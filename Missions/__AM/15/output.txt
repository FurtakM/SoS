// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38350 0 0
// InitNature ;
  19: CALL 38218 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12360 0 0
// PrepareRussian ;
  40: CALL 7323 0 0
// PrepareLegion ;
  44: CALL 4478 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17080 0 0
// MC_Start ( ) ;
  60: CALL 40530 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 125
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 126
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63326 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63419 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 62769 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62584 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63326 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63419 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62584 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 62769 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63199 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62247 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63326 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63419 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 130
 971: PUSH
 972: LD_EXP 130
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62584 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63326 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63419 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62476 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 63737 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 62908 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63199 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63199 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63531 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62584 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63150 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69058 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 73898 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 73898 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 73898 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 73898 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 73898 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69058 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69058 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69058 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69058 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 69058 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 69058 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 69058 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 69058 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 69058 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 69058 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 69058 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 69058 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 69058 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 69058 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 69058 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// extraSquad := [ ] ;
3222: LD_ADDR_EXP 62
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// tmp := [ ] ;
3229: LD_ADDR_VAR 0 5
3233: PUSH
3234: EMPTY
3235: ST_TO_ADDR
// if JMMGirl <> 2 then
3236: LD_EXP 7
3240: PUSH
3241: LD_INT 2
3243: NONEQUAL
3244: IFFALSE 3268
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 43
3250: PUSH
3251: LD_STRING Lisa
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 69058 0 3
3267: ST_TO_ADDR
// if Lisa then
3268: LD_EXP 43
3272: IFFALSE 3290
// tmp := tmp ^ Lisa ;
3274: LD_ADDR_VAR 0 5
3278: PUSH
3279: LD_VAR 0 5
3283: PUSH
3284: LD_EXP 43
3288: ADD
3289: ST_TO_ADDR
// if JMMGirl < 3 then
3290: LD_EXP 7
3294: PUSH
3295: LD_INT 3
3297: LESS
3298: IFFALSE 3329
// begin Connie := NewCharacter ( Coonie ) ;
3300: LD_ADDR_EXP 55
3304: PUSH
3305: LD_STRING Coonie
3307: PPUSH
3308: CALL_OW 25
3312: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3313: LD_ADDR_VAR 0 5
3317: PUSH
3318: LD_VAR 0 5
3322: PUSH
3323: LD_EXP 55
3327: ADD
3328: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3329: LD_ADDR_EXP 44
3333: PUSH
3334: LD_STRING Donaldson
3336: PPUSH
3337: LD_EXP 1
3341: NOT
3342: PPUSH
3343: LD_STRING 13s_
3345: PPUSH
3346: CALL 69058 0 3
3350: ST_TO_ADDR
// if Donaldson then
3351: LD_EXP 44
3355: IFFALSE 3373
// tmp := tmp ^ Donaldson ;
3357: LD_ADDR_VAR 0 5
3361: PUSH
3362: LD_VAR 0 5
3366: PUSH
3367: LD_EXP 44
3371: ADD
3372: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3373: LD_ADDR_EXP 45
3377: PUSH
3378: LD_STRING Bobby
3380: PPUSH
3381: LD_EXP 1
3385: NOT
3386: PPUSH
3387: LD_STRING 13s_
3389: PPUSH
3390: CALL 69058 0 3
3394: ST_TO_ADDR
// if Bobby then
3395: LD_EXP 45
3399: IFFALSE 3417
// tmp := tmp ^ Bobby ;
3401: LD_ADDR_VAR 0 5
3405: PUSH
3406: LD_VAR 0 5
3410: PUSH
3411: LD_EXP 45
3415: ADD
3416: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3417: LD_ADDR_EXP 46
3421: PUSH
3422: LD_STRING Cyrus
3424: PPUSH
3425: LD_EXP 1
3429: NOT
3430: PPUSH
3431: LD_STRING 13s_
3433: PPUSH
3434: CALL 69058 0 3
3438: ST_TO_ADDR
// if Cyrus then
3439: LD_EXP 46
3443: IFFALSE 3461
// tmp := tmp ^ Cyrus ;
3445: LD_ADDR_VAR 0 5
3449: PUSH
3450: LD_VAR 0 5
3454: PUSH
3455: LD_EXP 46
3459: ADD
3460: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3461: LD_ADDR_EXP 47
3465: PUSH
3466: LD_STRING Denis
3468: PPUSH
3469: LD_EXP 1
3473: NOT
3474: PPUSH
3475: LD_STRING 13s_
3477: PPUSH
3478: CALL 69058 0 3
3482: ST_TO_ADDR
// if not Denis then
3483: LD_EXP 47
3487: NOT
3488: IFFALSE 3512
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3490: LD_ADDR_EXP 47
3494: PUSH
3495: LD_STRING Denis
3497: PPUSH
3498: LD_EXP 1
3502: NOT
3503: PPUSH
3504: LD_STRING 13f_
3506: PPUSH
3507: CALL 69058 0 3
3511: ST_TO_ADDR
// if Denis then
3512: LD_EXP 47
3516: IFFALSE 3534
// tmp := tmp ^ Denis ;
3518: LD_ADDR_VAR 0 5
3522: PUSH
3523: LD_VAR 0 5
3527: PUSH
3528: LD_EXP 47
3532: ADD
3533: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3534: LD_ADDR_EXP 48
3538: PUSH
3539: LD_STRING Brown
3541: PPUSH
3542: LD_EXP 1
3546: NOT
3547: PPUSH
3548: LD_STRING 13s_
3550: PPUSH
3551: CALL 69058 0 3
3555: ST_TO_ADDR
// if Brown then
3556: LD_EXP 48
3560: IFFALSE 3578
// tmp := tmp ^ Brown ;
3562: LD_ADDR_VAR 0 5
3566: PUSH
3567: LD_VAR 0 5
3571: PUSH
3572: LD_EXP 48
3576: ADD
3577: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3578: LD_ADDR_EXP 49
3582: PUSH
3583: LD_STRING Gladstone
3585: PPUSH
3586: LD_EXP 1
3590: NOT
3591: PPUSH
3592: LD_STRING 13s_
3594: PPUSH
3595: CALL 69058 0 3
3599: ST_TO_ADDR
// if Gladstone then
3600: LD_EXP 49
3604: IFFALSE 3622
// tmp := tmp ^ Gladstone ;
3606: LD_ADDR_VAR 0 5
3610: PUSH
3611: LD_VAR 0 5
3615: PUSH
3616: LD_EXP 49
3620: ADD
3621: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3622: LD_ADDR_EXP 50
3626: PUSH
3627: LD_STRING Houten
3629: PPUSH
3630: LD_EXP 1
3634: NOT
3635: PPUSH
3636: LD_STRING 13s_
3638: PPUSH
3639: CALL 69058 0 3
3643: ST_TO_ADDR
// if Houten then
3644: LD_EXP 50
3648: IFFALSE 3666
// tmp := tmp ^ Houten ;
3650: LD_ADDR_VAR 0 5
3654: PUSH
3655: LD_VAR 0 5
3659: PUSH
3660: LD_EXP 50
3664: ADD
3665: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3666: LD_ADDR_EXP 51
3670: PUSH
3671: LD_STRING Cornel
3673: PPUSH
3674: LD_EXP 1
3678: NOT
3679: PPUSH
3680: LD_STRING 13s_
3682: PPUSH
3683: CALL 69058 0 3
3687: ST_TO_ADDR
// if Cornel then
3688: LD_EXP 51
3692: IFFALSE 3710
// tmp := tmp ^ Cornel ;
3694: LD_ADDR_VAR 0 5
3698: PUSH
3699: LD_VAR 0 5
3703: PUSH
3704: LD_EXP 51
3708: ADD
3709: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3710: LD_ADDR_EXP 52
3714: PUSH
3715: LD_STRING Gary
3717: PPUSH
3718: LD_EXP 1
3722: NOT
3723: PPUSH
3724: LD_STRING 13s_
3726: PPUSH
3727: CALL 69058 0 3
3731: ST_TO_ADDR
// if Gary then
3732: LD_EXP 52
3736: IFFALSE 3754
// tmp := tmp ^ Gary ;
3738: LD_ADDR_VAR 0 5
3742: PUSH
3743: LD_VAR 0 5
3747: PUSH
3748: LD_EXP 52
3752: ADD
3753: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3754: LD_ADDR_EXP 53
3758: PUSH
3759: LD_STRING Frank
3761: PPUSH
3762: LD_EXP 1
3766: NOT
3767: PPUSH
3768: LD_STRING 13s_
3770: PPUSH
3771: CALL 69058 0 3
3775: ST_TO_ADDR
// if Frank then
3776: LD_EXP 53
3780: IFFALSE 3798
// tmp := tmp ^ Frank ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_VAR 0 5
3791: PUSH
3792: LD_EXP 53
3796: ADD
3797: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3798: LD_ADDR_EXP 54
3802: PUSH
3803: LD_STRING Kikuchi
3805: PPUSH
3806: LD_EXP 1
3810: NOT
3811: PPUSH
3812: LD_STRING 13s_
3814: PPUSH
3815: CALL 69058 0 3
3819: ST_TO_ADDR
// if Kikuchi then
3820: LD_EXP 54
3824: IFFALSE 3842
// tmp := tmp ^ Kikuchi ;
3826: LD_ADDR_VAR 0 5
3830: PUSH
3831: LD_VAR 0 5
3835: PUSH
3836: LD_EXP 54
3840: ADD
3841: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3842: LD_ADDR_EXP 57
3846: PUSH
3847: LD_STRING Mike
3849: PPUSH
3850: LD_EXP 1
3854: NOT
3855: PPUSH
3856: LD_STRING 10c_
3858: PPUSH
3859: CALL 69058 0 3
3863: ST_TO_ADDR
// if Mike then
3864: LD_EXP 57
3868: IFFALSE 3891
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3870: LD_EXP 57
3874: PPUSH
3875: LD_INT 61
3877: PPUSH
3878: LD_INT 89
3880: PPUSH
3881: LD_INT 8
3883: PPUSH
3884: LD_INT 0
3886: PPUSH
3887: CALL_OW 50
// vip := tmp ;
3891: LD_ADDR_EXP 61
3895: PUSH
3896: LD_VAR 0 5
3900: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3901: LD_ADDR_VAR 0 5
3905: PUSH
3906: LD_VAR 0 5
3910: PUSH
3911: LD_STRING 13s_others
3913: PPUSH
3914: CALL_OW 31
3918: UNION
3919: ST_TO_ADDR
// if tmp < 18 then
3920: LD_VAR 0 5
3924: PUSH
3925: LD_INT 18
3927: LESS
3928: IFFALSE 4033
// begin InitHC_All ( ) ;
3930: CALL_OW 584
// for i = 1 to 18 - tmp do
3934: LD_ADDR_VAR 0 2
3938: PUSH
3939: DOUBLE
3940: LD_INT 1
3942: DEC
3943: ST_TO_ADDR
3944: LD_INT 18
3946: PUSH
3947: LD_VAR 0 5
3951: MINUS
3952: PUSH
3953: FOR_TO
3954: IFFALSE 4031
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3956: LD_INT 1
3958: PPUSH
3959: LD_VAR 0 2
3963: PUSH
3964: LD_INT 4
3966: MOD
3967: PUSH
3968: LD_INT 1
3970: PLUS
3971: PPUSH
3972: LD_INT 4
3974: PPUSH
3975: CALL_OW 380
// un := CreateHuman ;
3979: LD_ADDR_VAR 0 10
3983: PUSH
3984: CALL_OW 44
3988: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3989: LD_ADDR_VAR 0 5
3993: PUSH
3994: LD_VAR 0 5
3998: PPUSH
3999: LD_VAR 0 10
4003: PPUSH
4004: CALL 106760 0 2
4008: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4009: LD_ADDR_EXP 62
4013: PUSH
4014: LD_EXP 62
4018: PPUSH
4019: LD_VAR 0 10
4023: PPUSH
4024: CALL 106760 0 2
4028: ST_TO_ADDR
// end ;
4029: GO 3953
4031: POP
4032: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4033: LD_ADDR_VAR 0 6
4037: PUSH
4038: LD_INT 53
4040: PPUSH
4041: LD_INT 94
4043: PPUSH
4044: CALL_OW 428
4048: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4049: LD_ADDR_VAR 0 7
4053: PUSH
4054: LD_INT 56
4056: PPUSH
4057: LD_INT 101
4059: PPUSH
4060: CALL_OW 428
4064: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4065: LD_ADDR_VAR 0 8
4069: PUSH
4070: LD_INT 67
4072: PPUSH
4073: LD_INT 101
4075: PPUSH
4076: CALL_OW 428
4080: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4081: LD_ADDR_VAR 0 9
4085: PUSH
4086: LD_INT 54
4088: PPUSH
4089: LD_INT 85
4091: PPUSH
4092: CALL_OW 428
4096: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4097: LD_ADDR_VAR 0 3
4101: PUSH
4102: LD_VAR 0 8
4106: PUSH
4107: LD_VAR 0 6
4111: PUSH
4112: LD_VAR 0 9
4116: PUSH
4117: LD_VAR 0 7
4121: PUSH
4122: EMPTY
4123: LIST
4124: LIST
4125: LIST
4126: LIST
4127: ST_TO_ADDR
// for i in tmp do
4128: LD_ADDR_VAR 0 2
4132: PUSH
4133: LD_VAR 0 5
4137: PUSH
4138: FOR_IN
4139: IFFALSE 4334
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4141: LD_VAR 0 3
4145: PUSH
4146: LD_INT 1
4148: ARRAY
4149: PPUSH
4150: CALL_OW 266
4154: PUSH
4155: LD_INT 4
4157: DOUBLE
4158: EQUAL
4159: IFTRUE 4163
4161: GO 4178
4163: POP
// SetClass ( i , class_soldier ) ; b_depot :
4164: LD_VAR 0 2
4168: PPUSH
4169: LD_INT 1
4171: PPUSH
4172: CALL_OW 336
4176: GO 4248
4178: LD_INT 0
4180: DOUBLE
4181: EQUAL
4182: IFTRUE 4186
4184: GO 4201
4186: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4187: LD_VAR 0 2
4191: PPUSH
4192: LD_INT 2
4194: PPUSH
4195: CALL_OW 336
4199: GO 4248
4201: LD_INT 2
4203: DOUBLE
4204: EQUAL
4205: IFTRUE 4209
4207: GO 4224
4209: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4210: LD_VAR 0 2
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 336
4222: GO 4248
4224: LD_INT 6
4226: DOUBLE
4227: EQUAL
4228: IFTRUE 4232
4230: GO 4247
4232: POP
// SetClass ( i , class_scientistic ) ; end ;
4233: LD_VAR 0 2
4237: PPUSH
4238: LD_INT 4
4240: PPUSH
4241: CALL_OW 336
4245: GO 4248
4247: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4248: LD_VAR 0 3
4252: PUSH
4253: LD_INT 1
4255: ARRAY
4256: PPUSH
4257: CALL_OW 313
4261: PUSH
4262: LD_INT 6
4264: EQUAL
4265: IFFALSE 4285
// b := Delete ( b , 1 ) ;
4267: LD_ADDR_VAR 0 3
4271: PUSH
4272: LD_VAR 0 3
4276: PPUSH
4277: LD_INT 1
4279: PPUSH
4280: CALL_OW 3
4284: ST_TO_ADDR
// if b then
4285: LD_VAR 0 3
4289: IFFALSE 4311
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4291: LD_VAR 0 2
4295: PPUSH
4296: LD_VAR 0 3
4300: PUSH
4301: LD_INT 1
4303: ARRAY
4304: PPUSH
4305: CALL_OW 52
4309: GO 4332
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4311: LD_VAR 0 2
4315: PPUSH
4316: LD_INT 61
4318: PPUSH
4319: LD_INT 89
4321: PPUSH
4322: LD_INT 8
4324: PPUSH
4325: LD_INT 0
4327: PPUSH
4328: CALL_OW 50
// end ;
4332: GO 4138
4334: POP
4335: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4336: LD_INT 2
4338: PPUSH
4339: LD_INT 1
4341: PPUSH
4342: LD_INT 1
4344: PPUSH
4345: LD_INT 12
4347: PPUSH
4348: LD_INT 100
4350: PPUSH
4351: CALL 73898 0 5
// veh := CreateVehicle ;
4355: LD_ADDR_VAR 0 4
4359: PUSH
4360: CALL_OW 45
4364: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4365: LD_VAR 0 4
4369: PPUSH
4370: LD_INT 4
4372: PPUSH
4373: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4377: LD_VAR 0 4
4381: PPUSH
4382: LD_INT 49
4384: PPUSH
4385: LD_INT 88
4387: PPUSH
4388: LD_INT 0
4390: PPUSH
4391: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4395: LD_VAR 0 4
4399: PPUSH
4400: LD_INT 1
4402: PPUSH
4403: LD_INT 100
4405: PPUSH
4406: CALL_OW 290
// uc_side := 0 ;
4410: LD_ADDR_OWVAR 20
4414: PUSH
4415: LD_INT 0
4417: ST_TO_ADDR
// uc_nation := 0 ;
4418: LD_ADDR_OWVAR 21
4422: PUSH
4423: LD_INT 0
4425: ST_TO_ADDR
// for i := 1 to 3 do
4426: LD_ADDR_VAR 0 2
4430: PUSH
4431: DOUBLE
4432: LD_INT 1
4434: DEC
4435: ST_TO_ADDR
4436: LD_INT 3
4438: PUSH
4439: FOR_TO
4440: IFFALSE 4471
// begin InitHc ;
4442: CALL_OW 19
// hc_class := class_apeman ;
4446: LD_ADDR_OWVAR 28
4450: PUSH
4451: LD_INT 12
4453: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4454: CALL_OW 44
4458: PPUSH
4459: LD_INT 13
4461: PPUSH
4462: LD_INT 0
4464: PPUSH
4465: CALL_OW 49
// end ;
4469: GO 4439
4471: POP
4472: POP
// end ; end_of_file
4473: LD_VAR 0 1
4477: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
// side := 8 ;
4485: LD_ADDR_VAR 0 3
4489: PUSH
4490: LD_INT 8
4492: ST_TO_ADDR
// uc_side := side ;
4493: LD_ADDR_OWVAR 20
4497: PUSH
4498: LD_VAR 0 3
4502: ST_TO_ADDR
// uc_nation := 2 ;
4503: LD_ADDR_OWVAR 21
4507: PUSH
4508: LD_INT 2
4510: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4511: LD_ADDR_VAR 0 2
4515: PUSH
4516: LD_INT 22
4518: PUSH
4519: LD_VAR 0 3
4523: PUSH
4524: EMPTY
4525: LIST
4526: LIST
4527: PUSH
4528: LD_INT 21
4530: PUSH
4531: LD_INT 3
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: CALL_OW 69
4546: PUSH
4547: FOR_IN
4548: IFFALSE 4564
// SetBLevel ( i , 10 ) ;
4550: LD_VAR 0 2
4554: PPUSH
4555: LD_INT 10
4557: PPUSH
4558: CALL_OW 241
4562: GO 4547
4564: POP
4565: POP
// if KurtStatus then
4566: LD_EXP 3
4570: IFFALSE 4593
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4572: LD_ADDR_EXP 63
4576: PUSH
4577: LD_STRING Kurt
4579: PPUSH
4580: LD_INT 0
4582: PPUSH
4583: LD_STRING 
4585: PPUSH
4586: CALL 69058 0 3
4590: ST_TO_ADDR
4591: GO 4615
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4593: LD_ADDR_EXP 63
4597: PUSH
4598: LD_STRING AltKurt
4600: PPUSH
4601: LD_EXP 1
4605: NOT
4606: PPUSH
4607: LD_STRING 
4609: PPUSH
4610: CALL 69058 0 3
4614: ST_TO_ADDR
// if not Kurt then
4615: LD_EXP 63
4619: NOT
4620: IFFALSE 4646
// begin InitHc ;
4622: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4626: LD_INT 1
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 381
// Kurt := CreateHuman ;
4636: LD_ADDR_EXP 63
4640: PUSH
4641: CALL_OW 44
4645: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4646: LD_EXP 63
4650: PPUSH
4651: LD_INT 324
4653: PPUSH
4654: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4658: LD_ADDR_EXP 64
4662: PUSH
4663: LD_STRING Kozlov
4665: PPUSH
4666: LD_INT 0
4668: PPUSH
4669: LD_STRING 
4671: PPUSH
4672: CALL 69058 0 3
4676: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4677: LD_EXP 64
4681: PPUSH
4682: LD_INT 22
4684: PUSH
4685: LD_INT 8
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 23
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 30
4704: PUSH
4705: LD_INT 8
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: EMPTY
4713: LIST
4714: LIST
4715: LIST
4716: PPUSH
4717: CALL_OW 69
4721: PUSH
4722: LD_INT 1
4724: ARRAY
4725: PPUSH
4726: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4730: LD_EXP 64
4734: PPUSH
4735: LD_INT 3
4737: PPUSH
4738: LD_INT 10
4740: PPUSH
4741: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4745: LD_EXP 64
4749: PPUSH
4750: LD_INT 4
4752: PPUSH
4753: LD_INT 10
4755: PPUSH
4756: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4760: LD_ADDR_VAR 0 5
4764: PUSH
4765: LD_INT 22
4767: PUSH
4768: LD_VAR 0 3
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: PUSH
4777: LD_INT 30
4779: PUSH
4780: LD_INT 32
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 58
4789: PUSH
4790: EMPTY
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: ST_TO_ADDR
// for i = 1 to 10 do
4803: LD_ADDR_VAR 0 2
4807: PUSH
4808: DOUBLE
4809: LD_INT 1
4811: DEC
4812: ST_TO_ADDR
4813: LD_INT 10
4815: PUSH
4816: FOR_TO
4817: IFFALSE 4889
// begin uc_nation := nation_nature ;
4819: LD_ADDR_OWVAR 21
4823: PUSH
4824: LD_INT 0
4826: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4827: LD_ADDR_OWVAR 28
4831: PUSH
4832: LD_INT 15
4834: ST_TO_ADDR
// hc_gallery :=  ;
4835: LD_ADDR_OWVAR 33
4839: PUSH
4840: LD_STRING 
4842: ST_TO_ADDR
// hc_name :=  ;
4843: LD_ADDR_OWVAR 26
4847: PUSH
4848: LD_STRING 
4850: ST_TO_ADDR
// un := CreateHuman ;
4851: LD_ADDR_VAR 0 4
4855: PUSH
4856: CALL_OW 44
4860: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4861: LD_VAR 0 4
4865: PPUSH
4866: LD_VAR 0 5
4870: PUSH
4871: LD_VAR 0 5
4875: PUSH
4876: LD_VAR 0 2
4880: MINUS
4881: ARRAY
4882: PPUSH
4883: CALL_OW 52
// end ;
4887: GO 4816
4889: POP
4890: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4891: LD_ADDR_VAR 0 5
4895: PUSH
4896: LD_STRING 12_kurt_squad
4898: PPUSH
4899: CALL_OW 31
4903: ST_TO_ADDR
// if tmp then
4904: LD_VAR 0 5
4908: IFFALSE 4942
// for i in tmp do
4910: LD_ADDR_VAR 0 2
4914: PUSH
4915: LD_VAR 0 5
4919: PUSH
4920: FOR_IN
4921: IFFALSE 4940
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4923: LD_VAR 0 2
4927: PPUSH
4928: LD_INT 5
4930: PPUSH
4931: LD_INT 0
4933: PPUSH
4934: CALL_OW 49
4938: GO 4920
4940: POP
4941: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4942: LD_INT 324
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: LD_STRING 
4950: PPUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: LD_INT 10
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PPUSH
4975: LD_INT 3000
4977: PUSH
4978: LD_INT 500
4980: PUSH
4981: LD_INT 150
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: LIST
4988: PPUSH
4989: LD_INT 16
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 6
4997: PUSH
4998: LD_INT 8
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PPUSH
5007: CALL 77719 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5011: LD_ADDR_EXP 101
5015: PUSH
5016: LD_EXP 101
5020: PPUSH
5021: LD_INT 3
5023: PPUSH
5024: LD_INT 22
5026: PUSH
5027: LD_VAR 0 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 23
5038: PUSH
5039: LD_INT 2
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: PUSH
5046: LD_INT 3
5048: PUSH
5049: LD_INT 21
5051: PUSH
5052: LD_INT 2
5054: PUSH
5055: EMPTY
5056: LIST
5057: LIST
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: PUSH
5063: EMPTY
5064: LIST
5065: LIST
5066: LIST
5067: PPUSH
5068: CALL_OW 69
5072: PUSH
5073: LD_EXP 63
5077: DIFF
5078: PPUSH
5079: CALL_OW 1
5083: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5084: LD_INT 1
5086: PPUSH
5087: LD_INT 7
5089: PPUSH
5090: CALL_OW 383
// hc_name := Ali Hadrach ;
5094: LD_ADDR_OWVAR 26
5098: PUSH
5099: LD_STRING Ali Hadrach
5101: ST_TO_ADDR
// hc_face_number := 31 ;
5102: LD_ADDR_OWVAR 34
5106: PUSH
5107: LD_INT 31
5109: ST_TO_ADDR
// Friend := CreateHuman ;
5110: LD_ADDR_EXP 65
5114: PUSH
5115: CALL_OW 44
5119: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5120: LD_INT 14
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: LD_INT 1
5128: PPUSH
5129: LD_INT 29
5131: PPUSH
5132: LD_INT 100
5134: PPUSH
5135: CALL 73898 0 5
// powellBomb := CreateVehicle ;
5139: LD_ADDR_EXP 66
5143: PUSH
5144: CALL_OW 45
5148: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5149: LD_EXP 66
5153: PPUSH
5154: LD_INT 90
5156: PPUSH
5157: LD_INT 51
5159: PPUSH
5160: LD_INT 0
5162: PPUSH
5163: CALL_OW 48
// end ;
5167: LD_VAR 0 1
5171: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5172: LD_INT 0
5174: PPUSH
5175: PPUSH
5176: PPUSH
// if IsLive ( kozlov_fac ) then
5177: LD_INT 332
5179: PPUSH
5180: CALL_OW 300
5184: IFFALSE 5188
// exit ;
5186: GO 5755
// ComExitBuilding ( Kozlov ) ;
5188: LD_EXP 64
5192: PPUSH
5193: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5197: LD_EXP 64
5201: PPUSH
5202: CALL_OW 257
5206: PUSH
5207: LD_INT 2
5209: NONEQUAL
5210: IFFALSE 5245
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5212: LD_EXP 64
5216: PPUSH
5217: LD_INT 324
5219: PPUSH
5220: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5224: LD_EXP 64
5228: PPUSH
5229: LD_INT 2
5231: PPUSH
5232: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5236: LD_EXP 64
5240: PPUSH
5241: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5245: LD_EXP 64
5249: PPUSH
5250: LD_INT 2
5252: PPUSH
5253: LD_INT 93
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 3
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 30
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 23
5295: PUSH
5296: LD_INT 3
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5321: LD_ADDR_VAR 0 2
5325: PUSH
5326: LD_INT 22
5328: PUSH
5329: LD_INT 8
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: PUSH
5336: LD_INT 30
5338: PUSH
5339: LD_INT 3
5341: PUSH
5342: EMPTY
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 23
5348: PUSH
5349: LD_INT 3
5351: PUSH
5352: EMPTY
5353: LIST
5354: LIST
5355: PUSH
5356: LD_INT 57
5358: PUSH
5359: EMPTY
5360: LIST
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: LIST
5367: PPUSH
5368: CALL_OW 69
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5377: LD_INT 22
5379: PUSH
5380: LD_INT 8
5382: PUSH
5383: EMPTY
5384: LIST
5385: LIST
5386: PUSH
5387: LD_INT 23
5389: PUSH
5390: LD_INT 3
5392: PUSH
5393: EMPTY
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 30
5399: PUSH
5400: LD_INT 21
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: LIST
5411: PPUSH
5412: CALL_OW 69
5416: NOT
5417: IFFALSE 5495
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5419: LD_EXP 64
5423: PPUSH
5424: LD_INT 21
5426: PPUSH
5427: LD_INT 97
5429: PPUSH
5430: LD_INT 36
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5440: LD_INT 35
5442: PPUSH
5443: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5447: LD_INT 22
5449: PUSH
5450: LD_INT 8
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PUSH
5457: LD_INT 23
5459: PUSH
5460: LD_INT 3
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PUSH
5467: LD_INT 30
5469: PUSH
5470: LD_INT 21
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 57
5479: PUSH
5480: EMPTY
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: LIST
5487: LIST
5488: PPUSH
5489: CALL_OW 69
5493: IFFALSE 5440
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5495: LD_INT 22
5497: PUSH
5498: LD_INT 8
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: PUSH
5505: LD_INT 23
5507: PUSH
5508: LD_INT 3
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PUSH
5515: LD_INT 30
5517: PUSH
5518: LD_INT 18
5520: PUSH
5521: EMPTY
5522: LIST
5523: LIST
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL_OW 69
5534: NOT
5535: IFFALSE 5613
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5537: LD_EXP 64
5541: PPUSH
5542: LD_INT 18
5544: PPUSH
5545: LD_INT 89
5547: PPUSH
5548: LD_INT 32
5550: PPUSH
5551: LD_INT 1
5553: PPUSH
5554: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5558: LD_INT 35
5560: PPUSH
5561: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5565: LD_INT 22
5567: PUSH
5568: LD_INT 8
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: PUSH
5575: LD_INT 23
5577: PUSH
5578: LD_INT 3
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: PUSH
5585: LD_INT 30
5587: PUSH
5588: LD_INT 18
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 57
5597: PUSH
5598: EMPTY
5599: LIST
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PPUSH
5607: CALL_OW 69
5611: IFFALSE 5558
// end ; lab := kozlov_lab ;
5613: LD_ADDR_VAR 0 3
5617: PUSH
5618: LD_INT 336
5620: ST_TO_ADDR
// if not lab then
5621: LD_VAR 0 3
5625: NOT
5626: IFFALSE 5630
// exit ;
5628: GO 5755
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5630: LD_EXP 64
5634: PPUSH
5635: LD_VAR 0 3
5639: PUSH
5640: LD_INT 1
5642: ARRAY
5643: PPUSH
5644: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5648: LD_EXP 64
5652: PPUSH
5653: LD_INT 4
5655: PPUSH
5656: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5660: LD_VAR 0 3
5664: PUSH
5665: LD_INT 1
5667: ARRAY
5668: PPUSH
5669: LD_INT 25
5671: PPUSH
5672: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5676: LD_INT 35
5678: PPUSH
5679: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5683: LD_INT 25
5685: PPUSH
5686: LD_INT 8
5688: PPUSH
5689: CALL_OW 321
5693: PUSH
5694: LD_INT 2
5696: EQUAL
5697: IFFALSE 5676
// ComExitBuilding ( Kozlov ) ;
5699: LD_EXP 64
5703: PPUSH
5704: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5708: LD_EXP 64
5712: PPUSH
5713: LD_VAR 0 2
5717: PPUSH
5718: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5722: LD_EXP 64
5726: PPUSH
5727: LD_INT 3
5729: PPUSH
5730: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5734: LD_VAR 0 2
5738: PPUSH
5739: LD_INT 23
5741: PPUSH
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 1
5747: PPUSH
5748: LD_INT 48
5750: PPUSH
5751: CALL_OW 125
// end ;
5755: LD_VAR 0 1
5759: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5760: LD_EXP 22
5764: NOT
5765: PUSH
5766: LD_EXP 15
5770: PUSH
5771: LD_INT 6
5773: GREATEREQUAL
5774: AND
5775: IFFALSE 5856
5777: GO 5779
5779: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5780: LD_INT 3
5782: PPUSH
5783: LD_INT 3
5785: PPUSH
5786: CALL 62769 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 14
5795: PUSH
5796: LD_INT 1
5798: PUSH
5799: LD_INT 1
5801: PUSH
5802: LD_INT 28
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: LIST
5809: LIST
5810: PUSH
5811: LD_INT 14
5813: PUSH
5814: LD_INT 1
5816: PUSH
5817: LD_INT 1
5819: PUSH
5820: LD_INT 28
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 14
5831: PUSH
5832: LD_INT 1
5834: PUSH
5835: LD_INT 1
5837: PUSH
5838: LD_INT 28
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: LIST
5851: PPUSH
5852: CALL 62632 0 2
// end ;
5856: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5857: LD_EXP 22
5861: NOT
5862: PUSH
5863: LD_EXP 15
5867: PUSH
5868: LD_INT 6
5870: GREATEREQUAL
5871: AND
5872: PUSH
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 64050 0 2
5883: NOT
5884: AND
5885: IFFALSE 6759
5887: GO 5889
5889: DISABLE
5890: LD_INT 0
5892: PPUSH
5893: PPUSH
5894: PPUSH
// begin enable ;
5895: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5896: LD_INT 22
5898: PUSH
5899: LD_INT 8
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 23
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 30
5918: PUSH
5919: LD_INT 3
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: LIST
5930: PPUSH
5931: CALL_OW 69
5935: NOT
5936: IFFALSE 5940
// exit ;
5938: GO 6759
// if Prob ( 40 ) then
5940: LD_INT 40
5942: PPUSH
5943: CALL_OW 13
5947: IFFALSE 6074
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5949: LD_INT 3
5951: PPUSH
5952: LD_INT 14
5954: PUSH
5955: LD_INT 1
5957: PUSH
5958: LD_INT 2
5960: PUSH
5961: LD_INT 28
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: LIST
5968: LIST
5969: PUSH
5970: LD_INT 14
5972: PUSH
5973: LD_INT 1
5975: PUSH
5976: LD_INT 2
5978: PUSH
5979: LD_INT 28
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: PUSH
5988: LD_INT 14
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: LD_INT 2
5996: PUSH
5997: LD_INT 28
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: LIST
6004: LIST
6005: PUSH
6006: LD_INT 14
6008: PUSH
6009: LD_INT 1
6011: PUSH
6012: LD_INT 2
6014: PUSH
6015: LD_INT 28
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: PUSH
6024: LD_INT 14
6026: PUSH
6027: LD_INT 1
6029: PUSH
6030: LD_INT 2
6032: PUSH
6033: LD_INT 28
6035: PUSH
6036: EMPTY
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: PUSH
6042: LD_INT 14
6044: PUSH
6045: LD_INT 1
6047: PUSH
6048: LD_INT 2
6050: PUSH
6051: LD_INT 26
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: LIST
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL 62632 0 2
// end else
6072: GO 6281
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6074: LD_INT 3
6076: PPUSH
6077: LD_INT 14
6079: PUSH
6080: LD_INT 1
6082: PUSH
6083: LD_INT 2
6085: PUSH
6086: LD_INT 27
6088: PUSH
6089: LD_INT 26
6091: PUSH
6092: LD_INT 26
6094: PUSH
6095: LD_INT 28
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: LIST
6102: LIST
6103: PUSH
6104: LD_OWVAR 67
6108: ARRAY
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: PUSH
6116: LD_INT 14
6118: PUSH
6119: LD_INT 1
6121: PUSH
6122: LD_INT 2
6124: PUSH
6125: LD_INT 27
6127: PUSH
6128: LD_INT 26
6130: PUSH
6131: LD_INT 26
6133: PUSH
6134: LD_INT 26
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: LD_OWVAR 67
6147: ARRAY
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 14
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: LD_INT 26
6166: PUSH
6167: LD_INT 26
6169: PUSH
6170: LD_INT 29
6172: PUSH
6173: LD_INT 29
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PUSH
6182: LD_OWVAR 67
6186: ARRAY
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: LD_INT 13
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: LD_INT 2
6202: PUSH
6203: LD_INT 26
6205: PUSH
6206: LD_INT 29
6208: PUSH
6209: LD_INT 29
6211: PUSH
6212: LD_INT 29
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: LIST
6219: LIST
6220: PUSH
6221: LD_OWVAR 67
6225: ARRAY
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 13
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 29
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 62632 0 2
// end ; repeat wait ( 0 0$1 ) ;
6281: LD_INT 35
6283: PPUSH
6284: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6288: LD_INT 3
6290: PPUSH
6291: LD_INT 1
6293: PPUSH
6294: CALL 64050 0 2
6298: PUSH
6299: LD_INT 6
6301: GREATEREQUAL
6302: IFFALSE 6281
// wait ( 0 0$30 ) ;
6304: LD_INT 1050
6306: PPUSH
6307: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6311: LD_ADDR_VAR 0 2
6315: PUSH
6316: LD_INT 3
6318: PPUSH
6319: LD_INT 1
6321: PPUSH
6322: CALL 64050 0 2
6326: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6327: LD_ADDR_EXP 120
6331: PUSH
6332: LD_EXP 120
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_EXP 120
6344: PUSH
6345: LD_INT 3
6347: ARRAY
6348: PUSH
6349: LD_VAR 0 2
6353: DIFF
6354: PPUSH
6355: CALL_OW 1
6359: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6360: LD_ADDR_VAR 0 3
6364: PUSH
6365: LD_INT 0
6367: PPUSH
6368: LD_INT 2
6370: PPUSH
6371: CALL_OW 12
6375: ST_TO_ADDR
// if target then
6376: LD_VAR 0 3
6380: IFFALSE 6517
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6382: LD_ADDR_VAR 0 2
6386: PUSH
6387: LD_VAR 0 2
6391: PPUSH
6392: LD_INT 24
6394: PUSH
6395: LD_INT 250
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 72
6406: ST_TO_ADDR
// if not tmp then
6407: LD_VAR 0 2
6411: NOT
6412: IFFALSE 6416
// break ;
6414: GO 6515
// for i in tmp do
6416: LD_ADDR_VAR 0 1
6420: PUSH
6421: LD_VAR 0 2
6425: PUSH
6426: FOR_IN
6427: IFFALSE 6467
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6429: LD_VAR 0 1
6433: PPUSH
6434: LD_INT 89
6436: PPUSH
6437: LD_INT 71
6439: PPUSH
6440: CALL_OW 297
6444: PUSH
6445: LD_INT 9
6447: GREATER
6448: IFFALSE 6465
// ComMoveXY ( i , 89 , 71 ) ;
6450: LD_VAR 0 1
6454: PPUSH
6455: LD_INT 89
6457: PPUSH
6458: LD_INT 71
6460: PPUSH
6461: CALL_OW 111
6465: GO 6426
6467: POP
6468: POP
// wait ( 0 0$1 ) ;
6469: LD_INT 35
6471: PPUSH
6472: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6476: LD_VAR 0 2
6480: PPUSH
6481: LD_INT 92
6483: PUSH
6484: LD_INT 89
6486: PUSH
6487: LD_INT 71
6489: PUSH
6490: LD_INT 9
6492: PUSH
6493: EMPTY
6494: LIST
6495: LIST
6496: LIST
6497: LIST
6498: PPUSH
6499: CALL_OW 72
6503: PUSH
6504: LD_VAR 0 2
6508: PUSH
6509: LD_INT 1
6511: MINUS
6512: GREATEREQUAL
6513: IFFALSE 6382
// end else
6515: GO 6650
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6517: LD_ADDR_VAR 0 2
6521: PUSH
6522: LD_VAR 0 2
6526: PPUSH
6527: LD_INT 24
6529: PUSH
6530: LD_INT 250
6532: PUSH
6533: EMPTY
6534: LIST
6535: LIST
6536: PPUSH
6537: CALL_OW 72
6541: ST_TO_ADDR
// if not tmp then
6542: LD_VAR 0 2
6546: NOT
6547: IFFALSE 6551
// break ;
6549: GO 6650
// for i in tmp do
6551: LD_ADDR_VAR 0 1
6555: PUSH
6556: LD_VAR 0 2
6560: PUSH
6561: FOR_IN
6562: IFFALSE 6602
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6564: LD_VAR 0 1
6568: PPUSH
6569: LD_INT 125
6571: PPUSH
6572: LD_INT 129
6574: PPUSH
6575: CALL_OW 297
6579: PUSH
6580: LD_INT 9
6582: GREATER
6583: IFFALSE 6600
// ComMoveXY ( i , 125 , 129 ) ;
6585: LD_VAR 0 1
6589: PPUSH
6590: LD_INT 125
6592: PPUSH
6593: LD_INT 129
6595: PPUSH
6596: CALL_OW 111
6600: GO 6561
6602: POP
6603: POP
// wait ( 0 0$1 ) ;
6604: LD_INT 35
6606: PPUSH
6607: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6611: LD_VAR 0 2
6615: PPUSH
6616: LD_INT 92
6618: PUSH
6619: LD_INT 125
6621: PUSH
6622: LD_INT 129
6624: PUSH
6625: LD_INT 9
6627: PUSH
6628: EMPTY
6629: LIST
6630: LIST
6631: LIST
6632: LIST
6633: PPUSH
6634: CALL_OW 72
6638: PUSH
6639: LD_VAR 0 2
6643: PUSH
6644: LD_INT 1
6646: MINUS
6647: GREATEREQUAL
6648: IFFALSE 6517
// end ; repeat wait ( 0 0$1 ) ;
6650: LD_INT 35
6652: PPUSH
6653: CALL_OW 67
// for i in tmp do
6657: LD_ADDR_VAR 0 1
6661: PUSH
6662: LD_VAR 0 2
6666: PUSH
6667: FOR_IN
6668: IFFALSE 6750
// begin if GetLives ( i ) > 251 then
6670: LD_VAR 0 1
6674: PPUSH
6675: CALL_OW 256
6679: PUSH
6680: LD_INT 251
6682: GREATER
6683: IFFALSE 6721
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6685: LD_VAR 0 1
6689: PPUSH
6690: LD_INT 81
6692: PUSH
6693: LD_INT 8
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: PPUSH
6700: CALL_OW 69
6704: PPUSH
6705: LD_VAR 0 1
6709: PPUSH
6710: CALL_OW 74
6714: PPUSH
6715: CALL_OW 115
6719: GO 6748
// if IsDead ( i ) then
6721: LD_VAR 0 1
6725: PPUSH
6726: CALL_OW 301
6730: IFFALSE 6748
// tmp := tmp diff i ;
6732: LD_ADDR_VAR 0 2
6736: PUSH
6737: LD_VAR 0 2
6741: PUSH
6742: LD_VAR 0 1
6746: DIFF
6747: ST_TO_ADDR
// end ;
6748: GO 6667
6750: POP
6751: POP
// until not tmp ;
6752: LD_VAR 0 2
6756: NOT
6757: IFFALSE 6650
// end ;
6759: PPOPN 3
6761: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6762: LD_EXP 22
6766: NOT
6767: PUSH
6768: LD_EXP 15
6772: PUSH
6773: LD_INT 6
6775: GREATEREQUAL
6776: AND
6777: PUSH
6778: LD_OWVAR 67
6782: PUSH
6783: LD_INT 1
6785: GREATER
6786: AND
6787: IFFALSE 7320
6789: GO 6791
6791: DISABLE
6792: LD_INT 0
6794: PPUSH
6795: PPUSH
6796: PPUSH
// begin enable ;
6797: ENABLE
// tmp := [ ] ;
6798: LD_ADDR_VAR 0 3
6802: PUSH
6803: EMPTY
6804: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6805: LD_ADDR_VAR 0 1
6809: PUSH
6810: DOUBLE
6811: LD_INT 1
6813: DEC
6814: ST_TO_ADDR
6815: LD_INT 4
6817: PUSH
6818: LD_INT 6
6820: PUSH
6821: LD_INT 7
6823: PUSH
6824: LD_INT 8
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: LIST
6831: LIST
6832: PUSH
6833: LD_OWVAR 67
6837: ARRAY
6838: PUSH
6839: FOR_TO
6840: IFFALSE 7000
// begin uc_side := 8 ;
6842: LD_ADDR_OWVAR 20
6846: PUSH
6847: LD_INT 8
6849: ST_TO_ADDR
// uc_nation := 2 ;
6850: LD_ADDR_OWVAR 21
6854: PUSH
6855: LD_INT 2
6857: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6858: LD_INT 13
6860: PUSH
6861: LD_INT 14
6863: PUSH
6864: EMPTY
6865: LIST
6866: LIST
6867: PUSH
6868: LD_INT 1
6870: PPUSH
6871: LD_INT 2
6873: PPUSH
6874: CALL_OW 12
6878: ARRAY
6879: PPUSH
6880: LD_INT 1
6882: PPUSH
6883: LD_INT 5
6885: PPUSH
6886: LD_INT 27
6888: PUSH
6889: LD_INT 28
6891: PUSH
6892: LD_INT 26
6894: PUSH
6895: LD_INT 25
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 1
6906: PPUSH
6907: LD_INT 4
6909: PPUSH
6910: CALL_OW 12
6914: ARRAY
6915: PPUSH
6916: LD_INT 88
6918: PPUSH
6919: CALL 73898 0 5
// un := CreateVehicle ;
6923: LD_ADDR_VAR 0 2
6927: PUSH
6928: CALL_OW 45
6932: ST_TO_ADDR
// tmp := tmp ^ un ;
6933: LD_ADDR_VAR 0 3
6937: PUSH
6938: LD_VAR 0 3
6942: PUSH
6943: LD_VAR 0 2
6947: ADD
6948: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6949: LD_VAR 0 2
6953: PPUSH
6954: LD_INT 3
6956: PPUSH
6957: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6961: LD_VAR 0 2
6965: PPUSH
6966: LD_INT 30
6968: PPUSH
6969: LD_INT 0
6971: PPUSH
6972: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6976: LD_VAR 0 2
6980: PPUSH
6981: LD_INT 16
6983: PPUSH
6984: LD_INT 11
6986: PPUSH
6987: CALL_OW 111
// wait ( 0 0$2 ) ;
6991: LD_INT 70
6993: PPUSH
6994: CALL_OW 67
// end ;
6998: GO 6839
7000: POP
7001: POP
// for i = 1 to Difficulty do
7002: LD_ADDR_VAR 0 1
7006: PUSH
7007: DOUBLE
7008: LD_INT 1
7010: DEC
7011: ST_TO_ADDR
7012: LD_OWVAR 67
7016: PUSH
7017: FOR_TO
7018: IFFALSE 7147
// begin uc_side := 8 ;
7020: LD_ADDR_OWVAR 20
7024: PUSH
7025: LD_INT 8
7027: ST_TO_ADDR
// uc_nation := 2 ;
7028: LD_ADDR_OWVAR 21
7032: PUSH
7033: LD_INT 2
7035: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7036: LD_INT 0
7038: PPUSH
7039: LD_INT 8
7041: PPUSH
7042: LD_INT 8
7044: PUSH
7045: LD_INT 8
7047: PUSH
7048: LD_INT 9
7050: PUSH
7051: LD_INT 10
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: LIST
7058: LIST
7059: PUSH
7060: LD_OWVAR 67
7064: ARRAY
7065: PPUSH
7066: CALL_OW 380
// un := CreateHuman ;
7070: LD_ADDR_VAR 0 2
7074: PUSH
7075: CALL_OW 44
7079: ST_TO_ADDR
// tmp := tmp ^ un ;
7080: LD_ADDR_VAR 0 3
7084: PUSH
7085: LD_VAR 0 3
7089: PUSH
7090: LD_VAR 0 2
7094: ADD
7095: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7096: LD_VAR 0 2
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7108: LD_VAR 0 2
7112: PPUSH
7113: LD_INT 30
7115: PPUSH
7116: LD_INT 0
7118: PPUSH
7119: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7123: LD_VAR 0 2
7127: PPUSH
7128: LD_INT 16
7130: PPUSH
7131: LD_INT 11
7133: PPUSH
7134: CALL_OW 111
// wait ( 0 0$2 ) ;
7138: LD_INT 70
7140: PPUSH
7141: CALL_OW 67
// end ;
7145: GO 7017
7147: POP
7148: POP
// repeat wait ( 0 0$1 ) ;
7149: LD_INT 35
7151: PPUSH
7152: CALL_OW 67
// if legionDestroyed then
7156: LD_EXP 22
7160: IFFALSE 7164
// exit ;
7162: GO 7320
// for i in tmp do
7164: LD_ADDR_VAR 0 1
7168: PUSH
7169: LD_VAR 0 3
7173: PUSH
7174: FOR_IN
7175: IFFALSE 7311
// begin if GetLives ( i ) > 250 then
7177: LD_VAR 0 1
7181: PPUSH
7182: CALL_OW 256
7186: PUSH
7187: LD_INT 250
7189: GREATER
7190: IFFALSE 7282
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7192: LD_INT 81
7194: PUSH
7195: LD_INT 8
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: LD_INT 91
7204: PUSH
7205: LD_VAR 0 1
7209: PUSH
7210: LD_INT 10
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: LIST
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PPUSH
7222: CALL_OW 69
7226: NOT
7227: IFFALSE 7246
// ComAgressiveMove ( i , 67 , 110 ) else
7229: LD_VAR 0 1
7233: PPUSH
7234: LD_INT 67
7236: PPUSH
7237: LD_INT 110
7239: PPUSH
7240: CALL_OW 114
7244: GO 7280
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7246: LD_VAR 0 1
7250: PPUSH
7251: LD_INT 81
7253: PUSH
7254: LD_INT 8
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: PPUSH
7261: CALL_OW 69
7265: PPUSH
7266: LD_VAR 0 1
7270: PPUSH
7271: CALL_OW 74
7275: PPUSH
7276: CALL_OW 115
// end else
7280: GO 7309
// if IsDead ( i ) then
7282: LD_VAR 0 1
7286: PPUSH
7287: CALL_OW 301
7291: IFFALSE 7309
// tmp := tmp diff i ;
7293: LD_ADDR_VAR 0 3
7297: PUSH
7298: LD_VAR 0 3
7302: PUSH
7303: LD_VAR 0 1
7307: DIFF
7308: ST_TO_ADDR
// end ;
7309: GO 7174
7311: POP
7312: POP
// until not tmp ;
7313: LD_VAR 0 3
7317: NOT
7318: IFFALSE 7149
// end ; end_of_file
7320: PPOPN 3
7322: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7323: LD_INT 0
7325: PPUSH
7326: PPUSH
7327: PPUSH
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
7332: PPUSH
7333: PPUSH
7334: PPUSH
// side := 3 ;
7335: LD_ADDR_VAR 0 6
7339: PUSH
7340: LD_INT 3
7342: ST_TO_ADDR
// uc_side := side ;
7343: LD_ADDR_OWVAR 20
7347: PUSH
7348: LD_VAR 0 6
7352: ST_TO_ADDR
// uc_nation := 3 ;
7353: LD_ADDR_OWVAR 21
7357: PUSH
7358: LD_INT 3
7360: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7361: LD_ADDR_VAR 0 2
7365: PUSH
7366: LD_INT 22
7368: PUSH
7369: LD_VAR 0 6
7373: PUSH
7374: EMPTY
7375: LIST
7376: LIST
7377: PUSH
7378: LD_INT 21
7380: PUSH
7381: LD_INT 3
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: PUSH
7388: EMPTY
7389: LIST
7390: LIST
7391: PPUSH
7392: CALL_OW 69
7396: PUSH
7397: FOR_IN
7398: IFFALSE 7414
// SetBLevel ( i , 10 ) ;
7400: LD_VAR 0 2
7404: PPUSH
7405: LD_INT 10
7407: PPUSH
7408: CALL_OW 241
7412: GO 7397
7414: POP
7415: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7416: LD_ADDR_VAR 0 10
7420: PUSH
7421: LD_INT 22
7423: PUSH
7424: LD_VAR 0 6
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: LD_INT 30
7435: PUSH
7436: LD_INT 34
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 69
7451: ST_TO_ADDR
// if teleport then
7452: LD_VAR 0 10
7456: IFFALSE 7477
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7458: LD_VAR 0 10
7462: PUSH
7463: LD_INT 1
7465: ARRAY
7466: PPUSH
7467: LD_INT 123
7469: PPUSH
7470: LD_INT 122
7472: PPUSH
7473: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7477: LD_ADDR_EXP 67
7481: PUSH
7482: LD_STRING Platonov
7484: PPUSH
7485: CALL_OW 25
7489: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7490: LD_ADDR_EXP 68
7494: PUSH
7495: LD_STRING Kovalyuk
7497: PPUSH
7498: CALL_OW 25
7502: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7503: LD_ADDR_EXP 70
7507: PUSH
7508: LD_STRING Yakotich
7510: PPUSH
7511: LD_EXP 1
7515: NOT
7516: PPUSH
7517: LD_STRING 09_
7519: PPUSH
7520: CALL 69058 0 3
7524: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7525: LD_ADDR_EXP 69
7529: PUSH
7530: LD_STRING Bystrov
7532: PPUSH
7533: CALL_OW 25
7537: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7538: LD_ADDR_EXP 71
7542: PUSH
7543: LD_STRING Gleb
7545: PPUSH
7546: CALL_OW 25
7550: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7551: LD_STRING 03_Cornel
7553: PPUSH
7554: CALL_OW 28
7558: IFFALSE 7606
// begin Bierezov := NewCharacter ( Mikhail ) ;
7560: LD_ADDR_EXP 72
7564: PUSH
7565: LD_STRING Mikhail
7567: PPUSH
7568: CALL_OW 25
7572: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7573: LD_EXP 72
7577: PPUSH
7578: LD_INT 197
7580: PPUSH
7581: LD_INT 111
7583: PPUSH
7584: LD_INT 9
7586: PPUSH
7587: LD_INT 0
7589: PPUSH
7590: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7594: LD_EXP 72
7598: PPUSH
7599: LD_INT 3
7601: PPUSH
7602: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7606: LD_EXP 67
7610: PPUSH
7611: LD_INT 126
7613: PPUSH
7614: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7618: LD_EXP 68
7622: PPUSH
7623: LD_INT 134
7625: PPUSH
7626: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7630: LD_EXP 70
7634: PPUSH
7635: LD_INT 197
7637: PPUSH
7638: LD_INT 111
7640: PPUSH
7641: LD_INT 9
7643: PPUSH
7644: LD_INT 0
7646: PPUSH
7647: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7651: LD_EXP 69
7655: PPUSH
7656: LD_INT 197
7658: PPUSH
7659: LD_INT 111
7661: PPUSH
7662: LD_INT 9
7664: PPUSH
7665: LD_INT 0
7667: PPUSH
7668: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7672: LD_EXP 71
7676: PPUSH
7677: LD_INT 197
7679: PPUSH
7680: LD_INT 111
7682: PPUSH
7683: LD_INT 9
7685: PPUSH
7686: LD_INT 0
7688: PPUSH
7689: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7693: LD_ADDR_VAR 0 5
7697: PUSH
7698: LD_INT 126
7700: PPUSH
7701: LD_INT 4
7703: PPUSH
7704: LD_STRING zhukov
7706: PPUSH
7707: LD_INT 9
7709: PUSH
7710: LD_INT 10
7712: PUSH
7713: LD_INT 10
7715: PUSH
7716: LD_INT 10
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_OWVAR 67
7729: ARRAY
7730: PPUSH
7731: LD_INT 90000
7733: PUSH
7734: LD_INT 1000
7736: PUSH
7737: LD_INT 300
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: LIST
7744: PPUSH
7745: LD_INT 18
7747: PUSH
7748: LD_INT 8
7750: PUSH
7751: LD_INT 12
7753: PUSH
7754: LD_INT 6
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PPUSH
7763: CALL 77719 0 6
7767: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7768: LD_ADDR_EXP 101
7772: PUSH
7773: LD_EXP 101
7777: PPUSH
7778: LD_INT 2
7780: PPUSH
7781: LD_VAR 0 5
7785: PUSH
7786: LD_EXP 70
7790: PUSH
7791: LD_EXP 69
7795: PUSH
7796: LD_EXP 71
7800: PUSH
7801: LD_EXP 72
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: LIST
7810: LIST
7811: UNION
7812: PPUSH
7813: CALL_OW 1
7817: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7818: LD_ADDR_VAR 0 4
7822: PUSH
7823: LD_INT 267
7825: PPUSH
7826: CALL_OW 274
7830: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7831: LD_VAR 0 4
7835: PPUSH
7836: LD_INT 1
7838: PPUSH
7839: LD_INT 5000
7841: PPUSH
7842: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7846: LD_VAR 0 4
7850: PPUSH
7851: LD_INT 2
7853: PPUSH
7854: LD_INT 200
7856: PPUSH
7857: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7861: LD_VAR 0 4
7865: PPUSH
7866: LD_INT 3
7868: PPUSH
7869: LD_INT 200
7871: PPUSH
7872: CALL_OW 277
// for i := 1 to 6 do
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: DOUBLE
7882: LD_INT 1
7884: DEC
7885: ST_TO_ADDR
7886: LD_INT 6
7888: PUSH
7889: FOR_TO
7890: IFFALSE 7973
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7892: LD_INT 0
7894: PPUSH
7895: LD_INT 8
7897: PUSH
7898: LD_INT 9
7900: PUSH
7901: LD_INT 10
7903: PUSH
7904: LD_INT 10
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: LIST
7912: PUSH
7913: LD_OWVAR 67
7917: ARRAY
7918: PPUSH
7919: CALL_OW 381
// un := CreateHuman ;
7923: LD_ADDR_VAR 0 8
7927: PUSH
7928: CALL_OW 44
7932: ST_TO_ADDR
// if i mod 2 = 0 then
7933: LD_VAR 0 2
7937: PUSH
7938: LD_INT 2
7940: MOD
7941: PUSH
7942: LD_INT 0
7944: EQUAL
7945: IFFALSE 7959
// SetClass ( un , class_bazooker ) ;
7947: LD_VAR 0 8
7951: PPUSH
7952: LD_INT 9
7954: PPUSH
7955: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
7959: LD_VAR 0 8
7963: PPUSH
7964: LD_INT 460
7966: PPUSH
7967: CALL_OW 52
// end ;
7971: GO 7889
7973: POP
7974: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
7975: LD_INT 21
7977: PPUSH
7978: LD_INT 3
7980: PPUSH
7981: LD_INT 3
7983: PPUSH
7984: LD_INT 52
7986: PPUSH
7987: LD_INT 100
7989: PPUSH
7990: CALL 73898 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
7994: CALL_OW 45
7998: PPUSH
7999: LD_INT 259
8001: PPUSH
8002: LD_INT 145
8004: PPUSH
8005: LD_INT 3
8007: PPUSH
8008: LD_INT 0
8010: PPUSH
8011: CALL 108900 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8015: CALL_OW 45
8019: PPUSH
8020: LD_INT 245
8022: PPUSH
8023: LD_INT 139
8025: PPUSH
8026: LD_INT 3
8028: PPUSH
8029: LD_INT 0
8031: PPUSH
8032: CALL 108900 0 5
// behemoths := [ ] ;
8036: LD_ADDR_EXP 75
8040: PUSH
8041: EMPTY
8042: ST_TO_ADDR
// behemothBuilders := [ ] ;
8043: LD_ADDR_EXP 76
8047: PUSH
8048: EMPTY
8049: ST_TO_ADDR
// if Kovalyuk then
8050: LD_EXP 68
8054: IFFALSE 8076
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8056: LD_ADDR_EXP 76
8060: PUSH
8061: LD_EXP 76
8065: PPUSH
8066: LD_EXP 68
8070: PPUSH
8071: CALL 106760 0 2
8075: ST_TO_ADDR
// j := 3 ;
8076: LD_ADDR_VAR 0 3
8080: PUSH
8081: LD_INT 3
8083: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8084: LD_ADDR_VAR 0 2
8088: PUSH
8089: LD_INT 22
8091: PUSH
8092: LD_INT 3
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 25
8101: PUSH
8102: LD_INT 3
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PPUSH
8113: CALL_OW 69
8117: PUSH
8118: LD_EXP 68
8122: DIFF
8123: PUSH
8124: FOR_IN
8125: IFFALSE 8175
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8127: LD_ADDR_EXP 76
8131: PUSH
8132: LD_EXP 76
8136: PPUSH
8137: LD_VAR 0 2
8141: PPUSH
8142: CALL 106760 0 2
8146: ST_TO_ADDR
// j := j - 1 ;
8147: LD_ADDR_VAR 0 3
8151: PUSH
8152: LD_VAR 0 3
8156: PUSH
8157: LD_INT 1
8159: MINUS
8160: ST_TO_ADDR
// if j = 0 then
8161: LD_VAR 0 3
8165: PUSH
8166: LD_INT 0
8168: EQUAL
8169: IFFALSE 8173
// break ;
8171: GO 8175
// end ;
8173: GO 8124
8175: POP
8176: POP
// end ;
8177: LD_VAR 0 1
8181: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8182: LD_INT 0
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
8188: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8189: LD_ADDR_VAR 0 4
8193: PUSH
8194: LD_INT 209
8196: PUSH
8197: LD_INT 149
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 219
8206: PUSH
8207: LD_INT 154
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 223
8216: PUSH
8217: LD_INT 149
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: LD_INT 232
8226: PUSH
8227: LD_INT 155
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: LIST
8238: LIST
8239: ST_TO_ADDR
// if not behemothBuilders then
8240: LD_EXP 76
8244: NOT
8245: IFFALSE 8249
// exit ;
8247: GO 8380
// j := 1 ;
8249: LD_ADDR_VAR 0 3
8253: PUSH
8254: LD_INT 1
8256: ST_TO_ADDR
// for i in behemothBuilders do
8257: LD_ADDR_VAR 0 2
8261: PUSH
8262: LD_EXP 76
8266: PUSH
8267: FOR_IN
8268: IFFALSE 8378
// begin if GetClass ( i ) <> class_mechanic then
8270: LD_VAR 0 2
8274: PPUSH
8275: CALL_OW 257
8279: PUSH
8280: LD_INT 3
8282: NONEQUAL
8283: IFFALSE 8297
// SetClass ( i , class_mechanic ) ;
8285: LD_VAR 0 2
8289: PPUSH
8290: LD_INT 3
8292: PPUSH
8293: CALL_OW 336
// if IsInUnit ( i ) then
8297: LD_VAR 0 2
8301: PPUSH
8302: CALL_OW 310
8306: IFFALSE 8317
// ComExitBuilding ( i ) ;
8308: LD_VAR 0 2
8312: PPUSH
8313: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8317: LD_VAR 0 2
8321: PPUSH
8322: LD_INT 37
8324: PPUSH
8325: LD_VAR 0 4
8329: PUSH
8330: LD_VAR 0 3
8334: ARRAY
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: LD_VAR 0 4
8344: PUSH
8345: LD_VAR 0 3
8349: ARRAY
8350: PUSH
8351: LD_INT 2
8353: ARRAY
8354: PPUSH
8355: LD_INT 0
8357: PPUSH
8358: CALL_OW 230
// j := j + 1 ;
8362: LD_ADDR_VAR 0 3
8366: PUSH
8367: LD_VAR 0 3
8371: PUSH
8372: LD_INT 1
8374: PLUS
8375: ST_TO_ADDR
// end ;
8376: GO 8267
8378: POP
8379: POP
// end ;
8380: LD_VAR 0 1
8384: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8385: LD_INT 24
8387: PPUSH
8388: LD_INT 30
8390: PUSH
8391: LD_INT 37
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PPUSH
8398: CALL_OW 70
8402: IFFALSE 8415
8404: GO 8406
8406: DISABLE
// behemothUnderConstruct := true ;
8407: LD_ADDR_EXP 26
8411: PUSH
8412: LD_INT 1
8414: ST_TO_ADDR
8415: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8416: LD_INT 3
8418: PPUSH
8419: CALL 106821 0 1
8423: PUSH
8424: LD_INT 22
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 30
8436: PUSH
8437: LD_INT 37
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: PPUSH
8448: CALL_OW 69
8452: NOT
8453: AND
8454: IFFALSE 8640
8456: GO 8458
8458: DISABLE
8459: LD_INT 0
8461: PPUSH
8462: PPUSH
// begin enable ;
8463: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8464: LD_ADDR_VAR 0 2
8468: PUSH
8469: LD_INT 3
8471: PPUSH
8472: CALL 106821 0 1
8476: ST_TO_ADDR
// for i in tmp do
8477: LD_ADDR_VAR 0 1
8481: PUSH
8482: LD_VAR 0 2
8486: PUSH
8487: FOR_IN
8488: IFFALSE 8638
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8490: LD_VAR 0 1
8494: PPUSH
8495: LD_INT 9
8497: PPUSH
8498: CALL_OW 308
8502: PUSH
8503: LD_VAR 0 1
8507: PPUSH
8508: CALL_OW 110
8512: PUSH
8513: LD_INT 2
8515: EQUAL
8516: NOT
8517: AND
8518: IFFALSE 8532
// SetTag ( i , 2 ) ;
8520: LD_VAR 0 1
8524: PPUSH
8525: LD_INT 2
8527: PPUSH
8528: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8532: LD_INT 81
8534: PUSH
8535: LD_INT 3
8537: PUSH
8538: EMPTY
8539: LIST
8540: LIST
8541: PUSH
8542: LD_INT 91
8544: PUSH
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 12
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 69
8566: NOT
8567: PUSH
8568: LD_VAR 0 1
8572: PPUSH
8573: CALL_OW 110
8577: PUSH
8578: LD_INT 2
8580: EQUAL
8581: NOT
8582: AND
8583: IFFALSE 8602
// ComAgressiveMove ( i , 64 , 93 ) else
8585: LD_VAR 0 1
8589: PPUSH
8590: LD_INT 64
8592: PPUSH
8593: LD_INT 93
8595: PPUSH
8596: CALL_OW 114
8600: GO 8636
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8602: LD_VAR 0 1
8606: PPUSH
8607: LD_INT 81
8609: PUSH
8610: LD_INT 3
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 69
8621: PPUSH
8622: LD_VAR 0 1
8626: PPUSH
8627: CALL_OW 74
8631: PPUSH
8632: CALL_OW 115
// end ;
8636: GO 8487
8638: POP
8639: POP
// end ;
8640: PPOPN 2
8642: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8643: LD_INT 0
8645: PPUSH
8646: PPUSH
8647: PPUSH
// result := [ ] ;
8648: LD_ADDR_VAR 0 2
8652: PUSH
8653: EMPTY
8654: ST_TO_ADDR
// uc_side := 6 ;
8655: LD_ADDR_OWVAR 20
8659: PUSH
8660: LD_INT 6
8662: ST_TO_ADDR
// uc_nation := 3 ;
8663: LD_ADDR_OWVAR 21
8667: PUSH
8668: LD_INT 3
8670: ST_TO_ADDR
// case strength of 1 :
8671: LD_VAR 0 1
8675: PUSH
8676: LD_INT 1
8678: DOUBLE
8679: EQUAL
8680: IFTRUE 8684
8682: GO 8826
8684: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8685: LD_ADDR_VAR 0 3
8689: PUSH
8690: DOUBLE
8691: LD_INT 1
8693: DEC
8694: ST_TO_ADDR
8695: LD_INT 4
8697: PUSH
8698: LD_INT 5
8700: PUSH
8701: LD_INT 6
8703: PUSH
8704: LD_INT 7
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: LIST
8711: LIST
8712: PUSH
8713: LD_OWVAR 67
8717: ARRAY
8718: PUSH
8719: FOR_TO
8720: IFFALSE 8822
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8722: LD_INT 22
8724: PUSH
8725: LD_INT 24
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: PUSH
8732: LD_VAR 0 3
8736: PUSH
8737: LD_INT 2
8739: MOD
8740: PUSH
8741: LD_INT 1
8743: PLUS
8744: ARRAY
8745: PPUSH
8746: LD_INT 1
8748: PUSH
8749: LD_INT 3
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: PUSH
8756: LD_INT 1
8758: PPUSH
8759: LD_INT 2
8761: PPUSH
8762: CALL_OW 12
8766: ARRAY
8767: PPUSH
8768: LD_INT 3
8770: PPUSH
8771: LD_INT 43
8773: PUSH
8774: LD_INT 44
8776: PUSH
8777: LD_INT 45
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: CALL_OW 12
8795: ARRAY
8796: PPUSH
8797: LD_INT 80
8799: PPUSH
8800: CALL 73898 0 5
// result := result union CreateVehicle ;
8804: LD_ADDR_VAR 0 2
8808: PUSH
8809: LD_VAR 0 2
8813: PUSH
8814: CALL_OW 45
8818: UNION
8819: ST_TO_ADDR
// end ;
8820: GO 8719
8822: POP
8823: POP
// end ; 2 :
8824: GO 9821
8826: LD_INT 2
8828: DOUBLE
8829: EQUAL
8830: IFTRUE 8834
8832: GO 9002
8834: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8835: LD_ADDR_VAR 0 3
8839: PUSH
8840: DOUBLE
8841: LD_INT 1
8843: DEC
8844: ST_TO_ADDR
8845: LD_INT 5
8847: PUSH
8848: LD_INT 6
8850: PUSH
8851: LD_INT 7
8853: PUSH
8854: LD_INT 8
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: LIST
8861: LIST
8862: PUSH
8863: LD_OWVAR 67
8867: ARRAY
8868: PUSH
8869: FOR_TO
8870: IFFALSE 8998
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8872: LD_INT 22
8874: PUSH
8875: LD_INT 24
8877: PUSH
8878: LD_INT 24
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 3
8890: PUSH
8891: LD_INT 3
8893: MOD
8894: PUSH
8895: LD_INT 1
8897: PLUS
8898: ARRAY
8899: PPUSH
8900: LD_INT 1
8902: PUSH
8903: LD_INT 3
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 1
8912: PPUSH
8913: LD_INT 2
8915: PPUSH
8916: CALL_OW 12
8920: ARRAY
8921: PPUSH
8922: LD_INT 3
8924: PPUSH
8925: LD_INT 43
8927: PUSH
8928: LD_INT 44
8930: PUSH
8931: LD_INT 45
8933: PUSH
8934: LD_INT 44
8936: PUSH
8937: LD_INT 46
8939: PUSH
8940: LD_INT 46
8942: PUSH
8943: LD_INT 49
8945: PUSH
8946: LD_INT 49
8948: PUSH
8949: EMPTY
8950: LIST
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 8
8966: MOD
8967: PUSH
8968: LD_INT 1
8970: PLUS
8971: ARRAY
8972: PPUSH
8973: LD_INT 80
8975: PPUSH
8976: CALL 73898 0 5
// result := result union CreateVehicle ;
8980: LD_ADDR_VAR 0 2
8984: PUSH
8985: LD_VAR 0 2
8989: PUSH
8990: CALL_OW 45
8994: UNION
8995: ST_TO_ADDR
// end ;
8996: GO 8869
8998: POP
8999: POP
// end ; 3 :
9000: GO 9821
9002: LD_INT 3
9004: DOUBLE
9005: EQUAL
9006: IFTRUE 9010
9008: GO 9182
9010: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9011: LD_ADDR_VAR 0 3
9015: PUSH
9016: DOUBLE
9017: LD_INT 1
9019: DEC
9020: ST_TO_ADDR
9021: LD_INT 6
9023: PUSH
9024: LD_INT 7
9026: PUSH
9027: LD_INT 8
9029: PUSH
9030: LD_INT 9
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: LIST
9038: PUSH
9039: LD_OWVAR 67
9043: ARRAY
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9178
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 3
9100: PPUSH
9101: LD_INT 43
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 45
9109: PUSH
9110: LD_INT 45
9112: PUSH
9113: LD_INT 46
9115: PUSH
9116: LD_INT 46
9118: PUSH
9119: LD_INT 49
9121: PUSH
9122: LD_INT 49
9124: PUSH
9125: LD_INT 49
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: PUSH
9139: LD_VAR 0 3
9143: PUSH
9144: LD_INT 9
9146: MOD
9147: PUSH
9148: LD_INT 1
9150: PLUS
9151: ARRAY
9152: PPUSH
9153: LD_INT 80
9155: PPUSH
9156: CALL 73898 0 5
// result := result union CreateVehicle ;
9160: LD_ADDR_VAR 0 2
9164: PUSH
9165: LD_VAR 0 2
9169: PUSH
9170: CALL_OW 45
9174: UNION
9175: ST_TO_ADDR
// end ;
9176: GO 9045
9178: POP
9179: POP
// end ; 4 :
9180: GO 9821
9182: LD_INT 4
9184: DOUBLE
9185: EQUAL
9186: IFTRUE 9190
9188: GO 9820
9190: POP
// begin uc_nation := 3 ;
9191: LD_ADDR_OWVAR 21
9195: PUSH
9196: LD_INT 3
9198: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9199: LD_ADDR_VAR 0 3
9203: PUSH
9204: DOUBLE
9205: LD_INT 1
9207: DEC
9208: ST_TO_ADDR
9209: LD_INT 6
9211: PUSH
9212: LD_INT 8
9214: PUSH
9215: LD_INT 9
9217: PUSH
9218: LD_INT 10
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: LIST
9225: LIST
9226: PUSH
9227: LD_OWVAR 67
9231: ARRAY
9232: PUSH
9233: FOR_TO
9234: IFFALSE 9366
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9236: LD_INT 22
9238: PUSH
9239: LD_INT 24
9241: PUSH
9242: LD_INT 24
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: PUSH
9250: LD_VAR 0 3
9254: PUSH
9255: LD_INT 3
9257: MOD
9258: PUSH
9259: LD_INT 1
9261: PLUS
9262: ARRAY
9263: PPUSH
9264: LD_INT 1
9266: PUSH
9267: LD_INT 3
9269: PUSH
9270: EMPTY
9271: LIST
9272: LIST
9273: PUSH
9274: LD_INT 1
9276: PPUSH
9277: LD_INT 2
9279: PPUSH
9280: CALL_OW 12
9284: ARRAY
9285: PPUSH
9286: LD_INT 3
9288: PPUSH
9289: LD_INT 45
9291: PUSH
9292: LD_INT 47
9294: PUSH
9295: LD_INT 47
9297: PUSH
9298: LD_INT 45
9300: PUSH
9301: LD_INT 46
9303: PUSH
9304: LD_INT 46
9306: PUSH
9307: LD_INT 49
9309: PUSH
9310: LD_INT 49
9312: PUSH
9313: LD_INT 49
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: LIST
9325: LIST
9326: PUSH
9327: LD_VAR 0 3
9331: PUSH
9332: LD_INT 9
9334: MOD
9335: PUSH
9336: LD_INT 1
9338: PLUS
9339: ARRAY
9340: PPUSH
9341: LD_INT 80
9343: PPUSH
9344: CALL 73898 0 5
// result := result union CreateVehicle ;
9348: LD_ADDR_VAR 0 2
9352: PUSH
9353: LD_VAR 0 2
9357: PUSH
9358: CALL_OW 45
9362: UNION
9363: ST_TO_ADDR
// end ;
9364: GO 9233
9366: POP
9367: POP
// if not KappaStatus then
9368: LD_EXP 2
9372: NOT
9373: IFFALSE 9608
// begin uc_nation := 1 ;
9375: LD_ADDR_OWVAR 21
9379: PUSH
9380: LD_INT 1
9382: ST_TO_ADDR
// for i = 1 to 3 do
9383: LD_ADDR_VAR 0 3
9387: PUSH
9388: DOUBLE
9389: LD_INT 1
9391: DEC
9392: ST_TO_ADDR
9393: LD_INT 3
9395: PUSH
9396: FOR_TO
9397: IFFALSE 9533
// begin j := rand ( 0 , 1 ) ;
9399: LD_ADDR_VAR 0 4
9403: PUSH
9404: LD_INT 0
9406: PPUSH
9407: LD_INT 1
9409: PPUSH
9410: CALL_OW 12
9414: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9415: LD_INT 3
9417: PUSH
9418: LD_INT 5
9420: PUSH
9421: LD_INT 5
9423: PUSH
9424: LD_INT 4
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: LIST
9431: LIST
9432: PUSH
9433: LD_VAR 0 4
9437: PUSH
9438: LD_INT 1
9440: PPUSH
9441: LD_INT 3
9443: PPUSH
9444: CALL_OW 12
9448: PLUS
9449: ARRAY
9450: PPUSH
9451: LD_INT 1
9453: PUSH
9454: LD_INT 3
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PUSH
9461: LD_INT 1
9463: PPUSH
9464: LD_INT 2
9466: PPUSH
9467: CALL_OW 12
9471: ARRAY
9472: PPUSH
9473: LD_INT 3
9475: PPUSH
9476: LD_INT 9
9478: PUSH
9479: LD_INT 7
9481: PUSH
9482: LD_INT 6
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: LIST
9489: PUSH
9490: LD_VAR 0 4
9494: PUSH
9495: LD_INT 1
9497: PPUSH
9498: LD_INT 2
9500: PPUSH
9501: CALL_OW 12
9505: PLUS
9506: ARRAY
9507: PPUSH
9508: LD_INT 85
9510: PPUSH
9511: CALL 73898 0 5
// result := result union CreateVehicle ;
9515: LD_ADDR_VAR 0 2
9519: PUSH
9520: LD_VAR 0 2
9524: PUSH
9525: CALL_OW 45
9529: UNION
9530: ST_TO_ADDR
// end ;
9531: GO 9396
9533: POP
9534: POP
// if vsevolodFirstAttack then
9535: LD_EXP 24
9539: IFFALSE 9606
// begin vsevolodFirstAttack := false ;
9541: LD_ADDR_EXP 24
9545: PUSH
9546: LD_INT 0
9548: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9549: LD_INT 5
9551: PPUSH
9552: LD_INT 3
9554: PPUSH
9555: LD_INT 1
9557: PPUSH
9558: LD_INT 6
9560: PPUSH
9561: LD_INT 100
9563: PPUSH
9564: CALL 73898 0 5
// sewiVeh := CreateVehicle ;
9568: LD_ADDR_EXP 74
9572: PUSH
9573: CALL_OW 45
9577: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9578: LD_EXP 74
9582: PPUSH
9583: LD_INT 1
9585: PPUSH
9586: CALL_OW 242
// result := result union sewiVeh ;
9590: LD_ADDR_VAR 0 2
9594: PUSH
9595: LD_VAR 0 2
9599: PUSH
9600: LD_EXP 74
9604: UNION
9605: ST_TO_ADDR
// end ; end else
9606: GO 9818
// if vsevolodFirstAttack then
9608: LD_EXP 24
9612: IFFALSE 9818
// begin vsevolodFirstAttack := false ;
9614: LD_ADDR_EXP 24
9618: PUSH
9619: LD_INT 0
9621: ST_TO_ADDR
// uc_nation := 3 ;
9622: LD_ADDR_OWVAR 21
9626: PUSH
9627: LD_INT 3
9629: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9630: LD_ADDR_VAR 0 3
9634: PUSH
9635: DOUBLE
9636: LD_INT 1
9638: DEC
9639: ST_TO_ADDR
9640: LD_INT 2
9642: PUSH
9643: LD_OWVAR 67
9647: PLUS
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9758
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9652: LD_INT 22
9654: PUSH
9655: LD_INT 24
9657: PUSH
9658: LD_INT 24
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: LD_VAR 0 3
9670: PUSH
9671: LD_INT 3
9673: MOD
9674: PUSH
9675: LD_INT 1
9677: PLUS
9678: ARRAY
9679: PPUSH
9680: LD_INT 1
9682: PUSH
9683: LD_INT 3
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: PUSH
9690: LD_INT 1
9692: PPUSH
9693: LD_INT 2
9695: PPUSH
9696: CALL_OW 12
9700: ARRAY
9701: PPUSH
9702: LD_INT 1
9704: PPUSH
9705: LD_INT 45
9707: PUSH
9708: LD_INT 47
9710: PUSH
9711: LD_INT 47
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: PUSH
9719: LD_VAR 0 3
9723: PUSH
9724: LD_INT 3
9726: MOD
9727: PUSH
9728: LD_INT 1
9730: PLUS
9731: ARRAY
9732: PPUSH
9733: LD_INT 80
9735: PPUSH
9736: CALL 73898 0 5
// result := result union CreateVehicle ;
9740: LD_ADDR_VAR 0 2
9744: PUSH
9745: LD_VAR 0 2
9749: PUSH
9750: CALL_OW 45
9754: UNION
9755: ST_TO_ADDR
// end ;
9756: GO 9649
9758: POP
9759: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9760: LD_INT 24
9762: PPUSH
9763: LD_INT 3
9765: PPUSH
9766: LD_INT 1
9768: PPUSH
9769: LD_INT 47
9771: PPUSH
9772: LD_INT 100
9774: PPUSH
9775: CALL 73898 0 5
// sewiVeh := CreateVehicle ;
9779: LD_ADDR_EXP 74
9783: PUSH
9784: CALL_OW 45
9788: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9789: LD_EXP 74
9793: PPUSH
9794: LD_INT 6
9796: NEG
9797: PPUSH
9798: CALL_OW 242
// result := result union sewiVeh ;
9802: LD_ADDR_VAR 0 2
9806: PUSH
9807: LD_VAR 0 2
9811: PUSH
9812: LD_EXP 74
9816: UNION
9817: ST_TO_ADDR
// end ; end ; end ;
9818: GO 9821
9820: POP
// end ;
9821: LD_VAR 0 2
9825: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9826: LD_EXP 16
9830: IFFALSE 10571
9832: GO 9834
9834: DISABLE
9835: LD_INT 0
9837: PPUSH
9838: PPUSH
9839: PPUSH
9840: PPUSH
9841: PPUSH
9842: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9843: LD_ADDR_VAR 0 4
9847: PUSH
9848: LD_INT 11
9850: PUSH
9851: LD_INT 12
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9858: LD_ADDR_VAR 0 3
9862: PUSH
9863: LD_INT 11550
9865: PUSH
9866: LD_INT 10150
9868: PUSH
9869: LD_INT 9800
9871: PUSH
9872: LD_INT 9450
9874: PUSH
9875: EMPTY
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: PUSH
9881: LD_OWVAR 67
9885: ARRAY
9886: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9887: LD_ADDR_VAR 0 6
9891: PUSH
9892: LD_INT 70
9894: PUSH
9895: LD_INT 118
9897: PUSH
9898: EMPTY
9899: LIST
9900: LIST
9901: PUSH
9902: LD_INT 78
9904: PUSH
9905: LD_INT 31
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: ST_TO_ADDR
// repeat if missionStage = 2 then
9916: LD_EXP 15
9920: PUSH
9921: LD_INT 2
9923: EQUAL
9924: IFFALSE 9935
// wait ( 1 1$30 ) else
9926: LD_INT 3150
9928: PPUSH
9929: CALL_OW 67
9933: GO 9944
// wait ( time ) ;
9935: LD_VAR 0 3
9939: PPUSH
9940: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9944: LD_EXP 15
9948: PUSH
9949: LD_INT 6
9951: EQUAL
9952: PUSH
9953: LD_OWVAR 67
9957: PUSH
9958: LD_INT 2
9960: GREATER
9961: OR
9962: IFFALSE 9990
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9964: LD_INT 51
9966: PPUSH
9967: LD_INT 6
9969: PPUSH
9970: LD_INT 2
9972: PPUSH
9973: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9977: LD_INT 57
9979: PPUSH
9980: LD_INT 6
9982: PPUSH
9983: LD_INT 2
9985: PPUSH
9986: CALL_OW 322
// end ; if missionStage = 8 then
9990: LD_EXP 15
9994: PUSH
9995: LD_INT 8
9997: EQUAL
9998: IFFALSE 10026
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10000: LD_INT 52
10002: PPUSH
10003: LD_INT 6
10005: PPUSH
10006: LD_INT 2
10008: PPUSH
10009: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10013: LD_INT 58
10015: PPUSH
10016: LD_INT 6
10018: PPUSH
10019: LD_INT 2
10021: PPUSH
10022: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10026: LD_OWVAR 67
10030: PUSH
10031: LD_INT 4
10033: EQUAL
10034: PUSH
10035: LD_EXP 15
10039: PUSH
10040: LD_INT 10
10042: EQUAL
10043: OR
10044: IFFALSE 10072
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10046: LD_INT 53
10048: PPUSH
10049: LD_INT 6
10051: PPUSH
10052: LD_INT 2
10054: PPUSH
10055: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10059: LD_INT 59
10061: PPUSH
10062: LD_INT 6
10064: PPUSH
10065: LD_INT 2
10067: PPUSH
10068: CALL_OW 322
// end ; if activeAttacks then
10072: LD_EXP 16
10076: IFFALSE 10565
// begin if missionStage = 2 then
10078: LD_EXP 15
10082: PUSH
10083: LD_INT 2
10085: EQUAL
10086: IFFALSE 10096
// strength := 1 ;
10088: LD_ADDR_VAR 0 5
10092: PUSH
10093: LD_INT 1
10095: ST_TO_ADDR
// if missionStage > 2 then
10096: LD_EXP 15
10100: PUSH
10101: LD_INT 2
10103: GREATER
10104: IFFALSE 10114
// strength := 2 ;
10106: LD_ADDR_VAR 0 5
10110: PUSH
10111: LD_INT 2
10113: ST_TO_ADDR
// if missionStage > 6 then
10114: LD_EXP 15
10118: PUSH
10119: LD_INT 6
10121: GREATER
10122: IFFALSE 10132
// strength := 3 ;
10124: LD_ADDR_VAR 0 5
10128: PUSH
10129: LD_INT 3
10131: ST_TO_ADDR
// if missionStage > 10 then
10132: LD_EXP 15
10136: PUSH
10137: LD_INT 10
10139: GREATER
10140: IFFALSE 10150
// strength := 4 ;
10142: LD_ADDR_VAR 0 5
10146: PUSH
10147: LD_INT 4
10149: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10150: LD_ADDR_VAR 0 2
10154: PUSH
10155: LD_VAR 0 5
10159: PPUSH
10160: CALL 8643 0 1
10164: ST_TO_ADDR
// for i in tmp do
10165: LD_ADDR_VAR 0 1
10169: PUSH
10170: LD_VAR 0 2
10174: PUSH
10175: FOR_IN
10176: IFFALSE 10434
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10178: LD_VAR 0 1
10182: PPUSH
10183: LD_VAR 0 4
10187: PUSH
10188: LD_INT 1
10190: PPUSH
10191: LD_INT 2
10193: PPUSH
10194: CALL_OW 12
10198: ARRAY
10199: PPUSH
10200: LD_INT 0
10202: PPUSH
10203: CALL_OW 49
// if i = sewiVeh then
10207: LD_VAR 0 1
10211: PUSH
10212: LD_EXP 74
10216: EQUAL
10217: IFFALSE 10254
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10219: LD_ADDR_EXP 73
10223: PUSH
10224: LD_STRING Vsevolod
10226: PPUSH
10227: LD_INT 0
10229: PPUSH
10230: LD_STRING 
10232: PPUSH
10233: CALL 69058 0 3
10237: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10238: LD_EXP 73
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 52
// end else
10252: GO 10335
// if GetControl ( i ) = control_manual then
10254: LD_VAR 0 1
10258: PPUSH
10259: CALL_OW 263
10263: PUSH
10264: LD_INT 1
10266: EQUAL
10267: IFFALSE 10335
// begin uc_side := 6 ;
10269: LD_ADDR_OWVAR 20
10273: PUSH
10274: LD_INT 6
10276: ST_TO_ADDR
// uc_nation := 3 ;
10277: LD_ADDR_OWVAR 21
10281: PUSH
10282: LD_INT 3
10284: ST_TO_ADDR
// hc_gallery :=  ;
10285: LD_ADDR_OWVAR 33
10289: PUSH
10290: LD_STRING 
10292: ST_TO_ADDR
// hc_name :=  ;
10293: LD_ADDR_OWVAR 26
10297: PUSH
10298: LD_STRING 
10300: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10301: LD_INT 0
10303: PPUSH
10304: LD_INT 3
10306: PPUSH
10307: LD_INT 10
10309: PPUSH
10310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10314: CALL_OW 44
10318: PPUSH
10319: LD_VAR 0 1
10323: PPUSH
10324: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10328: LD_INT 10
10330: PPUSH
10331: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10335: LD_INT 1
10337: PPUSH
10338: LD_INT 3
10340: PPUSH
10341: CALL_OW 12
10345: PUSH
10346: LD_INT 1
10348: DOUBLE
10349: EQUAL
10350: IFTRUE 10354
10352: GO 10372
10354: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10355: LD_VAR 0 1
10359: PPUSH
10360: LD_INT 111
10362: PPUSH
10363: LD_INT 197
10365: PPUSH
10366: CALL_OW 111
10370: GO 10425
10372: LD_INT 2
10374: DOUBLE
10375: EQUAL
10376: IFTRUE 10380
10378: GO 10398
10380: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10381: LD_VAR 0 1
10385: PPUSH
10386: LD_INT 91
10388: PPUSH
10389: LD_INT 165
10391: PPUSH
10392: CALL_OW 111
10396: GO 10425
10398: LD_INT 3
10400: DOUBLE
10401: EQUAL
10402: IFTRUE 10406
10404: GO 10424
10406: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10407: LD_VAR 0 1
10411: PPUSH
10412: LD_INT 137
10414: PPUSH
10415: LD_INT 157
10417: PPUSH
10418: CALL_OW 111
10422: GO 10425
10424: POP
// wait ( 0 0$2 ) ;
10425: LD_INT 70
10427: PPUSH
10428: CALL_OW 67
// end ;
10432: GO 10175
10434: POP
10435: POP
// repeat wait ( 0 0$1 ) ;
10436: LD_INT 35
10438: PPUSH
10439: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10443: LD_ADDR_VAR 0 1
10447: PUSH
10448: LD_VAR 0 2
10452: PPUSH
10453: LD_INT 50
10455: PUSH
10456: EMPTY
10457: LIST
10458: PPUSH
10459: CALL_OW 72
10463: PUSH
10464: FOR_IN
10465: IFFALSE 10524
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10467: LD_VAR 0 1
10471: PPUSH
10472: LD_INT 108
10474: PUSH
10475: LD_INT 153
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PUSH
10482: LD_INT 105
10484: PUSH
10485: LD_INT 149
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PUSH
10492: LD_INT 85
10494: PUSH
10495: LD_INT 131
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 64
10504: PUSH
10505: LD_INT 105
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: LIST
10516: LIST
10517: PPUSH
10518: CALL 109364 0 2
10522: GO 10464
10524: POP
10525: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10526: LD_VAR 0 2
10530: PPUSH
10531: LD_INT 3
10533: PUSH
10534: LD_INT 34
10536: PUSH
10537: LD_INT 49
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: PUSH
10544: EMPTY
10545: LIST
10546: LIST
10547: PUSH
10548: LD_INT 50
10550: PUSH
10551: EMPTY
10552: LIST
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: PPUSH
10558: CALL_OW 72
10562: NOT
10563: IFFALSE 10436
// end ; until russianDestroyed ;
10565: LD_EXP 21
10569: IFFALSE 9916
// end ;
10571: PPOPN 6
10573: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
10574: LD_EXP 21
10578: NOT
10579: PUSH
10580: LD_EXP 15
10584: PUSH
10585: LD_INT 6
10587: GREATEREQUAL
10588: AND
10589: IFFALSE 11528
10591: GO 10593
10593: DISABLE
10594: LD_INT 0
10596: PPUSH
10597: PPUSH
10598: PPUSH
10599: PPUSH
// begin enable ;
10600: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10601: LD_INT 22
10603: PUSH
10604: LD_INT 3
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 3
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 69
10629: NOT
10630: IFFALSE 10634
// exit ;
10632: GO 11528
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10634: LD_ADDR_VAR 0 4
10638: PUSH
10639: LD_INT 22
10641: PUSH
10642: LD_INT 3
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PUSH
10649: LD_INT 30
10651: PUSH
10652: LD_INT 34
10654: PUSH
10655: EMPTY
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PPUSH
10663: CALL_OW 69
10667: ST_TO_ADDR
// if Prob ( 40 ) then
10668: LD_INT 40
10670: PPUSH
10671: CALL_OW 13
10675: IFFALSE 10821
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10677: LD_INT 2
10679: PPUSH
10680: LD_INT 22
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: LD_INT 3
10688: PUSH
10689: LD_INT 49
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PUSH
10698: LD_INT 22
10700: PUSH
10701: LD_INT 3
10703: PUSH
10704: LD_INT 3
10706: PUSH
10707: LD_INT 49
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: LIST
10714: LIST
10715: PUSH
10716: LD_INT 22
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: LD_INT 3
10724: PUSH
10725: LD_INT 49
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: LIST
10732: LIST
10733: PUSH
10734: LD_INT 24
10736: PUSH
10737: LD_INT 3
10739: PUSH
10740: LD_INT 3
10742: PUSH
10743: LD_INT 46
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: PUSH
10752: LD_INT 24
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: LD_INT 3
10760: PUSH
10761: LD_INT 46
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: LIST
10769: PUSH
10770: LD_INT 24
10772: PUSH
10773: LD_INT 3
10775: PUSH
10776: LD_INT 3
10778: PUSH
10779: LD_INT 46
10781: PUSH
10782: EMPTY
10783: LIST
10784: LIST
10785: LIST
10786: LIST
10787: PUSH
10788: LD_INT 24
10790: PUSH
10791: LD_INT 3
10793: PUSH
10794: LD_INT 3
10796: PUSH
10797: LD_INT 46
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: LIST
10812: LIST
10813: LIST
10814: PPUSH
10815: CALL 62632 0 2
// end else
10819: GO 10963
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10821: LD_INT 2
10823: PPUSH
10824: LD_INT 24
10826: PUSH
10827: LD_INT 3
10829: PUSH
10830: LD_INT 3
10832: PUSH
10833: LD_INT 47
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PUSH
10842: LD_INT 24
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: LD_INT 3
10850: PUSH
10851: LD_INT 47
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: LIST
10858: LIST
10859: PUSH
10860: LD_INT 24
10862: PUSH
10863: LD_INT 3
10865: PUSH
10866: LD_INT 3
10868: PUSH
10869: LD_INT 47
10871: PUSH
10872: EMPTY
10873: LIST
10874: LIST
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 24
10880: PUSH
10881: LD_INT 3
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: LD_INT 46
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: LIST
10894: LIST
10895: PUSH
10896: LD_INT 24
10898: PUSH
10899: LD_INT 3
10901: PUSH
10902: LD_INT 3
10904: PUSH
10905: LD_INT 46
10907: PUSH
10908: EMPTY
10909: LIST
10910: LIST
10911: LIST
10912: LIST
10913: PUSH
10914: LD_INT 24
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 3
10922: PUSH
10923: LD_INT 46
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 24
10934: PUSH
10935: LD_INT 3
10937: PUSH
10938: LD_INT 3
10940: PUSH
10941: LD_INT 46
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: LIST
10948: LIST
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: PPUSH
10959: CALL 62632 0 2
// end ; repeat wait ( 0 0$1 ) ;
10963: LD_INT 35
10965: PPUSH
10966: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10970: LD_INT 2
10972: PPUSH
10973: LD_INT 1
10975: PPUSH
10976: CALL 64050 0 2
10980: PUSH
10981: LD_INT 7
10983: GREATEREQUAL
10984: IFFALSE 10963
// wait ( 0 0$10 ) ;
10986: LD_INT 350
10988: PPUSH
10989: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10993: LD_ADDR_VAR 0 2
10997: PUSH
10998: LD_INT 2
11000: PPUSH
11001: LD_INT 1
11003: PPUSH
11004: CALL 64050 0 2
11008: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11009: LD_ADDR_EXP 120
11013: PUSH
11014: LD_EXP 120
11018: PPUSH
11019: LD_INT 2
11021: PPUSH
11022: LD_EXP 120
11026: PUSH
11027: LD_INT 2
11029: ARRAY
11030: PUSH
11031: LD_VAR 0 2
11035: DIFF
11036: PPUSH
11037: CALL_OW 1
11041: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11042: LD_ADDR_VAR 0 3
11046: PUSH
11047: LD_INT 0
11049: PPUSH
11050: LD_INT 1
11052: PPUSH
11053: CALL_OW 12
11057: ST_TO_ADDR
// if target then
11058: LD_VAR 0 3
11062: IFFALSE 11190
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11064: LD_ADDR_VAR 0 2
11068: PUSH
11069: LD_VAR 0 2
11073: PPUSH
11074: LD_INT 24
11076: PUSH
11077: LD_INT 250
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PPUSH
11084: CALL_OW 72
11088: ST_TO_ADDR
// for i in tmp do
11089: LD_ADDR_VAR 0 1
11093: PUSH
11094: LD_VAR 0 2
11098: PUSH
11099: FOR_IN
11100: IFFALSE 11140
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11102: LD_VAR 0 1
11106: PPUSH
11107: LD_INT 139
11109: PPUSH
11110: LD_INT 89
11112: PPUSH
11113: CALL_OW 297
11117: PUSH
11118: LD_INT 9
11120: GREATER
11121: IFFALSE 11138
// ComMoveXY ( i , 139 , 89 ) ;
11123: LD_VAR 0 1
11127: PPUSH
11128: LD_INT 139
11130: PPUSH
11131: LD_INT 89
11133: PPUSH
11134: CALL_OW 111
11138: GO 11099
11140: POP
11141: POP
// wait ( 0 0$1 ) ;
11142: LD_INT 35
11144: PPUSH
11145: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
11149: LD_VAR 0 2
11153: PPUSH
11154: LD_INT 92
11156: PUSH
11157: LD_INT 139
11159: PUSH
11160: LD_INT 89
11162: PUSH
11163: LD_INT 9
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: PPUSH
11172: CALL_OW 72
11176: PUSH
11177: LD_VAR 0 2
11181: PUSH
11182: LD_INT 1
11184: MINUS
11185: GREATEREQUAL
11186: IFFALSE 11064
// end else
11188: GO 11332
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11190: LD_VAR 0 2
11194: PPUSH
11195: LD_VAR 0 4
11199: PUSH
11200: LD_INT 1
11202: ARRAY
11203: PPUSH
11204: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11208: LD_ADDR_VAR 0 2
11212: PUSH
11213: LD_VAR 0 2
11217: PPUSH
11218: LD_INT 24
11220: PUSH
11221: LD_INT 250
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PPUSH
11228: CALL_OW 72
11232: ST_TO_ADDR
// for i in tmp do
11233: LD_ADDR_VAR 0 1
11237: PUSH
11238: LD_VAR 0 2
11242: PUSH
11243: FOR_IN
11244: IFFALSE 11284
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11246: LD_VAR 0 1
11250: PPUSH
11251: LD_INT 124
11253: PPUSH
11254: LD_INT 139
11256: PPUSH
11257: CALL_OW 297
11261: PUSH
11262: LD_INT 9
11264: GREATER
11265: IFFALSE 11282
// ComMoveXY ( i , 124 , 139 ) ;
11267: LD_VAR 0 1
11271: PPUSH
11272: LD_INT 124
11274: PPUSH
11275: LD_INT 139
11277: PPUSH
11278: CALL_OW 111
11282: GO 11243
11284: POP
11285: POP
// wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11293: LD_VAR 0 2
11297: PPUSH
11298: LD_INT 92
11300: PUSH
11301: LD_INT 124
11303: PUSH
11304: LD_INT 139
11306: PUSH
11307: LD_INT 9
11309: PUSH
11310: EMPTY
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: PPUSH
11316: CALL_OW 72
11320: PUSH
11321: LD_VAR 0 2
11325: PUSH
11326: LD_INT 1
11328: MINUS
11329: GREATEREQUAL
11330: IFFALSE 11208
// end ; repeat wait ( 0 0$1 ) ;
11332: LD_INT 35
11334: PPUSH
11335: CALL_OW 67
// for i in tmp do
11339: LD_ADDR_VAR 0 1
11343: PUSH
11344: LD_VAR 0 2
11348: PUSH
11349: FOR_IN
11350: IFFALSE 11519
// begin if GetLives ( i ) > 251 then
11352: LD_VAR 0 1
11356: PPUSH
11357: CALL_OW 256
11361: PUSH
11362: LD_INT 251
11364: GREATER
11365: IFFALSE 11490
// begin if GetWeapon ( i ) = ru_time_lapser then
11367: LD_VAR 0 1
11371: PPUSH
11372: CALL_OW 264
11376: PUSH
11377: LD_INT 49
11379: EQUAL
11380: IFFALSE 11436
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11382: LD_VAR 0 1
11386: PPUSH
11387: LD_INT 2
11389: PUSH
11390: LD_INT 22
11392: PUSH
11393: LD_INT 1
11395: PUSH
11396: EMPTY
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 22
11402: PUSH
11403: LD_INT 8
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: PPUSH
11420: LD_VAR 0 1
11424: PPUSH
11425: CALL_OW 74
11429: PPUSH
11430: CALL_OW 112
11434: GO 11488
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11436: LD_VAR 0 1
11440: PPUSH
11441: LD_INT 2
11443: PUSH
11444: LD_INT 22
11446: PUSH
11447: LD_INT 1
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: PUSH
11454: LD_INT 22
11456: PUSH
11457: LD_INT 8
11459: PUSH
11460: EMPTY
11461: LIST
11462: LIST
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: LIST
11468: PPUSH
11469: CALL_OW 69
11473: PPUSH
11474: LD_VAR 0 1
11478: PPUSH
11479: CALL_OW 74
11483: PPUSH
11484: CALL_OW 115
// end else
11488: GO 11517
// if IsDead ( i ) then
11490: LD_VAR 0 1
11494: PPUSH
11495: CALL_OW 301
11499: IFFALSE 11517
// tmp := tmp diff i ;
11501: LD_ADDR_VAR 0 2
11505: PUSH
11506: LD_VAR 0 2
11510: PUSH
11511: LD_VAR 0 1
11515: DIFF
11516: ST_TO_ADDR
// end ;
11517: GO 11349
11519: POP
11520: POP
// until not tmp ;
11521: LD_VAR 0 2
11525: NOT
11526: IFFALSE 11332
// end ;
11528: PPOPN 4
11530: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11531: LD_EXP 15
11535: PUSH
11536: LD_INT 7
11538: GREATEREQUAL
11539: PUSH
11540: LD_OWVAR 67
11544: PUSH
11545: LD_INT 1
11547: GREATER
11548: AND
11549: IFFALSE 11841
11551: GO 11553
11553: DISABLE
11554: LD_INT 0
11556: PPUSH
11557: PPUSH
11558: PPUSH
// begin ruMobile := [ ] ;
11559: LD_ADDR_EXP 77
11563: PUSH
11564: EMPTY
11565: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11566: LD_ADDR_VAR 0 1
11570: PUSH
11571: DOUBLE
11572: LD_INT 1
11574: DEC
11575: ST_TO_ADDR
11576: LD_INT 4
11578: PUSH
11579: LD_INT 5
11581: PUSH
11582: LD_INT 6
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: LIST
11589: PUSH
11590: LD_OWVAR 67
11594: PUSH
11595: LD_INT 1
11597: MINUS
11598: ARRAY
11599: PUSH
11600: FOR_TO
11601: IFFALSE 11839
// begin uc_side := 3 ;
11603: LD_ADDR_OWVAR 20
11607: PUSH
11608: LD_INT 3
11610: ST_TO_ADDR
// uc_nation := 1 ;
11611: LD_ADDR_OWVAR 21
11615: PUSH
11616: LD_INT 1
11618: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11619: LD_INT 5
11621: PPUSH
11622: LD_INT 3
11624: PPUSH
11625: LD_INT 1
11627: PPUSH
11628: LD_INT 9
11630: PUSH
11631: LD_INT 7
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_VAR 0 1
11642: PUSH
11643: LD_INT 2
11645: MOD
11646: PUSH
11647: LD_INT 1
11649: PLUS
11650: ARRAY
11651: PPUSH
11652: LD_INT 100
11654: PPUSH
11655: CALL 73898 0 5
// veh := CreateVehicle ;
11659: LD_ADDR_VAR 0 2
11663: PUSH
11664: CALL_OW 45
11668: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_INT 3
11676: PPUSH
11677: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11681: LD_VAR 0 2
11685: PPUSH
11686: LD_INT 29
11688: PPUSH
11689: LD_INT 0
11691: PPUSH
11692: CALL_OW 49
// uc_nation := 3 ;
11696: LD_ADDR_OWVAR 21
11700: PUSH
11701: LD_INT 3
11703: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11704: LD_INT 0
11706: PPUSH
11707: LD_INT 10
11709: PPUSH
11710: CALL_OW 383
// un := CreateHuman ;
11714: LD_ADDR_VAR 0 3
11718: PUSH
11719: CALL_OW 44
11723: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11724: LD_VAR 0 3
11728: PPUSH
11729: LD_INT 105
11731: PPUSH
11732: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11736: LD_VAR 0 3
11740: PPUSH
11741: LD_INT 3
11743: PPUSH
11744: CALL_OW 259
11748: PUSH
11749: LD_INT 8
11751: PUSH
11752: LD_INT 9
11754: PUSH
11755: LD_INT 10
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: LIST
11762: PUSH
11763: LD_OWVAR 67
11767: ARRAY
11768: LESS
11769: IFFALSE 11803
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11771: LD_VAR 0 3
11775: PPUSH
11776: LD_INT 3
11778: PPUSH
11779: LD_INT 8
11781: PUSH
11782: LD_INT 9
11784: PUSH
11785: LD_INT 10
11787: PUSH
11788: EMPTY
11789: LIST
11790: LIST
11791: LIST
11792: PUSH
11793: LD_OWVAR 67
11797: ARRAY
11798: PPUSH
11799: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
11803: LD_VAR 0 3
11807: PPUSH
11808: LD_VAR 0 2
11812: PPUSH
11813: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11817: LD_ADDR_EXP 77
11821: PUSH
11822: LD_EXP 77
11826: PPUSH
11827: LD_VAR 0 2
11831: PPUSH
11832: CALL 106760 0 2
11836: ST_TO_ADDR
// end ;
11837: GO 11600
11839: POP
11840: POP
// end ;
11841: PPOPN 3
11843: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11844: LD_EXP 77
11848: IFFALSE 12357
11850: GO 11852
11852: DISABLE
11853: LD_INT 0
11855: PPUSH
11856: PPUSH
11857: PPUSH
// begin enable ;
11858: ENABLE
// if not ruMobile then
11859: LD_EXP 77
11863: NOT
11864: IFFALSE 11869
// begin disable ;
11866: DISABLE
// exit ;
11867: GO 12357
// end ; for i in ruMobile do
11869: LD_ADDR_VAR 0 1
11873: PUSH
11874: LD_EXP 77
11878: PUSH
11879: FOR_IN
11880: IFFALSE 12355
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11882: LD_VAR 0 1
11886: PPUSH
11887: CALL_OW 302
11891: NOT
11892: PUSH
11893: LD_VAR 0 1
11897: PPUSH
11898: CALL_OW 255
11902: PUSH
11903: LD_INT 3
11905: NONEQUAL
11906: OR
11907: IFFALSE 11927
// begin ruMobile := ruMobile diff i ;
11909: LD_ADDR_EXP 77
11913: PUSH
11914: LD_EXP 77
11918: PUSH
11919: LD_VAR 0 1
11923: DIFF
11924: ST_TO_ADDR
// continue ;
11925: GO 11879
// end ; if GetTag ( i ) = 300 then
11927: LD_VAR 0 1
11931: PPUSH
11932: CALL_OW 110
11936: PUSH
11937: LD_INT 300
11939: EQUAL
11940: IFFALSE 11990
// begin ComMoveXY ( i , 160 , 81 ) ;
11942: LD_VAR 0 1
11946: PPUSH
11947: LD_INT 160
11949: PPUSH
11950: LD_INT 81
11952: PPUSH
11953: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11957: LD_VAR 0 1
11961: PPUSH
11962: LD_INT 160
11964: PPUSH
11965: LD_INT 81
11967: PPUSH
11968: CALL_OW 297
11972: PUSH
11973: LD_INT 8
11975: LESS
11976: IFFALSE 11990
// SetTag ( i , 301 ) ;
11978: LD_VAR 0 1
11982: PPUSH
11983: LD_INT 301
11985: PPUSH
11986: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11990: LD_VAR 0 1
11994: PPUSH
11995: CALL_OW 110
11999: PUSH
12000: LD_INT 301
12002: EQUAL
12003: IFFALSE 12046
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12005: LD_VAR 0 1
12009: PPUSH
12010: LD_INT 33
12012: PPUSH
12013: CALL_OW 308
12017: NOT
12018: IFFALSE 12034
// ComMoveToArea ( i , ruMobileParkingArea ) else
12020: LD_VAR 0 1
12024: PPUSH
12025: LD_INT 33
12027: PPUSH
12028: CALL_OW 113
12032: GO 12046
// SetTag ( i , 302 ) ;
12034: LD_VAR 0 1
12038: PPUSH
12039: LD_INT 302
12041: PPUSH
12042: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12046: LD_VAR 0 1
12050: PPUSH
12051: CALL_OW 110
12055: PUSH
12056: LD_INT 302
12058: EQUAL
12059: IFFALSE 12189
// begin if GetLives ( i ) < 1000 then
12061: LD_VAR 0 1
12065: PPUSH
12066: CALL_OW 256
12070: PUSH
12071: LD_INT 1000
12073: LESS
12074: IFFALSE 12166
// begin if not IsDrivenBy ( i ) then
12076: LD_VAR 0 1
12080: PPUSH
12081: CALL_OW 311
12085: NOT
12086: IFFALSE 12090
// continue ;
12088: GO 11879
// mech := IsDrivenBy ( i ) ;
12090: LD_ADDR_VAR 0 2
12094: PUSH
12095: LD_VAR 0 1
12099: PPUSH
12100: CALL_OW 311
12104: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12105: LD_VAR 0 2
12109: PPUSH
12110: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12114: LD_VAR 0 2
12118: PPUSH
12119: LD_VAR 0 1
12123: PPUSH
12124: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12128: LD_INT 35
12130: PPUSH
12131: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12135: LD_VAR 0 1
12139: PPUSH
12140: CALL_OW 256
12144: PUSH
12145: LD_INT 1000
12147: EQUAL
12148: IFFALSE 12128
// ComEnterUnit ( mech , i ) ;
12150: LD_VAR 0 2
12154: PPUSH
12155: LD_VAR 0 1
12159: PPUSH
12160: CALL_OW 120
// end else
12164: GO 12189
// if IsDrivenBy ( i ) then
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL_OW 311
12175: IFFALSE 12189
// SetTag ( i , 0 ) ;
12177: LD_VAR 0 1
12181: PPUSH
12182: LD_INT 0
12184: PPUSH
12185: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12189: LD_VAR 0 1
12193: PPUSH
12194: CALL_OW 110
12198: PUSH
12199: LD_INT 300
12201: LESS
12202: IFFALSE 12353
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12204: LD_ADDR_VAR 0 3
12208: PUSH
12209: LD_INT 4
12211: PPUSH
12212: LD_INT 81
12214: PUSH
12215: LD_INT 3
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PPUSH
12222: CALL_OW 70
12226: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 256
12236: PUSH
12237: LD_INT 650
12239: LESS
12240: IFFALSE 12265
// begin ComStop ( i ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: CALL_OW 141
// SetTag ( i , 300 ) ;
12251: LD_VAR 0 1
12255: PPUSH
12256: LD_INT 300
12258: PPUSH
12259: CALL_OW 109
// continue ;
12263: GO 11879
// end ; if enemy then
12265: LD_VAR 0 3
12269: IFFALSE 12309
// begin if not HasTask ( i ) then
12271: LD_VAR 0 1
12275: PPUSH
12276: CALL_OW 314
12280: NOT
12281: IFFALSE 12307
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12283: LD_VAR 0 1
12287: PPUSH
12288: LD_VAR 0 3
12292: PPUSH
12293: LD_VAR 0 1
12297: PPUSH
12298: CALL_OW 74
12302: PPUSH
12303: CALL_OW 115
// end else
12307: GO 12353
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12309: LD_VAR 0 1
12313: PPUSH
12314: LD_INT 158
12316: PUSH
12317: LD_INT 61
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PUSH
12324: LD_INT 98
12326: PUSH
12327: LD_INT 100
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: PUSH
12334: LD_INT 78
12336: PUSH
12337: LD_INT 93
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: LIST
12348: PPUSH
12349: CALL 109364 0 2
// end ; end ;
12353: GO 11879
12355: POP
12356: POP
// end ; end_of_file
12357: PPOPN 3
12359: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12360: LD_INT 0
12362: PPUSH
12363: PPUSH
12364: PPUSH
12365: PPUSH
12366: PPUSH
12367: PPUSH
12368: PPUSH
// side := 7 ;
12369: LD_ADDR_VAR 0 5
12373: PUSH
12374: LD_INT 7
12376: ST_TO_ADDR
// uc_side := side ;
12377: LD_ADDR_OWVAR 20
12381: PUSH
12382: LD_VAR 0 5
12386: ST_TO_ADDR
// uc_nation := 1 ;
12387: LD_ADDR_OWVAR 21
12391: PUSH
12392: LD_INT 1
12394: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12395: LD_ADDR_VAR 0 2
12399: PUSH
12400: LD_INT 22
12402: PUSH
12403: LD_VAR 0 5
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PUSH
12412: LD_INT 21
12414: PUSH
12415: LD_INT 3
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: PPUSH
12426: CALL_OW 69
12430: PUSH
12431: FOR_IN
12432: IFFALSE 12448
// SetBLevel ( i , 10 ) ;
12434: LD_VAR 0 2
12438: PPUSH
12439: LD_INT 10
12441: PPUSH
12442: CALL_OW 241
12446: GO 12431
12448: POP
12449: POP
// base := GetBase ( al_depot ) ;
12450: LD_ADDR_VAR 0 4
12454: PUSH
12455: LD_INT 2
12457: PPUSH
12458: CALL_OW 274
12462: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12463: LD_ADDR_VAR 0 6
12467: PUSH
12468: LD_INT 22
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 30
12482: PUSH
12483: LD_INT 34
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: PPUSH
12494: CALL_OW 69
12498: ST_TO_ADDR
// if teleport then
12499: LD_VAR 0 6
12503: IFFALSE 12524
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12505: LD_VAR 0 6
12509: PUSH
12510: LD_INT 1
12512: ARRAY
12513: PPUSH
12514: LD_INT 262
12516: PPUSH
12517: LD_INT 119
12519: PPUSH
12520: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12524: LD_VAR 0 4
12528: PPUSH
12529: LD_INT 1
12531: PPUSH
12532: LD_INT 19500
12534: PPUSH
12535: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12539: LD_VAR 0 4
12543: PPUSH
12544: LD_INT 2
12546: PPUSH
12547: LD_INT 200
12549: PPUSH
12550: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12554: LD_VAR 0 4
12558: PPUSH
12559: LD_INT 3
12561: PPUSH
12562: LD_INT 650
12564: PPUSH
12565: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12569: LD_ADDR_EXP 78
12573: PUSH
12574: LD_STRING Roth
12576: PPUSH
12577: CALL_OW 25
12581: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12582: LD_ADDR_EXP 79
12586: PUSH
12587: LD_STRING Simms
12589: PPUSH
12590: LD_EXP 1
12594: NOT
12595: PPUSH
12596: LD_STRING 10c_
12598: PPUSH
12599: CALL 69058 0 3
12603: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12604: LD_EXP 79
12608: PPUSH
12609: LD_INT 4
12611: PPUSH
12612: CALL_OW 336
// if not Simms then
12616: LD_EXP 79
12620: NOT
12621: IFFALSE 12651
// begin uc_nation := 1 ;
12623: LD_ADDR_OWVAR 21
12627: PUSH
12628: LD_INT 1
12630: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12631: LD_INT 2
12633: PPUSH
12634: LD_INT 10
12636: PPUSH
12637: CALL_OW 384
// Simms := CreateHuman ;
12641: LD_ADDR_EXP 79
12645: PUSH
12646: CALL_OW 44
12650: ST_TO_ADDR
// end ; uc_nation := 3 ;
12651: LD_ADDR_OWVAR 21
12655: PUSH
12656: LD_INT 3
12658: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12659: LD_ADDR_EXP 80
12663: PUSH
12664: LD_STRING Kirilenkova
12666: PPUSH
12667: CALL_OW 25
12671: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12672: LD_ADDR_EXP 94
12676: PUSH
12677: LD_STRING Oblukov
12679: PPUSH
12680: CALL_OW 25
12684: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12685: LD_ADDR_EXP 81
12689: PUSH
12690: LD_STRING Dolgov
12692: PPUSH
12693: CALL_OW 25
12697: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12698: LD_ADDR_EXP 82
12702: PUSH
12703: LD_STRING Petrosyan
12705: PPUSH
12706: CALL_OW 25
12710: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12711: LD_ADDR_EXP 93
12715: PUSH
12716: LD_STRING Scholtze
12718: PPUSH
12719: CALL_OW 25
12723: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12724: LD_ADDR_EXP 92
12728: PUSH
12729: LD_STRING Kapitsova
12731: PPUSH
12732: CALL_OW 25
12736: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12737: LD_ADDR_EXP 83
12741: PUSH
12742: LD_STRING Petrovova
12744: PPUSH
12745: CALL_OW 25
12749: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12750: LD_ADDR_EXP 84
12754: PUSH
12755: LD_STRING Kuzmov
12757: PPUSH
12758: CALL_OW 25
12762: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12763: LD_ADDR_EXP 91
12767: PUSH
12768: LD_STRING Karamazov
12770: PPUSH
12771: CALL_OW 25
12775: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12776: LD_STRING 13_Lipshchin_1
12778: PPUSH
12779: LD_INT 0
12781: PPUSH
12782: CALL_OW 30
12786: IFFALSE 12801
// Lipshchin := NewCharacter ( Lipshchin ) ;
12788: LD_ADDR_EXP 85
12792: PUSH
12793: LD_STRING Lipshchin
12795: PPUSH
12796: CALL_OW 25
12800: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12801: LD_STRING 13_Titov_1
12803: PPUSH
12804: LD_INT 0
12806: PPUSH
12807: CALL_OW 30
12811: IFFALSE 12826
// Titov := NewCharacter ( Titov ) ;
12813: LD_ADDR_EXP 87
12817: PUSH
12818: LD_STRING Titov
12820: PPUSH
12821: CALL_OW 25
12825: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12826: LD_STRING 13_Gnyevko_1
12828: PPUSH
12829: LD_INT 0
12831: PPUSH
12832: CALL_OW 30
12836: IFFALSE 12851
// Gnyevko := NewCharacter ( Gnyevko ) ;
12838: LD_ADDR_EXP 86
12842: PUSH
12843: LD_STRING Gnyevko
12845: PPUSH
12846: CALL_OW 25
12850: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12851: LD_STRING 13_Xavier_1
12853: PPUSH
12854: LD_INT 0
12856: PPUSH
12857: CALL_OW 30
12861: IFFALSE 12876
// Xavier := NewCharacter ( Xavier2 ) ;
12863: LD_ADDR_EXP 88
12867: PUSH
12868: LD_STRING Xavier2
12870: PPUSH
12871: CALL_OW 25
12875: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12876: LD_STRING 13_Belkov_1
12878: PPUSH
12879: LD_INT 0
12881: PPUSH
12882: CALL_OW 30
12886: IFFALSE 12901
// Belkov := NewCharacter ( Belkov ) ;
12888: LD_ADDR_EXP 89
12892: PUSH
12893: LD_STRING Belkov
12895: PPUSH
12896: CALL_OW 25
12900: ST_TO_ADDR
// if not BurlakStatus then
12901: LD_EXP 9
12905: NOT
12906: IFFALSE 12921
// Burlak = NewCharacter ( Burlak ) ;
12908: LD_ADDR_EXP 90
12912: PUSH
12913: LD_STRING Burlak
12915: PPUSH
12916: CALL_OW 25
12920: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12921: LD_ADDR_VAR 0 3
12925: PUSH
12926: LD_EXP 78
12930: PUSH
12931: LD_EXP 80
12935: PUSH
12936: LD_EXP 94
12940: PUSH
12941: LD_EXP 81
12945: PUSH
12946: LD_EXP 82
12950: PUSH
12951: LD_EXP 93
12955: PUSH
12956: LD_EXP 92
12960: PUSH
12961: LD_EXP 83
12965: PUSH
12966: LD_EXP 84
12970: PUSH
12971: LD_EXP 91
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: ST_TO_ADDR
// if Simms then
12988: LD_EXP 79
12992: IFFALSE 13010
// tmp := tmp ^ Simms ;
12994: LD_ADDR_VAR 0 3
12998: PUSH
12999: LD_VAR 0 3
13003: PUSH
13004: LD_EXP 79
13008: ADD
13009: ST_TO_ADDR
// if Titov then
13010: LD_EXP 87
13014: IFFALSE 13032
// tmp := tmp ^ Titov ;
13016: LD_ADDR_VAR 0 3
13020: PUSH
13021: LD_VAR 0 3
13025: PUSH
13026: LD_EXP 87
13030: ADD
13031: ST_TO_ADDR
// if Lipshchin then
13032: LD_EXP 85
13036: IFFALSE 13054
// tmp := tmp ^ Lipshchin ;
13038: LD_ADDR_VAR 0 3
13042: PUSH
13043: LD_VAR 0 3
13047: PUSH
13048: LD_EXP 85
13052: ADD
13053: ST_TO_ADDR
// if Gnyevko then
13054: LD_EXP 86
13058: IFFALSE 13076
// tmp := tmp ^ Gnyevko ;
13060: LD_ADDR_VAR 0 3
13064: PUSH
13065: LD_VAR 0 3
13069: PUSH
13070: LD_EXP 86
13074: ADD
13075: ST_TO_ADDR
// if Xavier then
13076: LD_EXP 88
13080: IFFALSE 13098
// tmp := tmp ^ Xavier ;
13082: LD_ADDR_VAR 0 3
13086: PUSH
13087: LD_VAR 0 3
13091: PUSH
13092: LD_EXP 88
13096: ADD
13097: ST_TO_ADDR
// if Belkov then
13098: LD_EXP 89
13102: IFFALSE 13120
// tmp := tmp ^ Belkov ;
13104: LD_ADDR_VAR 0 3
13108: PUSH
13109: LD_VAR 0 3
13113: PUSH
13114: LD_EXP 89
13118: ADD
13119: ST_TO_ADDR
// if Burlak then
13120: LD_EXP 90
13124: IFFALSE 13142
// tmp := tmp ^ Burlak ;
13126: LD_ADDR_VAR 0 3
13130: PUSH
13131: LD_VAR 0 3
13135: PUSH
13136: LD_EXP 90
13140: ADD
13141: ST_TO_ADDR
// for i = 1 to 11 do
13142: LD_ADDR_VAR 0 2
13146: PUSH
13147: DOUBLE
13148: LD_INT 1
13150: DEC
13151: ST_TO_ADDR
13152: LD_INT 11
13154: PUSH
13155: FOR_TO
13156: IFFALSE 13224
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13158: LD_ADDR_OWVAR 21
13162: PUSH
13163: LD_INT 1
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 1
13175: PPUSH
13176: LD_INT 2
13178: PPUSH
13179: CALL_OW 12
13183: ARRAY
13184: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13185: LD_INT 0
13187: PPUSH
13188: LD_INT 1
13190: PPUSH
13191: LD_INT 4
13193: PPUSH
13194: CALL_OW 12
13198: PPUSH
13199: LD_INT 10
13201: PPUSH
13202: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13206: LD_ADDR_VAR 0 3
13210: PUSH
13211: LD_VAR 0 3
13215: PUSH
13216: CALL_OW 44
13220: ADD
13221: ST_TO_ADDR
// end ;
13222: GO 13155
13224: POP
13225: POP
// for i in tmp do
13226: LD_ADDR_VAR 0 2
13230: PUSH
13231: LD_VAR 0 3
13235: PUSH
13236: FOR_IN
13237: IFFALSE 13262
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13239: LD_VAR 0 2
13243: PPUSH
13244: LD_INT 260
13246: PPUSH
13247: LD_INT 235
13249: PPUSH
13250: LD_INT 8
13252: PPUSH
13253: LD_INT 0
13255: PPUSH
13256: CALL_OW 50
13260: GO 13236
13262: POP
13263: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13264: LD_ADDR_EXP 101
13268: PUSH
13269: LD_EXP 101
13273: PPUSH
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 22
13279: PUSH
13280: LD_VAR 0 5
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: PUSH
13289: LD_INT 3
13291: PUSH
13292: LD_INT 21
13294: PUSH
13295: LD_INT 2
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: PPUSH
13310: CALL_OW 69
13314: PUSH
13315: LD_EXP 78
13319: PUSH
13320: LD_EXP 79
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: DIFF
13329: PPUSH
13330: CALL_OW 1
13334: ST_TO_ADDR
// uc_side := 0 ;
13335: LD_ADDR_OWVAR 20
13339: PUSH
13340: LD_INT 0
13342: ST_TO_ADDR
// uc_nation := 0 ;
13343: LD_ADDR_OWVAR 21
13347: PUSH
13348: LD_INT 0
13350: ST_TO_ADDR
// for i = 1 to 5 do
13351: LD_ADDR_VAR 0 2
13355: PUSH
13356: DOUBLE
13357: LD_INT 1
13359: DEC
13360: ST_TO_ADDR
13361: LD_INT 5
13363: PUSH
13364: FOR_TO
13365: IFFALSE 13402
// begin InitHc ;
13367: CALL_OW 19
// hc_class := class_apeman ;
13371: LD_ADDR_OWVAR 28
13375: PUSH
13376: LD_INT 12
13378: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13379: CALL_OW 44
13383: PPUSH
13384: LD_INT 299
13386: PPUSH
13387: LD_INT 229
13389: PPUSH
13390: LD_INT 10
13392: PPUSH
13393: LD_INT 0
13395: PPUSH
13396: CALL_OW 50
// end ;
13400: GO 13364
13402: POP
13403: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13404: LD_EXP 78
13408: PPUSH
13409: LD_INT 259
13411: PPUSH
13412: LD_INT 235
13414: PPUSH
13415: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13419: LD_EXP 78
13423: PPUSH
13424: LD_INT 262
13426: PPUSH
13427: LD_INT 235
13429: PPUSH
13430: CALL_OW 178
// if Simms then
13434: LD_EXP 79
13438: IFFALSE 13469
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13440: LD_EXP 79
13444: PPUSH
13445: LD_INT 262
13447: PPUSH
13448: LD_INT 235
13450: PPUSH
13451: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13455: LD_EXP 79
13459: PPUSH
13460: LD_EXP 78
13464: PPUSH
13465: CALL_OW 179
// end ; uc_side := 7 ;
13469: LD_ADDR_OWVAR 20
13473: PUSH
13474: LD_INT 7
13476: ST_TO_ADDR
// uc_nation := 1 ;
13477: LD_ADDR_OWVAR 21
13481: PUSH
13482: LD_INT 1
13484: ST_TO_ADDR
// bc_type := b_control_tower ;
13485: LD_ADDR_OWVAR 42
13489: PUSH
13490: LD_INT 36
13492: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13493: LD_ADDR_VAR 0 7
13497: PUSH
13498: LD_INT 268
13500: PPUSH
13501: LD_INT 251
13503: PPUSH
13504: LD_INT 4
13506: PPUSH
13507: CALL_OW 47
13511: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13512: LD_INT 0
13514: PPUSH
13515: LD_INT 10
13517: PPUSH
13518: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13522: CALL_OW 44
13526: PPUSH
13527: LD_VAR 0 7
13531: PPUSH
13532: CALL_OW 52
// end ;
13536: LD_VAR 0 1
13540: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13541: LD_EXP 31
13545: PUSH
13546: LD_EXP 23
13550: NOT
13551: AND
13552: IFFALSE 13780
13554: GO 13556
13556: DISABLE
13557: LD_INT 0
13559: PPUSH
13560: PPUSH
13561: PPUSH
// begin enable ;
13562: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13563: LD_ADDR_VAR 0 2
13567: PUSH
13568: LD_INT 81
13570: PUSH
13571: LD_INT 7
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 2
13580: PUSH
13581: LD_INT 32
13583: PUSH
13584: LD_INT 3
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 30
13593: PUSH
13594: LD_INT 30
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 30
13603: PUSH
13604: LD_INT 28
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 34
13613: PUSH
13614: LD_INT 49
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 34
13623: PUSH
13624: LD_INT 10
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 34
13633: PUSH
13634: LD_INT 8
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: PPUSH
13654: CALL_OW 69
13658: ST_TO_ADDR
// if not tmp then
13659: LD_VAR 0 2
13663: NOT
13664: IFFALSE 13668
// exit ;
13666: GO 13780
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13668: LD_VAR 0 2
13672: PPUSH
13673: LD_INT 34
13675: PUSH
13676: LD_INT 8
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: PPUSH
13683: CALL_OW 72
13687: IFFALSE 13720
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13689: LD_ADDR_VAR 0 3
13693: PUSH
13694: LD_VAR 0 2
13698: PPUSH
13699: LD_INT 34
13701: PUSH
13702: LD_INT 8
13704: PUSH
13705: EMPTY
13706: LIST
13707: LIST
13708: PPUSH
13709: CALL_OW 72
13713: PUSH
13714: LD_INT 1
13716: ARRAY
13717: ST_TO_ADDR
13718: GO 13744
// target := tmp [ rand ( 1 , tmp ) ] ;
13720: LD_ADDR_VAR 0 3
13724: PUSH
13725: LD_VAR 0 2
13729: PUSH
13730: LD_INT 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL_OW 12
13742: ARRAY
13743: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13744: LD_VAR 0 3
13748: PPUSH
13749: CALL_OW 255
13753: PUSH
13754: LD_INT 1
13756: EQUAL
13757: IFFALSE 13768
// CenterNowOnUnits ( target ) ;
13759: LD_VAR 0 3
13763: PPUSH
13764: CALL_OW 87
// SetLives ( target , 0 ) ;
13768: LD_VAR 0 3
13772: PPUSH
13773: LD_INT 0
13775: PPUSH
13776: CALL_OW 234
// end ;
13780: PPOPN 3
13782: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13783: LD_EXP 23
13787: NOT
13788: PUSH
13789: LD_EXP 31
13793: AND
13794: IFFALSE 14310
13796: GO 13798
13798: DISABLE
13799: LD_INT 0
13801: PPUSH
13802: PPUSH
13803: PPUSH
// begin uc_side := 7 ;
13804: LD_ADDR_OWVAR 20
13808: PUSH
13809: LD_INT 7
13811: ST_TO_ADDR
// uc_nation := 1 ;
13812: LD_ADDR_OWVAR 21
13816: PUSH
13817: LD_INT 1
13819: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
13820: LD_ADDR_VAR 0 3
13824: PUSH
13825: LD_INT 125
13827: PUSH
13828: LD_INT 163
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: LD_INT 185
13837: PUSH
13838: LD_INT 168
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: PUSH
13845: LD_INT 111
13847: PUSH
13848: LD_INT 97
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PUSH
13855: LD_INT 94
13857: PUSH
13858: LD_INT 114
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: PUSH
13865: EMPTY
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: PPUSH
13871: CALL 106865 0 1
13875: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13876: LD_ADDR_EXP 95
13880: PUSH
13881: EMPTY
13882: ST_TO_ADDR
// for i = 1 to Difficulty do
13883: LD_ADDR_VAR 0 1
13887: PUSH
13888: DOUBLE
13889: LD_INT 1
13891: DEC
13892: ST_TO_ADDR
13893: LD_OWVAR 67
13897: PUSH
13898: FOR_TO
13899: IFFALSE 14057
// begin InitHc ;
13901: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13905: LD_INT 0
13907: PPUSH
13908: LD_INT 8
13910: PPUSH
13911: CALL_OW 381
// un := CreateHuman ;
13915: LD_ADDR_VAR 0 2
13919: PUSH
13920: CALL_OW 44
13924: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13925: LD_VAR 0 2
13929: PPUSH
13930: LD_INT 258
13932: PPUSH
13933: LD_INT 267
13935: PPUSH
13936: LD_INT 4
13938: PPUSH
13939: LD_INT 0
13941: PPUSH
13942: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13946: LD_ADDR_EXP 95
13950: PUSH
13951: LD_EXP 95
13955: PUSH
13956: LD_VAR 0 2
13960: UNION
13961: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13962: LD_VAR 0 2
13966: PPUSH
13967: LD_VAR 0 3
13971: PUSH
13972: LD_VAR 0 1
13976: ARRAY
13977: PUSH
13978: LD_INT 1
13980: ARRAY
13981: PPUSH
13982: LD_VAR 0 3
13986: PUSH
13987: LD_VAR 0 1
13991: ARRAY
13992: PUSH
13993: LD_INT 2
13995: ARRAY
13996: PPUSH
13997: LD_INT 4
13999: PPUSH
14000: LD_INT 1
14002: PPUSH
14003: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14007: LD_VAR 0 2
14011: PPUSH
14012: LD_VAR 0 3
14016: PUSH
14017: LD_VAR 0 1
14021: ARRAY
14022: PUSH
14023: LD_INT 1
14025: ARRAY
14026: PPUSH
14027: LD_VAR 0 3
14031: PUSH
14032: LD_VAR 0 1
14036: ARRAY
14037: PUSH
14038: LD_INT 2
14040: ARRAY
14041: PPUSH
14042: CALL_OW 171
// AddComInvisible ( un ) ;
14046: LD_VAR 0 2
14050: PPUSH
14051: CALL_OW 212
// end ;
14055: GO 13898
14057: POP
14058: POP
// repeat wait ( 0 0$45 ) ;
14059: LD_INT 1575
14061: PPUSH
14062: CALL_OW 67
// for i in allianceSpecialForce do
14066: LD_ADDR_VAR 0 1
14070: PUSH
14071: LD_EXP 95
14075: PUSH
14076: FOR_IN
14077: IFFALSE 14295
// begin if IsInvisible ( i ) then
14079: LD_VAR 0 1
14083: PPUSH
14084: CALL_OW 571
14088: IFFALSE 14264
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14090: LD_ADDR_VAR 0 3
14094: PUSH
14095: LD_INT 22
14097: PUSH
14098: LD_INT 1
14100: PUSH
14101: EMPTY
14102: LIST
14103: LIST
14104: PUSH
14105: LD_INT 50
14107: PUSH
14108: EMPTY
14109: LIST
14110: PUSH
14111: LD_INT 56
14113: PUSH
14114: EMPTY
14115: LIST
14116: PUSH
14117: LD_INT 91
14119: PUSH
14120: LD_VAR 0 1
14124: PUSH
14125: LD_INT 25
14127: PUSH
14128: EMPTY
14129: LIST
14130: LIST
14131: LIST
14132: PUSH
14133: LD_INT 2
14135: PUSH
14136: LD_INT 25
14138: PUSH
14139: LD_INT 1
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: LD_INT 25
14148: PUSH
14149: LD_INT 2
14151: PUSH
14152: EMPTY
14153: LIST
14154: LIST
14155: PUSH
14156: LD_INT 25
14158: PUSH
14159: LD_INT 3
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: PUSH
14166: LD_INT 25
14168: PUSH
14169: LD_INT 4
14171: PUSH
14172: EMPTY
14173: LIST
14174: LIST
14175: PUSH
14176: LD_INT 25
14178: PUSH
14179: LD_INT 5
14181: PUSH
14182: EMPTY
14183: LIST
14184: LIST
14185: PUSH
14186: LD_INT 25
14188: PUSH
14189: LD_INT 8
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: PUSH
14205: EMPTY
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: PPUSH
14212: CALL_OW 69
14216: ST_TO_ADDR
// if not tmp then
14217: LD_VAR 0 3
14221: NOT
14222: IFFALSE 14226
// continue ;
14224: GO 14076
// if Prob ( 30 * Difficulty ) then
14226: LD_INT 30
14228: PUSH
14229: LD_OWVAR 67
14233: MUL
14234: PPUSH
14235: CALL_OW 13
14239: IFFALSE 14264
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14241: LD_VAR 0 3
14245: PUSH
14246: LD_INT 1
14248: PPUSH
14249: LD_VAR 0 3
14253: PPUSH
14254: CALL_OW 12
14258: ARRAY
14259: PPUSH
14260: CALL 34227 0 1
// end ; if IsDead ( i ) then
14264: LD_VAR 0 1
14268: PPUSH
14269: CALL_OW 301
14273: IFFALSE 14293
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14275: LD_ADDR_EXP 95
14279: PUSH
14280: LD_EXP 95
14284: PUSH
14285: LD_VAR 0 1
14289: DIFF
14290: ST_TO_ADDR
// continue ;
14291: GO 14076
// end ; end ;
14293: GO 14076
14295: POP
14296: POP
// until allianceDestroyed or not allianceSpecialForce ;
14297: LD_EXP 23
14301: PUSH
14302: LD_EXP 95
14306: NOT
14307: OR
14308: IFFALSE 14059
// end ;
14310: PPOPN 3
14312: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14313: LD_EXP 31
14317: PUSH
14318: LD_INT 22
14320: PUSH
14321: LD_INT 1
14323: PUSH
14324: EMPTY
14325: LIST
14326: LIST
14327: PUSH
14328: LD_INT 2
14330: PUSH
14331: LD_INT 35
14333: PUSH
14334: LD_INT 8
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: PUSH
14341: LD_INT 34
14343: PUSH
14344: LD_INT 8
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: PUSH
14351: EMPTY
14352: LIST
14353: LIST
14354: LIST
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PPUSH
14360: CALL_OW 69
14364: AND
14365: IFFALSE 14765
14367: GO 14369
14369: DISABLE
14370: LD_INT 0
14372: PPUSH
14373: PPUSH
14374: PPUSH
14375: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14376: LD_ADDR_VAR 0 1
14380: PUSH
14381: DOUBLE
14382: LD_INT 1
14384: DEC
14385: ST_TO_ADDR
14386: LD_INT 6
14388: PUSH
14389: LD_INT 8
14391: PUSH
14392: LD_INT 10
14394: PUSH
14395: LD_INT 12
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: PUSH
14404: LD_OWVAR 67
14408: ARRAY
14409: PUSH
14410: FOR_TO
14411: IFFALSE 14603
// begin uc_side := 7 ;
14413: LD_ADDR_OWVAR 20
14417: PUSH
14418: LD_INT 7
14420: ST_TO_ADDR
// uc_nation := 1 ;
14421: LD_ADDR_OWVAR 21
14425: PUSH
14426: LD_INT 1
14428: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14429: LD_INT 5
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: LD_INT 2
14437: PUSH
14438: LD_INT 3
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 1
14447: PPUSH
14448: LD_INT 2
14450: PPUSH
14451: CALL_OW 12
14455: ARRAY
14456: PPUSH
14457: LD_INT 6
14459: PUSH
14460: LD_INT 9
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PUSH
14467: LD_INT 1
14469: PPUSH
14470: LD_INT 2
14472: PPUSH
14473: CALL_OW 12
14477: ARRAY
14478: PPUSH
14479: LD_INT 100
14481: PPUSH
14482: CALL 73898 0 5
// un := CreateVehicle ;
14486: LD_ADDR_VAR 0 2
14490: PUSH
14491: CALL_OW 45
14495: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14496: LD_VAR 0 2
14500: PPUSH
14501: LD_INT 4
14503: PPUSH
14504: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14508: LD_VAR 0 2
14512: PPUSH
14513: LD_INT 307
14515: PPUSH
14516: LD_INT 219
14518: PPUSH
14519: LD_INT 6
14521: PPUSH
14522: LD_INT 0
14524: PPUSH
14525: CALL_OW 50
// if GetControl ( un ) = control_remote then
14529: LD_VAR 0 2
14533: PPUSH
14534: CALL_OW 263
14538: PUSH
14539: LD_INT 2
14541: EQUAL
14542: IFFALSE 14553
// Connect ( un ) ;
14544: LD_VAR 0 2
14548: PPUSH
14549: CALL 77366 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14553: LD_VAR 0 2
14557: PPUSH
14558: LD_INT 124
14560: PPUSH
14561: LD_INT 92
14563: PPUSH
14564: LD_INT 12
14566: PPUSH
14567: LD_INT 1
14569: PPUSH
14570: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14574: LD_ADDR_VAR 0 3
14578: PUSH
14579: LD_VAR 0 3
14583: PPUSH
14584: LD_VAR 0 2
14588: PPUSH
14589: CALL 106760 0 2
14593: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14594: LD_INT 10
14596: PPUSH
14597: CALL_OW 67
// end ;
14601: GO 14410
14603: POP
14604: POP
// repeat wait ( 0 0$2 ) ;
14605: LD_INT 70
14607: PPUSH
14608: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14612: LD_ADDR_VAR 0 4
14616: PUSH
14617: LD_INT 22
14619: PUSH
14620: LD_INT 1
14622: PUSH
14623: EMPTY
14624: LIST
14625: LIST
14626: PUSH
14627: LD_INT 34
14629: PUSH
14630: LD_INT 8
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: PPUSH
14641: CALL_OW 69
14645: ST_TO_ADDR
// if not e then
14646: LD_VAR 0 4
14650: NOT
14651: IFFALSE 14687
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14653: LD_ADDR_VAR 0 4
14657: PUSH
14658: LD_INT 22
14660: PUSH
14661: LD_INT 1
14663: PUSH
14664: EMPTY
14665: LIST
14666: LIST
14667: PUSH
14668: LD_INT 21
14670: PUSH
14671: LD_INT 2
14673: PUSH
14674: EMPTY
14675: LIST
14676: LIST
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: PPUSH
14682: CALL_OW 69
14686: ST_TO_ADDR
// for i in tmp do
14687: LD_ADDR_VAR 0 1
14691: PUSH
14692: LD_VAR 0 3
14696: PUSH
14697: FOR_IN
14698: IFFALSE 14756
// if not IsOK ( i ) then
14700: LD_VAR 0 1
14704: PPUSH
14705: CALL_OW 302
14709: NOT
14710: IFFALSE 14730
// tmp := tmp diff i else
14712: LD_ADDR_VAR 0 3
14716: PUSH
14717: LD_VAR 0 3
14721: PUSH
14722: LD_VAR 0 1
14726: DIFF
14727: ST_TO_ADDR
14728: GO 14754
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_VAR 0 4
14739: PPUSH
14740: LD_VAR 0 1
14744: PPUSH
14745: CALL_OW 74
14749: PPUSH
14750: CALL_OW 115
14754: GO 14697
14756: POP
14757: POP
// until not tmp ;
14758: LD_VAR 0 3
14762: NOT
14763: IFFALSE 14605
// end ;
14765: PPOPN 4
14767: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
14768: LD_EXP 23
14772: NOT
14773: PUSH
14774: LD_EXP 31
14778: AND
14779: IFFALSE 15729
14781: GO 14783
14783: DISABLE
14784: LD_INT 0
14786: PPUSH
14787: PPUSH
14788: PPUSH
14789: PPUSH
// begin enable ;
14790: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14791: LD_INT 22
14793: PUSH
14794: LD_INT 7
14796: PUSH
14797: EMPTY
14798: LIST
14799: LIST
14800: PUSH
14801: LD_INT 30
14803: PUSH
14804: LD_INT 3
14806: PUSH
14807: EMPTY
14808: LIST
14809: LIST
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: PPUSH
14815: CALL_OW 69
14819: NOT
14820: IFFALSE 14824
// exit ;
14822: GO 15729
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
14824: LD_ADDR_VAR 0 4
14828: PUSH
14829: LD_INT 22
14831: PUSH
14832: LD_INT 7
14834: PUSH
14835: EMPTY
14836: LIST
14837: LIST
14838: PUSH
14839: LD_INT 30
14841: PUSH
14842: LD_INT 34
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PPUSH
14853: CALL_OW 69
14857: ST_TO_ADDR
// if Prob ( 40 ) then
14858: LD_INT 40
14860: PPUSH
14861: CALL_OW 13
14865: IFFALSE 15011
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
14867: LD_INT 1
14869: PPUSH
14870: LD_INT 5
14872: PUSH
14873: LD_INT 3
14875: PUSH
14876: LD_INT 2
14878: PUSH
14879: LD_INT 6
14881: PUSH
14882: EMPTY
14883: LIST
14884: LIST
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 5
14890: PUSH
14891: LD_INT 3
14893: PUSH
14894: LD_INT 2
14896: PUSH
14897: LD_INT 6
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: LIST
14904: LIST
14905: PUSH
14906: LD_INT 5
14908: PUSH
14909: LD_INT 3
14911: PUSH
14912: LD_INT 2
14914: PUSH
14915: LD_INT 6
14917: PUSH
14918: EMPTY
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: PUSH
14924: LD_INT 5
14926: PUSH
14927: LD_INT 3
14929: PUSH
14930: LD_INT 2
14932: PUSH
14933: LD_INT 9
14935: PUSH
14936: EMPTY
14937: LIST
14938: LIST
14939: LIST
14940: LIST
14941: PUSH
14942: LD_INT 24
14944: PUSH
14945: LD_INT 3
14947: PUSH
14948: LD_INT 3
14950: PUSH
14951: LD_INT 45
14953: PUSH
14954: EMPTY
14955: LIST
14956: LIST
14957: LIST
14958: LIST
14959: PUSH
14960: LD_INT 24
14962: PUSH
14963: LD_INT 3
14965: PUSH
14966: LD_INT 3
14968: PUSH
14969: LD_INT 47
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 24
14980: PUSH
14981: LD_INT 3
14983: PUSH
14984: LD_INT 3
14986: PUSH
14987: LD_INT 45
14989: PUSH
14990: EMPTY
14991: LIST
14992: LIST
14993: LIST
14994: LIST
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: PPUSH
15005: CALL 62632 0 2
// end else
15009: GO 15153
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15011: LD_INT 1
15013: PPUSH
15014: LD_INT 24
15016: PUSH
15017: LD_INT 3
15019: PUSH
15020: LD_INT 3
15022: PUSH
15023: LD_INT 47
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: PUSH
15032: LD_INT 24
15034: PUSH
15035: LD_INT 3
15037: PUSH
15038: LD_INT 3
15040: PUSH
15041: LD_INT 47
15043: PUSH
15044: EMPTY
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: PUSH
15050: LD_INT 5
15052: PUSH
15053: LD_INT 3
15055: PUSH
15056: LD_INT 2
15058: PUSH
15059: LD_INT 9
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: PUSH
15068: LD_INT 5
15070: PUSH
15071: LD_INT 3
15073: PUSH
15074: LD_INT 2
15076: PUSH
15077: LD_INT 9
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: PUSH
15086: LD_INT 5
15088: PUSH
15089: LD_INT 3
15091: PUSH
15092: LD_INT 2
15094: PUSH
15095: LD_INT 9
15097: PUSH
15098: EMPTY
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 24
15106: PUSH
15107: LD_INT 1
15109: PUSH
15110: LD_INT 3
15112: PUSH
15113: LD_INT 45
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: PUSH
15122: LD_INT 24
15124: PUSH
15125: LD_INT 1
15127: PUSH
15128: LD_INT 3
15130: PUSH
15131: LD_INT 45
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL 62632 0 2
// end ; repeat wait ( 0 0$1 ) ;
15153: LD_INT 35
15155: PPUSH
15156: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
15160: LD_INT 1
15162: PPUSH
15163: LD_INT 1
15165: PPUSH
15166: CALL 64050 0 2
15170: PUSH
15171: LD_INT 7
15173: GREATEREQUAL
15174: IFFALSE 15153
// wait ( 0 0$10 ) ;
15176: LD_INT 350
15178: PPUSH
15179: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
15183: LD_ADDR_VAR 0 2
15187: PUSH
15188: LD_INT 1
15190: PPUSH
15191: LD_INT 1
15193: PPUSH
15194: CALL 64050 0 2
15198: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15199: LD_ADDR_EXP 120
15203: PUSH
15204: LD_EXP 120
15208: PPUSH
15209: LD_INT 1
15211: PPUSH
15212: LD_EXP 120
15216: PUSH
15217: LD_INT 1
15219: ARRAY
15220: PUSH
15221: LD_VAR 0 2
15225: DIFF
15226: PPUSH
15227: CALL_OW 1
15231: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: PPUSH
15240: LD_INT 1
15242: PPUSH
15243: CALL_OW 12
15247: ST_TO_ADDR
// if target then
15248: LD_VAR 0 3
15252: IFFALSE 15418
// begin for i in tmp do
15254: LD_ADDR_VAR 0 1
15258: PUSH
15259: LD_VAR 0 2
15263: PUSH
15264: FOR_IN
15265: IFFALSE 15290
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15267: LD_VAR 0 1
15271: PPUSH
15272: LD_INT 179
15274: PPUSH
15275: LD_INT 209
15277: PPUSH
15278: LD_INT 8
15280: PPUSH
15281: LD_INT 1
15283: PPUSH
15284: CALL_OW 483
15288: GO 15264
15290: POP
15291: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15292: LD_ADDR_VAR 0 2
15296: PUSH
15297: LD_VAR 0 2
15301: PPUSH
15302: LD_INT 24
15304: PUSH
15305: LD_INT 250
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PPUSH
15312: CALL_OW 72
15316: ST_TO_ADDR
// for i in tmp do
15317: LD_ADDR_VAR 0 1
15321: PUSH
15322: LD_VAR 0 2
15326: PUSH
15327: FOR_IN
15328: IFFALSE 15368
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15330: LD_VAR 0 1
15334: PPUSH
15335: LD_INT 179
15337: PPUSH
15338: LD_INT 209
15340: PPUSH
15341: CALL_OW 297
15345: PUSH
15346: LD_INT 9
15348: GREATER
15349: IFFALSE 15366
// ComMoveXY ( i , 179 , 209 ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: LD_INT 179
15358: PPUSH
15359: LD_INT 209
15361: PPUSH
15362: CALL_OW 111
15366: GO 15327
15368: POP
15369: POP
// wait ( 0 0$1 ) ;
15370: LD_INT 35
15372: PPUSH
15373: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
15377: LD_VAR 0 2
15381: PPUSH
15382: LD_INT 92
15384: PUSH
15385: LD_INT 179
15387: PUSH
15388: LD_INT 209
15390: PUSH
15391: LD_INT 9
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: PPUSH
15400: CALL_OW 72
15404: PUSH
15405: LD_VAR 0 2
15409: PUSH
15410: LD_INT 1
15412: MINUS
15413: GREATEREQUAL
15414: IFFALSE 15292
// end else
15416: GO 15580
// begin for i in tmp do
15418: LD_ADDR_VAR 0 1
15422: PUSH
15423: LD_VAR 0 2
15427: PUSH
15428: FOR_IN
15429: IFFALSE 15454
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15431: LD_VAR 0 1
15435: PPUSH
15436: LD_INT 285
15438: PPUSH
15439: LD_INT 163
15441: PPUSH
15442: LD_INT 8
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL_OW 483
15452: GO 15428
15454: POP
15455: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15456: LD_ADDR_VAR 0 2
15460: PUSH
15461: LD_VAR 0 2
15465: PPUSH
15466: LD_INT 24
15468: PUSH
15469: LD_INT 250
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: PPUSH
15476: CALL_OW 72
15480: ST_TO_ADDR
// for i in tmp do
15481: LD_ADDR_VAR 0 1
15485: PUSH
15486: LD_VAR 0 2
15490: PUSH
15491: FOR_IN
15492: IFFALSE 15532
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15494: LD_VAR 0 1
15498: PPUSH
15499: LD_INT 285
15501: PPUSH
15502: LD_INT 163
15504: PPUSH
15505: CALL_OW 297
15509: PUSH
15510: LD_INT 9
15512: GREATER
15513: IFFALSE 15530
// ComMoveXY ( i , 285 , 163 ) ;
15515: LD_VAR 0 1
15519: PPUSH
15520: LD_INT 285
15522: PPUSH
15523: LD_INT 163
15525: PPUSH
15526: CALL_OW 111
15530: GO 15491
15532: POP
15533: POP
// wait ( 0 0$1 ) ;
15534: LD_INT 35
15536: PPUSH
15537: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
15541: LD_VAR 0 2
15545: PPUSH
15546: LD_INT 92
15548: PUSH
15549: LD_INT 285
15551: PUSH
15552: LD_INT 163
15554: PUSH
15555: LD_INT 9
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: PPUSH
15564: CALL_OW 72
15568: PUSH
15569: LD_VAR 0 2
15573: PUSH
15574: LD_INT 1
15576: MINUS
15577: GREATEREQUAL
15578: IFFALSE 15456
// end ; repeat wait ( 0 0$1 ) ;
15580: LD_INT 35
15582: PPUSH
15583: CALL_OW 67
// for i in tmp do
15587: LD_ADDR_VAR 0 1
15591: PUSH
15592: LD_VAR 0 2
15596: PUSH
15597: FOR_IN
15598: IFFALSE 15720
// if GetLives ( i ) > 251 then
15600: LD_VAR 0 1
15604: PPUSH
15605: CALL_OW 256
15609: PUSH
15610: LD_INT 251
15612: GREATER
15613: IFFALSE 15702
// begin if GetWeapon ( i ) = ru_time_lapser then
15615: LD_VAR 0 1
15619: PPUSH
15620: CALL_OW 264
15624: PUSH
15625: LD_INT 49
15627: EQUAL
15628: IFFALSE 15666
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15630: LD_VAR 0 1
15634: PPUSH
15635: LD_INT 81
15637: PUSH
15638: LD_INT 7
15640: PUSH
15641: EMPTY
15642: LIST
15643: LIST
15644: PPUSH
15645: CALL_OW 69
15649: PPUSH
15650: LD_VAR 0 1
15654: PPUSH
15655: CALL_OW 74
15659: PPUSH
15660: CALL_OW 112
15664: GO 15700
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15666: LD_VAR 0 1
15670: PPUSH
15671: LD_INT 81
15673: PUSH
15674: LD_INT 7
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: PPUSH
15681: CALL_OW 69
15685: PPUSH
15686: LD_VAR 0 1
15690: PPUSH
15691: CALL_OW 74
15695: PPUSH
15696: CALL_OW 115
// end else
15700: GO 15718
// tmp := tmp diff i ;
15702: LD_ADDR_VAR 0 2
15706: PUSH
15707: LD_VAR 0 2
15711: PUSH
15712: LD_VAR 0 1
15716: DIFF
15717: ST_TO_ADDR
15718: GO 15597
15720: POP
15721: POP
// until not tmp ;
15722: LD_VAR 0 2
15726: NOT
15727: IFFALSE 15580
// end ;
15729: PPOPN 4
15731: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
15732: LD_EXP 31
15736: PUSH
15737: LD_EXP 78
15741: PPUSH
15742: CALL_OW 302
15746: AND
15747: PUSH
15748: LD_OWVAR 67
15752: PUSH
15753: LD_INT 2
15755: GREATER
15756: AND
15757: IFFALSE 15857
15759: GO 15761
15761: DISABLE
// begin enable ;
15762: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
15763: LD_EXP 78
15767: PPUSH
15768: LD_INT 245
15770: PPUSH
15771: LD_INT 234
15773: PPUSH
15774: CALL_OW 297
15778: PUSH
15779: LD_INT 6
15781: GREATER
15782: IFFALSE 15801
// ComMoveXY ( Roth , 245 , 234 ) else
15784: LD_EXP 78
15788: PPUSH
15789: LD_INT 245
15791: PPUSH
15792: LD_INT 234
15794: PPUSH
15795: CALL_OW 111
15799: GO 15857
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
15801: LD_EXP 78
15805: PPUSH
15806: LD_INT 259
15808: PUSH
15809: LD_INT 235
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PUSH
15816: LD_INT 252
15818: PUSH
15819: LD_INT 209
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PUSH
15826: LD_INT 275
15828: PUSH
15829: LD_INT 235
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PUSH
15836: EMPTY
15837: LIST
15838: LIST
15839: LIST
15840: PUSH
15841: LD_INT 1
15843: PPUSH
15844: LD_INT 3
15846: PPUSH
15847: CALL_OW 12
15851: ARRAY
15852: PPUSH
15853: CALL 110762 0 2
// end ; end_of_file
15857: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
15858: LD_INT 0
15860: PPUSH
15861: PPUSH
15862: PPUSH
15863: PPUSH
// missionStage := 13 ;
15864: LD_ADDR_EXP 15
15868: PUSH
15869: LD_INT 13
15871: ST_TO_ADDR
// uc_side := 2 ;
15872: LD_ADDR_OWVAR 20
15876: PUSH
15877: LD_INT 2
15879: ST_TO_ADDR
// uc_nation := 2 ;
15880: LD_ADDR_OWVAR 21
15884: PUSH
15885: LD_INT 2
15887: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
15888: LD_ADDR_EXP 96
15892: PUSH
15893: LD_STRING Omar
15895: PPUSH
15896: CALL_OW 25
15900: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
15901: LD_EXP 96
15905: PPUSH
15906: LD_INT 4
15908: PPUSH
15909: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
15913: LD_EXP 96
15917: PPUSH
15918: LD_INT 242
15920: PPUSH
15921: LD_INT 75
15923: PPUSH
15924: LD_INT 0
15926: PPUSH
15927: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
15931: LD_ADDR_EXP 97
15935: PUSH
15936: LD_STRING Heike
15938: PPUSH
15939: CALL_OW 25
15943: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
15944: LD_INT 14
15946: PPUSH
15947: LD_INT 3
15949: PPUSH
15950: LD_INT 1
15952: PPUSH
15953: LD_INT 27
15955: PPUSH
15956: LD_INT 100
15958: PPUSH
15959: CALL 73898 0 5
// veh := CreateVehicle ;
15963: LD_ADDR_VAR 0 3
15967: PUSH
15968: CALL_OW 45
15972: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
15973: LD_VAR 0 3
15977: PPUSH
15978: LD_INT 2
15980: NEG
15981: PPUSH
15982: CALL_OW 242
// SetDir ( veh , 4 ) ;
15986: LD_VAR 0 3
15990: PPUSH
15991: LD_INT 4
15993: PPUSH
15994: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
15998: LD_VAR 0 3
16002: PPUSH
16003: LD_INT 241
16005: PPUSH
16006: LD_INT 72
16008: PPUSH
16009: LD_INT 0
16011: PPUSH
16012: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16016: LD_EXP 97
16020: PPUSH
16021: LD_VAR 0 3
16025: PPUSH
16026: CALL_OW 52
// if KhatamStatus then
16030: LD_EXP 8
16034: IFFALSE 16097
// begin Khatam := NewCharacter ( Khatam ) ;
16036: LD_ADDR_EXP 98
16040: PUSH
16041: LD_STRING Khatam
16043: PPUSH
16044: CALL_OW 25
16048: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16049: LD_EXP 98
16053: PPUSH
16054: LD_INT 245
16056: PPUSH
16057: LD_INT 78
16059: PPUSH
16060: LD_INT 3
16062: PPUSH
16063: LD_INT 0
16065: PPUSH
16066: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16070: LD_EXP 98
16074: PPUSH
16075: LD_INT 4
16077: PPUSH
16078: LD_INT 10
16080: PPUSH
16081: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16085: LD_EXP 98
16089: PPUSH
16090: LD_INT 4
16092: PPUSH
16093: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16097: LD_ADDR_VAR 0 2
16101: PUSH
16102: DOUBLE
16103: LD_INT 1
16105: DEC
16106: ST_TO_ADDR
16107: LD_INT 2
16109: PUSH
16110: LD_INT 2
16112: PUSH
16113: LD_INT 3
16115: PUSH
16116: LD_INT 3
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: PUSH
16125: LD_OWVAR 67
16129: ARRAY
16130: PUSH
16131: FOR_TO
16132: IFFALSE 16198
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16134: LD_INT 0
16136: PPUSH
16137: LD_INT 6
16139: PUSH
16140: LD_OWVAR 67
16144: PLUS
16145: PPUSH
16146: CALL_OW 384
// un := CreateHuman ;
16150: LD_ADDR_VAR 0 4
16154: PUSH
16155: CALL_OW 44
16159: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16160: LD_VAR 0 4
16164: PPUSH
16165: LD_INT 28
16167: PUSH
16168: LD_INT 29
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: PUSH
16175: LD_VAR 0 2
16179: PUSH
16180: LD_INT 2
16182: MOD
16183: PUSH
16184: LD_INT 1
16186: PLUS
16187: ARRAY
16188: PPUSH
16189: LD_INT 0
16191: PPUSH
16192: CALL_OW 49
// end ;
16196: GO 16131
16198: POP
16199: POP
// for i = 1 to 6 do
16200: LD_ADDR_VAR 0 2
16204: PUSH
16205: DOUBLE
16206: LD_INT 1
16208: DEC
16209: ST_TO_ADDR
16210: LD_INT 6
16212: PUSH
16213: FOR_TO
16214: IFFALSE 16259
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16216: LD_INT 0
16218: PPUSH
16219: LD_INT 6
16221: PUSH
16222: LD_OWVAR 67
16226: PLUS
16227: PPUSH
16228: CALL_OW 381
// un := CreateHuman ;
16232: LD_ADDR_VAR 0 4
16236: PUSH
16237: CALL_OW 44
16241: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16242: LD_VAR 0 4
16246: PPUSH
16247: LD_INT 32
16249: PPUSH
16250: LD_INT 0
16252: PPUSH
16253: CALL_OW 49
// end ;
16257: GO 16213
16259: POP
16260: POP
// for i = 1 to 3 do
16261: LD_ADDR_VAR 0 2
16265: PUSH
16266: DOUBLE
16267: LD_INT 1
16269: DEC
16270: ST_TO_ADDR
16271: LD_INT 3
16273: PUSH
16274: FOR_TO
16275: IFFALSE 16323
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16277: LD_INT 0
16279: PPUSH
16280: LD_INT 8
16282: PPUSH
16283: LD_INT 6
16285: PUSH
16286: LD_OWVAR 67
16290: PLUS
16291: PPUSH
16292: CALL_OW 380
// un := CreateHuman ;
16296: LD_ADDR_VAR 0 4
16300: PUSH
16301: CALL_OW 44
16305: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16306: LD_VAR 0 4
16310: PPUSH
16311: LD_INT 32
16313: PPUSH
16314: LD_INT 0
16316: PPUSH
16317: CALL_OW 49
// end ;
16321: GO 16274
16323: POP
16324: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16325: LD_ADDR_VAR 0 2
16329: PUSH
16330: DOUBLE
16331: LD_INT 1
16333: DEC
16334: ST_TO_ADDR
16335: LD_INT 2
16337: PUSH
16338: LD_INT 3
16340: PUSH
16341: LD_INT 4
16343: PUSH
16344: LD_INT 4
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: LIST
16351: LIST
16352: PUSH
16353: LD_OWVAR 67
16357: ARRAY
16358: PUSH
16359: FOR_TO
16360: IFFALSE 16450
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16362: LD_INT 14
16364: PPUSH
16365: LD_INT 2
16367: PPUSH
16368: LD_INT 1
16370: PPUSH
16371: LD_INT 28
16373: PPUSH
16374: LD_INT 80
16376: PPUSH
16377: CALL 73898 0 5
// veh := CreateVehicle ;
16381: LD_ADDR_VAR 0 3
16385: PUSH
16386: CALL_OW 45
16390: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16391: LD_VAR 0 3
16395: PPUSH
16396: LD_INT 3
16398: PPUSH
16399: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16403: LD_VAR 0 3
16407: PPUSH
16408: LD_INT 29
16410: PPUSH
16411: LD_INT 0
16413: PPUSH
16414: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16418: LD_INT 0
16420: PPUSH
16421: LD_INT 6
16423: PUSH
16424: LD_OWVAR 67
16428: PLUS
16429: PPUSH
16430: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16434: CALL_OW 44
16438: PPUSH
16439: LD_VAR 0 3
16443: PPUSH
16444: CALL_OW 52
// end ;
16448: GO 16359
16450: POP
16451: POP
// for i = 1 to 5 + Difficulty do
16452: LD_ADDR_VAR 0 2
16456: PUSH
16457: DOUBLE
16458: LD_INT 1
16460: DEC
16461: ST_TO_ADDR
16462: LD_INT 5
16464: PUSH
16465: LD_OWVAR 67
16469: PLUS
16470: PUSH
16471: FOR_TO
16472: IFFALSE 16599
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16474: LD_INT 14
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: LD_INT 3
16482: PPUSH
16483: CALL_OW 12
16487: PPUSH
16488: LD_INT 1
16490: PPUSH
16491: LD_INT 28
16493: PUSH
16494: LD_INT 26
16496: PUSH
16497: LD_INT 27
16499: PUSH
16500: LD_INT 25
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: LD_VAR 0 2
16513: PUSH
16514: LD_INT 4
16516: MOD
16517: PUSH
16518: LD_INT 1
16520: PLUS
16521: ARRAY
16522: PPUSH
16523: LD_INT 80
16525: PPUSH
16526: CALL 73898 0 5
// veh := CreateVehicle ;
16530: LD_ADDR_VAR 0 3
16534: PUSH
16535: CALL_OW 45
16539: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16540: LD_VAR 0 3
16544: PPUSH
16545: LD_INT 4
16547: PPUSH
16548: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16552: LD_VAR 0 3
16556: PPUSH
16557: LD_INT 28
16559: PPUSH
16560: LD_INT 0
16562: PPUSH
16563: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16567: LD_INT 0
16569: PPUSH
16570: LD_INT 6
16572: PUSH
16573: LD_OWVAR 67
16577: PLUS
16578: PPUSH
16579: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16583: CALL_OW 44
16587: PPUSH
16588: LD_VAR 0 3
16592: PPUSH
16593: CALL_OW 52
// end ;
16597: GO 16471
16599: POP
16600: POP
// for i = 1 to Difficulty do
16601: LD_ADDR_VAR 0 2
16605: PUSH
16606: DOUBLE
16607: LD_INT 1
16609: DEC
16610: ST_TO_ADDR
16611: LD_OWVAR 67
16615: PUSH
16616: FOR_TO
16617: IFFALSE 16677
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16619: LD_INT 14
16621: PPUSH
16622: LD_INT 3
16624: PPUSH
16625: LD_INT 5
16627: PPUSH
16628: LD_INT 29
16630: PPUSH
16631: LD_INT 80
16633: PPUSH
16634: CALL 73898 0 5
// veh := CreateVehicle ;
16638: LD_ADDR_VAR 0 3
16642: PUSH
16643: CALL_OW 45
16647: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16648: LD_VAR 0 3
16652: PPUSH
16653: LD_INT 4
16655: PPUSH
16656: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16660: LD_VAR 0 3
16664: PPUSH
16665: LD_INT 28
16667: PPUSH
16668: LD_INT 0
16670: PPUSH
16671: CALL_OW 49
// end ;
16675: GO 16616
16677: POP
16678: POP
// end ;
16679: LD_VAR 0 1
16683: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16684: LD_INT 22
16686: PUSH
16687: LD_INT 2
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: PPUSH
16694: CALL_OW 69
16698: IFFALSE 17077
16700: GO 16702
16702: DISABLE
16703: LD_INT 0
16705: PPUSH
16706: PPUSH
16707: PPUSH
16708: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
16709: LD_ADDR_VAR 0 3
16713: PUSH
16714: LD_INT 22
16716: PUSH
16717: LD_INT 2
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: LD_INT 25
16726: PUSH
16727: LD_INT 4
16729: PUSH
16730: EMPTY
16731: LIST
16732: LIST
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: PPUSH
16738: CALL_OW 69
16742: PUSH
16743: LD_EXP 98
16747: DIFF
16748: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
16749: LD_ADDR_VAR 0 2
16753: PUSH
16754: LD_INT 22
16756: PUSH
16757: LD_INT 2
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PPUSH
16764: CALL_OW 69
16768: PUSH
16769: LD_EXP 98
16773: PUSH
16774: LD_VAR 0 3
16778: UNION
16779: DIFF
16780: ST_TO_ADDR
// if Khatam then
16781: LD_EXP 98
16785: IFFALSE 16802
// ComMoveXY ( Khatam , 211 , 92 ) ;
16787: LD_EXP 98
16791: PPUSH
16792: LD_INT 211
16794: PPUSH
16795: LD_INT 92
16797: PPUSH
16798: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
16802: LD_INT 197
16804: PPUSH
16805: LD_INT 80
16807: PPUSH
16808: LD_INT 2
16810: PPUSH
16811: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
16815: LD_INT 213
16817: PPUSH
16818: LD_INT 90
16820: PPUSH
16821: LD_INT 2
16823: PPUSH
16824: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
16828: LD_INT 215
16830: PPUSH
16831: LD_INT 129
16833: PPUSH
16834: LD_INT 2
16836: PPUSH
16837: CALL_OW 441
// if sci then
16841: LD_VAR 0 3
16845: IFFALSE 16866
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
16847: LD_VAR 0 3
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: PPUSH
16856: LD_INT 197
16858: PPUSH
16859: LD_INT 80
16861: PPUSH
16862: CALL_OW 158
// if sci > 1 then
16866: LD_VAR 0 3
16870: PUSH
16871: LD_INT 1
16873: GREATER
16874: IFFALSE 16895
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
16876: LD_VAR 0 3
16880: PUSH
16881: LD_INT 2
16883: ARRAY
16884: PPUSH
16885: LD_INT 213
16887: PPUSH
16888: LD_INT 90
16890: PPUSH
16891: CALL_OW 158
// if sci > 2 then
16895: LD_VAR 0 3
16899: PUSH
16900: LD_INT 2
16902: GREATER
16903: IFFALSE 16924
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
16905: LD_VAR 0 3
16909: PUSH
16910: LD_INT 3
16912: ARRAY
16913: PPUSH
16914: LD_INT 215
16916: PPUSH
16917: LD_INT 129
16919: PPUSH
16920: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
16924: LD_VAR 0 2
16928: PPUSH
16929: LD_INT 195
16931: PPUSH
16932: LD_INT 102
16934: PPUSH
16935: CALL_OW 114
// wait ( 0 0$5 ) ;
16939: LD_INT 175
16941: PPUSH
16942: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
16946: LD_INT 70
16948: PPUSH
16949: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
16953: LD_ADDR_VAR 0 4
16957: PUSH
16958: LD_INT 92
16960: PUSH
16961: LD_INT 195
16963: PUSH
16964: LD_INT 102
16966: PUSH
16967: LD_INT 36
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: PUSH
16976: LD_INT 22
16978: PUSH
16979: LD_INT 1
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PPUSH
16990: CALL_OW 69
16994: ST_TO_ADDR
// for i in tmp do
16995: LD_ADDR_VAR 0 1
16999: PUSH
17000: LD_VAR 0 2
17004: PUSH
17005: FOR_IN
17006: IFFALSE 17057
// if enemy then
17008: LD_VAR 0 4
17012: IFFALSE 17040
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17014: LD_VAR 0 1
17018: PPUSH
17019: LD_VAR 0 4
17023: PPUSH
17024: LD_VAR 0 1
17028: PPUSH
17029: CALL_OW 74
17033: PPUSH
17034: CALL_OW 115
17038: GO 17055
// ComAgressiveMove ( i , 195 , 102 ) ;
17040: LD_VAR 0 1
17044: PPUSH
17045: LD_INT 195
17047: PPUSH
17048: LD_INT 102
17050: PPUSH
17051: CALL_OW 114
17055: GO 17005
17057: POP
17058: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17059: LD_VAR 0 2
17063: PPUSH
17064: LD_INT 50
17066: PUSH
17067: EMPTY
17068: LIST
17069: PPUSH
17070: CALL_OW 72
17074: NOT
17075: IFFALSE 16946
// end ; end_of_file
17077: PPOPN 4
17079: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17080: LD_INT 0
17082: PPUSH
17083: PPUSH
17084: PPUSH
17085: PPUSH
17086: PPUSH
17087: PPUSH
17088: PPUSH
17089: PPUSH
17090: PPUSH
// Video ( true ) ;
17091: LD_INT 1
17093: PPUSH
17094: CALL 106732 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17098: LD_ADDR_VAR 0 5
17102: PUSH
17103: LD_INT 7
17105: PPUSH
17106: LD_INT 0
17108: PPUSH
17109: CALL_OW 517
17113: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17114: LD_ADDR_VAR 0 2
17118: PUSH
17119: DOUBLE
17120: LD_INT 1
17122: DEC
17123: ST_TO_ADDR
17124: LD_VAR 0 5
17128: PUSH
17129: LD_INT 1
17131: ARRAY
17132: PUSH
17133: FOR_TO
17134: IFFALSE 17179
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17136: LD_VAR 0 5
17140: PUSH
17141: LD_INT 1
17143: ARRAY
17144: PUSH
17145: LD_VAR 0 2
17149: ARRAY
17150: PPUSH
17151: LD_VAR 0 5
17155: PUSH
17156: LD_INT 2
17158: ARRAY
17159: PUSH
17160: LD_VAR 0 2
17164: ARRAY
17165: PPUSH
17166: LD_INT 1
17168: PPUSH
17169: LD_INT 15
17171: NEG
17172: PPUSH
17173: CALL 106646 0 4
17177: GO 17133
17179: POP
17180: POP
// CenterNowOnUnits ( Powell ) ;
17181: LD_EXP 60
17185: PPUSH
17186: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17190: LD_ADDR_VAR 0 5
17194: PUSH
17195: LD_EXP 58
17199: PUSH
17200: EMPTY
17201: LIST
17202: ST_TO_ADDR
// if GirlNewVeh then
17203: LD_EXP 59
17207: IFFALSE 17225
// tmp := tmp ^ GirlNewVeh ;
17209: LD_ADDR_VAR 0 5
17213: PUSH
17214: LD_VAR 0 5
17218: PUSH
17219: LD_EXP 59
17223: ADD
17224: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17225: LD_VAR 0 5
17229: PPUSH
17230: LD_INT 60
17232: PPUSH
17233: LD_INT 109
17235: PPUSH
17236: CALL_OW 111
// if KappaStatus then
17240: LD_EXP 2
17244: IFFALSE 17296
// begin Say ( JMM , D1nT-JMM-1 ) ;
17246: LD_EXP 40
17250: PPUSH
17251: LD_STRING D1nT-JMM-1
17253: PPUSH
17254: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17258: LD_EXP 60
17262: PPUSH
17263: LD_STRING D1T-Pow-1
17265: PPUSH
17266: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17270: LD_EXP 40
17274: PPUSH
17275: LD_STRING D1T-JMM-2
17277: PPUSH
17278: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17282: LD_EXP 60
17286: PPUSH
17287: LD_STRING D1T-Pow-2
17289: PPUSH
17290: CALL_OW 88
// end else
17294: GO 17502
// if JMMGirlStatus then
17296: LD_EXP 6
17300: IFFALSE 17445
// begin Say ( JMM , D1T-JMM-1 ) ;
17302: LD_EXP 40
17306: PPUSH
17307: LD_STRING D1T-JMM-1
17309: PPUSH
17310: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17314: LD_EXP 60
17318: PPUSH
17319: LD_STRING D1T-Pow-1
17321: PPUSH
17322: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17326: LD_EXP 40
17330: PPUSH
17331: LD_STRING D1T-JMM-3
17333: PPUSH
17334: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17338: LD_EXP 60
17342: PPUSH
17343: LD_STRING D1T-Pow-3
17345: PPUSH
17346: CALL_OW 88
// if JMMGirl then
17350: LD_EXP 7
17354: IFFALSE 17443
// begin case JMMGirl of 1 :
17356: LD_EXP 7
17360: PUSH
17361: LD_INT 1
17363: DOUBLE
17364: EQUAL
17365: IFTRUE 17369
17367: GO 17384
17369: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17370: LD_EXP 41
17374: PPUSH
17375: LD_STRING D1T-Joan-3
17377: PPUSH
17378: CALL_OW 88
17382: GO 17431
17384: LD_INT 2
17386: DOUBLE
17387: EQUAL
17388: IFTRUE 17392
17390: GO 17407
17392: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17393: LD_EXP 43
17397: PPUSH
17398: LD_STRING D1T-Lisa-3
17400: PPUSH
17401: CALL_OW 88
17405: GO 17431
17407: LD_INT 3
17409: DOUBLE
17410: EQUAL
17411: IFTRUE 17415
17413: GO 17430
17415: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17416: LD_EXP 55
17420: PPUSH
17421: LD_STRING D1T-Con-3
17423: PPUSH
17424: CALL_OW 88
17428: GO 17431
17430: POP
// Say ( Powell , D1T-Pow-4 ) ;
17431: LD_EXP 60
17435: PPUSH
17436: LD_STRING D1T-Pow-4
17438: PPUSH
17439: CALL_OW 88
// end ; end else
17443: GO 17502
// if not FastEnd then
17445: LD_EXP 11
17449: NOT
17450: IFFALSE 17478
// begin Say ( JMM , D1T-JMM-4 ) ;
17452: LD_EXP 40
17456: PPUSH
17457: LD_STRING D1T-JMM-4
17459: PPUSH
17460: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17464: LD_EXP 60
17468: PPUSH
17469: LD_STRING D1T-Pow-5
17471: PPUSH
17472: CALL_OW 88
// end else
17476: GO 17502
// begin Say ( JMM , D1nT-JMM-1 ) ;
17478: LD_EXP 40
17482: PPUSH
17483: LD_STRING D1nT-JMM-1
17485: PPUSH
17486: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17490: LD_EXP 60
17494: PPUSH
17495: LD_STRING D1nT-Pow-1
17497: PPUSH
17498: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17502: LD_INT 3
17504: PPUSH
17505: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17509: LD_EXP 58
17513: PPUSH
17514: CALL_OW 314
17518: NOT
17519: IFFALSE 17502
// ComExitVehicle ( JMM ) ;
17521: LD_EXP 40
17525: PPUSH
17526: CALL_OW 121
// repeat wait ( 3 ) ;
17530: LD_INT 3
17532: PPUSH
17533: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17537: LD_EXP 40
17541: PPUSH
17542: CALL_OW 310
17546: NOT
17547: IFFALSE 17530
// ComMoveXY ( JMM , 60 , 94 ) ;
17549: LD_EXP 40
17553: PPUSH
17554: LD_INT 60
17556: PPUSH
17557: LD_INT 94
17559: PPUSH
17560: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17564: LD_EXP 40
17568: PPUSH
17569: LD_EXP 60
17573: PPUSH
17574: CALL_OW 179
// if Joan then
17578: LD_EXP 41
17582: IFFALSE 17636
// begin ComExitVehicle ( Joan ) ;
17584: LD_EXP 41
17588: PPUSH
17589: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17593: LD_EXP 41
17597: PPUSH
17598: LD_INT 35
17600: PPUSH
17601: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17605: LD_EXP 41
17609: PPUSH
17610: LD_INT 65
17612: PPUSH
17613: LD_INT 104
17615: PPUSH
17616: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17620: LD_EXP 41
17624: PPUSH
17625: LD_EXP 40
17629: PPUSH
17630: CALL_OW 179
// end else
17634: GO 17770
// if Lisa and JMMGirl = 2 then
17636: LD_EXP 43
17640: PUSH
17641: LD_EXP 7
17645: PUSH
17646: LD_INT 2
17648: EQUAL
17649: AND
17650: IFFALSE 17704
// begin ComExitVehicle ( Lisa ) ;
17652: LD_EXP 43
17656: PPUSH
17657: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17661: LD_EXP 43
17665: PPUSH
17666: LD_INT 35
17668: PPUSH
17669: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17673: LD_EXP 43
17677: PPUSH
17678: LD_INT 65
17680: PPUSH
17681: LD_INT 104
17683: PPUSH
17684: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17688: LD_EXP 43
17692: PPUSH
17693: LD_EXP 40
17697: PPUSH
17698: CALL_OW 179
// end else
17702: GO 17770
// if Connie and JMMGirl = 3 then
17704: LD_EXP 55
17708: PUSH
17709: LD_EXP 7
17713: PUSH
17714: LD_INT 3
17716: EQUAL
17717: AND
17718: IFFALSE 17770
// begin ComExitVehicle ( Connie ) ;
17720: LD_EXP 55
17724: PPUSH
17725: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
17729: LD_EXP 55
17733: PPUSH
17734: LD_INT 35
17736: PPUSH
17737: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
17741: LD_EXP 55
17745: PPUSH
17746: LD_INT 65
17748: PPUSH
17749: LD_INT 104
17751: PPUSH
17752: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
17756: LD_EXP 55
17760: PPUSH
17761: LD_EXP 40
17765: PPUSH
17766: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
17770: LD_INT 35
17772: PPUSH
17773: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
17777: LD_EXP 40
17781: PPUSH
17782: LD_EXP 60
17786: PPUSH
17787: CALL_OW 296
17791: PUSH
17792: LD_INT 8
17794: LESS
17795: IFFALSE 17770
// wait ( 0 0$0.5 ) ;
17797: LD_INT 18
17799: PPUSH
17800: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
17804: LD_EXP 40
17808: PPUSH
17809: LD_STRING D1-JMM-1
17811: PPUSH
17812: CALL_OW 88
// async ;
17816: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
17817: LD_EXP 60
17821: PPUSH
17822: LD_STRING D1-Pow-1
17824: PPUSH
17825: CALL_OW 88
// if not dialogue_skipped then
17829: LD_OWVAR 59
17833: NOT
17834: IFFALSE 17843
// wait ( 0 0$2 ) ;
17836: LD_INT 70
17838: PPUSH
17839: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
17843: LD_INT 170
17845: PPUSH
17846: LD_INT 99
17848: PPUSH
17849: LD_INT 1
17851: PPUSH
17852: LD_INT 6
17854: NEG
17855: PPUSH
17856: CALL 106646 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
17860: LD_INT 174
17862: PPUSH
17863: LD_INT 115
17865: PPUSH
17866: LD_INT 1
17868: PPUSH
17869: LD_INT 6
17871: NEG
17872: PPUSH
17873: CALL 106646 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
17877: LD_INT 169
17879: PPUSH
17880: LD_INT 71
17882: PPUSH
17883: LD_INT 1
17885: PPUSH
17886: LD_INT 6
17888: NEG
17889: PPUSH
17890: CALL 106646 0 4
// if not dialogue_skipped then
17894: LD_OWVAR 59
17898: NOT
17899: IFFALSE 17918
// begin CenterOnXY ( 170 , 99 ) ;
17901: LD_INT 170
17903: PPUSH
17904: LD_INT 99
17906: PPUSH
17907: CALL_OW 84
// wait ( 0 0$2.3 ) ;
17911: LD_INT 80
17913: PPUSH
17914: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
17918: LD_INT 75
17920: PPUSH
17921: LD_INT 53
17923: PPUSH
17924: LD_INT 1
17926: PPUSH
17927: LD_INT 9
17929: NEG
17930: PPUSH
17931: CALL 106646 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
17935: LD_INT 54
17937: PPUSH
17938: LD_INT 42
17940: PPUSH
17941: LD_INT 1
17943: PPUSH
17944: LD_INT 9
17946: NEG
17947: PPUSH
17948: CALL 106646 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
17952: LD_INT 62
17954: PPUSH
17955: LD_INT 51
17957: PPUSH
17958: LD_INT 1
17960: PPUSH
17961: LD_INT 9
17963: NEG
17964: PPUSH
17965: CALL 106646 0 4
// if not dialogue_skipped then
17969: LD_OWVAR 59
17973: NOT
17974: IFFALSE 17993
// begin CenterOnXY ( 75 , 53 ) ;
17976: LD_INT 75
17978: PPUSH
17979: LD_INT 53
17981: PPUSH
17982: CALL_OW 84
// wait ( 0 0$4 ) ;
17986: LD_INT 140
17988: PPUSH
17989: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
17993: LD_EXP 60
17997: PPUSH
17998: CALL_OW 87
// if not dialogue_skipped then
18002: LD_OWVAR 59
18006: NOT
18007: IFFALSE 18016
// wait ( 0 0$2 ) ;
18009: LD_INT 70
18011: PPUSH
18012: CALL_OW 67
// sync ;
18016: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18017: LD_EXP 40
18021: PPUSH
18022: LD_STRING D1-JMM-2
18024: PPUSH
18025: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18029: LD_EXP 60
18033: PPUSH
18034: LD_STRING D1-Pow-2
18036: PPUSH
18037: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18041: LD_EXP 40
18045: PPUSH
18046: LD_STRING D1-JMM-3
18048: PPUSH
18049: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18053: LD_EXP 60
18057: PPUSH
18058: LD_STRING D1-Pow-3
18060: PPUSH
18061: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18065: LD_EXP 40
18069: PPUSH
18070: LD_STRING D1-JMM-4
18072: PPUSH
18073: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18077: LD_EXP 60
18081: PPUSH
18082: LD_STRING D1-Pow-4
18084: PPUSH
18085: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18089: LD_EXP 40
18093: PPUSH
18094: LD_STRING D1-JMM-5
18096: PPUSH
18097: CALL_OW 88
// async ;
18101: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18102: LD_EXP 60
18106: PPUSH
18107: LD_STRING D1-Pow-5
18109: PPUSH
18110: CALL_OW 88
// if not dialogue_skipped then
18114: LD_OWVAR 59
18118: NOT
18119: IFFALSE 18128
// wait ( 0 0$3.6 ) ;
18121: LD_INT 126
18123: PPUSH
18124: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18128: LD_INT 134
18130: PPUSH
18131: LD_INT 210
18133: PPUSH
18134: LD_INT 1
18136: PPUSH
18137: LD_INT 11
18139: NEG
18140: PPUSH
18141: CALL 106646 0 4
// if not dialogue_skipped then
18145: LD_OWVAR 59
18149: NOT
18150: IFFALSE 18169
// begin CenterOnXY ( 134 , 210 ) ;
18152: LD_INT 134
18154: PPUSH
18155: LD_INT 210
18157: PPUSH
18158: CALL_OW 84
// wait ( 0 0$2 ) ;
18162: LD_INT 70
18164: PPUSH
18165: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18169: LD_INT 101
18171: PPUSH
18172: LD_INT 159
18174: PPUSH
18175: LD_INT 1
18177: PPUSH
18178: LD_INT 10
18180: NEG
18181: PPUSH
18182: CALL 106646 0 4
// if not dialogue_skipped then
18186: LD_OWVAR 59
18190: NOT
18191: IFFALSE 18210
// begin CenterOnXY ( 101 , 159 ) ;
18193: LD_INT 101
18195: PPUSH
18196: LD_INT 159
18198: PPUSH
18199: CALL_OW 84
// wait ( 0 0$2 ) ;
18203: LD_INT 70
18205: PPUSH
18206: CALL_OW 67
// end ; sync ;
18210: SYNC
// CenterNowOnUnits ( Powell ) ;
18211: LD_EXP 60
18215: PPUSH
18216: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18220: LD_ADDR_VAR 0 6
18224: PUSH
18225: LD_INT 1
18227: PUSH
18228: LD_INT 2
18230: PUSH
18231: LD_INT 3
18233: PUSH
18234: LD_INT 4
18236: PUSH
18237: LD_INT 5
18239: PUSH
18240: LD_INT 6
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: ST_TO_ADDR
// if not dialogue_skipped then
18251: LD_OWVAR 59
18255: NOT
18256: IFFALSE 18425
// begin game_speed := 4 ;
18258: LD_ADDR_OWVAR 65
18262: PUSH
18263: LD_INT 4
18265: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18266: LD_INT 210
18268: PPUSH
18269: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18273: LD_ADDR_VAR 0 7
18277: PUSH
18278: LD_STRING Q1
18280: PPUSH
18281: LD_VAR 0 6
18285: PPUSH
18286: CALL_OW 98
18290: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18291: LD_ADDR_VAR 0 7
18295: PUSH
18296: LD_STRING Q1
18298: PPUSH
18299: LD_VAR 0 6
18303: PPUSH
18304: CALL_OW 98
18308: ST_TO_ADDR
// options := options diff dec ;
18309: LD_ADDR_VAR 0 6
18313: PUSH
18314: LD_VAR 0 6
18318: PUSH
18319: LD_VAR 0 7
18323: DIFF
18324: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18325: LD_VAR 0 7
18329: PPUSH
18330: LD_VAR 0 6
18334: PPUSH
18335: CALL 19989 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18339: LD_VAR 0 7
18343: PUSH
18344: LD_INT 5
18346: PUSH
18347: LD_INT 6
18349: PUSH
18350: EMPTY
18351: LIST
18352: LIST
18353: IN
18354: PUSH
18355: LD_VAR 0 6
18359: PUSH
18360: LD_INT 2
18362: EQUAL
18363: OR
18364: IFFALSE 18291
// if not ( dec in [ 5 , 6 ] ) then
18366: LD_VAR 0 7
18370: PUSH
18371: LD_INT 5
18373: PUSH
18374: LD_INT 6
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: IN
18381: NOT
18382: IFFALSE 18425
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18384: LD_ADDR_VAR 0 7
18388: PUSH
18389: LD_STRING Q1a
18391: PPUSH
18392: LD_INT 1
18394: PUSH
18395: LD_INT 2
18397: PUSH
18398: EMPTY
18399: LIST
18400: LIST
18401: PPUSH
18402: CALL_OW 98
18406: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18407: LD_VAR 0 7
18411: PUSH
18412: LD_INT 4
18414: PLUS
18415: PPUSH
18416: LD_VAR 0 6
18420: PPUSH
18421: CALL 19989 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18425: LD_INT 81
18427: PPUSH
18428: LD_INT 127
18430: PPUSH
18431: CALL_OW 84
// amount := 8 ;
18435: LD_ADDR_VAR 0 8
18439: PUSH
18440: LD_INT 8
18442: ST_TO_ADDR
// macmilan_squad := [ ] ;
18443: LD_ADDR_VAR 0 9
18447: PUSH
18448: EMPTY
18449: ST_TO_ADDR
// if vip < amount then
18450: LD_EXP 61
18454: PUSH
18455: LD_VAR 0 8
18459: LESS
18460: IFFALSE 18504
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18462: LD_ADDR_VAR 0 5
18466: PUSH
18467: LD_EXP 61
18471: PUSH
18472: LD_INT 22
18474: PUSH
18475: LD_INT 4
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: PUSH
18482: LD_INT 21
18484: PUSH
18485: LD_INT 1
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: PPUSH
18496: CALL_OW 69
18500: UNION
18501: ST_TO_ADDR
18502: GO 18514
// tmp := vip ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_EXP 61
18513: ST_TO_ADDR
// tmp := tmp diff Powell ;
18514: LD_ADDR_VAR 0 5
18518: PUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_EXP 60
18528: DIFF
18529: ST_TO_ADDR
// if tmp < amount then
18530: LD_VAR 0 5
18534: PUSH
18535: LD_VAR 0 8
18539: LESS
18540: IFFALSE 18552
// amount := tmp ;
18542: LD_ADDR_VAR 0 8
18546: PUSH
18547: LD_VAR 0 5
18551: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18552: LD_VAR 0 5
18556: PUSH
18557: LD_INT 1
18559: ARRAY
18560: PPUSH
18561: CALL_OW 257
18565: PUSH
18566: LD_INT 2
18568: NONEQUAL
18569: IFFALSE 18667
// begin if IsInUnit ( tmp [ 1 ] ) then
18571: LD_VAR 0 5
18575: PUSH
18576: LD_INT 1
18578: ARRAY
18579: PPUSH
18580: CALL_OW 310
18584: IFFALSE 18599
// ComExitBuilding ( tmp [ 1 ] ) ;
18586: LD_VAR 0 5
18590: PUSH
18591: LD_INT 1
18593: ARRAY
18594: PPUSH
18595: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18599: LD_INT 387
18601: PPUSH
18602: CALL_OW 313
18606: PUSH
18607: LD_INT 6
18609: EQUAL
18610: IFFALSE 18635
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18612: LD_INT 387
18614: PPUSH
18615: CALL_OW 313
18619: PUSH
18620: LD_INT 1
18622: ARRAY
18623: PPUSH
18624: CALL_OW 122
// wait ( 3 ) ;
18628: LD_INT 3
18630: PPUSH
18631: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18635: LD_VAR 0 5
18639: PUSH
18640: LD_INT 1
18642: ARRAY
18643: PPUSH
18644: LD_INT 387
18646: PPUSH
18647: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18651: LD_VAR 0 5
18655: PUSH
18656: LD_INT 1
18658: ARRAY
18659: PPUSH
18660: LD_INT 2
18662: PPUSH
18663: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18667: LD_EXP 40
18671: PPUSH
18672: LD_INT 82
18674: PPUSH
18675: LD_INT 129
18677: PPUSH
18678: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18682: LD_EXP 40
18686: PPUSH
18687: LD_EXP 60
18691: PPUSH
18692: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18696: LD_INT 22
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL_OW 69
18710: PUSH
18711: LD_EXP 40
18715: DIFF
18716: PPUSH
18717: LD_INT 84
18719: PPUSH
18720: LD_INT 128
18722: PPUSH
18723: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
18727: LD_INT 22
18729: PUSH
18730: LD_INT 1
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: PPUSH
18737: CALL_OW 69
18741: PUSH
18742: LD_EXP 40
18746: DIFF
18747: PPUSH
18748: LD_EXP 40
18752: PPUSH
18753: CALL_OW 179
// for i = 1 to amount do
18757: LD_ADDR_VAR 0 2
18761: PUSH
18762: DOUBLE
18763: LD_INT 1
18765: DEC
18766: ST_TO_ADDR
18767: LD_VAR 0 8
18771: PUSH
18772: FOR_TO
18773: IFFALSE 18941
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
18775: LD_ADDR_VAR 0 9
18779: PUSH
18780: LD_VAR 0 9
18784: PUSH
18785: LD_VAR 0 5
18789: PUSH
18790: LD_VAR 0 2
18794: ARRAY
18795: ADD
18796: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
18797: LD_VAR 0 5
18801: PUSH
18802: LD_VAR 0 2
18806: ARRAY
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18829
// AddComExitBuilding ( tmp [ i ] ) ;
18814: LD_VAR 0 5
18818: PUSH
18819: LD_VAR 0 2
18823: ARRAY
18824: PPUSH
18825: CALL_OW 182
// if i = 2 and JMMNewVeh then
18829: LD_VAR 0 2
18833: PUSH
18834: LD_INT 2
18836: EQUAL
18837: PUSH
18838: LD_EXP 58
18842: AND
18843: IFFALSE 18901
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
18845: LD_VAR 0 5
18849: PUSH
18850: LD_VAR 0 2
18854: ARRAY
18855: PPUSH
18856: LD_EXP 58
18860: PPUSH
18861: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
18865: LD_VAR 0 5
18869: PUSH
18870: LD_VAR 0 2
18874: ARRAY
18875: PPUSH
18876: LD_INT 86
18878: PPUSH
18879: LD_INT 133
18881: PPUSH
18882: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
18886: LD_VAR 0 5
18890: PUSH
18891: LD_VAR 0 2
18895: ARRAY
18896: PPUSH
18897: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
18901: LD_VAR 0 5
18905: PUSH
18906: LD_VAR 0 2
18910: ARRAY
18911: PPUSH
18912: LD_INT 8
18914: PPUSH
18915: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
18919: LD_VAR 0 5
18923: PUSH
18924: LD_VAR 0 2
18928: ARRAY
18929: PPUSH
18930: LD_EXP 40
18934: PPUSH
18935: CALL_OW 179
// end ;
18939: GO 18772
18941: POP
18942: POP
// if GirlNewVeh then
18943: LD_EXP 59
18947: IFFALSE 18961
// SetSide ( GirlNewVeh , 4 ) ;
18949: LD_EXP 59
18953: PPUSH
18954: LD_INT 4
18956: PPUSH
18957: CALL_OW 235
// if Mike then
18961: LD_EXP 57
18965: IFFALSE 19002
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
18967: LD_ADDR_VAR 0 9
18971: PUSH
18972: LD_VAR 0 9
18976: PPUSH
18977: LD_EXP 57
18981: PPUSH
18982: CALL 106760 0 2
18986: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
18987: LD_EXP 57
18991: PPUSH
18992: LD_INT 86
18994: PPUSH
18995: LD_INT 133
18997: PPUSH
18998: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19002: LD_INT 35
19004: PPUSH
19005: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19009: LD_VAR 0 9
19013: PPUSH
19014: LD_INT 95
19016: PUSH
19017: LD_INT 9
19019: PUSH
19020: EMPTY
19021: LIST
19022: LIST
19023: PPUSH
19024: CALL_OW 72
19028: PUSH
19029: LD_INT 0
19031: EQUAL
19032: PUSH
19033: LD_EXP 40
19037: PPUSH
19038: LD_INT 9
19040: PPUSH
19041: CALL_OW 308
19045: NOT
19046: AND
19047: IFFALSE 19002
// wait ( 0 0$2 ) ;
19049: LD_INT 70
19051: PPUSH
19052: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19056: LD_VAR 0 9
19060: PPUSH
19061: LD_INT 1
19063: PPUSH
19064: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19068: LD_INT 21
19070: PUSH
19071: LD_INT 2
19073: PUSH
19074: EMPTY
19075: LIST
19076: LIST
19077: PUSH
19078: LD_INT 92
19080: PUSH
19081: LD_INT 83
19083: PUSH
19084: LD_INT 130
19086: PUSH
19087: LD_INT 10
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: LIST
19094: LIST
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PPUSH
19100: CALL_OW 69
19104: PPUSH
19105: LD_INT 1
19107: PPUSH
19108: CALL_OW 235
// tick := 0 ;
19112: LD_ADDR_OWVAR 1
19116: PUSH
19117: LD_INT 0
19119: ST_TO_ADDR
// Video ( false ) ;
19120: LD_INT 0
19122: PPUSH
19123: CALL 106732 0 1
// ChangeMissionObjectives ( M1 ) ;
19127: LD_STRING M1
19129: PPUSH
19130: CALL_OW 337
// SaveForQuickRestart ;
19134: CALL_OW 22
// missionStart := true ;
19138: LD_ADDR_EXP 13
19142: PUSH
19143: LD_INT 1
19145: ST_TO_ADDR
// missionStage := 2 ;
19146: LD_ADDR_EXP 15
19150: PUSH
19151: LD_INT 2
19153: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19154: LD_INT 35
19156: PPUSH
19157: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_INT 22
19168: PUSH
19169: LD_INT 4
19171: PUSH
19172: EMPTY
19173: LIST
19174: LIST
19175: PUSH
19176: LD_INT 21
19178: PUSH
19179: LD_INT 1
19181: PUSH
19182: EMPTY
19183: LIST
19184: LIST
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: PPUSH
19190: CALL_OW 69
19194: PUSH
19195: LD_EXP 60
19199: DIFF
19200: ST_TO_ADDR
// if not tmp then
19201: LD_VAR 0 5
19205: NOT
19206: IFFALSE 19221
// tmp := [ Powell ] ;
19208: LD_ADDR_VAR 0 5
19212: PUSH
19213: LD_EXP 60
19217: PUSH
19218: EMPTY
19219: LIST
19220: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19221: LD_ADDR_VAR 0 4
19225: PUSH
19226: LD_INT 22
19228: PUSH
19229: LD_INT 4
19231: PUSH
19232: EMPTY
19233: LIST
19234: LIST
19235: PUSH
19236: LD_INT 34
19238: PUSH
19239: LD_INT 12
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: PPUSH
19250: CALL_OW 69
19254: PUSH
19255: LD_INT 1
19257: ARRAY
19258: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19259: LD_VAR 0 5
19263: PUSH
19264: LD_INT 1
19266: ARRAY
19267: PPUSH
19268: CALL_OW 310
19272: IFFALSE 19287
// ComExitBuilding ( tmp [ 1 ] ) ;
19274: LD_VAR 0 5
19278: PUSH
19279: LD_INT 1
19281: ARRAY
19282: PPUSH
19283: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19287: LD_VAR 0 5
19291: PUSH
19292: LD_INT 1
19294: ARRAY
19295: PPUSH
19296: LD_VAR 0 4
19300: PPUSH
19301: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19305: LD_VAR 0 5
19309: PUSH
19310: LD_INT 1
19312: ARRAY
19313: PPUSH
19314: LD_INT 80
19316: PPUSH
19317: LD_INT 136
19319: PPUSH
19320: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_INT 1
19331: ARRAY
19332: PPUSH
19333: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19337: LD_VAR 0 5
19341: PUSH
19342: LD_INT 1
19344: ARRAY
19345: PPUSH
19346: LD_INT 59
19348: PPUSH
19349: LD_INT 112
19351: PPUSH
19352: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19369: LD_EXP 41
19373: PUSH
19374: LD_EXP 41
19378: PPUSH
19379: CALL_OW 255
19383: PUSH
19384: LD_INT 1
19386: EQUAL
19387: AND
19388: IFFALSE 19414
// begin Say ( Joan , D3W-Joan-1 ) ;
19390: LD_EXP 41
19394: PPUSH
19395: LD_STRING D3W-Joan-1
19397: PPUSH
19398: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19402: LD_EXP 40
19406: PPUSH
19407: LD_STRING D3W-JMM-1
19409: PPUSH
19410: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19414: LD_EXP 43
19418: PUSH
19419: LD_EXP 43
19423: PPUSH
19424: CALL_OW 255
19428: PUSH
19429: LD_INT 1
19431: EQUAL
19432: AND
19433: PUSH
19434: LD_EXP 43
19438: PUSH
19439: LD_EXP 61
19443: IN
19444: NOT
19445: AND
19446: IFFALSE 19472
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19448: LD_EXP 43
19452: PPUSH
19453: LD_STRING D3W-Lisa-1
19455: PPUSH
19456: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19460: LD_EXP 40
19464: PPUSH
19465: LD_STRING D3W-JMM-1
19467: PPUSH
19468: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19472: LD_EXP 55
19476: PUSH
19477: LD_EXP 55
19481: PPUSH
19482: CALL_OW 255
19486: PUSH
19487: LD_INT 1
19489: EQUAL
19490: AND
19491: IFFALSE 19517
// begin Say ( Connie , D3W-Con-1 ) ;
19493: LD_EXP 55
19497: PPUSH
19498: LD_STRING D3W-Con-1
19500: PPUSH
19501: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19505: LD_EXP 40
19509: PPUSH
19510: LD_STRING D3W-JMM-1
19512: PPUSH
19513: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19517: LD_INT 18
19519: PPUSH
19520: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19524: LD_EXP 43
19528: PUSH
19529: LD_EXP 61
19533: IN
19534: PUSH
19535: LD_EXP 43
19539: PPUSH
19540: CALL_OW 255
19544: PUSH
19545: LD_INT 1
19547: EQUAL
19548: AND
19549: IFFALSE 19565
// Say ( Lisa , D3nW-Lisa-1 ) else
19551: LD_EXP 43
19555: PPUSH
19556: LD_STRING D3nW-Lisa-1
19558: PPUSH
19559: CALL_OW 88
19563: GO 19809
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19565: LD_EXP 46
19569: PUSH
19570: LD_EXP 61
19574: IN
19575: PUSH
19576: LD_EXP 46
19580: PPUSH
19581: CALL_OW 255
19585: PUSH
19586: LD_INT 1
19588: EQUAL
19589: AND
19590: IFFALSE 19606
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19592: LD_EXP 46
19596: PPUSH
19597: LD_STRING D3nW-Cyrus-1
19599: PPUSH
19600: CALL_OW 88
19604: GO 19809
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19606: LD_EXP 45
19610: PUSH
19611: LD_EXP 61
19615: IN
19616: PUSH
19617: LD_EXP 45
19621: PPUSH
19622: CALL_OW 255
19626: PUSH
19627: LD_INT 1
19629: EQUAL
19630: AND
19631: IFFALSE 19647
// Say ( Bobby , D3nW-Bobby-1 ) else
19633: LD_EXP 45
19637: PPUSH
19638: LD_STRING D3nW-Bobby-1
19640: PPUSH
19641: CALL_OW 88
19645: GO 19809
// if Gary in vip and GetSide ( Gary ) = 1 then
19647: LD_EXP 52
19651: PUSH
19652: LD_EXP 61
19656: IN
19657: PUSH
19658: LD_EXP 52
19662: PPUSH
19663: CALL_OW 255
19667: PUSH
19668: LD_INT 1
19670: EQUAL
19671: AND
19672: IFFALSE 19688
// Say ( Gary , D3nW-Gary-1 ) else
19674: LD_EXP 52
19678: PPUSH
19679: LD_STRING D3nW-Gary-1
19681: PPUSH
19682: CALL_OW 88
19686: GO 19809
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19688: LD_EXP 44
19692: PUSH
19693: LD_EXP 61
19697: IN
19698: PUSH
19699: LD_EXP 44
19703: PPUSH
19704: CALL_OW 255
19708: PUSH
19709: LD_INT 1
19711: EQUAL
19712: AND
19713: IFFALSE 19729
// Say ( Donaldson , D3nW-Don-1 ) else
19715: LD_EXP 44
19719: PPUSH
19720: LD_STRING D3nW-Don-1
19722: PPUSH
19723: CALL_OW 88
19727: GO 19809
// if Cornel in vip and GetSide ( Cornel ) = 1 then
19729: LD_EXP 51
19733: PUSH
19734: LD_EXP 61
19738: IN
19739: PUSH
19740: LD_EXP 51
19744: PPUSH
19745: CALL_OW 255
19749: PUSH
19750: LD_INT 1
19752: EQUAL
19753: AND
19754: IFFALSE 19770
// Say ( Cornel , D3nW-Corn-1 ) else
19756: LD_EXP 51
19760: PPUSH
19761: LD_STRING D3nW-Corn-1
19763: PPUSH
19764: CALL_OW 88
19768: GO 19809
// if Frank in vip and GetSide ( Frank ) = 1 then
19770: LD_EXP 53
19774: PUSH
19775: LD_EXP 61
19779: IN
19780: PUSH
19781: LD_EXP 53
19785: PPUSH
19786: CALL_OW 255
19790: PUSH
19791: LD_INT 1
19793: EQUAL
19794: AND
19795: IFFALSE 19809
// Say ( Frank , D3nW-Frank-1 ) ;
19797: LD_EXP 53
19801: PPUSH
19802: LD_STRING D3nW-Frank-1
19804: PPUSH
19805: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
19809: LD_EXP 61
19813: PPUSH
19814: LD_INT 22
19816: PUSH
19817: LD_INT 1
19819: PUSH
19820: EMPTY
19821: LIST
19822: LIST
19823: PPUSH
19824: CALL_OW 72
19828: IFFALSE 19854
// begin Say ( JMM , D3nW-JMM-1 ) ;
19830: LD_EXP 40
19834: PPUSH
19835: LD_STRING D3nW-JMM-1
19837: PPUSH
19838: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
19842: LD_EXP 40
19846: PPUSH
19847: LD_STRING D3nW-JMM-1a
19849: PPUSH
19850: CALL_OW 88
// end ; t := 0 0$00 ;
19854: LD_ADDR_VAR 0 3
19858: PUSH
19859: LD_INT 0
19861: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19862: LD_INT 35
19864: PPUSH
19865: CALL_OW 67
// t := t + 0 0$1 ;
19869: LD_ADDR_VAR 0 3
19873: PUSH
19874: LD_VAR 0 3
19878: PUSH
19879: LD_INT 35
19881: PLUS
19882: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
19883: LD_INT 59
19885: PPUSH
19886: LD_INT 112
19888: PPUSH
19889: CALL_OW 428
19893: PUSH
19894: LD_VAR 0 3
19898: PUSH
19899: LD_INT 2100
19901: GREATER
19902: OR
19903: IFFALSE 19862
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
19905: LD_ADDR_EXP 101
19909: PUSH
19910: LD_EXP 101
19914: PPUSH
19915: LD_INT 4
19917: PPUSH
19918: LD_INT 22
19920: PUSH
19921: LD_INT 4
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 23
19930: PUSH
19931: LD_INT 1
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: LD_INT 3
19940: PUSH
19941: LD_INT 21
19943: PUSH
19944: LD_INT 2
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: PUSH
19955: EMPTY
19956: LIST
19957: LIST
19958: LIST
19959: PPUSH
19960: CALL_OW 69
19964: PUSH
19965: LD_EXP 60
19969: DIFF
19970: PPUSH
19971: CALL_OW 1
19975: ST_TO_ADDR
// activeAttacks := true ;
19976: LD_ADDR_EXP 16
19980: PUSH
19981: LD_INT 1
19983: ST_TO_ADDR
// end ;
19984: LD_VAR 0 1
19988: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
19989: LD_INT 0
19991: PPUSH
// case question of 1 :
19992: LD_VAR 0 1
19996: PUSH
19997: LD_INT 1
19999: DOUBLE
20000: EQUAL
20001: IFTRUE 20005
20003: GO 20056
20005: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20006: LD_EXP 40
20010: PPUSH
20011: LD_STRING D2Mot-JMM-1
20013: PPUSH
20014: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20018: LD_EXP 60
20022: PPUSH
20023: LD_STRING D2Mot-Pow-1
20025: PPUSH
20026: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20030: LD_EXP 40
20034: PPUSH
20035: LD_STRING D2Mot-JMM-2
20037: PPUSH
20038: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20042: LD_EXP 60
20046: PPUSH
20047: LD_STRING D2Mot-Pow-2
20049: PPUSH
20050: CALL_OW 88
// end ; 2 :
20054: GO 20407
20056: LD_INT 2
20058: DOUBLE
20059: EQUAL
20060: IFTRUE 20064
20062: GO 20140
20064: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20065: LD_EXP 40
20069: PPUSH
20070: LD_STRING D2Rus-JMM-1
20072: PPUSH
20073: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20077: LD_EXP 60
20081: PPUSH
20082: LD_STRING D2Rus-Pow-1
20084: PPUSH
20085: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20089: LD_EXP 40
20093: PPUSH
20094: LD_STRING D2Rus-JMM-2
20096: PPUSH
20097: CALL_OW 88
// if not ( 3 in list_of_q ) then
20101: LD_INT 3
20103: PUSH
20104: LD_VAR 0 2
20108: IN
20109: NOT
20110: IFFALSE 20126
// Say ( Powell , D2Rus-Pow-2 ) else
20112: LD_EXP 60
20116: PPUSH
20117: LD_STRING D2Rus-Pow-2
20119: PPUSH
20120: CALL_OW 88
20124: GO 20138
// Say ( Powell , D2Rus-Pow-2a ) ;
20126: LD_EXP 60
20130: PPUSH
20131: LD_STRING D2Rus-Pow-2a
20133: PPUSH
20134: CALL_OW 88
// end ; 3 :
20138: GO 20407
20140: LD_INT 3
20142: DOUBLE
20143: EQUAL
20144: IFTRUE 20148
20146: GO 20233
20148: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20149: LD_EXP 40
20153: PPUSH
20154: LD_STRING D2Leg-JMM-1
20156: PPUSH
20157: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20161: LD_EXP 60
20165: PPUSH
20166: LD_STRING D2Leg-Pow-1
20168: PPUSH
20169: CALL_OW 88
// if 2 in list_of_q then
20173: LD_INT 2
20175: PUSH
20176: LD_VAR 0 2
20180: IN
20181: IFFALSE 20207
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20183: LD_EXP 40
20187: PPUSH
20188: LD_STRING D2Leg-JMM-2
20190: PPUSH
20191: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20195: LD_EXP 60
20199: PPUSH
20200: LD_STRING D2Leg-Pow-2
20202: PPUSH
20203: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20207: LD_EXP 40
20211: PPUSH
20212: LD_STRING D2Leg-JMM-3
20214: PPUSH
20215: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20219: LD_EXP 60
20223: PPUSH
20224: LD_STRING D2Leg-Pow-3
20226: PPUSH
20227: CALL_OW 88
// end ; 4 :
20231: GO 20407
20233: LD_INT 4
20235: DOUBLE
20236: EQUAL
20237: IFTRUE 20241
20239: GO 20316
20241: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20242: LD_EXP 40
20246: PPUSH
20247: LD_STRING D2Ar-JMM-1
20249: PPUSH
20250: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20254: LD_EXP 60
20258: PPUSH
20259: LD_STRING D2Ar-Pow-1
20261: PPUSH
20262: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20266: LD_EXP 40
20270: PPUSH
20271: LD_STRING D2Ar-JMM-2
20273: PPUSH
20274: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20278: LD_EXP 60
20282: PPUSH
20283: LD_STRING D2Ar-Pow-2
20285: PPUSH
20286: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20290: LD_EXP 40
20294: PPUSH
20295: LD_STRING D2Ar-JMM-3
20297: PPUSH
20298: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20302: LD_EXP 60
20306: PPUSH
20307: LD_STRING D2Ar-Pow-3
20309: PPUSH
20310: CALL_OW 88
// end ; 5 :
20314: GO 20407
20316: LD_INT 5
20318: DOUBLE
20319: EQUAL
20320: IFTRUE 20324
20322: GO 20339
20324: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20325: LD_EXP 40
20329: PPUSH
20330: LD_STRING D2Conf-JMM-1
20332: PPUSH
20333: CALL_OW 88
20337: GO 20407
20339: LD_INT 6
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20406
20347: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20348: LD_EXP 40
20352: PPUSH
20353: LD_STRING D2Com-JMM-1
20355: PPUSH
20356: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20360: LD_EXP 60
20364: PPUSH
20365: LD_STRING D2Com-Pow-1
20367: PPUSH
20368: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20372: LD_EXP 40
20376: PPUSH
20377: LD_STRING D2Com-JMM-2
20379: PPUSH
20380: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20384: LD_EXP 60
20388: PPUSH
20389: LD_STRING D2Com-Pow-2
20391: PPUSH
20392: CALL_OW 88
// powellAngerQuery := true ;
20396: LD_ADDR_EXP 36
20400: PUSH
20401: LD_INT 1
20403: ST_TO_ADDR
// end ; end ;
20404: GO 20407
20406: POP
// end ;
20407: LD_VAR 0 3
20411: RET
// every 0 0$5 trigger missionStart do var tmp ;
20412: LD_EXP 13
20416: IFFALSE 20741
20418: GO 20420
20420: DISABLE
20421: LD_INT 0
20423: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20424: LD_INT 35
20426: PPUSH
20427: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20431: LD_INT 14
20433: PPUSH
20434: LD_INT 22
20436: PUSH
20437: LD_INT 1
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PUSH
20444: LD_INT 3
20446: PUSH
20447: LD_INT 21
20449: PUSH
20450: LD_INT 3
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PPUSH
20465: CALL_OW 70
20469: PUSH
20470: LD_EXP 15
20474: PUSH
20475: LD_INT 2
20477: PUSH
20478: LD_INT 3
20480: PUSH
20481: LD_INT 4
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: LIST
20491: LIST
20492: IN
20493: AND
20494: IFFALSE 20731
// begin powellAnger := powellAnger + 1 ;
20496: LD_ADDR_EXP 17
20500: PUSH
20501: LD_EXP 17
20505: PUSH
20506: LD_INT 1
20508: PLUS
20509: ST_TO_ADDR
// Video ( true ) ;
20510: LD_INT 1
20512: PPUSH
20513: CALL 106732 0 1
// CenterNowOnUnits ( tmp ) ;
20517: LD_VAR 0 1
20521: PPUSH
20522: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20526: LD_INT 14
20528: PPUSH
20529: LD_INT 22
20531: PUSH
20532: LD_INT 1
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PPUSH
20539: CALL_OW 70
20543: PPUSH
20544: LD_INT 86
20546: PPUSH
20547: LD_INT 133
20549: PPUSH
20550: CALL_OW 111
// async ;
20554: ASYNC
// case powellAnger of 1 :
20555: LD_EXP 17
20559: PUSH
20560: LD_INT 1
20562: DOUBLE
20563: EQUAL
20564: IFTRUE 20568
20566: GO 20583
20568: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20569: LD_EXP 60
20573: PPUSH
20574: LD_STRING DBack1-Pow-1
20576: PPUSH
20577: CALL_OW 88
20581: GO 20630
20583: LD_INT 2
20585: DOUBLE
20586: EQUAL
20587: IFTRUE 20591
20589: GO 20606
20591: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20592: LD_EXP 60
20596: PPUSH
20597: LD_STRING DBack2-Pow-1
20599: PPUSH
20600: CALL_OW 88
20604: GO 20630
20606: LD_INT 3
20608: DOUBLE
20609: EQUAL
20610: IFTRUE 20614
20612: GO 20629
20614: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20615: LD_EXP 60
20619: PPUSH
20620: LD_STRING DBack3-Pow-1
20622: PPUSH
20623: CALL_OW 88
20627: GO 20630
20629: POP
// sync ;
20630: SYNC
// repeat wait ( 0 0$1 ) ;
20631: LD_INT 35
20633: PPUSH
20634: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20638: LD_INT 14
20640: PPUSH
20641: LD_INT 22
20643: PUSH
20644: LD_INT 1
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: PPUSH
20651: CALL_OW 70
20655: PPUSH
20656: LD_INT 86
20658: PPUSH
20659: LD_INT 133
20661: PPUSH
20662: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20666: LD_INT 14
20668: PPUSH
20669: LD_INT 22
20671: PUSH
20672: LD_INT 1
20674: PUSH
20675: EMPTY
20676: LIST
20677: LIST
20678: PUSH
20679: LD_INT 3
20681: PUSH
20682: LD_INT 21
20684: PUSH
20685: LD_INT 3
20687: PUSH
20688: EMPTY
20689: LIST
20690: LIST
20691: PUSH
20692: EMPTY
20693: LIST
20694: LIST
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: PPUSH
20700: CALL_OW 70
20704: NOT
20705: IFFALSE 20631
// if powellAnger >= 3 then
20707: LD_EXP 17
20711: PUSH
20712: LD_INT 3
20714: GREATEREQUAL
20715: IFFALSE 20724
// YouLost ( Dismissed ) ;
20717: LD_STRING Dismissed
20719: PPUSH
20720: CALL_OW 104
// Video ( false ) ;
20724: LD_INT 0
20726: PPUSH
20727: CALL 106732 0 1
// end ; until missionStage > 5 ;
20731: LD_EXP 15
20735: PUSH
20736: LD_INT 5
20738: GREATER
20739: IFFALSE 20424
// end ;
20741: PPOPN 1
20743: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
20744: LD_EXP 13
20748: PUSH
20749: LD_INT 22
20751: PUSH
20752: LD_INT 4
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: PUSH
20759: LD_INT 21
20761: PUSH
20762: LD_INT 2
20764: PUSH
20765: EMPTY
20766: LIST
20767: LIST
20768: PUSH
20769: EMPTY
20770: LIST
20771: LIST
20772: PPUSH
20773: CALL_OW 69
20777: PUSH
20778: LD_INT 4
20780: GREATEREQUAL
20781: AND
20782: PUSH
20783: LD_EXP 15
20787: PUSH
20788: LD_INT 2
20790: EQUAL
20791: AND
20792: IFFALSE 23042
20794: GO 20796
20796: DISABLE
20797: LD_INT 0
20799: PPUSH
20800: PPUSH
20801: PPUSH
20802: PPUSH
20803: PPUSH
20804: PPUSH
20805: PPUSH
20806: PPUSH
20807: PPUSH
20808: PPUSH
20809: PPUSH
// begin missionStage := 3 ;
20810: LD_ADDR_EXP 15
20814: PUSH
20815: LD_INT 3
20817: ST_TO_ADDR
// retreat := false ;
20818: LD_ADDR_VAR 0 4
20822: PUSH
20823: LD_INT 0
20825: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
20826: LD_ADDR_VAR 0 5
20830: PUSH
20831: LD_INT 22
20833: PUSH
20834: LD_INT 4
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: PUSH
20841: LD_INT 30
20843: PUSH
20844: LD_INT 4
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PPUSH
20855: CALL_OW 69
20859: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20860: LD_ADDR_VAR 0 6
20864: PUSH
20865: LD_INT 22
20867: PUSH
20868: LD_INT 4
20870: PUSH
20871: EMPTY
20872: LIST
20873: LIST
20874: PUSH
20875: LD_INT 30
20877: PUSH
20878: LD_INT 5
20880: PUSH
20881: EMPTY
20882: LIST
20883: LIST
20884: PUSH
20885: EMPTY
20886: LIST
20887: LIST
20888: PPUSH
20889: CALL_OW 69
20893: ST_TO_ADDR
// if not bar then
20894: LD_VAR 0 6
20898: NOT
20899: IFFALSE 20952
// begin repeat wait ( 0 0$1 ) ;
20901: LD_INT 35
20903: PPUSH
20904: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
20908: LD_INT 22
20910: PUSH
20911: LD_INT 4
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: PUSH
20918: LD_INT 3
20920: PUSH
20921: LD_INT 57
20923: PUSH
20924: EMPTY
20925: LIST
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: PUSH
20931: LD_INT 30
20933: PUSH
20934: LD_INT 5
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PUSH
20941: EMPTY
20942: LIST
20943: LIST
20944: LIST
20945: PPUSH
20946: CALL_OW 69
20950: IFFALSE 20901
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20952: LD_ADDR_VAR 0 6
20956: PUSH
20957: LD_INT 22
20959: PUSH
20960: LD_INT 4
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: LD_INT 30
20969: PUSH
20970: LD_INT 5
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: PPUSH
20981: CALL_OW 69
20985: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20986: LD_INT 35
20988: PPUSH
20989: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
20993: LD_EXP 120
20997: PUSH
20998: LD_INT 4
21000: ARRAY
21001: PUSH
21002: LD_INT 4
21004: GREATEREQUAL
21005: IFFALSE 20986
// tmp := [ ] ;
21007: LD_ADDR_VAR 0 2
21011: PUSH
21012: EMPTY
21013: ST_TO_ADDR
// tmp2 := [ ] ;
21014: LD_ADDR_VAR 0 3
21018: PUSH
21019: EMPTY
21020: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21021: LD_ADDR_VAR 0 1
21025: PUSH
21026: LD_INT 22
21028: PUSH
21029: LD_INT 4
21031: PUSH
21032: EMPTY
21033: LIST
21034: LIST
21035: PUSH
21036: LD_INT 2
21038: PUSH
21039: LD_INT 25
21041: PUSH
21042: LD_INT 1
21044: PUSH
21045: EMPTY
21046: LIST
21047: LIST
21048: PUSH
21049: LD_INT 25
21051: PUSH
21052: LD_INT 2
21054: PUSH
21055: EMPTY
21056: LIST
21057: LIST
21058: PUSH
21059: LD_INT 25
21061: PUSH
21062: LD_INT 3
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: LD_INT 25
21071: PUSH
21072: LD_INT 4
21074: PUSH
21075: EMPTY
21076: LIST
21077: LIST
21078: PUSH
21079: LD_INT 25
21081: PUSH
21082: LD_INT 5
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: PUSH
21089: EMPTY
21090: LIST
21091: LIST
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: PPUSH
21101: CALL_OW 69
21105: PUSH
21106: LD_EXP 60
21110: PUSH
21111: LD_EXP 61
21115: UNION
21116: DIFF
21117: PUSH
21118: FOR_IN
21119: IFFALSE 21181
// if not i in extraSquad then
21121: LD_VAR 0 1
21125: PUSH
21126: LD_EXP 62
21130: IN
21131: NOT
21132: IFFALSE 21156
// tmp := Join ( tmp , i ) else
21134: LD_ADDR_VAR 0 2
21138: PUSH
21139: LD_VAR 0 2
21143: PPUSH
21144: LD_VAR 0 1
21148: PPUSH
21149: CALL 106760 0 2
21153: ST_TO_ADDR
21154: GO 21179
// tmp := Insert ( tmp , 1 , i ) ;
21156: LD_ADDR_VAR 0 2
21160: PUSH
21161: LD_VAR 0 2
21165: PPUSH
21166: LD_INT 1
21168: PPUSH
21169: LD_VAR 0 1
21173: PPUSH
21174: CALL_OW 2
21178: ST_TO_ADDR
21179: GO 21118
21181: POP
21182: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21183: LD_ADDR_VAR 0 1
21187: PUSH
21188: LD_VAR 0 2
21192: PPUSH
21193: LD_INT 26
21195: PUSH
21196: LD_INT 1
21198: PUSH
21199: EMPTY
21200: LIST
21201: LIST
21202: PPUSH
21203: CALL_OW 72
21207: PUSH
21208: FOR_IN
21209: IFFALSE 21260
// begin p := Inc ( p ) ;
21211: LD_ADDR_VAR 0 11
21215: PUSH
21216: LD_VAR 0 11
21220: PPUSH
21221: CALL 108121 0 1
21225: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21226: LD_ADDR_VAR 0 3
21230: PUSH
21231: LD_VAR 0 3
21235: PPUSH
21236: LD_VAR 0 1
21240: PPUSH
21241: CALL 106760 0 2
21245: ST_TO_ADDR
// if p = 4 then
21246: LD_VAR 0 11
21250: PUSH
21251: LD_INT 4
21253: EQUAL
21254: IFFALSE 21258
// break ;
21256: GO 21260
// end ;
21258: GO 21208
21260: POP
21261: POP
// tmp := tmp diff tmp2 ;
21262: LD_ADDR_VAR 0 2
21266: PUSH
21267: LD_VAR 0 2
21271: PUSH
21272: LD_VAR 0 3
21276: DIFF
21277: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21278: LD_ADDR_VAR 0 2
21282: PUSH
21283: LD_VAR 0 2
21287: PPUSH
21288: LD_INT 3
21290: PPUSH
21291: CALL 105264 0 2
21295: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21296: LD_ADDR_VAR 0 3
21300: PUSH
21301: LD_VAR 0 3
21305: PPUSH
21306: LD_INT 3
21308: PPUSH
21309: CALL 105264 0 2
21313: ST_TO_ADDR
// for i := 1 to 4 do
21314: LD_ADDR_VAR 0 1
21318: PUSH
21319: DOUBLE
21320: LD_INT 1
21322: DEC
21323: ST_TO_ADDR
21324: LD_INT 4
21326: PUSH
21327: FOR_TO
21328: IFFALSE 21481
// begin if tmp2 then
21330: LD_VAR 0 3
21334: IFFALSE 21402
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21336: LD_ADDR_EXP 18
21340: PUSH
21341: LD_EXP 18
21345: PPUSH
21346: LD_INT 1
21348: PPUSH
21349: LD_EXP 18
21353: PUSH
21354: LD_INT 1
21356: ARRAY
21357: PUSH
21358: LD_VAR 0 3
21362: PUSH
21363: LD_VAR 0 3
21367: ARRAY
21368: ADD
21369: PPUSH
21370: CALL_OW 1
21374: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21375: LD_VAR 0 3
21379: PUSH
21380: LD_VAR 0 3
21384: ARRAY
21385: PPUSH
21386: LD_INT 1
21388: PPUSH
21389: CALL_OW 109
// tmp2 := [ ] ;
21393: LD_ADDR_VAR 0 3
21397: PUSH
21398: EMPTY
21399: ST_TO_ADDR
// end else
21400: GO 21479
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21402: LD_ADDR_EXP 18
21406: PUSH
21407: LD_EXP 18
21411: PPUSH
21412: LD_INT 1
21414: PPUSH
21415: LD_EXP 18
21419: PUSH
21420: LD_INT 1
21422: ARRAY
21423: PUSH
21424: LD_VAR 0 2
21428: PUSH
21429: LD_VAR 0 2
21433: ARRAY
21434: ADD
21435: PPUSH
21436: CALL_OW 1
21440: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21441: LD_VAR 0 2
21445: PUSH
21446: LD_VAR 0 2
21450: ARRAY
21451: PPUSH
21452: LD_INT 1
21454: PPUSH
21455: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21459: LD_ADDR_VAR 0 2
21463: PUSH
21464: LD_VAR 0 2
21468: PPUSH
21469: LD_VAR 0 2
21473: PPUSH
21474: CALL_OW 3
21478: ST_TO_ADDR
// end ; end ;
21479: GO 21327
21481: POP
21482: POP
// if tmp2 then
21483: LD_VAR 0 3
21487: IFFALSE 21505
// tmp := tmp union tmp2 ;
21489: LD_ADDR_VAR 0 2
21493: PUSH
21494: LD_VAR 0 2
21498: PUSH
21499: LD_VAR 0 3
21503: UNION
21504: ST_TO_ADDR
// for i := 1 to 4 do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: DOUBLE
21511: LD_INT 1
21513: DEC
21514: ST_TO_ADDR
21515: LD_INT 4
21517: PUSH
21518: FOR_TO
21519: IFFALSE 21568
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21521: LD_ADDR_EXP 18
21525: PUSH
21526: LD_EXP 18
21530: PPUSH
21531: LD_INT 2
21533: PPUSH
21534: LD_EXP 18
21538: PUSH
21539: LD_INT 2
21541: ARRAY
21542: PUSH
21543: LD_VAR 0 2
21547: PUSH
21548: LD_VAR 0 2
21552: PUSH
21553: LD_VAR 0 1
21557: MINUS
21558: ARRAY
21559: ADD
21560: PPUSH
21561: CALL_OW 1
21565: ST_TO_ADDR
21566: GO 21518
21568: POP
21569: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21570: LD_ADDR_EXP 101
21574: PUSH
21575: LD_EXP 101
21579: PPUSH
21580: LD_INT 4
21582: PPUSH
21583: LD_EXP 101
21587: PUSH
21588: LD_INT 4
21590: ARRAY
21591: PUSH
21592: LD_EXP 18
21596: PUSH
21597: LD_INT 1
21599: ARRAY
21600: DIFF
21601: PPUSH
21602: CALL_OW 1
21606: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21607: LD_VAR 0 5
21611: PUSH
21612: LD_INT 1
21614: ARRAY
21615: PPUSH
21616: CALL_OW 313
21620: IFFALSE 21675
// begin for i in UnitsInside ( arm [ 1 ] ) do
21622: LD_ADDR_VAR 0 1
21626: PUSH
21627: LD_VAR 0 5
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: PPUSH
21636: CALL_OW 313
21640: PUSH
21641: FOR_IN
21642: IFFALSE 21673
// begin ComExitBuilding ( i ) ;
21644: LD_VAR 0 1
21648: PPUSH
21649: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21653: LD_VAR 0 1
21657: PPUSH
21658: LD_VAR 0 6
21662: PUSH
21663: LD_INT 1
21665: ARRAY
21666: PPUSH
21667: CALL_OW 180
// end ;
21671: GO 21641
21673: POP
21674: POP
// end ; wait ( 0 0$3 ) ;
21675: LD_INT 105
21677: PPUSH
21678: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21682: LD_ADDR_VAR 0 1
21686: PUSH
21687: LD_EXP 18
21691: PUSH
21692: LD_INT 1
21694: ARRAY
21695: PUSH
21696: FOR_IN
21697: IFFALSE 21804
// begin if IsInUnit ( i ) then
21699: LD_VAR 0 1
21703: PPUSH
21704: CALL_OW 310
21708: IFFALSE 21719
// ComExitBuilding ( i ) ;
21710: LD_VAR 0 1
21714: PPUSH
21715: CALL_OW 122
// if GetClass ( i ) <> 1 then
21719: LD_VAR 0 1
21723: PPUSH
21724: CALL_OW 257
21728: PUSH
21729: LD_INT 1
21731: NONEQUAL
21732: IFFALSE 21773
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
21734: LD_VAR 0 1
21738: PPUSH
21739: LD_VAR 0 5
21743: PUSH
21744: LD_INT 1
21746: ARRAY
21747: PPUSH
21748: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
21752: LD_VAR 0 1
21756: PPUSH
21757: LD_INT 1
21759: PPUSH
21760: CALL_OW 183
// AddComExitBuilding ( i ) ;
21764: LD_VAR 0 1
21768: PPUSH
21769: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
21773: LD_VAR 0 1
21777: PPUSH
21778: LD_INT 60
21780: PPUSH
21781: LD_INT 94
21783: PPUSH
21784: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
21788: LD_VAR 0 1
21792: PPUSH
21793: LD_EXP 60
21797: PPUSH
21798: CALL_OW 179
// end ;
21802: GO 21696
21804: POP
21805: POP
// wait ( 0 0$45 ) ;
21806: LD_INT 1575
21808: PPUSH
21809: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
21813: LD_EXP 60
21817: PPUSH
21818: LD_STRING D4-Pow-1
21820: PPUSH
21821: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
21825: LD_ADDR_VAR 0 2
21829: PUSH
21830: LD_EXP 18
21834: PUSH
21835: LD_INT 1
21837: ARRAY
21838: PPUSH
21839: LD_INT 26
21841: PUSH
21842: LD_INT 1
21844: PUSH
21845: EMPTY
21846: LIST
21847: LIST
21848: PPUSH
21849: CALL_OW 72
21853: ST_TO_ADDR
// if tmp then
21854: LD_VAR 0 2
21858: IFFALSE 21876
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
21860: LD_VAR 0 2
21864: PUSH
21865: LD_INT 1
21867: ARRAY
21868: PPUSH
21869: LD_STRING D4-Sol1-1
21871: PPUSH
21872: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
21876: LD_EXP 60
21880: PPUSH
21881: LD_STRING D4-Pow-2
21883: PPUSH
21884: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
21888: LD_ADDR_VAR 0 1
21892: PUSH
21893: DOUBLE
21894: LD_INT 1
21896: DEC
21897: ST_TO_ADDR
21898: LD_EXP 18
21902: PUSH
21903: LD_INT 1
21905: ARRAY
21906: PUSH
21907: FOR_TO
21908: IFFALSE 22001
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
21910: LD_EXP 18
21914: PUSH
21915: LD_INT 1
21917: ARRAY
21918: PUSH
21919: LD_VAR 0 1
21923: ARRAY
21924: PPUSH
21925: LD_EXP 120
21929: PUSH
21930: LD_INT 4
21932: ARRAY
21933: PUSH
21934: LD_INT 1
21936: ARRAY
21937: PPUSH
21938: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
21942: LD_ADDR_EXP 120
21946: PUSH
21947: LD_EXP 120
21951: PPUSH
21952: LD_INT 4
21954: PPUSH
21955: LD_EXP 120
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PPUSH
21964: LD_INT 1
21966: PPUSH
21967: CALL_OW 3
21971: PPUSH
21972: CALL_OW 1
21976: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
21977: LD_INT 8
21979: PPUSH
21980: LD_EXP 18
21984: PUSH
21985: LD_INT 1
21987: ARRAY
21988: PUSH
21989: LD_VAR 0 1
21993: ARRAY
21994: PPUSH
21995: CALL_OW 471
// end ;
21999: GO 21907
22001: POP
22002: POP
// repeat wait ( 0 0$1 ) ;
22003: LD_INT 35
22005: PPUSH
22006: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22010: LD_EXP 18
22014: PUSH
22015: LD_INT 1
22017: ARRAY
22018: PPUSH
22019: LD_INT 55
22021: PUSH
22022: EMPTY
22023: LIST
22024: PPUSH
22025: CALL_OW 72
22029: PUSH
22030: LD_INT 4
22032: GREATEREQUAL
22033: IFFALSE 22003
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22035: LD_EXP 18
22039: PUSH
22040: LD_INT 1
22042: ARRAY
22043: PPUSH
22044: LD_INT 69
22046: PPUSH
22047: LD_INT 94
22049: PPUSH
22050: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22054: LD_EXP 18
22058: PUSH
22059: LD_INT 1
22061: ARRAY
22062: PPUSH
22063: LD_INT 82
22065: PPUSH
22066: LD_INT 83
22068: PPUSH
22069: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22073: LD_EXP 18
22077: PUSH
22078: LD_INT 1
22080: ARRAY
22081: PPUSH
22082: LD_INT 77
22084: PPUSH
22085: LD_INT 69
22087: PPUSH
22088: CALL_OW 174
// repeat wait ( 3 ) ;
22092: LD_INT 3
22094: PPUSH
22095: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22099: LD_ADDR_VAR 0 1
22103: PUSH
22104: LD_EXP 18
22108: PUSH
22109: LD_INT 1
22111: ARRAY
22112: PUSH
22113: FOR_IN
22114: IFFALSE 22250
// begin if GetLives ( i ) < 990 then
22116: LD_VAR 0 1
22120: PPUSH
22121: CALL_OW 256
22125: PUSH
22126: LD_INT 990
22128: LESS
22129: IFFALSE 22143
// SetLives ( i , 1000 ) ;
22131: LD_VAR 0 1
22135: PPUSH
22136: LD_INT 1000
22138: PPUSH
22139: CALL_OW 234
// if not IsInUnit ( i ) then
22143: LD_VAR 0 1
22147: PPUSH
22148: CALL_OW 310
22152: NOT
22153: IFFALSE 22248
// begin if not HasTask ( i ) then
22155: LD_VAR 0 1
22159: PPUSH
22160: CALL_OW 314
22164: NOT
22165: IFFALSE 22182
// ComMoveXY ( i , 64 , 93 ) ;
22167: LD_VAR 0 1
22171: PPUSH
22172: LD_INT 64
22174: PPUSH
22175: LD_INT 93
22177: PPUSH
22178: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22182: LD_VAR 0 4
22186: NOT
22187: PUSH
22188: LD_VAR 0 1
22192: PPUSH
22193: CALL_OW 258
22197: PUSH
22198: LD_INT 1
22200: EQUAL
22201: AND
22202: IFFALSE 22248
// begin retreat := true ;
22204: LD_ADDR_VAR 0 4
22208: PUSH
22209: LD_INT 1
22211: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22212: LD_VAR 0 1
22216: PPUSH
22217: LD_INT 2
22219: PPUSH
22220: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22224: LD_VAR 0 1
22228: PPUSH
22229: LD_STRING D4a-Sol1-1
22231: PPUSH
22232: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22236: LD_EXP 60
22240: PPUSH
22241: LD_STRING D4a-Pow-1
22243: PPUSH
22244: CALL_OW 88
// end ; end ; end ;
22248: GO 22113
22250: POP
22251: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22252: LD_EXP 18
22256: PUSH
22257: LD_INT 1
22259: ARRAY
22260: PPUSH
22261: LD_INT 95
22263: PUSH
22264: LD_INT 9
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: PUSH
22271: LD_INT 3
22273: PUSH
22274: LD_INT 55
22276: PUSH
22277: EMPTY
22278: LIST
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PPUSH
22288: CALL_OW 72
22292: PUSH
22293: LD_INT 4
22295: GREATEREQUAL
22296: IFFALSE 22092
// for i in powellSquadAttack [ 1 ] do
22298: LD_ADDR_VAR 0 1
22302: PUSH
22303: LD_EXP 18
22307: PUSH
22308: LD_INT 1
22310: ARRAY
22311: PUSH
22312: FOR_IN
22313: IFFALSE 22449
// begin if GetTag ( i ) = 2 then
22315: LD_VAR 0 1
22319: PPUSH
22320: CALL_OW 110
22324: PUSH
22325: LD_INT 2
22327: EQUAL
22328: IFFALSE 22390
// begin ComMoveXY ( i , 60 , 94 ) ;
22330: LD_VAR 0 1
22334: PPUSH
22335: LD_INT 60
22337: PPUSH
22338: LD_INT 94
22340: PPUSH
22341: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22345: LD_VAR 0 1
22349: PPUSH
22350: LD_EXP 60
22354: PPUSH
22355: CALL_OW 179
// wait ( 0 0$3 ) ;
22359: LD_INT 105
22361: PPUSH
22362: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22366: LD_VAR 0 1
22370: PPUSH
22371: LD_STRING D4a-Sol1-2
22373: PPUSH
22374: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22378: LD_EXP 60
22382: PPUSH
22383: LD_STRING D4a-Pow-2
22385: PPUSH
22386: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22390: LD_VAR 0 1
22394: PPUSH
22395: LD_INT 0
22397: PPUSH
22398: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22402: LD_ADDR_EXP 101
22406: PUSH
22407: LD_EXP 101
22411: PPUSH
22412: LD_INT 4
22414: PPUSH
22415: LD_EXP 101
22419: PUSH
22420: LD_INT 4
22422: ARRAY
22423: PUSH
22424: LD_VAR 0 1
22428: UNION
22429: PPUSH
22430: CALL_OW 1
22434: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22435: LD_INT 8
22437: PPUSH
22438: LD_VAR 0 1
22442: PPUSH
22443: CALL_OW 472
// end ;
22447: GO 22312
22449: POP
22450: POP
// wait ( 2 2$00 ) ;
22451: LD_INT 4200
22453: PPUSH
22454: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22458: LD_ADDR_VAR 0 9
22462: PUSH
22463: LD_INT 22
22465: PUSH
22466: LD_INT 4
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: PUSH
22473: LD_INT 30
22475: PUSH
22476: LD_INT 32
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: PUSH
22483: LD_INT 58
22485: PUSH
22486: EMPTY
22487: LIST
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: LIST
22493: PPUSH
22494: CALL_OW 69
22498: ST_TO_ADDR
// if tmp then
22499: LD_VAR 0 2
22503: IFFALSE 22743
// begin for i := 1 to tmp do
22505: LD_ADDR_VAR 0 1
22509: PUSH
22510: DOUBLE
22511: LD_INT 1
22513: DEC
22514: ST_TO_ADDR
22515: LD_VAR 0 2
22519: PUSH
22520: FOR_TO
22521: IFFALSE 22734
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22523: LD_ADDR_EXP 101
22527: PUSH
22528: LD_EXP 101
22532: PPUSH
22533: LD_INT 4
22535: PPUSH
22536: LD_EXP 101
22540: PUSH
22541: LD_INT 4
22543: ARRAY
22544: PUSH
22545: LD_VAR 0 2
22549: PUSH
22550: LD_VAR 0 1
22554: ARRAY
22555: DIFF
22556: PPUSH
22557: CALL_OW 1
22561: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22562: LD_ADDR_VAR 0 10
22566: PUSH
22567: LD_VAR 0 2
22571: PUSH
22572: LD_VAR 0 1
22576: ARRAY
22577: PPUSH
22578: CALL_OW 310
22582: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22583: LD_VAR 0 10
22587: PUSH
22588: LD_VAR 0 10
22592: PPUSH
22593: CALL_OW 266
22597: PUSH
22598: LD_INT 32
22600: EQUAL
22601: AND
22602: IFFALSE 22606
// continue ;
22604: GO 22520
// if t then
22606: LD_VAR 0 10
22610: IFFALSE 22627
// ComExitBuilding ( tmp [ i ] ) ;
22612: LD_VAR 0 2
22616: PUSH
22617: LD_VAR 0 1
22621: ARRAY
22622: PPUSH
22623: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22627: LD_VAR 0 2
22631: PUSH
22632: LD_VAR 0 1
22636: ARRAY
22637: PPUSH
22638: LD_VAR 0 5
22642: PUSH
22643: LD_INT 1
22645: ARRAY
22646: PPUSH
22647: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22651: LD_VAR 0 2
22655: PUSH
22656: LD_VAR 0 1
22660: ARRAY
22661: PPUSH
22662: LD_INT 1
22664: PPUSH
22665: CALL_OW 183
// if emptyTowers then
22669: LD_VAR 0 9
22673: IFFALSE 22732
// begin AddComExitBuilding ( tmp [ i ] ) ;
22675: LD_VAR 0 2
22679: PUSH
22680: LD_VAR 0 1
22684: ARRAY
22685: PPUSH
22686: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22690: LD_VAR 0 2
22694: PUSH
22695: LD_VAR 0 1
22699: ARRAY
22700: PPUSH
22701: LD_VAR 0 9
22705: PUSH
22706: LD_INT 1
22708: ARRAY
22709: PPUSH
22710: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
22714: LD_ADDR_VAR 0 9
22718: PUSH
22719: LD_VAR 0 9
22723: PPUSH
22724: LD_INT 1
22726: PPUSH
22727: CALL_OW 3
22731: ST_TO_ADDR
// end ; end ;
22732: GO 22520
22734: POP
22735: POP
// wait ( 0 0$30 ) ;
22736: LD_INT 1050
22738: PPUSH
22739: CALL_OW 67
// end ; uc_side := 6 ;
22743: LD_ADDR_OWVAR 20
22747: PUSH
22748: LD_INT 6
22750: ST_TO_ADDR
// uc_nation := 3 ;
22751: LD_ADDR_OWVAR 21
22755: PUSH
22756: LD_INT 3
22758: ST_TO_ADDR
// ru := [ ] ;
22759: LD_ADDR_VAR 0 7
22763: PUSH
22764: EMPTY
22765: ST_TO_ADDR
// for i = 1 to 5 do
22766: LD_ADDR_VAR 0 1
22770: PUSH
22771: DOUBLE
22772: LD_INT 1
22774: DEC
22775: ST_TO_ADDR
22776: LD_INT 5
22778: PUSH
22779: FOR_TO
22780: IFFALSE 22900
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
22782: LD_INT 22
22784: PUSH
22785: LD_INT 23
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: PUSH
22792: LD_INT 1
22794: PPUSH
22795: LD_INT 2
22797: PPUSH
22798: CALL_OW 12
22802: ARRAY
22803: PPUSH
22804: LD_INT 1
22806: PPUSH
22807: LD_INT 3
22809: PPUSH
22810: LD_INT 43
22812: PUSH
22813: LD_INT 44
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: PUSH
22820: LD_INT 1
22822: PPUSH
22823: LD_INT 2
22825: PPUSH
22826: CALL_OW 12
22830: ARRAY
22831: PPUSH
22832: LD_INT 89
22834: PPUSH
22835: CALL 73898 0 5
// un := CreateVehicle ;
22839: LD_ADDR_VAR 0 8
22843: PUSH
22844: CALL_OW 45
22848: ST_TO_ADDR
// SetDir ( un , 4 ) ;
22849: LD_VAR 0 8
22853: PPUSH
22854: LD_INT 4
22856: PPUSH
22857: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
22861: LD_VAR 0 8
22865: PPUSH
22866: LD_INT 136
22868: PPUSH
22869: LD_INT 90
22871: PPUSH
22872: LD_INT 8
22874: PPUSH
22875: LD_INT 0
22877: PPUSH
22878: CALL_OW 50
// ru := ru ^ un ;
22882: LD_ADDR_VAR 0 7
22886: PUSH
22887: LD_VAR 0 7
22891: PUSH
22892: LD_VAR 0 8
22896: ADD
22897: ST_TO_ADDR
// end ;
22898: GO 22779
22900: POP
22901: POP
// if ru then
22902: LD_VAR 0 7
22906: IFFALSE 22923
// ComAgressiveMove ( ru , 57 , 94 ) ;
22908: LD_VAR 0 7
22912: PPUSH
22913: LD_INT 57
22915: PPUSH
22916: LD_INT 94
22918: PPUSH
22919: CALL_OW 114
// wait ( 3 3$00 ) ;
22923: LD_INT 6300
22925: PPUSH
22926: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22930: LD_INT 4
22932: PPUSH
22933: LD_INT 3
22935: PUSH
22936: LD_INT 1
22938: PUSH
22939: LD_INT 1
22941: PUSH
22942: LD_INT 5
22944: PUSH
22945: EMPTY
22946: LIST
22947: LIST
22948: LIST
22949: LIST
22950: PUSH
22951: LD_INT 4
22953: PUSH
22954: LD_INT 1
22956: PUSH
22957: LD_INT 1
22959: PUSH
22960: LD_INT 6
22962: PUSH
22963: EMPTY
22964: LIST
22965: LIST
22966: LIST
22967: LIST
22968: PUSH
22969: LD_INT 4
22971: PUSH
22972: LD_INT 1
22974: PUSH
22975: LD_INT 1
22977: PUSH
22978: LD_INT 7
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: LIST
22986: PUSH
22987: LD_INT 3
22989: PUSH
22990: LD_INT 1
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: LD_INT 7
22998: PUSH
22999: EMPTY
23000: LIST
23001: LIST
23002: LIST
23003: LIST
23004: PUSH
23005: LD_INT 3
23007: PUSH
23008: LD_INT 1
23010: PUSH
23011: LD_INT 1
23013: PUSH
23014: LD_INT 5
23016: PUSH
23017: EMPTY
23018: LIST
23019: LIST
23020: LIST
23021: LIST
23022: PUSH
23023: EMPTY
23024: LIST
23025: LIST
23026: LIST
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL 62584 0 2
// missionStage := 4 ;
23034: LD_ADDR_EXP 15
23038: PUSH
23039: LD_INT 4
23041: ST_TO_ADDR
// end ;
23042: PPOPN 11
23044: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23045: LD_EXP 15
23049: PUSH
23050: LD_INT 4
23052: EQUAL
23053: PUSH
23054: LD_INT 22
23056: PUSH
23057: LD_INT 4
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: PUSH
23064: LD_INT 21
23066: PUSH
23067: LD_INT 2
23069: PUSH
23070: EMPTY
23071: LIST
23072: LIST
23073: PUSH
23074: EMPTY
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 69
23082: PUSH
23083: LD_INT 5
23085: GREATEREQUAL
23086: AND
23087: IFFALSE 27354
23089: GO 23091
23091: DISABLE
23092: LD_INT 0
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
23104: PPUSH
23105: PPUSH
23106: PPUSH
// begin wait ( 0 0$10 ) ;
23107: LD_INT 350
23109: PPUSH
23110: CALL_OW 67
// missionStage := 5 ;
23114: LD_ADDR_EXP 15
23118: PUSH
23119: LD_INT 5
23121: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23122: LD_ADDR_VAR 0 10
23126: PUSH
23127: LD_INT 22
23129: PUSH
23130: LD_INT 4
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: PUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 4
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 5
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PPUSH
23169: CALL_OW 69
23173: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23174: LD_ADDR_VAR 0 6
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 4
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 1
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 3
23201: PUSH
23202: LD_INT 25
23204: PUSH
23205: LD_INT 16
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 3
23218: PUSH
23219: LD_INT 25
23221: PUSH
23222: LD_INT 12
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: PPUSH
23239: CALL_OW 69
23243: PUSH
23244: LD_EXP 60
23248: DIFF
23249: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23250: LD_ADDR_VAR 0 9
23254: PUSH
23255: LD_INT 22
23257: PUSH
23258: LD_INT 4
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: LD_INT 30
23267: PUSH
23268: LD_INT 3
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PPUSH
23279: CALL_OW 69
23283: PUSH
23284: LD_INT 1
23286: ARRAY
23287: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23288: LD_INT 350
23290: PPUSH
23291: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23295: LD_EXP 120
23299: PUSH
23300: LD_INT 4
23302: ARRAY
23303: PUSH
23304: LD_INT 5
23306: LESS
23307: PUSH
23308: LD_VAR 0 9
23312: PPUSH
23313: CALL_OW 461
23317: PUSH
23318: LD_INT 2
23320: EQUAL
23321: AND
23322: IFFALSE 23352
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23324: LD_INT 4
23326: PPUSH
23327: LD_INT 3
23329: PUSH
23330: LD_INT 1
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: LD_INT 5
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: PUSH
23345: EMPTY
23346: LIST
23347: PPUSH
23348: CALL 62632 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23352: LD_EXP 120
23356: PUSH
23357: LD_INT 4
23359: ARRAY
23360: PUSH
23361: LD_INT 5
23363: GREATEREQUAL
23364: PUSH
23365: LD_EXP 120
23369: PUSH
23370: LD_INT 4
23372: ARRAY
23373: PPUSH
23374: LD_INT 58
23376: PUSH
23377: EMPTY
23378: LIST
23379: PPUSH
23380: CALL_OW 72
23384: PUSH
23385: LD_INT 5
23387: GREATEREQUAL
23388: AND
23389: IFFALSE 23288
// powellAllowRetreat := false ;
23391: LD_ADDR_EXP 19
23395: PUSH
23396: LD_INT 0
23398: ST_TO_ADDR
// activeAttacks := false ;
23399: LD_ADDR_EXP 16
23403: PUSH
23404: LD_INT 0
23406: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23407: LD_INT 35
23409: PPUSH
23410: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23414: LD_INT 22
23416: PUSH
23417: LD_INT 6
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PPUSH
23424: CALL_OW 69
23428: PUSH
23429: LD_INT 0
23431: EQUAL
23432: IFFALSE 23407
// tmp := mc_vehicles [ 4 ] ;
23434: LD_ADDR_VAR 0 3
23438: PUSH
23439: LD_EXP 120
23443: PUSH
23444: LD_INT 4
23446: ARRAY
23447: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23448: LD_ADDR_VAR 0 1
23452: PUSH
23453: DOUBLE
23454: LD_INT 1
23456: DEC
23457: ST_TO_ADDR
23458: LD_EXP 18
23462: PUSH
23463: FOR_TO
23464: IFFALSE 23725
// begin for j in powellSquadAttack [ i ] do
23466: LD_ADDR_VAR 0 2
23470: PUSH
23471: LD_EXP 18
23475: PUSH
23476: LD_VAR 0 1
23480: ARRAY
23481: PUSH
23482: FOR_IN
23483: IFFALSE 23721
// begin forces := forces diff j ;
23485: LD_ADDR_VAR 0 6
23489: PUSH
23490: LD_VAR 0 6
23494: PUSH
23495: LD_VAR 0 2
23499: DIFF
23500: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23501: LD_VAR 0 2
23505: PPUSH
23506: LD_INT 1
23508: PPUSH
23509: CALL_OW 109
// wait ( 0 0$2 ) ;
23513: LD_INT 70
23515: PPUSH
23516: CALL_OW 67
// if IsInUnit ( j ) then
23520: LD_VAR 0 2
23524: PPUSH
23525: CALL_OW 310
23529: IFFALSE 23540
// ComExitBuilding ( j ) ;
23531: LD_VAR 0 2
23535: PPUSH
23536: CALL_OW 122
// if GetClass ( j ) <> 1 then
23540: LD_VAR 0 2
23544: PPUSH
23545: CALL_OW 257
23549: PUSH
23550: LD_INT 1
23552: NONEQUAL
23553: IFFALSE 23633
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23555: LD_VAR 0 10
23559: PUSH
23560: LD_INT 1
23562: ARRAY
23563: PPUSH
23564: CALL_OW 313
23568: PUSH
23569: LD_INT 5
23571: GREATEREQUAL
23572: IFFALSE 23594
// AddComEnterUnit ( j , arm [ 2 ] ) else
23574: LD_VAR 0 2
23578: PPUSH
23579: LD_VAR 0 10
23583: PUSH
23584: LD_INT 2
23586: ARRAY
23587: PPUSH
23588: CALL_OW 180
23592: GO 23612
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23594: LD_VAR 0 2
23598: PPUSH
23599: LD_VAR 0 10
23603: PUSH
23604: LD_INT 1
23606: ARRAY
23607: PPUSH
23608: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23612: LD_VAR 0 2
23616: PPUSH
23617: LD_INT 1
23619: PPUSH
23620: CALL_OW 183
// AddComExitBuilding ( j ) ;
23624: LD_VAR 0 2
23628: PPUSH
23629: CALL_OW 182
// end ; if i = 2 then
23633: LD_VAR 0 1
23637: PUSH
23638: LD_INT 2
23640: EQUAL
23641: IFFALSE 23658
// AddComMoveXY ( j , 61 , 93 ) ;
23643: LD_VAR 0 2
23647: PPUSH
23648: LD_INT 61
23650: PPUSH
23651: LD_INT 93
23653: PPUSH
23654: CALL_OW 171
// if i = 1 then
23658: LD_VAR 0 1
23662: PUSH
23663: LD_INT 1
23665: EQUAL
23666: IFFALSE 23719
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23668: LD_VAR 0 2
23672: PPUSH
23673: LD_VAR 0 3
23677: PUSH
23678: LD_INT 1
23680: ARRAY
23681: PPUSH
23682: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23686: LD_ADDR_VAR 0 3
23690: PUSH
23691: LD_VAR 0 3
23695: PPUSH
23696: LD_INT 1
23698: PPUSH
23699: CALL_OW 3
23703: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
23704: LD_VAR 0 2
23708: PPUSH
23709: LD_INT 69
23711: PPUSH
23712: LD_INT 94
23714: PPUSH
23715: CALL_OW 171
// end ; end ;
23719: GO 23482
23721: POP
23722: POP
// end ;
23723: GO 23463
23725: POP
23726: POP
// wait ( 0 0$30 ) ;
23727: LD_INT 1050
23729: PPUSH
23730: CALL_OW 67
// MC_Kill ( 4 ) ;
23734: LD_INT 4
23736: PPUSH
23737: CALL 38607 0 1
// tmp := UnitsInside ( fac ) ;
23741: LD_ADDR_VAR 0 3
23745: PUSH
23746: LD_VAR 0 9
23750: PPUSH
23751: CALL_OW 313
23755: ST_TO_ADDR
// if tmp then
23756: LD_VAR 0 3
23760: IFFALSE 23881
// for i in tmp do
23762: LD_ADDR_VAR 0 1
23766: PUSH
23767: LD_VAR 0 3
23771: PUSH
23772: FOR_IN
23773: IFFALSE 23879
// begin ComExitBuilding ( i ) ;
23775: LD_VAR 0 1
23779: PPUSH
23780: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
23784: LD_VAR 0 10
23788: PUSH
23789: LD_INT 2
23791: ARRAY
23792: PPUSH
23793: CALL_OW 313
23797: PUSH
23798: LD_INT 6
23800: LESS
23801: IFFALSE 23823
// AddComEnterUnit ( i , arm [ 2 ] ) else
23803: LD_VAR 0 1
23807: PPUSH
23808: LD_VAR 0 10
23812: PUSH
23813: LD_INT 2
23815: ARRAY
23816: PPUSH
23817: CALL_OW 180
23821: GO 23877
// if UnitsInside ( arm [ 1 ] ) < 6 then
23823: LD_VAR 0 10
23827: PUSH
23828: LD_INT 1
23830: ARRAY
23831: PPUSH
23832: CALL_OW 313
23836: PUSH
23837: LD_INT 6
23839: LESS
23840: IFFALSE 23862
// AddComEnterUnit ( i , arm [ 1 ] ) else
23842: LD_VAR 0 1
23846: PPUSH
23847: LD_VAR 0 10
23851: PUSH
23852: LD_INT 1
23854: ARRAY
23855: PPUSH
23856: CALL_OW 180
23860: GO 23877
// AddComMoveXY ( i , 37 , 68 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 37
23869: PPUSH
23870: LD_INT 68
23872: PPUSH
23873: CALL_OW 171
// end ;
23877: GO 23772
23879: POP
23880: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
23881: LD_ADDR_VAR 0 11
23885: PUSH
23886: LD_VAR 0 6
23890: PPUSH
23891: LD_INT 26
23893: PUSH
23894: LD_INT 1
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: PPUSH
23901: CALL_OW 72
23905: PUSH
23906: LD_EXP 61
23910: DIFF
23911: ST_TO_ADDR
// if not speaker then
23912: LD_VAR 0 11
23916: NOT
23917: IFFALSE 23944
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
23919: LD_ADDR_VAR 0 11
23923: PUSH
23924: LD_VAR 0 6
23928: PPUSH
23929: LD_INT 26
23931: PUSH
23932: LD_INT 1
23934: PUSH
23935: EMPTY
23936: LIST
23937: LIST
23938: PPUSH
23939: CALL_OW 72
23943: ST_TO_ADDR
// if speaker then
23944: LD_VAR 0 11
23948: IFFALSE 23964
// speaker := speaker [ 1 ] ;
23950: LD_ADDR_VAR 0 11
23954: PUSH
23955: LD_VAR 0 11
23959: PUSH
23960: LD_INT 1
23962: ARRAY
23963: ST_TO_ADDR
// Video ( true ) ;
23964: LD_INT 1
23966: PPUSH
23967: CALL 106732 0 1
// CenterNowOnUnits ( Powell ) ;
23971: LD_EXP 60
23975: PPUSH
23976: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
23980: LD_ADDR_VAR 0 3
23984: PUSH
23985: LD_VAR 0 6
23989: PPUSH
23990: LD_INT 3
23992: PUSH
23993: LD_INT 25
23995: PUSH
23996: LD_INT 1
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PPUSH
24007: CALL_OW 72
24011: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24012: LD_ADDR_VAR 0 12
24016: PUSH
24017: LD_INT 22
24019: PUSH
24020: LD_INT 4
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: LD_INT 32
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 58
24039: PUSH
24040: EMPTY
24041: LIST
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: LIST
24047: PPUSH
24048: CALL_OW 69
24052: ST_TO_ADDR
// for i := 1 to 4 do
24053: LD_ADDR_VAR 0 1
24057: PUSH
24058: DOUBLE
24059: LD_INT 1
24061: DEC
24062: ST_TO_ADDR
24063: LD_INT 4
24065: PUSH
24066: FOR_TO
24067: IFFALSE 24213
// begin if IsInUnit ( tmp [ i ] ) then
24069: LD_VAR 0 3
24073: PUSH
24074: LD_VAR 0 1
24078: ARRAY
24079: PPUSH
24080: CALL_OW 310
24084: IFFALSE 24101
// ComExitBuilding ( tmp [ i ] ) ;
24086: LD_VAR 0 3
24090: PUSH
24091: LD_VAR 0 1
24095: ARRAY
24096: PPUSH
24097: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24101: LD_VAR 0 3
24105: PUSH
24106: LD_VAR 0 1
24110: ARRAY
24111: PPUSH
24112: LD_VAR 0 10
24116: PUSH
24117: LD_INT 1
24119: ARRAY
24120: PPUSH
24121: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24125: LD_VAR 0 3
24129: PUSH
24130: LD_VAR 0 1
24134: ARRAY
24135: PPUSH
24136: LD_INT 1
24138: PPUSH
24139: CALL_OW 183
// if Count ( emp_towers ) then
24143: LD_VAR 0 12
24147: PPUSH
24148: CALL 71160 0 1
24152: IFFALSE 24211
// begin AddComExitBuilding ( tmp [ i ] ) ;
24154: LD_VAR 0 3
24158: PUSH
24159: LD_VAR 0 1
24163: ARRAY
24164: PPUSH
24165: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24169: LD_VAR 0 3
24173: PUSH
24174: LD_VAR 0 1
24178: ARRAY
24179: PPUSH
24180: LD_VAR 0 12
24184: PUSH
24185: LD_INT 1
24187: ARRAY
24188: PPUSH
24189: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: CALL_OW 3
24210: ST_TO_ADDR
// end ; end ;
24211: GO 24066
24213: POP
24214: POP
// wait ( 0 0$5 ) ;
24215: LD_INT 175
24217: PPUSH
24218: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24222: LD_VAR 0 3
24226: PPUSH
24227: LD_INT 3
24229: PUSH
24230: LD_INT 54
24232: PUSH
24233: EMPTY
24234: LIST
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PPUSH
24240: CALL_OW 72
24244: IFFALSE 24264
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24246: LD_VAR 0 3
24250: PPUSH
24251: LD_VAR 0 10
24255: PUSH
24256: LD_INT 1
24258: ARRAY
24259: PPUSH
24260: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24264: LD_ADDR_VAR 0 3
24268: PUSH
24269: LD_EXP 18
24273: PUSH
24274: LD_INT 1
24276: ARRAY
24277: PUSH
24278: LD_EXP 18
24282: PUSH
24283: LD_INT 2
24285: ARRAY
24286: ADD
24287: PPUSH
24288: LD_INT 26
24290: PUSH
24291: LD_INT 1
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PPUSH
24298: CALL_OW 72
24302: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24303: LD_ADDR_VAR 0 1
24307: PUSH
24308: LD_EXP 18
24312: PUSH
24313: LD_INT 2
24315: ARRAY
24316: PUSH
24317: FOR_IN
24318: IFFALSE 24336
// ComTurnUnit ( i , Powell ) ;
24320: LD_VAR 0 1
24324: PPUSH
24325: LD_EXP 60
24329: PPUSH
24330: CALL_OW 119
24334: GO 24317
24336: POP
24337: POP
// Say ( Powell , D5-Pow-1 ) ;
24338: LD_EXP 60
24342: PPUSH
24343: LD_STRING D5-Pow-1
24345: PPUSH
24346: CALL_OW 88
// if tmp then
24350: LD_VAR 0 3
24354: IFFALSE 24372
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24356: LD_VAR 0 3
24360: PUSH
24361: LD_INT 1
24363: ARRAY
24364: PPUSH
24365: LD_STRING D5-Sol2-1
24367: PPUSH
24368: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24372: LD_EXP 60
24376: PPUSH
24377: LD_STRING D5-Pow-2
24379: PPUSH
24380: CALL_OW 88
// if tmp > 1 then
24384: LD_VAR 0 3
24388: PUSH
24389: LD_INT 1
24391: GREATER
24392: IFFALSE 24410
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24394: LD_VAR 0 3
24398: PUSH
24399: LD_INT 2
24401: ARRAY
24402: PPUSH
24403: LD_STRING D5-Sol2-2
24405: PPUSH
24406: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24410: LD_EXP 60
24414: PPUSH
24415: LD_STRING D5-Pow-3
24417: PPUSH
24418: CALL_OW 88
// wait ( 0 0$1 ) ;
24422: LD_INT 35
24424: PPUSH
24425: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24429: LD_ADDR_VAR 0 3
24433: PUSH
24434: LD_EXP 18
24438: PUSH
24439: LD_INT 1
24441: ARRAY
24442: PUSH
24443: LD_EXP 18
24447: PUSH
24448: LD_INT 2
24450: ARRAY
24451: UNION
24452: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24453: LD_VAR 0 3
24457: PPUSH
24458: LD_INT 80
24460: PPUSH
24461: LD_INT 67
24463: PPUSH
24464: CALL_OW 114
// wait ( 0 0$2 ) ;
24468: LD_INT 70
24470: PPUSH
24471: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24475: LD_INT 79
24477: PPUSH
24478: LD_INT 72
24480: PPUSH
24481: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24485: LD_INT 70
24487: PPUSH
24488: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24492: LD_VAR 0 3
24496: PPUSH
24497: LD_INT 3
24499: PUSH
24500: LD_INT 24
24502: PUSH
24503: LD_INT 1000
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PPUSH
24514: CALL_OW 72
24518: IFFALSE 24485
// Say ( Powell , D5a-Pow-1 ) ;
24520: LD_EXP 60
24524: PPUSH
24525: LD_STRING D5a-Pow-1
24527: PPUSH
24528: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24532: LD_EXP 60
24536: PPUSH
24537: LD_STRING D5a-Pow-1a
24539: PPUSH
24540: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24544: LD_INT 24
24546: PPUSH
24547: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24551: LD_EXP 60
24555: PPUSH
24556: LD_STRING D5a-Pow-1b
24558: PPUSH
24559: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24563: LD_INT 10
24565: PPUSH
24566: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24570: LD_EXP 60
24574: PPUSH
24575: LD_STRING D5a-Pow-1c
24577: PPUSH
24578: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24582: LD_VAR 0 3
24586: PPUSH
24587: LD_INT 68
24589: PPUSH
24590: LD_INT 63
24592: PPUSH
24593: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24597: LD_INT 18
24599: PPUSH
24600: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24604: LD_EXP 60
24608: PPUSH
24609: LD_STRING D5a-Pow-1d
24611: PPUSH
24612: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24616: LD_INT 35
24618: PPUSH
24619: CALL_OW 67
// if not HasTask ( tmp ) then
24623: LD_VAR 0 3
24627: PPUSH
24628: CALL_OW 314
24632: NOT
24633: IFFALSE 24650
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24635: LD_VAR 0 3
24639: PPUSH
24640: LD_INT 68
24642: PPUSH
24643: LD_INT 63
24645: PPUSH
24646: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24650: LD_VAR 0 3
24654: PPUSH
24655: LD_INT 24
24657: PUSH
24658: LD_INT 1
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PPUSH
24665: CALL_OW 72
24669: NOT
24670: IFFALSE 24616
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24672: LD_ADDR_VAR 0 3
24676: PUSH
24677: LD_INT 22
24679: PUSH
24680: LD_INT 4
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 92
24689: PUSH
24690: LD_INT 60
24692: PUSH
24693: LD_INT 93
24695: PUSH
24696: LD_INT 10
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 3
24707: PUSH
24708: LD_INT 54
24710: PUSH
24711: EMPTY
24712: LIST
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: LIST
24722: PPUSH
24723: CALL_OW 69
24727: PUSH
24728: LD_EXP 60
24732: DIFF
24733: ST_TO_ADDR
// if tmp then
24734: LD_VAR 0 3
24738: IFFALSE 24772
// for i in tmp do
24740: LD_ADDR_VAR 0 1
24744: PUSH
24745: LD_VAR 0 3
24749: PUSH
24750: FOR_IN
24751: IFFALSE 24770
// ComMoveXY ( i , 36 , 67 ) ;
24753: LD_VAR 0 1
24757: PPUSH
24758: LD_INT 36
24760: PPUSH
24761: LD_INT 67
24763: PPUSH
24764: CALL_OW 111
24768: GO 24750
24770: POP
24771: POP
// wait ( 0 0$3 ) ;
24772: LD_INT 105
24774: PPUSH
24775: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
24779: LD_VAR 0 11
24783: PPUSH
24784: LD_STRING D6-Sol3-1
24786: PPUSH
24787: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
24791: LD_EXP 60
24795: PPUSH
24796: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
24800: LD_EXP 60
24804: PPUSH
24805: LD_STRING D6-Pow-1
24807: PPUSH
24808: CALL_OW 88
// tmp := [ ] ;
24812: LD_ADDR_VAR 0 3
24816: PUSH
24817: EMPTY
24818: ST_TO_ADDR
// for i = 1 to 2 do
24819: LD_ADDR_VAR 0 1
24823: PUSH
24824: DOUBLE
24825: LD_INT 1
24827: DEC
24828: ST_TO_ADDR
24829: LD_INT 2
24831: PUSH
24832: FOR_TO
24833: IFFALSE 24947
// begin uc_side := 8 ;
24835: LD_ADDR_OWVAR 20
24839: PUSH
24840: LD_INT 8
24842: ST_TO_ADDR
// uc_nation := 2 ;
24843: LD_ADDR_OWVAR 21
24847: PUSH
24848: LD_INT 2
24850: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
24851: LD_INT 14
24853: PPUSH
24854: LD_INT 3
24856: PPUSH
24857: LD_INT 2
24859: PPUSH
24860: LD_INT 29
24862: PPUSH
24863: LD_INT 100
24865: PPUSH
24866: CALL 73898 0 5
// veh := CreateVehicle ;
24870: LD_ADDR_VAR 0 13
24874: PUSH
24875: CALL_OW 45
24879: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
24880: LD_VAR 0 13
24884: PPUSH
24885: LD_INT 4
24887: PPUSH
24888: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
24892: LD_VAR 0 13
24896: PPUSH
24897: LD_INT 99
24899: PPUSH
24900: LD_INT 83
24902: PPUSH
24903: LD_INT 3
24905: PPUSH
24906: LD_INT 0
24908: PPUSH
24909: CALL_OW 50
// wait ( 3 ) ;
24913: LD_INT 3
24915: PPUSH
24916: CALL_OW 67
// Connect ( veh ) ;
24920: LD_VAR 0 13
24924: PPUSH
24925: CALL 77366 0 1
// tmp := tmp ^ veh ;
24929: LD_ADDR_VAR 0 3
24933: PUSH
24934: LD_VAR 0 3
24938: PUSH
24939: LD_VAR 0 13
24943: ADD
24944: ST_TO_ADDR
// end ;
24945: GO 24832
24947: POP
24948: POP
// wait ( 0 0$1 ) ;
24949: LD_INT 35
24951: PPUSH
24952: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
24956: LD_INT 99
24958: PPUSH
24959: LD_INT 83
24961: PPUSH
24962: LD_INT 1
24964: PPUSH
24965: LD_INT 10
24967: PPUSH
24968: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
24972: LD_INT 99
24974: PPUSH
24975: LD_INT 83
24977: PPUSH
24978: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
24982: LD_VAR 0 11
24986: PPUSH
24987: LD_STRING D6-Sol3-2
24989: PPUSH
24990: CALL_OW 88
// async ;
24994: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
24995: LD_EXP 60
24999: PPUSH
25000: LD_STRING D6-Pow-2
25002: PPUSH
25003: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25007: LD_VAR 0 3
25011: PUSH
25012: LD_INT 1
25014: ARRAY
25015: PPUSH
25016: LD_VAR 0 9
25020: PPUSH
25021: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25025: LD_VAR 0 3
25029: PUSH
25030: LD_INT 2
25032: ARRAY
25033: PPUSH
25034: LD_INT 22
25036: PUSH
25037: LD_INT 4
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 21
25046: PUSH
25047: LD_INT 3
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PPUSH
25058: CALL_OW 69
25062: PPUSH
25063: LD_VAR 0 3
25067: PUSH
25068: LD_INT 2
25070: ARRAY
25071: PPUSH
25072: CALL_OW 74
25076: PPUSH
25077: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25081: LD_EXP 60
25085: PPUSH
25086: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25090: LD_INT 99
25092: PPUSH
25093: LD_INT 83
25095: PPUSH
25096: LD_INT 1
25098: PPUSH
25099: CALL_OW 331
// repeat wait ( 4 ) ;
25103: LD_INT 4
25105: PPUSH
25106: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25110: LD_VAR 0 3
25114: PUSH
25115: LD_INT 1
25117: ARRAY
25118: PPUSH
25119: CALL_OW 256
25123: PUSH
25124: LD_INT 1000
25126: LESS
25127: IFFALSE 25145
// SetLives ( tmp [ 1 ] , 1000 ) ;
25129: LD_VAR 0 3
25133: PUSH
25134: LD_INT 1
25136: ARRAY
25137: PPUSH
25138: LD_INT 1000
25140: PPUSH
25141: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25145: LD_INT 22
25147: PUSH
25148: LD_INT 4
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PUSH
25155: LD_INT 30
25157: PUSH
25158: LD_INT 3
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PPUSH
25169: CALL_OW 69
25173: PUSH
25174: LD_INT 0
25176: EQUAL
25177: IFFALSE 25103
// skirmish := false ;
25179: LD_ADDR_EXP 99
25183: PUSH
25184: LD_INT 0
25186: ST_TO_ADDR
// sync ;
25187: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25188: LD_EXP 60
25192: PPUSH
25193: LD_STRING D6a-Pow-1
25195: PPUSH
25196: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25200: LD_VAR 0 11
25204: PPUSH
25205: LD_STRING D6a-Sol3-1
25207: PPUSH
25208: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25212: LD_EXP 60
25216: PPUSH
25217: LD_STRING D6a-Pow-2
25219: PPUSH
25220: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25224: LD_VAR 0 11
25228: PPUSH
25229: LD_STRING D6a-Sol3-2
25231: PPUSH
25232: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25236: LD_EXP 60
25240: PPUSH
25241: LD_STRING D6a-Pow-3
25243: PPUSH
25244: CALL_OW 88
// powellCenterCameraMode := true ;
25248: LD_ADDR_EXP 20
25252: PUSH
25253: LD_INT 1
25255: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25256: LD_ADDR_VAR 0 1
25260: PUSH
25261: LD_INT 22
25263: PUSH
25264: LD_INT 8
25266: PUSH
25267: EMPTY
25268: LIST
25269: LIST
25270: PUSH
25271: LD_INT 25
25273: PUSH
25274: LD_INT 2
25276: PUSH
25277: EMPTY
25278: LIST
25279: LIST
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: PPUSH
25285: CALL_OW 69
25289: PUSH
25290: FOR_IN
25291: IFFALSE 25346
// begin SetTag ( i , 1 ) ;
25293: LD_VAR 0 1
25297: PPUSH
25298: LD_INT 1
25300: PPUSH
25301: CALL_OW 109
// ComExitBuilding ( i ) ;
25305: LD_VAR 0 1
25309: PPUSH
25310: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25314: LD_VAR 0 1
25318: PPUSH
25319: LD_INT 35
25321: PPUSH
25322: LD_INT 6
25324: PPUSH
25325: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25329: LD_VAR 0 1
25333: PPUSH
25334: LD_INT 53
25336: PPUSH
25337: LD_INT 4
25339: PPUSH
25340: CALL_OW 171
// end ;
25344: GO 25290
25346: POP
25347: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25348: LD_ADDR_VAR 0 3
25352: PUSH
25353: LD_INT 22
25355: PUSH
25356: LD_INT 4
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: LD_INT 21
25365: PUSH
25366: LD_INT 2
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 3
25375: PUSH
25376: LD_INT 34
25378: PUSH
25379: LD_INT 12
25381: PUSH
25382: EMPTY
25383: LIST
25384: LIST
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: PUSH
25390: EMPTY
25391: LIST
25392: LIST
25393: LIST
25394: PPUSH
25395: CALL_OW 69
25399: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25400: LD_EXP 60
25404: PPUSH
25405: LD_VAR 0 3
25409: PPUSH
25410: LD_EXP 60
25414: PPUSH
25415: CALL_OW 74
25419: PPUSH
25420: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25424: LD_EXP 60
25428: PPUSH
25429: LD_INT 100
25431: PPUSH
25432: LD_INT 88
25434: PPUSH
25435: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25439: LD_EXP 60
25443: PPUSH
25444: LD_INT 100
25446: PPUSH
25447: LD_INT 75
25449: PPUSH
25450: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25454: LD_EXP 60
25458: PPUSH
25459: LD_INT 88
25461: PPUSH
25462: LD_INT 53
25464: PPUSH
25465: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25469: LD_INT 8
25471: PPUSH
25472: LD_EXP 60
25476: PPUSH
25477: CALL_OW 471
// repeat wait ( 3 ) ;
25481: LD_INT 3
25483: PPUSH
25484: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25488: LD_INT 22
25490: PUSH
25491: LD_INT 4
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 92
25500: PUSH
25501: LD_INT 100
25503: PUSH
25504: LD_INT 75
25506: PUSH
25507: LD_INT 6
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PPUSH
25520: CALL_OW 69
25524: IFFALSE 25481
// async ;
25526: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25527: LD_EXP 60
25531: PPUSH
25532: LD_STRING D6b-Pow-1
25534: PPUSH
25535: CALL_OW 88
// repeat wait ( 3 ) ;
25539: LD_INT 3
25541: PPUSH
25542: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25546: LD_EXP 60
25550: PPUSH
25551: CALL_OW 310
25555: PPUSH
25556: CALL_OW 256
25560: PUSH
25561: LD_INT 1000
25563: LESS
25564: IFFALSE 25583
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25566: LD_EXP 60
25570: PPUSH
25571: CALL_OW 310
25575: PPUSH
25576: LD_INT 1000
25578: PPUSH
25579: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25583: LD_EXP 60
25587: PPUSH
25588: CALL_OW 256
25592: PUSH
25593: LD_INT 1000
25595: LESS
25596: IFFALSE 25610
// SetLives ( Powell , 1000 ) ;
25598: LD_EXP 60
25602: PPUSH
25603: LD_INT 1000
25605: PPUSH
25606: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25610: LD_EXP 60
25614: PPUSH
25615: LD_EXP 66
25619: PPUSH
25620: CALL_OW 296
25624: PUSH
25625: LD_INT 5
25627: LESS
25628: PUSH
25629: LD_EXP 60
25633: PPUSH
25634: CALL_OW 310
25638: PPUSH
25639: LD_EXP 66
25643: PPUSH
25644: CALL_OW 296
25648: PUSH
25649: LD_INT 5
25651: LESS
25652: OR
25653: IFFALSE 25672
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25655: LD_EXP 60
25659: PPUSH
25660: CALL_OW 310
25664: PPUSH
25665: LD_INT 100
25667: PPUSH
25668: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25672: LD_EXP 60
25676: PPUSH
25677: CALL_OW 310
25681: NOT
25682: IFFALSE 25539
// DoNotAttack ( 8 , powellBomb ) ;
25684: LD_INT 8
25686: PPUSH
25687: LD_EXP 66
25691: PPUSH
25692: CALL_OW 471
// game_speed := 4 ;
25696: LD_ADDR_OWVAR 65
25700: PUSH
25701: LD_INT 4
25703: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
25704: LD_EXP 60
25708: PPUSH
25709: LD_STRING D6b-Pow-1a
25711: PPUSH
25712: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
25716: LD_EXP 60
25720: PPUSH
25721: LD_EXP 66
25725: PPUSH
25726: CALL_OW 180
// sync ;
25730: SYNC
// repeat wait ( 0 0$1 ) ;
25731: LD_INT 35
25733: PPUSH
25734: CALL_OW 67
// until IsInUnit ( Powell ) ;
25738: LD_EXP 60
25742: PPUSH
25743: CALL_OW 310
25747: IFFALSE 25731
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
25749: LD_INT 8
25751: PPUSH
25752: LD_EXP 60
25756: PPUSH
25757: CALL_OW 310
25761: PPUSH
25762: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
25766: LD_EXP 60
25770: PPUSH
25771: LD_INT 91
25773: PPUSH
25774: LD_INT 44
25776: PPUSH
25777: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25781: LD_EXP 60
25785: PPUSH
25786: LD_INT 96
25788: PPUSH
25789: LD_INT 44
25791: PPUSH
25792: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25796: LD_EXP 60
25800: PPUSH
25801: LD_INT 96
25803: PPUSH
25804: LD_INT 41
25806: PPUSH
25807: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25811: LD_EXP 60
25815: PPUSH
25816: LD_INT 92
25818: PPUSH
25819: LD_INT 39
25821: PPUSH
25822: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25826: LD_EXP 60
25830: PPUSH
25831: LD_INT 88
25833: PPUSH
25834: LD_INT 41
25836: PPUSH
25837: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25841: LD_EXP 60
25845: PPUSH
25846: LD_INT 91
25848: PPUSH
25849: LD_INT 44
25851: PPUSH
25852: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25856: LD_EXP 60
25860: PPUSH
25861: LD_INT 96
25863: PPUSH
25864: LD_INT 44
25866: PPUSH
25867: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25871: LD_EXP 60
25875: PPUSH
25876: LD_INT 96
25878: PPUSH
25879: LD_INT 41
25881: PPUSH
25882: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25886: LD_EXP 60
25890: PPUSH
25891: LD_INT 92
25893: PPUSH
25894: LD_INT 39
25896: PPUSH
25897: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25901: LD_EXP 60
25905: PPUSH
25906: LD_INT 88
25908: PPUSH
25909: LD_INT 41
25911: PPUSH
25912: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25916: LD_EXP 60
25920: PPUSH
25921: LD_INT 91
25923: PPUSH
25924: LD_INT 44
25926: PPUSH
25927: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
25931: LD_EXP 60
25935: PPUSH
25936: LD_INT 93
25938: PPUSH
25939: LD_INT 39
25941: PPUSH
25942: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
25946: LD_EXP 60
25950: PPUSH
25951: LD_INT 93
25953: PPUSH
25954: LD_INT 36
25956: PPUSH
25957: CALL_OW 171
// wait ( 0 0$3.5 ) ;
25961: LD_INT 122
25963: PPUSH
25964: CALL_OW 67
// game_speed := 4 ;
25968: LD_ADDR_OWVAR 65
25972: PUSH
25973: LD_INT 4
25975: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
25976: LD_EXP 60
25980: PPUSH
25981: LD_STRING D6b-Pow-1b
25983: PPUSH
25984: CALL_OW 88
// tmp := [ ] ;
25988: LD_ADDR_VAR 0 3
25992: PUSH
25993: EMPTY
25994: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
25995: LD_ADDR_VAR 0 5
25999: PUSH
26000: LD_INT 78
26002: PUSH
26003: LD_INT 47
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: LD_INT 106
26012: PUSH
26013: LD_INT 53
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26024: LD_ADDR_VAR 0 1
26028: PUSH
26029: LD_INT 22
26031: PUSH
26032: LD_INT 8
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 21
26041: PUSH
26042: LD_INT 3
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: LD_INT 92
26051: PUSH
26052: LD_INT 90
26054: PUSH
26055: LD_INT 52
26057: PUSH
26058: LD_INT 12
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: LIST
26071: PPUSH
26072: CALL_OW 69
26076: PUSH
26077: FOR_IN
26078: IFFALSE 26103
// tmp := tmp ^ UnitsInside ( i ) ;
26080: LD_ADDR_VAR 0 3
26084: PUSH
26085: LD_VAR 0 3
26089: PUSH
26090: LD_VAR 0 1
26094: PPUSH
26095: CALL_OW 313
26099: ADD
26100: ST_TO_ADDR
26101: GO 26077
26103: POP
26104: POP
// for i in tmp do
26105: LD_ADDR_VAR 0 1
26109: PUSH
26110: LD_VAR 0 3
26114: PUSH
26115: FOR_IN
26116: IFFALSE 26278
// begin dist := 9999 ;
26118: LD_ADDR_VAR 0 8
26122: PUSH
26123: LD_INT 9999
26125: ST_TO_ADDR
// _xy := [ ] ;
26126: LD_ADDR_VAR 0 7
26130: PUSH
26131: EMPTY
26132: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26133: LD_VAR 0 1
26137: PPUSH
26138: LD_INT 1
26140: PPUSH
26141: CALL_OW 109
// ComExitBuilding ( i ) ;
26145: LD_VAR 0 1
26149: PPUSH
26150: CALL_OW 122
// for j in xy do
26154: LD_ADDR_VAR 0 2
26158: PUSH
26159: LD_VAR 0 5
26163: PUSH
26164: FOR_IN
26165: IFFALSE 26247
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26167: LD_VAR 0 1
26171: PPUSH
26172: LD_VAR 0 2
26176: PUSH
26177: LD_INT 1
26179: ARRAY
26180: PPUSH
26181: LD_VAR 0 2
26185: PUSH
26186: LD_INT 2
26188: ARRAY
26189: PPUSH
26190: CALL_OW 297
26194: PUSH
26195: LD_VAR 0 8
26199: LESS
26200: IFFALSE 26245
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26202: LD_ADDR_VAR 0 8
26206: PUSH
26207: LD_VAR 0 1
26211: PPUSH
26212: LD_VAR 0 2
26216: PUSH
26217: LD_INT 1
26219: ARRAY
26220: PPUSH
26221: LD_VAR 0 2
26225: PUSH
26226: LD_INT 2
26228: ARRAY
26229: PPUSH
26230: CALL_OW 297
26234: ST_TO_ADDR
// _xy := j ;
26235: LD_ADDR_VAR 0 7
26239: PUSH
26240: LD_VAR 0 2
26244: ST_TO_ADDR
// end ;
26245: GO 26164
26247: POP
26248: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26249: LD_VAR 0 1
26253: PPUSH
26254: LD_VAR 0 7
26258: PUSH
26259: LD_INT 1
26261: ARRAY
26262: PPUSH
26263: LD_VAR 0 7
26267: PUSH
26268: LD_INT 2
26270: ARRAY
26271: PPUSH
26272: CALL_OW 171
// end ;
26276: GO 26115
26278: POP
26279: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26280: LD_ADDR_VAR 0 4
26284: PUSH
26285: LD_VAR 0 3
26289: PPUSH
26290: LD_INT 26
26292: PUSH
26293: LD_INT 1
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 25
26302: PUSH
26303: LD_INT 1
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PPUSH
26314: CALL_OW 72
26318: ST_TO_ADDR
// if tmp2 < 2 then
26319: LD_VAR 0 4
26323: PUSH
26324: LD_INT 2
26326: LESS
26327: IFFALSE 26396
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26329: LD_ADDR_VAR 0 4
26333: PUSH
26334: LD_INT 22
26336: PUSH
26337: LD_INT 8
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 26
26346: PUSH
26347: LD_INT 1
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 3
26356: PUSH
26357: LD_INT 25
26359: PUSH
26360: LD_INT 15
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: LIST
26375: PPUSH
26376: CALL_OW 69
26380: PUSH
26381: LD_EXP 63
26385: PUSH
26386: LD_EXP 64
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: DIFF
26395: ST_TO_ADDR
// if tmp2 then
26396: LD_VAR 0 4
26400: IFFALSE 26418
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26402: LD_VAR 0 4
26406: PUSH
26407: LD_INT 1
26409: ARRAY
26410: PPUSH
26411: LD_STRING D6b-ArSol1-1
26413: PPUSH
26414: CALL_OW 88
// async ;
26418: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26419: LD_EXP 60
26423: PPUSH
26424: LD_STRING D6b-Pow-2
26426: PPUSH
26427: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26431: LD_INT 18
26433: PPUSH
26434: CALL_OW 67
// if tmp2 > 1 then
26438: LD_VAR 0 4
26442: PUSH
26443: LD_INT 1
26445: GREATER
26446: IFFALSE 26464
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26448: LD_VAR 0 4
26452: PUSH
26453: LD_INT 2
26455: ARRAY
26456: PPUSH
26457: LD_STRING D6b-ArSol2-1
26459: PPUSH
26460: CALL_OW 88
// sync ;
26464: SYNC
// repeat wait ( 5 ) ;
26465: LD_INT 5
26467: PPUSH
26468: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26472: LD_INT 93
26474: PPUSH
26475: LD_INT 36
26477: PPUSH
26478: CALL_OW 428
26482: PPUSH
26483: CALL_OW 255
26487: PUSH
26488: LD_INT 4
26490: EQUAL
26491: IFFALSE 26465
// DialogueOn ;
26493: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26497: LD_INT 10
26499: PPUSH
26500: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26504: LD_EXP 60
26508: PPUSH
26509: LD_STRING D6b-Pow-2a
26511: PPUSH
26512: CALL_OW 88
// DialogueOff ;
26516: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26520: LD_EXP 60
26524: PPUSH
26525: CALL_OW 310
26529: PPUSH
26530: LD_INT 332
26532: PPUSH
26533: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26537: LD_INT 93
26539: PPUSH
26540: LD_INT 35
26542: PPUSH
26543: LD_INT 1
26545: PPUSH
26546: LD_INT 6
26548: NEG
26549: PPUSH
26550: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26554: LD_INT 35
26556: PPUSH
26557: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26561: LD_INT 332
26563: PPUSH
26564: CALL_OW 256
26568: PUSH
26569: LD_INT 1000
26571: LESS
26572: PUSH
26573: LD_INT 332
26575: PPUSH
26576: CALL_OW 300
26580: AND
26581: IFFALSE 26593
// SetLives ( kozlov_fac , 0 ) ;
26583: LD_INT 332
26585: PPUSH
26586: LD_INT 0
26588: PPUSH
26589: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26593: LD_INT 332
26595: PPUSH
26596: CALL_OW 301
26600: PUSH
26601: LD_EXP 60
26605: PPUSH
26606: CALL_OW 301
26610: OR
26611: IFFALSE 26554
// game_speed := 4 ;
26613: LD_ADDR_OWVAR 65
26617: PUSH
26618: LD_INT 4
26620: ST_TO_ADDR
// powellCenterCameraMode := false ;
26621: LD_ADDR_EXP 20
26625: PUSH
26626: LD_INT 0
26628: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26629: LD_ADDR_VAR 0 1
26633: PUSH
26634: LD_VAR 0 3
26638: PUSH
26639: LD_INT 22
26641: PUSH
26642: LD_INT 8
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 25
26651: PUSH
26652: LD_INT 2
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: PPUSH
26663: CALL_OW 69
26667: UNION
26668: PUSH
26669: FOR_IN
26670: IFFALSE 26686
// SetTag ( i , 0 ) ;
26672: LD_VAR 0 1
26676: PPUSH
26677: LD_INT 0
26679: PPUSH
26680: CALL_OW 109
26684: GO 26669
26686: POP
26687: POP
// wait ( 0 0$3 ) ;
26688: LD_INT 105
26690: PPUSH
26691: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26695: LD_INT 93
26697: PPUSH
26698: LD_INT 35
26700: PPUSH
26701: LD_INT 1
26703: PPUSH
26704: CALL_OW 331
// DialogueOn ;
26708: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
26712: LD_VAR 0 11
26716: PPUSH
26717: LD_STRING D6c-Sol3-1
26719: PPUSH
26720: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
26724: LD_INT 10
26726: PPUSH
26727: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
26731: LD_EXP 40
26735: PPUSH
26736: LD_STRING D6c-JMM-1
26738: PPUSH
26739: CALL_OW 88
// if Cyrus then
26743: LD_EXP 46
26747: IFFALSE 26761
// Say ( Cyrus , D6c-Cyrus-1 ) ;
26749: LD_EXP 46
26753: PPUSH
26754: LD_STRING D6c-Cyrus-1
26756: PPUSH
26757: CALL_OW 88
// if Bobby then
26761: LD_EXP 45
26765: IFFALSE 26779
// Say ( Bobby , D6c-Bobby-1 ) ;
26767: LD_EXP 45
26771: PPUSH
26772: LD_STRING D6c-Bobby-1
26774: PPUSH
26775: CALL_OW 88
// if Cornel then
26779: LD_EXP 51
26783: IFFALSE 26797
// Say ( Cornel , D6c-Corn-1 ) ;
26785: LD_EXP 51
26789: PPUSH
26790: LD_STRING D6c-Corn-1
26792: PPUSH
26793: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
26797: LD_ADDR_VAR 0 4
26801: PUSH
26802: LD_INT 2
26804: PUSH
26805: LD_INT 22
26807: PUSH
26808: LD_INT 1
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: PUSH
26815: LD_INT 22
26817: PUSH
26818: LD_INT 4
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: LIST
26829: PUSH
26830: LD_INT 26
26832: PUSH
26833: LD_INT 1
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 23
26842: PUSH
26843: LD_INT 1
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: LIST
26854: PPUSH
26855: CALL_OW 69
26859: PUSH
26860: LD_VAR 0 11
26864: PUSH
26865: LD_EXP 40
26869: UNION
26870: PUSH
26871: LD_EXP 61
26875: UNION
26876: DIFF
26877: ST_TO_ADDR
// if tmp2 then
26878: LD_VAR 0 4
26882: IFFALSE 26900
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
26884: LD_VAR 0 4
26888: PUSH
26889: LD_INT 1
26891: ARRAY
26892: PPUSH
26893: LD_STRING D6c-Sol1-1
26895: PPUSH
26896: CALL_OW 88
// if Lisa then
26900: LD_EXP 43
26904: IFFALSE 26918
// Say ( Lisa , D6c-Lisa-1 ) ;
26906: LD_EXP 43
26910: PPUSH
26911: LD_STRING D6c-Lisa-1
26913: PPUSH
26914: CALL_OW 88
// if Gary then
26918: LD_EXP 52
26922: IFFALSE 26936
// Say ( Gary , D6c-Gary-1 ) ;
26924: LD_EXP 52
26928: PPUSH
26929: LD_STRING D6c-Gary-1
26931: PPUSH
26932: CALL_OW 88
// if Donaldson then
26936: LD_EXP 44
26940: IFFALSE 26954
// Say ( Donaldson , D6c-Don-1 ) ;
26942: LD_EXP 44
26946: PPUSH
26947: LD_STRING D6c-Don-1
26949: PPUSH
26950: CALL_OW 88
// if tmp2 > 1 then
26954: LD_VAR 0 4
26958: PUSH
26959: LD_INT 1
26961: GREATER
26962: IFFALSE 26980
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
26964: LD_VAR 0 4
26968: PUSH
26969: LD_INT 2
26971: ARRAY
26972: PPUSH
26973: LD_STRING D6c-Sol2-1
26975: PPUSH
26976: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
26980: LD_VAR 0 11
26984: PPUSH
26985: LD_STRING D6c-Sol3-2
26987: PPUSH
26988: CALL_OW 88
// if IsInUnit ( JMM ) then
26992: LD_EXP 40
26996: PPUSH
26997: CALL_OW 310
27001: IFFALSE 27019
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27003: LD_EXP 40
27007: PPUSH
27008: CALL_OW 310
27012: PPUSH
27013: CALL_OW 87
27017: GO 27028
// CenterNowOnUnits ( JMM ) ;
27019: LD_EXP 40
27023: PPUSH
27024: CALL_OW 87
// dwait ( 0 0$2 ) ;
27028: LD_INT 70
27030: PPUSH
27031: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27035: LD_EXP 40
27039: PPUSH
27040: LD_STRING D6c-JMM-2
27042: PPUSH
27043: CALL_OW 88
// DialogueOff ;
27047: CALL_OW 7
// Video ( false ) ;
27051: LD_INT 0
27053: PPUSH
27054: CALL 106732 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27058: LD_INT 22
27060: PUSH
27061: LD_INT 4
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PPUSH
27068: CALL_OW 69
27072: PPUSH
27073: LD_INT 1
27075: PPUSH
27076: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27080: LD_INT 4
27082: PPUSH
27083: LD_INT 4
27085: PPUSH
27086: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27090: LD_ADDR_VAR 0 1
27094: PUSH
27095: LD_INT 4
27097: PPUSH
27098: LD_INT 1
27100: PPUSH
27101: LD_INT 2
27103: PPUSH
27104: CALL 69121 0 3
27108: PUSH
27109: FOR_IN
27110: IFFALSE 27147
// if GetTech ( i , 1 ) <> state_researched then
27112: LD_VAR 0 1
27116: PPUSH
27117: LD_INT 1
27119: PPUSH
27120: CALL_OW 321
27124: PUSH
27125: LD_INT 2
27127: NONEQUAL
27128: IFFALSE 27145
// SetTech ( i , 1 , state_researched ) ;
27130: LD_VAR 0 1
27134: PPUSH
27135: LD_INT 1
27137: PPUSH
27138: LD_INT 2
27140: PPUSH
27141: CALL_OW 322
27145: GO 27109
27147: POP
27148: POP
// missionStage := 6 ;
27149: LD_ADDR_EXP 15
27153: PUSH
27154: LD_INT 6
27156: ST_TO_ADDR
// activeAttacks := true ;
27157: LD_ADDR_EXP 16
27161: PUSH
27162: LD_INT 1
27164: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27165: LD_STRING M2
27167: PPUSH
27168: CALL_OW 337
// SaveForQuickRestart ;
27172: CALL_OW 22
// wait ( 0 0$40 ) ;
27176: LD_INT 1400
27178: PPUSH
27179: CALL_OW 67
// DialogueOn ;
27183: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27187: LD_EXP 65
27191: PPUSH
27192: LD_STRING D7-Friend-1
27194: PPUSH
27195: CALL 110679 0 2
// Say ( JMM , D7-JMM-1 ) ;
27199: LD_EXP 40
27203: PPUSH
27204: LD_STRING D7-JMM-1
27206: PPUSH
27207: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27211: LD_EXP 65
27215: PPUSH
27216: LD_STRING D7-Friend-2
27218: PPUSH
27219: CALL 110679 0 2
// Say ( JMM , D7-JMM-2 ) ;
27223: LD_EXP 40
27227: PPUSH
27228: LD_STRING D7-JMM-2
27230: PPUSH
27231: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27235: LD_EXP 65
27239: PPUSH
27240: LD_STRING D7-Friend-3
27242: PPUSH
27243: CALL 110679 0 2
// Say ( JMM , D7-JMM-3 ) ;
27247: LD_EXP 40
27251: PPUSH
27252: LD_STRING D7-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27259: LD_EXP 65
27263: PPUSH
27264: LD_STRING D7-Friend-4
27266: PPUSH
27267: CALL 110679 0 2
// Say ( JMM , D7-JMM-4 ) ;
27271: LD_EXP 40
27275: PPUSH
27276: LD_STRING D7-JMM-4
27278: PPUSH
27279: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27283: LD_EXP 65
27287: PPUSH
27288: LD_STRING D7-Friend-5
27290: PPUSH
27291: CALL 110679 0 2
// Say ( JMM , D7-JMM-5 ) ;
27295: LD_EXP 40
27299: PPUSH
27300: LD_STRING D7-JMM-5
27302: PPUSH
27303: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27307: LD_EXP 65
27311: PPUSH
27312: LD_STRING D7-Friend-6
27314: PPUSH
27315: CALL 110679 0 2
// Say ( JMM , D7-JMM-6 ) ;
27319: LD_EXP 40
27323: PPUSH
27324: LD_STRING D7-JMM-6
27326: PPUSH
27327: CALL_OW 88
// DialogueOff ;
27331: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27335: LD_STRING Mlegion
27337: PPUSH
27338: CALL_OW 337
// skirmish := true ;
27342: LD_ADDR_EXP 99
27346: PUSH
27347: LD_INT 1
27349: ST_TO_ADDR
// RebuildKozlovFactory ;
27350: CALL 5172 0 0
// end ;
27354: PPOPN 13
27356: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27357: LD_EXP 20
27361: PUSH
27362: LD_EXP 60
27366: PPUSH
27367: CALL_OW 300
27371: AND
27372: IFFALSE 27414
27374: GO 27376
27376: DISABLE
// begin enable ;
27377: ENABLE
// if IsInUnit ( Powell ) then
27378: LD_EXP 60
27382: PPUSH
27383: CALL_OW 310
27387: IFFALSE 27405
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27389: LD_EXP 60
27393: PPUSH
27394: CALL_OW 310
27398: PPUSH
27399: CALL_OW 85
27403: GO 27414
// CenterOnUnits ( Powell ) ;
27405: LD_EXP 60
27409: PPUSH
27410: CALL_OW 85
// end ;
27414: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27415: LD_INT 22
27417: PUSH
27418: LD_INT 8
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 34
27427: PUSH
27428: LD_INT 48
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PPUSH
27439: CALL_OW 69
27443: IFFALSE 27717
27445: GO 27447
27447: DISABLE
27448: LD_INT 0
27450: PPUSH
27451: PPUSH
// begin if missionStage < 9 then
27452: LD_EXP 15
27456: PUSH
27457: LD_INT 9
27459: LESS
27460: IFFALSE 27470
// missionStage := 9 ;
27462: LD_ADDR_EXP 15
27466: PUSH
27467: LD_INT 9
27469: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27470: LD_ADDR_VAR 0 1
27474: PUSH
27475: LD_INT 22
27477: PUSH
27478: LD_INT 8
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 34
27487: PUSH
27488: LD_INT 48
27490: PUSH
27491: EMPTY
27492: LIST
27493: LIST
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PPUSH
27499: CALL_OW 69
27503: PUSH
27504: LD_INT 1
27506: ARRAY
27507: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27508: LD_INT 175
27510: PPUSH
27511: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27515: LD_EXP 12
27519: PUSH
27520: LD_EXP 3
27524: PUSH
27525: LD_INT 0
27527: PUSH
27528: LD_INT 2
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: IN
27535: OR
27536: IFFALSE 27559
// target := [ 68 , 108 , 1 ] else
27538: LD_ADDR_VAR 0 2
27542: PUSH
27543: LD_INT 68
27545: PUSH
27546: LD_INT 108
27548: PUSH
27549: LD_INT 1
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: LIST
27556: ST_TO_ADDR
27557: GO 27578
// target := [ 181 , 88 , 2 ] ;
27559: LD_ADDR_VAR 0 2
27563: PUSH
27564: LD_INT 181
27566: PUSH
27567: LD_INT 88
27569: PUSH
27570: LD_INT 2
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27578: LD_VAR 0 1
27582: PPUSH
27583: LD_VAR 0 2
27587: PUSH
27588: LD_INT 1
27590: ARRAY
27591: PPUSH
27592: LD_VAR 0 2
27596: PUSH
27597: LD_INT 2
27599: ARRAY
27600: PPUSH
27601: CALL_OW 176
// if target [ 3 ] = 1 then
27605: LD_VAR 0 2
27609: PUSH
27610: LD_INT 3
27612: ARRAY
27613: PUSH
27614: LD_INT 1
27616: EQUAL
27617: IFFALSE 27633
// SayRadio ( Kurt , D12-Kurt-1 ) else
27619: LD_EXP 63
27623: PPUSH
27624: LD_STRING D12-Kurt-1
27626: PPUSH
27627: CALL_OW 94
27631: GO 27657
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27633: LD_EXP 63
27637: PPUSH
27638: LD_STRING D12a-Kurt-1
27640: PPUSH
27641: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27645: LD_EXP 78
27649: PPUSH
27650: LD_STRING D12a-Roth-1
27652: PPUSH
27653: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27657: LD_INT 350
27659: PPUSH
27660: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27664: LD_VAR 0 1
27668: PPUSH
27669: LD_INT 22
27671: PUSH
27672: LD_INT 8
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 23
27681: PUSH
27682: LD_INT 2
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: LD_INT 30
27691: PUSH
27692: LD_INT 3
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: LIST
27703: PPUSH
27704: CALL_OW 69
27708: PUSH
27709: LD_INT 1
27711: ARRAY
27712: PPUSH
27713: CALL_OW 228
// end ;
27717: PPOPN 2
27719: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
27720: LD_EXP 63
27724: PPUSH
27725: CALL_OW 256
27729: PUSH
27730: LD_INT 999
27732: LESS
27733: PUSH
27734: LD_INT 22
27736: PUSH
27737: LD_INT 8
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 21
27746: PUSH
27747: LD_INT 1
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 23
27756: PUSH
27757: LD_INT 2
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: LIST
27768: PPUSH
27769: CALL_OW 69
27773: PUSH
27774: LD_INT 9
27776: PUSH
27777: LD_INT 8
27779: PUSH
27780: LD_INT 7
27782: PUSH
27783: LD_INT 6
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: LIST
27790: LIST
27791: PUSH
27792: LD_OWVAR 67
27796: ARRAY
27797: LESSEQUAL
27798: OR
27799: PUSH
27800: LD_INT 22
27802: PUSH
27803: LD_INT 8
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 34
27812: PUSH
27813: LD_INT 48
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PPUSH
27824: CALL_OW 69
27828: NOT
27829: AND
27830: PUSH
27831: LD_EXP 63
27835: PPUSH
27836: CALL_OW 302
27840: AND
27841: PUSH
27842: LD_INT 5
27844: PPUSH
27845: LD_INT 22
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PPUSH
27855: CALL_OW 70
27859: AND
27860: IFFALSE 28622
27862: GO 27864
27864: DISABLE
27865: LD_INT 0
27867: PPUSH
27868: PPUSH
27869: PPUSH
// begin legionDestroyed := true ;
27870: LD_ADDR_EXP 22
27874: PUSH
27875: LD_INT 1
27877: ST_TO_ADDR
// DialogueOn ;
27878: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
27882: LD_EXP 40
27886: PPUSH
27887: LD_STRING D13-JMM-1
27889: PPUSH
27890: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
27894: LD_EXP 63
27898: PPUSH
27899: LD_STRING D13-Kurt-1
27901: PPUSH
27902: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
27906: LD_EXP 40
27910: PPUSH
27911: LD_STRING D13-JMM-2
27913: PPUSH
27914: CALL_OW 88
// if FakeInfo then
27918: LD_EXP 12
27922: IFFALSE 27942
// begin Say ( Kurt , D13-Kurt-2 ) ;
27924: LD_EXP 63
27928: PPUSH
27929: LD_STRING D13-Kurt-2
27931: PPUSH
27932: CALL_OW 88
// DialogueOff ;
27936: CALL_OW 7
// exit ;
27940: GO 28622
// end ; if not KurtStatus then
27942: LD_EXP 3
27946: NOT
27947: IFFALSE 27963
// Say ( Kurt , D13-Kurt-2b ) else
27949: LD_EXP 63
27953: PPUSH
27954: LD_STRING D13-Kurt-2b
27956: PPUSH
27957: CALL_OW 88
27961: GO 27975
// Say ( Kurt , D13-Kurt-2a ) ;
27963: LD_EXP 63
27967: PPUSH
27968: LD_STRING D13-Kurt-2a
27970: PPUSH
27971: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
27975: LD_EXP 40
27979: PPUSH
27980: LD_STRING D13-JMM-3
27982: PPUSH
27983: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
27987: LD_EXP 63
27991: PPUSH
27992: LD_STRING D13-Kurt-3
27994: PPUSH
27995: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
27999: LD_EXP 40
28003: PPUSH
28004: LD_STRING D13-JMM-4
28006: PPUSH
28007: CALL_OW 88
// DialogueOff ;
28011: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28015: LD_STRING MlegionOut
28017: PPUSH
28018: CALL_OW 337
// MC_Kill ( 3 ) ;
28022: LD_INT 3
28024: PPUSH
28025: CALL 38607 0 1
// KillUnit ( Kozlov ) ;
28029: LD_EXP 64
28033: PPUSH
28034: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28038: LD_ADDR_VAR 0 1
28042: PUSH
28043: LD_INT 22
28045: PUSH
28046: LD_INT 8
28048: PUSH
28049: EMPTY
28050: LIST
28051: LIST
28052: PUSH
28053: LD_INT 23
28055: PUSH
28056: LD_INT 3
28058: PUSH
28059: EMPTY
28060: LIST
28061: LIST
28062: PUSH
28063: LD_INT 3
28065: PUSH
28066: LD_INT 21
28068: PUSH
28069: LD_INT 33
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: LIST
28084: PPUSH
28085: CALL_OW 69
28089: PUSH
28090: FOR_IN
28091: IFFALSE 28104
// KillUnit ( i ) ;
28093: LD_VAR 0 1
28097: PPUSH
28098: CALL_OW 66
28102: GO 28090
28104: POP
28105: POP
// ChangeSideFog ( 8 , 1 ) ;
28106: LD_INT 8
28108: PPUSH
28109: LD_INT 1
28111: PPUSH
28112: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28116: LD_ADDR_VAR 0 2
28120: PUSH
28121: LD_INT 22
28123: PUSH
28124: LD_INT 8
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PUSH
28131: LD_INT 21
28133: PUSH
28134: LD_INT 1
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PPUSH
28145: CALL_OW 69
28149: PUSH
28150: LD_EXP 64
28154: PUSH
28155: LD_EXP 63
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: DIFF
28164: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28165: LD_VAR 0 2
28169: PUSH
28170: LD_INT 6
28172: PUSH
28173: LD_INT 5
28175: PUSH
28176: LD_INT 4
28178: PUSH
28179: LD_INT 3
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: LIST
28186: LIST
28187: PUSH
28188: LD_OWVAR 67
28192: ARRAY
28193: GREATEREQUAL
28194: IFFALSE 28346
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28196: LD_ADDR_VAR 0 3
28200: PUSH
28201: LD_INT 6
28203: PUSH
28204: LD_INT 5
28206: PUSH
28207: LD_INT 4
28209: PUSH
28210: LD_INT 3
28212: PUSH
28213: EMPTY
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: PUSH
28219: LD_OWVAR 67
28223: ARRAY
28224: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28225: LD_ADDR_VAR 0 1
28229: PUSH
28230: DOUBLE
28231: LD_VAR 0 2
28235: PUSH
28236: LD_VAR 0 3
28240: PUSH
28241: LD_INT 1
28243: PLUS
28244: MINUS
28245: INC
28246: ST_TO_ADDR
28247: LD_INT 1
28249: PUSH
28250: FOR_DOWNTO
28251: IFFALSE 28342
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28253: LD_ADDR_EXP 38
28257: PUSH
28258: LD_EXP 38
28262: PUSH
28263: LD_VAR 0 2
28267: PUSH
28268: LD_VAR 0 1
28272: ARRAY
28273: ADD
28274: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28275: LD_VAR 0 2
28279: PUSH
28280: LD_VAR 0 1
28284: ARRAY
28285: PPUSH
28286: CALL_OW 310
28290: IFFALSE 28307
// ComExit ( tmp [ i ] ) ;
28292: LD_VAR 0 2
28296: PUSH
28297: LD_VAR 0 1
28301: ARRAY
28302: PPUSH
28303: CALL 107158 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28307: LD_VAR 0 2
28311: PUSH
28312: LD_VAR 0 1
28316: ARRAY
28317: PPUSH
28318: LD_INT 34
28320: PUSH
28321: LD_INT 0
28323: PPUSH
28324: LD_INT 6
28326: PPUSH
28327: CALL_OW 12
28331: PLUS
28332: PPUSH
28333: LD_INT 1
28335: PPUSH
28336: CALL_OW 171
// end ;
28340: GO 28250
28342: POP
28343: POP
// end else
28344: GO 28356
// x := tmp ;
28346: LD_ADDR_VAR 0 3
28350: PUSH
28351: LD_VAR 0 2
28355: ST_TO_ADDR
// for i := tmp downto tmp - x do
28356: LD_ADDR_VAR 0 1
28360: PUSH
28361: DOUBLE
28362: LD_VAR 0 2
28366: INC
28367: ST_TO_ADDR
28368: LD_VAR 0 2
28372: PUSH
28373: LD_VAR 0 3
28377: MINUS
28378: PUSH
28379: FOR_DOWNTO
28380: IFFALSE 28452
// begin if IsInUnit ( tmp [ i ] ) then
28382: LD_VAR 0 2
28386: PUSH
28387: LD_VAR 0 1
28391: ARRAY
28392: PPUSH
28393: CALL_OW 310
28397: IFFALSE 28414
// ComExit ( tmp [ i ] ) ;
28399: LD_VAR 0 2
28403: PUSH
28404: LD_VAR 0 1
28408: ARRAY
28409: PPUSH
28410: CALL 107158 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28414: LD_VAR 0 2
28418: PUSH
28419: LD_VAR 0 1
28423: ARRAY
28424: PPUSH
28425: LD_INT 1
28427: PPUSH
28428: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28432: LD_VAR 0 2
28436: PUSH
28437: LD_VAR 0 1
28441: ARRAY
28442: PPUSH
28443: LD_INT 1000
28445: PPUSH
28446: CALL_OW 234
// end ;
28450: GO 28379
28452: POP
28453: POP
// wait ( 0 0$0.3 ) ;
28454: LD_INT 10
28456: PPUSH
28457: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28461: LD_ADDR_VAR 0 1
28465: PUSH
28466: LD_INT 22
28468: PUSH
28469: LD_INT 8
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: LD_INT 21
28478: PUSH
28479: LD_INT 2
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PPUSH
28490: CALL_OW 69
28494: PUSH
28495: FOR_IN
28496: IFFALSE 28509
// KillUnit ( i ) ;
28498: LD_VAR 0 1
28502: PPUSH
28503: CALL_OW 66
28507: GO 28495
28509: POP
28510: POP
// SetSide ( Kurt , 1 ) ;
28511: LD_EXP 63
28515: PPUSH
28516: LD_INT 1
28518: PPUSH
28519: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28523: LD_INT 22
28525: PUSH
28526: LD_INT 8
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 21
28535: PUSH
28536: LD_INT 3
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PPUSH
28547: CALL_OW 69
28551: PPUSH
28552: LD_INT 1
28554: PPUSH
28555: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28559: LD_INT 8
28561: PPUSH
28562: LD_INT 1
28564: PPUSH
28565: LD_INT 1
28567: PPUSH
28568: LD_INT 1
28570: PPUSH
28571: CALL_OW 80
// wait ( 1 1$20 ) ;
28575: LD_INT 2800
28577: PPUSH
28578: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28582: LD_EXP 65
28586: PPUSH
28587: LD_INT 37
28589: PPUSH
28590: LD_INT 1
28592: PPUSH
28593: LD_INT 0
28595: PPUSH
28596: CALL_OW 48
// wait ( 0 0$1 ) ;
28600: LD_INT 35
28602: PPUSH
28603: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28607: LD_EXP 65
28611: PPUSH
28612: LD_INT 60
28614: PPUSH
28615: LD_INT 95
28617: PPUSH
28618: CALL_OW 111
// end ;
28622: PPOPN 3
28624: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28625: LD_EXP 22
28629: NOT
28630: PUSH
28631: LD_INT 22
28633: PUSH
28634: LD_INT 8
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: LD_INT 21
28643: PUSH
28644: LD_INT 1
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: PPUSH
28655: CALL_OW 69
28659: PUSH
28660: LD_INT 0
28662: EQUAL
28663: AND
28664: IFFALSE 28684
28666: GO 28668
28668: DISABLE
// begin legionDestroyed := true ;
28669: LD_ADDR_EXP 22
28673: PUSH
28674: LD_INT 1
28676: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28677: LD_STRING MlegionOut
28679: PPUSH
28680: CALL_OW 337
// end ;
28684: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28685: LD_EXP 38
28689: IFFALSE 28764
28691: GO 28693
28693: DISABLE
28694: LD_INT 0
28696: PPUSH
// begin enable ;
28697: ENABLE
// for i in legionEscapeUnits do
28698: LD_ADDR_VAR 0 1
28702: PUSH
28703: LD_EXP 38
28707: PUSH
28708: FOR_IN
28709: IFFALSE 28762
// begin if IsInArea ( i , legionEscapeArea ) then
28711: LD_VAR 0 1
28715: PPUSH
28716: LD_INT 31
28718: PPUSH
28719: CALL_OW 308
28723: IFFALSE 28736
// RemoveUnit ( i ) else
28725: LD_VAR 0 1
28729: PPUSH
28730: CALL_OW 64
28734: GO 28760
// if not HasTask ( i ) then
28736: LD_VAR 0 1
28740: PPUSH
28741: CALL_OW 314
28745: NOT
28746: IFFALSE 28760
// ComMoveToArea ( i , legionEscapeArea ) ;
28748: LD_VAR 0 1
28752: PPUSH
28753: LD_INT 31
28755: PPUSH
28756: CALL_OW 113
// end ;
28760: GO 28708
28762: POP
28763: POP
// end ;
28764: PPOPN 1
28766: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
28767: LD_INT 1
28769: PPUSH
28770: LD_EXP 65
28774: PPUSH
28775: CALL_OW 292
28779: IFFALSE 29077
28781: GO 28783
28783: DISABLE
28784: LD_INT 0
28786: PPUSH
// begin wait ( 0 0$2 ) ;
28787: LD_INT 70
28789: PPUSH
28790: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28794: LD_EXP 65
28798: PPUSH
28799: CALL_OW 87
// DialogueOn ;
28803: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
28807: LD_EXP 40
28811: PPUSH
28812: LD_STRING D14-JMM-1
28814: PPUSH
28815: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
28819: LD_EXP 65
28823: PPUSH
28824: LD_STRING D14-Friend-1
28826: PPUSH
28827: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
28831: LD_EXP 40
28835: PPUSH
28836: LD_STRING D14-JMM-2
28838: PPUSH
28839: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
28843: LD_EXP 65
28847: PPUSH
28848: LD_STRING D14-Friend-2
28850: PPUSH
28851: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
28855: LD_EXP 40
28859: PPUSH
28860: LD_STRING D14-JMM-3
28862: PPUSH
28863: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
28867: LD_EXP 65
28871: PPUSH
28872: LD_STRING D14-Friend-3
28874: PPUSH
28875: CALL_OW 88
// DialogueOff ;
28879: CALL_OW 7
// dec := Query ( Q14 ) ;
28883: LD_ADDR_VAR 0 1
28887: PUSH
28888: LD_STRING Q14
28890: PPUSH
28891: CALL_OW 97
28895: ST_TO_ADDR
// if dec = 1 then
28896: LD_VAR 0 1
28900: PUSH
28901: LD_INT 1
28903: EQUAL
28904: IFFALSE 28938
// begin DialogueOn ;
28906: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
28910: LD_EXP 40
28914: PPUSH
28915: LD_STRING D14a-JMM-1
28917: PPUSH
28918: CALL_OW 88
// DialogueOff ;
28922: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28926: LD_EXP 65
28930: PPUSH
28931: LD_INT 1
28933: PPUSH
28934: CALL_OW 235
// end ; if dec = 2 then
28938: LD_VAR 0 1
28942: PUSH
28943: LD_INT 2
28945: EQUAL
28946: IFFALSE 28999
// begin DialogueOn ;
28948: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
28952: LD_EXP 40
28956: PPUSH
28957: LD_STRING D14b-JMM-1
28959: PPUSH
28960: CALL_OW 88
// DialogueOff ;
28964: CALL_OW 7
// wait ( 0 0$1 ) ;
28968: LD_INT 35
28970: PPUSH
28971: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
28975: LD_EXP 65
28979: PPUSH
28980: LD_INT 9
28982: PPUSH
28983: LD_INT 2
28985: PPUSH
28986: CALL_OW 111
// AddComHold ( Friend ) ;
28990: LD_EXP 65
28994: PPUSH
28995: CALL_OW 200
// end ; if dec = 3 then
28999: LD_VAR 0 1
29003: PUSH
29004: LD_INT 3
29006: EQUAL
29007: IFFALSE 29077
// begin DialogueOn ;
29009: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29013: LD_EXP 40
29017: PPUSH
29018: LD_STRING D14c-JMM-1
29020: PPUSH
29021: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29025: LD_EXP 65
29029: PPUSH
29030: LD_STRING D14c-Friend-1
29032: PPUSH
29033: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29037: LD_EXP 40
29041: PPUSH
29042: LD_STRING D14c-JMM-2
29044: PPUSH
29045: CALL_OW 88
// DialogueOff ;
29049: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29053: LD_EXP 65
29057: PPUSH
29058: LD_INT 9
29060: PPUSH
29061: LD_INT 2
29063: PPUSH
29064: CALL_OW 111
// AddComHold ( Friend ) ;
29068: LD_EXP 65
29072: PPUSH
29073: CALL_OW 200
// end ; end ;
29077: PPOPN 1
29079: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29080: LD_INT 9
29082: PPUSH
29083: LD_INT 2
29085: PPUSH
29086: CALL_OW 428
29090: PUSH
29091: LD_EXP 65
29095: EQUAL
29096: PUSH
29097: LD_EXP 65
29101: PPUSH
29102: CALL_OW 255
29106: PUSH
29107: LD_INT 8
29109: EQUAL
29110: AND
29111: IFFALSE 29125
29113: GO 29115
29115: DISABLE
// RemoveUnit ( Friend ) ;
29116: LD_EXP 65
29120: PPUSH
29121: CALL_OW 64
29125: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29126: LD_EXP 14
29130: PUSH
29131: LD_INT 31500
29133: GREATEREQUAL
29134: PUSH
29135: LD_EXP 7
29139: AND
29140: PUSH
29141: LD_EXP 2
29145: AND
29146: IFFALSE 29576
29148: GO 29150
29150: DISABLE
29151: LD_INT 0
29153: PPUSH
29154: PPUSH
29155: PPUSH
// begin missionStage := 7 ;
29156: LD_ADDR_EXP 15
29160: PUSH
29161: LD_INT 7
29163: ST_TO_ADDR
// uc_side = 1 ;
29164: LD_ADDR_OWVAR 20
29168: PUSH
29169: LD_INT 1
29171: ST_TO_ADDR
// uc_nation = 1 ;
29172: LD_ADDR_OWVAR 21
29176: PUSH
29177: LD_INT 1
29179: ST_TO_ADDR
// for i = 1 to 5 do
29180: LD_ADDR_VAR 0 1
29184: PUSH
29185: DOUBLE
29186: LD_INT 1
29188: DEC
29189: ST_TO_ADDR
29190: LD_INT 5
29192: PUSH
29193: FOR_TO
29194: IFFALSE 29290
// begin vc_engine = 3 ;
29196: LD_ADDR_OWVAR 39
29200: PUSH
29201: LD_INT 3
29203: ST_TO_ADDR
// vc_control = 3 ;
29204: LD_ADDR_OWVAR 38
29208: PUSH
29209: LD_INT 3
29211: ST_TO_ADDR
// vc_chassis = 3 ;
29212: LD_ADDR_OWVAR 37
29216: PUSH
29217: LD_INT 3
29219: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29220: LD_ADDR_OWVAR 40
29224: PUSH
29225: LD_INT 5
29227: PUSH
29228: LD_INT 9
29230: PUSH
29231: LD_INT 7
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: PPUSH
29242: LD_INT 3
29244: PPUSH
29245: CALL_OW 12
29249: ARRAY
29250: ST_TO_ADDR
// veh = CreateVehicle ;
29251: LD_ADDR_VAR 0 2
29255: PUSH
29256: CALL_OW 45
29260: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29261: LD_VAR 0 2
29265: PPUSH
29266: LD_INT 1
29268: PPUSH
29269: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29273: LD_VAR 0 2
29277: PPUSH
29278: LD_INT 19
29280: PPUSH
29281: LD_INT 0
29283: PPUSH
29284: CALL_OW 49
// end ;
29288: GO 29193
29290: POP
29291: POP
// vc_engine = 3 ;
29292: LD_ADDR_OWVAR 39
29296: PUSH
29297: LD_INT 3
29299: ST_TO_ADDR
// vc_control = 1 ;
29300: LD_ADDR_OWVAR 38
29304: PUSH
29305: LD_INT 1
29307: ST_TO_ADDR
// vc_chassis = 3 ;
29308: LD_ADDR_OWVAR 37
29312: PUSH
29313: LD_INT 3
29315: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29316: LD_ADDR_OWVAR 40
29320: PUSH
29321: LD_INT 5
29323: PUSH
29324: LD_INT 9
29326: PUSH
29327: LD_INT 7
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 1
29337: PPUSH
29338: LD_INT 3
29340: PPUSH
29341: CALL_OW 12
29345: ARRAY
29346: ST_TO_ADDR
// vehG = CreateVehicle ;
29347: LD_ADDR_VAR 0 3
29351: PUSH
29352: CALL_OW 45
29356: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29357: LD_VAR 0 3
29361: PPUSH
29362: LD_INT 1
29364: PPUSH
29365: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29369: LD_VAR 0 3
29373: PPUSH
29374: LD_INT 19
29376: PPUSH
29377: LD_INT 0
29379: PPUSH
29380: CALL_OW 49
// if JMMGirl = 1 then
29384: LD_EXP 7
29388: PUSH
29389: LD_INT 1
29391: EQUAL
29392: IFFALSE 29448
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29394: LD_ADDR_EXP 41
29398: PUSH
29399: LD_STRING Joan
29401: PPUSH
29402: LD_INT 1
29404: PPUSH
29405: LD_STRING 14_
29407: PPUSH
29408: CALL 69058 0 3
29412: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29413: LD_EXP 41
29417: PPUSH
29418: LD_VAR 0 3
29422: PPUSH
29423: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29427: LD_VAR 0 3
29431: PPUSH
29432: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29436: LD_EXP 41
29440: PPUSH
29441: LD_STRING D10BW-Joan-1
29443: PPUSH
29444: CALL_OW 94
// end ; if JMMGirl = 2 then
29448: LD_EXP 7
29452: PUSH
29453: LD_INT 2
29455: EQUAL
29456: IFFALSE 29512
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29458: LD_ADDR_EXP 43
29462: PUSH
29463: LD_STRING Lisa
29465: PPUSH
29466: LD_INT 1
29468: PPUSH
29469: LD_STRING 14_
29471: PPUSH
29472: CALL 69058 0 3
29476: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29477: LD_EXP 43
29481: PPUSH
29482: LD_VAR 0 3
29486: PPUSH
29487: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29491: LD_VAR 0 3
29495: PPUSH
29496: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29500: LD_EXP 43
29504: PPUSH
29505: LD_STRING D10BW-Lisa-1
29507: PPUSH
29508: CALL_OW 94
// end ; if JMMGirl = 3 then
29512: LD_EXP 7
29516: PUSH
29517: LD_INT 3
29519: EQUAL
29520: IFFALSE 29576
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29522: LD_ADDR_EXP 55
29526: PUSH
29527: LD_STRING Connie
29529: PPUSH
29530: LD_INT 1
29532: PPUSH
29533: LD_STRING 14_
29535: PPUSH
29536: CALL 69058 0 3
29540: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29541: LD_EXP 55
29545: PPUSH
29546: LD_VAR 0 3
29550: PPUSH
29551: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29555: LD_VAR 0 3
29559: PPUSH
29560: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29564: LD_EXP 55
29568: PPUSH
29569: LD_STRING D10BW-Con-1
29571: PPUSH
29572: CALL_OW 94
// end ; end ;
29576: PPOPN 3
29578: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29579: LD_EXP 14
29583: PUSH
29584: LD_INT 94500
29586: GREATEREQUAL
29587: IFFALSE 29999
29589: GO 29591
29591: DISABLE
29592: LD_INT 0
29594: PPUSH
29595: PPUSH
29596: PPUSH
// begin tmp := PrepareStevensSquad ;
29597: LD_ADDR_VAR 0 3
29601: PUSH
29602: CALL 2323 0 0
29606: ST_TO_ADDR
// if not tmp then
29607: LD_VAR 0 3
29611: NOT
29612: IFFALSE 29616
// exit ;
29614: GO 29999
// uc_side := 1 ;
29616: LD_ADDR_OWVAR 20
29620: PUSH
29621: LD_INT 1
29623: ST_TO_ADDR
// uc_nation := 1 ;
29624: LD_ADDR_OWVAR 21
29628: PUSH
29629: LD_INT 1
29631: ST_TO_ADDR
// for i in tmp do
29632: LD_ADDR_VAR 0 1
29636: PUSH
29637: LD_VAR 0 3
29641: PUSH
29642: FOR_IN
29643: IFFALSE 29740
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29645: LD_INT 3
29647: PPUSH
29648: LD_INT 3
29650: PPUSH
29651: LD_INT 1
29653: PPUSH
29654: LD_INT 5
29656: PUSH
29657: LD_INT 9
29659: PUSH
29660: LD_INT 7
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: LIST
29667: PUSH
29668: LD_INT 1
29670: PPUSH
29671: LD_INT 3
29673: PPUSH
29674: CALL_OW 12
29678: ARRAY
29679: PPUSH
29680: LD_INT 40
29682: PPUSH
29683: CALL 73898 0 5
// veh := CreateVehicle ;
29687: LD_ADDR_VAR 0 2
29691: PUSH
29692: CALL_OW 45
29696: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29697: LD_VAR 0 2
29701: PPUSH
29702: LD_INT 1
29704: PPUSH
29705: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29709: LD_VAR 0 2
29713: PPUSH
29714: LD_INT 19
29716: PPUSH
29717: LD_INT 0
29719: PPUSH
29720: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
29724: LD_VAR 0 1
29728: PPUSH
29729: LD_VAR 0 2
29733: PPUSH
29734: CALL_OW 52
// end ;
29738: GO 29642
29740: POP
29741: POP
// missionStage := 8 ;
29742: LD_ADDR_EXP 15
29746: PUSH
29747: LD_INT 8
29749: ST_TO_ADDR
// DialogueOn ;
29750: CALL_OW 6
// if Stevens then
29754: LD_EXP 42
29758: IFFALSE 29872
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
29760: LD_EXP 42
29764: PPUSH
29765: CALL_OW 310
29769: PPUSH
29770: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
29774: LD_EXP 42
29778: PPUSH
29779: LD_STRING D8-Huck-1
29781: PPUSH
29782: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
29786: LD_EXP 40
29790: PPUSH
29791: LD_STRING D8-JMM-1
29793: PPUSH
29794: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
29798: LD_EXP 42
29802: PPUSH
29803: LD_STRING D8-Huck-2
29805: PPUSH
29806: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29810: LD_EXP 40
29814: PPUSH
29815: LD_STRING D8-JMM-2
29817: PPUSH
29818: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
29822: LD_EXP 42
29826: PPUSH
29827: LD_STRING D8-Huck-3
29829: PPUSH
29830: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29834: LD_EXP 40
29838: PPUSH
29839: LD_STRING D8-JMM-3
29841: PPUSH
29842: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
29846: LD_EXP 42
29850: PPUSH
29851: LD_STRING D8-Huck-4
29853: PPUSH
29854: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29858: LD_EXP 40
29862: PPUSH
29863: LD_STRING D8-JMM-4
29865: PPUSH
29866: CALL_OW 88
// end else
29870: GO 29982
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
29872: LD_EXP 56
29876: PPUSH
29877: CALL_OW 310
29881: PPUSH
29882: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
29886: LD_EXP 56
29890: PPUSH
29891: LD_STRING D8-Huck-1
29893: PPUSH
29894: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
29898: LD_EXP 40
29902: PPUSH
29903: LD_STRING D8-JMM-1a
29905: PPUSH
29906: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
29910: LD_EXP 56
29914: PPUSH
29915: LD_STRING D8-Huck-2
29917: PPUSH
29918: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29922: LD_EXP 40
29926: PPUSH
29927: LD_STRING D8-JMM-2
29929: PPUSH
29930: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
29934: LD_EXP 56
29938: PPUSH
29939: LD_STRING D8-Huck-3
29941: PPUSH
29942: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29946: LD_EXP 40
29950: PPUSH
29951: LD_STRING D8-JMM-3
29953: PPUSH
29954: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
29958: LD_EXP 56
29962: PPUSH
29963: LD_STRING D8-Huck-4
29965: PPUSH
29966: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29970: LD_EXP 40
29974: PPUSH
29975: LD_STRING D8-JMM-4
29977: PPUSH
29978: CALL_OW 88
// end ; DialogueOff ;
29982: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
29986: LD_INT 25
29988: PPUSH
29989: LD_INT 1
29991: PPUSH
29992: LD_INT 1
29994: PPUSH
29995: CALL_OW 322
// end ;
29999: PPOPN 3
30001: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30002: LD_EXP 74
30006: PPUSH
30007: CALL_OW 302
30011: PUSH
30012: LD_INT 1
30014: PPUSH
30015: LD_EXP 74
30019: PPUSH
30020: CALL_OW 292
30024: AND
30025: IFFALSE 30276
30027: GO 30029
30029: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30030: LD_EXP 74
30034: PPUSH
30035: CALL_OW 87
// DialogueOn ;
30039: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30043: LD_EXP 40
30047: PPUSH
30048: LD_STRING D10nB-JMM-1
30050: PPUSH
30051: CALL_OW 88
// if BurlakStatus = 1 then
30055: LD_EXP 9
30059: PUSH
30060: LD_INT 1
30062: EQUAL
30063: IFFALSE 30077
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30065: LD_EXP 73
30069: PPUSH
30070: LD_STRING D10nB-Vse-1a
30072: PPUSH
30073: CALL_OW 94
// end ; if BurlakStatus = 0 then
30077: LD_EXP 9
30081: PUSH
30082: LD_INT 0
30084: EQUAL
30085: IFFALSE 30099
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30087: LD_EXP 73
30091: PPUSH
30092: LD_STRING D10nB-Vse-1
30094: PPUSH
30095: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30099: LD_EXP 40
30103: PPUSH
30104: LD_STRING D10nB-JMM-2
30106: PPUSH
30107: CALL_OW 88
// if KappaStatus then
30111: LD_EXP 2
30115: IFFALSE 30129
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30117: LD_EXP 73
30121: PPUSH
30122: LD_STRING D10nB-Vse-5a
30124: PPUSH
30125: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30129: LD_EXP 2
30133: NOT
30134: PUSH
30135: LD_EXP 6
30139: PUSH
30140: LD_INT 0
30142: EQUAL
30143: AND
30144: IFFALSE 30272
// begin if JMMGirl = 1 then
30146: LD_EXP 7
30150: PUSH
30151: LD_INT 1
30153: EQUAL
30154: IFFALSE 30204
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30156: LD_EXP 73
30160: PPUSH
30161: LD_STRING D10nB-Vse-2
30163: PPUSH
30164: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30168: LD_EXP 40
30172: PPUSH
30173: LD_STRING D10nB-JMM-3
30175: PPUSH
30176: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30180: LD_EXP 73
30184: PPUSH
30185: LD_STRING D10nB-Vse-3
30187: PPUSH
30188: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30192: LD_EXP 40
30196: PPUSH
30197: LD_STRING D10nB-JMM-4
30199: PPUSH
30200: CALL_OW 88
// end ; if JMMGirl = 2 then
30204: LD_EXP 7
30208: PUSH
30209: LD_INT 2
30211: EQUAL
30212: IFFALSE 30238
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30214: LD_EXP 73
30218: PPUSH
30219: LD_STRING D10nB-Vse-4
30221: PPUSH
30222: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30226: LD_EXP 40
30230: PPUSH
30231: LD_STRING D10nB-JMM-5
30233: PPUSH
30234: CALL_OW 88
// end ; if JMMGirl = 3 then
30238: LD_EXP 7
30242: PUSH
30243: LD_INT 3
30245: EQUAL
30246: IFFALSE 30272
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30248: LD_EXP 73
30252: PPUSH
30253: LD_STRING D10nB-Vse-5
30255: PPUSH
30256: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30260: LD_EXP 40
30264: PPUSH
30265: LD_STRING D10nB-JMM-6
30267: PPUSH
30268: CALL_OW 88
// end ; end ; DialogueOff ;
30272: CALL_OW 7
// end ;
30276: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30277: LD_EXP 14
30281: PUSH
30282: LD_INT 115500
30284: GREATEREQUAL
30285: PUSH
30286: LD_EXP 68
30290: PPUSH
30291: CALL_OW 302
30295: AND
30296: PUSH
30297: LD_INT 267
30299: PPUSH
30300: CALL_OW 302
30304: AND
30305: IFFALSE 30681
30307: GO 30309
30309: DISABLE
30310: LD_INT 0
30312: PPUSH
// begin missionStage := 10 ;
30313: LD_ADDR_EXP 15
30317: PUSH
30318: LD_INT 10
30320: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30321: LD_ADDR_VAR 0 1
30325: PUSH
30326: LD_INT 22
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 23
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 26
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 3
30358: PUSH
30359: LD_INT 25
30361: PUSH
30362: LD_INT 12
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 3
30375: PUSH
30376: LD_INT 25
30378: PUSH
30379: LD_INT 16
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: PPUSH
30397: CALL_OW 69
30401: PUSH
30402: LD_EXP 40
30406: PUSH
30407: LD_EXP 63
30411: PUSH
30412: LD_EXP 42
30416: PUSH
30417: LD_EXP 56
30421: PUSH
30422: LD_EXP 43
30426: PUSH
30427: LD_EXP 44
30431: PUSH
30432: LD_EXP 45
30436: PUSH
30437: LD_EXP 46
30441: PUSH
30442: LD_EXP 47
30446: PUSH
30447: LD_EXP 48
30451: PUSH
30452: LD_EXP 49
30456: PUSH
30457: LD_EXP 50
30461: PUSH
30462: LD_EXP 51
30466: PUSH
30467: LD_EXP 52
30471: PUSH
30472: LD_EXP 53
30476: PUSH
30477: LD_EXP 54
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: DIFF
30500: ST_TO_ADDR
// if not tmp and Brown then
30501: LD_VAR 0 1
30505: NOT
30506: PUSH
30507: LD_EXP 48
30511: AND
30512: IFFALSE 30527
// tmp := [ Brown ] ;
30514: LD_ADDR_VAR 0 1
30518: PUSH
30519: LD_EXP 48
30523: PUSH
30524: EMPTY
30525: LIST
30526: ST_TO_ADDR
// DialogueOn ;
30527: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30531: LD_VAR 0 1
30535: PUSH
30536: LD_INT 1
30538: ARRAY
30539: PPUSH
30540: LD_STRING D11-Sol1-1
30542: PPUSH
30543: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30547: LD_EXP 67
30551: PPUSH
30552: LD_STRING D11-Pla-1
30554: PPUSH
30555: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30559: LD_EXP 68
30563: PPUSH
30564: LD_STRING D11-Kov-1
30566: PPUSH
30567: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30571: LD_EXP 67
30575: PPUSH
30576: LD_STRING D11-Pla-2
30578: PPUSH
30579: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30583: LD_VAR 0 1
30587: PUSH
30588: LD_INT 1
30590: ARRAY
30591: PPUSH
30592: LD_STRING D11-Sol1-2
30594: PPUSH
30595: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30599: LD_EXP 40
30603: PPUSH
30604: LD_STRING D11-JMM-2
30606: PPUSH
30607: CALL_OW 88
// DialogueOff ;
30611: CALL_OW 7
// allowBehemothConstruct := true ;
30615: LD_ADDR_EXP 25
30619: PUSH
30620: LD_INT 1
30622: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30623: LD_STRING M4
30625: PPUSH
30626: CALL_OW 337
// BuildBehemoths ;
30630: CALL 8182 0 0
// repeat wait ( 15 15$00 ) ;
30634: LD_INT 31500
30636: PPUSH
30637: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30641: LD_EXP 27
30645: IFFALSE 30649
// break ;
30647: GO 30681
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30649: LD_INT 267
30651: PPUSH
30652: CALL_OW 274
30656: PPUSH
30657: LD_INT 1
30659: PPUSH
30660: CALL_OW 275
30664: PUSH
30665: LD_INT 1000
30667: GREATEREQUAL
30668: IFFALSE 30674
// BuildBehemoths ;
30670: CALL 8182 0 0
// until not behemothBuilders ;
30674: LD_EXP 76
30678: NOT
30679: IFFALSE 30634
// end ;
30681: PPOPN 1
30683: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30684: LD_EXP 76
30688: NOT
30689: PUSH
30690: LD_EXP 28
30694: NOT
30695: AND
30696: PUSH
30697: LD_EXP 25
30701: AND
30702: IFFALSE 30722
30704: GO 30706
30706: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
30707: LD_STRING M4a
30709: PPUSH
30710: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
30714: LD_ADDR_EXP 27
30718: PUSH
30719: LD_INT 1
30721: ST_TO_ADDR
// end ;
30722: END
// every 0 0$1 trigger behemothDone do
30723: LD_EXP 28
30727: IFFALSE 30739
30729: GO 30731
30731: DISABLE
// ChangeMissionObjectives ( M4b ) ;
30732: LD_STRING M4b
30734: PPUSH
30735: CALL_OW 337
30739: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
30740: LD_EXP 29
30744: NOT
30745: IFFALSE 30941
30747: GO 30749
30749: DISABLE
30750: LD_INT 0
30752: PPUSH
30753: PPUSH
// begin enable ;
30754: ENABLE
// tmp := GetBehemoths ( 3 ) ;
30755: LD_ADDR_VAR 0 1
30759: PUSH
30760: LD_INT 3
30762: PPUSH
30763: CALL 106821 0 1
30767: ST_TO_ADDR
// if not tmp and not behemothDone then
30768: LD_VAR 0 1
30772: NOT
30773: PUSH
30774: LD_EXP 28
30778: NOT
30779: AND
30780: IFFALSE 30816
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
30782: LD_ADDR_VAR 0 1
30786: PUSH
30787: LD_INT 22
30789: PUSH
30790: LD_INT 3
30792: PUSH
30793: EMPTY
30794: LIST
30795: LIST
30796: PUSH
30797: LD_INT 30
30799: PUSH
30800: LD_INT 37
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PPUSH
30811: CALL_OW 69
30815: ST_TO_ADDR
// if not tmp then
30816: LD_VAR 0 1
30820: NOT
30821: IFFALSE 30825
// exit ;
30823: GO 30941
// for i in tmp do
30825: LD_ADDR_VAR 0 2
30829: PUSH
30830: LD_VAR 0 1
30834: PUSH
30835: FOR_IN
30836: IFFALSE 30939
// if See ( 1 , i ) then
30838: LD_INT 1
30840: PPUSH
30841: LD_VAR 0 2
30845: PPUSH
30846: CALL_OW 292
30850: IFFALSE 30937
// begin if GetType ( i ) = unit_building then
30852: LD_VAR 0 2
30856: PPUSH
30857: CALL_OW 247
30861: PUSH
30862: LD_INT 3
30864: EQUAL
30865: IFFALSE 30903
// begin disable ;
30867: DISABLE
// CenterNowOnUnits ( i ) ;
30868: LD_VAR 0 2
30872: PPUSH
30873: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
30877: LD_EXP 40
30881: PPUSH
30882: LD_STRING D17a-JMM-1
30884: PPUSH
30885: CALL_OW 88
// seeBehemoth := true ;
30889: LD_ADDR_EXP 29
30893: PUSH
30894: LD_INT 1
30896: ST_TO_ADDR
// exit ;
30897: POP
30898: POP
30899: GO 30941
// end else
30901: GO 30937
// begin disable ;
30903: DISABLE
// CenterNowOnUnits ( i ) ;
30904: LD_VAR 0 2
30908: PPUSH
30909: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
30913: LD_EXP 40
30917: PPUSH
30918: LD_STRING D17b-JMM-1
30920: PPUSH
30921: CALL_OW 88
// seeBehemoth := true ;
30925: LD_ADDR_EXP 29
30929: PUSH
30930: LD_INT 1
30932: ST_TO_ADDR
// exit ;
30933: POP
30934: POP
30935: GO 30941
// end ; end ;
30937: GO 30835
30939: POP
30940: POP
// end ;
30941: PPOPN 2
30943: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
30944: LD_EXP 14
30948: PUSH
30949: LD_INT 123200
30951: GREATEREQUAL
30952: IFFALSE 32152
30954: GO 30956
30956: DISABLE
30957: LD_INT 0
30959: PPUSH
30960: PPUSH
30961: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
30962: LD_INT 2
30964: PPUSH
30965: LD_INT 23
30967: PUSH
30968: LD_INT 3
30970: PUSH
30971: LD_INT 3
30973: PUSH
30974: LD_INT 48
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: PUSH
30983: EMPTY
30984: LIST
30985: PPUSH
30986: CALL 62632 0 2
// repeat wait ( 0 0$1 ) ;
30990: LD_INT 35
30992: PPUSH
30993: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
30997: LD_INT 22
30999: PUSH
31000: LD_INT 3
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: PUSH
31007: LD_INT 34
31009: PUSH
31010: LD_INT 48
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PPUSH
31021: CALL_OW 69
31025: IFFALSE 30990
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31027: LD_ADDR_VAR 0 1
31031: PUSH
31032: LD_INT 22
31034: PUSH
31035: LD_INT 3
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 34
31044: PUSH
31045: LD_INT 48
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PPUSH
31056: CALL_OW 69
31060: PUSH
31061: LD_INT 1
31063: ARRAY
31064: ST_TO_ADDR
// missionStage := 12 ;
31065: LD_ADDR_EXP 15
31069: PUSH
31070: LD_INT 12
31072: ST_TO_ADDR
// platonovHasBomb := true ;
31073: LD_ADDR_EXP 30
31077: PUSH
31078: LD_INT 1
31080: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31081: LD_VAR 0 1
31085: PPUSH
31086: LD_INT 181
31088: PPUSH
31089: LD_INT 86
31091: PPUSH
31092: CALL_OW 171
// AddComHold ( bomb ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: CALL_OW 200
// wait ( 0 0$10 ) ;
31105: LD_INT 350
31107: PPUSH
31108: CALL_OW 67
// DialogueOn ;
31112: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31116: LD_EXP 67
31120: PPUSH
31121: LD_STRING D15-Pla-1
31123: PPUSH
31124: CALL_OW 94
// dec := Query ( Q15a ) ;
31128: LD_ADDR_VAR 0 2
31132: PUSH
31133: LD_STRING Q15a
31135: PPUSH
31136: CALL_OW 97
31140: ST_TO_ADDR
// if dec = 1 then
31141: LD_VAR 0 2
31145: PUSH
31146: LD_INT 1
31148: EQUAL
31149: IFFALSE 31172
// begin Say ( JMM , D15a-JMM-1 ) ;
31151: LD_EXP 40
31155: PPUSH
31156: LD_STRING D15a-JMM-1
31158: PPUSH
31159: CALL_OW 88
// YouLost ( Surrender ) ;
31163: LD_STRING Surrender
31165: PPUSH
31166: CALL_OW 104
// exit ;
31170: GO 32152
// end ; if dec = 2 then
31172: LD_VAR 0 2
31176: PUSH
31177: LD_INT 2
31179: EQUAL
31180: IFFALSE 31249
// begin Say ( JMM , D15b-JMM-1 ) ;
31182: LD_EXP 40
31186: PPUSH
31187: LD_STRING D15b-JMM-1
31189: PPUSH
31190: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31194: LD_EXP 67
31198: PPUSH
31199: LD_STRING D15b-Pla-1
31201: PPUSH
31202: CALL_OW 94
// DialogueOff ;
31206: CALL_OW 7
// wait ( 3 3$00 ) ;
31210: LD_INT 6300
31212: PPUSH
31213: CALL_OW 67
// DialogueOn ;
31217: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31221: LD_EXP 40
31225: PPUSH
31226: LD_STRING D15d-JMM-1a
31228: PPUSH
31229: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31233: LD_EXP 67
31237: PPUSH
31238: LD_STRING D15d-Pla-1
31240: PPUSH
31241: CALL_OW 94
// DialogueOff ;
31245: CALL_OW 7
// end ; if dec = 3 then
31249: LD_VAR 0 2
31253: PUSH
31254: LD_INT 3
31256: EQUAL
31257: IFFALSE 31311
// begin Say ( JMM , D15c-JMM-1 ) ;
31259: LD_EXP 40
31263: PPUSH
31264: LD_STRING D15c-JMM-1
31266: PPUSH
31267: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31271: LD_EXP 67
31275: PPUSH
31276: LD_STRING D15c-Pla-1
31278: PPUSH
31279: CALL_OW 94
// DialogueOff ;
31283: CALL_OW 7
// wait ( 0 0$15 ) ;
31287: LD_INT 525
31289: PPUSH
31290: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31294: LD_VAR 0 1
31298: PPUSH
31299: LD_INT 60
31301: PPUSH
31302: LD_INT 95
31304: PPUSH
31305: CALL_OW 116
// exit ;
31309: GO 32152
// end ; if dec = 4 then
31311: LD_VAR 0 2
31315: PUSH
31316: LD_INT 4
31318: EQUAL
31319: IFFALSE 31349
// begin Say ( JMM , D15d-JMM-1 ) ;
31321: LD_EXP 40
31325: PPUSH
31326: LD_STRING D15d-JMM-1
31328: PPUSH
31329: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31333: LD_EXP 67
31337: PPUSH
31338: LD_STRING D15d-Pla-1
31340: PPUSH
31341: CALL_OW 94
// DialogueOff ;
31345: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31349: LD_EXP 65
31353: PPUSH
31354: CALL_OW 302
31358: PUSH
31359: LD_EXP 65
31363: PPUSH
31364: CALL_OW 255
31368: PUSH
31369: LD_INT 1
31371: EQUAL
31372: AND
31373: PUSH
31374: LD_INT 22
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 34
31386: PUSH
31387: LD_INT 8
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PPUSH
31398: CALL_OW 69
31402: NOT
31403: AND
31404: IFFALSE 32053
// begin SetSide ( Friend , 8 ) ;
31406: LD_EXP 65
31410: PPUSH
31411: LD_INT 8
31413: PPUSH
31414: CALL_OW 235
// if IsInUnit ( Friend ) then
31418: LD_EXP 65
31422: PPUSH
31423: CALL_OW 310
31427: IFFALSE 31438
// ComExitBuilding ( Friend ) ;
31429: LD_EXP 65
31433: PPUSH
31434: CALL_OW 122
// if IsDriver ( Friend ) then
31438: LD_EXP 65
31442: PPUSH
31443: CALL 104364 0 1
31447: IFFALSE 31458
// ComExitVehicle ( Friend ) ;
31449: LD_EXP 65
31453: PPUSH
31454: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31458: LD_EXP 65
31462: PPUSH
31463: LD_INT 9
31465: PPUSH
31466: LD_INT 2
31468: PPUSH
31469: CALL_OW 171
// wait ( 0 0$05 ) ;
31473: LD_INT 175
31475: PPUSH
31476: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31480: LD_EXP 65
31484: PPUSH
31485: CALL_OW 87
// DialogueOn ;
31489: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31493: LD_EXP 40
31497: PPUSH
31498: LD_STRING D16-JMM-1
31500: PPUSH
31501: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31505: LD_EXP 65
31509: PPUSH
31510: LD_STRING D16-Friend-1
31512: PPUSH
31513: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31517: LD_EXP 40
31521: PPUSH
31522: LD_STRING D16-JMM-2
31524: PPUSH
31525: CALL_OW 88
// DialogueOff ;
31529: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31533: LD_EXP 65
31537: PPUSH
31538: LD_INT 1
31540: PPUSH
31541: CALL_OW 235
// ComHold ( Friend ) ;
31545: LD_EXP 65
31549: PPUSH
31550: CALL_OW 140
// wait ( 0 0$20 ) ;
31554: LD_INT 700
31556: PPUSH
31557: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31561: LD_EXP 65
31565: PPUSH
31566: LD_INT 9
31568: PPUSH
31569: LD_INT 2
31571: PPUSH
31572: CALL_OW 297
31576: PUSH
31577: LD_INT 30
31579: LESS
31580: IFFALSE 31649
// begin SetSide ( Friend , 8 ) ;
31582: LD_EXP 65
31586: PPUSH
31587: LD_INT 8
31589: PPUSH
31590: CALL_OW 235
// if IsInUnit ( Friend ) then
31594: LD_EXP 65
31598: PPUSH
31599: CALL_OW 310
31603: IFFALSE 31614
// ComExitBuilding ( Friend ) ;
31605: LD_EXP 65
31609: PPUSH
31610: CALL_OW 122
// if IsDriver ( Friend ) then
31614: LD_EXP 65
31618: PPUSH
31619: CALL 104364 0 1
31623: IFFALSE 31634
// ComExitVehicle ( Friend ) ;
31625: LD_EXP 65
31629: PPUSH
31630: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31634: LD_EXP 65
31638: PPUSH
31639: LD_INT 9
31641: PPUSH
31642: LD_INT 2
31644: PPUSH
31645: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31649: LD_INT 1050
31651: PPUSH
31652: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31656: LD_INT 22
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 34
31668: PUSH
31669: LD_INT 8
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PPUSH
31680: CALL_OW 69
31684: NOT
31685: IFFALSE 32031
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31687: LD_ADDR_VAR 0 3
31691: PUSH
31692: LD_INT 22
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 26
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 3
31714: PUSH
31715: LD_INT 25
31717: PUSH
31718: LD_INT 12
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 25
31727: PUSH
31728: LD_INT 16
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: LIST
31744: PPUSH
31745: CALL_OW 69
31749: PUSH
31750: LD_EXP 40
31754: PUSH
31755: LD_EXP 42
31759: PUSH
31760: LD_EXP 56
31764: PUSH
31765: LD_EXP 43
31769: PUSH
31770: LD_EXP 44
31774: PUSH
31775: LD_EXP 45
31779: PUSH
31780: LD_EXP 46
31784: PUSH
31785: LD_EXP 47
31789: PUSH
31790: LD_EXP 48
31794: PUSH
31795: LD_EXP 49
31799: PUSH
31800: LD_EXP 50
31804: PUSH
31805: LD_EXP 51
31809: PUSH
31810: LD_EXP 52
31814: PUSH
31815: LD_EXP 53
31819: PUSH
31820: LD_EXP 54
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: DIFF
31842: ST_TO_ADDR
// DialogueOn ;
31843: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
31847: LD_EXP 67
31851: PPUSH
31852: LD_STRING D16a-Pla-1
31854: PPUSH
31855: CALL_OW 94
// if Stevens then
31859: LD_EXP 42
31863: IFFALSE 31879
// Say ( Stevens , D16a-Huck-1 ) else
31865: LD_EXP 42
31869: PPUSH
31870: LD_STRING D16a-Huck-1
31872: PPUSH
31873: CALL_OW 88
31877: GO 31921
// if Baker then
31879: LD_EXP 56
31883: IFFALSE 31899
// Say ( Baker , D16a-Huck-1 ) else
31885: LD_EXP 56
31889: PPUSH
31890: LD_STRING D16a-Huck-1
31892: PPUSH
31893: CALL_OW 88
31897: GO 31921
// if tmp then
31899: LD_VAR 0 3
31903: IFFALSE 31921
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
31905: LD_VAR 0 3
31909: PUSH
31910: LD_INT 1
31912: ARRAY
31913: PPUSH
31914: LD_STRING D16a-Sol1-1
31916: PPUSH
31917: CALL_OW 88
// if GetSide ( Friend ) = 8 then
31921: LD_EXP 65
31925: PPUSH
31926: CALL_OW 255
31930: PUSH
31931: LD_INT 8
31933: EQUAL
31934: IFFALSE 31950
// Say ( JMM , D16a-JMM-1 ) else
31936: LD_EXP 40
31940: PPUSH
31941: LD_STRING D16a-JMM-1
31943: PPUSH
31944: CALL_OW 88
31948: GO 32010
// begin Say ( JMM , D16a-JMM-1a ) ;
31950: LD_EXP 40
31954: PPUSH
31955: LD_STRING D16a-JMM-1a
31957: PPUSH
31958: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
31962: LD_EXP 65
31966: PPUSH
31967: LD_STRING D16a-Friend-1
31969: PPUSH
31970: CALL_OW 88
// ComExitBuilding ( Friend ) ;
31974: LD_EXP 65
31978: PPUSH
31979: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
31983: LD_EXP 65
31987: PPUSH
31988: LD_INT 191
31990: PPUSH
31991: LD_INT 103
31993: PPUSH
31994: CALL_OW 171
// SetSide ( Friend , 3 ) ;
31998: LD_EXP 65
32002: PPUSH
32003: LD_INT 3
32005: PPUSH
32006: CALL_OW 235
// end ; DialogueOff ;
32010: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32014: LD_VAR 0 1
32018: PPUSH
32019: LD_INT 60
32021: PPUSH
32022: LD_INT 95
32024: PPUSH
32025: CALL_OW 116
// end else
32029: GO 32051
// begin DialogueOn ;
32031: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32035: LD_EXP 67
32039: PPUSH
32040: LD_STRING D16c-Pla-1
32042: PPUSH
32043: CALL_OW 94
// DialogueOff ;
32047: CALL_OW 7
// end ; end else
32051: GO 32152
// begin wait ( 3 3$00 ) ;
32053: LD_INT 6300
32055: PPUSH
32056: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32060: LD_INT 22
32062: PUSH
32063: LD_INT 1
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 34
32072: PUSH
32073: LD_INT 8
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PPUSH
32084: CALL_OW 69
32088: NOT
32089: IFFALSE 32132
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32091: LD_EXP 67
32095: PPUSH
32096: LD_STRING D16b-Pla-1
32098: PPUSH
32099: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32103: LD_EXP 40
32107: PPUSH
32108: LD_STRING D16b-JMM-1
32110: PPUSH
32111: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32115: LD_VAR 0 1
32119: PPUSH
32120: LD_INT 60
32122: PPUSH
32123: LD_INT 95
32125: PPUSH
32126: CALL_OW 116
// end else
32130: GO 32152
// begin DialogueOn ;
32132: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32136: LD_EXP 67
32140: PPUSH
32141: LD_STRING D16c-Pla-1
32143: PPUSH
32144: CALL_OW 94
// DialogueOff ;
32148: CALL_OW 7
// end ; end ; end ;
32152: PPOPN 3
32154: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32155: LD_INT 25
32157: PPUSH
32158: LD_INT 1
32160: PPUSH
32161: CALL_OW 321
32165: PUSH
32166: LD_INT 2
32168: EQUAL
32169: PUSH
32170: LD_EXP 14
32174: PUSH
32175: LD_INT 126000
32177: GREATEREQUAL
32178: OR
32179: PUSH
32180: LD_EXP 23
32184: NOT
32185: AND
32186: PUSH
32187: LD_EXP 78
32191: PPUSH
32192: CALL_OW 302
32196: AND
32197: IFFALSE 32555
32199: GO 32201
32201: DISABLE
32202: LD_INT 0
32204: PPUSH
// begin missionStage := 11 ;
32205: LD_ADDR_EXP 15
32209: PUSH
32210: LD_INT 11
32212: ST_TO_ADDR
// DialogueOn ;
32213: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32217: LD_EXP 78
32221: PPUSH
32222: LD_STRING D9-Roth-1
32224: PPUSH
32225: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32229: LD_EXP 40
32233: PPUSH
32234: LD_STRING D9-JMM-1
32236: PPUSH
32237: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32241: LD_EXP 78
32245: PPUSH
32246: LD_STRING D9-Roth-2
32248: PPUSH
32249: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32253: LD_EXP 78
32257: PPUSH
32258: LD_STRING D9-Roth-2a
32260: PPUSH
32261: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32265: LD_EXP 67
32269: PPUSH
32270: LD_STRING D9-Pla-2
32272: PPUSH
32273: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32277: LD_EXP 78
32281: PPUSH
32282: LD_STRING D9-Roth-3
32284: PPUSH
32285: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32289: LD_EXP 67
32293: PPUSH
32294: LD_STRING D9-Pla-3
32296: PPUSH
32297: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32301: LD_EXP 78
32305: PPUSH
32306: LD_STRING D9-Roth-4
32308: PPUSH
32309: CALL_OW 94
// dec := Query ( Q9 ) ;
32313: LD_ADDR_VAR 0 1
32317: PUSH
32318: LD_STRING Q9
32320: PPUSH
32321: CALL_OW 97
32325: ST_TO_ADDR
// if dec = 1 then
32326: LD_VAR 0 1
32330: PUSH
32331: LD_INT 1
32333: EQUAL
32334: IFFALSE 32348
// SayRadio ( Roth , D9a-Roth-1 ) ;
32336: LD_EXP 78
32340: PPUSH
32341: LD_STRING D9a-Roth-1
32343: PPUSH
32344: CALL_OW 94
// if dec = 2 then
32348: LD_VAR 0 1
32352: PUSH
32353: LD_INT 2
32355: EQUAL
32356: IFFALSE 32382
// begin Say ( JMM , D9b-JMM-1 ) ;
32358: LD_EXP 40
32362: PPUSH
32363: LD_STRING D9b-JMM-1
32365: PPUSH
32366: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32370: LD_EXP 78
32374: PPUSH
32375: LD_STRING D9b-Roth-1
32377: PPUSH
32378: CALL_OW 94
// end ; if dec = 3 then
32382: LD_VAR 0 1
32386: PUSH
32387: LD_INT 3
32389: EQUAL
32390: IFFALSE 32452
// begin Say ( JMM , D9c-JMM-1 ) ;
32392: LD_EXP 40
32396: PPUSH
32397: LD_STRING D9c-JMM-1
32399: PPUSH
32400: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32404: LD_EXP 78
32408: PPUSH
32409: LD_STRING D9c-Roth-1
32411: PPUSH
32412: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32416: LD_EXP 40
32420: PPUSH
32421: LD_STRING D9c-JMM-2
32423: PPUSH
32424: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32428: LD_EXP 78
32432: PPUSH
32433: LD_STRING D9c-Roth-2
32435: PPUSH
32436: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32440: LD_EXP 40
32444: PPUSH
32445: LD_STRING D9c-JMM-3
32447: PPUSH
32448: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32452: LD_EXP 78
32456: PPUSH
32457: LD_STRING D9c-Roth-3
32459: PPUSH
32460: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32464: LD_EXP 78
32468: PPUSH
32469: LD_STRING D9cont-Roth-1
32471: PPUSH
32472: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32476: LD_EXP 40
32480: PPUSH
32481: LD_STRING D9cont-JMM-1
32483: PPUSH
32484: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32488: LD_EXP 78
32492: PPUSH
32493: LD_STRING D9cont-Roth-2
32495: PPUSH
32496: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32500: LD_EXP 40
32504: PPUSH
32505: LD_STRING D9cont-JMM-2
32507: PPUSH
32508: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32512: LD_EXP 78
32516: PPUSH
32517: LD_STRING D9cont-Roth-3
32519: PPUSH
32520: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32524: LD_EXP 40
32528: PPUSH
32529: LD_STRING D9cont-JMM-3
32531: PPUSH
32532: CALL_OW 88
// DialogueOff ;
32536: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32540: LD_STRING M3
32542: PPUSH
32543: CALL_OW 337
// allianceActive := true ;
32547: LD_ADDR_EXP 31
32551: PUSH
32552: LD_INT 1
32554: ST_TO_ADDR
// end ;
32555: PPOPN 1
32557: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32558: LD_INT 1
32560: PPUSH
32561: LD_INT 126
32563: PPUSH
32564: CALL_OW 292
32568: PUSH
32569: LD_EXP 67
32573: PPUSH
32574: CALL_OW 310
32578: AND
32579: IFFALSE 32732
32581: GO 32583
32583: DISABLE
32584: LD_INT 0
32586: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32587: LD_EXP 67
32591: PPUSH
32592: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32596: LD_ADDR_VAR 0 1
32600: PUSH
32601: LD_INT 4
32603: PPUSH
32604: LD_INT 22
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: EMPTY
32611: LIST
32612: LIST
32613: PPUSH
32614: CALL_OW 70
32618: PPUSH
32619: LD_EXP 67
32623: PPUSH
32624: CALL_OW 74
32628: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32629: LD_EXP 67
32633: PPUSH
32634: LD_VAR 0 1
32638: PUSH
32639: LD_INT 1
32641: ARRAY
32642: PPUSH
32643: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32647: LD_EXP 67
32651: PPUSH
32652: LD_STRING D18-Pla-1
32654: PPUSH
32655: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
32659: LD_INT 22
32661: PUSH
32662: LD_INT 3
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 34
32671: PUSH
32672: LD_INT 48
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PPUSH
32683: CALL_OW 69
32687: IFFALSE 32732
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
32689: LD_INT 22
32691: PUSH
32692: LD_INT 3
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 34
32701: PUSH
32702: LD_INT 48
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PPUSH
32713: CALL_OW 69
32717: PUSH
32718: LD_INT 1
32720: ARRAY
32721: PPUSH
32722: LD_INT 111
32724: PPUSH
32725: LD_INT 97
32727: PPUSH
32728: CALL_OW 116
// end ;
32732: PPOPN 1
32734: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
32735: LD_EXP 67
32739: PPUSH
32740: CALL_OW 301
32744: PUSH
32745: LD_EXP 70
32749: PPUSH
32750: CALL_OW 301
32754: AND
32755: PUSH
32756: LD_INT 22
32758: PUSH
32759: LD_INT 3
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 21
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 50
32778: PUSH
32779: EMPTY
32780: LIST
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: LIST
32786: PPUSH
32787: CALL_OW 69
32791: PUSH
32792: LD_INT 7
32794: PUSH
32795: LD_INT 8
32797: PUSH
32798: LD_INT 9
32800: PUSH
32801: LD_INT 10
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: PUSH
32810: LD_OWVAR 67
32814: ARRAY
32815: LESS
32816: AND
32817: IFFALSE 33616
32819: GO 32821
32821: DISABLE
32822: LD_INT 0
32824: PPUSH
32825: PPUSH
32826: PPUSH
32827: PPUSH
// begin MC_Kill ( 2 ) ;
32828: LD_INT 2
32830: PPUSH
32831: CALL 38607 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
32835: LD_INT 1
32837: PPUSH
32838: LD_INT 3
32840: PPUSH
32841: LD_INT 1
32843: PPUSH
32844: LD_INT 1
32846: PPUSH
32847: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
32851: LD_ADDR_VAR 0 2
32855: PUSH
32856: LD_INT 22
32858: PUSH
32859: LD_INT 3
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 21
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 50
32878: PUSH
32879: EMPTY
32880: LIST
32881: PUSH
32882: LD_INT 26
32884: PUSH
32885: LD_INT 1
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: PPUSH
32898: CALL_OW 69
32902: ST_TO_ADDR
// if not tmp then
32903: LD_VAR 0 2
32907: NOT
32908: IFFALSE 32964
// begin uc_side = 3 ;
32910: LD_ADDR_OWVAR 20
32914: PUSH
32915: LD_INT 3
32917: ST_TO_ADDR
// uc_nation = 3 ;
32918: LD_ADDR_OWVAR 21
32922: PUSH
32923: LD_INT 3
32925: ST_TO_ADDR
// hc_name =  ;
32926: LD_ADDR_OWVAR 26
32930: PUSH
32931: LD_STRING 
32933: ST_TO_ADDR
// hc_gallery =  ;
32934: LD_ADDR_OWVAR 33
32938: PUSH
32939: LD_STRING 
32941: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
32942: LD_INT 1
32944: PPUSH
32945: LD_INT 10
32947: PPUSH
32948: CALL_OW 381
// tmp = CreateHuman ;
32952: LD_ADDR_VAR 0 2
32956: PUSH
32957: CALL_OW 44
32961: ST_TO_ADDR
// end else
32962: GO 32978
// tmp := tmp [ 1 ] ;
32964: LD_ADDR_VAR 0 2
32968: PUSH
32969: LD_VAR 0 2
32973: PUSH
32974: LD_INT 1
32976: ARRAY
32977: ST_TO_ADDR
// DialogueOn ;
32978: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
32982: LD_VAR 0 2
32986: PPUSH
32987: LD_STRING DSurrenderRussians-RSol1-1a
32989: PPUSH
32990: CALL_OW 94
// DialogueOff ;
32994: CALL_OW 7
// russianDestroyed := true ;
32998: LD_ADDR_EXP 21
33002: PUSH
33003: LD_INT 1
33005: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33006: LD_ADDR_VAR 0 1
33010: PUSH
33011: LD_INT 22
33013: PUSH
33014: LD_INT 6
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PPUSH
33021: CALL_OW 69
33025: PUSH
33026: FOR_IN
33027: IFFALSE 33040
// KillUnit ( i ) ;
33029: LD_VAR 0 1
33033: PPUSH
33034: CALL_OW 66
33038: GO 33026
33040: POP
33041: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33042: LD_INT 22
33044: PUSH
33045: LD_INT 3
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 21
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PPUSH
33066: CALL_OW 69
33070: PPUSH
33071: CALL_OW 122
// wait ( 0 0$1 ) ;
33075: LD_INT 35
33077: PPUSH
33078: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33082: LD_INT 22
33084: PUSH
33085: LD_INT 3
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 21
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PPUSH
33106: CALL_OW 69
33110: PPUSH
33111: LD_INT 25
33113: PPUSH
33114: CALL_OW 173
// wait ( 0 0$35 ) ;
33118: LD_INT 1225
33120: PPUSH
33121: CALL_OW 67
// PrepareOmarInvasion ;
33125: CALL 15858 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33129: LD_ADDR_VAR 0 2
33133: PUSH
33134: LD_EXP 96
33138: PPUSH
33139: CALL_OW 250
33143: PUSH
33144: LD_EXP 96
33148: PPUSH
33149: CALL_OW 251
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33158: LD_VAR 0 2
33162: PUSH
33163: LD_INT 1
33165: ARRAY
33166: PPUSH
33167: LD_VAR 0 2
33171: PUSH
33172: LD_INT 2
33174: ARRAY
33175: PPUSH
33176: LD_INT 1
33178: PPUSH
33179: LD_INT 8
33181: NEG
33182: PPUSH
33183: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33187: LD_EXP 96
33191: PPUSH
33192: CALL_OW 87
// DialogueOn ;
33196: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33200: LD_EXP 40
33204: PPUSH
33205: LD_STRING D19-JMM-1
33207: PPUSH
33208: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33212: LD_ADDR_VAR 0 3
33216: PUSH
33217: LD_INT 22
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 26
33229: PUSH
33230: LD_INT 1
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 2
33239: PUSH
33240: LD_INT 25
33242: PUSH
33243: LD_INT 1
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 25
33252: PUSH
33253: LD_INT 2
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 25
33262: PUSH
33263: LD_INT 3
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 25
33272: PUSH
33273: LD_INT 4
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 25
33282: PUSH
33283: LD_INT 5
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 25
33292: PUSH
33293: LD_INT 8
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: LIST
33313: PPUSH
33314: CALL_OW 69
33318: PUSH
33319: LD_EXP 40
33323: PUSH
33324: LD_EXP 41
33328: PUSH
33329: LD_EXP 63
33333: PUSH
33334: LD_EXP 42
33338: PUSH
33339: LD_EXP 43
33343: PUSH
33344: LD_EXP 44
33348: PUSH
33349: LD_EXP 45
33353: PUSH
33354: LD_EXP 46
33358: PUSH
33359: LD_EXP 47
33363: PUSH
33364: LD_EXP 48
33368: PUSH
33369: LD_EXP 49
33373: PUSH
33374: LD_EXP 50
33378: PUSH
33379: LD_EXP 51
33383: PUSH
33384: LD_EXP 52
33388: PUSH
33389: LD_EXP 53
33393: PUSH
33394: LD_EXP 54
33398: PUSH
33399: LD_EXP 55
33403: PUSH
33404: LD_EXP 56
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: DIFF
33429: ST_TO_ADDR
// if tmp2 then
33430: LD_VAR 0 3
33434: IFFALSE 33452
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33436: LD_VAR 0 3
33440: PUSH
33441: LD_INT 1
33443: ARRAY
33444: PPUSH
33445: LD_STRING D19-Sol1-1
33447: PPUSH
33448: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33452: LD_EXP 40
33456: PPUSH
33457: LD_STRING D19-JMM-2
33459: PPUSH
33460: CALL_OW 88
// DialogueOff ;
33464: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33468: LD_VAR 0 2
33472: PUSH
33473: LD_INT 1
33475: ARRAY
33476: PPUSH
33477: LD_VAR 0 2
33481: PUSH
33482: LD_INT 2
33484: ARRAY
33485: PPUSH
33486: LD_INT 1
33488: PPUSH
33489: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33493: LD_STRING M5
33495: PPUSH
33496: CALL_OW 337
// omarOnMotherLode := false ;
33500: LD_ADDR_VAR 0 4
33504: PUSH
33505: LD_INT 0
33507: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33508: LD_INT 35
33510: PPUSH
33511: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33515: LD_EXP 96
33519: PPUSH
33520: LD_INT 215
33522: PPUSH
33523: LD_INT 100
33525: PPUSH
33526: CALL_OW 297
33530: PUSH
33531: LD_INT 10
33533: LESS
33534: PUSH
33535: LD_VAR 0 4
33539: NOT
33540: AND
33541: IFFALSE 33575
// begin omarOnMotherLode := true ;
33543: LD_ADDR_VAR 0 4
33547: PUSH
33548: LD_INT 1
33550: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33551: LD_EXP 40
33555: PPUSH
33556: LD_STRING D19b-JMM-1
33558: PPUSH
33559: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33563: LD_EXP 96
33567: PPUSH
33568: LD_STRING DOmarContam-Omar-1
33570: PPUSH
33571: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33575: LD_EXP 96
33579: PPUSH
33580: CALL_OW 301
33584: IFFALSE 33508
// Say ( JMM , D19a-JMM-1 ) ;
33586: LD_EXP 40
33590: PPUSH
33591: LD_STRING D19a-JMM-1
33593: PPUSH
33594: CALL_OW 88
// if Heike then
33598: LD_EXP 97
33602: IFFALSE 33616
// Say ( Heike , D19a-Hke-1 ) ;
33604: LD_EXP 97
33608: PPUSH
33609: LD_STRING D19a-Hke-1
33611: PPUSH
33612: CALL_OW 88
// end ;
33616: PPOPN 4
33618: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33619: LD_INT 22
33621: PUSH
33622: LD_INT 3
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 21
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PPUSH
33643: CALL_OW 69
33647: PUSH
33648: LD_EXP 21
33652: AND
33653: IFFALSE 33721
33655: GO 33657
33657: DISABLE
33658: LD_INT 0
33660: PPUSH
33661: PPUSH
// begin enable ;
33662: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33663: LD_ADDR_VAR 0 2
33667: PUSH
33668: LD_INT 25
33670: PPUSH
33671: LD_INT 22
33673: PUSH
33674: LD_INT 3
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PPUSH
33681: CALL_OW 70
33685: ST_TO_ADDR
// if not tmp then
33686: LD_VAR 0 2
33690: NOT
33691: IFFALSE 33695
// exit ;
33693: GO 33721
// for i in tmp do
33695: LD_ADDR_VAR 0 1
33699: PUSH
33700: LD_VAR 0 2
33704: PUSH
33705: FOR_IN
33706: IFFALSE 33719
// RemoveUnit ( i ) ;
33708: LD_VAR 0 1
33712: PPUSH
33713: CALL_OW 64
33717: GO 33705
33719: POP
33720: POP
// end ;
33721: PPOPN 2
33723: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
33724: LD_INT 22
33726: PUSH
33727: LD_INT 7
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 21
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PPUSH
33748: CALL_OW 69
33752: PUSH
33753: LD_INT 6
33755: LESS
33756: IFFALSE 34224
33758: GO 33760
33760: DISABLE
33761: LD_INT 0
33763: PPUSH
33764: PPUSH
// begin MC_Kill ( 1 ) ;
33765: LD_INT 1
33767: PPUSH
33768: CALL 38607 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
33772: LD_INT 7
33774: PPUSH
33775: LD_INT 1
33777: PPUSH
33778: LD_INT 1
33780: PPUSH
33781: LD_INT 1
33783: PPUSH
33784: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
33788: LD_ADDR_VAR 0 1
33792: PUSH
33793: LD_INT 22
33795: PUSH
33796: LD_INT 7
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 26
33805: PUSH
33806: LD_INT 1
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PPUSH
33817: CALL_OW 69
33821: PUSH
33822: LD_EXP 78
33826: DIFF
33827: ST_TO_ADDR
// if tmp then
33828: LD_VAR 0 1
33832: IFFALSE 33850
// tmp := tmp [ 1 ] else
33834: LD_ADDR_VAR 0 1
33838: PUSH
33839: LD_VAR 0 1
33843: PUSH
33844: LD_INT 1
33846: ARRAY
33847: ST_TO_ADDR
33848: GO 33886
// begin uc_side := 7 ;
33850: LD_ADDR_OWVAR 20
33854: PUSH
33855: LD_INT 7
33857: ST_TO_ADDR
// uc_nation := 1 ;
33858: LD_ADDR_OWVAR 21
33862: PUSH
33863: LD_INT 1
33865: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
33866: LD_INT 1
33868: PPUSH
33869: LD_INT 8
33871: PPUSH
33872: CALL_OW 384
// tmp := CreateHuman ;
33876: LD_ADDR_VAR 0 1
33880: PUSH
33881: CALL_OW 44
33885: ST_TO_ADDR
// end ; DialogueOn ;
33886: CALL_OW 6
// if IsOK ( Roth ) then
33890: LD_EXP 78
33894: PPUSH
33895: CALL_OW 302
33899: IFFALSE 33913
// Say ( JMM , DAb-JMM-1 ) ;
33901: LD_EXP 40
33905: PPUSH
33906: LD_STRING DAb-JMM-1
33908: PPUSH
33909: CALL_OW 88
// if IsOK ( Roth ) then
33913: LD_EXP 78
33917: PPUSH
33918: CALL_OW 302
33922: IFFALSE 33946
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
33924: LD_EXP 78
33928: PPUSH
33929: LD_STRING DSurrenderAlliance-Roth-1
33931: PPUSH
33932: CALL_OW 88
// RothCaptured := true ;
33936: LD_ADDR_EXP 33
33940: PUSH
33941: LD_INT 1
33943: ST_TO_ADDR
// end else
33944: GO 33958
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
33946: LD_VAR 0 1
33950: PPUSH
33951: LD_STRING DSurrenderAlliance-Sci1-1
33953: PPUSH
33954: CALL_OW 88
// DialogueOff ;
33958: CALL_OW 7
// allianceDestroyed := true ;
33962: LD_ADDR_EXP 23
33966: PUSH
33967: LD_INT 1
33969: ST_TO_ADDR
// if capturedUnit = 0 then
33970: LD_EXP 34
33974: PUSH
33975: LD_INT 0
33977: EQUAL
33978: IFFALSE 33987
// SetAchievement ( ACH_ALLIANCE ) ;
33980: LD_STRING ACH_ALLIANCE
33982: PPUSH
33983: CALL_OW 543
// if trueAmericans then
33987: LD_EXP 35
33991: IFFALSE 34067
// begin if trueAmericans = 1 then
33993: LD_EXP 35
33997: PUSH
33998: LD_INT 1
34000: EQUAL
34001: IFFALSE 34017
// Say ( JMM , DAb-JMM-1a ) else
34003: LD_EXP 40
34007: PPUSH
34008: LD_STRING DAb-JMM-1a
34010: PPUSH
34011: CALL_OW 88
34015: GO 34029
// Say ( JMM , DAb-JMM-1b ) ;
34017: LD_EXP 40
34021: PPUSH
34022: LD_STRING DAb-JMM-1b
34024: PPUSH
34025: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34029: LD_EXP 35
34033: PPUSH
34034: CALL_OW 87
// for i in trueAmericans do
34038: LD_ADDR_VAR 0 2
34042: PUSH
34043: LD_EXP 35
34047: PUSH
34048: FOR_IN
34049: IFFALSE 34065
// SetSide ( i , 1 ) ;
34051: LD_VAR 0 2
34055: PPUSH
34056: LD_INT 1
34058: PPUSH
34059: CALL_OW 235
34063: GO 34048
34065: POP
34066: POP
// end ; repeat wait ( 0 0$1 ) ;
34067: LD_INT 35
34069: PPUSH
34070: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34074: LD_ADDR_VAR 0 2
34078: PUSH
34079: LD_INT 22
34081: PUSH
34082: LD_INT 7
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 21
34091: PUSH
34092: LD_INT 1
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PPUSH
34103: CALL_OW 69
34107: PUSH
34108: FOR_IN
34109: IFFALSE 34191
// begin if IsInUnit ( i ) then
34111: LD_VAR 0 2
34115: PPUSH
34116: CALL_OW 310
34120: IFFALSE 34131
// ComExitBuilding ( i ) ;
34122: LD_VAR 0 2
34126: PPUSH
34127: CALL_OW 122
// if IsDriver ( i ) then
34131: LD_VAR 0 2
34135: PPUSH
34136: CALL 104364 0 1
34140: IFFALSE 34151
// ComExitVehicle ( i ) ;
34142: LD_VAR 0 2
34146: PPUSH
34147: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34151: LD_VAR 0 2
34155: PPUSH
34156: LD_INT 26
34158: PPUSH
34159: CALL_OW 308
34163: NOT
34164: IFFALSE 34180
// AddComMoveToArea ( i , allianceEscapeArea ) else
34166: LD_VAR 0 2
34170: PPUSH
34171: LD_INT 26
34173: PPUSH
34174: CALL_OW 173
34178: GO 34189
// RemoveUnit ( i ) ;
34180: LD_VAR 0 2
34184: PPUSH
34185: CALL_OW 64
// end ;
34189: GO 34108
34191: POP
34192: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34193: LD_INT 22
34195: PUSH
34196: LD_INT 7
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 21
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PPUSH
34217: CALL_OW 69
34221: NOT
34222: IFFALSE 34067
// end ;
34224: PPOPN 2
34226: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34227: LD_INT 0
34229: PPUSH
34230: PPUSH
// if not unit then
34231: LD_VAR 0 1
34235: NOT
34236: IFFALSE 34240
// exit ;
34238: GO 35748
// DoNotAttack ( 7 , unit ) ;
34240: LD_INT 7
34242: PPUSH
34243: LD_VAR 0 1
34247: PPUSH
34248: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34252: LD_VAR 0 1
34256: PPUSH
34257: LD_INT 260
34259: PPUSH
34260: LD_INT 235
34262: PPUSH
34263: LD_INT 3
34265: PPUSH
34266: LD_INT 1
34268: PPUSH
34269: CALL_OW 483
// SetSide ( unit , 4 ) ;
34273: LD_VAR 0 1
34277: PPUSH
34278: LD_INT 4
34280: PPUSH
34281: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34285: LD_ADDR_EXP 34
34289: PUSH
34290: LD_EXP 34
34294: PUSH
34295: LD_INT 1
34297: PLUS
34298: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34299: LD_INT 70
34301: PPUSH
34302: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34306: LD_INT 260
34308: PPUSH
34309: LD_INT 235
34311: PPUSH
34312: LD_INT 1
34314: PPUSH
34315: LD_INT 8
34317: NEG
34318: PPUSH
34319: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34323: LD_VAR 0 1
34327: PPUSH
34328: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34332: LD_VAR 0 1
34336: PPUSH
34337: LD_EXP 78
34341: PPUSH
34342: CALL_OW 119
// DialogueOn ;
34346: CALL_OW 6
// case unit of JMM :
34350: LD_VAR 0 1
34354: PUSH
34355: LD_EXP 40
34359: DOUBLE
34360: EQUAL
34361: IFTRUE 34365
34363: GO 34380
34365: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34366: LD_EXP 40
34370: PPUSH
34371: LD_STRING DA1-JMM-1
34373: PPUSH
34374: CALL_OW 91
34378: GO 34822
34380: LD_EXP 41
34384: DOUBLE
34385: EQUAL
34386: IFTRUE 34390
34388: GO 34405
34390: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34391: LD_EXP 41
34395: PPUSH
34396: LD_STRING DA1-Joan-1
34398: PPUSH
34399: CALL_OW 91
34403: GO 34822
34405: LD_EXP 43
34409: DOUBLE
34410: EQUAL
34411: IFTRUE 34415
34413: GO 34430
34415: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34416: LD_EXP 43
34420: PPUSH
34421: LD_STRING DA1-Lisa-1
34423: PPUSH
34424: CALL_OW 91
34428: GO 34822
34430: LD_EXP 44
34434: DOUBLE
34435: EQUAL
34436: IFTRUE 34440
34438: GO 34455
34440: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34441: LD_EXP 44
34445: PPUSH
34446: LD_STRING DA1-Don-1
34448: PPUSH
34449: CALL_OW 91
34453: GO 34822
34455: LD_EXP 51
34459: DOUBLE
34460: EQUAL
34461: IFTRUE 34465
34463: GO 34480
34465: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34466: LD_EXP 51
34470: PPUSH
34471: LD_STRING DA1-Corn-1
34473: PPUSH
34474: CALL_OW 91
34478: GO 34822
34480: LD_EXP 47
34484: DOUBLE
34485: EQUAL
34486: IFTRUE 34490
34488: GO 34505
34490: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34491: LD_EXP 47
34495: PPUSH
34496: LD_STRING DA1-Den-1
34498: PPUSH
34499: CALL_OW 91
34503: GO 34822
34505: LD_EXP 45
34509: DOUBLE
34510: EQUAL
34511: IFTRUE 34515
34513: GO 34530
34515: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34516: LD_EXP 45
34520: PPUSH
34521: LD_STRING DA1-Bobby-1
34523: PPUSH
34524: CALL_OW 91
34528: GO 34822
34530: LD_EXP 49
34534: DOUBLE
34535: EQUAL
34536: IFTRUE 34540
34538: GO 34555
34540: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34541: LD_EXP 49
34545: PPUSH
34546: LD_STRING DA1-Glad-1
34548: PPUSH
34549: CALL_OW 91
34553: GO 34822
34555: LD_EXP 46
34559: DOUBLE
34560: EQUAL
34561: IFTRUE 34565
34563: GO 34580
34565: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34566: LD_EXP 46
34570: PPUSH
34571: LD_STRING DA1-Cyrus-1
34573: PPUSH
34574: CALL_OW 91
34578: GO 34822
34580: LD_EXP 42
34584: DOUBLE
34585: EQUAL
34586: IFTRUE 34590
34588: GO 34605
34590: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34591: LD_EXP 42
34595: PPUSH
34596: LD_STRING DA1-Huck-1
34598: PPUSH
34599: CALL_OW 91
34603: GO 34822
34605: LD_EXP 56
34609: DOUBLE
34610: EQUAL
34611: IFTRUE 34615
34613: GO 34630
34615: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34616: LD_EXP 56
34620: PPUSH
34621: LD_STRING DA1-Huck-1
34623: PPUSH
34624: CALL_OW 91
34628: GO 34822
34630: LD_EXP 48
34634: DOUBLE
34635: EQUAL
34636: IFTRUE 34640
34638: GO 34655
34640: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34641: LD_EXP 48
34645: PPUSH
34646: LD_STRING DA1-Brown-1
34648: PPUSH
34649: CALL_OW 91
34653: GO 34822
34655: LD_EXP 52
34659: DOUBLE
34660: EQUAL
34661: IFTRUE 34665
34663: GO 34680
34665: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34666: LD_EXP 52
34670: PPUSH
34671: LD_STRING DA1-Gary-1
34673: PPUSH
34674: CALL_OW 91
34678: GO 34822
34680: LD_EXP 55
34684: DOUBLE
34685: EQUAL
34686: IFTRUE 34690
34688: GO 34705
34690: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
34691: LD_EXP 55
34695: PPUSH
34696: LD_STRING DA1-Con-1
34698: PPUSH
34699: CALL_OW 91
34703: GO 34822
34705: LD_EXP 63
34709: DOUBLE
34710: EQUAL
34711: IFTRUE 34715
34713: GO 34730
34715: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
34716: LD_EXP 63
34720: PPUSH
34721: LD_STRING DA1-Kurt-1
34723: PPUSH
34724: CALL_OW 91
34728: GO 34822
34730: LD_EXP 54
34734: DOUBLE
34735: EQUAL
34736: IFTRUE 34740
34738: GO 34755
34740: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
34741: LD_EXP 54
34745: PPUSH
34746: LD_STRING DA1-Yam-1
34748: PPUSH
34749: CALL_OW 91
34753: GO 34822
34755: LD_EXP 53
34759: DOUBLE
34760: EQUAL
34761: IFTRUE 34765
34763: GO 34780
34765: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
34766: LD_EXP 53
34770: PPUSH
34771: LD_STRING DA1-Frank-1
34773: PPUSH
34774: CALL_OW 91
34778: GO 34822
34780: POP
// begin if GetSex ( unit ) = sex_male then
34781: LD_VAR 0 1
34785: PPUSH
34786: CALL_OW 258
34790: PUSH
34791: LD_INT 1
34793: EQUAL
34794: IFFALSE 34810
// ForceSay ( unit , DA1-Sol1-1 ) else
34796: LD_VAR 0 1
34800: PPUSH
34801: LD_STRING DA1-Sol1-1
34803: PPUSH
34804: CALL_OW 91
34808: GO 34822
// ForceSay ( unit , DA1-FSol1-1 ) ;
34810: LD_VAR 0 1
34814: PPUSH
34815: LD_STRING DA1-FSol1-1
34817: PPUSH
34818: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
34822: LD_EXP 78
34826: PPUSH
34827: LD_STRING DA-Roth-1
34829: PPUSH
34830: CALL_OW 88
// if capturedUnit = 1 then
34834: LD_EXP 34
34838: PUSH
34839: LD_INT 1
34841: EQUAL
34842: IFFALSE 34870
// begin Say ( Simms , DA-Sim-1 ) ;
34844: LD_EXP 79
34848: PPUSH
34849: LD_STRING DA-Sim-1
34851: PPUSH
34852: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
34856: LD_EXP 78
34860: PPUSH
34861: LD_STRING DA-Roth-2
34863: PPUSH
34864: CALL_OW 88
// end else
34868: GO 34882
// Say ( Simms , DA-Sim-2 ) ;
34870: LD_EXP 79
34874: PPUSH
34875: LD_STRING DA-Sim-2
34877: PPUSH
34878: CALL_OW 88
// case unit of JMM :
34882: LD_VAR 0 1
34886: PUSH
34887: LD_EXP 40
34891: DOUBLE
34892: EQUAL
34893: IFTRUE 34897
34895: GO 34912
34897: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
34898: LD_EXP 40
34902: PPUSH
34903: LD_STRING DA1-JMM-1a
34905: PPUSH
34906: CALL_OW 91
34910: GO 35429
34912: LD_EXP 41
34916: DOUBLE
34917: EQUAL
34918: IFTRUE 34922
34920: GO 34937
34922: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
34923: LD_EXP 41
34927: PPUSH
34928: LD_STRING DA1-Joan-1a
34930: PPUSH
34931: CALL_OW 91
34935: GO 35429
34937: LD_EXP 43
34941: DOUBLE
34942: EQUAL
34943: IFTRUE 34947
34945: GO 34962
34947: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
34948: LD_EXP 43
34952: PPUSH
34953: LD_STRING DA1-Lisa-1a
34955: PPUSH
34956: CALL_OW 91
34960: GO 35429
34962: LD_EXP 44
34966: DOUBLE
34967: EQUAL
34968: IFTRUE 34972
34970: GO 34987
34972: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
34973: LD_EXP 44
34977: PPUSH
34978: LD_STRING DA1-Don-1a
34980: PPUSH
34981: CALL_OW 91
34985: GO 35429
34987: LD_EXP 51
34991: DOUBLE
34992: EQUAL
34993: IFTRUE 34997
34995: GO 35012
34997: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
34998: LD_EXP 51
35002: PPUSH
35003: LD_STRING DA1-Corn-1a
35005: PPUSH
35006: CALL_OW 91
35010: GO 35429
35012: LD_EXP 47
35016: DOUBLE
35017: EQUAL
35018: IFTRUE 35022
35020: GO 35037
35022: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35023: LD_EXP 47
35027: PPUSH
35028: LD_STRING DA1-Den-1a
35030: PPUSH
35031: CALL_OW 91
35035: GO 35429
35037: LD_EXP 45
35041: DOUBLE
35042: EQUAL
35043: IFTRUE 35047
35045: GO 35062
35047: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35048: LD_EXP 45
35052: PPUSH
35053: LD_STRING DA1-Bobby-1a
35055: PPUSH
35056: CALL_OW 91
35060: GO 35429
35062: LD_EXP 49
35066: DOUBLE
35067: EQUAL
35068: IFTRUE 35072
35070: GO 35087
35072: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35073: LD_EXP 49
35077: PPUSH
35078: LD_STRING DA1-Glad-1a
35080: PPUSH
35081: CALL_OW 91
35085: GO 35429
35087: LD_EXP 46
35091: DOUBLE
35092: EQUAL
35093: IFTRUE 35097
35095: GO 35112
35097: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35098: LD_EXP 46
35102: PPUSH
35103: LD_STRING DA1-Cyrus-1a
35105: PPUSH
35106: CALL_OW 91
35110: GO 35429
35112: LD_EXP 42
35116: DOUBLE
35117: EQUAL
35118: IFTRUE 35122
35120: GO 35137
35122: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35123: LD_EXP 42
35127: PPUSH
35128: LD_STRING DA1-Huck-1a
35130: PPUSH
35131: CALL_OW 91
35135: GO 35429
35137: LD_EXP 56
35141: DOUBLE
35142: EQUAL
35143: IFTRUE 35147
35145: GO 35162
35147: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35148: LD_EXP 56
35152: PPUSH
35153: LD_STRING DA1-Huck-1a
35155: PPUSH
35156: CALL_OW 91
35160: GO 35429
35162: LD_EXP 48
35166: DOUBLE
35167: EQUAL
35168: IFTRUE 35172
35170: GO 35187
35172: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35173: LD_EXP 48
35177: PPUSH
35178: LD_STRING DA1-Brown-1a
35180: PPUSH
35181: CALL_OW 91
35185: GO 35429
35187: LD_EXP 52
35191: DOUBLE
35192: EQUAL
35193: IFTRUE 35197
35195: GO 35212
35197: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35198: LD_EXP 52
35202: PPUSH
35203: LD_STRING DA1-Gary-1a
35205: PPUSH
35206: CALL_OW 91
35210: GO 35429
35212: LD_EXP 55
35216: DOUBLE
35217: EQUAL
35218: IFTRUE 35222
35220: GO 35247
35222: POP
// if JMMGirl = 3 then
35223: LD_EXP 7
35227: PUSH
35228: LD_INT 3
35230: EQUAL
35231: IFFALSE 35245
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35233: LD_EXP 55
35237: PPUSH
35238: LD_STRING DA1-Con-1a
35240: PPUSH
35241: CALL_OW 91
35245: GO 35429
35247: LD_EXP 63
35251: DOUBLE
35252: EQUAL
35253: IFTRUE 35257
35255: GO 35272
35257: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35258: LD_EXP 63
35262: PPUSH
35263: LD_STRING DA1-Kurt-1a
35265: PPUSH
35266: CALL_OW 91
35270: GO 35429
35272: LD_EXP 54
35276: DOUBLE
35277: EQUAL
35278: IFTRUE 35282
35280: GO 35297
35282: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35283: LD_EXP 54
35287: PPUSH
35288: LD_STRING DA1-Yam-1a
35290: PPUSH
35291: CALL_OW 91
35295: GO 35429
35297: LD_EXP 53
35301: DOUBLE
35302: EQUAL
35303: IFTRUE 35307
35305: GO 35322
35307: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35308: LD_EXP 53
35312: PPUSH
35313: LD_STRING DA1-Frank-1a
35315: PPUSH
35316: CALL_OW 91
35320: GO 35429
35322: POP
// begin join := rand ( 0 , 1 ) ;
35323: LD_ADDR_VAR 0 3
35327: PUSH
35328: LD_INT 0
35330: PPUSH
35331: LD_INT 1
35333: PPUSH
35334: CALL_OW 12
35338: ST_TO_ADDR
// if join then
35339: LD_VAR 0 3
35343: IFFALSE 35388
// begin if GetSex ( unit ) = sex_male then
35345: LD_VAR 0 1
35349: PPUSH
35350: CALL_OW 258
35354: PUSH
35355: LD_INT 1
35357: EQUAL
35358: IFFALSE 35374
// ForceSay ( unit , DA1-Sol1-1b ) else
35360: LD_VAR 0 1
35364: PPUSH
35365: LD_STRING DA1-Sol1-1b
35367: PPUSH
35368: CALL_OW 91
35372: GO 35386
// ForceSay ( unit , DA1-FSol1-1b ) ;
35374: LD_VAR 0 1
35378: PPUSH
35379: LD_STRING DA1-FSol1-1b
35381: PPUSH
35382: CALL_OW 91
// end else
35386: GO 35429
// begin if GetSex ( unit ) = sex_male then
35388: LD_VAR 0 1
35392: PPUSH
35393: CALL_OW 258
35397: PUSH
35398: LD_INT 1
35400: EQUAL
35401: IFFALSE 35417
// ForceSay ( unit , DA1-Sol1-1a ) else
35403: LD_VAR 0 1
35407: PPUSH
35408: LD_STRING DA1-Sol1-1a
35410: PPUSH
35411: CALL_OW 91
35415: GO 35429
// ForceSay ( unit , DA1-FSol1-1a ) ;
35417: LD_VAR 0 1
35421: PPUSH
35422: LD_STRING DA1-FSol1-1a
35424: PPUSH
35425: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35429: LD_VAR 0 1
35433: PUSH
35434: LD_EXP 40
35438: EQUAL
35439: IFFALSE 35450
// begin YouLost ( JMMCaptured ) ;
35441: LD_STRING JMMCaptured
35443: PPUSH
35444: CALL_OW 104
// exit ;
35448: GO 35748
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35450: LD_VAR 0 1
35454: PUSH
35455: LD_EXP 44
35459: PUSH
35460: LD_EXP 47
35464: PUSH
35465: LD_EXP 45
35469: PUSH
35470: LD_EXP 42
35474: PUSH
35475: LD_EXP 56
35479: PUSH
35480: LD_EXP 48
35484: PUSH
35485: LD_EXP 54
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: IN
35499: PUSH
35500: LD_VAR 0 3
35504: OR
35505: IFFALSE 35604
// begin Say ( Roth , DA-Roth-3 ) ;
35507: LD_EXP 78
35511: PPUSH
35512: LD_STRING DA-Roth-3
35514: PPUSH
35515: CALL_OW 88
// SetSide ( unit , 7 ) ;
35519: LD_VAR 0 1
35523: PPUSH
35524: LD_INT 7
35526: PPUSH
35527: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35531: LD_ADDR_EXP 101
35535: PUSH
35536: LD_EXP 101
35540: PPUSH
35541: LD_INT 1
35543: PPUSH
35544: LD_EXP 101
35548: PUSH
35549: LD_INT 1
35551: ARRAY
35552: PUSH
35553: LD_VAR 0 1
35557: ADD
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35564: LD_INT 260
35566: PPUSH
35567: LD_INT 235
35569: PPUSH
35570: LD_INT 1
35572: PPUSH
35573: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35577: LD_VAR 0 1
35581: PPUSH
35582: LD_INT 1000
35584: PPUSH
35585: CALL_OW 234
// DialogueOff ;
35589: CALL_OW 7
// ComFree ( unit ) ;
35593: LD_VAR 0 1
35597: PPUSH
35598: CALL_OW 139
// end else
35602: GO 35685
// begin Say ( Roth , DA-Roth-3a ) ;
35604: LD_EXP 78
35608: PPUSH
35609: LD_STRING DA-Roth-3a
35611: PPUSH
35612: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35616: LD_ADDR_EXP 35
35620: PUSH
35621: LD_EXP 35
35625: PUSH
35626: LD_VAR 0 1
35630: ADD
35631: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35632: LD_INT 260
35634: PPUSH
35635: LD_INT 235
35637: PPUSH
35638: LD_INT 1
35640: PPUSH
35641: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35645: LD_VAR 0 1
35649: PPUSH
35650: LD_INT 1000
35652: PPUSH
35653: CALL_OW 234
// DialogueOff ;
35657: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35661: LD_VAR 0 1
35665: PPUSH
35666: LD_INT 272
35668: PPUSH
35669: LD_INT 254
35671: PPUSH
35672: CALL_OW 111
// AddComHold ( unit ) ;
35676: LD_VAR 0 1
35680: PPUSH
35681: CALL_OW 200
// end ; if capturedUnit = 1 then
35685: LD_EXP 34
35689: PUSH
35690: LD_INT 1
35692: EQUAL
35693: IFFALSE 35748
// begin DialogueOn ;
35695: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
35699: LD_EXP 40
35703: PPUSH
35704: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
35708: LD_EXP 40
35712: PPUSH
35713: LD_STRING DAa-JMM-1
35715: PPUSH
35716: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
35720: LD_EXP 40
35724: PPUSH
35725: LD_STRING DAa-JMM-1a
35727: PPUSH
35728: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
35732: LD_EXP 40
35736: PPUSH
35737: LD_STRING DAa-JMM-1b
35739: PPUSH
35740: CALL_OW 88
// DialogueOff ;
35744: CALL_OW 7
// end ; end ;
35748: LD_VAR 0 2
35752: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
35753: LD_EXP 15
35757: PUSH
35758: LD_INT 13
35760: GREATEREQUAL
35761: PUSH
35762: LD_INT 22
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 21
35774: PUSH
35775: LD_INT 1
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PPUSH
35786: CALL_OW 69
35790: PUSH
35791: LD_INT 0
35793: EQUAL
35794: AND
35795: PUSH
35796: LD_INT 22
35798: PUSH
35799: LD_INT 2
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 33
35808: PUSH
35809: LD_INT 5
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 21
35818: PUSH
35819: LD_INT 2
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 50
35828: PUSH
35829: EMPTY
35830: LIST
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: LIST
35836: LIST
35837: PPUSH
35838: CALL_OW 69
35842: PUSH
35843: LD_INT 0
35845: EQUAL
35846: AND
35847: PUSH
35848: LD_EXP 21
35852: AND
35853: PUSH
35854: LD_EXP 22
35858: AND
35859: PUSH
35860: LD_EXP 23
35864: AND
35865: IFFALSE 36561
35867: GO 35869
35869: DISABLE
35870: LD_INT 0
35872: PPUSH
35873: PPUSH
35874: PPUSH
// begin m1 := false ;
35875: LD_ADDR_VAR 0 1
35879: PUSH
35880: LD_INT 0
35882: ST_TO_ADDR
// m2 := false ;
35883: LD_ADDR_VAR 0 2
35887: PUSH
35888: LD_INT 0
35890: ST_TO_ADDR
// m3 := false ;
35891: LD_ADDR_VAR 0 3
35895: PUSH
35896: LD_INT 0
35898: ST_TO_ADDR
// if not bombExploded then
35899: LD_EXP 37
35903: NOT
35904: IFFALSE 35913
// SetAchievement ( ACH_SIBROCKET ) ;
35906: LD_STRING ACH_SIBROCKET
35908: PPUSH
35909: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
35913: LD_EXP 65
35917: PPUSH
35918: CALL_OW 255
35922: PUSH
35923: LD_INT 1
35925: EQUAL
35926: PUSH
35927: LD_EXP 65
35931: PPUSH
35932: CALL_OW 302
35936: AND
35937: IFFALSE 35953
// begin wait ( 3 ) ;
35939: LD_INT 3
35941: PPUSH
35942: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
35946: LD_STRING ACH_OPO
35948: PPUSH
35949: CALL_OW 543
// end ; if tick <= 120 120$00 then
35953: LD_OWVAR 1
35957: PUSH
35958: LD_INT 252000
35960: LESSEQUAL
35961: IFFALSE 35977
// begin wait ( 3 ) ;
35963: LD_INT 3
35965: PPUSH
35966: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
35970: LD_STRING ACH_ASPEED_15
35972: PPUSH
35973: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
35977: LD_EXP 40
35981: PPUSH
35982: CALL_OW 87
// music_class := 5 ;
35986: LD_ADDR_OWVAR 72
35990: PUSH
35991: LD_INT 5
35993: ST_TO_ADDR
// music_nat := 5 ;
35994: LD_ADDR_OWVAR 71
35998: PUSH
35999: LD_INT 5
36001: ST_TO_ADDR
// DialogueOn ;
36002: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36006: LD_EXP 40
36010: PPUSH
36011: LD_STRING D20-JMM-1
36013: PPUSH
36014: CALL_OW 88
// if IsOK ( Joan ) then
36018: LD_EXP 41
36022: PPUSH
36023: CALL_OW 302
36027: IFFALSE 36041
// Say ( Joan , D20-Joan-1 ) ;
36029: LD_EXP 41
36033: PPUSH
36034: LD_STRING D20-Joan-1
36036: PPUSH
36037: CALL_OW 88
// if IsOk ( Lisa ) then
36041: LD_EXP 43
36045: PPUSH
36046: CALL_OW 302
36050: IFFALSE 36064
// Say ( Lisa , D20-Lisa-1 ) ;
36052: LD_EXP 43
36056: PPUSH
36057: LD_STRING D20-Lisa-1
36059: PPUSH
36060: CALL_OW 88
// if IsOk ( Donaldson ) then
36064: LD_EXP 44
36068: PPUSH
36069: CALL_OW 302
36073: IFFALSE 36087
// Say ( Donaldson , D20-Don-1 ) ;
36075: LD_EXP 44
36079: PPUSH
36080: LD_STRING D20-Don-1
36082: PPUSH
36083: CALL_OW 88
// if IsOK ( Cornel ) then
36087: LD_EXP 51
36091: PPUSH
36092: CALL_OW 302
36096: IFFALSE 36110
// Say ( Cornel , D20-Corn-1 ) ;
36098: LD_EXP 51
36102: PPUSH
36103: LD_STRING D20-Corn-1
36105: PPUSH
36106: CALL_OW 88
// if IsOk ( Denis ) then
36110: LD_EXP 47
36114: PPUSH
36115: CALL_OW 302
36119: IFFALSE 36133
// Say ( Denis , D20-Den-1 ) ;
36121: LD_EXP 47
36125: PPUSH
36126: LD_STRING D20-Den-1
36128: PPUSH
36129: CALL_OW 88
// if IsOk ( Bobby ) then
36133: LD_EXP 45
36137: PPUSH
36138: CALL_OW 302
36142: IFFALSE 36156
// Say ( Bobby , D20-Bobby-1 ) ;
36144: LD_EXP 45
36148: PPUSH
36149: LD_STRING D20-Bobby-1
36151: PPUSH
36152: CALL_OW 88
// if IsOk ( Gladstone ) then
36156: LD_EXP 49
36160: PPUSH
36161: CALL_OW 302
36165: IFFALSE 36179
// Say ( Gladstone , D20-Glad-1 ) ;
36167: LD_EXP 49
36171: PPUSH
36172: LD_STRING D20-Glad-1
36174: PPUSH
36175: CALL_OW 88
// if IsOk ( Cyrus ) then
36179: LD_EXP 46
36183: PPUSH
36184: CALL_OW 302
36188: IFFALSE 36202
// Say ( Cyrus , D20-Cyrus-1 ) ;
36190: LD_EXP 46
36194: PPUSH
36195: LD_STRING D20-Cyrus-1
36197: PPUSH
36198: CALL_OW 88
// if IsOk ( Stevens ) then
36202: LD_EXP 42
36206: PPUSH
36207: CALL_OW 302
36211: IFFALSE 36225
// Say ( Stevens , D20-Huck-1 ) ;
36213: LD_EXP 42
36217: PPUSH
36218: LD_STRING D20-Huck-1
36220: PPUSH
36221: CALL_OW 88
// if IsOk ( Brown ) then
36225: LD_EXP 48
36229: PPUSH
36230: CALL_OW 302
36234: IFFALSE 36248
// Say ( Brown , D20-Brown-1 ) ;
36236: LD_EXP 48
36240: PPUSH
36241: LD_STRING D20-Brown-1
36243: PPUSH
36244: CALL_OW 88
// if IsOk ( Gary ) then
36248: LD_EXP 52
36252: PPUSH
36253: CALL_OW 302
36257: IFFALSE 36271
// Say ( Gary , D20-Gary-1 ) ;
36259: LD_EXP 52
36263: PPUSH
36264: LD_STRING D20-Gary-1
36266: PPUSH
36267: CALL_OW 88
// if IsOk ( Connie ) then
36271: LD_EXP 55
36275: PPUSH
36276: CALL_OW 302
36280: IFFALSE 36294
// Say ( Connie , D20-Con-1 ) ;
36282: LD_EXP 55
36286: PPUSH
36287: LD_STRING D20-Con-1
36289: PPUSH
36290: CALL_OW 88
// if IsOk ( Kurt ) then
36294: LD_EXP 63
36298: PPUSH
36299: CALL_OW 302
36303: IFFALSE 36317
// Say ( Kurt , D20-Kurt-1 ) ;
36305: LD_EXP 63
36309: PPUSH
36310: LD_STRING D20-Kurt-1
36312: PPUSH
36313: CALL_OW 88
// if IsOk ( Kikuchi ) then
36317: LD_EXP 54
36321: PPUSH
36322: CALL_OW 302
36326: IFFALSE 36340
// Say ( Kikuchi , D20-Yam-1 ) ;
36328: LD_EXP 54
36332: PPUSH
36333: LD_STRING D20-Yam-1
36335: PPUSH
36336: CALL_OW 88
// if IsOk ( Frank ) then
36340: LD_EXP 53
36344: PPUSH
36345: CALL_OW 302
36349: IFFALSE 36363
// Say ( Frank , D20-Frank-1 ) ;
36351: LD_EXP 53
36355: PPUSH
36356: LD_STRING D20-Frank-1
36358: PPUSH
36359: CALL_OW 88
// DialogueOff ;
36363: CALL_OW 7
// if RothCaptured then
36367: LD_EXP 33
36371: IFFALSE 36393
// begin m1 := true ;
36373: LD_ADDR_VAR 0 1
36377: PUSH
36378: LD_INT 1
36380: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36381: LD_STRING Roth
36383: PPUSH
36384: LD_INT 1
36386: PPUSH
36387: CALL_OW 101
// end else
36391: GO 36404
// AddMedal ( Roth , - 1 ) ;
36393: LD_STRING Roth
36395: PPUSH
36396: LD_INT 1
36398: NEG
36399: PPUSH
36400: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36404: LD_EXP 25
36408: NOT
36409: PUSH
36410: LD_EXP 27
36414: OR
36415: PUSH
36416: LD_EXP 28
36420: NOT
36421: OR
36422: IFFALSE 36444
// begin m2 := true ;
36424: LD_ADDR_VAR 0 2
36428: PUSH
36429: LD_INT 1
36431: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36432: LD_STRING Project
36434: PPUSH
36435: LD_INT 1
36437: PPUSH
36438: CALL_OW 101
// end else
36442: GO 36455
// AddMedal ( Project , - 1 ) ;
36444: LD_STRING Project
36446: PPUSH
36447: LD_INT 1
36449: NEG
36450: PPUSH
36451: CALL_OW 101
// if lostCounter = 0 then
36455: LD_EXP 32
36459: PUSH
36460: LD_INT 0
36462: EQUAL
36463: IFFALSE 36485
// begin m3 := true ;
36465: LD_ADDR_VAR 0 3
36469: PUSH
36470: LD_INT 1
36472: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36473: LD_STRING NoLosses
36475: PPUSH
36476: LD_INT 1
36478: PPUSH
36479: CALL_OW 101
// end else
36483: GO 36496
// AddMedal ( NoLosses , - 1 ) ;
36485: LD_STRING NoLosses
36487: PPUSH
36488: LD_INT 1
36490: NEG
36491: PPUSH
36492: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36496: LD_VAR 0 1
36500: PUSH
36501: LD_VAR 0 2
36505: AND
36506: PUSH
36507: LD_VAR 0 3
36511: AND
36512: PUSH
36513: LD_OWVAR 67
36517: PUSH
36518: LD_INT 3
36520: GREATEREQUAL
36521: AND
36522: IFFALSE 36534
// SetAchievementEX ( ACH_AMER , 15 ) ;
36524: LD_STRING ACH_AMER
36526: PPUSH
36527: LD_INT 15
36529: PPUSH
36530: CALL_OW 564
// GiveMedals ( MAIN ) ;
36534: LD_STRING MAIN
36536: PPUSH
36537: CALL_OW 102
// music_class := 4 ;
36541: LD_ADDR_OWVAR 72
36545: PUSH
36546: LD_INT 4
36548: ST_TO_ADDR
// music_nat := 1 ;
36549: LD_ADDR_OWVAR 71
36553: PUSH
36554: LD_INT 1
36556: ST_TO_ADDR
// YouWin ;
36557: CALL_OW 103
// end ; end_of_file
36561: PPOPN 3
36563: END
// export function CustomEvent ( event ) ; begin
36564: LD_INT 0
36566: PPUSH
// end ;
36567: LD_VAR 0 2
36571: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36572: LD_VAR 0 1
36576: PUSH
36577: LD_INT 1
36579: EQUAL
36580: PUSH
36581: LD_VAR 0 2
36585: PUSH
36586: LD_INT 4
36588: EQUAL
36589: AND
36590: PUSH
36591: LD_EXP 60
36595: PPUSH
36596: CALL_OW 300
36600: AND
36601: IFFALSE 36617
// begin wait ( 0 0$2 ) ;
36603: LD_INT 70
36605: PPUSH
36606: CALL_OW 67
// YouLost ( Dismissed ) ;
36610: LD_STRING Dismissed
36612: PPUSH
36613: CALL_OW 104
// end ; end ;
36617: PPOPN 2
36619: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
36620: LD_VAR 0 2
36624: PPUSH
36625: LD_VAR 0 3
36629: PPUSH
36630: LD_INT 18
36632: PPUSH
36633: CALL_OW 309
36637: IFFALSE 36646
// YouLost ( Motherlode3 ) ;
36639: LD_STRING Motherlode3
36641: PPUSH
36642: CALL_OW 104
// end ;
36646: PPOPN 3
36648: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
36649: LD_EXP 27
36653: NOT
36654: IFFALSE 36664
// behemothDone := true ;
36656: LD_ADDR_EXP 28
36660: PUSH
36661: LD_INT 1
36663: ST_TO_ADDR
// end ;
36664: PPOPN 1
36666: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
36667: LD_VAR 0 1
36671: PPUSH
36672: CALL_OW 255
36676: PUSH
36677: LD_INT 1
36679: EQUAL
36680: IFFALSE 36690
// bombExploded := true ;
36682: LD_ADDR_EXP 37
36686: PUSH
36687: LD_INT 1
36689: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
36690: LD_VAR 0 1
36694: PPUSH
36695: CALL_OW 255
36699: PUSH
36700: LD_INT 3
36702: EQUAL
36703: IFFALSE 36733
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
36705: LD_INT 2
36707: PPUSH
36708: LD_INT 23
36710: PUSH
36711: LD_INT 3
36713: PUSH
36714: LD_INT 3
36716: PUSH
36717: LD_INT 48
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: LIST
36724: LIST
36725: PUSH
36726: EMPTY
36727: LIST
36728: PPUSH
36729: CALL 62632 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
36733: LD_VAR 0 1
36737: PPUSH
36738: CALL_OW 255
36742: PUSH
36743: LD_INT 1
36745: EQUAL
36746: PUSH
36747: LD_EXP 65
36751: PPUSH
36752: CALL_OW 255
36756: PUSH
36757: LD_INT 1
36759: EQUAL
36760: AND
36761: PUSH
36762: LD_EXP 65
36766: PPUSH
36767: CALL_OW 302
36771: AND
36772: PUSH
36773: LD_EXP 30
36777: AND
36778: PUSH
36779: LD_INT 22
36781: PUSH
36782: LD_INT 3
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 34
36791: PUSH
36792: LD_INT 48
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: EMPTY
36800: LIST
36801: LIST
36802: PPUSH
36803: CALL_OW 69
36807: AND
36808: PUSH
36809: LD_INT 22
36811: PUSH
36812: LD_INT 1
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 34
36821: PUSH
36822: LD_INT 8
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PPUSH
36833: CALL_OW 69
36837: NOT
36838: AND
36839: IFFALSE 36891
// begin wait ( 0 0$5 ) ;
36841: LD_INT 175
36843: PPUSH
36844: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
36848: LD_INT 22
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 34
36860: PUSH
36861: LD_INT 48
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PPUSH
36872: CALL_OW 69
36876: PUSH
36877: LD_INT 1
36879: ARRAY
36880: PPUSH
36881: LD_INT 60
36883: PPUSH
36884: LD_INT 95
36886: PPUSH
36887: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
36891: LD_VAR 0 2
36895: PPUSH
36896: LD_VAR 0 3
36900: PPUSH
36901: LD_INT 18
36903: PPUSH
36904: CALL_OW 309
36908: PUSH
36909: LD_VAR 0 2
36913: PPUSH
36914: LD_VAR 0 3
36918: PPUSH
36919: LD_INT 18
36921: PPUSH
36922: CALL 110569 0 3
36926: OR
36927: IFFALSE 36974
// begin if GetSide ( unit ) = 1 then
36929: LD_VAR 0 1
36933: PPUSH
36934: CALL_OW 255
36938: PUSH
36939: LD_INT 1
36941: EQUAL
36942: IFFALSE 36960
// begin wait ( 0 0$6 ) ;
36944: LD_INT 210
36946: PPUSH
36947: CALL_OW 67
// YouLost ( Motherlode2 ) ;
36951: LD_STRING Motherlode2
36953: PPUSH
36954: CALL_OW 104
// end else
36958: GO 36974
// begin wait ( 0 0$6 ) ;
36960: LD_INT 210
36962: PPUSH
36963: CALL_OW 67
// YouLost ( Motherlode1 ) ;
36967: LD_STRING Motherlode1
36969: PPUSH
36970: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
36974: LD_VAR 0 1
36978: PPUSH
36979: CALL_OW 255
36983: PUSH
36984: LD_INT 3
36986: EQUAL
36987: IFFALSE 37008
// begin wait ( 0 0$5 ) ;
36989: LD_INT 175
36991: PPUSH
36992: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
36996: LD_EXP 67
37000: PPUSH
37001: LD_STRING D18-Pla-1
37003: PPUSH
37004: CALL_OW 94
// end ; end ;
37008: PPOPN 3
37010: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37011: LD_VAR 0 1
37015: PPUSH
37016: CALL 126784 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37020: LD_VAR 0 1
37024: PUSH
37025: LD_INT 22
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 21
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 23
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: LIST
37059: PPUSH
37060: CALL_OW 69
37064: IN
37065: IFFALSE 37081
// lostCounter := lostCounter + 1 ;
37067: LD_ADDR_EXP 32
37071: PUSH
37072: LD_EXP 32
37076: PUSH
37077: LD_INT 1
37079: PLUS
37080: ST_TO_ADDR
// if un in behemothBuilders then
37081: LD_VAR 0 1
37085: PUSH
37086: LD_EXP 76
37090: IN
37091: IFFALSE 37111
// begin behemothBuilders := behemothBuilders diff un ;
37093: LD_ADDR_EXP 76
37097: PUSH
37098: LD_EXP 76
37102: PUSH
37103: LD_VAR 0 1
37107: DIFF
37108: ST_TO_ADDR
// exit ;
37109: GO 37141
// end ; if un = JMM then
37111: LD_VAR 0 1
37115: PUSH
37116: LD_EXP 40
37120: EQUAL
37121: IFFALSE 37132
// begin YouLost ( JMM ) ;
37123: LD_STRING JMM
37125: PPUSH
37126: CALL_OW 104
// exit ;
37130: GO 37141
// end ; MCE_UnitDestroyed ( un ) ;
37132: LD_VAR 0 1
37136: PPUSH
37137: CALL 66074 0 1
// end ;
37141: PPOPN 1
37143: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37144: LD_VAR 0 1
37148: PPUSH
37149: LD_VAR 0 2
37153: PPUSH
37154: CALL 68406 0 2
// end ;
37158: PPOPN 2
37160: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37161: LD_VAR 0 1
37165: PPUSH
37166: CALL 67474 0 1
// end ;
37170: PPOPN 1
37172: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37173: LD_VAR 0 1
37177: PUSH
37178: LD_INT 22
37180: PUSH
37181: LD_INT 8
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 30
37190: PUSH
37191: LD_INT 2
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 23
37200: PUSH
37201: LD_INT 3
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: LIST
37212: PPUSH
37213: CALL_OW 69
37217: IN
37218: IFFALSE 37245
// begin ComUpgrade ( building ) ;
37220: LD_VAR 0 1
37224: PPUSH
37225: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37229: LD_EXP 64
37233: PPUSH
37234: LD_VAR 0 1
37238: PPUSH
37239: CALL 77258 0 2
// exit ;
37243: GO 37254
// end ; MCE_BuildingComplete ( building ) ;
37245: LD_VAR 0 1
37249: PPUSH
37250: CALL 67715 0 1
// end ;
37254: PPOPN 1
37256: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37257: LD_VAR 0 1
37261: PPUSH
37262: LD_VAR 0 2
37266: PPUSH
37267: CALL 65770 0 2
// end ;
37271: PPOPN 2
37273: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37274: LD_VAR 0 1
37278: PPUSH
37279: LD_VAR 0 2
37283: PPUSH
37284: LD_VAR 0 3
37288: PPUSH
37289: LD_VAR 0 4
37293: PPUSH
37294: LD_VAR 0 5
37298: PPUSH
37299: CALL 65390 0 5
// end ;
37303: PPOPN 5
37305: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37306: LD_VAR 0 1
37310: PPUSH
37311: CALL_OW 255
37315: PUSH
37316: LD_INT 1
37318: EQUAL
37319: IFFALSE 37336
// amConstructCounter := Inc ( amConstructCounter ) ;
37321: LD_ADDR_EXP 39
37325: PUSH
37326: LD_EXP 39
37330: PPUSH
37331: CALL 108121 0 1
37335: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37336: LD_VAR 0 1
37340: PPUSH
37341: LD_VAR 0 2
37345: PPUSH
37346: CALL 126904 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37350: LD_VAR 0 1
37354: PPUSH
37355: LD_VAR 0 2
37359: PPUSH
37360: CALL 64943 0 2
// end ;
37364: PPOPN 2
37366: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37367: LD_VAR 0 1
37371: PPUSH
37372: LD_VAR 0 2
37376: PPUSH
37377: LD_VAR 0 3
37381: PPUSH
37382: LD_VAR 0 4
37386: PPUSH
37387: CALL 64781 0 4
// end ;
37391: PPOPN 4
37393: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37394: LD_VAR 0 1
37398: PPUSH
37399: LD_VAR 0 2
37403: PPUSH
37404: LD_VAR 0 3
37408: PPUSH
37409: CALL 64556 0 3
// end ;
37413: PPOPN 3
37415: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37416: LD_VAR 0 1
37420: PPUSH
37421: LD_VAR 0 2
37425: PPUSH
37426: CALL 64441 0 2
// end ;
37430: PPOPN 2
37432: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37433: LD_VAR 0 1
37437: PPUSH
37438: LD_VAR 0 2
37442: PPUSH
37443: CALL 68701 0 2
// end ;
37447: PPOPN 2
37449: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37450: LD_VAR 0 1
37454: PUSH
37455: LD_INT 460
37457: EQUAL
37458: IFFALSE 37480
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37460: LD_VAR 0 2
37464: PPUSH
37465: LD_INT 227
37467: PPUSH
37468: LD_INT 136
37470: PPUSH
37471: CALL_OW 428
37475: PPUSH
37476: CALL_OW 120
// end ;
37480: PPOPN 2
37482: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37483: LD_VAR 0 1
37487: PPUSH
37488: CALL_OW 255
37492: PUSH
37493: LD_INT 4
37495: EQUAL
37496: PUSH
37497: LD_VAR 0 1
37501: PUSH
37502: LD_EXP 18
37506: PUSH
37507: LD_INT 1
37509: ARRAY
37510: IN
37511: AND
37512: PUSH
37513: LD_EXP 19
37517: AND
37518: IFFALSE 37537
// begin ComMoveXY ( driver , 61 , 93 ) ;
37520: LD_VAR 0 1
37524: PPUSH
37525: LD_INT 61
37527: PPUSH
37528: LD_INT 93
37530: PPUSH
37531: CALL_OW 111
// exit ;
37535: GO 37606
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
37537: LD_VAR 0 1
37541: PPUSH
37542: CALL_OW 255
37546: PUSH
37547: LD_INT 3
37549: EQUAL
37550: PUSH
37551: LD_VAR 0 1
37555: PPUSH
37556: CALL_OW 110
37560: PUSH
37561: LD_INT 105
37563: EQUAL
37564: AND
37565: IFFALSE 37582
// begin ComMoveXY ( driver , 187 , 92 ) ;
37567: LD_VAR 0 1
37571: PPUSH
37572: LD_INT 187
37574: PPUSH
37575: LD_INT 92
37577: PPUSH
37578: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37582: LD_VAR 0 1
37586: PPUSH
37587: LD_VAR 0 2
37591: PPUSH
37592: LD_VAR 0 3
37596: PPUSH
37597: LD_VAR 0 4
37601: PPUSH
37602: CALL 68917 0 4
// end ;
37606: PPOPN 4
37608: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37609: LD_VAR 0 1
37613: PPUSH
37614: LD_VAR 0 2
37618: PPUSH
37619: CALL 64250 0 2
// end ;
37623: PPOPN 2
37625: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
37626: LD_VAR 0 1
37630: PPUSH
37631: CALL 126888 0 1
// end ; end_of_file
37635: PPOPN 1
37637: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
37638: LD_EXP 15
37642: PUSH
37643: LD_INT 2
37645: EQUAL
37646: IFFALSE 38163
37648: GO 37650
37650: DISABLE
37651: LD_INT 0
37653: PPUSH
37654: PPUSH
// begin time := 0 0$35 ;
37655: LD_ADDR_VAR 0 2
37659: PUSH
37660: LD_INT 1225
37662: ST_TO_ADDR
// repeat wait ( time ) ;
37663: LD_VAR 0 2
37667: PPUSH
37668: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
37672: LD_INT 1
37674: PPUSH
37675: LD_INT 5
37677: PPUSH
37678: CALL_OW 12
37682: PPUSH
37683: LD_INT 106
37685: PPUSH
37686: LD_INT 150
37688: PPUSH
37689: LD_INT 19
37691: PPUSH
37692: LD_INT 1
37694: PPUSH
37695: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
37699: LD_INT 455
37701: PPUSH
37702: LD_INT 770
37704: PPUSH
37705: CALL_OW 12
37709: PPUSH
37710: CALL_OW 67
// if Prob ( 50 ) then
37714: LD_INT 50
37716: PPUSH
37717: CALL_OW 13
37721: IFFALSE 37750
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
37723: LD_INT 1
37725: PPUSH
37726: LD_INT 5
37728: PPUSH
37729: CALL_OW 12
37733: PPUSH
37734: LD_INT 62
37736: PPUSH
37737: LD_INT 108
37739: PPUSH
37740: LD_INT 10
37742: PPUSH
37743: LD_INT 1
37745: PPUSH
37746: CALL_OW 56
// until missionStage > 4 ;
37750: LD_EXP 15
37754: PUSH
37755: LD_INT 4
37757: GREATER
37758: IFFALSE 37663
// repeat wait ( 0 0$1 ) ;
37760: LD_INT 35
37762: PPUSH
37763: CALL_OW 67
// until missionStage = 6 ;
37767: LD_EXP 15
37771: PUSH
37772: LD_INT 6
37774: EQUAL
37775: IFFALSE 37760
// time := 0 0$20 ;
37777: LD_ADDR_VAR 0 2
37781: PUSH
37782: LD_INT 700
37784: ST_TO_ADDR
// repeat wait ( time ) ;
37785: LD_VAR 0 2
37789: PPUSH
37790: CALL_OW 67
// if Prob ( 90 ) then
37794: LD_INT 90
37796: PPUSH
37797: CALL_OW 13
37801: IFFALSE 37844
// begin time := time + 0 0$2 ;
37803: LD_ADDR_VAR 0 2
37807: PUSH
37808: LD_VAR 0 2
37812: PUSH
37813: LD_INT 70
37815: PLUS
37816: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
37817: LD_INT 1
37819: PPUSH
37820: LD_INT 5
37822: PPUSH
37823: CALL_OW 12
37827: PPUSH
37828: LD_INT 106
37830: PPUSH
37831: LD_INT 89
37833: PPUSH
37834: LD_INT 45
37836: PPUSH
37837: LD_INT 1
37839: PPUSH
37840: CALL_OW 56
// end ; if Prob ( 45 ) then
37844: LD_INT 45
37846: PPUSH
37847: CALL_OW 13
37851: IFFALSE 37907
// begin for i := 1 to 4 do
37853: LD_ADDR_VAR 0 1
37857: PUSH
37858: DOUBLE
37859: LD_INT 1
37861: DEC
37862: ST_TO_ADDR
37863: LD_INT 4
37865: PUSH
37866: FOR_TO
37867: IFFALSE 37905
// begin wait ( 0 0$5 ) ;
37869: LD_INT 175
37871: PPUSH
37872: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
37876: LD_INT 1
37878: PPUSH
37879: LD_INT 5
37881: PPUSH
37882: CALL_OW 12
37886: PPUSH
37887: LD_INT 113
37889: PPUSH
37890: LD_INT 117
37892: PPUSH
37893: LD_INT 25
37895: PPUSH
37896: LD_INT 1
37898: PPUSH
37899: CALL_OW 56
// end ;
37903: GO 37866
37905: POP
37906: POP
// end ; if Prob ( 40 ) then
37907: LD_INT 40
37909: PPUSH
37910: CALL_OW 13
37914: IFFALSE 37960
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
37916: LD_INT 385
37918: PPUSH
37919: LD_INT 945
37921: PPUSH
37922: CALL_OW 12
37926: PPUSH
37927: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
37931: LD_INT 1
37933: PPUSH
37934: LD_INT 5
37936: PPUSH
37937: CALL_OW 12
37941: PPUSH
37942: LD_INT 21
37944: PPUSH
37945: LD_INT 26
37947: PPUSH
37948: LD_INT 12
37950: PPUSH
37951: LD_INT 1
37953: PPUSH
37954: CALL_OW 56
// end else
37958: GO 37996
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
37960: LD_INT 700
37962: PPUSH
37963: LD_INT 1225
37965: PPUSH
37966: CALL_OW 12
37970: PPUSH
37971: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
37975: LD_INT 1
37977: PPUSH
37978: LD_INT 5
37980: PPUSH
37981: CALL_OW 12
37985: PPUSH
37986: LD_INT 16
37988: PPUSH
37989: LD_INT 1
37991: PPUSH
37992: CALL_OW 55
// end ; if Prob ( 50 ) then
37996: LD_INT 50
37998: PPUSH
37999: CALL_OW 13
38003: IFFALSE 38049
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38005: LD_INT 700
38007: PPUSH
38008: LD_INT 1050
38010: PPUSH
38011: CALL_OW 12
38015: PPUSH
38016: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38020: LD_INT 1
38022: PPUSH
38023: LD_INT 5
38025: PPUSH
38026: CALL_OW 12
38030: PPUSH
38031: LD_INT 168
38033: PPUSH
38034: LD_INT 168
38036: PPUSH
38037: LD_INT 16
38039: PPUSH
38040: LD_INT 1
38042: PPUSH
38043: CALL_OW 56
// end else
38047: GO 38085
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38049: LD_INT 350
38051: PPUSH
38052: LD_INT 525
38054: PPUSH
38055: CALL_OW 12
38059: PPUSH
38060: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38064: LD_INT 1
38066: PPUSH
38067: LD_INT 5
38069: PPUSH
38070: CALL_OW 12
38074: PPUSH
38075: LD_INT 15
38077: PPUSH
38078: LD_INT 1
38080: PPUSH
38081: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38085: LD_INT 175
38087: PPUSH
38088: LD_INT 315
38090: PPUSH
38091: CALL_OW 12
38095: PPUSH
38096: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38100: LD_INT 1
38102: PPUSH
38103: LD_INT 5
38105: PPUSH
38106: CALL_OW 12
38110: PPUSH
38111: LD_INT 103
38113: PPUSH
38114: LD_INT 140
38116: PPUSH
38117: LD_INT 20
38119: PPUSH
38120: LD_INT 1
38122: PPUSH
38123: CALL_OW 56
// time := time + 0 0$2 ;
38127: LD_ADDR_VAR 0 2
38131: PUSH
38132: LD_VAR 0 2
38136: PUSH
38137: LD_INT 70
38139: PLUS
38140: ST_TO_ADDR
// if time > 1 1$20 then
38141: LD_VAR 0 2
38145: PUSH
38146: LD_INT 2800
38148: GREATER
38149: IFFALSE 38159
// time := 0 0$30 ;
38151: LD_ADDR_VAR 0 2
38155: PUSH
38156: LD_INT 1050
38158: ST_TO_ADDR
// until false ;
38159: LD_INT 0
38161: IFFALSE 37785
// end ; end_of_file
38163: PPOPN 2
38165: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38166: LD_EXP 13
38170: PUSH
38171: LD_EXP 15
38175: PUSH
38176: LD_INT 6
38178: GREATEREQUAL
38179: AND
38180: IFFALSE 38217
38182: GO 38184
38184: DISABLE
// begin enable ;
38185: ENABLE
// missionTime := missionTime + 0 0$1 ;
38186: LD_ADDR_EXP 14
38190: PUSH
38191: LD_EXP 14
38195: PUSH
38196: LD_INT 35
38198: PLUS
38199: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38200: LD_ADDR_OWVAR 47
38204: PUSH
38205: LD_STRING #Am15-1
38207: PUSH
38208: LD_EXP 14
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: ST_TO_ADDR
// end ; end_of_file
38217: END
// export function InitNature ; begin
38218: LD_INT 0
38220: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38221: LD_INT 3
38223: PPUSH
38224: LD_INT 3
38226: PPUSH
38227: LD_INT 2
38229: PPUSH
38230: LD_INT 1
38232: PPUSH
38233: LD_INT 1
38235: PPUSH
38236: LD_INT 0
38238: PPUSH
38239: LD_INT 0
38241: PPUSH
38242: LD_INT 20
38244: PPUSH
38245: LD_INT 0
38247: PPUSH
38248: CALL 103437 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38252: LD_INT 2
38254: PPUSH
38255: LD_INT 1
38257: PPUSH
38258: LD_INT 1
38260: PPUSH
38261: LD_INT 1
38263: PPUSH
38264: LD_INT 1
38266: PPUSH
38267: LD_INT 0
38269: PPUSH
38270: LD_INT 0
38272: PPUSH
38273: LD_INT 21
38275: PPUSH
38276: LD_INT 0
38278: PPUSH
38279: CALL 103437 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38283: LD_INT 4
38285: PPUSH
38286: LD_INT 1
38288: PPUSH
38289: LD_INT 2
38291: PPUSH
38292: LD_INT 4
38294: PPUSH
38295: LD_INT 2
38297: PPUSH
38298: LD_INT 1
38300: PPUSH
38301: LD_INT 0
38303: PPUSH
38304: LD_INT 22
38306: PPUSH
38307: LD_INT 0
38309: PPUSH
38310: CALL 103437 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38314: LD_INT 0
38316: PPUSH
38317: LD_INT 0
38319: PPUSH
38320: LD_INT 0
38322: PPUSH
38323: LD_INT 0
38325: PPUSH
38326: LD_INT 0
38328: PPUSH
38329: LD_INT 0
38331: PPUSH
38332: LD_INT 9
38334: PPUSH
38335: LD_INT 0
38337: PPUSH
38338: LD_INT 23
38340: PPUSH
38341: CALL 103437 0 9
// end ; end_of_file
38345: LD_VAR 0 1
38349: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38350: LD_INT 0
38352: PPUSH
38353: PPUSH
// skirmish := false ;
38354: LD_ADDR_EXP 99
38358: PUSH
38359: LD_INT 0
38361: ST_TO_ADDR
// debug_mc := false ;
38362: LD_ADDR_EXP 100
38366: PUSH
38367: LD_INT 0
38369: ST_TO_ADDR
// mc_bases := [ ] ;
38370: LD_ADDR_EXP 101
38374: PUSH
38375: EMPTY
38376: ST_TO_ADDR
// mc_sides := [ ] ;
38377: LD_ADDR_EXP 127
38381: PUSH
38382: EMPTY
38383: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38384: LD_ADDR_EXP 102
38388: PUSH
38389: EMPTY
38390: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38391: LD_ADDR_EXP 103
38395: PUSH
38396: EMPTY
38397: ST_TO_ADDR
// mc_need_heal := [ ] ;
38398: LD_ADDR_EXP 104
38402: PUSH
38403: EMPTY
38404: ST_TO_ADDR
// mc_healers := [ ] ;
38405: LD_ADDR_EXP 105
38409: PUSH
38410: EMPTY
38411: ST_TO_ADDR
// mc_build_list := [ ] ;
38412: LD_ADDR_EXP 106
38416: PUSH
38417: EMPTY
38418: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38419: LD_ADDR_EXP 133
38423: PUSH
38424: EMPTY
38425: ST_TO_ADDR
// mc_builders := [ ] ;
38426: LD_ADDR_EXP 107
38430: PUSH
38431: EMPTY
38432: ST_TO_ADDR
// mc_construct_list := [ ] ;
38433: LD_ADDR_EXP 108
38437: PUSH
38438: EMPTY
38439: ST_TO_ADDR
// mc_turret_list := [ ] ;
38440: LD_ADDR_EXP 109
38444: PUSH
38445: EMPTY
38446: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38447: LD_ADDR_EXP 110
38451: PUSH
38452: EMPTY
38453: ST_TO_ADDR
// mc_miners := [ ] ;
38454: LD_ADDR_EXP 115
38458: PUSH
38459: EMPTY
38460: ST_TO_ADDR
// mc_mines := [ ] ;
38461: LD_ADDR_EXP 114
38465: PUSH
38466: EMPTY
38467: ST_TO_ADDR
// mc_minefields := [ ] ;
38468: LD_ADDR_EXP 116
38472: PUSH
38473: EMPTY
38474: ST_TO_ADDR
// mc_crates := [ ] ;
38475: LD_ADDR_EXP 117
38479: PUSH
38480: EMPTY
38481: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38482: LD_ADDR_EXP 118
38486: PUSH
38487: EMPTY
38488: ST_TO_ADDR
// mc_crates_area := [ ] ;
38489: LD_ADDR_EXP 119
38493: PUSH
38494: EMPTY
38495: ST_TO_ADDR
// mc_vehicles := [ ] ;
38496: LD_ADDR_EXP 120
38500: PUSH
38501: EMPTY
38502: ST_TO_ADDR
// mc_attack := [ ] ;
38503: LD_ADDR_EXP 121
38507: PUSH
38508: EMPTY
38509: ST_TO_ADDR
// mc_produce := [ ] ;
38510: LD_ADDR_EXP 122
38514: PUSH
38515: EMPTY
38516: ST_TO_ADDR
// mc_defender := [ ] ;
38517: LD_ADDR_EXP 123
38521: PUSH
38522: EMPTY
38523: ST_TO_ADDR
// mc_parking := [ ] ;
38524: LD_ADDR_EXP 125
38528: PUSH
38529: EMPTY
38530: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38531: LD_ADDR_EXP 111
38535: PUSH
38536: EMPTY
38537: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38538: LD_ADDR_EXP 113
38542: PUSH
38543: EMPTY
38544: ST_TO_ADDR
// mc_scan := [ ] ;
38545: LD_ADDR_EXP 124
38549: PUSH
38550: EMPTY
38551: ST_TO_ADDR
// mc_scan_area := [ ] ;
38552: LD_ADDR_EXP 126
38556: PUSH
38557: EMPTY
38558: ST_TO_ADDR
// mc_tech := [ ] ;
38559: LD_ADDR_EXP 128
38563: PUSH
38564: EMPTY
38565: ST_TO_ADDR
// mc_class := [ ] ;
38566: LD_ADDR_EXP 142
38570: PUSH
38571: EMPTY
38572: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38573: LD_ADDR_EXP 143
38577: PUSH
38578: EMPTY
38579: ST_TO_ADDR
// mc_is_defending := [ ] ;
38580: LD_ADDR_EXP 144
38584: PUSH
38585: EMPTY
38586: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38587: LD_ADDR_EXP 135
38591: PUSH
38592: EMPTY
38593: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38594: LD_ADDR_EXP 145
38598: PUSH
38599: LD_INT 0
38601: ST_TO_ADDR
// end ;
38602: LD_VAR 0 1
38606: RET
// export function MC_Kill ( base ) ; begin
38607: LD_INT 0
38609: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38610: LD_ADDR_EXP 101
38614: PUSH
38615: LD_EXP 101
38619: PPUSH
38620: LD_VAR 0 1
38624: PPUSH
38625: EMPTY
38626: PPUSH
38627: CALL_OW 1
38631: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38632: LD_ADDR_EXP 102
38636: PUSH
38637: LD_EXP 102
38641: PPUSH
38642: LD_VAR 0 1
38646: PPUSH
38647: EMPTY
38648: PPUSH
38649: CALL_OW 1
38653: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38654: LD_ADDR_EXP 103
38658: PUSH
38659: LD_EXP 103
38663: PPUSH
38664: LD_VAR 0 1
38668: PPUSH
38669: EMPTY
38670: PPUSH
38671: CALL_OW 1
38675: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38676: LD_ADDR_EXP 104
38680: PUSH
38681: LD_EXP 104
38685: PPUSH
38686: LD_VAR 0 1
38690: PPUSH
38691: EMPTY
38692: PPUSH
38693: CALL_OW 1
38697: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38698: LD_ADDR_EXP 105
38702: PUSH
38703: LD_EXP 105
38707: PPUSH
38708: LD_VAR 0 1
38712: PPUSH
38713: EMPTY
38714: PPUSH
38715: CALL_OW 1
38719: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38720: LD_ADDR_EXP 106
38724: PUSH
38725: LD_EXP 106
38729: PPUSH
38730: LD_VAR 0 1
38734: PPUSH
38735: EMPTY
38736: PPUSH
38737: CALL_OW 1
38741: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38742: LD_ADDR_EXP 107
38746: PUSH
38747: LD_EXP 107
38751: PPUSH
38752: LD_VAR 0 1
38756: PPUSH
38757: EMPTY
38758: PPUSH
38759: CALL_OW 1
38763: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38764: LD_ADDR_EXP 108
38768: PUSH
38769: LD_EXP 108
38773: PPUSH
38774: LD_VAR 0 1
38778: PPUSH
38779: EMPTY
38780: PPUSH
38781: CALL_OW 1
38785: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38786: LD_ADDR_EXP 109
38790: PUSH
38791: LD_EXP 109
38795: PPUSH
38796: LD_VAR 0 1
38800: PPUSH
38801: EMPTY
38802: PPUSH
38803: CALL_OW 1
38807: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38808: LD_ADDR_EXP 110
38812: PUSH
38813: LD_EXP 110
38817: PPUSH
38818: LD_VAR 0 1
38822: PPUSH
38823: EMPTY
38824: PPUSH
38825: CALL_OW 1
38829: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38830: LD_ADDR_EXP 111
38834: PUSH
38835: LD_EXP 111
38839: PPUSH
38840: LD_VAR 0 1
38844: PPUSH
38845: EMPTY
38846: PPUSH
38847: CALL_OW 1
38851: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38852: LD_ADDR_EXP 112
38856: PUSH
38857: LD_EXP 112
38861: PPUSH
38862: LD_VAR 0 1
38866: PPUSH
38867: LD_INT 0
38869: PPUSH
38870: CALL_OW 1
38874: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38875: LD_ADDR_EXP 113
38879: PUSH
38880: LD_EXP 113
38884: PPUSH
38885: LD_VAR 0 1
38889: PPUSH
38890: EMPTY
38891: PPUSH
38892: CALL_OW 1
38896: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38897: LD_ADDR_EXP 114
38901: PUSH
38902: LD_EXP 114
38906: PPUSH
38907: LD_VAR 0 1
38911: PPUSH
38912: EMPTY
38913: PPUSH
38914: CALL_OW 1
38918: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38919: LD_ADDR_EXP 115
38923: PUSH
38924: LD_EXP 115
38928: PPUSH
38929: LD_VAR 0 1
38933: PPUSH
38934: EMPTY
38935: PPUSH
38936: CALL_OW 1
38940: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38941: LD_ADDR_EXP 116
38945: PUSH
38946: LD_EXP 116
38950: PPUSH
38951: LD_VAR 0 1
38955: PPUSH
38956: EMPTY
38957: PPUSH
38958: CALL_OW 1
38962: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38963: LD_ADDR_EXP 117
38967: PUSH
38968: LD_EXP 117
38972: PPUSH
38973: LD_VAR 0 1
38977: PPUSH
38978: EMPTY
38979: PPUSH
38980: CALL_OW 1
38984: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38985: LD_ADDR_EXP 118
38989: PUSH
38990: LD_EXP 118
38994: PPUSH
38995: LD_VAR 0 1
38999: PPUSH
39000: EMPTY
39001: PPUSH
39002: CALL_OW 1
39006: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39007: LD_ADDR_EXP 119
39011: PUSH
39012: LD_EXP 119
39016: PPUSH
39017: LD_VAR 0 1
39021: PPUSH
39022: EMPTY
39023: PPUSH
39024: CALL_OW 1
39028: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39029: LD_ADDR_EXP 120
39033: PUSH
39034: LD_EXP 120
39038: PPUSH
39039: LD_VAR 0 1
39043: PPUSH
39044: EMPTY
39045: PPUSH
39046: CALL_OW 1
39050: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39051: LD_ADDR_EXP 121
39055: PUSH
39056: LD_EXP 121
39060: PPUSH
39061: LD_VAR 0 1
39065: PPUSH
39066: EMPTY
39067: PPUSH
39068: CALL_OW 1
39072: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39073: LD_ADDR_EXP 122
39077: PUSH
39078: LD_EXP 122
39082: PPUSH
39083: LD_VAR 0 1
39087: PPUSH
39088: EMPTY
39089: PPUSH
39090: CALL_OW 1
39094: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39095: LD_ADDR_EXP 123
39099: PUSH
39100: LD_EXP 123
39104: PPUSH
39105: LD_VAR 0 1
39109: PPUSH
39110: EMPTY
39111: PPUSH
39112: CALL_OW 1
39116: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39117: LD_ADDR_EXP 124
39121: PUSH
39122: LD_EXP 124
39126: PPUSH
39127: LD_VAR 0 1
39131: PPUSH
39132: EMPTY
39133: PPUSH
39134: CALL_OW 1
39138: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39139: LD_ADDR_EXP 125
39143: PUSH
39144: LD_EXP 125
39148: PPUSH
39149: LD_VAR 0 1
39153: PPUSH
39154: EMPTY
39155: PPUSH
39156: CALL_OW 1
39160: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39161: LD_ADDR_EXP 126
39165: PUSH
39166: LD_EXP 126
39170: PPUSH
39171: LD_VAR 0 1
39175: PPUSH
39176: EMPTY
39177: PPUSH
39178: CALL_OW 1
39182: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39183: LD_ADDR_EXP 128
39187: PUSH
39188: LD_EXP 128
39192: PPUSH
39193: LD_VAR 0 1
39197: PPUSH
39198: EMPTY
39199: PPUSH
39200: CALL_OW 1
39204: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39205: LD_ADDR_EXP 130
39209: PUSH
39210: LD_EXP 130
39214: PPUSH
39215: LD_VAR 0 1
39219: PPUSH
39220: EMPTY
39221: PPUSH
39222: CALL_OW 1
39226: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39227: LD_ADDR_EXP 131
39231: PUSH
39232: LD_EXP 131
39236: PPUSH
39237: LD_VAR 0 1
39241: PPUSH
39242: EMPTY
39243: PPUSH
39244: CALL_OW 1
39248: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39249: LD_ADDR_EXP 132
39253: PUSH
39254: LD_EXP 132
39258: PPUSH
39259: LD_VAR 0 1
39263: PPUSH
39264: EMPTY
39265: PPUSH
39266: CALL_OW 1
39270: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39271: LD_ADDR_EXP 133
39275: PUSH
39276: LD_EXP 133
39280: PPUSH
39281: LD_VAR 0 1
39285: PPUSH
39286: EMPTY
39287: PPUSH
39288: CALL_OW 1
39292: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39293: LD_ADDR_EXP 134
39297: PUSH
39298: LD_EXP 134
39302: PPUSH
39303: LD_VAR 0 1
39307: PPUSH
39308: EMPTY
39309: PPUSH
39310: CALL_OW 1
39314: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39315: LD_ADDR_EXP 135
39319: PUSH
39320: LD_EXP 135
39324: PPUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: EMPTY
39331: PPUSH
39332: CALL_OW 1
39336: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39337: LD_ADDR_EXP 136
39341: PUSH
39342: LD_EXP 136
39346: PPUSH
39347: LD_VAR 0 1
39351: PPUSH
39352: EMPTY
39353: PPUSH
39354: CALL_OW 1
39358: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39359: LD_ADDR_EXP 137
39363: PUSH
39364: LD_EXP 137
39368: PPUSH
39369: LD_VAR 0 1
39373: PPUSH
39374: EMPTY
39375: PPUSH
39376: CALL_OW 1
39380: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39381: LD_ADDR_EXP 138
39385: PUSH
39386: LD_EXP 138
39390: PPUSH
39391: LD_VAR 0 1
39395: PPUSH
39396: EMPTY
39397: PPUSH
39398: CALL_OW 1
39402: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39403: LD_ADDR_EXP 139
39407: PUSH
39408: LD_EXP 139
39412: PPUSH
39413: LD_VAR 0 1
39417: PPUSH
39418: EMPTY
39419: PPUSH
39420: CALL_OW 1
39424: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39425: LD_ADDR_EXP 140
39429: PUSH
39430: LD_EXP 140
39434: PPUSH
39435: LD_VAR 0 1
39439: PPUSH
39440: EMPTY
39441: PPUSH
39442: CALL_OW 1
39446: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39447: LD_ADDR_EXP 141
39451: PUSH
39452: LD_EXP 141
39456: PPUSH
39457: LD_VAR 0 1
39461: PPUSH
39462: EMPTY
39463: PPUSH
39464: CALL_OW 1
39468: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39469: LD_ADDR_EXP 142
39473: PUSH
39474: LD_EXP 142
39478: PPUSH
39479: LD_VAR 0 1
39483: PPUSH
39484: EMPTY
39485: PPUSH
39486: CALL_OW 1
39490: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39491: LD_ADDR_EXP 143
39495: PUSH
39496: LD_EXP 143
39500: PPUSH
39501: LD_VAR 0 1
39505: PPUSH
39506: LD_INT 0
39508: PPUSH
39509: CALL_OW 1
39513: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39514: LD_ADDR_EXP 144
39518: PUSH
39519: LD_EXP 144
39523: PPUSH
39524: LD_VAR 0 1
39528: PPUSH
39529: LD_INT 0
39531: PPUSH
39532: CALL_OW 1
39536: ST_TO_ADDR
// end ;
39537: LD_VAR 0 2
39541: RET
// export function MC_Add ( side , units ) ; var base ; begin
39542: LD_INT 0
39544: PPUSH
39545: PPUSH
// base := mc_bases + 1 ;
39546: LD_ADDR_VAR 0 4
39550: PUSH
39551: LD_EXP 101
39555: PUSH
39556: LD_INT 1
39558: PLUS
39559: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39560: LD_ADDR_EXP 127
39564: PUSH
39565: LD_EXP 127
39569: PPUSH
39570: LD_VAR 0 4
39574: PPUSH
39575: LD_VAR 0 1
39579: PPUSH
39580: CALL_OW 1
39584: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39585: LD_ADDR_EXP 101
39589: PUSH
39590: LD_EXP 101
39594: PPUSH
39595: LD_VAR 0 4
39599: PPUSH
39600: LD_VAR 0 2
39604: PPUSH
39605: CALL_OW 1
39609: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39610: LD_ADDR_EXP 102
39614: PUSH
39615: LD_EXP 102
39619: PPUSH
39620: LD_VAR 0 4
39624: PPUSH
39625: EMPTY
39626: PPUSH
39627: CALL_OW 1
39631: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39632: LD_ADDR_EXP 103
39636: PUSH
39637: LD_EXP 103
39641: PPUSH
39642: LD_VAR 0 4
39646: PPUSH
39647: EMPTY
39648: PPUSH
39649: CALL_OW 1
39653: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39654: LD_ADDR_EXP 104
39658: PUSH
39659: LD_EXP 104
39663: PPUSH
39664: LD_VAR 0 4
39668: PPUSH
39669: EMPTY
39670: PPUSH
39671: CALL_OW 1
39675: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39676: LD_ADDR_EXP 105
39680: PUSH
39681: LD_EXP 105
39685: PPUSH
39686: LD_VAR 0 4
39690: PPUSH
39691: EMPTY
39692: PPUSH
39693: CALL_OW 1
39697: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39698: LD_ADDR_EXP 106
39702: PUSH
39703: LD_EXP 106
39707: PPUSH
39708: LD_VAR 0 4
39712: PPUSH
39713: EMPTY
39714: PPUSH
39715: CALL_OW 1
39719: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39720: LD_ADDR_EXP 107
39724: PUSH
39725: LD_EXP 107
39729: PPUSH
39730: LD_VAR 0 4
39734: PPUSH
39735: EMPTY
39736: PPUSH
39737: CALL_OW 1
39741: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39742: LD_ADDR_EXP 108
39746: PUSH
39747: LD_EXP 108
39751: PPUSH
39752: LD_VAR 0 4
39756: PPUSH
39757: EMPTY
39758: PPUSH
39759: CALL_OW 1
39763: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39764: LD_ADDR_EXP 109
39768: PUSH
39769: LD_EXP 109
39773: PPUSH
39774: LD_VAR 0 4
39778: PPUSH
39779: EMPTY
39780: PPUSH
39781: CALL_OW 1
39785: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39786: LD_ADDR_EXP 110
39790: PUSH
39791: LD_EXP 110
39795: PPUSH
39796: LD_VAR 0 4
39800: PPUSH
39801: EMPTY
39802: PPUSH
39803: CALL_OW 1
39807: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39808: LD_ADDR_EXP 111
39812: PUSH
39813: LD_EXP 111
39817: PPUSH
39818: LD_VAR 0 4
39822: PPUSH
39823: EMPTY
39824: PPUSH
39825: CALL_OW 1
39829: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39830: LD_ADDR_EXP 112
39834: PUSH
39835: LD_EXP 112
39839: PPUSH
39840: LD_VAR 0 4
39844: PPUSH
39845: LD_INT 0
39847: PPUSH
39848: CALL_OW 1
39852: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39853: LD_ADDR_EXP 113
39857: PUSH
39858: LD_EXP 113
39862: PPUSH
39863: LD_VAR 0 4
39867: PPUSH
39868: EMPTY
39869: PPUSH
39870: CALL_OW 1
39874: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39875: LD_ADDR_EXP 114
39879: PUSH
39880: LD_EXP 114
39884: PPUSH
39885: LD_VAR 0 4
39889: PPUSH
39890: EMPTY
39891: PPUSH
39892: CALL_OW 1
39896: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39897: LD_ADDR_EXP 115
39901: PUSH
39902: LD_EXP 115
39906: PPUSH
39907: LD_VAR 0 4
39911: PPUSH
39912: EMPTY
39913: PPUSH
39914: CALL_OW 1
39918: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39919: LD_ADDR_EXP 116
39923: PUSH
39924: LD_EXP 116
39928: PPUSH
39929: LD_VAR 0 4
39933: PPUSH
39934: EMPTY
39935: PPUSH
39936: CALL_OW 1
39940: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39941: LD_ADDR_EXP 117
39945: PUSH
39946: LD_EXP 117
39950: PPUSH
39951: LD_VAR 0 4
39955: PPUSH
39956: EMPTY
39957: PPUSH
39958: CALL_OW 1
39962: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39963: LD_ADDR_EXP 118
39967: PUSH
39968: LD_EXP 118
39972: PPUSH
39973: LD_VAR 0 4
39977: PPUSH
39978: EMPTY
39979: PPUSH
39980: CALL_OW 1
39984: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39985: LD_ADDR_EXP 119
39989: PUSH
39990: LD_EXP 119
39994: PPUSH
39995: LD_VAR 0 4
39999: PPUSH
40000: EMPTY
40001: PPUSH
40002: CALL_OW 1
40006: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40007: LD_ADDR_EXP 120
40011: PUSH
40012: LD_EXP 120
40016: PPUSH
40017: LD_VAR 0 4
40021: PPUSH
40022: EMPTY
40023: PPUSH
40024: CALL_OW 1
40028: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40029: LD_ADDR_EXP 121
40033: PUSH
40034: LD_EXP 121
40038: PPUSH
40039: LD_VAR 0 4
40043: PPUSH
40044: EMPTY
40045: PPUSH
40046: CALL_OW 1
40050: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40051: LD_ADDR_EXP 122
40055: PUSH
40056: LD_EXP 122
40060: PPUSH
40061: LD_VAR 0 4
40065: PPUSH
40066: EMPTY
40067: PPUSH
40068: CALL_OW 1
40072: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40073: LD_ADDR_EXP 123
40077: PUSH
40078: LD_EXP 123
40082: PPUSH
40083: LD_VAR 0 4
40087: PPUSH
40088: EMPTY
40089: PPUSH
40090: CALL_OW 1
40094: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40095: LD_ADDR_EXP 124
40099: PUSH
40100: LD_EXP 124
40104: PPUSH
40105: LD_VAR 0 4
40109: PPUSH
40110: EMPTY
40111: PPUSH
40112: CALL_OW 1
40116: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40117: LD_ADDR_EXP 125
40121: PUSH
40122: LD_EXP 125
40126: PPUSH
40127: LD_VAR 0 4
40131: PPUSH
40132: EMPTY
40133: PPUSH
40134: CALL_OW 1
40138: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40139: LD_ADDR_EXP 126
40143: PUSH
40144: LD_EXP 126
40148: PPUSH
40149: LD_VAR 0 4
40153: PPUSH
40154: EMPTY
40155: PPUSH
40156: CALL_OW 1
40160: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40161: LD_ADDR_EXP 128
40165: PUSH
40166: LD_EXP 128
40170: PPUSH
40171: LD_VAR 0 4
40175: PPUSH
40176: EMPTY
40177: PPUSH
40178: CALL_OW 1
40182: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40183: LD_ADDR_EXP 130
40187: PUSH
40188: LD_EXP 130
40192: PPUSH
40193: LD_VAR 0 4
40197: PPUSH
40198: EMPTY
40199: PPUSH
40200: CALL_OW 1
40204: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40205: LD_ADDR_EXP 131
40209: PUSH
40210: LD_EXP 131
40214: PPUSH
40215: LD_VAR 0 4
40219: PPUSH
40220: EMPTY
40221: PPUSH
40222: CALL_OW 1
40226: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40227: LD_ADDR_EXP 132
40231: PUSH
40232: LD_EXP 132
40236: PPUSH
40237: LD_VAR 0 4
40241: PPUSH
40242: EMPTY
40243: PPUSH
40244: CALL_OW 1
40248: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40249: LD_ADDR_EXP 133
40253: PUSH
40254: LD_EXP 133
40258: PPUSH
40259: LD_VAR 0 4
40263: PPUSH
40264: EMPTY
40265: PPUSH
40266: CALL_OW 1
40270: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40271: LD_ADDR_EXP 134
40275: PUSH
40276: LD_EXP 134
40280: PPUSH
40281: LD_VAR 0 4
40285: PPUSH
40286: EMPTY
40287: PPUSH
40288: CALL_OW 1
40292: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40293: LD_ADDR_EXP 135
40297: PUSH
40298: LD_EXP 135
40302: PPUSH
40303: LD_VAR 0 4
40307: PPUSH
40308: EMPTY
40309: PPUSH
40310: CALL_OW 1
40314: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40315: LD_ADDR_EXP 136
40319: PUSH
40320: LD_EXP 136
40324: PPUSH
40325: LD_VAR 0 4
40329: PPUSH
40330: EMPTY
40331: PPUSH
40332: CALL_OW 1
40336: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40337: LD_ADDR_EXP 137
40341: PUSH
40342: LD_EXP 137
40346: PPUSH
40347: LD_VAR 0 4
40351: PPUSH
40352: EMPTY
40353: PPUSH
40354: CALL_OW 1
40358: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40359: LD_ADDR_EXP 138
40363: PUSH
40364: LD_EXP 138
40368: PPUSH
40369: LD_VAR 0 4
40373: PPUSH
40374: EMPTY
40375: PPUSH
40376: CALL_OW 1
40380: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40381: LD_ADDR_EXP 139
40385: PUSH
40386: LD_EXP 139
40390: PPUSH
40391: LD_VAR 0 4
40395: PPUSH
40396: EMPTY
40397: PPUSH
40398: CALL_OW 1
40402: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40403: LD_ADDR_EXP 140
40407: PUSH
40408: LD_EXP 140
40412: PPUSH
40413: LD_VAR 0 4
40417: PPUSH
40418: EMPTY
40419: PPUSH
40420: CALL_OW 1
40424: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40425: LD_ADDR_EXP 141
40429: PUSH
40430: LD_EXP 141
40434: PPUSH
40435: LD_VAR 0 4
40439: PPUSH
40440: EMPTY
40441: PPUSH
40442: CALL_OW 1
40446: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40447: LD_ADDR_EXP 142
40451: PUSH
40452: LD_EXP 142
40456: PPUSH
40457: LD_VAR 0 4
40461: PPUSH
40462: EMPTY
40463: PPUSH
40464: CALL_OW 1
40468: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40469: LD_ADDR_EXP 143
40473: PUSH
40474: LD_EXP 143
40478: PPUSH
40479: LD_VAR 0 4
40483: PPUSH
40484: LD_INT 0
40486: PPUSH
40487: CALL_OW 1
40491: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40492: LD_ADDR_EXP 144
40496: PUSH
40497: LD_EXP 144
40501: PPUSH
40502: LD_VAR 0 4
40506: PPUSH
40507: LD_INT 0
40509: PPUSH
40510: CALL_OW 1
40514: ST_TO_ADDR
// result := base ;
40515: LD_ADDR_VAR 0 3
40519: PUSH
40520: LD_VAR 0 4
40524: ST_TO_ADDR
// end ;
40525: LD_VAR 0 3
40529: RET
// export function MC_Start ( ) ; var i ; begin
40530: LD_INT 0
40532: PPUSH
40533: PPUSH
// for i = 1 to mc_bases do
40534: LD_ADDR_VAR 0 2
40538: PUSH
40539: DOUBLE
40540: LD_INT 1
40542: DEC
40543: ST_TO_ADDR
40544: LD_EXP 101
40548: PUSH
40549: FOR_TO
40550: IFFALSE 41650
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40552: LD_ADDR_EXP 101
40556: PUSH
40557: LD_EXP 101
40561: PPUSH
40562: LD_VAR 0 2
40566: PPUSH
40567: LD_EXP 101
40571: PUSH
40572: LD_VAR 0 2
40576: ARRAY
40577: PUSH
40578: LD_INT 0
40580: DIFF
40581: PPUSH
40582: CALL_OW 1
40586: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40587: LD_ADDR_EXP 102
40591: PUSH
40592: LD_EXP 102
40596: PPUSH
40597: LD_VAR 0 2
40601: PPUSH
40602: EMPTY
40603: PPUSH
40604: CALL_OW 1
40608: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40609: LD_ADDR_EXP 103
40613: PUSH
40614: LD_EXP 103
40618: PPUSH
40619: LD_VAR 0 2
40623: PPUSH
40624: EMPTY
40625: PPUSH
40626: CALL_OW 1
40630: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
40631: LD_ADDR_EXP 104
40635: PUSH
40636: LD_EXP 104
40640: PPUSH
40641: LD_VAR 0 2
40645: PPUSH
40646: EMPTY
40647: PPUSH
40648: CALL_OW 1
40652: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
40653: LD_ADDR_EXP 105
40657: PUSH
40658: LD_EXP 105
40662: PPUSH
40663: LD_VAR 0 2
40667: PPUSH
40668: EMPTY
40669: PUSH
40670: EMPTY
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PPUSH
40676: CALL_OW 1
40680: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
40681: LD_ADDR_EXP 106
40685: PUSH
40686: LD_EXP 106
40690: PPUSH
40691: LD_VAR 0 2
40695: PPUSH
40696: EMPTY
40697: PPUSH
40698: CALL_OW 1
40702: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
40703: LD_ADDR_EXP 133
40707: PUSH
40708: LD_EXP 133
40712: PPUSH
40713: LD_VAR 0 2
40717: PPUSH
40718: EMPTY
40719: PPUSH
40720: CALL_OW 1
40724: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
40725: LD_ADDR_EXP 107
40729: PUSH
40730: LD_EXP 107
40734: PPUSH
40735: LD_VAR 0 2
40739: PPUSH
40740: EMPTY
40741: PPUSH
40742: CALL_OW 1
40746: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
40747: LD_ADDR_EXP 108
40751: PUSH
40752: LD_EXP 108
40756: PPUSH
40757: LD_VAR 0 2
40761: PPUSH
40762: EMPTY
40763: PPUSH
40764: CALL_OW 1
40768: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
40769: LD_ADDR_EXP 109
40773: PUSH
40774: LD_EXP 109
40778: PPUSH
40779: LD_VAR 0 2
40783: PPUSH
40784: LD_EXP 101
40788: PUSH
40789: LD_VAR 0 2
40793: ARRAY
40794: PPUSH
40795: LD_INT 2
40797: PUSH
40798: LD_INT 30
40800: PUSH
40801: LD_INT 32
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 30
40810: PUSH
40811: LD_INT 33
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: LIST
40822: PPUSH
40823: CALL_OW 72
40827: PPUSH
40828: CALL_OW 1
40832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
40833: LD_ADDR_EXP 110
40837: PUSH
40838: LD_EXP 110
40842: PPUSH
40843: LD_VAR 0 2
40847: PPUSH
40848: LD_EXP 101
40852: PUSH
40853: LD_VAR 0 2
40857: ARRAY
40858: PPUSH
40859: LD_INT 2
40861: PUSH
40862: LD_INT 30
40864: PUSH
40865: LD_INT 32
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 30
40874: PUSH
40875: LD_INT 31
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 58
40889: PUSH
40890: EMPTY
40891: LIST
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PPUSH
40897: CALL_OW 72
40901: PPUSH
40902: CALL_OW 1
40906: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
40907: LD_ADDR_EXP 111
40911: PUSH
40912: LD_EXP 111
40916: PPUSH
40917: LD_VAR 0 2
40921: PPUSH
40922: EMPTY
40923: PPUSH
40924: CALL_OW 1
40928: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
40929: LD_ADDR_EXP 115
40933: PUSH
40934: LD_EXP 115
40938: PPUSH
40939: LD_VAR 0 2
40943: PPUSH
40944: EMPTY
40945: PPUSH
40946: CALL_OW 1
40950: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
40951: LD_ADDR_EXP 114
40955: PUSH
40956: LD_EXP 114
40960: PPUSH
40961: LD_VAR 0 2
40965: PPUSH
40966: EMPTY
40967: PPUSH
40968: CALL_OW 1
40972: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
40973: LD_ADDR_EXP 116
40977: PUSH
40978: LD_EXP 116
40982: PPUSH
40983: LD_VAR 0 2
40987: PPUSH
40988: EMPTY
40989: PPUSH
40990: CALL_OW 1
40994: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
40995: LD_ADDR_EXP 117
40999: PUSH
41000: LD_EXP 117
41004: PPUSH
41005: LD_VAR 0 2
41009: PPUSH
41010: EMPTY
41011: PPUSH
41012: CALL_OW 1
41016: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41017: LD_ADDR_EXP 118
41021: PUSH
41022: LD_EXP 118
41026: PPUSH
41027: LD_VAR 0 2
41031: PPUSH
41032: EMPTY
41033: PPUSH
41034: CALL_OW 1
41038: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41039: LD_ADDR_EXP 119
41043: PUSH
41044: LD_EXP 119
41048: PPUSH
41049: LD_VAR 0 2
41053: PPUSH
41054: EMPTY
41055: PPUSH
41056: CALL_OW 1
41060: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41061: LD_ADDR_EXP 120
41065: PUSH
41066: LD_EXP 120
41070: PPUSH
41071: LD_VAR 0 2
41075: PPUSH
41076: EMPTY
41077: PPUSH
41078: CALL_OW 1
41082: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41083: LD_ADDR_EXP 121
41087: PUSH
41088: LD_EXP 121
41092: PPUSH
41093: LD_VAR 0 2
41097: PPUSH
41098: EMPTY
41099: PPUSH
41100: CALL_OW 1
41104: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41105: LD_ADDR_EXP 122
41109: PUSH
41110: LD_EXP 122
41114: PPUSH
41115: LD_VAR 0 2
41119: PPUSH
41120: EMPTY
41121: PPUSH
41122: CALL_OW 1
41126: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41127: LD_ADDR_EXP 123
41131: PUSH
41132: LD_EXP 123
41136: PPUSH
41137: LD_VAR 0 2
41141: PPUSH
41142: EMPTY
41143: PPUSH
41144: CALL_OW 1
41148: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41149: LD_ADDR_EXP 112
41153: PUSH
41154: LD_EXP 112
41158: PPUSH
41159: LD_VAR 0 2
41163: PPUSH
41164: LD_INT 0
41166: PPUSH
41167: CALL_OW 1
41171: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41172: LD_ADDR_EXP 125
41176: PUSH
41177: LD_EXP 125
41181: PPUSH
41182: LD_VAR 0 2
41186: PPUSH
41187: LD_INT 0
41189: PPUSH
41190: CALL_OW 1
41194: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41195: LD_ADDR_EXP 113
41199: PUSH
41200: LD_EXP 113
41204: PPUSH
41205: LD_VAR 0 2
41209: PPUSH
41210: EMPTY
41211: PPUSH
41212: CALL_OW 1
41216: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41217: LD_ADDR_EXP 124
41221: PUSH
41222: LD_EXP 124
41226: PPUSH
41227: LD_VAR 0 2
41231: PPUSH
41232: LD_INT 0
41234: PPUSH
41235: CALL_OW 1
41239: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41240: LD_ADDR_EXP 126
41244: PUSH
41245: LD_EXP 126
41249: PPUSH
41250: LD_VAR 0 2
41254: PPUSH
41255: EMPTY
41256: PPUSH
41257: CALL_OW 1
41261: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41262: LD_ADDR_EXP 129
41266: PUSH
41267: LD_EXP 129
41271: PPUSH
41272: LD_VAR 0 2
41276: PPUSH
41277: LD_INT 0
41279: PPUSH
41280: CALL_OW 1
41284: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41285: LD_ADDR_EXP 130
41289: PUSH
41290: LD_EXP 130
41294: PPUSH
41295: LD_VAR 0 2
41299: PPUSH
41300: EMPTY
41301: PPUSH
41302: CALL_OW 1
41306: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41307: LD_ADDR_EXP 131
41311: PUSH
41312: LD_EXP 131
41316: PPUSH
41317: LD_VAR 0 2
41321: PPUSH
41322: EMPTY
41323: PPUSH
41324: CALL_OW 1
41328: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41329: LD_ADDR_EXP 132
41333: PUSH
41334: LD_EXP 132
41338: PPUSH
41339: LD_VAR 0 2
41343: PPUSH
41344: EMPTY
41345: PPUSH
41346: CALL_OW 1
41350: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41351: LD_ADDR_EXP 134
41355: PUSH
41356: LD_EXP 134
41360: PPUSH
41361: LD_VAR 0 2
41365: PPUSH
41366: LD_EXP 101
41370: PUSH
41371: LD_VAR 0 2
41375: ARRAY
41376: PPUSH
41377: LD_INT 2
41379: PUSH
41380: LD_INT 30
41382: PUSH
41383: LD_INT 6
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 30
41392: PUSH
41393: LD_INT 7
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 30
41402: PUSH
41403: LD_INT 8
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: LIST
41415: PPUSH
41416: CALL_OW 72
41420: PPUSH
41421: CALL_OW 1
41425: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41426: LD_ADDR_EXP 135
41430: PUSH
41431: LD_EXP 135
41435: PPUSH
41436: LD_VAR 0 2
41440: PPUSH
41441: EMPTY
41442: PPUSH
41443: CALL_OW 1
41447: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41448: LD_ADDR_EXP 136
41452: PUSH
41453: LD_EXP 136
41457: PPUSH
41458: LD_VAR 0 2
41462: PPUSH
41463: EMPTY
41464: PPUSH
41465: CALL_OW 1
41469: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41470: LD_ADDR_EXP 137
41474: PUSH
41475: LD_EXP 137
41479: PPUSH
41480: LD_VAR 0 2
41484: PPUSH
41485: EMPTY
41486: PPUSH
41487: CALL_OW 1
41491: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41492: LD_ADDR_EXP 138
41496: PUSH
41497: LD_EXP 138
41501: PPUSH
41502: LD_VAR 0 2
41506: PPUSH
41507: EMPTY
41508: PPUSH
41509: CALL_OW 1
41513: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41514: LD_ADDR_EXP 139
41518: PUSH
41519: LD_EXP 139
41523: PPUSH
41524: LD_VAR 0 2
41528: PPUSH
41529: EMPTY
41530: PPUSH
41531: CALL_OW 1
41535: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41536: LD_ADDR_EXP 140
41540: PUSH
41541: LD_EXP 140
41545: PPUSH
41546: LD_VAR 0 2
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL_OW 1
41557: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41558: LD_ADDR_EXP 141
41562: PUSH
41563: LD_EXP 141
41567: PPUSH
41568: LD_VAR 0 2
41572: PPUSH
41573: EMPTY
41574: PPUSH
41575: CALL_OW 1
41579: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41580: LD_ADDR_EXP 142
41584: PUSH
41585: LD_EXP 142
41589: PPUSH
41590: LD_VAR 0 2
41594: PPUSH
41595: EMPTY
41596: PPUSH
41597: CALL_OW 1
41601: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41602: LD_ADDR_EXP 143
41606: PUSH
41607: LD_EXP 143
41611: PPUSH
41612: LD_VAR 0 2
41616: PPUSH
41617: LD_INT 0
41619: PPUSH
41620: CALL_OW 1
41624: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
41625: LD_ADDR_EXP 144
41629: PUSH
41630: LD_EXP 144
41634: PPUSH
41635: LD_VAR 0 2
41639: PPUSH
41640: LD_INT 0
41642: PPUSH
41643: CALL_OW 1
41647: ST_TO_ADDR
// end ;
41648: GO 40549
41650: POP
41651: POP
// MC_InitSides ( ) ;
41652: CALL 41938 0 0
// MC_InitResearch ( ) ;
41656: CALL 41677 0 0
// CustomInitMacro ( ) ;
41660: CALL 475 0 0
// skirmish := true ;
41664: LD_ADDR_EXP 99
41668: PUSH
41669: LD_INT 1
41671: ST_TO_ADDR
// end ;
41672: LD_VAR 0 1
41676: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
41677: LD_INT 0
41679: PPUSH
41680: PPUSH
41681: PPUSH
41682: PPUSH
41683: PPUSH
41684: PPUSH
// if not mc_bases then
41685: LD_EXP 101
41689: NOT
41690: IFFALSE 41694
// exit ;
41692: GO 41933
// for i = 1 to 8 do
41694: LD_ADDR_VAR 0 2
41698: PUSH
41699: DOUBLE
41700: LD_INT 1
41702: DEC
41703: ST_TO_ADDR
41704: LD_INT 8
41706: PUSH
41707: FOR_TO
41708: IFFALSE 41734
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
41710: LD_ADDR_EXP 128
41714: PUSH
41715: LD_EXP 128
41719: PPUSH
41720: LD_VAR 0 2
41724: PPUSH
41725: EMPTY
41726: PPUSH
41727: CALL_OW 1
41731: ST_TO_ADDR
41732: GO 41707
41734: POP
41735: POP
// tmp := [ ] ;
41736: LD_ADDR_VAR 0 5
41740: PUSH
41741: EMPTY
41742: ST_TO_ADDR
// for i = 1 to mc_sides do
41743: LD_ADDR_VAR 0 2
41747: PUSH
41748: DOUBLE
41749: LD_INT 1
41751: DEC
41752: ST_TO_ADDR
41753: LD_EXP 127
41757: PUSH
41758: FOR_TO
41759: IFFALSE 41817
// if not mc_sides [ i ] in tmp then
41761: LD_EXP 127
41765: PUSH
41766: LD_VAR 0 2
41770: ARRAY
41771: PUSH
41772: LD_VAR 0 5
41776: IN
41777: NOT
41778: IFFALSE 41815
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
41780: LD_ADDR_VAR 0 5
41784: PUSH
41785: LD_VAR 0 5
41789: PPUSH
41790: LD_VAR 0 5
41794: PUSH
41795: LD_INT 1
41797: PLUS
41798: PPUSH
41799: LD_EXP 127
41803: PUSH
41804: LD_VAR 0 2
41808: ARRAY
41809: PPUSH
41810: CALL_OW 2
41814: ST_TO_ADDR
41815: GO 41758
41817: POP
41818: POP
// if not tmp then
41819: LD_VAR 0 5
41823: NOT
41824: IFFALSE 41828
// exit ;
41826: GO 41933
// for j in tmp do
41828: LD_ADDR_VAR 0 3
41832: PUSH
41833: LD_VAR 0 5
41837: PUSH
41838: FOR_IN
41839: IFFALSE 41931
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
41841: LD_ADDR_VAR 0 6
41845: PUSH
41846: LD_INT 22
41848: PUSH
41849: LD_VAR 0 3
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PPUSH
41858: CALL_OW 69
41862: ST_TO_ADDR
// if not un then
41863: LD_VAR 0 6
41867: NOT
41868: IFFALSE 41872
// continue ;
41870: GO 41838
// nation := GetNation ( un [ 1 ] ) ;
41872: LD_ADDR_VAR 0 4
41876: PUSH
41877: LD_VAR 0 6
41881: PUSH
41882: LD_INT 1
41884: ARRAY
41885: PPUSH
41886: CALL_OW 248
41890: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
41891: LD_ADDR_EXP 128
41895: PUSH
41896: LD_EXP 128
41900: PPUSH
41901: LD_VAR 0 3
41905: PPUSH
41906: LD_VAR 0 3
41910: PPUSH
41911: LD_VAR 0 4
41915: PPUSH
41916: LD_INT 1
41918: PPUSH
41919: CALL 69121 0 3
41923: PPUSH
41924: CALL_OW 1
41928: ST_TO_ADDR
// end ;
41929: GO 41838
41931: POP
41932: POP
// end ;
41933: LD_VAR 0 1
41937: RET
// export function MC_InitSides ( ) ; var i ; begin
41938: LD_INT 0
41940: PPUSH
41941: PPUSH
// if not mc_bases then
41942: LD_EXP 101
41946: NOT
41947: IFFALSE 41951
// exit ;
41949: GO 42025
// for i = 1 to mc_bases do
41951: LD_ADDR_VAR 0 2
41955: PUSH
41956: DOUBLE
41957: LD_INT 1
41959: DEC
41960: ST_TO_ADDR
41961: LD_EXP 101
41965: PUSH
41966: FOR_TO
41967: IFFALSE 42023
// if mc_bases [ i ] then
41969: LD_EXP 101
41973: PUSH
41974: LD_VAR 0 2
41978: ARRAY
41979: IFFALSE 42021
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
41981: LD_ADDR_EXP 127
41985: PUSH
41986: LD_EXP 127
41990: PPUSH
41991: LD_VAR 0 2
41995: PPUSH
41996: LD_EXP 101
42000: PUSH
42001: LD_VAR 0 2
42005: ARRAY
42006: PUSH
42007: LD_INT 1
42009: ARRAY
42010: PPUSH
42011: CALL_OW 255
42015: PPUSH
42016: CALL_OW 1
42020: ST_TO_ADDR
42021: GO 41966
42023: POP
42024: POP
// end ;
42025: LD_VAR 0 1
42029: RET
// every 0 0$03 trigger skirmish do
42030: LD_EXP 99
42034: IFFALSE 42188
42036: GO 42038
42038: DISABLE
// begin enable ;
42039: ENABLE
// MC_CheckBuildings ( ) ;
42040: CALL 46700 0 0
// MC_CheckPeopleLife ( ) ;
42044: CALL 46861 0 0
// RaiseSailEvent ( 100 ) ;
42048: LD_INT 100
42050: PPUSH
42051: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42055: LD_INT 103
42057: PPUSH
42058: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42062: LD_INT 104
42064: PPUSH
42065: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42069: LD_INT 105
42071: PPUSH
42072: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42076: LD_INT 106
42078: PPUSH
42079: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42083: LD_INT 107
42085: PPUSH
42086: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42090: LD_INT 108
42092: PPUSH
42093: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42097: LD_INT 109
42099: PPUSH
42100: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42104: LD_INT 110
42106: PPUSH
42107: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42111: LD_INT 111
42113: PPUSH
42114: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42118: LD_INT 112
42120: PPUSH
42121: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42125: LD_INT 113
42127: PPUSH
42128: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42132: LD_INT 120
42134: PPUSH
42135: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42139: LD_INT 121
42141: PPUSH
42142: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42146: LD_INT 122
42148: PPUSH
42149: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42153: LD_INT 123
42155: PPUSH
42156: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42160: LD_INT 124
42162: PPUSH
42163: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42167: LD_INT 125
42169: PPUSH
42170: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42174: LD_INT 126
42176: PPUSH
42177: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42181: LD_INT 200
42183: PPUSH
42184: CALL_OW 427
// end ;
42188: END
// on SailEvent ( event ) do begin if event < 100 then
42189: LD_VAR 0 1
42193: PUSH
42194: LD_INT 100
42196: LESS
42197: IFFALSE 42208
// CustomEvent ( event ) ;
42199: LD_VAR 0 1
42203: PPUSH
42204: CALL 36564 0 1
// if event = 100 then
42208: LD_VAR 0 1
42212: PUSH
42213: LD_INT 100
42215: EQUAL
42216: IFFALSE 42222
// MC_ClassManager ( ) ;
42218: CALL 42614 0 0
// if event = 101 then
42222: LD_VAR 0 1
42226: PUSH
42227: LD_INT 101
42229: EQUAL
42230: IFFALSE 42236
// MC_RepairBuildings ( ) ;
42232: CALL 47446 0 0
// if event = 102 then
42236: LD_VAR 0 1
42240: PUSH
42241: LD_INT 102
42243: EQUAL
42244: IFFALSE 42250
// MC_Heal ( ) ;
42246: CALL 48381 0 0
// if event = 103 then
42250: LD_VAR 0 1
42254: PUSH
42255: LD_INT 103
42257: EQUAL
42258: IFFALSE 42264
// MC_Build ( ) ;
42260: CALL 48803 0 0
// if event = 104 then
42264: LD_VAR 0 1
42268: PUSH
42269: LD_INT 104
42271: EQUAL
42272: IFFALSE 42278
// MC_TurretWeapon ( ) ;
42274: CALL 50437 0 0
// if event = 105 then
42278: LD_VAR 0 1
42282: PUSH
42283: LD_INT 105
42285: EQUAL
42286: IFFALSE 42292
// MC_BuildUpgrade ( ) ;
42288: CALL 49988 0 0
// if event = 106 then
42292: LD_VAR 0 1
42296: PUSH
42297: LD_INT 106
42299: EQUAL
42300: IFFALSE 42306
// MC_PlantMines ( ) ;
42302: CALL 50867 0 0
// if event = 107 then
42306: LD_VAR 0 1
42310: PUSH
42311: LD_INT 107
42313: EQUAL
42314: IFFALSE 42320
// MC_CollectCrates ( ) ;
42316: CALL 51665 0 0
// if event = 108 then
42320: LD_VAR 0 1
42324: PUSH
42325: LD_INT 108
42327: EQUAL
42328: IFFALSE 42334
// MC_LinkRemoteControl ( ) ;
42330: CALL 53515 0 0
// if event = 109 then
42334: LD_VAR 0 1
42338: PUSH
42339: LD_INT 109
42341: EQUAL
42342: IFFALSE 42348
// MC_ProduceVehicle ( ) ;
42344: CALL 53696 0 0
// if event = 110 then
42348: LD_VAR 0 1
42352: PUSH
42353: LD_INT 110
42355: EQUAL
42356: IFFALSE 42362
// MC_SendAttack ( ) ;
42358: CALL 54162 0 0
// if event = 111 then
42362: LD_VAR 0 1
42366: PUSH
42367: LD_INT 111
42369: EQUAL
42370: IFFALSE 42376
// MC_Defend ( ) ;
42372: CALL 54270 0 0
// if event = 112 then
42376: LD_VAR 0 1
42380: PUSH
42381: LD_INT 112
42383: EQUAL
42384: IFFALSE 42390
// MC_Research ( ) ;
42386: CALL 55150 0 0
// if event = 113 then
42390: LD_VAR 0 1
42394: PUSH
42395: LD_INT 113
42397: EQUAL
42398: IFFALSE 42404
// MC_MinesTrigger ( ) ;
42400: CALL 56264 0 0
// if event = 120 then
42404: LD_VAR 0 1
42408: PUSH
42409: LD_INT 120
42411: EQUAL
42412: IFFALSE 42418
// MC_RepairVehicle ( ) ;
42414: CALL 56363 0 0
// if event = 121 then
42418: LD_VAR 0 1
42422: PUSH
42423: LD_INT 121
42425: EQUAL
42426: IFFALSE 42432
// MC_TameApe ( ) ;
42428: CALL 57132 0 0
// if event = 122 then
42432: LD_VAR 0 1
42436: PUSH
42437: LD_INT 122
42439: EQUAL
42440: IFFALSE 42446
// MC_ChangeApeClass ( ) ;
42442: CALL 57961 0 0
// if event = 123 then
42446: LD_VAR 0 1
42450: PUSH
42451: LD_INT 123
42453: EQUAL
42454: IFFALSE 42460
// MC_Bazooka ( ) ;
42456: CALL 58611 0 0
// if event = 124 then
42460: LD_VAR 0 1
42464: PUSH
42465: LD_INT 124
42467: EQUAL
42468: IFFALSE 42474
// MC_TeleportExit ( ) ;
42470: CALL 58809 0 0
// if event = 125 then
42474: LD_VAR 0 1
42478: PUSH
42479: LD_INT 125
42481: EQUAL
42482: IFFALSE 42488
// MC_Deposits ( ) ;
42484: CALL 59456 0 0
// if event = 126 then
42488: LD_VAR 0 1
42492: PUSH
42493: LD_INT 126
42495: EQUAL
42496: IFFALSE 42502
// MC_RemoteDriver ( ) ;
42498: CALL 60081 0 0
// if event = 200 then
42502: LD_VAR 0 1
42506: PUSH
42507: LD_INT 200
42509: EQUAL
42510: IFFALSE 42516
// MC_Idle ( ) ;
42512: CALL 61988 0 0
// end ;
42516: PPOPN 1
42518: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42519: LD_INT 0
42521: PPUSH
42522: PPUSH
// if not mc_bases [ base ] or not tag then
42523: LD_EXP 101
42527: PUSH
42528: LD_VAR 0 1
42532: ARRAY
42533: NOT
42534: PUSH
42535: LD_VAR 0 2
42539: NOT
42540: OR
42541: IFFALSE 42545
// exit ;
42543: GO 42609
// for i in mc_bases [ base ] union mc_ape [ base ] do
42545: LD_ADDR_VAR 0 4
42549: PUSH
42550: LD_EXP 101
42554: PUSH
42555: LD_VAR 0 1
42559: ARRAY
42560: PUSH
42561: LD_EXP 130
42565: PUSH
42566: LD_VAR 0 1
42570: ARRAY
42571: UNION
42572: PUSH
42573: FOR_IN
42574: IFFALSE 42607
// if GetTag ( i ) = tag then
42576: LD_VAR 0 4
42580: PPUSH
42581: CALL_OW 110
42585: PUSH
42586: LD_VAR 0 2
42590: EQUAL
42591: IFFALSE 42605
// SetTag ( i , 0 ) ;
42593: LD_VAR 0 4
42597: PPUSH
42598: LD_INT 0
42600: PPUSH
42601: CALL_OW 109
42605: GO 42573
42607: POP
42608: POP
// end ;
42609: LD_VAR 0 3
42613: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
42614: LD_INT 0
42616: PPUSH
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
42623: PPUSH
// if not mc_bases then
42624: LD_EXP 101
42628: NOT
42629: IFFALSE 42633
// exit ;
42631: GO 43082
// for i = 1 to mc_bases do
42633: LD_ADDR_VAR 0 2
42637: PUSH
42638: DOUBLE
42639: LD_INT 1
42641: DEC
42642: ST_TO_ADDR
42643: LD_EXP 101
42647: PUSH
42648: FOR_TO
42649: IFFALSE 43080
// begin tmp := MC_ClassCheckReq ( i ) ;
42651: LD_ADDR_VAR 0 4
42655: PUSH
42656: LD_VAR 0 2
42660: PPUSH
42661: CALL 43087 0 1
42665: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
42666: LD_ADDR_EXP 142
42670: PUSH
42671: LD_EXP 142
42675: PPUSH
42676: LD_VAR 0 2
42680: PPUSH
42681: LD_VAR 0 4
42685: PPUSH
42686: CALL_OW 1
42690: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
42691: LD_ADDR_VAR 0 6
42695: PUSH
42696: LD_EXP 101
42700: PUSH
42701: LD_VAR 0 2
42705: ARRAY
42706: PPUSH
42707: LD_INT 2
42709: PUSH
42710: LD_INT 30
42712: PUSH
42713: LD_INT 4
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 30
42722: PUSH
42723: LD_INT 5
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: LIST
42734: PPUSH
42735: CALL_OW 72
42739: PUSH
42740: LD_EXP 101
42744: PUSH
42745: LD_VAR 0 2
42749: ARRAY
42750: PPUSH
42751: LD_INT 2
42753: PUSH
42754: LD_INT 30
42756: PUSH
42757: LD_INT 0
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 30
42766: PUSH
42767: LD_INT 1
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: LIST
42778: PPUSH
42779: CALL_OW 72
42783: PUSH
42784: LD_EXP 101
42788: PUSH
42789: LD_VAR 0 2
42793: ARRAY
42794: PPUSH
42795: LD_INT 30
42797: PUSH
42798: LD_INT 3
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PPUSH
42805: CALL_OW 72
42809: PUSH
42810: LD_EXP 101
42814: PUSH
42815: LD_VAR 0 2
42819: ARRAY
42820: PPUSH
42821: LD_INT 2
42823: PUSH
42824: LD_INT 30
42826: PUSH
42827: LD_INT 6
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 30
42836: PUSH
42837: LD_INT 7
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 30
42846: PUSH
42847: LD_INT 8
42849: PUSH
42850: EMPTY
42851: LIST
42852: LIST
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: PPUSH
42860: CALL_OW 72
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: ST_TO_ADDR
// for j := 1 to 4 do
42871: LD_ADDR_VAR 0 3
42875: PUSH
42876: DOUBLE
42877: LD_INT 1
42879: DEC
42880: ST_TO_ADDR
42881: LD_INT 4
42883: PUSH
42884: FOR_TO
42885: IFFALSE 43076
// begin if not tmp [ j ] then
42887: LD_VAR 0 4
42891: PUSH
42892: LD_VAR 0 3
42896: ARRAY
42897: NOT
42898: IFFALSE 42902
// continue ;
42900: GO 42884
// for p in tmp [ j ] do
42902: LD_ADDR_VAR 0 5
42906: PUSH
42907: LD_VAR 0 4
42911: PUSH
42912: LD_VAR 0 3
42916: ARRAY
42917: PUSH
42918: FOR_IN
42919: IFFALSE 43072
// begin if not b [ j ] then
42921: LD_VAR 0 6
42925: PUSH
42926: LD_VAR 0 3
42930: ARRAY
42931: NOT
42932: IFFALSE 42936
// break ;
42934: GO 43072
// e := 0 ;
42936: LD_ADDR_VAR 0 7
42940: PUSH
42941: LD_INT 0
42943: ST_TO_ADDR
// for k in b [ j ] do
42944: LD_ADDR_VAR 0 8
42948: PUSH
42949: LD_VAR 0 6
42953: PUSH
42954: LD_VAR 0 3
42958: ARRAY
42959: PUSH
42960: FOR_IN
42961: IFFALSE 42988
// if IsNotFull ( k ) then
42963: LD_VAR 0 8
42967: PPUSH
42968: CALL 71242 0 1
42972: IFFALSE 42986
// begin e := k ;
42974: LD_ADDR_VAR 0 7
42978: PUSH
42979: LD_VAR 0 8
42983: ST_TO_ADDR
// break ;
42984: GO 42988
// end ;
42986: GO 42960
42988: POP
42989: POP
// if e and not UnitGoingToBuilding ( p , e ) then
42990: LD_VAR 0 7
42994: PUSH
42995: LD_VAR 0 5
42999: PPUSH
43000: LD_VAR 0 7
43004: PPUSH
43005: CALL 105392 0 2
43009: NOT
43010: AND
43011: IFFALSE 43070
// begin if IsInUnit ( p ) then
43013: LD_VAR 0 5
43017: PPUSH
43018: CALL_OW 310
43022: IFFALSE 43033
// ComExitBuilding ( p ) ;
43024: LD_VAR 0 5
43028: PPUSH
43029: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43033: LD_VAR 0 5
43037: PPUSH
43038: LD_VAR 0 7
43042: PPUSH
43043: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43047: LD_VAR 0 5
43051: PPUSH
43052: LD_VAR 0 3
43056: PPUSH
43057: CALL_OW 183
// AddComExitBuilding ( p ) ;
43061: LD_VAR 0 5
43065: PPUSH
43066: CALL_OW 182
// end ; end ;
43070: GO 42918
43072: POP
43073: POP
// end ;
43074: GO 42884
43076: POP
43077: POP
// end ;
43078: GO 42648
43080: POP
43081: POP
// end ;
43082: LD_VAR 0 1
43086: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43087: LD_INT 0
43089: PPUSH
43090: PPUSH
43091: PPUSH
43092: PPUSH
43093: PPUSH
43094: PPUSH
43095: PPUSH
43096: PPUSH
43097: PPUSH
43098: PPUSH
43099: PPUSH
43100: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43101: LD_ADDR_VAR 0 2
43105: PUSH
43106: LD_INT 0
43108: PUSH
43109: LD_INT 0
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: LD_INT 0
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: LIST
43122: LIST
43123: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43124: LD_VAR 0 1
43128: NOT
43129: PUSH
43130: LD_EXP 101
43134: PUSH
43135: LD_VAR 0 1
43139: ARRAY
43140: NOT
43141: OR
43142: PUSH
43143: LD_EXP 101
43147: PUSH
43148: LD_VAR 0 1
43152: ARRAY
43153: PPUSH
43154: LD_INT 2
43156: PUSH
43157: LD_INT 30
43159: PUSH
43160: LD_INT 0
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 30
43169: PUSH
43170: LD_INT 1
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: PPUSH
43182: CALL_OW 72
43186: NOT
43187: OR
43188: IFFALSE 43192
// exit ;
43190: GO 46695
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43192: LD_ADDR_VAR 0 4
43196: PUSH
43197: LD_EXP 101
43201: PUSH
43202: LD_VAR 0 1
43206: ARRAY
43207: PPUSH
43208: LD_INT 2
43210: PUSH
43211: LD_INT 25
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 25
43223: PUSH
43224: LD_INT 2
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 25
43233: PUSH
43234: LD_INT 3
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 25
43243: PUSH
43244: LD_INT 4
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 25
43253: PUSH
43254: LD_INT 5
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 25
43263: PUSH
43264: LD_INT 8
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 25
43273: PUSH
43274: LD_INT 9
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: LIST
43285: LIST
43286: LIST
43287: LIST
43288: LIST
43289: LIST
43290: PPUSH
43291: CALL_OW 72
43295: ST_TO_ADDR
// if not tmp then
43296: LD_VAR 0 4
43300: NOT
43301: IFFALSE 43305
// exit ;
43303: GO 46695
// for i in tmp do
43305: LD_ADDR_VAR 0 3
43309: PUSH
43310: LD_VAR 0 4
43314: PUSH
43315: FOR_IN
43316: IFFALSE 43347
// if GetTag ( i ) then
43318: LD_VAR 0 3
43322: PPUSH
43323: CALL_OW 110
43327: IFFALSE 43345
// tmp := tmp diff i ;
43329: LD_ADDR_VAR 0 4
43333: PUSH
43334: LD_VAR 0 4
43338: PUSH
43339: LD_VAR 0 3
43343: DIFF
43344: ST_TO_ADDR
43345: GO 43315
43347: POP
43348: POP
// if not tmp then
43349: LD_VAR 0 4
43353: NOT
43354: IFFALSE 43358
// exit ;
43356: GO 46695
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43358: LD_ADDR_VAR 0 5
43362: PUSH
43363: LD_EXP 101
43367: PUSH
43368: LD_VAR 0 1
43372: ARRAY
43373: PPUSH
43374: LD_INT 2
43376: PUSH
43377: LD_INT 25
43379: PUSH
43380: LD_INT 1
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 25
43389: PUSH
43390: LD_INT 5
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 25
43399: PUSH
43400: LD_INT 8
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: PUSH
43407: LD_INT 25
43409: PUSH
43410: LD_INT 9
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: PPUSH
43424: CALL_OW 72
43428: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43429: LD_ADDR_VAR 0 6
43433: PUSH
43434: LD_EXP 101
43438: PUSH
43439: LD_VAR 0 1
43443: ARRAY
43444: PPUSH
43445: LD_INT 25
43447: PUSH
43448: LD_INT 2
43450: PUSH
43451: EMPTY
43452: LIST
43453: LIST
43454: PPUSH
43455: CALL_OW 72
43459: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43460: LD_ADDR_VAR 0 7
43464: PUSH
43465: LD_EXP 101
43469: PUSH
43470: LD_VAR 0 1
43474: ARRAY
43475: PPUSH
43476: LD_INT 25
43478: PUSH
43479: LD_INT 3
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PPUSH
43486: CALL_OW 72
43490: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43491: LD_ADDR_VAR 0 8
43495: PUSH
43496: LD_EXP 101
43500: PUSH
43501: LD_VAR 0 1
43505: ARRAY
43506: PPUSH
43507: LD_INT 25
43509: PUSH
43510: LD_INT 4
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PUSH
43517: LD_INT 24
43519: PUSH
43520: LD_INT 251
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PPUSH
43531: CALL_OW 72
43535: ST_TO_ADDR
// if mc_is_defending [ base ] then
43536: LD_EXP 144
43540: PUSH
43541: LD_VAR 0 1
43545: ARRAY
43546: IFFALSE 44007
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43548: LD_ADDR_EXP 143
43552: PUSH
43553: LD_EXP 143
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_INT 4
43565: PPUSH
43566: CALL_OW 1
43570: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43571: LD_ADDR_VAR 0 12
43575: PUSH
43576: LD_EXP 101
43580: PUSH
43581: LD_VAR 0 1
43585: ARRAY
43586: PPUSH
43587: LD_INT 2
43589: PUSH
43590: LD_INT 30
43592: PUSH
43593: LD_INT 4
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 30
43602: PUSH
43603: LD_INT 5
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: LIST
43614: PPUSH
43615: CALL_OW 72
43619: ST_TO_ADDR
// if not b then
43620: LD_VAR 0 12
43624: NOT
43625: IFFALSE 43629
// exit ;
43627: GO 46695
// p := [ ] ;
43629: LD_ADDR_VAR 0 11
43633: PUSH
43634: EMPTY
43635: ST_TO_ADDR
// if sci >= 2 then
43636: LD_VAR 0 8
43640: PUSH
43641: LD_INT 2
43643: GREATEREQUAL
43644: IFFALSE 43675
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
43646: LD_ADDR_VAR 0 8
43650: PUSH
43651: LD_VAR 0 8
43655: PUSH
43656: LD_INT 1
43658: ARRAY
43659: PUSH
43660: LD_VAR 0 8
43664: PUSH
43665: LD_INT 2
43667: ARRAY
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: ST_TO_ADDR
43673: GO 43736
// if sci = 1 then
43675: LD_VAR 0 8
43679: PUSH
43680: LD_INT 1
43682: EQUAL
43683: IFFALSE 43704
// sci := [ sci [ 1 ] ] else
43685: LD_ADDR_VAR 0 8
43689: PUSH
43690: LD_VAR 0 8
43694: PUSH
43695: LD_INT 1
43697: ARRAY
43698: PUSH
43699: EMPTY
43700: LIST
43701: ST_TO_ADDR
43702: GO 43736
// if sci = 0 then
43704: LD_VAR 0 8
43708: PUSH
43709: LD_INT 0
43711: EQUAL
43712: IFFALSE 43736
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
43714: LD_ADDR_VAR 0 11
43718: PUSH
43719: LD_VAR 0 4
43723: PPUSH
43724: LD_INT 4
43726: PPUSH
43727: CALL 105264 0 2
43731: PUSH
43732: LD_INT 1
43734: ARRAY
43735: ST_TO_ADDR
// if eng > 4 then
43736: LD_VAR 0 6
43740: PUSH
43741: LD_INT 4
43743: GREATER
43744: IFFALSE 43790
// for i = eng downto 4 do
43746: LD_ADDR_VAR 0 3
43750: PUSH
43751: DOUBLE
43752: LD_VAR 0 6
43756: INC
43757: ST_TO_ADDR
43758: LD_INT 4
43760: PUSH
43761: FOR_DOWNTO
43762: IFFALSE 43788
// eng := eng diff eng [ i ] ;
43764: LD_ADDR_VAR 0 6
43768: PUSH
43769: LD_VAR 0 6
43773: PUSH
43774: LD_VAR 0 6
43778: PUSH
43779: LD_VAR 0 3
43783: ARRAY
43784: DIFF
43785: ST_TO_ADDR
43786: GO 43761
43788: POP
43789: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
43790: LD_ADDR_VAR 0 4
43794: PUSH
43795: LD_VAR 0 4
43799: PUSH
43800: LD_VAR 0 5
43804: PUSH
43805: LD_VAR 0 6
43809: UNION
43810: PUSH
43811: LD_VAR 0 7
43815: UNION
43816: PUSH
43817: LD_VAR 0 8
43821: UNION
43822: DIFF
43823: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
43824: LD_ADDR_VAR 0 13
43828: PUSH
43829: LD_EXP 101
43833: PUSH
43834: LD_VAR 0 1
43838: ARRAY
43839: PPUSH
43840: LD_INT 2
43842: PUSH
43843: LD_INT 30
43845: PUSH
43846: LD_INT 32
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 30
43855: PUSH
43856: LD_INT 31
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: LIST
43867: PPUSH
43868: CALL_OW 72
43872: PUSH
43873: LD_EXP 101
43877: PUSH
43878: LD_VAR 0 1
43882: ARRAY
43883: PPUSH
43884: LD_INT 2
43886: PUSH
43887: LD_INT 30
43889: PUSH
43890: LD_INT 4
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 30
43899: PUSH
43900: LD_INT 5
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: LIST
43911: PPUSH
43912: CALL_OW 72
43916: PUSH
43917: LD_INT 6
43919: MUL
43920: PLUS
43921: ST_TO_ADDR
// if bcount < tmp then
43922: LD_VAR 0 13
43926: PUSH
43927: LD_VAR 0 4
43931: LESS
43932: IFFALSE 43978
// for i = tmp downto bcount do
43934: LD_ADDR_VAR 0 3
43938: PUSH
43939: DOUBLE
43940: LD_VAR 0 4
43944: INC
43945: ST_TO_ADDR
43946: LD_VAR 0 13
43950: PUSH
43951: FOR_DOWNTO
43952: IFFALSE 43976
// tmp := Delete ( tmp , tmp ) ;
43954: LD_ADDR_VAR 0 4
43958: PUSH
43959: LD_VAR 0 4
43963: PPUSH
43964: LD_VAR 0 4
43968: PPUSH
43969: CALL_OW 3
43973: ST_TO_ADDR
43974: GO 43951
43976: POP
43977: POP
// result := [ tmp , 0 , 0 , p ] ;
43978: LD_ADDR_VAR 0 2
43982: PUSH
43983: LD_VAR 0 4
43987: PUSH
43988: LD_INT 0
43990: PUSH
43991: LD_INT 0
43993: PUSH
43994: LD_VAR 0 11
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: ST_TO_ADDR
// exit ;
44005: GO 46695
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44007: LD_EXP 101
44011: PUSH
44012: LD_VAR 0 1
44016: ARRAY
44017: PPUSH
44018: LD_INT 2
44020: PUSH
44021: LD_INT 30
44023: PUSH
44024: LD_INT 6
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 30
44033: PUSH
44034: LD_INT 7
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 30
44043: PUSH
44044: LD_INT 8
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: PPUSH
44057: CALL_OW 72
44061: NOT
44062: PUSH
44063: LD_EXP 101
44067: PUSH
44068: LD_VAR 0 1
44072: ARRAY
44073: PPUSH
44074: LD_INT 30
44076: PUSH
44077: LD_INT 3
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PPUSH
44084: CALL_OW 72
44088: NOT
44089: AND
44090: IFFALSE 44162
// begin if eng = tmp then
44092: LD_VAR 0 6
44096: PUSH
44097: LD_VAR 0 4
44101: EQUAL
44102: IFFALSE 44106
// exit ;
44104: GO 46695
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44106: LD_ADDR_EXP 143
44110: PUSH
44111: LD_EXP 143
44115: PPUSH
44116: LD_VAR 0 1
44120: PPUSH
44121: LD_INT 1
44123: PPUSH
44124: CALL_OW 1
44128: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44129: LD_ADDR_VAR 0 2
44133: PUSH
44134: LD_INT 0
44136: PUSH
44137: LD_VAR 0 4
44141: PUSH
44142: LD_VAR 0 6
44146: DIFF
44147: PUSH
44148: LD_INT 0
44150: PUSH
44151: LD_INT 0
44153: PUSH
44154: EMPTY
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: ST_TO_ADDR
// exit ;
44160: GO 46695
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44162: LD_EXP 128
44166: PUSH
44167: LD_EXP 127
44171: PUSH
44172: LD_VAR 0 1
44176: ARRAY
44177: ARRAY
44178: PUSH
44179: LD_EXP 101
44183: PUSH
44184: LD_VAR 0 1
44188: ARRAY
44189: PPUSH
44190: LD_INT 2
44192: PUSH
44193: LD_INT 30
44195: PUSH
44196: LD_INT 6
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 30
44205: PUSH
44206: LD_INT 7
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: LD_INT 30
44215: PUSH
44216: LD_INT 8
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: LIST
44227: LIST
44228: PPUSH
44229: CALL_OW 72
44233: AND
44234: PUSH
44235: LD_EXP 101
44239: PUSH
44240: LD_VAR 0 1
44244: ARRAY
44245: PPUSH
44246: LD_INT 30
44248: PUSH
44249: LD_INT 3
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PPUSH
44256: CALL_OW 72
44260: NOT
44261: AND
44262: IFFALSE 44476
// begin if sci >= 6 then
44264: LD_VAR 0 8
44268: PUSH
44269: LD_INT 6
44271: GREATEREQUAL
44272: IFFALSE 44276
// exit ;
44274: GO 46695
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44276: LD_ADDR_EXP 143
44280: PUSH
44281: LD_EXP 143
44285: PPUSH
44286: LD_VAR 0 1
44290: PPUSH
44291: LD_INT 2
44293: PPUSH
44294: CALL_OW 1
44298: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44299: LD_ADDR_VAR 0 9
44303: PUSH
44304: LD_VAR 0 4
44308: PUSH
44309: LD_VAR 0 8
44313: DIFF
44314: PPUSH
44315: LD_INT 4
44317: PPUSH
44318: CALL 105264 0 2
44322: ST_TO_ADDR
// p := [ ] ;
44323: LD_ADDR_VAR 0 11
44327: PUSH
44328: EMPTY
44329: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44330: LD_VAR 0 8
44334: PUSH
44335: LD_INT 6
44337: LESS
44338: PUSH
44339: LD_VAR 0 9
44343: PUSH
44344: LD_INT 6
44346: GREATER
44347: AND
44348: IFFALSE 44429
// begin for i = 1 to 6 - sci do
44350: LD_ADDR_VAR 0 3
44354: PUSH
44355: DOUBLE
44356: LD_INT 1
44358: DEC
44359: ST_TO_ADDR
44360: LD_INT 6
44362: PUSH
44363: LD_VAR 0 8
44367: MINUS
44368: PUSH
44369: FOR_TO
44370: IFFALSE 44425
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44372: LD_ADDR_VAR 0 11
44376: PUSH
44377: LD_VAR 0 11
44381: PPUSH
44382: LD_VAR 0 11
44386: PUSH
44387: LD_INT 1
44389: PLUS
44390: PPUSH
44391: LD_VAR 0 9
44395: PUSH
44396: LD_INT 1
44398: ARRAY
44399: PPUSH
44400: CALL_OW 2
44404: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44405: LD_ADDR_VAR 0 9
44409: PUSH
44410: LD_VAR 0 9
44414: PPUSH
44415: LD_INT 1
44417: PPUSH
44418: CALL_OW 3
44422: ST_TO_ADDR
// end ;
44423: GO 44369
44425: POP
44426: POP
// end else
44427: GO 44449
// if sort then
44429: LD_VAR 0 9
44433: IFFALSE 44449
// p := sort [ 1 ] ;
44435: LD_ADDR_VAR 0 11
44439: PUSH
44440: LD_VAR 0 9
44444: PUSH
44445: LD_INT 1
44447: ARRAY
44448: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44449: LD_ADDR_VAR 0 2
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: LD_INT 0
44459: PUSH
44460: LD_INT 0
44462: PUSH
44463: LD_VAR 0 11
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: ST_TO_ADDR
// exit ;
44474: GO 46695
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44476: LD_EXP 128
44480: PUSH
44481: LD_EXP 127
44485: PUSH
44486: LD_VAR 0 1
44490: ARRAY
44491: ARRAY
44492: PUSH
44493: LD_EXP 101
44497: PUSH
44498: LD_VAR 0 1
44502: ARRAY
44503: PPUSH
44504: LD_INT 2
44506: PUSH
44507: LD_INT 30
44509: PUSH
44510: LD_INT 6
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 30
44519: PUSH
44520: LD_INT 7
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 30
44529: PUSH
44530: LD_INT 8
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: PPUSH
44543: CALL_OW 72
44547: AND
44548: PUSH
44549: LD_EXP 101
44553: PUSH
44554: LD_VAR 0 1
44558: ARRAY
44559: PPUSH
44560: LD_INT 30
44562: PUSH
44563: LD_INT 3
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PPUSH
44570: CALL_OW 72
44574: AND
44575: IFFALSE 45309
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44577: LD_ADDR_EXP 143
44581: PUSH
44582: LD_EXP 143
44586: PPUSH
44587: LD_VAR 0 1
44591: PPUSH
44592: LD_INT 3
44594: PPUSH
44595: CALL_OW 1
44599: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44600: LD_ADDR_VAR 0 2
44604: PUSH
44605: LD_INT 0
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: LD_INT 0
44613: PUSH
44614: LD_INT 0
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: ST_TO_ADDR
// if not eng then
44623: LD_VAR 0 6
44627: NOT
44628: IFFALSE 44691
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
44630: LD_ADDR_VAR 0 11
44634: PUSH
44635: LD_VAR 0 4
44639: PPUSH
44640: LD_INT 2
44642: PPUSH
44643: CALL 105264 0 2
44647: PUSH
44648: LD_INT 1
44650: ARRAY
44651: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
44652: LD_ADDR_VAR 0 2
44656: PUSH
44657: LD_VAR 0 2
44661: PPUSH
44662: LD_INT 2
44664: PPUSH
44665: LD_VAR 0 11
44669: PPUSH
44670: CALL_OW 1
44674: ST_TO_ADDR
// tmp := tmp diff p ;
44675: LD_ADDR_VAR 0 4
44679: PUSH
44680: LD_VAR 0 4
44684: PUSH
44685: LD_VAR 0 11
44689: DIFF
44690: ST_TO_ADDR
// end ; if tmp and sci < 6 then
44691: LD_VAR 0 4
44695: PUSH
44696: LD_VAR 0 8
44700: PUSH
44701: LD_INT 6
44703: LESS
44704: AND
44705: IFFALSE 44893
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
44707: LD_ADDR_VAR 0 9
44711: PUSH
44712: LD_VAR 0 4
44716: PUSH
44717: LD_VAR 0 8
44721: PUSH
44722: LD_VAR 0 7
44726: UNION
44727: DIFF
44728: PPUSH
44729: LD_INT 4
44731: PPUSH
44732: CALL 105264 0 2
44736: ST_TO_ADDR
// p := [ ] ;
44737: LD_ADDR_VAR 0 11
44741: PUSH
44742: EMPTY
44743: ST_TO_ADDR
// if sort then
44744: LD_VAR 0 9
44748: IFFALSE 44864
// for i = 1 to 6 - sci do
44750: LD_ADDR_VAR 0 3
44754: PUSH
44755: DOUBLE
44756: LD_INT 1
44758: DEC
44759: ST_TO_ADDR
44760: LD_INT 6
44762: PUSH
44763: LD_VAR 0 8
44767: MINUS
44768: PUSH
44769: FOR_TO
44770: IFFALSE 44862
// begin if i = sort then
44772: LD_VAR 0 3
44776: PUSH
44777: LD_VAR 0 9
44781: EQUAL
44782: IFFALSE 44786
// break ;
44784: GO 44862
// if GetClass ( i ) = 4 then
44786: LD_VAR 0 3
44790: PPUSH
44791: CALL_OW 257
44795: PUSH
44796: LD_INT 4
44798: EQUAL
44799: IFFALSE 44803
// continue ;
44801: GO 44769
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44803: LD_ADDR_VAR 0 11
44807: PUSH
44808: LD_VAR 0 11
44812: PPUSH
44813: LD_VAR 0 11
44817: PUSH
44818: LD_INT 1
44820: PLUS
44821: PPUSH
44822: LD_VAR 0 9
44826: PUSH
44827: LD_VAR 0 3
44831: ARRAY
44832: PPUSH
44833: CALL_OW 2
44837: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44838: LD_ADDR_VAR 0 4
44842: PUSH
44843: LD_VAR 0 4
44847: PUSH
44848: LD_VAR 0 9
44852: PUSH
44853: LD_VAR 0 3
44857: ARRAY
44858: DIFF
44859: ST_TO_ADDR
// end ;
44860: GO 44769
44862: POP
44863: POP
// if p then
44864: LD_VAR 0 11
44868: IFFALSE 44893
// result := Replace ( result , 4 , p ) ;
44870: LD_ADDR_VAR 0 2
44874: PUSH
44875: LD_VAR 0 2
44879: PPUSH
44880: LD_INT 4
44882: PPUSH
44883: LD_VAR 0 11
44887: PPUSH
44888: CALL_OW 1
44892: ST_TO_ADDR
// end ; if tmp and mech < 6 then
44893: LD_VAR 0 4
44897: PUSH
44898: LD_VAR 0 7
44902: PUSH
44903: LD_INT 6
44905: LESS
44906: AND
44907: IFFALSE 45095
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44909: LD_ADDR_VAR 0 9
44913: PUSH
44914: LD_VAR 0 4
44918: PUSH
44919: LD_VAR 0 8
44923: PUSH
44924: LD_VAR 0 7
44928: UNION
44929: DIFF
44930: PPUSH
44931: LD_INT 3
44933: PPUSH
44934: CALL 105264 0 2
44938: ST_TO_ADDR
// p := [ ] ;
44939: LD_ADDR_VAR 0 11
44943: PUSH
44944: EMPTY
44945: ST_TO_ADDR
// if sort then
44946: LD_VAR 0 9
44950: IFFALSE 45066
// for i = 1 to 6 - mech do
44952: LD_ADDR_VAR 0 3
44956: PUSH
44957: DOUBLE
44958: LD_INT 1
44960: DEC
44961: ST_TO_ADDR
44962: LD_INT 6
44964: PUSH
44965: LD_VAR 0 7
44969: MINUS
44970: PUSH
44971: FOR_TO
44972: IFFALSE 45064
// begin if i = sort then
44974: LD_VAR 0 3
44978: PUSH
44979: LD_VAR 0 9
44983: EQUAL
44984: IFFALSE 44988
// break ;
44986: GO 45064
// if GetClass ( i ) = 3 then
44988: LD_VAR 0 3
44992: PPUSH
44993: CALL_OW 257
44997: PUSH
44998: LD_INT 3
45000: EQUAL
45001: IFFALSE 45005
// continue ;
45003: GO 44971
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45005: LD_ADDR_VAR 0 11
45009: PUSH
45010: LD_VAR 0 11
45014: PPUSH
45015: LD_VAR 0 11
45019: PUSH
45020: LD_INT 1
45022: PLUS
45023: PPUSH
45024: LD_VAR 0 9
45028: PUSH
45029: LD_VAR 0 3
45033: ARRAY
45034: PPUSH
45035: CALL_OW 2
45039: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45040: LD_ADDR_VAR 0 4
45044: PUSH
45045: LD_VAR 0 4
45049: PUSH
45050: LD_VAR 0 9
45054: PUSH
45055: LD_VAR 0 3
45059: ARRAY
45060: DIFF
45061: ST_TO_ADDR
// end ;
45062: GO 44971
45064: POP
45065: POP
// if p then
45066: LD_VAR 0 11
45070: IFFALSE 45095
// result := Replace ( result , 3 , p ) ;
45072: LD_ADDR_VAR 0 2
45076: PUSH
45077: LD_VAR 0 2
45081: PPUSH
45082: LD_INT 3
45084: PPUSH
45085: LD_VAR 0 11
45089: PPUSH
45090: CALL_OW 1
45094: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45095: LD_VAR 0 4
45099: PUSH
45100: LD_INT 6
45102: GREATER
45103: PUSH
45104: LD_VAR 0 6
45108: PUSH
45109: LD_INT 6
45111: LESS
45112: AND
45113: IFFALSE 45307
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45115: LD_ADDR_VAR 0 9
45119: PUSH
45120: LD_VAR 0 4
45124: PUSH
45125: LD_VAR 0 8
45129: PUSH
45130: LD_VAR 0 7
45134: UNION
45135: PUSH
45136: LD_VAR 0 6
45140: UNION
45141: DIFF
45142: PPUSH
45143: LD_INT 2
45145: PPUSH
45146: CALL 105264 0 2
45150: ST_TO_ADDR
// p := [ ] ;
45151: LD_ADDR_VAR 0 11
45155: PUSH
45156: EMPTY
45157: ST_TO_ADDR
// if sort then
45158: LD_VAR 0 9
45162: IFFALSE 45278
// for i = 1 to 6 - eng do
45164: LD_ADDR_VAR 0 3
45168: PUSH
45169: DOUBLE
45170: LD_INT 1
45172: DEC
45173: ST_TO_ADDR
45174: LD_INT 6
45176: PUSH
45177: LD_VAR 0 6
45181: MINUS
45182: PUSH
45183: FOR_TO
45184: IFFALSE 45276
// begin if i = sort then
45186: LD_VAR 0 3
45190: PUSH
45191: LD_VAR 0 9
45195: EQUAL
45196: IFFALSE 45200
// break ;
45198: GO 45276
// if GetClass ( i ) = 2 then
45200: LD_VAR 0 3
45204: PPUSH
45205: CALL_OW 257
45209: PUSH
45210: LD_INT 2
45212: EQUAL
45213: IFFALSE 45217
// continue ;
45215: GO 45183
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45217: LD_ADDR_VAR 0 11
45221: PUSH
45222: LD_VAR 0 11
45226: PPUSH
45227: LD_VAR 0 11
45231: PUSH
45232: LD_INT 1
45234: PLUS
45235: PPUSH
45236: LD_VAR 0 9
45240: PUSH
45241: LD_VAR 0 3
45245: ARRAY
45246: PPUSH
45247: CALL_OW 2
45251: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45252: LD_ADDR_VAR 0 4
45256: PUSH
45257: LD_VAR 0 4
45261: PUSH
45262: LD_VAR 0 9
45266: PUSH
45267: LD_VAR 0 3
45271: ARRAY
45272: DIFF
45273: ST_TO_ADDR
// end ;
45274: GO 45183
45276: POP
45277: POP
// if p then
45278: LD_VAR 0 11
45282: IFFALSE 45307
// result := Replace ( result , 2 , p ) ;
45284: LD_ADDR_VAR 0 2
45288: PUSH
45289: LD_VAR 0 2
45293: PPUSH
45294: LD_INT 2
45296: PPUSH
45297: LD_VAR 0 11
45301: PPUSH
45302: CALL_OW 1
45306: ST_TO_ADDR
// end ; exit ;
45307: GO 46695
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45309: LD_EXP 128
45313: PUSH
45314: LD_EXP 127
45318: PUSH
45319: LD_VAR 0 1
45323: ARRAY
45324: ARRAY
45325: NOT
45326: PUSH
45327: LD_EXP 101
45331: PUSH
45332: LD_VAR 0 1
45336: ARRAY
45337: PPUSH
45338: LD_INT 30
45340: PUSH
45341: LD_INT 3
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PPUSH
45348: CALL_OW 72
45352: AND
45353: PUSH
45354: LD_EXP 106
45358: PUSH
45359: LD_VAR 0 1
45363: ARRAY
45364: AND
45365: IFFALSE 45973
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45367: LD_ADDR_EXP 143
45371: PUSH
45372: LD_EXP 143
45376: PPUSH
45377: LD_VAR 0 1
45381: PPUSH
45382: LD_INT 5
45384: PPUSH
45385: CALL_OW 1
45389: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45390: LD_ADDR_VAR 0 2
45394: PUSH
45395: LD_INT 0
45397: PUSH
45398: LD_INT 0
45400: PUSH
45401: LD_INT 0
45403: PUSH
45404: LD_INT 0
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: ST_TO_ADDR
// if sci > 1 then
45413: LD_VAR 0 8
45417: PUSH
45418: LD_INT 1
45420: GREATER
45421: IFFALSE 45449
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45423: LD_ADDR_VAR 0 4
45427: PUSH
45428: LD_VAR 0 4
45432: PUSH
45433: LD_VAR 0 8
45437: PUSH
45438: LD_VAR 0 8
45442: PUSH
45443: LD_INT 1
45445: ARRAY
45446: DIFF
45447: DIFF
45448: ST_TO_ADDR
// if tmp and not sci then
45449: LD_VAR 0 4
45453: PUSH
45454: LD_VAR 0 8
45458: NOT
45459: AND
45460: IFFALSE 45529
// begin sort := SortBySkill ( tmp , 4 ) ;
45462: LD_ADDR_VAR 0 9
45466: PUSH
45467: LD_VAR 0 4
45471: PPUSH
45472: LD_INT 4
45474: PPUSH
45475: CALL 105264 0 2
45479: ST_TO_ADDR
// if sort then
45480: LD_VAR 0 9
45484: IFFALSE 45500
// p := sort [ 1 ] ;
45486: LD_ADDR_VAR 0 11
45490: PUSH
45491: LD_VAR 0 9
45495: PUSH
45496: LD_INT 1
45498: ARRAY
45499: ST_TO_ADDR
// if p then
45500: LD_VAR 0 11
45504: IFFALSE 45529
// result := Replace ( result , 4 , p ) ;
45506: LD_ADDR_VAR 0 2
45510: PUSH
45511: LD_VAR 0 2
45515: PPUSH
45516: LD_INT 4
45518: PPUSH
45519: LD_VAR 0 11
45523: PPUSH
45524: CALL_OW 1
45528: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45529: LD_ADDR_VAR 0 4
45533: PUSH
45534: LD_VAR 0 4
45538: PUSH
45539: LD_VAR 0 7
45543: DIFF
45544: ST_TO_ADDR
// if tmp and mech < 6 then
45545: LD_VAR 0 4
45549: PUSH
45550: LD_VAR 0 7
45554: PUSH
45555: LD_INT 6
45557: LESS
45558: AND
45559: IFFALSE 45747
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45561: LD_ADDR_VAR 0 9
45565: PUSH
45566: LD_VAR 0 4
45570: PUSH
45571: LD_VAR 0 8
45575: PUSH
45576: LD_VAR 0 7
45580: UNION
45581: DIFF
45582: PPUSH
45583: LD_INT 3
45585: PPUSH
45586: CALL 105264 0 2
45590: ST_TO_ADDR
// p := [ ] ;
45591: LD_ADDR_VAR 0 11
45595: PUSH
45596: EMPTY
45597: ST_TO_ADDR
// if sort then
45598: LD_VAR 0 9
45602: IFFALSE 45718
// for i = 1 to 6 - mech do
45604: LD_ADDR_VAR 0 3
45608: PUSH
45609: DOUBLE
45610: LD_INT 1
45612: DEC
45613: ST_TO_ADDR
45614: LD_INT 6
45616: PUSH
45617: LD_VAR 0 7
45621: MINUS
45622: PUSH
45623: FOR_TO
45624: IFFALSE 45716
// begin if i = sort then
45626: LD_VAR 0 3
45630: PUSH
45631: LD_VAR 0 9
45635: EQUAL
45636: IFFALSE 45640
// break ;
45638: GO 45716
// if GetClass ( i ) = 3 then
45640: LD_VAR 0 3
45644: PPUSH
45645: CALL_OW 257
45649: PUSH
45650: LD_INT 3
45652: EQUAL
45653: IFFALSE 45657
// continue ;
45655: GO 45623
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45657: LD_ADDR_VAR 0 11
45661: PUSH
45662: LD_VAR 0 11
45666: PPUSH
45667: LD_VAR 0 11
45671: PUSH
45672: LD_INT 1
45674: PLUS
45675: PPUSH
45676: LD_VAR 0 9
45680: PUSH
45681: LD_VAR 0 3
45685: ARRAY
45686: PPUSH
45687: CALL_OW 2
45691: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45692: LD_ADDR_VAR 0 4
45696: PUSH
45697: LD_VAR 0 4
45701: PUSH
45702: LD_VAR 0 9
45706: PUSH
45707: LD_VAR 0 3
45711: ARRAY
45712: DIFF
45713: ST_TO_ADDR
// end ;
45714: GO 45623
45716: POP
45717: POP
// if p then
45718: LD_VAR 0 11
45722: IFFALSE 45747
// result := Replace ( result , 3 , p ) ;
45724: LD_ADDR_VAR 0 2
45728: PUSH
45729: LD_VAR 0 2
45733: PPUSH
45734: LD_INT 3
45736: PPUSH
45737: LD_VAR 0 11
45741: PPUSH
45742: CALL_OW 1
45746: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45747: LD_ADDR_VAR 0 4
45751: PUSH
45752: LD_VAR 0 4
45756: PUSH
45757: LD_VAR 0 6
45761: DIFF
45762: ST_TO_ADDR
// if tmp and eng < 6 then
45763: LD_VAR 0 4
45767: PUSH
45768: LD_VAR 0 6
45772: PUSH
45773: LD_INT 6
45775: LESS
45776: AND
45777: IFFALSE 45971
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45779: LD_ADDR_VAR 0 9
45783: PUSH
45784: LD_VAR 0 4
45788: PUSH
45789: LD_VAR 0 8
45793: PUSH
45794: LD_VAR 0 7
45798: UNION
45799: PUSH
45800: LD_VAR 0 6
45804: UNION
45805: DIFF
45806: PPUSH
45807: LD_INT 2
45809: PPUSH
45810: CALL 105264 0 2
45814: ST_TO_ADDR
// p := [ ] ;
45815: LD_ADDR_VAR 0 11
45819: PUSH
45820: EMPTY
45821: ST_TO_ADDR
// if sort then
45822: LD_VAR 0 9
45826: IFFALSE 45942
// for i = 1 to 6 - eng do
45828: LD_ADDR_VAR 0 3
45832: PUSH
45833: DOUBLE
45834: LD_INT 1
45836: DEC
45837: ST_TO_ADDR
45838: LD_INT 6
45840: PUSH
45841: LD_VAR 0 6
45845: MINUS
45846: PUSH
45847: FOR_TO
45848: IFFALSE 45940
// begin if i = sort then
45850: LD_VAR 0 3
45854: PUSH
45855: LD_VAR 0 9
45859: EQUAL
45860: IFFALSE 45864
// break ;
45862: GO 45940
// if GetClass ( i ) = 2 then
45864: LD_VAR 0 3
45868: PPUSH
45869: CALL_OW 257
45873: PUSH
45874: LD_INT 2
45876: EQUAL
45877: IFFALSE 45881
// continue ;
45879: GO 45847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45881: LD_ADDR_VAR 0 11
45885: PUSH
45886: LD_VAR 0 11
45890: PPUSH
45891: LD_VAR 0 11
45895: PUSH
45896: LD_INT 1
45898: PLUS
45899: PPUSH
45900: LD_VAR 0 9
45904: PUSH
45905: LD_VAR 0 3
45909: ARRAY
45910: PPUSH
45911: CALL_OW 2
45915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45916: LD_ADDR_VAR 0 4
45920: PUSH
45921: LD_VAR 0 4
45925: PUSH
45926: LD_VAR 0 9
45930: PUSH
45931: LD_VAR 0 3
45935: ARRAY
45936: DIFF
45937: ST_TO_ADDR
// end ;
45938: GO 45847
45940: POP
45941: POP
// if p then
45942: LD_VAR 0 11
45946: IFFALSE 45971
// result := Replace ( result , 2 , p ) ;
45948: LD_ADDR_VAR 0 2
45952: PUSH
45953: LD_VAR 0 2
45957: PPUSH
45958: LD_INT 2
45960: PPUSH
45961: LD_VAR 0 11
45965: PPUSH
45966: CALL_OW 1
45970: ST_TO_ADDR
// end ; exit ;
45971: GO 46695
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
45973: LD_EXP 128
45977: PUSH
45978: LD_EXP 127
45982: PUSH
45983: LD_VAR 0 1
45987: ARRAY
45988: ARRAY
45989: NOT
45990: PUSH
45991: LD_EXP 101
45995: PUSH
45996: LD_VAR 0 1
46000: ARRAY
46001: PPUSH
46002: LD_INT 30
46004: PUSH
46005: LD_INT 3
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: PPUSH
46012: CALL_OW 72
46016: AND
46017: PUSH
46018: LD_EXP 106
46022: PUSH
46023: LD_VAR 0 1
46027: ARRAY
46028: NOT
46029: AND
46030: IFFALSE 46695
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46032: LD_ADDR_EXP 143
46036: PUSH
46037: LD_EXP 143
46041: PPUSH
46042: LD_VAR 0 1
46046: PPUSH
46047: LD_INT 6
46049: PPUSH
46050: CALL_OW 1
46054: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46055: LD_ADDR_VAR 0 2
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 0
46065: PUSH
46066: LD_INT 0
46068: PUSH
46069: LD_INT 0
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: ST_TO_ADDR
// if sci >= 1 then
46078: LD_VAR 0 8
46082: PUSH
46083: LD_INT 1
46085: GREATEREQUAL
46086: IFFALSE 46108
// tmp := tmp diff sci [ 1 ] ;
46088: LD_ADDR_VAR 0 4
46092: PUSH
46093: LD_VAR 0 4
46097: PUSH
46098: LD_VAR 0 8
46102: PUSH
46103: LD_INT 1
46105: ARRAY
46106: DIFF
46107: ST_TO_ADDR
// if tmp and not sci then
46108: LD_VAR 0 4
46112: PUSH
46113: LD_VAR 0 8
46117: NOT
46118: AND
46119: IFFALSE 46188
// begin sort := SortBySkill ( tmp , 4 ) ;
46121: LD_ADDR_VAR 0 9
46125: PUSH
46126: LD_VAR 0 4
46130: PPUSH
46131: LD_INT 4
46133: PPUSH
46134: CALL 105264 0 2
46138: ST_TO_ADDR
// if sort then
46139: LD_VAR 0 9
46143: IFFALSE 46159
// p := sort [ 1 ] ;
46145: LD_ADDR_VAR 0 11
46149: PUSH
46150: LD_VAR 0 9
46154: PUSH
46155: LD_INT 1
46157: ARRAY
46158: ST_TO_ADDR
// if p then
46159: LD_VAR 0 11
46163: IFFALSE 46188
// result := Replace ( result , 4 , p ) ;
46165: LD_ADDR_VAR 0 2
46169: PUSH
46170: LD_VAR 0 2
46174: PPUSH
46175: LD_INT 4
46177: PPUSH
46178: LD_VAR 0 11
46182: PPUSH
46183: CALL_OW 1
46187: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46188: LD_ADDR_VAR 0 4
46192: PUSH
46193: LD_VAR 0 4
46197: PUSH
46198: LD_VAR 0 7
46202: DIFF
46203: ST_TO_ADDR
// if tmp and mech < 6 then
46204: LD_VAR 0 4
46208: PUSH
46209: LD_VAR 0 7
46213: PUSH
46214: LD_INT 6
46216: LESS
46217: AND
46218: IFFALSE 46400
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46220: LD_ADDR_VAR 0 9
46224: PUSH
46225: LD_VAR 0 4
46229: PUSH
46230: LD_VAR 0 7
46234: DIFF
46235: PPUSH
46236: LD_INT 3
46238: PPUSH
46239: CALL 105264 0 2
46243: ST_TO_ADDR
// p := [ ] ;
46244: LD_ADDR_VAR 0 11
46248: PUSH
46249: EMPTY
46250: ST_TO_ADDR
// if sort then
46251: LD_VAR 0 9
46255: IFFALSE 46371
// for i = 1 to 6 - mech do
46257: LD_ADDR_VAR 0 3
46261: PUSH
46262: DOUBLE
46263: LD_INT 1
46265: DEC
46266: ST_TO_ADDR
46267: LD_INT 6
46269: PUSH
46270: LD_VAR 0 7
46274: MINUS
46275: PUSH
46276: FOR_TO
46277: IFFALSE 46369
// begin if i = sort then
46279: LD_VAR 0 3
46283: PUSH
46284: LD_VAR 0 9
46288: EQUAL
46289: IFFALSE 46293
// break ;
46291: GO 46369
// if GetClass ( i ) = 3 then
46293: LD_VAR 0 3
46297: PPUSH
46298: CALL_OW 257
46302: PUSH
46303: LD_INT 3
46305: EQUAL
46306: IFFALSE 46310
// continue ;
46308: GO 46276
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46310: LD_ADDR_VAR 0 11
46314: PUSH
46315: LD_VAR 0 11
46319: PPUSH
46320: LD_VAR 0 11
46324: PUSH
46325: LD_INT 1
46327: PLUS
46328: PPUSH
46329: LD_VAR 0 9
46333: PUSH
46334: LD_VAR 0 3
46338: ARRAY
46339: PPUSH
46340: CALL_OW 2
46344: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46345: LD_ADDR_VAR 0 4
46349: PUSH
46350: LD_VAR 0 4
46354: PUSH
46355: LD_VAR 0 9
46359: PUSH
46360: LD_VAR 0 3
46364: ARRAY
46365: DIFF
46366: ST_TO_ADDR
// end ;
46367: GO 46276
46369: POP
46370: POP
// if p then
46371: LD_VAR 0 11
46375: IFFALSE 46400
// result := Replace ( result , 3 , p ) ;
46377: LD_ADDR_VAR 0 2
46381: PUSH
46382: LD_VAR 0 2
46386: PPUSH
46387: LD_INT 3
46389: PPUSH
46390: LD_VAR 0 11
46394: PPUSH
46395: CALL_OW 1
46399: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46400: LD_ADDR_VAR 0 4
46404: PUSH
46405: LD_VAR 0 4
46409: PUSH
46410: LD_VAR 0 6
46414: DIFF
46415: ST_TO_ADDR
// if tmp and eng < 4 then
46416: LD_VAR 0 4
46420: PUSH
46421: LD_VAR 0 6
46425: PUSH
46426: LD_INT 4
46428: LESS
46429: AND
46430: IFFALSE 46620
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46432: LD_ADDR_VAR 0 9
46436: PUSH
46437: LD_VAR 0 4
46441: PUSH
46442: LD_VAR 0 7
46446: PUSH
46447: LD_VAR 0 6
46451: UNION
46452: DIFF
46453: PPUSH
46454: LD_INT 2
46456: PPUSH
46457: CALL 105264 0 2
46461: ST_TO_ADDR
// p := [ ] ;
46462: LD_ADDR_VAR 0 11
46466: PUSH
46467: EMPTY
46468: ST_TO_ADDR
// if sort then
46469: LD_VAR 0 9
46473: IFFALSE 46589
// for i = 1 to 4 - eng do
46475: LD_ADDR_VAR 0 3
46479: PUSH
46480: DOUBLE
46481: LD_INT 1
46483: DEC
46484: ST_TO_ADDR
46485: LD_INT 4
46487: PUSH
46488: LD_VAR 0 6
46492: MINUS
46493: PUSH
46494: FOR_TO
46495: IFFALSE 46587
// begin if i = sort then
46497: LD_VAR 0 3
46501: PUSH
46502: LD_VAR 0 9
46506: EQUAL
46507: IFFALSE 46511
// break ;
46509: GO 46587
// if GetClass ( i ) = 2 then
46511: LD_VAR 0 3
46515: PPUSH
46516: CALL_OW 257
46520: PUSH
46521: LD_INT 2
46523: EQUAL
46524: IFFALSE 46528
// continue ;
46526: GO 46494
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46528: LD_ADDR_VAR 0 11
46532: PUSH
46533: LD_VAR 0 11
46537: PPUSH
46538: LD_VAR 0 11
46542: PUSH
46543: LD_INT 1
46545: PLUS
46546: PPUSH
46547: LD_VAR 0 9
46551: PUSH
46552: LD_VAR 0 3
46556: ARRAY
46557: PPUSH
46558: CALL_OW 2
46562: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46563: LD_ADDR_VAR 0 4
46567: PUSH
46568: LD_VAR 0 4
46572: PUSH
46573: LD_VAR 0 9
46577: PUSH
46578: LD_VAR 0 3
46582: ARRAY
46583: DIFF
46584: ST_TO_ADDR
// end ;
46585: GO 46494
46587: POP
46588: POP
// if p then
46589: LD_VAR 0 11
46593: IFFALSE 46618
// result := Replace ( result , 2 , p ) ;
46595: LD_ADDR_VAR 0 2
46599: PUSH
46600: LD_VAR 0 2
46604: PPUSH
46605: LD_INT 2
46607: PPUSH
46608: LD_VAR 0 11
46612: PPUSH
46613: CALL_OW 1
46617: ST_TO_ADDR
// end else
46618: GO 46664
// for i = eng downto 5 do
46620: LD_ADDR_VAR 0 3
46624: PUSH
46625: DOUBLE
46626: LD_VAR 0 6
46630: INC
46631: ST_TO_ADDR
46632: LD_INT 5
46634: PUSH
46635: FOR_DOWNTO
46636: IFFALSE 46662
// tmp := tmp union eng [ i ] ;
46638: LD_ADDR_VAR 0 4
46642: PUSH
46643: LD_VAR 0 4
46647: PUSH
46648: LD_VAR 0 6
46652: PUSH
46653: LD_VAR 0 3
46657: ARRAY
46658: UNION
46659: ST_TO_ADDR
46660: GO 46635
46662: POP
46663: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
46664: LD_ADDR_VAR 0 2
46668: PUSH
46669: LD_VAR 0 2
46673: PPUSH
46674: LD_INT 1
46676: PPUSH
46677: LD_VAR 0 4
46681: PUSH
46682: LD_VAR 0 5
46686: DIFF
46687: PPUSH
46688: CALL_OW 1
46692: ST_TO_ADDR
// exit ;
46693: GO 46695
// end ; end ;
46695: LD_VAR 0 2
46699: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
46700: LD_INT 0
46702: PPUSH
46703: PPUSH
46704: PPUSH
// if not mc_bases then
46705: LD_EXP 101
46709: NOT
46710: IFFALSE 46714
// exit ;
46712: GO 46856
// for i = 1 to mc_bases do
46714: LD_ADDR_VAR 0 2
46718: PUSH
46719: DOUBLE
46720: LD_INT 1
46722: DEC
46723: ST_TO_ADDR
46724: LD_EXP 101
46728: PUSH
46729: FOR_TO
46730: IFFALSE 46847
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
46732: LD_ADDR_VAR 0 3
46736: PUSH
46737: LD_EXP 101
46741: PUSH
46742: LD_VAR 0 2
46746: ARRAY
46747: PPUSH
46748: LD_INT 21
46750: PUSH
46751: LD_INT 3
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 3
46760: PUSH
46761: LD_INT 2
46763: PUSH
46764: LD_INT 30
46766: PUSH
46767: LD_INT 29
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PUSH
46774: LD_INT 30
46776: PUSH
46777: LD_INT 30
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PUSH
46784: EMPTY
46785: LIST
46786: LIST
46787: LIST
46788: PUSH
46789: EMPTY
46790: LIST
46791: LIST
46792: PUSH
46793: LD_INT 3
46795: PUSH
46796: LD_INT 24
46798: PUSH
46799: LD_INT 1000
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: LIST
46814: PPUSH
46815: CALL_OW 72
46819: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
46820: LD_ADDR_EXP 102
46824: PUSH
46825: LD_EXP 102
46829: PPUSH
46830: LD_VAR 0 2
46834: PPUSH
46835: LD_VAR 0 3
46839: PPUSH
46840: CALL_OW 1
46844: ST_TO_ADDR
// end ;
46845: GO 46729
46847: POP
46848: POP
// RaiseSailEvent ( 101 ) ;
46849: LD_INT 101
46851: PPUSH
46852: CALL_OW 427
// end ;
46856: LD_VAR 0 1
46860: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
46861: LD_INT 0
46863: PPUSH
46864: PPUSH
46865: PPUSH
46866: PPUSH
46867: PPUSH
46868: PPUSH
46869: PPUSH
// if not mc_bases then
46870: LD_EXP 101
46874: NOT
46875: IFFALSE 46879
// exit ;
46877: GO 47441
// for i = 1 to mc_bases do
46879: LD_ADDR_VAR 0 2
46883: PUSH
46884: DOUBLE
46885: LD_INT 1
46887: DEC
46888: ST_TO_ADDR
46889: LD_EXP 101
46893: PUSH
46894: FOR_TO
46895: IFFALSE 47432
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
46897: LD_ADDR_VAR 0 5
46901: PUSH
46902: LD_EXP 101
46906: PUSH
46907: LD_VAR 0 2
46911: ARRAY
46912: PUSH
46913: LD_EXP 130
46917: PUSH
46918: LD_VAR 0 2
46922: ARRAY
46923: UNION
46924: PPUSH
46925: LD_INT 21
46927: PUSH
46928: LD_INT 1
46930: PUSH
46931: EMPTY
46932: LIST
46933: LIST
46934: PUSH
46935: LD_INT 1
46937: PUSH
46938: LD_INT 3
46940: PUSH
46941: LD_INT 54
46943: PUSH
46944: EMPTY
46945: LIST
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PUSH
46951: LD_INT 3
46953: PUSH
46954: LD_INT 24
46956: PUSH
46957: LD_INT 1000
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: LIST
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PPUSH
46977: CALL_OW 72
46981: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
46982: LD_ADDR_VAR 0 6
46986: PUSH
46987: LD_EXP 101
46991: PUSH
46992: LD_VAR 0 2
46996: ARRAY
46997: PPUSH
46998: LD_INT 21
47000: PUSH
47001: LD_INT 1
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: PUSH
47008: LD_INT 1
47010: PUSH
47011: LD_INT 3
47013: PUSH
47014: LD_INT 54
47016: PUSH
47017: EMPTY
47018: LIST
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: LD_INT 3
47026: PUSH
47027: LD_INT 24
47029: PUSH
47030: LD_INT 250
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: LIST
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: PPUSH
47050: CALL_OW 72
47054: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47055: LD_ADDR_VAR 0 7
47059: PUSH
47060: LD_VAR 0 5
47064: PUSH
47065: LD_VAR 0 6
47069: DIFF
47070: ST_TO_ADDR
// if not need_heal_1 then
47071: LD_VAR 0 6
47075: NOT
47076: IFFALSE 47109
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47078: LD_ADDR_EXP 104
47082: PUSH
47083: LD_EXP 104
47087: PPUSH
47088: LD_VAR 0 2
47092: PUSH
47093: LD_INT 1
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: PPUSH
47100: EMPTY
47101: PPUSH
47102: CALL 74020 0 3
47106: ST_TO_ADDR
47107: GO 47179
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47109: LD_ADDR_EXP 104
47113: PUSH
47114: LD_EXP 104
47118: PPUSH
47119: LD_VAR 0 2
47123: PUSH
47124: LD_INT 1
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: PPUSH
47131: LD_EXP 104
47135: PUSH
47136: LD_VAR 0 2
47140: ARRAY
47141: PUSH
47142: LD_INT 1
47144: ARRAY
47145: PPUSH
47146: LD_INT 3
47148: PUSH
47149: LD_INT 24
47151: PUSH
47152: LD_INT 1000
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: PUSH
47159: EMPTY
47160: LIST
47161: LIST
47162: PPUSH
47163: CALL_OW 72
47167: PUSH
47168: LD_VAR 0 6
47172: UNION
47173: PPUSH
47174: CALL 74020 0 3
47178: ST_TO_ADDR
// if not need_heal_2 then
47179: LD_VAR 0 7
47183: NOT
47184: IFFALSE 47217
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47186: LD_ADDR_EXP 104
47190: PUSH
47191: LD_EXP 104
47195: PPUSH
47196: LD_VAR 0 2
47200: PUSH
47201: LD_INT 2
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PPUSH
47208: EMPTY
47209: PPUSH
47210: CALL 74020 0 3
47214: ST_TO_ADDR
47215: GO 47249
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47217: LD_ADDR_EXP 104
47221: PUSH
47222: LD_EXP 104
47226: PPUSH
47227: LD_VAR 0 2
47231: PUSH
47232: LD_INT 2
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PPUSH
47239: LD_VAR 0 7
47243: PPUSH
47244: CALL 74020 0 3
47248: ST_TO_ADDR
// if need_heal_2 then
47249: LD_VAR 0 7
47253: IFFALSE 47414
// for j in need_heal_2 do
47255: LD_ADDR_VAR 0 3
47259: PUSH
47260: LD_VAR 0 7
47264: PUSH
47265: FOR_IN
47266: IFFALSE 47412
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47268: LD_ADDR_VAR 0 5
47272: PUSH
47273: LD_EXP 101
47277: PUSH
47278: LD_VAR 0 2
47282: ARRAY
47283: PPUSH
47284: LD_INT 2
47286: PUSH
47287: LD_INT 30
47289: PUSH
47290: LD_INT 6
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: LD_INT 30
47299: PUSH
47300: LD_INT 7
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 30
47309: PUSH
47310: LD_INT 8
47312: PUSH
47313: EMPTY
47314: LIST
47315: LIST
47316: PUSH
47317: LD_INT 30
47319: PUSH
47320: LD_INT 0
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: PUSH
47327: LD_INT 30
47329: PUSH
47330: LD_INT 1
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: EMPTY
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: PPUSH
47345: CALL_OW 72
47349: ST_TO_ADDR
// if tmp then
47350: LD_VAR 0 5
47354: IFFALSE 47410
// begin k := NearestUnitToUnit ( tmp , j ) ;
47356: LD_ADDR_VAR 0 4
47360: PUSH
47361: LD_VAR 0 5
47365: PPUSH
47366: LD_VAR 0 3
47370: PPUSH
47371: CALL_OW 74
47375: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47376: LD_VAR 0 3
47380: PPUSH
47381: LD_VAR 0 4
47385: PPUSH
47386: CALL_OW 296
47390: PUSH
47391: LD_INT 5
47393: GREATER
47394: IFFALSE 47410
// ComMoveToNearbyEntrance ( j , k ) ;
47396: LD_VAR 0 3
47400: PPUSH
47401: LD_VAR 0 4
47405: PPUSH
47406: CALL 107637 0 2
// end ; end ;
47410: GO 47265
47412: POP
47413: POP
// if not need_heal_1 and not need_heal_2 then
47414: LD_VAR 0 6
47418: NOT
47419: PUSH
47420: LD_VAR 0 7
47424: NOT
47425: AND
47426: IFFALSE 47430
// continue ;
47428: GO 46894
// end ;
47430: GO 46894
47432: POP
47433: POP
// RaiseSailEvent ( 102 ) ;
47434: LD_INT 102
47436: PPUSH
47437: CALL_OW 427
// end ;
47441: LD_VAR 0 1
47445: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47446: LD_INT 0
47448: PPUSH
47449: PPUSH
47450: PPUSH
47451: PPUSH
47452: PPUSH
47453: PPUSH
47454: PPUSH
47455: PPUSH
// if not mc_bases then
47456: LD_EXP 101
47460: NOT
47461: IFFALSE 47465
// exit ;
47463: GO 48376
// for i = 1 to mc_bases do
47465: LD_ADDR_VAR 0 2
47469: PUSH
47470: DOUBLE
47471: LD_INT 1
47473: DEC
47474: ST_TO_ADDR
47475: LD_EXP 101
47479: PUSH
47480: FOR_TO
47481: IFFALSE 48374
// begin if not mc_building_need_repair [ i ] then
47483: LD_EXP 102
47487: PUSH
47488: LD_VAR 0 2
47492: ARRAY
47493: NOT
47494: IFFALSE 47679
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47496: LD_ADDR_VAR 0 6
47500: PUSH
47501: LD_EXP 120
47505: PUSH
47506: LD_VAR 0 2
47510: ARRAY
47511: PPUSH
47512: LD_INT 3
47514: PUSH
47515: LD_INT 24
47517: PUSH
47518: LD_INT 1000
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: PUSH
47529: LD_INT 2
47531: PUSH
47532: LD_INT 34
47534: PUSH
47535: LD_INT 13
47537: PUSH
47538: EMPTY
47539: LIST
47540: LIST
47541: PUSH
47542: LD_INT 34
47544: PUSH
47545: LD_INT 52
47547: PUSH
47548: EMPTY
47549: LIST
47550: LIST
47551: PUSH
47552: LD_INT 34
47554: PUSH
47555: LD_INT 88
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PPUSH
47572: CALL_OW 72
47576: ST_TO_ADDR
// if cranes then
47577: LD_VAR 0 6
47581: IFFALSE 47643
// for j in cranes do
47583: LD_ADDR_VAR 0 3
47587: PUSH
47588: LD_VAR 0 6
47592: PUSH
47593: FOR_IN
47594: IFFALSE 47641
// if not IsInArea ( j , mc_parking [ i ] ) then
47596: LD_VAR 0 3
47600: PPUSH
47601: LD_EXP 125
47605: PUSH
47606: LD_VAR 0 2
47610: ARRAY
47611: PPUSH
47612: CALL_OW 308
47616: NOT
47617: IFFALSE 47639
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47619: LD_VAR 0 3
47623: PPUSH
47624: LD_EXP 125
47628: PUSH
47629: LD_VAR 0 2
47633: ARRAY
47634: PPUSH
47635: CALL_OW 113
47639: GO 47593
47641: POP
47642: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
47643: LD_ADDR_EXP 103
47647: PUSH
47648: LD_EXP 103
47652: PPUSH
47653: LD_VAR 0 2
47657: PPUSH
47658: EMPTY
47659: PPUSH
47660: CALL_OW 1
47664: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
47665: LD_VAR 0 2
47669: PPUSH
47670: LD_INT 101
47672: PPUSH
47673: CALL 42519 0 2
// continue ;
47677: GO 47480
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
47679: LD_ADDR_EXP 107
47683: PUSH
47684: LD_EXP 107
47688: PPUSH
47689: LD_VAR 0 2
47693: PPUSH
47694: EMPTY
47695: PPUSH
47696: CALL_OW 1
47700: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47701: LD_VAR 0 2
47705: PPUSH
47706: LD_INT 103
47708: PPUSH
47709: CALL 42519 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
47713: LD_ADDR_VAR 0 5
47717: PUSH
47718: LD_EXP 101
47722: PUSH
47723: LD_VAR 0 2
47727: ARRAY
47728: PUSH
47729: LD_EXP 130
47733: PUSH
47734: LD_VAR 0 2
47738: ARRAY
47739: UNION
47740: PPUSH
47741: LD_INT 2
47743: PUSH
47744: LD_INT 25
47746: PUSH
47747: LD_INT 2
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PUSH
47754: LD_INT 25
47756: PUSH
47757: LD_INT 16
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: LIST
47768: PUSH
47769: EMPTY
47770: LIST
47771: PPUSH
47772: CALL_OW 72
47776: ST_TO_ADDR
// if mc_need_heal [ i ] then
47777: LD_EXP 104
47781: PUSH
47782: LD_VAR 0 2
47786: ARRAY
47787: IFFALSE 47831
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
47789: LD_ADDR_VAR 0 5
47793: PUSH
47794: LD_VAR 0 5
47798: PUSH
47799: LD_EXP 104
47803: PUSH
47804: LD_VAR 0 2
47808: ARRAY
47809: PUSH
47810: LD_INT 1
47812: ARRAY
47813: PUSH
47814: LD_EXP 104
47818: PUSH
47819: LD_VAR 0 2
47823: ARRAY
47824: PUSH
47825: LD_INT 2
47827: ARRAY
47828: UNION
47829: DIFF
47830: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
47831: LD_ADDR_VAR 0 6
47835: PUSH
47836: LD_EXP 120
47840: PUSH
47841: LD_VAR 0 2
47845: ARRAY
47846: PPUSH
47847: LD_INT 2
47849: PUSH
47850: LD_INT 34
47852: PUSH
47853: LD_INT 13
47855: PUSH
47856: EMPTY
47857: LIST
47858: LIST
47859: PUSH
47860: LD_INT 34
47862: PUSH
47863: LD_INT 52
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: PUSH
47870: LD_INT 34
47872: PUSH
47873: LD_INT 88
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PPUSH
47886: CALL_OW 72
47890: ST_TO_ADDR
// if cranes then
47891: LD_VAR 0 6
47895: IFFALSE 48063
// begin for j in cranes do
47897: LD_ADDR_VAR 0 3
47901: PUSH
47902: LD_VAR 0 6
47906: PUSH
47907: FOR_IN
47908: IFFALSE 48061
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
47910: LD_VAR 0 3
47914: PPUSH
47915: CALL_OW 256
47919: PUSH
47920: LD_INT 1000
47922: EQUAL
47923: PUSH
47924: LD_VAR 0 3
47928: PPUSH
47929: CALL_OW 314
47933: NOT
47934: AND
47935: IFFALSE 48001
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
47937: LD_ADDR_VAR 0 8
47941: PUSH
47942: LD_EXP 102
47946: PUSH
47947: LD_VAR 0 2
47951: ARRAY
47952: PPUSH
47953: LD_VAR 0 3
47957: PPUSH
47958: CALL_OW 74
47962: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
47963: LD_VAR 0 8
47967: PPUSH
47968: LD_INT 16
47970: PPUSH
47971: CALL 76985 0 2
47975: PUSH
47976: LD_INT 4
47978: ARRAY
47979: PUSH
47980: LD_INT 10
47982: LESS
47983: IFFALSE 47999
// ComRepairBuilding ( j , to_repair ) ;
47985: LD_VAR 0 3
47989: PPUSH
47990: LD_VAR 0 8
47994: PPUSH
47995: CALL_OW 130
// end else
47999: GO 48059
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48001: LD_VAR 0 3
48005: PPUSH
48006: CALL_OW 256
48010: PUSH
48011: LD_INT 500
48013: LESS
48014: PUSH
48015: LD_VAR 0 3
48019: PPUSH
48020: LD_EXP 125
48024: PUSH
48025: LD_VAR 0 2
48029: ARRAY
48030: PPUSH
48031: CALL_OW 308
48035: NOT
48036: AND
48037: IFFALSE 48059
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48039: LD_VAR 0 3
48043: PPUSH
48044: LD_EXP 125
48048: PUSH
48049: LD_VAR 0 2
48053: ARRAY
48054: PPUSH
48055: CALL_OW 113
// end ;
48059: GO 47907
48061: POP
48062: POP
// end ; if tmp > 3 then
48063: LD_VAR 0 5
48067: PUSH
48068: LD_INT 3
48070: GREATER
48071: IFFALSE 48091
// tmp := ShrinkArray ( tmp , 4 ) ;
48073: LD_ADDR_VAR 0 5
48077: PUSH
48078: LD_VAR 0 5
48082: PPUSH
48083: LD_INT 4
48085: PPUSH
48086: CALL 107075 0 2
48090: ST_TO_ADDR
// if not tmp then
48091: LD_VAR 0 5
48095: NOT
48096: IFFALSE 48100
// continue ;
48098: GO 47480
// for j in tmp do
48100: LD_ADDR_VAR 0 3
48104: PUSH
48105: LD_VAR 0 5
48109: PUSH
48110: FOR_IN
48111: IFFALSE 48370
// begin if IsInUnit ( j ) then
48113: LD_VAR 0 3
48117: PPUSH
48118: CALL_OW 310
48122: IFFALSE 48133
// ComExitBuilding ( j ) ;
48124: LD_VAR 0 3
48128: PPUSH
48129: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48133: LD_VAR 0 3
48137: PUSH
48138: LD_EXP 103
48142: PUSH
48143: LD_VAR 0 2
48147: ARRAY
48148: IN
48149: NOT
48150: IFFALSE 48208
// begin SetTag ( j , 101 ) ;
48152: LD_VAR 0 3
48156: PPUSH
48157: LD_INT 101
48159: PPUSH
48160: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48164: LD_ADDR_EXP 103
48168: PUSH
48169: LD_EXP 103
48173: PPUSH
48174: LD_VAR 0 2
48178: PUSH
48179: LD_EXP 103
48183: PUSH
48184: LD_VAR 0 2
48188: ARRAY
48189: PUSH
48190: LD_INT 1
48192: PLUS
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PPUSH
48198: LD_VAR 0 3
48202: PPUSH
48203: CALL 74020 0 3
48207: ST_TO_ADDR
// end ; wait ( 1 ) ;
48208: LD_INT 1
48210: PPUSH
48211: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48215: LD_ADDR_VAR 0 7
48219: PUSH
48220: LD_EXP 102
48224: PUSH
48225: LD_VAR 0 2
48229: ARRAY
48230: ST_TO_ADDR
// if mc_scan [ i ] then
48231: LD_EXP 124
48235: PUSH
48236: LD_VAR 0 2
48240: ARRAY
48241: IFFALSE 48303
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48243: LD_ADDR_VAR 0 7
48247: PUSH
48248: LD_EXP 102
48252: PUSH
48253: LD_VAR 0 2
48257: ARRAY
48258: PPUSH
48259: LD_INT 3
48261: PUSH
48262: LD_INT 30
48264: PUSH
48265: LD_INT 32
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: PUSH
48272: LD_INT 30
48274: PUSH
48275: LD_INT 33
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: PUSH
48282: LD_INT 30
48284: PUSH
48285: LD_INT 31
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: PUSH
48292: EMPTY
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: PPUSH
48298: CALL_OW 72
48302: ST_TO_ADDR
// if not to_repair_tmp then
48303: LD_VAR 0 7
48307: NOT
48308: IFFALSE 48312
// continue ;
48310: GO 48110
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48312: LD_ADDR_VAR 0 8
48316: PUSH
48317: LD_VAR 0 7
48321: PPUSH
48322: LD_VAR 0 3
48326: PPUSH
48327: CALL_OW 74
48331: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48332: LD_VAR 0 8
48336: PPUSH
48337: LD_INT 16
48339: PPUSH
48340: CALL 76985 0 2
48344: PUSH
48345: LD_INT 4
48347: ARRAY
48348: PUSH
48349: LD_INT 14
48351: LESS
48352: IFFALSE 48368
// ComRepairBuilding ( j , to_repair ) ;
48354: LD_VAR 0 3
48358: PPUSH
48359: LD_VAR 0 8
48363: PPUSH
48364: CALL_OW 130
// end ;
48368: GO 48110
48370: POP
48371: POP
// end ;
48372: GO 47480
48374: POP
48375: POP
// end ;
48376: LD_VAR 0 1
48380: RET
// export function MC_Heal ; var i , j , tmp ; begin
48381: LD_INT 0
48383: PPUSH
48384: PPUSH
48385: PPUSH
48386: PPUSH
// if not mc_bases then
48387: LD_EXP 101
48391: NOT
48392: IFFALSE 48396
// exit ;
48394: GO 48798
// for i = 1 to mc_bases do
48396: LD_ADDR_VAR 0 2
48400: PUSH
48401: DOUBLE
48402: LD_INT 1
48404: DEC
48405: ST_TO_ADDR
48406: LD_EXP 101
48410: PUSH
48411: FOR_TO
48412: IFFALSE 48796
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48414: LD_EXP 104
48418: PUSH
48419: LD_VAR 0 2
48423: ARRAY
48424: PUSH
48425: LD_INT 1
48427: ARRAY
48428: NOT
48429: PUSH
48430: LD_EXP 104
48434: PUSH
48435: LD_VAR 0 2
48439: ARRAY
48440: PUSH
48441: LD_INT 2
48443: ARRAY
48444: NOT
48445: AND
48446: IFFALSE 48484
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48448: LD_ADDR_EXP 105
48452: PUSH
48453: LD_EXP 105
48457: PPUSH
48458: LD_VAR 0 2
48462: PPUSH
48463: EMPTY
48464: PPUSH
48465: CALL_OW 1
48469: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48470: LD_VAR 0 2
48474: PPUSH
48475: LD_INT 102
48477: PPUSH
48478: CALL 42519 0 2
// continue ;
48482: GO 48411
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48484: LD_ADDR_VAR 0 4
48488: PUSH
48489: LD_EXP 101
48493: PUSH
48494: LD_VAR 0 2
48498: ARRAY
48499: PPUSH
48500: LD_INT 25
48502: PUSH
48503: LD_INT 4
48505: PUSH
48506: EMPTY
48507: LIST
48508: LIST
48509: PPUSH
48510: CALL_OW 72
48514: ST_TO_ADDR
// if not tmp then
48515: LD_VAR 0 4
48519: NOT
48520: IFFALSE 48524
// continue ;
48522: GO 48411
// if mc_taming [ i ] then
48524: LD_EXP 132
48528: PUSH
48529: LD_VAR 0 2
48533: ARRAY
48534: IFFALSE 48558
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48536: LD_ADDR_EXP 132
48540: PUSH
48541: LD_EXP 132
48545: PPUSH
48546: LD_VAR 0 2
48550: PPUSH
48551: EMPTY
48552: PPUSH
48553: CALL_OW 1
48557: ST_TO_ADDR
// for j in tmp do
48558: LD_ADDR_VAR 0 3
48562: PUSH
48563: LD_VAR 0 4
48567: PUSH
48568: FOR_IN
48569: IFFALSE 48792
// begin if IsInUnit ( j ) then
48571: LD_VAR 0 3
48575: PPUSH
48576: CALL_OW 310
48580: IFFALSE 48591
// ComExitBuilding ( j ) ;
48582: LD_VAR 0 3
48586: PPUSH
48587: CALL_OW 122
// if not j in mc_healers [ i ] then
48591: LD_VAR 0 3
48595: PUSH
48596: LD_EXP 105
48600: PUSH
48601: LD_VAR 0 2
48605: ARRAY
48606: IN
48607: NOT
48608: IFFALSE 48654
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48610: LD_ADDR_EXP 105
48614: PUSH
48615: LD_EXP 105
48619: PPUSH
48620: LD_VAR 0 2
48624: PUSH
48625: LD_EXP 105
48629: PUSH
48630: LD_VAR 0 2
48634: ARRAY
48635: PUSH
48636: LD_INT 1
48638: PLUS
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PPUSH
48644: LD_VAR 0 3
48648: PPUSH
48649: CALL 74020 0 3
48653: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
48654: LD_VAR 0 3
48658: PPUSH
48659: CALL_OW 110
48663: PUSH
48664: LD_INT 102
48666: NONEQUAL
48667: IFFALSE 48681
// SetTag ( j , 102 ) ;
48669: LD_VAR 0 3
48673: PPUSH
48674: LD_INT 102
48676: PPUSH
48677: CALL_OW 109
// Wait ( 3 ) ;
48681: LD_INT 3
48683: PPUSH
48684: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
48688: LD_EXP 104
48692: PUSH
48693: LD_VAR 0 2
48697: ARRAY
48698: PUSH
48699: LD_INT 1
48701: ARRAY
48702: IFFALSE 48734
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
48704: LD_VAR 0 3
48708: PPUSH
48709: LD_EXP 104
48713: PUSH
48714: LD_VAR 0 2
48718: ARRAY
48719: PUSH
48720: LD_INT 1
48722: ARRAY
48723: PUSH
48724: LD_INT 1
48726: ARRAY
48727: PPUSH
48728: CALL_OW 128
48732: GO 48790
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
48734: LD_VAR 0 3
48738: PPUSH
48739: CALL_OW 314
48743: NOT
48744: PUSH
48745: LD_EXP 104
48749: PUSH
48750: LD_VAR 0 2
48754: ARRAY
48755: PUSH
48756: LD_INT 2
48758: ARRAY
48759: AND
48760: IFFALSE 48790
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
48762: LD_VAR 0 3
48766: PPUSH
48767: LD_EXP 104
48771: PUSH
48772: LD_VAR 0 2
48776: ARRAY
48777: PUSH
48778: LD_INT 2
48780: ARRAY
48781: PUSH
48782: LD_INT 1
48784: ARRAY
48785: PPUSH
48786: CALL_OW 128
// end ;
48790: GO 48568
48792: POP
48793: POP
// end ;
48794: GO 48411
48796: POP
48797: POP
// end ;
48798: LD_VAR 0 1
48802: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
48803: LD_INT 0
48805: PPUSH
48806: PPUSH
48807: PPUSH
48808: PPUSH
48809: PPUSH
48810: PPUSH
// if not mc_bases then
48811: LD_EXP 101
48815: NOT
48816: IFFALSE 48820
// exit ;
48818: GO 49983
// for i = 1 to mc_bases do
48820: LD_ADDR_VAR 0 2
48824: PUSH
48825: DOUBLE
48826: LD_INT 1
48828: DEC
48829: ST_TO_ADDR
48830: LD_EXP 101
48834: PUSH
48835: FOR_TO
48836: IFFALSE 49981
// begin if mc_scan [ i ] then
48838: LD_EXP 124
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: IFFALSE 48852
// continue ;
48850: GO 48835
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
48852: LD_EXP 106
48856: PUSH
48857: LD_VAR 0 2
48861: ARRAY
48862: NOT
48863: PUSH
48864: LD_EXP 108
48868: PUSH
48869: LD_VAR 0 2
48873: ARRAY
48874: NOT
48875: AND
48876: PUSH
48877: LD_EXP 107
48881: PUSH
48882: LD_VAR 0 2
48886: ARRAY
48887: AND
48888: IFFALSE 48926
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
48890: LD_ADDR_EXP 107
48894: PUSH
48895: LD_EXP 107
48899: PPUSH
48900: LD_VAR 0 2
48904: PPUSH
48905: EMPTY
48906: PPUSH
48907: CALL_OW 1
48911: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48912: LD_VAR 0 2
48916: PPUSH
48917: LD_INT 103
48919: PPUSH
48920: CALL 42519 0 2
// continue ;
48924: GO 48835
// end ; if mc_construct_list [ i ] then
48926: LD_EXP 108
48930: PUSH
48931: LD_VAR 0 2
48935: ARRAY
48936: IFFALSE 49156
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48938: LD_ADDR_VAR 0 5
48942: PUSH
48943: LD_EXP 101
48947: PUSH
48948: LD_VAR 0 2
48952: ARRAY
48953: PPUSH
48954: LD_INT 25
48956: PUSH
48957: LD_INT 2
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PPUSH
48964: CALL_OW 72
48968: PUSH
48969: LD_EXP 103
48973: PUSH
48974: LD_VAR 0 2
48978: ARRAY
48979: DIFF
48980: ST_TO_ADDR
// if not tmp then
48981: LD_VAR 0 5
48985: NOT
48986: IFFALSE 48990
// continue ;
48988: GO 48835
// for j in tmp do
48990: LD_ADDR_VAR 0 3
48994: PUSH
48995: LD_VAR 0 5
48999: PUSH
49000: FOR_IN
49001: IFFALSE 49152
// begin if not mc_builders [ i ] then
49003: LD_EXP 107
49007: PUSH
49008: LD_VAR 0 2
49012: ARRAY
49013: NOT
49014: IFFALSE 49072
// begin SetTag ( j , 103 ) ;
49016: LD_VAR 0 3
49020: PPUSH
49021: LD_INT 103
49023: PPUSH
49024: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49028: LD_ADDR_EXP 107
49032: PUSH
49033: LD_EXP 107
49037: PPUSH
49038: LD_VAR 0 2
49042: PUSH
49043: LD_EXP 107
49047: PUSH
49048: LD_VAR 0 2
49052: ARRAY
49053: PUSH
49054: LD_INT 1
49056: PLUS
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PPUSH
49062: LD_VAR 0 3
49066: PPUSH
49067: CALL 74020 0 3
49071: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49072: LD_VAR 0 3
49076: PPUSH
49077: CALL_OW 310
49081: IFFALSE 49092
// ComExitBuilding ( j ) ;
49083: LD_VAR 0 3
49087: PPUSH
49088: CALL_OW 122
// wait ( 3 ) ;
49092: LD_INT 3
49094: PPUSH
49095: CALL_OW 67
// if not mc_construct_list [ i ] then
49099: LD_EXP 108
49103: PUSH
49104: LD_VAR 0 2
49108: ARRAY
49109: NOT
49110: IFFALSE 49114
// break ;
49112: GO 49152
// if not HasTask ( j ) then
49114: LD_VAR 0 3
49118: PPUSH
49119: CALL_OW 314
49123: NOT
49124: IFFALSE 49150
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49126: LD_VAR 0 3
49130: PPUSH
49131: LD_EXP 108
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: PUSH
49142: LD_INT 1
49144: ARRAY
49145: PPUSH
49146: CALL 77258 0 2
// end ;
49150: GO 49000
49152: POP
49153: POP
// end else
49154: GO 49979
// if mc_build_list [ i ] then
49156: LD_EXP 106
49160: PUSH
49161: LD_VAR 0 2
49165: ARRAY
49166: IFFALSE 49979
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49168: LD_EXP 106
49172: PUSH
49173: LD_VAR 0 2
49177: ARRAY
49178: PUSH
49179: LD_INT 1
49181: ARRAY
49182: PUSH
49183: LD_INT 1
49185: ARRAY
49186: PPUSH
49187: CALL 77082 0 1
49191: PUSH
49192: LD_EXP 101
49196: PUSH
49197: LD_VAR 0 2
49201: ARRAY
49202: PPUSH
49203: LD_INT 2
49205: PUSH
49206: LD_INT 30
49208: PUSH
49209: LD_INT 2
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PUSH
49216: LD_INT 30
49218: PUSH
49219: LD_INT 3
49221: PUSH
49222: EMPTY
49223: LIST
49224: LIST
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: LIST
49230: PPUSH
49231: CALL_OW 72
49235: NOT
49236: AND
49237: IFFALSE 49342
// begin for j = 1 to mc_build_list [ i ] do
49239: LD_ADDR_VAR 0 3
49243: PUSH
49244: DOUBLE
49245: LD_INT 1
49247: DEC
49248: ST_TO_ADDR
49249: LD_EXP 106
49253: PUSH
49254: LD_VAR 0 2
49258: ARRAY
49259: PUSH
49260: FOR_TO
49261: IFFALSE 49340
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49263: LD_EXP 106
49267: PUSH
49268: LD_VAR 0 2
49272: ARRAY
49273: PUSH
49274: LD_VAR 0 3
49278: ARRAY
49279: PUSH
49280: LD_INT 1
49282: ARRAY
49283: PUSH
49284: LD_INT 2
49286: EQUAL
49287: IFFALSE 49338
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49289: LD_ADDR_EXP 106
49293: PUSH
49294: LD_EXP 106
49298: PPUSH
49299: LD_VAR 0 2
49303: PPUSH
49304: LD_EXP 106
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: PPUSH
49315: LD_VAR 0 3
49319: PPUSH
49320: LD_INT 1
49322: PPUSH
49323: LD_INT 0
49325: PPUSH
49326: CALL 73438 0 4
49330: PPUSH
49331: CALL_OW 1
49335: ST_TO_ADDR
// break ;
49336: GO 49340
// end ;
49338: GO 49260
49340: POP
49341: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49342: LD_ADDR_VAR 0 6
49346: PUSH
49347: LD_EXP 101
49351: PUSH
49352: LD_VAR 0 2
49356: ARRAY
49357: PPUSH
49358: LD_INT 2
49360: PUSH
49361: LD_INT 30
49363: PUSH
49364: LD_INT 0
49366: PUSH
49367: EMPTY
49368: LIST
49369: LIST
49370: PUSH
49371: LD_INT 30
49373: PUSH
49374: LD_INT 1
49376: PUSH
49377: EMPTY
49378: LIST
49379: LIST
49380: PUSH
49381: EMPTY
49382: LIST
49383: LIST
49384: LIST
49385: PPUSH
49386: CALL_OW 72
49390: ST_TO_ADDR
// for k := 1 to depot do
49391: LD_ADDR_VAR 0 4
49395: PUSH
49396: DOUBLE
49397: LD_INT 1
49399: DEC
49400: ST_TO_ADDR
49401: LD_VAR 0 6
49405: PUSH
49406: FOR_TO
49407: IFFALSE 49977
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49409: LD_EXP 106
49413: PUSH
49414: LD_VAR 0 2
49418: ARRAY
49419: PUSH
49420: LD_INT 1
49422: ARRAY
49423: PUSH
49424: LD_INT 1
49426: ARRAY
49427: PUSH
49428: LD_INT 0
49430: EQUAL
49431: PUSH
49432: LD_VAR 0 6
49436: PUSH
49437: LD_VAR 0 4
49441: ARRAY
49442: PPUSH
49443: LD_EXP 106
49447: PUSH
49448: LD_VAR 0 2
49452: ARRAY
49453: PUSH
49454: LD_INT 1
49456: ARRAY
49457: PUSH
49458: LD_INT 1
49460: ARRAY
49461: PPUSH
49462: LD_EXP 106
49466: PUSH
49467: LD_VAR 0 2
49471: ARRAY
49472: PUSH
49473: LD_INT 1
49475: ARRAY
49476: PUSH
49477: LD_INT 2
49479: ARRAY
49480: PPUSH
49481: LD_EXP 106
49485: PUSH
49486: LD_VAR 0 2
49490: ARRAY
49491: PUSH
49492: LD_INT 1
49494: ARRAY
49495: PUSH
49496: LD_INT 3
49498: ARRAY
49499: PPUSH
49500: LD_EXP 106
49504: PUSH
49505: LD_VAR 0 2
49509: ARRAY
49510: PUSH
49511: LD_INT 1
49513: ARRAY
49514: PUSH
49515: LD_INT 4
49517: ARRAY
49518: PPUSH
49519: CALL 82494 0 5
49523: OR
49524: IFFALSE 49805
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49526: LD_ADDR_VAR 0 5
49530: PUSH
49531: LD_EXP 101
49535: PUSH
49536: LD_VAR 0 2
49540: ARRAY
49541: PPUSH
49542: LD_INT 25
49544: PUSH
49545: LD_INT 2
49547: PUSH
49548: EMPTY
49549: LIST
49550: LIST
49551: PPUSH
49552: CALL_OW 72
49556: PUSH
49557: LD_EXP 103
49561: PUSH
49562: LD_VAR 0 2
49566: ARRAY
49567: DIFF
49568: ST_TO_ADDR
// if not tmp then
49569: LD_VAR 0 5
49573: NOT
49574: IFFALSE 49578
// continue ;
49576: GO 49406
// for j in tmp do
49578: LD_ADDR_VAR 0 3
49582: PUSH
49583: LD_VAR 0 5
49587: PUSH
49588: FOR_IN
49589: IFFALSE 49801
// begin if not mc_builders [ i ] then
49591: LD_EXP 107
49595: PUSH
49596: LD_VAR 0 2
49600: ARRAY
49601: NOT
49602: IFFALSE 49660
// begin SetTag ( j , 103 ) ;
49604: LD_VAR 0 3
49608: PPUSH
49609: LD_INT 103
49611: PPUSH
49612: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49616: LD_ADDR_EXP 107
49620: PUSH
49621: LD_EXP 107
49625: PPUSH
49626: LD_VAR 0 2
49630: PUSH
49631: LD_EXP 107
49635: PUSH
49636: LD_VAR 0 2
49640: ARRAY
49641: PUSH
49642: LD_INT 1
49644: PLUS
49645: PUSH
49646: EMPTY
49647: LIST
49648: LIST
49649: PPUSH
49650: LD_VAR 0 3
49654: PPUSH
49655: CALL 74020 0 3
49659: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49660: LD_VAR 0 3
49664: PPUSH
49665: CALL_OW 310
49669: IFFALSE 49680
// ComExitBuilding ( j ) ;
49671: LD_VAR 0 3
49675: PPUSH
49676: CALL_OW 122
// wait ( 3 ) ;
49680: LD_INT 3
49682: PPUSH
49683: CALL_OW 67
// if not mc_build_list [ i ] then
49687: LD_EXP 106
49691: PUSH
49692: LD_VAR 0 2
49696: ARRAY
49697: NOT
49698: IFFALSE 49702
// break ;
49700: GO 49801
// if not HasTask ( j ) then
49702: LD_VAR 0 3
49706: PPUSH
49707: CALL_OW 314
49711: NOT
49712: IFFALSE 49799
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
49714: LD_VAR 0 3
49718: PPUSH
49719: LD_EXP 106
49723: PUSH
49724: LD_VAR 0 2
49728: ARRAY
49729: PUSH
49730: LD_INT 1
49732: ARRAY
49733: PUSH
49734: LD_INT 1
49736: ARRAY
49737: PPUSH
49738: LD_EXP 106
49742: PUSH
49743: LD_VAR 0 2
49747: ARRAY
49748: PUSH
49749: LD_INT 1
49751: ARRAY
49752: PUSH
49753: LD_INT 2
49755: ARRAY
49756: PPUSH
49757: LD_EXP 106
49761: PUSH
49762: LD_VAR 0 2
49766: ARRAY
49767: PUSH
49768: LD_INT 1
49770: ARRAY
49771: PUSH
49772: LD_INT 3
49774: ARRAY
49775: PPUSH
49776: LD_EXP 106
49780: PUSH
49781: LD_VAR 0 2
49785: ARRAY
49786: PUSH
49787: LD_INT 1
49789: ARRAY
49790: PUSH
49791: LD_INT 4
49793: ARRAY
49794: PPUSH
49795: CALL_OW 145
// end ;
49799: GO 49588
49801: POP
49802: POP
// end else
49803: GO 49975
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
49805: LD_EXP 101
49809: PUSH
49810: LD_VAR 0 2
49814: ARRAY
49815: PPUSH
49816: LD_EXP 106
49820: PUSH
49821: LD_VAR 0 2
49825: ARRAY
49826: PUSH
49827: LD_INT 1
49829: ARRAY
49830: PUSH
49831: LD_INT 1
49833: ARRAY
49834: PPUSH
49835: LD_EXP 106
49839: PUSH
49840: LD_VAR 0 2
49844: ARRAY
49845: PUSH
49846: LD_INT 1
49848: ARRAY
49849: PUSH
49850: LD_INT 2
49852: ARRAY
49853: PPUSH
49854: LD_EXP 106
49858: PUSH
49859: LD_VAR 0 2
49863: ARRAY
49864: PUSH
49865: LD_INT 1
49867: ARRAY
49868: PUSH
49869: LD_INT 3
49871: ARRAY
49872: PPUSH
49873: LD_EXP 106
49877: PUSH
49878: LD_VAR 0 2
49882: ARRAY
49883: PUSH
49884: LD_INT 1
49886: ARRAY
49887: PUSH
49888: LD_INT 4
49890: ARRAY
49891: PPUSH
49892: LD_EXP 101
49896: PUSH
49897: LD_VAR 0 2
49901: ARRAY
49902: PPUSH
49903: LD_INT 21
49905: PUSH
49906: LD_INT 3
49908: PUSH
49909: EMPTY
49910: LIST
49911: LIST
49912: PPUSH
49913: CALL_OW 72
49917: PPUSH
49918: EMPTY
49919: PPUSH
49920: CALL 81248 0 7
49924: NOT
49925: IFFALSE 49975
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
49927: LD_ADDR_EXP 106
49931: PUSH
49932: LD_EXP 106
49936: PPUSH
49937: LD_VAR 0 2
49941: PPUSH
49942: LD_EXP 106
49946: PUSH
49947: LD_VAR 0 2
49951: ARRAY
49952: PPUSH
49953: LD_INT 1
49955: PPUSH
49956: LD_INT 1
49958: NEG
49959: PPUSH
49960: LD_INT 0
49962: PPUSH
49963: CALL 73438 0 4
49967: PPUSH
49968: CALL_OW 1
49972: ST_TO_ADDR
// continue ;
49973: GO 49406
// end ; end ;
49975: GO 49406
49977: POP
49978: POP
// end ; end ;
49979: GO 48835
49981: POP
49982: POP
// end ;
49983: LD_VAR 0 1
49987: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
49988: LD_INT 0
49990: PPUSH
49991: PPUSH
49992: PPUSH
49993: PPUSH
49994: PPUSH
49995: PPUSH
// if not mc_bases then
49996: LD_EXP 101
50000: NOT
50001: IFFALSE 50005
// exit ;
50003: GO 50432
// for i = 1 to mc_bases do
50005: LD_ADDR_VAR 0 2
50009: PUSH
50010: DOUBLE
50011: LD_INT 1
50013: DEC
50014: ST_TO_ADDR
50015: LD_EXP 101
50019: PUSH
50020: FOR_TO
50021: IFFALSE 50430
// begin tmp := mc_build_upgrade [ i ] ;
50023: LD_ADDR_VAR 0 4
50027: PUSH
50028: LD_EXP 133
50032: PUSH
50033: LD_VAR 0 2
50037: ARRAY
50038: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50039: LD_ADDR_VAR 0 6
50043: PUSH
50044: LD_EXP 134
50048: PUSH
50049: LD_VAR 0 2
50053: ARRAY
50054: PPUSH
50055: LD_INT 2
50057: PUSH
50058: LD_INT 30
50060: PUSH
50061: LD_INT 6
50063: PUSH
50064: EMPTY
50065: LIST
50066: LIST
50067: PUSH
50068: LD_INT 30
50070: PUSH
50071: LD_INT 7
50073: PUSH
50074: EMPTY
50075: LIST
50076: LIST
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: LIST
50082: PPUSH
50083: CALL_OW 72
50087: ST_TO_ADDR
// if not tmp and not lab then
50088: LD_VAR 0 4
50092: NOT
50093: PUSH
50094: LD_VAR 0 6
50098: NOT
50099: AND
50100: IFFALSE 50104
// continue ;
50102: GO 50020
// if tmp then
50104: LD_VAR 0 4
50108: IFFALSE 50228
// for j in tmp do
50110: LD_ADDR_VAR 0 3
50114: PUSH
50115: LD_VAR 0 4
50119: PUSH
50120: FOR_IN
50121: IFFALSE 50226
// begin if UpgradeCost ( j ) then
50123: LD_VAR 0 3
50127: PPUSH
50128: CALL 80908 0 1
50132: IFFALSE 50224
// begin ComUpgrade ( j ) ;
50134: LD_VAR 0 3
50138: PPUSH
50139: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50143: LD_ADDR_EXP 133
50147: PUSH
50148: LD_EXP 133
50152: PPUSH
50153: LD_VAR 0 2
50157: PPUSH
50158: LD_EXP 133
50162: PUSH
50163: LD_VAR 0 2
50167: ARRAY
50168: PUSH
50169: LD_VAR 0 3
50173: DIFF
50174: PPUSH
50175: CALL_OW 1
50179: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50180: LD_ADDR_EXP 108
50184: PUSH
50185: LD_EXP 108
50189: PPUSH
50190: LD_VAR 0 2
50194: PUSH
50195: LD_EXP 108
50199: PUSH
50200: LD_VAR 0 2
50204: ARRAY
50205: PUSH
50206: LD_INT 1
50208: PLUS
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PPUSH
50214: LD_VAR 0 3
50218: PPUSH
50219: CALL 74020 0 3
50223: ST_TO_ADDR
// end ; end ;
50224: GO 50120
50226: POP
50227: POP
// if not lab or not mc_lab_upgrade [ i ] then
50228: LD_VAR 0 6
50232: NOT
50233: PUSH
50234: LD_EXP 135
50238: PUSH
50239: LD_VAR 0 2
50243: ARRAY
50244: NOT
50245: OR
50246: IFFALSE 50250
// continue ;
50248: GO 50020
// for j in lab do
50250: LD_ADDR_VAR 0 3
50254: PUSH
50255: LD_VAR 0 6
50259: PUSH
50260: FOR_IN
50261: IFFALSE 50426
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50263: LD_VAR 0 3
50267: PPUSH
50268: CALL_OW 266
50272: PUSH
50273: LD_INT 6
50275: PUSH
50276: LD_INT 7
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: IN
50283: PUSH
50284: LD_VAR 0 3
50288: PPUSH
50289: CALL_OW 461
50293: PUSH
50294: LD_INT 1
50296: NONEQUAL
50297: AND
50298: IFFALSE 50424
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50300: LD_VAR 0 3
50304: PPUSH
50305: LD_EXP 135
50309: PUSH
50310: LD_VAR 0 2
50314: ARRAY
50315: PUSH
50316: LD_INT 1
50318: ARRAY
50319: PPUSH
50320: CALL 81113 0 2
50324: IFFALSE 50424
// begin ComCancel ( j ) ;
50326: LD_VAR 0 3
50330: PPUSH
50331: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50335: LD_VAR 0 3
50339: PPUSH
50340: LD_EXP 135
50344: PUSH
50345: LD_VAR 0 2
50349: ARRAY
50350: PUSH
50351: LD_INT 1
50353: ARRAY
50354: PPUSH
50355: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50359: LD_VAR 0 3
50363: PUSH
50364: LD_EXP 108
50368: PUSH
50369: LD_VAR 0 2
50373: ARRAY
50374: IN
50375: NOT
50376: IFFALSE 50422
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50378: LD_ADDR_EXP 108
50382: PUSH
50383: LD_EXP 108
50387: PPUSH
50388: LD_VAR 0 2
50392: PUSH
50393: LD_EXP 108
50397: PUSH
50398: LD_VAR 0 2
50402: ARRAY
50403: PUSH
50404: LD_INT 1
50406: PLUS
50407: PUSH
50408: EMPTY
50409: LIST
50410: LIST
50411: PPUSH
50412: LD_VAR 0 3
50416: PPUSH
50417: CALL 74020 0 3
50421: ST_TO_ADDR
// break ;
50422: GO 50426
// end ; end ; end ;
50424: GO 50260
50426: POP
50427: POP
// end ;
50428: GO 50020
50430: POP
50431: POP
// end ;
50432: LD_VAR 0 1
50436: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50437: LD_INT 0
50439: PPUSH
50440: PPUSH
50441: PPUSH
50442: PPUSH
50443: PPUSH
50444: PPUSH
50445: PPUSH
50446: PPUSH
50447: PPUSH
// if not mc_bases then
50448: LD_EXP 101
50452: NOT
50453: IFFALSE 50457
// exit ;
50455: GO 50862
// for i = 1 to mc_bases do
50457: LD_ADDR_VAR 0 2
50461: PUSH
50462: DOUBLE
50463: LD_INT 1
50465: DEC
50466: ST_TO_ADDR
50467: LD_EXP 101
50471: PUSH
50472: FOR_TO
50473: IFFALSE 50860
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50475: LD_EXP 109
50479: PUSH
50480: LD_VAR 0 2
50484: ARRAY
50485: NOT
50486: PUSH
50487: LD_EXP 101
50491: PUSH
50492: LD_VAR 0 2
50496: ARRAY
50497: PPUSH
50498: LD_INT 30
50500: PUSH
50501: LD_INT 3
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PPUSH
50508: CALL_OW 72
50512: NOT
50513: OR
50514: IFFALSE 50518
// continue ;
50516: GO 50472
// busy := false ;
50518: LD_ADDR_VAR 0 8
50522: PUSH
50523: LD_INT 0
50525: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50526: LD_ADDR_VAR 0 4
50530: PUSH
50531: LD_EXP 101
50535: PUSH
50536: LD_VAR 0 2
50540: ARRAY
50541: PPUSH
50542: LD_INT 30
50544: PUSH
50545: LD_INT 3
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PPUSH
50552: CALL_OW 72
50556: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50557: LD_ADDR_VAR 0 6
50561: PUSH
50562: LD_EXP 109
50566: PUSH
50567: LD_VAR 0 2
50571: ARRAY
50572: PPUSH
50573: LD_INT 2
50575: PUSH
50576: LD_INT 30
50578: PUSH
50579: LD_INT 32
50581: PUSH
50582: EMPTY
50583: LIST
50584: LIST
50585: PUSH
50586: LD_INT 30
50588: PUSH
50589: LD_INT 33
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: LIST
50600: PPUSH
50601: CALL_OW 72
50605: ST_TO_ADDR
// if not t then
50606: LD_VAR 0 6
50610: NOT
50611: IFFALSE 50615
// continue ;
50613: GO 50472
// for j in tmp do
50615: LD_ADDR_VAR 0 3
50619: PUSH
50620: LD_VAR 0 4
50624: PUSH
50625: FOR_IN
50626: IFFALSE 50656
// if not BuildingStatus ( j ) = bs_idle then
50628: LD_VAR 0 3
50632: PPUSH
50633: CALL_OW 461
50637: PUSH
50638: LD_INT 2
50640: EQUAL
50641: NOT
50642: IFFALSE 50654
// begin busy := true ;
50644: LD_ADDR_VAR 0 8
50648: PUSH
50649: LD_INT 1
50651: ST_TO_ADDR
// break ;
50652: GO 50656
// end ;
50654: GO 50625
50656: POP
50657: POP
// if busy then
50658: LD_VAR 0 8
50662: IFFALSE 50666
// continue ;
50664: GO 50472
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
50666: LD_ADDR_VAR 0 7
50670: PUSH
50671: LD_VAR 0 6
50675: PPUSH
50676: LD_INT 35
50678: PUSH
50679: LD_INT 0
50681: PUSH
50682: EMPTY
50683: LIST
50684: LIST
50685: PPUSH
50686: CALL_OW 72
50690: ST_TO_ADDR
// if tw then
50691: LD_VAR 0 7
50695: IFFALSE 50772
// begin tw := tw [ 1 ] ;
50697: LD_ADDR_VAR 0 7
50701: PUSH
50702: LD_VAR 0 7
50706: PUSH
50707: LD_INT 1
50709: ARRAY
50710: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
50711: LD_ADDR_VAR 0 9
50715: PUSH
50716: LD_VAR 0 7
50720: PPUSH
50721: LD_EXP 126
50725: PUSH
50726: LD_VAR 0 2
50730: ARRAY
50731: PPUSH
50732: CALL 79405 0 2
50736: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
50737: LD_EXP 140
50741: PUSH
50742: LD_VAR 0 2
50746: ARRAY
50747: IFFALSE 50770
// if not weapon in mc_allowed_tower_weapons [ i ] then
50749: LD_VAR 0 9
50753: PUSH
50754: LD_EXP 140
50758: PUSH
50759: LD_VAR 0 2
50763: ARRAY
50764: IN
50765: NOT
50766: IFFALSE 50770
// continue ;
50768: GO 50472
// end else
50770: GO 50835
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
50772: LD_ADDR_VAR 0 5
50776: PUSH
50777: LD_EXP 109
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PPUSH
50788: LD_VAR 0 4
50792: PPUSH
50793: CALL 106308 0 2
50797: ST_TO_ADDR
// if not tmp2 then
50798: LD_VAR 0 5
50802: NOT
50803: IFFALSE 50807
// continue ;
50805: GO 50472
// tw := tmp2 [ 1 ] ;
50807: LD_ADDR_VAR 0 7
50811: PUSH
50812: LD_VAR 0 5
50816: PUSH
50817: LD_INT 1
50819: ARRAY
50820: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
50821: LD_ADDR_VAR 0 9
50825: PUSH
50826: LD_VAR 0 5
50830: PUSH
50831: LD_INT 2
50833: ARRAY
50834: ST_TO_ADDR
// end ; if not weapon then
50835: LD_VAR 0 9
50839: NOT
50840: IFFALSE 50844
// continue ;
50842: GO 50472
// ComPlaceWeapon ( tw , weapon ) ;
50844: LD_VAR 0 7
50848: PPUSH
50849: LD_VAR 0 9
50853: PPUSH
50854: CALL_OW 148
// end ;
50858: GO 50472
50860: POP
50861: POP
// end ;
50862: LD_VAR 0 1
50866: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
50867: LD_INT 0
50869: PPUSH
50870: PPUSH
50871: PPUSH
50872: PPUSH
50873: PPUSH
50874: PPUSH
50875: PPUSH
// if not mc_bases then
50876: LD_EXP 101
50880: NOT
50881: IFFALSE 50885
// exit ;
50883: GO 51660
// for i = 1 to mc_bases do
50885: LD_ADDR_VAR 0 2
50889: PUSH
50890: DOUBLE
50891: LD_INT 1
50893: DEC
50894: ST_TO_ADDR
50895: LD_EXP 101
50899: PUSH
50900: FOR_TO
50901: IFFALSE 51658
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
50903: LD_EXP 114
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: NOT
50914: PUSH
50915: LD_EXP 114
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: PUSH
50926: LD_EXP 115
50930: PUSH
50931: LD_VAR 0 2
50935: ARRAY
50936: EQUAL
50937: OR
50938: PUSH
50939: LD_EXP 124
50943: PUSH
50944: LD_VAR 0 2
50948: ARRAY
50949: OR
50950: IFFALSE 50954
// continue ;
50952: GO 50900
// if mc_miners [ i ] then
50954: LD_EXP 115
50958: PUSH
50959: LD_VAR 0 2
50963: ARRAY
50964: IFFALSE 51345
// begin for j = mc_miners [ i ] downto 1 do
50966: LD_ADDR_VAR 0 3
50970: PUSH
50971: DOUBLE
50972: LD_EXP 115
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: INC
50983: ST_TO_ADDR
50984: LD_INT 1
50986: PUSH
50987: FOR_DOWNTO
50988: IFFALSE 51343
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
50990: LD_EXP 115
50994: PUSH
50995: LD_VAR 0 2
50999: ARRAY
51000: PUSH
51001: LD_VAR 0 3
51005: ARRAY
51006: PPUSH
51007: CALL_OW 301
51011: PUSH
51012: LD_EXP 115
51016: PUSH
51017: LD_VAR 0 2
51021: ARRAY
51022: PUSH
51023: LD_VAR 0 3
51027: ARRAY
51028: PPUSH
51029: CALL_OW 257
51033: PUSH
51034: LD_INT 1
51036: NONEQUAL
51037: OR
51038: IFFALSE 51101
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51040: LD_ADDR_VAR 0 5
51044: PUSH
51045: LD_EXP 115
51049: PUSH
51050: LD_VAR 0 2
51054: ARRAY
51055: PUSH
51056: LD_EXP 115
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PUSH
51067: LD_VAR 0 3
51071: ARRAY
51072: DIFF
51073: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51074: LD_ADDR_EXP 115
51078: PUSH
51079: LD_EXP 115
51083: PPUSH
51084: LD_VAR 0 2
51088: PPUSH
51089: LD_VAR 0 5
51093: PPUSH
51094: CALL_OW 1
51098: ST_TO_ADDR
// continue ;
51099: GO 50987
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51101: LD_EXP 115
51105: PUSH
51106: LD_VAR 0 2
51110: ARRAY
51111: PUSH
51112: LD_VAR 0 3
51116: ARRAY
51117: PPUSH
51118: CALL_OW 257
51122: PUSH
51123: LD_INT 1
51125: EQUAL
51126: PUSH
51127: LD_EXP 115
51131: PUSH
51132: LD_VAR 0 2
51136: ARRAY
51137: PUSH
51138: LD_VAR 0 3
51142: ARRAY
51143: PPUSH
51144: CALL_OW 459
51148: NOT
51149: AND
51150: PUSH
51151: LD_EXP 115
51155: PUSH
51156: LD_VAR 0 2
51160: ARRAY
51161: PUSH
51162: LD_VAR 0 3
51166: ARRAY
51167: PPUSH
51168: CALL_OW 314
51172: NOT
51173: AND
51174: IFFALSE 51341
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51176: LD_EXP 115
51180: PUSH
51181: LD_VAR 0 2
51185: ARRAY
51186: PUSH
51187: LD_VAR 0 3
51191: ARRAY
51192: PPUSH
51193: CALL_OW 310
51197: IFFALSE 51220
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51199: LD_EXP 115
51203: PUSH
51204: LD_VAR 0 2
51208: ARRAY
51209: PUSH
51210: LD_VAR 0 3
51214: ARRAY
51215: PPUSH
51216: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51220: LD_EXP 115
51224: PUSH
51225: LD_VAR 0 2
51229: ARRAY
51230: PUSH
51231: LD_VAR 0 3
51235: ARRAY
51236: PPUSH
51237: CALL_OW 314
51241: NOT
51242: IFFALSE 51341
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51244: LD_ADDR_VAR 0 7
51248: PUSH
51249: LD_VAR 0 3
51253: PUSH
51254: LD_EXP 114
51258: PUSH
51259: LD_VAR 0 2
51263: ARRAY
51264: PPUSH
51265: CALL 71160 0 1
51269: MOD
51270: PUSH
51271: LD_INT 1
51273: PLUS
51274: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51275: LD_EXP 115
51279: PUSH
51280: LD_VAR 0 2
51284: ARRAY
51285: PUSH
51286: LD_VAR 0 3
51290: ARRAY
51291: PPUSH
51292: LD_EXP 114
51296: PUSH
51297: LD_VAR 0 2
51301: ARRAY
51302: PUSH
51303: LD_VAR 0 7
51307: ARRAY
51308: PUSH
51309: LD_INT 1
51311: ARRAY
51312: PPUSH
51313: LD_EXP 114
51317: PUSH
51318: LD_VAR 0 2
51322: ARRAY
51323: PUSH
51324: LD_VAR 0 7
51328: ARRAY
51329: PUSH
51330: LD_INT 2
51332: ARRAY
51333: PPUSH
51334: LD_INT 0
51336: PPUSH
51337: CALL_OW 193
// end ; end ; end ;
51341: GO 50987
51343: POP
51344: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51345: LD_ADDR_VAR 0 5
51349: PUSH
51350: LD_EXP 101
51354: PUSH
51355: LD_VAR 0 2
51359: ARRAY
51360: PPUSH
51361: LD_INT 2
51363: PUSH
51364: LD_INT 30
51366: PUSH
51367: LD_INT 4
51369: PUSH
51370: EMPTY
51371: LIST
51372: LIST
51373: PUSH
51374: LD_INT 30
51376: PUSH
51377: LD_INT 5
51379: PUSH
51380: EMPTY
51381: LIST
51382: LIST
51383: PUSH
51384: LD_INT 30
51386: PUSH
51387: LD_INT 32
51389: PUSH
51390: EMPTY
51391: LIST
51392: LIST
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: PPUSH
51400: CALL_OW 72
51404: ST_TO_ADDR
// if not tmp then
51405: LD_VAR 0 5
51409: NOT
51410: IFFALSE 51414
// continue ;
51412: GO 50900
// list := [ ] ;
51414: LD_ADDR_VAR 0 6
51418: PUSH
51419: EMPTY
51420: ST_TO_ADDR
// for j in tmp do
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_VAR 0 5
51430: PUSH
51431: FOR_IN
51432: IFFALSE 51501
// begin for k in UnitsInside ( j ) do
51434: LD_ADDR_VAR 0 4
51438: PUSH
51439: LD_VAR 0 3
51443: PPUSH
51444: CALL_OW 313
51448: PUSH
51449: FOR_IN
51450: IFFALSE 51497
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51452: LD_VAR 0 4
51456: PPUSH
51457: CALL_OW 257
51461: PUSH
51462: LD_INT 1
51464: EQUAL
51465: PUSH
51466: LD_VAR 0 4
51470: PPUSH
51471: CALL_OW 459
51475: NOT
51476: AND
51477: IFFALSE 51495
// list := list ^ k ;
51479: LD_ADDR_VAR 0 6
51483: PUSH
51484: LD_VAR 0 6
51488: PUSH
51489: LD_VAR 0 4
51493: ADD
51494: ST_TO_ADDR
51495: GO 51449
51497: POP
51498: POP
// end ;
51499: GO 51431
51501: POP
51502: POP
// list := list diff mc_miners [ i ] ;
51503: LD_ADDR_VAR 0 6
51507: PUSH
51508: LD_VAR 0 6
51512: PUSH
51513: LD_EXP 115
51517: PUSH
51518: LD_VAR 0 2
51522: ARRAY
51523: DIFF
51524: ST_TO_ADDR
// if not list then
51525: LD_VAR 0 6
51529: NOT
51530: IFFALSE 51534
// continue ;
51532: GO 50900
// k := mc_mines [ i ] - mc_miners [ i ] ;
51534: LD_ADDR_VAR 0 4
51538: PUSH
51539: LD_EXP 114
51543: PUSH
51544: LD_VAR 0 2
51548: ARRAY
51549: PUSH
51550: LD_EXP 115
51554: PUSH
51555: LD_VAR 0 2
51559: ARRAY
51560: MINUS
51561: ST_TO_ADDR
// if k > list then
51562: LD_VAR 0 4
51566: PUSH
51567: LD_VAR 0 6
51571: GREATER
51572: IFFALSE 51584
// k := list ;
51574: LD_ADDR_VAR 0 4
51578: PUSH
51579: LD_VAR 0 6
51583: ST_TO_ADDR
// for j = 1 to k do
51584: LD_ADDR_VAR 0 3
51588: PUSH
51589: DOUBLE
51590: LD_INT 1
51592: DEC
51593: ST_TO_ADDR
51594: LD_VAR 0 4
51598: PUSH
51599: FOR_TO
51600: IFFALSE 51654
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51602: LD_ADDR_EXP 115
51606: PUSH
51607: LD_EXP 115
51611: PPUSH
51612: LD_VAR 0 2
51616: PUSH
51617: LD_EXP 115
51621: PUSH
51622: LD_VAR 0 2
51626: ARRAY
51627: PUSH
51628: LD_INT 1
51630: PLUS
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: PPUSH
51636: LD_VAR 0 6
51640: PUSH
51641: LD_VAR 0 3
51645: ARRAY
51646: PPUSH
51647: CALL 74020 0 3
51651: ST_TO_ADDR
51652: GO 51599
51654: POP
51655: POP
// end ;
51656: GO 50900
51658: POP
51659: POP
// end ;
51660: LD_VAR 0 1
51664: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
51665: LD_INT 0
51667: PPUSH
51668: PPUSH
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
51673: PPUSH
51674: PPUSH
51675: PPUSH
51676: PPUSH
51677: PPUSH
// if not mc_bases then
51678: LD_EXP 101
51682: NOT
51683: IFFALSE 51687
// exit ;
51685: GO 53510
// for i = 1 to mc_bases do
51687: LD_ADDR_VAR 0 2
51691: PUSH
51692: DOUBLE
51693: LD_INT 1
51695: DEC
51696: ST_TO_ADDR
51697: LD_EXP 101
51701: PUSH
51702: FOR_TO
51703: IFFALSE 53508
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
51705: LD_EXP 101
51709: PUSH
51710: LD_VAR 0 2
51714: ARRAY
51715: NOT
51716: PUSH
51717: LD_EXP 108
51721: PUSH
51722: LD_VAR 0 2
51726: ARRAY
51727: OR
51728: IFFALSE 51732
// continue ;
51730: GO 51702
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
51732: LD_EXP 117
51736: PUSH
51737: LD_VAR 0 2
51741: ARRAY
51742: NOT
51743: PUSH
51744: LD_EXP 118
51748: PUSH
51749: LD_VAR 0 2
51753: ARRAY
51754: AND
51755: IFFALSE 51793
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51757: LD_ADDR_EXP 118
51761: PUSH
51762: LD_EXP 118
51766: PPUSH
51767: LD_VAR 0 2
51771: PPUSH
51772: EMPTY
51773: PPUSH
51774: CALL_OW 1
51778: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
51779: LD_VAR 0 2
51783: PPUSH
51784: LD_INT 107
51786: PPUSH
51787: CALL 42519 0 2
// continue ;
51791: GO 51702
// end ; target := [ ] ;
51793: LD_ADDR_VAR 0 7
51797: PUSH
51798: EMPTY
51799: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51800: LD_ADDR_VAR 0 6
51804: PUSH
51805: LD_EXP 101
51809: PUSH
51810: LD_VAR 0 2
51814: ARRAY
51815: PUSH
51816: LD_INT 1
51818: ARRAY
51819: PPUSH
51820: CALL_OW 255
51824: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51825: LD_ADDR_VAR 0 9
51829: PUSH
51830: LD_EXP 101
51834: PUSH
51835: LD_VAR 0 2
51839: ARRAY
51840: PPUSH
51841: LD_INT 2
51843: PUSH
51844: LD_INT 30
51846: PUSH
51847: LD_INT 0
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: LD_INT 30
51856: PUSH
51857: LD_INT 1
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: LIST
51868: PPUSH
51869: CALL_OW 72
51873: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
51874: LD_ADDR_VAR 0 3
51878: PUSH
51879: DOUBLE
51880: LD_EXP 117
51884: PUSH
51885: LD_VAR 0 2
51889: ARRAY
51890: INC
51891: ST_TO_ADDR
51892: LD_INT 1
51894: PUSH
51895: FOR_DOWNTO
51896: IFFALSE 52141
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
51898: LD_EXP 117
51902: PUSH
51903: LD_VAR 0 2
51907: ARRAY
51908: PUSH
51909: LD_VAR 0 3
51913: ARRAY
51914: PUSH
51915: LD_INT 2
51917: ARRAY
51918: PPUSH
51919: LD_EXP 117
51923: PUSH
51924: LD_VAR 0 2
51928: ARRAY
51929: PUSH
51930: LD_VAR 0 3
51934: ARRAY
51935: PUSH
51936: LD_INT 3
51938: ARRAY
51939: PPUSH
51940: CALL_OW 488
51944: PUSH
51945: LD_EXP 117
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PUSH
51956: LD_VAR 0 3
51960: ARRAY
51961: PUSH
51962: LD_INT 2
51964: ARRAY
51965: PPUSH
51966: LD_EXP 117
51970: PUSH
51971: LD_VAR 0 2
51975: ARRAY
51976: PUSH
51977: LD_VAR 0 3
51981: ARRAY
51982: PUSH
51983: LD_INT 3
51985: ARRAY
51986: PPUSH
51987: CALL_OW 284
51991: PUSH
51992: LD_INT 0
51994: EQUAL
51995: AND
51996: IFFALSE 52051
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
51998: LD_ADDR_VAR 0 5
52002: PUSH
52003: LD_EXP 117
52007: PUSH
52008: LD_VAR 0 2
52012: ARRAY
52013: PPUSH
52014: LD_VAR 0 3
52018: PPUSH
52019: CALL_OW 3
52023: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52024: LD_ADDR_EXP 117
52028: PUSH
52029: LD_EXP 117
52033: PPUSH
52034: LD_VAR 0 2
52038: PPUSH
52039: LD_VAR 0 5
52043: PPUSH
52044: CALL_OW 1
52048: ST_TO_ADDR
// continue ;
52049: GO 51895
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52051: LD_VAR 0 6
52055: PPUSH
52056: LD_EXP 117
52060: PUSH
52061: LD_VAR 0 2
52065: ARRAY
52066: PUSH
52067: LD_VAR 0 3
52071: ARRAY
52072: PUSH
52073: LD_INT 2
52075: ARRAY
52076: PPUSH
52077: LD_EXP 117
52081: PUSH
52082: LD_VAR 0 2
52086: ARRAY
52087: PUSH
52088: LD_VAR 0 3
52092: ARRAY
52093: PUSH
52094: LD_INT 3
52096: ARRAY
52097: PPUSH
52098: LD_INT 30
52100: PPUSH
52101: CALL 75284 0 4
52105: PUSH
52106: LD_INT 4
52108: ARRAY
52109: PUSH
52110: LD_INT 0
52112: EQUAL
52113: IFFALSE 52139
// begin target := mc_crates [ i ] [ j ] ;
52115: LD_ADDR_VAR 0 7
52119: PUSH
52120: LD_EXP 117
52124: PUSH
52125: LD_VAR 0 2
52129: ARRAY
52130: PUSH
52131: LD_VAR 0 3
52135: ARRAY
52136: ST_TO_ADDR
// break ;
52137: GO 52141
// end ; end ;
52139: GO 51895
52141: POP
52142: POP
// if not target then
52143: LD_VAR 0 7
52147: NOT
52148: IFFALSE 52152
// continue ;
52150: GO 51702
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52152: LD_ADDR_VAR 0 8
52156: PUSH
52157: LD_EXP 120
52161: PUSH
52162: LD_VAR 0 2
52166: ARRAY
52167: PPUSH
52168: LD_INT 2
52170: PUSH
52171: LD_INT 3
52173: PUSH
52174: LD_INT 58
52176: PUSH
52177: EMPTY
52178: LIST
52179: PUSH
52180: EMPTY
52181: LIST
52182: LIST
52183: PUSH
52184: LD_INT 61
52186: PUSH
52187: EMPTY
52188: LIST
52189: PUSH
52190: LD_INT 33
52192: PUSH
52193: LD_INT 5
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PUSH
52200: LD_INT 33
52202: PUSH
52203: LD_INT 3
52205: PUSH
52206: EMPTY
52207: LIST
52208: LIST
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: LIST
52214: LIST
52215: LIST
52216: PUSH
52217: LD_INT 2
52219: PUSH
52220: LD_INT 34
52222: PUSH
52223: LD_INT 32
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: PUSH
52230: LD_INT 34
52232: PUSH
52233: LD_INT 51
52235: PUSH
52236: EMPTY
52237: LIST
52238: LIST
52239: PUSH
52240: LD_INT 34
52242: PUSH
52243: LD_INT 12
52245: PUSH
52246: EMPTY
52247: LIST
52248: LIST
52249: PUSH
52250: EMPTY
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: PUSH
52256: EMPTY
52257: LIST
52258: LIST
52259: PPUSH
52260: CALL_OW 72
52264: ST_TO_ADDR
// if not cargo then
52265: LD_VAR 0 8
52269: NOT
52270: IFFALSE 52976
// begin if mc_crates_collector [ i ] < 5 then
52272: LD_EXP 118
52276: PUSH
52277: LD_VAR 0 2
52281: ARRAY
52282: PUSH
52283: LD_INT 5
52285: LESS
52286: IFFALSE 52652
// begin if mc_ape [ i ] then
52288: LD_EXP 130
52292: PUSH
52293: LD_VAR 0 2
52297: ARRAY
52298: IFFALSE 52345
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52300: LD_ADDR_VAR 0 5
52304: PUSH
52305: LD_EXP 130
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: PPUSH
52316: LD_INT 25
52318: PUSH
52319: LD_INT 16
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: PUSH
52326: LD_INT 24
52328: PUSH
52329: LD_INT 750
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: PPUSH
52340: CALL_OW 72
52344: ST_TO_ADDR
// if not tmp then
52345: LD_VAR 0 5
52349: NOT
52350: IFFALSE 52397
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52352: LD_ADDR_VAR 0 5
52356: PUSH
52357: LD_EXP 101
52361: PUSH
52362: LD_VAR 0 2
52366: ARRAY
52367: PPUSH
52368: LD_INT 25
52370: PUSH
52371: LD_INT 2
52373: PUSH
52374: EMPTY
52375: LIST
52376: LIST
52377: PUSH
52378: LD_INT 24
52380: PUSH
52381: LD_INT 750
52383: PUSH
52384: EMPTY
52385: LIST
52386: LIST
52387: PUSH
52388: EMPTY
52389: LIST
52390: LIST
52391: PPUSH
52392: CALL_OW 72
52396: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52397: LD_EXP 130
52401: PUSH
52402: LD_VAR 0 2
52406: ARRAY
52407: PUSH
52408: LD_EXP 101
52412: PUSH
52413: LD_VAR 0 2
52417: ARRAY
52418: PPUSH
52419: LD_INT 25
52421: PUSH
52422: LD_INT 2
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: LD_INT 24
52431: PUSH
52432: LD_INT 750
52434: PUSH
52435: EMPTY
52436: LIST
52437: LIST
52438: PUSH
52439: EMPTY
52440: LIST
52441: LIST
52442: PPUSH
52443: CALL_OW 72
52447: AND
52448: PUSH
52449: LD_VAR 0 5
52453: PUSH
52454: LD_INT 5
52456: LESS
52457: AND
52458: IFFALSE 52540
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52460: LD_ADDR_VAR 0 3
52464: PUSH
52465: LD_EXP 101
52469: PUSH
52470: LD_VAR 0 2
52474: ARRAY
52475: PPUSH
52476: LD_INT 25
52478: PUSH
52479: LD_INT 2
52481: PUSH
52482: EMPTY
52483: LIST
52484: LIST
52485: PUSH
52486: LD_INT 24
52488: PUSH
52489: LD_INT 750
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: PUSH
52496: EMPTY
52497: LIST
52498: LIST
52499: PPUSH
52500: CALL_OW 72
52504: PUSH
52505: FOR_IN
52506: IFFALSE 52538
// begin tmp := tmp union j ;
52508: LD_ADDR_VAR 0 5
52512: PUSH
52513: LD_VAR 0 5
52517: PUSH
52518: LD_VAR 0 3
52522: UNION
52523: ST_TO_ADDR
// if tmp >= 5 then
52524: LD_VAR 0 5
52528: PUSH
52529: LD_INT 5
52531: GREATEREQUAL
52532: IFFALSE 52536
// break ;
52534: GO 52538
// end ;
52536: GO 52505
52538: POP
52539: POP
// end ; if not tmp then
52540: LD_VAR 0 5
52544: NOT
52545: IFFALSE 52549
// continue ;
52547: GO 51702
// for j in tmp do
52549: LD_ADDR_VAR 0 3
52553: PUSH
52554: LD_VAR 0 5
52558: PUSH
52559: FOR_IN
52560: IFFALSE 52650
// if not GetTag ( j ) then
52562: LD_VAR 0 3
52566: PPUSH
52567: CALL_OW 110
52571: NOT
52572: IFFALSE 52648
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52574: LD_ADDR_EXP 118
52578: PUSH
52579: LD_EXP 118
52583: PPUSH
52584: LD_VAR 0 2
52588: PUSH
52589: LD_EXP 118
52593: PUSH
52594: LD_VAR 0 2
52598: ARRAY
52599: PUSH
52600: LD_INT 1
52602: PLUS
52603: PUSH
52604: EMPTY
52605: LIST
52606: LIST
52607: PPUSH
52608: LD_VAR 0 3
52612: PPUSH
52613: CALL 74020 0 3
52617: ST_TO_ADDR
// SetTag ( j , 107 ) ;
52618: LD_VAR 0 3
52622: PPUSH
52623: LD_INT 107
52625: PPUSH
52626: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
52630: LD_EXP 118
52634: PUSH
52635: LD_VAR 0 2
52639: ARRAY
52640: PUSH
52641: LD_INT 5
52643: GREATEREQUAL
52644: IFFALSE 52648
// break ;
52646: GO 52650
// end ;
52648: GO 52559
52650: POP
52651: POP
// end ; if mc_crates_collector [ i ] and target then
52652: LD_EXP 118
52656: PUSH
52657: LD_VAR 0 2
52661: ARRAY
52662: PUSH
52663: LD_VAR 0 7
52667: AND
52668: IFFALSE 52974
// begin if mc_crates_collector [ i ] < target [ 1 ] then
52670: LD_EXP 118
52674: PUSH
52675: LD_VAR 0 2
52679: ARRAY
52680: PUSH
52681: LD_VAR 0 7
52685: PUSH
52686: LD_INT 1
52688: ARRAY
52689: LESS
52690: IFFALSE 52710
// tmp := mc_crates_collector [ i ] else
52692: LD_ADDR_VAR 0 5
52696: PUSH
52697: LD_EXP 118
52701: PUSH
52702: LD_VAR 0 2
52706: ARRAY
52707: ST_TO_ADDR
52708: GO 52724
// tmp := target [ 1 ] ;
52710: LD_ADDR_VAR 0 5
52714: PUSH
52715: LD_VAR 0 7
52719: PUSH
52720: LD_INT 1
52722: ARRAY
52723: ST_TO_ADDR
// k := 0 ;
52724: LD_ADDR_VAR 0 4
52728: PUSH
52729: LD_INT 0
52731: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
52732: LD_ADDR_VAR 0 3
52736: PUSH
52737: LD_EXP 118
52741: PUSH
52742: LD_VAR 0 2
52746: ARRAY
52747: PUSH
52748: FOR_IN
52749: IFFALSE 52972
// begin k := k + 1 ;
52751: LD_ADDR_VAR 0 4
52755: PUSH
52756: LD_VAR 0 4
52760: PUSH
52761: LD_INT 1
52763: PLUS
52764: ST_TO_ADDR
// if k > tmp then
52765: LD_VAR 0 4
52769: PUSH
52770: LD_VAR 0 5
52774: GREATER
52775: IFFALSE 52779
// break ;
52777: GO 52972
// if not GetClass ( j ) in [ 2 , 16 ] then
52779: LD_VAR 0 3
52783: PPUSH
52784: CALL_OW 257
52788: PUSH
52789: LD_INT 2
52791: PUSH
52792: LD_INT 16
52794: PUSH
52795: EMPTY
52796: LIST
52797: LIST
52798: IN
52799: NOT
52800: IFFALSE 52853
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
52802: LD_ADDR_EXP 118
52806: PUSH
52807: LD_EXP 118
52811: PPUSH
52812: LD_VAR 0 2
52816: PPUSH
52817: LD_EXP 118
52821: PUSH
52822: LD_VAR 0 2
52826: ARRAY
52827: PUSH
52828: LD_VAR 0 3
52832: DIFF
52833: PPUSH
52834: CALL_OW 1
52838: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52839: LD_VAR 0 3
52843: PPUSH
52844: LD_INT 0
52846: PPUSH
52847: CALL_OW 109
// continue ;
52851: GO 52748
// end ; if IsInUnit ( j ) then
52853: LD_VAR 0 3
52857: PPUSH
52858: CALL_OW 310
52862: IFFALSE 52873
// ComExitBuilding ( j ) ;
52864: LD_VAR 0 3
52868: PPUSH
52869: CALL_OW 122
// wait ( 3 ) ;
52873: LD_INT 3
52875: PPUSH
52876: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
52880: LD_VAR 0 3
52884: PPUSH
52885: CALL_OW 314
52889: PUSH
52890: LD_VAR 0 6
52894: PPUSH
52895: LD_VAR 0 7
52899: PUSH
52900: LD_INT 2
52902: ARRAY
52903: PPUSH
52904: LD_VAR 0 7
52908: PUSH
52909: LD_INT 3
52911: ARRAY
52912: PPUSH
52913: LD_INT 30
52915: PPUSH
52916: CALL 75284 0 4
52920: PUSH
52921: LD_INT 4
52923: ARRAY
52924: AND
52925: IFFALSE 52943
// ComStandNearbyBuilding ( j , depot ) else
52927: LD_VAR 0 3
52931: PPUSH
52932: LD_VAR 0 9
52936: PPUSH
52937: CALL 70622 0 2
52941: GO 52970
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52943: LD_VAR 0 3
52947: PPUSH
52948: LD_VAR 0 7
52952: PUSH
52953: LD_INT 2
52955: ARRAY
52956: PPUSH
52957: LD_VAR 0 7
52961: PUSH
52962: LD_INT 3
52964: ARRAY
52965: PPUSH
52966: CALL_OW 117
// end ;
52970: GO 52748
52972: POP
52973: POP
// end ; end else
52974: GO 53506
// begin for j in cargo do
52976: LD_ADDR_VAR 0 3
52980: PUSH
52981: LD_VAR 0 8
52985: PUSH
52986: FOR_IN
52987: IFFALSE 53504
// begin if GetTag ( j ) <> 0 then
52989: LD_VAR 0 3
52993: PPUSH
52994: CALL_OW 110
52998: PUSH
52999: LD_INT 0
53001: NONEQUAL
53002: IFFALSE 53006
// continue ;
53004: GO 52986
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53006: LD_VAR 0 3
53010: PPUSH
53011: CALL_OW 256
53015: PUSH
53016: LD_INT 1000
53018: LESS
53019: PUSH
53020: LD_VAR 0 3
53024: PPUSH
53025: LD_EXP 125
53029: PUSH
53030: LD_VAR 0 2
53034: ARRAY
53035: PPUSH
53036: CALL_OW 308
53040: NOT
53041: AND
53042: IFFALSE 53064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53044: LD_VAR 0 3
53048: PPUSH
53049: LD_EXP 125
53053: PUSH
53054: LD_VAR 0 2
53058: ARRAY
53059: PPUSH
53060: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53064: LD_VAR 0 3
53068: PPUSH
53069: CALL_OW 256
53073: PUSH
53074: LD_INT 1000
53076: LESS
53077: PUSH
53078: LD_VAR 0 3
53082: PPUSH
53083: LD_EXP 125
53087: PUSH
53088: LD_VAR 0 2
53092: ARRAY
53093: PPUSH
53094: CALL_OW 308
53098: AND
53099: IFFALSE 53103
// continue ;
53101: GO 52986
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53103: LD_VAR 0 3
53107: PPUSH
53108: CALL_OW 262
53112: PUSH
53113: LD_INT 2
53115: EQUAL
53116: PUSH
53117: LD_VAR 0 3
53121: PPUSH
53122: CALL_OW 261
53126: PUSH
53127: LD_INT 15
53129: LESS
53130: AND
53131: IFFALSE 53135
// continue ;
53133: GO 52986
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53135: LD_VAR 0 3
53139: PPUSH
53140: CALL_OW 262
53144: PUSH
53145: LD_INT 1
53147: EQUAL
53148: PUSH
53149: LD_VAR 0 3
53153: PPUSH
53154: CALL_OW 261
53158: PUSH
53159: LD_INT 10
53161: LESS
53162: AND
53163: IFFALSE 53443
// begin if not depot then
53165: LD_VAR 0 9
53169: NOT
53170: IFFALSE 53174
// continue ;
53172: GO 52986
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53174: LD_VAR 0 3
53178: PPUSH
53179: LD_VAR 0 9
53183: PPUSH
53184: LD_VAR 0 3
53188: PPUSH
53189: CALL_OW 74
53193: PPUSH
53194: CALL_OW 296
53198: PUSH
53199: LD_INT 6
53201: LESS
53202: IFFALSE 53218
// SetFuel ( j , 100 ) else
53204: LD_VAR 0 3
53208: PPUSH
53209: LD_INT 100
53211: PPUSH
53212: CALL_OW 240
53216: GO 53443
// if GetFuel ( j ) = 0 then
53218: LD_VAR 0 3
53222: PPUSH
53223: CALL_OW 261
53227: PUSH
53228: LD_INT 0
53230: EQUAL
53231: IFFALSE 53443
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53233: LD_ADDR_EXP 120
53237: PUSH
53238: LD_EXP 120
53242: PPUSH
53243: LD_VAR 0 2
53247: PPUSH
53248: LD_EXP 120
53252: PUSH
53253: LD_VAR 0 2
53257: ARRAY
53258: PUSH
53259: LD_VAR 0 3
53263: DIFF
53264: PPUSH
53265: CALL_OW 1
53269: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53270: LD_VAR 0 3
53274: PPUSH
53275: CALL_OW 263
53279: PUSH
53280: LD_INT 1
53282: EQUAL
53283: IFFALSE 53299
// ComExitVehicle ( IsInUnit ( j ) ) ;
53285: LD_VAR 0 3
53289: PPUSH
53290: CALL_OW 310
53294: PPUSH
53295: CALL_OW 121
// if GetControl ( j ) = control_remote then
53299: LD_VAR 0 3
53303: PPUSH
53304: CALL_OW 263
53308: PUSH
53309: LD_INT 2
53311: EQUAL
53312: IFFALSE 53323
// ComUnlink ( j ) ;
53314: LD_VAR 0 3
53318: PPUSH
53319: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53323: LD_ADDR_VAR 0 10
53327: PUSH
53328: LD_VAR 0 2
53332: PPUSH
53333: LD_INT 3
53335: PPUSH
53336: CALL 63087 0 2
53340: ST_TO_ADDR
// if fac then
53341: LD_VAR 0 10
53345: IFFALSE 53441
// begin for k in fac do
53347: LD_ADDR_VAR 0 4
53351: PUSH
53352: LD_VAR 0 10
53356: PUSH
53357: FOR_IN
53358: IFFALSE 53439
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53360: LD_ADDR_VAR 0 11
53364: PUSH
53365: LD_VAR 0 10
53369: PPUSH
53370: LD_VAR 0 3
53374: PPUSH
53375: CALL_OW 265
53379: PPUSH
53380: LD_VAR 0 3
53384: PPUSH
53385: CALL_OW 262
53389: PPUSH
53390: LD_VAR 0 3
53394: PPUSH
53395: CALL_OW 263
53399: PPUSH
53400: LD_VAR 0 3
53404: PPUSH
53405: CALL_OW 264
53409: PPUSH
53410: CALL 71518 0 5
53414: ST_TO_ADDR
// if components then
53415: LD_VAR 0 11
53419: IFFALSE 53437
// begin MC_InsertProduceList ( i , components ) ;
53421: LD_VAR 0 2
53425: PPUSH
53426: LD_VAR 0 11
53430: PPUSH
53431: CALL 62632 0 2
// break ;
53435: GO 53439
// end ; end ;
53437: GO 53357
53439: POP
53440: POP
// end ; continue ;
53441: GO 52986
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53443: LD_VAR 0 3
53447: PPUSH
53448: LD_INT 1
53450: PPUSH
53451: CALL_OW 289
53455: PUSH
53456: LD_INT 100
53458: LESS
53459: PUSH
53460: LD_VAR 0 3
53464: PPUSH
53465: CALL_OW 314
53469: NOT
53470: AND
53471: IFFALSE 53500
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53473: LD_VAR 0 3
53477: PPUSH
53478: LD_VAR 0 7
53482: PUSH
53483: LD_INT 2
53485: ARRAY
53486: PPUSH
53487: LD_VAR 0 7
53491: PUSH
53492: LD_INT 3
53494: ARRAY
53495: PPUSH
53496: CALL_OW 117
// break ;
53500: GO 53504
// end ;
53502: GO 52986
53504: POP
53505: POP
// end ; end ;
53506: GO 51702
53508: POP
53509: POP
// end ;
53510: LD_VAR 0 1
53514: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53515: LD_INT 0
53517: PPUSH
53518: PPUSH
53519: PPUSH
53520: PPUSH
// if not mc_bases then
53521: LD_EXP 101
53525: NOT
53526: IFFALSE 53530
// exit ;
53528: GO 53691
// for i = 1 to mc_bases do
53530: LD_ADDR_VAR 0 2
53534: PUSH
53535: DOUBLE
53536: LD_INT 1
53538: DEC
53539: ST_TO_ADDR
53540: LD_EXP 101
53544: PUSH
53545: FOR_TO
53546: IFFALSE 53689
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53548: LD_ADDR_VAR 0 4
53552: PUSH
53553: LD_EXP 120
53557: PUSH
53558: LD_VAR 0 2
53562: ARRAY
53563: PUSH
53564: LD_EXP 123
53568: PUSH
53569: LD_VAR 0 2
53573: ARRAY
53574: UNION
53575: PPUSH
53576: LD_INT 33
53578: PUSH
53579: LD_INT 2
53581: PUSH
53582: EMPTY
53583: LIST
53584: LIST
53585: PPUSH
53586: CALL_OW 72
53590: ST_TO_ADDR
// if tmp then
53591: LD_VAR 0 4
53595: IFFALSE 53687
// for j in tmp do
53597: LD_ADDR_VAR 0 3
53601: PUSH
53602: LD_VAR 0 4
53606: PUSH
53607: FOR_IN
53608: IFFALSE 53685
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53610: LD_VAR 0 3
53614: PPUSH
53615: CALL_OW 312
53619: NOT
53620: PUSH
53621: LD_VAR 0 3
53625: PPUSH
53626: CALL_OW 256
53630: PUSH
53631: LD_INT 250
53633: GREATEREQUAL
53634: AND
53635: IFFALSE 53648
// Connect ( j ) else
53637: LD_VAR 0 3
53641: PPUSH
53642: CALL 77366 0 1
53646: GO 53683
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
53648: LD_VAR 0 3
53652: PPUSH
53653: CALL_OW 256
53657: PUSH
53658: LD_INT 250
53660: LESS
53661: PUSH
53662: LD_VAR 0 3
53666: PPUSH
53667: CALL_OW 312
53671: AND
53672: IFFALSE 53683
// ComUnlink ( j ) ;
53674: LD_VAR 0 3
53678: PPUSH
53679: CALL_OW 136
53683: GO 53607
53685: POP
53686: POP
// end ;
53687: GO 53545
53689: POP
53690: POP
// end ;
53691: LD_VAR 0 1
53695: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
53696: LD_INT 0
53698: PPUSH
53699: PPUSH
53700: PPUSH
53701: PPUSH
53702: PPUSH
// if not mc_bases then
53703: LD_EXP 101
53707: NOT
53708: IFFALSE 53712
// exit ;
53710: GO 54157
// for i = 1 to mc_bases do
53712: LD_ADDR_VAR 0 2
53716: PUSH
53717: DOUBLE
53718: LD_INT 1
53720: DEC
53721: ST_TO_ADDR
53722: LD_EXP 101
53726: PUSH
53727: FOR_TO
53728: IFFALSE 54155
// begin if not mc_produce [ i ] then
53730: LD_EXP 122
53734: PUSH
53735: LD_VAR 0 2
53739: ARRAY
53740: NOT
53741: IFFALSE 53745
// continue ;
53743: GO 53727
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53745: LD_ADDR_VAR 0 5
53749: PUSH
53750: LD_EXP 101
53754: PUSH
53755: LD_VAR 0 2
53759: ARRAY
53760: PPUSH
53761: LD_INT 30
53763: PUSH
53764: LD_INT 3
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PPUSH
53771: CALL_OW 72
53775: ST_TO_ADDR
// if not fac then
53776: LD_VAR 0 5
53780: NOT
53781: IFFALSE 53785
// continue ;
53783: GO 53727
// for j in fac do
53785: LD_ADDR_VAR 0 3
53789: PUSH
53790: LD_VAR 0 5
53794: PUSH
53795: FOR_IN
53796: IFFALSE 54151
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
53798: LD_VAR 0 3
53802: PPUSH
53803: CALL_OW 461
53807: PUSH
53808: LD_INT 2
53810: NONEQUAL
53811: PUSH
53812: LD_VAR 0 3
53816: PPUSH
53817: LD_INT 15
53819: PPUSH
53820: CALL 76985 0 2
53824: PUSH
53825: LD_INT 4
53827: ARRAY
53828: OR
53829: IFFALSE 53833
// continue ;
53831: GO 53795
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
53833: LD_VAR 0 3
53837: PPUSH
53838: LD_EXP 122
53842: PUSH
53843: LD_VAR 0 2
53847: ARRAY
53848: PUSH
53849: LD_INT 1
53851: ARRAY
53852: PUSH
53853: LD_INT 1
53855: ARRAY
53856: PPUSH
53857: LD_EXP 122
53861: PUSH
53862: LD_VAR 0 2
53866: ARRAY
53867: PUSH
53868: LD_INT 1
53870: ARRAY
53871: PUSH
53872: LD_INT 2
53874: ARRAY
53875: PPUSH
53876: LD_EXP 122
53880: PUSH
53881: LD_VAR 0 2
53885: ARRAY
53886: PUSH
53887: LD_INT 1
53889: ARRAY
53890: PUSH
53891: LD_INT 3
53893: ARRAY
53894: PPUSH
53895: LD_EXP 122
53899: PUSH
53900: LD_VAR 0 2
53904: ARRAY
53905: PUSH
53906: LD_INT 1
53908: ARRAY
53909: PUSH
53910: LD_INT 4
53912: ARRAY
53913: PPUSH
53914: CALL_OW 448
53918: PUSH
53919: LD_VAR 0 3
53923: PPUSH
53924: LD_EXP 122
53928: PUSH
53929: LD_VAR 0 2
53933: ARRAY
53934: PUSH
53935: LD_INT 1
53937: ARRAY
53938: PUSH
53939: LD_INT 1
53941: ARRAY
53942: PUSH
53943: LD_EXP 122
53947: PUSH
53948: LD_VAR 0 2
53952: ARRAY
53953: PUSH
53954: LD_INT 1
53956: ARRAY
53957: PUSH
53958: LD_INT 2
53960: ARRAY
53961: PUSH
53962: LD_EXP 122
53966: PUSH
53967: LD_VAR 0 2
53971: ARRAY
53972: PUSH
53973: LD_INT 1
53975: ARRAY
53976: PUSH
53977: LD_INT 3
53979: ARRAY
53980: PUSH
53981: LD_EXP 122
53985: PUSH
53986: LD_VAR 0 2
53990: ARRAY
53991: PUSH
53992: LD_INT 1
53994: ARRAY
53995: PUSH
53996: LD_INT 4
53998: ARRAY
53999: PUSH
54000: EMPTY
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: PPUSH
54006: CALL 80761 0 2
54010: AND
54011: IFFALSE 54149
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54013: LD_VAR 0 3
54017: PPUSH
54018: LD_EXP 122
54022: PUSH
54023: LD_VAR 0 2
54027: ARRAY
54028: PUSH
54029: LD_INT 1
54031: ARRAY
54032: PUSH
54033: LD_INT 1
54035: ARRAY
54036: PPUSH
54037: LD_EXP 122
54041: PUSH
54042: LD_VAR 0 2
54046: ARRAY
54047: PUSH
54048: LD_INT 1
54050: ARRAY
54051: PUSH
54052: LD_INT 2
54054: ARRAY
54055: PPUSH
54056: LD_EXP 122
54060: PUSH
54061: LD_VAR 0 2
54065: ARRAY
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PUSH
54071: LD_INT 3
54073: ARRAY
54074: PPUSH
54075: LD_EXP 122
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: PUSH
54086: LD_INT 1
54088: ARRAY
54089: PUSH
54090: LD_INT 4
54092: ARRAY
54093: PPUSH
54094: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54098: LD_ADDR_VAR 0 4
54102: PUSH
54103: LD_EXP 122
54107: PUSH
54108: LD_VAR 0 2
54112: ARRAY
54113: PPUSH
54114: LD_INT 1
54116: PPUSH
54117: CALL_OW 3
54121: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54122: LD_ADDR_EXP 122
54126: PUSH
54127: LD_EXP 122
54131: PPUSH
54132: LD_VAR 0 2
54136: PPUSH
54137: LD_VAR 0 4
54141: PPUSH
54142: CALL_OW 1
54146: ST_TO_ADDR
// break ;
54147: GO 54151
// end ; end ;
54149: GO 53795
54151: POP
54152: POP
// end ;
54153: GO 53727
54155: POP
54156: POP
// end ;
54157: LD_VAR 0 1
54161: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54162: LD_INT 0
54164: PPUSH
54165: PPUSH
54166: PPUSH
// if not mc_bases then
54167: LD_EXP 101
54171: NOT
54172: IFFALSE 54176
// exit ;
54174: GO 54265
// for i = 1 to mc_bases do
54176: LD_ADDR_VAR 0 2
54180: PUSH
54181: DOUBLE
54182: LD_INT 1
54184: DEC
54185: ST_TO_ADDR
54186: LD_EXP 101
54190: PUSH
54191: FOR_TO
54192: IFFALSE 54263
// begin if mc_attack [ i ] then
54194: LD_EXP 121
54198: PUSH
54199: LD_VAR 0 2
54203: ARRAY
54204: IFFALSE 54261
// begin tmp := mc_attack [ i ] [ 1 ] ;
54206: LD_ADDR_VAR 0 3
54210: PUSH
54211: LD_EXP 121
54215: PUSH
54216: LD_VAR 0 2
54220: ARRAY
54221: PUSH
54222: LD_INT 1
54224: ARRAY
54225: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54226: LD_ADDR_EXP 121
54230: PUSH
54231: LD_EXP 121
54235: PPUSH
54236: LD_VAR 0 2
54240: PPUSH
54241: EMPTY
54242: PPUSH
54243: CALL_OW 1
54247: ST_TO_ADDR
// Attack ( tmp ) ;
54248: LD_VAR 0 3
54252: PPUSH
54253: CALL 131512 0 1
// exit ;
54257: POP
54258: POP
54259: GO 54265
// end ; end ;
54261: GO 54191
54263: POP
54264: POP
// end ;
54265: LD_VAR 0 1
54269: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54270: LD_INT 0
54272: PPUSH
54273: PPUSH
54274: PPUSH
54275: PPUSH
54276: PPUSH
54277: PPUSH
54278: PPUSH
// if not mc_bases then
54279: LD_EXP 101
54283: NOT
54284: IFFALSE 54288
// exit ;
54286: GO 55145
// for i = 1 to mc_bases do
54288: LD_ADDR_VAR 0 2
54292: PUSH
54293: DOUBLE
54294: LD_INT 1
54296: DEC
54297: ST_TO_ADDR
54298: LD_EXP 101
54302: PUSH
54303: FOR_TO
54304: IFFALSE 55143
// begin if not mc_bases [ i ] then
54306: LD_EXP 101
54310: PUSH
54311: LD_VAR 0 2
54315: ARRAY
54316: NOT
54317: IFFALSE 54321
// continue ;
54319: GO 54303
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54321: LD_ADDR_VAR 0 7
54325: PUSH
54326: LD_EXP 101
54330: PUSH
54331: LD_VAR 0 2
54335: ARRAY
54336: PUSH
54337: LD_INT 1
54339: ARRAY
54340: PPUSH
54341: CALL 70844 0 1
54345: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54346: LD_ADDR_EXP 124
54350: PUSH
54351: LD_EXP 124
54355: PPUSH
54356: LD_VAR 0 2
54360: PPUSH
54361: LD_EXP 101
54365: PUSH
54366: LD_VAR 0 2
54370: ARRAY
54371: PUSH
54372: LD_INT 1
54374: ARRAY
54375: PPUSH
54376: CALL_OW 255
54380: PPUSH
54381: LD_EXP 126
54385: PUSH
54386: LD_VAR 0 2
54390: ARRAY
54391: PPUSH
54392: CALL 70809 0 2
54396: PPUSH
54397: CALL_OW 1
54401: ST_TO_ADDR
// if not mc_scan [ i ] then
54402: LD_EXP 124
54406: PUSH
54407: LD_VAR 0 2
54411: ARRAY
54412: NOT
54413: IFFALSE 54591
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54415: LD_ADDR_EXP 144
54419: PUSH
54420: LD_EXP 144
54424: PPUSH
54425: LD_VAR 0 2
54429: PPUSH
54430: LD_INT 0
54432: PPUSH
54433: CALL_OW 1
54437: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54438: LD_ADDR_VAR 0 4
54442: PUSH
54443: LD_EXP 101
54447: PUSH
54448: LD_VAR 0 2
54452: ARRAY
54453: PPUSH
54454: LD_INT 2
54456: PUSH
54457: LD_INT 25
54459: PUSH
54460: LD_INT 5
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: PUSH
54467: LD_INT 25
54469: PUSH
54470: LD_INT 8
54472: PUSH
54473: EMPTY
54474: LIST
54475: LIST
54476: PUSH
54477: LD_INT 25
54479: PUSH
54480: LD_INT 9
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: PUSH
54487: EMPTY
54488: LIST
54489: LIST
54490: LIST
54491: LIST
54492: PPUSH
54493: CALL_OW 72
54497: ST_TO_ADDR
// if not tmp then
54498: LD_VAR 0 4
54502: NOT
54503: IFFALSE 54507
// continue ;
54505: GO 54303
// for j in tmp do
54507: LD_ADDR_VAR 0 3
54511: PUSH
54512: LD_VAR 0 4
54516: PUSH
54517: FOR_IN
54518: IFFALSE 54589
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54520: LD_VAR 0 3
54524: PPUSH
54525: CALL_OW 310
54529: PPUSH
54530: CALL_OW 266
54534: PUSH
54535: LD_INT 5
54537: EQUAL
54538: PUSH
54539: LD_VAR 0 3
54543: PPUSH
54544: CALL_OW 257
54548: PUSH
54549: LD_INT 1
54551: EQUAL
54552: AND
54553: PUSH
54554: LD_VAR 0 3
54558: PPUSH
54559: CALL_OW 459
54563: NOT
54564: AND
54565: PUSH
54566: LD_VAR 0 7
54570: AND
54571: IFFALSE 54587
// ComChangeProfession ( j , class ) ;
54573: LD_VAR 0 3
54577: PPUSH
54578: LD_VAR 0 7
54582: PPUSH
54583: CALL_OW 123
54587: GO 54517
54589: POP
54590: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54591: LD_EXP 124
54595: PUSH
54596: LD_VAR 0 2
54600: ARRAY
54601: PUSH
54602: LD_EXP 144
54606: PUSH
54607: LD_VAR 0 2
54611: ARRAY
54612: NOT
54613: AND
54614: PUSH
54615: LD_EXP 123
54619: PUSH
54620: LD_VAR 0 2
54624: ARRAY
54625: NOT
54626: AND
54627: PUSH
54628: LD_EXP 101
54632: PUSH
54633: LD_VAR 0 2
54637: ARRAY
54638: PPUSH
54639: LD_INT 50
54641: PUSH
54642: EMPTY
54643: LIST
54644: PUSH
54645: LD_INT 2
54647: PUSH
54648: LD_INT 30
54650: PUSH
54651: LD_INT 32
54653: PUSH
54654: EMPTY
54655: LIST
54656: LIST
54657: PUSH
54658: LD_INT 30
54660: PUSH
54661: LD_INT 33
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: PUSH
54668: LD_INT 30
54670: PUSH
54671: LD_INT 4
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: PUSH
54678: LD_INT 30
54680: PUSH
54681: LD_INT 5
54683: PUSH
54684: EMPTY
54685: LIST
54686: LIST
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: PUSH
54695: EMPTY
54696: LIST
54697: LIST
54698: PPUSH
54699: CALL_OW 72
54703: PUSH
54704: LD_INT 4
54706: LESS
54707: PUSH
54708: LD_EXP 101
54712: PUSH
54713: LD_VAR 0 2
54717: ARRAY
54718: PPUSH
54719: LD_INT 3
54721: PUSH
54722: LD_INT 24
54724: PUSH
54725: LD_INT 1000
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PUSH
54736: LD_INT 2
54738: PUSH
54739: LD_INT 30
54741: PUSH
54742: LD_INT 0
54744: PUSH
54745: EMPTY
54746: LIST
54747: LIST
54748: PUSH
54749: LD_INT 30
54751: PUSH
54752: LD_INT 1
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: LIST
54763: PUSH
54764: EMPTY
54765: LIST
54766: LIST
54767: PPUSH
54768: CALL_OW 72
54772: OR
54773: AND
54774: IFFALSE 55025
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54776: LD_ADDR_EXP 144
54780: PUSH
54781: LD_EXP 144
54785: PPUSH
54786: LD_VAR 0 2
54790: PPUSH
54791: LD_INT 1
54793: PPUSH
54794: CALL_OW 1
54798: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54799: LD_ADDR_VAR 0 4
54803: PUSH
54804: LD_EXP 101
54808: PUSH
54809: LD_VAR 0 2
54813: ARRAY
54814: PPUSH
54815: LD_INT 2
54817: PUSH
54818: LD_INT 25
54820: PUSH
54821: LD_INT 1
54823: PUSH
54824: EMPTY
54825: LIST
54826: LIST
54827: PUSH
54828: LD_INT 25
54830: PUSH
54831: LD_INT 5
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: PUSH
54838: LD_INT 25
54840: PUSH
54841: LD_INT 8
54843: PUSH
54844: EMPTY
54845: LIST
54846: LIST
54847: PUSH
54848: LD_INT 25
54850: PUSH
54851: LD_INT 9
54853: PUSH
54854: EMPTY
54855: LIST
54856: LIST
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: PPUSH
54865: CALL_OW 72
54869: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
54870: LD_ADDR_VAR 0 4
54874: PUSH
54875: LD_VAR 0 4
54879: PUSH
54880: LD_VAR 0 4
54884: PPUSH
54885: LD_INT 18
54887: PPUSH
54888: CALL 104329 0 2
54892: DIFF
54893: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
54894: LD_VAR 0 4
54898: NOT
54899: PUSH
54900: LD_EXP 101
54904: PUSH
54905: LD_VAR 0 2
54909: ARRAY
54910: PPUSH
54911: LD_INT 2
54913: PUSH
54914: LD_INT 30
54916: PUSH
54917: LD_INT 4
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: PUSH
54924: LD_INT 30
54926: PUSH
54927: LD_INT 5
54929: PUSH
54930: EMPTY
54931: LIST
54932: LIST
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: LIST
54938: PPUSH
54939: CALL_OW 72
54943: NOT
54944: AND
54945: IFFALSE 55007
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
54947: LD_ADDR_VAR 0 4
54951: PUSH
54952: LD_EXP 101
54956: PUSH
54957: LD_VAR 0 2
54961: ARRAY
54962: PPUSH
54963: LD_INT 2
54965: PUSH
54966: LD_INT 25
54968: PUSH
54969: LD_INT 2
54971: PUSH
54972: EMPTY
54973: LIST
54974: LIST
54975: PUSH
54976: LD_INT 25
54978: PUSH
54979: LD_INT 3
54981: PUSH
54982: EMPTY
54983: LIST
54984: LIST
54985: PUSH
54986: LD_INT 25
54988: PUSH
54989: LD_INT 4
54991: PUSH
54992: EMPTY
54993: LIST
54994: LIST
54995: PUSH
54996: EMPTY
54997: LIST
54998: LIST
54999: LIST
55000: LIST
55001: PPUSH
55002: CALL_OW 72
55006: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55007: LD_VAR 0 2
55011: PPUSH
55012: LD_VAR 0 4
55016: PPUSH
55017: CALL 136221 0 2
// exit ;
55021: POP
55022: POP
55023: GO 55145
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55025: LD_EXP 124
55029: PUSH
55030: LD_VAR 0 2
55034: ARRAY
55035: PUSH
55036: LD_EXP 144
55040: PUSH
55041: LD_VAR 0 2
55045: ARRAY
55046: NOT
55047: AND
55048: PUSH
55049: LD_EXP 123
55053: PUSH
55054: LD_VAR 0 2
55058: ARRAY
55059: AND
55060: IFFALSE 55141
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55062: LD_ADDR_EXP 144
55066: PUSH
55067: LD_EXP 144
55071: PPUSH
55072: LD_VAR 0 2
55076: PPUSH
55077: LD_INT 1
55079: PPUSH
55080: CALL_OW 1
55084: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55085: LD_ADDR_VAR 0 4
55089: PUSH
55090: LD_EXP 123
55094: PUSH
55095: LD_VAR 0 2
55099: ARRAY
55100: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55101: LD_ADDR_EXP 123
55105: PUSH
55106: LD_EXP 123
55110: PPUSH
55111: LD_VAR 0 2
55115: PPUSH
55116: EMPTY
55117: PPUSH
55118: CALL_OW 1
55122: ST_TO_ADDR
// Defend ( i , tmp ) ;
55123: LD_VAR 0 2
55127: PPUSH
55128: LD_VAR 0 4
55132: PPUSH
55133: CALL 136817 0 2
// exit ;
55137: POP
55138: POP
55139: GO 55145
// end ; end ;
55141: GO 54303
55143: POP
55144: POP
// end ;
55145: LD_VAR 0 1
55149: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55150: LD_INT 0
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
55156: PPUSH
55157: PPUSH
55158: PPUSH
55159: PPUSH
55160: PPUSH
55161: PPUSH
55162: PPUSH
// if not mc_bases then
55163: LD_EXP 101
55167: NOT
55168: IFFALSE 55172
// exit ;
55170: GO 56259
// for i = 1 to mc_bases do
55172: LD_ADDR_VAR 0 2
55176: PUSH
55177: DOUBLE
55178: LD_INT 1
55180: DEC
55181: ST_TO_ADDR
55182: LD_EXP 101
55186: PUSH
55187: FOR_TO
55188: IFFALSE 56257
// begin tmp := mc_lab [ i ] ;
55190: LD_ADDR_VAR 0 6
55194: PUSH
55195: LD_EXP 134
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: ST_TO_ADDR
// if not tmp then
55206: LD_VAR 0 6
55210: NOT
55211: IFFALSE 55215
// continue ;
55213: GO 55187
// idle_lab := 0 ;
55215: LD_ADDR_VAR 0 11
55219: PUSH
55220: LD_INT 0
55222: ST_TO_ADDR
// for j in tmp do
55223: LD_ADDR_VAR 0 3
55227: PUSH
55228: LD_VAR 0 6
55232: PUSH
55233: FOR_IN
55234: IFFALSE 56253
// begin researching := false ;
55236: LD_ADDR_VAR 0 10
55240: PUSH
55241: LD_INT 0
55243: ST_TO_ADDR
// side := GetSide ( j ) ;
55244: LD_ADDR_VAR 0 4
55248: PUSH
55249: LD_VAR 0 3
55253: PPUSH
55254: CALL_OW 255
55258: ST_TO_ADDR
// if not mc_tech [ side ] then
55259: LD_EXP 128
55263: PUSH
55264: LD_VAR 0 4
55268: ARRAY
55269: NOT
55270: IFFALSE 55274
// continue ;
55272: GO 55233
// if BuildingStatus ( j ) = bs_idle then
55274: LD_VAR 0 3
55278: PPUSH
55279: CALL_OW 461
55283: PUSH
55284: LD_INT 2
55286: EQUAL
55287: IFFALSE 55475
// begin if idle_lab and UnitsInside ( j ) < 6 then
55289: LD_VAR 0 11
55293: PUSH
55294: LD_VAR 0 3
55298: PPUSH
55299: CALL_OW 313
55303: PUSH
55304: LD_INT 6
55306: LESS
55307: AND
55308: IFFALSE 55379
// begin tmp2 := UnitsInside ( idle_lab ) ;
55310: LD_ADDR_VAR 0 9
55314: PUSH
55315: LD_VAR 0 11
55319: PPUSH
55320: CALL_OW 313
55324: ST_TO_ADDR
// if tmp2 then
55325: LD_VAR 0 9
55329: IFFALSE 55371
// for x in tmp2 do
55331: LD_ADDR_VAR 0 7
55335: PUSH
55336: LD_VAR 0 9
55340: PUSH
55341: FOR_IN
55342: IFFALSE 55369
// begin ComExitBuilding ( x ) ;
55344: LD_VAR 0 7
55348: PPUSH
55349: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55353: LD_VAR 0 7
55357: PPUSH
55358: LD_VAR 0 3
55362: PPUSH
55363: CALL_OW 180
// end ;
55367: GO 55341
55369: POP
55370: POP
// idle_lab := 0 ;
55371: LD_ADDR_VAR 0 11
55375: PUSH
55376: LD_INT 0
55378: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55379: LD_ADDR_VAR 0 5
55383: PUSH
55384: LD_EXP 128
55388: PUSH
55389: LD_VAR 0 4
55393: ARRAY
55394: PUSH
55395: FOR_IN
55396: IFFALSE 55456
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55398: LD_VAR 0 3
55402: PPUSH
55403: LD_VAR 0 5
55407: PPUSH
55408: CALL_OW 430
55412: PUSH
55413: LD_VAR 0 4
55417: PPUSH
55418: LD_VAR 0 5
55422: PPUSH
55423: CALL 69914 0 2
55427: AND
55428: IFFALSE 55454
// begin researching := true ;
55430: LD_ADDR_VAR 0 10
55434: PUSH
55435: LD_INT 1
55437: ST_TO_ADDR
// ComResearch ( j , t ) ;
55438: LD_VAR 0 3
55442: PPUSH
55443: LD_VAR 0 5
55447: PPUSH
55448: CALL_OW 124
// break ;
55452: GO 55456
// end ;
55454: GO 55395
55456: POP
55457: POP
// if not researching then
55458: LD_VAR 0 10
55462: NOT
55463: IFFALSE 55475
// idle_lab := j ;
55465: LD_ADDR_VAR 0 11
55469: PUSH
55470: LD_VAR 0 3
55474: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55475: LD_VAR 0 3
55479: PPUSH
55480: CALL_OW 461
55484: PUSH
55485: LD_INT 10
55487: EQUAL
55488: IFFALSE 56076
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55490: LD_EXP 130
55494: PUSH
55495: LD_VAR 0 2
55499: ARRAY
55500: NOT
55501: PUSH
55502: LD_EXP 131
55506: PUSH
55507: LD_VAR 0 2
55511: ARRAY
55512: NOT
55513: AND
55514: PUSH
55515: LD_EXP 128
55519: PUSH
55520: LD_VAR 0 4
55524: ARRAY
55525: PUSH
55526: LD_INT 1
55528: GREATER
55529: AND
55530: IFFALSE 55661
// begin ComCancel ( j ) ;
55532: LD_VAR 0 3
55536: PPUSH
55537: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55541: LD_ADDR_EXP 128
55545: PUSH
55546: LD_EXP 128
55550: PPUSH
55551: LD_VAR 0 4
55555: PPUSH
55556: LD_EXP 128
55560: PUSH
55561: LD_VAR 0 4
55565: ARRAY
55566: PPUSH
55567: LD_EXP 128
55571: PUSH
55572: LD_VAR 0 4
55576: ARRAY
55577: PUSH
55578: LD_INT 1
55580: MINUS
55581: PPUSH
55582: LD_EXP 128
55586: PUSH
55587: LD_VAR 0 4
55591: ARRAY
55592: PPUSH
55593: LD_INT 0
55595: PPUSH
55596: CALL 73438 0 4
55600: PPUSH
55601: CALL_OW 1
55605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55606: LD_ADDR_EXP 128
55610: PUSH
55611: LD_EXP 128
55615: PPUSH
55616: LD_VAR 0 4
55620: PPUSH
55621: LD_EXP 128
55625: PUSH
55626: LD_VAR 0 4
55630: ARRAY
55631: PPUSH
55632: LD_EXP 128
55636: PUSH
55637: LD_VAR 0 4
55641: ARRAY
55642: PPUSH
55643: LD_INT 1
55645: PPUSH
55646: LD_INT 0
55648: PPUSH
55649: CALL 73438 0 4
55653: PPUSH
55654: CALL_OW 1
55658: ST_TO_ADDR
// continue ;
55659: GO 55233
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
55661: LD_EXP 130
55665: PUSH
55666: LD_VAR 0 2
55670: ARRAY
55671: PUSH
55672: LD_EXP 131
55676: PUSH
55677: LD_VAR 0 2
55681: ARRAY
55682: NOT
55683: AND
55684: IFFALSE 55811
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
55686: LD_ADDR_EXP 131
55690: PUSH
55691: LD_EXP 131
55695: PPUSH
55696: LD_VAR 0 2
55700: PUSH
55701: LD_EXP 131
55705: PUSH
55706: LD_VAR 0 2
55710: ARRAY
55711: PUSH
55712: LD_INT 1
55714: PLUS
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: PPUSH
55720: LD_EXP 130
55724: PUSH
55725: LD_VAR 0 2
55729: ARRAY
55730: PUSH
55731: LD_INT 1
55733: ARRAY
55734: PPUSH
55735: CALL 74020 0 3
55739: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
55740: LD_EXP 130
55744: PUSH
55745: LD_VAR 0 2
55749: ARRAY
55750: PUSH
55751: LD_INT 1
55753: ARRAY
55754: PPUSH
55755: LD_INT 112
55757: PPUSH
55758: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
55762: LD_ADDR_VAR 0 9
55766: PUSH
55767: LD_EXP 130
55771: PUSH
55772: LD_VAR 0 2
55776: ARRAY
55777: PPUSH
55778: LD_INT 1
55780: PPUSH
55781: CALL_OW 3
55785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
55786: LD_ADDR_EXP 130
55790: PUSH
55791: LD_EXP 130
55795: PPUSH
55796: LD_VAR 0 2
55800: PPUSH
55801: LD_VAR 0 9
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
55811: LD_EXP 130
55815: PUSH
55816: LD_VAR 0 2
55820: ARRAY
55821: PUSH
55822: LD_EXP 131
55826: PUSH
55827: LD_VAR 0 2
55831: ARRAY
55832: AND
55833: PUSH
55834: LD_EXP 131
55838: PUSH
55839: LD_VAR 0 2
55843: ARRAY
55844: PUSH
55845: LD_INT 1
55847: ARRAY
55848: PPUSH
55849: CALL_OW 310
55853: NOT
55854: AND
55855: PUSH
55856: LD_VAR 0 3
55860: PPUSH
55861: CALL_OW 313
55865: PUSH
55866: LD_INT 6
55868: EQUAL
55869: AND
55870: IFFALSE 55926
// begin tmp2 := UnitsInside ( j ) ;
55872: LD_ADDR_VAR 0 9
55876: PUSH
55877: LD_VAR 0 3
55881: PPUSH
55882: CALL_OW 313
55886: ST_TO_ADDR
// if tmp2 = 6 then
55887: LD_VAR 0 9
55891: PUSH
55892: LD_INT 6
55894: EQUAL
55895: IFFALSE 55926
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
55897: LD_VAR 0 9
55901: PUSH
55902: LD_INT 1
55904: ARRAY
55905: PPUSH
55906: LD_INT 112
55908: PPUSH
55909: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
55913: LD_VAR 0 9
55917: PUSH
55918: LD_INT 1
55920: ARRAY
55921: PPUSH
55922: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
55926: LD_EXP 131
55930: PUSH
55931: LD_VAR 0 2
55935: ARRAY
55936: PUSH
55937: LD_EXP 131
55941: PUSH
55942: LD_VAR 0 2
55946: ARRAY
55947: PUSH
55948: LD_INT 1
55950: ARRAY
55951: PPUSH
55952: CALL_OW 314
55956: NOT
55957: AND
55958: PUSH
55959: LD_EXP 131
55963: PUSH
55964: LD_VAR 0 2
55968: ARRAY
55969: PUSH
55970: LD_INT 1
55972: ARRAY
55973: PPUSH
55974: CALL_OW 310
55978: NOT
55979: AND
55980: IFFALSE 56006
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
55982: LD_EXP 131
55986: PUSH
55987: LD_VAR 0 2
55991: ARRAY
55992: PUSH
55993: LD_INT 1
55995: ARRAY
55996: PPUSH
55997: LD_VAR 0 3
56001: PPUSH
56002: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56006: LD_EXP 131
56010: PUSH
56011: LD_VAR 0 2
56015: ARRAY
56016: PUSH
56017: LD_INT 1
56019: ARRAY
56020: PPUSH
56021: CALL_OW 310
56025: PUSH
56026: LD_EXP 131
56030: PUSH
56031: LD_VAR 0 2
56035: ARRAY
56036: PUSH
56037: LD_INT 1
56039: ARRAY
56040: PPUSH
56041: CALL_OW 310
56045: PPUSH
56046: CALL_OW 461
56050: PUSH
56051: LD_INT 3
56053: NONEQUAL
56054: AND
56055: IFFALSE 56076
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56057: LD_EXP 131
56061: PUSH
56062: LD_VAR 0 2
56066: ARRAY
56067: PUSH
56068: LD_INT 1
56070: ARRAY
56071: PPUSH
56072: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56076: LD_VAR 0 3
56080: PPUSH
56081: CALL_OW 461
56085: PUSH
56086: LD_INT 6
56088: EQUAL
56089: PUSH
56090: LD_VAR 0 6
56094: PUSH
56095: LD_INT 1
56097: GREATER
56098: AND
56099: IFFALSE 56251
// begin sci := [ ] ;
56101: LD_ADDR_VAR 0 8
56105: PUSH
56106: EMPTY
56107: ST_TO_ADDR
// for x in ( tmp diff j ) do
56108: LD_ADDR_VAR 0 7
56112: PUSH
56113: LD_VAR 0 6
56117: PUSH
56118: LD_VAR 0 3
56122: DIFF
56123: PUSH
56124: FOR_IN
56125: IFFALSE 56177
// begin if sci = 6 then
56127: LD_VAR 0 8
56131: PUSH
56132: LD_INT 6
56134: EQUAL
56135: IFFALSE 56139
// break ;
56137: GO 56177
// if BuildingStatus ( x ) = bs_idle then
56139: LD_VAR 0 7
56143: PPUSH
56144: CALL_OW 461
56148: PUSH
56149: LD_INT 2
56151: EQUAL
56152: IFFALSE 56175
// sci := sci ^ UnitsInside ( x ) ;
56154: LD_ADDR_VAR 0 8
56158: PUSH
56159: LD_VAR 0 8
56163: PUSH
56164: LD_VAR 0 7
56168: PPUSH
56169: CALL_OW 313
56173: ADD
56174: ST_TO_ADDR
// end ;
56175: GO 56124
56177: POP
56178: POP
// if not sci then
56179: LD_VAR 0 8
56183: NOT
56184: IFFALSE 56188
// continue ;
56186: GO 55233
// for x in sci do
56188: LD_ADDR_VAR 0 7
56192: PUSH
56193: LD_VAR 0 8
56197: PUSH
56198: FOR_IN
56199: IFFALSE 56249
// if IsInUnit ( x ) and not HasTask ( x ) then
56201: LD_VAR 0 7
56205: PPUSH
56206: CALL_OW 310
56210: PUSH
56211: LD_VAR 0 7
56215: PPUSH
56216: CALL_OW 314
56220: NOT
56221: AND
56222: IFFALSE 56247
// begin ComExitBuilding ( x ) ;
56224: LD_VAR 0 7
56228: PPUSH
56229: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56233: LD_VAR 0 7
56237: PPUSH
56238: LD_VAR 0 3
56242: PPUSH
56243: CALL_OW 180
// end ;
56247: GO 56198
56249: POP
56250: POP
// end ; end ;
56251: GO 55233
56253: POP
56254: POP
// end ;
56255: GO 55187
56257: POP
56258: POP
// end ;
56259: LD_VAR 0 1
56263: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56264: LD_INT 0
56266: PPUSH
56267: PPUSH
// if not mc_bases then
56268: LD_EXP 101
56272: NOT
56273: IFFALSE 56277
// exit ;
56275: GO 56358
// for i = 1 to mc_bases do
56277: LD_ADDR_VAR 0 2
56281: PUSH
56282: DOUBLE
56283: LD_INT 1
56285: DEC
56286: ST_TO_ADDR
56287: LD_EXP 101
56291: PUSH
56292: FOR_TO
56293: IFFALSE 56356
// if mc_mines [ i ] and mc_miners [ i ] then
56295: LD_EXP 114
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: PUSH
56306: LD_EXP 115
56310: PUSH
56311: LD_VAR 0 2
56315: ARRAY
56316: AND
56317: IFFALSE 56354
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56319: LD_EXP 115
56323: PUSH
56324: LD_VAR 0 2
56328: ARRAY
56329: PUSH
56330: LD_INT 1
56332: ARRAY
56333: PPUSH
56334: CALL_OW 255
56338: PPUSH
56339: LD_EXP 114
56343: PUSH
56344: LD_VAR 0 2
56348: ARRAY
56349: PPUSH
56350: CALL 70997 0 2
56354: GO 56292
56356: POP
56357: POP
// end ;
56358: LD_VAR 0 1
56362: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56363: LD_INT 0
56365: PPUSH
56366: PPUSH
56367: PPUSH
56368: PPUSH
56369: PPUSH
56370: PPUSH
56371: PPUSH
56372: PPUSH
// if not mc_bases or not mc_parking then
56373: LD_EXP 101
56377: NOT
56378: PUSH
56379: LD_EXP 125
56383: NOT
56384: OR
56385: IFFALSE 56389
// exit ;
56387: GO 57127
// for i = 1 to mc_bases do
56389: LD_ADDR_VAR 0 2
56393: PUSH
56394: DOUBLE
56395: LD_INT 1
56397: DEC
56398: ST_TO_ADDR
56399: LD_EXP 101
56403: PUSH
56404: FOR_TO
56405: IFFALSE 57125
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56407: LD_EXP 101
56411: PUSH
56412: LD_VAR 0 2
56416: ARRAY
56417: NOT
56418: PUSH
56419: LD_EXP 125
56423: PUSH
56424: LD_VAR 0 2
56428: ARRAY
56429: NOT
56430: OR
56431: IFFALSE 56435
// continue ;
56433: GO 56404
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56435: LD_ADDR_VAR 0 5
56439: PUSH
56440: LD_EXP 101
56444: PUSH
56445: LD_VAR 0 2
56449: ARRAY
56450: PUSH
56451: LD_INT 1
56453: ARRAY
56454: PPUSH
56455: CALL_OW 255
56459: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56460: LD_ADDR_VAR 0 6
56464: PUSH
56465: LD_EXP 101
56469: PUSH
56470: LD_VAR 0 2
56474: ARRAY
56475: PPUSH
56476: LD_INT 30
56478: PUSH
56479: LD_INT 3
56481: PUSH
56482: EMPTY
56483: LIST
56484: LIST
56485: PPUSH
56486: CALL_OW 72
56490: ST_TO_ADDR
// if not fac then
56491: LD_VAR 0 6
56495: NOT
56496: IFFALSE 56547
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56498: LD_ADDR_VAR 0 6
56502: PUSH
56503: LD_EXP 101
56507: PUSH
56508: LD_VAR 0 2
56512: ARRAY
56513: PPUSH
56514: LD_INT 2
56516: PUSH
56517: LD_INT 30
56519: PUSH
56520: LD_INT 0
56522: PUSH
56523: EMPTY
56524: LIST
56525: LIST
56526: PUSH
56527: LD_INT 30
56529: PUSH
56530: LD_INT 1
56532: PUSH
56533: EMPTY
56534: LIST
56535: LIST
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: LIST
56541: PPUSH
56542: CALL_OW 72
56546: ST_TO_ADDR
// if not fac then
56547: LD_VAR 0 6
56551: NOT
56552: IFFALSE 56556
// continue ;
56554: GO 56404
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56556: LD_ADDR_VAR 0 7
56560: PUSH
56561: LD_EXP 125
56565: PUSH
56566: LD_VAR 0 2
56570: ARRAY
56571: PPUSH
56572: LD_INT 22
56574: PUSH
56575: LD_VAR 0 5
56579: PUSH
56580: EMPTY
56581: LIST
56582: LIST
56583: PUSH
56584: LD_INT 21
56586: PUSH
56587: LD_INT 2
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: PUSH
56594: LD_INT 3
56596: PUSH
56597: LD_INT 60
56599: PUSH
56600: EMPTY
56601: LIST
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PUSH
56607: LD_INT 3
56609: PUSH
56610: LD_INT 24
56612: PUSH
56613: LD_INT 1000
56615: PUSH
56616: EMPTY
56617: LIST
56618: LIST
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: LIST
56628: LIST
56629: PPUSH
56630: CALL_OW 70
56634: ST_TO_ADDR
// for j in fac do
56635: LD_ADDR_VAR 0 3
56639: PUSH
56640: LD_VAR 0 6
56644: PUSH
56645: FOR_IN
56646: IFFALSE 56741
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56648: LD_ADDR_VAR 0 7
56652: PUSH
56653: LD_VAR 0 7
56657: PUSH
56658: LD_INT 22
56660: PUSH
56661: LD_VAR 0 5
56665: PUSH
56666: EMPTY
56667: LIST
56668: LIST
56669: PUSH
56670: LD_INT 91
56672: PUSH
56673: LD_VAR 0 3
56677: PUSH
56678: LD_INT 15
56680: PUSH
56681: EMPTY
56682: LIST
56683: LIST
56684: LIST
56685: PUSH
56686: LD_INT 21
56688: PUSH
56689: LD_INT 2
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: PUSH
56696: LD_INT 3
56698: PUSH
56699: LD_INT 60
56701: PUSH
56702: EMPTY
56703: LIST
56704: PUSH
56705: EMPTY
56706: LIST
56707: LIST
56708: PUSH
56709: LD_INT 3
56711: PUSH
56712: LD_INT 24
56714: PUSH
56715: LD_INT 1000
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: EMPTY
56727: LIST
56728: LIST
56729: LIST
56730: LIST
56731: LIST
56732: PPUSH
56733: CALL_OW 69
56737: UNION
56738: ST_TO_ADDR
56739: GO 56645
56741: POP
56742: POP
// if not vehs then
56743: LD_VAR 0 7
56747: NOT
56748: IFFALSE 56774
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56750: LD_ADDR_EXP 113
56754: PUSH
56755: LD_EXP 113
56759: PPUSH
56760: LD_VAR 0 2
56764: PPUSH
56765: EMPTY
56766: PPUSH
56767: CALL_OW 1
56771: ST_TO_ADDR
// continue ;
56772: GO 56404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56774: LD_ADDR_VAR 0 8
56778: PUSH
56779: LD_EXP 101
56783: PUSH
56784: LD_VAR 0 2
56788: ARRAY
56789: PPUSH
56790: LD_INT 30
56792: PUSH
56793: LD_INT 3
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PPUSH
56800: CALL_OW 72
56804: ST_TO_ADDR
// if tmp then
56805: LD_VAR 0 8
56809: IFFALSE 56912
// begin for j in tmp do
56811: LD_ADDR_VAR 0 3
56815: PUSH
56816: LD_VAR 0 8
56820: PUSH
56821: FOR_IN
56822: IFFALSE 56910
// for k in UnitsInside ( j ) do
56824: LD_ADDR_VAR 0 4
56828: PUSH
56829: LD_VAR 0 3
56833: PPUSH
56834: CALL_OW 313
56838: PUSH
56839: FOR_IN
56840: IFFALSE 56906
// if k then
56842: LD_VAR 0 4
56846: IFFALSE 56904
// if not k in mc_repair_vehicle [ i ] then
56848: LD_VAR 0 4
56852: PUSH
56853: LD_EXP 113
56857: PUSH
56858: LD_VAR 0 2
56862: ARRAY
56863: IN
56864: NOT
56865: IFFALSE 56904
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
56867: LD_ADDR_EXP 113
56871: PUSH
56872: LD_EXP 113
56876: PPUSH
56877: LD_VAR 0 2
56881: PPUSH
56882: LD_EXP 113
56886: PUSH
56887: LD_VAR 0 2
56891: ARRAY
56892: PUSH
56893: LD_VAR 0 4
56897: UNION
56898: PPUSH
56899: CALL_OW 1
56903: ST_TO_ADDR
56904: GO 56839
56906: POP
56907: POP
56908: GO 56821
56910: POP
56911: POP
// end ; if not mc_repair_vehicle [ i ] then
56912: LD_EXP 113
56916: PUSH
56917: LD_VAR 0 2
56921: ARRAY
56922: NOT
56923: IFFALSE 56927
// continue ;
56925: GO 56404
// for j in mc_repair_vehicle [ i ] do
56927: LD_ADDR_VAR 0 3
56931: PUSH
56932: LD_EXP 113
56936: PUSH
56937: LD_VAR 0 2
56941: ARRAY
56942: PUSH
56943: FOR_IN
56944: IFFALSE 57121
// begin if GetClass ( j ) <> 3 then
56946: LD_VAR 0 3
56950: PPUSH
56951: CALL_OW 257
56955: PUSH
56956: LD_INT 3
56958: NONEQUAL
56959: IFFALSE 57000
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
56961: LD_ADDR_EXP 113
56965: PUSH
56966: LD_EXP 113
56970: PPUSH
56971: LD_VAR 0 2
56975: PPUSH
56976: LD_EXP 113
56980: PUSH
56981: LD_VAR 0 2
56985: ARRAY
56986: PUSH
56987: LD_VAR 0 3
56991: DIFF
56992: PPUSH
56993: CALL_OW 1
56997: ST_TO_ADDR
// continue ;
56998: GO 56943
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57000: LD_VAR 0 3
57004: PPUSH
57005: CALL_OW 311
57009: NOT
57010: PUSH
57011: LD_VAR 0 3
57015: PUSH
57016: LD_EXP 104
57020: PUSH
57021: LD_VAR 0 2
57025: ARRAY
57026: PUSH
57027: LD_INT 1
57029: ARRAY
57030: IN
57031: NOT
57032: AND
57033: PUSH
57034: LD_VAR 0 3
57038: PUSH
57039: LD_EXP 104
57043: PUSH
57044: LD_VAR 0 2
57048: ARRAY
57049: PUSH
57050: LD_INT 2
57052: ARRAY
57053: IN
57054: NOT
57055: AND
57056: IFFALSE 57119
// begin if IsInUnit ( j ) then
57058: LD_VAR 0 3
57062: PPUSH
57063: CALL_OW 310
57067: IFFALSE 57080
// ComExitBuilding ( j ) else
57069: LD_VAR 0 3
57073: PPUSH
57074: CALL_OW 122
57078: GO 57119
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57080: LD_VAR 0 3
57084: PPUSH
57085: LD_VAR 0 7
57089: PUSH
57090: LD_INT 1
57092: ARRAY
57093: PPUSH
57094: CALL 108825 0 2
57098: NOT
57099: IFFALSE 57119
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57101: LD_VAR 0 3
57105: PPUSH
57106: LD_VAR 0 7
57110: PUSH
57111: LD_INT 1
57113: ARRAY
57114: PPUSH
57115: CALL_OW 129
// end ; end ;
57119: GO 56943
57121: POP
57122: POP
// end ;
57123: GO 56404
57125: POP
57126: POP
// end ;
57127: LD_VAR 0 1
57131: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57132: LD_INT 0
57134: PPUSH
57135: PPUSH
57136: PPUSH
57137: PPUSH
57138: PPUSH
57139: PPUSH
57140: PPUSH
57141: PPUSH
57142: PPUSH
57143: PPUSH
57144: PPUSH
// if not mc_bases then
57145: LD_EXP 101
57149: NOT
57150: IFFALSE 57154
// exit ;
57152: GO 57956
// for i = 1 to mc_bases do
57154: LD_ADDR_VAR 0 2
57158: PUSH
57159: DOUBLE
57160: LD_INT 1
57162: DEC
57163: ST_TO_ADDR
57164: LD_EXP 101
57168: PUSH
57169: FOR_TO
57170: IFFALSE 57954
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57172: LD_EXP 129
57176: PUSH
57177: LD_VAR 0 2
57181: ARRAY
57182: NOT
57183: PUSH
57184: LD_EXP 104
57188: PUSH
57189: LD_VAR 0 2
57193: ARRAY
57194: PUSH
57195: LD_INT 1
57197: ARRAY
57198: OR
57199: PUSH
57200: LD_EXP 104
57204: PUSH
57205: LD_VAR 0 2
57209: ARRAY
57210: PUSH
57211: LD_INT 2
57213: ARRAY
57214: OR
57215: PUSH
57216: LD_EXP 127
57220: PUSH
57221: LD_VAR 0 2
57225: ARRAY
57226: PPUSH
57227: LD_INT 1
57229: PPUSH
57230: CALL_OW 325
57234: NOT
57235: OR
57236: PUSH
57237: LD_EXP 124
57241: PUSH
57242: LD_VAR 0 2
57246: ARRAY
57247: OR
57248: IFFALSE 57252
// continue ;
57250: GO 57169
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57252: LD_ADDR_VAR 0 8
57256: PUSH
57257: LD_EXP 101
57261: PUSH
57262: LD_VAR 0 2
57266: ARRAY
57267: PPUSH
57268: LD_INT 25
57270: PUSH
57271: LD_INT 4
57273: PUSH
57274: EMPTY
57275: LIST
57276: LIST
57277: PUSH
57278: LD_INT 50
57280: PUSH
57281: EMPTY
57282: LIST
57283: PUSH
57284: LD_INT 3
57286: PUSH
57287: LD_INT 60
57289: PUSH
57290: EMPTY
57291: LIST
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: LIST
57301: PPUSH
57302: CALL_OW 72
57306: PUSH
57307: LD_EXP 105
57311: PUSH
57312: LD_VAR 0 2
57316: ARRAY
57317: DIFF
57318: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57319: LD_ADDR_VAR 0 9
57323: PUSH
57324: LD_EXP 101
57328: PUSH
57329: LD_VAR 0 2
57333: ARRAY
57334: PPUSH
57335: LD_INT 2
57337: PUSH
57338: LD_INT 30
57340: PUSH
57341: LD_INT 0
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: PUSH
57348: LD_INT 30
57350: PUSH
57351: LD_INT 1
57353: PUSH
57354: EMPTY
57355: LIST
57356: LIST
57357: PUSH
57358: EMPTY
57359: LIST
57360: LIST
57361: LIST
57362: PPUSH
57363: CALL_OW 72
57367: ST_TO_ADDR
// if not tmp or not dep then
57368: LD_VAR 0 8
57372: NOT
57373: PUSH
57374: LD_VAR 0 9
57378: NOT
57379: OR
57380: IFFALSE 57384
// continue ;
57382: GO 57169
// side := GetSide ( tmp [ 1 ] ) ;
57384: LD_ADDR_VAR 0 11
57388: PUSH
57389: LD_VAR 0 8
57393: PUSH
57394: LD_INT 1
57396: ARRAY
57397: PPUSH
57398: CALL_OW 255
57402: ST_TO_ADDR
// dep := dep [ 1 ] ;
57403: LD_ADDR_VAR 0 9
57407: PUSH
57408: LD_VAR 0 9
57412: PUSH
57413: LD_INT 1
57415: ARRAY
57416: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57417: LD_ADDR_VAR 0 7
57421: PUSH
57422: LD_EXP 129
57426: PUSH
57427: LD_VAR 0 2
57431: ARRAY
57432: PPUSH
57433: LD_INT 22
57435: PUSH
57436: LD_INT 0
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PUSH
57443: LD_INT 25
57445: PUSH
57446: LD_INT 12
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: PUSH
57453: EMPTY
57454: LIST
57455: LIST
57456: PPUSH
57457: CALL_OW 70
57461: PUSH
57462: LD_INT 22
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 25
57474: PUSH
57475: LD_INT 12
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: LD_INT 91
57484: PUSH
57485: LD_VAR 0 9
57489: PUSH
57490: LD_INT 20
57492: PUSH
57493: EMPTY
57494: LIST
57495: LIST
57496: LIST
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: LIST
57502: PPUSH
57503: CALL_OW 69
57507: UNION
57508: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57509: LD_ADDR_VAR 0 10
57513: PUSH
57514: LD_EXP 129
57518: PUSH
57519: LD_VAR 0 2
57523: ARRAY
57524: PPUSH
57525: LD_INT 81
57527: PUSH
57528: LD_VAR 0 11
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: PPUSH
57537: CALL_OW 70
57541: ST_TO_ADDR
// if not apes or danger_at_area then
57542: LD_VAR 0 7
57546: NOT
57547: PUSH
57548: LD_VAR 0 10
57552: OR
57553: IFFALSE 57603
// begin if mc_taming [ i ] then
57555: LD_EXP 132
57559: PUSH
57560: LD_VAR 0 2
57564: ARRAY
57565: IFFALSE 57601
// begin MC_Reset ( i , 121 ) ;
57567: LD_VAR 0 2
57571: PPUSH
57572: LD_INT 121
57574: PPUSH
57575: CALL 42519 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57579: LD_ADDR_EXP 132
57583: PUSH
57584: LD_EXP 132
57588: PPUSH
57589: LD_VAR 0 2
57593: PPUSH
57594: EMPTY
57595: PPUSH
57596: CALL_OW 1
57600: ST_TO_ADDR
// end ; continue ;
57601: GO 57169
// end ; for j in tmp do
57603: LD_ADDR_VAR 0 3
57607: PUSH
57608: LD_VAR 0 8
57612: PUSH
57613: FOR_IN
57614: IFFALSE 57950
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
57616: LD_VAR 0 3
57620: PUSH
57621: LD_EXP 132
57625: PUSH
57626: LD_VAR 0 2
57630: ARRAY
57631: IN
57632: NOT
57633: PUSH
57634: LD_EXP 132
57638: PUSH
57639: LD_VAR 0 2
57643: ARRAY
57644: PUSH
57645: LD_INT 3
57647: LESS
57648: AND
57649: IFFALSE 57707
// begin SetTag ( j , 121 ) ;
57651: LD_VAR 0 3
57655: PPUSH
57656: LD_INT 121
57658: PPUSH
57659: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
57663: LD_ADDR_EXP 132
57667: PUSH
57668: LD_EXP 132
57672: PPUSH
57673: LD_VAR 0 2
57677: PUSH
57678: LD_EXP 132
57682: PUSH
57683: LD_VAR 0 2
57687: ARRAY
57688: PUSH
57689: LD_INT 1
57691: PLUS
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: PPUSH
57697: LD_VAR 0 3
57701: PPUSH
57702: CALL 74020 0 3
57706: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
57707: LD_VAR 0 3
57711: PUSH
57712: LD_EXP 132
57716: PUSH
57717: LD_VAR 0 2
57721: ARRAY
57722: IN
57723: IFFALSE 57948
// begin if GetClass ( j ) <> 4 then
57725: LD_VAR 0 3
57729: PPUSH
57730: CALL_OW 257
57734: PUSH
57735: LD_INT 4
57737: NONEQUAL
57738: IFFALSE 57791
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
57740: LD_ADDR_EXP 132
57744: PUSH
57745: LD_EXP 132
57749: PPUSH
57750: LD_VAR 0 2
57754: PPUSH
57755: LD_EXP 132
57759: PUSH
57760: LD_VAR 0 2
57764: ARRAY
57765: PUSH
57766: LD_VAR 0 3
57770: DIFF
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57777: LD_VAR 0 3
57781: PPUSH
57782: LD_INT 0
57784: PPUSH
57785: CALL_OW 109
// continue ;
57789: GO 57613
// end ; if IsInUnit ( j ) then
57791: LD_VAR 0 3
57795: PPUSH
57796: CALL_OW 310
57800: IFFALSE 57811
// ComExitBuilding ( j ) ;
57802: LD_VAR 0 3
57806: PPUSH
57807: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
57811: LD_ADDR_VAR 0 6
57815: PUSH
57816: LD_VAR 0 7
57820: PPUSH
57821: LD_VAR 0 3
57825: PPUSH
57826: CALL_OW 74
57830: ST_TO_ADDR
// if not ape then
57831: LD_VAR 0 6
57835: NOT
57836: IFFALSE 57840
// break ;
57838: GO 57950
// x := GetX ( ape ) ;
57840: LD_ADDR_VAR 0 4
57844: PUSH
57845: LD_VAR 0 6
57849: PPUSH
57850: CALL_OW 250
57854: ST_TO_ADDR
// y := GetY ( ape ) ;
57855: LD_ADDR_VAR 0 5
57859: PUSH
57860: LD_VAR 0 6
57864: PPUSH
57865: CALL_OW 251
57869: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
57870: LD_VAR 0 4
57874: PPUSH
57875: LD_VAR 0 5
57879: PPUSH
57880: CALL_OW 488
57884: NOT
57885: PUSH
57886: LD_VAR 0 11
57890: PPUSH
57891: LD_VAR 0 4
57895: PPUSH
57896: LD_VAR 0 5
57900: PPUSH
57901: LD_INT 20
57903: PPUSH
57904: CALL 75284 0 4
57908: PUSH
57909: LD_INT 4
57911: ARRAY
57912: OR
57913: IFFALSE 57917
// break ;
57915: GO 57950
// if not HasTask ( j ) then
57917: LD_VAR 0 3
57921: PPUSH
57922: CALL_OW 314
57926: NOT
57927: IFFALSE 57948
// ComTameXY ( j , x , y ) ;
57929: LD_VAR 0 3
57933: PPUSH
57934: LD_VAR 0 4
57938: PPUSH
57939: LD_VAR 0 5
57943: PPUSH
57944: CALL_OW 131
// end ; end ;
57948: GO 57613
57950: POP
57951: POP
// end ;
57952: GO 57169
57954: POP
57955: POP
// end ;
57956: LD_VAR 0 1
57960: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
57961: LD_INT 0
57963: PPUSH
57964: PPUSH
57965: PPUSH
57966: PPUSH
57967: PPUSH
57968: PPUSH
57969: PPUSH
57970: PPUSH
// if not mc_bases then
57971: LD_EXP 101
57975: NOT
57976: IFFALSE 57980
// exit ;
57978: GO 58606
// for i = 1 to mc_bases do
57980: LD_ADDR_VAR 0 2
57984: PUSH
57985: DOUBLE
57986: LD_INT 1
57988: DEC
57989: ST_TO_ADDR
57990: LD_EXP 101
57994: PUSH
57995: FOR_TO
57996: IFFALSE 58604
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
57998: LD_EXP 130
58002: PUSH
58003: LD_VAR 0 2
58007: ARRAY
58008: NOT
58009: PUSH
58010: LD_EXP 130
58014: PUSH
58015: LD_VAR 0 2
58019: ARRAY
58020: PPUSH
58021: LD_INT 25
58023: PUSH
58024: LD_INT 12
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PPUSH
58031: CALL_OW 72
58035: NOT
58036: OR
58037: IFFALSE 58041
// continue ;
58039: GO 57995
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58041: LD_ADDR_VAR 0 5
58045: PUSH
58046: LD_EXP 130
58050: PUSH
58051: LD_VAR 0 2
58055: ARRAY
58056: PUSH
58057: LD_INT 1
58059: ARRAY
58060: PPUSH
58061: CALL_OW 255
58065: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58066: LD_VAR 0 5
58070: PPUSH
58071: LD_INT 2
58073: PPUSH
58074: CALL_OW 325
58078: IFFALSE 58331
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58080: LD_ADDR_VAR 0 4
58084: PUSH
58085: LD_EXP 130
58089: PUSH
58090: LD_VAR 0 2
58094: ARRAY
58095: PPUSH
58096: LD_INT 25
58098: PUSH
58099: LD_INT 16
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PPUSH
58106: CALL_OW 72
58110: ST_TO_ADDR
// if tmp < 6 then
58111: LD_VAR 0 4
58115: PUSH
58116: LD_INT 6
58118: LESS
58119: IFFALSE 58331
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58121: LD_ADDR_VAR 0 6
58125: PUSH
58126: LD_EXP 101
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: PPUSH
58137: LD_INT 2
58139: PUSH
58140: LD_INT 30
58142: PUSH
58143: LD_INT 0
58145: PUSH
58146: EMPTY
58147: LIST
58148: LIST
58149: PUSH
58150: LD_INT 30
58152: PUSH
58153: LD_INT 1
58155: PUSH
58156: EMPTY
58157: LIST
58158: LIST
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: LIST
58164: PPUSH
58165: CALL_OW 72
58169: ST_TO_ADDR
// if depot then
58170: LD_VAR 0 6
58174: IFFALSE 58331
// begin selected := 0 ;
58176: LD_ADDR_VAR 0 7
58180: PUSH
58181: LD_INT 0
58183: ST_TO_ADDR
// for j in depot do
58184: LD_ADDR_VAR 0 3
58188: PUSH
58189: LD_VAR 0 6
58193: PUSH
58194: FOR_IN
58195: IFFALSE 58226
// begin if UnitsInside ( j ) < 6 then
58197: LD_VAR 0 3
58201: PPUSH
58202: CALL_OW 313
58206: PUSH
58207: LD_INT 6
58209: LESS
58210: IFFALSE 58224
// begin selected := j ;
58212: LD_ADDR_VAR 0 7
58216: PUSH
58217: LD_VAR 0 3
58221: ST_TO_ADDR
// break ;
58222: GO 58226
// end ; end ;
58224: GO 58194
58226: POP
58227: POP
// if selected then
58228: LD_VAR 0 7
58232: IFFALSE 58331
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58234: LD_ADDR_VAR 0 3
58238: PUSH
58239: LD_EXP 130
58243: PUSH
58244: LD_VAR 0 2
58248: ARRAY
58249: PPUSH
58250: LD_INT 25
58252: PUSH
58253: LD_INT 12
58255: PUSH
58256: EMPTY
58257: LIST
58258: LIST
58259: PPUSH
58260: CALL_OW 72
58264: PUSH
58265: FOR_IN
58266: IFFALSE 58329
// if not HasTask ( j ) then
58268: LD_VAR 0 3
58272: PPUSH
58273: CALL_OW 314
58277: NOT
58278: IFFALSE 58327
// begin if not IsInUnit ( j ) then
58280: LD_VAR 0 3
58284: PPUSH
58285: CALL_OW 310
58289: NOT
58290: IFFALSE 58306
// ComEnterUnit ( j , selected ) ;
58292: LD_VAR 0 3
58296: PPUSH
58297: LD_VAR 0 7
58301: PPUSH
58302: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58306: LD_VAR 0 3
58310: PPUSH
58311: LD_INT 16
58313: PPUSH
58314: CALL_OW 183
// AddComExitBuilding ( j ) ;
58318: LD_VAR 0 3
58322: PPUSH
58323: CALL_OW 182
// end ;
58327: GO 58265
58329: POP
58330: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58331: LD_VAR 0 5
58335: PPUSH
58336: LD_INT 11
58338: PPUSH
58339: CALL_OW 325
58343: IFFALSE 58602
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58345: LD_ADDR_VAR 0 4
58349: PUSH
58350: LD_EXP 130
58354: PUSH
58355: LD_VAR 0 2
58359: ARRAY
58360: PPUSH
58361: LD_INT 25
58363: PUSH
58364: LD_INT 16
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: PPUSH
58371: CALL_OW 72
58375: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58376: LD_VAR 0 4
58380: PUSH
58381: LD_INT 6
58383: GREATEREQUAL
58384: PUSH
58385: LD_VAR 0 5
58389: PPUSH
58390: LD_INT 2
58392: PPUSH
58393: CALL_OW 325
58397: NOT
58398: OR
58399: IFFALSE 58602
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58401: LD_ADDR_VAR 0 8
58405: PUSH
58406: LD_EXP 101
58410: PUSH
58411: LD_VAR 0 2
58415: ARRAY
58416: PPUSH
58417: LD_INT 2
58419: PUSH
58420: LD_INT 30
58422: PUSH
58423: LD_INT 4
58425: PUSH
58426: EMPTY
58427: LIST
58428: LIST
58429: PUSH
58430: LD_INT 30
58432: PUSH
58433: LD_INT 5
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: LIST
58444: PPUSH
58445: CALL_OW 72
58449: ST_TO_ADDR
// if barracks then
58450: LD_VAR 0 8
58454: IFFALSE 58602
// begin selected := 0 ;
58456: LD_ADDR_VAR 0 7
58460: PUSH
58461: LD_INT 0
58463: ST_TO_ADDR
// for j in barracks do
58464: LD_ADDR_VAR 0 3
58468: PUSH
58469: LD_VAR 0 8
58473: PUSH
58474: FOR_IN
58475: IFFALSE 58506
// begin if UnitsInside ( j ) < 6 then
58477: LD_VAR 0 3
58481: PPUSH
58482: CALL_OW 313
58486: PUSH
58487: LD_INT 6
58489: LESS
58490: IFFALSE 58504
// begin selected := j ;
58492: LD_ADDR_VAR 0 7
58496: PUSH
58497: LD_VAR 0 3
58501: ST_TO_ADDR
// break ;
58502: GO 58506
// end ; end ;
58504: GO 58474
58506: POP
58507: POP
// if selected then
58508: LD_VAR 0 7
58512: IFFALSE 58602
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58514: LD_ADDR_VAR 0 3
58518: PUSH
58519: LD_EXP 130
58523: PUSH
58524: LD_VAR 0 2
58528: ARRAY
58529: PPUSH
58530: LD_INT 25
58532: PUSH
58533: LD_INT 12
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PPUSH
58540: CALL_OW 72
58544: PUSH
58545: FOR_IN
58546: IFFALSE 58600
// if not IsInUnit ( j ) and not HasTask ( j ) then
58548: LD_VAR 0 3
58552: PPUSH
58553: CALL_OW 310
58557: NOT
58558: PUSH
58559: LD_VAR 0 3
58563: PPUSH
58564: CALL_OW 314
58568: NOT
58569: AND
58570: IFFALSE 58598
// begin ComEnterUnit ( j , selected ) ;
58572: LD_VAR 0 3
58576: PPUSH
58577: LD_VAR 0 7
58581: PPUSH
58582: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58586: LD_VAR 0 3
58590: PPUSH
58591: LD_INT 15
58593: PPUSH
58594: CALL_OW 183
// end ;
58598: GO 58545
58600: POP
58601: POP
// end ; end ; end ; end ; end ;
58602: GO 57995
58604: POP
58605: POP
// end ;
58606: LD_VAR 0 1
58610: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58611: LD_INT 0
58613: PPUSH
58614: PPUSH
58615: PPUSH
58616: PPUSH
// if not mc_bases then
58617: LD_EXP 101
58621: NOT
58622: IFFALSE 58626
// exit ;
58624: GO 58804
// for i = 1 to mc_bases do
58626: LD_ADDR_VAR 0 2
58630: PUSH
58631: DOUBLE
58632: LD_INT 1
58634: DEC
58635: ST_TO_ADDR
58636: LD_EXP 101
58640: PUSH
58641: FOR_TO
58642: IFFALSE 58802
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
58644: LD_ADDR_VAR 0 4
58648: PUSH
58649: LD_EXP 101
58653: PUSH
58654: LD_VAR 0 2
58658: ARRAY
58659: PPUSH
58660: LD_INT 25
58662: PUSH
58663: LD_INT 9
58665: PUSH
58666: EMPTY
58667: LIST
58668: LIST
58669: PPUSH
58670: CALL_OW 72
58674: ST_TO_ADDR
// if not tmp then
58675: LD_VAR 0 4
58679: NOT
58680: IFFALSE 58684
// continue ;
58682: GO 58641
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
58684: LD_EXP 127
58688: PUSH
58689: LD_VAR 0 2
58693: ARRAY
58694: PPUSH
58695: LD_INT 29
58697: PPUSH
58698: CALL_OW 325
58702: NOT
58703: PUSH
58704: LD_EXP 127
58708: PUSH
58709: LD_VAR 0 2
58713: ARRAY
58714: PPUSH
58715: LD_INT 28
58717: PPUSH
58718: CALL_OW 325
58722: NOT
58723: AND
58724: IFFALSE 58728
// continue ;
58726: GO 58641
// for j in tmp do
58728: LD_ADDR_VAR 0 3
58732: PUSH
58733: LD_VAR 0 4
58737: PUSH
58738: FOR_IN
58739: IFFALSE 58798
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58741: LD_VAR 0 3
58745: PUSH
58746: LD_EXP 104
58750: PUSH
58751: LD_VAR 0 2
58755: ARRAY
58756: PUSH
58757: LD_INT 1
58759: ARRAY
58760: IN
58761: NOT
58762: PUSH
58763: LD_VAR 0 3
58767: PUSH
58768: LD_EXP 104
58772: PUSH
58773: LD_VAR 0 2
58777: ARRAY
58778: PUSH
58779: LD_INT 2
58781: ARRAY
58782: IN
58783: NOT
58784: AND
58785: IFFALSE 58796
// ComSpaceTimeShoot ( j ) ;
58787: LD_VAR 0 3
58791: PPUSH
58792: CALL 70005 0 1
58796: GO 58738
58798: POP
58799: POP
// end ;
58800: GO 58641
58802: POP
58803: POP
// end ;
58804: LD_VAR 0 1
58808: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
58809: LD_INT 0
58811: PPUSH
58812: PPUSH
58813: PPUSH
58814: PPUSH
58815: PPUSH
58816: PPUSH
58817: PPUSH
58818: PPUSH
58819: PPUSH
// if not mc_bases then
58820: LD_EXP 101
58824: NOT
58825: IFFALSE 58829
// exit ;
58827: GO 59451
// for i = 1 to mc_bases do
58829: LD_ADDR_VAR 0 2
58833: PUSH
58834: DOUBLE
58835: LD_INT 1
58837: DEC
58838: ST_TO_ADDR
58839: LD_EXP 101
58843: PUSH
58844: FOR_TO
58845: IFFALSE 59449
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
58847: LD_EXP 136
58851: PUSH
58852: LD_VAR 0 2
58856: ARRAY
58857: NOT
58858: PUSH
58859: LD_INT 38
58861: PPUSH
58862: LD_EXP 127
58866: PUSH
58867: LD_VAR 0 2
58871: ARRAY
58872: PPUSH
58873: CALL_OW 321
58877: PUSH
58878: LD_INT 2
58880: NONEQUAL
58881: OR
58882: IFFALSE 58886
// continue ;
58884: GO 58844
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
58886: LD_ADDR_VAR 0 8
58890: PUSH
58891: LD_EXP 101
58895: PUSH
58896: LD_VAR 0 2
58900: ARRAY
58901: PPUSH
58902: LD_INT 30
58904: PUSH
58905: LD_INT 34
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PPUSH
58912: CALL_OW 72
58916: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
58917: LD_ADDR_VAR 0 9
58921: PUSH
58922: LD_EXP 101
58926: PUSH
58927: LD_VAR 0 2
58931: ARRAY
58932: PPUSH
58933: LD_INT 25
58935: PUSH
58936: LD_INT 4
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PPUSH
58943: CALL_OW 72
58947: PPUSH
58948: LD_INT 0
58950: PPUSH
58951: CALL 104329 0 2
58955: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
58956: LD_VAR 0 9
58960: NOT
58961: PUSH
58962: LD_VAR 0 8
58966: NOT
58967: OR
58968: PUSH
58969: LD_EXP 101
58973: PUSH
58974: LD_VAR 0 2
58978: ARRAY
58979: PPUSH
58980: LD_INT 124
58982: PPUSH
58983: CALL 104329 0 2
58987: OR
58988: IFFALSE 58992
// continue ;
58990: GO 58844
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
58992: LD_EXP 137
58996: PUSH
58997: LD_VAR 0 2
59001: ARRAY
59002: PUSH
59003: LD_EXP 136
59007: PUSH
59008: LD_VAR 0 2
59012: ARRAY
59013: LESS
59014: PUSH
59015: LD_EXP 137
59019: PUSH
59020: LD_VAR 0 2
59024: ARRAY
59025: PUSH
59026: LD_VAR 0 8
59030: LESS
59031: AND
59032: IFFALSE 59447
// begin tmp := sci [ 1 ] ;
59034: LD_ADDR_VAR 0 7
59038: PUSH
59039: LD_VAR 0 9
59043: PUSH
59044: LD_INT 1
59046: ARRAY
59047: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59048: LD_VAR 0 7
59052: PPUSH
59053: LD_INT 124
59055: PPUSH
59056: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59060: LD_ADDR_VAR 0 3
59064: PUSH
59065: DOUBLE
59066: LD_EXP 136
59070: PUSH
59071: LD_VAR 0 2
59075: ARRAY
59076: INC
59077: ST_TO_ADDR
59078: LD_EXP 136
59082: PUSH
59083: LD_VAR 0 2
59087: ARRAY
59088: PUSH
59089: FOR_DOWNTO
59090: IFFALSE 59433
// begin if IsInUnit ( tmp ) then
59092: LD_VAR 0 7
59096: PPUSH
59097: CALL_OW 310
59101: IFFALSE 59112
// ComExitBuilding ( tmp ) ;
59103: LD_VAR 0 7
59107: PPUSH
59108: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59112: LD_INT 35
59114: PPUSH
59115: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59119: LD_VAR 0 7
59123: PPUSH
59124: CALL_OW 310
59128: NOT
59129: PUSH
59130: LD_VAR 0 7
59134: PPUSH
59135: CALL_OW 314
59139: NOT
59140: AND
59141: IFFALSE 59112
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59143: LD_ADDR_VAR 0 6
59147: PUSH
59148: LD_VAR 0 7
59152: PPUSH
59153: CALL_OW 250
59157: PUSH
59158: LD_VAR 0 7
59162: PPUSH
59163: CALL_OW 251
59167: PUSH
59168: EMPTY
59169: LIST
59170: LIST
59171: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59172: LD_INT 35
59174: PPUSH
59175: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59179: LD_ADDR_VAR 0 4
59183: PUSH
59184: LD_EXP 136
59188: PUSH
59189: LD_VAR 0 2
59193: ARRAY
59194: PUSH
59195: LD_VAR 0 3
59199: ARRAY
59200: PUSH
59201: LD_INT 1
59203: ARRAY
59204: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59205: LD_ADDR_VAR 0 5
59209: PUSH
59210: LD_EXP 136
59214: PUSH
59215: LD_VAR 0 2
59219: ARRAY
59220: PUSH
59221: LD_VAR 0 3
59225: ARRAY
59226: PUSH
59227: LD_INT 2
59229: ARRAY
59230: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59231: LD_VAR 0 7
59235: PPUSH
59236: LD_INT 10
59238: PPUSH
59239: CALL 76985 0 2
59243: PUSH
59244: LD_INT 4
59246: ARRAY
59247: IFFALSE 59285
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59249: LD_VAR 0 7
59253: PPUSH
59254: LD_VAR 0 6
59258: PUSH
59259: LD_INT 1
59261: ARRAY
59262: PPUSH
59263: LD_VAR 0 6
59267: PUSH
59268: LD_INT 2
59270: ARRAY
59271: PPUSH
59272: CALL_OW 111
// wait ( 0 0$10 ) ;
59276: LD_INT 350
59278: PPUSH
59279: CALL_OW 67
// end else
59283: GO 59311
// begin ComMoveXY ( tmp , x , y ) ;
59285: LD_VAR 0 7
59289: PPUSH
59290: LD_VAR 0 4
59294: PPUSH
59295: LD_VAR 0 5
59299: PPUSH
59300: CALL_OW 111
// wait ( 0 0$3 ) ;
59304: LD_INT 105
59306: PPUSH
59307: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59311: LD_VAR 0 7
59315: PPUSH
59316: LD_VAR 0 4
59320: PPUSH
59321: LD_VAR 0 5
59325: PPUSH
59326: CALL_OW 307
59330: IFFALSE 59172
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59332: LD_VAR 0 7
59336: PPUSH
59337: LD_VAR 0 4
59341: PPUSH
59342: LD_VAR 0 5
59346: PPUSH
59347: LD_VAR 0 8
59351: PUSH
59352: LD_VAR 0 3
59356: ARRAY
59357: PPUSH
59358: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59362: LD_INT 35
59364: PPUSH
59365: CALL_OW 67
// until not HasTask ( tmp ) ;
59369: LD_VAR 0 7
59373: PPUSH
59374: CALL_OW 314
59378: NOT
59379: IFFALSE 59362
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59381: LD_ADDR_EXP 137
59385: PUSH
59386: LD_EXP 137
59390: PPUSH
59391: LD_VAR 0 2
59395: PUSH
59396: LD_EXP 137
59400: PUSH
59401: LD_VAR 0 2
59405: ARRAY
59406: PUSH
59407: LD_INT 1
59409: PLUS
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: PPUSH
59415: LD_VAR 0 8
59419: PUSH
59420: LD_VAR 0 3
59424: ARRAY
59425: PPUSH
59426: CALL 74020 0 3
59430: ST_TO_ADDR
// end ;
59431: GO 59089
59433: POP
59434: POP
// MC_Reset ( i , 124 ) ;
59435: LD_VAR 0 2
59439: PPUSH
59440: LD_INT 124
59442: PPUSH
59443: CALL 42519 0 2
// end ; end ;
59447: GO 58844
59449: POP
59450: POP
// end ;
59451: LD_VAR 0 1
59455: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59456: LD_INT 0
59458: PPUSH
59459: PPUSH
59460: PPUSH
// if not mc_bases then
59461: LD_EXP 101
59465: NOT
59466: IFFALSE 59470
// exit ;
59468: GO 60076
// for i = 1 to mc_bases do
59470: LD_ADDR_VAR 0 2
59474: PUSH
59475: DOUBLE
59476: LD_INT 1
59478: DEC
59479: ST_TO_ADDR
59480: LD_EXP 101
59484: PUSH
59485: FOR_TO
59486: IFFALSE 60074
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59488: LD_ADDR_VAR 0 3
59492: PUSH
59493: LD_EXP 101
59497: PUSH
59498: LD_VAR 0 2
59502: ARRAY
59503: PPUSH
59504: LD_INT 25
59506: PUSH
59507: LD_INT 4
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PPUSH
59514: CALL_OW 72
59518: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59519: LD_VAR 0 3
59523: NOT
59524: PUSH
59525: LD_EXP 138
59529: PUSH
59530: LD_VAR 0 2
59534: ARRAY
59535: NOT
59536: OR
59537: PUSH
59538: LD_EXP 101
59542: PUSH
59543: LD_VAR 0 2
59547: ARRAY
59548: PPUSH
59549: LD_INT 2
59551: PUSH
59552: LD_INT 30
59554: PUSH
59555: LD_INT 0
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PUSH
59562: LD_INT 30
59564: PUSH
59565: LD_INT 1
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: LIST
59576: PPUSH
59577: CALL_OW 72
59581: NOT
59582: OR
59583: IFFALSE 59633
// begin if mc_deposits_finder [ i ] then
59585: LD_EXP 139
59589: PUSH
59590: LD_VAR 0 2
59594: ARRAY
59595: IFFALSE 59631
// begin MC_Reset ( i , 125 ) ;
59597: LD_VAR 0 2
59601: PPUSH
59602: LD_INT 125
59604: PPUSH
59605: CALL 42519 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59609: LD_ADDR_EXP 139
59613: PUSH
59614: LD_EXP 139
59618: PPUSH
59619: LD_VAR 0 2
59623: PPUSH
59624: EMPTY
59625: PPUSH
59626: CALL_OW 1
59630: ST_TO_ADDR
// end ; continue ;
59631: GO 59485
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
59633: LD_EXP 138
59637: PUSH
59638: LD_VAR 0 2
59642: ARRAY
59643: PUSH
59644: LD_INT 1
59646: ARRAY
59647: PUSH
59648: LD_INT 3
59650: ARRAY
59651: PUSH
59652: LD_INT 1
59654: EQUAL
59655: PUSH
59656: LD_INT 20
59658: PPUSH
59659: LD_EXP 127
59663: PUSH
59664: LD_VAR 0 2
59668: ARRAY
59669: PPUSH
59670: CALL_OW 321
59674: PUSH
59675: LD_INT 2
59677: NONEQUAL
59678: AND
59679: IFFALSE 59729
// begin if mc_deposits_finder [ i ] then
59681: LD_EXP 139
59685: PUSH
59686: LD_VAR 0 2
59690: ARRAY
59691: IFFALSE 59727
// begin MC_Reset ( i , 125 ) ;
59693: LD_VAR 0 2
59697: PPUSH
59698: LD_INT 125
59700: PPUSH
59701: CALL 42519 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59705: LD_ADDR_EXP 139
59709: PUSH
59710: LD_EXP 139
59714: PPUSH
59715: LD_VAR 0 2
59719: PPUSH
59720: EMPTY
59721: PPUSH
59722: CALL_OW 1
59726: ST_TO_ADDR
// end ; continue ;
59727: GO 59485
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
59729: LD_EXP 138
59733: PUSH
59734: LD_VAR 0 2
59738: ARRAY
59739: PUSH
59740: LD_INT 1
59742: ARRAY
59743: PUSH
59744: LD_INT 1
59746: ARRAY
59747: PPUSH
59748: LD_EXP 138
59752: PUSH
59753: LD_VAR 0 2
59757: ARRAY
59758: PUSH
59759: LD_INT 1
59761: ARRAY
59762: PUSH
59763: LD_INT 2
59765: ARRAY
59766: PPUSH
59767: LD_EXP 127
59771: PUSH
59772: LD_VAR 0 2
59776: ARRAY
59777: PPUSH
59778: CALL_OW 440
59782: IFFALSE 59825
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
59784: LD_ADDR_EXP 138
59788: PUSH
59789: LD_EXP 138
59793: PPUSH
59794: LD_VAR 0 2
59798: PPUSH
59799: LD_EXP 138
59803: PUSH
59804: LD_VAR 0 2
59808: ARRAY
59809: PPUSH
59810: LD_INT 1
59812: PPUSH
59813: CALL_OW 3
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
59823: GO 60072
// begin if not mc_deposits_finder [ i ] then
59825: LD_EXP 139
59829: PUSH
59830: LD_VAR 0 2
59834: ARRAY
59835: NOT
59836: IFFALSE 59888
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
59838: LD_ADDR_EXP 139
59842: PUSH
59843: LD_EXP 139
59847: PPUSH
59848: LD_VAR 0 2
59852: PPUSH
59853: LD_VAR 0 3
59857: PUSH
59858: LD_INT 1
59860: ARRAY
59861: PUSH
59862: EMPTY
59863: LIST
59864: PPUSH
59865: CALL_OW 1
59869: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
59870: LD_VAR 0 3
59874: PUSH
59875: LD_INT 1
59877: ARRAY
59878: PPUSH
59879: LD_INT 125
59881: PPUSH
59882: CALL_OW 109
// end else
59886: GO 60072
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
59888: LD_EXP 139
59892: PUSH
59893: LD_VAR 0 2
59897: ARRAY
59898: PUSH
59899: LD_INT 1
59901: ARRAY
59902: PPUSH
59903: CALL_OW 310
59907: IFFALSE 59930
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
59909: LD_EXP 139
59913: PUSH
59914: LD_VAR 0 2
59918: ARRAY
59919: PUSH
59920: LD_INT 1
59922: ARRAY
59923: PPUSH
59924: CALL_OW 122
59928: GO 60072
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
59930: LD_EXP 139
59934: PUSH
59935: LD_VAR 0 2
59939: ARRAY
59940: PUSH
59941: LD_INT 1
59943: ARRAY
59944: PPUSH
59945: CALL_OW 314
59949: NOT
59950: PUSH
59951: LD_EXP 139
59955: PUSH
59956: LD_VAR 0 2
59960: ARRAY
59961: PUSH
59962: LD_INT 1
59964: ARRAY
59965: PPUSH
59966: LD_EXP 138
59970: PUSH
59971: LD_VAR 0 2
59975: ARRAY
59976: PUSH
59977: LD_INT 1
59979: ARRAY
59980: PUSH
59981: LD_INT 1
59983: ARRAY
59984: PPUSH
59985: LD_EXP 138
59989: PUSH
59990: LD_VAR 0 2
59994: ARRAY
59995: PUSH
59996: LD_INT 1
59998: ARRAY
59999: PUSH
60000: LD_INT 2
60002: ARRAY
60003: PPUSH
60004: CALL_OW 297
60008: PUSH
60009: LD_INT 6
60011: GREATER
60012: AND
60013: IFFALSE 60072
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60015: LD_EXP 139
60019: PUSH
60020: LD_VAR 0 2
60024: ARRAY
60025: PUSH
60026: LD_INT 1
60028: ARRAY
60029: PPUSH
60030: LD_EXP 138
60034: PUSH
60035: LD_VAR 0 2
60039: ARRAY
60040: PUSH
60041: LD_INT 1
60043: ARRAY
60044: PUSH
60045: LD_INT 1
60047: ARRAY
60048: PPUSH
60049: LD_EXP 138
60053: PUSH
60054: LD_VAR 0 2
60058: ARRAY
60059: PUSH
60060: LD_INT 1
60062: ARRAY
60063: PUSH
60064: LD_INT 2
60066: ARRAY
60067: PPUSH
60068: CALL_OW 111
// end ; end ; end ;
60072: GO 59485
60074: POP
60075: POP
// end ;
60076: LD_VAR 0 1
60080: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60081: LD_INT 0
60083: PPUSH
60084: PPUSH
60085: PPUSH
60086: PPUSH
60087: PPUSH
60088: PPUSH
60089: PPUSH
60090: PPUSH
60091: PPUSH
60092: PPUSH
60093: PPUSH
// if not mc_bases then
60094: LD_EXP 101
60098: NOT
60099: IFFALSE 60103
// exit ;
60101: GO 61043
// for i = 1 to mc_bases do
60103: LD_ADDR_VAR 0 2
60107: PUSH
60108: DOUBLE
60109: LD_INT 1
60111: DEC
60112: ST_TO_ADDR
60113: LD_EXP 101
60117: PUSH
60118: FOR_TO
60119: IFFALSE 61041
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60121: LD_EXP 101
60125: PUSH
60126: LD_VAR 0 2
60130: ARRAY
60131: NOT
60132: PUSH
60133: LD_EXP 124
60137: PUSH
60138: LD_VAR 0 2
60142: ARRAY
60143: OR
60144: IFFALSE 60148
// continue ;
60146: GO 60118
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60148: LD_ADDR_VAR 0 7
60152: PUSH
60153: LD_EXP 101
60157: PUSH
60158: LD_VAR 0 2
60162: ARRAY
60163: PUSH
60164: LD_INT 1
60166: ARRAY
60167: PPUSH
60168: CALL_OW 248
60172: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60173: LD_VAR 0 7
60177: PUSH
60178: LD_INT 3
60180: EQUAL
60181: PUSH
60182: LD_EXP 120
60186: PUSH
60187: LD_VAR 0 2
60191: ARRAY
60192: PUSH
60193: LD_EXP 123
60197: PUSH
60198: LD_VAR 0 2
60202: ARRAY
60203: UNION
60204: PPUSH
60205: LD_INT 33
60207: PUSH
60208: LD_INT 2
60210: PUSH
60211: EMPTY
60212: LIST
60213: LIST
60214: PPUSH
60215: CALL_OW 72
60219: NOT
60220: OR
60221: IFFALSE 60225
// continue ;
60223: GO 60118
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60225: LD_ADDR_VAR 0 9
60229: PUSH
60230: LD_EXP 101
60234: PUSH
60235: LD_VAR 0 2
60239: ARRAY
60240: PPUSH
60241: LD_INT 30
60243: PUSH
60244: LD_INT 36
60246: PUSH
60247: EMPTY
60248: LIST
60249: LIST
60250: PPUSH
60251: CALL_OW 72
60255: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60256: LD_ADDR_VAR 0 10
60260: PUSH
60261: LD_EXP 120
60265: PUSH
60266: LD_VAR 0 2
60270: ARRAY
60271: PPUSH
60272: LD_INT 34
60274: PUSH
60275: LD_INT 31
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: PPUSH
60282: CALL_OW 72
60286: ST_TO_ADDR
// if not cts and not mcts then
60287: LD_VAR 0 9
60291: NOT
60292: PUSH
60293: LD_VAR 0 10
60297: NOT
60298: AND
60299: IFFALSE 60303
// continue ;
60301: GO 60118
// x := cts ;
60303: LD_ADDR_VAR 0 11
60307: PUSH
60308: LD_VAR 0 9
60312: ST_TO_ADDR
// if not x then
60313: LD_VAR 0 11
60317: NOT
60318: IFFALSE 60330
// x := mcts ;
60320: LD_ADDR_VAR 0 11
60324: PUSH
60325: LD_VAR 0 10
60329: ST_TO_ADDR
// if not x then
60330: LD_VAR 0 11
60334: NOT
60335: IFFALSE 60339
// continue ;
60337: GO 60118
// if mc_remote_driver [ i ] then
60339: LD_EXP 141
60343: PUSH
60344: LD_VAR 0 2
60348: ARRAY
60349: IFFALSE 60736
// for j in mc_remote_driver [ i ] do
60351: LD_ADDR_VAR 0 3
60355: PUSH
60356: LD_EXP 141
60360: PUSH
60361: LD_VAR 0 2
60365: ARRAY
60366: PUSH
60367: FOR_IN
60368: IFFALSE 60734
// begin if GetClass ( j ) <> 3 then
60370: LD_VAR 0 3
60374: PPUSH
60375: CALL_OW 257
60379: PUSH
60380: LD_INT 3
60382: NONEQUAL
60383: IFFALSE 60436
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60385: LD_ADDR_EXP 141
60389: PUSH
60390: LD_EXP 141
60394: PPUSH
60395: LD_VAR 0 2
60399: PPUSH
60400: LD_EXP 141
60404: PUSH
60405: LD_VAR 0 2
60409: ARRAY
60410: PUSH
60411: LD_VAR 0 3
60415: DIFF
60416: PPUSH
60417: CALL_OW 1
60421: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60422: LD_VAR 0 3
60426: PPUSH
60427: LD_INT 0
60429: PPUSH
60430: CALL_OW 109
// continue ;
60434: GO 60367
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60436: LD_EXP 120
60440: PUSH
60441: LD_VAR 0 2
60445: ARRAY
60446: PPUSH
60447: LD_INT 34
60449: PUSH
60450: LD_INT 31
60452: PUSH
60453: EMPTY
60454: LIST
60455: LIST
60456: PUSH
60457: LD_INT 58
60459: PUSH
60460: EMPTY
60461: LIST
60462: PUSH
60463: EMPTY
60464: LIST
60465: LIST
60466: PPUSH
60467: CALL_OW 72
60471: PUSH
60472: LD_VAR 0 3
60476: PPUSH
60477: CALL 104364 0 1
60481: NOT
60482: AND
60483: IFFALSE 60554
// begin if IsInUnit ( j ) then
60485: LD_VAR 0 3
60489: PPUSH
60490: CALL_OW 310
60494: IFFALSE 60505
// ComExitBuilding ( j ) ;
60496: LD_VAR 0 3
60500: PPUSH
60501: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60505: LD_VAR 0 3
60509: PPUSH
60510: LD_EXP 120
60514: PUSH
60515: LD_VAR 0 2
60519: ARRAY
60520: PPUSH
60521: LD_INT 34
60523: PUSH
60524: LD_INT 31
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: PUSH
60531: LD_INT 58
60533: PUSH
60534: EMPTY
60535: LIST
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PPUSH
60541: CALL_OW 72
60545: PUSH
60546: LD_INT 1
60548: ARRAY
60549: PPUSH
60550: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60554: LD_VAR 0 3
60558: PPUSH
60559: CALL_OW 310
60563: NOT
60564: PUSH
60565: LD_VAR 0 3
60569: PPUSH
60570: CALL_OW 310
60574: PPUSH
60575: CALL_OW 266
60579: PUSH
60580: LD_INT 36
60582: NONEQUAL
60583: PUSH
60584: LD_VAR 0 3
60588: PPUSH
60589: CALL 104364 0 1
60593: NOT
60594: AND
60595: OR
60596: IFFALSE 60732
// begin if IsInUnit ( j ) then
60598: LD_VAR 0 3
60602: PPUSH
60603: CALL_OW 310
60607: IFFALSE 60618
// ComExitBuilding ( j ) ;
60609: LD_VAR 0 3
60613: PPUSH
60614: CALL_OW 122
// ct := 0 ;
60618: LD_ADDR_VAR 0 8
60622: PUSH
60623: LD_INT 0
60625: ST_TO_ADDR
// for k in x do
60626: LD_ADDR_VAR 0 4
60630: PUSH
60631: LD_VAR 0 11
60635: PUSH
60636: FOR_IN
60637: IFFALSE 60710
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
60639: LD_VAR 0 4
60643: PPUSH
60644: CALL_OW 264
60648: PUSH
60649: LD_INT 31
60651: EQUAL
60652: PUSH
60653: LD_VAR 0 4
60657: PPUSH
60658: CALL_OW 311
60662: NOT
60663: AND
60664: PUSH
60665: LD_VAR 0 4
60669: PPUSH
60670: CALL_OW 266
60674: PUSH
60675: LD_INT 36
60677: EQUAL
60678: PUSH
60679: LD_VAR 0 4
60683: PPUSH
60684: CALL_OW 313
60688: PUSH
60689: LD_INT 3
60691: LESS
60692: AND
60693: OR
60694: IFFALSE 60708
// begin ct := k ;
60696: LD_ADDR_VAR 0 8
60700: PUSH
60701: LD_VAR 0 4
60705: ST_TO_ADDR
// break ;
60706: GO 60710
// end ;
60708: GO 60636
60710: POP
60711: POP
// if ct then
60712: LD_VAR 0 8
60716: IFFALSE 60732
// ComEnterUnit ( j , ct ) ;
60718: LD_VAR 0 3
60722: PPUSH
60723: LD_VAR 0 8
60727: PPUSH
60728: CALL_OW 120
// end ; end ;
60732: GO 60367
60734: POP
60735: POP
// places := 0 ;
60736: LD_ADDR_VAR 0 5
60740: PUSH
60741: LD_INT 0
60743: ST_TO_ADDR
// for j = 1 to x do
60744: LD_ADDR_VAR 0 3
60748: PUSH
60749: DOUBLE
60750: LD_INT 1
60752: DEC
60753: ST_TO_ADDR
60754: LD_VAR 0 11
60758: PUSH
60759: FOR_TO
60760: IFFALSE 60836
// if GetWeapon ( x [ j ] ) = ar_control_tower then
60762: LD_VAR 0 11
60766: PUSH
60767: LD_VAR 0 3
60771: ARRAY
60772: PPUSH
60773: CALL_OW 264
60777: PUSH
60778: LD_INT 31
60780: EQUAL
60781: IFFALSE 60799
// places := places + 1 else
60783: LD_ADDR_VAR 0 5
60787: PUSH
60788: LD_VAR 0 5
60792: PUSH
60793: LD_INT 1
60795: PLUS
60796: ST_TO_ADDR
60797: GO 60834
// if GetBType ( x [ j ] ) = b_control_tower then
60799: LD_VAR 0 11
60803: PUSH
60804: LD_VAR 0 3
60808: ARRAY
60809: PPUSH
60810: CALL_OW 266
60814: PUSH
60815: LD_INT 36
60817: EQUAL
60818: IFFALSE 60834
// places := places + 3 ;
60820: LD_ADDR_VAR 0 5
60824: PUSH
60825: LD_VAR 0 5
60829: PUSH
60830: LD_INT 3
60832: PLUS
60833: ST_TO_ADDR
60834: GO 60759
60836: POP
60837: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
60838: LD_VAR 0 5
60842: PUSH
60843: LD_INT 0
60845: EQUAL
60846: PUSH
60847: LD_VAR 0 5
60851: PUSH
60852: LD_EXP 141
60856: PUSH
60857: LD_VAR 0 2
60861: ARRAY
60862: LESSEQUAL
60863: OR
60864: IFFALSE 60868
// continue ;
60866: GO 60118
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
60868: LD_ADDR_VAR 0 6
60872: PUSH
60873: LD_EXP 101
60877: PUSH
60878: LD_VAR 0 2
60882: ARRAY
60883: PPUSH
60884: LD_INT 25
60886: PUSH
60887: LD_INT 3
60889: PUSH
60890: EMPTY
60891: LIST
60892: LIST
60893: PPUSH
60894: CALL_OW 72
60898: PUSH
60899: LD_EXP 141
60903: PUSH
60904: LD_VAR 0 2
60908: ARRAY
60909: DIFF
60910: PPUSH
60911: LD_INT 3
60913: PPUSH
60914: CALL 105264 0 2
60918: ST_TO_ADDR
// for j in tmp do
60919: LD_ADDR_VAR 0 3
60923: PUSH
60924: LD_VAR 0 6
60928: PUSH
60929: FOR_IN
60930: IFFALSE 60965
// if GetTag ( j ) > 0 then
60932: LD_VAR 0 3
60936: PPUSH
60937: CALL_OW 110
60941: PUSH
60942: LD_INT 0
60944: GREATER
60945: IFFALSE 60963
// tmp := tmp diff j ;
60947: LD_ADDR_VAR 0 6
60951: PUSH
60952: LD_VAR 0 6
60956: PUSH
60957: LD_VAR 0 3
60961: DIFF
60962: ST_TO_ADDR
60963: GO 60929
60965: POP
60966: POP
// if not tmp then
60967: LD_VAR 0 6
60971: NOT
60972: IFFALSE 60976
// continue ;
60974: GO 60118
// if places then
60976: LD_VAR 0 5
60980: IFFALSE 61039
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
60982: LD_ADDR_EXP 141
60986: PUSH
60987: LD_EXP 141
60991: PPUSH
60992: LD_VAR 0 2
60996: PPUSH
60997: LD_EXP 141
61001: PUSH
61002: LD_VAR 0 2
61006: ARRAY
61007: PUSH
61008: LD_VAR 0 6
61012: PUSH
61013: LD_INT 1
61015: ARRAY
61016: UNION
61017: PPUSH
61018: CALL_OW 1
61022: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61023: LD_VAR 0 6
61027: PUSH
61028: LD_INT 1
61030: ARRAY
61031: PPUSH
61032: LD_INT 126
61034: PPUSH
61035: CALL_OW 109
// end ; end ;
61039: GO 60118
61041: POP
61042: POP
// end ;
61043: LD_VAR 0 1
61047: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61048: LD_INT 0
61050: PPUSH
61051: PPUSH
61052: PPUSH
61053: PPUSH
61054: PPUSH
61055: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61056: LD_VAR 0 1
61060: NOT
61061: PUSH
61062: LD_VAR 0 2
61066: NOT
61067: OR
61068: PUSH
61069: LD_VAR 0 3
61073: NOT
61074: OR
61075: PUSH
61076: LD_VAR 0 4
61080: PUSH
61081: LD_INT 1
61083: PUSH
61084: LD_INT 2
61086: PUSH
61087: LD_INT 3
61089: PUSH
61090: LD_INT 4
61092: PUSH
61093: LD_INT 5
61095: PUSH
61096: LD_INT 8
61098: PUSH
61099: LD_INT 9
61101: PUSH
61102: LD_INT 15
61104: PUSH
61105: LD_INT 16
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: IN
61119: NOT
61120: OR
61121: IFFALSE 61125
// exit ;
61123: GO 61983
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61125: LD_ADDR_VAR 0 2
61129: PUSH
61130: LD_VAR 0 2
61134: PPUSH
61135: LD_INT 21
61137: PUSH
61138: LD_INT 3
61140: PUSH
61141: EMPTY
61142: LIST
61143: LIST
61144: PUSH
61145: LD_INT 24
61147: PUSH
61148: LD_INT 250
61150: PUSH
61151: EMPTY
61152: LIST
61153: LIST
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: PPUSH
61159: CALL_OW 72
61163: ST_TO_ADDR
// case class of 1 , 15 :
61164: LD_VAR 0 4
61168: PUSH
61169: LD_INT 1
61171: DOUBLE
61172: EQUAL
61173: IFTRUE 61183
61175: LD_INT 15
61177: DOUBLE
61178: EQUAL
61179: IFTRUE 61183
61181: GO 61268
61183: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61184: LD_ADDR_VAR 0 8
61188: PUSH
61189: LD_VAR 0 2
61193: PPUSH
61194: LD_INT 2
61196: PUSH
61197: LD_INT 30
61199: PUSH
61200: LD_INT 32
61202: PUSH
61203: EMPTY
61204: LIST
61205: LIST
61206: PUSH
61207: LD_INT 30
61209: PUSH
61210: LD_INT 31
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PUSH
61217: EMPTY
61218: LIST
61219: LIST
61220: LIST
61221: PPUSH
61222: CALL_OW 72
61226: PUSH
61227: LD_VAR 0 2
61231: PPUSH
61232: LD_INT 2
61234: PUSH
61235: LD_INT 30
61237: PUSH
61238: LD_INT 4
61240: PUSH
61241: EMPTY
61242: LIST
61243: LIST
61244: PUSH
61245: LD_INT 30
61247: PUSH
61248: LD_INT 5
61250: PUSH
61251: EMPTY
61252: LIST
61253: LIST
61254: PUSH
61255: EMPTY
61256: LIST
61257: LIST
61258: LIST
61259: PPUSH
61260: CALL_OW 72
61264: ADD
61265: ST_TO_ADDR
61266: GO 61514
61268: LD_INT 2
61270: DOUBLE
61271: EQUAL
61272: IFTRUE 61282
61274: LD_INT 16
61276: DOUBLE
61277: EQUAL
61278: IFTRUE 61282
61280: GO 61328
61282: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61283: LD_ADDR_VAR 0 8
61287: PUSH
61288: LD_VAR 0 2
61292: PPUSH
61293: LD_INT 2
61295: PUSH
61296: LD_INT 30
61298: PUSH
61299: LD_INT 0
61301: PUSH
61302: EMPTY
61303: LIST
61304: LIST
61305: PUSH
61306: LD_INT 30
61308: PUSH
61309: LD_INT 1
61311: PUSH
61312: EMPTY
61313: LIST
61314: LIST
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: LIST
61320: PPUSH
61321: CALL_OW 72
61325: ST_TO_ADDR
61326: GO 61514
61328: LD_INT 3
61330: DOUBLE
61331: EQUAL
61332: IFTRUE 61336
61334: GO 61382
61336: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61337: LD_ADDR_VAR 0 8
61341: PUSH
61342: LD_VAR 0 2
61346: PPUSH
61347: LD_INT 2
61349: PUSH
61350: LD_INT 30
61352: PUSH
61353: LD_INT 2
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: PUSH
61360: LD_INT 30
61362: PUSH
61363: LD_INT 3
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: LIST
61374: PPUSH
61375: CALL_OW 72
61379: ST_TO_ADDR
61380: GO 61514
61382: LD_INT 4
61384: DOUBLE
61385: EQUAL
61386: IFTRUE 61390
61388: GO 61447
61390: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61391: LD_ADDR_VAR 0 8
61395: PUSH
61396: LD_VAR 0 2
61400: PPUSH
61401: LD_INT 2
61403: PUSH
61404: LD_INT 30
61406: PUSH
61407: LD_INT 6
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 30
61416: PUSH
61417: LD_INT 7
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 30
61426: PUSH
61427: LD_INT 8
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: LIST
61438: LIST
61439: PPUSH
61440: CALL_OW 72
61444: ST_TO_ADDR
61445: GO 61514
61447: LD_INT 5
61449: DOUBLE
61450: EQUAL
61451: IFTRUE 61467
61453: LD_INT 8
61455: DOUBLE
61456: EQUAL
61457: IFTRUE 61467
61459: LD_INT 9
61461: DOUBLE
61462: EQUAL
61463: IFTRUE 61467
61465: GO 61513
61467: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61468: LD_ADDR_VAR 0 8
61472: PUSH
61473: LD_VAR 0 2
61477: PPUSH
61478: LD_INT 2
61480: PUSH
61481: LD_INT 30
61483: PUSH
61484: LD_INT 4
61486: PUSH
61487: EMPTY
61488: LIST
61489: LIST
61490: PUSH
61491: LD_INT 30
61493: PUSH
61494: LD_INT 5
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: EMPTY
61502: LIST
61503: LIST
61504: LIST
61505: PPUSH
61506: CALL_OW 72
61510: ST_TO_ADDR
61511: GO 61514
61513: POP
// if not tmp then
61514: LD_VAR 0 8
61518: NOT
61519: IFFALSE 61523
// exit ;
61521: GO 61983
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61523: LD_VAR 0 4
61527: PUSH
61528: LD_INT 1
61530: PUSH
61531: LD_INT 15
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: IN
61538: PUSH
61539: LD_EXP 110
61543: PUSH
61544: LD_VAR 0 1
61548: ARRAY
61549: AND
61550: IFFALSE 61706
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61552: LD_ADDR_VAR 0 9
61556: PUSH
61557: LD_EXP 110
61561: PUSH
61562: LD_VAR 0 1
61566: ARRAY
61567: PUSH
61568: LD_INT 1
61570: ARRAY
61571: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61572: LD_VAR 0 9
61576: PUSH
61577: LD_EXP 111
61581: PUSH
61582: LD_VAR 0 1
61586: ARRAY
61587: IN
61588: NOT
61589: IFFALSE 61704
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61591: LD_ADDR_EXP 111
61595: PUSH
61596: LD_EXP 111
61600: PPUSH
61601: LD_VAR 0 1
61605: PUSH
61606: LD_EXP 111
61610: PUSH
61611: LD_VAR 0 1
61615: ARRAY
61616: PUSH
61617: LD_INT 1
61619: PLUS
61620: PUSH
61621: EMPTY
61622: LIST
61623: LIST
61624: PPUSH
61625: LD_VAR 0 9
61629: PPUSH
61630: CALL 74020 0 3
61634: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
61635: LD_ADDR_EXP 110
61639: PUSH
61640: LD_EXP 110
61644: PPUSH
61645: LD_VAR 0 1
61649: PPUSH
61650: LD_EXP 110
61654: PUSH
61655: LD_VAR 0 1
61659: ARRAY
61660: PUSH
61661: LD_VAR 0 9
61665: DIFF
61666: PPUSH
61667: CALL_OW 1
61671: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
61672: LD_VAR 0 3
61676: PPUSH
61677: LD_EXP 111
61681: PUSH
61682: LD_VAR 0 1
61686: ARRAY
61687: PUSH
61688: LD_EXP 111
61692: PUSH
61693: LD_VAR 0 1
61697: ARRAY
61698: ARRAY
61699: PPUSH
61700: CALL_OW 120
// end ; exit ;
61704: GO 61983
// end ; if tmp > 1 then
61706: LD_VAR 0 8
61710: PUSH
61711: LD_INT 1
61713: GREATER
61714: IFFALSE 61818
// for i = 2 to tmp do
61716: LD_ADDR_VAR 0 6
61720: PUSH
61721: DOUBLE
61722: LD_INT 2
61724: DEC
61725: ST_TO_ADDR
61726: LD_VAR 0 8
61730: PUSH
61731: FOR_TO
61732: IFFALSE 61816
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
61734: LD_VAR 0 8
61738: PUSH
61739: LD_VAR 0 6
61743: ARRAY
61744: PPUSH
61745: CALL_OW 461
61749: PUSH
61750: LD_INT 6
61752: EQUAL
61753: IFFALSE 61814
// begin x := tmp [ i ] ;
61755: LD_ADDR_VAR 0 9
61759: PUSH
61760: LD_VAR 0 8
61764: PUSH
61765: LD_VAR 0 6
61769: ARRAY
61770: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
61771: LD_ADDR_VAR 0 8
61775: PUSH
61776: LD_VAR 0 8
61780: PPUSH
61781: LD_VAR 0 6
61785: PPUSH
61786: CALL_OW 3
61790: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
61791: LD_ADDR_VAR 0 8
61795: PUSH
61796: LD_VAR 0 8
61800: PPUSH
61801: LD_INT 1
61803: PPUSH
61804: LD_VAR 0 9
61808: PPUSH
61809: CALL_OW 2
61813: ST_TO_ADDR
// end ;
61814: GO 61731
61816: POP
61817: POP
// for i in tmp do
61818: LD_ADDR_VAR 0 6
61822: PUSH
61823: LD_VAR 0 8
61827: PUSH
61828: FOR_IN
61829: IFFALSE 61856
// begin if IsNotFull ( i ) then
61831: LD_VAR 0 6
61835: PPUSH
61836: CALL 71242 0 1
61840: IFFALSE 61854
// begin j := i ;
61842: LD_ADDR_VAR 0 7
61846: PUSH
61847: LD_VAR 0 6
61851: ST_TO_ADDR
// break ;
61852: GO 61856
// end ; end ;
61854: GO 61828
61856: POP
61857: POP
// if j then
61858: LD_VAR 0 7
61862: IFFALSE 61880
// ComEnterUnit ( unit , j ) else
61864: LD_VAR 0 3
61868: PPUSH
61869: LD_VAR 0 7
61873: PPUSH
61874: CALL_OW 120
61878: GO 61983
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61880: LD_ADDR_VAR 0 10
61884: PUSH
61885: LD_VAR 0 2
61889: PPUSH
61890: LD_INT 2
61892: PUSH
61893: LD_INT 30
61895: PUSH
61896: LD_INT 0
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: PUSH
61903: LD_INT 30
61905: PUSH
61906: LD_INT 1
61908: PUSH
61909: EMPTY
61910: LIST
61911: LIST
61912: PUSH
61913: EMPTY
61914: LIST
61915: LIST
61916: LIST
61917: PPUSH
61918: CALL_OW 72
61922: ST_TO_ADDR
// if depot then
61923: LD_VAR 0 10
61927: IFFALSE 61983
// begin depot := NearestUnitToUnit ( depot , unit ) ;
61929: LD_ADDR_VAR 0 10
61933: PUSH
61934: LD_VAR 0 10
61938: PPUSH
61939: LD_VAR 0 3
61943: PPUSH
61944: CALL_OW 74
61948: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
61949: LD_VAR 0 3
61953: PPUSH
61954: LD_VAR 0 10
61958: PPUSH
61959: CALL_OW 296
61963: PUSH
61964: LD_INT 10
61966: GREATER
61967: IFFALSE 61983
// ComStandNearbyBuilding ( unit , depot ) ;
61969: LD_VAR 0 3
61973: PPUSH
61974: LD_VAR 0 10
61978: PPUSH
61979: CALL 70622 0 2
// end ; end ; end ;
61983: LD_VAR 0 5
61987: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
61988: LD_INT 0
61990: PPUSH
61991: PPUSH
61992: PPUSH
61993: PPUSH
// if not mc_bases then
61994: LD_EXP 101
61998: NOT
61999: IFFALSE 62003
// exit ;
62001: GO 62242
// for i = 1 to mc_bases do
62003: LD_ADDR_VAR 0 2
62007: PUSH
62008: DOUBLE
62009: LD_INT 1
62011: DEC
62012: ST_TO_ADDR
62013: LD_EXP 101
62017: PUSH
62018: FOR_TO
62019: IFFALSE 62240
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62021: LD_ADDR_VAR 0 4
62025: PUSH
62026: LD_EXP 101
62030: PUSH
62031: LD_VAR 0 2
62035: ARRAY
62036: PPUSH
62037: LD_INT 21
62039: PUSH
62040: LD_INT 1
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: PPUSH
62047: CALL_OW 72
62051: PUSH
62052: LD_EXP 130
62056: PUSH
62057: LD_VAR 0 2
62061: ARRAY
62062: UNION
62063: ST_TO_ADDR
// if not tmp then
62064: LD_VAR 0 4
62068: NOT
62069: IFFALSE 62073
// continue ;
62071: GO 62018
// for j in tmp do
62073: LD_ADDR_VAR 0 3
62077: PUSH
62078: LD_VAR 0 4
62082: PUSH
62083: FOR_IN
62084: IFFALSE 62236
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62086: LD_VAR 0 3
62090: PPUSH
62091: CALL_OW 110
62095: NOT
62096: PUSH
62097: LD_VAR 0 3
62101: PPUSH
62102: CALL_OW 314
62106: NOT
62107: AND
62108: PUSH
62109: LD_VAR 0 3
62113: PPUSH
62114: CALL_OW 311
62118: NOT
62119: AND
62120: PUSH
62121: LD_VAR 0 3
62125: PPUSH
62126: CALL_OW 310
62130: NOT
62131: AND
62132: PUSH
62133: LD_VAR 0 3
62137: PUSH
62138: LD_EXP 104
62142: PUSH
62143: LD_VAR 0 2
62147: ARRAY
62148: PUSH
62149: LD_INT 1
62151: ARRAY
62152: IN
62153: NOT
62154: AND
62155: PUSH
62156: LD_VAR 0 3
62160: PUSH
62161: LD_EXP 104
62165: PUSH
62166: LD_VAR 0 2
62170: ARRAY
62171: PUSH
62172: LD_INT 2
62174: ARRAY
62175: IN
62176: NOT
62177: AND
62178: PUSH
62179: LD_VAR 0 3
62183: PUSH
62184: LD_EXP 113
62188: PUSH
62189: LD_VAR 0 2
62193: ARRAY
62194: IN
62195: NOT
62196: AND
62197: IFFALSE 62234
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62199: LD_VAR 0 2
62203: PPUSH
62204: LD_EXP 101
62208: PUSH
62209: LD_VAR 0 2
62213: ARRAY
62214: PPUSH
62215: LD_VAR 0 3
62219: PPUSH
62220: LD_VAR 0 3
62224: PPUSH
62225: CALL_OW 257
62229: PPUSH
62230: CALL 61048 0 4
// end ;
62234: GO 62083
62236: POP
62237: POP
// end ;
62238: GO 62018
62240: POP
62241: POP
// end ;
62242: LD_VAR 0 1
62246: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62247: LD_INT 0
62249: PPUSH
62250: PPUSH
62251: PPUSH
62252: PPUSH
62253: PPUSH
62254: PPUSH
// if not mc_bases [ base ] then
62255: LD_EXP 101
62259: PUSH
62260: LD_VAR 0 1
62264: ARRAY
62265: NOT
62266: IFFALSE 62270
// exit ;
62268: GO 62471
// tmp := [ ] ;
62270: LD_ADDR_VAR 0 6
62274: PUSH
62275: EMPTY
62276: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62277: LD_ADDR_VAR 0 7
62281: PUSH
62282: LD_VAR 0 3
62286: PPUSH
62287: LD_INT 0
62289: PPUSH
62290: CALL_OW 517
62294: ST_TO_ADDR
// if not list then
62295: LD_VAR 0 7
62299: NOT
62300: IFFALSE 62304
// exit ;
62302: GO 62471
// c := Count ( list [ 1 ] ) ;
62304: LD_ADDR_VAR 0 9
62308: PUSH
62309: LD_VAR 0 7
62313: PUSH
62314: LD_INT 1
62316: ARRAY
62317: PPUSH
62318: CALL 71160 0 1
62322: ST_TO_ADDR
// if amount > c then
62323: LD_VAR 0 2
62327: PUSH
62328: LD_VAR 0 9
62332: GREATER
62333: IFFALSE 62345
// amount := c ;
62335: LD_ADDR_VAR 0 2
62339: PUSH
62340: LD_VAR 0 9
62344: ST_TO_ADDR
// for i := 1 to amount do
62345: LD_ADDR_VAR 0 5
62349: PUSH
62350: DOUBLE
62351: LD_INT 1
62353: DEC
62354: ST_TO_ADDR
62355: LD_VAR 0 2
62359: PUSH
62360: FOR_TO
62361: IFFALSE 62419
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62363: LD_ADDR_VAR 0 6
62367: PUSH
62368: LD_VAR 0 6
62372: PPUSH
62373: LD_VAR 0 5
62377: PPUSH
62378: LD_VAR 0 7
62382: PUSH
62383: LD_INT 1
62385: ARRAY
62386: PUSH
62387: LD_VAR 0 5
62391: ARRAY
62392: PUSH
62393: LD_VAR 0 7
62397: PUSH
62398: LD_INT 2
62400: ARRAY
62401: PUSH
62402: LD_VAR 0 5
62406: ARRAY
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: PPUSH
62412: CALL_OW 1
62416: ST_TO_ADDR
62417: GO 62360
62419: POP
62420: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62421: LD_ADDR_EXP 114
62425: PUSH
62426: LD_EXP 114
62430: PPUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: LD_VAR 0 6
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62446: LD_ADDR_EXP 116
62450: PUSH
62451: LD_EXP 116
62455: PPUSH
62456: LD_VAR 0 1
62460: PPUSH
62461: LD_VAR 0 3
62465: PPUSH
62466: CALL_OW 1
62470: ST_TO_ADDR
// end ;
62471: LD_VAR 0 4
62475: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62476: LD_INT 0
62478: PPUSH
// if not mc_bases [ base ] then
62479: LD_EXP 101
62483: PUSH
62484: LD_VAR 0 1
62488: ARRAY
62489: NOT
62490: IFFALSE 62494
// exit ;
62492: GO 62519
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62494: LD_ADDR_EXP 106
62498: PUSH
62499: LD_EXP 106
62503: PPUSH
62504: LD_VAR 0 1
62508: PPUSH
62509: LD_VAR 0 2
62513: PPUSH
62514: CALL_OW 1
62518: ST_TO_ADDR
// end ;
62519: LD_VAR 0 3
62523: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62524: LD_INT 0
62526: PPUSH
// if not mc_bases [ base ] then
62527: LD_EXP 101
62531: PUSH
62532: LD_VAR 0 1
62536: ARRAY
62537: NOT
62538: IFFALSE 62542
// exit ;
62540: GO 62579
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62542: LD_ADDR_EXP 106
62546: PUSH
62547: LD_EXP 106
62551: PPUSH
62552: LD_VAR 0 1
62556: PPUSH
62557: LD_EXP 106
62561: PUSH
62562: LD_VAR 0 1
62566: ARRAY
62567: PUSH
62568: LD_VAR 0 2
62572: UNION
62573: PPUSH
62574: CALL_OW 1
62578: ST_TO_ADDR
// end ;
62579: LD_VAR 0 3
62583: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62584: LD_INT 0
62586: PPUSH
// if not mc_bases [ base ] then
62587: LD_EXP 101
62591: PUSH
62592: LD_VAR 0 1
62596: ARRAY
62597: NOT
62598: IFFALSE 62602
// exit ;
62600: GO 62627
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62602: LD_ADDR_EXP 122
62606: PUSH
62607: LD_EXP 122
62611: PPUSH
62612: LD_VAR 0 1
62616: PPUSH
62617: LD_VAR 0 2
62621: PPUSH
62622: CALL_OW 1
62626: ST_TO_ADDR
// end ;
62627: LD_VAR 0 3
62631: RET
// export function MC_InsertProduceList ( base , components ) ; begin
62632: LD_INT 0
62634: PPUSH
// if not mc_bases [ base ] then
62635: LD_EXP 101
62639: PUSH
62640: LD_VAR 0 1
62644: ARRAY
62645: NOT
62646: IFFALSE 62650
// exit ;
62648: GO 62687
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
62650: LD_ADDR_EXP 122
62654: PUSH
62655: LD_EXP 122
62659: PPUSH
62660: LD_VAR 0 1
62664: PPUSH
62665: LD_EXP 122
62669: PUSH
62670: LD_VAR 0 1
62674: ARRAY
62675: PUSH
62676: LD_VAR 0 2
62680: ADD
62681: PPUSH
62682: CALL_OW 1
62686: ST_TO_ADDR
// end ;
62687: LD_VAR 0 3
62691: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
62692: LD_INT 0
62694: PPUSH
// if not mc_bases [ base ] then
62695: LD_EXP 101
62699: PUSH
62700: LD_VAR 0 1
62704: ARRAY
62705: NOT
62706: IFFALSE 62710
// exit ;
62708: GO 62764
// mc_defender := Replace ( mc_defender , base , deflist ) ;
62710: LD_ADDR_EXP 123
62714: PUSH
62715: LD_EXP 123
62719: PPUSH
62720: LD_VAR 0 1
62724: PPUSH
62725: LD_VAR 0 2
62729: PPUSH
62730: CALL_OW 1
62734: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
62735: LD_ADDR_EXP 112
62739: PUSH
62740: LD_EXP 112
62744: PPUSH
62745: LD_VAR 0 1
62749: PPUSH
62750: LD_VAR 0 2
62754: PUSH
62755: LD_INT 0
62757: PLUS
62758: PPUSH
62759: CALL_OW 1
62763: ST_TO_ADDR
// end ;
62764: LD_VAR 0 3
62768: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
62769: LD_INT 0
62771: PPUSH
// if not mc_bases [ base ] then
62772: LD_EXP 101
62776: PUSH
62777: LD_VAR 0 1
62781: ARRAY
62782: NOT
62783: IFFALSE 62787
// exit ;
62785: GO 62812
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
62787: LD_ADDR_EXP 112
62791: PUSH
62792: LD_EXP 112
62796: PPUSH
62797: LD_VAR 0 1
62801: PPUSH
62802: LD_VAR 0 2
62806: PPUSH
62807: CALL_OW 1
62811: ST_TO_ADDR
// end ;
62812: LD_VAR 0 3
62816: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
62817: LD_INT 0
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
// if not mc_bases [ base ] then
62823: LD_EXP 101
62827: PUSH
62828: LD_VAR 0 1
62832: ARRAY
62833: NOT
62834: IFFALSE 62838
// exit ;
62836: GO 62903
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
62838: LD_ADDR_EXP 121
62842: PUSH
62843: LD_EXP 121
62847: PPUSH
62848: LD_VAR 0 1
62852: PUSH
62853: LD_EXP 121
62857: PUSH
62858: LD_VAR 0 1
62862: ARRAY
62863: PUSH
62864: LD_INT 1
62866: PLUS
62867: PUSH
62868: EMPTY
62869: LIST
62870: LIST
62871: PPUSH
62872: LD_VAR 0 1
62876: PUSH
62877: LD_VAR 0 2
62881: PUSH
62882: LD_VAR 0 3
62886: PUSH
62887: LD_VAR 0 4
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: PPUSH
62898: CALL 74020 0 3
62902: ST_TO_ADDR
// end ;
62903: LD_VAR 0 5
62907: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
62908: LD_INT 0
62910: PPUSH
// if not mc_bases [ base ] then
62911: LD_EXP 101
62915: PUSH
62916: LD_VAR 0 1
62920: ARRAY
62921: NOT
62922: IFFALSE 62926
// exit ;
62924: GO 62951
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
62926: LD_ADDR_EXP 138
62930: PUSH
62931: LD_EXP 138
62935: PPUSH
62936: LD_VAR 0 1
62940: PPUSH
62941: LD_VAR 0 2
62945: PPUSH
62946: CALL_OW 1
62950: ST_TO_ADDR
// end ;
62951: LD_VAR 0 3
62955: RET
// export function MC_GetMinesField ( base ) ; begin
62956: LD_INT 0
62958: PPUSH
// result := mc_mines [ base ] ;
62959: LD_ADDR_VAR 0 2
62963: PUSH
62964: LD_EXP 114
62968: PUSH
62969: LD_VAR 0 1
62973: ARRAY
62974: ST_TO_ADDR
// end ;
62975: LD_VAR 0 2
62979: RET
// export function MC_GetProduceList ( base ) ; begin
62980: LD_INT 0
62982: PPUSH
// result := mc_produce [ base ] ;
62983: LD_ADDR_VAR 0 2
62987: PUSH
62988: LD_EXP 122
62992: PUSH
62993: LD_VAR 0 1
62997: ARRAY
62998: ST_TO_ADDR
// end ;
62999: LD_VAR 0 2
63003: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63004: LD_INT 0
63006: PPUSH
63007: PPUSH
// if not mc_bases then
63008: LD_EXP 101
63012: NOT
63013: IFFALSE 63017
// exit ;
63015: GO 63082
// if mc_bases [ base ] then
63017: LD_EXP 101
63021: PUSH
63022: LD_VAR 0 1
63026: ARRAY
63027: IFFALSE 63082
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63029: LD_ADDR_VAR 0 3
63033: PUSH
63034: LD_EXP 101
63038: PUSH
63039: LD_VAR 0 1
63043: ARRAY
63044: PPUSH
63045: LD_INT 30
63047: PUSH
63048: LD_VAR 0 2
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PPUSH
63057: CALL_OW 72
63061: ST_TO_ADDR
// if result then
63062: LD_VAR 0 3
63066: IFFALSE 63082
// result := result [ 1 ] ;
63068: LD_ADDR_VAR 0 3
63072: PUSH
63073: LD_VAR 0 3
63077: PUSH
63078: LD_INT 1
63080: ARRAY
63081: ST_TO_ADDR
// end ; end ;
63082: LD_VAR 0 3
63086: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63087: LD_INT 0
63089: PPUSH
63090: PPUSH
// if not mc_bases then
63091: LD_EXP 101
63095: NOT
63096: IFFALSE 63100
// exit ;
63098: GO 63145
// if mc_bases [ base ] then
63100: LD_EXP 101
63104: PUSH
63105: LD_VAR 0 1
63109: ARRAY
63110: IFFALSE 63145
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63112: LD_ADDR_VAR 0 3
63116: PUSH
63117: LD_EXP 101
63121: PUSH
63122: LD_VAR 0 1
63126: ARRAY
63127: PPUSH
63128: LD_INT 30
63130: PUSH
63131: LD_VAR 0 2
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: PPUSH
63140: CALL_OW 72
63144: ST_TO_ADDR
// end ;
63145: LD_VAR 0 3
63149: RET
// export function MC_SetTame ( base , area ) ; begin
63150: LD_INT 0
63152: PPUSH
// if not mc_bases or not base then
63153: LD_EXP 101
63157: NOT
63158: PUSH
63159: LD_VAR 0 1
63163: NOT
63164: OR
63165: IFFALSE 63169
// exit ;
63167: GO 63194
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63169: LD_ADDR_EXP 129
63173: PUSH
63174: LD_EXP 129
63178: PPUSH
63179: LD_VAR 0 1
63183: PPUSH
63184: LD_VAR 0 2
63188: PPUSH
63189: CALL_OW 1
63193: ST_TO_ADDR
// end ;
63194: LD_VAR 0 3
63198: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63199: LD_INT 0
63201: PPUSH
63202: PPUSH
// if not mc_bases or not base then
63203: LD_EXP 101
63207: NOT
63208: PUSH
63209: LD_VAR 0 1
63213: NOT
63214: OR
63215: IFFALSE 63219
// exit ;
63217: GO 63321
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63219: LD_ADDR_VAR 0 4
63223: PUSH
63224: LD_EXP 101
63228: PUSH
63229: LD_VAR 0 1
63233: ARRAY
63234: PPUSH
63235: LD_INT 30
63237: PUSH
63238: LD_VAR 0 2
63242: PUSH
63243: EMPTY
63244: LIST
63245: LIST
63246: PPUSH
63247: CALL_OW 72
63251: ST_TO_ADDR
// if not tmp then
63252: LD_VAR 0 4
63256: NOT
63257: IFFALSE 63261
// exit ;
63259: GO 63321
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63261: LD_ADDR_EXP 133
63265: PUSH
63266: LD_EXP 133
63270: PPUSH
63271: LD_VAR 0 1
63275: PPUSH
63276: LD_EXP 133
63280: PUSH
63281: LD_VAR 0 1
63285: ARRAY
63286: PPUSH
63287: LD_EXP 133
63291: PUSH
63292: LD_VAR 0 1
63296: ARRAY
63297: PUSH
63298: LD_INT 1
63300: PLUS
63301: PPUSH
63302: LD_VAR 0 4
63306: PUSH
63307: LD_INT 1
63309: ARRAY
63310: PPUSH
63311: CALL_OW 2
63315: PPUSH
63316: CALL_OW 1
63320: ST_TO_ADDR
// end ;
63321: LD_VAR 0 3
63325: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63326: LD_INT 0
63328: PPUSH
63329: PPUSH
// if not mc_bases or not base or not kinds then
63330: LD_EXP 101
63334: NOT
63335: PUSH
63336: LD_VAR 0 1
63340: NOT
63341: OR
63342: PUSH
63343: LD_VAR 0 2
63347: NOT
63348: OR
63349: IFFALSE 63353
// exit ;
63351: GO 63414
// for i in kinds do
63353: LD_ADDR_VAR 0 4
63357: PUSH
63358: LD_VAR 0 2
63362: PUSH
63363: FOR_IN
63364: IFFALSE 63412
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63366: LD_ADDR_EXP 135
63370: PUSH
63371: LD_EXP 135
63375: PPUSH
63376: LD_VAR 0 1
63380: PUSH
63381: LD_EXP 135
63385: PUSH
63386: LD_VAR 0 1
63390: ARRAY
63391: PUSH
63392: LD_INT 1
63394: PLUS
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: PPUSH
63400: LD_VAR 0 4
63404: PPUSH
63405: CALL 74020 0 3
63409: ST_TO_ADDR
63410: GO 63363
63412: POP
63413: POP
// end ;
63414: LD_VAR 0 3
63418: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63419: LD_INT 0
63421: PPUSH
// if not mc_bases or not base or not areas then
63422: LD_EXP 101
63426: NOT
63427: PUSH
63428: LD_VAR 0 1
63432: NOT
63433: OR
63434: PUSH
63435: LD_VAR 0 2
63439: NOT
63440: OR
63441: IFFALSE 63445
// exit ;
63443: GO 63470
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63445: LD_ADDR_EXP 119
63449: PUSH
63450: LD_EXP 119
63454: PPUSH
63455: LD_VAR 0 1
63459: PPUSH
63460: LD_VAR 0 2
63464: PPUSH
63465: CALL_OW 1
63469: ST_TO_ADDR
// end ;
63470: LD_VAR 0 3
63474: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63475: LD_INT 0
63477: PPUSH
// if not mc_bases or not base or not teleports_exit then
63478: LD_EXP 101
63482: NOT
63483: PUSH
63484: LD_VAR 0 1
63488: NOT
63489: OR
63490: PUSH
63491: LD_VAR 0 2
63495: NOT
63496: OR
63497: IFFALSE 63501
// exit ;
63499: GO 63526
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63501: LD_ADDR_EXP 136
63505: PUSH
63506: LD_EXP 136
63510: PPUSH
63511: LD_VAR 0 1
63515: PPUSH
63516: LD_VAR 0 2
63520: PPUSH
63521: CALL_OW 1
63525: ST_TO_ADDR
// end ;
63526: LD_VAR 0 3
63530: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63531: LD_INT 0
63533: PPUSH
63534: PPUSH
63535: PPUSH
// if not mc_bases or not base or not ext_list then
63536: LD_EXP 101
63540: NOT
63541: PUSH
63542: LD_VAR 0 1
63546: NOT
63547: OR
63548: PUSH
63549: LD_VAR 0 5
63553: NOT
63554: OR
63555: IFFALSE 63559
// exit ;
63557: GO 63732
// tmp := GetFacExtXYD ( x , y , d ) ;
63559: LD_ADDR_VAR 0 8
63563: PUSH
63564: LD_VAR 0 2
63568: PPUSH
63569: LD_VAR 0 3
63573: PPUSH
63574: LD_VAR 0 4
63578: PPUSH
63579: CALL 104394 0 3
63583: ST_TO_ADDR
// if not tmp then
63584: LD_VAR 0 8
63588: NOT
63589: IFFALSE 63593
// exit ;
63591: GO 63732
// for i in tmp do
63593: LD_ADDR_VAR 0 7
63597: PUSH
63598: LD_VAR 0 8
63602: PUSH
63603: FOR_IN
63604: IFFALSE 63730
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63606: LD_ADDR_EXP 106
63610: PUSH
63611: LD_EXP 106
63615: PPUSH
63616: LD_VAR 0 1
63620: PPUSH
63621: LD_EXP 106
63625: PUSH
63626: LD_VAR 0 1
63630: ARRAY
63631: PPUSH
63632: LD_EXP 106
63636: PUSH
63637: LD_VAR 0 1
63641: ARRAY
63642: PUSH
63643: LD_INT 1
63645: PLUS
63646: PPUSH
63647: LD_VAR 0 5
63651: PUSH
63652: LD_INT 1
63654: ARRAY
63655: PUSH
63656: LD_VAR 0 7
63660: PUSH
63661: LD_INT 1
63663: ARRAY
63664: PUSH
63665: LD_VAR 0 7
63669: PUSH
63670: LD_INT 2
63672: ARRAY
63673: PUSH
63674: LD_VAR 0 7
63678: PUSH
63679: LD_INT 3
63681: ARRAY
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: LIST
63687: LIST
63688: PPUSH
63689: CALL_OW 2
63693: PPUSH
63694: CALL_OW 1
63698: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
63699: LD_ADDR_VAR 0 5
63703: PUSH
63704: LD_VAR 0 5
63708: PPUSH
63709: LD_INT 1
63711: PPUSH
63712: CALL_OW 3
63716: ST_TO_ADDR
// if not ext_list then
63717: LD_VAR 0 5
63721: NOT
63722: IFFALSE 63728
// exit ;
63724: POP
63725: POP
63726: GO 63732
// end ;
63728: GO 63603
63730: POP
63731: POP
// end ;
63732: LD_VAR 0 6
63736: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
63737: LD_INT 0
63739: PPUSH
// if not mc_bases or not base or not weapon_list then
63740: LD_EXP 101
63744: NOT
63745: PUSH
63746: LD_VAR 0 1
63750: NOT
63751: OR
63752: PUSH
63753: LD_VAR 0 2
63757: NOT
63758: OR
63759: IFFALSE 63763
// exit ;
63761: GO 63788
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
63763: LD_ADDR_EXP 140
63767: PUSH
63768: LD_EXP 140
63772: PPUSH
63773: LD_VAR 0 1
63777: PPUSH
63778: LD_VAR 0 2
63782: PPUSH
63783: CALL_OW 1
63787: ST_TO_ADDR
// end ;
63788: LD_VAR 0 3
63792: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
63793: LD_INT 0
63795: PPUSH
// if not mc_bases or not base or not tech_list then
63796: LD_EXP 101
63800: NOT
63801: PUSH
63802: LD_VAR 0 1
63806: NOT
63807: OR
63808: PUSH
63809: LD_VAR 0 2
63813: NOT
63814: OR
63815: IFFALSE 63819
// exit ;
63817: GO 63844
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
63819: LD_ADDR_EXP 128
63823: PUSH
63824: LD_EXP 128
63828: PPUSH
63829: LD_VAR 0 1
63833: PPUSH
63834: LD_VAR 0 2
63838: PPUSH
63839: CALL_OW 1
63843: ST_TO_ADDR
// end ;
63844: LD_VAR 0 3
63848: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
63849: LD_INT 0
63851: PPUSH
// if not mc_bases or not parking_area or not base then
63852: LD_EXP 101
63856: NOT
63857: PUSH
63858: LD_VAR 0 2
63862: NOT
63863: OR
63864: PUSH
63865: LD_VAR 0 1
63869: NOT
63870: OR
63871: IFFALSE 63875
// exit ;
63873: GO 63900
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
63875: LD_ADDR_EXP 125
63879: PUSH
63880: LD_EXP 125
63884: PPUSH
63885: LD_VAR 0 1
63889: PPUSH
63890: LD_VAR 0 2
63894: PPUSH
63895: CALL_OW 1
63899: ST_TO_ADDR
// end ;
63900: LD_VAR 0 3
63904: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
63905: LD_INT 0
63907: PPUSH
// if not mc_bases or not base or not scan_area then
63908: LD_EXP 101
63912: NOT
63913: PUSH
63914: LD_VAR 0 1
63918: NOT
63919: OR
63920: PUSH
63921: LD_VAR 0 2
63925: NOT
63926: OR
63927: IFFALSE 63931
// exit ;
63929: GO 63956
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
63931: LD_ADDR_EXP 126
63935: PUSH
63936: LD_EXP 126
63940: PPUSH
63941: LD_VAR 0 1
63945: PPUSH
63946: LD_VAR 0 2
63950: PPUSH
63951: CALL_OW 1
63955: ST_TO_ADDR
// end ;
63956: LD_VAR 0 3
63960: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
63961: LD_INT 0
63963: PPUSH
63964: PPUSH
// if not mc_bases or not base then
63965: LD_EXP 101
63969: NOT
63970: PUSH
63971: LD_VAR 0 1
63975: NOT
63976: OR
63977: IFFALSE 63981
// exit ;
63979: GO 64045
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
63981: LD_ADDR_VAR 0 3
63985: PUSH
63986: LD_INT 1
63988: PUSH
63989: LD_INT 2
63991: PUSH
63992: LD_INT 3
63994: PUSH
63995: LD_INT 4
63997: PUSH
63998: LD_INT 11
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: LIST
64005: LIST
64006: LIST
64007: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64008: LD_ADDR_EXP 128
64012: PUSH
64013: LD_EXP 128
64017: PPUSH
64018: LD_VAR 0 1
64022: PPUSH
64023: LD_EXP 128
64027: PUSH
64028: LD_VAR 0 1
64032: ARRAY
64033: PUSH
64034: LD_VAR 0 3
64038: DIFF
64039: PPUSH
64040: CALL_OW 1
64044: ST_TO_ADDR
// end ;
64045: LD_VAR 0 2
64049: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64050: LD_INT 0
64052: PPUSH
// result := mc_vehicles [ base ] ;
64053: LD_ADDR_VAR 0 3
64057: PUSH
64058: LD_EXP 120
64062: PUSH
64063: LD_VAR 0 1
64067: ARRAY
64068: ST_TO_ADDR
// if onlyCombat then
64069: LD_VAR 0 2
64073: IFFALSE 64245
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64075: LD_ADDR_VAR 0 3
64079: PUSH
64080: LD_VAR 0 3
64084: PUSH
64085: LD_VAR 0 3
64089: PPUSH
64090: LD_INT 2
64092: PUSH
64093: LD_INT 34
64095: PUSH
64096: LD_INT 12
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 34
64105: PUSH
64106: LD_INT 51
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 34
64115: PUSH
64116: LD_INT 89
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: LD_INT 34
64125: PUSH
64126: LD_INT 32
64128: PUSH
64129: EMPTY
64130: LIST
64131: LIST
64132: PUSH
64133: LD_INT 34
64135: PUSH
64136: LD_INT 13
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PUSH
64143: LD_INT 34
64145: PUSH
64146: LD_INT 52
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 34
64155: PUSH
64156: LD_INT 88
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 34
64165: PUSH
64166: LD_INT 14
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PUSH
64173: LD_INT 34
64175: PUSH
64176: LD_INT 53
64178: PUSH
64179: EMPTY
64180: LIST
64181: LIST
64182: PUSH
64183: LD_INT 34
64185: PUSH
64186: LD_INT 98
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 34
64195: PUSH
64196: LD_INT 31
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 34
64205: PUSH
64206: LD_INT 48
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: LD_INT 34
64215: PUSH
64216: LD_INT 8
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: EMPTY
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: PPUSH
64239: CALL_OW 72
64243: DIFF
64244: ST_TO_ADDR
// end ; end_of_file
64245: LD_VAR 0 3
64249: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64250: LD_INT 0
64252: PPUSH
64253: PPUSH
64254: PPUSH
// if not mc_bases or not skirmish then
64255: LD_EXP 101
64259: NOT
64260: PUSH
64261: LD_EXP 99
64265: NOT
64266: OR
64267: IFFALSE 64271
// exit ;
64269: GO 64436
// for i = 1 to mc_bases do
64271: LD_ADDR_VAR 0 4
64275: PUSH
64276: DOUBLE
64277: LD_INT 1
64279: DEC
64280: ST_TO_ADDR
64281: LD_EXP 101
64285: PUSH
64286: FOR_TO
64287: IFFALSE 64434
// begin if sci in mc_bases [ i ] then
64289: LD_VAR 0 2
64293: PUSH
64294: LD_EXP 101
64298: PUSH
64299: LD_VAR 0 4
64303: ARRAY
64304: IN
64305: IFFALSE 64432
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64307: LD_ADDR_EXP 130
64311: PUSH
64312: LD_EXP 130
64316: PPUSH
64317: LD_VAR 0 4
64321: PUSH
64322: LD_EXP 130
64326: PUSH
64327: LD_VAR 0 4
64331: ARRAY
64332: PUSH
64333: LD_INT 1
64335: PLUS
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PPUSH
64341: LD_VAR 0 1
64345: PPUSH
64346: CALL 74020 0 3
64350: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64351: LD_ADDR_VAR 0 5
64355: PUSH
64356: LD_EXP 101
64360: PUSH
64361: LD_VAR 0 4
64365: ARRAY
64366: PPUSH
64367: LD_INT 2
64369: PUSH
64370: LD_INT 30
64372: PUSH
64373: LD_INT 0
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 30
64382: PUSH
64383: LD_INT 1
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: EMPTY
64391: LIST
64392: LIST
64393: LIST
64394: PPUSH
64395: CALL_OW 72
64399: PPUSH
64400: LD_VAR 0 1
64404: PPUSH
64405: CALL_OW 74
64409: ST_TO_ADDR
// if tmp then
64410: LD_VAR 0 5
64414: IFFALSE 64430
// ComStandNearbyBuilding ( ape , tmp ) ;
64416: LD_VAR 0 1
64420: PPUSH
64421: LD_VAR 0 5
64425: PPUSH
64426: CALL 70622 0 2
// break ;
64430: GO 64434
// end ; end ;
64432: GO 64286
64434: POP
64435: POP
// end ;
64436: LD_VAR 0 3
64440: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64441: LD_INT 0
64443: PPUSH
64444: PPUSH
64445: PPUSH
// if not mc_bases or not skirmish then
64446: LD_EXP 101
64450: NOT
64451: PUSH
64452: LD_EXP 99
64456: NOT
64457: OR
64458: IFFALSE 64462
// exit ;
64460: GO 64551
// for i = 1 to mc_bases do
64462: LD_ADDR_VAR 0 4
64466: PUSH
64467: DOUBLE
64468: LD_INT 1
64470: DEC
64471: ST_TO_ADDR
64472: LD_EXP 101
64476: PUSH
64477: FOR_TO
64478: IFFALSE 64549
// begin if building in mc_busy_turret_list [ i ] then
64480: LD_VAR 0 1
64484: PUSH
64485: LD_EXP 111
64489: PUSH
64490: LD_VAR 0 4
64494: ARRAY
64495: IN
64496: IFFALSE 64547
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64498: LD_ADDR_VAR 0 5
64502: PUSH
64503: LD_EXP 111
64507: PUSH
64508: LD_VAR 0 4
64512: ARRAY
64513: PUSH
64514: LD_VAR 0 1
64518: DIFF
64519: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64520: LD_ADDR_EXP 111
64524: PUSH
64525: LD_EXP 111
64529: PPUSH
64530: LD_VAR 0 4
64534: PPUSH
64535: LD_VAR 0 5
64539: PPUSH
64540: CALL_OW 1
64544: ST_TO_ADDR
// break ;
64545: GO 64549
// end ; end ;
64547: GO 64477
64549: POP
64550: POP
// end ;
64551: LD_VAR 0 3
64555: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64556: LD_INT 0
64558: PPUSH
64559: PPUSH
64560: PPUSH
// if not mc_bases or not skirmish then
64561: LD_EXP 101
64565: NOT
64566: PUSH
64567: LD_EXP 99
64571: NOT
64572: OR
64573: IFFALSE 64577
// exit ;
64575: GO 64776
// for i = 1 to mc_bases do
64577: LD_ADDR_VAR 0 5
64581: PUSH
64582: DOUBLE
64583: LD_INT 1
64585: DEC
64586: ST_TO_ADDR
64587: LD_EXP 101
64591: PUSH
64592: FOR_TO
64593: IFFALSE 64774
// if building in mc_bases [ i ] then
64595: LD_VAR 0 1
64599: PUSH
64600: LD_EXP 101
64604: PUSH
64605: LD_VAR 0 5
64609: ARRAY
64610: IN
64611: IFFALSE 64772
// begin tmp := mc_bases [ i ] diff building ;
64613: LD_ADDR_VAR 0 6
64617: PUSH
64618: LD_EXP 101
64622: PUSH
64623: LD_VAR 0 5
64627: ARRAY
64628: PUSH
64629: LD_VAR 0 1
64633: DIFF
64634: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
64635: LD_ADDR_EXP 101
64639: PUSH
64640: LD_EXP 101
64644: PPUSH
64645: LD_VAR 0 5
64649: PPUSH
64650: LD_VAR 0 6
64654: PPUSH
64655: CALL_OW 1
64659: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
64660: LD_VAR 0 1
64664: PUSH
64665: LD_EXP 109
64669: PUSH
64670: LD_VAR 0 5
64674: ARRAY
64675: IN
64676: IFFALSE 64715
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
64678: LD_ADDR_EXP 109
64682: PUSH
64683: LD_EXP 109
64687: PPUSH
64688: LD_VAR 0 5
64692: PPUSH
64693: LD_EXP 109
64697: PUSH
64698: LD_VAR 0 5
64702: ARRAY
64703: PUSH
64704: LD_VAR 0 1
64708: DIFF
64709: PPUSH
64710: CALL_OW 1
64714: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
64715: LD_VAR 0 1
64719: PUSH
64720: LD_EXP 110
64724: PUSH
64725: LD_VAR 0 5
64729: ARRAY
64730: IN
64731: IFFALSE 64770
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
64733: LD_ADDR_EXP 110
64737: PUSH
64738: LD_EXP 110
64742: PPUSH
64743: LD_VAR 0 5
64747: PPUSH
64748: LD_EXP 110
64752: PUSH
64753: LD_VAR 0 5
64757: ARRAY
64758: PUSH
64759: LD_VAR 0 1
64763: DIFF
64764: PPUSH
64765: CALL_OW 1
64769: ST_TO_ADDR
// break ;
64770: GO 64774
// end ;
64772: GO 64592
64774: POP
64775: POP
// end ;
64776: LD_VAR 0 4
64780: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
64781: LD_INT 0
64783: PPUSH
64784: PPUSH
64785: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
64786: LD_EXP 101
64790: NOT
64791: PUSH
64792: LD_EXP 99
64796: NOT
64797: OR
64798: PUSH
64799: LD_VAR 0 3
64803: PUSH
64804: LD_EXP 127
64808: IN
64809: NOT
64810: OR
64811: IFFALSE 64815
// exit ;
64813: GO 64938
// for i = 1 to mc_vehicles do
64815: LD_ADDR_VAR 0 6
64819: PUSH
64820: DOUBLE
64821: LD_INT 1
64823: DEC
64824: ST_TO_ADDR
64825: LD_EXP 120
64829: PUSH
64830: FOR_TO
64831: IFFALSE 64936
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
64833: LD_VAR 0 2
64837: PUSH
64838: LD_EXP 120
64842: PUSH
64843: LD_VAR 0 6
64847: ARRAY
64848: IN
64849: PUSH
64850: LD_VAR 0 1
64854: PUSH
64855: LD_EXP 120
64859: PUSH
64860: LD_VAR 0 6
64864: ARRAY
64865: IN
64866: OR
64867: IFFALSE 64934
// begin tmp := mc_vehicles [ i ] diff old ;
64869: LD_ADDR_VAR 0 7
64873: PUSH
64874: LD_EXP 120
64878: PUSH
64879: LD_VAR 0 6
64883: ARRAY
64884: PUSH
64885: LD_VAR 0 2
64889: DIFF
64890: ST_TO_ADDR
// tmp := tmp diff new ;
64891: LD_ADDR_VAR 0 7
64895: PUSH
64896: LD_VAR 0 7
64900: PUSH
64901: LD_VAR 0 1
64905: DIFF
64906: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
64907: LD_ADDR_EXP 120
64911: PUSH
64912: LD_EXP 120
64916: PPUSH
64917: LD_VAR 0 6
64921: PPUSH
64922: LD_VAR 0 7
64926: PPUSH
64927: CALL_OW 1
64931: ST_TO_ADDR
// break ;
64932: GO 64936
// end ;
64934: GO 64830
64936: POP
64937: POP
// end ;
64938: LD_VAR 0 5
64942: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
64943: LD_INT 0
64945: PPUSH
64946: PPUSH
64947: PPUSH
64948: PPUSH
// if not mc_bases or not skirmish then
64949: LD_EXP 101
64953: NOT
64954: PUSH
64955: LD_EXP 99
64959: NOT
64960: OR
64961: IFFALSE 64965
// exit ;
64963: GO 65385
// repeat wait ( 0 0$1 ) ;
64965: LD_INT 35
64967: PPUSH
64968: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
64972: LD_EXP 145
64976: NOT
64977: IFFALSE 64965
// mc_block_vehicle_constructed_thread := true ;
64979: LD_ADDR_EXP 145
64983: PUSH
64984: LD_INT 1
64986: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
64987: LD_ADDR_VAR 0 5
64991: PUSH
64992: LD_VAR 0 1
64996: PPUSH
64997: CALL_OW 255
65001: ST_TO_ADDR
// for i = 1 to mc_bases do
65002: LD_ADDR_VAR 0 4
65006: PUSH
65007: DOUBLE
65008: LD_INT 1
65010: DEC
65011: ST_TO_ADDR
65012: LD_EXP 101
65016: PUSH
65017: FOR_TO
65018: IFFALSE 65375
// begin if factory in mc_bases [ i ] then
65020: LD_VAR 0 2
65024: PUSH
65025: LD_EXP 101
65029: PUSH
65030: LD_VAR 0 4
65034: ARRAY
65035: IN
65036: IFFALSE 65373
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65038: LD_EXP 123
65042: PUSH
65043: LD_VAR 0 4
65047: ARRAY
65048: PUSH
65049: LD_EXP 112
65053: PUSH
65054: LD_VAR 0 4
65058: ARRAY
65059: LESS
65060: PUSH
65061: LD_VAR 0 1
65065: PPUSH
65066: CALL_OW 264
65070: PUSH
65071: LD_INT 31
65073: PUSH
65074: LD_INT 32
65076: PUSH
65077: LD_INT 51
65079: PUSH
65080: LD_INT 89
65082: PUSH
65083: LD_INT 12
65085: PUSH
65086: LD_INT 30
65088: PUSH
65089: LD_INT 98
65091: PUSH
65092: LD_INT 11
65094: PUSH
65095: LD_INT 53
65097: PUSH
65098: LD_INT 14
65100: PUSH
65101: LD_INT 91
65103: PUSH
65104: LD_INT 29
65106: PUSH
65107: LD_INT 99
65109: PUSH
65110: LD_INT 13
65112: PUSH
65113: LD_INT 52
65115: PUSH
65116: LD_INT 88
65118: PUSH
65119: LD_INT 48
65121: PUSH
65122: LD_INT 8
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: LIST
65129: LIST
65130: LIST
65131: LIST
65132: LIST
65133: LIST
65134: LIST
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: IN
65145: NOT
65146: AND
65147: IFFALSE 65195
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65149: LD_ADDR_EXP 123
65153: PUSH
65154: LD_EXP 123
65158: PPUSH
65159: LD_VAR 0 4
65163: PUSH
65164: LD_EXP 123
65168: PUSH
65169: LD_VAR 0 4
65173: ARRAY
65174: PUSH
65175: LD_INT 1
65177: PLUS
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: PPUSH
65183: LD_VAR 0 1
65187: PPUSH
65188: CALL 74020 0 3
65192: ST_TO_ADDR
65193: GO 65239
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65195: LD_ADDR_EXP 120
65199: PUSH
65200: LD_EXP 120
65204: PPUSH
65205: LD_VAR 0 4
65209: PUSH
65210: LD_EXP 120
65214: PUSH
65215: LD_VAR 0 4
65219: ARRAY
65220: PUSH
65221: LD_INT 1
65223: PLUS
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PPUSH
65229: LD_VAR 0 1
65233: PPUSH
65234: CALL 74020 0 3
65238: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65239: LD_ADDR_EXP 145
65243: PUSH
65244: LD_INT 0
65246: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65247: LD_VAR 0 1
65251: PPUSH
65252: CALL_OW 263
65256: PUSH
65257: LD_INT 2
65259: EQUAL
65260: IFFALSE 65289
// begin repeat wait ( 0 0$3 ) ;
65262: LD_INT 105
65264: PPUSH
65265: CALL_OW 67
// Connect ( vehicle ) ;
65269: LD_VAR 0 1
65273: PPUSH
65274: CALL 77366 0 1
// until IsControledBy ( vehicle ) ;
65278: LD_VAR 0 1
65282: PPUSH
65283: CALL_OW 312
65287: IFFALSE 65262
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65289: LD_VAR 0 1
65293: PPUSH
65294: LD_EXP 125
65298: PUSH
65299: LD_VAR 0 4
65303: ARRAY
65304: PPUSH
65305: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65309: LD_VAR 0 1
65313: PPUSH
65314: CALL_OW 263
65318: PUSH
65319: LD_INT 1
65321: NONEQUAL
65322: IFFALSE 65326
// break ;
65324: GO 65375
// repeat wait ( 0 0$1 ) ;
65326: LD_INT 35
65328: PPUSH
65329: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65333: LD_VAR 0 1
65337: PPUSH
65338: LD_EXP 125
65342: PUSH
65343: LD_VAR 0 4
65347: ARRAY
65348: PPUSH
65349: CALL_OW 308
65353: IFFALSE 65326
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65355: LD_VAR 0 1
65359: PPUSH
65360: CALL_OW 311
65364: PPUSH
65365: CALL_OW 121
// exit ;
65369: POP
65370: POP
65371: GO 65385
// end ; end ;
65373: GO 65017
65375: POP
65376: POP
// mc_block_vehicle_constructed_thread := false ;
65377: LD_ADDR_EXP 145
65381: PUSH
65382: LD_INT 0
65384: ST_TO_ADDR
// end ;
65385: LD_VAR 0 3
65389: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65390: LD_INT 0
65392: PPUSH
65393: PPUSH
65394: PPUSH
65395: PPUSH
// if not mc_bases or not skirmish then
65396: LD_EXP 101
65400: NOT
65401: PUSH
65402: LD_EXP 99
65406: NOT
65407: OR
65408: IFFALSE 65412
// exit ;
65410: GO 65765
// repeat wait ( 0 0$1 ) ;
65412: LD_INT 35
65414: PPUSH
65415: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65419: LD_VAR 0 2
65423: PPUSH
65424: LD_VAR 0 3
65428: PPUSH
65429: CALL_OW 284
65433: IFFALSE 65412
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65435: LD_VAR 0 2
65439: PPUSH
65440: LD_VAR 0 3
65444: PPUSH
65445: CALL_OW 283
65449: PUSH
65450: LD_INT 4
65452: EQUAL
65453: IFFALSE 65457
// exit ;
65455: GO 65765
// for i = 1 to mc_bases do
65457: LD_ADDR_VAR 0 7
65461: PUSH
65462: DOUBLE
65463: LD_INT 1
65465: DEC
65466: ST_TO_ADDR
65467: LD_EXP 101
65471: PUSH
65472: FOR_TO
65473: IFFALSE 65763
// begin if mc_crates_area [ i ] then
65475: LD_EXP 119
65479: PUSH
65480: LD_VAR 0 7
65484: ARRAY
65485: IFFALSE 65596
// for j in mc_crates_area [ i ] do
65487: LD_ADDR_VAR 0 8
65491: PUSH
65492: LD_EXP 119
65496: PUSH
65497: LD_VAR 0 7
65501: ARRAY
65502: PUSH
65503: FOR_IN
65504: IFFALSE 65594
// if InArea ( x , y , j ) then
65506: LD_VAR 0 2
65510: PPUSH
65511: LD_VAR 0 3
65515: PPUSH
65516: LD_VAR 0 8
65520: PPUSH
65521: CALL_OW 309
65525: IFFALSE 65592
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65527: LD_ADDR_EXP 117
65531: PUSH
65532: LD_EXP 117
65536: PPUSH
65537: LD_VAR 0 7
65541: PUSH
65542: LD_EXP 117
65546: PUSH
65547: LD_VAR 0 7
65551: ARRAY
65552: PUSH
65553: LD_INT 1
65555: PLUS
65556: PUSH
65557: EMPTY
65558: LIST
65559: LIST
65560: PPUSH
65561: LD_VAR 0 4
65565: PUSH
65566: LD_VAR 0 2
65570: PUSH
65571: LD_VAR 0 3
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: LIST
65580: PPUSH
65581: CALL 74020 0 3
65585: ST_TO_ADDR
// exit ;
65586: POP
65587: POP
65588: POP
65589: POP
65590: GO 65765
// end ;
65592: GO 65503
65594: POP
65595: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65596: LD_ADDR_VAR 0 9
65600: PUSH
65601: LD_EXP 101
65605: PUSH
65606: LD_VAR 0 7
65610: ARRAY
65611: PPUSH
65612: LD_INT 2
65614: PUSH
65615: LD_INT 30
65617: PUSH
65618: LD_INT 0
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PUSH
65625: LD_INT 30
65627: PUSH
65628: LD_INT 1
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: LIST
65639: PPUSH
65640: CALL_OW 72
65644: ST_TO_ADDR
// if not depot then
65645: LD_VAR 0 9
65649: NOT
65650: IFFALSE 65654
// continue ;
65652: GO 65472
// for j in depot do
65654: LD_ADDR_VAR 0 8
65658: PUSH
65659: LD_VAR 0 9
65663: PUSH
65664: FOR_IN
65665: IFFALSE 65759
// if GetDistUnitXY ( j , x , y ) < 30 then
65667: LD_VAR 0 8
65671: PPUSH
65672: LD_VAR 0 2
65676: PPUSH
65677: LD_VAR 0 3
65681: PPUSH
65682: CALL_OW 297
65686: PUSH
65687: LD_INT 30
65689: LESS
65690: IFFALSE 65757
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65692: LD_ADDR_EXP 117
65696: PUSH
65697: LD_EXP 117
65701: PPUSH
65702: LD_VAR 0 7
65706: PUSH
65707: LD_EXP 117
65711: PUSH
65712: LD_VAR 0 7
65716: ARRAY
65717: PUSH
65718: LD_INT 1
65720: PLUS
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PPUSH
65726: LD_VAR 0 4
65730: PUSH
65731: LD_VAR 0 2
65735: PUSH
65736: LD_VAR 0 3
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: LIST
65745: PPUSH
65746: CALL 74020 0 3
65750: ST_TO_ADDR
// exit ;
65751: POP
65752: POP
65753: POP
65754: POP
65755: GO 65765
// end ;
65757: GO 65664
65759: POP
65760: POP
// end ;
65761: GO 65472
65763: POP
65764: POP
// end ;
65765: LD_VAR 0 6
65769: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
65770: LD_INT 0
65772: PPUSH
65773: PPUSH
65774: PPUSH
65775: PPUSH
// if not mc_bases or not skirmish then
65776: LD_EXP 101
65780: NOT
65781: PUSH
65782: LD_EXP 99
65786: NOT
65787: OR
65788: IFFALSE 65792
// exit ;
65790: GO 66069
// side := GetSide ( lab ) ;
65792: LD_ADDR_VAR 0 4
65796: PUSH
65797: LD_VAR 0 2
65801: PPUSH
65802: CALL_OW 255
65806: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
65807: LD_VAR 0 4
65811: PUSH
65812: LD_EXP 127
65816: IN
65817: NOT
65818: PUSH
65819: LD_EXP 128
65823: NOT
65824: OR
65825: PUSH
65826: LD_EXP 101
65830: NOT
65831: OR
65832: IFFALSE 65836
// exit ;
65834: GO 66069
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
65836: LD_ADDR_EXP 128
65840: PUSH
65841: LD_EXP 128
65845: PPUSH
65846: LD_VAR 0 4
65850: PPUSH
65851: LD_EXP 128
65855: PUSH
65856: LD_VAR 0 4
65860: ARRAY
65861: PUSH
65862: LD_VAR 0 1
65866: DIFF
65867: PPUSH
65868: CALL_OW 1
65872: ST_TO_ADDR
// for i = 1 to mc_bases do
65873: LD_ADDR_VAR 0 5
65877: PUSH
65878: DOUBLE
65879: LD_INT 1
65881: DEC
65882: ST_TO_ADDR
65883: LD_EXP 101
65887: PUSH
65888: FOR_TO
65889: IFFALSE 66067
// begin if lab in mc_bases [ i ] then
65891: LD_VAR 0 2
65895: PUSH
65896: LD_EXP 101
65900: PUSH
65901: LD_VAR 0 5
65905: ARRAY
65906: IN
65907: IFFALSE 66065
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
65909: LD_VAR 0 1
65913: PUSH
65914: LD_INT 11
65916: PUSH
65917: LD_INT 4
65919: PUSH
65920: LD_INT 3
65922: PUSH
65923: LD_INT 2
65925: PUSH
65926: EMPTY
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: IN
65932: PUSH
65933: LD_EXP 131
65937: PUSH
65938: LD_VAR 0 5
65942: ARRAY
65943: AND
65944: IFFALSE 66065
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
65946: LD_ADDR_VAR 0 6
65950: PUSH
65951: LD_EXP 131
65955: PUSH
65956: LD_VAR 0 5
65960: ARRAY
65961: PUSH
65962: LD_INT 1
65964: ARRAY
65965: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65966: LD_ADDR_EXP 131
65970: PUSH
65971: LD_EXP 131
65975: PPUSH
65976: LD_VAR 0 5
65980: PPUSH
65981: EMPTY
65982: PPUSH
65983: CALL_OW 1
65987: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
65988: LD_VAR 0 6
65992: PPUSH
65993: LD_INT 0
65995: PPUSH
65996: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66000: LD_VAR 0 6
66004: PPUSH
66005: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66009: LD_ADDR_EXP 130
66013: PUSH
66014: LD_EXP 130
66018: PPUSH
66019: LD_VAR 0 5
66023: PPUSH
66024: LD_EXP 130
66028: PUSH
66029: LD_VAR 0 5
66033: ARRAY
66034: PPUSH
66035: LD_INT 1
66037: PPUSH
66038: LD_VAR 0 6
66042: PPUSH
66043: CALL_OW 2
66047: PPUSH
66048: CALL_OW 1
66052: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66053: LD_VAR 0 5
66057: PPUSH
66058: LD_INT 112
66060: PPUSH
66061: CALL 42519 0 2
// end ; end ; end ;
66065: GO 65888
66067: POP
66068: POP
// end ;
66069: LD_VAR 0 3
66073: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66074: LD_INT 0
66076: PPUSH
66077: PPUSH
66078: PPUSH
66079: PPUSH
66080: PPUSH
66081: PPUSH
66082: PPUSH
66083: PPUSH
// if not mc_bases or not skirmish then
66084: LD_EXP 101
66088: NOT
66089: PUSH
66090: LD_EXP 99
66094: NOT
66095: OR
66096: IFFALSE 66100
// exit ;
66098: GO 67469
// for i = 1 to mc_bases do
66100: LD_ADDR_VAR 0 3
66104: PUSH
66105: DOUBLE
66106: LD_INT 1
66108: DEC
66109: ST_TO_ADDR
66110: LD_EXP 101
66114: PUSH
66115: FOR_TO
66116: IFFALSE 67467
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66118: LD_VAR 0 1
66122: PUSH
66123: LD_EXP 101
66127: PUSH
66128: LD_VAR 0 3
66132: ARRAY
66133: IN
66134: PUSH
66135: LD_VAR 0 1
66139: PUSH
66140: LD_EXP 108
66144: PUSH
66145: LD_VAR 0 3
66149: ARRAY
66150: IN
66151: OR
66152: PUSH
66153: LD_VAR 0 1
66157: PUSH
66158: LD_EXP 123
66162: PUSH
66163: LD_VAR 0 3
66167: ARRAY
66168: IN
66169: OR
66170: PUSH
66171: LD_VAR 0 1
66175: PUSH
66176: LD_EXP 120
66180: PUSH
66181: LD_VAR 0 3
66185: ARRAY
66186: IN
66187: OR
66188: PUSH
66189: LD_VAR 0 1
66193: PUSH
66194: LD_EXP 130
66198: PUSH
66199: LD_VAR 0 3
66203: ARRAY
66204: IN
66205: OR
66206: PUSH
66207: LD_VAR 0 1
66211: PUSH
66212: LD_EXP 131
66216: PUSH
66217: LD_VAR 0 3
66221: ARRAY
66222: IN
66223: OR
66224: IFFALSE 67465
// begin if un in mc_ape [ i ] then
66226: LD_VAR 0 1
66230: PUSH
66231: LD_EXP 130
66235: PUSH
66236: LD_VAR 0 3
66240: ARRAY
66241: IN
66242: IFFALSE 66281
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66244: LD_ADDR_EXP 130
66248: PUSH
66249: LD_EXP 130
66253: PPUSH
66254: LD_VAR 0 3
66258: PPUSH
66259: LD_EXP 130
66263: PUSH
66264: LD_VAR 0 3
66268: ARRAY
66269: PUSH
66270: LD_VAR 0 1
66274: DIFF
66275: PPUSH
66276: CALL_OW 1
66280: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66281: LD_VAR 0 1
66285: PUSH
66286: LD_EXP 131
66290: PUSH
66291: LD_VAR 0 3
66295: ARRAY
66296: IN
66297: IFFALSE 66321
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66299: LD_ADDR_EXP 131
66303: PUSH
66304: LD_EXP 131
66308: PPUSH
66309: LD_VAR 0 3
66313: PPUSH
66314: EMPTY
66315: PPUSH
66316: CALL_OW 1
66320: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66321: LD_VAR 0 1
66325: PPUSH
66326: CALL_OW 247
66330: PUSH
66331: LD_INT 2
66333: EQUAL
66334: PUSH
66335: LD_VAR 0 1
66339: PPUSH
66340: CALL_OW 110
66344: PUSH
66345: LD_INT 20
66347: EQUAL
66348: PUSH
66349: LD_VAR 0 1
66353: PUSH
66354: LD_EXP 123
66358: PUSH
66359: LD_VAR 0 3
66363: ARRAY
66364: IN
66365: OR
66366: PUSH
66367: LD_VAR 0 1
66371: PPUSH
66372: CALL_OW 264
66376: PUSH
66377: LD_INT 12
66379: PUSH
66380: LD_INT 51
66382: PUSH
66383: LD_INT 89
66385: PUSH
66386: LD_INT 32
66388: PUSH
66389: LD_INT 13
66391: PUSH
66392: LD_INT 52
66394: PUSH
66395: LD_INT 31
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: IN
66407: OR
66408: AND
66409: IFFALSE 66717
// begin if un in mc_defender [ i ] then
66411: LD_VAR 0 1
66415: PUSH
66416: LD_EXP 123
66420: PUSH
66421: LD_VAR 0 3
66425: ARRAY
66426: IN
66427: IFFALSE 66466
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66429: LD_ADDR_EXP 123
66433: PUSH
66434: LD_EXP 123
66438: PPUSH
66439: LD_VAR 0 3
66443: PPUSH
66444: LD_EXP 123
66448: PUSH
66449: LD_VAR 0 3
66453: ARRAY
66454: PUSH
66455: LD_VAR 0 1
66459: DIFF
66460: PPUSH
66461: CALL_OW 1
66465: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66466: LD_ADDR_VAR 0 8
66470: PUSH
66471: LD_VAR 0 3
66475: PPUSH
66476: LD_INT 3
66478: PPUSH
66479: CALL 63087 0 2
66483: ST_TO_ADDR
// if fac then
66484: LD_VAR 0 8
66488: IFFALSE 66717
// begin for j in fac do
66490: LD_ADDR_VAR 0 4
66494: PUSH
66495: LD_VAR 0 8
66499: PUSH
66500: FOR_IN
66501: IFFALSE 66715
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66503: LD_ADDR_VAR 0 9
66507: PUSH
66508: LD_VAR 0 8
66512: PPUSH
66513: LD_VAR 0 1
66517: PPUSH
66518: CALL_OW 265
66522: PPUSH
66523: LD_VAR 0 1
66527: PPUSH
66528: CALL_OW 262
66532: PPUSH
66533: LD_VAR 0 1
66537: PPUSH
66538: CALL_OW 263
66542: PPUSH
66543: LD_VAR 0 1
66547: PPUSH
66548: CALL_OW 264
66552: PPUSH
66553: CALL 71518 0 5
66557: ST_TO_ADDR
// if components then
66558: LD_VAR 0 9
66562: IFFALSE 66713
// begin if GetWeapon ( un ) = ar_control_tower then
66564: LD_VAR 0 1
66568: PPUSH
66569: CALL_OW 264
66573: PUSH
66574: LD_INT 31
66576: EQUAL
66577: IFFALSE 66694
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66579: LD_VAR 0 1
66583: PPUSH
66584: CALL_OW 311
66588: PPUSH
66589: LD_INT 0
66591: PPUSH
66592: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66596: LD_ADDR_EXP 141
66600: PUSH
66601: LD_EXP 141
66605: PPUSH
66606: LD_VAR 0 3
66610: PPUSH
66611: LD_EXP 141
66615: PUSH
66616: LD_VAR 0 3
66620: ARRAY
66621: PUSH
66622: LD_VAR 0 1
66626: PPUSH
66627: CALL_OW 311
66631: DIFF
66632: PPUSH
66633: CALL_OW 1
66637: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
66638: LD_ADDR_VAR 0 7
66642: PUSH
66643: LD_EXP 122
66647: PUSH
66648: LD_VAR 0 3
66652: ARRAY
66653: PPUSH
66654: LD_INT 1
66656: PPUSH
66657: LD_VAR 0 9
66661: PPUSH
66662: CALL_OW 2
66666: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66667: LD_ADDR_EXP 122
66671: PUSH
66672: LD_EXP 122
66676: PPUSH
66677: LD_VAR 0 3
66681: PPUSH
66682: LD_VAR 0 7
66686: PPUSH
66687: CALL_OW 1
66691: ST_TO_ADDR
// end else
66692: GO 66711
// MC_InsertProduceList ( i , [ components ] ) ;
66694: LD_VAR 0 3
66698: PPUSH
66699: LD_VAR 0 9
66703: PUSH
66704: EMPTY
66705: LIST
66706: PPUSH
66707: CALL 62632 0 2
// break ;
66711: GO 66715
// end ; end ;
66713: GO 66500
66715: POP
66716: POP
// end ; end ; if GetType ( un ) = unit_building then
66717: LD_VAR 0 1
66721: PPUSH
66722: CALL_OW 247
66726: PUSH
66727: LD_INT 3
66729: EQUAL
66730: IFFALSE 67133
// begin btype := GetBType ( un ) ;
66732: LD_ADDR_VAR 0 5
66736: PUSH
66737: LD_VAR 0 1
66741: PPUSH
66742: CALL_OW 266
66746: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
66747: LD_VAR 0 5
66751: PUSH
66752: LD_INT 29
66754: PUSH
66755: LD_INT 30
66757: PUSH
66758: EMPTY
66759: LIST
66760: LIST
66761: IN
66762: IFFALSE 66835
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
66764: LD_VAR 0 1
66768: PPUSH
66769: CALL_OW 250
66773: PPUSH
66774: LD_VAR 0 1
66778: PPUSH
66779: CALL_OW 251
66783: PPUSH
66784: LD_VAR 0 1
66788: PPUSH
66789: CALL_OW 255
66793: PPUSH
66794: CALL_OW 440
66798: NOT
66799: IFFALSE 66835
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
66801: LD_VAR 0 1
66805: PPUSH
66806: CALL_OW 250
66810: PPUSH
66811: LD_VAR 0 1
66815: PPUSH
66816: CALL_OW 251
66820: PPUSH
66821: LD_VAR 0 1
66825: PPUSH
66826: CALL_OW 255
66830: PPUSH
66831: CALL_OW 441
// end ; if btype = b_warehouse then
66835: LD_VAR 0 5
66839: PUSH
66840: LD_INT 1
66842: EQUAL
66843: IFFALSE 66861
// begin btype := b_depot ;
66845: LD_ADDR_VAR 0 5
66849: PUSH
66850: LD_INT 0
66852: ST_TO_ADDR
// pos := 1 ;
66853: LD_ADDR_VAR 0 6
66857: PUSH
66858: LD_INT 1
66860: ST_TO_ADDR
// end ; if btype = b_factory then
66861: LD_VAR 0 5
66865: PUSH
66866: LD_INT 3
66868: EQUAL
66869: IFFALSE 66887
// begin btype := b_workshop ;
66871: LD_ADDR_VAR 0 5
66875: PUSH
66876: LD_INT 2
66878: ST_TO_ADDR
// pos := 1 ;
66879: LD_ADDR_VAR 0 6
66883: PUSH
66884: LD_INT 1
66886: ST_TO_ADDR
// end ; if btype = b_barracks then
66887: LD_VAR 0 5
66891: PUSH
66892: LD_INT 5
66894: EQUAL
66895: IFFALSE 66905
// btype := b_armoury ;
66897: LD_ADDR_VAR 0 5
66901: PUSH
66902: LD_INT 4
66904: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
66905: LD_VAR 0 5
66909: PUSH
66910: LD_INT 7
66912: PUSH
66913: LD_INT 8
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: IN
66920: IFFALSE 66930
// btype := b_lab ;
66922: LD_ADDR_VAR 0 5
66926: PUSH
66927: LD_INT 6
66929: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
66930: LD_ADDR_EXP 106
66934: PUSH
66935: LD_EXP 106
66939: PPUSH
66940: LD_VAR 0 3
66944: PUSH
66945: LD_EXP 106
66949: PUSH
66950: LD_VAR 0 3
66954: ARRAY
66955: PUSH
66956: LD_INT 1
66958: PLUS
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: LD_VAR 0 5
66968: PUSH
66969: LD_VAR 0 1
66973: PPUSH
66974: CALL_OW 250
66978: PUSH
66979: LD_VAR 0 1
66983: PPUSH
66984: CALL_OW 251
66988: PUSH
66989: LD_VAR 0 1
66993: PPUSH
66994: CALL_OW 254
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: PPUSH
67005: CALL 74020 0 3
67009: ST_TO_ADDR
// if pos = 1 then
67010: LD_VAR 0 6
67014: PUSH
67015: LD_INT 1
67017: EQUAL
67018: IFFALSE 67133
// begin tmp := mc_build_list [ i ] ;
67020: LD_ADDR_VAR 0 7
67024: PUSH
67025: LD_EXP 106
67029: PUSH
67030: LD_VAR 0 3
67034: ARRAY
67035: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67036: LD_VAR 0 7
67040: PPUSH
67041: LD_INT 2
67043: PUSH
67044: LD_INT 30
67046: PUSH
67047: LD_INT 0
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 30
67056: PUSH
67057: LD_INT 1
67059: PUSH
67060: EMPTY
67061: LIST
67062: LIST
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: LIST
67068: PPUSH
67069: CALL_OW 72
67073: IFFALSE 67083
// pos := 2 ;
67075: LD_ADDR_VAR 0 6
67079: PUSH
67080: LD_INT 2
67082: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67083: LD_ADDR_VAR 0 7
67087: PUSH
67088: LD_VAR 0 7
67092: PPUSH
67093: LD_VAR 0 6
67097: PPUSH
67098: LD_VAR 0 7
67102: PPUSH
67103: CALL 74346 0 3
67107: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67108: LD_ADDR_EXP 106
67112: PUSH
67113: LD_EXP 106
67117: PPUSH
67118: LD_VAR 0 3
67122: PPUSH
67123: LD_VAR 0 7
67127: PPUSH
67128: CALL_OW 1
67132: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67133: LD_VAR 0 1
67137: PUSH
67138: LD_EXP 101
67142: PUSH
67143: LD_VAR 0 3
67147: ARRAY
67148: IN
67149: IFFALSE 67188
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67151: LD_ADDR_EXP 101
67155: PUSH
67156: LD_EXP 101
67160: PPUSH
67161: LD_VAR 0 3
67165: PPUSH
67166: LD_EXP 101
67170: PUSH
67171: LD_VAR 0 3
67175: ARRAY
67176: PUSH
67177: LD_VAR 0 1
67181: DIFF
67182: PPUSH
67183: CALL_OW 1
67187: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67188: LD_VAR 0 1
67192: PUSH
67193: LD_EXP 108
67197: PUSH
67198: LD_VAR 0 3
67202: ARRAY
67203: IN
67204: IFFALSE 67243
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67206: LD_ADDR_EXP 108
67210: PUSH
67211: LD_EXP 108
67215: PPUSH
67216: LD_VAR 0 3
67220: PPUSH
67221: LD_EXP 108
67225: PUSH
67226: LD_VAR 0 3
67230: ARRAY
67231: PUSH
67232: LD_VAR 0 1
67236: DIFF
67237: PPUSH
67238: CALL_OW 1
67242: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67243: LD_VAR 0 1
67247: PUSH
67248: LD_EXP 120
67252: PUSH
67253: LD_VAR 0 3
67257: ARRAY
67258: IN
67259: IFFALSE 67298
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67261: LD_ADDR_EXP 120
67265: PUSH
67266: LD_EXP 120
67270: PPUSH
67271: LD_VAR 0 3
67275: PPUSH
67276: LD_EXP 120
67280: PUSH
67281: LD_VAR 0 3
67285: ARRAY
67286: PUSH
67287: LD_VAR 0 1
67291: DIFF
67292: PPUSH
67293: CALL_OW 1
67297: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67298: LD_VAR 0 1
67302: PUSH
67303: LD_EXP 123
67307: PUSH
67308: LD_VAR 0 3
67312: ARRAY
67313: IN
67314: IFFALSE 67353
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67316: LD_ADDR_EXP 123
67320: PUSH
67321: LD_EXP 123
67325: PPUSH
67326: LD_VAR 0 3
67330: PPUSH
67331: LD_EXP 123
67335: PUSH
67336: LD_VAR 0 3
67340: ARRAY
67341: PUSH
67342: LD_VAR 0 1
67346: DIFF
67347: PPUSH
67348: CALL_OW 1
67352: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67353: LD_VAR 0 1
67357: PUSH
67358: LD_EXP 110
67362: PUSH
67363: LD_VAR 0 3
67367: ARRAY
67368: IN
67369: IFFALSE 67408
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67371: LD_ADDR_EXP 110
67375: PUSH
67376: LD_EXP 110
67380: PPUSH
67381: LD_VAR 0 3
67385: PPUSH
67386: LD_EXP 110
67390: PUSH
67391: LD_VAR 0 3
67395: ARRAY
67396: PUSH
67397: LD_VAR 0 1
67401: DIFF
67402: PPUSH
67403: CALL_OW 1
67407: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67408: LD_VAR 0 1
67412: PUSH
67413: LD_EXP 109
67417: PUSH
67418: LD_VAR 0 3
67422: ARRAY
67423: IN
67424: IFFALSE 67463
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67426: LD_ADDR_EXP 109
67430: PUSH
67431: LD_EXP 109
67435: PPUSH
67436: LD_VAR 0 3
67440: PPUSH
67441: LD_EXP 109
67445: PUSH
67446: LD_VAR 0 3
67450: ARRAY
67451: PUSH
67452: LD_VAR 0 1
67456: DIFF
67457: PPUSH
67458: CALL_OW 1
67462: ST_TO_ADDR
// end ; break ;
67463: GO 67467
// end ;
67465: GO 66115
67467: POP
67468: POP
// end ;
67469: LD_VAR 0 2
67473: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67474: LD_INT 0
67476: PPUSH
67477: PPUSH
67478: PPUSH
// if not mc_bases or not skirmish then
67479: LD_EXP 101
67483: NOT
67484: PUSH
67485: LD_EXP 99
67489: NOT
67490: OR
67491: IFFALSE 67495
// exit ;
67493: GO 67710
// for i = 1 to mc_bases do
67495: LD_ADDR_VAR 0 3
67499: PUSH
67500: DOUBLE
67501: LD_INT 1
67503: DEC
67504: ST_TO_ADDR
67505: LD_EXP 101
67509: PUSH
67510: FOR_TO
67511: IFFALSE 67708
// begin if building in mc_construct_list [ i ] then
67513: LD_VAR 0 1
67517: PUSH
67518: LD_EXP 108
67522: PUSH
67523: LD_VAR 0 3
67527: ARRAY
67528: IN
67529: IFFALSE 67706
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67531: LD_ADDR_EXP 108
67535: PUSH
67536: LD_EXP 108
67540: PPUSH
67541: LD_VAR 0 3
67545: PPUSH
67546: LD_EXP 108
67550: PUSH
67551: LD_VAR 0 3
67555: ARRAY
67556: PUSH
67557: LD_VAR 0 1
67561: DIFF
67562: PPUSH
67563: CALL_OW 1
67567: ST_TO_ADDR
// if building in mc_lab [ i ] then
67568: LD_VAR 0 1
67572: PUSH
67573: LD_EXP 134
67577: PUSH
67578: LD_VAR 0 3
67582: ARRAY
67583: IN
67584: IFFALSE 67639
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67586: LD_ADDR_EXP 135
67590: PUSH
67591: LD_EXP 135
67595: PPUSH
67596: LD_VAR 0 3
67600: PPUSH
67601: LD_EXP 135
67605: PUSH
67606: LD_VAR 0 3
67610: ARRAY
67611: PPUSH
67612: LD_INT 1
67614: PPUSH
67615: LD_EXP 135
67619: PUSH
67620: LD_VAR 0 3
67624: ARRAY
67625: PPUSH
67626: LD_INT 0
67628: PPUSH
67629: CALL 73438 0 4
67633: PPUSH
67634: CALL_OW 1
67638: ST_TO_ADDR
// if not building in mc_bases [ i ] then
67639: LD_VAR 0 1
67643: PUSH
67644: LD_EXP 101
67648: PUSH
67649: LD_VAR 0 3
67653: ARRAY
67654: IN
67655: NOT
67656: IFFALSE 67702
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67658: LD_ADDR_EXP 101
67662: PUSH
67663: LD_EXP 101
67667: PPUSH
67668: LD_VAR 0 3
67672: PUSH
67673: LD_EXP 101
67677: PUSH
67678: LD_VAR 0 3
67682: ARRAY
67683: PUSH
67684: LD_INT 1
67686: PLUS
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PPUSH
67692: LD_VAR 0 1
67696: PPUSH
67697: CALL 74020 0 3
67701: ST_TO_ADDR
// exit ;
67702: POP
67703: POP
67704: GO 67710
// end ; end ;
67706: GO 67510
67708: POP
67709: POP
// end ;
67710: LD_VAR 0 2
67714: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
67715: LD_INT 0
67717: PPUSH
67718: PPUSH
67719: PPUSH
67720: PPUSH
67721: PPUSH
67722: PPUSH
67723: PPUSH
// if not mc_bases or not skirmish then
67724: LD_EXP 101
67728: NOT
67729: PUSH
67730: LD_EXP 99
67734: NOT
67735: OR
67736: IFFALSE 67740
// exit ;
67738: GO 68401
// for i = 1 to mc_bases do
67740: LD_ADDR_VAR 0 3
67744: PUSH
67745: DOUBLE
67746: LD_INT 1
67748: DEC
67749: ST_TO_ADDR
67750: LD_EXP 101
67754: PUSH
67755: FOR_TO
67756: IFFALSE 68399
// begin if building in mc_construct_list [ i ] then
67758: LD_VAR 0 1
67762: PUSH
67763: LD_EXP 108
67767: PUSH
67768: LD_VAR 0 3
67772: ARRAY
67773: IN
67774: IFFALSE 68397
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67776: LD_ADDR_EXP 108
67780: PUSH
67781: LD_EXP 108
67785: PPUSH
67786: LD_VAR 0 3
67790: PPUSH
67791: LD_EXP 108
67795: PUSH
67796: LD_VAR 0 3
67800: ARRAY
67801: PUSH
67802: LD_VAR 0 1
67806: DIFF
67807: PPUSH
67808: CALL_OW 1
67812: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67813: LD_ADDR_EXP 101
67817: PUSH
67818: LD_EXP 101
67822: PPUSH
67823: LD_VAR 0 3
67827: PUSH
67828: LD_EXP 101
67832: PUSH
67833: LD_VAR 0 3
67837: ARRAY
67838: PUSH
67839: LD_INT 1
67841: PLUS
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PPUSH
67847: LD_VAR 0 1
67851: PPUSH
67852: CALL 74020 0 3
67856: ST_TO_ADDR
// btype := GetBType ( building ) ;
67857: LD_ADDR_VAR 0 5
67861: PUSH
67862: LD_VAR 0 1
67866: PPUSH
67867: CALL_OW 266
67871: ST_TO_ADDR
// side := GetSide ( building ) ;
67872: LD_ADDR_VAR 0 8
67876: PUSH
67877: LD_VAR 0 1
67881: PPUSH
67882: CALL_OW 255
67886: ST_TO_ADDR
// if btype = b_lab then
67887: LD_VAR 0 5
67891: PUSH
67892: LD_INT 6
67894: EQUAL
67895: IFFALSE 67945
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
67897: LD_ADDR_EXP 134
67901: PUSH
67902: LD_EXP 134
67906: PPUSH
67907: LD_VAR 0 3
67911: PUSH
67912: LD_EXP 134
67916: PUSH
67917: LD_VAR 0 3
67921: ARRAY
67922: PUSH
67923: LD_INT 1
67925: PLUS
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PPUSH
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL 74020 0 3
67940: ST_TO_ADDR
// exit ;
67941: POP
67942: POP
67943: GO 68401
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
67945: LD_VAR 0 5
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 2
67955: PUSH
67956: LD_INT 4
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: LIST
67963: IN
67964: IFFALSE 68088
// begin if btype = b_armoury then
67966: LD_VAR 0 5
67970: PUSH
67971: LD_INT 4
67973: EQUAL
67974: IFFALSE 67984
// btype := b_barracks ;
67976: LD_ADDR_VAR 0 5
67980: PUSH
67981: LD_INT 5
67983: ST_TO_ADDR
// if btype = b_depot then
67984: LD_VAR 0 5
67988: PUSH
67989: LD_INT 0
67991: EQUAL
67992: IFFALSE 68002
// btype := b_warehouse ;
67994: LD_ADDR_VAR 0 5
67998: PUSH
67999: LD_INT 1
68001: ST_TO_ADDR
// if btype = b_workshop then
68002: LD_VAR 0 5
68006: PUSH
68007: LD_INT 2
68009: EQUAL
68010: IFFALSE 68020
// btype := b_factory ;
68012: LD_ADDR_VAR 0 5
68016: PUSH
68017: LD_INT 3
68019: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68020: LD_VAR 0 5
68024: PPUSH
68025: LD_VAR 0 8
68029: PPUSH
68030: CALL_OW 323
68034: PUSH
68035: LD_INT 1
68037: EQUAL
68038: IFFALSE 68084
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68040: LD_ADDR_EXP 133
68044: PUSH
68045: LD_EXP 133
68049: PPUSH
68050: LD_VAR 0 3
68054: PUSH
68055: LD_EXP 133
68059: PUSH
68060: LD_VAR 0 3
68064: ARRAY
68065: PUSH
68066: LD_INT 1
68068: PLUS
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PPUSH
68074: LD_VAR 0 1
68078: PPUSH
68079: CALL 74020 0 3
68083: ST_TO_ADDR
// exit ;
68084: POP
68085: POP
68086: GO 68401
// end ; if btype in [ b_bunker , b_turret ] then
68088: LD_VAR 0 5
68092: PUSH
68093: LD_INT 32
68095: PUSH
68096: LD_INT 33
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: IN
68103: IFFALSE 68393
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68105: LD_ADDR_EXP 109
68109: PUSH
68110: LD_EXP 109
68114: PPUSH
68115: LD_VAR 0 3
68119: PUSH
68120: LD_EXP 109
68124: PUSH
68125: LD_VAR 0 3
68129: ARRAY
68130: PUSH
68131: LD_INT 1
68133: PLUS
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PPUSH
68139: LD_VAR 0 1
68143: PPUSH
68144: CALL 74020 0 3
68148: ST_TO_ADDR
// if btype = b_bunker then
68149: LD_VAR 0 5
68153: PUSH
68154: LD_INT 32
68156: EQUAL
68157: IFFALSE 68393
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68159: LD_ADDR_EXP 110
68163: PUSH
68164: LD_EXP 110
68168: PPUSH
68169: LD_VAR 0 3
68173: PUSH
68174: LD_EXP 110
68178: PUSH
68179: LD_VAR 0 3
68183: ARRAY
68184: PUSH
68185: LD_INT 1
68187: PLUS
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PPUSH
68193: LD_VAR 0 1
68197: PPUSH
68198: CALL 74020 0 3
68202: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68203: LD_ADDR_VAR 0 6
68207: PUSH
68208: LD_EXP 101
68212: PUSH
68213: LD_VAR 0 3
68217: ARRAY
68218: PPUSH
68219: LD_INT 25
68221: PUSH
68222: LD_INT 1
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 3
68231: PUSH
68232: LD_INT 54
68234: PUSH
68235: EMPTY
68236: LIST
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PPUSH
68246: CALL_OW 72
68250: ST_TO_ADDR
// if tmp then
68251: LD_VAR 0 6
68255: IFFALSE 68261
// exit ;
68257: POP
68258: POP
68259: GO 68401
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68261: LD_ADDR_VAR 0 6
68265: PUSH
68266: LD_EXP 101
68270: PUSH
68271: LD_VAR 0 3
68275: ARRAY
68276: PPUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 30
68282: PUSH
68283: LD_INT 4
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 30
68292: PUSH
68293: LD_INT 5
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: LIST
68304: PPUSH
68305: CALL_OW 72
68309: ST_TO_ADDR
// if not tmp then
68310: LD_VAR 0 6
68314: NOT
68315: IFFALSE 68321
// exit ;
68317: POP
68318: POP
68319: GO 68401
// for j in tmp do
68321: LD_ADDR_VAR 0 4
68325: PUSH
68326: LD_VAR 0 6
68330: PUSH
68331: FOR_IN
68332: IFFALSE 68391
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68334: LD_ADDR_VAR 0 7
68338: PUSH
68339: LD_VAR 0 4
68343: PPUSH
68344: CALL_OW 313
68348: PPUSH
68349: LD_INT 25
68351: PUSH
68352: LD_INT 1
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PPUSH
68359: CALL_OW 72
68363: ST_TO_ADDR
// if units then
68364: LD_VAR 0 7
68368: IFFALSE 68389
// begin ComExitBuilding ( units [ 1 ] ) ;
68370: LD_VAR 0 7
68374: PUSH
68375: LD_INT 1
68377: ARRAY
68378: PPUSH
68379: CALL_OW 122
// exit ;
68383: POP
68384: POP
68385: POP
68386: POP
68387: GO 68401
// end ; end ;
68389: GO 68331
68391: POP
68392: POP
// end ; end ; exit ;
68393: POP
68394: POP
68395: GO 68401
// end ; end ;
68397: GO 67755
68399: POP
68400: POP
// end ;
68401: LD_VAR 0 2
68405: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68406: LD_INT 0
68408: PPUSH
68409: PPUSH
68410: PPUSH
68411: PPUSH
68412: PPUSH
68413: PPUSH
68414: PPUSH
// if not mc_bases or not skirmish then
68415: LD_EXP 101
68419: NOT
68420: PUSH
68421: LD_EXP 99
68425: NOT
68426: OR
68427: IFFALSE 68431
// exit ;
68429: GO 68696
// btype := GetBType ( building ) ;
68431: LD_ADDR_VAR 0 6
68435: PUSH
68436: LD_VAR 0 1
68440: PPUSH
68441: CALL_OW 266
68445: ST_TO_ADDR
// x := GetX ( building ) ;
68446: LD_ADDR_VAR 0 7
68450: PUSH
68451: LD_VAR 0 1
68455: PPUSH
68456: CALL_OW 250
68460: ST_TO_ADDR
// y := GetY ( building ) ;
68461: LD_ADDR_VAR 0 8
68465: PUSH
68466: LD_VAR 0 1
68470: PPUSH
68471: CALL_OW 251
68475: ST_TO_ADDR
// d := GetDir ( building ) ;
68476: LD_ADDR_VAR 0 9
68480: PUSH
68481: LD_VAR 0 1
68485: PPUSH
68486: CALL_OW 254
68490: ST_TO_ADDR
// for i = 1 to mc_bases do
68491: LD_ADDR_VAR 0 4
68495: PUSH
68496: DOUBLE
68497: LD_INT 1
68499: DEC
68500: ST_TO_ADDR
68501: LD_EXP 101
68505: PUSH
68506: FOR_TO
68507: IFFALSE 68694
// begin if not mc_build_list [ i ] then
68509: LD_EXP 106
68513: PUSH
68514: LD_VAR 0 4
68518: ARRAY
68519: NOT
68520: IFFALSE 68524
// continue ;
68522: GO 68506
// for j := 1 to mc_build_list [ i ] do
68524: LD_ADDR_VAR 0 5
68528: PUSH
68529: DOUBLE
68530: LD_INT 1
68532: DEC
68533: ST_TO_ADDR
68534: LD_EXP 106
68538: PUSH
68539: LD_VAR 0 4
68543: ARRAY
68544: PUSH
68545: FOR_TO
68546: IFFALSE 68690
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68548: LD_VAR 0 6
68552: PUSH
68553: LD_VAR 0 7
68557: PUSH
68558: LD_VAR 0 8
68562: PUSH
68563: LD_VAR 0 9
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: PPUSH
68574: LD_EXP 106
68578: PUSH
68579: LD_VAR 0 4
68583: ARRAY
68584: PUSH
68585: LD_VAR 0 5
68589: ARRAY
68590: PPUSH
68591: CALL 80577 0 2
68595: IFFALSE 68688
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68597: LD_ADDR_EXP 106
68601: PUSH
68602: LD_EXP 106
68606: PPUSH
68607: LD_VAR 0 4
68611: PPUSH
68612: LD_EXP 106
68616: PUSH
68617: LD_VAR 0 4
68621: ARRAY
68622: PPUSH
68623: LD_VAR 0 5
68627: PPUSH
68628: CALL_OW 3
68632: PPUSH
68633: CALL_OW 1
68637: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
68638: LD_ADDR_EXP 108
68642: PUSH
68643: LD_EXP 108
68647: PPUSH
68648: LD_VAR 0 4
68652: PUSH
68653: LD_EXP 108
68657: PUSH
68658: LD_VAR 0 4
68662: ARRAY
68663: PUSH
68664: LD_INT 1
68666: PLUS
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PPUSH
68672: LD_VAR 0 1
68676: PPUSH
68677: CALL 74020 0 3
68681: ST_TO_ADDR
// exit ;
68682: POP
68683: POP
68684: POP
68685: POP
68686: GO 68696
// end ;
68688: GO 68545
68690: POP
68691: POP
// end ;
68692: GO 68506
68694: POP
68695: POP
// end ;
68696: LD_VAR 0 3
68700: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
68701: LD_INT 0
68703: PPUSH
68704: PPUSH
68705: PPUSH
// if not mc_bases or not skirmish then
68706: LD_EXP 101
68710: NOT
68711: PUSH
68712: LD_EXP 99
68716: NOT
68717: OR
68718: IFFALSE 68722
// exit ;
68720: GO 68912
// for i = 1 to mc_bases do
68722: LD_ADDR_VAR 0 4
68726: PUSH
68727: DOUBLE
68728: LD_INT 1
68730: DEC
68731: ST_TO_ADDR
68732: LD_EXP 101
68736: PUSH
68737: FOR_TO
68738: IFFALSE 68825
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
68740: LD_VAR 0 1
68744: PUSH
68745: LD_EXP 109
68749: PUSH
68750: LD_VAR 0 4
68754: ARRAY
68755: IN
68756: PUSH
68757: LD_VAR 0 1
68761: PUSH
68762: LD_EXP 110
68766: PUSH
68767: LD_VAR 0 4
68771: ARRAY
68772: IN
68773: NOT
68774: AND
68775: IFFALSE 68823
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68777: LD_ADDR_EXP 110
68781: PUSH
68782: LD_EXP 110
68786: PPUSH
68787: LD_VAR 0 4
68791: PUSH
68792: LD_EXP 110
68796: PUSH
68797: LD_VAR 0 4
68801: ARRAY
68802: PUSH
68803: LD_INT 1
68805: PLUS
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PPUSH
68811: LD_VAR 0 1
68815: PPUSH
68816: CALL 74020 0 3
68820: ST_TO_ADDR
// break ;
68821: GO 68825
// end ; end ;
68823: GO 68737
68825: POP
68826: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
68827: LD_VAR 0 1
68831: PPUSH
68832: CALL_OW 257
68836: PUSH
68837: LD_EXP 127
68841: IN
68842: PUSH
68843: LD_VAR 0 1
68847: PPUSH
68848: CALL_OW 266
68852: PUSH
68853: LD_INT 5
68855: EQUAL
68856: AND
68857: PUSH
68858: LD_VAR 0 2
68862: PPUSH
68863: CALL_OW 110
68867: PUSH
68868: LD_INT 18
68870: NONEQUAL
68871: AND
68872: IFFALSE 68912
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
68874: LD_VAR 0 2
68878: PPUSH
68879: CALL_OW 257
68883: PUSH
68884: LD_INT 5
68886: PUSH
68887: LD_INT 8
68889: PUSH
68890: LD_INT 9
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: LIST
68897: IN
68898: IFFALSE 68912
// SetClass ( unit , 1 ) ;
68900: LD_VAR 0 2
68904: PPUSH
68905: LD_INT 1
68907: PPUSH
68908: CALL_OW 336
// end ;
68912: LD_VAR 0 3
68916: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
68917: LD_INT 0
68919: PPUSH
68920: PPUSH
// if not mc_bases or not skirmish then
68921: LD_EXP 101
68925: NOT
68926: PUSH
68927: LD_EXP 99
68931: NOT
68932: OR
68933: IFFALSE 68937
// exit ;
68935: GO 69053
// if GetLives ( abandoned_vehicle ) > 250 then
68937: LD_VAR 0 2
68941: PPUSH
68942: CALL_OW 256
68946: PUSH
68947: LD_INT 250
68949: GREATER
68950: IFFALSE 68954
// exit ;
68952: GO 69053
// for i = 1 to mc_bases do
68954: LD_ADDR_VAR 0 6
68958: PUSH
68959: DOUBLE
68960: LD_INT 1
68962: DEC
68963: ST_TO_ADDR
68964: LD_EXP 101
68968: PUSH
68969: FOR_TO
68970: IFFALSE 69051
// begin if driver in mc_bases [ i ] then
68972: LD_VAR 0 1
68976: PUSH
68977: LD_EXP 101
68981: PUSH
68982: LD_VAR 0 6
68986: ARRAY
68987: IN
68988: IFFALSE 69049
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
68990: LD_VAR 0 1
68994: PPUSH
68995: LD_EXP 101
68999: PUSH
69000: LD_VAR 0 6
69004: ARRAY
69005: PPUSH
69006: LD_INT 2
69008: PUSH
69009: LD_INT 30
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 30
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: LIST
69033: PPUSH
69034: CALL_OW 72
69038: PUSH
69039: LD_INT 1
69041: ARRAY
69042: PPUSH
69043: CALL 107637 0 2
// break ;
69047: GO 69051
// end ; end ;
69049: GO 68969
69051: POP
69052: POP
// end ; end_of_file
69053: LD_VAR 0 5
69057: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69058: LD_INT 0
69060: PPUSH
69061: PPUSH
// if exist_mode then
69062: LD_VAR 0 2
69066: IFFALSE 69091
// unit := CreateCharacter ( prefix & ident ) else
69068: LD_ADDR_VAR 0 5
69072: PUSH
69073: LD_VAR 0 3
69077: PUSH
69078: LD_VAR 0 1
69082: STR
69083: PPUSH
69084: CALL_OW 34
69088: ST_TO_ADDR
69089: GO 69106
// unit := NewCharacter ( ident ) ;
69091: LD_ADDR_VAR 0 5
69095: PUSH
69096: LD_VAR 0 1
69100: PPUSH
69101: CALL_OW 25
69105: ST_TO_ADDR
// result := unit ;
69106: LD_ADDR_VAR 0 4
69110: PUSH
69111: LD_VAR 0 5
69115: ST_TO_ADDR
// end ;
69116: LD_VAR 0 4
69120: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69121: LD_INT 0
69123: PPUSH
69124: PPUSH
// if not side or not nation then
69125: LD_VAR 0 1
69129: NOT
69130: PUSH
69131: LD_VAR 0 2
69135: NOT
69136: OR
69137: IFFALSE 69141
// exit ;
69139: GO 69909
// case nation of nation_american :
69141: LD_VAR 0 2
69145: PUSH
69146: LD_INT 1
69148: DOUBLE
69149: EQUAL
69150: IFTRUE 69154
69152: GO 69368
69154: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69155: LD_ADDR_VAR 0 4
69159: PUSH
69160: LD_INT 35
69162: PUSH
69163: LD_INT 45
69165: PUSH
69166: LD_INT 46
69168: PUSH
69169: LD_INT 47
69171: PUSH
69172: LD_INT 82
69174: PUSH
69175: LD_INT 83
69177: PUSH
69178: LD_INT 84
69180: PUSH
69181: LD_INT 85
69183: PUSH
69184: LD_INT 86
69186: PUSH
69187: LD_INT 1
69189: PUSH
69190: LD_INT 2
69192: PUSH
69193: LD_INT 6
69195: PUSH
69196: LD_INT 15
69198: PUSH
69199: LD_INT 16
69201: PUSH
69202: LD_INT 7
69204: PUSH
69205: LD_INT 12
69207: PUSH
69208: LD_INT 13
69210: PUSH
69211: LD_INT 10
69213: PUSH
69214: LD_INT 14
69216: PUSH
69217: LD_INT 20
69219: PUSH
69220: LD_INT 21
69222: PUSH
69223: LD_INT 22
69225: PUSH
69226: LD_INT 25
69228: PUSH
69229: LD_INT 32
69231: PUSH
69232: LD_INT 27
69234: PUSH
69235: LD_INT 36
69237: PUSH
69238: LD_INT 69
69240: PUSH
69241: LD_INT 39
69243: PUSH
69244: LD_INT 34
69246: PUSH
69247: LD_INT 40
69249: PUSH
69250: LD_INT 48
69252: PUSH
69253: LD_INT 49
69255: PUSH
69256: LD_INT 50
69258: PUSH
69259: LD_INT 51
69261: PUSH
69262: LD_INT 52
69264: PUSH
69265: LD_INT 53
69267: PUSH
69268: LD_INT 54
69270: PUSH
69271: LD_INT 55
69273: PUSH
69274: LD_INT 56
69276: PUSH
69277: LD_INT 57
69279: PUSH
69280: LD_INT 58
69282: PUSH
69283: LD_INT 59
69285: PUSH
69286: LD_INT 60
69288: PUSH
69289: LD_INT 61
69291: PUSH
69292: LD_INT 62
69294: PUSH
69295: LD_INT 80
69297: PUSH
69298: LD_INT 82
69300: PUSH
69301: LD_INT 83
69303: PUSH
69304: LD_INT 84
69306: PUSH
69307: LD_INT 85
69309: PUSH
69310: LD_INT 86
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: ST_TO_ADDR
69366: GO 69833
69368: LD_INT 2
69370: DOUBLE
69371: EQUAL
69372: IFTRUE 69376
69374: GO 69602
69376: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69377: LD_ADDR_VAR 0 4
69381: PUSH
69382: LD_INT 35
69384: PUSH
69385: LD_INT 45
69387: PUSH
69388: LD_INT 46
69390: PUSH
69391: LD_INT 47
69393: PUSH
69394: LD_INT 82
69396: PUSH
69397: LD_INT 83
69399: PUSH
69400: LD_INT 84
69402: PUSH
69403: LD_INT 85
69405: PUSH
69406: LD_INT 87
69408: PUSH
69409: LD_INT 70
69411: PUSH
69412: LD_INT 1
69414: PUSH
69415: LD_INT 11
69417: PUSH
69418: LD_INT 3
69420: PUSH
69421: LD_INT 4
69423: PUSH
69424: LD_INT 5
69426: PUSH
69427: LD_INT 6
69429: PUSH
69430: LD_INT 15
69432: PUSH
69433: LD_INT 18
69435: PUSH
69436: LD_INT 7
69438: PUSH
69439: LD_INT 17
69441: PUSH
69442: LD_INT 8
69444: PUSH
69445: LD_INT 20
69447: PUSH
69448: LD_INT 21
69450: PUSH
69451: LD_INT 22
69453: PUSH
69454: LD_INT 72
69456: PUSH
69457: LD_INT 26
69459: PUSH
69460: LD_INT 69
69462: PUSH
69463: LD_INT 39
69465: PUSH
69466: LD_INT 40
69468: PUSH
69469: LD_INT 41
69471: PUSH
69472: LD_INT 42
69474: PUSH
69475: LD_INT 43
69477: PUSH
69478: LD_INT 48
69480: PUSH
69481: LD_INT 49
69483: PUSH
69484: LD_INT 50
69486: PUSH
69487: LD_INT 51
69489: PUSH
69490: LD_INT 52
69492: PUSH
69493: LD_INT 53
69495: PUSH
69496: LD_INT 54
69498: PUSH
69499: LD_INT 55
69501: PUSH
69502: LD_INT 56
69504: PUSH
69505: LD_INT 60
69507: PUSH
69508: LD_INT 61
69510: PUSH
69511: LD_INT 62
69513: PUSH
69514: LD_INT 66
69516: PUSH
69517: LD_INT 67
69519: PUSH
69520: LD_INT 68
69522: PUSH
69523: LD_INT 81
69525: PUSH
69526: LD_INT 82
69528: PUSH
69529: LD_INT 83
69531: PUSH
69532: LD_INT 84
69534: PUSH
69535: LD_INT 85
69537: PUSH
69538: LD_INT 87
69540: PUSH
69541: LD_INT 88
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: LIST
69553: LIST
69554: LIST
69555: LIST
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: LIST
69561: LIST
69562: LIST
69563: LIST
69564: LIST
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: LIST
69575: LIST
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: ST_TO_ADDR
69600: GO 69833
69602: LD_INT 3
69604: DOUBLE
69605: EQUAL
69606: IFTRUE 69610
69608: GO 69832
69610: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69611: LD_ADDR_VAR 0 4
69615: PUSH
69616: LD_INT 46
69618: PUSH
69619: LD_INT 47
69621: PUSH
69622: LD_INT 1
69624: PUSH
69625: LD_INT 2
69627: PUSH
69628: LD_INT 82
69630: PUSH
69631: LD_INT 83
69633: PUSH
69634: LD_INT 84
69636: PUSH
69637: LD_INT 85
69639: PUSH
69640: LD_INT 86
69642: PUSH
69643: LD_INT 11
69645: PUSH
69646: LD_INT 9
69648: PUSH
69649: LD_INT 20
69651: PUSH
69652: LD_INT 19
69654: PUSH
69655: LD_INT 21
69657: PUSH
69658: LD_INT 24
69660: PUSH
69661: LD_INT 22
69663: PUSH
69664: LD_INT 25
69666: PUSH
69667: LD_INT 28
69669: PUSH
69670: LD_INT 29
69672: PUSH
69673: LD_INT 30
69675: PUSH
69676: LD_INT 31
69678: PUSH
69679: LD_INT 37
69681: PUSH
69682: LD_INT 38
69684: PUSH
69685: LD_INT 32
69687: PUSH
69688: LD_INT 27
69690: PUSH
69691: LD_INT 33
69693: PUSH
69694: LD_INT 69
69696: PUSH
69697: LD_INT 39
69699: PUSH
69700: LD_INT 34
69702: PUSH
69703: LD_INT 40
69705: PUSH
69706: LD_INT 71
69708: PUSH
69709: LD_INT 23
69711: PUSH
69712: LD_INT 44
69714: PUSH
69715: LD_INT 48
69717: PUSH
69718: LD_INT 49
69720: PUSH
69721: LD_INT 50
69723: PUSH
69724: LD_INT 51
69726: PUSH
69727: LD_INT 52
69729: PUSH
69730: LD_INT 53
69732: PUSH
69733: LD_INT 54
69735: PUSH
69736: LD_INT 55
69738: PUSH
69739: LD_INT 56
69741: PUSH
69742: LD_INT 57
69744: PUSH
69745: LD_INT 58
69747: PUSH
69748: LD_INT 59
69750: PUSH
69751: LD_INT 63
69753: PUSH
69754: LD_INT 64
69756: PUSH
69757: LD_INT 65
69759: PUSH
69760: LD_INT 82
69762: PUSH
69763: LD_INT 83
69765: PUSH
69766: LD_INT 84
69768: PUSH
69769: LD_INT 85
69771: PUSH
69772: LD_INT 86
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: LIST
69781: LIST
69782: LIST
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: LIST
69788: LIST
69789: LIST
69790: LIST
69791: LIST
69792: LIST
69793: LIST
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: LIST
69799: LIST
69800: LIST
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: ST_TO_ADDR
69830: GO 69833
69832: POP
// if state > - 1 and state < 3 then
69833: LD_VAR 0 3
69837: PUSH
69838: LD_INT 1
69840: NEG
69841: GREATER
69842: PUSH
69843: LD_VAR 0 3
69847: PUSH
69848: LD_INT 3
69850: LESS
69851: AND
69852: IFFALSE 69909
// for i in result do
69854: LD_ADDR_VAR 0 5
69858: PUSH
69859: LD_VAR 0 4
69863: PUSH
69864: FOR_IN
69865: IFFALSE 69907
// if GetTech ( i , side ) <> state then
69867: LD_VAR 0 5
69871: PPUSH
69872: LD_VAR 0 1
69876: PPUSH
69877: CALL_OW 321
69881: PUSH
69882: LD_VAR 0 3
69886: NONEQUAL
69887: IFFALSE 69905
// result := result diff i ;
69889: LD_ADDR_VAR 0 4
69893: PUSH
69894: LD_VAR 0 4
69898: PUSH
69899: LD_VAR 0 5
69903: DIFF
69904: ST_TO_ADDR
69905: GO 69864
69907: POP
69908: POP
// end ;
69909: LD_VAR 0 4
69913: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
69914: LD_INT 0
69916: PPUSH
69917: PPUSH
69918: PPUSH
// result := true ;
69919: LD_ADDR_VAR 0 3
69923: PUSH
69924: LD_INT 1
69926: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
69927: LD_ADDR_VAR 0 5
69931: PUSH
69932: LD_VAR 0 2
69936: PPUSH
69937: CALL_OW 480
69941: ST_TO_ADDR
// if not tmp then
69942: LD_VAR 0 5
69946: NOT
69947: IFFALSE 69951
// exit ;
69949: GO 70000
// for i in tmp do
69951: LD_ADDR_VAR 0 4
69955: PUSH
69956: LD_VAR 0 5
69960: PUSH
69961: FOR_IN
69962: IFFALSE 69998
// if GetTech ( i , side ) <> state_researched then
69964: LD_VAR 0 4
69968: PPUSH
69969: LD_VAR 0 1
69973: PPUSH
69974: CALL_OW 321
69978: PUSH
69979: LD_INT 2
69981: NONEQUAL
69982: IFFALSE 69996
// begin result := false ;
69984: LD_ADDR_VAR 0 3
69988: PUSH
69989: LD_INT 0
69991: ST_TO_ADDR
// exit ;
69992: POP
69993: POP
69994: GO 70000
// end ;
69996: GO 69961
69998: POP
69999: POP
// end ;
70000: LD_VAR 0 3
70004: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70005: LD_INT 0
70007: PPUSH
70008: PPUSH
70009: PPUSH
70010: PPUSH
70011: PPUSH
70012: PPUSH
70013: PPUSH
70014: PPUSH
70015: PPUSH
70016: PPUSH
70017: PPUSH
70018: PPUSH
70019: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70020: LD_VAR 0 1
70024: NOT
70025: PUSH
70026: LD_VAR 0 1
70030: PPUSH
70031: CALL_OW 257
70035: PUSH
70036: LD_INT 9
70038: NONEQUAL
70039: OR
70040: IFFALSE 70044
// exit ;
70042: GO 70617
// side := GetSide ( unit ) ;
70044: LD_ADDR_VAR 0 9
70048: PUSH
70049: LD_VAR 0 1
70053: PPUSH
70054: CALL_OW 255
70058: ST_TO_ADDR
// tech_space := tech_spacanom ;
70059: LD_ADDR_VAR 0 12
70063: PUSH
70064: LD_INT 29
70066: ST_TO_ADDR
// tech_time := tech_taurad ;
70067: LD_ADDR_VAR 0 13
70071: PUSH
70072: LD_INT 28
70074: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70075: LD_ADDR_VAR 0 11
70079: PUSH
70080: LD_VAR 0 1
70084: PPUSH
70085: CALL_OW 310
70089: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70090: LD_VAR 0 11
70094: PPUSH
70095: CALL_OW 247
70099: PUSH
70100: LD_INT 2
70102: EQUAL
70103: IFFALSE 70107
// exit ;
70105: GO 70617
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70107: LD_ADDR_VAR 0 8
70111: PUSH
70112: LD_INT 81
70114: PUSH
70115: LD_VAR 0 9
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 3
70126: PUSH
70127: LD_INT 21
70129: PUSH
70130: LD_INT 3
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PPUSH
70145: CALL_OW 69
70149: ST_TO_ADDR
// if not tmp then
70150: LD_VAR 0 8
70154: NOT
70155: IFFALSE 70159
// exit ;
70157: GO 70617
// if in_unit then
70159: LD_VAR 0 11
70163: IFFALSE 70187
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70165: LD_ADDR_VAR 0 10
70169: PUSH
70170: LD_VAR 0 8
70174: PPUSH
70175: LD_VAR 0 11
70179: PPUSH
70180: CALL_OW 74
70184: ST_TO_ADDR
70185: GO 70207
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70187: LD_ADDR_VAR 0 10
70191: PUSH
70192: LD_VAR 0 8
70196: PPUSH
70197: LD_VAR 0 1
70201: PPUSH
70202: CALL_OW 74
70206: ST_TO_ADDR
// if not enemy then
70207: LD_VAR 0 10
70211: NOT
70212: IFFALSE 70216
// exit ;
70214: GO 70617
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70216: LD_VAR 0 11
70220: PUSH
70221: LD_VAR 0 11
70225: PPUSH
70226: LD_VAR 0 10
70230: PPUSH
70231: CALL_OW 296
70235: PUSH
70236: LD_INT 13
70238: GREATER
70239: AND
70240: PUSH
70241: LD_VAR 0 1
70245: PPUSH
70246: LD_VAR 0 10
70250: PPUSH
70251: CALL_OW 296
70255: PUSH
70256: LD_INT 12
70258: GREATER
70259: OR
70260: IFFALSE 70264
// exit ;
70262: GO 70617
// missile := [ 1 ] ;
70264: LD_ADDR_VAR 0 14
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: EMPTY
70273: LIST
70274: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70275: LD_VAR 0 9
70279: PPUSH
70280: LD_VAR 0 12
70284: PPUSH
70285: CALL_OW 325
70289: IFFALSE 70318
// missile := Replace ( missile , missile + 1 , 2 ) ;
70291: LD_ADDR_VAR 0 14
70295: PUSH
70296: LD_VAR 0 14
70300: PPUSH
70301: LD_VAR 0 14
70305: PUSH
70306: LD_INT 1
70308: PLUS
70309: PPUSH
70310: LD_INT 2
70312: PPUSH
70313: CALL_OW 1
70317: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70318: LD_VAR 0 9
70322: PPUSH
70323: LD_VAR 0 13
70327: PPUSH
70328: CALL_OW 325
70332: PUSH
70333: LD_VAR 0 10
70337: PPUSH
70338: CALL_OW 255
70342: PPUSH
70343: LD_VAR 0 13
70347: PPUSH
70348: CALL_OW 325
70352: NOT
70353: AND
70354: IFFALSE 70383
// missile := Replace ( missile , missile + 1 , 3 ) ;
70356: LD_ADDR_VAR 0 14
70360: PUSH
70361: LD_VAR 0 14
70365: PPUSH
70366: LD_VAR 0 14
70370: PUSH
70371: LD_INT 1
70373: PLUS
70374: PPUSH
70375: LD_INT 3
70377: PPUSH
70378: CALL_OW 1
70382: ST_TO_ADDR
// if missile < 2 then
70383: LD_VAR 0 14
70387: PUSH
70388: LD_INT 2
70390: LESS
70391: IFFALSE 70395
// exit ;
70393: GO 70617
// x := GetX ( enemy ) ;
70395: LD_ADDR_VAR 0 4
70399: PUSH
70400: LD_VAR 0 10
70404: PPUSH
70405: CALL_OW 250
70409: ST_TO_ADDR
// y := GetY ( enemy ) ;
70410: LD_ADDR_VAR 0 5
70414: PUSH
70415: LD_VAR 0 10
70419: PPUSH
70420: CALL_OW 251
70424: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70425: LD_ADDR_VAR 0 6
70429: PUSH
70430: LD_VAR 0 4
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PPUSH
70439: LD_INT 1
70441: PPUSH
70442: CALL_OW 12
70446: PLUS
70447: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70448: LD_ADDR_VAR 0 7
70452: PUSH
70453: LD_VAR 0 5
70457: PUSH
70458: LD_INT 1
70460: NEG
70461: PPUSH
70462: LD_INT 1
70464: PPUSH
70465: CALL_OW 12
70469: PLUS
70470: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70471: LD_VAR 0 6
70475: PPUSH
70476: LD_VAR 0 7
70480: PPUSH
70481: CALL_OW 488
70485: NOT
70486: IFFALSE 70508
// begin _x := x ;
70488: LD_ADDR_VAR 0 6
70492: PUSH
70493: LD_VAR 0 4
70497: ST_TO_ADDR
// _y := y ;
70498: LD_ADDR_VAR 0 7
70502: PUSH
70503: LD_VAR 0 5
70507: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70508: LD_ADDR_VAR 0 3
70512: PUSH
70513: LD_INT 1
70515: PPUSH
70516: LD_VAR 0 14
70520: PPUSH
70521: CALL_OW 12
70525: ST_TO_ADDR
// case i of 1 :
70526: LD_VAR 0 3
70530: PUSH
70531: LD_INT 1
70533: DOUBLE
70534: EQUAL
70535: IFTRUE 70539
70537: GO 70556
70539: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70540: LD_VAR 0 1
70544: PPUSH
70545: LD_VAR 0 10
70549: PPUSH
70550: CALL_OW 115
70554: GO 70617
70556: LD_INT 2
70558: DOUBLE
70559: EQUAL
70560: IFTRUE 70564
70562: GO 70586
70564: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70565: LD_VAR 0 1
70569: PPUSH
70570: LD_VAR 0 6
70574: PPUSH
70575: LD_VAR 0 7
70579: PPUSH
70580: CALL_OW 153
70584: GO 70617
70586: LD_INT 3
70588: DOUBLE
70589: EQUAL
70590: IFTRUE 70594
70592: GO 70616
70594: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70595: LD_VAR 0 1
70599: PPUSH
70600: LD_VAR 0 6
70604: PPUSH
70605: LD_VAR 0 7
70609: PPUSH
70610: CALL_OW 154
70614: GO 70617
70616: POP
// end ;
70617: LD_VAR 0 2
70621: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
70622: LD_INT 0
70624: PPUSH
70625: PPUSH
70626: PPUSH
70627: PPUSH
70628: PPUSH
70629: PPUSH
// if not unit or not building then
70630: LD_VAR 0 1
70634: NOT
70635: PUSH
70636: LD_VAR 0 2
70640: NOT
70641: OR
70642: IFFALSE 70646
// exit ;
70644: GO 70804
// x := GetX ( building ) ;
70646: LD_ADDR_VAR 0 5
70650: PUSH
70651: LD_VAR 0 2
70655: PPUSH
70656: CALL_OW 250
70660: ST_TO_ADDR
// y := GetY ( building ) ;
70661: LD_ADDR_VAR 0 6
70665: PUSH
70666: LD_VAR 0 2
70670: PPUSH
70671: CALL_OW 251
70675: ST_TO_ADDR
// for i = 0 to 5 do
70676: LD_ADDR_VAR 0 4
70680: PUSH
70681: DOUBLE
70682: LD_INT 0
70684: DEC
70685: ST_TO_ADDR
70686: LD_INT 5
70688: PUSH
70689: FOR_TO
70690: IFFALSE 70802
// begin _x := ShiftX ( x , i , 3 ) ;
70692: LD_ADDR_VAR 0 7
70696: PUSH
70697: LD_VAR 0 5
70701: PPUSH
70702: LD_VAR 0 4
70706: PPUSH
70707: LD_INT 3
70709: PPUSH
70710: CALL_OW 272
70714: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
70715: LD_ADDR_VAR 0 8
70719: PUSH
70720: LD_VAR 0 6
70724: PPUSH
70725: LD_VAR 0 4
70729: PPUSH
70730: LD_INT 3
70732: PPUSH
70733: CALL_OW 273
70737: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70738: LD_VAR 0 7
70742: PPUSH
70743: LD_VAR 0 8
70747: PPUSH
70748: CALL_OW 488
70752: NOT
70753: IFFALSE 70757
// continue ;
70755: GO 70689
// if HexInfo ( _x , _y ) = 0 then
70757: LD_VAR 0 7
70761: PPUSH
70762: LD_VAR 0 8
70766: PPUSH
70767: CALL_OW 428
70771: PUSH
70772: LD_INT 0
70774: EQUAL
70775: IFFALSE 70800
// begin ComMoveXY ( unit , _x , _y ) ;
70777: LD_VAR 0 1
70781: PPUSH
70782: LD_VAR 0 7
70786: PPUSH
70787: LD_VAR 0 8
70791: PPUSH
70792: CALL_OW 111
// exit ;
70796: POP
70797: POP
70798: GO 70804
// end ; end ;
70800: GO 70689
70802: POP
70803: POP
// end ;
70804: LD_VAR 0 3
70808: RET
// export function ScanBase ( side , base_area ) ; begin
70809: LD_INT 0
70811: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
70812: LD_ADDR_VAR 0 3
70816: PUSH
70817: LD_VAR 0 2
70821: PPUSH
70822: LD_INT 81
70824: PUSH
70825: LD_VAR 0 1
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PPUSH
70834: CALL_OW 70
70838: ST_TO_ADDR
// end ;
70839: LD_VAR 0 3
70843: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
70844: LD_INT 0
70846: PPUSH
70847: PPUSH
70848: PPUSH
70849: PPUSH
// result := false ;
70850: LD_ADDR_VAR 0 2
70854: PUSH
70855: LD_INT 0
70857: ST_TO_ADDR
// side := GetSide ( unit ) ;
70858: LD_ADDR_VAR 0 3
70862: PUSH
70863: LD_VAR 0 1
70867: PPUSH
70868: CALL_OW 255
70872: ST_TO_ADDR
// nat := GetNation ( unit ) ;
70873: LD_ADDR_VAR 0 4
70877: PUSH
70878: LD_VAR 0 1
70882: PPUSH
70883: CALL_OW 248
70887: ST_TO_ADDR
// case nat of 1 :
70888: LD_VAR 0 4
70892: PUSH
70893: LD_INT 1
70895: DOUBLE
70896: EQUAL
70897: IFTRUE 70901
70899: GO 70912
70901: POP
// tech := tech_lassight ; 2 :
70902: LD_ADDR_VAR 0 5
70906: PUSH
70907: LD_INT 12
70909: ST_TO_ADDR
70910: GO 70951
70912: LD_INT 2
70914: DOUBLE
70915: EQUAL
70916: IFTRUE 70920
70918: GO 70931
70920: POP
// tech := tech_mortar ; 3 :
70921: LD_ADDR_VAR 0 5
70925: PUSH
70926: LD_INT 41
70928: ST_TO_ADDR
70929: GO 70951
70931: LD_INT 3
70933: DOUBLE
70934: EQUAL
70935: IFTRUE 70939
70937: GO 70950
70939: POP
// tech := tech_bazooka ; end ;
70940: LD_ADDR_VAR 0 5
70944: PUSH
70945: LD_INT 44
70947: ST_TO_ADDR
70948: GO 70951
70950: POP
// if Researched ( side , tech ) then
70951: LD_VAR 0 3
70955: PPUSH
70956: LD_VAR 0 5
70960: PPUSH
70961: CALL_OW 325
70965: IFFALSE 70992
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
70967: LD_ADDR_VAR 0 2
70971: PUSH
70972: LD_INT 5
70974: PUSH
70975: LD_INT 8
70977: PUSH
70978: LD_INT 9
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: LIST
70985: PUSH
70986: LD_VAR 0 4
70990: ARRAY
70991: ST_TO_ADDR
// end ;
70992: LD_VAR 0 2
70996: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
70997: LD_INT 0
70999: PPUSH
71000: PPUSH
71001: PPUSH
// if not mines then
71002: LD_VAR 0 2
71006: NOT
71007: IFFALSE 71011
// exit ;
71009: GO 71155
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71011: LD_ADDR_VAR 0 5
71015: PUSH
71016: LD_INT 81
71018: PUSH
71019: LD_VAR 0 1
71023: PUSH
71024: EMPTY
71025: LIST
71026: LIST
71027: PUSH
71028: LD_INT 3
71030: PUSH
71031: LD_INT 21
71033: PUSH
71034: LD_INT 3
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PPUSH
71049: CALL_OW 69
71053: ST_TO_ADDR
// for i in mines do
71054: LD_ADDR_VAR 0 4
71058: PUSH
71059: LD_VAR 0 2
71063: PUSH
71064: FOR_IN
71065: IFFALSE 71153
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71067: LD_VAR 0 4
71071: PUSH
71072: LD_INT 1
71074: ARRAY
71075: PPUSH
71076: LD_VAR 0 4
71080: PUSH
71081: LD_INT 2
71083: ARRAY
71084: PPUSH
71085: CALL_OW 458
71089: NOT
71090: IFFALSE 71094
// continue ;
71092: GO 71064
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71094: LD_VAR 0 4
71098: PUSH
71099: LD_INT 1
71101: ARRAY
71102: PPUSH
71103: LD_VAR 0 4
71107: PUSH
71108: LD_INT 2
71110: ARRAY
71111: PPUSH
71112: CALL_OW 428
71116: PUSH
71117: LD_VAR 0 5
71121: IN
71122: IFFALSE 71151
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71124: LD_VAR 0 4
71128: PUSH
71129: LD_INT 1
71131: ARRAY
71132: PPUSH
71133: LD_VAR 0 4
71137: PUSH
71138: LD_INT 2
71140: ARRAY
71141: PPUSH
71142: LD_VAR 0 1
71146: PPUSH
71147: CALL_OW 456
// end ;
71151: GO 71064
71153: POP
71154: POP
// end ;
71155: LD_VAR 0 3
71159: RET
// export function Count ( array ) ; begin
71160: LD_INT 0
71162: PPUSH
// result := array + 0 ;
71163: LD_ADDR_VAR 0 2
71167: PUSH
71168: LD_VAR 0 1
71172: PUSH
71173: LD_INT 0
71175: PLUS
71176: ST_TO_ADDR
// end ;
71177: LD_VAR 0 2
71181: RET
// export function IsEmpty ( building ) ; begin
71182: LD_INT 0
71184: PPUSH
// if not building then
71185: LD_VAR 0 1
71189: NOT
71190: IFFALSE 71194
// exit ;
71192: GO 71237
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71194: LD_ADDR_VAR 0 2
71198: PUSH
71199: LD_VAR 0 1
71203: PUSH
71204: LD_INT 22
71206: PUSH
71207: LD_VAR 0 1
71211: PPUSH
71212: CALL_OW 255
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: PUSH
71221: LD_INT 58
71223: PUSH
71224: EMPTY
71225: LIST
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PPUSH
71231: CALL_OW 69
71235: IN
71236: ST_TO_ADDR
// end ;
71237: LD_VAR 0 2
71241: RET
// export function IsNotFull ( building ) ; var places ; begin
71242: LD_INT 0
71244: PPUSH
71245: PPUSH
// if not building then
71246: LD_VAR 0 1
71250: NOT
71251: IFFALSE 71255
// exit ;
71253: GO 71283
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71255: LD_ADDR_VAR 0 2
71259: PUSH
71260: LD_VAR 0 1
71264: PPUSH
71265: LD_INT 3
71267: PUSH
71268: LD_INT 62
71270: PUSH
71271: EMPTY
71272: LIST
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PPUSH
71278: CALL_OW 72
71282: ST_TO_ADDR
// end ;
71283: LD_VAR 0 2
71287: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71288: LD_INT 0
71290: PPUSH
71291: PPUSH
71292: PPUSH
71293: PPUSH
// tmp := [ ] ;
71294: LD_ADDR_VAR 0 3
71298: PUSH
71299: EMPTY
71300: ST_TO_ADDR
// list := [ ] ;
71301: LD_ADDR_VAR 0 5
71305: PUSH
71306: EMPTY
71307: ST_TO_ADDR
// for i = 16 to 25 do
71308: LD_ADDR_VAR 0 4
71312: PUSH
71313: DOUBLE
71314: LD_INT 16
71316: DEC
71317: ST_TO_ADDR
71318: LD_INT 25
71320: PUSH
71321: FOR_TO
71322: IFFALSE 71395
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71324: LD_ADDR_VAR 0 3
71328: PUSH
71329: LD_VAR 0 3
71333: PUSH
71334: LD_INT 22
71336: PUSH
71337: LD_VAR 0 1
71341: PPUSH
71342: CALL_OW 255
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PUSH
71351: LD_INT 91
71353: PUSH
71354: LD_VAR 0 1
71358: PUSH
71359: LD_INT 6
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 30
71369: PUSH
71370: LD_VAR 0 4
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: LIST
71383: PUSH
71384: EMPTY
71385: LIST
71386: PPUSH
71387: CALL_OW 69
71391: ADD
71392: ST_TO_ADDR
71393: GO 71321
71395: POP
71396: POP
// for i = 1 to tmp do
71397: LD_ADDR_VAR 0 4
71401: PUSH
71402: DOUBLE
71403: LD_INT 1
71405: DEC
71406: ST_TO_ADDR
71407: LD_VAR 0 3
71411: PUSH
71412: FOR_TO
71413: IFFALSE 71501
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71415: LD_ADDR_VAR 0 5
71419: PUSH
71420: LD_VAR 0 5
71424: PUSH
71425: LD_VAR 0 3
71429: PUSH
71430: LD_VAR 0 4
71434: ARRAY
71435: PPUSH
71436: CALL_OW 266
71440: PUSH
71441: LD_VAR 0 3
71445: PUSH
71446: LD_VAR 0 4
71450: ARRAY
71451: PPUSH
71452: CALL_OW 250
71456: PUSH
71457: LD_VAR 0 3
71461: PUSH
71462: LD_VAR 0 4
71466: ARRAY
71467: PPUSH
71468: CALL_OW 251
71472: PUSH
71473: LD_VAR 0 3
71477: PUSH
71478: LD_VAR 0 4
71482: ARRAY
71483: PPUSH
71484: CALL_OW 254
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: PUSH
71495: EMPTY
71496: LIST
71497: ADD
71498: ST_TO_ADDR
71499: GO 71412
71501: POP
71502: POP
// result := list ;
71503: LD_ADDR_VAR 0 2
71507: PUSH
71508: LD_VAR 0 5
71512: ST_TO_ADDR
// end ;
71513: LD_VAR 0 2
71517: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71518: LD_INT 0
71520: PPUSH
71521: PPUSH
71522: PPUSH
71523: PPUSH
71524: PPUSH
71525: PPUSH
71526: PPUSH
// if not factory then
71527: LD_VAR 0 1
71531: NOT
71532: IFFALSE 71536
// exit ;
71534: GO 72129
// if control = control_apeman then
71536: LD_VAR 0 4
71540: PUSH
71541: LD_INT 5
71543: EQUAL
71544: IFFALSE 71653
// begin tmp := UnitsInside ( factory ) ;
71546: LD_ADDR_VAR 0 8
71550: PUSH
71551: LD_VAR 0 1
71555: PPUSH
71556: CALL_OW 313
71560: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71561: LD_VAR 0 8
71565: PPUSH
71566: LD_INT 25
71568: PUSH
71569: LD_INT 12
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PPUSH
71576: CALL_OW 72
71580: NOT
71581: IFFALSE 71591
// control := control_manual ;
71583: LD_ADDR_VAR 0 4
71587: PUSH
71588: LD_INT 1
71590: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71591: LD_ADDR_VAR 0 8
71595: PUSH
71596: LD_VAR 0 1
71600: PPUSH
71601: CALL 71288 0 1
71605: ST_TO_ADDR
// if tmp then
71606: LD_VAR 0 8
71610: IFFALSE 71653
// begin for i in tmp do
71612: LD_ADDR_VAR 0 7
71616: PUSH
71617: LD_VAR 0 8
71621: PUSH
71622: FOR_IN
71623: IFFALSE 71651
// if i [ 1 ] = b_ext_radio then
71625: LD_VAR 0 7
71629: PUSH
71630: LD_INT 1
71632: ARRAY
71633: PUSH
71634: LD_INT 22
71636: EQUAL
71637: IFFALSE 71649
// begin control := control_remote ;
71639: LD_ADDR_VAR 0 4
71643: PUSH
71644: LD_INT 2
71646: ST_TO_ADDR
// break ;
71647: GO 71651
// end ;
71649: GO 71622
71651: POP
71652: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71653: LD_VAR 0 1
71657: PPUSH
71658: LD_VAR 0 2
71662: PPUSH
71663: LD_VAR 0 3
71667: PPUSH
71668: LD_VAR 0 4
71672: PPUSH
71673: LD_VAR 0 5
71677: PPUSH
71678: CALL_OW 448
71682: IFFALSE 71717
// begin result := [ chassis , engine , control , weapon ] ;
71684: LD_ADDR_VAR 0 6
71688: PUSH
71689: LD_VAR 0 2
71693: PUSH
71694: LD_VAR 0 3
71698: PUSH
71699: LD_VAR 0 4
71703: PUSH
71704: LD_VAR 0 5
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: ST_TO_ADDR
// exit ;
71715: GO 72129
// end ; _chassis := AvailableChassisList ( factory ) ;
71717: LD_ADDR_VAR 0 9
71721: PUSH
71722: LD_VAR 0 1
71726: PPUSH
71727: CALL_OW 475
71731: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
71732: LD_ADDR_VAR 0 11
71736: PUSH
71737: LD_VAR 0 1
71741: PPUSH
71742: CALL_OW 476
71746: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
71747: LD_ADDR_VAR 0 12
71751: PUSH
71752: LD_VAR 0 1
71756: PPUSH
71757: CALL_OW 477
71761: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
71762: LD_ADDR_VAR 0 10
71766: PUSH
71767: LD_VAR 0 1
71771: PPUSH
71772: CALL_OW 478
71776: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
71777: LD_VAR 0 9
71781: NOT
71782: PUSH
71783: LD_VAR 0 11
71787: NOT
71788: OR
71789: PUSH
71790: LD_VAR 0 12
71794: NOT
71795: OR
71796: PUSH
71797: LD_VAR 0 10
71801: NOT
71802: OR
71803: IFFALSE 71838
// begin result := [ chassis , engine , control , weapon ] ;
71805: LD_ADDR_VAR 0 6
71809: PUSH
71810: LD_VAR 0 2
71814: PUSH
71815: LD_VAR 0 3
71819: PUSH
71820: LD_VAR 0 4
71824: PUSH
71825: LD_VAR 0 5
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: ST_TO_ADDR
// exit ;
71836: GO 72129
// end ; if not chassis in _chassis then
71838: LD_VAR 0 2
71842: PUSH
71843: LD_VAR 0 9
71847: IN
71848: NOT
71849: IFFALSE 71875
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
71851: LD_ADDR_VAR 0 2
71855: PUSH
71856: LD_VAR 0 9
71860: PUSH
71861: LD_INT 1
71863: PPUSH
71864: LD_VAR 0 9
71868: PPUSH
71869: CALL_OW 12
71873: ARRAY
71874: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
71875: LD_VAR 0 2
71879: PPUSH
71880: LD_VAR 0 3
71884: PPUSH
71885: CALL 72134 0 2
71889: NOT
71890: IFFALSE 71949
// repeat engine := _engine [ 1 ] ;
71892: LD_ADDR_VAR 0 3
71896: PUSH
71897: LD_VAR 0 11
71901: PUSH
71902: LD_INT 1
71904: ARRAY
71905: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
71906: LD_ADDR_VAR 0 11
71910: PUSH
71911: LD_VAR 0 11
71915: PPUSH
71916: LD_INT 1
71918: PPUSH
71919: CALL_OW 3
71923: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
71924: LD_VAR 0 2
71928: PPUSH
71929: LD_VAR 0 3
71933: PPUSH
71934: CALL 72134 0 2
71938: PUSH
71939: LD_VAR 0 11
71943: PUSH
71944: EMPTY
71945: EQUAL
71946: OR
71947: IFFALSE 71892
// if not control in _control then
71949: LD_VAR 0 4
71953: PUSH
71954: LD_VAR 0 12
71958: IN
71959: NOT
71960: IFFALSE 71986
// control := _control [ rand ( 1 , _control ) ] ;
71962: LD_ADDR_VAR 0 4
71966: PUSH
71967: LD_VAR 0 12
71971: PUSH
71972: LD_INT 1
71974: PPUSH
71975: LD_VAR 0 12
71979: PPUSH
71980: CALL_OW 12
71984: ARRAY
71985: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
71986: LD_VAR 0 2
71990: PPUSH
71991: LD_VAR 0 5
71995: PPUSH
71996: CALL 72354 0 2
72000: NOT
72001: IFFALSE 72060
// repeat weapon := _weapon [ 1 ] ;
72003: LD_ADDR_VAR 0 5
72007: PUSH
72008: LD_VAR 0 10
72012: PUSH
72013: LD_INT 1
72015: ARRAY
72016: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72017: LD_ADDR_VAR 0 10
72021: PUSH
72022: LD_VAR 0 10
72026: PPUSH
72027: LD_INT 1
72029: PPUSH
72030: CALL_OW 3
72034: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72035: LD_VAR 0 2
72039: PPUSH
72040: LD_VAR 0 5
72044: PPUSH
72045: CALL 72354 0 2
72049: PUSH
72050: LD_VAR 0 10
72054: PUSH
72055: EMPTY
72056: EQUAL
72057: OR
72058: IFFALSE 72003
// result := [ ] ;
72060: LD_ADDR_VAR 0 6
72064: PUSH
72065: EMPTY
72066: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72067: LD_VAR 0 1
72071: PPUSH
72072: LD_VAR 0 2
72076: PPUSH
72077: LD_VAR 0 3
72081: PPUSH
72082: LD_VAR 0 4
72086: PPUSH
72087: LD_VAR 0 5
72091: PPUSH
72092: CALL_OW 448
72096: IFFALSE 72129
// result := [ chassis , engine , control , weapon ] ;
72098: LD_ADDR_VAR 0 6
72102: PUSH
72103: LD_VAR 0 2
72107: PUSH
72108: LD_VAR 0 3
72112: PUSH
72113: LD_VAR 0 4
72117: PUSH
72118: LD_VAR 0 5
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: ST_TO_ADDR
// end ;
72129: LD_VAR 0 6
72133: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72134: LD_INT 0
72136: PPUSH
// if not chassis or not engine then
72137: LD_VAR 0 1
72141: NOT
72142: PUSH
72143: LD_VAR 0 2
72147: NOT
72148: OR
72149: IFFALSE 72153
// exit ;
72151: GO 72349
// case engine of engine_solar :
72153: LD_VAR 0 2
72157: PUSH
72158: LD_INT 2
72160: DOUBLE
72161: EQUAL
72162: IFTRUE 72166
72164: GO 72204
72166: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72167: LD_ADDR_VAR 0 3
72171: PUSH
72172: LD_INT 11
72174: PUSH
72175: LD_INT 12
72177: PUSH
72178: LD_INT 13
72180: PUSH
72181: LD_INT 14
72183: PUSH
72184: LD_INT 1
72186: PUSH
72187: LD_INT 2
72189: PUSH
72190: LD_INT 3
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: ST_TO_ADDR
72202: GO 72333
72204: LD_INT 1
72206: DOUBLE
72207: EQUAL
72208: IFTRUE 72212
72210: GO 72274
72212: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72213: LD_ADDR_VAR 0 3
72217: PUSH
72218: LD_INT 11
72220: PUSH
72221: LD_INT 12
72223: PUSH
72224: LD_INT 13
72226: PUSH
72227: LD_INT 14
72229: PUSH
72230: LD_INT 1
72232: PUSH
72233: LD_INT 2
72235: PUSH
72236: LD_INT 3
72238: PUSH
72239: LD_INT 4
72241: PUSH
72242: LD_INT 5
72244: PUSH
72245: LD_INT 21
72247: PUSH
72248: LD_INT 23
72250: PUSH
72251: LD_INT 22
72253: PUSH
72254: LD_INT 24
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: LIST
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: LIST
72269: LIST
72270: LIST
72271: ST_TO_ADDR
72272: GO 72333
72274: LD_INT 3
72276: DOUBLE
72277: EQUAL
72278: IFTRUE 72282
72280: GO 72332
72282: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72283: LD_ADDR_VAR 0 3
72287: PUSH
72288: LD_INT 13
72290: PUSH
72291: LD_INT 14
72293: PUSH
72294: LD_INT 2
72296: PUSH
72297: LD_INT 3
72299: PUSH
72300: LD_INT 4
72302: PUSH
72303: LD_INT 5
72305: PUSH
72306: LD_INT 21
72308: PUSH
72309: LD_INT 22
72311: PUSH
72312: LD_INT 23
72314: PUSH
72315: LD_INT 24
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: ST_TO_ADDR
72330: GO 72333
72332: POP
// result := ( chassis in result ) ;
72333: LD_ADDR_VAR 0 3
72337: PUSH
72338: LD_VAR 0 1
72342: PUSH
72343: LD_VAR 0 3
72347: IN
72348: ST_TO_ADDR
// end ;
72349: LD_VAR 0 3
72353: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72354: LD_INT 0
72356: PPUSH
// if not chassis or not weapon then
72357: LD_VAR 0 1
72361: NOT
72362: PUSH
72363: LD_VAR 0 2
72367: NOT
72368: OR
72369: IFFALSE 72373
// exit ;
72371: GO 73433
// case weapon of us_machine_gun :
72373: LD_VAR 0 2
72377: PUSH
72378: LD_INT 2
72380: DOUBLE
72381: EQUAL
72382: IFTRUE 72386
72384: GO 72416
72386: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72387: LD_ADDR_VAR 0 3
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: LD_INT 2
72397: PUSH
72398: LD_INT 3
72400: PUSH
72401: LD_INT 4
72403: PUSH
72404: LD_INT 5
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: ST_TO_ADDR
72414: GO 73417
72416: LD_INT 3
72418: DOUBLE
72419: EQUAL
72420: IFTRUE 72424
72422: GO 72454
72424: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72425: LD_ADDR_VAR 0 3
72429: PUSH
72430: LD_INT 1
72432: PUSH
72433: LD_INT 2
72435: PUSH
72436: LD_INT 3
72438: PUSH
72439: LD_INT 4
72441: PUSH
72442: LD_INT 5
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: ST_TO_ADDR
72452: GO 73417
72454: LD_INT 11
72456: DOUBLE
72457: EQUAL
72458: IFTRUE 72462
72460: GO 72492
72462: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72463: LD_ADDR_VAR 0 3
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: LD_INT 2
72473: PUSH
72474: LD_INT 3
72476: PUSH
72477: LD_INT 4
72479: PUSH
72480: LD_INT 5
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: ST_TO_ADDR
72490: GO 73417
72492: LD_INT 4
72494: DOUBLE
72495: EQUAL
72496: IFTRUE 72500
72498: GO 72526
72500: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72501: LD_ADDR_VAR 0 3
72505: PUSH
72506: LD_INT 2
72508: PUSH
72509: LD_INT 3
72511: PUSH
72512: LD_INT 4
72514: PUSH
72515: LD_INT 5
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: LIST
72522: LIST
72523: ST_TO_ADDR
72524: GO 73417
72526: LD_INT 5
72528: DOUBLE
72529: EQUAL
72530: IFTRUE 72534
72532: GO 72560
72534: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72535: LD_ADDR_VAR 0 3
72539: PUSH
72540: LD_INT 2
72542: PUSH
72543: LD_INT 3
72545: PUSH
72546: LD_INT 4
72548: PUSH
72549: LD_INT 5
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: ST_TO_ADDR
72558: GO 73417
72560: LD_INT 9
72562: DOUBLE
72563: EQUAL
72564: IFTRUE 72568
72566: GO 72594
72568: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72569: LD_ADDR_VAR 0 3
72573: PUSH
72574: LD_INT 2
72576: PUSH
72577: LD_INT 3
72579: PUSH
72580: LD_INT 4
72582: PUSH
72583: LD_INT 5
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: ST_TO_ADDR
72592: GO 73417
72594: LD_INT 7
72596: DOUBLE
72597: EQUAL
72598: IFTRUE 72602
72600: GO 72628
72602: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72603: LD_ADDR_VAR 0 3
72607: PUSH
72608: LD_INT 2
72610: PUSH
72611: LD_INT 3
72613: PUSH
72614: LD_INT 4
72616: PUSH
72617: LD_INT 5
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: ST_TO_ADDR
72626: GO 73417
72628: LD_INT 12
72630: DOUBLE
72631: EQUAL
72632: IFTRUE 72636
72634: GO 72662
72636: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
72637: LD_ADDR_VAR 0 3
72641: PUSH
72642: LD_INT 2
72644: PUSH
72645: LD_INT 3
72647: PUSH
72648: LD_INT 4
72650: PUSH
72651: LD_INT 5
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: ST_TO_ADDR
72660: GO 73417
72662: LD_INT 13
72664: DOUBLE
72665: EQUAL
72666: IFTRUE 72670
72668: GO 72696
72670: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
72671: LD_ADDR_VAR 0 3
72675: PUSH
72676: LD_INT 2
72678: PUSH
72679: LD_INT 3
72681: PUSH
72682: LD_INT 4
72684: PUSH
72685: LD_INT 5
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: LIST
72692: LIST
72693: ST_TO_ADDR
72694: GO 73417
72696: LD_INT 14
72698: DOUBLE
72699: EQUAL
72700: IFTRUE 72704
72702: GO 72722
72704: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
72705: LD_ADDR_VAR 0 3
72709: PUSH
72710: LD_INT 4
72712: PUSH
72713: LD_INT 5
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: ST_TO_ADDR
72720: GO 73417
72722: LD_INT 6
72724: DOUBLE
72725: EQUAL
72726: IFTRUE 72730
72728: GO 72748
72730: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
72731: LD_ADDR_VAR 0 3
72735: PUSH
72736: LD_INT 4
72738: PUSH
72739: LD_INT 5
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: ST_TO_ADDR
72746: GO 73417
72748: LD_INT 10
72750: DOUBLE
72751: EQUAL
72752: IFTRUE 72756
72754: GO 72774
72756: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
72757: LD_ADDR_VAR 0 3
72761: PUSH
72762: LD_INT 4
72764: PUSH
72765: LD_INT 5
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: ST_TO_ADDR
72772: GO 73417
72774: LD_INT 22
72776: DOUBLE
72777: EQUAL
72778: IFTRUE 72782
72780: GO 72808
72782: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
72783: LD_ADDR_VAR 0 3
72787: PUSH
72788: LD_INT 11
72790: PUSH
72791: LD_INT 12
72793: PUSH
72794: LD_INT 13
72796: PUSH
72797: LD_INT 14
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: LIST
72804: LIST
72805: ST_TO_ADDR
72806: GO 73417
72808: LD_INT 23
72810: DOUBLE
72811: EQUAL
72812: IFTRUE 72816
72814: GO 72842
72816: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
72817: LD_ADDR_VAR 0 3
72821: PUSH
72822: LD_INT 11
72824: PUSH
72825: LD_INT 12
72827: PUSH
72828: LD_INT 13
72830: PUSH
72831: LD_INT 14
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: ST_TO_ADDR
72840: GO 73417
72842: LD_INT 24
72844: DOUBLE
72845: EQUAL
72846: IFTRUE 72850
72848: GO 72876
72850: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
72851: LD_ADDR_VAR 0 3
72855: PUSH
72856: LD_INT 11
72858: PUSH
72859: LD_INT 12
72861: PUSH
72862: LD_INT 13
72864: PUSH
72865: LD_INT 14
72867: PUSH
72868: EMPTY
72869: LIST
72870: LIST
72871: LIST
72872: LIST
72873: ST_TO_ADDR
72874: GO 73417
72876: LD_INT 30
72878: DOUBLE
72879: EQUAL
72880: IFTRUE 72884
72882: GO 72910
72884: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
72885: LD_ADDR_VAR 0 3
72889: PUSH
72890: LD_INT 11
72892: PUSH
72893: LD_INT 12
72895: PUSH
72896: LD_INT 13
72898: PUSH
72899: LD_INT 14
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: LIST
72906: LIST
72907: ST_TO_ADDR
72908: GO 73417
72910: LD_INT 25
72912: DOUBLE
72913: EQUAL
72914: IFTRUE 72918
72916: GO 72936
72918: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
72919: LD_ADDR_VAR 0 3
72923: PUSH
72924: LD_INT 13
72926: PUSH
72927: LD_INT 14
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: ST_TO_ADDR
72934: GO 73417
72936: LD_INT 27
72938: DOUBLE
72939: EQUAL
72940: IFTRUE 72944
72942: GO 72962
72944: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
72945: LD_ADDR_VAR 0 3
72949: PUSH
72950: LD_INT 13
72952: PUSH
72953: LD_INT 14
72955: PUSH
72956: EMPTY
72957: LIST
72958: LIST
72959: ST_TO_ADDR
72960: GO 73417
72962: LD_INT 92
72964: DOUBLE
72965: EQUAL
72966: IFTRUE 72970
72968: GO 72996
72970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
72971: LD_ADDR_VAR 0 3
72975: PUSH
72976: LD_INT 11
72978: PUSH
72979: LD_INT 12
72981: PUSH
72982: LD_INT 13
72984: PUSH
72985: LD_INT 14
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: LIST
72992: LIST
72993: ST_TO_ADDR
72994: GO 73417
72996: LD_INT 28
72998: DOUBLE
72999: EQUAL
73000: IFTRUE 73004
73002: GO 73022
73004: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73005: LD_ADDR_VAR 0 3
73009: PUSH
73010: LD_INT 13
73012: PUSH
73013: LD_INT 14
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: ST_TO_ADDR
73020: GO 73417
73022: LD_INT 29
73024: DOUBLE
73025: EQUAL
73026: IFTRUE 73030
73028: GO 73048
73030: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73031: LD_ADDR_VAR 0 3
73035: PUSH
73036: LD_INT 13
73038: PUSH
73039: LD_INT 14
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: ST_TO_ADDR
73046: GO 73417
73048: LD_INT 31
73050: DOUBLE
73051: EQUAL
73052: IFTRUE 73056
73054: GO 73074
73056: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73057: LD_ADDR_VAR 0 3
73061: PUSH
73062: LD_INT 13
73064: PUSH
73065: LD_INT 14
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: ST_TO_ADDR
73072: GO 73417
73074: LD_INT 26
73076: DOUBLE
73077: EQUAL
73078: IFTRUE 73082
73080: GO 73100
73082: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73083: LD_ADDR_VAR 0 3
73087: PUSH
73088: LD_INT 13
73090: PUSH
73091: LD_INT 14
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: ST_TO_ADDR
73098: GO 73417
73100: LD_INT 42
73102: DOUBLE
73103: EQUAL
73104: IFTRUE 73108
73106: GO 73134
73108: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73109: LD_ADDR_VAR 0 3
73113: PUSH
73114: LD_INT 21
73116: PUSH
73117: LD_INT 22
73119: PUSH
73120: LD_INT 23
73122: PUSH
73123: LD_INT 24
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: ST_TO_ADDR
73132: GO 73417
73134: LD_INT 43
73136: DOUBLE
73137: EQUAL
73138: IFTRUE 73142
73140: GO 73168
73142: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73143: LD_ADDR_VAR 0 3
73147: PUSH
73148: LD_INT 21
73150: PUSH
73151: LD_INT 22
73153: PUSH
73154: LD_INT 23
73156: PUSH
73157: LD_INT 24
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: ST_TO_ADDR
73166: GO 73417
73168: LD_INT 44
73170: DOUBLE
73171: EQUAL
73172: IFTRUE 73176
73174: GO 73202
73176: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73177: LD_ADDR_VAR 0 3
73181: PUSH
73182: LD_INT 21
73184: PUSH
73185: LD_INT 22
73187: PUSH
73188: LD_INT 23
73190: PUSH
73191: LD_INT 24
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: ST_TO_ADDR
73200: GO 73417
73202: LD_INT 45
73204: DOUBLE
73205: EQUAL
73206: IFTRUE 73210
73208: GO 73236
73210: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73211: LD_ADDR_VAR 0 3
73215: PUSH
73216: LD_INT 21
73218: PUSH
73219: LD_INT 22
73221: PUSH
73222: LD_INT 23
73224: PUSH
73225: LD_INT 24
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: ST_TO_ADDR
73234: GO 73417
73236: LD_INT 49
73238: DOUBLE
73239: EQUAL
73240: IFTRUE 73244
73242: GO 73270
73244: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73245: LD_ADDR_VAR 0 3
73249: PUSH
73250: LD_INT 21
73252: PUSH
73253: LD_INT 22
73255: PUSH
73256: LD_INT 23
73258: PUSH
73259: LD_INT 24
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: ST_TO_ADDR
73268: GO 73417
73270: LD_INT 51
73272: DOUBLE
73273: EQUAL
73274: IFTRUE 73278
73276: GO 73304
73278: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73279: LD_ADDR_VAR 0 3
73283: PUSH
73284: LD_INT 21
73286: PUSH
73287: LD_INT 22
73289: PUSH
73290: LD_INT 23
73292: PUSH
73293: LD_INT 24
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: ST_TO_ADDR
73302: GO 73417
73304: LD_INT 52
73306: DOUBLE
73307: EQUAL
73308: IFTRUE 73312
73310: GO 73338
73312: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73313: LD_ADDR_VAR 0 3
73317: PUSH
73318: LD_INT 21
73320: PUSH
73321: LD_INT 22
73323: PUSH
73324: LD_INT 23
73326: PUSH
73327: LD_INT 24
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: LIST
73334: LIST
73335: ST_TO_ADDR
73336: GO 73417
73338: LD_INT 53
73340: DOUBLE
73341: EQUAL
73342: IFTRUE 73346
73344: GO 73364
73346: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73347: LD_ADDR_VAR 0 3
73351: PUSH
73352: LD_INT 23
73354: PUSH
73355: LD_INT 24
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: ST_TO_ADDR
73362: GO 73417
73364: LD_INT 46
73366: DOUBLE
73367: EQUAL
73368: IFTRUE 73372
73370: GO 73390
73372: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73373: LD_ADDR_VAR 0 3
73377: PUSH
73378: LD_INT 23
73380: PUSH
73381: LD_INT 24
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: ST_TO_ADDR
73388: GO 73417
73390: LD_INT 47
73392: DOUBLE
73393: EQUAL
73394: IFTRUE 73398
73396: GO 73416
73398: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73399: LD_ADDR_VAR 0 3
73403: PUSH
73404: LD_INT 23
73406: PUSH
73407: LD_INT 24
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: ST_TO_ADDR
73414: GO 73417
73416: POP
// result := ( chassis in result ) ;
73417: LD_ADDR_VAR 0 3
73421: PUSH
73422: LD_VAR 0 1
73426: PUSH
73427: LD_VAR 0 3
73431: IN
73432: ST_TO_ADDR
// end ;
73433: LD_VAR 0 3
73437: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73438: LD_INT 0
73440: PPUSH
73441: PPUSH
73442: PPUSH
73443: PPUSH
73444: PPUSH
73445: PPUSH
73446: PPUSH
// result := array ;
73447: LD_ADDR_VAR 0 5
73451: PUSH
73452: LD_VAR 0 1
73456: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73457: LD_VAR 0 1
73461: NOT
73462: PUSH
73463: LD_VAR 0 2
73467: NOT
73468: OR
73469: PUSH
73470: LD_VAR 0 3
73474: NOT
73475: OR
73476: PUSH
73477: LD_VAR 0 2
73481: PUSH
73482: LD_VAR 0 1
73486: GREATER
73487: OR
73488: PUSH
73489: LD_VAR 0 3
73493: PUSH
73494: LD_VAR 0 1
73498: GREATER
73499: OR
73500: IFFALSE 73504
// exit ;
73502: GO 73800
// if direction then
73504: LD_VAR 0 4
73508: IFFALSE 73572
// begin d := 1 ;
73510: LD_ADDR_VAR 0 9
73514: PUSH
73515: LD_INT 1
73517: ST_TO_ADDR
// if i_from > i_to then
73518: LD_VAR 0 2
73522: PUSH
73523: LD_VAR 0 3
73527: GREATER
73528: IFFALSE 73554
// length := ( array - i_from ) + i_to else
73530: LD_ADDR_VAR 0 11
73534: PUSH
73535: LD_VAR 0 1
73539: PUSH
73540: LD_VAR 0 2
73544: MINUS
73545: PUSH
73546: LD_VAR 0 3
73550: PLUS
73551: ST_TO_ADDR
73552: GO 73570
// length := i_to - i_from ;
73554: LD_ADDR_VAR 0 11
73558: PUSH
73559: LD_VAR 0 3
73563: PUSH
73564: LD_VAR 0 2
73568: MINUS
73569: ST_TO_ADDR
// end else
73570: GO 73633
// begin d := - 1 ;
73572: LD_ADDR_VAR 0 9
73576: PUSH
73577: LD_INT 1
73579: NEG
73580: ST_TO_ADDR
// if i_from > i_to then
73581: LD_VAR 0 2
73585: PUSH
73586: LD_VAR 0 3
73590: GREATER
73591: IFFALSE 73611
// length := i_from - i_to else
73593: LD_ADDR_VAR 0 11
73597: PUSH
73598: LD_VAR 0 2
73602: PUSH
73603: LD_VAR 0 3
73607: MINUS
73608: ST_TO_ADDR
73609: GO 73633
// length := ( array - i_to ) + i_from ;
73611: LD_ADDR_VAR 0 11
73615: PUSH
73616: LD_VAR 0 1
73620: PUSH
73621: LD_VAR 0 3
73625: MINUS
73626: PUSH
73627: LD_VAR 0 2
73631: PLUS
73632: ST_TO_ADDR
// end ; if not length then
73633: LD_VAR 0 11
73637: NOT
73638: IFFALSE 73642
// exit ;
73640: GO 73800
// tmp := array ;
73642: LD_ADDR_VAR 0 10
73646: PUSH
73647: LD_VAR 0 1
73651: ST_TO_ADDR
// for i = 1 to length do
73652: LD_ADDR_VAR 0 6
73656: PUSH
73657: DOUBLE
73658: LD_INT 1
73660: DEC
73661: ST_TO_ADDR
73662: LD_VAR 0 11
73666: PUSH
73667: FOR_TO
73668: IFFALSE 73788
// begin for j = 1 to array do
73670: LD_ADDR_VAR 0 7
73674: PUSH
73675: DOUBLE
73676: LD_INT 1
73678: DEC
73679: ST_TO_ADDR
73680: LD_VAR 0 1
73684: PUSH
73685: FOR_TO
73686: IFFALSE 73774
// begin k := j + d ;
73688: LD_ADDR_VAR 0 8
73692: PUSH
73693: LD_VAR 0 7
73697: PUSH
73698: LD_VAR 0 9
73702: PLUS
73703: ST_TO_ADDR
// if k > array then
73704: LD_VAR 0 8
73708: PUSH
73709: LD_VAR 0 1
73713: GREATER
73714: IFFALSE 73724
// k := 1 ;
73716: LD_ADDR_VAR 0 8
73720: PUSH
73721: LD_INT 1
73723: ST_TO_ADDR
// if not k then
73724: LD_VAR 0 8
73728: NOT
73729: IFFALSE 73741
// k := array ;
73731: LD_ADDR_VAR 0 8
73735: PUSH
73736: LD_VAR 0 1
73740: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
73741: LD_ADDR_VAR 0 10
73745: PUSH
73746: LD_VAR 0 10
73750: PPUSH
73751: LD_VAR 0 8
73755: PPUSH
73756: LD_VAR 0 1
73760: PUSH
73761: LD_VAR 0 7
73765: ARRAY
73766: PPUSH
73767: CALL_OW 1
73771: ST_TO_ADDR
// end ;
73772: GO 73685
73774: POP
73775: POP
// array := tmp ;
73776: LD_ADDR_VAR 0 1
73780: PUSH
73781: LD_VAR 0 10
73785: ST_TO_ADDR
// end ;
73786: GO 73667
73788: POP
73789: POP
// result := array ;
73790: LD_ADDR_VAR 0 5
73794: PUSH
73795: LD_VAR 0 1
73799: ST_TO_ADDR
// end ;
73800: LD_VAR 0 5
73804: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
73805: LD_INT 0
73807: PPUSH
73808: PPUSH
// result := 0 ;
73809: LD_ADDR_VAR 0 3
73813: PUSH
73814: LD_INT 0
73816: ST_TO_ADDR
// if not array or not value in array then
73817: LD_VAR 0 1
73821: NOT
73822: PUSH
73823: LD_VAR 0 2
73827: PUSH
73828: LD_VAR 0 1
73832: IN
73833: NOT
73834: OR
73835: IFFALSE 73839
// exit ;
73837: GO 73893
// for i = 1 to array do
73839: LD_ADDR_VAR 0 4
73843: PUSH
73844: DOUBLE
73845: LD_INT 1
73847: DEC
73848: ST_TO_ADDR
73849: LD_VAR 0 1
73853: PUSH
73854: FOR_TO
73855: IFFALSE 73891
// if value = array [ i ] then
73857: LD_VAR 0 2
73861: PUSH
73862: LD_VAR 0 1
73866: PUSH
73867: LD_VAR 0 4
73871: ARRAY
73872: EQUAL
73873: IFFALSE 73889
// begin result := i ;
73875: LD_ADDR_VAR 0 3
73879: PUSH
73880: LD_VAR 0 4
73884: ST_TO_ADDR
// exit ;
73885: POP
73886: POP
73887: GO 73893
// end ;
73889: GO 73854
73891: POP
73892: POP
// end ;
73893: LD_VAR 0 3
73897: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
73898: LD_INT 0
73900: PPUSH
// vc_chassis := chassis ;
73901: LD_ADDR_OWVAR 37
73905: PUSH
73906: LD_VAR 0 1
73910: ST_TO_ADDR
// vc_engine := engine ;
73911: LD_ADDR_OWVAR 39
73915: PUSH
73916: LD_VAR 0 2
73920: ST_TO_ADDR
// vc_control := control ;
73921: LD_ADDR_OWVAR 38
73925: PUSH
73926: LD_VAR 0 3
73930: ST_TO_ADDR
// vc_weapon := weapon ;
73931: LD_ADDR_OWVAR 40
73935: PUSH
73936: LD_VAR 0 4
73940: ST_TO_ADDR
// vc_fuel_battery := fuel ;
73941: LD_ADDR_OWVAR 41
73945: PUSH
73946: LD_VAR 0 5
73950: ST_TO_ADDR
// end ;
73951: LD_VAR 0 6
73955: RET
// export function WantPlant ( unit ) ; var task ; begin
73956: LD_INT 0
73958: PPUSH
73959: PPUSH
// result := false ;
73960: LD_ADDR_VAR 0 2
73964: PUSH
73965: LD_INT 0
73967: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
73968: LD_ADDR_VAR 0 3
73972: PUSH
73973: LD_VAR 0 1
73977: PPUSH
73978: CALL_OW 437
73982: ST_TO_ADDR
// if task then
73983: LD_VAR 0 3
73987: IFFALSE 74015
// if task [ 1 ] [ 1 ] = p then
73989: LD_VAR 0 3
73993: PUSH
73994: LD_INT 1
73996: ARRAY
73997: PUSH
73998: LD_INT 1
74000: ARRAY
74001: PUSH
74002: LD_STRING p
74004: EQUAL
74005: IFFALSE 74015
// result := true ;
74007: LD_ADDR_VAR 0 2
74011: PUSH
74012: LD_INT 1
74014: ST_TO_ADDR
// end ;
74015: LD_VAR 0 2
74019: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74020: LD_INT 0
74022: PPUSH
74023: PPUSH
74024: PPUSH
74025: PPUSH
// if pos < 1 then
74026: LD_VAR 0 2
74030: PUSH
74031: LD_INT 1
74033: LESS
74034: IFFALSE 74038
// exit ;
74036: GO 74341
// if pos = 1 then
74038: LD_VAR 0 2
74042: PUSH
74043: LD_INT 1
74045: EQUAL
74046: IFFALSE 74079
// result := Replace ( arr , pos [ 1 ] , value ) else
74048: LD_ADDR_VAR 0 4
74052: PUSH
74053: LD_VAR 0 1
74057: PPUSH
74058: LD_VAR 0 2
74062: PUSH
74063: LD_INT 1
74065: ARRAY
74066: PPUSH
74067: LD_VAR 0 3
74071: PPUSH
74072: CALL_OW 1
74076: ST_TO_ADDR
74077: GO 74341
// begin tmp := arr ;
74079: LD_ADDR_VAR 0 6
74083: PUSH
74084: LD_VAR 0 1
74088: ST_TO_ADDR
// s_arr := [ tmp ] ;
74089: LD_ADDR_VAR 0 7
74093: PUSH
74094: LD_VAR 0 6
74098: PUSH
74099: EMPTY
74100: LIST
74101: ST_TO_ADDR
// for i = 1 to pos - 1 do
74102: LD_ADDR_VAR 0 5
74106: PUSH
74107: DOUBLE
74108: LD_INT 1
74110: DEC
74111: ST_TO_ADDR
74112: LD_VAR 0 2
74116: PUSH
74117: LD_INT 1
74119: MINUS
74120: PUSH
74121: FOR_TO
74122: IFFALSE 74167
// begin tmp := tmp [ pos [ i ] ] ;
74124: LD_ADDR_VAR 0 6
74128: PUSH
74129: LD_VAR 0 6
74133: PUSH
74134: LD_VAR 0 2
74138: PUSH
74139: LD_VAR 0 5
74143: ARRAY
74144: ARRAY
74145: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74146: LD_ADDR_VAR 0 7
74150: PUSH
74151: LD_VAR 0 7
74155: PUSH
74156: LD_VAR 0 6
74160: PUSH
74161: EMPTY
74162: LIST
74163: ADD
74164: ST_TO_ADDR
// end ;
74165: GO 74121
74167: POP
74168: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74169: LD_ADDR_VAR 0 6
74173: PUSH
74174: LD_VAR 0 6
74178: PPUSH
74179: LD_VAR 0 2
74183: PUSH
74184: LD_VAR 0 2
74188: ARRAY
74189: PPUSH
74190: LD_VAR 0 3
74194: PPUSH
74195: CALL_OW 1
74199: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74200: LD_ADDR_VAR 0 7
74204: PUSH
74205: LD_VAR 0 7
74209: PPUSH
74210: LD_VAR 0 7
74214: PPUSH
74215: LD_VAR 0 6
74219: PPUSH
74220: CALL_OW 1
74224: ST_TO_ADDR
// for i = s_arr downto 2 do
74225: LD_ADDR_VAR 0 5
74229: PUSH
74230: DOUBLE
74231: LD_VAR 0 7
74235: INC
74236: ST_TO_ADDR
74237: LD_INT 2
74239: PUSH
74240: FOR_DOWNTO
74241: IFFALSE 74325
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74243: LD_ADDR_VAR 0 6
74247: PUSH
74248: LD_VAR 0 7
74252: PUSH
74253: LD_VAR 0 5
74257: PUSH
74258: LD_INT 1
74260: MINUS
74261: ARRAY
74262: PPUSH
74263: LD_VAR 0 2
74267: PUSH
74268: LD_VAR 0 5
74272: PUSH
74273: LD_INT 1
74275: MINUS
74276: ARRAY
74277: PPUSH
74278: LD_VAR 0 7
74282: PUSH
74283: LD_VAR 0 5
74287: ARRAY
74288: PPUSH
74289: CALL_OW 1
74293: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74294: LD_ADDR_VAR 0 7
74298: PUSH
74299: LD_VAR 0 7
74303: PPUSH
74304: LD_VAR 0 5
74308: PUSH
74309: LD_INT 1
74311: MINUS
74312: PPUSH
74313: LD_VAR 0 6
74317: PPUSH
74318: CALL_OW 1
74322: ST_TO_ADDR
// end ;
74323: GO 74240
74325: POP
74326: POP
// result := s_arr [ 1 ] ;
74327: LD_ADDR_VAR 0 4
74331: PUSH
74332: LD_VAR 0 7
74336: PUSH
74337: LD_INT 1
74339: ARRAY
74340: ST_TO_ADDR
// end ; end ;
74341: LD_VAR 0 4
74345: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74346: LD_INT 0
74348: PPUSH
74349: PPUSH
// if not list then
74350: LD_VAR 0 1
74354: NOT
74355: IFFALSE 74359
// exit ;
74357: GO 74450
// i := list [ pos1 ] ;
74359: LD_ADDR_VAR 0 5
74363: PUSH
74364: LD_VAR 0 1
74368: PUSH
74369: LD_VAR 0 2
74373: ARRAY
74374: ST_TO_ADDR
// if not i then
74375: LD_VAR 0 5
74379: NOT
74380: IFFALSE 74384
// exit ;
74382: GO 74450
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74384: LD_ADDR_VAR 0 1
74388: PUSH
74389: LD_VAR 0 1
74393: PPUSH
74394: LD_VAR 0 2
74398: PPUSH
74399: LD_VAR 0 1
74403: PUSH
74404: LD_VAR 0 3
74408: ARRAY
74409: PPUSH
74410: CALL_OW 1
74414: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74415: LD_ADDR_VAR 0 1
74419: PUSH
74420: LD_VAR 0 1
74424: PPUSH
74425: LD_VAR 0 3
74429: PPUSH
74430: LD_VAR 0 5
74434: PPUSH
74435: CALL_OW 1
74439: ST_TO_ADDR
// result := list ;
74440: LD_ADDR_VAR 0 4
74444: PUSH
74445: LD_VAR 0 1
74449: ST_TO_ADDR
// end ;
74450: LD_VAR 0 4
74454: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74455: LD_INT 0
74457: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74458: LD_ADDR_VAR 0 5
74462: PUSH
74463: LD_VAR 0 1
74467: PPUSH
74468: CALL_OW 250
74472: PPUSH
74473: LD_VAR 0 1
74477: PPUSH
74478: CALL_OW 251
74482: PPUSH
74483: LD_VAR 0 2
74487: PPUSH
74488: LD_VAR 0 3
74492: PPUSH
74493: LD_VAR 0 4
74497: PPUSH
74498: CALL 74876 0 5
74502: ST_TO_ADDR
// end ;
74503: LD_VAR 0 5
74507: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
74508: LD_INT 0
74510: PPUSH
74511: PPUSH
74512: PPUSH
74513: PPUSH
// if not list or not unit then
74514: LD_VAR 0 2
74518: NOT
74519: PUSH
74520: LD_VAR 0 1
74524: NOT
74525: OR
74526: IFFALSE 74530
// exit ;
74528: GO 74871
// result := [ ] ;
74530: LD_ADDR_VAR 0 5
74534: PUSH
74535: EMPTY
74536: ST_TO_ADDR
// for i in list do
74537: LD_ADDR_VAR 0 6
74541: PUSH
74542: LD_VAR 0 2
74546: PUSH
74547: FOR_IN
74548: IFFALSE 74766
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
74550: LD_ADDR_VAR 0 8
74554: PUSH
74555: LD_VAR 0 1
74559: PPUSH
74560: LD_VAR 0 6
74564: PUSH
74565: LD_INT 1
74567: ARRAY
74568: PPUSH
74569: LD_VAR 0 6
74573: PUSH
74574: LD_INT 2
74576: ARRAY
74577: PPUSH
74578: CALL_OW 297
74582: ST_TO_ADDR
// if not Count ( result ) then
74583: LD_VAR 0 5
74587: PPUSH
74588: CALL 71160 0 1
74592: NOT
74593: IFFALSE 74626
// begin result := Join ( result , [ i , tmp ] ) ;
74595: LD_ADDR_VAR 0 5
74599: PUSH
74600: LD_VAR 0 5
74604: PPUSH
74605: LD_VAR 0 6
74609: PUSH
74610: LD_VAR 0 8
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PPUSH
74619: CALL 106760 0 2
74623: ST_TO_ADDR
// continue ;
74624: GO 74547
// end ; if result [ result ] [ 2 ] <= tmp then
74626: LD_VAR 0 5
74630: PUSH
74631: LD_VAR 0 5
74635: ARRAY
74636: PUSH
74637: LD_INT 2
74639: ARRAY
74640: PUSH
74641: LD_VAR 0 8
74645: LESSEQUAL
74646: IFFALSE 74679
// result := Join ( result , [ i , tmp ] ) else
74648: LD_ADDR_VAR 0 5
74652: PUSH
74653: LD_VAR 0 5
74657: PPUSH
74658: LD_VAR 0 6
74662: PUSH
74663: LD_VAR 0 8
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PPUSH
74672: CALL 106760 0 2
74676: ST_TO_ADDR
74677: GO 74764
// begin for j := 1 to Count ( result ) do
74679: LD_ADDR_VAR 0 7
74683: PUSH
74684: DOUBLE
74685: LD_INT 1
74687: DEC
74688: ST_TO_ADDR
74689: LD_VAR 0 5
74693: PPUSH
74694: CALL 71160 0 1
74698: PUSH
74699: FOR_TO
74700: IFFALSE 74762
// begin if tmp < result [ j ] [ 2 ] then
74702: LD_VAR 0 8
74706: PUSH
74707: LD_VAR 0 5
74711: PUSH
74712: LD_VAR 0 7
74716: ARRAY
74717: PUSH
74718: LD_INT 2
74720: ARRAY
74721: LESS
74722: IFFALSE 74760
// begin result := Insert ( result , j , [ i , tmp ] ) ;
74724: LD_ADDR_VAR 0 5
74728: PUSH
74729: LD_VAR 0 5
74733: PPUSH
74734: LD_VAR 0 7
74738: PPUSH
74739: LD_VAR 0 6
74743: PUSH
74744: LD_VAR 0 8
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PPUSH
74753: CALL_OW 2
74757: ST_TO_ADDR
// break ;
74758: GO 74762
// end ; end ;
74760: GO 74699
74762: POP
74763: POP
// end ; end ;
74764: GO 74547
74766: POP
74767: POP
// if result and not asc then
74768: LD_VAR 0 5
74772: PUSH
74773: LD_VAR 0 3
74777: NOT
74778: AND
74779: IFFALSE 74796
// result := ReverseArray ( result ) ;
74781: LD_ADDR_VAR 0 5
74785: PUSH
74786: LD_VAR 0 5
74790: PPUSH
74791: CALL 102036 0 1
74795: ST_TO_ADDR
// tmp := [ ] ;
74796: LD_ADDR_VAR 0 8
74800: PUSH
74801: EMPTY
74802: ST_TO_ADDR
// if mode then
74803: LD_VAR 0 4
74807: IFFALSE 74871
// begin for i := 1 to result do
74809: LD_ADDR_VAR 0 6
74813: PUSH
74814: DOUBLE
74815: LD_INT 1
74817: DEC
74818: ST_TO_ADDR
74819: LD_VAR 0 5
74823: PUSH
74824: FOR_TO
74825: IFFALSE 74859
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
74827: LD_ADDR_VAR 0 8
74831: PUSH
74832: LD_VAR 0 8
74836: PPUSH
74837: LD_VAR 0 5
74841: PUSH
74842: LD_VAR 0 6
74846: ARRAY
74847: PUSH
74848: LD_INT 1
74850: ARRAY
74851: PPUSH
74852: CALL 106760 0 2
74856: ST_TO_ADDR
74857: GO 74824
74859: POP
74860: POP
// result := tmp ;
74861: LD_ADDR_VAR 0 5
74865: PUSH
74866: LD_VAR 0 8
74870: ST_TO_ADDR
// end ; end ;
74871: LD_VAR 0 5
74875: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
74876: LD_INT 0
74878: PPUSH
74879: PPUSH
74880: PPUSH
74881: PPUSH
// if not list then
74882: LD_VAR 0 3
74886: NOT
74887: IFFALSE 74891
// exit ;
74889: GO 75279
// result := [ ] ;
74891: LD_ADDR_VAR 0 6
74895: PUSH
74896: EMPTY
74897: ST_TO_ADDR
// for i in list do
74898: LD_ADDR_VAR 0 7
74902: PUSH
74903: LD_VAR 0 3
74907: PUSH
74908: FOR_IN
74909: IFFALSE 75111
// begin tmp := GetDistUnitXY ( i , x , y ) ;
74911: LD_ADDR_VAR 0 9
74915: PUSH
74916: LD_VAR 0 7
74920: PPUSH
74921: LD_VAR 0 1
74925: PPUSH
74926: LD_VAR 0 2
74930: PPUSH
74931: CALL_OW 297
74935: ST_TO_ADDR
// if not result then
74936: LD_VAR 0 6
74940: NOT
74941: IFFALSE 74967
// result := [ [ i , tmp ] ] else
74943: LD_ADDR_VAR 0 6
74947: PUSH
74948: LD_VAR 0 7
74952: PUSH
74953: LD_VAR 0 9
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: EMPTY
74963: LIST
74964: ST_TO_ADDR
74965: GO 75109
// begin if result [ result ] [ 2 ] < tmp then
74967: LD_VAR 0 6
74971: PUSH
74972: LD_VAR 0 6
74976: ARRAY
74977: PUSH
74978: LD_INT 2
74980: ARRAY
74981: PUSH
74982: LD_VAR 0 9
74986: LESS
74987: IFFALSE 75029
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
74989: LD_ADDR_VAR 0 6
74993: PUSH
74994: LD_VAR 0 6
74998: PPUSH
74999: LD_VAR 0 6
75003: PUSH
75004: LD_INT 1
75006: PLUS
75007: PPUSH
75008: LD_VAR 0 7
75012: PUSH
75013: LD_VAR 0 9
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PPUSH
75022: CALL_OW 2
75026: ST_TO_ADDR
75027: GO 75109
// for j = 1 to result do
75029: LD_ADDR_VAR 0 8
75033: PUSH
75034: DOUBLE
75035: LD_INT 1
75037: DEC
75038: ST_TO_ADDR
75039: LD_VAR 0 6
75043: PUSH
75044: FOR_TO
75045: IFFALSE 75107
// begin if tmp < result [ j ] [ 2 ] then
75047: LD_VAR 0 9
75051: PUSH
75052: LD_VAR 0 6
75056: PUSH
75057: LD_VAR 0 8
75061: ARRAY
75062: PUSH
75063: LD_INT 2
75065: ARRAY
75066: LESS
75067: IFFALSE 75105
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75069: LD_ADDR_VAR 0 6
75073: PUSH
75074: LD_VAR 0 6
75078: PPUSH
75079: LD_VAR 0 8
75083: PPUSH
75084: LD_VAR 0 7
75088: PUSH
75089: LD_VAR 0 9
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PPUSH
75098: CALL_OW 2
75102: ST_TO_ADDR
// break ;
75103: GO 75107
// end ; end ;
75105: GO 75044
75107: POP
75108: POP
// end ; end ;
75109: GO 74908
75111: POP
75112: POP
// if result and not asc then
75113: LD_VAR 0 6
75117: PUSH
75118: LD_VAR 0 4
75122: NOT
75123: AND
75124: IFFALSE 75199
// begin tmp := result ;
75126: LD_ADDR_VAR 0 9
75130: PUSH
75131: LD_VAR 0 6
75135: ST_TO_ADDR
// for i = tmp downto 1 do
75136: LD_ADDR_VAR 0 7
75140: PUSH
75141: DOUBLE
75142: LD_VAR 0 9
75146: INC
75147: ST_TO_ADDR
75148: LD_INT 1
75150: PUSH
75151: FOR_DOWNTO
75152: IFFALSE 75197
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75154: LD_ADDR_VAR 0 6
75158: PUSH
75159: LD_VAR 0 6
75163: PPUSH
75164: LD_VAR 0 9
75168: PUSH
75169: LD_VAR 0 7
75173: MINUS
75174: PUSH
75175: LD_INT 1
75177: PLUS
75178: PPUSH
75179: LD_VAR 0 9
75183: PUSH
75184: LD_VAR 0 7
75188: ARRAY
75189: PPUSH
75190: CALL_OW 1
75194: ST_TO_ADDR
75195: GO 75151
75197: POP
75198: POP
// end ; tmp := [ ] ;
75199: LD_ADDR_VAR 0 9
75203: PUSH
75204: EMPTY
75205: ST_TO_ADDR
// if mode then
75206: LD_VAR 0 5
75210: IFFALSE 75279
// begin for i = 1 to result do
75212: LD_ADDR_VAR 0 7
75216: PUSH
75217: DOUBLE
75218: LD_INT 1
75220: DEC
75221: ST_TO_ADDR
75222: LD_VAR 0 6
75226: PUSH
75227: FOR_TO
75228: IFFALSE 75267
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75230: LD_ADDR_VAR 0 9
75234: PUSH
75235: LD_VAR 0 9
75239: PPUSH
75240: LD_VAR 0 7
75244: PPUSH
75245: LD_VAR 0 6
75249: PUSH
75250: LD_VAR 0 7
75254: ARRAY
75255: PUSH
75256: LD_INT 1
75258: ARRAY
75259: PPUSH
75260: CALL_OW 1
75264: ST_TO_ADDR
75265: GO 75227
75267: POP
75268: POP
// result := tmp ;
75269: LD_ADDR_VAR 0 6
75273: PUSH
75274: LD_VAR 0 9
75278: ST_TO_ADDR
// end ; end ;
75279: LD_VAR 0 6
75283: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75284: LD_INT 0
75286: PPUSH
75287: PPUSH
75288: PPUSH
75289: PPUSH
75290: PPUSH
75291: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75292: LD_ADDR_VAR 0 5
75296: PUSH
75297: LD_INT 0
75299: PUSH
75300: LD_INT 0
75302: PUSH
75303: LD_INT 0
75305: PUSH
75306: EMPTY
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: LIST
75312: LIST
75313: ST_TO_ADDR
// if not x or not y then
75314: LD_VAR 0 2
75318: NOT
75319: PUSH
75320: LD_VAR 0 3
75324: NOT
75325: OR
75326: IFFALSE 75330
// exit ;
75328: GO 76980
// if not range then
75330: LD_VAR 0 4
75334: NOT
75335: IFFALSE 75345
// range := 10 ;
75337: LD_ADDR_VAR 0 4
75341: PUSH
75342: LD_INT 10
75344: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75345: LD_ADDR_VAR 0 8
75349: PUSH
75350: LD_INT 81
75352: PUSH
75353: LD_VAR 0 1
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 92
75364: PUSH
75365: LD_VAR 0 2
75369: PUSH
75370: LD_VAR 0 3
75374: PUSH
75375: LD_VAR 0 4
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 3
75388: PUSH
75389: LD_INT 21
75391: PUSH
75392: LD_INT 3
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: LIST
75407: PPUSH
75408: CALL_OW 69
75412: ST_TO_ADDR
// if not tmp then
75413: LD_VAR 0 8
75417: NOT
75418: IFFALSE 75422
// exit ;
75420: GO 76980
// for i in tmp do
75422: LD_ADDR_VAR 0 6
75426: PUSH
75427: LD_VAR 0 8
75431: PUSH
75432: FOR_IN
75433: IFFALSE 76955
// begin points := [ 0 , 0 , 0 ] ;
75435: LD_ADDR_VAR 0 9
75439: PUSH
75440: LD_INT 0
75442: PUSH
75443: LD_INT 0
75445: PUSH
75446: LD_INT 0
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: ST_TO_ADDR
// bpoints := 1 ;
75454: LD_ADDR_VAR 0 10
75458: PUSH
75459: LD_INT 1
75461: ST_TO_ADDR
// case GetType ( i ) of unit_human :
75462: LD_VAR 0 6
75466: PPUSH
75467: CALL_OW 247
75471: PUSH
75472: LD_INT 1
75474: DOUBLE
75475: EQUAL
75476: IFTRUE 75480
75478: GO 76058
75480: POP
// begin if GetClass ( i ) = 1 then
75481: LD_VAR 0 6
75485: PPUSH
75486: CALL_OW 257
75490: PUSH
75491: LD_INT 1
75493: EQUAL
75494: IFFALSE 75515
// points := [ 10 , 5 , 3 ] ;
75496: LD_ADDR_VAR 0 9
75500: PUSH
75501: LD_INT 10
75503: PUSH
75504: LD_INT 5
75506: PUSH
75507: LD_INT 3
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: LIST
75514: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
75515: LD_VAR 0 6
75519: PPUSH
75520: CALL_OW 257
75524: PUSH
75525: LD_INT 2
75527: PUSH
75528: LD_INT 3
75530: PUSH
75531: LD_INT 4
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: LIST
75538: IN
75539: IFFALSE 75560
// points := [ 3 , 2 , 1 ] ;
75541: LD_ADDR_VAR 0 9
75545: PUSH
75546: LD_INT 3
75548: PUSH
75549: LD_INT 2
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: LIST
75559: ST_TO_ADDR
// if GetClass ( i ) = 5 then
75560: LD_VAR 0 6
75564: PPUSH
75565: CALL_OW 257
75569: PUSH
75570: LD_INT 5
75572: EQUAL
75573: IFFALSE 75594
// points := [ 130 , 5 , 2 ] ;
75575: LD_ADDR_VAR 0 9
75579: PUSH
75580: LD_INT 130
75582: PUSH
75583: LD_INT 5
75585: PUSH
75586: LD_INT 2
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: LIST
75593: ST_TO_ADDR
// if GetClass ( i ) = 8 then
75594: LD_VAR 0 6
75598: PPUSH
75599: CALL_OW 257
75603: PUSH
75604: LD_INT 8
75606: EQUAL
75607: IFFALSE 75628
// points := [ 35 , 35 , 30 ] ;
75609: LD_ADDR_VAR 0 9
75613: PUSH
75614: LD_INT 35
75616: PUSH
75617: LD_INT 35
75619: PUSH
75620: LD_INT 30
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: LIST
75627: ST_TO_ADDR
// if GetClass ( i ) = 9 then
75628: LD_VAR 0 6
75632: PPUSH
75633: CALL_OW 257
75637: PUSH
75638: LD_INT 9
75640: EQUAL
75641: IFFALSE 75662
// points := [ 20 , 55 , 40 ] ;
75643: LD_ADDR_VAR 0 9
75647: PUSH
75648: LD_INT 20
75650: PUSH
75651: LD_INT 55
75653: PUSH
75654: LD_INT 40
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: LIST
75661: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
75662: LD_VAR 0 6
75666: PPUSH
75667: CALL_OW 257
75671: PUSH
75672: LD_INT 12
75674: PUSH
75675: LD_INT 16
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: IN
75682: IFFALSE 75703
// points := [ 5 , 3 , 2 ] ;
75684: LD_ADDR_VAR 0 9
75688: PUSH
75689: LD_INT 5
75691: PUSH
75692: LD_INT 3
75694: PUSH
75695: LD_INT 2
75697: PUSH
75698: EMPTY
75699: LIST
75700: LIST
75701: LIST
75702: ST_TO_ADDR
// if GetClass ( i ) = 17 then
75703: LD_VAR 0 6
75707: PPUSH
75708: CALL_OW 257
75712: PUSH
75713: LD_INT 17
75715: EQUAL
75716: IFFALSE 75737
// points := [ 100 , 50 , 75 ] ;
75718: LD_ADDR_VAR 0 9
75722: PUSH
75723: LD_INT 100
75725: PUSH
75726: LD_INT 50
75728: PUSH
75729: LD_INT 75
75731: PUSH
75732: EMPTY
75733: LIST
75734: LIST
75735: LIST
75736: ST_TO_ADDR
// if GetClass ( i ) = 15 then
75737: LD_VAR 0 6
75741: PPUSH
75742: CALL_OW 257
75746: PUSH
75747: LD_INT 15
75749: EQUAL
75750: IFFALSE 75771
// points := [ 10 , 5 , 3 ] ;
75752: LD_ADDR_VAR 0 9
75756: PUSH
75757: LD_INT 10
75759: PUSH
75760: LD_INT 5
75762: PUSH
75763: LD_INT 3
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: LIST
75770: ST_TO_ADDR
// if GetClass ( i ) = 14 then
75771: LD_VAR 0 6
75775: PPUSH
75776: CALL_OW 257
75780: PUSH
75781: LD_INT 14
75783: EQUAL
75784: IFFALSE 75805
// points := [ 10 , 0 , 0 ] ;
75786: LD_ADDR_VAR 0 9
75790: PUSH
75791: LD_INT 10
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: LD_INT 0
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: ST_TO_ADDR
// if GetClass ( i ) = 11 then
75805: LD_VAR 0 6
75809: PPUSH
75810: CALL_OW 257
75814: PUSH
75815: LD_INT 11
75817: EQUAL
75818: IFFALSE 75839
// points := [ 30 , 10 , 5 ] ;
75820: LD_ADDR_VAR 0 9
75824: PUSH
75825: LD_INT 30
75827: PUSH
75828: LD_INT 10
75830: PUSH
75831: LD_INT 5
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: LIST
75838: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
75839: LD_VAR 0 1
75843: PPUSH
75844: LD_INT 5
75846: PPUSH
75847: CALL_OW 321
75851: PUSH
75852: LD_INT 2
75854: EQUAL
75855: IFFALSE 75872
// bpoints := bpoints * 1.8 ;
75857: LD_ADDR_VAR 0 10
75861: PUSH
75862: LD_VAR 0 10
75866: PUSH
75867: LD_REAL  1.80000000000000E+0000
75870: MUL
75871: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
75872: LD_VAR 0 6
75876: PPUSH
75877: CALL_OW 257
75881: PUSH
75882: LD_INT 1
75884: PUSH
75885: LD_INT 2
75887: PUSH
75888: LD_INT 3
75890: PUSH
75891: LD_INT 4
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: LIST
75898: LIST
75899: IN
75900: PUSH
75901: LD_VAR 0 1
75905: PPUSH
75906: LD_INT 51
75908: PPUSH
75909: CALL_OW 321
75913: PUSH
75914: LD_INT 2
75916: EQUAL
75917: AND
75918: IFFALSE 75935
// bpoints := bpoints * 1.2 ;
75920: LD_ADDR_VAR 0 10
75924: PUSH
75925: LD_VAR 0 10
75929: PUSH
75930: LD_REAL  1.20000000000000E+0000
75933: MUL
75934: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
75935: LD_VAR 0 6
75939: PPUSH
75940: CALL_OW 257
75944: PUSH
75945: LD_INT 5
75947: PUSH
75948: LD_INT 7
75950: PUSH
75951: LD_INT 9
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: LIST
75958: IN
75959: PUSH
75960: LD_VAR 0 1
75964: PPUSH
75965: LD_INT 52
75967: PPUSH
75968: CALL_OW 321
75972: PUSH
75973: LD_INT 2
75975: EQUAL
75976: AND
75977: IFFALSE 75994
// bpoints := bpoints * 1.5 ;
75979: LD_ADDR_VAR 0 10
75983: PUSH
75984: LD_VAR 0 10
75988: PUSH
75989: LD_REAL  1.50000000000000E+0000
75992: MUL
75993: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
75994: LD_VAR 0 1
75998: PPUSH
75999: LD_INT 66
76001: PPUSH
76002: CALL_OW 321
76006: PUSH
76007: LD_INT 2
76009: EQUAL
76010: IFFALSE 76027
// bpoints := bpoints * 1.1 ;
76012: LD_ADDR_VAR 0 10
76016: PUSH
76017: LD_VAR 0 10
76021: PUSH
76022: LD_REAL  1.10000000000000E+0000
76025: MUL
76026: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76027: LD_ADDR_VAR 0 10
76031: PUSH
76032: LD_VAR 0 10
76036: PUSH
76037: LD_VAR 0 6
76041: PPUSH
76042: LD_INT 1
76044: PPUSH
76045: CALL_OW 259
76049: PUSH
76050: LD_REAL  1.15000000000000E+0000
76053: MUL
76054: MUL
76055: ST_TO_ADDR
// end ; unit_vehicle :
76056: GO 76884
76058: LD_INT 2
76060: DOUBLE
76061: EQUAL
76062: IFTRUE 76066
76064: GO 76872
76066: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76067: LD_VAR 0 6
76071: PPUSH
76072: CALL_OW 264
76076: PUSH
76077: LD_INT 2
76079: PUSH
76080: LD_INT 42
76082: PUSH
76083: LD_INT 24
76085: PUSH
76086: EMPTY
76087: LIST
76088: LIST
76089: LIST
76090: IN
76091: IFFALSE 76112
// points := [ 25 , 5 , 3 ] ;
76093: LD_ADDR_VAR 0 9
76097: PUSH
76098: LD_INT 25
76100: PUSH
76101: LD_INT 5
76103: PUSH
76104: LD_INT 3
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: LIST
76111: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76112: LD_VAR 0 6
76116: PPUSH
76117: CALL_OW 264
76121: PUSH
76122: LD_INT 4
76124: PUSH
76125: LD_INT 43
76127: PUSH
76128: LD_INT 25
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: LIST
76135: IN
76136: IFFALSE 76157
// points := [ 40 , 15 , 5 ] ;
76138: LD_ADDR_VAR 0 9
76142: PUSH
76143: LD_INT 40
76145: PUSH
76146: LD_INT 15
76148: PUSH
76149: LD_INT 5
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: LIST
76156: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76157: LD_VAR 0 6
76161: PPUSH
76162: CALL_OW 264
76166: PUSH
76167: LD_INT 3
76169: PUSH
76170: LD_INT 23
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: IN
76177: IFFALSE 76198
// points := [ 7 , 25 , 8 ] ;
76179: LD_ADDR_VAR 0 9
76183: PUSH
76184: LD_INT 7
76186: PUSH
76187: LD_INT 25
76189: PUSH
76190: LD_INT 8
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: LIST
76197: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76198: LD_VAR 0 6
76202: PPUSH
76203: CALL_OW 264
76207: PUSH
76208: LD_INT 5
76210: PUSH
76211: LD_INT 27
76213: PUSH
76214: LD_INT 44
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: LIST
76221: IN
76222: IFFALSE 76243
// points := [ 14 , 50 , 16 ] ;
76224: LD_ADDR_VAR 0 9
76228: PUSH
76229: LD_INT 14
76231: PUSH
76232: LD_INT 50
76234: PUSH
76235: LD_INT 16
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: LIST
76242: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76243: LD_VAR 0 6
76247: PPUSH
76248: CALL_OW 264
76252: PUSH
76253: LD_INT 6
76255: PUSH
76256: LD_INT 46
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: IN
76263: IFFALSE 76284
// points := [ 32 , 120 , 70 ] ;
76265: LD_ADDR_VAR 0 9
76269: PUSH
76270: LD_INT 32
76272: PUSH
76273: LD_INT 120
76275: PUSH
76276: LD_INT 70
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: LIST
76283: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76284: LD_VAR 0 6
76288: PPUSH
76289: CALL_OW 264
76293: PUSH
76294: LD_INT 7
76296: PUSH
76297: LD_INT 28
76299: PUSH
76300: LD_INT 45
76302: PUSH
76303: LD_INT 92
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: IN
76312: IFFALSE 76333
// points := [ 35 , 20 , 45 ] ;
76314: LD_ADDR_VAR 0 9
76318: PUSH
76319: LD_INT 35
76321: PUSH
76322: LD_INT 20
76324: PUSH
76325: LD_INT 45
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: LIST
76332: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76333: LD_VAR 0 6
76337: PPUSH
76338: CALL_OW 264
76342: PUSH
76343: LD_INT 47
76345: PUSH
76346: EMPTY
76347: LIST
76348: IN
76349: IFFALSE 76370
// points := [ 67 , 45 , 75 ] ;
76351: LD_ADDR_VAR 0 9
76355: PUSH
76356: LD_INT 67
76358: PUSH
76359: LD_INT 45
76361: PUSH
76362: LD_INT 75
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: LIST
76369: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76370: LD_VAR 0 6
76374: PPUSH
76375: CALL_OW 264
76379: PUSH
76380: LD_INT 26
76382: PUSH
76383: EMPTY
76384: LIST
76385: IN
76386: IFFALSE 76407
// points := [ 120 , 30 , 80 ] ;
76388: LD_ADDR_VAR 0 9
76392: PUSH
76393: LD_INT 120
76395: PUSH
76396: LD_INT 30
76398: PUSH
76399: LD_INT 80
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: LIST
76406: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
76407: LD_VAR 0 6
76411: PPUSH
76412: CALL_OW 264
76416: PUSH
76417: LD_INT 22
76419: PUSH
76420: EMPTY
76421: LIST
76422: IN
76423: IFFALSE 76444
// points := [ 40 , 1 , 1 ] ;
76425: LD_ADDR_VAR 0 9
76429: PUSH
76430: LD_INT 40
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: LIST
76443: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
76444: LD_VAR 0 6
76448: PPUSH
76449: CALL_OW 264
76453: PUSH
76454: LD_INT 29
76456: PUSH
76457: EMPTY
76458: LIST
76459: IN
76460: IFFALSE 76481
// points := [ 70 , 200 , 400 ] ;
76462: LD_ADDR_VAR 0 9
76466: PUSH
76467: LD_INT 70
76469: PUSH
76470: LD_INT 200
76472: PUSH
76473: LD_INT 400
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: LIST
76480: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
76481: LD_VAR 0 6
76485: PPUSH
76486: CALL_OW 264
76490: PUSH
76491: LD_INT 14
76493: PUSH
76494: LD_INT 53
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: IN
76501: IFFALSE 76522
// points := [ 40 , 10 , 20 ] ;
76503: LD_ADDR_VAR 0 9
76507: PUSH
76508: LD_INT 40
76510: PUSH
76511: LD_INT 10
76513: PUSH
76514: LD_INT 20
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: LIST
76521: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
76522: LD_VAR 0 6
76526: PPUSH
76527: CALL_OW 264
76531: PUSH
76532: LD_INT 9
76534: PUSH
76535: EMPTY
76536: LIST
76537: IN
76538: IFFALSE 76559
// points := [ 5 , 70 , 20 ] ;
76540: LD_ADDR_VAR 0 9
76544: PUSH
76545: LD_INT 5
76547: PUSH
76548: LD_INT 70
76550: PUSH
76551: LD_INT 20
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: LIST
76558: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
76559: LD_VAR 0 6
76563: PPUSH
76564: CALL_OW 264
76568: PUSH
76569: LD_INT 10
76571: PUSH
76572: EMPTY
76573: LIST
76574: IN
76575: IFFALSE 76596
// points := [ 35 , 110 , 70 ] ;
76577: LD_ADDR_VAR 0 9
76581: PUSH
76582: LD_INT 35
76584: PUSH
76585: LD_INT 110
76587: PUSH
76588: LD_INT 70
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: LIST
76595: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
76596: LD_VAR 0 6
76600: PPUSH
76601: CALL_OW 265
76605: PUSH
76606: LD_INT 25
76608: EQUAL
76609: IFFALSE 76630
// points := [ 80 , 65 , 100 ] ;
76611: LD_ADDR_VAR 0 9
76615: PUSH
76616: LD_INT 80
76618: PUSH
76619: LD_INT 65
76621: PUSH
76622: LD_INT 100
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: LIST
76629: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
76630: LD_VAR 0 6
76634: PPUSH
76635: CALL_OW 263
76639: PUSH
76640: LD_INT 1
76642: EQUAL
76643: IFFALSE 76678
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
76645: LD_ADDR_VAR 0 10
76649: PUSH
76650: LD_VAR 0 10
76654: PUSH
76655: LD_VAR 0 6
76659: PPUSH
76660: CALL_OW 311
76664: PPUSH
76665: LD_INT 3
76667: PPUSH
76668: CALL_OW 259
76672: PUSH
76673: LD_INT 4
76675: MUL
76676: MUL
76677: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
76678: LD_VAR 0 6
76682: PPUSH
76683: CALL_OW 263
76687: PUSH
76688: LD_INT 2
76690: EQUAL
76691: IFFALSE 76742
// begin j := IsControledBy ( i ) ;
76693: LD_ADDR_VAR 0 7
76697: PUSH
76698: LD_VAR 0 6
76702: PPUSH
76703: CALL_OW 312
76707: ST_TO_ADDR
// if j then
76708: LD_VAR 0 7
76712: IFFALSE 76742
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
76714: LD_ADDR_VAR 0 10
76718: PUSH
76719: LD_VAR 0 10
76723: PUSH
76724: LD_VAR 0 7
76728: PPUSH
76729: LD_INT 3
76731: PPUSH
76732: CALL_OW 259
76736: PUSH
76737: LD_INT 3
76739: MUL
76740: MUL
76741: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
76742: LD_VAR 0 6
76746: PPUSH
76747: CALL_OW 264
76751: PUSH
76752: LD_INT 5
76754: PUSH
76755: LD_INT 6
76757: PUSH
76758: LD_INT 46
76760: PUSH
76761: LD_INT 44
76763: PUSH
76764: LD_INT 47
76766: PUSH
76767: LD_INT 45
76769: PUSH
76770: LD_INT 28
76772: PUSH
76773: LD_INT 7
76775: PUSH
76776: LD_INT 27
76778: PUSH
76779: LD_INT 29
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: LIST
76793: IN
76794: PUSH
76795: LD_VAR 0 1
76799: PPUSH
76800: LD_INT 52
76802: PPUSH
76803: CALL_OW 321
76807: PUSH
76808: LD_INT 2
76810: EQUAL
76811: AND
76812: IFFALSE 76829
// bpoints := bpoints * 1.2 ;
76814: LD_ADDR_VAR 0 10
76818: PUSH
76819: LD_VAR 0 10
76823: PUSH
76824: LD_REAL  1.20000000000000E+0000
76827: MUL
76828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
76829: LD_VAR 0 6
76833: PPUSH
76834: CALL_OW 264
76838: PUSH
76839: LD_INT 6
76841: PUSH
76842: LD_INT 46
76844: PUSH
76845: LD_INT 47
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: IN
76853: IFFALSE 76870
// bpoints := bpoints * 1.2 ;
76855: LD_ADDR_VAR 0 10
76859: PUSH
76860: LD_VAR 0 10
76864: PUSH
76865: LD_REAL  1.20000000000000E+0000
76868: MUL
76869: ST_TO_ADDR
// end ; unit_building :
76870: GO 76884
76872: LD_INT 3
76874: DOUBLE
76875: EQUAL
76876: IFTRUE 76880
76878: GO 76883
76880: POP
// ; end ;
76881: GO 76884
76883: POP
// for j = 1 to 3 do
76884: LD_ADDR_VAR 0 7
76888: PUSH
76889: DOUBLE
76890: LD_INT 1
76892: DEC
76893: ST_TO_ADDR
76894: LD_INT 3
76896: PUSH
76897: FOR_TO
76898: IFFALSE 76951
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
76900: LD_ADDR_VAR 0 5
76904: PUSH
76905: LD_VAR 0 5
76909: PPUSH
76910: LD_VAR 0 7
76914: PPUSH
76915: LD_VAR 0 5
76919: PUSH
76920: LD_VAR 0 7
76924: ARRAY
76925: PUSH
76926: LD_VAR 0 9
76930: PUSH
76931: LD_VAR 0 7
76935: ARRAY
76936: PUSH
76937: LD_VAR 0 10
76941: MUL
76942: PLUS
76943: PPUSH
76944: CALL_OW 1
76948: ST_TO_ADDR
76949: GO 76897
76951: POP
76952: POP
// end ;
76953: GO 75432
76955: POP
76956: POP
// result := Replace ( result , 4 , tmp ) ;
76957: LD_ADDR_VAR 0 5
76961: PUSH
76962: LD_VAR 0 5
76966: PPUSH
76967: LD_INT 4
76969: PPUSH
76970: LD_VAR 0 8
76974: PPUSH
76975: CALL_OW 1
76979: ST_TO_ADDR
// end ;
76980: LD_VAR 0 5
76984: RET
// export function DangerAtRange ( unit , range ) ; begin
76985: LD_INT 0
76987: PPUSH
// if not unit then
76988: LD_VAR 0 1
76992: NOT
76993: IFFALSE 76997
// exit ;
76995: GO 77042
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
76997: LD_ADDR_VAR 0 3
77001: PUSH
77002: LD_VAR 0 1
77006: PPUSH
77007: CALL_OW 255
77011: PPUSH
77012: LD_VAR 0 1
77016: PPUSH
77017: CALL_OW 250
77021: PPUSH
77022: LD_VAR 0 1
77026: PPUSH
77027: CALL_OW 251
77031: PPUSH
77032: LD_VAR 0 2
77036: PPUSH
77037: CALL 75284 0 4
77041: ST_TO_ADDR
// end ;
77042: LD_VAR 0 3
77046: RET
// export function DangerInArea ( side , area ) ; begin
77047: LD_INT 0
77049: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77050: LD_ADDR_VAR 0 3
77054: PUSH
77055: LD_VAR 0 2
77059: PPUSH
77060: LD_INT 81
77062: PUSH
77063: LD_VAR 0 1
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PPUSH
77072: CALL_OW 70
77076: ST_TO_ADDR
// end ;
77077: LD_VAR 0 3
77081: RET
// export function IsExtension ( b ) ; begin
77082: LD_INT 0
77084: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77085: LD_ADDR_VAR 0 2
77089: PUSH
77090: LD_VAR 0 1
77094: PUSH
77095: LD_INT 23
77097: PUSH
77098: LD_INT 20
77100: PUSH
77101: LD_INT 22
77103: PUSH
77104: LD_INT 17
77106: PUSH
77107: LD_INT 24
77109: PUSH
77110: LD_INT 21
77112: PUSH
77113: LD_INT 19
77115: PUSH
77116: LD_INT 16
77118: PUSH
77119: LD_INT 25
77121: PUSH
77122: LD_INT 18
77124: PUSH
77125: EMPTY
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: IN
77137: ST_TO_ADDR
// end ;
77138: LD_VAR 0 2
77142: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77143: LD_INT 0
77145: PPUSH
77146: PPUSH
77147: PPUSH
// result := [ ] ;
77148: LD_ADDR_VAR 0 4
77152: PUSH
77153: EMPTY
77154: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77155: LD_ADDR_VAR 0 5
77159: PUSH
77160: LD_VAR 0 2
77164: PPUSH
77165: LD_INT 21
77167: PUSH
77168: LD_INT 3
77170: PUSH
77171: EMPTY
77172: LIST
77173: LIST
77174: PPUSH
77175: CALL_OW 70
77179: ST_TO_ADDR
// if not tmp then
77180: LD_VAR 0 5
77184: NOT
77185: IFFALSE 77189
// exit ;
77187: GO 77253
// if checkLink then
77189: LD_VAR 0 3
77193: IFFALSE 77243
// begin for i in tmp do
77195: LD_ADDR_VAR 0 6
77199: PUSH
77200: LD_VAR 0 5
77204: PUSH
77205: FOR_IN
77206: IFFALSE 77241
// if GetBase ( i ) <> base then
77208: LD_VAR 0 6
77212: PPUSH
77213: CALL_OW 274
77217: PUSH
77218: LD_VAR 0 1
77222: NONEQUAL
77223: IFFALSE 77239
// ComLinkToBase ( base , i ) ;
77225: LD_VAR 0 1
77229: PPUSH
77230: LD_VAR 0 6
77234: PPUSH
77235: CALL_OW 169
77239: GO 77205
77241: POP
77242: POP
// end ; result := tmp ;
77243: LD_ADDR_VAR 0 4
77247: PUSH
77248: LD_VAR 0 5
77252: ST_TO_ADDR
// end ;
77253: LD_VAR 0 4
77257: RET
// export function ComComplete ( units , b ) ; var i ; begin
77258: LD_INT 0
77260: PPUSH
77261: PPUSH
// if not units then
77262: LD_VAR 0 1
77266: NOT
77267: IFFALSE 77271
// exit ;
77269: GO 77361
// for i in units do
77271: LD_ADDR_VAR 0 4
77275: PUSH
77276: LD_VAR 0 1
77280: PUSH
77281: FOR_IN
77282: IFFALSE 77359
// if BuildingStatus ( b ) = bs_build then
77284: LD_VAR 0 2
77288: PPUSH
77289: CALL_OW 461
77293: PUSH
77294: LD_INT 1
77296: EQUAL
77297: IFFALSE 77357
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77299: LD_VAR 0 4
77303: PPUSH
77304: LD_STRING h
77306: PUSH
77307: LD_VAR 0 2
77311: PPUSH
77312: CALL_OW 250
77316: PUSH
77317: LD_VAR 0 2
77321: PPUSH
77322: CALL_OW 251
77326: PUSH
77327: LD_VAR 0 2
77331: PUSH
77332: LD_INT 0
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: LD_INT 0
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: PUSH
77350: EMPTY
77351: LIST
77352: PPUSH
77353: CALL_OW 446
77357: GO 77281
77359: POP
77360: POP
// end ;
77361: LD_VAR 0 3
77365: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77366: LD_INT 0
77368: PPUSH
77369: PPUSH
77370: PPUSH
77371: PPUSH
77372: PPUSH
77373: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77374: LD_VAR 0 1
77378: NOT
77379: PUSH
77380: LD_VAR 0 1
77384: PPUSH
77385: CALL_OW 263
77389: PUSH
77390: LD_INT 2
77392: NONEQUAL
77393: OR
77394: IFFALSE 77398
// exit ;
77396: GO 77714
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
77398: LD_ADDR_VAR 0 6
77402: PUSH
77403: LD_INT 22
77405: PUSH
77406: LD_VAR 0 1
77410: PPUSH
77411: CALL_OW 255
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 2
77422: PUSH
77423: LD_INT 30
77425: PUSH
77426: LD_INT 36
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: PUSH
77433: LD_INT 34
77435: PUSH
77436: LD_INT 31
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: LIST
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PPUSH
77452: CALL_OW 69
77456: ST_TO_ADDR
// if not tmp then
77457: LD_VAR 0 6
77461: NOT
77462: IFFALSE 77466
// exit ;
77464: GO 77714
// result := [ ] ;
77466: LD_ADDR_VAR 0 2
77470: PUSH
77471: EMPTY
77472: ST_TO_ADDR
// for i in tmp do
77473: LD_ADDR_VAR 0 3
77477: PUSH
77478: LD_VAR 0 6
77482: PUSH
77483: FOR_IN
77484: IFFALSE 77555
// begin t := UnitsInside ( i ) ;
77486: LD_ADDR_VAR 0 4
77490: PUSH
77491: LD_VAR 0 3
77495: PPUSH
77496: CALL_OW 313
77500: ST_TO_ADDR
// if t then
77501: LD_VAR 0 4
77505: IFFALSE 77553
// for j in t do
77507: LD_ADDR_VAR 0 7
77511: PUSH
77512: LD_VAR 0 4
77516: PUSH
77517: FOR_IN
77518: IFFALSE 77551
// result := Replace ( result , result + 1 , j ) ;
77520: LD_ADDR_VAR 0 2
77524: PUSH
77525: LD_VAR 0 2
77529: PPUSH
77530: LD_VAR 0 2
77534: PUSH
77535: LD_INT 1
77537: PLUS
77538: PPUSH
77539: LD_VAR 0 7
77543: PPUSH
77544: CALL_OW 1
77548: ST_TO_ADDR
77549: GO 77517
77551: POP
77552: POP
// end ;
77553: GO 77483
77555: POP
77556: POP
// if not result then
77557: LD_VAR 0 2
77561: NOT
77562: IFFALSE 77566
// exit ;
77564: GO 77714
// mech := result [ 1 ] ;
77566: LD_ADDR_VAR 0 5
77570: PUSH
77571: LD_VAR 0 2
77575: PUSH
77576: LD_INT 1
77578: ARRAY
77579: ST_TO_ADDR
// if result > 1 then
77580: LD_VAR 0 2
77584: PUSH
77585: LD_INT 1
77587: GREATER
77588: IFFALSE 77700
// begin for i = 2 to result do
77590: LD_ADDR_VAR 0 3
77594: PUSH
77595: DOUBLE
77596: LD_INT 2
77598: DEC
77599: ST_TO_ADDR
77600: LD_VAR 0 2
77604: PUSH
77605: FOR_TO
77606: IFFALSE 77698
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
77608: LD_ADDR_VAR 0 4
77612: PUSH
77613: LD_VAR 0 2
77617: PUSH
77618: LD_VAR 0 3
77622: ARRAY
77623: PPUSH
77624: LD_INT 3
77626: PPUSH
77627: CALL_OW 259
77631: PUSH
77632: LD_VAR 0 2
77636: PUSH
77637: LD_VAR 0 3
77641: ARRAY
77642: PPUSH
77643: CALL_OW 432
77647: MINUS
77648: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
77649: LD_VAR 0 4
77653: PUSH
77654: LD_VAR 0 5
77658: PPUSH
77659: LD_INT 3
77661: PPUSH
77662: CALL_OW 259
77666: PUSH
77667: LD_VAR 0 5
77671: PPUSH
77672: CALL_OW 432
77676: MINUS
77677: GREATEREQUAL
77678: IFFALSE 77696
// mech := result [ i ] ;
77680: LD_ADDR_VAR 0 5
77684: PUSH
77685: LD_VAR 0 2
77689: PUSH
77690: LD_VAR 0 3
77694: ARRAY
77695: ST_TO_ADDR
// end ;
77696: GO 77605
77698: POP
77699: POP
// end ; ComLinkTo ( vehicle , mech ) ;
77700: LD_VAR 0 1
77704: PPUSH
77705: LD_VAR 0 5
77709: PPUSH
77710: CALL_OW 135
// end ;
77714: LD_VAR 0 2
77718: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
77719: LD_INT 0
77721: PPUSH
77722: PPUSH
77723: PPUSH
77724: PPUSH
77725: PPUSH
77726: PPUSH
77727: PPUSH
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
// result := [ ] ;
77734: LD_ADDR_VAR 0 7
77738: PUSH
77739: EMPTY
77740: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
77741: LD_VAR 0 1
77745: PPUSH
77746: CALL_OW 266
77750: PUSH
77751: LD_INT 0
77753: PUSH
77754: LD_INT 1
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: IN
77761: NOT
77762: IFFALSE 77766
// exit ;
77764: GO 79400
// if name then
77766: LD_VAR 0 3
77770: IFFALSE 77786
// SetBName ( base_dep , name ) ;
77772: LD_VAR 0 1
77776: PPUSH
77777: LD_VAR 0 3
77781: PPUSH
77782: CALL_OW 500
// base := GetBase ( base_dep ) ;
77786: LD_ADDR_VAR 0 15
77790: PUSH
77791: LD_VAR 0 1
77795: PPUSH
77796: CALL_OW 274
77800: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
77801: LD_ADDR_VAR 0 16
77805: PUSH
77806: LD_VAR 0 1
77810: PPUSH
77811: CALL_OW 255
77815: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
77816: LD_ADDR_VAR 0 17
77820: PUSH
77821: LD_VAR 0 1
77825: PPUSH
77826: CALL_OW 248
77830: ST_TO_ADDR
// if sources then
77831: LD_VAR 0 5
77835: IFFALSE 77882
// for i = 1 to 3 do
77837: LD_ADDR_VAR 0 8
77841: PUSH
77842: DOUBLE
77843: LD_INT 1
77845: DEC
77846: ST_TO_ADDR
77847: LD_INT 3
77849: PUSH
77850: FOR_TO
77851: IFFALSE 77880
// AddResourceType ( base , i , sources [ i ] ) ;
77853: LD_VAR 0 15
77857: PPUSH
77858: LD_VAR 0 8
77862: PPUSH
77863: LD_VAR 0 5
77867: PUSH
77868: LD_VAR 0 8
77872: ARRAY
77873: PPUSH
77874: CALL_OW 276
77878: GO 77850
77880: POP
77881: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
77882: LD_ADDR_VAR 0 18
77886: PUSH
77887: LD_VAR 0 15
77891: PPUSH
77892: LD_VAR 0 2
77896: PPUSH
77897: LD_INT 1
77899: PPUSH
77900: CALL 77143 0 3
77904: ST_TO_ADDR
// InitHc ;
77905: CALL_OW 19
// InitUc ;
77909: CALL_OW 18
// uc_side := side ;
77913: LD_ADDR_OWVAR 20
77917: PUSH
77918: LD_VAR 0 16
77922: ST_TO_ADDR
// uc_nation := nation ;
77923: LD_ADDR_OWVAR 21
77927: PUSH
77928: LD_VAR 0 17
77932: ST_TO_ADDR
// if buildings then
77933: LD_VAR 0 18
77937: IFFALSE 79259
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
77939: LD_ADDR_VAR 0 19
77943: PUSH
77944: LD_VAR 0 18
77948: PPUSH
77949: LD_INT 2
77951: PUSH
77952: LD_INT 30
77954: PUSH
77955: LD_INT 29
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 30
77964: PUSH
77965: LD_INT 30
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: LIST
77976: PPUSH
77977: CALL_OW 72
77981: ST_TO_ADDR
// if tmp then
77982: LD_VAR 0 19
77986: IFFALSE 78034
// for i in tmp do
77988: LD_ADDR_VAR 0 8
77992: PUSH
77993: LD_VAR 0 19
77997: PUSH
77998: FOR_IN
77999: IFFALSE 78032
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78001: LD_VAR 0 8
78005: PPUSH
78006: CALL_OW 250
78010: PPUSH
78011: LD_VAR 0 8
78015: PPUSH
78016: CALL_OW 251
78020: PPUSH
78021: LD_VAR 0 16
78025: PPUSH
78026: CALL_OW 441
78030: GO 77998
78032: POP
78033: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78034: LD_VAR 0 18
78038: PPUSH
78039: LD_INT 2
78041: PUSH
78042: LD_INT 30
78044: PUSH
78045: LD_INT 32
78047: PUSH
78048: EMPTY
78049: LIST
78050: LIST
78051: PUSH
78052: LD_INT 30
78054: PUSH
78055: LD_INT 33
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: LIST
78066: PPUSH
78067: CALL_OW 72
78071: IFFALSE 78159
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78073: LD_ADDR_VAR 0 8
78077: PUSH
78078: LD_VAR 0 18
78082: PPUSH
78083: LD_INT 2
78085: PUSH
78086: LD_INT 30
78088: PUSH
78089: LD_INT 32
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 30
78098: PUSH
78099: LD_INT 33
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: LIST
78110: PPUSH
78111: CALL_OW 72
78115: PUSH
78116: FOR_IN
78117: IFFALSE 78157
// begin if not GetBWeapon ( i ) then
78119: LD_VAR 0 8
78123: PPUSH
78124: CALL_OW 269
78128: NOT
78129: IFFALSE 78155
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78131: LD_VAR 0 8
78135: PPUSH
78136: LD_VAR 0 8
78140: PPUSH
78141: LD_VAR 0 2
78145: PPUSH
78146: CALL 79405 0 2
78150: PPUSH
78151: CALL_OW 431
// end ;
78155: GO 78116
78157: POP
78158: POP
// end ; for i = 1 to personel do
78159: LD_ADDR_VAR 0 8
78163: PUSH
78164: DOUBLE
78165: LD_INT 1
78167: DEC
78168: ST_TO_ADDR
78169: LD_VAR 0 6
78173: PUSH
78174: FOR_TO
78175: IFFALSE 79239
// begin if i > 4 then
78177: LD_VAR 0 8
78181: PUSH
78182: LD_INT 4
78184: GREATER
78185: IFFALSE 78189
// break ;
78187: GO 79239
// case i of 1 :
78189: LD_VAR 0 8
78193: PUSH
78194: LD_INT 1
78196: DOUBLE
78197: EQUAL
78198: IFTRUE 78202
78200: GO 78282
78202: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78203: LD_ADDR_VAR 0 12
78207: PUSH
78208: LD_VAR 0 18
78212: PPUSH
78213: LD_INT 22
78215: PUSH
78216: LD_VAR 0 16
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 58
78227: PUSH
78228: EMPTY
78229: LIST
78230: PUSH
78231: LD_INT 2
78233: PUSH
78234: LD_INT 30
78236: PUSH
78237: LD_INT 32
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 30
78246: PUSH
78247: LD_INT 4
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 30
78256: PUSH
78257: LD_INT 5
78259: PUSH
78260: EMPTY
78261: LIST
78262: LIST
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: LIST
78274: PPUSH
78275: CALL_OW 72
78279: ST_TO_ADDR
78280: GO 78504
78282: LD_INT 2
78284: DOUBLE
78285: EQUAL
78286: IFTRUE 78290
78288: GO 78352
78290: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78291: LD_ADDR_VAR 0 12
78295: PUSH
78296: LD_VAR 0 18
78300: PPUSH
78301: LD_INT 22
78303: PUSH
78304: LD_VAR 0 16
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 2
78315: PUSH
78316: LD_INT 30
78318: PUSH
78319: LD_INT 0
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PUSH
78326: LD_INT 30
78328: PUSH
78329: LD_INT 1
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: LIST
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PPUSH
78345: CALL_OW 72
78349: ST_TO_ADDR
78350: GO 78504
78352: LD_INT 3
78354: DOUBLE
78355: EQUAL
78356: IFTRUE 78360
78358: GO 78422
78360: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78361: LD_ADDR_VAR 0 12
78365: PUSH
78366: LD_VAR 0 18
78370: PPUSH
78371: LD_INT 22
78373: PUSH
78374: LD_VAR 0 16
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 2
78385: PUSH
78386: LD_INT 30
78388: PUSH
78389: LD_INT 2
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 30
78398: PUSH
78399: LD_INT 3
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: LIST
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PPUSH
78415: CALL_OW 72
78419: ST_TO_ADDR
78420: GO 78504
78422: LD_INT 4
78424: DOUBLE
78425: EQUAL
78426: IFTRUE 78430
78428: GO 78503
78430: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
78431: LD_ADDR_VAR 0 12
78435: PUSH
78436: LD_VAR 0 18
78440: PPUSH
78441: LD_INT 22
78443: PUSH
78444: LD_VAR 0 16
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 2
78455: PUSH
78456: LD_INT 30
78458: PUSH
78459: LD_INT 6
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 30
78468: PUSH
78469: LD_INT 7
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 30
78478: PUSH
78479: LD_INT 8
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: LIST
78490: LIST
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PPUSH
78496: CALL_OW 72
78500: ST_TO_ADDR
78501: GO 78504
78503: POP
// if i = 1 then
78504: LD_VAR 0 8
78508: PUSH
78509: LD_INT 1
78511: EQUAL
78512: IFFALSE 78623
// begin tmp := [ ] ;
78514: LD_ADDR_VAR 0 19
78518: PUSH
78519: EMPTY
78520: ST_TO_ADDR
// for j in f do
78521: LD_ADDR_VAR 0 9
78525: PUSH
78526: LD_VAR 0 12
78530: PUSH
78531: FOR_IN
78532: IFFALSE 78605
// if GetBType ( j ) = b_bunker then
78534: LD_VAR 0 9
78538: PPUSH
78539: CALL_OW 266
78543: PUSH
78544: LD_INT 32
78546: EQUAL
78547: IFFALSE 78574
// tmp := Insert ( tmp , 1 , j ) else
78549: LD_ADDR_VAR 0 19
78553: PUSH
78554: LD_VAR 0 19
78558: PPUSH
78559: LD_INT 1
78561: PPUSH
78562: LD_VAR 0 9
78566: PPUSH
78567: CALL_OW 2
78571: ST_TO_ADDR
78572: GO 78603
// tmp := Insert ( tmp , tmp + 1 , j ) ;
78574: LD_ADDR_VAR 0 19
78578: PUSH
78579: LD_VAR 0 19
78583: PPUSH
78584: LD_VAR 0 19
78588: PUSH
78589: LD_INT 1
78591: PLUS
78592: PPUSH
78593: LD_VAR 0 9
78597: PPUSH
78598: CALL_OW 2
78602: ST_TO_ADDR
78603: GO 78531
78605: POP
78606: POP
// if tmp then
78607: LD_VAR 0 19
78611: IFFALSE 78623
// f := tmp ;
78613: LD_ADDR_VAR 0 12
78617: PUSH
78618: LD_VAR 0 19
78622: ST_TO_ADDR
// end ; x := personel [ i ] ;
78623: LD_ADDR_VAR 0 13
78627: PUSH
78628: LD_VAR 0 6
78632: PUSH
78633: LD_VAR 0 8
78637: ARRAY
78638: ST_TO_ADDR
// if x = - 1 then
78639: LD_VAR 0 13
78643: PUSH
78644: LD_INT 1
78646: NEG
78647: EQUAL
78648: IFFALSE 78857
// begin for j in f do
78650: LD_ADDR_VAR 0 9
78654: PUSH
78655: LD_VAR 0 12
78659: PUSH
78660: FOR_IN
78661: IFFALSE 78853
// repeat InitHc ;
78663: CALL_OW 19
// if GetBType ( j ) = b_barracks then
78667: LD_VAR 0 9
78671: PPUSH
78672: CALL_OW 266
78676: PUSH
78677: LD_INT 5
78679: EQUAL
78680: IFFALSE 78750
// begin if UnitsInside ( j ) < 3 then
78682: LD_VAR 0 9
78686: PPUSH
78687: CALL_OW 313
78691: PUSH
78692: LD_INT 3
78694: LESS
78695: IFFALSE 78731
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78697: LD_INT 0
78699: PPUSH
78700: LD_INT 5
78702: PUSH
78703: LD_INT 8
78705: PUSH
78706: LD_INT 9
78708: PUSH
78709: EMPTY
78710: LIST
78711: LIST
78712: LIST
78713: PUSH
78714: LD_VAR 0 17
78718: ARRAY
78719: PPUSH
78720: LD_VAR 0 4
78724: PPUSH
78725: CALL_OW 380
78729: GO 78748
// PrepareHuman ( false , i , skill ) ;
78731: LD_INT 0
78733: PPUSH
78734: LD_VAR 0 8
78738: PPUSH
78739: LD_VAR 0 4
78743: PPUSH
78744: CALL_OW 380
// end else
78748: GO 78767
// PrepareHuman ( false , i , skill ) ;
78750: LD_INT 0
78752: PPUSH
78753: LD_VAR 0 8
78757: PPUSH
78758: LD_VAR 0 4
78762: PPUSH
78763: CALL_OW 380
// un := CreateHuman ;
78767: LD_ADDR_VAR 0 14
78771: PUSH
78772: CALL_OW 44
78776: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78777: LD_ADDR_VAR 0 7
78781: PUSH
78782: LD_VAR 0 7
78786: PPUSH
78787: LD_INT 1
78789: PPUSH
78790: LD_VAR 0 14
78794: PPUSH
78795: CALL_OW 2
78799: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
78800: LD_VAR 0 14
78804: PPUSH
78805: LD_VAR 0 9
78809: PPUSH
78810: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
78814: LD_VAR 0 9
78818: PPUSH
78819: CALL_OW 313
78823: PUSH
78824: LD_INT 6
78826: EQUAL
78827: PUSH
78828: LD_VAR 0 9
78832: PPUSH
78833: CALL_OW 266
78837: PUSH
78838: LD_INT 32
78840: PUSH
78841: LD_INT 31
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: IN
78848: OR
78849: IFFALSE 78663
78851: GO 78660
78853: POP
78854: POP
// end else
78855: GO 79237
// for j = 1 to x do
78857: LD_ADDR_VAR 0 9
78861: PUSH
78862: DOUBLE
78863: LD_INT 1
78865: DEC
78866: ST_TO_ADDR
78867: LD_VAR 0 13
78871: PUSH
78872: FOR_TO
78873: IFFALSE 79235
// begin InitHc ;
78875: CALL_OW 19
// if not f then
78879: LD_VAR 0 12
78883: NOT
78884: IFFALSE 78973
// begin PrepareHuman ( false , i , skill ) ;
78886: LD_INT 0
78888: PPUSH
78889: LD_VAR 0 8
78893: PPUSH
78894: LD_VAR 0 4
78898: PPUSH
78899: CALL_OW 380
// un := CreateHuman ;
78903: LD_ADDR_VAR 0 14
78907: PUSH
78908: CALL_OW 44
78912: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78913: LD_ADDR_VAR 0 7
78917: PUSH
78918: LD_VAR 0 7
78922: PPUSH
78923: LD_INT 1
78925: PPUSH
78926: LD_VAR 0 14
78930: PPUSH
78931: CALL_OW 2
78935: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78936: LD_VAR 0 14
78940: PPUSH
78941: LD_VAR 0 1
78945: PPUSH
78946: CALL_OW 250
78950: PPUSH
78951: LD_VAR 0 1
78955: PPUSH
78956: CALL_OW 251
78960: PPUSH
78961: LD_INT 10
78963: PPUSH
78964: LD_INT 0
78966: PPUSH
78967: CALL_OW 50
// continue ;
78971: GO 78872
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
78973: LD_VAR 0 12
78977: PUSH
78978: LD_INT 1
78980: ARRAY
78981: PPUSH
78982: CALL_OW 313
78986: PUSH
78987: LD_VAR 0 12
78991: PUSH
78992: LD_INT 1
78994: ARRAY
78995: PPUSH
78996: CALL_OW 266
79000: PUSH
79001: LD_INT 32
79003: PUSH
79004: LD_INT 31
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: IN
79011: AND
79012: PUSH
79013: LD_VAR 0 12
79017: PUSH
79018: LD_INT 1
79020: ARRAY
79021: PPUSH
79022: CALL_OW 313
79026: PUSH
79027: LD_INT 6
79029: EQUAL
79030: OR
79031: IFFALSE 79051
// f := Delete ( f , 1 ) ;
79033: LD_ADDR_VAR 0 12
79037: PUSH
79038: LD_VAR 0 12
79042: PPUSH
79043: LD_INT 1
79045: PPUSH
79046: CALL_OW 3
79050: ST_TO_ADDR
// if not f then
79051: LD_VAR 0 12
79055: NOT
79056: IFFALSE 79074
// begin x := x + 2 ;
79058: LD_ADDR_VAR 0 13
79062: PUSH
79063: LD_VAR 0 13
79067: PUSH
79068: LD_INT 2
79070: PLUS
79071: ST_TO_ADDR
// continue ;
79072: GO 78872
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79074: LD_VAR 0 12
79078: PUSH
79079: LD_INT 1
79081: ARRAY
79082: PPUSH
79083: CALL_OW 266
79087: PUSH
79088: LD_INT 5
79090: EQUAL
79091: IFFALSE 79165
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79093: LD_VAR 0 12
79097: PUSH
79098: LD_INT 1
79100: ARRAY
79101: PPUSH
79102: CALL_OW 313
79106: PUSH
79107: LD_INT 3
79109: LESS
79110: IFFALSE 79146
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79112: LD_INT 0
79114: PPUSH
79115: LD_INT 5
79117: PUSH
79118: LD_INT 8
79120: PUSH
79121: LD_INT 9
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: LIST
79128: PUSH
79129: LD_VAR 0 17
79133: ARRAY
79134: PPUSH
79135: LD_VAR 0 4
79139: PPUSH
79140: CALL_OW 380
79144: GO 79163
// PrepareHuman ( false , i , skill ) ;
79146: LD_INT 0
79148: PPUSH
79149: LD_VAR 0 8
79153: PPUSH
79154: LD_VAR 0 4
79158: PPUSH
79159: CALL_OW 380
// end else
79163: GO 79182
// PrepareHuman ( false , i , skill ) ;
79165: LD_INT 0
79167: PPUSH
79168: LD_VAR 0 8
79172: PPUSH
79173: LD_VAR 0 4
79177: PPUSH
79178: CALL_OW 380
// un := CreateHuman ;
79182: LD_ADDR_VAR 0 14
79186: PUSH
79187: CALL_OW 44
79191: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79192: LD_ADDR_VAR 0 7
79196: PUSH
79197: LD_VAR 0 7
79201: PPUSH
79202: LD_INT 1
79204: PPUSH
79205: LD_VAR 0 14
79209: PPUSH
79210: CALL_OW 2
79214: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79215: LD_VAR 0 14
79219: PPUSH
79220: LD_VAR 0 12
79224: PUSH
79225: LD_INT 1
79227: ARRAY
79228: PPUSH
79229: CALL_OW 52
// end ;
79233: GO 78872
79235: POP
79236: POP
// end ;
79237: GO 78174
79239: POP
79240: POP
// result := result ^ buildings ;
79241: LD_ADDR_VAR 0 7
79245: PUSH
79246: LD_VAR 0 7
79250: PUSH
79251: LD_VAR 0 18
79255: ADD
79256: ST_TO_ADDR
// end else
79257: GO 79400
// begin for i = 1 to personel do
79259: LD_ADDR_VAR 0 8
79263: PUSH
79264: DOUBLE
79265: LD_INT 1
79267: DEC
79268: ST_TO_ADDR
79269: LD_VAR 0 6
79273: PUSH
79274: FOR_TO
79275: IFFALSE 79398
// begin if i > 4 then
79277: LD_VAR 0 8
79281: PUSH
79282: LD_INT 4
79284: GREATER
79285: IFFALSE 79289
// break ;
79287: GO 79398
// x := personel [ i ] ;
79289: LD_ADDR_VAR 0 13
79293: PUSH
79294: LD_VAR 0 6
79298: PUSH
79299: LD_VAR 0 8
79303: ARRAY
79304: ST_TO_ADDR
// if x = - 1 then
79305: LD_VAR 0 13
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: EQUAL
79314: IFFALSE 79318
// continue ;
79316: GO 79274
// PrepareHuman ( false , i , skill ) ;
79318: LD_INT 0
79320: PPUSH
79321: LD_VAR 0 8
79325: PPUSH
79326: LD_VAR 0 4
79330: PPUSH
79331: CALL_OW 380
// un := CreateHuman ;
79335: LD_ADDR_VAR 0 14
79339: PUSH
79340: CALL_OW 44
79344: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79345: LD_VAR 0 14
79349: PPUSH
79350: LD_VAR 0 1
79354: PPUSH
79355: CALL_OW 250
79359: PPUSH
79360: LD_VAR 0 1
79364: PPUSH
79365: CALL_OW 251
79369: PPUSH
79370: LD_INT 10
79372: PPUSH
79373: LD_INT 0
79375: PPUSH
79376: CALL_OW 50
// result := result ^ un ;
79380: LD_ADDR_VAR 0 7
79384: PUSH
79385: LD_VAR 0 7
79389: PUSH
79390: LD_VAR 0 14
79394: ADD
79395: ST_TO_ADDR
// end ;
79396: GO 79274
79398: POP
79399: POP
// end ; end ;
79400: LD_VAR 0 7
79404: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
79405: LD_INT 0
79407: PPUSH
79408: PPUSH
79409: PPUSH
79410: PPUSH
79411: PPUSH
79412: PPUSH
79413: PPUSH
79414: PPUSH
79415: PPUSH
79416: PPUSH
79417: PPUSH
79418: PPUSH
79419: PPUSH
79420: PPUSH
79421: PPUSH
79422: PPUSH
// result := false ;
79423: LD_ADDR_VAR 0 3
79427: PUSH
79428: LD_INT 0
79430: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
79431: LD_VAR 0 1
79435: NOT
79436: PUSH
79437: LD_VAR 0 1
79441: PPUSH
79442: CALL_OW 266
79446: PUSH
79447: LD_INT 32
79449: PUSH
79450: LD_INT 33
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: IN
79457: NOT
79458: OR
79459: IFFALSE 79463
// exit ;
79461: GO 80572
// nat := GetNation ( tower ) ;
79463: LD_ADDR_VAR 0 12
79467: PUSH
79468: LD_VAR 0 1
79472: PPUSH
79473: CALL_OW 248
79477: ST_TO_ADDR
// side := GetSide ( tower ) ;
79478: LD_ADDR_VAR 0 16
79482: PUSH
79483: LD_VAR 0 1
79487: PPUSH
79488: CALL_OW 255
79492: ST_TO_ADDR
// x := GetX ( tower ) ;
79493: LD_ADDR_VAR 0 10
79497: PUSH
79498: LD_VAR 0 1
79502: PPUSH
79503: CALL_OW 250
79507: ST_TO_ADDR
// y := GetY ( tower ) ;
79508: LD_ADDR_VAR 0 11
79512: PUSH
79513: LD_VAR 0 1
79517: PPUSH
79518: CALL_OW 251
79522: ST_TO_ADDR
// if not x or not y then
79523: LD_VAR 0 10
79527: NOT
79528: PUSH
79529: LD_VAR 0 11
79533: NOT
79534: OR
79535: IFFALSE 79539
// exit ;
79537: GO 80572
// weapon := 0 ;
79539: LD_ADDR_VAR 0 18
79543: PUSH
79544: LD_INT 0
79546: ST_TO_ADDR
// fac_list := [ ] ;
79547: LD_ADDR_VAR 0 17
79551: PUSH
79552: EMPTY
79553: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
79554: LD_ADDR_VAR 0 6
79558: PUSH
79559: LD_VAR 0 1
79563: PPUSH
79564: CALL_OW 274
79568: PPUSH
79569: LD_VAR 0 2
79573: PPUSH
79574: LD_INT 0
79576: PPUSH
79577: CALL 77143 0 3
79581: PPUSH
79582: LD_INT 30
79584: PUSH
79585: LD_INT 3
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PPUSH
79592: CALL_OW 72
79596: ST_TO_ADDR
// if not factories then
79597: LD_VAR 0 6
79601: NOT
79602: IFFALSE 79606
// exit ;
79604: GO 80572
// for i in factories do
79606: LD_ADDR_VAR 0 8
79610: PUSH
79611: LD_VAR 0 6
79615: PUSH
79616: FOR_IN
79617: IFFALSE 79642
// fac_list := fac_list union AvailableWeaponList ( i ) ;
79619: LD_ADDR_VAR 0 17
79623: PUSH
79624: LD_VAR 0 17
79628: PUSH
79629: LD_VAR 0 8
79633: PPUSH
79634: CALL_OW 478
79638: UNION
79639: ST_TO_ADDR
79640: GO 79616
79642: POP
79643: POP
// if not fac_list then
79644: LD_VAR 0 17
79648: NOT
79649: IFFALSE 79653
// exit ;
79651: GO 80572
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
79653: LD_ADDR_VAR 0 5
79657: PUSH
79658: LD_INT 4
79660: PUSH
79661: LD_INT 5
79663: PUSH
79664: LD_INT 9
79666: PUSH
79667: LD_INT 10
79669: PUSH
79670: LD_INT 6
79672: PUSH
79673: LD_INT 7
79675: PUSH
79676: LD_INT 11
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 27
79690: PUSH
79691: LD_INT 28
79693: PUSH
79694: LD_INT 26
79696: PUSH
79697: LD_INT 30
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 43
79708: PUSH
79709: LD_INT 44
79711: PUSH
79712: LD_INT 46
79714: PUSH
79715: LD_INT 45
79717: PUSH
79718: LD_INT 47
79720: PUSH
79721: LD_INT 49
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: LIST
79730: LIST
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: LIST
79736: PUSH
79737: LD_VAR 0 12
79741: ARRAY
79742: ST_TO_ADDR
// list := list isect fac_list ;
79743: LD_ADDR_VAR 0 5
79747: PUSH
79748: LD_VAR 0 5
79752: PUSH
79753: LD_VAR 0 17
79757: ISECT
79758: ST_TO_ADDR
// if not list then
79759: LD_VAR 0 5
79763: NOT
79764: IFFALSE 79768
// exit ;
79766: GO 80572
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
79768: LD_VAR 0 12
79772: PUSH
79773: LD_INT 3
79775: EQUAL
79776: PUSH
79777: LD_INT 49
79779: PUSH
79780: LD_VAR 0 5
79784: IN
79785: AND
79786: PUSH
79787: LD_INT 31
79789: PPUSH
79790: LD_VAR 0 16
79794: PPUSH
79795: CALL_OW 321
79799: PUSH
79800: LD_INT 2
79802: EQUAL
79803: AND
79804: IFFALSE 79864
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
79806: LD_INT 22
79808: PUSH
79809: LD_VAR 0 16
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 35
79820: PUSH
79821: LD_INT 49
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 91
79830: PUSH
79831: LD_VAR 0 1
79835: PUSH
79836: LD_INT 10
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: LIST
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: LIST
79848: PPUSH
79849: CALL_OW 69
79853: NOT
79854: IFFALSE 79864
// weapon := ru_time_lapser ;
79856: LD_ADDR_VAR 0 18
79860: PUSH
79861: LD_INT 49
79863: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
79864: LD_VAR 0 12
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 2
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: IN
79879: PUSH
79880: LD_INT 11
79882: PUSH
79883: LD_VAR 0 5
79887: IN
79888: PUSH
79889: LD_INT 30
79891: PUSH
79892: LD_VAR 0 5
79896: IN
79897: OR
79898: AND
79899: PUSH
79900: LD_INT 6
79902: PPUSH
79903: LD_VAR 0 16
79907: PPUSH
79908: CALL_OW 321
79912: PUSH
79913: LD_INT 2
79915: EQUAL
79916: AND
79917: IFFALSE 80082
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
79919: LD_INT 22
79921: PUSH
79922: LD_VAR 0 16
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 2
79933: PUSH
79934: LD_INT 35
79936: PUSH
79937: LD_INT 11
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 35
79946: PUSH
79947: LD_INT 30
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 91
79961: PUSH
79962: LD_VAR 0 1
79966: PUSH
79967: LD_INT 18
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: LIST
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: LIST
79979: PPUSH
79980: CALL_OW 69
79984: NOT
79985: PUSH
79986: LD_INT 22
79988: PUSH
79989: LD_VAR 0 16
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 2
80000: PUSH
80001: LD_INT 30
80003: PUSH
80004: LD_INT 32
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PUSH
80011: LD_INT 30
80013: PUSH
80014: LD_INT 33
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 91
80028: PUSH
80029: LD_VAR 0 1
80033: PUSH
80034: LD_INT 12
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: LIST
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: LIST
80046: PUSH
80047: EMPTY
80048: LIST
80049: PPUSH
80050: CALL_OW 69
80054: PUSH
80055: LD_INT 2
80057: GREATER
80058: AND
80059: IFFALSE 80082
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80061: LD_ADDR_VAR 0 18
80065: PUSH
80066: LD_INT 11
80068: PUSH
80069: LD_INT 30
80071: PUSH
80072: EMPTY
80073: LIST
80074: LIST
80075: PUSH
80076: LD_VAR 0 12
80080: ARRAY
80081: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80082: LD_VAR 0 18
80086: NOT
80087: PUSH
80088: LD_INT 40
80090: PPUSH
80091: LD_VAR 0 16
80095: PPUSH
80096: CALL_OW 321
80100: PUSH
80101: LD_INT 2
80103: EQUAL
80104: AND
80105: PUSH
80106: LD_INT 7
80108: PUSH
80109: LD_VAR 0 5
80113: IN
80114: PUSH
80115: LD_INT 28
80117: PUSH
80118: LD_VAR 0 5
80122: IN
80123: OR
80124: PUSH
80125: LD_INT 45
80127: PUSH
80128: LD_VAR 0 5
80132: IN
80133: OR
80134: AND
80135: IFFALSE 80389
// begin hex := GetHexInfo ( x , y ) ;
80137: LD_ADDR_VAR 0 4
80141: PUSH
80142: LD_VAR 0 10
80146: PPUSH
80147: LD_VAR 0 11
80151: PPUSH
80152: CALL_OW 546
80156: ST_TO_ADDR
// if hex [ 1 ] then
80157: LD_VAR 0 4
80161: PUSH
80162: LD_INT 1
80164: ARRAY
80165: IFFALSE 80169
// exit ;
80167: GO 80572
// height := hex [ 2 ] ;
80169: LD_ADDR_VAR 0 15
80173: PUSH
80174: LD_VAR 0 4
80178: PUSH
80179: LD_INT 2
80181: ARRAY
80182: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80183: LD_ADDR_VAR 0 14
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: LD_INT 3
80196: PUSH
80197: LD_INT 5
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: LIST
80204: LIST
80205: ST_TO_ADDR
// for i in tmp do
80206: LD_ADDR_VAR 0 8
80210: PUSH
80211: LD_VAR 0 14
80215: PUSH
80216: FOR_IN
80217: IFFALSE 80387
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80219: LD_ADDR_VAR 0 9
80223: PUSH
80224: LD_VAR 0 10
80228: PPUSH
80229: LD_VAR 0 8
80233: PPUSH
80234: LD_INT 5
80236: PPUSH
80237: CALL_OW 272
80241: PUSH
80242: LD_VAR 0 11
80246: PPUSH
80247: LD_VAR 0 8
80251: PPUSH
80252: LD_INT 5
80254: PPUSH
80255: CALL_OW 273
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80264: LD_VAR 0 9
80268: PUSH
80269: LD_INT 1
80271: ARRAY
80272: PPUSH
80273: LD_VAR 0 9
80277: PUSH
80278: LD_INT 2
80280: ARRAY
80281: PPUSH
80282: CALL_OW 488
80286: IFFALSE 80385
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80288: LD_ADDR_VAR 0 4
80292: PUSH
80293: LD_VAR 0 9
80297: PUSH
80298: LD_INT 1
80300: ARRAY
80301: PPUSH
80302: LD_VAR 0 9
80306: PUSH
80307: LD_INT 2
80309: ARRAY
80310: PPUSH
80311: CALL_OW 546
80315: ST_TO_ADDR
// if hex [ 1 ] then
80316: LD_VAR 0 4
80320: PUSH
80321: LD_INT 1
80323: ARRAY
80324: IFFALSE 80328
// continue ;
80326: GO 80216
// h := hex [ 2 ] ;
80328: LD_ADDR_VAR 0 13
80332: PUSH
80333: LD_VAR 0 4
80337: PUSH
80338: LD_INT 2
80340: ARRAY
80341: ST_TO_ADDR
// if h + 7 < height then
80342: LD_VAR 0 13
80346: PUSH
80347: LD_INT 7
80349: PLUS
80350: PUSH
80351: LD_VAR 0 15
80355: LESS
80356: IFFALSE 80385
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80358: LD_ADDR_VAR 0 18
80362: PUSH
80363: LD_INT 7
80365: PUSH
80366: LD_INT 28
80368: PUSH
80369: LD_INT 45
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: LIST
80376: PUSH
80377: LD_VAR 0 12
80381: ARRAY
80382: ST_TO_ADDR
// break ;
80383: GO 80387
// end ; end ; end ;
80385: GO 80216
80387: POP
80388: POP
// end ; if not weapon then
80389: LD_VAR 0 18
80393: NOT
80394: IFFALSE 80454
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
80396: LD_ADDR_VAR 0 5
80400: PUSH
80401: LD_VAR 0 5
80405: PUSH
80406: LD_INT 11
80408: PUSH
80409: LD_INT 30
80411: PUSH
80412: LD_INT 49
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: LIST
80419: DIFF
80420: ST_TO_ADDR
// if not list then
80421: LD_VAR 0 5
80425: NOT
80426: IFFALSE 80430
// exit ;
80428: GO 80572
// weapon := list [ rand ( 1 , list ) ] ;
80430: LD_ADDR_VAR 0 18
80434: PUSH
80435: LD_VAR 0 5
80439: PUSH
80440: LD_INT 1
80442: PPUSH
80443: LD_VAR 0 5
80447: PPUSH
80448: CALL_OW 12
80452: ARRAY
80453: ST_TO_ADDR
// end ; if weapon then
80454: LD_VAR 0 18
80458: IFFALSE 80572
// begin tmp := CostOfWeapon ( weapon ) ;
80460: LD_ADDR_VAR 0 14
80464: PUSH
80465: LD_VAR 0 18
80469: PPUSH
80470: CALL_OW 451
80474: ST_TO_ADDR
// j := GetBase ( tower ) ;
80475: LD_ADDR_VAR 0 9
80479: PUSH
80480: LD_VAR 0 1
80484: PPUSH
80485: CALL_OW 274
80489: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
80490: LD_VAR 0 9
80494: PPUSH
80495: LD_INT 1
80497: PPUSH
80498: CALL_OW 275
80502: PUSH
80503: LD_VAR 0 14
80507: PUSH
80508: LD_INT 1
80510: ARRAY
80511: GREATEREQUAL
80512: PUSH
80513: LD_VAR 0 9
80517: PPUSH
80518: LD_INT 2
80520: PPUSH
80521: CALL_OW 275
80525: PUSH
80526: LD_VAR 0 14
80530: PUSH
80531: LD_INT 2
80533: ARRAY
80534: GREATEREQUAL
80535: AND
80536: PUSH
80537: LD_VAR 0 9
80541: PPUSH
80542: LD_INT 3
80544: PPUSH
80545: CALL_OW 275
80549: PUSH
80550: LD_VAR 0 14
80554: PUSH
80555: LD_INT 3
80557: ARRAY
80558: GREATEREQUAL
80559: AND
80560: IFFALSE 80572
// result := weapon ;
80562: LD_ADDR_VAR 0 3
80566: PUSH
80567: LD_VAR 0 18
80571: ST_TO_ADDR
// end ; end ;
80572: LD_VAR 0 3
80576: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
80577: LD_INT 0
80579: PPUSH
80580: PPUSH
// result := true ;
80581: LD_ADDR_VAR 0 3
80585: PUSH
80586: LD_INT 1
80588: ST_TO_ADDR
// if array1 = array2 then
80589: LD_VAR 0 1
80593: PUSH
80594: LD_VAR 0 2
80598: EQUAL
80599: IFFALSE 80659
// begin for i = 1 to array1 do
80601: LD_ADDR_VAR 0 4
80605: PUSH
80606: DOUBLE
80607: LD_INT 1
80609: DEC
80610: ST_TO_ADDR
80611: LD_VAR 0 1
80615: PUSH
80616: FOR_TO
80617: IFFALSE 80655
// if array1 [ i ] <> array2 [ i ] then
80619: LD_VAR 0 1
80623: PUSH
80624: LD_VAR 0 4
80628: ARRAY
80629: PUSH
80630: LD_VAR 0 2
80634: PUSH
80635: LD_VAR 0 4
80639: ARRAY
80640: NONEQUAL
80641: IFFALSE 80653
// begin result := false ;
80643: LD_ADDR_VAR 0 3
80647: PUSH
80648: LD_INT 0
80650: ST_TO_ADDR
// break ;
80651: GO 80655
// end ;
80653: GO 80616
80655: POP
80656: POP
// end else
80657: GO 80667
// result := false ;
80659: LD_ADDR_VAR 0 3
80663: PUSH
80664: LD_INT 0
80666: ST_TO_ADDR
// end ;
80667: LD_VAR 0 3
80671: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
80672: LD_INT 0
80674: PPUSH
80675: PPUSH
// if not array1 or not array2 then
80676: LD_VAR 0 1
80680: NOT
80681: PUSH
80682: LD_VAR 0 2
80686: NOT
80687: OR
80688: IFFALSE 80692
// exit ;
80690: GO 80756
// result := true ;
80692: LD_ADDR_VAR 0 3
80696: PUSH
80697: LD_INT 1
80699: ST_TO_ADDR
// for i = 1 to array1 do
80700: LD_ADDR_VAR 0 4
80704: PUSH
80705: DOUBLE
80706: LD_INT 1
80708: DEC
80709: ST_TO_ADDR
80710: LD_VAR 0 1
80714: PUSH
80715: FOR_TO
80716: IFFALSE 80754
// if array1 [ i ] <> array2 [ i ] then
80718: LD_VAR 0 1
80722: PUSH
80723: LD_VAR 0 4
80727: ARRAY
80728: PUSH
80729: LD_VAR 0 2
80733: PUSH
80734: LD_VAR 0 4
80738: ARRAY
80739: NONEQUAL
80740: IFFALSE 80752
// begin result := false ;
80742: LD_ADDR_VAR 0 3
80746: PUSH
80747: LD_INT 0
80749: ST_TO_ADDR
// break ;
80750: GO 80754
// end ;
80752: GO 80715
80754: POP
80755: POP
// end ;
80756: LD_VAR 0 3
80760: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
80761: LD_INT 0
80763: PPUSH
80764: PPUSH
80765: PPUSH
// pom := GetBase ( fac ) ;
80766: LD_ADDR_VAR 0 5
80770: PUSH
80771: LD_VAR 0 1
80775: PPUSH
80776: CALL_OW 274
80780: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
80781: LD_ADDR_VAR 0 4
80785: PUSH
80786: LD_VAR 0 2
80790: PUSH
80791: LD_INT 1
80793: ARRAY
80794: PPUSH
80795: LD_VAR 0 2
80799: PUSH
80800: LD_INT 2
80802: ARRAY
80803: PPUSH
80804: LD_VAR 0 2
80808: PUSH
80809: LD_INT 3
80811: ARRAY
80812: PPUSH
80813: LD_VAR 0 2
80817: PUSH
80818: LD_INT 4
80820: ARRAY
80821: PPUSH
80822: CALL_OW 449
80826: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80827: LD_ADDR_VAR 0 3
80831: PUSH
80832: LD_VAR 0 5
80836: PPUSH
80837: LD_INT 1
80839: PPUSH
80840: CALL_OW 275
80844: PUSH
80845: LD_VAR 0 4
80849: PUSH
80850: LD_INT 1
80852: ARRAY
80853: GREATEREQUAL
80854: PUSH
80855: LD_VAR 0 5
80859: PPUSH
80860: LD_INT 2
80862: PPUSH
80863: CALL_OW 275
80867: PUSH
80868: LD_VAR 0 4
80872: PUSH
80873: LD_INT 2
80875: ARRAY
80876: GREATEREQUAL
80877: AND
80878: PUSH
80879: LD_VAR 0 5
80883: PPUSH
80884: LD_INT 3
80886: PPUSH
80887: CALL_OW 275
80891: PUSH
80892: LD_VAR 0 4
80896: PUSH
80897: LD_INT 3
80899: ARRAY
80900: GREATEREQUAL
80901: AND
80902: ST_TO_ADDR
// end ;
80903: LD_VAR 0 3
80907: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
80908: LD_INT 0
80910: PPUSH
80911: PPUSH
80912: PPUSH
80913: PPUSH
// pom := GetBase ( building ) ;
80914: LD_ADDR_VAR 0 3
80918: PUSH
80919: LD_VAR 0 1
80923: PPUSH
80924: CALL_OW 274
80928: ST_TO_ADDR
// if not pom then
80929: LD_VAR 0 3
80933: NOT
80934: IFFALSE 80938
// exit ;
80936: GO 81108
// btype := GetBType ( building ) ;
80938: LD_ADDR_VAR 0 5
80942: PUSH
80943: LD_VAR 0 1
80947: PPUSH
80948: CALL_OW 266
80952: ST_TO_ADDR
// if btype = b_armoury then
80953: LD_VAR 0 5
80957: PUSH
80958: LD_INT 4
80960: EQUAL
80961: IFFALSE 80971
// btype := b_barracks ;
80963: LD_ADDR_VAR 0 5
80967: PUSH
80968: LD_INT 5
80970: ST_TO_ADDR
// if btype = b_depot then
80971: LD_VAR 0 5
80975: PUSH
80976: LD_INT 0
80978: EQUAL
80979: IFFALSE 80989
// btype := b_warehouse ;
80981: LD_ADDR_VAR 0 5
80985: PUSH
80986: LD_INT 1
80988: ST_TO_ADDR
// if btype = b_workshop then
80989: LD_VAR 0 5
80993: PUSH
80994: LD_INT 2
80996: EQUAL
80997: IFFALSE 81007
// btype := b_factory ;
80999: LD_ADDR_VAR 0 5
81003: PUSH
81004: LD_INT 3
81006: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81007: LD_ADDR_VAR 0 4
81011: PUSH
81012: LD_VAR 0 5
81016: PPUSH
81017: LD_VAR 0 1
81021: PPUSH
81022: CALL_OW 248
81026: PPUSH
81027: CALL_OW 450
81031: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81032: LD_ADDR_VAR 0 2
81036: PUSH
81037: LD_VAR 0 3
81041: PPUSH
81042: LD_INT 1
81044: PPUSH
81045: CALL_OW 275
81049: PUSH
81050: LD_VAR 0 4
81054: PUSH
81055: LD_INT 1
81057: ARRAY
81058: GREATEREQUAL
81059: PUSH
81060: LD_VAR 0 3
81064: PPUSH
81065: LD_INT 2
81067: PPUSH
81068: CALL_OW 275
81072: PUSH
81073: LD_VAR 0 4
81077: PUSH
81078: LD_INT 2
81080: ARRAY
81081: GREATEREQUAL
81082: AND
81083: PUSH
81084: LD_VAR 0 3
81088: PPUSH
81089: LD_INT 3
81091: PPUSH
81092: CALL_OW 275
81096: PUSH
81097: LD_VAR 0 4
81101: PUSH
81102: LD_INT 3
81104: ARRAY
81105: GREATEREQUAL
81106: AND
81107: ST_TO_ADDR
// end ;
81108: LD_VAR 0 2
81112: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81113: LD_INT 0
81115: PPUSH
81116: PPUSH
81117: PPUSH
// pom := GetBase ( building ) ;
81118: LD_ADDR_VAR 0 4
81122: PUSH
81123: LD_VAR 0 1
81127: PPUSH
81128: CALL_OW 274
81132: ST_TO_ADDR
// if not pom then
81133: LD_VAR 0 4
81137: NOT
81138: IFFALSE 81142
// exit ;
81140: GO 81243
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81142: LD_ADDR_VAR 0 5
81146: PUSH
81147: LD_VAR 0 2
81151: PPUSH
81152: LD_VAR 0 1
81156: PPUSH
81157: CALL_OW 248
81161: PPUSH
81162: CALL_OW 450
81166: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81167: LD_ADDR_VAR 0 3
81171: PUSH
81172: LD_VAR 0 4
81176: PPUSH
81177: LD_INT 1
81179: PPUSH
81180: CALL_OW 275
81184: PUSH
81185: LD_VAR 0 5
81189: PUSH
81190: LD_INT 1
81192: ARRAY
81193: GREATEREQUAL
81194: PUSH
81195: LD_VAR 0 4
81199: PPUSH
81200: LD_INT 2
81202: PPUSH
81203: CALL_OW 275
81207: PUSH
81208: LD_VAR 0 5
81212: PUSH
81213: LD_INT 2
81215: ARRAY
81216: GREATEREQUAL
81217: AND
81218: PUSH
81219: LD_VAR 0 4
81223: PPUSH
81224: LD_INT 3
81226: PPUSH
81227: CALL_OW 275
81231: PUSH
81232: LD_VAR 0 5
81236: PUSH
81237: LD_INT 3
81239: ARRAY
81240: GREATEREQUAL
81241: AND
81242: ST_TO_ADDR
// end ;
81243: LD_VAR 0 3
81247: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81248: LD_INT 0
81250: PPUSH
81251: PPUSH
81252: PPUSH
81253: PPUSH
81254: PPUSH
81255: PPUSH
81256: PPUSH
81257: PPUSH
81258: PPUSH
81259: PPUSH
81260: PPUSH
// result := false ;
81261: LD_ADDR_VAR 0 8
81265: PUSH
81266: LD_INT 0
81268: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81269: LD_VAR 0 5
81273: NOT
81274: PUSH
81275: LD_VAR 0 1
81279: NOT
81280: OR
81281: PUSH
81282: LD_VAR 0 2
81286: NOT
81287: OR
81288: PUSH
81289: LD_VAR 0 3
81293: NOT
81294: OR
81295: IFFALSE 81299
// exit ;
81297: GO 82113
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81299: LD_ADDR_VAR 0 14
81303: PUSH
81304: LD_VAR 0 1
81308: PPUSH
81309: LD_VAR 0 2
81313: PPUSH
81314: LD_VAR 0 3
81318: PPUSH
81319: LD_VAR 0 4
81323: PPUSH
81324: LD_VAR 0 5
81328: PUSH
81329: LD_INT 1
81331: ARRAY
81332: PPUSH
81333: CALL_OW 248
81337: PPUSH
81338: LD_INT 0
81340: PPUSH
81341: CALL 83366 0 6
81345: ST_TO_ADDR
// if not hexes then
81346: LD_VAR 0 14
81350: NOT
81351: IFFALSE 81355
// exit ;
81353: GO 82113
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81355: LD_ADDR_VAR 0 17
81359: PUSH
81360: LD_VAR 0 5
81364: PPUSH
81365: LD_INT 22
81367: PUSH
81368: LD_VAR 0 13
81372: PPUSH
81373: CALL_OW 255
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 2
81384: PUSH
81385: LD_INT 30
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 30
81397: PUSH
81398: LD_INT 1
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: LIST
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PPUSH
81414: CALL_OW 72
81418: ST_TO_ADDR
// for i = 1 to hexes do
81419: LD_ADDR_VAR 0 9
81423: PUSH
81424: DOUBLE
81425: LD_INT 1
81427: DEC
81428: ST_TO_ADDR
81429: LD_VAR 0 14
81433: PUSH
81434: FOR_TO
81435: IFFALSE 82111
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81437: LD_ADDR_VAR 0 13
81441: PUSH
81442: LD_VAR 0 14
81446: PUSH
81447: LD_VAR 0 9
81451: ARRAY
81452: PUSH
81453: LD_INT 1
81455: ARRAY
81456: PPUSH
81457: LD_VAR 0 14
81461: PUSH
81462: LD_VAR 0 9
81466: ARRAY
81467: PUSH
81468: LD_INT 2
81470: ARRAY
81471: PPUSH
81472: CALL_OW 428
81476: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
81477: LD_VAR 0 14
81481: PUSH
81482: LD_VAR 0 9
81486: ARRAY
81487: PUSH
81488: LD_INT 1
81490: ARRAY
81491: PPUSH
81492: LD_VAR 0 14
81496: PUSH
81497: LD_VAR 0 9
81501: ARRAY
81502: PUSH
81503: LD_INT 2
81505: ARRAY
81506: PPUSH
81507: CALL_OW 351
81511: PUSH
81512: LD_VAR 0 14
81516: PUSH
81517: LD_VAR 0 9
81521: ARRAY
81522: PUSH
81523: LD_INT 1
81525: ARRAY
81526: PPUSH
81527: LD_VAR 0 14
81531: PUSH
81532: LD_VAR 0 9
81536: ARRAY
81537: PUSH
81538: LD_INT 2
81540: ARRAY
81541: PPUSH
81542: CALL_OW 488
81546: NOT
81547: OR
81548: PUSH
81549: LD_VAR 0 13
81553: PPUSH
81554: CALL_OW 247
81558: PUSH
81559: LD_INT 3
81561: EQUAL
81562: OR
81563: IFFALSE 81569
// exit ;
81565: POP
81566: POP
81567: GO 82113
// if not tmp then
81569: LD_VAR 0 13
81573: NOT
81574: IFFALSE 81578
// continue ;
81576: GO 81434
// result := true ;
81578: LD_ADDR_VAR 0 8
81582: PUSH
81583: LD_INT 1
81585: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
81586: LD_VAR 0 6
81590: PUSH
81591: LD_VAR 0 13
81595: PPUSH
81596: CALL_OW 247
81600: PUSH
81601: LD_INT 2
81603: EQUAL
81604: AND
81605: PUSH
81606: LD_VAR 0 13
81610: PPUSH
81611: CALL_OW 263
81615: PUSH
81616: LD_INT 1
81618: EQUAL
81619: AND
81620: IFFALSE 81784
// begin if IsDrivenBy ( tmp ) then
81622: LD_VAR 0 13
81626: PPUSH
81627: CALL_OW 311
81631: IFFALSE 81635
// continue ;
81633: GO 81434
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
81635: LD_VAR 0 6
81639: PPUSH
81640: LD_INT 3
81642: PUSH
81643: LD_INT 60
81645: PUSH
81646: EMPTY
81647: LIST
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 3
81655: PUSH
81656: LD_INT 55
81658: PUSH
81659: EMPTY
81660: LIST
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PPUSH
81670: CALL_OW 72
81674: IFFALSE 81782
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
81676: LD_ADDR_VAR 0 18
81680: PUSH
81681: LD_VAR 0 6
81685: PPUSH
81686: LD_INT 3
81688: PUSH
81689: LD_INT 60
81691: PUSH
81692: EMPTY
81693: LIST
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 3
81701: PUSH
81702: LD_INT 55
81704: PUSH
81705: EMPTY
81706: LIST
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PPUSH
81716: CALL_OW 72
81720: PUSH
81721: LD_INT 1
81723: ARRAY
81724: ST_TO_ADDR
// if IsInUnit ( driver ) then
81725: LD_VAR 0 18
81729: PPUSH
81730: CALL_OW 310
81734: IFFALSE 81745
// ComExit ( driver ) ;
81736: LD_VAR 0 18
81740: PPUSH
81741: CALL 107158 0 1
// AddComEnterUnit ( driver , tmp ) ;
81745: LD_VAR 0 18
81749: PPUSH
81750: LD_VAR 0 13
81754: PPUSH
81755: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
81759: LD_VAR 0 18
81763: PPUSH
81764: LD_VAR 0 7
81768: PPUSH
81769: CALL_OW 173
// AddComExitVehicle ( driver ) ;
81773: LD_VAR 0 18
81777: PPUSH
81778: CALL_OW 181
// end ; continue ;
81782: GO 81434
// end ; if not cleaners or not tmp in cleaners then
81784: LD_VAR 0 6
81788: NOT
81789: PUSH
81790: LD_VAR 0 13
81794: PUSH
81795: LD_VAR 0 6
81799: IN
81800: NOT
81801: OR
81802: IFFALSE 82109
// begin if dep then
81804: LD_VAR 0 17
81808: IFFALSE 81944
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
81810: LD_ADDR_VAR 0 16
81814: PUSH
81815: LD_VAR 0 17
81819: PUSH
81820: LD_INT 1
81822: ARRAY
81823: PPUSH
81824: CALL_OW 250
81828: PPUSH
81829: LD_VAR 0 17
81833: PUSH
81834: LD_INT 1
81836: ARRAY
81837: PPUSH
81838: CALL_OW 254
81842: PPUSH
81843: LD_INT 5
81845: PPUSH
81846: CALL_OW 272
81850: PUSH
81851: LD_VAR 0 17
81855: PUSH
81856: LD_INT 1
81858: ARRAY
81859: PPUSH
81860: CALL_OW 251
81864: PPUSH
81865: LD_VAR 0 17
81869: PUSH
81870: LD_INT 1
81872: ARRAY
81873: PPUSH
81874: CALL_OW 254
81878: PPUSH
81879: LD_INT 5
81881: PPUSH
81882: CALL_OW 273
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
81891: LD_VAR 0 16
81895: PUSH
81896: LD_INT 1
81898: ARRAY
81899: PPUSH
81900: LD_VAR 0 16
81904: PUSH
81905: LD_INT 2
81907: ARRAY
81908: PPUSH
81909: CALL_OW 488
81913: IFFALSE 81944
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
81915: LD_VAR 0 13
81919: PPUSH
81920: LD_VAR 0 16
81924: PUSH
81925: LD_INT 1
81927: ARRAY
81928: PPUSH
81929: LD_VAR 0 16
81933: PUSH
81934: LD_INT 2
81936: ARRAY
81937: PPUSH
81938: CALL_OW 111
// continue ;
81942: GO 81434
// end ; end ; r := GetDir ( tmp ) ;
81944: LD_ADDR_VAR 0 15
81948: PUSH
81949: LD_VAR 0 13
81953: PPUSH
81954: CALL_OW 254
81958: ST_TO_ADDR
// if r = 5 then
81959: LD_VAR 0 15
81963: PUSH
81964: LD_INT 5
81966: EQUAL
81967: IFFALSE 81977
// r := 0 ;
81969: LD_ADDR_VAR 0 15
81973: PUSH
81974: LD_INT 0
81976: ST_TO_ADDR
// for j = r to 5 do
81977: LD_ADDR_VAR 0 10
81981: PUSH
81982: DOUBLE
81983: LD_VAR 0 15
81987: DEC
81988: ST_TO_ADDR
81989: LD_INT 5
81991: PUSH
81992: FOR_TO
81993: IFFALSE 82107
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
81995: LD_ADDR_VAR 0 11
81999: PUSH
82000: LD_VAR 0 13
82004: PPUSH
82005: CALL_OW 250
82009: PPUSH
82010: LD_VAR 0 10
82014: PPUSH
82015: LD_INT 2
82017: PPUSH
82018: CALL_OW 272
82022: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82023: LD_ADDR_VAR 0 12
82027: PUSH
82028: LD_VAR 0 13
82032: PPUSH
82033: CALL_OW 251
82037: PPUSH
82038: LD_VAR 0 10
82042: PPUSH
82043: LD_INT 2
82045: PPUSH
82046: CALL_OW 273
82050: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82051: LD_VAR 0 11
82055: PPUSH
82056: LD_VAR 0 12
82060: PPUSH
82061: CALL_OW 488
82065: PUSH
82066: LD_VAR 0 11
82070: PPUSH
82071: LD_VAR 0 12
82075: PPUSH
82076: CALL_OW 428
82080: NOT
82081: AND
82082: IFFALSE 82105
// begin ComMoveXY ( tmp , _x , _y ) ;
82084: LD_VAR 0 13
82088: PPUSH
82089: LD_VAR 0 11
82093: PPUSH
82094: LD_VAR 0 12
82098: PPUSH
82099: CALL_OW 111
// break ;
82103: GO 82107
// end ; end ;
82105: GO 81992
82107: POP
82108: POP
// end ; end ;
82109: GO 81434
82111: POP
82112: POP
// end ;
82113: LD_VAR 0 8
82117: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82118: LD_INT 0
82120: PPUSH
// result := true ;
82121: LD_ADDR_VAR 0 3
82125: PUSH
82126: LD_INT 1
82128: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82129: LD_VAR 0 2
82133: PUSH
82134: LD_INT 24
82136: DOUBLE
82137: EQUAL
82138: IFTRUE 82148
82140: LD_INT 33
82142: DOUBLE
82143: EQUAL
82144: IFTRUE 82148
82146: GO 82173
82148: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82149: LD_ADDR_VAR 0 3
82153: PUSH
82154: LD_INT 32
82156: PPUSH
82157: LD_VAR 0 1
82161: PPUSH
82162: CALL_OW 321
82166: PUSH
82167: LD_INT 2
82169: EQUAL
82170: ST_TO_ADDR
82171: GO 82489
82173: LD_INT 20
82175: DOUBLE
82176: EQUAL
82177: IFTRUE 82181
82179: GO 82206
82181: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82182: LD_ADDR_VAR 0 3
82186: PUSH
82187: LD_INT 6
82189: PPUSH
82190: LD_VAR 0 1
82194: PPUSH
82195: CALL_OW 321
82199: PUSH
82200: LD_INT 2
82202: EQUAL
82203: ST_TO_ADDR
82204: GO 82489
82206: LD_INT 22
82208: DOUBLE
82209: EQUAL
82210: IFTRUE 82220
82212: LD_INT 36
82214: DOUBLE
82215: EQUAL
82216: IFTRUE 82220
82218: GO 82245
82220: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82221: LD_ADDR_VAR 0 3
82225: PUSH
82226: LD_INT 15
82228: PPUSH
82229: LD_VAR 0 1
82233: PPUSH
82234: CALL_OW 321
82238: PUSH
82239: LD_INT 2
82241: EQUAL
82242: ST_TO_ADDR
82243: GO 82489
82245: LD_INT 30
82247: DOUBLE
82248: EQUAL
82249: IFTRUE 82253
82251: GO 82278
82253: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82254: LD_ADDR_VAR 0 3
82258: PUSH
82259: LD_INT 20
82261: PPUSH
82262: LD_VAR 0 1
82266: PPUSH
82267: CALL_OW 321
82271: PUSH
82272: LD_INT 2
82274: EQUAL
82275: ST_TO_ADDR
82276: GO 82489
82278: LD_INT 28
82280: DOUBLE
82281: EQUAL
82282: IFTRUE 82292
82284: LD_INT 21
82286: DOUBLE
82287: EQUAL
82288: IFTRUE 82292
82290: GO 82317
82292: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82293: LD_ADDR_VAR 0 3
82297: PUSH
82298: LD_INT 21
82300: PPUSH
82301: LD_VAR 0 1
82305: PPUSH
82306: CALL_OW 321
82310: PUSH
82311: LD_INT 2
82313: EQUAL
82314: ST_TO_ADDR
82315: GO 82489
82317: LD_INT 16
82319: DOUBLE
82320: EQUAL
82321: IFTRUE 82325
82323: GO 82350
82325: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82326: LD_ADDR_VAR 0 3
82330: PUSH
82331: LD_INT 84
82333: PPUSH
82334: LD_VAR 0 1
82338: PPUSH
82339: CALL_OW 321
82343: PUSH
82344: LD_INT 2
82346: EQUAL
82347: ST_TO_ADDR
82348: GO 82489
82350: LD_INT 19
82352: DOUBLE
82353: EQUAL
82354: IFTRUE 82364
82356: LD_INT 23
82358: DOUBLE
82359: EQUAL
82360: IFTRUE 82364
82362: GO 82389
82364: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82365: LD_ADDR_VAR 0 3
82369: PUSH
82370: LD_INT 83
82372: PPUSH
82373: LD_VAR 0 1
82377: PPUSH
82378: CALL_OW 321
82382: PUSH
82383: LD_INT 2
82385: EQUAL
82386: ST_TO_ADDR
82387: GO 82489
82389: LD_INT 17
82391: DOUBLE
82392: EQUAL
82393: IFTRUE 82397
82395: GO 82422
82397: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
82398: LD_ADDR_VAR 0 3
82402: PUSH
82403: LD_INT 39
82405: PPUSH
82406: LD_VAR 0 1
82410: PPUSH
82411: CALL_OW 321
82415: PUSH
82416: LD_INT 2
82418: EQUAL
82419: ST_TO_ADDR
82420: GO 82489
82422: LD_INT 18
82424: DOUBLE
82425: EQUAL
82426: IFTRUE 82430
82428: GO 82455
82430: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
82431: LD_ADDR_VAR 0 3
82435: PUSH
82436: LD_INT 40
82438: PPUSH
82439: LD_VAR 0 1
82443: PPUSH
82444: CALL_OW 321
82448: PUSH
82449: LD_INT 2
82451: EQUAL
82452: ST_TO_ADDR
82453: GO 82489
82455: LD_INT 27
82457: DOUBLE
82458: EQUAL
82459: IFTRUE 82463
82461: GO 82488
82463: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
82464: LD_ADDR_VAR 0 3
82468: PUSH
82469: LD_INT 35
82471: PPUSH
82472: LD_VAR 0 1
82476: PPUSH
82477: CALL_OW 321
82481: PUSH
82482: LD_INT 2
82484: EQUAL
82485: ST_TO_ADDR
82486: GO 82489
82488: POP
// end ;
82489: LD_VAR 0 3
82493: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
82494: LD_INT 0
82496: PPUSH
82497: PPUSH
82498: PPUSH
82499: PPUSH
82500: PPUSH
82501: PPUSH
82502: PPUSH
82503: PPUSH
82504: PPUSH
82505: PPUSH
82506: PPUSH
// result := false ;
82507: LD_ADDR_VAR 0 6
82511: PUSH
82512: LD_INT 0
82514: ST_TO_ADDR
// if btype = b_depot then
82515: LD_VAR 0 2
82519: PUSH
82520: LD_INT 0
82522: EQUAL
82523: IFFALSE 82535
// begin result := true ;
82525: LD_ADDR_VAR 0 6
82529: PUSH
82530: LD_INT 1
82532: ST_TO_ADDR
// exit ;
82533: GO 83361
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
82535: LD_VAR 0 1
82539: NOT
82540: PUSH
82541: LD_VAR 0 1
82545: PPUSH
82546: CALL_OW 266
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: IN
82561: NOT
82562: OR
82563: PUSH
82564: LD_VAR 0 2
82568: NOT
82569: OR
82570: PUSH
82571: LD_VAR 0 5
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: LD_INT 1
82581: PUSH
82582: LD_INT 2
82584: PUSH
82585: LD_INT 3
82587: PUSH
82588: LD_INT 4
82590: PUSH
82591: LD_INT 5
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: IN
82602: NOT
82603: OR
82604: PUSH
82605: LD_VAR 0 3
82609: PPUSH
82610: LD_VAR 0 4
82614: PPUSH
82615: CALL_OW 488
82619: NOT
82620: OR
82621: IFFALSE 82625
// exit ;
82623: GO 83361
// side := GetSide ( depot ) ;
82625: LD_ADDR_VAR 0 9
82629: PUSH
82630: LD_VAR 0 1
82634: PPUSH
82635: CALL_OW 255
82639: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
82640: LD_VAR 0 9
82644: PPUSH
82645: LD_VAR 0 2
82649: PPUSH
82650: CALL 82118 0 2
82654: NOT
82655: IFFALSE 82659
// exit ;
82657: GO 83361
// pom := GetBase ( depot ) ;
82659: LD_ADDR_VAR 0 10
82663: PUSH
82664: LD_VAR 0 1
82668: PPUSH
82669: CALL_OW 274
82673: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
82674: LD_ADDR_VAR 0 11
82678: PUSH
82679: LD_VAR 0 2
82683: PPUSH
82684: LD_VAR 0 1
82688: PPUSH
82689: CALL_OW 248
82693: PPUSH
82694: CALL_OW 450
82698: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
82699: LD_VAR 0 10
82703: PPUSH
82704: LD_INT 1
82706: PPUSH
82707: CALL_OW 275
82711: PUSH
82712: LD_VAR 0 11
82716: PUSH
82717: LD_INT 1
82719: ARRAY
82720: GREATEREQUAL
82721: PUSH
82722: LD_VAR 0 10
82726: PPUSH
82727: LD_INT 2
82729: PPUSH
82730: CALL_OW 275
82734: PUSH
82735: LD_VAR 0 11
82739: PUSH
82740: LD_INT 2
82742: ARRAY
82743: GREATEREQUAL
82744: AND
82745: PUSH
82746: LD_VAR 0 10
82750: PPUSH
82751: LD_INT 3
82753: PPUSH
82754: CALL_OW 275
82758: PUSH
82759: LD_VAR 0 11
82763: PUSH
82764: LD_INT 3
82766: ARRAY
82767: GREATEREQUAL
82768: AND
82769: NOT
82770: IFFALSE 82774
// exit ;
82772: GO 83361
// if GetBType ( depot ) = b_depot then
82774: LD_VAR 0 1
82778: PPUSH
82779: CALL_OW 266
82783: PUSH
82784: LD_INT 0
82786: EQUAL
82787: IFFALSE 82799
// dist := 28 else
82789: LD_ADDR_VAR 0 14
82793: PUSH
82794: LD_INT 28
82796: ST_TO_ADDR
82797: GO 82807
// dist := 36 ;
82799: LD_ADDR_VAR 0 14
82803: PUSH
82804: LD_INT 36
82806: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
82807: LD_VAR 0 1
82811: PPUSH
82812: LD_VAR 0 3
82816: PPUSH
82817: LD_VAR 0 4
82821: PPUSH
82822: CALL_OW 297
82826: PUSH
82827: LD_VAR 0 14
82831: GREATER
82832: IFFALSE 82836
// exit ;
82834: GO 83361
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
82836: LD_ADDR_VAR 0 12
82840: PUSH
82841: LD_VAR 0 2
82845: PPUSH
82846: LD_VAR 0 3
82850: PPUSH
82851: LD_VAR 0 4
82855: PPUSH
82856: LD_VAR 0 5
82860: PPUSH
82861: LD_VAR 0 1
82865: PPUSH
82866: CALL_OW 248
82870: PPUSH
82871: LD_INT 0
82873: PPUSH
82874: CALL 83366 0 6
82878: ST_TO_ADDR
// if not hexes then
82879: LD_VAR 0 12
82883: NOT
82884: IFFALSE 82888
// exit ;
82886: GO 83361
// hex := GetHexInfo ( x , y ) ;
82888: LD_ADDR_VAR 0 15
82892: PUSH
82893: LD_VAR 0 3
82897: PPUSH
82898: LD_VAR 0 4
82902: PPUSH
82903: CALL_OW 546
82907: ST_TO_ADDR
// if hex [ 1 ] then
82908: LD_VAR 0 15
82912: PUSH
82913: LD_INT 1
82915: ARRAY
82916: IFFALSE 82920
// exit ;
82918: GO 83361
// height := hex [ 2 ] ;
82920: LD_ADDR_VAR 0 13
82924: PUSH
82925: LD_VAR 0 15
82929: PUSH
82930: LD_INT 2
82932: ARRAY
82933: ST_TO_ADDR
// for i = 1 to hexes do
82934: LD_ADDR_VAR 0 7
82938: PUSH
82939: DOUBLE
82940: LD_INT 1
82942: DEC
82943: ST_TO_ADDR
82944: LD_VAR 0 12
82948: PUSH
82949: FOR_TO
82950: IFFALSE 83280
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
82952: LD_VAR 0 12
82956: PUSH
82957: LD_VAR 0 7
82961: ARRAY
82962: PUSH
82963: LD_INT 1
82965: ARRAY
82966: PPUSH
82967: LD_VAR 0 12
82971: PUSH
82972: LD_VAR 0 7
82976: ARRAY
82977: PUSH
82978: LD_INT 2
82980: ARRAY
82981: PPUSH
82982: CALL_OW 488
82986: NOT
82987: PUSH
82988: LD_VAR 0 12
82992: PUSH
82993: LD_VAR 0 7
82997: ARRAY
82998: PUSH
82999: LD_INT 1
83001: ARRAY
83002: PPUSH
83003: LD_VAR 0 12
83007: PUSH
83008: LD_VAR 0 7
83012: ARRAY
83013: PUSH
83014: LD_INT 2
83016: ARRAY
83017: PPUSH
83018: CALL_OW 428
83022: PUSH
83023: LD_INT 0
83025: GREATER
83026: OR
83027: PUSH
83028: LD_VAR 0 12
83032: PUSH
83033: LD_VAR 0 7
83037: ARRAY
83038: PUSH
83039: LD_INT 1
83041: ARRAY
83042: PPUSH
83043: LD_VAR 0 12
83047: PUSH
83048: LD_VAR 0 7
83052: ARRAY
83053: PUSH
83054: LD_INT 2
83056: ARRAY
83057: PPUSH
83058: CALL_OW 351
83062: OR
83063: IFFALSE 83069
// exit ;
83065: POP
83066: POP
83067: GO 83361
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83069: LD_ADDR_VAR 0 8
83073: PUSH
83074: LD_VAR 0 12
83078: PUSH
83079: LD_VAR 0 7
83083: ARRAY
83084: PUSH
83085: LD_INT 1
83087: ARRAY
83088: PPUSH
83089: LD_VAR 0 12
83093: PUSH
83094: LD_VAR 0 7
83098: ARRAY
83099: PUSH
83100: LD_INT 2
83102: ARRAY
83103: PPUSH
83104: CALL_OW 546
83108: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83109: LD_VAR 0 8
83113: PUSH
83114: LD_INT 1
83116: ARRAY
83117: PUSH
83118: LD_VAR 0 8
83122: PUSH
83123: LD_INT 2
83125: ARRAY
83126: PUSH
83127: LD_VAR 0 13
83131: PUSH
83132: LD_INT 2
83134: PLUS
83135: GREATER
83136: OR
83137: PUSH
83138: LD_VAR 0 8
83142: PUSH
83143: LD_INT 2
83145: ARRAY
83146: PUSH
83147: LD_VAR 0 13
83151: PUSH
83152: LD_INT 2
83154: MINUS
83155: LESS
83156: OR
83157: PUSH
83158: LD_VAR 0 8
83162: PUSH
83163: LD_INT 3
83165: ARRAY
83166: PUSH
83167: LD_INT 0
83169: PUSH
83170: LD_INT 8
83172: PUSH
83173: LD_INT 9
83175: PUSH
83176: LD_INT 10
83178: PUSH
83179: LD_INT 11
83181: PUSH
83182: LD_INT 12
83184: PUSH
83185: LD_INT 13
83187: PUSH
83188: LD_INT 16
83190: PUSH
83191: LD_INT 17
83193: PUSH
83194: LD_INT 18
83196: PUSH
83197: LD_INT 19
83199: PUSH
83200: LD_INT 20
83202: PUSH
83203: LD_INT 21
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: LIST
83210: LIST
83211: LIST
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: IN
83221: NOT
83222: OR
83223: PUSH
83224: LD_VAR 0 8
83228: PUSH
83229: LD_INT 5
83231: ARRAY
83232: NOT
83233: OR
83234: PUSH
83235: LD_VAR 0 8
83239: PUSH
83240: LD_INT 6
83242: ARRAY
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: LD_INT 2
83249: PUSH
83250: LD_INT 7
83252: PUSH
83253: LD_INT 9
83255: PUSH
83256: LD_INT 10
83258: PUSH
83259: LD_INT 11
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: IN
83270: NOT
83271: OR
83272: IFFALSE 83278
// exit ;
83274: POP
83275: POP
83276: GO 83361
// end ;
83278: GO 82949
83280: POP
83281: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83282: LD_VAR 0 9
83286: PPUSH
83287: LD_VAR 0 3
83291: PPUSH
83292: LD_VAR 0 4
83296: PPUSH
83297: LD_INT 20
83299: PPUSH
83300: CALL 75284 0 4
83304: PUSH
83305: LD_INT 4
83307: ARRAY
83308: IFFALSE 83312
// exit ;
83310: GO 83361
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83312: LD_VAR 0 2
83316: PUSH
83317: LD_INT 29
83319: PUSH
83320: LD_INT 30
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: IN
83327: PUSH
83328: LD_VAR 0 3
83332: PPUSH
83333: LD_VAR 0 4
83337: PPUSH
83338: LD_VAR 0 9
83342: PPUSH
83343: CALL_OW 440
83347: NOT
83348: AND
83349: IFFALSE 83353
// exit ;
83351: GO 83361
// result := true ;
83353: LD_ADDR_VAR 0 6
83357: PUSH
83358: LD_INT 1
83360: ST_TO_ADDR
// end ;
83361: LD_VAR 0 6
83365: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83366: LD_INT 0
83368: PPUSH
83369: PPUSH
83370: PPUSH
83371: PPUSH
83372: PPUSH
83373: PPUSH
83374: PPUSH
83375: PPUSH
83376: PPUSH
83377: PPUSH
83378: PPUSH
83379: PPUSH
83380: PPUSH
83381: PPUSH
83382: PPUSH
83383: PPUSH
83384: PPUSH
83385: PPUSH
83386: PPUSH
83387: PPUSH
83388: PPUSH
83389: PPUSH
83390: PPUSH
83391: PPUSH
83392: PPUSH
83393: PPUSH
83394: PPUSH
83395: PPUSH
83396: PPUSH
83397: PPUSH
83398: PPUSH
83399: PPUSH
83400: PPUSH
83401: PPUSH
83402: PPUSH
83403: PPUSH
83404: PPUSH
83405: PPUSH
83406: PPUSH
83407: PPUSH
83408: PPUSH
83409: PPUSH
83410: PPUSH
83411: PPUSH
83412: PPUSH
83413: PPUSH
83414: PPUSH
83415: PPUSH
83416: PPUSH
83417: PPUSH
83418: PPUSH
83419: PPUSH
83420: PPUSH
83421: PPUSH
83422: PPUSH
83423: PPUSH
83424: PPUSH
83425: PPUSH
// result = [ ] ;
83426: LD_ADDR_VAR 0 7
83430: PUSH
83431: EMPTY
83432: ST_TO_ADDR
// temp_list = [ ] ;
83433: LD_ADDR_VAR 0 9
83437: PUSH
83438: EMPTY
83439: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
83440: LD_VAR 0 4
83444: PUSH
83445: LD_INT 0
83447: PUSH
83448: LD_INT 1
83450: PUSH
83451: LD_INT 2
83453: PUSH
83454: LD_INT 3
83456: PUSH
83457: LD_INT 4
83459: PUSH
83460: LD_INT 5
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: IN
83471: NOT
83472: PUSH
83473: LD_VAR 0 1
83477: PUSH
83478: LD_INT 0
83480: PUSH
83481: LD_INT 1
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: IN
83488: PUSH
83489: LD_VAR 0 5
83493: PUSH
83494: LD_INT 1
83496: PUSH
83497: LD_INT 2
83499: PUSH
83500: LD_INT 3
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: LIST
83507: IN
83508: NOT
83509: AND
83510: OR
83511: IFFALSE 83515
// exit ;
83513: GO 101906
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
83515: LD_VAR 0 1
83519: PUSH
83520: LD_INT 6
83522: PUSH
83523: LD_INT 7
83525: PUSH
83526: LD_INT 8
83528: PUSH
83529: LD_INT 13
83531: PUSH
83532: LD_INT 12
83534: PUSH
83535: LD_INT 15
83537: PUSH
83538: LD_INT 11
83540: PUSH
83541: LD_INT 14
83543: PUSH
83544: LD_INT 10
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: IN
83558: IFFALSE 83568
// btype = b_lab ;
83560: LD_ADDR_VAR 0 1
83564: PUSH
83565: LD_INT 6
83567: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
83568: LD_VAR 0 6
83572: PUSH
83573: LD_INT 0
83575: PUSH
83576: LD_INT 1
83578: PUSH
83579: LD_INT 2
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: LIST
83586: IN
83587: NOT
83588: PUSH
83589: LD_VAR 0 1
83593: PUSH
83594: LD_INT 0
83596: PUSH
83597: LD_INT 1
83599: PUSH
83600: LD_INT 2
83602: PUSH
83603: LD_INT 3
83605: PUSH
83606: LD_INT 6
83608: PUSH
83609: LD_INT 36
83611: PUSH
83612: LD_INT 4
83614: PUSH
83615: LD_INT 5
83617: PUSH
83618: LD_INT 31
83620: PUSH
83621: LD_INT 32
83623: PUSH
83624: LD_INT 33
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: IN
83640: NOT
83641: PUSH
83642: LD_VAR 0 6
83646: PUSH
83647: LD_INT 1
83649: EQUAL
83650: AND
83651: OR
83652: PUSH
83653: LD_VAR 0 1
83657: PUSH
83658: LD_INT 2
83660: PUSH
83661: LD_INT 3
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: IN
83668: NOT
83669: PUSH
83670: LD_VAR 0 6
83674: PUSH
83675: LD_INT 2
83677: EQUAL
83678: AND
83679: OR
83680: IFFALSE 83690
// mode = 0 ;
83682: LD_ADDR_VAR 0 6
83686: PUSH
83687: LD_INT 0
83689: ST_TO_ADDR
// case mode of 0 :
83690: LD_VAR 0 6
83694: PUSH
83695: LD_INT 0
83697: DOUBLE
83698: EQUAL
83699: IFTRUE 83703
83701: GO 95156
83703: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83704: LD_ADDR_VAR 0 11
83708: PUSH
83709: LD_INT 0
83711: PUSH
83712: LD_INT 0
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 0
83721: PUSH
83722: LD_INT 1
83724: NEG
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 0
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 1
83742: PUSH
83743: LD_INT 1
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 0
83752: PUSH
83753: LD_INT 1
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 1
83762: NEG
83763: PUSH
83764: LD_INT 0
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 1
83773: NEG
83774: PUSH
83775: LD_INT 1
83777: NEG
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 1
83785: NEG
83786: PUSH
83787: LD_INT 2
83789: NEG
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: LD_INT 0
83797: PUSH
83798: LD_INT 2
83800: NEG
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: PUSH
83806: LD_INT 1
83808: PUSH
83809: LD_INT 1
83811: NEG
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: LD_INT 2
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 2
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 1
83839: NEG
83840: PUSH
83841: LD_INT 1
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 3
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 3
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 2
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83897: LD_ADDR_VAR 0 12
83901: PUSH
83902: LD_INT 0
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 1
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 1
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 0
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 1
83955: NEG
83956: PUSH
83957: LD_INT 0
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 1
83966: NEG
83967: PUSH
83968: LD_INT 1
83970: NEG
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: LD_INT 1
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 2
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 2
83999: PUSH
84000: LD_INT 1
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 1
84009: NEG
84010: PUSH
84011: LD_INT 1
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 2
84020: NEG
84021: PUSH
84022: LD_INT 0
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 2
84031: NEG
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 2
84043: NEG
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 3
84054: NEG
84055: PUSH
84056: LD_INT 0
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 3
84065: NEG
84066: PUSH
84067: LD_INT 1
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84093: LD_ADDR_VAR 0 13
84097: PUSH
84098: LD_INT 0
84100: PUSH
84101: LD_INT 0
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 0
84110: PUSH
84111: LD_INT 1
84113: NEG
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 1
84121: PUSH
84122: LD_INT 0
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: LD_INT 1
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 1
84162: NEG
84163: PUSH
84164: LD_INT 1
84166: NEG
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 1
84174: NEG
84175: PUSH
84176: LD_INT 2
84178: NEG
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 2
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 2
84196: PUSH
84197: LD_INT 2
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 1
84206: PUSH
84207: LD_INT 2
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 2
84216: NEG
84217: PUSH
84218: LD_INT 1
84220: NEG
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 2
84228: NEG
84229: PUSH
84230: LD_INT 2
84232: NEG
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: PUSH
84238: LD_INT 2
84240: NEG
84241: PUSH
84242: LD_INT 3
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 3
84252: NEG
84253: PUSH
84254: LD_INT 2
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 3
84264: NEG
84265: PUSH
84266: LD_INT 3
84268: NEG
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: EMPTY
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84292: LD_ADDR_VAR 0 14
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: LD_INT 0
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 0
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 1
84320: PUSH
84321: LD_INT 0
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 1
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: LD_INT 0
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: EMPTY
84368: LIST
84369: LIST
84370: PUSH
84371: LD_INT 1
84373: NEG
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 0
84385: PUSH
84386: LD_INT 2
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 1
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: PUSH
84408: LD_INT 2
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: LD_INT 2
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 1
84427: NEG
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 1
84438: NEG
84439: PUSH
84440: LD_INT 3
84442: NEG
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 0
84450: PUSH
84451: LD_INT 3
84453: NEG
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 1
84461: PUSH
84462: LD_INT 2
84464: NEG
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: LIST
84479: LIST
84480: LIST
84481: LIST
84482: LIST
84483: LIST
84484: LIST
84485: LIST
84486: LIST
84487: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
84488: LD_ADDR_VAR 0 15
84492: PUSH
84493: LD_INT 0
84495: PUSH
84496: LD_INT 0
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 0
84505: PUSH
84506: LD_INT 1
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 1
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 1
84526: PUSH
84527: LD_INT 1
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: LD_INT 1
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 1
84546: NEG
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 1
84557: NEG
84558: PUSH
84559: LD_INT 1
84561: NEG
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 1
84569: PUSH
84570: LD_INT 1
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 2
84580: PUSH
84581: LD_INT 0
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: LD_INT 2
84590: PUSH
84591: LD_INT 1
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: LD_INT 1
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: PUSH
84609: LD_INT 2
84611: NEG
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: EMPTY
84617: LIST
84618: LIST
84619: PUSH
84620: LD_INT 2
84622: NEG
84623: PUSH
84624: LD_INT 1
84626: NEG
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: LD_INT 1
84637: NEG
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: PUSH
84643: LD_INT 3
84645: PUSH
84646: LD_INT 0
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 3
84655: PUSH
84656: LD_INT 1
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
84681: LD_ADDR_VAR 0 16
84685: PUSH
84686: LD_INT 0
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: PUSH
84720: LD_INT 1
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PUSH
84727: LD_INT 0
84729: PUSH
84730: LD_INT 1
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 1
84739: NEG
84740: PUSH
84741: LD_INT 0
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 1
84750: NEG
84751: PUSH
84752: LD_INT 1
84754: NEG
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: PUSH
84760: LD_INT 1
84762: NEG
84763: PUSH
84764: LD_INT 2
84766: NEG
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 2
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 2
84784: PUSH
84785: LD_INT 2
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: LD_INT 2
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 2
84804: NEG
84805: PUSH
84806: LD_INT 1
84808: NEG
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 2
84816: NEG
84817: PUSH
84818: LD_INT 2
84820: NEG
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 3
84828: PUSH
84829: LD_INT 2
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 3
84838: PUSH
84839: LD_INT 3
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 2
84848: PUSH
84849: LD_INT 3
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84874: LD_ADDR_VAR 0 17
84878: PUSH
84879: LD_INT 0
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: LD_INT 0
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 1
84912: PUSH
84913: LD_INT 1
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 0
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: LD_INT 0
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: PUSH
84941: LD_INT 1
84943: NEG
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 1
84955: NEG
84956: PUSH
84957: LD_INT 2
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 0
84967: PUSH
84968: LD_INT 2
84970: NEG
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 1
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 2
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 2
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 2
85009: PUSH
85010: LD_INT 2
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: PUSH
85020: LD_INT 2
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 0
85029: PUSH
85030: LD_INT 2
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: LD_INT 1
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 2
85050: NEG
85051: PUSH
85052: LD_INT 0
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 2
85061: NEG
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 2
85073: NEG
85074: PUSH
85075: LD_INT 2
85077: NEG
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85104: LD_ADDR_VAR 0 18
85108: PUSH
85109: LD_INT 0
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 1
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: LD_INT 1
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 0
85152: PUSH
85153: LD_INT 1
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: NEG
85163: PUSH
85164: LD_INT 0
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 1
85173: NEG
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 1
85185: NEG
85186: PUSH
85187: LD_INT 2
85189: NEG
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 0
85197: PUSH
85198: LD_INT 2
85200: NEG
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 1
85208: PUSH
85209: LD_INT 1
85211: NEG
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 2
85219: PUSH
85220: LD_INT 0
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 2
85229: PUSH
85230: LD_INT 1
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 2
85239: PUSH
85240: LD_INT 2
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 1
85249: PUSH
85250: LD_INT 2
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 2
85280: NEG
85281: PUSH
85282: LD_INT 0
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 2
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 2
85303: NEG
85304: PUSH
85305: LD_INT 2
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85334: LD_ADDR_VAR 0 19
85338: PUSH
85339: LD_INT 0
85341: PUSH
85342: LD_INT 0
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 0
85351: PUSH
85352: LD_INT 1
85354: NEG
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 1
85362: PUSH
85363: LD_INT 0
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 1
85372: PUSH
85373: LD_INT 1
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 0
85382: PUSH
85383: LD_INT 1
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 1
85392: NEG
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 1
85403: NEG
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: PUSH
85413: LD_INT 1
85415: NEG
85416: PUSH
85417: LD_INT 2
85419: NEG
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: PUSH
85425: LD_INT 0
85427: PUSH
85428: LD_INT 2
85430: NEG
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 1
85438: PUSH
85439: LD_INT 1
85441: NEG
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 2
85449: PUSH
85450: LD_INT 0
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 2
85459: PUSH
85460: LD_INT 1
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 2
85469: PUSH
85470: LD_INT 2
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 1
85479: PUSH
85480: LD_INT 2
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: PUSH
85487: LD_INT 0
85489: PUSH
85490: LD_INT 2
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 1
85499: NEG
85500: PUSH
85501: LD_INT 1
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 2
85510: NEG
85511: PUSH
85512: LD_INT 0
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: PUSH
85519: LD_INT 2
85521: NEG
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 2
85533: NEG
85534: PUSH
85535: LD_INT 2
85537: NEG
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85564: LD_ADDR_VAR 0 20
85568: PUSH
85569: LD_INT 0
85571: PUSH
85572: LD_INT 0
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 0
85581: PUSH
85582: LD_INT 1
85584: NEG
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: LD_INT 0
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 1
85602: PUSH
85603: LD_INT 1
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 0
85612: PUSH
85613: LD_INT 1
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 1
85622: NEG
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 1
85633: NEG
85634: PUSH
85635: LD_INT 1
85637: NEG
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 1
85645: NEG
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: LD_INT 2
85660: NEG
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: PUSH
85666: LD_INT 1
85668: PUSH
85669: LD_INT 1
85671: NEG
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 2
85679: PUSH
85680: LD_INT 0
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 2
85689: PUSH
85690: LD_INT 1
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: PUSH
85697: LD_INT 2
85699: PUSH
85700: LD_INT 2
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: PUSH
85707: LD_INT 1
85709: PUSH
85710: LD_INT 2
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 2
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 1
85729: NEG
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 2
85740: NEG
85741: PUSH
85742: LD_INT 0
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 2
85751: NEG
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 2
85763: NEG
85764: PUSH
85765: LD_INT 2
85767: NEG
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85794: LD_ADDR_VAR 0 21
85798: PUSH
85799: LD_INT 0
85801: PUSH
85802: LD_INT 0
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 1
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: PUSH
85823: LD_INT 0
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: LD_INT 1
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: LD_INT 1
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: LD_INT 0
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: LD_INT 1
85867: NEG
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 1
85875: NEG
85876: PUSH
85877: LD_INT 2
85879: NEG
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 0
85887: PUSH
85888: LD_INT 2
85890: NEG
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 1
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 2
85909: PUSH
85910: LD_INT 0
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 2
85919: PUSH
85920: LD_INT 1
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 2
85929: PUSH
85930: LD_INT 2
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: LD_INT 2
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 0
85949: PUSH
85950: LD_INT 2
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: LD_INT 1
85959: NEG
85960: PUSH
85961: LD_INT 1
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 2
85970: NEG
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 2
85981: NEG
85982: PUSH
85983: LD_INT 1
85985: NEG
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 2
85993: NEG
85994: PUSH
85995: LD_INT 2
85997: NEG
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: LIST
86022: LIST
86023: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86024: LD_ADDR_VAR 0 22
86028: PUSH
86029: LD_INT 0
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 0
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: PUSH
86053: LD_INT 0
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 1
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 0
86072: PUSH
86073: LD_INT 1
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 1
86082: NEG
86083: PUSH
86084: LD_INT 0
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: LD_INT 1
86093: NEG
86094: PUSH
86095: LD_INT 1
86097: NEG
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: LD_INT 2
86109: NEG
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: LD_INT 2
86120: NEG
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 1
86128: PUSH
86129: LD_INT 1
86131: NEG
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 2
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 2
86149: PUSH
86150: LD_INT 1
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 2
86159: PUSH
86160: LD_INT 2
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 1
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 0
86179: PUSH
86180: LD_INT 2
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 1
86189: NEG
86190: PUSH
86191: LD_INT 1
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 2
86200: NEG
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 2
86211: NEG
86212: PUSH
86213: LD_INT 1
86215: NEG
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 2
86223: NEG
86224: PUSH
86225: LD_INT 2
86227: NEG
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86254: LD_ADDR_VAR 0 23
86258: PUSH
86259: LD_INT 0
86261: PUSH
86262: LD_INT 0
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: LD_INT 1
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 0
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PUSH
86290: LD_INT 1
86292: PUSH
86293: LD_INT 1
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 0
86302: PUSH
86303: LD_INT 1
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 1
86312: NEG
86313: PUSH
86314: LD_INT 0
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 1
86323: NEG
86324: PUSH
86325: LD_INT 1
86327: NEG
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 1
86335: NEG
86336: PUSH
86337: LD_INT 2
86339: NEG
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: LD_INT 2
86350: NEG
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_INT 1
86358: PUSH
86359: LD_INT 1
86361: NEG
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 2
86369: PUSH
86370: LD_INT 0
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 2
86379: PUSH
86380: LD_INT 1
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 2
86389: PUSH
86390: LD_INT 2
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 1
86399: PUSH
86400: LD_INT 2
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: PUSH
86407: LD_INT 0
86409: PUSH
86410: LD_INT 2
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 1
86419: NEG
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 2
86430: NEG
86431: PUSH
86432: LD_INT 0
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 2
86441: NEG
86442: PUSH
86443: LD_INT 1
86445: NEG
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 2
86453: NEG
86454: PUSH
86455: LD_INT 2
86457: NEG
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PUSH
86463: LD_INT 2
86465: NEG
86466: PUSH
86467: LD_INT 3
86469: NEG
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: LD_INT 3
86481: NEG
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: PUSH
86490: LD_INT 2
86492: NEG
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 2
86500: PUSH
86501: LD_INT 1
86503: NEG
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
86534: LD_ADDR_VAR 0 24
86538: PUSH
86539: LD_INT 0
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 0
86551: PUSH
86552: LD_INT 1
86554: NEG
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 1
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 1
86572: PUSH
86573: LD_INT 1
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 0
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 1
86592: NEG
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: EMPTY
86598: LIST
86599: LIST
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: LD_INT 1
86607: NEG
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 1
86615: NEG
86616: PUSH
86617: LD_INT 2
86619: NEG
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 0
86627: PUSH
86628: LD_INT 2
86630: NEG
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 1
86638: PUSH
86639: LD_INT 1
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 2
86649: PUSH
86650: LD_INT 0
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: LD_INT 2
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: LD_INT 2
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: NEG
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: NEG
86711: PUSH
86712: LD_INT 0
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 2
86721: NEG
86722: PUSH
86723: LD_INT 1
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 2
86733: NEG
86734: PUSH
86735: LD_INT 2
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 1
86745: PUSH
86746: LD_INT 2
86748: NEG
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: PUSH
86757: LD_INT 1
86759: NEG
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: PUSH
86765: LD_INT 3
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 3
86777: PUSH
86778: LD_INT 2
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
86810: LD_ADDR_VAR 0 25
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 0
86827: PUSH
86828: LD_INT 1
86830: NEG
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 1
86838: PUSH
86839: LD_INT 0
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 1
86848: PUSH
86849: LD_INT 1
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 0
86858: PUSH
86859: LD_INT 1
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: NEG
86869: PUSH
86870: LD_INT 0
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 1
86879: NEG
86880: PUSH
86881: LD_INT 1
86883: NEG
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: PUSH
86889: LD_INT 1
86891: NEG
86892: PUSH
86893: LD_INT 2
86895: NEG
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 0
86903: PUSH
86904: LD_INT 2
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 1
86914: PUSH
86915: LD_INT 1
86917: NEG
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 2
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 2
86935: PUSH
86936: LD_INT 1
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 2
86945: PUSH
86946: LD_INT 2
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: LD_INT 2
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 0
86965: PUSH
86966: LD_INT 2
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: NEG
86976: PUSH
86977: LD_INT 1
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 2
86986: NEG
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 2
86997: NEG
86998: PUSH
86999: LD_INT 1
87001: NEG
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 2
87009: NEG
87010: PUSH
87011: LD_INT 2
87013: NEG
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 3
87021: PUSH
87022: LD_INT 1
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 3
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 2
87041: PUSH
87042: LD_INT 3
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 1
87051: PUSH
87052: LD_INT 3
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87084: LD_ADDR_VAR 0 26
87088: PUSH
87089: LD_INT 0
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 0
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 1
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: LD_INT 1
87157: NEG
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 1
87165: NEG
87166: PUSH
87167: LD_INT 2
87169: NEG
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: LD_INT 2
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 1
87188: PUSH
87189: LD_INT 1
87191: NEG
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 2
87199: PUSH
87200: LD_INT 0
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 2
87209: PUSH
87210: LD_INT 1
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: PUSH
87217: LD_INT 2
87219: PUSH
87220: LD_INT 2
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 1
87229: PUSH
87230: LD_INT 2
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 0
87239: PUSH
87240: LD_INT 2
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: LD_INT 1
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 2
87260: NEG
87261: PUSH
87262: LD_INT 0
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 2
87271: NEG
87272: PUSH
87273: LD_INT 1
87275: NEG
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 2
87283: NEG
87284: PUSH
87285: LD_INT 2
87287: NEG
87288: PUSH
87289: EMPTY
87290: LIST
87291: LIST
87292: PUSH
87293: LD_INT 2
87295: PUSH
87296: LD_INT 3
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: LD_INT 1
87305: PUSH
87306: LD_INT 3
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 1
87315: NEG
87316: PUSH
87317: LD_INT 2
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 2
87326: NEG
87327: PUSH
87328: LD_INT 1
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87360: LD_ADDR_VAR 0 27
87364: PUSH
87365: LD_INT 0
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: LD_INT 1
87380: NEG
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: LD_INT 0
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: LD_INT 1
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: LD_INT 1
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: LD_INT 1
87433: NEG
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: PUSH
87443: LD_INT 2
87445: NEG
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 0
87453: PUSH
87454: LD_INT 2
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 1
87464: PUSH
87465: LD_INT 1
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 2
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 2
87485: PUSH
87486: LD_INT 1
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 2
87495: PUSH
87496: LD_INT 2
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 1
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: LD_INT 1
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 2
87536: NEG
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: NEG
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 2
87559: NEG
87560: PUSH
87561: LD_INT 2
87563: NEG
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 1
87571: NEG
87572: PUSH
87573: LD_INT 2
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 2
87582: NEG
87583: PUSH
87584: LD_INT 1
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 3
87593: NEG
87594: PUSH
87595: LD_INT 1
87597: NEG
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 3
87605: NEG
87606: PUSH
87607: LD_INT 2
87609: NEG
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87640: LD_ADDR_VAR 0 28
87644: PUSH
87645: LD_INT 0
87647: PUSH
87648: LD_INT 0
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 0
87657: PUSH
87658: LD_INT 1
87660: NEG
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 1
87668: PUSH
87669: LD_INT 0
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 1
87678: PUSH
87679: LD_INT 1
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 0
87688: PUSH
87689: LD_INT 1
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 1
87698: NEG
87699: PUSH
87700: LD_INT 0
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 1
87709: NEG
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 1
87721: NEG
87722: PUSH
87723: LD_INT 2
87725: NEG
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 0
87733: PUSH
87734: LD_INT 2
87736: NEG
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 1
87744: PUSH
87745: LD_INT 1
87747: NEG
87748: PUSH
87749: EMPTY
87750: LIST
87751: LIST
87752: PUSH
87753: LD_INT 2
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 2
87765: PUSH
87766: LD_INT 1
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 2
87775: PUSH
87776: LD_INT 2
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 1
87785: PUSH
87786: LD_INT 2
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: LD_INT 2
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 1
87805: NEG
87806: PUSH
87807: LD_INT 1
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 2
87816: NEG
87817: PUSH
87818: LD_INT 0
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 2
87827: NEG
87828: PUSH
87829: LD_INT 1
87831: NEG
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: LD_INT 2
87839: NEG
87840: PUSH
87841: LD_INT 2
87843: NEG
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 2
87851: NEG
87852: PUSH
87853: LD_INT 3
87855: NEG
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: NEG
87864: PUSH
87865: LD_INT 3
87867: NEG
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 3
87875: NEG
87876: PUSH
87877: LD_INT 1
87879: NEG
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PUSH
87885: LD_INT 3
87887: NEG
87888: PUSH
87889: LD_INT 2
87891: NEG
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87922: LD_ADDR_VAR 0 29
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: LD_INT 0
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 0
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 1
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: LD_INT 1
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: NEG
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 1
87991: NEG
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 1
88003: NEG
88004: PUSH
88005: LD_INT 2
88007: NEG
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 2
88018: NEG
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 1
88026: PUSH
88027: LD_INT 1
88029: NEG
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 2
88037: PUSH
88038: LD_INT 0
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 2
88047: PUSH
88048: LD_INT 1
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 1
88057: PUSH
88058: LD_INT 2
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 0
88067: PUSH
88068: LD_INT 2
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 1
88077: NEG
88078: PUSH
88079: LD_INT 1
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: LD_INT 2
88088: NEG
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 2
88100: NEG
88101: PUSH
88102: LD_INT 2
88104: NEG
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 2
88112: NEG
88113: PUSH
88114: LD_INT 3
88116: NEG
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 2
88124: PUSH
88125: LD_INT 1
88127: NEG
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 3
88135: PUSH
88136: LD_INT 1
88138: PUSH
88139: EMPTY
88140: LIST
88141: LIST
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: LD_INT 3
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: NEG
88156: PUSH
88157: LD_INT 2
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 3
88166: NEG
88167: PUSH
88168: LD_INT 2
88170: NEG
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88201: LD_ADDR_VAR 0 30
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: LD_INT 0
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 0
88218: PUSH
88219: LD_INT 1
88221: NEG
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 1
88229: PUSH
88230: LD_INT 0
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 1
88239: PUSH
88240: LD_INT 1
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 0
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: LD_INT 0
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 1
88270: NEG
88271: PUSH
88272: LD_INT 1
88274: NEG
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 1
88282: NEG
88283: PUSH
88284: LD_INT 2
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 0
88294: PUSH
88295: LD_INT 2
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: PUSH
88306: LD_INT 1
88308: NEG
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 2
88316: PUSH
88317: LD_INT 0
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 2
88326: PUSH
88327: LD_INT 1
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 2
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: LD_INT 2
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: LD_INT 1
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 2
88367: NEG
88368: PUSH
88369: LD_INT 0
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 2
88378: NEG
88379: PUSH
88380: LD_INT 1
88382: NEG
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 1
88390: NEG
88391: PUSH
88392: LD_INT 3
88394: NEG
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: PUSH
88403: LD_INT 2
88405: NEG
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 3
88413: PUSH
88414: LD_INT 2
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 3
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 2
88433: NEG
88434: PUSH
88435: LD_INT 1
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 3
88444: NEG
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88479: LD_ADDR_VAR 0 31
88483: PUSH
88484: LD_INT 0
88486: PUSH
88487: LD_INT 0
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 0
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: LD_INT 0
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 1
88517: PUSH
88518: LD_INT 1
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: PUSH
88525: LD_INT 0
88527: PUSH
88528: LD_INT 1
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 1
88537: NEG
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: LD_INT 1
88552: NEG
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: NEG
88561: PUSH
88562: LD_INT 2
88564: NEG
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: PUSH
88573: LD_INT 1
88575: NEG
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 2
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: PUSH
88591: LD_INT 2
88593: PUSH
88594: LD_INT 1
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 2
88603: PUSH
88604: LD_INT 2
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 1
88613: PUSH
88614: LD_INT 2
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 0
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: LD_INT 1
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PUSH
88642: LD_INT 2
88644: NEG
88645: PUSH
88646: LD_INT 1
88648: NEG
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 2
88656: NEG
88657: PUSH
88658: LD_INT 2
88660: NEG
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 2
88668: NEG
88669: PUSH
88670: LD_INT 3
88672: NEG
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 2
88680: PUSH
88681: LD_INT 1
88683: NEG
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 3
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 1
88701: PUSH
88702: LD_INT 3
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: NEG
88712: PUSH
88713: LD_INT 2
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 3
88722: NEG
88723: PUSH
88724: LD_INT 2
88726: NEG
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88757: LD_ADDR_VAR 0 32
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: LD_INT 1
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: LD_INT 1
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: LD_INT 1
88830: NEG
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 1
88838: NEG
88839: PUSH
88840: LD_INT 2
88842: NEG
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: LD_INT 2
88853: NEG
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 1
88861: PUSH
88862: LD_INT 1
88864: NEG
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: LD_INT 2
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 2
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 0
88902: PUSH
88903: LD_INT 2
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 1
88912: NEG
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_INT 2
88923: NEG
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 2
88934: NEG
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: LD_INT 3
88950: NEG
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 2
88961: NEG
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 3
88969: PUSH
88970: LD_INT 2
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 2
88979: PUSH
88980: LD_INT 3
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: NEG
88990: PUSH
88991: LD_INT 1
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 3
89000: NEG
89001: PUSH
89002: LD_INT 1
89004: NEG
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89035: LD_ADDR_VAR 0 33
89039: PUSH
89040: LD_INT 0
89042: PUSH
89043: LD_INT 0
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: LD_INT 1
89055: NEG
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 1
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: LD_INT 1
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 0
89083: PUSH
89084: LD_INT 1
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 1
89093: NEG
89094: PUSH
89095: LD_INT 0
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 1
89104: NEG
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: PUSH
89114: LD_INT 1
89116: NEG
89117: PUSH
89118: LD_INT 2
89120: NEG
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: LD_INT 1
89131: NEG
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 2
89139: PUSH
89140: LD_INT 0
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 2
89149: PUSH
89150: LD_INT 1
89152: PUSH
89153: EMPTY
89154: LIST
89155: LIST
89156: PUSH
89157: LD_INT 1
89159: PUSH
89160: LD_INT 2
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 0
89169: PUSH
89170: LD_INT 2
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 1
89179: NEG
89180: PUSH
89181: LD_INT 1
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 2
89190: NEG
89191: PUSH
89192: LD_INT 0
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 2
89201: NEG
89202: PUSH
89203: LD_INT 1
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 2
89213: NEG
89214: PUSH
89215: LD_INT 2
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 2
89225: NEG
89226: PUSH
89227: LD_INT 3
89229: NEG
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 2
89237: PUSH
89238: LD_INT 1
89240: NEG
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: PUSH
89246: LD_INT 3
89248: PUSH
89249: LD_INT 1
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: PUSH
89256: LD_INT 1
89258: PUSH
89259: LD_INT 3
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: LD_INT 1
89268: NEG
89269: PUSH
89270: LD_INT 2
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 3
89279: NEG
89280: PUSH
89281: LD_INT 2
89283: NEG
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89314: LD_ADDR_VAR 0 34
89318: PUSH
89319: LD_INT 0
89321: PUSH
89322: LD_INT 0
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 0
89331: PUSH
89332: LD_INT 1
89334: NEG
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 0
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 1
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 0
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 1
89372: NEG
89373: PUSH
89374: LD_INT 0
89376: PUSH
89377: EMPTY
89378: LIST
89379: LIST
89380: PUSH
89381: LD_INT 1
89383: NEG
89384: PUSH
89385: LD_INT 1
89387: NEG
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 1
89395: NEG
89396: PUSH
89397: LD_INT 2
89399: NEG
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 0
89407: PUSH
89408: LD_INT 2
89410: NEG
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: PUSH
89416: LD_INT 1
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: PUSH
89427: LD_INT 2
89429: PUSH
89430: LD_INT 1
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 2
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: LD_INT 2
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 1
89459: NEG
89460: PUSH
89461: LD_INT 1
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 2
89470: NEG
89471: PUSH
89472: LD_INT 0
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 2
89481: NEG
89482: PUSH
89483: LD_INT 1
89485: NEG
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PUSH
89491: LD_INT 2
89493: NEG
89494: PUSH
89495: LD_INT 2
89497: NEG
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PUSH
89503: LD_INT 1
89505: NEG
89506: PUSH
89507: LD_INT 3
89509: NEG
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 1
89517: PUSH
89518: LD_INT 2
89520: NEG
89521: PUSH
89522: EMPTY
89523: LIST
89524: LIST
89525: PUSH
89526: LD_INT 3
89528: PUSH
89529: LD_INT 2
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 2
89538: PUSH
89539: LD_INT 3
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: LD_INT 2
89548: NEG
89549: PUSH
89550: LD_INT 1
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: PUSH
89557: LD_INT 3
89559: NEG
89560: PUSH
89561: LD_INT 1
89563: NEG
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89594: LD_ADDR_VAR 0 35
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: LD_INT 0
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 0
89611: PUSH
89612: LD_INT 1
89614: NEG
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 1
89622: PUSH
89623: LD_INT 0
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 1
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: LD_INT 1
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 1
89652: NEG
89653: PUSH
89654: LD_INT 0
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 1
89663: NEG
89664: PUSH
89665: LD_INT 1
89667: NEG
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 2
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 2
89685: NEG
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89706: LD_ADDR_VAR 0 36
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: LD_INT 0
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 1
89734: PUSH
89735: LD_INT 0
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 1
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: NEG
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 1
89775: NEG
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: LD_INT 2
89791: NEG
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 1
89799: PUSH
89800: LD_INT 2
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89818: LD_ADDR_VAR 0 37
89822: PUSH
89823: LD_INT 0
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 0
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 1
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 0
89866: PUSH
89867: LD_INT 1
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 1
89876: NEG
89877: PUSH
89878: LD_INT 0
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 1
89887: NEG
89888: PUSH
89889: LD_INT 1
89891: NEG
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 1
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: LD_INT 1
89910: NEG
89911: PUSH
89912: LD_INT 1
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89930: LD_ADDR_VAR 0 38
89934: PUSH
89935: LD_INT 0
89937: PUSH
89938: LD_INT 0
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 0
89947: PUSH
89948: LD_INT 1
89950: NEG
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 1
89968: PUSH
89969: LD_INT 1
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 0
89978: PUSH
89979: LD_INT 1
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: LD_INT 0
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: LD_INT 1
90003: NEG
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 2
90011: PUSH
90012: LD_INT 1
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: LD_INT 2
90021: NEG
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90042: LD_ADDR_VAR 0 39
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: LD_INT 0
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: LD_INT 1
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 1
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 1
90080: PUSH
90081: LD_INT 1
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 0
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 1
90100: NEG
90101: PUSH
90102: LD_INT 0
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: LD_INT 1
90115: NEG
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: NEG
90124: PUSH
90125: LD_INT 2
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: PUSH
90136: LD_INT 2
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90154: LD_ADDR_VAR 0 40
90158: PUSH
90159: LD_INT 0
90161: PUSH
90162: LD_INT 0
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 0
90171: PUSH
90172: LD_INT 1
90174: NEG
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 1
90182: PUSH
90183: LD_INT 0
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 1
90192: PUSH
90193: LD_INT 1
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 0
90202: PUSH
90203: LD_INT 1
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 1
90212: NEG
90213: PUSH
90214: LD_INT 0
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 1
90223: NEG
90224: PUSH
90225: LD_INT 1
90227: NEG
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 1
90235: PUSH
90236: LD_INT 1
90238: NEG
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 1
90246: NEG
90247: PUSH
90248: LD_INT 1
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90266: LD_ADDR_VAR 0 41
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 0
90283: PUSH
90284: LD_INT 1
90286: NEG
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 1
90294: PUSH
90295: LD_INT 0
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 1
90304: PUSH
90305: LD_INT 1
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: PUSH
90312: LD_INT 0
90314: PUSH
90315: LD_INT 1
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: PUSH
90322: LD_INT 1
90324: NEG
90325: PUSH
90326: LD_INT 0
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 1
90335: NEG
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: LD_INT 2
90351: NEG
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 1
90359: PUSH
90360: LD_INT 1
90362: NEG
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 2
90370: PUSH
90371: LD_INT 0
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 2
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 2
90390: PUSH
90391: LD_INT 2
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: LD_INT 1
90400: PUSH
90401: LD_INT 2
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 1
90410: NEG
90411: PUSH
90412: LD_INT 1
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 2
90421: NEG
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 2
90432: NEG
90433: PUSH
90434: LD_INT 1
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 2
90444: NEG
90445: PUSH
90446: LD_INT 2
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 2
90456: NEG
90457: PUSH
90458: LD_INT 3
90460: NEG
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: PUSH
90466: LD_INT 2
90468: PUSH
90469: LD_INT 1
90471: NEG
90472: PUSH
90473: EMPTY
90474: LIST
90475: LIST
90476: PUSH
90477: LD_INT 3
90479: PUSH
90480: LD_INT 0
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 3
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 3
90499: PUSH
90500: LD_INT 2
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 3
90509: PUSH
90510: LD_INT 3
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 2
90519: PUSH
90520: LD_INT 3
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 2
90529: NEG
90530: PUSH
90531: LD_INT 1
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: LD_INT 3
90540: NEG
90541: PUSH
90542: LD_INT 0
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 3
90551: NEG
90552: PUSH
90553: LD_INT 1
90555: NEG
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: LD_INT 3
90563: NEG
90564: PUSH
90565: LD_INT 2
90567: NEG
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 3
90575: NEG
90576: PUSH
90577: LD_INT 3
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90616: LD_ADDR_VAR 0 42
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: LD_INT 0
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 0
90633: PUSH
90634: LD_INT 1
90636: NEG
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 1
90644: PUSH
90645: LD_INT 0
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 1
90654: PUSH
90655: LD_INT 1
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: NEG
90675: PUSH
90676: LD_INT 0
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 1
90685: NEG
90686: PUSH
90687: LD_INT 1
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 1
90697: NEG
90698: PUSH
90699: LD_INT 2
90701: NEG
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: LD_INT 2
90712: NEG
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 1
90720: PUSH
90721: LD_INT 1
90723: NEG
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 2
90731: PUSH
90732: LD_INT 1
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: LD_INT 2
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 1
90751: PUSH
90752: LD_INT 2
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 0
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: LD_INT 1
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 2
90782: NEG
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 2
90794: NEG
90795: PUSH
90796: LD_INT 2
90798: NEG
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 2
90806: NEG
90807: PUSH
90808: LD_INT 3
90810: NEG
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: LD_INT 1
90818: NEG
90819: PUSH
90820: LD_INT 3
90822: NEG
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 0
90830: PUSH
90831: LD_INT 3
90833: NEG
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 1
90841: PUSH
90842: LD_INT 2
90844: NEG
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 3
90852: PUSH
90853: LD_INT 2
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 3
90862: PUSH
90863: LD_INT 3
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 2
90872: PUSH
90873: LD_INT 3
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: LD_INT 1
90882: PUSH
90883: LD_INT 3
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: LD_INT 3
90895: PUSH
90896: EMPTY
90897: LIST
90898: LIST
90899: PUSH
90900: LD_INT 1
90902: NEG
90903: PUSH
90904: LD_INT 2
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 3
90913: NEG
90914: PUSH
90915: LD_INT 2
90917: NEG
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 3
90925: NEG
90926: PUSH
90927: LD_INT 3
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: EMPTY
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: LIST
90946: LIST
90947: LIST
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90966: LD_ADDR_VAR 0 43
90970: PUSH
90971: LD_INT 0
90973: PUSH
90974: LD_INT 0
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 0
90983: PUSH
90984: LD_INT 1
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 1
90994: PUSH
90995: LD_INT 0
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 1
91004: PUSH
91005: LD_INT 1
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 0
91014: PUSH
91015: LD_INT 1
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 1
91024: NEG
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 1
91035: NEG
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 1
91047: NEG
91048: PUSH
91049: LD_INT 2
91051: NEG
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: LD_INT 2
91062: NEG
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: LD_INT 1
91073: NEG
91074: PUSH
91075: EMPTY
91076: LIST
91077: LIST
91078: PUSH
91079: LD_INT 2
91081: PUSH
91082: LD_INT 0
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 2
91091: PUSH
91092: LD_INT 1
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 1
91101: PUSH
91102: LD_INT 2
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 0
91111: PUSH
91112: LD_INT 2
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 1
91121: NEG
91122: PUSH
91123: LD_INT 1
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: LD_INT 2
91132: NEG
91133: PUSH
91134: LD_INT 0
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 2
91143: NEG
91144: PUSH
91145: LD_INT 1
91147: NEG
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: NEG
91156: PUSH
91157: LD_INT 3
91159: NEG
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: LD_INT 3
91170: NEG
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 1
91178: PUSH
91179: LD_INT 2
91181: NEG
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 2
91189: PUSH
91190: LD_INT 1
91192: NEG
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: PUSH
91198: LD_INT 3
91200: PUSH
91201: LD_INT 0
91203: PUSH
91204: EMPTY
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 3
91210: PUSH
91211: LD_INT 1
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: PUSH
91218: LD_INT 1
91220: PUSH
91221: LD_INT 3
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 0
91230: PUSH
91231: LD_INT 3
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 1
91240: NEG
91241: PUSH
91242: LD_INT 2
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 2
91251: NEG
91252: PUSH
91253: LD_INT 1
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 3
91262: NEG
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 3
91273: NEG
91274: PUSH
91275: LD_INT 1
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91314: LD_ADDR_VAR 0 44
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 0
91331: PUSH
91332: LD_INT 1
91334: NEG
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: LD_INT 0
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: PUSH
91350: LD_INT 1
91352: PUSH
91353: LD_INT 1
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 0
91362: PUSH
91363: LD_INT 1
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: LD_INT 1
91372: NEG
91373: PUSH
91374: LD_INT 0
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: NEG
91384: PUSH
91385: LD_INT 1
91387: NEG
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 1
91395: NEG
91396: PUSH
91397: LD_INT 2
91399: NEG
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: LD_INT 1
91410: NEG
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 2
91418: PUSH
91419: LD_INT 0
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 2
91428: PUSH
91429: LD_INT 1
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 2
91438: PUSH
91439: LD_INT 2
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: LD_INT 2
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: LD_INT 1
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: PUSH
91467: LD_INT 2
91469: NEG
91470: PUSH
91471: LD_INT 0
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 2
91480: NEG
91481: PUSH
91482: LD_INT 1
91484: NEG
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 2
91492: NEG
91493: PUSH
91494: LD_INT 2
91496: NEG
91497: PUSH
91498: EMPTY
91499: LIST
91500: LIST
91501: PUSH
91502: LD_INT 2
91504: NEG
91505: PUSH
91506: LD_INT 3
91508: NEG
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 2
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 3
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 3
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: LD_INT 3
91547: PUSH
91548: LD_INT 2
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 3
91557: PUSH
91558: LD_INT 3
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: PUSH
91565: LD_INT 2
91567: PUSH
91568: LD_INT 3
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: PUSH
91575: LD_INT 2
91577: NEG
91578: PUSH
91579: LD_INT 1
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 3
91588: NEG
91589: PUSH
91590: LD_INT 0
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PUSH
91597: LD_INT 3
91599: NEG
91600: PUSH
91601: LD_INT 1
91603: NEG
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: PUSH
91609: LD_INT 3
91611: NEG
91612: PUSH
91613: LD_INT 2
91615: NEG
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 3
91623: NEG
91624: PUSH
91625: LD_INT 3
91627: NEG
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91664: LD_ADDR_VAR 0 45
91668: PUSH
91669: LD_INT 0
91671: PUSH
91672: LD_INT 0
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 0
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 1
91692: PUSH
91693: LD_INT 0
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 1
91702: PUSH
91703: LD_INT 1
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 0
91712: PUSH
91713: LD_INT 1
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: LD_INT 0
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: PUSH
91731: LD_INT 1
91733: NEG
91734: PUSH
91735: LD_INT 1
91737: NEG
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 1
91745: NEG
91746: PUSH
91747: LD_INT 2
91749: NEG
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 0
91757: PUSH
91758: LD_INT 2
91760: NEG
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 1
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 2
91779: PUSH
91780: LD_INT 1
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: LD_INT 2
91789: PUSH
91790: LD_INT 2
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: LD_INT 1
91799: PUSH
91800: LD_INT 2
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 0
91809: PUSH
91810: LD_INT 2
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PUSH
91817: LD_INT 1
91819: NEG
91820: PUSH
91821: LD_INT 1
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 2
91830: NEG
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 2
91842: NEG
91843: PUSH
91844: LD_INT 2
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: NEG
91855: PUSH
91856: LD_INT 3
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 1
91866: NEG
91867: PUSH
91868: LD_INT 3
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: LD_INT 3
91881: NEG
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 1
91889: PUSH
91890: LD_INT 2
91892: NEG
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 3
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: EMPTY
91905: LIST
91906: LIST
91907: PUSH
91908: LD_INT 3
91910: PUSH
91911: LD_INT 3
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 2
91920: PUSH
91921: LD_INT 3
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: LD_INT 3
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 0
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: EMPTY
91945: LIST
91946: LIST
91947: PUSH
91948: LD_INT 1
91950: NEG
91951: PUSH
91952: LD_INT 2
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: PUSH
91959: LD_INT 3
91961: NEG
91962: PUSH
91963: LD_INT 2
91965: NEG
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: LD_INT 3
91973: NEG
91974: PUSH
91975: LD_INT 3
91977: NEG
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92014: LD_ADDR_VAR 0 46
92018: PUSH
92019: LD_INT 0
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 0
92031: PUSH
92032: LD_INT 1
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: LD_INT 0
92045: PUSH
92046: EMPTY
92047: LIST
92048: LIST
92049: PUSH
92050: LD_INT 1
92052: PUSH
92053: LD_INT 1
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PUSH
92060: LD_INT 0
92062: PUSH
92063: LD_INT 1
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: LD_INT 0
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: PUSH
92081: LD_INT 1
92083: NEG
92084: PUSH
92085: LD_INT 1
92087: NEG
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 1
92095: NEG
92096: PUSH
92097: LD_INT 2
92099: NEG
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 0
92107: PUSH
92108: LD_INT 2
92110: NEG
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: PUSH
92116: LD_INT 1
92118: PUSH
92119: LD_INT 1
92121: NEG
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 2
92129: PUSH
92130: LD_INT 0
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 2
92139: PUSH
92140: LD_INT 1
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 1
92149: PUSH
92150: LD_INT 2
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 0
92159: PUSH
92160: LD_INT 2
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 1
92169: NEG
92170: PUSH
92171: LD_INT 1
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: LD_INT 2
92180: NEG
92181: PUSH
92182: LD_INT 0
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: LD_INT 2
92191: NEG
92192: PUSH
92193: LD_INT 1
92195: NEG
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 1
92203: NEG
92204: PUSH
92205: LD_INT 3
92207: NEG
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 0
92215: PUSH
92216: LD_INT 3
92218: NEG
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 1
92226: PUSH
92227: LD_INT 2
92229: NEG
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 2
92237: PUSH
92238: LD_INT 1
92240: NEG
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 3
92248: PUSH
92249: LD_INT 0
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 3
92258: PUSH
92259: LD_INT 1
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 1
92268: PUSH
92269: LD_INT 3
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 0
92278: PUSH
92279: LD_INT 3
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 1
92288: NEG
92289: PUSH
92290: LD_INT 2
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 2
92299: NEG
92300: PUSH
92301: LD_INT 1
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: NEG
92322: PUSH
92323: LD_INT 1
92325: NEG
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92362: LD_ADDR_VAR 0 47
92366: PUSH
92367: LD_INT 0
92369: PUSH
92370: LD_INT 0
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: LD_INT 1
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: LD_INT 1
92390: PUSH
92391: LD_INT 0
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: LD_INT 1
92400: PUSH
92401: LD_INT 1
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: PUSH
92408: LD_INT 0
92410: PUSH
92411: LD_INT 1
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: PUSH
92418: LD_INT 1
92420: NEG
92421: PUSH
92422: LD_INT 0
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: LD_INT 1
92435: NEG
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 1
92443: NEG
92444: PUSH
92445: LD_INT 2
92447: NEG
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 0
92455: PUSH
92456: LD_INT 2
92458: NEG
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 1
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 2
92477: NEG
92478: PUSH
92479: LD_INT 1
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: LD_INT 2
92489: NEG
92490: PUSH
92491: LD_INT 2
92493: NEG
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92513: LD_ADDR_VAR 0 48
92517: PUSH
92518: LD_INT 0
92520: PUSH
92521: LD_INT 0
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 0
92530: PUSH
92531: LD_INT 1
92533: NEG
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 1
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: PUSH
92549: LD_INT 1
92551: PUSH
92552: LD_INT 1
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 0
92561: PUSH
92562: LD_INT 1
92564: PUSH
92565: EMPTY
92566: LIST
92567: LIST
92568: PUSH
92569: LD_INT 1
92571: NEG
92572: PUSH
92573: LD_INT 0
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 1
92582: NEG
92583: PUSH
92584: LD_INT 1
92586: NEG
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: PUSH
92592: LD_INT 1
92594: NEG
92595: PUSH
92596: LD_INT 2
92598: NEG
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 0
92606: PUSH
92607: LD_INT 2
92609: NEG
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 1
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 2
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 2
92638: PUSH
92639: LD_INT 1
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92660: LD_ADDR_VAR 0 49
92664: PUSH
92665: LD_INT 0
92667: PUSH
92668: LD_INT 0
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 0
92677: PUSH
92678: LD_INT 1
92680: NEG
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 1
92688: PUSH
92689: LD_INT 0
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 1
92698: PUSH
92699: LD_INT 1
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: PUSH
92706: LD_INT 0
92708: PUSH
92709: LD_INT 1
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 1
92718: NEG
92719: PUSH
92720: LD_INT 0
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 1
92729: NEG
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 1
92741: PUSH
92742: LD_INT 1
92744: NEG
92745: PUSH
92746: EMPTY
92747: LIST
92748: LIST
92749: PUSH
92750: LD_INT 2
92752: PUSH
92753: LD_INT 0
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 2
92762: PUSH
92763: LD_INT 1
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 2
92772: PUSH
92773: LD_INT 2
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 1
92782: PUSH
92783: LD_INT 2
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92804: LD_ADDR_VAR 0 50
92808: PUSH
92809: LD_INT 0
92811: PUSH
92812: LD_INT 0
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 0
92821: PUSH
92822: LD_INT 1
92824: NEG
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 1
92832: PUSH
92833: LD_INT 0
92835: PUSH
92836: EMPTY
92837: LIST
92838: LIST
92839: PUSH
92840: LD_INT 1
92842: PUSH
92843: LD_INT 1
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 0
92852: PUSH
92853: LD_INT 1
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: PUSH
92860: LD_INT 1
92862: NEG
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 1
92873: NEG
92874: PUSH
92875: LD_INT 1
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 2
92885: PUSH
92886: LD_INT 1
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 2
92895: PUSH
92896: LD_INT 2
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 1
92905: PUSH
92906: LD_INT 2
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 0
92915: PUSH
92916: LD_INT 2
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 1
92925: NEG
92926: PUSH
92927: LD_INT 1
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92948: LD_ADDR_VAR 0 51
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: LD_INT 0
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 1
92976: PUSH
92977: LD_INT 0
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: PUSH
92987: LD_INT 1
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: LD_INT 0
92996: PUSH
92997: LD_INT 1
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: LD_INT 0
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 1
93017: NEG
93018: PUSH
93019: LD_INT 1
93021: NEG
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 1
93029: PUSH
93030: LD_INT 2
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 0
93039: PUSH
93040: LD_INT 2
93042: PUSH
93043: EMPTY
93044: LIST
93045: LIST
93046: PUSH
93047: LD_INT 1
93049: NEG
93050: PUSH
93051: LD_INT 1
93053: PUSH
93054: EMPTY
93055: LIST
93056: LIST
93057: PUSH
93058: LD_INT 2
93060: NEG
93061: PUSH
93062: LD_INT 0
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 2
93071: NEG
93072: PUSH
93073: LD_INT 1
93075: NEG
93076: PUSH
93077: EMPTY
93078: LIST
93079: LIST
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93095: LD_ADDR_VAR 0 52
93099: PUSH
93100: LD_INT 0
93102: PUSH
93103: LD_INT 0
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 0
93112: PUSH
93113: LD_INT 1
93115: NEG
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: PUSH
93121: LD_INT 1
93123: PUSH
93124: LD_INT 0
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 1
93133: PUSH
93134: LD_INT 1
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PUSH
93141: LD_INT 0
93143: PUSH
93144: LD_INT 1
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 1
93153: NEG
93154: PUSH
93155: LD_INT 0
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 1
93164: NEG
93165: PUSH
93166: LD_INT 1
93168: NEG
93169: PUSH
93170: EMPTY
93171: LIST
93172: LIST
93173: PUSH
93174: LD_INT 1
93176: NEG
93177: PUSH
93178: LD_INT 2
93180: NEG
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 1
93188: NEG
93189: PUSH
93190: LD_INT 1
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 2
93199: NEG
93200: PUSH
93201: LD_INT 0
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: LD_INT 2
93210: NEG
93211: PUSH
93212: LD_INT 1
93214: NEG
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 2
93222: NEG
93223: PUSH
93224: LD_INT 2
93226: NEG
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93246: LD_ADDR_VAR 0 53
93250: PUSH
93251: LD_INT 0
93253: PUSH
93254: LD_INT 0
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 0
93263: PUSH
93264: LD_INT 1
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: LD_INT 0
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: LD_INT 1
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 0
93294: PUSH
93295: LD_INT 1
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: NEG
93305: PUSH
93306: LD_INT 0
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 1
93315: NEG
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: PUSH
93325: LD_INT 1
93327: NEG
93328: PUSH
93329: LD_INT 2
93331: NEG
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 2
93342: NEG
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 1
93350: PUSH
93351: LD_INT 1
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 2
93361: PUSH
93362: LD_INT 0
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: LD_INT 2
93371: PUSH
93372: LD_INT 1
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: PUSH
93379: LD_INT 2
93381: PUSH
93382: LD_INT 2
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 1
93391: PUSH
93392: LD_INT 2
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 0
93401: PUSH
93402: LD_INT 2
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 1
93411: NEG
93412: PUSH
93413: LD_INT 1
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 2
93422: NEG
93423: PUSH
93424: LD_INT 0
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 2
93433: NEG
93434: PUSH
93435: LD_INT 1
93437: NEG
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: PUSH
93443: LD_INT 2
93445: NEG
93446: PUSH
93447: LD_INT 2
93449: NEG
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: PUSH
93455: EMPTY
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93476: LD_ADDR_VAR 0 54
93480: PUSH
93481: LD_INT 0
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 0
93493: PUSH
93494: LD_INT 1
93496: NEG
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 1
93504: PUSH
93505: LD_INT 0
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 1
93514: PUSH
93515: LD_INT 1
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 0
93524: PUSH
93525: LD_INT 1
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 1
93534: NEG
93535: PUSH
93536: LD_INT 0
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 1
93545: NEG
93546: PUSH
93547: LD_INT 1
93549: NEG
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: LD_INT 1
93557: NEG
93558: PUSH
93559: LD_INT 2
93561: NEG
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 0
93569: PUSH
93570: LD_INT 2
93572: NEG
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: LD_INT 1
93580: PUSH
93581: LD_INT 1
93583: NEG
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 2
93591: PUSH
93592: LD_INT 0
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 2
93601: PUSH
93602: LD_INT 1
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 2
93611: PUSH
93612: LD_INT 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 1
93621: PUSH
93622: LD_INT 2
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 0
93631: PUSH
93632: LD_INT 2
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 1
93641: NEG
93642: PUSH
93643: LD_INT 1
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: PUSH
93650: LD_INT 2
93652: NEG
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 2
93663: NEG
93664: PUSH
93665: LD_INT 1
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 2
93675: NEG
93676: PUSH
93677: LD_INT 2
93679: NEG
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93706: LD_ADDR_VAR 0 55
93710: PUSH
93711: LD_INT 0
93713: PUSH
93714: LD_INT 0
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 0
93723: PUSH
93724: LD_INT 1
93726: NEG
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 1
93734: PUSH
93735: LD_INT 0
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 1
93744: PUSH
93745: LD_INT 1
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 0
93754: PUSH
93755: LD_INT 1
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 1
93764: NEG
93765: PUSH
93766: LD_INT 0
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 1
93775: NEG
93776: PUSH
93777: LD_INT 1
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 1
93787: NEG
93788: PUSH
93789: LD_INT 2
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 0
93799: PUSH
93800: LD_INT 2
93802: NEG
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: LD_INT 1
93810: PUSH
93811: LD_INT 1
93813: NEG
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 2
93821: PUSH
93822: LD_INT 0
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 2
93831: PUSH
93832: LD_INT 1
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 2
93841: PUSH
93842: LD_INT 2
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 1
93851: PUSH
93852: LD_INT 2
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 0
93861: PUSH
93862: LD_INT 2
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: LD_INT 1
93871: NEG
93872: PUSH
93873: LD_INT 1
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 2
93882: NEG
93883: PUSH
93884: LD_INT 0
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 2
93893: NEG
93894: PUSH
93895: LD_INT 1
93897: NEG
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 2
93905: NEG
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93936: LD_ADDR_VAR 0 56
93940: PUSH
93941: LD_INT 0
93943: PUSH
93944: LD_INT 0
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 0
93953: PUSH
93954: LD_INT 1
93956: NEG
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 1
93964: PUSH
93965: LD_INT 0
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 1
93974: PUSH
93975: LD_INT 1
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: PUSH
93982: LD_INT 0
93984: PUSH
93985: LD_INT 1
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 1
93994: NEG
93995: PUSH
93996: LD_INT 0
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 1
94005: NEG
94006: PUSH
94007: LD_INT 1
94009: NEG
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: LD_INT 1
94017: NEG
94018: PUSH
94019: LD_INT 2
94021: NEG
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: PUSH
94027: LD_INT 0
94029: PUSH
94030: LD_INT 2
94032: NEG
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 1
94040: PUSH
94041: LD_INT 1
94043: NEG
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 2
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 2
94071: PUSH
94072: LD_INT 2
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 1
94081: PUSH
94082: LD_INT 2
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 0
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 1
94101: NEG
94102: PUSH
94103: LD_INT 1
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: PUSH
94110: LD_INT 2
94112: NEG
94113: PUSH
94114: LD_INT 0
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 2
94123: NEG
94124: PUSH
94125: LD_INT 1
94127: NEG
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: PUSH
94133: LD_INT 2
94135: NEG
94136: PUSH
94137: LD_INT 2
94139: NEG
94140: PUSH
94141: EMPTY
94142: LIST
94143: LIST
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94166: LD_ADDR_VAR 0 57
94170: PUSH
94171: LD_INT 0
94173: PUSH
94174: LD_INT 0
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 0
94183: PUSH
94184: LD_INT 1
94186: NEG
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 1
94194: PUSH
94195: LD_INT 0
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 1
94204: PUSH
94205: LD_INT 1
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 0
94214: PUSH
94215: LD_INT 1
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 1
94224: NEG
94225: PUSH
94226: LD_INT 0
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 1
94235: NEG
94236: PUSH
94237: LD_INT 1
94239: NEG
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: PUSH
94245: LD_INT 1
94247: NEG
94248: PUSH
94249: LD_INT 2
94251: NEG
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: PUSH
94257: LD_INT 0
94259: PUSH
94260: LD_INT 2
94262: NEG
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: PUSH
94268: LD_INT 1
94270: PUSH
94271: LD_INT 1
94273: NEG
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: PUSH
94279: LD_INT 2
94281: PUSH
94282: LD_INT 0
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 2
94291: PUSH
94292: LD_INT 1
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 2
94301: PUSH
94302: LD_INT 2
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PUSH
94309: LD_INT 1
94311: PUSH
94312: LD_INT 2
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 0
94321: PUSH
94322: LD_INT 2
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 1
94331: NEG
94332: PUSH
94333: LD_INT 1
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 2
94342: NEG
94343: PUSH
94344: LD_INT 0
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 2
94353: NEG
94354: PUSH
94355: LD_INT 1
94357: NEG
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 2
94365: NEG
94366: PUSH
94367: LD_INT 2
94369: NEG
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: EMPTY
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94396: LD_ADDR_VAR 0 58
94400: PUSH
94401: LD_INT 0
94403: PUSH
94404: LD_INT 0
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 0
94413: PUSH
94414: LD_INT 1
94416: NEG
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 1
94424: PUSH
94425: LD_INT 0
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: PUSH
94432: LD_INT 1
94434: PUSH
94435: LD_INT 1
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 0
94444: PUSH
94445: LD_INT 1
94447: PUSH
94448: EMPTY
94449: LIST
94450: LIST
94451: PUSH
94452: LD_INT 1
94454: NEG
94455: PUSH
94456: LD_INT 0
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 1
94465: NEG
94466: PUSH
94467: LD_INT 1
94469: NEG
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 1
94477: NEG
94478: PUSH
94479: LD_INT 2
94481: NEG
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: LD_INT 2
94492: NEG
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 1
94500: PUSH
94501: LD_INT 1
94503: NEG
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 2
94511: PUSH
94512: LD_INT 0
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 2
94521: PUSH
94522: LD_INT 1
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 2
94531: PUSH
94532: LD_INT 2
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 1
94541: PUSH
94542: LD_INT 2
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 0
94551: PUSH
94552: LD_INT 2
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 1
94561: NEG
94562: PUSH
94563: LD_INT 1
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 2
94572: NEG
94573: PUSH
94574: LD_INT 0
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 2
94583: NEG
94584: PUSH
94585: LD_INT 1
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 2
94595: NEG
94596: PUSH
94597: LD_INT 2
94599: NEG
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94626: LD_ADDR_VAR 0 59
94630: PUSH
94631: LD_INT 0
94633: PUSH
94634: LD_INT 0
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 0
94643: PUSH
94644: LD_INT 1
94646: NEG
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 1
94654: PUSH
94655: LD_INT 0
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 1
94664: PUSH
94665: LD_INT 1
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: LD_INT 1
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 1
94684: NEG
94685: PUSH
94686: LD_INT 0
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 1
94695: NEG
94696: PUSH
94697: LD_INT 1
94699: NEG
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94714: LD_ADDR_VAR 0 60
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: LD_INT 0
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: LD_INT 0
94731: PUSH
94732: LD_INT 1
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 1
94742: PUSH
94743: LD_INT 0
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 1
94752: PUSH
94753: LD_INT 1
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: LD_INT 0
94762: PUSH
94763: LD_INT 1
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 1
94772: NEG
94773: PUSH
94774: LD_INT 0
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: PUSH
94781: LD_INT 1
94783: NEG
94784: PUSH
94785: LD_INT 1
94787: NEG
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94802: LD_ADDR_VAR 0 61
94806: PUSH
94807: LD_INT 0
94809: PUSH
94810: LD_INT 0
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 0
94819: PUSH
94820: LD_INT 1
94822: NEG
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 1
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 1
94840: PUSH
94841: LD_INT 1
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 0
94850: PUSH
94851: LD_INT 1
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 1
94860: NEG
94861: PUSH
94862: LD_INT 0
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 1
94871: NEG
94872: PUSH
94873: LD_INT 1
94875: NEG
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94890: LD_ADDR_VAR 0 62
94894: PUSH
94895: LD_INT 0
94897: PUSH
94898: LD_INT 0
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 0
94907: PUSH
94908: LD_INT 1
94910: NEG
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 1
94918: PUSH
94919: LD_INT 0
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 1
94928: PUSH
94929: LD_INT 1
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 0
94938: PUSH
94939: LD_INT 1
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 1
94948: NEG
94949: PUSH
94950: LD_INT 0
94952: PUSH
94953: EMPTY
94954: LIST
94955: LIST
94956: PUSH
94957: LD_INT 1
94959: NEG
94960: PUSH
94961: LD_INT 1
94963: NEG
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94978: LD_ADDR_VAR 0 63
94982: PUSH
94983: LD_INT 0
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 0
94995: PUSH
94996: LD_INT 1
94998: NEG
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: PUSH
95004: LD_INT 1
95006: PUSH
95007: LD_INT 0
95009: PUSH
95010: EMPTY
95011: LIST
95012: LIST
95013: PUSH
95014: LD_INT 1
95016: PUSH
95017: LD_INT 1
95019: PUSH
95020: EMPTY
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 0
95026: PUSH
95027: LD_INT 1
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: PUSH
95034: LD_INT 1
95036: NEG
95037: PUSH
95038: LD_INT 0
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 1
95047: NEG
95048: PUSH
95049: LD_INT 1
95051: NEG
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95066: LD_ADDR_VAR 0 64
95070: PUSH
95071: LD_INT 0
95073: PUSH
95074: LD_INT 0
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 0
95083: PUSH
95084: LD_INT 1
95086: NEG
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 1
95094: PUSH
95095: LD_INT 0
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 1
95104: PUSH
95105: LD_INT 1
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 0
95114: PUSH
95115: LD_INT 1
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 1
95124: NEG
95125: PUSH
95126: LD_INT 0
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 1
95135: NEG
95136: PUSH
95137: LD_INT 1
95139: NEG
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: ST_TO_ADDR
// end ; 1 :
95154: GO 101051
95156: LD_INT 1
95158: DOUBLE
95159: EQUAL
95160: IFTRUE 95164
95162: GO 97787
95164: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95165: LD_ADDR_VAR 0 11
95169: PUSH
95170: LD_INT 1
95172: NEG
95173: PUSH
95174: LD_INT 3
95176: NEG
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 0
95184: PUSH
95185: LD_INT 3
95187: NEG
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 1
95195: PUSH
95196: LD_INT 2
95198: NEG
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: LIST
95208: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95209: LD_ADDR_VAR 0 12
95213: PUSH
95214: LD_INT 2
95216: PUSH
95217: LD_INT 1
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 3
95227: PUSH
95228: LD_INT 0
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 3
95237: PUSH
95238: LD_INT 1
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: LIST
95249: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95250: LD_ADDR_VAR 0 13
95254: PUSH
95255: LD_INT 3
95257: PUSH
95258: LD_INT 2
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 3
95267: PUSH
95268: LD_INT 3
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 2
95277: PUSH
95278: LD_INT 3
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: LIST
95289: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95290: LD_ADDR_VAR 0 14
95294: PUSH
95295: LD_INT 1
95297: PUSH
95298: LD_INT 3
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 0
95307: PUSH
95308: LD_INT 3
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 1
95317: NEG
95318: PUSH
95319: LD_INT 2
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: EMPTY
95327: LIST
95328: LIST
95329: LIST
95330: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95331: LD_ADDR_VAR 0 15
95335: PUSH
95336: LD_INT 2
95338: NEG
95339: PUSH
95340: LD_INT 1
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 3
95349: NEG
95350: PUSH
95351: LD_INT 0
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 3
95360: NEG
95361: PUSH
95362: LD_INT 1
95364: NEG
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: LIST
95374: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95375: LD_ADDR_VAR 0 16
95379: PUSH
95380: LD_INT 2
95382: NEG
95383: PUSH
95384: LD_INT 3
95386: NEG
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 3
95394: NEG
95395: PUSH
95396: LD_INT 2
95398: NEG
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 3
95406: NEG
95407: PUSH
95408: LD_INT 3
95410: NEG
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: LIST
95420: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95421: LD_ADDR_VAR 0 17
95425: PUSH
95426: LD_INT 1
95428: NEG
95429: PUSH
95430: LD_INT 3
95432: NEG
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 0
95440: PUSH
95441: LD_INT 3
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 1
95451: PUSH
95452: LD_INT 2
95454: NEG
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: LIST
95464: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95465: LD_ADDR_VAR 0 18
95469: PUSH
95470: LD_INT 2
95472: PUSH
95473: LD_INT 1
95475: NEG
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 3
95483: PUSH
95484: LD_INT 0
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 3
95493: PUSH
95494: LD_INT 1
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: EMPTY
95502: LIST
95503: LIST
95504: LIST
95505: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95506: LD_ADDR_VAR 0 19
95510: PUSH
95511: LD_INT 3
95513: PUSH
95514: LD_INT 2
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 3
95523: PUSH
95524: LD_INT 3
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 2
95533: PUSH
95534: LD_INT 3
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: LIST
95545: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95546: LD_ADDR_VAR 0 20
95550: PUSH
95551: LD_INT 1
95553: PUSH
95554: LD_INT 3
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 0
95563: PUSH
95564: LD_INT 3
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 1
95573: NEG
95574: PUSH
95575: LD_INT 2
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: LIST
95586: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95587: LD_ADDR_VAR 0 21
95591: PUSH
95592: LD_INT 2
95594: NEG
95595: PUSH
95596: LD_INT 1
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 3
95605: NEG
95606: PUSH
95607: LD_INT 0
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 3
95616: NEG
95617: PUSH
95618: LD_INT 1
95620: NEG
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: EMPTY
95627: LIST
95628: LIST
95629: LIST
95630: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95631: LD_ADDR_VAR 0 22
95635: PUSH
95636: LD_INT 2
95638: NEG
95639: PUSH
95640: LD_INT 3
95642: NEG
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 3
95650: NEG
95651: PUSH
95652: LD_INT 2
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 3
95662: NEG
95663: PUSH
95664: LD_INT 3
95666: NEG
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: LIST
95676: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
95677: LD_ADDR_VAR 0 23
95681: PUSH
95682: LD_INT 0
95684: PUSH
95685: LD_INT 3
95687: NEG
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: LD_INT 1
95695: NEG
95696: PUSH
95697: LD_INT 4
95699: NEG
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 1
95707: PUSH
95708: LD_INT 3
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: LIST
95720: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
95721: LD_ADDR_VAR 0 24
95725: PUSH
95726: LD_INT 3
95728: PUSH
95729: LD_INT 0
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 3
95738: PUSH
95739: LD_INT 1
95741: NEG
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 4
95749: PUSH
95750: LD_INT 1
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: LIST
95761: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
95762: LD_ADDR_VAR 0 25
95766: PUSH
95767: LD_INT 3
95769: PUSH
95770: LD_INT 3
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 4
95779: PUSH
95780: LD_INT 3
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 3
95789: PUSH
95790: LD_INT 4
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: LIST
95801: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
95802: LD_ADDR_VAR 0 26
95806: PUSH
95807: LD_INT 0
95809: PUSH
95810: LD_INT 3
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 1
95819: PUSH
95820: LD_INT 4
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 1
95829: NEG
95830: PUSH
95831: LD_INT 3
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: LIST
95842: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
95843: LD_ADDR_VAR 0 27
95847: PUSH
95848: LD_INT 3
95850: NEG
95851: PUSH
95852: LD_INT 0
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 3
95861: NEG
95862: PUSH
95863: LD_INT 1
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 4
95872: NEG
95873: PUSH
95874: LD_INT 1
95876: NEG
95877: PUSH
95878: EMPTY
95879: LIST
95880: LIST
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: LIST
95886: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
95887: LD_ADDR_VAR 0 28
95891: PUSH
95892: LD_INT 3
95894: NEG
95895: PUSH
95896: LD_INT 3
95898: NEG
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 3
95906: NEG
95907: PUSH
95908: LD_INT 4
95910: NEG
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 4
95918: NEG
95919: PUSH
95920: LD_INT 3
95922: NEG
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: LIST
95932: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
95933: LD_ADDR_VAR 0 29
95937: PUSH
95938: LD_INT 1
95940: NEG
95941: PUSH
95942: LD_INT 3
95944: NEG
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: PUSH
95950: LD_INT 0
95952: PUSH
95953: LD_INT 3
95955: NEG
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 1
95963: PUSH
95964: LD_INT 2
95966: NEG
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: PUSH
95972: LD_INT 1
95974: NEG
95975: PUSH
95976: LD_INT 4
95978: NEG
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 0
95986: PUSH
95987: LD_INT 4
95989: NEG
95990: PUSH
95991: EMPTY
95992: LIST
95993: LIST
95994: PUSH
95995: LD_INT 1
95997: PUSH
95998: LD_INT 3
96000: NEG
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 1
96008: NEG
96009: PUSH
96010: LD_INT 5
96012: NEG
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 0
96020: PUSH
96021: LD_INT 5
96023: NEG
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 1
96031: PUSH
96032: LD_INT 4
96034: NEG
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 1
96042: NEG
96043: PUSH
96044: LD_INT 6
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 0
96054: PUSH
96055: LD_INT 6
96057: NEG
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: LD_INT 1
96065: PUSH
96066: LD_INT 5
96068: NEG
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96088: LD_ADDR_VAR 0 30
96092: PUSH
96093: LD_INT 2
96095: PUSH
96096: LD_INT 1
96098: NEG
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: LD_INT 3
96106: PUSH
96107: LD_INT 0
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PUSH
96114: LD_INT 3
96116: PUSH
96117: LD_INT 1
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 3
96126: PUSH
96127: LD_INT 1
96129: NEG
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: LD_INT 4
96137: PUSH
96138: LD_INT 0
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 4
96147: PUSH
96148: LD_INT 1
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 4
96157: PUSH
96158: LD_INT 1
96160: NEG
96161: PUSH
96162: EMPTY
96163: LIST
96164: LIST
96165: PUSH
96166: LD_INT 5
96168: PUSH
96169: LD_INT 0
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 5
96178: PUSH
96179: LD_INT 1
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 5
96188: PUSH
96189: LD_INT 1
96191: NEG
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 6
96199: PUSH
96200: LD_INT 0
96202: PUSH
96203: EMPTY
96204: LIST
96205: LIST
96206: PUSH
96207: LD_INT 6
96209: PUSH
96210: LD_INT 1
96212: PUSH
96213: EMPTY
96214: LIST
96215: LIST
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96231: LD_ADDR_VAR 0 31
96235: PUSH
96236: LD_INT 3
96238: PUSH
96239: LD_INT 2
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 3
96248: PUSH
96249: LD_INT 3
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: PUSH
96256: LD_INT 2
96258: PUSH
96259: LD_INT 3
96261: PUSH
96262: EMPTY
96263: LIST
96264: LIST
96265: PUSH
96266: LD_INT 4
96268: PUSH
96269: LD_INT 3
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 4
96278: PUSH
96279: LD_INT 4
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 3
96288: PUSH
96289: LD_INT 4
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: PUSH
96296: LD_INT 5
96298: PUSH
96299: LD_INT 4
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 5
96308: PUSH
96309: LD_INT 5
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 4
96318: PUSH
96319: LD_INT 5
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 6
96328: PUSH
96329: LD_INT 5
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 6
96338: PUSH
96339: LD_INT 6
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 5
96348: PUSH
96349: LD_INT 6
96351: PUSH
96352: EMPTY
96353: LIST
96354: LIST
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96370: LD_ADDR_VAR 0 32
96374: PUSH
96375: LD_INT 1
96377: PUSH
96378: LD_INT 3
96380: PUSH
96381: EMPTY
96382: LIST
96383: LIST
96384: PUSH
96385: LD_INT 0
96387: PUSH
96388: LD_INT 3
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 1
96397: NEG
96398: PUSH
96399: LD_INT 2
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 1
96408: PUSH
96409: LD_INT 4
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 0
96418: PUSH
96419: LD_INT 4
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 1
96428: NEG
96429: PUSH
96430: LD_INT 3
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 1
96439: PUSH
96440: LD_INT 5
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 0
96449: PUSH
96450: LD_INT 5
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 1
96459: NEG
96460: PUSH
96461: LD_INT 4
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 1
96470: PUSH
96471: LD_INT 6
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: LD_INT 0
96480: PUSH
96481: LD_INT 6
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: LD_INT 1
96490: NEG
96491: PUSH
96492: LD_INT 5
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
96513: LD_ADDR_VAR 0 33
96517: PUSH
96518: LD_INT 2
96520: NEG
96521: PUSH
96522: LD_INT 1
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 3
96531: NEG
96532: PUSH
96533: LD_INT 0
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: PUSH
96540: LD_INT 3
96542: NEG
96543: PUSH
96544: LD_INT 1
96546: NEG
96547: PUSH
96548: EMPTY
96549: LIST
96550: LIST
96551: PUSH
96552: LD_INT 3
96554: NEG
96555: PUSH
96556: LD_INT 1
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 4
96565: NEG
96566: PUSH
96567: LD_INT 0
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 4
96576: NEG
96577: PUSH
96578: LD_INT 1
96580: NEG
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 4
96588: NEG
96589: PUSH
96590: LD_INT 1
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 5
96599: NEG
96600: PUSH
96601: LD_INT 0
96603: PUSH
96604: EMPTY
96605: LIST
96606: LIST
96607: PUSH
96608: LD_INT 5
96610: NEG
96611: PUSH
96612: LD_INT 1
96614: NEG
96615: PUSH
96616: EMPTY
96617: LIST
96618: LIST
96619: PUSH
96620: LD_INT 5
96622: NEG
96623: PUSH
96624: LD_INT 1
96626: PUSH
96627: EMPTY
96628: LIST
96629: LIST
96630: PUSH
96631: LD_INT 6
96633: NEG
96634: PUSH
96635: LD_INT 0
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 6
96644: NEG
96645: PUSH
96646: LD_INT 1
96648: NEG
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
96668: LD_ADDR_VAR 0 34
96672: PUSH
96673: LD_INT 2
96675: NEG
96676: PUSH
96677: LD_INT 3
96679: NEG
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 3
96687: NEG
96688: PUSH
96689: LD_INT 2
96691: NEG
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 3
96699: NEG
96700: PUSH
96701: LD_INT 3
96703: NEG
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 3
96711: NEG
96712: PUSH
96713: LD_INT 4
96715: NEG
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 4
96723: NEG
96724: PUSH
96725: LD_INT 3
96727: NEG
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 4
96735: NEG
96736: PUSH
96737: LD_INT 4
96739: NEG
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 4
96747: NEG
96748: PUSH
96749: LD_INT 5
96751: NEG
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 5
96759: NEG
96760: PUSH
96761: LD_INT 4
96763: NEG
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 5
96771: NEG
96772: PUSH
96773: LD_INT 5
96775: NEG
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 5
96783: NEG
96784: PUSH
96785: LD_INT 6
96787: NEG
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PUSH
96793: LD_INT 6
96795: NEG
96796: PUSH
96797: LD_INT 5
96799: NEG
96800: PUSH
96801: EMPTY
96802: LIST
96803: LIST
96804: PUSH
96805: LD_INT 6
96807: NEG
96808: PUSH
96809: LD_INT 6
96811: NEG
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
96831: LD_ADDR_VAR 0 41
96835: PUSH
96836: LD_INT 0
96838: PUSH
96839: LD_INT 2
96841: NEG
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: PUSH
96847: LD_INT 1
96849: NEG
96850: PUSH
96851: LD_INT 3
96853: NEG
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 1
96861: PUSH
96862: LD_INT 2
96864: NEG
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: PUSH
96870: EMPTY
96871: LIST
96872: LIST
96873: LIST
96874: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
96875: LD_ADDR_VAR 0 42
96879: PUSH
96880: LD_INT 2
96882: PUSH
96883: LD_INT 0
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: LD_INT 2
96892: PUSH
96893: LD_INT 1
96895: NEG
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 3
96903: PUSH
96904: LD_INT 1
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: LIST
96915: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
96916: LD_ADDR_VAR 0 43
96920: PUSH
96921: LD_INT 2
96923: PUSH
96924: LD_INT 2
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 3
96933: PUSH
96934: LD_INT 2
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: PUSH
96941: LD_INT 2
96943: PUSH
96944: LD_INT 3
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: LIST
96955: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
96956: LD_ADDR_VAR 0 44
96960: PUSH
96961: LD_INT 0
96963: PUSH
96964: LD_INT 2
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 1
96973: PUSH
96974: LD_INT 3
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 1
96983: NEG
96984: PUSH
96985: LD_INT 2
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: LIST
96996: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
96997: LD_ADDR_VAR 0 45
97001: PUSH
97002: LD_INT 2
97004: NEG
97005: PUSH
97006: LD_INT 0
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: LD_INT 2
97015: NEG
97016: PUSH
97017: LD_INT 1
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 3
97026: NEG
97027: PUSH
97028: LD_INT 1
97030: NEG
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: LIST
97040: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97041: LD_ADDR_VAR 0 46
97045: PUSH
97046: LD_INT 2
97048: NEG
97049: PUSH
97050: LD_INT 2
97052: NEG
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PUSH
97058: LD_INT 2
97060: NEG
97061: PUSH
97062: LD_INT 3
97064: NEG
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_INT 3
97072: NEG
97073: PUSH
97074: LD_INT 2
97076: NEG
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: LIST
97086: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97087: LD_ADDR_VAR 0 47
97091: PUSH
97092: LD_INT 2
97094: NEG
97095: PUSH
97096: LD_INT 3
97098: NEG
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 1
97106: NEG
97107: PUSH
97108: LD_INT 3
97110: NEG
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97120: LD_ADDR_VAR 0 48
97124: PUSH
97125: LD_INT 1
97127: PUSH
97128: LD_INT 2
97130: NEG
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 2
97138: PUSH
97139: LD_INT 1
97141: NEG
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97151: LD_ADDR_VAR 0 49
97155: PUSH
97156: LD_INT 3
97158: PUSH
97159: LD_INT 1
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: LD_INT 3
97168: PUSH
97169: LD_INT 2
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97180: LD_ADDR_VAR 0 50
97184: PUSH
97185: LD_INT 2
97187: PUSH
97188: LD_INT 3
97190: PUSH
97191: EMPTY
97192: LIST
97193: LIST
97194: PUSH
97195: LD_INT 1
97197: PUSH
97198: LD_INT 3
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97209: LD_ADDR_VAR 0 51
97213: PUSH
97214: LD_INT 1
97216: NEG
97217: PUSH
97218: LD_INT 2
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PUSH
97225: LD_INT 2
97227: NEG
97228: PUSH
97229: LD_INT 1
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97240: LD_ADDR_VAR 0 52
97244: PUSH
97245: LD_INT 3
97247: NEG
97248: PUSH
97249: LD_INT 1
97251: NEG
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: LD_INT 3
97259: NEG
97260: PUSH
97261: LD_INT 2
97263: NEG
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: EMPTY
97270: LIST
97271: LIST
97272: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97273: LD_ADDR_VAR 0 53
97277: PUSH
97278: LD_INT 1
97280: NEG
97281: PUSH
97282: LD_INT 3
97284: NEG
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 0
97292: PUSH
97293: LD_INT 3
97295: NEG
97296: PUSH
97297: EMPTY
97298: LIST
97299: LIST
97300: PUSH
97301: LD_INT 1
97303: PUSH
97304: LD_INT 2
97306: NEG
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: LIST
97316: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97317: LD_ADDR_VAR 0 54
97321: PUSH
97322: LD_INT 2
97324: PUSH
97325: LD_INT 1
97327: NEG
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PUSH
97333: LD_INT 3
97335: PUSH
97336: LD_INT 0
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PUSH
97343: LD_INT 3
97345: PUSH
97346: LD_INT 1
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: LIST
97357: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97358: LD_ADDR_VAR 0 55
97362: PUSH
97363: LD_INT 3
97365: PUSH
97366: LD_INT 2
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: LD_INT 3
97375: PUSH
97376: LD_INT 3
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 2
97385: PUSH
97386: LD_INT 3
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: LIST
97397: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97398: LD_ADDR_VAR 0 56
97402: PUSH
97403: LD_INT 1
97405: PUSH
97406: LD_INT 3
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: LD_INT 0
97415: PUSH
97416: LD_INT 3
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PUSH
97423: LD_INT 1
97425: NEG
97426: PUSH
97427: LD_INT 2
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: LIST
97438: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97439: LD_ADDR_VAR 0 57
97443: PUSH
97444: LD_INT 2
97446: NEG
97447: PUSH
97448: LD_INT 1
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PUSH
97455: LD_INT 3
97457: NEG
97458: PUSH
97459: LD_INT 0
97461: PUSH
97462: EMPTY
97463: LIST
97464: LIST
97465: PUSH
97466: LD_INT 3
97468: NEG
97469: PUSH
97470: LD_INT 1
97472: NEG
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: PUSH
97478: EMPTY
97479: LIST
97480: LIST
97481: LIST
97482: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97483: LD_ADDR_VAR 0 58
97487: PUSH
97488: LD_INT 2
97490: NEG
97491: PUSH
97492: LD_INT 3
97494: NEG
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 3
97502: NEG
97503: PUSH
97504: LD_INT 2
97506: NEG
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: PUSH
97512: LD_INT 3
97514: NEG
97515: PUSH
97516: LD_INT 3
97518: NEG
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: LIST
97528: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
97529: LD_ADDR_VAR 0 59
97533: PUSH
97534: LD_INT 1
97536: NEG
97537: PUSH
97538: LD_INT 2
97540: NEG
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: LD_INT 0
97548: PUSH
97549: LD_INT 2
97551: NEG
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PUSH
97557: LD_INT 1
97559: PUSH
97560: LD_INT 1
97562: NEG
97563: PUSH
97564: EMPTY
97565: LIST
97566: LIST
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: LIST
97572: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
97573: LD_ADDR_VAR 0 60
97577: PUSH
97578: LD_INT 1
97580: PUSH
97581: LD_INT 1
97583: NEG
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: PUSH
97589: LD_INT 2
97591: PUSH
97592: LD_INT 0
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 2
97601: PUSH
97602: LD_INT 1
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: EMPTY
97610: LIST
97611: LIST
97612: LIST
97613: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
97614: LD_ADDR_VAR 0 61
97618: PUSH
97619: LD_INT 2
97621: PUSH
97622: LD_INT 1
97624: PUSH
97625: EMPTY
97626: LIST
97627: LIST
97628: PUSH
97629: LD_INT 2
97631: PUSH
97632: LD_INT 2
97634: PUSH
97635: EMPTY
97636: LIST
97637: LIST
97638: PUSH
97639: LD_INT 1
97641: PUSH
97642: LD_INT 2
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: LIST
97653: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
97654: LD_ADDR_VAR 0 62
97658: PUSH
97659: LD_INT 1
97661: PUSH
97662: LD_INT 2
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: LD_INT 0
97671: PUSH
97672: LD_INT 2
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: PUSH
97679: LD_INT 1
97681: NEG
97682: PUSH
97683: LD_INT 1
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: LIST
97694: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
97695: LD_ADDR_VAR 0 63
97699: PUSH
97700: LD_INT 1
97702: NEG
97703: PUSH
97704: LD_INT 1
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: PUSH
97711: LD_INT 2
97713: NEG
97714: PUSH
97715: LD_INT 0
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: PUSH
97722: LD_INT 2
97724: NEG
97725: PUSH
97726: LD_INT 1
97728: NEG
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: LIST
97738: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
97739: LD_ADDR_VAR 0 64
97743: PUSH
97744: LD_INT 1
97746: NEG
97747: PUSH
97748: LD_INT 2
97750: NEG
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 2
97758: NEG
97759: PUSH
97760: LD_INT 1
97762: NEG
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 2
97770: NEG
97771: PUSH
97772: LD_INT 2
97774: NEG
97775: PUSH
97776: EMPTY
97777: LIST
97778: LIST
97779: PUSH
97780: EMPTY
97781: LIST
97782: LIST
97783: LIST
97784: ST_TO_ADDR
// end ; 2 :
97785: GO 101051
97787: LD_INT 2
97789: DOUBLE
97790: EQUAL
97791: IFTRUE 97795
97793: GO 101050
97795: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
97796: LD_ADDR_VAR 0 29
97800: PUSH
97801: LD_INT 4
97803: PUSH
97804: LD_INT 0
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PUSH
97811: LD_INT 4
97813: PUSH
97814: LD_INT 1
97816: NEG
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: LD_INT 5
97824: PUSH
97825: LD_INT 0
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 5
97834: PUSH
97835: LD_INT 1
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 4
97844: PUSH
97845: LD_INT 1
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 3
97854: PUSH
97855: LD_INT 0
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 3
97864: PUSH
97865: LD_INT 1
97867: NEG
97868: PUSH
97869: EMPTY
97870: LIST
97871: LIST
97872: PUSH
97873: LD_INT 3
97875: PUSH
97876: LD_INT 2
97878: NEG
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: PUSH
97884: LD_INT 5
97886: PUSH
97887: LD_INT 2
97889: PUSH
97890: EMPTY
97891: LIST
97892: LIST
97893: PUSH
97894: LD_INT 3
97896: PUSH
97897: LD_INT 3
97899: PUSH
97900: EMPTY
97901: LIST
97902: LIST
97903: PUSH
97904: LD_INT 3
97906: PUSH
97907: LD_INT 2
97909: PUSH
97910: EMPTY
97911: LIST
97912: LIST
97913: PUSH
97914: LD_INT 4
97916: PUSH
97917: LD_INT 3
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 4
97926: PUSH
97927: LD_INT 4
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: LD_INT 3
97936: PUSH
97937: LD_INT 4
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: PUSH
97944: LD_INT 2
97946: PUSH
97947: LD_INT 3
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: PUSH
97954: LD_INT 2
97956: PUSH
97957: LD_INT 2
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PUSH
97964: LD_INT 4
97966: PUSH
97967: LD_INT 2
97969: PUSH
97970: EMPTY
97971: LIST
97972: LIST
97973: PUSH
97974: LD_INT 2
97976: PUSH
97977: LD_INT 4
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: LD_INT 0
97986: PUSH
97987: LD_INT 4
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: LD_INT 0
97996: PUSH
97997: LD_INT 3
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 1
98006: PUSH
98007: LD_INT 4
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: PUSH
98014: LD_INT 1
98016: PUSH
98017: LD_INT 5
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PUSH
98024: LD_INT 0
98026: PUSH
98027: LD_INT 5
98029: PUSH
98030: EMPTY
98031: LIST
98032: LIST
98033: PUSH
98034: LD_INT 1
98036: NEG
98037: PUSH
98038: LD_INT 4
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 1
98047: NEG
98048: PUSH
98049: LD_INT 3
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 2
98058: PUSH
98059: LD_INT 5
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 2
98068: NEG
98069: PUSH
98070: LD_INT 3
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: PUSH
98077: LD_INT 3
98079: NEG
98080: PUSH
98081: LD_INT 0
98083: PUSH
98084: EMPTY
98085: LIST
98086: LIST
98087: PUSH
98088: LD_INT 3
98090: NEG
98091: PUSH
98092: LD_INT 1
98094: NEG
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: PUSH
98100: LD_INT 2
98102: NEG
98103: PUSH
98104: LD_INT 0
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: LD_INT 2
98113: NEG
98114: PUSH
98115: LD_INT 1
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 3
98124: NEG
98125: PUSH
98126: LD_INT 1
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PUSH
98133: LD_INT 4
98135: NEG
98136: PUSH
98137: LD_INT 0
98139: PUSH
98140: EMPTY
98141: LIST
98142: LIST
98143: PUSH
98144: LD_INT 4
98146: NEG
98147: PUSH
98148: LD_INT 1
98150: NEG
98151: PUSH
98152: EMPTY
98153: LIST
98154: LIST
98155: PUSH
98156: LD_INT 4
98158: NEG
98159: PUSH
98160: LD_INT 2
98162: NEG
98163: PUSH
98164: EMPTY
98165: LIST
98166: LIST
98167: PUSH
98168: LD_INT 2
98170: NEG
98171: PUSH
98172: LD_INT 2
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: PUSH
98179: LD_INT 4
98181: NEG
98182: PUSH
98183: LD_INT 4
98185: NEG
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: PUSH
98191: LD_INT 4
98193: NEG
98194: PUSH
98195: LD_INT 5
98197: NEG
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: PUSH
98203: LD_INT 3
98205: NEG
98206: PUSH
98207: LD_INT 4
98209: NEG
98210: PUSH
98211: EMPTY
98212: LIST
98213: LIST
98214: PUSH
98215: LD_INT 3
98217: NEG
98218: PUSH
98219: LD_INT 3
98221: NEG
98222: PUSH
98223: EMPTY
98224: LIST
98225: LIST
98226: PUSH
98227: LD_INT 4
98229: NEG
98230: PUSH
98231: LD_INT 3
98233: NEG
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PUSH
98239: LD_INT 5
98241: NEG
98242: PUSH
98243: LD_INT 4
98245: NEG
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: LD_INT 5
98253: NEG
98254: PUSH
98255: LD_INT 5
98257: NEG
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 3
98265: NEG
98266: PUSH
98267: LD_INT 5
98269: NEG
98270: PUSH
98271: EMPTY
98272: LIST
98273: LIST
98274: PUSH
98275: LD_INT 5
98277: NEG
98278: PUSH
98279: LD_INT 3
98281: NEG
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98334: LD_ADDR_VAR 0 30
98338: PUSH
98339: LD_INT 4
98341: PUSH
98342: LD_INT 4
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 4
98351: PUSH
98352: LD_INT 3
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 5
98361: PUSH
98362: LD_INT 4
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 5
98371: PUSH
98372: LD_INT 5
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PUSH
98379: LD_INT 4
98381: PUSH
98382: LD_INT 5
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: PUSH
98389: LD_INT 3
98391: PUSH
98392: LD_INT 4
98394: PUSH
98395: EMPTY
98396: LIST
98397: LIST
98398: PUSH
98399: LD_INT 3
98401: PUSH
98402: LD_INT 3
98404: PUSH
98405: EMPTY
98406: LIST
98407: LIST
98408: PUSH
98409: LD_INT 5
98411: PUSH
98412: LD_INT 3
98414: PUSH
98415: EMPTY
98416: LIST
98417: LIST
98418: PUSH
98419: LD_INT 3
98421: PUSH
98422: LD_INT 5
98424: PUSH
98425: EMPTY
98426: LIST
98427: LIST
98428: PUSH
98429: LD_INT 0
98431: PUSH
98432: LD_INT 3
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: LD_INT 0
98441: PUSH
98442: LD_INT 2
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 1
98451: PUSH
98452: LD_INT 3
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: LD_INT 1
98461: PUSH
98462: LD_INT 4
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 0
98471: PUSH
98472: LD_INT 4
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: PUSH
98479: LD_INT 1
98481: NEG
98482: PUSH
98483: LD_INT 3
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: PUSH
98490: LD_INT 1
98492: NEG
98493: PUSH
98494: LD_INT 2
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PUSH
98501: LD_INT 2
98503: PUSH
98504: LD_INT 4
98506: PUSH
98507: EMPTY
98508: LIST
98509: LIST
98510: PUSH
98511: LD_INT 2
98513: NEG
98514: PUSH
98515: LD_INT 2
98517: PUSH
98518: EMPTY
98519: LIST
98520: LIST
98521: PUSH
98522: LD_INT 4
98524: NEG
98525: PUSH
98526: LD_INT 0
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PUSH
98533: LD_INT 4
98535: NEG
98536: PUSH
98537: LD_INT 1
98539: NEG
98540: PUSH
98541: EMPTY
98542: LIST
98543: LIST
98544: PUSH
98545: LD_INT 3
98547: NEG
98548: PUSH
98549: LD_INT 0
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 3
98558: NEG
98559: PUSH
98560: LD_INT 1
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 4
98569: NEG
98570: PUSH
98571: LD_INT 1
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 5
98580: NEG
98581: PUSH
98582: LD_INT 0
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: LD_INT 5
98591: NEG
98592: PUSH
98593: LD_INT 1
98595: NEG
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: PUSH
98601: LD_INT 5
98603: NEG
98604: PUSH
98605: LD_INT 2
98607: NEG
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: PUSH
98613: LD_INT 3
98615: NEG
98616: PUSH
98617: LD_INT 2
98619: PUSH
98620: EMPTY
98621: LIST
98622: LIST
98623: PUSH
98624: LD_INT 3
98626: NEG
98627: PUSH
98628: LD_INT 3
98630: NEG
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 3
98638: NEG
98639: PUSH
98640: LD_INT 4
98642: NEG
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: LD_INT 2
98650: NEG
98651: PUSH
98652: LD_INT 3
98654: NEG
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: PUSH
98660: LD_INT 2
98662: NEG
98663: PUSH
98664: LD_INT 2
98666: NEG
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 3
98674: NEG
98675: PUSH
98676: LD_INT 2
98678: NEG
98679: PUSH
98680: EMPTY
98681: LIST
98682: LIST
98683: PUSH
98684: LD_INT 4
98686: NEG
98687: PUSH
98688: LD_INT 3
98690: NEG
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PUSH
98696: LD_INT 4
98698: NEG
98699: PUSH
98700: LD_INT 4
98702: NEG
98703: PUSH
98704: EMPTY
98705: LIST
98706: LIST
98707: PUSH
98708: LD_INT 2
98710: NEG
98711: PUSH
98712: LD_INT 4
98714: NEG
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: LD_INT 4
98722: NEG
98723: PUSH
98724: LD_INT 2
98726: NEG
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: PUSH
98732: LD_INT 0
98734: PUSH
98735: LD_INT 4
98737: NEG
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: LD_INT 0
98745: PUSH
98746: LD_INT 5
98748: NEG
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 1
98756: PUSH
98757: LD_INT 4
98759: NEG
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 1
98767: PUSH
98768: LD_INT 3
98770: NEG
98771: PUSH
98772: EMPTY
98773: LIST
98774: LIST
98775: PUSH
98776: LD_INT 0
98778: PUSH
98779: LD_INT 3
98781: NEG
98782: PUSH
98783: EMPTY
98784: LIST
98785: LIST
98786: PUSH
98787: LD_INT 1
98789: NEG
98790: PUSH
98791: LD_INT 4
98793: NEG
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PUSH
98799: LD_INT 1
98801: NEG
98802: PUSH
98803: LD_INT 5
98805: NEG
98806: PUSH
98807: EMPTY
98808: LIST
98809: LIST
98810: PUSH
98811: LD_INT 2
98813: PUSH
98814: LD_INT 3
98816: NEG
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: PUSH
98822: LD_INT 2
98824: NEG
98825: PUSH
98826: LD_INT 5
98828: NEG
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
98881: LD_ADDR_VAR 0 31
98885: PUSH
98886: LD_INT 0
98888: PUSH
98889: LD_INT 4
98891: PUSH
98892: EMPTY
98893: LIST
98894: LIST
98895: PUSH
98896: LD_INT 0
98898: PUSH
98899: LD_INT 3
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: LD_INT 1
98908: PUSH
98909: LD_INT 4
98911: PUSH
98912: EMPTY
98913: LIST
98914: LIST
98915: PUSH
98916: LD_INT 1
98918: PUSH
98919: LD_INT 5
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: PUSH
98926: LD_INT 0
98928: PUSH
98929: LD_INT 5
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_INT 1
98938: NEG
98939: PUSH
98940: LD_INT 4
98942: PUSH
98943: EMPTY
98944: LIST
98945: LIST
98946: PUSH
98947: LD_INT 1
98949: NEG
98950: PUSH
98951: LD_INT 3
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PUSH
98958: LD_INT 2
98960: PUSH
98961: LD_INT 5
98963: PUSH
98964: EMPTY
98965: LIST
98966: LIST
98967: PUSH
98968: LD_INT 2
98970: NEG
98971: PUSH
98972: LD_INT 3
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PUSH
98979: LD_INT 3
98981: NEG
98982: PUSH
98983: LD_INT 0
98985: PUSH
98986: EMPTY
98987: LIST
98988: LIST
98989: PUSH
98990: LD_INT 3
98992: NEG
98993: PUSH
98994: LD_INT 1
98996: NEG
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 2
99004: NEG
99005: PUSH
99006: LD_INT 0
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PUSH
99013: LD_INT 2
99015: NEG
99016: PUSH
99017: LD_INT 1
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: PUSH
99024: LD_INT 3
99026: NEG
99027: PUSH
99028: LD_INT 1
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: PUSH
99035: LD_INT 4
99037: NEG
99038: PUSH
99039: LD_INT 0
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 4
99048: NEG
99049: PUSH
99050: LD_INT 1
99052: NEG
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: LD_INT 4
99060: NEG
99061: PUSH
99062: LD_INT 2
99064: NEG
99065: PUSH
99066: EMPTY
99067: LIST
99068: LIST
99069: PUSH
99070: LD_INT 2
99072: NEG
99073: PUSH
99074: LD_INT 2
99076: PUSH
99077: EMPTY
99078: LIST
99079: LIST
99080: PUSH
99081: LD_INT 4
99083: NEG
99084: PUSH
99085: LD_INT 4
99087: NEG
99088: PUSH
99089: EMPTY
99090: LIST
99091: LIST
99092: PUSH
99093: LD_INT 4
99095: NEG
99096: PUSH
99097: LD_INT 5
99099: NEG
99100: PUSH
99101: EMPTY
99102: LIST
99103: LIST
99104: PUSH
99105: LD_INT 3
99107: NEG
99108: PUSH
99109: LD_INT 4
99111: NEG
99112: PUSH
99113: EMPTY
99114: LIST
99115: LIST
99116: PUSH
99117: LD_INT 3
99119: NEG
99120: PUSH
99121: LD_INT 3
99123: NEG
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PUSH
99129: LD_INT 4
99131: NEG
99132: PUSH
99133: LD_INT 3
99135: NEG
99136: PUSH
99137: EMPTY
99138: LIST
99139: LIST
99140: PUSH
99141: LD_INT 5
99143: NEG
99144: PUSH
99145: LD_INT 4
99147: NEG
99148: PUSH
99149: EMPTY
99150: LIST
99151: LIST
99152: PUSH
99153: LD_INT 5
99155: NEG
99156: PUSH
99157: LD_INT 5
99159: NEG
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: PUSH
99165: LD_INT 3
99167: NEG
99168: PUSH
99169: LD_INT 5
99171: NEG
99172: PUSH
99173: EMPTY
99174: LIST
99175: LIST
99176: PUSH
99177: LD_INT 5
99179: NEG
99180: PUSH
99181: LD_INT 3
99183: NEG
99184: PUSH
99185: EMPTY
99186: LIST
99187: LIST
99188: PUSH
99189: LD_INT 0
99191: PUSH
99192: LD_INT 3
99194: NEG
99195: PUSH
99196: EMPTY
99197: LIST
99198: LIST
99199: PUSH
99200: LD_INT 0
99202: PUSH
99203: LD_INT 4
99205: NEG
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 1
99213: PUSH
99214: LD_INT 3
99216: NEG
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 1
99224: PUSH
99225: LD_INT 2
99227: NEG
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PUSH
99233: LD_INT 0
99235: PUSH
99236: LD_INT 2
99238: NEG
99239: PUSH
99240: EMPTY
99241: LIST
99242: LIST
99243: PUSH
99244: LD_INT 1
99246: NEG
99247: PUSH
99248: LD_INT 3
99250: NEG
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: PUSH
99256: LD_INT 1
99258: NEG
99259: PUSH
99260: LD_INT 4
99262: NEG
99263: PUSH
99264: EMPTY
99265: LIST
99266: LIST
99267: PUSH
99268: LD_INT 2
99270: PUSH
99271: LD_INT 2
99273: NEG
99274: PUSH
99275: EMPTY
99276: LIST
99277: LIST
99278: PUSH
99279: LD_INT 2
99281: NEG
99282: PUSH
99283: LD_INT 4
99285: NEG
99286: PUSH
99287: EMPTY
99288: LIST
99289: LIST
99290: PUSH
99291: LD_INT 4
99293: PUSH
99294: LD_INT 0
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: PUSH
99301: LD_INT 4
99303: PUSH
99304: LD_INT 1
99306: NEG
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 5
99314: PUSH
99315: LD_INT 0
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: PUSH
99322: LD_INT 5
99324: PUSH
99325: LD_INT 1
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: LD_INT 4
99334: PUSH
99335: LD_INT 1
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PUSH
99342: LD_INT 3
99344: PUSH
99345: LD_INT 0
99347: PUSH
99348: EMPTY
99349: LIST
99350: LIST
99351: PUSH
99352: LD_INT 3
99354: PUSH
99355: LD_INT 1
99357: NEG
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: LD_INT 3
99365: PUSH
99366: LD_INT 2
99368: NEG
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: PUSH
99374: LD_INT 5
99376: PUSH
99377: LD_INT 2
99379: PUSH
99380: EMPTY
99381: LIST
99382: LIST
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
99431: LD_ADDR_VAR 0 32
99435: PUSH
99436: LD_INT 4
99438: NEG
99439: PUSH
99440: LD_INT 0
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PUSH
99447: LD_INT 4
99449: NEG
99450: PUSH
99451: LD_INT 1
99453: NEG
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: PUSH
99459: LD_INT 3
99461: NEG
99462: PUSH
99463: LD_INT 0
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PUSH
99470: LD_INT 3
99472: NEG
99473: PUSH
99474: LD_INT 1
99476: PUSH
99477: EMPTY
99478: LIST
99479: LIST
99480: PUSH
99481: LD_INT 4
99483: NEG
99484: PUSH
99485: LD_INT 1
99487: PUSH
99488: EMPTY
99489: LIST
99490: LIST
99491: PUSH
99492: LD_INT 5
99494: NEG
99495: PUSH
99496: LD_INT 0
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: PUSH
99503: LD_INT 5
99505: NEG
99506: PUSH
99507: LD_INT 1
99509: NEG
99510: PUSH
99511: EMPTY
99512: LIST
99513: LIST
99514: PUSH
99515: LD_INT 5
99517: NEG
99518: PUSH
99519: LD_INT 2
99521: NEG
99522: PUSH
99523: EMPTY
99524: LIST
99525: LIST
99526: PUSH
99527: LD_INT 3
99529: NEG
99530: PUSH
99531: LD_INT 2
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PUSH
99538: LD_INT 3
99540: NEG
99541: PUSH
99542: LD_INT 3
99544: NEG
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: PUSH
99550: LD_INT 3
99552: NEG
99553: PUSH
99554: LD_INT 4
99556: NEG
99557: PUSH
99558: EMPTY
99559: LIST
99560: LIST
99561: PUSH
99562: LD_INT 2
99564: NEG
99565: PUSH
99566: LD_INT 3
99568: NEG
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: LD_INT 2
99576: NEG
99577: PUSH
99578: LD_INT 2
99580: NEG
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: LD_INT 3
99588: NEG
99589: PUSH
99590: LD_INT 2
99592: NEG
99593: PUSH
99594: EMPTY
99595: LIST
99596: LIST
99597: PUSH
99598: LD_INT 4
99600: NEG
99601: PUSH
99602: LD_INT 3
99604: NEG
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: PUSH
99610: LD_INT 4
99612: NEG
99613: PUSH
99614: LD_INT 4
99616: NEG
99617: PUSH
99618: EMPTY
99619: LIST
99620: LIST
99621: PUSH
99622: LD_INT 2
99624: NEG
99625: PUSH
99626: LD_INT 4
99628: NEG
99629: PUSH
99630: EMPTY
99631: LIST
99632: LIST
99633: PUSH
99634: LD_INT 4
99636: NEG
99637: PUSH
99638: LD_INT 2
99640: NEG
99641: PUSH
99642: EMPTY
99643: LIST
99644: LIST
99645: PUSH
99646: LD_INT 0
99648: PUSH
99649: LD_INT 4
99651: NEG
99652: PUSH
99653: EMPTY
99654: LIST
99655: LIST
99656: PUSH
99657: LD_INT 0
99659: PUSH
99660: LD_INT 5
99662: NEG
99663: PUSH
99664: EMPTY
99665: LIST
99666: LIST
99667: PUSH
99668: LD_INT 1
99670: PUSH
99671: LD_INT 4
99673: NEG
99674: PUSH
99675: EMPTY
99676: LIST
99677: LIST
99678: PUSH
99679: LD_INT 1
99681: PUSH
99682: LD_INT 3
99684: NEG
99685: PUSH
99686: EMPTY
99687: LIST
99688: LIST
99689: PUSH
99690: LD_INT 0
99692: PUSH
99693: LD_INT 3
99695: NEG
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: PUSH
99701: LD_INT 1
99703: NEG
99704: PUSH
99705: LD_INT 4
99707: NEG
99708: PUSH
99709: EMPTY
99710: LIST
99711: LIST
99712: PUSH
99713: LD_INT 1
99715: NEG
99716: PUSH
99717: LD_INT 5
99719: NEG
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 2
99727: PUSH
99728: LD_INT 3
99730: NEG
99731: PUSH
99732: EMPTY
99733: LIST
99734: LIST
99735: PUSH
99736: LD_INT 2
99738: NEG
99739: PUSH
99740: LD_INT 5
99742: NEG
99743: PUSH
99744: EMPTY
99745: LIST
99746: LIST
99747: PUSH
99748: LD_INT 3
99750: PUSH
99751: LD_INT 0
99753: PUSH
99754: EMPTY
99755: LIST
99756: LIST
99757: PUSH
99758: LD_INT 3
99760: PUSH
99761: LD_INT 1
99763: NEG
99764: PUSH
99765: EMPTY
99766: LIST
99767: LIST
99768: PUSH
99769: LD_INT 4
99771: PUSH
99772: LD_INT 0
99774: PUSH
99775: EMPTY
99776: LIST
99777: LIST
99778: PUSH
99779: LD_INT 4
99781: PUSH
99782: LD_INT 1
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 3
99791: PUSH
99792: LD_INT 1
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: PUSH
99799: LD_INT 2
99801: PUSH
99802: LD_INT 0
99804: PUSH
99805: EMPTY
99806: LIST
99807: LIST
99808: PUSH
99809: LD_INT 2
99811: PUSH
99812: LD_INT 1
99814: NEG
99815: PUSH
99816: EMPTY
99817: LIST
99818: LIST
99819: PUSH
99820: LD_INT 2
99822: PUSH
99823: LD_INT 2
99825: NEG
99826: PUSH
99827: EMPTY
99828: LIST
99829: LIST
99830: PUSH
99831: LD_INT 4
99833: PUSH
99834: LD_INT 2
99836: PUSH
99837: EMPTY
99838: LIST
99839: LIST
99840: PUSH
99841: LD_INT 4
99843: PUSH
99844: LD_INT 4
99846: PUSH
99847: EMPTY
99848: LIST
99849: LIST
99850: PUSH
99851: LD_INT 4
99853: PUSH
99854: LD_INT 3
99856: PUSH
99857: EMPTY
99858: LIST
99859: LIST
99860: PUSH
99861: LD_INT 5
99863: PUSH
99864: LD_INT 4
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: PUSH
99871: LD_INT 5
99873: PUSH
99874: LD_INT 5
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: PUSH
99881: LD_INT 4
99883: PUSH
99884: LD_INT 5
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 3
99893: PUSH
99894: LD_INT 4
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: LD_INT 3
99903: PUSH
99904: LD_INT 3
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PUSH
99911: LD_INT 5
99913: PUSH
99914: LD_INT 3
99916: PUSH
99917: EMPTY
99918: LIST
99919: LIST
99920: PUSH
99921: LD_INT 3
99923: PUSH
99924: LD_INT 5
99926: PUSH
99927: EMPTY
99928: LIST
99929: LIST
99930: PUSH
99931: EMPTY
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: LIST
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: LIST
99973: LIST
99974: LIST
99975: LIST
99976: LIST
99977: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
99978: LD_ADDR_VAR 0 33
99982: PUSH
99983: LD_INT 4
99985: NEG
99986: PUSH
99987: LD_INT 4
99989: NEG
99990: PUSH
99991: EMPTY
99992: LIST
99993: LIST
99994: PUSH
99995: LD_INT 4
99997: NEG
99998: PUSH
99999: LD_INT 5
100001: NEG
100002: PUSH
100003: EMPTY
100004: LIST
100005: LIST
100006: PUSH
100007: LD_INT 3
100009: NEG
100010: PUSH
100011: LD_INT 4
100013: NEG
100014: PUSH
100015: EMPTY
100016: LIST
100017: LIST
100018: PUSH
100019: LD_INT 3
100021: NEG
100022: PUSH
100023: LD_INT 3
100025: NEG
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: PUSH
100031: LD_INT 4
100033: NEG
100034: PUSH
100035: LD_INT 3
100037: NEG
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 5
100045: NEG
100046: PUSH
100047: LD_INT 4
100049: NEG
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PUSH
100055: LD_INT 5
100057: NEG
100058: PUSH
100059: LD_INT 5
100061: NEG
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PUSH
100067: LD_INT 3
100069: NEG
100070: PUSH
100071: LD_INT 5
100073: NEG
100074: PUSH
100075: EMPTY
100076: LIST
100077: LIST
100078: PUSH
100079: LD_INT 5
100081: NEG
100082: PUSH
100083: LD_INT 3
100085: NEG
100086: PUSH
100087: EMPTY
100088: LIST
100089: LIST
100090: PUSH
100091: LD_INT 0
100093: PUSH
100094: LD_INT 3
100096: NEG
100097: PUSH
100098: EMPTY
100099: LIST
100100: LIST
100101: PUSH
100102: LD_INT 0
100104: PUSH
100105: LD_INT 4
100107: NEG
100108: PUSH
100109: EMPTY
100110: LIST
100111: LIST
100112: PUSH
100113: LD_INT 1
100115: PUSH
100116: LD_INT 3
100118: NEG
100119: PUSH
100120: EMPTY
100121: LIST
100122: LIST
100123: PUSH
100124: LD_INT 1
100126: PUSH
100127: LD_INT 2
100129: NEG
100130: PUSH
100131: EMPTY
100132: LIST
100133: LIST
100134: PUSH
100135: LD_INT 0
100137: PUSH
100138: LD_INT 2
100140: NEG
100141: PUSH
100142: EMPTY
100143: LIST
100144: LIST
100145: PUSH
100146: LD_INT 1
100148: NEG
100149: PUSH
100150: LD_INT 3
100152: NEG
100153: PUSH
100154: EMPTY
100155: LIST
100156: LIST
100157: PUSH
100158: LD_INT 1
100160: NEG
100161: PUSH
100162: LD_INT 4
100164: NEG
100165: PUSH
100166: EMPTY
100167: LIST
100168: LIST
100169: PUSH
100170: LD_INT 2
100172: PUSH
100173: LD_INT 2
100175: NEG
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: PUSH
100181: LD_INT 2
100183: NEG
100184: PUSH
100185: LD_INT 4
100187: NEG
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 4
100195: PUSH
100196: LD_INT 0
100198: PUSH
100199: EMPTY
100200: LIST
100201: LIST
100202: PUSH
100203: LD_INT 4
100205: PUSH
100206: LD_INT 1
100208: NEG
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: PUSH
100214: LD_INT 5
100216: PUSH
100217: LD_INT 0
100219: PUSH
100220: EMPTY
100221: LIST
100222: LIST
100223: PUSH
100224: LD_INT 5
100226: PUSH
100227: LD_INT 1
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: PUSH
100234: LD_INT 4
100236: PUSH
100237: LD_INT 1
100239: PUSH
100240: EMPTY
100241: LIST
100242: LIST
100243: PUSH
100244: LD_INT 3
100246: PUSH
100247: LD_INT 0
100249: PUSH
100250: EMPTY
100251: LIST
100252: LIST
100253: PUSH
100254: LD_INT 3
100256: PUSH
100257: LD_INT 1
100259: NEG
100260: PUSH
100261: EMPTY
100262: LIST
100263: LIST
100264: PUSH
100265: LD_INT 3
100267: PUSH
100268: LD_INT 2
100270: NEG
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: PUSH
100276: LD_INT 5
100278: PUSH
100279: LD_INT 2
100281: PUSH
100282: EMPTY
100283: LIST
100284: LIST
100285: PUSH
100286: LD_INT 3
100288: PUSH
100289: LD_INT 3
100291: PUSH
100292: EMPTY
100293: LIST
100294: LIST
100295: PUSH
100296: LD_INT 3
100298: PUSH
100299: LD_INT 2
100301: PUSH
100302: EMPTY
100303: LIST
100304: LIST
100305: PUSH
100306: LD_INT 4
100308: PUSH
100309: LD_INT 3
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: LD_INT 4
100318: PUSH
100319: LD_INT 4
100321: PUSH
100322: EMPTY
100323: LIST
100324: LIST
100325: PUSH
100326: LD_INT 3
100328: PUSH
100329: LD_INT 4
100331: PUSH
100332: EMPTY
100333: LIST
100334: LIST
100335: PUSH
100336: LD_INT 2
100338: PUSH
100339: LD_INT 3
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: PUSH
100346: LD_INT 2
100348: PUSH
100349: LD_INT 2
100351: PUSH
100352: EMPTY
100353: LIST
100354: LIST
100355: PUSH
100356: LD_INT 4
100358: PUSH
100359: LD_INT 2
100361: PUSH
100362: EMPTY
100363: LIST
100364: LIST
100365: PUSH
100366: LD_INT 2
100368: PUSH
100369: LD_INT 4
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 0
100378: PUSH
100379: LD_INT 4
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PUSH
100386: LD_INT 0
100388: PUSH
100389: LD_INT 3
100391: PUSH
100392: EMPTY
100393: LIST
100394: LIST
100395: PUSH
100396: LD_INT 1
100398: PUSH
100399: LD_INT 4
100401: PUSH
100402: EMPTY
100403: LIST
100404: LIST
100405: PUSH
100406: LD_INT 1
100408: PUSH
100409: LD_INT 5
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: PUSH
100416: LD_INT 0
100418: PUSH
100419: LD_INT 5
100421: PUSH
100422: EMPTY
100423: LIST
100424: LIST
100425: PUSH
100426: LD_INT 1
100428: NEG
100429: PUSH
100430: LD_INT 4
100432: PUSH
100433: EMPTY
100434: LIST
100435: LIST
100436: PUSH
100437: LD_INT 1
100439: NEG
100440: PUSH
100441: LD_INT 3
100443: PUSH
100444: EMPTY
100445: LIST
100446: LIST
100447: PUSH
100448: LD_INT 2
100450: PUSH
100451: LD_INT 5
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: PUSH
100458: LD_INT 2
100460: NEG
100461: PUSH
100462: LD_INT 3
100464: PUSH
100465: EMPTY
100466: LIST
100467: LIST
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: LIST
100511: LIST
100512: LIST
100513: LIST
100514: LIST
100515: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
100516: LD_ADDR_VAR 0 34
100520: PUSH
100521: LD_INT 0
100523: PUSH
100524: LD_INT 4
100526: NEG
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: PUSH
100532: LD_INT 0
100534: PUSH
100535: LD_INT 5
100537: NEG
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: LD_INT 1
100545: PUSH
100546: LD_INT 4
100548: NEG
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: LD_INT 1
100556: PUSH
100557: LD_INT 3
100559: NEG
100560: PUSH
100561: EMPTY
100562: LIST
100563: LIST
100564: PUSH
100565: LD_INT 0
100567: PUSH
100568: LD_INT 3
100570: NEG
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: PUSH
100576: LD_INT 1
100578: NEG
100579: PUSH
100580: LD_INT 4
100582: NEG
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 1
100590: NEG
100591: PUSH
100592: LD_INT 5
100594: NEG
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PUSH
100600: LD_INT 2
100602: PUSH
100603: LD_INT 3
100605: NEG
100606: PUSH
100607: EMPTY
100608: LIST
100609: LIST
100610: PUSH
100611: LD_INT 2
100613: NEG
100614: PUSH
100615: LD_INT 5
100617: NEG
100618: PUSH
100619: EMPTY
100620: LIST
100621: LIST
100622: PUSH
100623: LD_INT 3
100625: PUSH
100626: LD_INT 0
100628: PUSH
100629: EMPTY
100630: LIST
100631: LIST
100632: PUSH
100633: LD_INT 3
100635: PUSH
100636: LD_INT 1
100638: NEG
100639: PUSH
100640: EMPTY
100641: LIST
100642: LIST
100643: PUSH
100644: LD_INT 4
100646: PUSH
100647: LD_INT 0
100649: PUSH
100650: EMPTY
100651: LIST
100652: LIST
100653: PUSH
100654: LD_INT 4
100656: PUSH
100657: LD_INT 1
100659: PUSH
100660: EMPTY
100661: LIST
100662: LIST
100663: PUSH
100664: LD_INT 3
100666: PUSH
100667: LD_INT 1
100669: PUSH
100670: EMPTY
100671: LIST
100672: LIST
100673: PUSH
100674: LD_INT 2
100676: PUSH
100677: LD_INT 0
100679: PUSH
100680: EMPTY
100681: LIST
100682: LIST
100683: PUSH
100684: LD_INT 2
100686: PUSH
100687: LD_INT 1
100689: NEG
100690: PUSH
100691: EMPTY
100692: LIST
100693: LIST
100694: PUSH
100695: LD_INT 2
100697: PUSH
100698: LD_INT 2
100700: NEG
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: PUSH
100706: LD_INT 4
100708: PUSH
100709: LD_INT 2
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: LD_INT 4
100718: PUSH
100719: LD_INT 4
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PUSH
100726: LD_INT 4
100728: PUSH
100729: LD_INT 3
100731: PUSH
100732: EMPTY
100733: LIST
100734: LIST
100735: PUSH
100736: LD_INT 5
100738: PUSH
100739: LD_INT 4
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: PUSH
100746: LD_INT 5
100748: PUSH
100749: LD_INT 5
100751: PUSH
100752: EMPTY
100753: LIST
100754: LIST
100755: PUSH
100756: LD_INT 4
100758: PUSH
100759: LD_INT 5
100761: PUSH
100762: EMPTY
100763: LIST
100764: LIST
100765: PUSH
100766: LD_INT 3
100768: PUSH
100769: LD_INT 4
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: PUSH
100776: LD_INT 3
100778: PUSH
100779: LD_INT 3
100781: PUSH
100782: EMPTY
100783: LIST
100784: LIST
100785: PUSH
100786: LD_INT 5
100788: PUSH
100789: LD_INT 3
100791: PUSH
100792: EMPTY
100793: LIST
100794: LIST
100795: PUSH
100796: LD_INT 3
100798: PUSH
100799: LD_INT 5
100801: PUSH
100802: EMPTY
100803: LIST
100804: LIST
100805: PUSH
100806: LD_INT 0
100808: PUSH
100809: LD_INT 3
100811: PUSH
100812: EMPTY
100813: LIST
100814: LIST
100815: PUSH
100816: LD_INT 0
100818: PUSH
100819: LD_INT 2
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PUSH
100826: LD_INT 1
100828: PUSH
100829: LD_INT 3
100831: PUSH
100832: EMPTY
100833: LIST
100834: LIST
100835: PUSH
100836: LD_INT 1
100838: PUSH
100839: LD_INT 4
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: PUSH
100846: LD_INT 0
100848: PUSH
100849: LD_INT 4
100851: PUSH
100852: EMPTY
100853: LIST
100854: LIST
100855: PUSH
100856: LD_INT 1
100858: NEG
100859: PUSH
100860: LD_INT 3
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: PUSH
100867: LD_INT 1
100869: NEG
100870: PUSH
100871: LD_INT 2
100873: PUSH
100874: EMPTY
100875: LIST
100876: LIST
100877: PUSH
100878: LD_INT 2
100880: PUSH
100881: LD_INT 4
100883: PUSH
100884: EMPTY
100885: LIST
100886: LIST
100887: PUSH
100888: LD_INT 2
100890: NEG
100891: PUSH
100892: LD_INT 2
100894: PUSH
100895: EMPTY
100896: LIST
100897: LIST
100898: PUSH
100899: LD_INT 4
100901: NEG
100902: PUSH
100903: LD_INT 0
100905: PUSH
100906: EMPTY
100907: LIST
100908: LIST
100909: PUSH
100910: LD_INT 4
100912: NEG
100913: PUSH
100914: LD_INT 1
100916: NEG
100917: PUSH
100918: EMPTY
100919: LIST
100920: LIST
100921: PUSH
100922: LD_INT 3
100924: NEG
100925: PUSH
100926: LD_INT 0
100928: PUSH
100929: EMPTY
100930: LIST
100931: LIST
100932: PUSH
100933: LD_INT 3
100935: NEG
100936: PUSH
100937: LD_INT 1
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: PUSH
100944: LD_INT 4
100946: NEG
100947: PUSH
100948: LD_INT 1
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PUSH
100955: LD_INT 5
100957: NEG
100958: PUSH
100959: LD_INT 0
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PUSH
100966: LD_INT 5
100968: NEG
100969: PUSH
100970: LD_INT 1
100972: NEG
100973: PUSH
100974: EMPTY
100975: LIST
100976: LIST
100977: PUSH
100978: LD_INT 5
100980: NEG
100981: PUSH
100982: LD_INT 2
100984: NEG
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PUSH
100990: LD_INT 3
100992: NEG
100993: PUSH
100994: LD_INT 2
100996: PUSH
100997: EMPTY
100998: LIST
100999: LIST
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: LIST
101005: LIST
101006: LIST
101007: LIST
101008: LIST
101009: LIST
101010: LIST
101011: LIST
101012: LIST
101013: LIST
101014: LIST
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: LIST
101032: LIST
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: LIST
101047: ST_TO_ADDR
// end ; end ;
101048: GO 101051
101050: POP
// case btype of b_depot , b_warehouse :
101051: LD_VAR 0 1
101055: PUSH
101056: LD_INT 0
101058: DOUBLE
101059: EQUAL
101060: IFTRUE 101070
101062: LD_INT 1
101064: DOUBLE
101065: EQUAL
101066: IFTRUE 101070
101068: GO 101271
101070: POP
// case nation of nation_american :
101071: LD_VAR 0 5
101075: PUSH
101076: LD_INT 1
101078: DOUBLE
101079: EQUAL
101080: IFTRUE 101084
101082: GO 101140
101084: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101085: LD_ADDR_VAR 0 9
101089: PUSH
101090: LD_VAR 0 11
101094: PUSH
101095: LD_VAR 0 12
101099: PUSH
101100: LD_VAR 0 13
101104: PUSH
101105: LD_VAR 0 14
101109: PUSH
101110: LD_VAR 0 15
101114: PUSH
101115: LD_VAR 0 16
101119: PUSH
101120: EMPTY
101121: LIST
101122: LIST
101123: LIST
101124: LIST
101125: LIST
101126: LIST
101127: PUSH
101128: LD_VAR 0 4
101132: PUSH
101133: LD_INT 1
101135: PLUS
101136: ARRAY
101137: ST_TO_ADDR
101138: GO 101269
101140: LD_INT 2
101142: DOUBLE
101143: EQUAL
101144: IFTRUE 101148
101146: GO 101204
101148: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101149: LD_ADDR_VAR 0 9
101153: PUSH
101154: LD_VAR 0 17
101158: PUSH
101159: LD_VAR 0 18
101163: PUSH
101164: LD_VAR 0 19
101168: PUSH
101169: LD_VAR 0 20
101173: PUSH
101174: LD_VAR 0 21
101178: PUSH
101179: LD_VAR 0 22
101183: PUSH
101184: EMPTY
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: PUSH
101192: LD_VAR 0 4
101196: PUSH
101197: LD_INT 1
101199: PLUS
101200: ARRAY
101201: ST_TO_ADDR
101202: GO 101269
101204: LD_INT 3
101206: DOUBLE
101207: EQUAL
101208: IFTRUE 101212
101210: GO 101268
101212: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101213: LD_ADDR_VAR 0 9
101217: PUSH
101218: LD_VAR 0 23
101222: PUSH
101223: LD_VAR 0 24
101227: PUSH
101228: LD_VAR 0 25
101232: PUSH
101233: LD_VAR 0 26
101237: PUSH
101238: LD_VAR 0 27
101242: PUSH
101243: LD_VAR 0 28
101247: PUSH
101248: EMPTY
101249: LIST
101250: LIST
101251: LIST
101252: LIST
101253: LIST
101254: LIST
101255: PUSH
101256: LD_VAR 0 4
101260: PUSH
101261: LD_INT 1
101263: PLUS
101264: ARRAY
101265: ST_TO_ADDR
101266: GO 101269
101268: POP
101269: GO 101824
101271: LD_INT 2
101273: DOUBLE
101274: EQUAL
101275: IFTRUE 101285
101277: LD_INT 3
101279: DOUBLE
101280: EQUAL
101281: IFTRUE 101285
101283: GO 101341
101285: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101286: LD_ADDR_VAR 0 9
101290: PUSH
101291: LD_VAR 0 29
101295: PUSH
101296: LD_VAR 0 30
101300: PUSH
101301: LD_VAR 0 31
101305: PUSH
101306: LD_VAR 0 32
101310: PUSH
101311: LD_VAR 0 33
101315: PUSH
101316: LD_VAR 0 34
101320: PUSH
101321: EMPTY
101322: LIST
101323: LIST
101324: LIST
101325: LIST
101326: LIST
101327: LIST
101328: PUSH
101329: LD_VAR 0 4
101333: PUSH
101334: LD_INT 1
101336: PLUS
101337: ARRAY
101338: ST_TO_ADDR
101339: GO 101824
101341: LD_INT 16
101343: DOUBLE
101344: EQUAL
101345: IFTRUE 101403
101347: LD_INT 17
101349: DOUBLE
101350: EQUAL
101351: IFTRUE 101403
101353: LD_INT 18
101355: DOUBLE
101356: EQUAL
101357: IFTRUE 101403
101359: LD_INT 19
101361: DOUBLE
101362: EQUAL
101363: IFTRUE 101403
101365: LD_INT 22
101367: DOUBLE
101368: EQUAL
101369: IFTRUE 101403
101371: LD_INT 20
101373: DOUBLE
101374: EQUAL
101375: IFTRUE 101403
101377: LD_INT 21
101379: DOUBLE
101380: EQUAL
101381: IFTRUE 101403
101383: LD_INT 23
101385: DOUBLE
101386: EQUAL
101387: IFTRUE 101403
101389: LD_INT 24
101391: DOUBLE
101392: EQUAL
101393: IFTRUE 101403
101395: LD_INT 25
101397: DOUBLE
101398: EQUAL
101399: IFTRUE 101403
101401: GO 101459
101403: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
101404: LD_ADDR_VAR 0 9
101408: PUSH
101409: LD_VAR 0 35
101413: PUSH
101414: LD_VAR 0 36
101418: PUSH
101419: LD_VAR 0 37
101423: PUSH
101424: LD_VAR 0 38
101428: PUSH
101429: LD_VAR 0 39
101433: PUSH
101434: LD_VAR 0 40
101438: PUSH
101439: EMPTY
101440: LIST
101441: LIST
101442: LIST
101443: LIST
101444: LIST
101445: LIST
101446: PUSH
101447: LD_VAR 0 4
101451: PUSH
101452: LD_INT 1
101454: PLUS
101455: ARRAY
101456: ST_TO_ADDR
101457: GO 101824
101459: LD_INT 6
101461: DOUBLE
101462: EQUAL
101463: IFTRUE 101515
101465: LD_INT 7
101467: DOUBLE
101468: EQUAL
101469: IFTRUE 101515
101471: LD_INT 8
101473: DOUBLE
101474: EQUAL
101475: IFTRUE 101515
101477: LD_INT 13
101479: DOUBLE
101480: EQUAL
101481: IFTRUE 101515
101483: LD_INT 12
101485: DOUBLE
101486: EQUAL
101487: IFTRUE 101515
101489: LD_INT 15
101491: DOUBLE
101492: EQUAL
101493: IFTRUE 101515
101495: LD_INT 11
101497: DOUBLE
101498: EQUAL
101499: IFTRUE 101515
101501: LD_INT 14
101503: DOUBLE
101504: EQUAL
101505: IFTRUE 101515
101507: LD_INT 10
101509: DOUBLE
101510: EQUAL
101511: IFTRUE 101515
101513: GO 101571
101515: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
101516: LD_ADDR_VAR 0 9
101520: PUSH
101521: LD_VAR 0 41
101525: PUSH
101526: LD_VAR 0 42
101530: PUSH
101531: LD_VAR 0 43
101535: PUSH
101536: LD_VAR 0 44
101540: PUSH
101541: LD_VAR 0 45
101545: PUSH
101546: LD_VAR 0 46
101550: PUSH
101551: EMPTY
101552: LIST
101553: LIST
101554: LIST
101555: LIST
101556: LIST
101557: LIST
101558: PUSH
101559: LD_VAR 0 4
101563: PUSH
101564: LD_INT 1
101566: PLUS
101567: ARRAY
101568: ST_TO_ADDR
101569: GO 101824
101571: LD_INT 36
101573: DOUBLE
101574: EQUAL
101575: IFTRUE 101579
101577: GO 101635
101579: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
101580: LD_ADDR_VAR 0 9
101584: PUSH
101585: LD_VAR 0 47
101589: PUSH
101590: LD_VAR 0 48
101594: PUSH
101595: LD_VAR 0 49
101599: PUSH
101600: LD_VAR 0 50
101604: PUSH
101605: LD_VAR 0 51
101609: PUSH
101610: LD_VAR 0 52
101614: PUSH
101615: EMPTY
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: LIST
101621: LIST
101622: PUSH
101623: LD_VAR 0 4
101627: PUSH
101628: LD_INT 1
101630: PLUS
101631: ARRAY
101632: ST_TO_ADDR
101633: GO 101824
101635: LD_INT 4
101637: DOUBLE
101638: EQUAL
101639: IFTRUE 101661
101641: LD_INT 5
101643: DOUBLE
101644: EQUAL
101645: IFTRUE 101661
101647: LD_INT 34
101649: DOUBLE
101650: EQUAL
101651: IFTRUE 101661
101653: LD_INT 37
101655: DOUBLE
101656: EQUAL
101657: IFTRUE 101661
101659: GO 101717
101661: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
101662: LD_ADDR_VAR 0 9
101666: PUSH
101667: LD_VAR 0 53
101671: PUSH
101672: LD_VAR 0 54
101676: PUSH
101677: LD_VAR 0 55
101681: PUSH
101682: LD_VAR 0 56
101686: PUSH
101687: LD_VAR 0 57
101691: PUSH
101692: LD_VAR 0 58
101696: PUSH
101697: EMPTY
101698: LIST
101699: LIST
101700: LIST
101701: LIST
101702: LIST
101703: LIST
101704: PUSH
101705: LD_VAR 0 4
101709: PUSH
101710: LD_INT 1
101712: PLUS
101713: ARRAY
101714: ST_TO_ADDR
101715: GO 101824
101717: LD_INT 31
101719: DOUBLE
101720: EQUAL
101721: IFTRUE 101767
101723: LD_INT 32
101725: DOUBLE
101726: EQUAL
101727: IFTRUE 101767
101729: LD_INT 33
101731: DOUBLE
101732: EQUAL
101733: IFTRUE 101767
101735: LD_INT 27
101737: DOUBLE
101738: EQUAL
101739: IFTRUE 101767
101741: LD_INT 26
101743: DOUBLE
101744: EQUAL
101745: IFTRUE 101767
101747: LD_INT 28
101749: DOUBLE
101750: EQUAL
101751: IFTRUE 101767
101753: LD_INT 29
101755: DOUBLE
101756: EQUAL
101757: IFTRUE 101767
101759: LD_INT 30
101761: DOUBLE
101762: EQUAL
101763: IFTRUE 101767
101765: GO 101823
101767: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
101768: LD_ADDR_VAR 0 9
101772: PUSH
101773: LD_VAR 0 59
101777: PUSH
101778: LD_VAR 0 60
101782: PUSH
101783: LD_VAR 0 61
101787: PUSH
101788: LD_VAR 0 62
101792: PUSH
101793: LD_VAR 0 63
101797: PUSH
101798: LD_VAR 0 64
101802: PUSH
101803: EMPTY
101804: LIST
101805: LIST
101806: LIST
101807: LIST
101808: LIST
101809: LIST
101810: PUSH
101811: LD_VAR 0 4
101815: PUSH
101816: LD_INT 1
101818: PLUS
101819: ARRAY
101820: ST_TO_ADDR
101821: GO 101824
101823: POP
// temp_list2 = [ ] ;
101824: LD_ADDR_VAR 0 10
101828: PUSH
101829: EMPTY
101830: ST_TO_ADDR
// for i in temp_list do
101831: LD_ADDR_VAR 0 8
101835: PUSH
101836: LD_VAR 0 9
101840: PUSH
101841: FOR_IN
101842: IFFALSE 101894
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
101844: LD_ADDR_VAR 0 10
101848: PUSH
101849: LD_VAR 0 10
101853: PUSH
101854: LD_VAR 0 8
101858: PUSH
101859: LD_INT 1
101861: ARRAY
101862: PUSH
101863: LD_VAR 0 2
101867: PLUS
101868: PUSH
101869: LD_VAR 0 8
101873: PUSH
101874: LD_INT 2
101876: ARRAY
101877: PUSH
101878: LD_VAR 0 3
101882: PLUS
101883: PUSH
101884: EMPTY
101885: LIST
101886: LIST
101887: PUSH
101888: EMPTY
101889: LIST
101890: ADD
101891: ST_TO_ADDR
101892: GO 101841
101894: POP
101895: POP
// result = temp_list2 ;
101896: LD_ADDR_VAR 0 7
101900: PUSH
101901: LD_VAR 0 10
101905: ST_TO_ADDR
// end ;
101906: LD_VAR 0 7
101910: RET
// export function EnemyInRange ( unit , dist ) ; begin
101911: LD_INT 0
101913: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
101914: LD_ADDR_VAR 0 3
101918: PUSH
101919: LD_VAR 0 1
101923: PPUSH
101924: CALL_OW 255
101928: PPUSH
101929: LD_VAR 0 1
101933: PPUSH
101934: CALL_OW 250
101938: PPUSH
101939: LD_VAR 0 1
101943: PPUSH
101944: CALL_OW 251
101948: PPUSH
101949: LD_VAR 0 2
101953: PPUSH
101954: CALL 75284 0 4
101958: PUSH
101959: LD_INT 4
101961: ARRAY
101962: ST_TO_ADDR
// end ;
101963: LD_VAR 0 3
101967: RET
// export function PlayerSeeMe ( unit ) ; begin
101968: LD_INT 0
101970: PPUSH
// result := See ( your_side , unit ) ;
101971: LD_ADDR_VAR 0 2
101975: PUSH
101976: LD_OWVAR 2
101980: PPUSH
101981: LD_VAR 0 1
101985: PPUSH
101986: CALL_OW 292
101990: ST_TO_ADDR
// end ;
101991: LD_VAR 0 2
101995: RET
// export function ReverseDir ( unit ) ; begin
101996: LD_INT 0
101998: PPUSH
// if not unit then
101999: LD_VAR 0 1
102003: NOT
102004: IFFALSE 102008
// exit ;
102006: GO 102031
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102008: LD_ADDR_VAR 0 2
102012: PUSH
102013: LD_VAR 0 1
102017: PPUSH
102018: CALL_OW 254
102022: PUSH
102023: LD_INT 3
102025: PLUS
102026: PUSH
102027: LD_INT 6
102029: MOD
102030: ST_TO_ADDR
// end ;
102031: LD_VAR 0 2
102035: RET
// export function ReverseArray ( array ) ; var i ; begin
102036: LD_INT 0
102038: PPUSH
102039: PPUSH
// if not array then
102040: LD_VAR 0 1
102044: NOT
102045: IFFALSE 102049
// exit ;
102047: GO 102104
// result := [ ] ;
102049: LD_ADDR_VAR 0 2
102053: PUSH
102054: EMPTY
102055: ST_TO_ADDR
// for i := array downto 1 do
102056: LD_ADDR_VAR 0 3
102060: PUSH
102061: DOUBLE
102062: LD_VAR 0 1
102066: INC
102067: ST_TO_ADDR
102068: LD_INT 1
102070: PUSH
102071: FOR_DOWNTO
102072: IFFALSE 102102
// result := Join ( result , array [ i ] ) ;
102074: LD_ADDR_VAR 0 2
102078: PUSH
102079: LD_VAR 0 2
102083: PPUSH
102084: LD_VAR 0 1
102088: PUSH
102089: LD_VAR 0 3
102093: ARRAY
102094: PPUSH
102095: CALL 106760 0 2
102099: ST_TO_ADDR
102100: GO 102071
102102: POP
102103: POP
// end ;
102104: LD_VAR 0 2
102108: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102109: LD_INT 0
102111: PPUSH
102112: PPUSH
102113: PPUSH
102114: PPUSH
102115: PPUSH
102116: PPUSH
// if not unit or not hexes then
102117: LD_VAR 0 1
102121: NOT
102122: PUSH
102123: LD_VAR 0 2
102127: NOT
102128: OR
102129: IFFALSE 102133
// exit ;
102131: GO 102256
// dist := 9999 ;
102133: LD_ADDR_VAR 0 5
102137: PUSH
102138: LD_INT 9999
102140: ST_TO_ADDR
// for i = 1 to hexes do
102141: LD_ADDR_VAR 0 4
102145: PUSH
102146: DOUBLE
102147: LD_INT 1
102149: DEC
102150: ST_TO_ADDR
102151: LD_VAR 0 2
102155: PUSH
102156: FOR_TO
102157: IFFALSE 102244
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102159: LD_ADDR_VAR 0 6
102163: PUSH
102164: LD_VAR 0 1
102168: PPUSH
102169: LD_VAR 0 2
102173: PUSH
102174: LD_VAR 0 4
102178: ARRAY
102179: PUSH
102180: LD_INT 1
102182: ARRAY
102183: PPUSH
102184: LD_VAR 0 2
102188: PUSH
102189: LD_VAR 0 4
102193: ARRAY
102194: PUSH
102195: LD_INT 2
102197: ARRAY
102198: PPUSH
102199: CALL_OW 297
102203: ST_TO_ADDR
// if tdist < dist then
102204: LD_VAR 0 6
102208: PUSH
102209: LD_VAR 0 5
102213: LESS
102214: IFFALSE 102242
// begin hex := hexes [ i ] ;
102216: LD_ADDR_VAR 0 8
102220: PUSH
102221: LD_VAR 0 2
102225: PUSH
102226: LD_VAR 0 4
102230: ARRAY
102231: ST_TO_ADDR
// dist := tdist ;
102232: LD_ADDR_VAR 0 5
102236: PUSH
102237: LD_VAR 0 6
102241: ST_TO_ADDR
// end ; end ;
102242: GO 102156
102244: POP
102245: POP
// result := hex ;
102246: LD_ADDR_VAR 0 3
102250: PUSH
102251: LD_VAR 0 8
102255: ST_TO_ADDR
// end ;
102256: LD_VAR 0 3
102260: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102261: LD_INT 0
102263: PPUSH
102264: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102265: LD_VAR 0 1
102269: NOT
102270: PUSH
102271: LD_VAR 0 1
102275: PUSH
102276: LD_INT 21
102278: PUSH
102279: LD_INT 2
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: PUSH
102286: LD_INT 23
102288: PUSH
102289: LD_INT 2
102291: PUSH
102292: EMPTY
102293: LIST
102294: LIST
102295: PUSH
102296: EMPTY
102297: LIST
102298: LIST
102299: PPUSH
102300: CALL_OW 69
102304: IN
102305: NOT
102306: OR
102307: IFFALSE 102311
// exit ;
102309: GO 102358
// for i = 1 to 3 do
102311: LD_ADDR_VAR 0 3
102315: PUSH
102316: DOUBLE
102317: LD_INT 1
102319: DEC
102320: ST_TO_ADDR
102321: LD_INT 3
102323: PUSH
102324: FOR_TO
102325: IFFALSE 102356
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102327: LD_VAR 0 1
102331: PPUSH
102332: CALL_OW 250
102336: PPUSH
102337: LD_VAR 0 1
102341: PPUSH
102342: CALL_OW 251
102346: PPUSH
102347: LD_INT 1
102349: PPUSH
102350: CALL_OW 453
102354: GO 102324
102356: POP
102357: POP
// end ;
102358: LD_VAR 0 2
102362: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102363: LD_INT 0
102365: PPUSH
102366: PPUSH
102367: PPUSH
102368: PPUSH
102369: PPUSH
102370: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
102371: LD_VAR 0 1
102375: NOT
102376: PUSH
102377: LD_VAR 0 2
102381: NOT
102382: OR
102383: PUSH
102384: LD_VAR 0 1
102388: PPUSH
102389: CALL_OW 314
102393: OR
102394: IFFALSE 102398
// exit ;
102396: GO 102865
// if GetLives ( i ) < 250 then
102398: LD_VAR 0 4
102402: PPUSH
102403: CALL_OW 256
102407: PUSH
102408: LD_INT 250
102410: LESS
102411: IFFALSE 102424
// begin ComAutodestruct ( i ) ;
102413: LD_VAR 0 4
102417: PPUSH
102418: CALL 102261 0 1
// exit ;
102422: GO 102865
// end ; x := GetX ( enemy_unit ) ;
102424: LD_ADDR_VAR 0 7
102428: PUSH
102429: LD_VAR 0 2
102433: PPUSH
102434: CALL_OW 250
102438: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
102439: LD_ADDR_VAR 0 8
102443: PUSH
102444: LD_VAR 0 2
102448: PPUSH
102449: CALL_OW 251
102453: ST_TO_ADDR
// if not x or not y then
102454: LD_VAR 0 7
102458: NOT
102459: PUSH
102460: LD_VAR 0 8
102464: NOT
102465: OR
102466: IFFALSE 102470
// exit ;
102468: GO 102865
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
102470: LD_ADDR_VAR 0 6
102474: PUSH
102475: LD_VAR 0 7
102479: PPUSH
102480: LD_INT 0
102482: PPUSH
102483: LD_INT 4
102485: PPUSH
102486: CALL_OW 272
102490: PUSH
102491: LD_VAR 0 8
102495: PPUSH
102496: LD_INT 0
102498: PPUSH
102499: LD_INT 4
102501: PPUSH
102502: CALL_OW 273
102506: PUSH
102507: EMPTY
102508: LIST
102509: LIST
102510: PUSH
102511: LD_VAR 0 7
102515: PPUSH
102516: LD_INT 1
102518: PPUSH
102519: LD_INT 4
102521: PPUSH
102522: CALL_OW 272
102526: PUSH
102527: LD_VAR 0 8
102531: PPUSH
102532: LD_INT 1
102534: PPUSH
102535: LD_INT 4
102537: PPUSH
102538: CALL_OW 273
102542: PUSH
102543: EMPTY
102544: LIST
102545: LIST
102546: PUSH
102547: LD_VAR 0 7
102551: PPUSH
102552: LD_INT 2
102554: PPUSH
102555: LD_INT 4
102557: PPUSH
102558: CALL_OW 272
102562: PUSH
102563: LD_VAR 0 8
102567: PPUSH
102568: LD_INT 2
102570: PPUSH
102571: LD_INT 4
102573: PPUSH
102574: CALL_OW 273
102578: PUSH
102579: EMPTY
102580: LIST
102581: LIST
102582: PUSH
102583: LD_VAR 0 7
102587: PPUSH
102588: LD_INT 3
102590: PPUSH
102591: LD_INT 4
102593: PPUSH
102594: CALL_OW 272
102598: PUSH
102599: LD_VAR 0 8
102603: PPUSH
102604: LD_INT 3
102606: PPUSH
102607: LD_INT 4
102609: PPUSH
102610: CALL_OW 273
102614: PUSH
102615: EMPTY
102616: LIST
102617: LIST
102618: PUSH
102619: LD_VAR 0 7
102623: PPUSH
102624: LD_INT 4
102626: PPUSH
102627: LD_INT 4
102629: PPUSH
102630: CALL_OW 272
102634: PUSH
102635: LD_VAR 0 8
102639: PPUSH
102640: LD_INT 4
102642: PPUSH
102643: LD_INT 4
102645: PPUSH
102646: CALL_OW 273
102650: PUSH
102651: EMPTY
102652: LIST
102653: LIST
102654: PUSH
102655: LD_VAR 0 7
102659: PPUSH
102660: LD_INT 5
102662: PPUSH
102663: LD_INT 4
102665: PPUSH
102666: CALL_OW 272
102670: PUSH
102671: LD_VAR 0 8
102675: PPUSH
102676: LD_INT 5
102678: PPUSH
102679: LD_INT 4
102681: PPUSH
102682: CALL_OW 273
102686: PUSH
102687: EMPTY
102688: LIST
102689: LIST
102690: PUSH
102691: EMPTY
102692: LIST
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: ST_TO_ADDR
// for i = tmp downto 1 do
102699: LD_ADDR_VAR 0 4
102703: PUSH
102704: DOUBLE
102705: LD_VAR 0 6
102709: INC
102710: ST_TO_ADDR
102711: LD_INT 1
102713: PUSH
102714: FOR_DOWNTO
102715: IFFALSE 102816
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
102717: LD_VAR 0 6
102721: PUSH
102722: LD_VAR 0 4
102726: ARRAY
102727: PUSH
102728: LD_INT 1
102730: ARRAY
102731: PPUSH
102732: LD_VAR 0 6
102736: PUSH
102737: LD_VAR 0 4
102741: ARRAY
102742: PUSH
102743: LD_INT 2
102745: ARRAY
102746: PPUSH
102747: CALL_OW 488
102751: NOT
102752: PUSH
102753: LD_VAR 0 6
102757: PUSH
102758: LD_VAR 0 4
102762: ARRAY
102763: PUSH
102764: LD_INT 1
102766: ARRAY
102767: PPUSH
102768: LD_VAR 0 6
102772: PUSH
102773: LD_VAR 0 4
102777: ARRAY
102778: PUSH
102779: LD_INT 2
102781: ARRAY
102782: PPUSH
102783: CALL_OW 428
102787: PUSH
102788: LD_INT 0
102790: NONEQUAL
102791: OR
102792: IFFALSE 102814
// tmp := Delete ( tmp , i ) ;
102794: LD_ADDR_VAR 0 6
102798: PUSH
102799: LD_VAR 0 6
102803: PPUSH
102804: LD_VAR 0 4
102808: PPUSH
102809: CALL_OW 3
102813: ST_TO_ADDR
102814: GO 102714
102816: POP
102817: POP
// j := GetClosestHex ( unit , tmp ) ;
102818: LD_ADDR_VAR 0 5
102822: PUSH
102823: LD_VAR 0 1
102827: PPUSH
102828: LD_VAR 0 6
102832: PPUSH
102833: CALL 102109 0 2
102837: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
102838: LD_VAR 0 1
102842: PPUSH
102843: LD_VAR 0 5
102847: PUSH
102848: LD_INT 1
102850: ARRAY
102851: PPUSH
102852: LD_VAR 0 5
102856: PUSH
102857: LD_INT 2
102859: ARRAY
102860: PPUSH
102861: CALL_OW 111
// end ;
102865: LD_VAR 0 3
102869: RET
// export function PrepareApemanSoldier ( ) ; begin
102870: LD_INT 0
102872: PPUSH
// uc_nation := 0 ;
102873: LD_ADDR_OWVAR 21
102877: PUSH
102878: LD_INT 0
102880: ST_TO_ADDR
// hc_sex := sex_male ;
102881: LD_ADDR_OWVAR 27
102885: PUSH
102886: LD_INT 1
102888: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
102889: LD_ADDR_OWVAR 28
102893: PUSH
102894: LD_INT 15
102896: ST_TO_ADDR
// hc_gallery :=  ;
102897: LD_ADDR_OWVAR 33
102901: PUSH
102902: LD_STRING 
102904: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102905: LD_ADDR_OWVAR 31
102909: PUSH
102910: LD_INT 0
102912: PPUSH
102913: LD_INT 3
102915: PPUSH
102916: CALL_OW 12
102920: PUSH
102921: LD_INT 0
102923: PPUSH
102924: LD_INT 3
102926: PPUSH
102927: CALL_OW 12
102931: PUSH
102932: LD_INT 0
102934: PUSH
102935: LD_INT 0
102937: PUSH
102938: EMPTY
102939: LIST
102940: LIST
102941: LIST
102942: LIST
102943: ST_TO_ADDR
// end ;
102944: LD_VAR 0 1
102948: RET
// export function PrepareApemanEngineer ( ) ; begin
102949: LD_INT 0
102951: PPUSH
// uc_nation := 0 ;
102952: LD_ADDR_OWVAR 21
102956: PUSH
102957: LD_INT 0
102959: ST_TO_ADDR
// hc_sex := sex_male ;
102960: LD_ADDR_OWVAR 27
102964: PUSH
102965: LD_INT 1
102967: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
102968: LD_ADDR_OWVAR 28
102972: PUSH
102973: LD_INT 16
102975: ST_TO_ADDR
// hc_gallery :=  ;
102976: LD_ADDR_OWVAR 33
102980: PUSH
102981: LD_STRING 
102983: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102984: LD_ADDR_OWVAR 31
102988: PUSH
102989: LD_INT 0
102991: PPUSH
102992: LD_INT 3
102994: PPUSH
102995: CALL_OW 12
102999: PUSH
103000: LD_INT 0
103002: PPUSH
103003: LD_INT 3
103005: PPUSH
103006: CALL_OW 12
103010: PUSH
103011: LD_INT 0
103013: PUSH
103014: LD_INT 0
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: LIST
103021: LIST
103022: ST_TO_ADDR
// end ;
103023: LD_VAR 0 1
103027: RET
// export function PrepareApeman ( agressivity ) ; begin
103028: LD_INT 0
103030: PPUSH
// uc_side := 0 ;
103031: LD_ADDR_OWVAR 20
103035: PUSH
103036: LD_INT 0
103038: ST_TO_ADDR
// uc_nation := 0 ;
103039: LD_ADDR_OWVAR 21
103043: PUSH
103044: LD_INT 0
103046: ST_TO_ADDR
// hc_sex := sex_male ;
103047: LD_ADDR_OWVAR 27
103051: PUSH
103052: LD_INT 1
103054: ST_TO_ADDR
// hc_class := class_apeman ;
103055: LD_ADDR_OWVAR 28
103059: PUSH
103060: LD_INT 12
103062: ST_TO_ADDR
// hc_gallery :=  ;
103063: LD_ADDR_OWVAR 33
103067: PUSH
103068: LD_STRING 
103070: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103071: LD_ADDR_OWVAR 35
103075: PUSH
103076: LD_VAR 0 1
103080: NEG
103081: PPUSH
103082: LD_VAR 0 1
103086: PPUSH
103087: CALL_OW 12
103091: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103092: LD_ADDR_OWVAR 31
103096: PUSH
103097: LD_INT 0
103099: PPUSH
103100: LD_INT 3
103102: PPUSH
103103: CALL_OW 12
103107: PUSH
103108: LD_INT 0
103110: PPUSH
103111: LD_INT 3
103113: PPUSH
103114: CALL_OW 12
103118: PUSH
103119: LD_INT 0
103121: PUSH
103122: LD_INT 0
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: ST_TO_ADDR
// end ;
103131: LD_VAR 0 2
103135: RET
// export function PrepareTiger ( agressivity ) ; begin
103136: LD_INT 0
103138: PPUSH
// uc_side := 0 ;
103139: LD_ADDR_OWVAR 20
103143: PUSH
103144: LD_INT 0
103146: ST_TO_ADDR
// uc_nation := 0 ;
103147: LD_ADDR_OWVAR 21
103151: PUSH
103152: LD_INT 0
103154: ST_TO_ADDR
// hc_class := class_tiger ;
103155: LD_ADDR_OWVAR 28
103159: PUSH
103160: LD_INT 14
103162: ST_TO_ADDR
// hc_gallery :=  ;
103163: LD_ADDR_OWVAR 33
103167: PUSH
103168: LD_STRING 
103170: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103171: LD_ADDR_OWVAR 35
103175: PUSH
103176: LD_VAR 0 1
103180: NEG
103181: PPUSH
103182: LD_VAR 0 1
103186: PPUSH
103187: CALL_OW 12
103191: ST_TO_ADDR
// end ;
103192: LD_VAR 0 2
103196: RET
// export function PrepareEnchidna ( ) ; begin
103197: LD_INT 0
103199: PPUSH
// uc_side := 0 ;
103200: LD_ADDR_OWVAR 20
103204: PUSH
103205: LD_INT 0
103207: ST_TO_ADDR
// uc_nation := 0 ;
103208: LD_ADDR_OWVAR 21
103212: PUSH
103213: LD_INT 0
103215: ST_TO_ADDR
// hc_class := class_baggie ;
103216: LD_ADDR_OWVAR 28
103220: PUSH
103221: LD_INT 13
103223: ST_TO_ADDR
// hc_gallery :=  ;
103224: LD_ADDR_OWVAR 33
103228: PUSH
103229: LD_STRING 
103231: ST_TO_ADDR
// end ;
103232: LD_VAR 0 1
103236: RET
// export function PrepareFrog ( ) ; begin
103237: LD_INT 0
103239: PPUSH
// uc_side := 0 ;
103240: LD_ADDR_OWVAR 20
103244: PUSH
103245: LD_INT 0
103247: ST_TO_ADDR
// uc_nation := 0 ;
103248: LD_ADDR_OWVAR 21
103252: PUSH
103253: LD_INT 0
103255: ST_TO_ADDR
// hc_class := class_frog ;
103256: LD_ADDR_OWVAR 28
103260: PUSH
103261: LD_INT 19
103263: ST_TO_ADDR
// hc_gallery :=  ;
103264: LD_ADDR_OWVAR 33
103268: PUSH
103269: LD_STRING 
103271: ST_TO_ADDR
// end ;
103272: LD_VAR 0 1
103276: RET
// export function PrepareFish ( ) ; begin
103277: LD_INT 0
103279: PPUSH
// uc_side := 0 ;
103280: LD_ADDR_OWVAR 20
103284: PUSH
103285: LD_INT 0
103287: ST_TO_ADDR
// uc_nation := 0 ;
103288: LD_ADDR_OWVAR 21
103292: PUSH
103293: LD_INT 0
103295: ST_TO_ADDR
// hc_class := class_fish ;
103296: LD_ADDR_OWVAR 28
103300: PUSH
103301: LD_INT 20
103303: ST_TO_ADDR
// hc_gallery :=  ;
103304: LD_ADDR_OWVAR 33
103308: PUSH
103309: LD_STRING 
103311: ST_TO_ADDR
// end ;
103312: LD_VAR 0 1
103316: RET
// export function PrepareBird ( ) ; begin
103317: LD_INT 0
103319: PPUSH
// uc_side := 0 ;
103320: LD_ADDR_OWVAR 20
103324: PUSH
103325: LD_INT 0
103327: ST_TO_ADDR
// uc_nation := 0 ;
103328: LD_ADDR_OWVAR 21
103332: PUSH
103333: LD_INT 0
103335: ST_TO_ADDR
// hc_class := class_phororhacos ;
103336: LD_ADDR_OWVAR 28
103340: PUSH
103341: LD_INT 18
103343: ST_TO_ADDR
// hc_gallery :=  ;
103344: LD_ADDR_OWVAR 33
103348: PUSH
103349: LD_STRING 
103351: ST_TO_ADDR
// end ;
103352: LD_VAR 0 1
103356: RET
// export function PrepareHorse ( ) ; begin
103357: LD_INT 0
103359: PPUSH
// uc_side := 0 ;
103360: LD_ADDR_OWVAR 20
103364: PUSH
103365: LD_INT 0
103367: ST_TO_ADDR
// uc_nation := 0 ;
103368: LD_ADDR_OWVAR 21
103372: PUSH
103373: LD_INT 0
103375: ST_TO_ADDR
// hc_class := class_horse ;
103376: LD_ADDR_OWVAR 28
103380: PUSH
103381: LD_INT 21
103383: ST_TO_ADDR
// hc_gallery :=  ;
103384: LD_ADDR_OWVAR 33
103388: PUSH
103389: LD_STRING 
103391: ST_TO_ADDR
// end ;
103392: LD_VAR 0 1
103396: RET
// export function PrepareMastodont ( ) ; begin
103397: LD_INT 0
103399: PPUSH
// uc_side := 0 ;
103400: LD_ADDR_OWVAR 20
103404: PUSH
103405: LD_INT 0
103407: ST_TO_ADDR
// uc_nation := 0 ;
103408: LD_ADDR_OWVAR 21
103412: PUSH
103413: LD_INT 0
103415: ST_TO_ADDR
// vc_chassis := class_mastodont ;
103416: LD_ADDR_OWVAR 37
103420: PUSH
103421: LD_INT 31
103423: ST_TO_ADDR
// vc_control := control_rider ;
103424: LD_ADDR_OWVAR 38
103428: PUSH
103429: LD_INT 4
103431: ST_TO_ADDR
// end ;
103432: LD_VAR 0 1
103436: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
103437: LD_INT 0
103439: PPUSH
103440: PPUSH
103441: PPUSH
// uc_side = 0 ;
103442: LD_ADDR_OWVAR 20
103446: PUSH
103447: LD_INT 0
103449: ST_TO_ADDR
// uc_nation = 0 ;
103450: LD_ADDR_OWVAR 21
103454: PUSH
103455: LD_INT 0
103457: ST_TO_ADDR
// InitHc_All ( ) ;
103458: CALL_OW 584
// InitVc ;
103462: CALL_OW 20
// if mastodonts then
103466: LD_VAR 0 6
103470: IFFALSE 103537
// for i = 1 to mastodonts do
103472: LD_ADDR_VAR 0 11
103476: PUSH
103477: DOUBLE
103478: LD_INT 1
103480: DEC
103481: ST_TO_ADDR
103482: LD_VAR 0 6
103486: PUSH
103487: FOR_TO
103488: IFFALSE 103535
// begin vc_chassis := 31 ;
103490: LD_ADDR_OWVAR 37
103494: PUSH
103495: LD_INT 31
103497: ST_TO_ADDR
// vc_control := control_rider ;
103498: LD_ADDR_OWVAR 38
103502: PUSH
103503: LD_INT 4
103505: ST_TO_ADDR
// animal := CreateVehicle ;
103506: LD_ADDR_VAR 0 12
103510: PUSH
103511: CALL_OW 45
103515: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103516: LD_VAR 0 12
103520: PPUSH
103521: LD_VAR 0 8
103525: PPUSH
103526: LD_INT 0
103528: PPUSH
103529: CALL 105665 0 3
// end ;
103533: GO 103487
103535: POP
103536: POP
// if horses then
103537: LD_VAR 0 5
103541: IFFALSE 103608
// for i = 1 to horses do
103543: LD_ADDR_VAR 0 11
103547: PUSH
103548: DOUBLE
103549: LD_INT 1
103551: DEC
103552: ST_TO_ADDR
103553: LD_VAR 0 5
103557: PUSH
103558: FOR_TO
103559: IFFALSE 103606
// begin hc_class := 21 ;
103561: LD_ADDR_OWVAR 28
103565: PUSH
103566: LD_INT 21
103568: ST_TO_ADDR
// hc_gallery :=  ;
103569: LD_ADDR_OWVAR 33
103573: PUSH
103574: LD_STRING 
103576: ST_TO_ADDR
// animal := CreateHuman ;
103577: LD_ADDR_VAR 0 12
103581: PUSH
103582: CALL_OW 44
103586: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103587: LD_VAR 0 12
103591: PPUSH
103592: LD_VAR 0 8
103596: PPUSH
103597: LD_INT 0
103599: PPUSH
103600: CALL 105665 0 3
// end ;
103604: GO 103558
103606: POP
103607: POP
// if birds then
103608: LD_VAR 0 1
103612: IFFALSE 103679
// for i = 1 to birds do
103614: LD_ADDR_VAR 0 11
103618: PUSH
103619: DOUBLE
103620: LD_INT 1
103622: DEC
103623: ST_TO_ADDR
103624: LD_VAR 0 1
103628: PUSH
103629: FOR_TO
103630: IFFALSE 103677
// begin hc_class := 18 ;
103632: LD_ADDR_OWVAR 28
103636: PUSH
103637: LD_INT 18
103639: ST_TO_ADDR
// hc_gallery =  ;
103640: LD_ADDR_OWVAR 33
103644: PUSH
103645: LD_STRING 
103647: ST_TO_ADDR
// animal := CreateHuman ;
103648: LD_ADDR_VAR 0 12
103652: PUSH
103653: CALL_OW 44
103657: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103658: LD_VAR 0 12
103662: PPUSH
103663: LD_VAR 0 8
103667: PPUSH
103668: LD_INT 0
103670: PPUSH
103671: CALL 105665 0 3
// end ;
103675: GO 103629
103677: POP
103678: POP
// if tigers then
103679: LD_VAR 0 2
103683: IFFALSE 103767
// for i = 1 to tigers do
103685: LD_ADDR_VAR 0 11
103689: PUSH
103690: DOUBLE
103691: LD_INT 1
103693: DEC
103694: ST_TO_ADDR
103695: LD_VAR 0 2
103699: PUSH
103700: FOR_TO
103701: IFFALSE 103765
// begin hc_class = class_tiger ;
103703: LD_ADDR_OWVAR 28
103707: PUSH
103708: LD_INT 14
103710: ST_TO_ADDR
// hc_gallery =  ;
103711: LD_ADDR_OWVAR 33
103715: PUSH
103716: LD_STRING 
103718: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
103719: LD_ADDR_OWVAR 35
103723: PUSH
103724: LD_INT 7
103726: NEG
103727: PPUSH
103728: LD_INT 7
103730: PPUSH
103731: CALL_OW 12
103735: ST_TO_ADDR
// animal := CreateHuman ;
103736: LD_ADDR_VAR 0 12
103740: PUSH
103741: CALL_OW 44
103745: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103746: LD_VAR 0 12
103750: PPUSH
103751: LD_VAR 0 8
103755: PPUSH
103756: LD_INT 0
103758: PPUSH
103759: CALL 105665 0 3
// end ;
103763: GO 103700
103765: POP
103766: POP
// if apemans then
103767: LD_VAR 0 3
103771: IFFALSE 103894
// for i = 1 to apemans do
103773: LD_ADDR_VAR 0 11
103777: PUSH
103778: DOUBLE
103779: LD_INT 1
103781: DEC
103782: ST_TO_ADDR
103783: LD_VAR 0 3
103787: PUSH
103788: FOR_TO
103789: IFFALSE 103892
// begin hc_class = class_apeman ;
103791: LD_ADDR_OWVAR 28
103795: PUSH
103796: LD_INT 12
103798: ST_TO_ADDR
// hc_gallery =  ;
103799: LD_ADDR_OWVAR 33
103803: PUSH
103804: LD_STRING 
103806: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
103807: LD_ADDR_OWVAR 35
103811: PUSH
103812: LD_INT 2
103814: NEG
103815: PPUSH
103816: LD_INT 2
103818: PPUSH
103819: CALL_OW 12
103823: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
103824: LD_ADDR_OWVAR 31
103828: PUSH
103829: LD_INT 1
103831: PPUSH
103832: LD_INT 3
103834: PPUSH
103835: CALL_OW 12
103839: PUSH
103840: LD_INT 1
103842: PPUSH
103843: LD_INT 3
103845: PPUSH
103846: CALL_OW 12
103850: PUSH
103851: LD_INT 0
103853: PUSH
103854: LD_INT 0
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: LIST
103861: LIST
103862: ST_TO_ADDR
// animal := CreateHuman ;
103863: LD_ADDR_VAR 0 12
103867: PUSH
103868: CALL_OW 44
103872: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103873: LD_VAR 0 12
103877: PPUSH
103878: LD_VAR 0 8
103882: PPUSH
103883: LD_INT 0
103885: PPUSH
103886: CALL 105665 0 3
// end ;
103890: GO 103788
103892: POP
103893: POP
// if enchidnas then
103894: LD_VAR 0 4
103898: IFFALSE 103965
// for i = 1 to enchidnas do
103900: LD_ADDR_VAR 0 11
103904: PUSH
103905: DOUBLE
103906: LD_INT 1
103908: DEC
103909: ST_TO_ADDR
103910: LD_VAR 0 4
103914: PUSH
103915: FOR_TO
103916: IFFALSE 103963
// begin hc_class = 13 ;
103918: LD_ADDR_OWVAR 28
103922: PUSH
103923: LD_INT 13
103925: ST_TO_ADDR
// hc_gallery =  ;
103926: LD_ADDR_OWVAR 33
103930: PUSH
103931: LD_STRING 
103933: ST_TO_ADDR
// animal := CreateHuman ;
103934: LD_ADDR_VAR 0 12
103938: PUSH
103939: CALL_OW 44
103943: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103944: LD_VAR 0 12
103948: PPUSH
103949: LD_VAR 0 8
103953: PPUSH
103954: LD_INT 0
103956: PPUSH
103957: CALL 105665 0 3
// end ;
103961: GO 103915
103963: POP
103964: POP
// if fishes then
103965: LD_VAR 0 7
103969: IFFALSE 104036
// for i = 1 to fishes do
103971: LD_ADDR_VAR 0 11
103975: PUSH
103976: DOUBLE
103977: LD_INT 1
103979: DEC
103980: ST_TO_ADDR
103981: LD_VAR 0 7
103985: PUSH
103986: FOR_TO
103987: IFFALSE 104034
// begin hc_class = 20 ;
103989: LD_ADDR_OWVAR 28
103993: PUSH
103994: LD_INT 20
103996: ST_TO_ADDR
// hc_gallery =  ;
103997: LD_ADDR_OWVAR 33
104001: PUSH
104002: LD_STRING 
104004: ST_TO_ADDR
// animal := CreateHuman ;
104005: LD_ADDR_VAR 0 12
104009: PUSH
104010: CALL_OW 44
104014: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104015: LD_VAR 0 12
104019: PPUSH
104020: LD_VAR 0 9
104024: PPUSH
104025: LD_INT 0
104027: PPUSH
104028: CALL 105665 0 3
// end ;
104032: GO 103986
104034: POP
104035: POP
// end ;
104036: LD_VAR 0 10
104040: RET
// export function WantHeal ( sci , unit ) ; begin
104041: LD_INT 0
104043: PPUSH
// if GetTaskList ( sci ) > 0 then
104044: LD_VAR 0 1
104048: PPUSH
104049: CALL_OW 437
104053: PUSH
104054: LD_INT 0
104056: GREATER
104057: IFFALSE 104127
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104059: LD_VAR 0 1
104063: PPUSH
104064: CALL_OW 437
104068: PUSH
104069: LD_INT 1
104071: ARRAY
104072: PUSH
104073: LD_INT 1
104075: ARRAY
104076: PUSH
104077: LD_STRING l
104079: EQUAL
104080: PUSH
104081: LD_VAR 0 1
104085: PPUSH
104086: CALL_OW 437
104090: PUSH
104091: LD_INT 1
104093: ARRAY
104094: PUSH
104095: LD_INT 4
104097: ARRAY
104098: PUSH
104099: LD_VAR 0 2
104103: EQUAL
104104: AND
104105: IFFALSE 104117
// result := true else
104107: LD_ADDR_VAR 0 3
104111: PUSH
104112: LD_INT 1
104114: ST_TO_ADDR
104115: GO 104125
// result := false ;
104117: LD_ADDR_VAR 0 3
104121: PUSH
104122: LD_INT 0
104124: ST_TO_ADDR
// end else
104125: GO 104135
// result := false ;
104127: LD_ADDR_VAR 0 3
104131: PUSH
104132: LD_INT 0
104134: ST_TO_ADDR
// end ;
104135: LD_VAR 0 3
104139: RET
// export function HealTarget ( sci ) ; begin
104140: LD_INT 0
104142: PPUSH
// if not sci then
104143: LD_VAR 0 1
104147: NOT
104148: IFFALSE 104152
// exit ;
104150: GO 104217
// result := 0 ;
104152: LD_ADDR_VAR 0 2
104156: PUSH
104157: LD_INT 0
104159: ST_TO_ADDR
// if GetTaskList ( sci ) then
104160: LD_VAR 0 1
104164: PPUSH
104165: CALL_OW 437
104169: IFFALSE 104217
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104171: LD_VAR 0 1
104175: PPUSH
104176: CALL_OW 437
104180: PUSH
104181: LD_INT 1
104183: ARRAY
104184: PUSH
104185: LD_INT 1
104187: ARRAY
104188: PUSH
104189: LD_STRING l
104191: EQUAL
104192: IFFALSE 104217
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104194: LD_ADDR_VAR 0 2
104198: PUSH
104199: LD_VAR 0 1
104203: PPUSH
104204: CALL_OW 437
104208: PUSH
104209: LD_INT 1
104211: ARRAY
104212: PUSH
104213: LD_INT 4
104215: ARRAY
104216: ST_TO_ADDR
// end ;
104217: LD_VAR 0 2
104221: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104222: LD_INT 0
104224: PPUSH
104225: PPUSH
104226: PPUSH
104227: PPUSH
// if not base_units then
104228: LD_VAR 0 1
104232: NOT
104233: IFFALSE 104237
// exit ;
104235: GO 104324
// result := false ;
104237: LD_ADDR_VAR 0 2
104241: PUSH
104242: LD_INT 0
104244: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104245: LD_ADDR_VAR 0 5
104249: PUSH
104250: LD_VAR 0 1
104254: PPUSH
104255: LD_INT 21
104257: PUSH
104258: LD_INT 3
104260: PUSH
104261: EMPTY
104262: LIST
104263: LIST
104264: PPUSH
104265: CALL_OW 72
104269: ST_TO_ADDR
// if not tmp then
104270: LD_VAR 0 5
104274: NOT
104275: IFFALSE 104279
// exit ;
104277: GO 104324
// for i in tmp do
104279: LD_ADDR_VAR 0 3
104283: PUSH
104284: LD_VAR 0 5
104288: PUSH
104289: FOR_IN
104290: IFFALSE 104322
// begin result := EnemyInRange ( i , 22 ) ;
104292: LD_ADDR_VAR 0 2
104296: PUSH
104297: LD_VAR 0 3
104301: PPUSH
104302: LD_INT 22
104304: PPUSH
104305: CALL 101911 0 2
104309: ST_TO_ADDR
// if result then
104310: LD_VAR 0 2
104314: IFFALSE 104320
// exit ;
104316: POP
104317: POP
104318: GO 104324
// end ;
104320: GO 104289
104322: POP
104323: POP
// end ;
104324: LD_VAR 0 2
104328: RET
// export function FilterByTag ( units , tag ) ; begin
104329: LD_INT 0
104331: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104332: LD_ADDR_VAR 0 3
104336: PUSH
104337: LD_VAR 0 1
104341: PPUSH
104342: LD_INT 120
104344: PUSH
104345: LD_VAR 0 2
104349: PUSH
104350: EMPTY
104351: LIST
104352: LIST
104353: PPUSH
104354: CALL_OW 72
104358: ST_TO_ADDR
// end ;
104359: LD_VAR 0 3
104363: RET
// export function IsDriver ( un ) ; begin
104364: LD_INT 0
104366: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104367: LD_ADDR_VAR 0 2
104371: PUSH
104372: LD_VAR 0 1
104376: PUSH
104377: LD_INT 55
104379: PUSH
104380: EMPTY
104381: LIST
104382: PPUSH
104383: CALL_OW 69
104387: IN
104388: ST_TO_ADDR
// end ;
104389: LD_VAR 0 2
104393: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104394: LD_INT 0
104396: PPUSH
104397: PPUSH
// list := [ ] ;
104398: LD_ADDR_VAR 0 5
104402: PUSH
104403: EMPTY
104404: ST_TO_ADDR
// case d of 0 :
104405: LD_VAR 0 3
104409: PUSH
104410: LD_INT 0
104412: DOUBLE
104413: EQUAL
104414: IFTRUE 104418
104416: GO 104551
104418: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104419: LD_ADDR_VAR 0 5
104423: PUSH
104424: LD_VAR 0 1
104428: PUSH
104429: LD_INT 4
104431: MINUS
104432: PUSH
104433: LD_VAR 0 2
104437: PUSH
104438: LD_INT 4
104440: MINUS
104441: PUSH
104442: LD_INT 2
104444: PUSH
104445: EMPTY
104446: LIST
104447: LIST
104448: LIST
104449: PUSH
104450: LD_VAR 0 1
104454: PUSH
104455: LD_INT 3
104457: MINUS
104458: PUSH
104459: LD_VAR 0 2
104463: PUSH
104464: LD_INT 1
104466: PUSH
104467: EMPTY
104468: LIST
104469: LIST
104470: LIST
104471: PUSH
104472: LD_VAR 0 1
104476: PUSH
104477: LD_INT 4
104479: PLUS
104480: PUSH
104481: LD_VAR 0 2
104485: PUSH
104486: LD_INT 4
104488: PUSH
104489: EMPTY
104490: LIST
104491: LIST
104492: LIST
104493: PUSH
104494: LD_VAR 0 1
104498: PUSH
104499: LD_INT 3
104501: PLUS
104502: PUSH
104503: LD_VAR 0 2
104507: PUSH
104508: LD_INT 3
104510: PLUS
104511: PUSH
104512: LD_INT 5
104514: PUSH
104515: EMPTY
104516: LIST
104517: LIST
104518: LIST
104519: PUSH
104520: LD_VAR 0 1
104524: PUSH
104525: LD_VAR 0 2
104529: PUSH
104530: LD_INT 4
104532: PLUS
104533: PUSH
104534: LD_INT 0
104536: PUSH
104537: EMPTY
104538: LIST
104539: LIST
104540: LIST
104541: PUSH
104542: EMPTY
104543: LIST
104544: LIST
104545: LIST
104546: LIST
104547: LIST
104548: ST_TO_ADDR
// end ; 1 :
104549: GO 105249
104551: LD_INT 1
104553: DOUBLE
104554: EQUAL
104555: IFTRUE 104559
104557: GO 104692
104559: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104560: LD_ADDR_VAR 0 5
104564: PUSH
104565: LD_VAR 0 1
104569: PUSH
104570: LD_VAR 0 2
104574: PUSH
104575: LD_INT 4
104577: MINUS
104578: PUSH
104579: LD_INT 3
104581: PUSH
104582: EMPTY
104583: LIST
104584: LIST
104585: LIST
104586: PUSH
104587: LD_VAR 0 1
104591: PUSH
104592: LD_INT 3
104594: MINUS
104595: PUSH
104596: LD_VAR 0 2
104600: PUSH
104601: LD_INT 3
104603: MINUS
104604: PUSH
104605: LD_INT 2
104607: PUSH
104608: EMPTY
104609: LIST
104610: LIST
104611: LIST
104612: PUSH
104613: LD_VAR 0 1
104617: PUSH
104618: LD_INT 4
104620: MINUS
104621: PUSH
104622: LD_VAR 0 2
104626: PUSH
104627: LD_INT 1
104629: PUSH
104630: EMPTY
104631: LIST
104632: LIST
104633: LIST
104634: PUSH
104635: LD_VAR 0 1
104639: PUSH
104640: LD_VAR 0 2
104644: PUSH
104645: LD_INT 3
104647: PLUS
104648: PUSH
104649: LD_INT 0
104651: PUSH
104652: EMPTY
104653: LIST
104654: LIST
104655: LIST
104656: PUSH
104657: LD_VAR 0 1
104661: PUSH
104662: LD_INT 4
104664: PLUS
104665: PUSH
104666: LD_VAR 0 2
104670: PUSH
104671: LD_INT 4
104673: PLUS
104674: PUSH
104675: LD_INT 5
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: LIST
104682: PUSH
104683: EMPTY
104684: LIST
104685: LIST
104686: LIST
104687: LIST
104688: LIST
104689: ST_TO_ADDR
// end ; 2 :
104690: GO 105249
104692: LD_INT 2
104694: DOUBLE
104695: EQUAL
104696: IFTRUE 104700
104698: GO 104829
104700: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104701: LD_ADDR_VAR 0 5
104705: PUSH
104706: LD_VAR 0 1
104710: PUSH
104711: LD_VAR 0 2
104715: PUSH
104716: LD_INT 3
104718: MINUS
104719: PUSH
104720: LD_INT 3
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: LIST
104727: PUSH
104728: LD_VAR 0 1
104732: PUSH
104733: LD_INT 4
104735: PLUS
104736: PUSH
104737: LD_VAR 0 2
104741: PUSH
104742: LD_INT 4
104744: PUSH
104745: EMPTY
104746: LIST
104747: LIST
104748: LIST
104749: PUSH
104750: LD_VAR 0 1
104754: PUSH
104755: LD_VAR 0 2
104759: PUSH
104760: LD_INT 4
104762: PLUS
104763: PUSH
104764: LD_INT 0
104766: PUSH
104767: EMPTY
104768: LIST
104769: LIST
104770: LIST
104771: PUSH
104772: LD_VAR 0 1
104776: PUSH
104777: LD_INT 3
104779: MINUS
104780: PUSH
104781: LD_VAR 0 2
104785: PUSH
104786: LD_INT 1
104788: PUSH
104789: EMPTY
104790: LIST
104791: LIST
104792: LIST
104793: PUSH
104794: LD_VAR 0 1
104798: PUSH
104799: LD_INT 4
104801: MINUS
104802: PUSH
104803: LD_VAR 0 2
104807: PUSH
104808: LD_INT 4
104810: MINUS
104811: PUSH
104812: LD_INT 2
104814: PUSH
104815: EMPTY
104816: LIST
104817: LIST
104818: LIST
104819: PUSH
104820: EMPTY
104821: LIST
104822: LIST
104823: LIST
104824: LIST
104825: LIST
104826: ST_TO_ADDR
// end ; 3 :
104827: GO 105249
104829: LD_INT 3
104831: DOUBLE
104832: EQUAL
104833: IFTRUE 104837
104835: GO 104970
104837: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104838: LD_ADDR_VAR 0 5
104842: PUSH
104843: LD_VAR 0 1
104847: PUSH
104848: LD_INT 3
104850: PLUS
104851: PUSH
104852: LD_VAR 0 2
104856: PUSH
104857: LD_INT 4
104859: PUSH
104860: EMPTY
104861: LIST
104862: LIST
104863: LIST
104864: PUSH
104865: LD_VAR 0 1
104869: PUSH
104870: LD_INT 4
104872: PLUS
104873: PUSH
104874: LD_VAR 0 2
104878: PUSH
104879: LD_INT 4
104881: PLUS
104882: PUSH
104883: LD_INT 5
104885: PUSH
104886: EMPTY
104887: LIST
104888: LIST
104889: LIST
104890: PUSH
104891: LD_VAR 0 1
104895: PUSH
104896: LD_INT 4
104898: MINUS
104899: PUSH
104900: LD_VAR 0 2
104904: PUSH
104905: LD_INT 1
104907: PUSH
104908: EMPTY
104909: LIST
104910: LIST
104911: LIST
104912: PUSH
104913: LD_VAR 0 1
104917: PUSH
104918: LD_VAR 0 2
104922: PUSH
104923: LD_INT 4
104925: MINUS
104926: PUSH
104927: LD_INT 3
104929: PUSH
104930: EMPTY
104931: LIST
104932: LIST
104933: LIST
104934: PUSH
104935: LD_VAR 0 1
104939: PUSH
104940: LD_INT 3
104942: MINUS
104943: PUSH
104944: LD_VAR 0 2
104948: PUSH
104949: LD_INT 3
104951: MINUS
104952: PUSH
104953: LD_INT 2
104955: PUSH
104956: EMPTY
104957: LIST
104958: LIST
104959: LIST
104960: PUSH
104961: EMPTY
104962: LIST
104963: LIST
104964: LIST
104965: LIST
104966: LIST
104967: ST_TO_ADDR
// end ; 4 :
104968: GO 105249
104970: LD_INT 4
104972: DOUBLE
104973: EQUAL
104974: IFTRUE 104978
104976: GO 105111
104978: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104979: LD_ADDR_VAR 0 5
104983: PUSH
104984: LD_VAR 0 1
104988: PUSH
104989: LD_VAR 0 2
104993: PUSH
104994: LD_INT 4
104996: PLUS
104997: PUSH
104998: LD_INT 0
105000: PUSH
105001: EMPTY
105002: LIST
105003: LIST
105004: LIST
105005: PUSH
105006: LD_VAR 0 1
105010: PUSH
105011: LD_INT 3
105013: PLUS
105014: PUSH
105015: LD_VAR 0 2
105019: PUSH
105020: LD_INT 3
105022: PLUS
105023: PUSH
105024: LD_INT 5
105026: PUSH
105027: EMPTY
105028: LIST
105029: LIST
105030: LIST
105031: PUSH
105032: LD_VAR 0 1
105036: PUSH
105037: LD_INT 4
105039: PLUS
105040: PUSH
105041: LD_VAR 0 2
105045: PUSH
105046: LD_INT 4
105048: PUSH
105049: EMPTY
105050: LIST
105051: LIST
105052: LIST
105053: PUSH
105054: LD_VAR 0 1
105058: PUSH
105059: LD_VAR 0 2
105063: PUSH
105064: LD_INT 3
105066: MINUS
105067: PUSH
105068: LD_INT 3
105070: PUSH
105071: EMPTY
105072: LIST
105073: LIST
105074: LIST
105075: PUSH
105076: LD_VAR 0 1
105080: PUSH
105081: LD_INT 4
105083: MINUS
105084: PUSH
105085: LD_VAR 0 2
105089: PUSH
105090: LD_INT 4
105092: MINUS
105093: PUSH
105094: LD_INT 2
105096: PUSH
105097: EMPTY
105098: LIST
105099: LIST
105100: LIST
105101: PUSH
105102: EMPTY
105103: LIST
105104: LIST
105105: LIST
105106: LIST
105107: LIST
105108: ST_TO_ADDR
// end ; 5 :
105109: GO 105249
105111: LD_INT 5
105113: DOUBLE
105114: EQUAL
105115: IFTRUE 105119
105117: GO 105248
105119: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105120: LD_ADDR_VAR 0 5
105124: PUSH
105125: LD_VAR 0 1
105129: PUSH
105130: LD_INT 4
105132: MINUS
105133: PUSH
105134: LD_VAR 0 2
105138: PUSH
105139: LD_INT 1
105141: PUSH
105142: EMPTY
105143: LIST
105144: LIST
105145: LIST
105146: PUSH
105147: LD_VAR 0 1
105151: PUSH
105152: LD_VAR 0 2
105156: PUSH
105157: LD_INT 4
105159: MINUS
105160: PUSH
105161: LD_INT 3
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: LIST
105168: PUSH
105169: LD_VAR 0 1
105173: PUSH
105174: LD_INT 4
105176: PLUS
105177: PUSH
105178: LD_VAR 0 2
105182: PUSH
105183: LD_INT 4
105185: PLUS
105186: PUSH
105187: LD_INT 5
105189: PUSH
105190: EMPTY
105191: LIST
105192: LIST
105193: LIST
105194: PUSH
105195: LD_VAR 0 1
105199: PUSH
105200: LD_INT 3
105202: PLUS
105203: PUSH
105204: LD_VAR 0 2
105208: PUSH
105209: LD_INT 4
105211: PUSH
105212: EMPTY
105213: LIST
105214: LIST
105215: LIST
105216: PUSH
105217: LD_VAR 0 1
105221: PUSH
105222: LD_VAR 0 2
105226: PUSH
105227: LD_INT 3
105229: PLUS
105230: PUSH
105231: LD_INT 0
105233: PUSH
105234: EMPTY
105235: LIST
105236: LIST
105237: LIST
105238: PUSH
105239: EMPTY
105240: LIST
105241: LIST
105242: LIST
105243: LIST
105244: LIST
105245: ST_TO_ADDR
// end ; end ;
105246: GO 105249
105248: POP
// result := list ;
105249: LD_ADDR_VAR 0 4
105253: PUSH
105254: LD_VAR 0 5
105258: ST_TO_ADDR
// end ;
105259: LD_VAR 0 4
105263: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105264: LD_INT 0
105266: PPUSH
105267: PPUSH
105268: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105269: LD_VAR 0 1
105273: NOT
105274: PUSH
105275: LD_VAR 0 2
105279: PUSH
105280: LD_INT 1
105282: PUSH
105283: LD_INT 2
105285: PUSH
105286: LD_INT 3
105288: PUSH
105289: LD_INT 4
105291: PUSH
105292: EMPTY
105293: LIST
105294: LIST
105295: LIST
105296: LIST
105297: IN
105298: NOT
105299: OR
105300: IFFALSE 105304
// exit ;
105302: GO 105387
// tmp := [ ] ;
105304: LD_ADDR_VAR 0 5
105308: PUSH
105309: EMPTY
105310: ST_TO_ADDR
// for i in units do
105311: LD_ADDR_VAR 0 4
105315: PUSH
105316: LD_VAR 0 1
105320: PUSH
105321: FOR_IN
105322: IFFALSE 105356
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105324: LD_ADDR_VAR 0 5
105328: PUSH
105329: LD_VAR 0 5
105333: PPUSH
105334: LD_VAR 0 4
105338: PPUSH
105339: LD_VAR 0 2
105343: PPUSH
105344: CALL_OW 259
105348: PPUSH
105349: CALL 106760 0 2
105353: ST_TO_ADDR
105354: GO 105321
105356: POP
105357: POP
// if not tmp then
105358: LD_VAR 0 5
105362: NOT
105363: IFFALSE 105367
// exit ;
105365: GO 105387
// result := SortListByListDesc ( units , tmp ) ;
105367: LD_ADDR_VAR 0 3
105371: PUSH
105372: LD_VAR 0 1
105376: PPUSH
105377: LD_VAR 0 5
105381: PPUSH
105382: CALL_OW 77
105386: ST_TO_ADDR
// end ;
105387: LD_VAR 0 3
105391: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105392: LD_INT 0
105394: PPUSH
105395: PPUSH
105396: PPUSH
// result := false ;
105397: LD_ADDR_VAR 0 3
105401: PUSH
105402: LD_INT 0
105404: ST_TO_ADDR
// if not building then
105405: LD_VAR 0 2
105409: NOT
105410: IFFALSE 105414
// exit ;
105412: GO 105552
// x := GetX ( building ) ;
105414: LD_ADDR_VAR 0 4
105418: PUSH
105419: LD_VAR 0 2
105423: PPUSH
105424: CALL_OW 250
105428: ST_TO_ADDR
// y := GetY ( building ) ;
105429: LD_ADDR_VAR 0 5
105433: PUSH
105434: LD_VAR 0 2
105438: PPUSH
105439: CALL_OW 251
105443: ST_TO_ADDR
// if not x or not y then
105444: LD_VAR 0 4
105448: NOT
105449: PUSH
105450: LD_VAR 0 5
105454: NOT
105455: OR
105456: IFFALSE 105460
// exit ;
105458: GO 105552
// if GetTaskList ( unit ) then
105460: LD_VAR 0 1
105464: PPUSH
105465: CALL_OW 437
105469: IFFALSE 105552
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105471: LD_STRING e
105473: PUSH
105474: LD_VAR 0 1
105478: PPUSH
105479: CALL_OW 437
105483: PUSH
105484: LD_INT 1
105486: ARRAY
105487: PUSH
105488: LD_INT 1
105490: ARRAY
105491: EQUAL
105492: PUSH
105493: LD_VAR 0 4
105497: PUSH
105498: LD_VAR 0 1
105502: PPUSH
105503: CALL_OW 437
105507: PUSH
105508: LD_INT 1
105510: ARRAY
105511: PUSH
105512: LD_INT 2
105514: ARRAY
105515: EQUAL
105516: AND
105517: PUSH
105518: LD_VAR 0 5
105522: PUSH
105523: LD_VAR 0 1
105527: PPUSH
105528: CALL_OW 437
105532: PUSH
105533: LD_INT 1
105535: ARRAY
105536: PUSH
105537: LD_INT 3
105539: ARRAY
105540: EQUAL
105541: AND
105542: IFFALSE 105552
// result := true end ;
105544: LD_ADDR_VAR 0 3
105548: PUSH
105549: LD_INT 1
105551: ST_TO_ADDR
// end ;
105552: LD_VAR 0 3
105556: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
105557: LD_INT 0
105559: PPUSH
// result := false ;
105560: LD_ADDR_VAR 0 4
105564: PUSH
105565: LD_INT 0
105567: ST_TO_ADDR
// if GetTaskList ( unit ) then
105568: LD_VAR 0 1
105572: PPUSH
105573: CALL_OW 437
105577: IFFALSE 105660
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105579: LD_STRING M
105581: PUSH
105582: LD_VAR 0 1
105586: PPUSH
105587: CALL_OW 437
105591: PUSH
105592: LD_INT 1
105594: ARRAY
105595: PUSH
105596: LD_INT 1
105598: ARRAY
105599: EQUAL
105600: PUSH
105601: LD_VAR 0 2
105605: PUSH
105606: LD_VAR 0 1
105610: PPUSH
105611: CALL_OW 437
105615: PUSH
105616: LD_INT 1
105618: ARRAY
105619: PUSH
105620: LD_INT 2
105622: ARRAY
105623: EQUAL
105624: AND
105625: PUSH
105626: LD_VAR 0 3
105630: PUSH
105631: LD_VAR 0 1
105635: PPUSH
105636: CALL_OW 437
105640: PUSH
105641: LD_INT 1
105643: ARRAY
105644: PUSH
105645: LD_INT 3
105647: ARRAY
105648: EQUAL
105649: AND
105650: IFFALSE 105660
// result := true ;
105652: LD_ADDR_VAR 0 4
105656: PUSH
105657: LD_INT 1
105659: ST_TO_ADDR
// end ; end ;
105660: LD_VAR 0 4
105664: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105665: LD_INT 0
105667: PPUSH
105668: PPUSH
105669: PPUSH
105670: PPUSH
// if not unit or not area then
105671: LD_VAR 0 1
105675: NOT
105676: PUSH
105677: LD_VAR 0 2
105681: NOT
105682: OR
105683: IFFALSE 105687
// exit ;
105685: GO 105863
// tmp := AreaToList ( area , i ) ;
105687: LD_ADDR_VAR 0 6
105691: PUSH
105692: LD_VAR 0 2
105696: PPUSH
105697: LD_VAR 0 5
105701: PPUSH
105702: CALL_OW 517
105706: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105707: LD_ADDR_VAR 0 5
105711: PUSH
105712: DOUBLE
105713: LD_INT 1
105715: DEC
105716: ST_TO_ADDR
105717: LD_VAR 0 6
105721: PUSH
105722: LD_INT 1
105724: ARRAY
105725: PUSH
105726: FOR_TO
105727: IFFALSE 105861
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105729: LD_ADDR_VAR 0 7
105733: PUSH
105734: LD_VAR 0 6
105738: PUSH
105739: LD_INT 1
105741: ARRAY
105742: PUSH
105743: LD_VAR 0 5
105747: ARRAY
105748: PUSH
105749: LD_VAR 0 6
105753: PUSH
105754: LD_INT 2
105756: ARRAY
105757: PUSH
105758: LD_VAR 0 5
105762: ARRAY
105763: PUSH
105764: EMPTY
105765: LIST
105766: LIST
105767: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
105768: LD_INT 92
105770: PUSH
105771: LD_VAR 0 7
105775: PUSH
105776: LD_INT 1
105778: ARRAY
105779: PUSH
105780: LD_VAR 0 7
105784: PUSH
105785: LD_INT 2
105787: ARRAY
105788: PUSH
105789: LD_INT 2
105791: PUSH
105792: EMPTY
105793: LIST
105794: LIST
105795: LIST
105796: LIST
105797: PPUSH
105798: CALL_OW 69
105802: PUSH
105803: LD_INT 0
105805: EQUAL
105806: IFFALSE 105859
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105808: LD_VAR 0 1
105812: PPUSH
105813: LD_VAR 0 7
105817: PUSH
105818: LD_INT 1
105820: ARRAY
105821: PPUSH
105822: LD_VAR 0 7
105826: PUSH
105827: LD_INT 2
105829: ARRAY
105830: PPUSH
105831: LD_VAR 0 3
105835: PPUSH
105836: CALL_OW 48
// result := IsPlaced ( unit ) ;
105840: LD_ADDR_VAR 0 4
105844: PUSH
105845: LD_VAR 0 1
105849: PPUSH
105850: CALL_OW 305
105854: ST_TO_ADDR
// exit ;
105855: POP
105856: POP
105857: GO 105863
// end ; end ;
105859: GO 105726
105861: POP
105862: POP
// end ;
105863: LD_VAR 0 4
105867: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105868: LD_INT 0
105870: PPUSH
105871: PPUSH
105872: PPUSH
// if not side or side > 8 then
105873: LD_VAR 0 1
105877: NOT
105878: PUSH
105879: LD_VAR 0 1
105883: PUSH
105884: LD_INT 8
105886: GREATER
105887: OR
105888: IFFALSE 105892
// exit ;
105890: GO 106079
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105892: LD_ADDR_VAR 0 4
105896: PUSH
105897: LD_INT 22
105899: PUSH
105900: LD_VAR 0 1
105904: PUSH
105905: EMPTY
105906: LIST
105907: LIST
105908: PUSH
105909: LD_INT 21
105911: PUSH
105912: LD_INT 3
105914: PUSH
105915: EMPTY
105916: LIST
105917: LIST
105918: PUSH
105919: EMPTY
105920: LIST
105921: LIST
105922: PPUSH
105923: CALL_OW 69
105927: ST_TO_ADDR
// if not tmp then
105928: LD_VAR 0 4
105932: NOT
105933: IFFALSE 105937
// exit ;
105935: GO 106079
// enable_addtolog := true ;
105937: LD_ADDR_OWVAR 81
105941: PUSH
105942: LD_INT 1
105944: ST_TO_ADDR
// AddToLog ( [ ) ;
105945: LD_STRING [
105947: PPUSH
105948: CALL_OW 561
// for i in tmp do
105952: LD_ADDR_VAR 0 3
105956: PUSH
105957: LD_VAR 0 4
105961: PUSH
105962: FOR_IN
105963: IFFALSE 106070
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105965: LD_STRING [
105967: PUSH
105968: LD_VAR 0 3
105972: PPUSH
105973: CALL_OW 266
105977: STR
105978: PUSH
105979: LD_STRING , 
105981: STR
105982: PUSH
105983: LD_VAR 0 3
105987: PPUSH
105988: CALL_OW 250
105992: STR
105993: PUSH
105994: LD_STRING , 
105996: STR
105997: PUSH
105998: LD_VAR 0 3
106002: PPUSH
106003: CALL_OW 251
106007: STR
106008: PUSH
106009: LD_STRING , 
106011: STR
106012: PUSH
106013: LD_VAR 0 3
106017: PPUSH
106018: CALL_OW 254
106022: STR
106023: PUSH
106024: LD_STRING , 
106026: STR
106027: PUSH
106028: LD_VAR 0 3
106032: PPUSH
106033: LD_INT 1
106035: PPUSH
106036: CALL_OW 268
106040: STR
106041: PUSH
106042: LD_STRING , 
106044: STR
106045: PUSH
106046: LD_VAR 0 3
106050: PPUSH
106051: LD_INT 2
106053: PPUSH
106054: CALL_OW 268
106058: STR
106059: PUSH
106060: LD_STRING ],
106062: STR
106063: PPUSH
106064: CALL_OW 561
// end ;
106068: GO 105962
106070: POP
106071: POP
// AddToLog ( ]; ) ;
106072: LD_STRING ];
106074: PPUSH
106075: CALL_OW 561
// end ;
106079: LD_VAR 0 2
106083: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106084: LD_INT 0
106086: PPUSH
106087: PPUSH
106088: PPUSH
106089: PPUSH
106090: PPUSH
// if not area or not rate or not max then
106091: LD_VAR 0 1
106095: NOT
106096: PUSH
106097: LD_VAR 0 2
106101: NOT
106102: OR
106103: PUSH
106104: LD_VAR 0 4
106108: NOT
106109: OR
106110: IFFALSE 106114
// exit ;
106112: GO 106303
// while 1 do
106114: LD_INT 1
106116: IFFALSE 106303
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106118: LD_ADDR_VAR 0 9
106122: PUSH
106123: LD_VAR 0 1
106127: PPUSH
106128: LD_INT 1
106130: PPUSH
106131: CALL_OW 287
106135: PUSH
106136: LD_INT 10
106138: MUL
106139: ST_TO_ADDR
// r := rate / 10 ;
106140: LD_ADDR_VAR 0 7
106144: PUSH
106145: LD_VAR 0 2
106149: PUSH
106150: LD_INT 10
106152: DIVREAL
106153: ST_TO_ADDR
// time := 1 1$00 ;
106154: LD_ADDR_VAR 0 8
106158: PUSH
106159: LD_INT 2100
106161: ST_TO_ADDR
// if amount < min then
106162: LD_VAR 0 9
106166: PUSH
106167: LD_VAR 0 3
106171: LESS
106172: IFFALSE 106190
// r := r * 2 else
106174: LD_ADDR_VAR 0 7
106178: PUSH
106179: LD_VAR 0 7
106183: PUSH
106184: LD_INT 2
106186: MUL
106187: ST_TO_ADDR
106188: GO 106216
// if amount > max then
106190: LD_VAR 0 9
106194: PUSH
106195: LD_VAR 0 4
106199: GREATER
106200: IFFALSE 106216
// r := r / 2 ;
106202: LD_ADDR_VAR 0 7
106206: PUSH
106207: LD_VAR 0 7
106211: PUSH
106212: LD_INT 2
106214: DIVREAL
106215: ST_TO_ADDR
// time := time / r ;
106216: LD_ADDR_VAR 0 8
106220: PUSH
106221: LD_VAR 0 8
106225: PUSH
106226: LD_VAR 0 7
106230: DIVREAL
106231: ST_TO_ADDR
// if time < 0 then
106232: LD_VAR 0 8
106236: PUSH
106237: LD_INT 0
106239: LESS
106240: IFFALSE 106257
// time := time * - 1 ;
106242: LD_ADDR_VAR 0 8
106246: PUSH
106247: LD_VAR 0 8
106251: PUSH
106252: LD_INT 1
106254: NEG
106255: MUL
106256: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106257: LD_VAR 0 8
106261: PUSH
106262: LD_INT 35
106264: PPUSH
106265: LD_INT 875
106267: PPUSH
106268: CALL_OW 12
106272: PLUS
106273: PPUSH
106274: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106278: LD_INT 1
106280: PPUSH
106281: LD_INT 5
106283: PPUSH
106284: CALL_OW 12
106288: PPUSH
106289: LD_VAR 0 1
106293: PPUSH
106294: LD_INT 1
106296: PPUSH
106297: CALL_OW 55
// end ;
106301: GO 106114
// end ;
106303: LD_VAR 0 5
106307: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106308: LD_INT 0
106310: PPUSH
106311: PPUSH
106312: PPUSH
106313: PPUSH
106314: PPUSH
106315: PPUSH
106316: PPUSH
106317: PPUSH
// if not turrets or not factories then
106318: LD_VAR 0 1
106322: NOT
106323: PUSH
106324: LD_VAR 0 2
106328: NOT
106329: OR
106330: IFFALSE 106334
// exit ;
106332: GO 106641
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106334: LD_ADDR_VAR 0 10
106338: PUSH
106339: LD_INT 5
106341: PUSH
106342: LD_INT 6
106344: PUSH
106345: EMPTY
106346: LIST
106347: LIST
106348: PUSH
106349: LD_INT 2
106351: PUSH
106352: LD_INT 4
106354: PUSH
106355: EMPTY
106356: LIST
106357: LIST
106358: PUSH
106359: LD_INT 3
106361: PUSH
106362: LD_INT 5
106364: PUSH
106365: EMPTY
106366: LIST
106367: LIST
106368: PUSH
106369: EMPTY
106370: LIST
106371: LIST
106372: LIST
106373: PUSH
106374: LD_INT 24
106376: PUSH
106377: LD_INT 25
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: PUSH
106384: LD_INT 23
106386: PUSH
106387: LD_INT 27
106389: PUSH
106390: EMPTY
106391: LIST
106392: LIST
106393: PUSH
106394: EMPTY
106395: LIST
106396: LIST
106397: PUSH
106398: LD_INT 42
106400: PUSH
106401: LD_INT 43
106403: PUSH
106404: EMPTY
106405: LIST
106406: LIST
106407: PUSH
106408: LD_INT 44
106410: PUSH
106411: LD_INT 46
106413: PUSH
106414: EMPTY
106415: LIST
106416: LIST
106417: PUSH
106418: LD_INT 45
106420: PUSH
106421: LD_INT 47
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: PUSH
106428: EMPTY
106429: LIST
106430: LIST
106431: LIST
106432: PUSH
106433: EMPTY
106434: LIST
106435: LIST
106436: LIST
106437: ST_TO_ADDR
// result := [ ] ;
106438: LD_ADDR_VAR 0 3
106442: PUSH
106443: EMPTY
106444: ST_TO_ADDR
// for i in turrets do
106445: LD_ADDR_VAR 0 4
106449: PUSH
106450: LD_VAR 0 1
106454: PUSH
106455: FOR_IN
106456: IFFALSE 106639
// begin nat := GetNation ( i ) ;
106458: LD_ADDR_VAR 0 7
106462: PUSH
106463: LD_VAR 0 4
106467: PPUSH
106468: CALL_OW 248
106472: ST_TO_ADDR
// weapon := 0 ;
106473: LD_ADDR_VAR 0 8
106477: PUSH
106478: LD_INT 0
106480: ST_TO_ADDR
// if not nat then
106481: LD_VAR 0 7
106485: NOT
106486: IFFALSE 106490
// continue ;
106488: GO 106455
// for j in list [ nat ] do
106490: LD_ADDR_VAR 0 5
106494: PUSH
106495: LD_VAR 0 10
106499: PUSH
106500: LD_VAR 0 7
106504: ARRAY
106505: PUSH
106506: FOR_IN
106507: IFFALSE 106548
// if GetBWeapon ( i ) = j [ 1 ] then
106509: LD_VAR 0 4
106513: PPUSH
106514: CALL_OW 269
106518: PUSH
106519: LD_VAR 0 5
106523: PUSH
106524: LD_INT 1
106526: ARRAY
106527: EQUAL
106528: IFFALSE 106546
// begin weapon := j [ 2 ] ;
106530: LD_ADDR_VAR 0 8
106534: PUSH
106535: LD_VAR 0 5
106539: PUSH
106540: LD_INT 2
106542: ARRAY
106543: ST_TO_ADDR
// break ;
106544: GO 106548
// end ;
106546: GO 106506
106548: POP
106549: POP
// if not weapon then
106550: LD_VAR 0 8
106554: NOT
106555: IFFALSE 106559
// continue ;
106557: GO 106455
// for k in factories do
106559: LD_ADDR_VAR 0 6
106563: PUSH
106564: LD_VAR 0 2
106568: PUSH
106569: FOR_IN
106570: IFFALSE 106635
// begin weapons := AvailableWeaponList ( k ) ;
106572: LD_ADDR_VAR 0 9
106576: PUSH
106577: LD_VAR 0 6
106581: PPUSH
106582: CALL_OW 478
106586: ST_TO_ADDR
// if not weapons then
106587: LD_VAR 0 9
106591: NOT
106592: IFFALSE 106596
// continue ;
106594: GO 106569
// if weapon in weapons then
106596: LD_VAR 0 8
106600: PUSH
106601: LD_VAR 0 9
106605: IN
106606: IFFALSE 106633
// begin result := [ i , weapon ] ;
106608: LD_ADDR_VAR 0 3
106612: PUSH
106613: LD_VAR 0 4
106617: PUSH
106618: LD_VAR 0 8
106622: PUSH
106623: EMPTY
106624: LIST
106625: LIST
106626: ST_TO_ADDR
// exit ;
106627: POP
106628: POP
106629: POP
106630: POP
106631: GO 106641
// end ; end ;
106633: GO 106569
106635: POP
106636: POP
// end ;
106637: GO 106455
106639: POP
106640: POP
// end ;
106641: LD_VAR 0 3
106645: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106646: LD_INT 0
106648: PPUSH
// if not side or side > 8 then
106649: LD_VAR 0 3
106653: NOT
106654: PUSH
106655: LD_VAR 0 3
106659: PUSH
106660: LD_INT 8
106662: GREATER
106663: OR
106664: IFFALSE 106668
// exit ;
106666: GO 106727
// if not range then
106668: LD_VAR 0 4
106672: NOT
106673: IFFALSE 106684
// range := - 12 ;
106675: LD_ADDR_VAR 0 4
106679: PUSH
106680: LD_INT 12
106682: NEG
106683: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106684: LD_VAR 0 1
106688: PPUSH
106689: LD_VAR 0 2
106693: PPUSH
106694: LD_VAR 0 3
106698: PPUSH
106699: LD_VAR 0 4
106703: PPUSH
106704: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106708: LD_VAR 0 1
106712: PPUSH
106713: LD_VAR 0 2
106717: PPUSH
106718: LD_VAR 0 3
106722: PPUSH
106723: CALL_OW 331
// end ;
106727: LD_VAR 0 5
106731: RET
// export function Video ( mode ) ; begin
106732: LD_INT 0
106734: PPUSH
// ingame_video = mode ;
106735: LD_ADDR_OWVAR 52
106739: PUSH
106740: LD_VAR 0 1
106744: ST_TO_ADDR
// interface_hidden = mode ;
106745: LD_ADDR_OWVAR 54
106749: PUSH
106750: LD_VAR 0 1
106754: ST_TO_ADDR
// end ;
106755: LD_VAR 0 2
106759: RET
// export function Join ( array , element ) ; begin
106760: LD_INT 0
106762: PPUSH
// result := Replace ( array , array + 1 , element ) ;
106763: LD_ADDR_VAR 0 3
106767: PUSH
106768: LD_VAR 0 1
106772: PPUSH
106773: LD_VAR 0 1
106777: PUSH
106778: LD_INT 1
106780: PLUS
106781: PPUSH
106782: LD_VAR 0 2
106786: PPUSH
106787: CALL_OW 1
106791: ST_TO_ADDR
// end ;
106792: LD_VAR 0 3
106796: RET
// export function JoinUnion ( array , element ) ; begin
106797: LD_INT 0
106799: PPUSH
// result := array union element ;
106800: LD_ADDR_VAR 0 3
106804: PUSH
106805: LD_VAR 0 1
106809: PUSH
106810: LD_VAR 0 2
106814: UNION
106815: ST_TO_ADDR
// end ;
106816: LD_VAR 0 3
106820: RET
// export function GetBehemoths ( side ) ; begin
106821: LD_INT 0
106823: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
106824: LD_ADDR_VAR 0 2
106828: PUSH
106829: LD_INT 22
106831: PUSH
106832: LD_VAR 0 1
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: PUSH
106841: LD_INT 31
106843: PUSH
106844: LD_INT 25
106846: PUSH
106847: EMPTY
106848: LIST
106849: LIST
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: PPUSH
106855: CALL_OW 69
106859: ST_TO_ADDR
// end ;
106860: LD_VAR 0 2
106864: RET
// export function Shuffle ( array ) ; var i , index ; begin
106865: LD_INT 0
106867: PPUSH
106868: PPUSH
106869: PPUSH
// result := [ ] ;
106870: LD_ADDR_VAR 0 2
106874: PUSH
106875: EMPTY
106876: ST_TO_ADDR
// if not array then
106877: LD_VAR 0 1
106881: NOT
106882: IFFALSE 106886
// exit ;
106884: GO 106985
// Randomize ;
106886: CALL_OW 10
// for i = array downto 1 do
106890: LD_ADDR_VAR 0 3
106894: PUSH
106895: DOUBLE
106896: LD_VAR 0 1
106900: INC
106901: ST_TO_ADDR
106902: LD_INT 1
106904: PUSH
106905: FOR_DOWNTO
106906: IFFALSE 106983
// begin index := rand ( 1 , array ) ;
106908: LD_ADDR_VAR 0 4
106912: PUSH
106913: LD_INT 1
106915: PPUSH
106916: LD_VAR 0 1
106920: PPUSH
106921: CALL_OW 12
106925: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106926: LD_ADDR_VAR 0 2
106930: PUSH
106931: LD_VAR 0 2
106935: PPUSH
106936: LD_VAR 0 2
106940: PUSH
106941: LD_INT 1
106943: PLUS
106944: PPUSH
106945: LD_VAR 0 1
106949: PUSH
106950: LD_VAR 0 4
106954: ARRAY
106955: PPUSH
106956: CALL_OW 2
106960: ST_TO_ADDR
// array := Delete ( array , index ) ;
106961: LD_ADDR_VAR 0 1
106965: PUSH
106966: LD_VAR 0 1
106970: PPUSH
106971: LD_VAR 0 4
106975: PPUSH
106976: CALL_OW 3
106980: ST_TO_ADDR
// end ;
106981: GO 106905
106983: POP
106984: POP
// end ;
106985: LD_VAR 0 2
106989: RET
// export function GetBaseMaterials ( base ) ; begin
106990: LD_INT 0
106992: PPUSH
// result := [ 0 , 0 , 0 ] ;
106993: LD_ADDR_VAR 0 2
106997: PUSH
106998: LD_INT 0
107000: PUSH
107001: LD_INT 0
107003: PUSH
107004: LD_INT 0
107006: PUSH
107007: EMPTY
107008: LIST
107009: LIST
107010: LIST
107011: ST_TO_ADDR
// if not base then
107012: LD_VAR 0 1
107016: NOT
107017: IFFALSE 107021
// exit ;
107019: GO 107070
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107021: LD_ADDR_VAR 0 2
107025: PUSH
107026: LD_VAR 0 1
107030: PPUSH
107031: LD_INT 1
107033: PPUSH
107034: CALL_OW 275
107038: PUSH
107039: LD_VAR 0 1
107043: PPUSH
107044: LD_INT 2
107046: PPUSH
107047: CALL_OW 275
107051: PUSH
107052: LD_VAR 0 1
107056: PPUSH
107057: LD_INT 3
107059: PPUSH
107060: CALL_OW 275
107064: PUSH
107065: EMPTY
107066: LIST
107067: LIST
107068: LIST
107069: ST_TO_ADDR
// end ;
107070: LD_VAR 0 2
107074: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107075: LD_INT 0
107077: PPUSH
107078: PPUSH
// result := array ;
107079: LD_ADDR_VAR 0 3
107083: PUSH
107084: LD_VAR 0 1
107088: ST_TO_ADDR
// if size >= result then
107089: LD_VAR 0 2
107093: PUSH
107094: LD_VAR 0 3
107098: GREATEREQUAL
107099: IFFALSE 107103
// exit ;
107101: GO 107153
// if size then
107103: LD_VAR 0 2
107107: IFFALSE 107153
// for i := array downto size do
107109: LD_ADDR_VAR 0 4
107113: PUSH
107114: DOUBLE
107115: LD_VAR 0 1
107119: INC
107120: ST_TO_ADDR
107121: LD_VAR 0 2
107125: PUSH
107126: FOR_DOWNTO
107127: IFFALSE 107151
// result := Delete ( result , result ) ;
107129: LD_ADDR_VAR 0 3
107133: PUSH
107134: LD_VAR 0 3
107138: PPUSH
107139: LD_VAR 0 3
107143: PPUSH
107144: CALL_OW 3
107148: ST_TO_ADDR
107149: GO 107126
107151: POP
107152: POP
// end ;
107153: LD_VAR 0 3
107157: RET
// export function ComExit ( unit ) ; var tmp ; begin
107158: LD_INT 0
107160: PPUSH
107161: PPUSH
// if not IsInUnit ( unit ) then
107162: LD_VAR 0 1
107166: PPUSH
107167: CALL_OW 310
107171: NOT
107172: IFFALSE 107176
// exit ;
107174: GO 107236
// tmp := IsInUnit ( unit ) ;
107176: LD_ADDR_VAR 0 3
107180: PUSH
107181: LD_VAR 0 1
107185: PPUSH
107186: CALL_OW 310
107190: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107191: LD_VAR 0 3
107195: PPUSH
107196: CALL_OW 247
107200: PUSH
107201: LD_INT 2
107203: EQUAL
107204: IFFALSE 107217
// ComExitVehicle ( unit ) else
107206: LD_VAR 0 1
107210: PPUSH
107211: CALL_OW 121
107215: GO 107226
// ComExitBuilding ( unit ) ;
107217: LD_VAR 0 1
107221: PPUSH
107222: CALL_OW 122
// result := tmp ;
107226: LD_ADDR_VAR 0 2
107230: PUSH
107231: LD_VAR 0 3
107235: ST_TO_ADDR
// end ;
107236: LD_VAR 0 2
107240: RET
// export function ComExitAll ( units ) ; var i ; begin
107241: LD_INT 0
107243: PPUSH
107244: PPUSH
// if not units then
107245: LD_VAR 0 1
107249: NOT
107250: IFFALSE 107254
// exit ;
107252: GO 107280
// for i in units do
107254: LD_ADDR_VAR 0 3
107258: PUSH
107259: LD_VAR 0 1
107263: PUSH
107264: FOR_IN
107265: IFFALSE 107278
// ComExit ( i ) ;
107267: LD_VAR 0 3
107271: PPUSH
107272: CALL 107158 0 1
107276: GO 107264
107278: POP
107279: POP
// end ;
107280: LD_VAR 0 2
107284: RET
// export function ResetHc ; begin
107285: LD_INT 0
107287: PPUSH
// InitHc ;
107288: CALL_OW 19
// hc_importance := 0 ;
107292: LD_ADDR_OWVAR 32
107296: PUSH
107297: LD_INT 0
107299: ST_TO_ADDR
// end ;
107300: LD_VAR 0 1
107304: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107305: LD_INT 0
107307: PPUSH
107308: PPUSH
107309: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107310: LD_ADDR_VAR 0 6
107314: PUSH
107315: LD_VAR 0 1
107319: PUSH
107320: LD_VAR 0 3
107324: PLUS
107325: PUSH
107326: LD_INT 2
107328: DIV
107329: ST_TO_ADDR
// if _x < 0 then
107330: LD_VAR 0 6
107334: PUSH
107335: LD_INT 0
107337: LESS
107338: IFFALSE 107355
// _x := _x * - 1 ;
107340: LD_ADDR_VAR 0 6
107344: PUSH
107345: LD_VAR 0 6
107349: PUSH
107350: LD_INT 1
107352: NEG
107353: MUL
107354: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107355: LD_ADDR_VAR 0 7
107359: PUSH
107360: LD_VAR 0 2
107364: PUSH
107365: LD_VAR 0 4
107369: PLUS
107370: PUSH
107371: LD_INT 2
107373: DIV
107374: ST_TO_ADDR
// if _y < 0 then
107375: LD_VAR 0 7
107379: PUSH
107380: LD_INT 0
107382: LESS
107383: IFFALSE 107400
// _y := _y * - 1 ;
107385: LD_ADDR_VAR 0 7
107389: PUSH
107390: LD_VAR 0 7
107394: PUSH
107395: LD_INT 1
107397: NEG
107398: MUL
107399: ST_TO_ADDR
// result := [ _x , _y ] ;
107400: LD_ADDR_VAR 0 5
107404: PUSH
107405: LD_VAR 0 6
107409: PUSH
107410: LD_VAR 0 7
107414: PUSH
107415: EMPTY
107416: LIST
107417: LIST
107418: ST_TO_ADDR
// end ;
107419: LD_VAR 0 5
107423: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
107424: LD_INT 0
107426: PPUSH
107427: PPUSH
107428: PPUSH
107429: PPUSH
// task := GetTaskList ( unit ) ;
107430: LD_ADDR_VAR 0 7
107434: PUSH
107435: LD_VAR 0 1
107439: PPUSH
107440: CALL_OW 437
107444: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
107445: LD_VAR 0 7
107449: NOT
107450: PUSH
107451: LD_VAR 0 1
107455: PPUSH
107456: LD_VAR 0 2
107460: PPUSH
107461: CALL_OW 308
107465: NOT
107466: AND
107467: IFFALSE 107471
// exit ;
107469: GO 107589
// if IsInArea ( unit , area ) then
107471: LD_VAR 0 1
107475: PPUSH
107476: LD_VAR 0 2
107480: PPUSH
107481: CALL_OW 308
107485: IFFALSE 107503
// begin ComMoveToArea ( unit , goAway ) ;
107487: LD_VAR 0 1
107491: PPUSH
107492: LD_VAR 0 3
107496: PPUSH
107497: CALL_OW 113
// exit ;
107501: GO 107589
// end ; if task [ 1 ] [ 1 ] <> M then
107503: LD_VAR 0 7
107507: PUSH
107508: LD_INT 1
107510: ARRAY
107511: PUSH
107512: LD_INT 1
107514: ARRAY
107515: PUSH
107516: LD_STRING M
107518: NONEQUAL
107519: IFFALSE 107523
// exit ;
107521: GO 107589
// x := task [ 1 ] [ 2 ] ;
107523: LD_ADDR_VAR 0 5
107527: PUSH
107528: LD_VAR 0 7
107532: PUSH
107533: LD_INT 1
107535: ARRAY
107536: PUSH
107537: LD_INT 2
107539: ARRAY
107540: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
107541: LD_ADDR_VAR 0 6
107545: PUSH
107546: LD_VAR 0 7
107550: PUSH
107551: LD_INT 1
107553: ARRAY
107554: PUSH
107555: LD_INT 3
107557: ARRAY
107558: ST_TO_ADDR
// if InArea ( x , y , area ) then
107559: LD_VAR 0 5
107563: PPUSH
107564: LD_VAR 0 6
107568: PPUSH
107569: LD_VAR 0 2
107573: PPUSH
107574: CALL_OW 309
107578: IFFALSE 107589
// ComStop ( unit ) ;
107580: LD_VAR 0 1
107584: PPUSH
107585: CALL_OW 141
// end ;
107589: LD_VAR 0 4
107593: RET
// export function Abs ( value ) ; begin
107594: LD_INT 0
107596: PPUSH
// result := value ;
107597: LD_ADDR_VAR 0 2
107601: PUSH
107602: LD_VAR 0 1
107606: ST_TO_ADDR
// if value < 0 then
107607: LD_VAR 0 1
107611: PUSH
107612: LD_INT 0
107614: LESS
107615: IFFALSE 107632
// result := value * - 1 ;
107617: LD_ADDR_VAR 0 2
107621: PUSH
107622: LD_VAR 0 1
107626: PUSH
107627: LD_INT 1
107629: NEG
107630: MUL
107631: ST_TO_ADDR
// end ;
107632: LD_VAR 0 2
107636: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
107637: LD_INT 0
107639: PPUSH
107640: PPUSH
107641: PPUSH
107642: PPUSH
107643: PPUSH
107644: PPUSH
107645: PPUSH
107646: PPUSH
// if not unit or not building then
107647: LD_VAR 0 1
107651: NOT
107652: PUSH
107653: LD_VAR 0 2
107657: NOT
107658: OR
107659: IFFALSE 107663
// exit ;
107661: GO 107889
// x := GetX ( building ) ;
107663: LD_ADDR_VAR 0 4
107667: PUSH
107668: LD_VAR 0 2
107672: PPUSH
107673: CALL_OW 250
107677: ST_TO_ADDR
// y := GetY ( building ) ;
107678: LD_ADDR_VAR 0 6
107682: PUSH
107683: LD_VAR 0 2
107687: PPUSH
107688: CALL_OW 251
107692: ST_TO_ADDR
// d := GetDir ( building ) ;
107693: LD_ADDR_VAR 0 8
107697: PUSH
107698: LD_VAR 0 2
107702: PPUSH
107703: CALL_OW 254
107707: ST_TO_ADDR
// r := 4 ;
107708: LD_ADDR_VAR 0 9
107712: PUSH
107713: LD_INT 4
107715: ST_TO_ADDR
// for i := 1 to 5 do
107716: LD_ADDR_VAR 0 10
107720: PUSH
107721: DOUBLE
107722: LD_INT 1
107724: DEC
107725: ST_TO_ADDR
107726: LD_INT 5
107728: PUSH
107729: FOR_TO
107730: IFFALSE 107887
// begin _x := ShiftX ( x , d , r + i ) ;
107732: LD_ADDR_VAR 0 5
107736: PUSH
107737: LD_VAR 0 4
107741: PPUSH
107742: LD_VAR 0 8
107746: PPUSH
107747: LD_VAR 0 9
107751: PUSH
107752: LD_VAR 0 10
107756: PLUS
107757: PPUSH
107758: CALL_OW 272
107762: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
107763: LD_ADDR_VAR 0 7
107767: PUSH
107768: LD_VAR 0 6
107772: PPUSH
107773: LD_VAR 0 8
107777: PPUSH
107778: LD_VAR 0 9
107782: PUSH
107783: LD_VAR 0 10
107787: PLUS
107788: PPUSH
107789: CALL_OW 273
107793: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
107794: LD_VAR 0 5
107798: PPUSH
107799: LD_VAR 0 7
107803: PPUSH
107804: CALL_OW 488
107808: PUSH
107809: LD_VAR 0 5
107813: PPUSH
107814: LD_VAR 0 7
107818: PPUSH
107819: CALL_OW 428
107823: PPUSH
107824: CALL_OW 247
107828: PUSH
107829: LD_INT 3
107831: PUSH
107832: LD_INT 2
107834: PUSH
107835: EMPTY
107836: LIST
107837: LIST
107838: IN
107839: NOT
107840: AND
107841: IFFALSE 107885
// begin ComMoveXY ( unit , _x , _y ) ;
107843: LD_VAR 0 1
107847: PPUSH
107848: LD_VAR 0 5
107852: PPUSH
107853: LD_VAR 0 7
107857: PPUSH
107858: CALL_OW 111
// result := [ _x , _y ] ;
107862: LD_ADDR_VAR 0 3
107866: PUSH
107867: LD_VAR 0 5
107871: PUSH
107872: LD_VAR 0 7
107876: PUSH
107877: EMPTY
107878: LIST
107879: LIST
107880: ST_TO_ADDR
// exit ;
107881: POP
107882: POP
107883: GO 107889
// end ; end ;
107885: GO 107729
107887: POP
107888: POP
// end ;
107889: LD_VAR 0 3
107893: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
107894: LD_INT 0
107896: PPUSH
107897: PPUSH
107898: PPUSH
// result := 0 ;
107899: LD_ADDR_VAR 0 3
107903: PUSH
107904: LD_INT 0
107906: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
107907: LD_VAR 0 1
107911: PUSH
107912: LD_INT 0
107914: LESS
107915: PUSH
107916: LD_VAR 0 1
107920: PUSH
107921: LD_INT 8
107923: GREATER
107924: OR
107925: PUSH
107926: LD_VAR 0 2
107930: PUSH
107931: LD_INT 0
107933: LESS
107934: OR
107935: PUSH
107936: LD_VAR 0 2
107940: PUSH
107941: LD_INT 8
107943: GREATER
107944: OR
107945: IFFALSE 107949
// exit ;
107947: GO 108024
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
107949: LD_ADDR_VAR 0 4
107953: PUSH
107954: LD_INT 22
107956: PUSH
107957: LD_VAR 0 2
107961: PUSH
107962: EMPTY
107963: LIST
107964: LIST
107965: PPUSH
107966: CALL_OW 69
107970: PUSH
107971: FOR_IN
107972: IFFALSE 108022
// begin un := UnitShoot ( i ) ;
107974: LD_ADDR_VAR 0 5
107978: PUSH
107979: LD_VAR 0 4
107983: PPUSH
107984: CALL_OW 504
107988: ST_TO_ADDR
// if GetSide ( un ) = side1 then
107989: LD_VAR 0 5
107993: PPUSH
107994: CALL_OW 255
107998: PUSH
107999: LD_VAR 0 1
108003: EQUAL
108004: IFFALSE 108020
// begin result := un ;
108006: LD_ADDR_VAR 0 3
108010: PUSH
108011: LD_VAR 0 5
108015: ST_TO_ADDR
// exit ;
108016: POP
108017: POP
108018: GO 108024
// end ; end ;
108020: GO 107971
108022: POP
108023: POP
// end ;
108024: LD_VAR 0 3
108028: RET
// export function GetCargoBay ( units ) ; begin
108029: LD_INT 0
108031: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108032: LD_ADDR_VAR 0 2
108036: PUSH
108037: LD_VAR 0 1
108041: PPUSH
108042: LD_INT 2
108044: PUSH
108045: LD_INT 34
108047: PUSH
108048: LD_INT 12
108050: PUSH
108051: EMPTY
108052: LIST
108053: LIST
108054: PUSH
108055: LD_INT 34
108057: PUSH
108058: LD_INT 51
108060: PUSH
108061: EMPTY
108062: LIST
108063: LIST
108064: PUSH
108065: LD_INT 34
108067: PUSH
108068: LD_INT 32
108070: PUSH
108071: EMPTY
108072: LIST
108073: LIST
108074: PUSH
108075: LD_INT 34
108077: PUSH
108078: LD_INT 89
108080: PUSH
108081: EMPTY
108082: LIST
108083: LIST
108084: PUSH
108085: EMPTY
108086: LIST
108087: LIST
108088: LIST
108089: LIST
108090: LIST
108091: PPUSH
108092: CALL_OW 72
108096: ST_TO_ADDR
// end ;
108097: LD_VAR 0 2
108101: RET
// export function Negate ( value ) ; begin
108102: LD_INT 0
108104: PPUSH
// result := not value ;
108105: LD_ADDR_VAR 0 2
108109: PUSH
108110: LD_VAR 0 1
108114: NOT
108115: ST_TO_ADDR
// end ;
108116: LD_VAR 0 2
108120: RET
// export function Inc ( value ) ; begin
108121: LD_INT 0
108123: PPUSH
// result := value + 1 ;
108124: LD_ADDR_VAR 0 2
108128: PUSH
108129: LD_VAR 0 1
108133: PUSH
108134: LD_INT 1
108136: PLUS
108137: ST_TO_ADDR
// end ;
108138: LD_VAR 0 2
108142: RET
// export function Dec ( value ) ; begin
108143: LD_INT 0
108145: PPUSH
// result := value - 1 ;
108146: LD_ADDR_VAR 0 2
108150: PUSH
108151: LD_VAR 0 1
108155: PUSH
108156: LD_INT 1
108158: MINUS
108159: ST_TO_ADDR
// end ;
108160: LD_VAR 0 2
108164: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108165: LD_INT 0
108167: PPUSH
108168: PPUSH
108169: PPUSH
108170: PPUSH
108171: PPUSH
108172: PPUSH
108173: PPUSH
108174: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108175: LD_VAR 0 1
108179: PPUSH
108180: LD_VAR 0 2
108184: PPUSH
108185: CALL_OW 488
108189: NOT
108190: PUSH
108191: LD_VAR 0 3
108195: PPUSH
108196: LD_VAR 0 4
108200: PPUSH
108201: CALL_OW 488
108205: NOT
108206: OR
108207: IFFALSE 108220
// begin result := - 1 ;
108209: LD_ADDR_VAR 0 5
108213: PUSH
108214: LD_INT 1
108216: NEG
108217: ST_TO_ADDR
// exit ;
108218: GO 108455
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108220: LD_ADDR_VAR 0 12
108224: PUSH
108225: LD_VAR 0 1
108229: PPUSH
108230: LD_VAR 0 2
108234: PPUSH
108235: LD_VAR 0 3
108239: PPUSH
108240: LD_VAR 0 4
108244: PPUSH
108245: CALL 107305 0 4
108249: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108250: LD_ADDR_VAR 0 11
108254: PUSH
108255: LD_VAR 0 1
108259: PPUSH
108260: LD_VAR 0 2
108264: PPUSH
108265: LD_VAR 0 12
108269: PUSH
108270: LD_INT 1
108272: ARRAY
108273: PPUSH
108274: LD_VAR 0 12
108278: PUSH
108279: LD_INT 2
108281: ARRAY
108282: PPUSH
108283: CALL_OW 298
108287: ST_TO_ADDR
// distance := 9999 ;
108288: LD_ADDR_VAR 0 10
108292: PUSH
108293: LD_INT 9999
108295: ST_TO_ADDR
// for i := 0 to 5 do
108296: LD_ADDR_VAR 0 6
108300: PUSH
108301: DOUBLE
108302: LD_INT 0
108304: DEC
108305: ST_TO_ADDR
108306: LD_INT 5
108308: PUSH
108309: FOR_TO
108310: IFFALSE 108453
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108312: LD_ADDR_VAR 0 7
108316: PUSH
108317: LD_VAR 0 1
108321: PPUSH
108322: LD_VAR 0 6
108326: PPUSH
108327: LD_VAR 0 11
108331: PPUSH
108332: CALL_OW 272
108336: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108337: LD_ADDR_VAR 0 8
108341: PUSH
108342: LD_VAR 0 2
108346: PPUSH
108347: LD_VAR 0 6
108351: PPUSH
108352: LD_VAR 0 11
108356: PPUSH
108357: CALL_OW 273
108361: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108362: LD_VAR 0 7
108366: PPUSH
108367: LD_VAR 0 8
108371: PPUSH
108372: CALL_OW 488
108376: NOT
108377: IFFALSE 108381
// continue ;
108379: GO 108309
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108381: LD_ADDR_VAR 0 9
108385: PUSH
108386: LD_VAR 0 12
108390: PUSH
108391: LD_INT 1
108393: ARRAY
108394: PPUSH
108395: LD_VAR 0 12
108399: PUSH
108400: LD_INT 2
108402: ARRAY
108403: PPUSH
108404: LD_VAR 0 7
108408: PPUSH
108409: LD_VAR 0 8
108413: PPUSH
108414: CALL_OW 298
108418: ST_TO_ADDR
// if tmp < distance then
108419: LD_VAR 0 9
108423: PUSH
108424: LD_VAR 0 10
108428: LESS
108429: IFFALSE 108451
// begin result := i ;
108431: LD_ADDR_VAR 0 5
108435: PUSH
108436: LD_VAR 0 6
108440: ST_TO_ADDR
// distance := tmp ;
108441: LD_ADDR_VAR 0 10
108445: PUSH
108446: LD_VAR 0 9
108450: ST_TO_ADDR
// end ; end ;
108451: GO 108309
108453: POP
108454: POP
// end ;
108455: LD_VAR 0 5
108459: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108460: LD_INT 0
108462: PPUSH
108463: PPUSH
// if not driver or not IsInUnit ( driver ) then
108464: LD_VAR 0 1
108468: NOT
108469: PUSH
108470: LD_VAR 0 1
108474: PPUSH
108475: CALL_OW 310
108479: NOT
108480: OR
108481: IFFALSE 108485
// exit ;
108483: GO 108575
// vehicle := IsInUnit ( driver ) ;
108485: LD_ADDR_VAR 0 3
108489: PUSH
108490: LD_VAR 0 1
108494: PPUSH
108495: CALL_OW 310
108499: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108500: LD_VAR 0 1
108504: PPUSH
108505: LD_STRING \
108507: PUSH
108508: LD_INT 0
108510: PUSH
108511: LD_INT 0
108513: PUSH
108514: LD_INT 0
108516: PUSH
108517: LD_INT 0
108519: PUSH
108520: LD_INT 0
108522: PUSH
108523: LD_INT 0
108525: PUSH
108526: EMPTY
108527: LIST
108528: LIST
108529: LIST
108530: LIST
108531: LIST
108532: LIST
108533: LIST
108534: PUSH
108535: LD_STRING E
108537: PUSH
108538: LD_INT 0
108540: PUSH
108541: LD_INT 0
108543: PUSH
108544: LD_VAR 0 3
108548: PUSH
108549: LD_INT 0
108551: PUSH
108552: LD_INT 0
108554: PUSH
108555: LD_INT 0
108557: PUSH
108558: EMPTY
108559: LIST
108560: LIST
108561: LIST
108562: LIST
108563: LIST
108564: LIST
108565: LIST
108566: PUSH
108567: EMPTY
108568: LIST
108569: LIST
108570: PPUSH
108571: CALL_OW 446
// end ;
108575: LD_VAR 0 2
108579: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108580: LD_INT 0
108582: PPUSH
108583: PPUSH
// if not driver or not IsInUnit ( driver ) then
108584: LD_VAR 0 1
108588: NOT
108589: PUSH
108590: LD_VAR 0 1
108594: PPUSH
108595: CALL_OW 310
108599: NOT
108600: OR
108601: IFFALSE 108605
// exit ;
108603: GO 108695
// vehicle := IsInUnit ( driver ) ;
108605: LD_ADDR_VAR 0 3
108609: PUSH
108610: LD_VAR 0 1
108614: PPUSH
108615: CALL_OW 310
108619: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108620: LD_VAR 0 1
108624: PPUSH
108625: LD_STRING \
108627: PUSH
108628: LD_INT 0
108630: PUSH
108631: LD_INT 0
108633: PUSH
108634: LD_INT 0
108636: PUSH
108637: LD_INT 0
108639: PUSH
108640: LD_INT 0
108642: PUSH
108643: LD_INT 0
108645: PUSH
108646: EMPTY
108647: LIST
108648: LIST
108649: LIST
108650: LIST
108651: LIST
108652: LIST
108653: LIST
108654: PUSH
108655: LD_STRING E
108657: PUSH
108658: LD_INT 0
108660: PUSH
108661: LD_INT 0
108663: PUSH
108664: LD_VAR 0 3
108668: PUSH
108669: LD_INT 0
108671: PUSH
108672: LD_INT 0
108674: PUSH
108675: LD_INT 0
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: LIST
108682: LIST
108683: LIST
108684: LIST
108685: LIST
108686: PUSH
108687: EMPTY
108688: LIST
108689: LIST
108690: PPUSH
108691: CALL_OW 447
// end ;
108695: LD_VAR 0 2
108699: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
108700: LD_INT 0
108702: PPUSH
108703: PPUSH
108704: PPUSH
// tmp := [ ] ;
108705: LD_ADDR_VAR 0 5
108709: PUSH
108710: EMPTY
108711: ST_TO_ADDR
// for i in units do
108712: LD_ADDR_VAR 0 4
108716: PUSH
108717: LD_VAR 0 1
108721: PUSH
108722: FOR_IN
108723: IFFALSE 108761
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
108725: LD_ADDR_VAR 0 5
108729: PUSH
108730: LD_VAR 0 5
108734: PPUSH
108735: LD_VAR 0 5
108739: PUSH
108740: LD_INT 1
108742: PLUS
108743: PPUSH
108744: LD_VAR 0 4
108748: PPUSH
108749: CALL_OW 256
108753: PPUSH
108754: CALL_OW 2
108758: ST_TO_ADDR
108759: GO 108722
108761: POP
108762: POP
// if not tmp then
108763: LD_VAR 0 5
108767: NOT
108768: IFFALSE 108772
// exit ;
108770: GO 108820
// if asc then
108772: LD_VAR 0 2
108776: IFFALSE 108800
// result := SortListByListAsc ( units , tmp ) else
108778: LD_ADDR_VAR 0 3
108782: PUSH
108783: LD_VAR 0 1
108787: PPUSH
108788: LD_VAR 0 5
108792: PPUSH
108793: CALL_OW 76
108797: ST_TO_ADDR
108798: GO 108820
// result := SortListByListDesc ( units , tmp ) ;
108800: LD_ADDR_VAR 0 3
108804: PUSH
108805: LD_VAR 0 1
108809: PPUSH
108810: LD_VAR 0 5
108814: PPUSH
108815: CALL_OW 77
108819: ST_TO_ADDR
// end ;
108820: LD_VAR 0 3
108824: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
108825: LD_INT 0
108827: PPUSH
108828: PPUSH
// task := GetTaskList ( mech ) ;
108829: LD_ADDR_VAR 0 4
108833: PUSH
108834: LD_VAR 0 1
108838: PPUSH
108839: CALL_OW 437
108843: ST_TO_ADDR
// if not task then
108844: LD_VAR 0 4
108848: NOT
108849: IFFALSE 108853
// exit ;
108851: GO 108895
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
108853: LD_ADDR_VAR 0 3
108857: PUSH
108858: LD_VAR 0 4
108862: PUSH
108863: LD_INT 1
108865: ARRAY
108866: PUSH
108867: LD_INT 1
108869: ARRAY
108870: PUSH
108871: LD_STRING r
108873: EQUAL
108874: PUSH
108875: LD_VAR 0 4
108879: PUSH
108880: LD_INT 1
108882: ARRAY
108883: PUSH
108884: LD_INT 4
108886: ARRAY
108887: PUSH
108888: LD_VAR 0 2
108892: EQUAL
108893: AND
108894: ST_TO_ADDR
// end ;
108895: LD_VAR 0 3
108899: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
108900: LD_INT 0
108902: PPUSH
// SetDir ( unit , d ) ;
108903: LD_VAR 0 1
108907: PPUSH
108908: LD_VAR 0 4
108912: PPUSH
108913: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
108917: LD_VAR 0 1
108921: PPUSH
108922: LD_VAR 0 2
108926: PPUSH
108927: LD_VAR 0 3
108931: PPUSH
108932: LD_VAR 0 5
108936: PPUSH
108937: CALL_OW 48
// end ;
108941: LD_VAR 0 6
108945: RET
// export function ToNaturalNumber ( number ) ; begin
108946: LD_INT 0
108948: PPUSH
// result := number div 1 ;
108949: LD_ADDR_VAR 0 2
108953: PUSH
108954: LD_VAR 0 1
108958: PUSH
108959: LD_INT 1
108961: DIV
108962: ST_TO_ADDR
// if number < 0 then
108963: LD_VAR 0 1
108967: PUSH
108968: LD_INT 0
108970: LESS
108971: IFFALSE 108981
// result := 0 ;
108973: LD_ADDR_VAR 0 2
108977: PUSH
108978: LD_INT 0
108980: ST_TO_ADDR
// end ;
108981: LD_VAR 0 2
108985: RET
// export function SortByClass ( units , class ) ; var un ; begin
108986: LD_INT 0
108988: PPUSH
108989: PPUSH
// if not units or not class then
108990: LD_VAR 0 1
108994: NOT
108995: PUSH
108996: LD_VAR 0 2
109000: NOT
109001: OR
109002: IFFALSE 109006
// exit ;
109004: GO 109101
// result := [ ] ;
109006: LD_ADDR_VAR 0 3
109010: PUSH
109011: EMPTY
109012: ST_TO_ADDR
// for un in units do
109013: LD_ADDR_VAR 0 4
109017: PUSH
109018: LD_VAR 0 1
109022: PUSH
109023: FOR_IN
109024: IFFALSE 109099
// if GetClass ( un ) = class then
109026: LD_VAR 0 4
109030: PPUSH
109031: CALL_OW 257
109035: PUSH
109036: LD_VAR 0 2
109040: EQUAL
109041: IFFALSE 109068
// result := Insert ( result , 1 , un ) else
109043: LD_ADDR_VAR 0 3
109047: PUSH
109048: LD_VAR 0 3
109052: PPUSH
109053: LD_INT 1
109055: PPUSH
109056: LD_VAR 0 4
109060: PPUSH
109061: CALL_OW 2
109065: ST_TO_ADDR
109066: GO 109097
// result := Replace ( result , result + 1 , un ) ;
109068: LD_ADDR_VAR 0 3
109072: PUSH
109073: LD_VAR 0 3
109077: PPUSH
109078: LD_VAR 0 3
109082: PUSH
109083: LD_INT 1
109085: PLUS
109086: PPUSH
109087: LD_VAR 0 4
109091: PPUSH
109092: CALL_OW 1
109096: ST_TO_ADDR
109097: GO 109023
109099: POP
109100: POP
// end ;
109101: LD_VAR 0 3
109105: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109106: LD_INT 0
109108: PPUSH
109109: PPUSH
109110: PPUSH
109111: PPUSH
109112: PPUSH
109113: PPUSH
109114: PPUSH
// result := [ ] ;
109115: LD_ADDR_VAR 0 4
109119: PUSH
109120: EMPTY
109121: ST_TO_ADDR
// if x - r < 0 then
109122: LD_VAR 0 1
109126: PUSH
109127: LD_VAR 0 3
109131: MINUS
109132: PUSH
109133: LD_INT 0
109135: LESS
109136: IFFALSE 109148
// min_x := 0 else
109138: LD_ADDR_VAR 0 8
109142: PUSH
109143: LD_INT 0
109145: ST_TO_ADDR
109146: GO 109164
// min_x := x - r ;
109148: LD_ADDR_VAR 0 8
109152: PUSH
109153: LD_VAR 0 1
109157: PUSH
109158: LD_VAR 0 3
109162: MINUS
109163: ST_TO_ADDR
// if y - r < 0 then
109164: LD_VAR 0 2
109168: PUSH
109169: LD_VAR 0 3
109173: MINUS
109174: PUSH
109175: LD_INT 0
109177: LESS
109178: IFFALSE 109190
// min_y := 0 else
109180: LD_ADDR_VAR 0 7
109184: PUSH
109185: LD_INT 0
109187: ST_TO_ADDR
109188: GO 109206
// min_y := y - r ;
109190: LD_ADDR_VAR 0 7
109194: PUSH
109195: LD_VAR 0 2
109199: PUSH
109200: LD_VAR 0 3
109204: MINUS
109205: ST_TO_ADDR
// max_x := x + r ;
109206: LD_ADDR_VAR 0 9
109210: PUSH
109211: LD_VAR 0 1
109215: PUSH
109216: LD_VAR 0 3
109220: PLUS
109221: ST_TO_ADDR
// max_y := y + r ;
109222: LD_ADDR_VAR 0 10
109226: PUSH
109227: LD_VAR 0 2
109231: PUSH
109232: LD_VAR 0 3
109236: PLUS
109237: ST_TO_ADDR
// for _x = min_x to max_x do
109238: LD_ADDR_VAR 0 5
109242: PUSH
109243: DOUBLE
109244: LD_VAR 0 8
109248: DEC
109249: ST_TO_ADDR
109250: LD_VAR 0 9
109254: PUSH
109255: FOR_TO
109256: IFFALSE 109357
// for _y = min_y to max_y do
109258: LD_ADDR_VAR 0 6
109262: PUSH
109263: DOUBLE
109264: LD_VAR 0 7
109268: DEC
109269: ST_TO_ADDR
109270: LD_VAR 0 10
109274: PUSH
109275: FOR_TO
109276: IFFALSE 109353
// begin if not ValidHex ( _x , _y ) then
109278: LD_VAR 0 5
109282: PPUSH
109283: LD_VAR 0 6
109287: PPUSH
109288: CALL_OW 488
109292: NOT
109293: IFFALSE 109297
// continue ;
109295: GO 109275
// if GetResourceTypeXY ( _x , _y ) then
109297: LD_VAR 0 5
109301: PPUSH
109302: LD_VAR 0 6
109306: PPUSH
109307: CALL_OW 283
109311: IFFALSE 109351
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109313: LD_ADDR_VAR 0 4
109317: PUSH
109318: LD_VAR 0 4
109322: PPUSH
109323: LD_VAR 0 4
109327: PUSH
109328: LD_INT 1
109330: PLUS
109331: PPUSH
109332: LD_VAR 0 5
109336: PUSH
109337: LD_VAR 0 6
109341: PUSH
109342: EMPTY
109343: LIST
109344: LIST
109345: PPUSH
109346: CALL_OW 1
109350: ST_TO_ADDR
// end ;
109351: GO 109275
109353: POP
109354: POP
109355: GO 109255
109357: POP
109358: POP
// end ;
109359: LD_VAR 0 4
109363: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109364: LD_INT 0
109366: PPUSH
109367: PPUSH
109368: PPUSH
109369: PPUSH
109370: PPUSH
109371: PPUSH
109372: PPUSH
109373: PPUSH
// if not units then
109374: LD_VAR 0 1
109378: NOT
109379: IFFALSE 109383
// exit ;
109381: GO 109907
// result := UnitFilter ( units , [ f_ok ] ) ;
109383: LD_ADDR_VAR 0 3
109387: PUSH
109388: LD_VAR 0 1
109392: PPUSH
109393: LD_INT 50
109395: PUSH
109396: EMPTY
109397: LIST
109398: PPUSH
109399: CALL_OW 72
109403: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
109404: LD_ADDR_VAR 0 8
109408: PUSH
109409: LD_VAR 0 1
109413: PUSH
109414: LD_INT 1
109416: ARRAY
109417: PPUSH
109418: CALL_OW 255
109422: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
109423: LD_ADDR_VAR 0 10
109427: PUSH
109428: LD_INT 29
109430: PUSH
109431: LD_INT 91
109433: PUSH
109434: LD_INT 49
109436: PUSH
109437: EMPTY
109438: LIST
109439: LIST
109440: LIST
109441: ST_TO_ADDR
// if not result then
109442: LD_VAR 0 3
109446: NOT
109447: IFFALSE 109451
// exit ;
109449: GO 109907
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
109451: LD_ADDR_VAR 0 5
109455: PUSH
109456: LD_INT 81
109458: PUSH
109459: LD_VAR 0 8
109463: PUSH
109464: EMPTY
109465: LIST
109466: LIST
109467: PPUSH
109468: CALL_OW 69
109472: ST_TO_ADDR
// for i in result do
109473: LD_ADDR_VAR 0 4
109477: PUSH
109478: LD_VAR 0 3
109482: PUSH
109483: FOR_IN
109484: IFFALSE 109905
// begin tag := GetTag ( i ) + 1 ;
109486: LD_ADDR_VAR 0 9
109490: PUSH
109491: LD_VAR 0 4
109495: PPUSH
109496: CALL_OW 110
109500: PUSH
109501: LD_INT 1
109503: PLUS
109504: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
109505: LD_ADDR_VAR 0 7
109509: PUSH
109510: LD_VAR 0 4
109514: PPUSH
109515: CALL_OW 250
109519: PPUSH
109520: LD_VAR 0 4
109524: PPUSH
109525: CALL_OW 251
109529: PPUSH
109530: LD_INT 6
109532: PPUSH
109533: CALL 109106 0 3
109537: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
109538: LD_VAR 0 4
109542: PPUSH
109543: CALL_OW 247
109547: PUSH
109548: LD_INT 2
109550: EQUAL
109551: PUSH
109552: LD_VAR 0 7
109556: AND
109557: PUSH
109558: LD_VAR 0 4
109562: PPUSH
109563: CALL_OW 264
109567: PUSH
109568: LD_VAR 0 10
109572: IN
109573: NOT
109574: AND
109575: IFFALSE 109614
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
109577: LD_VAR 0 4
109581: PPUSH
109582: LD_VAR 0 7
109586: PUSH
109587: LD_INT 1
109589: ARRAY
109590: PUSH
109591: LD_INT 1
109593: ARRAY
109594: PPUSH
109595: LD_VAR 0 7
109599: PUSH
109600: LD_INT 1
109602: ARRAY
109603: PUSH
109604: LD_INT 2
109606: ARRAY
109607: PPUSH
109608: CALL_OW 116
109612: GO 109903
// if path > tag then
109614: LD_VAR 0 2
109618: PUSH
109619: LD_VAR 0 9
109623: GREATER
109624: IFFALSE 109832
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
109626: LD_ADDR_VAR 0 6
109630: PUSH
109631: LD_VAR 0 5
109635: PPUSH
109636: LD_INT 91
109638: PUSH
109639: LD_VAR 0 4
109643: PUSH
109644: LD_INT 8
109646: PUSH
109647: EMPTY
109648: LIST
109649: LIST
109650: LIST
109651: PPUSH
109652: CALL_OW 72
109656: ST_TO_ADDR
// if nearEnemy then
109657: LD_VAR 0 6
109661: IFFALSE 109730
// begin if GetWeapon ( i ) = ru_time_lapser then
109663: LD_VAR 0 4
109667: PPUSH
109668: CALL_OW 264
109672: PUSH
109673: LD_INT 49
109675: EQUAL
109676: IFFALSE 109704
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
109678: LD_VAR 0 4
109682: PPUSH
109683: LD_VAR 0 6
109687: PPUSH
109688: LD_VAR 0 4
109692: PPUSH
109693: CALL_OW 74
109697: PPUSH
109698: CALL_OW 112
109702: GO 109728
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
109704: LD_VAR 0 4
109708: PPUSH
109709: LD_VAR 0 6
109713: PPUSH
109714: LD_VAR 0 4
109718: PPUSH
109719: CALL_OW 74
109723: PPUSH
109724: CALL 110832 0 2
// end else
109728: GO 109830
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
109730: LD_VAR 0 4
109734: PPUSH
109735: LD_VAR 0 2
109739: PUSH
109740: LD_VAR 0 9
109744: ARRAY
109745: PUSH
109746: LD_INT 1
109748: ARRAY
109749: PPUSH
109750: LD_VAR 0 2
109754: PUSH
109755: LD_VAR 0 9
109759: ARRAY
109760: PUSH
109761: LD_INT 2
109763: ARRAY
109764: PPUSH
109765: CALL_OW 297
109769: PUSH
109770: LD_INT 6
109772: GREATER
109773: IFFALSE 109816
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
109775: LD_VAR 0 4
109779: PPUSH
109780: LD_VAR 0 2
109784: PUSH
109785: LD_VAR 0 9
109789: ARRAY
109790: PUSH
109791: LD_INT 1
109793: ARRAY
109794: PPUSH
109795: LD_VAR 0 2
109799: PUSH
109800: LD_VAR 0 9
109804: ARRAY
109805: PUSH
109806: LD_INT 2
109808: ARRAY
109809: PPUSH
109810: CALL_OW 114
109814: GO 109830
// SetTag ( i , tag ) ;
109816: LD_VAR 0 4
109820: PPUSH
109821: LD_VAR 0 9
109825: PPUSH
109826: CALL_OW 109
// end else
109830: GO 109903
// if enemy then
109832: LD_VAR 0 5
109836: IFFALSE 109903
// begin if GetWeapon ( i ) = ru_time_lapser then
109838: LD_VAR 0 4
109842: PPUSH
109843: CALL_OW 264
109847: PUSH
109848: LD_INT 49
109850: EQUAL
109851: IFFALSE 109879
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109853: LD_VAR 0 4
109857: PPUSH
109858: LD_VAR 0 5
109862: PPUSH
109863: LD_VAR 0 4
109867: PPUSH
109868: CALL_OW 74
109872: PPUSH
109873: CALL_OW 112
109877: GO 109903
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
109879: LD_VAR 0 4
109883: PPUSH
109884: LD_VAR 0 5
109888: PPUSH
109889: LD_VAR 0 4
109893: PPUSH
109894: CALL_OW 74
109898: PPUSH
109899: CALL 110832 0 2
// end ; end ;
109903: GO 109483
109905: POP
109906: POP
// end ;
109907: LD_VAR 0 3
109911: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
109912: LD_INT 0
109914: PPUSH
109915: PPUSH
109916: PPUSH
// if not unit or IsInUnit ( unit ) then
109917: LD_VAR 0 1
109921: NOT
109922: PUSH
109923: LD_VAR 0 1
109927: PPUSH
109928: CALL_OW 310
109932: OR
109933: IFFALSE 109937
// exit ;
109935: GO 110028
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
109937: LD_ADDR_VAR 0 4
109941: PUSH
109942: LD_VAR 0 1
109946: PPUSH
109947: CALL_OW 250
109951: PPUSH
109952: LD_VAR 0 2
109956: PPUSH
109957: LD_INT 1
109959: PPUSH
109960: CALL_OW 272
109964: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
109965: LD_ADDR_VAR 0 5
109969: PUSH
109970: LD_VAR 0 1
109974: PPUSH
109975: CALL_OW 251
109979: PPUSH
109980: LD_VAR 0 2
109984: PPUSH
109985: LD_INT 1
109987: PPUSH
109988: CALL_OW 273
109992: ST_TO_ADDR
// if ValidHex ( x , y ) then
109993: LD_VAR 0 4
109997: PPUSH
109998: LD_VAR 0 5
110002: PPUSH
110003: CALL_OW 488
110007: IFFALSE 110028
// ComTurnXY ( unit , x , y ) ;
110009: LD_VAR 0 1
110013: PPUSH
110014: LD_VAR 0 4
110018: PPUSH
110019: LD_VAR 0 5
110023: PPUSH
110024: CALL_OW 118
// end ;
110028: LD_VAR 0 3
110032: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110033: LD_INT 0
110035: PPUSH
110036: PPUSH
// result := false ;
110037: LD_ADDR_VAR 0 3
110041: PUSH
110042: LD_INT 0
110044: ST_TO_ADDR
// if not units then
110045: LD_VAR 0 2
110049: NOT
110050: IFFALSE 110054
// exit ;
110052: GO 110099
// for i in units do
110054: LD_ADDR_VAR 0 4
110058: PUSH
110059: LD_VAR 0 2
110063: PUSH
110064: FOR_IN
110065: IFFALSE 110097
// if See ( side , i ) then
110067: LD_VAR 0 1
110071: PPUSH
110072: LD_VAR 0 4
110076: PPUSH
110077: CALL_OW 292
110081: IFFALSE 110095
// begin result := true ;
110083: LD_ADDR_VAR 0 3
110087: PUSH
110088: LD_INT 1
110090: ST_TO_ADDR
// exit ;
110091: POP
110092: POP
110093: GO 110099
// end ;
110095: GO 110064
110097: POP
110098: POP
// end ;
110099: LD_VAR 0 3
110103: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110104: LD_INT 0
110106: PPUSH
110107: PPUSH
110108: PPUSH
110109: PPUSH
// if not unit or not points then
110110: LD_VAR 0 1
110114: NOT
110115: PUSH
110116: LD_VAR 0 2
110120: NOT
110121: OR
110122: IFFALSE 110126
// exit ;
110124: GO 110216
// dist := 99999 ;
110126: LD_ADDR_VAR 0 5
110130: PUSH
110131: LD_INT 99999
110133: ST_TO_ADDR
// for i in points do
110134: LD_ADDR_VAR 0 4
110138: PUSH
110139: LD_VAR 0 2
110143: PUSH
110144: FOR_IN
110145: IFFALSE 110214
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110147: LD_ADDR_VAR 0 6
110151: PUSH
110152: LD_VAR 0 1
110156: PPUSH
110157: LD_VAR 0 4
110161: PUSH
110162: LD_INT 1
110164: ARRAY
110165: PPUSH
110166: LD_VAR 0 4
110170: PUSH
110171: LD_INT 2
110173: ARRAY
110174: PPUSH
110175: CALL_OW 297
110179: ST_TO_ADDR
// if tmpDist < dist then
110180: LD_VAR 0 6
110184: PUSH
110185: LD_VAR 0 5
110189: LESS
110190: IFFALSE 110212
// begin result := i ;
110192: LD_ADDR_VAR 0 3
110196: PUSH
110197: LD_VAR 0 4
110201: ST_TO_ADDR
// dist := tmpDist ;
110202: LD_ADDR_VAR 0 5
110206: PUSH
110207: LD_VAR 0 6
110211: ST_TO_ADDR
// end ; end ;
110212: GO 110144
110214: POP
110215: POP
// end ;
110216: LD_VAR 0 3
110220: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110221: LD_INT 0
110223: PPUSH
// uc_side := side ;
110224: LD_ADDR_OWVAR 20
110228: PUSH
110229: LD_VAR 0 1
110233: ST_TO_ADDR
// uc_nation := 3 ;
110234: LD_ADDR_OWVAR 21
110238: PUSH
110239: LD_INT 3
110241: ST_TO_ADDR
// vc_chassis := 25 ;
110242: LD_ADDR_OWVAR 37
110246: PUSH
110247: LD_INT 25
110249: ST_TO_ADDR
// vc_engine := engine_siberite ;
110250: LD_ADDR_OWVAR 39
110254: PUSH
110255: LD_INT 3
110257: ST_TO_ADDR
// vc_control := control_computer ;
110258: LD_ADDR_OWVAR 38
110262: PUSH
110263: LD_INT 3
110265: ST_TO_ADDR
// vc_weapon := 59 ;
110266: LD_ADDR_OWVAR 40
110270: PUSH
110271: LD_INT 59
110273: ST_TO_ADDR
// result := CreateVehicle ;
110274: LD_ADDR_VAR 0 5
110278: PUSH
110279: CALL_OW 45
110283: ST_TO_ADDR
// SetDir ( result , d ) ;
110284: LD_VAR 0 5
110288: PPUSH
110289: LD_VAR 0 4
110293: PPUSH
110294: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110298: LD_VAR 0 5
110302: PPUSH
110303: LD_VAR 0 2
110307: PPUSH
110308: LD_VAR 0 3
110312: PPUSH
110313: LD_INT 0
110315: PPUSH
110316: CALL_OW 48
// end ;
110320: LD_VAR 0 5
110324: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110325: LD_INT 0
110327: PPUSH
110328: PPUSH
110329: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110330: LD_ADDR_VAR 0 2
110334: PUSH
110335: LD_INT 0
110337: PUSH
110338: LD_INT 0
110340: PUSH
110341: LD_INT 0
110343: PUSH
110344: LD_INT 0
110346: PUSH
110347: EMPTY
110348: LIST
110349: LIST
110350: LIST
110351: LIST
110352: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110353: LD_VAR 0 1
110357: NOT
110358: PUSH
110359: LD_VAR 0 1
110363: PPUSH
110364: CALL_OW 264
110368: PUSH
110369: LD_INT 12
110371: PUSH
110372: LD_INT 51
110374: PUSH
110375: LD_INT 32
110377: PUSH
110378: LD_INT 89
110380: PUSH
110381: EMPTY
110382: LIST
110383: LIST
110384: LIST
110385: LIST
110386: IN
110387: NOT
110388: OR
110389: IFFALSE 110393
// exit ;
110391: GO 110491
// for i := 1 to 3 do
110393: LD_ADDR_VAR 0 3
110397: PUSH
110398: DOUBLE
110399: LD_INT 1
110401: DEC
110402: ST_TO_ADDR
110403: LD_INT 3
110405: PUSH
110406: FOR_TO
110407: IFFALSE 110489
// begin tmp := GetCargo ( cargo , i ) ;
110409: LD_ADDR_VAR 0 4
110413: PUSH
110414: LD_VAR 0 1
110418: PPUSH
110419: LD_VAR 0 3
110423: PPUSH
110424: CALL_OW 289
110428: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
110429: LD_ADDR_VAR 0 2
110433: PUSH
110434: LD_VAR 0 2
110438: PPUSH
110439: LD_VAR 0 3
110443: PPUSH
110444: LD_VAR 0 4
110448: PPUSH
110449: CALL_OW 1
110453: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
110454: LD_ADDR_VAR 0 2
110458: PUSH
110459: LD_VAR 0 2
110463: PPUSH
110464: LD_INT 4
110466: PPUSH
110467: LD_VAR 0 2
110471: PUSH
110472: LD_INT 4
110474: ARRAY
110475: PUSH
110476: LD_VAR 0 4
110480: PLUS
110481: PPUSH
110482: CALL_OW 1
110486: ST_TO_ADDR
// end ;
110487: GO 110406
110489: POP
110490: POP
// end ;
110491: LD_VAR 0 2
110495: RET
// export function Length ( array ) ; begin
110496: LD_INT 0
110498: PPUSH
// result := array + 0 ;
110499: LD_ADDR_VAR 0 2
110503: PUSH
110504: LD_VAR 0 1
110508: PUSH
110509: LD_INT 0
110511: PLUS
110512: ST_TO_ADDR
// end ;
110513: LD_VAR 0 2
110517: RET
// export function PrepareArray ( array ) ; begin
110518: LD_INT 0
110520: PPUSH
// result := array diff 0 ;
110521: LD_ADDR_VAR 0 2
110525: PUSH
110526: LD_VAR 0 1
110530: PUSH
110531: LD_INT 0
110533: DIFF
110534: ST_TO_ADDR
// if not result [ 1 ] then
110535: LD_VAR 0 2
110539: PUSH
110540: LD_INT 1
110542: ARRAY
110543: NOT
110544: IFFALSE 110564
// result := Delete ( result , 1 ) ;
110546: LD_ADDR_VAR 0 2
110550: PUSH
110551: LD_VAR 0 2
110555: PPUSH
110556: LD_INT 1
110558: PPUSH
110559: CALL_OW 3
110563: ST_TO_ADDR
// end ;
110564: LD_VAR 0 2
110568: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
110569: LD_INT 0
110571: PPUSH
110572: PPUSH
110573: PPUSH
110574: PPUSH
// sibRocketRange := 25 ;
110575: LD_ADDR_VAR 0 6
110579: PUSH
110580: LD_INT 25
110582: ST_TO_ADDR
// result := false ;
110583: LD_ADDR_VAR 0 4
110587: PUSH
110588: LD_INT 0
110590: ST_TO_ADDR
// for i := 0 to 5 do
110591: LD_ADDR_VAR 0 5
110595: PUSH
110596: DOUBLE
110597: LD_INT 0
110599: DEC
110600: ST_TO_ADDR
110601: LD_INT 5
110603: PUSH
110604: FOR_TO
110605: IFFALSE 110672
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
110607: LD_VAR 0 1
110611: PPUSH
110612: LD_VAR 0 5
110616: PPUSH
110617: LD_VAR 0 6
110621: PPUSH
110622: CALL_OW 272
110626: PPUSH
110627: LD_VAR 0 2
110631: PPUSH
110632: LD_VAR 0 5
110636: PPUSH
110637: LD_VAR 0 6
110641: PPUSH
110642: CALL_OW 273
110646: PPUSH
110647: LD_VAR 0 3
110651: PPUSH
110652: CALL_OW 309
110656: IFFALSE 110670
// begin result := true ;
110658: LD_ADDR_VAR 0 4
110662: PUSH
110663: LD_INT 1
110665: ST_TO_ADDR
// exit ;
110666: POP
110667: POP
110668: GO 110674
// end ;
110670: GO 110604
110672: POP
110673: POP
// end ;
110674: LD_VAR 0 4
110678: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
110679: LD_INT 0
110681: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
110682: LD_VAR 0 1
110686: PPUSH
110687: LD_VAR 0 2
110691: PPUSH
110692: LD_INT 0
110694: PPUSH
110695: LD_INT 0
110697: PPUSH
110698: LD_INT 1
110700: PPUSH
110701: LD_INT 0
110703: PPUSH
110704: CALL_OW 587
// end ;
110708: LD_VAR 0 3
110712: RET
// export function CenterOnNow ( unit ) ; begin
110713: LD_INT 0
110715: PPUSH
// result := IsInUnit ( unit ) ;
110716: LD_ADDR_VAR 0 2
110720: PUSH
110721: LD_VAR 0 1
110725: PPUSH
110726: CALL_OW 310
110730: ST_TO_ADDR
// if not result then
110731: LD_VAR 0 2
110735: NOT
110736: IFFALSE 110748
// result := unit ;
110738: LD_ADDR_VAR 0 2
110742: PUSH
110743: LD_VAR 0 1
110747: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
110748: LD_VAR 0 1
110752: PPUSH
110753: CALL_OW 87
// end ;
110757: LD_VAR 0 2
110761: RET
// export function ComMoveHex ( unit , hex ) ; begin
110762: LD_INT 0
110764: PPUSH
// if not hex then
110765: LD_VAR 0 2
110769: NOT
110770: IFFALSE 110774
// exit ;
110772: GO 110827
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
110774: LD_VAR 0 2
110778: PUSH
110779: LD_INT 1
110781: ARRAY
110782: PPUSH
110783: LD_VAR 0 2
110787: PUSH
110788: LD_INT 2
110790: ARRAY
110791: PPUSH
110792: CALL_OW 428
110796: IFFALSE 110800
// exit ;
110798: GO 110827
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
110800: LD_VAR 0 1
110804: PPUSH
110805: LD_VAR 0 2
110809: PUSH
110810: LD_INT 1
110812: ARRAY
110813: PPUSH
110814: LD_VAR 0 2
110818: PUSH
110819: LD_INT 2
110821: ARRAY
110822: PPUSH
110823: CALL_OW 111
// end ;
110827: LD_VAR 0 3
110831: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
110832: LD_INT 0
110834: PPUSH
110835: PPUSH
110836: PPUSH
// if not unit or not enemy then
110837: LD_VAR 0 1
110841: NOT
110842: PUSH
110843: LD_VAR 0 2
110847: NOT
110848: OR
110849: IFFALSE 110853
// exit ;
110851: GO 110977
// x := GetX ( enemy ) ;
110853: LD_ADDR_VAR 0 4
110857: PUSH
110858: LD_VAR 0 2
110862: PPUSH
110863: CALL_OW 250
110867: ST_TO_ADDR
// y := GetY ( enemy ) ;
110868: LD_ADDR_VAR 0 5
110872: PUSH
110873: LD_VAR 0 2
110877: PPUSH
110878: CALL_OW 251
110882: ST_TO_ADDR
// if ValidHex ( x , y ) then
110883: LD_VAR 0 4
110887: PPUSH
110888: LD_VAR 0 5
110892: PPUSH
110893: CALL_OW 488
110897: IFFALSE 110977
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
110899: LD_VAR 0 2
110903: PPUSH
110904: CALL_OW 247
110908: PUSH
110909: LD_INT 3
110911: PUSH
110912: LD_INT 2
110914: PUSH
110915: EMPTY
110916: LIST
110917: LIST
110918: IN
110919: PUSH
110920: LD_VAR 0 1
110924: PPUSH
110925: CALL_OW 255
110929: PPUSH
110930: LD_VAR 0 2
110934: PPUSH
110935: CALL_OW 292
110939: AND
110940: IFFALSE 110958
// ComAttackUnit ( unit , enemy ) else
110942: LD_VAR 0 1
110946: PPUSH
110947: LD_VAR 0 2
110951: PPUSH
110952: CALL_OW 115
110956: GO 110977
// ComAgressiveMove ( unit , x , y ) ;
110958: LD_VAR 0 1
110962: PPUSH
110963: LD_VAR 0 4
110967: PPUSH
110968: LD_VAR 0 5
110972: PPUSH
110973: CALL_OW 114
// end ; end_of_file end_of_file
110977: LD_VAR 0 3
110981: RET
// export globalGameSaveCounter ; every 0 0$1 do
110982: GO 110984
110984: DISABLE
// begin enable ;
110985: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
110986: LD_STRING updateTimer(
110988: PUSH
110989: LD_OWVAR 1
110993: STR
110994: PUSH
110995: LD_STRING );
110997: STR
110998: PPUSH
110999: CALL_OW 559
// end ;
111003: END
// every 0 0$1 do
111004: GO 111006
111006: DISABLE
// begin globalGameSaveCounter := 0 ;
111007: LD_ADDR_EXP 146
111011: PUSH
111012: LD_INT 0
111014: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
111015: LD_STRING setGameSaveCounter(0)
111017: PPUSH
111018: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
111022: LD_STRING initStreamRollete();
111024: PPUSH
111025: CALL_OW 559
// InitStreamMode ;
111029: CALL 112355 0 0
// DefineStreamItems ( false ) ;
111033: LD_INT 0
111035: PPUSH
111036: CALL 112819 0 1
// end ;
111040: END
// export function SOS_MapStart ( ) ; begin
111041: LD_INT 0
111043: PPUSH
// if streamModeActive then
111044: LD_EXP 147
111048: IFFALSE 111057
// DefineStreamItems ( true ) ;
111050: LD_INT 1
111052: PPUSH
111053: CALL 112819 0 1
// UpdateLuaVariables ( ) ;
111057: CALL 111074 0 0
// UpdateFactoryWaypoints ( ) ;
111061: CALL 125688 0 0
// UpdateWarehouseGatheringPoints ( ) ;
111065: CALL 125945 0 0
// end ;
111069: LD_VAR 0 1
111073: RET
// function UpdateLuaVariables ( ) ; begin
111074: LD_INT 0
111076: PPUSH
// if globalGameSaveCounter then
111077: LD_EXP 146
111081: IFFALSE 111115
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
111083: LD_ADDR_EXP 146
111087: PUSH
111088: LD_EXP 146
111092: PPUSH
111093: CALL 108121 0 1
111097: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
111098: LD_STRING setGameSaveCounter(
111100: PUSH
111101: LD_EXP 146
111105: STR
111106: PUSH
111107: LD_STRING )
111109: STR
111110: PPUSH
111111: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
111115: LD_STRING setGameDifficulty(
111117: PUSH
111118: LD_OWVAR 67
111122: STR
111123: PUSH
111124: LD_STRING )
111126: STR
111127: PPUSH
111128: CALL_OW 559
// end ;
111132: LD_VAR 0 1
111136: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
111137: LD_INT 0
111139: PPUSH
// if p2 = stream_mode then
111140: LD_VAR 0 2
111144: PUSH
111145: LD_INT 100
111147: EQUAL
111148: IFFALSE 112151
// begin if not StreamModeActive then
111150: LD_EXP 147
111154: NOT
111155: IFFALSE 111165
// StreamModeActive := true ;
111157: LD_ADDR_EXP 147
111161: PUSH
111162: LD_INT 1
111164: ST_TO_ADDR
// if p3 = 0 then
111165: LD_VAR 0 3
111169: PUSH
111170: LD_INT 0
111172: EQUAL
111173: IFFALSE 111179
// InitStreamMode ;
111175: CALL 112355 0 0
// if p3 = 1 then
111179: LD_VAR 0 3
111183: PUSH
111184: LD_INT 1
111186: EQUAL
111187: IFFALSE 111197
// sRocket := true ;
111189: LD_ADDR_EXP 152
111193: PUSH
111194: LD_INT 1
111196: ST_TO_ADDR
// if p3 = 2 then
111197: LD_VAR 0 3
111201: PUSH
111202: LD_INT 2
111204: EQUAL
111205: IFFALSE 111215
// sSpeed := true ;
111207: LD_ADDR_EXP 151
111211: PUSH
111212: LD_INT 1
111214: ST_TO_ADDR
// if p3 = 3 then
111215: LD_VAR 0 3
111219: PUSH
111220: LD_INT 3
111222: EQUAL
111223: IFFALSE 111233
// sEngine := true ;
111225: LD_ADDR_EXP 153
111229: PUSH
111230: LD_INT 1
111232: ST_TO_ADDR
// if p3 = 4 then
111233: LD_VAR 0 3
111237: PUSH
111238: LD_INT 4
111240: EQUAL
111241: IFFALSE 111251
// sSpec := true ;
111243: LD_ADDR_EXP 150
111247: PUSH
111248: LD_INT 1
111250: ST_TO_ADDR
// if p3 = 5 then
111251: LD_VAR 0 3
111255: PUSH
111256: LD_INT 5
111258: EQUAL
111259: IFFALSE 111269
// sLevel := true ;
111261: LD_ADDR_EXP 154
111265: PUSH
111266: LD_INT 1
111268: ST_TO_ADDR
// if p3 = 6 then
111269: LD_VAR 0 3
111273: PUSH
111274: LD_INT 6
111276: EQUAL
111277: IFFALSE 111287
// sArmoury := true ;
111279: LD_ADDR_EXP 155
111283: PUSH
111284: LD_INT 1
111286: ST_TO_ADDR
// if p3 = 7 then
111287: LD_VAR 0 3
111291: PUSH
111292: LD_INT 7
111294: EQUAL
111295: IFFALSE 111305
// sRadar := true ;
111297: LD_ADDR_EXP 156
111301: PUSH
111302: LD_INT 1
111304: ST_TO_ADDR
// if p3 = 8 then
111305: LD_VAR 0 3
111309: PUSH
111310: LD_INT 8
111312: EQUAL
111313: IFFALSE 111323
// sBunker := true ;
111315: LD_ADDR_EXP 157
111319: PUSH
111320: LD_INT 1
111322: ST_TO_ADDR
// if p3 = 9 then
111323: LD_VAR 0 3
111327: PUSH
111328: LD_INT 9
111330: EQUAL
111331: IFFALSE 111341
// sHack := true ;
111333: LD_ADDR_EXP 158
111337: PUSH
111338: LD_INT 1
111340: ST_TO_ADDR
// if p3 = 10 then
111341: LD_VAR 0 3
111345: PUSH
111346: LD_INT 10
111348: EQUAL
111349: IFFALSE 111359
// sFire := true ;
111351: LD_ADDR_EXP 159
111355: PUSH
111356: LD_INT 1
111358: ST_TO_ADDR
// if p3 = 11 then
111359: LD_VAR 0 3
111363: PUSH
111364: LD_INT 11
111366: EQUAL
111367: IFFALSE 111377
// sRefresh := true ;
111369: LD_ADDR_EXP 160
111373: PUSH
111374: LD_INT 1
111376: ST_TO_ADDR
// if p3 = 12 then
111377: LD_VAR 0 3
111381: PUSH
111382: LD_INT 12
111384: EQUAL
111385: IFFALSE 111395
// sExp := true ;
111387: LD_ADDR_EXP 161
111391: PUSH
111392: LD_INT 1
111394: ST_TO_ADDR
// if p3 = 13 then
111395: LD_VAR 0 3
111399: PUSH
111400: LD_INT 13
111402: EQUAL
111403: IFFALSE 111413
// sDepot := true ;
111405: LD_ADDR_EXP 162
111409: PUSH
111410: LD_INT 1
111412: ST_TO_ADDR
// if p3 = 14 then
111413: LD_VAR 0 3
111417: PUSH
111418: LD_INT 14
111420: EQUAL
111421: IFFALSE 111431
// sFlag := true ;
111423: LD_ADDR_EXP 163
111427: PUSH
111428: LD_INT 1
111430: ST_TO_ADDR
// if p3 = 15 then
111431: LD_VAR 0 3
111435: PUSH
111436: LD_INT 15
111438: EQUAL
111439: IFFALSE 111449
// sKamikadze := true ;
111441: LD_ADDR_EXP 171
111445: PUSH
111446: LD_INT 1
111448: ST_TO_ADDR
// if p3 = 16 then
111449: LD_VAR 0 3
111453: PUSH
111454: LD_INT 16
111456: EQUAL
111457: IFFALSE 111467
// sTroll := true ;
111459: LD_ADDR_EXP 172
111463: PUSH
111464: LD_INT 1
111466: ST_TO_ADDR
// if p3 = 17 then
111467: LD_VAR 0 3
111471: PUSH
111472: LD_INT 17
111474: EQUAL
111475: IFFALSE 111485
// sSlow := true ;
111477: LD_ADDR_EXP 173
111481: PUSH
111482: LD_INT 1
111484: ST_TO_ADDR
// if p3 = 18 then
111485: LD_VAR 0 3
111489: PUSH
111490: LD_INT 18
111492: EQUAL
111493: IFFALSE 111503
// sLack := true ;
111495: LD_ADDR_EXP 174
111499: PUSH
111500: LD_INT 1
111502: ST_TO_ADDR
// if p3 = 19 then
111503: LD_VAR 0 3
111507: PUSH
111508: LD_INT 19
111510: EQUAL
111511: IFFALSE 111521
// sTank := true ;
111513: LD_ADDR_EXP 176
111517: PUSH
111518: LD_INT 1
111520: ST_TO_ADDR
// if p3 = 20 then
111521: LD_VAR 0 3
111525: PUSH
111526: LD_INT 20
111528: EQUAL
111529: IFFALSE 111539
// sRemote := true ;
111531: LD_ADDR_EXP 177
111535: PUSH
111536: LD_INT 1
111538: ST_TO_ADDR
// if p3 = 21 then
111539: LD_VAR 0 3
111543: PUSH
111544: LD_INT 21
111546: EQUAL
111547: IFFALSE 111557
// sPowell := true ;
111549: LD_ADDR_EXP 178
111553: PUSH
111554: LD_INT 1
111556: ST_TO_ADDR
// if p3 = 22 then
111557: LD_VAR 0 3
111561: PUSH
111562: LD_INT 22
111564: EQUAL
111565: IFFALSE 111575
// sTeleport := true ;
111567: LD_ADDR_EXP 181
111571: PUSH
111572: LD_INT 1
111574: ST_TO_ADDR
// if p3 = 23 then
111575: LD_VAR 0 3
111579: PUSH
111580: LD_INT 23
111582: EQUAL
111583: IFFALSE 111593
// sOilTower := true ;
111585: LD_ADDR_EXP 183
111589: PUSH
111590: LD_INT 1
111592: ST_TO_ADDR
// if p3 = 24 then
111593: LD_VAR 0 3
111597: PUSH
111598: LD_INT 24
111600: EQUAL
111601: IFFALSE 111611
// sShovel := true ;
111603: LD_ADDR_EXP 184
111607: PUSH
111608: LD_INT 1
111610: ST_TO_ADDR
// if p3 = 25 then
111611: LD_VAR 0 3
111615: PUSH
111616: LD_INT 25
111618: EQUAL
111619: IFFALSE 111629
// sSheik := true ;
111621: LD_ADDR_EXP 185
111625: PUSH
111626: LD_INT 1
111628: ST_TO_ADDR
// if p3 = 26 then
111629: LD_VAR 0 3
111633: PUSH
111634: LD_INT 26
111636: EQUAL
111637: IFFALSE 111647
// sEarthquake := true ;
111639: LD_ADDR_EXP 187
111643: PUSH
111644: LD_INT 1
111646: ST_TO_ADDR
// if p3 = 27 then
111647: LD_VAR 0 3
111651: PUSH
111652: LD_INT 27
111654: EQUAL
111655: IFFALSE 111665
// sAI := true ;
111657: LD_ADDR_EXP 188
111661: PUSH
111662: LD_INT 1
111664: ST_TO_ADDR
// if p3 = 28 then
111665: LD_VAR 0 3
111669: PUSH
111670: LD_INT 28
111672: EQUAL
111673: IFFALSE 111683
// sCargo := true ;
111675: LD_ADDR_EXP 191
111679: PUSH
111680: LD_INT 1
111682: ST_TO_ADDR
// if p3 = 29 then
111683: LD_VAR 0 3
111687: PUSH
111688: LD_INT 29
111690: EQUAL
111691: IFFALSE 111701
// sDLaser := true ;
111693: LD_ADDR_EXP 192
111697: PUSH
111698: LD_INT 1
111700: ST_TO_ADDR
// if p3 = 30 then
111701: LD_VAR 0 3
111705: PUSH
111706: LD_INT 30
111708: EQUAL
111709: IFFALSE 111719
// sExchange := true ;
111711: LD_ADDR_EXP 193
111715: PUSH
111716: LD_INT 1
111718: ST_TO_ADDR
// if p3 = 31 then
111719: LD_VAR 0 3
111723: PUSH
111724: LD_INT 31
111726: EQUAL
111727: IFFALSE 111737
// sFac := true ;
111729: LD_ADDR_EXP 194
111733: PUSH
111734: LD_INT 1
111736: ST_TO_ADDR
// if p3 = 32 then
111737: LD_VAR 0 3
111741: PUSH
111742: LD_INT 32
111744: EQUAL
111745: IFFALSE 111755
// sPower := true ;
111747: LD_ADDR_EXP 195
111751: PUSH
111752: LD_INT 1
111754: ST_TO_ADDR
// if p3 = 33 then
111755: LD_VAR 0 3
111759: PUSH
111760: LD_INT 33
111762: EQUAL
111763: IFFALSE 111773
// sRandom := true ;
111765: LD_ADDR_EXP 196
111769: PUSH
111770: LD_INT 1
111772: ST_TO_ADDR
// if p3 = 34 then
111773: LD_VAR 0 3
111777: PUSH
111778: LD_INT 34
111780: EQUAL
111781: IFFALSE 111791
// sShield := true ;
111783: LD_ADDR_EXP 197
111787: PUSH
111788: LD_INT 1
111790: ST_TO_ADDR
// if p3 = 35 then
111791: LD_VAR 0 3
111795: PUSH
111796: LD_INT 35
111798: EQUAL
111799: IFFALSE 111809
// sTime := true ;
111801: LD_ADDR_EXP 198
111805: PUSH
111806: LD_INT 1
111808: ST_TO_ADDR
// if p3 = 36 then
111809: LD_VAR 0 3
111813: PUSH
111814: LD_INT 36
111816: EQUAL
111817: IFFALSE 111827
// sTools := true ;
111819: LD_ADDR_EXP 199
111823: PUSH
111824: LD_INT 1
111826: ST_TO_ADDR
// if p3 = 101 then
111827: LD_VAR 0 3
111831: PUSH
111832: LD_INT 101
111834: EQUAL
111835: IFFALSE 111845
// sSold := true ;
111837: LD_ADDR_EXP 164
111841: PUSH
111842: LD_INT 1
111844: ST_TO_ADDR
// if p3 = 102 then
111845: LD_VAR 0 3
111849: PUSH
111850: LD_INT 102
111852: EQUAL
111853: IFFALSE 111863
// sDiff := true ;
111855: LD_ADDR_EXP 165
111859: PUSH
111860: LD_INT 1
111862: ST_TO_ADDR
// if p3 = 103 then
111863: LD_VAR 0 3
111867: PUSH
111868: LD_INT 103
111870: EQUAL
111871: IFFALSE 111881
// sFog := true ;
111873: LD_ADDR_EXP 168
111877: PUSH
111878: LD_INT 1
111880: ST_TO_ADDR
// if p3 = 104 then
111881: LD_VAR 0 3
111885: PUSH
111886: LD_INT 104
111888: EQUAL
111889: IFFALSE 111899
// sReset := true ;
111891: LD_ADDR_EXP 169
111895: PUSH
111896: LD_INT 1
111898: ST_TO_ADDR
// if p3 = 105 then
111899: LD_VAR 0 3
111903: PUSH
111904: LD_INT 105
111906: EQUAL
111907: IFFALSE 111917
// sSun := true ;
111909: LD_ADDR_EXP 170
111913: PUSH
111914: LD_INT 1
111916: ST_TO_ADDR
// if p3 = 106 then
111917: LD_VAR 0 3
111921: PUSH
111922: LD_INT 106
111924: EQUAL
111925: IFFALSE 111935
// sTiger := true ;
111927: LD_ADDR_EXP 166
111931: PUSH
111932: LD_INT 1
111934: ST_TO_ADDR
// if p3 = 107 then
111935: LD_VAR 0 3
111939: PUSH
111940: LD_INT 107
111942: EQUAL
111943: IFFALSE 111953
// sBomb := true ;
111945: LD_ADDR_EXP 167
111949: PUSH
111950: LD_INT 1
111952: ST_TO_ADDR
// if p3 = 108 then
111953: LD_VAR 0 3
111957: PUSH
111958: LD_INT 108
111960: EQUAL
111961: IFFALSE 111971
// sWound := true ;
111963: LD_ADDR_EXP 175
111967: PUSH
111968: LD_INT 1
111970: ST_TO_ADDR
// if p3 = 109 then
111971: LD_VAR 0 3
111975: PUSH
111976: LD_INT 109
111978: EQUAL
111979: IFFALSE 111989
// sBetray := true ;
111981: LD_ADDR_EXP 179
111985: PUSH
111986: LD_INT 1
111988: ST_TO_ADDR
// if p3 = 110 then
111989: LD_VAR 0 3
111993: PUSH
111994: LD_INT 110
111996: EQUAL
111997: IFFALSE 112007
// sContamin := true ;
111999: LD_ADDR_EXP 180
112003: PUSH
112004: LD_INT 1
112006: ST_TO_ADDR
// if p3 = 111 then
112007: LD_VAR 0 3
112011: PUSH
112012: LD_INT 111
112014: EQUAL
112015: IFFALSE 112025
// sOil := true ;
112017: LD_ADDR_EXP 182
112021: PUSH
112022: LD_INT 1
112024: ST_TO_ADDR
// if p3 = 112 then
112025: LD_VAR 0 3
112029: PUSH
112030: LD_INT 112
112032: EQUAL
112033: IFFALSE 112043
// sStu := true ;
112035: LD_ADDR_EXP 186
112039: PUSH
112040: LD_INT 1
112042: ST_TO_ADDR
// if p3 = 113 then
112043: LD_VAR 0 3
112047: PUSH
112048: LD_INT 113
112050: EQUAL
112051: IFFALSE 112061
// sBazooka := true ;
112053: LD_ADDR_EXP 189
112057: PUSH
112058: LD_INT 1
112060: ST_TO_ADDR
// if p3 = 114 then
112061: LD_VAR 0 3
112065: PUSH
112066: LD_INT 114
112068: EQUAL
112069: IFFALSE 112079
// sMortar := true ;
112071: LD_ADDR_EXP 190
112075: PUSH
112076: LD_INT 1
112078: ST_TO_ADDR
// if p3 = 115 then
112079: LD_VAR 0 3
112083: PUSH
112084: LD_INT 115
112086: EQUAL
112087: IFFALSE 112097
// sRanger := true ;
112089: LD_ADDR_EXP 200
112093: PUSH
112094: LD_INT 1
112096: ST_TO_ADDR
// if p3 = 116 then
112097: LD_VAR 0 3
112101: PUSH
112102: LD_INT 116
112104: EQUAL
112105: IFFALSE 112115
// sComputer := true ;
112107: LD_ADDR_EXP 201
112111: PUSH
112112: LD_INT 1
112114: ST_TO_ADDR
// if p3 = 117 then
112115: LD_VAR 0 3
112119: PUSH
112120: LD_INT 117
112122: EQUAL
112123: IFFALSE 112133
// s30 := true ;
112125: LD_ADDR_EXP 202
112129: PUSH
112130: LD_INT 1
112132: ST_TO_ADDR
// if p3 = 118 then
112133: LD_VAR 0 3
112137: PUSH
112138: LD_INT 118
112140: EQUAL
112141: IFFALSE 112151
// s60 := true ;
112143: LD_ADDR_EXP 203
112147: PUSH
112148: LD_INT 1
112150: ST_TO_ADDR
// end ; if p2 = hack_mode then
112151: LD_VAR 0 2
112155: PUSH
112156: LD_INT 101
112158: EQUAL
112159: IFFALSE 112287
// begin case p3 of 1 :
112161: LD_VAR 0 3
112165: PUSH
112166: LD_INT 1
112168: DOUBLE
112169: EQUAL
112170: IFTRUE 112174
112172: GO 112181
112174: POP
// hHackUnlimitedResources ; 2 :
112175: CALL 124434 0 0
112179: GO 112287
112181: LD_INT 2
112183: DOUBLE
112184: EQUAL
112185: IFTRUE 112189
112187: GO 112196
112189: POP
// hHackSetLevel10 ; 3 :
112190: CALL 124567 0 0
112194: GO 112287
112196: LD_INT 3
112198: DOUBLE
112199: EQUAL
112200: IFTRUE 112204
112202: GO 112211
112204: POP
// hHackSetLevel10YourUnits ; 4 :
112205: CALL 124652 0 0
112209: GO 112287
112211: LD_INT 4
112213: DOUBLE
112214: EQUAL
112215: IFTRUE 112219
112217: GO 112226
112219: POP
// hHackInvincible ; 5 :
112220: CALL 125100 0 0
112224: GO 112287
112226: LD_INT 5
112228: DOUBLE
112229: EQUAL
112230: IFTRUE 112234
112232: GO 112241
112234: POP
// hHackInvisible ; 6 :
112235: CALL 125211 0 0
112239: GO 112287
112241: LD_INT 6
112243: DOUBLE
112244: EQUAL
112245: IFTRUE 112249
112247: GO 112256
112249: POP
// hHackChangeYourSide ; 7 :
112250: CALL 125268 0 0
112254: GO 112287
112256: LD_INT 7
112258: DOUBLE
112259: EQUAL
112260: IFTRUE 112264
112262: GO 112271
112264: POP
// hHackChangeUnitSide ; 8 :
112265: CALL 125310 0 0
112269: GO 112287
112271: LD_INT 8
112273: DOUBLE
112274: EQUAL
112275: IFTRUE 112279
112277: GO 112286
112279: POP
// hHackFog ; end ;
112280: CALL 125411 0 0
112284: GO 112287
112286: POP
// end ; if p2 = game_save_mode then
112287: LD_VAR 0 2
112291: PUSH
112292: LD_INT 102
112294: EQUAL
112295: IFFALSE 112350
// begin if p3 = 1 then
112297: LD_VAR 0 3
112301: PUSH
112302: LD_INT 1
112304: EQUAL
112305: IFFALSE 112317
// globalGameSaveCounter := p4 ;
112307: LD_ADDR_EXP 146
112311: PUSH
112312: LD_VAR 0 4
112316: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
112317: LD_VAR 0 3
112321: PUSH
112322: LD_INT 2
112324: EQUAL
112325: PUSH
112326: LD_EXP 146
112330: AND
112331: IFFALSE 112350
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112333: LD_STRING setGameSaveCounter(
112335: PUSH
112336: LD_EXP 146
112340: STR
112341: PUSH
112342: LD_STRING )
112344: STR
112345: PPUSH
112346: CALL_OW 559
// end ; end ;
112350: LD_VAR 0 7
112354: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
112355: LD_INT 0
112357: PPUSH
// streamModeActive := false ;
112358: LD_ADDR_EXP 147
112362: PUSH
112363: LD_INT 0
112365: ST_TO_ADDR
// normalCounter := 36 ;
112366: LD_ADDR_EXP 148
112370: PUSH
112371: LD_INT 36
112373: ST_TO_ADDR
// hardcoreCounter := 18 ;
112374: LD_ADDR_EXP 149
112378: PUSH
112379: LD_INT 18
112381: ST_TO_ADDR
// sRocket := false ;
112382: LD_ADDR_EXP 152
112386: PUSH
112387: LD_INT 0
112389: ST_TO_ADDR
// sSpeed := false ;
112390: LD_ADDR_EXP 151
112394: PUSH
112395: LD_INT 0
112397: ST_TO_ADDR
// sEngine := false ;
112398: LD_ADDR_EXP 153
112402: PUSH
112403: LD_INT 0
112405: ST_TO_ADDR
// sSpec := false ;
112406: LD_ADDR_EXP 150
112410: PUSH
112411: LD_INT 0
112413: ST_TO_ADDR
// sLevel := false ;
112414: LD_ADDR_EXP 154
112418: PUSH
112419: LD_INT 0
112421: ST_TO_ADDR
// sArmoury := false ;
112422: LD_ADDR_EXP 155
112426: PUSH
112427: LD_INT 0
112429: ST_TO_ADDR
// sRadar := false ;
112430: LD_ADDR_EXP 156
112434: PUSH
112435: LD_INT 0
112437: ST_TO_ADDR
// sBunker := false ;
112438: LD_ADDR_EXP 157
112442: PUSH
112443: LD_INT 0
112445: ST_TO_ADDR
// sHack := false ;
112446: LD_ADDR_EXP 158
112450: PUSH
112451: LD_INT 0
112453: ST_TO_ADDR
// sFire := false ;
112454: LD_ADDR_EXP 159
112458: PUSH
112459: LD_INT 0
112461: ST_TO_ADDR
// sRefresh := false ;
112462: LD_ADDR_EXP 160
112466: PUSH
112467: LD_INT 0
112469: ST_TO_ADDR
// sExp := false ;
112470: LD_ADDR_EXP 161
112474: PUSH
112475: LD_INT 0
112477: ST_TO_ADDR
// sDepot := false ;
112478: LD_ADDR_EXP 162
112482: PUSH
112483: LD_INT 0
112485: ST_TO_ADDR
// sFlag := false ;
112486: LD_ADDR_EXP 163
112490: PUSH
112491: LD_INT 0
112493: ST_TO_ADDR
// sKamikadze := false ;
112494: LD_ADDR_EXP 171
112498: PUSH
112499: LD_INT 0
112501: ST_TO_ADDR
// sTroll := false ;
112502: LD_ADDR_EXP 172
112506: PUSH
112507: LD_INT 0
112509: ST_TO_ADDR
// sSlow := false ;
112510: LD_ADDR_EXP 173
112514: PUSH
112515: LD_INT 0
112517: ST_TO_ADDR
// sLack := false ;
112518: LD_ADDR_EXP 174
112522: PUSH
112523: LD_INT 0
112525: ST_TO_ADDR
// sTank := false ;
112526: LD_ADDR_EXP 176
112530: PUSH
112531: LD_INT 0
112533: ST_TO_ADDR
// sRemote := false ;
112534: LD_ADDR_EXP 177
112538: PUSH
112539: LD_INT 0
112541: ST_TO_ADDR
// sPowell := false ;
112542: LD_ADDR_EXP 178
112546: PUSH
112547: LD_INT 0
112549: ST_TO_ADDR
// sTeleport := false ;
112550: LD_ADDR_EXP 181
112554: PUSH
112555: LD_INT 0
112557: ST_TO_ADDR
// sOilTower := false ;
112558: LD_ADDR_EXP 183
112562: PUSH
112563: LD_INT 0
112565: ST_TO_ADDR
// sShovel := false ;
112566: LD_ADDR_EXP 184
112570: PUSH
112571: LD_INT 0
112573: ST_TO_ADDR
// sSheik := false ;
112574: LD_ADDR_EXP 185
112578: PUSH
112579: LD_INT 0
112581: ST_TO_ADDR
// sEarthquake := false ;
112582: LD_ADDR_EXP 187
112586: PUSH
112587: LD_INT 0
112589: ST_TO_ADDR
// sAI := false ;
112590: LD_ADDR_EXP 188
112594: PUSH
112595: LD_INT 0
112597: ST_TO_ADDR
// sCargo := false ;
112598: LD_ADDR_EXP 191
112602: PUSH
112603: LD_INT 0
112605: ST_TO_ADDR
// sDLaser := false ;
112606: LD_ADDR_EXP 192
112610: PUSH
112611: LD_INT 0
112613: ST_TO_ADDR
// sExchange := false ;
112614: LD_ADDR_EXP 193
112618: PUSH
112619: LD_INT 0
112621: ST_TO_ADDR
// sFac := false ;
112622: LD_ADDR_EXP 194
112626: PUSH
112627: LD_INT 0
112629: ST_TO_ADDR
// sPower := false ;
112630: LD_ADDR_EXP 195
112634: PUSH
112635: LD_INT 0
112637: ST_TO_ADDR
// sRandom := false ;
112638: LD_ADDR_EXP 196
112642: PUSH
112643: LD_INT 0
112645: ST_TO_ADDR
// sShield := false ;
112646: LD_ADDR_EXP 197
112650: PUSH
112651: LD_INT 0
112653: ST_TO_ADDR
// sTime := false ;
112654: LD_ADDR_EXP 198
112658: PUSH
112659: LD_INT 0
112661: ST_TO_ADDR
// sTools := false ;
112662: LD_ADDR_EXP 199
112666: PUSH
112667: LD_INT 0
112669: ST_TO_ADDR
// sSold := false ;
112670: LD_ADDR_EXP 164
112674: PUSH
112675: LD_INT 0
112677: ST_TO_ADDR
// sDiff := false ;
112678: LD_ADDR_EXP 165
112682: PUSH
112683: LD_INT 0
112685: ST_TO_ADDR
// sFog := false ;
112686: LD_ADDR_EXP 168
112690: PUSH
112691: LD_INT 0
112693: ST_TO_ADDR
// sReset := false ;
112694: LD_ADDR_EXP 169
112698: PUSH
112699: LD_INT 0
112701: ST_TO_ADDR
// sSun := false ;
112702: LD_ADDR_EXP 170
112706: PUSH
112707: LD_INT 0
112709: ST_TO_ADDR
// sTiger := false ;
112710: LD_ADDR_EXP 166
112714: PUSH
112715: LD_INT 0
112717: ST_TO_ADDR
// sBomb := false ;
112718: LD_ADDR_EXP 167
112722: PUSH
112723: LD_INT 0
112725: ST_TO_ADDR
// sWound := false ;
112726: LD_ADDR_EXP 175
112730: PUSH
112731: LD_INT 0
112733: ST_TO_ADDR
// sBetray := false ;
112734: LD_ADDR_EXP 179
112738: PUSH
112739: LD_INT 0
112741: ST_TO_ADDR
// sContamin := false ;
112742: LD_ADDR_EXP 180
112746: PUSH
112747: LD_INT 0
112749: ST_TO_ADDR
// sOil := false ;
112750: LD_ADDR_EXP 182
112754: PUSH
112755: LD_INT 0
112757: ST_TO_ADDR
// sStu := false ;
112758: LD_ADDR_EXP 186
112762: PUSH
112763: LD_INT 0
112765: ST_TO_ADDR
// sBazooka := false ;
112766: LD_ADDR_EXP 189
112770: PUSH
112771: LD_INT 0
112773: ST_TO_ADDR
// sMortar := false ;
112774: LD_ADDR_EXP 190
112778: PUSH
112779: LD_INT 0
112781: ST_TO_ADDR
// sRanger := false ;
112782: LD_ADDR_EXP 200
112786: PUSH
112787: LD_INT 0
112789: ST_TO_ADDR
// sComputer := false ;
112790: LD_ADDR_EXP 201
112794: PUSH
112795: LD_INT 0
112797: ST_TO_ADDR
// s30 := false ;
112798: LD_ADDR_EXP 202
112802: PUSH
112803: LD_INT 0
112805: ST_TO_ADDR
// s60 := false ;
112806: LD_ADDR_EXP 203
112810: PUSH
112811: LD_INT 0
112813: ST_TO_ADDR
// end ;
112814: LD_VAR 0 1
112818: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
112819: LD_INT 0
112821: PPUSH
112822: PPUSH
112823: PPUSH
112824: PPUSH
112825: PPUSH
112826: PPUSH
112827: PPUSH
// result := [ ] ;
112828: LD_ADDR_VAR 0 2
112832: PUSH
112833: EMPTY
112834: ST_TO_ADDR
// if campaign_id = 1 then
112835: LD_OWVAR 69
112839: PUSH
112840: LD_INT 1
112842: EQUAL
112843: IFFALSE 116009
// begin case mission_number of 1 :
112845: LD_OWVAR 70
112849: PUSH
112850: LD_INT 1
112852: DOUBLE
112853: EQUAL
112854: IFTRUE 112858
112856: GO 112934
112858: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
112859: LD_ADDR_VAR 0 2
112863: PUSH
112864: LD_INT 2
112866: PUSH
112867: LD_INT 4
112869: PUSH
112870: LD_INT 11
112872: PUSH
112873: LD_INT 12
112875: PUSH
112876: LD_INT 15
112878: PUSH
112879: LD_INT 16
112881: PUSH
112882: LD_INT 22
112884: PUSH
112885: LD_INT 23
112887: PUSH
112888: LD_INT 26
112890: PUSH
112891: EMPTY
112892: LIST
112893: LIST
112894: LIST
112895: LIST
112896: LIST
112897: LIST
112898: LIST
112899: LIST
112900: LIST
112901: PUSH
112902: LD_INT 101
112904: PUSH
112905: LD_INT 102
112907: PUSH
112908: LD_INT 106
112910: PUSH
112911: LD_INT 116
112913: PUSH
112914: LD_INT 117
112916: PUSH
112917: LD_INT 118
112919: PUSH
112920: EMPTY
112921: LIST
112922: LIST
112923: LIST
112924: LIST
112925: LIST
112926: LIST
112927: PUSH
112928: EMPTY
112929: LIST
112930: LIST
112931: ST_TO_ADDR
112932: GO 116007
112934: LD_INT 2
112936: DOUBLE
112937: EQUAL
112938: IFTRUE 112942
112940: GO 113026
112942: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
112943: LD_ADDR_VAR 0 2
112947: PUSH
112948: LD_INT 2
112950: PUSH
112951: LD_INT 4
112953: PUSH
112954: LD_INT 11
112956: PUSH
112957: LD_INT 12
112959: PUSH
112960: LD_INT 15
112962: PUSH
112963: LD_INT 16
112965: PUSH
112966: LD_INT 22
112968: PUSH
112969: LD_INT 23
112971: PUSH
112972: LD_INT 26
112974: PUSH
112975: EMPTY
112976: LIST
112977: LIST
112978: LIST
112979: LIST
112980: LIST
112981: LIST
112982: LIST
112983: LIST
112984: LIST
112985: PUSH
112986: LD_INT 101
112988: PUSH
112989: LD_INT 102
112991: PUSH
112992: LD_INT 105
112994: PUSH
112995: LD_INT 106
112997: PUSH
112998: LD_INT 108
113000: PUSH
113001: LD_INT 116
113003: PUSH
113004: LD_INT 117
113006: PUSH
113007: LD_INT 118
113009: PUSH
113010: EMPTY
113011: LIST
113012: LIST
113013: LIST
113014: LIST
113015: LIST
113016: LIST
113017: LIST
113018: LIST
113019: PUSH
113020: EMPTY
113021: LIST
113022: LIST
113023: ST_TO_ADDR
113024: GO 116007
113026: LD_INT 3
113028: DOUBLE
113029: EQUAL
113030: IFTRUE 113034
113032: GO 113122
113034: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
113035: LD_ADDR_VAR 0 2
113039: PUSH
113040: LD_INT 2
113042: PUSH
113043: LD_INT 4
113045: PUSH
113046: LD_INT 5
113048: PUSH
113049: LD_INT 11
113051: PUSH
113052: LD_INT 12
113054: PUSH
113055: LD_INT 15
113057: PUSH
113058: LD_INT 16
113060: PUSH
113061: LD_INT 22
113063: PUSH
113064: LD_INT 26
113066: PUSH
113067: LD_INT 36
113069: PUSH
113070: EMPTY
113071: LIST
113072: LIST
113073: LIST
113074: LIST
113075: LIST
113076: LIST
113077: LIST
113078: LIST
113079: LIST
113080: LIST
113081: PUSH
113082: LD_INT 101
113084: PUSH
113085: LD_INT 102
113087: PUSH
113088: LD_INT 105
113090: PUSH
113091: LD_INT 106
113093: PUSH
113094: LD_INT 108
113096: PUSH
113097: LD_INT 116
113099: PUSH
113100: LD_INT 117
113102: PUSH
113103: LD_INT 118
113105: PUSH
113106: EMPTY
113107: LIST
113108: LIST
113109: LIST
113110: LIST
113111: LIST
113112: LIST
113113: LIST
113114: LIST
113115: PUSH
113116: EMPTY
113117: LIST
113118: LIST
113119: ST_TO_ADDR
113120: GO 116007
113122: LD_INT 4
113124: DOUBLE
113125: EQUAL
113126: IFTRUE 113130
113128: GO 113226
113130: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
113131: LD_ADDR_VAR 0 2
113135: PUSH
113136: LD_INT 2
113138: PUSH
113139: LD_INT 4
113141: PUSH
113142: LD_INT 5
113144: PUSH
113145: LD_INT 8
113147: PUSH
113148: LD_INT 11
113150: PUSH
113151: LD_INT 12
113153: PUSH
113154: LD_INT 15
113156: PUSH
113157: LD_INT 16
113159: PUSH
113160: LD_INT 22
113162: PUSH
113163: LD_INT 23
113165: PUSH
113166: LD_INT 26
113168: PUSH
113169: LD_INT 36
113171: PUSH
113172: EMPTY
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: LIST
113179: LIST
113180: LIST
113181: LIST
113182: LIST
113183: LIST
113184: LIST
113185: PUSH
113186: LD_INT 101
113188: PUSH
113189: LD_INT 102
113191: PUSH
113192: LD_INT 105
113194: PUSH
113195: LD_INT 106
113197: PUSH
113198: LD_INT 108
113200: PUSH
113201: LD_INT 116
113203: PUSH
113204: LD_INT 117
113206: PUSH
113207: LD_INT 118
113209: PUSH
113210: EMPTY
113211: LIST
113212: LIST
113213: LIST
113214: LIST
113215: LIST
113216: LIST
113217: LIST
113218: LIST
113219: PUSH
113220: EMPTY
113221: LIST
113222: LIST
113223: ST_TO_ADDR
113224: GO 116007
113226: LD_INT 5
113228: DOUBLE
113229: EQUAL
113230: IFTRUE 113234
113232: GO 113346
113234: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
113235: LD_ADDR_VAR 0 2
113239: PUSH
113240: LD_INT 2
113242: PUSH
113243: LD_INT 4
113245: PUSH
113246: LD_INT 5
113248: PUSH
113249: LD_INT 6
113251: PUSH
113252: LD_INT 8
113254: PUSH
113255: LD_INT 11
113257: PUSH
113258: LD_INT 12
113260: PUSH
113261: LD_INT 15
113263: PUSH
113264: LD_INT 16
113266: PUSH
113267: LD_INT 22
113269: PUSH
113270: LD_INT 23
113272: PUSH
113273: LD_INT 25
113275: PUSH
113276: LD_INT 26
113278: PUSH
113279: LD_INT 36
113281: PUSH
113282: EMPTY
113283: LIST
113284: LIST
113285: LIST
113286: LIST
113287: LIST
113288: LIST
113289: LIST
113290: LIST
113291: LIST
113292: LIST
113293: LIST
113294: LIST
113295: LIST
113296: LIST
113297: PUSH
113298: LD_INT 101
113300: PUSH
113301: LD_INT 102
113303: PUSH
113304: LD_INT 105
113306: PUSH
113307: LD_INT 106
113309: PUSH
113310: LD_INT 108
113312: PUSH
113313: LD_INT 109
113315: PUSH
113316: LD_INT 112
113318: PUSH
113319: LD_INT 116
113321: PUSH
113322: LD_INT 117
113324: PUSH
113325: LD_INT 118
113327: PUSH
113328: EMPTY
113329: LIST
113330: LIST
113331: LIST
113332: LIST
113333: LIST
113334: LIST
113335: LIST
113336: LIST
113337: LIST
113338: LIST
113339: PUSH
113340: EMPTY
113341: LIST
113342: LIST
113343: ST_TO_ADDR
113344: GO 116007
113346: LD_INT 6
113348: DOUBLE
113349: EQUAL
113350: IFTRUE 113354
113352: GO 113486
113354: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
113355: LD_ADDR_VAR 0 2
113359: PUSH
113360: LD_INT 2
113362: PUSH
113363: LD_INT 4
113365: PUSH
113366: LD_INT 5
113368: PUSH
113369: LD_INT 6
113371: PUSH
113372: LD_INT 8
113374: PUSH
113375: LD_INT 11
113377: PUSH
113378: LD_INT 12
113380: PUSH
113381: LD_INT 15
113383: PUSH
113384: LD_INT 16
113386: PUSH
113387: LD_INT 20
113389: PUSH
113390: LD_INT 21
113392: PUSH
113393: LD_INT 22
113395: PUSH
113396: LD_INT 23
113398: PUSH
113399: LD_INT 25
113401: PUSH
113402: LD_INT 26
113404: PUSH
113405: LD_INT 30
113407: PUSH
113408: LD_INT 31
113410: PUSH
113411: LD_INT 32
113413: PUSH
113414: LD_INT 36
113416: PUSH
113417: EMPTY
113418: LIST
113419: LIST
113420: LIST
113421: LIST
113422: LIST
113423: LIST
113424: LIST
113425: LIST
113426: LIST
113427: LIST
113428: LIST
113429: LIST
113430: LIST
113431: LIST
113432: LIST
113433: LIST
113434: LIST
113435: LIST
113436: LIST
113437: PUSH
113438: LD_INT 101
113440: PUSH
113441: LD_INT 102
113443: PUSH
113444: LD_INT 105
113446: PUSH
113447: LD_INT 106
113449: PUSH
113450: LD_INT 108
113452: PUSH
113453: LD_INT 109
113455: PUSH
113456: LD_INT 112
113458: PUSH
113459: LD_INT 116
113461: PUSH
113462: LD_INT 117
113464: PUSH
113465: LD_INT 118
113467: PUSH
113468: EMPTY
113469: LIST
113470: LIST
113471: LIST
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: PUSH
113480: EMPTY
113481: LIST
113482: LIST
113483: ST_TO_ADDR
113484: GO 116007
113486: LD_INT 7
113488: DOUBLE
113489: EQUAL
113490: IFTRUE 113494
113492: GO 113606
113494: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
113495: LD_ADDR_VAR 0 2
113499: PUSH
113500: LD_INT 2
113502: PUSH
113503: LD_INT 4
113505: PUSH
113506: LD_INT 5
113508: PUSH
113509: LD_INT 7
113511: PUSH
113512: LD_INT 11
113514: PUSH
113515: LD_INT 12
113517: PUSH
113518: LD_INT 15
113520: PUSH
113521: LD_INT 16
113523: PUSH
113524: LD_INT 20
113526: PUSH
113527: LD_INT 21
113529: PUSH
113530: LD_INT 22
113532: PUSH
113533: LD_INT 23
113535: PUSH
113536: LD_INT 25
113538: PUSH
113539: LD_INT 26
113541: PUSH
113542: EMPTY
113543: LIST
113544: LIST
113545: LIST
113546: LIST
113547: LIST
113548: LIST
113549: LIST
113550: LIST
113551: LIST
113552: LIST
113553: LIST
113554: LIST
113555: LIST
113556: LIST
113557: PUSH
113558: LD_INT 101
113560: PUSH
113561: LD_INT 102
113563: PUSH
113564: LD_INT 103
113566: PUSH
113567: LD_INT 105
113569: PUSH
113570: LD_INT 106
113572: PUSH
113573: LD_INT 108
113575: PUSH
113576: LD_INT 112
113578: PUSH
113579: LD_INT 116
113581: PUSH
113582: LD_INT 117
113584: PUSH
113585: LD_INT 118
113587: PUSH
113588: EMPTY
113589: LIST
113590: LIST
113591: LIST
113592: LIST
113593: LIST
113594: LIST
113595: LIST
113596: LIST
113597: LIST
113598: LIST
113599: PUSH
113600: EMPTY
113601: LIST
113602: LIST
113603: ST_TO_ADDR
113604: GO 116007
113606: LD_INT 8
113608: DOUBLE
113609: EQUAL
113610: IFTRUE 113614
113612: GO 113754
113614: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
113615: LD_ADDR_VAR 0 2
113619: PUSH
113620: LD_INT 2
113622: PUSH
113623: LD_INT 4
113625: PUSH
113626: LD_INT 5
113628: PUSH
113629: LD_INT 6
113631: PUSH
113632: LD_INT 7
113634: PUSH
113635: LD_INT 8
113637: PUSH
113638: LD_INT 11
113640: PUSH
113641: LD_INT 12
113643: PUSH
113644: LD_INT 15
113646: PUSH
113647: LD_INT 16
113649: PUSH
113650: LD_INT 20
113652: PUSH
113653: LD_INT 21
113655: PUSH
113656: LD_INT 22
113658: PUSH
113659: LD_INT 23
113661: PUSH
113662: LD_INT 25
113664: PUSH
113665: LD_INT 26
113667: PUSH
113668: LD_INT 30
113670: PUSH
113671: LD_INT 31
113673: PUSH
113674: LD_INT 32
113676: PUSH
113677: LD_INT 36
113679: PUSH
113680: EMPTY
113681: LIST
113682: LIST
113683: LIST
113684: LIST
113685: LIST
113686: LIST
113687: LIST
113688: LIST
113689: LIST
113690: LIST
113691: LIST
113692: LIST
113693: LIST
113694: LIST
113695: LIST
113696: LIST
113697: LIST
113698: LIST
113699: LIST
113700: LIST
113701: PUSH
113702: LD_INT 101
113704: PUSH
113705: LD_INT 102
113707: PUSH
113708: LD_INT 103
113710: PUSH
113711: LD_INT 105
113713: PUSH
113714: LD_INT 106
113716: PUSH
113717: LD_INT 108
113719: PUSH
113720: LD_INT 109
113722: PUSH
113723: LD_INT 112
113725: PUSH
113726: LD_INT 116
113728: PUSH
113729: LD_INT 117
113731: PUSH
113732: LD_INT 118
113734: PUSH
113735: EMPTY
113736: LIST
113737: LIST
113738: LIST
113739: LIST
113740: LIST
113741: LIST
113742: LIST
113743: LIST
113744: LIST
113745: LIST
113746: LIST
113747: PUSH
113748: EMPTY
113749: LIST
113750: LIST
113751: ST_TO_ADDR
113752: GO 116007
113754: LD_INT 9
113756: DOUBLE
113757: EQUAL
113758: IFTRUE 113762
113760: GO 113910
113762: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
113763: LD_ADDR_VAR 0 2
113767: PUSH
113768: LD_INT 2
113770: PUSH
113771: LD_INT 4
113773: PUSH
113774: LD_INT 5
113776: PUSH
113777: LD_INT 6
113779: PUSH
113780: LD_INT 7
113782: PUSH
113783: LD_INT 8
113785: PUSH
113786: LD_INT 11
113788: PUSH
113789: LD_INT 12
113791: PUSH
113792: LD_INT 15
113794: PUSH
113795: LD_INT 16
113797: PUSH
113798: LD_INT 20
113800: PUSH
113801: LD_INT 21
113803: PUSH
113804: LD_INT 22
113806: PUSH
113807: LD_INT 23
113809: PUSH
113810: LD_INT 25
113812: PUSH
113813: LD_INT 26
113815: PUSH
113816: LD_INT 28
113818: PUSH
113819: LD_INT 30
113821: PUSH
113822: LD_INT 31
113824: PUSH
113825: LD_INT 32
113827: PUSH
113828: LD_INT 36
113830: PUSH
113831: EMPTY
113832: LIST
113833: LIST
113834: LIST
113835: LIST
113836: LIST
113837: LIST
113838: LIST
113839: LIST
113840: LIST
113841: LIST
113842: LIST
113843: LIST
113844: LIST
113845: LIST
113846: LIST
113847: LIST
113848: LIST
113849: LIST
113850: LIST
113851: LIST
113852: LIST
113853: PUSH
113854: LD_INT 101
113856: PUSH
113857: LD_INT 102
113859: PUSH
113860: LD_INT 103
113862: PUSH
113863: LD_INT 105
113865: PUSH
113866: LD_INT 106
113868: PUSH
113869: LD_INT 108
113871: PUSH
113872: LD_INT 109
113874: PUSH
113875: LD_INT 112
113877: PUSH
113878: LD_INT 114
113880: PUSH
113881: LD_INT 116
113883: PUSH
113884: LD_INT 117
113886: PUSH
113887: LD_INT 118
113889: PUSH
113890: EMPTY
113891: LIST
113892: LIST
113893: LIST
113894: LIST
113895: LIST
113896: LIST
113897: LIST
113898: LIST
113899: LIST
113900: LIST
113901: LIST
113902: LIST
113903: PUSH
113904: EMPTY
113905: LIST
113906: LIST
113907: ST_TO_ADDR
113908: GO 116007
113910: LD_INT 10
113912: DOUBLE
113913: EQUAL
113914: IFTRUE 113918
113916: GO 114114
113918: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
113919: LD_ADDR_VAR 0 2
113923: PUSH
113924: LD_INT 2
113926: PUSH
113927: LD_INT 4
113929: PUSH
113930: LD_INT 5
113932: PUSH
113933: LD_INT 6
113935: PUSH
113936: LD_INT 7
113938: PUSH
113939: LD_INT 8
113941: PUSH
113942: LD_INT 9
113944: PUSH
113945: LD_INT 10
113947: PUSH
113948: LD_INT 11
113950: PUSH
113951: LD_INT 12
113953: PUSH
113954: LD_INT 13
113956: PUSH
113957: LD_INT 14
113959: PUSH
113960: LD_INT 15
113962: PUSH
113963: LD_INT 16
113965: PUSH
113966: LD_INT 17
113968: PUSH
113969: LD_INT 18
113971: PUSH
113972: LD_INT 19
113974: PUSH
113975: LD_INT 20
113977: PUSH
113978: LD_INT 21
113980: PUSH
113981: LD_INT 22
113983: PUSH
113984: LD_INT 23
113986: PUSH
113987: LD_INT 24
113989: PUSH
113990: LD_INT 25
113992: PUSH
113993: LD_INT 26
113995: PUSH
113996: LD_INT 28
113998: PUSH
113999: LD_INT 30
114001: PUSH
114002: LD_INT 31
114004: PUSH
114005: LD_INT 32
114007: PUSH
114008: LD_INT 36
114010: PUSH
114011: EMPTY
114012: LIST
114013: LIST
114014: LIST
114015: LIST
114016: LIST
114017: LIST
114018: LIST
114019: LIST
114020: LIST
114021: LIST
114022: LIST
114023: LIST
114024: LIST
114025: LIST
114026: LIST
114027: LIST
114028: LIST
114029: LIST
114030: LIST
114031: LIST
114032: LIST
114033: LIST
114034: LIST
114035: LIST
114036: LIST
114037: LIST
114038: LIST
114039: LIST
114040: LIST
114041: PUSH
114042: LD_INT 101
114044: PUSH
114045: LD_INT 102
114047: PUSH
114048: LD_INT 103
114050: PUSH
114051: LD_INT 104
114053: PUSH
114054: LD_INT 105
114056: PUSH
114057: LD_INT 106
114059: PUSH
114060: LD_INT 107
114062: PUSH
114063: LD_INT 108
114065: PUSH
114066: LD_INT 109
114068: PUSH
114069: LD_INT 110
114071: PUSH
114072: LD_INT 111
114074: PUSH
114075: LD_INT 112
114077: PUSH
114078: LD_INT 114
114080: PUSH
114081: LD_INT 116
114083: PUSH
114084: LD_INT 117
114086: PUSH
114087: LD_INT 118
114089: PUSH
114090: EMPTY
114091: LIST
114092: LIST
114093: LIST
114094: LIST
114095: LIST
114096: LIST
114097: LIST
114098: LIST
114099: LIST
114100: LIST
114101: LIST
114102: LIST
114103: LIST
114104: LIST
114105: LIST
114106: LIST
114107: PUSH
114108: EMPTY
114109: LIST
114110: LIST
114111: ST_TO_ADDR
114112: GO 116007
114114: LD_INT 11
114116: DOUBLE
114117: EQUAL
114118: IFTRUE 114122
114120: GO 114326
114122: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
114123: LD_ADDR_VAR 0 2
114127: PUSH
114128: LD_INT 2
114130: PUSH
114131: LD_INT 3
114133: PUSH
114134: LD_INT 4
114136: PUSH
114137: LD_INT 5
114139: PUSH
114140: LD_INT 6
114142: PUSH
114143: LD_INT 7
114145: PUSH
114146: LD_INT 8
114148: PUSH
114149: LD_INT 9
114151: PUSH
114152: LD_INT 10
114154: PUSH
114155: LD_INT 11
114157: PUSH
114158: LD_INT 12
114160: PUSH
114161: LD_INT 13
114163: PUSH
114164: LD_INT 14
114166: PUSH
114167: LD_INT 15
114169: PUSH
114170: LD_INT 16
114172: PUSH
114173: LD_INT 17
114175: PUSH
114176: LD_INT 18
114178: PUSH
114179: LD_INT 19
114181: PUSH
114182: LD_INT 20
114184: PUSH
114185: LD_INT 21
114187: PUSH
114188: LD_INT 22
114190: PUSH
114191: LD_INT 23
114193: PUSH
114194: LD_INT 24
114196: PUSH
114197: LD_INT 25
114199: PUSH
114200: LD_INT 26
114202: PUSH
114203: LD_INT 28
114205: PUSH
114206: LD_INT 30
114208: PUSH
114209: LD_INT 31
114211: PUSH
114212: LD_INT 32
114214: PUSH
114215: LD_INT 34
114217: PUSH
114218: LD_INT 36
114220: PUSH
114221: EMPTY
114222: LIST
114223: LIST
114224: LIST
114225: LIST
114226: LIST
114227: LIST
114228: LIST
114229: LIST
114230: LIST
114231: LIST
114232: LIST
114233: LIST
114234: LIST
114235: LIST
114236: LIST
114237: LIST
114238: LIST
114239: LIST
114240: LIST
114241: LIST
114242: LIST
114243: LIST
114244: LIST
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: LIST
114250: LIST
114251: LIST
114252: LIST
114253: PUSH
114254: LD_INT 101
114256: PUSH
114257: LD_INT 102
114259: PUSH
114260: LD_INT 103
114262: PUSH
114263: LD_INT 104
114265: PUSH
114266: LD_INT 105
114268: PUSH
114269: LD_INT 106
114271: PUSH
114272: LD_INT 107
114274: PUSH
114275: LD_INT 108
114277: PUSH
114278: LD_INT 109
114280: PUSH
114281: LD_INT 110
114283: PUSH
114284: LD_INT 111
114286: PUSH
114287: LD_INT 112
114289: PUSH
114290: LD_INT 114
114292: PUSH
114293: LD_INT 116
114295: PUSH
114296: LD_INT 117
114298: PUSH
114299: LD_INT 118
114301: PUSH
114302: EMPTY
114303: LIST
114304: LIST
114305: LIST
114306: LIST
114307: LIST
114308: LIST
114309: LIST
114310: LIST
114311: LIST
114312: LIST
114313: LIST
114314: LIST
114315: LIST
114316: LIST
114317: LIST
114318: LIST
114319: PUSH
114320: EMPTY
114321: LIST
114322: LIST
114323: ST_TO_ADDR
114324: GO 116007
114326: LD_INT 12
114328: DOUBLE
114329: EQUAL
114330: IFTRUE 114334
114332: GO 114554
114334: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
114335: LD_ADDR_VAR 0 2
114339: PUSH
114340: LD_INT 1
114342: PUSH
114343: LD_INT 2
114345: PUSH
114346: LD_INT 3
114348: PUSH
114349: LD_INT 4
114351: PUSH
114352: LD_INT 5
114354: PUSH
114355: LD_INT 6
114357: PUSH
114358: LD_INT 7
114360: PUSH
114361: LD_INT 8
114363: PUSH
114364: LD_INT 9
114366: PUSH
114367: LD_INT 10
114369: PUSH
114370: LD_INT 11
114372: PUSH
114373: LD_INT 12
114375: PUSH
114376: LD_INT 13
114378: PUSH
114379: LD_INT 14
114381: PUSH
114382: LD_INT 15
114384: PUSH
114385: LD_INT 16
114387: PUSH
114388: LD_INT 17
114390: PUSH
114391: LD_INT 18
114393: PUSH
114394: LD_INT 19
114396: PUSH
114397: LD_INT 20
114399: PUSH
114400: LD_INT 21
114402: PUSH
114403: LD_INT 22
114405: PUSH
114406: LD_INT 23
114408: PUSH
114409: LD_INT 24
114411: PUSH
114412: LD_INT 25
114414: PUSH
114415: LD_INT 26
114417: PUSH
114418: LD_INT 27
114420: PUSH
114421: LD_INT 28
114423: PUSH
114424: LD_INT 30
114426: PUSH
114427: LD_INT 31
114429: PUSH
114430: LD_INT 32
114432: PUSH
114433: LD_INT 33
114435: PUSH
114436: LD_INT 34
114438: PUSH
114439: LD_INT 36
114441: PUSH
114442: EMPTY
114443: LIST
114444: LIST
114445: LIST
114446: LIST
114447: LIST
114448: LIST
114449: LIST
114450: LIST
114451: LIST
114452: LIST
114453: LIST
114454: LIST
114455: LIST
114456: LIST
114457: LIST
114458: LIST
114459: LIST
114460: LIST
114461: LIST
114462: LIST
114463: LIST
114464: LIST
114465: LIST
114466: LIST
114467: LIST
114468: LIST
114469: LIST
114470: LIST
114471: LIST
114472: LIST
114473: LIST
114474: LIST
114475: LIST
114476: LIST
114477: PUSH
114478: LD_INT 101
114480: PUSH
114481: LD_INT 102
114483: PUSH
114484: LD_INT 103
114486: PUSH
114487: LD_INT 104
114489: PUSH
114490: LD_INT 105
114492: PUSH
114493: LD_INT 106
114495: PUSH
114496: LD_INT 107
114498: PUSH
114499: LD_INT 108
114501: PUSH
114502: LD_INT 109
114504: PUSH
114505: LD_INT 110
114507: PUSH
114508: LD_INT 111
114510: PUSH
114511: LD_INT 112
114513: PUSH
114514: LD_INT 113
114516: PUSH
114517: LD_INT 114
114519: PUSH
114520: LD_INT 116
114522: PUSH
114523: LD_INT 117
114525: PUSH
114526: LD_INT 118
114528: PUSH
114529: EMPTY
114530: LIST
114531: LIST
114532: LIST
114533: LIST
114534: LIST
114535: LIST
114536: LIST
114537: LIST
114538: LIST
114539: LIST
114540: LIST
114541: LIST
114542: LIST
114543: LIST
114544: LIST
114545: LIST
114546: LIST
114547: PUSH
114548: EMPTY
114549: LIST
114550: LIST
114551: ST_TO_ADDR
114552: GO 116007
114554: LD_INT 13
114556: DOUBLE
114557: EQUAL
114558: IFTRUE 114562
114560: GO 114770
114562: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
114563: LD_ADDR_VAR 0 2
114567: PUSH
114568: LD_INT 1
114570: PUSH
114571: LD_INT 2
114573: PUSH
114574: LD_INT 3
114576: PUSH
114577: LD_INT 4
114579: PUSH
114580: LD_INT 5
114582: PUSH
114583: LD_INT 8
114585: PUSH
114586: LD_INT 9
114588: PUSH
114589: LD_INT 10
114591: PUSH
114592: LD_INT 11
114594: PUSH
114595: LD_INT 12
114597: PUSH
114598: LD_INT 14
114600: PUSH
114601: LD_INT 15
114603: PUSH
114604: LD_INT 16
114606: PUSH
114607: LD_INT 17
114609: PUSH
114610: LD_INT 18
114612: PUSH
114613: LD_INT 19
114615: PUSH
114616: LD_INT 20
114618: PUSH
114619: LD_INT 21
114621: PUSH
114622: LD_INT 22
114624: PUSH
114625: LD_INT 23
114627: PUSH
114628: LD_INT 24
114630: PUSH
114631: LD_INT 25
114633: PUSH
114634: LD_INT 26
114636: PUSH
114637: LD_INT 27
114639: PUSH
114640: LD_INT 28
114642: PUSH
114643: LD_INT 30
114645: PUSH
114646: LD_INT 31
114648: PUSH
114649: LD_INT 32
114651: PUSH
114652: LD_INT 33
114654: PUSH
114655: LD_INT 34
114657: PUSH
114658: LD_INT 36
114660: PUSH
114661: EMPTY
114662: LIST
114663: LIST
114664: LIST
114665: LIST
114666: LIST
114667: LIST
114668: LIST
114669: LIST
114670: LIST
114671: LIST
114672: LIST
114673: LIST
114674: LIST
114675: LIST
114676: LIST
114677: LIST
114678: LIST
114679: LIST
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: PUSH
114694: LD_INT 101
114696: PUSH
114697: LD_INT 102
114699: PUSH
114700: LD_INT 103
114702: PUSH
114703: LD_INT 104
114705: PUSH
114706: LD_INT 105
114708: PUSH
114709: LD_INT 106
114711: PUSH
114712: LD_INT 107
114714: PUSH
114715: LD_INT 108
114717: PUSH
114718: LD_INT 109
114720: PUSH
114721: LD_INT 110
114723: PUSH
114724: LD_INT 111
114726: PUSH
114727: LD_INT 112
114729: PUSH
114730: LD_INT 113
114732: PUSH
114733: LD_INT 114
114735: PUSH
114736: LD_INT 116
114738: PUSH
114739: LD_INT 117
114741: PUSH
114742: LD_INT 118
114744: PUSH
114745: EMPTY
114746: LIST
114747: LIST
114748: LIST
114749: LIST
114750: LIST
114751: LIST
114752: LIST
114753: LIST
114754: LIST
114755: LIST
114756: LIST
114757: LIST
114758: LIST
114759: LIST
114760: LIST
114761: LIST
114762: LIST
114763: PUSH
114764: EMPTY
114765: LIST
114766: LIST
114767: ST_TO_ADDR
114768: GO 116007
114770: LD_INT 14
114772: DOUBLE
114773: EQUAL
114774: IFTRUE 114778
114776: GO 115002
114778: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
114779: LD_ADDR_VAR 0 2
114783: PUSH
114784: LD_INT 1
114786: PUSH
114787: LD_INT 2
114789: PUSH
114790: LD_INT 3
114792: PUSH
114793: LD_INT 4
114795: PUSH
114796: LD_INT 5
114798: PUSH
114799: LD_INT 6
114801: PUSH
114802: LD_INT 7
114804: PUSH
114805: LD_INT 8
114807: PUSH
114808: LD_INT 9
114810: PUSH
114811: LD_INT 10
114813: PUSH
114814: LD_INT 11
114816: PUSH
114817: LD_INT 12
114819: PUSH
114820: LD_INT 13
114822: PUSH
114823: LD_INT 14
114825: PUSH
114826: LD_INT 15
114828: PUSH
114829: LD_INT 16
114831: PUSH
114832: LD_INT 17
114834: PUSH
114835: LD_INT 18
114837: PUSH
114838: LD_INT 19
114840: PUSH
114841: LD_INT 20
114843: PUSH
114844: LD_INT 21
114846: PUSH
114847: LD_INT 22
114849: PUSH
114850: LD_INT 23
114852: PUSH
114853: LD_INT 24
114855: PUSH
114856: LD_INT 25
114858: PUSH
114859: LD_INT 26
114861: PUSH
114862: LD_INT 27
114864: PUSH
114865: LD_INT 28
114867: PUSH
114868: LD_INT 29
114870: PUSH
114871: LD_INT 30
114873: PUSH
114874: LD_INT 31
114876: PUSH
114877: LD_INT 32
114879: PUSH
114880: LD_INT 33
114882: PUSH
114883: LD_INT 34
114885: PUSH
114886: LD_INT 36
114888: PUSH
114889: EMPTY
114890: LIST
114891: LIST
114892: LIST
114893: LIST
114894: LIST
114895: LIST
114896: LIST
114897: LIST
114898: LIST
114899: LIST
114900: LIST
114901: LIST
114902: LIST
114903: LIST
114904: LIST
114905: LIST
114906: LIST
114907: LIST
114908: LIST
114909: LIST
114910: LIST
114911: LIST
114912: LIST
114913: LIST
114914: LIST
114915: LIST
114916: LIST
114917: LIST
114918: LIST
114919: LIST
114920: LIST
114921: LIST
114922: LIST
114923: LIST
114924: LIST
114925: PUSH
114926: LD_INT 101
114928: PUSH
114929: LD_INT 102
114931: PUSH
114932: LD_INT 103
114934: PUSH
114935: LD_INT 104
114937: PUSH
114938: LD_INT 105
114940: PUSH
114941: LD_INT 106
114943: PUSH
114944: LD_INT 107
114946: PUSH
114947: LD_INT 108
114949: PUSH
114950: LD_INT 109
114952: PUSH
114953: LD_INT 110
114955: PUSH
114956: LD_INT 111
114958: PUSH
114959: LD_INT 112
114961: PUSH
114962: LD_INT 113
114964: PUSH
114965: LD_INT 114
114967: PUSH
114968: LD_INT 116
114970: PUSH
114971: LD_INT 117
114973: PUSH
114974: LD_INT 118
114976: PUSH
114977: EMPTY
114978: LIST
114979: LIST
114980: LIST
114981: LIST
114982: LIST
114983: LIST
114984: LIST
114985: LIST
114986: LIST
114987: LIST
114988: LIST
114989: LIST
114990: LIST
114991: LIST
114992: LIST
114993: LIST
114994: LIST
114995: PUSH
114996: EMPTY
114997: LIST
114998: LIST
114999: ST_TO_ADDR
115000: GO 116007
115002: LD_INT 15
115004: DOUBLE
115005: EQUAL
115006: IFTRUE 115010
115008: GO 115234
115010: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
115011: LD_ADDR_VAR 0 2
115015: PUSH
115016: LD_INT 1
115018: PUSH
115019: LD_INT 2
115021: PUSH
115022: LD_INT 3
115024: PUSH
115025: LD_INT 4
115027: PUSH
115028: LD_INT 5
115030: PUSH
115031: LD_INT 6
115033: PUSH
115034: LD_INT 7
115036: PUSH
115037: LD_INT 8
115039: PUSH
115040: LD_INT 9
115042: PUSH
115043: LD_INT 10
115045: PUSH
115046: LD_INT 11
115048: PUSH
115049: LD_INT 12
115051: PUSH
115052: LD_INT 13
115054: PUSH
115055: LD_INT 14
115057: PUSH
115058: LD_INT 15
115060: PUSH
115061: LD_INT 16
115063: PUSH
115064: LD_INT 17
115066: PUSH
115067: LD_INT 18
115069: PUSH
115070: LD_INT 19
115072: PUSH
115073: LD_INT 20
115075: PUSH
115076: LD_INT 21
115078: PUSH
115079: LD_INT 22
115081: PUSH
115082: LD_INT 23
115084: PUSH
115085: LD_INT 24
115087: PUSH
115088: LD_INT 25
115090: PUSH
115091: LD_INT 26
115093: PUSH
115094: LD_INT 27
115096: PUSH
115097: LD_INT 28
115099: PUSH
115100: LD_INT 29
115102: PUSH
115103: LD_INT 30
115105: PUSH
115106: LD_INT 31
115108: PUSH
115109: LD_INT 32
115111: PUSH
115112: LD_INT 33
115114: PUSH
115115: LD_INT 34
115117: PUSH
115118: LD_INT 36
115120: PUSH
115121: EMPTY
115122: LIST
115123: LIST
115124: LIST
115125: LIST
115126: LIST
115127: LIST
115128: LIST
115129: LIST
115130: LIST
115131: LIST
115132: LIST
115133: LIST
115134: LIST
115135: LIST
115136: LIST
115137: LIST
115138: LIST
115139: LIST
115140: LIST
115141: LIST
115142: LIST
115143: LIST
115144: LIST
115145: LIST
115146: LIST
115147: LIST
115148: LIST
115149: LIST
115150: LIST
115151: LIST
115152: LIST
115153: LIST
115154: LIST
115155: LIST
115156: LIST
115157: PUSH
115158: LD_INT 101
115160: PUSH
115161: LD_INT 102
115163: PUSH
115164: LD_INT 103
115166: PUSH
115167: LD_INT 104
115169: PUSH
115170: LD_INT 105
115172: PUSH
115173: LD_INT 106
115175: PUSH
115176: LD_INT 107
115178: PUSH
115179: LD_INT 108
115181: PUSH
115182: LD_INT 109
115184: PUSH
115185: LD_INT 110
115187: PUSH
115188: LD_INT 111
115190: PUSH
115191: LD_INT 112
115193: PUSH
115194: LD_INT 113
115196: PUSH
115197: LD_INT 114
115199: PUSH
115200: LD_INT 116
115202: PUSH
115203: LD_INT 117
115205: PUSH
115206: LD_INT 118
115208: PUSH
115209: EMPTY
115210: LIST
115211: LIST
115212: LIST
115213: LIST
115214: LIST
115215: LIST
115216: LIST
115217: LIST
115218: LIST
115219: LIST
115220: LIST
115221: LIST
115222: LIST
115223: LIST
115224: LIST
115225: LIST
115226: LIST
115227: PUSH
115228: EMPTY
115229: LIST
115230: LIST
115231: ST_TO_ADDR
115232: GO 116007
115234: LD_INT 16
115236: DOUBLE
115237: EQUAL
115238: IFTRUE 115242
115240: GO 115378
115242: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
115243: LD_ADDR_VAR 0 2
115247: PUSH
115248: LD_INT 2
115250: PUSH
115251: LD_INT 4
115253: PUSH
115254: LD_INT 5
115256: PUSH
115257: LD_INT 7
115259: PUSH
115260: LD_INT 11
115262: PUSH
115263: LD_INT 12
115265: PUSH
115266: LD_INT 15
115268: PUSH
115269: LD_INT 16
115271: PUSH
115272: LD_INT 20
115274: PUSH
115275: LD_INT 21
115277: PUSH
115278: LD_INT 22
115280: PUSH
115281: LD_INT 23
115283: PUSH
115284: LD_INT 25
115286: PUSH
115287: LD_INT 26
115289: PUSH
115290: LD_INT 30
115292: PUSH
115293: LD_INT 31
115295: PUSH
115296: LD_INT 32
115298: PUSH
115299: LD_INT 33
115301: PUSH
115302: LD_INT 34
115304: PUSH
115305: EMPTY
115306: LIST
115307: LIST
115308: LIST
115309: LIST
115310: LIST
115311: LIST
115312: LIST
115313: LIST
115314: LIST
115315: LIST
115316: LIST
115317: LIST
115318: LIST
115319: LIST
115320: LIST
115321: LIST
115322: LIST
115323: LIST
115324: LIST
115325: PUSH
115326: LD_INT 101
115328: PUSH
115329: LD_INT 102
115331: PUSH
115332: LD_INT 103
115334: PUSH
115335: LD_INT 106
115337: PUSH
115338: LD_INT 108
115340: PUSH
115341: LD_INT 112
115343: PUSH
115344: LD_INT 113
115346: PUSH
115347: LD_INT 114
115349: PUSH
115350: LD_INT 116
115352: PUSH
115353: LD_INT 117
115355: PUSH
115356: LD_INT 118
115358: PUSH
115359: EMPTY
115360: LIST
115361: LIST
115362: LIST
115363: LIST
115364: LIST
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: PUSH
115372: EMPTY
115373: LIST
115374: LIST
115375: ST_TO_ADDR
115376: GO 116007
115378: LD_INT 17
115380: DOUBLE
115381: EQUAL
115382: IFTRUE 115386
115384: GO 115610
115386: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
115387: LD_ADDR_VAR 0 2
115391: PUSH
115392: LD_INT 1
115394: PUSH
115395: LD_INT 2
115397: PUSH
115398: LD_INT 3
115400: PUSH
115401: LD_INT 4
115403: PUSH
115404: LD_INT 5
115406: PUSH
115407: LD_INT 6
115409: PUSH
115410: LD_INT 7
115412: PUSH
115413: LD_INT 8
115415: PUSH
115416: LD_INT 9
115418: PUSH
115419: LD_INT 10
115421: PUSH
115422: LD_INT 11
115424: PUSH
115425: LD_INT 12
115427: PUSH
115428: LD_INT 13
115430: PUSH
115431: LD_INT 14
115433: PUSH
115434: LD_INT 15
115436: PUSH
115437: LD_INT 16
115439: PUSH
115440: LD_INT 17
115442: PUSH
115443: LD_INT 18
115445: PUSH
115446: LD_INT 19
115448: PUSH
115449: LD_INT 20
115451: PUSH
115452: LD_INT 21
115454: PUSH
115455: LD_INT 22
115457: PUSH
115458: LD_INT 23
115460: PUSH
115461: LD_INT 24
115463: PUSH
115464: LD_INT 25
115466: PUSH
115467: LD_INT 26
115469: PUSH
115470: LD_INT 27
115472: PUSH
115473: LD_INT 28
115475: PUSH
115476: LD_INT 29
115478: PUSH
115479: LD_INT 30
115481: PUSH
115482: LD_INT 31
115484: PUSH
115485: LD_INT 32
115487: PUSH
115488: LD_INT 33
115490: PUSH
115491: LD_INT 34
115493: PUSH
115494: LD_INT 36
115496: PUSH
115497: EMPTY
115498: LIST
115499: LIST
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: LIST
115507: LIST
115508: LIST
115509: LIST
115510: LIST
115511: LIST
115512: LIST
115513: LIST
115514: LIST
115515: LIST
115516: LIST
115517: LIST
115518: LIST
115519: LIST
115520: LIST
115521: LIST
115522: LIST
115523: LIST
115524: LIST
115525: LIST
115526: LIST
115527: LIST
115528: LIST
115529: LIST
115530: LIST
115531: LIST
115532: LIST
115533: PUSH
115534: LD_INT 101
115536: PUSH
115537: LD_INT 102
115539: PUSH
115540: LD_INT 103
115542: PUSH
115543: LD_INT 104
115545: PUSH
115546: LD_INT 105
115548: PUSH
115549: LD_INT 106
115551: PUSH
115552: LD_INT 107
115554: PUSH
115555: LD_INT 108
115557: PUSH
115558: LD_INT 109
115560: PUSH
115561: LD_INT 110
115563: PUSH
115564: LD_INT 111
115566: PUSH
115567: LD_INT 112
115569: PUSH
115570: LD_INT 113
115572: PUSH
115573: LD_INT 114
115575: PUSH
115576: LD_INT 116
115578: PUSH
115579: LD_INT 117
115581: PUSH
115582: LD_INT 118
115584: PUSH
115585: EMPTY
115586: LIST
115587: LIST
115588: LIST
115589: LIST
115590: LIST
115591: LIST
115592: LIST
115593: LIST
115594: LIST
115595: LIST
115596: LIST
115597: LIST
115598: LIST
115599: LIST
115600: LIST
115601: LIST
115602: LIST
115603: PUSH
115604: EMPTY
115605: LIST
115606: LIST
115607: ST_TO_ADDR
115608: GO 116007
115610: LD_INT 18
115612: DOUBLE
115613: EQUAL
115614: IFTRUE 115618
115616: GO 115766
115618: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
115619: LD_ADDR_VAR 0 2
115623: PUSH
115624: LD_INT 2
115626: PUSH
115627: LD_INT 4
115629: PUSH
115630: LD_INT 5
115632: PUSH
115633: LD_INT 7
115635: PUSH
115636: LD_INT 11
115638: PUSH
115639: LD_INT 12
115641: PUSH
115642: LD_INT 15
115644: PUSH
115645: LD_INT 16
115647: PUSH
115648: LD_INT 20
115650: PUSH
115651: LD_INT 21
115653: PUSH
115654: LD_INT 22
115656: PUSH
115657: LD_INT 23
115659: PUSH
115660: LD_INT 25
115662: PUSH
115663: LD_INT 26
115665: PUSH
115666: LD_INT 30
115668: PUSH
115669: LD_INT 31
115671: PUSH
115672: LD_INT 32
115674: PUSH
115675: LD_INT 33
115677: PUSH
115678: LD_INT 34
115680: PUSH
115681: LD_INT 35
115683: PUSH
115684: LD_INT 36
115686: PUSH
115687: EMPTY
115688: LIST
115689: LIST
115690: LIST
115691: LIST
115692: LIST
115693: LIST
115694: LIST
115695: LIST
115696: LIST
115697: LIST
115698: LIST
115699: LIST
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: LIST
115705: LIST
115706: LIST
115707: LIST
115708: LIST
115709: PUSH
115710: LD_INT 101
115712: PUSH
115713: LD_INT 102
115715: PUSH
115716: LD_INT 103
115718: PUSH
115719: LD_INT 106
115721: PUSH
115722: LD_INT 108
115724: PUSH
115725: LD_INT 112
115727: PUSH
115728: LD_INT 113
115730: PUSH
115731: LD_INT 114
115733: PUSH
115734: LD_INT 115
115736: PUSH
115737: LD_INT 116
115739: PUSH
115740: LD_INT 117
115742: PUSH
115743: LD_INT 118
115745: PUSH
115746: EMPTY
115747: LIST
115748: LIST
115749: LIST
115750: LIST
115751: LIST
115752: LIST
115753: LIST
115754: LIST
115755: LIST
115756: LIST
115757: LIST
115758: LIST
115759: PUSH
115760: EMPTY
115761: LIST
115762: LIST
115763: ST_TO_ADDR
115764: GO 116007
115766: LD_INT 19
115768: DOUBLE
115769: EQUAL
115770: IFTRUE 115774
115772: GO 116006
115774: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
115775: LD_ADDR_VAR 0 2
115779: PUSH
115780: LD_INT 1
115782: PUSH
115783: LD_INT 2
115785: PUSH
115786: LD_INT 3
115788: PUSH
115789: LD_INT 4
115791: PUSH
115792: LD_INT 5
115794: PUSH
115795: LD_INT 6
115797: PUSH
115798: LD_INT 7
115800: PUSH
115801: LD_INT 8
115803: PUSH
115804: LD_INT 9
115806: PUSH
115807: LD_INT 10
115809: PUSH
115810: LD_INT 11
115812: PUSH
115813: LD_INT 12
115815: PUSH
115816: LD_INT 13
115818: PUSH
115819: LD_INT 14
115821: PUSH
115822: LD_INT 15
115824: PUSH
115825: LD_INT 16
115827: PUSH
115828: LD_INT 17
115830: PUSH
115831: LD_INT 18
115833: PUSH
115834: LD_INT 19
115836: PUSH
115837: LD_INT 20
115839: PUSH
115840: LD_INT 21
115842: PUSH
115843: LD_INT 22
115845: PUSH
115846: LD_INT 23
115848: PUSH
115849: LD_INT 24
115851: PUSH
115852: LD_INT 25
115854: PUSH
115855: LD_INT 26
115857: PUSH
115858: LD_INT 27
115860: PUSH
115861: LD_INT 28
115863: PUSH
115864: LD_INT 29
115866: PUSH
115867: LD_INT 30
115869: PUSH
115870: LD_INT 31
115872: PUSH
115873: LD_INT 32
115875: PUSH
115876: LD_INT 33
115878: PUSH
115879: LD_INT 34
115881: PUSH
115882: LD_INT 35
115884: PUSH
115885: LD_INT 36
115887: PUSH
115888: EMPTY
115889: LIST
115890: LIST
115891: LIST
115892: LIST
115893: LIST
115894: LIST
115895: LIST
115896: LIST
115897: LIST
115898: LIST
115899: LIST
115900: LIST
115901: LIST
115902: LIST
115903: LIST
115904: LIST
115905: LIST
115906: LIST
115907: LIST
115908: LIST
115909: LIST
115910: LIST
115911: LIST
115912: LIST
115913: LIST
115914: LIST
115915: LIST
115916: LIST
115917: LIST
115918: LIST
115919: LIST
115920: LIST
115921: LIST
115922: LIST
115923: LIST
115924: LIST
115925: PUSH
115926: LD_INT 101
115928: PUSH
115929: LD_INT 102
115931: PUSH
115932: LD_INT 103
115934: PUSH
115935: LD_INT 104
115937: PUSH
115938: LD_INT 105
115940: PUSH
115941: LD_INT 106
115943: PUSH
115944: LD_INT 107
115946: PUSH
115947: LD_INT 108
115949: PUSH
115950: LD_INT 109
115952: PUSH
115953: LD_INT 110
115955: PUSH
115956: LD_INT 111
115958: PUSH
115959: LD_INT 112
115961: PUSH
115962: LD_INT 113
115964: PUSH
115965: LD_INT 114
115967: PUSH
115968: LD_INT 115
115970: PUSH
115971: LD_INT 116
115973: PUSH
115974: LD_INT 117
115976: PUSH
115977: LD_INT 118
115979: PUSH
115980: EMPTY
115981: LIST
115982: LIST
115983: LIST
115984: LIST
115985: LIST
115986: LIST
115987: LIST
115988: LIST
115989: LIST
115990: LIST
115991: LIST
115992: LIST
115993: LIST
115994: LIST
115995: LIST
115996: LIST
115997: LIST
115998: LIST
115999: PUSH
116000: EMPTY
116001: LIST
116002: LIST
116003: ST_TO_ADDR
116004: GO 116007
116006: POP
// end else
116007: GO 116238
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
116009: LD_ADDR_VAR 0 2
116013: PUSH
116014: LD_INT 1
116016: PUSH
116017: LD_INT 2
116019: PUSH
116020: LD_INT 3
116022: PUSH
116023: LD_INT 4
116025: PUSH
116026: LD_INT 5
116028: PUSH
116029: LD_INT 6
116031: PUSH
116032: LD_INT 7
116034: PUSH
116035: LD_INT 8
116037: PUSH
116038: LD_INT 9
116040: PUSH
116041: LD_INT 10
116043: PUSH
116044: LD_INT 11
116046: PUSH
116047: LD_INT 12
116049: PUSH
116050: LD_INT 13
116052: PUSH
116053: LD_INT 14
116055: PUSH
116056: LD_INT 15
116058: PUSH
116059: LD_INT 16
116061: PUSH
116062: LD_INT 17
116064: PUSH
116065: LD_INT 18
116067: PUSH
116068: LD_INT 19
116070: PUSH
116071: LD_INT 20
116073: PUSH
116074: LD_INT 21
116076: PUSH
116077: LD_INT 22
116079: PUSH
116080: LD_INT 23
116082: PUSH
116083: LD_INT 24
116085: PUSH
116086: LD_INT 25
116088: PUSH
116089: LD_INT 26
116091: PUSH
116092: LD_INT 27
116094: PUSH
116095: LD_INT 28
116097: PUSH
116098: LD_INT 29
116100: PUSH
116101: LD_INT 30
116103: PUSH
116104: LD_INT 31
116106: PUSH
116107: LD_INT 32
116109: PUSH
116110: LD_INT 33
116112: PUSH
116113: LD_INT 34
116115: PUSH
116116: LD_INT 35
116118: PUSH
116119: LD_INT 36
116121: PUSH
116122: EMPTY
116123: LIST
116124: LIST
116125: LIST
116126: LIST
116127: LIST
116128: LIST
116129: LIST
116130: LIST
116131: LIST
116132: LIST
116133: LIST
116134: LIST
116135: LIST
116136: LIST
116137: LIST
116138: LIST
116139: LIST
116140: LIST
116141: LIST
116142: LIST
116143: LIST
116144: LIST
116145: LIST
116146: LIST
116147: LIST
116148: LIST
116149: LIST
116150: LIST
116151: LIST
116152: LIST
116153: LIST
116154: LIST
116155: LIST
116156: LIST
116157: LIST
116158: LIST
116159: PUSH
116160: LD_INT 101
116162: PUSH
116163: LD_INT 102
116165: PUSH
116166: LD_INT 103
116168: PUSH
116169: LD_INT 104
116171: PUSH
116172: LD_INT 105
116174: PUSH
116175: LD_INT 106
116177: PUSH
116178: LD_INT 107
116180: PUSH
116181: LD_INT 108
116183: PUSH
116184: LD_INT 109
116186: PUSH
116187: LD_INT 110
116189: PUSH
116190: LD_INT 111
116192: PUSH
116193: LD_INT 112
116195: PUSH
116196: LD_INT 113
116198: PUSH
116199: LD_INT 114
116201: PUSH
116202: LD_INT 115
116204: PUSH
116205: LD_INT 116
116207: PUSH
116208: LD_INT 117
116210: PUSH
116211: LD_INT 118
116213: PUSH
116214: EMPTY
116215: LIST
116216: LIST
116217: LIST
116218: LIST
116219: LIST
116220: LIST
116221: LIST
116222: LIST
116223: LIST
116224: LIST
116225: LIST
116226: LIST
116227: LIST
116228: LIST
116229: LIST
116230: LIST
116231: LIST
116232: LIST
116233: PUSH
116234: EMPTY
116235: LIST
116236: LIST
116237: ST_TO_ADDR
// if result then
116238: LD_VAR 0 2
116242: IFFALSE 117028
// begin normal :=  ;
116244: LD_ADDR_VAR 0 5
116248: PUSH
116249: LD_STRING 
116251: ST_TO_ADDR
// hardcore :=  ;
116252: LD_ADDR_VAR 0 6
116256: PUSH
116257: LD_STRING 
116259: ST_TO_ADDR
// active :=  ;
116260: LD_ADDR_VAR 0 7
116264: PUSH
116265: LD_STRING 
116267: ST_TO_ADDR
// for i = 1 to normalCounter do
116268: LD_ADDR_VAR 0 8
116272: PUSH
116273: DOUBLE
116274: LD_INT 1
116276: DEC
116277: ST_TO_ADDR
116278: LD_EXP 148
116282: PUSH
116283: FOR_TO
116284: IFFALSE 116385
// begin tmp := 0 ;
116286: LD_ADDR_VAR 0 3
116290: PUSH
116291: LD_STRING 0
116293: ST_TO_ADDR
// if result [ 1 ] then
116294: LD_VAR 0 2
116298: PUSH
116299: LD_INT 1
116301: ARRAY
116302: IFFALSE 116367
// if result [ 1 ] [ 1 ] = i then
116304: LD_VAR 0 2
116308: PUSH
116309: LD_INT 1
116311: ARRAY
116312: PUSH
116313: LD_INT 1
116315: ARRAY
116316: PUSH
116317: LD_VAR 0 8
116321: EQUAL
116322: IFFALSE 116367
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
116324: LD_ADDR_VAR 0 2
116328: PUSH
116329: LD_VAR 0 2
116333: PPUSH
116334: LD_INT 1
116336: PPUSH
116337: LD_VAR 0 2
116341: PUSH
116342: LD_INT 1
116344: ARRAY
116345: PPUSH
116346: LD_INT 1
116348: PPUSH
116349: CALL_OW 3
116353: PPUSH
116354: CALL_OW 1
116358: ST_TO_ADDR
// tmp := 1 ;
116359: LD_ADDR_VAR 0 3
116363: PUSH
116364: LD_STRING 1
116366: ST_TO_ADDR
// end ; normal := normal & tmp ;
116367: LD_ADDR_VAR 0 5
116371: PUSH
116372: LD_VAR 0 5
116376: PUSH
116377: LD_VAR 0 3
116381: STR
116382: ST_TO_ADDR
// end ;
116383: GO 116283
116385: POP
116386: POP
// for i = 1 to hardcoreCounter do
116387: LD_ADDR_VAR 0 8
116391: PUSH
116392: DOUBLE
116393: LD_INT 1
116395: DEC
116396: ST_TO_ADDR
116397: LD_EXP 149
116401: PUSH
116402: FOR_TO
116403: IFFALSE 116508
// begin tmp := 0 ;
116405: LD_ADDR_VAR 0 3
116409: PUSH
116410: LD_STRING 0
116412: ST_TO_ADDR
// if result [ 2 ] then
116413: LD_VAR 0 2
116417: PUSH
116418: LD_INT 2
116420: ARRAY
116421: IFFALSE 116490
// if result [ 2 ] [ 1 ] = 100 + i then
116423: LD_VAR 0 2
116427: PUSH
116428: LD_INT 2
116430: ARRAY
116431: PUSH
116432: LD_INT 1
116434: ARRAY
116435: PUSH
116436: LD_INT 100
116438: PUSH
116439: LD_VAR 0 8
116443: PLUS
116444: EQUAL
116445: IFFALSE 116490
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
116447: LD_ADDR_VAR 0 2
116451: PUSH
116452: LD_VAR 0 2
116456: PPUSH
116457: LD_INT 2
116459: PPUSH
116460: LD_VAR 0 2
116464: PUSH
116465: LD_INT 2
116467: ARRAY
116468: PPUSH
116469: LD_INT 1
116471: PPUSH
116472: CALL_OW 3
116476: PPUSH
116477: CALL_OW 1
116481: ST_TO_ADDR
// tmp := 1 ;
116482: LD_ADDR_VAR 0 3
116486: PUSH
116487: LD_STRING 1
116489: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
116490: LD_ADDR_VAR 0 6
116494: PUSH
116495: LD_VAR 0 6
116499: PUSH
116500: LD_VAR 0 3
116504: STR
116505: ST_TO_ADDR
// end ;
116506: GO 116402
116508: POP
116509: POP
// if isGameLoad then
116510: LD_VAR 0 1
116514: IFFALSE 116989
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
116516: LD_ADDR_VAR 0 4
116520: PUSH
116521: LD_EXP 152
116525: PUSH
116526: LD_EXP 151
116530: PUSH
116531: LD_EXP 153
116535: PUSH
116536: LD_EXP 150
116540: PUSH
116541: LD_EXP 154
116545: PUSH
116546: LD_EXP 155
116550: PUSH
116551: LD_EXP 156
116555: PUSH
116556: LD_EXP 157
116560: PUSH
116561: LD_EXP 158
116565: PUSH
116566: LD_EXP 159
116570: PUSH
116571: LD_EXP 160
116575: PUSH
116576: LD_EXP 161
116580: PUSH
116581: LD_EXP 162
116585: PUSH
116586: LD_EXP 163
116590: PUSH
116591: LD_EXP 171
116595: PUSH
116596: LD_EXP 172
116600: PUSH
116601: LD_EXP 173
116605: PUSH
116606: LD_EXP 174
116610: PUSH
116611: LD_EXP 176
116615: PUSH
116616: LD_EXP 177
116620: PUSH
116621: LD_EXP 178
116625: PUSH
116626: LD_EXP 181
116630: PUSH
116631: LD_EXP 183
116635: PUSH
116636: LD_EXP 184
116640: PUSH
116641: LD_EXP 185
116645: PUSH
116646: LD_EXP 187
116650: PUSH
116651: LD_EXP 188
116655: PUSH
116656: LD_EXP 191
116660: PUSH
116661: LD_EXP 192
116665: PUSH
116666: LD_EXP 193
116670: PUSH
116671: LD_EXP 194
116675: PUSH
116676: LD_EXP 195
116680: PUSH
116681: LD_EXP 196
116685: PUSH
116686: LD_EXP 197
116690: PUSH
116691: LD_EXP 198
116695: PUSH
116696: LD_EXP 199
116700: PUSH
116701: LD_EXP 164
116705: PUSH
116706: LD_EXP 165
116710: PUSH
116711: LD_EXP 168
116715: PUSH
116716: LD_EXP 169
116720: PUSH
116721: LD_EXP 170
116725: PUSH
116726: LD_EXP 166
116730: PUSH
116731: LD_EXP 167
116735: PUSH
116736: LD_EXP 175
116740: PUSH
116741: LD_EXP 179
116745: PUSH
116746: LD_EXP 180
116750: PUSH
116751: LD_EXP 182
116755: PUSH
116756: LD_EXP 186
116760: PUSH
116761: LD_EXP 189
116765: PUSH
116766: LD_EXP 190
116770: PUSH
116771: LD_EXP 200
116775: PUSH
116776: LD_EXP 201
116780: PUSH
116781: LD_EXP 202
116785: PUSH
116786: LD_EXP 203
116790: PUSH
116791: EMPTY
116792: LIST
116793: LIST
116794: LIST
116795: LIST
116796: LIST
116797: LIST
116798: LIST
116799: LIST
116800: LIST
116801: LIST
116802: LIST
116803: LIST
116804: LIST
116805: LIST
116806: LIST
116807: LIST
116808: LIST
116809: LIST
116810: LIST
116811: LIST
116812: LIST
116813: LIST
116814: LIST
116815: LIST
116816: LIST
116817: LIST
116818: LIST
116819: LIST
116820: LIST
116821: LIST
116822: LIST
116823: LIST
116824: LIST
116825: LIST
116826: LIST
116827: LIST
116828: LIST
116829: LIST
116830: LIST
116831: LIST
116832: LIST
116833: LIST
116834: LIST
116835: LIST
116836: LIST
116837: LIST
116838: LIST
116839: LIST
116840: LIST
116841: LIST
116842: LIST
116843: LIST
116844: LIST
116845: LIST
116846: ST_TO_ADDR
// tmp :=  ;
116847: LD_ADDR_VAR 0 3
116851: PUSH
116852: LD_STRING 
116854: ST_TO_ADDR
// for i = 1 to normalCounter do
116855: LD_ADDR_VAR 0 8
116859: PUSH
116860: DOUBLE
116861: LD_INT 1
116863: DEC
116864: ST_TO_ADDR
116865: LD_EXP 148
116869: PUSH
116870: FOR_TO
116871: IFFALSE 116907
// begin if flags [ i ] then
116873: LD_VAR 0 4
116877: PUSH
116878: LD_VAR 0 8
116882: ARRAY
116883: IFFALSE 116905
// tmp := tmp & i & ; ;
116885: LD_ADDR_VAR 0 3
116889: PUSH
116890: LD_VAR 0 3
116894: PUSH
116895: LD_VAR 0 8
116899: STR
116900: PUSH
116901: LD_STRING ;
116903: STR
116904: ST_TO_ADDR
// end ;
116905: GO 116870
116907: POP
116908: POP
// for i = 1 to hardcoreCounter do
116909: LD_ADDR_VAR 0 8
116913: PUSH
116914: DOUBLE
116915: LD_INT 1
116917: DEC
116918: ST_TO_ADDR
116919: LD_EXP 149
116923: PUSH
116924: FOR_TO
116925: IFFALSE 116971
// begin if flags [ normalCounter + i ] then
116927: LD_VAR 0 4
116931: PUSH
116932: LD_EXP 148
116936: PUSH
116937: LD_VAR 0 8
116941: PLUS
116942: ARRAY
116943: IFFALSE 116969
// tmp := tmp & ( 100 + i ) & ; ;
116945: LD_ADDR_VAR 0 3
116949: PUSH
116950: LD_VAR 0 3
116954: PUSH
116955: LD_INT 100
116957: PUSH
116958: LD_VAR 0 8
116962: PLUS
116963: STR
116964: PUSH
116965: LD_STRING ;
116967: STR
116968: ST_TO_ADDR
// end ;
116969: GO 116924
116971: POP
116972: POP
// if tmp then
116973: LD_VAR 0 3
116977: IFFALSE 116989
// active := tmp ;
116979: LD_ADDR_VAR 0 7
116983: PUSH
116984: LD_VAR 0 3
116988: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
116989: LD_STRING getStreamItemsFromMission("
116991: PUSH
116992: LD_VAR 0 5
116996: STR
116997: PUSH
116998: LD_STRING ","
117000: STR
117001: PUSH
117002: LD_VAR 0 6
117006: STR
117007: PUSH
117008: LD_STRING ","
117010: STR
117011: PUSH
117012: LD_VAR 0 7
117016: STR
117017: PUSH
117018: LD_STRING ")
117020: STR
117021: PPUSH
117022: CALL_OW 559
// end else
117026: GO 117035
// ToLua ( getStreamItemsFromMission("","","") ) ;
117028: LD_STRING getStreamItemsFromMission("","","")
117030: PPUSH
117031: CALL_OW 559
// end ;
117035: LD_VAR 0 2
117039: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
117040: LD_EXP 147
117044: PUSH
117045: LD_EXP 152
117049: AND
117050: IFFALSE 117174
117052: GO 117054
117054: DISABLE
117055: LD_INT 0
117057: PPUSH
117058: PPUSH
// begin enable ;
117059: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
117060: LD_ADDR_VAR 0 2
117064: PUSH
117065: LD_INT 22
117067: PUSH
117068: LD_OWVAR 2
117072: PUSH
117073: EMPTY
117074: LIST
117075: LIST
117076: PUSH
117077: LD_INT 2
117079: PUSH
117080: LD_INT 34
117082: PUSH
117083: LD_INT 7
117085: PUSH
117086: EMPTY
117087: LIST
117088: LIST
117089: PUSH
117090: LD_INT 34
117092: PUSH
117093: LD_INT 45
117095: PUSH
117096: EMPTY
117097: LIST
117098: LIST
117099: PUSH
117100: LD_INT 34
117102: PUSH
117103: LD_INT 28
117105: PUSH
117106: EMPTY
117107: LIST
117108: LIST
117109: PUSH
117110: LD_INT 34
117112: PUSH
117113: LD_INT 47
117115: PUSH
117116: EMPTY
117117: LIST
117118: LIST
117119: PUSH
117120: EMPTY
117121: LIST
117122: LIST
117123: LIST
117124: LIST
117125: LIST
117126: PUSH
117127: EMPTY
117128: LIST
117129: LIST
117130: PPUSH
117131: CALL_OW 69
117135: ST_TO_ADDR
// if not tmp then
117136: LD_VAR 0 2
117140: NOT
117141: IFFALSE 117145
// exit ;
117143: GO 117174
// for i in tmp do
117145: LD_ADDR_VAR 0 1
117149: PUSH
117150: LD_VAR 0 2
117154: PUSH
117155: FOR_IN
117156: IFFALSE 117172
// begin SetLives ( i , 0 ) ;
117158: LD_VAR 0 1
117162: PPUSH
117163: LD_INT 0
117165: PPUSH
117166: CALL_OW 234
// end ;
117170: GO 117155
117172: POP
117173: POP
// end ;
117174: PPOPN 2
117176: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
117177: LD_EXP 147
117181: PUSH
117182: LD_EXP 153
117186: AND
117187: IFFALSE 117271
117189: GO 117191
117191: DISABLE
117192: LD_INT 0
117194: PPUSH
117195: PPUSH
// begin enable ;
117196: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
117197: LD_ADDR_VAR 0 2
117201: PUSH
117202: LD_INT 22
117204: PUSH
117205: LD_OWVAR 2
117209: PUSH
117210: EMPTY
117211: LIST
117212: LIST
117213: PUSH
117214: LD_INT 32
117216: PUSH
117217: LD_INT 3
117219: PUSH
117220: EMPTY
117221: LIST
117222: LIST
117223: PUSH
117224: EMPTY
117225: LIST
117226: LIST
117227: PPUSH
117228: CALL_OW 69
117232: ST_TO_ADDR
// if not tmp then
117233: LD_VAR 0 2
117237: NOT
117238: IFFALSE 117242
// exit ;
117240: GO 117271
// for i in tmp do
117242: LD_ADDR_VAR 0 1
117246: PUSH
117247: LD_VAR 0 2
117251: PUSH
117252: FOR_IN
117253: IFFALSE 117269
// begin SetLives ( i , 0 ) ;
117255: LD_VAR 0 1
117259: PPUSH
117260: LD_INT 0
117262: PPUSH
117263: CALL_OW 234
// end ;
117267: GO 117252
117269: POP
117270: POP
// end ;
117271: PPOPN 2
117273: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
117274: LD_EXP 147
117278: PUSH
117279: LD_EXP 150
117283: AND
117284: IFFALSE 117377
117286: GO 117288
117288: DISABLE
117289: LD_INT 0
117291: PPUSH
// begin enable ;
117292: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
117293: LD_ADDR_VAR 0 1
117297: PUSH
117298: LD_INT 22
117300: PUSH
117301: LD_OWVAR 2
117305: PUSH
117306: EMPTY
117307: LIST
117308: LIST
117309: PUSH
117310: LD_INT 2
117312: PUSH
117313: LD_INT 25
117315: PUSH
117316: LD_INT 5
117318: PUSH
117319: EMPTY
117320: LIST
117321: LIST
117322: PUSH
117323: LD_INT 25
117325: PUSH
117326: LD_INT 9
117328: PUSH
117329: EMPTY
117330: LIST
117331: LIST
117332: PUSH
117333: LD_INT 25
117335: PUSH
117336: LD_INT 8
117338: PUSH
117339: EMPTY
117340: LIST
117341: LIST
117342: PUSH
117343: EMPTY
117344: LIST
117345: LIST
117346: LIST
117347: LIST
117348: PUSH
117349: EMPTY
117350: LIST
117351: LIST
117352: PPUSH
117353: CALL_OW 69
117357: PUSH
117358: FOR_IN
117359: IFFALSE 117375
// begin SetClass ( i , 1 ) ;
117361: LD_VAR 0 1
117365: PPUSH
117366: LD_INT 1
117368: PPUSH
117369: CALL_OW 336
// end ;
117373: GO 117358
117375: POP
117376: POP
// end ;
117377: PPOPN 1
117379: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
117380: LD_EXP 147
117384: PUSH
117385: LD_EXP 151
117389: AND
117390: PUSH
117391: LD_OWVAR 65
117395: PUSH
117396: LD_INT 7
117398: LESS
117399: AND
117400: IFFALSE 117414
117402: GO 117404
117404: DISABLE
// begin enable ;
117405: ENABLE
// game_speed := 7 ;
117406: LD_ADDR_OWVAR 65
117410: PUSH
117411: LD_INT 7
117413: ST_TO_ADDR
// end ;
117414: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
117415: LD_EXP 147
117419: PUSH
117420: LD_EXP 154
117424: AND
117425: IFFALSE 117627
117427: GO 117429
117429: DISABLE
117430: LD_INT 0
117432: PPUSH
117433: PPUSH
117434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
117435: LD_ADDR_VAR 0 3
117439: PUSH
117440: LD_INT 81
117442: PUSH
117443: LD_OWVAR 2
117447: PUSH
117448: EMPTY
117449: LIST
117450: LIST
117451: PUSH
117452: LD_INT 21
117454: PUSH
117455: LD_INT 1
117457: PUSH
117458: EMPTY
117459: LIST
117460: LIST
117461: PUSH
117462: EMPTY
117463: LIST
117464: LIST
117465: PPUSH
117466: CALL_OW 69
117470: ST_TO_ADDR
// if not tmp then
117471: LD_VAR 0 3
117475: NOT
117476: IFFALSE 117480
// exit ;
117478: GO 117627
// if tmp > 5 then
117480: LD_VAR 0 3
117484: PUSH
117485: LD_INT 5
117487: GREATER
117488: IFFALSE 117500
// k := 5 else
117490: LD_ADDR_VAR 0 2
117494: PUSH
117495: LD_INT 5
117497: ST_TO_ADDR
117498: GO 117510
// k := tmp ;
117500: LD_ADDR_VAR 0 2
117504: PUSH
117505: LD_VAR 0 3
117509: ST_TO_ADDR
// for i := 1 to k do
117510: LD_ADDR_VAR 0 1
117514: PUSH
117515: DOUBLE
117516: LD_INT 1
117518: DEC
117519: ST_TO_ADDR
117520: LD_VAR 0 2
117524: PUSH
117525: FOR_TO
117526: IFFALSE 117625
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
117528: LD_VAR 0 3
117532: PUSH
117533: LD_VAR 0 1
117537: ARRAY
117538: PPUSH
117539: LD_VAR 0 1
117543: PUSH
117544: LD_INT 4
117546: MOD
117547: PUSH
117548: LD_INT 1
117550: PLUS
117551: PPUSH
117552: CALL_OW 259
117556: PUSH
117557: LD_INT 10
117559: LESS
117560: IFFALSE 117623
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
117562: LD_VAR 0 3
117566: PUSH
117567: LD_VAR 0 1
117571: ARRAY
117572: PPUSH
117573: LD_VAR 0 1
117577: PUSH
117578: LD_INT 4
117580: MOD
117581: PUSH
117582: LD_INT 1
117584: PLUS
117585: PPUSH
117586: LD_VAR 0 3
117590: PUSH
117591: LD_VAR 0 1
117595: ARRAY
117596: PPUSH
117597: LD_VAR 0 1
117601: PUSH
117602: LD_INT 4
117604: MOD
117605: PUSH
117606: LD_INT 1
117608: PLUS
117609: PPUSH
117610: CALL_OW 259
117614: PUSH
117615: LD_INT 1
117617: PLUS
117618: PPUSH
117619: CALL_OW 237
117623: GO 117525
117625: POP
117626: POP
// end ;
117627: PPOPN 3
117629: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
117630: LD_EXP 147
117634: PUSH
117635: LD_EXP 155
117639: AND
117640: IFFALSE 117660
117642: GO 117644
117644: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
117645: LD_INT 4
117647: PPUSH
117648: LD_OWVAR 2
117652: PPUSH
117653: LD_INT 0
117655: PPUSH
117656: CALL_OW 324
117660: END
// every 0 0$1 trigger StreamModeActive and sShovel do
117661: LD_EXP 147
117665: PUSH
117666: LD_EXP 184
117670: AND
117671: IFFALSE 117691
117673: GO 117675
117675: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
117676: LD_INT 19
117678: PPUSH
117679: LD_OWVAR 2
117683: PPUSH
117684: LD_INT 0
117686: PPUSH
117687: CALL_OW 324
117691: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
117692: LD_EXP 147
117696: PUSH
117697: LD_EXP 156
117701: AND
117702: IFFALSE 117804
117704: GO 117706
117706: DISABLE
117707: LD_INT 0
117709: PPUSH
117710: PPUSH
// begin enable ;
117711: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
117712: LD_ADDR_VAR 0 2
117716: PUSH
117717: LD_INT 22
117719: PUSH
117720: LD_OWVAR 2
117724: PUSH
117725: EMPTY
117726: LIST
117727: LIST
117728: PUSH
117729: LD_INT 2
117731: PUSH
117732: LD_INT 34
117734: PUSH
117735: LD_INT 11
117737: PUSH
117738: EMPTY
117739: LIST
117740: LIST
117741: PUSH
117742: LD_INT 34
117744: PUSH
117745: LD_INT 30
117747: PUSH
117748: EMPTY
117749: LIST
117750: LIST
117751: PUSH
117752: EMPTY
117753: LIST
117754: LIST
117755: LIST
117756: PUSH
117757: EMPTY
117758: LIST
117759: LIST
117760: PPUSH
117761: CALL_OW 69
117765: ST_TO_ADDR
// if not tmp then
117766: LD_VAR 0 2
117770: NOT
117771: IFFALSE 117775
// exit ;
117773: GO 117804
// for i in tmp do
117775: LD_ADDR_VAR 0 1
117779: PUSH
117780: LD_VAR 0 2
117784: PUSH
117785: FOR_IN
117786: IFFALSE 117802
// begin SetLives ( i , 0 ) ;
117788: LD_VAR 0 1
117792: PPUSH
117793: LD_INT 0
117795: PPUSH
117796: CALL_OW 234
// end ;
117800: GO 117785
117802: POP
117803: POP
// end ;
117804: PPOPN 2
117806: END
// every 0 0$1 trigger StreamModeActive and sBunker do
117807: LD_EXP 147
117811: PUSH
117812: LD_EXP 157
117816: AND
117817: IFFALSE 117837
117819: GO 117821
117821: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
117822: LD_INT 32
117824: PPUSH
117825: LD_OWVAR 2
117829: PPUSH
117830: LD_INT 0
117832: PPUSH
117833: CALL_OW 324
117837: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
117838: LD_EXP 147
117842: PUSH
117843: LD_EXP 158
117847: AND
117848: IFFALSE 118029
117850: GO 117852
117852: DISABLE
117853: LD_INT 0
117855: PPUSH
117856: PPUSH
117857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
117858: LD_ADDR_VAR 0 2
117862: PUSH
117863: LD_INT 22
117865: PUSH
117866: LD_OWVAR 2
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: PUSH
117875: LD_INT 33
117877: PUSH
117878: LD_INT 3
117880: PUSH
117881: EMPTY
117882: LIST
117883: LIST
117884: PUSH
117885: EMPTY
117886: LIST
117887: LIST
117888: PPUSH
117889: CALL_OW 69
117893: ST_TO_ADDR
// if not tmp then
117894: LD_VAR 0 2
117898: NOT
117899: IFFALSE 117903
// exit ;
117901: GO 118029
// side := 0 ;
117903: LD_ADDR_VAR 0 3
117907: PUSH
117908: LD_INT 0
117910: ST_TO_ADDR
// for i := 1 to 8 do
117911: LD_ADDR_VAR 0 1
117915: PUSH
117916: DOUBLE
117917: LD_INT 1
117919: DEC
117920: ST_TO_ADDR
117921: LD_INT 8
117923: PUSH
117924: FOR_TO
117925: IFFALSE 117973
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
117927: LD_OWVAR 2
117931: PUSH
117932: LD_VAR 0 1
117936: NONEQUAL
117937: PUSH
117938: LD_OWVAR 2
117942: PPUSH
117943: LD_VAR 0 1
117947: PPUSH
117948: CALL_OW 81
117952: PUSH
117953: LD_INT 2
117955: EQUAL
117956: AND
117957: IFFALSE 117971
// begin side := i ;
117959: LD_ADDR_VAR 0 3
117963: PUSH
117964: LD_VAR 0 1
117968: ST_TO_ADDR
// break ;
117969: GO 117973
// end ;
117971: GO 117924
117973: POP
117974: POP
// if not side then
117975: LD_VAR 0 3
117979: NOT
117980: IFFALSE 117984
// exit ;
117982: GO 118029
// for i := 1 to tmp do
117984: LD_ADDR_VAR 0 1
117988: PUSH
117989: DOUBLE
117990: LD_INT 1
117992: DEC
117993: ST_TO_ADDR
117994: LD_VAR 0 2
117998: PUSH
117999: FOR_TO
118000: IFFALSE 118027
// if Prob ( 60 ) then
118002: LD_INT 60
118004: PPUSH
118005: CALL_OW 13
118009: IFFALSE 118025
// SetSide ( i , side ) ;
118011: LD_VAR 0 1
118015: PPUSH
118016: LD_VAR 0 3
118020: PPUSH
118021: CALL_OW 235
118025: GO 117999
118027: POP
118028: POP
// end ;
118029: PPOPN 3
118031: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
118032: LD_EXP 147
118036: PUSH
118037: LD_EXP 160
118041: AND
118042: IFFALSE 118161
118044: GO 118046
118046: DISABLE
118047: LD_INT 0
118049: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
118050: LD_ADDR_VAR 0 1
118054: PUSH
118055: LD_INT 22
118057: PUSH
118058: LD_OWVAR 2
118062: PUSH
118063: EMPTY
118064: LIST
118065: LIST
118066: PUSH
118067: LD_INT 21
118069: PUSH
118070: LD_INT 1
118072: PUSH
118073: EMPTY
118074: LIST
118075: LIST
118076: PUSH
118077: LD_INT 3
118079: PUSH
118080: LD_INT 23
118082: PUSH
118083: LD_INT 0
118085: PUSH
118086: EMPTY
118087: LIST
118088: LIST
118089: PUSH
118090: EMPTY
118091: LIST
118092: LIST
118093: PUSH
118094: EMPTY
118095: LIST
118096: LIST
118097: LIST
118098: PPUSH
118099: CALL_OW 69
118103: PUSH
118104: FOR_IN
118105: IFFALSE 118159
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
118107: LD_VAR 0 1
118111: PPUSH
118112: CALL_OW 257
118116: PUSH
118117: LD_INT 1
118119: PUSH
118120: LD_INT 2
118122: PUSH
118123: LD_INT 3
118125: PUSH
118126: LD_INT 4
118128: PUSH
118129: EMPTY
118130: LIST
118131: LIST
118132: LIST
118133: LIST
118134: IN
118135: IFFALSE 118157
// SetClass ( un , rand ( 1 , 4 ) ) ;
118137: LD_VAR 0 1
118141: PPUSH
118142: LD_INT 1
118144: PPUSH
118145: LD_INT 4
118147: PPUSH
118148: CALL_OW 12
118152: PPUSH
118153: CALL_OW 336
118157: GO 118104
118159: POP
118160: POP
// end ;
118161: PPOPN 1
118163: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
118164: LD_EXP 147
118168: PUSH
118169: LD_EXP 159
118173: AND
118174: IFFALSE 118253
118176: GO 118178
118178: DISABLE
118179: LD_INT 0
118181: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
118182: LD_ADDR_VAR 0 1
118186: PUSH
118187: LD_INT 22
118189: PUSH
118190: LD_OWVAR 2
118194: PUSH
118195: EMPTY
118196: LIST
118197: LIST
118198: PUSH
118199: LD_INT 21
118201: PUSH
118202: LD_INT 3
118204: PUSH
118205: EMPTY
118206: LIST
118207: LIST
118208: PUSH
118209: EMPTY
118210: LIST
118211: LIST
118212: PPUSH
118213: CALL_OW 69
118217: ST_TO_ADDR
// if not tmp then
118218: LD_VAR 0 1
118222: NOT
118223: IFFALSE 118227
// exit ;
118225: GO 118253
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
118227: LD_VAR 0 1
118231: PUSH
118232: LD_INT 1
118234: PPUSH
118235: LD_VAR 0 1
118239: PPUSH
118240: CALL_OW 12
118244: ARRAY
118245: PPUSH
118246: LD_INT 100
118248: PPUSH
118249: CALL_OW 234
// end ;
118253: PPOPN 1
118255: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
118256: LD_EXP 147
118260: PUSH
118261: LD_EXP 161
118265: AND
118266: IFFALSE 118364
118268: GO 118270
118270: DISABLE
118271: LD_INT 0
118273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118274: LD_ADDR_VAR 0 1
118278: PUSH
118279: LD_INT 22
118281: PUSH
118282: LD_OWVAR 2
118286: PUSH
118287: EMPTY
118288: LIST
118289: LIST
118290: PUSH
118291: LD_INT 21
118293: PUSH
118294: LD_INT 1
118296: PUSH
118297: EMPTY
118298: LIST
118299: LIST
118300: PUSH
118301: EMPTY
118302: LIST
118303: LIST
118304: PPUSH
118305: CALL_OW 69
118309: ST_TO_ADDR
// if not tmp then
118310: LD_VAR 0 1
118314: NOT
118315: IFFALSE 118319
// exit ;
118317: GO 118364
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
118319: LD_VAR 0 1
118323: PUSH
118324: LD_INT 1
118326: PPUSH
118327: LD_VAR 0 1
118331: PPUSH
118332: CALL_OW 12
118336: ARRAY
118337: PPUSH
118338: LD_INT 1
118340: PPUSH
118341: LD_INT 4
118343: PPUSH
118344: CALL_OW 12
118348: PPUSH
118349: LD_INT 3000
118351: PPUSH
118352: LD_INT 9000
118354: PPUSH
118355: CALL_OW 12
118359: PPUSH
118360: CALL_OW 492
// end ;
118364: PPOPN 1
118366: END
// every 0 0$1 trigger StreamModeActive and sDepot do
118367: LD_EXP 147
118371: PUSH
118372: LD_EXP 162
118376: AND
118377: IFFALSE 118397
118379: GO 118381
118381: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
118382: LD_INT 1
118384: PPUSH
118385: LD_OWVAR 2
118389: PPUSH
118390: LD_INT 0
118392: PPUSH
118393: CALL_OW 324
118397: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
118398: LD_EXP 147
118402: PUSH
118403: LD_EXP 163
118407: AND
118408: IFFALSE 118491
118410: GO 118412
118412: DISABLE
118413: LD_INT 0
118415: PPUSH
118416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
118417: LD_ADDR_VAR 0 2
118421: PUSH
118422: LD_INT 22
118424: PUSH
118425: LD_OWVAR 2
118429: PUSH
118430: EMPTY
118431: LIST
118432: LIST
118433: PUSH
118434: LD_INT 21
118436: PUSH
118437: LD_INT 3
118439: PUSH
118440: EMPTY
118441: LIST
118442: LIST
118443: PUSH
118444: EMPTY
118445: LIST
118446: LIST
118447: PPUSH
118448: CALL_OW 69
118452: ST_TO_ADDR
// if not tmp then
118453: LD_VAR 0 2
118457: NOT
118458: IFFALSE 118462
// exit ;
118460: GO 118491
// for i in tmp do
118462: LD_ADDR_VAR 0 1
118466: PUSH
118467: LD_VAR 0 2
118471: PUSH
118472: FOR_IN
118473: IFFALSE 118489
// SetBLevel ( i , 10 ) ;
118475: LD_VAR 0 1
118479: PPUSH
118480: LD_INT 10
118482: PPUSH
118483: CALL_OW 241
118487: GO 118472
118489: POP
118490: POP
// end ;
118491: PPOPN 2
118493: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
118494: LD_EXP 147
118498: PUSH
118499: LD_EXP 164
118503: AND
118504: IFFALSE 118615
118506: GO 118508
118508: DISABLE
118509: LD_INT 0
118511: PPUSH
118512: PPUSH
118513: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118514: LD_ADDR_VAR 0 3
118518: PUSH
118519: LD_INT 22
118521: PUSH
118522: LD_OWVAR 2
118526: PUSH
118527: EMPTY
118528: LIST
118529: LIST
118530: PUSH
118531: LD_INT 25
118533: PUSH
118534: LD_INT 1
118536: PUSH
118537: EMPTY
118538: LIST
118539: LIST
118540: PUSH
118541: EMPTY
118542: LIST
118543: LIST
118544: PPUSH
118545: CALL_OW 69
118549: ST_TO_ADDR
// if not tmp then
118550: LD_VAR 0 3
118554: NOT
118555: IFFALSE 118559
// exit ;
118557: GO 118615
// un := tmp [ rand ( 1 , tmp ) ] ;
118559: LD_ADDR_VAR 0 2
118563: PUSH
118564: LD_VAR 0 3
118568: PUSH
118569: LD_INT 1
118571: PPUSH
118572: LD_VAR 0 3
118576: PPUSH
118577: CALL_OW 12
118581: ARRAY
118582: ST_TO_ADDR
// if Crawls ( un ) then
118583: LD_VAR 0 2
118587: PPUSH
118588: CALL_OW 318
118592: IFFALSE 118603
// ComWalk ( un ) ;
118594: LD_VAR 0 2
118598: PPUSH
118599: CALL_OW 138
// SetClass ( un , class_sniper ) ;
118603: LD_VAR 0 2
118607: PPUSH
118608: LD_INT 5
118610: PPUSH
118611: CALL_OW 336
// end ;
118615: PPOPN 3
118617: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
118618: LD_EXP 147
118622: PUSH
118623: LD_EXP 165
118627: AND
118628: PUSH
118629: LD_OWVAR 67
118633: PUSH
118634: LD_INT 4
118636: LESS
118637: AND
118638: IFFALSE 118657
118640: GO 118642
118642: DISABLE
// begin Difficulty := Difficulty + 1 ;
118643: LD_ADDR_OWVAR 67
118647: PUSH
118648: LD_OWVAR 67
118652: PUSH
118653: LD_INT 1
118655: PLUS
118656: ST_TO_ADDR
// end ;
118657: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
118658: LD_EXP 147
118662: PUSH
118663: LD_EXP 166
118667: AND
118668: IFFALSE 118771
118670: GO 118672
118672: DISABLE
118673: LD_INT 0
118675: PPUSH
// begin for i := 1 to 5 do
118676: LD_ADDR_VAR 0 1
118680: PUSH
118681: DOUBLE
118682: LD_INT 1
118684: DEC
118685: ST_TO_ADDR
118686: LD_INT 5
118688: PUSH
118689: FOR_TO
118690: IFFALSE 118769
// begin uc_nation := nation_nature ;
118692: LD_ADDR_OWVAR 21
118696: PUSH
118697: LD_INT 0
118699: ST_TO_ADDR
// uc_side := 0 ;
118700: LD_ADDR_OWVAR 20
118704: PUSH
118705: LD_INT 0
118707: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
118708: LD_ADDR_OWVAR 29
118712: PUSH
118713: LD_INT 12
118715: PUSH
118716: LD_INT 12
118718: PUSH
118719: EMPTY
118720: LIST
118721: LIST
118722: ST_TO_ADDR
// hc_agressivity := 20 ;
118723: LD_ADDR_OWVAR 35
118727: PUSH
118728: LD_INT 20
118730: ST_TO_ADDR
// hc_class := class_tiger ;
118731: LD_ADDR_OWVAR 28
118735: PUSH
118736: LD_INT 14
118738: ST_TO_ADDR
// hc_gallery :=  ;
118739: LD_ADDR_OWVAR 33
118743: PUSH
118744: LD_STRING 
118746: ST_TO_ADDR
// hc_name :=  ;
118747: LD_ADDR_OWVAR 26
118751: PUSH
118752: LD_STRING 
118754: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
118755: CALL_OW 44
118759: PPUSH
118760: LD_INT 0
118762: PPUSH
118763: CALL_OW 51
// end ;
118767: GO 118689
118769: POP
118770: POP
// end ;
118771: PPOPN 1
118773: END
// every 0 0$1 trigger StreamModeActive and sBomb do
118774: LD_EXP 147
118778: PUSH
118779: LD_EXP 167
118783: AND
118784: IFFALSE 118793
118786: GO 118788
118788: DISABLE
// StreamSibBomb ;
118789: CALL 118794 0 0
118793: END
// export function StreamSibBomb ; var i , x , y ; begin
118794: LD_INT 0
118796: PPUSH
118797: PPUSH
118798: PPUSH
118799: PPUSH
// result := false ;
118800: LD_ADDR_VAR 0 1
118804: PUSH
118805: LD_INT 0
118807: ST_TO_ADDR
// for i := 1 to 16 do
118808: LD_ADDR_VAR 0 2
118812: PUSH
118813: DOUBLE
118814: LD_INT 1
118816: DEC
118817: ST_TO_ADDR
118818: LD_INT 16
118820: PUSH
118821: FOR_TO
118822: IFFALSE 119021
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118824: LD_ADDR_VAR 0 3
118828: PUSH
118829: LD_INT 10
118831: PUSH
118832: LD_INT 20
118834: PUSH
118835: LD_INT 30
118837: PUSH
118838: LD_INT 40
118840: PUSH
118841: LD_INT 50
118843: PUSH
118844: LD_INT 60
118846: PUSH
118847: LD_INT 70
118849: PUSH
118850: LD_INT 80
118852: PUSH
118853: LD_INT 90
118855: PUSH
118856: LD_INT 100
118858: PUSH
118859: LD_INT 110
118861: PUSH
118862: LD_INT 120
118864: PUSH
118865: LD_INT 130
118867: PUSH
118868: LD_INT 140
118870: PUSH
118871: LD_INT 150
118873: PUSH
118874: EMPTY
118875: LIST
118876: LIST
118877: LIST
118878: LIST
118879: LIST
118880: LIST
118881: LIST
118882: LIST
118883: LIST
118884: LIST
118885: LIST
118886: LIST
118887: LIST
118888: LIST
118889: LIST
118890: PUSH
118891: LD_INT 1
118893: PPUSH
118894: LD_INT 15
118896: PPUSH
118897: CALL_OW 12
118901: ARRAY
118902: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118903: LD_ADDR_VAR 0 4
118907: PUSH
118908: LD_INT 10
118910: PUSH
118911: LD_INT 20
118913: PUSH
118914: LD_INT 30
118916: PUSH
118917: LD_INT 40
118919: PUSH
118920: LD_INT 50
118922: PUSH
118923: LD_INT 60
118925: PUSH
118926: LD_INT 70
118928: PUSH
118929: LD_INT 80
118931: PUSH
118932: LD_INT 90
118934: PUSH
118935: LD_INT 100
118937: PUSH
118938: LD_INT 110
118940: PUSH
118941: LD_INT 120
118943: PUSH
118944: LD_INT 130
118946: PUSH
118947: LD_INT 140
118949: PUSH
118950: LD_INT 150
118952: PUSH
118953: EMPTY
118954: LIST
118955: LIST
118956: LIST
118957: LIST
118958: LIST
118959: LIST
118960: LIST
118961: LIST
118962: LIST
118963: LIST
118964: LIST
118965: LIST
118966: LIST
118967: LIST
118968: LIST
118969: PUSH
118970: LD_INT 1
118972: PPUSH
118973: LD_INT 15
118975: PPUSH
118976: CALL_OW 12
118980: ARRAY
118981: ST_TO_ADDR
// if ValidHex ( x , y ) then
118982: LD_VAR 0 3
118986: PPUSH
118987: LD_VAR 0 4
118991: PPUSH
118992: CALL_OW 488
118996: IFFALSE 119019
// begin result := [ x , y ] ;
118998: LD_ADDR_VAR 0 1
119002: PUSH
119003: LD_VAR 0 3
119007: PUSH
119008: LD_VAR 0 4
119012: PUSH
119013: EMPTY
119014: LIST
119015: LIST
119016: ST_TO_ADDR
// break ;
119017: GO 119021
// end ; end ;
119019: GO 118821
119021: POP
119022: POP
// if result then
119023: LD_VAR 0 1
119027: IFFALSE 119087
// begin ToLua ( playSibBomb() ) ;
119029: LD_STRING playSibBomb()
119031: PPUSH
119032: CALL_OW 559
// wait ( 0 0$14 ) ;
119036: LD_INT 490
119038: PPUSH
119039: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
119043: LD_VAR 0 1
119047: PUSH
119048: LD_INT 1
119050: ARRAY
119051: PPUSH
119052: LD_VAR 0 1
119056: PUSH
119057: LD_INT 2
119059: ARRAY
119060: PPUSH
119061: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
119065: LD_VAR 0 1
119069: PUSH
119070: LD_INT 1
119072: ARRAY
119073: PPUSH
119074: LD_VAR 0 1
119078: PUSH
119079: LD_INT 2
119081: ARRAY
119082: PPUSH
119083: CALL_OW 429
// end ; end ;
119087: LD_VAR 0 1
119091: RET
// every 0 0$1 trigger StreamModeActive and sReset do
119092: LD_EXP 147
119096: PUSH
119097: LD_EXP 169
119101: AND
119102: IFFALSE 119114
119104: GO 119106
119106: DISABLE
// YouLost (  ) ;
119107: LD_STRING 
119109: PPUSH
119110: CALL_OW 104
119114: END
// every 0 0$1 trigger StreamModeActive and sFog do
119115: LD_EXP 147
119119: PUSH
119120: LD_EXP 168
119124: AND
119125: IFFALSE 119139
119127: GO 119129
119129: DISABLE
// FogOff ( your_side ) ;
119130: LD_OWVAR 2
119134: PPUSH
119135: CALL_OW 344
119139: END
// every 0 0$1 trigger StreamModeActive and sSun do
119140: LD_EXP 147
119144: PUSH
119145: LD_EXP 170
119149: AND
119150: IFFALSE 119178
119152: GO 119154
119154: DISABLE
// begin solar_recharge_percent := 0 ;
119155: LD_ADDR_OWVAR 79
119159: PUSH
119160: LD_INT 0
119162: ST_TO_ADDR
// wait ( 5 5$00 ) ;
119163: LD_INT 10500
119165: PPUSH
119166: CALL_OW 67
// solar_recharge_percent := 100 ;
119170: LD_ADDR_OWVAR 79
119174: PUSH
119175: LD_INT 100
119177: ST_TO_ADDR
// end ;
119178: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
119179: LD_EXP 147
119183: PUSH
119184: LD_EXP 171
119188: AND
119189: IFFALSE 119428
119191: GO 119193
119193: DISABLE
119194: LD_INT 0
119196: PPUSH
119197: PPUSH
119198: PPUSH
// begin tmp := [ ] ;
119199: LD_ADDR_VAR 0 3
119203: PUSH
119204: EMPTY
119205: ST_TO_ADDR
// for i := 1 to 6 do
119206: LD_ADDR_VAR 0 1
119210: PUSH
119211: DOUBLE
119212: LD_INT 1
119214: DEC
119215: ST_TO_ADDR
119216: LD_INT 6
119218: PUSH
119219: FOR_TO
119220: IFFALSE 119325
// begin uc_nation := nation_nature ;
119222: LD_ADDR_OWVAR 21
119226: PUSH
119227: LD_INT 0
119229: ST_TO_ADDR
// uc_side := 0 ;
119230: LD_ADDR_OWVAR 20
119234: PUSH
119235: LD_INT 0
119237: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
119238: LD_ADDR_OWVAR 29
119242: PUSH
119243: LD_INT 12
119245: PUSH
119246: LD_INT 12
119248: PUSH
119249: EMPTY
119250: LIST
119251: LIST
119252: ST_TO_ADDR
// hc_agressivity := 20 ;
119253: LD_ADDR_OWVAR 35
119257: PUSH
119258: LD_INT 20
119260: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
119261: LD_ADDR_OWVAR 28
119265: PUSH
119266: LD_INT 17
119268: ST_TO_ADDR
// hc_gallery :=  ;
119269: LD_ADDR_OWVAR 33
119273: PUSH
119274: LD_STRING 
119276: ST_TO_ADDR
// hc_name :=  ;
119277: LD_ADDR_OWVAR 26
119281: PUSH
119282: LD_STRING 
119284: ST_TO_ADDR
// un := CreateHuman ;
119285: LD_ADDR_VAR 0 2
119289: PUSH
119290: CALL_OW 44
119294: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
119295: LD_VAR 0 2
119299: PPUSH
119300: LD_INT 1
119302: PPUSH
119303: CALL_OW 51
// tmp := tmp ^ un ;
119307: LD_ADDR_VAR 0 3
119311: PUSH
119312: LD_VAR 0 3
119316: PUSH
119317: LD_VAR 0 2
119321: ADD
119322: ST_TO_ADDR
// end ;
119323: GO 119219
119325: POP
119326: POP
// repeat wait ( 0 0$1 ) ;
119327: LD_INT 35
119329: PPUSH
119330: CALL_OW 67
// for un in tmp do
119334: LD_ADDR_VAR 0 2
119338: PUSH
119339: LD_VAR 0 3
119343: PUSH
119344: FOR_IN
119345: IFFALSE 119419
// begin if IsDead ( un ) then
119347: LD_VAR 0 2
119351: PPUSH
119352: CALL_OW 301
119356: IFFALSE 119376
// begin tmp := tmp diff un ;
119358: LD_ADDR_VAR 0 3
119362: PUSH
119363: LD_VAR 0 3
119367: PUSH
119368: LD_VAR 0 2
119372: DIFF
119373: ST_TO_ADDR
// continue ;
119374: GO 119344
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
119376: LD_VAR 0 2
119380: PPUSH
119381: LD_INT 3
119383: PUSH
119384: LD_INT 22
119386: PUSH
119387: LD_INT 0
119389: PUSH
119390: EMPTY
119391: LIST
119392: LIST
119393: PUSH
119394: EMPTY
119395: LIST
119396: LIST
119397: PPUSH
119398: CALL_OW 69
119402: PPUSH
119403: LD_VAR 0 2
119407: PPUSH
119408: CALL_OW 74
119412: PPUSH
119413: CALL_OW 115
// end ;
119417: GO 119344
119419: POP
119420: POP
// until not tmp ;
119421: LD_VAR 0 3
119425: NOT
119426: IFFALSE 119327
// end ;
119428: PPOPN 3
119430: END
// every 0 0$1 trigger StreamModeActive and sTroll do
119431: LD_EXP 147
119435: PUSH
119436: LD_EXP 172
119440: AND
119441: IFFALSE 119495
119443: GO 119445
119445: DISABLE
// begin ToLua ( displayTroll(); ) ;
119446: LD_STRING displayTroll();
119448: PPUSH
119449: CALL_OW 559
// wait ( 3 3$00 ) ;
119453: LD_INT 6300
119455: PPUSH
119456: CALL_OW 67
// ToLua ( hideTroll(); ) ;
119460: LD_STRING hideTroll();
119462: PPUSH
119463: CALL_OW 559
// wait ( 1 1$00 ) ;
119467: LD_INT 2100
119469: PPUSH
119470: CALL_OW 67
// ToLua ( displayTroll(); ) ;
119474: LD_STRING displayTroll();
119476: PPUSH
119477: CALL_OW 559
// wait ( 1 1$00 ) ;
119481: LD_INT 2100
119483: PPUSH
119484: CALL_OW 67
// ToLua ( hideTroll(); ) ;
119488: LD_STRING hideTroll();
119490: PPUSH
119491: CALL_OW 559
// end ;
119495: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
119496: LD_EXP 147
119500: PUSH
119501: LD_EXP 173
119505: AND
119506: IFFALSE 119569
119508: GO 119510
119510: DISABLE
119511: LD_INT 0
119513: PPUSH
// begin p := 0 ;
119514: LD_ADDR_VAR 0 1
119518: PUSH
119519: LD_INT 0
119521: ST_TO_ADDR
// repeat game_speed := 1 ;
119522: LD_ADDR_OWVAR 65
119526: PUSH
119527: LD_INT 1
119529: ST_TO_ADDR
// wait ( 0 0$1 ) ;
119530: LD_INT 35
119532: PPUSH
119533: CALL_OW 67
// p := p + 1 ;
119537: LD_ADDR_VAR 0 1
119541: PUSH
119542: LD_VAR 0 1
119546: PUSH
119547: LD_INT 1
119549: PLUS
119550: ST_TO_ADDR
// until p >= 60 ;
119551: LD_VAR 0 1
119555: PUSH
119556: LD_INT 60
119558: GREATEREQUAL
119559: IFFALSE 119522
// game_speed := 4 ;
119561: LD_ADDR_OWVAR 65
119565: PUSH
119566: LD_INT 4
119568: ST_TO_ADDR
// end ;
119569: PPOPN 1
119571: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
119572: LD_EXP 147
119576: PUSH
119577: LD_EXP 174
119581: AND
119582: IFFALSE 119728
119584: GO 119586
119586: DISABLE
119587: LD_INT 0
119589: PPUSH
119590: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
119591: LD_ADDR_VAR 0 1
119595: PUSH
119596: LD_INT 22
119598: PUSH
119599: LD_OWVAR 2
119603: PUSH
119604: EMPTY
119605: LIST
119606: LIST
119607: PUSH
119608: LD_INT 2
119610: PUSH
119611: LD_INT 30
119613: PUSH
119614: LD_INT 0
119616: PUSH
119617: EMPTY
119618: LIST
119619: LIST
119620: PUSH
119621: LD_INT 30
119623: PUSH
119624: LD_INT 1
119626: PUSH
119627: EMPTY
119628: LIST
119629: LIST
119630: PUSH
119631: EMPTY
119632: LIST
119633: LIST
119634: LIST
119635: PUSH
119636: EMPTY
119637: LIST
119638: LIST
119639: PPUSH
119640: CALL_OW 69
119644: ST_TO_ADDR
// if not depot then
119645: LD_VAR 0 1
119649: NOT
119650: IFFALSE 119654
// exit ;
119652: GO 119728
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
119654: LD_ADDR_VAR 0 2
119658: PUSH
119659: LD_VAR 0 1
119663: PUSH
119664: LD_INT 1
119666: PPUSH
119667: LD_VAR 0 1
119671: PPUSH
119672: CALL_OW 12
119676: ARRAY
119677: PPUSH
119678: CALL_OW 274
119682: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
119683: LD_VAR 0 2
119687: PPUSH
119688: LD_INT 1
119690: PPUSH
119691: LD_INT 0
119693: PPUSH
119694: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
119698: LD_VAR 0 2
119702: PPUSH
119703: LD_INT 2
119705: PPUSH
119706: LD_INT 0
119708: PPUSH
119709: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
119713: LD_VAR 0 2
119717: PPUSH
119718: LD_INT 3
119720: PPUSH
119721: LD_INT 0
119723: PPUSH
119724: CALL_OW 277
// end ;
119728: PPOPN 2
119730: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
119731: LD_EXP 147
119735: PUSH
119736: LD_EXP 175
119740: AND
119741: IFFALSE 119838
119743: GO 119745
119745: DISABLE
119746: LD_INT 0
119748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119749: LD_ADDR_VAR 0 1
119753: PUSH
119754: LD_INT 22
119756: PUSH
119757: LD_OWVAR 2
119761: PUSH
119762: EMPTY
119763: LIST
119764: LIST
119765: PUSH
119766: LD_INT 21
119768: PUSH
119769: LD_INT 1
119771: PUSH
119772: EMPTY
119773: LIST
119774: LIST
119775: PUSH
119776: LD_INT 3
119778: PUSH
119779: LD_INT 23
119781: PUSH
119782: LD_INT 0
119784: PUSH
119785: EMPTY
119786: LIST
119787: LIST
119788: PUSH
119789: EMPTY
119790: LIST
119791: LIST
119792: PUSH
119793: EMPTY
119794: LIST
119795: LIST
119796: LIST
119797: PPUSH
119798: CALL_OW 69
119802: ST_TO_ADDR
// if not tmp then
119803: LD_VAR 0 1
119807: NOT
119808: IFFALSE 119812
// exit ;
119810: GO 119838
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
119812: LD_VAR 0 1
119816: PUSH
119817: LD_INT 1
119819: PPUSH
119820: LD_VAR 0 1
119824: PPUSH
119825: CALL_OW 12
119829: ARRAY
119830: PPUSH
119831: LD_INT 200
119833: PPUSH
119834: CALL_OW 234
// end ;
119838: PPOPN 1
119840: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
119841: LD_EXP 147
119845: PUSH
119846: LD_EXP 176
119850: AND
119851: IFFALSE 119930
119853: GO 119855
119855: DISABLE
119856: LD_INT 0
119858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
119859: LD_ADDR_VAR 0 1
119863: PUSH
119864: LD_INT 22
119866: PUSH
119867: LD_OWVAR 2
119871: PUSH
119872: EMPTY
119873: LIST
119874: LIST
119875: PUSH
119876: LD_INT 21
119878: PUSH
119879: LD_INT 2
119881: PUSH
119882: EMPTY
119883: LIST
119884: LIST
119885: PUSH
119886: EMPTY
119887: LIST
119888: LIST
119889: PPUSH
119890: CALL_OW 69
119894: ST_TO_ADDR
// if not tmp then
119895: LD_VAR 0 1
119899: NOT
119900: IFFALSE 119904
// exit ;
119902: GO 119930
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
119904: LD_VAR 0 1
119908: PUSH
119909: LD_INT 1
119911: PPUSH
119912: LD_VAR 0 1
119916: PPUSH
119917: CALL_OW 12
119921: ARRAY
119922: PPUSH
119923: LD_INT 60
119925: PPUSH
119926: CALL_OW 234
// end ;
119930: PPOPN 1
119932: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
119933: LD_EXP 147
119937: PUSH
119938: LD_EXP 177
119942: AND
119943: IFFALSE 120042
119945: GO 119947
119947: DISABLE
119948: LD_INT 0
119950: PPUSH
119951: PPUSH
// begin enable ;
119952: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
119953: LD_ADDR_VAR 0 1
119957: PUSH
119958: LD_INT 22
119960: PUSH
119961: LD_OWVAR 2
119965: PUSH
119966: EMPTY
119967: LIST
119968: LIST
119969: PUSH
119970: LD_INT 61
119972: PUSH
119973: EMPTY
119974: LIST
119975: PUSH
119976: LD_INT 33
119978: PUSH
119979: LD_INT 2
119981: PUSH
119982: EMPTY
119983: LIST
119984: LIST
119985: PUSH
119986: EMPTY
119987: LIST
119988: LIST
119989: LIST
119990: PPUSH
119991: CALL_OW 69
119995: ST_TO_ADDR
// if not tmp then
119996: LD_VAR 0 1
120000: NOT
120001: IFFALSE 120005
// exit ;
120003: GO 120042
// for i in tmp do
120005: LD_ADDR_VAR 0 2
120009: PUSH
120010: LD_VAR 0 1
120014: PUSH
120015: FOR_IN
120016: IFFALSE 120040
// if IsControledBy ( i ) then
120018: LD_VAR 0 2
120022: PPUSH
120023: CALL_OW 312
120027: IFFALSE 120038
// ComUnlink ( i ) ;
120029: LD_VAR 0 2
120033: PPUSH
120034: CALL_OW 136
120038: GO 120015
120040: POP
120041: POP
// end ;
120042: PPOPN 2
120044: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
120045: LD_EXP 147
120049: PUSH
120050: LD_EXP 178
120054: AND
120055: IFFALSE 120195
120057: GO 120059
120059: DISABLE
120060: LD_INT 0
120062: PPUSH
120063: PPUSH
// begin ToLua ( displayPowell(); ) ;
120064: LD_STRING displayPowell();
120066: PPUSH
120067: CALL_OW 559
// uc_side := 0 ;
120071: LD_ADDR_OWVAR 20
120075: PUSH
120076: LD_INT 0
120078: ST_TO_ADDR
// uc_nation := 2 ;
120079: LD_ADDR_OWVAR 21
120083: PUSH
120084: LD_INT 2
120086: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
120087: LD_ADDR_OWVAR 37
120091: PUSH
120092: LD_INT 14
120094: ST_TO_ADDR
// vc_engine := engine_siberite ;
120095: LD_ADDR_OWVAR 39
120099: PUSH
120100: LD_INT 3
120102: ST_TO_ADDR
// vc_control := control_apeman ;
120103: LD_ADDR_OWVAR 38
120107: PUSH
120108: LD_INT 5
120110: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
120111: LD_ADDR_OWVAR 40
120115: PUSH
120116: LD_INT 29
120118: ST_TO_ADDR
// un := CreateVehicle ;
120119: LD_ADDR_VAR 0 2
120123: PUSH
120124: CALL_OW 45
120128: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120129: LD_VAR 0 2
120133: PPUSH
120134: LD_INT 1
120136: PPUSH
120137: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
120141: LD_INT 35
120143: PPUSH
120144: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
120148: LD_VAR 0 2
120152: PPUSH
120153: LD_INT 22
120155: PUSH
120156: LD_OWVAR 2
120160: PUSH
120161: EMPTY
120162: LIST
120163: LIST
120164: PPUSH
120165: CALL_OW 69
120169: PPUSH
120170: LD_VAR 0 2
120174: PPUSH
120175: CALL_OW 74
120179: PPUSH
120180: CALL_OW 115
// until IsDead ( un ) ;
120184: LD_VAR 0 2
120188: PPUSH
120189: CALL_OW 301
120193: IFFALSE 120141
// end ;
120195: PPOPN 2
120197: END
// every 0 0$1 trigger StreamModeActive and sStu do
120198: LD_EXP 147
120202: PUSH
120203: LD_EXP 186
120207: AND
120208: IFFALSE 120224
120210: GO 120212
120212: DISABLE
// begin ToLua ( displayStucuk(); ) ;
120213: LD_STRING displayStucuk();
120215: PPUSH
120216: CALL_OW 559
// ResetFog ;
120220: CALL_OW 335
// end ;
120224: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
120225: LD_EXP 147
120229: PUSH
120230: LD_EXP 179
120234: AND
120235: IFFALSE 120376
120237: GO 120239
120239: DISABLE
120240: LD_INT 0
120242: PPUSH
120243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120244: LD_ADDR_VAR 0 2
120248: PUSH
120249: LD_INT 22
120251: PUSH
120252: LD_OWVAR 2
120256: PUSH
120257: EMPTY
120258: LIST
120259: LIST
120260: PUSH
120261: LD_INT 21
120263: PUSH
120264: LD_INT 1
120266: PUSH
120267: EMPTY
120268: LIST
120269: LIST
120270: PUSH
120271: EMPTY
120272: LIST
120273: LIST
120274: PPUSH
120275: CALL_OW 69
120279: ST_TO_ADDR
// if not tmp then
120280: LD_VAR 0 2
120284: NOT
120285: IFFALSE 120289
// exit ;
120287: GO 120376
// un := tmp [ rand ( 1 , tmp ) ] ;
120289: LD_ADDR_VAR 0 1
120293: PUSH
120294: LD_VAR 0 2
120298: PUSH
120299: LD_INT 1
120301: PPUSH
120302: LD_VAR 0 2
120306: PPUSH
120307: CALL_OW 12
120311: ARRAY
120312: ST_TO_ADDR
// SetSide ( un , 0 ) ;
120313: LD_VAR 0 1
120317: PPUSH
120318: LD_INT 0
120320: PPUSH
120321: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
120325: LD_VAR 0 1
120329: PPUSH
120330: LD_OWVAR 3
120334: PUSH
120335: LD_VAR 0 1
120339: DIFF
120340: PPUSH
120341: LD_VAR 0 1
120345: PPUSH
120346: CALL_OW 74
120350: PPUSH
120351: CALL_OW 115
// wait ( 0 0$20 ) ;
120355: LD_INT 700
120357: PPUSH
120358: CALL_OW 67
// SetSide ( un , your_side ) ;
120362: LD_VAR 0 1
120366: PPUSH
120367: LD_OWVAR 2
120371: PPUSH
120372: CALL_OW 235
// end ;
120376: PPOPN 2
120378: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
120379: LD_EXP 147
120383: PUSH
120384: LD_EXP 180
120388: AND
120389: IFFALSE 120495
120391: GO 120393
120393: DISABLE
120394: LD_INT 0
120396: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120397: LD_ADDR_VAR 0 1
120401: PUSH
120402: LD_INT 22
120404: PUSH
120405: LD_OWVAR 2
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: PUSH
120414: LD_INT 2
120416: PUSH
120417: LD_INT 30
120419: PUSH
120420: LD_INT 0
120422: PUSH
120423: EMPTY
120424: LIST
120425: LIST
120426: PUSH
120427: LD_INT 30
120429: PUSH
120430: LD_INT 1
120432: PUSH
120433: EMPTY
120434: LIST
120435: LIST
120436: PUSH
120437: EMPTY
120438: LIST
120439: LIST
120440: LIST
120441: PUSH
120442: EMPTY
120443: LIST
120444: LIST
120445: PPUSH
120446: CALL_OW 69
120450: ST_TO_ADDR
// if not depot then
120451: LD_VAR 0 1
120455: NOT
120456: IFFALSE 120460
// exit ;
120458: GO 120495
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
120460: LD_VAR 0 1
120464: PUSH
120465: LD_INT 1
120467: ARRAY
120468: PPUSH
120469: CALL_OW 250
120473: PPUSH
120474: LD_VAR 0 1
120478: PUSH
120479: LD_INT 1
120481: ARRAY
120482: PPUSH
120483: CALL_OW 251
120487: PPUSH
120488: LD_INT 70
120490: PPUSH
120491: CALL_OW 495
// end ;
120495: PPOPN 1
120497: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
120498: LD_EXP 147
120502: PUSH
120503: LD_EXP 181
120507: AND
120508: IFFALSE 120719
120510: GO 120512
120512: DISABLE
120513: LD_INT 0
120515: PPUSH
120516: PPUSH
120517: PPUSH
120518: PPUSH
120519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120520: LD_ADDR_VAR 0 5
120524: PUSH
120525: LD_INT 22
120527: PUSH
120528: LD_OWVAR 2
120532: PUSH
120533: EMPTY
120534: LIST
120535: LIST
120536: PUSH
120537: LD_INT 21
120539: PUSH
120540: LD_INT 1
120542: PUSH
120543: EMPTY
120544: LIST
120545: LIST
120546: PUSH
120547: EMPTY
120548: LIST
120549: LIST
120550: PPUSH
120551: CALL_OW 69
120555: ST_TO_ADDR
// if not tmp then
120556: LD_VAR 0 5
120560: NOT
120561: IFFALSE 120565
// exit ;
120563: GO 120719
// for i in tmp do
120565: LD_ADDR_VAR 0 1
120569: PUSH
120570: LD_VAR 0 5
120574: PUSH
120575: FOR_IN
120576: IFFALSE 120717
// begin d := rand ( 0 , 5 ) ;
120578: LD_ADDR_VAR 0 4
120582: PUSH
120583: LD_INT 0
120585: PPUSH
120586: LD_INT 5
120588: PPUSH
120589: CALL_OW 12
120593: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
120594: LD_ADDR_VAR 0 2
120598: PUSH
120599: LD_VAR 0 1
120603: PPUSH
120604: CALL_OW 250
120608: PPUSH
120609: LD_VAR 0 4
120613: PPUSH
120614: LD_INT 3
120616: PPUSH
120617: LD_INT 12
120619: PPUSH
120620: CALL_OW 12
120624: PPUSH
120625: CALL_OW 272
120629: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
120630: LD_ADDR_VAR 0 3
120634: PUSH
120635: LD_VAR 0 1
120639: PPUSH
120640: CALL_OW 251
120644: PPUSH
120645: LD_VAR 0 4
120649: PPUSH
120650: LD_INT 3
120652: PPUSH
120653: LD_INT 12
120655: PPUSH
120656: CALL_OW 12
120660: PPUSH
120661: CALL_OW 273
120665: ST_TO_ADDR
// if ValidHex ( x , y ) then
120666: LD_VAR 0 2
120670: PPUSH
120671: LD_VAR 0 3
120675: PPUSH
120676: CALL_OW 488
120680: IFFALSE 120715
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
120682: LD_VAR 0 1
120686: PPUSH
120687: LD_VAR 0 2
120691: PPUSH
120692: LD_VAR 0 3
120696: PPUSH
120697: LD_INT 3
120699: PPUSH
120700: LD_INT 6
120702: PPUSH
120703: CALL_OW 12
120707: PPUSH
120708: LD_INT 1
120710: PPUSH
120711: CALL_OW 483
// end ;
120715: GO 120575
120717: POP
120718: POP
// end ;
120719: PPOPN 5
120721: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
120722: LD_EXP 147
120726: PUSH
120727: LD_EXP 182
120731: AND
120732: IFFALSE 120826
120734: GO 120736
120736: DISABLE
120737: LD_INT 0
120739: PPUSH
120740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
120741: LD_ADDR_VAR 0 2
120745: PUSH
120746: LD_INT 22
120748: PUSH
120749: LD_OWVAR 2
120753: PUSH
120754: EMPTY
120755: LIST
120756: LIST
120757: PUSH
120758: LD_INT 32
120760: PUSH
120761: LD_INT 1
120763: PUSH
120764: EMPTY
120765: LIST
120766: LIST
120767: PUSH
120768: LD_INT 21
120770: PUSH
120771: LD_INT 2
120773: PUSH
120774: EMPTY
120775: LIST
120776: LIST
120777: PUSH
120778: EMPTY
120779: LIST
120780: LIST
120781: LIST
120782: PPUSH
120783: CALL_OW 69
120787: ST_TO_ADDR
// if not tmp then
120788: LD_VAR 0 2
120792: NOT
120793: IFFALSE 120797
// exit ;
120795: GO 120826
// for i in tmp do
120797: LD_ADDR_VAR 0 1
120801: PUSH
120802: LD_VAR 0 2
120806: PUSH
120807: FOR_IN
120808: IFFALSE 120824
// SetFuel ( i , 0 ) ;
120810: LD_VAR 0 1
120814: PPUSH
120815: LD_INT 0
120817: PPUSH
120818: CALL_OW 240
120822: GO 120807
120824: POP
120825: POP
// end ;
120826: PPOPN 2
120828: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
120829: LD_EXP 147
120833: PUSH
120834: LD_EXP 183
120838: AND
120839: IFFALSE 120905
120841: GO 120843
120843: DISABLE
120844: LD_INT 0
120846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120847: LD_ADDR_VAR 0 1
120851: PUSH
120852: LD_INT 22
120854: PUSH
120855: LD_OWVAR 2
120859: PUSH
120860: EMPTY
120861: LIST
120862: LIST
120863: PUSH
120864: LD_INT 30
120866: PUSH
120867: LD_INT 29
120869: PUSH
120870: EMPTY
120871: LIST
120872: LIST
120873: PUSH
120874: EMPTY
120875: LIST
120876: LIST
120877: PPUSH
120878: CALL_OW 69
120882: ST_TO_ADDR
// if not tmp then
120883: LD_VAR 0 1
120887: NOT
120888: IFFALSE 120892
// exit ;
120890: GO 120905
// DestroyUnit ( tmp [ 1 ] ) ;
120892: LD_VAR 0 1
120896: PUSH
120897: LD_INT 1
120899: ARRAY
120900: PPUSH
120901: CALL_OW 65
// end ;
120905: PPOPN 1
120907: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
120908: LD_EXP 147
120912: PUSH
120913: LD_EXP 185
120917: AND
120918: IFFALSE 121047
120920: GO 120922
120922: DISABLE
120923: LD_INT 0
120925: PPUSH
// begin uc_side := 0 ;
120926: LD_ADDR_OWVAR 20
120930: PUSH
120931: LD_INT 0
120933: ST_TO_ADDR
// uc_nation := nation_arabian ;
120934: LD_ADDR_OWVAR 21
120938: PUSH
120939: LD_INT 2
120941: ST_TO_ADDR
// hc_gallery :=  ;
120942: LD_ADDR_OWVAR 33
120946: PUSH
120947: LD_STRING 
120949: ST_TO_ADDR
// hc_name :=  ;
120950: LD_ADDR_OWVAR 26
120954: PUSH
120955: LD_STRING 
120957: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
120958: LD_INT 1
120960: PPUSH
120961: LD_INT 11
120963: PPUSH
120964: LD_INT 10
120966: PPUSH
120967: CALL_OW 380
// un := CreateHuman ;
120971: LD_ADDR_VAR 0 1
120975: PUSH
120976: CALL_OW 44
120980: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120981: LD_VAR 0 1
120985: PPUSH
120986: LD_INT 1
120988: PPUSH
120989: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
120993: LD_INT 35
120995: PPUSH
120996: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121000: LD_VAR 0 1
121004: PPUSH
121005: LD_INT 22
121007: PUSH
121008: LD_OWVAR 2
121012: PUSH
121013: EMPTY
121014: LIST
121015: LIST
121016: PPUSH
121017: CALL_OW 69
121021: PPUSH
121022: LD_VAR 0 1
121026: PPUSH
121027: CALL_OW 74
121031: PPUSH
121032: CALL_OW 115
// until IsDead ( un ) ;
121036: LD_VAR 0 1
121040: PPUSH
121041: CALL_OW 301
121045: IFFALSE 120993
// end ;
121047: PPOPN 1
121049: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
121050: LD_EXP 147
121054: PUSH
121055: LD_EXP 187
121059: AND
121060: IFFALSE 121072
121062: GO 121064
121064: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
121065: LD_STRING earthquake(getX(game), 0, 32)
121067: PPUSH
121068: CALL_OW 559
121072: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
121073: LD_EXP 147
121077: PUSH
121078: LD_EXP 188
121082: AND
121083: IFFALSE 121174
121085: GO 121087
121087: DISABLE
121088: LD_INT 0
121090: PPUSH
// begin enable ;
121091: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
121092: LD_ADDR_VAR 0 1
121096: PUSH
121097: LD_INT 22
121099: PUSH
121100: LD_OWVAR 2
121104: PUSH
121105: EMPTY
121106: LIST
121107: LIST
121108: PUSH
121109: LD_INT 21
121111: PUSH
121112: LD_INT 2
121114: PUSH
121115: EMPTY
121116: LIST
121117: LIST
121118: PUSH
121119: LD_INT 33
121121: PUSH
121122: LD_INT 3
121124: PUSH
121125: EMPTY
121126: LIST
121127: LIST
121128: PUSH
121129: EMPTY
121130: LIST
121131: LIST
121132: LIST
121133: PPUSH
121134: CALL_OW 69
121138: ST_TO_ADDR
// if not tmp then
121139: LD_VAR 0 1
121143: NOT
121144: IFFALSE 121148
// exit ;
121146: GO 121174
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
121148: LD_VAR 0 1
121152: PUSH
121153: LD_INT 1
121155: PPUSH
121156: LD_VAR 0 1
121160: PPUSH
121161: CALL_OW 12
121165: ARRAY
121166: PPUSH
121167: LD_INT 1
121169: PPUSH
121170: CALL_OW 234
// end ;
121174: PPOPN 1
121176: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
121177: LD_EXP 147
121181: PUSH
121182: LD_EXP 189
121186: AND
121187: IFFALSE 121328
121189: GO 121191
121191: DISABLE
121192: LD_INT 0
121194: PPUSH
121195: PPUSH
121196: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121197: LD_ADDR_VAR 0 3
121201: PUSH
121202: LD_INT 22
121204: PUSH
121205: LD_OWVAR 2
121209: PUSH
121210: EMPTY
121211: LIST
121212: LIST
121213: PUSH
121214: LD_INT 25
121216: PUSH
121217: LD_INT 1
121219: PUSH
121220: EMPTY
121221: LIST
121222: LIST
121223: PUSH
121224: EMPTY
121225: LIST
121226: LIST
121227: PPUSH
121228: CALL_OW 69
121232: ST_TO_ADDR
// if not tmp then
121233: LD_VAR 0 3
121237: NOT
121238: IFFALSE 121242
// exit ;
121240: GO 121328
// un := tmp [ rand ( 1 , tmp ) ] ;
121242: LD_ADDR_VAR 0 2
121246: PUSH
121247: LD_VAR 0 3
121251: PUSH
121252: LD_INT 1
121254: PPUSH
121255: LD_VAR 0 3
121259: PPUSH
121260: CALL_OW 12
121264: ARRAY
121265: ST_TO_ADDR
// if Crawls ( un ) then
121266: LD_VAR 0 2
121270: PPUSH
121271: CALL_OW 318
121275: IFFALSE 121286
// ComWalk ( un ) ;
121277: LD_VAR 0 2
121281: PPUSH
121282: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
121286: LD_VAR 0 2
121290: PPUSH
121291: LD_INT 9
121293: PPUSH
121294: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
121298: LD_INT 28
121300: PPUSH
121301: LD_OWVAR 2
121305: PPUSH
121306: LD_INT 2
121308: PPUSH
121309: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
121313: LD_INT 29
121315: PPUSH
121316: LD_OWVAR 2
121320: PPUSH
121321: LD_INT 2
121323: PPUSH
121324: CALL_OW 322
// end ;
121328: PPOPN 3
121330: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
121331: LD_EXP 147
121335: PUSH
121336: LD_EXP 190
121340: AND
121341: IFFALSE 121452
121343: GO 121345
121345: DISABLE
121346: LD_INT 0
121348: PPUSH
121349: PPUSH
121350: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121351: LD_ADDR_VAR 0 3
121355: PUSH
121356: LD_INT 22
121358: PUSH
121359: LD_OWVAR 2
121363: PUSH
121364: EMPTY
121365: LIST
121366: LIST
121367: PUSH
121368: LD_INT 25
121370: PUSH
121371: LD_INT 1
121373: PUSH
121374: EMPTY
121375: LIST
121376: LIST
121377: PUSH
121378: EMPTY
121379: LIST
121380: LIST
121381: PPUSH
121382: CALL_OW 69
121386: ST_TO_ADDR
// if not tmp then
121387: LD_VAR 0 3
121391: NOT
121392: IFFALSE 121396
// exit ;
121394: GO 121452
// un := tmp [ rand ( 1 , tmp ) ] ;
121396: LD_ADDR_VAR 0 2
121400: PUSH
121401: LD_VAR 0 3
121405: PUSH
121406: LD_INT 1
121408: PPUSH
121409: LD_VAR 0 3
121413: PPUSH
121414: CALL_OW 12
121418: ARRAY
121419: ST_TO_ADDR
// if Crawls ( un ) then
121420: LD_VAR 0 2
121424: PPUSH
121425: CALL_OW 318
121429: IFFALSE 121440
// ComWalk ( un ) ;
121431: LD_VAR 0 2
121435: PPUSH
121436: CALL_OW 138
// SetClass ( un , class_mortar ) ;
121440: LD_VAR 0 2
121444: PPUSH
121445: LD_INT 8
121447: PPUSH
121448: CALL_OW 336
// end ;
121452: PPOPN 3
121454: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
121455: LD_EXP 147
121459: PUSH
121460: LD_EXP 191
121464: AND
121465: IFFALSE 121609
121467: GO 121469
121469: DISABLE
121470: LD_INT 0
121472: PPUSH
121473: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
121474: LD_ADDR_VAR 0 2
121478: PUSH
121479: LD_INT 22
121481: PUSH
121482: LD_OWVAR 2
121486: PUSH
121487: EMPTY
121488: LIST
121489: LIST
121490: PUSH
121491: LD_INT 21
121493: PUSH
121494: LD_INT 2
121496: PUSH
121497: EMPTY
121498: LIST
121499: LIST
121500: PUSH
121501: LD_INT 2
121503: PUSH
121504: LD_INT 34
121506: PUSH
121507: LD_INT 12
121509: PUSH
121510: EMPTY
121511: LIST
121512: LIST
121513: PUSH
121514: LD_INT 34
121516: PUSH
121517: LD_INT 51
121519: PUSH
121520: EMPTY
121521: LIST
121522: LIST
121523: PUSH
121524: LD_INT 34
121526: PUSH
121527: LD_INT 32
121529: PUSH
121530: EMPTY
121531: LIST
121532: LIST
121533: PUSH
121534: EMPTY
121535: LIST
121536: LIST
121537: LIST
121538: LIST
121539: PUSH
121540: EMPTY
121541: LIST
121542: LIST
121543: LIST
121544: PPUSH
121545: CALL_OW 69
121549: ST_TO_ADDR
// if not tmp then
121550: LD_VAR 0 2
121554: NOT
121555: IFFALSE 121559
// exit ;
121557: GO 121609
// for i in tmp do
121559: LD_ADDR_VAR 0 1
121563: PUSH
121564: LD_VAR 0 2
121568: PUSH
121569: FOR_IN
121570: IFFALSE 121607
// if GetCargo ( i , mat_artifact ) = 0 then
121572: LD_VAR 0 1
121576: PPUSH
121577: LD_INT 4
121579: PPUSH
121580: CALL_OW 289
121584: PUSH
121585: LD_INT 0
121587: EQUAL
121588: IFFALSE 121605
// SetCargo ( i , mat_siberit , 100 ) ;
121590: LD_VAR 0 1
121594: PPUSH
121595: LD_INT 3
121597: PPUSH
121598: LD_INT 100
121600: PPUSH
121601: CALL_OW 290
121605: GO 121569
121607: POP
121608: POP
// end ;
121609: PPOPN 2
121611: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
121612: LD_EXP 147
121616: PUSH
121617: LD_EXP 192
121621: AND
121622: IFFALSE 121805
121624: GO 121626
121626: DISABLE
121627: LD_INT 0
121629: PPUSH
121630: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121631: LD_ADDR_VAR 0 2
121635: PUSH
121636: LD_INT 22
121638: PUSH
121639: LD_OWVAR 2
121643: PUSH
121644: EMPTY
121645: LIST
121646: LIST
121647: PPUSH
121648: CALL_OW 69
121652: ST_TO_ADDR
// if not tmp then
121653: LD_VAR 0 2
121657: NOT
121658: IFFALSE 121662
// exit ;
121660: GO 121805
// for i := 1 to 2 do
121662: LD_ADDR_VAR 0 1
121666: PUSH
121667: DOUBLE
121668: LD_INT 1
121670: DEC
121671: ST_TO_ADDR
121672: LD_INT 2
121674: PUSH
121675: FOR_TO
121676: IFFALSE 121803
// begin uc_side := your_side ;
121678: LD_ADDR_OWVAR 20
121682: PUSH
121683: LD_OWVAR 2
121687: ST_TO_ADDR
// uc_nation := nation_american ;
121688: LD_ADDR_OWVAR 21
121692: PUSH
121693: LD_INT 1
121695: ST_TO_ADDR
// vc_chassis := us_morphling ;
121696: LD_ADDR_OWVAR 37
121700: PUSH
121701: LD_INT 5
121703: ST_TO_ADDR
// vc_engine := engine_siberite ;
121704: LD_ADDR_OWVAR 39
121708: PUSH
121709: LD_INT 3
121711: ST_TO_ADDR
// vc_control := control_computer ;
121712: LD_ADDR_OWVAR 38
121716: PUSH
121717: LD_INT 3
121719: ST_TO_ADDR
// vc_weapon := us_double_laser ;
121720: LD_ADDR_OWVAR 40
121724: PUSH
121725: LD_INT 10
121727: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
121728: LD_VAR 0 2
121732: PUSH
121733: LD_INT 1
121735: ARRAY
121736: PPUSH
121737: CALL_OW 310
121741: NOT
121742: IFFALSE 121789
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
121744: CALL_OW 45
121748: PPUSH
121749: LD_VAR 0 2
121753: PUSH
121754: LD_INT 1
121756: ARRAY
121757: PPUSH
121758: CALL_OW 250
121762: PPUSH
121763: LD_VAR 0 2
121767: PUSH
121768: LD_INT 1
121770: ARRAY
121771: PPUSH
121772: CALL_OW 251
121776: PPUSH
121777: LD_INT 12
121779: PPUSH
121780: LD_INT 1
121782: PPUSH
121783: CALL_OW 50
121787: GO 121801
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
121789: CALL_OW 45
121793: PPUSH
121794: LD_INT 1
121796: PPUSH
121797: CALL_OW 51
// end ;
121801: GO 121675
121803: POP
121804: POP
// end ;
121805: PPOPN 2
121807: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
121808: LD_EXP 147
121812: PUSH
121813: LD_EXP 193
121817: AND
121818: IFFALSE 122040
121820: GO 121822
121822: DISABLE
121823: LD_INT 0
121825: PPUSH
121826: PPUSH
121827: PPUSH
121828: PPUSH
121829: PPUSH
121830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121831: LD_ADDR_VAR 0 6
121835: PUSH
121836: LD_INT 22
121838: PUSH
121839: LD_OWVAR 2
121843: PUSH
121844: EMPTY
121845: LIST
121846: LIST
121847: PUSH
121848: LD_INT 21
121850: PUSH
121851: LD_INT 1
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: PUSH
121858: LD_INT 3
121860: PUSH
121861: LD_INT 23
121863: PUSH
121864: LD_INT 0
121866: PUSH
121867: EMPTY
121868: LIST
121869: LIST
121870: PUSH
121871: EMPTY
121872: LIST
121873: LIST
121874: PUSH
121875: EMPTY
121876: LIST
121877: LIST
121878: LIST
121879: PPUSH
121880: CALL_OW 69
121884: ST_TO_ADDR
// if not tmp then
121885: LD_VAR 0 6
121889: NOT
121890: IFFALSE 121894
// exit ;
121892: GO 122040
// s1 := rand ( 1 , 4 ) ;
121894: LD_ADDR_VAR 0 2
121898: PUSH
121899: LD_INT 1
121901: PPUSH
121902: LD_INT 4
121904: PPUSH
121905: CALL_OW 12
121909: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
121910: LD_ADDR_VAR 0 4
121914: PUSH
121915: LD_VAR 0 6
121919: PUSH
121920: LD_INT 1
121922: ARRAY
121923: PPUSH
121924: LD_VAR 0 2
121928: PPUSH
121929: CALL_OW 259
121933: ST_TO_ADDR
// if s1 = 1 then
121934: LD_VAR 0 2
121938: PUSH
121939: LD_INT 1
121941: EQUAL
121942: IFFALSE 121962
// s2 := rand ( 2 , 4 ) else
121944: LD_ADDR_VAR 0 3
121948: PUSH
121949: LD_INT 2
121951: PPUSH
121952: LD_INT 4
121954: PPUSH
121955: CALL_OW 12
121959: ST_TO_ADDR
121960: GO 121970
// s2 := 1 ;
121962: LD_ADDR_VAR 0 3
121966: PUSH
121967: LD_INT 1
121969: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
121970: LD_ADDR_VAR 0 5
121974: PUSH
121975: LD_VAR 0 6
121979: PUSH
121980: LD_INT 1
121982: ARRAY
121983: PPUSH
121984: LD_VAR 0 3
121988: PPUSH
121989: CALL_OW 259
121993: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
121994: LD_VAR 0 6
121998: PUSH
121999: LD_INT 1
122001: ARRAY
122002: PPUSH
122003: LD_VAR 0 2
122007: PPUSH
122008: LD_VAR 0 5
122012: PPUSH
122013: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
122017: LD_VAR 0 6
122021: PUSH
122022: LD_INT 1
122024: ARRAY
122025: PPUSH
122026: LD_VAR 0 3
122030: PPUSH
122031: LD_VAR 0 4
122035: PPUSH
122036: CALL_OW 237
// end ;
122040: PPOPN 6
122042: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
122043: LD_EXP 147
122047: PUSH
122048: LD_EXP 194
122052: AND
122053: IFFALSE 122132
122055: GO 122057
122057: DISABLE
122058: LD_INT 0
122060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
122061: LD_ADDR_VAR 0 1
122065: PUSH
122066: LD_INT 22
122068: PUSH
122069: LD_OWVAR 2
122073: PUSH
122074: EMPTY
122075: LIST
122076: LIST
122077: PUSH
122078: LD_INT 30
122080: PUSH
122081: LD_INT 3
122083: PUSH
122084: EMPTY
122085: LIST
122086: LIST
122087: PUSH
122088: EMPTY
122089: LIST
122090: LIST
122091: PPUSH
122092: CALL_OW 69
122096: ST_TO_ADDR
// if not tmp then
122097: LD_VAR 0 1
122101: NOT
122102: IFFALSE 122106
// exit ;
122104: GO 122132
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122106: LD_VAR 0 1
122110: PUSH
122111: LD_INT 1
122113: PPUSH
122114: LD_VAR 0 1
122118: PPUSH
122119: CALL_OW 12
122123: ARRAY
122124: PPUSH
122125: LD_INT 1
122127: PPUSH
122128: CALL_OW 234
// end ;
122132: PPOPN 1
122134: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
122135: LD_EXP 147
122139: PUSH
122140: LD_EXP 195
122144: AND
122145: IFFALSE 122257
122147: GO 122149
122149: DISABLE
122150: LD_INT 0
122152: PPUSH
122153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
122154: LD_ADDR_VAR 0 2
122158: PUSH
122159: LD_INT 22
122161: PUSH
122162: LD_OWVAR 2
122166: PUSH
122167: EMPTY
122168: LIST
122169: LIST
122170: PUSH
122171: LD_INT 2
122173: PUSH
122174: LD_INT 30
122176: PUSH
122177: LD_INT 27
122179: PUSH
122180: EMPTY
122181: LIST
122182: LIST
122183: PUSH
122184: LD_INT 30
122186: PUSH
122187: LD_INT 26
122189: PUSH
122190: EMPTY
122191: LIST
122192: LIST
122193: PUSH
122194: LD_INT 30
122196: PUSH
122197: LD_INT 28
122199: PUSH
122200: EMPTY
122201: LIST
122202: LIST
122203: PUSH
122204: EMPTY
122205: LIST
122206: LIST
122207: LIST
122208: LIST
122209: PUSH
122210: EMPTY
122211: LIST
122212: LIST
122213: PPUSH
122214: CALL_OW 69
122218: ST_TO_ADDR
// if not tmp then
122219: LD_VAR 0 2
122223: NOT
122224: IFFALSE 122228
// exit ;
122226: GO 122257
// for i in tmp do
122228: LD_ADDR_VAR 0 1
122232: PUSH
122233: LD_VAR 0 2
122237: PUSH
122238: FOR_IN
122239: IFFALSE 122255
// SetLives ( i , 1 ) ;
122241: LD_VAR 0 1
122245: PPUSH
122246: LD_INT 1
122248: PPUSH
122249: CALL_OW 234
122253: GO 122238
122255: POP
122256: POP
// end ;
122257: PPOPN 2
122259: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
122260: LD_EXP 147
122264: PUSH
122265: LD_EXP 196
122269: AND
122270: IFFALSE 122557
122272: GO 122274
122274: DISABLE
122275: LD_INT 0
122277: PPUSH
122278: PPUSH
122279: PPUSH
// begin i := rand ( 1 , 7 ) ;
122280: LD_ADDR_VAR 0 1
122284: PUSH
122285: LD_INT 1
122287: PPUSH
122288: LD_INT 7
122290: PPUSH
122291: CALL_OW 12
122295: ST_TO_ADDR
// case i of 1 :
122296: LD_VAR 0 1
122300: PUSH
122301: LD_INT 1
122303: DOUBLE
122304: EQUAL
122305: IFTRUE 122309
122307: GO 122319
122309: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
122310: LD_STRING earthquake(getX(game), 0, 32)
122312: PPUSH
122313: CALL_OW 559
122317: GO 122557
122319: LD_INT 2
122321: DOUBLE
122322: EQUAL
122323: IFTRUE 122327
122325: GO 122341
122327: POP
// begin ToLua ( displayStucuk(); ) ;
122328: LD_STRING displayStucuk();
122330: PPUSH
122331: CALL_OW 559
// ResetFog ;
122335: CALL_OW 335
// end ; 3 :
122339: GO 122557
122341: LD_INT 3
122343: DOUBLE
122344: EQUAL
122345: IFTRUE 122349
122347: GO 122453
122349: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122350: LD_ADDR_VAR 0 2
122354: PUSH
122355: LD_INT 22
122357: PUSH
122358: LD_OWVAR 2
122362: PUSH
122363: EMPTY
122364: LIST
122365: LIST
122366: PUSH
122367: LD_INT 25
122369: PUSH
122370: LD_INT 1
122372: PUSH
122373: EMPTY
122374: LIST
122375: LIST
122376: PUSH
122377: EMPTY
122378: LIST
122379: LIST
122380: PPUSH
122381: CALL_OW 69
122385: ST_TO_ADDR
// if not tmp then
122386: LD_VAR 0 2
122390: NOT
122391: IFFALSE 122395
// exit ;
122393: GO 122557
// un := tmp [ rand ( 1 , tmp ) ] ;
122395: LD_ADDR_VAR 0 3
122399: PUSH
122400: LD_VAR 0 2
122404: PUSH
122405: LD_INT 1
122407: PPUSH
122408: LD_VAR 0 2
122412: PPUSH
122413: CALL_OW 12
122417: ARRAY
122418: ST_TO_ADDR
// if Crawls ( un ) then
122419: LD_VAR 0 3
122423: PPUSH
122424: CALL_OW 318
122428: IFFALSE 122439
// ComWalk ( un ) ;
122430: LD_VAR 0 3
122434: PPUSH
122435: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122439: LD_VAR 0 3
122443: PPUSH
122444: LD_INT 8
122446: PPUSH
122447: CALL_OW 336
// end ; 4 :
122451: GO 122557
122453: LD_INT 4
122455: DOUBLE
122456: EQUAL
122457: IFTRUE 122461
122459: GO 122535
122461: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122462: LD_ADDR_VAR 0 2
122466: PUSH
122467: LD_INT 22
122469: PUSH
122470: LD_OWVAR 2
122474: PUSH
122475: EMPTY
122476: LIST
122477: LIST
122478: PUSH
122479: LD_INT 30
122481: PUSH
122482: LD_INT 29
122484: PUSH
122485: EMPTY
122486: LIST
122487: LIST
122488: PUSH
122489: EMPTY
122490: LIST
122491: LIST
122492: PPUSH
122493: CALL_OW 69
122497: ST_TO_ADDR
// if not tmp then
122498: LD_VAR 0 2
122502: NOT
122503: IFFALSE 122507
// exit ;
122505: GO 122557
// CenterNowOnUnits ( tmp [ 1 ] ) ;
122507: LD_VAR 0 2
122511: PUSH
122512: LD_INT 1
122514: ARRAY
122515: PPUSH
122516: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
122520: LD_VAR 0 2
122524: PUSH
122525: LD_INT 1
122527: ARRAY
122528: PPUSH
122529: CALL_OW 65
// end ; 5 .. 7 :
122533: GO 122557
122535: LD_INT 5
122537: DOUBLE
122538: GREATEREQUAL
122539: IFFALSE 122547
122541: LD_INT 7
122543: DOUBLE
122544: LESSEQUAL
122545: IFTRUE 122549
122547: GO 122556
122549: POP
// StreamSibBomb ; end ;
122550: CALL 118794 0 0
122554: GO 122557
122556: POP
// end ;
122557: PPOPN 3
122559: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
122560: LD_EXP 147
122564: PUSH
122565: LD_EXP 197
122569: AND
122570: IFFALSE 122726
122572: GO 122574
122574: DISABLE
122575: LD_INT 0
122577: PPUSH
122578: PPUSH
122579: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
122580: LD_ADDR_VAR 0 2
122584: PUSH
122585: LD_INT 81
122587: PUSH
122588: LD_OWVAR 2
122592: PUSH
122593: EMPTY
122594: LIST
122595: LIST
122596: PUSH
122597: LD_INT 2
122599: PUSH
122600: LD_INT 21
122602: PUSH
122603: LD_INT 1
122605: PUSH
122606: EMPTY
122607: LIST
122608: LIST
122609: PUSH
122610: LD_INT 21
122612: PUSH
122613: LD_INT 2
122615: PUSH
122616: EMPTY
122617: LIST
122618: LIST
122619: PUSH
122620: EMPTY
122621: LIST
122622: LIST
122623: LIST
122624: PUSH
122625: EMPTY
122626: LIST
122627: LIST
122628: PPUSH
122629: CALL_OW 69
122633: ST_TO_ADDR
// if not tmp then
122634: LD_VAR 0 2
122638: NOT
122639: IFFALSE 122643
// exit ;
122641: GO 122726
// p := 0 ;
122643: LD_ADDR_VAR 0 3
122647: PUSH
122648: LD_INT 0
122650: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
122651: LD_INT 35
122653: PPUSH
122654: CALL_OW 67
// p := p + 1 ;
122658: LD_ADDR_VAR 0 3
122662: PUSH
122663: LD_VAR 0 3
122667: PUSH
122668: LD_INT 1
122670: PLUS
122671: ST_TO_ADDR
// for i in tmp do
122672: LD_ADDR_VAR 0 1
122676: PUSH
122677: LD_VAR 0 2
122681: PUSH
122682: FOR_IN
122683: IFFALSE 122714
// if GetLives ( i ) < 1000 then
122685: LD_VAR 0 1
122689: PPUSH
122690: CALL_OW 256
122694: PUSH
122695: LD_INT 1000
122697: LESS
122698: IFFALSE 122712
// SetLives ( i , 1000 ) ;
122700: LD_VAR 0 1
122704: PPUSH
122705: LD_INT 1000
122707: PPUSH
122708: CALL_OW 234
122712: GO 122682
122714: POP
122715: POP
// until p > 20 ;
122716: LD_VAR 0 3
122720: PUSH
122721: LD_INT 20
122723: GREATER
122724: IFFALSE 122651
// end ;
122726: PPOPN 3
122728: END
// every 0 0$1 trigger StreamModeActive and sTime do
122729: LD_EXP 147
122733: PUSH
122734: LD_EXP 198
122738: AND
122739: IFFALSE 122774
122741: GO 122743
122743: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
122744: LD_INT 28
122746: PPUSH
122747: LD_OWVAR 2
122751: PPUSH
122752: LD_INT 2
122754: PPUSH
122755: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
122759: LD_INT 30
122761: PPUSH
122762: LD_OWVAR 2
122766: PPUSH
122767: LD_INT 2
122769: PPUSH
122770: CALL_OW 322
// end ;
122774: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
122775: LD_EXP 147
122779: PUSH
122780: LD_EXP 199
122784: AND
122785: IFFALSE 122906
122787: GO 122789
122789: DISABLE
122790: LD_INT 0
122792: PPUSH
122793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
122794: LD_ADDR_VAR 0 2
122798: PUSH
122799: LD_INT 22
122801: PUSH
122802: LD_OWVAR 2
122806: PUSH
122807: EMPTY
122808: LIST
122809: LIST
122810: PUSH
122811: LD_INT 21
122813: PUSH
122814: LD_INT 1
122816: PUSH
122817: EMPTY
122818: LIST
122819: LIST
122820: PUSH
122821: LD_INT 3
122823: PUSH
122824: LD_INT 23
122826: PUSH
122827: LD_INT 0
122829: PUSH
122830: EMPTY
122831: LIST
122832: LIST
122833: PUSH
122834: EMPTY
122835: LIST
122836: LIST
122837: PUSH
122838: EMPTY
122839: LIST
122840: LIST
122841: LIST
122842: PPUSH
122843: CALL_OW 69
122847: ST_TO_ADDR
// if not tmp then
122848: LD_VAR 0 2
122852: NOT
122853: IFFALSE 122857
// exit ;
122855: GO 122906
// for i in tmp do
122857: LD_ADDR_VAR 0 1
122861: PUSH
122862: LD_VAR 0 2
122866: PUSH
122867: FOR_IN
122868: IFFALSE 122904
// begin if Crawls ( i ) then
122870: LD_VAR 0 1
122874: PPUSH
122875: CALL_OW 318
122879: IFFALSE 122890
// ComWalk ( i ) ;
122881: LD_VAR 0 1
122885: PPUSH
122886: CALL_OW 138
// SetClass ( i , 2 ) ;
122890: LD_VAR 0 1
122894: PPUSH
122895: LD_INT 2
122897: PPUSH
122898: CALL_OW 336
// end ;
122902: GO 122867
122904: POP
122905: POP
// end ;
122906: PPOPN 2
122908: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
122909: LD_EXP 147
122913: PUSH
122914: LD_EXP 200
122918: AND
122919: IFFALSE 123207
122921: GO 122923
122923: DISABLE
122924: LD_INT 0
122926: PPUSH
122927: PPUSH
122928: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
122929: LD_OWVAR 2
122933: PPUSH
122934: LD_INT 9
122936: PPUSH
122937: LD_INT 1
122939: PPUSH
122940: LD_INT 1
122942: PPUSH
122943: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
122947: LD_INT 9
122949: PPUSH
122950: LD_OWVAR 2
122954: PPUSH
122955: CALL_OW 343
// uc_side := 9 ;
122959: LD_ADDR_OWVAR 20
122963: PUSH
122964: LD_INT 9
122966: ST_TO_ADDR
// uc_nation := 2 ;
122967: LD_ADDR_OWVAR 21
122971: PUSH
122972: LD_INT 2
122974: ST_TO_ADDR
// hc_name := Dark Warrior ;
122975: LD_ADDR_OWVAR 26
122979: PUSH
122980: LD_STRING Dark Warrior
122982: ST_TO_ADDR
// hc_gallery :=  ;
122983: LD_ADDR_OWVAR 33
122987: PUSH
122988: LD_STRING 
122990: ST_TO_ADDR
// hc_noskilllimit := true ;
122991: LD_ADDR_OWVAR 76
122995: PUSH
122996: LD_INT 1
122998: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
122999: LD_ADDR_OWVAR 31
123003: PUSH
123004: LD_INT 30
123006: PUSH
123007: LD_INT 30
123009: PUSH
123010: LD_INT 30
123012: PUSH
123013: LD_INT 30
123015: PUSH
123016: EMPTY
123017: LIST
123018: LIST
123019: LIST
123020: LIST
123021: ST_TO_ADDR
// un := CreateHuman ;
123022: LD_ADDR_VAR 0 3
123026: PUSH
123027: CALL_OW 44
123031: ST_TO_ADDR
// hc_noskilllimit := false ;
123032: LD_ADDR_OWVAR 76
123036: PUSH
123037: LD_INT 0
123039: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123040: LD_VAR 0 3
123044: PPUSH
123045: LD_INT 1
123047: PPUSH
123048: CALL_OW 51
// ToLua ( playRanger() ) ;
123052: LD_STRING playRanger()
123054: PPUSH
123055: CALL_OW 559
// p := 0 ;
123059: LD_ADDR_VAR 0 2
123063: PUSH
123064: LD_INT 0
123066: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
123067: LD_INT 35
123069: PPUSH
123070: CALL_OW 67
// p := p + 1 ;
123074: LD_ADDR_VAR 0 2
123078: PUSH
123079: LD_VAR 0 2
123083: PUSH
123084: LD_INT 1
123086: PLUS
123087: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
123088: LD_VAR 0 3
123092: PPUSH
123093: CALL_OW 256
123097: PUSH
123098: LD_INT 1000
123100: LESS
123101: IFFALSE 123115
// SetLives ( un , 1000 ) ;
123103: LD_VAR 0 3
123107: PPUSH
123108: LD_INT 1000
123110: PPUSH
123111: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
123115: LD_VAR 0 3
123119: PPUSH
123120: LD_INT 81
123122: PUSH
123123: LD_OWVAR 2
123127: PUSH
123128: EMPTY
123129: LIST
123130: LIST
123131: PUSH
123132: LD_INT 91
123134: PUSH
123135: LD_VAR 0 3
123139: PUSH
123140: LD_INT 30
123142: PUSH
123143: EMPTY
123144: LIST
123145: LIST
123146: LIST
123147: PUSH
123148: EMPTY
123149: LIST
123150: LIST
123151: PPUSH
123152: CALL_OW 69
123156: PPUSH
123157: LD_VAR 0 3
123161: PPUSH
123162: CALL_OW 74
123166: PPUSH
123167: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
123171: LD_VAR 0 2
123175: PUSH
123176: LD_INT 80
123178: GREATER
123179: PUSH
123180: LD_VAR 0 3
123184: PPUSH
123185: CALL_OW 301
123189: OR
123190: IFFALSE 123067
// if un then
123192: LD_VAR 0 3
123196: IFFALSE 123207
// RemoveUnit ( un ) ;
123198: LD_VAR 0 3
123202: PPUSH
123203: CALL_OW 64
// end ;
123207: PPOPN 3
123209: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
123210: LD_EXP 201
123214: IFFALSE 123330
123216: GO 123218
123218: DISABLE
123219: LD_INT 0
123221: PPUSH
123222: PPUSH
123223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
123224: LD_ADDR_VAR 0 2
123228: PUSH
123229: LD_INT 81
123231: PUSH
123232: LD_OWVAR 2
123236: PUSH
123237: EMPTY
123238: LIST
123239: LIST
123240: PUSH
123241: LD_INT 21
123243: PUSH
123244: LD_INT 1
123246: PUSH
123247: EMPTY
123248: LIST
123249: LIST
123250: PUSH
123251: EMPTY
123252: LIST
123253: LIST
123254: PPUSH
123255: CALL_OW 69
123259: ST_TO_ADDR
// ToLua ( playComputer() ) ;
123260: LD_STRING playComputer()
123262: PPUSH
123263: CALL_OW 559
// if not tmp then
123267: LD_VAR 0 2
123271: NOT
123272: IFFALSE 123276
// exit ;
123274: GO 123330
// for i in tmp do
123276: LD_ADDR_VAR 0 1
123280: PUSH
123281: LD_VAR 0 2
123285: PUSH
123286: FOR_IN
123287: IFFALSE 123328
// for j := 1 to 4 do
123289: LD_ADDR_VAR 0 3
123293: PUSH
123294: DOUBLE
123295: LD_INT 1
123297: DEC
123298: ST_TO_ADDR
123299: LD_INT 4
123301: PUSH
123302: FOR_TO
123303: IFFALSE 123324
// SetSkill ( i , j , 10 ) ;
123305: LD_VAR 0 1
123309: PPUSH
123310: LD_VAR 0 3
123314: PPUSH
123315: LD_INT 10
123317: PPUSH
123318: CALL_OW 237
123322: GO 123302
123324: POP
123325: POP
123326: GO 123286
123328: POP
123329: POP
// end ;
123330: PPOPN 3
123332: END
// every 0 0$1 trigger s30 do var i , tmp ;
123333: LD_EXP 202
123337: IFFALSE 123406
123339: GO 123341
123341: DISABLE
123342: LD_INT 0
123344: PPUSH
123345: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123346: LD_ADDR_VAR 0 2
123350: PUSH
123351: LD_INT 22
123353: PUSH
123354: LD_OWVAR 2
123358: PUSH
123359: EMPTY
123360: LIST
123361: LIST
123362: PPUSH
123363: CALL_OW 69
123367: ST_TO_ADDR
// if not tmp then
123368: LD_VAR 0 2
123372: NOT
123373: IFFALSE 123377
// exit ;
123375: GO 123406
// for i in tmp do
123377: LD_ADDR_VAR 0 1
123381: PUSH
123382: LD_VAR 0 2
123386: PUSH
123387: FOR_IN
123388: IFFALSE 123404
// SetLives ( i , 300 ) ;
123390: LD_VAR 0 1
123394: PPUSH
123395: LD_INT 300
123397: PPUSH
123398: CALL_OW 234
123402: GO 123387
123404: POP
123405: POP
// end ;
123406: PPOPN 2
123408: END
// every 0 0$1 trigger s60 do var i , tmp ;
123409: LD_EXP 203
123413: IFFALSE 123482
123415: GO 123417
123417: DISABLE
123418: LD_INT 0
123420: PPUSH
123421: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123422: LD_ADDR_VAR 0 2
123426: PUSH
123427: LD_INT 22
123429: PUSH
123430: LD_OWVAR 2
123434: PUSH
123435: EMPTY
123436: LIST
123437: LIST
123438: PPUSH
123439: CALL_OW 69
123443: ST_TO_ADDR
// if not tmp then
123444: LD_VAR 0 2
123448: NOT
123449: IFFALSE 123453
// exit ;
123451: GO 123482
// for i in tmp do
123453: LD_ADDR_VAR 0 1
123457: PUSH
123458: LD_VAR 0 2
123462: PUSH
123463: FOR_IN
123464: IFFALSE 123480
// SetLives ( i , 600 ) ;
123466: LD_VAR 0 1
123470: PPUSH
123471: LD_INT 600
123473: PPUSH
123474: CALL_OW 234
123478: GO 123463
123480: POP
123481: POP
// end ;
123482: PPOPN 2
123484: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
123485: LD_INT 0
123487: PPUSH
// case cmd of 301 :
123488: LD_VAR 0 1
123492: PUSH
123493: LD_INT 301
123495: DOUBLE
123496: EQUAL
123497: IFTRUE 123501
123499: GO 123533
123501: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
123502: LD_VAR 0 6
123506: PPUSH
123507: LD_VAR 0 7
123511: PPUSH
123512: LD_VAR 0 8
123516: PPUSH
123517: LD_VAR 0 4
123521: PPUSH
123522: LD_VAR 0 5
123526: PPUSH
123527: CALL 124742 0 5
123531: GO 123654
123533: LD_INT 302
123535: DOUBLE
123536: EQUAL
123537: IFTRUE 123541
123539: GO 123578
123541: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
123542: LD_VAR 0 6
123546: PPUSH
123547: LD_VAR 0 7
123551: PPUSH
123552: LD_VAR 0 8
123556: PPUSH
123557: LD_VAR 0 9
123561: PPUSH
123562: LD_VAR 0 4
123566: PPUSH
123567: LD_VAR 0 5
123571: PPUSH
123572: CALL 124833 0 6
123576: GO 123654
123578: LD_INT 303
123580: DOUBLE
123581: EQUAL
123582: IFTRUE 123586
123584: GO 123623
123586: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
123587: LD_VAR 0 6
123591: PPUSH
123592: LD_VAR 0 7
123596: PPUSH
123597: LD_VAR 0 8
123601: PPUSH
123602: LD_VAR 0 9
123606: PPUSH
123607: LD_VAR 0 4
123611: PPUSH
123612: LD_VAR 0 5
123616: PPUSH
123617: CALL 123659 0 6
123621: GO 123654
123623: LD_INT 304
123625: DOUBLE
123626: EQUAL
123627: IFTRUE 123631
123629: GO 123653
123631: POP
// hHackTeleport ( unit , x , y ) ; end ;
123632: LD_VAR 0 2
123636: PPUSH
123637: LD_VAR 0 4
123641: PPUSH
123642: LD_VAR 0 5
123646: PPUSH
123647: CALL 125426 0 3
123651: GO 123654
123653: POP
// end ;
123654: LD_VAR 0 12
123658: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
123659: LD_INT 0
123661: PPUSH
123662: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
123663: LD_VAR 0 1
123667: PUSH
123668: LD_INT 1
123670: LESS
123671: PUSH
123672: LD_VAR 0 1
123676: PUSH
123677: LD_INT 3
123679: GREATER
123680: OR
123681: PUSH
123682: LD_VAR 0 5
123686: PPUSH
123687: LD_VAR 0 6
123691: PPUSH
123692: CALL_OW 428
123696: OR
123697: IFFALSE 123701
// exit ;
123699: GO 124429
// uc_side := your_side ;
123701: LD_ADDR_OWVAR 20
123705: PUSH
123706: LD_OWVAR 2
123710: ST_TO_ADDR
// uc_nation := nation ;
123711: LD_ADDR_OWVAR 21
123715: PUSH
123716: LD_VAR 0 1
123720: ST_TO_ADDR
// bc_level = 1 ;
123721: LD_ADDR_OWVAR 43
123725: PUSH
123726: LD_INT 1
123728: ST_TO_ADDR
// case btype of 1 :
123729: LD_VAR 0 2
123733: PUSH
123734: LD_INT 1
123736: DOUBLE
123737: EQUAL
123738: IFTRUE 123742
123740: GO 123753
123742: POP
// bc_type := b_depot ; 2 :
123743: LD_ADDR_OWVAR 42
123747: PUSH
123748: LD_INT 0
123750: ST_TO_ADDR
123751: GO 124373
123753: LD_INT 2
123755: DOUBLE
123756: EQUAL
123757: IFTRUE 123761
123759: GO 123772
123761: POP
// bc_type := b_warehouse ; 3 :
123762: LD_ADDR_OWVAR 42
123766: PUSH
123767: LD_INT 1
123769: ST_TO_ADDR
123770: GO 124373
123772: LD_INT 3
123774: DOUBLE
123775: EQUAL
123776: IFTRUE 123780
123778: GO 123791
123780: POP
// bc_type := b_lab ; 4 .. 9 :
123781: LD_ADDR_OWVAR 42
123785: PUSH
123786: LD_INT 6
123788: ST_TO_ADDR
123789: GO 124373
123791: LD_INT 4
123793: DOUBLE
123794: GREATEREQUAL
123795: IFFALSE 123803
123797: LD_INT 9
123799: DOUBLE
123800: LESSEQUAL
123801: IFTRUE 123805
123803: GO 123865
123805: POP
// begin bc_type := b_lab_half ;
123806: LD_ADDR_OWVAR 42
123810: PUSH
123811: LD_INT 7
123813: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
123814: LD_ADDR_OWVAR 44
123818: PUSH
123819: LD_INT 10
123821: PUSH
123822: LD_INT 11
123824: PUSH
123825: LD_INT 12
123827: PUSH
123828: LD_INT 15
123830: PUSH
123831: LD_INT 14
123833: PUSH
123834: LD_INT 13
123836: PUSH
123837: EMPTY
123838: LIST
123839: LIST
123840: LIST
123841: LIST
123842: LIST
123843: LIST
123844: PUSH
123845: LD_VAR 0 2
123849: PUSH
123850: LD_INT 3
123852: MINUS
123853: ARRAY
123854: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
123855: LD_ADDR_OWVAR 45
123859: PUSH
123860: LD_INT 9
123862: ST_TO_ADDR
// end ; 10 .. 13 :
123863: GO 124373
123865: LD_INT 10
123867: DOUBLE
123868: GREATEREQUAL
123869: IFFALSE 123877
123871: LD_INT 13
123873: DOUBLE
123874: LESSEQUAL
123875: IFTRUE 123879
123877: GO 123956
123879: POP
// begin bc_type := b_lab_full ;
123880: LD_ADDR_OWVAR 42
123884: PUSH
123885: LD_INT 8
123887: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
123888: LD_ADDR_OWVAR 44
123892: PUSH
123893: LD_INT 10
123895: PUSH
123896: LD_INT 12
123898: PUSH
123899: LD_INT 14
123901: PUSH
123902: LD_INT 13
123904: PUSH
123905: EMPTY
123906: LIST
123907: LIST
123908: LIST
123909: LIST
123910: PUSH
123911: LD_VAR 0 2
123915: PUSH
123916: LD_INT 9
123918: MINUS
123919: ARRAY
123920: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
123921: LD_ADDR_OWVAR 45
123925: PUSH
123926: LD_INT 11
123928: PUSH
123929: LD_INT 15
123931: PUSH
123932: LD_INT 12
123934: PUSH
123935: LD_INT 15
123937: PUSH
123938: EMPTY
123939: LIST
123940: LIST
123941: LIST
123942: LIST
123943: PUSH
123944: LD_VAR 0 2
123948: PUSH
123949: LD_INT 9
123951: MINUS
123952: ARRAY
123953: ST_TO_ADDR
// end ; 14 :
123954: GO 124373
123956: LD_INT 14
123958: DOUBLE
123959: EQUAL
123960: IFTRUE 123964
123962: GO 123975
123964: POP
// bc_type := b_workshop ; 15 :
123965: LD_ADDR_OWVAR 42
123969: PUSH
123970: LD_INT 2
123972: ST_TO_ADDR
123973: GO 124373
123975: LD_INT 15
123977: DOUBLE
123978: EQUAL
123979: IFTRUE 123983
123981: GO 123994
123983: POP
// bc_type := b_factory ; 16 :
123984: LD_ADDR_OWVAR 42
123988: PUSH
123989: LD_INT 3
123991: ST_TO_ADDR
123992: GO 124373
123994: LD_INT 16
123996: DOUBLE
123997: EQUAL
123998: IFTRUE 124002
124000: GO 124013
124002: POP
// bc_type := b_ext_gun ; 17 :
124003: LD_ADDR_OWVAR 42
124007: PUSH
124008: LD_INT 17
124010: ST_TO_ADDR
124011: GO 124373
124013: LD_INT 17
124015: DOUBLE
124016: EQUAL
124017: IFTRUE 124021
124019: GO 124049
124021: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
124022: LD_ADDR_OWVAR 42
124026: PUSH
124027: LD_INT 19
124029: PUSH
124030: LD_INT 23
124032: PUSH
124033: LD_INT 19
124035: PUSH
124036: EMPTY
124037: LIST
124038: LIST
124039: LIST
124040: PUSH
124041: LD_VAR 0 1
124045: ARRAY
124046: ST_TO_ADDR
124047: GO 124373
124049: LD_INT 18
124051: DOUBLE
124052: EQUAL
124053: IFTRUE 124057
124055: GO 124068
124057: POP
// bc_type := b_ext_radar ; 19 :
124058: LD_ADDR_OWVAR 42
124062: PUSH
124063: LD_INT 20
124065: ST_TO_ADDR
124066: GO 124373
124068: LD_INT 19
124070: DOUBLE
124071: EQUAL
124072: IFTRUE 124076
124074: GO 124087
124076: POP
// bc_type := b_ext_radio ; 20 :
124077: LD_ADDR_OWVAR 42
124081: PUSH
124082: LD_INT 22
124084: ST_TO_ADDR
124085: GO 124373
124087: LD_INT 20
124089: DOUBLE
124090: EQUAL
124091: IFTRUE 124095
124093: GO 124106
124095: POP
// bc_type := b_ext_siberium ; 21 :
124096: LD_ADDR_OWVAR 42
124100: PUSH
124101: LD_INT 21
124103: ST_TO_ADDR
124104: GO 124373
124106: LD_INT 21
124108: DOUBLE
124109: EQUAL
124110: IFTRUE 124114
124112: GO 124125
124114: POP
// bc_type := b_ext_computer ; 22 :
124115: LD_ADDR_OWVAR 42
124119: PUSH
124120: LD_INT 24
124122: ST_TO_ADDR
124123: GO 124373
124125: LD_INT 22
124127: DOUBLE
124128: EQUAL
124129: IFTRUE 124133
124131: GO 124144
124133: POP
// bc_type := b_ext_track ; 23 :
124134: LD_ADDR_OWVAR 42
124138: PUSH
124139: LD_INT 16
124141: ST_TO_ADDR
124142: GO 124373
124144: LD_INT 23
124146: DOUBLE
124147: EQUAL
124148: IFTRUE 124152
124150: GO 124163
124152: POP
// bc_type := b_ext_laser ; 24 :
124153: LD_ADDR_OWVAR 42
124157: PUSH
124158: LD_INT 25
124160: ST_TO_ADDR
124161: GO 124373
124163: LD_INT 24
124165: DOUBLE
124166: EQUAL
124167: IFTRUE 124171
124169: GO 124182
124171: POP
// bc_type := b_control_tower ; 25 :
124172: LD_ADDR_OWVAR 42
124176: PUSH
124177: LD_INT 36
124179: ST_TO_ADDR
124180: GO 124373
124182: LD_INT 25
124184: DOUBLE
124185: EQUAL
124186: IFTRUE 124190
124188: GO 124201
124190: POP
// bc_type := b_breastwork ; 26 :
124191: LD_ADDR_OWVAR 42
124195: PUSH
124196: LD_INT 31
124198: ST_TO_ADDR
124199: GO 124373
124201: LD_INT 26
124203: DOUBLE
124204: EQUAL
124205: IFTRUE 124209
124207: GO 124220
124209: POP
// bc_type := b_bunker ; 27 :
124210: LD_ADDR_OWVAR 42
124214: PUSH
124215: LD_INT 32
124217: ST_TO_ADDR
124218: GO 124373
124220: LD_INT 27
124222: DOUBLE
124223: EQUAL
124224: IFTRUE 124228
124226: GO 124239
124228: POP
// bc_type := b_turret ; 28 :
124229: LD_ADDR_OWVAR 42
124233: PUSH
124234: LD_INT 33
124236: ST_TO_ADDR
124237: GO 124373
124239: LD_INT 28
124241: DOUBLE
124242: EQUAL
124243: IFTRUE 124247
124245: GO 124258
124247: POP
// bc_type := b_armoury ; 29 :
124248: LD_ADDR_OWVAR 42
124252: PUSH
124253: LD_INT 4
124255: ST_TO_ADDR
124256: GO 124373
124258: LD_INT 29
124260: DOUBLE
124261: EQUAL
124262: IFTRUE 124266
124264: GO 124277
124266: POP
// bc_type := b_barracks ; 30 :
124267: LD_ADDR_OWVAR 42
124271: PUSH
124272: LD_INT 5
124274: ST_TO_ADDR
124275: GO 124373
124277: LD_INT 30
124279: DOUBLE
124280: EQUAL
124281: IFTRUE 124285
124283: GO 124296
124285: POP
// bc_type := b_solar_power ; 31 :
124286: LD_ADDR_OWVAR 42
124290: PUSH
124291: LD_INT 27
124293: ST_TO_ADDR
124294: GO 124373
124296: LD_INT 31
124298: DOUBLE
124299: EQUAL
124300: IFTRUE 124304
124302: GO 124315
124304: POP
// bc_type := b_oil_power ; 32 :
124305: LD_ADDR_OWVAR 42
124309: PUSH
124310: LD_INT 26
124312: ST_TO_ADDR
124313: GO 124373
124315: LD_INT 32
124317: DOUBLE
124318: EQUAL
124319: IFTRUE 124323
124321: GO 124334
124323: POP
// bc_type := b_siberite_power ; 33 :
124324: LD_ADDR_OWVAR 42
124328: PUSH
124329: LD_INT 28
124331: ST_TO_ADDR
124332: GO 124373
124334: LD_INT 33
124336: DOUBLE
124337: EQUAL
124338: IFTRUE 124342
124340: GO 124353
124342: POP
// bc_type := b_oil_mine ; 34 :
124343: LD_ADDR_OWVAR 42
124347: PUSH
124348: LD_INT 29
124350: ST_TO_ADDR
124351: GO 124373
124353: LD_INT 34
124355: DOUBLE
124356: EQUAL
124357: IFTRUE 124361
124359: GO 124372
124361: POP
// bc_type := b_siberite_mine ; end ;
124362: LD_ADDR_OWVAR 42
124366: PUSH
124367: LD_INT 30
124369: ST_TO_ADDR
124370: GO 124373
124372: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
124373: LD_ADDR_VAR 0 8
124377: PUSH
124378: LD_VAR 0 5
124382: PPUSH
124383: LD_VAR 0 6
124387: PPUSH
124388: LD_VAR 0 3
124392: PPUSH
124393: CALL_OW 47
124397: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
124398: LD_OWVAR 42
124402: PUSH
124403: LD_INT 32
124405: PUSH
124406: LD_INT 33
124408: PUSH
124409: EMPTY
124410: LIST
124411: LIST
124412: IN
124413: IFFALSE 124429
// PlaceWeaponTurret ( b , weapon ) ;
124415: LD_VAR 0 8
124419: PPUSH
124420: LD_VAR 0 4
124424: PPUSH
124425: CALL_OW 431
// end ;
124429: LD_VAR 0 7
124433: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
124434: LD_INT 0
124436: PPUSH
124437: PPUSH
124438: PPUSH
124439: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
124440: LD_ADDR_VAR 0 4
124444: PUSH
124445: LD_INT 22
124447: PUSH
124448: LD_OWVAR 2
124452: PUSH
124453: EMPTY
124454: LIST
124455: LIST
124456: PUSH
124457: LD_INT 2
124459: PUSH
124460: LD_INT 30
124462: PUSH
124463: LD_INT 0
124465: PUSH
124466: EMPTY
124467: LIST
124468: LIST
124469: PUSH
124470: LD_INT 30
124472: PUSH
124473: LD_INT 1
124475: PUSH
124476: EMPTY
124477: LIST
124478: LIST
124479: PUSH
124480: EMPTY
124481: LIST
124482: LIST
124483: LIST
124484: PUSH
124485: EMPTY
124486: LIST
124487: LIST
124488: PPUSH
124489: CALL_OW 69
124493: ST_TO_ADDR
// if not tmp then
124494: LD_VAR 0 4
124498: NOT
124499: IFFALSE 124503
// exit ;
124501: GO 124562
// for i in tmp do
124503: LD_ADDR_VAR 0 2
124507: PUSH
124508: LD_VAR 0 4
124512: PUSH
124513: FOR_IN
124514: IFFALSE 124560
// for j = 1 to 3 do
124516: LD_ADDR_VAR 0 3
124520: PUSH
124521: DOUBLE
124522: LD_INT 1
124524: DEC
124525: ST_TO_ADDR
124526: LD_INT 3
124528: PUSH
124529: FOR_TO
124530: IFFALSE 124556
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
124532: LD_VAR 0 2
124536: PPUSH
124537: CALL_OW 274
124541: PPUSH
124542: LD_VAR 0 3
124546: PPUSH
124547: LD_INT 99999
124549: PPUSH
124550: CALL_OW 277
124554: GO 124529
124556: POP
124557: POP
124558: GO 124513
124560: POP
124561: POP
// end ;
124562: LD_VAR 0 1
124566: RET
// export function hHackSetLevel10 ; var i , j ; begin
124567: LD_INT 0
124569: PPUSH
124570: PPUSH
124571: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
124572: LD_ADDR_VAR 0 2
124576: PUSH
124577: LD_INT 21
124579: PUSH
124580: LD_INT 1
124582: PUSH
124583: EMPTY
124584: LIST
124585: LIST
124586: PPUSH
124587: CALL_OW 69
124591: PUSH
124592: FOR_IN
124593: IFFALSE 124645
// if IsSelected ( i ) then
124595: LD_VAR 0 2
124599: PPUSH
124600: CALL_OW 306
124604: IFFALSE 124643
// begin for j := 1 to 4 do
124606: LD_ADDR_VAR 0 3
124610: PUSH
124611: DOUBLE
124612: LD_INT 1
124614: DEC
124615: ST_TO_ADDR
124616: LD_INT 4
124618: PUSH
124619: FOR_TO
124620: IFFALSE 124641
// SetSkill ( i , j , 10 ) ;
124622: LD_VAR 0 2
124626: PPUSH
124627: LD_VAR 0 3
124631: PPUSH
124632: LD_INT 10
124634: PPUSH
124635: CALL_OW 237
124639: GO 124619
124641: POP
124642: POP
// end ;
124643: GO 124592
124645: POP
124646: POP
// end ;
124647: LD_VAR 0 1
124651: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
124652: LD_INT 0
124654: PPUSH
124655: PPUSH
124656: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
124657: LD_ADDR_VAR 0 2
124661: PUSH
124662: LD_INT 22
124664: PUSH
124665: LD_OWVAR 2
124669: PUSH
124670: EMPTY
124671: LIST
124672: LIST
124673: PUSH
124674: LD_INT 21
124676: PUSH
124677: LD_INT 1
124679: PUSH
124680: EMPTY
124681: LIST
124682: LIST
124683: PUSH
124684: EMPTY
124685: LIST
124686: LIST
124687: PPUSH
124688: CALL_OW 69
124692: PUSH
124693: FOR_IN
124694: IFFALSE 124735
// begin for j := 1 to 4 do
124696: LD_ADDR_VAR 0 3
124700: PUSH
124701: DOUBLE
124702: LD_INT 1
124704: DEC
124705: ST_TO_ADDR
124706: LD_INT 4
124708: PUSH
124709: FOR_TO
124710: IFFALSE 124731
// SetSkill ( i , j , 10 ) ;
124712: LD_VAR 0 2
124716: PPUSH
124717: LD_VAR 0 3
124721: PPUSH
124722: LD_INT 10
124724: PPUSH
124725: CALL_OW 237
124729: GO 124709
124731: POP
124732: POP
// end ;
124733: GO 124693
124735: POP
124736: POP
// end ;
124737: LD_VAR 0 1
124741: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
124742: LD_INT 0
124744: PPUSH
// uc_side := your_side ;
124745: LD_ADDR_OWVAR 20
124749: PUSH
124750: LD_OWVAR 2
124754: ST_TO_ADDR
// uc_nation := nation ;
124755: LD_ADDR_OWVAR 21
124759: PUSH
124760: LD_VAR 0 1
124764: ST_TO_ADDR
// InitHc ;
124765: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
124769: LD_INT 0
124771: PPUSH
124772: LD_VAR 0 2
124776: PPUSH
124777: LD_VAR 0 3
124781: PPUSH
124782: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
124786: LD_VAR 0 4
124790: PPUSH
124791: LD_VAR 0 5
124795: PPUSH
124796: CALL_OW 428
124800: PUSH
124801: LD_INT 0
124803: EQUAL
124804: IFFALSE 124828
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
124806: CALL_OW 44
124810: PPUSH
124811: LD_VAR 0 4
124815: PPUSH
124816: LD_VAR 0 5
124820: PPUSH
124821: LD_INT 1
124823: PPUSH
124824: CALL_OW 48
// end ;
124828: LD_VAR 0 6
124832: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
124833: LD_INT 0
124835: PPUSH
124836: PPUSH
// uc_side := your_side ;
124837: LD_ADDR_OWVAR 20
124841: PUSH
124842: LD_OWVAR 2
124846: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
124847: LD_VAR 0 1
124851: PUSH
124852: LD_INT 1
124854: PUSH
124855: LD_INT 2
124857: PUSH
124858: LD_INT 3
124860: PUSH
124861: LD_INT 4
124863: PUSH
124864: LD_INT 5
124866: PUSH
124867: EMPTY
124868: LIST
124869: LIST
124870: LIST
124871: LIST
124872: LIST
124873: IN
124874: IFFALSE 124886
// uc_nation := nation_american else
124876: LD_ADDR_OWVAR 21
124880: PUSH
124881: LD_INT 1
124883: ST_TO_ADDR
124884: GO 124929
// if chassis in [ 11 , 12 , 13 , 14 ] then
124886: LD_VAR 0 1
124890: PUSH
124891: LD_INT 11
124893: PUSH
124894: LD_INT 12
124896: PUSH
124897: LD_INT 13
124899: PUSH
124900: LD_INT 14
124902: PUSH
124903: EMPTY
124904: LIST
124905: LIST
124906: LIST
124907: LIST
124908: IN
124909: IFFALSE 124921
// uc_nation := nation_arabian else
124911: LD_ADDR_OWVAR 21
124915: PUSH
124916: LD_INT 2
124918: ST_TO_ADDR
124919: GO 124929
// uc_nation := nation_russian ;
124921: LD_ADDR_OWVAR 21
124925: PUSH
124926: LD_INT 3
124928: ST_TO_ADDR
// vc_chassis := chassis ;
124929: LD_ADDR_OWVAR 37
124933: PUSH
124934: LD_VAR 0 1
124938: ST_TO_ADDR
// vc_engine := engine ;
124939: LD_ADDR_OWVAR 39
124943: PUSH
124944: LD_VAR 0 2
124948: ST_TO_ADDR
// vc_control := control ;
124949: LD_ADDR_OWVAR 38
124953: PUSH
124954: LD_VAR 0 3
124958: ST_TO_ADDR
// vc_weapon := weapon ;
124959: LD_ADDR_OWVAR 40
124963: PUSH
124964: LD_VAR 0 4
124968: ST_TO_ADDR
// un := CreateVehicle ;
124969: LD_ADDR_VAR 0 8
124973: PUSH
124974: CALL_OW 45
124978: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
124979: LD_VAR 0 8
124983: PPUSH
124984: LD_INT 0
124986: PPUSH
124987: LD_INT 5
124989: PPUSH
124990: CALL_OW 12
124994: PPUSH
124995: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
124999: LD_VAR 0 8
125003: PPUSH
125004: LD_VAR 0 5
125008: PPUSH
125009: LD_VAR 0 6
125013: PPUSH
125014: LD_INT 1
125016: PPUSH
125017: CALL_OW 48
// end ;
125021: LD_VAR 0 7
125025: RET
// export hInvincible ; every 1 do
125026: GO 125028
125028: DISABLE
// hInvincible := [ ] ;
125029: LD_ADDR_EXP 204
125033: PUSH
125034: EMPTY
125035: ST_TO_ADDR
125036: END
// every 10 do var i ;
125037: GO 125039
125039: DISABLE
125040: LD_INT 0
125042: PPUSH
// begin enable ;
125043: ENABLE
// if not hInvincible then
125044: LD_EXP 204
125048: NOT
125049: IFFALSE 125053
// exit ;
125051: GO 125097
// for i in hInvincible do
125053: LD_ADDR_VAR 0 1
125057: PUSH
125058: LD_EXP 204
125062: PUSH
125063: FOR_IN
125064: IFFALSE 125095
// if GetLives ( i ) < 1000 then
125066: LD_VAR 0 1
125070: PPUSH
125071: CALL_OW 256
125075: PUSH
125076: LD_INT 1000
125078: LESS
125079: IFFALSE 125093
// SetLives ( i , 1000 ) ;
125081: LD_VAR 0 1
125085: PPUSH
125086: LD_INT 1000
125088: PPUSH
125089: CALL_OW 234
125093: GO 125063
125095: POP
125096: POP
// end ;
125097: PPOPN 1
125099: END
// export function hHackInvincible ; var i ; begin
125100: LD_INT 0
125102: PPUSH
125103: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
125104: LD_ADDR_VAR 0 2
125108: PUSH
125109: LD_INT 2
125111: PUSH
125112: LD_INT 21
125114: PUSH
125115: LD_INT 1
125117: PUSH
125118: EMPTY
125119: LIST
125120: LIST
125121: PUSH
125122: LD_INT 21
125124: PUSH
125125: LD_INT 2
125127: PUSH
125128: EMPTY
125129: LIST
125130: LIST
125131: PUSH
125132: EMPTY
125133: LIST
125134: LIST
125135: LIST
125136: PPUSH
125137: CALL_OW 69
125141: PUSH
125142: FOR_IN
125143: IFFALSE 125204
// if IsSelected ( i ) then
125145: LD_VAR 0 2
125149: PPUSH
125150: CALL_OW 306
125154: IFFALSE 125202
// begin if i in hInvincible then
125156: LD_VAR 0 2
125160: PUSH
125161: LD_EXP 204
125165: IN
125166: IFFALSE 125186
// hInvincible := hInvincible diff i else
125168: LD_ADDR_EXP 204
125172: PUSH
125173: LD_EXP 204
125177: PUSH
125178: LD_VAR 0 2
125182: DIFF
125183: ST_TO_ADDR
125184: GO 125202
// hInvincible := hInvincible union i ;
125186: LD_ADDR_EXP 204
125190: PUSH
125191: LD_EXP 204
125195: PUSH
125196: LD_VAR 0 2
125200: UNION
125201: ST_TO_ADDR
// end ;
125202: GO 125142
125204: POP
125205: POP
// end ;
125206: LD_VAR 0 1
125210: RET
// export function hHackInvisible ; var i , j ; begin
125211: LD_INT 0
125213: PPUSH
125214: PPUSH
125215: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125216: LD_ADDR_VAR 0 2
125220: PUSH
125221: LD_INT 21
125223: PUSH
125224: LD_INT 1
125226: PUSH
125227: EMPTY
125228: LIST
125229: LIST
125230: PPUSH
125231: CALL_OW 69
125235: PUSH
125236: FOR_IN
125237: IFFALSE 125261
// if IsSelected ( i ) then
125239: LD_VAR 0 2
125243: PPUSH
125244: CALL_OW 306
125248: IFFALSE 125259
// ComForceInvisible ( i ) ;
125250: LD_VAR 0 2
125254: PPUSH
125255: CALL_OW 496
125259: GO 125236
125261: POP
125262: POP
// end ;
125263: LD_VAR 0 1
125267: RET
// export function hHackChangeYourSide ; begin
125268: LD_INT 0
125270: PPUSH
// if your_side = 8 then
125271: LD_OWVAR 2
125275: PUSH
125276: LD_INT 8
125278: EQUAL
125279: IFFALSE 125291
// your_side := 0 else
125281: LD_ADDR_OWVAR 2
125285: PUSH
125286: LD_INT 0
125288: ST_TO_ADDR
125289: GO 125305
// your_side := your_side + 1 ;
125291: LD_ADDR_OWVAR 2
125295: PUSH
125296: LD_OWVAR 2
125300: PUSH
125301: LD_INT 1
125303: PLUS
125304: ST_TO_ADDR
// end ;
125305: LD_VAR 0 1
125309: RET
// export function hHackChangeUnitSide ; var i , j ; begin
125310: LD_INT 0
125312: PPUSH
125313: PPUSH
125314: PPUSH
// for i in all_units do
125315: LD_ADDR_VAR 0 2
125319: PUSH
125320: LD_OWVAR 3
125324: PUSH
125325: FOR_IN
125326: IFFALSE 125404
// if IsSelected ( i ) then
125328: LD_VAR 0 2
125332: PPUSH
125333: CALL_OW 306
125337: IFFALSE 125402
// begin j := GetSide ( i ) ;
125339: LD_ADDR_VAR 0 3
125343: PUSH
125344: LD_VAR 0 2
125348: PPUSH
125349: CALL_OW 255
125353: ST_TO_ADDR
// if j = 8 then
125354: LD_VAR 0 3
125358: PUSH
125359: LD_INT 8
125361: EQUAL
125362: IFFALSE 125374
// j := 0 else
125364: LD_ADDR_VAR 0 3
125368: PUSH
125369: LD_INT 0
125371: ST_TO_ADDR
125372: GO 125388
// j := j + 1 ;
125374: LD_ADDR_VAR 0 3
125378: PUSH
125379: LD_VAR 0 3
125383: PUSH
125384: LD_INT 1
125386: PLUS
125387: ST_TO_ADDR
// SetSide ( i , j ) ;
125388: LD_VAR 0 2
125392: PPUSH
125393: LD_VAR 0 3
125397: PPUSH
125398: CALL_OW 235
// end ;
125402: GO 125325
125404: POP
125405: POP
// end ;
125406: LD_VAR 0 1
125410: RET
// export function hHackFog ; begin
125411: LD_INT 0
125413: PPUSH
// FogOff ( true ) ;
125414: LD_INT 1
125416: PPUSH
125417: CALL_OW 344
// end ;
125421: LD_VAR 0 1
125425: RET
// export function hHackTeleport ( unit , x , y ) ; begin
125426: LD_INT 0
125428: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
125429: LD_VAR 0 1
125433: PPUSH
125434: LD_VAR 0 2
125438: PPUSH
125439: LD_VAR 0 3
125443: PPUSH
125444: LD_INT 1
125446: PPUSH
125447: LD_INT 1
125449: PPUSH
125450: CALL_OW 483
// CenterOnXY ( x , y ) ;
125454: LD_VAR 0 2
125458: PPUSH
125459: LD_VAR 0 3
125463: PPUSH
125464: CALL_OW 84
// end ;
125468: LD_VAR 0 4
125472: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
125473: LD_INT 0
125475: PPUSH
125476: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
125477: LD_VAR 0 1
125481: NOT
125482: PUSH
125483: LD_VAR 0 2
125487: PPUSH
125488: LD_VAR 0 3
125492: PPUSH
125493: CALL_OW 488
125497: NOT
125498: OR
125499: PUSH
125500: LD_VAR 0 1
125504: PPUSH
125505: CALL_OW 266
125509: PUSH
125510: LD_INT 3
125512: NONEQUAL
125513: PUSH
125514: LD_VAR 0 1
125518: PPUSH
125519: CALL_OW 247
125523: PUSH
125524: LD_INT 1
125526: EQUAL
125527: NOT
125528: AND
125529: OR
125530: IFFALSE 125534
// exit ;
125532: GO 125683
// if GetType ( factory ) = unit_human then
125534: LD_VAR 0 1
125538: PPUSH
125539: CALL_OW 247
125543: PUSH
125544: LD_INT 1
125546: EQUAL
125547: IFFALSE 125564
// factory := IsInUnit ( factory ) ;
125549: LD_ADDR_VAR 0 1
125553: PUSH
125554: LD_VAR 0 1
125558: PPUSH
125559: CALL_OW 310
125563: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
125564: LD_VAR 0 1
125568: PPUSH
125569: CALL_OW 266
125573: PUSH
125574: LD_INT 3
125576: NONEQUAL
125577: IFFALSE 125581
// exit ;
125579: GO 125683
// if HexInfo ( x , y ) = factory then
125581: LD_VAR 0 2
125585: PPUSH
125586: LD_VAR 0 3
125590: PPUSH
125591: CALL_OW 428
125595: PUSH
125596: LD_VAR 0 1
125600: EQUAL
125601: IFFALSE 125628
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
125603: LD_ADDR_EXP 205
125607: PUSH
125608: LD_EXP 205
125612: PPUSH
125613: LD_VAR 0 1
125617: PPUSH
125618: LD_INT 0
125620: PPUSH
125621: CALL_OW 1
125625: ST_TO_ADDR
125626: GO 125679
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
125628: LD_ADDR_EXP 205
125632: PUSH
125633: LD_EXP 205
125637: PPUSH
125638: LD_VAR 0 1
125642: PPUSH
125643: LD_VAR 0 1
125647: PPUSH
125648: CALL_OW 255
125652: PUSH
125653: LD_VAR 0 1
125657: PUSH
125658: LD_VAR 0 2
125662: PUSH
125663: LD_VAR 0 3
125667: PUSH
125668: EMPTY
125669: LIST
125670: LIST
125671: LIST
125672: LIST
125673: PPUSH
125674: CALL_OW 1
125678: ST_TO_ADDR
// UpdateFactoryWaypoints ;
125679: CALL 125688 0 0
// end ;
125683: LD_VAR 0 4
125687: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
125688: LD_INT 0
125690: PPUSH
125691: PPUSH
125692: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
125693: LD_STRING resetFactoryWaypoint();
125695: PPUSH
125696: CALL_OW 559
// if factoryWaypoints then
125700: LD_EXP 205
125704: IFFALSE 125830
// begin list := PrepareArray ( factoryWaypoints ) ;
125706: LD_ADDR_VAR 0 3
125710: PUSH
125711: LD_EXP 205
125715: PPUSH
125716: CALL 110518 0 1
125720: ST_TO_ADDR
// for i := 1 to list do
125721: LD_ADDR_VAR 0 2
125725: PUSH
125726: DOUBLE
125727: LD_INT 1
125729: DEC
125730: ST_TO_ADDR
125731: LD_VAR 0 3
125735: PUSH
125736: FOR_TO
125737: IFFALSE 125828
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
125739: LD_STRING setFactoryWaypointXY(
125741: PUSH
125742: LD_VAR 0 3
125746: PUSH
125747: LD_VAR 0 2
125751: ARRAY
125752: PUSH
125753: LD_INT 1
125755: ARRAY
125756: STR
125757: PUSH
125758: LD_STRING ,
125760: STR
125761: PUSH
125762: LD_VAR 0 3
125766: PUSH
125767: LD_VAR 0 2
125771: ARRAY
125772: PUSH
125773: LD_INT 2
125775: ARRAY
125776: STR
125777: PUSH
125778: LD_STRING ,
125780: STR
125781: PUSH
125782: LD_VAR 0 3
125786: PUSH
125787: LD_VAR 0 2
125791: ARRAY
125792: PUSH
125793: LD_INT 3
125795: ARRAY
125796: STR
125797: PUSH
125798: LD_STRING ,
125800: STR
125801: PUSH
125802: LD_VAR 0 3
125806: PUSH
125807: LD_VAR 0 2
125811: ARRAY
125812: PUSH
125813: LD_INT 4
125815: ARRAY
125816: STR
125817: PUSH
125818: LD_STRING )
125820: STR
125821: PPUSH
125822: CALL_OW 559
125826: GO 125736
125828: POP
125829: POP
// end ; end ;
125830: LD_VAR 0 1
125834: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
125835: LD_INT 0
125837: PPUSH
// if HexInfo ( x , y ) = warehouse then
125838: LD_VAR 0 2
125842: PPUSH
125843: LD_VAR 0 3
125847: PPUSH
125848: CALL_OW 428
125852: PUSH
125853: LD_VAR 0 1
125857: EQUAL
125858: IFFALSE 125885
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
125860: LD_ADDR_EXP 206
125864: PUSH
125865: LD_EXP 206
125869: PPUSH
125870: LD_VAR 0 1
125874: PPUSH
125875: LD_INT 0
125877: PPUSH
125878: CALL_OW 1
125882: ST_TO_ADDR
125883: GO 125936
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
125885: LD_ADDR_EXP 206
125889: PUSH
125890: LD_EXP 206
125894: PPUSH
125895: LD_VAR 0 1
125899: PPUSH
125900: LD_VAR 0 1
125904: PPUSH
125905: CALL_OW 255
125909: PUSH
125910: LD_VAR 0 1
125914: PUSH
125915: LD_VAR 0 2
125919: PUSH
125920: LD_VAR 0 3
125924: PUSH
125925: EMPTY
125926: LIST
125927: LIST
125928: LIST
125929: LIST
125930: PPUSH
125931: CALL_OW 1
125935: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
125936: CALL 125945 0 0
// end ;
125940: LD_VAR 0 4
125944: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
125945: LD_INT 0
125947: PPUSH
125948: PPUSH
125949: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
125950: LD_STRING resetWarehouseGatheringPoints();
125952: PPUSH
125953: CALL_OW 559
// if warehouseGatheringPoints then
125957: LD_EXP 206
125961: IFFALSE 126087
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
125963: LD_ADDR_VAR 0 3
125967: PUSH
125968: LD_EXP 206
125972: PPUSH
125973: CALL 110518 0 1
125977: ST_TO_ADDR
// for i := 1 to list do
125978: LD_ADDR_VAR 0 2
125982: PUSH
125983: DOUBLE
125984: LD_INT 1
125986: DEC
125987: ST_TO_ADDR
125988: LD_VAR 0 3
125992: PUSH
125993: FOR_TO
125994: IFFALSE 126085
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
125996: LD_STRING setWarehouseGatheringPointXY(
125998: PUSH
125999: LD_VAR 0 3
126003: PUSH
126004: LD_VAR 0 2
126008: ARRAY
126009: PUSH
126010: LD_INT 1
126012: ARRAY
126013: STR
126014: PUSH
126015: LD_STRING ,
126017: STR
126018: PUSH
126019: LD_VAR 0 3
126023: PUSH
126024: LD_VAR 0 2
126028: ARRAY
126029: PUSH
126030: LD_INT 2
126032: ARRAY
126033: STR
126034: PUSH
126035: LD_STRING ,
126037: STR
126038: PUSH
126039: LD_VAR 0 3
126043: PUSH
126044: LD_VAR 0 2
126048: ARRAY
126049: PUSH
126050: LD_INT 3
126052: ARRAY
126053: STR
126054: PUSH
126055: LD_STRING ,
126057: STR
126058: PUSH
126059: LD_VAR 0 3
126063: PUSH
126064: LD_VAR 0 2
126068: ARRAY
126069: PUSH
126070: LD_INT 4
126072: ARRAY
126073: STR
126074: PUSH
126075: LD_STRING )
126077: STR
126078: PPUSH
126079: CALL_OW 559
126083: GO 125993
126085: POP
126086: POP
// end ; end ;
126087: LD_VAR 0 1
126091: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
126092: LD_EXP 206
126096: IFFALSE 126781
126098: GO 126100
126100: DISABLE
126101: LD_INT 0
126103: PPUSH
126104: PPUSH
126105: PPUSH
126106: PPUSH
126107: PPUSH
126108: PPUSH
126109: PPUSH
126110: PPUSH
126111: PPUSH
// begin enable ;
126112: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
126113: LD_ADDR_VAR 0 3
126117: PUSH
126118: LD_EXP 206
126122: PPUSH
126123: CALL 110518 0 1
126127: ST_TO_ADDR
// if not list then
126128: LD_VAR 0 3
126132: NOT
126133: IFFALSE 126137
// exit ;
126135: GO 126781
// for i := 1 to list do
126137: LD_ADDR_VAR 0 1
126141: PUSH
126142: DOUBLE
126143: LD_INT 1
126145: DEC
126146: ST_TO_ADDR
126147: LD_VAR 0 3
126151: PUSH
126152: FOR_TO
126153: IFFALSE 126779
// begin depot := list [ i ] [ 2 ] ;
126155: LD_ADDR_VAR 0 8
126159: PUSH
126160: LD_VAR 0 3
126164: PUSH
126165: LD_VAR 0 1
126169: ARRAY
126170: PUSH
126171: LD_INT 2
126173: ARRAY
126174: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
126175: LD_ADDR_VAR 0 5
126179: PUSH
126180: LD_VAR 0 3
126184: PUSH
126185: LD_VAR 0 1
126189: ARRAY
126190: PUSH
126191: LD_INT 1
126193: ARRAY
126194: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
126195: LD_VAR 0 8
126199: PPUSH
126200: CALL_OW 301
126204: PUSH
126205: LD_VAR 0 5
126209: PUSH
126210: LD_VAR 0 8
126214: PPUSH
126215: CALL_OW 255
126219: NONEQUAL
126220: OR
126221: IFFALSE 126250
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
126223: LD_ADDR_EXP 206
126227: PUSH
126228: LD_EXP 206
126232: PPUSH
126233: LD_VAR 0 8
126237: PPUSH
126238: LD_INT 0
126240: PPUSH
126241: CALL_OW 1
126245: ST_TO_ADDR
// exit ;
126246: POP
126247: POP
126248: GO 126781
// end ; x := list [ i ] [ 3 ] ;
126250: LD_ADDR_VAR 0 6
126254: PUSH
126255: LD_VAR 0 3
126259: PUSH
126260: LD_VAR 0 1
126264: ARRAY
126265: PUSH
126266: LD_INT 3
126268: ARRAY
126269: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
126270: LD_ADDR_VAR 0 7
126274: PUSH
126275: LD_VAR 0 3
126279: PUSH
126280: LD_VAR 0 1
126284: ARRAY
126285: PUSH
126286: LD_INT 4
126288: ARRAY
126289: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
126290: LD_ADDR_VAR 0 9
126294: PUSH
126295: LD_VAR 0 6
126299: PPUSH
126300: LD_VAR 0 7
126304: PPUSH
126305: LD_INT 16
126307: PPUSH
126308: CALL 109106 0 3
126312: ST_TO_ADDR
// if not cratesNearbyPoint then
126313: LD_VAR 0 9
126317: NOT
126318: IFFALSE 126324
// exit ;
126320: POP
126321: POP
126322: GO 126781
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
126324: LD_ADDR_VAR 0 4
126328: PUSH
126329: LD_INT 22
126331: PUSH
126332: LD_VAR 0 5
126336: PUSH
126337: EMPTY
126338: LIST
126339: LIST
126340: PUSH
126341: LD_INT 3
126343: PUSH
126344: LD_INT 60
126346: PUSH
126347: EMPTY
126348: LIST
126349: PUSH
126350: EMPTY
126351: LIST
126352: LIST
126353: PUSH
126354: LD_INT 91
126356: PUSH
126357: LD_VAR 0 8
126361: PUSH
126362: LD_INT 6
126364: PUSH
126365: EMPTY
126366: LIST
126367: LIST
126368: LIST
126369: PUSH
126370: LD_INT 2
126372: PUSH
126373: LD_INT 25
126375: PUSH
126376: LD_INT 2
126378: PUSH
126379: EMPTY
126380: LIST
126381: LIST
126382: PUSH
126383: LD_INT 25
126385: PUSH
126386: LD_INT 16
126388: PUSH
126389: EMPTY
126390: LIST
126391: LIST
126392: PUSH
126393: EMPTY
126394: LIST
126395: LIST
126396: LIST
126397: PUSH
126398: EMPTY
126399: LIST
126400: LIST
126401: LIST
126402: LIST
126403: PPUSH
126404: CALL_OW 69
126408: PUSH
126409: LD_VAR 0 8
126413: PPUSH
126414: CALL_OW 313
126418: PPUSH
126419: LD_INT 3
126421: PUSH
126422: LD_INT 60
126424: PUSH
126425: EMPTY
126426: LIST
126427: PUSH
126428: EMPTY
126429: LIST
126430: LIST
126431: PUSH
126432: LD_INT 2
126434: PUSH
126435: LD_INT 25
126437: PUSH
126438: LD_INT 2
126440: PUSH
126441: EMPTY
126442: LIST
126443: LIST
126444: PUSH
126445: LD_INT 25
126447: PUSH
126448: LD_INT 16
126450: PUSH
126451: EMPTY
126452: LIST
126453: LIST
126454: PUSH
126455: EMPTY
126456: LIST
126457: LIST
126458: LIST
126459: PUSH
126460: EMPTY
126461: LIST
126462: LIST
126463: PPUSH
126464: CALL_OW 72
126468: UNION
126469: ST_TO_ADDR
// if tmp then
126470: LD_VAR 0 4
126474: IFFALSE 126554
// begin tmp := ShrinkArray ( tmp , 3 ) ;
126476: LD_ADDR_VAR 0 4
126480: PUSH
126481: LD_VAR 0 4
126485: PPUSH
126486: LD_INT 3
126488: PPUSH
126489: CALL 107075 0 2
126493: ST_TO_ADDR
// for j in tmp do
126494: LD_ADDR_VAR 0 2
126498: PUSH
126499: LD_VAR 0 4
126503: PUSH
126504: FOR_IN
126505: IFFALSE 126548
// begin if IsInUnit ( j ) then
126507: LD_VAR 0 2
126511: PPUSH
126512: CALL_OW 310
126516: IFFALSE 126527
// ComExit ( j ) ;
126518: LD_VAR 0 2
126522: PPUSH
126523: CALL 107158 0 1
// AddComCollect ( j , x , y ) ;
126527: LD_VAR 0 2
126531: PPUSH
126532: LD_VAR 0 6
126536: PPUSH
126537: LD_VAR 0 7
126541: PPUSH
126542: CALL_OW 177
// end ;
126546: GO 126504
126548: POP
126549: POP
// exit ;
126550: POP
126551: POP
126552: GO 126781
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
126554: LD_ADDR_VAR 0 4
126558: PUSH
126559: LD_INT 22
126561: PUSH
126562: LD_VAR 0 5
126566: PUSH
126567: EMPTY
126568: LIST
126569: LIST
126570: PUSH
126571: LD_INT 91
126573: PUSH
126574: LD_VAR 0 8
126578: PUSH
126579: LD_INT 8
126581: PUSH
126582: EMPTY
126583: LIST
126584: LIST
126585: LIST
126586: PUSH
126587: LD_INT 2
126589: PUSH
126590: LD_INT 34
126592: PUSH
126593: LD_INT 12
126595: PUSH
126596: EMPTY
126597: LIST
126598: LIST
126599: PUSH
126600: LD_INT 34
126602: PUSH
126603: LD_INT 51
126605: PUSH
126606: EMPTY
126607: LIST
126608: LIST
126609: PUSH
126610: LD_INT 34
126612: PUSH
126613: LD_INT 32
126615: PUSH
126616: EMPTY
126617: LIST
126618: LIST
126619: PUSH
126620: LD_INT 34
126622: PUSH
126623: LD_INT 89
126625: PUSH
126626: EMPTY
126627: LIST
126628: LIST
126629: PUSH
126630: EMPTY
126631: LIST
126632: LIST
126633: LIST
126634: LIST
126635: LIST
126636: PUSH
126637: EMPTY
126638: LIST
126639: LIST
126640: LIST
126641: PPUSH
126642: CALL_OW 69
126646: ST_TO_ADDR
// if tmp then
126647: LD_VAR 0 4
126651: IFFALSE 126777
// begin for j in tmp do
126653: LD_ADDR_VAR 0 2
126657: PUSH
126658: LD_VAR 0 4
126662: PUSH
126663: FOR_IN
126664: IFFALSE 126775
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
126666: LD_VAR 0 2
126670: PPUSH
126671: CALL_OW 262
126675: PUSH
126676: LD_INT 3
126678: EQUAL
126679: PUSH
126680: LD_VAR 0 2
126684: PPUSH
126685: CALL_OW 261
126689: PUSH
126690: LD_INT 20
126692: GREATER
126693: OR
126694: PUSH
126695: LD_VAR 0 2
126699: PPUSH
126700: CALL_OW 314
126704: NOT
126705: AND
126706: PUSH
126707: LD_VAR 0 2
126711: PPUSH
126712: CALL_OW 263
126716: PUSH
126717: LD_INT 1
126719: NONEQUAL
126720: PUSH
126721: LD_VAR 0 2
126725: PPUSH
126726: CALL_OW 311
126730: OR
126731: AND
126732: IFFALSE 126773
// begin ComCollect ( j , x , y ) ;
126734: LD_VAR 0 2
126738: PPUSH
126739: LD_VAR 0 6
126743: PPUSH
126744: LD_VAR 0 7
126748: PPUSH
126749: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
126753: LD_VAR 0 2
126757: PPUSH
126758: LD_VAR 0 8
126762: PPUSH
126763: CALL_OW 172
// exit ;
126767: POP
126768: POP
126769: POP
126770: POP
126771: GO 126781
// end ;
126773: GO 126663
126775: POP
126776: POP
// end ; end ;
126777: GO 126152
126779: POP
126780: POP
// end ; end_of_file
126781: PPOPN 9
126783: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
126784: LD_INT 0
126786: PPUSH
126787: PPUSH
126788: PPUSH
126789: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
126790: LD_VAR 0 1
126794: PPUSH
126795: CALL_OW 264
126799: PUSH
126800: LD_INT 91
126802: EQUAL
126803: IFFALSE 126875
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
126805: LD_INT 68
126807: PPUSH
126808: LD_VAR 0 1
126812: PPUSH
126813: CALL_OW 255
126817: PPUSH
126818: CALL_OW 321
126822: PUSH
126823: LD_INT 2
126825: EQUAL
126826: IFFALSE 126838
// eff := 70 else
126828: LD_ADDR_VAR 0 4
126832: PUSH
126833: LD_INT 70
126835: ST_TO_ADDR
126836: GO 126846
// eff := 30 ;
126838: LD_ADDR_VAR 0 4
126842: PUSH
126843: LD_INT 30
126845: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
126846: LD_VAR 0 1
126850: PPUSH
126851: CALL_OW 250
126855: PPUSH
126856: LD_VAR 0 1
126860: PPUSH
126861: CALL_OW 251
126865: PPUSH
126866: LD_VAR 0 4
126870: PPUSH
126871: CALL_OW 495
// end ; end ;
126875: LD_VAR 0 2
126879: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
126880: LD_INT 0
126882: PPUSH
// end ;
126883: LD_VAR 0 4
126887: RET
// export function SOS_Command ( cmd ) ; begin
126888: LD_INT 0
126890: PPUSH
// end ;
126891: LD_VAR 0 2
126895: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
126896: LD_INT 0
126898: PPUSH
// end ;
126899: LD_VAR 0 6
126903: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
126904: LD_INT 0
126906: PPUSH
126907: PPUSH
// if not vehicle or not factory then
126908: LD_VAR 0 1
126912: NOT
126913: PUSH
126914: LD_VAR 0 2
126918: NOT
126919: OR
126920: IFFALSE 126924
// exit ;
126922: GO 127155
// if factoryWaypoints >= factory then
126924: LD_EXP 205
126928: PUSH
126929: LD_VAR 0 2
126933: GREATEREQUAL
126934: IFFALSE 127155
// if factoryWaypoints [ factory ] then
126936: LD_EXP 205
126940: PUSH
126941: LD_VAR 0 2
126945: ARRAY
126946: IFFALSE 127155
// begin if GetControl ( vehicle ) = control_manual then
126948: LD_VAR 0 1
126952: PPUSH
126953: CALL_OW 263
126957: PUSH
126958: LD_INT 1
126960: EQUAL
126961: IFFALSE 127042
// begin driver := IsDrivenBy ( vehicle ) ;
126963: LD_ADDR_VAR 0 4
126967: PUSH
126968: LD_VAR 0 1
126972: PPUSH
126973: CALL_OW 311
126977: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126978: LD_VAR 0 4
126982: PPUSH
126983: LD_EXP 205
126987: PUSH
126988: LD_VAR 0 2
126992: ARRAY
126993: PUSH
126994: LD_INT 3
126996: ARRAY
126997: PPUSH
126998: LD_EXP 205
127002: PUSH
127003: LD_VAR 0 2
127007: ARRAY
127008: PUSH
127009: LD_INT 4
127011: ARRAY
127012: PPUSH
127013: CALL_OW 171
// AddComExitVehicle ( driver ) ;
127017: LD_VAR 0 4
127021: PPUSH
127022: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
127026: LD_VAR 0 4
127030: PPUSH
127031: LD_VAR 0 2
127035: PPUSH
127036: CALL_OW 180
// end else
127040: GO 127155
// if GetControl ( vehicle ) = control_remote then
127042: LD_VAR 0 1
127046: PPUSH
127047: CALL_OW 263
127051: PUSH
127052: LD_INT 2
127054: EQUAL
127055: IFFALSE 127116
// begin wait ( 0 0$2 ) ;
127057: LD_INT 70
127059: PPUSH
127060: CALL_OW 67
// if Connect ( vehicle ) then
127064: LD_VAR 0 1
127068: PPUSH
127069: CALL 77366 0 1
127073: IFFALSE 127114
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
127075: LD_VAR 0 1
127079: PPUSH
127080: LD_EXP 205
127084: PUSH
127085: LD_VAR 0 2
127089: ARRAY
127090: PUSH
127091: LD_INT 3
127093: ARRAY
127094: PPUSH
127095: LD_EXP 205
127099: PUSH
127100: LD_VAR 0 2
127104: ARRAY
127105: PUSH
127106: LD_INT 4
127108: ARRAY
127109: PPUSH
127110: CALL_OW 171
// end else
127114: GO 127155
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
127116: LD_VAR 0 1
127120: PPUSH
127121: LD_EXP 205
127125: PUSH
127126: LD_VAR 0 2
127130: ARRAY
127131: PUSH
127132: LD_INT 3
127134: ARRAY
127135: PPUSH
127136: LD_EXP 205
127140: PUSH
127141: LD_VAR 0 2
127145: ARRAY
127146: PUSH
127147: LD_INT 4
127149: ARRAY
127150: PPUSH
127151: CALL_OW 171
// end ; end ;
127155: LD_VAR 0 3
127159: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
127160: LD_INT 0
127162: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
127163: LD_VAR 0 1
127167: PUSH
127168: LD_INT 250
127170: EQUAL
127171: PUSH
127172: LD_VAR 0 2
127176: PPUSH
127177: CALL_OW 264
127181: PUSH
127182: LD_INT 81
127184: EQUAL
127185: AND
127186: IFFALSE 127207
// MinerPlaceMine ( unit , x , y ) ;
127188: LD_VAR 0 2
127192: PPUSH
127193: LD_VAR 0 4
127197: PPUSH
127198: LD_VAR 0 5
127202: PPUSH
127203: CALL 130031 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
127207: LD_VAR 0 1
127211: PUSH
127212: LD_INT 251
127214: EQUAL
127215: PUSH
127216: LD_VAR 0 2
127220: PPUSH
127221: CALL_OW 264
127225: PUSH
127226: LD_INT 81
127228: EQUAL
127229: AND
127230: IFFALSE 127251
// MinerDetonateMine ( unit , x , y ) ;
127232: LD_VAR 0 2
127236: PPUSH
127237: LD_VAR 0 4
127241: PPUSH
127242: LD_VAR 0 5
127246: PPUSH
127247: CALL 130306 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
127251: LD_VAR 0 1
127255: PUSH
127256: LD_INT 252
127258: EQUAL
127259: PUSH
127260: LD_VAR 0 2
127264: PPUSH
127265: CALL_OW 264
127269: PUSH
127270: LD_INT 81
127272: EQUAL
127273: AND
127274: IFFALSE 127295
// MinerCreateMinefield ( unit , x , y ) ;
127276: LD_VAR 0 2
127280: PPUSH
127281: LD_VAR 0 4
127285: PPUSH
127286: LD_VAR 0 5
127290: PPUSH
127291: CALL 130723 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
127295: LD_VAR 0 1
127299: PUSH
127300: LD_INT 253
127302: EQUAL
127303: PUSH
127304: LD_VAR 0 2
127308: PPUSH
127309: CALL_OW 257
127313: PUSH
127314: LD_INT 5
127316: EQUAL
127317: AND
127318: IFFALSE 127339
// ComBinocular ( unit , x , y ) ;
127320: LD_VAR 0 2
127324: PPUSH
127325: LD_VAR 0 4
127329: PPUSH
127330: LD_VAR 0 5
127334: PPUSH
127335: CALL 131092 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
127339: LD_VAR 0 1
127343: PUSH
127344: LD_INT 254
127346: EQUAL
127347: PUSH
127348: LD_VAR 0 2
127352: PPUSH
127353: CALL_OW 264
127357: PUSH
127358: LD_INT 99
127360: EQUAL
127361: AND
127362: PUSH
127363: LD_VAR 0 3
127367: PPUSH
127368: CALL_OW 263
127372: PUSH
127373: LD_INT 3
127375: EQUAL
127376: AND
127377: IFFALSE 127393
// HackDestroyVehicle ( unit , selectedUnit ) ;
127379: LD_VAR 0 2
127383: PPUSH
127384: LD_VAR 0 3
127388: PPUSH
127389: CALL 129395 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
127393: LD_VAR 0 1
127397: PUSH
127398: LD_INT 255
127400: EQUAL
127401: PUSH
127402: LD_VAR 0 2
127406: PPUSH
127407: CALL_OW 264
127411: PUSH
127412: LD_INT 14
127414: PUSH
127415: LD_INT 53
127417: PUSH
127418: EMPTY
127419: LIST
127420: LIST
127421: IN
127422: AND
127423: PUSH
127424: LD_VAR 0 4
127428: PPUSH
127429: LD_VAR 0 5
127433: PPUSH
127434: CALL_OW 488
127438: AND
127439: IFFALSE 127463
// CutTreeXYR ( unit , x , y , 12 ) ;
127441: LD_VAR 0 2
127445: PPUSH
127446: LD_VAR 0 4
127450: PPUSH
127451: LD_VAR 0 5
127455: PPUSH
127456: LD_INT 12
127458: PPUSH
127459: CALL 127558 0 4
// if cmd = 256 then
127463: LD_VAR 0 1
127467: PUSH
127468: LD_INT 256
127470: EQUAL
127471: IFFALSE 127492
// SetFactoryWaypoint ( unit , x , y ) ;
127473: LD_VAR 0 2
127477: PPUSH
127478: LD_VAR 0 4
127482: PPUSH
127483: LD_VAR 0 5
127487: PPUSH
127488: CALL 125473 0 3
// if cmd = 257 then
127492: LD_VAR 0 1
127496: PUSH
127497: LD_INT 257
127499: EQUAL
127500: IFFALSE 127521
// SetWarehouseGatheringPoint ( unit , x , y ) ;
127502: LD_VAR 0 2
127506: PPUSH
127507: LD_VAR 0 4
127511: PPUSH
127512: LD_VAR 0 5
127516: PPUSH
127517: CALL 125835 0 3
// if cmd = 258 then
127521: LD_VAR 0 1
127525: PUSH
127526: LD_INT 258
127528: EQUAL
127529: IFFALSE 127553
// BurnTreeXYR ( unit , x , y , 8 ) ;
127531: LD_VAR 0 2
127535: PPUSH
127536: LD_VAR 0 4
127540: PPUSH
127541: LD_VAR 0 5
127545: PPUSH
127546: LD_INT 8
127548: PPUSH
127549: CALL 127952 0 4
// end ;
127553: LD_VAR 0 6
127557: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
127558: LD_INT 0
127560: PPUSH
127561: PPUSH
127562: PPUSH
127563: PPUSH
127564: PPUSH
127565: PPUSH
127566: PPUSH
127567: PPUSH
127568: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
127569: LD_VAR 0 1
127573: PPUSH
127574: CALL_OW 302
127578: NOT
127579: PUSH
127580: LD_VAR 0 2
127584: PPUSH
127585: LD_VAR 0 3
127589: PPUSH
127590: CALL_OW 488
127594: NOT
127595: OR
127596: PUSH
127597: LD_VAR 0 4
127601: NOT
127602: OR
127603: IFFALSE 127607
// exit ;
127605: GO 127947
// list := [ ] ;
127607: LD_ADDR_VAR 0 13
127611: PUSH
127612: EMPTY
127613: ST_TO_ADDR
// if x - r < 0 then
127614: LD_VAR 0 2
127618: PUSH
127619: LD_VAR 0 4
127623: MINUS
127624: PUSH
127625: LD_INT 0
127627: LESS
127628: IFFALSE 127640
// min_x := 0 else
127630: LD_ADDR_VAR 0 7
127634: PUSH
127635: LD_INT 0
127637: ST_TO_ADDR
127638: GO 127656
// min_x := x - r ;
127640: LD_ADDR_VAR 0 7
127644: PUSH
127645: LD_VAR 0 2
127649: PUSH
127650: LD_VAR 0 4
127654: MINUS
127655: ST_TO_ADDR
// if y - r < 0 then
127656: LD_VAR 0 3
127660: PUSH
127661: LD_VAR 0 4
127665: MINUS
127666: PUSH
127667: LD_INT 0
127669: LESS
127670: IFFALSE 127682
// min_y := 0 else
127672: LD_ADDR_VAR 0 8
127676: PUSH
127677: LD_INT 0
127679: ST_TO_ADDR
127680: GO 127698
// min_y := y - r ;
127682: LD_ADDR_VAR 0 8
127686: PUSH
127687: LD_VAR 0 3
127691: PUSH
127692: LD_VAR 0 4
127696: MINUS
127697: ST_TO_ADDR
// max_x := x + r ;
127698: LD_ADDR_VAR 0 9
127702: PUSH
127703: LD_VAR 0 2
127707: PUSH
127708: LD_VAR 0 4
127712: PLUS
127713: ST_TO_ADDR
// max_y := y + r ;
127714: LD_ADDR_VAR 0 10
127718: PUSH
127719: LD_VAR 0 3
127723: PUSH
127724: LD_VAR 0 4
127728: PLUS
127729: ST_TO_ADDR
// for _x = min_x to max_x do
127730: LD_ADDR_VAR 0 11
127734: PUSH
127735: DOUBLE
127736: LD_VAR 0 7
127740: DEC
127741: ST_TO_ADDR
127742: LD_VAR 0 9
127746: PUSH
127747: FOR_TO
127748: IFFALSE 127865
// for _y = min_y to max_y do
127750: LD_ADDR_VAR 0 12
127754: PUSH
127755: DOUBLE
127756: LD_VAR 0 8
127760: DEC
127761: ST_TO_ADDR
127762: LD_VAR 0 10
127766: PUSH
127767: FOR_TO
127768: IFFALSE 127861
// begin if not ValidHex ( _x , _y ) then
127770: LD_VAR 0 11
127774: PPUSH
127775: LD_VAR 0 12
127779: PPUSH
127780: CALL_OW 488
127784: NOT
127785: IFFALSE 127789
// continue ;
127787: GO 127767
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
127789: LD_VAR 0 11
127793: PPUSH
127794: LD_VAR 0 12
127798: PPUSH
127799: CALL_OW 351
127803: PUSH
127804: LD_VAR 0 11
127808: PPUSH
127809: LD_VAR 0 12
127813: PPUSH
127814: CALL_OW 554
127818: AND
127819: IFFALSE 127859
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
127821: LD_ADDR_VAR 0 13
127825: PUSH
127826: LD_VAR 0 13
127830: PPUSH
127831: LD_VAR 0 13
127835: PUSH
127836: LD_INT 1
127838: PLUS
127839: PPUSH
127840: LD_VAR 0 11
127844: PUSH
127845: LD_VAR 0 12
127849: PUSH
127850: EMPTY
127851: LIST
127852: LIST
127853: PPUSH
127854: CALL_OW 2
127858: ST_TO_ADDR
// end ;
127859: GO 127767
127861: POP
127862: POP
127863: GO 127747
127865: POP
127866: POP
// if not list then
127867: LD_VAR 0 13
127871: NOT
127872: IFFALSE 127876
// exit ;
127874: GO 127947
// for i in list do
127876: LD_ADDR_VAR 0 6
127880: PUSH
127881: LD_VAR 0 13
127885: PUSH
127886: FOR_IN
127887: IFFALSE 127945
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
127889: LD_VAR 0 1
127893: PPUSH
127894: LD_STRING M
127896: PUSH
127897: LD_VAR 0 6
127901: PUSH
127902: LD_INT 1
127904: ARRAY
127905: PUSH
127906: LD_VAR 0 6
127910: PUSH
127911: LD_INT 2
127913: ARRAY
127914: PUSH
127915: LD_INT 0
127917: PUSH
127918: LD_INT 0
127920: PUSH
127921: LD_INT 0
127923: PUSH
127924: LD_INT 0
127926: PUSH
127927: EMPTY
127928: LIST
127929: LIST
127930: LIST
127931: LIST
127932: LIST
127933: LIST
127934: LIST
127935: PUSH
127936: EMPTY
127937: LIST
127938: PPUSH
127939: CALL_OW 447
127943: GO 127886
127945: POP
127946: POP
// end ;
127947: LD_VAR 0 5
127951: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
127952: LD_INT 0
127954: PPUSH
127955: PPUSH
127956: PPUSH
127957: PPUSH
127958: PPUSH
127959: PPUSH
127960: PPUSH
127961: PPUSH
127962: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
127963: LD_VAR 0 1
127967: PPUSH
127968: CALL_OW 302
127972: NOT
127973: PUSH
127974: LD_VAR 0 2
127978: PPUSH
127979: LD_VAR 0 3
127983: PPUSH
127984: CALL_OW 488
127988: NOT
127989: OR
127990: PUSH
127991: LD_VAR 0 4
127995: NOT
127996: OR
127997: IFFALSE 128001
// exit ;
127999: GO 128349
// list := [ ] ;
128001: LD_ADDR_VAR 0 13
128005: PUSH
128006: EMPTY
128007: ST_TO_ADDR
// if x - r < 0 then
128008: LD_VAR 0 2
128012: PUSH
128013: LD_VAR 0 4
128017: MINUS
128018: PUSH
128019: LD_INT 0
128021: LESS
128022: IFFALSE 128034
// min_x := 0 else
128024: LD_ADDR_VAR 0 7
128028: PUSH
128029: LD_INT 0
128031: ST_TO_ADDR
128032: GO 128050
// min_x := x - r ;
128034: LD_ADDR_VAR 0 7
128038: PUSH
128039: LD_VAR 0 2
128043: PUSH
128044: LD_VAR 0 4
128048: MINUS
128049: ST_TO_ADDR
// if y - r < 0 then
128050: LD_VAR 0 3
128054: PUSH
128055: LD_VAR 0 4
128059: MINUS
128060: PUSH
128061: LD_INT 0
128063: LESS
128064: IFFALSE 128076
// min_y := 0 else
128066: LD_ADDR_VAR 0 8
128070: PUSH
128071: LD_INT 0
128073: ST_TO_ADDR
128074: GO 128092
// min_y := y - r ;
128076: LD_ADDR_VAR 0 8
128080: PUSH
128081: LD_VAR 0 3
128085: PUSH
128086: LD_VAR 0 4
128090: MINUS
128091: ST_TO_ADDR
// max_x := x + r ;
128092: LD_ADDR_VAR 0 9
128096: PUSH
128097: LD_VAR 0 2
128101: PUSH
128102: LD_VAR 0 4
128106: PLUS
128107: ST_TO_ADDR
// max_y := y + r ;
128108: LD_ADDR_VAR 0 10
128112: PUSH
128113: LD_VAR 0 3
128117: PUSH
128118: LD_VAR 0 4
128122: PLUS
128123: ST_TO_ADDR
// for _x = min_x to max_x do
128124: LD_ADDR_VAR 0 11
128128: PUSH
128129: DOUBLE
128130: LD_VAR 0 7
128134: DEC
128135: ST_TO_ADDR
128136: LD_VAR 0 9
128140: PUSH
128141: FOR_TO
128142: IFFALSE 128259
// for _y = min_y to max_y do
128144: LD_ADDR_VAR 0 12
128148: PUSH
128149: DOUBLE
128150: LD_VAR 0 8
128154: DEC
128155: ST_TO_ADDR
128156: LD_VAR 0 10
128160: PUSH
128161: FOR_TO
128162: IFFALSE 128255
// begin if not ValidHex ( _x , _y ) then
128164: LD_VAR 0 11
128168: PPUSH
128169: LD_VAR 0 12
128173: PPUSH
128174: CALL_OW 488
128178: NOT
128179: IFFALSE 128183
// continue ;
128181: GO 128161
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
128183: LD_VAR 0 11
128187: PPUSH
128188: LD_VAR 0 12
128192: PPUSH
128193: CALL_OW 351
128197: PUSH
128198: LD_VAR 0 11
128202: PPUSH
128203: LD_VAR 0 12
128207: PPUSH
128208: CALL_OW 554
128212: AND
128213: IFFALSE 128253
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
128215: LD_ADDR_VAR 0 13
128219: PUSH
128220: LD_VAR 0 13
128224: PPUSH
128225: LD_VAR 0 13
128229: PUSH
128230: LD_INT 1
128232: PLUS
128233: PPUSH
128234: LD_VAR 0 11
128238: PUSH
128239: LD_VAR 0 12
128243: PUSH
128244: EMPTY
128245: LIST
128246: LIST
128247: PPUSH
128248: CALL_OW 2
128252: ST_TO_ADDR
// end ;
128253: GO 128161
128255: POP
128256: POP
128257: GO 128141
128259: POP
128260: POP
// if not list then
128261: LD_VAR 0 13
128265: NOT
128266: IFFALSE 128270
// exit ;
128268: GO 128349
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
128270: LD_ADDR_VAR 0 13
128274: PUSH
128275: LD_VAR 0 1
128279: PPUSH
128280: LD_VAR 0 13
128284: PPUSH
128285: LD_INT 1
128287: PPUSH
128288: LD_INT 1
128290: PPUSH
128291: CALL 74508 0 4
128295: ST_TO_ADDR
// ComStop ( flame ) ;
128296: LD_VAR 0 1
128300: PPUSH
128301: CALL_OW 141
// for i in list do
128305: LD_ADDR_VAR 0 6
128309: PUSH
128310: LD_VAR 0 13
128314: PUSH
128315: FOR_IN
128316: IFFALSE 128347
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
128318: LD_VAR 0 1
128322: PPUSH
128323: LD_VAR 0 6
128327: PUSH
128328: LD_INT 1
128330: ARRAY
128331: PPUSH
128332: LD_VAR 0 6
128336: PUSH
128337: LD_INT 2
128339: ARRAY
128340: PPUSH
128341: CALL_OW 176
128345: GO 128315
128347: POP
128348: POP
// end ;
128349: LD_VAR 0 5
128353: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
128354: LD_EXP 208
128358: NOT
128359: IFFALSE 128409
128361: GO 128363
128363: DISABLE
// begin initHack := true ;
128364: LD_ADDR_EXP 208
128368: PUSH
128369: LD_INT 1
128371: ST_TO_ADDR
// hackTanks := [ ] ;
128372: LD_ADDR_EXP 209
128376: PUSH
128377: EMPTY
128378: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
128379: LD_ADDR_EXP 210
128383: PUSH
128384: EMPTY
128385: ST_TO_ADDR
// hackLimit := 3 ;
128386: LD_ADDR_EXP 211
128390: PUSH
128391: LD_INT 3
128393: ST_TO_ADDR
// hackDist := 12 ;
128394: LD_ADDR_EXP 212
128398: PUSH
128399: LD_INT 12
128401: ST_TO_ADDR
// hackCounter := [ ] ;
128402: LD_ADDR_EXP 213
128406: PUSH
128407: EMPTY
128408: ST_TO_ADDR
// end ;
128409: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
128410: LD_EXP 208
128414: PUSH
128415: LD_INT 34
128417: PUSH
128418: LD_INT 99
128420: PUSH
128421: EMPTY
128422: LIST
128423: LIST
128424: PPUSH
128425: CALL_OW 69
128429: AND
128430: IFFALSE 128683
128432: GO 128434
128434: DISABLE
128435: LD_INT 0
128437: PPUSH
128438: PPUSH
// begin enable ;
128439: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
128440: LD_ADDR_VAR 0 1
128444: PUSH
128445: LD_INT 34
128447: PUSH
128448: LD_INT 99
128450: PUSH
128451: EMPTY
128452: LIST
128453: LIST
128454: PPUSH
128455: CALL_OW 69
128459: PUSH
128460: FOR_IN
128461: IFFALSE 128681
// begin if not i in hackTanks then
128463: LD_VAR 0 1
128467: PUSH
128468: LD_EXP 209
128472: IN
128473: NOT
128474: IFFALSE 128557
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
128476: LD_ADDR_EXP 209
128480: PUSH
128481: LD_EXP 209
128485: PPUSH
128486: LD_EXP 209
128490: PUSH
128491: LD_INT 1
128493: PLUS
128494: PPUSH
128495: LD_VAR 0 1
128499: PPUSH
128500: CALL_OW 1
128504: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
128505: LD_ADDR_EXP 210
128509: PUSH
128510: LD_EXP 210
128514: PPUSH
128515: LD_EXP 210
128519: PUSH
128520: LD_INT 1
128522: PLUS
128523: PPUSH
128524: EMPTY
128525: PPUSH
128526: CALL_OW 1
128530: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
128531: LD_ADDR_EXP 213
128535: PUSH
128536: LD_EXP 213
128540: PPUSH
128541: LD_EXP 213
128545: PUSH
128546: LD_INT 1
128548: PLUS
128549: PPUSH
128550: EMPTY
128551: PPUSH
128552: CALL_OW 1
128556: ST_TO_ADDR
// end ; if not IsOk ( i ) then
128557: LD_VAR 0 1
128561: PPUSH
128562: CALL_OW 302
128566: NOT
128567: IFFALSE 128580
// begin HackUnlinkAll ( i ) ;
128569: LD_VAR 0 1
128573: PPUSH
128574: CALL 128686 0 1
// continue ;
128578: GO 128460
// end ; HackCheckCapturedStatus ( i ) ;
128580: LD_VAR 0 1
128584: PPUSH
128585: CALL 129129 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
128589: LD_ADDR_VAR 0 2
128593: PUSH
128594: LD_INT 81
128596: PUSH
128597: LD_VAR 0 1
128601: PPUSH
128602: CALL_OW 255
128606: PUSH
128607: EMPTY
128608: LIST
128609: LIST
128610: PUSH
128611: LD_INT 33
128613: PUSH
128614: LD_INT 3
128616: PUSH
128617: EMPTY
128618: LIST
128619: LIST
128620: PUSH
128621: LD_INT 91
128623: PUSH
128624: LD_VAR 0 1
128628: PUSH
128629: LD_EXP 212
128633: PUSH
128634: EMPTY
128635: LIST
128636: LIST
128637: LIST
128638: PUSH
128639: LD_INT 50
128641: PUSH
128642: EMPTY
128643: LIST
128644: PUSH
128645: EMPTY
128646: LIST
128647: LIST
128648: LIST
128649: LIST
128650: PPUSH
128651: CALL_OW 69
128655: ST_TO_ADDR
// if not tmp then
128656: LD_VAR 0 2
128660: NOT
128661: IFFALSE 128665
// continue ;
128663: GO 128460
// HackLink ( i , tmp ) ;
128665: LD_VAR 0 1
128669: PPUSH
128670: LD_VAR 0 2
128674: PPUSH
128675: CALL 128822 0 2
// end ;
128679: GO 128460
128681: POP
128682: POP
// end ;
128683: PPOPN 2
128685: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
128686: LD_INT 0
128688: PPUSH
128689: PPUSH
128690: PPUSH
// if not hack in hackTanks then
128691: LD_VAR 0 1
128695: PUSH
128696: LD_EXP 209
128700: IN
128701: NOT
128702: IFFALSE 128706
// exit ;
128704: GO 128817
// index := GetElementIndex ( hackTanks , hack ) ;
128706: LD_ADDR_VAR 0 4
128710: PUSH
128711: LD_EXP 209
128715: PPUSH
128716: LD_VAR 0 1
128720: PPUSH
128721: CALL 73805 0 2
128725: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
128726: LD_EXP 210
128730: PUSH
128731: LD_VAR 0 4
128735: ARRAY
128736: IFFALSE 128817
// begin for i in hackTanksCaptured [ index ] do
128738: LD_ADDR_VAR 0 3
128742: PUSH
128743: LD_EXP 210
128747: PUSH
128748: LD_VAR 0 4
128752: ARRAY
128753: PUSH
128754: FOR_IN
128755: IFFALSE 128781
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
128757: LD_VAR 0 3
128761: PUSH
128762: LD_INT 1
128764: ARRAY
128765: PPUSH
128766: LD_VAR 0 3
128770: PUSH
128771: LD_INT 2
128773: ARRAY
128774: PPUSH
128775: CALL_OW 235
128779: GO 128754
128781: POP
128782: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
128783: LD_ADDR_EXP 210
128787: PUSH
128788: LD_EXP 210
128792: PPUSH
128793: LD_VAR 0 4
128797: PPUSH
128798: EMPTY
128799: PPUSH
128800: CALL_OW 1
128804: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
128805: LD_VAR 0 1
128809: PPUSH
128810: LD_INT 0
128812: PPUSH
128813: CALL_OW 505
// end ; end ;
128817: LD_VAR 0 2
128821: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
128822: LD_INT 0
128824: PPUSH
128825: PPUSH
128826: PPUSH
// if not hack in hackTanks or not vehicles then
128827: LD_VAR 0 1
128831: PUSH
128832: LD_EXP 209
128836: IN
128837: NOT
128838: PUSH
128839: LD_VAR 0 2
128843: NOT
128844: OR
128845: IFFALSE 128849
// exit ;
128847: GO 129124
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
128849: LD_ADDR_VAR 0 2
128853: PUSH
128854: LD_VAR 0 1
128858: PPUSH
128859: LD_VAR 0 2
128863: PPUSH
128864: LD_INT 1
128866: PPUSH
128867: LD_INT 1
128869: PPUSH
128870: CALL 74455 0 4
128874: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
128875: LD_ADDR_VAR 0 5
128879: PUSH
128880: LD_EXP 209
128884: PPUSH
128885: LD_VAR 0 1
128889: PPUSH
128890: CALL 73805 0 2
128894: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
128895: LD_EXP 210
128899: PUSH
128900: LD_VAR 0 5
128904: ARRAY
128905: PUSH
128906: LD_EXP 211
128910: LESS
128911: IFFALSE 129100
// begin for i := 1 to vehicles do
128913: LD_ADDR_VAR 0 4
128917: PUSH
128918: DOUBLE
128919: LD_INT 1
128921: DEC
128922: ST_TO_ADDR
128923: LD_VAR 0 2
128927: PUSH
128928: FOR_TO
128929: IFFALSE 129098
// begin if hackTanksCaptured [ index ] = hackLimit then
128931: LD_EXP 210
128935: PUSH
128936: LD_VAR 0 5
128940: ARRAY
128941: PUSH
128942: LD_EXP 211
128946: EQUAL
128947: IFFALSE 128951
// break ;
128949: GO 129098
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
128951: LD_ADDR_EXP 213
128955: PUSH
128956: LD_EXP 213
128960: PPUSH
128961: LD_VAR 0 5
128965: PPUSH
128966: LD_EXP 213
128970: PUSH
128971: LD_VAR 0 5
128975: ARRAY
128976: PUSH
128977: LD_INT 1
128979: PLUS
128980: PPUSH
128981: CALL_OW 1
128985: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
128986: LD_ADDR_EXP 210
128990: PUSH
128991: LD_EXP 210
128995: PPUSH
128996: LD_VAR 0 5
129000: PUSH
129001: LD_EXP 210
129005: PUSH
129006: LD_VAR 0 5
129010: ARRAY
129011: PUSH
129012: LD_INT 1
129014: PLUS
129015: PUSH
129016: EMPTY
129017: LIST
129018: LIST
129019: PPUSH
129020: LD_VAR 0 2
129024: PUSH
129025: LD_VAR 0 4
129029: ARRAY
129030: PUSH
129031: LD_VAR 0 2
129035: PUSH
129036: LD_VAR 0 4
129040: ARRAY
129041: PPUSH
129042: CALL_OW 255
129046: PUSH
129047: EMPTY
129048: LIST
129049: LIST
129050: PPUSH
129051: CALL 74020 0 3
129055: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
129056: LD_VAR 0 2
129060: PUSH
129061: LD_VAR 0 4
129065: ARRAY
129066: PPUSH
129067: LD_VAR 0 1
129071: PPUSH
129072: CALL_OW 255
129076: PPUSH
129077: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
129081: LD_VAR 0 2
129085: PUSH
129086: LD_VAR 0 4
129090: ARRAY
129091: PPUSH
129092: CALL_OW 141
// end ;
129096: GO 128928
129098: POP
129099: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
129100: LD_VAR 0 1
129104: PPUSH
129105: LD_EXP 210
129109: PUSH
129110: LD_VAR 0 5
129114: ARRAY
129115: PUSH
129116: LD_INT 0
129118: PLUS
129119: PPUSH
129120: CALL_OW 505
// end ;
129124: LD_VAR 0 3
129128: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
129129: LD_INT 0
129131: PPUSH
129132: PPUSH
129133: PPUSH
129134: PPUSH
// if not hack in hackTanks then
129135: LD_VAR 0 1
129139: PUSH
129140: LD_EXP 209
129144: IN
129145: NOT
129146: IFFALSE 129150
// exit ;
129148: GO 129390
// index := GetElementIndex ( hackTanks , hack ) ;
129150: LD_ADDR_VAR 0 4
129154: PUSH
129155: LD_EXP 209
129159: PPUSH
129160: LD_VAR 0 1
129164: PPUSH
129165: CALL 73805 0 2
129169: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
129170: LD_ADDR_VAR 0 3
129174: PUSH
129175: DOUBLE
129176: LD_EXP 210
129180: PUSH
129181: LD_VAR 0 4
129185: ARRAY
129186: INC
129187: ST_TO_ADDR
129188: LD_INT 1
129190: PUSH
129191: FOR_DOWNTO
129192: IFFALSE 129364
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
129194: LD_ADDR_VAR 0 5
129198: PUSH
129199: LD_EXP 210
129203: PUSH
129204: LD_VAR 0 4
129208: ARRAY
129209: PUSH
129210: LD_VAR 0 3
129214: ARRAY
129215: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
129216: LD_VAR 0 5
129220: PUSH
129221: LD_INT 1
129223: ARRAY
129224: PPUSH
129225: CALL_OW 302
129229: NOT
129230: PUSH
129231: LD_VAR 0 5
129235: PUSH
129236: LD_INT 1
129238: ARRAY
129239: PPUSH
129240: CALL_OW 255
129244: PUSH
129245: LD_VAR 0 1
129249: PPUSH
129250: CALL_OW 255
129254: NONEQUAL
129255: OR
129256: IFFALSE 129362
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
129258: LD_VAR 0 5
129262: PUSH
129263: LD_INT 1
129265: ARRAY
129266: PPUSH
129267: CALL_OW 305
129271: PUSH
129272: LD_VAR 0 5
129276: PUSH
129277: LD_INT 1
129279: ARRAY
129280: PPUSH
129281: CALL_OW 255
129285: PUSH
129286: LD_VAR 0 1
129290: PPUSH
129291: CALL_OW 255
129295: EQUAL
129296: AND
129297: IFFALSE 129321
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
129299: LD_VAR 0 5
129303: PUSH
129304: LD_INT 1
129306: ARRAY
129307: PPUSH
129308: LD_VAR 0 5
129312: PUSH
129313: LD_INT 2
129315: ARRAY
129316: PPUSH
129317: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
129321: LD_ADDR_EXP 210
129325: PUSH
129326: LD_EXP 210
129330: PPUSH
129331: LD_VAR 0 4
129335: PPUSH
129336: LD_EXP 210
129340: PUSH
129341: LD_VAR 0 4
129345: ARRAY
129346: PPUSH
129347: LD_VAR 0 3
129351: PPUSH
129352: CALL_OW 3
129356: PPUSH
129357: CALL_OW 1
129361: ST_TO_ADDR
// end ; end ;
129362: GO 129191
129364: POP
129365: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
129366: LD_VAR 0 1
129370: PPUSH
129371: LD_EXP 210
129375: PUSH
129376: LD_VAR 0 4
129380: ARRAY
129381: PUSH
129382: LD_INT 0
129384: PLUS
129385: PPUSH
129386: CALL_OW 505
// end ;
129390: LD_VAR 0 2
129394: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
129395: LD_INT 0
129397: PPUSH
129398: PPUSH
129399: PPUSH
129400: PPUSH
// if not hack in hackTanks then
129401: LD_VAR 0 1
129405: PUSH
129406: LD_EXP 209
129410: IN
129411: NOT
129412: IFFALSE 129416
// exit ;
129414: GO 129501
// index := GetElementIndex ( hackTanks , hack ) ;
129416: LD_ADDR_VAR 0 5
129420: PUSH
129421: LD_EXP 209
129425: PPUSH
129426: LD_VAR 0 1
129430: PPUSH
129431: CALL 73805 0 2
129435: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
129436: LD_ADDR_VAR 0 4
129440: PUSH
129441: DOUBLE
129442: LD_INT 1
129444: DEC
129445: ST_TO_ADDR
129446: LD_EXP 210
129450: PUSH
129451: LD_VAR 0 5
129455: ARRAY
129456: PUSH
129457: FOR_TO
129458: IFFALSE 129499
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
129460: LD_EXP 210
129464: PUSH
129465: LD_VAR 0 5
129469: ARRAY
129470: PUSH
129471: LD_VAR 0 4
129475: ARRAY
129476: PUSH
129477: LD_INT 1
129479: ARRAY
129480: PUSH
129481: LD_VAR 0 2
129485: EQUAL
129486: IFFALSE 129497
// KillUnit ( vehicle ) ;
129488: LD_VAR 0 2
129492: PPUSH
129493: CALL_OW 66
129497: GO 129457
129499: POP
129500: POP
// end ;
129501: LD_VAR 0 3
129505: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
129506: LD_EXP 214
129510: NOT
129511: IFFALSE 129546
129513: GO 129515
129515: DISABLE
// begin initMiner := true ;
129516: LD_ADDR_EXP 214
129520: PUSH
129521: LD_INT 1
129523: ST_TO_ADDR
// minersList := [ ] ;
129524: LD_ADDR_EXP 215
129528: PUSH
129529: EMPTY
129530: ST_TO_ADDR
// minerMinesList := [ ] ;
129531: LD_ADDR_EXP 216
129535: PUSH
129536: EMPTY
129537: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
129538: LD_ADDR_EXP 217
129542: PUSH
129543: LD_INT 5
129545: ST_TO_ADDR
// end ;
129546: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
129547: LD_EXP 214
129551: PUSH
129552: LD_INT 34
129554: PUSH
129555: LD_INT 81
129557: PUSH
129558: EMPTY
129559: LIST
129560: LIST
129561: PPUSH
129562: CALL_OW 69
129566: AND
129567: IFFALSE 130028
129569: GO 129571
129571: DISABLE
129572: LD_INT 0
129574: PPUSH
129575: PPUSH
129576: PPUSH
129577: PPUSH
// begin enable ;
129578: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
129579: LD_ADDR_VAR 0 1
129583: PUSH
129584: LD_INT 34
129586: PUSH
129587: LD_INT 81
129589: PUSH
129590: EMPTY
129591: LIST
129592: LIST
129593: PPUSH
129594: CALL_OW 69
129598: PUSH
129599: FOR_IN
129600: IFFALSE 129672
// begin if not i in minersList then
129602: LD_VAR 0 1
129606: PUSH
129607: LD_EXP 215
129611: IN
129612: NOT
129613: IFFALSE 129670
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
129615: LD_ADDR_EXP 215
129619: PUSH
129620: LD_EXP 215
129624: PPUSH
129625: LD_EXP 215
129629: PUSH
129630: LD_INT 1
129632: PLUS
129633: PPUSH
129634: LD_VAR 0 1
129638: PPUSH
129639: CALL_OW 1
129643: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
129644: LD_ADDR_EXP 216
129648: PUSH
129649: LD_EXP 216
129653: PPUSH
129654: LD_EXP 216
129658: PUSH
129659: LD_INT 1
129661: PLUS
129662: PPUSH
129663: EMPTY
129664: PPUSH
129665: CALL_OW 1
129669: ST_TO_ADDR
// end end ;
129670: GO 129599
129672: POP
129673: POP
// for i := minerMinesList downto 1 do
129674: LD_ADDR_VAR 0 1
129678: PUSH
129679: DOUBLE
129680: LD_EXP 216
129684: INC
129685: ST_TO_ADDR
129686: LD_INT 1
129688: PUSH
129689: FOR_DOWNTO
129690: IFFALSE 130026
// begin if IsLive ( minersList [ i ] ) then
129692: LD_EXP 215
129696: PUSH
129697: LD_VAR 0 1
129701: ARRAY
129702: PPUSH
129703: CALL_OW 300
129707: IFFALSE 129735
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
129709: LD_EXP 215
129713: PUSH
129714: LD_VAR 0 1
129718: ARRAY
129719: PPUSH
129720: LD_EXP 216
129724: PUSH
129725: LD_VAR 0 1
129729: ARRAY
129730: PPUSH
129731: CALL_OW 505
// if not minerMinesList [ i ] then
129735: LD_EXP 216
129739: PUSH
129740: LD_VAR 0 1
129744: ARRAY
129745: NOT
129746: IFFALSE 129750
// continue ;
129748: GO 129689
// for j := minerMinesList [ i ] downto 1 do
129750: LD_ADDR_VAR 0 2
129754: PUSH
129755: DOUBLE
129756: LD_EXP 216
129760: PUSH
129761: LD_VAR 0 1
129765: ARRAY
129766: INC
129767: ST_TO_ADDR
129768: LD_INT 1
129770: PUSH
129771: FOR_DOWNTO
129772: IFFALSE 130022
// begin side := GetSide ( minersList [ i ] ) ;
129774: LD_ADDR_VAR 0 3
129778: PUSH
129779: LD_EXP 215
129783: PUSH
129784: LD_VAR 0 1
129788: ARRAY
129789: PPUSH
129790: CALL_OW 255
129794: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
129795: LD_ADDR_VAR 0 4
129799: PUSH
129800: LD_EXP 216
129804: PUSH
129805: LD_VAR 0 1
129809: ARRAY
129810: PUSH
129811: LD_VAR 0 2
129815: ARRAY
129816: PUSH
129817: LD_INT 1
129819: ARRAY
129820: PPUSH
129821: LD_EXP 216
129825: PUSH
129826: LD_VAR 0 1
129830: ARRAY
129831: PUSH
129832: LD_VAR 0 2
129836: ARRAY
129837: PUSH
129838: LD_INT 2
129840: ARRAY
129841: PPUSH
129842: CALL_OW 428
129846: ST_TO_ADDR
// if not tmp then
129847: LD_VAR 0 4
129851: NOT
129852: IFFALSE 129856
// continue ;
129854: GO 129771
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
129856: LD_VAR 0 4
129860: PUSH
129861: LD_INT 81
129863: PUSH
129864: LD_VAR 0 3
129868: PUSH
129869: EMPTY
129870: LIST
129871: LIST
129872: PPUSH
129873: CALL_OW 69
129877: IN
129878: PUSH
129879: LD_EXP 216
129883: PUSH
129884: LD_VAR 0 1
129888: ARRAY
129889: PUSH
129890: LD_VAR 0 2
129894: ARRAY
129895: PUSH
129896: LD_INT 1
129898: ARRAY
129899: PPUSH
129900: LD_EXP 216
129904: PUSH
129905: LD_VAR 0 1
129909: ARRAY
129910: PUSH
129911: LD_VAR 0 2
129915: ARRAY
129916: PUSH
129917: LD_INT 2
129919: ARRAY
129920: PPUSH
129921: CALL_OW 458
129925: AND
129926: IFFALSE 130020
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
129928: LD_EXP 216
129932: PUSH
129933: LD_VAR 0 1
129937: ARRAY
129938: PUSH
129939: LD_VAR 0 2
129943: ARRAY
129944: PUSH
129945: LD_INT 1
129947: ARRAY
129948: PPUSH
129949: LD_EXP 216
129953: PUSH
129954: LD_VAR 0 1
129958: ARRAY
129959: PUSH
129960: LD_VAR 0 2
129964: ARRAY
129965: PUSH
129966: LD_INT 2
129968: ARRAY
129969: PPUSH
129970: LD_VAR 0 3
129974: PPUSH
129975: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
129979: LD_ADDR_EXP 216
129983: PUSH
129984: LD_EXP 216
129988: PPUSH
129989: LD_VAR 0 1
129993: PPUSH
129994: LD_EXP 216
129998: PUSH
129999: LD_VAR 0 1
130003: ARRAY
130004: PPUSH
130005: LD_VAR 0 2
130009: PPUSH
130010: CALL_OW 3
130014: PPUSH
130015: CALL_OW 1
130019: ST_TO_ADDR
// end ; end ;
130020: GO 129771
130022: POP
130023: POP
// end ;
130024: GO 129689
130026: POP
130027: POP
// end ;
130028: PPOPN 4
130030: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
130031: LD_INT 0
130033: PPUSH
130034: PPUSH
// result := false ;
130035: LD_ADDR_VAR 0 4
130039: PUSH
130040: LD_INT 0
130042: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
130043: LD_VAR 0 1
130047: PPUSH
130048: CALL_OW 264
130052: PUSH
130053: LD_INT 81
130055: EQUAL
130056: NOT
130057: IFFALSE 130061
// exit ;
130059: GO 130301
// index := GetElementIndex ( minersList , unit ) ;
130061: LD_ADDR_VAR 0 5
130065: PUSH
130066: LD_EXP 215
130070: PPUSH
130071: LD_VAR 0 1
130075: PPUSH
130076: CALL 73805 0 2
130080: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
130081: LD_EXP 216
130085: PUSH
130086: LD_VAR 0 5
130090: ARRAY
130091: PUSH
130092: LD_EXP 217
130096: GREATEREQUAL
130097: IFFALSE 130101
// exit ;
130099: GO 130301
// ComMoveXY ( unit , x , y ) ;
130101: LD_VAR 0 1
130105: PPUSH
130106: LD_VAR 0 2
130110: PPUSH
130111: LD_VAR 0 3
130115: PPUSH
130116: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
130120: LD_INT 35
130122: PPUSH
130123: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
130127: LD_VAR 0 1
130131: PPUSH
130132: LD_VAR 0 2
130136: PPUSH
130137: LD_VAR 0 3
130141: PPUSH
130142: CALL 105557 0 3
130146: NOT
130147: PUSH
130148: LD_VAR 0 1
130152: PPUSH
130153: CALL_OW 314
130157: AND
130158: IFFALSE 130162
// exit ;
130160: GO 130301
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
130162: LD_VAR 0 2
130166: PPUSH
130167: LD_VAR 0 3
130171: PPUSH
130172: CALL_OW 428
130176: PUSH
130177: LD_VAR 0 1
130181: EQUAL
130182: PUSH
130183: LD_VAR 0 1
130187: PPUSH
130188: CALL_OW 314
130192: NOT
130193: AND
130194: IFFALSE 130120
// PlaySoundXY ( x , y , PlantMine ) ;
130196: LD_VAR 0 2
130200: PPUSH
130201: LD_VAR 0 3
130205: PPUSH
130206: LD_STRING PlantMine
130208: PPUSH
130209: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
130213: LD_VAR 0 2
130217: PPUSH
130218: LD_VAR 0 3
130222: PPUSH
130223: LD_VAR 0 1
130227: PPUSH
130228: CALL_OW 255
130232: PPUSH
130233: LD_INT 0
130235: PPUSH
130236: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
130240: LD_ADDR_EXP 216
130244: PUSH
130245: LD_EXP 216
130249: PPUSH
130250: LD_VAR 0 5
130254: PUSH
130255: LD_EXP 216
130259: PUSH
130260: LD_VAR 0 5
130264: ARRAY
130265: PUSH
130266: LD_INT 1
130268: PLUS
130269: PUSH
130270: EMPTY
130271: LIST
130272: LIST
130273: PPUSH
130274: LD_VAR 0 2
130278: PUSH
130279: LD_VAR 0 3
130283: PUSH
130284: EMPTY
130285: LIST
130286: LIST
130287: PPUSH
130288: CALL 74020 0 3
130292: ST_TO_ADDR
// result := true ;
130293: LD_ADDR_VAR 0 4
130297: PUSH
130298: LD_INT 1
130300: ST_TO_ADDR
// end ;
130301: LD_VAR 0 4
130305: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
130306: LD_INT 0
130308: PPUSH
130309: PPUSH
130310: PPUSH
// if not unit in minersList then
130311: LD_VAR 0 1
130315: PUSH
130316: LD_EXP 215
130320: IN
130321: NOT
130322: IFFALSE 130326
// exit ;
130324: GO 130718
// index := GetElementIndex ( minersList , unit ) ;
130326: LD_ADDR_VAR 0 6
130330: PUSH
130331: LD_EXP 215
130335: PPUSH
130336: LD_VAR 0 1
130340: PPUSH
130341: CALL 73805 0 2
130345: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
130346: LD_ADDR_VAR 0 5
130350: PUSH
130351: DOUBLE
130352: LD_EXP 216
130356: PUSH
130357: LD_VAR 0 6
130361: ARRAY
130362: INC
130363: ST_TO_ADDR
130364: LD_INT 1
130366: PUSH
130367: FOR_DOWNTO
130368: IFFALSE 130529
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
130370: LD_EXP 216
130374: PUSH
130375: LD_VAR 0 6
130379: ARRAY
130380: PUSH
130381: LD_VAR 0 5
130385: ARRAY
130386: PUSH
130387: LD_INT 1
130389: ARRAY
130390: PUSH
130391: LD_VAR 0 2
130395: EQUAL
130396: PUSH
130397: LD_EXP 216
130401: PUSH
130402: LD_VAR 0 6
130406: ARRAY
130407: PUSH
130408: LD_VAR 0 5
130412: ARRAY
130413: PUSH
130414: LD_INT 2
130416: ARRAY
130417: PUSH
130418: LD_VAR 0 3
130422: EQUAL
130423: AND
130424: IFFALSE 130527
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
130426: LD_EXP 216
130430: PUSH
130431: LD_VAR 0 6
130435: ARRAY
130436: PUSH
130437: LD_VAR 0 5
130441: ARRAY
130442: PUSH
130443: LD_INT 1
130445: ARRAY
130446: PPUSH
130447: LD_EXP 216
130451: PUSH
130452: LD_VAR 0 6
130456: ARRAY
130457: PUSH
130458: LD_VAR 0 5
130462: ARRAY
130463: PUSH
130464: LD_INT 2
130466: ARRAY
130467: PPUSH
130468: LD_VAR 0 1
130472: PPUSH
130473: CALL_OW 255
130477: PPUSH
130478: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
130482: LD_ADDR_EXP 216
130486: PUSH
130487: LD_EXP 216
130491: PPUSH
130492: LD_VAR 0 6
130496: PPUSH
130497: LD_EXP 216
130501: PUSH
130502: LD_VAR 0 6
130506: ARRAY
130507: PPUSH
130508: LD_VAR 0 5
130512: PPUSH
130513: CALL_OW 3
130517: PPUSH
130518: CALL_OW 1
130522: ST_TO_ADDR
// exit ;
130523: POP
130524: POP
130525: GO 130718
// end ; end ;
130527: GO 130367
130529: POP
130530: POP
// for i := minerMinesList [ index ] downto 1 do
130531: LD_ADDR_VAR 0 5
130535: PUSH
130536: DOUBLE
130537: LD_EXP 216
130541: PUSH
130542: LD_VAR 0 6
130546: ARRAY
130547: INC
130548: ST_TO_ADDR
130549: LD_INT 1
130551: PUSH
130552: FOR_DOWNTO
130553: IFFALSE 130716
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
130555: LD_EXP 216
130559: PUSH
130560: LD_VAR 0 6
130564: ARRAY
130565: PUSH
130566: LD_VAR 0 5
130570: ARRAY
130571: PUSH
130572: LD_INT 1
130574: ARRAY
130575: PPUSH
130576: LD_EXP 216
130580: PUSH
130581: LD_VAR 0 6
130585: ARRAY
130586: PUSH
130587: LD_VAR 0 5
130591: ARRAY
130592: PUSH
130593: LD_INT 2
130595: ARRAY
130596: PPUSH
130597: LD_VAR 0 2
130601: PPUSH
130602: LD_VAR 0 3
130606: PPUSH
130607: CALL_OW 298
130611: PUSH
130612: LD_INT 6
130614: LESS
130615: IFFALSE 130714
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
130617: LD_EXP 216
130621: PUSH
130622: LD_VAR 0 6
130626: ARRAY
130627: PUSH
130628: LD_VAR 0 5
130632: ARRAY
130633: PUSH
130634: LD_INT 1
130636: ARRAY
130637: PPUSH
130638: LD_EXP 216
130642: PUSH
130643: LD_VAR 0 6
130647: ARRAY
130648: PUSH
130649: LD_VAR 0 5
130653: ARRAY
130654: PUSH
130655: LD_INT 2
130657: ARRAY
130658: PPUSH
130659: LD_VAR 0 1
130663: PPUSH
130664: CALL_OW 255
130668: PPUSH
130669: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
130673: LD_ADDR_EXP 216
130677: PUSH
130678: LD_EXP 216
130682: PPUSH
130683: LD_VAR 0 6
130687: PPUSH
130688: LD_EXP 216
130692: PUSH
130693: LD_VAR 0 6
130697: ARRAY
130698: PPUSH
130699: LD_VAR 0 5
130703: PPUSH
130704: CALL_OW 3
130708: PPUSH
130709: CALL_OW 1
130713: ST_TO_ADDR
// end ; end ;
130714: GO 130552
130716: POP
130717: POP
// end ;
130718: LD_VAR 0 4
130722: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
130723: LD_INT 0
130725: PPUSH
130726: PPUSH
130727: PPUSH
130728: PPUSH
130729: PPUSH
130730: PPUSH
130731: PPUSH
130732: PPUSH
130733: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
130734: LD_VAR 0 1
130738: PPUSH
130739: CALL_OW 264
130743: PUSH
130744: LD_INT 81
130746: EQUAL
130747: NOT
130748: PUSH
130749: LD_VAR 0 1
130753: PUSH
130754: LD_EXP 215
130758: IN
130759: NOT
130760: OR
130761: IFFALSE 130765
// exit ;
130763: GO 131087
// index := GetElementIndex ( minersList , unit ) ;
130765: LD_ADDR_VAR 0 6
130769: PUSH
130770: LD_EXP 215
130774: PPUSH
130775: LD_VAR 0 1
130779: PPUSH
130780: CALL 73805 0 2
130784: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
130785: LD_ADDR_VAR 0 8
130789: PUSH
130790: LD_EXP 217
130794: PUSH
130795: LD_EXP 216
130799: PUSH
130800: LD_VAR 0 6
130804: ARRAY
130805: MINUS
130806: ST_TO_ADDR
// if not minesFreeAmount then
130807: LD_VAR 0 8
130811: NOT
130812: IFFALSE 130816
// exit ;
130814: GO 131087
// tmp := [ ] ;
130816: LD_ADDR_VAR 0 7
130820: PUSH
130821: EMPTY
130822: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
130823: LD_ADDR_VAR 0 5
130827: PUSH
130828: DOUBLE
130829: LD_INT 1
130831: DEC
130832: ST_TO_ADDR
130833: LD_VAR 0 8
130837: PUSH
130838: FOR_TO
130839: IFFALSE 131034
// begin _d := rand ( 0 , 5 ) ;
130841: LD_ADDR_VAR 0 11
130845: PUSH
130846: LD_INT 0
130848: PPUSH
130849: LD_INT 5
130851: PPUSH
130852: CALL_OW 12
130856: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
130857: LD_ADDR_VAR 0 12
130861: PUSH
130862: LD_INT 2
130864: PPUSH
130865: LD_INT 6
130867: PPUSH
130868: CALL_OW 12
130872: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
130873: LD_ADDR_VAR 0 9
130877: PUSH
130878: LD_VAR 0 2
130882: PPUSH
130883: LD_VAR 0 11
130887: PPUSH
130888: LD_VAR 0 12
130892: PPUSH
130893: CALL_OW 272
130897: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
130898: LD_ADDR_VAR 0 10
130902: PUSH
130903: LD_VAR 0 3
130907: PPUSH
130908: LD_VAR 0 11
130912: PPUSH
130913: LD_VAR 0 12
130917: PPUSH
130918: CALL_OW 273
130922: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
130923: LD_VAR 0 9
130927: PPUSH
130928: LD_VAR 0 10
130932: PPUSH
130933: CALL_OW 488
130937: PUSH
130938: LD_VAR 0 9
130942: PUSH
130943: LD_VAR 0 10
130947: PUSH
130948: EMPTY
130949: LIST
130950: LIST
130951: PUSH
130952: LD_VAR 0 7
130956: IN
130957: NOT
130958: AND
130959: PUSH
130960: LD_VAR 0 9
130964: PPUSH
130965: LD_VAR 0 10
130969: PPUSH
130970: CALL_OW 458
130974: NOT
130975: AND
130976: IFFALSE 131018
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
130978: LD_ADDR_VAR 0 7
130982: PUSH
130983: LD_VAR 0 7
130987: PPUSH
130988: LD_VAR 0 7
130992: PUSH
130993: LD_INT 1
130995: PLUS
130996: PPUSH
130997: LD_VAR 0 9
131001: PUSH
131002: LD_VAR 0 10
131006: PUSH
131007: EMPTY
131008: LIST
131009: LIST
131010: PPUSH
131011: CALL_OW 1
131015: ST_TO_ADDR
131016: GO 131032
// i := i - 1 ;
131018: LD_ADDR_VAR 0 5
131022: PUSH
131023: LD_VAR 0 5
131027: PUSH
131028: LD_INT 1
131030: MINUS
131031: ST_TO_ADDR
// end ;
131032: GO 130838
131034: POP
131035: POP
// for i in tmp do
131036: LD_ADDR_VAR 0 5
131040: PUSH
131041: LD_VAR 0 7
131045: PUSH
131046: FOR_IN
131047: IFFALSE 131085
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
131049: LD_VAR 0 1
131053: PPUSH
131054: LD_VAR 0 5
131058: PUSH
131059: LD_INT 1
131061: ARRAY
131062: PPUSH
131063: LD_VAR 0 5
131067: PUSH
131068: LD_INT 2
131070: ARRAY
131071: PPUSH
131072: CALL 130031 0 3
131076: NOT
131077: IFFALSE 131083
// exit ;
131079: POP
131080: POP
131081: GO 131087
131083: GO 131046
131085: POP
131086: POP
// end ;
131087: LD_VAR 0 4
131091: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
131092: LD_INT 0
131094: PPUSH
131095: PPUSH
131096: PPUSH
131097: PPUSH
131098: PPUSH
131099: PPUSH
131100: PPUSH
// if not GetClass ( unit ) = class_sniper then
131101: LD_VAR 0 1
131105: PPUSH
131106: CALL_OW 257
131110: PUSH
131111: LD_INT 5
131113: EQUAL
131114: NOT
131115: IFFALSE 131119
// exit ;
131117: GO 131507
// dist := 8 ;
131119: LD_ADDR_VAR 0 5
131123: PUSH
131124: LD_INT 8
131126: ST_TO_ADDR
// viewRange := 12 ;
131127: LD_ADDR_VAR 0 7
131131: PUSH
131132: LD_INT 12
131134: ST_TO_ADDR
// side := GetSide ( unit ) ;
131135: LD_ADDR_VAR 0 6
131139: PUSH
131140: LD_VAR 0 1
131144: PPUSH
131145: CALL_OW 255
131149: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
131150: LD_INT 61
131152: PPUSH
131153: LD_VAR 0 6
131157: PPUSH
131158: CALL_OW 321
131162: PUSH
131163: LD_INT 2
131165: EQUAL
131166: IFFALSE 131176
// viewRange := 16 ;
131168: LD_ADDR_VAR 0 7
131172: PUSH
131173: LD_INT 16
131175: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
131176: LD_VAR 0 1
131180: PPUSH
131181: LD_VAR 0 2
131185: PPUSH
131186: LD_VAR 0 3
131190: PPUSH
131191: CALL_OW 297
131195: PUSH
131196: LD_VAR 0 5
131200: GREATER
131201: IFFALSE 131280
// begin ComMoveXY ( unit , x , y ) ;
131203: LD_VAR 0 1
131207: PPUSH
131208: LD_VAR 0 2
131212: PPUSH
131213: LD_VAR 0 3
131217: PPUSH
131218: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131222: LD_INT 35
131224: PPUSH
131225: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
131229: LD_VAR 0 1
131233: PPUSH
131234: LD_VAR 0 2
131238: PPUSH
131239: LD_VAR 0 3
131243: PPUSH
131244: CALL 105557 0 3
131248: NOT
131249: IFFALSE 131253
// exit ;
131251: GO 131507
// until GetDistUnitXY ( unit , x , y ) < dist ;
131253: LD_VAR 0 1
131257: PPUSH
131258: LD_VAR 0 2
131262: PPUSH
131263: LD_VAR 0 3
131267: PPUSH
131268: CALL_OW 297
131272: PUSH
131273: LD_VAR 0 5
131277: LESS
131278: IFFALSE 131222
// end ; ComTurnXY ( unit , x , y ) ;
131280: LD_VAR 0 1
131284: PPUSH
131285: LD_VAR 0 2
131289: PPUSH
131290: LD_VAR 0 3
131294: PPUSH
131295: CALL_OW 118
// wait ( 5 ) ;
131299: LD_INT 5
131301: PPUSH
131302: CALL_OW 67
// _d := GetDir ( unit ) ;
131306: LD_ADDR_VAR 0 10
131310: PUSH
131311: LD_VAR 0 1
131315: PPUSH
131316: CALL_OW 254
131320: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
131321: LD_ADDR_VAR 0 8
131325: PUSH
131326: LD_VAR 0 1
131330: PPUSH
131331: CALL_OW 250
131335: PPUSH
131336: LD_VAR 0 10
131340: PPUSH
131341: LD_VAR 0 5
131345: PPUSH
131346: CALL_OW 272
131350: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
131351: LD_ADDR_VAR 0 9
131355: PUSH
131356: LD_VAR 0 1
131360: PPUSH
131361: CALL_OW 251
131365: PPUSH
131366: LD_VAR 0 10
131370: PPUSH
131371: LD_VAR 0 5
131375: PPUSH
131376: CALL_OW 273
131380: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
131381: LD_VAR 0 8
131385: PPUSH
131386: LD_VAR 0 9
131390: PPUSH
131391: CALL_OW 488
131395: NOT
131396: IFFALSE 131400
// exit ;
131398: GO 131507
// ComAnimCustom ( unit , 1 ) ;
131400: LD_VAR 0 1
131404: PPUSH
131405: LD_INT 1
131407: PPUSH
131408: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
131412: LD_VAR 0 8
131416: PPUSH
131417: LD_VAR 0 9
131421: PPUSH
131422: LD_VAR 0 6
131426: PPUSH
131427: LD_VAR 0 7
131431: PPUSH
131432: CALL_OW 330
// repeat wait ( 1 ) ;
131436: LD_INT 1
131438: PPUSH
131439: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
131443: LD_VAR 0 1
131447: PPUSH
131448: CALL_OW 316
131452: PUSH
131453: LD_VAR 0 1
131457: PPUSH
131458: CALL_OW 314
131462: OR
131463: PUSH
131464: LD_VAR 0 1
131468: PPUSH
131469: CALL_OW 302
131473: NOT
131474: OR
131475: PUSH
131476: LD_VAR 0 1
131480: PPUSH
131481: CALL_OW 301
131485: OR
131486: IFFALSE 131436
// RemoveSeeing ( _x , _y , side ) ;
131488: LD_VAR 0 8
131492: PPUSH
131493: LD_VAR 0 9
131497: PPUSH
131498: LD_VAR 0 6
131502: PPUSH
131503: CALL_OW 331
// end ; end_of_file
131507: LD_VAR 0 4
131511: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
131512: LD_INT 0
131514: PPUSH
131515: PPUSH
131516: PPUSH
131517: PPUSH
131518: PPUSH
131519: PPUSH
131520: PPUSH
131521: PPUSH
131522: PPUSH
131523: PPUSH
131524: PPUSH
131525: PPUSH
131526: PPUSH
131527: PPUSH
131528: PPUSH
131529: PPUSH
131530: PPUSH
131531: PPUSH
131532: PPUSH
131533: PPUSH
131534: PPUSH
131535: PPUSH
131536: PPUSH
131537: PPUSH
131538: PPUSH
131539: PPUSH
131540: PPUSH
131541: PPUSH
131542: PPUSH
131543: PPUSH
131544: PPUSH
131545: PPUSH
131546: PPUSH
131547: PPUSH
// if not list then
131548: LD_VAR 0 1
131552: NOT
131553: IFFALSE 131557
// exit ;
131555: GO 136216
// base := list [ 1 ] ;
131557: LD_ADDR_VAR 0 3
131561: PUSH
131562: LD_VAR 0 1
131566: PUSH
131567: LD_INT 1
131569: ARRAY
131570: ST_TO_ADDR
// group := list [ 2 ] ;
131571: LD_ADDR_VAR 0 4
131575: PUSH
131576: LD_VAR 0 1
131580: PUSH
131581: LD_INT 2
131583: ARRAY
131584: ST_TO_ADDR
// path := list [ 3 ] ;
131585: LD_ADDR_VAR 0 5
131589: PUSH
131590: LD_VAR 0 1
131594: PUSH
131595: LD_INT 3
131597: ARRAY
131598: ST_TO_ADDR
// flags := list [ 4 ] ;
131599: LD_ADDR_VAR 0 6
131603: PUSH
131604: LD_VAR 0 1
131608: PUSH
131609: LD_INT 4
131611: ARRAY
131612: ST_TO_ADDR
// mined := [ ] ;
131613: LD_ADDR_VAR 0 27
131617: PUSH
131618: EMPTY
131619: ST_TO_ADDR
// bombed := [ ] ;
131620: LD_ADDR_VAR 0 28
131624: PUSH
131625: EMPTY
131626: ST_TO_ADDR
// healers := [ ] ;
131627: LD_ADDR_VAR 0 31
131631: PUSH
131632: EMPTY
131633: ST_TO_ADDR
// to_heal := [ ] ;
131634: LD_ADDR_VAR 0 30
131638: PUSH
131639: EMPTY
131640: ST_TO_ADDR
// repairs := [ ] ;
131641: LD_ADDR_VAR 0 33
131645: PUSH
131646: EMPTY
131647: ST_TO_ADDR
// to_repair := [ ] ;
131648: LD_ADDR_VAR 0 32
131652: PUSH
131653: EMPTY
131654: ST_TO_ADDR
// if not group or not path then
131655: LD_VAR 0 4
131659: NOT
131660: PUSH
131661: LD_VAR 0 5
131665: NOT
131666: OR
131667: IFFALSE 131671
// exit ;
131669: GO 136216
// side := GetSide ( group [ 1 ] ) ;
131671: LD_ADDR_VAR 0 35
131675: PUSH
131676: LD_VAR 0 4
131680: PUSH
131681: LD_INT 1
131683: ARRAY
131684: PPUSH
131685: CALL_OW 255
131689: ST_TO_ADDR
// if flags then
131690: LD_VAR 0 6
131694: IFFALSE 131838
// begin f_ignore_area := flags [ 1 ] ;
131696: LD_ADDR_VAR 0 17
131700: PUSH
131701: LD_VAR 0 6
131705: PUSH
131706: LD_INT 1
131708: ARRAY
131709: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
131710: LD_ADDR_VAR 0 18
131714: PUSH
131715: LD_VAR 0 6
131719: PUSH
131720: LD_INT 2
131722: ARRAY
131723: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
131724: LD_ADDR_VAR 0 19
131728: PUSH
131729: LD_VAR 0 6
131733: PUSH
131734: LD_INT 3
131736: ARRAY
131737: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
131738: LD_ADDR_VAR 0 20
131742: PUSH
131743: LD_VAR 0 6
131747: PUSH
131748: LD_INT 4
131750: ARRAY
131751: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
131752: LD_ADDR_VAR 0 21
131756: PUSH
131757: LD_VAR 0 6
131761: PUSH
131762: LD_INT 5
131764: ARRAY
131765: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
131766: LD_ADDR_VAR 0 22
131770: PUSH
131771: LD_VAR 0 6
131775: PUSH
131776: LD_INT 6
131778: ARRAY
131779: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
131780: LD_ADDR_VAR 0 23
131784: PUSH
131785: LD_VAR 0 6
131789: PUSH
131790: LD_INT 7
131792: ARRAY
131793: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
131794: LD_ADDR_VAR 0 24
131798: PUSH
131799: LD_VAR 0 6
131803: PUSH
131804: LD_INT 8
131806: ARRAY
131807: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
131808: LD_ADDR_VAR 0 25
131812: PUSH
131813: LD_VAR 0 6
131817: PUSH
131818: LD_INT 9
131820: ARRAY
131821: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
131822: LD_ADDR_VAR 0 26
131826: PUSH
131827: LD_VAR 0 6
131831: PUSH
131832: LD_INT 10
131834: ARRAY
131835: ST_TO_ADDR
// end else
131836: GO 131918
// begin f_ignore_area := false ;
131838: LD_ADDR_VAR 0 17
131842: PUSH
131843: LD_INT 0
131845: ST_TO_ADDR
// f_capture := false ;
131846: LD_ADDR_VAR 0 18
131850: PUSH
131851: LD_INT 0
131853: ST_TO_ADDR
// f_ignore_civ := false ;
131854: LD_ADDR_VAR 0 19
131858: PUSH
131859: LD_INT 0
131861: ST_TO_ADDR
// f_murder := false ;
131862: LD_ADDR_VAR 0 20
131866: PUSH
131867: LD_INT 0
131869: ST_TO_ADDR
// f_mines := false ;
131870: LD_ADDR_VAR 0 21
131874: PUSH
131875: LD_INT 0
131877: ST_TO_ADDR
// f_repair := false ;
131878: LD_ADDR_VAR 0 22
131882: PUSH
131883: LD_INT 0
131885: ST_TO_ADDR
// f_heal := false ;
131886: LD_ADDR_VAR 0 23
131890: PUSH
131891: LD_INT 0
131893: ST_TO_ADDR
// f_spacetime := false ;
131894: LD_ADDR_VAR 0 24
131898: PUSH
131899: LD_INT 0
131901: ST_TO_ADDR
// f_attack_depot := false ;
131902: LD_ADDR_VAR 0 25
131906: PUSH
131907: LD_INT 0
131909: ST_TO_ADDR
// f_crawl := false ;
131910: LD_ADDR_VAR 0 26
131914: PUSH
131915: LD_INT 0
131917: ST_TO_ADDR
// end ; if f_heal then
131918: LD_VAR 0 23
131922: IFFALSE 131949
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
131924: LD_ADDR_VAR 0 31
131928: PUSH
131929: LD_VAR 0 4
131933: PPUSH
131934: LD_INT 25
131936: PUSH
131937: LD_INT 4
131939: PUSH
131940: EMPTY
131941: LIST
131942: LIST
131943: PPUSH
131944: CALL_OW 72
131948: ST_TO_ADDR
// if f_repair then
131949: LD_VAR 0 22
131953: IFFALSE 131980
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
131955: LD_ADDR_VAR 0 33
131959: PUSH
131960: LD_VAR 0 4
131964: PPUSH
131965: LD_INT 25
131967: PUSH
131968: LD_INT 3
131970: PUSH
131971: EMPTY
131972: LIST
131973: LIST
131974: PPUSH
131975: CALL_OW 72
131979: ST_TO_ADDR
// units_path := [ ] ;
131980: LD_ADDR_VAR 0 16
131984: PUSH
131985: EMPTY
131986: ST_TO_ADDR
// for i = 1 to group do
131987: LD_ADDR_VAR 0 7
131991: PUSH
131992: DOUBLE
131993: LD_INT 1
131995: DEC
131996: ST_TO_ADDR
131997: LD_VAR 0 4
132001: PUSH
132002: FOR_TO
132003: IFFALSE 132032
// units_path := Replace ( units_path , i , path ) ;
132005: LD_ADDR_VAR 0 16
132009: PUSH
132010: LD_VAR 0 16
132014: PPUSH
132015: LD_VAR 0 7
132019: PPUSH
132020: LD_VAR 0 5
132024: PPUSH
132025: CALL_OW 1
132029: ST_TO_ADDR
132030: GO 132002
132032: POP
132033: POP
// repeat for i = group downto 1 do
132034: LD_ADDR_VAR 0 7
132038: PUSH
132039: DOUBLE
132040: LD_VAR 0 4
132044: INC
132045: ST_TO_ADDR
132046: LD_INT 1
132048: PUSH
132049: FOR_DOWNTO
132050: IFFALSE 136172
// begin wait ( 5 ) ;
132052: LD_INT 5
132054: PPUSH
132055: CALL_OW 67
// tmp := [ ] ;
132059: LD_ADDR_VAR 0 14
132063: PUSH
132064: EMPTY
132065: ST_TO_ADDR
// attacking := false ;
132066: LD_ADDR_VAR 0 29
132070: PUSH
132071: LD_INT 0
132073: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
132074: LD_VAR 0 4
132078: PUSH
132079: LD_VAR 0 7
132083: ARRAY
132084: PPUSH
132085: CALL_OW 301
132089: PUSH
132090: LD_VAR 0 4
132094: PUSH
132095: LD_VAR 0 7
132099: ARRAY
132100: NOT
132101: OR
132102: IFFALSE 132211
// begin if GetType ( group [ i ] ) = unit_human then
132104: LD_VAR 0 4
132108: PUSH
132109: LD_VAR 0 7
132113: ARRAY
132114: PPUSH
132115: CALL_OW 247
132119: PUSH
132120: LD_INT 1
132122: EQUAL
132123: IFFALSE 132169
// begin to_heal := to_heal diff group [ i ] ;
132125: LD_ADDR_VAR 0 30
132129: PUSH
132130: LD_VAR 0 30
132134: PUSH
132135: LD_VAR 0 4
132139: PUSH
132140: LD_VAR 0 7
132144: ARRAY
132145: DIFF
132146: ST_TO_ADDR
// healers := healers diff group [ i ] ;
132147: LD_ADDR_VAR 0 31
132151: PUSH
132152: LD_VAR 0 31
132156: PUSH
132157: LD_VAR 0 4
132161: PUSH
132162: LD_VAR 0 7
132166: ARRAY
132167: DIFF
132168: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
132169: LD_ADDR_VAR 0 4
132173: PUSH
132174: LD_VAR 0 4
132178: PPUSH
132179: LD_VAR 0 7
132183: PPUSH
132184: CALL_OW 3
132188: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
132189: LD_ADDR_VAR 0 16
132193: PUSH
132194: LD_VAR 0 16
132198: PPUSH
132199: LD_VAR 0 7
132203: PPUSH
132204: CALL_OW 3
132208: ST_TO_ADDR
// continue ;
132209: GO 132049
// end ; if f_repair then
132211: LD_VAR 0 22
132215: IFFALSE 132704
// begin if GetType ( group [ i ] ) = unit_vehicle then
132217: LD_VAR 0 4
132221: PUSH
132222: LD_VAR 0 7
132226: ARRAY
132227: PPUSH
132228: CALL_OW 247
132232: PUSH
132233: LD_INT 2
132235: EQUAL
132236: IFFALSE 132426
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
132238: LD_VAR 0 4
132242: PUSH
132243: LD_VAR 0 7
132247: ARRAY
132248: PPUSH
132249: CALL_OW 256
132253: PUSH
132254: LD_INT 700
132256: LESS
132257: PUSH
132258: LD_VAR 0 4
132262: PUSH
132263: LD_VAR 0 7
132267: ARRAY
132268: PUSH
132269: LD_VAR 0 32
132273: IN
132274: NOT
132275: AND
132276: IFFALSE 132300
// to_repair := to_repair union group [ i ] ;
132278: LD_ADDR_VAR 0 32
132282: PUSH
132283: LD_VAR 0 32
132287: PUSH
132288: LD_VAR 0 4
132292: PUSH
132293: LD_VAR 0 7
132297: ARRAY
132298: UNION
132299: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
132300: LD_VAR 0 4
132304: PUSH
132305: LD_VAR 0 7
132309: ARRAY
132310: PPUSH
132311: CALL_OW 256
132315: PUSH
132316: LD_INT 1000
132318: EQUAL
132319: PUSH
132320: LD_VAR 0 4
132324: PUSH
132325: LD_VAR 0 7
132329: ARRAY
132330: PUSH
132331: LD_VAR 0 32
132335: IN
132336: AND
132337: IFFALSE 132361
// to_repair := to_repair diff group [ i ] ;
132339: LD_ADDR_VAR 0 32
132343: PUSH
132344: LD_VAR 0 32
132348: PUSH
132349: LD_VAR 0 4
132353: PUSH
132354: LD_VAR 0 7
132358: ARRAY
132359: DIFF
132360: ST_TO_ADDR
// if group [ i ] in to_repair then
132361: LD_VAR 0 4
132365: PUSH
132366: LD_VAR 0 7
132370: ARRAY
132371: PUSH
132372: LD_VAR 0 32
132376: IN
132377: IFFALSE 132424
// begin if not IsInArea ( group [ i ] , f_repair ) then
132379: LD_VAR 0 4
132383: PUSH
132384: LD_VAR 0 7
132388: ARRAY
132389: PPUSH
132390: LD_VAR 0 22
132394: PPUSH
132395: CALL_OW 308
132399: NOT
132400: IFFALSE 132422
// ComMoveToArea ( group [ i ] , f_repair ) ;
132402: LD_VAR 0 4
132406: PUSH
132407: LD_VAR 0 7
132411: ARRAY
132412: PPUSH
132413: LD_VAR 0 22
132417: PPUSH
132418: CALL_OW 113
// continue ;
132422: GO 132049
// end ; end else
132424: GO 132704
// if group [ i ] in repairs then
132426: LD_VAR 0 4
132430: PUSH
132431: LD_VAR 0 7
132435: ARRAY
132436: PUSH
132437: LD_VAR 0 33
132441: IN
132442: IFFALSE 132704
// begin if IsInUnit ( group [ i ] ) then
132444: LD_VAR 0 4
132448: PUSH
132449: LD_VAR 0 7
132453: ARRAY
132454: PPUSH
132455: CALL_OW 310
132459: IFFALSE 132527
// begin z := IsInUnit ( group [ i ] ) ;
132461: LD_ADDR_VAR 0 13
132465: PUSH
132466: LD_VAR 0 4
132470: PUSH
132471: LD_VAR 0 7
132475: ARRAY
132476: PPUSH
132477: CALL_OW 310
132481: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
132482: LD_VAR 0 13
132486: PUSH
132487: LD_VAR 0 32
132491: IN
132492: PUSH
132493: LD_VAR 0 13
132497: PPUSH
132498: LD_VAR 0 22
132502: PPUSH
132503: CALL_OW 308
132507: AND
132508: IFFALSE 132525
// ComExitVehicle ( group [ i ] ) ;
132510: LD_VAR 0 4
132514: PUSH
132515: LD_VAR 0 7
132519: ARRAY
132520: PPUSH
132521: CALL_OW 121
// end else
132525: GO 132704
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
132527: LD_ADDR_VAR 0 13
132531: PUSH
132532: LD_VAR 0 4
132536: PPUSH
132537: LD_INT 95
132539: PUSH
132540: LD_VAR 0 22
132544: PUSH
132545: EMPTY
132546: LIST
132547: LIST
132548: PUSH
132549: LD_INT 58
132551: PUSH
132552: EMPTY
132553: LIST
132554: PUSH
132555: EMPTY
132556: LIST
132557: LIST
132558: PPUSH
132559: CALL_OW 72
132563: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
132564: LD_VAR 0 4
132568: PUSH
132569: LD_VAR 0 7
132573: ARRAY
132574: PPUSH
132575: CALL_OW 314
132579: NOT
132580: IFFALSE 132702
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
132582: LD_ADDR_VAR 0 10
132586: PUSH
132587: LD_VAR 0 13
132591: PPUSH
132592: LD_VAR 0 4
132596: PUSH
132597: LD_VAR 0 7
132601: ARRAY
132602: PPUSH
132603: CALL_OW 74
132607: ST_TO_ADDR
// if not x then
132608: LD_VAR 0 10
132612: NOT
132613: IFFALSE 132617
// continue ;
132615: GO 132049
// if GetLives ( x ) < 1000 then
132617: LD_VAR 0 10
132621: PPUSH
132622: CALL_OW 256
132626: PUSH
132627: LD_INT 1000
132629: LESS
132630: IFFALSE 132654
// ComRepairVehicle ( group [ i ] , x ) else
132632: LD_VAR 0 4
132636: PUSH
132637: LD_VAR 0 7
132641: ARRAY
132642: PPUSH
132643: LD_VAR 0 10
132647: PPUSH
132648: CALL_OW 129
132652: GO 132702
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
132654: LD_VAR 0 23
132658: PUSH
132659: LD_VAR 0 4
132663: PUSH
132664: LD_VAR 0 7
132668: ARRAY
132669: PPUSH
132670: CALL_OW 256
132674: PUSH
132675: LD_INT 1000
132677: LESS
132678: AND
132679: NOT
132680: IFFALSE 132702
// ComEnterUnit ( group [ i ] , x ) ;
132682: LD_VAR 0 4
132686: PUSH
132687: LD_VAR 0 7
132691: ARRAY
132692: PPUSH
132693: LD_VAR 0 10
132697: PPUSH
132698: CALL_OW 120
// end ; continue ;
132702: GO 132049
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
132704: LD_VAR 0 23
132708: PUSH
132709: LD_VAR 0 4
132713: PUSH
132714: LD_VAR 0 7
132718: ARRAY
132719: PPUSH
132720: CALL_OW 247
132724: PUSH
132725: LD_INT 1
132727: EQUAL
132728: AND
132729: IFFALSE 133207
// begin if group [ i ] in healers then
132731: LD_VAR 0 4
132735: PUSH
132736: LD_VAR 0 7
132740: ARRAY
132741: PUSH
132742: LD_VAR 0 31
132746: IN
132747: IFFALSE 133020
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
132749: LD_VAR 0 4
132753: PUSH
132754: LD_VAR 0 7
132758: ARRAY
132759: PPUSH
132760: LD_VAR 0 23
132764: PPUSH
132765: CALL_OW 308
132769: NOT
132770: PUSH
132771: LD_VAR 0 4
132775: PUSH
132776: LD_VAR 0 7
132780: ARRAY
132781: PPUSH
132782: CALL_OW 314
132786: NOT
132787: AND
132788: IFFALSE 132812
// ComMoveToArea ( group [ i ] , f_heal ) else
132790: LD_VAR 0 4
132794: PUSH
132795: LD_VAR 0 7
132799: ARRAY
132800: PPUSH
132801: LD_VAR 0 23
132805: PPUSH
132806: CALL_OW 113
132810: GO 133018
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
132812: LD_VAR 0 4
132816: PUSH
132817: LD_VAR 0 7
132821: ARRAY
132822: PPUSH
132823: CALL 104140 0 1
132827: PPUSH
132828: CALL_OW 256
132832: PUSH
132833: LD_INT 1000
132835: EQUAL
132836: IFFALSE 132855
// ComStop ( group [ i ] ) else
132838: LD_VAR 0 4
132842: PUSH
132843: LD_VAR 0 7
132847: ARRAY
132848: PPUSH
132849: CALL_OW 141
132853: GO 133018
// if not HasTask ( group [ i ] ) and to_heal then
132855: LD_VAR 0 4
132859: PUSH
132860: LD_VAR 0 7
132864: ARRAY
132865: PPUSH
132866: CALL_OW 314
132870: NOT
132871: PUSH
132872: LD_VAR 0 30
132876: AND
132877: IFFALSE 133018
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
132879: LD_ADDR_VAR 0 13
132883: PUSH
132884: LD_VAR 0 30
132888: PPUSH
132889: LD_INT 3
132891: PUSH
132892: LD_INT 54
132894: PUSH
132895: EMPTY
132896: LIST
132897: PUSH
132898: EMPTY
132899: LIST
132900: LIST
132901: PPUSH
132902: CALL_OW 72
132906: PPUSH
132907: LD_VAR 0 4
132911: PUSH
132912: LD_VAR 0 7
132916: ARRAY
132917: PPUSH
132918: CALL_OW 74
132922: ST_TO_ADDR
// if z then
132923: LD_VAR 0 13
132927: IFFALSE 133018
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
132929: LD_INT 91
132931: PUSH
132932: LD_VAR 0 13
132936: PUSH
132937: LD_INT 10
132939: PUSH
132940: EMPTY
132941: LIST
132942: LIST
132943: LIST
132944: PUSH
132945: LD_INT 81
132947: PUSH
132948: LD_VAR 0 13
132952: PPUSH
132953: CALL_OW 255
132957: PUSH
132958: EMPTY
132959: LIST
132960: LIST
132961: PUSH
132962: EMPTY
132963: LIST
132964: LIST
132965: PPUSH
132966: CALL_OW 69
132970: PUSH
132971: LD_INT 0
132973: EQUAL
132974: IFFALSE 132998
// ComHeal ( group [ i ] , z ) else
132976: LD_VAR 0 4
132980: PUSH
132981: LD_VAR 0 7
132985: ARRAY
132986: PPUSH
132987: LD_VAR 0 13
132991: PPUSH
132992: CALL_OW 128
132996: GO 133018
// ComMoveToArea ( group [ i ] , f_heal ) ;
132998: LD_VAR 0 4
133002: PUSH
133003: LD_VAR 0 7
133007: ARRAY
133008: PPUSH
133009: LD_VAR 0 23
133013: PPUSH
133014: CALL_OW 113
// end ; continue ;
133018: GO 132049
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
133020: LD_VAR 0 4
133024: PUSH
133025: LD_VAR 0 7
133029: ARRAY
133030: PPUSH
133031: CALL_OW 256
133035: PUSH
133036: LD_INT 700
133038: LESS
133039: PUSH
133040: LD_VAR 0 4
133044: PUSH
133045: LD_VAR 0 7
133049: ARRAY
133050: PUSH
133051: LD_VAR 0 30
133055: IN
133056: NOT
133057: AND
133058: IFFALSE 133082
// to_heal := to_heal union group [ i ] ;
133060: LD_ADDR_VAR 0 30
133064: PUSH
133065: LD_VAR 0 30
133069: PUSH
133070: LD_VAR 0 4
133074: PUSH
133075: LD_VAR 0 7
133079: ARRAY
133080: UNION
133081: ST_TO_ADDR
// if group [ i ] in to_heal then
133082: LD_VAR 0 4
133086: PUSH
133087: LD_VAR 0 7
133091: ARRAY
133092: PUSH
133093: LD_VAR 0 30
133097: IN
133098: IFFALSE 133207
// begin if GetLives ( group [ i ] ) = 1000 then
133100: LD_VAR 0 4
133104: PUSH
133105: LD_VAR 0 7
133109: ARRAY
133110: PPUSH
133111: CALL_OW 256
133115: PUSH
133116: LD_INT 1000
133118: EQUAL
133119: IFFALSE 133145
// to_heal := to_heal diff group [ i ] else
133121: LD_ADDR_VAR 0 30
133125: PUSH
133126: LD_VAR 0 30
133130: PUSH
133131: LD_VAR 0 4
133135: PUSH
133136: LD_VAR 0 7
133140: ARRAY
133141: DIFF
133142: ST_TO_ADDR
133143: GO 133207
// begin if not IsInArea ( group [ i ] , to_heal ) then
133145: LD_VAR 0 4
133149: PUSH
133150: LD_VAR 0 7
133154: ARRAY
133155: PPUSH
133156: LD_VAR 0 30
133160: PPUSH
133161: CALL_OW 308
133165: NOT
133166: IFFALSE 133190
// ComMoveToArea ( group [ i ] , f_heal ) else
133168: LD_VAR 0 4
133172: PUSH
133173: LD_VAR 0 7
133177: ARRAY
133178: PPUSH
133179: LD_VAR 0 23
133183: PPUSH
133184: CALL_OW 113
133188: GO 133205
// ComHold ( group [ i ] ) ;
133190: LD_VAR 0 4
133194: PUSH
133195: LD_VAR 0 7
133199: ARRAY
133200: PPUSH
133201: CALL_OW 140
// continue ;
133205: GO 132049
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
133207: LD_VAR 0 4
133211: PUSH
133212: LD_VAR 0 7
133216: ARRAY
133217: PPUSH
133218: LD_INT 10
133220: PPUSH
133221: CALL 101911 0 2
133225: NOT
133226: PUSH
133227: LD_VAR 0 16
133231: PUSH
133232: LD_VAR 0 7
133236: ARRAY
133237: PUSH
133238: EMPTY
133239: EQUAL
133240: NOT
133241: AND
133242: IFFALSE 133508
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
133244: LD_VAR 0 4
133248: PUSH
133249: LD_VAR 0 7
133253: ARRAY
133254: PPUSH
133255: CALL_OW 262
133259: PUSH
133260: LD_INT 1
133262: PUSH
133263: LD_INT 2
133265: PUSH
133266: EMPTY
133267: LIST
133268: LIST
133269: IN
133270: IFFALSE 133311
// if GetFuel ( group [ i ] ) < 10 then
133272: LD_VAR 0 4
133276: PUSH
133277: LD_VAR 0 7
133281: ARRAY
133282: PPUSH
133283: CALL_OW 261
133287: PUSH
133288: LD_INT 10
133290: LESS
133291: IFFALSE 133311
// SetFuel ( group [ i ] , 12 ) ;
133293: LD_VAR 0 4
133297: PUSH
133298: LD_VAR 0 7
133302: ARRAY
133303: PPUSH
133304: LD_INT 12
133306: PPUSH
133307: CALL_OW 240
// if units_path [ i ] then
133311: LD_VAR 0 16
133315: PUSH
133316: LD_VAR 0 7
133320: ARRAY
133321: IFFALSE 133506
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
133323: LD_VAR 0 4
133327: PUSH
133328: LD_VAR 0 7
133332: ARRAY
133333: PPUSH
133334: LD_VAR 0 16
133338: PUSH
133339: LD_VAR 0 7
133343: ARRAY
133344: PUSH
133345: LD_INT 1
133347: ARRAY
133348: PUSH
133349: LD_INT 1
133351: ARRAY
133352: PPUSH
133353: LD_VAR 0 16
133357: PUSH
133358: LD_VAR 0 7
133362: ARRAY
133363: PUSH
133364: LD_INT 1
133366: ARRAY
133367: PUSH
133368: LD_INT 2
133370: ARRAY
133371: PPUSH
133372: CALL_OW 297
133376: PUSH
133377: LD_INT 6
133379: GREATER
133380: IFFALSE 133455
// begin if not HasTask ( group [ i ] ) then
133382: LD_VAR 0 4
133386: PUSH
133387: LD_VAR 0 7
133391: ARRAY
133392: PPUSH
133393: CALL_OW 314
133397: NOT
133398: IFFALSE 133453
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
133400: LD_VAR 0 4
133404: PUSH
133405: LD_VAR 0 7
133409: ARRAY
133410: PPUSH
133411: LD_VAR 0 16
133415: PUSH
133416: LD_VAR 0 7
133420: ARRAY
133421: PUSH
133422: LD_INT 1
133424: ARRAY
133425: PUSH
133426: LD_INT 1
133428: ARRAY
133429: PPUSH
133430: LD_VAR 0 16
133434: PUSH
133435: LD_VAR 0 7
133439: ARRAY
133440: PUSH
133441: LD_INT 1
133443: ARRAY
133444: PUSH
133445: LD_INT 2
133447: ARRAY
133448: PPUSH
133449: CALL_OW 114
// end else
133453: GO 133506
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
133455: LD_ADDR_VAR 0 15
133459: PUSH
133460: LD_VAR 0 16
133464: PUSH
133465: LD_VAR 0 7
133469: ARRAY
133470: PPUSH
133471: LD_INT 1
133473: PPUSH
133474: CALL_OW 3
133478: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
133479: LD_ADDR_VAR 0 16
133483: PUSH
133484: LD_VAR 0 16
133488: PPUSH
133489: LD_VAR 0 7
133493: PPUSH
133494: LD_VAR 0 15
133498: PPUSH
133499: CALL_OW 1
133503: ST_TO_ADDR
// continue ;
133504: GO 132049
// end ; end ; end else
133506: GO 136170
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
133508: LD_ADDR_VAR 0 14
133512: PUSH
133513: LD_INT 81
133515: PUSH
133516: LD_VAR 0 4
133520: PUSH
133521: LD_VAR 0 7
133525: ARRAY
133526: PPUSH
133527: CALL_OW 255
133531: PUSH
133532: EMPTY
133533: LIST
133534: LIST
133535: PPUSH
133536: CALL_OW 69
133540: ST_TO_ADDR
// if not tmp then
133541: LD_VAR 0 14
133545: NOT
133546: IFFALSE 133550
// continue ;
133548: GO 132049
// if f_ignore_area then
133550: LD_VAR 0 17
133554: IFFALSE 133642
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
133556: LD_ADDR_VAR 0 15
133560: PUSH
133561: LD_VAR 0 14
133565: PPUSH
133566: LD_INT 3
133568: PUSH
133569: LD_INT 92
133571: PUSH
133572: LD_VAR 0 17
133576: PUSH
133577: LD_INT 1
133579: ARRAY
133580: PUSH
133581: LD_VAR 0 17
133585: PUSH
133586: LD_INT 2
133588: ARRAY
133589: PUSH
133590: LD_VAR 0 17
133594: PUSH
133595: LD_INT 3
133597: ARRAY
133598: PUSH
133599: EMPTY
133600: LIST
133601: LIST
133602: LIST
133603: LIST
133604: PUSH
133605: EMPTY
133606: LIST
133607: LIST
133608: PPUSH
133609: CALL_OW 72
133613: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
133614: LD_VAR 0 14
133618: PUSH
133619: LD_VAR 0 15
133623: DIFF
133624: IFFALSE 133642
// tmp := tmp diff tmp2 ;
133626: LD_ADDR_VAR 0 14
133630: PUSH
133631: LD_VAR 0 14
133635: PUSH
133636: LD_VAR 0 15
133640: DIFF
133641: ST_TO_ADDR
// end ; if not f_murder then
133642: LD_VAR 0 20
133646: NOT
133647: IFFALSE 133705
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
133649: LD_ADDR_VAR 0 15
133653: PUSH
133654: LD_VAR 0 14
133658: PPUSH
133659: LD_INT 3
133661: PUSH
133662: LD_INT 50
133664: PUSH
133665: EMPTY
133666: LIST
133667: PUSH
133668: EMPTY
133669: LIST
133670: LIST
133671: PPUSH
133672: CALL_OW 72
133676: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
133677: LD_VAR 0 14
133681: PUSH
133682: LD_VAR 0 15
133686: DIFF
133687: IFFALSE 133705
// tmp := tmp diff tmp2 ;
133689: LD_ADDR_VAR 0 14
133693: PUSH
133694: LD_VAR 0 14
133698: PUSH
133699: LD_VAR 0 15
133703: DIFF
133704: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
133705: LD_ADDR_VAR 0 14
133709: PUSH
133710: LD_VAR 0 4
133714: PUSH
133715: LD_VAR 0 7
133719: ARRAY
133720: PPUSH
133721: LD_VAR 0 14
133725: PPUSH
133726: LD_INT 1
133728: PPUSH
133729: LD_INT 1
133731: PPUSH
133732: CALL 74455 0 4
133736: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
133737: LD_VAR 0 4
133741: PUSH
133742: LD_VAR 0 7
133746: ARRAY
133747: PPUSH
133748: CALL_OW 257
133752: PUSH
133753: LD_INT 1
133755: EQUAL
133756: IFFALSE 134204
// begin if WantPlant ( group [ i ] ) then
133758: LD_VAR 0 4
133762: PUSH
133763: LD_VAR 0 7
133767: ARRAY
133768: PPUSH
133769: CALL 73956 0 1
133773: IFFALSE 133777
// continue ;
133775: GO 132049
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
133777: LD_VAR 0 18
133781: PUSH
133782: LD_VAR 0 4
133786: PUSH
133787: LD_VAR 0 7
133791: ARRAY
133792: PPUSH
133793: CALL_OW 310
133797: NOT
133798: AND
133799: PUSH
133800: LD_VAR 0 14
133804: PUSH
133805: LD_INT 1
133807: ARRAY
133808: PUSH
133809: LD_VAR 0 14
133813: PPUSH
133814: LD_INT 21
133816: PUSH
133817: LD_INT 2
133819: PUSH
133820: EMPTY
133821: LIST
133822: LIST
133823: PUSH
133824: LD_INT 58
133826: PUSH
133827: EMPTY
133828: LIST
133829: PUSH
133830: EMPTY
133831: LIST
133832: LIST
133833: PPUSH
133834: CALL_OW 72
133838: IN
133839: AND
133840: IFFALSE 133876
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
133842: LD_VAR 0 4
133846: PUSH
133847: LD_VAR 0 7
133851: ARRAY
133852: PPUSH
133853: LD_VAR 0 14
133857: PUSH
133858: LD_INT 1
133860: ARRAY
133861: PPUSH
133862: CALL_OW 120
// attacking := true ;
133866: LD_ADDR_VAR 0 29
133870: PUSH
133871: LD_INT 1
133873: ST_TO_ADDR
// continue ;
133874: GO 132049
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
133876: LD_VAR 0 26
133880: PUSH
133881: LD_VAR 0 4
133885: PUSH
133886: LD_VAR 0 7
133890: ARRAY
133891: PPUSH
133892: CALL_OW 257
133896: PUSH
133897: LD_INT 1
133899: EQUAL
133900: AND
133901: PUSH
133902: LD_VAR 0 4
133906: PUSH
133907: LD_VAR 0 7
133911: ARRAY
133912: PPUSH
133913: CALL_OW 256
133917: PUSH
133918: LD_INT 800
133920: LESS
133921: AND
133922: PUSH
133923: LD_VAR 0 4
133927: PUSH
133928: LD_VAR 0 7
133932: ARRAY
133933: PPUSH
133934: CALL_OW 318
133938: NOT
133939: AND
133940: IFFALSE 133957
// ComCrawl ( group [ i ] ) ;
133942: LD_VAR 0 4
133946: PUSH
133947: LD_VAR 0 7
133951: ARRAY
133952: PPUSH
133953: CALL_OW 137
// if f_mines then
133957: LD_VAR 0 21
133961: IFFALSE 134204
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
133963: LD_VAR 0 14
133967: PUSH
133968: LD_INT 1
133970: ARRAY
133971: PPUSH
133972: CALL_OW 247
133976: PUSH
133977: LD_INT 3
133979: EQUAL
133980: PUSH
133981: LD_VAR 0 14
133985: PUSH
133986: LD_INT 1
133988: ARRAY
133989: PUSH
133990: LD_VAR 0 27
133994: IN
133995: NOT
133996: AND
133997: IFFALSE 134204
// begin x := GetX ( tmp [ 1 ] ) ;
133999: LD_ADDR_VAR 0 10
134003: PUSH
134004: LD_VAR 0 14
134008: PUSH
134009: LD_INT 1
134011: ARRAY
134012: PPUSH
134013: CALL_OW 250
134017: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
134018: LD_ADDR_VAR 0 11
134022: PUSH
134023: LD_VAR 0 14
134027: PUSH
134028: LD_INT 1
134030: ARRAY
134031: PPUSH
134032: CALL_OW 251
134036: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
134037: LD_ADDR_VAR 0 12
134041: PUSH
134042: LD_VAR 0 4
134046: PUSH
134047: LD_VAR 0 7
134051: ARRAY
134052: PPUSH
134053: CALL 101996 0 1
134057: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
134058: LD_VAR 0 4
134062: PUSH
134063: LD_VAR 0 7
134067: ARRAY
134068: PPUSH
134069: LD_VAR 0 10
134073: PPUSH
134074: LD_VAR 0 11
134078: PPUSH
134079: LD_VAR 0 14
134083: PUSH
134084: LD_INT 1
134086: ARRAY
134087: PPUSH
134088: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
134092: LD_VAR 0 4
134096: PUSH
134097: LD_VAR 0 7
134101: ARRAY
134102: PPUSH
134103: LD_VAR 0 10
134107: PPUSH
134108: LD_VAR 0 12
134112: PPUSH
134113: LD_INT 7
134115: PPUSH
134116: CALL_OW 272
134120: PPUSH
134121: LD_VAR 0 11
134125: PPUSH
134126: LD_VAR 0 12
134130: PPUSH
134131: LD_INT 7
134133: PPUSH
134134: CALL_OW 273
134138: PPUSH
134139: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
134143: LD_VAR 0 4
134147: PUSH
134148: LD_VAR 0 7
134152: ARRAY
134153: PPUSH
134154: LD_INT 71
134156: PPUSH
134157: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
134161: LD_ADDR_VAR 0 27
134165: PUSH
134166: LD_VAR 0 27
134170: PPUSH
134171: LD_VAR 0 27
134175: PUSH
134176: LD_INT 1
134178: PLUS
134179: PPUSH
134180: LD_VAR 0 14
134184: PUSH
134185: LD_INT 1
134187: ARRAY
134188: PPUSH
134189: CALL_OW 1
134193: ST_TO_ADDR
// attacking := true ;
134194: LD_ADDR_VAR 0 29
134198: PUSH
134199: LD_INT 1
134201: ST_TO_ADDR
// continue ;
134202: GO 132049
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
134204: LD_VAR 0 4
134208: PUSH
134209: LD_VAR 0 7
134213: ARRAY
134214: PPUSH
134215: CALL_OW 257
134219: PUSH
134220: LD_INT 17
134222: EQUAL
134223: PUSH
134224: LD_VAR 0 4
134228: PUSH
134229: LD_VAR 0 7
134233: ARRAY
134234: PPUSH
134235: CALL_OW 110
134239: PUSH
134240: LD_INT 71
134242: EQUAL
134243: NOT
134244: AND
134245: IFFALSE 134391
// begin attacking := false ;
134247: LD_ADDR_VAR 0 29
134251: PUSH
134252: LD_INT 0
134254: ST_TO_ADDR
// k := 5 ;
134255: LD_ADDR_VAR 0 9
134259: PUSH
134260: LD_INT 5
134262: ST_TO_ADDR
// if tmp < k then
134263: LD_VAR 0 14
134267: PUSH
134268: LD_VAR 0 9
134272: LESS
134273: IFFALSE 134285
// k := tmp ;
134275: LD_ADDR_VAR 0 9
134279: PUSH
134280: LD_VAR 0 14
134284: ST_TO_ADDR
// for j = 1 to k do
134285: LD_ADDR_VAR 0 8
134289: PUSH
134290: DOUBLE
134291: LD_INT 1
134293: DEC
134294: ST_TO_ADDR
134295: LD_VAR 0 9
134299: PUSH
134300: FOR_TO
134301: IFFALSE 134389
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
134303: LD_VAR 0 14
134307: PUSH
134308: LD_VAR 0 8
134312: ARRAY
134313: PUSH
134314: LD_VAR 0 14
134318: PPUSH
134319: LD_INT 58
134321: PUSH
134322: EMPTY
134323: LIST
134324: PPUSH
134325: CALL_OW 72
134329: IN
134330: NOT
134331: IFFALSE 134387
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
134333: LD_VAR 0 4
134337: PUSH
134338: LD_VAR 0 7
134342: ARRAY
134343: PPUSH
134344: LD_VAR 0 14
134348: PUSH
134349: LD_VAR 0 8
134353: ARRAY
134354: PPUSH
134355: CALL_OW 115
// attacking := true ;
134359: LD_ADDR_VAR 0 29
134363: PUSH
134364: LD_INT 1
134366: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
134367: LD_VAR 0 4
134371: PUSH
134372: LD_VAR 0 7
134376: ARRAY
134377: PPUSH
134378: LD_INT 71
134380: PPUSH
134381: CALL_OW 109
// continue ;
134385: GO 134300
// end ; end ;
134387: GO 134300
134389: POP
134390: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
134391: LD_VAR 0 4
134395: PUSH
134396: LD_VAR 0 7
134400: ARRAY
134401: PPUSH
134402: CALL_OW 257
134406: PUSH
134407: LD_INT 8
134409: EQUAL
134410: PUSH
134411: LD_VAR 0 4
134415: PUSH
134416: LD_VAR 0 7
134420: ARRAY
134421: PPUSH
134422: CALL_OW 264
134426: PUSH
134427: LD_INT 28
134429: PUSH
134430: LD_INT 45
134432: PUSH
134433: LD_INT 7
134435: PUSH
134436: LD_INT 47
134438: PUSH
134439: EMPTY
134440: LIST
134441: LIST
134442: LIST
134443: LIST
134444: IN
134445: OR
134446: IFFALSE 134702
// begin attacking := false ;
134448: LD_ADDR_VAR 0 29
134452: PUSH
134453: LD_INT 0
134455: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
134456: LD_VAR 0 14
134460: PUSH
134461: LD_INT 1
134463: ARRAY
134464: PPUSH
134465: CALL_OW 266
134469: PUSH
134470: LD_INT 32
134472: PUSH
134473: LD_INT 31
134475: PUSH
134476: LD_INT 33
134478: PUSH
134479: LD_INT 4
134481: PUSH
134482: LD_INT 5
134484: PUSH
134485: EMPTY
134486: LIST
134487: LIST
134488: LIST
134489: LIST
134490: LIST
134491: IN
134492: IFFALSE 134678
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
134494: LD_ADDR_VAR 0 9
134498: PUSH
134499: LD_VAR 0 14
134503: PUSH
134504: LD_INT 1
134506: ARRAY
134507: PPUSH
134508: CALL_OW 266
134512: PPUSH
134513: LD_VAR 0 14
134517: PUSH
134518: LD_INT 1
134520: ARRAY
134521: PPUSH
134522: CALL_OW 250
134526: PPUSH
134527: LD_VAR 0 14
134531: PUSH
134532: LD_INT 1
134534: ARRAY
134535: PPUSH
134536: CALL_OW 251
134540: PPUSH
134541: LD_VAR 0 14
134545: PUSH
134546: LD_INT 1
134548: ARRAY
134549: PPUSH
134550: CALL_OW 254
134554: PPUSH
134555: LD_VAR 0 14
134559: PUSH
134560: LD_INT 1
134562: ARRAY
134563: PPUSH
134564: CALL_OW 248
134568: PPUSH
134569: LD_INT 0
134571: PPUSH
134572: CALL 83366 0 6
134576: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
134577: LD_ADDR_VAR 0 8
134581: PUSH
134582: LD_VAR 0 4
134586: PUSH
134587: LD_VAR 0 7
134591: ARRAY
134592: PPUSH
134593: LD_VAR 0 9
134597: PPUSH
134598: CALL 102109 0 2
134602: ST_TO_ADDR
// if j then
134603: LD_VAR 0 8
134607: IFFALSE 134676
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
134609: LD_VAR 0 8
134613: PUSH
134614: LD_INT 1
134616: ARRAY
134617: PPUSH
134618: LD_VAR 0 8
134622: PUSH
134623: LD_INT 2
134625: ARRAY
134626: PPUSH
134627: CALL_OW 488
134631: IFFALSE 134676
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
134633: LD_VAR 0 4
134637: PUSH
134638: LD_VAR 0 7
134642: ARRAY
134643: PPUSH
134644: LD_VAR 0 8
134648: PUSH
134649: LD_INT 1
134651: ARRAY
134652: PPUSH
134653: LD_VAR 0 8
134657: PUSH
134658: LD_INT 2
134660: ARRAY
134661: PPUSH
134662: CALL_OW 116
// attacking := true ;
134666: LD_ADDR_VAR 0 29
134670: PUSH
134671: LD_INT 1
134673: ST_TO_ADDR
// continue ;
134674: GO 132049
// end ; end else
134676: GO 134702
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134678: LD_VAR 0 4
134682: PUSH
134683: LD_VAR 0 7
134687: ARRAY
134688: PPUSH
134689: LD_VAR 0 14
134693: PUSH
134694: LD_INT 1
134696: ARRAY
134697: PPUSH
134698: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
134702: LD_VAR 0 4
134706: PUSH
134707: LD_VAR 0 7
134711: ARRAY
134712: PPUSH
134713: CALL_OW 265
134717: PUSH
134718: LD_INT 11
134720: EQUAL
134721: IFFALSE 134999
// begin k := 10 ;
134723: LD_ADDR_VAR 0 9
134727: PUSH
134728: LD_INT 10
134730: ST_TO_ADDR
// x := 0 ;
134731: LD_ADDR_VAR 0 10
134735: PUSH
134736: LD_INT 0
134738: ST_TO_ADDR
// if tmp < k then
134739: LD_VAR 0 14
134743: PUSH
134744: LD_VAR 0 9
134748: LESS
134749: IFFALSE 134761
// k := tmp ;
134751: LD_ADDR_VAR 0 9
134755: PUSH
134756: LD_VAR 0 14
134760: ST_TO_ADDR
// for j = k downto 1 do
134761: LD_ADDR_VAR 0 8
134765: PUSH
134766: DOUBLE
134767: LD_VAR 0 9
134771: INC
134772: ST_TO_ADDR
134773: LD_INT 1
134775: PUSH
134776: FOR_DOWNTO
134777: IFFALSE 134852
// begin if GetType ( tmp [ j ] ) = unit_human then
134779: LD_VAR 0 14
134783: PUSH
134784: LD_VAR 0 8
134788: ARRAY
134789: PPUSH
134790: CALL_OW 247
134794: PUSH
134795: LD_INT 1
134797: EQUAL
134798: IFFALSE 134850
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
134800: LD_VAR 0 4
134804: PUSH
134805: LD_VAR 0 7
134809: ARRAY
134810: PPUSH
134811: LD_VAR 0 14
134815: PUSH
134816: LD_VAR 0 8
134820: ARRAY
134821: PPUSH
134822: CALL 102363 0 2
// x := tmp [ j ] ;
134826: LD_ADDR_VAR 0 10
134830: PUSH
134831: LD_VAR 0 14
134835: PUSH
134836: LD_VAR 0 8
134840: ARRAY
134841: ST_TO_ADDR
// attacking := true ;
134842: LD_ADDR_VAR 0 29
134846: PUSH
134847: LD_INT 1
134849: ST_TO_ADDR
// end ; end ;
134850: GO 134776
134852: POP
134853: POP
// if not x then
134854: LD_VAR 0 10
134858: NOT
134859: IFFALSE 134999
// begin attacking := true ;
134861: LD_ADDR_VAR 0 29
134865: PUSH
134866: LD_INT 1
134868: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
134869: LD_VAR 0 4
134873: PUSH
134874: LD_VAR 0 7
134878: ARRAY
134879: PPUSH
134880: CALL_OW 250
134884: PPUSH
134885: LD_VAR 0 4
134889: PUSH
134890: LD_VAR 0 7
134894: ARRAY
134895: PPUSH
134896: CALL_OW 251
134900: PPUSH
134901: CALL_OW 546
134905: PUSH
134906: LD_INT 2
134908: ARRAY
134909: PUSH
134910: LD_VAR 0 14
134914: PUSH
134915: LD_INT 1
134917: ARRAY
134918: PPUSH
134919: CALL_OW 250
134923: PPUSH
134924: LD_VAR 0 14
134928: PUSH
134929: LD_INT 1
134931: ARRAY
134932: PPUSH
134933: CALL_OW 251
134937: PPUSH
134938: CALL_OW 546
134942: PUSH
134943: LD_INT 2
134945: ARRAY
134946: EQUAL
134947: IFFALSE 134975
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
134949: LD_VAR 0 4
134953: PUSH
134954: LD_VAR 0 7
134958: ARRAY
134959: PPUSH
134960: LD_VAR 0 14
134964: PUSH
134965: LD_INT 1
134967: ARRAY
134968: PPUSH
134969: CALL 102363 0 2
134973: GO 134999
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134975: LD_VAR 0 4
134979: PUSH
134980: LD_VAR 0 7
134984: ARRAY
134985: PPUSH
134986: LD_VAR 0 14
134990: PUSH
134991: LD_INT 1
134993: ARRAY
134994: PPUSH
134995: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
134999: LD_VAR 0 4
135003: PUSH
135004: LD_VAR 0 7
135008: ARRAY
135009: PPUSH
135010: CALL_OW 264
135014: PUSH
135015: LD_INT 29
135017: EQUAL
135018: IFFALSE 135384
// begin if WantsToAttack ( group [ i ] ) in bombed then
135020: LD_VAR 0 4
135024: PUSH
135025: LD_VAR 0 7
135029: ARRAY
135030: PPUSH
135031: CALL_OW 319
135035: PUSH
135036: LD_VAR 0 28
135040: IN
135041: IFFALSE 135045
// continue ;
135043: GO 132049
// k := 8 ;
135045: LD_ADDR_VAR 0 9
135049: PUSH
135050: LD_INT 8
135052: ST_TO_ADDR
// x := 0 ;
135053: LD_ADDR_VAR 0 10
135057: PUSH
135058: LD_INT 0
135060: ST_TO_ADDR
// if tmp < k then
135061: LD_VAR 0 14
135065: PUSH
135066: LD_VAR 0 9
135070: LESS
135071: IFFALSE 135083
// k := tmp ;
135073: LD_ADDR_VAR 0 9
135077: PUSH
135078: LD_VAR 0 14
135082: ST_TO_ADDR
// for j = 1 to k do
135083: LD_ADDR_VAR 0 8
135087: PUSH
135088: DOUBLE
135089: LD_INT 1
135091: DEC
135092: ST_TO_ADDR
135093: LD_VAR 0 9
135097: PUSH
135098: FOR_TO
135099: IFFALSE 135231
// begin if GetType ( tmp [ j ] ) = unit_building then
135101: LD_VAR 0 14
135105: PUSH
135106: LD_VAR 0 8
135110: ARRAY
135111: PPUSH
135112: CALL_OW 247
135116: PUSH
135117: LD_INT 3
135119: EQUAL
135120: IFFALSE 135229
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
135122: LD_VAR 0 14
135126: PUSH
135127: LD_VAR 0 8
135131: ARRAY
135132: PUSH
135133: LD_VAR 0 28
135137: IN
135138: NOT
135139: PUSH
135140: LD_VAR 0 14
135144: PUSH
135145: LD_VAR 0 8
135149: ARRAY
135150: PPUSH
135151: CALL_OW 313
135155: AND
135156: IFFALSE 135229
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135158: LD_VAR 0 4
135162: PUSH
135163: LD_VAR 0 7
135167: ARRAY
135168: PPUSH
135169: LD_VAR 0 14
135173: PUSH
135174: LD_VAR 0 8
135178: ARRAY
135179: PPUSH
135180: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
135184: LD_ADDR_VAR 0 28
135188: PUSH
135189: LD_VAR 0 28
135193: PPUSH
135194: LD_VAR 0 28
135198: PUSH
135199: LD_INT 1
135201: PLUS
135202: PPUSH
135203: LD_VAR 0 14
135207: PUSH
135208: LD_VAR 0 8
135212: ARRAY
135213: PPUSH
135214: CALL_OW 1
135218: ST_TO_ADDR
// attacking := true ;
135219: LD_ADDR_VAR 0 29
135223: PUSH
135224: LD_INT 1
135226: ST_TO_ADDR
// break ;
135227: GO 135231
// end ; end ;
135229: GO 135098
135231: POP
135232: POP
// if not attacking and f_attack_depot then
135233: LD_VAR 0 29
135237: NOT
135238: PUSH
135239: LD_VAR 0 25
135243: AND
135244: IFFALSE 135339
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
135246: LD_ADDR_VAR 0 13
135250: PUSH
135251: LD_VAR 0 14
135255: PPUSH
135256: LD_INT 2
135258: PUSH
135259: LD_INT 30
135261: PUSH
135262: LD_INT 0
135264: PUSH
135265: EMPTY
135266: LIST
135267: LIST
135268: PUSH
135269: LD_INT 30
135271: PUSH
135272: LD_INT 1
135274: PUSH
135275: EMPTY
135276: LIST
135277: LIST
135278: PUSH
135279: EMPTY
135280: LIST
135281: LIST
135282: LIST
135283: PPUSH
135284: CALL_OW 72
135288: ST_TO_ADDR
// if z then
135289: LD_VAR 0 13
135293: IFFALSE 135339
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
135295: LD_VAR 0 4
135299: PUSH
135300: LD_VAR 0 7
135304: ARRAY
135305: PPUSH
135306: LD_VAR 0 13
135310: PPUSH
135311: LD_VAR 0 4
135315: PUSH
135316: LD_VAR 0 7
135320: ARRAY
135321: PPUSH
135322: CALL_OW 74
135326: PPUSH
135327: CALL_OW 115
// attacking := true ;
135331: LD_ADDR_VAR 0 29
135335: PUSH
135336: LD_INT 1
135338: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
135339: LD_VAR 0 4
135343: PUSH
135344: LD_VAR 0 7
135348: ARRAY
135349: PPUSH
135350: CALL_OW 256
135354: PUSH
135355: LD_INT 500
135357: LESS
135358: IFFALSE 135384
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
135360: LD_VAR 0 4
135364: PUSH
135365: LD_VAR 0 7
135369: ARRAY
135370: PPUSH
135371: LD_VAR 0 14
135375: PUSH
135376: LD_INT 1
135378: ARRAY
135379: PPUSH
135380: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
135384: LD_VAR 0 4
135388: PUSH
135389: LD_VAR 0 7
135393: ARRAY
135394: PPUSH
135395: CALL_OW 264
135399: PUSH
135400: LD_INT 49
135402: EQUAL
135403: IFFALSE 135524
// begin if not HasTask ( group [ i ] ) then
135405: LD_VAR 0 4
135409: PUSH
135410: LD_VAR 0 7
135414: ARRAY
135415: PPUSH
135416: CALL_OW 314
135420: NOT
135421: IFFALSE 135524
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
135423: LD_ADDR_VAR 0 9
135427: PUSH
135428: LD_INT 81
135430: PUSH
135431: LD_VAR 0 4
135435: PUSH
135436: LD_VAR 0 7
135440: ARRAY
135441: PPUSH
135442: CALL_OW 255
135446: PUSH
135447: EMPTY
135448: LIST
135449: LIST
135450: PPUSH
135451: CALL_OW 69
135455: PPUSH
135456: LD_VAR 0 4
135460: PUSH
135461: LD_VAR 0 7
135465: ARRAY
135466: PPUSH
135467: CALL_OW 74
135471: ST_TO_ADDR
// if k then
135472: LD_VAR 0 9
135476: IFFALSE 135524
// if GetDistUnits ( group [ i ] , k ) > 10 then
135478: LD_VAR 0 4
135482: PUSH
135483: LD_VAR 0 7
135487: ARRAY
135488: PPUSH
135489: LD_VAR 0 9
135493: PPUSH
135494: CALL_OW 296
135498: PUSH
135499: LD_INT 10
135501: GREATER
135502: IFFALSE 135524
// ComMoveUnit ( group [ i ] , k ) ;
135504: LD_VAR 0 4
135508: PUSH
135509: LD_VAR 0 7
135513: ARRAY
135514: PPUSH
135515: LD_VAR 0 9
135519: PPUSH
135520: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
135524: LD_VAR 0 4
135528: PUSH
135529: LD_VAR 0 7
135533: ARRAY
135534: PPUSH
135535: CALL_OW 256
135539: PUSH
135540: LD_INT 250
135542: LESS
135543: PUSH
135544: LD_VAR 0 4
135548: PUSH
135549: LD_VAR 0 7
135553: ARRAY
135554: PUSH
135555: LD_INT 21
135557: PUSH
135558: LD_INT 2
135560: PUSH
135561: EMPTY
135562: LIST
135563: LIST
135564: PUSH
135565: LD_INT 23
135567: PUSH
135568: LD_INT 2
135570: PUSH
135571: EMPTY
135572: LIST
135573: LIST
135574: PUSH
135575: EMPTY
135576: LIST
135577: LIST
135578: PPUSH
135579: CALL_OW 69
135583: IN
135584: AND
135585: IFFALSE 135710
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
135587: LD_ADDR_VAR 0 9
135591: PUSH
135592: LD_OWVAR 3
135596: PUSH
135597: LD_VAR 0 4
135601: PUSH
135602: LD_VAR 0 7
135606: ARRAY
135607: DIFF
135608: PPUSH
135609: LD_VAR 0 4
135613: PUSH
135614: LD_VAR 0 7
135618: ARRAY
135619: PPUSH
135620: CALL_OW 74
135624: ST_TO_ADDR
// if not k then
135625: LD_VAR 0 9
135629: NOT
135630: IFFALSE 135634
// continue ;
135632: GO 132049
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
135634: LD_VAR 0 9
135638: PUSH
135639: LD_INT 81
135641: PUSH
135642: LD_VAR 0 4
135646: PUSH
135647: LD_VAR 0 7
135651: ARRAY
135652: PPUSH
135653: CALL_OW 255
135657: PUSH
135658: EMPTY
135659: LIST
135660: LIST
135661: PPUSH
135662: CALL_OW 69
135666: IN
135667: PUSH
135668: LD_VAR 0 9
135672: PPUSH
135673: LD_VAR 0 4
135677: PUSH
135678: LD_VAR 0 7
135682: ARRAY
135683: PPUSH
135684: CALL_OW 296
135688: PUSH
135689: LD_INT 5
135691: LESS
135692: AND
135693: IFFALSE 135710
// ComAutodestruct ( group [ i ] ) ;
135695: LD_VAR 0 4
135699: PUSH
135700: LD_VAR 0 7
135704: ARRAY
135705: PPUSH
135706: CALL 102261 0 1
// end ; if f_attack_depot then
135710: LD_VAR 0 25
135714: IFFALSE 135826
// begin k := 6 ;
135716: LD_ADDR_VAR 0 9
135720: PUSH
135721: LD_INT 6
135723: ST_TO_ADDR
// if tmp < k then
135724: LD_VAR 0 14
135728: PUSH
135729: LD_VAR 0 9
135733: LESS
135734: IFFALSE 135746
// k := tmp ;
135736: LD_ADDR_VAR 0 9
135740: PUSH
135741: LD_VAR 0 14
135745: ST_TO_ADDR
// for j = 1 to k do
135746: LD_ADDR_VAR 0 8
135750: PUSH
135751: DOUBLE
135752: LD_INT 1
135754: DEC
135755: ST_TO_ADDR
135756: LD_VAR 0 9
135760: PUSH
135761: FOR_TO
135762: IFFALSE 135824
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
135764: LD_VAR 0 8
135768: PPUSH
135769: CALL_OW 266
135773: PUSH
135774: LD_INT 0
135776: PUSH
135777: LD_INT 1
135779: PUSH
135780: EMPTY
135781: LIST
135782: LIST
135783: IN
135784: IFFALSE 135822
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135786: LD_VAR 0 4
135790: PUSH
135791: LD_VAR 0 7
135795: ARRAY
135796: PPUSH
135797: LD_VAR 0 14
135801: PUSH
135802: LD_VAR 0 8
135806: ARRAY
135807: PPUSH
135808: CALL_OW 115
// attacking := true ;
135812: LD_ADDR_VAR 0 29
135816: PUSH
135817: LD_INT 1
135819: ST_TO_ADDR
// break ;
135820: GO 135824
// end ;
135822: GO 135761
135824: POP
135825: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
135826: LD_VAR 0 4
135830: PUSH
135831: LD_VAR 0 7
135835: ARRAY
135836: PPUSH
135837: CALL_OW 302
135841: PUSH
135842: LD_VAR 0 29
135846: NOT
135847: AND
135848: IFFALSE 136170
// begin if GetTag ( group [ i ] ) = 71 then
135850: LD_VAR 0 4
135854: PUSH
135855: LD_VAR 0 7
135859: ARRAY
135860: PPUSH
135861: CALL_OW 110
135865: PUSH
135866: LD_INT 71
135868: EQUAL
135869: IFFALSE 135910
// begin if HasTask ( group [ i ] ) then
135871: LD_VAR 0 4
135875: PUSH
135876: LD_VAR 0 7
135880: ARRAY
135881: PPUSH
135882: CALL_OW 314
135886: IFFALSE 135892
// continue else
135888: GO 132049
135890: GO 135910
// SetTag ( group [ i ] , 0 ) ;
135892: LD_VAR 0 4
135896: PUSH
135897: LD_VAR 0 7
135901: ARRAY
135902: PPUSH
135903: LD_INT 0
135905: PPUSH
135906: CALL_OW 109
// end ; k := 8 ;
135910: LD_ADDR_VAR 0 9
135914: PUSH
135915: LD_INT 8
135917: ST_TO_ADDR
// x := 0 ;
135918: LD_ADDR_VAR 0 10
135922: PUSH
135923: LD_INT 0
135925: ST_TO_ADDR
// if tmp < k then
135926: LD_VAR 0 14
135930: PUSH
135931: LD_VAR 0 9
135935: LESS
135936: IFFALSE 135948
// k := tmp ;
135938: LD_ADDR_VAR 0 9
135942: PUSH
135943: LD_VAR 0 14
135947: ST_TO_ADDR
// for j = 1 to k do
135948: LD_ADDR_VAR 0 8
135952: PUSH
135953: DOUBLE
135954: LD_INT 1
135956: DEC
135957: ST_TO_ADDR
135958: LD_VAR 0 9
135962: PUSH
135963: FOR_TO
135964: IFFALSE 136062
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
135966: LD_VAR 0 14
135970: PUSH
135971: LD_VAR 0 8
135975: ARRAY
135976: PPUSH
135977: CALL_OW 247
135981: PUSH
135982: LD_INT 1
135984: EQUAL
135985: PUSH
135986: LD_VAR 0 14
135990: PUSH
135991: LD_VAR 0 8
135995: ARRAY
135996: PPUSH
135997: CALL_OW 256
136001: PUSH
136002: LD_INT 250
136004: LESS
136005: PUSH
136006: LD_VAR 0 20
136010: AND
136011: PUSH
136012: LD_VAR 0 20
136016: NOT
136017: PUSH
136018: LD_VAR 0 14
136022: PUSH
136023: LD_VAR 0 8
136027: ARRAY
136028: PPUSH
136029: CALL_OW 256
136033: PUSH
136034: LD_INT 250
136036: GREATEREQUAL
136037: AND
136038: OR
136039: AND
136040: IFFALSE 136060
// begin x := tmp [ j ] ;
136042: LD_ADDR_VAR 0 10
136046: PUSH
136047: LD_VAR 0 14
136051: PUSH
136052: LD_VAR 0 8
136056: ARRAY
136057: ST_TO_ADDR
// break ;
136058: GO 136062
// end ;
136060: GO 135963
136062: POP
136063: POP
// if x then
136064: LD_VAR 0 10
136068: IFFALSE 136092
// ComAttackUnit ( group [ i ] , x ) else
136070: LD_VAR 0 4
136074: PUSH
136075: LD_VAR 0 7
136079: ARRAY
136080: PPUSH
136081: LD_VAR 0 10
136085: PPUSH
136086: CALL_OW 115
136090: GO 136116
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136092: LD_VAR 0 4
136096: PUSH
136097: LD_VAR 0 7
136101: ARRAY
136102: PPUSH
136103: LD_VAR 0 14
136107: PUSH
136108: LD_INT 1
136110: ARRAY
136111: PPUSH
136112: CALL_OW 115
// if not HasTask ( group [ i ] ) then
136116: LD_VAR 0 4
136120: PUSH
136121: LD_VAR 0 7
136125: ARRAY
136126: PPUSH
136127: CALL_OW 314
136131: NOT
136132: IFFALSE 136170
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
136134: LD_VAR 0 4
136138: PUSH
136139: LD_VAR 0 7
136143: ARRAY
136144: PPUSH
136145: LD_VAR 0 14
136149: PPUSH
136150: LD_VAR 0 4
136154: PUSH
136155: LD_VAR 0 7
136159: ARRAY
136160: PPUSH
136161: CALL_OW 74
136165: PPUSH
136166: CALL_OW 115
// end ; end ; end ;
136170: GO 132049
136172: POP
136173: POP
// wait ( 0 0$2 ) ;
136174: LD_INT 70
136176: PPUSH
136177: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
136181: LD_VAR 0 4
136185: NOT
136186: PUSH
136187: LD_VAR 0 4
136191: PUSH
136192: EMPTY
136193: EQUAL
136194: OR
136195: PUSH
136196: LD_INT 81
136198: PUSH
136199: LD_VAR 0 35
136203: PUSH
136204: EMPTY
136205: LIST
136206: LIST
136207: PPUSH
136208: CALL_OW 69
136212: NOT
136213: OR
136214: IFFALSE 132034
// end ;
136216: LD_VAR 0 2
136220: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
136221: LD_INT 0
136223: PPUSH
136224: PPUSH
136225: PPUSH
136226: PPUSH
136227: PPUSH
136228: PPUSH
// if not base or not mc_bases [ base ] or not solds then
136229: LD_VAR 0 1
136233: NOT
136234: PUSH
136235: LD_EXP 101
136239: PUSH
136240: LD_VAR 0 1
136244: ARRAY
136245: NOT
136246: OR
136247: PUSH
136248: LD_VAR 0 2
136252: NOT
136253: OR
136254: IFFALSE 136258
// exit ;
136256: GO 136812
// side := mc_sides [ base ] ;
136258: LD_ADDR_VAR 0 6
136262: PUSH
136263: LD_EXP 127
136267: PUSH
136268: LD_VAR 0 1
136272: ARRAY
136273: ST_TO_ADDR
// if not side then
136274: LD_VAR 0 6
136278: NOT
136279: IFFALSE 136283
// exit ;
136281: GO 136812
// for i in solds do
136283: LD_ADDR_VAR 0 7
136287: PUSH
136288: LD_VAR 0 2
136292: PUSH
136293: FOR_IN
136294: IFFALSE 136355
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
136296: LD_VAR 0 7
136300: PPUSH
136301: CALL_OW 310
136305: PPUSH
136306: CALL_OW 266
136310: PUSH
136311: LD_INT 32
136313: PUSH
136314: LD_INT 31
136316: PUSH
136317: EMPTY
136318: LIST
136319: LIST
136320: IN
136321: IFFALSE 136341
// solds := solds diff i else
136323: LD_ADDR_VAR 0 2
136327: PUSH
136328: LD_VAR 0 2
136332: PUSH
136333: LD_VAR 0 7
136337: DIFF
136338: ST_TO_ADDR
136339: GO 136353
// SetTag ( i , 18 ) ;
136341: LD_VAR 0 7
136345: PPUSH
136346: LD_INT 18
136348: PPUSH
136349: CALL_OW 109
136353: GO 136293
136355: POP
136356: POP
// if not solds then
136357: LD_VAR 0 2
136361: NOT
136362: IFFALSE 136366
// exit ;
136364: GO 136812
// repeat wait ( 0 0$2 ) ;
136366: LD_INT 70
136368: PPUSH
136369: CALL_OW 67
// enemy := mc_scan [ base ] ;
136373: LD_ADDR_VAR 0 4
136377: PUSH
136378: LD_EXP 124
136382: PUSH
136383: LD_VAR 0 1
136387: ARRAY
136388: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136389: LD_EXP 101
136393: PUSH
136394: LD_VAR 0 1
136398: ARRAY
136399: NOT
136400: PUSH
136401: LD_EXP 101
136405: PUSH
136406: LD_VAR 0 1
136410: ARRAY
136411: PUSH
136412: EMPTY
136413: EQUAL
136414: OR
136415: IFFALSE 136452
// begin for i in solds do
136417: LD_ADDR_VAR 0 7
136421: PUSH
136422: LD_VAR 0 2
136426: PUSH
136427: FOR_IN
136428: IFFALSE 136441
// ComStop ( i ) ;
136430: LD_VAR 0 7
136434: PPUSH
136435: CALL_OW 141
136439: GO 136427
136441: POP
136442: POP
// solds := [ ] ;
136443: LD_ADDR_VAR 0 2
136447: PUSH
136448: EMPTY
136449: ST_TO_ADDR
// exit ;
136450: GO 136812
// end ; for i in solds do
136452: LD_ADDR_VAR 0 7
136456: PUSH
136457: LD_VAR 0 2
136461: PUSH
136462: FOR_IN
136463: IFFALSE 136784
// begin if IsInUnit ( i ) then
136465: LD_VAR 0 7
136469: PPUSH
136470: CALL_OW 310
136474: IFFALSE 136485
// ComExitBuilding ( i ) ;
136476: LD_VAR 0 7
136480: PPUSH
136481: CALL_OW 122
// if GetLives ( i ) > 500 then
136485: LD_VAR 0 7
136489: PPUSH
136490: CALL_OW 256
136494: PUSH
136495: LD_INT 500
136497: GREATER
136498: IFFALSE 136551
// begin e := NearestUnitToUnit ( enemy , i ) ;
136500: LD_ADDR_VAR 0 5
136504: PUSH
136505: LD_VAR 0 4
136509: PPUSH
136510: LD_VAR 0 7
136514: PPUSH
136515: CALL_OW 74
136519: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
136520: LD_VAR 0 7
136524: PPUSH
136525: LD_VAR 0 5
136529: PPUSH
136530: CALL_OW 250
136534: PPUSH
136535: LD_VAR 0 5
136539: PPUSH
136540: CALL_OW 251
136544: PPUSH
136545: CALL_OW 114
// end else
136549: GO 136782
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
136551: LD_VAR 0 7
136555: PPUSH
136556: LD_EXP 101
136560: PUSH
136561: LD_VAR 0 1
136565: ARRAY
136566: PPUSH
136567: LD_INT 2
136569: PUSH
136570: LD_INT 30
136572: PUSH
136573: LD_INT 0
136575: PUSH
136576: EMPTY
136577: LIST
136578: LIST
136579: PUSH
136580: LD_INT 30
136582: PUSH
136583: LD_INT 1
136585: PUSH
136586: EMPTY
136587: LIST
136588: LIST
136589: PUSH
136590: LD_INT 30
136592: PUSH
136593: LD_INT 6
136595: PUSH
136596: EMPTY
136597: LIST
136598: LIST
136599: PUSH
136600: EMPTY
136601: LIST
136602: LIST
136603: LIST
136604: LIST
136605: PPUSH
136606: CALL_OW 72
136610: PPUSH
136611: LD_VAR 0 7
136615: PPUSH
136616: CALL_OW 74
136620: PPUSH
136621: CALL_OW 296
136625: PUSH
136626: LD_INT 10
136628: GREATER
136629: IFFALSE 136782
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
136631: LD_ADDR_VAR 0 8
136635: PUSH
136636: LD_EXP 101
136640: PUSH
136641: LD_VAR 0 1
136645: ARRAY
136646: PPUSH
136647: LD_INT 2
136649: PUSH
136650: LD_INT 30
136652: PUSH
136653: LD_INT 0
136655: PUSH
136656: EMPTY
136657: LIST
136658: LIST
136659: PUSH
136660: LD_INT 30
136662: PUSH
136663: LD_INT 1
136665: PUSH
136666: EMPTY
136667: LIST
136668: LIST
136669: PUSH
136670: LD_INT 30
136672: PUSH
136673: LD_INT 6
136675: PUSH
136676: EMPTY
136677: LIST
136678: LIST
136679: PUSH
136680: EMPTY
136681: LIST
136682: LIST
136683: LIST
136684: LIST
136685: PPUSH
136686: CALL_OW 72
136690: PPUSH
136691: LD_VAR 0 7
136695: PPUSH
136696: CALL_OW 74
136700: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
136701: LD_VAR 0 7
136705: PPUSH
136706: LD_VAR 0 8
136710: PPUSH
136711: CALL_OW 250
136715: PPUSH
136716: LD_INT 3
136718: PPUSH
136719: LD_INT 5
136721: PPUSH
136722: CALL_OW 272
136726: PPUSH
136727: LD_VAR 0 8
136731: PPUSH
136732: CALL_OW 251
136736: PPUSH
136737: LD_INT 3
136739: PPUSH
136740: LD_INT 5
136742: PPUSH
136743: CALL_OW 273
136747: PPUSH
136748: CALL_OW 111
// SetTag ( i , 0 ) ;
136752: LD_VAR 0 7
136756: PPUSH
136757: LD_INT 0
136759: PPUSH
136760: CALL_OW 109
// solds := solds diff i ;
136764: LD_ADDR_VAR 0 2
136768: PUSH
136769: LD_VAR 0 2
136773: PUSH
136774: LD_VAR 0 7
136778: DIFF
136779: ST_TO_ADDR
// continue ;
136780: GO 136462
// end ; end ;
136782: GO 136462
136784: POP
136785: POP
// until not solds or not enemy ;
136786: LD_VAR 0 2
136790: NOT
136791: PUSH
136792: LD_VAR 0 4
136796: NOT
136797: OR
136798: IFFALSE 136366
// MC_Reset ( base , 18 ) ;
136800: LD_VAR 0 1
136804: PPUSH
136805: LD_INT 18
136807: PPUSH
136808: CALL 42519 0 2
// end ;
136812: LD_VAR 0 3
136816: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
136817: LD_INT 0
136819: PPUSH
136820: PPUSH
136821: PPUSH
136822: PPUSH
136823: PPUSH
136824: PPUSH
136825: PPUSH
136826: PPUSH
136827: PPUSH
136828: PPUSH
136829: PPUSH
136830: PPUSH
136831: PPUSH
136832: PPUSH
136833: PPUSH
136834: PPUSH
136835: PPUSH
136836: PPUSH
136837: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
136838: LD_ADDR_VAR 0 12
136842: PUSH
136843: LD_EXP 101
136847: PUSH
136848: LD_VAR 0 1
136852: ARRAY
136853: PPUSH
136854: LD_INT 25
136856: PUSH
136857: LD_INT 3
136859: PUSH
136860: EMPTY
136861: LIST
136862: LIST
136863: PPUSH
136864: CALL_OW 72
136868: ST_TO_ADDR
// if mc_remote_driver [ base ] then
136869: LD_EXP 141
136873: PUSH
136874: LD_VAR 0 1
136878: ARRAY
136879: IFFALSE 136903
// mechs := mechs diff mc_remote_driver [ base ] ;
136881: LD_ADDR_VAR 0 12
136885: PUSH
136886: LD_VAR 0 12
136890: PUSH
136891: LD_EXP 141
136895: PUSH
136896: LD_VAR 0 1
136900: ARRAY
136901: DIFF
136902: ST_TO_ADDR
// for i in mechs do
136903: LD_ADDR_VAR 0 4
136907: PUSH
136908: LD_VAR 0 12
136912: PUSH
136913: FOR_IN
136914: IFFALSE 136949
// if GetTag ( i ) > 0 then
136916: LD_VAR 0 4
136920: PPUSH
136921: CALL_OW 110
136925: PUSH
136926: LD_INT 0
136928: GREATER
136929: IFFALSE 136947
// mechs := mechs diff i ;
136931: LD_ADDR_VAR 0 12
136935: PUSH
136936: LD_VAR 0 12
136940: PUSH
136941: LD_VAR 0 4
136945: DIFF
136946: ST_TO_ADDR
136947: GO 136913
136949: POP
136950: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
136951: LD_ADDR_VAR 0 8
136955: PUSH
136956: LD_EXP 101
136960: PUSH
136961: LD_VAR 0 1
136965: ARRAY
136966: PPUSH
136967: LD_INT 2
136969: PUSH
136970: LD_INT 25
136972: PUSH
136973: LD_INT 1
136975: PUSH
136976: EMPTY
136977: LIST
136978: LIST
136979: PUSH
136980: LD_INT 25
136982: PUSH
136983: LD_INT 5
136985: PUSH
136986: EMPTY
136987: LIST
136988: LIST
136989: PUSH
136990: LD_INT 25
136992: PUSH
136993: LD_INT 8
136995: PUSH
136996: EMPTY
136997: LIST
136998: LIST
136999: PUSH
137000: LD_INT 25
137002: PUSH
137003: LD_INT 9
137005: PUSH
137006: EMPTY
137007: LIST
137008: LIST
137009: PUSH
137010: EMPTY
137011: LIST
137012: LIST
137013: LIST
137014: LIST
137015: LIST
137016: PPUSH
137017: CALL_OW 72
137021: ST_TO_ADDR
// if not defenders and not solds then
137022: LD_VAR 0 2
137026: NOT
137027: PUSH
137028: LD_VAR 0 8
137032: NOT
137033: AND
137034: IFFALSE 137038
// exit ;
137036: GO 138808
// depot_under_attack := false ;
137038: LD_ADDR_VAR 0 16
137042: PUSH
137043: LD_INT 0
137045: ST_TO_ADDR
// sold_defenders := [ ] ;
137046: LD_ADDR_VAR 0 17
137050: PUSH
137051: EMPTY
137052: ST_TO_ADDR
// if mechs then
137053: LD_VAR 0 12
137057: IFFALSE 137210
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
137059: LD_ADDR_VAR 0 4
137063: PUSH
137064: LD_VAR 0 2
137068: PPUSH
137069: LD_INT 21
137071: PUSH
137072: LD_INT 2
137074: PUSH
137075: EMPTY
137076: LIST
137077: LIST
137078: PPUSH
137079: CALL_OW 72
137083: PUSH
137084: FOR_IN
137085: IFFALSE 137208
// begin if GetTag ( i ) <> 20 then
137087: LD_VAR 0 4
137091: PPUSH
137092: CALL_OW 110
137096: PUSH
137097: LD_INT 20
137099: NONEQUAL
137100: IFFALSE 137114
// SetTag ( i , 20 ) ;
137102: LD_VAR 0 4
137106: PPUSH
137107: LD_INT 20
137109: PPUSH
137110: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
137114: LD_VAR 0 4
137118: PPUSH
137119: CALL_OW 263
137123: PUSH
137124: LD_INT 1
137126: EQUAL
137127: PUSH
137128: LD_VAR 0 4
137132: PPUSH
137133: CALL_OW 311
137137: NOT
137138: AND
137139: IFFALSE 137206
// begin un := mechs [ 1 ] ;
137141: LD_ADDR_VAR 0 10
137145: PUSH
137146: LD_VAR 0 12
137150: PUSH
137151: LD_INT 1
137153: ARRAY
137154: ST_TO_ADDR
// ComExit ( un ) ;
137155: LD_VAR 0 10
137159: PPUSH
137160: CALL 107158 0 1
// AddComEnterUnit ( un , i ) ;
137164: LD_VAR 0 10
137168: PPUSH
137169: LD_VAR 0 4
137173: PPUSH
137174: CALL_OW 180
// SetTag ( un , 19 ) ;
137178: LD_VAR 0 10
137182: PPUSH
137183: LD_INT 19
137185: PPUSH
137186: CALL_OW 109
// mechs := mechs diff un ;
137190: LD_ADDR_VAR 0 12
137194: PUSH
137195: LD_VAR 0 12
137199: PUSH
137200: LD_VAR 0 10
137204: DIFF
137205: ST_TO_ADDR
// end ; end ;
137206: GO 137084
137208: POP
137209: POP
// if solds then
137210: LD_VAR 0 8
137214: IFFALSE 137273
// for i in solds do
137216: LD_ADDR_VAR 0 4
137220: PUSH
137221: LD_VAR 0 8
137225: PUSH
137226: FOR_IN
137227: IFFALSE 137271
// if not GetTag ( i ) then
137229: LD_VAR 0 4
137233: PPUSH
137234: CALL_OW 110
137238: NOT
137239: IFFALSE 137269
// begin defenders := defenders union i ;
137241: LD_ADDR_VAR 0 2
137245: PUSH
137246: LD_VAR 0 2
137250: PUSH
137251: LD_VAR 0 4
137255: UNION
137256: ST_TO_ADDR
// SetTag ( i , 18 ) ;
137257: LD_VAR 0 4
137261: PPUSH
137262: LD_INT 18
137264: PPUSH
137265: CALL_OW 109
// end ;
137269: GO 137226
137271: POP
137272: POP
// repeat wait ( 0 0$2 ) ;
137273: LD_INT 70
137275: PPUSH
137276: CALL_OW 67
// enemy := mc_scan [ base ] ;
137280: LD_ADDR_VAR 0 21
137284: PUSH
137285: LD_EXP 124
137289: PUSH
137290: LD_VAR 0 1
137294: ARRAY
137295: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137296: LD_EXP 101
137300: PUSH
137301: LD_VAR 0 1
137305: ARRAY
137306: NOT
137307: PUSH
137308: LD_EXP 101
137312: PUSH
137313: LD_VAR 0 1
137317: ARRAY
137318: PUSH
137319: EMPTY
137320: EQUAL
137321: OR
137322: IFFALSE 137359
// begin for i in defenders do
137324: LD_ADDR_VAR 0 4
137328: PUSH
137329: LD_VAR 0 2
137333: PUSH
137334: FOR_IN
137335: IFFALSE 137348
// ComStop ( i ) ;
137337: LD_VAR 0 4
137341: PPUSH
137342: CALL_OW 141
137346: GO 137334
137348: POP
137349: POP
// defenders := [ ] ;
137350: LD_ADDR_VAR 0 2
137354: PUSH
137355: EMPTY
137356: ST_TO_ADDR
// exit ;
137357: GO 138808
// end ; for i in defenders do
137359: LD_ADDR_VAR 0 4
137363: PUSH
137364: LD_VAR 0 2
137368: PUSH
137369: FOR_IN
137370: IFFALSE 138268
// begin e := NearestUnitToUnit ( enemy , i ) ;
137372: LD_ADDR_VAR 0 13
137376: PUSH
137377: LD_VAR 0 21
137381: PPUSH
137382: LD_VAR 0 4
137386: PPUSH
137387: CALL_OW 74
137391: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
137392: LD_ADDR_VAR 0 7
137396: PUSH
137397: LD_EXP 101
137401: PUSH
137402: LD_VAR 0 1
137406: ARRAY
137407: PPUSH
137408: LD_INT 2
137410: PUSH
137411: LD_INT 30
137413: PUSH
137414: LD_INT 0
137416: PUSH
137417: EMPTY
137418: LIST
137419: LIST
137420: PUSH
137421: LD_INT 30
137423: PUSH
137424: LD_INT 1
137426: PUSH
137427: EMPTY
137428: LIST
137429: LIST
137430: PUSH
137431: EMPTY
137432: LIST
137433: LIST
137434: LIST
137435: PPUSH
137436: CALL_OW 72
137440: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
137441: LD_ADDR_VAR 0 16
137445: PUSH
137446: LD_VAR 0 7
137450: NOT
137451: PUSH
137452: LD_VAR 0 7
137456: PPUSH
137457: LD_INT 3
137459: PUSH
137460: LD_INT 24
137462: PUSH
137463: LD_INT 600
137465: PUSH
137466: EMPTY
137467: LIST
137468: LIST
137469: PUSH
137470: EMPTY
137471: LIST
137472: LIST
137473: PPUSH
137474: CALL_OW 72
137478: OR
137479: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
137480: LD_VAR 0 4
137484: PPUSH
137485: CALL_OW 247
137489: PUSH
137490: LD_INT 2
137492: DOUBLE
137493: EQUAL
137494: IFTRUE 137498
137496: GO 137894
137498: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
137499: LD_VAR 0 4
137503: PPUSH
137504: CALL_OW 256
137508: PUSH
137509: LD_INT 1000
137511: EQUAL
137512: PUSH
137513: LD_VAR 0 4
137517: PPUSH
137518: LD_VAR 0 13
137522: PPUSH
137523: CALL_OW 296
137527: PUSH
137528: LD_INT 40
137530: LESS
137531: PUSH
137532: LD_VAR 0 13
137536: PPUSH
137537: LD_EXP 126
137541: PUSH
137542: LD_VAR 0 1
137546: ARRAY
137547: PPUSH
137548: CALL_OW 308
137552: OR
137553: AND
137554: IFFALSE 137676
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
137556: LD_VAR 0 4
137560: PPUSH
137561: CALL_OW 262
137565: PUSH
137566: LD_INT 1
137568: EQUAL
137569: PUSH
137570: LD_VAR 0 4
137574: PPUSH
137575: CALL_OW 261
137579: PUSH
137580: LD_INT 30
137582: LESS
137583: AND
137584: PUSH
137585: LD_VAR 0 7
137589: AND
137590: IFFALSE 137660
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
137592: LD_VAR 0 4
137596: PPUSH
137597: LD_VAR 0 7
137601: PPUSH
137602: LD_VAR 0 4
137606: PPUSH
137607: CALL_OW 74
137611: PPUSH
137612: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
137616: LD_VAR 0 4
137620: PPUSH
137621: LD_VAR 0 7
137625: PPUSH
137626: LD_VAR 0 4
137630: PPUSH
137631: CALL_OW 74
137635: PPUSH
137636: CALL_OW 296
137640: PUSH
137641: LD_INT 6
137643: LESS
137644: IFFALSE 137658
// SetFuel ( i , 100 ) ;
137646: LD_VAR 0 4
137650: PPUSH
137651: LD_INT 100
137653: PPUSH
137654: CALL_OW 240
// end else
137658: GO 137674
// ComAttackUnit ( i , e ) ;
137660: LD_VAR 0 4
137664: PPUSH
137665: LD_VAR 0 13
137669: PPUSH
137670: CALL_OW 115
// end else
137674: GO 137777
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
137676: LD_VAR 0 13
137680: PPUSH
137681: LD_EXP 126
137685: PUSH
137686: LD_VAR 0 1
137690: ARRAY
137691: PPUSH
137692: CALL_OW 308
137696: NOT
137697: PUSH
137698: LD_VAR 0 4
137702: PPUSH
137703: LD_VAR 0 13
137707: PPUSH
137708: CALL_OW 296
137712: PUSH
137713: LD_INT 40
137715: GREATEREQUAL
137716: AND
137717: PUSH
137718: LD_VAR 0 4
137722: PPUSH
137723: CALL_OW 256
137727: PUSH
137728: LD_INT 650
137730: LESSEQUAL
137731: OR
137732: PUSH
137733: LD_VAR 0 4
137737: PPUSH
137738: LD_EXP 125
137742: PUSH
137743: LD_VAR 0 1
137747: ARRAY
137748: PPUSH
137749: CALL_OW 308
137753: NOT
137754: AND
137755: IFFALSE 137777
// ComMoveToArea ( i , mc_parking [ base ] ) ;
137757: LD_VAR 0 4
137761: PPUSH
137762: LD_EXP 125
137766: PUSH
137767: LD_VAR 0 1
137771: ARRAY
137772: PPUSH
137773: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
137777: LD_VAR 0 4
137781: PPUSH
137782: CALL_OW 256
137786: PUSH
137787: LD_INT 1000
137789: LESS
137790: PUSH
137791: LD_VAR 0 4
137795: PPUSH
137796: CALL_OW 263
137800: PUSH
137801: LD_INT 1
137803: EQUAL
137804: AND
137805: PUSH
137806: LD_VAR 0 4
137810: PPUSH
137811: CALL_OW 311
137815: AND
137816: PUSH
137817: LD_VAR 0 4
137821: PPUSH
137822: LD_EXP 125
137826: PUSH
137827: LD_VAR 0 1
137831: ARRAY
137832: PPUSH
137833: CALL_OW 308
137837: AND
137838: IFFALSE 137892
// begin mech := IsDrivenBy ( i ) ;
137840: LD_ADDR_VAR 0 9
137844: PUSH
137845: LD_VAR 0 4
137849: PPUSH
137850: CALL_OW 311
137854: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
137855: LD_VAR 0 9
137859: PPUSH
137860: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
137864: LD_VAR 0 9
137868: PPUSH
137869: LD_VAR 0 4
137873: PPUSH
137874: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
137878: LD_VAR 0 9
137882: PPUSH
137883: LD_VAR 0 4
137887: PPUSH
137888: CALL_OW 180
// end ; end ; unit_human :
137892: GO 138239
137894: LD_INT 1
137896: DOUBLE
137897: EQUAL
137898: IFTRUE 137902
137900: GO 138238
137902: POP
// begin b := IsInUnit ( i ) ;
137903: LD_ADDR_VAR 0 18
137907: PUSH
137908: LD_VAR 0 4
137912: PPUSH
137913: CALL_OW 310
137917: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
137918: LD_ADDR_VAR 0 19
137922: PUSH
137923: LD_VAR 0 18
137927: NOT
137928: PUSH
137929: LD_VAR 0 18
137933: PPUSH
137934: CALL_OW 266
137938: PUSH
137939: LD_INT 32
137941: PUSH
137942: LD_INT 31
137944: PUSH
137945: EMPTY
137946: LIST
137947: LIST
137948: IN
137949: OR
137950: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
137951: LD_VAR 0 18
137955: PPUSH
137956: CALL_OW 266
137960: PUSH
137961: LD_INT 5
137963: EQUAL
137964: PUSH
137965: LD_VAR 0 4
137969: PPUSH
137970: CALL_OW 257
137974: PUSH
137975: LD_INT 1
137977: PUSH
137978: LD_INT 2
137980: PUSH
137981: LD_INT 3
137983: PUSH
137984: LD_INT 4
137986: PUSH
137987: EMPTY
137988: LIST
137989: LIST
137990: LIST
137991: LIST
137992: IN
137993: AND
137994: IFFALSE 138031
// begin class := AllowSpecClass ( i ) ;
137996: LD_ADDR_VAR 0 20
138000: PUSH
138001: LD_VAR 0 4
138005: PPUSH
138006: CALL 70844 0 1
138010: ST_TO_ADDR
// if class then
138011: LD_VAR 0 20
138015: IFFALSE 138031
// ComChangeProfession ( i , class ) ;
138017: LD_VAR 0 4
138021: PPUSH
138022: LD_VAR 0 20
138026: PPUSH
138027: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
138031: LD_VAR 0 16
138035: PUSH
138036: LD_VAR 0 2
138040: PPUSH
138041: LD_INT 21
138043: PUSH
138044: LD_INT 2
138046: PUSH
138047: EMPTY
138048: LIST
138049: LIST
138050: PPUSH
138051: CALL_OW 72
138055: PUSH
138056: LD_INT 1
138058: LESSEQUAL
138059: OR
138060: PUSH
138061: LD_VAR 0 19
138065: AND
138066: PUSH
138067: LD_VAR 0 4
138071: PUSH
138072: LD_VAR 0 17
138076: IN
138077: NOT
138078: AND
138079: IFFALSE 138172
// begin if b then
138081: LD_VAR 0 18
138085: IFFALSE 138134
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
138087: LD_VAR 0 18
138091: PPUSH
138092: LD_VAR 0 21
138096: PPUSH
138097: LD_VAR 0 18
138101: PPUSH
138102: CALL_OW 74
138106: PPUSH
138107: CALL_OW 296
138111: PUSH
138112: LD_INT 10
138114: LESS
138115: PUSH
138116: LD_VAR 0 18
138120: PPUSH
138121: CALL_OW 461
138125: PUSH
138126: LD_INT 7
138128: NONEQUAL
138129: AND
138130: IFFALSE 138134
// continue ;
138132: GO 137369
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
138134: LD_ADDR_VAR 0 17
138138: PUSH
138139: LD_VAR 0 17
138143: PPUSH
138144: LD_VAR 0 17
138148: PUSH
138149: LD_INT 1
138151: PLUS
138152: PPUSH
138153: LD_VAR 0 4
138157: PPUSH
138158: CALL_OW 1
138162: ST_TO_ADDR
// ComExitBuilding ( i ) ;
138163: LD_VAR 0 4
138167: PPUSH
138168: CALL_OW 122
// end ; if sold_defenders then
138172: LD_VAR 0 17
138176: IFFALSE 138236
// if i in sold_defenders then
138178: LD_VAR 0 4
138182: PUSH
138183: LD_VAR 0 17
138187: IN
138188: IFFALSE 138236
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
138190: LD_VAR 0 4
138194: PPUSH
138195: CALL_OW 314
138199: NOT
138200: PUSH
138201: LD_VAR 0 4
138205: PPUSH
138206: LD_VAR 0 13
138210: PPUSH
138211: CALL_OW 296
138215: PUSH
138216: LD_INT 30
138218: LESS
138219: AND
138220: IFFALSE 138236
// ComAttackUnit ( i , e ) ;
138222: LD_VAR 0 4
138226: PPUSH
138227: LD_VAR 0 13
138231: PPUSH
138232: CALL_OW 115
// end ; end ; end ;
138236: GO 138239
138238: POP
// if IsDead ( i ) then
138239: LD_VAR 0 4
138243: PPUSH
138244: CALL_OW 301
138248: IFFALSE 138266
// defenders := defenders diff i ;
138250: LD_ADDR_VAR 0 2
138254: PUSH
138255: LD_VAR 0 2
138259: PUSH
138260: LD_VAR 0 4
138264: DIFF
138265: ST_TO_ADDR
// end ;
138266: GO 137369
138268: POP
138269: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
138270: LD_VAR 0 21
138274: NOT
138275: PUSH
138276: LD_VAR 0 2
138280: NOT
138281: OR
138282: PUSH
138283: LD_EXP 101
138287: PUSH
138288: LD_VAR 0 1
138292: ARRAY
138293: NOT
138294: OR
138295: IFFALSE 137273
// MC_Reset ( base , 18 ) ;
138297: LD_VAR 0 1
138301: PPUSH
138302: LD_INT 18
138304: PPUSH
138305: CALL 42519 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138309: LD_ADDR_VAR 0 2
138313: PUSH
138314: LD_VAR 0 2
138318: PUSH
138319: LD_VAR 0 2
138323: PPUSH
138324: LD_INT 2
138326: PUSH
138327: LD_INT 25
138329: PUSH
138330: LD_INT 1
138332: PUSH
138333: EMPTY
138334: LIST
138335: LIST
138336: PUSH
138337: LD_INT 25
138339: PUSH
138340: LD_INT 5
138342: PUSH
138343: EMPTY
138344: LIST
138345: LIST
138346: PUSH
138347: LD_INT 25
138349: PUSH
138350: LD_INT 8
138352: PUSH
138353: EMPTY
138354: LIST
138355: LIST
138356: PUSH
138357: LD_INT 25
138359: PUSH
138360: LD_INT 9
138362: PUSH
138363: EMPTY
138364: LIST
138365: LIST
138366: PUSH
138367: EMPTY
138368: LIST
138369: LIST
138370: LIST
138371: LIST
138372: LIST
138373: PPUSH
138374: CALL_OW 72
138378: DIFF
138379: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
138380: LD_VAR 0 21
138384: NOT
138385: PUSH
138386: LD_VAR 0 2
138390: PPUSH
138391: LD_INT 21
138393: PUSH
138394: LD_INT 2
138396: PUSH
138397: EMPTY
138398: LIST
138399: LIST
138400: PPUSH
138401: CALL_OW 72
138405: AND
138406: IFFALSE 138744
// begin tmp := FilterByTag ( defenders , 19 ) ;
138408: LD_ADDR_VAR 0 11
138412: PUSH
138413: LD_VAR 0 2
138417: PPUSH
138418: LD_INT 19
138420: PPUSH
138421: CALL 104329 0 2
138425: ST_TO_ADDR
// if tmp then
138426: LD_VAR 0 11
138430: IFFALSE 138500
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
138432: LD_ADDR_VAR 0 11
138436: PUSH
138437: LD_VAR 0 11
138441: PPUSH
138442: LD_INT 25
138444: PUSH
138445: LD_INT 3
138447: PUSH
138448: EMPTY
138449: LIST
138450: LIST
138451: PPUSH
138452: CALL_OW 72
138456: ST_TO_ADDR
// if tmp then
138457: LD_VAR 0 11
138461: IFFALSE 138500
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
138463: LD_ADDR_EXP 113
138467: PUSH
138468: LD_EXP 113
138472: PPUSH
138473: LD_VAR 0 1
138477: PPUSH
138478: LD_EXP 113
138482: PUSH
138483: LD_VAR 0 1
138487: ARRAY
138488: PUSH
138489: LD_VAR 0 11
138493: UNION
138494: PPUSH
138495: CALL_OW 1
138499: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
138500: LD_VAR 0 1
138504: PPUSH
138505: LD_INT 19
138507: PPUSH
138508: CALL 42519 0 2
// repeat wait ( 0 0$1 ) ;
138512: LD_INT 35
138514: PPUSH
138515: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138519: LD_EXP 101
138523: PUSH
138524: LD_VAR 0 1
138528: ARRAY
138529: NOT
138530: PUSH
138531: LD_EXP 101
138535: PUSH
138536: LD_VAR 0 1
138540: ARRAY
138541: PUSH
138542: EMPTY
138543: EQUAL
138544: OR
138545: IFFALSE 138582
// begin for i in defenders do
138547: LD_ADDR_VAR 0 4
138551: PUSH
138552: LD_VAR 0 2
138556: PUSH
138557: FOR_IN
138558: IFFALSE 138571
// ComStop ( i ) ;
138560: LD_VAR 0 4
138564: PPUSH
138565: CALL_OW 141
138569: GO 138557
138571: POP
138572: POP
// defenders := [ ] ;
138573: LD_ADDR_VAR 0 2
138577: PUSH
138578: EMPTY
138579: ST_TO_ADDR
// exit ;
138580: GO 138808
// end ; for i in defenders do
138582: LD_ADDR_VAR 0 4
138586: PUSH
138587: LD_VAR 0 2
138591: PUSH
138592: FOR_IN
138593: IFFALSE 138682
// begin if not IsInArea ( i , mc_parking [ base ] ) then
138595: LD_VAR 0 4
138599: PPUSH
138600: LD_EXP 125
138604: PUSH
138605: LD_VAR 0 1
138609: ARRAY
138610: PPUSH
138611: CALL_OW 308
138615: NOT
138616: IFFALSE 138640
// ComMoveToArea ( i , mc_parking [ base ] ) else
138618: LD_VAR 0 4
138622: PPUSH
138623: LD_EXP 125
138627: PUSH
138628: LD_VAR 0 1
138632: ARRAY
138633: PPUSH
138634: CALL_OW 113
138638: GO 138680
// if GetControl ( i ) = control_manual then
138640: LD_VAR 0 4
138644: PPUSH
138645: CALL_OW 263
138649: PUSH
138650: LD_INT 1
138652: EQUAL
138653: IFFALSE 138680
// if IsDrivenBy ( i ) then
138655: LD_VAR 0 4
138659: PPUSH
138660: CALL_OW 311
138664: IFFALSE 138680
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
138666: LD_VAR 0 4
138670: PPUSH
138671: CALL_OW 311
138675: PPUSH
138676: CALL_OW 121
// end ;
138680: GO 138592
138682: POP
138683: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
138684: LD_VAR 0 2
138688: PPUSH
138689: LD_INT 95
138691: PUSH
138692: LD_EXP 125
138696: PUSH
138697: LD_VAR 0 1
138701: ARRAY
138702: PUSH
138703: EMPTY
138704: LIST
138705: LIST
138706: PPUSH
138707: CALL_OW 72
138711: PUSH
138712: LD_VAR 0 2
138716: EQUAL
138717: PUSH
138718: LD_EXP 124
138722: PUSH
138723: LD_VAR 0 1
138727: ARRAY
138728: OR
138729: PUSH
138730: LD_EXP 101
138734: PUSH
138735: LD_VAR 0 1
138739: ARRAY
138740: NOT
138741: OR
138742: IFFALSE 138512
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
138744: LD_ADDR_EXP 123
138748: PUSH
138749: LD_EXP 123
138753: PPUSH
138754: LD_VAR 0 1
138758: PPUSH
138759: LD_VAR 0 2
138763: PPUSH
138764: LD_INT 21
138766: PUSH
138767: LD_INT 2
138769: PUSH
138770: EMPTY
138771: LIST
138772: LIST
138773: PPUSH
138774: CALL_OW 72
138778: PPUSH
138779: CALL_OW 1
138783: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
138784: LD_VAR 0 1
138788: PPUSH
138789: LD_INT 19
138791: PPUSH
138792: CALL 42519 0 2
// MC_Reset ( base , 20 ) ;
138796: LD_VAR 0 1
138800: PPUSH
138801: LD_INT 20
138803: PPUSH
138804: CALL 42519 0 2
// end ; end_of_file
138808: LD_VAR 0 3
138812: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
138813: LD_VAR 0 1
138817: PUSH
138818: LD_INT 200
138820: DOUBLE
138821: GREATEREQUAL
138822: IFFALSE 138830
138824: LD_INT 299
138826: DOUBLE
138827: LESSEQUAL
138828: IFTRUE 138832
138830: GO 138864
138832: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
138833: LD_VAR 0 1
138837: PPUSH
138838: LD_VAR 0 2
138842: PPUSH
138843: LD_VAR 0 3
138847: PPUSH
138848: LD_VAR 0 4
138852: PPUSH
138853: LD_VAR 0 5
138857: PPUSH
138858: CALL 127160 0 5
138862: GO 138941
138864: LD_INT 300
138866: DOUBLE
138867: GREATEREQUAL
138868: IFFALSE 138876
138870: LD_INT 399
138872: DOUBLE
138873: LESSEQUAL
138874: IFTRUE 138878
138876: GO 138940
138878: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
138879: LD_VAR 0 1
138883: PPUSH
138884: LD_VAR 0 2
138888: PPUSH
138889: LD_VAR 0 3
138893: PPUSH
138894: LD_VAR 0 4
138898: PPUSH
138899: LD_VAR 0 5
138903: PPUSH
138904: LD_VAR 0 6
138908: PPUSH
138909: LD_VAR 0 7
138913: PPUSH
138914: LD_VAR 0 8
138918: PPUSH
138919: LD_VAR 0 9
138923: PPUSH
138924: LD_VAR 0 10
138928: PPUSH
138929: LD_VAR 0 11
138933: PPUSH
138934: CALL 123485 0 11
138938: GO 138941
138940: POP
// end ;
138941: PPOPN 11
138943: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
138944: LD_VAR 0 1
138948: PPUSH
138949: LD_VAR 0 2
138953: PPUSH
138954: LD_VAR 0 3
138958: PPUSH
138959: LD_VAR 0 4
138963: PPUSH
138964: LD_VAR 0 5
138968: PPUSH
138969: CALL 126896 0 5
// end ; end_of_file
138973: PPOPN 5
138975: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
138976: LD_VAR 0 1
138980: PPUSH
138981: LD_VAR 0 2
138985: PPUSH
138986: LD_VAR 0 3
138990: PPUSH
138991: LD_VAR 0 4
138995: PPUSH
138996: LD_VAR 0 5
139000: PPUSH
139001: LD_VAR 0 6
139005: PPUSH
139006: CALL 111137 0 6
// end ;
139010: PPOPN 6
139012: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
139013: LD_INT 0
139015: PPUSH
// begin if not units then
139016: LD_VAR 0 1
139020: NOT
139021: IFFALSE 139025
// exit ;
139023: GO 139025
// end ;
139025: PPOPN 7
139027: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
139028: CALL 111041 0 0
// end ;
139032: PPOPN 1
139034: END
