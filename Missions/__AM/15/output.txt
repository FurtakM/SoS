// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35128 0 0
// InitNature ;
  19: CALL 34996 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11163 0 0
// PrepareRussian ;
  40: CALL 7019 0 0
// PrepareLegion ;
  44: CALL 4208 0 0
// PreparePowell ;
  48: CALL 2941 0 0
// PrepareAmerican ;
  52: CALL 1713 0 0
// Action ;
  56: CALL 15078 0 0
// MC_Start ( ) ;
  60: CALL 37293 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 121
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 122
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 60038 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 60131 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 59481 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 59296 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 60038 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 60131 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 59296 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 59481 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59911 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 14
 894: PUSH
 895: LD_INT 15
 897: PUSH
 898: EMPTY
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58978 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 60038 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 60131 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 126
 959: PUSH
 960: LD_EXP 126
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_INT 88
1070: PUSH
1071: EMPTY
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PPUSH
1083: CALL 59296 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 10
1092: PUSH
1093: LD_INT 12
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: PPUSH
1100: CALL 60038 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1104: LD_INT 4
1106: PPUSH
1107: LD_INT 9
1109: PUSH
1110: EMPTY
1111: LIST
1112: PPUSH
1113: CALL 60131 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1117: LD_INT 4
1119: PPUSH
1120: LD_INT 26
1122: PUSH
1123: LD_INT 74
1125: PUSH
1126: LD_INT 107
1128: PUSH
1129: LD_INT 0
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 32
1140: PUSH
1141: LD_INT 77
1143: PUSH
1144: LD_INT 101
1146: PUSH
1147: LD_INT 4
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: LD_INT 32
1158: PUSH
1159: LD_INT 69
1161: PUSH
1162: LD_INT 86
1164: PUSH
1165: LD_INT 4
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: PUSH
1174: LD_INT 27
1176: PUSH
1177: LD_INT 77
1179: PUSH
1180: LD_INT 110
1182: PUSH
1183: LD_INT 3
1185: PUSH
1186: EMPTY
1187: LIST
1188: LIST
1189: LIST
1190: LIST
1191: PUSH
1192: LD_INT 27
1194: PUSH
1195: LD_INT 42
1197: PUSH
1198: LD_INT 79
1200: PUSH
1201: LD_INT 5
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: PUSH
1210: LD_INT 29
1212: PUSH
1213: LD_INT 86
1215: PUSH
1216: LD_INT 105
1218: PUSH
1219: LD_INT 2
1221: PUSH
1222: EMPTY
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: PUSH
1228: LD_INT 30
1230: PUSH
1231: LD_INT 40
1233: PUSH
1234: LD_INT 75
1236: PUSH
1237: LD_INT 1
1239: PUSH
1240: EMPTY
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_INT 32
1248: PUSH
1249: LD_INT 80
1251: PUSH
1252: LD_INT 106
1254: PUSH
1255: LD_INT 4
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: PUSH
1264: LD_INT 32
1266: PUSH
1267: LD_INT 75
1269: PUSH
1270: LD_INT 114
1272: PUSH
1273: LD_INT 5
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: PUSH
1282: LD_INT 32
1284: PUSH
1285: LD_INT 82
1287: PUSH
1288: LD_INT 110
1290: PUSH
1291: LD_INT 5
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: PUSH
1300: LD_INT 32
1302: PUSH
1303: LD_INT 62
1305: PUSH
1306: LD_INT 78
1308: PUSH
1309: LD_INT 4
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: PUSH
1318: LD_INT 4
1320: PUSH
1321: LD_INT 39
1323: PUSH
1324: LD_INT 61
1326: PUSH
1327: LD_INT 3
1329: PUSH
1330: EMPTY
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: PPUSH
1350: CALL 59188 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 5
1359: PUSH
1360: LD_INT 6
1362: PUSH
1363: LD_INT 7
1365: PUSH
1366: LD_INT 9
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: PPUSH
1375: CALL 60449 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1379: LD_INT 4
1381: PPUSH
1382: LD_INT 40
1384: PUSH
1385: LD_INT 75
1387: PUSH
1388: LD_INT 1
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PUSH
1396: LD_INT 86
1398: PUSH
1399: LD_INT 105
1401: PUSH
1402: LD_INT 0
1404: PUSH
1405: EMPTY
1406: LIST
1407: LIST
1408: LIST
1409: PUSH
1410: EMPTY
1411: LIST
1412: LIST
1413: PPUSH
1414: CALL 59620 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1418: LD_INT 4
1420: PPUSH
1421: LD_INT 2
1423: PPUSH
1424: CALL 59911 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1428: LD_INT 4
1430: PPUSH
1431: LD_INT 0
1433: PPUSH
1434: CALL 59911 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1438: LD_INT 4
1440: PPUSH
1441: LD_INT 54
1443: PPUSH
1444: LD_INT 85
1446: PPUSH
1447: LD_INT 2
1449: PPUSH
1450: LD_INT 19
1452: PUSH
1453: LD_INT 16
1455: PUSH
1456: LD_INT 17
1458: PUSH
1459: LD_INT 18
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: PPUSH
1468: CALL 60243 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1472: LD_INT 4
1474: PPUSH
1475: LD_INT 3
1477: PUSH
1478: LD_INT 1
1480: PUSH
1481: LD_INT 1
1483: PUSH
1484: LD_INT 5
1486: PUSH
1487: EMPTY
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 1
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 6
1504: PUSH
1505: EMPTY
1506: LIST
1507: LIST
1508: LIST
1509: LIST
1510: PUSH
1511: LD_INT 4
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 1
1519: PUSH
1520: LD_INT 7
1522: PUSH
1523: EMPTY
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: PUSH
1529: LD_INT 4
1531: PUSH
1532: LD_INT 1
1534: PUSH
1535: LD_INT 1
1537: PUSH
1538: LD_INT 6
1540: PUSH
1541: EMPTY
1542: LIST
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PPUSH
1553: CALL 59296 0 2
// MC_SetTame ( 4 , powellApe ) ;
1557: LD_INT 4
1559: PPUSH
1560: LD_INT 13
1562: PPUSH
1563: CALL 59862 0 2
// end ;
1567: LD_VAR 0 1
1571: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1572: LD_EXP 36
1576: PUSH
1577: LD_EXP 17
1581: PUSH
1582: LD_INT 2
1584: GREATEREQUAL
1585: AND
1586: IFFALSE 1598
1588: GO 1590
1590: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1591: LD_STRING ACH_POWELL
1593: PPUSH
1594: CALL_OW 543
1598: END
// every 0 0$1 trigger debug do var i , tmp ;
1599: LD_EXP 1
1603: IFFALSE 1710
1605: GO 1607
1607: DISABLE
1608: LD_INT 0
1610: PPUSH
1611: PPUSH
// begin enable ;
1612: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1613: LD_ADDR_VAR 0 2
1617: PUSH
1618: LD_INT 22
1620: PUSH
1621: LD_INT 1
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: PUSH
1628: LD_INT 3
1630: PUSH
1631: LD_INT 21
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: EMPTY
1638: LIST
1639: LIST
1640: PUSH
1641: EMPTY
1642: LIST
1643: LIST
1644: PUSH
1645: LD_INT 3
1647: PUSH
1648: LD_INT 24
1650: PUSH
1651: LD_INT 999
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL_OW 69
1671: ST_TO_ADDR
// if not tmp then
1672: LD_VAR 0 2
1676: NOT
1677: IFFALSE 1681
// exit ;
1679: GO 1710
// for i in tmp do
1681: LD_ADDR_VAR 0 1
1685: PUSH
1686: LD_VAR 0 2
1690: PUSH
1691: FOR_IN
1692: IFFALSE 1708
// SetLives ( i , 1000 ) ;
1694: LD_VAR 0 1
1698: PPUSH
1699: LD_INT 1000
1701: PPUSH
1702: CALL_OW 234
1706: GO 1691
1708: POP
1709: POP
// end ; end_of_file
1710: PPOPN 2
1712: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1713: LD_INT 0
1715: PPUSH
// uc_side := 1 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 1
1723: ST_TO_ADDR
// uc_nation := 1 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 1
1731: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1732: LD_ADDR_EXP 39
1736: PUSH
1737: LD_STRING JMM
1739: PPUSH
1740: LD_EXP 1
1744: NOT
1745: PPUSH
1746: LD_STRING 14_
1748: PPUSH
1749: CALL 65732 0 3
1753: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1754: LD_EXP 4
1758: NOT
1759: PUSH
1760: LD_EXP 4
1764: PUSH
1765: LD_INT 1
1767: ARRAY
1768: PUSH
1769: LD_INT 1
1771: ARRAY
1772: NOT
1773: OR
1774: IFFALSE 1797
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1776: LD_INT 5
1778: PPUSH
1779: LD_INT 3
1781: PPUSH
1782: LD_INT 1
1784: PPUSH
1785: LD_INT 9
1787: PPUSH
1788: LD_INT 100
1790: PPUSH
1791: CALL 70747 0 5
1795: GO 1856
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1797: LD_EXP 4
1801: PUSH
1802: LD_INT 1
1804: ARRAY
1805: PUSH
1806: LD_INT 1
1808: ARRAY
1809: PPUSH
1810: LD_EXP 4
1814: PUSH
1815: LD_INT 2
1817: ARRAY
1818: PUSH
1819: LD_INT 1
1821: ARRAY
1822: PPUSH
1823: LD_EXP 4
1827: PUSH
1828: LD_INT 3
1830: ARRAY
1831: PUSH
1832: LD_INT 1
1834: ARRAY
1835: PPUSH
1836: LD_EXP 4
1840: PUSH
1841: LD_INT 4
1843: ARRAY
1844: PUSH
1845: LD_INT 1
1847: ARRAY
1848: PPUSH
1849: LD_INT 30
1851: PPUSH
1852: CALL 70747 0 5
// JMMNewVeh := CreateVehicle ;
1856: LD_ADDR_EXP 56
1860: PUSH
1861: CALL_OW 45
1865: ST_TO_ADDR
// if not JMMNewVeh then
1866: LD_EXP 56
1870: NOT
1871: IFFALSE 1902
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1873: LD_INT 5
1875: PPUSH
1876: LD_INT 3
1878: PPUSH
1879: LD_INT 1
1881: PPUSH
1882: LD_INT 9
1884: PPUSH
1885: LD_INT 100
1887: PPUSH
1888: CALL 70747 0 5
// JMMNewVeh := CreateVehicle ;
1892: LD_ADDR_EXP 56
1896: PUSH
1897: CALL_OW 45
1901: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1902: LD_EXP 56
1906: PPUSH
1907: LD_INT 4
1909: PPUSH
1910: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1914: LD_EXP 56
1918: PPUSH
1919: LD_INT 79
1921: PPUSH
1922: LD_INT 91
1924: PPUSH
1925: LD_INT 0
1927: PPUSH
1928: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1932: LD_EXP 39
1936: PPUSH
1937: LD_EXP 56
1941: PPUSH
1942: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1946: LD_EXP 6
1950: PUSH
1951: LD_EXP 2
1955: NOT
1956: AND
1957: IFFALSE 2215
// begin if not JMMGirlVeh then
1959: LD_EXP 5
1963: NOT
1964: IFFALSE 1987
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1966: LD_INT 3
1968: PPUSH
1969: LD_INT 3
1971: PPUSH
1972: LD_INT 1
1974: PPUSH
1975: LD_INT 9
1977: PPUSH
1978: LD_INT 100
1980: PPUSH
1981: CALL 70747 0 5
1985: GO 2046
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1987: LD_EXP 5
1991: PUSH
1992: LD_INT 1
1994: ARRAY
1995: PUSH
1996: LD_INT 1
1998: ARRAY
1999: PPUSH
2000: LD_EXP 5
2004: PUSH
2005: LD_INT 2
2007: ARRAY
2008: PUSH
2009: LD_INT 1
2011: ARRAY
2012: PPUSH
2013: LD_EXP 5
2017: PUSH
2018: LD_INT 3
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: ARRAY
2025: PPUSH
2026: LD_EXP 5
2030: PUSH
2031: LD_INT 4
2033: ARRAY
2034: PUSH
2035: LD_INT 1
2037: ARRAY
2038: PPUSH
2039: LD_INT 30
2041: PPUSH
2042: CALL 70747 0 5
// GirlNewVeh := CreateVehicle ;
2046: LD_ADDR_EXP 57
2050: PUSH
2051: CALL_OW 45
2055: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2056: LD_EXP 57
2060: PPUSH
2061: LD_INT 4
2063: PPUSH
2064: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2068: LD_EXP 57
2072: PPUSH
2073: LD_INT 82
2075: PPUSH
2076: LD_INT 96
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: CALL_OW 48
// if JMMGirl = 1 then
2086: LD_EXP 7
2090: PUSH
2091: LD_INT 1
2093: EQUAL
2094: IFFALSE 2129
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2096: LD_ADDR_EXP 40
2100: PUSH
2101: LD_STRING Joan
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_STRING 14_
2109: PPUSH
2110: CALL 65732 0 3
2114: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2115: LD_EXP 40
2119: PPUSH
2120: LD_EXP 57
2124: PPUSH
2125: CALL_OW 52
// end ; if JMMGirl = 2 then
2129: LD_EXP 7
2133: PUSH
2134: LD_INT 2
2136: EQUAL
2137: IFFALSE 2172
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2139: LD_ADDR_EXP 42
2143: PUSH
2144: LD_STRING Lisa
2146: PPUSH
2147: LD_INT 1
2149: PPUSH
2150: LD_STRING 14_
2152: PPUSH
2153: CALL 65732 0 3
2157: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2158: LD_EXP 42
2162: PPUSH
2163: LD_EXP 57
2167: PPUSH
2168: CALL_OW 52
// end ; if JMMGirl = 3 then
2172: LD_EXP 7
2176: PUSH
2177: LD_INT 3
2179: EQUAL
2180: IFFALSE 2215
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2182: LD_ADDR_EXP 54
2186: PUSH
2187: LD_STRING Connie
2189: PPUSH
2190: LD_INT 1
2192: PPUSH
2193: LD_STRING 14_
2195: PPUSH
2196: CALL 65732 0 3
2200: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2201: LD_EXP 54
2205: PPUSH
2206: LD_EXP 57
2210: PPUSH
2211: CALL_OW 52
// end ; end ; end ;
2215: LD_VAR 0 1
2219: RET
// export function PrepareStevensSquad ; var tmp ; begin
2220: LD_INT 0
2222: PPUSH
2223: PPUSH
// uc_side := 1 ;
2224: LD_ADDR_OWVAR 20
2228: PUSH
2229: LD_INT 1
2231: ST_TO_ADDR
// uc_nation := 1 ;
2232: LD_ADDR_OWVAR 21
2236: PUSH
2237: LD_INT 1
2239: ST_TO_ADDR
// tmp := [ ] ;
2240: LD_ADDR_VAR 0 2
2244: PUSH
2245: EMPTY
2246: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2247: LD_ADDR_EXP 41
2251: PUSH
2252: LD_STRING Stevens
2254: PPUSH
2255: LD_EXP 1
2259: NOT
2260: PPUSH
2261: LD_STRING 13f_
2263: PPUSH
2264: CALL 65732 0 3
2268: ST_TO_ADDR
// if not Stevens then
2269: LD_EXP 41
2273: NOT
2274: IFFALSE 2330
// begin hc_name = Baker Smith ;
2276: LD_ADDR_OWVAR 26
2280: PUSH
2281: LD_STRING Baker Smith
2283: ST_TO_ADDR
// hc_gallery =  ;
2284: LD_ADDR_OWVAR 33
2288: PUSH
2289: LD_STRING 
2291: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2292: LD_INT 1
2294: PPUSH
2295: LD_INT 10
2297: PPUSH
2298: CALL_OW 384
// Baker = CreateHuman ;
2302: LD_ADDR_EXP 55
2306: PUSH
2307: CALL_OW 44
2311: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2312: LD_ADDR_VAR 0 2
2316: PUSH
2317: LD_VAR 0 2
2321: PUSH
2322: LD_EXP 55
2326: ADD
2327: ST_TO_ADDR
// end else
2328: GO 2346
// tmp := tmp ^ Stevens ;
2330: LD_ADDR_VAR 0 2
2334: PUSH
2335: LD_VAR 0 2
2339: PUSH
2340: LD_EXP 41
2344: ADD
2345: ST_TO_ADDR
// if not Lisa then
2346: LD_EXP 42
2350: NOT
2351: IFFALSE 2397
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2353: LD_ADDR_EXP 42
2357: PUSH
2358: LD_STRING Lisa
2360: PPUSH
2361: LD_EXP 1
2365: NOT
2366: PPUSH
2367: LD_STRING 13f_
2369: PPUSH
2370: CALL 65732 0 3
2374: ST_TO_ADDR
// if Lisa then
2375: LD_EXP 42
2379: IFFALSE 2397
// tmp := tmp ^ Lisa ;
2381: LD_ADDR_VAR 0 2
2385: PUSH
2386: LD_VAR 0 2
2390: PUSH
2391: LD_EXP 42
2395: ADD
2396: ST_TO_ADDR
// end ; if not Donaldson then
2397: LD_EXP 43
2401: NOT
2402: IFFALSE 2448
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2404: LD_ADDR_EXP 43
2408: PUSH
2409: LD_STRING Donaldson
2411: PPUSH
2412: LD_EXP 1
2416: NOT
2417: PPUSH
2418: LD_STRING 13f_
2420: PPUSH
2421: CALL 65732 0 3
2425: ST_TO_ADDR
// if Donaldson then
2426: LD_EXP 43
2430: IFFALSE 2448
// tmp := tmp ^ Donaldson ;
2432: LD_ADDR_VAR 0 2
2436: PUSH
2437: LD_VAR 0 2
2441: PUSH
2442: LD_EXP 43
2446: ADD
2447: ST_TO_ADDR
// end ; if not Bobby then
2448: LD_EXP 44
2452: NOT
2453: IFFALSE 2499
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2455: LD_ADDR_EXP 44
2459: PUSH
2460: LD_STRING Bobby
2462: PPUSH
2463: LD_EXP 1
2467: NOT
2468: PPUSH
2469: LD_STRING 13f_
2471: PPUSH
2472: CALL 65732 0 3
2476: ST_TO_ADDR
// if Bobby then
2477: LD_EXP 44
2481: IFFALSE 2499
// tmp := tmp ^ Bobby ;
2483: LD_ADDR_VAR 0 2
2487: PUSH
2488: LD_VAR 0 2
2492: PUSH
2493: LD_EXP 44
2497: ADD
2498: ST_TO_ADDR
// end ; if not Cyrus then
2499: LD_EXP 45
2503: NOT
2504: IFFALSE 2550
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2506: LD_ADDR_EXP 45
2510: PUSH
2511: LD_STRING Cyrus
2513: PPUSH
2514: LD_EXP 1
2518: NOT
2519: PPUSH
2520: LD_STRING 13f_
2522: PPUSH
2523: CALL 65732 0 3
2527: ST_TO_ADDR
// if Cyrus then
2528: LD_EXP 45
2532: IFFALSE 2550
// tmp := tmp ^ Cyrus ;
2534: LD_ADDR_VAR 0 2
2538: PUSH
2539: LD_VAR 0 2
2543: PUSH
2544: LD_EXP 45
2548: ADD
2549: ST_TO_ADDR
// end ; if not Brown then
2550: LD_EXP 47
2554: NOT
2555: IFFALSE 2601
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2557: LD_ADDR_EXP 47
2561: PUSH
2562: LD_STRING Brown
2564: PPUSH
2565: LD_EXP 1
2569: NOT
2570: PPUSH
2571: LD_STRING 13f_
2573: PPUSH
2574: CALL 65732 0 3
2578: ST_TO_ADDR
// if Brown then
2579: LD_EXP 47
2583: IFFALSE 2601
// tmp := tmp ^ Brown ;
2585: LD_ADDR_VAR 0 2
2589: PUSH
2590: LD_VAR 0 2
2594: PUSH
2595: LD_EXP 47
2599: ADD
2600: ST_TO_ADDR
// end ; if not Gladstone then
2601: LD_EXP 48
2605: NOT
2606: IFFALSE 2652
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2608: LD_ADDR_EXP 48
2612: PUSH
2613: LD_STRING Gladstone
2615: PPUSH
2616: LD_EXP 1
2620: NOT
2621: PPUSH
2622: LD_STRING 13f_
2624: PPUSH
2625: CALL 65732 0 3
2629: ST_TO_ADDR
// if Gladstone then
2630: LD_EXP 48
2634: IFFALSE 2652
// tmp := tmp ^ Gladstone ;
2636: LD_ADDR_VAR 0 2
2640: PUSH
2641: LD_VAR 0 2
2645: PUSH
2646: LD_EXP 48
2650: ADD
2651: ST_TO_ADDR
// end ; if not Houten then
2652: LD_EXP 49
2656: NOT
2657: IFFALSE 2703
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2659: LD_ADDR_EXP 49
2663: PUSH
2664: LD_STRING Houten
2666: PPUSH
2667: LD_EXP 1
2671: NOT
2672: PPUSH
2673: LD_STRING 13f_
2675: PPUSH
2676: CALL 65732 0 3
2680: ST_TO_ADDR
// if Houten then
2681: LD_EXP 49
2685: IFFALSE 2703
// tmp := tmp ^ Houten ;
2687: LD_ADDR_VAR 0 2
2691: PUSH
2692: LD_VAR 0 2
2696: PUSH
2697: LD_EXP 49
2701: ADD
2702: ST_TO_ADDR
// end ; if not Cornel then
2703: LD_EXP 50
2707: NOT
2708: IFFALSE 2754
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2710: LD_ADDR_EXP 50
2714: PUSH
2715: LD_STRING Cornell
2717: PPUSH
2718: LD_EXP 1
2722: NOT
2723: PPUSH
2724: LD_STRING 13f_
2726: PPUSH
2727: CALL 65732 0 3
2731: ST_TO_ADDR
// if Cornel then
2732: LD_EXP 50
2736: IFFALSE 2754
// tmp := tmp ^ Cornel ;
2738: LD_ADDR_VAR 0 2
2742: PUSH
2743: LD_VAR 0 2
2747: PUSH
2748: LD_EXP 50
2752: ADD
2753: ST_TO_ADDR
// end ; if not Gary then
2754: LD_EXP 51
2758: NOT
2759: IFFALSE 2805
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2761: LD_ADDR_EXP 51
2765: PUSH
2766: LD_STRING Gary
2768: PPUSH
2769: LD_EXP 1
2773: NOT
2774: PPUSH
2775: LD_STRING 13f_
2777: PPUSH
2778: CALL 65732 0 3
2782: ST_TO_ADDR
// if Gary then
2783: LD_EXP 51
2787: IFFALSE 2805
// tmp := tmp ^ Gary ;
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: LD_VAR 0 2
2798: PUSH
2799: LD_EXP 51
2803: ADD
2804: ST_TO_ADDR
// end ; if not Frank then
2805: LD_EXP 52
2809: NOT
2810: IFFALSE 2856
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2812: LD_ADDR_EXP 52
2816: PUSH
2817: LD_STRING Frank
2819: PPUSH
2820: LD_EXP 1
2824: NOT
2825: PPUSH
2826: LD_STRING 13f_
2828: PPUSH
2829: CALL 65732 0 3
2833: ST_TO_ADDR
// if Frank then
2834: LD_EXP 52
2838: IFFALSE 2856
// tmp := tmp ^ Frank ;
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: LD_VAR 0 2
2849: PUSH
2850: LD_EXP 52
2854: ADD
2855: ST_TO_ADDR
// end ; if not Kikuchi then
2856: LD_EXP 53
2860: NOT
2861: IFFALSE 2907
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2863: LD_ADDR_EXP 53
2867: PUSH
2868: LD_STRING Kikuchi
2870: PPUSH
2871: LD_EXP 1
2875: NOT
2876: PPUSH
2877: LD_STRING 13f_
2879: PPUSH
2880: CALL 65732 0 3
2884: ST_TO_ADDR
// if Kikuchi then
2885: LD_EXP 53
2889: IFFALSE 2907
// tmp := tmp ^ Kikuchi ;
2891: LD_ADDR_VAR 0 2
2895: PUSH
2896: LD_VAR 0 2
2900: PUSH
2901: LD_EXP 53
2905: ADD
2906: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2907: LD_ADDR_VAR 0 2
2911: PUSH
2912: LD_VAR 0 2
2916: PUSH
2917: LD_STRING 13_other_survivors
2919: PPUSH
2920: CALL_OW 31
2924: UNION
2925: ST_TO_ADDR
// result := tmp ;
2926: LD_ADDR_VAR 0 1
2930: PUSH
2931: LD_VAR 0 2
2935: ST_TO_ADDR
// end ; end_of_file
2936: LD_VAR 0 1
2940: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2941: LD_INT 0
2943: PPUSH
2944: PPUSH
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
// uc_side := 4 ;
2953: LD_ADDR_OWVAR 20
2957: PUSH
2958: LD_INT 4
2960: ST_TO_ADDR
// uc_nation := 1 ;
2961: LD_ADDR_OWVAR 21
2965: PUSH
2966: LD_INT 1
2968: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2969: LD_INT 387
2971: PPUSH
2972: CALL_OW 274
2976: PPUSH
2977: LD_INT 1
2979: PPUSH
2980: LD_INT 3500
2982: PUSH
2983: LD_INT 3000
2985: PUSH
2986: LD_INT 2500
2988: PUSH
2989: LD_INT 2000
2991: PUSH
2992: EMPTY
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: PUSH
2998: LD_OWVAR 67
3002: ARRAY
3003: PPUSH
3004: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3008: LD_INT 387
3010: PPUSH
3011: CALL_OW 274
3015: PPUSH
3016: LD_INT 2
3018: PPUSH
3019: LD_INT 400
3021: PPUSH
3022: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3026: LD_INT 387
3028: PPUSH
3029: CALL_OW 274
3033: PPUSH
3034: LD_INT 3
3036: PPUSH
3037: LD_INT 10
3039: PPUSH
3040: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3044: LD_ADDR_EXP 58
3048: PUSH
3049: LD_STRING Powell
3051: PPUSH
3052: CALL_OW 25
3056: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3057: LD_EXP 58
3061: PPUSH
3062: LD_INT 57
3064: PPUSH
3065: LD_INT 94
3067: PPUSH
3068: LD_INT 0
3070: PPUSH
3071: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3075: LD_EXP 58
3079: PPUSH
3080: LD_INT 58
3082: PPUSH
3083: LD_INT 94
3085: PPUSH
3086: CALL_OW 118
// vip := [ ] ;
3090: LD_ADDR_EXP 59
3094: PUSH
3095: EMPTY
3096: ST_TO_ADDR
// tmp := [ ] ;
3097: LD_ADDR_VAR 0 6
3101: PUSH
3102: EMPTY
3103: ST_TO_ADDR
// if JMMGirl <> 2 then
3104: LD_EXP 7
3108: PUSH
3109: LD_INT 2
3111: NONEQUAL
3112: IFFALSE 3136
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3114: LD_ADDR_EXP 42
3118: PUSH
3119: LD_STRING Lisa
3121: PPUSH
3122: LD_EXP 1
3126: NOT
3127: PPUSH
3128: LD_STRING 13s_
3130: PPUSH
3131: CALL 65732 0 3
3135: ST_TO_ADDR
// if Lisa then
3136: LD_EXP 42
3140: IFFALSE 3158
// tmp := tmp ^ Lisa ;
3142: LD_ADDR_VAR 0 6
3146: PUSH
3147: LD_VAR 0 6
3151: PUSH
3152: LD_EXP 42
3156: ADD
3157: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3158: LD_ADDR_EXP 43
3162: PUSH
3163: LD_STRING Donaldson
3165: PPUSH
3166: LD_EXP 1
3170: NOT
3171: PPUSH
3172: LD_STRING 13s_
3174: PPUSH
3175: CALL 65732 0 3
3179: ST_TO_ADDR
// if Donaldson then
3180: LD_EXP 43
3184: IFFALSE 3202
// tmp := tmp ^ Donaldson ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: LD_VAR 0 6
3195: PUSH
3196: LD_EXP 43
3200: ADD
3201: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3202: LD_ADDR_EXP 44
3206: PUSH
3207: LD_STRING Bobby
3209: PPUSH
3210: LD_EXP 1
3214: NOT
3215: PPUSH
3216: LD_STRING 13s_
3218: PPUSH
3219: CALL 65732 0 3
3223: ST_TO_ADDR
// if Bobby then
3224: LD_EXP 44
3228: IFFALSE 3246
// tmp := tmp ^ Bobby ;
3230: LD_ADDR_VAR 0 6
3234: PUSH
3235: LD_VAR 0 6
3239: PUSH
3240: LD_EXP 44
3244: ADD
3245: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 45
3250: PUSH
3251: LD_STRING Cyrus
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 65732 0 3
3267: ST_TO_ADDR
// if Cyrus then
3268: LD_EXP 45
3272: IFFALSE 3290
// tmp := tmp ^ Cyrus ;
3274: LD_ADDR_VAR 0 6
3278: PUSH
3279: LD_VAR 0 6
3283: PUSH
3284: LD_EXP 45
3288: ADD
3289: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3290: LD_ADDR_EXP 46
3294: PUSH
3295: LD_STRING Denis
3297: PPUSH
3298: LD_EXP 1
3302: NOT
3303: PPUSH
3304: LD_STRING 13s_
3306: PPUSH
3307: CALL 65732 0 3
3311: ST_TO_ADDR
// if not Denis then
3312: LD_EXP 46
3316: NOT
3317: IFFALSE 3341
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3319: LD_ADDR_EXP 46
3323: PUSH
3324: LD_STRING Denis
3326: PPUSH
3327: LD_EXP 1
3331: NOT
3332: PPUSH
3333: LD_STRING 13f_
3335: PPUSH
3336: CALL 65732 0 3
3340: ST_TO_ADDR
// if Denis then
3341: LD_EXP 46
3345: IFFALSE 3363
// tmp := tmp ^ Denis ;
3347: LD_ADDR_VAR 0 6
3351: PUSH
3352: LD_VAR 0 6
3356: PUSH
3357: LD_EXP 46
3361: ADD
3362: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3363: LD_ADDR_EXP 47
3367: PUSH
3368: LD_STRING Brown
3370: PPUSH
3371: LD_EXP 1
3375: NOT
3376: PPUSH
3377: LD_STRING 13s_
3379: PPUSH
3380: CALL 65732 0 3
3384: ST_TO_ADDR
// if Brown then
3385: LD_EXP 47
3389: IFFALSE 3407
// tmp := tmp ^ Brown ;
3391: LD_ADDR_VAR 0 6
3395: PUSH
3396: LD_VAR 0 6
3400: PUSH
3401: LD_EXP 47
3405: ADD
3406: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3407: LD_ADDR_EXP 48
3411: PUSH
3412: LD_STRING Gladstone
3414: PPUSH
3415: LD_EXP 1
3419: NOT
3420: PPUSH
3421: LD_STRING 13s_
3423: PPUSH
3424: CALL 65732 0 3
3428: ST_TO_ADDR
// if Gladstone then
3429: LD_EXP 48
3433: IFFALSE 3451
// tmp := tmp ^ Gladstone ;
3435: LD_ADDR_VAR 0 6
3439: PUSH
3440: LD_VAR 0 6
3444: PUSH
3445: LD_EXP 48
3449: ADD
3450: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3451: LD_ADDR_EXP 49
3455: PUSH
3456: LD_STRING Houten
3458: PPUSH
3459: LD_EXP 1
3463: NOT
3464: PPUSH
3465: LD_STRING 13s_
3467: PPUSH
3468: CALL 65732 0 3
3472: ST_TO_ADDR
// if Houten then
3473: LD_EXP 49
3477: IFFALSE 3495
// tmp := tmp ^ Houten ;
3479: LD_ADDR_VAR 0 6
3483: PUSH
3484: LD_VAR 0 6
3488: PUSH
3489: LD_EXP 49
3493: ADD
3494: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3495: LD_ADDR_EXP 50
3499: PUSH
3500: LD_STRING Cornel
3502: PPUSH
3503: LD_EXP 1
3507: NOT
3508: PPUSH
3509: LD_STRING 13s_
3511: PPUSH
3512: CALL 65732 0 3
3516: ST_TO_ADDR
// if Cornel then
3517: LD_EXP 50
3521: IFFALSE 3539
// tmp := tmp ^ Cornel ;
3523: LD_ADDR_VAR 0 6
3527: PUSH
3528: LD_VAR 0 6
3532: PUSH
3533: LD_EXP 50
3537: ADD
3538: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3539: LD_ADDR_EXP 51
3543: PUSH
3544: LD_STRING Gary
3546: PPUSH
3547: LD_EXP 1
3551: NOT
3552: PPUSH
3553: LD_STRING 13s_
3555: PPUSH
3556: CALL 65732 0 3
3560: ST_TO_ADDR
// if Gary then
3561: LD_EXP 51
3565: IFFALSE 3583
// tmp := tmp ^ Gary ;
3567: LD_ADDR_VAR 0 6
3571: PUSH
3572: LD_VAR 0 6
3576: PUSH
3577: LD_EXP 51
3581: ADD
3582: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3583: LD_ADDR_EXP 52
3587: PUSH
3588: LD_STRING Frank
3590: PPUSH
3591: LD_EXP 1
3595: NOT
3596: PPUSH
3597: LD_STRING 13s_
3599: PPUSH
3600: CALL 65732 0 3
3604: ST_TO_ADDR
// if Frank then
3605: LD_EXP 52
3609: IFFALSE 3627
// tmp := tmp ^ Frank ;
3611: LD_ADDR_VAR 0 6
3615: PUSH
3616: LD_VAR 0 6
3620: PUSH
3621: LD_EXP 52
3625: ADD
3626: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3627: LD_ADDR_EXP 53
3631: PUSH
3632: LD_STRING Kikuchi
3634: PPUSH
3635: LD_EXP 1
3639: NOT
3640: PPUSH
3641: LD_STRING 13s_
3643: PPUSH
3644: CALL 65732 0 3
3648: ST_TO_ADDR
// if Kikuchi then
3649: LD_EXP 53
3653: IFFALSE 3671
// tmp := tmp ^ Kikuchi ;
3655: LD_ADDR_VAR 0 6
3659: PUSH
3660: LD_VAR 0 6
3664: PUSH
3665: LD_EXP 53
3669: ADD
3670: ST_TO_ADDR
// vip := tmp ;
3671: LD_ADDR_EXP 59
3675: PUSH
3676: LD_VAR 0 6
3680: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3681: LD_ADDR_VAR 0 6
3685: PUSH
3686: LD_VAR 0 6
3690: PUSH
3691: LD_STRING 13s_others
3693: PPUSH
3694: CALL_OW 31
3698: UNION
3699: ST_TO_ADDR
// if tmp < 18 then
3700: LD_VAR 0 6
3704: PUSH
3705: LD_INT 18
3707: LESS
3708: IFFALSE 3775
// for i = 1 to 18 - tmp do
3710: LD_ADDR_VAR 0 2
3714: PUSH
3715: DOUBLE
3716: LD_INT 1
3718: DEC
3719: ST_TO_ADDR
3720: LD_INT 18
3722: PUSH
3723: LD_VAR 0 6
3727: MINUS
3728: PUSH
3729: FOR_TO
3730: IFFALSE 3773
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3732: LD_INT 1
3734: PPUSH
3735: LD_VAR 0 2
3739: PUSH
3740: LD_INT 4
3742: MOD
3743: PUSH
3744: LD_INT 1
3746: PLUS
3747: PPUSH
3748: LD_INT 5
3750: PPUSH
3751: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3755: LD_ADDR_VAR 0 6
3759: PUSH
3760: LD_VAR 0 6
3764: PUSH
3765: CALL_OW 44
3769: ADD
3770: ST_TO_ADDR
// end ;
3771: GO 3729
3773: POP
3774: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3775: LD_ADDR_VAR 0 7
3779: PUSH
3780: LD_INT 22
3782: PUSH
3783: LD_INT 4
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: LD_INT 30
3792: PUSH
3793: LD_INT 0
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: PPUSH
3804: CALL_OW 69
3808: PUSH
3809: LD_INT 1
3811: ARRAY
3812: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3813: LD_ADDR_VAR 0 8
3817: PUSH
3818: LD_INT 22
3820: PUSH
3821: LD_INT 4
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PUSH
3828: LD_INT 30
3830: PUSH
3831: LD_INT 6
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PPUSH
3842: CALL_OW 69
3846: PUSH
3847: LD_INT 1
3849: ARRAY
3850: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3851: LD_ADDR_VAR 0 9
3855: PUSH
3856: LD_INT 22
3858: PUSH
3859: LD_INT 4
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PUSH
3866: LD_INT 30
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: PPUSH
3880: CALL_OW 69
3884: PUSH
3885: LD_INT 1
3887: ARRAY
3888: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3889: LD_ADDR_VAR 0 10
3893: PUSH
3894: LD_INT 22
3896: PUSH
3897: LD_INT 4
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PUSH
3904: LD_INT 30
3906: PUSH
3907: LD_INT 2
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: EMPTY
3915: LIST
3916: LIST
3917: PPUSH
3918: CALL_OW 69
3922: PUSH
3923: LD_INT 1
3925: ARRAY
3926: ST_TO_ADDR
// for i in tmp do
3927: LD_ADDR_VAR 0 2
3931: PUSH
3932: LD_VAR 0 6
3936: PUSH
3937: FOR_IN
3938: IFFALSE 4064
// begin cl := GetClass ( i ) ;
3940: LD_ADDR_VAR 0 5
3944: PUSH
3945: LD_VAR 0 2
3949: PPUSH
3950: CALL_OW 257
3954: ST_TO_ADDR
// if cl > 4 then
3955: LD_VAR 0 5
3959: PUSH
3960: LD_INT 4
3962: GREATER
3963: IFFALSE 3973
// cl := 1 ;
3965: LD_ADDR_VAR 0 5
3969: PUSH
3970: LD_INT 1
3972: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3973: LD_ADDR_VAR 0 3
3977: PUSH
3978: LD_VAR 0 9
3982: PUSH
3983: LD_VAR 0 7
3987: PUSH
3988: LD_VAR 0 10
3992: PUSH
3993: LD_VAR 0 8
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_VAR 0 5
4008: ARRAY
4009: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4010: LD_VAR 0 3
4014: PPUSH
4015: CALL_OW 313
4019: PUSH
4020: LD_INT 6
4022: LESS
4023: IFFALSE 4041
// PlaceHumanInUnit ( i , b ) else
4025: LD_VAR 0 2
4029: PPUSH
4030: LD_VAR 0 3
4034: PPUSH
4035: CALL_OW 52
4039: GO 4062
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4041: LD_VAR 0 2
4045: PPUSH
4046: LD_INT 61
4048: PPUSH
4049: LD_INT 89
4051: PPUSH
4052: LD_INT 6
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 50
// end ;
4062: GO 3937
4064: POP
4065: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4066: LD_INT 2
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 12
4077: PPUSH
4078: LD_INT 100
4080: PPUSH
4081: CALL 70747 0 5
// veh := CreateVehicle ;
4085: LD_ADDR_VAR 0 4
4089: PUSH
4090: CALL_OW 45
4094: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4095: LD_VAR 0 4
4099: PPUSH
4100: LD_INT 4
4102: PPUSH
4103: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4107: LD_VAR 0 4
4111: PPUSH
4112: LD_INT 49
4114: PPUSH
4115: LD_INT 88
4117: PPUSH
4118: LD_INT 0
4120: PPUSH
4121: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4125: LD_VAR 0 4
4129: PPUSH
4130: LD_INT 1
4132: PPUSH
4133: LD_INT 100
4135: PPUSH
4136: CALL_OW 290
// uc_side := 0 ;
4140: LD_ADDR_OWVAR 20
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// uc_nation := 0 ;
4148: LD_ADDR_OWVAR 21
4152: PUSH
4153: LD_INT 0
4155: ST_TO_ADDR
// for i = 1 to 4 do
4156: LD_ADDR_VAR 0 2
4160: PUSH
4161: DOUBLE
4162: LD_INT 1
4164: DEC
4165: ST_TO_ADDR
4166: LD_INT 4
4168: PUSH
4169: FOR_TO
4170: IFFALSE 4201
// begin InitHc ;
4172: CALL_OW 19
// hc_class := class_apeman ;
4176: LD_ADDR_OWVAR 28
4180: PUSH
4181: LD_INT 12
4183: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4184: CALL_OW 44
4188: PPUSH
4189: LD_INT 13
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 49
// end ;
4199: GO 4169
4201: POP
4202: POP
// end ; end_of_file
4203: LD_VAR 0 1
4207: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4208: LD_INT 0
4210: PPUSH
4211: PPUSH
4212: PPUSH
4213: PPUSH
4214: PPUSH
// side := 8 ;
4215: LD_ADDR_VAR 0 3
4219: PUSH
4220: LD_INT 8
4222: ST_TO_ADDR
// uc_side := side ;
4223: LD_ADDR_OWVAR 20
4227: PUSH
4228: LD_VAR 0 3
4232: ST_TO_ADDR
// uc_nation := 2 ;
4233: LD_ADDR_OWVAR 21
4237: PUSH
4238: LD_INT 2
4240: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4241: LD_ADDR_VAR 0 2
4245: PUSH
4246: LD_INT 22
4248: PUSH
4249: LD_VAR 0 3
4253: PUSH
4254: EMPTY
4255: LIST
4256: LIST
4257: PUSH
4258: LD_INT 21
4260: PUSH
4261: LD_INT 3
4263: PUSH
4264: EMPTY
4265: LIST
4266: LIST
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: PPUSH
4272: CALL_OW 69
4276: PUSH
4277: FOR_IN
4278: IFFALSE 4294
// SetBLevel ( i , 10 ) ;
4280: LD_VAR 0 2
4284: PPUSH
4285: LD_INT 10
4287: PPUSH
4288: CALL_OW 241
4292: GO 4277
4294: POP
4295: POP
// if KurtStatus then
4296: LD_EXP 3
4300: IFFALSE 4323
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4302: LD_ADDR_EXP 60
4306: PUSH
4307: LD_STRING Kurt
4309: PPUSH
4310: LD_INT 0
4312: PPUSH
4313: LD_STRING 
4315: PPUSH
4316: CALL 65732 0 3
4320: ST_TO_ADDR
4321: GO 4345
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4323: LD_ADDR_EXP 60
4327: PUSH
4328: LD_STRING AltKurt
4330: PPUSH
4331: LD_EXP 1
4335: NOT
4336: PPUSH
4337: LD_STRING 
4339: PPUSH
4340: CALL 65732 0 3
4344: ST_TO_ADDR
// if not Kurt then
4345: LD_EXP 60
4349: NOT
4350: IFFALSE 4376
// begin InitHc ;
4352: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4356: LD_INT 1
4358: PPUSH
4359: LD_INT 10
4361: PPUSH
4362: CALL_OW 381
// Kurt := CreateHuman ;
4366: LD_ADDR_EXP 60
4370: PUSH
4371: CALL_OW 44
4375: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4376: LD_EXP 60
4380: PPUSH
4381: LD_INT 324
4383: PPUSH
4384: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4388: LD_ADDR_EXP 61
4392: PUSH
4393: LD_STRING Kozlov
4395: PPUSH
4396: LD_INT 0
4398: PPUSH
4399: LD_STRING 
4401: PPUSH
4402: CALL 65732 0 3
4406: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4407: LD_EXP 61
4411: PPUSH
4412: LD_INT 22
4414: PUSH
4415: LD_INT 8
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 23
4424: PUSH
4425: LD_INT 3
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 30
4434: PUSH
4435: LD_INT 8
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 1
4454: ARRAY
4455: PPUSH
4456: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4460: LD_EXP 61
4464: PPUSH
4465: LD_INT 3
4467: PPUSH
4468: LD_INT 10
4470: PPUSH
4471: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4475: LD_EXP 61
4479: PPUSH
4480: LD_INT 4
4482: PPUSH
4483: LD_INT 10
4485: PPUSH
4486: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4490: LD_ADDR_VAR 0 5
4494: PUSH
4495: LD_INT 22
4497: PUSH
4498: LD_VAR 0 3
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: PUSH
4507: LD_INT 30
4509: PUSH
4510: LD_INT 32
4512: PUSH
4513: EMPTY
4514: LIST
4515: LIST
4516: PUSH
4517: LD_INT 58
4519: PUSH
4520: EMPTY
4521: LIST
4522: PUSH
4523: EMPTY
4524: LIST
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL_OW 69
4532: ST_TO_ADDR
// for i = 1 to 10 do
4533: LD_ADDR_VAR 0 2
4537: PUSH
4538: DOUBLE
4539: LD_INT 1
4541: DEC
4542: ST_TO_ADDR
4543: LD_INT 10
4545: PUSH
4546: FOR_TO
4547: IFFALSE 4619
// begin uc_nation := nation_nature ;
4549: LD_ADDR_OWVAR 21
4553: PUSH
4554: LD_INT 0
4556: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4557: LD_ADDR_OWVAR 28
4561: PUSH
4562: LD_INT 15
4564: ST_TO_ADDR
// hc_gallery :=  ;
4565: LD_ADDR_OWVAR 33
4569: PUSH
4570: LD_STRING 
4572: ST_TO_ADDR
// hc_name :=  ;
4573: LD_ADDR_OWVAR 26
4577: PUSH
4578: LD_STRING 
4580: ST_TO_ADDR
// un := CreateHuman ;
4581: LD_ADDR_VAR 0 4
4585: PUSH
4586: CALL_OW 44
4590: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4591: LD_VAR 0 4
4595: PPUSH
4596: LD_VAR 0 5
4600: PUSH
4601: LD_VAR 0 5
4605: PUSH
4606: LD_VAR 0 2
4610: MINUS
4611: ARRAY
4612: PPUSH
4613: CALL_OW 52
// end ;
4617: GO 4546
4619: POP
4620: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4621: LD_ADDR_VAR 0 5
4625: PUSH
4626: LD_STRING 12_kurt_squad
4628: PPUSH
4629: CALL_OW 31
4633: ST_TO_ADDR
// if tmp then
4634: LD_VAR 0 5
4638: IFFALSE 4672
// for i in tmp do
4640: LD_ADDR_VAR 0 2
4644: PUSH
4645: LD_VAR 0 5
4649: PUSH
4650: FOR_IN
4651: IFFALSE 4670
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4653: LD_VAR 0 2
4657: PPUSH
4658: LD_INT 5
4660: PPUSH
4661: LD_INT 0
4663: PPUSH
4664: CALL_OW 49
4668: GO 4650
4670: POP
4671: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4672: LD_INT 324
4674: PPUSH
4675: LD_INT 5
4677: PPUSH
4678: LD_STRING 
4680: PPUSH
4681: LD_INT 8
4683: PUSH
4684: LD_INT 9
4686: PUSH
4687: LD_INT 10
4689: PUSH
4690: LD_INT 10
4692: PUSH
4693: EMPTY
4694: LIST
4695: LIST
4696: LIST
4697: LIST
4698: PUSH
4699: LD_OWVAR 67
4703: ARRAY
4704: PPUSH
4705: LD_INT 3000
4707: PUSH
4708: LD_INT 500
4710: PUSH
4711: LD_INT 150
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: PPUSH
4719: LD_INT 16
4721: PUSH
4722: LD_INT 6
4724: PUSH
4725: LD_INT 6
4727: PUSH
4728: LD_INT 8
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: LIST
4735: LIST
4736: PPUSH
4737: CALL 74191 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4741: LD_ADDR_EXP 97
4745: PUSH
4746: LD_EXP 97
4750: PPUSH
4751: LD_INT 3
4753: PPUSH
4754: LD_INT 22
4756: PUSH
4757: LD_VAR 0 3
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: LD_INT 23
4768: PUSH
4769: LD_INT 2
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: PUSH
4776: LD_INT 3
4778: PUSH
4779: LD_INT 21
4781: PUSH
4782: LD_INT 2
4784: PUSH
4785: EMPTY
4786: LIST
4787: LIST
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_EXP 60
4807: DIFF
4808: PPUSH
4809: CALL_OW 1
4813: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4814: LD_INT 1
4816: PPUSH
4817: LD_INT 7
4819: PPUSH
4820: CALL_OW 383
// Friend := CreateHuman ;
4824: LD_ADDR_EXP 62
4828: PUSH
4829: CALL_OW 44
4833: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4834: LD_INT 14
4836: PPUSH
4837: LD_INT 3
4839: PPUSH
4840: LD_INT 1
4842: PPUSH
4843: LD_INT 29
4845: PPUSH
4846: LD_INT 100
4848: PPUSH
4849: CALL 70747 0 5
// powellBomb := CreateVehicle ;
4853: LD_ADDR_EXP 63
4857: PUSH
4858: CALL_OW 45
4862: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4863: LD_EXP 63
4867: PPUSH
4868: LD_INT 90
4870: PPUSH
4871: LD_INT 51
4873: PPUSH
4874: LD_INT 0
4876: PPUSH
4877: CALL_OW 48
// end ;
4881: LD_VAR 0 1
4885: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4886: LD_INT 0
4888: PPUSH
4889: PPUSH
4890: PPUSH
// if IsLive ( kozlov_fac ) then
4891: LD_INT 332
4893: PPUSH
4894: CALL_OW 300
4898: IFFALSE 4902
// exit ;
4900: GO 5469
// ComExitBuilding ( Kozlov ) ;
4902: LD_EXP 61
4906: PPUSH
4907: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4911: LD_EXP 61
4915: PPUSH
4916: CALL_OW 257
4920: PUSH
4921: LD_INT 2
4923: NONEQUAL
4924: IFFALSE 4959
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4926: LD_EXP 61
4930: PPUSH
4931: LD_INT 324
4933: PPUSH
4934: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4938: LD_EXP 61
4942: PPUSH
4943: LD_INT 2
4945: PPUSH
4946: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4950: LD_EXP 61
4954: PPUSH
4955: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4959: LD_EXP 61
4963: PPUSH
4964: LD_INT 2
4966: PPUSH
4967: LD_INT 93
4969: PPUSH
4970: LD_INT 32
4972: PPUSH
4973: LD_INT 3
4975: PPUSH
4976: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4980: LD_INT 35
4982: PPUSH
4983: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4987: LD_INT 22
4989: PUSH
4990: LD_INT 8
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: LD_INT 30
4999: PUSH
5000: LD_INT 3
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 23
5009: PUSH
5010: LD_INT 3
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 57
5019: PUSH
5020: EMPTY
5021: LIST
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: LIST
5027: LIST
5028: PPUSH
5029: CALL_OW 69
5033: IFFALSE 4980
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5035: LD_ADDR_VAR 0 2
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_INT 8
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: PUSH
5050: LD_INT 30
5052: PUSH
5053: LD_INT 3
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PUSH
5060: LD_INT 23
5062: PUSH
5063: LD_INT 3
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 57
5072: PUSH
5073: EMPTY
5074: LIST
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: LIST
5080: LIST
5081: PPUSH
5082: CALL_OW 69
5086: PUSH
5087: LD_INT 1
5089: ARRAY
5090: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5091: LD_INT 22
5093: PUSH
5094: LD_INT 8
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 23
5103: PUSH
5104: LD_INT 3
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 30
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: NOT
5131: IFFALSE 5209
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5133: LD_EXP 61
5137: PPUSH
5138: LD_INT 21
5140: PPUSH
5141: LD_INT 97
5143: PPUSH
5144: LD_INT 36
5146: PPUSH
5147: LD_INT 5
5149: PPUSH
5150: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5154: LD_INT 35
5156: PPUSH
5157: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5161: LD_INT 22
5163: PUSH
5164: LD_INT 8
5166: PUSH
5167: EMPTY
5168: LIST
5169: LIST
5170: PUSH
5171: LD_INT 23
5173: PUSH
5174: LD_INT 3
5176: PUSH
5177: EMPTY
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 30
5183: PUSH
5184: LD_INT 21
5186: PUSH
5187: EMPTY
5188: LIST
5189: LIST
5190: PUSH
5191: LD_INT 57
5193: PUSH
5194: EMPTY
5195: LIST
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: PPUSH
5203: CALL_OW 69
5207: IFFALSE 5154
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5209: LD_INT 22
5211: PUSH
5212: LD_INT 8
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 23
5221: PUSH
5222: LD_INT 3
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 30
5231: PUSH
5232: LD_INT 18
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 69
5248: NOT
5249: IFFALSE 5327
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5251: LD_EXP 61
5255: PPUSH
5256: LD_INT 18
5258: PPUSH
5259: LD_INT 89
5261: PPUSH
5262: LD_INT 32
5264: PPUSH
5265: LD_INT 1
5267: PPUSH
5268: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5272: LD_INT 35
5274: PPUSH
5275: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5279: LD_INT 22
5281: PUSH
5282: LD_INT 8
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: PUSH
5289: LD_INT 23
5291: PUSH
5292: LD_INT 3
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PUSH
5299: LD_INT 30
5301: PUSH
5302: LD_INT 18
5304: PUSH
5305: EMPTY
5306: LIST
5307: LIST
5308: PUSH
5309: LD_INT 57
5311: PUSH
5312: EMPTY
5313: LIST
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: LIST
5319: LIST
5320: PPUSH
5321: CALL_OW 69
5325: IFFALSE 5272
// end ; lab := kozlov_lab ;
5327: LD_ADDR_VAR 0 3
5331: PUSH
5332: LD_INT 336
5334: ST_TO_ADDR
// if not lab then
5335: LD_VAR 0 3
5339: NOT
5340: IFFALSE 5344
// exit ;
5342: GO 5469
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5344: LD_EXP 61
5348: PPUSH
5349: LD_VAR 0 3
5353: PUSH
5354: LD_INT 1
5356: ARRAY
5357: PPUSH
5358: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5362: LD_EXP 61
5366: PPUSH
5367: LD_INT 4
5369: PPUSH
5370: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5374: LD_VAR 0 3
5378: PUSH
5379: LD_INT 1
5381: ARRAY
5382: PPUSH
5383: LD_INT 25
5385: PPUSH
5386: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5390: LD_INT 35
5392: PPUSH
5393: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5397: LD_INT 25
5399: PPUSH
5400: LD_INT 8
5402: PPUSH
5403: CALL_OW 321
5407: PUSH
5408: LD_INT 2
5410: EQUAL
5411: IFFALSE 5390
// ComExitBuilding ( Kozlov ) ;
5413: LD_EXP 61
5417: PPUSH
5418: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5422: LD_EXP 61
5426: PPUSH
5427: LD_VAR 0 2
5431: PPUSH
5432: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5436: LD_EXP 61
5440: PPUSH
5441: LD_INT 3
5443: PPUSH
5444: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5448: LD_VAR 0 2
5452: PPUSH
5453: LD_INT 23
5455: PPUSH
5456: LD_INT 3
5458: PPUSH
5459: LD_INT 1
5461: PPUSH
5462: LD_INT 48
5464: PPUSH
5465: CALL_OW 125
// end ;
5469: LD_VAR 0 1
5473: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5474: LD_EXP 22
5478: NOT
5479: PUSH
5480: LD_EXP 15
5484: PUSH
5485: LD_INT 6
5487: GREATEREQUAL
5488: AND
5489: IFFALSE 5570
5491: GO 5493
5493: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5494: LD_INT 3
5496: PPUSH
5497: LD_INT 3
5499: PPUSH
5500: CALL 59481 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5504: LD_INT 3
5506: PPUSH
5507: LD_INT 14
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: LD_INT 1
5515: PUSH
5516: LD_INT 28
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: PUSH
5525: LD_INT 14
5527: PUSH
5528: LD_INT 1
5530: PUSH
5531: LD_INT 1
5533: PUSH
5534: LD_INT 28
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: LIST
5541: LIST
5542: PUSH
5543: LD_INT 14
5545: PUSH
5546: LD_INT 1
5548: PUSH
5549: LD_INT 1
5551: PUSH
5552: LD_INT 28
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: PPUSH
5566: CALL 59344 0 2
// end ;
5570: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5571: LD_EXP 22
5575: NOT
5576: PUSH
5577: LD_EXP 15
5581: PUSH
5582: LD_INT 6
5584: GREATEREQUAL
5585: AND
5586: PUSH
5587: LD_INT 3
5589: PPUSH
5590: LD_INT 1
5592: PPUSH
5593: CALL 60762 0 2
5597: NOT
5598: AND
5599: IFFALSE 6455
5601: GO 5603
5603: DISABLE
5604: LD_INT 0
5606: PPUSH
5607: PPUSH
5608: PPUSH
// begin enable ;
5609: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5610: LD_INT 22
5612: PUSH
5613: LD_INT 8
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PUSH
5620: LD_INT 23
5622: PUSH
5623: LD_INT 2
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: PUSH
5630: LD_INT 30
5632: PUSH
5633: LD_INT 3
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: LIST
5644: PPUSH
5645: CALL_OW 69
5649: NOT
5650: IFFALSE 5654
// exit ;
5652: GO 6455
// if Prob ( 40 ) then
5654: LD_INT 40
5656: PPUSH
5657: CALL_OW 13
5661: IFFALSE 5788
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5663: LD_INT 3
5665: PPUSH
5666: LD_INT 14
5668: PUSH
5669: LD_INT 1
5671: PUSH
5672: LD_INT 2
5674: PUSH
5675: LD_INT 28
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 14
5686: PUSH
5687: LD_INT 1
5689: PUSH
5690: LD_INT 2
5692: PUSH
5693: LD_INT 28
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_INT 14
5704: PUSH
5705: LD_INT 1
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: LD_INT 28
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: LIST
5718: LIST
5719: PUSH
5720: LD_INT 14
5722: PUSH
5723: LD_INT 1
5725: PUSH
5726: LD_INT 2
5728: PUSH
5729: LD_INT 28
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 14
5740: PUSH
5741: LD_INT 1
5743: PUSH
5744: LD_INT 2
5746: PUSH
5747: LD_INT 28
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 14
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 2
5764: PUSH
5765: LD_INT 26
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: LIST
5780: LIST
5781: PPUSH
5782: CALL 59344 0 2
// end else
5786: GO 5995
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5788: LD_INT 3
5790: PPUSH
5791: LD_INT 14
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 27
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 26
5808: PUSH
5809: LD_INT 28
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 27
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: LIST
5856: PUSH
5857: LD_OWVAR 67
5861: ARRAY
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 14
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 2
5877: PUSH
5878: LD_INT 26
5880: PUSH
5881: LD_INT 26
5883: PUSH
5884: LD_INT 29
5886: PUSH
5887: LD_INT 29
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: PUSH
5896: LD_OWVAR 67
5900: ARRAY
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 13
5910: PUSH
5911: LD_INT 1
5913: PUSH
5914: LD_INT 2
5916: PUSH
5917: LD_INT 26
5919: PUSH
5920: LD_INT 29
5922: PUSH
5923: LD_INT 29
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_OWVAR 67
5939: ARRAY
5940: PUSH
5941: EMPTY
5942: LIST
5943: LIST
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 13
5949: PUSH
5950: LD_INT 1
5952: PUSH
5953: LD_INT 2
5955: PUSH
5956: LD_INT 29
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 14
5967: PUSH
5968: LD_INT 1
5970: PUSH
5971: LD_INT 2
5973: PUSH
5974: LD_INT 26
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: LIST
5981: LIST
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: PPUSH
5991: CALL 59344 0 2
// end ; repeat wait ( 0 0$1 ) ;
5995: LD_INT 35
5997: PPUSH
5998: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6002: LD_INT 3
6004: PPUSH
6005: LD_INT 1
6007: PPUSH
6008: CALL 60762 0 2
6012: PUSH
6013: LD_INT 6
6015: GREATEREQUAL
6016: IFFALSE 5995
// wait ( 0 0$30 ) ;
6018: LD_INT 1050
6020: PPUSH
6021: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6025: LD_ADDR_VAR 0 2
6029: PUSH
6030: LD_INT 3
6032: PPUSH
6033: LD_INT 1
6035: PPUSH
6036: CALL 60762 0 2
6040: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6041: LD_ADDR_EXP 116
6045: PUSH
6046: LD_EXP 116
6050: PPUSH
6051: LD_INT 3
6053: PPUSH
6054: LD_EXP 116
6058: PUSH
6059: LD_INT 3
6061: ARRAY
6062: PUSH
6063: LD_VAR 0 2
6067: DIFF
6068: PPUSH
6069: CALL_OW 1
6073: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6074: LD_ADDR_VAR 0 3
6078: PUSH
6079: LD_INT 0
6081: PPUSH
6082: LD_INT 2
6084: PPUSH
6085: CALL_OW 12
6089: ST_TO_ADDR
// if target then
6090: LD_VAR 0 3
6094: IFFALSE 6222
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6096: LD_ADDR_VAR 0 2
6100: PUSH
6101: LD_VAR 0 2
6105: PPUSH
6106: LD_INT 24
6108: PUSH
6109: LD_INT 250
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PPUSH
6116: CALL_OW 72
6120: ST_TO_ADDR
// for i in tmp do
6121: LD_ADDR_VAR 0 1
6125: PUSH
6126: LD_VAR 0 2
6130: PUSH
6131: FOR_IN
6132: IFFALSE 6172
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6134: LD_VAR 0 1
6138: PPUSH
6139: LD_INT 89
6141: PPUSH
6142: LD_INT 71
6144: PPUSH
6145: CALL_OW 297
6149: PUSH
6150: LD_INT 9
6152: GREATER
6153: IFFALSE 6170
// ComMoveXY ( i , 89 , 71 ) ;
6155: LD_VAR 0 1
6159: PPUSH
6160: LD_INT 89
6162: PPUSH
6163: LD_INT 71
6165: PPUSH
6166: CALL_OW 111
6170: GO 6131
6172: POP
6173: POP
// wait ( 0 0$1 ) ;
6174: LD_INT 35
6176: PPUSH
6177: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6181: LD_VAR 0 2
6185: PPUSH
6186: LD_INT 92
6188: PUSH
6189: LD_INT 89
6191: PUSH
6192: LD_INT 71
6194: PUSH
6195: LD_INT 9
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: PPUSH
6204: CALL_OW 72
6208: PUSH
6209: LD_VAR 0 2
6213: PUSH
6214: LD_INT 1
6216: MINUS
6217: GREATEREQUAL
6218: IFFALSE 6096
// end else
6220: GO 6346
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6222: LD_ADDR_VAR 0 2
6226: PUSH
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_INT 24
6234: PUSH
6235: LD_INT 250
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: PPUSH
6242: CALL_OW 72
6246: ST_TO_ADDR
// for i in tmp do
6247: LD_ADDR_VAR 0 1
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: FOR_IN
6258: IFFALSE 6298
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6260: LD_VAR 0 1
6264: PPUSH
6265: LD_INT 125
6267: PPUSH
6268: LD_INT 129
6270: PPUSH
6271: CALL_OW 297
6275: PUSH
6276: LD_INT 9
6278: GREATER
6279: IFFALSE 6296
// ComMoveXY ( i , 125 , 129 ) ;
6281: LD_VAR 0 1
6285: PPUSH
6286: LD_INT 125
6288: PPUSH
6289: LD_INT 129
6291: PPUSH
6292: CALL_OW 111
6296: GO 6257
6298: POP
6299: POP
// wait ( 0 0$1 ) ;
6300: LD_INT 35
6302: PPUSH
6303: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6307: LD_VAR 0 2
6311: PPUSH
6312: LD_INT 92
6314: PUSH
6315: LD_INT 125
6317: PUSH
6318: LD_INT 129
6320: PUSH
6321: LD_INT 9
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: PPUSH
6330: CALL_OW 72
6334: PUSH
6335: LD_VAR 0 2
6339: PUSH
6340: LD_INT 1
6342: MINUS
6343: GREATEREQUAL
6344: IFFALSE 6222
// end ; repeat wait ( 0 0$1 ) ;
6346: LD_INT 35
6348: PPUSH
6349: CALL_OW 67
// for i in tmp do
6353: LD_ADDR_VAR 0 1
6357: PUSH
6358: LD_VAR 0 2
6362: PUSH
6363: FOR_IN
6364: IFFALSE 6446
// begin if GetLives ( i ) > 251 then
6366: LD_VAR 0 1
6370: PPUSH
6371: CALL_OW 256
6375: PUSH
6376: LD_INT 251
6378: GREATER
6379: IFFALSE 6417
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6381: LD_VAR 0 1
6385: PPUSH
6386: LD_INT 81
6388: PUSH
6389: LD_INT 8
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PPUSH
6396: CALL_OW 69
6400: PPUSH
6401: LD_VAR 0 1
6405: PPUSH
6406: CALL_OW 74
6410: PPUSH
6411: CALL_OW 115
6415: GO 6444
// if IsDead ( i ) then
6417: LD_VAR 0 1
6421: PPUSH
6422: CALL_OW 301
6426: IFFALSE 6444
// tmp := tmp diff i ;
6428: LD_ADDR_VAR 0 2
6432: PUSH
6433: LD_VAR 0 2
6437: PUSH
6438: LD_VAR 0 1
6442: DIFF
6443: ST_TO_ADDR
// end ;
6444: GO 6363
6446: POP
6447: POP
// until not tmp ;
6448: LD_VAR 0 2
6452: NOT
6453: IFFALSE 6346
// end ;
6455: PPOPN 3
6457: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6458: LD_EXP 22
6462: NOT
6463: PUSH
6464: LD_EXP 15
6468: PUSH
6469: LD_INT 6
6471: GREATEREQUAL
6472: AND
6473: PUSH
6474: LD_OWVAR 67
6478: PUSH
6479: LD_INT 1
6481: GREATER
6482: AND
6483: IFFALSE 7016
6485: GO 6487
6487: DISABLE
6488: LD_INT 0
6490: PPUSH
6491: PPUSH
6492: PPUSH
// begin enable ;
6493: ENABLE
// tmp := [ ] ;
6494: LD_ADDR_VAR 0 3
6498: PUSH
6499: EMPTY
6500: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6501: LD_ADDR_VAR 0 1
6505: PUSH
6506: DOUBLE
6507: LD_INT 1
6509: DEC
6510: ST_TO_ADDR
6511: LD_INT 4
6513: PUSH
6514: LD_INT 6
6516: PUSH
6517: LD_INT 7
6519: PUSH
6520: LD_INT 8
6522: PUSH
6523: EMPTY
6524: LIST
6525: LIST
6526: LIST
6527: LIST
6528: PUSH
6529: LD_OWVAR 67
6533: ARRAY
6534: PUSH
6535: FOR_TO
6536: IFFALSE 6696
// begin uc_side := 8 ;
6538: LD_ADDR_OWVAR 20
6542: PUSH
6543: LD_INT 8
6545: ST_TO_ADDR
// uc_nation := 2 ;
6546: LD_ADDR_OWVAR 21
6550: PUSH
6551: LD_INT 2
6553: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6554: LD_INT 13
6556: PUSH
6557: LD_INT 14
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: LD_INT 1
6566: PPUSH
6567: LD_INT 2
6569: PPUSH
6570: CALL_OW 12
6574: ARRAY
6575: PPUSH
6576: LD_INT 1
6578: PPUSH
6579: LD_INT 5
6581: PPUSH
6582: LD_INT 27
6584: PUSH
6585: LD_INT 28
6587: PUSH
6588: LD_INT 26
6590: PUSH
6591: LD_INT 25
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 1
6602: PPUSH
6603: LD_INT 4
6605: PPUSH
6606: CALL_OW 12
6610: ARRAY
6611: PPUSH
6612: LD_INT 88
6614: PPUSH
6615: CALL 70747 0 5
// un := CreateVehicle ;
6619: LD_ADDR_VAR 0 2
6623: PUSH
6624: CALL_OW 45
6628: ST_TO_ADDR
// tmp := tmp ^ un ;
6629: LD_ADDR_VAR 0 3
6633: PUSH
6634: LD_VAR 0 3
6638: PUSH
6639: LD_VAR 0 2
6643: ADD
6644: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6645: LD_VAR 0 2
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6657: LD_VAR 0 2
6661: PPUSH
6662: LD_INT 30
6664: PPUSH
6665: LD_INT 0
6667: PPUSH
6668: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6672: LD_VAR 0 2
6676: PPUSH
6677: LD_INT 16
6679: PPUSH
6680: LD_INT 11
6682: PPUSH
6683: CALL_OW 111
// wait ( 0 0$2 ) ;
6687: LD_INT 70
6689: PPUSH
6690: CALL_OW 67
// end ;
6694: GO 6535
6696: POP
6697: POP
// for i = 1 to Difficulty do
6698: LD_ADDR_VAR 0 1
6702: PUSH
6703: DOUBLE
6704: LD_INT 1
6706: DEC
6707: ST_TO_ADDR
6708: LD_OWVAR 67
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6843
// begin uc_side := 8 ;
6716: LD_ADDR_OWVAR 20
6720: PUSH
6721: LD_INT 8
6723: ST_TO_ADDR
// uc_nation := 2 ;
6724: LD_ADDR_OWVAR 21
6728: PUSH
6729: LD_INT 2
6731: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6732: LD_INT 0
6734: PPUSH
6735: LD_INT 8
6737: PPUSH
6738: LD_INT 8
6740: PUSH
6741: LD_INT 8
6743: PUSH
6744: LD_INT 9
6746: PUSH
6747: LD_INT 10
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: LIST
6754: LIST
6755: PUSH
6756: LD_OWVAR 67
6760: ARRAY
6761: PPUSH
6762: CALL_OW 380
// un := CreateHuman ;
6766: LD_ADDR_VAR 0 2
6770: PUSH
6771: CALL_OW 44
6775: ST_TO_ADDR
// tmp := tmp ^ un ;
6776: LD_ADDR_VAR 0 3
6780: PUSH
6781: LD_VAR 0 3
6785: PUSH
6786: LD_VAR 0 2
6790: ADD
6791: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6792: LD_VAR 0 2
6796: PPUSH
6797: LD_INT 3
6799: PPUSH
6800: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6804: LD_VAR 0 2
6808: PPUSH
6809: LD_INT 30
6811: PPUSH
6812: LD_INT 0
6814: PPUSH
6815: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6819: LD_VAR 0 2
6823: PPUSH
6824: LD_INT 16
6826: PPUSH
6827: LD_INT 11
6829: PPUSH
6830: CALL_OW 111
// wait ( 0 0$2 ) ;
6834: LD_INT 70
6836: PPUSH
6837: CALL_OW 67
// end ;
6841: GO 6713
6843: POP
6844: POP
// repeat wait ( 0 0$1 ) ;
6845: LD_INT 35
6847: PPUSH
6848: CALL_OW 67
// if legionDestroyed then
6852: LD_EXP 22
6856: IFFALSE 6860
// exit ;
6858: GO 7016
// for i in tmp do
6860: LD_ADDR_VAR 0 1
6864: PUSH
6865: LD_VAR 0 3
6869: PUSH
6870: FOR_IN
6871: IFFALSE 7007
// begin if GetLives ( i ) > 250 then
6873: LD_VAR 0 1
6877: PPUSH
6878: CALL_OW 256
6882: PUSH
6883: LD_INT 250
6885: GREATER
6886: IFFALSE 6978
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6888: LD_INT 81
6890: PUSH
6891: LD_INT 8
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 91
6900: PUSH
6901: LD_VAR 0 1
6905: PUSH
6906: LD_INT 10
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: PPUSH
6918: CALL_OW 69
6922: NOT
6923: IFFALSE 6942
// ComAgressiveMove ( i , 67 , 110 ) else
6925: LD_VAR 0 1
6929: PPUSH
6930: LD_INT 67
6932: PPUSH
6933: LD_INT 110
6935: PPUSH
6936: CALL_OW 114
6940: GO 6976
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6942: LD_VAR 0 1
6946: PPUSH
6947: LD_INT 81
6949: PUSH
6950: LD_INT 8
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: PPUSH
6957: CALL_OW 69
6961: PPUSH
6962: LD_VAR 0 1
6966: PPUSH
6967: CALL_OW 74
6971: PPUSH
6972: CALL_OW 115
// end else
6976: GO 7005
// if IsDead ( i ) then
6978: LD_VAR 0 1
6982: PPUSH
6983: CALL_OW 301
6987: IFFALSE 7005
// tmp := tmp diff i ;
6989: LD_ADDR_VAR 0 3
6993: PUSH
6994: LD_VAR 0 3
6998: PUSH
6999: LD_VAR 0 1
7003: DIFF
7004: ST_TO_ADDR
// end ;
7005: GO 6870
7007: POP
7008: POP
// until not tmp ;
7009: LD_VAR 0 3
7013: NOT
7014: IFFALSE 6845
// end ; end_of_file
7016: PPOPN 3
7018: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7019: LD_INT 0
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
7025: PPUSH
7026: PPUSH
7027: PPUSH
7028: PPUSH
7029: PPUSH
// side := 3 ;
7030: LD_ADDR_VAR 0 6
7034: PUSH
7035: LD_INT 3
7037: ST_TO_ADDR
// uc_side := side ;
7038: LD_ADDR_OWVAR 20
7042: PUSH
7043: LD_VAR 0 6
7047: ST_TO_ADDR
// uc_nation := 3 ;
7048: LD_ADDR_OWVAR 21
7052: PUSH
7053: LD_INT 3
7055: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7056: LD_ADDR_VAR 0 2
7060: PUSH
7061: LD_INT 22
7063: PUSH
7064: LD_VAR 0 6
7068: PUSH
7069: EMPTY
7070: LIST
7071: LIST
7072: PUSH
7073: LD_INT 21
7075: PUSH
7076: LD_INT 3
7078: PUSH
7079: EMPTY
7080: LIST
7081: LIST
7082: PUSH
7083: EMPTY
7084: LIST
7085: LIST
7086: PPUSH
7087: CALL_OW 69
7091: PUSH
7092: FOR_IN
7093: IFFALSE 7109
// SetBLevel ( i , 10 ) ;
7095: LD_VAR 0 2
7099: PPUSH
7100: LD_INT 10
7102: PPUSH
7103: CALL_OW 241
7107: GO 7092
7109: POP
7110: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7111: LD_ADDR_VAR 0 9
7115: PUSH
7116: LD_INT 22
7118: PUSH
7119: LD_VAR 0 6
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 30
7130: PUSH
7131: LD_INT 34
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PPUSH
7142: CALL_OW 69
7146: ST_TO_ADDR
// if teleport then
7147: LD_VAR 0 9
7151: IFFALSE 7172
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7153: LD_VAR 0 9
7157: PUSH
7158: LD_INT 1
7160: ARRAY
7161: PPUSH
7162: LD_INT 123
7164: PPUSH
7165: LD_INT 122
7167: PPUSH
7168: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7172: LD_ADDR_EXP 64
7176: PUSH
7177: LD_STRING Platonov
7179: PPUSH
7180: CALL_OW 25
7184: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7185: LD_ADDR_EXP 65
7189: PUSH
7190: LD_STRING Kovalyuk
7192: PPUSH
7193: CALL_OW 25
7197: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7198: LD_ADDR_EXP 67
7202: PUSH
7203: LD_STRING Yakotich
7205: PPUSH
7206: LD_EXP 1
7210: NOT
7211: PPUSH
7212: LD_STRING 09_
7214: PPUSH
7215: CALL 65732 0 3
7219: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7220: LD_ADDR_EXP 66
7224: PUSH
7225: LD_STRING Bystrov
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7233: LD_ADDR_EXP 68
7237: PUSH
7238: LD_STRING Gleb
7240: PPUSH
7241: CALL_OW 25
7245: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7246: LD_STRING 03_Cornel
7248: PPUSH
7249: CALL_OW 28
7253: IFFALSE 7301
// begin Bierezov := NewCharacter ( Mikhail ) ;
7255: LD_ADDR_EXP 69
7259: PUSH
7260: LD_STRING Mikhail
7262: PPUSH
7263: CALL_OW 25
7267: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 69
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7289: LD_EXP 69
7293: PPUSH
7294: LD_INT 3
7296: PPUSH
7297: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7301: LD_EXP 64
7305: PPUSH
7306: LD_INT 126
7308: PPUSH
7309: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7313: LD_EXP 65
7317: PPUSH
7318: LD_INT 134
7320: PPUSH
7321: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7325: LD_EXP 67
7329: PPUSH
7330: LD_INT 197
7332: PPUSH
7333: LD_INT 111
7335: PPUSH
7336: LD_INT 9
7338: PPUSH
7339: LD_INT 0
7341: PPUSH
7342: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7346: LD_EXP 66
7350: PPUSH
7351: LD_INT 197
7353: PPUSH
7354: LD_INT 111
7356: PPUSH
7357: LD_INT 9
7359: PPUSH
7360: LD_INT 0
7362: PPUSH
7363: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7367: LD_EXP 68
7371: PPUSH
7372: LD_INT 197
7374: PPUSH
7375: LD_INT 111
7377: PPUSH
7378: LD_INT 9
7380: PPUSH
7381: LD_INT 0
7383: PPUSH
7384: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7388: LD_ADDR_VAR 0 5
7392: PUSH
7393: LD_INT 126
7395: PPUSH
7396: LD_INT 4
7398: PPUSH
7399: LD_STRING zhukov
7401: PPUSH
7402: LD_INT 9
7404: PUSH
7405: LD_INT 10
7407: PUSH
7408: LD_INT 10
7410: PUSH
7411: LD_INT 10
7413: PUSH
7414: EMPTY
7415: LIST
7416: LIST
7417: LIST
7418: LIST
7419: PUSH
7420: LD_OWVAR 67
7424: ARRAY
7425: PPUSH
7426: LD_INT 90000
7428: PUSH
7429: LD_INT 1000
7431: PUSH
7432: LD_INT 300
7434: PUSH
7435: EMPTY
7436: LIST
7437: LIST
7438: LIST
7439: PPUSH
7440: LD_INT 18
7442: PUSH
7443: LD_INT 8
7445: PUSH
7446: LD_INT 13
7448: PUSH
7449: LD_INT 8
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: PPUSH
7458: CALL 74191 0 6
7462: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7463: LD_ADDR_VAR 0 4
7467: PUSH
7468: LD_INT 267
7470: PPUSH
7471: CALL_OW 274
7475: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7476: LD_VAR 0 4
7480: PPUSH
7481: LD_INT 1
7483: PPUSH
7484: LD_INT 5000
7486: PPUSH
7487: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7491: LD_VAR 0 4
7495: PPUSH
7496: LD_INT 2
7498: PPUSH
7499: LD_INT 200
7501: PPUSH
7502: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7506: LD_VAR 0 4
7510: PPUSH
7511: LD_INT 3
7513: PPUSH
7514: LD_INT 200
7516: PPUSH
7517: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7521: LD_ADDR_EXP 97
7525: PUSH
7526: LD_EXP 97
7530: PPUSH
7531: LD_INT 2
7533: PPUSH
7534: LD_VAR 0 5
7538: PUSH
7539: LD_INT 22
7541: PUSH
7542: LD_VAR 0 6
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_INT 3
7553: PUSH
7554: LD_INT 21
7556: PUSH
7557: LD_INT 2
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PPUSH
7572: CALL_OW 69
7576: UNION
7577: PUSH
7578: LD_EXP 64
7582: DIFF
7583: PPUSH
7584: CALL_OW 1
7588: ST_TO_ADDR
// behemoths := [ ] ;
7589: LD_ADDR_EXP 72
7593: PUSH
7594: EMPTY
7595: ST_TO_ADDR
// behemothBuilders := [ ] ;
7596: LD_ADDR_EXP 73
7600: PUSH
7601: EMPTY
7602: ST_TO_ADDR
// if Kovalyuk then
7603: LD_EXP 65
7607: IFFALSE 7629
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7609: LD_ADDR_EXP 73
7613: PUSH
7614: LD_EXP 73
7618: PPUSH
7619: LD_EXP 65
7623: PPUSH
7624: CALL 103108 0 2
7628: ST_TO_ADDR
// j := 3 ;
7629: LD_ADDR_VAR 0 3
7633: PUSH
7634: LD_INT 3
7636: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7637: LD_ADDR_VAR 0 2
7641: PUSH
7642: LD_INT 22
7644: PUSH
7645: LD_INT 3
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: PUSH
7652: LD_INT 25
7654: PUSH
7655: LD_INT 3
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PPUSH
7666: CALL_OW 69
7670: PUSH
7671: LD_EXP 65
7675: DIFF
7676: PUSH
7677: FOR_IN
7678: IFFALSE 7728
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7680: LD_ADDR_EXP 73
7684: PUSH
7685: LD_EXP 73
7689: PPUSH
7690: LD_VAR 0 2
7694: PPUSH
7695: CALL 103108 0 2
7699: ST_TO_ADDR
// j := j - 1 ;
7700: LD_ADDR_VAR 0 3
7704: PUSH
7705: LD_VAR 0 3
7709: PUSH
7710: LD_INT 1
7712: MINUS
7713: ST_TO_ADDR
// if j = 0 then
7714: LD_VAR 0 3
7718: PUSH
7719: LD_INT 0
7721: EQUAL
7722: IFFALSE 7726
// break ;
7724: GO 7728
// end ;
7726: GO 7677
7728: POP
7729: POP
// end ;
7730: LD_VAR 0 1
7734: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7735: LD_INT 0
7737: PPUSH
7738: PPUSH
7739: PPUSH
7740: PPUSH
7741: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7742: LD_ADDR_VAR 0 4
7746: PUSH
7747: LD_INT 209
7749: PUSH
7750: LD_INT 149
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PUSH
7757: LD_INT 219
7759: PUSH
7760: LD_INT 154
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PUSH
7767: LD_INT 223
7769: PUSH
7770: LD_INT 149
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 232
7779: PUSH
7780: LD_INT 155
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: LIST
7791: LIST
7792: ST_TO_ADDR
// if not behemothBuilders then
7793: LD_EXP 73
7797: NOT
7798: IFFALSE 7802
// exit ;
7800: GO 7906
// j := 1 ;
7802: LD_ADDR_VAR 0 3
7806: PUSH
7807: LD_INT 1
7809: ST_TO_ADDR
// for i in behemothBuilders do
7810: LD_ADDR_VAR 0 2
7814: PUSH
7815: LD_EXP 73
7819: PUSH
7820: FOR_IN
7821: IFFALSE 7904
// begin if IsInUnit ( i ) then
7823: LD_VAR 0 2
7827: PPUSH
7828: CALL_OW 310
7832: IFFALSE 7843
// ComExitBuilding ( i ) ;
7834: LD_VAR 0 2
7838: PPUSH
7839: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7843: LD_VAR 0 2
7847: PPUSH
7848: LD_INT 37
7850: PPUSH
7851: LD_VAR 0 4
7855: PUSH
7856: LD_VAR 0 3
7860: ARRAY
7861: PUSH
7862: LD_INT 1
7864: ARRAY
7865: PPUSH
7866: LD_VAR 0 4
7870: PUSH
7871: LD_VAR 0 3
7875: ARRAY
7876: PUSH
7877: LD_INT 2
7879: ARRAY
7880: PPUSH
7881: LD_INT 0
7883: PPUSH
7884: CALL_OW 230
// j := j + 1 ;
7888: LD_ADDR_VAR 0 3
7892: PUSH
7893: LD_VAR 0 3
7897: PUSH
7898: LD_INT 1
7900: PLUS
7901: ST_TO_ADDR
// end ;
7902: GO 7820
7904: POP
7905: POP
// end ;
7906: LD_VAR 0 1
7910: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7911: LD_INT 24
7913: PPUSH
7914: LD_INT 30
7916: PUSH
7917: LD_INT 37
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PPUSH
7924: CALL_OW 70
7928: IFFALSE 7941
7930: GO 7932
7932: DISABLE
// behemothUnderConstruct := true ;
7933: LD_ADDR_EXP 26
7937: PUSH
7938: LD_INT 1
7940: ST_TO_ADDR
7941: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7942: LD_INT 3
7944: PPUSH
7945: CALL 103169 0 1
7949: PUSH
7950: LD_INT 22
7952: PUSH
7953: LD_INT 3
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PUSH
7960: LD_INT 30
7962: PUSH
7963: LD_INT 37
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: PUSH
7970: EMPTY
7971: LIST
7972: LIST
7973: PPUSH
7974: CALL_OW 69
7978: NOT
7979: AND
7980: IFFALSE 8166
7982: GO 7984
7984: DISABLE
7985: LD_INT 0
7987: PPUSH
7988: PPUSH
// begin enable ;
7989: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7990: LD_ADDR_VAR 0 2
7994: PUSH
7995: LD_INT 3
7997: PPUSH
7998: CALL 103169 0 1
8002: ST_TO_ADDR
// for i in tmp do
8003: LD_ADDR_VAR 0 1
8007: PUSH
8008: LD_VAR 0 2
8012: PUSH
8013: FOR_IN
8014: IFFALSE 8164
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 9
8023: PPUSH
8024: CALL_OW 308
8028: PUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 110
8038: PUSH
8039: LD_INT 2
8041: EQUAL
8042: NOT
8043: AND
8044: IFFALSE 8058
// SetTag ( i , 2 ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 2
8053: PPUSH
8054: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8058: LD_INT 81
8060: PUSH
8061: LD_INT 3
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PUSH
8068: LD_INT 91
8070: PUSH
8071: LD_VAR 0 1
8075: PUSH
8076: LD_INT 12
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: LIST
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PPUSH
8088: CALL_OW 69
8092: NOT
8093: PUSH
8094: LD_VAR 0 1
8098: PPUSH
8099: CALL_OW 110
8103: PUSH
8104: LD_INT 2
8106: EQUAL
8107: NOT
8108: AND
8109: IFFALSE 8128
// ComAgressiveMove ( i , 64 , 93 ) else
8111: LD_VAR 0 1
8115: PPUSH
8116: LD_INT 64
8118: PPUSH
8119: LD_INT 93
8121: PPUSH
8122: CALL_OW 114
8126: GO 8162
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8128: LD_VAR 0 1
8132: PPUSH
8133: LD_INT 81
8135: PUSH
8136: LD_INT 3
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PPUSH
8143: CALL_OW 69
8147: PPUSH
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 74
8157: PPUSH
8158: CALL_OW 115
// end ;
8162: GO 8013
8164: POP
8165: POP
// end ;
8166: PPOPN 2
8168: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8169: LD_INT 0
8171: PPUSH
8172: PPUSH
8173: PPUSH
// result := [ ] ;
8174: LD_ADDR_VAR 0 2
8178: PUSH
8179: EMPTY
8180: ST_TO_ADDR
// uc_side := 6 ;
8181: LD_ADDR_OWVAR 20
8185: PUSH
8186: LD_INT 6
8188: ST_TO_ADDR
// uc_nation := 3 ;
8189: LD_ADDR_OWVAR 21
8193: PUSH
8194: LD_INT 3
8196: ST_TO_ADDR
// case strength of 1 :
8197: LD_VAR 0 1
8201: PUSH
8202: LD_INT 1
8204: DOUBLE
8205: EQUAL
8206: IFTRUE 8210
8208: GO 8352
8210: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8211: LD_ADDR_VAR 0 3
8215: PUSH
8216: DOUBLE
8217: LD_INT 1
8219: DEC
8220: ST_TO_ADDR
8221: LD_INT 4
8223: PUSH
8224: LD_INT 5
8226: PUSH
8227: LD_INT 6
8229: PUSH
8230: LD_INT 7
8232: PUSH
8233: EMPTY
8234: LIST
8235: LIST
8236: LIST
8237: LIST
8238: PUSH
8239: LD_OWVAR 67
8243: ARRAY
8244: PUSH
8245: FOR_TO
8246: IFFALSE 8348
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8248: LD_INT 22
8250: PUSH
8251: LD_INT 24
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PUSH
8258: LD_VAR 0 3
8262: PUSH
8263: LD_INT 2
8265: MOD
8266: PUSH
8267: LD_INT 1
8269: PLUS
8270: ARRAY
8271: PPUSH
8272: LD_INT 1
8274: PUSH
8275: LD_INT 3
8277: PUSH
8278: EMPTY
8279: LIST
8280: LIST
8281: PUSH
8282: LD_INT 1
8284: PPUSH
8285: LD_INT 2
8287: PPUSH
8288: CALL_OW 12
8292: ARRAY
8293: PPUSH
8294: LD_INT 3
8296: PPUSH
8297: LD_INT 43
8299: PUSH
8300: LD_INT 44
8302: PUSH
8303: LD_INT 45
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 1
8313: PPUSH
8314: LD_INT 3
8316: PPUSH
8317: CALL_OW 12
8321: ARRAY
8322: PPUSH
8323: LD_INT 80
8325: PPUSH
8326: CALL 70747 0 5
// result := result union CreateVehicle ;
8330: LD_ADDR_VAR 0 2
8334: PUSH
8335: LD_VAR 0 2
8339: PUSH
8340: CALL_OW 45
8344: UNION
8345: ST_TO_ADDR
// end ;
8346: GO 8245
8348: POP
8349: POP
// end ; 2 :
8350: GO 9315
8352: LD_INT 2
8354: DOUBLE
8355: EQUAL
8356: IFTRUE 8360
8358: GO 8520
8360: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: DOUBLE
8367: LD_INT 1
8369: DEC
8370: ST_TO_ADDR
8371: LD_INT 5
8373: PUSH
8374: LD_INT 6
8376: PUSH
8377: LD_INT 7
8379: PUSH
8380: LD_INT 8
8382: PUSH
8383: EMPTY
8384: LIST
8385: LIST
8386: LIST
8387: LIST
8388: PUSH
8389: LD_OWVAR 67
8393: ARRAY
8394: PUSH
8395: FOR_TO
8396: IFFALSE 8516
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8398: LD_INT 22
8400: PUSH
8401: LD_INT 24
8403: PUSH
8404: LD_INT 24
8406: PUSH
8407: EMPTY
8408: LIST
8409: LIST
8410: LIST
8411: PUSH
8412: LD_VAR 0 3
8416: PUSH
8417: LD_INT 3
8419: MOD
8420: PUSH
8421: LD_INT 1
8423: PLUS
8424: ARRAY
8425: PPUSH
8426: LD_INT 1
8428: PUSH
8429: LD_INT 3
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PUSH
8436: LD_INT 1
8438: PPUSH
8439: LD_INT 2
8441: PPUSH
8442: CALL_OW 12
8446: ARRAY
8447: PPUSH
8448: LD_INT 3
8450: PPUSH
8451: LD_INT 43
8453: PUSH
8454: LD_INT 44
8456: PUSH
8457: LD_INT 45
8459: PUSH
8460: LD_INT 44
8462: PUSH
8463: LD_INT 46
8465: PUSH
8466: LD_INT 46
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: LIST
8475: LIST
8476: PUSH
8477: LD_VAR 0 3
8481: PUSH
8482: LD_INT 6
8484: MOD
8485: PUSH
8486: LD_INT 1
8488: PLUS
8489: ARRAY
8490: PPUSH
8491: LD_INT 80
8493: PPUSH
8494: CALL 70747 0 5
// result := result union CreateVehicle ;
8498: LD_ADDR_VAR 0 2
8502: PUSH
8503: LD_VAR 0 2
8507: PUSH
8508: CALL_OW 45
8512: UNION
8513: ST_TO_ADDR
// end ;
8514: GO 8395
8516: POP
8517: POP
// end ; 3 :
8518: GO 9315
8520: LD_INT 3
8522: DOUBLE
8523: EQUAL
8524: IFTRUE 8528
8526: GO 8688
8528: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8529: LD_ADDR_VAR 0 3
8533: PUSH
8534: DOUBLE
8535: LD_INT 1
8537: DEC
8538: ST_TO_ADDR
8539: LD_INT 5
8541: PUSH
8542: LD_INT 7
8544: PUSH
8545: LD_INT 8
8547: PUSH
8548: LD_INT 9
8550: PUSH
8551: EMPTY
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: PUSH
8557: LD_OWVAR 67
8561: ARRAY
8562: PUSH
8563: FOR_TO
8564: IFFALSE 8684
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8566: LD_INT 22
8568: PUSH
8569: LD_INT 24
8571: PUSH
8572: LD_INT 24
8574: PUSH
8575: EMPTY
8576: LIST
8577: LIST
8578: LIST
8579: PUSH
8580: LD_VAR 0 3
8584: PUSH
8585: LD_INT 3
8587: MOD
8588: PUSH
8589: LD_INT 1
8591: PLUS
8592: ARRAY
8593: PPUSH
8594: LD_INT 1
8596: PUSH
8597: LD_INT 3
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PUSH
8604: LD_INT 1
8606: PPUSH
8607: LD_INT 2
8609: PPUSH
8610: CALL_OW 12
8614: ARRAY
8615: PPUSH
8616: LD_INT 3
8618: PPUSH
8619: LD_INT 43
8621: PUSH
8622: LD_INT 47
8624: PUSH
8625: LD_INT 45
8627: PUSH
8628: LD_INT 45
8630: PUSH
8631: LD_INT 46
8633: PUSH
8634: LD_INT 46
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: PUSH
8645: LD_VAR 0 3
8649: PUSH
8650: LD_INT 6
8652: MOD
8653: PUSH
8654: LD_INT 1
8656: PLUS
8657: ARRAY
8658: PPUSH
8659: LD_INT 80
8661: PPUSH
8662: CALL 70747 0 5
// result := result union CreateVehicle ;
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: LD_VAR 0 2
8675: PUSH
8676: CALL_OW 45
8680: UNION
8681: ST_TO_ADDR
// end ;
8682: GO 8563
8684: POP
8685: POP
// end ; 4 :
8686: GO 9315
8688: LD_INT 4
8690: DOUBLE
8691: EQUAL
8692: IFTRUE 8696
8694: GO 9314
8696: POP
// begin uc_nation := 3 ;
8697: LD_ADDR_OWVAR 21
8701: PUSH
8702: LD_INT 3
8704: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8705: LD_ADDR_VAR 0 3
8709: PUSH
8710: DOUBLE
8711: LD_INT 1
8713: DEC
8714: ST_TO_ADDR
8715: LD_INT 6
8717: PUSH
8718: LD_INT 8
8720: PUSH
8721: LD_INT 9
8723: PUSH
8724: LD_INT 10
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: LIST
8731: LIST
8732: PUSH
8733: LD_OWVAR 67
8737: ARRAY
8738: PUSH
8739: FOR_TO
8740: IFFALSE 8860
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8742: LD_INT 22
8744: PUSH
8745: LD_INT 24
8747: PUSH
8748: LD_INT 24
8750: PUSH
8751: EMPTY
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: LD_VAR 0 3
8760: PUSH
8761: LD_INT 3
8763: MOD
8764: PUSH
8765: LD_INT 1
8767: PLUS
8768: ARRAY
8769: PPUSH
8770: LD_INT 1
8772: PUSH
8773: LD_INT 3
8775: PUSH
8776: EMPTY
8777: LIST
8778: LIST
8779: PUSH
8780: LD_INT 1
8782: PPUSH
8783: LD_INT 2
8785: PPUSH
8786: CALL_OW 12
8790: ARRAY
8791: PPUSH
8792: LD_INT 3
8794: PPUSH
8795: LD_INT 45
8797: PUSH
8798: LD_INT 47
8800: PUSH
8801: LD_INT 47
8803: PUSH
8804: LD_INT 45
8806: PUSH
8807: LD_INT 46
8809: PUSH
8810: LD_INT 46
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: LIST
8817: LIST
8818: LIST
8819: LIST
8820: PUSH
8821: LD_VAR 0 3
8825: PUSH
8826: LD_INT 6
8828: MOD
8829: PUSH
8830: LD_INT 1
8832: PLUS
8833: ARRAY
8834: PPUSH
8835: LD_INT 80
8837: PPUSH
8838: CALL 70747 0 5
// result := result union CreateVehicle ;
8842: LD_ADDR_VAR 0 2
8846: PUSH
8847: LD_VAR 0 2
8851: PUSH
8852: CALL_OW 45
8856: UNION
8857: ST_TO_ADDR
// end ;
8858: GO 8739
8860: POP
8861: POP
// if not KappaStatus then
8862: LD_EXP 2
8866: NOT
8867: IFFALSE 9102
// begin uc_nation := 1 ;
8869: LD_ADDR_OWVAR 21
8873: PUSH
8874: LD_INT 1
8876: ST_TO_ADDR
// for i = 1 to 3 do
8877: LD_ADDR_VAR 0 3
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_INT 3
8889: PUSH
8890: FOR_TO
8891: IFFALSE 9027
// begin j := rand ( 0 , 1 ) ;
8893: LD_ADDR_VAR 0 4
8897: PUSH
8898: LD_INT 0
8900: PPUSH
8901: LD_INT 1
8903: PPUSH
8904: CALL_OW 12
8908: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8909: LD_INT 3
8911: PUSH
8912: LD_INT 5
8914: PUSH
8915: LD_INT 5
8917: PUSH
8918: LD_INT 4
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: PUSH
8927: LD_VAR 0 4
8931: PUSH
8932: LD_INT 1
8934: PPUSH
8935: LD_INT 3
8937: PPUSH
8938: CALL_OW 12
8942: PLUS
8943: ARRAY
8944: PPUSH
8945: LD_INT 1
8947: PUSH
8948: LD_INT 3
8950: PUSH
8951: EMPTY
8952: LIST
8953: LIST
8954: PUSH
8955: LD_INT 1
8957: PPUSH
8958: LD_INT 2
8960: PPUSH
8961: CALL_OW 12
8965: ARRAY
8966: PPUSH
8967: LD_INT 3
8969: PPUSH
8970: LD_INT 9
8972: PUSH
8973: LD_INT 7
8975: PUSH
8976: LD_INT 6
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: LIST
8983: PUSH
8984: LD_VAR 0 4
8988: PUSH
8989: LD_INT 1
8991: PPUSH
8992: LD_INT 2
8994: PPUSH
8995: CALL_OW 12
8999: PLUS
9000: ARRAY
9001: PPUSH
9002: LD_INT 85
9004: PPUSH
9005: CALL 70747 0 5
// result := result union CreateVehicle ;
9009: LD_ADDR_VAR 0 2
9013: PUSH
9014: LD_VAR 0 2
9018: PUSH
9019: CALL_OW 45
9023: UNION
9024: ST_TO_ADDR
// end ;
9025: GO 8890
9027: POP
9028: POP
// if vsevolodFirstAttack then
9029: LD_EXP 24
9033: IFFALSE 9100
// begin vsevolodFirstAttack := false ;
9035: LD_ADDR_EXP 24
9039: PUSH
9040: LD_INT 0
9042: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9043: LD_INT 5
9045: PPUSH
9046: LD_INT 3
9048: PPUSH
9049: LD_INT 1
9051: PPUSH
9052: LD_INT 6
9054: PPUSH
9055: LD_INT 100
9057: PPUSH
9058: CALL 70747 0 5
// sewiVeh := CreateVehicle ;
9062: LD_ADDR_EXP 71
9066: PUSH
9067: CALL_OW 45
9071: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9072: LD_EXP 71
9076: PPUSH
9077: LD_INT 1
9079: PPUSH
9080: CALL_OW 242
// result := result union sewiVeh ;
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_VAR 0 2
9093: PUSH
9094: LD_EXP 71
9098: UNION
9099: ST_TO_ADDR
// end ; end else
9100: GO 9312
// if vsevolodFirstAttack then
9102: LD_EXP 24
9106: IFFALSE 9312
// begin vsevolodFirstAttack := false ;
9108: LD_ADDR_EXP 24
9112: PUSH
9113: LD_INT 0
9115: ST_TO_ADDR
// uc_nation := 3 ;
9116: LD_ADDR_OWVAR 21
9120: PUSH
9121: LD_INT 3
9123: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9124: LD_ADDR_VAR 0 3
9128: PUSH
9129: DOUBLE
9130: LD_INT 1
9132: DEC
9133: ST_TO_ADDR
9134: LD_INT 2
9136: PUSH
9137: LD_OWVAR 67
9141: PLUS
9142: PUSH
9143: FOR_TO
9144: IFFALSE 9252
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9146: LD_INT 22
9148: PUSH
9149: LD_INT 24
9151: PUSH
9152: LD_INT 24
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: LIST
9159: PUSH
9160: LD_VAR 0 3
9164: PUSH
9165: LD_INT 3
9167: MOD
9168: PUSH
9169: LD_INT 1
9171: PLUS
9172: ARRAY
9173: PPUSH
9174: LD_INT 1
9176: PUSH
9177: LD_INT 3
9179: PUSH
9180: EMPTY
9181: LIST
9182: LIST
9183: PUSH
9184: LD_INT 1
9186: PPUSH
9187: LD_INT 2
9189: PPUSH
9190: CALL_OW 12
9194: ARRAY
9195: PPUSH
9196: LD_INT 1
9198: PPUSH
9199: LD_INT 45
9201: PUSH
9202: LD_INT 47
9204: PUSH
9205: LD_INT 47
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: LIST
9212: PUSH
9213: LD_VAR 0 3
9217: PUSH
9218: LD_INT 3
9220: MOD
9221: PUSH
9222: LD_INT 1
9224: PLUS
9225: ARRAY
9226: PPUSH
9227: LD_INT 80
9229: PPUSH
9230: CALL 70747 0 5
// result := result union CreateVehicle ;
9234: LD_ADDR_VAR 0 2
9238: PUSH
9239: LD_VAR 0 2
9243: PUSH
9244: CALL_OW 45
9248: UNION
9249: ST_TO_ADDR
// end ;
9250: GO 9143
9252: POP
9253: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9254: LD_INT 24
9256: PPUSH
9257: LD_INT 3
9259: PPUSH
9260: LD_INT 1
9262: PPUSH
9263: LD_INT 47
9265: PPUSH
9266: LD_INT 100
9268: PPUSH
9269: CALL 70747 0 5
// sewiVeh := CreateVehicle ;
9273: LD_ADDR_EXP 71
9277: PUSH
9278: CALL_OW 45
9282: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9283: LD_EXP 71
9287: PPUSH
9288: LD_INT 6
9290: NEG
9291: PPUSH
9292: CALL_OW 242
// result := result union sewiVeh ;
9296: LD_ADDR_VAR 0 2
9300: PUSH
9301: LD_VAR 0 2
9305: PUSH
9306: LD_EXP 71
9310: UNION
9311: ST_TO_ADDR
// end ; end ; end ;
9312: GO 9315
9314: POP
// end ;
9315: LD_VAR 0 2
9319: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9320: LD_EXP 16
9324: IFFALSE 10169
9326: GO 9328
9328: DISABLE
9329: LD_INT 0
9331: PPUSH
9332: PPUSH
9333: PPUSH
9334: PPUSH
9335: PPUSH
9336: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9337: LD_ADDR_VAR 0 4
9341: PUSH
9342: LD_INT 11
9344: PUSH
9345: LD_INT 12
9347: PUSH
9348: EMPTY
9349: LIST
9350: LIST
9351: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9352: LD_ADDR_VAR 0 3
9356: PUSH
9357: LD_INT 11550
9359: PUSH
9360: LD_INT 10150
9362: PUSH
9363: LD_INT 9800
9365: PUSH
9366: LD_INT 9450
9368: PUSH
9369: EMPTY
9370: LIST
9371: LIST
9372: LIST
9373: LIST
9374: PUSH
9375: LD_OWVAR 67
9379: ARRAY
9380: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9381: LD_ADDR_VAR 0 6
9385: PUSH
9386: LD_INT 70
9388: PUSH
9389: LD_INT 118
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: LD_INT 78
9398: PUSH
9399: LD_INT 31
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: ST_TO_ADDR
// repeat if missionStage = 2 then
9410: LD_EXP 15
9414: PUSH
9415: LD_INT 2
9417: EQUAL
9418: IFFALSE 9429
// wait ( 1 1$30 ) else
9420: LD_INT 3150
9422: PPUSH
9423: CALL_OW 67
9427: GO 9438
// wait ( time ) ;
9429: LD_VAR 0 3
9433: PPUSH
9434: CALL_OW 67
// if missionStage = 6 then
9438: LD_EXP 15
9442: PUSH
9443: LD_INT 6
9445: EQUAL
9446: IFFALSE 9474
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9448: LD_INT 51
9450: PPUSH
9451: LD_INT 6
9453: PPUSH
9454: LD_INT 2
9456: PPUSH
9457: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9461: LD_INT 57
9463: PPUSH
9464: LD_INT 6
9466: PPUSH
9467: LD_INT 2
9469: PPUSH
9470: CALL_OW 322
// end ; if missionStage = 8 then
9474: LD_EXP 15
9478: PUSH
9479: LD_INT 8
9481: EQUAL
9482: IFFALSE 9510
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9484: LD_INT 52
9486: PPUSH
9487: LD_INT 6
9489: PPUSH
9490: LD_INT 2
9492: PPUSH
9493: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9497: LD_INT 58
9499: PPUSH
9500: LD_INT 6
9502: PPUSH
9503: LD_INT 2
9505: PPUSH
9506: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9510: LD_EXP 15
9514: PUSH
9515: LD_INT 10
9517: EQUAL
9518: PUSH
9519: LD_OWVAR 67
9523: PUSH
9524: LD_INT 1
9526: GREATER
9527: AND
9528: IFFALSE 9556
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9530: LD_INT 53
9532: PPUSH
9533: LD_INT 6
9535: PPUSH
9536: LD_INT 2
9538: PPUSH
9539: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9543: LD_INT 59
9545: PPUSH
9546: LD_INT 6
9548: PPUSH
9549: LD_INT 2
9551: PPUSH
9552: CALL_OW 322
// end ; if activeAttacks then
9556: LD_EXP 16
9560: IFFALSE 10163
// begin if missionStage = 2 then
9562: LD_EXP 15
9566: PUSH
9567: LD_INT 2
9569: EQUAL
9570: IFFALSE 9580
// strength := 1 ;
9572: LD_ADDR_VAR 0 5
9576: PUSH
9577: LD_INT 1
9579: ST_TO_ADDR
// if missionStage > 2 then
9580: LD_EXP 15
9584: PUSH
9585: LD_INT 2
9587: GREATER
9588: IFFALSE 9598
// strength := 2 ;
9590: LD_ADDR_VAR 0 5
9594: PUSH
9595: LD_INT 2
9597: ST_TO_ADDR
// if missionStage > 6 then
9598: LD_EXP 15
9602: PUSH
9603: LD_INT 6
9605: GREATER
9606: IFFALSE 9616
// strength := 3 ;
9608: LD_ADDR_VAR 0 5
9612: PUSH
9613: LD_INT 3
9615: ST_TO_ADDR
// if missionStage > 10 then
9616: LD_EXP 15
9620: PUSH
9621: LD_INT 10
9623: GREATER
9624: IFFALSE 9634
// strength := 4 ;
9626: LD_ADDR_VAR 0 5
9630: PUSH
9631: LD_INT 4
9633: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9634: LD_ADDR_VAR 0 2
9638: PUSH
9639: LD_VAR 0 5
9643: PPUSH
9644: CALL 8169 0 1
9648: ST_TO_ADDR
// for i in tmp do
9649: LD_ADDR_VAR 0 1
9653: PUSH
9654: LD_VAR 0 2
9658: PUSH
9659: FOR_IN
9660: IFFALSE 9843
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9662: LD_VAR 0 1
9666: PPUSH
9667: LD_VAR 0 4
9671: PUSH
9672: LD_INT 1
9674: PPUSH
9675: LD_INT 2
9677: PPUSH
9678: CALL_OW 12
9682: ARRAY
9683: PPUSH
9684: LD_INT 0
9686: PPUSH
9687: CALL_OW 49
// if i = sewiVeh then
9691: LD_VAR 0 1
9695: PUSH
9696: LD_EXP 71
9700: EQUAL
9701: IFFALSE 9738
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9703: LD_ADDR_EXP 70
9707: PUSH
9708: LD_STRING Vsevolod
9710: PPUSH
9711: LD_INT 0
9713: PPUSH
9714: LD_STRING 
9716: PPUSH
9717: CALL 65732 0 3
9721: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9722: LD_EXP 70
9726: PPUSH
9727: LD_VAR 0 1
9731: PPUSH
9732: CALL_OW 52
// end else
9736: GO 9819
// if GetControl ( i ) = control_manual then
9738: LD_VAR 0 1
9742: PPUSH
9743: CALL_OW 263
9747: PUSH
9748: LD_INT 1
9750: EQUAL
9751: IFFALSE 9819
// begin uc_side := 6 ;
9753: LD_ADDR_OWVAR 20
9757: PUSH
9758: LD_INT 6
9760: ST_TO_ADDR
// uc_nation := 3 ;
9761: LD_ADDR_OWVAR 21
9765: PUSH
9766: LD_INT 3
9768: ST_TO_ADDR
// hc_gallery :=  ;
9769: LD_ADDR_OWVAR 33
9773: PUSH
9774: LD_STRING 
9776: ST_TO_ADDR
// hc_name :=  ;
9777: LD_ADDR_OWVAR 26
9781: PUSH
9782: LD_STRING 
9784: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9785: LD_INT 0
9787: PPUSH
9788: LD_INT 3
9790: PPUSH
9791: LD_INT 10
9793: PPUSH
9794: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9798: CALL_OW 44
9802: PPUSH
9803: LD_VAR 0 1
9807: PPUSH
9808: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9812: LD_INT 10
9814: PPUSH
9815: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9819: LD_VAR 0 1
9823: PPUSH
9824: LD_INT 111
9826: PPUSH
9827: LD_INT 197
9829: PPUSH
9830: CALL_OW 111
// wait ( 0 0$2 ) ;
9834: LD_INT 70
9836: PPUSH
9837: CALL_OW 67
// end ;
9841: GO 9659
9843: POP
9844: POP
// repeat wait ( 0 0$1 ) ;
9845: LD_INT 35
9847: PPUSH
9848: CALL_OW 67
// for i in tmp do
9852: LD_ADDR_VAR 0 1
9856: PUSH
9857: LD_VAR 0 2
9861: PUSH
9862: FOR_IN
9863: IFFALSE 10144
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9865: LD_INT 81
9867: PUSH
9868: LD_INT 6
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: PUSH
9875: LD_INT 91
9877: PUSH
9878: LD_VAR 0 1
9882: PUSH
9883: LD_INT 12
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: EMPTY
9892: LIST
9893: LIST
9894: PPUSH
9895: CALL_OW 69
9899: IFFALSE 9957
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9901: LD_VAR 0 1
9905: PPUSH
9906: LD_INT 81
9908: PUSH
9909: LD_INT 6
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PUSH
9916: LD_INT 91
9918: PUSH
9919: LD_VAR 0 1
9923: PUSH
9924: LD_INT 12
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: LIST
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PPUSH
9936: CALL_OW 69
9940: PPUSH
9941: LD_VAR 0 1
9945: PPUSH
9946: CALL_OW 74
9950: PPUSH
9951: CALL_OW 115
9955: GO 10142
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9957: LD_INT 9
9959: PPUSH
9960: LD_INT 81
9962: PUSH
9963: LD_INT 6
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PPUSH
9970: CALL_OW 70
9974: IFFALSE 10108
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9976: LD_VAR 0 1
9980: PPUSH
9981: LD_VAR 0 6
9985: PUSH
9986: LD_INT 1
9988: ARRAY
9989: PUSH
9990: LD_INT 1
9992: ARRAY
9993: PPUSH
9994: LD_VAR 0 6
9998: PUSH
9999: LD_INT 1
10001: ARRAY
10002: PUSH
10003: LD_INT 2
10005: ARRAY
10006: PPUSH
10007: CALL_OW 297
10011: PUSH
10012: LD_INT 10
10014: GREATER
10015: PUSH
10016: LD_VAR 0 1
10020: PPUSH
10021: LD_INT 9
10023: PPUSH
10024: CALL_OW 308
10028: NOT
10029: AND
10030: IFFALSE 10069
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10032: LD_VAR 0 1
10036: PPUSH
10037: LD_VAR 0 6
10041: PUSH
10042: LD_INT 1
10044: ARRAY
10045: PUSH
10046: LD_INT 1
10048: ARRAY
10049: PPUSH
10050: LD_VAR 0 6
10054: PUSH
10055: LD_INT 1
10057: ARRAY
10058: PUSH
10059: LD_INT 2
10061: ARRAY
10062: PPUSH
10063: CALL_OW 114
10067: GO 10106
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10069: LD_VAR 0 1
10073: PPUSH
10074: LD_INT 9
10076: PPUSH
10077: LD_INT 81
10079: PUSH
10080: LD_INT 6
10082: PUSH
10083: EMPTY
10084: LIST
10085: LIST
10086: PPUSH
10087: CALL_OW 70
10091: PPUSH
10092: LD_VAR 0 1
10096: PPUSH
10097: CALL_OW 74
10101: PPUSH
10102: CALL_OW 115
// end else
10106: GO 10142
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10108: LD_VAR 0 1
10112: PPUSH
10113: LD_INT 81
10115: PUSH
10116: LD_INT 6
10118: PUSH
10119: EMPTY
10120: LIST
10121: LIST
10122: PPUSH
10123: CALL_OW 69
10127: PPUSH
10128: LD_VAR 0 1
10132: PPUSH
10133: CALL_OW 74
10137: PPUSH
10138: CALL_OW 115
// end ;
10142: GO 9862
10144: POP
10145: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10146: LD_INT 22
10148: PUSH
10149: LD_INT 6
10151: PUSH
10152: EMPTY
10153: LIST
10154: LIST
10155: PPUSH
10156: CALL_OW 69
10160: NOT
10161: IFFALSE 9845
// end ; until russianDestroyed ;
10163: LD_EXP 21
10167: IFFALSE 9410
// end ;
10169: PPOPN 6
10171: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10172: LD_EXP 21
10176: NOT
10177: PUSH
10178: LD_EXP 15
10182: PUSH
10183: LD_INT 6
10185: GREATEREQUAL
10186: AND
10187: PUSH
10188: LD_INT 2
10190: PPUSH
10191: LD_INT 1
10193: PPUSH
10194: CALL 60762 0 2
10198: NOT
10199: AND
10200: IFFALSE 11160
10202: GO 10204
10204: DISABLE
10205: LD_INT 0
10207: PPUSH
10208: PPUSH
10209: PPUSH
10210: PPUSH
// begin enable ;
10211: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10212: LD_INT 22
10214: PUSH
10215: LD_INT 3
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 30
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PPUSH
10236: CALL_OW 69
10240: NOT
10241: IFFALSE 10245
// exit ;
10243: GO 11160
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10245: LD_ADDR_VAR 0 4
10249: PUSH
10250: LD_INT 22
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: PUSH
10260: LD_INT 30
10262: PUSH
10263: LD_INT 34
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PPUSH
10274: CALL_OW 69
10278: ST_TO_ADDR
// if Prob ( 40 ) then
10279: LD_INT 40
10281: PPUSH
10282: CALL_OW 13
10286: IFFALSE 10413
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10288: LD_INT 2
10290: PPUSH
10291: LD_INT 22
10293: PUSH
10294: LD_INT 3
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 49
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: PUSH
10309: LD_INT 22
10311: PUSH
10312: LD_INT 3
10314: PUSH
10315: LD_INT 3
10317: PUSH
10318: LD_INT 49
10320: PUSH
10321: EMPTY
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 22
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 3
10335: PUSH
10336: LD_INT 49
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PUSH
10345: LD_INT 24
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 3
10353: PUSH
10354: LD_INT 46
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: LD_INT 24
10365: PUSH
10366: LD_INT 3
10368: PUSH
10369: LD_INT 3
10371: PUSH
10372: LD_INT 46
10374: PUSH
10375: EMPTY
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_INT 24
10383: PUSH
10384: LD_INT 3
10386: PUSH
10387: LD_INT 3
10389: PUSH
10390: LD_INT 46
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: LIST
10405: LIST
10406: PPUSH
10407: CALL 59344 0 2
// end else
10411: GO 10536
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10413: LD_INT 2
10415: PPUSH
10416: LD_INT 24
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 47
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 3
10442: PUSH
10443: LD_INT 47
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 24
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 3
10460: PUSH
10461: LD_INT 47
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PUSH
10470: LD_INT 24
10472: PUSH
10473: LD_INT 3
10475: PUSH
10476: LD_INT 3
10478: PUSH
10479: LD_INT 46
10481: PUSH
10482: EMPTY
10483: LIST
10484: LIST
10485: LIST
10486: LIST
10487: PUSH
10488: LD_INT 24
10490: PUSH
10491: LD_INT 3
10493: PUSH
10494: LD_INT 3
10496: PUSH
10497: LD_INT 46
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 24
10508: PUSH
10509: LD_INT 3
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: LD_INT 46
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: PPUSH
10532: CALL 59344 0 2
// end ; if Difficulty > 1 then
10536: LD_OWVAR 67
10540: PUSH
10541: LD_INT 1
10543: GREATER
10544: IFFALSE 10574
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10546: LD_INT 2
10548: PPUSH
10549: LD_INT 24
10551: PUSH
10552: LD_INT 3
10554: PUSH
10555: LD_INT 3
10557: PUSH
10558: LD_INT 47
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: PUSH
10567: EMPTY
10568: LIST
10569: PPUSH
10570: CALL 59344 0 2
// repeat wait ( 0 0$1 ) ;
10574: LD_INT 35
10576: PPUSH
10577: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10581: LD_INT 2
10583: PPUSH
10584: LD_INT 1
10586: PPUSH
10587: CALL 60762 0 2
10591: PUSH
10592: LD_INT 6
10594: PUSH
10595: LD_INT 7
10597: PUSH
10598: LD_INT 7
10600: PUSH
10601: LD_INT 7
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: PUSH
10610: LD_OWVAR 67
10614: ARRAY
10615: GREATEREQUAL
10616: IFFALSE 10574
// wait ( 0 0$30 ) ;
10618: LD_INT 1050
10620: PPUSH
10621: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10625: LD_ADDR_VAR 0 2
10629: PUSH
10630: LD_INT 2
10632: PPUSH
10633: LD_INT 1
10635: PPUSH
10636: CALL 60762 0 2
10640: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10641: LD_ADDR_EXP 116
10645: PUSH
10646: LD_EXP 116
10650: PPUSH
10651: LD_INT 2
10653: PPUSH
10654: LD_EXP 116
10658: PUSH
10659: LD_INT 2
10661: ARRAY
10662: PUSH
10663: LD_VAR 0 2
10667: DIFF
10668: PPUSH
10669: CALL_OW 1
10673: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10674: LD_ADDR_VAR 0 3
10678: PUSH
10679: LD_INT 0
10681: PPUSH
10682: LD_INT 1
10684: PPUSH
10685: CALL_OW 12
10689: ST_TO_ADDR
// if target then
10690: LD_VAR 0 3
10694: IFFALSE 10822
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10696: LD_ADDR_VAR 0 2
10700: PUSH
10701: LD_VAR 0 2
10705: PPUSH
10706: LD_INT 24
10708: PUSH
10709: LD_INT 250
10711: PUSH
10712: EMPTY
10713: LIST
10714: LIST
10715: PPUSH
10716: CALL_OW 72
10720: ST_TO_ADDR
// for i in tmp do
10721: LD_ADDR_VAR 0 1
10725: PUSH
10726: LD_VAR 0 2
10730: PUSH
10731: FOR_IN
10732: IFFALSE 10772
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10734: LD_VAR 0 1
10738: PPUSH
10739: LD_INT 139
10741: PPUSH
10742: LD_INT 89
10744: PPUSH
10745: CALL_OW 297
10749: PUSH
10750: LD_INT 9
10752: GREATER
10753: IFFALSE 10770
// ComMoveXY ( i , 139 , 89 ) ;
10755: LD_VAR 0 1
10759: PPUSH
10760: LD_INT 139
10762: PPUSH
10763: LD_INT 89
10765: PPUSH
10766: CALL_OW 111
10770: GO 10731
10772: POP
10773: POP
// wait ( 0 0$1 ) ;
10774: LD_INT 35
10776: PPUSH
10777: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10781: LD_VAR 0 2
10785: PPUSH
10786: LD_INT 92
10788: PUSH
10789: LD_INT 139
10791: PUSH
10792: LD_INT 89
10794: PUSH
10795: LD_INT 9
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: LIST
10802: LIST
10803: PPUSH
10804: CALL_OW 72
10808: PUSH
10809: LD_VAR 0 2
10813: PUSH
10814: LD_INT 1
10816: MINUS
10817: GREATEREQUAL
10818: IFFALSE 10696
// end else
10820: GO 10964
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10822: LD_VAR 0 2
10826: PPUSH
10827: LD_VAR 0 4
10831: PUSH
10832: LD_INT 1
10834: ARRAY
10835: PPUSH
10836: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10840: LD_ADDR_VAR 0 2
10844: PUSH
10845: LD_VAR 0 2
10849: PPUSH
10850: LD_INT 24
10852: PUSH
10853: LD_INT 250
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 72
10864: ST_TO_ADDR
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 10916
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_INT 124
10885: PPUSH
10886: LD_INT 139
10888: PPUSH
10889: CALL_OW 297
10893: PUSH
10894: LD_INT 9
10896: GREATER
10897: IFFALSE 10914
// ComMoveXY ( i , 124 , 139 ) ;
10899: LD_VAR 0 1
10903: PPUSH
10904: LD_INT 124
10906: PPUSH
10907: LD_INT 139
10909: PPUSH
10910: CALL_OW 111
10914: GO 10875
10916: POP
10917: POP
// wait ( 0 0$1 ) ;
10918: LD_INT 35
10920: PPUSH
10921: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10925: LD_VAR 0 2
10929: PPUSH
10930: LD_INT 92
10932: PUSH
10933: LD_INT 124
10935: PUSH
10936: LD_INT 139
10938: PUSH
10939: LD_INT 9
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: LIST
10946: LIST
10947: PPUSH
10948: CALL_OW 72
10952: PUSH
10953: LD_VAR 0 2
10957: PUSH
10958: LD_INT 1
10960: MINUS
10961: GREATEREQUAL
10962: IFFALSE 10840
// end ; repeat wait ( 0 0$1 ) ;
10964: LD_INT 35
10966: PPUSH
10967: CALL_OW 67
// for i in tmp do
10971: LD_ADDR_VAR 0 1
10975: PUSH
10976: LD_VAR 0 2
10980: PUSH
10981: FOR_IN
10982: IFFALSE 11151
// begin if GetLives ( i ) > 251 then
10984: LD_VAR 0 1
10988: PPUSH
10989: CALL_OW 256
10993: PUSH
10994: LD_INT 251
10996: GREATER
10997: IFFALSE 11122
// begin if GetWeapon ( i ) = ru_time_lapser then
10999: LD_VAR 0 1
11003: PPUSH
11004: CALL_OW 264
11008: PUSH
11009: LD_INT 49
11011: EQUAL
11012: IFFALSE 11068
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11014: LD_VAR 0 1
11018: PPUSH
11019: LD_INT 2
11021: PUSH
11022: LD_INT 22
11024: PUSH
11025: LD_INT 1
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: PUSH
11032: LD_INT 22
11034: PUSH
11035: LD_INT 8
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: LIST
11045: LIST
11046: PPUSH
11047: CALL_OW 69
11051: PPUSH
11052: LD_VAR 0 1
11056: PPUSH
11057: CALL_OW 74
11061: PPUSH
11062: CALL_OW 112
11066: GO 11120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11068: LD_VAR 0 1
11072: PPUSH
11073: LD_INT 2
11075: PUSH
11076: LD_INT 22
11078: PUSH
11079: LD_INT 1
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: PUSH
11086: LD_INT 22
11088: PUSH
11089: LD_INT 8
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: PUSH
11096: EMPTY
11097: LIST
11098: LIST
11099: LIST
11100: PPUSH
11101: CALL_OW 69
11105: PPUSH
11106: LD_VAR 0 1
11110: PPUSH
11111: CALL_OW 74
11115: PPUSH
11116: CALL_OW 115
// end else
11120: GO 11149
// if IsDead ( i ) then
11122: LD_VAR 0 1
11126: PPUSH
11127: CALL_OW 301
11131: IFFALSE 11149
// tmp := tmp diff i ;
11133: LD_ADDR_VAR 0 2
11137: PUSH
11138: LD_VAR 0 2
11142: PUSH
11143: LD_VAR 0 1
11147: DIFF
11148: ST_TO_ADDR
// end ;
11149: GO 10981
11151: POP
11152: POP
// until not tmp ;
11153: LD_VAR 0 2
11157: NOT
11158: IFFALSE 10964
// end ; end_of_file
11160: PPOPN 4
11162: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11163: LD_INT 0
11165: PPUSH
11166: PPUSH
11167: PPUSH
11168: PPUSH
11169: PPUSH
11170: PPUSH
// side := 7 ;
11171: LD_ADDR_VAR 0 5
11175: PUSH
11176: LD_INT 7
11178: ST_TO_ADDR
// uc_side := side ;
11179: LD_ADDR_OWVAR 20
11183: PUSH
11184: LD_VAR 0 5
11188: ST_TO_ADDR
// uc_nation := 1 ;
11189: LD_ADDR_OWVAR 21
11193: PUSH
11194: LD_INT 1
11196: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11197: LD_ADDR_VAR 0 2
11201: PUSH
11202: LD_INT 22
11204: PUSH
11205: LD_VAR 0 5
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PUSH
11214: LD_INT 21
11216: PUSH
11217: LD_INT 3
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PPUSH
11228: CALL_OW 69
11232: PUSH
11233: FOR_IN
11234: IFFALSE 11250
// SetBLevel ( i , 10 ) ;
11236: LD_VAR 0 2
11240: PPUSH
11241: LD_INT 10
11243: PPUSH
11244: CALL_OW 241
11248: GO 11233
11250: POP
11251: POP
// base := GetBase ( al_depot ) ;
11252: LD_ADDR_VAR 0 4
11256: PUSH
11257: LD_INT 2
11259: PPUSH
11260: CALL_OW 274
11264: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11265: LD_ADDR_VAR 0 6
11269: PUSH
11270: LD_INT 22
11272: PUSH
11273: LD_VAR 0 5
11277: PUSH
11278: EMPTY
11279: LIST
11280: LIST
11281: PUSH
11282: LD_INT 30
11284: PUSH
11285: LD_INT 34
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PUSH
11292: EMPTY
11293: LIST
11294: LIST
11295: PPUSH
11296: CALL_OW 69
11300: ST_TO_ADDR
// if teleport then
11301: LD_VAR 0 6
11305: IFFALSE 11326
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11307: LD_VAR 0 6
11311: PUSH
11312: LD_INT 1
11314: ARRAY
11315: PPUSH
11316: LD_INT 262
11318: PPUSH
11319: LD_INT 119
11321: PPUSH
11322: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11326: LD_VAR 0 4
11330: PPUSH
11331: LD_INT 1
11333: PPUSH
11334: LD_INT 19500
11336: PPUSH
11337: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11341: LD_VAR 0 4
11345: PPUSH
11346: LD_INT 2
11348: PPUSH
11349: LD_INT 200
11351: PPUSH
11352: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11356: LD_VAR 0 4
11360: PPUSH
11361: LD_INT 3
11363: PPUSH
11364: LD_INT 650
11366: PPUSH
11367: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11371: LD_ADDR_EXP 74
11375: PUSH
11376: LD_STRING Roth
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11384: LD_ADDR_EXP 75
11388: PUSH
11389: LD_STRING Simms
11391: PPUSH
11392: LD_EXP 1
11396: NOT
11397: PPUSH
11398: LD_STRING 10c_
11400: PPUSH
11401: CALL 65732 0 3
11405: ST_TO_ADDR
// if not Simms then
11406: LD_EXP 75
11410: NOT
11411: IFFALSE 11441
// begin uc_nation := 1 ;
11413: LD_ADDR_OWVAR 21
11417: PUSH
11418: LD_INT 1
11420: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11421: LD_INT 2
11423: PPUSH
11424: LD_INT 10
11426: PPUSH
11427: CALL_OW 384
// Simms := CreateHuman ;
11431: LD_ADDR_EXP 75
11435: PUSH
11436: CALL_OW 44
11440: ST_TO_ADDR
// end ; uc_nation := 3 ;
11441: LD_ADDR_OWVAR 21
11445: PUSH
11446: LD_INT 3
11448: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11449: LD_ADDR_EXP 76
11453: PUSH
11454: LD_STRING Kirilenkova
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11462: LD_ADDR_EXP 90
11466: PUSH
11467: LD_STRING Oblukov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11475: LD_ADDR_EXP 77
11479: PUSH
11480: LD_STRING Dolgov
11482: PPUSH
11483: CALL_OW 25
11487: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11488: LD_ADDR_EXP 78
11492: PUSH
11493: LD_STRING Petrosyan
11495: PPUSH
11496: CALL_OW 25
11500: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11501: LD_ADDR_EXP 89
11505: PUSH
11506: LD_STRING Scholtze
11508: PPUSH
11509: CALL_OW 25
11513: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11514: LD_ADDR_EXP 88
11518: PUSH
11519: LD_STRING Kapitsova
11521: PPUSH
11522: CALL_OW 25
11526: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11527: LD_ADDR_EXP 79
11531: PUSH
11532: LD_STRING Petrovova
11534: PPUSH
11535: CALL_OW 25
11539: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11540: LD_ADDR_EXP 80
11544: PUSH
11545: LD_STRING Kuzmov
11547: PPUSH
11548: CALL_OW 25
11552: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11553: LD_ADDR_EXP 87
11557: PUSH
11558: LD_STRING Karamazov
11560: PPUSH
11561: CALL_OW 25
11565: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11566: LD_STRING 13_Lipshchin_1
11568: PPUSH
11569: LD_INT 0
11571: PPUSH
11572: CALL_OW 30
11576: IFFALSE 11591
// Lipshchin := NewCharacter ( Lipshchin ) ;
11578: LD_ADDR_EXP 81
11582: PUSH
11583: LD_STRING Lipshchin
11585: PPUSH
11586: CALL_OW 25
11590: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11591: LD_STRING 13_Titov_1
11593: PPUSH
11594: LD_INT 0
11596: PPUSH
11597: CALL_OW 30
11601: IFFALSE 11616
// Titov := NewCharacter ( Titov ) ;
11603: LD_ADDR_EXP 83
11607: PUSH
11608: LD_STRING Titov
11610: PPUSH
11611: CALL_OW 25
11615: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11616: LD_STRING 13_Gnyevko_1
11618: PPUSH
11619: LD_INT 0
11621: PPUSH
11622: CALL_OW 30
11626: IFFALSE 11641
// Gnyevko := NewCharacter ( Gnyevko ) ;
11628: LD_ADDR_EXP 82
11632: PUSH
11633: LD_STRING Gnyevko
11635: PPUSH
11636: CALL_OW 25
11640: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11641: LD_STRING 13_Xavier_1
11643: PPUSH
11644: LD_INT 0
11646: PPUSH
11647: CALL_OW 30
11651: IFFALSE 11666
// Xavier := NewCharacter ( Xavier2 ) ;
11653: LD_ADDR_EXP 84
11657: PUSH
11658: LD_STRING Xavier2
11660: PPUSH
11661: CALL_OW 25
11665: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11666: LD_STRING 13_Belkov_1
11668: PPUSH
11669: LD_INT 0
11671: PPUSH
11672: CALL_OW 30
11676: IFFALSE 11691
// Belkov := NewCharacter ( Belkov ) ;
11678: LD_ADDR_EXP 85
11682: PUSH
11683: LD_STRING Belkov
11685: PPUSH
11686: CALL_OW 25
11690: ST_TO_ADDR
// if not BurlakStatus then
11691: LD_EXP 9
11695: NOT
11696: IFFALSE 11711
// Burlak = NewCharacter ( Burlak ) ;
11698: LD_ADDR_EXP 86
11702: PUSH
11703: LD_STRING Burlak
11705: PPUSH
11706: CALL_OW 25
11710: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11711: LD_ADDR_VAR 0 3
11715: PUSH
11716: LD_EXP 74
11720: PUSH
11721: LD_EXP 76
11725: PUSH
11726: LD_EXP 90
11730: PUSH
11731: LD_EXP 77
11735: PUSH
11736: LD_EXP 78
11740: PUSH
11741: LD_EXP 89
11745: PUSH
11746: LD_EXP 88
11750: PUSH
11751: LD_EXP 79
11755: PUSH
11756: LD_EXP 80
11760: PUSH
11761: LD_EXP 87
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: ST_TO_ADDR
// if Simms then
11778: LD_EXP 75
11782: IFFALSE 11800
// tmp := tmp ^ Simms ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 75
11798: ADD
11799: ST_TO_ADDR
// if Titov then
11800: LD_EXP 83
11804: IFFALSE 11822
// tmp := tmp ^ Titov ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 83
11820: ADD
11821: ST_TO_ADDR
// if Lipshchin then
11822: LD_EXP 81
11826: IFFALSE 11844
// tmp := tmp ^ Lipshchin ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 81
11842: ADD
11843: ST_TO_ADDR
// if Gnyevko then
11844: LD_EXP 82
11848: IFFALSE 11866
// tmp := tmp ^ Gnyevko ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 82
11864: ADD
11865: ST_TO_ADDR
// if Xavier then
11866: LD_EXP 84
11870: IFFALSE 11888
// tmp := tmp ^ Xavier ;
11872: LD_ADDR_VAR 0 3
11876: PUSH
11877: LD_VAR 0 3
11881: PUSH
11882: LD_EXP 84
11886: ADD
11887: ST_TO_ADDR
// if Belkov then
11888: LD_EXP 85
11892: IFFALSE 11910
// tmp := tmp ^ Belkov ;
11894: LD_ADDR_VAR 0 3
11898: PUSH
11899: LD_VAR 0 3
11903: PUSH
11904: LD_EXP 85
11908: ADD
11909: ST_TO_ADDR
// if Burlak then
11910: LD_EXP 86
11914: IFFALSE 11932
// tmp := tmp ^ Burlak ;
11916: LD_ADDR_VAR 0 3
11920: PUSH
11921: LD_VAR 0 3
11925: PUSH
11926: LD_EXP 86
11930: ADD
11931: ST_TO_ADDR
// for i = 1 to 11 do
11932: LD_ADDR_VAR 0 2
11936: PUSH
11937: DOUBLE
11938: LD_INT 1
11940: DEC
11941: ST_TO_ADDR
11942: LD_INT 11
11944: PUSH
11945: FOR_TO
11946: IFFALSE 12012
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11948: LD_ADDR_OWVAR 21
11952: PUSH
11953: LD_INT 1
11955: PUSH
11956: LD_INT 3
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: PUSH
11963: LD_INT 1
11965: PPUSH
11966: LD_INT 2
11968: PPUSH
11969: CALL_OW 12
11973: ARRAY
11974: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11975: LD_INT 0
11977: PPUSH
11978: LD_VAR 0 2
11982: PUSH
11983: LD_INT 2
11985: DIV
11986: PPUSH
11987: LD_INT 10
11989: PPUSH
11990: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11994: LD_ADDR_VAR 0 3
11998: PUSH
11999: LD_VAR 0 3
12003: PUSH
12004: CALL_OW 44
12008: ADD
12009: ST_TO_ADDR
// end ;
12010: GO 11945
12012: POP
12013: POP
// for i in tmp do
12014: LD_ADDR_VAR 0 2
12018: PUSH
12019: LD_VAR 0 3
12023: PUSH
12024: FOR_IN
12025: IFFALSE 12050
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12027: LD_VAR 0 2
12031: PPUSH
12032: LD_INT 260
12034: PPUSH
12035: LD_INT 235
12037: PPUSH
12038: LD_INT 8
12040: PPUSH
12041: LD_INT 0
12043: PPUSH
12044: CALL_OW 50
12048: GO 12024
12050: POP
12051: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12052: LD_ADDR_EXP 97
12056: PUSH
12057: LD_EXP 97
12061: PPUSH
12062: LD_INT 1
12064: PPUSH
12065: LD_INT 22
12067: PUSH
12068: LD_VAR 0 5
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PUSH
12077: LD_INT 3
12079: PUSH
12080: LD_INT 21
12082: PUSH
12083: LD_INT 2
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 69
12102: PUSH
12103: LD_EXP 74
12107: PUSH
12108: LD_EXP 75
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: DIFF
12117: PPUSH
12118: CALL_OW 1
12122: ST_TO_ADDR
// uc_side := 0 ;
12123: LD_ADDR_OWVAR 20
12127: PUSH
12128: LD_INT 0
12130: ST_TO_ADDR
// uc_nation := 0 ;
12131: LD_ADDR_OWVAR 21
12135: PUSH
12136: LD_INT 0
12138: ST_TO_ADDR
// for i = 1 to 5 do
12139: LD_ADDR_VAR 0 2
12143: PUSH
12144: DOUBLE
12145: LD_INT 1
12147: DEC
12148: ST_TO_ADDR
12149: LD_INT 5
12151: PUSH
12152: FOR_TO
12153: IFFALSE 12190
// begin InitHc ;
12155: CALL_OW 19
// hc_class := class_apeman ;
12159: LD_ADDR_OWVAR 28
12163: PUSH
12164: LD_INT 12
12166: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12167: CALL_OW 44
12171: PPUSH
12172: LD_INT 299
12174: PPUSH
12175: LD_INT 229
12177: PPUSH
12178: LD_INT 10
12180: PPUSH
12181: LD_INT 0
12183: PPUSH
12184: CALL_OW 50
// end ;
12188: GO 12152
12190: POP
12191: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12192: LD_EXP 74
12196: PPUSH
12197: LD_INT 259
12199: PPUSH
12200: LD_INT 235
12202: PPUSH
12203: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12207: LD_EXP 74
12211: PPUSH
12212: LD_INT 262
12214: PPUSH
12215: LD_INT 235
12217: PPUSH
12218: CALL_OW 178
// if Simms then
12222: LD_EXP 75
12226: IFFALSE 12257
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12228: LD_EXP 75
12232: PPUSH
12233: LD_INT 262
12235: PPUSH
12236: LD_INT 235
12238: PPUSH
12239: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12243: LD_EXP 75
12247: PPUSH
12248: LD_EXP 74
12252: PPUSH
12253: CALL_OW 179
// end ; end ;
12257: LD_VAR 0 1
12261: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12262: LD_EXP 31
12266: PUSH
12267: LD_EXP 23
12271: NOT
12272: AND
12273: IFFALSE 12449
12275: GO 12277
12277: DISABLE
12278: LD_INT 0
12280: PPUSH
12281: PPUSH
12282: PPUSH
// begin enable ;
12283: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12284: LD_ADDR_VAR 0 2
12288: PUSH
12289: LD_INT 81
12291: PUSH
12292: LD_INT 7
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 2
12301: PUSH
12302: LD_INT 32
12304: PUSH
12305: LD_INT 3
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 30
12314: PUSH
12315: LD_INT 30
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PUSH
12322: LD_INT 30
12324: PUSH
12325: LD_INT 28
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 34
12334: PUSH
12335: LD_INT 49
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: LD_INT 34
12344: PUSH
12345: LD_INT 10
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: PUSH
12352: LD_INT 34
12354: PUSH
12355: LD_INT 8
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: LIST
12366: LIST
12367: LIST
12368: LIST
12369: LIST
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PPUSH
12375: CALL_OW 69
12379: ST_TO_ADDR
// if not tmp then
12380: LD_VAR 0 2
12384: NOT
12385: IFFALSE 12389
// exit ;
12387: GO 12449
// target := tmp [ rand ( 1 , tmp ) ] ;
12389: LD_ADDR_VAR 0 3
12393: PUSH
12394: LD_VAR 0 2
12398: PUSH
12399: LD_INT 1
12401: PPUSH
12402: LD_VAR 0 2
12406: PPUSH
12407: CALL_OW 12
12411: ARRAY
12412: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12413: LD_VAR 0 3
12417: PPUSH
12418: CALL_OW 255
12422: PUSH
12423: LD_INT 1
12425: EQUAL
12426: IFFALSE 12437
// CenterNowOnUnits ( target ) ;
12428: LD_VAR 0 3
12432: PPUSH
12433: CALL_OW 87
// SetLives ( target , 0 ) ;
12437: LD_VAR 0 3
12441: PPUSH
12442: LD_INT 0
12444: PPUSH
12445: CALL_OW 234
// end ;
12449: PPOPN 3
12451: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12452: LD_EXP 23
12456: NOT
12457: PUSH
12458: LD_EXP 31
12462: AND
12463: IFFALSE 12989
12465: GO 12467
12467: DISABLE
12468: LD_INT 0
12470: PPUSH
12471: PPUSH
12472: PPUSH
// begin uc_side := 7 ;
12473: LD_ADDR_OWVAR 20
12477: PUSH
12478: LD_INT 7
12480: ST_TO_ADDR
// uc_nation := 1 ;
12481: LD_ADDR_OWVAR 21
12485: PUSH
12486: LD_INT 1
12488: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12489: LD_ADDR_VAR 0 3
12493: PUSH
12494: LD_INT 125
12496: PUSH
12497: LD_INT 163
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: PUSH
12504: LD_INT 185
12506: PUSH
12507: LD_INT 168
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: PUSH
12514: LD_INT 111
12516: PUSH
12517: LD_INT 97
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: PPUSH
12529: CALL 103213 0 1
12533: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12534: LD_ADDR_EXP 91
12538: PUSH
12539: EMPTY
12540: ST_TO_ADDR
// for i = 1 to Difficulty do
12541: LD_ADDR_VAR 0 1
12545: PUSH
12546: DOUBLE
12547: LD_INT 1
12549: DEC
12550: ST_TO_ADDR
12551: LD_OWVAR 67
12555: PUSH
12556: FOR_TO
12557: IFFALSE 12715
// begin InitHc ;
12559: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12563: LD_INT 0
12565: PPUSH
12566: LD_INT 8
12568: PPUSH
12569: CALL_OW 381
// un := CreateHuman ;
12573: LD_ADDR_VAR 0 2
12577: PUSH
12578: CALL_OW 44
12582: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12583: LD_VAR 0 2
12587: PPUSH
12588: LD_INT 258
12590: PPUSH
12591: LD_INT 267
12593: PPUSH
12594: LD_INT 4
12596: PPUSH
12597: LD_INT 0
12599: PPUSH
12600: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12604: LD_ADDR_EXP 91
12608: PUSH
12609: LD_EXP 91
12613: PUSH
12614: LD_VAR 0 2
12618: UNION
12619: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12620: LD_VAR 0 2
12624: PPUSH
12625: LD_VAR 0 3
12629: PUSH
12630: LD_VAR 0 1
12634: ARRAY
12635: PUSH
12636: LD_INT 1
12638: ARRAY
12639: PPUSH
12640: LD_VAR 0 3
12644: PUSH
12645: LD_VAR 0 1
12649: ARRAY
12650: PUSH
12651: LD_INT 2
12653: ARRAY
12654: PPUSH
12655: LD_INT 4
12657: PPUSH
12658: LD_INT 1
12660: PPUSH
12661: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12665: LD_VAR 0 2
12669: PPUSH
12670: LD_VAR 0 3
12674: PUSH
12675: LD_VAR 0 1
12679: ARRAY
12680: PUSH
12681: LD_INT 1
12683: ARRAY
12684: PPUSH
12685: LD_VAR 0 3
12689: PUSH
12690: LD_VAR 0 1
12694: ARRAY
12695: PUSH
12696: LD_INT 2
12698: ARRAY
12699: PPUSH
12700: CALL_OW 171
// AddComInvisible ( un ) ;
12704: LD_VAR 0 2
12708: PPUSH
12709: CALL_OW 212
// end ;
12713: GO 12556
12715: POP
12716: POP
// repeat wait ( 0 0$20 ) ;
12717: LD_INT 700
12719: PPUSH
12720: CALL_OW 67
// for i in allianceSpecialForce do
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: LD_EXP 91
12733: PUSH
12734: FOR_IN
12735: IFFALSE 12974
// begin if IsInvisible ( i ) then
12737: LD_VAR 0 1
12741: PPUSH
12742: CALL_OW 571
12746: IFFALSE 12943
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12748: LD_ADDR_VAR 0 3
12752: PUSH
12753: LD_INT 22
12755: PUSH
12756: LD_INT 1
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: PUSH
12763: LD_INT 50
12765: PUSH
12766: EMPTY
12767: LIST
12768: PUSH
12769: LD_INT 56
12771: PUSH
12772: EMPTY
12773: LIST
12774: PUSH
12775: LD_INT 91
12777: PUSH
12778: LD_VAR 0 1
12782: PUSH
12783: LD_INT 25
12785: PUSH
12786: LD_INT 30
12788: PUSH
12789: LD_INT 35
12791: PUSH
12792: LD_INT 40
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: PUSH
12801: LD_OWVAR 67
12805: ARRAY
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: LIST
12811: PUSH
12812: LD_INT 2
12814: PUSH
12815: LD_INT 25
12817: PUSH
12818: LD_INT 1
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 25
12827: PUSH
12828: LD_INT 2
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: PUSH
12835: LD_INT 25
12837: PUSH
12838: LD_INT 3
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PUSH
12845: LD_INT 25
12847: PUSH
12848: LD_INT 4
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: PUSH
12855: LD_INT 25
12857: PUSH
12858: LD_INT 5
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: PUSH
12865: LD_INT 25
12867: PUSH
12868: LD_INT 8
12870: PUSH
12871: EMPTY
12872: LIST
12873: LIST
12874: PUSH
12875: EMPTY
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: LIST
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: PPUSH
12891: CALL_OW 69
12895: ST_TO_ADDR
// if not tmp then
12896: LD_VAR 0 3
12900: NOT
12901: IFFALSE 12905
// continue ;
12903: GO 12734
// if Prob ( 30 * Difficulty ) then
12905: LD_INT 30
12907: PUSH
12908: LD_OWVAR 67
12912: MUL
12913: PPUSH
12914: CALL_OW 13
12918: IFFALSE 12943
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12920: LD_VAR 0 3
12924: PUSH
12925: LD_INT 1
12927: PPUSH
12928: LD_VAR 0 3
12932: PPUSH
12933: CALL_OW 12
12937: ARRAY
12938: PPUSH
12939: CALL 31292 0 1
// end ; if IsDead ( i ) then
12943: LD_VAR 0 1
12947: PPUSH
12948: CALL_OW 301
12952: IFFALSE 12972
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12954: LD_ADDR_EXP 91
12958: PUSH
12959: LD_EXP 91
12963: PUSH
12964: LD_VAR 0 1
12968: DIFF
12969: ST_TO_ADDR
// continue ;
12970: GO 12734
// end ; end ;
12972: GO 12734
12974: POP
12975: POP
// until allianceDestroyed or not allianceSpecialForce ;
12976: LD_EXP 23
12980: PUSH
12981: LD_EXP 91
12985: NOT
12986: OR
12987: IFFALSE 12717
// end ;
12989: PPOPN 3
12991: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12992: LD_EXP 23
12996: NOT
12997: PUSH
12998: LD_EXP 31
13002: AND
13003: IFFALSE 13974
13005: GO 13007
13007: DISABLE
13008: LD_INT 0
13010: PPUSH
13011: PPUSH
13012: PPUSH
13013: PPUSH
// begin enable ;
13014: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13015: LD_INT 22
13017: PUSH
13018: LD_INT 7
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: PUSH
13025: LD_INT 30
13027: PUSH
13028: LD_INT 3
13030: PUSH
13031: EMPTY
13032: LIST
13033: LIST
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PPUSH
13039: CALL_OW 69
13043: NOT
13044: IFFALSE 13048
// exit ;
13046: GO 13974
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13048: LD_ADDR_VAR 0 4
13052: PUSH
13053: LD_INT 22
13055: PUSH
13056: LD_INT 7
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 30
13065: PUSH
13066: LD_INT 34
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PPUSH
13077: CALL_OW 69
13081: ST_TO_ADDR
// if Prob ( 40 ) then
13082: LD_INT 40
13084: PPUSH
13085: CALL_OW 13
13089: IFFALSE 13216
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13091: LD_INT 1
13093: PPUSH
13094: LD_INT 5
13096: PUSH
13097: LD_INT 3
13099: PUSH
13100: LD_INT 2
13102: PUSH
13103: LD_INT 6
13105: PUSH
13106: EMPTY
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: PUSH
13112: LD_INT 5
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 2
13120: PUSH
13121: LD_INT 6
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: PUSH
13130: LD_INT 5
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 2
13138: PUSH
13139: LD_INT 6
13141: PUSH
13142: EMPTY
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: PUSH
13148: LD_INT 24
13150: PUSH
13151: LD_INT 3
13153: PUSH
13154: LD_INT 3
13156: PUSH
13157: LD_INT 45
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: PUSH
13166: LD_INT 24
13168: PUSH
13169: LD_INT 3
13171: PUSH
13172: LD_INT 3
13174: PUSH
13175: LD_INT 47
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: PUSH
13184: LD_INT 24
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 3
13192: PUSH
13193: LD_INT 45
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: PPUSH
13210: CALL 59344 0 2
// end else
13214: GO 13339
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13216: LD_INT 1
13218: PPUSH
13219: LD_INT 24
13221: PUSH
13222: LD_INT 3
13224: PUSH
13225: LD_INT 3
13227: PUSH
13228: LD_INT 47
13230: PUSH
13231: EMPTY
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: PUSH
13237: LD_INT 24
13239: PUSH
13240: LD_INT 3
13242: PUSH
13243: LD_INT 3
13245: PUSH
13246: LD_INT 47
13248: PUSH
13249: EMPTY
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: PUSH
13255: LD_INT 5
13257: PUSH
13258: LD_INT 3
13260: PUSH
13261: LD_INT 2
13263: PUSH
13264: LD_INT 9
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: LIST
13271: LIST
13272: PUSH
13273: LD_INT 5
13275: PUSH
13276: LD_INT 3
13278: PUSH
13279: LD_INT 2
13281: PUSH
13282: LD_INT 9
13284: PUSH
13285: EMPTY
13286: LIST
13287: LIST
13288: LIST
13289: LIST
13290: PUSH
13291: LD_INT 24
13293: PUSH
13294: LD_INT 1
13296: PUSH
13297: LD_INT 3
13299: PUSH
13300: LD_INT 45
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: LIST
13307: LIST
13308: PUSH
13309: LD_INT 24
13311: PUSH
13312: LD_INT 1
13314: PUSH
13315: LD_INT 3
13317: PUSH
13318: LD_INT 45
13320: PUSH
13321: EMPTY
13322: LIST
13323: LIST
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: PPUSH
13335: CALL 59344 0 2
// end ; if Difficulty > 1 then
13339: LD_OWVAR 67
13343: PUSH
13344: LD_INT 1
13346: GREATER
13347: IFFALSE 13377
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13349: LD_INT 1
13351: PPUSH
13352: LD_INT 24
13354: PUSH
13355: LD_INT 3
13357: PUSH
13358: LD_INT 3
13360: PUSH
13361: LD_INT 47
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: PUSH
13370: EMPTY
13371: LIST
13372: PPUSH
13373: CALL 59344 0 2
// repeat wait ( 0 0$1 ) ;
13377: LD_INT 35
13379: PPUSH
13380: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13384: LD_INT 1
13386: PPUSH
13387: LD_INT 1
13389: PPUSH
13390: CALL 60762 0 2
13394: PUSH
13395: LD_INT 6
13397: PUSH
13398: LD_INT 7
13400: PUSH
13401: LD_INT 7
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: LIST
13411: LIST
13412: PUSH
13413: LD_OWVAR 67
13417: ARRAY
13418: GREATEREQUAL
13419: IFFALSE 13377
// wait ( 0 0$40 ) ;
13421: LD_INT 1400
13423: PPUSH
13424: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13428: LD_ADDR_VAR 0 2
13432: PUSH
13433: LD_INT 1
13435: PPUSH
13436: LD_INT 1
13438: PPUSH
13439: CALL 60762 0 2
13443: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13444: LD_ADDR_EXP 116
13448: PUSH
13449: LD_EXP 116
13453: PPUSH
13454: LD_INT 1
13456: PPUSH
13457: LD_EXP 116
13461: PUSH
13462: LD_INT 1
13464: ARRAY
13465: PUSH
13466: LD_VAR 0 2
13470: DIFF
13471: PPUSH
13472: CALL_OW 1
13476: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13477: LD_ADDR_VAR 0 3
13481: PUSH
13482: LD_INT 0
13484: PPUSH
13485: LD_INT 1
13487: PPUSH
13488: CALL_OW 12
13492: ST_TO_ADDR
// if target then
13493: LD_VAR 0 3
13497: IFFALSE 13663
// begin for i in tmp do
13499: LD_ADDR_VAR 0 1
13503: PUSH
13504: LD_VAR 0 2
13508: PUSH
13509: FOR_IN
13510: IFFALSE 13535
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13512: LD_VAR 0 1
13516: PPUSH
13517: LD_INT 179
13519: PPUSH
13520: LD_INT 209
13522: PPUSH
13523: LD_INT 8
13525: PPUSH
13526: LD_INT 1
13528: PPUSH
13529: CALL_OW 483
13533: GO 13509
13535: POP
13536: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13537: LD_ADDR_VAR 0 2
13541: PUSH
13542: LD_VAR 0 2
13546: PPUSH
13547: LD_INT 24
13549: PUSH
13550: LD_INT 250
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PPUSH
13557: CALL_OW 72
13561: ST_TO_ADDR
// for i in tmp do
13562: LD_ADDR_VAR 0 1
13566: PUSH
13567: LD_VAR 0 2
13571: PUSH
13572: FOR_IN
13573: IFFALSE 13613
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13575: LD_VAR 0 1
13579: PPUSH
13580: LD_INT 179
13582: PPUSH
13583: LD_INT 209
13585: PPUSH
13586: CALL_OW 297
13590: PUSH
13591: LD_INT 9
13593: GREATER
13594: IFFALSE 13611
// ComMoveXY ( i , 179 , 209 ) ;
13596: LD_VAR 0 1
13600: PPUSH
13601: LD_INT 179
13603: PPUSH
13604: LD_INT 209
13606: PPUSH
13607: CALL_OW 111
13611: GO 13572
13613: POP
13614: POP
// wait ( 0 0$1 ) ;
13615: LD_INT 35
13617: PPUSH
13618: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13622: LD_VAR 0 2
13626: PPUSH
13627: LD_INT 92
13629: PUSH
13630: LD_INT 179
13632: PUSH
13633: LD_INT 209
13635: PUSH
13636: LD_INT 9
13638: PUSH
13639: EMPTY
13640: LIST
13641: LIST
13642: LIST
13643: LIST
13644: PPUSH
13645: CALL_OW 72
13649: PUSH
13650: LD_VAR 0 2
13654: PUSH
13655: LD_INT 1
13657: MINUS
13658: GREATEREQUAL
13659: IFFALSE 13537
// end else
13661: GO 13825
// begin for i in tmp do
13663: LD_ADDR_VAR 0 1
13667: PUSH
13668: LD_VAR 0 2
13672: PUSH
13673: FOR_IN
13674: IFFALSE 13699
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13676: LD_VAR 0 1
13680: PPUSH
13681: LD_INT 285
13683: PPUSH
13684: LD_INT 163
13686: PPUSH
13687: LD_INT 8
13689: PPUSH
13690: LD_INT 1
13692: PPUSH
13693: CALL_OW 483
13697: GO 13673
13699: POP
13700: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13701: LD_ADDR_VAR 0 2
13705: PUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_INT 24
13713: PUSH
13714: LD_INT 250
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: PPUSH
13721: CALL_OW 72
13725: ST_TO_ADDR
// for i in tmp do
13726: LD_ADDR_VAR 0 1
13730: PUSH
13731: LD_VAR 0 2
13735: PUSH
13736: FOR_IN
13737: IFFALSE 13777
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13739: LD_VAR 0 1
13743: PPUSH
13744: LD_INT 285
13746: PPUSH
13747: LD_INT 163
13749: PPUSH
13750: CALL_OW 297
13754: PUSH
13755: LD_INT 9
13757: GREATER
13758: IFFALSE 13775
// ComMoveXY ( i , 285 , 163 ) ;
13760: LD_VAR 0 1
13764: PPUSH
13765: LD_INT 285
13767: PPUSH
13768: LD_INT 163
13770: PPUSH
13771: CALL_OW 111
13775: GO 13736
13777: POP
13778: POP
// wait ( 0 0$1 ) ;
13779: LD_INT 35
13781: PPUSH
13782: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13786: LD_VAR 0 2
13790: PPUSH
13791: LD_INT 92
13793: PUSH
13794: LD_INT 285
13796: PUSH
13797: LD_INT 163
13799: PUSH
13800: LD_INT 9
13802: PUSH
13803: EMPTY
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: PPUSH
13809: CALL_OW 72
13813: PUSH
13814: LD_VAR 0 2
13818: PUSH
13819: LD_INT 1
13821: MINUS
13822: GREATEREQUAL
13823: IFFALSE 13701
// end ; repeat wait ( 0 0$1 ) ;
13825: LD_INT 35
13827: PPUSH
13828: CALL_OW 67
// for i in tmp do
13832: LD_ADDR_VAR 0 1
13836: PUSH
13837: LD_VAR 0 2
13841: PUSH
13842: FOR_IN
13843: IFFALSE 13965
// if GetLives ( i ) > 251 then
13845: LD_VAR 0 1
13849: PPUSH
13850: CALL_OW 256
13854: PUSH
13855: LD_INT 251
13857: GREATER
13858: IFFALSE 13947
// begin if GetWeapon ( i ) = ru_time_lapser then
13860: LD_VAR 0 1
13864: PPUSH
13865: CALL_OW 264
13869: PUSH
13870: LD_INT 49
13872: EQUAL
13873: IFFALSE 13911
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13875: LD_VAR 0 1
13879: PPUSH
13880: LD_INT 81
13882: PUSH
13883: LD_INT 7
13885: PUSH
13886: EMPTY
13887: LIST
13888: LIST
13889: PPUSH
13890: CALL_OW 69
13894: PPUSH
13895: LD_VAR 0 1
13899: PPUSH
13900: CALL_OW 74
13904: PPUSH
13905: CALL_OW 112
13909: GO 13945
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_INT 81
13918: PUSH
13919: LD_INT 7
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: PPUSH
13926: CALL_OW 69
13930: PPUSH
13931: LD_VAR 0 1
13935: PPUSH
13936: CALL_OW 74
13940: PPUSH
13941: CALL_OW 115
// end else
13945: GO 13963
// tmp := tmp diff i ;
13947: LD_ADDR_VAR 0 2
13951: PUSH
13952: LD_VAR 0 2
13956: PUSH
13957: LD_VAR 0 1
13961: DIFF
13962: ST_TO_ADDR
13963: GO 13842
13965: POP
13966: POP
// until not tmp ;
13967: LD_VAR 0 2
13971: NOT
13972: IFFALSE 13825
// end ; end_of_file
13974: PPOPN 4
13976: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13977: LD_INT 0
13979: PPUSH
13980: PPUSH
13981: PPUSH
13982: PPUSH
// missionStage := 13 ;
13983: LD_ADDR_EXP 15
13987: PUSH
13988: LD_INT 13
13990: ST_TO_ADDR
// uc_side := 2 ;
13991: LD_ADDR_OWVAR 20
13995: PUSH
13996: LD_INT 2
13998: ST_TO_ADDR
// uc_nation := 2 ;
13999: LD_ADDR_OWVAR 21
14003: PUSH
14004: LD_INT 2
14006: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14007: LD_ADDR_EXP 92
14011: PUSH
14012: LD_STRING Omar
14014: PPUSH
14015: CALL_OW 25
14019: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14020: LD_EXP 92
14024: PPUSH
14025: LD_INT 4
14027: PPUSH
14028: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14032: LD_EXP 92
14036: PPUSH
14037: LD_INT 242
14039: PPUSH
14040: LD_INT 75
14042: PPUSH
14043: LD_INT 0
14045: PPUSH
14046: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14050: LD_ADDR_EXP 93
14054: PUSH
14055: LD_STRING Heike
14057: PPUSH
14058: CALL_OW 25
14062: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14063: LD_INT 14
14065: PPUSH
14066: LD_INT 3
14068: PPUSH
14069: LD_INT 1
14071: PPUSH
14072: LD_INT 27
14074: PPUSH
14075: LD_INT 100
14077: PPUSH
14078: CALL 70747 0 5
// veh := CreateVehicle ;
14082: LD_ADDR_VAR 0 3
14086: PUSH
14087: CALL_OW 45
14091: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14092: LD_VAR 0 3
14096: PPUSH
14097: LD_INT 2
14099: NEG
14100: PPUSH
14101: CALL_OW 242
// SetDir ( veh , 4 ) ;
14105: LD_VAR 0 3
14109: PPUSH
14110: LD_INT 4
14112: PPUSH
14113: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14117: LD_VAR 0 3
14121: PPUSH
14122: LD_INT 241
14124: PPUSH
14125: LD_INT 72
14127: PPUSH
14128: LD_INT 0
14130: PPUSH
14131: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14135: LD_EXP 93
14139: PPUSH
14140: LD_VAR 0 3
14144: PPUSH
14145: CALL_OW 52
// if KhatamStatus then
14149: LD_EXP 8
14153: IFFALSE 14216
// begin Khatam := NewCharacter ( Khatam ) ;
14155: LD_ADDR_EXP 94
14159: PUSH
14160: LD_STRING Khatam
14162: PPUSH
14163: CALL_OW 25
14167: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14168: LD_EXP 94
14172: PPUSH
14173: LD_INT 245
14175: PPUSH
14176: LD_INT 78
14178: PPUSH
14179: LD_INT 3
14181: PPUSH
14182: LD_INT 0
14184: PPUSH
14185: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14189: LD_EXP 94
14193: PPUSH
14194: LD_INT 4
14196: PPUSH
14197: LD_INT 10
14199: PPUSH
14200: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14204: LD_EXP 94
14208: PPUSH
14209: LD_INT 4
14211: PPUSH
14212: CALL_OW 336
// end ; for i = 1 to Difficulty do
14216: LD_ADDR_VAR 0 2
14220: PUSH
14221: DOUBLE
14222: LD_INT 1
14224: DEC
14225: ST_TO_ADDR
14226: LD_OWVAR 67
14230: PUSH
14231: FOR_TO
14232: IFFALSE 14298
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14234: LD_INT 0
14236: PPUSH
14237: LD_INT 7
14239: PUSH
14240: LD_OWVAR 67
14244: PLUS
14245: PPUSH
14246: CALL_OW 384
// un := CreateHuman ;
14250: LD_ADDR_VAR 0 4
14254: PUSH
14255: CALL_OW 44
14259: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14260: LD_VAR 0 4
14264: PPUSH
14265: LD_INT 28
14267: PUSH
14268: LD_INT 29
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: PUSH
14275: LD_VAR 0 2
14279: PUSH
14280: LD_INT 2
14282: MOD
14283: PUSH
14284: LD_INT 1
14286: PLUS
14287: ARRAY
14288: PPUSH
14289: LD_INT 0
14291: PPUSH
14292: CALL_OW 49
// end ;
14296: GO 14231
14298: POP
14299: POP
// for i = 1 to 6 do
14300: LD_ADDR_VAR 0 2
14304: PUSH
14305: DOUBLE
14306: LD_INT 1
14308: DEC
14309: ST_TO_ADDR
14310: LD_INT 6
14312: PUSH
14313: FOR_TO
14314: IFFALSE 14359
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14316: LD_INT 0
14318: PPUSH
14319: LD_INT 7
14321: PUSH
14322: LD_OWVAR 67
14326: PLUS
14327: PPUSH
14328: CALL_OW 381
// un := CreateHuman ;
14332: LD_ADDR_VAR 0 4
14336: PUSH
14337: CALL_OW 44
14341: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14342: LD_VAR 0 4
14346: PPUSH
14347: LD_INT 28
14349: PPUSH
14350: LD_INT 0
14352: PPUSH
14353: CALL_OW 49
// end ;
14357: GO 14313
14359: POP
14360: POP
// for i = 1 to 3 do
14361: LD_ADDR_VAR 0 2
14365: PUSH
14366: DOUBLE
14367: LD_INT 1
14369: DEC
14370: ST_TO_ADDR
14371: LD_INT 3
14373: PUSH
14374: FOR_TO
14375: IFFALSE 14423
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14377: LD_INT 0
14379: PPUSH
14380: LD_INT 8
14382: PPUSH
14383: LD_INT 7
14385: PUSH
14386: LD_OWVAR 67
14390: PLUS
14391: PPUSH
14392: CALL_OW 380
// un := CreateHuman ;
14396: LD_ADDR_VAR 0 4
14400: PUSH
14401: CALL_OW 44
14405: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14406: LD_VAR 0 4
14410: PPUSH
14411: LD_INT 28
14413: PPUSH
14414: LD_INT 0
14416: PPUSH
14417: CALL_OW 49
// end ;
14421: GO 14374
14423: POP
14424: POP
// for i = 1 to 3 do
14425: LD_ADDR_VAR 0 2
14429: PUSH
14430: DOUBLE
14431: LD_INT 1
14433: DEC
14434: ST_TO_ADDR
14435: LD_INT 3
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14529
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 2
14446: PPUSH
14447: LD_INT 1
14449: PPUSH
14450: LD_INT 28
14452: PPUSH
14453: LD_INT 80
14455: PPUSH
14456: CALL 70747 0 5
// veh := CreateVehicle ;
14460: LD_ADDR_VAR 0 3
14464: PUSH
14465: CALL_OW 45
14469: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14470: LD_VAR 0 3
14474: PPUSH
14475: LD_INT 3
14477: PPUSH
14478: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14482: LD_VAR 0 3
14486: PPUSH
14487: LD_INT 29
14489: PPUSH
14490: LD_INT 0
14492: PPUSH
14493: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14497: LD_INT 0
14499: PPUSH
14500: LD_INT 7
14502: PUSH
14503: LD_OWVAR 67
14507: PLUS
14508: PPUSH
14509: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14513: CALL_OW 44
14517: PPUSH
14518: LD_VAR 0 3
14522: PPUSH
14523: CALL_OW 52
// end ;
14527: GO 14438
14529: POP
14530: POP
// for i = 1 to 5 + Difficulty do
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: DOUBLE
14537: LD_INT 1
14539: DEC
14540: ST_TO_ADDR
14541: LD_INT 5
14543: PUSH
14544: LD_OWVAR 67
14548: PLUS
14549: PUSH
14550: FOR_TO
14551: IFFALSE 14678
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14553: LD_INT 14
14555: PPUSH
14556: LD_INT 1
14558: PPUSH
14559: LD_INT 3
14561: PPUSH
14562: CALL_OW 12
14566: PPUSH
14567: LD_INT 1
14569: PPUSH
14570: LD_INT 28
14572: PUSH
14573: LD_INT 26
14575: PUSH
14576: LD_INT 27
14578: PUSH
14579: LD_INT 25
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: PUSH
14588: LD_VAR 0 2
14592: PUSH
14593: LD_INT 4
14595: MOD
14596: PUSH
14597: LD_INT 1
14599: PLUS
14600: ARRAY
14601: PPUSH
14602: LD_INT 80
14604: PPUSH
14605: CALL 70747 0 5
// veh := CreateVehicle ;
14609: LD_ADDR_VAR 0 3
14613: PUSH
14614: CALL_OW 45
14618: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14619: LD_VAR 0 3
14623: PPUSH
14624: LD_INT 4
14626: PPUSH
14627: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14631: LD_VAR 0 3
14635: PPUSH
14636: LD_INT 28
14638: PPUSH
14639: LD_INT 0
14641: PPUSH
14642: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14646: LD_INT 0
14648: PPUSH
14649: LD_INT 7
14651: PUSH
14652: LD_OWVAR 67
14656: PLUS
14657: PPUSH
14658: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14662: CALL_OW 44
14666: PPUSH
14667: LD_VAR 0 3
14671: PPUSH
14672: CALL_OW 52
// end ;
14676: GO 14550
14678: POP
14679: POP
// for i = 1 to 3 do
14680: LD_ADDR_VAR 0 2
14684: PUSH
14685: DOUBLE
14686: LD_INT 1
14688: DEC
14689: ST_TO_ADDR
14690: LD_INT 3
14692: PUSH
14693: FOR_TO
14694: IFFALSE 14754
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14696: LD_INT 14
14698: PPUSH
14699: LD_INT 3
14701: PPUSH
14702: LD_INT 5
14704: PPUSH
14705: LD_INT 29
14707: PPUSH
14708: LD_INT 80
14710: PPUSH
14711: CALL 70747 0 5
// veh := CreateVehicle ;
14715: LD_ADDR_VAR 0 3
14719: PUSH
14720: CALL_OW 45
14724: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14725: LD_VAR 0 3
14729: PPUSH
14730: LD_INT 4
14732: PPUSH
14733: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14737: LD_VAR 0 3
14741: PPUSH
14742: LD_INT 28
14744: PPUSH
14745: LD_INT 0
14747: PPUSH
14748: CALL_OW 49
// end ;
14752: GO 14693
14754: POP
14755: POP
// end ;
14756: LD_VAR 0 1
14760: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14761: LD_INT 22
14763: PUSH
14764: LD_INT 2
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PPUSH
14771: CALL_OW 69
14775: IFFALSE 15075
14777: GO 14779
14779: DISABLE
14780: LD_INT 0
14782: PPUSH
14783: PPUSH
14784: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 2
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 25
14802: PUSH
14803: LD_INT 4
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 69
14818: PUSH
14819: LD_EXP 94
14823: DIFF
14824: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14825: LD_ADDR_VAR 0 2
14829: PUSH
14830: LD_INT 22
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PPUSH
14840: CALL_OW 69
14844: PUSH
14845: LD_EXP 94
14849: PUSH
14850: LD_VAR 0 3
14854: UNION
14855: DIFF
14856: ST_TO_ADDR
// if Khatam then
14857: LD_EXP 94
14861: IFFALSE 14878
// ComMoveXY ( Khatam , 211 , 92 ) ;
14863: LD_EXP 94
14867: PPUSH
14868: LD_INT 211
14870: PPUSH
14871: LD_INT 92
14873: PPUSH
14874: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14878: LD_INT 197
14880: PPUSH
14881: LD_INT 80
14883: PPUSH
14884: LD_INT 2
14886: PPUSH
14887: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14891: LD_INT 213
14893: PPUSH
14894: LD_INT 90
14896: PPUSH
14897: LD_INT 2
14899: PPUSH
14900: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14904: LD_INT 215
14906: PPUSH
14907: LD_INT 129
14909: PPUSH
14910: LD_INT 2
14912: PPUSH
14913: CALL_OW 441
// if sci then
14917: LD_VAR 0 3
14921: IFFALSE 14942
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14923: LD_VAR 0 3
14927: PUSH
14928: LD_INT 1
14930: ARRAY
14931: PPUSH
14932: LD_INT 197
14934: PPUSH
14935: LD_INT 80
14937: PPUSH
14938: CALL_OW 158
// if sci > 1 then
14942: LD_VAR 0 3
14946: PUSH
14947: LD_INT 1
14949: GREATER
14950: IFFALSE 14971
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14952: LD_VAR 0 3
14956: PUSH
14957: LD_INT 2
14959: ARRAY
14960: PPUSH
14961: LD_INT 213
14963: PPUSH
14964: LD_INT 90
14966: PPUSH
14967: CALL_OW 158
// if sci > 2 then
14971: LD_VAR 0 3
14975: PUSH
14976: LD_INT 2
14978: GREATER
14979: IFFALSE 15000
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14981: LD_VAR 0 3
14985: PUSH
14986: LD_INT 3
14988: ARRAY
14989: PPUSH
14990: LD_INT 215
14992: PPUSH
14993: LD_INT 129
14995: PPUSH
14996: CALL_OW 158
// repeat wait ( 0 0$2 ) ;
15000: LD_INT 70
15002: PPUSH
15003: CALL_OW 67
// for i in tmp do
15007: LD_ADDR_VAR 0 1
15011: PUSH
15012: LD_VAR 0 2
15016: PUSH
15017: FOR_IN
15018: IFFALSE 15056
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15020: LD_VAR 0 1
15024: PPUSH
15025: LD_INT 81
15027: PUSH
15028: LD_INT 2
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: PPUSH
15035: CALL_OW 69
15039: PPUSH
15040: LD_VAR 0 1
15044: PPUSH
15045: CALL_OW 74
15049: PPUSH
15050: CALL_OW 115
15054: GO 15017
15056: POP
15057: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15058: LD_INT 22
15060: PUSH
15061: LD_INT 2
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: NOT
15073: IFFALSE 15000
// end ; end_of_file
15075: PPOPN 3
15077: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15078: LD_INT 0
15080: PPUSH
15081: PPUSH
15082: PPUSH
15083: PPUSH
15084: PPUSH
15085: PPUSH
15086: PPUSH
15087: PPUSH
15088: PPUSH
// Video ( true ) ;
15089: LD_INT 1
15091: PPUSH
15092: CALL 103080 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15096: LD_ADDR_VAR 0 5
15100: PUSH
15101: LD_INT 7
15103: PPUSH
15104: LD_INT 0
15106: PPUSH
15107: CALL_OW 517
15111: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15112: LD_ADDR_VAR 0 2
15116: PUSH
15117: DOUBLE
15118: LD_INT 1
15120: DEC
15121: ST_TO_ADDR
15122: LD_VAR 0 5
15126: PUSH
15127: LD_INT 1
15129: ARRAY
15130: PUSH
15131: FOR_TO
15132: IFFALSE 15177
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15134: LD_VAR 0 5
15138: PUSH
15139: LD_INT 1
15141: ARRAY
15142: PUSH
15143: LD_VAR 0 2
15147: ARRAY
15148: PPUSH
15149: LD_VAR 0 5
15153: PUSH
15154: LD_INT 2
15156: ARRAY
15157: PUSH
15158: LD_VAR 0 2
15162: ARRAY
15163: PPUSH
15164: LD_INT 1
15166: PPUSH
15167: LD_INT 15
15169: NEG
15170: PPUSH
15171: CALL 102994 0 4
15175: GO 15131
15177: POP
15178: POP
// CenterNowOnUnits ( Powell ) ;
15179: LD_EXP 58
15183: PPUSH
15184: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15188: LD_ADDR_VAR 0 5
15192: PUSH
15193: LD_EXP 56
15197: PUSH
15198: EMPTY
15199: LIST
15200: ST_TO_ADDR
// if GirlNewVeh then
15201: LD_EXP 57
15205: IFFALSE 15223
// tmp := tmp ^ GirlNewVeh ;
15207: LD_ADDR_VAR 0 5
15211: PUSH
15212: LD_VAR 0 5
15216: PUSH
15217: LD_EXP 57
15221: ADD
15222: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15223: LD_VAR 0 5
15227: PPUSH
15228: LD_INT 60
15230: PPUSH
15231: LD_INT 109
15233: PPUSH
15234: CALL_OW 111
// if KappaStatus then
15238: LD_EXP 2
15242: IFFALSE 15294
// begin Say ( JMM , D1nT-JMM-1 ) ;
15244: LD_EXP 39
15248: PPUSH
15249: LD_STRING D1nT-JMM-1
15251: PPUSH
15252: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15256: LD_EXP 58
15260: PPUSH
15261: LD_STRING D1T-Pow-1
15263: PPUSH
15264: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15268: LD_EXP 39
15272: PPUSH
15273: LD_STRING D1T-JMM-2
15275: PPUSH
15276: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15280: LD_EXP 58
15284: PPUSH
15285: LD_STRING D1T-Pow-2
15287: PPUSH
15288: CALL_OW 88
// end else
15292: GO 15500
// if JMMGirlStatus then
15294: LD_EXP 6
15298: IFFALSE 15443
// begin Say ( JMM , D1T-JMM-1 ) ;
15300: LD_EXP 39
15304: PPUSH
15305: LD_STRING D1T-JMM-1
15307: PPUSH
15308: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15312: LD_EXP 58
15316: PPUSH
15317: LD_STRING D1T-Pow-1
15319: PPUSH
15320: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15324: LD_EXP 39
15328: PPUSH
15329: LD_STRING D1T-JMM-3
15331: PPUSH
15332: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15336: LD_EXP 58
15340: PPUSH
15341: LD_STRING D1T-Pow-3
15343: PPUSH
15344: CALL_OW 88
// if JMMGirl then
15348: LD_EXP 7
15352: IFFALSE 15441
// begin case JMMGirl of 1 :
15354: LD_EXP 7
15358: PUSH
15359: LD_INT 1
15361: DOUBLE
15362: EQUAL
15363: IFTRUE 15367
15365: GO 15382
15367: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15368: LD_EXP 40
15372: PPUSH
15373: LD_STRING D1T-Joan-3
15375: PPUSH
15376: CALL_OW 88
15380: GO 15429
15382: LD_INT 2
15384: DOUBLE
15385: EQUAL
15386: IFTRUE 15390
15388: GO 15405
15390: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15391: LD_EXP 42
15395: PPUSH
15396: LD_STRING D1T-Lisa-3
15398: PPUSH
15399: CALL_OW 88
15403: GO 15429
15405: LD_INT 3
15407: DOUBLE
15408: EQUAL
15409: IFTRUE 15413
15411: GO 15428
15413: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15414: LD_EXP 54
15418: PPUSH
15419: LD_STRING D1T-Con-3
15421: PPUSH
15422: CALL_OW 88
15426: GO 15429
15428: POP
// Say ( Powell , D1T-Pow-4 ) ;
15429: LD_EXP 58
15433: PPUSH
15434: LD_STRING D1T-Pow-4
15436: PPUSH
15437: CALL_OW 88
// end ; end else
15441: GO 15500
// if not FastEnd then
15443: LD_EXP 11
15447: NOT
15448: IFFALSE 15476
// begin Say ( JMM , D1T-JMM-4 ) ;
15450: LD_EXP 39
15454: PPUSH
15455: LD_STRING D1T-JMM-4
15457: PPUSH
15458: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15462: LD_EXP 58
15466: PPUSH
15467: LD_STRING D1T-Pow-5
15469: PPUSH
15470: CALL_OW 88
// end else
15474: GO 15500
// begin Say ( JMM , D1nT-JMM-1 ) ;
15476: LD_EXP 39
15480: PPUSH
15481: LD_STRING D1nT-JMM-1
15483: PPUSH
15484: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15488: LD_EXP 58
15492: PPUSH
15493: LD_STRING D1nT-Pow-1
15495: PPUSH
15496: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15500: LD_INT 35
15502: PPUSH
15503: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15507: LD_EXP 56
15511: PPUSH
15512: CALL_OW 314
15516: NOT
15517: IFFALSE 15500
// ComExitVehicle ( JMM ) ;
15519: LD_EXP 39
15523: PPUSH
15524: CALL_OW 121
// wait ( 3 ) ;
15528: LD_INT 3
15530: PPUSH
15531: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15535: LD_EXP 39
15539: PPUSH
15540: LD_INT 60
15542: PPUSH
15543: LD_INT 94
15545: PPUSH
15546: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15550: LD_EXP 39
15554: PPUSH
15555: LD_EXP 58
15559: PPUSH
15560: CALL_OW 179
// if Joan then
15564: LD_EXP 40
15568: IFFALSE 15622
// begin ComExitVehicle ( Joan ) ;
15570: LD_EXP 40
15574: PPUSH
15575: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15579: LD_EXP 40
15583: PPUSH
15584: LD_INT 35
15586: PPUSH
15587: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15591: LD_EXP 40
15595: PPUSH
15596: LD_INT 65
15598: PPUSH
15599: LD_INT 104
15601: PPUSH
15602: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15606: LD_EXP 40
15610: PPUSH
15611: LD_EXP 39
15615: PPUSH
15616: CALL_OW 179
// end else
15620: GO 15756
// if Lisa and JMMGirl = 2 then
15622: LD_EXP 42
15626: PUSH
15627: LD_EXP 7
15631: PUSH
15632: LD_INT 2
15634: EQUAL
15635: AND
15636: IFFALSE 15690
// begin ComExitVehicle ( Lisa ) ;
15638: LD_EXP 42
15642: PPUSH
15643: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15647: LD_EXP 42
15651: PPUSH
15652: LD_INT 35
15654: PPUSH
15655: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15659: LD_EXP 42
15663: PPUSH
15664: LD_INT 65
15666: PPUSH
15667: LD_INT 104
15669: PPUSH
15670: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15674: LD_EXP 42
15678: PPUSH
15679: LD_EXP 39
15683: PPUSH
15684: CALL_OW 179
// end else
15688: GO 15756
// if Connie and JMMGirl = 3 then
15690: LD_EXP 54
15694: PUSH
15695: LD_EXP 7
15699: PUSH
15700: LD_INT 3
15702: EQUAL
15703: AND
15704: IFFALSE 15756
// begin ComExitVehicle ( Connie ) ;
15706: LD_EXP 54
15710: PPUSH
15711: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15715: LD_EXP 54
15719: PPUSH
15720: LD_INT 35
15722: PPUSH
15723: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15727: LD_EXP 54
15731: PPUSH
15732: LD_INT 65
15734: PPUSH
15735: LD_INT 104
15737: PPUSH
15738: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15742: LD_EXP 54
15746: PPUSH
15747: LD_EXP 39
15751: PPUSH
15752: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15756: LD_INT 35
15758: PPUSH
15759: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15763: LD_EXP 39
15767: PPUSH
15768: LD_EXP 58
15772: PPUSH
15773: CALL_OW 296
15777: PUSH
15778: LD_INT 6
15780: LESS
15781: IFFALSE 15756
// wait ( 0 0$0.5 ) ;
15783: LD_INT 18
15785: PPUSH
15786: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15790: LD_EXP 39
15794: PPUSH
15795: LD_STRING D1-JMM-1
15797: PPUSH
15798: CALL_OW 88
// async ;
15802: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15803: LD_EXP 58
15807: PPUSH
15808: LD_STRING D1-Pow-1
15810: PPUSH
15811: CALL_OW 88
// if not dialogue_skipped then
15815: LD_OWVAR 59
15819: NOT
15820: IFFALSE 15829
// wait ( 0 0$2 ) ;
15822: LD_INT 70
15824: PPUSH
15825: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15829: LD_INT 170
15831: PPUSH
15832: LD_INT 99
15834: PPUSH
15835: LD_INT 1
15837: PPUSH
15838: LD_INT 6
15840: NEG
15841: PPUSH
15842: CALL 102994 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15846: LD_INT 174
15848: PPUSH
15849: LD_INT 115
15851: PPUSH
15852: LD_INT 1
15854: PPUSH
15855: LD_INT 6
15857: NEG
15858: PPUSH
15859: CALL 102994 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15863: LD_INT 169
15865: PPUSH
15866: LD_INT 71
15868: PPUSH
15869: LD_INT 1
15871: PPUSH
15872: LD_INT 6
15874: NEG
15875: PPUSH
15876: CALL 102994 0 4
// if not dialogue_skipped then
15880: LD_OWVAR 59
15884: NOT
15885: IFFALSE 15904
// begin CenterOnXY ( 170 , 99 ) ;
15887: LD_INT 170
15889: PPUSH
15890: LD_INT 99
15892: PPUSH
15893: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15897: LD_INT 80
15899: PPUSH
15900: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15904: LD_INT 75
15906: PPUSH
15907: LD_INT 53
15909: PPUSH
15910: LD_INT 1
15912: PPUSH
15913: LD_INT 9
15915: NEG
15916: PPUSH
15917: CALL 102994 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15921: LD_INT 54
15923: PPUSH
15924: LD_INT 42
15926: PPUSH
15927: LD_INT 1
15929: PPUSH
15930: LD_INT 9
15932: NEG
15933: PPUSH
15934: CALL 102994 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15938: LD_INT 62
15940: PPUSH
15941: LD_INT 51
15943: PPUSH
15944: LD_INT 1
15946: PPUSH
15947: LD_INT 9
15949: NEG
15950: PPUSH
15951: CALL 102994 0 4
// if not dialogue_skipped then
15955: LD_OWVAR 59
15959: NOT
15960: IFFALSE 15979
// begin CenterOnXY ( 75 , 53 ) ;
15962: LD_INT 75
15964: PPUSH
15965: LD_INT 53
15967: PPUSH
15968: CALL_OW 84
// wait ( 0 0$4 ) ;
15972: LD_INT 140
15974: PPUSH
15975: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15979: LD_EXP 58
15983: PPUSH
15984: CALL_OW 87
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$2 ) ;
15995: LD_INT 70
15997: PPUSH
15998: CALL_OW 67
// sync ;
16002: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16003: LD_EXP 39
16007: PPUSH
16008: LD_STRING D1-JMM-2
16010: PPUSH
16011: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16015: LD_EXP 58
16019: PPUSH
16020: LD_STRING D1-Pow-2
16022: PPUSH
16023: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16027: LD_EXP 39
16031: PPUSH
16032: LD_STRING D1-JMM-3
16034: PPUSH
16035: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16039: LD_EXP 58
16043: PPUSH
16044: LD_STRING D1-Pow-3
16046: PPUSH
16047: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16051: LD_EXP 39
16055: PPUSH
16056: LD_STRING D1-JMM-4
16058: PPUSH
16059: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16063: LD_EXP 58
16067: PPUSH
16068: LD_STRING D1-Pow-4
16070: PPUSH
16071: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16075: LD_EXP 39
16079: PPUSH
16080: LD_STRING D1-JMM-5
16082: PPUSH
16083: CALL_OW 88
// async ;
16087: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16088: LD_EXP 58
16092: PPUSH
16093: LD_STRING D1-Pow-5
16095: PPUSH
16096: CALL_OW 88
// if not dialogue_skipped then
16100: LD_OWVAR 59
16104: NOT
16105: IFFALSE 16114
// wait ( 0 0$3.6 ) ;
16107: LD_INT 126
16109: PPUSH
16110: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16114: LD_INT 134
16116: PPUSH
16117: LD_INT 210
16119: PPUSH
16120: LD_INT 1
16122: PPUSH
16123: LD_INT 11
16125: NEG
16126: PPUSH
16127: CALL 102994 0 4
// if not dialogue_skipped then
16131: LD_OWVAR 59
16135: NOT
16136: IFFALSE 16155
// begin CenterOnXY ( 134 , 210 ) ;
16138: LD_INT 134
16140: PPUSH
16141: LD_INT 210
16143: PPUSH
16144: CALL_OW 84
// wait ( 0 0$2 ) ;
16148: LD_INT 70
16150: PPUSH
16151: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16155: LD_INT 101
16157: PPUSH
16158: LD_INT 159
16160: PPUSH
16161: LD_INT 1
16163: PPUSH
16164: LD_INT 10
16166: NEG
16167: PPUSH
16168: CALL 102994 0 4
// if not dialogue_skipped then
16172: LD_OWVAR 59
16176: NOT
16177: IFFALSE 16196
// begin CenterOnXY ( 101 , 159 ) ;
16179: LD_INT 101
16181: PPUSH
16182: LD_INT 159
16184: PPUSH
16185: CALL_OW 84
// wait ( 0 0$2 ) ;
16189: LD_INT 70
16191: PPUSH
16192: CALL_OW 67
// end ; sync ;
16196: SYNC
// CenterNowOnUnits ( Powell ) ;
16197: LD_EXP 58
16201: PPUSH
16202: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16206: LD_ADDR_VAR 0 6
16210: PUSH
16211: LD_INT 1
16213: PUSH
16214: LD_INT 2
16216: PUSH
16217: LD_INT 3
16219: PUSH
16220: LD_INT 4
16222: PUSH
16223: LD_INT 5
16225: PUSH
16226: LD_INT 6
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: ST_TO_ADDR
// if not dialogue_skipped then
16237: LD_OWVAR 59
16241: NOT
16242: IFFALSE 16411
// begin game_speed := 4 ;
16244: LD_ADDR_OWVAR 65
16248: PUSH
16249: LD_INT 4
16251: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16252: LD_INT 210
16254: PPUSH
16255: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16259: LD_ADDR_VAR 0 7
16263: PUSH
16264: LD_STRING Q1
16266: PPUSH
16267: LD_VAR 0 6
16271: PPUSH
16272: CALL_OW 98
16276: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16277: LD_ADDR_VAR 0 7
16281: PUSH
16282: LD_STRING Q1
16284: PPUSH
16285: LD_VAR 0 6
16289: PPUSH
16290: CALL_OW 98
16294: ST_TO_ADDR
// options = options diff dec ;
16295: LD_ADDR_VAR 0 6
16299: PUSH
16300: LD_VAR 0 6
16304: PUSH
16305: LD_VAR 0 7
16309: DIFF
16310: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16311: LD_VAR 0 7
16315: PPUSH
16316: LD_VAR 0 6
16320: PPUSH
16321: CALL 17883 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16325: LD_VAR 0 7
16329: PUSH
16330: LD_INT 5
16332: PUSH
16333: LD_INT 6
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: IN
16340: PUSH
16341: LD_VAR 0 6
16345: PUSH
16346: LD_INT 2
16348: EQUAL
16349: OR
16350: IFFALSE 16277
// if not ( dec in [ 5 , 6 ] ) then
16352: LD_VAR 0 7
16356: PUSH
16357: LD_INT 5
16359: PUSH
16360: LD_INT 6
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: IN
16367: NOT
16368: IFFALSE 16411
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16370: LD_ADDR_VAR 0 7
16374: PUSH
16375: LD_STRING Q1a
16377: PPUSH
16378: LD_INT 1
16380: PUSH
16381: LD_INT 2
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PPUSH
16388: CALL_OW 98
16392: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16393: LD_VAR 0 7
16397: PUSH
16398: LD_INT 4
16400: PLUS
16401: PPUSH
16402: LD_VAR 0 6
16406: PPUSH
16407: CALL 17883 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16411: LD_INT 81
16413: PPUSH
16414: LD_INT 127
16416: PPUSH
16417: CALL_OW 84
// amount := 5 ;
16421: LD_ADDR_VAR 0 8
16425: PUSH
16426: LD_INT 5
16428: ST_TO_ADDR
// macmilan_squad := [ ] ;
16429: LD_ADDR_VAR 0 9
16433: PUSH
16434: EMPTY
16435: ST_TO_ADDR
// if vip < amount then
16436: LD_EXP 59
16440: PUSH
16441: LD_VAR 0 8
16445: LESS
16446: IFFALSE 16490
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16448: LD_ADDR_VAR 0 5
16452: PUSH
16453: LD_EXP 59
16457: PUSH
16458: LD_INT 22
16460: PUSH
16461: LD_INT 4
16463: PUSH
16464: EMPTY
16465: LIST
16466: LIST
16467: PUSH
16468: LD_INT 21
16470: PUSH
16471: LD_INT 1
16473: PUSH
16474: EMPTY
16475: LIST
16476: LIST
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PPUSH
16482: CALL_OW 69
16486: UNION
16487: ST_TO_ADDR
16488: GO 16500
// tmp := vip ;
16490: LD_ADDR_VAR 0 5
16494: PUSH
16495: LD_EXP 59
16499: ST_TO_ADDR
// tmp := tmp diff Powell ;
16500: LD_ADDR_VAR 0 5
16504: PUSH
16505: LD_VAR 0 5
16509: PUSH
16510: LD_EXP 58
16514: DIFF
16515: ST_TO_ADDR
// if tmp < amount then
16516: LD_VAR 0 5
16520: PUSH
16521: LD_VAR 0 8
16525: LESS
16526: IFFALSE 16538
// amount := tmp ;
16528: LD_ADDR_VAR 0 8
16532: PUSH
16533: LD_VAR 0 5
16537: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16538: LD_VAR 0 5
16542: PUSH
16543: LD_INT 1
16545: ARRAY
16546: PPUSH
16547: CALL_OW 257
16551: PUSH
16552: LD_INT 2
16554: NONEQUAL
16555: IFFALSE 16617
// begin if IsInUnit ( tmp [ 1 ] ) then
16557: LD_VAR 0 5
16561: PUSH
16562: LD_INT 1
16564: ARRAY
16565: PPUSH
16566: CALL_OW 310
16570: IFFALSE 16585
// ComExitBuilding ( tmp [ 1 ] ) ;
16572: LD_VAR 0 5
16576: PUSH
16577: LD_INT 1
16579: ARRAY
16580: PPUSH
16581: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16585: LD_VAR 0 5
16589: PUSH
16590: LD_INT 1
16592: ARRAY
16593: PPUSH
16594: LD_INT 387
16596: PPUSH
16597: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16601: LD_VAR 0 5
16605: PUSH
16606: LD_INT 1
16608: ARRAY
16609: PPUSH
16610: LD_INT 2
16612: PPUSH
16613: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16617: LD_EXP 39
16621: PPUSH
16622: LD_INT 82
16624: PPUSH
16625: LD_INT 129
16627: PPUSH
16628: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16632: LD_EXP 39
16636: PPUSH
16637: LD_EXP 58
16641: PPUSH
16642: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16646: LD_INT 22
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PPUSH
16656: CALL_OW 69
16660: PUSH
16661: LD_EXP 39
16665: DIFF
16666: PPUSH
16667: LD_INT 84
16669: PPUSH
16670: LD_INT 128
16672: PPUSH
16673: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16677: LD_INT 22
16679: PUSH
16680: LD_INT 1
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: PPUSH
16687: CALL_OW 69
16691: PUSH
16692: LD_EXP 39
16696: DIFF
16697: PPUSH
16698: LD_EXP 39
16702: PPUSH
16703: CALL_OW 179
// for i = 1 to amount do
16707: LD_ADDR_VAR 0 2
16711: PUSH
16712: DOUBLE
16713: LD_INT 1
16715: DEC
16716: ST_TO_ADDR
16717: LD_VAR 0 8
16721: PUSH
16722: FOR_TO
16723: IFFALSE 16891
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16725: LD_ADDR_VAR 0 9
16729: PUSH
16730: LD_VAR 0 9
16734: PUSH
16735: LD_VAR 0 5
16739: PUSH
16740: LD_VAR 0 2
16744: ARRAY
16745: ADD
16746: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16747: LD_VAR 0 5
16751: PUSH
16752: LD_VAR 0 2
16756: ARRAY
16757: PPUSH
16758: CALL_OW 310
16762: IFFALSE 16779
// AddComExitBuilding ( tmp [ i ] ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: CALL_OW 182
// if i = 2 and JMMNewVeh then
16779: LD_VAR 0 2
16783: PUSH
16784: LD_INT 2
16786: EQUAL
16787: PUSH
16788: LD_EXP 56
16792: AND
16793: IFFALSE 16851
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16795: LD_VAR 0 5
16799: PUSH
16800: LD_VAR 0 2
16804: ARRAY
16805: PPUSH
16806: LD_EXP 56
16810: PPUSH
16811: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16815: LD_VAR 0 5
16819: PUSH
16820: LD_VAR 0 2
16824: ARRAY
16825: PPUSH
16826: LD_INT 86
16828: PPUSH
16829: LD_INT 133
16831: PPUSH
16832: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16836: LD_VAR 0 5
16840: PUSH
16841: LD_VAR 0 2
16845: ARRAY
16846: PPUSH
16847: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16851: LD_VAR 0 5
16855: PUSH
16856: LD_VAR 0 2
16860: ARRAY
16861: PPUSH
16862: LD_INT 8
16864: PPUSH
16865: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16869: LD_VAR 0 5
16873: PUSH
16874: LD_VAR 0 2
16878: ARRAY
16879: PPUSH
16880: LD_EXP 39
16884: PPUSH
16885: CALL_OW 179
// end ;
16889: GO 16722
16891: POP
16892: POP
// if GirlNewVeh then
16893: LD_EXP 57
16897: IFFALSE 16911
// SetSide ( GirlNewVeh , 4 ) ;
16899: LD_EXP 57
16903: PPUSH
16904: LD_INT 4
16906: PPUSH
16907: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16911: LD_INT 35
16913: PPUSH
16914: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16918: LD_VAR 0 9
16922: PPUSH
16923: LD_INT 95
16925: PUSH
16926: LD_INT 9
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: PPUSH
16933: CALL_OW 72
16937: PUSH
16938: LD_INT 0
16940: EQUAL
16941: PUSH
16942: LD_EXP 39
16946: PPUSH
16947: LD_INT 9
16949: PPUSH
16950: CALL_OW 308
16954: NOT
16955: AND
16956: IFFALSE 16911
// wait ( 0 0$2 ) ;
16958: LD_INT 70
16960: PPUSH
16961: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16965: LD_VAR 0 9
16969: PPUSH
16970: LD_INT 1
16972: PPUSH
16973: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16977: LD_INT 21
16979: PUSH
16980: LD_INT 2
16982: PUSH
16983: EMPTY
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 92
16989: PUSH
16990: LD_INT 83
16992: PUSH
16993: LD_INT 130
16995: PUSH
16996: LD_INT 10
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: PPUSH
17009: CALL_OW 69
17013: PPUSH
17014: LD_INT 1
17016: PPUSH
17017: CALL_OW 235
// Video ( false ) ;
17021: LD_INT 0
17023: PPUSH
17024: CALL 103080 0 1
// ChangeMissionObjectives ( M1 ) ;
17028: LD_STRING M1
17030: PPUSH
17031: CALL_OW 337
// SaveForQuickRestart ;
17035: CALL_OW 22
// missionStart := true ;
17039: LD_ADDR_EXP 13
17043: PUSH
17044: LD_INT 1
17046: ST_TO_ADDR
// missionStage := 2 ;
17047: LD_ADDR_EXP 15
17051: PUSH
17052: LD_INT 2
17054: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17055: LD_INT 105
17057: PPUSH
17058: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17062: LD_ADDR_VAR 0 5
17066: PUSH
17067: LD_INT 22
17069: PUSH
17070: LD_INT 4
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: PUSH
17077: LD_INT 21
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: EMPTY
17084: LIST
17085: LIST
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PPUSH
17091: CALL_OW 69
17095: PUSH
17096: LD_EXP 58
17100: DIFF
17101: ST_TO_ADDR
// if not tmp then
17102: LD_VAR 0 5
17106: NOT
17107: IFFALSE 17122
// tmp := [ Powell ] ;
17109: LD_ADDR_VAR 0 5
17113: PUSH
17114: LD_EXP 58
17118: PUSH
17119: EMPTY
17120: LIST
17121: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17122: LD_ADDR_EXP 97
17126: PUSH
17127: LD_EXP 97
17131: PPUSH
17132: LD_INT 4
17134: PPUSH
17135: LD_INT 22
17137: PUSH
17138: LD_INT 4
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 23
17147: PUSH
17148: LD_INT 1
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PUSH
17155: LD_INT 3
17157: PUSH
17158: LD_INT 21
17160: PUSH
17161: LD_INT 2
17163: PUSH
17164: EMPTY
17165: LIST
17166: LIST
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: PPUSH
17177: CALL_OW 69
17181: PUSH
17182: LD_EXP 58
17186: DIFF
17187: PPUSH
17188: CALL_OW 1
17192: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17193: LD_ADDR_VAR 0 4
17197: PUSH
17198: LD_INT 22
17200: PUSH
17201: LD_INT 4
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: PUSH
17208: LD_INT 34
17210: PUSH
17211: LD_INT 12
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: PUSH
17218: EMPTY
17219: LIST
17220: LIST
17221: PPUSH
17222: CALL_OW 69
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17231: LD_VAR 0 5
17235: PUSH
17236: LD_INT 1
17238: ARRAY
17239: PPUSH
17240: CALL_OW 310
17244: IFFALSE 17259
// ComExitBuilding ( tmp [ 1 ] ) ;
17246: LD_VAR 0 5
17250: PUSH
17251: LD_INT 1
17253: ARRAY
17254: PPUSH
17255: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17259: LD_VAR 0 5
17263: PUSH
17264: LD_INT 1
17266: ARRAY
17267: PPUSH
17268: LD_VAR 0 4
17272: PPUSH
17273: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17277: LD_VAR 0 5
17281: PUSH
17282: LD_INT 1
17284: ARRAY
17285: PPUSH
17286: LD_INT 80
17288: PPUSH
17289: LD_INT 136
17291: PPUSH
17292: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17296: LD_VAR 0 5
17300: PUSH
17301: LD_INT 1
17303: ARRAY
17304: PPUSH
17305: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17309: LD_VAR 0 5
17313: PUSH
17314: LD_INT 1
17316: ARRAY
17317: PPUSH
17318: LD_INT 59
17320: PPUSH
17321: LD_INT 112
17323: PPUSH
17324: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17328: LD_VAR 0 5
17332: PUSH
17333: LD_INT 1
17335: ARRAY
17336: PPUSH
17337: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17341: LD_EXP 40
17345: PUSH
17346: LD_EXP 40
17350: PPUSH
17351: CALL_OW 255
17355: PUSH
17356: LD_INT 1
17358: EQUAL
17359: AND
17360: IFFALSE 17386
// begin Say ( Joan , D3W-Joan-1 ) ;
17362: LD_EXP 40
17366: PPUSH
17367: LD_STRING D3W-Joan-1
17369: PPUSH
17370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17374: LD_EXP 39
17378: PPUSH
17379: LD_STRING D3W-JMM-1
17381: PPUSH
17382: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17386: LD_EXP 42
17390: PUSH
17391: LD_EXP 42
17395: PPUSH
17396: CALL_OW 255
17400: PUSH
17401: LD_INT 1
17403: EQUAL
17404: AND
17405: PUSH
17406: LD_EXP 42
17410: PUSH
17411: LD_EXP 59
17415: IN
17416: NOT
17417: AND
17418: IFFALSE 17444
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17420: LD_EXP 42
17424: PPUSH
17425: LD_STRING D3W-Lisa-1
17427: PPUSH
17428: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17432: LD_EXP 39
17436: PPUSH
17437: LD_STRING D3W-JMM-1
17439: PPUSH
17440: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17444: LD_EXP 54
17448: PUSH
17449: LD_EXP 54
17453: PPUSH
17454: CALL_OW 255
17458: PUSH
17459: LD_INT 1
17461: EQUAL
17462: AND
17463: IFFALSE 17489
// begin Say ( Connie , D3W-Con-1 ) ;
17465: LD_EXP 54
17469: PPUSH
17470: LD_STRING D3W-Con-1
17472: PPUSH
17473: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17477: LD_EXP 39
17481: PPUSH
17482: LD_STRING D3W-JMM-1
17484: PPUSH
17485: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17489: LD_EXP 42
17493: PUSH
17494: LD_EXP 59
17498: IN
17499: PUSH
17500: LD_EXP 42
17504: PPUSH
17505: CALL_OW 255
17509: PUSH
17510: LD_INT 1
17512: EQUAL
17513: AND
17514: IFFALSE 17530
// Say ( Lisa , D3nW-Lisa-1 ) else
17516: LD_EXP 42
17520: PPUSH
17521: LD_STRING D3nW-Lisa-1
17523: PPUSH
17524: CALL_OW 88
17528: GO 17774
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17530: LD_EXP 45
17534: PUSH
17535: LD_EXP 59
17539: IN
17540: PUSH
17541: LD_EXP 45
17545: PPUSH
17546: CALL_OW 255
17550: PUSH
17551: LD_INT 1
17553: EQUAL
17554: AND
17555: IFFALSE 17571
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17557: LD_EXP 45
17561: PPUSH
17562: LD_STRING D3nW-Cyrus-1
17564: PPUSH
17565: CALL_OW 88
17569: GO 17774
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17571: LD_EXP 44
17575: PUSH
17576: LD_EXP 59
17580: IN
17581: PUSH
17582: LD_EXP 44
17586: PPUSH
17587: CALL_OW 255
17591: PUSH
17592: LD_INT 1
17594: EQUAL
17595: AND
17596: IFFALSE 17612
// Say ( Bobby , D3nW-Bobby-1 ) else
17598: LD_EXP 44
17602: PPUSH
17603: LD_STRING D3nW-Bobby-1
17605: PPUSH
17606: CALL_OW 88
17610: GO 17774
// if Gary in vip and GetSide ( Gary ) = 1 then
17612: LD_EXP 51
17616: PUSH
17617: LD_EXP 59
17621: IN
17622: PUSH
17623: LD_EXP 51
17627: PPUSH
17628: CALL_OW 255
17632: PUSH
17633: LD_INT 1
17635: EQUAL
17636: AND
17637: IFFALSE 17653
// Say ( Gary , D3nW-Gary-1 ) else
17639: LD_EXP 51
17643: PPUSH
17644: LD_STRING D3nW-Gary-1
17646: PPUSH
17647: CALL_OW 88
17651: GO 17774
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17653: LD_EXP 43
17657: PUSH
17658: LD_EXP 59
17662: IN
17663: PUSH
17664: LD_EXP 43
17668: PPUSH
17669: CALL_OW 255
17673: PUSH
17674: LD_INT 1
17676: EQUAL
17677: AND
17678: IFFALSE 17694
// Say ( Donaldson , D3nW-Don-1 ) else
17680: LD_EXP 43
17684: PPUSH
17685: LD_STRING D3nW-Don-1
17687: PPUSH
17688: CALL_OW 88
17692: GO 17774
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17694: LD_EXP 50
17698: PUSH
17699: LD_EXP 59
17703: IN
17704: PUSH
17705: LD_EXP 50
17709: PPUSH
17710: CALL_OW 255
17714: PUSH
17715: LD_INT 1
17717: EQUAL
17718: AND
17719: IFFALSE 17735
// Say ( Cornel , D3nW-Corn-1 ) else
17721: LD_EXP 50
17725: PPUSH
17726: LD_STRING D3nW-Corn-1
17728: PPUSH
17729: CALL_OW 88
17733: GO 17774
// if Frank in vip and GetSide ( Frank ) = 1 then
17735: LD_EXP 52
17739: PUSH
17740: LD_EXP 59
17744: IN
17745: PUSH
17746: LD_EXP 52
17750: PPUSH
17751: CALL_OW 255
17755: PUSH
17756: LD_INT 1
17758: EQUAL
17759: AND
17760: IFFALSE 17774
// Say ( Frank , D3nW-Frank-1 ) ;
17762: LD_EXP 52
17766: PPUSH
17767: LD_STRING D3nW-Frank-1
17769: PPUSH
17770: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17774: LD_EXP 59
17778: PPUSH
17779: LD_INT 22
17781: PUSH
17782: LD_INT 1
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL_OW 72
17793: IFFALSE 17819
// begin Say ( JMM , D3nW-JMM-1 ) ;
17795: LD_EXP 39
17799: PPUSH
17800: LD_STRING D3nW-JMM-1
17802: PPUSH
17803: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17807: LD_EXP 39
17811: PPUSH
17812: LD_STRING D3nW-JMM-1a
17814: PPUSH
17815: CALL_OW 88
// end ; t := 0 0$00 ;
17819: LD_ADDR_VAR 0 3
17823: PUSH
17824: LD_INT 0
17826: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17827: LD_INT 35
17829: PPUSH
17830: CALL_OW 67
// t := t + 0 0$1 ;
17834: LD_ADDR_VAR 0 3
17838: PUSH
17839: LD_VAR 0 3
17843: PUSH
17844: LD_INT 35
17846: PLUS
17847: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17848: LD_INT 59
17850: PPUSH
17851: LD_INT 112
17853: PPUSH
17854: CALL_OW 428
17858: PUSH
17859: LD_VAR 0 3
17863: PUSH
17864: LD_INT 2100
17866: GREATER
17867: OR
17868: IFFALSE 17827
// activeAttacks := true ;
17870: LD_ADDR_EXP 16
17874: PUSH
17875: LD_INT 1
17877: ST_TO_ADDR
// end ;
17878: LD_VAR 0 1
17882: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17883: LD_INT 0
17885: PPUSH
// case question of 1 :
17886: LD_VAR 0 1
17890: PUSH
17891: LD_INT 1
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17950
17899: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17900: LD_EXP 39
17904: PPUSH
17905: LD_STRING D2Mot-JMM-1
17907: PPUSH
17908: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17912: LD_EXP 58
17916: PPUSH
17917: LD_STRING D2Mot-Pow-1
17919: PPUSH
17920: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17924: LD_EXP 39
17928: PPUSH
17929: LD_STRING D2Mot-JMM-2
17931: PPUSH
17932: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17936: LD_EXP 58
17940: PPUSH
17941: LD_STRING D2Mot-Pow-2
17943: PPUSH
17944: CALL_OW 88
// end ; 2 :
17948: GO 18301
17950: LD_INT 2
17952: DOUBLE
17953: EQUAL
17954: IFTRUE 17958
17956: GO 18034
17958: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17959: LD_EXP 39
17963: PPUSH
17964: LD_STRING D2Rus-JMM-1
17966: PPUSH
17967: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17971: LD_EXP 58
17975: PPUSH
17976: LD_STRING D2Rus-Pow-1
17978: PPUSH
17979: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17983: LD_EXP 39
17987: PPUSH
17988: LD_STRING D2Rus-JMM-2
17990: PPUSH
17991: CALL_OW 88
// if not ( 3 in list_of_q ) then
17995: LD_INT 3
17997: PUSH
17998: LD_VAR 0 2
18002: IN
18003: NOT
18004: IFFALSE 18020
// Say ( Powell , D2Rus-Pow-2 ) else
18006: LD_EXP 58
18010: PPUSH
18011: LD_STRING D2Rus-Pow-2
18013: PPUSH
18014: CALL_OW 88
18018: GO 18032
// Say ( Powell , D2Rus-Pow-2a ) ;
18020: LD_EXP 58
18024: PPUSH
18025: LD_STRING D2Rus-Pow-2a
18027: PPUSH
18028: CALL_OW 88
// end ; 3 :
18032: GO 18301
18034: LD_INT 3
18036: DOUBLE
18037: EQUAL
18038: IFTRUE 18042
18040: GO 18127
18042: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18043: LD_EXP 39
18047: PPUSH
18048: LD_STRING D2Leg-JMM-1
18050: PPUSH
18051: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18055: LD_EXP 58
18059: PPUSH
18060: LD_STRING D2Leg-Pow-1
18062: PPUSH
18063: CALL_OW 88
// if 2 in list_of_q then
18067: LD_INT 2
18069: PUSH
18070: LD_VAR 0 2
18074: IN
18075: IFFALSE 18101
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18077: LD_EXP 39
18081: PPUSH
18082: LD_STRING D2Leg-JMM-2
18084: PPUSH
18085: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18089: LD_EXP 58
18093: PPUSH
18094: LD_STRING D2Leg-Pow-2
18096: PPUSH
18097: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18101: LD_EXP 39
18105: PPUSH
18106: LD_STRING D2Leg-JMM-3
18108: PPUSH
18109: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18113: LD_EXP 58
18117: PPUSH
18118: LD_STRING D2Leg-Pow-3
18120: PPUSH
18121: CALL_OW 88
// end ; 4 :
18125: GO 18301
18127: LD_INT 4
18129: DOUBLE
18130: EQUAL
18131: IFTRUE 18135
18133: GO 18210
18135: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18136: LD_EXP 39
18140: PPUSH
18141: LD_STRING D2Ar-JMM-1
18143: PPUSH
18144: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18148: LD_EXP 58
18152: PPUSH
18153: LD_STRING D2Ar-Pow-1
18155: PPUSH
18156: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18160: LD_EXP 39
18164: PPUSH
18165: LD_STRING D2Ar-JMM-2
18167: PPUSH
18168: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18172: LD_EXP 58
18176: PPUSH
18177: LD_STRING D2Ar-Pow-2
18179: PPUSH
18180: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18184: LD_EXP 39
18188: PPUSH
18189: LD_STRING D2Ar-JMM-3
18191: PPUSH
18192: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18196: LD_EXP 58
18200: PPUSH
18201: LD_STRING D2Ar-Pow-3
18203: PPUSH
18204: CALL_OW 88
// end ; 5 :
18208: GO 18301
18210: LD_INT 5
18212: DOUBLE
18213: EQUAL
18214: IFTRUE 18218
18216: GO 18233
18218: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18219: LD_EXP 39
18223: PPUSH
18224: LD_STRING D2Conf-JMM-1
18226: PPUSH
18227: CALL_OW 88
18231: GO 18301
18233: LD_INT 6
18235: DOUBLE
18236: EQUAL
18237: IFTRUE 18241
18239: GO 18300
18241: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18242: LD_EXP 39
18246: PPUSH
18247: LD_STRING D2Com-JMM-1
18249: PPUSH
18250: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18254: LD_EXP 58
18258: PPUSH
18259: LD_STRING D2Com-Pow-1
18261: PPUSH
18262: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18266: LD_EXP 39
18270: PPUSH
18271: LD_STRING D2Com-JMM-2
18273: PPUSH
18274: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18278: LD_EXP 58
18282: PPUSH
18283: LD_STRING D2Com-Pow-2
18285: PPUSH
18286: CALL_OW 88
// powellAngerQuery := true ;
18290: LD_ADDR_EXP 36
18294: PUSH
18295: LD_INT 1
18297: ST_TO_ADDR
// end ; end ;
18298: GO 18301
18300: POP
// end ;
18301: LD_VAR 0 3
18305: RET
// every 0 0$5 trigger missionStart do var tmp ;
18306: LD_EXP 13
18310: IFFALSE 18593
18312: GO 18314
18314: DISABLE
18315: LD_INT 0
18317: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18318: LD_INT 35
18320: PPUSH
18321: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18325: LD_INT 14
18327: PPUSH
18328: LD_INT 22
18330: PUSH
18331: LD_INT 1
18333: PUSH
18334: EMPTY
18335: LIST
18336: LIST
18337: PPUSH
18338: CALL_OW 70
18342: PUSH
18343: LD_EXP 15
18347: PUSH
18348: LD_INT 2
18350: PUSH
18351: LD_INT 3
18353: PUSH
18354: LD_INT 4
18356: PUSH
18357: LD_INT 5
18359: PUSH
18360: EMPTY
18361: LIST
18362: LIST
18363: LIST
18364: LIST
18365: IN
18366: AND
18367: IFFALSE 18583
// begin powellAnger := powellAnger + 1 ;
18369: LD_ADDR_EXP 17
18373: PUSH
18374: LD_EXP 17
18378: PUSH
18379: LD_INT 1
18381: PLUS
18382: ST_TO_ADDR
// Video ( true ) ;
18383: LD_INT 1
18385: PPUSH
18386: CALL 103080 0 1
// CenterNowOnUnits ( tmp ) ;
18390: LD_VAR 0 1
18394: PPUSH
18395: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// async ;
18427: ASYNC
// case powellAnger of 1 :
18428: LD_EXP 17
18432: PUSH
18433: LD_INT 1
18435: DOUBLE
18436: EQUAL
18437: IFTRUE 18441
18439: GO 18456
18441: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18442: LD_EXP 58
18446: PPUSH
18447: LD_STRING DBack1-Pow-1
18449: PPUSH
18450: CALL_OW 88
18454: GO 18503
18456: LD_INT 2
18458: DOUBLE
18459: EQUAL
18460: IFTRUE 18464
18462: GO 18479
18464: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18465: LD_EXP 58
18469: PPUSH
18470: LD_STRING DBack2-Pow-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18503
18479: LD_INT 3
18481: DOUBLE
18482: EQUAL
18483: IFTRUE 18487
18485: GO 18502
18487: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18488: LD_EXP 58
18492: PPUSH
18493: LD_STRING DBack3-Pow-1
18495: PPUSH
18496: CALL_OW 88
18500: GO 18503
18502: POP
// sync ;
18503: SYNC
// repeat wait ( 0 0$1 ) ;
18504: LD_INT 35
18506: PPUSH
18507: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18511: LD_INT 14
18513: PPUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 1
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PPUSH
18524: CALL_OW 70
18528: PPUSH
18529: LD_INT 86
18531: PPUSH
18532: LD_INT 133
18534: PPUSH
18535: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18539: LD_INT 14
18541: PPUSH
18542: LD_INT 22
18544: PUSH
18545: LD_INT 1
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: PPUSH
18552: CALL_OW 70
18556: NOT
18557: IFFALSE 18504
// if powellAnger >= 3 then
18559: LD_EXP 17
18563: PUSH
18564: LD_INT 3
18566: GREATEREQUAL
18567: IFFALSE 18576
// YouLost ( Dismissed ) ;
18569: LD_STRING Dismissed
18571: PPUSH
18572: CALL_OW 104
// Video ( false ) ;
18576: LD_INT 0
18578: PPUSH
18579: CALL 103080 0 1
// end ; until missionStage > 5 ;
18583: LD_EXP 15
18587: PUSH
18588: LD_INT 5
18590: GREATER
18591: IFFALSE 18318
// end ;
18593: PPOPN 1
18595: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18596: LD_EXP 13
18600: PUSH
18601: LD_INT 22
18603: PUSH
18604: LD_INT 4
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PUSH
18611: LD_INT 21
18613: PUSH
18614: LD_INT 2
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PPUSH
18625: CALL_OW 69
18629: PUSH
18630: LD_INT 4
18632: GREATEREQUAL
18633: AND
18634: PUSH
18635: LD_EXP 15
18639: PUSH
18640: LD_INT 2
18642: EQUAL
18643: AND
18644: IFFALSE 20467
18646: GO 18648
18648: DISABLE
18649: LD_INT 0
18651: PPUSH
18652: PPUSH
18653: PPUSH
18654: PPUSH
18655: PPUSH
18656: PPUSH
18657: PPUSH
18658: PPUSH
// begin missionStage := 3 ;
18659: LD_ADDR_EXP 15
18663: PUSH
18664: LD_INT 3
18666: ST_TO_ADDR
// retreat := false ;
18667: LD_ADDR_VAR 0 4
18671: PUSH
18672: LD_INT 0
18674: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18675: LD_ADDR_VAR 0 5
18679: PUSH
18680: LD_INT 22
18682: PUSH
18683: LD_INT 4
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PUSH
18690: LD_INT 30
18692: PUSH
18693: LD_INT 4
18695: PUSH
18696: EMPTY
18697: LIST
18698: LIST
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PPUSH
18704: CALL_OW 69
18708: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18709: LD_ADDR_VAR 0 6
18713: PUSH
18714: LD_INT 22
18716: PUSH
18717: LD_INT 4
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: PUSH
18724: LD_INT 30
18726: PUSH
18727: LD_INT 5
18729: PUSH
18730: EMPTY
18731: LIST
18732: LIST
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 69
18742: ST_TO_ADDR
// if not bar then
18743: LD_VAR 0 6
18747: NOT
18748: IFFALSE 18801
// begin repeat wait ( 0 0$1 ) ;
18750: LD_INT 35
18752: PPUSH
18753: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18757: LD_INT 22
18759: PUSH
18760: LD_INT 4
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 3
18769: PUSH
18770: LD_INT 57
18772: PUSH
18773: EMPTY
18774: LIST
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: LD_INT 30
18782: PUSH
18783: LD_INT 5
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: IFFALSE 18750
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18801: LD_ADDR_VAR 0 6
18805: PUSH
18806: LD_INT 22
18808: PUSH
18809: LD_INT 4
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: PUSH
18816: LD_INT 30
18818: PUSH
18819: LD_INT 5
18821: PUSH
18822: EMPTY
18823: LIST
18824: LIST
18825: PUSH
18826: EMPTY
18827: LIST
18828: LIST
18829: PPUSH
18830: CALL_OW 69
18834: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18835: LD_INT 35
18837: PPUSH
18838: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18842: LD_EXP 116
18846: PUSH
18847: LD_INT 4
18849: ARRAY
18850: PUSH
18851: LD_INT 4
18853: GREATEREQUAL
18854: IFFALSE 18835
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18856: LD_ADDR_VAR 0 2
18860: PUSH
18861: LD_INT 22
18863: PUSH
18864: LD_INT 4
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: LD_INT 2
18873: PUSH
18874: LD_INT 25
18876: PUSH
18877: LD_INT 1
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: PUSH
18884: LD_INT 25
18886: PUSH
18887: LD_INT 2
18889: PUSH
18890: EMPTY
18891: LIST
18892: LIST
18893: PUSH
18894: LD_INT 25
18896: PUSH
18897: LD_INT 3
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 25
18906: PUSH
18907: LD_INT 4
18909: PUSH
18910: EMPTY
18911: LIST
18912: LIST
18913: PUSH
18914: LD_INT 25
18916: PUSH
18917: LD_INT 5
18919: PUSH
18920: EMPTY
18921: LIST
18922: LIST
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PPUSH
18936: CALL_OW 69
18940: PUSH
18941: LD_EXP 58
18945: PUSH
18946: LD_EXP 59
18950: ADD
18951: DIFF
18952: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18953: LD_ADDR_VAR 0 3
18957: PUSH
18958: LD_VAR 0 2
18962: PPUSH
18963: LD_INT 26
18965: PUSH
18966: LD_INT 1
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: PPUSH
18973: CALL_OW 72
18977: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18978: LD_ADDR_VAR 0 2
18982: PUSH
18983: LD_VAR 0 2
18987: PUSH
18988: LD_VAR 0 3
18992: DIFF
18993: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18994: LD_ADDR_VAR 0 2
18998: PUSH
18999: LD_VAR 0 2
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL 101617 0 2
19011: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_VAR 0 3
19021: PPUSH
19022: LD_INT 1
19024: PPUSH
19025: CALL 101617 0 2
19029: ST_TO_ADDR
// for i = 1 to 4 do
19030: LD_ADDR_VAR 0 1
19034: PUSH
19035: DOUBLE
19036: LD_INT 1
19038: DEC
19039: ST_TO_ADDR
19040: LD_INT 4
19042: PUSH
19043: FOR_TO
19044: IFFALSE 19210
// begin if tmp2 then
19046: LD_VAR 0 3
19050: IFFALSE 19131
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19052: LD_ADDR_EXP 18
19056: PUSH
19057: LD_EXP 18
19061: PPUSH
19062: LD_INT 1
19064: PPUSH
19065: LD_EXP 18
19069: PUSH
19070: LD_INT 1
19072: ARRAY
19073: PUSH
19074: LD_VAR 0 3
19078: PUSH
19079: LD_VAR 0 3
19083: ARRAY
19084: ADD
19085: PPUSH
19086: CALL_OW 1
19090: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19091: LD_VAR 0 3
19095: PUSH
19096: LD_VAR 0 3
19100: ARRAY
19101: PPUSH
19102: LD_INT 1
19104: PPUSH
19105: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19109: LD_ADDR_VAR 0 3
19113: PUSH
19114: LD_VAR 0 3
19118: PPUSH
19119: LD_VAR 0 3
19123: PPUSH
19124: CALL_OW 3
19128: ST_TO_ADDR
// end else
19129: GO 19208
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19131: LD_ADDR_EXP 18
19135: PUSH
19136: LD_EXP 18
19140: PPUSH
19141: LD_INT 1
19143: PPUSH
19144: LD_EXP 18
19148: PUSH
19149: LD_INT 1
19151: ARRAY
19152: PUSH
19153: LD_VAR 0 2
19157: PUSH
19158: LD_VAR 0 2
19162: ARRAY
19163: ADD
19164: PPUSH
19165: CALL_OW 1
19169: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19170: LD_VAR 0 2
19174: PUSH
19175: LD_VAR 0 2
19179: ARRAY
19180: PPUSH
19181: LD_INT 1
19183: PPUSH
19184: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19188: LD_ADDR_VAR 0 2
19192: PUSH
19193: LD_VAR 0 2
19197: PPUSH
19198: LD_VAR 0 2
19202: PPUSH
19203: CALL_OW 3
19207: ST_TO_ADDR
// end ; end ;
19208: GO 19043
19210: POP
19211: POP
// if tmp2 then
19212: LD_VAR 0 3
19216: IFFALSE 19234
// tmp := tmp union tmp2 ;
19218: LD_ADDR_VAR 0 2
19222: PUSH
19223: LD_VAR 0 2
19227: PUSH
19228: LD_VAR 0 3
19232: UNION
19233: ST_TO_ADDR
// for i = 1 to 4 do
19234: LD_ADDR_VAR 0 1
19238: PUSH
19239: DOUBLE
19240: LD_INT 1
19242: DEC
19243: ST_TO_ADDR
19244: LD_INT 4
19246: PUSH
19247: FOR_TO
19248: IFFALSE 19297
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19250: LD_ADDR_EXP 18
19254: PUSH
19255: LD_EXP 18
19259: PPUSH
19260: LD_INT 2
19262: PPUSH
19263: LD_EXP 18
19267: PUSH
19268: LD_INT 2
19270: ARRAY
19271: PUSH
19272: LD_VAR 0 2
19276: PUSH
19277: LD_VAR 0 2
19281: PUSH
19282: LD_VAR 0 1
19286: MINUS
19287: ARRAY
19288: ADD
19289: PPUSH
19290: CALL_OW 1
19294: ST_TO_ADDR
19295: GO 19247
19297: POP
19298: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19299: LD_ADDR_EXP 97
19303: PUSH
19304: LD_EXP 97
19308: PPUSH
19309: LD_INT 4
19311: PPUSH
19312: LD_EXP 97
19316: PUSH
19317: LD_INT 4
19319: ARRAY
19320: PUSH
19321: LD_EXP 18
19325: PUSH
19326: LD_INT 1
19328: ARRAY
19329: DIFF
19330: PPUSH
19331: CALL_OW 1
19335: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19336: LD_VAR 0 5
19340: PUSH
19341: LD_INT 1
19343: ARRAY
19344: PPUSH
19345: CALL_OW 313
19349: IFFALSE 19404
// begin for i in UnitsInside ( arm [ 1 ] ) do
19351: LD_ADDR_VAR 0 1
19355: PUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 313
19369: PUSH
19370: FOR_IN
19371: IFFALSE 19402
// begin ComExitBuilding ( i ) ;
19373: LD_VAR 0 1
19377: PPUSH
19378: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19382: LD_VAR 0 1
19386: PPUSH
19387: LD_VAR 0 6
19391: PUSH
19392: LD_INT 1
19394: ARRAY
19395: PPUSH
19396: CALL_OW 180
// end ;
19400: GO 19370
19402: POP
19403: POP
// end ; wait ( 0 0$3 ) ;
19404: LD_INT 105
19406: PPUSH
19407: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19411: LD_ADDR_VAR 0 1
19415: PUSH
19416: LD_EXP 18
19420: PUSH
19421: LD_INT 1
19423: ARRAY
19424: PUSH
19425: FOR_IN
19426: IFFALSE 19533
// begin if IsInUnit ( i ) then
19428: LD_VAR 0 1
19432: PPUSH
19433: CALL_OW 310
19437: IFFALSE 19448
// ComExitBuilding ( i ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: CALL_OW 122
// if GetClass ( i ) <> 1 then
19448: LD_VAR 0 1
19452: PPUSH
19453: CALL_OW 257
19457: PUSH
19458: LD_INT 1
19460: NONEQUAL
19461: IFFALSE 19502
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19463: LD_VAR 0 1
19467: PPUSH
19468: LD_VAR 0 5
19472: PUSH
19473: LD_INT 1
19475: ARRAY
19476: PPUSH
19477: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19481: LD_VAR 0 1
19485: PPUSH
19486: LD_INT 1
19488: PPUSH
19489: CALL_OW 183
// AddComExitBuilding ( i ) ;
19493: LD_VAR 0 1
19497: PPUSH
19498: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19502: LD_VAR 0 1
19506: PPUSH
19507: LD_INT 60
19509: PPUSH
19510: LD_INT 94
19512: PPUSH
19513: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19517: LD_VAR 0 1
19521: PPUSH
19522: LD_EXP 58
19526: PPUSH
19527: CALL_OW 179
// end ;
19531: GO 19425
19533: POP
19534: POP
// wait ( 0 0$15 ) ;
19535: LD_INT 525
19537: PPUSH
19538: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19542: LD_EXP 58
19546: PPUSH
19547: LD_STRING D4-Pow-1
19549: PPUSH
19550: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19554: LD_ADDR_VAR 0 2
19558: PUSH
19559: LD_EXP 18
19563: PUSH
19564: LD_INT 1
19566: ARRAY
19567: PPUSH
19568: LD_INT 26
19570: PUSH
19571: LD_INT 1
19573: PUSH
19574: EMPTY
19575: LIST
19576: LIST
19577: PPUSH
19578: CALL_OW 72
19582: ST_TO_ADDR
// if tmp then
19583: LD_VAR 0 2
19587: IFFALSE 19605
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19589: LD_VAR 0 2
19593: PUSH
19594: LD_INT 1
19596: ARRAY
19597: PPUSH
19598: LD_STRING D4-Sol1-1
19600: PPUSH
19601: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19605: LD_EXP 58
19609: PPUSH
19610: LD_STRING D4-Pow-2
19612: PPUSH
19613: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19617: LD_ADDR_VAR 0 1
19621: PUSH
19622: DOUBLE
19623: LD_INT 1
19625: DEC
19626: ST_TO_ADDR
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PUSH
19636: FOR_TO
19637: IFFALSE 19730
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19639: LD_EXP 18
19643: PUSH
19644: LD_INT 1
19646: ARRAY
19647: PUSH
19648: LD_VAR 0 1
19652: ARRAY
19653: PPUSH
19654: LD_EXP 116
19658: PUSH
19659: LD_INT 4
19661: ARRAY
19662: PUSH
19663: LD_INT 1
19665: ARRAY
19666: PPUSH
19667: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19671: LD_ADDR_EXP 116
19675: PUSH
19676: LD_EXP 116
19680: PPUSH
19681: LD_INT 4
19683: PPUSH
19684: LD_EXP 116
19688: PUSH
19689: LD_INT 4
19691: ARRAY
19692: PPUSH
19693: LD_INT 1
19695: PPUSH
19696: CALL_OW 3
19700: PPUSH
19701: CALL_OW 1
19705: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19706: LD_INT 8
19708: PPUSH
19709: LD_EXP 18
19713: PUSH
19714: LD_INT 1
19716: ARRAY
19717: PUSH
19718: LD_VAR 0 1
19722: ARRAY
19723: PPUSH
19724: CALL_OW 471
// end ;
19728: GO 19636
19730: POP
19731: POP
// repeat wait ( 0 0$1 ) ;
19732: LD_INT 35
19734: PPUSH
19735: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19739: LD_EXP 18
19743: PUSH
19744: LD_INT 1
19746: ARRAY
19747: PPUSH
19748: LD_INT 55
19750: PUSH
19751: EMPTY
19752: LIST
19753: PPUSH
19754: CALL_OW 72
19758: PUSH
19759: LD_INT 4
19761: GREATEREQUAL
19762: IFFALSE 19732
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19764: LD_EXP 18
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_INT 69
19775: PPUSH
19776: LD_INT 94
19778: PPUSH
19779: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19783: LD_EXP 18
19787: PUSH
19788: LD_INT 1
19790: ARRAY
19791: PPUSH
19792: LD_INT 82
19794: PPUSH
19795: LD_INT 83
19797: PPUSH
19798: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19802: LD_EXP 18
19806: PUSH
19807: LD_INT 1
19809: ARRAY
19810: PPUSH
19811: LD_INT 77
19813: PPUSH
19814: LD_INT 69
19816: PPUSH
19817: CALL_OW 174
// repeat wait ( 3 ) ;
19821: LD_INT 3
19823: PPUSH
19824: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19828: LD_ADDR_VAR 0 1
19832: PUSH
19833: LD_EXP 18
19837: PUSH
19838: LD_INT 1
19840: ARRAY
19841: PUSH
19842: FOR_IN
19843: IFFALSE 19979
// begin if GetLives ( i ) < 990 then
19845: LD_VAR 0 1
19849: PPUSH
19850: CALL_OW 256
19854: PUSH
19855: LD_INT 990
19857: LESS
19858: IFFALSE 19872
// SetLives ( i , 1000 ) ;
19860: LD_VAR 0 1
19864: PPUSH
19865: LD_INT 1000
19867: PPUSH
19868: CALL_OW 234
// if not IsInUnit ( i ) then
19872: LD_VAR 0 1
19876: PPUSH
19877: CALL_OW 310
19881: NOT
19882: IFFALSE 19977
// begin if not HasTask ( i ) then
19884: LD_VAR 0 1
19888: PPUSH
19889: CALL_OW 314
19893: NOT
19894: IFFALSE 19911
// ComMoveXY ( i , 64 , 93 ) ;
19896: LD_VAR 0 1
19900: PPUSH
19901: LD_INT 64
19903: PPUSH
19904: LD_INT 93
19906: PPUSH
19907: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19911: LD_VAR 0 4
19915: NOT
19916: PUSH
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 258
19926: PUSH
19927: LD_INT 1
19929: EQUAL
19930: AND
19931: IFFALSE 19977
// begin retreat := true ;
19933: LD_ADDR_VAR 0 4
19937: PUSH
19938: LD_INT 1
19940: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19941: LD_VAR 0 1
19945: PPUSH
19946: LD_INT 2
19948: PPUSH
19949: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19953: LD_VAR 0 1
19957: PPUSH
19958: LD_STRING D4a-Sol1-1
19960: PPUSH
19961: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19965: LD_EXP 58
19969: PPUSH
19970: LD_STRING D4a-Pow-1
19972: PPUSH
19973: CALL_OW 88
// end ; end ; end ;
19977: GO 19842
19979: POP
19980: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19981: LD_EXP 18
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: PPUSH
19990: LD_INT 95
19992: PUSH
19993: LD_INT 9
19995: PUSH
19996: EMPTY
19997: LIST
19998: LIST
19999: PUSH
20000: LD_INT 3
20002: PUSH
20003: LD_INT 55
20005: PUSH
20006: EMPTY
20007: LIST
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: PPUSH
20017: CALL_OW 72
20021: PUSH
20022: LD_INT 4
20024: GREATEREQUAL
20025: IFFALSE 19821
// for i in powellSquadAttack [ 1 ] do
20027: LD_ADDR_VAR 0 1
20031: PUSH
20032: LD_EXP 18
20036: PUSH
20037: LD_INT 1
20039: ARRAY
20040: PUSH
20041: FOR_IN
20042: IFFALSE 20178
// begin if GetTag ( i ) = 2 then
20044: LD_VAR 0 1
20048: PPUSH
20049: CALL_OW 110
20053: PUSH
20054: LD_INT 2
20056: EQUAL
20057: IFFALSE 20119
// begin ComMoveXY ( i , 60 , 94 ) ;
20059: LD_VAR 0 1
20063: PPUSH
20064: LD_INT 60
20066: PPUSH
20067: LD_INT 94
20069: PPUSH
20070: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20074: LD_VAR 0 1
20078: PPUSH
20079: LD_EXP 58
20083: PPUSH
20084: CALL_OW 179
// wait ( 0 0$3 ) ;
20088: LD_INT 105
20090: PPUSH
20091: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20095: LD_VAR 0 1
20099: PPUSH
20100: LD_STRING D4a-Sol1-2
20102: PPUSH
20103: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20107: LD_EXP 58
20111: PPUSH
20112: LD_STRING D4a-Pow-2
20114: PPUSH
20115: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20119: LD_VAR 0 1
20123: PPUSH
20124: LD_INT 0
20126: PPUSH
20127: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20131: LD_ADDR_EXP 97
20135: PUSH
20136: LD_EXP 97
20140: PPUSH
20141: LD_INT 4
20143: PPUSH
20144: LD_EXP 97
20148: PUSH
20149: LD_INT 4
20151: ARRAY
20152: PUSH
20153: LD_VAR 0 1
20157: UNION
20158: PPUSH
20159: CALL_OW 1
20163: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20164: LD_INT 8
20166: PPUSH
20167: LD_VAR 0 1
20171: PPUSH
20172: CALL_OW 472
// end ;
20176: GO 20041
20178: POP
20179: POP
// wait ( 4 4$00 ) ;
20180: LD_INT 8400
20182: PPUSH
20183: CALL_OW 67
// uc_side := 6 ;
20187: LD_ADDR_OWVAR 20
20191: PUSH
20192: LD_INT 6
20194: ST_TO_ADDR
// uc_nation := 3 ;
20195: LD_ADDR_OWVAR 21
20199: PUSH
20200: LD_INT 3
20202: ST_TO_ADDR
// ru := [ ] ;
20203: LD_ADDR_VAR 0 7
20207: PUSH
20208: EMPTY
20209: ST_TO_ADDR
// for i = 1 to 4 do
20210: LD_ADDR_VAR 0 1
20214: PUSH
20215: DOUBLE
20216: LD_INT 1
20218: DEC
20219: ST_TO_ADDR
20220: LD_INT 4
20222: PUSH
20223: FOR_TO
20224: IFFALSE 20325
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20226: LD_INT 22
20228: PPUSH
20229: LD_INT 1
20231: PPUSH
20232: LD_INT 3
20234: PPUSH
20235: LD_INT 43
20237: PUSH
20238: LD_INT 44
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: LD_INT 1
20247: PPUSH
20248: LD_INT 2
20250: PPUSH
20251: CALL_OW 12
20255: ARRAY
20256: PPUSH
20257: LD_INT 89
20259: PPUSH
20260: CALL 70747 0 5
// un := CreateVehicle ;
20264: LD_ADDR_VAR 0 8
20268: PUSH
20269: CALL_OW 45
20273: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20274: LD_VAR 0 8
20278: PPUSH
20279: LD_INT 4
20281: PPUSH
20282: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20286: LD_VAR 0 8
20290: PPUSH
20291: LD_INT 136
20293: PPUSH
20294: LD_INT 90
20296: PPUSH
20297: LD_INT 8
20299: PPUSH
20300: LD_INT 0
20302: PPUSH
20303: CALL_OW 50
// ru := ru ^ un ;
20307: LD_ADDR_VAR 0 7
20311: PUSH
20312: LD_VAR 0 7
20316: PUSH
20317: LD_VAR 0 8
20321: ADD
20322: ST_TO_ADDR
// end ;
20323: GO 20223
20325: POP
20326: POP
// if ru then
20327: LD_VAR 0 7
20331: IFFALSE 20348
// ComAgressiveMove ( ru , 80 , 92 ) ;
20333: LD_VAR 0 7
20337: PPUSH
20338: LD_INT 80
20340: PPUSH
20341: LD_INT 92
20343: PPUSH
20344: CALL_OW 114
// wait ( 8 8$00 ) ;
20348: LD_INT 16800
20350: PPUSH
20351: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20355: LD_INT 4
20357: PPUSH
20358: LD_INT 3
20360: PUSH
20361: LD_INT 1
20363: PUSH
20364: LD_INT 1
20366: PUSH
20367: LD_INT 5
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: LIST
20374: LIST
20375: PUSH
20376: LD_INT 4
20378: PUSH
20379: LD_INT 1
20381: PUSH
20382: LD_INT 1
20384: PUSH
20385: LD_INT 6
20387: PUSH
20388: EMPTY
20389: LIST
20390: LIST
20391: LIST
20392: LIST
20393: PUSH
20394: LD_INT 4
20396: PUSH
20397: LD_INT 1
20399: PUSH
20400: LD_INT 1
20402: PUSH
20403: LD_INT 7
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 3
20414: PUSH
20415: LD_INT 1
20417: PUSH
20418: LD_INT 1
20420: PUSH
20421: LD_INT 7
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: PUSH
20430: LD_INT 3
20432: PUSH
20433: LD_INT 1
20435: PUSH
20436: LD_INT 1
20438: PUSH
20439: LD_INT 5
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: LIST
20454: PPUSH
20455: CALL 59296 0 2
// missionStage := 4 ;
20459: LD_ADDR_EXP 15
20463: PUSH
20464: LD_INT 4
20466: ST_TO_ADDR
// end ;
20467: PPOPN 8
20469: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20470: LD_EXP 15
20474: PUSH
20475: LD_INT 4
20477: EQUAL
20478: PUSH
20479: LD_INT 22
20481: PUSH
20482: LD_INT 4
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: PUSH
20489: LD_INT 21
20491: PUSH
20492: LD_INT 2
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PPUSH
20503: CALL_OW 69
20507: PUSH
20508: LD_INT 5
20510: GREATEREQUAL
20511: AND
20512: IFFALSE 24640
20514: GO 20516
20516: DISABLE
20517: LD_INT 0
20519: PPUSH
20520: PPUSH
20521: PPUSH
20522: PPUSH
20523: PPUSH
20524: PPUSH
20525: PPUSH
20526: PPUSH
20527: PPUSH
20528: PPUSH
20529: PPUSH
20530: PPUSH
20531: PPUSH
// begin wait ( 0 0$30 ) ;
20532: LD_INT 1050
20534: PPUSH
20535: CALL_OW 67
// missionStage := 5 ;
20539: LD_ADDR_EXP 15
20543: PUSH
20544: LD_INT 5
20546: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20547: LD_ADDR_VAR 0 10
20551: PUSH
20552: LD_INT 22
20554: PUSH
20555: LD_INT 4
20557: PUSH
20558: EMPTY
20559: LIST
20560: LIST
20561: PUSH
20562: LD_INT 2
20564: PUSH
20565: LD_INT 30
20567: PUSH
20568: LD_INT 4
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: PUSH
20575: LD_INT 30
20577: PUSH
20578: LD_INT 5
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: LIST
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: PPUSH
20594: CALL_OW 69
20598: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20599: LD_ADDR_VAR 0 6
20603: PUSH
20604: LD_INT 22
20606: PUSH
20607: LD_INT 4
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: PUSH
20614: LD_INT 21
20616: PUSH
20617: LD_INT 1
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: PUSH
20624: LD_INT 3
20626: PUSH
20627: LD_INT 25
20629: PUSH
20630: LD_INT 16
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: PUSH
20641: LD_INT 3
20643: PUSH
20644: LD_INT 25
20646: PUSH
20647: LD_INT 12
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: PUSH
20654: EMPTY
20655: LIST
20656: LIST
20657: PUSH
20658: EMPTY
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: PPUSH
20664: CALL_OW 69
20668: PUSH
20669: LD_EXP 58
20673: DIFF
20674: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20675: LD_ADDR_VAR 0 9
20679: PUSH
20680: LD_INT 22
20682: PUSH
20683: LD_INT 4
20685: PUSH
20686: EMPTY
20687: LIST
20688: LIST
20689: PUSH
20690: LD_INT 30
20692: PUSH
20693: LD_INT 3
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: PPUSH
20704: CALL_OW 69
20708: PUSH
20709: LD_INT 1
20711: ARRAY
20712: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20713: LD_INT 35
20715: PPUSH
20716: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20720: LD_EXP 116
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: PUSH
20729: LD_INT 5
20731: GREATEREQUAL
20732: PUSH
20733: LD_EXP 116
20737: PUSH
20738: LD_INT 4
20740: ARRAY
20741: PPUSH
20742: LD_INT 58
20744: PUSH
20745: EMPTY
20746: LIST
20747: PPUSH
20748: CALL_OW 72
20752: PUSH
20753: LD_INT 5
20755: GREATEREQUAL
20756: AND
20757: IFFALSE 20713
// powellAllowRetreat := false ;
20759: LD_ADDR_EXP 19
20763: PUSH
20764: LD_INT 0
20766: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20767: LD_INT 700
20769: PPUSH
20770: CALL_OW 67
// activeAttacks := false ;
20774: LD_ADDR_EXP 16
20778: PUSH
20779: LD_INT 0
20781: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20782: LD_INT 35
20784: PPUSH
20785: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20789: LD_INT 22
20791: PUSH
20792: LD_INT 6
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: PPUSH
20799: CALL_OW 69
20803: PUSH
20804: LD_INT 0
20806: EQUAL
20807: IFFALSE 20782
// tmp := mc_vehicles [ 4 ] ;
20809: LD_ADDR_VAR 0 3
20813: PUSH
20814: LD_EXP 116
20818: PUSH
20819: LD_INT 4
20821: ARRAY
20822: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20823: LD_ADDR_VAR 0 1
20827: PUSH
20828: DOUBLE
20829: LD_INT 1
20831: DEC
20832: ST_TO_ADDR
20833: LD_EXP 18
20837: PUSH
20838: FOR_TO
20839: IFFALSE 21100
// begin for j in powellSquadAttack [ i ] do
20841: LD_ADDR_VAR 0 2
20845: PUSH
20846: LD_EXP 18
20850: PUSH
20851: LD_VAR 0 1
20855: ARRAY
20856: PUSH
20857: FOR_IN
20858: IFFALSE 21096
// begin forces := forces diff j ;
20860: LD_ADDR_VAR 0 6
20864: PUSH
20865: LD_VAR 0 6
20869: PUSH
20870: LD_VAR 0 2
20874: DIFF
20875: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20876: LD_VAR 0 2
20880: PPUSH
20881: LD_INT 1
20883: PPUSH
20884: CALL_OW 109
// wait ( 0 0$2 ) ;
20888: LD_INT 70
20890: PPUSH
20891: CALL_OW 67
// if IsInUnit ( j ) then
20895: LD_VAR 0 2
20899: PPUSH
20900: CALL_OW 310
20904: IFFALSE 20915
// ComExitBuilding ( j ) ;
20906: LD_VAR 0 2
20910: PPUSH
20911: CALL_OW 122
// if GetClass ( j ) <> 1 then
20915: LD_VAR 0 2
20919: PPUSH
20920: CALL_OW 257
20924: PUSH
20925: LD_INT 1
20927: NONEQUAL
20928: IFFALSE 21008
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20930: LD_VAR 0 10
20934: PUSH
20935: LD_INT 1
20937: ARRAY
20938: PPUSH
20939: CALL_OW 313
20943: PUSH
20944: LD_INT 5
20946: GREATEREQUAL
20947: IFFALSE 20969
// AddComEnterUnit ( j , arm [ 2 ] ) else
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 10
20958: PUSH
20959: LD_INT 2
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
20967: GO 20987
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20969: LD_VAR 0 2
20973: PPUSH
20974: LD_VAR 0 10
20978: PUSH
20979: LD_INT 1
20981: ARRAY
20982: PPUSH
20983: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20987: LD_VAR 0 2
20991: PPUSH
20992: LD_INT 1
20994: PPUSH
20995: CALL_OW 183
// AddComExitBuilding ( j ) ;
20999: LD_VAR 0 2
21003: PPUSH
21004: CALL_OW 182
// end ; if i = 2 then
21008: LD_VAR 0 1
21012: PUSH
21013: LD_INT 2
21015: EQUAL
21016: IFFALSE 21033
// AddComMoveXY ( j , 61 , 93 ) ;
21018: LD_VAR 0 2
21022: PPUSH
21023: LD_INT 61
21025: PPUSH
21026: LD_INT 93
21028: PPUSH
21029: CALL_OW 171
// if i = 1 then
21033: LD_VAR 0 1
21037: PUSH
21038: LD_INT 1
21040: EQUAL
21041: IFFALSE 21094
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21043: LD_VAR 0 2
21047: PPUSH
21048: LD_VAR 0 3
21052: PUSH
21053: LD_INT 1
21055: ARRAY
21056: PPUSH
21057: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21061: LD_ADDR_VAR 0 3
21065: PUSH
21066: LD_VAR 0 3
21070: PPUSH
21071: LD_INT 1
21073: PPUSH
21074: CALL_OW 3
21078: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21079: LD_VAR 0 2
21083: PPUSH
21084: LD_INT 69
21086: PPUSH
21087: LD_INT 94
21089: PPUSH
21090: CALL_OW 171
// end ; end ;
21094: GO 20857
21096: POP
21097: POP
// end ;
21098: GO 20838
21100: POP
21101: POP
// wait ( 0 0$55 ) ;
21102: LD_INT 1925
21104: PPUSH
21105: CALL_OW 67
// MC_Kill ( 4 ) ;
21109: LD_INT 4
21111: PPUSH
21112: CALL 35370 0 1
// tmp := UnitsInside ( fac ) ;
21116: LD_ADDR_VAR 0 3
21120: PUSH
21121: LD_VAR 0 9
21125: PPUSH
21126: CALL_OW 313
21130: ST_TO_ADDR
// if tmp then
21131: LD_VAR 0 3
21135: IFFALSE 21256
// for i in tmp do
21137: LD_ADDR_VAR 0 1
21141: PUSH
21142: LD_VAR 0 3
21146: PUSH
21147: FOR_IN
21148: IFFALSE 21254
// begin ComExitBuilding ( i ) ;
21150: LD_VAR 0 1
21154: PPUSH
21155: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21159: LD_VAR 0 10
21163: PUSH
21164: LD_INT 2
21166: ARRAY
21167: PPUSH
21168: CALL_OW 313
21172: PUSH
21173: LD_INT 6
21175: LESS
21176: IFFALSE 21198
// AddComEnterUnit ( i , arm [ 2 ] ) else
21178: LD_VAR 0 1
21182: PPUSH
21183: LD_VAR 0 10
21187: PUSH
21188: LD_INT 2
21190: ARRAY
21191: PPUSH
21192: CALL_OW 180
21196: GO 21252
// if UnitsInside ( arm [ 1 ] ) < 6 then
21198: LD_VAR 0 10
21202: PUSH
21203: LD_INT 1
21205: ARRAY
21206: PPUSH
21207: CALL_OW 313
21211: PUSH
21212: LD_INT 6
21214: LESS
21215: IFFALSE 21237
// AddComEnterUnit ( i , arm [ 1 ] ) else
21217: LD_VAR 0 1
21221: PPUSH
21222: LD_VAR 0 10
21226: PUSH
21227: LD_INT 1
21229: ARRAY
21230: PPUSH
21231: CALL_OW 180
21235: GO 21252
// AddComMoveXY ( i , 37 , 68 ) ;
21237: LD_VAR 0 1
21241: PPUSH
21242: LD_INT 37
21244: PPUSH
21245: LD_INT 68
21247: PPUSH
21248: CALL_OW 171
// end ;
21252: GO 21147
21254: POP
21255: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21256: LD_ADDR_VAR 0 11
21260: PUSH
21261: LD_VAR 0 6
21265: PPUSH
21266: LD_INT 26
21268: PUSH
21269: LD_INT 1
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: PPUSH
21276: CALL_OW 72
21280: PUSH
21281: LD_EXP 59
21285: DIFF
21286: ST_TO_ADDR
// if not speaker then
21287: LD_VAR 0 11
21291: NOT
21292: IFFALSE 21319
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21294: LD_ADDR_VAR 0 11
21298: PUSH
21299: LD_VAR 0 6
21303: PPUSH
21304: LD_INT 26
21306: PUSH
21307: LD_INT 1
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: PPUSH
21314: CALL_OW 72
21318: ST_TO_ADDR
// if speaker then
21319: LD_VAR 0 11
21323: IFFALSE 21339
// speaker := speaker [ 1 ] ;
21325: LD_ADDR_VAR 0 11
21329: PUSH
21330: LD_VAR 0 11
21334: PUSH
21335: LD_INT 1
21337: ARRAY
21338: ST_TO_ADDR
// Video ( true ) ;
21339: LD_INT 1
21341: PPUSH
21342: CALL 103080 0 1
// CenterNowOnUnits ( Powell ) ;
21346: LD_EXP 58
21350: PPUSH
21351: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21355: LD_ADDR_VAR 0 3
21359: PUSH
21360: LD_VAR 0 6
21364: PPUSH
21365: LD_INT 3
21367: PUSH
21368: LD_INT 25
21370: PUSH
21371: LD_INT 1
21373: PUSH
21374: EMPTY
21375: LIST
21376: LIST
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PPUSH
21382: CALL_OW 72
21386: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21387: LD_ADDR_VAR 0 12
21391: PUSH
21392: LD_INT 22
21394: PUSH
21395: LD_INT 4
21397: PUSH
21398: EMPTY
21399: LIST
21400: LIST
21401: PUSH
21402: LD_INT 30
21404: PUSH
21405: LD_INT 32
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: PUSH
21412: LD_INT 58
21414: PUSH
21415: EMPTY
21416: LIST
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: LIST
21422: PPUSH
21423: CALL_OW 69
21427: ST_TO_ADDR
// for i = 1 to 6 do
21428: LD_ADDR_VAR 0 1
21432: PUSH
21433: DOUBLE
21434: LD_INT 1
21436: DEC
21437: ST_TO_ADDR
21438: LD_INT 6
21440: PUSH
21441: FOR_TO
21442: IFFALSE 21583
// begin if IsInUnit ( tmp [ i ] ) then
21444: LD_VAR 0 3
21448: PUSH
21449: LD_VAR 0 1
21453: ARRAY
21454: PPUSH
21455: CALL_OW 310
21459: IFFALSE 21476
// ComExitBuilding ( tmp [ i ] ) ;
21461: LD_VAR 0 3
21465: PUSH
21466: LD_VAR 0 1
21470: ARRAY
21471: PPUSH
21472: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21476: LD_VAR 0 3
21480: PUSH
21481: LD_VAR 0 1
21485: ARRAY
21486: PPUSH
21487: LD_VAR 0 10
21491: PUSH
21492: LD_INT 1
21494: ARRAY
21495: PPUSH
21496: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21500: LD_VAR 0 3
21504: PUSH
21505: LD_VAR 0 1
21509: ARRAY
21510: PPUSH
21511: LD_INT 1
21513: PPUSH
21514: CALL_OW 183
// if emp_towers then
21518: LD_VAR 0 12
21522: IFFALSE 21581
// begin AddComExitBuilding ( tmp [ i ] ) ;
21524: LD_VAR 0 3
21528: PUSH
21529: LD_VAR 0 1
21533: ARRAY
21534: PPUSH
21535: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21539: LD_VAR 0 3
21543: PUSH
21544: LD_VAR 0 1
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 12
21554: PUSH
21555: LD_INT 1
21557: ARRAY
21558: PPUSH
21559: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21563: LD_ADDR_VAR 0 12
21567: PUSH
21568: LD_VAR 0 12
21572: PPUSH
21573: LD_INT 1
21575: PPUSH
21576: CALL_OW 3
21580: ST_TO_ADDR
// end ; end ;
21581: GO 21441
21583: POP
21584: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21585: LD_ADDR_VAR 0 3
21589: PUSH
21590: LD_EXP 18
21594: PUSH
21595: LD_INT 1
21597: ARRAY
21598: PUSH
21599: LD_EXP 18
21603: PUSH
21604: LD_INT 2
21606: ARRAY
21607: ADD
21608: PPUSH
21609: LD_INT 26
21611: PUSH
21612: LD_INT 1
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PPUSH
21619: CALL_OW 72
21623: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21624: LD_ADDR_VAR 0 1
21628: PUSH
21629: LD_EXP 18
21633: PUSH
21634: LD_INT 2
21636: ARRAY
21637: PUSH
21638: FOR_IN
21639: IFFALSE 21657
// ComTurnUnit ( i , Powell ) ;
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_EXP 58
21650: PPUSH
21651: CALL_OW 119
21655: GO 21638
21657: POP
21658: POP
// Say ( Powell , D5-Pow-1 ) ;
21659: LD_EXP 58
21663: PPUSH
21664: LD_STRING D5-Pow-1
21666: PPUSH
21667: CALL_OW 88
// if tmp then
21671: LD_VAR 0 3
21675: IFFALSE 21693
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21677: LD_VAR 0 3
21681: PUSH
21682: LD_INT 1
21684: ARRAY
21685: PPUSH
21686: LD_STRING D5-Sol2-1
21688: PPUSH
21689: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21693: LD_EXP 58
21697: PPUSH
21698: LD_STRING D5-Pow-2
21700: PPUSH
21701: CALL_OW 88
// if tmp > 1 then
21705: LD_VAR 0 3
21709: PUSH
21710: LD_INT 1
21712: GREATER
21713: IFFALSE 21731
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21715: LD_VAR 0 3
21719: PUSH
21720: LD_INT 2
21722: ARRAY
21723: PPUSH
21724: LD_STRING D5-Sol2-2
21726: PPUSH
21727: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21731: LD_EXP 58
21735: PPUSH
21736: LD_STRING D5-Pow-3
21738: PPUSH
21739: CALL_OW 88
// wait ( 0 0$1 ) ;
21743: LD_INT 35
21745: PPUSH
21746: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21750: LD_ADDR_VAR 0 3
21754: PUSH
21755: LD_EXP 18
21759: PUSH
21760: LD_INT 1
21762: ARRAY
21763: PUSH
21764: LD_EXP 18
21768: PUSH
21769: LD_INT 2
21771: ARRAY
21772: UNION
21773: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21774: LD_VAR 0 3
21778: PPUSH
21779: LD_INT 80
21781: PPUSH
21782: LD_INT 67
21784: PPUSH
21785: CALL_OW 114
// wait ( 0 0$2 ) ;
21789: LD_INT 70
21791: PPUSH
21792: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21796: LD_INT 79
21798: PPUSH
21799: LD_INT 72
21801: PPUSH
21802: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21806: LD_INT 35
21808: PPUSH
21809: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21813: LD_VAR 0 3
21817: PPUSH
21818: LD_INT 3
21820: PUSH
21821: LD_INT 24
21823: PUSH
21824: LD_INT 1000
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: PPUSH
21835: CALL_OW 72
21839: IFFALSE 21806
// Say ( Powell , D5a-Pow-1 ) ;
21841: LD_EXP 58
21845: PPUSH
21846: LD_STRING D5a-Pow-1
21848: PPUSH
21849: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21853: LD_EXP 58
21857: PPUSH
21858: LD_STRING D5a-Pow-1a
21860: PPUSH
21861: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21865: LD_INT 10
21867: PPUSH
21868: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21872: LD_EXP 58
21876: PPUSH
21877: LD_STRING D5a-Pow-1b
21879: PPUSH
21880: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21884: LD_EXP 58
21888: PPUSH
21889: LD_STRING D5a-Pow-1c
21891: PPUSH
21892: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21896: LD_EXP 58
21900: PPUSH
21901: LD_STRING D5a-Pow-1d
21903: PPUSH
21904: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21908: LD_INT 35
21910: PPUSH
21911: CALL_OW 67
// if not HasTask ( tmp ) then
21915: LD_VAR 0 3
21919: PPUSH
21920: CALL_OW 314
21924: NOT
21925: IFFALSE 21942
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21927: LD_VAR 0 3
21931: PPUSH
21932: LD_INT 80
21934: PPUSH
21935: LD_INT 67
21937: PPUSH
21938: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21942: LD_VAR 0 3
21946: PPUSH
21947: LD_INT 24
21949: PUSH
21950: LD_INT 1
21952: PUSH
21953: EMPTY
21954: LIST
21955: LIST
21956: PPUSH
21957: CALL_OW 72
21961: NOT
21962: IFFALSE 21908
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21964: LD_ADDR_VAR 0 3
21968: PUSH
21969: LD_INT 22
21971: PUSH
21972: LD_INT 4
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: PUSH
21979: LD_INT 92
21981: PUSH
21982: LD_INT 60
21984: PUSH
21985: LD_INT 93
21987: PUSH
21988: LD_INT 10
21990: PUSH
21991: EMPTY
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: PUSH
21997: LD_INT 3
21999: PUSH
22000: LD_INT 54
22002: PUSH
22003: EMPTY
22004: LIST
22005: PUSH
22006: EMPTY
22007: LIST
22008: LIST
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: PPUSH
22015: CALL_OW 69
22019: PUSH
22020: LD_EXP 58
22024: DIFF
22025: ST_TO_ADDR
// if tmp then
22026: LD_VAR 0 3
22030: IFFALSE 22064
// for i in tmp do
22032: LD_ADDR_VAR 0 1
22036: PUSH
22037: LD_VAR 0 3
22041: PUSH
22042: FOR_IN
22043: IFFALSE 22062
// ComMoveXY ( i , 36 , 67 ) ;
22045: LD_VAR 0 1
22049: PPUSH
22050: LD_INT 36
22052: PPUSH
22053: LD_INT 67
22055: PPUSH
22056: CALL_OW 111
22060: GO 22042
22062: POP
22063: POP
// wait ( 0 0$3 ) ;
22064: LD_INT 105
22066: PPUSH
22067: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22071: LD_VAR 0 11
22075: PPUSH
22076: LD_STRING D6-Sol3-1
22078: PPUSH
22079: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22083: LD_EXP 58
22087: PPUSH
22088: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22092: LD_EXP 58
22096: PPUSH
22097: LD_STRING D6-Pow-1
22099: PPUSH
22100: CALL_OW 88
// tmp := [ ] ;
22104: LD_ADDR_VAR 0 3
22108: PUSH
22109: EMPTY
22110: ST_TO_ADDR
// for i = 1 to 2 do
22111: LD_ADDR_VAR 0 1
22115: PUSH
22116: DOUBLE
22117: LD_INT 1
22119: DEC
22120: ST_TO_ADDR
22121: LD_INT 2
22123: PUSH
22124: FOR_TO
22125: IFFALSE 22239
// begin uc_side := 8 ;
22127: LD_ADDR_OWVAR 20
22131: PUSH
22132: LD_INT 8
22134: ST_TO_ADDR
// uc_nation := 2 ;
22135: LD_ADDR_OWVAR 21
22139: PUSH
22140: LD_INT 2
22142: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22143: LD_INT 14
22145: PPUSH
22146: LD_INT 3
22148: PPUSH
22149: LD_INT 2
22151: PPUSH
22152: LD_INT 29
22154: PPUSH
22155: LD_INT 100
22157: PPUSH
22158: CALL 70747 0 5
// veh := CreateVehicle ;
22162: LD_ADDR_VAR 0 13
22166: PUSH
22167: CALL_OW 45
22171: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22172: LD_VAR 0 13
22176: PPUSH
22177: LD_INT 4
22179: PPUSH
22180: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22184: LD_VAR 0 13
22188: PPUSH
22189: LD_INT 99
22191: PPUSH
22192: LD_INT 83
22194: PPUSH
22195: LD_INT 6
22197: PPUSH
22198: LD_INT 0
22200: PPUSH
22201: CALL_OW 50
// wait ( 3 ) ;
22205: LD_INT 3
22207: PPUSH
22208: CALL_OW 67
// Connect ( veh ) ;
22212: LD_VAR 0 13
22216: PPUSH
22217: CALL 73838 0 1
// tmp := tmp ^ veh ;
22221: LD_ADDR_VAR 0 3
22225: PUSH
22226: LD_VAR 0 3
22230: PUSH
22231: LD_VAR 0 13
22235: ADD
22236: ST_TO_ADDR
// end ;
22237: GO 22124
22239: POP
22240: POP
// wait ( 0 0$1 ) ;
22241: LD_INT 35
22243: PPUSH
22244: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: LD_INT 10
22259: PPUSH
22260: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22264: LD_INT 99
22266: PPUSH
22267: LD_INT 83
22269: PPUSH
22270: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22274: LD_VAR 0 11
22278: PPUSH
22279: LD_STRING D6-Sol3-2
22281: PPUSH
22282: CALL_OW 88
// async ;
22286: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22287: LD_EXP 58
22291: PPUSH
22292: LD_STRING D6-Pow-2
22294: PPUSH
22295: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22299: LD_VAR 0 3
22303: PUSH
22304: LD_INT 1
22306: ARRAY
22307: PPUSH
22308: LD_VAR 0 9
22312: PPUSH
22313: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22317: LD_VAR 0 3
22321: PUSH
22322: LD_INT 2
22324: ARRAY
22325: PPUSH
22326: LD_INT 22
22328: PUSH
22329: LD_INT 4
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: PUSH
22336: LD_INT 21
22338: PUSH
22339: LD_INT 3
22341: PUSH
22342: EMPTY
22343: LIST
22344: LIST
22345: PUSH
22346: EMPTY
22347: LIST
22348: LIST
22349: PPUSH
22350: CALL_OW 69
22354: PPUSH
22355: LD_VAR 0 3
22359: PUSH
22360: LD_INT 2
22362: ARRAY
22363: PPUSH
22364: CALL_OW 74
22368: PPUSH
22369: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22373: LD_EXP 58
22377: PPUSH
22378: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22382: LD_INT 99
22384: PPUSH
22385: LD_INT 83
22387: PPUSH
22388: LD_INT 1
22390: PPUSH
22391: CALL_OW 331
// repeat wait ( 4 ) ;
22395: LD_INT 4
22397: PPUSH
22398: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22402: LD_VAR 0 3
22406: PUSH
22407: LD_INT 1
22409: ARRAY
22410: PPUSH
22411: CALL_OW 256
22415: PUSH
22416: LD_INT 1000
22418: LESS
22419: IFFALSE 22437
// SetLives ( tmp [ 1 ] , 1000 ) ;
22421: LD_VAR 0 3
22425: PUSH
22426: LD_INT 1
22428: ARRAY
22429: PPUSH
22430: LD_INT 1000
22432: PPUSH
22433: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22437: LD_INT 22
22439: PUSH
22440: LD_INT 4
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PUSH
22447: LD_INT 30
22449: PUSH
22450: LD_INT 3
22452: PUSH
22453: EMPTY
22454: LIST
22455: LIST
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PPUSH
22461: CALL_OW 69
22465: PUSH
22466: LD_INT 0
22468: EQUAL
22469: IFFALSE 22395
// skirmish := false ;
22471: LD_ADDR_EXP 95
22475: PUSH
22476: LD_INT 0
22478: ST_TO_ADDR
// sync ;
22479: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22480: LD_EXP 58
22484: PPUSH
22485: LD_STRING D6a-Pow-1
22487: PPUSH
22488: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22492: LD_VAR 0 11
22496: PPUSH
22497: LD_STRING D6a-Sol3-1
22499: PPUSH
22500: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22504: LD_EXP 58
22508: PPUSH
22509: LD_STRING D6a-Pow-2
22511: PPUSH
22512: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22516: LD_VAR 0 11
22520: PPUSH
22521: LD_STRING D6a-Sol3-2
22523: PPUSH
22524: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22528: LD_EXP 58
22532: PPUSH
22533: LD_STRING D6a-Pow-3
22535: PPUSH
22536: CALL_OW 88
// powellCenterCameraMode := true ;
22540: LD_ADDR_EXP 20
22544: PUSH
22545: LD_INT 1
22547: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22548: LD_ADDR_VAR 0 1
22552: PUSH
22553: LD_INT 22
22555: PUSH
22556: LD_INT 8
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 25
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: PUSH
22573: EMPTY
22574: LIST
22575: LIST
22576: PPUSH
22577: CALL_OW 69
22581: PUSH
22582: FOR_IN
22583: IFFALSE 22638
// begin SetTag ( i , 1 ) ;
22585: LD_VAR 0 1
22589: PPUSH
22590: LD_INT 1
22592: PPUSH
22593: CALL_OW 109
// ComExitBuilding ( i ) ;
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22606: LD_VAR 0 1
22610: PPUSH
22611: LD_INT 35
22613: PPUSH
22614: LD_INT 6
22616: PPUSH
22617: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22621: LD_VAR 0 1
22625: PPUSH
22626: LD_INT 53
22628: PPUSH
22629: LD_INT 4
22631: PPUSH
22632: CALL_OW 171
// end ;
22636: GO 22582
22638: POP
22639: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22640: LD_ADDR_VAR 0 3
22644: PUSH
22645: LD_INT 22
22647: PUSH
22648: LD_INT 4
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: PUSH
22655: LD_INT 21
22657: PUSH
22658: LD_INT 2
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 3
22667: PUSH
22668: LD_INT 34
22670: PUSH
22671: LD_INT 12
22673: PUSH
22674: EMPTY
22675: LIST
22676: LIST
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: LIST
22686: PPUSH
22687: CALL_OW 69
22691: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_VAR 0 3
22701: PPUSH
22702: LD_EXP 58
22706: PPUSH
22707: CALL_OW 74
22711: PPUSH
22712: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: LD_INT 100
22723: PPUSH
22724: LD_INT 88
22726: PPUSH
22727: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: LD_INT 100
22738: PPUSH
22739: LD_INT 75
22741: PPUSH
22742: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22746: LD_EXP 58
22750: PPUSH
22751: LD_INT 88
22753: PPUSH
22754: LD_INT 53
22756: PPUSH
22757: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22761: LD_INT 8
22763: PPUSH
22764: LD_EXP 58
22768: PPUSH
22769: CALL_OW 471
// repeat wait ( 3 ) ;
22773: LD_INT 3
22775: PPUSH
22776: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22780: LD_INT 22
22782: PUSH
22783: LD_INT 4
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: LD_INT 92
22792: PUSH
22793: LD_INT 100
22795: PUSH
22796: LD_INT 75
22798: PUSH
22799: LD_INT 6
22801: PUSH
22802: EMPTY
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: PPUSH
22812: CALL_OW 69
22816: IFFALSE 22773
// async ;
22818: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22819: LD_EXP 58
22823: PPUSH
22824: LD_STRING D6b-Pow-1
22826: PPUSH
22827: CALL_OW 88
// repeat wait ( 3 ) ;
22831: LD_INT 3
22833: PPUSH
22834: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22838: LD_EXP 58
22842: PPUSH
22843: CALL_OW 310
22847: PPUSH
22848: CALL_OW 256
22852: PUSH
22853: LD_INT 1000
22855: LESS
22856: IFFALSE 22875
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22858: LD_EXP 58
22862: PPUSH
22863: CALL_OW 310
22867: PPUSH
22868: LD_INT 1000
22870: PPUSH
22871: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22875: LD_EXP 58
22879: PPUSH
22880: CALL_OW 256
22884: PUSH
22885: LD_INT 1000
22887: LESS
22888: IFFALSE 22902
// SetLives ( Powell , 1000 ) ;
22890: LD_EXP 58
22894: PPUSH
22895: LD_INT 1000
22897: PPUSH
22898: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22902: LD_EXP 58
22906: PPUSH
22907: LD_EXP 63
22911: PPUSH
22912: CALL_OW 296
22916: PUSH
22917: LD_INT 5
22919: LESS
22920: PUSH
22921: LD_EXP 58
22925: PPUSH
22926: CALL_OW 310
22930: PPUSH
22931: LD_EXP 63
22935: PPUSH
22936: CALL_OW 296
22940: PUSH
22941: LD_INT 5
22943: LESS
22944: OR
22945: IFFALSE 22964
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22947: LD_EXP 58
22951: PPUSH
22952: CALL_OW 310
22956: PPUSH
22957: LD_INT 100
22959: PPUSH
22960: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22964: LD_EXP 58
22968: PPUSH
22969: CALL_OW 310
22973: NOT
22974: IFFALSE 22831
// DoNotAttack ( 8 , powellBomb ) ;
22976: LD_INT 8
22978: PPUSH
22979: LD_EXP 63
22983: PPUSH
22984: CALL_OW 471
// game_speed := 4 ;
22988: LD_ADDR_OWVAR 65
22992: PUSH
22993: LD_INT 4
22995: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22996: LD_EXP 58
23000: PPUSH
23001: LD_STRING D6b-Pow-1a
23003: PPUSH
23004: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
23008: LD_EXP 58
23012: PPUSH
23013: LD_EXP 63
23017: PPUSH
23018: CALL_OW 180
// sync ;
23022: SYNC
// repeat wait ( 0 0$1 ) ;
23023: LD_INT 35
23025: PPUSH
23026: CALL_OW 67
// until IsInUnit ( Powell ) ;
23030: LD_EXP 58
23034: PPUSH
23035: CALL_OW 310
23039: IFFALSE 23023
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23041: LD_INT 8
23043: PPUSH
23044: LD_EXP 58
23048: PPUSH
23049: CALL_OW 310
23053: PPUSH
23054: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23058: LD_EXP 58
23062: PPUSH
23063: LD_INT 91
23065: PPUSH
23066: LD_INT 44
23068: PPUSH
23069: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23073: LD_EXP 58
23077: PPUSH
23078: LD_INT 96
23080: PPUSH
23081: LD_INT 44
23083: PPUSH
23084: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23088: LD_EXP 58
23092: PPUSH
23093: LD_INT 96
23095: PPUSH
23096: LD_INT 41
23098: PPUSH
23099: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23103: LD_EXP 58
23107: PPUSH
23108: LD_INT 92
23110: PPUSH
23111: LD_INT 39
23113: PPUSH
23114: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23118: LD_EXP 58
23122: PPUSH
23123: LD_INT 88
23125: PPUSH
23126: LD_INT 41
23128: PPUSH
23129: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23133: LD_EXP 58
23137: PPUSH
23138: LD_INT 91
23140: PPUSH
23141: LD_INT 44
23143: PPUSH
23144: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23148: LD_EXP 58
23152: PPUSH
23153: LD_INT 96
23155: PPUSH
23156: LD_INT 44
23158: PPUSH
23159: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23163: LD_EXP 58
23167: PPUSH
23168: LD_INT 96
23170: PPUSH
23171: LD_INT 41
23173: PPUSH
23174: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23178: LD_EXP 58
23182: PPUSH
23183: LD_INT 92
23185: PPUSH
23186: LD_INT 39
23188: PPUSH
23189: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23193: LD_EXP 58
23197: PPUSH
23198: LD_INT 88
23200: PPUSH
23201: LD_INT 41
23203: PPUSH
23204: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23208: LD_EXP 58
23212: PPUSH
23213: LD_INT 91
23215: PPUSH
23216: LD_INT 44
23218: PPUSH
23219: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23223: LD_EXP 58
23227: PPUSH
23228: LD_INT 93
23230: PPUSH
23231: LD_INT 39
23233: PPUSH
23234: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23238: LD_EXP 58
23242: PPUSH
23243: LD_INT 93
23245: PPUSH
23246: LD_INT 36
23248: PPUSH
23249: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23253: LD_INT 122
23255: PPUSH
23256: CALL_OW 67
// game_speed := 4 ;
23260: LD_ADDR_OWVAR 65
23264: PUSH
23265: LD_INT 4
23267: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23268: LD_EXP 58
23272: PPUSH
23273: LD_STRING D6b-Pow-1b
23275: PPUSH
23276: CALL_OW 88
// tmp := [ ] ;
23280: LD_ADDR_VAR 0 3
23284: PUSH
23285: EMPTY
23286: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23287: LD_ADDR_VAR 0 5
23291: PUSH
23292: LD_INT 78
23294: PUSH
23295: LD_INT 47
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: PUSH
23302: LD_INT 106
23304: PUSH
23305: LD_INT 53
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23316: LD_ADDR_VAR 0 1
23320: PUSH
23321: LD_INT 22
23323: PUSH
23324: LD_INT 8
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: PUSH
23331: LD_INT 21
23333: PUSH
23334: LD_INT 3
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: PUSH
23341: LD_INT 92
23343: PUSH
23344: LD_INT 90
23346: PUSH
23347: LD_INT 52
23349: PUSH
23350: LD_INT 12
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: LIST
23363: PPUSH
23364: CALL_OW 69
23368: PUSH
23369: FOR_IN
23370: IFFALSE 23395
// tmp := tmp ^ UnitsInside ( i ) ;
23372: LD_ADDR_VAR 0 3
23376: PUSH
23377: LD_VAR 0 3
23381: PUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 313
23391: ADD
23392: ST_TO_ADDR
23393: GO 23369
23395: POP
23396: POP
// for i in tmp do
23397: LD_ADDR_VAR 0 1
23401: PUSH
23402: LD_VAR 0 3
23406: PUSH
23407: FOR_IN
23408: IFFALSE 23570
// begin dist := 9999 ;
23410: LD_ADDR_VAR 0 8
23414: PUSH
23415: LD_INT 9999
23417: ST_TO_ADDR
// _xy := [ ] ;
23418: LD_ADDR_VAR 0 7
23422: PUSH
23423: EMPTY
23424: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23425: LD_VAR 0 1
23429: PPUSH
23430: LD_INT 1
23432: PPUSH
23433: CALL_OW 109
// ComExitBuilding ( i ) ;
23437: LD_VAR 0 1
23441: PPUSH
23442: CALL_OW 122
// for j in xy do
23446: LD_ADDR_VAR 0 2
23450: PUSH
23451: LD_VAR 0 5
23455: PUSH
23456: FOR_IN
23457: IFFALSE 23539
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23459: LD_VAR 0 1
23463: PPUSH
23464: LD_VAR 0 2
23468: PUSH
23469: LD_INT 1
23471: ARRAY
23472: PPUSH
23473: LD_VAR 0 2
23477: PUSH
23478: LD_INT 2
23480: ARRAY
23481: PPUSH
23482: CALL_OW 297
23486: PUSH
23487: LD_VAR 0 8
23491: LESS
23492: IFFALSE 23537
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23494: LD_ADDR_VAR 0 8
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: LD_VAR 0 2
23508: PUSH
23509: LD_INT 1
23511: ARRAY
23512: PPUSH
23513: LD_VAR 0 2
23517: PUSH
23518: LD_INT 2
23520: ARRAY
23521: PPUSH
23522: CALL_OW 297
23526: ST_TO_ADDR
// _xy := j ;
23527: LD_ADDR_VAR 0 7
23531: PUSH
23532: LD_VAR 0 2
23536: ST_TO_ADDR
// end ;
23537: GO 23456
23539: POP
23540: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23541: LD_VAR 0 1
23545: PPUSH
23546: LD_VAR 0 7
23550: PUSH
23551: LD_INT 1
23553: ARRAY
23554: PPUSH
23555: LD_VAR 0 7
23559: PUSH
23560: LD_INT 2
23562: ARRAY
23563: PPUSH
23564: CALL_OW 171
// end ;
23568: GO 23407
23570: POP
23571: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23572: LD_ADDR_VAR 0 4
23576: PUSH
23577: LD_VAR 0 3
23581: PPUSH
23582: LD_INT 26
23584: PUSH
23585: LD_INT 1
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PUSH
23592: LD_INT 25
23594: PUSH
23595: LD_INT 1
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: PUSH
23602: EMPTY
23603: LIST
23604: LIST
23605: PPUSH
23606: CALL_OW 72
23610: ST_TO_ADDR
// if tmp2 < 2 then
23611: LD_VAR 0 4
23615: PUSH
23616: LD_INT 2
23618: LESS
23619: IFFALSE 23688
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23621: LD_ADDR_VAR 0 4
23625: PUSH
23626: LD_INT 22
23628: PUSH
23629: LD_INT 8
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: PUSH
23636: LD_INT 26
23638: PUSH
23639: LD_INT 1
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: PUSH
23646: LD_INT 3
23648: PUSH
23649: LD_INT 25
23651: PUSH
23652: LD_INT 15
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: LIST
23667: PPUSH
23668: CALL_OW 69
23672: PUSH
23673: LD_EXP 60
23677: PUSH
23678: LD_EXP 61
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: DIFF
23687: ST_TO_ADDR
// if tmp2 then
23688: LD_VAR 0 4
23692: IFFALSE 23710
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23694: LD_VAR 0 4
23698: PUSH
23699: LD_INT 1
23701: ARRAY
23702: PPUSH
23703: LD_STRING D6b-ArSol1-1
23705: PPUSH
23706: CALL_OW 88
// async ;
23710: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23711: LD_EXP 58
23715: PPUSH
23716: LD_STRING D6b-Pow-2
23718: PPUSH
23719: CALL_OW 88
// wait ( 0 0$1 ) ;
23723: LD_INT 35
23725: PPUSH
23726: CALL_OW 67
// if tmp2 > 1 then
23730: LD_VAR 0 4
23734: PUSH
23735: LD_INT 1
23737: GREATER
23738: IFFALSE 23756
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23740: LD_VAR 0 4
23744: PUSH
23745: LD_INT 2
23747: ARRAY
23748: PPUSH
23749: LD_STRING D6b-ArSol2-1
23751: PPUSH
23752: CALL_OW 88
// sync ;
23756: SYNC
// repeat wait ( 5 ) ;
23757: LD_INT 5
23759: PPUSH
23760: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23764: LD_INT 93
23766: PPUSH
23767: LD_INT 36
23769: PPUSH
23770: CALL_OW 428
23774: PPUSH
23775: CALL_OW 255
23779: PUSH
23780: LD_INT 4
23782: EQUAL
23783: IFFALSE 23757
// DialogueOn ;
23785: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23789: LD_INT 10
23791: PPUSH
23792: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23796: LD_EXP 58
23800: PPUSH
23801: LD_STRING D6b-Pow-2a
23803: PPUSH
23804: CALL_OW 88
// DialogueOff ;
23808: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23812: LD_EXP 58
23816: PPUSH
23817: CALL_OW 310
23821: PPUSH
23822: LD_INT 332
23824: PPUSH
23825: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23829: LD_INT 93
23831: PPUSH
23832: LD_INT 35
23834: PPUSH
23835: LD_INT 1
23837: PPUSH
23838: LD_INT 6
23840: NEG
23841: PPUSH
23842: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23846: LD_INT 35
23848: PPUSH
23849: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23853: LD_INT 332
23855: PPUSH
23856: CALL_OW 256
23860: PUSH
23861: LD_INT 1000
23863: LESS
23864: PUSH
23865: LD_INT 332
23867: PPUSH
23868: CALL_OW 300
23872: AND
23873: IFFALSE 23885
// SetLives ( kozlov_fac , 0 ) ;
23875: LD_INT 332
23877: PPUSH
23878: LD_INT 0
23880: PPUSH
23881: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23885: LD_INT 332
23887: PPUSH
23888: CALL_OW 301
23892: PUSH
23893: LD_EXP 58
23897: PPUSH
23898: CALL_OW 301
23902: OR
23903: IFFALSE 23846
// game_speed := 4 ;
23905: LD_ADDR_OWVAR 65
23909: PUSH
23910: LD_INT 4
23912: ST_TO_ADDR
// powellCenterCameraMode := false ;
23913: LD_ADDR_EXP 20
23917: PUSH
23918: LD_INT 0
23920: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23921: LD_ADDR_VAR 0 1
23925: PUSH
23926: LD_VAR 0 3
23930: PUSH
23931: LD_INT 22
23933: PUSH
23934: LD_INT 8
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: LD_INT 25
23943: PUSH
23944: LD_INT 2
23946: PUSH
23947: EMPTY
23948: LIST
23949: LIST
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PPUSH
23955: CALL_OW 69
23959: UNION
23960: PUSH
23961: FOR_IN
23962: IFFALSE 23978
// SetTag ( i , 0 ) ;
23964: LD_VAR 0 1
23968: PPUSH
23969: LD_INT 0
23971: PPUSH
23972: CALL_OW 109
23976: GO 23961
23978: POP
23979: POP
// wait ( 0 0$3 ) ;
23980: LD_INT 105
23982: PPUSH
23983: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23987: LD_INT 93
23989: PPUSH
23990: LD_INT 35
23992: PPUSH
23993: LD_INT 1
23995: PPUSH
23996: CALL_OW 331
// DialogueOn ;
24000: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
24004: LD_VAR 0 11
24008: PPUSH
24009: LD_STRING D6c-Sol3-1
24011: PPUSH
24012: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24016: LD_INT 10
24018: PPUSH
24019: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24023: LD_EXP 39
24027: PPUSH
24028: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24032: LD_EXP 39
24036: PPUSH
24037: LD_STRING D6c-JMM-1
24039: PPUSH
24040: CALL_OW 88
// if Cyrus then
24044: LD_EXP 45
24048: IFFALSE 24062
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24050: LD_EXP 45
24054: PPUSH
24055: LD_STRING D6c-Cyrus-1
24057: PPUSH
24058: CALL_OW 88
// if Bobby then
24062: LD_EXP 44
24066: IFFALSE 24080
// Say ( Bobby , D6c-Bobby-1 ) ;
24068: LD_EXP 44
24072: PPUSH
24073: LD_STRING D6c-Bobby-1
24075: PPUSH
24076: CALL_OW 88
// if Cornel then
24080: LD_EXP 50
24084: IFFALSE 24098
// Say ( Cornel , D6c-Corn-1 ) ;
24086: LD_EXP 50
24090: PPUSH
24091: LD_STRING D6c-Corn-1
24093: PPUSH
24094: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24098: LD_ADDR_VAR 0 4
24102: PUSH
24103: LD_INT 2
24105: PUSH
24106: LD_INT 22
24108: PUSH
24109: LD_INT 1
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: PUSH
24116: LD_INT 22
24118: PUSH
24119: LD_INT 4
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 26
24133: PUSH
24134: LD_INT 1
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PUSH
24141: LD_INT 3
24143: PUSH
24144: LD_INT 25
24146: PUSH
24147: LD_INT 16
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 25
24156: PUSH
24157: LD_INT 12
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: LIST
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: LIST
24173: PPUSH
24174: CALL_OW 69
24178: PUSH
24179: LD_VAR 0 11
24183: PUSH
24184: LD_EXP 39
24188: UNION
24189: PUSH
24190: LD_EXP 59
24194: UNION
24195: PUSH
24196: EMPTY
24197: LIST
24198: DIFF
24199: ST_TO_ADDR
// if tmp2 then
24200: LD_VAR 0 4
24204: IFFALSE 24222
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24206: LD_VAR 0 4
24210: PUSH
24211: LD_INT 1
24213: ARRAY
24214: PPUSH
24215: LD_STRING D6c-Sol1-1
24217: PPUSH
24218: CALL_OW 88
// if Lisa then
24222: LD_EXP 42
24226: IFFALSE 24240
// Say ( Lisa , D6c-Lisa-1 ) ;
24228: LD_EXP 42
24232: PPUSH
24233: LD_STRING D6c-Lisa-1
24235: PPUSH
24236: CALL_OW 88
// if Gary then
24240: LD_EXP 51
24244: IFFALSE 24258
// Say ( Gary , D6c-Gary-1 ) ;
24246: LD_EXP 51
24250: PPUSH
24251: LD_STRING D6c-Gary-1
24253: PPUSH
24254: CALL_OW 88
// if Donaldson then
24258: LD_EXP 43
24262: IFFALSE 24276
// Say ( Donaldson , D6c-Don-1 ) ;
24264: LD_EXP 43
24268: PPUSH
24269: LD_STRING D6c-Don-1
24271: PPUSH
24272: CALL_OW 88
// if tmp2 > 1 then
24276: LD_VAR 0 4
24280: PUSH
24281: LD_INT 1
24283: GREATER
24284: IFFALSE 24302
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24286: LD_VAR 0 4
24290: PUSH
24291: LD_INT 2
24293: ARRAY
24294: PPUSH
24295: LD_STRING D6c-Sol2-1
24297: PPUSH
24298: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24302: LD_VAR 0 11
24306: PPUSH
24307: LD_STRING D6c-Sol3-2
24309: PPUSH
24310: CALL_OW 88
// dwait ( 0 0$1 ) ;
24314: LD_INT 35
24316: PPUSH
24317: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24321: LD_EXP 39
24325: PPUSH
24326: LD_STRING D6c-JMM-2
24328: PPUSH
24329: CALL_OW 88
// DialogueOff ;
24333: CALL_OW 7
// Video ( false ) ;
24337: LD_INT 0
24339: PPUSH
24340: CALL 103080 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24344: LD_INT 22
24346: PUSH
24347: LD_INT 4
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PPUSH
24354: CALL_OW 69
24358: PPUSH
24359: LD_INT 1
24361: PPUSH
24362: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24366: LD_INT 4
24368: PPUSH
24369: LD_INT 4
24371: PPUSH
24372: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24376: LD_ADDR_VAR 0 1
24380: PUSH
24381: LD_INT 4
24383: PPUSH
24384: LD_INT 1
24386: PPUSH
24387: LD_INT 2
24389: PPUSH
24390: CALL 65795 0 3
24394: PUSH
24395: FOR_IN
24396: IFFALSE 24433
// if GetTech ( i , 1 ) <> state_researched then
24398: LD_VAR 0 1
24402: PPUSH
24403: LD_INT 1
24405: PPUSH
24406: CALL_OW 321
24410: PUSH
24411: LD_INT 2
24413: NONEQUAL
24414: IFFALSE 24431
// SetTech ( i , 1 , state_researched ) ;
24416: LD_VAR 0 1
24420: PPUSH
24421: LD_INT 1
24423: PPUSH
24424: LD_INT 2
24426: PPUSH
24427: CALL_OW 322
24431: GO 24395
24433: POP
24434: POP
// missionStage := 6 ;
24435: LD_ADDR_EXP 15
24439: PUSH
24440: LD_INT 6
24442: ST_TO_ADDR
// activeAttacks := true ;
24443: LD_ADDR_EXP 16
24447: PUSH
24448: LD_INT 1
24450: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24451: LD_STRING M2
24453: PPUSH
24454: CALL_OW 337
// SaveForQuickRestart ;
24458: CALL_OW 22
// wait ( 0 0$40 ) ;
24462: LD_INT 1400
24464: PPUSH
24465: CALL_OW 67
// DialogueOn ;
24469: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24473: LD_EXP 62
24477: PPUSH
24478: LD_STRING D7-Friend-1
24480: PPUSH
24481: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24485: LD_EXP 39
24489: PPUSH
24490: LD_STRING D7-JMM-1
24492: PPUSH
24493: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24497: LD_EXP 62
24501: PPUSH
24502: LD_STRING D7-Friend-2
24504: PPUSH
24505: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24509: LD_EXP 39
24513: PPUSH
24514: LD_STRING D7-JMM-2
24516: PPUSH
24517: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24521: LD_EXP 62
24525: PPUSH
24526: LD_STRING D7-Friend-3
24528: PPUSH
24529: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24533: LD_EXP 39
24537: PPUSH
24538: LD_STRING D7-JMM-3
24540: PPUSH
24541: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24545: LD_EXP 62
24549: PPUSH
24550: LD_STRING D7-Friend-4
24552: PPUSH
24553: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24557: LD_EXP 39
24561: PPUSH
24562: LD_STRING D7-JMM-4
24564: PPUSH
24565: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24569: LD_EXP 62
24573: PPUSH
24574: LD_STRING D7-Friend-5
24576: PPUSH
24577: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24581: LD_EXP 39
24585: PPUSH
24586: LD_STRING D7-JMM-5
24588: PPUSH
24589: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24593: LD_EXP 62
24597: PPUSH
24598: LD_STRING D7-Friend-6
24600: PPUSH
24601: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24605: LD_EXP 39
24609: PPUSH
24610: LD_STRING D7-JMM-6
24612: PPUSH
24613: CALL_OW 88
// DialogueOff ;
24617: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24621: LD_STRING Mlegion
24623: PPUSH
24624: CALL_OW 337
// skirmish := true ;
24628: LD_ADDR_EXP 95
24632: PUSH
24633: LD_INT 1
24635: ST_TO_ADDR
// RebuildKozlovFactory ;
24636: CALL 4886 0 0
// end ;
24640: PPOPN 13
24642: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24643: LD_EXP 20
24647: PUSH
24648: LD_EXP 58
24652: PPUSH
24653: CALL_OW 300
24657: AND
24658: IFFALSE 24700
24660: GO 24662
24662: DISABLE
// begin enable ;
24663: ENABLE
// if IsInUnit ( Powell ) then
24664: LD_EXP 58
24668: PPUSH
24669: CALL_OW 310
24673: IFFALSE 24691
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24675: LD_EXP 58
24679: PPUSH
24680: CALL_OW 310
24684: PPUSH
24685: CALL_OW 85
24689: GO 24700
// CenterOnUnits ( Powell ) ;
24691: LD_EXP 58
24695: PPUSH
24696: CALL_OW 85
// end ;
24700: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24701: LD_INT 22
24703: PUSH
24704: LD_INT 8
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: PUSH
24711: LD_INT 34
24713: PUSH
24714: LD_INT 48
24716: PUSH
24717: EMPTY
24718: LIST
24719: LIST
24720: PUSH
24721: EMPTY
24722: LIST
24723: LIST
24724: PPUSH
24725: CALL_OW 69
24729: IFFALSE 25003
24731: GO 24733
24733: DISABLE
24734: LD_INT 0
24736: PPUSH
24737: PPUSH
// begin if missionStage < 9 then
24738: LD_EXP 15
24742: PUSH
24743: LD_INT 9
24745: LESS
24746: IFFALSE 24756
// missionStage := 9 ;
24748: LD_ADDR_EXP 15
24752: PUSH
24753: LD_INT 9
24755: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24756: LD_ADDR_VAR 0 1
24760: PUSH
24761: LD_INT 22
24763: PUSH
24764: LD_INT 8
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PUSH
24771: LD_INT 34
24773: PUSH
24774: LD_INT 48
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PPUSH
24785: CALL_OW 69
24789: PUSH
24790: LD_INT 1
24792: ARRAY
24793: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24794: LD_INT 175
24796: PPUSH
24797: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24801: LD_EXP 12
24805: PUSH
24806: LD_EXP 3
24810: PUSH
24811: LD_INT 0
24813: PUSH
24814: LD_INT 2
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: IN
24821: OR
24822: IFFALSE 24845
// target := [ 68 , 108 , 1 ] else
24824: LD_ADDR_VAR 0 2
24828: PUSH
24829: LD_INT 68
24831: PUSH
24832: LD_INT 108
24834: PUSH
24835: LD_INT 1
24837: PUSH
24838: EMPTY
24839: LIST
24840: LIST
24841: LIST
24842: ST_TO_ADDR
24843: GO 24864
// target := [ 181 , 88 , 2 ] ;
24845: LD_ADDR_VAR 0 2
24849: PUSH
24850: LD_INT 181
24852: PUSH
24853: LD_INT 88
24855: PUSH
24856: LD_INT 2
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: LIST
24863: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24864: LD_VAR 0 1
24868: PPUSH
24869: LD_VAR 0 2
24873: PUSH
24874: LD_INT 1
24876: ARRAY
24877: PPUSH
24878: LD_VAR 0 2
24882: PUSH
24883: LD_INT 2
24885: ARRAY
24886: PPUSH
24887: CALL_OW 176
// if target [ 3 ] = 1 then
24891: LD_VAR 0 2
24895: PUSH
24896: LD_INT 3
24898: ARRAY
24899: PUSH
24900: LD_INT 1
24902: EQUAL
24903: IFFALSE 24919
// SayRadio ( Kurt , D12-Kurt-1 ) else
24905: LD_EXP 60
24909: PPUSH
24910: LD_STRING D12-Kurt-1
24912: PPUSH
24913: CALL_OW 94
24917: GO 24943
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24919: LD_EXP 60
24923: PPUSH
24924: LD_STRING D12a-Kurt-1
24926: PPUSH
24927: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24931: LD_EXP 74
24935: PPUSH
24936: LD_STRING D12a-Roth-1
24938: PPUSH
24939: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24943: LD_INT 350
24945: PPUSH
24946: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24950: LD_VAR 0 1
24954: PPUSH
24955: LD_INT 22
24957: PUSH
24958: LD_INT 8
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: LD_INT 23
24967: PUSH
24968: LD_INT 2
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: PUSH
24975: LD_INT 30
24977: PUSH
24978: LD_INT 3
24980: PUSH
24981: EMPTY
24982: LIST
24983: LIST
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: LIST
24989: PPUSH
24990: CALL_OW 69
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PPUSH
24999: CALL_OW 228
// end ;
25003: PPOPN 2
25005: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
25006: LD_EXP 60
25010: PPUSH
25011: CALL_OW 256
25015: PUSH
25016: LD_INT 999
25018: LESS
25019: PUSH
25020: LD_INT 22
25022: PUSH
25023: LD_INT 8
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: LD_INT 21
25032: PUSH
25033: LD_INT 1
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: PUSH
25040: LD_INT 23
25042: PUSH
25043: LD_INT 2
25045: PUSH
25046: EMPTY
25047: LIST
25048: LIST
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: LIST
25054: PPUSH
25055: CALL_OW 69
25059: PUSH
25060: LD_INT 9
25062: PUSH
25063: LD_INT 8
25065: PUSH
25066: LD_INT 7
25068: PUSH
25069: LD_INT 6
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: LIST
25076: LIST
25077: PUSH
25078: LD_OWVAR 67
25082: ARRAY
25083: LESSEQUAL
25084: OR
25085: PUSH
25086: LD_INT 22
25088: PUSH
25089: LD_INT 8
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PUSH
25096: LD_INT 34
25098: PUSH
25099: LD_INT 48
25101: PUSH
25102: EMPTY
25103: LIST
25104: LIST
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PPUSH
25110: CALL_OW 69
25114: NOT
25115: AND
25116: PUSH
25117: LD_EXP 60
25121: PPUSH
25122: CALL_OW 302
25126: AND
25127: PUSH
25128: LD_INT 5
25130: PPUSH
25131: LD_INT 22
25133: PUSH
25134: LD_INT 1
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PPUSH
25141: CALL_OW 70
25145: AND
25146: IFFALSE 25859
25148: GO 25150
25150: DISABLE
25151: LD_INT 0
25153: PPUSH
25154: PPUSH
25155: PPUSH
// begin legionDestroyed := true ;
25156: LD_ADDR_EXP 22
25160: PUSH
25161: LD_INT 1
25163: ST_TO_ADDR
// DialogueOn ;
25164: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25168: LD_EXP 39
25172: PPUSH
25173: LD_STRING D13-JMM-1
25175: PPUSH
25176: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25180: LD_EXP 60
25184: PPUSH
25185: LD_STRING D13-Kurt-1
25187: PPUSH
25188: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25192: LD_EXP 39
25196: PPUSH
25197: LD_STRING D13-JMM-2
25199: PPUSH
25200: CALL_OW 88
// if FakeInfo then
25204: LD_EXP 12
25208: IFFALSE 25228
// begin Say ( Kurt , D13-Kurt-2 ) ;
25210: LD_EXP 60
25214: PPUSH
25215: LD_STRING D13-Kurt-2
25217: PPUSH
25218: CALL_OW 88
// DialogueOff ;
25222: CALL_OW 7
// exit ;
25226: GO 25859
// end ; if not KurtStatus then
25228: LD_EXP 3
25232: NOT
25233: IFFALSE 25249
// Say ( Kurt , D13-Kurt-2b ) else
25235: LD_EXP 60
25239: PPUSH
25240: LD_STRING D13-Kurt-2b
25242: PPUSH
25243: CALL_OW 88
25247: GO 25261
// Say ( Kurt , D13-Kurt-2a ) ;
25249: LD_EXP 60
25253: PPUSH
25254: LD_STRING D13-Kurt-2a
25256: PPUSH
25257: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25261: LD_EXP 39
25265: PPUSH
25266: LD_STRING D13-JMM-3
25268: PPUSH
25269: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25273: LD_EXP 60
25277: PPUSH
25278: LD_STRING D13-Kurt-3
25280: PPUSH
25281: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25285: LD_EXP 39
25289: PPUSH
25290: LD_STRING D13-JMM-4
25292: PPUSH
25293: CALL_OW 88
// DialogueOff ;
25297: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25301: LD_STRING MlegionOut
25303: PPUSH
25304: CALL_OW 337
// MC_Kill ( 3 ) ;
25308: LD_INT 3
25310: PPUSH
25311: CALL 35370 0 1
// KillUnit ( Kozlov ) ;
25315: LD_EXP 61
25319: PPUSH
25320: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25324: LD_ADDR_VAR 0 1
25328: PUSH
25329: LD_INT 22
25331: PUSH
25332: LD_INT 8
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 23
25341: PUSH
25342: LD_INT 3
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: LD_INT 3
25351: PUSH
25352: LD_INT 21
25354: PUSH
25355: LD_INT 33
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: LIST
25370: PPUSH
25371: CALL_OW 69
25375: PUSH
25376: FOR_IN
25377: IFFALSE 25390
// KillUnit ( i ) ;
25379: LD_VAR 0 1
25383: PPUSH
25384: CALL_OW 66
25388: GO 25376
25390: POP
25391: POP
// ChangeSideFog ( 8 , 1 ) ;
25392: LD_INT 8
25394: PPUSH
25395: LD_INT 1
25397: PPUSH
25398: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25402: LD_ADDR_VAR 0 2
25406: PUSH
25407: LD_INT 22
25409: PUSH
25410: LD_INT 8
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 21
25419: PUSH
25420: LD_INT 1
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: PPUSH
25431: CALL_OW 69
25435: PUSH
25436: LD_EXP 61
25440: PUSH
25441: LD_EXP 60
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: DIFF
25450: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25451: LD_VAR 0 2
25455: PUSH
25456: LD_INT 6
25458: PUSH
25459: LD_INT 5
25461: PUSH
25462: LD_INT 4
25464: PUSH
25465: LD_INT 3
25467: PUSH
25468: EMPTY
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: PUSH
25474: LD_OWVAR 67
25478: ARRAY
25479: GREATEREQUAL
25480: IFFALSE 25658
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25482: LD_ADDR_VAR 0 3
25486: PUSH
25487: LD_INT 6
25489: PUSH
25490: LD_INT 5
25492: PUSH
25493: LD_INT 4
25495: PUSH
25496: LD_INT 3
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: LIST
25503: LIST
25504: PUSH
25505: LD_OWVAR 67
25509: ARRAY
25510: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25511: LD_ADDR_VAR 0 1
25515: PUSH
25516: DOUBLE
25517: LD_VAR 0 2
25521: PUSH
25522: LD_VAR 0 3
25526: PUSH
25527: LD_INT 1
25529: PLUS
25530: MINUS
25531: INC
25532: ST_TO_ADDR
25533: LD_INT 1
25535: PUSH
25536: FOR_DOWNTO
25537: IFFALSE 25654
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25539: LD_ADDR_EXP 38
25543: PUSH
25544: LD_EXP 38
25548: PUSH
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: ADD
25560: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25561: LD_VAR 0 2
25565: PUSH
25566: LD_VAR 0 1
25570: ARRAY
25571: PPUSH
25572: CALL_OW 310
25576: IFFALSE 25593
// ComExitBuilding ( tmp [ i ] ) ;
25578: LD_VAR 0 2
25582: PUSH
25583: LD_VAR 0 1
25587: ARRAY
25588: PPUSH
25589: CALL_OW 122
// if IsInUnit ( i ) then
25593: LD_VAR 0 1
25597: PPUSH
25598: CALL_OW 310
25602: IFFALSE 25619
// ComExitVehicle ( tmp [ i ] ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25619: LD_VAR 0 2
25623: PUSH
25624: LD_VAR 0 1
25628: ARRAY
25629: PPUSH
25630: LD_INT 34
25632: PUSH
25633: LD_INT 0
25635: PPUSH
25636: LD_INT 6
25638: PPUSH
25639: CALL_OW 12
25643: PLUS
25644: PPUSH
25645: LD_INT 1
25647: PPUSH
25648: CALL_OW 171
// end ;
25652: GO 25536
25654: POP
25655: POP
// end else
25656: GO 25668
// x := tmp ;
25658: LD_ADDR_VAR 0 3
25662: PUSH
25663: LD_VAR 0 2
25667: ST_TO_ADDR
// for i := tmp downto tmp - x do
25668: LD_ADDR_VAR 0 1
25672: PUSH
25673: DOUBLE
25674: LD_VAR 0 2
25678: INC
25679: ST_TO_ADDR
25680: LD_VAR 0 2
25684: PUSH
25685: LD_VAR 0 3
25689: MINUS
25690: PUSH
25691: FOR_DOWNTO
25692: IFFALSE 25746
// begin if IsInUnit ( tmp [ i ] ) then
25694: LD_VAR 0 2
25698: PUSH
25699: LD_VAR 0 1
25703: ARRAY
25704: PPUSH
25705: CALL_OW 310
25709: IFFALSE 25726
// ComExitVehicle ( tmp [ i ] ) ;
25711: LD_VAR 0 2
25715: PUSH
25716: LD_VAR 0 1
25720: ARRAY
25721: PPUSH
25722: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25726: LD_VAR 0 2
25730: PUSH
25731: LD_VAR 0 1
25735: ARRAY
25736: PPUSH
25737: LD_INT 1
25739: PPUSH
25740: CALL_OW 235
// end ;
25744: GO 25691
25746: POP
25747: POP
// SetSide ( Kurt , 1 ) ;
25748: LD_EXP 60
25752: PPUSH
25753: LD_INT 1
25755: PPUSH
25756: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25760: LD_INT 22
25762: PUSH
25763: LD_INT 8
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PUSH
25770: LD_INT 21
25772: PUSH
25773: LD_INT 3
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PPUSH
25784: CALL_OW 69
25788: PPUSH
25789: LD_INT 1
25791: PPUSH
25792: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25796: LD_INT 8
25798: PPUSH
25799: LD_INT 1
25801: PPUSH
25802: LD_INT 1
25804: PPUSH
25805: LD_INT 1
25807: PPUSH
25808: CALL_OW 80
// wait ( 1 1$20 ) ;
25812: LD_INT 2800
25814: PPUSH
25815: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25819: LD_EXP 62
25823: PPUSH
25824: LD_INT 37
25826: PPUSH
25827: LD_INT 1
25829: PPUSH
25830: LD_INT 0
25832: PPUSH
25833: CALL_OW 48
// wait ( 0 0$1 ) ;
25837: LD_INT 35
25839: PPUSH
25840: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25844: LD_EXP 62
25848: PPUSH
25849: LD_INT 60
25851: PPUSH
25852: LD_INT 95
25854: PPUSH
25855: CALL_OW 111
// end ;
25859: PPOPN 3
25861: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25862: LD_EXP 22
25866: NOT
25867: PUSH
25868: LD_INT 22
25870: PUSH
25871: LD_INT 8
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PUSH
25878: LD_INT 21
25880: PUSH
25881: LD_INT 1
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL_OW 69
25896: PUSH
25897: LD_INT 0
25899: EQUAL
25900: AND
25901: IFFALSE 25921
25903: GO 25905
25905: DISABLE
// begin legionDestroyed := true ;
25906: LD_ADDR_EXP 22
25910: PUSH
25911: LD_INT 1
25913: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25914: LD_STRING MlegionOut
25916: PPUSH
25917: CALL_OW 337
// end ;
25921: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25922: LD_EXP 38
25926: IFFALSE 26001
25928: GO 25930
25930: DISABLE
25931: LD_INT 0
25933: PPUSH
// begin enable ;
25934: ENABLE
// for i in legionEscapeUnits do
25935: LD_ADDR_VAR 0 1
25939: PUSH
25940: LD_EXP 38
25944: PUSH
25945: FOR_IN
25946: IFFALSE 25999
// begin if IsInArea ( i , legionEscapeArea ) then
25948: LD_VAR 0 1
25952: PPUSH
25953: LD_INT 31
25955: PPUSH
25956: CALL_OW 308
25960: IFFALSE 25973
// RemoveUnit ( i ) else
25962: LD_VAR 0 1
25966: PPUSH
25967: CALL_OW 64
25971: GO 25997
// if not HasTask ( i ) then
25973: LD_VAR 0 1
25977: PPUSH
25978: CALL_OW 314
25982: NOT
25983: IFFALSE 25997
// ComMoveToArea ( i , legionEscapeArea ) ;
25985: LD_VAR 0 1
25989: PPUSH
25990: LD_INT 31
25992: PPUSH
25993: CALL_OW 113
// end ;
25997: GO 25945
25999: POP
26000: POP
// end ;
26001: PPOPN 1
26003: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
26004: LD_INT 1
26006: PPUSH
26007: LD_EXP 62
26011: PPUSH
26012: CALL_OW 292
26016: IFFALSE 26314
26018: GO 26020
26020: DISABLE
26021: LD_INT 0
26023: PPUSH
// begin wait ( 0 0$2 ) ;
26024: LD_INT 70
26026: PPUSH
26027: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26031: LD_EXP 62
26035: PPUSH
26036: CALL_OW 87
// DialogueOn ;
26040: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26044: LD_EXP 39
26048: PPUSH
26049: LD_STRING D14-JMM-1
26051: PPUSH
26052: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26056: LD_EXP 62
26060: PPUSH
26061: LD_STRING D14-Friend-1
26063: PPUSH
26064: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26068: LD_EXP 39
26072: PPUSH
26073: LD_STRING D14-JMM-2
26075: PPUSH
26076: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26080: LD_EXP 62
26084: PPUSH
26085: LD_STRING D14-Friend-2
26087: PPUSH
26088: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26092: LD_EXP 39
26096: PPUSH
26097: LD_STRING D14-JMM-3
26099: PPUSH
26100: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26104: LD_EXP 62
26108: PPUSH
26109: LD_STRING D14-Friend-3
26111: PPUSH
26112: CALL_OW 88
// DialogueOff ;
26116: CALL_OW 7
// dec = Query ( Q14 ) ;
26120: LD_ADDR_VAR 0 1
26124: PUSH
26125: LD_STRING Q14
26127: PPUSH
26128: CALL_OW 97
26132: ST_TO_ADDR
// if dec = 1 then
26133: LD_VAR 0 1
26137: PUSH
26138: LD_INT 1
26140: EQUAL
26141: IFFALSE 26175
// begin DialogueOn ;
26143: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26147: LD_EXP 39
26151: PPUSH
26152: LD_STRING D14a-JMM-1
26154: PPUSH
26155: CALL_OW 88
// DialogueOff ;
26159: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26163: LD_EXP 62
26167: PPUSH
26168: LD_INT 1
26170: PPUSH
26171: CALL_OW 235
// end ; if dec = 2 then
26175: LD_VAR 0 1
26179: PUSH
26180: LD_INT 2
26182: EQUAL
26183: IFFALSE 26236
// begin DialogueOn ;
26185: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26189: LD_EXP 39
26193: PPUSH
26194: LD_STRING D14b-JMM-1
26196: PPUSH
26197: CALL_OW 88
// DialogueOff ;
26201: CALL_OW 7
// wait ( 0 0$1 ) ;
26205: LD_INT 35
26207: PPUSH
26208: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26212: LD_EXP 62
26216: PPUSH
26217: LD_INT 9
26219: PPUSH
26220: LD_INT 2
26222: PPUSH
26223: CALL_OW 111
// AddComHold ( Friend ) ;
26227: LD_EXP 62
26231: PPUSH
26232: CALL_OW 200
// end ; if dec = 3 then
26236: LD_VAR 0 1
26240: PUSH
26241: LD_INT 3
26243: EQUAL
26244: IFFALSE 26314
// begin DialogueOn ;
26246: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26250: LD_EXP 39
26254: PPUSH
26255: LD_STRING D14c-JMM-1
26257: PPUSH
26258: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26262: LD_EXP 62
26266: PPUSH
26267: LD_STRING D14c-Friend-1
26269: PPUSH
26270: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26274: LD_EXP 39
26278: PPUSH
26279: LD_STRING D14c-JMM-2
26281: PPUSH
26282: CALL_OW 88
// DialogueOff ;
26286: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26290: LD_EXP 62
26294: PPUSH
26295: LD_INT 9
26297: PPUSH
26298: LD_INT 2
26300: PPUSH
26301: CALL_OW 111
// AddComHold ( Friend ) ;
26305: LD_EXP 62
26309: PPUSH
26310: CALL_OW 200
// end ; end ;
26314: PPOPN 1
26316: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26317: LD_INT 9
26319: PPUSH
26320: LD_INT 2
26322: PPUSH
26323: CALL_OW 428
26327: PUSH
26328: LD_EXP 62
26332: EQUAL
26333: PUSH
26334: LD_EXP 62
26338: PPUSH
26339: CALL_OW 255
26343: PUSH
26344: LD_INT 8
26346: EQUAL
26347: AND
26348: IFFALSE 26362
26350: GO 26352
26352: DISABLE
// RemoveUnit ( Friend ) ;
26353: LD_EXP 62
26357: PPUSH
26358: CALL_OW 64
26362: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26363: LD_EXP 14
26367: PUSH
26368: LD_INT 31500
26370: GREATEREQUAL
26371: PUSH
26372: LD_EXP 7
26376: AND
26377: PUSH
26378: LD_EXP 2
26382: AND
26383: IFFALSE 26813
26385: GO 26387
26387: DISABLE
26388: LD_INT 0
26390: PPUSH
26391: PPUSH
26392: PPUSH
// begin missionStage := 7 ;
26393: LD_ADDR_EXP 15
26397: PUSH
26398: LD_INT 7
26400: ST_TO_ADDR
// uc_side = 1 ;
26401: LD_ADDR_OWVAR 20
26405: PUSH
26406: LD_INT 1
26408: ST_TO_ADDR
// uc_nation = 1 ;
26409: LD_ADDR_OWVAR 21
26413: PUSH
26414: LD_INT 1
26416: ST_TO_ADDR
// for i = 1 to 5 do
26417: LD_ADDR_VAR 0 1
26421: PUSH
26422: DOUBLE
26423: LD_INT 1
26425: DEC
26426: ST_TO_ADDR
26427: LD_INT 5
26429: PUSH
26430: FOR_TO
26431: IFFALSE 26527
// begin vc_engine = 3 ;
26433: LD_ADDR_OWVAR 39
26437: PUSH
26438: LD_INT 3
26440: ST_TO_ADDR
// vc_control = 3 ;
26441: LD_ADDR_OWVAR 38
26445: PUSH
26446: LD_INT 3
26448: ST_TO_ADDR
// vc_chassis = 3 ;
26449: LD_ADDR_OWVAR 37
26453: PUSH
26454: LD_INT 3
26456: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26457: LD_ADDR_OWVAR 40
26461: PUSH
26462: LD_INT 5
26464: PUSH
26465: LD_INT 9
26467: PUSH
26468: LD_INT 7
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: PPUSH
26479: LD_INT 3
26481: PPUSH
26482: CALL_OW 12
26486: ARRAY
26487: ST_TO_ADDR
// veh = CreateVehicle ;
26488: LD_ADDR_VAR 0 2
26492: PUSH
26493: CALL_OW 45
26497: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26498: LD_VAR 0 2
26502: PPUSH
26503: LD_INT 1
26505: PPUSH
26506: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26510: LD_VAR 0 2
26514: PPUSH
26515: LD_INT 19
26517: PPUSH
26518: LD_INT 0
26520: PPUSH
26521: CALL_OW 49
// end ;
26525: GO 26430
26527: POP
26528: POP
// vc_engine = 3 ;
26529: LD_ADDR_OWVAR 39
26533: PUSH
26534: LD_INT 3
26536: ST_TO_ADDR
// vc_control = 1 ;
26537: LD_ADDR_OWVAR 38
26541: PUSH
26542: LD_INT 1
26544: ST_TO_ADDR
// vc_chassis = 3 ;
26545: LD_ADDR_OWVAR 37
26549: PUSH
26550: LD_INT 3
26552: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26553: LD_ADDR_OWVAR 40
26557: PUSH
26558: LD_INT 5
26560: PUSH
26561: LD_INT 9
26563: PUSH
26564: LD_INT 7
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: LIST
26571: PUSH
26572: LD_INT 1
26574: PPUSH
26575: LD_INT 3
26577: PPUSH
26578: CALL_OW 12
26582: ARRAY
26583: ST_TO_ADDR
// vehG = CreateVehicle ;
26584: LD_ADDR_VAR 0 3
26588: PUSH
26589: CALL_OW 45
26593: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26594: LD_VAR 0 3
26598: PPUSH
26599: LD_INT 1
26601: PPUSH
26602: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: LD_INT 19
26613: PPUSH
26614: LD_INT 0
26616: PPUSH
26617: CALL_OW 49
// if JMMGirl = 1 then
26621: LD_EXP 7
26625: PUSH
26626: LD_INT 1
26628: EQUAL
26629: IFFALSE 26685
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26631: LD_ADDR_EXP 40
26635: PUSH
26636: LD_STRING Joan
26638: PPUSH
26639: LD_INT 1
26641: PPUSH
26642: LD_STRING 14_
26644: PPUSH
26645: CALL 65732 0 3
26649: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26650: LD_EXP 40
26654: PPUSH
26655: LD_VAR 0 3
26659: PPUSH
26660: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26664: LD_VAR 0 3
26668: PPUSH
26669: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26673: LD_EXP 40
26677: PPUSH
26678: LD_STRING D10BW-Joan-1
26680: PPUSH
26681: CALL_OW 94
// end ; if JMMGirl = 2 then
26685: LD_EXP 7
26689: PUSH
26690: LD_INT 2
26692: EQUAL
26693: IFFALSE 26749
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26695: LD_ADDR_EXP 42
26699: PUSH
26700: LD_STRING Lisa
26702: PPUSH
26703: LD_INT 1
26705: PPUSH
26706: LD_STRING 14_
26708: PPUSH
26709: CALL 65732 0 3
26713: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26714: LD_EXP 42
26718: PPUSH
26719: LD_VAR 0 3
26723: PPUSH
26724: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26728: LD_VAR 0 3
26732: PPUSH
26733: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26737: LD_EXP 42
26741: PPUSH
26742: LD_STRING D10BW-Lisa-1
26744: PPUSH
26745: CALL_OW 94
// end ; if JMMGirl = 3 then
26749: LD_EXP 7
26753: PUSH
26754: LD_INT 3
26756: EQUAL
26757: IFFALSE 26813
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26759: LD_ADDR_EXP 54
26763: PUSH
26764: LD_STRING Connie
26766: PPUSH
26767: LD_INT 1
26769: PPUSH
26770: LD_STRING 14_
26772: PPUSH
26773: CALL 65732 0 3
26777: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26778: LD_EXP 54
26782: PPUSH
26783: LD_VAR 0 3
26787: PPUSH
26788: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26792: LD_VAR 0 3
26796: PPUSH
26797: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26801: LD_EXP 54
26805: PPUSH
26806: LD_STRING D10BW-Con-1
26808: PPUSH
26809: CALL_OW 94
// end ; end ;
26813: PPOPN 3
26815: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26816: LD_EXP 14
26820: PUSH
26821: LD_INT 94500
26823: GREATEREQUAL
26824: IFFALSE 27236
26826: GO 26828
26828: DISABLE
26829: LD_INT 0
26831: PPUSH
26832: PPUSH
26833: PPUSH
// begin tmp := PrepareStevensSquad ;
26834: LD_ADDR_VAR 0 3
26838: PUSH
26839: CALL 2220 0 0
26843: ST_TO_ADDR
// if not tmp then
26844: LD_VAR 0 3
26848: NOT
26849: IFFALSE 26853
// exit ;
26851: GO 27236
// uc_side := 1 ;
26853: LD_ADDR_OWVAR 20
26857: PUSH
26858: LD_INT 1
26860: ST_TO_ADDR
// uc_nation := 1 ;
26861: LD_ADDR_OWVAR 21
26865: PUSH
26866: LD_INT 1
26868: ST_TO_ADDR
// for i in tmp do
26869: LD_ADDR_VAR 0 1
26873: PUSH
26874: LD_VAR 0 3
26878: PUSH
26879: FOR_IN
26880: IFFALSE 26977
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26882: LD_INT 3
26884: PPUSH
26885: LD_INT 3
26887: PPUSH
26888: LD_INT 1
26890: PPUSH
26891: LD_INT 5
26893: PUSH
26894: LD_INT 9
26896: PUSH
26897: LD_INT 7
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 1
26907: PPUSH
26908: LD_INT 3
26910: PPUSH
26911: CALL_OW 12
26915: ARRAY
26916: PPUSH
26917: LD_INT 40
26919: PPUSH
26920: CALL 70747 0 5
// veh := CreateVehicle ;
26924: LD_ADDR_VAR 0 2
26928: PUSH
26929: CALL_OW 45
26933: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26934: LD_VAR 0 2
26938: PPUSH
26939: LD_INT 1
26941: PPUSH
26942: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 19
26953: PPUSH
26954: LD_INT 0
26956: PPUSH
26957: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26961: LD_VAR 0 1
26965: PPUSH
26966: LD_VAR 0 2
26970: PPUSH
26971: CALL_OW 52
// end ;
26975: GO 26879
26977: POP
26978: POP
// missionStage := 8 ;
26979: LD_ADDR_EXP 15
26983: PUSH
26984: LD_INT 8
26986: ST_TO_ADDR
// DialogueOn ;
26987: CALL_OW 6
// if Stevens then
26991: LD_EXP 41
26995: IFFALSE 27109
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26997: LD_EXP 41
27001: PPUSH
27002: CALL_OW 310
27006: PPUSH
27007: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
27011: LD_EXP 41
27015: PPUSH
27016: LD_STRING D8-Huck-1
27018: PPUSH
27019: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27023: LD_EXP 39
27027: PPUSH
27028: LD_STRING D8-JMM-1
27030: PPUSH
27031: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27035: LD_EXP 41
27039: PPUSH
27040: LD_STRING D8-Huck-2
27042: PPUSH
27043: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27047: LD_EXP 39
27051: PPUSH
27052: LD_STRING D8-JMM-2
27054: PPUSH
27055: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27059: LD_EXP 41
27063: PPUSH
27064: LD_STRING D8-Huck-3
27066: PPUSH
27067: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27071: LD_EXP 39
27075: PPUSH
27076: LD_STRING D8-JMM-3
27078: PPUSH
27079: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27083: LD_EXP 41
27087: PPUSH
27088: LD_STRING D8-Huck-4
27090: PPUSH
27091: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27095: LD_EXP 39
27099: PPUSH
27100: LD_STRING D8-JMM-4
27102: PPUSH
27103: CALL_OW 88
// end else
27107: GO 27219
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27109: LD_EXP 55
27113: PPUSH
27114: CALL_OW 310
27118: PPUSH
27119: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27123: LD_EXP 55
27127: PPUSH
27128: LD_STRING D8-Huck-1
27130: PPUSH
27131: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27135: LD_EXP 39
27139: PPUSH
27140: LD_STRING D8-JMM-1a
27142: PPUSH
27143: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27147: LD_EXP 55
27151: PPUSH
27152: LD_STRING D8-Huck-2
27154: PPUSH
27155: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27159: LD_EXP 39
27163: PPUSH
27164: LD_STRING D8-JMM-2
27166: PPUSH
27167: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27171: LD_EXP 55
27175: PPUSH
27176: LD_STRING D8-Huck-3
27178: PPUSH
27179: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27183: LD_EXP 39
27187: PPUSH
27188: LD_STRING D8-JMM-3
27190: PPUSH
27191: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27195: LD_EXP 55
27199: PPUSH
27200: LD_STRING D8-Huck-4
27202: PPUSH
27203: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27207: LD_EXP 39
27211: PPUSH
27212: LD_STRING D8-JMM-4
27214: PPUSH
27215: CALL_OW 88
// end ; DialogueOff ;
27219: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27223: LD_INT 25
27225: PPUSH
27226: LD_INT 1
27228: PPUSH
27229: LD_INT 1
27231: PPUSH
27232: CALL_OW 322
// end ;
27236: PPOPN 3
27238: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27239: LD_INT 1
27241: PPUSH
27242: LD_EXP 71
27246: PPUSH
27247: CALL_OW 292
27251: IFFALSE 27502
27253: GO 27255
27255: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27256: LD_EXP 71
27260: PPUSH
27261: CALL_OW 87
// DialogueOn ;
27265: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27269: LD_EXP 39
27273: PPUSH
27274: LD_STRING D10nB-JMM-1
27276: PPUSH
27277: CALL_OW 88
// if BurlakStatus = 1 then
27281: LD_EXP 9
27285: PUSH
27286: LD_INT 1
27288: EQUAL
27289: IFFALSE 27303
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27291: LD_EXP 70
27295: PPUSH
27296: LD_STRING D10nB-Vse-1a
27298: PPUSH
27299: CALL_OW 94
// end ; if BurlakStatus = 0 then
27303: LD_EXP 9
27307: PUSH
27308: LD_INT 0
27310: EQUAL
27311: IFFALSE 27325
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27313: LD_EXP 70
27317: PPUSH
27318: LD_STRING D10nB-Vse-1
27320: PPUSH
27321: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27325: LD_EXP 39
27329: PPUSH
27330: LD_STRING D10nB-JMM-2
27332: PPUSH
27333: CALL_OW 88
// if KappaStatus then
27337: LD_EXP 2
27341: IFFALSE 27355
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27343: LD_EXP 70
27347: PPUSH
27348: LD_STRING D10nB-Vse-5a
27350: PPUSH
27351: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27355: LD_EXP 2
27359: NOT
27360: PUSH
27361: LD_EXP 6
27365: PUSH
27366: LD_INT 0
27368: EQUAL
27369: AND
27370: IFFALSE 27498
// begin if JMMGirl = 1 then
27372: LD_EXP 7
27376: PUSH
27377: LD_INT 1
27379: EQUAL
27380: IFFALSE 27430
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27382: LD_EXP 70
27386: PPUSH
27387: LD_STRING D10nB-Vse-2
27389: PPUSH
27390: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27394: LD_EXP 39
27398: PPUSH
27399: LD_STRING D10nB-JMM-3
27401: PPUSH
27402: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27406: LD_EXP 70
27410: PPUSH
27411: LD_STRING D10nB-Vse-3
27413: PPUSH
27414: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27418: LD_EXP 39
27422: PPUSH
27423: LD_STRING D10nB-JMM-4
27425: PPUSH
27426: CALL_OW 88
// end ; if JMMGirl = 2 then
27430: LD_EXP 7
27434: PUSH
27435: LD_INT 2
27437: EQUAL
27438: IFFALSE 27464
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27440: LD_EXP 70
27444: PPUSH
27445: LD_STRING D10nB-Vse-4
27447: PPUSH
27448: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27452: LD_EXP 39
27456: PPUSH
27457: LD_STRING D10nB-JMM-5
27459: PPUSH
27460: CALL_OW 88
// end ; if JMMGirl = 3 then
27464: LD_EXP 7
27468: PUSH
27469: LD_INT 3
27471: EQUAL
27472: IFFALSE 27498
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27474: LD_EXP 70
27478: PPUSH
27479: LD_STRING D10nB-Vse-5
27481: PPUSH
27482: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27486: LD_EXP 39
27490: PPUSH
27491: LD_STRING D10nB-JMM-6
27493: PPUSH
27494: CALL_OW 88
// end ; end ; DialogueOff ;
27498: CALL_OW 7
// end ;
27502: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27503: LD_EXP 14
27507: PUSH
27508: LD_INT 115500
27510: GREATEREQUAL
27511: IFFALSE 27887
27513: GO 27515
27515: DISABLE
27516: LD_INT 0
27518: PPUSH
// begin missionStage := 10 ;
27519: LD_ADDR_EXP 15
27523: PUSH
27524: LD_INT 10
27526: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27527: LD_ADDR_VAR 0 1
27531: PUSH
27532: LD_INT 22
27534: PUSH
27535: LD_INT 1
27537: PUSH
27538: EMPTY
27539: LIST
27540: LIST
27541: PUSH
27542: LD_INT 23
27544: PUSH
27545: LD_INT 1
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PUSH
27552: LD_INT 26
27554: PUSH
27555: LD_INT 1
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 3
27564: PUSH
27565: LD_INT 25
27567: PUSH
27568: LD_INT 12
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 3
27581: PUSH
27582: LD_INT 25
27584: PUSH
27585: LD_INT 16
27587: PUSH
27588: EMPTY
27589: LIST
27590: LIST
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: PPUSH
27603: CALL_OW 69
27607: PUSH
27608: LD_EXP 39
27612: PUSH
27613: LD_EXP 60
27617: PUSH
27618: LD_EXP 41
27622: PUSH
27623: LD_EXP 55
27627: PUSH
27628: LD_EXP 42
27632: PUSH
27633: LD_EXP 43
27637: PUSH
27638: LD_EXP 44
27642: PUSH
27643: LD_EXP 45
27647: PUSH
27648: LD_EXP 46
27652: PUSH
27653: LD_EXP 47
27657: PUSH
27658: LD_EXP 48
27662: PUSH
27663: LD_EXP 49
27667: PUSH
27668: LD_EXP 50
27672: PUSH
27673: LD_EXP 51
27677: PUSH
27678: LD_EXP 52
27682: PUSH
27683: LD_EXP 53
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: DIFF
27706: ST_TO_ADDR
// if not tmp and Brown then
27707: LD_VAR 0 1
27711: NOT
27712: PUSH
27713: LD_EXP 47
27717: AND
27718: IFFALSE 27733
// tmp := [ Brown ] ;
27720: LD_ADDR_VAR 0 1
27724: PUSH
27725: LD_EXP 47
27729: PUSH
27730: EMPTY
27731: LIST
27732: ST_TO_ADDR
// DialogueOn ;
27733: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27737: LD_VAR 0 1
27741: PUSH
27742: LD_INT 1
27744: ARRAY
27745: PPUSH
27746: LD_STRING D11-Sol1-1
27748: PPUSH
27749: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27753: LD_EXP 64
27757: PPUSH
27758: LD_STRING D11-Pla-1
27760: PPUSH
27761: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27765: LD_EXP 65
27769: PPUSH
27770: LD_STRING D11-Kov-1
27772: PPUSH
27773: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27777: LD_EXP 64
27781: PPUSH
27782: LD_STRING D11-Pla-2
27784: PPUSH
27785: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27789: LD_VAR 0 1
27793: PUSH
27794: LD_INT 1
27796: ARRAY
27797: PPUSH
27798: LD_STRING D11-Sol1-2
27800: PPUSH
27801: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27805: LD_EXP 39
27809: PPUSH
27810: LD_STRING D11-JMM-2
27812: PPUSH
27813: CALL_OW 88
// DialogueOff ;
27817: CALL_OW 7
// allowBehemothConstruct := true ;
27821: LD_ADDR_EXP 25
27825: PUSH
27826: LD_INT 1
27828: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27829: LD_STRING M4
27831: PPUSH
27832: CALL_OW 337
// BuildBehemoths ;
27836: CALL 7735 0 0
// repeat wait ( 15 15$00 ) ;
27840: LD_INT 31500
27842: PPUSH
27843: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27847: LD_EXP 27
27851: IFFALSE 27855
// break ;
27853: GO 27887
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27855: LD_INT 267
27857: PPUSH
27858: CALL_OW 274
27862: PPUSH
27863: LD_INT 1
27865: PPUSH
27866: CALL_OW 275
27870: PUSH
27871: LD_INT 1000
27873: GREATEREQUAL
27874: IFFALSE 27880
// BuildBehemoths ;
27876: CALL 7735 0 0
// until not behemothBuilders ;
27880: LD_EXP 73
27884: NOT
27885: IFFALSE 27840
// end ;
27887: PPOPN 1
27889: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27890: LD_EXP 73
27894: NOT
27895: PUSH
27896: LD_EXP 28
27900: NOT
27901: AND
27902: PUSH
27903: LD_EXP 25
27907: AND
27908: IFFALSE 27928
27910: GO 27912
27912: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27913: LD_STRING M4a
27915: PPUSH
27916: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27920: LD_ADDR_EXP 27
27924: PUSH
27925: LD_INT 1
27927: ST_TO_ADDR
// end ;
27928: END
// every 0 0$1 trigger behemothDone do
27929: LD_EXP 28
27933: IFFALSE 27945
27935: GO 27937
27937: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27938: LD_STRING M4b
27940: PPUSH
27941: CALL_OW 337
27945: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27946: LD_EXP 29
27950: NOT
27951: IFFALSE 28147
27953: GO 27955
27955: DISABLE
27956: LD_INT 0
27958: PPUSH
27959: PPUSH
// begin enable ;
27960: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27961: LD_ADDR_VAR 0 1
27965: PUSH
27966: LD_INT 3
27968: PPUSH
27969: CALL 103169 0 1
27973: ST_TO_ADDR
// if not tmp and not behemothDone then
27974: LD_VAR 0 1
27978: NOT
27979: PUSH
27980: LD_EXP 28
27984: NOT
27985: AND
27986: IFFALSE 28022
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27988: LD_ADDR_VAR 0 1
27992: PUSH
27993: LD_INT 22
27995: PUSH
27996: LD_INT 3
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 30
28005: PUSH
28006: LD_INT 37
28008: PUSH
28009: EMPTY
28010: LIST
28011: LIST
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PPUSH
28017: CALL_OW 69
28021: ST_TO_ADDR
// if not tmp then
28022: LD_VAR 0 1
28026: NOT
28027: IFFALSE 28031
// exit ;
28029: GO 28147
// for i in tmp do
28031: LD_ADDR_VAR 0 2
28035: PUSH
28036: LD_VAR 0 1
28040: PUSH
28041: FOR_IN
28042: IFFALSE 28145
// if See ( 1 , i ) then
28044: LD_INT 1
28046: PPUSH
28047: LD_VAR 0 2
28051: PPUSH
28052: CALL_OW 292
28056: IFFALSE 28143
// begin if GetType ( i ) = unit_building then
28058: LD_VAR 0 2
28062: PPUSH
28063: CALL_OW 247
28067: PUSH
28068: LD_INT 3
28070: EQUAL
28071: IFFALSE 28109
// begin CenterNowOnUnits ( i ) ;
28073: LD_VAR 0 2
28077: PPUSH
28078: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28082: LD_EXP 39
28086: PPUSH
28087: LD_STRING D17a-JMM-1
28089: PPUSH
28090: CALL_OW 88
// seeBehemoth := true ;
28094: LD_ADDR_EXP 29
28098: PUSH
28099: LD_INT 1
28101: ST_TO_ADDR
// disable ;
28102: DISABLE
// exit ;
28103: POP
28104: POP
28105: GO 28147
// end else
28107: GO 28143
// begin CenterNowOnUnits ( i ) ;
28109: LD_VAR 0 2
28113: PPUSH
28114: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28118: LD_EXP 39
28122: PPUSH
28123: LD_STRING D17b-JMM-1
28125: PPUSH
28126: CALL_OW 88
// seeBehemoth := true ;
28130: LD_ADDR_EXP 29
28134: PUSH
28135: LD_INT 1
28137: ST_TO_ADDR
// disable ;
28138: DISABLE
// exit ;
28139: POP
28140: POP
28141: GO 28147
// end ; end ;
28143: GO 28041
28145: POP
28146: POP
// end ;
28147: PPOPN 2
28149: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28150: LD_EXP 14
28154: PUSH
28155: LD_INT 123200
28157: GREATEREQUAL
28158: IFFALSE 29334
28160: GO 28162
28162: DISABLE
28163: LD_INT 0
28165: PPUSH
28166: PPUSH
28167: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28168: LD_INT 2
28170: PPUSH
28171: LD_INT 23
28173: PUSH
28174: LD_INT 3
28176: PUSH
28177: LD_INT 3
28179: PUSH
28180: LD_INT 48
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: LIST
28187: LIST
28188: PUSH
28189: EMPTY
28190: LIST
28191: PPUSH
28192: CALL 59344 0 2
// repeat wait ( 0 0$1 ) ;
28196: LD_INT 35
28198: PPUSH
28199: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28203: LD_INT 22
28205: PUSH
28206: LD_INT 3
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PUSH
28213: LD_INT 34
28215: PUSH
28216: LD_INT 48
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PPUSH
28227: CALL_OW 69
28231: IFFALSE 28196
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28233: LD_ADDR_VAR 0 1
28237: PUSH
28238: LD_INT 22
28240: PUSH
28241: LD_INT 3
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 34
28250: PUSH
28251: LD_INT 48
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PPUSH
28262: CALL_OW 69
28266: PUSH
28267: LD_INT 1
28269: ARRAY
28270: ST_TO_ADDR
// missionStage := 12 ;
28271: LD_ADDR_EXP 15
28275: PUSH
28276: LD_INT 12
28278: ST_TO_ADDR
// platonovHasBomb := true ;
28279: LD_ADDR_EXP 30
28283: PUSH
28284: LD_INT 1
28286: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28287: LD_VAR 0 1
28291: PPUSH
28292: LD_INT 181
28294: PPUSH
28295: LD_INT 86
28297: PPUSH
28298: CALL_OW 171
// AddComHold ( bomb ) ;
28302: LD_VAR 0 1
28306: PPUSH
28307: CALL_OW 200
// wait ( 0 0$10 ) ;
28311: LD_INT 350
28313: PPUSH
28314: CALL_OW 67
// DialogueOn ;
28318: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28322: LD_EXP 64
28326: PPUSH
28327: LD_STRING D15-Pla-1
28329: PPUSH
28330: CALL_OW 94
// dec = Query ( Q15a ) ;
28334: LD_ADDR_VAR 0 2
28338: PUSH
28339: LD_STRING Q15a
28341: PPUSH
28342: CALL_OW 97
28346: ST_TO_ADDR
// if dec = 1 then
28347: LD_VAR 0 2
28351: PUSH
28352: LD_INT 1
28354: EQUAL
28355: IFFALSE 28378
// begin Say ( JMM , D15a-JMM-1 ) ;
28357: LD_EXP 39
28361: PPUSH
28362: LD_STRING D15a-JMM-1
28364: PPUSH
28365: CALL_OW 88
// YouLost ( Surrender ) ;
28369: LD_STRING Surrender
28371: PPUSH
28372: CALL_OW 104
// exit ;
28376: GO 29334
// end ; if dec = 2 then
28378: LD_VAR 0 2
28382: PUSH
28383: LD_INT 2
28385: EQUAL
28386: IFFALSE 28455
// begin Say ( JMM , D15b-JMM-1 ) ;
28388: LD_EXP 39
28392: PPUSH
28393: LD_STRING D15b-JMM-1
28395: PPUSH
28396: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28400: LD_EXP 64
28404: PPUSH
28405: LD_STRING D15b-Pla-1
28407: PPUSH
28408: CALL_OW 94
// DialogueOff ;
28412: CALL_OW 7
// wait ( 3 3$00 ) ;
28416: LD_INT 6300
28418: PPUSH
28419: CALL_OW 67
// DialogueOn ;
28423: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28427: LD_EXP 39
28431: PPUSH
28432: LD_STRING D15d-JMM-1a
28434: PPUSH
28435: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28439: LD_EXP 64
28443: PPUSH
28444: LD_STRING D15d-Pla-1
28446: PPUSH
28447: CALL_OW 94
// DialogueOff ;
28451: CALL_OW 7
// end ; if dec = 3 then
28455: LD_VAR 0 2
28459: PUSH
28460: LD_INT 3
28462: EQUAL
28463: IFFALSE 28517
// begin Say ( JMM , D15c-JMM-1 ) ;
28465: LD_EXP 39
28469: PPUSH
28470: LD_STRING D15c-JMM-1
28472: PPUSH
28473: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28477: LD_EXP 64
28481: PPUSH
28482: LD_STRING D15c-Pla-1
28484: PPUSH
28485: CALL_OW 94
// DialogueOff ;
28489: CALL_OW 7
// wait ( 0 0$15 ) ;
28493: LD_INT 525
28495: PPUSH
28496: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28500: LD_VAR 0 1
28504: PPUSH
28505: LD_INT 60
28507: PPUSH
28508: LD_INT 95
28510: PPUSH
28511: CALL_OW 116
// exit ;
28515: GO 29334
// end ; if dec = 4 then
28517: LD_VAR 0 2
28521: PUSH
28522: LD_INT 4
28524: EQUAL
28525: IFFALSE 28555
// begin Say ( JMM , D15d-JMM-1 ) ;
28527: LD_EXP 39
28531: PPUSH
28532: LD_STRING D15d-JMM-1
28534: PPUSH
28535: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28539: LD_EXP 64
28543: PPUSH
28544: LD_STRING D15d-Pla-1
28546: PPUSH
28547: CALL_OW 94
// DialogueOff ;
28551: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28555: LD_EXP 62
28559: PPUSH
28560: CALL_OW 302
28564: PUSH
28565: LD_EXP 62
28569: PPUSH
28570: CALL_OW 255
28574: PUSH
28575: LD_INT 1
28577: EQUAL
28578: AND
28579: PUSH
28580: LD_INT 22
28582: PUSH
28583: LD_INT 1
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 34
28592: PUSH
28593: LD_INT 8
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: EMPTY
28601: LIST
28602: LIST
28603: PPUSH
28604: CALL_OW 69
28608: NOT
28609: AND
28610: IFFALSE 29235
// begin SetSide ( Friend , 8 ) ;
28612: LD_EXP 62
28616: PPUSH
28617: LD_INT 8
28619: PPUSH
28620: CALL_OW 235
// if IsInUnit ( Friend ) then
28624: LD_EXP 62
28628: PPUSH
28629: CALL_OW 310
28633: IFFALSE 28644
// ComExitBuilding ( Friend ) ;
28635: LD_EXP 62
28639: PPUSH
28640: CALL_OW 122
// if IsDriver ( Friend ) then
28644: LD_EXP 62
28648: PPUSH
28649: CALL 100717 0 1
28653: IFFALSE 28664
// ComExitVehicle ( Friend ) ;
28655: LD_EXP 62
28659: PPUSH
28660: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28664: LD_EXP 62
28668: PPUSH
28669: LD_INT 9
28671: PPUSH
28672: LD_INT 2
28674: PPUSH
28675: CALL_OW 171
// wait ( 0 0$05 ) ;
28679: LD_INT 175
28681: PPUSH
28682: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28686: LD_EXP 62
28690: PPUSH
28691: CALL_OW 87
// DialogueOn ;
28695: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28699: LD_EXP 39
28703: PPUSH
28704: LD_STRING D16-JMM-1
28706: PPUSH
28707: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28711: LD_EXP 62
28715: PPUSH
28716: LD_STRING D16-Friend-1
28718: PPUSH
28719: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28723: LD_EXP 39
28727: PPUSH
28728: LD_STRING D16-JMM-2
28730: PPUSH
28731: CALL_OW 88
// DialogueOff ;
28735: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28739: LD_EXP 62
28743: PPUSH
28744: LD_INT 1
28746: PPUSH
28747: CALL_OW 235
// ComHold ( Friend ) ;
28751: LD_EXP 62
28755: PPUSH
28756: CALL_OW 140
// wait ( 0 0$20 ) ;
28760: LD_INT 700
28762: PPUSH
28763: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28767: LD_EXP 62
28771: PPUSH
28772: LD_INT 9
28774: PPUSH
28775: LD_INT 2
28777: PPUSH
28778: CALL_OW 297
28782: PUSH
28783: LD_INT 30
28785: LESS
28786: IFFALSE 28855
// begin SetSide ( Friend , 8 ) ;
28788: LD_EXP 62
28792: PPUSH
28793: LD_INT 8
28795: PPUSH
28796: CALL_OW 235
// if IsInUnit ( Friend ) then
28800: LD_EXP 62
28804: PPUSH
28805: CALL_OW 310
28809: IFFALSE 28820
// ComExitBuilding ( Friend ) ;
28811: LD_EXP 62
28815: PPUSH
28816: CALL_OW 122
// if IsDriver ( Friend ) then
28820: LD_EXP 62
28824: PPUSH
28825: CALL 100717 0 1
28829: IFFALSE 28840
// ComExitVehicle ( Friend ) ;
28831: LD_EXP 62
28835: PPUSH
28836: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28840: LD_EXP 62
28844: PPUSH
28845: LD_INT 9
28847: PPUSH
28848: LD_INT 2
28850: PPUSH
28851: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28855: LD_INT 1050
28857: PPUSH
28858: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28862: LD_INT 22
28864: PUSH
28865: LD_INT 1
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 34
28874: PUSH
28875: LD_INT 8
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PPUSH
28886: CALL_OW 69
28890: NOT
28891: IFFALSE 29213
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28893: LD_ADDR_VAR 0 3
28897: PUSH
28898: LD_INT 22
28900: PUSH
28901: LD_INT 1
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 26
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 3
28920: PUSH
28921: LD_INT 25
28923: PUSH
28924: LD_INT 12
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 25
28933: PUSH
28934: LD_INT 16
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: LIST
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: LIST
28950: PPUSH
28951: CALL_OW 69
28955: PUSH
28956: LD_EXP 39
28960: PUSH
28961: LD_EXP 41
28965: PUSH
28966: LD_EXP 55
28970: PUSH
28971: LD_EXP 42
28975: PUSH
28976: LD_EXP 43
28980: PUSH
28981: LD_EXP 44
28985: PUSH
28986: LD_EXP 45
28990: PUSH
28991: LD_EXP 46
28995: PUSH
28996: LD_EXP 47
29000: PUSH
29001: LD_EXP 48
29005: PUSH
29006: LD_EXP 49
29010: PUSH
29011: LD_EXP 50
29015: PUSH
29016: LD_EXP 51
29020: PUSH
29021: LD_EXP 52
29025: PUSH
29026: LD_EXP 53
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: DIFF
29048: ST_TO_ADDR
// DialogueOn ;
29049: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29053: LD_EXP 64
29057: PPUSH
29058: LD_STRING D16a-Pla-1
29060: PPUSH
29061: CALL_OW 94
// if Stevens then
29065: LD_EXP 41
29069: IFFALSE 29085
// Say ( Stevens , D16a-Huck-1 ) else
29071: LD_EXP 41
29075: PPUSH
29076: LD_STRING D16a-Huck-1
29078: PPUSH
29079: CALL_OW 88
29083: GO 29127
// if Baker then
29085: LD_EXP 55
29089: IFFALSE 29105
// Say ( Baker , D16a-Huck-1 ) else
29091: LD_EXP 55
29095: PPUSH
29096: LD_STRING D16a-Huck-1
29098: PPUSH
29099: CALL_OW 88
29103: GO 29127
// if tmp then
29105: LD_VAR 0 3
29109: IFFALSE 29127
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29111: LD_VAR 0 3
29115: PUSH
29116: LD_INT 1
29118: ARRAY
29119: PPUSH
29120: LD_STRING D16a-Sol1-1
29122: PPUSH
29123: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29127: LD_EXP 62
29131: PPUSH
29132: CALL_OW 255
29136: PUSH
29137: LD_INT 8
29139: EQUAL
29140: IFFALSE 29156
// Say ( JMM , D16a-JMM-1 ) else
29142: LD_EXP 39
29146: PPUSH
29147: LD_STRING D16a-JMM-1
29149: PPUSH
29150: CALL_OW 88
29154: GO 29192
// begin Say ( JMM , D16a-JMM-1a ) ;
29156: LD_EXP 39
29160: PPUSH
29161: LD_STRING D16a-JMM-1a
29163: PPUSH
29164: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29168: LD_EXP 62
29172: PPUSH
29173: LD_STRING D16a-Friend-1
29175: PPUSH
29176: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29180: LD_EXP 62
29184: PPUSH
29185: LD_INT 3
29187: PPUSH
29188: CALL_OW 235
// end ; DialogueOff ;
29192: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29196: LD_VAR 0 1
29200: PPUSH
29201: LD_INT 60
29203: PPUSH
29204: LD_INT 95
29206: PPUSH
29207: CALL_OW 116
// end else
29211: GO 29233
// begin DialogueOn ;
29213: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29217: LD_EXP 64
29221: PPUSH
29222: LD_STRING D16c-Pla-
29224: PPUSH
29225: CALL_OW 94
// DialogueOff ;
29229: CALL_OW 7
// end ; end else
29233: GO 29334
// begin wait ( 3 3$00 ) ;
29235: LD_INT 6300
29237: PPUSH
29238: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29242: LD_INT 22
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 34
29254: PUSH
29255: LD_INT 8
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PPUSH
29266: CALL_OW 69
29270: NOT
29271: IFFALSE 29314
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29273: LD_EXP 64
29277: PPUSH
29278: LD_STRING D16b-Pla-1
29280: PPUSH
29281: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29285: LD_EXP 39
29289: PPUSH
29290: LD_STRING D16b-JMM-
29292: PPUSH
29293: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29297: LD_VAR 0 1
29301: PPUSH
29302: LD_INT 60
29304: PPUSH
29305: LD_INT 95
29307: PPUSH
29308: CALL_OW 116
// end else
29312: GO 29334
// begin DialogueOn ;
29314: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29318: LD_EXP 64
29322: PPUSH
29323: LD_STRING D16c-Pla-
29325: PPUSH
29326: CALL_OW 94
// DialogueOff ;
29330: CALL_OW 7
// end ; end ; end ;
29334: PPOPN 3
29336: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29337: LD_EXP 14
29341: PUSH
29342: LD_INT 126000
29344: GREATEREQUAL
29345: PUSH
29346: LD_EXP 23
29350: NOT
29351: AND
29352: PUSH
29353: LD_EXP 74
29357: PPUSH
29358: CALL_OW 302
29362: AND
29363: IFFALSE 29721
29365: GO 29367
29367: DISABLE
29368: LD_INT 0
29370: PPUSH
// begin missionStage = 11 ;
29371: LD_ADDR_EXP 15
29375: PUSH
29376: LD_INT 11
29378: ST_TO_ADDR
// DialogueOn ;
29379: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29383: LD_EXP 74
29387: PPUSH
29388: LD_STRING D9-Roth-1
29390: PPUSH
29391: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29395: LD_EXP 39
29399: PPUSH
29400: LD_STRING D9-JMM-1
29402: PPUSH
29403: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29407: LD_EXP 74
29411: PPUSH
29412: LD_STRING D9-Roth-2
29414: PPUSH
29415: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29419: LD_EXP 74
29423: PPUSH
29424: LD_STRING D9-Roth-2a
29426: PPUSH
29427: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29431: LD_EXP 64
29435: PPUSH
29436: LD_STRING D9-Pla-2
29438: PPUSH
29439: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29443: LD_EXP 74
29447: PPUSH
29448: LD_STRING D9-Roth-3
29450: PPUSH
29451: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29455: LD_EXP 64
29459: PPUSH
29460: LD_STRING D9-Pla-3
29462: PPUSH
29463: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29467: LD_EXP 74
29471: PPUSH
29472: LD_STRING D9-Roth-4
29474: PPUSH
29475: CALL_OW 94
// dec = Query ( Q9 ) ;
29479: LD_ADDR_VAR 0 1
29483: PUSH
29484: LD_STRING Q9
29486: PPUSH
29487: CALL_OW 97
29491: ST_TO_ADDR
// if dec = 1 then
29492: LD_VAR 0 1
29496: PUSH
29497: LD_INT 1
29499: EQUAL
29500: IFFALSE 29514
// SayRadio ( Roth , D9a-Roth-1 ) ;
29502: LD_EXP 74
29506: PPUSH
29507: LD_STRING D9a-Roth-1
29509: PPUSH
29510: CALL_OW 94
// if dec = 2 then
29514: LD_VAR 0 1
29518: PUSH
29519: LD_INT 2
29521: EQUAL
29522: IFFALSE 29548
// begin Say ( JMM , D9b-JMM-1 ) ;
29524: LD_EXP 39
29528: PPUSH
29529: LD_STRING D9b-JMM-1
29531: PPUSH
29532: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29536: LD_EXP 74
29540: PPUSH
29541: LD_STRING D9b-Roth-1
29543: PPUSH
29544: CALL_OW 94
// end ; if dec = 3 then
29548: LD_VAR 0 1
29552: PUSH
29553: LD_INT 3
29555: EQUAL
29556: IFFALSE 29618
// begin Say ( JMM , D9c-JMM-1 ) ;
29558: LD_EXP 39
29562: PPUSH
29563: LD_STRING D9c-JMM-1
29565: PPUSH
29566: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29570: LD_EXP 74
29574: PPUSH
29575: LD_STRING D9c-Roth-1
29577: PPUSH
29578: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29582: LD_EXP 39
29586: PPUSH
29587: LD_STRING D9c-JMM-2
29589: PPUSH
29590: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29594: LD_EXP 74
29598: PPUSH
29599: LD_STRING D9c-Roth-2
29601: PPUSH
29602: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29606: LD_EXP 39
29610: PPUSH
29611: LD_STRING D9c-JMM-3
29613: PPUSH
29614: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29618: LD_EXP 74
29622: PPUSH
29623: LD_STRING D9c-Roth-3
29625: PPUSH
29626: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29630: LD_EXP 74
29634: PPUSH
29635: LD_STRING D9cont-Roth-1
29637: PPUSH
29638: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29642: LD_EXP 39
29646: PPUSH
29647: LD_STRING D9cont-JMM-1
29649: PPUSH
29650: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29654: LD_EXP 74
29658: PPUSH
29659: LD_STRING D9cont-Roth-2
29661: PPUSH
29662: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29666: LD_EXP 39
29670: PPUSH
29671: LD_STRING D9cont-JMM-2
29673: PPUSH
29674: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29678: LD_EXP 74
29682: PPUSH
29683: LD_STRING D9cont-Roth-3
29685: PPUSH
29686: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29690: LD_EXP 39
29694: PPUSH
29695: LD_STRING D9cont-JMM-3
29697: PPUSH
29698: CALL_OW 88
// DialogueOff ;
29702: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29706: LD_STRING M3
29708: PPUSH
29709: CALL_OW 337
// allianceActive := true ;
29713: LD_ADDR_EXP 31
29717: PUSH
29718: LD_INT 1
29720: ST_TO_ADDR
// end ;
29721: PPOPN 1
29723: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29724: LD_INT 1
29726: PPUSH
29727: LD_INT 126
29729: PPUSH
29730: CALL_OW 292
29734: PUSH
29735: LD_EXP 64
29739: PPUSH
29740: CALL_OW 310
29744: AND
29745: IFFALSE 29825
29747: GO 29749
29749: DISABLE
29750: LD_INT 0
29752: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29753: LD_EXP 64
29757: PPUSH
29758: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29762: LD_ADDR_VAR 0 1
29766: PUSH
29767: LD_INT 4
29769: PPUSH
29770: LD_INT 22
29772: PUSH
29773: LD_INT 1
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PPUSH
29780: CALL_OW 70
29784: PPUSH
29785: LD_EXP 64
29789: PPUSH
29790: CALL_OW 74
29794: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29795: LD_EXP 64
29799: PPUSH
29800: LD_VAR 0 1
29804: PUSH
29805: LD_INT 1
29807: ARRAY
29808: PPUSH
29809: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29813: LD_EXP 64
29817: PPUSH
29818: LD_STRING D18-Pla-1
29820: PPUSH
29821: CALL_OW 88
// end ;
29825: PPOPN 1
29827: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29828: LD_EXP 64
29832: PPUSH
29833: CALL_OW 301
29837: PUSH
29838: LD_EXP 67
29842: PPUSH
29843: CALL_OW 301
29847: AND
29848: PUSH
29849: LD_INT 22
29851: PUSH
29852: LD_INT 3
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 21
29861: PUSH
29862: LD_INT 1
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: LD_INT 50
29871: PUSH
29872: EMPTY
29873: LIST
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: LIST
29879: PPUSH
29880: CALL_OW 69
29884: PUSH
29885: LD_INT 7
29887: PUSH
29888: LD_INT 8
29890: PUSH
29891: LD_INT 9
29893: PUSH
29894: LD_INT 10
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: PUSH
29903: LD_OWVAR 67
29907: ARRAY
29908: LESS
29909: AND
29910: IFFALSE 30681
29912: GO 29914
29914: DISABLE
29915: LD_INT 0
29917: PPUSH
29918: PPUSH
29919: PPUSH
29920: PPUSH
// begin MC_Kill ( 2 ) ;
29921: LD_INT 2
29923: PPUSH
29924: CALL 35370 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29928: LD_INT 1
29930: PPUSH
29931: LD_INT 3
29933: PPUSH
29934: LD_INT 1
29936: PPUSH
29937: LD_INT 1
29939: PPUSH
29940: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29944: LD_ADDR_VAR 0 1
29948: PUSH
29949: LD_INT 22
29951: PUSH
29952: LD_INT 3
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 21
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 24
29971: PUSH
29972: LD_INT 900
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: LIST
29983: PPUSH
29984: CALL_OW 69
29988: PUSH
29989: FOR_IN
29990: IFFALSE 30021
// if GetSex ( i ) = sex_male then
29992: LD_VAR 0 1
29996: PPUSH
29997: CALL_OW 258
30001: PUSH
30002: LD_INT 1
30004: EQUAL
30005: IFFALSE 30019
// begin tmp = i ;
30007: LD_ADDR_VAR 0 2
30011: PUSH
30012: LD_VAR 0 1
30016: ST_TO_ADDR
// break ;
30017: GO 30021
// end ;
30019: GO 29989
30021: POP
30022: POP
// if tmp = 0 then
30023: LD_VAR 0 2
30027: PUSH
30028: LD_INT 0
30030: EQUAL
30031: IFFALSE 30085
// begin uc_side = 3 ;
30033: LD_ADDR_OWVAR 20
30037: PUSH
30038: LD_INT 3
30040: ST_TO_ADDR
// uc_nation = 3 ;
30041: LD_ADDR_OWVAR 21
30045: PUSH
30046: LD_INT 3
30048: ST_TO_ADDR
// hc_name =  ;
30049: LD_ADDR_OWVAR 26
30053: PUSH
30054: LD_STRING 
30056: ST_TO_ADDR
// hc_gallery =  ;
30057: LD_ADDR_OWVAR 33
30061: PUSH
30062: LD_STRING 
30064: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30065: LD_INT 1
30067: PPUSH
30068: LD_INT 10
30070: PPUSH
30071: CALL_OW 381
// tmp = CreateHuman ;
30075: LD_ADDR_VAR 0 2
30079: PUSH
30080: CALL_OW 44
30084: ST_TO_ADDR
// end ; DialogueOn ;
30085: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30089: LD_VAR 0 2
30093: PPUSH
30094: LD_STRING DSurrenderRussians-RSol1-1a
30096: PPUSH
30097: CALL_OW 94
// DialogueOff ;
30101: CALL_OW 7
// russianDestroyed := true ;
30105: LD_ADDR_EXP 21
30109: PUSH
30110: LD_INT 1
30112: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30113: LD_INT 22
30115: PUSH
30116: LD_INT 3
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 21
30125: PUSH
30126: LD_INT 1
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PPUSH
30137: CALL_OW 69
30141: PPUSH
30142: CALL_OW 122
// wait ( 0 0$1 ) ;
30146: LD_INT 35
30148: PPUSH
30149: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30153: LD_INT 22
30155: PUSH
30156: LD_INT 3
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PUSH
30163: LD_INT 21
30165: PUSH
30166: LD_INT 1
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PPUSH
30177: CALL_OW 69
30181: PPUSH
30182: LD_INT 25
30184: PPUSH
30185: CALL_OW 173
// wait ( 0 0$10 ) ;
30189: LD_INT 350
30191: PPUSH
30192: CALL_OW 67
// PrepareOmarInvasion ;
30196: CALL 13977 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30200: LD_ADDR_VAR 0 2
30204: PUSH
30205: LD_EXP 92
30209: PPUSH
30210: CALL_OW 250
30214: PUSH
30215: LD_EXP 92
30219: PPUSH
30220: CALL_OW 251
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30229: LD_VAR 0 2
30233: PUSH
30234: LD_INT 1
30236: ARRAY
30237: PPUSH
30238: LD_VAR 0 2
30242: PUSH
30243: LD_INT 2
30245: ARRAY
30246: PPUSH
30247: LD_INT 1
30249: PPUSH
30250: LD_INT 8
30252: NEG
30253: PPUSH
30254: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30258: LD_EXP 92
30262: PPUSH
30263: CALL_OW 87
// DialogueOn ;
30267: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30271: LD_EXP 39
30275: PPUSH
30276: LD_STRING D19-JMM-1
30278: PPUSH
30279: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30283: LD_ADDR_VAR 0 3
30287: PUSH
30288: LD_INT 22
30290: PUSH
30291: LD_INT 1
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: LD_INT 26
30300: PUSH
30301: LD_INT 1
30303: PUSH
30304: EMPTY
30305: LIST
30306: LIST
30307: PUSH
30308: LD_INT 2
30310: PUSH
30311: LD_INT 25
30313: PUSH
30314: LD_INT 1
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 25
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 25
30333: PUSH
30334: LD_INT 3
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 25
30343: PUSH
30344: LD_INT 4
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 25
30353: PUSH
30354: LD_INT 5
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 25
30363: PUSH
30364: LD_INT 8
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: EMPTY
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: LIST
30384: PPUSH
30385: CALL_OW 69
30389: PUSH
30390: LD_EXP 39
30394: PUSH
30395: LD_EXP 40
30399: PUSH
30400: LD_EXP 41
30404: PUSH
30405: LD_EXP 42
30409: PUSH
30410: LD_EXP 43
30414: PUSH
30415: LD_EXP 44
30419: PUSH
30420: LD_EXP 45
30424: PUSH
30425: LD_EXP 46
30429: PUSH
30430: LD_EXP 47
30434: PUSH
30435: LD_EXP 48
30439: PUSH
30440: LD_EXP 49
30444: PUSH
30445: LD_EXP 50
30449: PUSH
30450: LD_EXP 51
30454: PUSH
30455: LD_EXP 52
30459: PUSH
30460: LD_EXP 53
30464: PUSH
30465: LD_EXP 54
30469: PUSH
30470: LD_EXP 55
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: DIFF
30494: ST_TO_ADDR
// if tmp2 then
30495: LD_VAR 0 3
30499: IFFALSE 30517
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30501: LD_VAR 0 3
30505: PUSH
30506: LD_INT 1
30508: ARRAY
30509: PPUSH
30510: LD_STRING D19-Sol1-1
30512: PPUSH
30513: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30517: LD_EXP 39
30521: PPUSH
30522: LD_STRING D19-JMM-2
30524: PPUSH
30525: CALL_OW 88
// DialogueOff ;
30529: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30533: LD_VAR 0 2
30537: PUSH
30538: LD_INT 1
30540: ARRAY
30541: PPUSH
30542: LD_VAR 0 2
30546: PUSH
30547: LD_INT 2
30549: ARRAY
30550: PPUSH
30551: LD_INT 1
30553: PPUSH
30554: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30558: LD_STRING M5
30560: PPUSH
30561: CALL_OW 337
// omarOnMotherLode := false ;
30565: LD_ADDR_VAR 0 4
30569: PUSH
30570: LD_INT 0
30572: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30573: LD_INT 35
30575: PPUSH
30576: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30580: LD_EXP 92
30584: PPUSH
30585: LD_INT 215
30587: PPUSH
30588: LD_INT 100
30590: PPUSH
30591: CALL_OW 297
30595: PUSH
30596: LD_INT 10
30598: LESS
30599: PUSH
30600: LD_VAR 0 4
30604: NOT
30605: AND
30606: IFFALSE 30640
// begin omarOnMotherLode := true ;
30608: LD_ADDR_VAR 0 4
30612: PUSH
30613: LD_INT 1
30615: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30616: LD_EXP 39
30620: PPUSH
30621: LD_STRING D19b-JMM-1
30623: PPUSH
30624: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30628: LD_EXP 92
30632: PPUSH
30633: LD_STRING DOmarContam-Omar-1
30635: PPUSH
30636: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30640: LD_EXP 92
30644: PPUSH
30645: CALL_OW 301
30649: IFFALSE 30573
// Say ( JMM , D19a-JMM-1 ) ;
30651: LD_EXP 39
30655: PPUSH
30656: LD_STRING D19a-JMM-1
30658: PPUSH
30659: CALL_OW 88
// if Heike then
30663: LD_EXP 93
30667: IFFALSE 30681
// Say ( Heike , D19a-Hke-1 ) ;
30669: LD_EXP 93
30673: PPUSH
30674: LD_STRING D19a-Hke-1
30676: PPUSH
30677: CALL_OW 88
// end ;
30681: PPOPN 4
30683: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30684: LD_INT 22
30686: PUSH
30687: LD_INT 3
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 21
30696: PUSH
30697: LD_INT 1
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PPUSH
30708: CALL_OW 69
30712: PUSH
30713: LD_EXP 21
30717: AND
30718: IFFALSE 30786
30720: GO 30722
30722: DISABLE
30723: LD_INT 0
30725: PPUSH
30726: PPUSH
// begin enable ;
30727: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30728: LD_ADDR_VAR 0 2
30732: PUSH
30733: LD_INT 25
30735: PPUSH
30736: LD_INT 22
30738: PUSH
30739: LD_INT 3
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PPUSH
30746: CALL_OW 70
30750: ST_TO_ADDR
// if not tmp then
30751: LD_VAR 0 2
30755: NOT
30756: IFFALSE 30760
// exit ;
30758: GO 30786
// for i in tmp do
30760: LD_ADDR_VAR 0 1
30764: PUSH
30765: LD_VAR 0 2
30769: PUSH
30770: FOR_IN
30771: IFFALSE 30784
// RemoveUnit ( i ) ;
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 64
30782: GO 30770
30784: POP
30785: POP
// end ;
30786: PPOPN 2
30788: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30789: LD_INT 22
30791: PUSH
30792: LD_INT 7
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 21
30801: PUSH
30802: LD_INT 1
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PPUSH
30813: CALL_OW 69
30817: PUSH
30818: LD_INT 6
30820: LESS
30821: IFFALSE 31289
30823: GO 30825
30825: DISABLE
30826: LD_INT 0
30828: PPUSH
30829: PPUSH
// begin MC_Kill ( 1 ) ;
30830: LD_INT 1
30832: PPUSH
30833: CALL 35370 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30837: LD_INT 7
30839: PPUSH
30840: LD_INT 1
30842: PPUSH
30843: LD_INT 1
30845: PPUSH
30846: LD_INT 1
30848: PPUSH
30849: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30853: LD_ADDR_VAR 0 1
30857: PUSH
30858: LD_INT 22
30860: PUSH
30861: LD_INT 7
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 26
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PPUSH
30882: CALL_OW 69
30886: PUSH
30887: LD_EXP 74
30891: DIFF
30892: ST_TO_ADDR
// if tmp then
30893: LD_VAR 0 1
30897: IFFALSE 30915
// tmp := tmp [ 1 ] else
30899: LD_ADDR_VAR 0 1
30903: PUSH
30904: LD_VAR 0 1
30908: PUSH
30909: LD_INT 1
30911: ARRAY
30912: ST_TO_ADDR
30913: GO 30951
// begin uc_side := 7 ;
30915: LD_ADDR_OWVAR 20
30919: PUSH
30920: LD_INT 7
30922: ST_TO_ADDR
// uc_nation := 1 ;
30923: LD_ADDR_OWVAR 21
30927: PUSH
30928: LD_INT 1
30930: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30931: LD_INT 1
30933: PPUSH
30934: LD_INT 8
30936: PPUSH
30937: CALL_OW 384
// tmp := CreateHuman ;
30941: LD_ADDR_VAR 0 1
30945: PUSH
30946: CALL_OW 44
30950: ST_TO_ADDR
// end ; DialogueOn ;
30951: CALL_OW 6
// if IsOK ( Roth ) then
30955: LD_EXP 74
30959: PPUSH
30960: CALL_OW 302
30964: IFFALSE 30978
// Say ( JMM , DAb-JMM-1 ) ;
30966: LD_EXP 39
30970: PPUSH
30971: LD_STRING DAb-JMM-1
30973: PPUSH
30974: CALL_OW 88
// if IsOK ( Roth ) then
30978: LD_EXP 74
30982: PPUSH
30983: CALL_OW 302
30987: IFFALSE 31011
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30989: LD_EXP 74
30993: PPUSH
30994: LD_STRING DSurrenderAlliance-Roth-1
30996: PPUSH
30997: CALL_OW 88
// RothCaptured := true ;
31001: LD_ADDR_EXP 33
31005: PUSH
31006: LD_INT 1
31008: ST_TO_ADDR
// end else
31009: GO 31023
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
31011: LD_VAR 0 1
31015: PPUSH
31016: LD_STRING DSurrenderAlliance-Sci1-1
31018: PPUSH
31019: CALL_OW 88
// DialogueOff ;
31023: CALL_OW 7
// allianceDestroyed := true ;
31027: LD_ADDR_EXP 23
31031: PUSH
31032: LD_INT 1
31034: ST_TO_ADDR
// if capturedUnit = 0 then
31035: LD_EXP 34
31039: PUSH
31040: LD_INT 0
31042: EQUAL
31043: IFFALSE 31052
// SetAchievement ( ACH_ALLIANCE ) ;
31045: LD_STRING ACH_ALLIANCE
31047: PPUSH
31048: CALL_OW 543
// if trueAmericans then
31052: LD_EXP 35
31056: IFFALSE 31132
// begin if trueAmericans = 1 then
31058: LD_EXP 35
31062: PUSH
31063: LD_INT 1
31065: EQUAL
31066: IFFALSE 31082
// Say ( JMM , DAb-JMM-1a ) else
31068: LD_EXP 39
31072: PPUSH
31073: LD_STRING DAb-JMM-1a
31075: PPUSH
31076: CALL_OW 88
31080: GO 31094
// Say ( JMM , DAb-JMM-1b ) ;
31082: LD_EXP 39
31086: PPUSH
31087: LD_STRING DAb-JMM-1b
31089: PPUSH
31090: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31094: LD_EXP 35
31098: PPUSH
31099: CALL_OW 87
// for i in trueAmericans do
31103: LD_ADDR_VAR 0 2
31107: PUSH
31108: LD_EXP 35
31112: PUSH
31113: FOR_IN
31114: IFFALSE 31130
// SetSide ( i , 1 ) ;
31116: LD_VAR 0 2
31120: PPUSH
31121: LD_INT 1
31123: PPUSH
31124: CALL_OW 235
31128: GO 31113
31130: POP
31131: POP
// end ; repeat wait ( 0 0$1 ) ;
31132: LD_INT 35
31134: PPUSH
31135: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31139: LD_ADDR_VAR 0 2
31143: PUSH
31144: LD_INT 22
31146: PUSH
31147: LD_INT 7
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 21
31156: PUSH
31157: LD_INT 1
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PPUSH
31168: CALL_OW 69
31172: PUSH
31173: FOR_IN
31174: IFFALSE 31256
// begin if IsInUnit ( i ) then
31176: LD_VAR 0 2
31180: PPUSH
31181: CALL_OW 310
31185: IFFALSE 31196
// ComExitBuilding ( i ) ;
31187: LD_VAR 0 2
31191: PPUSH
31192: CALL_OW 122
// if IsDriver ( i ) then
31196: LD_VAR 0 2
31200: PPUSH
31201: CALL 100717 0 1
31205: IFFALSE 31216
// ComExitVehicle ( i ) ;
31207: LD_VAR 0 2
31211: PPUSH
31212: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31216: LD_VAR 0 2
31220: PPUSH
31221: LD_INT 26
31223: PPUSH
31224: CALL_OW 308
31228: NOT
31229: IFFALSE 31245
// AddComMoveToArea ( i , allianceEscapeArea ) else
31231: LD_VAR 0 2
31235: PPUSH
31236: LD_INT 26
31238: PPUSH
31239: CALL_OW 173
31243: GO 31254
// RemoveUnit ( i ) ;
31245: LD_VAR 0 2
31249: PPUSH
31250: CALL_OW 64
// end ;
31254: GO 31173
31256: POP
31257: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31258: LD_INT 22
31260: PUSH
31261: LD_INT 7
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 21
31270: PUSH
31271: LD_INT 1
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PPUSH
31282: CALL_OW 69
31286: NOT
31287: IFFALSE 31132
// end ;
31289: PPOPN 2
31291: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31292: LD_INT 0
31294: PPUSH
31295: PPUSH
// if not unit then
31296: LD_VAR 0 1
31300: NOT
31301: IFFALSE 31305
// exit ;
31303: GO 32803
// DoNotAttack ( 7 , unit ) ;
31305: LD_INT 7
31307: PPUSH
31308: LD_VAR 0 1
31312: PPUSH
31313: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31317: LD_VAR 0 1
31321: PPUSH
31322: LD_INT 260
31324: PPUSH
31325: LD_INT 235
31327: PPUSH
31328: LD_INT 3
31330: PPUSH
31331: LD_INT 1
31333: PPUSH
31334: CALL_OW 483
// SetSide ( unit , 4 ) ;
31338: LD_VAR 0 1
31342: PPUSH
31343: LD_INT 4
31345: PPUSH
31346: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31350: LD_ADDR_EXP 34
31354: PUSH
31355: LD_EXP 34
31359: PUSH
31360: LD_INT 1
31362: PLUS
31363: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31364: LD_INT 70
31366: PPUSH
31367: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31371: LD_INT 260
31373: PPUSH
31374: LD_INT 235
31376: PPUSH
31377: LD_INT 1
31379: PPUSH
31380: LD_INT 8
31382: NEG
31383: PPUSH
31384: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31388: LD_VAR 0 1
31392: PPUSH
31393: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31397: LD_VAR 0 1
31401: PPUSH
31402: LD_EXP 74
31406: PPUSH
31407: CALL_OW 119
// DialogueOn ;
31411: CALL_OW 6
// case unit of JMM :
31415: LD_VAR 0 1
31419: PUSH
31420: LD_EXP 39
31424: DOUBLE
31425: EQUAL
31426: IFTRUE 31430
31428: GO 31445
31430: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31431: LD_EXP 39
31435: PPUSH
31436: LD_STRING DA1-JMM-1
31438: PPUSH
31439: CALL_OW 91
31443: GO 31887
31445: LD_EXP 40
31449: DOUBLE
31450: EQUAL
31451: IFTRUE 31455
31453: GO 31470
31455: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31456: LD_EXP 40
31460: PPUSH
31461: LD_STRING DA1-Joan-1
31463: PPUSH
31464: CALL_OW 91
31468: GO 31887
31470: LD_EXP 42
31474: DOUBLE
31475: EQUAL
31476: IFTRUE 31480
31478: GO 31495
31480: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31481: LD_EXP 42
31485: PPUSH
31486: LD_STRING DA1-Lisa-1
31488: PPUSH
31489: CALL_OW 91
31493: GO 31887
31495: LD_EXP 43
31499: DOUBLE
31500: EQUAL
31501: IFTRUE 31505
31503: GO 31520
31505: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31506: LD_EXP 43
31510: PPUSH
31511: LD_STRING DA1-Don-1
31513: PPUSH
31514: CALL_OW 91
31518: GO 31887
31520: LD_EXP 50
31524: DOUBLE
31525: EQUAL
31526: IFTRUE 31530
31528: GO 31545
31530: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31531: LD_EXP 50
31535: PPUSH
31536: LD_STRING DA1-Corn-1
31538: PPUSH
31539: CALL_OW 91
31543: GO 31887
31545: LD_EXP 46
31549: DOUBLE
31550: EQUAL
31551: IFTRUE 31555
31553: GO 31570
31555: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31556: LD_EXP 46
31560: PPUSH
31561: LD_STRING DA1-Den-1
31563: PPUSH
31564: CALL_OW 91
31568: GO 31887
31570: LD_EXP 44
31574: DOUBLE
31575: EQUAL
31576: IFTRUE 31580
31578: GO 31595
31580: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31581: LD_EXP 44
31585: PPUSH
31586: LD_STRING DA1-Bobby-1
31588: PPUSH
31589: CALL_OW 91
31593: GO 31887
31595: LD_EXP 48
31599: DOUBLE
31600: EQUAL
31601: IFTRUE 31605
31603: GO 31620
31605: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31606: LD_EXP 48
31610: PPUSH
31611: LD_STRING DA1-Glad-1
31613: PPUSH
31614: CALL_OW 91
31618: GO 31887
31620: LD_EXP 45
31624: DOUBLE
31625: EQUAL
31626: IFTRUE 31630
31628: GO 31645
31630: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31631: LD_EXP 45
31635: PPUSH
31636: LD_STRING DA1-Cyrus-1
31638: PPUSH
31639: CALL_OW 91
31643: GO 31887
31645: LD_EXP 41
31649: DOUBLE
31650: EQUAL
31651: IFTRUE 31655
31653: GO 31670
31655: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31656: LD_EXP 41
31660: PPUSH
31661: LD_STRING DA1-Huck-1
31663: PPUSH
31664: CALL_OW 91
31668: GO 31887
31670: LD_EXP 55
31674: DOUBLE
31675: EQUAL
31676: IFTRUE 31680
31678: GO 31695
31680: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31681: LD_EXP 55
31685: PPUSH
31686: LD_STRING DA1-Huck-1
31688: PPUSH
31689: CALL_OW 91
31693: GO 31887
31695: LD_EXP 47
31699: DOUBLE
31700: EQUAL
31701: IFTRUE 31705
31703: GO 31720
31705: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31706: LD_EXP 47
31710: PPUSH
31711: LD_STRING DA1-Brown-1
31713: PPUSH
31714: CALL_OW 91
31718: GO 31887
31720: LD_EXP 51
31724: DOUBLE
31725: EQUAL
31726: IFTRUE 31730
31728: GO 31745
31730: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31731: LD_EXP 51
31735: PPUSH
31736: LD_STRING DA1-Gary-1
31738: PPUSH
31739: CALL_OW 91
31743: GO 31887
31745: LD_EXP 54
31749: DOUBLE
31750: EQUAL
31751: IFTRUE 31755
31753: GO 31770
31755: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31756: LD_EXP 54
31760: PPUSH
31761: LD_STRING DA1-Con-1
31763: PPUSH
31764: CALL_OW 91
31768: GO 31887
31770: LD_EXP 60
31774: DOUBLE
31775: EQUAL
31776: IFTRUE 31780
31778: GO 31795
31780: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31781: LD_EXP 60
31785: PPUSH
31786: LD_STRING DA1-Kurt-1
31788: PPUSH
31789: CALL_OW 91
31793: GO 31887
31795: LD_EXP 53
31799: DOUBLE
31800: EQUAL
31801: IFTRUE 31805
31803: GO 31820
31805: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31806: LD_EXP 53
31810: PPUSH
31811: LD_STRING DA1-Yam-1
31813: PPUSH
31814: CALL_OW 91
31818: GO 31887
31820: LD_EXP 52
31824: DOUBLE
31825: EQUAL
31826: IFTRUE 31830
31828: GO 31845
31830: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31831: LD_EXP 52
31835: PPUSH
31836: LD_STRING DA1-Frank-1
31838: PPUSH
31839: CALL_OW 91
31843: GO 31887
31845: POP
// begin if GetSex ( unit ) = sex_male then
31846: LD_VAR 0 1
31850: PPUSH
31851: CALL_OW 258
31855: PUSH
31856: LD_INT 1
31858: EQUAL
31859: IFFALSE 31875
// ForceSay ( unit , DA1-Sol1-1 ) else
31861: LD_VAR 0 1
31865: PPUSH
31866: LD_STRING DA1-Sol1-1
31868: PPUSH
31869: CALL_OW 91
31873: GO 31887
// ForceSay ( unit , DA1-FSol1-1 ) ;
31875: LD_VAR 0 1
31879: PPUSH
31880: LD_STRING DA1-FSol1-1
31882: PPUSH
31883: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31887: LD_EXP 74
31891: PPUSH
31892: LD_STRING DA-Roth-1
31894: PPUSH
31895: CALL_OW 88
// if capturedUnit = 1 then
31899: LD_EXP 34
31903: PUSH
31904: LD_INT 1
31906: EQUAL
31907: IFFALSE 31935
// begin Say ( Simms , DA-Sim-1 ) ;
31909: LD_EXP 75
31913: PPUSH
31914: LD_STRING DA-Sim-1
31916: PPUSH
31917: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31921: LD_EXP 74
31925: PPUSH
31926: LD_STRING DA-Roth-2
31928: PPUSH
31929: CALL_OW 88
// end else
31933: GO 31947
// Say ( Simms , DA-Sim-2 ) ;
31935: LD_EXP 75
31939: PPUSH
31940: LD_STRING DA-Sim-2
31942: PPUSH
31943: CALL_OW 88
// case unit of JMM :
31947: LD_VAR 0 1
31951: PUSH
31952: LD_EXP 39
31956: DOUBLE
31957: EQUAL
31958: IFTRUE 31962
31960: GO 31977
31962: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31963: LD_EXP 39
31967: PPUSH
31968: LD_STRING DA1-JMM-1a
31970: PPUSH
31971: CALL_OW 91
31975: GO 32484
31977: LD_EXP 40
31981: DOUBLE
31982: EQUAL
31983: IFTRUE 31987
31985: GO 32002
31987: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31988: LD_EXP 40
31992: PPUSH
31993: LD_STRING DA1-Joan-1a
31995: PPUSH
31996: CALL_OW 91
32000: GO 32484
32002: LD_EXP 42
32006: DOUBLE
32007: EQUAL
32008: IFTRUE 32012
32010: GO 32027
32012: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
32013: LD_EXP 42
32017: PPUSH
32018: LD_STRING DA1-Lisa-1a
32020: PPUSH
32021: CALL_OW 91
32025: GO 32484
32027: LD_EXP 43
32031: DOUBLE
32032: EQUAL
32033: IFTRUE 32037
32035: GO 32052
32037: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32038: LD_EXP 43
32042: PPUSH
32043: LD_STRING DA1-Don-1a
32045: PPUSH
32046: CALL_OW 91
32050: GO 32484
32052: LD_EXP 50
32056: DOUBLE
32057: EQUAL
32058: IFTRUE 32062
32060: GO 32077
32062: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32063: LD_EXP 50
32067: PPUSH
32068: LD_STRING DA1-Corn-1a
32070: PPUSH
32071: CALL_OW 91
32075: GO 32484
32077: LD_EXP 46
32081: DOUBLE
32082: EQUAL
32083: IFTRUE 32087
32085: GO 32102
32087: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32088: LD_EXP 46
32092: PPUSH
32093: LD_STRING DA1-Den-1a
32095: PPUSH
32096: CALL_OW 91
32100: GO 32484
32102: LD_EXP 44
32106: DOUBLE
32107: EQUAL
32108: IFTRUE 32112
32110: GO 32127
32112: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32113: LD_EXP 44
32117: PPUSH
32118: LD_STRING DA1-Bobby-1a
32120: PPUSH
32121: CALL_OW 91
32125: GO 32484
32127: LD_EXP 48
32131: DOUBLE
32132: EQUAL
32133: IFTRUE 32137
32135: GO 32152
32137: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32138: LD_EXP 48
32142: PPUSH
32143: LD_STRING DA1-Glad-1a
32145: PPUSH
32146: CALL_OW 91
32150: GO 32484
32152: LD_EXP 45
32156: DOUBLE
32157: EQUAL
32158: IFTRUE 32162
32160: GO 32177
32162: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32163: LD_EXP 45
32167: PPUSH
32168: LD_STRING DA1-Cyrus-1a
32170: PPUSH
32171: CALL_OW 91
32175: GO 32484
32177: LD_EXP 41
32181: DOUBLE
32182: EQUAL
32183: IFTRUE 32187
32185: GO 32202
32187: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32188: LD_EXP 41
32192: PPUSH
32193: LD_STRING DA1-Huck-1a
32195: PPUSH
32196: CALL_OW 91
32200: GO 32484
32202: LD_EXP 55
32206: DOUBLE
32207: EQUAL
32208: IFTRUE 32212
32210: GO 32227
32212: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32213: LD_EXP 55
32217: PPUSH
32218: LD_STRING DA1-Huck-1a
32220: PPUSH
32221: CALL_OW 91
32225: GO 32484
32227: LD_EXP 47
32231: DOUBLE
32232: EQUAL
32233: IFTRUE 32237
32235: GO 32252
32237: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32238: LD_EXP 47
32242: PPUSH
32243: LD_STRING DA1-Brown-1a
32245: PPUSH
32246: CALL_OW 91
32250: GO 32484
32252: LD_EXP 51
32256: DOUBLE
32257: EQUAL
32258: IFTRUE 32262
32260: GO 32277
32262: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32263: LD_EXP 51
32267: PPUSH
32268: LD_STRING DA1-Gary-1a
32270: PPUSH
32271: CALL_OW 91
32275: GO 32484
32277: LD_EXP 54
32281: DOUBLE
32282: EQUAL
32283: IFTRUE 32287
32285: GO 32302
32287: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32288: LD_EXP 54
32292: PPUSH
32293: LD_STRING DA1-Con-1a
32295: PPUSH
32296: CALL_OW 91
32300: GO 32484
32302: LD_EXP 60
32306: DOUBLE
32307: EQUAL
32308: IFTRUE 32312
32310: GO 32327
32312: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32313: LD_EXP 60
32317: PPUSH
32318: LD_STRING DA1-Kurt-1a
32320: PPUSH
32321: CALL_OW 91
32325: GO 32484
32327: LD_EXP 53
32331: DOUBLE
32332: EQUAL
32333: IFTRUE 32337
32335: GO 32352
32337: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32338: LD_EXP 53
32342: PPUSH
32343: LD_STRING DA1-Yam-1a
32345: PPUSH
32346: CALL_OW 91
32350: GO 32484
32352: LD_EXP 52
32356: DOUBLE
32357: EQUAL
32358: IFTRUE 32362
32360: GO 32377
32362: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32363: LD_EXP 52
32367: PPUSH
32368: LD_STRING DA1-Frank-1a
32370: PPUSH
32371: CALL_OW 91
32375: GO 32484
32377: POP
// begin join := rand ( 0 , 1 ) ;
32378: LD_ADDR_VAR 0 3
32382: PUSH
32383: LD_INT 0
32385: PPUSH
32386: LD_INT 1
32388: PPUSH
32389: CALL_OW 12
32393: ST_TO_ADDR
// if join then
32394: LD_VAR 0 3
32398: IFFALSE 32443
// begin if GetSex ( unit ) = sex_male then
32400: LD_VAR 0 1
32404: PPUSH
32405: CALL_OW 258
32409: PUSH
32410: LD_INT 1
32412: EQUAL
32413: IFFALSE 32429
// ForceSay ( unit , DA1-Sol1-1b ) else
32415: LD_VAR 0 1
32419: PPUSH
32420: LD_STRING DA1-Sol1-1b
32422: PPUSH
32423: CALL_OW 91
32427: GO 32441
// ForceSay ( unit , DA1-FSol1-1b ) ;
32429: LD_VAR 0 1
32433: PPUSH
32434: LD_STRING DA1-FSol1-1b
32436: PPUSH
32437: CALL_OW 91
// end else
32441: GO 32484
// begin if GetSex ( unit ) = sex_male then
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 258
32452: PUSH
32453: LD_INT 1
32455: EQUAL
32456: IFFALSE 32472
// ForceSay ( unit , DA1-Sol1-1a ) else
32458: LD_VAR 0 1
32462: PPUSH
32463: LD_STRING DA1-Sol1-1a
32465: PPUSH
32466: CALL_OW 91
32470: GO 32484
// ForceSay ( unit , DA1-FSol1-1a ) ;
32472: LD_VAR 0 1
32476: PPUSH
32477: LD_STRING DA1-FSol1-1a
32479: PPUSH
32480: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32484: LD_VAR 0 1
32488: PUSH
32489: LD_EXP 39
32493: EQUAL
32494: IFFALSE 32505
// begin YouLost ( JMMCaptured ) ;
32496: LD_STRING JMMCaptured
32498: PPUSH
32499: CALL_OW 104
// exit ;
32503: GO 32803
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32505: LD_VAR 0 1
32509: PUSH
32510: LD_EXP 43
32514: PUSH
32515: LD_EXP 46
32519: PUSH
32520: LD_EXP 44
32524: PUSH
32525: LD_EXP 41
32529: PUSH
32530: LD_EXP 55
32534: PUSH
32535: LD_EXP 47
32539: PUSH
32540: LD_EXP 53
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: IN
32554: PUSH
32555: LD_VAR 0 3
32559: OR
32560: IFFALSE 32659
// begin Say ( Roth , DA-Roth-3 ) ;
32562: LD_EXP 74
32566: PPUSH
32567: LD_STRING DA-Roth-3
32569: PPUSH
32570: CALL_OW 88
// SetSide ( unit , 7 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 7
32581: PPUSH
32582: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32586: LD_ADDR_EXP 97
32590: PUSH
32591: LD_EXP 97
32595: PPUSH
32596: LD_INT 1
32598: PPUSH
32599: LD_EXP 97
32603: PUSH
32604: LD_INT 1
32606: ARRAY
32607: PUSH
32608: LD_VAR 0 1
32612: ADD
32613: PPUSH
32614: CALL_OW 1
32618: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32619: LD_INT 260
32621: PPUSH
32622: LD_INT 235
32624: PPUSH
32625: LD_INT 1
32627: PPUSH
32628: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32632: LD_VAR 0 1
32636: PPUSH
32637: LD_INT 1000
32639: PPUSH
32640: CALL_OW 234
// DialogueOff ;
32644: CALL_OW 7
// ComFree ( unit ) ;
32648: LD_VAR 0 1
32652: PPUSH
32653: CALL_OW 139
// end else
32657: GO 32740
// begin Say ( Roth , DA-Roth-3a ) ;
32659: LD_EXP 74
32663: PPUSH
32664: LD_STRING DA-Roth-3a
32666: PPUSH
32667: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32671: LD_ADDR_EXP 35
32675: PUSH
32676: LD_EXP 35
32680: PUSH
32681: LD_VAR 0 1
32685: ADD
32686: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32687: LD_INT 260
32689: PPUSH
32690: LD_INT 235
32692: PPUSH
32693: LD_INT 1
32695: PPUSH
32696: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32700: LD_VAR 0 1
32704: PPUSH
32705: LD_INT 1000
32707: PPUSH
32708: CALL_OW 234
// DialogueOff ;
32712: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32716: LD_VAR 0 1
32720: PPUSH
32721: LD_INT 272
32723: PPUSH
32724: LD_INT 254
32726: PPUSH
32727: CALL_OW 111
// AddComHold ( unit ) ;
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 200
// end ; if capturedUnit = 1 then
32740: LD_EXP 34
32744: PUSH
32745: LD_INT 1
32747: EQUAL
32748: IFFALSE 32803
// begin DialogueOn ;
32750: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32754: LD_EXP 39
32758: PPUSH
32759: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32763: LD_EXP 39
32767: PPUSH
32768: LD_STRING DAa-JMM-1
32770: PPUSH
32771: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32775: LD_EXP 39
32779: PPUSH
32780: LD_STRING DAa-JMM-1a
32782: PPUSH
32783: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32787: LD_EXP 39
32791: PPUSH
32792: LD_STRING DAa-JMM-1b
32794: PPUSH
32795: CALL_OW 88
// DialogueOff ;
32799: CALL_OW 7
// end ; end ;
32803: LD_VAR 0 2
32807: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32808: LD_EXP 15
32812: PUSH
32813: LD_INT 13
32815: GREATEREQUAL
32816: PUSH
32817: LD_INT 22
32819: PUSH
32820: LD_INT 2
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 21
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PPUSH
32841: CALL_OW 69
32845: PUSH
32846: LD_INT 0
32848: EQUAL
32849: AND
32850: PUSH
32851: LD_INT 22
32853: PUSH
32854: LD_INT 2
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 33
32863: PUSH
32864: LD_INT 5
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 21
32873: PUSH
32874: LD_INT 2
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: LD_INT 50
32883: PUSH
32884: EMPTY
32885: LIST
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: PPUSH
32893: CALL_OW 69
32897: PUSH
32898: LD_INT 0
32900: EQUAL
32901: AND
32902: PUSH
32903: LD_EXP 21
32907: AND
32908: PUSH
32909: LD_EXP 22
32913: AND
32914: PUSH
32915: LD_EXP 23
32919: AND
32920: IFFALSE 33569
32922: GO 32924
32924: DISABLE
32925: LD_INT 0
32927: PPUSH
32928: PPUSH
32929: PPUSH
// begin m1 := false ;
32930: LD_ADDR_VAR 0 1
32934: PUSH
32935: LD_INT 0
32937: ST_TO_ADDR
// m2 := false ;
32938: LD_ADDR_VAR 0 2
32942: PUSH
32943: LD_INT 0
32945: ST_TO_ADDR
// m3 := false ;
32946: LD_ADDR_VAR 0 3
32950: PUSH
32951: LD_INT 0
32953: ST_TO_ADDR
// if not bombExploded then
32954: LD_EXP 37
32958: NOT
32959: IFFALSE 32968
// SetAchievement ( ACH_SIBROCKET ) ;
32961: LD_STRING ACH_SIBROCKET
32963: PPUSH
32964: CALL_OW 543
// if tick <= 120 120$00 then
32968: LD_OWVAR 1
32972: PUSH
32973: LD_INT 252000
32975: LESSEQUAL
32976: IFFALSE 32992
// begin wait ( 3 ) ;
32978: LD_INT 3
32980: PPUSH
32981: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32985: LD_STRING ACH_ASPEED_15
32987: PPUSH
32988: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32992: LD_EXP 39
32996: PPUSH
32997: CALL_OW 87
// music_class := 5 ;
33001: LD_ADDR_OWVAR 72
33005: PUSH
33006: LD_INT 5
33008: ST_TO_ADDR
// music_nat := 5 ;
33009: LD_ADDR_OWVAR 71
33013: PUSH
33014: LD_INT 5
33016: ST_TO_ADDR
// DialogueOn ;
33017: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33021: LD_EXP 39
33025: PPUSH
33026: LD_STRING D20-JMM-1
33028: PPUSH
33029: CALL_OW 88
// if IsOK ( Joan ) then
33033: LD_EXP 40
33037: PPUSH
33038: CALL_OW 302
33042: IFFALSE 33056
// Say ( Joan , D20-Joan-1 ) ;
33044: LD_EXP 40
33048: PPUSH
33049: LD_STRING D20-Joan-1
33051: PPUSH
33052: CALL_OW 88
// if IsOk ( Lisa ) then
33056: LD_EXP 42
33060: PPUSH
33061: CALL_OW 302
33065: IFFALSE 33079
// Say ( Lisa , D20-Lisa-1 ) ;
33067: LD_EXP 42
33071: PPUSH
33072: LD_STRING D20-Lisa-1
33074: PPUSH
33075: CALL_OW 88
// if IsOk ( Donaldson ) then
33079: LD_EXP 43
33083: PPUSH
33084: CALL_OW 302
33088: IFFALSE 33102
// Say ( Donaldson , D20-Don-1 ) ;
33090: LD_EXP 43
33094: PPUSH
33095: LD_STRING D20-Don-1
33097: PPUSH
33098: CALL_OW 88
// if IsOK ( Cornel ) then
33102: LD_EXP 50
33106: PPUSH
33107: CALL_OW 302
33111: IFFALSE 33125
// Say ( Cornel , D20-Corn-1 ) ;
33113: LD_EXP 50
33117: PPUSH
33118: LD_STRING D20-Corn-1
33120: PPUSH
33121: CALL_OW 88
// if IsOk ( Denis ) then
33125: LD_EXP 46
33129: PPUSH
33130: CALL_OW 302
33134: IFFALSE 33148
// Say ( Denis , D20-Den-1 ) ;
33136: LD_EXP 46
33140: PPUSH
33141: LD_STRING D20-Den-1
33143: PPUSH
33144: CALL_OW 88
// if IsOk ( Bobby ) then
33148: LD_EXP 44
33152: PPUSH
33153: CALL_OW 302
33157: IFFALSE 33171
// Say ( Bobby , D20-Bobby-1 ) ;
33159: LD_EXP 44
33163: PPUSH
33164: LD_STRING D20-Bobby-1
33166: PPUSH
33167: CALL_OW 88
// if IsOk ( Gladstone ) then
33171: LD_EXP 48
33175: PPUSH
33176: CALL_OW 302
33180: IFFALSE 33194
// Say ( Gladstone , D20-Glad-1 ) ;
33182: LD_EXP 48
33186: PPUSH
33187: LD_STRING D20-Glad-1
33189: PPUSH
33190: CALL_OW 88
// if IsOk ( Cyrus ) then
33194: LD_EXP 45
33198: PPUSH
33199: CALL_OW 302
33203: IFFALSE 33217
// Say ( Cyrus , D20-Cyrus-1 ) ;
33205: LD_EXP 45
33209: PPUSH
33210: LD_STRING D20-Cyrus-1
33212: PPUSH
33213: CALL_OW 88
// if IsOk ( Stevens ) then
33217: LD_EXP 41
33221: PPUSH
33222: CALL_OW 302
33226: IFFALSE 33240
// Say ( Stevens , D20-Huck-1 ) ;
33228: LD_EXP 41
33232: PPUSH
33233: LD_STRING D20-Huck-1
33235: PPUSH
33236: CALL_OW 88
// if IsOk ( Brown ) then
33240: LD_EXP 47
33244: PPUSH
33245: CALL_OW 302
33249: IFFALSE 33263
// Say ( Brown , D20-Brown-1 ) ;
33251: LD_EXP 47
33255: PPUSH
33256: LD_STRING D20-Brown-1
33258: PPUSH
33259: CALL_OW 88
// if IsOk ( Gary ) then
33263: LD_EXP 51
33267: PPUSH
33268: CALL_OW 302
33272: IFFALSE 33286
// Say ( Gary , D20-Gary-1 ) ;
33274: LD_EXP 51
33278: PPUSH
33279: LD_STRING D20-Gary-1
33281: PPUSH
33282: CALL_OW 88
// if IsOk ( Connie ) then
33286: LD_EXP 54
33290: PPUSH
33291: CALL_OW 302
33295: IFFALSE 33309
// Say ( Connie , D20-Con-1 ) ;
33297: LD_EXP 54
33301: PPUSH
33302: LD_STRING D20-Con-1
33304: PPUSH
33305: CALL_OW 88
// if IsOk ( Kurt ) then
33309: LD_EXP 60
33313: PPUSH
33314: CALL_OW 302
33318: IFFALSE 33332
// Say ( Kurt , D20-Kurt-1 ) ;
33320: LD_EXP 60
33324: PPUSH
33325: LD_STRING D20-Kurt-1
33327: PPUSH
33328: CALL_OW 88
// if IsOk ( Kikuchi ) then
33332: LD_EXP 53
33336: PPUSH
33337: CALL_OW 302
33341: IFFALSE 33355
// Say ( Kikuchi , D20-Yam-1 ) ;
33343: LD_EXP 53
33347: PPUSH
33348: LD_STRING D20-Yam-1
33350: PPUSH
33351: CALL_OW 88
// if IsOk ( Frank ) then
33355: LD_EXP 52
33359: PPUSH
33360: CALL_OW 302
33364: IFFALSE 33378
// Say ( Frank , D20-Frank-1 ) ;
33366: LD_EXP 52
33370: PPUSH
33371: LD_STRING D20-Frank-1
33373: PPUSH
33374: CALL_OW 88
// DialogueOff ;
33378: CALL_OW 7
// if RothCaptured then
33382: LD_EXP 33
33386: IFFALSE 33408
// begin m1 := true ;
33388: LD_ADDR_VAR 0 1
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33396: LD_STRING Roth
33398: PPUSH
33399: LD_INT 1
33401: PPUSH
33402: CALL_OW 101
// end else
33406: GO 33419
// AddMedal ( Roth , - 1 ) ;
33408: LD_STRING Roth
33410: PPUSH
33411: LD_INT 1
33413: NEG
33414: PPUSH
33415: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33419: LD_EXP 25
33423: NOT
33424: PUSH
33425: LD_EXP 27
33429: OR
33430: IFFALSE 33452
// begin m2 := true ;
33432: LD_ADDR_VAR 0 2
33436: PUSH
33437: LD_INT 1
33439: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33440: LD_STRING Project
33442: PPUSH
33443: LD_INT 1
33445: PPUSH
33446: CALL_OW 101
// end else
33450: GO 33463
// AddMedal ( Project , - 1 ) ;
33452: LD_STRING Project
33454: PPUSH
33455: LD_INT 1
33457: NEG
33458: PPUSH
33459: CALL_OW 101
// if lostCounter = 0 then
33463: LD_EXP 32
33467: PUSH
33468: LD_INT 0
33470: EQUAL
33471: IFFALSE 33493
// begin m3 := true ;
33473: LD_ADDR_VAR 0 3
33477: PUSH
33478: LD_INT 1
33480: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33481: LD_STRING NoLosses
33483: PPUSH
33484: LD_INT 1
33486: PPUSH
33487: CALL_OW 101
// end else
33491: GO 33504
// AddMedal ( NoLosses , - 1 ) ;
33493: LD_STRING NoLosses
33495: PPUSH
33496: LD_INT 1
33498: NEG
33499: PPUSH
33500: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33504: LD_VAR 0 1
33508: PUSH
33509: LD_VAR 0 2
33513: AND
33514: PUSH
33515: LD_VAR 0 3
33519: AND
33520: PUSH
33521: LD_OWVAR 67
33525: PUSH
33526: LD_INT 3
33528: GREATEREQUAL
33529: AND
33530: IFFALSE 33542
// SetAchievementEX ( ACH_AMER , 15 ) ;
33532: LD_STRING ACH_AMER
33534: PPUSH
33535: LD_INT 15
33537: PPUSH
33538: CALL_OW 564
// GiveMedals ( MAIN ) ;
33542: LD_STRING MAIN
33544: PPUSH
33545: CALL_OW 102
// music_class := 4 ;
33549: LD_ADDR_OWVAR 72
33553: PUSH
33554: LD_INT 4
33556: ST_TO_ADDR
// music_nat := 1 ;
33557: LD_ADDR_OWVAR 71
33561: PUSH
33562: LD_INT 1
33564: ST_TO_ADDR
// YouWin ;
33565: CALL_OW 103
// end ; end_of_file
33569: PPOPN 3
33571: END
// export function CustomEvent ( event ) ; begin
33572: LD_INT 0
33574: PPUSH
// end ;
33575: LD_VAR 0 2
33579: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33580: LD_VAR 0 1
33584: PUSH
33585: LD_INT 1
33587: EQUAL
33588: PUSH
33589: LD_VAR 0 2
33593: PUSH
33594: LD_INT 4
33596: EQUAL
33597: AND
33598: PUSH
33599: LD_EXP 58
33603: PPUSH
33604: CALL_OW 300
33608: AND
33609: IFFALSE 33625
// begin wait ( 0 0$2 ) ;
33611: LD_INT 70
33613: PPUSH
33614: CALL_OW 67
// YouLost ( Dismissed ) ;
33618: LD_STRING Dismissed
33620: PPUSH
33621: CALL_OW 104
// end ; end ;
33625: PPOPN 2
33627: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33628: LD_VAR 0 2
33632: PPUSH
33633: LD_VAR 0 3
33637: PPUSH
33638: LD_INT 18
33640: PPUSH
33641: CALL_OW 309
33645: IFFALSE 33654
// YouLost ( Motherlode3 ) ;
33647: LD_STRING Motherlode3
33649: PPUSH
33650: CALL_OW 104
// end ;
33654: PPOPN 3
33656: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33657: LD_EXP 27
33661: NOT
33662: IFFALSE 33672
// behemothDone := true ;
33664: LD_ADDR_EXP 28
33668: PUSH
33669: LD_INT 1
33671: ST_TO_ADDR
// end ;
33672: PPOPN 1
33674: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33675: LD_VAR 0 1
33679: PPUSH
33680: CALL_OW 255
33684: PUSH
33685: LD_INT 1
33687: EQUAL
33688: IFFALSE 33698
// bombExploded := true ;
33690: LD_ADDR_EXP 37
33694: PUSH
33695: LD_INT 1
33697: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33698: LD_VAR 0 1
33702: PPUSH
33703: CALL_OW 255
33707: PUSH
33708: LD_INT 1
33710: EQUAL
33711: PUSH
33712: LD_EXP 30
33716: AND
33717: PUSH
33718: LD_INT 22
33720: PUSH
33721: LD_INT 3
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 34
33730: PUSH
33731: LD_INT 48
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PPUSH
33742: CALL_OW 69
33746: AND
33747: PUSH
33748: LD_INT 22
33750: PUSH
33751: LD_INT 1
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 34
33760: PUSH
33761: LD_INT 8
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PPUSH
33772: CALL_OW 69
33776: NOT
33777: AND
33778: IFFALSE 33830
// begin wait ( 0 0$5 ) ;
33780: LD_INT 175
33782: PPUSH
33783: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33787: LD_INT 22
33789: PUSH
33790: LD_INT 3
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 34
33799: PUSH
33800: LD_INT 48
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PPUSH
33811: CALL_OW 69
33815: PUSH
33816: LD_INT 1
33818: ARRAY
33819: PPUSH
33820: LD_INT 60
33822: PPUSH
33823: LD_INT 95
33825: PPUSH
33826: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33830: LD_VAR 0 2
33834: PPUSH
33835: LD_VAR 0 3
33839: PPUSH
33840: LD_INT 18
33842: PPUSH
33843: CALL_OW 309
33847: IFFALSE 33894
// begin if GetSide ( unit ) = 1 then
33849: LD_VAR 0 1
33853: PPUSH
33854: CALL_OW 255
33858: PUSH
33859: LD_INT 1
33861: EQUAL
33862: IFFALSE 33880
// begin wait ( 0 0$6 ) ;
33864: LD_INT 210
33866: PPUSH
33867: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33871: LD_STRING Motherlode2
33873: PPUSH
33874: CALL_OW 104
// end else
33878: GO 33894
// begin wait ( 0 0$6 ) ;
33880: LD_INT 210
33882: PPUSH
33883: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33887: LD_STRING Motherlode1
33889: PPUSH
33890: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33894: LD_VAR 0 1
33898: PPUSH
33899: CALL_OW 255
33903: PUSH
33904: LD_INT 3
33906: EQUAL
33907: IFFALSE 33928
// begin wait ( 0 0$5 ) ;
33909: LD_INT 175
33911: PPUSH
33912: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33916: LD_EXP 64
33920: PPUSH
33921: LD_STRING D18-Pla-1
33923: PPUSH
33924: CALL_OW 94
// end ; end ;
33928: PPOPN 3
33930: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
33931: LD_VAR 0 1
33935: PPUSH
33936: CALL 122566 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33940: LD_VAR 0 1
33944: PUSH
33945: LD_INT 22
33947: PUSH
33948: LD_INT 1
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 21
33957: PUSH
33958: LD_INT 1
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 23
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: LIST
33979: PPUSH
33980: CALL_OW 69
33984: IN
33985: IFFALSE 34001
// lostCounter := lostCounter + 1 ;
33987: LD_ADDR_EXP 32
33991: PUSH
33992: LD_EXP 32
33996: PUSH
33997: LD_INT 1
33999: PLUS
34000: ST_TO_ADDR
// if un in behemothBuilders then
34001: LD_VAR 0 1
34005: PUSH
34006: LD_EXP 73
34010: IN
34011: IFFALSE 34031
// begin behemothBuilders := behemothBuilders diff un ;
34013: LD_ADDR_EXP 73
34017: PUSH
34018: LD_EXP 73
34022: PUSH
34023: LD_VAR 0 1
34027: DIFF
34028: ST_TO_ADDR
// exit ;
34029: GO 34061
// end ; if un = JMM then
34031: LD_VAR 0 1
34035: PUSH
34036: LD_EXP 39
34040: EQUAL
34041: IFFALSE 34052
// begin YouLost ( JMM ) ;
34043: LD_STRING JMM
34045: PPUSH
34046: CALL_OW 104
// exit ;
34050: GO 34061
// end ; MCE_UnitDestroyed ( un ) ;
34052: LD_VAR 0 1
34056: PPUSH
34057: CALL 62748 0 1
// end ;
34061: PPOPN 1
34063: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34064: LD_VAR 0 1
34068: PPUSH
34069: LD_VAR 0 2
34073: PPUSH
34074: CALL 65080 0 2
// end ;
34078: PPOPN 2
34080: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34081: LD_VAR 0 1
34085: PPUSH
34086: CALL 64148 0 1
// end ;
34090: PPOPN 1
34092: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34093: LD_VAR 0 1
34097: PUSH
34098: LD_INT 22
34100: PUSH
34101: LD_INT 8
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 30
34110: PUSH
34111: LD_INT 2
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 23
34120: PUSH
34121: LD_INT 3
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: LIST
34132: PPUSH
34133: CALL_OW 69
34137: IN
34138: IFFALSE 34165
// begin ComUpgrade ( building ) ;
34140: LD_VAR 0 1
34144: PPUSH
34145: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34149: LD_EXP 61
34153: PPUSH
34154: LD_VAR 0 1
34158: PPUSH
34159: CALL 73730 0 2
// exit ;
34163: GO 34174
// end ; MCE_BuildingComplete ( building ) ;
34165: LD_VAR 0 1
34169: PPUSH
34170: CALL 64389 0 1
// end ;
34174: PPOPN 1
34176: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34177: LD_VAR 0 1
34181: PPUSH
34182: LD_VAR 0 2
34186: PPUSH
34187: CALL 62444 0 2
// end ;
34191: PPOPN 2
34193: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34194: LD_VAR 0 1
34198: PPUSH
34199: LD_VAR 0 2
34203: PPUSH
34204: LD_VAR 0 3
34208: PPUSH
34209: LD_VAR 0 4
34213: PPUSH
34214: LD_VAR 0 5
34218: PPUSH
34219: CALL 62064 0 5
// end ;
34223: PPOPN 5
34225: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
34226: LD_VAR 0 1
34230: PPUSH
34231: LD_VAR 0 2
34235: PPUSH
34236: CALL 122686 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
34240: LD_VAR 0 1
34244: PPUSH
34245: LD_VAR 0 2
34249: PPUSH
34250: CALL 61655 0 2
// end ;
34254: PPOPN 2
34256: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34257: LD_VAR 0 1
34261: PPUSH
34262: LD_VAR 0 2
34266: PPUSH
34267: LD_VAR 0 3
34271: PPUSH
34272: LD_VAR 0 4
34276: PPUSH
34277: CALL 61493 0 4
// end ;
34281: PPOPN 4
34283: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34284: LD_VAR 0 1
34288: PPUSH
34289: LD_VAR 0 2
34293: PPUSH
34294: LD_VAR 0 3
34298: PPUSH
34299: CALL 61268 0 3
// end ;
34303: PPOPN 3
34305: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34306: LD_VAR 0 1
34310: PPUSH
34311: LD_VAR 0 2
34315: PPUSH
34316: CALL 61153 0 2
// end ;
34320: PPOPN 2
34322: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34323: LD_VAR 0 1
34327: PPUSH
34328: LD_VAR 0 2
34332: PPUSH
34333: CALL 65375 0 2
// end ;
34337: PPOPN 2
34339: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34340: LD_VAR 0 1
34344: PPUSH
34345: CALL_OW 255
34349: PUSH
34350: LD_INT 4
34352: EQUAL
34353: PUSH
34354: LD_VAR 0 1
34358: PUSH
34359: LD_EXP 18
34363: PUSH
34364: LD_INT 1
34366: ARRAY
34367: IN
34368: AND
34369: PUSH
34370: LD_EXP 19
34374: AND
34375: IFFALSE 34394
// begin ComMoveXY ( driver , 61 , 93 ) ;
34377: LD_VAR 0 1
34381: PPUSH
34382: LD_INT 61
34384: PPUSH
34385: LD_INT 93
34387: PPUSH
34388: CALL_OW 111
// exit ;
34392: GO 34418
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34394: LD_VAR 0 1
34398: PPUSH
34399: LD_VAR 0 2
34403: PPUSH
34404: LD_VAR 0 3
34408: PPUSH
34409: LD_VAR 0 4
34413: PPUSH
34414: CALL 65591 0 4
// end ;
34418: PPOPN 4
34420: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34421: LD_VAR 0 1
34425: PPUSH
34426: LD_VAR 0 2
34430: PPUSH
34431: CALL 60962 0 2
// end ;
34435: PPOPN 2
34437: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34438: LD_VAR 0 1
34442: PPUSH
34443: CALL 122670 0 1
// end ; end_of_file
34447: PPOPN 1
34449: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34450: LD_EXP 15
34454: PUSH
34455: LD_INT 2
34457: EQUAL
34458: IFFALSE 34941
34460: GO 34462
34462: DISABLE
34463: LD_INT 0
34465: PPUSH
// begin time := 0 0$40 ;
34466: LD_ADDR_VAR 0 1
34470: PUSH
34471: LD_INT 1400
34473: ST_TO_ADDR
// repeat wait ( time ) ;
34474: LD_VAR 0 1
34478: PPUSH
34479: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34483: LD_INT 1
34485: PPUSH
34486: LD_INT 5
34488: PPUSH
34489: CALL_OW 12
34493: PPUSH
34494: LD_INT 106
34496: PPUSH
34497: LD_INT 150
34499: PPUSH
34500: LD_INT 19
34502: PPUSH
34503: LD_INT 1
34505: PPUSH
34506: CALL_OW 56
// time := time + 0 0$9 ;
34510: LD_ADDR_VAR 0 1
34514: PUSH
34515: LD_VAR 0 1
34519: PUSH
34520: LD_INT 315
34522: PLUS
34523: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34524: LD_INT 455
34526: PPUSH
34527: LD_INT 840
34529: PPUSH
34530: CALL_OW 12
34534: PPUSH
34535: CALL_OW 67
// if Prob ( 50 ) then
34539: LD_INT 50
34541: PPUSH
34542: CALL_OW 13
34546: IFFALSE 34575
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34548: LD_INT 1
34550: PPUSH
34551: LD_INT 5
34553: PPUSH
34554: CALL_OW 12
34558: PPUSH
34559: LD_INT 62
34561: PPUSH
34562: LD_INT 108
34564: PPUSH
34565: LD_INT 10
34567: PPUSH
34568: LD_INT 1
34570: PPUSH
34571: CALL_OW 56
// until missionStage > 4 ;
34575: LD_EXP 15
34579: PUSH
34580: LD_INT 4
34582: GREATER
34583: IFFALSE 34474
// repeat wait ( 0 0$1 ) ;
34585: LD_INT 35
34587: PPUSH
34588: CALL_OW 67
// until missionStage = 6 ;
34592: LD_EXP 15
34596: PUSH
34597: LD_INT 6
34599: EQUAL
34600: IFFALSE 34585
// time := 0 0$50 ;
34602: LD_ADDR_VAR 0 1
34606: PUSH
34607: LD_INT 1750
34609: ST_TO_ADDR
// repeat wait ( time ) ;
34610: LD_VAR 0 1
34614: PPUSH
34615: CALL_OW 67
// if Prob ( 50 ) then
34619: LD_INT 50
34621: PPUSH
34622: CALL_OW 13
34626: IFFALSE 34655
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34628: LD_INT 1
34630: PPUSH
34631: LD_INT 5
34633: PPUSH
34634: CALL_OW 12
34638: PPUSH
34639: LD_INT 106
34641: PPUSH
34642: LD_INT 89
34644: PPUSH
34645: LD_INT 45
34647: PPUSH
34648: LD_INT 1
34650: PPUSH
34651: CALL_OW 56
// time := time + 0 0$2 ;
34655: LD_ADDR_VAR 0 1
34659: PUSH
34660: LD_VAR 0 1
34664: PUSH
34665: LD_INT 70
34667: PLUS
34668: ST_TO_ADDR
// if Prob ( 30 ) then
34669: LD_INT 30
34671: PPUSH
34672: CALL_OW 13
34676: IFFALSE 34722
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34678: LD_INT 385
34680: PPUSH
34681: LD_INT 945
34683: PPUSH
34684: CALL_OW 12
34688: PPUSH
34689: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34693: LD_INT 1
34695: PPUSH
34696: LD_INT 5
34698: PPUSH
34699: CALL_OW 12
34703: PPUSH
34704: LD_INT 21
34706: PPUSH
34707: LD_INT 26
34709: PPUSH
34710: LD_INT 12
34712: PPUSH
34713: LD_INT 1
34715: PPUSH
34716: CALL_OW 56
// end else
34720: GO 34758
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34722: LD_INT 700
34724: PPUSH
34725: LD_INT 1225
34727: PPUSH
34728: CALL_OW 12
34732: PPUSH
34733: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34737: LD_INT 1
34739: PPUSH
34740: LD_INT 5
34742: PPUSH
34743: CALL_OW 12
34747: PPUSH
34748: LD_INT 16
34750: PPUSH
34751: LD_INT 1
34753: PPUSH
34754: CALL_OW 55
// end ; if Prob ( 50 ) then
34758: LD_INT 50
34760: PPUSH
34761: CALL_OW 13
34765: IFFALSE 34811
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34767: LD_INT 700
34769: PPUSH
34770: LD_INT 1050
34772: PPUSH
34773: CALL_OW 12
34777: PPUSH
34778: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34782: LD_INT 1
34784: PPUSH
34785: LD_INT 5
34787: PPUSH
34788: CALL_OW 12
34792: PPUSH
34793: LD_INT 181
34795: PPUSH
34796: LD_INT 218
34798: PPUSH
34799: LD_INT 16
34801: PPUSH
34802: LD_INT 1
34804: PPUSH
34805: CALL_OW 56
// end else
34809: GO 34847
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34811: LD_INT 350
34813: PPUSH
34814: LD_INT 525
34816: PPUSH
34817: CALL_OW 12
34821: PPUSH
34822: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34826: LD_INT 1
34828: PPUSH
34829: LD_INT 5
34831: PPUSH
34832: CALL_OW 12
34836: PPUSH
34837: LD_INT 15
34839: PPUSH
34840: LD_INT 1
34842: PPUSH
34843: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34847: LD_INT 45
34849: PUSH
34850: LD_INT 32
34852: PUSH
34853: LD_INT 25
34855: PUSH
34856: LD_INT 22
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: PUSH
34865: LD_OWVAR 67
34869: ARRAY
34870: PPUSH
34871: CALL_OW 13
34875: IFFALSE 34919
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34877: LD_INT 175
34879: PPUSH
34880: LD_INT 315
34882: PPUSH
34883: CALL_OW 12
34887: PPUSH
34888: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34892: LD_INT 1
34894: PPUSH
34895: LD_INT 5
34897: PPUSH
34898: CALL_OW 12
34902: PPUSH
34903: LD_INT 103
34905: PPUSH
34906: LD_INT 140
34908: PPUSH
34909: LD_INT 20
34911: PPUSH
34912: LD_INT 1
34914: PPUSH
34915: CALL_OW 56
// end ; if time > 1 1$20 then
34919: LD_VAR 0 1
34923: PUSH
34924: LD_INT 2800
34926: GREATER
34927: IFFALSE 34937
// time := 0 0$30 ;
34929: LD_ADDR_VAR 0 1
34933: PUSH
34934: LD_INT 1050
34936: ST_TO_ADDR
// until false ;
34937: LD_INT 0
34939: IFFALSE 34610
// end ; end_of_file
34941: PPOPN 1
34943: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34944: LD_EXP 13
34948: PUSH
34949: LD_EXP 15
34953: PUSH
34954: LD_INT 6
34956: GREATEREQUAL
34957: AND
34958: IFFALSE 34995
34960: GO 34962
34962: DISABLE
// begin enable ;
34963: ENABLE
// missionTime := missionTime + 0 0$1 ;
34964: LD_ADDR_EXP 14
34968: PUSH
34969: LD_EXP 14
34973: PUSH
34974: LD_INT 35
34976: PLUS
34977: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34978: LD_ADDR_OWVAR 47
34982: PUSH
34983: LD_STRING #Am15-1
34985: PUSH
34986: LD_EXP 14
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: ST_TO_ADDR
// end ; end_of_file
34995: END
// export function InitNature ; begin
34996: LD_INT 0
34998: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34999: LD_INT 3
35001: PPUSH
35002: LD_INT 3
35004: PPUSH
35005: LD_INT 2
35007: PPUSH
35008: LD_INT 1
35010: PPUSH
35011: LD_INT 1
35013: PPUSH
35014: LD_INT 0
35016: PPUSH
35017: LD_INT 0
35019: PPUSH
35020: LD_INT 20
35022: PPUSH
35023: LD_INT 0
35025: PPUSH
35026: CALL 99790 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
35030: LD_INT 2
35032: PPUSH
35033: LD_INT 1
35035: PPUSH
35036: LD_INT 1
35038: PPUSH
35039: LD_INT 1
35041: PPUSH
35042: LD_INT 1
35044: PPUSH
35045: LD_INT 0
35047: PPUSH
35048: LD_INT 0
35050: PPUSH
35051: LD_INT 21
35053: PPUSH
35054: LD_INT 0
35056: PPUSH
35057: CALL 99790 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35061: LD_INT 4
35063: PPUSH
35064: LD_INT 1
35066: PPUSH
35067: LD_INT 2
35069: PPUSH
35070: LD_INT 4
35072: PPUSH
35073: LD_INT 2
35075: PPUSH
35076: LD_INT 1
35078: PPUSH
35079: LD_INT 0
35081: PPUSH
35082: LD_INT 22
35084: PPUSH
35085: LD_INT 0
35087: PPUSH
35088: CALL 99790 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35092: LD_INT 0
35094: PPUSH
35095: LD_INT 0
35097: PPUSH
35098: LD_INT 0
35100: PPUSH
35101: LD_INT 0
35103: PPUSH
35104: LD_INT 0
35106: PPUSH
35107: LD_INT 0
35109: PPUSH
35110: LD_INT 9
35112: PPUSH
35113: LD_INT 0
35115: PPUSH
35116: LD_INT 23
35118: PPUSH
35119: CALL 99790 0 9
// end ; end_of_file
35123: LD_VAR 0 1
35127: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35128: LD_INT 0
35130: PPUSH
35131: PPUSH
// skirmish := false ;
35132: LD_ADDR_EXP 95
35136: PUSH
35137: LD_INT 0
35139: ST_TO_ADDR
// debug_mc := false ;
35140: LD_ADDR_EXP 96
35144: PUSH
35145: LD_INT 0
35147: ST_TO_ADDR
// mc_bases := [ ] ;
35148: LD_ADDR_EXP 97
35152: PUSH
35153: EMPTY
35154: ST_TO_ADDR
// mc_sides := [ ] ;
35155: LD_ADDR_EXP 123
35159: PUSH
35160: EMPTY
35161: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35162: LD_ADDR_EXP 98
35166: PUSH
35167: EMPTY
35168: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35169: LD_ADDR_EXP 99
35173: PUSH
35174: EMPTY
35175: ST_TO_ADDR
// mc_need_heal := [ ] ;
35176: LD_ADDR_EXP 100
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_healers := [ ] ;
35183: LD_ADDR_EXP 101
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_build_list := [ ] ;
35190: LD_ADDR_EXP 102
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35197: LD_ADDR_EXP 129
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_builders := [ ] ;
35204: LD_ADDR_EXP 103
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_construct_list := [ ] ;
35211: LD_ADDR_EXP 104
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_turret_list := [ ] ;
35218: LD_ADDR_EXP 105
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35225: LD_ADDR_EXP 106
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_miners := [ ] ;
35232: LD_ADDR_EXP 111
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_mines := [ ] ;
35239: LD_ADDR_EXP 110
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_minefields := [ ] ;
35246: LD_ADDR_EXP 112
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_crates := [ ] ;
35253: LD_ADDR_EXP 113
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35260: LD_ADDR_EXP 114
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_crates_area := [ ] ;
35267: LD_ADDR_EXP 115
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_vehicles := [ ] ;
35274: LD_ADDR_EXP 116
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_attack := [ ] ;
35281: LD_ADDR_EXP 117
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_produce := [ ] ;
35288: LD_ADDR_EXP 118
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_defender := [ ] ;
35295: LD_ADDR_EXP 119
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_parking := [ ] ;
35302: LD_ADDR_EXP 121
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35309: LD_ADDR_EXP 107
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35316: LD_ADDR_EXP 109
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_scan := [ ] ;
35323: LD_ADDR_EXP 120
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_scan_area := [ ] ;
35330: LD_ADDR_EXP 122
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_tech := [ ] ;
35337: LD_ADDR_EXP 124
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// mc_class := [ ] ;
35344: LD_ADDR_EXP 138
35348: PUSH
35349: EMPTY
35350: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35351: LD_ADDR_EXP 139
35355: PUSH
35356: EMPTY
35357: ST_TO_ADDR
// mc_is_defending := [ ] ;
35358: LD_ADDR_EXP 140
35362: PUSH
35363: EMPTY
35364: ST_TO_ADDR
// end ;
35365: LD_VAR 0 1
35369: RET
// export function MC_Kill ( base ) ; begin
35370: LD_INT 0
35372: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35373: LD_ADDR_EXP 97
35377: PUSH
35378: LD_EXP 97
35382: PPUSH
35383: LD_VAR 0 1
35387: PPUSH
35388: EMPTY
35389: PPUSH
35390: CALL_OW 1
35394: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35395: LD_ADDR_EXP 98
35399: PUSH
35400: LD_EXP 98
35404: PPUSH
35405: LD_VAR 0 1
35409: PPUSH
35410: EMPTY
35411: PPUSH
35412: CALL_OW 1
35416: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35417: LD_ADDR_EXP 99
35421: PUSH
35422: LD_EXP 99
35426: PPUSH
35427: LD_VAR 0 1
35431: PPUSH
35432: EMPTY
35433: PPUSH
35434: CALL_OW 1
35438: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35439: LD_ADDR_EXP 100
35443: PUSH
35444: LD_EXP 100
35448: PPUSH
35449: LD_VAR 0 1
35453: PPUSH
35454: EMPTY
35455: PPUSH
35456: CALL_OW 1
35460: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35461: LD_ADDR_EXP 101
35465: PUSH
35466: LD_EXP 101
35470: PPUSH
35471: LD_VAR 0 1
35475: PPUSH
35476: EMPTY
35477: PPUSH
35478: CALL_OW 1
35482: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35483: LD_ADDR_EXP 102
35487: PUSH
35488: LD_EXP 102
35492: PPUSH
35493: LD_VAR 0 1
35497: PPUSH
35498: EMPTY
35499: PPUSH
35500: CALL_OW 1
35504: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35505: LD_ADDR_EXP 103
35509: PUSH
35510: LD_EXP 103
35514: PPUSH
35515: LD_VAR 0 1
35519: PPUSH
35520: EMPTY
35521: PPUSH
35522: CALL_OW 1
35526: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35527: LD_ADDR_EXP 104
35531: PUSH
35532: LD_EXP 104
35536: PPUSH
35537: LD_VAR 0 1
35541: PPUSH
35542: EMPTY
35543: PPUSH
35544: CALL_OW 1
35548: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35549: LD_ADDR_EXP 105
35553: PUSH
35554: LD_EXP 105
35558: PPUSH
35559: LD_VAR 0 1
35563: PPUSH
35564: EMPTY
35565: PPUSH
35566: CALL_OW 1
35570: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35571: LD_ADDR_EXP 106
35575: PUSH
35576: LD_EXP 106
35580: PPUSH
35581: LD_VAR 0 1
35585: PPUSH
35586: EMPTY
35587: PPUSH
35588: CALL_OW 1
35592: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35593: LD_ADDR_EXP 107
35597: PUSH
35598: LD_EXP 107
35602: PPUSH
35603: LD_VAR 0 1
35607: PPUSH
35608: EMPTY
35609: PPUSH
35610: CALL_OW 1
35614: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35615: LD_ADDR_EXP 108
35619: PUSH
35620: LD_EXP 108
35624: PPUSH
35625: LD_VAR 0 1
35629: PPUSH
35630: LD_INT 0
35632: PPUSH
35633: CALL_OW 1
35637: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35638: LD_ADDR_EXP 109
35642: PUSH
35643: LD_EXP 109
35647: PPUSH
35648: LD_VAR 0 1
35652: PPUSH
35653: EMPTY
35654: PPUSH
35655: CALL_OW 1
35659: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35660: LD_ADDR_EXP 110
35664: PUSH
35665: LD_EXP 110
35669: PPUSH
35670: LD_VAR 0 1
35674: PPUSH
35675: EMPTY
35676: PPUSH
35677: CALL_OW 1
35681: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35682: LD_ADDR_EXP 111
35686: PUSH
35687: LD_EXP 111
35691: PPUSH
35692: LD_VAR 0 1
35696: PPUSH
35697: EMPTY
35698: PPUSH
35699: CALL_OW 1
35703: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35704: LD_ADDR_EXP 112
35708: PUSH
35709: LD_EXP 112
35713: PPUSH
35714: LD_VAR 0 1
35718: PPUSH
35719: EMPTY
35720: PPUSH
35721: CALL_OW 1
35725: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35726: LD_ADDR_EXP 113
35730: PUSH
35731: LD_EXP 113
35735: PPUSH
35736: LD_VAR 0 1
35740: PPUSH
35741: EMPTY
35742: PPUSH
35743: CALL_OW 1
35747: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35748: LD_ADDR_EXP 114
35752: PUSH
35753: LD_EXP 114
35757: PPUSH
35758: LD_VAR 0 1
35762: PPUSH
35763: EMPTY
35764: PPUSH
35765: CALL_OW 1
35769: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35770: LD_ADDR_EXP 115
35774: PUSH
35775: LD_EXP 115
35779: PPUSH
35780: LD_VAR 0 1
35784: PPUSH
35785: EMPTY
35786: PPUSH
35787: CALL_OW 1
35791: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35792: LD_ADDR_EXP 116
35796: PUSH
35797: LD_EXP 116
35801: PPUSH
35802: LD_VAR 0 1
35806: PPUSH
35807: EMPTY
35808: PPUSH
35809: CALL_OW 1
35813: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35814: LD_ADDR_EXP 117
35818: PUSH
35819: LD_EXP 117
35823: PPUSH
35824: LD_VAR 0 1
35828: PPUSH
35829: EMPTY
35830: PPUSH
35831: CALL_OW 1
35835: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35836: LD_ADDR_EXP 118
35840: PUSH
35841: LD_EXP 118
35845: PPUSH
35846: LD_VAR 0 1
35850: PPUSH
35851: EMPTY
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35858: LD_ADDR_EXP 119
35862: PUSH
35863: LD_EXP 119
35867: PPUSH
35868: LD_VAR 0 1
35872: PPUSH
35873: EMPTY
35874: PPUSH
35875: CALL_OW 1
35879: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35880: LD_ADDR_EXP 120
35884: PUSH
35885: LD_EXP 120
35889: PPUSH
35890: LD_VAR 0 1
35894: PPUSH
35895: EMPTY
35896: PPUSH
35897: CALL_OW 1
35901: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35902: LD_ADDR_EXP 121
35906: PUSH
35907: LD_EXP 121
35911: PPUSH
35912: LD_VAR 0 1
35916: PPUSH
35917: EMPTY
35918: PPUSH
35919: CALL_OW 1
35923: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35924: LD_ADDR_EXP 122
35928: PUSH
35929: LD_EXP 122
35933: PPUSH
35934: LD_VAR 0 1
35938: PPUSH
35939: EMPTY
35940: PPUSH
35941: CALL_OW 1
35945: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35946: LD_ADDR_EXP 124
35950: PUSH
35951: LD_EXP 124
35955: PPUSH
35956: LD_VAR 0 1
35960: PPUSH
35961: EMPTY
35962: PPUSH
35963: CALL_OW 1
35967: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35968: LD_ADDR_EXP 126
35972: PUSH
35973: LD_EXP 126
35977: PPUSH
35978: LD_VAR 0 1
35982: PPUSH
35983: EMPTY
35984: PPUSH
35985: CALL_OW 1
35989: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35990: LD_ADDR_EXP 127
35994: PUSH
35995: LD_EXP 127
35999: PPUSH
36000: LD_VAR 0 1
36004: PPUSH
36005: EMPTY
36006: PPUSH
36007: CALL_OW 1
36011: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36012: LD_ADDR_EXP 128
36016: PUSH
36017: LD_EXP 128
36021: PPUSH
36022: LD_VAR 0 1
36026: PPUSH
36027: EMPTY
36028: PPUSH
36029: CALL_OW 1
36033: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36034: LD_ADDR_EXP 129
36038: PUSH
36039: LD_EXP 129
36043: PPUSH
36044: LD_VAR 0 1
36048: PPUSH
36049: EMPTY
36050: PPUSH
36051: CALL_OW 1
36055: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36056: LD_ADDR_EXP 130
36060: PUSH
36061: LD_EXP 130
36065: PPUSH
36066: LD_VAR 0 1
36070: PPUSH
36071: EMPTY
36072: PPUSH
36073: CALL_OW 1
36077: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36078: LD_ADDR_EXP 131
36082: PUSH
36083: LD_EXP 131
36087: PPUSH
36088: LD_VAR 0 1
36092: PPUSH
36093: EMPTY
36094: PPUSH
36095: CALL_OW 1
36099: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36100: LD_ADDR_EXP 132
36104: PUSH
36105: LD_EXP 132
36109: PPUSH
36110: LD_VAR 0 1
36114: PPUSH
36115: EMPTY
36116: PPUSH
36117: CALL_OW 1
36121: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36122: LD_ADDR_EXP 133
36126: PUSH
36127: LD_EXP 133
36131: PPUSH
36132: LD_VAR 0 1
36136: PPUSH
36137: EMPTY
36138: PPUSH
36139: CALL_OW 1
36143: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36144: LD_ADDR_EXP 134
36148: PUSH
36149: LD_EXP 134
36153: PPUSH
36154: LD_VAR 0 1
36158: PPUSH
36159: EMPTY
36160: PPUSH
36161: CALL_OW 1
36165: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36166: LD_ADDR_EXP 135
36170: PUSH
36171: LD_EXP 135
36175: PPUSH
36176: LD_VAR 0 1
36180: PPUSH
36181: EMPTY
36182: PPUSH
36183: CALL_OW 1
36187: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36188: LD_ADDR_EXP 136
36192: PUSH
36193: LD_EXP 136
36197: PPUSH
36198: LD_VAR 0 1
36202: PPUSH
36203: EMPTY
36204: PPUSH
36205: CALL_OW 1
36209: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36210: LD_ADDR_EXP 137
36214: PUSH
36215: LD_EXP 137
36219: PPUSH
36220: LD_VAR 0 1
36224: PPUSH
36225: EMPTY
36226: PPUSH
36227: CALL_OW 1
36231: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36232: LD_ADDR_EXP 138
36236: PUSH
36237: LD_EXP 138
36241: PPUSH
36242: LD_VAR 0 1
36246: PPUSH
36247: EMPTY
36248: PPUSH
36249: CALL_OW 1
36253: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36254: LD_ADDR_EXP 139
36258: PUSH
36259: LD_EXP 139
36263: PPUSH
36264: LD_VAR 0 1
36268: PPUSH
36269: LD_INT 0
36271: PPUSH
36272: CALL_OW 1
36276: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36277: LD_ADDR_EXP 140
36281: PUSH
36282: LD_EXP 140
36286: PPUSH
36287: LD_VAR 0 1
36291: PPUSH
36292: LD_INT 0
36294: PPUSH
36295: CALL_OW 1
36299: ST_TO_ADDR
// end ;
36300: LD_VAR 0 2
36304: RET
// export function MC_Add ( side , units ) ; var base ; begin
36305: LD_INT 0
36307: PPUSH
36308: PPUSH
// base := mc_bases + 1 ;
36309: LD_ADDR_VAR 0 4
36313: PUSH
36314: LD_EXP 97
36318: PUSH
36319: LD_INT 1
36321: PLUS
36322: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36323: LD_ADDR_EXP 123
36327: PUSH
36328: LD_EXP 123
36332: PPUSH
36333: LD_VAR 0 4
36337: PPUSH
36338: LD_VAR 0 1
36342: PPUSH
36343: CALL_OW 1
36347: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36348: LD_ADDR_EXP 97
36352: PUSH
36353: LD_EXP 97
36357: PPUSH
36358: LD_VAR 0 4
36362: PPUSH
36363: LD_VAR 0 2
36367: PPUSH
36368: CALL_OW 1
36372: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36373: LD_ADDR_EXP 98
36377: PUSH
36378: LD_EXP 98
36382: PPUSH
36383: LD_VAR 0 4
36387: PPUSH
36388: EMPTY
36389: PPUSH
36390: CALL_OW 1
36394: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36395: LD_ADDR_EXP 99
36399: PUSH
36400: LD_EXP 99
36404: PPUSH
36405: LD_VAR 0 4
36409: PPUSH
36410: EMPTY
36411: PPUSH
36412: CALL_OW 1
36416: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36417: LD_ADDR_EXP 100
36421: PUSH
36422: LD_EXP 100
36426: PPUSH
36427: LD_VAR 0 4
36431: PPUSH
36432: EMPTY
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36439: LD_ADDR_EXP 101
36443: PUSH
36444: LD_EXP 101
36448: PPUSH
36449: LD_VAR 0 4
36453: PPUSH
36454: EMPTY
36455: PPUSH
36456: CALL_OW 1
36460: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36461: LD_ADDR_EXP 102
36465: PUSH
36466: LD_EXP 102
36470: PPUSH
36471: LD_VAR 0 4
36475: PPUSH
36476: EMPTY
36477: PPUSH
36478: CALL_OW 1
36482: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36483: LD_ADDR_EXP 103
36487: PUSH
36488: LD_EXP 103
36492: PPUSH
36493: LD_VAR 0 4
36497: PPUSH
36498: EMPTY
36499: PPUSH
36500: CALL_OW 1
36504: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36505: LD_ADDR_EXP 104
36509: PUSH
36510: LD_EXP 104
36514: PPUSH
36515: LD_VAR 0 4
36519: PPUSH
36520: EMPTY
36521: PPUSH
36522: CALL_OW 1
36526: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36527: LD_ADDR_EXP 105
36531: PUSH
36532: LD_EXP 105
36536: PPUSH
36537: LD_VAR 0 4
36541: PPUSH
36542: EMPTY
36543: PPUSH
36544: CALL_OW 1
36548: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36549: LD_ADDR_EXP 106
36553: PUSH
36554: LD_EXP 106
36558: PPUSH
36559: LD_VAR 0 4
36563: PPUSH
36564: EMPTY
36565: PPUSH
36566: CALL_OW 1
36570: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36571: LD_ADDR_EXP 107
36575: PUSH
36576: LD_EXP 107
36580: PPUSH
36581: LD_VAR 0 4
36585: PPUSH
36586: EMPTY
36587: PPUSH
36588: CALL_OW 1
36592: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36593: LD_ADDR_EXP 108
36597: PUSH
36598: LD_EXP 108
36602: PPUSH
36603: LD_VAR 0 4
36607: PPUSH
36608: LD_INT 0
36610: PPUSH
36611: CALL_OW 1
36615: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36616: LD_ADDR_EXP 109
36620: PUSH
36621: LD_EXP 109
36625: PPUSH
36626: LD_VAR 0 4
36630: PPUSH
36631: EMPTY
36632: PPUSH
36633: CALL_OW 1
36637: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36638: LD_ADDR_EXP 110
36642: PUSH
36643: LD_EXP 110
36647: PPUSH
36648: LD_VAR 0 4
36652: PPUSH
36653: EMPTY
36654: PPUSH
36655: CALL_OW 1
36659: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36660: LD_ADDR_EXP 111
36664: PUSH
36665: LD_EXP 111
36669: PPUSH
36670: LD_VAR 0 4
36674: PPUSH
36675: EMPTY
36676: PPUSH
36677: CALL_OW 1
36681: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36682: LD_ADDR_EXP 112
36686: PUSH
36687: LD_EXP 112
36691: PPUSH
36692: LD_VAR 0 4
36696: PPUSH
36697: EMPTY
36698: PPUSH
36699: CALL_OW 1
36703: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36704: LD_ADDR_EXP 113
36708: PUSH
36709: LD_EXP 113
36713: PPUSH
36714: LD_VAR 0 4
36718: PPUSH
36719: EMPTY
36720: PPUSH
36721: CALL_OW 1
36725: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36726: LD_ADDR_EXP 114
36730: PUSH
36731: LD_EXP 114
36735: PPUSH
36736: LD_VAR 0 4
36740: PPUSH
36741: EMPTY
36742: PPUSH
36743: CALL_OW 1
36747: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36748: LD_ADDR_EXP 115
36752: PUSH
36753: LD_EXP 115
36757: PPUSH
36758: LD_VAR 0 4
36762: PPUSH
36763: EMPTY
36764: PPUSH
36765: CALL_OW 1
36769: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36770: LD_ADDR_EXP 116
36774: PUSH
36775: LD_EXP 116
36779: PPUSH
36780: LD_VAR 0 4
36784: PPUSH
36785: EMPTY
36786: PPUSH
36787: CALL_OW 1
36791: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36792: LD_ADDR_EXP 117
36796: PUSH
36797: LD_EXP 117
36801: PPUSH
36802: LD_VAR 0 4
36806: PPUSH
36807: EMPTY
36808: PPUSH
36809: CALL_OW 1
36813: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36814: LD_ADDR_EXP 118
36818: PUSH
36819: LD_EXP 118
36823: PPUSH
36824: LD_VAR 0 4
36828: PPUSH
36829: EMPTY
36830: PPUSH
36831: CALL_OW 1
36835: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36836: LD_ADDR_EXP 119
36840: PUSH
36841: LD_EXP 119
36845: PPUSH
36846: LD_VAR 0 4
36850: PPUSH
36851: EMPTY
36852: PPUSH
36853: CALL_OW 1
36857: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36858: LD_ADDR_EXP 120
36862: PUSH
36863: LD_EXP 120
36867: PPUSH
36868: LD_VAR 0 4
36872: PPUSH
36873: EMPTY
36874: PPUSH
36875: CALL_OW 1
36879: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36880: LD_ADDR_EXP 121
36884: PUSH
36885: LD_EXP 121
36889: PPUSH
36890: LD_VAR 0 4
36894: PPUSH
36895: EMPTY
36896: PPUSH
36897: CALL_OW 1
36901: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36902: LD_ADDR_EXP 122
36906: PUSH
36907: LD_EXP 122
36911: PPUSH
36912: LD_VAR 0 4
36916: PPUSH
36917: EMPTY
36918: PPUSH
36919: CALL_OW 1
36923: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36924: LD_ADDR_EXP 124
36928: PUSH
36929: LD_EXP 124
36933: PPUSH
36934: LD_VAR 0 4
36938: PPUSH
36939: EMPTY
36940: PPUSH
36941: CALL_OW 1
36945: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36946: LD_ADDR_EXP 126
36950: PUSH
36951: LD_EXP 126
36955: PPUSH
36956: LD_VAR 0 4
36960: PPUSH
36961: EMPTY
36962: PPUSH
36963: CALL_OW 1
36967: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36968: LD_ADDR_EXP 127
36972: PUSH
36973: LD_EXP 127
36977: PPUSH
36978: LD_VAR 0 4
36982: PPUSH
36983: EMPTY
36984: PPUSH
36985: CALL_OW 1
36989: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36990: LD_ADDR_EXP 128
36994: PUSH
36995: LD_EXP 128
36999: PPUSH
37000: LD_VAR 0 4
37004: PPUSH
37005: EMPTY
37006: PPUSH
37007: CALL_OW 1
37011: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37012: LD_ADDR_EXP 129
37016: PUSH
37017: LD_EXP 129
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: EMPTY
37028: PPUSH
37029: CALL_OW 1
37033: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37034: LD_ADDR_EXP 130
37038: PUSH
37039: LD_EXP 130
37043: PPUSH
37044: LD_VAR 0 4
37048: PPUSH
37049: EMPTY
37050: PPUSH
37051: CALL_OW 1
37055: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37056: LD_ADDR_EXP 131
37060: PUSH
37061: LD_EXP 131
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: EMPTY
37072: PPUSH
37073: CALL_OW 1
37077: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37078: LD_ADDR_EXP 132
37082: PUSH
37083: LD_EXP 132
37087: PPUSH
37088: LD_VAR 0 4
37092: PPUSH
37093: EMPTY
37094: PPUSH
37095: CALL_OW 1
37099: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37100: LD_ADDR_EXP 133
37104: PUSH
37105: LD_EXP 133
37109: PPUSH
37110: LD_VAR 0 4
37114: PPUSH
37115: EMPTY
37116: PPUSH
37117: CALL_OW 1
37121: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37122: LD_ADDR_EXP 134
37126: PUSH
37127: LD_EXP 134
37131: PPUSH
37132: LD_VAR 0 4
37136: PPUSH
37137: EMPTY
37138: PPUSH
37139: CALL_OW 1
37143: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37144: LD_ADDR_EXP 135
37148: PUSH
37149: LD_EXP 135
37153: PPUSH
37154: LD_VAR 0 4
37158: PPUSH
37159: EMPTY
37160: PPUSH
37161: CALL_OW 1
37165: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37166: LD_ADDR_EXP 136
37170: PUSH
37171: LD_EXP 136
37175: PPUSH
37176: LD_VAR 0 4
37180: PPUSH
37181: EMPTY
37182: PPUSH
37183: CALL_OW 1
37187: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37188: LD_ADDR_EXP 137
37192: PUSH
37193: LD_EXP 137
37197: PPUSH
37198: LD_VAR 0 4
37202: PPUSH
37203: EMPTY
37204: PPUSH
37205: CALL_OW 1
37209: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37210: LD_ADDR_EXP 138
37214: PUSH
37215: LD_EXP 138
37219: PPUSH
37220: LD_VAR 0 4
37224: PPUSH
37225: EMPTY
37226: PPUSH
37227: CALL_OW 1
37231: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37232: LD_ADDR_EXP 139
37236: PUSH
37237: LD_EXP 139
37241: PPUSH
37242: LD_VAR 0 4
37246: PPUSH
37247: LD_INT 0
37249: PPUSH
37250: CALL_OW 1
37254: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37255: LD_ADDR_EXP 140
37259: PUSH
37260: LD_EXP 140
37264: PPUSH
37265: LD_VAR 0 4
37269: PPUSH
37270: LD_INT 0
37272: PPUSH
37273: CALL_OW 1
37277: ST_TO_ADDR
// result := base ;
37278: LD_ADDR_VAR 0 3
37282: PUSH
37283: LD_VAR 0 4
37287: ST_TO_ADDR
// end ;
37288: LD_VAR 0 3
37292: RET
// export function MC_Start ( ) ; var i ; begin
37293: LD_INT 0
37295: PPUSH
37296: PPUSH
// for i = 1 to mc_bases do
37297: LD_ADDR_VAR 0 2
37301: PUSH
37302: DOUBLE
37303: LD_INT 1
37305: DEC
37306: ST_TO_ADDR
37307: LD_EXP 97
37311: PUSH
37312: FOR_TO
37313: IFFALSE 38413
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37315: LD_ADDR_EXP 97
37319: PUSH
37320: LD_EXP 97
37324: PPUSH
37325: LD_VAR 0 2
37329: PPUSH
37330: LD_EXP 97
37334: PUSH
37335: LD_VAR 0 2
37339: ARRAY
37340: PUSH
37341: LD_INT 0
37343: DIFF
37344: PPUSH
37345: CALL_OW 1
37349: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37350: LD_ADDR_EXP 98
37354: PUSH
37355: LD_EXP 98
37359: PPUSH
37360: LD_VAR 0 2
37364: PPUSH
37365: EMPTY
37366: PPUSH
37367: CALL_OW 1
37371: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37372: LD_ADDR_EXP 99
37376: PUSH
37377: LD_EXP 99
37381: PPUSH
37382: LD_VAR 0 2
37386: PPUSH
37387: EMPTY
37388: PPUSH
37389: CALL_OW 1
37393: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37394: LD_ADDR_EXP 100
37398: PUSH
37399: LD_EXP 100
37403: PPUSH
37404: LD_VAR 0 2
37408: PPUSH
37409: EMPTY
37410: PPUSH
37411: CALL_OW 1
37415: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37416: LD_ADDR_EXP 101
37420: PUSH
37421: LD_EXP 101
37425: PPUSH
37426: LD_VAR 0 2
37430: PPUSH
37431: EMPTY
37432: PUSH
37433: EMPTY
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PPUSH
37439: CALL_OW 1
37443: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37444: LD_ADDR_EXP 102
37448: PUSH
37449: LD_EXP 102
37453: PPUSH
37454: LD_VAR 0 2
37458: PPUSH
37459: EMPTY
37460: PPUSH
37461: CALL_OW 1
37465: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37466: LD_ADDR_EXP 129
37470: PUSH
37471: LD_EXP 129
37475: PPUSH
37476: LD_VAR 0 2
37480: PPUSH
37481: EMPTY
37482: PPUSH
37483: CALL_OW 1
37487: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37488: LD_ADDR_EXP 103
37492: PUSH
37493: LD_EXP 103
37497: PPUSH
37498: LD_VAR 0 2
37502: PPUSH
37503: EMPTY
37504: PPUSH
37505: CALL_OW 1
37509: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37510: LD_ADDR_EXP 104
37514: PUSH
37515: LD_EXP 104
37519: PPUSH
37520: LD_VAR 0 2
37524: PPUSH
37525: EMPTY
37526: PPUSH
37527: CALL_OW 1
37531: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37532: LD_ADDR_EXP 105
37536: PUSH
37537: LD_EXP 105
37541: PPUSH
37542: LD_VAR 0 2
37546: PPUSH
37547: LD_EXP 97
37551: PUSH
37552: LD_VAR 0 2
37556: ARRAY
37557: PPUSH
37558: LD_INT 2
37560: PUSH
37561: LD_INT 30
37563: PUSH
37564: LD_INT 32
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 30
37573: PUSH
37574: LD_INT 33
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: LIST
37585: PPUSH
37586: CALL_OW 72
37590: PPUSH
37591: CALL_OW 1
37595: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37596: LD_ADDR_EXP 106
37600: PUSH
37601: LD_EXP 106
37605: PPUSH
37606: LD_VAR 0 2
37610: PPUSH
37611: LD_EXP 97
37615: PUSH
37616: LD_VAR 0 2
37620: ARRAY
37621: PPUSH
37622: LD_INT 2
37624: PUSH
37625: LD_INT 30
37627: PUSH
37628: LD_INT 32
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 30
37637: PUSH
37638: LD_INT 31
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 58
37652: PUSH
37653: EMPTY
37654: LIST
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PPUSH
37660: CALL_OW 72
37664: PPUSH
37665: CALL_OW 1
37669: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37670: LD_ADDR_EXP 107
37674: PUSH
37675: LD_EXP 107
37679: PPUSH
37680: LD_VAR 0 2
37684: PPUSH
37685: EMPTY
37686: PPUSH
37687: CALL_OW 1
37691: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37692: LD_ADDR_EXP 111
37696: PUSH
37697: LD_EXP 111
37701: PPUSH
37702: LD_VAR 0 2
37706: PPUSH
37707: EMPTY
37708: PPUSH
37709: CALL_OW 1
37713: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37714: LD_ADDR_EXP 110
37718: PUSH
37719: LD_EXP 110
37723: PPUSH
37724: LD_VAR 0 2
37728: PPUSH
37729: EMPTY
37730: PPUSH
37731: CALL_OW 1
37735: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37736: LD_ADDR_EXP 112
37740: PUSH
37741: LD_EXP 112
37745: PPUSH
37746: LD_VAR 0 2
37750: PPUSH
37751: EMPTY
37752: PPUSH
37753: CALL_OW 1
37757: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37758: LD_ADDR_EXP 113
37762: PUSH
37763: LD_EXP 113
37767: PPUSH
37768: LD_VAR 0 2
37772: PPUSH
37773: EMPTY
37774: PPUSH
37775: CALL_OW 1
37779: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37780: LD_ADDR_EXP 114
37784: PUSH
37785: LD_EXP 114
37789: PPUSH
37790: LD_VAR 0 2
37794: PPUSH
37795: EMPTY
37796: PPUSH
37797: CALL_OW 1
37801: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37802: LD_ADDR_EXP 115
37806: PUSH
37807: LD_EXP 115
37811: PPUSH
37812: LD_VAR 0 2
37816: PPUSH
37817: EMPTY
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37824: LD_ADDR_EXP 116
37828: PUSH
37829: LD_EXP 116
37833: PPUSH
37834: LD_VAR 0 2
37838: PPUSH
37839: EMPTY
37840: PPUSH
37841: CALL_OW 1
37845: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37846: LD_ADDR_EXP 117
37850: PUSH
37851: LD_EXP 117
37855: PPUSH
37856: LD_VAR 0 2
37860: PPUSH
37861: EMPTY
37862: PPUSH
37863: CALL_OW 1
37867: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37868: LD_ADDR_EXP 118
37872: PUSH
37873: LD_EXP 118
37877: PPUSH
37878: LD_VAR 0 2
37882: PPUSH
37883: EMPTY
37884: PPUSH
37885: CALL_OW 1
37889: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37890: LD_ADDR_EXP 119
37894: PUSH
37895: LD_EXP 119
37899: PPUSH
37900: LD_VAR 0 2
37904: PPUSH
37905: EMPTY
37906: PPUSH
37907: CALL_OW 1
37911: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37912: LD_ADDR_EXP 108
37916: PUSH
37917: LD_EXP 108
37921: PPUSH
37922: LD_VAR 0 2
37926: PPUSH
37927: LD_INT 0
37929: PPUSH
37930: CALL_OW 1
37934: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37935: LD_ADDR_EXP 121
37939: PUSH
37940: LD_EXP 121
37944: PPUSH
37945: LD_VAR 0 2
37949: PPUSH
37950: LD_INT 0
37952: PPUSH
37953: CALL_OW 1
37957: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37958: LD_ADDR_EXP 109
37962: PUSH
37963: LD_EXP 109
37967: PPUSH
37968: LD_VAR 0 2
37972: PPUSH
37973: EMPTY
37974: PPUSH
37975: CALL_OW 1
37979: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37980: LD_ADDR_EXP 120
37984: PUSH
37985: LD_EXP 120
37989: PPUSH
37990: LD_VAR 0 2
37994: PPUSH
37995: LD_INT 0
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38003: LD_ADDR_EXP 122
38007: PUSH
38008: LD_EXP 122
38012: PPUSH
38013: LD_VAR 0 2
38017: PPUSH
38018: EMPTY
38019: PPUSH
38020: CALL_OW 1
38024: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38025: LD_ADDR_EXP 125
38029: PUSH
38030: LD_EXP 125
38034: PPUSH
38035: LD_VAR 0 2
38039: PPUSH
38040: LD_INT 0
38042: PPUSH
38043: CALL_OW 1
38047: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38048: LD_ADDR_EXP 126
38052: PUSH
38053: LD_EXP 126
38057: PPUSH
38058: LD_VAR 0 2
38062: PPUSH
38063: EMPTY
38064: PPUSH
38065: CALL_OW 1
38069: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38070: LD_ADDR_EXP 127
38074: PUSH
38075: LD_EXP 127
38079: PPUSH
38080: LD_VAR 0 2
38084: PPUSH
38085: EMPTY
38086: PPUSH
38087: CALL_OW 1
38091: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38092: LD_ADDR_EXP 128
38096: PUSH
38097: LD_EXP 128
38101: PPUSH
38102: LD_VAR 0 2
38106: PPUSH
38107: EMPTY
38108: PPUSH
38109: CALL_OW 1
38113: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38114: LD_ADDR_EXP 130
38118: PUSH
38119: LD_EXP 130
38123: PPUSH
38124: LD_VAR 0 2
38128: PPUSH
38129: LD_EXP 97
38133: PUSH
38134: LD_VAR 0 2
38138: ARRAY
38139: PPUSH
38140: LD_INT 2
38142: PUSH
38143: LD_INT 30
38145: PUSH
38146: LD_INT 6
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 30
38155: PUSH
38156: LD_INT 7
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: LD_INT 30
38165: PUSH
38166: LD_INT 8
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: PPUSH
38179: CALL_OW 72
38183: PPUSH
38184: CALL_OW 1
38188: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38189: LD_ADDR_EXP 131
38193: PUSH
38194: LD_EXP 131
38198: PPUSH
38199: LD_VAR 0 2
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL_OW 1
38210: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38211: LD_ADDR_EXP 132
38215: PUSH
38216: LD_EXP 132
38220: PPUSH
38221: LD_VAR 0 2
38225: PPUSH
38226: EMPTY
38227: PPUSH
38228: CALL_OW 1
38232: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38233: LD_ADDR_EXP 133
38237: PUSH
38238: LD_EXP 133
38242: PPUSH
38243: LD_VAR 0 2
38247: PPUSH
38248: EMPTY
38249: PPUSH
38250: CALL_OW 1
38254: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38255: LD_ADDR_EXP 134
38259: PUSH
38260: LD_EXP 134
38264: PPUSH
38265: LD_VAR 0 2
38269: PPUSH
38270: EMPTY
38271: PPUSH
38272: CALL_OW 1
38276: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38277: LD_ADDR_EXP 135
38281: PUSH
38282: LD_EXP 135
38286: PPUSH
38287: LD_VAR 0 2
38291: PPUSH
38292: EMPTY
38293: PPUSH
38294: CALL_OW 1
38298: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38299: LD_ADDR_EXP 136
38303: PUSH
38304: LD_EXP 136
38308: PPUSH
38309: LD_VAR 0 2
38313: PPUSH
38314: EMPTY
38315: PPUSH
38316: CALL_OW 1
38320: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38321: LD_ADDR_EXP 137
38325: PUSH
38326: LD_EXP 137
38330: PPUSH
38331: LD_VAR 0 2
38335: PPUSH
38336: EMPTY
38337: PPUSH
38338: CALL_OW 1
38342: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38343: LD_ADDR_EXP 138
38347: PUSH
38348: LD_EXP 138
38352: PPUSH
38353: LD_VAR 0 2
38357: PPUSH
38358: EMPTY
38359: PPUSH
38360: CALL_OW 1
38364: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38365: LD_ADDR_EXP 139
38369: PUSH
38370: LD_EXP 139
38374: PPUSH
38375: LD_VAR 0 2
38379: PPUSH
38380: LD_INT 0
38382: PPUSH
38383: CALL_OW 1
38387: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38388: LD_ADDR_EXP 140
38392: PUSH
38393: LD_EXP 140
38397: PPUSH
38398: LD_VAR 0 2
38402: PPUSH
38403: LD_INT 0
38405: PPUSH
38406: CALL_OW 1
38410: ST_TO_ADDR
// end ;
38411: GO 37312
38413: POP
38414: POP
// MC_InitSides ( ) ;
38415: CALL 38701 0 0
// MC_InitResearch ( ) ;
38419: CALL 38440 0 0
// CustomInitMacro ( ) ;
38423: CALL 467 0 0
// skirmish := true ;
38427: LD_ADDR_EXP 95
38431: PUSH
38432: LD_INT 1
38434: ST_TO_ADDR
// end ;
38435: LD_VAR 0 1
38439: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38440: LD_INT 0
38442: PPUSH
38443: PPUSH
38444: PPUSH
38445: PPUSH
38446: PPUSH
38447: PPUSH
// if not mc_bases then
38448: LD_EXP 97
38452: NOT
38453: IFFALSE 38457
// exit ;
38455: GO 38696
// for i = 1 to 8 do
38457: LD_ADDR_VAR 0 2
38461: PUSH
38462: DOUBLE
38463: LD_INT 1
38465: DEC
38466: ST_TO_ADDR
38467: LD_INT 8
38469: PUSH
38470: FOR_TO
38471: IFFALSE 38497
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38473: LD_ADDR_EXP 124
38477: PUSH
38478: LD_EXP 124
38482: PPUSH
38483: LD_VAR 0 2
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL_OW 1
38494: ST_TO_ADDR
38495: GO 38470
38497: POP
38498: POP
// tmp := [ ] ;
38499: LD_ADDR_VAR 0 5
38503: PUSH
38504: EMPTY
38505: ST_TO_ADDR
// for i = 1 to mc_sides do
38506: LD_ADDR_VAR 0 2
38510: PUSH
38511: DOUBLE
38512: LD_INT 1
38514: DEC
38515: ST_TO_ADDR
38516: LD_EXP 123
38520: PUSH
38521: FOR_TO
38522: IFFALSE 38580
// if not mc_sides [ i ] in tmp then
38524: LD_EXP 123
38528: PUSH
38529: LD_VAR 0 2
38533: ARRAY
38534: PUSH
38535: LD_VAR 0 5
38539: IN
38540: NOT
38541: IFFALSE 38578
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38543: LD_ADDR_VAR 0 5
38547: PUSH
38548: LD_VAR 0 5
38552: PPUSH
38553: LD_VAR 0 5
38557: PUSH
38558: LD_INT 1
38560: PLUS
38561: PPUSH
38562: LD_EXP 123
38566: PUSH
38567: LD_VAR 0 2
38571: ARRAY
38572: PPUSH
38573: CALL_OW 2
38577: ST_TO_ADDR
38578: GO 38521
38580: POP
38581: POP
// if not tmp then
38582: LD_VAR 0 5
38586: NOT
38587: IFFALSE 38591
// exit ;
38589: GO 38696
// for j in tmp do
38591: LD_ADDR_VAR 0 3
38595: PUSH
38596: LD_VAR 0 5
38600: PUSH
38601: FOR_IN
38602: IFFALSE 38694
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38604: LD_ADDR_VAR 0 6
38608: PUSH
38609: LD_INT 22
38611: PUSH
38612: LD_VAR 0 3
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PPUSH
38621: CALL_OW 69
38625: ST_TO_ADDR
// if not un then
38626: LD_VAR 0 6
38630: NOT
38631: IFFALSE 38635
// continue ;
38633: GO 38601
// nation := GetNation ( un [ 1 ] ) ;
38635: LD_ADDR_VAR 0 4
38639: PUSH
38640: LD_VAR 0 6
38644: PUSH
38645: LD_INT 1
38647: ARRAY
38648: PPUSH
38649: CALL_OW 248
38653: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38654: LD_ADDR_EXP 124
38658: PUSH
38659: LD_EXP 124
38663: PPUSH
38664: LD_VAR 0 3
38668: PPUSH
38669: LD_VAR 0 3
38673: PPUSH
38674: LD_VAR 0 4
38678: PPUSH
38679: LD_INT 1
38681: PPUSH
38682: CALL 65795 0 3
38686: PPUSH
38687: CALL_OW 1
38691: ST_TO_ADDR
// end ;
38692: GO 38601
38694: POP
38695: POP
// end ;
38696: LD_VAR 0 1
38700: RET
// export function MC_InitSides ( ) ; var i ; begin
38701: LD_INT 0
38703: PPUSH
38704: PPUSH
// if not mc_bases then
38705: LD_EXP 97
38709: NOT
38710: IFFALSE 38714
// exit ;
38712: GO 38788
// for i = 1 to mc_bases do
38714: LD_ADDR_VAR 0 2
38718: PUSH
38719: DOUBLE
38720: LD_INT 1
38722: DEC
38723: ST_TO_ADDR
38724: LD_EXP 97
38728: PUSH
38729: FOR_TO
38730: IFFALSE 38786
// if mc_bases [ i ] then
38732: LD_EXP 97
38736: PUSH
38737: LD_VAR 0 2
38741: ARRAY
38742: IFFALSE 38784
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38744: LD_ADDR_EXP 123
38748: PUSH
38749: LD_EXP 123
38753: PPUSH
38754: LD_VAR 0 2
38758: PPUSH
38759: LD_EXP 97
38763: PUSH
38764: LD_VAR 0 2
38768: ARRAY
38769: PUSH
38770: LD_INT 1
38772: ARRAY
38773: PPUSH
38774: CALL_OW 255
38778: PPUSH
38779: CALL_OW 1
38783: ST_TO_ADDR
38784: GO 38729
38786: POP
38787: POP
// end ;
38788: LD_VAR 0 1
38792: RET
// every 0 0$03 trigger skirmish do
38793: LD_EXP 95
38797: IFFALSE 38951
38799: GO 38801
38801: DISABLE
// begin enable ;
38802: ENABLE
// MC_CheckBuildings ( ) ;
38803: CALL 43449 0 0
// MC_CheckPeopleLife ( ) ;
38807: CALL 43610 0 0
// RaiseSailEvent ( 100 ) ;
38811: LD_INT 100
38813: PPUSH
38814: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38818: LD_INT 103
38820: PPUSH
38821: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38825: LD_INT 104
38827: PPUSH
38828: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38832: LD_INT 105
38834: PPUSH
38835: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38839: LD_INT 106
38841: PPUSH
38842: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38846: LD_INT 107
38848: PPUSH
38849: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38853: LD_INT 108
38855: PPUSH
38856: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38860: LD_INT 109
38862: PPUSH
38863: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38867: LD_INT 110
38869: PPUSH
38870: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38874: LD_INT 111
38876: PPUSH
38877: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38881: LD_INT 112
38883: PPUSH
38884: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38888: LD_INT 113
38890: PPUSH
38891: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38895: LD_INT 120
38897: PPUSH
38898: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38902: LD_INT 121
38904: PPUSH
38905: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38909: LD_INT 122
38911: PPUSH
38912: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38916: LD_INT 123
38918: PPUSH
38919: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38923: LD_INT 124
38925: PPUSH
38926: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38930: LD_INT 125
38932: PPUSH
38933: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38937: LD_INT 126
38939: PPUSH
38940: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38944: LD_INT 200
38946: PPUSH
38947: CALL_OW 427
// end ;
38951: END
// on SailEvent ( event ) do begin if event < 100 then
38952: LD_VAR 0 1
38956: PUSH
38957: LD_INT 100
38959: LESS
38960: IFFALSE 38971
// CustomEvent ( event ) ;
38962: LD_VAR 0 1
38966: PPUSH
38967: CALL 33572 0 1
// if event = 100 then
38971: LD_VAR 0 1
38975: PUSH
38976: LD_INT 100
38978: EQUAL
38979: IFFALSE 38985
// MC_ClassManager ( ) ;
38981: CALL 39377 0 0
// if event = 101 then
38985: LD_VAR 0 1
38989: PUSH
38990: LD_INT 101
38992: EQUAL
38993: IFFALSE 38999
// MC_RepairBuildings ( ) ;
38995: CALL 44195 0 0
// if event = 102 then
38999: LD_VAR 0 1
39003: PUSH
39004: LD_INT 102
39006: EQUAL
39007: IFFALSE 39013
// MC_Heal ( ) ;
39009: CALL 45098 0 0
// if event = 103 then
39013: LD_VAR 0 1
39017: PUSH
39018: LD_INT 103
39020: EQUAL
39021: IFFALSE 39027
// MC_Build ( ) ;
39023: CALL 45520 0 0
// if event = 104 then
39027: LD_VAR 0 1
39031: PUSH
39032: LD_INT 104
39034: EQUAL
39035: IFFALSE 39041
// MC_TurretWeapon ( ) ;
39037: CALL 47161 0 0
// if event = 105 then
39041: LD_VAR 0 1
39045: PUSH
39046: LD_INT 105
39048: EQUAL
39049: IFFALSE 39055
// MC_BuildUpgrade ( ) ;
39051: CALL 46712 0 0
// if event = 106 then
39055: LD_VAR 0 1
39059: PUSH
39060: LD_INT 106
39062: EQUAL
39063: IFFALSE 39069
// MC_PlantMines ( ) ;
39065: CALL 47591 0 0
// if event = 107 then
39069: LD_VAR 0 1
39073: PUSH
39074: LD_INT 107
39076: EQUAL
39077: IFFALSE 39083
// MC_CollectCrates ( ) ;
39079: CALL 48382 0 0
// if event = 108 then
39083: LD_VAR 0 1
39087: PUSH
39088: LD_INT 108
39090: EQUAL
39091: IFFALSE 39097
// MC_LinkRemoteControl ( ) ;
39093: CALL 50232 0 0
// if event = 109 then
39097: LD_VAR 0 1
39101: PUSH
39102: LD_INT 109
39104: EQUAL
39105: IFFALSE 39111
// MC_ProduceVehicle ( ) ;
39107: CALL 50413 0 0
// if event = 110 then
39111: LD_VAR 0 1
39115: PUSH
39116: LD_INT 110
39118: EQUAL
39119: IFFALSE 39125
// MC_SendAttack ( ) ;
39121: CALL 50879 0 0
// if event = 111 then
39125: LD_VAR 0 1
39129: PUSH
39130: LD_INT 111
39132: EQUAL
39133: IFFALSE 39139
// MC_Defend ( ) ;
39135: CALL 50987 0 0
// if event = 112 then
39139: LD_VAR 0 1
39143: PUSH
39144: LD_INT 112
39146: EQUAL
39147: IFFALSE 39153
// MC_Research ( ) ;
39149: CALL 51867 0 0
// if event = 113 then
39153: LD_VAR 0 1
39157: PUSH
39158: LD_INT 113
39160: EQUAL
39161: IFFALSE 39167
// MC_MinesTrigger ( ) ;
39163: CALL 52981 0 0
// if event = 120 then
39167: LD_VAR 0 1
39171: PUSH
39172: LD_INT 120
39174: EQUAL
39175: IFFALSE 39181
// MC_RepairVehicle ( ) ;
39177: CALL 53080 0 0
// if event = 121 then
39181: LD_VAR 0 1
39185: PUSH
39186: LD_INT 121
39188: EQUAL
39189: IFFALSE 39195
// MC_TameApe ( ) ;
39191: CALL 53821 0 0
// if event = 122 then
39195: LD_VAR 0 1
39199: PUSH
39200: LD_INT 122
39202: EQUAL
39203: IFFALSE 39209
// MC_ChangeApeClass ( ) ;
39205: CALL 54650 0 0
// if event = 123 then
39209: LD_VAR 0 1
39213: PUSH
39214: LD_INT 123
39216: EQUAL
39217: IFFALSE 39223
// MC_Bazooka ( ) ;
39219: CALL 55300 0 0
// if event = 124 then
39223: LD_VAR 0 1
39227: PUSH
39228: LD_INT 124
39230: EQUAL
39231: IFFALSE 39237
// MC_TeleportExit ( ) ;
39233: CALL 55498 0 0
// if event = 125 then
39237: LD_VAR 0 1
39241: PUSH
39242: LD_INT 125
39244: EQUAL
39245: IFFALSE 39251
// MC_Deposits ( ) ;
39247: CALL 56145 0 0
// if event = 126 then
39251: LD_VAR 0 1
39255: PUSH
39256: LD_INT 126
39258: EQUAL
39259: IFFALSE 39265
// MC_RemoteDriver ( ) ;
39261: CALL 56770 0 0
// if event = 200 then
39265: LD_VAR 0 1
39269: PUSH
39270: LD_INT 200
39272: EQUAL
39273: IFFALSE 39279
// MC_Idle ( ) ;
39275: CALL 58719 0 0
// end ;
39279: PPOPN 1
39281: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39282: LD_INT 0
39284: PPUSH
39285: PPUSH
// if not mc_bases [ base ] or not tag then
39286: LD_EXP 97
39290: PUSH
39291: LD_VAR 0 1
39295: ARRAY
39296: NOT
39297: PUSH
39298: LD_VAR 0 2
39302: NOT
39303: OR
39304: IFFALSE 39308
// exit ;
39306: GO 39372
// for i in mc_bases [ base ] union mc_ape [ base ] do
39308: LD_ADDR_VAR 0 4
39312: PUSH
39313: LD_EXP 97
39317: PUSH
39318: LD_VAR 0 1
39322: ARRAY
39323: PUSH
39324: LD_EXP 126
39328: PUSH
39329: LD_VAR 0 1
39333: ARRAY
39334: UNION
39335: PUSH
39336: FOR_IN
39337: IFFALSE 39370
// if GetTag ( i ) = tag then
39339: LD_VAR 0 4
39343: PPUSH
39344: CALL_OW 110
39348: PUSH
39349: LD_VAR 0 2
39353: EQUAL
39354: IFFALSE 39368
// SetTag ( i , 0 ) ;
39356: LD_VAR 0 4
39360: PPUSH
39361: LD_INT 0
39363: PPUSH
39364: CALL_OW 109
39368: GO 39336
39370: POP
39371: POP
// end ;
39372: LD_VAR 0 3
39376: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39377: LD_INT 0
39379: PPUSH
39380: PPUSH
39381: PPUSH
39382: PPUSH
39383: PPUSH
39384: PPUSH
39385: PPUSH
39386: PPUSH
// if not mc_bases then
39387: LD_EXP 97
39391: NOT
39392: IFFALSE 39396
// exit ;
39394: GO 39854
// for i = 1 to mc_bases do
39396: LD_ADDR_VAR 0 2
39400: PUSH
39401: DOUBLE
39402: LD_INT 1
39404: DEC
39405: ST_TO_ADDR
39406: LD_EXP 97
39410: PUSH
39411: FOR_TO
39412: IFFALSE 39852
// begin tmp := MC_ClassCheckReq ( i ) ;
39414: LD_ADDR_VAR 0 4
39418: PUSH
39419: LD_VAR 0 2
39423: PPUSH
39424: CALL 39859 0 1
39428: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39429: LD_ADDR_EXP 138
39433: PUSH
39434: LD_EXP 138
39438: PPUSH
39439: LD_VAR 0 2
39443: PPUSH
39444: LD_VAR 0 4
39448: PPUSH
39449: CALL_OW 1
39453: ST_TO_ADDR
// if not tmp then
39454: LD_VAR 0 4
39458: NOT
39459: IFFALSE 39463
// continue ;
39461: GO 39411
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39463: LD_ADDR_VAR 0 6
39467: PUSH
39468: LD_EXP 97
39472: PUSH
39473: LD_VAR 0 2
39477: ARRAY
39478: PPUSH
39479: LD_INT 2
39481: PUSH
39482: LD_INT 30
39484: PUSH
39485: LD_INT 4
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 30
39494: PUSH
39495: LD_INT 5
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: LIST
39506: PPUSH
39507: CALL_OW 72
39511: PUSH
39512: LD_EXP 97
39516: PUSH
39517: LD_VAR 0 2
39521: ARRAY
39522: PPUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 30
39528: PUSH
39529: LD_INT 0
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 30
39538: PUSH
39539: LD_INT 1
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: LIST
39550: PPUSH
39551: CALL_OW 72
39555: PUSH
39556: LD_EXP 97
39560: PUSH
39561: LD_VAR 0 2
39565: ARRAY
39566: PPUSH
39567: LD_INT 30
39569: PUSH
39570: LD_INT 3
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PPUSH
39577: CALL_OW 72
39581: PUSH
39582: LD_EXP 97
39586: PUSH
39587: LD_VAR 0 2
39591: ARRAY
39592: PPUSH
39593: LD_INT 2
39595: PUSH
39596: LD_INT 30
39598: PUSH
39599: LD_INT 6
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 30
39608: PUSH
39609: LD_INT 7
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 30
39618: PUSH
39619: LD_INT 8
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: PPUSH
39632: CALL_OW 72
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: ST_TO_ADDR
// for j = 1 to 4 do
39643: LD_ADDR_VAR 0 3
39647: PUSH
39648: DOUBLE
39649: LD_INT 1
39651: DEC
39652: ST_TO_ADDR
39653: LD_INT 4
39655: PUSH
39656: FOR_TO
39657: IFFALSE 39848
// begin if not tmp [ j ] then
39659: LD_VAR 0 4
39663: PUSH
39664: LD_VAR 0 3
39668: ARRAY
39669: NOT
39670: IFFALSE 39674
// continue ;
39672: GO 39656
// for p in tmp [ j ] do
39674: LD_ADDR_VAR 0 5
39678: PUSH
39679: LD_VAR 0 4
39683: PUSH
39684: LD_VAR 0 3
39688: ARRAY
39689: PUSH
39690: FOR_IN
39691: IFFALSE 39844
// begin if not b [ j ] then
39693: LD_VAR 0 6
39697: PUSH
39698: LD_VAR 0 3
39702: ARRAY
39703: NOT
39704: IFFALSE 39708
// break ;
39706: GO 39844
// e := 0 ;
39708: LD_ADDR_VAR 0 7
39712: PUSH
39713: LD_INT 0
39715: ST_TO_ADDR
// for k in b [ j ] do
39716: LD_ADDR_VAR 0 8
39720: PUSH
39721: LD_VAR 0 6
39725: PUSH
39726: LD_VAR 0 3
39730: ARRAY
39731: PUSH
39732: FOR_IN
39733: IFFALSE 39760
// if IsNotFull ( k ) then
39735: LD_VAR 0 8
39739: PPUSH
39740: CALL 67948 0 1
39744: IFFALSE 39758
// begin e := k ;
39746: LD_ADDR_VAR 0 7
39750: PUSH
39751: LD_VAR 0 8
39755: ST_TO_ADDR
// break ;
39756: GO 39760
// end ;
39758: GO 39732
39760: POP
39761: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39762: LD_VAR 0 7
39766: PUSH
39767: LD_VAR 0 5
39771: PPUSH
39772: LD_VAR 0 7
39776: PPUSH
39777: CALL 101754 0 2
39781: NOT
39782: AND
39783: IFFALSE 39842
// begin if IsInUnit ( p ) then
39785: LD_VAR 0 5
39789: PPUSH
39790: CALL_OW 310
39794: IFFALSE 39805
// ComExitBuilding ( p ) ;
39796: LD_VAR 0 5
39800: PPUSH
39801: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39805: LD_VAR 0 5
39809: PPUSH
39810: LD_VAR 0 7
39814: PPUSH
39815: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39819: LD_VAR 0 5
39823: PPUSH
39824: LD_VAR 0 3
39828: PPUSH
39829: CALL_OW 183
// AddComExitBuilding ( p ) ;
39833: LD_VAR 0 5
39837: PPUSH
39838: CALL_OW 182
// end ; end ;
39842: GO 39690
39844: POP
39845: POP
// end ;
39846: GO 39656
39848: POP
39849: POP
// end ;
39850: GO 39411
39852: POP
39853: POP
// end ;
39854: LD_VAR 0 1
39858: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39859: LD_INT 0
39861: PPUSH
39862: PPUSH
39863: PPUSH
39864: PPUSH
39865: PPUSH
39866: PPUSH
39867: PPUSH
39868: PPUSH
39869: PPUSH
39870: PPUSH
39871: PPUSH
39872: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39873: LD_VAR 0 1
39877: NOT
39878: PUSH
39879: LD_EXP 97
39883: PUSH
39884: LD_VAR 0 1
39888: ARRAY
39889: NOT
39890: OR
39891: PUSH
39892: LD_EXP 97
39896: PUSH
39897: LD_VAR 0 1
39901: ARRAY
39902: PPUSH
39903: LD_INT 2
39905: PUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 0
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 30
39918: PUSH
39919: LD_INT 1
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: LIST
39930: PPUSH
39931: CALL_OW 72
39935: NOT
39936: OR
39937: IFFALSE 39941
// exit ;
39939: GO 43444
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39941: LD_ADDR_VAR 0 4
39945: PUSH
39946: LD_EXP 97
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: PPUSH
39957: LD_INT 2
39959: PUSH
39960: LD_INT 25
39962: PUSH
39963: LD_INT 1
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 25
39972: PUSH
39973: LD_INT 2
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 25
39982: PUSH
39983: LD_INT 3
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: LD_INT 25
39992: PUSH
39993: LD_INT 4
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 25
40002: PUSH
40003: LD_INT 5
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 25
40012: PUSH
40013: LD_INT 8
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 25
40022: PUSH
40023: LD_INT 9
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: PPUSH
40040: CALL_OW 72
40044: ST_TO_ADDR
// if not tmp then
40045: LD_VAR 0 4
40049: NOT
40050: IFFALSE 40054
// exit ;
40052: GO 43444
// for i in tmp do
40054: LD_ADDR_VAR 0 3
40058: PUSH
40059: LD_VAR 0 4
40063: PUSH
40064: FOR_IN
40065: IFFALSE 40096
// if GetTag ( i ) then
40067: LD_VAR 0 3
40071: PPUSH
40072: CALL_OW 110
40076: IFFALSE 40094
// tmp := tmp diff i ;
40078: LD_ADDR_VAR 0 4
40082: PUSH
40083: LD_VAR 0 4
40087: PUSH
40088: LD_VAR 0 3
40092: DIFF
40093: ST_TO_ADDR
40094: GO 40064
40096: POP
40097: POP
// if not tmp then
40098: LD_VAR 0 4
40102: NOT
40103: IFFALSE 40107
// exit ;
40105: GO 43444
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40107: LD_ADDR_VAR 0 5
40111: PUSH
40112: LD_EXP 97
40116: PUSH
40117: LD_VAR 0 1
40121: ARRAY
40122: PPUSH
40123: LD_INT 2
40125: PUSH
40126: LD_INT 25
40128: PUSH
40129: LD_INT 1
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 25
40138: PUSH
40139: LD_INT 5
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 25
40148: PUSH
40149: LD_INT 8
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 25
40158: PUSH
40159: LD_INT 9
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: PPUSH
40173: CALL_OW 72
40177: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40178: LD_ADDR_VAR 0 6
40182: PUSH
40183: LD_EXP 97
40187: PUSH
40188: LD_VAR 0 1
40192: ARRAY
40193: PPUSH
40194: LD_INT 25
40196: PUSH
40197: LD_INT 2
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PPUSH
40204: CALL_OW 72
40208: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40209: LD_ADDR_VAR 0 7
40213: PUSH
40214: LD_EXP 97
40218: PUSH
40219: LD_VAR 0 1
40223: ARRAY
40224: PPUSH
40225: LD_INT 25
40227: PUSH
40228: LD_INT 3
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PPUSH
40235: CALL_OW 72
40239: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40240: LD_ADDR_VAR 0 8
40244: PUSH
40245: LD_EXP 97
40249: PUSH
40250: LD_VAR 0 1
40254: ARRAY
40255: PPUSH
40256: LD_INT 25
40258: PUSH
40259: LD_INT 4
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 24
40268: PUSH
40269: LD_INT 251
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PPUSH
40280: CALL_OW 72
40284: ST_TO_ADDR
// if mc_is_defending [ base ] then
40285: LD_EXP 140
40289: PUSH
40290: LD_VAR 0 1
40294: ARRAY
40295: IFFALSE 40756
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40297: LD_ADDR_EXP 139
40301: PUSH
40302: LD_EXP 139
40306: PPUSH
40307: LD_VAR 0 1
40311: PPUSH
40312: LD_INT 4
40314: PPUSH
40315: CALL_OW 1
40319: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40320: LD_ADDR_VAR 0 12
40324: PUSH
40325: LD_EXP 97
40329: PUSH
40330: LD_VAR 0 1
40334: ARRAY
40335: PPUSH
40336: LD_INT 2
40338: PUSH
40339: LD_INT 30
40341: PUSH
40342: LD_INT 4
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 30
40351: PUSH
40352: LD_INT 5
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: LIST
40363: PPUSH
40364: CALL_OW 72
40368: ST_TO_ADDR
// if not b then
40369: LD_VAR 0 12
40373: NOT
40374: IFFALSE 40378
// exit ;
40376: GO 43444
// p := [ ] ;
40378: LD_ADDR_VAR 0 11
40382: PUSH
40383: EMPTY
40384: ST_TO_ADDR
// if sci >= 2 then
40385: LD_VAR 0 8
40389: PUSH
40390: LD_INT 2
40392: GREATEREQUAL
40393: IFFALSE 40424
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40395: LD_ADDR_VAR 0 8
40399: PUSH
40400: LD_VAR 0 8
40404: PUSH
40405: LD_INT 1
40407: ARRAY
40408: PUSH
40409: LD_VAR 0 8
40413: PUSH
40414: LD_INT 2
40416: ARRAY
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: ST_TO_ADDR
40422: GO 40485
// if sci = 1 then
40424: LD_VAR 0 8
40428: PUSH
40429: LD_INT 1
40431: EQUAL
40432: IFFALSE 40453
// sci := [ sci [ 1 ] ] else
40434: LD_ADDR_VAR 0 8
40438: PUSH
40439: LD_VAR 0 8
40443: PUSH
40444: LD_INT 1
40446: ARRAY
40447: PUSH
40448: EMPTY
40449: LIST
40450: ST_TO_ADDR
40451: GO 40485
// if sci = 0 then
40453: LD_VAR 0 8
40457: PUSH
40458: LD_INT 0
40460: EQUAL
40461: IFFALSE 40485
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40463: LD_ADDR_VAR 0 11
40467: PUSH
40468: LD_VAR 0 4
40472: PPUSH
40473: LD_INT 4
40475: PPUSH
40476: CALL 101617 0 2
40480: PUSH
40481: LD_INT 1
40483: ARRAY
40484: ST_TO_ADDR
// if eng > 4 then
40485: LD_VAR 0 6
40489: PUSH
40490: LD_INT 4
40492: GREATER
40493: IFFALSE 40539
// for i = eng downto 4 do
40495: LD_ADDR_VAR 0 3
40499: PUSH
40500: DOUBLE
40501: LD_VAR 0 6
40505: INC
40506: ST_TO_ADDR
40507: LD_INT 4
40509: PUSH
40510: FOR_DOWNTO
40511: IFFALSE 40537
// eng := eng diff eng [ i ] ;
40513: LD_ADDR_VAR 0 6
40517: PUSH
40518: LD_VAR 0 6
40522: PUSH
40523: LD_VAR 0 6
40527: PUSH
40528: LD_VAR 0 3
40532: ARRAY
40533: DIFF
40534: ST_TO_ADDR
40535: GO 40510
40537: POP
40538: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40539: LD_ADDR_VAR 0 4
40543: PUSH
40544: LD_VAR 0 4
40548: PUSH
40549: LD_VAR 0 5
40553: PUSH
40554: LD_VAR 0 6
40558: UNION
40559: PUSH
40560: LD_VAR 0 7
40564: UNION
40565: PUSH
40566: LD_VAR 0 8
40570: UNION
40571: DIFF
40572: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40573: LD_ADDR_VAR 0 13
40577: PUSH
40578: LD_EXP 97
40582: PUSH
40583: LD_VAR 0 1
40587: ARRAY
40588: PPUSH
40589: LD_INT 2
40591: PUSH
40592: LD_INT 30
40594: PUSH
40595: LD_INT 32
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 30
40604: PUSH
40605: LD_INT 31
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: LIST
40616: PPUSH
40617: CALL_OW 72
40621: PUSH
40622: LD_EXP 97
40626: PUSH
40627: LD_VAR 0 1
40631: ARRAY
40632: PPUSH
40633: LD_INT 2
40635: PUSH
40636: LD_INT 30
40638: PUSH
40639: LD_INT 4
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 30
40648: PUSH
40649: LD_INT 5
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: LIST
40660: PPUSH
40661: CALL_OW 72
40665: PUSH
40666: LD_INT 6
40668: MUL
40669: PLUS
40670: ST_TO_ADDR
// if bcount < tmp then
40671: LD_VAR 0 13
40675: PUSH
40676: LD_VAR 0 4
40680: LESS
40681: IFFALSE 40727
// for i = tmp downto bcount do
40683: LD_ADDR_VAR 0 3
40687: PUSH
40688: DOUBLE
40689: LD_VAR 0 4
40693: INC
40694: ST_TO_ADDR
40695: LD_VAR 0 13
40699: PUSH
40700: FOR_DOWNTO
40701: IFFALSE 40725
// tmp := Delete ( tmp , tmp ) ;
40703: LD_ADDR_VAR 0 4
40707: PUSH
40708: LD_VAR 0 4
40712: PPUSH
40713: LD_VAR 0 4
40717: PPUSH
40718: CALL_OW 3
40722: ST_TO_ADDR
40723: GO 40700
40725: POP
40726: POP
// result := [ tmp , 0 , 0 , p ] ;
40727: LD_ADDR_VAR 0 2
40731: PUSH
40732: LD_VAR 0 4
40736: PUSH
40737: LD_INT 0
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: LD_VAR 0 11
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: ST_TO_ADDR
// exit ;
40754: GO 43444
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40756: LD_EXP 97
40760: PUSH
40761: LD_VAR 0 1
40765: ARRAY
40766: PPUSH
40767: LD_INT 2
40769: PUSH
40770: LD_INT 30
40772: PUSH
40773: LD_INT 6
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 30
40782: PUSH
40783: LD_INT 7
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 30
40792: PUSH
40793: LD_INT 8
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: PPUSH
40806: CALL_OW 72
40810: NOT
40811: PUSH
40812: LD_EXP 97
40816: PUSH
40817: LD_VAR 0 1
40821: ARRAY
40822: PPUSH
40823: LD_INT 30
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PPUSH
40833: CALL_OW 72
40837: NOT
40838: AND
40839: IFFALSE 40911
// begin if eng = tmp then
40841: LD_VAR 0 6
40845: PUSH
40846: LD_VAR 0 4
40850: EQUAL
40851: IFFALSE 40855
// exit ;
40853: GO 43444
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40855: LD_ADDR_EXP 139
40859: PUSH
40860: LD_EXP 139
40864: PPUSH
40865: LD_VAR 0 1
40869: PPUSH
40870: LD_INT 1
40872: PPUSH
40873: CALL_OW 1
40877: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40878: LD_ADDR_VAR 0 2
40882: PUSH
40883: LD_INT 0
40885: PUSH
40886: LD_VAR 0 4
40890: PUSH
40891: LD_VAR 0 6
40895: DIFF
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: LD_INT 0
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: ST_TO_ADDR
// exit ;
40909: GO 43444
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40911: LD_EXP 124
40915: PUSH
40916: LD_EXP 123
40920: PUSH
40921: LD_VAR 0 1
40925: ARRAY
40926: ARRAY
40927: PUSH
40928: LD_EXP 97
40932: PUSH
40933: LD_VAR 0 1
40937: ARRAY
40938: PPUSH
40939: LD_INT 2
40941: PUSH
40942: LD_INT 30
40944: PUSH
40945: LD_INT 6
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 30
40954: PUSH
40955: LD_INT 7
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 8
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: PPUSH
40978: CALL_OW 72
40982: AND
40983: PUSH
40984: LD_EXP 97
40988: PUSH
40989: LD_VAR 0 1
40993: ARRAY
40994: PPUSH
40995: LD_INT 30
40997: PUSH
40998: LD_INT 3
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PPUSH
41005: CALL_OW 72
41009: NOT
41010: AND
41011: IFFALSE 41225
// begin if sci >= 6 then
41013: LD_VAR 0 8
41017: PUSH
41018: LD_INT 6
41020: GREATEREQUAL
41021: IFFALSE 41025
// exit ;
41023: GO 43444
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41025: LD_ADDR_EXP 139
41029: PUSH
41030: LD_EXP 139
41034: PPUSH
41035: LD_VAR 0 1
41039: PPUSH
41040: LD_INT 2
41042: PPUSH
41043: CALL_OW 1
41047: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41048: LD_ADDR_VAR 0 9
41052: PUSH
41053: LD_VAR 0 4
41057: PUSH
41058: LD_VAR 0 8
41062: DIFF
41063: PPUSH
41064: LD_INT 4
41066: PPUSH
41067: CALL 101617 0 2
41071: ST_TO_ADDR
// p := [ ] ;
41072: LD_ADDR_VAR 0 11
41076: PUSH
41077: EMPTY
41078: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41079: LD_VAR 0 8
41083: PUSH
41084: LD_INT 6
41086: LESS
41087: PUSH
41088: LD_VAR 0 9
41092: PUSH
41093: LD_INT 6
41095: GREATER
41096: AND
41097: IFFALSE 41178
// begin for i = 1 to 6 - sci do
41099: LD_ADDR_VAR 0 3
41103: PUSH
41104: DOUBLE
41105: LD_INT 1
41107: DEC
41108: ST_TO_ADDR
41109: LD_INT 6
41111: PUSH
41112: LD_VAR 0 8
41116: MINUS
41117: PUSH
41118: FOR_TO
41119: IFFALSE 41174
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41121: LD_ADDR_VAR 0 11
41125: PUSH
41126: LD_VAR 0 11
41130: PPUSH
41131: LD_VAR 0 11
41135: PUSH
41136: LD_INT 1
41138: PLUS
41139: PPUSH
41140: LD_VAR 0 9
41144: PUSH
41145: LD_INT 1
41147: ARRAY
41148: PPUSH
41149: CALL_OW 2
41153: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41154: LD_ADDR_VAR 0 9
41158: PUSH
41159: LD_VAR 0 9
41163: PPUSH
41164: LD_INT 1
41166: PPUSH
41167: CALL_OW 3
41171: ST_TO_ADDR
// end ;
41172: GO 41118
41174: POP
41175: POP
// end else
41176: GO 41198
// if sort then
41178: LD_VAR 0 9
41182: IFFALSE 41198
// p := sort [ 1 ] ;
41184: LD_ADDR_VAR 0 11
41188: PUSH
41189: LD_VAR 0 9
41193: PUSH
41194: LD_INT 1
41196: ARRAY
41197: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41198: LD_ADDR_VAR 0 2
41202: PUSH
41203: LD_INT 0
41205: PUSH
41206: LD_INT 0
41208: PUSH
41209: LD_INT 0
41211: PUSH
41212: LD_VAR 0 11
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: ST_TO_ADDR
// exit ;
41223: GO 43444
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41225: LD_EXP 124
41229: PUSH
41230: LD_EXP 123
41234: PUSH
41235: LD_VAR 0 1
41239: ARRAY
41240: ARRAY
41241: PUSH
41242: LD_EXP 97
41246: PUSH
41247: LD_VAR 0 1
41251: ARRAY
41252: PPUSH
41253: LD_INT 2
41255: PUSH
41256: LD_INT 30
41258: PUSH
41259: LD_INT 6
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 30
41268: PUSH
41269: LD_INT 7
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 30
41278: PUSH
41279: LD_INT 8
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: LIST
41290: LIST
41291: PPUSH
41292: CALL_OW 72
41296: AND
41297: PUSH
41298: LD_EXP 97
41302: PUSH
41303: LD_VAR 0 1
41307: ARRAY
41308: PPUSH
41309: LD_INT 30
41311: PUSH
41312: LD_INT 3
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PPUSH
41319: CALL_OW 72
41323: AND
41324: IFFALSE 42058
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41326: LD_ADDR_EXP 139
41330: PUSH
41331: LD_EXP 139
41335: PPUSH
41336: LD_VAR 0 1
41340: PPUSH
41341: LD_INT 3
41343: PPUSH
41344: CALL_OW 1
41348: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41349: LD_ADDR_VAR 0 2
41353: PUSH
41354: LD_INT 0
41356: PUSH
41357: LD_INT 0
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: LIST
41370: LIST
41371: ST_TO_ADDR
// if not eng then
41372: LD_VAR 0 6
41376: NOT
41377: IFFALSE 41440
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41379: LD_ADDR_VAR 0 11
41383: PUSH
41384: LD_VAR 0 4
41388: PPUSH
41389: LD_INT 2
41391: PPUSH
41392: CALL 101617 0 2
41396: PUSH
41397: LD_INT 1
41399: ARRAY
41400: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41401: LD_ADDR_VAR 0 2
41405: PUSH
41406: LD_VAR 0 2
41410: PPUSH
41411: LD_INT 2
41413: PPUSH
41414: LD_VAR 0 11
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// tmp := tmp diff p ;
41424: LD_ADDR_VAR 0 4
41428: PUSH
41429: LD_VAR 0 4
41433: PUSH
41434: LD_VAR 0 11
41438: DIFF
41439: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41440: LD_VAR 0 4
41444: PUSH
41445: LD_VAR 0 8
41449: PUSH
41450: LD_INT 6
41452: LESS
41453: AND
41454: IFFALSE 41642
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41456: LD_ADDR_VAR 0 9
41460: PUSH
41461: LD_VAR 0 4
41465: PUSH
41466: LD_VAR 0 8
41470: PUSH
41471: LD_VAR 0 7
41475: UNION
41476: DIFF
41477: PPUSH
41478: LD_INT 4
41480: PPUSH
41481: CALL 101617 0 2
41485: ST_TO_ADDR
// p := [ ] ;
41486: LD_ADDR_VAR 0 11
41490: PUSH
41491: EMPTY
41492: ST_TO_ADDR
// if sort then
41493: LD_VAR 0 9
41497: IFFALSE 41613
// for i = 1 to 6 - sci do
41499: LD_ADDR_VAR 0 3
41503: PUSH
41504: DOUBLE
41505: LD_INT 1
41507: DEC
41508: ST_TO_ADDR
41509: LD_INT 6
41511: PUSH
41512: LD_VAR 0 8
41516: MINUS
41517: PUSH
41518: FOR_TO
41519: IFFALSE 41611
// begin if i = sort then
41521: LD_VAR 0 3
41525: PUSH
41526: LD_VAR 0 9
41530: EQUAL
41531: IFFALSE 41535
// break ;
41533: GO 41611
// if GetClass ( i ) = 4 then
41535: LD_VAR 0 3
41539: PPUSH
41540: CALL_OW 257
41544: PUSH
41545: LD_INT 4
41547: EQUAL
41548: IFFALSE 41552
// continue ;
41550: GO 41518
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41552: LD_ADDR_VAR 0 11
41556: PUSH
41557: LD_VAR 0 11
41561: PPUSH
41562: LD_VAR 0 11
41566: PUSH
41567: LD_INT 1
41569: PLUS
41570: PPUSH
41571: LD_VAR 0 9
41575: PUSH
41576: LD_VAR 0 3
41580: ARRAY
41581: PPUSH
41582: CALL_OW 2
41586: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41587: LD_ADDR_VAR 0 4
41591: PUSH
41592: LD_VAR 0 4
41596: PUSH
41597: LD_VAR 0 9
41601: PUSH
41602: LD_VAR 0 3
41606: ARRAY
41607: DIFF
41608: ST_TO_ADDR
// end ;
41609: GO 41518
41611: POP
41612: POP
// if p then
41613: LD_VAR 0 11
41617: IFFALSE 41642
// result := Replace ( result , 4 , p ) ;
41619: LD_ADDR_VAR 0 2
41623: PUSH
41624: LD_VAR 0 2
41628: PPUSH
41629: LD_INT 4
41631: PPUSH
41632: LD_VAR 0 11
41636: PPUSH
41637: CALL_OW 1
41641: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41642: LD_VAR 0 4
41646: PUSH
41647: LD_VAR 0 7
41651: PUSH
41652: LD_INT 6
41654: LESS
41655: AND
41656: IFFALSE 41844
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41658: LD_ADDR_VAR 0 9
41662: PUSH
41663: LD_VAR 0 4
41667: PUSH
41668: LD_VAR 0 8
41672: PUSH
41673: LD_VAR 0 7
41677: UNION
41678: DIFF
41679: PPUSH
41680: LD_INT 3
41682: PPUSH
41683: CALL 101617 0 2
41687: ST_TO_ADDR
// p := [ ] ;
41688: LD_ADDR_VAR 0 11
41692: PUSH
41693: EMPTY
41694: ST_TO_ADDR
// if sort then
41695: LD_VAR 0 9
41699: IFFALSE 41815
// for i = 1 to 6 - mech do
41701: LD_ADDR_VAR 0 3
41705: PUSH
41706: DOUBLE
41707: LD_INT 1
41709: DEC
41710: ST_TO_ADDR
41711: LD_INT 6
41713: PUSH
41714: LD_VAR 0 7
41718: MINUS
41719: PUSH
41720: FOR_TO
41721: IFFALSE 41813
// begin if i = sort then
41723: LD_VAR 0 3
41727: PUSH
41728: LD_VAR 0 9
41732: EQUAL
41733: IFFALSE 41737
// break ;
41735: GO 41813
// if GetClass ( i ) = 3 then
41737: LD_VAR 0 3
41741: PPUSH
41742: CALL_OW 257
41746: PUSH
41747: LD_INT 3
41749: EQUAL
41750: IFFALSE 41754
// continue ;
41752: GO 41720
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41754: LD_ADDR_VAR 0 11
41758: PUSH
41759: LD_VAR 0 11
41763: PPUSH
41764: LD_VAR 0 11
41768: PUSH
41769: LD_INT 1
41771: PLUS
41772: PPUSH
41773: LD_VAR 0 9
41777: PUSH
41778: LD_VAR 0 3
41782: ARRAY
41783: PPUSH
41784: CALL_OW 2
41788: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41789: LD_ADDR_VAR 0 4
41793: PUSH
41794: LD_VAR 0 4
41798: PUSH
41799: LD_VAR 0 9
41803: PUSH
41804: LD_VAR 0 3
41808: ARRAY
41809: DIFF
41810: ST_TO_ADDR
// end ;
41811: GO 41720
41813: POP
41814: POP
// if p then
41815: LD_VAR 0 11
41819: IFFALSE 41844
// result := Replace ( result , 3 , p ) ;
41821: LD_ADDR_VAR 0 2
41825: PUSH
41826: LD_VAR 0 2
41830: PPUSH
41831: LD_INT 3
41833: PPUSH
41834: LD_VAR 0 11
41838: PPUSH
41839: CALL_OW 1
41843: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41844: LD_VAR 0 4
41848: PUSH
41849: LD_INT 6
41851: GREATER
41852: PUSH
41853: LD_VAR 0 6
41857: PUSH
41858: LD_INT 6
41860: LESS
41861: AND
41862: IFFALSE 42056
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41864: LD_ADDR_VAR 0 9
41868: PUSH
41869: LD_VAR 0 4
41873: PUSH
41874: LD_VAR 0 8
41878: PUSH
41879: LD_VAR 0 7
41883: UNION
41884: PUSH
41885: LD_VAR 0 6
41889: UNION
41890: DIFF
41891: PPUSH
41892: LD_INT 2
41894: PPUSH
41895: CALL 101617 0 2
41899: ST_TO_ADDR
// p := [ ] ;
41900: LD_ADDR_VAR 0 11
41904: PUSH
41905: EMPTY
41906: ST_TO_ADDR
// if sort then
41907: LD_VAR 0 9
41911: IFFALSE 42027
// for i = 1 to 6 - eng do
41913: LD_ADDR_VAR 0 3
41917: PUSH
41918: DOUBLE
41919: LD_INT 1
41921: DEC
41922: ST_TO_ADDR
41923: LD_INT 6
41925: PUSH
41926: LD_VAR 0 6
41930: MINUS
41931: PUSH
41932: FOR_TO
41933: IFFALSE 42025
// begin if i = sort then
41935: LD_VAR 0 3
41939: PUSH
41940: LD_VAR 0 9
41944: EQUAL
41945: IFFALSE 41949
// break ;
41947: GO 42025
// if GetClass ( i ) = 2 then
41949: LD_VAR 0 3
41953: PPUSH
41954: CALL_OW 257
41958: PUSH
41959: LD_INT 2
41961: EQUAL
41962: IFFALSE 41966
// continue ;
41964: GO 41932
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41966: LD_ADDR_VAR 0 11
41970: PUSH
41971: LD_VAR 0 11
41975: PPUSH
41976: LD_VAR 0 11
41980: PUSH
41981: LD_INT 1
41983: PLUS
41984: PPUSH
41985: LD_VAR 0 9
41989: PUSH
41990: LD_VAR 0 3
41994: ARRAY
41995: PPUSH
41996: CALL_OW 2
42000: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42001: LD_ADDR_VAR 0 4
42005: PUSH
42006: LD_VAR 0 4
42010: PUSH
42011: LD_VAR 0 9
42015: PUSH
42016: LD_VAR 0 3
42020: ARRAY
42021: DIFF
42022: ST_TO_ADDR
// end ;
42023: GO 41932
42025: POP
42026: POP
// if p then
42027: LD_VAR 0 11
42031: IFFALSE 42056
// result := Replace ( result , 2 , p ) ;
42033: LD_ADDR_VAR 0 2
42037: PUSH
42038: LD_VAR 0 2
42042: PPUSH
42043: LD_INT 2
42045: PPUSH
42046: LD_VAR 0 11
42050: PPUSH
42051: CALL_OW 1
42055: ST_TO_ADDR
// end ; exit ;
42056: GO 43444
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42058: LD_EXP 124
42062: PUSH
42063: LD_EXP 123
42067: PUSH
42068: LD_VAR 0 1
42072: ARRAY
42073: ARRAY
42074: NOT
42075: PUSH
42076: LD_EXP 97
42080: PUSH
42081: LD_VAR 0 1
42085: ARRAY
42086: PPUSH
42087: LD_INT 30
42089: PUSH
42090: LD_INT 3
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PPUSH
42097: CALL_OW 72
42101: AND
42102: PUSH
42103: LD_EXP 102
42107: PUSH
42108: LD_VAR 0 1
42112: ARRAY
42113: AND
42114: IFFALSE 42722
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42116: LD_ADDR_EXP 139
42120: PUSH
42121: LD_EXP 139
42125: PPUSH
42126: LD_VAR 0 1
42130: PPUSH
42131: LD_INT 5
42133: PPUSH
42134: CALL_OW 1
42138: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42139: LD_ADDR_VAR 0 2
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 0
42149: PUSH
42150: LD_INT 0
42152: PUSH
42153: LD_INT 0
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: ST_TO_ADDR
// if sci > 1 then
42162: LD_VAR 0 8
42166: PUSH
42167: LD_INT 1
42169: GREATER
42170: IFFALSE 42198
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42172: LD_ADDR_VAR 0 4
42176: PUSH
42177: LD_VAR 0 4
42181: PUSH
42182: LD_VAR 0 8
42186: PUSH
42187: LD_VAR 0 8
42191: PUSH
42192: LD_INT 1
42194: ARRAY
42195: DIFF
42196: DIFF
42197: ST_TO_ADDR
// if tmp and not sci then
42198: LD_VAR 0 4
42202: PUSH
42203: LD_VAR 0 8
42207: NOT
42208: AND
42209: IFFALSE 42278
// begin sort := SortBySkill ( tmp , 4 ) ;
42211: LD_ADDR_VAR 0 9
42215: PUSH
42216: LD_VAR 0 4
42220: PPUSH
42221: LD_INT 4
42223: PPUSH
42224: CALL 101617 0 2
42228: ST_TO_ADDR
// if sort then
42229: LD_VAR 0 9
42233: IFFALSE 42249
// p := sort [ 1 ] ;
42235: LD_ADDR_VAR 0 11
42239: PUSH
42240: LD_VAR 0 9
42244: PUSH
42245: LD_INT 1
42247: ARRAY
42248: ST_TO_ADDR
// if p then
42249: LD_VAR 0 11
42253: IFFALSE 42278
// result := Replace ( result , 4 , p ) ;
42255: LD_ADDR_VAR 0 2
42259: PUSH
42260: LD_VAR 0 2
42264: PPUSH
42265: LD_INT 4
42267: PPUSH
42268: LD_VAR 0 11
42272: PPUSH
42273: CALL_OW 1
42277: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42278: LD_ADDR_VAR 0 4
42282: PUSH
42283: LD_VAR 0 4
42287: PUSH
42288: LD_VAR 0 7
42292: DIFF
42293: ST_TO_ADDR
// if tmp and mech < 6 then
42294: LD_VAR 0 4
42298: PUSH
42299: LD_VAR 0 7
42303: PUSH
42304: LD_INT 6
42306: LESS
42307: AND
42308: IFFALSE 42496
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42310: LD_ADDR_VAR 0 9
42314: PUSH
42315: LD_VAR 0 4
42319: PUSH
42320: LD_VAR 0 8
42324: PUSH
42325: LD_VAR 0 7
42329: UNION
42330: DIFF
42331: PPUSH
42332: LD_INT 3
42334: PPUSH
42335: CALL 101617 0 2
42339: ST_TO_ADDR
// p := [ ] ;
42340: LD_ADDR_VAR 0 11
42344: PUSH
42345: EMPTY
42346: ST_TO_ADDR
// if sort then
42347: LD_VAR 0 9
42351: IFFALSE 42467
// for i = 1 to 6 - mech do
42353: LD_ADDR_VAR 0 3
42357: PUSH
42358: DOUBLE
42359: LD_INT 1
42361: DEC
42362: ST_TO_ADDR
42363: LD_INT 6
42365: PUSH
42366: LD_VAR 0 7
42370: MINUS
42371: PUSH
42372: FOR_TO
42373: IFFALSE 42465
// begin if i = sort then
42375: LD_VAR 0 3
42379: PUSH
42380: LD_VAR 0 9
42384: EQUAL
42385: IFFALSE 42389
// break ;
42387: GO 42465
// if GetClass ( i ) = 3 then
42389: LD_VAR 0 3
42393: PPUSH
42394: CALL_OW 257
42398: PUSH
42399: LD_INT 3
42401: EQUAL
42402: IFFALSE 42406
// continue ;
42404: GO 42372
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42406: LD_ADDR_VAR 0 11
42410: PUSH
42411: LD_VAR 0 11
42415: PPUSH
42416: LD_VAR 0 11
42420: PUSH
42421: LD_INT 1
42423: PLUS
42424: PPUSH
42425: LD_VAR 0 9
42429: PUSH
42430: LD_VAR 0 3
42434: ARRAY
42435: PPUSH
42436: CALL_OW 2
42440: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42441: LD_ADDR_VAR 0 4
42445: PUSH
42446: LD_VAR 0 4
42450: PUSH
42451: LD_VAR 0 9
42455: PUSH
42456: LD_VAR 0 3
42460: ARRAY
42461: DIFF
42462: ST_TO_ADDR
// end ;
42463: GO 42372
42465: POP
42466: POP
// if p then
42467: LD_VAR 0 11
42471: IFFALSE 42496
// result := Replace ( result , 3 , p ) ;
42473: LD_ADDR_VAR 0 2
42477: PUSH
42478: LD_VAR 0 2
42482: PPUSH
42483: LD_INT 3
42485: PPUSH
42486: LD_VAR 0 11
42490: PPUSH
42491: CALL_OW 1
42495: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42496: LD_ADDR_VAR 0 4
42500: PUSH
42501: LD_VAR 0 4
42505: PUSH
42506: LD_VAR 0 6
42510: DIFF
42511: ST_TO_ADDR
// if tmp and eng < 6 then
42512: LD_VAR 0 4
42516: PUSH
42517: LD_VAR 0 6
42521: PUSH
42522: LD_INT 6
42524: LESS
42525: AND
42526: IFFALSE 42720
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42528: LD_ADDR_VAR 0 9
42532: PUSH
42533: LD_VAR 0 4
42537: PUSH
42538: LD_VAR 0 8
42542: PUSH
42543: LD_VAR 0 7
42547: UNION
42548: PUSH
42549: LD_VAR 0 6
42553: UNION
42554: DIFF
42555: PPUSH
42556: LD_INT 2
42558: PPUSH
42559: CALL 101617 0 2
42563: ST_TO_ADDR
// p := [ ] ;
42564: LD_ADDR_VAR 0 11
42568: PUSH
42569: EMPTY
42570: ST_TO_ADDR
// if sort then
42571: LD_VAR 0 9
42575: IFFALSE 42691
// for i = 1 to 6 - eng do
42577: LD_ADDR_VAR 0 3
42581: PUSH
42582: DOUBLE
42583: LD_INT 1
42585: DEC
42586: ST_TO_ADDR
42587: LD_INT 6
42589: PUSH
42590: LD_VAR 0 6
42594: MINUS
42595: PUSH
42596: FOR_TO
42597: IFFALSE 42689
// begin if i = sort then
42599: LD_VAR 0 3
42603: PUSH
42604: LD_VAR 0 9
42608: EQUAL
42609: IFFALSE 42613
// break ;
42611: GO 42689
// if GetClass ( i ) = 2 then
42613: LD_VAR 0 3
42617: PPUSH
42618: CALL_OW 257
42622: PUSH
42623: LD_INT 2
42625: EQUAL
42626: IFFALSE 42630
// continue ;
42628: GO 42596
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42630: LD_ADDR_VAR 0 11
42634: PUSH
42635: LD_VAR 0 11
42639: PPUSH
42640: LD_VAR 0 11
42644: PUSH
42645: LD_INT 1
42647: PLUS
42648: PPUSH
42649: LD_VAR 0 9
42653: PUSH
42654: LD_VAR 0 3
42658: ARRAY
42659: PPUSH
42660: CALL_OW 2
42664: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42665: LD_ADDR_VAR 0 4
42669: PUSH
42670: LD_VAR 0 4
42674: PUSH
42675: LD_VAR 0 9
42679: PUSH
42680: LD_VAR 0 3
42684: ARRAY
42685: DIFF
42686: ST_TO_ADDR
// end ;
42687: GO 42596
42689: POP
42690: POP
// if p then
42691: LD_VAR 0 11
42695: IFFALSE 42720
// result := Replace ( result , 2 , p ) ;
42697: LD_ADDR_VAR 0 2
42701: PUSH
42702: LD_VAR 0 2
42706: PPUSH
42707: LD_INT 2
42709: PPUSH
42710: LD_VAR 0 11
42714: PPUSH
42715: CALL_OW 1
42719: ST_TO_ADDR
// end ; exit ;
42720: GO 43444
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42722: LD_EXP 124
42726: PUSH
42727: LD_EXP 123
42731: PUSH
42732: LD_VAR 0 1
42736: ARRAY
42737: ARRAY
42738: NOT
42739: PUSH
42740: LD_EXP 97
42744: PUSH
42745: LD_VAR 0 1
42749: ARRAY
42750: PPUSH
42751: LD_INT 30
42753: PUSH
42754: LD_INT 3
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: PPUSH
42761: CALL_OW 72
42765: AND
42766: PUSH
42767: LD_EXP 102
42771: PUSH
42772: LD_VAR 0 1
42776: ARRAY
42777: NOT
42778: AND
42779: IFFALSE 43444
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42781: LD_ADDR_EXP 139
42785: PUSH
42786: LD_EXP 139
42790: PPUSH
42791: LD_VAR 0 1
42795: PPUSH
42796: LD_INT 6
42798: PPUSH
42799: CALL_OW 1
42803: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42804: LD_ADDR_VAR 0 2
42808: PUSH
42809: LD_INT 0
42811: PUSH
42812: LD_INT 0
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: ST_TO_ADDR
// if sci >= 1 then
42827: LD_VAR 0 8
42831: PUSH
42832: LD_INT 1
42834: GREATEREQUAL
42835: IFFALSE 42857
// tmp := tmp diff sci [ 1 ] ;
42837: LD_ADDR_VAR 0 4
42841: PUSH
42842: LD_VAR 0 4
42846: PUSH
42847: LD_VAR 0 8
42851: PUSH
42852: LD_INT 1
42854: ARRAY
42855: DIFF
42856: ST_TO_ADDR
// if tmp and not sci then
42857: LD_VAR 0 4
42861: PUSH
42862: LD_VAR 0 8
42866: NOT
42867: AND
42868: IFFALSE 42937
// begin sort := SortBySkill ( tmp , 4 ) ;
42870: LD_ADDR_VAR 0 9
42874: PUSH
42875: LD_VAR 0 4
42879: PPUSH
42880: LD_INT 4
42882: PPUSH
42883: CALL 101617 0 2
42887: ST_TO_ADDR
// if sort then
42888: LD_VAR 0 9
42892: IFFALSE 42908
// p := sort [ 1 ] ;
42894: LD_ADDR_VAR 0 11
42898: PUSH
42899: LD_VAR 0 9
42903: PUSH
42904: LD_INT 1
42906: ARRAY
42907: ST_TO_ADDR
// if p then
42908: LD_VAR 0 11
42912: IFFALSE 42937
// result := Replace ( result , 4 , p ) ;
42914: LD_ADDR_VAR 0 2
42918: PUSH
42919: LD_VAR 0 2
42923: PPUSH
42924: LD_INT 4
42926: PPUSH
42927: LD_VAR 0 11
42931: PPUSH
42932: CALL_OW 1
42936: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42937: LD_ADDR_VAR 0 4
42941: PUSH
42942: LD_VAR 0 4
42946: PUSH
42947: LD_VAR 0 7
42951: DIFF
42952: ST_TO_ADDR
// if tmp and mech < 6 then
42953: LD_VAR 0 4
42957: PUSH
42958: LD_VAR 0 7
42962: PUSH
42963: LD_INT 6
42965: LESS
42966: AND
42967: IFFALSE 43149
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42969: LD_ADDR_VAR 0 9
42973: PUSH
42974: LD_VAR 0 4
42978: PUSH
42979: LD_VAR 0 7
42983: DIFF
42984: PPUSH
42985: LD_INT 3
42987: PPUSH
42988: CALL 101617 0 2
42992: ST_TO_ADDR
// p := [ ] ;
42993: LD_ADDR_VAR 0 11
42997: PUSH
42998: EMPTY
42999: ST_TO_ADDR
// if sort then
43000: LD_VAR 0 9
43004: IFFALSE 43120
// for i = 1 to 6 - mech do
43006: LD_ADDR_VAR 0 3
43010: PUSH
43011: DOUBLE
43012: LD_INT 1
43014: DEC
43015: ST_TO_ADDR
43016: LD_INT 6
43018: PUSH
43019: LD_VAR 0 7
43023: MINUS
43024: PUSH
43025: FOR_TO
43026: IFFALSE 43118
// begin if i = sort then
43028: LD_VAR 0 3
43032: PUSH
43033: LD_VAR 0 9
43037: EQUAL
43038: IFFALSE 43042
// break ;
43040: GO 43118
// if GetClass ( i ) = 3 then
43042: LD_VAR 0 3
43046: PPUSH
43047: CALL_OW 257
43051: PUSH
43052: LD_INT 3
43054: EQUAL
43055: IFFALSE 43059
// continue ;
43057: GO 43025
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43059: LD_ADDR_VAR 0 11
43063: PUSH
43064: LD_VAR 0 11
43068: PPUSH
43069: LD_VAR 0 11
43073: PUSH
43074: LD_INT 1
43076: PLUS
43077: PPUSH
43078: LD_VAR 0 9
43082: PUSH
43083: LD_VAR 0 3
43087: ARRAY
43088: PPUSH
43089: CALL_OW 2
43093: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: LD_VAR 0 4
43103: PUSH
43104: LD_VAR 0 9
43108: PUSH
43109: LD_VAR 0 3
43113: ARRAY
43114: DIFF
43115: ST_TO_ADDR
// end ;
43116: GO 43025
43118: POP
43119: POP
// if p then
43120: LD_VAR 0 11
43124: IFFALSE 43149
// result := Replace ( result , 3 , p ) ;
43126: LD_ADDR_VAR 0 2
43130: PUSH
43131: LD_VAR 0 2
43135: PPUSH
43136: LD_INT 3
43138: PPUSH
43139: LD_VAR 0 11
43143: PPUSH
43144: CALL_OW 1
43148: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43149: LD_ADDR_VAR 0 4
43153: PUSH
43154: LD_VAR 0 4
43158: PUSH
43159: LD_VAR 0 6
43163: DIFF
43164: ST_TO_ADDR
// if tmp and eng < 4 then
43165: LD_VAR 0 4
43169: PUSH
43170: LD_VAR 0 6
43174: PUSH
43175: LD_INT 4
43177: LESS
43178: AND
43179: IFFALSE 43369
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43181: LD_ADDR_VAR 0 9
43185: PUSH
43186: LD_VAR 0 4
43190: PUSH
43191: LD_VAR 0 7
43195: PUSH
43196: LD_VAR 0 6
43200: UNION
43201: DIFF
43202: PPUSH
43203: LD_INT 2
43205: PPUSH
43206: CALL 101617 0 2
43210: ST_TO_ADDR
// p := [ ] ;
43211: LD_ADDR_VAR 0 11
43215: PUSH
43216: EMPTY
43217: ST_TO_ADDR
// if sort then
43218: LD_VAR 0 9
43222: IFFALSE 43338
// for i = 1 to 4 - eng do
43224: LD_ADDR_VAR 0 3
43228: PUSH
43229: DOUBLE
43230: LD_INT 1
43232: DEC
43233: ST_TO_ADDR
43234: LD_INT 4
43236: PUSH
43237: LD_VAR 0 6
43241: MINUS
43242: PUSH
43243: FOR_TO
43244: IFFALSE 43336
// begin if i = sort then
43246: LD_VAR 0 3
43250: PUSH
43251: LD_VAR 0 9
43255: EQUAL
43256: IFFALSE 43260
// break ;
43258: GO 43336
// if GetClass ( i ) = 2 then
43260: LD_VAR 0 3
43264: PPUSH
43265: CALL_OW 257
43269: PUSH
43270: LD_INT 2
43272: EQUAL
43273: IFFALSE 43277
// continue ;
43275: GO 43243
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43277: LD_ADDR_VAR 0 11
43281: PUSH
43282: LD_VAR 0 11
43286: PPUSH
43287: LD_VAR 0 11
43291: PUSH
43292: LD_INT 1
43294: PLUS
43295: PPUSH
43296: LD_VAR 0 9
43300: PUSH
43301: LD_VAR 0 3
43305: ARRAY
43306: PPUSH
43307: CALL_OW 2
43311: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43312: LD_ADDR_VAR 0 4
43316: PUSH
43317: LD_VAR 0 4
43321: PUSH
43322: LD_VAR 0 9
43326: PUSH
43327: LD_VAR 0 3
43331: ARRAY
43332: DIFF
43333: ST_TO_ADDR
// end ;
43334: GO 43243
43336: POP
43337: POP
// if p then
43338: LD_VAR 0 11
43342: IFFALSE 43367
// result := Replace ( result , 2 , p ) ;
43344: LD_ADDR_VAR 0 2
43348: PUSH
43349: LD_VAR 0 2
43353: PPUSH
43354: LD_INT 2
43356: PPUSH
43357: LD_VAR 0 11
43361: PPUSH
43362: CALL_OW 1
43366: ST_TO_ADDR
// end else
43367: GO 43413
// for i = eng downto 5 do
43369: LD_ADDR_VAR 0 3
43373: PUSH
43374: DOUBLE
43375: LD_VAR 0 6
43379: INC
43380: ST_TO_ADDR
43381: LD_INT 5
43383: PUSH
43384: FOR_DOWNTO
43385: IFFALSE 43411
// tmp := tmp union eng [ i ] ;
43387: LD_ADDR_VAR 0 4
43391: PUSH
43392: LD_VAR 0 4
43396: PUSH
43397: LD_VAR 0 6
43401: PUSH
43402: LD_VAR 0 3
43406: ARRAY
43407: UNION
43408: ST_TO_ADDR
43409: GO 43384
43411: POP
43412: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43413: LD_ADDR_VAR 0 2
43417: PUSH
43418: LD_VAR 0 2
43422: PPUSH
43423: LD_INT 1
43425: PPUSH
43426: LD_VAR 0 4
43430: PUSH
43431: LD_VAR 0 5
43435: DIFF
43436: PPUSH
43437: CALL_OW 1
43441: ST_TO_ADDR
// exit ;
43442: GO 43444
// end ; end ;
43444: LD_VAR 0 2
43448: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43449: LD_INT 0
43451: PPUSH
43452: PPUSH
43453: PPUSH
// if not mc_bases then
43454: LD_EXP 97
43458: NOT
43459: IFFALSE 43463
// exit ;
43461: GO 43605
// for i = 1 to mc_bases do
43463: LD_ADDR_VAR 0 2
43467: PUSH
43468: DOUBLE
43469: LD_INT 1
43471: DEC
43472: ST_TO_ADDR
43473: LD_EXP 97
43477: PUSH
43478: FOR_TO
43479: IFFALSE 43596
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43481: LD_ADDR_VAR 0 3
43485: PUSH
43486: LD_EXP 97
43490: PUSH
43491: LD_VAR 0 2
43495: ARRAY
43496: PPUSH
43497: LD_INT 21
43499: PUSH
43500: LD_INT 3
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 3
43509: PUSH
43510: LD_INT 2
43512: PUSH
43513: LD_INT 30
43515: PUSH
43516: LD_INT 29
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 30
43525: PUSH
43526: LD_INT 30
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: LIST
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 3
43544: PUSH
43545: LD_INT 24
43547: PUSH
43548: LD_INT 1000
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: LIST
43563: PPUSH
43564: CALL_OW 72
43568: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43569: LD_ADDR_EXP 98
43573: PUSH
43574: LD_EXP 98
43578: PPUSH
43579: LD_VAR 0 2
43583: PPUSH
43584: LD_VAR 0 3
43588: PPUSH
43589: CALL_OW 1
43593: ST_TO_ADDR
// end ;
43594: GO 43478
43596: POP
43597: POP
// RaiseSailEvent ( 101 ) ;
43598: LD_INT 101
43600: PPUSH
43601: CALL_OW 427
// end ;
43605: LD_VAR 0 1
43609: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43610: LD_INT 0
43612: PPUSH
43613: PPUSH
43614: PPUSH
43615: PPUSH
43616: PPUSH
43617: PPUSH
43618: PPUSH
// if not mc_bases then
43619: LD_EXP 97
43623: NOT
43624: IFFALSE 43628
// exit ;
43626: GO 44190
// for i = 1 to mc_bases do
43628: LD_ADDR_VAR 0 2
43632: PUSH
43633: DOUBLE
43634: LD_INT 1
43636: DEC
43637: ST_TO_ADDR
43638: LD_EXP 97
43642: PUSH
43643: FOR_TO
43644: IFFALSE 44181
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43646: LD_ADDR_VAR 0 5
43650: PUSH
43651: LD_EXP 97
43655: PUSH
43656: LD_VAR 0 2
43660: ARRAY
43661: PUSH
43662: LD_EXP 126
43666: PUSH
43667: LD_VAR 0 2
43671: ARRAY
43672: UNION
43673: PPUSH
43674: LD_INT 21
43676: PUSH
43677: LD_INT 1
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 1
43686: PUSH
43687: LD_INT 3
43689: PUSH
43690: LD_INT 54
43692: PUSH
43693: EMPTY
43694: LIST
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 3
43702: PUSH
43703: LD_INT 24
43705: PUSH
43706: LD_INT 1000
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: LIST
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PPUSH
43726: CALL_OW 72
43730: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43731: LD_ADDR_VAR 0 6
43735: PUSH
43736: LD_EXP 97
43740: PUSH
43741: LD_VAR 0 2
43745: ARRAY
43746: PPUSH
43747: LD_INT 21
43749: PUSH
43750: LD_INT 1
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 1
43759: PUSH
43760: LD_INT 3
43762: PUSH
43763: LD_INT 54
43765: PUSH
43766: EMPTY
43767: LIST
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 3
43775: PUSH
43776: LD_INT 24
43778: PUSH
43779: LD_INT 250
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: EMPTY
43791: LIST
43792: LIST
43793: LIST
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PPUSH
43799: CALL_OW 72
43803: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43804: LD_ADDR_VAR 0 7
43808: PUSH
43809: LD_VAR 0 5
43813: PUSH
43814: LD_VAR 0 6
43818: DIFF
43819: ST_TO_ADDR
// if not need_heal_1 then
43820: LD_VAR 0 6
43824: NOT
43825: IFFALSE 43858
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43827: LD_ADDR_EXP 100
43831: PUSH
43832: LD_EXP 100
43836: PPUSH
43837: LD_VAR 0 2
43841: PUSH
43842: LD_INT 1
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PPUSH
43849: EMPTY
43850: PPUSH
43851: CALL 70869 0 3
43855: ST_TO_ADDR
43856: GO 43928
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43858: LD_ADDR_EXP 100
43862: PUSH
43863: LD_EXP 100
43867: PPUSH
43868: LD_VAR 0 2
43872: PUSH
43873: LD_INT 1
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PPUSH
43880: LD_EXP 100
43884: PUSH
43885: LD_VAR 0 2
43889: ARRAY
43890: PUSH
43891: LD_INT 1
43893: ARRAY
43894: PPUSH
43895: LD_INT 3
43897: PUSH
43898: LD_INT 24
43900: PUSH
43901: LD_INT 1000
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PPUSH
43912: CALL_OW 72
43916: PUSH
43917: LD_VAR 0 6
43921: UNION
43922: PPUSH
43923: CALL 70869 0 3
43927: ST_TO_ADDR
// if not need_heal_2 then
43928: LD_VAR 0 7
43932: NOT
43933: IFFALSE 43966
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43935: LD_ADDR_EXP 100
43939: PUSH
43940: LD_EXP 100
43944: PPUSH
43945: LD_VAR 0 2
43949: PUSH
43950: LD_INT 2
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PPUSH
43957: EMPTY
43958: PPUSH
43959: CALL 70869 0 3
43963: ST_TO_ADDR
43964: GO 43998
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43966: LD_ADDR_EXP 100
43970: PUSH
43971: LD_EXP 100
43975: PPUSH
43976: LD_VAR 0 2
43980: PUSH
43981: LD_INT 2
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: PPUSH
43988: LD_VAR 0 7
43992: PPUSH
43993: CALL 70869 0 3
43997: ST_TO_ADDR
// if need_heal_2 then
43998: LD_VAR 0 7
44002: IFFALSE 44163
// for j in need_heal_2 do
44004: LD_ADDR_VAR 0 3
44008: PUSH
44009: LD_VAR 0 7
44013: PUSH
44014: FOR_IN
44015: IFFALSE 44161
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44017: LD_ADDR_VAR 0 5
44021: PUSH
44022: LD_EXP 97
44026: PUSH
44027: LD_VAR 0 2
44031: ARRAY
44032: PPUSH
44033: LD_INT 2
44035: PUSH
44036: LD_INT 30
44038: PUSH
44039: LD_INT 6
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 30
44048: PUSH
44049: LD_INT 7
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 30
44058: PUSH
44059: LD_INT 8
44061: PUSH
44062: EMPTY
44063: LIST
44064: LIST
44065: PUSH
44066: LD_INT 30
44068: PUSH
44069: LD_INT 0
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 30
44078: PUSH
44079: LD_INT 1
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: EMPTY
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: PPUSH
44094: CALL_OW 72
44098: ST_TO_ADDR
// if tmp then
44099: LD_VAR 0 5
44103: IFFALSE 44159
// begin k := NearestUnitToUnit ( tmp , j ) ;
44105: LD_ADDR_VAR 0 4
44109: PUSH
44110: LD_VAR 0 5
44114: PPUSH
44115: LD_VAR 0 3
44119: PPUSH
44120: CALL_OW 74
44124: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44125: LD_VAR 0 3
44129: PPUSH
44130: LD_VAR 0 4
44134: PPUSH
44135: CALL_OW 296
44139: PUSH
44140: LD_INT 5
44142: GREATER
44143: IFFALSE 44159
// ComMoveToNearbyEntrance ( j , k ) ;
44145: LD_VAR 0 3
44149: PPUSH
44150: LD_VAR 0 4
44154: PPUSH
44155: CALL 103985 0 2
// end ; end ;
44159: GO 44014
44161: POP
44162: POP
// if not need_heal_1 and not need_heal_2 then
44163: LD_VAR 0 6
44167: NOT
44168: PUSH
44169: LD_VAR 0 7
44173: NOT
44174: AND
44175: IFFALSE 44179
// continue ;
44177: GO 43643
// end ;
44179: GO 43643
44181: POP
44182: POP
// RaiseSailEvent ( 102 ) ;
44183: LD_INT 102
44185: PPUSH
44186: CALL_OW 427
// end ;
44190: LD_VAR 0 1
44194: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44195: LD_INT 0
44197: PPUSH
44198: PPUSH
44199: PPUSH
44200: PPUSH
44201: PPUSH
44202: PPUSH
44203: PPUSH
44204: PPUSH
// if not mc_bases then
44205: LD_EXP 97
44209: NOT
44210: IFFALSE 44214
// exit ;
44212: GO 45093
// for i = 1 to mc_bases do
44214: LD_ADDR_VAR 0 2
44218: PUSH
44219: DOUBLE
44220: LD_INT 1
44222: DEC
44223: ST_TO_ADDR
44224: LD_EXP 97
44228: PUSH
44229: FOR_TO
44230: IFFALSE 45091
// begin if not mc_building_need_repair [ i ] then
44232: LD_EXP 98
44236: PUSH
44237: LD_VAR 0 2
44241: ARRAY
44242: NOT
44243: IFFALSE 44428
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_EXP 116
44254: PUSH
44255: LD_VAR 0 2
44259: ARRAY
44260: PPUSH
44261: LD_INT 3
44263: PUSH
44264: LD_INT 24
44266: PUSH
44267: LD_INT 1000
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 2
44280: PUSH
44281: LD_INT 34
44283: PUSH
44284: LD_INT 13
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: PUSH
44291: LD_INT 34
44293: PUSH
44294: LD_INT 52
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 34
44303: PUSH
44304: LD_INT 88
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: LIST
44315: LIST
44316: PUSH
44317: EMPTY
44318: LIST
44319: LIST
44320: PPUSH
44321: CALL_OW 72
44325: ST_TO_ADDR
// if cranes then
44326: LD_VAR 0 6
44330: IFFALSE 44392
// for j in cranes do
44332: LD_ADDR_VAR 0 3
44336: PUSH
44337: LD_VAR 0 6
44341: PUSH
44342: FOR_IN
44343: IFFALSE 44390
// if not IsInArea ( j , mc_parking [ i ] ) then
44345: LD_VAR 0 3
44349: PPUSH
44350: LD_EXP 121
44354: PUSH
44355: LD_VAR 0 2
44359: ARRAY
44360: PPUSH
44361: CALL_OW 308
44365: NOT
44366: IFFALSE 44388
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44368: LD_VAR 0 3
44372: PPUSH
44373: LD_EXP 121
44377: PUSH
44378: LD_VAR 0 2
44382: ARRAY
44383: PPUSH
44384: CALL_OW 113
44388: GO 44342
44390: POP
44391: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44392: LD_ADDR_EXP 99
44396: PUSH
44397: LD_EXP 99
44401: PPUSH
44402: LD_VAR 0 2
44406: PPUSH
44407: EMPTY
44408: PPUSH
44409: CALL_OW 1
44413: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44414: LD_VAR 0 2
44418: PPUSH
44419: LD_INT 101
44421: PPUSH
44422: CALL 39282 0 2
// continue ;
44426: GO 44229
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44428: LD_ADDR_EXP 103
44432: PUSH
44433: LD_EXP 103
44437: PPUSH
44438: LD_VAR 0 2
44442: PPUSH
44443: EMPTY
44444: PPUSH
44445: CALL_OW 1
44449: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44450: LD_VAR 0 2
44454: PPUSH
44455: LD_INT 103
44457: PPUSH
44458: CALL 39282 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44462: LD_ADDR_VAR 0 5
44466: PUSH
44467: LD_EXP 97
44471: PUSH
44472: LD_VAR 0 2
44476: ARRAY
44477: PUSH
44478: LD_EXP 126
44482: PUSH
44483: LD_VAR 0 2
44487: ARRAY
44488: UNION
44489: PPUSH
44490: LD_INT 2
44492: PUSH
44493: LD_INT 25
44495: PUSH
44496: LD_INT 2
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 25
44505: PUSH
44506: LD_INT 16
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: LIST
44517: PUSH
44518: EMPTY
44519: LIST
44520: PPUSH
44521: CALL_OW 72
44525: ST_TO_ADDR
// if mc_need_heal [ i ] then
44526: LD_EXP 100
44530: PUSH
44531: LD_VAR 0 2
44535: ARRAY
44536: IFFALSE 44580
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44538: LD_ADDR_VAR 0 5
44542: PUSH
44543: LD_VAR 0 5
44547: PUSH
44548: LD_EXP 100
44552: PUSH
44553: LD_VAR 0 2
44557: ARRAY
44558: PUSH
44559: LD_INT 1
44561: ARRAY
44562: PUSH
44563: LD_EXP 100
44567: PUSH
44568: LD_VAR 0 2
44572: ARRAY
44573: PUSH
44574: LD_INT 2
44576: ARRAY
44577: UNION
44578: DIFF
44579: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44580: LD_ADDR_VAR 0 6
44584: PUSH
44585: LD_EXP 116
44589: PUSH
44590: LD_VAR 0 2
44594: ARRAY
44595: PPUSH
44596: LD_INT 2
44598: PUSH
44599: LD_INT 34
44601: PUSH
44602: LD_INT 13
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 34
44611: PUSH
44612: LD_INT 52
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 34
44621: PUSH
44622: LD_INT 88
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: PPUSH
44635: CALL_OW 72
44639: ST_TO_ADDR
// if cranes then
44640: LD_VAR 0 6
44644: IFFALSE 44780
// begin for j in cranes do
44646: LD_ADDR_VAR 0 3
44650: PUSH
44651: LD_VAR 0 6
44655: PUSH
44656: FOR_IN
44657: IFFALSE 44778
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44659: LD_VAR 0 3
44663: PPUSH
44664: CALL_OW 256
44668: PUSH
44669: LD_INT 1000
44671: EQUAL
44672: PUSH
44673: LD_VAR 0 3
44677: PPUSH
44678: CALL_OW 314
44682: NOT
44683: AND
44684: IFFALSE 44718
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44686: LD_VAR 0 3
44690: PPUSH
44691: LD_EXP 98
44695: PUSH
44696: LD_VAR 0 2
44700: ARRAY
44701: PPUSH
44702: LD_VAR 0 3
44706: PPUSH
44707: CALL_OW 74
44711: PPUSH
44712: CALL_OW 130
44716: GO 44776
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44718: LD_VAR 0 3
44722: PPUSH
44723: CALL_OW 256
44727: PUSH
44728: LD_INT 500
44730: LESS
44731: PUSH
44732: LD_VAR 0 3
44736: PPUSH
44737: LD_EXP 121
44741: PUSH
44742: LD_VAR 0 2
44746: ARRAY
44747: PPUSH
44748: CALL_OW 308
44752: NOT
44753: AND
44754: IFFALSE 44776
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44756: LD_VAR 0 3
44760: PPUSH
44761: LD_EXP 121
44765: PUSH
44766: LD_VAR 0 2
44770: ARRAY
44771: PPUSH
44772: CALL_OW 113
// end ;
44776: GO 44656
44778: POP
44779: POP
// end ; if tmp > 3 then
44780: LD_VAR 0 5
44784: PUSH
44785: LD_INT 3
44787: GREATER
44788: IFFALSE 44808
// tmp := ShrinkArray ( tmp , 4 ) ;
44790: LD_ADDR_VAR 0 5
44794: PUSH
44795: LD_VAR 0 5
44799: PPUSH
44800: LD_INT 4
44802: PPUSH
44803: CALL 103423 0 2
44807: ST_TO_ADDR
// if not tmp then
44808: LD_VAR 0 5
44812: NOT
44813: IFFALSE 44817
// continue ;
44815: GO 44229
// for j in tmp do
44817: LD_ADDR_VAR 0 3
44821: PUSH
44822: LD_VAR 0 5
44826: PUSH
44827: FOR_IN
44828: IFFALSE 45087
// begin if IsInUnit ( j ) then
44830: LD_VAR 0 3
44834: PPUSH
44835: CALL_OW 310
44839: IFFALSE 44850
// ComExitBuilding ( j ) ;
44841: LD_VAR 0 3
44845: PPUSH
44846: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44850: LD_VAR 0 3
44854: PUSH
44855: LD_EXP 99
44859: PUSH
44860: LD_VAR 0 2
44864: ARRAY
44865: IN
44866: NOT
44867: IFFALSE 44925
// begin SetTag ( j , 101 ) ;
44869: LD_VAR 0 3
44873: PPUSH
44874: LD_INT 101
44876: PPUSH
44877: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44881: LD_ADDR_EXP 99
44885: PUSH
44886: LD_EXP 99
44890: PPUSH
44891: LD_VAR 0 2
44895: PUSH
44896: LD_EXP 99
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: PUSH
44907: LD_INT 1
44909: PLUS
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PPUSH
44915: LD_VAR 0 3
44919: PPUSH
44920: CALL 70869 0 3
44924: ST_TO_ADDR
// end ; wait ( 1 ) ;
44925: LD_INT 1
44927: PPUSH
44928: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44932: LD_ADDR_VAR 0 7
44936: PUSH
44937: LD_EXP 98
44941: PUSH
44942: LD_VAR 0 2
44946: ARRAY
44947: ST_TO_ADDR
// if mc_scan [ i ] then
44948: LD_EXP 120
44952: PUSH
44953: LD_VAR 0 2
44957: ARRAY
44958: IFFALSE 45020
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44960: LD_ADDR_VAR 0 7
44964: PUSH
44965: LD_EXP 98
44969: PUSH
44970: LD_VAR 0 2
44974: ARRAY
44975: PPUSH
44976: LD_INT 3
44978: PUSH
44979: LD_INT 30
44981: PUSH
44982: LD_INT 32
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 30
44991: PUSH
44992: LD_INT 33
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 30
45001: PUSH
45002: LD_INT 31
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: PPUSH
45015: CALL_OW 72
45019: ST_TO_ADDR
// if not to_repair_tmp then
45020: LD_VAR 0 7
45024: NOT
45025: IFFALSE 45029
// continue ;
45027: GO 44827
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45029: LD_ADDR_VAR 0 8
45033: PUSH
45034: LD_VAR 0 7
45038: PPUSH
45039: LD_VAR 0 3
45043: PPUSH
45044: CALL_OW 74
45048: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45049: LD_VAR 0 8
45053: PPUSH
45054: LD_INT 16
45056: PPUSH
45057: CALL 73466 0 2
45061: PUSH
45062: LD_INT 4
45064: ARRAY
45065: PUSH
45066: LD_INT 10
45068: LESS
45069: IFFALSE 45085
// ComRepairBuilding ( j , to_repair ) ;
45071: LD_VAR 0 3
45075: PPUSH
45076: LD_VAR 0 8
45080: PPUSH
45081: CALL_OW 130
// end ;
45085: GO 44827
45087: POP
45088: POP
// end ;
45089: GO 44229
45091: POP
45092: POP
// end ;
45093: LD_VAR 0 1
45097: RET
// export function MC_Heal ; var i , j , tmp ; begin
45098: LD_INT 0
45100: PPUSH
45101: PPUSH
45102: PPUSH
45103: PPUSH
// if not mc_bases then
45104: LD_EXP 97
45108: NOT
45109: IFFALSE 45113
// exit ;
45111: GO 45515
// for i = 1 to mc_bases do
45113: LD_ADDR_VAR 0 2
45117: PUSH
45118: DOUBLE
45119: LD_INT 1
45121: DEC
45122: ST_TO_ADDR
45123: LD_EXP 97
45127: PUSH
45128: FOR_TO
45129: IFFALSE 45513
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45131: LD_EXP 100
45135: PUSH
45136: LD_VAR 0 2
45140: ARRAY
45141: PUSH
45142: LD_INT 1
45144: ARRAY
45145: NOT
45146: PUSH
45147: LD_EXP 100
45151: PUSH
45152: LD_VAR 0 2
45156: ARRAY
45157: PUSH
45158: LD_INT 2
45160: ARRAY
45161: NOT
45162: AND
45163: IFFALSE 45201
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45165: LD_ADDR_EXP 101
45169: PUSH
45170: LD_EXP 101
45174: PPUSH
45175: LD_VAR 0 2
45179: PPUSH
45180: EMPTY
45181: PPUSH
45182: CALL_OW 1
45186: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45187: LD_VAR 0 2
45191: PPUSH
45192: LD_INT 102
45194: PPUSH
45195: CALL 39282 0 2
// continue ;
45199: GO 45128
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45201: LD_ADDR_VAR 0 4
45205: PUSH
45206: LD_EXP 97
45210: PUSH
45211: LD_VAR 0 2
45215: ARRAY
45216: PPUSH
45217: LD_INT 25
45219: PUSH
45220: LD_INT 4
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PPUSH
45227: CALL_OW 72
45231: ST_TO_ADDR
// if not tmp then
45232: LD_VAR 0 4
45236: NOT
45237: IFFALSE 45241
// continue ;
45239: GO 45128
// if mc_taming [ i ] then
45241: LD_EXP 128
45245: PUSH
45246: LD_VAR 0 2
45250: ARRAY
45251: IFFALSE 45275
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45253: LD_ADDR_EXP 128
45257: PUSH
45258: LD_EXP 128
45262: PPUSH
45263: LD_VAR 0 2
45267: PPUSH
45268: EMPTY
45269: PPUSH
45270: CALL_OW 1
45274: ST_TO_ADDR
// for j in tmp do
45275: LD_ADDR_VAR 0 3
45279: PUSH
45280: LD_VAR 0 4
45284: PUSH
45285: FOR_IN
45286: IFFALSE 45509
// begin if IsInUnit ( j ) then
45288: LD_VAR 0 3
45292: PPUSH
45293: CALL_OW 310
45297: IFFALSE 45308
// ComExitBuilding ( j ) ;
45299: LD_VAR 0 3
45303: PPUSH
45304: CALL_OW 122
// if not j in mc_healers [ i ] then
45308: LD_VAR 0 3
45312: PUSH
45313: LD_EXP 101
45317: PUSH
45318: LD_VAR 0 2
45322: ARRAY
45323: IN
45324: NOT
45325: IFFALSE 45371
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45327: LD_ADDR_EXP 101
45331: PUSH
45332: LD_EXP 101
45336: PPUSH
45337: LD_VAR 0 2
45341: PUSH
45342: LD_EXP 101
45346: PUSH
45347: LD_VAR 0 2
45351: ARRAY
45352: PUSH
45353: LD_INT 1
45355: PLUS
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PPUSH
45361: LD_VAR 0 3
45365: PPUSH
45366: CALL 70869 0 3
45370: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45371: LD_VAR 0 3
45375: PPUSH
45376: CALL_OW 110
45380: PUSH
45381: LD_INT 102
45383: NONEQUAL
45384: IFFALSE 45398
// SetTag ( j , 102 ) ;
45386: LD_VAR 0 3
45390: PPUSH
45391: LD_INT 102
45393: PPUSH
45394: CALL_OW 109
// Wait ( 3 ) ;
45398: LD_INT 3
45400: PPUSH
45401: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45405: LD_EXP 100
45409: PUSH
45410: LD_VAR 0 2
45414: ARRAY
45415: PUSH
45416: LD_INT 1
45418: ARRAY
45419: IFFALSE 45451
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45421: LD_VAR 0 3
45425: PPUSH
45426: LD_EXP 100
45430: PUSH
45431: LD_VAR 0 2
45435: ARRAY
45436: PUSH
45437: LD_INT 1
45439: ARRAY
45440: PUSH
45441: LD_INT 1
45443: ARRAY
45444: PPUSH
45445: CALL_OW 128
45449: GO 45507
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45451: LD_VAR 0 3
45455: PPUSH
45456: CALL_OW 314
45460: NOT
45461: PUSH
45462: LD_EXP 100
45466: PUSH
45467: LD_VAR 0 2
45471: ARRAY
45472: PUSH
45473: LD_INT 2
45475: ARRAY
45476: AND
45477: IFFALSE 45507
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45479: LD_VAR 0 3
45483: PPUSH
45484: LD_EXP 100
45488: PUSH
45489: LD_VAR 0 2
45493: ARRAY
45494: PUSH
45495: LD_INT 2
45497: ARRAY
45498: PUSH
45499: LD_INT 1
45501: ARRAY
45502: PPUSH
45503: CALL_OW 128
// end ;
45507: GO 45285
45509: POP
45510: POP
// end ;
45511: GO 45128
45513: POP
45514: POP
// end ;
45515: LD_VAR 0 1
45519: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45520: LD_INT 0
45522: PPUSH
45523: PPUSH
45524: PPUSH
45525: PPUSH
45526: PPUSH
// if not mc_bases then
45527: LD_EXP 97
45531: NOT
45532: IFFALSE 45536
// exit ;
45534: GO 46707
// for i = 1 to mc_bases do
45536: LD_ADDR_VAR 0 2
45540: PUSH
45541: DOUBLE
45542: LD_INT 1
45544: DEC
45545: ST_TO_ADDR
45546: LD_EXP 97
45550: PUSH
45551: FOR_TO
45552: IFFALSE 46705
// begin if mc_scan [ i ] then
45554: LD_EXP 120
45558: PUSH
45559: LD_VAR 0 2
45563: ARRAY
45564: IFFALSE 45568
// continue ;
45566: GO 45551
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45568: LD_EXP 102
45572: PUSH
45573: LD_VAR 0 2
45577: ARRAY
45578: NOT
45579: PUSH
45580: LD_EXP 104
45584: PUSH
45585: LD_VAR 0 2
45589: ARRAY
45590: NOT
45591: AND
45592: PUSH
45593: LD_EXP 103
45597: PUSH
45598: LD_VAR 0 2
45602: ARRAY
45603: AND
45604: IFFALSE 45642
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45606: LD_ADDR_EXP 103
45610: PUSH
45611: LD_EXP 103
45615: PPUSH
45616: LD_VAR 0 2
45620: PPUSH
45621: EMPTY
45622: PPUSH
45623: CALL_OW 1
45627: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45628: LD_VAR 0 2
45632: PPUSH
45633: LD_INT 103
45635: PPUSH
45636: CALL 39282 0 2
// continue ;
45640: GO 45551
// end ; if mc_construct_list [ i ] then
45642: LD_EXP 104
45646: PUSH
45647: LD_VAR 0 2
45651: ARRAY
45652: IFFALSE 45872
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45654: LD_ADDR_VAR 0 4
45658: PUSH
45659: LD_EXP 97
45663: PUSH
45664: LD_VAR 0 2
45668: ARRAY
45669: PPUSH
45670: LD_INT 25
45672: PUSH
45673: LD_INT 2
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PPUSH
45680: CALL_OW 72
45684: PUSH
45685: LD_EXP 99
45689: PUSH
45690: LD_VAR 0 2
45694: ARRAY
45695: DIFF
45696: ST_TO_ADDR
// if not tmp then
45697: LD_VAR 0 4
45701: NOT
45702: IFFALSE 45706
// continue ;
45704: GO 45551
// for j in tmp do
45706: LD_ADDR_VAR 0 3
45710: PUSH
45711: LD_VAR 0 4
45715: PUSH
45716: FOR_IN
45717: IFFALSE 45868
// begin if not mc_builders [ i ] then
45719: LD_EXP 103
45723: PUSH
45724: LD_VAR 0 2
45728: ARRAY
45729: NOT
45730: IFFALSE 45788
// begin SetTag ( j , 103 ) ;
45732: LD_VAR 0 3
45736: PPUSH
45737: LD_INT 103
45739: PPUSH
45740: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45744: LD_ADDR_EXP 103
45748: PUSH
45749: LD_EXP 103
45753: PPUSH
45754: LD_VAR 0 2
45758: PUSH
45759: LD_EXP 103
45763: PUSH
45764: LD_VAR 0 2
45768: ARRAY
45769: PUSH
45770: LD_INT 1
45772: PLUS
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: PPUSH
45778: LD_VAR 0 3
45782: PPUSH
45783: CALL 70869 0 3
45787: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45788: LD_VAR 0 3
45792: PPUSH
45793: CALL_OW 310
45797: IFFALSE 45808
// ComExitBuilding ( j ) ;
45799: LD_VAR 0 3
45803: PPUSH
45804: CALL_OW 122
// wait ( 3 ) ;
45808: LD_INT 3
45810: PPUSH
45811: CALL_OW 67
// if not mc_construct_list [ i ] then
45815: LD_EXP 104
45819: PUSH
45820: LD_VAR 0 2
45824: ARRAY
45825: NOT
45826: IFFALSE 45830
// break ;
45828: GO 45868
// if not HasTask ( j ) then
45830: LD_VAR 0 3
45834: PPUSH
45835: CALL_OW 314
45839: NOT
45840: IFFALSE 45866
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45842: LD_VAR 0 3
45846: PPUSH
45847: LD_EXP 104
45851: PUSH
45852: LD_VAR 0 2
45856: ARRAY
45857: PUSH
45858: LD_INT 1
45860: ARRAY
45861: PPUSH
45862: CALL 73730 0 2
// end ;
45866: GO 45716
45868: POP
45869: POP
// end else
45870: GO 46703
// if mc_build_list [ i ] then
45872: LD_EXP 102
45876: PUSH
45877: LD_VAR 0 2
45881: ARRAY
45882: IFFALSE 46703
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45884: LD_ADDR_VAR 0 5
45888: PUSH
45889: LD_EXP 97
45893: PUSH
45894: LD_VAR 0 2
45898: ARRAY
45899: PPUSH
45900: LD_INT 2
45902: PUSH
45903: LD_INT 30
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 30
45915: PUSH
45916: LD_INT 1
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: LIST
45927: PPUSH
45928: CALL_OW 72
45932: ST_TO_ADDR
// if depot then
45933: LD_VAR 0 5
45937: IFFALSE 45955
// depot := depot [ 1 ] else
45939: LD_ADDR_VAR 0 5
45943: PUSH
45944: LD_VAR 0 5
45948: PUSH
45949: LD_INT 1
45951: ARRAY
45952: ST_TO_ADDR
45953: GO 45963
// depot := 0 ;
45955: LD_ADDR_VAR 0 5
45959: PUSH
45960: LD_INT 0
45962: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45963: LD_EXP 102
45967: PUSH
45968: LD_VAR 0 2
45972: ARRAY
45973: PUSH
45974: LD_INT 1
45976: ARRAY
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PPUSH
45982: CALL 73554 0 1
45986: PUSH
45987: LD_EXP 97
45991: PUSH
45992: LD_VAR 0 2
45996: ARRAY
45997: PPUSH
45998: LD_INT 2
46000: PUSH
46001: LD_INT 30
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 30
46013: PUSH
46014: LD_INT 3
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: EMPTY
46022: LIST
46023: LIST
46024: LIST
46025: PPUSH
46026: CALL_OW 72
46030: NOT
46031: AND
46032: IFFALSE 46137
// begin for j = 1 to mc_build_list [ i ] do
46034: LD_ADDR_VAR 0 3
46038: PUSH
46039: DOUBLE
46040: LD_INT 1
46042: DEC
46043: ST_TO_ADDR
46044: LD_EXP 102
46048: PUSH
46049: LD_VAR 0 2
46053: ARRAY
46054: PUSH
46055: FOR_TO
46056: IFFALSE 46135
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46058: LD_EXP 102
46062: PUSH
46063: LD_VAR 0 2
46067: ARRAY
46068: PUSH
46069: LD_VAR 0 3
46073: ARRAY
46074: PUSH
46075: LD_INT 1
46077: ARRAY
46078: PUSH
46079: LD_INT 2
46081: EQUAL
46082: IFFALSE 46133
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46084: LD_ADDR_EXP 102
46088: PUSH
46089: LD_EXP 102
46093: PPUSH
46094: LD_VAR 0 2
46098: PPUSH
46099: LD_EXP 102
46103: PUSH
46104: LD_VAR 0 2
46108: ARRAY
46109: PPUSH
46110: LD_VAR 0 3
46114: PPUSH
46115: LD_INT 1
46117: PPUSH
46118: LD_INT 0
46120: PPUSH
46121: CALL 70287 0 4
46125: PPUSH
46126: CALL_OW 1
46130: ST_TO_ADDR
// break ;
46131: GO 46135
// end ;
46133: GO 46055
46135: POP
46136: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46137: LD_EXP 102
46141: PUSH
46142: LD_VAR 0 2
46146: ARRAY
46147: PUSH
46148: LD_INT 1
46150: ARRAY
46151: PUSH
46152: LD_INT 1
46154: ARRAY
46155: PUSH
46156: LD_INT 0
46158: EQUAL
46159: PUSH
46160: LD_VAR 0 5
46164: PUSH
46165: LD_VAR 0 5
46169: PPUSH
46170: LD_EXP 102
46174: PUSH
46175: LD_VAR 0 2
46179: ARRAY
46180: PUSH
46181: LD_INT 1
46183: ARRAY
46184: PUSH
46185: LD_INT 1
46187: ARRAY
46188: PPUSH
46189: LD_EXP 102
46193: PUSH
46194: LD_VAR 0 2
46198: ARRAY
46199: PUSH
46200: LD_INT 1
46202: ARRAY
46203: PUSH
46204: LD_INT 2
46206: ARRAY
46207: PPUSH
46208: LD_EXP 102
46212: PUSH
46213: LD_VAR 0 2
46217: ARRAY
46218: PUSH
46219: LD_INT 1
46221: ARRAY
46222: PUSH
46223: LD_INT 3
46225: ARRAY
46226: PPUSH
46227: LD_EXP 102
46231: PUSH
46232: LD_VAR 0 2
46236: ARRAY
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PUSH
46242: LD_INT 4
46244: ARRAY
46245: PPUSH
46246: CALL 78966 0 5
46250: AND
46251: OR
46252: IFFALSE 46533
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46254: LD_ADDR_VAR 0 4
46258: PUSH
46259: LD_EXP 97
46263: PUSH
46264: LD_VAR 0 2
46268: ARRAY
46269: PPUSH
46270: LD_INT 25
46272: PUSH
46273: LD_INT 2
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PPUSH
46280: CALL_OW 72
46284: PUSH
46285: LD_EXP 99
46289: PUSH
46290: LD_VAR 0 2
46294: ARRAY
46295: DIFF
46296: ST_TO_ADDR
// if not tmp then
46297: LD_VAR 0 4
46301: NOT
46302: IFFALSE 46306
// continue ;
46304: GO 45551
// for j in tmp do
46306: LD_ADDR_VAR 0 3
46310: PUSH
46311: LD_VAR 0 4
46315: PUSH
46316: FOR_IN
46317: IFFALSE 46529
// begin if not mc_builders [ i ] then
46319: LD_EXP 103
46323: PUSH
46324: LD_VAR 0 2
46328: ARRAY
46329: NOT
46330: IFFALSE 46388
// begin SetTag ( j , 103 ) ;
46332: LD_VAR 0 3
46336: PPUSH
46337: LD_INT 103
46339: PPUSH
46340: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46344: LD_ADDR_EXP 103
46348: PUSH
46349: LD_EXP 103
46353: PPUSH
46354: LD_VAR 0 2
46358: PUSH
46359: LD_EXP 103
46363: PUSH
46364: LD_VAR 0 2
46368: ARRAY
46369: PUSH
46370: LD_INT 1
46372: PLUS
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PPUSH
46378: LD_VAR 0 3
46382: PPUSH
46383: CALL 70869 0 3
46387: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46388: LD_VAR 0 3
46392: PPUSH
46393: CALL_OW 310
46397: IFFALSE 46408
// ComExitBuilding ( j ) ;
46399: LD_VAR 0 3
46403: PPUSH
46404: CALL_OW 122
// wait ( 3 ) ;
46408: LD_INT 3
46410: PPUSH
46411: CALL_OW 67
// if not mc_build_list [ i ] then
46415: LD_EXP 102
46419: PUSH
46420: LD_VAR 0 2
46424: ARRAY
46425: NOT
46426: IFFALSE 46430
// break ;
46428: GO 46529
// if not HasTask ( j ) then
46430: LD_VAR 0 3
46434: PPUSH
46435: CALL_OW 314
46439: NOT
46440: IFFALSE 46527
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46442: LD_VAR 0 3
46446: PPUSH
46447: LD_EXP 102
46451: PUSH
46452: LD_VAR 0 2
46456: ARRAY
46457: PUSH
46458: LD_INT 1
46460: ARRAY
46461: PUSH
46462: LD_INT 1
46464: ARRAY
46465: PPUSH
46466: LD_EXP 102
46470: PUSH
46471: LD_VAR 0 2
46475: ARRAY
46476: PUSH
46477: LD_INT 1
46479: ARRAY
46480: PUSH
46481: LD_INT 2
46483: ARRAY
46484: PPUSH
46485: LD_EXP 102
46489: PUSH
46490: LD_VAR 0 2
46494: ARRAY
46495: PUSH
46496: LD_INT 1
46498: ARRAY
46499: PUSH
46500: LD_INT 3
46502: ARRAY
46503: PPUSH
46504: LD_EXP 102
46508: PUSH
46509: LD_VAR 0 2
46513: ARRAY
46514: PUSH
46515: LD_INT 1
46517: ARRAY
46518: PUSH
46519: LD_INT 4
46521: ARRAY
46522: PPUSH
46523: CALL_OW 145
// end ;
46527: GO 46316
46529: POP
46530: POP
// end else
46531: GO 46703
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46533: LD_EXP 97
46537: PUSH
46538: LD_VAR 0 2
46542: ARRAY
46543: PPUSH
46544: LD_EXP 102
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PUSH
46555: LD_INT 1
46557: ARRAY
46558: PUSH
46559: LD_INT 1
46561: ARRAY
46562: PPUSH
46563: LD_EXP 102
46567: PUSH
46568: LD_VAR 0 2
46572: ARRAY
46573: PUSH
46574: LD_INT 1
46576: ARRAY
46577: PUSH
46578: LD_INT 2
46580: ARRAY
46581: PPUSH
46582: LD_EXP 102
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_INT 1
46595: ARRAY
46596: PUSH
46597: LD_INT 3
46599: ARRAY
46600: PPUSH
46601: LD_EXP 102
46605: PUSH
46606: LD_VAR 0 2
46610: ARRAY
46611: PUSH
46612: LD_INT 1
46614: ARRAY
46615: PUSH
46616: LD_INT 4
46618: ARRAY
46619: PPUSH
46620: LD_EXP 97
46624: PUSH
46625: LD_VAR 0 2
46629: ARRAY
46630: PPUSH
46631: LD_INT 21
46633: PUSH
46634: LD_INT 3
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: PPUSH
46641: CALL_OW 72
46645: PPUSH
46646: EMPTY
46647: PPUSH
46648: CALL 77720 0 7
46652: NOT
46653: IFFALSE 46703
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46655: LD_ADDR_EXP 102
46659: PUSH
46660: LD_EXP 102
46664: PPUSH
46665: LD_VAR 0 2
46669: PPUSH
46670: LD_EXP 102
46674: PUSH
46675: LD_VAR 0 2
46679: ARRAY
46680: PPUSH
46681: LD_INT 1
46683: PPUSH
46684: LD_INT 1
46686: NEG
46687: PPUSH
46688: LD_INT 0
46690: PPUSH
46691: CALL 70287 0 4
46695: PPUSH
46696: CALL_OW 1
46700: ST_TO_ADDR
// continue ;
46701: GO 45551
// end ; end ; end ;
46703: GO 45551
46705: POP
46706: POP
// end ;
46707: LD_VAR 0 1
46711: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46712: LD_INT 0
46714: PPUSH
46715: PPUSH
46716: PPUSH
46717: PPUSH
46718: PPUSH
46719: PPUSH
// if not mc_bases then
46720: LD_EXP 97
46724: NOT
46725: IFFALSE 46729
// exit ;
46727: GO 47156
// for i = 1 to mc_bases do
46729: LD_ADDR_VAR 0 2
46733: PUSH
46734: DOUBLE
46735: LD_INT 1
46737: DEC
46738: ST_TO_ADDR
46739: LD_EXP 97
46743: PUSH
46744: FOR_TO
46745: IFFALSE 47154
// begin tmp := mc_build_upgrade [ i ] ;
46747: LD_ADDR_VAR 0 4
46751: PUSH
46752: LD_EXP 129
46756: PUSH
46757: LD_VAR 0 2
46761: ARRAY
46762: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46763: LD_ADDR_VAR 0 6
46767: PUSH
46768: LD_EXP 130
46772: PUSH
46773: LD_VAR 0 2
46777: ARRAY
46778: PPUSH
46779: LD_INT 2
46781: PUSH
46782: LD_INT 30
46784: PUSH
46785: LD_INT 6
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: LD_INT 30
46794: PUSH
46795: LD_INT 7
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: LIST
46806: PPUSH
46807: CALL_OW 72
46811: ST_TO_ADDR
// if not tmp and not lab then
46812: LD_VAR 0 4
46816: NOT
46817: PUSH
46818: LD_VAR 0 6
46822: NOT
46823: AND
46824: IFFALSE 46828
// continue ;
46826: GO 46744
// if tmp then
46828: LD_VAR 0 4
46832: IFFALSE 46952
// for j in tmp do
46834: LD_ADDR_VAR 0 3
46838: PUSH
46839: LD_VAR 0 4
46843: PUSH
46844: FOR_IN
46845: IFFALSE 46950
// begin if UpgradeCost ( j ) then
46847: LD_VAR 0 3
46851: PPUSH
46852: CALL 77380 0 1
46856: IFFALSE 46948
// begin ComUpgrade ( j ) ;
46858: LD_VAR 0 3
46862: PPUSH
46863: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46867: LD_ADDR_EXP 129
46871: PUSH
46872: LD_EXP 129
46876: PPUSH
46877: LD_VAR 0 2
46881: PPUSH
46882: LD_EXP 129
46886: PUSH
46887: LD_VAR 0 2
46891: ARRAY
46892: PUSH
46893: LD_VAR 0 3
46897: DIFF
46898: PPUSH
46899: CALL_OW 1
46903: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46904: LD_ADDR_EXP 104
46908: PUSH
46909: LD_EXP 104
46913: PPUSH
46914: LD_VAR 0 2
46918: PUSH
46919: LD_EXP 104
46923: PUSH
46924: LD_VAR 0 2
46928: ARRAY
46929: PUSH
46930: LD_INT 1
46932: PLUS
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PPUSH
46938: LD_VAR 0 3
46942: PPUSH
46943: CALL 70869 0 3
46947: ST_TO_ADDR
// end ; end ;
46948: GO 46844
46950: POP
46951: POP
// if not lab or not mc_lab_upgrade [ i ] then
46952: LD_VAR 0 6
46956: NOT
46957: PUSH
46958: LD_EXP 131
46962: PUSH
46963: LD_VAR 0 2
46967: ARRAY
46968: NOT
46969: OR
46970: IFFALSE 46974
// continue ;
46972: GO 46744
// for j in lab do
46974: LD_ADDR_VAR 0 3
46978: PUSH
46979: LD_VAR 0 6
46983: PUSH
46984: FOR_IN
46985: IFFALSE 47150
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46987: LD_VAR 0 3
46991: PPUSH
46992: CALL_OW 266
46996: PUSH
46997: LD_INT 6
46999: PUSH
47000: LD_INT 7
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: IN
47007: PUSH
47008: LD_VAR 0 3
47012: PPUSH
47013: CALL_OW 461
47017: PUSH
47018: LD_INT 1
47020: NONEQUAL
47021: AND
47022: IFFALSE 47148
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_EXP 131
47033: PUSH
47034: LD_VAR 0 2
47038: ARRAY
47039: PUSH
47040: LD_INT 1
47042: ARRAY
47043: PPUSH
47044: CALL 77585 0 2
47048: IFFALSE 47148
// begin ComCancel ( j ) ;
47050: LD_VAR 0 3
47054: PPUSH
47055: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47059: LD_VAR 0 3
47063: PPUSH
47064: LD_EXP 131
47068: PUSH
47069: LD_VAR 0 2
47073: ARRAY
47074: PUSH
47075: LD_INT 1
47077: ARRAY
47078: PPUSH
47079: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47083: LD_VAR 0 3
47087: PUSH
47088: LD_EXP 104
47092: PUSH
47093: LD_VAR 0 2
47097: ARRAY
47098: IN
47099: NOT
47100: IFFALSE 47146
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47102: LD_ADDR_EXP 104
47106: PUSH
47107: LD_EXP 104
47111: PPUSH
47112: LD_VAR 0 2
47116: PUSH
47117: LD_EXP 104
47121: PUSH
47122: LD_VAR 0 2
47126: ARRAY
47127: PUSH
47128: LD_INT 1
47130: PLUS
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PPUSH
47136: LD_VAR 0 3
47140: PPUSH
47141: CALL 70869 0 3
47145: ST_TO_ADDR
// break ;
47146: GO 47150
// end ; end ; end ;
47148: GO 46984
47150: POP
47151: POP
// end ;
47152: GO 46744
47154: POP
47155: POP
// end ;
47156: LD_VAR 0 1
47160: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47161: LD_INT 0
47163: PPUSH
47164: PPUSH
47165: PPUSH
47166: PPUSH
47167: PPUSH
47168: PPUSH
47169: PPUSH
47170: PPUSH
47171: PPUSH
// if not mc_bases then
47172: LD_EXP 97
47176: NOT
47177: IFFALSE 47181
// exit ;
47179: GO 47586
// for i = 1 to mc_bases do
47181: LD_ADDR_VAR 0 2
47185: PUSH
47186: DOUBLE
47187: LD_INT 1
47189: DEC
47190: ST_TO_ADDR
47191: LD_EXP 97
47195: PUSH
47196: FOR_TO
47197: IFFALSE 47584
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47199: LD_EXP 105
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: NOT
47210: PUSH
47211: LD_EXP 97
47215: PUSH
47216: LD_VAR 0 2
47220: ARRAY
47221: PPUSH
47222: LD_INT 30
47224: PUSH
47225: LD_INT 3
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PPUSH
47232: CALL_OW 72
47236: NOT
47237: OR
47238: IFFALSE 47242
// continue ;
47240: GO 47196
// busy := false ;
47242: LD_ADDR_VAR 0 8
47246: PUSH
47247: LD_INT 0
47249: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47250: LD_ADDR_VAR 0 4
47254: PUSH
47255: LD_EXP 97
47259: PUSH
47260: LD_VAR 0 2
47264: ARRAY
47265: PPUSH
47266: LD_INT 30
47268: PUSH
47269: LD_INT 3
47271: PUSH
47272: EMPTY
47273: LIST
47274: LIST
47275: PPUSH
47276: CALL_OW 72
47280: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47281: LD_ADDR_VAR 0 6
47285: PUSH
47286: LD_EXP 105
47290: PUSH
47291: LD_VAR 0 2
47295: ARRAY
47296: PPUSH
47297: LD_INT 2
47299: PUSH
47300: LD_INT 30
47302: PUSH
47303: LD_INT 32
47305: PUSH
47306: EMPTY
47307: LIST
47308: LIST
47309: PUSH
47310: LD_INT 30
47312: PUSH
47313: LD_INT 33
47315: PUSH
47316: EMPTY
47317: LIST
47318: LIST
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: LIST
47324: PPUSH
47325: CALL_OW 72
47329: ST_TO_ADDR
// if not t then
47330: LD_VAR 0 6
47334: NOT
47335: IFFALSE 47339
// continue ;
47337: GO 47196
// for j in tmp do
47339: LD_ADDR_VAR 0 3
47343: PUSH
47344: LD_VAR 0 4
47348: PUSH
47349: FOR_IN
47350: IFFALSE 47380
// if not BuildingStatus ( j ) = bs_idle then
47352: LD_VAR 0 3
47356: PPUSH
47357: CALL_OW 461
47361: PUSH
47362: LD_INT 2
47364: EQUAL
47365: NOT
47366: IFFALSE 47378
// begin busy := true ;
47368: LD_ADDR_VAR 0 8
47372: PUSH
47373: LD_INT 1
47375: ST_TO_ADDR
// break ;
47376: GO 47380
// end ;
47378: GO 47349
47380: POP
47381: POP
// if busy then
47382: LD_VAR 0 8
47386: IFFALSE 47390
// continue ;
47388: GO 47196
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47390: LD_ADDR_VAR 0 7
47394: PUSH
47395: LD_VAR 0 6
47399: PPUSH
47400: LD_INT 35
47402: PUSH
47403: LD_INT 0
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PPUSH
47410: CALL_OW 72
47414: ST_TO_ADDR
// if tw then
47415: LD_VAR 0 7
47419: IFFALSE 47496
// begin tw := tw [ 1 ] ;
47421: LD_ADDR_VAR 0 7
47425: PUSH
47426: LD_VAR 0 7
47430: PUSH
47431: LD_INT 1
47433: ARRAY
47434: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47435: LD_ADDR_VAR 0 9
47439: PUSH
47440: LD_VAR 0 7
47444: PPUSH
47445: LD_EXP 122
47449: PUSH
47450: LD_VAR 0 2
47454: ARRAY
47455: PPUSH
47456: CALL 75877 0 2
47460: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47461: LD_EXP 136
47465: PUSH
47466: LD_VAR 0 2
47470: ARRAY
47471: IFFALSE 47494
// if not weapon in mc_allowed_tower_weapons [ i ] then
47473: LD_VAR 0 9
47477: PUSH
47478: LD_EXP 136
47482: PUSH
47483: LD_VAR 0 2
47487: ARRAY
47488: IN
47489: NOT
47490: IFFALSE 47494
// continue ;
47492: GO 47196
// end else
47494: GO 47559
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47496: LD_ADDR_VAR 0 5
47500: PUSH
47501: LD_EXP 105
47505: PUSH
47506: LD_VAR 0 2
47510: ARRAY
47511: PPUSH
47512: LD_VAR 0 4
47516: PPUSH
47517: CALL 102656 0 2
47521: ST_TO_ADDR
// if not tmp2 then
47522: LD_VAR 0 5
47526: NOT
47527: IFFALSE 47531
// continue ;
47529: GO 47196
// tw := tmp2 [ 1 ] ;
47531: LD_ADDR_VAR 0 7
47535: PUSH
47536: LD_VAR 0 5
47540: PUSH
47541: LD_INT 1
47543: ARRAY
47544: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47545: LD_ADDR_VAR 0 9
47549: PUSH
47550: LD_VAR 0 5
47554: PUSH
47555: LD_INT 2
47557: ARRAY
47558: ST_TO_ADDR
// end ; if not weapon then
47559: LD_VAR 0 9
47563: NOT
47564: IFFALSE 47568
// continue ;
47566: GO 47196
// ComPlaceWeapon ( tw , weapon ) ;
47568: LD_VAR 0 7
47572: PPUSH
47573: LD_VAR 0 9
47577: PPUSH
47578: CALL_OW 148
// end ;
47582: GO 47196
47584: POP
47585: POP
// end ;
47586: LD_VAR 0 1
47590: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47591: LD_INT 0
47593: PPUSH
47594: PPUSH
47595: PPUSH
47596: PPUSH
47597: PPUSH
47598: PPUSH
47599: PPUSH
// if not mc_bases then
47600: LD_EXP 97
47604: NOT
47605: IFFALSE 47609
// exit ;
47607: GO 48377
// for i = 1 to mc_bases do
47609: LD_ADDR_VAR 0 2
47613: PUSH
47614: DOUBLE
47615: LD_INT 1
47617: DEC
47618: ST_TO_ADDR
47619: LD_EXP 97
47623: PUSH
47624: FOR_TO
47625: IFFALSE 48375
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47627: LD_EXP 110
47631: PUSH
47632: LD_VAR 0 2
47636: ARRAY
47637: NOT
47638: PUSH
47639: LD_EXP 110
47643: PUSH
47644: LD_VAR 0 2
47648: ARRAY
47649: PUSH
47650: LD_EXP 111
47654: PUSH
47655: LD_VAR 0 2
47659: ARRAY
47660: EQUAL
47661: OR
47662: PUSH
47663: LD_EXP 120
47667: PUSH
47668: LD_VAR 0 2
47672: ARRAY
47673: OR
47674: IFFALSE 47678
// continue ;
47676: GO 47624
// if mc_miners [ i ] then
47678: LD_EXP 111
47682: PUSH
47683: LD_VAR 0 2
47687: ARRAY
47688: IFFALSE 48062
// begin for j = mc_miners [ i ] downto 1 do
47690: LD_ADDR_VAR 0 3
47694: PUSH
47695: DOUBLE
47696: LD_EXP 111
47700: PUSH
47701: LD_VAR 0 2
47705: ARRAY
47706: INC
47707: ST_TO_ADDR
47708: LD_INT 1
47710: PUSH
47711: FOR_DOWNTO
47712: IFFALSE 48060
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47714: LD_EXP 111
47718: PUSH
47719: LD_VAR 0 2
47723: ARRAY
47724: PUSH
47725: LD_VAR 0 3
47729: ARRAY
47730: PPUSH
47731: CALL_OW 301
47735: PUSH
47736: LD_EXP 111
47740: PUSH
47741: LD_VAR 0 2
47745: ARRAY
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: PPUSH
47753: CALL_OW 257
47757: PUSH
47758: LD_INT 1
47760: NONEQUAL
47761: OR
47762: IFFALSE 47825
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47764: LD_ADDR_VAR 0 5
47768: PUSH
47769: LD_EXP 111
47773: PUSH
47774: LD_VAR 0 2
47778: ARRAY
47779: PUSH
47780: LD_EXP 111
47784: PUSH
47785: LD_VAR 0 2
47789: ARRAY
47790: PUSH
47791: LD_VAR 0 3
47795: ARRAY
47796: DIFF
47797: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47798: LD_ADDR_EXP 111
47802: PUSH
47803: LD_EXP 111
47807: PPUSH
47808: LD_VAR 0 2
47812: PPUSH
47813: LD_VAR 0 5
47817: PPUSH
47818: CALL_OW 1
47822: ST_TO_ADDR
// continue ;
47823: GO 47711
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47825: LD_EXP 111
47829: PUSH
47830: LD_VAR 0 2
47834: ARRAY
47835: PUSH
47836: LD_VAR 0 3
47840: ARRAY
47841: PPUSH
47842: CALL_OW 257
47846: PUSH
47847: LD_INT 1
47849: EQUAL
47850: PUSH
47851: LD_EXP 111
47855: PUSH
47856: LD_VAR 0 2
47860: ARRAY
47861: PUSH
47862: LD_VAR 0 3
47866: ARRAY
47867: PPUSH
47868: CALL_OW 459
47872: NOT
47873: AND
47874: PUSH
47875: LD_EXP 111
47879: PUSH
47880: LD_VAR 0 2
47884: ARRAY
47885: PUSH
47886: LD_VAR 0 3
47890: ARRAY
47891: PPUSH
47892: CALL_OW 314
47896: NOT
47897: AND
47898: IFFALSE 48058
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47900: LD_EXP 111
47904: PUSH
47905: LD_VAR 0 2
47909: ARRAY
47910: PUSH
47911: LD_VAR 0 3
47915: ARRAY
47916: PPUSH
47917: CALL_OW 310
47921: IFFALSE 47944
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47923: LD_EXP 111
47927: PUSH
47928: LD_VAR 0 2
47932: ARRAY
47933: PUSH
47934: LD_VAR 0 3
47938: ARRAY
47939: PPUSH
47940: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47944: LD_EXP 111
47948: PUSH
47949: LD_VAR 0 2
47953: ARRAY
47954: PUSH
47955: LD_VAR 0 3
47959: ARRAY
47960: PPUSH
47961: CALL_OW 314
47965: NOT
47966: IFFALSE 48058
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47968: LD_ADDR_VAR 0 7
47972: PUSH
47973: LD_INT 1
47975: PPUSH
47976: LD_EXP 110
47980: PUSH
47981: LD_VAR 0 2
47985: ARRAY
47986: PPUSH
47987: CALL_OW 12
47991: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
47992: LD_EXP 111
47996: PUSH
47997: LD_VAR 0 2
48001: ARRAY
48002: PUSH
48003: LD_VAR 0 3
48007: ARRAY
48008: PPUSH
48009: LD_EXP 110
48013: PUSH
48014: LD_VAR 0 2
48018: ARRAY
48019: PUSH
48020: LD_VAR 0 7
48024: ARRAY
48025: PUSH
48026: LD_INT 1
48028: ARRAY
48029: PPUSH
48030: LD_EXP 110
48034: PUSH
48035: LD_VAR 0 2
48039: ARRAY
48040: PUSH
48041: LD_VAR 0 7
48045: ARRAY
48046: PUSH
48047: LD_INT 2
48049: ARRAY
48050: PPUSH
48051: LD_INT 0
48053: PPUSH
48054: CALL_OW 193
// end ; end ; end ;
48058: GO 47711
48060: POP
48061: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48062: LD_ADDR_VAR 0 5
48066: PUSH
48067: LD_EXP 97
48071: PUSH
48072: LD_VAR 0 2
48076: ARRAY
48077: PPUSH
48078: LD_INT 2
48080: PUSH
48081: LD_INT 30
48083: PUSH
48084: LD_INT 4
48086: PUSH
48087: EMPTY
48088: LIST
48089: LIST
48090: PUSH
48091: LD_INT 30
48093: PUSH
48094: LD_INT 5
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: PUSH
48101: LD_INT 30
48103: PUSH
48104: LD_INT 32
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PUSH
48111: EMPTY
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: PPUSH
48117: CALL_OW 72
48121: ST_TO_ADDR
// if not tmp then
48122: LD_VAR 0 5
48126: NOT
48127: IFFALSE 48131
// continue ;
48129: GO 47624
// list := [ ] ;
48131: LD_ADDR_VAR 0 6
48135: PUSH
48136: EMPTY
48137: ST_TO_ADDR
// for j in tmp do
48138: LD_ADDR_VAR 0 3
48142: PUSH
48143: LD_VAR 0 5
48147: PUSH
48148: FOR_IN
48149: IFFALSE 48218
// begin for k in UnitsInside ( j ) do
48151: LD_ADDR_VAR 0 4
48155: PUSH
48156: LD_VAR 0 3
48160: PPUSH
48161: CALL_OW 313
48165: PUSH
48166: FOR_IN
48167: IFFALSE 48214
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48169: LD_VAR 0 4
48173: PPUSH
48174: CALL_OW 257
48178: PUSH
48179: LD_INT 1
48181: EQUAL
48182: PUSH
48183: LD_VAR 0 4
48187: PPUSH
48188: CALL_OW 459
48192: NOT
48193: AND
48194: IFFALSE 48212
// list := list ^ k ;
48196: LD_ADDR_VAR 0 6
48200: PUSH
48201: LD_VAR 0 6
48205: PUSH
48206: LD_VAR 0 4
48210: ADD
48211: ST_TO_ADDR
48212: GO 48166
48214: POP
48215: POP
// end ;
48216: GO 48148
48218: POP
48219: POP
// list := list diff mc_miners [ i ] ;
48220: LD_ADDR_VAR 0 6
48224: PUSH
48225: LD_VAR 0 6
48229: PUSH
48230: LD_EXP 111
48234: PUSH
48235: LD_VAR 0 2
48239: ARRAY
48240: DIFF
48241: ST_TO_ADDR
// if not list then
48242: LD_VAR 0 6
48246: NOT
48247: IFFALSE 48251
// continue ;
48249: GO 47624
// k := mc_mines [ i ] - mc_miners [ i ] ;
48251: LD_ADDR_VAR 0 4
48255: PUSH
48256: LD_EXP 110
48260: PUSH
48261: LD_VAR 0 2
48265: ARRAY
48266: PUSH
48267: LD_EXP 111
48271: PUSH
48272: LD_VAR 0 2
48276: ARRAY
48277: MINUS
48278: ST_TO_ADDR
// if k > list then
48279: LD_VAR 0 4
48283: PUSH
48284: LD_VAR 0 6
48288: GREATER
48289: IFFALSE 48301
// k := list ;
48291: LD_ADDR_VAR 0 4
48295: PUSH
48296: LD_VAR 0 6
48300: ST_TO_ADDR
// for j = 1 to k do
48301: LD_ADDR_VAR 0 3
48305: PUSH
48306: DOUBLE
48307: LD_INT 1
48309: DEC
48310: ST_TO_ADDR
48311: LD_VAR 0 4
48315: PUSH
48316: FOR_TO
48317: IFFALSE 48371
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48319: LD_ADDR_EXP 111
48323: PUSH
48324: LD_EXP 111
48328: PPUSH
48329: LD_VAR 0 2
48333: PUSH
48334: LD_EXP 111
48338: PUSH
48339: LD_VAR 0 2
48343: ARRAY
48344: PUSH
48345: LD_INT 1
48347: PLUS
48348: PUSH
48349: EMPTY
48350: LIST
48351: LIST
48352: PPUSH
48353: LD_VAR 0 6
48357: PUSH
48358: LD_VAR 0 3
48362: ARRAY
48363: PPUSH
48364: CALL 70869 0 3
48368: ST_TO_ADDR
48369: GO 48316
48371: POP
48372: POP
// end ;
48373: GO 47624
48375: POP
48376: POP
// end ;
48377: LD_VAR 0 1
48381: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48382: LD_INT 0
48384: PPUSH
48385: PPUSH
48386: PPUSH
48387: PPUSH
48388: PPUSH
48389: PPUSH
48390: PPUSH
48391: PPUSH
48392: PPUSH
48393: PPUSH
48394: PPUSH
// if not mc_bases then
48395: LD_EXP 97
48399: NOT
48400: IFFALSE 48404
// exit ;
48402: GO 50227
// for i = 1 to mc_bases do
48404: LD_ADDR_VAR 0 2
48408: PUSH
48409: DOUBLE
48410: LD_INT 1
48412: DEC
48413: ST_TO_ADDR
48414: LD_EXP 97
48418: PUSH
48419: FOR_TO
48420: IFFALSE 50225
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48422: LD_EXP 97
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: NOT
48433: PUSH
48434: LD_EXP 104
48438: PUSH
48439: LD_VAR 0 2
48443: ARRAY
48444: OR
48445: IFFALSE 48449
// continue ;
48447: GO 48419
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48449: LD_EXP 113
48453: PUSH
48454: LD_VAR 0 2
48458: ARRAY
48459: NOT
48460: PUSH
48461: LD_EXP 114
48465: PUSH
48466: LD_VAR 0 2
48470: ARRAY
48471: AND
48472: IFFALSE 48510
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48474: LD_ADDR_EXP 114
48478: PUSH
48479: LD_EXP 114
48483: PPUSH
48484: LD_VAR 0 2
48488: PPUSH
48489: EMPTY
48490: PPUSH
48491: CALL_OW 1
48495: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48496: LD_VAR 0 2
48500: PPUSH
48501: LD_INT 107
48503: PPUSH
48504: CALL 39282 0 2
// continue ;
48508: GO 48419
// end ; target := [ ] ;
48510: LD_ADDR_VAR 0 7
48514: PUSH
48515: EMPTY
48516: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48517: LD_ADDR_VAR 0 6
48521: PUSH
48522: LD_EXP 97
48526: PUSH
48527: LD_VAR 0 2
48531: ARRAY
48532: PUSH
48533: LD_INT 1
48535: ARRAY
48536: PPUSH
48537: CALL_OW 255
48541: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48542: LD_ADDR_VAR 0 9
48546: PUSH
48547: LD_EXP 97
48551: PUSH
48552: LD_VAR 0 2
48556: ARRAY
48557: PPUSH
48558: LD_INT 2
48560: PUSH
48561: LD_INT 30
48563: PUSH
48564: LD_INT 0
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: PUSH
48571: LD_INT 30
48573: PUSH
48574: LD_INT 1
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: LIST
48585: PPUSH
48586: CALL_OW 72
48590: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48591: LD_ADDR_VAR 0 3
48595: PUSH
48596: DOUBLE
48597: LD_EXP 113
48601: PUSH
48602: LD_VAR 0 2
48606: ARRAY
48607: INC
48608: ST_TO_ADDR
48609: LD_INT 1
48611: PUSH
48612: FOR_DOWNTO
48613: IFFALSE 48858
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48615: LD_EXP 113
48619: PUSH
48620: LD_VAR 0 2
48624: ARRAY
48625: PUSH
48626: LD_VAR 0 3
48630: ARRAY
48631: PUSH
48632: LD_INT 2
48634: ARRAY
48635: PPUSH
48636: LD_EXP 113
48640: PUSH
48641: LD_VAR 0 2
48645: ARRAY
48646: PUSH
48647: LD_VAR 0 3
48651: ARRAY
48652: PUSH
48653: LD_INT 3
48655: ARRAY
48656: PPUSH
48657: CALL_OW 488
48661: PUSH
48662: LD_EXP 113
48666: PUSH
48667: LD_VAR 0 2
48671: ARRAY
48672: PUSH
48673: LD_VAR 0 3
48677: ARRAY
48678: PUSH
48679: LD_INT 2
48681: ARRAY
48682: PPUSH
48683: LD_EXP 113
48687: PUSH
48688: LD_VAR 0 2
48692: ARRAY
48693: PUSH
48694: LD_VAR 0 3
48698: ARRAY
48699: PUSH
48700: LD_INT 3
48702: ARRAY
48703: PPUSH
48704: CALL_OW 284
48708: PUSH
48709: LD_INT 0
48711: EQUAL
48712: AND
48713: IFFALSE 48768
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48715: LD_ADDR_VAR 0 5
48719: PUSH
48720: LD_EXP 113
48724: PUSH
48725: LD_VAR 0 2
48729: ARRAY
48730: PPUSH
48731: LD_VAR 0 3
48735: PPUSH
48736: CALL_OW 3
48740: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48741: LD_ADDR_EXP 113
48745: PUSH
48746: LD_EXP 113
48750: PPUSH
48751: LD_VAR 0 2
48755: PPUSH
48756: LD_VAR 0 5
48760: PPUSH
48761: CALL_OW 1
48765: ST_TO_ADDR
// continue ;
48766: GO 48612
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48768: LD_VAR 0 6
48772: PPUSH
48773: LD_EXP 113
48777: PUSH
48778: LD_VAR 0 2
48782: ARRAY
48783: PUSH
48784: LD_VAR 0 3
48788: ARRAY
48789: PUSH
48790: LD_INT 2
48792: ARRAY
48793: PPUSH
48794: LD_EXP 113
48798: PUSH
48799: LD_VAR 0 2
48803: ARRAY
48804: PUSH
48805: LD_VAR 0 3
48809: ARRAY
48810: PUSH
48811: LD_INT 3
48813: ARRAY
48814: PPUSH
48815: LD_INT 30
48817: PPUSH
48818: CALL 71765 0 4
48822: PUSH
48823: LD_INT 4
48825: ARRAY
48826: PUSH
48827: LD_INT 0
48829: EQUAL
48830: IFFALSE 48856
// begin target := mc_crates [ i ] [ j ] ;
48832: LD_ADDR_VAR 0 7
48836: PUSH
48837: LD_EXP 113
48841: PUSH
48842: LD_VAR 0 2
48846: ARRAY
48847: PUSH
48848: LD_VAR 0 3
48852: ARRAY
48853: ST_TO_ADDR
// break ;
48854: GO 48858
// end ; end ;
48856: GO 48612
48858: POP
48859: POP
// if not target then
48860: LD_VAR 0 7
48864: NOT
48865: IFFALSE 48869
// continue ;
48867: GO 48419
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48869: LD_ADDR_VAR 0 8
48873: PUSH
48874: LD_EXP 116
48878: PUSH
48879: LD_VAR 0 2
48883: ARRAY
48884: PPUSH
48885: LD_INT 2
48887: PUSH
48888: LD_INT 3
48890: PUSH
48891: LD_INT 58
48893: PUSH
48894: EMPTY
48895: LIST
48896: PUSH
48897: EMPTY
48898: LIST
48899: LIST
48900: PUSH
48901: LD_INT 61
48903: PUSH
48904: EMPTY
48905: LIST
48906: PUSH
48907: LD_INT 33
48909: PUSH
48910: LD_INT 5
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: PUSH
48917: LD_INT 33
48919: PUSH
48920: LD_INT 3
48922: PUSH
48923: EMPTY
48924: LIST
48925: LIST
48926: PUSH
48927: EMPTY
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 2
48936: PUSH
48937: LD_INT 34
48939: PUSH
48940: LD_INT 32
48942: PUSH
48943: EMPTY
48944: LIST
48945: LIST
48946: PUSH
48947: LD_INT 34
48949: PUSH
48950: LD_INT 51
48952: PUSH
48953: EMPTY
48954: LIST
48955: LIST
48956: PUSH
48957: LD_INT 34
48959: PUSH
48960: LD_INT 12
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: PUSH
48967: EMPTY
48968: LIST
48969: LIST
48970: LIST
48971: LIST
48972: PUSH
48973: EMPTY
48974: LIST
48975: LIST
48976: PPUSH
48977: CALL_OW 72
48981: ST_TO_ADDR
// if not cargo then
48982: LD_VAR 0 8
48986: NOT
48987: IFFALSE 49693
// begin if mc_crates_collector [ i ] < 5 then
48989: LD_EXP 114
48993: PUSH
48994: LD_VAR 0 2
48998: ARRAY
48999: PUSH
49000: LD_INT 5
49002: LESS
49003: IFFALSE 49369
// begin if mc_ape [ i ] then
49005: LD_EXP 126
49009: PUSH
49010: LD_VAR 0 2
49014: ARRAY
49015: IFFALSE 49062
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49017: LD_ADDR_VAR 0 5
49021: PUSH
49022: LD_EXP 126
49026: PUSH
49027: LD_VAR 0 2
49031: ARRAY
49032: PPUSH
49033: LD_INT 25
49035: PUSH
49036: LD_INT 16
49038: PUSH
49039: EMPTY
49040: LIST
49041: LIST
49042: PUSH
49043: LD_INT 24
49045: PUSH
49046: LD_INT 750
49048: PUSH
49049: EMPTY
49050: LIST
49051: LIST
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: PPUSH
49057: CALL_OW 72
49061: ST_TO_ADDR
// if not tmp then
49062: LD_VAR 0 5
49066: NOT
49067: IFFALSE 49114
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49069: LD_ADDR_VAR 0 5
49073: PUSH
49074: LD_EXP 97
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PPUSH
49085: LD_INT 25
49087: PUSH
49088: LD_INT 2
49090: PUSH
49091: EMPTY
49092: LIST
49093: LIST
49094: PUSH
49095: LD_INT 24
49097: PUSH
49098: LD_INT 750
49100: PUSH
49101: EMPTY
49102: LIST
49103: LIST
49104: PUSH
49105: EMPTY
49106: LIST
49107: LIST
49108: PPUSH
49109: CALL_OW 72
49113: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49114: LD_EXP 126
49118: PUSH
49119: LD_VAR 0 2
49123: ARRAY
49124: PUSH
49125: LD_EXP 97
49129: PUSH
49130: LD_VAR 0 2
49134: ARRAY
49135: PPUSH
49136: LD_INT 25
49138: PUSH
49139: LD_INT 2
49141: PUSH
49142: EMPTY
49143: LIST
49144: LIST
49145: PUSH
49146: LD_INT 24
49148: PUSH
49149: LD_INT 750
49151: PUSH
49152: EMPTY
49153: LIST
49154: LIST
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: PPUSH
49160: CALL_OW 72
49164: AND
49165: PUSH
49166: LD_VAR 0 5
49170: PUSH
49171: LD_INT 5
49173: LESS
49174: AND
49175: IFFALSE 49257
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49177: LD_ADDR_VAR 0 3
49181: PUSH
49182: LD_EXP 97
49186: PUSH
49187: LD_VAR 0 2
49191: ARRAY
49192: PPUSH
49193: LD_INT 25
49195: PUSH
49196: LD_INT 2
49198: PUSH
49199: EMPTY
49200: LIST
49201: LIST
49202: PUSH
49203: LD_INT 24
49205: PUSH
49206: LD_INT 750
49208: PUSH
49209: EMPTY
49210: LIST
49211: LIST
49212: PUSH
49213: EMPTY
49214: LIST
49215: LIST
49216: PPUSH
49217: CALL_OW 72
49221: PUSH
49222: FOR_IN
49223: IFFALSE 49255
// begin tmp := tmp union j ;
49225: LD_ADDR_VAR 0 5
49229: PUSH
49230: LD_VAR 0 5
49234: PUSH
49235: LD_VAR 0 3
49239: UNION
49240: ST_TO_ADDR
// if tmp >= 5 then
49241: LD_VAR 0 5
49245: PUSH
49246: LD_INT 5
49248: GREATEREQUAL
49249: IFFALSE 49253
// break ;
49251: GO 49255
// end ;
49253: GO 49222
49255: POP
49256: POP
// end ; if not tmp then
49257: LD_VAR 0 5
49261: NOT
49262: IFFALSE 49266
// continue ;
49264: GO 48419
// for j in tmp do
49266: LD_ADDR_VAR 0 3
49270: PUSH
49271: LD_VAR 0 5
49275: PUSH
49276: FOR_IN
49277: IFFALSE 49367
// if not GetTag ( j ) then
49279: LD_VAR 0 3
49283: PPUSH
49284: CALL_OW 110
49288: NOT
49289: IFFALSE 49365
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49291: LD_ADDR_EXP 114
49295: PUSH
49296: LD_EXP 114
49300: PPUSH
49301: LD_VAR 0 2
49305: PUSH
49306: LD_EXP 114
49310: PUSH
49311: LD_VAR 0 2
49315: ARRAY
49316: PUSH
49317: LD_INT 1
49319: PLUS
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PPUSH
49325: LD_VAR 0 3
49329: PPUSH
49330: CALL 70869 0 3
49334: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49335: LD_VAR 0 3
49339: PPUSH
49340: LD_INT 107
49342: PPUSH
49343: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49347: LD_EXP 114
49351: PUSH
49352: LD_VAR 0 2
49356: ARRAY
49357: PUSH
49358: LD_INT 5
49360: GREATEREQUAL
49361: IFFALSE 49365
// break ;
49363: GO 49367
// end ;
49365: GO 49276
49367: POP
49368: POP
// end ; if mc_crates_collector [ i ] and target then
49369: LD_EXP 114
49373: PUSH
49374: LD_VAR 0 2
49378: ARRAY
49379: PUSH
49380: LD_VAR 0 7
49384: AND
49385: IFFALSE 49691
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49387: LD_EXP 114
49391: PUSH
49392: LD_VAR 0 2
49396: ARRAY
49397: PUSH
49398: LD_VAR 0 7
49402: PUSH
49403: LD_INT 1
49405: ARRAY
49406: LESS
49407: IFFALSE 49427
// tmp := mc_crates_collector [ i ] else
49409: LD_ADDR_VAR 0 5
49413: PUSH
49414: LD_EXP 114
49418: PUSH
49419: LD_VAR 0 2
49423: ARRAY
49424: ST_TO_ADDR
49425: GO 49441
// tmp := target [ 1 ] ;
49427: LD_ADDR_VAR 0 5
49431: PUSH
49432: LD_VAR 0 7
49436: PUSH
49437: LD_INT 1
49439: ARRAY
49440: ST_TO_ADDR
// k := 0 ;
49441: LD_ADDR_VAR 0 4
49445: PUSH
49446: LD_INT 0
49448: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49449: LD_ADDR_VAR 0 3
49453: PUSH
49454: LD_EXP 114
49458: PUSH
49459: LD_VAR 0 2
49463: ARRAY
49464: PUSH
49465: FOR_IN
49466: IFFALSE 49689
// begin k := k + 1 ;
49468: LD_ADDR_VAR 0 4
49472: PUSH
49473: LD_VAR 0 4
49477: PUSH
49478: LD_INT 1
49480: PLUS
49481: ST_TO_ADDR
// if k > tmp then
49482: LD_VAR 0 4
49486: PUSH
49487: LD_VAR 0 5
49491: GREATER
49492: IFFALSE 49496
// break ;
49494: GO 49689
// if not GetClass ( j ) in [ 2 , 16 ] then
49496: LD_VAR 0 3
49500: PPUSH
49501: CALL_OW 257
49505: PUSH
49506: LD_INT 2
49508: PUSH
49509: LD_INT 16
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: IN
49516: NOT
49517: IFFALSE 49570
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49519: LD_ADDR_EXP 114
49523: PUSH
49524: LD_EXP 114
49528: PPUSH
49529: LD_VAR 0 2
49533: PPUSH
49534: LD_EXP 114
49538: PUSH
49539: LD_VAR 0 2
49543: ARRAY
49544: PUSH
49545: LD_VAR 0 3
49549: DIFF
49550: PPUSH
49551: CALL_OW 1
49555: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49556: LD_VAR 0 3
49560: PPUSH
49561: LD_INT 0
49563: PPUSH
49564: CALL_OW 109
// continue ;
49568: GO 49465
// end ; if IsInUnit ( j ) then
49570: LD_VAR 0 3
49574: PPUSH
49575: CALL_OW 310
49579: IFFALSE 49590
// ComExitBuilding ( j ) ;
49581: LD_VAR 0 3
49585: PPUSH
49586: CALL_OW 122
// wait ( 3 ) ;
49590: LD_INT 3
49592: PPUSH
49593: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49597: LD_VAR 0 3
49601: PPUSH
49602: CALL_OW 314
49606: PUSH
49607: LD_VAR 0 6
49611: PPUSH
49612: LD_VAR 0 7
49616: PUSH
49617: LD_INT 2
49619: ARRAY
49620: PPUSH
49621: LD_VAR 0 7
49625: PUSH
49626: LD_INT 3
49628: ARRAY
49629: PPUSH
49630: LD_INT 30
49632: PPUSH
49633: CALL 71765 0 4
49637: PUSH
49638: LD_INT 4
49640: ARRAY
49641: AND
49642: IFFALSE 49660
// ComStandNearbyBuilding ( j , depot ) else
49644: LD_VAR 0 3
49648: PPUSH
49649: LD_VAR 0 9
49653: PPUSH
49654: CALL 67296 0 2
49658: GO 49687
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49660: LD_VAR 0 3
49664: PPUSH
49665: LD_VAR 0 7
49669: PUSH
49670: LD_INT 2
49672: ARRAY
49673: PPUSH
49674: LD_VAR 0 7
49678: PUSH
49679: LD_INT 3
49681: ARRAY
49682: PPUSH
49683: CALL_OW 117
// end ;
49687: GO 49465
49689: POP
49690: POP
// end ; end else
49691: GO 50223
// begin for j in cargo do
49693: LD_ADDR_VAR 0 3
49697: PUSH
49698: LD_VAR 0 8
49702: PUSH
49703: FOR_IN
49704: IFFALSE 50221
// begin if GetTag ( j ) <> 0 then
49706: LD_VAR 0 3
49710: PPUSH
49711: CALL_OW 110
49715: PUSH
49716: LD_INT 0
49718: NONEQUAL
49719: IFFALSE 49723
// continue ;
49721: GO 49703
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49723: LD_VAR 0 3
49727: PPUSH
49728: CALL_OW 256
49732: PUSH
49733: LD_INT 1000
49735: LESS
49736: PUSH
49737: LD_VAR 0 3
49741: PPUSH
49742: LD_EXP 121
49746: PUSH
49747: LD_VAR 0 2
49751: ARRAY
49752: PPUSH
49753: CALL_OW 308
49757: NOT
49758: AND
49759: IFFALSE 49781
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49761: LD_VAR 0 3
49765: PPUSH
49766: LD_EXP 121
49770: PUSH
49771: LD_VAR 0 2
49775: ARRAY
49776: PPUSH
49777: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49781: LD_VAR 0 3
49785: PPUSH
49786: CALL_OW 256
49790: PUSH
49791: LD_INT 1000
49793: LESS
49794: PUSH
49795: LD_VAR 0 3
49799: PPUSH
49800: LD_EXP 121
49804: PUSH
49805: LD_VAR 0 2
49809: ARRAY
49810: PPUSH
49811: CALL_OW 308
49815: AND
49816: IFFALSE 49820
// continue ;
49818: GO 49703
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49820: LD_VAR 0 3
49824: PPUSH
49825: CALL_OW 262
49829: PUSH
49830: LD_INT 2
49832: EQUAL
49833: PUSH
49834: LD_VAR 0 3
49838: PPUSH
49839: CALL_OW 261
49843: PUSH
49844: LD_INT 15
49846: LESS
49847: AND
49848: IFFALSE 49852
// continue ;
49850: GO 49703
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49852: LD_VAR 0 3
49856: PPUSH
49857: CALL_OW 262
49861: PUSH
49862: LD_INT 1
49864: EQUAL
49865: PUSH
49866: LD_VAR 0 3
49870: PPUSH
49871: CALL_OW 261
49875: PUSH
49876: LD_INT 10
49878: LESS
49879: AND
49880: IFFALSE 50160
// begin if not depot then
49882: LD_VAR 0 9
49886: NOT
49887: IFFALSE 49891
// continue ;
49889: GO 49703
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49891: LD_VAR 0 3
49895: PPUSH
49896: LD_VAR 0 9
49900: PPUSH
49901: LD_VAR 0 3
49905: PPUSH
49906: CALL_OW 74
49910: PPUSH
49911: CALL_OW 296
49915: PUSH
49916: LD_INT 6
49918: LESS
49919: IFFALSE 49935
// SetFuel ( j , 100 ) else
49921: LD_VAR 0 3
49925: PPUSH
49926: LD_INT 100
49928: PPUSH
49929: CALL_OW 240
49933: GO 50160
// if GetFuel ( j ) = 0 then
49935: LD_VAR 0 3
49939: PPUSH
49940: CALL_OW 261
49944: PUSH
49945: LD_INT 0
49947: EQUAL
49948: IFFALSE 50160
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49950: LD_ADDR_EXP 116
49954: PUSH
49955: LD_EXP 116
49959: PPUSH
49960: LD_VAR 0 2
49964: PPUSH
49965: LD_EXP 116
49969: PUSH
49970: LD_VAR 0 2
49974: ARRAY
49975: PUSH
49976: LD_VAR 0 3
49980: DIFF
49981: PPUSH
49982: CALL_OW 1
49986: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49987: LD_VAR 0 3
49991: PPUSH
49992: CALL_OW 263
49996: PUSH
49997: LD_INT 1
49999: EQUAL
50000: IFFALSE 50016
// ComExitVehicle ( IsInUnit ( j ) ) ;
50002: LD_VAR 0 3
50006: PPUSH
50007: CALL_OW 310
50011: PPUSH
50012: CALL_OW 121
// if GetControl ( j ) = control_remote then
50016: LD_VAR 0 3
50020: PPUSH
50021: CALL_OW 263
50025: PUSH
50026: LD_INT 2
50028: EQUAL
50029: IFFALSE 50040
// ComUnlink ( j ) ;
50031: LD_VAR 0 3
50035: PPUSH
50036: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50040: LD_ADDR_VAR 0 10
50044: PUSH
50045: LD_VAR 0 2
50049: PPUSH
50050: LD_INT 3
50052: PPUSH
50053: CALL 59799 0 2
50057: ST_TO_ADDR
// if fac then
50058: LD_VAR 0 10
50062: IFFALSE 50158
// begin for k in fac do
50064: LD_ADDR_VAR 0 4
50068: PUSH
50069: LD_VAR 0 10
50073: PUSH
50074: FOR_IN
50075: IFFALSE 50156
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50077: LD_ADDR_VAR 0 11
50081: PUSH
50082: LD_VAR 0 10
50086: PPUSH
50087: LD_VAR 0 3
50091: PPUSH
50092: CALL_OW 265
50096: PPUSH
50097: LD_VAR 0 3
50101: PPUSH
50102: CALL_OW 262
50106: PPUSH
50107: LD_VAR 0 3
50111: PPUSH
50112: CALL_OW 263
50116: PPUSH
50117: LD_VAR 0 3
50121: PPUSH
50122: CALL_OW 264
50126: PPUSH
50127: CALL 68367 0 5
50131: ST_TO_ADDR
// if components then
50132: LD_VAR 0 11
50136: IFFALSE 50154
// begin MC_InsertProduceList ( i , components ) ;
50138: LD_VAR 0 2
50142: PPUSH
50143: LD_VAR 0 11
50147: PPUSH
50148: CALL 59344 0 2
// break ;
50152: GO 50156
// end ; end ;
50154: GO 50074
50156: POP
50157: POP
// end ; continue ;
50158: GO 49703
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50160: LD_VAR 0 3
50164: PPUSH
50165: LD_INT 1
50167: PPUSH
50168: CALL_OW 289
50172: PUSH
50173: LD_INT 100
50175: LESS
50176: PUSH
50177: LD_VAR 0 3
50181: PPUSH
50182: CALL_OW 314
50186: NOT
50187: AND
50188: IFFALSE 50217
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50190: LD_VAR 0 3
50194: PPUSH
50195: LD_VAR 0 7
50199: PUSH
50200: LD_INT 2
50202: ARRAY
50203: PPUSH
50204: LD_VAR 0 7
50208: PUSH
50209: LD_INT 3
50211: ARRAY
50212: PPUSH
50213: CALL_OW 117
// break ;
50217: GO 50221
// end ;
50219: GO 49703
50221: POP
50222: POP
// end ; end ;
50223: GO 48419
50225: POP
50226: POP
// end ;
50227: LD_VAR 0 1
50231: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50232: LD_INT 0
50234: PPUSH
50235: PPUSH
50236: PPUSH
50237: PPUSH
// if not mc_bases then
50238: LD_EXP 97
50242: NOT
50243: IFFALSE 50247
// exit ;
50245: GO 50408
// for i = 1 to mc_bases do
50247: LD_ADDR_VAR 0 2
50251: PUSH
50252: DOUBLE
50253: LD_INT 1
50255: DEC
50256: ST_TO_ADDR
50257: LD_EXP 97
50261: PUSH
50262: FOR_TO
50263: IFFALSE 50406
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50265: LD_ADDR_VAR 0 4
50269: PUSH
50270: LD_EXP 116
50274: PUSH
50275: LD_VAR 0 2
50279: ARRAY
50280: PUSH
50281: LD_EXP 119
50285: PUSH
50286: LD_VAR 0 2
50290: ARRAY
50291: UNION
50292: PPUSH
50293: LD_INT 33
50295: PUSH
50296: LD_INT 2
50298: PUSH
50299: EMPTY
50300: LIST
50301: LIST
50302: PPUSH
50303: CALL_OW 72
50307: ST_TO_ADDR
// if tmp then
50308: LD_VAR 0 4
50312: IFFALSE 50404
// for j in tmp do
50314: LD_ADDR_VAR 0 3
50318: PUSH
50319: LD_VAR 0 4
50323: PUSH
50324: FOR_IN
50325: IFFALSE 50402
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50327: LD_VAR 0 3
50331: PPUSH
50332: CALL_OW 312
50336: NOT
50337: PUSH
50338: LD_VAR 0 3
50342: PPUSH
50343: CALL_OW 256
50347: PUSH
50348: LD_INT 250
50350: GREATEREQUAL
50351: AND
50352: IFFALSE 50365
// Connect ( j ) else
50354: LD_VAR 0 3
50358: PPUSH
50359: CALL 73838 0 1
50363: GO 50400
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50365: LD_VAR 0 3
50369: PPUSH
50370: CALL_OW 256
50374: PUSH
50375: LD_INT 250
50377: LESS
50378: PUSH
50379: LD_VAR 0 3
50383: PPUSH
50384: CALL_OW 312
50388: AND
50389: IFFALSE 50400
// ComUnlink ( j ) ;
50391: LD_VAR 0 3
50395: PPUSH
50396: CALL_OW 136
50400: GO 50324
50402: POP
50403: POP
// end ;
50404: GO 50262
50406: POP
50407: POP
// end ;
50408: LD_VAR 0 1
50412: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50413: LD_INT 0
50415: PPUSH
50416: PPUSH
50417: PPUSH
50418: PPUSH
50419: PPUSH
// if not mc_bases then
50420: LD_EXP 97
50424: NOT
50425: IFFALSE 50429
// exit ;
50427: GO 50874
// for i = 1 to mc_bases do
50429: LD_ADDR_VAR 0 2
50433: PUSH
50434: DOUBLE
50435: LD_INT 1
50437: DEC
50438: ST_TO_ADDR
50439: LD_EXP 97
50443: PUSH
50444: FOR_TO
50445: IFFALSE 50872
// begin if not mc_produce [ i ] then
50447: LD_EXP 118
50451: PUSH
50452: LD_VAR 0 2
50456: ARRAY
50457: NOT
50458: IFFALSE 50462
// continue ;
50460: GO 50444
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50462: LD_ADDR_VAR 0 5
50466: PUSH
50467: LD_EXP 97
50471: PUSH
50472: LD_VAR 0 2
50476: ARRAY
50477: PPUSH
50478: LD_INT 30
50480: PUSH
50481: LD_INT 3
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PPUSH
50488: CALL_OW 72
50492: ST_TO_ADDR
// if not fac then
50493: LD_VAR 0 5
50497: NOT
50498: IFFALSE 50502
// continue ;
50500: GO 50444
// for j in fac do
50502: LD_ADDR_VAR 0 3
50506: PUSH
50507: LD_VAR 0 5
50511: PUSH
50512: FOR_IN
50513: IFFALSE 50868
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50515: LD_VAR 0 3
50519: PPUSH
50520: CALL_OW 461
50524: PUSH
50525: LD_INT 2
50527: NONEQUAL
50528: PUSH
50529: LD_VAR 0 3
50533: PPUSH
50534: LD_INT 15
50536: PPUSH
50537: CALL 73466 0 2
50541: PUSH
50542: LD_INT 4
50544: ARRAY
50545: OR
50546: IFFALSE 50550
// continue ;
50548: GO 50512
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50550: LD_VAR 0 3
50554: PPUSH
50555: LD_EXP 118
50559: PUSH
50560: LD_VAR 0 2
50564: ARRAY
50565: PUSH
50566: LD_INT 1
50568: ARRAY
50569: PUSH
50570: LD_INT 1
50572: ARRAY
50573: PPUSH
50574: LD_EXP 118
50578: PUSH
50579: LD_VAR 0 2
50583: ARRAY
50584: PUSH
50585: LD_INT 1
50587: ARRAY
50588: PUSH
50589: LD_INT 2
50591: ARRAY
50592: PPUSH
50593: LD_EXP 118
50597: PUSH
50598: LD_VAR 0 2
50602: ARRAY
50603: PUSH
50604: LD_INT 1
50606: ARRAY
50607: PUSH
50608: LD_INT 3
50610: ARRAY
50611: PPUSH
50612: LD_EXP 118
50616: PUSH
50617: LD_VAR 0 2
50621: ARRAY
50622: PUSH
50623: LD_INT 1
50625: ARRAY
50626: PUSH
50627: LD_INT 4
50629: ARRAY
50630: PPUSH
50631: CALL_OW 448
50635: PUSH
50636: LD_VAR 0 3
50640: PPUSH
50641: LD_EXP 118
50645: PUSH
50646: LD_VAR 0 2
50650: ARRAY
50651: PUSH
50652: LD_INT 1
50654: ARRAY
50655: PUSH
50656: LD_INT 1
50658: ARRAY
50659: PUSH
50660: LD_EXP 118
50664: PUSH
50665: LD_VAR 0 2
50669: ARRAY
50670: PUSH
50671: LD_INT 1
50673: ARRAY
50674: PUSH
50675: LD_INT 2
50677: ARRAY
50678: PUSH
50679: LD_EXP 118
50683: PUSH
50684: LD_VAR 0 2
50688: ARRAY
50689: PUSH
50690: LD_INT 1
50692: ARRAY
50693: PUSH
50694: LD_INT 3
50696: ARRAY
50697: PUSH
50698: LD_EXP 118
50702: PUSH
50703: LD_VAR 0 2
50707: ARRAY
50708: PUSH
50709: LD_INT 1
50711: ARRAY
50712: PUSH
50713: LD_INT 4
50715: ARRAY
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: LIST
50721: LIST
50722: PPUSH
50723: CALL 77233 0 2
50727: AND
50728: IFFALSE 50866
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50730: LD_VAR 0 3
50734: PPUSH
50735: LD_EXP 118
50739: PUSH
50740: LD_VAR 0 2
50744: ARRAY
50745: PUSH
50746: LD_INT 1
50748: ARRAY
50749: PUSH
50750: LD_INT 1
50752: ARRAY
50753: PPUSH
50754: LD_EXP 118
50758: PUSH
50759: LD_VAR 0 2
50763: ARRAY
50764: PUSH
50765: LD_INT 1
50767: ARRAY
50768: PUSH
50769: LD_INT 2
50771: ARRAY
50772: PPUSH
50773: LD_EXP 118
50777: PUSH
50778: LD_VAR 0 2
50782: ARRAY
50783: PUSH
50784: LD_INT 1
50786: ARRAY
50787: PUSH
50788: LD_INT 3
50790: ARRAY
50791: PPUSH
50792: LD_EXP 118
50796: PUSH
50797: LD_VAR 0 2
50801: ARRAY
50802: PUSH
50803: LD_INT 1
50805: ARRAY
50806: PUSH
50807: LD_INT 4
50809: ARRAY
50810: PPUSH
50811: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50815: LD_ADDR_VAR 0 4
50819: PUSH
50820: LD_EXP 118
50824: PUSH
50825: LD_VAR 0 2
50829: ARRAY
50830: PPUSH
50831: LD_INT 1
50833: PPUSH
50834: CALL_OW 3
50838: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50839: LD_ADDR_EXP 118
50843: PUSH
50844: LD_EXP 118
50848: PPUSH
50849: LD_VAR 0 2
50853: PPUSH
50854: LD_VAR 0 4
50858: PPUSH
50859: CALL_OW 1
50863: ST_TO_ADDR
// break ;
50864: GO 50868
// end ; end ;
50866: GO 50512
50868: POP
50869: POP
// end ;
50870: GO 50444
50872: POP
50873: POP
// end ;
50874: LD_VAR 0 1
50878: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50879: LD_INT 0
50881: PPUSH
50882: PPUSH
50883: PPUSH
// if not mc_bases then
50884: LD_EXP 97
50888: NOT
50889: IFFALSE 50893
// exit ;
50891: GO 50982
// for i = 1 to mc_bases do
50893: LD_ADDR_VAR 0 2
50897: PUSH
50898: DOUBLE
50899: LD_INT 1
50901: DEC
50902: ST_TO_ADDR
50903: LD_EXP 97
50907: PUSH
50908: FOR_TO
50909: IFFALSE 50980
// begin if mc_attack [ i ] then
50911: LD_EXP 117
50915: PUSH
50916: LD_VAR 0 2
50920: ARRAY
50921: IFFALSE 50978
// begin tmp := mc_attack [ i ] [ 1 ] ;
50923: LD_ADDR_VAR 0 3
50927: PUSH
50928: LD_EXP 117
50932: PUSH
50933: LD_VAR 0 2
50937: ARRAY
50938: PUSH
50939: LD_INT 1
50941: ARRAY
50942: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50943: LD_ADDR_EXP 117
50947: PUSH
50948: LD_EXP 117
50952: PPUSH
50953: LD_VAR 0 2
50957: PPUSH
50958: EMPTY
50959: PPUSH
50960: CALL_OW 1
50964: ST_TO_ADDR
// Attack ( tmp ) ;
50965: LD_VAR 0 3
50969: PPUSH
50970: CALL 126855 0 1
// exit ;
50974: POP
50975: POP
50976: GO 50982
// end ; end ;
50978: GO 50908
50980: POP
50981: POP
// end ;
50982: LD_VAR 0 1
50986: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50987: LD_INT 0
50989: PPUSH
50990: PPUSH
50991: PPUSH
50992: PPUSH
50993: PPUSH
50994: PPUSH
50995: PPUSH
// if not mc_bases then
50996: LD_EXP 97
51000: NOT
51001: IFFALSE 51005
// exit ;
51003: GO 51862
// for i = 1 to mc_bases do
51005: LD_ADDR_VAR 0 2
51009: PUSH
51010: DOUBLE
51011: LD_INT 1
51013: DEC
51014: ST_TO_ADDR
51015: LD_EXP 97
51019: PUSH
51020: FOR_TO
51021: IFFALSE 51860
// begin if not mc_bases [ i ] then
51023: LD_EXP 97
51027: PUSH
51028: LD_VAR 0 2
51032: ARRAY
51033: NOT
51034: IFFALSE 51038
// continue ;
51036: GO 51020
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51038: LD_ADDR_VAR 0 7
51042: PUSH
51043: LD_EXP 97
51047: PUSH
51048: LD_VAR 0 2
51052: ARRAY
51053: PUSH
51054: LD_INT 1
51056: ARRAY
51057: PPUSH
51058: CALL 67518 0 1
51062: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51063: LD_ADDR_EXP 120
51067: PUSH
51068: LD_EXP 120
51072: PPUSH
51073: LD_VAR 0 2
51077: PPUSH
51078: LD_EXP 97
51082: PUSH
51083: LD_VAR 0 2
51087: ARRAY
51088: PUSH
51089: LD_INT 1
51091: ARRAY
51092: PPUSH
51093: CALL_OW 255
51097: PPUSH
51098: LD_EXP 122
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PPUSH
51109: CALL 67483 0 2
51113: PPUSH
51114: CALL_OW 1
51118: ST_TO_ADDR
// if not mc_scan [ i ] then
51119: LD_EXP 120
51123: PUSH
51124: LD_VAR 0 2
51128: ARRAY
51129: NOT
51130: IFFALSE 51308
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51132: LD_ADDR_EXP 140
51136: PUSH
51137: LD_EXP 140
51141: PPUSH
51142: LD_VAR 0 2
51146: PPUSH
51147: LD_INT 0
51149: PPUSH
51150: CALL_OW 1
51154: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51155: LD_ADDR_VAR 0 4
51159: PUSH
51160: LD_EXP 97
51164: PUSH
51165: LD_VAR 0 2
51169: ARRAY
51170: PPUSH
51171: LD_INT 2
51173: PUSH
51174: LD_INT 25
51176: PUSH
51177: LD_INT 5
51179: PUSH
51180: EMPTY
51181: LIST
51182: LIST
51183: PUSH
51184: LD_INT 25
51186: PUSH
51187: LD_INT 8
51189: PUSH
51190: EMPTY
51191: LIST
51192: LIST
51193: PUSH
51194: LD_INT 25
51196: PUSH
51197: LD_INT 9
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: LIST
51208: LIST
51209: PPUSH
51210: CALL_OW 72
51214: ST_TO_ADDR
// if not tmp then
51215: LD_VAR 0 4
51219: NOT
51220: IFFALSE 51224
// continue ;
51222: GO 51020
// for j in tmp do
51224: LD_ADDR_VAR 0 3
51228: PUSH
51229: LD_VAR 0 4
51233: PUSH
51234: FOR_IN
51235: IFFALSE 51306
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51237: LD_VAR 0 3
51241: PPUSH
51242: CALL_OW 310
51246: PPUSH
51247: CALL_OW 266
51251: PUSH
51252: LD_INT 5
51254: EQUAL
51255: PUSH
51256: LD_VAR 0 3
51260: PPUSH
51261: CALL_OW 257
51265: PUSH
51266: LD_INT 1
51268: EQUAL
51269: AND
51270: PUSH
51271: LD_VAR 0 3
51275: PPUSH
51276: CALL_OW 459
51280: NOT
51281: AND
51282: PUSH
51283: LD_VAR 0 7
51287: AND
51288: IFFALSE 51304
// ComChangeProfession ( j , class ) ;
51290: LD_VAR 0 3
51294: PPUSH
51295: LD_VAR 0 7
51299: PPUSH
51300: CALL_OW 123
51304: GO 51234
51306: POP
51307: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51308: LD_EXP 120
51312: PUSH
51313: LD_VAR 0 2
51317: ARRAY
51318: PUSH
51319: LD_EXP 140
51323: PUSH
51324: LD_VAR 0 2
51328: ARRAY
51329: NOT
51330: AND
51331: PUSH
51332: LD_EXP 119
51336: PUSH
51337: LD_VAR 0 2
51341: ARRAY
51342: NOT
51343: AND
51344: PUSH
51345: LD_EXP 97
51349: PUSH
51350: LD_VAR 0 2
51354: ARRAY
51355: PPUSH
51356: LD_INT 50
51358: PUSH
51359: EMPTY
51360: LIST
51361: PUSH
51362: LD_INT 2
51364: PUSH
51365: LD_INT 30
51367: PUSH
51368: LD_INT 32
51370: PUSH
51371: EMPTY
51372: LIST
51373: LIST
51374: PUSH
51375: LD_INT 30
51377: PUSH
51378: LD_INT 33
51380: PUSH
51381: EMPTY
51382: LIST
51383: LIST
51384: PUSH
51385: LD_INT 30
51387: PUSH
51388: LD_INT 4
51390: PUSH
51391: EMPTY
51392: LIST
51393: LIST
51394: PUSH
51395: LD_INT 30
51397: PUSH
51398: LD_INT 5
51400: PUSH
51401: EMPTY
51402: LIST
51403: LIST
51404: PUSH
51405: EMPTY
51406: LIST
51407: LIST
51408: LIST
51409: LIST
51410: LIST
51411: PUSH
51412: EMPTY
51413: LIST
51414: LIST
51415: PPUSH
51416: CALL_OW 72
51420: PUSH
51421: LD_INT 4
51423: LESS
51424: PUSH
51425: LD_EXP 97
51429: PUSH
51430: LD_VAR 0 2
51434: ARRAY
51435: PPUSH
51436: LD_INT 3
51438: PUSH
51439: LD_INT 24
51441: PUSH
51442: LD_INT 1000
51444: PUSH
51445: EMPTY
51446: LIST
51447: LIST
51448: PUSH
51449: EMPTY
51450: LIST
51451: LIST
51452: PUSH
51453: LD_INT 2
51455: PUSH
51456: LD_INT 30
51458: PUSH
51459: LD_INT 0
51461: PUSH
51462: EMPTY
51463: LIST
51464: LIST
51465: PUSH
51466: LD_INT 30
51468: PUSH
51469: LD_INT 1
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: PUSH
51476: EMPTY
51477: LIST
51478: LIST
51479: LIST
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: PPUSH
51485: CALL_OW 72
51489: OR
51490: AND
51491: IFFALSE 51742
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51493: LD_ADDR_EXP 140
51497: PUSH
51498: LD_EXP 140
51502: PPUSH
51503: LD_VAR 0 2
51507: PPUSH
51508: LD_INT 1
51510: PPUSH
51511: CALL_OW 1
51515: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51516: LD_ADDR_VAR 0 4
51520: PUSH
51521: LD_EXP 97
51525: PUSH
51526: LD_VAR 0 2
51530: ARRAY
51531: PPUSH
51532: LD_INT 2
51534: PUSH
51535: LD_INT 25
51537: PUSH
51538: LD_INT 1
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: PUSH
51545: LD_INT 25
51547: PUSH
51548: LD_INT 5
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: PUSH
51555: LD_INT 25
51557: PUSH
51558: LD_INT 8
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PUSH
51565: LD_INT 25
51567: PUSH
51568: LD_INT 9
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: EMPTY
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: PPUSH
51582: CALL_OW 72
51586: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51587: LD_ADDR_VAR 0 4
51591: PUSH
51592: LD_VAR 0 4
51596: PUSH
51597: LD_VAR 0 4
51601: PPUSH
51602: LD_INT 18
51604: PPUSH
51605: CALL 100682 0 2
51609: DIFF
51610: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51611: LD_VAR 0 4
51615: NOT
51616: PUSH
51617: LD_EXP 97
51621: PUSH
51622: LD_VAR 0 2
51626: ARRAY
51627: PPUSH
51628: LD_INT 2
51630: PUSH
51631: LD_INT 30
51633: PUSH
51634: LD_INT 4
51636: PUSH
51637: EMPTY
51638: LIST
51639: LIST
51640: PUSH
51641: LD_INT 30
51643: PUSH
51644: LD_INT 5
51646: PUSH
51647: EMPTY
51648: LIST
51649: LIST
51650: PUSH
51651: EMPTY
51652: LIST
51653: LIST
51654: LIST
51655: PPUSH
51656: CALL_OW 72
51660: NOT
51661: AND
51662: IFFALSE 51724
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51664: LD_ADDR_VAR 0 4
51668: PUSH
51669: LD_EXP 97
51673: PUSH
51674: LD_VAR 0 2
51678: ARRAY
51679: PPUSH
51680: LD_INT 2
51682: PUSH
51683: LD_INT 25
51685: PUSH
51686: LD_INT 2
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: PUSH
51693: LD_INT 25
51695: PUSH
51696: LD_INT 3
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: PUSH
51703: LD_INT 25
51705: PUSH
51706: LD_INT 4
51708: PUSH
51709: EMPTY
51710: LIST
51711: LIST
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: LIST
51717: LIST
51718: PPUSH
51719: CALL_OW 72
51723: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51724: LD_VAR 0 2
51728: PPUSH
51729: LD_VAR 0 4
51733: PPUSH
51734: CALL 131564 0 2
// exit ;
51738: POP
51739: POP
51740: GO 51862
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51742: LD_EXP 120
51746: PUSH
51747: LD_VAR 0 2
51751: ARRAY
51752: PUSH
51753: LD_EXP 140
51757: PUSH
51758: LD_VAR 0 2
51762: ARRAY
51763: NOT
51764: AND
51765: PUSH
51766: LD_EXP 119
51770: PUSH
51771: LD_VAR 0 2
51775: ARRAY
51776: AND
51777: IFFALSE 51858
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51779: LD_ADDR_EXP 140
51783: PUSH
51784: LD_EXP 140
51788: PPUSH
51789: LD_VAR 0 2
51793: PPUSH
51794: LD_INT 1
51796: PPUSH
51797: CALL_OW 1
51801: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51802: LD_ADDR_VAR 0 4
51806: PUSH
51807: LD_EXP 119
51811: PUSH
51812: LD_VAR 0 2
51816: ARRAY
51817: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51818: LD_ADDR_EXP 119
51822: PUSH
51823: LD_EXP 119
51827: PPUSH
51828: LD_VAR 0 2
51832: PPUSH
51833: EMPTY
51834: PPUSH
51835: CALL_OW 1
51839: ST_TO_ADDR
// Defend ( i , tmp ) ;
51840: LD_VAR 0 2
51844: PPUSH
51845: LD_VAR 0 4
51849: PPUSH
51850: CALL 132160 0 2
// exit ;
51854: POP
51855: POP
51856: GO 51862
// end ; end ;
51858: GO 51020
51860: POP
51861: POP
// end ;
51862: LD_VAR 0 1
51866: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51867: LD_INT 0
51869: PPUSH
51870: PPUSH
51871: PPUSH
51872: PPUSH
51873: PPUSH
51874: PPUSH
51875: PPUSH
51876: PPUSH
51877: PPUSH
51878: PPUSH
51879: PPUSH
// if not mc_bases then
51880: LD_EXP 97
51884: NOT
51885: IFFALSE 51889
// exit ;
51887: GO 52976
// for i = 1 to mc_bases do
51889: LD_ADDR_VAR 0 2
51893: PUSH
51894: DOUBLE
51895: LD_INT 1
51897: DEC
51898: ST_TO_ADDR
51899: LD_EXP 97
51903: PUSH
51904: FOR_TO
51905: IFFALSE 52974
// begin tmp := mc_lab [ i ] ;
51907: LD_ADDR_VAR 0 6
51911: PUSH
51912: LD_EXP 130
51916: PUSH
51917: LD_VAR 0 2
51921: ARRAY
51922: ST_TO_ADDR
// if not tmp then
51923: LD_VAR 0 6
51927: NOT
51928: IFFALSE 51932
// continue ;
51930: GO 51904
// idle_lab := 0 ;
51932: LD_ADDR_VAR 0 11
51936: PUSH
51937: LD_INT 0
51939: ST_TO_ADDR
// for j in tmp do
51940: LD_ADDR_VAR 0 3
51944: PUSH
51945: LD_VAR 0 6
51949: PUSH
51950: FOR_IN
51951: IFFALSE 52970
// begin researching := false ;
51953: LD_ADDR_VAR 0 10
51957: PUSH
51958: LD_INT 0
51960: ST_TO_ADDR
// side := GetSide ( j ) ;
51961: LD_ADDR_VAR 0 4
51965: PUSH
51966: LD_VAR 0 3
51970: PPUSH
51971: CALL_OW 255
51975: ST_TO_ADDR
// if not mc_tech [ side ] then
51976: LD_EXP 124
51980: PUSH
51981: LD_VAR 0 4
51985: ARRAY
51986: NOT
51987: IFFALSE 51991
// continue ;
51989: GO 51950
// if BuildingStatus ( j ) = bs_idle then
51991: LD_VAR 0 3
51995: PPUSH
51996: CALL_OW 461
52000: PUSH
52001: LD_INT 2
52003: EQUAL
52004: IFFALSE 52192
// begin if idle_lab and UnitsInside ( j ) < 6 then
52006: LD_VAR 0 11
52010: PUSH
52011: LD_VAR 0 3
52015: PPUSH
52016: CALL_OW 313
52020: PUSH
52021: LD_INT 6
52023: LESS
52024: AND
52025: IFFALSE 52096
// begin tmp2 := UnitsInside ( idle_lab ) ;
52027: LD_ADDR_VAR 0 9
52031: PUSH
52032: LD_VAR 0 11
52036: PPUSH
52037: CALL_OW 313
52041: ST_TO_ADDR
// if tmp2 then
52042: LD_VAR 0 9
52046: IFFALSE 52088
// for x in tmp2 do
52048: LD_ADDR_VAR 0 7
52052: PUSH
52053: LD_VAR 0 9
52057: PUSH
52058: FOR_IN
52059: IFFALSE 52086
// begin ComExitBuilding ( x ) ;
52061: LD_VAR 0 7
52065: PPUSH
52066: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52070: LD_VAR 0 7
52074: PPUSH
52075: LD_VAR 0 3
52079: PPUSH
52080: CALL_OW 180
// end ;
52084: GO 52058
52086: POP
52087: POP
// idle_lab := 0 ;
52088: LD_ADDR_VAR 0 11
52092: PUSH
52093: LD_INT 0
52095: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52096: LD_ADDR_VAR 0 5
52100: PUSH
52101: LD_EXP 124
52105: PUSH
52106: LD_VAR 0 4
52110: ARRAY
52111: PUSH
52112: FOR_IN
52113: IFFALSE 52173
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52115: LD_VAR 0 3
52119: PPUSH
52120: LD_VAR 0 5
52124: PPUSH
52125: CALL_OW 430
52129: PUSH
52130: LD_VAR 0 4
52134: PPUSH
52135: LD_VAR 0 5
52139: PPUSH
52140: CALL 66588 0 2
52144: AND
52145: IFFALSE 52171
// begin researching := true ;
52147: LD_ADDR_VAR 0 10
52151: PUSH
52152: LD_INT 1
52154: ST_TO_ADDR
// ComResearch ( j , t ) ;
52155: LD_VAR 0 3
52159: PPUSH
52160: LD_VAR 0 5
52164: PPUSH
52165: CALL_OW 124
// break ;
52169: GO 52173
// end ;
52171: GO 52112
52173: POP
52174: POP
// if not researching then
52175: LD_VAR 0 10
52179: NOT
52180: IFFALSE 52192
// idle_lab := j ;
52182: LD_ADDR_VAR 0 11
52186: PUSH
52187: LD_VAR 0 3
52191: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52192: LD_VAR 0 3
52196: PPUSH
52197: CALL_OW 461
52201: PUSH
52202: LD_INT 10
52204: EQUAL
52205: IFFALSE 52793
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52207: LD_EXP 126
52211: PUSH
52212: LD_VAR 0 2
52216: ARRAY
52217: NOT
52218: PUSH
52219: LD_EXP 127
52223: PUSH
52224: LD_VAR 0 2
52228: ARRAY
52229: NOT
52230: AND
52231: PUSH
52232: LD_EXP 124
52236: PUSH
52237: LD_VAR 0 4
52241: ARRAY
52242: PUSH
52243: LD_INT 1
52245: GREATER
52246: AND
52247: IFFALSE 52378
// begin ComCancel ( j ) ;
52249: LD_VAR 0 3
52253: PPUSH
52254: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52258: LD_ADDR_EXP 124
52262: PUSH
52263: LD_EXP 124
52267: PPUSH
52268: LD_VAR 0 4
52272: PPUSH
52273: LD_EXP 124
52277: PUSH
52278: LD_VAR 0 4
52282: ARRAY
52283: PPUSH
52284: LD_EXP 124
52288: PUSH
52289: LD_VAR 0 4
52293: ARRAY
52294: PUSH
52295: LD_INT 1
52297: MINUS
52298: PPUSH
52299: LD_EXP 124
52303: PUSH
52304: LD_VAR 0 4
52308: ARRAY
52309: PPUSH
52310: LD_INT 0
52312: PPUSH
52313: CALL 70287 0 4
52317: PPUSH
52318: CALL_OW 1
52322: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52323: LD_ADDR_EXP 124
52327: PUSH
52328: LD_EXP 124
52332: PPUSH
52333: LD_VAR 0 4
52337: PPUSH
52338: LD_EXP 124
52342: PUSH
52343: LD_VAR 0 4
52347: ARRAY
52348: PPUSH
52349: LD_EXP 124
52353: PUSH
52354: LD_VAR 0 4
52358: ARRAY
52359: PPUSH
52360: LD_INT 1
52362: PPUSH
52363: LD_INT 0
52365: PPUSH
52366: CALL 70287 0 4
52370: PPUSH
52371: CALL_OW 1
52375: ST_TO_ADDR
// continue ;
52376: GO 51950
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52378: LD_EXP 126
52382: PUSH
52383: LD_VAR 0 2
52387: ARRAY
52388: PUSH
52389: LD_EXP 127
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: NOT
52400: AND
52401: IFFALSE 52528
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52403: LD_ADDR_EXP 127
52407: PUSH
52408: LD_EXP 127
52412: PPUSH
52413: LD_VAR 0 2
52417: PUSH
52418: LD_EXP 127
52422: PUSH
52423: LD_VAR 0 2
52427: ARRAY
52428: PUSH
52429: LD_INT 1
52431: PLUS
52432: PUSH
52433: EMPTY
52434: LIST
52435: LIST
52436: PPUSH
52437: LD_EXP 126
52441: PUSH
52442: LD_VAR 0 2
52446: ARRAY
52447: PUSH
52448: LD_INT 1
52450: ARRAY
52451: PPUSH
52452: CALL 70869 0 3
52456: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52457: LD_EXP 126
52461: PUSH
52462: LD_VAR 0 2
52466: ARRAY
52467: PUSH
52468: LD_INT 1
52470: ARRAY
52471: PPUSH
52472: LD_INT 112
52474: PPUSH
52475: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52479: LD_ADDR_VAR 0 9
52483: PUSH
52484: LD_EXP 126
52488: PUSH
52489: LD_VAR 0 2
52493: ARRAY
52494: PPUSH
52495: LD_INT 1
52497: PPUSH
52498: CALL_OW 3
52502: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52503: LD_ADDR_EXP 126
52507: PUSH
52508: LD_EXP 126
52512: PPUSH
52513: LD_VAR 0 2
52517: PPUSH
52518: LD_VAR 0 9
52522: PPUSH
52523: CALL_OW 1
52527: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52528: LD_EXP 126
52532: PUSH
52533: LD_VAR 0 2
52537: ARRAY
52538: PUSH
52539: LD_EXP 127
52543: PUSH
52544: LD_VAR 0 2
52548: ARRAY
52549: AND
52550: PUSH
52551: LD_EXP 127
52555: PUSH
52556: LD_VAR 0 2
52560: ARRAY
52561: PUSH
52562: LD_INT 1
52564: ARRAY
52565: PPUSH
52566: CALL_OW 310
52570: NOT
52571: AND
52572: PUSH
52573: LD_VAR 0 3
52577: PPUSH
52578: CALL_OW 313
52582: PUSH
52583: LD_INT 6
52585: EQUAL
52586: AND
52587: IFFALSE 52643
// begin tmp2 := UnitsInside ( j ) ;
52589: LD_ADDR_VAR 0 9
52593: PUSH
52594: LD_VAR 0 3
52598: PPUSH
52599: CALL_OW 313
52603: ST_TO_ADDR
// if tmp2 = 6 then
52604: LD_VAR 0 9
52608: PUSH
52609: LD_INT 6
52611: EQUAL
52612: IFFALSE 52643
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52614: LD_VAR 0 9
52618: PUSH
52619: LD_INT 1
52621: ARRAY
52622: PPUSH
52623: LD_INT 112
52625: PPUSH
52626: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52630: LD_VAR 0 9
52634: PUSH
52635: LD_INT 1
52637: ARRAY
52638: PPUSH
52639: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52643: LD_EXP 127
52647: PUSH
52648: LD_VAR 0 2
52652: ARRAY
52653: PUSH
52654: LD_EXP 127
52658: PUSH
52659: LD_VAR 0 2
52663: ARRAY
52664: PUSH
52665: LD_INT 1
52667: ARRAY
52668: PPUSH
52669: CALL_OW 314
52673: NOT
52674: AND
52675: PUSH
52676: LD_EXP 127
52680: PUSH
52681: LD_VAR 0 2
52685: ARRAY
52686: PUSH
52687: LD_INT 1
52689: ARRAY
52690: PPUSH
52691: CALL_OW 310
52695: NOT
52696: AND
52697: IFFALSE 52723
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52699: LD_EXP 127
52703: PUSH
52704: LD_VAR 0 2
52708: ARRAY
52709: PUSH
52710: LD_INT 1
52712: ARRAY
52713: PPUSH
52714: LD_VAR 0 3
52718: PPUSH
52719: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52723: LD_EXP 127
52727: PUSH
52728: LD_VAR 0 2
52732: ARRAY
52733: PUSH
52734: LD_INT 1
52736: ARRAY
52737: PPUSH
52738: CALL_OW 310
52742: PUSH
52743: LD_EXP 127
52747: PUSH
52748: LD_VAR 0 2
52752: ARRAY
52753: PUSH
52754: LD_INT 1
52756: ARRAY
52757: PPUSH
52758: CALL_OW 310
52762: PPUSH
52763: CALL_OW 461
52767: PUSH
52768: LD_INT 3
52770: NONEQUAL
52771: AND
52772: IFFALSE 52793
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52774: LD_EXP 127
52778: PUSH
52779: LD_VAR 0 2
52783: ARRAY
52784: PUSH
52785: LD_INT 1
52787: ARRAY
52788: PPUSH
52789: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52793: LD_VAR 0 3
52797: PPUSH
52798: CALL_OW 461
52802: PUSH
52803: LD_INT 6
52805: EQUAL
52806: PUSH
52807: LD_VAR 0 6
52811: PUSH
52812: LD_INT 1
52814: GREATER
52815: AND
52816: IFFALSE 52968
// begin sci := [ ] ;
52818: LD_ADDR_VAR 0 8
52822: PUSH
52823: EMPTY
52824: ST_TO_ADDR
// for x in ( tmp diff j ) do
52825: LD_ADDR_VAR 0 7
52829: PUSH
52830: LD_VAR 0 6
52834: PUSH
52835: LD_VAR 0 3
52839: DIFF
52840: PUSH
52841: FOR_IN
52842: IFFALSE 52894
// begin if sci = 6 then
52844: LD_VAR 0 8
52848: PUSH
52849: LD_INT 6
52851: EQUAL
52852: IFFALSE 52856
// break ;
52854: GO 52894
// if BuildingStatus ( x ) = bs_idle then
52856: LD_VAR 0 7
52860: PPUSH
52861: CALL_OW 461
52865: PUSH
52866: LD_INT 2
52868: EQUAL
52869: IFFALSE 52892
// sci := sci ^ UnitsInside ( x ) ;
52871: LD_ADDR_VAR 0 8
52875: PUSH
52876: LD_VAR 0 8
52880: PUSH
52881: LD_VAR 0 7
52885: PPUSH
52886: CALL_OW 313
52890: ADD
52891: ST_TO_ADDR
// end ;
52892: GO 52841
52894: POP
52895: POP
// if not sci then
52896: LD_VAR 0 8
52900: NOT
52901: IFFALSE 52905
// continue ;
52903: GO 51950
// for x in sci do
52905: LD_ADDR_VAR 0 7
52909: PUSH
52910: LD_VAR 0 8
52914: PUSH
52915: FOR_IN
52916: IFFALSE 52966
// if IsInUnit ( x ) and not HasTask ( x ) then
52918: LD_VAR 0 7
52922: PPUSH
52923: CALL_OW 310
52927: PUSH
52928: LD_VAR 0 7
52932: PPUSH
52933: CALL_OW 314
52937: NOT
52938: AND
52939: IFFALSE 52964
// begin ComExitBuilding ( x ) ;
52941: LD_VAR 0 7
52945: PPUSH
52946: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52950: LD_VAR 0 7
52954: PPUSH
52955: LD_VAR 0 3
52959: PPUSH
52960: CALL_OW 180
// end ;
52964: GO 52915
52966: POP
52967: POP
// end ; end ;
52968: GO 51950
52970: POP
52971: POP
// end ;
52972: GO 51904
52974: POP
52975: POP
// end ;
52976: LD_VAR 0 1
52980: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52981: LD_INT 0
52983: PPUSH
52984: PPUSH
// if not mc_bases then
52985: LD_EXP 97
52989: NOT
52990: IFFALSE 52994
// exit ;
52992: GO 53075
// for i = 1 to mc_bases do
52994: LD_ADDR_VAR 0 2
52998: PUSH
52999: DOUBLE
53000: LD_INT 1
53002: DEC
53003: ST_TO_ADDR
53004: LD_EXP 97
53008: PUSH
53009: FOR_TO
53010: IFFALSE 53073
// if mc_mines [ i ] and mc_miners [ i ] then
53012: LD_EXP 110
53016: PUSH
53017: LD_VAR 0 2
53021: ARRAY
53022: PUSH
53023: LD_EXP 111
53027: PUSH
53028: LD_VAR 0 2
53032: ARRAY
53033: AND
53034: IFFALSE 53071
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53036: LD_EXP 111
53040: PUSH
53041: LD_VAR 0 2
53045: ARRAY
53046: PUSH
53047: LD_INT 1
53049: ARRAY
53050: PPUSH
53051: CALL_OW 255
53055: PPUSH
53056: LD_EXP 110
53060: PUSH
53061: LD_VAR 0 2
53065: ARRAY
53066: PPUSH
53067: CALL 67671 0 2
53071: GO 53009
53073: POP
53074: POP
// end ;
53075: LD_VAR 0 1
53079: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53080: LD_INT 0
53082: PPUSH
53083: PPUSH
53084: PPUSH
53085: PPUSH
53086: PPUSH
53087: PPUSH
53088: PPUSH
53089: PPUSH
// if not mc_bases or not mc_parking then
53090: LD_EXP 97
53094: NOT
53095: PUSH
53096: LD_EXP 121
53100: NOT
53101: OR
53102: IFFALSE 53106
// exit ;
53104: GO 53816
// for i = 1 to mc_bases do
53106: LD_ADDR_VAR 0 2
53110: PUSH
53111: DOUBLE
53112: LD_INT 1
53114: DEC
53115: ST_TO_ADDR
53116: LD_EXP 97
53120: PUSH
53121: FOR_TO
53122: IFFALSE 53814
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53124: LD_EXP 97
53128: PUSH
53129: LD_VAR 0 2
53133: ARRAY
53134: NOT
53135: PUSH
53136: LD_EXP 121
53140: PUSH
53141: LD_VAR 0 2
53145: ARRAY
53146: NOT
53147: OR
53148: IFFALSE 53152
// continue ;
53150: GO 53121
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53152: LD_ADDR_VAR 0 5
53156: PUSH
53157: LD_EXP 97
53161: PUSH
53162: LD_VAR 0 2
53166: ARRAY
53167: PUSH
53168: LD_INT 1
53170: ARRAY
53171: PPUSH
53172: CALL_OW 255
53176: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53177: LD_ADDR_VAR 0 6
53181: PUSH
53182: LD_EXP 97
53186: PUSH
53187: LD_VAR 0 2
53191: ARRAY
53192: PPUSH
53193: LD_INT 30
53195: PUSH
53196: LD_INT 3
53198: PUSH
53199: EMPTY
53200: LIST
53201: LIST
53202: PPUSH
53203: CALL_OW 72
53207: ST_TO_ADDR
// if not fac then
53208: LD_VAR 0 6
53212: NOT
53213: IFFALSE 53264
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53215: LD_ADDR_VAR 0 6
53219: PUSH
53220: LD_EXP 97
53224: PUSH
53225: LD_VAR 0 2
53229: ARRAY
53230: PPUSH
53231: LD_INT 2
53233: PUSH
53234: LD_INT 30
53236: PUSH
53237: LD_INT 0
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: PUSH
53244: LD_INT 30
53246: PUSH
53247: LD_INT 1
53249: PUSH
53250: EMPTY
53251: LIST
53252: LIST
53253: PUSH
53254: EMPTY
53255: LIST
53256: LIST
53257: LIST
53258: PPUSH
53259: CALL_OW 72
53263: ST_TO_ADDR
// if not fac then
53264: LD_VAR 0 6
53268: NOT
53269: IFFALSE 53273
// continue ;
53271: GO 53121
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53273: LD_ADDR_VAR 0 7
53277: PUSH
53278: LD_EXP 121
53282: PUSH
53283: LD_VAR 0 2
53287: ARRAY
53288: PPUSH
53289: LD_INT 22
53291: PUSH
53292: LD_VAR 0 5
53296: PUSH
53297: EMPTY
53298: LIST
53299: LIST
53300: PUSH
53301: LD_INT 21
53303: PUSH
53304: LD_INT 2
53306: PUSH
53307: EMPTY
53308: LIST
53309: LIST
53310: PUSH
53311: LD_INT 3
53313: PUSH
53314: LD_INT 24
53316: PUSH
53317: LD_INT 1000
53319: PUSH
53320: EMPTY
53321: LIST
53322: LIST
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: LIST
53332: PPUSH
53333: CALL_OW 70
53337: ST_TO_ADDR
// for j in fac do
53338: LD_ADDR_VAR 0 3
53342: PUSH
53343: LD_VAR 0 6
53347: PUSH
53348: FOR_IN
53349: IFFALSE 53430
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53351: LD_ADDR_VAR 0 7
53355: PUSH
53356: LD_VAR 0 7
53360: PUSH
53361: LD_INT 22
53363: PUSH
53364: LD_VAR 0 5
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: PUSH
53373: LD_INT 91
53375: PUSH
53376: LD_VAR 0 3
53380: PUSH
53381: LD_INT 15
53383: PUSH
53384: EMPTY
53385: LIST
53386: LIST
53387: LIST
53388: PUSH
53389: LD_INT 21
53391: PUSH
53392: LD_INT 2
53394: PUSH
53395: EMPTY
53396: LIST
53397: LIST
53398: PUSH
53399: LD_INT 3
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: LD_INT 1000
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: PUSH
53416: EMPTY
53417: LIST
53418: LIST
53419: LIST
53420: LIST
53421: PPUSH
53422: CALL_OW 69
53426: UNION
53427: ST_TO_ADDR
53428: GO 53348
53430: POP
53431: POP
// if not vehs then
53432: LD_VAR 0 7
53436: NOT
53437: IFFALSE 53463
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53439: LD_ADDR_EXP 109
53443: PUSH
53444: LD_EXP 109
53448: PPUSH
53449: LD_VAR 0 2
53453: PPUSH
53454: EMPTY
53455: PPUSH
53456: CALL_OW 1
53460: ST_TO_ADDR
// continue ;
53461: GO 53121
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53463: LD_ADDR_VAR 0 8
53467: PUSH
53468: LD_EXP 97
53472: PUSH
53473: LD_VAR 0 2
53477: ARRAY
53478: PPUSH
53479: LD_INT 30
53481: PUSH
53482: LD_INT 3
53484: PUSH
53485: EMPTY
53486: LIST
53487: LIST
53488: PPUSH
53489: CALL_OW 72
53493: ST_TO_ADDR
// if tmp then
53494: LD_VAR 0 8
53498: IFFALSE 53601
// begin for j in tmp do
53500: LD_ADDR_VAR 0 3
53504: PUSH
53505: LD_VAR 0 8
53509: PUSH
53510: FOR_IN
53511: IFFALSE 53599
// for k in UnitsInside ( j ) do
53513: LD_ADDR_VAR 0 4
53517: PUSH
53518: LD_VAR 0 3
53522: PPUSH
53523: CALL_OW 313
53527: PUSH
53528: FOR_IN
53529: IFFALSE 53595
// if k then
53531: LD_VAR 0 4
53535: IFFALSE 53593
// if not k in mc_repair_vehicle [ i ] then
53537: LD_VAR 0 4
53541: PUSH
53542: LD_EXP 109
53546: PUSH
53547: LD_VAR 0 2
53551: ARRAY
53552: IN
53553: NOT
53554: IFFALSE 53593
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53556: LD_ADDR_EXP 109
53560: PUSH
53561: LD_EXP 109
53565: PPUSH
53566: LD_VAR 0 2
53570: PPUSH
53571: LD_EXP 109
53575: PUSH
53576: LD_VAR 0 2
53580: ARRAY
53581: PUSH
53582: LD_VAR 0 4
53586: UNION
53587: PPUSH
53588: CALL_OW 1
53592: ST_TO_ADDR
53593: GO 53528
53595: POP
53596: POP
53597: GO 53510
53599: POP
53600: POP
// end ; if not mc_repair_vehicle [ i ] then
53601: LD_EXP 109
53605: PUSH
53606: LD_VAR 0 2
53610: ARRAY
53611: NOT
53612: IFFALSE 53616
// continue ;
53614: GO 53121
// for j in mc_repair_vehicle [ i ] do
53616: LD_ADDR_VAR 0 3
53620: PUSH
53621: LD_EXP 109
53625: PUSH
53626: LD_VAR 0 2
53630: ARRAY
53631: PUSH
53632: FOR_IN
53633: IFFALSE 53810
// begin if GetClass ( j ) <> 3 then
53635: LD_VAR 0 3
53639: PPUSH
53640: CALL_OW 257
53644: PUSH
53645: LD_INT 3
53647: NONEQUAL
53648: IFFALSE 53689
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53650: LD_ADDR_EXP 109
53654: PUSH
53655: LD_EXP 109
53659: PPUSH
53660: LD_VAR 0 2
53664: PPUSH
53665: LD_EXP 109
53669: PUSH
53670: LD_VAR 0 2
53674: ARRAY
53675: PUSH
53676: LD_VAR 0 3
53680: DIFF
53681: PPUSH
53682: CALL_OW 1
53686: ST_TO_ADDR
// continue ;
53687: GO 53632
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53689: LD_VAR 0 3
53693: PPUSH
53694: CALL_OW 311
53698: NOT
53699: PUSH
53700: LD_VAR 0 3
53704: PUSH
53705: LD_EXP 100
53709: PUSH
53710: LD_VAR 0 2
53714: ARRAY
53715: PUSH
53716: LD_INT 1
53718: ARRAY
53719: IN
53720: NOT
53721: AND
53722: PUSH
53723: LD_VAR 0 3
53727: PUSH
53728: LD_EXP 100
53732: PUSH
53733: LD_VAR 0 2
53737: ARRAY
53738: PUSH
53739: LD_INT 2
53741: ARRAY
53742: IN
53743: NOT
53744: AND
53745: IFFALSE 53808
// begin if IsInUnit ( j ) then
53747: LD_VAR 0 3
53751: PPUSH
53752: CALL_OW 310
53756: IFFALSE 53769
// ComExitBuilding ( j ) else
53758: LD_VAR 0 3
53762: PPUSH
53763: CALL_OW 122
53767: GO 53808
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53769: LD_VAR 0 3
53773: PPUSH
53774: LD_VAR 0 7
53778: PUSH
53779: LD_INT 1
53781: ARRAY
53782: PPUSH
53783: CALL 105173 0 2
53787: NOT
53788: IFFALSE 53808
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53790: LD_VAR 0 3
53794: PPUSH
53795: LD_VAR 0 7
53799: PUSH
53800: LD_INT 1
53802: ARRAY
53803: PPUSH
53804: CALL_OW 129
// end ; end ;
53808: GO 53632
53810: POP
53811: POP
// end ;
53812: GO 53121
53814: POP
53815: POP
// end ;
53816: LD_VAR 0 1
53820: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53821: LD_INT 0
53823: PPUSH
53824: PPUSH
53825: PPUSH
53826: PPUSH
53827: PPUSH
53828: PPUSH
53829: PPUSH
53830: PPUSH
53831: PPUSH
53832: PPUSH
53833: PPUSH
// if not mc_bases then
53834: LD_EXP 97
53838: NOT
53839: IFFALSE 53843
// exit ;
53841: GO 54645
// for i = 1 to mc_bases do
53843: LD_ADDR_VAR 0 2
53847: PUSH
53848: DOUBLE
53849: LD_INT 1
53851: DEC
53852: ST_TO_ADDR
53853: LD_EXP 97
53857: PUSH
53858: FOR_TO
53859: IFFALSE 54643
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53861: LD_EXP 125
53865: PUSH
53866: LD_VAR 0 2
53870: ARRAY
53871: NOT
53872: PUSH
53873: LD_EXP 100
53877: PUSH
53878: LD_VAR 0 2
53882: ARRAY
53883: PUSH
53884: LD_INT 1
53886: ARRAY
53887: OR
53888: PUSH
53889: LD_EXP 100
53893: PUSH
53894: LD_VAR 0 2
53898: ARRAY
53899: PUSH
53900: LD_INT 2
53902: ARRAY
53903: OR
53904: PUSH
53905: LD_EXP 123
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: PPUSH
53916: LD_INT 1
53918: PPUSH
53919: CALL_OW 325
53923: NOT
53924: OR
53925: PUSH
53926: LD_EXP 120
53930: PUSH
53931: LD_VAR 0 2
53935: ARRAY
53936: OR
53937: IFFALSE 53941
// continue ;
53939: GO 53858
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53941: LD_ADDR_VAR 0 8
53945: PUSH
53946: LD_EXP 97
53950: PUSH
53951: LD_VAR 0 2
53955: ARRAY
53956: PPUSH
53957: LD_INT 25
53959: PUSH
53960: LD_INT 4
53962: PUSH
53963: EMPTY
53964: LIST
53965: LIST
53966: PUSH
53967: LD_INT 50
53969: PUSH
53970: EMPTY
53971: LIST
53972: PUSH
53973: LD_INT 3
53975: PUSH
53976: LD_INT 60
53978: PUSH
53979: EMPTY
53980: LIST
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: LIST
53990: PPUSH
53991: CALL_OW 72
53995: PUSH
53996: LD_EXP 101
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: DIFF
54007: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54008: LD_ADDR_VAR 0 9
54012: PUSH
54013: LD_EXP 97
54017: PUSH
54018: LD_VAR 0 2
54022: ARRAY
54023: PPUSH
54024: LD_INT 2
54026: PUSH
54027: LD_INT 30
54029: PUSH
54030: LD_INT 0
54032: PUSH
54033: EMPTY
54034: LIST
54035: LIST
54036: PUSH
54037: LD_INT 30
54039: PUSH
54040: LD_INT 1
54042: PUSH
54043: EMPTY
54044: LIST
54045: LIST
54046: PUSH
54047: EMPTY
54048: LIST
54049: LIST
54050: LIST
54051: PPUSH
54052: CALL_OW 72
54056: ST_TO_ADDR
// if not tmp or not dep then
54057: LD_VAR 0 8
54061: NOT
54062: PUSH
54063: LD_VAR 0 9
54067: NOT
54068: OR
54069: IFFALSE 54073
// continue ;
54071: GO 53858
// side := GetSide ( tmp [ 1 ] ) ;
54073: LD_ADDR_VAR 0 11
54077: PUSH
54078: LD_VAR 0 8
54082: PUSH
54083: LD_INT 1
54085: ARRAY
54086: PPUSH
54087: CALL_OW 255
54091: ST_TO_ADDR
// dep := dep [ 1 ] ;
54092: LD_ADDR_VAR 0 9
54096: PUSH
54097: LD_VAR 0 9
54101: PUSH
54102: LD_INT 1
54104: ARRAY
54105: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54106: LD_ADDR_VAR 0 7
54110: PUSH
54111: LD_EXP 125
54115: PUSH
54116: LD_VAR 0 2
54120: ARRAY
54121: PPUSH
54122: LD_INT 22
54124: PUSH
54125: LD_INT 0
54127: PUSH
54128: EMPTY
54129: LIST
54130: LIST
54131: PUSH
54132: LD_INT 25
54134: PUSH
54135: LD_INT 12
54137: PUSH
54138: EMPTY
54139: LIST
54140: LIST
54141: PUSH
54142: EMPTY
54143: LIST
54144: LIST
54145: PPUSH
54146: CALL_OW 70
54150: PUSH
54151: LD_INT 22
54153: PUSH
54154: LD_INT 0
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: PUSH
54161: LD_INT 25
54163: PUSH
54164: LD_INT 12
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: PUSH
54171: LD_INT 91
54173: PUSH
54174: LD_VAR 0 9
54178: PUSH
54179: LD_INT 20
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: LIST
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: LIST
54191: PPUSH
54192: CALL_OW 69
54196: UNION
54197: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54198: LD_ADDR_VAR 0 10
54202: PUSH
54203: LD_EXP 125
54207: PUSH
54208: LD_VAR 0 2
54212: ARRAY
54213: PPUSH
54214: LD_INT 81
54216: PUSH
54217: LD_VAR 0 11
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: PPUSH
54226: CALL_OW 70
54230: ST_TO_ADDR
// if not apes or danger_at_area then
54231: LD_VAR 0 7
54235: NOT
54236: PUSH
54237: LD_VAR 0 10
54241: OR
54242: IFFALSE 54292
// begin if mc_taming [ i ] then
54244: LD_EXP 128
54248: PUSH
54249: LD_VAR 0 2
54253: ARRAY
54254: IFFALSE 54290
// begin MC_Reset ( i , 121 ) ;
54256: LD_VAR 0 2
54260: PPUSH
54261: LD_INT 121
54263: PPUSH
54264: CALL 39282 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54268: LD_ADDR_EXP 128
54272: PUSH
54273: LD_EXP 128
54277: PPUSH
54278: LD_VAR 0 2
54282: PPUSH
54283: EMPTY
54284: PPUSH
54285: CALL_OW 1
54289: ST_TO_ADDR
// end ; continue ;
54290: GO 53858
// end ; for j in tmp do
54292: LD_ADDR_VAR 0 3
54296: PUSH
54297: LD_VAR 0 8
54301: PUSH
54302: FOR_IN
54303: IFFALSE 54639
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54305: LD_VAR 0 3
54309: PUSH
54310: LD_EXP 128
54314: PUSH
54315: LD_VAR 0 2
54319: ARRAY
54320: IN
54321: NOT
54322: PUSH
54323: LD_EXP 128
54327: PUSH
54328: LD_VAR 0 2
54332: ARRAY
54333: PUSH
54334: LD_INT 3
54336: LESS
54337: AND
54338: IFFALSE 54396
// begin SetTag ( j , 121 ) ;
54340: LD_VAR 0 3
54344: PPUSH
54345: LD_INT 121
54347: PPUSH
54348: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54352: LD_ADDR_EXP 128
54356: PUSH
54357: LD_EXP 128
54361: PPUSH
54362: LD_VAR 0 2
54366: PUSH
54367: LD_EXP 128
54371: PUSH
54372: LD_VAR 0 2
54376: ARRAY
54377: PUSH
54378: LD_INT 1
54380: PLUS
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: PPUSH
54386: LD_VAR 0 3
54390: PPUSH
54391: CALL 70869 0 3
54395: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54396: LD_VAR 0 3
54400: PUSH
54401: LD_EXP 128
54405: PUSH
54406: LD_VAR 0 2
54410: ARRAY
54411: IN
54412: IFFALSE 54637
// begin if GetClass ( j ) <> 4 then
54414: LD_VAR 0 3
54418: PPUSH
54419: CALL_OW 257
54423: PUSH
54424: LD_INT 4
54426: NONEQUAL
54427: IFFALSE 54480
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54429: LD_ADDR_EXP 128
54433: PUSH
54434: LD_EXP 128
54438: PPUSH
54439: LD_VAR 0 2
54443: PPUSH
54444: LD_EXP 128
54448: PUSH
54449: LD_VAR 0 2
54453: ARRAY
54454: PUSH
54455: LD_VAR 0 3
54459: DIFF
54460: PPUSH
54461: CALL_OW 1
54465: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54466: LD_VAR 0 3
54470: PPUSH
54471: LD_INT 0
54473: PPUSH
54474: CALL_OW 109
// continue ;
54478: GO 54302
// end ; if IsInUnit ( j ) then
54480: LD_VAR 0 3
54484: PPUSH
54485: CALL_OW 310
54489: IFFALSE 54500
// ComExitBuilding ( j ) ;
54491: LD_VAR 0 3
54495: PPUSH
54496: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54500: LD_ADDR_VAR 0 6
54504: PUSH
54505: LD_VAR 0 7
54509: PPUSH
54510: LD_VAR 0 3
54514: PPUSH
54515: CALL_OW 74
54519: ST_TO_ADDR
// if not ape then
54520: LD_VAR 0 6
54524: NOT
54525: IFFALSE 54529
// break ;
54527: GO 54639
// x := GetX ( ape ) ;
54529: LD_ADDR_VAR 0 4
54533: PUSH
54534: LD_VAR 0 6
54538: PPUSH
54539: CALL_OW 250
54543: ST_TO_ADDR
// y := GetY ( ape ) ;
54544: LD_ADDR_VAR 0 5
54548: PUSH
54549: LD_VAR 0 6
54553: PPUSH
54554: CALL_OW 251
54558: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54559: LD_VAR 0 4
54563: PPUSH
54564: LD_VAR 0 5
54568: PPUSH
54569: CALL_OW 488
54573: NOT
54574: PUSH
54575: LD_VAR 0 11
54579: PPUSH
54580: LD_VAR 0 4
54584: PPUSH
54585: LD_VAR 0 5
54589: PPUSH
54590: LD_INT 20
54592: PPUSH
54593: CALL 71765 0 4
54597: PUSH
54598: LD_INT 4
54600: ARRAY
54601: OR
54602: IFFALSE 54606
// break ;
54604: GO 54639
// if not HasTask ( j ) then
54606: LD_VAR 0 3
54610: PPUSH
54611: CALL_OW 314
54615: NOT
54616: IFFALSE 54637
// ComTameXY ( j , x , y ) ;
54618: LD_VAR 0 3
54622: PPUSH
54623: LD_VAR 0 4
54627: PPUSH
54628: LD_VAR 0 5
54632: PPUSH
54633: CALL_OW 131
// end ; end ;
54637: GO 54302
54639: POP
54640: POP
// end ;
54641: GO 53858
54643: POP
54644: POP
// end ;
54645: LD_VAR 0 1
54649: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54650: LD_INT 0
54652: PPUSH
54653: PPUSH
54654: PPUSH
54655: PPUSH
54656: PPUSH
54657: PPUSH
54658: PPUSH
54659: PPUSH
// if not mc_bases then
54660: LD_EXP 97
54664: NOT
54665: IFFALSE 54669
// exit ;
54667: GO 55295
// for i = 1 to mc_bases do
54669: LD_ADDR_VAR 0 2
54673: PUSH
54674: DOUBLE
54675: LD_INT 1
54677: DEC
54678: ST_TO_ADDR
54679: LD_EXP 97
54683: PUSH
54684: FOR_TO
54685: IFFALSE 55293
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54687: LD_EXP 126
54691: PUSH
54692: LD_VAR 0 2
54696: ARRAY
54697: NOT
54698: PUSH
54699: LD_EXP 126
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: PPUSH
54710: LD_INT 25
54712: PUSH
54713: LD_INT 12
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: PPUSH
54720: CALL_OW 72
54724: NOT
54725: OR
54726: IFFALSE 54730
// continue ;
54728: GO 54684
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54730: LD_ADDR_VAR 0 5
54734: PUSH
54735: LD_EXP 126
54739: PUSH
54740: LD_VAR 0 2
54744: ARRAY
54745: PUSH
54746: LD_INT 1
54748: ARRAY
54749: PPUSH
54750: CALL_OW 255
54754: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54755: LD_VAR 0 5
54759: PPUSH
54760: LD_INT 2
54762: PPUSH
54763: CALL_OW 325
54767: IFFALSE 55020
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54769: LD_ADDR_VAR 0 4
54773: PUSH
54774: LD_EXP 126
54778: PUSH
54779: LD_VAR 0 2
54783: ARRAY
54784: PPUSH
54785: LD_INT 25
54787: PUSH
54788: LD_INT 16
54790: PUSH
54791: EMPTY
54792: LIST
54793: LIST
54794: PPUSH
54795: CALL_OW 72
54799: ST_TO_ADDR
// if tmp < 6 then
54800: LD_VAR 0 4
54804: PUSH
54805: LD_INT 6
54807: LESS
54808: IFFALSE 55020
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54810: LD_ADDR_VAR 0 6
54814: PUSH
54815: LD_EXP 97
54819: PUSH
54820: LD_VAR 0 2
54824: ARRAY
54825: PPUSH
54826: LD_INT 2
54828: PUSH
54829: LD_INT 30
54831: PUSH
54832: LD_INT 0
54834: PUSH
54835: EMPTY
54836: LIST
54837: LIST
54838: PUSH
54839: LD_INT 30
54841: PUSH
54842: LD_INT 1
54844: PUSH
54845: EMPTY
54846: LIST
54847: LIST
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: LIST
54853: PPUSH
54854: CALL_OW 72
54858: ST_TO_ADDR
// if depot then
54859: LD_VAR 0 6
54863: IFFALSE 55020
// begin selected := 0 ;
54865: LD_ADDR_VAR 0 7
54869: PUSH
54870: LD_INT 0
54872: ST_TO_ADDR
// for j in depot do
54873: LD_ADDR_VAR 0 3
54877: PUSH
54878: LD_VAR 0 6
54882: PUSH
54883: FOR_IN
54884: IFFALSE 54915
// begin if UnitsInside ( j ) < 6 then
54886: LD_VAR 0 3
54890: PPUSH
54891: CALL_OW 313
54895: PUSH
54896: LD_INT 6
54898: LESS
54899: IFFALSE 54913
// begin selected := j ;
54901: LD_ADDR_VAR 0 7
54905: PUSH
54906: LD_VAR 0 3
54910: ST_TO_ADDR
// break ;
54911: GO 54915
// end ; end ;
54913: GO 54883
54915: POP
54916: POP
// if selected then
54917: LD_VAR 0 7
54921: IFFALSE 55020
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54923: LD_ADDR_VAR 0 3
54927: PUSH
54928: LD_EXP 126
54932: PUSH
54933: LD_VAR 0 2
54937: ARRAY
54938: PPUSH
54939: LD_INT 25
54941: PUSH
54942: LD_INT 12
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: PPUSH
54949: CALL_OW 72
54953: PUSH
54954: FOR_IN
54955: IFFALSE 55018
// if not HasTask ( j ) then
54957: LD_VAR 0 3
54961: PPUSH
54962: CALL_OW 314
54966: NOT
54967: IFFALSE 55016
// begin if not IsInUnit ( j ) then
54969: LD_VAR 0 3
54973: PPUSH
54974: CALL_OW 310
54978: NOT
54979: IFFALSE 54995
// ComEnterUnit ( j , selected ) ;
54981: LD_VAR 0 3
54985: PPUSH
54986: LD_VAR 0 7
54990: PPUSH
54991: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54995: LD_VAR 0 3
54999: PPUSH
55000: LD_INT 16
55002: PPUSH
55003: CALL_OW 183
// AddComExitBuilding ( j ) ;
55007: LD_VAR 0 3
55011: PPUSH
55012: CALL_OW 182
// end ;
55016: GO 54954
55018: POP
55019: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55020: LD_VAR 0 5
55024: PPUSH
55025: LD_INT 11
55027: PPUSH
55028: CALL_OW 325
55032: IFFALSE 55291
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55034: LD_ADDR_VAR 0 4
55038: PUSH
55039: LD_EXP 126
55043: PUSH
55044: LD_VAR 0 2
55048: ARRAY
55049: PPUSH
55050: LD_INT 25
55052: PUSH
55053: LD_INT 16
55055: PUSH
55056: EMPTY
55057: LIST
55058: LIST
55059: PPUSH
55060: CALL_OW 72
55064: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55065: LD_VAR 0 4
55069: PUSH
55070: LD_INT 6
55072: GREATEREQUAL
55073: PUSH
55074: LD_VAR 0 5
55078: PPUSH
55079: LD_INT 2
55081: PPUSH
55082: CALL_OW 325
55086: NOT
55087: OR
55088: IFFALSE 55291
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55090: LD_ADDR_VAR 0 8
55094: PUSH
55095: LD_EXP 97
55099: PUSH
55100: LD_VAR 0 2
55104: ARRAY
55105: PPUSH
55106: LD_INT 2
55108: PUSH
55109: LD_INT 30
55111: PUSH
55112: LD_INT 4
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: PUSH
55119: LD_INT 30
55121: PUSH
55122: LD_INT 5
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: LIST
55133: PPUSH
55134: CALL_OW 72
55138: ST_TO_ADDR
// if barracks then
55139: LD_VAR 0 8
55143: IFFALSE 55291
// begin selected := 0 ;
55145: LD_ADDR_VAR 0 7
55149: PUSH
55150: LD_INT 0
55152: ST_TO_ADDR
// for j in barracks do
55153: LD_ADDR_VAR 0 3
55157: PUSH
55158: LD_VAR 0 8
55162: PUSH
55163: FOR_IN
55164: IFFALSE 55195
// begin if UnitsInside ( j ) < 6 then
55166: LD_VAR 0 3
55170: PPUSH
55171: CALL_OW 313
55175: PUSH
55176: LD_INT 6
55178: LESS
55179: IFFALSE 55193
// begin selected := j ;
55181: LD_ADDR_VAR 0 7
55185: PUSH
55186: LD_VAR 0 3
55190: ST_TO_ADDR
// break ;
55191: GO 55195
// end ; end ;
55193: GO 55163
55195: POP
55196: POP
// if selected then
55197: LD_VAR 0 7
55201: IFFALSE 55291
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55203: LD_ADDR_VAR 0 3
55207: PUSH
55208: LD_EXP 126
55212: PUSH
55213: LD_VAR 0 2
55217: ARRAY
55218: PPUSH
55219: LD_INT 25
55221: PUSH
55222: LD_INT 12
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: PPUSH
55229: CALL_OW 72
55233: PUSH
55234: FOR_IN
55235: IFFALSE 55289
// if not IsInUnit ( j ) and not HasTask ( j ) then
55237: LD_VAR 0 3
55241: PPUSH
55242: CALL_OW 310
55246: NOT
55247: PUSH
55248: LD_VAR 0 3
55252: PPUSH
55253: CALL_OW 314
55257: NOT
55258: AND
55259: IFFALSE 55287
// begin ComEnterUnit ( j , selected ) ;
55261: LD_VAR 0 3
55265: PPUSH
55266: LD_VAR 0 7
55270: PPUSH
55271: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55275: LD_VAR 0 3
55279: PPUSH
55280: LD_INT 15
55282: PPUSH
55283: CALL_OW 183
// end ;
55287: GO 55234
55289: POP
55290: POP
// end ; end ; end ; end ; end ;
55291: GO 54684
55293: POP
55294: POP
// end ;
55295: LD_VAR 0 1
55299: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55300: LD_INT 0
55302: PPUSH
55303: PPUSH
55304: PPUSH
55305: PPUSH
// if not mc_bases then
55306: LD_EXP 97
55310: NOT
55311: IFFALSE 55315
// exit ;
55313: GO 55493
// for i = 1 to mc_bases do
55315: LD_ADDR_VAR 0 2
55319: PUSH
55320: DOUBLE
55321: LD_INT 1
55323: DEC
55324: ST_TO_ADDR
55325: LD_EXP 97
55329: PUSH
55330: FOR_TO
55331: IFFALSE 55491
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55333: LD_ADDR_VAR 0 4
55337: PUSH
55338: LD_EXP 97
55342: PUSH
55343: LD_VAR 0 2
55347: ARRAY
55348: PPUSH
55349: LD_INT 25
55351: PUSH
55352: LD_INT 9
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: PPUSH
55359: CALL_OW 72
55363: ST_TO_ADDR
// if not tmp then
55364: LD_VAR 0 4
55368: NOT
55369: IFFALSE 55373
// continue ;
55371: GO 55330
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55373: LD_EXP 123
55377: PUSH
55378: LD_VAR 0 2
55382: ARRAY
55383: PPUSH
55384: LD_INT 29
55386: PPUSH
55387: CALL_OW 325
55391: NOT
55392: PUSH
55393: LD_EXP 123
55397: PUSH
55398: LD_VAR 0 2
55402: ARRAY
55403: PPUSH
55404: LD_INT 28
55406: PPUSH
55407: CALL_OW 325
55411: NOT
55412: AND
55413: IFFALSE 55417
// continue ;
55415: GO 55330
// for j in tmp do
55417: LD_ADDR_VAR 0 3
55421: PUSH
55422: LD_VAR 0 4
55426: PUSH
55427: FOR_IN
55428: IFFALSE 55487
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55430: LD_VAR 0 3
55434: PUSH
55435: LD_EXP 100
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: PUSH
55446: LD_INT 1
55448: ARRAY
55449: IN
55450: NOT
55451: PUSH
55452: LD_VAR 0 3
55456: PUSH
55457: LD_EXP 100
55461: PUSH
55462: LD_VAR 0 2
55466: ARRAY
55467: PUSH
55468: LD_INT 2
55470: ARRAY
55471: IN
55472: NOT
55473: AND
55474: IFFALSE 55485
// ComSpaceTimeShoot ( j ) ;
55476: LD_VAR 0 3
55480: PPUSH
55481: CALL 66679 0 1
55485: GO 55427
55487: POP
55488: POP
// end ;
55489: GO 55330
55491: POP
55492: POP
// end ;
55493: LD_VAR 0 1
55497: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55498: LD_INT 0
55500: PPUSH
55501: PPUSH
55502: PPUSH
55503: PPUSH
55504: PPUSH
55505: PPUSH
55506: PPUSH
55507: PPUSH
55508: PPUSH
// if not mc_bases then
55509: LD_EXP 97
55513: NOT
55514: IFFALSE 55518
// exit ;
55516: GO 56140
// for i = 1 to mc_bases do
55518: LD_ADDR_VAR 0 2
55522: PUSH
55523: DOUBLE
55524: LD_INT 1
55526: DEC
55527: ST_TO_ADDR
55528: LD_EXP 97
55532: PUSH
55533: FOR_TO
55534: IFFALSE 56138
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55536: LD_EXP 132
55540: PUSH
55541: LD_VAR 0 2
55545: ARRAY
55546: NOT
55547: PUSH
55548: LD_INT 38
55550: PPUSH
55551: LD_EXP 123
55555: PUSH
55556: LD_VAR 0 2
55560: ARRAY
55561: PPUSH
55562: CALL_OW 321
55566: PUSH
55567: LD_INT 2
55569: NONEQUAL
55570: OR
55571: IFFALSE 55575
// continue ;
55573: GO 55533
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55575: LD_ADDR_VAR 0 8
55579: PUSH
55580: LD_EXP 97
55584: PUSH
55585: LD_VAR 0 2
55589: ARRAY
55590: PPUSH
55591: LD_INT 30
55593: PUSH
55594: LD_INT 34
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: PPUSH
55601: CALL_OW 72
55605: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55606: LD_ADDR_VAR 0 9
55610: PUSH
55611: LD_EXP 97
55615: PUSH
55616: LD_VAR 0 2
55620: ARRAY
55621: PPUSH
55622: LD_INT 25
55624: PUSH
55625: LD_INT 4
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: PPUSH
55632: CALL_OW 72
55636: PPUSH
55637: LD_INT 0
55639: PPUSH
55640: CALL 100682 0 2
55644: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55645: LD_VAR 0 9
55649: NOT
55650: PUSH
55651: LD_VAR 0 8
55655: NOT
55656: OR
55657: PUSH
55658: LD_EXP 97
55662: PUSH
55663: LD_VAR 0 2
55667: ARRAY
55668: PPUSH
55669: LD_INT 124
55671: PPUSH
55672: CALL 100682 0 2
55676: OR
55677: IFFALSE 55681
// continue ;
55679: GO 55533
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55681: LD_EXP 133
55685: PUSH
55686: LD_VAR 0 2
55690: ARRAY
55691: PUSH
55692: LD_EXP 132
55696: PUSH
55697: LD_VAR 0 2
55701: ARRAY
55702: LESS
55703: PUSH
55704: LD_EXP 133
55708: PUSH
55709: LD_VAR 0 2
55713: ARRAY
55714: PUSH
55715: LD_VAR 0 8
55719: LESS
55720: AND
55721: IFFALSE 56136
// begin tmp := sci [ 1 ] ;
55723: LD_ADDR_VAR 0 7
55727: PUSH
55728: LD_VAR 0 9
55732: PUSH
55733: LD_INT 1
55735: ARRAY
55736: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55737: LD_VAR 0 7
55741: PPUSH
55742: LD_INT 124
55744: PPUSH
55745: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55749: LD_ADDR_VAR 0 3
55753: PUSH
55754: DOUBLE
55755: LD_EXP 132
55759: PUSH
55760: LD_VAR 0 2
55764: ARRAY
55765: INC
55766: ST_TO_ADDR
55767: LD_EXP 132
55771: PUSH
55772: LD_VAR 0 2
55776: ARRAY
55777: PUSH
55778: FOR_DOWNTO
55779: IFFALSE 56122
// begin if IsInUnit ( tmp ) then
55781: LD_VAR 0 7
55785: PPUSH
55786: CALL_OW 310
55790: IFFALSE 55801
// ComExitBuilding ( tmp ) ;
55792: LD_VAR 0 7
55796: PPUSH
55797: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55801: LD_INT 35
55803: PPUSH
55804: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55808: LD_VAR 0 7
55812: PPUSH
55813: CALL_OW 310
55817: NOT
55818: PUSH
55819: LD_VAR 0 7
55823: PPUSH
55824: CALL_OW 314
55828: NOT
55829: AND
55830: IFFALSE 55801
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55832: LD_ADDR_VAR 0 6
55836: PUSH
55837: LD_VAR 0 7
55841: PPUSH
55842: CALL_OW 250
55846: PUSH
55847: LD_VAR 0 7
55851: PPUSH
55852: CALL_OW 251
55856: PUSH
55857: EMPTY
55858: LIST
55859: LIST
55860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55861: LD_INT 35
55863: PPUSH
55864: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55868: LD_ADDR_VAR 0 4
55872: PUSH
55873: LD_EXP 132
55877: PUSH
55878: LD_VAR 0 2
55882: ARRAY
55883: PUSH
55884: LD_VAR 0 3
55888: ARRAY
55889: PUSH
55890: LD_INT 1
55892: ARRAY
55893: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55894: LD_ADDR_VAR 0 5
55898: PUSH
55899: LD_EXP 132
55903: PUSH
55904: LD_VAR 0 2
55908: ARRAY
55909: PUSH
55910: LD_VAR 0 3
55914: ARRAY
55915: PUSH
55916: LD_INT 2
55918: ARRAY
55919: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55920: LD_VAR 0 7
55924: PPUSH
55925: LD_INT 10
55927: PPUSH
55928: CALL 73466 0 2
55932: PUSH
55933: LD_INT 4
55935: ARRAY
55936: IFFALSE 55974
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55938: LD_VAR 0 7
55942: PPUSH
55943: LD_VAR 0 6
55947: PUSH
55948: LD_INT 1
55950: ARRAY
55951: PPUSH
55952: LD_VAR 0 6
55956: PUSH
55957: LD_INT 2
55959: ARRAY
55960: PPUSH
55961: CALL_OW 111
// wait ( 0 0$10 ) ;
55965: LD_INT 350
55967: PPUSH
55968: CALL_OW 67
// end else
55972: GO 56000
// begin ComMoveXY ( tmp , x , y ) ;
55974: LD_VAR 0 7
55978: PPUSH
55979: LD_VAR 0 4
55983: PPUSH
55984: LD_VAR 0 5
55988: PPUSH
55989: CALL_OW 111
// wait ( 0 0$3 ) ;
55993: LD_INT 105
55995: PPUSH
55996: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56000: LD_VAR 0 7
56004: PPUSH
56005: LD_VAR 0 4
56009: PPUSH
56010: LD_VAR 0 5
56014: PPUSH
56015: CALL_OW 307
56019: IFFALSE 55861
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56021: LD_VAR 0 7
56025: PPUSH
56026: LD_VAR 0 4
56030: PPUSH
56031: LD_VAR 0 5
56035: PPUSH
56036: LD_VAR 0 8
56040: PUSH
56041: LD_VAR 0 3
56045: ARRAY
56046: PPUSH
56047: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56051: LD_INT 35
56053: PPUSH
56054: CALL_OW 67
// until not HasTask ( tmp ) ;
56058: LD_VAR 0 7
56062: PPUSH
56063: CALL_OW 314
56067: NOT
56068: IFFALSE 56051
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56070: LD_ADDR_EXP 133
56074: PUSH
56075: LD_EXP 133
56079: PPUSH
56080: LD_VAR 0 2
56084: PUSH
56085: LD_EXP 133
56089: PUSH
56090: LD_VAR 0 2
56094: ARRAY
56095: PUSH
56096: LD_INT 1
56098: PLUS
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: PPUSH
56104: LD_VAR 0 8
56108: PUSH
56109: LD_VAR 0 3
56113: ARRAY
56114: PPUSH
56115: CALL 70869 0 3
56119: ST_TO_ADDR
// end ;
56120: GO 55778
56122: POP
56123: POP
// MC_Reset ( i , 124 ) ;
56124: LD_VAR 0 2
56128: PPUSH
56129: LD_INT 124
56131: PPUSH
56132: CALL 39282 0 2
// end ; end ;
56136: GO 55533
56138: POP
56139: POP
// end ;
56140: LD_VAR 0 1
56144: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56145: LD_INT 0
56147: PPUSH
56148: PPUSH
56149: PPUSH
// if not mc_bases then
56150: LD_EXP 97
56154: NOT
56155: IFFALSE 56159
// exit ;
56157: GO 56765
// for i = 1 to mc_bases do
56159: LD_ADDR_VAR 0 2
56163: PUSH
56164: DOUBLE
56165: LD_INT 1
56167: DEC
56168: ST_TO_ADDR
56169: LD_EXP 97
56173: PUSH
56174: FOR_TO
56175: IFFALSE 56763
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56177: LD_ADDR_VAR 0 3
56181: PUSH
56182: LD_EXP 97
56186: PUSH
56187: LD_VAR 0 2
56191: ARRAY
56192: PPUSH
56193: LD_INT 25
56195: PUSH
56196: LD_INT 4
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: PPUSH
56203: CALL_OW 72
56207: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56208: LD_VAR 0 3
56212: NOT
56213: PUSH
56214: LD_EXP 134
56218: PUSH
56219: LD_VAR 0 2
56223: ARRAY
56224: NOT
56225: OR
56226: PUSH
56227: LD_EXP 97
56231: PUSH
56232: LD_VAR 0 2
56236: ARRAY
56237: PPUSH
56238: LD_INT 2
56240: PUSH
56241: LD_INT 30
56243: PUSH
56244: LD_INT 0
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: PUSH
56251: LD_INT 30
56253: PUSH
56254: LD_INT 1
56256: PUSH
56257: EMPTY
56258: LIST
56259: LIST
56260: PUSH
56261: EMPTY
56262: LIST
56263: LIST
56264: LIST
56265: PPUSH
56266: CALL_OW 72
56270: NOT
56271: OR
56272: IFFALSE 56322
// begin if mc_deposits_finder [ i ] then
56274: LD_EXP 135
56278: PUSH
56279: LD_VAR 0 2
56283: ARRAY
56284: IFFALSE 56320
// begin MC_Reset ( i , 125 ) ;
56286: LD_VAR 0 2
56290: PPUSH
56291: LD_INT 125
56293: PPUSH
56294: CALL 39282 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56298: LD_ADDR_EXP 135
56302: PUSH
56303: LD_EXP 135
56307: PPUSH
56308: LD_VAR 0 2
56312: PPUSH
56313: EMPTY
56314: PPUSH
56315: CALL_OW 1
56319: ST_TO_ADDR
// end ; continue ;
56320: GO 56174
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56322: LD_EXP 134
56326: PUSH
56327: LD_VAR 0 2
56331: ARRAY
56332: PUSH
56333: LD_INT 1
56335: ARRAY
56336: PUSH
56337: LD_INT 3
56339: ARRAY
56340: PUSH
56341: LD_INT 1
56343: EQUAL
56344: PUSH
56345: LD_INT 20
56347: PPUSH
56348: LD_EXP 123
56352: PUSH
56353: LD_VAR 0 2
56357: ARRAY
56358: PPUSH
56359: CALL_OW 321
56363: PUSH
56364: LD_INT 2
56366: NONEQUAL
56367: AND
56368: IFFALSE 56418
// begin if mc_deposits_finder [ i ] then
56370: LD_EXP 135
56374: PUSH
56375: LD_VAR 0 2
56379: ARRAY
56380: IFFALSE 56416
// begin MC_Reset ( i , 125 ) ;
56382: LD_VAR 0 2
56386: PPUSH
56387: LD_INT 125
56389: PPUSH
56390: CALL 39282 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56394: LD_ADDR_EXP 135
56398: PUSH
56399: LD_EXP 135
56403: PPUSH
56404: LD_VAR 0 2
56408: PPUSH
56409: EMPTY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
// end ; continue ;
56416: GO 56174
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56418: LD_EXP 134
56422: PUSH
56423: LD_VAR 0 2
56427: ARRAY
56428: PUSH
56429: LD_INT 1
56431: ARRAY
56432: PUSH
56433: LD_INT 1
56435: ARRAY
56436: PPUSH
56437: LD_EXP 134
56441: PUSH
56442: LD_VAR 0 2
56446: ARRAY
56447: PUSH
56448: LD_INT 1
56450: ARRAY
56451: PUSH
56452: LD_INT 2
56454: ARRAY
56455: PPUSH
56456: LD_EXP 123
56460: PUSH
56461: LD_VAR 0 2
56465: ARRAY
56466: PPUSH
56467: CALL_OW 440
56471: IFFALSE 56514
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56473: LD_ADDR_EXP 134
56477: PUSH
56478: LD_EXP 134
56482: PPUSH
56483: LD_VAR 0 2
56487: PPUSH
56488: LD_EXP 134
56492: PUSH
56493: LD_VAR 0 2
56497: ARRAY
56498: PPUSH
56499: LD_INT 1
56501: PPUSH
56502: CALL_OW 3
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
56512: GO 56761
// begin if not mc_deposits_finder [ i ] then
56514: LD_EXP 135
56518: PUSH
56519: LD_VAR 0 2
56523: ARRAY
56524: NOT
56525: IFFALSE 56577
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56527: LD_ADDR_EXP 135
56531: PUSH
56532: LD_EXP 135
56536: PPUSH
56537: LD_VAR 0 2
56541: PPUSH
56542: LD_VAR 0 3
56546: PUSH
56547: LD_INT 1
56549: ARRAY
56550: PUSH
56551: EMPTY
56552: LIST
56553: PPUSH
56554: CALL_OW 1
56558: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56559: LD_VAR 0 3
56563: PUSH
56564: LD_INT 1
56566: ARRAY
56567: PPUSH
56568: LD_INT 125
56570: PPUSH
56571: CALL_OW 109
// end else
56575: GO 56761
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56577: LD_EXP 135
56581: PUSH
56582: LD_VAR 0 2
56586: ARRAY
56587: PUSH
56588: LD_INT 1
56590: ARRAY
56591: PPUSH
56592: CALL_OW 310
56596: IFFALSE 56619
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56598: LD_EXP 135
56602: PUSH
56603: LD_VAR 0 2
56607: ARRAY
56608: PUSH
56609: LD_INT 1
56611: ARRAY
56612: PPUSH
56613: CALL_OW 122
56617: GO 56761
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56619: LD_EXP 135
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PUSH
56630: LD_INT 1
56632: ARRAY
56633: PPUSH
56634: CALL_OW 314
56638: NOT
56639: PUSH
56640: LD_EXP 135
56644: PUSH
56645: LD_VAR 0 2
56649: ARRAY
56650: PUSH
56651: LD_INT 1
56653: ARRAY
56654: PPUSH
56655: LD_EXP 134
56659: PUSH
56660: LD_VAR 0 2
56664: ARRAY
56665: PUSH
56666: LD_INT 1
56668: ARRAY
56669: PUSH
56670: LD_INT 1
56672: ARRAY
56673: PPUSH
56674: LD_EXP 134
56678: PUSH
56679: LD_VAR 0 2
56683: ARRAY
56684: PUSH
56685: LD_INT 1
56687: ARRAY
56688: PUSH
56689: LD_INT 2
56691: ARRAY
56692: PPUSH
56693: CALL_OW 297
56697: PUSH
56698: LD_INT 6
56700: GREATER
56701: AND
56702: IFFALSE 56761
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56704: LD_EXP 135
56708: PUSH
56709: LD_VAR 0 2
56713: ARRAY
56714: PUSH
56715: LD_INT 1
56717: ARRAY
56718: PPUSH
56719: LD_EXP 134
56723: PUSH
56724: LD_VAR 0 2
56728: ARRAY
56729: PUSH
56730: LD_INT 1
56732: ARRAY
56733: PUSH
56734: LD_INT 1
56736: ARRAY
56737: PPUSH
56738: LD_EXP 134
56742: PUSH
56743: LD_VAR 0 2
56747: ARRAY
56748: PUSH
56749: LD_INT 1
56751: ARRAY
56752: PUSH
56753: LD_INT 2
56755: ARRAY
56756: PPUSH
56757: CALL_OW 111
// end ; end ; end ;
56761: GO 56174
56763: POP
56764: POP
// end ;
56765: LD_VAR 0 1
56769: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56770: LD_INT 0
56772: PPUSH
56773: PPUSH
56774: PPUSH
56775: PPUSH
56776: PPUSH
56777: PPUSH
56778: PPUSH
56779: PPUSH
56780: PPUSH
56781: PPUSH
56782: PPUSH
// if not mc_bases then
56783: LD_EXP 97
56787: NOT
56788: IFFALSE 56792
// exit ;
56790: GO 57732
// for i = 1 to mc_bases do
56792: LD_ADDR_VAR 0 2
56796: PUSH
56797: DOUBLE
56798: LD_INT 1
56800: DEC
56801: ST_TO_ADDR
56802: LD_EXP 97
56806: PUSH
56807: FOR_TO
56808: IFFALSE 57730
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56810: LD_EXP 97
56814: PUSH
56815: LD_VAR 0 2
56819: ARRAY
56820: NOT
56821: PUSH
56822: LD_EXP 120
56826: PUSH
56827: LD_VAR 0 2
56831: ARRAY
56832: OR
56833: IFFALSE 56837
// continue ;
56835: GO 56807
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56837: LD_ADDR_VAR 0 7
56841: PUSH
56842: LD_EXP 97
56846: PUSH
56847: LD_VAR 0 2
56851: ARRAY
56852: PUSH
56853: LD_INT 1
56855: ARRAY
56856: PPUSH
56857: CALL_OW 248
56861: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56862: LD_VAR 0 7
56866: PUSH
56867: LD_INT 3
56869: EQUAL
56870: PUSH
56871: LD_EXP 116
56875: PUSH
56876: LD_VAR 0 2
56880: ARRAY
56881: PUSH
56882: LD_EXP 119
56886: PUSH
56887: LD_VAR 0 2
56891: ARRAY
56892: UNION
56893: PPUSH
56894: LD_INT 33
56896: PUSH
56897: LD_INT 2
56899: PUSH
56900: EMPTY
56901: LIST
56902: LIST
56903: PPUSH
56904: CALL_OW 72
56908: NOT
56909: OR
56910: IFFALSE 56914
// continue ;
56912: GO 56807
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56914: LD_ADDR_VAR 0 9
56918: PUSH
56919: LD_EXP 97
56923: PUSH
56924: LD_VAR 0 2
56928: ARRAY
56929: PPUSH
56930: LD_INT 30
56932: PUSH
56933: LD_INT 36
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: PPUSH
56940: CALL_OW 72
56944: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56945: LD_ADDR_VAR 0 10
56949: PUSH
56950: LD_EXP 116
56954: PUSH
56955: LD_VAR 0 2
56959: ARRAY
56960: PPUSH
56961: LD_INT 34
56963: PUSH
56964: LD_INT 31
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PPUSH
56971: CALL_OW 72
56975: ST_TO_ADDR
// if not cts and not mcts then
56976: LD_VAR 0 9
56980: NOT
56981: PUSH
56982: LD_VAR 0 10
56986: NOT
56987: AND
56988: IFFALSE 56992
// continue ;
56990: GO 56807
// x := cts ;
56992: LD_ADDR_VAR 0 11
56996: PUSH
56997: LD_VAR 0 9
57001: ST_TO_ADDR
// if not x then
57002: LD_VAR 0 11
57006: NOT
57007: IFFALSE 57019
// x := mcts ;
57009: LD_ADDR_VAR 0 11
57013: PUSH
57014: LD_VAR 0 10
57018: ST_TO_ADDR
// if not x then
57019: LD_VAR 0 11
57023: NOT
57024: IFFALSE 57028
// continue ;
57026: GO 56807
// if mc_remote_driver [ i ] then
57028: LD_EXP 137
57032: PUSH
57033: LD_VAR 0 2
57037: ARRAY
57038: IFFALSE 57425
// for j in mc_remote_driver [ i ] do
57040: LD_ADDR_VAR 0 3
57044: PUSH
57045: LD_EXP 137
57049: PUSH
57050: LD_VAR 0 2
57054: ARRAY
57055: PUSH
57056: FOR_IN
57057: IFFALSE 57423
// begin if GetClass ( j ) <> 3 then
57059: LD_VAR 0 3
57063: PPUSH
57064: CALL_OW 257
57068: PUSH
57069: LD_INT 3
57071: NONEQUAL
57072: IFFALSE 57125
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57074: LD_ADDR_EXP 137
57078: PUSH
57079: LD_EXP 137
57083: PPUSH
57084: LD_VAR 0 2
57088: PPUSH
57089: LD_EXP 137
57093: PUSH
57094: LD_VAR 0 2
57098: ARRAY
57099: PUSH
57100: LD_VAR 0 3
57104: DIFF
57105: PPUSH
57106: CALL_OW 1
57110: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57111: LD_VAR 0 3
57115: PPUSH
57116: LD_INT 0
57118: PPUSH
57119: CALL_OW 109
// continue ;
57123: GO 57056
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57125: LD_EXP 116
57129: PUSH
57130: LD_VAR 0 2
57134: ARRAY
57135: PPUSH
57136: LD_INT 34
57138: PUSH
57139: LD_INT 31
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: PUSH
57146: LD_INT 58
57148: PUSH
57149: EMPTY
57150: LIST
57151: PUSH
57152: EMPTY
57153: LIST
57154: LIST
57155: PPUSH
57156: CALL_OW 72
57160: PUSH
57161: LD_VAR 0 3
57165: PPUSH
57166: CALL 100717 0 1
57170: NOT
57171: AND
57172: IFFALSE 57243
// begin if IsInUnit ( j ) then
57174: LD_VAR 0 3
57178: PPUSH
57179: CALL_OW 310
57183: IFFALSE 57194
// ComExitBuilding ( j ) ;
57185: LD_VAR 0 3
57189: PPUSH
57190: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57194: LD_VAR 0 3
57198: PPUSH
57199: LD_EXP 116
57203: PUSH
57204: LD_VAR 0 2
57208: ARRAY
57209: PPUSH
57210: LD_INT 34
57212: PUSH
57213: LD_INT 31
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: PUSH
57220: LD_INT 58
57222: PUSH
57223: EMPTY
57224: LIST
57225: PUSH
57226: EMPTY
57227: LIST
57228: LIST
57229: PPUSH
57230: CALL_OW 72
57234: PUSH
57235: LD_INT 1
57237: ARRAY
57238: PPUSH
57239: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57243: LD_VAR 0 3
57247: PPUSH
57248: CALL_OW 310
57252: NOT
57253: PUSH
57254: LD_VAR 0 3
57258: PPUSH
57259: CALL_OW 310
57263: PPUSH
57264: CALL_OW 266
57268: PUSH
57269: LD_INT 36
57271: NONEQUAL
57272: PUSH
57273: LD_VAR 0 3
57277: PPUSH
57278: CALL 100717 0 1
57282: NOT
57283: AND
57284: OR
57285: IFFALSE 57421
// begin if IsInUnit ( j ) then
57287: LD_VAR 0 3
57291: PPUSH
57292: CALL_OW 310
57296: IFFALSE 57307
// ComExitBuilding ( j ) ;
57298: LD_VAR 0 3
57302: PPUSH
57303: CALL_OW 122
// ct := 0 ;
57307: LD_ADDR_VAR 0 8
57311: PUSH
57312: LD_INT 0
57314: ST_TO_ADDR
// for k in x do
57315: LD_ADDR_VAR 0 4
57319: PUSH
57320: LD_VAR 0 11
57324: PUSH
57325: FOR_IN
57326: IFFALSE 57399
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57328: LD_VAR 0 4
57332: PPUSH
57333: CALL_OW 264
57337: PUSH
57338: LD_INT 31
57340: EQUAL
57341: PUSH
57342: LD_VAR 0 4
57346: PPUSH
57347: CALL_OW 311
57351: NOT
57352: AND
57353: PUSH
57354: LD_VAR 0 4
57358: PPUSH
57359: CALL_OW 266
57363: PUSH
57364: LD_INT 36
57366: EQUAL
57367: PUSH
57368: LD_VAR 0 4
57372: PPUSH
57373: CALL_OW 313
57377: PUSH
57378: LD_INT 3
57380: LESS
57381: AND
57382: OR
57383: IFFALSE 57397
// begin ct := k ;
57385: LD_ADDR_VAR 0 8
57389: PUSH
57390: LD_VAR 0 4
57394: ST_TO_ADDR
// break ;
57395: GO 57399
// end ;
57397: GO 57325
57399: POP
57400: POP
// if ct then
57401: LD_VAR 0 8
57405: IFFALSE 57421
// ComEnterUnit ( j , ct ) ;
57407: LD_VAR 0 3
57411: PPUSH
57412: LD_VAR 0 8
57416: PPUSH
57417: CALL_OW 120
// end ; end ;
57421: GO 57056
57423: POP
57424: POP
// places := 0 ;
57425: LD_ADDR_VAR 0 5
57429: PUSH
57430: LD_INT 0
57432: ST_TO_ADDR
// for j = 1 to x do
57433: LD_ADDR_VAR 0 3
57437: PUSH
57438: DOUBLE
57439: LD_INT 1
57441: DEC
57442: ST_TO_ADDR
57443: LD_VAR 0 11
57447: PUSH
57448: FOR_TO
57449: IFFALSE 57525
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57451: LD_VAR 0 11
57455: PUSH
57456: LD_VAR 0 3
57460: ARRAY
57461: PPUSH
57462: CALL_OW 264
57466: PUSH
57467: LD_INT 31
57469: EQUAL
57470: IFFALSE 57488
// places := places + 1 else
57472: LD_ADDR_VAR 0 5
57476: PUSH
57477: LD_VAR 0 5
57481: PUSH
57482: LD_INT 1
57484: PLUS
57485: ST_TO_ADDR
57486: GO 57523
// if GetBType ( x [ j ] ) = b_control_tower then
57488: LD_VAR 0 11
57492: PUSH
57493: LD_VAR 0 3
57497: ARRAY
57498: PPUSH
57499: CALL_OW 266
57503: PUSH
57504: LD_INT 36
57506: EQUAL
57507: IFFALSE 57523
// places := places + 3 ;
57509: LD_ADDR_VAR 0 5
57513: PUSH
57514: LD_VAR 0 5
57518: PUSH
57519: LD_INT 3
57521: PLUS
57522: ST_TO_ADDR
57523: GO 57448
57525: POP
57526: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57527: LD_VAR 0 5
57531: PUSH
57532: LD_INT 0
57534: EQUAL
57535: PUSH
57536: LD_VAR 0 5
57540: PUSH
57541: LD_EXP 137
57545: PUSH
57546: LD_VAR 0 2
57550: ARRAY
57551: LESSEQUAL
57552: OR
57553: IFFALSE 57557
// continue ;
57555: GO 56807
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57557: LD_ADDR_VAR 0 6
57561: PUSH
57562: LD_EXP 97
57566: PUSH
57567: LD_VAR 0 2
57571: ARRAY
57572: PPUSH
57573: LD_INT 25
57575: PUSH
57576: LD_INT 3
57578: PUSH
57579: EMPTY
57580: LIST
57581: LIST
57582: PPUSH
57583: CALL_OW 72
57587: PUSH
57588: LD_EXP 137
57592: PUSH
57593: LD_VAR 0 2
57597: ARRAY
57598: DIFF
57599: PPUSH
57600: LD_INT 3
57602: PPUSH
57603: CALL 101617 0 2
57607: ST_TO_ADDR
// for j in tmp do
57608: LD_ADDR_VAR 0 3
57612: PUSH
57613: LD_VAR 0 6
57617: PUSH
57618: FOR_IN
57619: IFFALSE 57654
// if GetTag ( j ) > 0 then
57621: LD_VAR 0 3
57625: PPUSH
57626: CALL_OW 110
57630: PUSH
57631: LD_INT 0
57633: GREATER
57634: IFFALSE 57652
// tmp := tmp diff j ;
57636: LD_ADDR_VAR 0 6
57640: PUSH
57641: LD_VAR 0 6
57645: PUSH
57646: LD_VAR 0 3
57650: DIFF
57651: ST_TO_ADDR
57652: GO 57618
57654: POP
57655: POP
// if not tmp then
57656: LD_VAR 0 6
57660: NOT
57661: IFFALSE 57665
// continue ;
57663: GO 56807
// if places then
57665: LD_VAR 0 5
57669: IFFALSE 57728
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57671: LD_ADDR_EXP 137
57675: PUSH
57676: LD_EXP 137
57680: PPUSH
57681: LD_VAR 0 2
57685: PPUSH
57686: LD_EXP 137
57690: PUSH
57691: LD_VAR 0 2
57695: ARRAY
57696: PUSH
57697: LD_VAR 0 6
57701: PUSH
57702: LD_INT 1
57704: ARRAY
57705: UNION
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57712: LD_VAR 0 6
57716: PUSH
57717: LD_INT 1
57719: ARRAY
57720: PPUSH
57721: LD_INT 126
57723: PPUSH
57724: CALL_OW 109
// end ; end ;
57728: GO 56807
57730: POP
57731: POP
// end ;
57732: LD_VAR 0 1
57736: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57737: LD_INT 0
57739: PPUSH
57740: PPUSH
57741: PPUSH
57742: PPUSH
57743: PPUSH
57744: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57745: LD_VAR 0 1
57749: NOT
57750: PUSH
57751: LD_VAR 0 2
57755: NOT
57756: OR
57757: PUSH
57758: LD_VAR 0 3
57762: NOT
57763: OR
57764: PUSH
57765: LD_VAR 0 4
57769: PUSH
57770: LD_INT 1
57772: PUSH
57773: LD_INT 2
57775: PUSH
57776: LD_INT 3
57778: PUSH
57779: LD_INT 4
57781: PUSH
57782: LD_INT 5
57784: PUSH
57785: LD_INT 8
57787: PUSH
57788: LD_INT 9
57790: PUSH
57791: LD_INT 15
57793: PUSH
57794: LD_INT 16
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: LIST
57801: LIST
57802: LIST
57803: LIST
57804: LIST
57805: LIST
57806: LIST
57807: IN
57808: NOT
57809: OR
57810: IFFALSE 57814
// exit ;
57812: GO 58714
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57814: LD_ADDR_VAR 0 2
57818: PUSH
57819: LD_VAR 0 2
57823: PPUSH
57824: LD_INT 21
57826: PUSH
57827: LD_INT 3
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: PUSH
57834: LD_INT 24
57836: PUSH
57837: LD_INT 250
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PPUSH
57848: CALL_OW 72
57852: ST_TO_ADDR
// case class of 1 , 15 :
57853: LD_VAR 0 4
57857: PUSH
57858: LD_INT 1
57860: DOUBLE
57861: EQUAL
57862: IFTRUE 57872
57864: LD_INT 15
57866: DOUBLE
57867: EQUAL
57868: IFTRUE 57872
57870: GO 57957
57872: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57873: LD_ADDR_VAR 0 8
57877: PUSH
57878: LD_VAR 0 2
57882: PPUSH
57883: LD_INT 2
57885: PUSH
57886: LD_INT 30
57888: PUSH
57889: LD_INT 32
57891: PUSH
57892: EMPTY
57893: LIST
57894: LIST
57895: PUSH
57896: LD_INT 30
57898: PUSH
57899: LD_INT 31
57901: PUSH
57902: EMPTY
57903: LIST
57904: LIST
57905: PUSH
57906: EMPTY
57907: LIST
57908: LIST
57909: LIST
57910: PPUSH
57911: CALL_OW 72
57915: PUSH
57916: LD_VAR 0 2
57920: PPUSH
57921: LD_INT 2
57923: PUSH
57924: LD_INT 30
57926: PUSH
57927: LD_INT 4
57929: PUSH
57930: EMPTY
57931: LIST
57932: LIST
57933: PUSH
57934: LD_INT 30
57936: PUSH
57937: LD_INT 5
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: LIST
57948: PPUSH
57949: CALL_OW 72
57953: ADD
57954: ST_TO_ADDR
57955: GO 58203
57957: LD_INT 2
57959: DOUBLE
57960: EQUAL
57961: IFTRUE 57971
57963: LD_INT 16
57965: DOUBLE
57966: EQUAL
57967: IFTRUE 57971
57969: GO 58017
57971: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57972: LD_ADDR_VAR 0 8
57976: PUSH
57977: LD_VAR 0 2
57981: PPUSH
57982: LD_INT 2
57984: PUSH
57985: LD_INT 30
57987: PUSH
57988: LD_INT 0
57990: PUSH
57991: EMPTY
57992: LIST
57993: LIST
57994: PUSH
57995: LD_INT 30
57997: PUSH
57998: LD_INT 1
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: EMPTY
58006: LIST
58007: LIST
58008: LIST
58009: PPUSH
58010: CALL_OW 72
58014: ST_TO_ADDR
58015: GO 58203
58017: LD_INT 3
58019: DOUBLE
58020: EQUAL
58021: IFTRUE 58025
58023: GO 58071
58025: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58026: LD_ADDR_VAR 0 8
58030: PUSH
58031: LD_VAR 0 2
58035: PPUSH
58036: LD_INT 2
58038: PUSH
58039: LD_INT 30
58041: PUSH
58042: LD_INT 2
58044: PUSH
58045: EMPTY
58046: LIST
58047: LIST
58048: PUSH
58049: LD_INT 30
58051: PUSH
58052: LD_INT 3
58054: PUSH
58055: EMPTY
58056: LIST
58057: LIST
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: LIST
58063: PPUSH
58064: CALL_OW 72
58068: ST_TO_ADDR
58069: GO 58203
58071: LD_INT 4
58073: DOUBLE
58074: EQUAL
58075: IFTRUE 58079
58077: GO 58136
58079: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58080: LD_ADDR_VAR 0 8
58084: PUSH
58085: LD_VAR 0 2
58089: PPUSH
58090: LD_INT 2
58092: PUSH
58093: LD_INT 30
58095: PUSH
58096: LD_INT 6
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: PUSH
58103: LD_INT 30
58105: PUSH
58106: LD_INT 7
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PUSH
58113: LD_INT 30
58115: PUSH
58116: LD_INT 8
58118: PUSH
58119: EMPTY
58120: LIST
58121: LIST
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: LIST
58127: LIST
58128: PPUSH
58129: CALL_OW 72
58133: ST_TO_ADDR
58134: GO 58203
58136: LD_INT 5
58138: DOUBLE
58139: EQUAL
58140: IFTRUE 58156
58142: LD_INT 8
58144: DOUBLE
58145: EQUAL
58146: IFTRUE 58156
58148: LD_INT 9
58150: DOUBLE
58151: EQUAL
58152: IFTRUE 58156
58154: GO 58202
58156: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58157: LD_ADDR_VAR 0 8
58161: PUSH
58162: LD_VAR 0 2
58166: PPUSH
58167: LD_INT 2
58169: PUSH
58170: LD_INT 30
58172: PUSH
58173: LD_INT 4
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: PUSH
58180: LD_INT 30
58182: PUSH
58183: LD_INT 5
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: LIST
58194: PPUSH
58195: CALL_OW 72
58199: ST_TO_ADDR
58200: GO 58203
58202: POP
// if not tmp then
58203: LD_VAR 0 8
58207: NOT
58208: IFFALSE 58212
// exit ;
58210: GO 58714
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58212: LD_VAR 0 4
58216: PUSH
58217: LD_INT 1
58219: PUSH
58220: LD_INT 15
58222: PUSH
58223: EMPTY
58224: LIST
58225: LIST
58226: IN
58227: PUSH
58228: LD_EXP 106
58232: PUSH
58233: LD_VAR 0 1
58237: ARRAY
58238: AND
58239: IFFALSE 58395
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58241: LD_ADDR_VAR 0 9
58245: PUSH
58246: LD_EXP 106
58250: PUSH
58251: LD_VAR 0 1
58255: ARRAY
58256: PUSH
58257: LD_INT 1
58259: ARRAY
58260: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58261: LD_VAR 0 9
58265: PUSH
58266: LD_EXP 107
58270: PUSH
58271: LD_VAR 0 1
58275: ARRAY
58276: IN
58277: NOT
58278: IFFALSE 58393
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58280: LD_ADDR_EXP 107
58284: PUSH
58285: LD_EXP 107
58289: PPUSH
58290: LD_VAR 0 1
58294: PUSH
58295: LD_EXP 107
58299: PUSH
58300: LD_VAR 0 1
58304: ARRAY
58305: PUSH
58306: LD_INT 1
58308: PLUS
58309: PUSH
58310: EMPTY
58311: LIST
58312: LIST
58313: PPUSH
58314: LD_VAR 0 9
58318: PPUSH
58319: CALL 70869 0 3
58323: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58324: LD_ADDR_EXP 106
58328: PUSH
58329: LD_EXP 106
58333: PPUSH
58334: LD_VAR 0 1
58338: PPUSH
58339: LD_EXP 106
58343: PUSH
58344: LD_VAR 0 1
58348: ARRAY
58349: PUSH
58350: LD_VAR 0 9
58354: DIFF
58355: PPUSH
58356: CALL_OW 1
58360: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58361: LD_VAR 0 3
58365: PPUSH
58366: LD_EXP 107
58370: PUSH
58371: LD_VAR 0 1
58375: ARRAY
58376: PUSH
58377: LD_EXP 107
58381: PUSH
58382: LD_VAR 0 1
58386: ARRAY
58387: ARRAY
58388: PPUSH
58389: CALL_OW 120
// end ; exit ;
58393: GO 58714
// end ; if tmp > 1 then
58395: LD_VAR 0 8
58399: PUSH
58400: LD_INT 1
58402: GREATER
58403: IFFALSE 58507
// for i = 2 to tmp do
58405: LD_ADDR_VAR 0 6
58409: PUSH
58410: DOUBLE
58411: LD_INT 2
58413: DEC
58414: ST_TO_ADDR
58415: LD_VAR 0 8
58419: PUSH
58420: FOR_TO
58421: IFFALSE 58505
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58423: LD_VAR 0 8
58427: PUSH
58428: LD_VAR 0 6
58432: ARRAY
58433: PPUSH
58434: CALL_OW 461
58438: PUSH
58439: LD_INT 6
58441: EQUAL
58442: IFFALSE 58503
// begin x := tmp [ i ] ;
58444: LD_ADDR_VAR 0 9
58448: PUSH
58449: LD_VAR 0 8
58453: PUSH
58454: LD_VAR 0 6
58458: ARRAY
58459: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58460: LD_ADDR_VAR 0 8
58464: PUSH
58465: LD_VAR 0 8
58469: PPUSH
58470: LD_VAR 0 6
58474: PPUSH
58475: CALL_OW 3
58479: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58480: LD_ADDR_VAR 0 8
58484: PUSH
58485: LD_VAR 0 8
58489: PPUSH
58490: LD_INT 1
58492: PPUSH
58493: LD_VAR 0 9
58497: PPUSH
58498: CALL_OW 2
58502: ST_TO_ADDR
// end ;
58503: GO 58420
58505: POP
58506: POP
// for i in tmp do
58507: LD_ADDR_VAR 0 6
58511: PUSH
58512: LD_VAR 0 8
58516: PUSH
58517: FOR_IN
58518: IFFALSE 58587
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58520: LD_VAR 0 6
58524: PPUSH
58525: CALL_OW 313
58529: PUSH
58530: LD_INT 6
58532: LESS
58533: PUSH
58534: LD_VAR 0 6
58538: PPUSH
58539: CALL_OW 266
58543: PUSH
58544: LD_INT 31
58546: PUSH
58547: LD_INT 32
58549: PUSH
58550: EMPTY
58551: LIST
58552: LIST
58553: IN
58554: NOT
58555: AND
58556: PUSH
58557: LD_VAR 0 6
58561: PPUSH
58562: CALL_OW 313
58566: PUSH
58567: LD_INT 0
58569: EQUAL
58570: OR
58571: IFFALSE 58585
// begin j := i ;
58573: LD_ADDR_VAR 0 7
58577: PUSH
58578: LD_VAR 0 6
58582: ST_TO_ADDR
// break ;
58583: GO 58587
// end ; end ;
58585: GO 58517
58587: POP
58588: POP
// if j then
58589: LD_VAR 0 7
58593: IFFALSE 58611
// ComEnterUnit ( unit , j ) else
58595: LD_VAR 0 3
58599: PPUSH
58600: LD_VAR 0 7
58604: PPUSH
58605: CALL_OW 120
58609: GO 58714
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58611: LD_ADDR_VAR 0 10
58615: PUSH
58616: LD_VAR 0 2
58620: PPUSH
58621: LD_INT 2
58623: PUSH
58624: LD_INT 30
58626: PUSH
58627: LD_INT 0
58629: PUSH
58630: EMPTY
58631: LIST
58632: LIST
58633: PUSH
58634: LD_INT 30
58636: PUSH
58637: LD_INT 1
58639: PUSH
58640: EMPTY
58641: LIST
58642: LIST
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: LIST
58648: PPUSH
58649: CALL_OW 72
58653: ST_TO_ADDR
// if depot then
58654: LD_VAR 0 10
58658: IFFALSE 58714
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58660: LD_ADDR_VAR 0 10
58664: PUSH
58665: LD_VAR 0 10
58669: PPUSH
58670: LD_VAR 0 3
58674: PPUSH
58675: CALL_OW 74
58679: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58680: LD_VAR 0 3
58684: PPUSH
58685: LD_VAR 0 10
58689: PPUSH
58690: CALL_OW 296
58694: PUSH
58695: LD_INT 10
58697: GREATER
58698: IFFALSE 58714
// ComStandNearbyBuilding ( unit , depot ) ;
58700: LD_VAR 0 3
58704: PPUSH
58705: LD_VAR 0 10
58709: PPUSH
58710: CALL 67296 0 2
// end ; end ; end ;
58714: LD_VAR 0 5
58718: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58719: LD_INT 0
58721: PPUSH
58722: PPUSH
58723: PPUSH
58724: PPUSH
// if not mc_bases then
58725: LD_EXP 97
58729: NOT
58730: IFFALSE 58734
// exit ;
58732: GO 58973
// for i = 1 to mc_bases do
58734: LD_ADDR_VAR 0 2
58738: PUSH
58739: DOUBLE
58740: LD_INT 1
58742: DEC
58743: ST_TO_ADDR
58744: LD_EXP 97
58748: PUSH
58749: FOR_TO
58750: IFFALSE 58971
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58752: LD_ADDR_VAR 0 4
58756: PUSH
58757: LD_EXP 97
58761: PUSH
58762: LD_VAR 0 2
58766: ARRAY
58767: PPUSH
58768: LD_INT 21
58770: PUSH
58771: LD_INT 1
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: PPUSH
58778: CALL_OW 72
58782: PUSH
58783: LD_EXP 126
58787: PUSH
58788: LD_VAR 0 2
58792: ARRAY
58793: UNION
58794: ST_TO_ADDR
// if not tmp then
58795: LD_VAR 0 4
58799: NOT
58800: IFFALSE 58804
// continue ;
58802: GO 58749
// for j in tmp do
58804: LD_ADDR_VAR 0 3
58808: PUSH
58809: LD_VAR 0 4
58813: PUSH
58814: FOR_IN
58815: IFFALSE 58967
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58817: LD_VAR 0 3
58821: PPUSH
58822: CALL_OW 110
58826: NOT
58827: PUSH
58828: LD_VAR 0 3
58832: PPUSH
58833: CALL_OW 314
58837: NOT
58838: AND
58839: PUSH
58840: LD_VAR 0 3
58844: PPUSH
58845: CALL_OW 311
58849: NOT
58850: AND
58851: PUSH
58852: LD_VAR 0 3
58856: PPUSH
58857: CALL_OW 310
58861: NOT
58862: AND
58863: PUSH
58864: LD_VAR 0 3
58868: PUSH
58869: LD_EXP 100
58873: PUSH
58874: LD_VAR 0 2
58878: ARRAY
58879: PUSH
58880: LD_INT 1
58882: ARRAY
58883: IN
58884: NOT
58885: AND
58886: PUSH
58887: LD_VAR 0 3
58891: PUSH
58892: LD_EXP 100
58896: PUSH
58897: LD_VAR 0 2
58901: ARRAY
58902: PUSH
58903: LD_INT 2
58905: ARRAY
58906: IN
58907: NOT
58908: AND
58909: PUSH
58910: LD_VAR 0 3
58914: PUSH
58915: LD_EXP 109
58919: PUSH
58920: LD_VAR 0 2
58924: ARRAY
58925: IN
58926: NOT
58927: AND
58928: IFFALSE 58965
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58930: LD_VAR 0 2
58934: PPUSH
58935: LD_EXP 97
58939: PUSH
58940: LD_VAR 0 2
58944: ARRAY
58945: PPUSH
58946: LD_VAR 0 3
58950: PPUSH
58951: LD_VAR 0 3
58955: PPUSH
58956: CALL_OW 257
58960: PPUSH
58961: CALL 57737 0 4
// end ;
58965: GO 58814
58967: POP
58968: POP
// end ;
58969: GO 58749
58971: POP
58972: POP
// end ;
58973: LD_VAR 0 1
58977: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58978: LD_INT 0
58980: PPUSH
58981: PPUSH
58982: PPUSH
58983: PPUSH
58984: PPUSH
58985: PPUSH
// if not mc_bases [ base ] then
58986: LD_EXP 97
58990: PUSH
58991: LD_VAR 0 1
58995: ARRAY
58996: NOT
58997: IFFALSE 59001
// exit ;
58999: GO 59183
// tmp := [ ] ;
59001: LD_ADDR_VAR 0 6
59005: PUSH
59006: EMPTY
59007: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59008: LD_ADDR_VAR 0 7
59012: PUSH
59013: LD_VAR 0 3
59017: PPUSH
59018: LD_INT 0
59020: PPUSH
59021: CALL_OW 517
59025: ST_TO_ADDR
// if not list then
59026: LD_VAR 0 7
59030: NOT
59031: IFFALSE 59035
// exit ;
59033: GO 59183
// for i = 1 to amount do
59035: LD_ADDR_VAR 0 5
59039: PUSH
59040: DOUBLE
59041: LD_INT 1
59043: DEC
59044: ST_TO_ADDR
59045: LD_VAR 0 2
59049: PUSH
59050: FOR_TO
59051: IFFALSE 59131
// begin x := rand ( 1 , list [ 1 ] ) ;
59053: LD_ADDR_VAR 0 8
59057: PUSH
59058: LD_INT 1
59060: PPUSH
59061: LD_VAR 0 7
59065: PUSH
59066: LD_INT 1
59068: ARRAY
59069: PPUSH
59070: CALL_OW 12
59074: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59075: LD_ADDR_VAR 0 6
59079: PUSH
59080: LD_VAR 0 6
59084: PPUSH
59085: LD_VAR 0 5
59089: PPUSH
59090: LD_VAR 0 7
59094: PUSH
59095: LD_INT 1
59097: ARRAY
59098: PUSH
59099: LD_VAR 0 8
59103: ARRAY
59104: PUSH
59105: LD_VAR 0 7
59109: PUSH
59110: LD_INT 2
59112: ARRAY
59113: PUSH
59114: LD_VAR 0 8
59118: ARRAY
59119: PUSH
59120: EMPTY
59121: LIST
59122: LIST
59123: PPUSH
59124: CALL_OW 1
59128: ST_TO_ADDR
// end ;
59129: GO 59050
59131: POP
59132: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59133: LD_ADDR_EXP 110
59137: PUSH
59138: LD_EXP 110
59142: PPUSH
59143: LD_VAR 0 1
59147: PPUSH
59148: LD_VAR 0 6
59152: PPUSH
59153: CALL_OW 1
59157: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59158: LD_ADDR_EXP 112
59162: PUSH
59163: LD_EXP 112
59167: PPUSH
59168: LD_VAR 0 1
59172: PPUSH
59173: LD_VAR 0 3
59177: PPUSH
59178: CALL_OW 1
59182: ST_TO_ADDR
// end ;
59183: LD_VAR 0 4
59187: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59188: LD_INT 0
59190: PPUSH
// if not mc_bases [ base ] then
59191: LD_EXP 97
59195: PUSH
59196: LD_VAR 0 1
59200: ARRAY
59201: NOT
59202: IFFALSE 59206
// exit ;
59204: GO 59231
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59206: LD_ADDR_EXP 102
59210: PUSH
59211: LD_EXP 102
59215: PPUSH
59216: LD_VAR 0 1
59220: PPUSH
59221: LD_VAR 0 2
59225: PPUSH
59226: CALL_OW 1
59230: ST_TO_ADDR
// end ;
59231: LD_VAR 0 3
59235: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59236: LD_INT 0
59238: PPUSH
// if not mc_bases [ base ] then
59239: LD_EXP 97
59243: PUSH
59244: LD_VAR 0 1
59248: ARRAY
59249: NOT
59250: IFFALSE 59254
// exit ;
59252: GO 59291
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59254: LD_ADDR_EXP 102
59258: PUSH
59259: LD_EXP 102
59263: PPUSH
59264: LD_VAR 0 1
59268: PPUSH
59269: LD_EXP 102
59273: PUSH
59274: LD_VAR 0 1
59278: ARRAY
59279: PUSH
59280: LD_VAR 0 2
59284: UNION
59285: PPUSH
59286: CALL_OW 1
59290: ST_TO_ADDR
// end ;
59291: LD_VAR 0 3
59295: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59296: LD_INT 0
59298: PPUSH
// if not mc_bases [ base ] then
59299: LD_EXP 97
59303: PUSH
59304: LD_VAR 0 1
59308: ARRAY
59309: NOT
59310: IFFALSE 59314
// exit ;
59312: GO 59339
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59314: LD_ADDR_EXP 118
59318: PUSH
59319: LD_EXP 118
59323: PPUSH
59324: LD_VAR 0 1
59328: PPUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: CALL_OW 1
59338: ST_TO_ADDR
// end ;
59339: LD_VAR 0 3
59343: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59344: LD_INT 0
59346: PPUSH
// if not mc_bases [ base ] then
59347: LD_EXP 97
59351: PUSH
59352: LD_VAR 0 1
59356: ARRAY
59357: NOT
59358: IFFALSE 59362
// exit ;
59360: GO 59399
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59362: LD_ADDR_EXP 118
59366: PUSH
59367: LD_EXP 118
59371: PPUSH
59372: LD_VAR 0 1
59376: PPUSH
59377: LD_EXP 118
59381: PUSH
59382: LD_VAR 0 1
59386: ARRAY
59387: PUSH
59388: LD_VAR 0 2
59392: ADD
59393: PPUSH
59394: CALL_OW 1
59398: ST_TO_ADDR
// end ;
59399: LD_VAR 0 3
59403: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59404: LD_INT 0
59406: PPUSH
// if not mc_bases [ base ] then
59407: LD_EXP 97
59411: PUSH
59412: LD_VAR 0 1
59416: ARRAY
59417: NOT
59418: IFFALSE 59422
// exit ;
59420: GO 59476
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59422: LD_ADDR_EXP 119
59426: PUSH
59427: LD_EXP 119
59431: PPUSH
59432: LD_VAR 0 1
59436: PPUSH
59437: LD_VAR 0 2
59441: PPUSH
59442: CALL_OW 1
59446: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59447: LD_ADDR_EXP 108
59451: PUSH
59452: LD_EXP 108
59456: PPUSH
59457: LD_VAR 0 1
59461: PPUSH
59462: LD_VAR 0 2
59466: PUSH
59467: LD_INT 0
59469: PLUS
59470: PPUSH
59471: CALL_OW 1
59475: ST_TO_ADDR
// end ;
59476: LD_VAR 0 3
59480: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59481: LD_INT 0
59483: PPUSH
// if not mc_bases [ base ] then
59484: LD_EXP 97
59488: PUSH
59489: LD_VAR 0 1
59493: ARRAY
59494: NOT
59495: IFFALSE 59499
// exit ;
59497: GO 59524
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59499: LD_ADDR_EXP 108
59503: PUSH
59504: LD_EXP 108
59508: PPUSH
59509: LD_VAR 0 1
59513: PPUSH
59514: LD_VAR 0 2
59518: PPUSH
59519: CALL_OW 1
59523: ST_TO_ADDR
// end ;
59524: LD_VAR 0 3
59528: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59529: LD_INT 0
59531: PPUSH
59532: PPUSH
59533: PPUSH
59534: PPUSH
// if not mc_bases [ base ] then
59535: LD_EXP 97
59539: PUSH
59540: LD_VAR 0 1
59544: ARRAY
59545: NOT
59546: IFFALSE 59550
// exit ;
59548: GO 59615
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59550: LD_ADDR_EXP 117
59554: PUSH
59555: LD_EXP 117
59559: PPUSH
59560: LD_VAR 0 1
59564: PUSH
59565: LD_EXP 117
59569: PUSH
59570: LD_VAR 0 1
59574: ARRAY
59575: PUSH
59576: LD_INT 1
59578: PLUS
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: PPUSH
59584: LD_VAR 0 1
59588: PUSH
59589: LD_VAR 0 2
59593: PUSH
59594: LD_VAR 0 3
59598: PUSH
59599: LD_VAR 0 4
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: LIST
59608: LIST
59609: PPUSH
59610: CALL 70869 0 3
59614: ST_TO_ADDR
// end ;
59615: LD_VAR 0 5
59619: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59620: LD_INT 0
59622: PPUSH
// if not mc_bases [ base ] then
59623: LD_EXP 97
59627: PUSH
59628: LD_VAR 0 1
59632: ARRAY
59633: NOT
59634: IFFALSE 59638
// exit ;
59636: GO 59663
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59638: LD_ADDR_EXP 134
59642: PUSH
59643: LD_EXP 134
59647: PPUSH
59648: LD_VAR 0 1
59652: PPUSH
59653: LD_VAR 0 2
59657: PPUSH
59658: CALL_OW 1
59662: ST_TO_ADDR
// end ;
59663: LD_VAR 0 3
59667: RET
// export function MC_GetMinesField ( base ) ; begin
59668: LD_INT 0
59670: PPUSH
// result := mc_mines [ base ] ;
59671: LD_ADDR_VAR 0 2
59675: PUSH
59676: LD_EXP 110
59680: PUSH
59681: LD_VAR 0 1
59685: ARRAY
59686: ST_TO_ADDR
// end ;
59687: LD_VAR 0 2
59691: RET
// export function MC_GetProduceList ( base ) ; begin
59692: LD_INT 0
59694: PPUSH
// result := mc_produce [ base ] ;
59695: LD_ADDR_VAR 0 2
59699: PUSH
59700: LD_EXP 118
59704: PUSH
59705: LD_VAR 0 1
59709: ARRAY
59710: ST_TO_ADDR
// end ;
59711: LD_VAR 0 2
59715: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59716: LD_INT 0
59718: PPUSH
59719: PPUSH
// if not mc_bases then
59720: LD_EXP 97
59724: NOT
59725: IFFALSE 59729
// exit ;
59727: GO 59794
// if mc_bases [ base ] then
59729: LD_EXP 97
59733: PUSH
59734: LD_VAR 0 1
59738: ARRAY
59739: IFFALSE 59794
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59741: LD_ADDR_VAR 0 3
59745: PUSH
59746: LD_EXP 97
59750: PUSH
59751: LD_VAR 0 1
59755: ARRAY
59756: PPUSH
59757: LD_INT 30
59759: PUSH
59760: LD_VAR 0 2
59764: PUSH
59765: EMPTY
59766: LIST
59767: LIST
59768: PPUSH
59769: CALL_OW 72
59773: ST_TO_ADDR
// if result then
59774: LD_VAR 0 3
59778: IFFALSE 59794
// result := result [ 1 ] ;
59780: LD_ADDR_VAR 0 3
59784: PUSH
59785: LD_VAR 0 3
59789: PUSH
59790: LD_INT 1
59792: ARRAY
59793: ST_TO_ADDR
// end ; end ;
59794: LD_VAR 0 3
59798: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59799: LD_INT 0
59801: PPUSH
59802: PPUSH
// if not mc_bases then
59803: LD_EXP 97
59807: NOT
59808: IFFALSE 59812
// exit ;
59810: GO 59857
// if mc_bases [ base ] then
59812: LD_EXP 97
59816: PUSH
59817: LD_VAR 0 1
59821: ARRAY
59822: IFFALSE 59857
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59824: LD_ADDR_VAR 0 3
59828: PUSH
59829: LD_EXP 97
59833: PUSH
59834: LD_VAR 0 1
59838: ARRAY
59839: PPUSH
59840: LD_INT 30
59842: PUSH
59843: LD_VAR 0 2
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: PPUSH
59852: CALL_OW 72
59856: ST_TO_ADDR
// end ;
59857: LD_VAR 0 3
59861: RET
// export function MC_SetTame ( base , area ) ; begin
59862: LD_INT 0
59864: PPUSH
// if not mc_bases or not base then
59865: LD_EXP 97
59869: NOT
59870: PUSH
59871: LD_VAR 0 1
59875: NOT
59876: OR
59877: IFFALSE 59881
// exit ;
59879: GO 59906
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59881: LD_ADDR_EXP 125
59885: PUSH
59886: LD_EXP 125
59890: PPUSH
59891: LD_VAR 0 1
59895: PPUSH
59896: LD_VAR 0 2
59900: PPUSH
59901: CALL_OW 1
59905: ST_TO_ADDR
// end ;
59906: LD_VAR 0 3
59910: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59911: LD_INT 0
59913: PPUSH
59914: PPUSH
// if not mc_bases or not base then
59915: LD_EXP 97
59919: NOT
59920: PUSH
59921: LD_VAR 0 1
59925: NOT
59926: OR
59927: IFFALSE 59931
// exit ;
59929: GO 60033
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59931: LD_ADDR_VAR 0 4
59935: PUSH
59936: LD_EXP 97
59940: PUSH
59941: LD_VAR 0 1
59945: ARRAY
59946: PPUSH
59947: LD_INT 30
59949: PUSH
59950: LD_VAR 0 2
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: PPUSH
59959: CALL_OW 72
59963: ST_TO_ADDR
// if not tmp then
59964: LD_VAR 0 4
59968: NOT
59969: IFFALSE 59973
// exit ;
59971: GO 60033
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59973: LD_ADDR_EXP 129
59977: PUSH
59978: LD_EXP 129
59982: PPUSH
59983: LD_VAR 0 1
59987: PPUSH
59988: LD_EXP 129
59992: PUSH
59993: LD_VAR 0 1
59997: ARRAY
59998: PPUSH
59999: LD_EXP 129
60003: PUSH
60004: LD_VAR 0 1
60008: ARRAY
60009: PUSH
60010: LD_INT 1
60012: PLUS
60013: PPUSH
60014: LD_VAR 0 4
60018: PUSH
60019: LD_INT 1
60021: ARRAY
60022: PPUSH
60023: CALL_OW 2
60027: PPUSH
60028: CALL_OW 1
60032: ST_TO_ADDR
// end ;
60033: LD_VAR 0 3
60037: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60038: LD_INT 0
60040: PPUSH
60041: PPUSH
// if not mc_bases or not base or not kinds then
60042: LD_EXP 97
60046: NOT
60047: PUSH
60048: LD_VAR 0 1
60052: NOT
60053: OR
60054: PUSH
60055: LD_VAR 0 2
60059: NOT
60060: OR
60061: IFFALSE 60065
// exit ;
60063: GO 60126
// for i in kinds do
60065: LD_ADDR_VAR 0 4
60069: PUSH
60070: LD_VAR 0 2
60074: PUSH
60075: FOR_IN
60076: IFFALSE 60124
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60078: LD_ADDR_EXP 131
60082: PUSH
60083: LD_EXP 131
60087: PPUSH
60088: LD_VAR 0 1
60092: PUSH
60093: LD_EXP 131
60097: PUSH
60098: LD_VAR 0 1
60102: ARRAY
60103: PUSH
60104: LD_INT 1
60106: PLUS
60107: PUSH
60108: EMPTY
60109: LIST
60110: LIST
60111: PPUSH
60112: LD_VAR 0 4
60116: PPUSH
60117: CALL 70869 0 3
60121: ST_TO_ADDR
60122: GO 60075
60124: POP
60125: POP
// end ;
60126: LD_VAR 0 3
60130: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60131: LD_INT 0
60133: PPUSH
// if not mc_bases or not base or not areas then
60134: LD_EXP 97
60138: NOT
60139: PUSH
60140: LD_VAR 0 1
60144: NOT
60145: OR
60146: PUSH
60147: LD_VAR 0 2
60151: NOT
60152: OR
60153: IFFALSE 60157
// exit ;
60155: GO 60182
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60157: LD_ADDR_EXP 115
60161: PUSH
60162: LD_EXP 115
60166: PPUSH
60167: LD_VAR 0 1
60171: PPUSH
60172: LD_VAR 0 2
60176: PPUSH
60177: CALL_OW 1
60181: ST_TO_ADDR
// end ;
60182: LD_VAR 0 3
60186: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60187: LD_INT 0
60189: PPUSH
// if not mc_bases or not base or not teleports_exit then
60190: LD_EXP 97
60194: NOT
60195: PUSH
60196: LD_VAR 0 1
60200: NOT
60201: OR
60202: PUSH
60203: LD_VAR 0 2
60207: NOT
60208: OR
60209: IFFALSE 60213
// exit ;
60211: GO 60238
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60213: LD_ADDR_EXP 132
60217: PUSH
60218: LD_EXP 132
60222: PPUSH
60223: LD_VAR 0 1
60227: PPUSH
60228: LD_VAR 0 2
60232: PPUSH
60233: CALL_OW 1
60237: ST_TO_ADDR
// end ;
60238: LD_VAR 0 3
60242: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60243: LD_INT 0
60245: PPUSH
60246: PPUSH
60247: PPUSH
// if not mc_bases or not base or not ext_list then
60248: LD_EXP 97
60252: NOT
60253: PUSH
60254: LD_VAR 0 1
60258: NOT
60259: OR
60260: PUSH
60261: LD_VAR 0 5
60265: NOT
60266: OR
60267: IFFALSE 60271
// exit ;
60269: GO 60444
// tmp := GetFacExtXYD ( x , y , d ) ;
60271: LD_ADDR_VAR 0 8
60275: PUSH
60276: LD_VAR 0 2
60280: PPUSH
60281: LD_VAR 0 3
60285: PPUSH
60286: LD_VAR 0 4
60290: PPUSH
60291: CALL 100747 0 3
60295: ST_TO_ADDR
// if not tmp then
60296: LD_VAR 0 8
60300: NOT
60301: IFFALSE 60305
// exit ;
60303: GO 60444
// for i in tmp do
60305: LD_ADDR_VAR 0 7
60309: PUSH
60310: LD_VAR 0 8
60314: PUSH
60315: FOR_IN
60316: IFFALSE 60442
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60318: LD_ADDR_EXP 102
60322: PUSH
60323: LD_EXP 102
60327: PPUSH
60328: LD_VAR 0 1
60332: PPUSH
60333: LD_EXP 102
60337: PUSH
60338: LD_VAR 0 1
60342: ARRAY
60343: PPUSH
60344: LD_EXP 102
60348: PUSH
60349: LD_VAR 0 1
60353: ARRAY
60354: PUSH
60355: LD_INT 1
60357: PLUS
60358: PPUSH
60359: LD_VAR 0 5
60363: PUSH
60364: LD_INT 1
60366: ARRAY
60367: PUSH
60368: LD_VAR 0 7
60372: PUSH
60373: LD_INT 1
60375: ARRAY
60376: PUSH
60377: LD_VAR 0 7
60381: PUSH
60382: LD_INT 2
60384: ARRAY
60385: PUSH
60386: LD_VAR 0 7
60390: PUSH
60391: LD_INT 3
60393: ARRAY
60394: PUSH
60395: EMPTY
60396: LIST
60397: LIST
60398: LIST
60399: LIST
60400: PPUSH
60401: CALL_OW 2
60405: PPUSH
60406: CALL_OW 1
60410: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60411: LD_ADDR_VAR 0 5
60415: PUSH
60416: LD_VAR 0 5
60420: PPUSH
60421: LD_INT 1
60423: PPUSH
60424: CALL_OW 3
60428: ST_TO_ADDR
// if not ext_list then
60429: LD_VAR 0 5
60433: NOT
60434: IFFALSE 60440
// exit ;
60436: POP
60437: POP
60438: GO 60444
// end ;
60440: GO 60315
60442: POP
60443: POP
// end ;
60444: LD_VAR 0 6
60448: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60449: LD_INT 0
60451: PPUSH
// if not mc_bases or not base or not weapon_list then
60452: LD_EXP 97
60456: NOT
60457: PUSH
60458: LD_VAR 0 1
60462: NOT
60463: OR
60464: PUSH
60465: LD_VAR 0 2
60469: NOT
60470: OR
60471: IFFALSE 60475
// exit ;
60473: GO 60500
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60475: LD_ADDR_EXP 136
60479: PUSH
60480: LD_EXP 136
60484: PPUSH
60485: LD_VAR 0 1
60489: PPUSH
60490: LD_VAR 0 2
60494: PPUSH
60495: CALL_OW 1
60499: ST_TO_ADDR
// end ;
60500: LD_VAR 0 3
60504: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60505: LD_INT 0
60507: PPUSH
// if not mc_bases or not base or not tech_list then
60508: LD_EXP 97
60512: NOT
60513: PUSH
60514: LD_VAR 0 1
60518: NOT
60519: OR
60520: PUSH
60521: LD_VAR 0 2
60525: NOT
60526: OR
60527: IFFALSE 60531
// exit ;
60529: GO 60556
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60531: LD_ADDR_EXP 124
60535: PUSH
60536: LD_EXP 124
60540: PPUSH
60541: LD_VAR 0 1
60545: PPUSH
60546: LD_VAR 0 2
60550: PPUSH
60551: CALL_OW 1
60555: ST_TO_ADDR
// end ;
60556: LD_VAR 0 3
60560: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60561: LD_INT 0
60563: PPUSH
// if not mc_bases or not parking_area or not base then
60564: LD_EXP 97
60568: NOT
60569: PUSH
60570: LD_VAR 0 2
60574: NOT
60575: OR
60576: PUSH
60577: LD_VAR 0 1
60581: NOT
60582: OR
60583: IFFALSE 60587
// exit ;
60585: GO 60612
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60587: LD_ADDR_EXP 121
60591: PUSH
60592: LD_EXP 121
60596: PPUSH
60597: LD_VAR 0 1
60601: PPUSH
60602: LD_VAR 0 2
60606: PPUSH
60607: CALL_OW 1
60611: ST_TO_ADDR
// end ;
60612: LD_VAR 0 3
60616: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60617: LD_INT 0
60619: PPUSH
// if not mc_bases or not base or not scan_area then
60620: LD_EXP 97
60624: NOT
60625: PUSH
60626: LD_VAR 0 1
60630: NOT
60631: OR
60632: PUSH
60633: LD_VAR 0 2
60637: NOT
60638: OR
60639: IFFALSE 60643
// exit ;
60641: GO 60668
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60643: LD_ADDR_EXP 122
60647: PUSH
60648: LD_EXP 122
60652: PPUSH
60653: LD_VAR 0 1
60657: PPUSH
60658: LD_VAR 0 2
60662: PPUSH
60663: CALL_OW 1
60667: ST_TO_ADDR
// end ;
60668: LD_VAR 0 3
60672: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60673: LD_INT 0
60675: PPUSH
60676: PPUSH
// if not mc_bases or not base then
60677: LD_EXP 97
60681: NOT
60682: PUSH
60683: LD_VAR 0 1
60687: NOT
60688: OR
60689: IFFALSE 60693
// exit ;
60691: GO 60757
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60693: LD_ADDR_VAR 0 3
60697: PUSH
60698: LD_INT 1
60700: PUSH
60701: LD_INT 2
60703: PUSH
60704: LD_INT 3
60706: PUSH
60707: LD_INT 4
60709: PUSH
60710: LD_INT 11
60712: PUSH
60713: EMPTY
60714: LIST
60715: LIST
60716: LIST
60717: LIST
60718: LIST
60719: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60720: LD_ADDR_EXP 124
60724: PUSH
60725: LD_EXP 124
60729: PPUSH
60730: LD_VAR 0 1
60734: PPUSH
60735: LD_EXP 124
60739: PUSH
60740: LD_VAR 0 1
60744: ARRAY
60745: PUSH
60746: LD_VAR 0 3
60750: DIFF
60751: PPUSH
60752: CALL_OW 1
60756: ST_TO_ADDR
// end ;
60757: LD_VAR 0 2
60761: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60762: LD_INT 0
60764: PPUSH
// result := mc_vehicles [ base ] ;
60765: LD_ADDR_VAR 0 3
60769: PUSH
60770: LD_EXP 116
60774: PUSH
60775: LD_VAR 0 1
60779: ARRAY
60780: ST_TO_ADDR
// if onlyCombat then
60781: LD_VAR 0 2
60785: IFFALSE 60957
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60787: LD_ADDR_VAR 0 3
60791: PUSH
60792: LD_VAR 0 3
60796: PUSH
60797: LD_VAR 0 3
60801: PPUSH
60802: LD_INT 2
60804: PUSH
60805: LD_INT 34
60807: PUSH
60808: LD_INT 12
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PUSH
60815: LD_INT 34
60817: PUSH
60818: LD_INT 51
60820: PUSH
60821: EMPTY
60822: LIST
60823: LIST
60824: PUSH
60825: LD_INT 34
60827: PUSH
60828: LD_INT 89
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PUSH
60835: LD_INT 34
60837: PUSH
60838: LD_INT 32
60840: PUSH
60841: EMPTY
60842: LIST
60843: LIST
60844: PUSH
60845: LD_INT 34
60847: PUSH
60848: LD_INT 13
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PUSH
60855: LD_INT 34
60857: PUSH
60858: LD_INT 52
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: PUSH
60865: LD_INT 34
60867: PUSH
60868: LD_INT 88
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PUSH
60875: LD_INT 34
60877: PUSH
60878: LD_INT 14
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PUSH
60885: LD_INT 34
60887: PUSH
60888: LD_INT 53
60890: PUSH
60891: EMPTY
60892: LIST
60893: LIST
60894: PUSH
60895: LD_INT 34
60897: PUSH
60898: LD_INT 98
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PUSH
60905: LD_INT 34
60907: PUSH
60908: LD_INT 31
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 34
60917: PUSH
60918: LD_INT 48
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 34
60927: PUSH
60928: LD_INT 8
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: EMPTY
60936: LIST
60937: LIST
60938: LIST
60939: LIST
60940: LIST
60941: LIST
60942: LIST
60943: LIST
60944: LIST
60945: LIST
60946: LIST
60947: LIST
60948: LIST
60949: LIST
60950: PPUSH
60951: CALL_OW 72
60955: DIFF
60956: ST_TO_ADDR
// end ; end_of_file
60957: LD_VAR 0 3
60961: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60962: LD_INT 0
60964: PPUSH
60965: PPUSH
60966: PPUSH
// if not mc_bases or not skirmish then
60967: LD_EXP 97
60971: NOT
60972: PUSH
60973: LD_EXP 95
60977: NOT
60978: OR
60979: IFFALSE 60983
// exit ;
60981: GO 61148
// for i = 1 to mc_bases do
60983: LD_ADDR_VAR 0 4
60987: PUSH
60988: DOUBLE
60989: LD_INT 1
60991: DEC
60992: ST_TO_ADDR
60993: LD_EXP 97
60997: PUSH
60998: FOR_TO
60999: IFFALSE 61146
// begin if sci in mc_bases [ i ] then
61001: LD_VAR 0 2
61005: PUSH
61006: LD_EXP 97
61010: PUSH
61011: LD_VAR 0 4
61015: ARRAY
61016: IN
61017: IFFALSE 61144
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61019: LD_ADDR_EXP 126
61023: PUSH
61024: LD_EXP 126
61028: PPUSH
61029: LD_VAR 0 4
61033: PUSH
61034: LD_EXP 126
61038: PUSH
61039: LD_VAR 0 4
61043: ARRAY
61044: PUSH
61045: LD_INT 1
61047: PLUS
61048: PUSH
61049: EMPTY
61050: LIST
61051: LIST
61052: PPUSH
61053: LD_VAR 0 1
61057: PPUSH
61058: CALL 70869 0 3
61062: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61063: LD_ADDR_VAR 0 5
61067: PUSH
61068: LD_EXP 97
61072: PUSH
61073: LD_VAR 0 4
61077: ARRAY
61078: PPUSH
61079: LD_INT 2
61081: PUSH
61082: LD_INT 30
61084: PUSH
61085: LD_INT 0
61087: PUSH
61088: EMPTY
61089: LIST
61090: LIST
61091: PUSH
61092: LD_INT 30
61094: PUSH
61095: LD_INT 1
61097: PUSH
61098: EMPTY
61099: LIST
61100: LIST
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: LIST
61106: PPUSH
61107: CALL_OW 72
61111: PPUSH
61112: LD_VAR 0 1
61116: PPUSH
61117: CALL_OW 74
61121: ST_TO_ADDR
// if tmp then
61122: LD_VAR 0 5
61126: IFFALSE 61142
// ComStandNearbyBuilding ( ape , tmp ) ;
61128: LD_VAR 0 1
61132: PPUSH
61133: LD_VAR 0 5
61137: PPUSH
61138: CALL 67296 0 2
// break ;
61142: GO 61146
// end ; end ;
61144: GO 60998
61146: POP
61147: POP
// end ;
61148: LD_VAR 0 3
61152: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61153: LD_INT 0
61155: PPUSH
61156: PPUSH
61157: PPUSH
// if not mc_bases or not skirmish then
61158: LD_EXP 97
61162: NOT
61163: PUSH
61164: LD_EXP 95
61168: NOT
61169: OR
61170: IFFALSE 61174
// exit ;
61172: GO 61263
// for i = 1 to mc_bases do
61174: LD_ADDR_VAR 0 4
61178: PUSH
61179: DOUBLE
61180: LD_INT 1
61182: DEC
61183: ST_TO_ADDR
61184: LD_EXP 97
61188: PUSH
61189: FOR_TO
61190: IFFALSE 61261
// begin if building in mc_busy_turret_list [ i ] then
61192: LD_VAR 0 1
61196: PUSH
61197: LD_EXP 107
61201: PUSH
61202: LD_VAR 0 4
61206: ARRAY
61207: IN
61208: IFFALSE 61259
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61210: LD_ADDR_VAR 0 5
61214: PUSH
61215: LD_EXP 107
61219: PUSH
61220: LD_VAR 0 4
61224: ARRAY
61225: PUSH
61226: LD_VAR 0 1
61230: DIFF
61231: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61232: LD_ADDR_EXP 107
61236: PUSH
61237: LD_EXP 107
61241: PPUSH
61242: LD_VAR 0 4
61246: PPUSH
61247: LD_VAR 0 5
61251: PPUSH
61252: CALL_OW 1
61256: ST_TO_ADDR
// break ;
61257: GO 61261
// end ; end ;
61259: GO 61189
61261: POP
61262: POP
// end ;
61263: LD_VAR 0 3
61267: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61268: LD_INT 0
61270: PPUSH
61271: PPUSH
61272: PPUSH
// if not mc_bases or not skirmish then
61273: LD_EXP 97
61277: NOT
61278: PUSH
61279: LD_EXP 95
61283: NOT
61284: OR
61285: IFFALSE 61289
// exit ;
61287: GO 61488
// for i = 1 to mc_bases do
61289: LD_ADDR_VAR 0 5
61293: PUSH
61294: DOUBLE
61295: LD_INT 1
61297: DEC
61298: ST_TO_ADDR
61299: LD_EXP 97
61303: PUSH
61304: FOR_TO
61305: IFFALSE 61486
// if building in mc_bases [ i ] then
61307: LD_VAR 0 1
61311: PUSH
61312: LD_EXP 97
61316: PUSH
61317: LD_VAR 0 5
61321: ARRAY
61322: IN
61323: IFFALSE 61484
// begin tmp := mc_bases [ i ] diff building ;
61325: LD_ADDR_VAR 0 6
61329: PUSH
61330: LD_EXP 97
61334: PUSH
61335: LD_VAR 0 5
61339: ARRAY
61340: PUSH
61341: LD_VAR 0 1
61345: DIFF
61346: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61347: LD_ADDR_EXP 97
61351: PUSH
61352: LD_EXP 97
61356: PPUSH
61357: LD_VAR 0 5
61361: PPUSH
61362: LD_VAR 0 6
61366: PPUSH
61367: CALL_OW 1
61371: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61372: LD_VAR 0 1
61376: PUSH
61377: LD_EXP 105
61381: PUSH
61382: LD_VAR 0 5
61386: ARRAY
61387: IN
61388: IFFALSE 61427
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61390: LD_ADDR_EXP 105
61394: PUSH
61395: LD_EXP 105
61399: PPUSH
61400: LD_VAR 0 5
61404: PPUSH
61405: LD_EXP 105
61409: PUSH
61410: LD_VAR 0 5
61414: ARRAY
61415: PUSH
61416: LD_VAR 0 1
61420: DIFF
61421: PPUSH
61422: CALL_OW 1
61426: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61427: LD_VAR 0 1
61431: PUSH
61432: LD_EXP 106
61436: PUSH
61437: LD_VAR 0 5
61441: ARRAY
61442: IN
61443: IFFALSE 61482
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61445: LD_ADDR_EXP 106
61449: PUSH
61450: LD_EXP 106
61454: PPUSH
61455: LD_VAR 0 5
61459: PPUSH
61460: LD_EXP 106
61464: PUSH
61465: LD_VAR 0 5
61469: ARRAY
61470: PUSH
61471: LD_VAR 0 1
61475: DIFF
61476: PPUSH
61477: CALL_OW 1
61481: ST_TO_ADDR
// break ;
61482: GO 61486
// end ;
61484: GO 61304
61486: POP
61487: POP
// end ;
61488: LD_VAR 0 4
61492: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61493: LD_INT 0
61495: PPUSH
61496: PPUSH
61497: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61498: LD_EXP 97
61502: NOT
61503: PUSH
61504: LD_EXP 95
61508: NOT
61509: OR
61510: PUSH
61511: LD_VAR 0 3
61515: PUSH
61516: LD_EXP 123
61520: IN
61521: NOT
61522: OR
61523: IFFALSE 61527
// exit ;
61525: GO 61650
// for i = 1 to mc_vehicles do
61527: LD_ADDR_VAR 0 6
61531: PUSH
61532: DOUBLE
61533: LD_INT 1
61535: DEC
61536: ST_TO_ADDR
61537: LD_EXP 116
61541: PUSH
61542: FOR_TO
61543: IFFALSE 61648
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61545: LD_VAR 0 2
61549: PUSH
61550: LD_EXP 116
61554: PUSH
61555: LD_VAR 0 6
61559: ARRAY
61560: IN
61561: PUSH
61562: LD_VAR 0 1
61566: PUSH
61567: LD_EXP 116
61571: PUSH
61572: LD_VAR 0 6
61576: ARRAY
61577: IN
61578: OR
61579: IFFALSE 61646
// begin tmp := mc_vehicles [ i ] diff old ;
61581: LD_ADDR_VAR 0 7
61585: PUSH
61586: LD_EXP 116
61590: PUSH
61591: LD_VAR 0 6
61595: ARRAY
61596: PUSH
61597: LD_VAR 0 2
61601: DIFF
61602: ST_TO_ADDR
// tmp := tmp diff new ;
61603: LD_ADDR_VAR 0 7
61607: PUSH
61608: LD_VAR 0 7
61612: PUSH
61613: LD_VAR 0 1
61617: DIFF
61618: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61619: LD_ADDR_EXP 116
61623: PUSH
61624: LD_EXP 116
61628: PPUSH
61629: LD_VAR 0 6
61633: PPUSH
61634: LD_VAR 0 7
61638: PPUSH
61639: CALL_OW 1
61643: ST_TO_ADDR
// break ;
61644: GO 61648
// end ;
61646: GO 61542
61648: POP
61649: POP
// end ;
61650: LD_VAR 0 5
61654: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61655: LD_INT 0
61657: PPUSH
61658: PPUSH
61659: PPUSH
61660: PPUSH
// if not mc_bases or not skirmish then
61661: LD_EXP 97
61665: NOT
61666: PUSH
61667: LD_EXP 95
61671: NOT
61672: OR
61673: IFFALSE 61677
// exit ;
61675: GO 62059
// side := GetSide ( vehicle ) ;
61677: LD_ADDR_VAR 0 5
61681: PUSH
61682: LD_VAR 0 1
61686: PPUSH
61687: CALL_OW 255
61691: ST_TO_ADDR
// for i = 1 to mc_bases do
61692: LD_ADDR_VAR 0 4
61696: PUSH
61697: DOUBLE
61698: LD_INT 1
61700: DEC
61701: ST_TO_ADDR
61702: LD_EXP 97
61706: PUSH
61707: FOR_TO
61708: IFFALSE 62057
// begin if factory in mc_bases [ i ] then
61710: LD_VAR 0 2
61714: PUSH
61715: LD_EXP 97
61719: PUSH
61720: LD_VAR 0 4
61724: ARRAY
61725: IN
61726: IFFALSE 62055
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61728: LD_EXP 119
61732: PUSH
61733: LD_VAR 0 4
61737: ARRAY
61738: PUSH
61739: LD_EXP 108
61743: PUSH
61744: LD_VAR 0 4
61748: ARRAY
61749: LESS
61750: PUSH
61751: LD_VAR 0 1
61755: PPUSH
61756: CALL_OW 264
61760: PUSH
61761: LD_INT 31
61763: PUSH
61764: LD_INT 32
61766: PUSH
61767: LD_INT 51
61769: PUSH
61770: LD_INT 89
61772: PUSH
61773: LD_INT 12
61775: PUSH
61776: LD_INT 30
61778: PUSH
61779: LD_INT 98
61781: PUSH
61782: LD_INT 11
61784: PUSH
61785: LD_INT 53
61787: PUSH
61788: LD_INT 14
61790: PUSH
61791: LD_INT 91
61793: PUSH
61794: LD_INT 29
61796: PUSH
61797: LD_INT 99
61799: PUSH
61800: LD_INT 13
61802: PUSH
61803: LD_INT 52
61805: PUSH
61806: LD_INT 88
61808: PUSH
61809: LD_INT 48
61811: PUSH
61812: LD_INT 8
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: LIST
61827: LIST
61828: LIST
61829: LIST
61830: LIST
61831: LIST
61832: LIST
61833: LIST
61834: IN
61835: NOT
61836: AND
61837: IFFALSE 61885
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61839: LD_ADDR_EXP 119
61843: PUSH
61844: LD_EXP 119
61848: PPUSH
61849: LD_VAR 0 4
61853: PUSH
61854: LD_EXP 119
61858: PUSH
61859: LD_VAR 0 4
61863: ARRAY
61864: PUSH
61865: LD_INT 1
61867: PLUS
61868: PUSH
61869: EMPTY
61870: LIST
61871: LIST
61872: PPUSH
61873: LD_VAR 0 1
61877: PPUSH
61878: CALL 70869 0 3
61882: ST_TO_ADDR
61883: GO 61929
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61885: LD_ADDR_EXP 116
61889: PUSH
61890: LD_EXP 116
61894: PPUSH
61895: LD_VAR 0 4
61899: PUSH
61900: LD_EXP 116
61904: PUSH
61905: LD_VAR 0 4
61909: ARRAY
61910: PUSH
61911: LD_INT 1
61913: PLUS
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PPUSH
61919: LD_VAR 0 1
61923: PPUSH
61924: CALL 70869 0 3
61928: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61929: LD_VAR 0 1
61933: PPUSH
61934: CALL_OW 263
61938: PUSH
61939: LD_INT 2
61941: EQUAL
61942: IFFALSE 61971
// begin repeat wait ( 0 0$3 ) ;
61944: LD_INT 105
61946: PPUSH
61947: CALL_OW 67
// Connect ( vehicle ) ;
61951: LD_VAR 0 1
61955: PPUSH
61956: CALL 73838 0 1
// until IsControledBy ( vehicle ) ;
61960: LD_VAR 0 1
61964: PPUSH
61965: CALL_OW 312
61969: IFFALSE 61944
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61971: LD_VAR 0 1
61975: PPUSH
61976: LD_EXP 121
61980: PUSH
61981: LD_VAR 0 4
61985: ARRAY
61986: PPUSH
61987: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61991: LD_VAR 0 1
61995: PPUSH
61996: CALL_OW 263
62000: PUSH
62001: LD_INT 1
62003: NONEQUAL
62004: IFFALSE 62008
// break ;
62006: GO 62057
// repeat wait ( 0 0$1 ) ;
62008: LD_INT 35
62010: PPUSH
62011: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62015: LD_VAR 0 1
62019: PPUSH
62020: LD_EXP 121
62024: PUSH
62025: LD_VAR 0 4
62029: ARRAY
62030: PPUSH
62031: CALL_OW 308
62035: IFFALSE 62008
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62037: LD_VAR 0 1
62041: PPUSH
62042: CALL_OW 311
62046: PPUSH
62047: CALL_OW 121
// exit ;
62051: POP
62052: POP
62053: GO 62059
// end ; end ;
62055: GO 61707
62057: POP
62058: POP
// end ;
62059: LD_VAR 0 3
62063: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62064: LD_INT 0
62066: PPUSH
62067: PPUSH
62068: PPUSH
62069: PPUSH
// if not mc_bases or not skirmish then
62070: LD_EXP 97
62074: NOT
62075: PUSH
62076: LD_EXP 95
62080: NOT
62081: OR
62082: IFFALSE 62086
// exit ;
62084: GO 62439
// repeat wait ( 0 0$1 ) ;
62086: LD_INT 35
62088: PPUSH
62089: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62093: LD_VAR 0 2
62097: PPUSH
62098: LD_VAR 0 3
62102: PPUSH
62103: CALL_OW 284
62107: IFFALSE 62086
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62109: LD_VAR 0 2
62113: PPUSH
62114: LD_VAR 0 3
62118: PPUSH
62119: CALL_OW 283
62123: PUSH
62124: LD_INT 4
62126: EQUAL
62127: IFFALSE 62131
// exit ;
62129: GO 62439
// for i = 1 to mc_bases do
62131: LD_ADDR_VAR 0 7
62135: PUSH
62136: DOUBLE
62137: LD_INT 1
62139: DEC
62140: ST_TO_ADDR
62141: LD_EXP 97
62145: PUSH
62146: FOR_TO
62147: IFFALSE 62437
// begin if mc_crates_area [ i ] then
62149: LD_EXP 115
62153: PUSH
62154: LD_VAR 0 7
62158: ARRAY
62159: IFFALSE 62270
// for j in mc_crates_area [ i ] do
62161: LD_ADDR_VAR 0 8
62165: PUSH
62166: LD_EXP 115
62170: PUSH
62171: LD_VAR 0 7
62175: ARRAY
62176: PUSH
62177: FOR_IN
62178: IFFALSE 62268
// if InArea ( x , y , j ) then
62180: LD_VAR 0 2
62184: PPUSH
62185: LD_VAR 0 3
62189: PPUSH
62190: LD_VAR 0 8
62194: PPUSH
62195: CALL_OW 309
62199: IFFALSE 62266
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62201: LD_ADDR_EXP 113
62205: PUSH
62206: LD_EXP 113
62210: PPUSH
62211: LD_VAR 0 7
62215: PUSH
62216: LD_EXP 113
62220: PUSH
62221: LD_VAR 0 7
62225: ARRAY
62226: PUSH
62227: LD_INT 1
62229: PLUS
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PPUSH
62235: LD_VAR 0 4
62239: PUSH
62240: LD_VAR 0 2
62244: PUSH
62245: LD_VAR 0 3
62249: PUSH
62250: EMPTY
62251: LIST
62252: LIST
62253: LIST
62254: PPUSH
62255: CALL 70869 0 3
62259: ST_TO_ADDR
// exit ;
62260: POP
62261: POP
62262: POP
62263: POP
62264: GO 62439
// end ;
62266: GO 62177
62268: POP
62269: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62270: LD_ADDR_VAR 0 9
62274: PUSH
62275: LD_EXP 97
62279: PUSH
62280: LD_VAR 0 7
62284: ARRAY
62285: PPUSH
62286: LD_INT 2
62288: PUSH
62289: LD_INT 30
62291: PUSH
62292: LD_INT 0
62294: PUSH
62295: EMPTY
62296: LIST
62297: LIST
62298: PUSH
62299: LD_INT 30
62301: PUSH
62302: LD_INT 1
62304: PUSH
62305: EMPTY
62306: LIST
62307: LIST
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: LIST
62313: PPUSH
62314: CALL_OW 72
62318: ST_TO_ADDR
// if not depot then
62319: LD_VAR 0 9
62323: NOT
62324: IFFALSE 62328
// continue ;
62326: GO 62146
// for j in depot do
62328: LD_ADDR_VAR 0 8
62332: PUSH
62333: LD_VAR 0 9
62337: PUSH
62338: FOR_IN
62339: IFFALSE 62433
// if GetDistUnitXY ( j , x , y ) < 30 then
62341: LD_VAR 0 8
62345: PPUSH
62346: LD_VAR 0 2
62350: PPUSH
62351: LD_VAR 0 3
62355: PPUSH
62356: CALL_OW 297
62360: PUSH
62361: LD_INT 30
62363: LESS
62364: IFFALSE 62431
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62366: LD_ADDR_EXP 113
62370: PUSH
62371: LD_EXP 113
62375: PPUSH
62376: LD_VAR 0 7
62380: PUSH
62381: LD_EXP 113
62385: PUSH
62386: LD_VAR 0 7
62390: ARRAY
62391: PUSH
62392: LD_INT 1
62394: PLUS
62395: PUSH
62396: EMPTY
62397: LIST
62398: LIST
62399: PPUSH
62400: LD_VAR 0 4
62404: PUSH
62405: LD_VAR 0 2
62409: PUSH
62410: LD_VAR 0 3
62414: PUSH
62415: EMPTY
62416: LIST
62417: LIST
62418: LIST
62419: PPUSH
62420: CALL 70869 0 3
62424: ST_TO_ADDR
// exit ;
62425: POP
62426: POP
62427: POP
62428: POP
62429: GO 62439
// end ;
62431: GO 62338
62433: POP
62434: POP
// end ;
62435: GO 62146
62437: POP
62438: POP
// end ;
62439: LD_VAR 0 6
62443: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62444: LD_INT 0
62446: PPUSH
62447: PPUSH
62448: PPUSH
62449: PPUSH
// if not mc_bases or not skirmish then
62450: LD_EXP 97
62454: NOT
62455: PUSH
62456: LD_EXP 95
62460: NOT
62461: OR
62462: IFFALSE 62466
// exit ;
62464: GO 62743
// side := GetSide ( lab ) ;
62466: LD_ADDR_VAR 0 4
62470: PUSH
62471: LD_VAR 0 2
62475: PPUSH
62476: CALL_OW 255
62480: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62481: LD_VAR 0 4
62485: PUSH
62486: LD_EXP 123
62490: IN
62491: NOT
62492: PUSH
62493: LD_EXP 124
62497: NOT
62498: OR
62499: PUSH
62500: LD_EXP 97
62504: NOT
62505: OR
62506: IFFALSE 62510
// exit ;
62508: GO 62743
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62510: LD_ADDR_EXP 124
62514: PUSH
62515: LD_EXP 124
62519: PPUSH
62520: LD_VAR 0 4
62524: PPUSH
62525: LD_EXP 124
62529: PUSH
62530: LD_VAR 0 4
62534: ARRAY
62535: PUSH
62536: LD_VAR 0 1
62540: DIFF
62541: PPUSH
62542: CALL_OW 1
62546: ST_TO_ADDR
// for i = 1 to mc_bases do
62547: LD_ADDR_VAR 0 5
62551: PUSH
62552: DOUBLE
62553: LD_INT 1
62555: DEC
62556: ST_TO_ADDR
62557: LD_EXP 97
62561: PUSH
62562: FOR_TO
62563: IFFALSE 62741
// begin if lab in mc_bases [ i ] then
62565: LD_VAR 0 2
62569: PUSH
62570: LD_EXP 97
62574: PUSH
62575: LD_VAR 0 5
62579: ARRAY
62580: IN
62581: IFFALSE 62739
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62583: LD_VAR 0 1
62587: PUSH
62588: LD_INT 11
62590: PUSH
62591: LD_INT 4
62593: PUSH
62594: LD_INT 3
62596: PUSH
62597: LD_INT 2
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: LIST
62604: LIST
62605: IN
62606: PUSH
62607: LD_EXP 127
62611: PUSH
62612: LD_VAR 0 5
62616: ARRAY
62617: AND
62618: IFFALSE 62739
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62620: LD_ADDR_VAR 0 6
62624: PUSH
62625: LD_EXP 127
62629: PUSH
62630: LD_VAR 0 5
62634: ARRAY
62635: PUSH
62636: LD_INT 1
62638: ARRAY
62639: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62640: LD_ADDR_EXP 127
62644: PUSH
62645: LD_EXP 127
62649: PPUSH
62650: LD_VAR 0 5
62654: PPUSH
62655: EMPTY
62656: PPUSH
62657: CALL_OW 1
62661: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62662: LD_VAR 0 6
62666: PPUSH
62667: LD_INT 0
62669: PPUSH
62670: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62674: LD_VAR 0 6
62678: PPUSH
62679: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62683: LD_ADDR_EXP 126
62687: PUSH
62688: LD_EXP 126
62692: PPUSH
62693: LD_VAR 0 5
62697: PPUSH
62698: LD_EXP 126
62702: PUSH
62703: LD_VAR 0 5
62707: ARRAY
62708: PPUSH
62709: LD_INT 1
62711: PPUSH
62712: LD_VAR 0 6
62716: PPUSH
62717: CALL_OW 2
62721: PPUSH
62722: CALL_OW 1
62726: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62727: LD_VAR 0 5
62731: PPUSH
62732: LD_INT 112
62734: PPUSH
62735: CALL 39282 0 2
// end ; end ; end ;
62739: GO 62562
62741: POP
62742: POP
// end ;
62743: LD_VAR 0 3
62747: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62748: LD_INT 0
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
// if not mc_bases or not skirmish then
62758: LD_EXP 97
62762: NOT
62763: PUSH
62764: LD_EXP 95
62768: NOT
62769: OR
62770: IFFALSE 62774
// exit ;
62772: GO 64143
// for i = 1 to mc_bases do
62774: LD_ADDR_VAR 0 3
62778: PUSH
62779: DOUBLE
62780: LD_INT 1
62782: DEC
62783: ST_TO_ADDR
62784: LD_EXP 97
62788: PUSH
62789: FOR_TO
62790: IFFALSE 64141
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62792: LD_VAR 0 1
62796: PUSH
62797: LD_EXP 97
62801: PUSH
62802: LD_VAR 0 3
62806: ARRAY
62807: IN
62808: PUSH
62809: LD_VAR 0 1
62813: PUSH
62814: LD_EXP 104
62818: PUSH
62819: LD_VAR 0 3
62823: ARRAY
62824: IN
62825: OR
62826: PUSH
62827: LD_VAR 0 1
62831: PUSH
62832: LD_EXP 119
62836: PUSH
62837: LD_VAR 0 3
62841: ARRAY
62842: IN
62843: OR
62844: PUSH
62845: LD_VAR 0 1
62849: PUSH
62850: LD_EXP 116
62854: PUSH
62855: LD_VAR 0 3
62859: ARRAY
62860: IN
62861: OR
62862: PUSH
62863: LD_VAR 0 1
62867: PUSH
62868: LD_EXP 126
62872: PUSH
62873: LD_VAR 0 3
62877: ARRAY
62878: IN
62879: OR
62880: PUSH
62881: LD_VAR 0 1
62885: PUSH
62886: LD_EXP 127
62890: PUSH
62891: LD_VAR 0 3
62895: ARRAY
62896: IN
62897: OR
62898: IFFALSE 64139
// begin if un in mc_ape [ i ] then
62900: LD_VAR 0 1
62904: PUSH
62905: LD_EXP 126
62909: PUSH
62910: LD_VAR 0 3
62914: ARRAY
62915: IN
62916: IFFALSE 62955
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62918: LD_ADDR_EXP 126
62922: PUSH
62923: LD_EXP 126
62927: PPUSH
62928: LD_VAR 0 3
62932: PPUSH
62933: LD_EXP 126
62937: PUSH
62938: LD_VAR 0 3
62942: ARRAY
62943: PUSH
62944: LD_VAR 0 1
62948: DIFF
62949: PPUSH
62950: CALL_OW 1
62954: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62955: LD_VAR 0 1
62959: PUSH
62960: LD_EXP 127
62964: PUSH
62965: LD_VAR 0 3
62969: ARRAY
62970: IN
62971: IFFALSE 62995
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62973: LD_ADDR_EXP 127
62977: PUSH
62978: LD_EXP 127
62982: PPUSH
62983: LD_VAR 0 3
62987: PPUSH
62988: EMPTY
62989: PPUSH
62990: CALL_OW 1
62994: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62995: LD_VAR 0 1
62999: PPUSH
63000: CALL_OW 247
63004: PUSH
63005: LD_INT 2
63007: EQUAL
63008: PUSH
63009: LD_VAR 0 1
63013: PPUSH
63014: CALL_OW 110
63018: PUSH
63019: LD_INT 20
63021: EQUAL
63022: PUSH
63023: LD_VAR 0 1
63027: PUSH
63028: LD_EXP 119
63032: PUSH
63033: LD_VAR 0 3
63037: ARRAY
63038: IN
63039: OR
63040: PUSH
63041: LD_VAR 0 1
63045: PPUSH
63046: CALL_OW 264
63050: PUSH
63051: LD_INT 12
63053: PUSH
63054: LD_INT 51
63056: PUSH
63057: LD_INT 89
63059: PUSH
63060: LD_INT 32
63062: PUSH
63063: LD_INT 13
63065: PUSH
63066: LD_INT 52
63068: PUSH
63069: LD_INT 31
63071: PUSH
63072: EMPTY
63073: LIST
63074: LIST
63075: LIST
63076: LIST
63077: LIST
63078: LIST
63079: LIST
63080: IN
63081: OR
63082: AND
63083: IFFALSE 63391
// begin if un in mc_defender [ i ] then
63085: LD_VAR 0 1
63089: PUSH
63090: LD_EXP 119
63094: PUSH
63095: LD_VAR 0 3
63099: ARRAY
63100: IN
63101: IFFALSE 63140
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63103: LD_ADDR_EXP 119
63107: PUSH
63108: LD_EXP 119
63112: PPUSH
63113: LD_VAR 0 3
63117: PPUSH
63118: LD_EXP 119
63122: PUSH
63123: LD_VAR 0 3
63127: ARRAY
63128: PUSH
63129: LD_VAR 0 1
63133: DIFF
63134: PPUSH
63135: CALL_OW 1
63139: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63140: LD_ADDR_VAR 0 8
63144: PUSH
63145: LD_VAR 0 3
63149: PPUSH
63150: LD_INT 3
63152: PPUSH
63153: CALL 59799 0 2
63157: ST_TO_ADDR
// if fac then
63158: LD_VAR 0 8
63162: IFFALSE 63391
// begin for j in fac do
63164: LD_ADDR_VAR 0 4
63168: PUSH
63169: LD_VAR 0 8
63173: PUSH
63174: FOR_IN
63175: IFFALSE 63389
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63177: LD_ADDR_VAR 0 9
63181: PUSH
63182: LD_VAR 0 8
63186: PPUSH
63187: LD_VAR 0 1
63191: PPUSH
63192: CALL_OW 265
63196: PPUSH
63197: LD_VAR 0 1
63201: PPUSH
63202: CALL_OW 262
63206: PPUSH
63207: LD_VAR 0 1
63211: PPUSH
63212: CALL_OW 263
63216: PPUSH
63217: LD_VAR 0 1
63221: PPUSH
63222: CALL_OW 264
63226: PPUSH
63227: CALL 68367 0 5
63231: ST_TO_ADDR
// if components then
63232: LD_VAR 0 9
63236: IFFALSE 63387
// begin if GetWeapon ( un ) = ar_control_tower then
63238: LD_VAR 0 1
63242: PPUSH
63243: CALL_OW 264
63247: PUSH
63248: LD_INT 31
63250: EQUAL
63251: IFFALSE 63368
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63253: LD_VAR 0 1
63257: PPUSH
63258: CALL_OW 311
63262: PPUSH
63263: LD_INT 0
63265: PPUSH
63266: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63270: LD_ADDR_EXP 137
63274: PUSH
63275: LD_EXP 137
63279: PPUSH
63280: LD_VAR 0 3
63284: PPUSH
63285: LD_EXP 137
63289: PUSH
63290: LD_VAR 0 3
63294: ARRAY
63295: PUSH
63296: LD_VAR 0 1
63300: PPUSH
63301: CALL_OW 311
63305: DIFF
63306: PPUSH
63307: CALL_OW 1
63311: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63312: LD_ADDR_VAR 0 7
63316: PUSH
63317: LD_EXP 118
63321: PUSH
63322: LD_VAR 0 3
63326: ARRAY
63327: PPUSH
63328: LD_INT 1
63330: PPUSH
63331: LD_VAR 0 9
63335: PPUSH
63336: CALL_OW 2
63340: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63341: LD_ADDR_EXP 118
63345: PUSH
63346: LD_EXP 118
63350: PPUSH
63351: LD_VAR 0 3
63355: PPUSH
63356: LD_VAR 0 7
63360: PPUSH
63361: CALL_OW 1
63365: ST_TO_ADDR
// end else
63366: GO 63385
// MC_InsertProduceList ( i , [ components ] ) ;
63368: LD_VAR 0 3
63372: PPUSH
63373: LD_VAR 0 9
63377: PUSH
63378: EMPTY
63379: LIST
63380: PPUSH
63381: CALL 59344 0 2
// break ;
63385: GO 63389
// end ; end ;
63387: GO 63174
63389: POP
63390: POP
// end ; end ; if GetType ( un ) = unit_building then
63391: LD_VAR 0 1
63395: PPUSH
63396: CALL_OW 247
63400: PUSH
63401: LD_INT 3
63403: EQUAL
63404: IFFALSE 63807
// begin btype := GetBType ( un ) ;
63406: LD_ADDR_VAR 0 5
63410: PUSH
63411: LD_VAR 0 1
63415: PPUSH
63416: CALL_OW 266
63420: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63421: LD_VAR 0 5
63425: PUSH
63426: LD_INT 29
63428: PUSH
63429: LD_INT 30
63431: PUSH
63432: EMPTY
63433: LIST
63434: LIST
63435: IN
63436: IFFALSE 63509
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63438: LD_VAR 0 1
63442: PPUSH
63443: CALL_OW 250
63447: PPUSH
63448: LD_VAR 0 1
63452: PPUSH
63453: CALL_OW 251
63457: PPUSH
63458: LD_VAR 0 1
63462: PPUSH
63463: CALL_OW 255
63467: PPUSH
63468: CALL_OW 440
63472: NOT
63473: IFFALSE 63509
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63475: LD_VAR 0 1
63479: PPUSH
63480: CALL_OW 250
63484: PPUSH
63485: LD_VAR 0 1
63489: PPUSH
63490: CALL_OW 251
63494: PPUSH
63495: LD_VAR 0 1
63499: PPUSH
63500: CALL_OW 255
63504: PPUSH
63505: CALL_OW 441
// end ; if btype = b_warehouse then
63509: LD_VAR 0 5
63513: PUSH
63514: LD_INT 1
63516: EQUAL
63517: IFFALSE 63535
// begin btype := b_depot ;
63519: LD_ADDR_VAR 0 5
63523: PUSH
63524: LD_INT 0
63526: ST_TO_ADDR
// pos := 1 ;
63527: LD_ADDR_VAR 0 6
63531: PUSH
63532: LD_INT 1
63534: ST_TO_ADDR
// end ; if btype = b_factory then
63535: LD_VAR 0 5
63539: PUSH
63540: LD_INT 3
63542: EQUAL
63543: IFFALSE 63561
// begin btype := b_workshop ;
63545: LD_ADDR_VAR 0 5
63549: PUSH
63550: LD_INT 2
63552: ST_TO_ADDR
// pos := 1 ;
63553: LD_ADDR_VAR 0 6
63557: PUSH
63558: LD_INT 1
63560: ST_TO_ADDR
// end ; if btype = b_barracks then
63561: LD_VAR 0 5
63565: PUSH
63566: LD_INT 5
63568: EQUAL
63569: IFFALSE 63579
// btype := b_armoury ;
63571: LD_ADDR_VAR 0 5
63575: PUSH
63576: LD_INT 4
63578: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63579: LD_VAR 0 5
63583: PUSH
63584: LD_INT 7
63586: PUSH
63587: LD_INT 8
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: IN
63594: IFFALSE 63604
// btype := b_lab ;
63596: LD_ADDR_VAR 0 5
63600: PUSH
63601: LD_INT 6
63603: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63604: LD_ADDR_EXP 102
63608: PUSH
63609: LD_EXP 102
63613: PPUSH
63614: LD_VAR 0 3
63618: PUSH
63619: LD_EXP 102
63623: PUSH
63624: LD_VAR 0 3
63628: ARRAY
63629: PUSH
63630: LD_INT 1
63632: PLUS
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: PPUSH
63638: LD_VAR 0 5
63642: PUSH
63643: LD_VAR 0 1
63647: PPUSH
63648: CALL_OW 250
63652: PUSH
63653: LD_VAR 0 1
63657: PPUSH
63658: CALL_OW 251
63662: PUSH
63663: LD_VAR 0 1
63667: PPUSH
63668: CALL_OW 254
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: PPUSH
63679: CALL 70869 0 3
63683: ST_TO_ADDR
// if pos = 1 then
63684: LD_VAR 0 6
63688: PUSH
63689: LD_INT 1
63691: EQUAL
63692: IFFALSE 63807
// begin tmp := mc_build_list [ i ] ;
63694: LD_ADDR_VAR 0 7
63698: PUSH
63699: LD_EXP 102
63703: PUSH
63704: LD_VAR 0 3
63708: ARRAY
63709: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63710: LD_VAR 0 7
63714: PPUSH
63715: LD_INT 2
63717: PUSH
63718: LD_INT 30
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 30
63730: PUSH
63731: LD_INT 1
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: LIST
63742: PPUSH
63743: CALL_OW 72
63747: IFFALSE 63757
// pos := 2 ;
63749: LD_ADDR_VAR 0 6
63753: PUSH
63754: LD_INT 2
63756: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63757: LD_ADDR_VAR 0 7
63761: PUSH
63762: LD_VAR 0 7
63766: PPUSH
63767: LD_VAR 0 6
63771: PPUSH
63772: LD_VAR 0 7
63776: PPUSH
63777: CALL 71195 0 3
63781: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63782: LD_ADDR_EXP 102
63786: PUSH
63787: LD_EXP 102
63791: PPUSH
63792: LD_VAR 0 3
63796: PPUSH
63797: LD_VAR 0 7
63801: PPUSH
63802: CALL_OW 1
63806: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63807: LD_VAR 0 1
63811: PUSH
63812: LD_EXP 97
63816: PUSH
63817: LD_VAR 0 3
63821: ARRAY
63822: IN
63823: IFFALSE 63862
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63825: LD_ADDR_EXP 97
63829: PUSH
63830: LD_EXP 97
63834: PPUSH
63835: LD_VAR 0 3
63839: PPUSH
63840: LD_EXP 97
63844: PUSH
63845: LD_VAR 0 3
63849: ARRAY
63850: PUSH
63851: LD_VAR 0 1
63855: DIFF
63856: PPUSH
63857: CALL_OW 1
63861: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63862: LD_VAR 0 1
63866: PUSH
63867: LD_EXP 104
63871: PUSH
63872: LD_VAR 0 3
63876: ARRAY
63877: IN
63878: IFFALSE 63917
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63880: LD_ADDR_EXP 104
63884: PUSH
63885: LD_EXP 104
63889: PPUSH
63890: LD_VAR 0 3
63894: PPUSH
63895: LD_EXP 104
63899: PUSH
63900: LD_VAR 0 3
63904: ARRAY
63905: PUSH
63906: LD_VAR 0 1
63910: DIFF
63911: PPUSH
63912: CALL_OW 1
63916: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63917: LD_VAR 0 1
63921: PUSH
63922: LD_EXP 116
63926: PUSH
63927: LD_VAR 0 3
63931: ARRAY
63932: IN
63933: IFFALSE 63972
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63935: LD_ADDR_EXP 116
63939: PUSH
63940: LD_EXP 116
63944: PPUSH
63945: LD_VAR 0 3
63949: PPUSH
63950: LD_EXP 116
63954: PUSH
63955: LD_VAR 0 3
63959: ARRAY
63960: PUSH
63961: LD_VAR 0 1
63965: DIFF
63966: PPUSH
63967: CALL_OW 1
63971: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63972: LD_VAR 0 1
63976: PUSH
63977: LD_EXP 119
63981: PUSH
63982: LD_VAR 0 3
63986: ARRAY
63987: IN
63988: IFFALSE 64027
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63990: LD_ADDR_EXP 119
63994: PUSH
63995: LD_EXP 119
63999: PPUSH
64000: LD_VAR 0 3
64004: PPUSH
64005: LD_EXP 119
64009: PUSH
64010: LD_VAR 0 3
64014: ARRAY
64015: PUSH
64016: LD_VAR 0 1
64020: DIFF
64021: PPUSH
64022: CALL_OW 1
64026: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64027: LD_VAR 0 1
64031: PUSH
64032: LD_EXP 106
64036: PUSH
64037: LD_VAR 0 3
64041: ARRAY
64042: IN
64043: IFFALSE 64082
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64045: LD_ADDR_EXP 106
64049: PUSH
64050: LD_EXP 106
64054: PPUSH
64055: LD_VAR 0 3
64059: PPUSH
64060: LD_EXP 106
64064: PUSH
64065: LD_VAR 0 3
64069: ARRAY
64070: PUSH
64071: LD_VAR 0 1
64075: DIFF
64076: PPUSH
64077: CALL_OW 1
64081: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64082: LD_VAR 0 1
64086: PUSH
64087: LD_EXP 105
64091: PUSH
64092: LD_VAR 0 3
64096: ARRAY
64097: IN
64098: IFFALSE 64137
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64100: LD_ADDR_EXP 105
64104: PUSH
64105: LD_EXP 105
64109: PPUSH
64110: LD_VAR 0 3
64114: PPUSH
64115: LD_EXP 105
64119: PUSH
64120: LD_VAR 0 3
64124: ARRAY
64125: PUSH
64126: LD_VAR 0 1
64130: DIFF
64131: PPUSH
64132: CALL_OW 1
64136: ST_TO_ADDR
// end ; break ;
64137: GO 64141
// end ;
64139: GO 62789
64141: POP
64142: POP
// end ;
64143: LD_VAR 0 2
64147: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64148: LD_INT 0
64150: PPUSH
64151: PPUSH
64152: PPUSH
// if not mc_bases or not skirmish then
64153: LD_EXP 97
64157: NOT
64158: PUSH
64159: LD_EXP 95
64163: NOT
64164: OR
64165: IFFALSE 64169
// exit ;
64167: GO 64384
// for i = 1 to mc_bases do
64169: LD_ADDR_VAR 0 3
64173: PUSH
64174: DOUBLE
64175: LD_INT 1
64177: DEC
64178: ST_TO_ADDR
64179: LD_EXP 97
64183: PUSH
64184: FOR_TO
64185: IFFALSE 64382
// begin if building in mc_construct_list [ i ] then
64187: LD_VAR 0 1
64191: PUSH
64192: LD_EXP 104
64196: PUSH
64197: LD_VAR 0 3
64201: ARRAY
64202: IN
64203: IFFALSE 64380
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64205: LD_ADDR_EXP 104
64209: PUSH
64210: LD_EXP 104
64214: PPUSH
64215: LD_VAR 0 3
64219: PPUSH
64220: LD_EXP 104
64224: PUSH
64225: LD_VAR 0 3
64229: ARRAY
64230: PUSH
64231: LD_VAR 0 1
64235: DIFF
64236: PPUSH
64237: CALL_OW 1
64241: ST_TO_ADDR
// if building in mc_lab [ i ] then
64242: LD_VAR 0 1
64246: PUSH
64247: LD_EXP 130
64251: PUSH
64252: LD_VAR 0 3
64256: ARRAY
64257: IN
64258: IFFALSE 64313
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64260: LD_ADDR_EXP 131
64264: PUSH
64265: LD_EXP 131
64269: PPUSH
64270: LD_VAR 0 3
64274: PPUSH
64275: LD_EXP 131
64279: PUSH
64280: LD_VAR 0 3
64284: ARRAY
64285: PPUSH
64286: LD_INT 1
64288: PPUSH
64289: LD_EXP 131
64293: PUSH
64294: LD_VAR 0 3
64298: ARRAY
64299: PPUSH
64300: LD_INT 0
64302: PPUSH
64303: CALL 70287 0 4
64307: PPUSH
64308: CALL_OW 1
64312: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64313: LD_VAR 0 1
64317: PUSH
64318: LD_EXP 97
64322: PUSH
64323: LD_VAR 0 3
64327: ARRAY
64328: IN
64329: NOT
64330: IFFALSE 64376
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64332: LD_ADDR_EXP 97
64336: PUSH
64337: LD_EXP 97
64341: PPUSH
64342: LD_VAR 0 3
64346: PUSH
64347: LD_EXP 97
64351: PUSH
64352: LD_VAR 0 3
64356: ARRAY
64357: PUSH
64358: LD_INT 1
64360: PLUS
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: PPUSH
64366: LD_VAR 0 1
64370: PPUSH
64371: CALL 70869 0 3
64375: ST_TO_ADDR
// exit ;
64376: POP
64377: POP
64378: GO 64384
// end ; end ;
64380: GO 64184
64382: POP
64383: POP
// end ;
64384: LD_VAR 0 2
64388: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64389: LD_INT 0
64391: PPUSH
64392: PPUSH
64393: PPUSH
64394: PPUSH
64395: PPUSH
64396: PPUSH
64397: PPUSH
// if not mc_bases or not skirmish then
64398: LD_EXP 97
64402: NOT
64403: PUSH
64404: LD_EXP 95
64408: NOT
64409: OR
64410: IFFALSE 64414
// exit ;
64412: GO 65075
// for i = 1 to mc_bases do
64414: LD_ADDR_VAR 0 3
64418: PUSH
64419: DOUBLE
64420: LD_INT 1
64422: DEC
64423: ST_TO_ADDR
64424: LD_EXP 97
64428: PUSH
64429: FOR_TO
64430: IFFALSE 65073
// begin if building in mc_construct_list [ i ] then
64432: LD_VAR 0 1
64436: PUSH
64437: LD_EXP 104
64441: PUSH
64442: LD_VAR 0 3
64446: ARRAY
64447: IN
64448: IFFALSE 65071
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64450: LD_ADDR_EXP 104
64454: PUSH
64455: LD_EXP 104
64459: PPUSH
64460: LD_VAR 0 3
64464: PPUSH
64465: LD_EXP 104
64469: PUSH
64470: LD_VAR 0 3
64474: ARRAY
64475: PUSH
64476: LD_VAR 0 1
64480: DIFF
64481: PPUSH
64482: CALL_OW 1
64486: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64487: LD_ADDR_EXP 97
64491: PUSH
64492: LD_EXP 97
64496: PPUSH
64497: LD_VAR 0 3
64501: PUSH
64502: LD_EXP 97
64506: PUSH
64507: LD_VAR 0 3
64511: ARRAY
64512: PUSH
64513: LD_INT 1
64515: PLUS
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: PPUSH
64521: LD_VAR 0 1
64525: PPUSH
64526: CALL 70869 0 3
64530: ST_TO_ADDR
// btype := GetBType ( building ) ;
64531: LD_ADDR_VAR 0 5
64535: PUSH
64536: LD_VAR 0 1
64540: PPUSH
64541: CALL_OW 266
64545: ST_TO_ADDR
// side := GetSide ( building ) ;
64546: LD_ADDR_VAR 0 8
64550: PUSH
64551: LD_VAR 0 1
64555: PPUSH
64556: CALL_OW 255
64560: ST_TO_ADDR
// if btype = b_lab then
64561: LD_VAR 0 5
64565: PUSH
64566: LD_INT 6
64568: EQUAL
64569: IFFALSE 64619
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64571: LD_ADDR_EXP 130
64575: PUSH
64576: LD_EXP 130
64580: PPUSH
64581: LD_VAR 0 3
64585: PUSH
64586: LD_EXP 130
64590: PUSH
64591: LD_VAR 0 3
64595: ARRAY
64596: PUSH
64597: LD_INT 1
64599: PLUS
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PPUSH
64605: LD_VAR 0 1
64609: PPUSH
64610: CALL 70869 0 3
64614: ST_TO_ADDR
// exit ;
64615: POP
64616: POP
64617: GO 65075
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64619: LD_VAR 0 5
64623: PUSH
64624: LD_INT 0
64626: PUSH
64627: LD_INT 2
64629: PUSH
64630: LD_INT 4
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: LIST
64637: IN
64638: IFFALSE 64762
// begin if btype = b_armoury then
64640: LD_VAR 0 5
64644: PUSH
64645: LD_INT 4
64647: EQUAL
64648: IFFALSE 64658
// btype := b_barracks ;
64650: LD_ADDR_VAR 0 5
64654: PUSH
64655: LD_INT 5
64657: ST_TO_ADDR
// if btype = b_depot then
64658: LD_VAR 0 5
64662: PUSH
64663: LD_INT 0
64665: EQUAL
64666: IFFALSE 64676
// btype := b_warehouse ;
64668: LD_ADDR_VAR 0 5
64672: PUSH
64673: LD_INT 1
64675: ST_TO_ADDR
// if btype = b_workshop then
64676: LD_VAR 0 5
64680: PUSH
64681: LD_INT 2
64683: EQUAL
64684: IFFALSE 64694
// btype := b_factory ;
64686: LD_ADDR_VAR 0 5
64690: PUSH
64691: LD_INT 3
64693: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64694: LD_VAR 0 5
64698: PPUSH
64699: LD_VAR 0 8
64703: PPUSH
64704: CALL_OW 323
64708: PUSH
64709: LD_INT 1
64711: EQUAL
64712: IFFALSE 64758
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64714: LD_ADDR_EXP 129
64718: PUSH
64719: LD_EXP 129
64723: PPUSH
64724: LD_VAR 0 3
64728: PUSH
64729: LD_EXP 129
64733: PUSH
64734: LD_VAR 0 3
64738: ARRAY
64739: PUSH
64740: LD_INT 1
64742: PLUS
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PPUSH
64748: LD_VAR 0 1
64752: PPUSH
64753: CALL 70869 0 3
64757: ST_TO_ADDR
// exit ;
64758: POP
64759: POP
64760: GO 65075
// end ; if btype in [ b_bunker , b_turret ] then
64762: LD_VAR 0 5
64766: PUSH
64767: LD_INT 32
64769: PUSH
64770: LD_INT 33
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: IN
64777: IFFALSE 65067
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64779: LD_ADDR_EXP 105
64783: PUSH
64784: LD_EXP 105
64788: PPUSH
64789: LD_VAR 0 3
64793: PUSH
64794: LD_EXP 105
64798: PUSH
64799: LD_VAR 0 3
64803: ARRAY
64804: PUSH
64805: LD_INT 1
64807: PLUS
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PPUSH
64813: LD_VAR 0 1
64817: PPUSH
64818: CALL 70869 0 3
64822: ST_TO_ADDR
// if btype = b_bunker then
64823: LD_VAR 0 5
64827: PUSH
64828: LD_INT 32
64830: EQUAL
64831: IFFALSE 65067
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64833: LD_ADDR_EXP 106
64837: PUSH
64838: LD_EXP 106
64842: PPUSH
64843: LD_VAR 0 3
64847: PUSH
64848: LD_EXP 106
64852: PUSH
64853: LD_VAR 0 3
64857: ARRAY
64858: PUSH
64859: LD_INT 1
64861: PLUS
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PPUSH
64867: LD_VAR 0 1
64871: PPUSH
64872: CALL 70869 0 3
64876: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64877: LD_ADDR_VAR 0 6
64881: PUSH
64882: LD_EXP 97
64886: PUSH
64887: LD_VAR 0 3
64891: ARRAY
64892: PPUSH
64893: LD_INT 25
64895: PUSH
64896: LD_INT 1
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 3
64905: PUSH
64906: LD_INT 54
64908: PUSH
64909: EMPTY
64910: LIST
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: EMPTY
64917: LIST
64918: LIST
64919: PPUSH
64920: CALL_OW 72
64924: ST_TO_ADDR
// if tmp then
64925: LD_VAR 0 6
64929: IFFALSE 64935
// exit ;
64931: POP
64932: POP
64933: GO 65075
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64935: LD_ADDR_VAR 0 6
64939: PUSH
64940: LD_EXP 97
64944: PUSH
64945: LD_VAR 0 3
64949: ARRAY
64950: PPUSH
64951: LD_INT 2
64953: PUSH
64954: LD_INT 30
64956: PUSH
64957: LD_INT 4
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 30
64966: PUSH
64967: LD_INT 5
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: LIST
64978: PPUSH
64979: CALL_OW 72
64983: ST_TO_ADDR
// if not tmp then
64984: LD_VAR 0 6
64988: NOT
64989: IFFALSE 64995
// exit ;
64991: POP
64992: POP
64993: GO 65075
// for j in tmp do
64995: LD_ADDR_VAR 0 4
64999: PUSH
65000: LD_VAR 0 6
65004: PUSH
65005: FOR_IN
65006: IFFALSE 65065
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65008: LD_ADDR_VAR 0 7
65012: PUSH
65013: LD_VAR 0 4
65017: PPUSH
65018: CALL_OW 313
65022: PPUSH
65023: LD_INT 25
65025: PUSH
65026: LD_INT 1
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: PPUSH
65033: CALL_OW 72
65037: ST_TO_ADDR
// if units then
65038: LD_VAR 0 7
65042: IFFALSE 65063
// begin ComExitBuilding ( units [ 1 ] ) ;
65044: LD_VAR 0 7
65048: PUSH
65049: LD_INT 1
65051: ARRAY
65052: PPUSH
65053: CALL_OW 122
// exit ;
65057: POP
65058: POP
65059: POP
65060: POP
65061: GO 65075
// end ; end ;
65063: GO 65005
65065: POP
65066: POP
// end ; end ; exit ;
65067: POP
65068: POP
65069: GO 65075
// end ; end ;
65071: GO 64429
65073: POP
65074: POP
// end ;
65075: LD_VAR 0 2
65079: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65080: LD_INT 0
65082: PPUSH
65083: PPUSH
65084: PPUSH
65085: PPUSH
65086: PPUSH
65087: PPUSH
65088: PPUSH
// if not mc_bases or not skirmish then
65089: LD_EXP 97
65093: NOT
65094: PUSH
65095: LD_EXP 95
65099: NOT
65100: OR
65101: IFFALSE 65105
// exit ;
65103: GO 65370
// btype := GetBType ( building ) ;
65105: LD_ADDR_VAR 0 6
65109: PUSH
65110: LD_VAR 0 1
65114: PPUSH
65115: CALL_OW 266
65119: ST_TO_ADDR
// x := GetX ( building ) ;
65120: LD_ADDR_VAR 0 7
65124: PUSH
65125: LD_VAR 0 1
65129: PPUSH
65130: CALL_OW 250
65134: ST_TO_ADDR
// y := GetY ( building ) ;
65135: LD_ADDR_VAR 0 8
65139: PUSH
65140: LD_VAR 0 1
65144: PPUSH
65145: CALL_OW 251
65149: ST_TO_ADDR
// d := GetDir ( building ) ;
65150: LD_ADDR_VAR 0 9
65154: PUSH
65155: LD_VAR 0 1
65159: PPUSH
65160: CALL_OW 254
65164: ST_TO_ADDR
// for i = 1 to mc_bases do
65165: LD_ADDR_VAR 0 4
65169: PUSH
65170: DOUBLE
65171: LD_INT 1
65173: DEC
65174: ST_TO_ADDR
65175: LD_EXP 97
65179: PUSH
65180: FOR_TO
65181: IFFALSE 65368
// begin if not mc_build_list [ i ] then
65183: LD_EXP 102
65187: PUSH
65188: LD_VAR 0 4
65192: ARRAY
65193: NOT
65194: IFFALSE 65198
// continue ;
65196: GO 65180
// for j := 1 to mc_build_list [ i ] do
65198: LD_ADDR_VAR 0 5
65202: PUSH
65203: DOUBLE
65204: LD_INT 1
65206: DEC
65207: ST_TO_ADDR
65208: LD_EXP 102
65212: PUSH
65213: LD_VAR 0 4
65217: ARRAY
65218: PUSH
65219: FOR_TO
65220: IFFALSE 65364
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65222: LD_VAR 0 6
65226: PUSH
65227: LD_VAR 0 7
65231: PUSH
65232: LD_VAR 0 8
65236: PUSH
65237: LD_VAR 0 9
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: PPUSH
65248: LD_EXP 102
65252: PUSH
65253: LD_VAR 0 4
65257: ARRAY
65258: PUSH
65259: LD_VAR 0 5
65263: ARRAY
65264: PPUSH
65265: CALL 77049 0 2
65269: IFFALSE 65362
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65271: LD_ADDR_EXP 102
65275: PUSH
65276: LD_EXP 102
65280: PPUSH
65281: LD_VAR 0 4
65285: PPUSH
65286: LD_EXP 102
65290: PUSH
65291: LD_VAR 0 4
65295: ARRAY
65296: PPUSH
65297: LD_VAR 0 5
65301: PPUSH
65302: CALL_OW 3
65306: PPUSH
65307: CALL_OW 1
65311: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65312: LD_ADDR_EXP 104
65316: PUSH
65317: LD_EXP 104
65321: PPUSH
65322: LD_VAR 0 4
65326: PUSH
65327: LD_EXP 104
65331: PUSH
65332: LD_VAR 0 4
65336: ARRAY
65337: PUSH
65338: LD_INT 1
65340: PLUS
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: PPUSH
65346: LD_VAR 0 1
65350: PPUSH
65351: CALL 70869 0 3
65355: ST_TO_ADDR
// exit ;
65356: POP
65357: POP
65358: POP
65359: POP
65360: GO 65370
// end ;
65362: GO 65219
65364: POP
65365: POP
// end ;
65366: GO 65180
65368: POP
65369: POP
// end ;
65370: LD_VAR 0 3
65374: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65375: LD_INT 0
65377: PPUSH
65378: PPUSH
65379: PPUSH
// if not mc_bases or not skirmish then
65380: LD_EXP 97
65384: NOT
65385: PUSH
65386: LD_EXP 95
65390: NOT
65391: OR
65392: IFFALSE 65396
// exit ;
65394: GO 65586
// for i = 1 to mc_bases do
65396: LD_ADDR_VAR 0 4
65400: PUSH
65401: DOUBLE
65402: LD_INT 1
65404: DEC
65405: ST_TO_ADDR
65406: LD_EXP 97
65410: PUSH
65411: FOR_TO
65412: IFFALSE 65499
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65414: LD_VAR 0 1
65418: PUSH
65419: LD_EXP 105
65423: PUSH
65424: LD_VAR 0 4
65428: ARRAY
65429: IN
65430: PUSH
65431: LD_VAR 0 1
65435: PUSH
65436: LD_EXP 106
65440: PUSH
65441: LD_VAR 0 4
65445: ARRAY
65446: IN
65447: NOT
65448: AND
65449: IFFALSE 65497
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65451: LD_ADDR_EXP 106
65455: PUSH
65456: LD_EXP 106
65460: PPUSH
65461: LD_VAR 0 4
65465: PUSH
65466: LD_EXP 106
65470: PUSH
65471: LD_VAR 0 4
65475: ARRAY
65476: PUSH
65477: LD_INT 1
65479: PLUS
65480: PUSH
65481: EMPTY
65482: LIST
65483: LIST
65484: PPUSH
65485: LD_VAR 0 1
65489: PPUSH
65490: CALL 70869 0 3
65494: ST_TO_ADDR
// break ;
65495: GO 65499
// end ; end ;
65497: GO 65411
65499: POP
65500: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65501: LD_VAR 0 1
65505: PPUSH
65506: CALL_OW 257
65510: PUSH
65511: LD_EXP 123
65515: IN
65516: PUSH
65517: LD_VAR 0 1
65521: PPUSH
65522: CALL_OW 266
65526: PUSH
65527: LD_INT 5
65529: EQUAL
65530: AND
65531: PUSH
65532: LD_VAR 0 2
65536: PPUSH
65537: CALL_OW 110
65541: PUSH
65542: LD_INT 18
65544: NONEQUAL
65545: AND
65546: IFFALSE 65586
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65548: LD_VAR 0 2
65552: PPUSH
65553: CALL_OW 257
65557: PUSH
65558: LD_INT 5
65560: PUSH
65561: LD_INT 8
65563: PUSH
65564: LD_INT 9
65566: PUSH
65567: EMPTY
65568: LIST
65569: LIST
65570: LIST
65571: IN
65572: IFFALSE 65586
// SetClass ( unit , 1 ) ;
65574: LD_VAR 0 2
65578: PPUSH
65579: LD_INT 1
65581: PPUSH
65582: CALL_OW 336
// end ;
65586: LD_VAR 0 3
65590: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65591: LD_INT 0
65593: PPUSH
65594: PPUSH
// if not mc_bases or not skirmish then
65595: LD_EXP 97
65599: NOT
65600: PUSH
65601: LD_EXP 95
65605: NOT
65606: OR
65607: IFFALSE 65611
// exit ;
65609: GO 65727
// if GetLives ( abandoned_vehicle ) > 250 then
65611: LD_VAR 0 2
65615: PPUSH
65616: CALL_OW 256
65620: PUSH
65621: LD_INT 250
65623: GREATER
65624: IFFALSE 65628
// exit ;
65626: GO 65727
// for i = 1 to mc_bases do
65628: LD_ADDR_VAR 0 6
65632: PUSH
65633: DOUBLE
65634: LD_INT 1
65636: DEC
65637: ST_TO_ADDR
65638: LD_EXP 97
65642: PUSH
65643: FOR_TO
65644: IFFALSE 65725
// begin if driver in mc_bases [ i ] then
65646: LD_VAR 0 1
65650: PUSH
65651: LD_EXP 97
65655: PUSH
65656: LD_VAR 0 6
65660: ARRAY
65661: IN
65662: IFFALSE 65723
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65664: LD_VAR 0 1
65668: PPUSH
65669: LD_EXP 97
65673: PUSH
65674: LD_VAR 0 6
65678: ARRAY
65679: PPUSH
65680: LD_INT 2
65682: PUSH
65683: LD_INT 30
65685: PUSH
65686: LD_INT 0
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 30
65695: PUSH
65696: LD_INT 1
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: PUSH
65703: EMPTY
65704: LIST
65705: LIST
65706: LIST
65707: PPUSH
65708: CALL_OW 72
65712: PUSH
65713: LD_INT 1
65715: ARRAY
65716: PPUSH
65717: CALL 103985 0 2
// break ;
65721: GO 65725
// end ; end ;
65723: GO 65643
65725: POP
65726: POP
// end ; end_of_file
65727: LD_VAR 0 5
65731: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65732: LD_INT 0
65734: PPUSH
65735: PPUSH
// if exist_mode then
65736: LD_VAR 0 2
65740: IFFALSE 65765
// unit := CreateCharacter ( prefix & ident ) else
65742: LD_ADDR_VAR 0 5
65746: PUSH
65747: LD_VAR 0 3
65751: PUSH
65752: LD_VAR 0 1
65756: STR
65757: PPUSH
65758: CALL_OW 34
65762: ST_TO_ADDR
65763: GO 65780
// unit := NewCharacter ( ident ) ;
65765: LD_ADDR_VAR 0 5
65769: PUSH
65770: LD_VAR 0 1
65774: PPUSH
65775: CALL_OW 25
65779: ST_TO_ADDR
// result := unit ;
65780: LD_ADDR_VAR 0 4
65784: PUSH
65785: LD_VAR 0 5
65789: ST_TO_ADDR
// end ;
65790: LD_VAR 0 4
65794: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65795: LD_INT 0
65797: PPUSH
65798: PPUSH
// if not side or not nation then
65799: LD_VAR 0 1
65803: NOT
65804: PUSH
65805: LD_VAR 0 2
65809: NOT
65810: OR
65811: IFFALSE 65815
// exit ;
65813: GO 66583
// case nation of nation_american :
65815: LD_VAR 0 2
65819: PUSH
65820: LD_INT 1
65822: DOUBLE
65823: EQUAL
65824: IFTRUE 65828
65826: GO 66042
65828: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65829: LD_ADDR_VAR 0 4
65833: PUSH
65834: LD_INT 35
65836: PUSH
65837: LD_INT 45
65839: PUSH
65840: LD_INT 46
65842: PUSH
65843: LD_INT 47
65845: PUSH
65846: LD_INT 82
65848: PUSH
65849: LD_INT 83
65851: PUSH
65852: LD_INT 84
65854: PUSH
65855: LD_INT 85
65857: PUSH
65858: LD_INT 86
65860: PUSH
65861: LD_INT 1
65863: PUSH
65864: LD_INT 2
65866: PUSH
65867: LD_INT 6
65869: PUSH
65870: LD_INT 15
65872: PUSH
65873: LD_INT 16
65875: PUSH
65876: LD_INT 7
65878: PUSH
65879: LD_INT 12
65881: PUSH
65882: LD_INT 13
65884: PUSH
65885: LD_INT 10
65887: PUSH
65888: LD_INT 14
65890: PUSH
65891: LD_INT 20
65893: PUSH
65894: LD_INT 21
65896: PUSH
65897: LD_INT 22
65899: PUSH
65900: LD_INT 25
65902: PUSH
65903: LD_INT 32
65905: PUSH
65906: LD_INT 27
65908: PUSH
65909: LD_INT 36
65911: PUSH
65912: LD_INT 69
65914: PUSH
65915: LD_INT 39
65917: PUSH
65918: LD_INT 34
65920: PUSH
65921: LD_INT 40
65923: PUSH
65924: LD_INT 48
65926: PUSH
65927: LD_INT 49
65929: PUSH
65930: LD_INT 50
65932: PUSH
65933: LD_INT 51
65935: PUSH
65936: LD_INT 52
65938: PUSH
65939: LD_INT 53
65941: PUSH
65942: LD_INT 54
65944: PUSH
65945: LD_INT 55
65947: PUSH
65948: LD_INT 56
65950: PUSH
65951: LD_INT 57
65953: PUSH
65954: LD_INT 58
65956: PUSH
65957: LD_INT 59
65959: PUSH
65960: LD_INT 60
65962: PUSH
65963: LD_INT 61
65965: PUSH
65966: LD_INT 62
65968: PUSH
65969: LD_INT 80
65971: PUSH
65972: LD_INT 82
65974: PUSH
65975: LD_INT 83
65977: PUSH
65978: LD_INT 84
65980: PUSH
65981: LD_INT 85
65983: PUSH
65984: LD_INT 86
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: LIST
66014: LIST
66015: LIST
66016: LIST
66017: LIST
66018: LIST
66019: LIST
66020: LIST
66021: LIST
66022: LIST
66023: LIST
66024: LIST
66025: LIST
66026: LIST
66027: LIST
66028: LIST
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: LIST
66039: ST_TO_ADDR
66040: GO 66507
66042: LD_INT 2
66044: DOUBLE
66045: EQUAL
66046: IFTRUE 66050
66048: GO 66276
66050: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66051: LD_ADDR_VAR 0 4
66055: PUSH
66056: LD_INT 35
66058: PUSH
66059: LD_INT 45
66061: PUSH
66062: LD_INT 46
66064: PUSH
66065: LD_INT 47
66067: PUSH
66068: LD_INT 82
66070: PUSH
66071: LD_INT 83
66073: PUSH
66074: LD_INT 84
66076: PUSH
66077: LD_INT 85
66079: PUSH
66080: LD_INT 87
66082: PUSH
66083: LD_INT 70
66085: PUSH
66086: LD_INT 1
66088: PUSH
66089: LD_INT 11
66091: PUSH
66092: LD_INT 3
66094: PUSH
66095: LD_INT 4
66097: PUSH
66098: LD_INT 5
66100: PUSH
66101: LD_INT 6
66103: PUSH
66104: LD_INT 15
66106: PUSH
66107: LD_INT 18
66109: PUSH
66110: LD_INT 7
66112: PUSH
66113: LD_INT 17
66115: PUSH
66116: LD_INT 8
66118: PUSH
66119: LD_INT 20
66121: PUSH
66122: LD_INT 21
66124: PUSH
66125: LD_INT 22
66127: PUSH
66128: LD_INT 72
66130: PUSH
66131: LD_INT 26
66133: PUSH
66134: LD_INT 69
66136: PUSH
66137: LD_INT 39
66139: PUSH
66140: LD_INT 40
66142: PUSH
66143: LD_INT 41
66145: PUSH
66146: LD_INT 42
66148: PUSH
66149: LD_INT 43
66151: PUSH
66152: LD_INT 48
66154: PUSH
66155: LD_INT 49
66157: PUSH
66158: LD_INT 50
66160: PUSH
66161: LD_INT 51
66163: PUSH
66164: LD_INT 52
66166: PUSH
66167: LD_INT 53
66169: PUSH
66170: LD_INT 54
66172: PUSH
66173: LD_INT 55
66175: PUSH
66176: LD_INT 56
66178: PUSH
66179: LD_INT 60
66181: PUSH
66182: LD_INT 61
66184: PUSH
66185: LD_INT 62
66187: PUSH
66188: LD_INT 66
66190: PUSH
66191: LD_INT 67
66193: PUSH
66194: LD_INT 68
66196: PUSH
66197: LD_INT 81
66199: PUSH
66200: LD_INT 82
66202: PUSH
66203: LD_INT 83
66205: PUSH
66206: LD_INT 84
66208: PUSH
66209: LD_INT 85
66211: PUSH
66212: LD_INT 87
66214: PUSH
66215: LD_INT 88
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: LIST
66264: LIST
66265: LIST
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: LIST
66271: LIST
66272: LIST
66273: ST_TO_ADDR
66274: GO 66507
66276: LD_INT 3
66278: DOUBLE
66279: EQUAL
66280: IFTRUE 66284
66282: GO 66506
66284: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66285: LD_ADDR_VAR 0 4
66289: PUSH
66290: LD_INT 46
66292: PUSH
66293: LD_INT 47
66295: PUSH
66296: LD_INT 1
66298: PUSH
66299: LD_INT 2
66301: PUSH
66302: LD_INT 82
66304: PUSH
66305: LD_INT 83
66307: PUSH
66308: LD_INT 84
66310: PUSH
66311: LD_INT 85
66313: PUSH
66314: LD_INT 86
66316: PUSH
66317: LD_INT 11
66319: PUSH
66320: LD_INT 9
66322: PUSH
66323: LD_INT 20
66325: PUSH
66326: LD_INT 19
66328: PUSH
66329: LD_INT 21
66331: PUSH
66332: LD_INT 24
66334: PUSH
66335: LD_INT 22
66337: PUSH
66338: LD_INT 25
66340: PUSH
66341: LD_INT 28
66343: PUSH
66344: LD_INT 29
66346: PUSH
66347: LD_INT 30
66349: PUSH
66350: LD_INT 31
66352: PUSH
66353: LD_INT 37
66355: PUSH
66356: LD_INT 38
66358: PUSH
66359: LD_INT 32
66361: PUSH
66362: LD_INT 27
66364: PUSH
66365: LD_INT 33
66367: PUSH
66368: LD_INT 69
66370: PUSH
66371: LD_INT 39
66373: PUSH
66374: LD_INT 34
66376: PUSH
66377: LD_INT 40
66379: PUSH
66380: LD_INT 71
66382: PUSH
66383: LD_INT 23
66385: PUSH
66386: LD_INT 44
66388: PUSH
66389: LD_INT 48
66391: PUSH
66392: LD_INT 49
66394: PUSH
66395: LD_INT 50
66397: PUSH
66398: LD_INT 51
66400: PUSH
66401: LD_INT 52
66403: PUSH
66404: LD_INT 53
66406: PUSH
66407: LD_INT 54
66409: PUSH
66410: LD_INT 55
66412: PUSH
66413: LD_INT 56
66415: PUSH
66416: LD_INT 57
66418: PUSH
66419: LD_INT 58
66421: PUSH
66422: LD_INT 59
66424: PUSH
66425: LD_INT 63
66427: PUSH
66428: LD_INT 64
66430: PUSH
66431: LD_INT 65
66433: PUSH
66434: LD_INT 82
66436: PUSH
66437: LD_INT 83
66439: PUSH
66440: LD_INT 84
66442: PUSH
66443: LD_INT 85
66445: PUSH
66446: LD_INT 86
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: LIST
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: ST_TO_ADDR
66504: GO 66507
66506: POP
// if state > - 1 and state < 3 then
66507: LD_VAR 0 3
66511: PUSH
66512: LD_INT 1
66514: NEG
66515: GREATER
66516: PUSH
66517: LD_VAR 0 3
66521: PUSH
66522: LD_INT 3
66524: LESS
66525: AND
66526: IFFALSE 66583
// for i in result do
66528: LD_ADDR_VAR 0 5
66532: PUSH
66533: LD_VAR 0 4
66537: PUSH
66538: FOR_IN
66539: IFFALSE 66581
// if GetTech ( i , side ) <> state then
66541: LD_VAR 0 5
66545: PPUSH
66546: LD_VAR 0 1
66550: PPUSH
66551: CALL_OW 321
66555: PUSH
66556: LD_VAR 0 3
66560: NONEQUAL
66561: IFFALSE 66579
// result := result diff i ;
66563: LD_ADDR_VAR 0 4
66567: PUSH
66568: LD_VAR 0 4
66572: PUSH
66573: LD_VAR 0 5
66577: DIFF
66578: ST_TO_ADDR
66579: GO 66538
66581: POP
66582: POP
// end ;
66583: LD_VAR 0 4
66587: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66588: LD_INT 0
66590: PPUSH
66591: PPUSH
66592: PPUSH
// result := true ;
66593: LD_ADDR_VAR 0 3
66597: PUSH
66598: LD_INT 1
66600: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66601: LD_ADDR_VAR 0 5
66605: PUSH
66606: LD_VAR 0 2
66610: PPUSH
66611: CALL_OW 480
66615: ST_TO_ADDR
// if not tmp then
66616: LD_VAR 0 5
66620: NOT
66621: IFFALSE 66625
// exit ;
66623: GO 66674
// for i in tmp do
66625: LD_ADDR_VAR 0 4
66629: PUSH
66630: LD_VAR 0 5
66634: PUSH
66635: FOR_IN
66636: IFFALSE 66672
// if GetTech ( i , side ) <> state_researched then
66638: LD_VAR 0 4
66642: PPUSH
66643: LD_VAR 0 1
66647: PPUSH
66648: CALL_OW 321
66652: PUSH
66653: LD_INT 2
66655: NONEQUAL
66656: IFFALSE 66670
// begin result := false ;
66658: LD_ADDR_VAR 0 3
66662: PUSH
66663: LD_INT 0
66665: ST_TO_ADDR
// exit ;
66666: POP
66667: POP
66668: GO 66674
// end ;
66670: GO 66635
66672: POP
66673: POP
// end ;
66674: LD_VAR 0 3
66678: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66679: LD_INT 0
66681: PPUSH
66682: PPUSH
66683: PPUSH
66684: PPUSH
66685: PPUSH
66686: PPUSH
66687: PPUSH
66688: PPUSH
66689: PPUSH
66690: PPUSH
66691: PPUSH
66692: PPUSH
66693: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66694: LD_VAR 0 1
66698: NOT
66699: PUSH
66700: LD_VAR 0 1
66704: PPUSH
66705: CALL_OW 257
66709: PUSH
66710: LD_INT 9
66712: NONEQUAL
66713: OR
66714: IFFALSE 66718
// exit ;
66716: GO 67291
// side := GetSide ( unit ) ;
66718: LD_ADDR_VAR 0 9
66722: PUSH
66723: LD_VAR 0 1
66727: PPUSH
66728: CALL_OW 255
66732: ST_TO_ADDR
// tech_space := tech_spacanom ;
66733: LD_ADDR_VAR 0 12
66737: PUSH
66738: LD_INT 29
66740: ST_TO_ADDR
// tech_time := tech_taurad ;
66741: LD_ADDR_VAR 0 13
66745: PUSH
66746: LD_INT 28
66748: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66749: LD_ADDR_VAR 0 11
66753: PUSH
66754: LD_VAR 0 1
66758: PPUSH
66759: CALL_OW 310
66763: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66764: LD_VAR 0 11
66768: PPUSH
66769: CALL_OW 247
66773: PUSH
66774: LD_INT 2
66776: EQUAL
66777: IFFALSE 66781
// exit ;
66779: GO 67291
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66781: LD_ADDR_VAR 0 8
66785: PUSH
66786: LD_INT 81
66788: PUSH
66789: LD_VAR 0 9
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 3
66800: PUSH
66801: LD_INT 21
66803: PUSH
66804: LD_INT 3
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PPUSH
66819: CALL_OW 69
66823: ST_TO_ADDR
// if not tmp then
66824: LD_VAR 0 8
66828: NOT
66829: IFFALSE 66833
// exit ;
66831: GO 67291
// if in_unit then
66833: LD_VAR 0 11
66837: IFFALSE 66861
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66839: LD_ADDR_VAR 0 10
66843: PUSH
66844: LD_VAR 0 8
66848: PPUSH
66849: LD_VAR 0 11
66853: PPUSH
66854: CALL_OW 74
66858: ST_TO_ADDR
66859: GO 66881
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66861: LD_ADDR_VAR 0 10
66865: PUSH
66866: LD_VAR 0 8
66870: PPUSH
66871: LD_VAR 0 1
66875: PPUSH
66876: CALL_OW 74
66880: ST_TO_ADDR
// if not enemy then
66881: LD_VAR 0 10
66885: NOT
66886: IFFALSE 66890
// exit ;
66888: GO 67291
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66890: LD_VAR 0 11
66894: PUSH
66895: LD_VAR 0 11
66899: PPUSH
66900: LD_VAR 0 10
66904: PPUSH
66905: CALL_OW 296
66909: PUSH
66910: LD_INT 13
66912: GREATER
66913: AND
66914: PUSH
66915: LD_VAR 0 1
66919: PPUSH
66920: LD_VAR 0 10
66924: PPUSH
66925: CALL_OW 296
66929: PUSH
66930: LD_INT 12
66932: GREATER
66933: OR
66934: IFFALSE 66938
// exit ;
66936: GO 67291
// missile := [ 1 ] ;
66938: LD_ADDR_VAR 0 14
66942: PUSH
66943: LD_INT 1
66945: PUSH
66946: EMPTY
66947: LIST
66948: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66949: LD_VAR 0 9
66953: PPUSH
66954: LD_VAR 0 12
66958: PPUSH
66959: CALL_OW 325
66963: IFFALSE 66992
// missile := Replace ( missile , missile + 1 , 2 ) ;
66965: LD_ADDR_VAR 0 14
66969: PUSH
66970: LD_VAR 0 14
66974: PPUSH
66975: LD_VAR 0 14
66979: PUSH
66980: LD_INT 1
66982: PLUS
66983: PPUSH
66984: LD_INT 2
66986: PPUSH
66987: CALL_OW 1
66991: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66992: LD_VAR 0 9
66996: PPUSH
66997: LD_VAR 0 13
67001: PPUSH
67002: CALL_OW 325
67006: PUSH
67007: LD_VAR 0 10
67011: PPUSH
67012: CALL_OW 255
67016: PPUSH
67017: LD_VAR 0 13
67021: PPUSH
67022: CALL_OW 325
67026: NOT
67027: AND
67028: IFFALSE 67057
// missile := Replace ( missile , missile + 1 , 3 ) ;
67030: LD_ADDR_VAR 0 14
67034: PUSH
67035: LD_VAR 0 14
67039: PPUSH
67040: LD_VAR 0 14
67044: PUSH
67045: LD_INT 1
67047: PLUS
67048: PPUSH
67049: LD_INT 3
67051: PPUSH
67052: CALL_OW 1
67056: ST_TO_ADDR
// if missile < 2 then
67057: LD_VAR 0 14
67061: PUSH
67062: LD_INT 2
67064: LESS
67065: IFFALSE 67069
// exit ;
67067: GO 67291
// x := GetX ( enemy ) ;
67069: LD_ADDR_VAR 0 4
67073: PUSH
67074: LD_VAR 0 10
67078: PPUSH
67079: CALL_OW 250
67083: ST_TO_ADDR
// y := GetY ( enemy ) ;
67084: LD_ADDR_VAR 0 5
67088: PUSH
67089: LD_VAR 0 10
67093: PPUSH
67094: CALL_OW 251
67098: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67099: LD_ADDR_VAR 0 6
67103: PUSH
67104: LD_VAR 0 4
67108: PUSH
67109: LD_INT 1
67111: NEG
67112: PPUSH
67113: LD_INT 1
67115: PPUSH
67116: CALL_OW 12
67120: PLUS
67121: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67122: LD_ADDR_VAR 0 7
67126: PUSH
67127: LD_VAR 0 5
67131: PUSH
67132: LD_INT 1
67134: NEG
67135: PPUSH
67136: LD_INT 1
67138: PPUSH
67139: CALL_OW 12
67143: PLUS
67144: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67145: LD_VAR 0 6
67149: PPUSH
67150: LD_VAR 0 7
67154: PPUSH
67155: CALL_OW 488
67159: NOT
67160: IFFALSE 67182
// begin _x := x ;
67162: LD_ADDR_VAR 0 6
67166: PUSH
67167: LD_VAR 0 4
67171: ST_TO_ADDR
// _y := y ;
67172: LD_ADDR_VAR 0 7
67176: PUSH
67177: LD_VAR 0 5
67181: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67182: LD_ADDR_VAR 0 3
67186: PUSH
67187: LD_INT 1
67189: PPUSH
67190: LD_VAR 0 14
67194: PPUSH
67195: CALL_OW 12
67199: ST_TO_ADDR
// case i of 1 :
67200: LD_VAR 0 3
67204: PUSH
67205: LD_INT 1
67207: DOUBLE
67208: EQUAL
67209: IFTRUE 67213
67211: GO 67230
67213: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67214: LD_VAR 0 1
67218: PPUSH
67219: LD_VAR 0 10
67223: PPUSH
67224: CALL_OW 115
67228: GO 67291
67230: LD_INT 2
67232: DOUBLE
67233: EQUAL
67234: IFTRUE 67238
67236: GO 67260
67238: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67239: LD_VAR 0 1
67243: PPUSH
67244: LD_VAR 0 6
67248: PPUSH
67249: LD_VAR 0 7
67253: PPUSH
67254: CALL_OW 153
67258: GO 67291
67260: LD_INT 3
67262: DOUBLE
67263: EQUAL
67264: IFTRUE 67268
67266: GO 67290
67268: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67269: LD_VAR 0 1
67273: PPUSH
67274: LD_VAR 0 6
67278: PPUSH
67279: LD_VAR 0 7
67283: PPUSH
67284: CALL_OW 154
67288: GO 67291
67290: POP
// end ;
67291: LD_VAR 0 2
67295: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67296: LD_INT 0
67298: PPUSH
67299: PPUSH
67300: PPUSH
67301: PPUSH
67302: PPUSH
67303: PPUSH
// if not unit or not building then
67304: LD_VAR 0 1
67308: NOT
67309: PUSH
67310: LD_VAR 0 2
67314: NOT
67315: OR
67316: IFFALSE 67320
// exit ;
67318: GO 67478
// x := GetX ( building ) ;
67320: LD_ADDR_VAR 0 5
67324: PUSH
67325: LD_VAR 0 2
67329: PPUSH
67330: CALL_OW 250
67334: ST_TO_ADDR
// y := GetY ( building ) ;
67335: LD_ADDR_VAR 0 6
67339: PUSH
67340: LD_VAR 0 2
67344: PPUSH
67345: CALL_OW 251
67349: ST_TO_ADDR
// for i = 0 to 5 do
67350: LD_ADDR_VAR 0 4
67354: PUSH
67355: DOUBLE
67356: LD_INT 0
67358: DEC
67359: ST_TO_ADDR
67360: LD_INT 5
67362: PUSH
67363: FOR_TO
67364: IFFALSE 67476
// begin _x := ShiftX ( x , i , 3 ) ;
67366: LD_ADDR_VAR 0 7
67370: PUSH
67371: LD_VAR 0 5
67375: PPUSH
67376: LD_VAR 0 4
67380: PPUSH
67381: LD_INT 3
67383: PPUSH
67384: CALL_OW 272
67388: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67389: LD_ADDR_VAR 0 8
67393: PUSH
67394: LD_VAR 0 6
67398: PPUSH
67399: LD_VAR 0 4
67403: PPUSH
67404: LD_INT 3
67406: PPUSH
67407: CALL_OW 273
67411: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67412: LD_VAR 0 7
67416: PPUSH
67417: LD_VAR 0 8
67421: PPUSH
67422: CALL_OW 488
67426: NOT
67427: IFFALSE 67431
// continue ;
67429: GO 67363
// if HexInfo ( _x , _y ) = 0 then
67431: LD_VAR 0 7
67435: PPUSH
67436: LD_VAR 0 8
67440: PPUSH
67441: CALL_OW 428
67445: PUSH
67446: LD_INT 0
67448: EQUAL
67449: IFFALSE 67474
// begin ComMoveXY ( unit , _x , _y ) ;
67451: LD_VAR 0 1
67455: PPUSH
67456: LD_VAR 0 7
67460: PPUSH
67461: LD_VAR 0 8
67465: PPUSH
67466: CALL_OW 111
// exit ;
67470: POP
67471: POP
67472: GO 67478
// end ; end ;
67474: GO 67363
67476: POP
67477: POP
// end ;
67478: LD_VAR 0 3
67482: RET
// export function ScanBase ( side , base_area ) ; begin
67483: LD_INT 0
67485: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67486: LD_ADDR_VAR 0 3
67490: PUSH
67491: LD_VAR 0 2
67495: PPUSH
67496: LD_INT 81
67498: PUSH
67499: LD_VAR 0 1
67503: PUSH
67504: EMPTY
67505: LIST
67506: LIST
67507: PPUSH
67508: CALL_OW 70
67512: ST_TO_ADDR
// end ;
67513: LD_VAR 0 3
67517: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67518: LD_INT 0
67520: PPUSH
67521: PPUSH
67522: PPUSH
67523: PPUSH
// result := false ;
67524: LD_ADDR_VAR 0 2
67528: PUSH
67529: LD_INT 0
67531: ST_TO_ADDR
// side := GetSide ( unit ) ;
67532: LD_ADDR_VAR 0 3
67536: PUSH
67537: LD_VAR 0 1
67541: PPUSH
67542: CALL_OW 255
67546: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67547: LD_ADDR_VAR 0 4
67551: PUSH
67552: LD_VAR 0 1
67556: PPUSH
67557: CALL_OW 248
67561: ST_TO_ADDR
// case nat of 1 :
67562: LD_VAR 0 4
67566: PUSH
67567: LD_INT 1
67569: DOUBLE
67570: EQUAL
67571: IFTRUE 67575
67573: GO 67586
67575: POP
// tech := tech_lassight ; 2 :
67576: LD_ADDR_VAR 0 5
67580: PUSH
67581: LD_INT 12
67583: ST_TO_ADDR
67584: GO 67625
67586: LD_INT 2
67588: DOUBLE
67589: EQUAL
67590: IFTRUE 67594
67592: GO 67605
67594: POP
// tech := tech_mortar ; 3 :
67595: LD_ADDR_VAR 0 5
67599: PUSH
67600: LD_INT 41
67602: ST_TO_ADDR
67603: GO 67625
67605: LD_INT 3
67607: DOUBLE
67608: EQUAL
67609: IFTRUE 67613
67611: GO 67624
67613: POP
// tech := tech_bazooka ; end ;
67614: LD_ADDR_VAR 0 5
67618: PUSH
67619: LD_INT 44
67621: ST_TO_ADDR
67622: GO 67625
67624: POP
// if Researched ( side , tech ) then
67625: LD_VAR 0 3
67629: PPUSH
67630: LD_VAR 0 5
67634: PPUSH
67635: CALL_OW 325
67639: IFFALSE 67666
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67641: LD_ADDR_VAR 0 2
67645: PUSH
67646: LD_INT 5
67648: PUSH
67649: LD_INT 8
67651: PUSH
67652: LD_INT 9
67654: PUSH
67655: EMPTY
67656: LIST
67657: LIST
67658: LIST
67659: PUSH
67660: LD_VAR 0 4
67664: ARRAY
67665: ST_TO_ADDR
// end ;
67666: LD_VAR 0 2
67670: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67671: LD_INT 0
67673: PPUSH
67674: PPUSH
67675: PPUSH
// if not mines then
67676: LD_VAR 0 2
67680: NOT
67681: IFFALSE 67685
// exit ;
67683: GO 67829
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67685: LD_ADDR_VAR 0 5
67689: PUSH
67690: LD_INT 81
67692: PUSH
67693: LD_VAR 0 1
67697: PUSH
67698: EMPTY
67699: LIST
67700: LIST
67701: PUSH
67702: LD_INT 3
67704: PUSH
67705: LD_INT 21
67707: PUSH
67708: LD_INT 3
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PPUSH
67723: CALL_OW 69
67727: ST_TO_ADDR
// for i in mines do
67728: LD_ADDR_VAR 0 4
67732: PUSH
67733: LD_VAR 0 2
67737: PUSH
67738: FOR_IN
67739: IFFALSE 67827
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67741: LD_VAR 0 4
67745: PUSH
67746: LD_INT 1
67748: ARRAY
67749: PPUSH
67750: LD_VAR 0 4
67754: PUSH
67755: LD_INT 2
67757: ARRAY
67758: PPUSH
67759: CALL_OW 458
67763: NOT
67764: IFFALSE 67768
// continue ;
67766: GO 67738
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67768: LD_VAR 0 4
67772: PUSH
67773: LD_INT 1
67775: ARRAY
67776: PPUSH
67777: LD_VAR 0 4
67781: PUSH
67782: LD_INT 2
67784: ARRAY
67785: PPUSH
67786: CALL_OW 428
67790: PUSH
67791: LD_VAR 0 5
67795: IN
67796: IFFALSE 67825
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67798: LD_VAR 0 4
67802: PUSH
67803: LD_INT 1
67805: ARRAY
67806: PPUSH
67807: LD_VAR 0 4
67811: PUSH
67812: LD_INT 2
67814: ARRAY
67815: PPUSH
67816: LD_VAR 0 1
67820: PPUSH
67821: CALL_OW 456
// end ;
67825: GO 67738
67827: POP
67828: POP
// end ;
67829: LD_VAR 0 3
67833: RET
// export function Count ( array ) ; var i ; begin
67834: LD_INT 0
67836: PPUSH
67837: PPUSH
// result := 0 ;
67838: LD_ADDR_VAR 0 2
67842: PUSH
67843: LD_INT 0
67845: ST_TO_ADDR
// for i in array do
67846: LD_ADDR_VAR 0 3
67850: PUSH
67851: LD_VAR 0 1
67855: PUSH
67856: FOR_IN
67857: IFFALSE 67881
// if i then
67859: LD_VAR 0 3
67863: IFFALSE 67879
// result := result + 1 ;
67865: LD_ADDR_VAR 0 2
67869: PUSH
67870: LD_VAR 0 2
67874: PUSH
67875: LD_INT 1
67877: PLUS
67878: ST_TO_ADDR
67879: GO 67856
67881: POP
67882: POP
// end ;
67883: LD_VAR 0 2
67887: RET
// export function IsEmpty ( building ) ; begin
67888: LD_INT 0
67890: PPUSH
// if not building then
67891: LD_VAR 0 1
67895: NOT
67896: IFFALSE 67900
// exit ;
67898: GO 67943
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67900: LD_ADDR_VAR 0 2
67904: PUSH
67905: LD_VAR 0 1
67909: PUSH
67910: LD_INT 22
67912: PUSH
67913: LD_VAR 0 1
67917: PPUSH
67918: CALL_OW 255
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 58
67929: PUSH
67930: EMPTY
67931: LIST
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PPUSH
67937: CALL_OW 69
67941: IN
67942: ST_TO_ADDR
// end ;
67943: LD_VAR 0 2
67947: RET
// export function IsNotFull ( building ) ; var places ; begin
67948: LD_INT 0
67950: PPUSH
67951: PPUSH
// if not building then
67952: LD_VAR 0 1
67956: NOT
67957: IFFALSE 67961
// exit ;
67959: GO 68132
// result := false ;
67961: LD_ADDR_VAR 0 2
67965: PUSH
67966: LD_INT 0
67968: ST_TO_ADDR
// places := 0 ;
67969: LD_ADDR_VAR 0 3
67973: PUSH
67974: LD_INT 0
67976: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
67977: LD_VAR 0 1
67981: PPUSH
67982: CALL_OW 266
67986: PUSH
67987: LD_INT 0
67989: DOUBLE
67990: EQUAL
67991: IFTRUE 68049
67993: LD_INT 1
67995: DOUBLE
67996: EQUAL
67997: IFTRUE 68049
67999: LD_INT 6
68001: DOUBLE
68002: EQUAL
68003: IFTRUE 68049
68005: LD_INT 7
68007: DOUBLE
68008: EQUAL
68009: IFTRUE 68049
68011: LD_INT 8
68013: DOUBLE
68014: EQUAL
68015: IFTRUE 68049
68017: LD_INT 4
68019: DOUBLE
68020: EQUAL
68021: IFTRUE 68049
68023: LD_INT 5
68025: DOUBLE
68026: EQUAL
68027: IFTRUE 68049
68029: LD_INT 2
68031: DOUBLE
68032: EQUAL
68033: IFTRUE 68049
68035: LD_INT 3
68037: DOUBLE
68038: EQUAL
68039: IFTRUE 68049
68041: LD_INT 35
68043: DOUBLE
68044: EQUAL
68045: IFTRUE 68049
68047: GO 68060
68049: POP
// places := 6 ; b_bunker , b_breastwork :
68050: LD_ADDR_VAR 0 3
68054: PUSH
68055: LD_INT 6
68057: ST_TO_ADDR
68058: GO 68105
68060: LD_INT 32
68062: DOUBLE
68063: EQUAL
68064: IFTRUE 68074
68066: LD_INT 31
68068: DOUBLE
68069: EQUAL
68070: IFTRUE 68074
68072: GO 68085
68074: POP
// places := 1 ; b_control_tower :
68075: LD_ADDR_VAR 0 3
68079: PUSH
68080: LD_INT 1
68082: ST_TO_ADDR
68083: GO 68105
68085: LD_INT 36
68087: DOUBLE
68088: EQUAL
68089: IFTRUE 68093
68091: GO 68104
68093: POP
// places := 3 ; end ;
68094: LD_ADDR_VAR 0 3
68098: PUSH
68099: LD_INT 3
68101: ST_TO_ADDR
68102: GO 68105
68104: POP
// if places then
68105: LD_VAR 0 3
68109: IFFALSE 68132
// result := UnitsInside ( building ) < places ;
68111: LD_ADDR_VAR 0 2
68115: PUSH
68116: LD_VAR 0 1
68120: PPUSH
68121: CALL_OW 313
68125: PUSH
68126: LD_VAR 0 3
68130: LESS
68131: ST_TO_ADDR
// end ;
68132: LD_VAR 0 2
68136: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68137: LD_INT 0
68139: PPUSH
68140: PPUSH
68141: PPUSH
68142: PPUSH
// tmp := [ ] ;
68143: LD_ADDR_VAR 0 3
68147: PUSH
68148: EMPTY
68149: ST_TO_ADDR
// list := [ ] ;
68150: LD_ADDR_VAR 0 5
68154: PUSH
68155: EMPTY
68156: ST_TO_ADDR
// for i = 16 to 25 do
68157: LD_ADDR_VAR 0 4
68161: PUSH
68162: DOUBLE
68163: LD_INT 16
68165: DEC
68166: ST_TO_ADDR
68167: LD_INT 25
68169: PUSH
68170: FOR_TO
68171: IFFALSE 68244
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68173: LD_ADDR_VAR 0 3
68177: PUSH
68178: LD_VAR 0 3
68182: PUSH
68183: LD_INT 22
68185: PUSH
68186: LD_VAR 0 1
68190: PPUSH
68191: CALL_OW 255
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 91
68202: PUSH
68203: LD_VAR 0 1
68207: PUSH
68208: LD_INT 6
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 30
68218: PUSH
68219: LD_VAR 0 4
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: LIST
68232: PUSH
68233: EMPTY
68234: LIST
68235: PPUSH
68236: CALL_OW 69
68240: ADD
68241: ST_TO_ADDR
68242: GO 68170
68244: POP
68245: POP
// for i = 1 to tmp do
68246: LD_ADDR_VAR 0 4
68250: PUSH
68251: DOUBLE
68252: LD_INT 1
68254: DEC
68255: ST_TO_ADDR
68256: LD_VAR 0 3
68260: PUSH
68261: FOR_TO
68262: IFFALSE 68350
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68264: LD_ADDR_VAR 0 5
68268: PUSH
68269: LD_VAR 0 5
68273: PUSH
68274: LD_VAR 0 3
68278: PUSH
68279: LD_VAR 0 4
68283: ARRAY
68284: PPUSH
68285: CALL_OW 266
68289: PUSH
68290: LD_VAR 0 3
68294: PUSH
68295: LD_VAR 0 4
68299: ARRAY
68300: PPUSH
68301: CALL_OW 250
68305: PUSH
68306: LD_VAR 0 3
68310: PUSH
68311: LD_VAR 0 4
68315: ARRAY
68316: PPUSH
68317: CALL_OW 251
68321: PUSH
68322: LD_VAR 0 3
68326: PUSH
68327: LD_VAR 0 4
68331: ARRAY
68332: PPUSH
68333: CALL_OW 254
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: PUSH
68344: EMPTY
68345: LIST
68346: ADD
68347: ST_TO_ADDR
68348: GO 68261
68350: POP
68351: POP
// result := list ;
68352: LD_ADDR_VAR 0 2
68356: PUSH
68357: LD_VAR 0 5
68361: ST_TO_ADDR
// end ;
68362: LD_VAR 0 2
68366: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68367: LD_INT 0
68369: PPUSH
68370: PPUSH
68371: PPUSH
68372: PPUSH
68373: PPUSH
68374: PPUSH
68375: PPUSH
// if not factory then
68376: LD_VAR 0 1
68380: NOT
68381: IFFALSE 68385
// exit ;
68383: GO 68978
// if control = control_apeman then
68385: LD_VAR 0 4
68389: PUSH
68390: LD_INT 5
68392: EQUAL
68393: IFFALSE 68502
// begin tmp := UnitsInside ( factory ) ;
68395: LD_ADDR_VAR 0 8
68399: PUSH
68400: LD_VAR 0 1
68404: PPUSH
68405: CALL_OW 313
68409: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68410: LD_VAR 0 8
68414: PPUSH
68415: LD_INT 25
68417: PUSH
68418: LD_INT 12
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PPUSH
68425: CALL_OW 72
68429: NOT
68430: IFFALSE 68440
// control := control_manual ;
68432: LD_ADDR_VAR 0 4
68436: PUSH
68437: LD_INT 1
68439: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68440: LD_ADDR_VAR 0 8
68444: PUSH
68445: LD_VAR 0 1
68449: PPUSH
68450: CALL 68137 0 1
68454: ST_TO_ADDR
// if tmp then
68455: LD_VAR 0 8
68459: IFFALSE 68502
// begin for i in tmp do
68461: LD_ADDR_VAR 0 7
68465: PUSH
68466: LD_VAR 0 8
68470: PUSH
68471: FOR_IN
68472: IFFALSE 68500
// if i [ 1 ] = b_ext_radio then
68474: LD_VAR 0 7
68478: PUSH
68479: LD_INT 1
68481: ARRAY
68482: PUSH
68483: LD_INT 22
68485: EQUAL
68486: IFFALSE 68498
// begin control := control_remote ;
68488: LD_ADDR_VAR 0 4
68492: PUSH
68493: LD_INT 2
68495: ST_TO_ADDR
// break ;
68496: GO 68500
// end ;
68498: GO 68471
68500: POP
68501: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68502: LD_VAR 0 1
68506: PPUSH
68507: LD_VAR 0 2
68511: PPUSH
68512: LD_VAR 0 3
68516: PPUSH
68517: LD_VAR 0 4
68521: PPUSH
68522: LD_VAR 0 5
68526: PPUSH
68527: CALL_OW 448
68531: IFFALSE 68566
// begin result := [ chassis , engine , control , weapon ] ;
68533: LD_ADDR_VAR 0 6
68537: PUSH
68538: LD_VAR 0 2
68542: PUSH
68543: LD_VAR 0 3
68547: PUSH
68548: LD_VAR 0 4
68552: PUSH
68553: LD_VAR 0 5
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: ST_TO_ADDR
// exit ;
68564: GO 68978
// end ; _chassis := AvailableChassisList ( factory ) ;
68566: LD_ADDR_VAR 0 9
68570: PUSH
68571: LD_VAR 0 1
68575: PPUSH
68576: CALL_OW 475
68580: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68581: LD_ADDR_VAR 0 11
68585: PUSH
68586: LD_VAR 0 1
68590: PPUSH
68591: CALL_OW 476
68595: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68596: LD_ADDR_VAR 0 12
68600: PUSH
68601: LD_VAR 0 1
68605: PPUSH
68606: CALL_OW 477
68610: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68611: LD_ADDR_VAR 0 10
68615: PUSH
68616: LD_VAR 0 1
68620: PPUSH
68621: CALL_OW 478
68625: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68626: LD_VAR 0 9
68630: NOT
68631: PUSH
68632: LD_VAR 0 11
68636: NOT
68637: OR
68638: PUSH
68639: LD_VAR 0 12
68643: NOT
68644: OR
68645: PUSH
68646: LD_VAR 0 10
68650: NOT
68651: OR
68652: IFFALSE 68687
// begin result := [ chassis , engine , control , weapon ] ;
68654: LD_ADDR_VAR 0 6
68658: PUSH
68659: LD_VAR 0 2
68663: PUSH
68664: LD_VAR 0 3
68668: PUSH
68669: LD_VAR 0 4
68673: PUSH
68674: LD_VAR 0 5
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: ST_TO_ADDR
// exit ;
68685: GO 68978
// end ; if not chassis in _chassis then
68687: LD_VAR 0 2
68691: PUSH
68692: LD_VAR 0 9
68696: IN
68697: NOT
68698: IFFALSE 68724
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68700: LD_ADDR_VAR 0 2
68704: PUSH
68705: LD_VAR 0 9
68709: PUSH
68710: LD_INT 1
68712: PPUSH
68713: LD_VAR 0 9
68717: PPUSH
68718: CALL_OW 12
68722: ARRAY
68723: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68724: LD_VAR 0 2
68728: PPUSH
68729: LD_VAR 0 3
68733: PPUSH
68734: CALL 68983 0 2
68738: NOT
68739: IFFALSE 68798
// repeat engine := _engine [ 1 ] ;
68741: LD_ADDR_VAR 0 3
68745: PUSH
68746: LD_VAR 0 11
68750: PUSH
68751: LD_INT 1
68753: ARRAY
68754: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68755: LD_ADDR_VAR 0 11
68759: PUSH
68760: LD_VAR 0 11
68764: PPUSH
68765: LD_INT 1
68767: PPUSH
68768: CALL_OW 3
68772: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68773: LD_VAR 0 2
68777: PPUSH
68778: LD_VAR 0 3
68782: PPUSH
68783: CALL 68983 0 2
68787: PUSH
68788: LD_VAR 0 11
68792: PUSH
68793: EMPTY
68794: EQUAL
68795: OR
68796: IFFALSE 68741
// if not control in _control then
68798: LD_VAR 0 4
68802: PUSH
68803: LD_VAR 0 12
68807: IN
68808: NOT
68809: IFFALSE 68835
// control := _control [ rand ( 1 , _control ) ] ;
68811: LD_ADDR_VAR 0 4
68815: PUSH
68816: LD_VAR 0 12
68820: PUSH
68821: LD_INT 1
68823: PPUSH
68824: LD_VAR 0 12
68828: PPUSH
68829: CALL_OW 12
68833: ARRAY
68834: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68835: LD_VAR 0 2
68839: PPUSH
68840: LD_VAR 0 5
68844: PPUSH
68845: CALL 69203 0 2
68849: NOT
68850: IFFALSE 68909
// repeat weapon := _weapon [ 1 ] ;
68852: LD_ADDR_VAR 0 5
68856: PUSH
68857: LD_VAR 0 10
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68866: LD_ADDR_VAR 0 10
68870: PUSH
68871: LD_VAR 0 10
68875: PPUSH
68876: LD_INT 1
68878: PPUSH
68879: CALL_OW 3
68883: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68884: LD_VAR 0 2
68888: PPUSH
68889: LD_VAR 0 5
68893: PPUSH
68894: CALL 69203 0 2
68898: PUSH
68899: LD_VAR 0 10
68903: PUSH
68904: EMPTY
68905: EQUAL
68906: OR
68907: IFFALSE 68852
// result := [ ] ;
68909: LD_ADDR_VAR 0 6
68913: PUSH
68914: EMPTY
68915: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68916: LD_VAR 0 1
68920: PPUSH
68921: LD_VAR 0 2
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: LD_VAR 0 4
68935: PPUSH
68936: LD_VAR 0 5
68940: PPUSH
68941: CALL_OW 448
68945: IFFALSE 68978
// result := [ chassis , engine , control , weapon ] ;
68947: LD_ADDR_VAR 0 6
68951: PUSH
68952: LD_VAR 0 2
68956: PUSH
68957: LD_VAR 0 3
68961: PUSH
68962: LD_VAR 0 4
68966: PUSH
68967: LD_VAR 0 5
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: ST_TO_ADDR
// end ;
68978: LD_VAR 0 6
68982: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68983: LD_INT 0
68985: PPUSH
// if not chassis or not engine then
68986: LD_VAR 0 1
68990: NOT
68991: PUSH
68992: LD_VAR 0 2
68996: NOT
68997: OR
68998: IFFALSE 69002
// exit ;
69000: GO 69198
// case engine of engine_solar :
69002: LD_VAR 0 2
69006: PUSH
69007: LD_INT 2
69009: DOUBLE
69010: EQUAL
69011: IFTRUE 69015
69013: GO 69053
69015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_INT 11
69023: PUSH
69024: LD_INT 12
69026: PUSH
69027: LD_INT 13
69029: PUSH
69030: LD_INT 14
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: ST_TO_ADDR
69051: GO 69182
69053: LD_INT 1
69055: DOUBLE
69056: EQUAL
69057: IFTRUE 69061
69059: GO 69123
69061: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69062: LD_ADDR_VAR 0 3
69066: PUSH
69067: LD_INT 11
69069: PUSH
69070: LD_INT 12
69072: PUSH
69073: LD_INT 13
69075: PUSH
69076: LD_INT 14
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: LD_INT 2
69084: PUSH
69085: LD_INT 3
69087: PUSH
69088: LD_INT 4
69090: PUSH
69091: LD_INT 5
69093: PUSH
69094: LD_INT 21
69096: PUSH
69097: LD_INT 23
69099: PUSH
69100: LD_INT 22
69102: PUSH
69103: LD_INT 24
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: ST_TO_ADDR
69121: GO 69182
69123: LD_INT 3
69125: DOUBLE
69126: EQUAL
69127: IFTRUE 69131
69129: GO 69181
69131: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69132: LD_ADDR_VAR 0 3
69136: PUSH
69137: LD_INT 13
69139: PUSH
69140: LD_INT 14
69142: PUSH
69143: LD_INT 2
69145: PUSH
69146: LD_INT 3
69148: PUSH
69149: LD_INT 4
69151: PUSH
69152: LD_INT 5
69154: PUSH
69155: LD_INT 21
69157: PUSH
69158: LD_INT 22
69160: PUSH
69161: LD_INT 23
69163: PUSH
69164: LD_INT 24
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: ST_TO_ADDR
69179: GO 69182
69181: POP
// result := ( chassis in result ) ;
69182: LD_ADDR_VAR 0 3
69186: PUSH
69187: LD_VAR 0 1
69191: PUSH
69192: LD_VAR 0 3
69196: IN
69197: ST_TO_ADDR
// end ;
69198: LD_VAR 0 3
69202: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69203: LD_INT 0
69205: PPUSH
// if not chassis or not weapon then
69206: LD_VAR 0 1
69210: NOT
69211: PUSH
69212: LD_VAR 0 2
69216: NOT
69217: OR
69218: IFFALSE 69222
// exit ;
69220: GO 70282
// case weapon of us_machine_gun :
69222: LD_VAR 0 2
69226: PUSH
69227: LD_INT 2
69229: DOUBLE
69230: EQUAL
69231: IFTRUE 69235
69233: GO 69265
69235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69236: LD_ADDR_VAR 0 3
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: LD_INT 2
69246: PUSH
69247: LD_INT 3
69249: PUSH
69250: LD_INT 4
69252: PUSH
69253: LD_INT 5
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: ST_TO_ADDR
69263: GO 70266
69265: LD_INT 3
69267: DOUBLE
69268: EQUAL
69269: IFTRUE 69273
69271: GO 69303
69273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69274: LD_ADDR_VAR 0 3
69278: PUSH
69279: LD_INT 1
69281: PUSH
69282: LD_INT 2
69284: PUSH
69285: LD_INT 3
69287: PUSH
69288: LD_INT 4
69290: PUSH
69291: LD_INT 5
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: ST_TO_ADDR
69301: GO 70266
69303: LD_INT 11
69305: DOUBLE
69306: EQUAL
69307: IFTRUE 69311
69309: GO 69341
69311: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: LD_INT 3
69325: PUSH
69326: LD_INT 4
69328: PUSH
69329: LD_INT 5
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
69339: GO 70266
69341: LD_INT 4
69343: DOUBLE
69344: EQUAL
69345: IFTRUE 69349
69347: GO 69375
69349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69350: LD_ADDR_VAR 0 3
69354: PUSH
69355: LD_INT 2
69357: PUSH
69358: LD_INT 3
69360: PUSH
69361: LD_INT 4
69363: PUSH
69364: LD_INT 5
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
69373: GO 70266
69375: LD_INT 5
69377: DOUBLE
69378: EQUAL
69379: IFTRUE 69383
69381: GO 69409
69383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69384: LD_ADDR_VAR 0 3
69388: PUSH
69389: LD_INT 2
69391: PUSH
69392: LD_INT 3
69394: PUSH
69395: LD_INT 4
69397: PUSH
69398: LD_INT 5
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: ST_TO_ADDR
69407: GO 70266
69409: LD_INT 9
69411: DOUBLE
69412: EQUAL
69413: IFTRUE 69417
69415: GO 69443
69417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69418: LD_ADDR_VAR 0 3
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 3
69428: PUSH
69429: LD_INT 4
69431: PUSH
69432: LD_INT 5
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: ST_TO_ADDR
69441: GO 70266
69443: LD_INT 7
69445: DOUBLE
69446: EQUAL
69447: IFTRUE 69451
69449: GO 69477
69451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69452: LD_ADDR_VAR 0 3
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: LD_INT 3
69462: PUSH
69463: LD_INT 4
69465: PUSH
69466: LD_INT 5
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: ST_TO_ADDR
69475: GO 70266
69477: LD_INT 12
69479: DOUBLE
69480: EQUAL
69481: IFTRUE 69485
69483: GO 69511
69485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69486: LD_ADDR_VAR 0 3
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 3
69496: PUSH
69497: LD_INT 4
69499: PUSH
69500: LD_INT 5
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: ST_TO_ADDR
69509: GO 70266
69511: LD_INT 13
69513: DOUBLE
69514: EQUAL
69515: IFTRUE 69519
69517: GO 69545
69519: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69520: LD_ADDR_VAR 0 3
69524: PUSH
69525: LD_INT 2
69527: PUSH
69528: LD_INT 3
69530: PUSH
69531: LD_INT 4
69533: PUSH
69534: LD_INT 5
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: ST_TO_ADDR
69543: GO 70266
69545: LD_INT 14
69547: DOUBLE
69548: EQUAL
69549: IFTRUE 69553
69551: GO 69571
69553: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69554: LD_ADDR_VAR 0 3
69558: PUSH
69559: LD_INT 4
69561: PUSH
69562: LD_INT 5
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: ST_TO_ADDR
69569: GO 70266
69571: LD_INT 6
69573: DOUBLE
69574: EQUAL
69575: IFTRUE 69579
69577: GO 69597
69579: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69580: LD_ADDR_VAR 0 3
69584: PUSH
69585: LD_INT 4
69587: PUSH
69588: LD_INT 5
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: ST_TO_ADDR
69595: GO 70266
69597: LD_INT 10
69599: DOUBLE
69600: EQUAL
69601: IFTRUE 69605
69603: GO 69623
69605: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69606: LD_ADDR_VAR 0 3
69610: PUSH
69611: LD_INT 4
69613: PUSH
69614: LD_INT 5
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: ST_TO_ADDR
69621: GO 70266
69623: LD_INT 22
69625: DOUBLE
69626: EQUAL
69627: IFTRUE 69631
69629: GO 69657
69631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69632: LD_ADDR_VAR 0 3
69636: PUSH
69637: LD_INT 11
69639: PUSH
69640: LD_INT 12
69642: PUSH
69643: LD_INT 13
69645: PUSH
69646: LD_INT 14
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: ST_TO_ADDR
69655: GO 70266
69657: LD_INT 23
69659: DOUBLE
69660: EQUAL
69661: IFTRUE 69665
69663: GO 69691
69665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69666: LD_ADDR_VAR 0 3
69670: PUSH
69671: LD_INT 11
69673: PUSH
69674: LD_INT 12
69676: PUSH
69677: LD_INT 13
69679: PUSH
69680: LD_INT 14
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: ST_TO_ADDR
69689: GO 70266
69691: LD_INT 24
69693: DOUBLE
69694: EQUAL
69695: IFTRUE 69699
69697: GO 69725
69699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69700: LD_ADDR_VAR 0 3
69704: PUSH
69705: LD_INT 11
69707: PUSH
69708: LD_INT 12
69710: PUSH
69711: LD_INT 13
69713: PUSH
69714: LD_INT 14
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: ST_TO_ADDR
69723: GO 70266
69725: LD_INT 30
69727: DOUBLE
69728: EQUAL
69729: IFTRUE 69733
69731: GO 69759
69733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69734: LD_ADDR_VAR 0 3
69738: PUSH
69739: LD_INT 11
69741: PUSH
69742: LD_INT 12
69744: PUSH
69745: LD_INT 13
69747: PUSH
69748: LD_INT 14
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: ST_TO_ADDR
69757: GO 70266
69759: LD_INT 25
69761: DOUBLE
69762: EQUAL
69763: IFTRUE 69767
69765: GO 69785
69767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69768: LD_ADDR_VAR 0 3
69772: PUSH
69773: LD_INT 13
69775: PUSH
69776: LD_INT 14
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: ST_TO_ADDR
69783: GO 70266
69785: LD_INT 27
69787: DOUBLE
69788: EQUAL
69789: IFTRUE 69793
69791: GO 69811
69793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69794: LD_ADDR_VAR 0 3
69798: PUSH
69799: LD_INT 13
69801: PUSH
69802: LD_INT 14
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: ST_TO_ADDR
69809: GO 70266
69811: LD_INT 92
69813: DOUBLE
69814: EQUAL
69815: IFTRUE 69819
69817: GO 69845
69819: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69820: LD_ADDR_VAR 0 3
69824: PUSH
69825: LD_INT 11
69827: PUSH
69828: LD_INT 12
69830: PUSH
69831: LD_INT 13
69833: PUSH
69834: LD_INT 14
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: ST_TO_ADDR
69843: GO 70266
69845: LD_INT 28
69847: DOUBLE
69848: EQUAL
69849: IFTRUE 69853
69851: GO 69871
69853: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69854: LD_ADDR_VAR 0 3
69858: PUSH
69859: LD_INT 13
69861: PUSH
69862: LD_INT 14
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: ST_TO_ADDR
69869: GO 70266
69871: LD_INT 29
69873: DOUBLE
69874: EQUAL
69875: IFTRUE 69879
69877: GO 69897
69879: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69880: LD_ADDR_VAR 0 3
69884: PUSH
69885: LD_INT 13
69887: PUSH
69888: LD_INT 14
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: ST_TO_ADDR
69895: GO 70266
69897: LD_INT 31
69899: DOUBLE
69900: EQUAL
69901: IFTRUE 69905
69903: GO 69923
69905: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69906: LD_ADDR_VAR 0 3
69910: PUSH
69911: LD_INT 13
69913: PUSH
69914: LD_INT 14
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: ST_TO_ADDR
69921: GO 70266
69923: LD_INT 26
69925: DOUBLE
69926: EQUAL
69927: IFTRUE 69931
69929: GO 69949
69931: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69932: LD_ADDR_VAR 0 3
69936: PUSH
69937: LD_INT 13
69939: PUSH
69940: LD_INT 14
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: ST_TO_ADDR
69947: GO 70266
69949: LD_INT 42
69951: DOUBLE
69952: EQUAL
69953: IFTRUE 69957
69955: GO 69983
69957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69958: LD_ADDR_VAR 0 3
69962: PUSH
69963: LD_INT 21
69965: PUSH
69966: LD_INT 22
69968: PUSH
69969: LD_INT 23
69971: PUSH
69972: LD_INT 24
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: ST_TO_ADDR
69981: GO 70266
69983: LD_INT 43
69985: DOUBLE
69986: EQUAL
69987: IFTRUE 69991
69989: GO 70017
69991: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69992: LD_ADDR_VAR 0 3
69996: PUSH
69997: LD_INT 21
69999: PUSH
70000: LD_INT 22
70002: PUSH
70003: LD_INT 23
70005: PUSH
70006: LD_INT 24
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: ST_TO_ADDR
70015: GO 70266
70017: LD_INT 44
70019: DOUBLE
70020: EQUAL
70021: IFTRUE 70025
70023: GO 70051
70025: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70026: LD_ADDR_VAR 0 3
70030: PUSH
70031: LD_INT 21
70033: PUSH
70034: LD_INT 22
70036: PUSH
70037: LD_INT 23
70039: PUSH
70040: LD_INT 24
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: ST_TO_ADDR
70049: GO 70266
70051: LD_INT 45
70053: DOUBLE
70054: EQUAL
70055: IFTRUE 70059
70057: GO 70085
70059: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70060: LD_ADDR_VAR 0 3
70064: PUSH
70065: LD_INT 21
70067: PUSH
70068: LD_INT 22
70070: PUSH
70071: LD_INT 23
70073: PUSH
70074: LD_INT 24
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: ST_TO_ADDR
70083: GO 70266
70085: LD_INT 49
70087: DOUBLE
70088: EQUAL
70089: IFTRUE 70093
70091: GO 70119
70093: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70094: LD_ADDR_VAR 0 3
70098: PUSH
70099: LD_INT 21
70101: PUSH
70102: LD_INT 22
70104: PUSH
70105: LD_INT 23
70107: PUSH
70108: LD_INT 24
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: LIST
70115: LIST
70116: ST_TO_ADDR
70117: GO 70266
70119: LD_INT 51
70121: DOUBLE
70122: EQUAL
70123: IFTRUE 70127
70125: GO 70153
70127: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70128: LD_ADDR_VAR 0 3
70132: PUSH
70133: LD_INT 21
70135: PUSH
70136: LD_INT 22
70138: PUSH
70139: LD_INT 23
70141: PUSH
70142: LD_INT 24
70144: PUSH
70145: EMPTY
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: ST_TO_ADDR
70151: GO 70266
70153: LD_INT 52
70155: DOUBLE
70156: EQUAL
70157: IFTRUE 70161
70159: GO 70187
70161: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70162: LD_ADDR_VAR 0 3
70166: PUSH
70167: LD_INT 21
70169: PUSH
70170: LD_INT 22
70172: PUSH
70173: LD_INT 23
70175: PUSH
70176: LD_INT 24
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: LIST
70183: LIST
70184: ST_TO_ADDR
70185: GO 70266
70187: LD_INT 53
70189: DOUBLE
70190: EQUAL
70191: IFTRUE 70195
70193: GO 70213
70195: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70196: LD_ADDR_VAR 0 3
70200: PUSH
70201: LD_INT 23
70203: PUSH
70204: LD_INT 24
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: ST_TO_ADDR
70211: GO 70266
70213: LD_INT 46
70215: DOUBLE
70216: EQUAL
70217: IFTRUE 70221
70219: GO 70239
70221: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70222: LD_ADDR_VAR 0 3
70226: PUSH
70227: LD_INT 23
70229: PUSH
70230: LD_INT 24
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: ST_TO_ADDR
70237: GO 70266
70239: LD_INT 47
70241: DOUBLE
70242: EQUAL
70243: IFTRUE 70247
70245: GO 70265
70247: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70248: LD_ADDR_VAR 0 3
70252: PUSH
70253: LD_INT 23
70255: PUSH
70256: LD_INT 24
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: ST_TO_ADDR
70263: GO 70266
70265: POP
// result := ( chassis in result ) ;
70266: LD_ADDR_VAR 0 3
70270: PUSH
70271: LD_VAR 0 1
70275: PUSH
70276: LD_VAR 0 3
70280: IN
70281: ST_TO_ADDR
// end ;
70282: LD_VAR 0 3
70286: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70287: LD_INT 0
70289: PPUSH
70290: PPUSH
70291: PPUSH
70292: PPUSH
70293: PPUSH
70294: PPUSH
70295: PPUSH
// result := array ;
70296: LD_ADDR_VAR 0 5
70300: PUSH
70301: LD_VAR 0 1
70305: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70306: LD_VAR 0 1
70310: NOT
70311: PUSH
70312: LD_VAR 0 2
70316: NOT
70317: OR
70318: PUSH
70319: LD_VAR 0 3
70323: NOT
70324: OR
70325: PUSH
70326: LD_VAR 0 2
70330: PUSH
70331: LD_VAR 0 1
70335: GREATER
70336: OR
70337: PUSH
70338: LD_VAR 0 3
70342: PUSH
70343: LD_VAR 0 1
70347: GREATER
70348: OR
70349: IFFALSE 70353
// exit ;
70351: GO 70649
// if direction then
70353: LD_VAR 0 4
70357: IFFALSE 70421
// begin d := 1 ;
70359: LD_ADDR_VAR 0 9
70363: PUSH
70364: LD_INT 1
70366: ST_TO_ADDR
// if i_from > i_to then
70367: LD_VAR 0 2
70371: PUSH
70372: LD_VAR 0 3
70376: GREATER
70377: IFFALSE 70403
// length := ( array - i_from ) + i_to else
70379: LD_ADDR_VAR 0 11
70383: PUSH
70384: LD_VAR 0 1
70388: PUSH
70389: LD_VAR 0 2
70393: MINUS
70394: PUSH
70395: LD_VAR 0 3
70399: PLUS
70400: ST_TO_ADDR
70401: GO 70419
// length := i_to - i_from ;
70403: LD_ADDR_VAR 0 11
70407: PUSH
70408: LD_VAR 0 3
70412: PUSH
70413: LD_VAR 0 2
70417: MINUS
70418: ST_TO_ADDR
// end else
70419: GO 70482
// begin d := - 1 ;
70421: LD_ADDR_VAR 0 9
70425: PUSH
70426: LD_INT 1
70428: NEG
70429: ST_TO_ADDR
// if i_from > i_to then
70430: LD_VAR 0 2
70434: PUSH
70435: LD_VAR 0 3
70439: GREATER
70440: IFFALSE 70460
// length := i_from - i_to else
70442: LD_ADDR_VAR 0 11
70446: PUSH
70447: LD_VAR 0 2
70451: PUSH
70452: LD_VAR 0 3
70456: MINUS
70457: ST_TO_ADDR
70458: GO 70482
// length := ( array - i_to ) + i_from ;
70460: LD_ADDR_VAR 0 11
70464: PUSH
70465: LD_VAR 0 1
70469: PUSH
70470: LD_VAR 0 3
70474: MINUS
70475: PUSH
70476: LD_VAR 0 2
70480: PLUS
70481: ST_TO_ADDR
// end ; if not length then
70482: LD_VAR 0 11
70486: NOT
70487: IFFALSE 70491
// exit ;
70489: GO 70649
// tmp := array ;
70491: LD_ADDR_VAR 0 10
70495: PUSH
70496: LD_VAR 0 1
70500: ST_TO_ADDR
// for i = 1 to length do
70501: LD_ADDR_VAR 0 6
70505: PUSH
70506: DOUBLE
70507: LD_INT 1
70509: DEC
70510: ST_TO_ADDR
70511: LD_VAR 0 11
70515: PUSH
70516: FOR_TO
70517: IFFALSE 70637
// begin for j = 1 to array do
70519: LD_ADDR_VAR 0 7
70523: PUSH
70524: DOUBLE
70525: LD_INT 1
70527: DEC
70528: ST_TO_ADDR
70529: LD_VAR 0 1
70533: PUSH
70534: FOR_TO
70535: IFFALSE 70623
// begin k := j + d ;
70537: LD_ADDR_VAR 0 8
70541: PUSH
70542: LD_VAR 0 7
70546: PUSH
70547: LD_VAR 0 9
70551: PLUS
70552: ST_TO_ADDR
// if k > array then
70553: LD_VAR 0 8
70557: PUSH
70558: LD_VAR 0 1
70562: GREATER
70563: IFFALSE 70573
// k := 1 ;
70565: LD_ADDR_VAR 0 8
70569: PUSH
70570: LD_INT 1
70572: ST_TO_ADDR
// if not k then
70573: LD_VAR 0 8
70577: NOT
70578: IFFALSE 70590
// k := array ;
70580: LD_ADDR_VAR 0 8
70584: PUSH
70585: LD_VAR 0 1
70589: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70590: LD_ADDR_VAR 0 10
70594: PUSH
70595: LD_VAR 0 10
70599: PPUSH
70600: LD_VAR 0 8
70604: PPUSH
70605: LD_VAR 0 1
70609: PUSH
70610: LD_VAR 0 7
70614: ARRAY
70615: PPUSH
70616: CALL_OW 1
70620: ST_TO_ADDR
// end ;
70621: GO 70534
70623: POP
70624: POP
// array := tmp ;
70625: LD_ADDR_VAR 0 1
70629: PUSH
70630: LD_VAR 0 10
70634: ST_TO_ADDR
// end ;
70635: GO 70516
70637: POP
70638: POP
// result := array ;
70639: LD_ADDR_VAR 0 5
70643: PUSH
70644: LD_VAR 0 1
70648: ST_TO_ADDR
// end ;
70649: LD_VAR 0 5
70653: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70654: LD_INT 0
70656: PPUSH
70657: PPUSH
// result := 0 ;
70658: LD_ADDR_VAR 0 3
70662: PUSH
70663: LD_INT 0
70665: ST_TO_ADDR
// if not array or not value in array then
70666: LD_VAR 0 1
70670: NOT
70671: PUSH
70672: LD_VAR 0 2
70676: PUSH
70677: LD_VAR 0 1
70681: IN
70682: NOT
70683: OR
70684: IFFALSE 70688
// exit ;
70686: GO 70742
// for i = 1 to array do
70688: LD_ADDR_VAR 0 4
70692: PUSH
70693: DOUBLE
70694: LD_INT 1
70696: DEC
70697: ST_TO_ADDR
70698: LD_VAR 0 1
70702: PUSH
70703: FOR_TO
70704: IFFALSE 70740
// if value = array [ i ] then
70706: LD_VAR 0 2
70710: PUSH
70711: LD_VAR 0 1
70715: PUSH
70716: LD_VAR 0 4
70720: ARRAY
70721: EQUAL
70722: IFFALSE 70738
// begin result := i ;
70724: LD_ADDR_VAR 0 3
70728: PUSH
70729: LD_VAR 0 4
70733: ST_TO_ADDR
// exit ;
70734: POP
70735: POP
70736: GO 70742
// end ;
70738: GO 70703
70740: POP
70741: POP
// end ;
70742: LD_VAR 0 3
70746: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70747: LD_INT 0
70749: PPUSH
// vc_chassis := chassis ;
70750: LD_ADDR_OWVAR 37
70754: PUSH
70755: LD_VAR 0 1
70759: ST_TO_ADDR
// vc_engine := engine ;
70760: LD_ADDR_OWVAR 39
70764: PUSH
70765: LD_VAR 0 2
70769: ST_TO_ADDR
// vc_control := control ;
70770: LD_ADDR_OWVAR 38
70774: PUSH
70775: LD_VAR 0 3
70779: ST_TO_ADDR
// vc_weapon := weapon ;
70780: LD_ADDR_OWVAR 40
70784: PUSH
70785: LD_VAR 0 4
70789: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70790: LD_ADDR_OWVAR 41
70794: PUSH
70795: LD_VAR 0 5
70799: ST_TO_ADDR
// end ;
70800: LD_VAR 0 6
70804: RET
// export function WantPlant ( unit ) ; var task ; begin
70805: LD_INT 0
70807: PPUSH
70808: PPUSH
// result := false ;
70809: LD_ADDR_VAR 0 2
70813: PUSH
70814: LD_INT 0
70816: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70817: LD_ADDR_VAR 0 3
70821: PUSH
70822: LD_VAR 0 1
70826: PPUSH
70827: CALL_OW 437
70831: ST_TO_ADDR
// if task then
70832: LD_VAR 0 3
70836: IFFALSE 70864
// if task [ 1 ] [ 1 ] = p then
70838: LD_VAR 0 3
70842: PUSH
70843: LD_INT 1
70845: ARRAY
70846: PUSH
70847: LD_INT 1
70849: ARRAY
70850: PUSH
70851: LD_STRING p
70853: EQUAL
70854: IFFALSE 70864
// result := true ;
70856: LD_ADDR_VAR 0 2
70860: PUSH
70861: LD_INT 1
70863: ST_TO_ADDR
// end ;
70864: LD_VAR 0 2
70868: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70869: LD_INT 0
70871: PPUSH
70872: PPUSH
70873: PPUSH
70874: PPUSH
// if pos < 1 then
70875: LD_VAR 0 2
70879: PUSH
70880: LD_INT 1
70882: LESS
70883: IFFALSE 70887
// exit ;
70885: GO 71190
// if pos = 1 then
70887: LD_VAR 0 2
70891: PUSH
70892: LD_INT 1
70894: EQUAL
70895: IFFALSE 70928
// result := Replace ( arr , pos [ 1 ] , value ) else
70897: LD_ADDR_VAR 0 4
70901: PUSH
70902: LD_VAR 0 1
70906: PPUSH
70907: LD_VAR 0 2
70911: PUSH
70912: LD_INT 1
70914: ARRAY
70915: PPUSH
70916: LD_VAR 0 3
70920: PPUSH
70921: CALL_OW 1
70925: ST_TO_ADDR
70926: GO 71190
// begin tmp := arr ;
70928: LD_ADDR_VAR 0 6
70932: PUSH
70933: LD_VAR 0 1
70937: ST_TO_ADDR
// s_arr := [ tmp ] ;
70938: LD_ADDR_VAR 0 7
70942: PUSH
70943: LD_VAR 0 6
70947: PUSH
70948: EMPTY
70949: LIST
70950: ST_TO_ADDR
// for i = 1 to pos - 1 do
70951: LD_ADDR_VAR 0 5
70955: PUSH
70956: DOUBLE
70957: LD_INT 1
70959: DEC
70960: ST_TO_ADDR
70961: LD_VAR 0 2
70965: PUSH
70966: LD_INT 1
70968: MINUS
70969: PUSH
70970: FOR_TO
70971: IFFALSE 71016
// begin tmp := tmp [ pos [ i ] ] ;
70973: LD_ADDR_VAR 0 6
70977: PUSH
70978: LD_VAR 0 6
70982: PUSH
70983: LD_VAR 0 2
70987: PUSH
70988: LD_VAR 0 5
70992: ARRAY
70993: ARRAY
70994: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70995: LD_ADDR_VAR 0 7
70999: PUSH
71000: LD_VAR 0 7
71004: PUSH
71005: LD_VAR 0 6
71009: PUSH
71010: EMPTY
71011: LIST
71012: ADD
71013: ST_TO_ADDR
// end ;
71014: GO 70970
71016: POP
71017: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71018: LD_ADDR_VAR 0 6
71022: PUSH
71023: LD_VAR 0 6
71027: PPUSH
71028: LD_VAR 0 2
71032: PUSH
71033: LD_VAR 0 2
71037: ARRAY
71038: PPUSH
71039: LD_VAR 0 3
71043: PPUSH
71044: CALL_OW 1
71048: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71049: LD_ADDR_VAR 0 7
71053: PUSH
71054: LD_VAR 0 7
71058: PPUSH
71059: LD_VAR 0 7
71063: PPUSH
71064: LD_VAR 0 6
71068: PPUSH
71069: CALL_OW 1
71073: ST_TO_ADDR
// for i = s_arr downto 2 do
71074: LD_ADDR_VAR 0 5
71078: PUSH
71079: DOUBLE
71080: LD_VAR 0 7
71084: INC
71085: ST_TO_ADDR
71086: LD_INT 2
71088: PUSH
71089: FOR_DOWNTO
71090: IFFALSE 71174
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71092: LD_ADDR_VAR 0 6
71096: PUSH
71097: LD_VAR 0 7
71101: PUSH
71102: LD_VAR 0 5
71106: PUSH
71107: LD_INT 1
71109: MINUS
71110: ARRAY
71111: PPUSH
71112: LD_VAR 0 2
71116: PUSH
71117: LD_VAR 0 5
71121: PUSH
71122: LD_INT 1
71124: MINUS
71125: ARRAY
71126: PPUSH
71127: LD_VAR 0 7
71131: PUSH
71132: LD_VAR 0 5
71136: ARRAY
71137: PPUSH
71138: CALL_OW 1
71142: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71143: LD_ADDR_VAR 0 7
71147: PUSH
71148: LD_VAR 0 7
71152: PPUSH
71153: LD_VAR 0 5
71157: PUSH
71158: LD_INT 1
71160: MINUS
71161: PPUSH
71162: LD_VAR 0 6
71166: PPUSH
71167: CALL_OW 1
71171: ST_TO_ADDR
// end ;
71172: GO 71089
71174: POP
71175: POP
// result := s_arr [ 1 ] ;
71176: LD_ADDR_VAR 0 4
71180: PUSH
71181: LD_VAR 0 7
71185: PUSH
71186: LD_INT 1
71188: ARRAY
71189: ST_TO_ADDR
// end ; end ;
71190: LD_VAR 0 4
71194: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71195: LD_INT 0
71197: PPUSH
71198: PPUSH
// if not list then
71199: LD_VAR 0 1
71203: NOT
71204: IFFALSE 71208
// exit ;
71206: GO 71299
// i := list [ pos1 ] ;
71208: LD_ADDR_VAR 0 5
71212: PUSH
71213: LD_VAR 0 1
71217: PUSH
71218: LD_VAR 0 2
71222: ARRAY
71223: ST_TO_ADDR
// if not i then
71224: LD_VAR 0 5
71228: NOT
71229: IFFALSE 71233
// exit ;
71231: GO 71299
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71233: LD_ADDR_VAR 0 1
71237: PUSH
71238: LD_VAR 0 1
71242: PPUSH
71243: LD_VAR 0 2
71247: PPUSH
71248: LD_VAR 0 1
71252: PUSH
71253: LD_VAR 0 3
71257: ARRAY
71258: PPUSH
71259: CALL_OW 1
71263: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71264: LD_ADDR_VAR 0 1
71268: PUSH
71269: LD_VAR 0 1
71273: PPUSH
71274: LD_VAR 0 3
71278: PPUSH
71279: LD_VAR 0 5
71283: PPUSH
71284: CALL_OW 1
71288: ST_TO_ADDR
// result := list ;
71289: LD_ADDR_VAR 0 4
71293: PUSH
71294: LD_VAR 0 1
71298: ST_TO_ADDR
// end ;
71299: LD_VAR 0 4
71303: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71304: LD_INT 0
71306: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71307: LD_ADDR_VAR 0 5
71311: PUSH
71312: LD_VAR 0 1
71316: PPUSH
71317: CALL_OW 250
71321: PPUSH
71322: LD_VAR 0 1
71326: PPUSH
71327: CALL_OW 251
71331: PPUSH
71332: LD_VAR 0 2
71336: PPUSH
71337: LD_VAR 0 3
71341: PPUSH
71342: LD_VAR 0 4
71346: PPUSH
71347: CALL 71357 0 5
71351: ST_TO_ADDR
// end ;
71352: LD_VAR 0 5
71356: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71357: LD_INT 0
71359: PPUSH
71360: PPUSH
71361: PPUSH
71362: PPUSH
// if not list then
71363: LD_VAR 0 3
71367: NOT
71368: IFFALSE 71372
// exit ;
71370: GO 71760
// result := [ ] ;
71372: LD_ADDR_VAR 0 6
71376: PUSH
71377: EMPTY
71378: ST_TO_ADDR
// for i in list do
71379: LD_ADDR_VAR 0 7
71383: PUSH
71384: LD_VAR 0 3
71388: PUSH
71389: FOR_IN
71390: IFFALSE 71592
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71392: LD_ADDR_VAR 0 9
71396: PUSH
71397: LD_VAR 0 7
71401: PPUSH
71402: LD_VAR 0 1
71406: PPUSH
71407: LD_VAR 0 2
71411: PPUSH
71412: CALL_OW 297
71416: ST_TO_ADDR
// if not result then
71417: LD_VAR 0 6
71421: NOT
71422: IFFALSE 71448
// result := [ [ i , tmp ] ] else
71424: LD_ADDR_VAR 0 6
71428: PUSH
71429: LD_VAR 0 7
71433: PUSH
71434: LD_VAR 0 9
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: EMPTY
71444: LIST
71445: ST_TO_ADDR
71446: GO 71590
// begin if result [ result ] [ 2 ] < tmp then
71448: LD_VAR 0 6
71452: PUSH
71453: LD_VAR 0 6
71457: ARRAY
71458: PUSH
71459: LD_INT 2
71461: ARRAY
71462: PUSH
71463: LD_VAR 0 9
71467: LESS
71468: IFFALSE 71510
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71470: LD_ADDR_VAR 0 6
71474: PUSH
71475: LD_VAR 0 6
71479: PPUSH
71480: LD_VAR 0 6
71484: PUSH
71485: LD_INT 1
71487: PLUS
71488: PPUSH
71489: LD_VAR 0 7
71493: PUSH
71494: LD_VAR 0 9
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PPUSH
71503: CALL_OW 2
71507: ST_TO_ADDR
71508: GO 71590
// for j = 1 to result do
71510: LD_ADDR_VAR 0 8
71514: PUSH
71515: DOUBLE
71516: LD_INT 1
71518: DEC
71519: ST_TO_ADDR
71520: LD_VAR 0 6
71524: PUSH
71525: FOR_TO
71526: IFFALSE 71588
// begin if tmp < result [ j ] [ 2 ] then
71528: LD_VAR 0 9
71532: PUSH
71533: LD_VAR 0 6
71537: PUSH
71538: LD_VAR 0 8
71542: ARRAY
71543: PUSH
71544: LD_INT 2
71546: ARRAY
71547: LESS
71548: IFFALSE 71586
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71550: LD_ADDR_VAR 0 6
71554: PUSH
71555: LD_VAR 0 6
71559: PPUSH
71560: LD_VAR 0 8
71564: PPUSH
71565: LD_VAR 0 7
71569: PUSH
71570: LD_VAR 0 9
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PPUSH
71579: CALL_OW 2
71583: ST_TO_ADDR
// break ;
71584: GO 71588
// end ; end ;
71586: GO 71525
71588: POP
71589: POP
// end ; end ;
71590: GO 71389
71592: POP
71593: POP
// if result and not asc then
71594: LD_VAR 0 6
71598: PUSH
71599: LD_VAR 0 4
71603: NOT
71604: AND
71605: IFFALSE 71680
// begin tmp := result ;
71607: LD_ADDR_VAR 0 9
71611: PUSH
71612: LD_VAR 0 6
71616: ST_TO_ADDR
// for i = tmp downto 1 do
71617: LD_ADDR_VAR 0 7
71621: PUSH
71622: DOUBLE
71623: LD_VAR 0 9
71627: INC
71628: ST_TO_ADDR
71629: LD_INT 1
71631: PUSH
71632: FOR_DOWNTO
71633: IFFALSE 71678
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71635: LD_ADDR_VAR 0 6
71639: PUSH
71640: LD_VAR 0 6
71644: PPUSH
71645: LD_VAR 0 9
71649: PUSH
71650: LD_VAR 0 7
71654: MINUS
71655: PUSH
71656: LD_INT 1
71658: PLUS
71659: PPUSH
71660: LD_VAR 0 9
71664: PUSH
71665: LD_VAR 0 7
71669: ARRAY
71670: PPUSH
71671: CALL_OW 1
71675: ST_TO_ADDR
71676: GO 71632
71678: POP
71679: POP
// end ; tmp := [ ] ;
71680: LD_ADDR_VAR 0 9
71684: PUSH
71685: EMPTY
71686: ST_TO_ADDR
// if mode then
71687: LD_VAR 0 5
71691: IFFALSE 71760
// begin for i = 1 to result do
71693: LD_ADDR_VAR 0 7
71697: PUSH
71698: DOUBLE
71699: LD_INT 1
71701: DEC
71702: ST_TO_ADDR
71703: LD_VAR 0 6
71707: PUSH
71708: FOR_TO
71709: IFFALSE 71748
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71711: LD_ADDR_VAR 0 9
71715: PUSH
71716: LD_VAR 0 9
71720: PPUSH
71721: LD_VAR 0 7
71725: PPUSH
71726: LD_VAR 0 6
71730: PUSH
71731: LD_VAR 0 7
71735: ARRAY
71736: PUSH
71737: LD_INT 1
71739: ARRAY
71740: PPUSH
71741: CALL_OW 1
71745: ST_TO_ADDR
71746: GO 71708
71748: POP
71749: POP
// result := tmp ;
71750: LD_ADDR_VAR 0 6
71754: PUSH
71755: LD_VAR 0 9
71759: ST_TO_ADDR
// end ; end ;
71760: LD_VAR 0 6
71764: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71765: LD_INT 0
71767: PPUSH
71768: PPUSH
71769: PPUSH
71770: PPUSH
71771: PPUSH
71772: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71773: LD_ADDR_VAR 0 5
71777: PUSH
71778: LD_INT 0
71780: PUSH
71781: LD_INT 0
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: EMPTY
71788: PUSH
71789: EMPTY
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: ST_TO_ADDR
// if not x or not y then
71795: LD_VAR 0 2
71799: NOT
71800: PUSH
71801: LD_VAR 0 3
71805: NOT
71806: OR
71807: IFFALSE 71811
// exit ;
71809: GO 73461
// if not range then
71811: LD_VAR 0 4
71815: NOT
71816: IFFALSE 71826
// range := 10 ;
71818: LD_ADDR_VAR 0 4
71822: PUSH
71823: LD_INT 10
71825: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71826: LD_ADDR_VAR 0 8
71830: PUSH
71831: LD_INT 81
71833: PUSH
71834: LD_VAR 0 1
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 92
71845: PUSH
71846: LD_VAR 0 2
71850: PUSH
71851: LD_VAR 0 3
71855: PUSH
71856: LD_VAR 0 4
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 3
71869: PUSH
71870: LD_INT 21
71872: PUSH
71873: LD_INT 3
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: EMPTY
71885: LIST
71886: LIST
71887: LIST
71888: PPUSH
71889: CALL_OW 69
71893: ST_TO_ADDR
// if not tmp then
71894: LD_VAR 0 8
71898: NOT
71899: IFFALSE 71903
// exit ;
71901: GO 73461
// for i in tmp do
71903: LD_ADDR_VAR 0 6
71907: PUSH
71908: LD_VAR 0 8
71912: PUSH
71913: FOR_IN
71914: IFFALSE 73436
// begin points := [ 0 , 0 , 0 ] ;
71916: LD_ADDR_VAR 0 9
71920: PUSH
71921: LD_INT 0
71923: PUSH
71924: LD_INT 0
71926: PUSH
71927: LD_INT 0
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: LIST
71934: ST_TO_ADDR
// bpoints := 1 ;
71935: LD_ADDR_VAR 0 10
71939: PUSH
71940: LD_INT 1
71942: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71943: LD_VAR 0 6
71947: PPUSH
71948: CALL_OW 247
71952: PUSH
71953: LD_INT 1
71955: DOUBLE
71956: EQUAL
71957: IFTRUE 71961
71959: GO 72539
71961: POP
// begin if GetClass ( i ) = 1 then
71962: LD_VAR 0 6
71966: PPUSH
71967: CALL_OW 257
71971: PUSH
71972: LD_INT 1
71974: EQUAL
71975: IFFALSE 71996
// points := [ 10 , 5 , 3 ] ;
71977: LD_ADDR_VAR 0 9
71981: PUSH
71982: LD_INT 10
71984: PUSH
71985: LD_INT 5
71987: PUSH
71988: LD_INT 3
71990: PUSH
71991: EMPTY
71992: LIST
71993: LIST
71994: LIST
71995: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71996: LD_VAR 0 6
72000: PPUSH
72001: CALL_OW 257
72005: PUSH
72006: LD_INT 2
72008: PUSH
72009: LD_INT 3
72011: PUSH
72012: LD_INT 4
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: LIST
72019: IN
72020: IFFALSE 72041
// points := [ 3 , 2 , 1 ] ;
72022: LD_ADDR_VAR 0 9
72026: PUSH
72027: LD_INT 3
72029: PUSH
72030: LD_INT 2
72032: PUSH
72033: LD_INT 1
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: LIST
72040: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72041: LD_VAR 0 6
72045: PPUSH
72046: CALL_OW 257
72050: PUSH
72051: LD_INT 5
72053: EQUAL
72054: IFFALSE 72075
// points := [ 130 , 5 , 2 ] ;
72056: LD_ADDR_VAR 0 9
72060: PUSH
72061: LD_INT 130
72063: PUSH
72064: LD_INT 5
72066: PUSH
72067: LD_INT 2
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: LIST
72074: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72075: LD_VAR 0 6
72079: PPUSH
72080: CALL_OW 257
72084: PUSH
72085: LD_INT 8
72087: EQUAL
72088: IFFALSE 72109
// points := [ 35 , 35 , 30 ] ;
72090: LD_ADDR_VAR 0 9
72094: PUSH
72095: LD_INT 35
72097: PUSH
72098: LD_INT 35
72100: PUSH
72101: LD_INT 30
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: LIST
72108: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72109: LD_VAR 0 6
72113: PPUSH
72114: CALL_OW 257
72118: PUSH
72119: LD_INT 9
72121: EQUAL
72122: IFFALSE 72143
// points := [ 20 , 55 , 40 ] ;
72124: LD_ADDR_VAR 0 9
72128: PUSH
72129: LD_INT 20
72131: PUSH
72132: LD_INT 55
72134: PUSH
72135: LD_INT 40
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: LIST
72142: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72143: LD_VAR 0 6
72147: PPUSH
72148: CALL_OW 257
72152: PUSH
72153: LD_INT 12
72155: PUSH
72156: LD_INT 16
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: IN
72163: IFFALSE 72184
// points := [ 5 , 3 , 2 ] ;
72165: LD_ADDR_VAR 0 9
72169: PUSH
72170: LD_INT 5
72172: PUSH
72173: LD_INT 3
72175: PUSH
72176: LD_INT 2
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: LIST
72183: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72184: LD_VAR 0 6
72188: PPUSH
72189: CALL_OW 257
72193: PUSH
72194: LD_INT 17
72196: EQUAL
72197: IFFALSE 72218
// points := [ 100 , 50 , 75 ] ;
72199: LD_ADDR_VAR 0 9
72203: PUSH
72204: LD_INT 100
72206: PUSH
72207: LD_INT 50
72209: PUSH
72210: LD_INT 75
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: LIST
72217: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72218: LD_VAR 0 6
72222: PPUSH
72223: CALL_OW 257
72227: PUSH
72228: LD_INT 15
72230: EQUAL
72231: IFFALSE 72252
// points := [ 10 , 5 , 3 ] ;
72233: LD_ADDR_VAR 0 9
72237: PUSH
72238: LD_INT 10
72240: PUSH
72241: LD_INT 5
72243: PUSH
72244: LD_INT 3
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: LIST
72251: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72252: LD_VAR 0 6
72256: PPUSH
72257: CALL_OW 257
72261: PUSH
72262: LD_INT 14
72264: EQUAL
72265: IFFALSE 72286
// points := [ 10 , 0 , 0 ] ;
72267: LD_ADDR_VAR 0 9
72271: PUSH
72272: LD_INT 10
72274: PUSH
72275: LD_INT 0
72277: PUSH
72278: LD_INT 0
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: LIST
72285: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72286: LD_VAR 0 6
72290: PPUSH
72291: CALL_OW 257
72295: PUSH
72296: LD_INT 11
72298: EQUAL
72299: IFFALSE 72320
// points := [ 30 , 10 , 5 ] ;
72301: LD_ADDR_VAR 0 9
72305: PUSH
72306: LD_INT 30
72308: PUSH
72309: LD_INT 10
72311: PUSH
72312: LD_INT 5
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: LIST
72319: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72320: LD_VAR 0 1
72324: PPUSH
72325: LD_INT 5
72327: PPUSH
72328: CALL_OW 321
72332: PUSH
72333: LD_INT 2
72335: EQUAL
72336: IFFALSE 72353
// bpoints := bpoints * 1.8 ;
72338: LD_ADDR_VAR 0 10
72342: PUSH
72343: LD_VAR 0 10
72347: PUSH
72348: LD_REAL  1.80000000000000E+0000
72351: MUL
72352: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72353: LD_VAR 0 6
72357: PPUSH
72358: CALL_OW 257
72362: PUSH
72363: LD_INT 1
72365: PUSH
72366: LD_INT 2
72368: PUSH
72369: LD_INT 3
72371: PUSH
72372: LD_INT 4
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: IN
72381: PUSH
72382: LD_VAR 0 1
72386: PPUSH
72387: LD_INT 51
72389: PPUSH
72390: CALL_OW 321
72394: PUSH
72395: LD_INT 2
72397: EQUAL
72398: AND
72399: IFFALSE 72416
// bpoints := bpoints * 1.2 ;
72401: LD_ADDR_VAR 0 10
72405: PUSH
72406: LD_VAR 0 10
72410: PUSH
72411: LD_REAL  1.20000000000000E+0000
72414: MUL
72415: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72416: LD_VAR 0 6
72420: PPUSH
72421: CALL_OW 257
72425: PUSH
72426: LD_INT 5
72428: PUSH
72429: LD_INT 7
72431: PUSH
72432: LD_INT 9
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: LIST
72439: IN
72440: PUSH
72441: LD_VAR 0 1
72445: PPUSH
72446: LD_INT 52
72448: PPUSH
72449: CALL_OW 321
72453: PUSH
72454: LD_INT 2
72456: EQUAL
72457: AND
72458: IFFALSE 72475
// bpoints := bpoints * 1.5 ;
72460: LD_ADDR_VAR 0 10
72464: PUSH
72465: LD_VAR 0 10
72469: PUSH
72470: LD_REAL  1.50000000000000E+0000
72473: MUL
72474: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72475: LD_VAR 0 1
72479: PPUSH
72480: LD_INT 66
72482: PPUSH
72483: CALL_OW 321
72487: PUSH
72488: LD_INT 2
72490: EQUAL
72491: IFFALSE 72508
// bpoints := bpoints * 1.1 ;
72493: LD_ADDR_VAR 0 10
72497: PUSH
72498: LD_VAR 0 10
72502: PUSH
72503: LD_REAL  1.10000000000000E+0000
72506: MUL
72507: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72508: LD_ADDR_VAR 0 10
72512: PUSH
72513: LD_VAR 0 10
72517: PUSH
72518: LD_VAR 0 6
72522: PPUSH
72523: LD_INT 1
72525: PPUSH
72526: CALL_OW 259
72530: PUSH
72531: LD_REAL  1.15000000000000E+0000
72534: MUL
72535: MUL
72536: ST_TO_ADDR
// end ; unit_vehicle :
72537: GO 73365
72539: LD_INT 2
72541: DOUBLE
72542: EQUAL
72543: IFTRUE 72547
72545: GO 73353
72547: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72548: LD_VAR 0 6
72552: PPUSH
72553: CALL_OW 264
72557: PUSH
72558: LD_INT 2
72560: PUSH
72561: LD_INT 42
72563: PUSH
72564: LD_INT 24
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: LIST
72571: IN
72572: IFFALSE 72593
// points := [ 25 , 5 , 3 ] ;
72574: LD_ADDR_VAR 0 9
72578: PUSH
72579: LD_INT 25
72581: PUSH
72582: LD_INT 5
72584: PUSH
72585: LD_INT 3
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: LIST
72592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72593: LD_VAR 0 6
72597: PPUSH
72598: CALL_OW 264
72602: PUSH
72603: LD_INT 4
72605: PUSH
72606: LD_INT 43
72608: PUSH
72609: LD_INT 25
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: LIST
72616: IN
72617: IFFALSE 72638
// points := [ 40 , 15 , 5 ] ;
72619: LD_ADDR_VAR 0 9
72623: PUSH
72624: LD_INT 40
72626: PUSH
72627: LD_INT 15
72629: PUSH
72630: LD_INT 5
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: LIST
72637: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72638: LD_VAR 0 6
72642: PPUSH
72643: CALL_OW 264
72647: PUSH
72648: LD_INT 3
72650: PUSH
72651: LD_INT 23
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: IN
72658: IFFALSE 72679
// points := [ 7 , 25 , 8 ] ;
72660: LD_ADDR_VAR 0 9
72664: PUSH
72665: LD_INT 7
72667: PUSH
72668: LD_INT 25
72670: PUSH
72671: LD_INT 8
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72679: LD_VAR 0 6
72683: PPUSH
72684: CALL_OW 264
72688: PUSH
72689: LD_INT 5
72691: PUSH
72692: LD_INT 27
72694: PUSH
72695: LD_INT 44
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: LIST
72702: IN
72703: IFFALSE 72724
// points := [ 14 , 50 , 16 ] ;
72705: LD_ADDR_VAR 0 9
72709: PUSH
72710: LD_INT 14
72712: PUSH
72713: LD_INT 50
72715: PUSH
72716: LD_INT 16
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: LIST
72723: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72724: LD_VAR 0 6
72728: PPUSH
72729: CALL_OW 264
72733: PUSH
72734: LD_INT 6
72736: PUSH
72737: LD_INT 46
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: IN
72744: IFFALSE 72765
// points := [ 32 , 120 , 70 ] ;
72746: LD_ADDR_VAR 0 9
72750: PUSH
72751: LD_INT 32
72753: PUSH
72754: LD_INT 120
72756: PUSH
72757: LD_INT 70
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: LIST
72764: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72765: LD_VAR 0 6
72769: PPUSH
72770: CALL_OW 264
72774: PUSH
72775: LD_INT 7
72777: PUSH
72778: LD_INT 28
72780: PUSH
72781: LD_INT 45
72783: PUSH
72784: LD_INT 92
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: IN
72793: IFFALSE 72814
// points := [ 35 , 20 , 45 ] ;
72795: LD_ADDR_VAR 0 9
72799: PUSH
72800: LD_INT 35
72802: PUSH
72803: LD_INT 20
72805: PUSH
72806: LD_INT 45
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: LIST
72813: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72814: LD_VAR 0 6
72818: PPUSH
72819: CALL_OW 264
72823: PUSH
72824: LD_INT 47
72826: PUSH
72827: EMPTY
72828: LIST
72829: IN
72830: IFFALSE 72851
// points := [ 67 , 45 , 75 ] ;
72832: LD_ADDR_VAR 0 9
72836: PUSH
72837: LD_INT 67
72839: PUSH
72840: LD_INT 45
72842: PUSH
72843: LD_INT 75
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: LIST
72850: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72851: LD_VAR 0 6
72855: PPUSH
72856: CALL_OW 264
72860: PUSH
72861: LD_INT 26
72863: PUSH
72864: EMPTY
72865: LIST
72866: IN
72867: IFFALSE 72888
// points := [ 120 , 30 , 80 ] ;
72869: LD_ADDR_VAR 0 9
72873: PUSH
72874: LD_INT 120
72876: PUSH
72877: LD_INT 30
72879: PUSH
72880: LD_INT 80
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: LIST
72887: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72888: LD_VAR 0 6
72892: PPUSH
72893: CALL_OW 264
72897: PUSH
72898: LD_INT 22
72900: PUSH
72901: EMPTY
72902: LIST
72903: IN
72904: IFFALSE 72925
// points := [ 40 , 1 , 1 ] ;
72906: LD_ADDR_VAR 0 9
72910: PUSH
72911: LD_INT 40
72913: PUSH
72914: LD_INT 1
72916: PUSH
72917: LD_INT 1
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72925: LD_VAR 0 6
72929: PPUSH
72930: CALL_OW 264
72934: PUSH
72935: LD_INT 29
72937: PUSH
72938: EMPTY
72939: LIST
72940: IN
72941: IFFALSE 72962
// points := [ 70 , 200 , 400 ] ;
72943: LD_ADDR_VAR 0 9
72947: PUSH
72948: LD_INT 70
72950: PUSH
72951: LD_INT 200
72953: PUSH
72954: LD_INT 400
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: LIST
72961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72962: LD_VAR 0 6
72966: PPUSH
72967: CALL_OW 264
72971: PUSH
72972: LD_INT 14
72974: PUSH
72975: LD_INT 53
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: IN
72982: IFFALSE 73003
// points := [ 40 , 10 , 20 ] ;
72984: LD_ADDR_VAR 0 9
72988: PUSH
72989: LD_INT 40
72991: PUSH
72992: LD_INT 10
72994: PUSH
72995: LD_INT 20
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: LIST
73002: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73003: LD_VAR 0 6
73007: PPUSH
73008: CALL_OW 264
73012: PUSH
73013: LD_INT 9
73015: PUSH
73016: EMPTY
73017: LIST
73018: IN
73019: IFFALSE 73040
// points := [ 5 , 70 , 20 ] ;
73021: LD_ADDR_VAR 0 9
73025: PUSH
73026: LD_INT 5
73028: PUSH
73029: LD_INT 70
73031: PUSH
73032: LD_INT 20
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: LIST
73039: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73040: LD_VAR 0 6
73044: PPUSH
73045: CALL_OW 264
73049: PUSH
73050: LD_INT 10
73052: PUSH
73053: EMPTY
73054: LIST
73055: IN
73056: IFFALSE 73077
// points := [ 35 , 110 , 70 ] ;
73058: LD_ADDR_VAR 0 9
73062: PUSH
73063: LD_INT 35
73065: PUSH
73066: LD_INT 110
73068: PUSH
73069: LD_INT 70
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: LIST
73076: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73077: LD_VAR 0 6
73081: PPUSH
73082: CALL_OW 265
73086: PUSH
73087: LD_INT 25
73089: EQUAL
73090: IFFALSE 73111
// points := [ 80 , 65 , 100 ] ;
73092: LD_ADDR_VAR 0 9
73096: PUSH
73097: LD_INT 80
73099: PUSH
73100: LD_INT 65
73102: PUSH
73103: LD_INT 100
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: LIST
73110: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73111: LD_VAR 0 6
73115: PPUSH
73116: CALL_OW 263
73120: PUSH
73121: LD_INT 1
73123: EQUAL
73124: IFFALSE 73159
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73126: LD_ADDR_VAR 0 10
73130: PUSH
73131: LD_VAR 0 10
73135: PUSH
73136: LD_VAR 0 6
73140: PPUSH
73141: CALL_OW 311
73145: PPUSH
73146: LD_INT 3
73148: PPUSH
73149: CALL_OW 259
73153: PUSH
73154: LD_INT 4
73156: MUL
73157: MUL
73158: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73159: LD_VAR 0 6
73163: PPUSH
73164: CALL_OW 263
73168: PUSH
73169: LD_INT 2
73171: EQUAL
73172: IFFALSE 73223
// begin j := IsControledBy ( i ) ;
73174: LD_ADDR_VAR 0 7
73178: PUSH
73179: LD_VAR 0 6
73183: PPUSH
73184: CALL_OW 312
73188: ST_TO_ADDR
// if j then
73189: LD_VAR 0 7
73193: IFFALSE 73223
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73195: LD_ADDR_VAR 0 10
73199: PUSH
73200: LD_VAR 0 10
73204: PUSH
73205: LD_VAR 0 7
73209: PPUSH
73210: LD_INT 3
73212: PPUSH
73213: CALL_OW 259
73217: PUSH
73218: LD_INT 3
73220: MUL
73221: MUL
73222: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73223: LD_VAR 0 6
73227: PPUSH
73228: CALL_OW 264
73232: PUSH
73233: LD_INT 5
73235: PUSH
73236: LD_INT 6
73238: PUSH
73239: LD_INT 46
73241: PUSH
73242: LD_INT 44
73244: PUSH
73245: LD_INT 47
73247: PUSH
73248: LD_INT 45
73250: PUSH
73251: LD_INT 28
73253: PUSH
73254: LD_INT 7
73256: PUSH
73257: LD_INT 27
73259: PUSH
73260: LD_INT 29
73262: PUSH
73263: EMPTY
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: IN
73275: PUSH
73276: LD_VAR 0 1
73280: PPUSH
73281: LD_INT 52
73283: PPUSH
73284: CALL_OW 321
73288: PUSH
73289: LD_INT 2
73291: EQUAL
73292: AND
73293: IFFALSE 73310
// bpoints := bpoints * 1.2 ;
73295: LD_ADDR_VAR 0 10
73299: PUSH
73300: LD_VAR 0 10
73304: PUSH
73305: LD_REAL  1.20000000000000E+0000
73308: MUL
73309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73310: LD_VAR 0 6
73314: PPUSH
73315: CALL_OW 264
73319: PUSH
73320: LD_INT 6
73322: PUSH
73323: LD_INT 46
73325: PUSH
73326: LD_INT 47
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: LIST
73333: IN
73334: IFFALSE 73351
// bpoints := bpoints * 1.2 ;
73336: LD_ADDR_VAR 0 10
73340: PUSH
73341: LD_VAR 0 10
73345: PUSH
73346: LD_REAL  1.20000000000000E+0000
73349: MUL
73350: ST_TO_ADDR
// end ; unit_building :
73351: GO 73365
73353: LD_INT 3
73355: DOUBLE
73356: EQUAL
73357: IFTRUE 73361
73359: GO 73364
73361: POP
// ; end ;
73362: GO 73365
73364: POP
// for j = 1 to 3 do
73365: LD_ADDR_VAR 0 7
73369: PUSH
73370: DOUBLE
73371: LD_INT 1
73373: DEC
73374: ST_TO_ADDR
73375: LD_INT 3
73377: PUSH
73378: FOR_TO
73379: IFFALSE 73432
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73381: LD_ADDR_VAR 0 5
73385: PUSH
73386: LD_VAR 0 5
73390: PPUSH
73391: LD_VAR 0 7
73395: PPUSH
73396: LD_VAR 0 5
73400: PUSH
73401: LD_VAR 0 7
73405: ARRAY
73406: PUSH
73407: LD_VAR 0 9
73411: PUSH
73412: LD_VAR 0 7
73416: ARRAY
73417: PUSH
73418: LD_VAR 0 10
73422: MUL
73423: PLUS
73424: PPUSH
73425: CALL_OW 1
73429: ST_TO_ADDR
73430: GO 73378
73432: POP
73433: POP
// end ;
73434: GO 71913
73436: POP
73437: POP
// result := Replace ( result , 4 , tmp ) ;
73438: LD_ADDR_VAR 0 5
73442: PUSH
73443: LD_VAR 0 5
73447: PPUSH
73448: LD_INT 4
73450: PPUSH
73451: LD_VAR 0 8
73455: PPUSH
73456: CALL_OW 1
73460: ST_TO_ADDR
// end ;
73461: LD_VAR 0 5
73465: RET
// export function DangerAtRange ( unit , range ) ; begin
73466: LD_INT 0
73468: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73469: LD_ADDR_VAR 0 3
73473: PUSH
73474: LD_VAR 0 1
73478: PPUSH
73479: CALL_OW 255
73483: PPUSH
73484: LD_VAR 0 1
73488: PPUSH
73489: CALL_OW 250
73493: PPUSH
73494: LD_VAR 0 1
73498: PPUSH
73499: CALL_OW 251
73503: PPUSH
73504: LD_VAR 0 2
73508: PPUSH
73509: CALL 71765 0 4
73513: ST_TO_ADDR
// end ;
73514: LD_VAR 0 3
73518: RET
// export function DangerInArea ( side , area ) ; begin
73519: LD_INT 0
73521: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73522: LD_ADDR_VAR 0 3
73526: PUSH
73527: LD_VAR 0 2
73531: PPUSH
73532: LD_INT 81
73534: PUSH
73535: LD_VAR 0 1
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PPUSH
73544: CALL_OW 70
73548: ST_TO_ADDR
// end ;
73549: LD_VAR 0 3
73553: RET
// export function IsExtension ( b ) ; begin
73554: LD_INT 0
73556: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73557: LD_ADDR_VAR 0 2
73561: PUSH
73562: LD_VAR 0 1
73566: PUSH
73567: LD_INT 23
73569: PUSH
73570: LD_INT 20
73572: PUSH
73573: LD_INT 22
73575: PUSH
73576: LD_INT 17
73578: PUSH
73579: LD_INT 24
73581: PUSH
73582: LD_INT 21
73584: PUSH
73585: LD_INT 19
73587: PUSH
73588: LD_INT 16
73590: PUSH
73591: LD_INT 25
73593: PUSH
73594: LD_INT 18
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: IN
73609: ST_TO_ADDR
// end ;
73610: LD_VAR 0 2
73614: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73615: LD_INT 0
73617: PPUSH
73618: PPUSH
73619: PPUSH
// result := [ ] ;
73620: LD_ADDR_VAR 0 4
73624: PUSH
73625: EMPTY
73626: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73627: LD_ADDR_VAR 0 5
73631: PUSH
73632: LD_VAR 0 2
73636: PPUSH
73637: LD_INT 21
73639: PUSH
73640: LD_INT 3
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: PPUSH
73647: CALL_OW 70
73651: ST_TO_ADDR
// if not tmp then
73652: LD_VAR 0 5
73656: NOT
73657: IFFALSE 73661
// exit ;
73659: GO 73725
// if checkLink then
73661: LD_VAR 0 3
73665: IFFALSE 73715
// begin for i in tmp do
73667: LD_ADDR_VAR 0 6
73671: PUSH
73672: LD_VAR 0 5
73676: PUSH
73677: FOR_IN
73678: IFFALSE 73713
// if GetBase ( i ) <> base then
73680: LD_VAR 0 6
73684: PPUSH
73685: CALL_OW 274
73689: PUSH
73690: LD_VAR 0 1
73694: NONEQUAL
73695: IFFALSE 73711
// ComLinkToBase ( base , i ) ;
73697: LD_VAR 0 1
73701: PPUSH
73702: LD_VAR 0 6
73706: PPUSH
73707: CALL_OW 169
73711: GO 73677
73713: POP
73714: POP
// end ; result := tmp ;
73715: LD_ADDR_VAR 0 4
73719: PUSH
73720: LD_VAR 0 5
73724: ST_TO_ADDR
// end ;
73725: LD_VAR 0 4
73729: RET
// export function ComComplete ( units , b ) ; var i ; begin
73730: LD_INT 0
73732: PPUSH
73733: PPUSH
// if not units then
73734: LD_VAR 0 1
73738: NOT
73739: IFFALSE 73743
// exit ;
73741: GO 73833
// for i in units do
73743: LD_ADDR_VAR 0 4
73747: PUSH
73748: LD_VAR 0 1
73752: PUSH
73753: FOR_IN
73754: IFFALSE 73831
// if BuildingStatus ( b ) = bs_build then
73756: LD_VAR 0 2
73760: PPUSH
73761: CALL_OW 461
73765: PUSH
73766: LD_INT 1
73768: EQUAL
73769: IFFALSE 73829
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73771: LD_VAR 0 4
73775: PPUSH
73776: LD_STRING h
73778: PUSH
73779: LD_VAR 0 2
73783: PPUSH
73784: CALL_OW 250
73788: PUSH
73789: LD_VAR 0 2
73793: PPUSH
73794: CALL_OW 251
73798: PUSH
73799: LD_VAR 0 2
73803: PUSH
73804: LD_INT 0
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: LD_INT 0
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: PUSH
73822: EMPTY
73823: LIST
73824: PPUSH
73825: CALL_OW 446
73829: GO 73753
73831: POP
73832: POP
// end ;
73833: LD_VAR 0 3
73837: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73838: LD_INT 0
73840: PPUSH
73841: PPUSH
73842: PPUSH
73843: PPUSH
73844: PPUSH
73845: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73846: LD_VAR 0 1
73850: NOT
73851: PUSH
73852: LD_VAR 0 1
73856: PPUSH
73857: CALL_OW 263
73861: PUSH
73862: LD_INT 2
73864: NONEQUAL
73865: OR
73866: IFFALSE 73870
// exit ;
73868: GO 74186
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73870: LD_ADDR_VAR 0 6
73874: PUSH
73875: LD_INT 22
73877: PUSH
73878: LD_VAR 0 1
73882: PPUSH
73883: CALL_OW 255
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 2
73894: PUSH
73895: LD_INT 30
73897: PUSH
73898: LD_INT 36
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 34
73907: PUSH
73908: LD_INT 31
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: LIST
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PPUSH
73924: CALL_OW 69
73928: ST_TO_ADDR
// if not tmp then
73929: LD_VAR 0 6
73933: NOT
73934: IFFALSE 73938
// exit ;
73936: GO 74186
// result := [ ] ;
73938: LD_ADDR_VAR 0 2
73942: PUSH
73943: EMPTY
73944: ST_TO_ADDR
// for i in tmp do
73945: LD_ADDR_VAR 0 3
73949: PUSH
73950: LD_VAR 0 6
73954: PUSH
73955: FOR_IN
73956: IFFALSE 74027
// begin t := UnitsInside ( i ) ;
73958: LD_ADDR_VAR 0 4
73962: PUSH
73963: LD_VAR 0 3
73967: PPUSH
73968: CALL_OW 313
73972: ST_TO_ADDR
// if t then
73973: LD_VAR 0 4
73977: IFFALSE 74025
// for j in t do
73979: LD_ADDR_VAR 0 7
73983: PUSH
73984: LD_VAR 0 4
73988: PUSH
73989: FOR_IN
73990: IFFALSE 74023
// result := Replace ( result , result + 1 , j ) ;
73992: LD_ADDR_VAR 0 2
73996: PUSH
73997: LD_VAR 0 2
74001: PPUSH
74002: LD_VAR 0 2
74006: PUSH
74007: LD_INT 1
74009: PLUS
74010: PPUSH
74011: LD_VAR 0 7
74015: PPUSH
74016: CALL_OW 1
74020: ST_TO_ADDR
74021: GO 73989
74023: POP
74024: POP
// end ;
74025: GO 73955
74027: POP
74028: POP
// if not result then
74029: LD_VAR 0 2
74033: NOT
74034: IFFALSE 74038
// exit ;
74036: GO 74186
// mech := result [ 1 ] ;
74038: LD_ADDR_VAR 0 5
74042: PUSH
74043: LD_VAR 0 2
74047: PUSH
74048: LD_INT 1
74050: ARRAY
74051: ST_TO_ADDR
// if result > 1 then
74052: LD_VAR 0 2
74056: PUSH
74057: LD_INT 1
74059: GREATER
74060: IFFALSE 74172
// begin for i = 2 to result do
74062: LD_ADDR_VAR 0 3
74066: PUSH
74067: DOUBLE
74068: LD_INT 2
74070: DEC
74071: ST_TO_ADDR
74072: LD_VAR 0 2
74076: PUSH
74077: FOR_TO
74078: IFFALSE 74170
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74080: LD_ADDR_VAR 0 4
74084: PUSH
74085: LD_VAR 0 2
74089: PUSH
74090: LD_VAR 0 3
74094: ARRAY
74095: PPUSH
74096: LD_INT 3
74098: PPUSH
74099: CALL_OW 259
74103: PUSH
74104: LD_VAR 0 2
74108: PUSH
74109: LD_VAR 0 3
74113: ARRAY
74114: PPUSH
74115: CALL_OW 432
74119: MINUS
74120: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74121: LD_VAR 0 4
74125: PUSH
74126: LD_VAR 0 5
74130: PPUSH
74131: LD_INT 3
74133: PPUSH
74134: CALL_OW 259
74138: PUSH
74139: LD_VAR 0 5
74143: PPUSH
74144: CALL_OW 432
74148: MINUS
74149: GREATEREQUAL
74150: IFFALSE 74168
// mech := result [ i ] ;
74152: LD_ADDR_VAR 0 5
74156: PUSH
74157: LD_VAR 0 2
74161: PUSH
74162: LD_VAR 0 3
74166: ARRAY
74167: ST_TO_ADDR
// end ;
74168: GO 74077
74170: POP
74171: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74172: LD_VAR 0 1
74176: PPUSH
74177: LD_VAR 0 5
74181: PPUSH
74182: CALL_OW 135
// end ;
74186: LD_VAR 0 2
74190: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74191: LD_INT 0
74193: PPUSH
74194: PPUSH
74195: PPUSH
74196: PPUSH
74197: PPUSH
74198: PPUSH
74199: PPUSH
74200: PPUSH
74201: PPUSH
74202: PPUSH
74203: PPUSH
74204: PPUSH
74205: PPUSH
// result := [ ] ;
74206: LD_ADDR_VAR 0 7
74210: PUSH
74211: EMPTY
74212: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74213: LD_VAR 0 1
74217: PPUSH
74218: CALL_OW 266
74222: PUSH
74223: LD_INT 0
74225: PUSH
74226: LD_INT 1
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: IN
74233: NOT
74234: IFFALSE 74238
// exit ;
74236: GO 75872
// if name then
74238: LD_VAR 0 3
74242: IFFALSE 74258
// SetBName ( base_dep , name ) ;
74244: LD_VAR 0 1
74248: PPUSH
74249: LD_VAR 0 3
74253: PPUSH
74254: CALL_OW 500
// base := GetBase ( base_dep ) ;
74258: LD_ADDR_VAR 0 15
74262: PUSH
74263: LD_VAR 0 1
74267: PPUSH
74268: CALL_OW 274
74272: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74273: LD_ADDR_VAR 0 16
74277: PUSH
74278: LD_VAR 0 1
74282: PPUSH
74283: CALL_OW 255
74287: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74288: LD_ADDR_VAR 0 17
74292: PUSH
74293: LD_VAR 0 1
74297: PPUSH
74298: CALL_OW 248
74302: ST_TO_ADDR
// if sources then
74303: LD_VAR 0 5
74307: IFFALSE 74354
// for i = 1 to 3 do
74309: LD_ADDR_VAR 0 8
74313: PUSH
74314: DOUBLE
74315: LD_INT 1
74317: DEC
74318: ST_TO_ADDR
74319: LD_INT 3
74321: PUSH
74322: FOR_TO
74323: IFFALSE 74352
// AddResourceType ( base , i , sources [ i ] ) ;
74325: LD_VAR 0 15
74329: PPUSH
74330: LD_VAR 0 8
74334: PPUSH
74335: LD_VAR 0 5
74339: PUSH
74340: LD_VAR 0 8
74344: ARRAY
74345: PPUSH
74346: CALL_OW 276
74350: GO 74322
74352: POP
74353: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74354: LD_ADDR_VAR 0 18
74358: PUSH
74359: LD_VAR 0 15
74363: PPUSH
74364: LD_VAR 0 2
74368: PPUSH
74369: LD_INT 1
74371: PPUSH
74372: CALL 73615 0 3
74376: ST_TO_ADDR
// InitHc ;
74377: CALL_OW 19
// InitUc ;
74381: CALL_OW 18
// uc_side := side ;
74385: LD_ADDR_OWVAR 20
74389: PUSH
74390: LD_VAR 0 16
74394: ST_TO_ADDR
// uc_nation := nation ;
74395: LD_ADDR_OWVAR 21
74399: PUSH
74400: LD_VAR 0 17
74404: ST_TO_ADDR
// if buildings then
74405: LD_VAR 0 18
74409: IFFALSE 75731
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74411: LD_ADDR_VAR 0 19
74415: PUSH
74416: LD_VAR 0 18
74420: PPUSH
74421: LD_INT 2
74423: PUSH
74424: LD_INT 30
74426: PUSH
74427: LD_INT 29
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 30
74436: PUSH
74437: LD_INT 30
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: LIST
74448: PPUSH
74449: CALL_OW 72
74453: ST_TO_ADDR
// if tmp then
74454: LD_VAR 0 19
74458: IFFALSE 74506
// for i in tmp do
74460: LD_ADDR_VAR 0 8
74464: PUSH
74465: LD_VAR 0 19
74469: PUSH
74470: FOR_IN
74471: IFFALSE 74504
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74473: LD_VAR 0 8
74477: PPUSH
74478: CALL_OW 250
74482: PPUSH
74483: LD_VAR 0 8
74487: PPUSH
74488: CALL_OW 251
74492: PPUSH
74493: LD_VAR 0 16
74497: PPUSH
74498: CALL_OW 441
74502: GO 74470
74504: POP
74505: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74506: LD_VAR 0 18
74510: PPUSH
74511: LD_INT 2
74513: PUSH
74514: LD_INT 30
74516: PUSH
74517: LD_INT 32
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 30
74526: PUSH
74527: LD_INT 33
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: LIST
74538: PPUSH
74539: CALL_OW 72
74543: IFFALSE 74631
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74545: LD_ADDR_VAR 0 8
74549: PUSH
74550: LD_VAR 0 18
74554: PPUSH
74555: LD_INT 2
74557: PUSH
74558: LD_INT 30
74560: PUSH
74561: LD_INT 32
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 30
74570: PUSH
74571: LD_INT 33
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: LIST
74582: PPUSH
74583: CALL_OW 72
74587: PUSH
74588: FOR_IN
74589: IFFALSE 74629
// begin if not GetBWeapon ( i ) then
74591: LD_VAR 0 8
74595: PPUSH
74596: CALL_OW 269
74600: NOT
74601: IFFALSE 74627
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74603: LD_VAR 0 8
74607: PPUSH
74608: LD_VAR 0 8
74612: PPUSH
74613: LD_VAR 0 2
74617: PPUSH
74618: CALL 75877 0 2
74622: PPUSH
74623: CALL_OW 431
// end ;
74627: GO 74588
74629: POP
74630: POP
// end ; for i = 1 to personel do
74631: LD_ADDR_VAR 0 8
74635: PUSH
74636: DOUBLE
74637: LD_INT 1
74639: DEC
74640: ST_TO_ADDR
74641: LD_VAR 0 6
74645: PUSH
74646: FOR_TO
74647: IFFALSE 75711
// begin if i > 4 then
74649: LD_VAR 0 8
74653: PUSH
74654: LD_INT 4
74656: GREATER
74657: IFFALSE 74661
// break ;
74659: GO 75711
// case i of 1 :
74661: LD_VAR 0 8
74665: PUSH
74666: LD_INT 1
74668: DOUBLE
74669: EQUAL
74670: IFTRUE 74674
74672: GO 74754
74674: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74675: LD_ADDR_VAR 0 12
74679: PUSH
74680: LD_VAR 0 18
74684: PPUSH
74685: LD_INT 22
74687: PUSH
74688: LD_VAR 0 16
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 58
74699: PUSH
74700: EMPTY
74701: LIST
74702: PUSH
74703: LD_INT 2
74705: PUSH
74706: LD_INT 30
74708: PUSH
74709: LD_INT 32
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 30
74718: PUSH
74719: LD_INT 4
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 30
74728: PUSH
74729: LD_INT 5
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: LIST
74746: PPUSH
74747: CALL_OW 72
74751: ST_TO_ADDR
74752: GO 74976
74754: LD_INT 2
74756: DOUBLE
74757: EQUAL
74758: IFTRUE 74762
74760: GO 74824
74762: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74763: LD_ADDR_VAR 0 12
74767: PUSH
74768: LD_VAR 0 18
74772: PPUSH
74773: LD_INT 22
74775: PUSH
74776: LD_VAR 0 16
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: LD_INT 2
74787: PUSH
74788: LD_INT 30
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 30
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: LIST
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PPUSH
74817: CALL_OW 72
74821: ST_TO_ADDR
74822: GO 74976
74824: LD_INT 3
74826: DOUBLE
74827: EQUAL
74828: IFTRUE 74832
74830: GO 74894
74832: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74833: LD_ADDR_VAR 0 12
74837: PUSH
74838: LD_VAR 0 18
74842: PPUSH
74843: LD_INT 22
74845: PUSH
74846: LD_VAR 0 16
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: PUSH
74855: LD_INT 2
74857: PUSH
74858: LD_INT 30
74860: PUSH
74861: LD_INT 2
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 30
74870: PUSH
74871: LD_INT 3
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: LIST
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PPUSH
74887: CALL_OW 72
74891: ST_TO_ADDR
74892: GO 74976
74894: LD_INT 4
74896: DOUBLE
74897: EQUAL
74898: IFTRUE 74902
74900: GO 74975
74902: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74903: LD_ADDR_VAR 0 12
74907: PUSH
74908: LD_VAR 0 18
74912: PPUSH
74913: LD_INT 22
74915: PUSH
74916: LD_VAR 0 16
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 2
74927: PUSH
74928: LD_INT 30
74930: PUSH
74931: LD_INT 6
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 30
74940: PUSH
74941: LD_INT 7
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 30
74950: PUSH
74951: LD_INT 8
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: PPUSH
74968: CALL_OW 72
74972: ST_TO_ADDR
74973: GO 74976
74975: POP
// if i = 1 then
74976: LD_VAR 0 8
74980: PUSH
74981: LD_INT 1
74983: EQUAL
74984: IFFALSE 75095
// begin tmp := [ ] ;
74986: LD_ADDR_VAR 0 19
74990: PUSH
74991: EMPTY
74992: ST_TO_ADDR
// for j in f do
74993: LD_ADDR_VAR 0 9
74997: PUSH
74998: LD_VAR 0 12
75002: PUSH
75003: FOR_IN
75004: IFFALSE 75077
// if GetBType ( j ) = b_bunker then
75006: LD_VAR 0 9
75010: PPUSH
75011: CALL_OW 266
75015: PUSH
75016: LD_INT 32
75018: EQUAL
75019: IFFALSE 75046
// tmp := Insert ( tmp , 1 , j ) else
75021: LD_ADDR_VAR 0 19
75025: PUSH
75026: LD_VAR 0 19
75030: PPUSH
75031: LD_INT 1
75033: PPUSH
75034: LD_VAR 0 9
75038: PPUSH
75039: CALL_OW 2
75043: ST_TO_ADDR
75044: GO 75075
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75046: LD_ADDR_VAR 0 19
75050: PUSH
75051: LD_VAR 0 19
75055: PPUSH
75056: LD_VAR 0 19
75060: PUSH
75061: LD_INT 1
75063: PLUS
75064: PPUSH
75065: LD_VAR 0 9
75069: PPUSH
75070: CALL_OW 2
75074: ST_TO_ADDR
75075: GO 75003
75077: POP
75078: POP
// if tmp then
75079: LD_VAR 0 19
75083: IFFALSE 75095
// f := tmp ;
75085: LD_ADDR_VAR 0 12
75089: PUSH
75090: LD_VAR 0 19
75094: ST_TO_ADDR
// end ; x := personel [ i ] ;
75095: LD_ADDR_VAR 0 13
75099: PUSH
75100: LD_VAR 0 6
75104: PUSH
75105: LD_VAR 0 8
75109: ARRAY
75110: ST_TO_ADDR
// if x = - 1 then
75111: LD_VAR 0 13
75115: PUSH
75116: LD_INT 1
75118: NEG
75119: EQUAL
75120: IFFALSE 75329
// begin for j in f do
75122: LD_ADDR_VAR 0 9
75126: PUSH
75127: LD_VAR 0 12
75131: PUSH
75132: FOR_IN
75133: IFFALSE 75325
// repeat InitHc ;
75135: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75139: LD_VAR 0 9
75143: PPUSH
75144: CALL_OW 266
75148: PUSH
75149: LD_INT 5
75151: EQUAL
75152: IFFALSE 75222
// begin if UnitsInside ( j ) < 3 then
75154: LD_VAR 0 9
75158: PPUSH
75159: CALL_OW 313
75163: PUSH
75164: LD_INT 3
75166: LESS
75167: IFFALSE 75203
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75169: LD_INT 0
75171: PPUSH
75172: LD_INT 5
75174: PUSH
75175: LD_INT 8
75177: PUSH
75178: LD_INT 9
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: LIST
75185: PUSH
75186: LD_VAR 0 17
75190: ARRAY
75191: PPUSH
75192: LD_VAR 0 4
75196: PPUSH
75197: CALL_OW 380
75201: GO 75220
// PrepareHuman ( false , i , skill ) ;
75203: LD_INT 0
75205: PPUSH
75206: LD_VAR 0 8
75210: PPUSH
75211: LD_VAR 0 4
75215: PPUSH
75216: CALL_OW 380
// end else
75220: GO 75239
// PrepareHuman ( false , i , skill ) ;
75222: LD_INT 0
75224: PPUSH
75225: LD_VAR 0 8
75229: PPUSH
75230: LD_VAR 0 4
75234: PPUSH
75235: CALL_OW 380
// un := CreateHuman ;
75239: LD_ADDR_VAR 0 14
75243: PUSH
75244: CALL_OW 44
75248: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75249: LD_ADDR_VAR 0 7
75253: PUSH
75254: LD_VAR 0 7
75258: PPUSH
75259: LD_INT 1
75261: PPUSH
75262: LD_VAR 0 14
75266: PPUSH
75267: CALL_OW 2
75271: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75272: LD_VAR 0 14
75276: PPUSH
75277: LD_VAR 0 9
75281: PPUSH
75282: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75286: LD_VAR 0 9
75290: PPUSH
75291: CALL_OW 313
75295: PUSH
75296: LD_INT 6
75298: EQUAL
75299: PUSH
75300: LD_VAR 0 9
75304: PPUSH
75305: CALL_OW 266
75309: PUSH
75310: LD_INT 32
75312: PUSH
75313: LD_INT 31
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: IN
75320: OR
75321: IFFALSE 75135
75323: GO 75132
75325: POP
75326: POP
// end else
75327: GO 75709
// for j = 1 to x do
75329: LD_ADDR_VAR 0 9
75333: PUSH
75334: DOUBLE
75335: LD_INT 1
75337: DEC
75338: ST_TO_ADDR
75339: LD_VAR 0 13
75343: PUSH
75344: FOR_TO
75345: IFFALSE 75707
// begin InitHc ;
75347: CALL_OW 19
// if not f then
75351: LD_VAR 0 12
75355: NOT
75356: IFFALSE 75445
// begin PrepareHuman ( false , i , skill ) ;
75358: LD_INT 0
75360: PPUSH
75361: LD_VAR 0 8
75365: PPUSH
75366: LD_VAR 0 4
75370: PPUSH
75371: CALL_OW 380
// un := CreateHuman ;
75375: LD_ADDR_VAR 0 14
75379: PUSH
75380: CALL_OW 44
75384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75385: LD_ADDR_VAR 0 7
75389: PUSH
75390: LD_VAR 0 7
75394: PPUSH
75395: LD_INT 1
75397: PPUSH
75398: LD_VAR 0 14
75402: PPUSH
75403: CALL_OW 2
75407: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75408: LD_VAR 0 14
75412: PPUSH
75413: LD_VAR 0 1
75417: PPUSH
75418: CALL_OW 250
75422: PPUSH
75423: LD_VAR 0 1
75427: PPUSH
75428: CALL_OW 251
75432: PPUSH
75433: LD_INT 10
75435: PPUSH
75436: LD_INT 0
75438: PPUSH
75439: CALL_OW 50
// continue ;
75443: GO 75344
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75445: LD_VAR 0 12
75449: PUSH
75450: LD_INT 1
75452: ARRAY
75453: PPUSH
75454: CALL_OW 313
75458: PUSH
75459: LD_VAR 0 12
75463: PUSH
75464: LD_INT 1
75466: ARRAY
75467: PPUSH
75468: CALL_OW 266
75472: PUSH
75473: LD_INT 32
75475: PUSH
75476: LD_INT 31
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: IN
75483: AND
75484: PUSH
75485: LD_VAR 0 12
75489: PUSH
75490: LD_INT 1
75492: ARRAY
75493: PPUSH
75494: CALL_OW 313
75498: PUSH
75499: LD_INT 6
75501: EQUAL
75502: OR
75503: IFFALSE 75523
// f := Delete ( f , 1 ) ;
75505: LD_ADDR_VAR 0 12
75509: PUSH
75510: LD_VAR 0 12
75514: PPUSH
75515: LD_INT 1
75517: PPUSH
75518: CALL_OW 3
75522: ST_TO_ADDR
// if not f then
75523: LD_VAR 0 12
75527: NOT
75528: IFFALSE 75546
// begin x := x + 2 ;
75530: LD_ADDR_VAR 0 13
75534: PUSH
75535: LD_VAR 0 13
75539: PUSH
75540: LD_INT 2
75542: PLUS
75543: ST_TO_ADDR
// continue ;
75544: GO 75344
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75546: LD_VAR 0 12
75550: PUSH
75551: LD_INT 1
75553: ARRAY
75554: PPUSH
75555: CALL_OW 266
75559: PUSH
75560: LD_INT 5
75562: EQUAL
75563: IFFALSE 75637
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75565: LD_VAR 0 12
75569: PUSH
75570: LD_INT 1
75572: ARRAY
75573: PPUSH
75574: CALL_OW 313
75578: PUSH
75579: LD_INT 3
75581: LESS
75582: IFFALSE 75618
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75584: LD_INT 0
75586: PPUSH
75587: LD_INT 5
75589: PUSH
75590: LD_INT 8
75592: PUSH
75593: LD_INT 9
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: LIST
75600: PUSH
75601: LD_VAR 0 17
75605: ARRAY
75606: PPUSH
75607: LD_VAR 0 4
75611: PPUSH
75612: CALL_OW 380
75616: GO 75635
// PrepareHuman ( false , i , skill ) ;
75618: LD_INT 0
75620: PPUSH
75621: LD_VAR 0 8
75625: PPUSH
75626: LD_VAR 0 4
75630: PPUSH
75631: CALL_OW 380
// end else
75635: GO 75654
// PrepareHuman ( false , i , skill ) ;
75637: LD_INT 0
75639: PPUSH
75640: LD_VAR 0 8
75644: PPUSH
75645: LD_VAR 0 4
75649: PPUSH
75650: CALL_OW 380
// un := CreateHuman ;
75654: LD_ADDR_VAR 0 14
75658: PUSH
75659: CALL_OW 44
75663: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75664: LD_ADDR_VAR 0 7
75668: PUSH
75669: LD_VAR 0 7
75673: PPUSH
75674: LD_INT 1
75676: PPUSH
75677: LD_VAR 0 14
75681: PPUSH
75682: CALL_OW 2
75686: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75687: LD_VAR 0 14
75691: PPUSH
75692: LD_VAR 0 12
75696: PUSH
75697: LD_INT 1
75699: ARRAY
75700: PPUSH
75701: CALL_OW 52
// end ;
75705: GO 75344
75707: POP
75708: POP
// end ;
75709: GO 74646
75711: POP
75712: POP
// result := result ^ buildings ;
75713: LD_ADDR_VAR 0 7
75717: PUSH
75718: LD_VAR 0 7
75722: PUSH
75723: LD_VAR 0 18
75727: ADD
75728: ST_TO_ADDR
// end else
75729: GO 75872
// begin for i = 1 to personel do
75731: LD_ADDR_VAR 0 8
75735: PUSH
75736: DOUBLE
75737: LD_INT 1
75739: DEC
75740: ST_TO_ADDR
75741: LD_VAR 0 6
75745: PUSH
75746: FOR_TO
75747: IFFALSE 75870
// begin if i > 4 then
75749: LD_VAR 0 8
75753: PUSH
75754: LD_INT 4
75756: GREATER
75757: IFFALSE 75761
// break ;
75759: GO 75870
// x := personel [ i ] ;
75761: LD_ADDR_VAR 0 13
75765: PUSH
75766: LD_VAR 0 6
75770: PUSH
75771: LD_VAR 0 8
75775: ARRAY
75776: ST_TO_ADDR
// if x = - 1 then
75777: LD_VAR 0 13
75781: PUSH
75782: LD_INT 1
75784: NEG
75785: EQUAL
75786: IFFALSE 75790
// continue ;
75788: GO 75746
// PrepareHuman ( false , i , skill ) ;
75790: LD_INT 0
75792: PPUSH
75793: LD_VAR 0 8
75797: PPUSH
75798: LD_VAR 0 4
75802: PPUSH
75803: CALL_OW 380
// un := CreateHuman ;
75807: LD_ADDR_VAR 0 14
75811: PUSH
75812: CALL_OW 44
75816: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75817: LD_VAR 0 14
75821: PPUSH
75822: LD_VAR 0 1
75826: PPUSH
75827: CALL_OW 250
75831: PPUSH
75832: LD_VAR 0 1
75836: PPUSH
75837: CALL_OW 251
75841: PPUSH
75842: LD_INT 10
75844: PPUSH
75845: LD_INT 0
75847: PPUSH
75848: CALL_OW 50
// result := result ^ un ;
75852: LD_ADDR_VAR 0 7
75856: PUSH
75857: LD_VAR 0 7
75861: PUSH
75862: LD_VAR 0 14
75866: ADD
75867: ST_TO_ADDR
// end ;
75868: GO 75746
75870: POP
75871: POP
// end ; end ;
75872: LD_VAR 0 7
75876: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75877: LD_INT 0
75879: PPUSH
75880: PPUSH
75881: PPUSH
75882: PPUSH
75883: PPUSH
75884: PPUSH
75885: PPUSH
75886: PPUSH
75887: PPUSH
75888: PPUSH
75889: PPUSH
75890: PPUSH
75891: PPUSH
75892: PPUSH
75893: PPUSH
75894: PPUSH
// result := false ;
75895: LD_ADDR_VAR 0 3
75899: PUSH
75900: LD_INT 0
75902: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75903: LD_VAR 0 1
75907: NOT
75908: PUSH
75909: LD_VAR 0 1
75913: PPUSH
75914: CALL_OW 266
75918: PUSH
75919: LD_INT 32
75921: PUSH
75922: LD_INT 33
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: IN
75929: NOT
75930: OR
75931: IFFALSE 75935
// exit ;
75933: GO 77044
// nat := GetNation ( tower ) ;
75935: LD_ADDR_VAR 0 12
75939: PUSH
75940: LD_VAR 0 1
75944: PPUSH
75945: CALL_OW 248
75949: ST_TO_ADDR
// side := GetSide ( tower ) ;
75950: LD_ADDR_VAR 0 16
75954: PUSH
75955: LD_VAR 0 1
75959: PPUSH
75960: CALL_OW 255
75964: ST_TO_ADDR
// x := GetX ( tower ) ;
75965: LD_ADDR_VAR 0 10
75969: PUSH
75970: LD_VAR 0 1
75974: PPUSH
75975: CALL_OW 250
75979: ST_TO_ADDR
// y := GetY ( tower ) ;
75980: LD_ADDR_VAR 0 11
75984: PUSH
75985: LD_VAR 0 1
75989: PPUSH
75990: CALL_OW 251
75994: ST_TO_ADDR
// if not x or not y then
75995: LD_VAR 0 10
75999: NOT
76000: PUSH
76001: LD_VAR 0 11
76005: NOT
76006: OR
76007: IFFALSE 76011
// exit ;
76009: GO 77044
// weapon := 0 ;
76011: LD_ADDR_VAR 0 18
76015: PUSH
76016: LD_INT 0
76018: ST_TO_ADDR
// fac_list := [ ] ;
76019: LD_ADDR_VAR 0 17
76023: PUSH
76024: EMPTY
76025: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76026: LD_ADDR_VAR 0 6
76030: PUSH
76031: LD_VAR 0 1
76035: PPUSH
76036: CALL_OW 274
76040: PPUSH
76041: LD_VAR 0 2
76045: PPUSH
76046: LD_INT 0
76048: PPUSH
76049: CALL 73615 0 3
76053: PPUSH
76054: LD_INT 30
76056: PUSH
76057: LD_INT 3
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PPUSH
76064: CALL_OW 72
76068: ST_TO_ADDR
// if not factories then
76069: LD_VAR 0 6
76073: NOT
76074: IFFALSE 76078
// exit ;
76076: GO 77044
// for i in factories do
76078: LD_ADDR_VAR 0 8
76082: PUSH
76083: LD_VAR 0 6
76087: PUSH
76088: FOR_IN
76089: IFFALSE 76114
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76091: LD_ADDR_VAR 0 17
76095: PUSH
76096: LD_VAR 0 17
76100: PUSH
76101: LD_VAR 0 8
76105: PPUSH
76106: CALL_OW 478
76110: UNION
76111: ST_TO_ADDR
76112: GO 76088
76114: POP
76115: POP
// if not fac_list then
76116: LD_VAR 0 17
76120: NOT
76121: IFFALSE 76125
// exit ;
76123: GO 77044
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76125: LD_ADDR_VAR 0 5
76129: PUSH
76130: LD_INT 4
76132: PUSH
76133: LD_INT 5
76135: PUSH
76136: LD_INT 9
76138: PUSH
76139: LD_INT 10
76141: PUSH
76142: LD_INT 6
76144: PUSH
76145: LD_INT 7
76147: PUSH
76148: LD_INT 11
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: PUSH
76160: LD_INT 27
76162: PUSH
76163: LD_INT 28
76165: PUSH
76166: LD_INT 26
76168: PUSH
76169: LD_INT 30
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: LIST
76176: LIST
76177: PUSH
76178: LD_INT 43
76180: PUSH
76181: LD_INT 44
76183: PUSH
76184: LD_INT 46
76186: PUSH
76187: LD_INT 45
76189: PUSH
76190: LD_INT 47
76192: PUSH
76193: LD_INT 49
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: LIST
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: LIST
76208: PUSH
76209: LD_VAR 0 12
76213: ARRAY
76214: ST_TO_ADDR
// list := list isect fac_list ;
76215: LD_ADDR_VAR 0 5
76219: PUSH
76220: LD_VAR 0 5
76224: PUSH
76225: LD_VAR 0 17
76229: ISECT
76230: ST_TO_ADDR
// if not list then
76231: LD_VAR 0 5
76235: NOT
76236: IFFALSE 76240
// exit ;
76238: GO 77044
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76240: LD_VAR 0 12
76244: PUSH
76245: LD_INT 3
76247: EQUAL
76248: PUSH
76249: LD_INT 49
76251: PUSH
76252: LD_VAR 0 5
76256: IN
76257: AND
76258: PUSH
76259: LD_INT 31
76261: PPUSH
76262: LD_VAR 0 16
76266: PPUSH
76267: CALL_OW 321
76271: PUSH
76272: LD_INT 2
76274: EQUAL
76275: AND
76276: IFFALSE 76336
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76278: LD_INT 22
76280: PUSH
76281: LD_VAR 0 16
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: PUSH
76290: LD_INT 35
76292: PUSH
76293: LD_INT 49
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PUSH
76300: LD_INT 91
76302: PUSH
76303: LD_VAR 0 1
76307: PUSH
76308: LD_INT 10
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: LIST
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: LIST
76320: PPUSH
76321: CALL_OW 69
76325: NOT
76326: IFFALSE 76336
// weapon := ru_time_lapser ;
76328: LD_ADDR_VAR 0 18
76332: PUSH
76333: LD_INT 49
76335: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76336: LD_VAR 0 12
76340: PUSH
76341: LD_INT 1
76343: PUSH
76344: LD_INT 2
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: IN
76351: PUSH
76352: LD_INT 11
76354: PUSH
76355: LD_VAR 0 5
76359: IN
76360: PUSH
76361: LD_INT 30
76363: PUSH
76364: LD_VAR 0 5
76368: IN
76369: OR
76370: AND
76371: PUSH
76372: LD_INT 6
76374: PPUSH
76375: LD_VAR 0 16
76379: PPUSH
76380: CALL_OW 321
76384: PUSH
76385: LD_INT 2
76387: EQUAL
76388: AND
76389: IFFALSE 76554
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76391: LD_INT 22
76393: PUSH
76394: LD_VAR 0 16
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 2
76405: PUSH
76406: LD_INT 35
76408: PUSH
76409: LD_INT 11
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 35
76418: PUSH
76419: LD_INT 30
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 91
76433: PUSH
76434: LD_VAR 0 1
76438: PUSH
76439: LD_INT 18
76441: PUSH
76442: EMPTY
76443: LIST
76444: LIST
76445: LIST
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: LIST
76451: PPUSH
76452: CALL_OW 69
76456: NOT
76457: PUSH
76458: LD_INT 22
76460: PUSH
76461: LD_VAR 0 16
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 2
76472: PUSH
76473: LD_INT 30
76475: PUSH
76476: LD_INT 32
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 30
76485: PUSH
76486: LD_INT 33
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: LIST
76497: PUSH
76498: LD_INT 91
76500: PUSH
76501: LD_VAR 0 1
76505: PUSH
76506: LD_INT 12
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: LIST
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: LIST
76518: PUSH
76519: EMPTY
76520: LIST
76521: PPUSH
76522: CALL_OW 69
76526: PUSH
76527: LD_INT 2
76529: GREATER
76530: AND
76531: IFFALSE 76554
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76533: LD_ADDR_VAR 0 18
76537: PUSH
76538: LD_INT 11
76540: PUSH
76541: LD_INT 30
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: LD_VAR 0 12
76552: ARRAY
76553: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76554: LD_VAR 0 18
76558: NOT
76559: PUSH
76560: LD_INT 40
76562: PPUSH
76563: LD_VAR 0 16
76567: PPUSH
76568: CALL_OW 321
76572: PUSH
76573: LD_INT 2
76575: EQUAL
76576: AND
76577: PUSH
76578: LD_INT 7
76580: PUSH
76581: LD_VAR 0 5
76585: IN
76586: PUSH
76587: LD_INT 28
76589: PUSH
76590: LD_VAR 0 5
76594: IN
76595: OR
76596: PUSH
76597: LD_INT 45
76599: PUSH
76600: LD_VAR 0 5
76604: IN
76605: OR
76606: AND
76607: IFFALSE 76861
// begin hex := GetHexInfo ( x , y ) ;
76609: LD_ADDR_VAR 0 4
76613: PUSH
76614: LD_VAR 0 10
76618: PPUSH
76619: LD_VAR 0 11
76623: PPUSH
76624: CALL_OW 546
76628: ST_TO_ADDR
// if hex [ 1 ] then
76629: LD_VAR 0 4
76633: PUSH
76634: LD_INT 1
76636: ARRAY
76637: IFFALSE 76641
// exit ;
76639: GO 77044
// height := hex [ 2 ] ;
76641: LD_ADDR_VAR 0 15
76645: PUSH
76646: LD_VAR 0 4
76650: PUSH
76651: LD_INT 2
76653: ARRAY
76654: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76655: LD_ADDR_VAR 0 14
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: LD_INT 2
76665: PUSH
76666: LD_INT 3
76668: PUSH
76669: LD_INT 5
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: ST_TO_ADDR
// for i in tmp do
76678: LD_ADDR_VAR 0 8
76682: PUSH
76683: LD_VAR 0 14
76687: PUSH
76688: FOR_IN
76689: IFFALSE 76859
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76691: LD_ADDR_VAR 0 9
76695: PUSH
76696: LD_VAR 0 10
76700: PPUSH
76701: LD_VAR 0 8
76705: PPUSH
76706: LD_INT 5
76708: PPUSH
76709: CALL_OW 272
76713: PUSH
76714: LD_VAR 0 11
76718: PPUSH
76719: LD_VAR 0 8
76723: PPUSH
76724: LD_INT 5
76726: PPUSH
76727: CALL_OW 273
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76736: LD_VAR 0 9
76740: PUSH
76741: LD_INT 1
76743: ARRAY
76744: PPUSH
76745: LD_VAR 0 9
76749: PUSH
76750: LD_INT 2
76752: ARRAY
76753: PPUSH
76754: CALL_OW 488
76758: IFFALSE 76857
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76760: LD_ADDR_VAR 0 4
76764: PUSH
76765: LD_VAR 0 9
76769: PUSH
76770: LD_INT 1
76772: ARRAY
76773: PPUSH
76774: LD_VAR 0 9
76778: PUSH
76779: LD_INT 2
76781: ARRAY
76782: PPUSH
76783: CALL_OW 546
76787: ST_TO_ADDR
// if hex [ 1 ] then
76788: LD_VAR 0 4
76792: PUSH
76793: LD_INT 1
76795: ARRAY
76796: IFFALSE 76800
// continue ;
76798: GO 76688
// h := hex [ 2 ] ;
76800: LD_ADDR_VAR 0 13
76804: PUSH
76805: LD_VAR 0 4
76809: PUSH
76810: LD_INT 2
76812: ARRAY
76813: ST_TO_ADDR
// if h + 7 < height then
76814: LD_VAR 0 13
76818: PUSH
76819: LD_INT 7
76821: PLUS
76822: PUSH
76823: LD_VAR 0 15
76827: LESS
76828: IFFALSE 76857
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76830: LD_ADDR_VAR 0 18
76834: PUSH
76835: LD_INT 7
76837: PUSH
76838: LD_INT 28
76840: PUSH
76841: LD_INT 45
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: LIST
76848: PUSH
76849: LD_VAR 0 12
76853: ARRAY
76854: ST_TO_ADDR
// break ;
76855: GO 76859
// end ; end ; end ;
76857: GO 76688
76859: POP
76860: POP
// end ; if not weapon then
76861: LD_VAR 0 18
76865: NOT
76866: IFFALSE 76926
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76868: LD_ADDR_VAR 0 5
76872: PUSH
76873: LD_VAR 0 5
76877: PUSH
76878: LD_INT 11
76880: PUSH
76881: LD_INT 30
76883: PUSH
76884: LD_INT 49
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: LIST
76891: DIFF
76892: ST_TO_ADDR
// if not list then
76893: LD_VAR 0 5
76897: NOT
76898: IFFALSE 76902
// exit ;
76900: GO 77044
// weapon := list [ rand ( 1 , list ) ] ;
76902: LD_ADDR_VAR 0 18
76906: PUSH
76907: LD_VAR 0 5
76911: PUSH
76912: LD_INT 1
76914: PPUSH
76915: LD_VAR 0 5
76919: PPUSH
76920: CALL_OW 12
76924: ARRAY
76925: ST_TO_ADDR
// end ; if weapon then
76926: LD_VAR 0 18
76930: IFFALSE 77044
// begin tmp := CostOfWeapon ( weapon ) ;
76932: LD_ADDR_VAR 0 14
76936: PUSH
76937: LD_VAR 0 18
76941: PPUSH
76942: CALL_OW 451
76946: ST_TO_ADDR
// j := GetBase ( tower ) ;
76947: LD_ADDR_VAR 0 9
76951: PUSH
76952: LD_VAR 0 1
76956: PPUSH
76957: CALL_OW 274
76961: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76962: LD_VAR 0 9
76966: PPUSH
76967: LD_INT 1
76969: PPUSH
76970: CALL_OW 275
76974: PUSH
76975: LD_VAR 0 14
76979: PUSH
76980: LD_INT 1
76982: ARRAY
76983: GREATEREQUAL
76984: PUSH
76985: LD_VAR 0 9
76989: PPUSH
76990: LD_INT 2
76992: PPUSH
76993: CALL_OW 275
76997: PUSH
76998: LD_VAR 0 14
77002: PUSH
77003: LD_INT 2
77005: ARRAY
77006: GREATEREQUAL
77007: AND
77008: PUSH
77009: LD_VAR 0 9
77013: PPUSH
77014: LD_INT 3
77016: PPUSH
77017: CALL_OW 275
77021: PUSH
77022: LD_VAR 0 14
77026: PUSH
77027: LD_INT 3
77029: ARRAY
77030: GREATEREQUAL
77031: AND
77032: IFFALSE 77044
// result := weapon ;
77034: LD_ADDR_VAR 0 3
77038: PUSH
77039: LD_VAR 0 18
77043: ST_TO_ADDR
// end ; end ;
77044: LD_VAR 0 3
77048: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77049: LD_INT 0
77051: PPUSH
77052: PPUSH
// result := true ;
77053: LD_ADDR_VAR 0 3
77057: PUSH
77058: LD_INT 1
77060: ST_TO_ADDR
// if array1 = array2 then
77061: LD_VAR 0 1
77065: PUSH
77066: LD_VAR 0 2
77070: EQUAL
77071: IFFALSE 77131
// begin for i = 1 to array1 do
77073: LD_ADDR_VAR 0 4
77077: PUSH
77078: DOUBLE
77079: LD_INT 1
77081: DEC
77082: ST_TO_ADDR
77083: LD_VAR 0 1
77087: PUSH
77088: FOR_TO
77089: IFFALSE 77127
// if array1 [ i ] <> array2 [ i ] then
77091: LD_VAR 0 1
77095: PUSH
77096: LD_VAR 0 4
77100: ARRAY
77101: PUSH
77102: LD_VAR 0 2
77106: PUSH
77107: LD_VAR 0 4
77111: ARRAY
77112: NONEQUAL
77113: IFFALSE 77125
// begin result := false ;
77115: LD_ADDR_VAR 0 3
77119: PUSH
77120: LD_INT 0
77122: ST_TO_ADDR
// break ;
77123: GO 77127
// end ;
77125: GO 77088
77127: POP
77128: POP
// end else
77129: GO 77139
// result := false ;
77131: LD_ADDR_VAR 0 3
77135: PUSH
77136: LD_INT 0
77138: ST_TO_ADDR
// end ;
77139: LD_VAR 0 3
77143: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77144: LD_INT 0
77146: PPUSH
77147: PPUSH
// if not array1 or not array2 then
77148: LD_VAR 0 1
77152: NOT
77153: PUSH
77154: LD_VAR 0 2
77158: NOT
77159: OR
77160: IFFALSE 77164
// exit ;
77162: GO 77228
// result := true ;
77164: LD_ADDR_VAR 0 3
77168: PUSH
77169: LD_INT 1
77171: ST_TO_ADDR
// for i = 1 to array1 do
77172: LD_ADDR_VAR 0 4
77176: PUSH
77177: DOUBLE
77178: LD_INT 1
77180: DEC
77181: ST_TO_ADDR
77182: LD_VAR 0 1
77186: PUSH
77187: FOR_TO
77188: IFFALSE 77226
// if array1 [ i ] <> array2 [ i ] then
77190: LD_VAR 0 1
77194: PUSH
77195: LD_VAR 0 4
77199: ARRAY
77200: PUSH
77201: LD_VAR 0 2
77205: PUSH
77206: LD_VAR 0 4
77210: ARRAY
77211: NONEQUAL
77212: IFFALSE 77224
// begin result := false ;
77214: LD_ADDR_VAR 0 3
77218: PUSH
77219: LD_INT 0
77221: ST_TO_ADDR
// break ;
77222: GO 77226
// end ;
77224: GO 77187
77226: POP
77227: POP
// end ;
77228: LD_VAR 0 3
77232: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77233: LD_INT 0
77235: PPUSH
77236: PPUSH
77237: PPUSH
// pom := GetBase ( fac ) ;
77238: LD_ADDR_VAR 0 5
77242: PUSH
77243: LD_VAR 0 1
77247: PPUSH
77248: CALL_OW 274
77252: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77253: LD_ADDR_VAR 0 4
77257: PUSH
77258: LD_VAR 0 2
77262: PUSH
77263: LD_INT 1
77265: ARRAY
77266: PPUSH
77267: LD_VAR 0 2
77271: PUSH
77272: LD_INT 2
77274: ARRAY
77275: PPUSH
77276: LD_VAR 0 2
77280: PUSH
77281: LD_INT 3
77283: ARRAY
77284: PPUSH
77285: LD_VAR 0 2
77289: PUSH
77290: LD_INT 4
77292: ARRAY
77293: PPUSH
77294: CALL_OW 449
77298: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77299: LD_ADDR_VAR 0 3
77303: PUSH
77304: LD_VAR 0 5
77308: PPUSH
77309: LD_INT 1
77311: PPUSH
77312: CALL_OW 275
77316: PUSH
77317: LD_VAR 0 4
77321: PUSH
77322: LD_INT 1
77324: ARRAY
77325: GREATEREQUAL
77326: PUSH
77327: LD_VAR 0 5
77331: PPUSH
77332: LD_INT 2
77334: PPUSH
77335: CALL_OW 275
77339: PUSH
77340: LD_VAR 0 4
77344: PUSH
77345: LD_INT 2
77347: ARRAY
77348: GREATEREQUAL
77349: AND
77350: PUSH
77351: LD_VAR 0 5
77355: PPUSH
77356: LD_INT 3
77358: PPUSH
77359: CALL_OW 275
77363: PUSH
77364: LD_VAR 0 4
77368: PUSH
77369: LD_INT 3
77371: ARRAY
77372: GREATEREQUAL
77373: AND
77374: ST_TO_ADDR
// end ;
77375: LD_VAR 0 3
77379: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77380: LD_INT 0
77382: PPUSH
77383: PPUSH
77384: PPUSH
77385: PPUSH
// pom := GetBase ( building ) ;
77386: LD_ADDR_VAR 0 3
77390: PUSH
77391: LD_VAR 0 1
77395: PPUSH
77396: CALL_OW 274
77400: ST_TO_ADDR
// if not pom then
77401: LD_VAR 0 3
77405: NOT
77406: IFFALSE 77410
// exit ;
77408: GO 77580
// btype := GetBType ( building ) ;
77410: LD_ADDR_VAR 0 5
77414: PUSH
77415: LD_VAR 0 1
77419: PPUSH
77420: CALL_OW 266
77424: ST_TO_ADDR
// if btype = b_armoury then
77425: LD_VAR 0 5
77429: PUSH
77430: LD_INT 4
77432: EQUAL
77433: IFFALSE 77443
// btype := b_barracks ;
77435: LD_ADDR_VAR 0 5
77439: PUSH
77440: LD_INT 5
77442: ST_TO_ADDR
// if btype = b_depot then
77443: LD_VAR 0 5
77447: PUSH
77448: LD_INT 0
77450: EQUAL
77451: IFFALSE 77461
// btype := b_warehouse ;
77453: LD_ADDR_VAR 0 5
77457: PUSH
77458: LD_INT 1
77460: ST_TO_ADDR
// if btype = b_workshop then
77461: LD_VAR 0 5
77465: PUSH
77466: LD_INT 2
77468: EQUAL
77469: IFFALSE 77479
// btype := b_factory ;
77471: LD_ADDR_VAR 0 5
77475: PUSH
77476: LD_INT 3
77478: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77479: LD_ADDR_VAR 0 4
77483: PUSH
77484: LD_VAR 0 5
77488: PPUSH
77489: LD_VAR 0 1
77493: PPUSH
77494: CALL_OW 248
77498: PPUSH
77499: CALL_OW 450
77503: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77504: LD_ADDR_VAR 0 2
77508: PUSH
77509: LD_VAR 0 3
77513: PPUSH
77514: LD_INT 1
77516: PPUSH
77517: CALL_OW 275
77521: PUSH
77522: LD_VAR 0 4
77526: PUSH
77527: LD_INT 1
77529: ARRAY
77530: GREATEREQUAL
77531: PUSH
77532: LD_VAR 0 3
77536: PPUSH
77537: LD_INT 2
77539: PPUSH
77540: CALL_OW 275
77544: PUSH
77545: LD_VAR 0 4
77549: PUSH
77550: LD_INT 2
77552: ARRAY
77553: GREATEREQUAL
77554: AND
77555: PUSH
77556: LD_VAR 0 3
77560: PPUSH
77561: LD_INT 3
77563: PPUSH
77564: CALL_OW 275
77568: PUSH
77569: LD_VAR 0 4
77573: PUSH
77574: LD_INT 3
77576: ARRAY
77577: GREATEREQUAL
77578: AND
77579: ST_TO_ADDR
// end ;
77580: LD_VAR 0 2
77584: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77585: LD_INT 0
77587: PPUSH
77588: PPUSH
77589: PPUSH
// pom := GetBase ( building ) ;
77590: LD_ADDR_VAR 0 4
77594: PUSH
77595: LD_VAR 0 1
77599: PPUSH
77600: CALL_OW 274
77604: ST_TO_ADDR
// if not pom then
77605: LD_VAR 0 4
77609: NOT
77610: IFFALSE 77614
// exit ;
77612: GO 77715
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77614: LD_ADDR_VAR 0 5
77618: PUSH
77619: LD_VAR 0 2
77623: PPUSH
77624: LD_VAR 0 1
77628: PPUSH
77629: CALL_OW 248
77633: PPUSH
77634: CALL_OW 450
77638: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77639: LD_ADDR_VAR 0 3
77643: PUSH
77644: LD_VAR 0 4
77648: PPUSH
77649: LD_INT 1
77651: PPUSH
77652: CALL_OW 275
77656: PUSH
77657: LD_VAR 0 5
77661: PUSH
77662: LD_INT 1
77664: ARRAY
77665: GREATEREQUAL
77666: PUSH
77667: LD_VAR 0 4
77671: PPUSH
77672: LD_INT 2
77674: PPUSH
77675: CALL_OW 275
77679: PUSH
77680: LD_VAR 0 5
77684: PUSH
77685: LD_INT 2
77687: ARRAY
77688: GREATEREQUAL
77689: AND
77690: PUSH
77691: LD_VAR 0 4
77695: PPUSH
77696: LD_INT 3
77698: PPUSH
77699: CALL_OW 275
77703: PUSH
77704: LD_VAR 0 5
77708: PUSH
77709: LD_INT 3
77711: ARRAY
77712: GREATEREQUAL
77713: AND
77714: ST_TO_ADDR
// end ;
77715: LD_VAR 0 3
77719: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77720: LD_INT 0
77722: PPUSH
77723: PPUSH
77724: PPUSH
77725: PPUSH
77726: PPUSH
77727: PPUSH
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
// result := false ;
77733: LD_ADDR_VAR 0 8
77737: PUSH
77738: LD_INT 0
77740: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77741: LD_VAR 0 5
77745: NOT
77746: PUSH
77747: LD_VAR 0 1
77751: NOT
77752: OR
77753: PUSH
77754: LD_VAR 0 2
77758: NOT
77759: OR
77760: PUSH
77761: LD_VAR 0 3
77765: NOT
77766: OR
77767: IFFALSE 77771
// exit ;
77769: GO 78585
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77771: LD_ADDR_VAR 0 14
77775: PUSH
77776: LD_VAR 0 1
77780: PPUSH
77781: LD_VAR 0 2
77785: PPUSH
77786: LD_VAR 0 3
77790: PPUSH
77791: LD_VAR 0 4
77795: PPUSH
77796: LD_VAR 0 5
77800: PUSH
77801: LD_INT 1
77803: ARRAY
77804: PPUSH
77805: CALL_OW 248
77809: PPUSH
77810: LD_INT 0
77812: PPUSH
77813: CALL 79818 0 6
77817: ST_TO_ADDR
// if not hexes then
77818: LD_VAR 0 14
77822: NOT
77823: IFFALSE 77827
// exit ;
77825: GO 78585
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77827: LD_ADDR_VAR 0 17
77831: PUSH
77832: LD_VAR 0 5
77836: PPUSH
77837: LD_INT 22
77839: PUSH
77840: LD_VAR 0 13
77844: PPUSH
77845: CALL_OW 255
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: LD_INT 30
77859: PUSH
77860: LD_INT 0
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 30
77869: PUSH
77870: LD_INT 1
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: LIST
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PPUSH
77886: CALL_OW 72
77890: ST_TO_ADDR
// for i = 1 to hexes do
77891: LD_ADDR_VAR 0 9
77895: PUSH
77896: DOUBLE
77897: LD_INT 1
77899: DEC
77900: ST_TO_ADDR
77901: LD_VAR 0 14
77905: PUSH
77906: FOR_TO
77907: IFFALSE 78583
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77909: LD_ADDR_VAR 0 13
77913: PUSH
77914: LD_VAR 0 14
77918: PUSH
77919: LD_VAR 0 9
77923: ARRAY
77924: PUSH
77925: LD_INT 1
77927: ARRAY
77928: PPUSH
77929: LD_VAR 0 14
77933: PUSH
77934: LD_VAR 0 9
77938: ARRAY
77939: PUSH
77940: LD_INT 2
77942: ARRAY
77943: PPUSH
77944: CALL_OW 428
77948: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77949: LD_VAR 0 14
77953: PUSH
77954: LD_VAR 0 9
77958: ARRAY
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: PPUSH
77964: LD_VAR 0 14
77968: PUSH
77969: LD_VAR 0 9
77973: ARRAY
77974: PUSH
77975: LD_INT 2
77977: ARRAY
77978: PPUSH
77979: CALL_OW 351
77983: PUSH
77984: LD_VAR 0 14
77988: PUSH
77989: LD_VAR 0 9
77993: ARRAY
77994: PUSH
77995: LD_INT 1
77997: ARRAY
77998: PPUSH
77999: LD_VAR 0 14
78003: PUSH
78004: LD_VAR 0 9
78008: ARRAY
78009: PUSH
78010: LD_INT 2
78012: ARRAY
78013: PPUSH
78014: CALL_OW 488
78018: NOT
78019: OR
78020: PUSH
78021: LD_VAR 0 13
78025: PPUSH
78026: CALL_OW 247
78030: PUSH
78031: LD_INT 3
78033: EQUAL
78034: OR
78035: IFFALSE 78041
// exit ;
78037: POP
78038: POP
78039: GO 78585
// if not tmp then
78041: LD_VAR 0 13
78045: NOT
78046: IFFALSE 78050
// continue ;
78048: GO 77906
// result := true ;
78050: LD_ADDR_VAR 0 8
78054: PUSH
78055: LD_INT 1
78057: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78058: LD_VAR 0 6
78062: PUSH
78063: LD_VAR 0 13
78067: PPUSH
78068: CALL_OW 247
78072: PUSH
78073: LD_INT 2
78075: EQUAL
78076: AND
78077: PUSH
78078: LD_VAR 0 13
78082: PPUSH
78083: CALL_OW 263
78087: PUSH
78088: LD_INT 1
78090: EQUAL
78091: AND
78092: IFFALSE 78256
// begin if IsDrivenBy ( tmp ) then
78094: LD_VAR 0 13
78098: PPUSH
78099: CALL_OW 311
78103: IFFALSE 78107
// continue ;
78105: GO 77906
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78107: LD_VAR 0 6
78111: PPUSH
78112: LD_INT 3
78114: PUSH
78115: LD_INT 60
78117: PUSH
78118: EMPTY
78119: LIST
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: LD_INT 55
78130: PUSH
78131: EMPTY
78132: LIST
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PPUSH
78142: CALL_OW 72
78146: IFFALSE 78254
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78148: LD_ADDR_VAR 0 18
78152: PUSH
78153: LD_VAR 0 6
78157: PPUSH
78158: LD_INT 3
78160: PUSH
78161: LD_INT 60
78163: PUSH
78164: EMPTY
78165: LIST
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 3
78173: PUSH
78174: LD_INT 55
78176: PUSH
78177: EMPTY
78178: LIST
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PPUSH
78188: CALL_OW 72
78192: PUSH
78193: LD_INT 1
78195: ARRAY
78196: ST_TO_ADDR
// if IsInUnit ( driver ) then
78197: LD_VAR 0 18
78201: PPUSH
78202: CALL_OW 310
78206: IFFALSE 78217
// ComExit ( driver ) ;
78208: LD_VAR 0 18
78212: PPUSH
78213: CALL 103506 0 1
// AddComEnterUnit ( driver , tmp ) ;
78217: LD_VAR 0 18
78221: PPUSH
78222: LD_VAR 0 13
78226: PPUSH
78227: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78231: LD_VAR 0 18
78235: PPUSH
78236: LD_VAR 0 7
78240: PPUSH
78241: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78245: LD_VAR 0 18
78249: PPUSH
78250: CALL_OW 181
// end ; continue ;
78254: GO 77906
// end ; if not cleaners or not tmp in cleaners then
78256: LD_VAR 0 6
78260: NOT
78261: PUSH
78262: LD_VAR 0 13
78266: PUSH
78267: LD_VAR 0 6
78271: IN
78272: NOT
78273: OR
78274: IFFALSE 78581
// begin if dep then
78276: LD_VAR 0 17
78280: IFFALSE 78416
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78282: LD_ADDR_VAR 0 16
78286: PUSH
78287: LD_VAR 0 17
78291: PUSH
78292: LD_INT 1
78294: ARRAY
78295: PPUSH
78296: CALL_OW 250
78300: PPUSH
78301: LD_VAR 0 17
78305: PUSH
78306: LD_INT 1
78308: ARRAY
78309: PPUSH
78310: CALL_OW 254
78314: PPUSH
78315: LD_INT 5
78317: PPUSH
78318: CALL_OW 272
78322: PUSH
78323: LD_VAR 0 17
78327: PUSH
78328: LD_INT 1
78330: ARRAY
78331: PPUSH
78332: CALL_OW 251
78336: PPUSH
78337: LD_VAR 0 17
78341: PUSH
78342: LD_INT 1
78344: ARRAY
78345: PPUSH
78346: CALL_OW 254
78350: PPUSH
78351: LD_INT 5
78353: PPUSH
78354: CALL_OW 273
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78363: LD_VAR 0 16
78367: PUSH
78368: LD_INT 1
78370: ARRAY
78371: PPUSH
78372: LD_VAR 0 16
78376: PUSH
78377: LD_INT 2
78379: ARRAY
78380: PPUSH
78381: CALL_OW 488
78385: IFFALSE 78416
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78387: LD_VAR 0 13
78391: PPUSH
78392: LD_VAR 0 16
78396: PUSH
78397: LD_INT 1
78399: ARRAY
78400: PPUSH
78401: LD_VAR 0 16
78405: PUSH
78406: LD_INT 2
78408: ARRAY
78409: PPUSH
78410: CALL_OW 111
// continue ;
78414: GO 77906
// end ; end ; r := GetDir ( tmp ) ;
78416: LD_ADDR_VAR 0 15
78420: PUSH
78421: LD_VAR 0 13
78425: PPUSH
78426: CALL_OW 254
78430: ST_TO_ADDR
// if r = 5 then
78431: LD_VAR 0 15
78435: PUSH
78436: LD_INT 5
78438: EQUAL
78439: IFFALSE 78449
// r := 0 ;
78441: LD_ADDR_VAR 0 15
78445: PUSH
78446: LD_INT 0
78448: ST_TO_ADDR
// for j = r to 5 do
78449: LD_ADDR_VAR 0 10
78453: PUSH
78454: DOUBLE
78455: LD_VAR 0 15
78459: DEC
78460: ST_TO_ADDR
78461: LD_INT 5
78463: PUSH
78464: FOR_TO
78465: IFFALSE 78579
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78467: LD_ADDR_VAR 0 11
78471: PUSH
78472: LD_VAR 0 13
78476: PPUSH
78477: CALL_OW 250
78481: PPUSH
78482: LD_VAR 0 10
78486: PPUSH
78487: LD_INT 2
78489: PPUSH
78490: CALL_OW 272
78494: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78495: LD_ADDR_VAR 0 12
78499: PUSH
78500: LD_VAR 0 13
78504: PPUSH
78505: CALL_OW 251
78509: PPUSH
78510: LD_VAR 0 10
78514: PPUSH
78515: LD_INT 2
78517: PPUSH
78518: CALL_OW 273
78522: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78523: LD_VAR 0 11
78527: PPUSH
78528: LD_VAR 0 12
78532: PPUSH
78533: CALL_OW 488
78537: PUSH
78538: LD_VAR 0 11
78542: PPUSH
78543: LD_VAR 0 12
78547: PPUSH
78548: CALL_OW 428
78552: NOT
78553: AND
78554: IFFALSE 78577
// begin ComMoveXY ( tmp , _x , _y ) ;
78556: LD_VAR 0 13
78560: PPUSH
78561: LD_VAR 0 11
78565: PPUSH
78566: LD_VAR 0 12
78570: PPUSH
78571: CALL_OW 111
// break ;
78575: GO 78579
// end ; end ;
78577: GO 78464
78579: POP
78580: POP
// end ; end ;
78581: GO 77906
78583: POP
78584: POP
// end ;
78585: LD_VAR 0 8
78589: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78590: LD_INT 0
78592: PPUSH
// result := true ;
78593: LD_ADDR_VAR 0 3
78597: PUSH
78598: LD_INT 1
78600: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78601: LD_VAR 0 2
78605: PUSH
78606: LD_INT 24
78608: DOUBLE
78609: EQUAL
78610: IFTRUE 78620
78612: LD_INT 33
78614: DOUBLE
78615: EQUAL
78616: IFTRUE 78620
78618: GO 78645
78620: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78621: LD_ADDR_VAR 0 3
78625: PUSH
78626: LD_INT 32
78628: PPUSH
78629: LD_VAR 0 1
78633: PPUSH
78634: CALL_OW 321
78638: PUSH
78639: LD_INT 2
78641: EQUAL
78642: ST_TO_ADDR
78643: GO 78961
78645: LD_INT 20
78647: DOUBLE
78648: EQUAL
78649: IFTRUE 78653
78651: GO 78678
78653: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78654: LD_ADDR_VAR 0 3
78658: PUSH
78659: LD_INT 6
78661: PPUSH
78662: LD_VAR 0 1
78666: PPUSH
78667: CALL_OW 321
78671: PUSH
78672: LD_INT 2
78674: EQUAL
78675: ST_TO_ADDR
78676: GO 78961
78678: LD_INT 22
78680: DOUBLE
78681: EQUAL
78682: IFTRUE 78692
78684: LD_INT 36
78686: DOUBLE
78687: EQUAL
78688: IFTRUE 78692
78690: GO 78717
78692: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78693: LD_ADDR_VAR 0 3
78697: PUSH
78698: LD_INT 15
78700: PPUSH
78701: LD_VAR 0 1
78705: PPUSH
78706: CALL_OW 321
78710: PUSH
78711: LD_INT 2
78713: EQUAL
78714: ST_TO_ADDR
78715: GO 78961
78717: LD_INT 30
78719: DOUBLE
78720: EQUAL
78721: IFTRUE 78725
78723: GO 78750
78725: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78726: LD_ADDR_VAR 0 3
78730: PUSH
78731: LD_INT 20
78733: PPUSH
78734: LD_VAR 0 1
78738: PPUSH
78739: CALL_OW 321
78743: PUSH
78744: LD_INT 2
78746: EQUAL
78747: ST_TO_ADDR
78748: GO 78961
78750: LD_INT 28
78752: DOUBLE
78753: EQUAL
78754: IFTRUE 78764
78756: LD_INT 21
78758: DOUBLE
78759: EQUAL
78760: IFTRUE 78764
78762: GO 78789
78764: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78765: LD_ADDR_VAR 0 3
78769: PUSH
78770: LD_INT 21
78772: PPUSH
78773: LD_VAR 0 1
78777: PPUSH
78778: CALL_OW 321
78782: PUSH
78783: LD_INT 2
78785: EQUAL
78786: ST_TO_ADDR
78787: GO 78961
78789: LD_INT 16
78791: DOUBLE
78792: EQUAL
78793: IFTRUE 78797
78795: GO 78822
78797: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78798: LD_ADDR_VAR 0 3
78802: PUSH
78803: LD_INT 84
78805: PPUSH
78806: LD_VAR 0 1
78810: PPUSH
78811: CALL_OW 321
78815: PUSH
78816: LD_INT 2
78818: EQUAL
78819: ST_TO_ADDR
78820: GO 78961
78822: LD_INT 19
78824: DOUBLE
78825: EQUAL
78826: IFTRUE 78836
78828: LD_INT 23
78830: DOUBLE
78831: EQUAL
78832: IFTRUE 78836
78834: GO 78861
78836: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78837: LD_ADDR_VAR 0 3
78841: PUSH
78842: LD_INT 83
78844: PPUSH
78845: LD_VAR 0 1
78849: PPUSH
78850: CALL_OW 321
78854: PUSH
78855: LD_INT 2
78857: EQUAL
78858: ST_TO_ADDR
78859: GO 78961
78861: LD_INT 17
78863: DOUBLE
78864: EQUAL
78865: IFTRUE 78869
78867: GO 78894
78869: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78870: LD_ADDR_VAR 0 3
78874: PUSH
78875: LD_INT 39
78877: PPUSH
78878: LD_VAR 0 1
78882: PPUSH
78883: CALL_OW 321
78887: PUSH
78888: LD_INT 2
78890: EQUAL
78891: ST_TO_ADDR
78892: GO 78961
78894: LD_INT 18
78896: DOUBLE
78897: EQUAL
78898: IFTRUE 78902
78900: GO 78927
78902: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78903: LD_ADDR_VAR 0 3
78907: PUSH
78908: LD_INT 40
78910: PPUSH
78911: LD_VAR 0 1
78915: PPUSH
78916: CALL_OW 321
78920: PUSH
78921: LD_INT 2
78923: EQUAL
78924: ST_TO_ADDR
78925: GO 78961
78927: LD_INT 27
78929: DOUBLE
78930: EQUAL
78931: IFTRUE 78935
78933: GO 78960
78935: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78936: LD_ADDR_VAR 0 3
78940: PUSH
78941: LD_INT 35
78943: PPUSH
78944: LD_VAR 0 1
78948: PPUSH
78949: CALL_OW 321
78953: PUSH
78954: LD_INT 2
78956: EQUAL
78957: ST_TO_ADDR
78958: GO 78961
78960: POP
// end ;
78961: LD_VAR 0 3
78965: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78966: LD_INT 0
78968: PPUSH
78969: PPUSH
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
78974: PPUSH
78975: PPUSH
78976: PPUSH
78977: PPUSH
78978: PPUSH
// result := false ;
78979: LD_ADDR_VAR 0 6
78983: PUSH
78984: LD_INT 0
78986: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78987: LD_VAR 0 1
78991: NOT
78992: PUSH
78993: LD_VAR 0 1
78997: PPUSH
78998: CALL_OW 266
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: LD_INT 1
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: IN
79013: NOT
79014: OR
79015: PUSH
79016: LD_VAR 0 2
79020: NOT
79021: OR
79022: PUSH
79023: LD_VAR 0 5
79027: PUSH
79028: LD_INT 0
79030: PUSH
79031: LD_INT 1
79033: PUSH
79034: LD_INT 2
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: LD_INT 4
79042: PUSH
79043: LD_INT 5
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: LIST
79050: LIST
79051: LIST
79052: LIST
79053: IN
79054: NOT
79055: OR
79056: PUSH
79057: LD_VAR 0 3
79061: PPUSH
79062: LD_VAR 0 4
79066: PPUSH
79067: CALL_OW 488
79071: NOT
79072: OR
79073: IFFALSE 79077
// exit ;
79075: GO 79813
// side := GetSide ( depot ) ;
79077: LD_ADDR_VAR 0 9
79081: PUSH
79082: LD_VAR 0 1
79086: PPUSH
79087: CALL_OW 255
79091: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79092: LD_VAR 0 9
79096: PPUSH
79097: LD_VAR 0 2
79101: PPUSH
79102: CALL 78590 0 2
79106: NOT
79107: IFFALSE 79111
// exit ;
79109: GO 79813
// pom := GetBase ( depot ) ;
79111: LD_ADDR_VAR 0 10
79115: PUSH
79116: LD_VAR 0 1
79120: PPUSH
79121: CALL_OW 274
79125: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79126: LD_ADDR_VAR 0 11
79130: PUSH
79131: LD_VAR 0 2
79135: PPUSH
79136: LD_VAR 0 1
79140: PPUSH
79141: CALL_OW 248
79145: PPUSH
79146: CALL_OW 450
79150: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79151: LD_VAR 0 10
79155: PPUSH
79156: LD_INT 1
79158: PPUSH
79159: CALL_OW 275
79163: PUSH
79164: LD_VAR 0 11
79168: PUSH
79169: LD_INT 1
79171: ARRAY
79172: GREATEREQUAL
79173: PUSH
79174: LD_VAR 0 10
79178: PPUSH
79179: LD_INT 2
79181: PPUSH
79182: CALL_OW 275
79186: PUSH
79187: LD_VAR 0 11
79191: PUSH
79192: LD_INT 2
79194: ARRAY
79195: GREATEREQUAL
79196: AND
79197: PUSH
79198: LD_VAR 0 10
79202: PPUSH
79203: LD_INT 3
79205: PPUSH
79206: CALL_OW 275
79210: PUSH
79211: LD_VAR 0 11
79215: PUSH
79216: LD_INT 3
79218: ARRAY
79219: GREATEREQUAL
79220: AND
79221: NOT
79222: IFFALSE 79226
// exit ;
79224: GO 79813
// if GetBType ( depot ) = b_depot then
79226: LD_VAR 0 1
79230: PPUSH
79231: CALL_OW 266
79235: PUSH
79236: LD_INT 0
79238: EQUAL
79239: IFFALSE 79251
// dist := 28 else
79241: LD_ADDR_VAR 0 14
79245: PUSH
79246: LD_INT 28
79248: ST_TO_ADDR
79249: GO 79259
// dist := 36 ;
79251: LD_ADDR_VAR 0 14
79255: PUSH
79256: LD_INT 36
79258: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79259: LD_VAR 0 1
79263: PPUSH
79264: LD_VAR 0 3
79268: PPUSH
79269: LD_VAR 0 4
79273: PPUSH
79274: CALL_OW 297
79278: PUSH
79279: LD_VAR 0 14
79283: GREATER
79284: IFFALSE 79288
// exit ;
79286: GO 79813
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79288: LD_ADDR_VAR 0 12
79292: PUSH
79293: LD_VAR 0 2
79297: PPUSH
79298: LD_VAR 0 3
79302: PPUSH
79303: LD_VAR 0 4
79307: PPUSH
79308: LD_VAR 0 5
79312: PPUSH
79313: LD_VAR 0 1
79317: PPUSH
79318: CALL_OW 248
79322: PPUSH
79323: LD_INT 0
79325: PPUSH
79326: CALL 79818 0 6
79330: ST_TO_ADDR
// if not hexes then
79331: LD_VAR 0 12
79335: NOT
79336: IFFALSE 79340
// exit ;
79338: GO 79813
// hex := GetHexInfo ( x , y ) ;
79340: LD_ADDR_VAR 0 15
79344: PUSH
79345: LD_VAR 0 3
79349: PPUSH
79350: LD_VAR 0 4
79354: PPUSH
79355: CALL_OW 546
79359: ST_TO_ADDR
// if hex [ 1 ] then
79360: LD_VAR 0 15
79364: PUSH
79365: LD_INT 1
79367: ARRAY
79368: IFFALSE 79372
// exit ;
79370: GO 79813
// height := hex [ 2 ] ;
79372: LD_ADDR_VAR 0 13
79376: PUSH
79377: LD_VAR 0 15
79381: PUSH
79382: LD_INT 2
79384: ARRAY
79385: ST_TO_ADDR
// for i = 1 to hexes do
79386: LD_ADDR_VAR 0 7
79390: PUSH
79391: DOUBLE
79392: LD_INT 1
79394: DEC
79395: ST_TO_ADDR
79396: LD_VAR 0 12
79400: PUSH
79401: FOR_TO
79402: IFFALSE 79732
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79404: LD_VAR 0 12
79408: PUSH
79409: LD_VAR 0 7
79413: ARRAY
79414: PUSH
79415: LD_INT 1
79417: ARRAY
79418: PPUSH
79419: LD_VAR 0 12
79423: PUSH
79424: LD_VAR 0 7
79428: ARRAY
79429: PUSH
79430: LD_INT 2
79432: ARRAY
79433: PPUSH
79434: CALL_OW 488
79438: NOT
79439: PUSH
79440: LD_VAR 0 12
79444: PUSH
79445: LD_VAR 0 7
79449: ARRAY
79450: PUSH
79451: LD_INT 1
79453: ARRAY
79454: PPUSH
79455: LD_VAR 0 12
79459: PUSH
79460: LD_VAR 0 7
79464: ARRAY
79465: PUSH
79466: LD_INT 2
79468: ARRAY
79469: PPUSH
79470: CALL_OW 428
79474: PUSH
79475: LD_INT 0
79477: GREATER
79478: OR
79479: PUSH
79480: LD_VAR 0 12
79484: PUSH
79485: LD_VAR 0 7
79489: ARRAY
79490: PUSH
79491: LD_INT 1
79493: ARRAY
79494: PPUSH
79495: LD_VAR 0 12
79499: PUSH
79500: LD_VAR 0 7
79504: ARRAY
79505: PUSH
79506: LD_INT 2
79508: ARRAY
79509: PPUSH
79510: CALL_OW 351
79514: OR
79515: IFFALSE 79521
// exit ;
79517: POP
79518: POP
79519: GO 79813
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79521: LD_ADDR_VAR 0 8
79525: PUSH
79526: LD_VAR 0 12
79530: PUSH
79531: LD_VAR 0 7
79535: ARRAY
79536: PUSH
79537: LD_INT 1
79539: ARRAY
79540: PPUSH
79541: LD_VAR 0 12
79545: PUSH
79546: LD_VAR 0 7
79550: ARRAY
79551: PUSH
79552: LD_INT 2
79554: ARRAY
79555: PPUSH
79556: CALL_OW 546
79560: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79561: LD_VAR 0 8
79565: PUSH
79566: LD_INT 1
79568: ARRAY
79569: PUSH
79570: LD_VAR 0 8
79574: PUSH
79575: LD_INT 2
79577: ARRAY
79578: PUSH
79579: LD_VAR 0 13
79583: PUSH
79584: LD_INT 2
79586: PLUS
79587: GREATER
79588: OR
79589: PUSH
79590: LD_VAR 0 8
79594: PUSH
79595: LD_INT 2
79597: ARRAY
79598: PUSH
79599: LD_VAR 0 13
79603: PUSH
79604: LD_INT 2
79606: MINUS
79607: LESS
79608: OR
79609: PUSH
79610: LD_VAR 0 8
79614: PUSH
79615: LD_INT 3
79617: ARRAY
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: LD_INT 8
79624: PUSH
79625: LD_INT 9
79627: PUSH
79628: LD_INT 10
79630: PUSH
79631: LD_INT 11
79633: PUSH
79634: LD_INT 12
79636: PUSH
79637: LD_INT 13
79639: PUSH
79640: LD_INT 16
79642: PUSH
79643: LD_INT 17
79645: PUSH
79646: LD_INT 18
79648: PUSH
79649: LD_INT 19
79651: PUSH
79652: LD_INT 20
79654: PUSH
79655: LD_INT 21
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: LIST
79662: LIST
79663: LIST
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: IN
79673: NOT
79674: OR
79675: PUSH
79676: LD_VAR 0 8
79680: PUSH
79681: LD_INT 5
79683: ARRAY
79684: NOT
79685: OR
79686: PUSH
79687: LD_VAR 0 8
79691: PUSH
79692: LD_INT 6
79694: ARRAY
79695: PUSH
79696: LD_INT 1
79698: PUSH
79699: LD_INT 2
79701: PUSH
79702: LD_INT 7
79704: PUSH
79705: LD_INT 9
79707: PUSH
79708: LD_INT 10
79710: PUSH
79711: LD_INT 11
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: IN
79722: NOT
79723: OR
79724: IFFALSE 79730
// exit ;
79726: POP
79727: POP
79728: GO 79813
// end ;
79730: GO 79401
79732: POP
79733: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79734: LD_VAR 0 9
79738: PPUSH
79739: LD_VAR 0 3
79743: PPUSH
79744: LD_VAR 0 4
79748: PPUSH
79749: LD_INT 20
79751: PPUSH
79752: CALL 71765 0 4
79756: PUSH
79757: LD_INT 4
79759: ARRAY
79760: IFFALSE 79764
// exit ;
79762: GO 79813
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79764: LD_VAR 0 2
79768: PUSH
79769: LD_INT 29
79771: PUSH
79772: LD_INT 30
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: IN
79779: PUSH
79780: LD_VAR 0 3
79784: PPUSH
79785: LD_VAR 0 4
79789: PPUSH
79790: LD_VAR 0 9
79794: PPUSH
79795: CALL_OW 440
79799: NOT
79800: AND
79801: IFFALSE 79805
// exit ;
79803: GO 79813
// result := true ;
79805: LD_ADDR_VAR 0 6
79809: PUSH
79810: LD_INT 1
79812: ST_TO_ADDR
// end ;
79813: LD_VAR 0 6
79817: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79818: LD_INT 0
79820: PPUSH
79821: PPUSH
79822: PPUSH
79823: PPUSH
79824: PPUSH
79825: PPUSH
79826: PPUSH
79827: PPUSH
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
79833: PPUSH
79834: PPUSH
79835: PPUSH
79836: PPUSH
79837: PPUSH
79838: PPUSH
79839: PPUSH
79840: PPUSH
79841: PPUSH
79842: PPUSH
79843: PPUSH
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
79851: PPUSH
79852: PPUSH
79853: PPUSH
79854: PPUSH
79855: PPUSH
79856: PPUSH
79857: PPUSH
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
// result = [ ] ;
79878: LD_ADDR_VAR 0 7
79882: PUSH
79883: EMPTY
79884: ST_TO_ADDR
// temp_list = [ ] ;
79885: LD_ADDR_VAR 0 9
79889: PUSH
79890: EMPTY
79891: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79892: LD_VAR 0 4
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: LD_INT 2
79905: PUSH
79906: LD_INT 3
79908: PUSH
79909: LD_INT 4
79911: PUSH
79912: LD_INT 5
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: IN
79923: NOT
79924: PUSH
79925: LD_VAR 0 1
79929: PUSH
79930: LD_INT 0
79932: PUSH
79933: LD_INT 1
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: IN
79940: PUSH
79941: LD_VAR 0 5
79945: PUSH
79946: LD_INT 1
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: LD_INT 3
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: LIST
79959: IN
79960: NOT
79961: AND
79962: OR
79963: IFFALSE 79967
// exit ;
79965: GO 98358
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79967: LD_VAR 0 1
79971: PUSH
79972: LD_INT 6
79974: PUSH
79975: LD_INT 7
79977: PUSH
79978: LD_INT 8
79980: PUSH
79981: LD_INT 13
79983: PUSH
79984: LD_INT 12
79986: PUSH
79987: LD_INT 15
79989: PUSH
79990: LD_INT 11
79992: PUSH
79993: LD_INT 14
79995: PUSH
79996: LD_INT 10
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: IN
80010: IFFALSE 80020
// btype = b_lab ;
80012: LD_ADDR_VAR 0 1
80016: PUSH
80017: LD_INT 6
80019: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80020: LD_VAR 0 6
80024: PUSH
80025: LD_INT 0
80027: PUSH
80028: LD_INT 1
80030: PUSH
80031: LD_INT 2
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: LIST
80038: IN
80039: NOT
80040: PUSH
80041: LD_VAR 0 1
80045: PUSH
80046: LD_INT 0
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: LD_INT 2
80054: PUSH
80055: LD_INT 3
80057: PUSH
80058: LD_INT 6
80060: PUSH
80061: LD_INT 36
80063: PUSH
80064: LD_INT 4
80066: PUSH
80067: LD_INT 5
80069: PUSH
80070: LD_INT 31
80072: PUSH
80073: LD_INT 32
80075: PUSH
80076: LD_INT 33
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: IN
80092: NOT
80093: PUSH
80094: LD_VAR 0 6
80098: PUSH
80099: LD_INT 1
80101: EQUAL
80102: AND
80103: OR
80104: PUSH
80105: LD_VAR 0 1
80109: PUSH
80110: LD_INT 2
80112: PUSH
80113: LD_INT 3
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: IN
80120: NOT
80121: PUSH
80122: LD_VAR 0 6
80126: PUSH
80127: LD_INT 2
80129: EQUAL
80130: AND
80131: OR
80132: IFFALSE 80142
// mode = 0 ;
80134: LD_ADDR_VAR 0 6
80138: PUSH
80139: LD_INT 0
80141: ST_TO_ADDR
// case mode of 0 :
80142: LD_VAR 0 6
80146: PUSH
80147: LD_INT 0
80149: DOUBLE
80150: EQUAL
80151: IFTRUE 80155
80153: GO 91608
80155: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80156: LD_ADDR_VAR 0 11
80160: PUSH
80161: LD_INT 0
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 0
80173: PUSH
80174: LD_INT 1
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 1
80184: PUSH
80185: LD_INT 0
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 1
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: LD_INT 1
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 1
80225: NEG
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 1
80237: NEG
80238: PUSH
80239: LD_INT 2
80241: NEG
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: LD_INT 2
80252: NEG
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: LD_INT 1
80263: NEG
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 1
80271: PUSH
80272: LD_INT 2
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 0
80281: PUSH
80282: LD_INT 2
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: NEG
80292: PUSH
80293: LD_INT 1
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 1
80302: PUSH
80303: LD_INT 3
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: LD_INT 3
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 1
80322: NEG
80323: PUSH
80324: LD_INT 2
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80349: LD_ADDR_VAR 0 12
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: LD_INT 0
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: LD_INT 0
80366: PUSH
80367: LD_INT 1
80369: NEG
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: LD_INT 0
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 1
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: LD_INT 1
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: LD_INT 0
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: NEG
80419: PUSH
80420: LD_INT 1
80422: NEG
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 2
80451: PUSH
80452: LD_INT 1
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: NEG
80462: PUSH
80463: LD_INT 1
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 2
80472: NEG
80473: PUSH
80474: LD_INT 0
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PUSH
80481: LD_INT 2
80483: NEG
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: NEG
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 3
80506: NEG
80507: PUSH
80508: LD_INT 0
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 3
80517: NEG
80518: PUSH
80519: LD_INT 1
80521: NEG
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80545: LD_ADDR_VAR 0 13
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 0
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 0
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: LD_INT 2
80630: NEG
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 2
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 2
80648: PUSH
80649: LD_INT 2
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: LD_INT 2
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: LD_INT 1
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 2
80680: NEG
80681: PUSH
80682: LD_INT 2
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 2
80692: NEG
80693: PUSH
80694: LD_INT 3
80696: NEG
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PUSH
80702: LD_INT 3
80704: NEG
80705: PUSH
80706: LD_INT 2
80708: NEG
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 3
80716: NEG
80717: PUSH
80718: LD_INT 3
80720: NEG
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80744: LD_ADDR_VAR 0 14
80748: PUSH
80749: LD_INT 0
80751: PUSH
80752: LD_INT 0
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: LD_INT 1
80764: NEG
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 1
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: LD_INT 1
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: LD_INT 1
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: LD_INT 2
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: LD_INT 2
80840: NEG
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 1
80848: PUSH
80849: LD_INT 1
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 1
80859: PUSH
80860: LD_INT 2
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: LD_INT 2
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: NEG
80891: PUSH
80892: LD_INT 3
80894: NEG
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 0
80902: PUSH
80903: LD_INT 3
80905: NEG
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 1
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80940: LD_ADDR_VAR 0 15
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 1
80960: NEG
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 2
81032: PUSH
81033: LD_INT 0
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: LD_INT 1
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: NEG
81053: PUSH
81054: LD_INT 1
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: NEG
81064: PUSH
81065: LD_INT 0
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 2
81074: NEG
81075: PUSH
81076: LD_INT 1
81078: NEG
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 2
81086: PUSH
81087: LD_INT 1
81089: NEG
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 3
81097: PUSH
81098: LD_INT 0
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 3
81107: PUSH
81108: LD_INT 1
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: LIST
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81133: LD_ADDR_VAR 0 16
81137: PUSH
81138: LD_INT 0
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 0
81150: PUSH
81151: LD_INT 1
81153: NEG
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: LD_INT 0
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 1
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 0
81181: PUSH
81182: LD_INT 1
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 1
81191: NEG
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: NEG
81203: PUSH
81204: LD_INT 1
81206: NEG
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: LD_INT 2
81218: NEG
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: LD_INT 2
81226: PUSH
81227: LD_INT 1
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 2
81236: PUSH
81237: LD_INT 2
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 1
81246: PUSH
81247: LD_INT 2
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 2
81256: NEG
81257: PUSH
81258: LD_INT 1
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: NEG
81269: PUSH
81270: LD_INT 2
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 3
81280: PUSH
81281: LD_INT 2
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 3
81290: PUSH
81291: LD_INT 3
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: LD_INT 3
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81326: LD_ADDR_VAR 0 17
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: LD_INT 0
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 0
81343: PUSH
81344: LD_INT 1
81346: NEG
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 1
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 1
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: LD_INT 1
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: PUSH
81397: LD_INT 1
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: LD_INT 2
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: LD_INT 2
81422: NEG
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 1
81430: PUSH
81431: LD_INT 1
81433: NEG
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 2
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 2
81451: PUSH
81452: LD_INT 1
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 2
81461: PUSH
81462: LD_INT 2
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 1
81471: PUSH
81472: LD_INT 2
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 2
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: NEG
81492: PUSH
81493: LD_INT 1
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 2
81502: NEG
81503: PUSH
81504: LD_INT 0
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 2
81513: NEG
81514: PUSH
81515: LD_INT 1
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 2
81525: NEG
81526: PUSH
81527: LD_INT 2
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81556: LD_ADDR_VAR 0 18
81560: PUSH
81561: LD_INT 0
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 0
81573: PUSH
81574: LD_INT 1
81576: NEG
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 1
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: LD_INT 1
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: LD_INT 1
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 1
81614: NEG
81615: PUSH
81616: LD_INT 0
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: NEG
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: LD_INT 2
81652: NEG
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: PUSH
81661: LD_INT 1
81663: NEG
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 2
81671: PUSH
81672: LD_INT 0
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 2
81681: PUSH
81682: LD_INT 1
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 2
81691: PUSH
81692: LD_INT 2
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: LD_INT 2
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: LD_INT 2
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 1
81721: NEG
81722: PUSH
81723: LD_INT 1
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 2
81732: NEG
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 2
81743: NEG
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 2
81755: NEG
81756: PUSH
81757: LD_INT 2
81759: NEG
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81786: LD_ADDR_VAR 0 19
81790: PUSH
81791: LD_INT 0
81793: PUSH
81794: LD_INT 0
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: LD_INT 1
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: PUSH
81815: LD_INT 0
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 1
81824: PUSH
81825: LD_INT 1
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: LD_INT 1
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 1
81855: NEG
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: LD_INT 2
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: LD_INT 2
81882: NEG
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 1
81890: PUSH
81891: LD_INT 1
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 2
81911: PUSH
81912: LD_INT 1
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 2
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: LD_INT 2
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 2
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 2
81962: NEG
81963: PUSH
81964: LD_INT 0
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 2
81973: NEG
81974: PUSH
81975: LD_INT 1
81977: NEG
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 2
81985: NEG
81986: PUSH
81987: LD_INT 2
81989: NEG
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82016: LD_ADDR_VAR 0 20
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: LD_INT 0
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 1
82074: NEG
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: NEG
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: LD_INT 2
82101: NEG
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: LD_INT 2
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 2
82151: PUSH
82152: LD_INT 2
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 1
82161: PUSH
82162: LD_INT 2
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 0
82171: PUSH
82172: LD_INT 2
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: NEG
82182: PUSH
82183: LD_INT 1
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 2
82192: NEG
82193: PUSH
82194: LD_INT 0
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 2
82215: NEG
82216: PUSH
82217: LD_INT 2
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82246: LD_ADDR_VAR 0 21
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: LD_INT 0
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: LD_INT 1
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: LD_INT 1
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: LD_INT 1
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: NEG
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: LD_INT 2
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 2
82342: NEG
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 2
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 2
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 2
82381: PUSH
82382: LD_INT 2
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 1
82391: PUSH
82392: LD_INT 2
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: LD_INT 2
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 1
82411: NEG
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 2
82422: NEG
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 2
82433: NEG
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 2
82445: NEG
82446: PUSH
82447: LD_INT 2
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82476: LD_ADDR_VAR 0 22
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: LD_INT 0
82486: PUSH
82487: EMPTY
82488: LIST
82489: LIST
82490: PUSH
82491: LD_INT 0
82493: PUSH
82494: LD_INT 1
82496: NEG
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 1
82504: PUSH
82505: LD_INT 0
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 1
82514: PUSH
82515: LD_INT 1
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: LD_INT 1
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: LD_INT 1
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: LD_INT 2
82561: NEG
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: LD_INT 2
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: PUSH
82581: LD_INT 1
82583: NEG
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PUSH
82589: LD_INT 2
82591: PUSH
82592: LD_INT 0
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 2
82601: PUSH
82602: LD_INT 1
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 2
82611: PUSH
82612: LD_INT 2
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 1
82621: PUSH
82622: LD_INT 2
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: LD_INT 2
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 1
82641: NEG
82642: PUSH
82643: LD_INT 1
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 2
82652: NEG
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 2
82675: NEG
82676: PUSH
82677: LD_INT 2
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82706: LD_ADDR_VAR 0 23
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: LD_INT 0
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: LD_INT 1
82726: NEG
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 1
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: LD_INT 0
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: NEG
82776: PUSH
82777: LD_INT 1
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: LD_INT 2
82791: NEG
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: LD_INT 2
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 2
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 2
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 1
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 2
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: NEG
82872: PUSH
82873: LD_INT 1
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: NEG
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 2
82893: NEG
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 2
82905: NEG
82906: PUSH
82907: LD_INT 2
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 2
82917: NEG
82918: PUSH
82919: LD_INT 3
82921: NEG
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 1
82929: NEG
82930: PUSH
82931: LD_INT 3
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: LD_INT 1
82955: NEG
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82986: LD_ADDR_VAR 0 24
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: LD_INT 0
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 0
83003: PUSH
83004: LD_INT 1
83006: NEG
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 1
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 0
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 1
83044: NEG
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 1
83059: NEG
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 2
83071: NEG
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 0
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 2
83162: NEG
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 2
83173: NEG
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 2
83185: NEG
83186: PUSH
83187: LD_INT 2
83189: NEG
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_INT 1
83197: PUSH
83198: LD_INT 2
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 3
83219: PUSH
83220: LD_INT 1
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 3
83229: PUSH
83230: LD_INT 2
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83262: LD_ADDR_VAR 0 25
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 0
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 0
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 1
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 1
83320: NEG
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 1
83331: NEG
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 1
83343: NEG
83344: PUSH
83345: LD_INT 2
83347: NEG
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 0
83355: PUSH
83356: LD_INT 2
83358: NEG
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 1
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 2
83387: PUSH
83388: LD_INT 1
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 2
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: PUSH
83408: LD_INT 2
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 0
83417: PUSH
83418: LD_INT 2
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: NEG
83428: PUSH
83429: LD_INT 1
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 2
83438: NEG
83439: PUSH
83440: LD_INT 0
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 2
83449: NEG
83450: PUSH
83451: LD_INT 1
83453: NEG
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: NEG
83462: PUSH
83463: LD_INT 2
83465: NEG
83466: PUSH
83467: EMPTY
83468: LIST
83469: LIST
83470: PUSH
83471: LD_INT 3
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 3
83483: PUSH
83484: LD_INT 2
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 2
83493: PUSH
83494: LD_INT 3
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: LD_INT 3
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83536: LD_ADDR_VAR 0 26
83540: PUSH
83541: LD_INT 0
83543: PUSH
83544: LD_INT 0
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 1
83556: NEG
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 1
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 1
83594: NEG
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 1
83605: NEG
83606: PUSH
83607: LD_INT 1
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 2
83621: NEG
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 0
83629: PUSH
83630: LD_INT 2
83632: NEG
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 1
83640: PUSH
83641: LD_INT 1
83643: NEG
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 2
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 2
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 2
83671: PUSH
83672: LD_INT 2
83674: PUSH
83675: EMPTY
83676: LIST
83677: LIST
83678: PUSH
83679: LD_INT 1
83681: PUSH
83682: LD_INT 2
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: PUSH
83689: LD_INT 0
83691: PUSH
83692: LD_INT 2
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: LD_INT 1
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 2
83712: NEG
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 2
83723: NEG
83724: PUSH
83725: LD_INT 1
83727: NEG
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: LD_INT 2
83739: NEG
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 2
83747: PUSH
83748: LD_INT 3
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: PUSH
83758: LD_INT 3
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: LD_INT 2
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 2
83778: NEG
83779: PUSH
83780: LD_INT 1
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83812: LD_ADDR_VAR 0 27
83816: PUSH
83817: LD_INT 0
83819: PUSH
83820: LD_INT 0
83822: PUSH
83823: EMPTY
83824: LIST
83825: LIST
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 1
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: NEG
83882: PUSH
83883: LD_INT 1
83885: NEG
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: LD_INT 2
83897: NEG
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 1
83916: PUSH
83917: LD_INT 1
83919: NEG
83920: PUSH
83921: EMPTY
83922: LIST
83923: LIST
83924: PUSH
83925: LD_INT 2
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 2
83937: PUSH
83938: LD_INT 1
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: LD_INT 2
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 1
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 0
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: LD_INT 1
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: NEG
84012: PUSH
84013: LD_INT 2
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: LD_INT 2
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 2
84034: NEG
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 3
84045: NEG
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 3
84057: NEG
84058: PUSH
84059: LD_INT 2
84061: NEG
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84092: LD_ADDR_VAR 0 28
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: LD_INT 0
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 0
84109: PUSH
84110: LD_INT 1
84112: NEG
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 1
84120: PUSH
84121: LD_INT 0
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: LD_INT 1
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: LD_INT 1
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: NEG
84151: PUSH
84152: LD_INT 0
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: NEG
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: NEG
84174: PUSH
84175: LD_INT 2
84177: NEG
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: LD_INT 0
84185: PUSH
84186: LD_INT 2
84188: NEG
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: LD_INT 1
84199: NEG
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 2
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 2
84217: PUSH
84218: LD_INT 1
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 2
84227: PUSH
84228: LD_INT 2
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 1
84237: PUSH
84238: LD_INT 2
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 0
84247: PUSH
84248: LD_INT 2
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 1
84257: NEG
84258: PUSH
84259: LD_INT 1
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 2
84268: NEG
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 2
84279: NEG
84280: PUSH
84281: LD_INT 1
84283: NEG
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 2
84291: NEG
84292: PUSH
84293: LD_INT 2
84295: NEG
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 2
84303: NEG
84304: PUSH
84305: LD_INT 3
84307: NEG
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 1
84315: NEG
84316: PUSH
84317: LD_INT 3
84319: NEG
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: LD_INT 3
84327: NEG
84328: PUSH
84329: LD_INT 1
84331: NEG
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 3
84339: NEG
84340: PUSH
84341: LD_INT 2
84343: NEG
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84374: LD_ADDR_VAR 0 29
84378: PUSH
84379: LD_INT 0
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 0
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: LD_INT 0
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 1
84412: PUSH
84413: LD_INT 1
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 0
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 1
84432: NEG
84433: PUSH
84434: LD_INT 0
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 1
84443: NEG
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: LD_INT 2
84470: NEG
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 1
84478: PUSH
84479: LD_INT 1
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 2
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 2
84499: PUSH
84500: LD_INT 1
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 1
84509: PUSH
84510: LD_INT 2
84512: PUSH
84513: EMPTY
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 0
84519: PUSH
84520: LD_INT 2
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 1
84529: NEG
84530: PUSH
84531: LD_INT 1
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 2
84540: NEG
84541: PUSH
84542: LD_INT 1
84544: NEG
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 2
84552: NEG
84553: PUSH
84554: LD_INT 2
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: LD_INT 3
84568: NEG
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 2
84576: PUSH
84577: LD_INT 1
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 3
84587: PUSH
84588: LD_INT 1
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: LD_INT 3
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 1
84607: NEG
84608: PUSH
84609: LD_INT 2
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 3
84618: NEG
84619: PUSH
84620: LD_INT 2
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: EMPTY
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: LIST
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84653: LD_ADDR_VAR 0 30
84657: PUSH
84658: LD_INT 0
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: LD_INT 1
84673: NEG
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 1
84681: PUSH
84682: LD_INT 0
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: PUSH
84692: LD_INT 1
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: NEG
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: NEG
84723: PUSH
84724: LD_INT 1
84726: NEG
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: LD_INT 2
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: LD_INT 2
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 2
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 2
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 2
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: LD_INT 2
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 1
84808: NEG
84809: PUSH
84810: LD_INT 1
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 2
84819: NEG
84820: PUSH
84821: LD_INT 0
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 2
84830: NEG
84831: PUSH
84832: LD_INT 1
84834: NEG
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: LD_INT 3
84846: NEG
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 1
84854: PUSH
84855: LD_INT 2
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 3
84865: PUSH
84866: LD_INT 2
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 2
84875: PUSH
84876: LD_INT 3
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 2
84885: NEG
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 3
84896: NEG
84897: PUSH
84898: LD_INT 1
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84931: LD_ADDR_VAR 0 31
84935: PUSH
84936: LD_INT 0
84938: PUSH
84939: LD_INT 0
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 0
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 1
84959: PUSH
84960: LD_INT 0
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 1
84969: PUSH
84970: LD_INT 1
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: NEG
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: LD_INT 2
85016: NEG
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: PUSH
85036: LD_INT 0
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 2
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 2
85055: PUSH
85056: LD_INT 2
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 1
85065: PUSH
85066: LD_INT 2
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: LD_INT 2
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 2
85096: NEG
85097: PUSH
85098: LD_INT 1
85100: NEG
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 2
85108: NEG
85109: PUSH
85110: LD_INT 2
85112: NEG
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: LD_INT 3
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 2
85132: PUSH
85133: LD_INT 1
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 3
85143: PUSH
85144: LD_INT 1
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: LD_INT 3
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 1
85163: NEG
85164: PUSH
85165: LD_INT 2
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 3
85174: NEG
85175: PUSH
85176: LD_INT 2
85178: NEG
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85209: LD_ADDR_VAR 0 32
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: LD_INT 1
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: LD_INT 0
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 1
85247: PUSH
85248: LD_INT 1
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: LD_INT 1
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: LD_INT 2
85294: NEG
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 0
85302: PUSH
85303: LD_INT 2
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: PUSH
85325: LD_INT 1
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: LD_INT 2
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: LD_INT 2
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 0
85354: PUSH
85355: LD_INT 2
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 0
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 2
85386: NEG
85387: PUSH
85388: LD_INT 1
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: LD_INT 3
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 1
85410: PUSH
85411: LD_INT 2
85413: NEG
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 3
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 2
85431: PUSH
85432: LD_INT 3
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 3
85452: NEG
85453: PUSH
85454: LD_INT 1
85456: NEG
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85487: LD_ADDR_VAR 0 33
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: LD_INT 0
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 1
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: LD_INT 1
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: LD_INT 1
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: LD_INT 1
85545: NEG
85546: PUSH
85547: LD_INT 0
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 1
85556: NEG
85557: PUSH
85558: LD_INT 1
85560: NEG
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: LD_INT 2
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 2
85591: PUSH
85592: LD_INT 0
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 2
85601: PUSH
85602: LD_INT 1
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: LD_INT 2
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: NEG
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 2
85642: NEG
85643: PUSH
85644: LD_INT 0
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 2
85653: NEG
85654: PUSH
85655: LD_INT 1
85657: NEG
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: LD_INT 2
85665: NEG
85666: PUSH
85667: LD_INT 2
85669: NEG
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: LD_INT 3
85681: NEG
85682: PUSH
85683: EMPTY
85684: LIST
85685: LIST
85686: PUSH
85687: LD_INT 2
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 3
85700: PUSH
85701: LD_INT 1
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 1
85710: PUSH
85711: LD_INT 3
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: LD_INT 2
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 3
85731: NEG
85732: PUSH
85733: LD_INT 2
85735: NEG
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85766: LD_ADDR_VAR 0 34
85770: PUSH
85771: LD_INT 0
85773: PUSH
85774: LD_INT 0
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: LD_INT 1
85786: NEG
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 0
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: NEG
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: NEG
85836: PUSH
85837: LD_INT 1
85839: NEG
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 1
85847: NEG
85848: PUSH
85849: LD_INT 2
85851: NEG
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: LD_INT 2
85862: NEG
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: LD_INT 1
85873: NEG
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 2
85881: PUSH
85882: LD_INT 1
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 2
85891: PUSH
85892: LD_INT 2
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: PUSH
85902: LD_INT 2
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 2
85922: NEG
85923: PUSH
85924: LD_INT 0
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: LD_INT 1
85937: NEG
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 2
85945: NEG
85946: PUSH
85947: LD_INT 2
85949: NEG
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 1
85957: NEG
85958: PUSH
85959: LD_INT 3
85961: NEG
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 3
85980: PUSH
85981: LD_INT 2
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 2
85990: PUSH
85991: LD_INT 3
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 2
86000: NEG
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 3
86011: NEG
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86046: LD_ADDR_VAR 0 35
86050: PUSH
86051: LD_INT 0
86053: PUSH
86054: LD_INT 0
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 0
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 1
86074: PUSH
86075: LD_INT 0
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 1
86104: NEG
86105: PUSH
86106: LD_INT 0
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: LD_INT 1
86119: NEG
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: PUSH
86125: LD_INT 2
86127: PUSH
86128: LD_INT 1
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: NEG
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86158: LD_ADDR_VAR 0 36
86162: PUSH
86163: LD_INT 0
86165: PUSH
86166: LD_INT 0
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 1
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 1
86227: NEG
86228: PUSH
86229: LD_INT 1
86231: NEG
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PUSH
86237: LD_INT 1
86239: NEG
86240: PUSH
86241: LD_INT 2
86243: NEG
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: PUSH
86252: LD_INT 2
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86270: LD_ADDR_VAR 0 37
86274: PUSH
86275: LD_INT 0
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: PUSH
86309: LD_INT 1
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: LD_INT 1
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: NEG
86329: PUSH
86330: LD_INT 0
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 1
86339: NEG
86340: PUSH
86341: LD_INT 1
86343: NEG
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 1
86351: PUSH
86352: LD_INT 1
86354: NEG
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: LD_INT 1
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86382: LD_ADDR_VAR 0 38
86386: PUSH
86387: LD_INT 0
86389: PUSH
86390: LD_INT 0
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: LD_INT 1
86402: NEG
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 1
86410: PUSH
86411: LD_INT 0
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: LD_INT 1
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 1
86440: NEG
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 1
86451: NEG
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 2
86463: PUSH
86464: LD_INT 1
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 2
86473: NEG
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: EMPTY
86480: LIST
86481: LIST
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86494: LD_ADDR_VAR 0 39
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: LD_INT 1
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: LD_INT 2
86579: NEG
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 1
86587: PUSH
86588: LD_INT 2
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86606: LD_ADDR_VAR 0 40
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: NEG
86676: PUSH
86677: LD_INT 1
86679: NEG
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: LD_INT 1
86690: NEG
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 1
86698: NEG
86699: PUSH
86700: LD_INT 1
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86718: LD_ADDR_VAR 0 41
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 1
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: LD_INT 2
86803: NEG
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 1
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: LD_INT 0
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: LD_INT 2
86832: PUSH
86833: LD_INT 1
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: LD_INT 2
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: PUSH
86850: LD_INT 1
86852: PUSH
86853: LD_INT 2
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: LD_INT 1
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 2
86873: NEG
86874: PUSH
86875: LD_INT 0
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 2
86896: NEG
86897: PUSH
86898: LD_INT 2
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 2
86920: PUSH
86921: LD_INT 1
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 3
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 3
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 3
86951: PUSH
86952: LD_INT 2
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 3
86961: PUSH
86962: LD_INT 3
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 2
86971: PUSH
86972: LD_INT 3
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 2
86981: NEG
86982: PUSH
86983: LD_INT 1
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 3
86992: NEG
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 3
87003: NEG
87004: PUSH
87005: LD_INT 1
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 3
87027: NEG
87028: PUSH
87029: LD_INT 3
87031: NEG
87032: PUSH
87033: EMPTY
87034: LIST
87035: LIST
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87068: LD_ADDR_VAR 0 42
87072: PUSH
87073: LD_INT 0
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: LD_INT 0
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 1
87106: PUSH
87107: LD_INT 1
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 1
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 1
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: LD_INT 2
87153: NEG
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: LD_INT 1
87175: NEG
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: LD_INT 1
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: LD_INT 2
87193: PUSH
87194: LD_INT 2
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 2
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: LD_INT 2
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 1
87223: NEG
87224: PUSH
87225: LD_INT 1
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 2
87234: NEG
87235: PUSH
87236: LD_INT 1
87238: NEG
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 2
87246: NEG
87247: PUSH
87248: LD_INT 2
87250: NEG
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 2
87258: NEG
87259: PUSH
87260: LD_INT 3
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 1
87270: NEG
87271: PUSH
87272: LD_INT 3
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 0
87282: PUSH
87283: LD_INT 3
87285: NEG
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 1
87293: PUSH
87294: LD_INT 2
87296: NEG
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 3
87304: PUSH
87305: LD_INT 2
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 3
87314: PUSH
87315: LD_INT 3
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 2
87324: PUSH
87325: LD_INT 3
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: LD_INT 3
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: LD_INT 3
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: LD_INT 2
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 3
87365: NEG
87366: PUSH
87367: LD_INT 2
87369: NEG
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 3
87377: NEG
87378: PUSH
87379: LD_INT 3
87381: NEG
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87418: LD_ADDR_VAR 0 43
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: LD_INT 0
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 0
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: LD_INT 0
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: LD_INT 1
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 1
87476: NEG
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: NEG
87488: PUSH
87489: LD_INT 1
87491: NEG
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 1
87499: NEG
87500: PUSH
87501: LD_INT 2
87503: NEG
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: LD_INT 2
87514: NEG
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: PUSH
87520: LD_INT 1
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 2
87533: PUSH
87534: LD_INT 0
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: PUSH
87541: LD_INT 2
87543: PUSH
87544: LD_INT 1
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: LD_INT 2
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 0
87563: PUSH
87564: LD_INT 2
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 1
87573: NEG
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 2
87584: NEG
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 2
87595: NEG
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 1
87607: NEG
87608: PUSH
87609: LD_INT 3
87611: NEG
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: LD_INT 3
87622: NEG
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: LD_INT 2
87633: NEG
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 2
87641: PUSH
87642: LD_INT 1
87644: NEG
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 3
87652: PUSH
87653: LD_INT 0
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 3
87662: PUSH
87663: LD_INT 1
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: LD_INT 3
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: LD_INT 3
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 1
87692: NEG
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 2
87703: NEG
87704: PUSH
87705: LD_INT 1
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 3
87714: NEG
87715: PUSH
87716: LD_INT 0
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 3
87725: NEG
87726: PUSH
87727: LD_INT 1
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87766: LD_ADDR_VAR 0 44
87770: PUSH
87771: LD_INT 0
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 1
87786: NEG
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: PUSH
87792: LD_INT 1
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: NEG
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: LD_INT 2
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 2
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 2
87880: PUSH
87881: LD_INT 1
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 2
87890: PUSH
87891: LD_INT 2
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: LD_INT 2
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 1
87910: NEG
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 2
87921: NEG
87922: PUSH
87923: LD_INT 0
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: NEG
87945: PUSH
87946: LD_INT 2
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: LD_INT 3
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: PUSH
87969: LD_INT 1
87971: NEG
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 3
87979: PUSH
87980: LD_INT 0
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 3
87989: PUSH
87990: LD_INT 1
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 3
87999: PUSH
88000: LD_INT 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 3
88009: PUSH
88010: LD_INT 3
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 2
88019: PUSH
88020: LD_INT 3
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 2
88029: NEG
88030: PUSH
88031: LD_INT 1
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 3
88040: NEG
88041: PUSH
88042: LD_INT 0
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 3
88051: NEG
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 3
88063: NEG
88064: PUSH
88065: LD_INT 2
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 3
88075: NEG
88076: PUSH
88077: LD_INT 3
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88116: LD_ADDR_VAR 0 45
88120: PUSH
88121: LD_INT 0
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: LD_INT 1
88136: NEG
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: PUSH
88155: LD_INT 1
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: LD_INT 1
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 1
88174: NEG
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: LD_INT 2
88201: NEG
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 1
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 2
88231: PUSH
88232: LD_INT 1
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 2
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: LD_INT 2
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: NEG
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 2
88282: NEG
88283: PUSH
88284: LD_INT 1
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 2
88294: NEG
88295: PUSH
88296: LD_INT 2
88298: NEG
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 2
88306: NEG
88307: PUSH
88308: LD_INT 3
88310: NEG
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: LD_INT 3
88322: NEG
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 0
88330: PUSH
88331: LD_INT 3
88333: NEG
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 1
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 3
88352: PUSH
88353: LD_INT 2
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 3
88362: PUSH
88363: LD_INT 3
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: LD_INT 3
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: PUSH
88380: LD_INT 1
88382: PUSH
88383: LD_INT 3
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: LD_INT 3
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: NEG
88403: PUSH
88404: LD_INT 2
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 3
88413: NEG
88414: PUSH
88415: LD_INT 2
88417: NEG
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 3
88425: NEG
88426: PUSH
88427: LD_INT 3
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88466: LD_ADDR_VAR 0 46
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: LD_INT 0
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 1
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 1
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: LD_INT 0
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: LD_INT 2
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: LD_INT 2
88562: NEG
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 1
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 2
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 2
88591: PUSH
88592: LD_INT 1
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 1
88601: PUSH
88602: LD_INT 2
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 0
88611: PUSH
88612: LD_INT 2
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 1
88621: NEG
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 2
88632: NEG
88633: PUSH
88634: LD_INT 0
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 2
88643: NEG
88644: PUSH
88645: LD_INT 1
88647: NEG
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: LD_INT 3
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: LD_INT 3
88670: NEG
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: LD_INT 2
88681: NEG
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: PUSH
88690: LD_INT 1
88692: NEG
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 3
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 3
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: PUSH
88721: LD_INT 3
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 0
88730: PUSH
88731: LD_INT 3
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 2
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 2
88751: NEG
88752: PUSH
88753: LD_INT 1
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 3
88762: NEG
88763: PUSH
88764: LD_INT 0
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 3
88773: NEG
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88814: LD_ADDR_VAR 0 47
88818: PUSH
88819: LD_INT 0
88821: PUSH
88822: LD_INT 0
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 0
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 1
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 1
88852: PUSH
88853: LD_INT 1
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 1
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: NEG
88884: PUSH
88885: LD_INT 1
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: LD_INT 2
88899: NEG
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: LD_INT 2
88910: NEG
88911: PUSH
88912: EMPTY
88913: LIST
88914: LIST
88915: PUSH
88916: LD_INT 1
88918: PUSH
88919: LD_INT 1
88921: NEG
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: PUSH
88927: LD_INT 2
88929: NEG
88930: PUSH
88931: LD_INT 1
88933: NEG
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 2
88941: NEG
88942: PUSH
88943: LD_INT 2
88945: NEG
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88965: LD_ADDR_VAR 0 48
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: LD_INT 0
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 1
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 1
89023: NEG
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 1
89034: NEG
89035: PUSH
89036: LD_INT 1
89038: NEG
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: LD_INT 2
89050: NEG
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: LD_INT 2
89061: NEG
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 1
89069: PUSH
89070: LD_INT 1
89072: NEG
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: LD_INT 0
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: PUSH
89091: LD_INT 1
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89112: LD_ADDR_VAR 0 49
89116: PUSH
89117: LD_INT 0
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 0
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 1
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 1
89150: PUSH
89151: LD_INT 1
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 1
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: LD_INT 1
89185: NEG
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: PUSH
89191: LD_INT 1
89193: PUSH
89194: LD_INT 1
89196: NEG
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 2
89204: PUSH
89205: LD_INT 0
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 2
89214: PUSH
89215: LD_INT 1
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 2
89224: PUSH
89225: LD_INT 2
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 2
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89256: LD_ADDR_VAR 0 50
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: LD_INT 0
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 0
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 2
89337: PUSH
89338: LD_INT 1
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 2
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 1
89357: PUSH
89358: LD_INT 2
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 0
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89400: LD_ADDR_VAR 0 51
89404: PUSH
89405: LD_INT 0
89407: PUSH
89408: LD_INT 0
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 1
89420: NEG
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: PUSH
89429: LD_INT 0
89431: PUSH
89432: EMPTY
89433: LIST
89434: LIST
89435: PUSH
89436: LD_INT 1
89438: PUSH
89439: LD_INT 1
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: LD_INT 1
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 1
89469: NEG
89470: PUSH
89471: LD_INT 1
89473: NEG
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: LD_INT 2
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: PUSH
89503: LD_INT 1
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89547: LD_ADDR_VAR 0 52
89551: PUSH
89552: LD_INT 0
89554: PUSH
89555: LD_INT 0
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 1
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: LD_INT 1
89620: NEG
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: LD_INT 2
89632: NEG
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 2
89651: NEG
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 2
89662: NEG
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 2
89674: NEG
89675: PUSH
89676: LD_INT 2
89678: NEG
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89698: LD_ADDR_VAR 0 53
89702: PUSH
89703: LD_INT 0
89705: PUSH
89706: LD_INT 0
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 0
89715: PUSH
89716: LD_INT 1
89718: NEG
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 1
89726: PUSH
89727: LD_INT 0
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 1
89736: PUSH
89737: LD_INT 1
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: LD_INT 1
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 1
89756: NEG
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: LD_INT 2
89783: NEG
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: LD_INT 2
89794: NEG
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 1
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: PUSH
89834: LD_INT 2
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 0
89853: PUSH
89854: LD_INT 2
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 1
89863: NEG
89864: PUSH
89865: LD_INT 1
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: LD_INT 0
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 2
89885: NEG
89886: PUSH
89887: LD_INT 1
89889: NEG
89890: PUSH
89891: EMPTY
89892: LIST
89893: LIST
89894: PUSH
89895: LD_INT 2
89897: NEG
89898: PUSH
89899: LD_INT 2
89901: NEG
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89928: LD_ADDR_VAR 0 54
89932: PUSH
89933: LD_INT 0
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: LD_INT 1
89948: NEG
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 1
89956: PUSH
89957: LD_INT 0
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: LD_INT 1
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 1
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: NEG
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 1
90009: NEG
90010: PUSH
90011: LD_INT 2
90013: NEG
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: LD_INT 2
90024: NEG
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 1
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 2
90043: PUSH
90044: LD_INT 0
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 2
90053: PUSH
90054: LD_INT 1
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 2
90063: PUSH
90064: LD_INT 2
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_INT 1
90073: PUSH
90074: LD_INT 2
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 0
90083: PUSH
90084: LD_INT 2
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 1
90093: NEG
90094: PUSH
90095: LD_INT 1
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 2
90104: NEG
90105: PUSH
90106: LD_INT 0
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 2
90115: NEG
90116: PUSH
90117: LD_INT 1
90119: NEG
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 2
90127: NEG
90128: PUSH
90129: LD_INT 2
90131: NEG
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90158: LD_ADDR_VAR 0 55
90162: PUSH
90163: LD_INT 0
90165: PUSH
90166: LD_INT 0
90168: PUSH
90169: EMPTY
90170: LIST
90171: LIST
90172: PUSH
90173: LD_INT 0
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: LD_INT 0
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: LD_INT 1
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 1
90216: NEG
90217: PUSH
90218: LD_INT 0
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: NEG
90228: PUSH
90229: LD_INT 1
90231: NEG
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: LD_INT 2
90243: NEG
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: LD_INT 2
90254: NEG
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: PUSH
90263: LD_INT 1
90265: NEG
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 2
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 2
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 2
90293: PUSH
90294: LD_INT 2
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: LD_INT 1
90303: PUSH
90304: LD_INT 2
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: LD_INT 2
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 1
90323: NEG
90324: PUSH
90325: LD_INT 1
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 2
90334: NEG
90335: PUSH
90336: LD_INT 0
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 2
90345: NEG
90346: PUSH
90347: LD_INT 1
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 2
90357: NEG
90358: PUSH
90359: LD_INT 2
90361: NEG
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90388: LD_ADDR_VAR 0 56
90392: PUSH
90393: LD_INT 0
90395: PUSH
90396: LD_INT 0
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: LD_INT 1
90408: NEG
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PUSH
90414: LD_INT 1
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 1
90426: PUSH
90427: LD_INT 1
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: LD_INT 1
90439: PUSH
90440: EMPTY
90441: LIST
90442: LIST
90443: PUSH
90444: LD_INT 1
90446: NEG
90447: PUSH
90448: LD_INT 0
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: LD_INT 2
90473: NEG
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: LD_INT 0
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 2
90513: PUSH
90514: LD_INT 1
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 2
90523: PUSH
90524: LD_INT 2
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 1
90533: PUSH
90534: LD_INT 2
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: LD_INT 0
90543: PUSH
90544: LD_INT 2
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 1
90553: NEG
90554: PUSH
90555: LD_INT 1
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 2
90564: NEG
90565: PUSH
90566: LD_INT 0
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 2
90575: NEG
90576: PUSH
90577: LD_INT 1
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 2
90587: NEG
90588: PUSH
90589: LD_INT 2
90591: NEG
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90618: LD_ADDR_VAR 0 57
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: LD_INT 1
90638: NEG
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 1
90646: PUSH
90647: LD_INT 0
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 1
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 2
90703: NEG
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: LD_INT 2
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 2
90733: PUSH
90734: LD_INT 0
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 2
90743: PUSH
90744: LD_INT 1
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 2
90753: PUSH
90754: LD_INT 2
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 1
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: EMPTY
90768: LIST
90769: LIST
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: NEG
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 2
90794: NEG
90795: PUSH
90796: LD_INT 0
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 1
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 2
90817: NEG
90818: PUSH
90819: LD_INT 2
90821: NEG
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90848: LD_ADDR_VAR 0 58
90852: PUSH
90853: LD_INT 0
90855: PUSH
90856: LD_INT 0
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 0
90865: PUSH
90866: LD_INT 1
90868: NEG
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: LD_INT 1
90876: PUSH
90877: LD_INT 0
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: PUSH
90884: LD_INT 1
90886: PUSH
90887: LD_INT 1
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: PUSH
90894: LD_INT 0
90896: PUSH
90897: LD_INT 1
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 1
90906: NEG
90907: PUSH
90908: LD_INT 0
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 1
90917: NEG
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 1
90929: NEG
90930: PUSH
90931: LD_INT 2
90933: NEG
90934: PUSH
90935: EMPTY
90936: LIST
90937: LIST
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: LD_INT 2
90944: NEG
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 1
90952: PUSH
90953: LD_INT 1
90955: NEG
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 2
90963: PUSH
90964: LD_INT 0
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 2
90973: PUSH
90974: LD_INT 1
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 2
90983: PUSH
90984: LD_INT 2
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 1
90993: PUSH
90994: LD_INT 2
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: PUSH
91001: LD_INT 0
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 1
91013: NEG
91014: PUSH
91015: LD_INT 1
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 2
91024: NEG
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 2
91035: NEG
91036: PUSH
91037: LD_INT 1
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 2
91047: NEG
91048: PUSH
91049: LD_INT 2
91051: NEG
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91078: LD_ADDR_VAR 0 59
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 0
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 0
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: LD_INT 0
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: LD_INT 1
91116: PUSH
91117: LD_INT 1
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: LD_INT 1
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 1
91136: NEG
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 1
91147: NEG
91148: PUSH
91149: LD_INT 1
91151: NEG
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91166: LD_ADDR_VAR 0 60
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: LD_INT 0
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 0
91183: PUSH
91184: LD_INT 1
91186: NEG
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: LD_INT 0
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 1
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: LD_INT 1
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: PUSH
91222: LD_INT 1
91224: NEG
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: NEG
91236: PUSH
91237: LD_INT 1
91239: NEG
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91254: LD_ADDR_VAR 0 61
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 0
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 1
91282: PUSH
91283: LD_INT 0
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: PUSH
91290: LD_INT 1
91292: PUSH
91293: LD_INT 1
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: LD_INT 1
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 1
91312: NEG
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: LD_INT 1
91327: NEG
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91342: LD_ADDR_VAR 0 62
91346: PUSH
91347: LD_INT 0
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 0
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 0
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 1
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 0
91390: PUSH
91391: LD_INT 1
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 1
91400: NEG
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 1
91411: NEG
91412: PUSH
91413: LD_INT 1
91415: NEG
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91430: LD_ADDR_VAR 0 63
91434: PUSH
91435: LD_INT 0
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 1
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 1
91468: PUSH
91469: LD_INT 1
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: LD_INT 1
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: NEG
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: LD_INT 1
91503: NEG
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91518: LD_ADDR_VAR 0 64
91522: PUSH
91523: LD_INT 0
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 0
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PUSH
91544: LD_INT 1
91546: PUSH
91547: LD_INT 0
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 1
91556: PUSH
91557: LD_INT 1
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: LD_INT 1
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 1
91576: NEG
91577: PUSH
91578: LD_INT 0
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 1
91587: NEG
91588: PUSH
91589: LD_INT 1
91591: NEG
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: ST_TO_ADDR
// end ; 1 :
91606: GO 97503
91608: LD_INT 1
91610: DOUBLE
91611: EQUAL
91612: IFTRUE 91616
91614: GO 94239
91616: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91617: LD_ADDR_VAR 0 11
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 0
91636: PUSH
91637: LD_INT 3
91639: NEG
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: LD_INT 2
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: LIST
91660: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91661: LD_ADDR_VAR 0 12
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 1
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 3
91679: PUSH
91680: LD_INT 0
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 3
91689: PUSH
91690: LD_INT 1
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: LIST
91701: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91702: LD_ADDR_VAR 0 13
91706: PUSH
91707: LD_INT 3
91709: PUSH
91710: LD_INT 2
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 3
91719: PUSH
91720: LD_INT 3
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 2
91729: PUSH
91730: LD_INT 3
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: LIST
91741: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91742: LD_ADDR_VAR 0 14
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: LD_INT 3
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 0
91759: PUSH
91760: LD_INT 3
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: LD_INT 2
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: LIST
91782: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91783: LD_ADDR_VAR 0 15
91787: PUSH
91788: LD_INT 2
91790: NEG
91791: PUSH
91792: LD_INT 1
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 3
91801: NEG
91802: PUSH
91803: LD_INT 0
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PUSH
91810: LD_INT 3
91812: NEG
91813: PUSH
91814: LD_INT 1
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: LIST
91826: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91827: LD_ADDR_VAR 0 16
91831: PUSH
91832: LD_INT 2
91834: NEG
91835: PUSH
91836: LD_INT 3
91838: NEG
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: LD_INT 2
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 3
91858: NEG
91859: PUSH
91860: LD_INT 3
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: LIST
91872: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91873: LD_ADDR_VAR 0 17
91877: PUSH
91878: LD_INT 1
91880: NEG
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 0
91892: PUSH
91893: LD_INT 3
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 1
91903: PUSH
91904: LD_INT 2
91906: NEG
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: LIST
91916: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91917: LD_ADDR_VAR 0 18
91921: PUSH
91922: LD_INT 2
91924: PUSH
91925: LD_INT 1
91927: NEG
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 3
91935: PUSH
91936: LD_INT 0
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 3
91945: PUSH
91946: LD_INT 1
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: LIST
91957: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91958: LD_ADDR_VAR 0 19
91962: PUSH
91963: LD_INT 3
91965: PUSH
91966: LD_INT 2
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: PUSH
91976: LD_INT 3
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 2
91985: PUSH
91986: LD_INT 3
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91998: LD_ADDR_VAR 0 20
92002: PUSH
92003: LD_INT 1
92005: PUSH
92006: LD_INT 3
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 3
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: NEG
92026: PUSH
92027: LD_INT 2
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: LIST
92038: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92039: LD_ADDR_VAR 0 21
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 3
92057: NEG
92058: PUSH
92059: LD_INT 0
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 3
92068: NEG
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: LIST
92082: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92083: LD_ADDR_VAR 0 22
92087: PUSH
92088: LD_INT 2
92090: NEG
92091: PUSH
92092: LD_INT 3
92094: NEG
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: LD_INT 2
92106: NEG
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: PUSH
92112: LD_INT 3
92114: NEG
92115: PUSH
92116: LD_INT 3
92118: NEG
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: LIST
92128: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92129: LD_ADDR_VAR 0 23
92133: PUSH
92134: LD_INT 0
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 1
92147: NEG
92148: PUSH
92149: LD_INT 4
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: LD_INT 3
92162: NEG
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: LIST
92172: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92173: LD_ADDR_VAR 0 24
92177: PUSH
92178: LD_INT 3
92180: PUSH
92181: LD_INT 0
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 3
92190: PUSH
92191: LD_INT 1
92193: NEG
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 4
92201: PUSH
92202: LD_INT 1
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: LIST
92213: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92214: LD_ADDR_VAR 0 25
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: LD_INT 3
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 4
92231: PUSH
92232: LD_INT 3
92234: PUSH
92235: EMPTY
92236: LIST
92237: LIST
92238: PUSH
92239: LD_INT 3
92241: PUSH
92242: LD_INT 4
92244: PUSH
92245: EMPTY
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: LIST
92253: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92254: LD_ADDR_VAR 0 26
92258: PUSH
92259: LD_INT 0
92261: PUSH
92262: LD_INT 3
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: PUSH
92269: LD_INT 1
92271: PUSH
92272: LD_INT 4
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: PUSH
92279: LD_INT 1
92281: NEG
92282: PUSH
92283: LD_INT 3
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: LIST
92294: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92295: LD_ADDR_VAR 0 27
92299: PUSH
92300: LD_INT 3
92302: NEG
92303: PUSH
92304: LD_INT 0
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 3
92313: NEG
92314: PUSH
92315: LD_INT 1
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 4
92324: NEG
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: LIST
92338: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92339: LD_ADDR_VAR 0 28
92343: PUSH
92344: LD_INT 3
92346: NEG
92347: PUSH
92348: LD_INT 3
92350: NEG
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: LD_INT 4
92362: NEG
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 4
92370: NEG
92371: PUSH
92372: LD_INT 3
92374: NEG
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: LIST
92384: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92385: LD_ADDR_VAR 0 29
92389: PUSH
92390: LD_INT 1
92392: NEG
92393: PUSH
92394: LD_INT 3
92396: NEG
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 0
92404: PUSH
92405: LD_INT 3
92407: NEG
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: LD_INT 1
92415: PUSH
92416: LD_INT 2
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 1
92426: NEG
92427: PUSH
92428: LD_INT 4
92430: NEG
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 0
92438: PUSH
92439: LD_INT 4
92441: NEG
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 1
92449: PUSH
92450: LD_INT 3
92452: NEG
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: NEG
92461: PUSH
92462: LD_INT 5
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 0
92472: PUSH
92473: LD_INT 5
92475: NEG
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: LD_INT 4
92486: NEG
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 1
92494: NEG
92495: PUSH
92496: LD_INT 6
92498: NEG
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 0
92506: PUSH
92507: LD_INT 6
92509: NEG
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PUSH
92515: LD_INT 1
92517: PUSH
92518: LD_INT 5
92520: NEG
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92540: LD_ADDR_VAR 0 30
92544: PUSH
92545: LD_INT 2
92547: PUSH
92548: LD_INT 1
92550: NEG
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 3
92558: PUSH
92559: LD_INT 0
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: PUSH
92566: LD_INT 3
92568: PUSH
92569: LD_INT 1
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 3
92578: PUSH
92579: LD_INT 1
92581: NEG
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 4
92589: PUSH
92590: LD_INT 0
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 4
92599: PUSH
92600: LD_INT 1
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 4
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 5
92620: PUSH
92621: LD_INT 0
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: LD_INT 5
92630: PUSH
92631: LD_INT 1
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 5
92640: PUSH
92641: LD_INT 1
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 6
92651: PUSH
92652: LD_INT 0
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 6
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92683: LD_ADDR_VAR 0 31
92687: PUSH
92688: LD_INT 3
92690: PUSH
92691: LD_INT 2
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 3
92700: PUSH
92701: LD_INT 3
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 2
92710: PUSH
92711: LD_INT 3
92713: PUSH
92714: EMPTY
92715: LIST
92716: LIST
92717: PUSH
92718: LD_INT 4
92720: PUSH
92721: LD_INT 3
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 4
92730: PUSH
92731: LD_INT 4
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: LD_INT 3
92740: PUSH
92741: LD_INT 4
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 5
92750: PUSH
92751: LD_INT 4
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: PUSH
92758: LD_INT 5
92760: PUSH
92761: LD_INT 5
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 4
92770: PUSH
92771: LD_INT 5
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 6
92780: PUSH
92781: LD_INT 5
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: LD_INT 6
92790: PUSH
92791: LD_INT 6
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PUSH
92798: LD_INT 5
92800: PUSH
92801: LD_INT 6
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92822: LD_ADDR_VAR 0 32
92826: PUSH
92827: LD_INT 1
92829: PUSH
92830: LD_INT 3
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: LD_INT 3
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 1
92849: NEG
92850: PUSH
92851: LD_INT 2
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: LD_INT 4
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 0
92870: PUSH
92871: LD_INT 4
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 1
92891: PUSH
92892: LD_INT 5
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 0
92901: PUSH
92902: LD_INT 5
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 1
92911: NEG
92912: PUSH
92913: LD_INT 4
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 1
92922: PUSH
92923: LD_INT 6
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 0
92932: PUSH
92933: LD_INT 6
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 1
92942: NEG
92943: PUSH
92944: LD_INT 5
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92965: LD_ADDR_VAR 0 33
92969: PUSH
92970: LD_INT 2
92972: NEG
92973: PUSH
92974: LD_INT 1
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: PUSH
92981: LD_INT 3
92983: NEG
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 3
92994: NEG
92995: PUSH
92996: LD_INT 1
92998: NEG
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 3
93006: NEG
93007: PUSH
93008: LD_INT 1
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 4
93017: NEG
93018: PUSH
93019: LD_INT 0
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 4
93028: NEG
93029: PUSH
93030: LD_INT 1
93032: NEG
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PUSH
93038: LD_INT 4
93040: NEG
93041: PUSH
93042: LD_INT 1
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 5
93051: NEG
93052: PUSH
93053: LD_INT 0
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: LD_INT 5
93062: NEG
93063: PUSH
93064: LD_INT 1
93066: NEG
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 5
93074: NEG
93075: PUSH
93076: LD_INT 1
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 6
93085: NEG
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 6
93096: NEG
93097: PUSH
93098: LD_INT 1
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: LIST
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93120: LD_ADDR_VAR 0 34
93124: PUSH
93125: LD_INT 2
93127: NEG
93128: PUSH
93129: LD_INT 3
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 3
93139: NEG
93140: PUSH
93141: LD_INT 2
93143: NEG
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 3
93151: NEG
93152: PUSH
93153: LD_INT 3
93155: NEG
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 3
93163: NEG
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 4
93175: NEG
93176: PUSH
93177: LD_INT 3
93179: NEG
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 4
93187: NEG
93188: PUSH
93189: LD_INT 4
93191: NEG
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PUSH
93197: LD_INT 4
93199: NEG
93200: PUSH
93201: LD_INT 5
93203: NEG
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 5
93211: NEG
93212: PUSH
93213: LD_INT 4
93215: NEG
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: LD_INT 5
93223: NEG
93224: PUSH
93225: LD_INT 5
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 5
93235: NEG
93236: PUSH
93237: LD_INT 6
93239: NEG
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 6
93247: NEG
93248: PUSH
93249: LD_INT 5
93251: NEG
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: LD_INT 6
93259: NEG
93260: PUSH
93261: LD_INT 6
93263: NEG
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93283: LD_ADDR_VAR 0 41
93287: PUSH
93288: LD_INT 0
93290: PUSH
93291: LD_INT 2
93293: NEG
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PUSH
93299: LD_INT 1
93301: NEG
93302: PUSH
93303: LD_INT 3
93305: NEG
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 1
93313: PUSH
93314: LD_INT 2
93316: NEG
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: LIST
93326: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93327: LD_ADDR_VAR 0 42
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: LD_INT 0
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 2
93344: PUSH
93345: LD_INT 1
93347: NEG
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: LD_INT 1
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: LIST
93367: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93368: LD_ADDR_VAR 0 43
93372: PUSH
93373: LD_INT 2
93375: PUSH
93376: LD_INT 2
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: LD_INT 2
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 2
93395: PUSH
93396: LD_INT 3
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: LIST
93407: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93408: LD_ADDR_VAR 0 44
93412: PUSH
93413: LD_INT 0
93415: PUSH
93416: LD_INT 2
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 1
93425: PUSH
93426: LD_INT 3
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 1
93435: NEG
93436: PUSH
93437: LD_INT 2
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: EMPTY
93445: LIST
93446: LIST
93447: LIST
93448: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93449: LD_ADDR_VAR 0 45
93453: PUSH
93454: LD_INT 2
93456: NEG
93457: PUSH
93458: LD_INT 0
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 2
93467: NEG
93468: PUSH
93469: LD_INT 1
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: LD_INT 1
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: LIST
93492: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93493: LD_ADDR_VAR 0 46
93497: PUSH
93498: LD_INT 2
93500: NEG
93501: PUSH
93502: LD_INT 2
93504: NEG
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 2
93512: NEG
93513: PUSH
93514: LD_INT 3
93516: NEG
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: LD_INT 2
93528: NEG
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: LIST
93538: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93539: LD_ADDR_VAR 0 47
93543: PUSH
93544: LD_INT 2
93546: NEG
93547: PUSH
93548: LD_INT 3
93550: NEG
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 1
93558: NEG
93559: PUSH
93560: LD_INT 3
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93572: LD_ADDR_VAR 0 48
93576: PUSH
93577: LD_INT 1
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 2
93590: PUSH
93591: LD_INT 1
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93603: LD_ADDR_VAR 0 49
93607: PUSH
93608: LD_INT 3
93610: PUSH
93611: LD_INT 1
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: LD_INT 3
93620: PUSH
93621: LD_INT 2
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93632: LD_ADDR_VAR 0 50
93636: PUSH
93637: LD_INT 2
93639: PUSH
93640: LD_INT 3
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 1
93649: PUSH
93650: LD_INT 3
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93661: LD_ADDR_VAR 0 51
93665: PUSH
93666: LD_INT 1
93668: NEG
93669: PUSH
93670: LD_INT 2
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 2
93679: NEG
93680: PUSH
93681: LD_INT 1
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93692: LD_ADDR_VAR 0 52
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 1
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 3
93711: NEG
93712: PUSH
93713: LD_INT 2
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93725: LD_ADDR_VAR 0 53
93729: PUSH
93730: LD_INT 1
93732: NEG
93733: PUSH
93734: LD_INT 3
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 0
93744: PUSH
93745: LD_INT 3
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 1
93755: PUSH
93756: LD_INT 2
93758: NEG
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: LIST
93768: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93769: LD_ADDR_VAR 0 54
93773: PUSH
93774: LD_INT 2
93776: PUSH
93777: LD_INT 1
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 3
93787: PUSH
93788: LD_INT 0
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 3
93797: PUSH
93798: LD_INT 1
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: LIST
93809: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93810: LD_ADDR_VAR 0 55
93814: PUSH
93815: LD_INT 3
93817: PUSH
93818: LD_INT 2
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 3
93827: PUSH
93828: LD_INT 3
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 2
93837: PUSH
93838: LD_INT 3
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: LIST
93849: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93850: LD_ADDR_VAR 0 56
93854: PUSH
93855: LD_INT 1
93857: PUSH
93858: LD_INT 3
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: LD_INT 3
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 1
93877: NEG
93878: PUSH
93879: LD_INT 2
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: LIST
93890: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93891: LD_ADDR_VAR 0 57
93895: PUSH
93896: LD_INT 2
93898: NEG
93899: PUSH
93900: LD_INT 1
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 3
93909: NEG
93910: PUSH
93911: LD_INT 0
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 3
93920: NEG
93921: PUSH
93922: LD_INT 1
93924: NEG
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: EMPTY
93931: LIST
93932: LIST
93933: LIST
93934: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93935: LD_ADDR_VAR 0 58
93939: PUSH
93940: LD_INT 2
93942: NEG
93943: PUSH
93944: LD_INT 3
93946: NEG
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: LD_INT 3
93966: NEG
93967: PUSH
93968: LD_INT 3
93970: NEG
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: LIST
93980: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93981: LD_ADDR_VAR 0 59
93985: PUSH
93986: LD_INT 1
93988: NEG
93989: PUSH
93990: LD_INT 2
93992: NEG
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: LD_INT 0
94000: PUSH
94001: LD_INT 2
94003: NEG
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 1
94011: PUSH
94012: LD_INT 1
94014: NEG
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: LIST
94024: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94025: LD_ADDR_VAR 0 60
94029: PUSH
94030: LD_INT 1
94032: PUSH
94033: LD_INT 1
94035: NEG
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 2
94043: PUSH
94044: LD_INT 0
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 2
94053: PUSH
94054: LD_INT 1
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: LIST
94065: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94066: LD_ADDR_VAR 0 61
94070: PUSH
94071: LD_INT 2
94073: PUSH
94074: LD_INT 1
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 2
94083: PUSH
94084: LD_INT 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 1
94093: PUSH
94094: LD_INT 2
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: LIST
94105: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94106: LD_ADDR_VAR 0 62
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: LD_INT 2
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 0
94123: PUSH
94124: LD_INT 2
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 1
94133: NEG
94134: PUSH
94135: LD_INT 1
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: LIST
94146: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94147: LD_ADDR_VAR 0 63
94151: PUSH
94152: LD_INT 1
94154: NEG
94155: PUSH
94156: LD_INT 1
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 2
94165: NEG
94166: PUSH
94167: LD_INT 0
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 2
94176: NEG
94177: PUSH
94178: LD_INT 1
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: LIST
94190: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94191: LD_ADDR_VAR 0 64
94195: PUSH
94196: LD_INT 1
94198: NEG
94199: PUSH
94200: LD_INT 2
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 2
94210: NEG
94211: PUSH
94212: LD_INT 1
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: LD_INT 2
94226: NEG
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: LIST
94236: ST_TO_ADDR
// end ; 2 :
94237: GO 97503
94239: LD_INT 2
94241: DOUBLE
94242: EQUAL
94243: IFTRUE 94247
94245: GO 97502
94247: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94248: LD_ADDR_VAR 0 29
94252: PUSH
94253: LD_INT 4
94255: PUSH
94256: LD_INT 0
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 4
94265: PUSH
94266: LD_INT 1
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 5
94276: PUSH
94277: LD_INT 0
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 5
94286: PUSH
94287: LD_INT 1
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 4
94296: PUSH
94297: LD_INT 1
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: LD_INT 3
94306: PUSH
94307: LD_INT 0
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 3
94316: PUSH
94317: LD_INT 1
94319: NEG
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 3
94327: PUSH
94328: LD_INT 2
94330: NEG
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: PUSH
94336: LD_INT 5
94338: PUSH
94339: LD_INT 2
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 3
94348: PUSH
94349: LD_INT 3
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 3
94358: PUSH
94359: LD_INT 2
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 4
94368: PUSH
94369: LD_INT 3
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 4
94378: PUSH
94379: LD_INT 4
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 3
94388: PUSH
94389: LD_INT 4
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 2
94398: PUSH
94399: LD_INT 3
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 2
94408: PUSH
94409: LD_INT 2
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 4
94418: PUSH
94419: LD_INT 2
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 2
94428: PUSH
94429: LD_INT 4
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: LD_INT 4
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: LD_INT 3
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 1
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: LD_INT 5
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 0
94478: PUSH
94479: LD_INT 5
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: NEG
94489: PUSH
94490: LD_INT 4
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 1
94499: NEG
94500: PUSH
94501: LD_INT 3
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 2
94510: PUSH
94511: LD_INT 5
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: PUSH
94518: LD_INT 2
94520: NEG
94521: PUSH
94522: LD_INT 3
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 3
94531: NEG
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 3
94542: NEG
94543: PUSH
94544: LD_INT 1
94546: NEG
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 2
94554: NEG
94555: PUSH
94556: LD_INT 0
94558: PUSH
94559: EMPTY
94560: LIST
94561: LIST
94562: PUSH
94563: LD_INT 2
94565: NEG
94566: PUSH
94567: LD_INT 1
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 3
94576: NEG
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 4
94587: NEG
94588: PUSH
94589: LD_INT 0
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 4
94598: NEG
94599: PUSH
94600: LD_INT 1
94602: NEG
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 4
94610: NEG
94611: PUSH
94612: LD_INT 2
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: LD_INT 2
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 4
94633: NEG
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 4
94645: NEG
94646: PUSH
94647: LD_INT 5
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 3
94657: NEG
94658: PUSH
94659: LD_INT 4
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 3
94669: NEG
94670: PUSH
94671: LD_INT 3
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 4
94681: NEG
94682: PUSH
94683: LD_INT 3
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: LD_INT 4
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 5
94705: NEG
94706: PUSH
94707: LD_INT 5
94709: NEG
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PUSH
94715: LD_INT 3
94717: NEG
94718: PUSH
94719: LD_INT 5
94721: NEG
94722: PUSH
94723: EMPTY
94724: LIST
94725: LIST
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: LD_INT 3
94733: NEG
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94786: LD_ADDR_VAR 0 30
94790: PUSH
94791: LD_INT 4
94793: PUSH
94794: LD_INT 4
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 4
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 5
94813: PUSH
94814: LD_INT 4
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 5
94823: PUSH
94824: LD_INT 5
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 4
94833: PUSH
94834: LD_INT 5
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: PUSH
94841: LD_INT 3
94843: PUSH
94844: LD_INT 4
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 3
94853: PUSH
94854: LD_INT 3
94856: PUSH
94857: EMPTY
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 5
94863: PUSH
94864: LD_INT 3
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 3
94873: PUSH
94874: LD_INT 5
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 0
94883: PUSH
94884: LD_INT 3
94886: PUSH
94887: EMPTY
94888: LIST
94889: LIST
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: LD_INT 2
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 1
94903: PUSH
94904: LD_INT 3
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 1
94913: PUSH
94914: LD_INT 4
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: LD_INT 0
94923: PUSH
94924: LD_INT 4
94926: PUSH
94927: EMPTY
94928: LIST
94929: LIST
94930: PUSH
94931: LD_INT 1
94933: NEG
94934: PUSH
94935: LD_INT 3
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 1
94944: NEG
94945: PUSH
94946: LD_INT 2
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 2
94955: PUSH
94956: LD_INT 4
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 2
94965: NEG
94966: PUSH
94967: LD_INT 2
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 4
94976: NEG
94977: PUSH
94978: LD_INT 0
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 4
94987: NEG
94988: PUSH
94989: LD_INT 1
94991: NEG
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 3
94999: NEG
95000: PUSH
95001: LD_INT 0
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 3
95010: NEG
95011: PUSH
95012: LD_INT 1
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: LD_INT 4
95021: NEG
95022: PUSH
95023: LD_INT 1
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: LD_INT 5
95032: NEG
95033: PUSH
95034: LD_INT 0
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 5
95043: NEG
95044: PUSH
95045: LD_INT 1
95047: NEG
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: LD_INT 2
95059: NEG
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 3
95067: NEG
95068: PUSH
95069: LD_INT 2
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 3
95078: NEG
95079: PUSH
95080: LD_INT 3
95082: NEG
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 3
95090: NEG
95091: PUSH
95092: LD_INT 4
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 2
95102: NEG
95103: PUSH
95104: LD_INT 3
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: LD_INT 2
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 3
95126: NEG
95127: PUSH
95128: LD_INT 2
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: LD_INT 3
95142: NEG
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 4
95150: NEG
95151: PUSH
95152: LD_INT 4
95154: NEG
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 2
95162: NEG
95163: PUSH
95164: LD_INT 4
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 4
95174: NEG
95175: PUSH
95176: LD_INT 2
95178: NEG
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 0
95186: PUSH
95187: LD_INT 4
95189: NEG
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 0
95197: PUSH
95198: LD_INT 5
95200: NEG
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: LD_INT 1
95208: PUSH
95209: LD_INT 4
95211: NEG
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 1
95219: PUSH
95220: LD_INT 3
95222: NEG
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 0
95230: PUSH
95231: LD_INT 3
95233: NEG
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 1
95241: NEG
95242: PUSH
95243: LD_INT 4
95245: NEG
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 1
95253: NEG
95254: PUSH
95255: LD_INT 5
95257: NEG
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 2
95265: PUSH
95266: LD_INT 3
95268: NEG
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 2
95276: NEG
95277: PUSH
95278: LD_INT 5
95280: NEG
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95333: LD_ADDR_VAR 0 31
95337: PUSH
95338: LD_INT 0
95340: PUSH
95341: LD_INT 4
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 0
95350: PUSH
95351: LD_INT 3
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 1
95360: PUSH
95361: LD_INT 4
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 1
95370: PUSH
95371: LD_INT 5
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: PUSH
95378: LD_INT 0
95380: PUSH
95381: LD_INT 5
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 1
95390: NEG
95391: PUSH
95392: LD_INT 4
95394: PUSH
95395: EMPTY
95396: LIST
95397: LIST
95398: PUSH
95399: LD_INT 1
95401: NEG
95402: PUSH
95403: LD_INT 3
95405: PUSH
95406: EMPTY
95407: LIST
95408: LIST
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: LD_INT 5
95415: PUSH
95416: EMPTY
95417: LIST
95418: LIST
95419: PUSH
95420: LD_INT 2
95422: NEG
95423: PUSH
95424: LD_INT 3
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 3
95433: NEG
95434: PUSH
95435: LD_INT 0
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 3
95444: NEG
95445: PUSH
95446: LD_INT 1
95448: NEG
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: PUSH
95454: LD_INT 2
95456: NEG
95457: PUSH
95458: LD_INT 0
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 2
95467: NEG
95468: PUSH
95469: LD_INT 1
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 3
95478: NEG
95479: PUSH
95480: LD_INT 1
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 4
95489: NEG
95490: PUSH
95491: LD_INT 0
95493: PUSH
95494: EMPTY
95495: LIST
95496: LIST
95497: PUSH
95498: LD_INT 4
95500: NEG
95501: PUSH
95502: LD_INT 1
95504: NEG
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: PUSH
95510: LD_INT 4
95512: NEG
95513: PUSH
95514: LD_INT 2
95516: NEG
95517: PUSH
95518: EMPTY
95519: LIST
95520: LIST
95521: PUSH
95522: LD_INT 2
95524: NEG
95525: PUSH
95526: LD_INT 2
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 4
95535: NEG
95536: PUSH
95537: LD_INT 4
95539: NEG
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 4
95547: NEG
95548: PUSH
95549: LD_INT 5
95551: NEG
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 3
95559: NEG
95560: PUSH
95561: LD_INT 4
95563: NEG
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: LD_INT 3
95571: NEG
95572: PUSH
95573: LD_INT 3
95575: NEG
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 4
95583: NEG
95584: PUSH
95585: LD_INT 3
95587: NEG
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 5
95595: NEG
95596: PUSH
95597: LD_INT 4
95599: NEG
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 5
95607: NEG
95608: PUSH
95609: LD_INT 5
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 3
95619: NEG
95620: PUSH
95621: LD_INT 5
95623: NEG
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 5
95631: NEG
95632: PUSH
95633: LD_INT 3
95635: NEG
95636: PUSH
95637: EMPTY
95638: LIST
95639: LIST
95640: PUSH
95641: LD_INT 0
95643: PUSH
95644: LD_INT 3
95646: NEG
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 0
95654: PUSH
95655: LD_INT 4
95657: NEG
95658: PUSH
95659: EMPTY
95660: LIST
95661: LIST
95662: PUSH
95663: LD_INT 1
95665: PUSH
95666: LD_INT 3
95668: NEG
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 1
95676: PUSH
95677: LD_INT 2
95679: NEG
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 0
95687: PUSH
95688: LD_INT 2
95690: NEG
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: LD_INT 1
95698: NEG
95699: PUSH
95700: LD_INT 3
95702: NEG
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 1
95710: NEG
95711: PUSH
95712: LD_INT 4
95714: NEG
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 2
95722: PUSH
95723: LD_INT 2
95725: NEG
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 2
95733: NEG
95734: PUSH
95735: LD_INT 4
95737: NEG
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: PUSH
95743: LD_INT 4
95745: PUSH
95746: LD_INT 0
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 4
95755: PUSH
95756: LD_INT 1
95758: NEG
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 5
95766: PUSH
95767: LD_INT 0
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 5
95776: PUSH
95777: LD_INT 1
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 4
95786: PUSH
95787: LD_INT 1
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 3
95796: PUSH
95797: LD_INT 0
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 3
95806: PUSH
95807: LD_INT 1
95809: NEG
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 3
95817: PUSH
95818: LD_INT 2
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 5
95828: PUSH
95829: LD_INT 2
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95883: LD_ADDR_VAR 0 32
95887: PUSH
95888: LD_INT 4
95890: NEG
95891: PUSH
95892: LD_INT 0
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 4
95901: NEG
95902: PUSH
95903: LD_INT 1
95905: NEG
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 3
95913: NEG
95914: PUSH
95915: LD_INT 0
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 3
95924: NEG
95925: PUSH
95926: LD_INT 1
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 4
95935: NEG
95936: PUSH
95937: LD_INT 1
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: PUSH
95944: LD_INT 5
95946: NEG
95947: PUSH
95948: LD_INT 0
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: LD_INT 5
95957: NEG
95958: PUSH
95959: LD_INT 1
95961: NEG
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: PUSH
95967: LD_INT 5
95969: NEG
95970: PUSH
95971: LD_INT 2
95973: NEG
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: LD_INT 3
95981: NEG
95982: PUSH
95983: LD_INT 2
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 3
95992: NEG
95993: PUSH
95994: LD_INT 3
95996: NEG
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 3
96004: NEG
96005: PUSH
96006: LD_INT 4
96008: NEG
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PUSH
96014: LD_INT 2
96016: NEG
96017: PUSH
96018: LD_INT 3
96020: NEG
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: NEG
96029: PUSH
96030: LD_INT 2
96032: NEG
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: LD_INT 3
96040: NEG
96041: PUSH
96042: LD_INT 2
96044: NEG
96045: PUSH
96046: EMPTY
96047: LIST
96048: LIST
96049: PUSH
96050: LD_INT 4
96052: NEG
96053: PUSH
96054: LD_INT 3
96056: NEG
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 4
96064: NEG
96065: PUSH
96066: LD_INT 4
96068: NEG
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: LD_INT 4
96080: NEG
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 4
96088: NEG
96089: PUSH
96090: LD_INT 2
96092: NEG
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 0
96100: PUSH
96101: LD_INT 4
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 0
96111: PUSH
96112: LD_INT 5
96114: NEG
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 1
96122: PUSH
96123: LD_INT 4
96125: NEG
96126: PUSH
96127: EMPTY
96128: LIST
96129: LIST
96130: PUSH
96131: LD_INT 1
96133: PUSH
96134: LD_INT 3
96136: NEG
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: PUSH
96142: LD_INT 0
96144: PUSH
96145: LD_INT 3
96147: NEG
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: LD_INT 1
96155: NEG
96156: PUSH
96157: LD_INT 4
96159: NEG
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 1
96167: NEG
96168: PUSH
96169: LD_INT 5
96171: NEG
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 2
96179: PUSH
96180: LD_INT 3
96182: NEG
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 2
96190: NEG
96191: PUSH
96192: LD_INT 5
96194: NEG
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 3
96202: PUSH
96203: LD_INT 0
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 3
96212: PUSH
96213: LD_INT 1
96215: NEG
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 4
96223: PUSH
96224: LD_INT 0
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 4
96233: PUSH
96234: LD_INT 1
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 3
96243: PUSH
96244: LD_INT 1
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: LD_INT 2
96253: PUSH
96254: LD_INT 0
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 2
96263: PUSH
96264: LD_INT 1
96266: NEG
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 2
96274: PUSH
96275: LD_INT 2
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: LD_INT 2
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 4
96295: PUSH
96296: LD_INT 4
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 4
96305: PUSH
96306: LD_INT 3
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 5
96315: PUSH
96316: LD_INT 4
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 5
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 4
96335: PUSH
96336: LD_INT 5
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 3
96345: PUSH
96346: LD_INT 4
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 3
96355: PUSH
96356: LD_INT 3
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 5
96365: PUSH
96366: LD_INT 3
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 3
96375: PUSH
96376: LD_INT 5
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: EMPTY
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96430: LD_ADDR_VAR 0 33
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 4
96441: NEG
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: LD_INT 5
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 3
96461: NEG
96462: PUSH
96463: LD_INT 4
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 3
96477: NEG
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: PUSH
96483: LD_INT 4
96485: NEG
96486: PUSH
96487: LD_INT 3
96489: NEG
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: LD_INT 5
96497: NEG
96498: PUSH
96499: LD_INT 4
96501: NEG
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 5
96509: NEG
96510: PUSH
96511: LD_INT 5
96513: NEG
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: NEG
96522: PUSH
96523: LD_INT 5
96525: NEG
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: LD_INT 3
96537: NEG
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: PUSH
96543: LD_INT 0
96545: PUSH
96546: LD_INT 3
96548: NEG
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: PUSH
96554: LD_INT 0
96556: PUSH
96557: LD_INT 4
96559: NEG
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 1
96567: PUSH
96568: LD_INT 3
96570: NEG
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: PUSH
96576: LD_INT 1
96578: PUSH
96579: LD_INT 2
96581: NEG
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 0
96589: PUSH
96590: LD_INT 2
96592: NEG
96593: PUSH
96594: EMPTY
96595: LIST
96596: LIST
96597: PUSH
96598: LD_INT 1
96600: NEG
96601: PUSH
96602: LD_INT 3
96604: NEG
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 1
96612: NEG
96613: PUSH
96614: LD_INT 4
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 2
96624: PUSH
96625: LD_INT 2
96627: NEG
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 2
96635: NEG
96636: PUSH
96637: LD_INT 4
96639: NEG
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 4
96647: PUSH
96648: LD_INT 0
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 4
96657: PUSH
96658: LD_INT 1
96660: NEG
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 5
96668: PUSH
96669: LD_INT 0
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PUSH
96676: LD_INT 5
96678: PUSH
96679: LD_INT 1
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 4
96688: PUSH
96689: LD_INT 1
96691: PUSH
96692: EMPTY
96693: LIST
96694: LIST
96695: PUSH
96696: LD_INT 3
96698: PUSH
96699: LD_INT 0
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 3
96708: PUSH
96709: LD_INT 1
96711: NEG
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 3
96719: PUSH
96720: LD_INT 2
96722: NEG
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: PUSH
96728: LD_INT 5
96730: PUSH
96731: LD_INT 2
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: PUSH
96738: LD_INT 3
96740: PUSH
96741: LD_INT 3
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: LD_INT 3
96750: PUSH
96751: LD_INT 2
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: LD_INT 4
96760: PUSH
96761: LD_INT 3
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: PUSH
96768: LD_INT 4
96770: PUSH
96771: LD_INT 4
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: LD_INT 3
96780: PUSH
96781: LD_INT 4
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: LD_INT 2
96790: PUSH
96791: LD_INT 3
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PUSH
96798: LD_INT 2
96800: PUSH
96801: LD_INT 2
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 4
96810: PUSH
96811: LD_INT 2
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 2
96820: PUSH
96821: LD_INT 4
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 0
96830: PUSH
96831: LD_INT 4
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: PUSH
96838: LD_INT 0
96840: PUSH
96841: LD_INT 3
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 1
96850: PUSH
96851: LD_INT 4
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 1
96860: PUSH
96861: LD_INT 5
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: LD_INT 0
96870: PUSH
96871: LD_INT 5
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: PUSH
96878: LD_INT 1
96880: NEG
96881: PUSH
96882: LD_INT 4
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 1
96891: NEG
96892: PUSH
96893: LD_INT 3
96895: PUSH
96896: EMPTY
96897: LIST
96898: LIST
96899: PUSH
96900: LD_INT 2
96902: PUSH
96903: LD_INT 5
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: PUSH
96910: LD_INT 2
96912: NEG
96913: PUSH
96914: LD_INT 3
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96968: LD_ADDR_VAR 0 34
96972: PUSH
96973: LD_INT 0
96975: PUSH
96976: LD_INT 4
96978: NEG
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 0
96986: PUSH
96987: LD_INT 5
96989: NEG
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 1
96997: PUSH
96998: LD_INT 4
97000: NEG
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 1
97008: PUSH
97009: LD_INT 3
97011: NEG
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 0
97019: PUSH
97020: LD_INT 3
97022: NEG
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 1
97030: NEG
97031: PUSH
97032: LD_INT 4
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 1
97042: NEG
97043: PUSH
97044: LD_INT 5
97046: NEG
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 2
97054: PUSH
97055: LD_INT 3
97057: NEG
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 2
97065: NEG
97066: PUSH
97067: LD_INT 5
97069: NEG
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: PUSH
97075: LD_INT 3
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 3
97087: PUSH
97088: LD_INT 1
97090: NEG
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 4
97098: PUSH
97099: LD_INT 0
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 4
97108: PUSH
97109: LD_INT 1
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PUSH
97116: LD_INT 3
97118: PUSH
97119: LD_INT 1
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 2
97128: PUSH
97129: LD_INT 0
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 2
97138: PUSH
97139: LD_INT 1
97141: NEG
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 2
97149: PUSH
97150: LD_INT 2
97152: NEG
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 4
97160: PUSH
97161: LD_INT 2
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 4
97170: PUSH
97171: LD_INT 4
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_INT 4
97180: PUSH
97181: LD_INT 3
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: PUSH
97188: LD_INT 5
97190: PUSH
97191: LD_INT 4
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 5
97200: PUSH
97201: LD_INT 5
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 4
97210: PUSH
97211: LD_INT 5
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 3
97220: PUSH
97221: LD_INT 4
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: LD_INT 3
97230: PUSH
97231: LD_INT 3
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 5
97240: PUSH
97241: LD_INT 3
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: PUSH
97248: LD_INT 3
97250: PUSH
97251: LD_INT 5
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 0
97260: PUSH
97261: LD_INT 3
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: PUSH
97268: LD_INT 0
97270: PUSH
97271: LD_INT 2
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 1
97280: PUSH
97281: LD_INT 3
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 1
97290: PUSH
97291: LD_INT 4
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: LD_INT 0
97300: PUSH
97301: LD_INT 4
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_INT 1
97310: NEG
97311: PUSH
97312: LD_INT 3
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 1
97321: NEG
97322: PUSH
97323: LD_INT 2
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: LD_INT 4
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: LD_INT 2
97342: NEG
97343: PUSH
97344: LD_INT 2
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: PUSH
97351: LD_INT 4
97353: NEG
97354: PUSH
97355: LD_INT 0
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 4
97364: NEG
97365: PUSH
97366: LD_INT 1
97368: NEG
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 3
97376: NEG
97377: PUSH
97378: LD_INT 0
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 3
97387: NEG
97388: PUSH
97389: LD_INT 1
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 4
97398: NEG
97399: PUSH
97400: LD_INT 1
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 5
97409: NEG
97410: PUSH
97411: LD_INT 0
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 5
97420: NEG
97421: PUSH
97422: LD_INT 1
97424: NEG
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 5
97432: NEG
97433: PUSH
97434: LD_INT 2
97436: NEG
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 3
97444: NEG
97445: PUSH
97446: LD_INT 2
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: ST_TO_ADDR
// end ; end ;
97500: GO 97503
97502: POP
// case btype of b_depot , b_warehouse :
97503: LD_VAR 0 1
97507: PUSH
97508: LD_INT 0
97510: DOUBLE
97511: EQUAL
97512: IFTRUE 97522
97514: LD_INT 1
97516: DOUBLE
97517: EQUAL
97518: IFTRUE 97522
97520: GO 97723
97522: POP
// case nation of nation_american :
97523: LD_VAR 0 5
97527: PUSH
97528: LD_INT 1
97530: DOUBLE
97531: EQUAL
97532: IFTRUE 97536
97534: GO 97592
97536: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97537: LD_ADDR_VAR 0 9
97541: PUSH
97542: LD_VAR 0 11
97546: PUSH
97547: LD_VAR 0 12
97551: PUSH
97552: LD_VAR 0 13
97556: PUSH
97557: LD_VAR 0 14
97561: PUSH
97562: LD_VAR 0 15
97566: PUSH
97567: LD_VAR 0 16
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: PUSH
97580: LD_VAR 0 4
97584: PUSH
97585: LD_INT 1
97587: PLUS
97588: ARRAY
97589: ST_TO_ADDR
97590: GO 97721
97592: LD_INT 2
97594: DOUBLE
97595: EQUAL
97596: IFTRUE 97600
97598: GO 97656
97600: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97601: LD_ADDR_VAR 0 9
97605: PUSH
97606: LD_VAR 0 17
97610: PUSH
97611: LD_VAR 0 18
97615: PUSH
97616: LD_VAR 0 19
97620: PUSH
97621: LD_VAR 0 20
97625: PUSH
97626: LD_VAR 0 21
97630: PUSH
97631: LD_VAR 0 22
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: PUSH
97644: LD_VAR 0 4
97648: PUSH
97649: LD_INT 1
97651: PLUS
97652: ARRAY
97653: ST_TO_ADDR
97654: GO 97721
97656: LD_INT 3
97658: DOUBLE
97659: EQUAL
97660: IFTRUE 97664
97662: GO 97720
97664: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97665: LD_ADDR_VAR 0 9
97669: PUSH
97670: LD_VAR 0 23
97674: PUSH
97675: LD_VAR 0 24
97679: PUSH
97680: LD_VAR 0 25
97684: PUSH
97685: LD_VAR 0 26
97689: PUSH
97690: LD_VAR 0 27
97694: PUSH
97695: LD_VAR 0 28
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: PUSH
97708: LD_VAR 0 4
97712: PUSH
97713: LD_INT 1
97715: PLUS
97716: ARRAY
97717: ST_TO_ADDR
97718: GO 97721
97720: POP
97721: GO 98276
97723: LD_INT 2
97725: DOUBLE
97726: EQUAL
97727: IFTRUE 97737
97729: LD_INT 3
97731: DOUBLE
97732: EQUAL
97733: IFTRUE 97737
97735: GO 97793
97737: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97738: LD_ADDR_VAR 0 9
97742: PUSH
97743: LD_VAR 0 29
97747: PUSH
97748: LD_VAR 0 30
97752: PUSH
97753: LD_VAR 0 31
97757: PUSH
97758: LD_VAR 0 32
97762: PUSH
97763: LD_VAR 0 33
97767: PUSH
97768: LD_VAR 0 34
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: PUSH
97781: LD_VAR 0 4
97785: PUSH
97786: LD_INT 1
97788: PLUS
97789: ARRAY
97790: ST_TO_ADDR
97791: GO 98276
97793: LD_INT 16
97795: DOUBLE
97796: EQUAL
97797: IFTRUE 97855
97799: LD_INT 17
97801: DOUBLE
97802: EQUAL
97803: IFTRUE 97855
97805: LD_INT 18
97807: DOUBLE
97808: EQUAL
97809: IFTRUE 97855
97811: LD_INT 19
97813: DOUBLE
97814: EQUAL
97815: IFTRUE 97855
97817: LD_INT 22
97819: DOUBLE
97820: EQUAL
97821: IFTRUE 97855
97823: LD_INT 20
97825: DOUBLE
97826: EQUAL
97827: IFTRUE 97855
97829: LD_INT 21
97831: DOUBLE
97832: EQUAL
97833: IFTRUE 97855
97835: LD_INT 23
97837: DOUBLE
97838: EQUAL
97839: IFTRUE 97855
97841: LD_INT 24
97843: DOUBLE
97844: EQUAL
97845: IFTRUE 97855
97847: LD_INT 25
97849: DOUBLE
97850: EQUAL
97851: IFTRUE 97855
97853: GO 97911
97855: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97856: LD_ADDR_VAR 0 9
97860: PUSH
97861: LD_VAR 0 35
97865: PUSH
97866: LD_VAR 0 36
97870: PUSH
97871: LD_VAR 0 37
97875: PUSH
97876: LD_VAR 0 38
97880: PUSH
97881: LD_VAR 0 39
97885: PUSH
97886: LD_VAR 0 40
97890: PUSH
97891: EMPTY
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: PUSH
97899: LD_VAR 0 4
97903: PUSH
97904: LD_INT 1
97906: PLUS
97907: ARRAY
97908: ST_TO_ADDR
97909: GO 98276
97911: LD_INT 6
97913: DOUBLE
97914: EQUAL
97915: IFTRUE 97967
97917: LD_INT 7
97919: DOUBLE
97920: EQUAL
97921: IFTRUE 97967
97923: LD_INT 8
97925: DOUBLE
97926: EQUAL
97927: IFTRUE 97967
97929: LD_INT 13
97931: DOUBLE
97932: EQUAL
97933: IFTRUE 97967
97935: LD_INT 12
97937: DOUBLE
97938: EQUAL
97939: IFTRUE 97967
97941: LD_INT 15
97943: DOUBLE
97944: EQUAL
97945: IFTRUE 97967
97947: LD_INT 11
97949: DOUBLE
97950: EQUAL
97951: IFTRUE 97967
97953: LD_INT 14
97955: DOUBLE
97956: EQUAL
97957: IFTRUE 97967
97959: LD_INT 10
97961: DOUBLE
97962: EQUAL
97963: IFTRUE 97967
97965: GO 98023
97967: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97968: LD_ADDR_VAR 0 9
97972: PUSH
97973: LD_VAR 0 41
97977: PUSH
97978: LD_VAR 0 42
97982: PUSH
97983: LD_VAR 0 43
97987: PUSH
97988: LD_VAR 0 44
97992: PUSH
97993: LD_VAR 0 45
97997: PUSH
97998: LD_VAR 0 46
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: PUSH
98011: LD_VAR 0 4
98015: PUSH
98016: LD_INT 1
98018: PLUS
98019: ARRAY
98020: ST_TO_ADDR
98021: GO 98276
98023: LD_INT 36
98025: DOUBLE
98026: EQUAL
98027: IFTRUE 98031
98029: GO 98087
98031: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98032: LD_ADDR_VAR 0 9
98036: PUSH
98037: LD_VAR 0 47
98041: PUSH
98042: LD_VAR 0 48
98046: PUSH
98047: LD_VAR 0 49
98051: PUSH
98052: LD_VAR 0 50
98056: PUSH
98057: LD_VAR 0 51
98061: PUSH
98062: LD_VAR 0 52
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: PUSH
98075: LD_VAR 0 4
98079: PUSH
98080: LD_INT 1
98082: PLUS
98083: ARRAY
98084: ST_TO_ADDR
98085: GO 98276
98087: LD_INT 4
98089: DOUBLE
98090: EQUAL
98091: IFTRUE 98113
98093: LD_INT 5
98095: DOUBLE
98096: EQUAL
98097: IFTRUE 98113
98099: LD_INT 34
98101: DOUBLE
98102: EQUAL
98103: IFTRUE 98113
98105: LD_INT 37
98107: DOUBLE
98108: EQUAL
98109: IFTRUE 98113
98111: GO 98169
98113: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98114: LD_ADDR_VAR 0 9
98118: PUSH
98119: LD_VAR 0 53
98123: PUSH
98124: LD_VAR 0 54
98128: PUSH
98129: LD_VAR 0 55
98133: PUSH
98134: LD_VAR 0 56
98138: PUSH
98139: LD_VAR 0 57
98143: PUSH
98144: LD_VAR 0 58
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: PUSH
98157: LD_VAR 0 4
98161: PUSH
98162: LD_INT 1
98164: PLUS
98165: ARRAY
98166: ST_TO_ADDR
98167: GO 98276
98169: LD_INT 31
98171: DOUBLE
98172: EQUAL
98173: IFTRUE 98219
98175: LD_INT 32
98177: DOUBLE
98178: EQUAL
98179: IFTRUE 98219
98181: LD_INT 33
98183: DOUBLE
98184: EQUAL
98185: IFTRUE 98219
98187: LD_INT 27
98189: DOUBLE
98190: EQUAL
98191: IFTRUE 98219
98193: LD_INT 26
98195: DOUBLE
98196: EQUAL
98197: IFTRUE 98219
98199: LD_INT 28
98201: DOUBLE
98202: EQUAL
98203: IFTRUE 98219
98205: LD_INT 29
98207: DOUBLE
98208: EQUAL
98209: IFTRUE 98219
98211: LD_INT 30
98213: DOUBLE
98214: EQUAL
98215: IFTRUE 98219
98217: GO 98275
98219: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98220: LD_ADDR_VAR 0 9
98224: PUSH
98225: LD_VAR 0 59
98229: PUSH
98230: LD_VAR 0 60
98234: PUSH
98235: LD_VAR 0 61
98239: PUSH
98240: LD_VAR 0 62
98244: PUSH
98245: LD_VAR 0 63
98249: PUSH
98250: LD_VAR 0 64
98254: PUSH
98255: EMPTY
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: PUSH
98263: LD_VAR 0 4
98267: PUSH
98268: LD_INT 1
98270: PLUS
98271: ARRAY
98272: ST_TO_ADDR
98273: GO 98276
98275: POP
// temp_list2 = [ ] ;
98276: LD_ADDR_VAR 0 10
98280: PUSH
98281: EMPTY
98282: ST_TO_ADDR
// for i in temp_list do
98283: LD_ADDR_VAR 0 8
98287: PUSH
98288: LD_VAR 0 9
98292: PUSH
98293: FOR_IN
98294: IFFALSE 98346
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98296: LD_ADDR_VAR 0 10
98300: PUSH
98301: LD_VAR 0 10
98305: PUSH
98306: LD_VAR 0 8
98310: PUSH
98311: LD_INT 1
98313: ARRAY
98314: PUSH
98315: LD_VAR 0 2
98319: PLUS
98320: PUSH
98321: LD_VAR 0 8
98325: PUSH
98326: LD_INT 2
98328: ARRAY
98329: PUSH
98330: LD_VAR 0 3
98334: PLUS
98335: PUSH
98336: EMPTY
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: ADD
98343: ST_TO_ADDR
98344: GO 98293
98346: POP
98347: POP
// result = temp_list2 ;
98348: LD_ADDR_VAR 0 7
98352: PUSH
98353: LD_VAR 0 10
98357: ST_TO_ADDR
// end ;
98358: LD_VAR 0 7
98362: RET
// export function EnemyInRange ( unit , dist ) ; begin
98363: LD_INT 0
98365: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98366: LD_ADDR_VAR 0 3
98370: PUSH
98371: LD_VAR 0 1
98375: PPUSH
98376: CALL_OW 255
98380: PPUSH
98381: LD_VAR 0 1
98385: PPUSH
98386: CALL_OW 250
98390: PPUSH
98391: LD_VAR 0 1
98395: PPUSH
98396: CALL_OW 251
98400: PPUSH
98401: LD_VAR 0 2
98405: PPUSH
98406: CALL 71765 0 4
98410: PUSH
98411: LD_INT 4
98413: ARRAY
98414: ST_TO_ADDR
// end ;
98415: LD_VAR 0 3
98419: RET
// export function PlayerSeeMe ( unit ) ; begin
98420: LD_INT 0
98422: PPUSH
// result := See ( your_side , unit ) ;
98423: LD_ADDR_VAR 0 2
98427: PUSH
98428: LD_OWVAR 2
98432: PPUSH
98433: LD_VAR 0 1
98437: PPUSH
98438: CALL_OW 292
98442: ST_TO_ADDR
// end ;
98443: LD_VAR 0 2
98447: RET
// export function ReverseDir ( unit ) ; begin
98448: LD_INT 0
98450: PPUSH
// if not unit then
98451: LD_VAR 0 1
98455: NOT
98456: IFFALSE 98460
// exit ;
98458: GO 98483
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98460: LD_ADDR_VAR 0 2
98464: PUSH
98465: LD_VAR 0 1
98469: PPUSH
98470: CALL_OW 254
98474: PUSH
98475: LD_INT 3
98477: PLUS
98478: PUSH
98479: LD_INT 6
98481: MOD
98482: ST_TO_ADDR
// end ;
98483: LD_VAR 0 2
98487: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
98488: LD_INT 0
98490: PPUSH
98491: PPUSH
98492: PPUSH
98493: PPUSH
98494: PPUSH
98495: PPUSH
// if not unit or not hexes then
98496: LD_VAR 0 1
98500: NOT
98501: PUSH
98502: LD_VAR 0 2
98506: NOT
98507: OR
98508: IFFALSE 98512
// exit ;
98510: GO 98635
// dist := 9999 ;
98512: LD_ADDR_VAR 0 5
98516: PUSH
98517: LD_INT 9999
98519: ST_TO_ADDR
// for i = 1 to hexes do
98520: LD_ADDR_VAR 0 4
98524: PUSH
98525: DOUBLE
98526: LD_INT 1
98528: DEC
98529: ST_TO_ADDR
98530: LD_VAR 0 2
98534: PUSH
98535: FOR_TO
98536: IFFALSE 98623
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98538: LD_ADDR_VAR 0 6
98542: PUSH
98543: LD_VAR 0 1
98547: PPUSH
98548: LD_VAR 0 2
98552: PUSH
98553: LD_VAR 0 4
98557: ARRAY
98558: PUSH
98559: LD_INT 1
98561: ARRAY
98562: PPUSH
98563: LD_VAR 0 2
98567: PUSH
98568: LD_VAR 0 4
98572: ARRAY
98573: PUSH
98574: LD_INT 2
98576: ARRAY
98577: PPUSH
98578: CALL_OW 297
98582: ST_TO_ADDR
// if tdist < dist then
98583: LD_VAR 0 6
98587: PUSH
98588: LD_VAR 0 5
98592: LESS
98593: IFFALSE 98621
// begin hex := hexes [ i ] ;
98595: LD_ADDR_VAR 0 8
98599: PUSH
98600: LD_VAR 0 2
98604: PUSH
98605: LD_VAR 0 4
98609: ARRAY
98610: ST_TO_ADDR
// dist := tdist ;
98611: LD_ADDR_VAR 0 5
98615: PUSH
98616: LD_VAR 0 6
98620: ST_TO_ADDR
// end ; end ;
98621: GO 98535
98623: POP
98624: POP
// result := hex ;
98625: LD_ADDR_VAR 0 3
98629: PUSH
98630: LD_VAR 0 8
98634: ST_TO_ADDR
// end ;
98635: LD_VAR 0 3
98639: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98640: LD_INT 0
98642: PPUSH
98643: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98644: LD_VAR 0 1
98648: NOT
98649: PUSH
98650: LD_VAR 0 1
98654: PUSH
98655: LD_INT 21
98657: PUSH
98658: LD_INT 2
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 23
98667: PUSH
98668: LD_INT 2
98670: PUSH
98671: EMPTY
98672: LIST
98673: LIST
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: PPUSH
98679: CALL_OW 69
98683: IN
98684: NOT
98685: OR
98686: IFFALSE 98690
// exit ;
98688: GO 98737
// for i = 1 to 3 do
98690: LD_ADDR_VAR 0 3
98694: PUSH
98695: DOUBLE
98696: LD_INT 1
98698: DEC
98699: ST_TO_ADDR
98700: LD_INT 3
98702: PUSH
98703: FOR_TO
98704: IFFALSE 98735
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98706: LD_VAR 0 1
98710: PPUSH
98711: CALL_OW 250
98715: PPUSH
98716: LD_VAR 0 1
98720: PPUSH
98721: CALL_OW 251
98725: PPUSH
98726: LD_INT 1
98728: PPUSH
98729: CALL_OW 453
98733: GO 98703
98735: POP
98736: POP
// end ;
98737: LD_VAR 0 2
98741: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98742: LD_INT 0
98744: PPUSH
98745: PPUSH
98746: PPUSH
98747: PPUSH
98748: PPUSH
98749: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98750: LD_VAR 0 1
98754: NOT
98755: PUSH
98756: LD_VAR 0 2
98760: NOT
98761: OR
98762: PUSH
98763: LD_VAR 0 1
98767: PPUSH
98768: CALL_OW 314
98772: OR
98773: IFFALSE 98777
// exit ;
98775: GO 99218
// x := GetX ( enemy_unit ) ;
98777: LD_ADDR_VAR 0 7
98781: PUSH
98782: LD_VAR 0 2
98786: PPUSH
98787: CALL_OW 250
98791: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98792: LD_ADDR_VAR 0 8
98796: PUSH
98797: LD_VAR 0 2
98801: PPUSH
98802: CALL_OW 251
98806: ST_TO_ADDR
// if not x or not y then
98807: LD_VAR 0 7
98811: NOT
98812: PUSH
98813: LD_VAR 0 8
98817: NOT
98818: OR
98819: IFFALSE 98823
// exit ;
98821: GO 99218
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98823: LD_ADDR_VAR 0 6
98827: PUSH
98828: LD_VAR 0 7
98832: PPUSH
98833: LD_INT 0
98835: PPUSH
98836: LD_INT 4
98838: PPUSH
98839: CALL_OW 272
98843: PUSH
98844: LD_VAR 0 8
98848: PPUSH
98849: LD_INT 0
98851: PPUSH
98852: LD_INT 4
98854: PPUSH
98855: CALL_OW 273
98859: PUSH
98860: EMPTY
98861: LIST
98862: LIST
98863: PUSH
98864: LD_VAR 0 7
98868: PPUSH
98869: LD_INT 1
98871: PPUSH
98872: LD_INT 4
98874: PPUSH
98875: CALL_OW 272
98879: PUSH
98880: LD_VAR 0 8
98884: PPUSH
98885: LD_INT 1
98887: PPUSH
98888: LD_INT 4
98890: PPUSH
98891: CALL_OW 273
98895: PUSH
98896: EMPTY
98897: LIST
98898: LIST
98899: PUSH
98900: LD_VAR 0 7
98904: PPUSH
98905: LD_INT 2
98907: PPUSH
98908: LD_INT 4
98910: PPUSH
98911: CALL_OW 272
98915: PUSH
98916: LD_VAR 0 8
98920: PPUSH
98921: LD_INT 2
98923: PPUSH
98924: LD_INT 4
98926: PPUSH
98927: CALL_OW 273
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_VAR 0 7
98940: PPUSH
98941: LD_INT 3
98943: PPUSH
98944: LD_INT 4
98946: PPUSH
98947: CALL_OW 272
98951: PUSH
98952: LD_VAR 0 8
98956: PPUSH
98957: LD_INT 3
98959: PPUSH
98960: LD_INT 4
98962: PPUSH
98963: CALL_OW 273
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: LD_VAR 0 7
98976: PPUSH
98977: LD_INT 4
98979: PPUSH
98980: LD_INT 4
98982: PPUSH
98983: CALL_OW 272
98987: PUSH
98988: LD_VAR 0 8
98992: PPUSH
98993: LD_INT 4
98995: PPUSH
98996: LD_INT 4
98998: PPUSH
98999: CALL_OW 273
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: LD_VAR 0 7
99012: PPUSH
99013: LD_INT 5
99015: PPUSH
99016: LD_INT 4
99018: PPUSH
99019: CALL_OW 272
99023: PUSH
99024: LD_VAR 0 8
99028: PPUSH
99029: LD_INT 5
99031: PPUSH
99032: LD_INT 4
99034: PPUSH
99035: CALL_OW 273
99039: PUSH
99040: EMPTY
99041: LIST
99042: LIST
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: ST_TO_ADDR
// for i = tmp downto 1 do
99052: LD_ADDR_VAR 0 4
99056: PUSH
99057: DOUBLE
99058: LD_VAR 0 6
99062: INC
99063: ST_TO_ADDR
99064: LD_INT 1
99066: PUSH
99067: FOR_DOWNTO
99068: IFFALSE 99169
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99070: LD_VAR 0 6
99074: PUSH
99075: LD_VAR 0 4
99079: ARRAY
99080: PUSH
99081: LD_INT 1
99083: ARRAY
99084: PPUSH
99085: LD_VAR 0 6
99089: PUSH
99090: LD_VAR 0 4
99094: ARRAY
99095: PUSH
99096: LD_INT 2
99098: ARRAY
99099: PPUSH
99100: CALL_OW 488
99104: NOT
99105: PUSH
99106: LD_VAR 0 6
99110: PUSH
99111: LD_VAR 0 4
99115: ARRAY
99116: PUSH
99117: LD_INT 1
99119: ARRAY
99120: PPUSH
99121: LD_VAR 0 6
99125: PUSH
99126: LD_VAR 0 4
99130: ARRAY
99131: PUSH
99132: LD_INT 2
99134: ARRAY
99135: PPUSH
99136: CALL_OW 428
99140: PUSH
99141: LD_INT 0
99143: NONEQUAL
99144: OR
99145: IFFALSE 99167
// tmp := Delete ( tmp , i ) ;
99147: LD_ADDR_VAR 0 6
99151: PUSH
99152: LD_VAR 0 6
99156: PPUSH
99157: LD_VAR 0 4
99161: PPUSH
99162: CALL_OW 3
99166: ST_TO_ADDR
99167: GO 99067
99169: POP
99170: POP
// j := GetClosestHex ( unit , tmp ) ;
99171: LD_ADDR_VAR 0 5
99175: PUSH
99176: LD_VAR 0 1
99180: PPUSH
99181: LD_VAR 0 6
99185: PPUSH
99186: CALL 98488 0 2
99190: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99191: LD_VAR 0 1
99195: PPUSH
99196: LD_VAR 0 5
99200: PUSH
99201: LD_INT 1
99203: ARRAY
99204: PPUSH
99205: LD_VAR 0 5
99209: PUSH
99210: LD_INT 2
99212: ARRAY
99213: PPUSH
99214: CALL_OW 111
// end ;
99218: LD_VAR 0 3
99222: RET
// export function PrepareApemanSoldier ( ) ; begin
99223: LD_INT 0
99225: PPUSH
// uc_nation := 0 ;
99226: LD_ADDR_OWVAR 21
99230: PUSH
99231: LD_INT 0
99233: ST_TO_ADDR
// hc_sex := sex_male ;
99234: LD_ADDR_OWVAR 27
99238: PUSH
99239: LD_INT 1
99241: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
99242: LD_ADDR_OWVAR 28
99246: PUSH
99247: LD_INT 15
99249: ST_TO_ADDR
// hc_gallery :=  ;
99250: LD_ADDR_OWVAR 33
99254: PUSH
99255: LD_STRING 
99257: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99258: LD_ADDR_OWVAR 31
99262: PUSH
99263: LD_INT 0
99265: PPUSH
99266: LD_INT 3
99268: PPUSH
99269: CALL_OW 12
99273: PUSH
99274: LD_INT 0
99276: PPUSH
99277: LD_INT 3
99279: PPUSH
99280: CALL_OW 12
99284: PUSH
99285: LD_INT 0
99287: PUSH
99288: LD_INT 0
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: LIST
99295: LIST
99296: ST_TO_ADDR
// end ;
99297: LD_VAR 0 1
99301: RET
// export function PrepareApemanEngineer ( ) ; begin
99302: LD_INT 0
99304: PPUSH
// uc_nation := 0 ;
99305: LD_ADDR_OWVAR 21
99309: PUSH
99310: LD_INT 0
99312: ST_TO_ADDR
// hc_sex := sex_male ;
99313: LD_ADDR_OWVAR 27
99317: PUSH
99318: LD_INT 1
99320: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
99321: LD_ADDR_OWVAR 28
99325: PUSH
99326: LD_INT 16
99328: ST_TO_ADDR
// hc_gallery :=  ;
99329: LD_ADDR_OWVAR 33
99333: PUSH
99334: LD_STRING 
99336: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99337: LD_ADDR_OWVAR 31
99341: PUSH
99342: LD_INT 0
99344: PPUSH
99345: LD_INT 3
99347: PPUSH
99348: CALL_OW 12
99352: PUSH
99353: LD_INT 0
99355: PPUSH
99356: LD_INT 3
99358: PPUSH
99359: CALL_OW 12
99363: PUSH
99364: LD_INT 0
99366: PUSH
99367: LD_INT 0
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: ST_TO_ADDR
// end ;
99376: LD_VAR 0 1
99380: RET
// export function PrepareApeman ( agressivity ) ; begin
99381: LD_INT 0
99383: PPUSH
// uc_side := 0 ;
99384: LD_ADDR_OWVAR 20
99388: PUSH
99389: LD_INT 0
99391: ST_TO_ADDR
// uc_nation := 0 ;
99392: LD_ADDR_OWVAR 21
99396: PUSH
99397: LD_INT 0
99399: ST_TO_ADDR
// hc_sex := sex_male ;
99400: LD_ADDR_OWVAR 27
99404: PUSH
99405: LD_INT 1
99407: ST_TO_ADDR
// hc_class := class_apeman ;
99408: LD_ADDR_OWVAR 28
99412: PUSH
99413: LD_INT 12
99415: ST_TO_ADDR
// hc_gallery :=  ;
99416: LD_ADDR_OWVAR 33
99420: PUSH
99421: LD_STRING 
99423: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99424: LD_ADDR_OWVAR 35
99428: PUSH
99429: LD_VAR 0 1
99433: NEG
99434: PPUSH
99435: LD_VAR 0 1
99439: PPUSH
99440: CALL_OW 12
99444: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99445: LD_ADDR_OWVAR 31
99449: PUSH
99450: LD_INT 0
99452: PPUSH
99453: LD_INT 3
99455: PPUSH
99456: CALL_OW 12
99460: PUSH
99461: LD_INT 0
99463: PPUSH
99464: LD_INT 3
99466: PPUSH
99467: CALL_OW 12
99471: PUSH
99472: LD_INT 0
99474: PUSH
99475: LD_INT 0
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: ST_TO_ADDR
// end ;
99484: LD_VAR 0 2
99488: RET
// export function PrepareTiger ( agressivity ) ; begin
99489: LD_INT 0
99491: PPUSH
// uc_side := 0 ;
99492: LD_ADDR_OWVAR 20
99496: PUSH
99497: LD_INT 0
99499: ST_TO_ADDR
// uc_nation := 0 ;
99500: LD_ADDR_OWVAR 21
99504: PUSH
99505: LD_INT 0
99507: ST_TO_ADDR
// hc_class := class_tiger ;
99508: LD_ADDR_OWVAR 28
99512: PUSH
99513: LD_INT 14
99515: ST_TO_ADDR
// hc_gallery :=  ;
99516: LD_ADDR_OWVAR 33
99520: PUSH
99521: LD_STRING 
99523: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99524: LD_ADDR_OWVAR 35
99528: PUSH
99529: LD_VAR 0 1
99533: NEG
99534: PPUSH
99535: LD_VAR 0 1
99539: PPUSH
99540: CALL_OW 12
99544: ST_TO_ADDR
// end ;
99545: LD_VAR 0 2
99549: RET
// export function PrepareEnchidna ( ) ; begin
99550: LD_INT 0
99552: PPUSH
// uc_side := 0 ;
99553: LD_ADDR_OWVAR 20
99557: PUSH
99558: LD_INT 0
99560: ST_TO_ADDR
// uc_nation := 0 ;
99561: LD_ADDR_OWVAR 21
99565: PUSH
99566: LD_INT 0
99568: ST_TO_ADDR
// hc_class := class_baggie ;
99569: LD_ADDR_OWVAR 28
99573: PUSH
99574: LD_INT 13
99576: ST_TO_ADDR
// hc_gallery :=  ;
99577: LD_ADDR_OWVAR 33
99581: PUSH
99582: LD_STRING 
99584: ST_TO_ADDR
// end ;
99585: LD_VAR 0 1
99589: RET
// export function PrepareFrog ( ) ; begin
99590: LD_INT 0
99592: PPUSH
// uc_side := 0 ;
99593: LD_ADDR_OWVAR 20
99597: PUSH
99598: LD_INT 0
99600: ST_TO_ADDR
// uc_nation := 0 ;
99601: LD_ADDR_OWVAR 21
99605: PUSH
99606: LD_INT 0
99608: ST_TO_ADDR
// hc_class := class_frog ;
99609: LD_ADDR_OWVAR 28
99613: PUSH
99614: LD_INT 19
99616: ST_TO_ADDR
// hc_gallery :=  ;
99617: LD_ADDR_OWVAR 33
99621: PUSH
99622: LD_STRING 
99624: ST_TO_ADDR
// end ;
99625: LD_VAR 0 1
99629: RET
// export function PrepareFish ( ) ; begin
99630: LD_INT 0
99632: PPUSH
// uc_side := 0 ;
99633: LD_ADDR_OWVAR 20
99637: PUSH
99638: LD_INT 0
99640: ST_TO_ADDR
// uc_nation := 0 ;
99641: LD_ADDR_OWVAR 21
99645: PUSH
99646: LD_INT 0
99648: ST_TO_ADDR
// hc_class := class_fish ;
99649: LD_ADDR_OWVAR 28
99653: PUSH
99654: LD_INT 20
99656: ST_TO_ADDR
// hc_gallery :=  ;
99657: LD_ADDR_OWVAR 33
99661: PUSH
99662: LD_STRING 
99664: ST_TO_ADDR
// end ;
99665: LD_VAR 0 1
99669: RET
// export function PrepareBird ( ) ; begin
99670: LD_INT 0
99672: PPUSH
// uc_side := 0 ;
99673: LD_ADDR_OWVAR 20
99677: PUSH
99678: LD_INT 0
99680: ST_TO_ADDR
// uc_nation := 0 ;
99681: LD_ADDR_OWVAR 21
99685: PUSH
99686: LD_INT 0
99688: ST_TO_ADDR
// hc_class := class_phororhacos ;
99689: LD_ADDR_OWVAR 28
99693: PUSH
99694: LD_INT 18
99696: ST_TO_ADDR
// hc_gallery :=  ;
99697: LD_ADDR_OWVAR 33
99701: PUSH
99702: LD_STRING 
99704: ST_TO_ADDR
// end ;
99705: LD_VAR 0 1
99709: RET
// export function PrepareHorse ( ) ; begin
99710: LD_INT 0
99712: PPUSH
// uc_side := 0 ;
99713: LD_ADDR_OWVAR 20
99717: PUSH
99718: LD_INT 0
99720: ST_TO_ADDR
// uc_nation := 0 ;
99721: LD_ADDR_OWVAR 21
99725: PUSH
99726: LD_INT 0
99728: ST_TO_ADDR
// hc_class := class_horse ;
99729: LD_ADDR_OWVAR 28
99733: PUSH
99734: LD_INT 21
99736: ST_TO_ADDR
// hc_gallery :=  ;
99737: LD_ADDR_OWVAR 33
99741: PUSH
99742: LD_STRING 
99744: ST_TO_ADDR
// end ;
99745: LD_VAR 0 1
99749: RET
// export function PrepareMastodont ( ) ; begin
99750: LD_INT 0
99752: PPUSH
// uc_side := 0 ;
99753: LD_ADDR_OWVAR 20
99757: PUSH
99758: LD_INT 0
99760: ST_TO_ADDR
// uc_nation := 0 ;
99761: LD_ADDR_OWVAR 21
99765: PUSH
99766: LD_INT 0
99768: ST_TO_ADDR
// vc_chassis := class_mastodont ;
99769: LD_ADDR_OWVAR 37
99773: PUSH
99774: LD_INT 31
99776: ST_TO_ADDR
// vc_control := control_rider ;
99777: LD_ADDR_OWVAR 38
99781: PUSH
99782: LD_INT 4
99784: ST_TO_ADDR
// end ;
99785: LD_VAR 0 1
99789: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99790: LD_INT 0
99792: PPUSH
99793: PPUSH
99794: PPUSH
// uc_side = 0 ;
99795: LD_ADDR_OWVAR 20
99799: PUSH
99800: LD_INT 0
99802: ST_TO_ADDR
// uc_nation = 0 ;
99803: LD_ADDR_OWVAR 21
99807: PUSH
99808: LD_INT 0
99810: ST_TO_ADDR
// InitHc_All ( ) ;
99811: CALL_OW 584
// InitVc ;
99815: CALL_OW 20
// if mastodonts then
99819: LD_VAR 0 6
99823: IFFALSE 99890
// for i = 1 to mastodonts do
99825: LD_ADDR_VAR 0 11
99829: PUSH
99830: DOUBLE
99831: LD_INT 1
99833: DEC
99834: ST_TO_ADDR
99835: LD_VAR 0 6
99839: PUSH
99840: FOR_TO
99841: IFFALSE 99888
// begin vc_chassis := 31 ;
99843: LD_ADDR_OWVAR 37
99847: PUSH
99848: LD_INT 31
99850: ST_TO_ADDR
// vc_control := control_rider ;
99851: LD_ADDR_OWVAR 38
99855: PUSH
99856: LD_INT 4
99858: ST_TO_ADDR
// animal := CreateVehicle ;
99859: LD_ADDR_VAR 0 12
99863: PUSH
99864: CALL_OW 45
99868: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99869: LD_VAR 0 12
99873: PPUSH
99874: LD_VAR 0 8
99878: PPUSH
99879: LD_INT 0
99881: PPUSH
99882: CALL 102025 0 3
// end ;
99886: GO 99840
99888: POP
99889: POP
// if horses then
99890: LD_VAR 0 5
99894: IFFALSE 99961
// for i = 1 to horses do
99896: LD_ADDR_VAR 0 11
99900: PUSH
99901: DOUBLE
99902: LD_INT 1
99904: DEC
99905: ST_TO_ADDR
99906: LD_VAR 0 5
99910: PUSH
99911: FOR_TO
99912: IFFALSE 99959
// begin hc_class := 21 ;
99914: LD_ADDR_OWVAR 28
99918: PUSH
99919: LD_INT 21
99921: ST_TO_ADDR
// hc_gallery :=  ;
99922: LD_ADDR_OWVAR 33
99926: PUSH
99927: LD_STRING 
99929: ST_TO_ADDR
// animal := CreateHuman ;
99930: LD_ADDR_VAR 0 12
99934: PUSH
99935: CALL_OW 44
99939: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99940: LD_VAR 0 12
99944: PPUSH
99945: LD_VAR 0 8
99949: PPUSH
99950: LD_INT 0
99952: PPUSH
99953: CALL 102025 0 3
// end ;
99957: GO 99911
99959: POP
99960: POP
// if birds then
99961: LD_VAR 0 1
99965: IFFALSE 100032
// for i = 1 to birds do
99967: LD_ADDR_VAR 0 11
99971: PUSH
99972: DOUBLE
99973: LD_INT 1
99975: DEC
99976: ST_TO_ADDR
99977: LD_VAR 0 1
99981: PUSH
99982: FOR_TO
99983: IFFALSE 100030
// begin hc_class = 18 ;
99985: LD_ADDR_OWVAR 28
99989: PUSH
99990: LD_INT 18
99992: ST_TO_ADDR
// hc_gallery =  ;
99993: LD_ADDR_OWVAR 33
99997: PUSH
99998: LD_STRING 
100000: ST_TO_ADDR
// animal := CreateHuman ;
100001: LD_ADDR_VAR 0 12
100005: PUSH
100006: CALL_OW 44
100010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100011: LD_VAR 0 12
100015: PPUSH
100016: LD_VAR 0 8
100020: PPUSH
100021: LD_INT 0
100023: PPUSH
100024: CALL 102025 0 3
// end ;
100028: GO 99982
100030: POP
100031: POP
// if tigers then
100032: LD_VAR 0 2
100036: IFFALSE 100120
// for i = 1 to tigers do
100038: LD_ADDR_VAR 0 11
100042: PUSH
100043: DOUBLE
100044: LD_INT 1
100046: DEC
100047: ST_TO_ADDR
100048: LD_VAR 0 2
100052: PUSH
100053: FOR_TO
100054: IFFALSE 100118
// begin hc_class = class_tiger ;
100056: LD_ADDR_OWVAR 28
100060: PUSH
100061: LD_INT 14
100063: ST_TO_ADDR
// hc_gallery =  ;
100064: LD_ADDR_OWVAR 33
100068: PUSH
100069: LD_STRING 
100071: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100072: LD_ADDR_OWVAR 35
100076: PUSH
100077: LD_INT 7
100079: NEG
100080: PPUSH
100081: LD_INT 7
100083: PPUSH
100084: CALL_OW 12
100088: ST_TO_ADDR
// animal := CreateHuman ;
100089: LD_ADDR_VAR 0 12
100093: PUSH
100094: CALL_OW 44
100098: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100099: LD_VAR 0 12
100103: PPUSH
100104: LD_VAR 0 8
100108: PPUSH
100109: LD_INT 0
100111: PPUSH
100112: CALL 102025 0 3
// end ;
100116: GO 100053
100118: POP
100119: POP
// if apemans then
100120: LD_VAR 0 3
100124: IFFALSE 100247
// for i = 1 to apemans do
100126: LD_ADDR_VAR 0 11
100130: PUSH
100131: DOUBLE
100132: LD_INT 1
100134: DEC
100135: ST_TO_ADDR
100136: LD_VAR 0 3
100140: PUSH
100141: FOR_TO
100142: IFFALSE 100245
// begin hc_class = class_apeman ;
100144: LD_ADDR_OWVAR 28
100148: PUSH
100149: LD_INT 12
100151: ST_TO_ADDR
// hc_gallery =  ;
100152: LD_ADDR_OWVAR 33
100156: PUSH
100157: LD_STRING 
100159: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
100160: LD_ADDR_OWVAR 35
100164: PUSH
100165: LD_INT 2
100167: NEG
100168: PPUSH
100169: LD_INT 2
100171: PPUSH
100172: CALL_OW 12
100176: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100177: LD_ADDR_OWVAR 31
100181: PUSH
100182: LD_INT 1
100184: PPUSH
100185: LD_INT 3
100187: PPUSH
100188: CALL_OW 12
100192: PUSH
100193: LD_INT 1
100195: PPUSH
100196: LD_INT 3
100198: PPUSH
100199: CALL_OW 12
100203: PUSH
100204: LD_INT 0
100206: PUSH
100207: LD_INT 0
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: ST_TO_ADDR
// animal := CreateHuman ;
100216: LD_ADDR_VAR 0 12
100220: PUSH
100221: CALL_OW 44
100225: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100226: LD_VAR 0 12
100230: PPUSH
100231: LD_VAR 0 8
100235: PPUSH
100236: LD_INT 0
100238: PPUSH
100239: CALL 102025 0 3
// end ;
100243: GO 100141
100245: POP
100246: POP
// if enchidnas then
100247: LD_VAR 0 4
100251: IFFALSE 100318
// for i = 1 to enchidnas do
100253: LD_ADDR_VAR 0 11
100257: PUSH
100258: DOUBLE
100259: LD_INT 1
100261: DEC
100262: ST_TO_ADDR
100263: LD_VAR 0 4
100267: PUSH
100268: FOR_TO
100269: IFFALSE 100316
// begin hc_class = 13 ;
100271: LD_ADDR_OWVAR 28
100275: PUSH
100276: LD_INT 13
100278: ST_TO_ADDR
// hc_gallery =  ;
100279: LD_ADDR_OWVAR 33
100283: PUSH
100284: LD_STRING 
100286: ST_TO_ADDR
// animal := CreateHuman ;
100287: LD_ADDR_VAR 0 12
100291: PUSH
100292: CALL_OW 44
100296: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100297: LD_VAR 0 12
100301: PPUSH
100302: LD_VAR 0 8
100306: PPUSH
100307: LD_INT 0
100309: PPUSH
100310: CALL 102025 0 3
// end ;
100314: GO 100268
100316: POP
100317: POP
// if fishes then
100318: LD_VAR 0 7
100322: IFFALSE 100389
// for i = 1 to fishes do
100324: LD_ADDR_VAR 0 11
100328: PUSH
100329: DOUBLE
100330: LD_INT 1
100332: DEC
100333: ST_TO_ADDR
100334: LD_VAR 0 7
100338: PUSH
100339: FOR_TO
100340: IFFALSE 100387
// begin hc_class = 20 ;
100342: LD_ADDR_OWVAR 28
100346: PUSH
100347: LD_INT 20
100349: ST_TO_ADDR
// hc_gallery =  ;
100350: LD_ADDR_OWVAR 33
100354: PUSH
100355: LD_STRING 
100357: ST_TO_ADDR
// animal := CreateHuman ;
100358: LD_ADDR_VAR 0 12
100362: PUSH
100363: CALL_OW 44
100367: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100368: LD_VAR 0 12
100372: PPUSH
100373: LD_VAR 0 9
100377: PPUSH
100378: LD_INT 0
100380: PPUSH
100381: CALL 102025 0 3
// end ;
100385: GO 100339
100387: POP
100388: POP
// end ;
100389: LD_VAR 0 10
100393: RET
// export function WantHeal ( sci , unit ) ; begin
100394: LD_INT 0
100396: PPUSH
// if GetTaskList ( sci ) > 0 then
100397: LD_VAR 0 1
100401: PPUSH
100402: CALL_OW 437
100406: PUSH
100407: LD_INT 0
100409: GREATER
100410: IFFALSE 100480
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100412: LD_VAR 0 1
100416: PPUSH
100417: CALL_OW 437
100421: PUSH
100422: LD_INT 1
100424: ARRAY
100425: PUSH
100426: LD_INT 1
100428: ARRAY
100429: PUSH
100430: LD_STRING l
100432: EQUAL
100433: PUSH
100434: LD_VAR 0 1
100438: PPUSH
100439: CALL_OW 437
100443: PUSH
100444: LD_INT 1
100446: ARRAY
100447: PUSH
100448: LD_INT 4
100450: ARRAY
100451: PUSH
100452: LD_VAR 0 2
100456: EQUAL
100457: AND
100458: IFFALSE 100470
// result := true else
100460: LD_ADDR_VAR 0 3
100464: PUSH
100465: LD_INT 1
100467: ST_TO_ADDR
100468: GO 100478
// result := false ;
100470: LD_ADDR_VAR 0 3
100474: PUSH
100475: LD_INT 0
100477: ST_TO_ADDR
// end else
100478: GO 100488
// result := false ;
100480: LD_ADDR_VAR 0 3
100484: PUSH
100485: LD_INT 0
100487: ST_TO_ADDR
// end ;
100488: LD_VAR 0 3
100492: RET
// export function HealTarget ( sci ) ; begin
100493: LD_INT 0
100495: PPUSH
// if not sci then
100496: LD_VAR 0 1
100500: NOT
100501: IFFALSE 100505
// exit ;
100503: GO 100570
// result := 0 ;
100505: LD_ADDR_VAR 0 2
100509: PUSH
100510: LD_INT 0
100512: ST_TO_ADDR
// if GetTaskList ( sci ) then
100513: LD_VAR 0 1
100517: PPUSH
100518: CALL_OW 437
100522: IFFALSE 100570
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100524: LD_VAR 0 1
100528: PPUSH
100529: CALL_OW 437
100533: PUSH
100534: LD_INT 1
100536: ARRAY
100537: PUSH
100538: LD_INT 1
100540: ARRAY
100541: PUSH
100542: LD_STRING l
100544: EQUAL
100545: IFFALSE 100570
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100547: LD_ADDR_VAR 0 2
100551: PUSH
100552: LD_VAR 0 1
100556: PPUSH
100557: CALL_OW 437
100561: PUSH
100562: LD_INT 1
100564: ARRAY
100565: PUSH
100566: LD_INT 4
100568: ARRAY
100569: ST_TO_ADDR
// end ;
100570: LD_VAR 0 2
100574: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100575: LD_INT 0
100577: PPUSH
100578: PPUSH
100579: PPUSH
100580: PPUSH
// if not base_units then
100581: LD_VAR 0 1
100585: NOT
100586: IFFALSE 100590
// exit ;
100588: GO 100677
// result := false ;
100590: LD_ADDR_VAR 0 2
100594: PUSH
100595: LD_INT 0
100597: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100598: LD_ADDR_VAR 0 5
100602: PUSH
100603: LD_VAR 0 1
100607: PPUSH
100608: LD_INT 21
100610: PUSH
100611: LD_INT 3
100613: PUSH
100614: EMPTY
100615: LIST
100616: LIST
100617: PPUSH
100618: CALL_OW 72
100622: ST_TO_ADDR
// if not tmp then
100623: LD_VAR 0 5
100627: NOT
100628: IFFALSE 100632
// exit ;
100630: GO 100677
// for i in tmp do
100632: LD_ADDR_VAR 0 3
100636: PUSH
100637: LD_VAR 0 5
100641: PUSH
100642: FOR_IN
100643: IFFALSE 100675
// begin result := EnemyInRange ( i , 22 ) ;
100645: LD_ADDR_VAR 0 2
100649: PUSH
100650: LD_VAR 0 3
100654: PPUSH
100655: LD_INT 22
100657: PPUSH
100658: CALL 98363 0 2
100662: ST_TO_ADDR
// if result then
100663: LD_VAR 0 2
100667: IFFALSE 100673
// exit ;
100669: POP
100670: POP
100671: GO 100677
// end ;
100673: GO 100642
100675: POP
100676: POP
// end ;
100677: LD_VAR 0 2
100681: RET
// export function FilterByTag ( units , tag ) ; begin
100682: LD_INT 0
100684: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
100685: LD_ADDR_VAR 0 3
100689: PUSH
100690: LD_VAR 0 1
100694: PPUSH
100695: LD_INT 120
100697: PUSH
100698: LD_VAR 0 2
100702: PUSH
100703: EMPTY
100704: LIST
100705: LIST
100706: PPUSH
100707: CALL_OW 72
100711: ST_TO_ADDR
// end ;
100712: LD_VAR 0 3
100716: RET
// export function IsDriver ( un ) ; begin
100717: LD_INT 0
100719: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100720: LD_ADDR_VAR 0 2
100724: PUSH
100725: LD_VAR 0 1
100729: PUSH
100730: LD_INT 55
100732: PUSH
100733: EMPTY
100734: LIST
100735: PPUSH
100736: CALL_OW 69
100740: IN
100741: ST_TO_ADDR
// end ;
100742: LD_VAR 0 2
100746: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100747: LD_INT 0
100749: PPUSH
100750: PPUSH
// list := [ ] ;
100751: LD_ADDR_VAR 0 5
100755: PUSH
100756: EMPTY
100757: ST_TO_ADDR
// case d of 0 :
100758: LD_VAR 0 3
100762: PUSH
100763: LD_INT 0
100765: DOUBLE
100766: EQUAL
100767: IFTRUE 100771
100769: GO 100904
100771: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100772: LD_ADDR_VAR 0 5
100776: PUSH
100777: LD_VAR 0 1
100781: PUSH
100782: LD_INT 4
100784: MINUS
100785: PUSH
100786: LD_VAR 0 2
100790: PUSH
100791: LD_INT 4
100793: MINUS
100794: PUSH
100795: LD_INT 2
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: LIST
100802: PUSH
100803: LD_VAR 0 1
100807: PUSH
100808: LD_INT 3
100810: MINUS
100811: PUSH
100812: LD_VAR 0 2
100816: PUSH
100817: LD_INT 1
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: LIST
100824: PUSH
100825: LD_VAR 0 1
100829: PUSH
100830: LD_INT 4
100832: PLUS
100833: PUSH
100834: LD_VAR 0 2
100838: PUSH
100839: LD_INT 4
100841: PUSH
100842: EMPTY
100843: LIST
100844: LIST
100845: LIST
100846: PUSH
100847: LD_VAR 0 1
100851: PUSH
100852: LD_INT 3
100854: PLUS
100855: PUSH
100856: LD_VAR 0 2
100860: PUSH
100861: LD_INT 3
100863: PLUS
100864: PUSH
100865: LD_INT 5
100867: PUSH
100868: EMPTY
100869: LIST
100870: LIST
100871: LIST
100872: PUSH
100873: LD_VAR 0 1
100877: PUSH
100878: LD_VAR 0 2
100882: PUSH
100883: LD_INT 4
100885: PLUS
100886: PUSH
100887: LD_INT 0
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: LIST
100894: PUSH
100895: EMPTY
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: ST_TO_ADDR
// end ; 1 :
100902: GO 101602
100904: LD_INT 1
100906: DOUBLE
100907: EQUAL
100908: IFTRUE 100912
100910: GO 101045
100912: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100913: LD_ADDR_VAR 0 5
100917: PUSH
100918: LD_VAR 0 1
100922: PUSH
100923: LD_VAR 0 2
100927: PUSH
100928: LD_INT 4
100930: MINUS
100931: PUSH
100932: LD_INT 3
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: LIST
100939: PUSH
100940: LD_VAR 0 1
100944: PUSH
100945: LD_INT 3
100947: MINUS
100948: PUSH
100949: LD_VAR 0 2
100953: PUSH
100954: LD_INT 3
100956: MINUS
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: PUSH
100966: LD_VAR 0 1
100970: PUSH
100971: LD_INT 4
100973: MINUS
100974: PUSH
100975: LD_VAR 0 2
100979: PUSH
100980: LD_INT 1
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: LIST
100987: PUSH
100988: LD_VAR 0 1
100992: PUSH
100993: LD_VAR 0 2
100997: PUSH
100998: LD_INT 3
101000: PLUS
101001: PUSH
101002: LD_INT 0
101004: PUSH
101005: EMPTY
101006: LIST
101007: LIST
101008: LIST
101009: PUSH
101010: LD_VAR 0 1
101014: PUSH
101015: LD_INT 4
101017: PLUS
101018: PUSH
101019: LD_VAR 0 2
101023: PUSH
101024: LD_INT 4
101026: PLUS
101027: PUSH
101028: LD_INT 5
101030: PUSH
101031: EMPTY
101032: LIST
101033: LIST
101034: LIST
101035: PUSH
101036: EMPTY
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: ST_TO_ADDR
// end ; 2 :
101043: GO 101602
101045: LD_INT 2
101047: DOUBLE
101048: EQUAL
101049: IFTRUE 101053
101051: GO 101182
101053: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
101054: LD_ADDR_VAR 0 5
101058: PUSH
101059: LD_VAR 0 1
101063: PUSH
101064: LD_VAR 0 2
101068: PUSH
101069: LD_INT 3
101071: MINUS
101072: PUSH
101073: LD_INT 3
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: LIST
101080: PUSH
101081: LD_VAR 0 1
101085: PUSH
101086: LD_INT 4
101088: PLUS
101089: PUSH
101090: LD_VAR 0 2
101094: PUSH
101095: LD_INT 4
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: LIST
101102: PUSH
101103: LD_VAR 0 1
101107: PUSH
101108: LD_VAR 0 2
101112: PUSH
101113: LD_INT 4
101115: PLUS
101116: PUSH
101117: LD_INT 0
101119: PUSH
101120: EMPTY
101121: LIST
101122: LIST
101123: LIST
101124: PUSH
101125: LD_VAR 0 1
101129: PUSH
101130: LD_INT 3
101132: MINUS
101133: PUSH
101134: LD_VAR 0 2
101138: PUSH
101139: LD_INT 1
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: LIST
101146: PUSH
101147: LD_VAR 0 1
101151: PUSH
101152: LD_INT 4
101154: MINUS
101155: PUSH
101156: LD_VAR 0 2
101160: PUSH
101161: LD_INT 4
101163: MINUS
101164: PUSH
101165: LD_INT 2
101167: PUSH
101168: EMPTY
101169: LIST
101170: LIST
101171: LIST
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: ST_TO_ADDR
// end ; 3 :
101180: GO 101602
101182: LD_INT 3
101184: DOUBLE
101185: EQUAL
101186: IFTRUE 101190
101188: GO 101323
101190: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
101191: LD_ADDR_VAR 0 5
101195: PUSH
101196: LD_VAR 0 1
101200: PUSH
101201: LD_INT 3
101203: PLUS
101204: PUSH
101205: LD_VAR 0 2
101209: PUSH
101210: LD_INT 4
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: LIST
101217: PUSH
101218: LD_VAR 0 1
101222: PUSH
101223: LD_INT 4
101225: PLUS
101226: PUSH
101227: LD_VAR 0 2
101231: PUSH
101232: LD_INT 4
101234: PLUS
101235: PUSH
101236: LD_INT 5
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: LIST
101243: PUSH
101244: LD_VAR 0 1
101248: PUSH
101249: LD_INT 4
101251: MINUS
101252: PUSH
101253: LD_VAR 0 2
101257: PUSH
101258: LD_INT 1
101260: PUSH
101261: EMPTY
101262: LIST
101263: LIST
101264: LIST
101265: PUSH
101266: LD_VAR 0 1
101270: PUSH
101271: LD_VAR 0 2
101275: PUSH
101276: LD_INT 4
101278: MINUS
101279: PUSH
101280: LD_INT 3
101282: PUSH
101283: EMPTY
101284: LIST
101285: LIST
101286: LIST
101287: PUSH
101288: LD_VAR 0 1
101292: PUSH
101293: LD_INT 3
101295: MINUS
101296: PUSH
101297: LD_VAR 0 2
101301: PUSH
101302: LD_INT 3
101304: MINUS
101305: PUSH
101306: LD_INT 2
101308: PUSH
101309: EMPTY
101310: LIST
101311: LIST
101312: LIST
101313: PUSH
101314: EMPTY
101315: LIST
101316: LIST
101317: LIST
101318: LIST
101319: LIST
101320: ST_TO_ADDR
// end ; 4 :
101321: GO 101602
101323: LD_INT 4
101325: DOUBLE
101326: EQUAL
101327: IFTRUE 101331
101329: GO 101464
101331: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
101332: LD_ADDR_VAR 0 5
101336: PUSH
101337: LD_VAR 0 1
101341: PUSH
101342: LD_VAR 0 2
101346: PUSH
101347: LD_INT 4
101349: PLUS
101350: PUSH
101351: LD_INT 0
101353: PUSH
101354: EMPTY
101355: LIST
101356: LIST
101357: LIST
101358: PUSH
101359: LD_VAR 0 1
101363: PUSH
101364: LD_INT 3
101366: PLUS
101367: PUSH
101368: LD_VAR 0 2
101372: PUSH
101373: LD_INT 3
101375: PLUS
101376: PUSH
101377: LD_INT 5
101379: PUSH
101380: EMPTY
101381: LIST
101382: LIST
101383: LIST
101384: PUSH
101385: LD_VAR 0 1
101389: PUSH
101390: LD_INT 4
101392: PLUS
101393: PUSH
101394: LD_VAR 0 2
101398: PUSH
101399: LD_INT 4
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: LIST
101406: PUSH
101407: LD_VAR 0 1
101411: PUSH
101412: LD_VAR 0 2
101416: PUSH
101417: LD_INT 3
101419: MINUS
101420: PUSH
101421: LD_INT 3
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: LIST
101428: PUSH
101429: LD_VAR 0 1
101433: PUSH
101434: LD_INT 4
101436: MINUS
101437: PUSH
101438: LD_VAR 0 2
101442: PUSH
101443: LD_INT 4
101445: MINUS
101446: PUSH
101447: LD_INT 2
101449: PUSH
101450: EMPTY
101451: LIST
101452: LIST
101453: LIST
101454: PUSH
101455: EMPTY
101456: LIST
101457: LIST
101458: LIST
101459: LIST
101460: LIST
101461: ST_TO_ADDR
// end ; 5 :
101462: GO 101602
101464: LD_INT 5
101466: DOUBLE
101467: EQUAL
101468: IFTRUE 101472
101470: GO 101601
101472: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
101473: LD_ADDR_VAR 0 5
101477: PUSH
101478: LD_VAR 0 1
101482: PUSH
101483: LD_INT 4
101485: MINUS
101486: PUSH
101487: LD_VAR 0 2
101491: PUSH
101492: LD_INT 1
101494: PUSH
101495: EMPTY
101496: LIST
101497: LIST
101498: LIST
101499: PUSH
101500: LD_VAR 0 1
101504: PUSH
101505: LD_VAR 0 2
101509: PUSH
101510: LD_INT 4
101512: MINUS
101513: PUSH
101514: LD_INT 3
101516: PUSH
101517: EMPTY
101518: LIST
101519: LIST
101520: LIST
101521: PUSH
101522: LD_VAR 0 1
101526: PUSH
101527: LD_INT 4
101529: PLUS
101530: PUSH
101531: LD_VAR 0 2
101535: PUSH
101536: LD_INT 4
101538: PLUS
101539: PUSH
101540: LD_INT 5
101542: PUSH
101543: EMPTY
101544: LIST
101545: LIST
101546: LIST
101547: PUSH
101548: LD_VAR 0 1
101552: PUSH
101553: LD_INT 3
101555: PLUS
101556: PUSH
101557: LD_VAR 0 2
101561: PUSH
101562: LD_INT 4
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: LIST
101569: PUSH
101570: LD_VAR 0 1
101574: PUSH
101575: LD_VAR 0 2
101579: PUSH
101580: LD_INT 3
101582: PLUS
101583: PUSH
101584: LD_INT 0
101586: PUSH
101587: EMPTY
101588: LIST
101589: LIST
101590: LIST
101591: PUSH
101592: EMPTY
101593: LIST
101594: LIST
101595: LIST
101596: LIST
101597: LIST
101598: ST_TO_ADDR
// end ; end ;
101599: GO 101602
101601: POP
// result := list ;
101602: LD_ADDR_VAR 0 4
101606: PUSH
101607: LD_VAR 0 5
101611: ST_TO_ADDR
// end ;
101612: LD_VAR 0 4
101616: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101617: LD_INT 0
101619: PPUSH
101620: PPUSH
101621: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101622: LD_VAR 0 1
101626: NOT
101627: PUSH
101628: LD_VAR 0 2
101632: PUSH
101633: LD_INT 1
101635: PUSH
101636: LD_INT 2
101638: PUSH
101639: LD_INT 3
101641: PUSH
101642: LD_INT 4
101644: PUSH
101645: EMPTY
101646: LIST
101647: LIST
101648: LIST
101649: LIST
101650: IN
101651: NOT
101652: OR
101653: IFFALSE 101657
// exit ;
101655: GO 101749
// tmp := [ ] ;
101657: LD_ADDR_VAR 0 5
101661: PUSH
101662: EMPTY
101663: ST_TO_ADDR
// for i in units do
101664: LD_ADDR_VAR 0 4
101668: PUSH
101669: LD_VAR 0 1
101673: PUSH
101674: FOR_IN
101675: IFFALSE 101718
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101677: LD_ADDR_VAR 0 5
101681: PUSH
101682: LD_VAR 0 5
101686: PPUSH
101687: LD_VAR 0 5
101691: PUSH
101692: LD_INT 1
101694: PLUS
101695: PPUSH
101696: LD_VAR 0 4
101700: PPUSH
101701: LD_VAR 0 2
101705: PPUSH
101706: CALL_OW 259
101710: PPUSH
101711: CALL_OW 2
101715: ST_TO_ADDR
101716: GO 101674
101718: POP
101719: POP
// if not tmp then
101720: LD_VAR 0 5
101724: NOT
101725: IFFALSE 101729
// exit ;
101727: GO 101749
// result := SortListByListDesc ( units , tmp ) ;
101729: LD_ADDR_VAR 0 3
101733: PUSH
101734: LD_VAR 0 1
101738: PPUSH
101739: LD_VAR 0 5
101743: PPUSH
101744: CALL_OW 77
101748: ST_TO_ADDR
// end ;
101749: LD_VAR 0 3
101753: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101754: LD_INT 0
101756: PPUSH
101757: PPUSH
101758: PPUSH
// result := false ;
101759: LD_ADDR_VAR 0 3
101763: PUSH
101764: LD_INT 0
101766: ST_TO_ADDR
// x := GetX ( building ) ;
101767: LD_ADDR_VAR 0 4
101771: PUSH
101772: LD_VAR 0 2
101776: PPUSH
101777: CALL_OW 250
101781: ST_TO_ADDR
// y := GetY ( building ) ;
101782: LD_ADDR_VAR 0 5
101786: PUSH
101787: LD_VAR 0 2
101791: PPUSH
101792: CALL_OW 251
101796: ST_TO_ADDR
// if not building or not x or not y then
101797: LD_VAR 0 2
101801: NOT
101802: PUSH
101803: LD_VAR 0 4
101807: NOT
101808: OR
101809: PUSH
101810: LD_VAR 0 5
101814: NOT
101815: OR
101816: IFFALSE 101820
// exit ;
101818: GO 101912
// if GetTaskList ( unit ) then
101820: LD_VAR 0 1
101824: PPUSH
101825: CALL_OW 437
101829: IFFALSE 101912
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101831: LD_STRING e
101833: PUSH
101834: LD_VAR 0 1
101838: PPUSH
101839: CALL_OW 437
101843: PUSH
101844: LD_INT 1
101846: ARRAY
101847: PUSH
101848: LD_INT 1
101850: ARRAY
101851: EQUAL
101852: PUSH
101853: LD_VAR 0 4
101857: PUSH
101858: LD_VAR 0 1
101862: PPUSH
101863: CALL_OW 437
101867: PUSH
101868: LD_INT 1
101870: ARRAY
101871: PUSH
101872: LD_INT 2
101874: ARRAY
101875: EQUAL
101876: AND
101877: PUSH
101878: LD_VAR 0 5
101882: PUSH
101883: LD_VAR 0 1
101887: PPUSH
101888: CALL_OW 437
101892: PUSH
101893: LD_INT 1
101895: ARRAY
101896: PUSH
101897: LD_INT 3
101899: ARRAY
101900: EQUAL
101901: AND
101902: IFFALSE 101912
// result := true end ;
101904: LD_ADDR_VAR 0 3
101908: PUSH
101909: LD_INT 1
101911: ST_TO_ADDR
// end ;
101912: LD_VAR 0 3
101916: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101917: LD_INT 0
101919: PPUSH
// result := false ;
101920: LD_ADDR_VAR 0 4
101924: PUSH
101925: LD_INT 0
101927: ST_TO_ADDR
// if GetTaskList ( unit ) then
101928: LD_VAR 0 1
101932: PPUSH
101933: CALL_OW 437
101937: IFFALSE 102020
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101939: LD_STRING M
101941: PUSH
101942: LD_VAR 0 1
101946: PPUSH
101947: CALL_OW 437
101951: PUSH
101952: LD_INT 1
101954: ARRAY
101955: PUSH
101956: LD_INT 1
101958: ARRAY
101959: EQUAL
101960: PUSH
101961: LD_VAR 0 2
101965: PUSH
101966: LD_VAR 0 1
101970: PPUSH
101971: CALL_OW 437
101975: PUSH
101976: LD_INT 1
101978: ARRAY
101979: PUSH
101980: LD_INT 2
101982: ARRAY
101983: EQUAL
101984: AND
101985: PUSH
101986: LD_VAR 0 3
101990: PUSH
101991: LD_VAR 0 1
101995: PPUSH
101996: CALL_OW 437
102000: PUSH
102001: LD_INT 1
102003: ARRAY
102004: PUSH
102005: LD_INT 3
102007: ARRAY
102008: EQUAL
102009: AND
102010: IFFALSE 102020
// result := true ;
102012: LD_ADDR_VAR 0 4
102016: PUSH
102017: LD_INT 1
102019: ST_TO_ADDR
// end ; end ;
102020: LD_VAR 0 4
102024: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102025: LD_INT 0
102027: PPUSH
102028: PPUSH
102029: PPUSH
102030: PPUSH
// if not unit or not area then
102031: LD_VAR 0 1
102035: NOT
102036: PUSH
102037: LD_VAR 0 2
102041: NOT
102042: OR
102043: IFFALSE 102047
// exit ;
102045: GO 102211
// tmp := AreaToList ( area , i ) ;
102047: LD_ADDR_VAR 0 6
102051: PUSH
102052: LD_VAR 0 2
102056: PPUSH
102057: LD_VAR 0 5
102061: PPUSH
102062: CALL_OW 517
102066: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102067: LD_ADDR_VAR 0 5
102071: PUSH
102072: DOUBLE
102073: LD_INT 1
102075: DEC
102076: ST_TO_ADDR
102077: LD_VAR 0 6
102081: PUSH
102082: LD_INT 1
102084: ARRAY
102085: PUSH
102086: FOR_TO
102087: IFFALSE 102209
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102089: LD_ADDR_VAR 0 7
102093: PUSH
102094: LD_VAR 0 6
102098: PUSH
102099: LD_INT 1
102101: ARRAY
102102: PUSH
102103: LD_VAR 0 5
102107: ARRAY
102108: PUSH
102109: LD_VAR 0 6
102113: PUSH
102114: LD_INT 2
102116: ARRAY
102117: PUSH
102118: LD_VAR 0 5
102122: ARRAY
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102128: LD_VAR 0 7
102132: PUSH
102133: LD_INT 1
102135: ARRAY
102136: PPUSH
102137: LD_VAR 0 7
102141: PUSH
102142: LD_INT 2
102144: ARRAY
102145: PPUSH
102146: CALL_OW 428
102150: PUSH
102151: LD_INT 0
102153: EQUAL
102154: IFFALSE 102207
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
102156: LD_VAR 0 1
102160: PPUSH
102161: LD_VAR 0 7
102165: PUSH
102166: LD_INT 1
102168: ARRAY
102169: PPUSH
102170: LD_VAR 0 7
102174: PUSH
102175: LD_INT 2
102177: ARRAY
102178: PPUSH
102179: LD_VAR 0 3
102183: PPUSH
102184: CALL_OW 48
// result := IsPlaced ( unit ) ;
102188: LD_ADDR_VAR 0 4
102192: PUSH
102193: LD_VAR 0 1
102197: PPUSH
102198: CALL_OW 305
102202: ST_TO_ADDR
// exit ;
102203: POP
102204: POP
102205: GO 102211
// end ; end ;
102207: GO 102086
102209: POP
102210: POP
// end ;
102211: LD_VAR 0 4
102215: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
102216: LD_INT 0
102218: PPUSH
102219: PPUSH
102220: PPUSH
// if not side or side > 8 then
102221: LD_VAR 0 1
102225: NOT
102226: PUSH
102227: LD_VAR 0 1
102231: PUSH
102232: LD_INT 8
102234: GREATER
102235: OR
102236: IFFALSE 102240
// exit ;
102238: GO 102427
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
102240: LD_ADDR_VAR 0 4
102244: PUSH
102245: LD_INT 22
102247: PUSH
102248: LD_VAR 0 1
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PUSH
102257: LD_INT 21
102259: PUSH
102260: LD_INT 3
102262: PUSH
102263: EMPTY
102264: LIST
102265: LIST
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: PPUSH
102271: CALL_OW 69
102275: ST_TO_ADDR
// if not tmp then
102276: LD_VAR 0 4
102280: NOT
102281: IFFALSE 102285
// exit ;
102283: GO 102427
// enable_addtolog := true ;
102285: LD_ADDR_OWVAR 81
102289: PUSH
102290: LD_INT 1
102292: ST_TO_ADDR
// AddToLog ( [ ) ;
102293: LD_STRING [
102295: PPUSH
102296: CALL_OW 561
// for i in tmp do
102300: LD_ADDR_VAR 0 3
102304: PUSH
102305: LD_VAR 0 4
102309: PUSH
102310: FOR_IN
102311: IFFALSE 102418
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
102313: LD_STRING [
102315: PUSH
102316: LD_VAR 0 3
102320: PPUSH
102321: CALL_OW 266
102325: STR
102326: PUSH
102327: LD_STRING , 
102329: STR
102330: PUSH
102331: LD_VAR 0 3
102335: PPUSH
102336: CALL_OW 250
102340: STR
102341: PUSH
102342: LD_STRING , 
102344: STR
102345: PUSH
102346: LD_VAR 0 3
102350: PPUSH
102351: CALL_OW 251
102355: STR
102356: PUSH
102357: LD_STRING , 
102359: STR
102360: PUSH
102361: LD_VAR 0 3
102365: PPUSH
102366: CALL_OW 254
102370: STR
102371: PUSH
102372: LD_STRING , 
102374: STR
102375: PUSH
102376: LD_VAR 0 3
102380: PPUSH
102381: LD_INT 1
102383: PPUSH
102384: CALL_OW 268
102388: STR
102389: PUSH
102390: LD_STRING , 
102392: STR
102393: PUSH
102394: LD_VAR 0 3
102398: PPUSH
102399: LD_INT 2
102401: PPUSH
102402: CALL_OW 268
102406: STR
102407: PUSH
102408: LD_STRING ],
102410: STR
102411: PPUSH
102412: CALL_OW 561
// end ;
102416: GO 102310
102418: POP
102419: POP
// AddToLog ( ]; ) ;
102420: LD_STRING ];
102422: PPUSH
102423: CALL_OW 561
// end ;
102427: LD_VAR 0 2
102431: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
102432: LD_INT 0
102434: PPUSH
102435: PPUSH
102436: PPUSH
102437: PPUSH
102438: PPUSH
// if not area or not rate or not max then
102439: LD_VAR 0 1
102443: NOT
102444: PUSH
102445: LD_VAR 0 2
102449: NOT
102450: OR
102451: PUSH
102452: LD_VAR 0 4
102456: NOT
102457: OR
102458: IFFALSE 102462
// exit ;
102460: GO 102651
// while 1 do
102462: LD_INT 1
102464: IFFALSE 102651
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
102466: LD_ADDR_VAR 0 9
102470: PUSH
102471: LD_VAR 0 1
102475: PPUSH
102476: LD_INT 1
102478: PPUSH
102479: CALL_OW 287
102483: PUSH
102484: LD_INT 10
102486: MUL
102487: ST_TO_ADDR
// r := rate / 10 ;
102488: LD_ADDR_VAR 0 7
102492: PUSH
102493: LD_VAR 0 2
102497: PUSH
102498: LD_INT 10
102500: DIVREAL
102501: ST_TO_ADDR
// time := 1 1$00 ;
102502: LD_ADDR_VAR 0 8
102506: PUSH
102507: LD_INT 2100
102509: ST_TO_ADDR
// if amount < min then
102510: LD_VAR 0 9
102514: PUSH
102515: LD_VAR 0 3
102519: LESS
102520: IFFALSE 102538
// r := r * 2 else
102522: LD_ADDR_VAR 0 7
102526: PUSH
102527: LD_VAR 0 7
102531: PUSH
102532: LD_INT 2
102534: MUL
102535: ST_TO_ADDR
102536: GO 102564
// if amount > max then
102538: LD_VAR 0 9
102542: PUSH
102543: LD_VAR 0 4
102547: GREATER
102548: IFFALSE 102564
// r := r / 2 ;
102550: LD_ADDR_VAR 0 7
102554: PUSH
102555: LD_VAR 0 7
102559: PUSH
102560: LD_INT 2
102562: DIVREAL
102563: ST_TO_ADDR
// time := time / r ;
102564: LD_ADDR_VAR 0 8
102568: PUSH
102569: LD_VAR 0 8
102573: PUSH
102574: LD_VAR 0 7
102578: DIVREAL
102579: ST_TO_ADDR
// if time < 0 then
102580: LD_VAR 0 8
102584: PUSH
102585: LD_INT 0
102587: LESS
102588: IFFALSE 102605
// time := time * - 1 ;
102590: LD_ADDR_VAR 0 8
102594: PUSH
102595: LD_VAR 0 8
102599: PUSH
102600: LD_INT 1
102602: NEG
102603: MUL
102604: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
102605: LD_VAR 0 8
102609: PUSH
102610: LD_INT 35
102612: PPUSH
102613: LD_INT 875
102615: PPUSH
102616: CALL_OW 12
102620: PLUS
102621: PPUSH
102622: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102626: LD_INT 1
102628: PPUSH
102629: LD_INT 5
102631: PPUSH
102632: CALL_OW 12
102636: PPUSH
102637: LD_VAR 0 1
102641: PPUSH
102642: LD_INT 1
102644: PPUSH
102645: CALL_OW 55
// end ;
102649: GO 102462
// end ;
102651: LD_VAR 0 5
102655: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102656: LD_INT 0
102658: PPUSH
102659: PPUSH
102660: PPUSH
102661: PPUSH
102662: PPUSH
102663: PPUSH
102664: PPUSH
102665: PPUSH
// if not turrets or not factories then
102666: LD_VAR 0 1
102670: NOT
102671: PUSH
102672: LD_VAR 0 2
102676: NOT
102677: OR
102678: IFFALSE 102682
// exit ;
102680: GO 102989
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102682: LD_ADDR_VAR 0 10
102686: PUSH
102687: LD_INT 5
102689: PUSH
102690: LD_INT 6
102692: PUSH
102693: EMPTY
102694: LIST
102695: LIST
102696: PUSH
102697: LD_INT 2
102699: PUSH
102700: LD_INT 4
102702: PUSH
102703: EMPTY
102704: LIST
102705: LIST
102706: PUSH
102707: LD_INT 3
102709: PUSH
102710: LD_INT 5
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PUSH
102717: EMPTY
102718: LIST
102719: LIST
102720: LIST
102721: PUSH
102722: LD_INT 24
102724: PUSH
102725: LD_INT 25
102727: PUSH
102728: EMPTY
102729: LIST
102730: LIST
102731: PUSH
102732: LD_INT 23
102734: PUSH
102735: LD_INT 27
102737: PUSH
102738: EMPTY
102739: LIST
102740: LIST
102741: PUSH
102742: EMPTY
102743: LIST
102744: LIST
102745: PUSH
102746: LD_INT 42
102748: PUSH
102749: LD_INT 43
102751: PUSH
102752: EMPTY
102753: LIST
102754: LIST
102755: PUSH
102756: LD_INT 44
102758: PUSH
102759: LD_INT 46
102761: PUSH
102762: EMPTY
102763: LIST
102764: LIST
102765: PUSH
102766: LD_INT 45
102768: PUSH
102769: LD_INT 47
102771: PUSH
102772: EMPTY
102773: LIST
102774: LIST
102775: PUSH
102776: EMPTY
102777: LIST
102778: LIST
102779: LIST
102780: PUSH
102781: EMPTY
102782: LIST
102783: LIST
102784: LIST
102785: ST_TO_ADDR
// result := [ ] ;
102786: LD_ADDR_VAR 0 3
102790: PUSH
102791: EMPTY
102792: ST_TO_ADDR
// for i in turrets do
102793: LD_ADDR_VAR 0 4
102797: PUSH
102798: LD_VAR 0 1
102802: PUSH
102803: FOR_IN
102804: IFFALSE 102987
// begin nat := GetNation ( i ) ;
102806: LD_ADDR_VAR 0 7
102810: PUSH
102811: LD_VAR 0 4
102815: PPUSH
102816: CALL_OW 248
102820: ST_TO_ADDR
// weapon := 0 ;
102821: LD_ADDR_VAR 0 8
102825: PUSH
102826: LD_INT 0
102828: ST_TO_ADDR
// if not nat then
102829: LD_VAR 0 7
102833: NOT
102834: IFFALSE 102838
// continue ;
102836: GO 102803
// for j in list [ nat ] do
102838: LD_ADDR_VAR 0 5
102842: PUSH
102843: LD_VAR 0 10
102847: PUSH
102848: LD_VAR 0 7
102852: ARRAY
102853: PUSH
102854: FOR_IN
102855: IFFALSE 102896
// if GetBWeapon ( i ) = j [ 1 ] then
102857: LD_VAR 0 4
102861: PPUSH
102862: CALL_OW 269
102866: PUSH
102867: LD_VAR 0 5
102871: PUSH
102872: LD_INT 1
102874: ARRAY
102875: EQUAL
102876: IFFALSE 102894
// begin weapon := j [ 2 ] ;
102878: LD_ADDR_VAR 0 8
102882: PUSH
102883: LD_VAR 0 5
102887: PUSH
102888: LD_INT 2
102890: ARRAY
102891: ST_TO_ADDR
// break ;
102892: GO 102896
// end ;
102894: GO 102854
102896: POP
102897: POP
// if not weapon then
102898: LD_VAR 0 8
102902: NOT
102903: IFFALSE 102907
// continue ;
102905: GO 102803
// for k in factories do
102907: LD_ADDR_VAR 0 6
102911: PUSH
102912: LD_VAR 0 2
102916: PUSH
102917: FOR_IN
102918: IFFALSE 102983
// begin weapons := AvailableWeaponList ( k ) ;
102920: LD_ADDR_VAR 0 9
102924: PUSH
102925: LD_VAR 0 6
102929: PPUSH
102930: CALL_OW 478
102934: ST_TO_ADDR
// if not weapons then
102935: LD_VAR 0 9
102939: NOT
102940: IFFALSE 102944
// continue ;
102942: GO 102917
// if weapon in weapons then
102944: LD_VAR 0 8
102948: PUSH
102949: LD_VAR 0 9
102953: IN
102954: IFFALSE 102981
// begin result := [ i , weapon ] ;
102956: LD_ADDR_VAR 0 3
102960: PUSH
102961: LD_VAR 0 4
102965: PUSH
102966: LD_VAR 0 8
102970: PUSH
102971: EMPTY
102972: LIST
102973: LIST
102974: ST_TO_ADDR
// exit ;
102975: POP
102976: POP
102977: POP
102978: POP
102979: GO 102989
// end ; end ;
102981: GO 102917
102983: POP
102984: POP
// end ;
102985: GO 102803
102987: POP
102988: POP
// end ;
102989: LD_VAR 0 3
102993: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102994: LD_INT 0
102996: PPUSH
// if not side or side > 8 then
102997: LD_VAR 0 3
103001: NOT
103002: PUSH
103003: LD_VAR 0 3
103007: PUSH
103008: LD_INT 8
103010: GREATER
103011: OR
103012: IFFALSE 103016
// exit ;
103014: GO 103075
// if not range then
103016: LD_VAR 0 4
103020: NOT
103021: IFFALSE 103032
// range := - 12 ;
103023: LD_ADDR_VAR 0 4
103027: PUSH
103028: LD_INT 12
103030: NEG
103031: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103032: LD_VAR 0 1
103036: PPUSH
103037: LD_VAR 0 2
103041: PPUSH
103042: LD_VAR 0 3
103046: PPUSH
103047: LD_VAR 0 4
103051: PPUSH
103052: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103056: LD_VAR 0 1
103060: PPUSH
103061: LD_VAR 0 2
103065: PPUSH
103066: LD_VAR 0 3
103070: PPUSH
103071: CALL_OW 331
// end ;
103075: LD_VAR 0 5
103079: RET
// export function Video ( mode ) ; begin
103080: LD_INT 0
103082: PPUSH
// ingame_video = mode ;
103083: LD_ADDR_OWVAR 52
103087: PUSH
103088: LD_VAR 0 1
103092: ST_TO_ADDR
// interface_hidden = mode ;
103093: LD_ADDR_OWVAR 54
103097: PUSH
103098: LD_VAR 0 1
103102: ST_TO_ADDR
// end ;
103103: LD_VAR 0 2
103107: RET
// export function Join ( array , element ) ; begin
103108: LD_INT 0
103110: PPUSH
// result := Replace ( array , array + 1 , element ) ;
103111: LD_ADDR_VAR 0 3
103115: PUSH
103116: LD_VAR 0 1
103120: PPUSH
103121: LD_VAR 0 1
103125: PUSH
103126: LD_INT 1
103128: PLUS
103129: PPUSH
103130: LD_VAR 0 2
103134: PPUSH
103135: CALL_OW 1
103139: ST_TO_ADDR
// end ;
103140: LD_VAR 0 3
103144: RET
// export function JoinUnion ( array , element ) ; begin
103145: LD_INT 0
103147: PPUSH
// result := array union element ;
103148: LD_ADDR_VAR 0 3
103152: PUSH
103153: LD_VAR 0 1
103157: PUSH
103158: LD_VAR 0 2
103162: UNION
103163: ST_TO_ADDR
// end ;
103164: LD_VAR 0 3
103168: RET
// export function GetBehemoths ( side ) ; begin
103169: LD_INT 0
103171: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
103172: LD_ADDR_VAR 0 2
103176: PUSH
103177: LD_INT 22
103179: PUSH
103180: LD_VAR 0 1
103184: PUSH
103185: EMPTY
103186: LIST
103187: LIST
103188: PUSH
103189: LD_INT 31
103191: PUSH
103192: LD_INT 25
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: PUSH
103199: EMPTY
103200: LIST
103201: LIST
103202: PPUSH
103203: CALL_OW 69
103207: ST_TO_ADDR
// end ;
103208: LD_VAR 0 2
103212: RET
// export function Shuffle ( array ) ; var i , index ; begin
103213: LD_INT 0
103215: PPUSH
103216: PPUSH
103217: PPUSH
// result := [ ] ;
103218: LD_ADDR_VAR 0 2
103222: PUSH
103223: EMPTY
103224: ST_TO_ADDR
// if not array then
103225: LD_VAR 0 1
103229: NOT
103230: IFFALSE 103234
// exit ;
103232: GO 103333
// Randomize ;
103234: CALL_OW 10
// for i = array downto 1 do
103238: LD_ADDR_VAR 0 3
103242: PUSH
103243: DOUBLE
103244: LD_VAR 0 1
103248: INC
103249: ST_TO_ADDR
103250: LD_INT 1
103252: PUSH
103253: FOR_DOWNTO
103254: IFFALSE 103331
// begin index := rand ( 1 , array ) ;
103256: LD_ADDR_VAR 0 4
103260: PUSH
103261: LD_INT 1
103263: PPUSH
103264: LD_VAR 0 1
103268: PPUSH
103269: CALL_OW 12
103273: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
103274: LD_ADDR_VAR 0 2
103278: PUSH
103279: LD_VAR 0 2
103283: PPUSH
103284: LD_VAR 0 2
103288: PUSH
103289: LD_INT 1
103291: PLUS
103292: PPUSH
103293: LD_VAR 0 1
103297: PUSH
103298: LD_VAR 0 4
103302: ARRAY
103303: PPUSH
103304: CALL_OW 2
103308: ST_TO_ADDR
// array := Delete ( array , index ) ;
103309: LD_ADDR_VAR 0 1
103313: PUSH
103314: LD_VAR 0 1
103318: PPUSH
103319: LD_VAR 0 4
103323: PPUSH
103324: CALL_OW 3
103328: ST_TO_ADDR
// end ;
103329: GO 103253
103331: POP
103332: POP
// end ;
103333: LD_VAR 0 2
103337: RET
// export function GetBaseMaterials ( base ) ; begin
103338: LD_INT 0
103340: PPUSH
// result := [ 0 , 0 , 0 ] ;
103341: LD_ADDR_VAR 0 2
103345: PUSH
103346: LD_INT 0
103348: PUSH
103349: LD_INT 0
103351: PUSH
103352: LD_INT 0
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: LIST
103359: ST_TO_ADDR
// if not base then
103360: LD_VAR 0 1
103364: NOT
103365: IFFALSE 103369
// exit ;
103367: GO 103418
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
103369: LD_ADDR_VAR 0 2
103373: PUSH
103374: LD_VAR 0 1
103378: PPUSH
103379: LD_INT 1
103381: PPUSH
103382: CALL_OW 275
103386: PUSH
103387: LD_VAR 0 1
103391: PPUSH
103392: LD_INT 2
103394: PPUSH
103395: CALL_OW 275
103399: PUSH
103400: LD_VAR 0 1
103404: PPUSH
103405: LD_INT 3
103407: PPUSH
103408: CALL_OW 275
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: LIST
103417: ST_TO_ADDR
// end ;
103418: LD_VAR 0 2
103422: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
103423: LD_INT 0
103425: PPUSH
103426: PPUSH
// result := array ;
103427: LD_ADDR_VAR 0 3
103431: PUSH
103432: LD_VAR 0 1
103436: ST_TO_ADDR
// if size >= result then
103437: LD_VAR 0 2
103441: PUSH
103442: LD_VAR 0 3
103446: GREATEREQUAL
103447: IFFALSE 103451
// exit ;
103449: GO 103501
// if size then
103451: LD_VAR 0 2
103455: IFFALSE 103501
// for i := array downto size do
103457: LD_ADDR_VAR 0 4
103461: PUSH
103462: DOUBLE
103463: LD_VAR 0 1
103467: INC
103468: ST_TO_ADDR
103469: LD_VAR 0 2
103473: PUSH
103474: FOR_DOWNTO
103475: IFFALSE 103499
// result := Delete ( result , result ) ;
103477: LD_ADDR_VAR 0 3
103481: PUSH
103482: LD_VAR 0 3
103486: PPUSH
103487: LD_VAR 0 3
103491: PPUSH
103492: CALL_OW 3
103496: ST_TO_ADDR
103497: GO 103474
103499: POP
103500: POP
// end ;
103501: LD_VAR 0 3
103505: RET
// export function ComExit ( unit ) ; var tmp ; begin
103506: LD_INT 0
103508: PPUSH
103509: PPUSH
// if not IsInUnit ( unit ) then
103510: LD_VAR 0 1
103514: PPUSH
103515: CALL_OW 310
103519: NOT
103520: IFFALSE 103524
// exit ;
103522: GO 103584
// tmp := IsInUnit ( unit ) ;
103524: LD_ADDR_VAR 0 3
103528: PUSH
103529: LD_VAR 0 1
103533: PPUSH
103534: CALL_OW 310
103538: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103539: LD_VAR 0 3
103543: PPUSH
103544: CALL_OW 247
103548: PUSH
103549: LD_INT 2
103551: EQUAL
103552: IFFALSE 103565
// ComExitVehicle ( unit ) else
103554: LD_VAR 0 1
103558: PPUSH
103559: CALL_OW 121
103563: GO 103574
// ComExitBuilding ( unit ) ;
103565: LD_VAR 0 1
103569: PPUSH
103570: CALL_OW 122
// result := tmp ;
103574: LD_ADDR_VAR 0 2
103578: PUSH
103579: LD_VAR 0 3
103583: ST_TO_ADDR
// end ;
103584: LD_VAR 0 2
103588: RET
// export function ComExitAll ( units ) ; var i ; begin
103589: LD_INT 0
103591: PPUSH
103592: PPUSH
// if not units then
103593: LD_VAR 0 1
103597: NOT
103598: IFFALSE 103602
// exit ;
103600: GO 103628
// for i in units do
103602: LD_ADDR_VAR 0 3
103606: PUSH
103607: LD_VAR 0 1
103611: PUSH
103612: FOR_IN
103613: IFFALSE 103626
// ComExit ( i ) ;
103615: LD_VAR 0 3
103619: PPUSH
103620: CALL 103506 0 1
103624: GO 103612
103626: POP
103627: POP
// end ;
103628: LD_VAR 0 2
103632: RET
// export function ResetHc ; begin
103633: LD_INT 0
103635: PPUSH
// InitHc ;
103636: CALL_OW 19
// hc_importance := 0 ;
103640: LD_ADDR_OWVAR 32
103644: PUSH
103645: LD_INT 0
103647: ST_TO_ADDR
// end ;
103648: LD_VAR 0 1
103652: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103653: LD_INT 0
103655: PPUSH
103656: PPUSH
103657: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103658: LD_ADDR_VAR 0 6
103662: PUSH
103663: LD_VAR 0 1
103667: PUSH
103668: LD_VAR 0 3
103672: PLUS
103673: PUSH
103674: LD_INT 2
103676: DIV
103677: ST_TO_ADDR
// if _x < 0 then
103678: LD_VAR 0 6
103682: PUSH
103683: LD_INT 0
103685: LESS
103686: IFFALSE 103703
// _x := _x * - 1 ;
103688: LD_ADDR_VAR 0 6
103692: PUSH
103693: LD_VAR 0 6
103697: PUSH
103698: LD_INT 1
103700: NEG
103701: MUL
103702: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103703: LD_ADDR_VAR 0 7
103707: PUSH
103708: LD_VAR 0 2
103712: PUSH
103713: LD_VAR 0 4
103717: PLUS
103718: PUSH
103719: LD_INT 2
103721: DIV
103722: ST_TO_ADDR
// if _y < 0 then
103723: LD_VAR 0 7
103727: PUSH
103728: LD_INT 0
103730: LESS
103731: IFFALSE 103748
// _y := _y * - 1 ;
103733: LD_ADDR_VAR 0 7
103737: PUSH
103738: LD_VAR 0 7
103742: PUSH
103743: LD_INT 1
103745: NEG
103746: MUL
103747: ST_TO_ADDR
// result := [ _x , _y ] ;
103748: LD_ADDR_VAR 0 5
103752: PUSH
103753: LD_VAR 0 6
103757: PUSH
103758: LD_VAR 0 7
103762: PUSH
103763: EMPTY
103764: LIST
103765: LIST
103766: ST_TO_ADDR
// end ;
103767: LD_VAR 0 5
103771: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103772: LD_INT 0
103774: PPUSH
103775: PPUSH
103776: PPUSH
103777: PPUSH
// task := GetTaskList ( unit ) ;
103778: LD_ADDR_VAR 0 7
103782: PUSH
103783: LD_VAR 0 1
103787: PPUSH
103788: CALL_OW 437
103792: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103793: LD_VAR 0 7
103797: NOT
103798: PUSH
103799: LD_VAR 0 1
103803: PPUSH
103804: LD_VAR 0 2
103808: PPUSH
103809: CALL_OW 308
103813: NOT
103814: AND
103815: IFFALSE 103819
// exit ;
103817: GO 103937
// if IsInArea ( unit , area ) then
103819: LD_VAR 0 1
103823: PPUSH
103824: LD_VAR 0 2
103828: PPUSH
103829: CALL_OW 308
103833: IFFALSE 103851
// begin ComMoveToArea ( unit , goAway ) ;
103835: LD_VAR 0 1
103839: PPUSH
103840: LD_VAR 0 3
103844: PPUSH
103845: CALL_OW 113
// exit ;
103849: GO 103937
// end ; if task [ 1 ] [ 1 ] <> M then
103851: LD_VAR 0 7
103855: PUSH
103856: LD_INT 1
103858: ARRAY
103859: PUSH
103860: LD_INT 1
103862: ARRAY
103863: PUSH
103864: LD_STRING M
103866: NONEQUAL
103867: IFFALSE 103871
// exit ;
103869: GO 103937
// x := task [ 1 ] [ 2 ] ;
103871: LD_ADDR_VAR 0 5
103875: PUSH
103876: LD_VAR 0 7
103880: PUSH
103881: LD_INT 1
103883: ARRAY
103884: PUSH
103885: LD_INT 2
103887: ARRAY
103888: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103889: LD_ADDR_VAR 0 6
103893: PUSH
103894: LD_VAR 0 7
103898: PUSH
103899: LD_INT 1
103901: ARRAY
103902: PUSH
103903: LD_INT 3
103905: ARRAY
103906: ST_TO_ADDR
// if InArea ( x , y , area ) then
103907: LD_VAR 0 5
103911: PPUSH
103912: LD_VAR 0 6
103916: PPUSH
103917: LD_VAR 0 2
103921: PPUSH
103922: CALL_OW 309
103926: IFFALSE 103937
// ComStop ( unit ) ;
103928: LD_VAR 0 1
103932: PPUSH
103933: CALL_OW 141
// end ;
103937: LD_VAR 0 4
103941: RET
// export function Abs ( value ) ; begin
103942: LD_INT 0
103944: PPUSH
// result := value ;
103945: LD_ADDR_VAR 0 2
103949: PUSH
103950: LD_VAR 0 1
103954: ST_TO_ADDR
// if value < 0 then
103955: LD_VAR 0 1
103959: PUSH
103960: LD_INT 0
103962: LESS
103963: IFFALSE 103980
// result := value * - 1 ;
103965: LD_ADDR_VAR 0 2
103969: PUSH
103970: LD_VAR 0 1
103974: PUSH
103975: LD_INT 1
103977: NEG
103978: MUL
103979: ST_TO_ADDR
// end ;
103980: LD_VAR 0 2
103984: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103985: LD_INT 0
103987: PPUSH
103988: PPUSH
103989: PPUSH
103990: PPUSH
103991: PPUSH
103992: PPUSH
103993: PPUSH
103994: PPUSH
// if not unit or not building then
103995: LD_VAR 0 1
103999: NOT
104000: PUSH
104001: LD_VAR 0 2
104005: NOT
104006: OR
104007: IFFALSE 104011
// exit ;
104009: GO 104237
// x := GetX ( building ) ;
104011: LD_ADDR_VAR 0 4
104015: PUSH
104016: LD_VAR 0 2
104020: PPUSH
104021: CALL_OW 250
104025: ST_TO_ADDR
// y := GetY ( building ) ;
104026: LD_ADDR_VAR 0 6
104030: PUSH
104031: LD_VAR 0 2
104035: PPUSH
104036: CALL_OW 251
104040: ST_TO_ADDR
// d := GetDir ( building ) ;
104041: LD_ADDR_VAR 0 8
104045: PUSH
104046: LD_VAR 0 2
104050: PPUSH
104051: CALL_OW 254
104055: ST_TO_ADDR
// r := 4 ;
104056: LD_ADDR_VAR 0 9
104060: PUSH
104061: LD_INT 4
104063: ST_TO_ADDR
// for i := 1 to 5 do
104064: LD_ADDR_VAR 0 10
104068: PUSH
104069: DOUBLE
104070: LD_INT 1
104072: DEC
104073: ST_TO_ADDR
104074: LD_INT 5
104076: PUSH
104077: FOR_TO
104078: IFFALSE 104235
// begin _x := ShiftX ( x , d , r + i ) ;
104080: LD_ADDR_VAR 0 5
104084: PUSH
104085: LD_VAR 0 4
104089: PPUSH
104090: LD_VAR 0 8
104094: PPUSH
104095: LD_VAR 0 9
104099: PUSH
104100: LD_VAR 0 10
104104: PLUS
104105: PPUSH
104106: CALL_OW 272
104110: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
104111: LD_ADDR_VAR 0 7
104115: PUSH
104116: LD_VAR 0 6
104120: PPUSH
104121: LD_VAR 0 8
104125: PPUSH
104126: LD_VAR 0 9
104130: PUSH
104131: LD_VAR 0 10
104135: PLUS
104136: PPUSH
104137: CALL_OW 273
104141: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
104142: LD_VAR 0 5
104146: PPUSH
104147: LD_VAR 0 7
104151: PPUSH
104152: CALL_OW 488
104156: PUSH
104157: LD_VAR 0 5
104161: PPUSH
104162: LD_VAR 0 7
104166: PPUSH
104167: CALL_OW 428
104171: PPUSH
104172: CALL_OW 247
104176: PUSH
104177: LD_INT 3
104179: PUSH
104180: LD_INT 2
104182: PUSH
104183: EMPTY
104184: LIST
104185: LIST
104186: IN
104187: NOT
104188: AND
104189: IFFALSE 104233
// begin ComMoveXY ( unit , _x , _y ) ;
104191: LD_VAR 0 1
104195: PPUSH
104196: LD_VAR 0 5
104200: PPUSH
104201: LD_VAR 0 7
104205: PPUSH
104206: CALL_OW 111
// result := [ _x , _y ] ;
104210: LD_ADDR_VAR 0 3
104214: PUSH
104215: LD_VAR 0 5
104219: PUSH
104220: LD_VAR 0 7
104224: PUSH
104225: EMPTY
104226: LIST
104227: LIST
104228: ST_TO_ADDR
// exit ;
104229: POP
104230: POP
104231: GO 104237
// end ; end ;
104233: GO 104077
104235: POP
104236: POP
// end ;
104237: LD_VAR 0 3
104241: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
104242: LD_INT 0
104244: PPUSH
104245: PPUSH
104246: PPUSH
// result := 0 ;
104247: LD_ADDR_VAR 0 3
104251: PUSH
104252: LD_INT 0
104254: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
104255: LD_VAR 0 1
104259: PUSH
104260: LD_INT 0
104262: LESS
104263: PUSH
104264: LD_VAR 0 1
104268: PUSH
104269: LD_INT 8
104271: GREATER
104272: OR
104273: PUSH
104274: LD_VAR 0 2
104278: PUSH
104279: LD_INT 0
104281: LESS
104282: OR
104283: PUSH
104284: LD_VAR 0 2
104288: PUSH
104289: LD_INT 8
104291: GREATER
104292: OR
104293: IFFALSE 104297
// exit ;
104295: GO 104372
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
104297: LD_ADDR_VAR 0 4
104301: PUSH
104302: LD_INT 22
104304: PUSH
104305: LD_VAR 0 2
104309: PUSH
104310: EMPTY
104311: LIST
104312: LIST
104313: PPUSH
104314: CALL_OW 69
104318: PUSH
104319: FOR_IN
104320: IFFALSE 104370
// begin un := UnitShoot ( i ) ;
104322: LD_ADDR_VAR 0 5
104326: PUSH
104327: LD_VAR 0 4
104331: PPUSH
104332: CALL_OW 504
104336: ST_TO_ADDR
// if GetSide ( un ) = side1 then
104337: LD_VAR 0 5
104341: PPUSH
104342: CALL_OW 255
104346: PUSH
104347: LD_VAR 0 1
104351: EQUAL
104352: IFFALSE 104368
// begin result := un ;
104354: LD_ADDR_VAR 0 3
104358: PUSH
104359: LD_VAR 0 5
104363: ST_TO_ADDR
// exit ;
104364: POP
104365: POP
104366: GO 104372
// end ; end ;
104368: GO 104319
104370: POP
104371: POP
// end ;
104372: LD_VAR 0 3
104376: RET
// export function GetCargoBay ( units ) ; begin
104377: LD_INT 0
104379: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
104380: LD_ADDR_VAR 0 2
104384: PUSH
104385: LD_VAR 0 1
104389: PPUSH
104390: LD_INT 2
104392: PUSH
104393: LD_INT 34
104395: PUSH
104396: LD_INT 12
104398: PUSH
104399: EMPTY
104400: LIST
104401: LIST
104402: PUSH
104403: LD_INT 34
104405: PUSH
104406: LD_INT 51
104408: PUSH
104409: EMPTY
104410: LIST
104411: LIST
104412: PUSH
104413: LD_INT 34
104415: PUSH
104416: LD_INT 32
104418: PUSH
104419: EMPTY
104420: LIST
104421: LIST
104422: PUSH
104423: LD_INT 34
104425: PUSH
104426: LD_INT 89
104428: PUSH
104429: EMPTY
104430: LIST
104431: LIST
104432: PUSH
104433: EMPTY
104434: LIST
104435: LIST
104436: LIST
104437: LIST
104438: LIST
104439: PPUSH
104440: CALL_OW 72
104444: ST_TO_ADDR
// end ;
104445: LD_VAR 0 2
104449: RET
// export function Negate ( value ) ; begin
104450: LD_INT 0
104452: PPUSH
// result := not value ;
104453: LD_ADDR_VAR 0 2
104457: PUSH
104458: LD_VAR 0 1
104462: NOT
104463: ST_TO_ADDR
// end ;
104464: LD_VAR 0 2
104468: RET
// export function Inc ( value ) ; begin
104469: LD_INT 0
104471: PPUSH
// result := value + 1 ;
104472: LD_ADDR_VAR 0 2
104476: PUSH
104477: LD_VAR 0 1
104481: PUSH
104482: LD_INT 1
104484: PLUS
104485: ST_TO_ADDR
// end ;
104486: LD_VAR 0 2
104490: RET
// export function Dec ( value ) ; begin
104491: LD_INT 0
104493: PPUSH
// result := value - 1 ;
104494: LD_ADDR_VAR 0 2
104498: PUSH
104499: LD_VAR 0 1
104503: PUSH
104504: LD_INT 1
104506: MINUS
104507: ST_TO_ADDR
// end ;
104508: LD_VAR 0 2
104512: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
104513: LD_INT 0
104515: PPUSH
104516: PPUSH
104517: PPUSH
104518: PPUSH
104519: PPUSH
104520: PPUSH
104521: PPUSH
104522: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
104523: LD_VAR 0 1
104527: PPUSH
104528: LD_VAR 0 2
104532: PPUSH
104533: CALL_OW 488
104537: NOT
104538: PUSH
104539: LD_VAR 0 3
104543: PPUSH
104544: LD_VAR 0 4
104548: PPUSH
104549: CALL_OW 488
104553: NOT
104554: OR
104555: IFFALSE 104568
// begin result := - 1 ;
104557: LD_ADDR_VAR 0 5
104561: PUSH
104562: LD_INT 1
104564: NEG
104565: ST_TO_ADDR
// exit ;
104566: GO 104803
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
104568: LD_ADDR_VAR 0 12
104572: PUSH
104573: LD_VAR 0 1
104577: PPUSH
104578: LD_VAR 0 2
104582: PPUSH
104583: LD_VAR 0 3
104587: PPUSH
104588: LD_VAR 0 4
104592: PPUSH
104593: CALL 103653 0 4
104597: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
104598: LD_ADDR_VAR 0 11
104602: PUSH
104603: LD_VAR 0 1
104607: PPUSH
104608: LD_VAR 0 2
104612: PPUSH
104613: LD_VAR 0 12
104617: PUSH
104618: LD_INT 1
104620: ARRAY
104621: PPUSH
104622: LD_VAR 0 12
104626: PUSH
104627: LD_INT 2
104629: ARRAY
104630: PPUSH
104631: CALL_OW 298
104635: ST_TO_ADDR
// distance := 9999 ;
104636: LD_ADDR_VAR 0 10
104640: PUSH
104641: LD_INT 9999
104643: ST_TO_ADDR
// for i := 0 to 5 do
104644: LD_ADDR_VAR 0 6
104648: PUSH
104649: DOUBLE
104650: LD_INT 0
104652: DEC
104653: ST_TO_ADDR
104654: LD_INT 5
104656: PUSH
104657: FOR_TO
104658: IFFALSE 104801
// begin _x := ShiftX ( x1 , i , centerDist ) ;
104660: LD_ADDR_VAR 0 7
104664: PUSH
104665: LD_VAR 0 1
104669: PPUSH
104670: LD_VAR 0 6
104674: PPUSH
104675: LD_VAR 0 11
104679: PPUSH
104680: CALL_OW 272
104684: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
104685: LD_ADDR_VAR 0 8
104689: PUSH
104690: LD_VAR 0 2
104694: PPUSH
104695: LD_VAR 0 6
104699: PPUSH
104700: LD_VAR 0 11
104704: PPUSH
104705: CALL_OW 273
104709: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104710: LD_VAR 0 7
104714: PPUSH
104715: LD_VAR 0 8
104719: PPUSH
104720: CALL_OW 488
104724: NOT
104725: IFFALSE 104729
// continue ;
104727: GO 104657
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
104729: LD_ADDR_VAR 0 9
104733: PUSH
104734: LD_VAR 0 12
104738: PUSH
104739: LD_INT 1
104741: ARRAY
104742: PPUSH
104743: LD_VAR 0 12
104747: PUSH
104748: LD_INT 2
104750: ARRAY
104751: PPUSH
104752: LD_VAR 0 7
104756: PPUSH
104757: LD_VAR 0 8
104761: PPUSH
104762: CALL_OW 298
104766: ST_TO_ADDR
// if tmp < distance then
104767: LD_VAR 0 9
104771: PUSH
104772: LD_VAR 0 10
104776: LESS
104777: IFFALSE 104799
// begin result := i ;
104779: LD_ADDR_VAR 0 5
104783: PUSH
104784: LD_VAR 0 6
104788: ST_TO_ADDR
// distance := tmp ;
104789: LD_ADDR_VAR 0 10
104793: PUSH
104794: LD_VAR 0 9
104798: ST_TO_ADDR
// end ; end ;
104799: GO 104657
104801: POP
104802: POP
// end ;
104803: LD_VAR 0 5
104807: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104808: LD_INT 0
104810: PPUSH
104811: PPUSH
// if not driver or not IsInUnit ( driver ) then
104812: LD_VAR 0 1
104816: NOT
104817: PUSH
104818: LD_VAR 0 1
104822: PPUSH
104823: CALL_OW 310
104827: NOT
104828: OR
104829: IFFALSE 104833
// exit ;
104831: GO 104923
// vehicle := IsInUnit ( driver ) ;
104833: LD_ADDR_VAR 0 3
104837: PUSH
104838: LD_VAR 0 1
104842: PPUSH
104843: CALL_OW 310
104847: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104848: LD_VAR 0 1
104852: PPUSH
104853: LD_STRING \
104855: PUSH
104856: LD_INT 0
104858: PUSH
104859: LD_INT 0
104861: PUSH
104862: LD_INT 0
104864: PUSH
104865: LD_INT 0
104867: PUSH
104868: LD_INT 0
104870: PUSH
104871: LD_INT 0
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: LIST
104878: LIST
104879: LIST
104880: LIST
104881: LIST
104882: PUSH
104883: LD_STRING E
104885: PUSH
104886: LD_INT 0
104888: PUSH
104889: LD_INT 0
104891: PUSH
104892: LD_VAR 0 3
104896: PUSH
104897: LD_INT 0
104899: PUSH
104900: LD_INT 0
104902: PUSH
104903: LD_INT 0
104905: PUSH
104906: EMPTY
104907: LIST
104908: LIST
104909: LIST
104910: LIST
104911: LIST
104912: LIST
104913: LIST
104914: PUSH
104915: EMPTY
104916: LIST
104917: LIST
104918: PPUSH
104919: CALL_OW 446
// end ;
104923: LD_VAR 0 2
104927: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104928: LD_INT 0
104930: PPUSH
104931: PPUSH
// if not driver or not IsInUnit ( driver ) then
104932: LD_VAR 0 1
104936: NOT
104937: PUSH
104938: LD_VAR 0 1
104942: PPUSH
104943: CALL_OW 310
104947: NOT
104948: OR
104949: IFFALSE 104953
// exit ;
104951: GO 105043
// vehicle := IsInUnit ( driver ) ;
104953: LD_ADDR_VAR 0 3
104957: PUSH
104958: LD_VAR 0 1
104962: PPUSH
104963: CALL_OW 310
104967: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104968: LD_VAR 0 1
104972: PPUSH
104973: LD_STRING \
104975: PUSH
104976: LD_INT 0
104978: PUSH
104979: LD_INT 0
104981: PUSH
104982: LD_INT 0
104984: PUSH
104985: LD_INT 0
104987: PUSH
104988: LD_INT 0
104990: PUSH
104991: LD_INT 0
104993: PUSH
104994: EMPTY
104995: LIST
104996: LIST
104997: LIST
104998: LIST
104999: LIST
105000: LIST
105001: LIST
105002: PUSH
105003: LD_STRING E
105005: PUSH
105006: LD_INT 0
105008: PUSH
105009: LD_INT 0
105011: PUSH
105012: LD_VAR 0 3
105016: PUSH
105017: LD_INT 0
105019: PUSH
105020: LD_INT 0
105022: PUSH
105023: LD_INT 0
105025: PUSH
105026: EMPTY
105027: LIST
105028: LIST
105029: LIST
105030: LIST
105031: LIST
105032: LIST
105033: LIST
105034: PUSH
105035: EMPTY
105036: LIST
105037: LIST
105038: PPUSH
105039: CALL_OW 447
// end ;
105043: LD_VAR 0 2
105047: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
105048: LD_INT 0
105050: PPUSH
105051: PPUSH
105052: PPUSH
// tmp := [ ] ;
105053: LD_ADDR_VAR 0 5
105057: PUSH
105058: EMPTY
105059: ST_TO_ADDR
// for i in units do
105060: LD_ADDR_VAR 0 4
105064: PUSH
105065: LD_VAR 0 1
105069: PUSH
105070: FOR_IN
105071: IFFALSE 105109
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
105073: LD_ADDR_VAR 0 5
105077: PUSH
105078: LD_VAR 0 5
105082: PPUSH
105083: LD_VAR 0 5
105087: PUSH
105088: LD_INT 1
105090: PLUS
105091: PPUSH
105092: LD_VAR 0 4
105096: PPUSH
105097: CALL_OW 256
105101: PPUSH
105102: CALL_OW 2
105106: ST_TO_ADDR
105107: GO 105070
105109: POP
105110: POP
// if not tmp then
105111: LD_VAR 0 5
105115: NOT
105116: IFFALSE 105120
// exit ;
105118: GO 105168
// if asc then
105120: LD_VAR 0 2
105124: IFFALSE 105148
// result := SortListByListAsc ( units , tmp ) else
105126: LD_ADDR_VAR 0 3
105130: PUSH
105131: LD_VAR 0 1
105135: PPUSH
105136: LD_VAR 0 5
105140: PPUSH
105141: CALL_OW 76
105145: ST_TO_ADDR
105146: GO 105168
// result := SortListByListDesc ( units , tmp ) ;
105148: LD_ADDR_VAR 0 3
105152: PUSH
105153: LD_VAR 0 1
105157: PPUSH
105158: LD_VAR 0 5
105162: PPUSH
105163: CALL_OW 77
105167: ST_TO_ADDR
// end ;
105168: LD_VAR 0 3
105172: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
105173: LD_INT 0
105175: PPUSH
105176: PPUSH
// task := GetTaskList ( mech ) ;
105177: LD_ADDR_VAR 0 4
105181: PUSH
105182: LD_VAR 0 1
105186: PPUSH
105187: CALL_OW 437
105191: ST_TO_ADDR
// if not task then
105192: LD_VAR 0 4
105196: NOT
105197: IFFALSE 105201
// exit ;
105199: GO 105243
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
105201: LD_ADDR_VAR 0 3
105205: PUSH
105206: LD_VAR 0 4
105210: PUSH
105211: LD_INT 1
105213: ARRAY
105214: PUSH
105215: LD_INT 1
105217: ARRAY
105218: PUSH
105219: LD_STRING r
105221: EQUAL
105222: PUSH
105223: LD_VAR 0 4
105227: PUSH
105228: LD_INT 1
105230: ARRAY
105231: PUSH
105232: LD_INT 4
105234: ARRAY
105235: PUSH
105236: LD_VAR 0 2
105240: EQUAL
105241: AND
105242: ST_TO_ADDR
// end ;
105243: LD_VAR 0 3
105247: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
105248: LD_INT 0
105250: PPUSH
// SetDir ( unit , d ) ;
105251: LD_VAR 0 1
105255: PPUSH
105256: LD_VAR 0 4
105260: PPUSH
105261: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
105265: LD_VAR 0 1
105269: PPUSH
105270: LD_VAR 0 2
105274: PPUSH
105275: LD_VAR 0 3
105279: PPUSH
105280: LD_VAR 0 5
105284: PPUSH
105285: CALL_OW 48
// end ;
105289: LD_VAR 0 6
105293: RET
// export function ToNaturalNumber ( number ) ; begin
105294: LD_INT 0
105296: PPUSH
// result := number div 1 ;
105297: LD_ADDR_VAR 0 2
105301: PUSH
105302: LD_VAR 0 1
105306: PUSH
105307: LD_INT 1
105309: DIV
105310: ST_TO_ADDR
// if number < 0 then
105311: LD_VAR 0 1
105315: PUSH
105316: LD_INT 0
105318: LESS
105319: IFFALSE 105329
// result := 0 ;
105321: LD_ADDR_VAR 0 2
105325: PUSH
105326: LD_INT 0
105328: ST_TO_ADDR
// end ;
105329: LD_VAR 0 2
105333: RET
// export function SortByClass ( units , class ) ; var un ; begin
105334: LD_INT 0
105336: PPUSH
105337: PPUSH
// if not units or not class then
105338: LD_VAR 0 1
105342: NOT
105343: PUSH
105344: LD_VAR 0 2
105348: NOT
105349: OR
105350: IFFALSE 105354
// exit ;
105352: GO 105449
// result := [ ] ;
105354: LD_ADDR_VAR 0 3
105358: PUSH
105359: EMPTY
105360: ST_TO_ADDR
// for un in units do
105361: LD_ADDR_VAR 0 4
105365: PUSH
105366: LD_VAR 0 1
105370: PUSH
105371: FOR_IN
105372: IFFALSE 105447
// if GetClass ( un ) = class then
105374: LD_VAR 0 4
105378: PPUSH
105379: CALL_OW 257
105383: PUSH
105384: LD_VAR 0 2
105388: EQUAL
105389: IFFALSE 105416
// result := Insert ( result , 1 , un ) else
105391: LD_ADDR_VAR 0 3
105395: PUSH
105396: LD_VAR 0 3
105400: PPUSH
105401: LD_INT 1
105403: PPUSH
105404: LD_VAR 0 4
105408: PPUSH
105409: CALL_OW 2
105413: ST_TO_ADDR
105414: GO 105445
// result := Replace ( result , result + 1 , un ) ;
105416: LD_ADDR_VAR 0 3
105420: PUSH
105421: LD_VAR 0 3
105425: PPUSH
105426: LD_VAR 0 3
105430: PUSH
105431: LD_INT 1
105433: PLUS
105434: PPUSH
105435: LD_VAR 0 4
105439: PPUSH
105440: CALL_OW 1
105444: ST_TO_ADDR
105445: GO 105371
105447: POP
105448: POP
// end ;
105449: LD_VAR 0 3
105453: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
105454: LD_INT 0
105456: PPUSH
105457: PPUSH
105458: PPUSH
105459: PPUSH
105460: PPUSH
105461: PPUSH
105462: PPUSH
// result := [ ] ;
105463: LD_ADDR_VAR 0 4
105467: PUSH
105468: EMPTY
105469: ST_TO_ADDR
// if x - r < 0 then
105470: LD_VAR 0 1
105474: PUSH
105475: LD_VAR 0 3
105479: MINUS
105480: PUSH
105481: LD_INT 0
105483: LESS
105484: IFFALSE 105496
// min_x := 0 else
105486: LD_ADDR_VAR 0 8
105490: PUSH
105491: LD_INT 0
105493: ST_TO_ADDR
105494: GO 105512
// min_x := x - r ;
105496: LD_ADDR_VAR 0 8
105500: PUSH
105501: LD_VAR 0 1
105505: PUSH
105506: LD_VAR 0 3
105510: MINUS
105511: ST_TO_ADDR
// if y - r < 0 then
105512: LD_VAR 0 2
105516: PUSH
105517: LD_VAR 0 3
105521: MINUS
105522: PUSH
105523: LD_INT 0
105525: LESS
105526: IFFALSE 105538
// min_y := 0 else
105528: LD_ADDR_VAR 0 7
105532: PUSH
105533: LD_INT 0
105535: ST_TO_ADDR
105536: GO 105554
// min_y := y - r ;
105538: LD_ADDR_VAR 0 7
105542: PUSH
105543: LD_VAR 0 2
105547: PUSH
105548: LD_VAR 0 3
105552: MINUS
105553: ST_TO_ADDR
// max_x := x + r ;
105554: LD_ADDR_VAR 0 9
105558: PUSH
105559: LD_VAR 0 1
105563: PUSH
105564: LD_VAR 0 3
105568: PLUS
105569: ST_TO_ADDR
// max_y := y + r ;
105570: LD_ADDR_VAR 0 10
105574: PUSH
105575: LD_VAR 0 2
105579: PUSH
105580: LD_VAR 0 3
105584: PLUS
105585: ST_TO_ADDR
// for _x = min_x to max_x do
105586: LD_ADDR_VAR 0 5
105590: PUSH
105591: DOUBLE
105592: LD_VAR 0 8
105596: DEC
105597: ST_TO_ADDR
105598: LD_VAR 0 9
105602: PUSH
105603: FOR_TO
105604: IFFALSE 105705
// for _y = min_y to max_y do
105606: LD_ADDR_VAR 0 6
105610: PUSH
105611: DOUBLE
105612: LD_VAR 0 7
105616: DEC
105617: ST_TO_ADDR
105618: LD_VAR 0 10
105622: PUSH
105623: FOR_TO
105624: IFFALSE 105701
// begin if not ValidHex ( _x , _y ) then
105626: LD_VAR 0 5
105630: PPUSH
105631: LD_VAR 0 6
105635: PPUSH
105636: CALL_OW 488
105640: NOT
105641: IFFALSE 105645
// continue ;
105643: GO 105623
// if GetResourceTypeXY ( _x , _y ) then
105645: LD_VAR 0 5
105649: PPUSH
105650: LD_VAR 0 6
105654: PPUSH
105655: CALL_OW 283
105659: IFFALSE 105699
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
105661: LD_ADDR_VAR 0 4
105665: PUSH
105666: LD_VAR 0 4
105670: PPUSH
105671: LD_VAR 0 4
105675: PUSH
105676: LD_INT 1
105678: PLUS
105679: PPUSH
105680: LD_VAR 0 5
105684: PUSH
105685: LD_VAR 0 6
105689: PUSH
105690: EMPTY
105691: LIST
105692: LIST
105693: PPUSH
105694: CALL_OW 1
105698: ST_TO_ADDR
// end ;
105699: GO 105623
105701: POP
105702: POP
105703: GO 105603
105705: POP
105706: POP
// end ;
105707: LD_VAR 0 4
105711: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
105712: LD_INT 0
105714: PPUSH
105715: PPUSH
105716: PPUSH
105717: PPUSH
105718: PPUSH
105719: PPUSH
105720: PPUSH
105721: PPUSH
// if not units then
105722: LD_VAR 0 1
105726: NOT
105727: IFFALSE 105731
// exit ;
105729: GO 106255
// result := UnitFilter ( units , [ f_ok ] ) ;
105731: LD_ADDR_VAR 0 3
105735: PUSH
105736: LD_VAR 0 1
105740: PPUSH
105741: LD_INT 50
105743: PUSH
105744: EMPTY
105745: LIST
105746: PPUSH
105747: CALL_OW 72
105751: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105752: LD_ADDR_VAR 0 8
105756: PUSH
105757: LD_VAR 0 1
105761: PUSH
105762: LD_INT 1
105764: ARRAY
105765: PPUSH
105766: CALL_OW 255
105770: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
105771: LD_ADDR_VAR 0 10
105775: PUSH
105776: LD_INT 29
105778: PUSH
105779: LD_INT 91
105781: PUSH
105782: LD_INT 49
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: LIST
105789: ST_TO_ADDR
// if not result then
105790: LD_VAR 0 3
105794: NOT
105795: IFFALSE 105799
// exit ;
105797: GO 106255
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105799: LD_ADDR_VAR 0 5
105803: PUSH
105804: LD_INT 81
105806: PUSH
105807: LD_VAR 0 8
105811: PUSH
105812: EMPTY
105813: LIST
105814: LIST
105815: PPUSH
105816: CALL_OW 69
105820: ST_TO_ADDR
// for i in result do
105821: LD_ADDR_VAR 0 4
105825: PUSH
105826: LD_VAR 0 3
105830: PUSH
105831: FOR_IN
105832: IFFALSE 106253
// begin tag := GetTag ( i ) + 1 ;
105834: LD_ADDR_VAR 0 9
105838: PUSH
105839: LD_VAR 0 4
105843: PPUSH
105844: CALL_OW 110
105848: PUSH
105849: LD_INT 1
105851: PLUS
105852: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
105853: LD_ADDR_VAR 0 7
105857: PUSH
105858: LD_VAR 0 4
105862: PPUSH
105863: CALL_OW 250
105867: PPUSH
105868: LD_VAR 0 4
105872: PPUSH
105873: CALL_OW 251
105877: PPUSH
105878: LD_INT 6
105880: PPUSH
105881: CALL 105454 0 3
105885: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
105886: LD_VAR 0 4
105890: PPUSH
105891: CALL_OW 247
105895: PUSH
105896: LD_INT 2
105898: EQUAL
105899: PUSH
105900: LD_VAR 0 7
105904: AND
105905: PUSH
105906: LD_VAR 0 4
105910: PPUSH
105911: CALL_OW 264
105915: PUSH
105916: LD_VAR 0 10
105920: IN
105921: NOT
105922: AND
105923: IFFALSE 105962
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
105925: LD_VAR 0 4
105929: PPUSH
105930: LD_VAR 0 7
105934: PUSH
105935: LD_INT 1
105937: ARRAY
105938: PUSH
105939: LD_INT 1
105941: ARRAY
105942: PPUSH
105943: LD_VAR 0 7
105947: PUSH
105948: LD_INT 1
105950: ARRAY
105951: PUSH
105952: LD_INT 2
105954: ARRAY
105955: PPUSH
105956: CALL_OW 116
105960: GO 106251
// if path > tag then
105962: LD_VAR 0 2
105966: PUSH
105967: LD_VAR 0 9
105971: GREATER
105972: IFFALSE 106180
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
105974: LD_ADDR_VAR 0 6
105978: PUSH
105979: LD_VAR 0 5
105983: PPUSH
105984: LD_INT 91
105986: PUSH
105987: LD_VAR 0 4
105991: PUSH
105992: LD_INT 8
105994: PUSH
105995: EMPTY
105996: LIST
105997: LIST
105998: LIST
105999: PPUSH
106000: CALL_OW 72
106004: ST_TO_ADDR
// if nearEnemy then
106005: LD_VAR 0 6
106009: IFFALSE 106078
// begin if GetWeapon ( i ) = ru_time_lapser then
106011: LD_VAR 0 4
106015: PPUSH
106016: CALL_OW 264
106020: PUSH
106021: LD_INT 49
106023: EQUAL
106024: IFFALSE 106052
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
106026: LD_VAR 0 4
106030: PPUSH
106031: LD_VAR 0 6
106035: PPUSH
106036: LD_VAR 0 4
106040: PPUSH
106041: CALL_OW 74
106045: PPUSH
106046: CALL_OW 112
106050: GO 106076
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
106052: LD_VAR 0 4
106056: PPUSH
106057: LD_VAR 0 6
106061: PPUSH
106062: LD_VAR 0 4
106066: PPUSH
106067: CALL_OW 74
106071: PPUSH
106072: CALL_OW 115
// end else
106076: GO 106178
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
106078: LD_VAR 0 4
106082: PPUSH
106083: LD_VAR 0 2
106087: PUSH
106088: LD_VAR 0 9
106092: ARRAY
106093: PUSH
106094: LD_INT 1
106096: ARRAY
106097: PPUSH
106098: LD_VAR 0 2
106102: PUSH
106103: LD_VAR 0 9
106107: ARRAY
106108: PUSH
106109: LD_INT 2
106111: ARRAY
106112: PPUSH
106113: CALL_OW 297
106117: PUSH
106118: LD_INT 6
106120: GREATER
106121: IFFALSE 106164
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
106123: LD_VAR 0 4
106127: PPUSH
106128: LD_VAR 0 2
106132: PUSH
106133: LD_VAR 0 9
106137: ARRAY
106138: PUSH
106139: LD_INT 1
106141: ARRAY
106142: PPUSH
106143: LD_VAR 0 2
106147: PUSH
106148: LD_VAR 0 9
106152: ARRAY
106153: PUSH
106154: LD_INT 2
106156: ARRAY
106157: PPUSH
106158: CALL_OW 114
106162: GO 106178
// SetTag ( i , tag ) ;
106164: LD_VAR 0 4
106168: PPUSH
106169: LD_VAR 0 9
106173: PPUSH
106174: CALL_OW 109
// end else
106178: GO 106251
// if enemy then
106180: LD_VAR 0 5
106184: IFFALSE 106251
// begin if GetWeapon ( i ) = ru_time_lapser then
106186: LD_VAR 0 4
106190: PPUSH
106191: CALL_OW 264
106195: PUSH
106196: LD_INT 49
106198: EQUAL
106199: IFFALSE 106227
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106201: LD_VAR 0 4
106205: PPUSH
106206: LD_VAR 0 5
106210: PPUSH
106211: LD_VAR 0 4
106215: PPUSH
106216: CALL_OW 74
106220: PPUSH
106221: CALL_OW 112
106225: GO 106251
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
106227: LD_VAR 0 4
106231: PPUSH
106232: LD_VAR 0 5
106236: PPUSH
106237: LD_VAR 0 4
106241: PPUSH
106242: CALL_OW 74
106246: PPUSH
106247: CALL_OW 115
// end ; end ;
106251: GO 105831
106253: POP
106254: POP
// end ;
106255: LD_VAR 0 3
106259: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
106260: LD_INT 0
106262: PPUSH
106263: PPUSH
106264: PPUSH
// if not unit or IsInUnit ( unit ) then
106265: LD_VAR 0 1
106269: NOT
106270: PUSH
106271: LD_VAR 0 1
106275: PPUSH
106276: CALL_OW 310
106280: OR
106281: IFFALSE 106285
// exit ;
106283: GO 106376
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
106285: LD_ADDR_VAR 0 4
106289: PUSH
106290: LD_VAR 0 1
106294: PPUSH
106295: CALL_OW 250
106299: PPUSH
106300: LD_VAR 0 2
106304: PPUSH
106305: LD_INT 1
106307: PPUSH
106308: CALL_OW 272
106312: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
106313: LD_ADDR_VAR 0 5
106317: PUSH
106318: LD_VAR 0 1
106322: PPUSH
106323: CALL_OW 251
106327: PPUSH
106328: LD_VAR 0 2
106332: PPUSH
106333: LD_INT 1
106335: PPUSH
106336: CALL_OW 273
106340: ST_TO_ADDR
// if ValidHex ( x , y ) then
106341: LD_VAR 0 4
106345: PPUSH
106346: LD_VAR 0 5
106350: PPUSH
106351: CALL_OW 488
106355: IFFALSE 106376
// ComTurnXY ( unit , x , y ) ;
106357: LD_VAR 0 1
106361: PPUSH
106362: LD_VAR 0 4
106366: PPUSH
106367: LD_VAR 0 5
106371: PPUSH
106372: CALL_OW 118
// end ;
106376: LD_VAR 0 3
106380: RET
// export function SeeUnits ( side , units ) ; var i ; begin
106381: LD_INT 0
106383: PPUSH
106384: PPUSH
// result := false ;
106385: LD_ADDR_VAR 0 3
106389: PUSH
106390: LD_INT 0
106392: ST_TO_ADDR
// if not units then
106393: LD_VAR 0 2
106397: NOT
106398: IFFALSE 106402
// exit ;
106400: GO 106447
// for i in units do
106402: LD_ADDR_VAR 0 4
106406: PUSH
106407: LD_VAR 0 2
106411: PUSH
106412: FOR_IN
106413: IFFALSE 106445
// if See ( side , i ) then
106415: LD_VAR 0 1
106419: PPUSH
106420: LD_VAR 0 4
106424: PPUSH
106425: CALL_OW 292
106429: IFFALSE 106443
// begin result := true ;
106431: LD_ADDR_VAR 0 3
106435: PUSH
106436: LD_INT 1
106438: ST_TO_ADDR
// exit ;
106439: POP
106440: POP
106441: GO 106447
// end ;
106443: GO 106412
106445: POP
106446: POP
// end ;
106447: LD_VAR 0 3
106451: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
106452: LD_INT 0
106454: PPUSH
106455: PPUSH
106456: PPUSH
106457: PPUSH
// if not unit or not points then
106458: LD_VAR 0 1
106462: NOT
106463: PUSH
106464: LD_VAR 0 2
106468: NOT
106469: OR
106470: IFFALSE 106474
// exit ;
106472: GO 106564
// dist := 99999 ;
106474: LD_ADDR_VAR 0 5
106478: PUSH
106479: LD_INT 99999
106481: ST_TO_ADDR
// for i in points do
106482: LD_ADDR_VAR 0 4
106486: PUSH
106487: LD_VAR 0 2
106491: PUSH
106492: FOR_IN
106493: IFFALSE 106562
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
106495: LD_ADDR_VAR 0 6
106499: PUSH
106500: LD_VAR 0 1
106504: PPUSH
106505: LD_VAR 0 4
106509: PUSH
106510: LD_INT 1
106512: ARRAY
106513: PPUSH
106514: LD_VAR 0 4
106518: PUSH
106519: LD_INT 2
106521: ARRAY
106522: PPUSH
106523: CALL_OW 297
106527: ST_TO_ADDR
// if tmpDist < dist then
106528: LD_VAR 0 6
106532: PUSH
106533: LD_VAR 0 5
106537: LESS
106538: IFFALSE 106560
// begin result := i ;
106540: LD_ADDR_VAR 0 3
106544: PUSH
106545: LD_VAR 0 4
106549: ST_TO_ADDR
// dist := tmpDist ;
106550: LD_ADDR_VAR 0 5
106554: PUSH
106555: LD_VAR 0 6
106559: ST_TO_ADDR
// end ; end ;
106560: GO 106492
106562: POP
106563: POP
// end ;
106564: LD_VAR 0 3
106568: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
106569: LD_INT 0
106571: PPUSH
// uc_side := side ;
106572: LD_ADDR_OWVAR 20
106576: PUSH
106577: LD_VAR 0 1
106581: ST_TO_ADDR
// uc_nation := 3 ;
106582: LD_ADDR_OWVAR 21
106586: PUSH
106587: LD_INT 3
106589: ST_TO_ADDR
// vc_chassis := 25 ;
106590: LD_ADDR_OWVAR 37
106594: PUSH
106595: LD_INT 25
106597: ST_TO_ADDR
// vc_engine := engine_siberite ;
106598: LD_ADDR_OWVAR 39
106602: PUSH
106603: LD_INT 3
106605: ST_TO_ADDR
// vc_control := control_computer ;
106606: LD_ADDR_OWVAR 38
106610: PUSH
106611: LD_INT 3
106613: ST_TO_ADDR
// vc_weapon := 59 ;
106614: LD_ADDR_OWVAR 40
106618: PUSH
106619: LD_INT 59
106621: ST_TO_ADDR
// result := CreateVehicle ;
106622: LD_ADDR_VAR 0 5
106626: PUSH
106627: CALL_OW 45
106631: ST_TO_ADDR
// SetDir ( result , d ) ;
106632: LD_VAR 0 5
106636: PPUSH
106637: LD_VAR 0 4
106641: PPUSH
106642: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
106646: LD_VAR 0 5
106650: PPUSH
106651: LD_VAR 0 2
106655: PPUSH
106656: LD_VAR 0 3
106660: PPUSH
106661: LD_INT 0
106663: PPUSH
106664: CALL_OW 48
// end ;
106668: LD_VAR 0 5
106672: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
106673: LD_INT 0
106675: PPUSH
106676: PPUSH
106677: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
106678: LD_ADDR_VAR 0 2
106682: PUSH
106683: LD_INT 0
106685: PUSH
106686: LD_INT 0
106688: PUSH
106689: LD_INT 0
106691: PUSH
106692: LD_INT 0
106694: PUSH
106695: EMPTY
106696: LIST
106697: LIST
106698: LIST
106699: LIST
106700: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
106701: LD_VAR 0 1
106705: NOT
106706: PUSH
106707: LD_VAR 0 1
106711: PPUSH
106712: CALL_OW 264
106716: PUSH
106717: LD_INT 12
106719: PUSH
106720: LD_INT 51
106722: PUSH
106723: LD_INT 32
106725: PUSH
106726: LD_INT 89
106728: PUSH
106729: EMPTY
106730: LIST
106731: LIST
106732: LIST
106733: LIST
106734: IN
106735: NOT
106736: OR
106737: IFFALSE 106741
// exit ;
106739: GO 106839
// for i := 1 to 3 do
106741: LD_ADDR_VAR 0 3
106745: PUSH
106746: DOUBLE
106747: LD_INT 1
106749: DEC
106750: ST_TO_ADDR
106751: LD_INT 3
106753: PUSH
106754: FOR_TO
106755: IFFALSE 106837
// begin tmp := GetCargo ( cargo , i ) ;
106757: LD_ADDR_VAR 0 4
106761: PUSH
106762: LD_VAR 0 1
106766: PPUSH
106767: LD_VAR 0 3
106771: PPUSH
106772: CALL_OW 289
106776: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
106777: LD_ADDR_VAR 0 2
106781: PUSH
106782: LD_VAR 0 2
106786: PPUSH
106787: LD_VAR 0 3
106791: PPUSH
106792: LD_VAR 0 4
106796: PPUSH
106797: CALL_OW 1
106801: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
106802: LD_ADDR_VAR 0 2
106806: PUSH
106807: LD_VAR 0 2
106811: PPUSH
106812: LD_INT 4
106814: PPUSH
106815: LD_VAR 0 2
106819: PUSH
106820: LD_INT 4
106822: ARRAY
106823: PUSH
106824: LD_VAR 0 4
106828: PLUS
106829: PPUSH
106830: CALL_OW 1
106834: ST_TO_ADDR
// end ;
106835: GO 106754
106837: POP
106838: POP
// end ;
106839: LD_VAR 0 2
106843: RET
// export function Length ( array ) ; begin
106844: LD_INT 0
106846: PPUSH
// result := array + 0 ;
106847: LD_ADDR_VAR 0 2
106851: PUSH
106852: LD_VAR 0 1
106856: PUSH
106857: LD_INT 0
106859: PLUS
106860: ST_TO_ADDR
// end ;
106861: LD_VAR 0 2
106865: RET
// export function PrepareArray ( array ) ; begin
106866: LD_INT 0
106868: PPUSH
// result := array diff 0 ;
106869: LD_ADDR_VAR 0 2
106873: PUSH
106874: LD_VAR 0 1
106878: PUSH
106879: LD_INT 0
106881: DIFF
106882: ST_TO_ADDR
// if not result [ 1 ] then
106883: LD_VAR 0 2
106887: PUSH
106888: LD_INT 1
106890: ARRAY
106891: NOT
106892: IFFALSE 106912
// result := Delete ( result , 1 ) ;
106894: LD_ADDR_VAR 0 2
106898: PUSH
106899: LD_VAR 0 2
106903: PPUSH
106904: LD_INT 1
106906: PPUSH
106907: CALL_OW 3
106911: ST_TO_ADDR
// end ; end_of_file end_of_file
106912: LD_VAR 0 2
106916: RET
// every 0 0$1 do
106917: GO 106919
106919: DISABLE
// begin enable ;
106920: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
106921: LD_STRING updateTimer(
106923: PUSH
106924: LD_OWVAR 1
106928: STR
106929: PUSH
106930: LD_STRING );
106932: STR
106933: PPUSH
106934: CALL_OW 559
// end ;
106938: END
// export function SOS_MapStart ( ) ; begin
106939: LD_INT 0
106941: PPUSH
// if streamModeActive then
106942: LD_EXP 141
106946: IFFALSE 106955
// DefineStreamItems ( true ) ;
106948: LD_INT 1
106950: PPUSH
106951: CALL 108609 0 1
// UpdateFactoryWaypoints ( ) ;
106955: CALL 121470 0 0
// UpdateWarehouseGatheringPoints ( ) ;
106959: CALL 121727 0 0
// end ;
106963: LD_VAR 0 1
106967: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106968: LD_INT 0
106970: PPUSH
// if p2 = 100 then
106971: LD_VAR 0 2
106975: PUSH
106976: LD_INT 100
106978: EQUAL
106979: IFFALSE 107982
// begin if not StreamModeActive then
106981: LD_EXP 141
106985: NOT
106986: IFFALSE 106996
// StreamModeActive := true ;
106988: LD_ADDR_EXP 141
106992: PUSH
106993: LD_INT 1
106995: ST_TO_ADDR
// if p3 = 0 then
106996: LD_VAR 0 3
107000: PUSH
107001: LD_INT 0
107003: EQUAL
107004: IFFALSE 107010
// InitStreamMode ;
107006: CALL 108145 0 0
// if p3 = 1 then
107010: LD_VAR 0 3
107014: PUSH
107015: LD_INT 1
107017: EQUAL
107018: IFFALSE 107028
// sRocket := true ;
107020: LD_ADDR_EXP 146
107024: PUSH
107025: LD_INT 1
107027: ST_TO_ADDR
// if p3 = 2 then
107028: LD_VAR 0 3
107032: PUSH
107033: LD_INT 2
107035: EQUAL
107036: IFFALSE 107046
// sSpeed := true ;
107038: LD_ADDR_EXP 145
107042: PUSH
107043: LD_INT 1
107045: ST_TO_ADDR
// if p3 = 3 then
107046: LD_VAR 0 3
107050: PUSH
107051: LD_INT 3
107053: EQUAL
107054: IFFALSE 107064
// sEngine := true ;
107056: LD_ADDR_EXP 147
107060: PUSH
107061: LD_INT 1
107063: ST_TO_ADDR
// if p3 = 4 then
107064: LD_VAR 0 3
107068: PUSH
107069: LD_INT 4
107071: EQUAL
107072: IFFALSE 107082
// sSpec := true ;
107074: LD_ADDR_EXP 144
107078: PUSH
107079: LD_INT 1
107081: ST_TO_ADDR
// if p3 = 5 then
107082: LD_VAR 0 3
107086: PUSH
107087: LD_INT 5
107089: EQUAL
107090: IFFALSE 107100
// sLevel := true ;
107092: LD_ADDR_EXP 148
107096: PUSH
107097: LD_INT 1
107099: ST_TO_ADDR
// if p3 = 6 then
107100: LD_VAR 0 3
107104: PUSH
107105: LD_INT 6
107107: EQUAL
107108: IFFALSE 107118
// sArmoury := true ;
107110: LD_ADDR_EXP 149
107114: PUSH
107115: LD_INT 1
107117: ST_TO_ADDR
// if p3 = 7 then
107118: LD_VAR 0 3
107122: PUSH
107123: LD_INT 7
107125: EQUAL
107126: IFFALSE 107136
// sRadar := true ;
107128: LD_ADDR_EXP 150
107132: PUSH
107133: LD_INT 1
107135: ST_TO_ADDR
// if p3 = 8 then
107136: LD_VAR 0 3
107140: PUSH
107141: LD_INT 8
107143: EQUAL
107144: IFFALSE 107154
// sBunker := true ;
107146: LD_ADDR_EXP 151
107150: PUSH
107151: LD_INT 1
107153: ST_TO_ADDR
// if p3 = 9 then
107154: LD_VAR 0 3
107158: PUSH
107159: LD_INT 9
107161: EQUAL
107162: IFFALSE 107172
// sHack := true ;
107164: LD_ADDR_EXP 152
107168: PUSH
107169: LD_INT 1
107171: ST_TO_ADDR
// if p3 = 10 then
107172: LD_VAR 0 3
107176: PUSH
107177: LD_INT 10
107179: EQUAL
107180: IFFALSE 107190
// sFire := true ;
107182: LD_ADDR_EXP 153
107186: PUSH
107187: LD_INT 1
107189: ST_TO_ADDR
// if p3 = 11 then
107190: LD_VAR 0 3
107194: PUSH
107195: LD_INT 11
107197: EQUAL
107198: IFFALSE 107208
// sRefresh := true ;
107200: LD_ADDR_EXP 154
107204: PUSH
107205: LD_INT 1
107207: ST_TO_ADDR
// if p3 = 12 then
107208: LD_VAR 0 3
107212: PUSH
107213: LD_INT 12
107215: EQUAL
107216: IFFALSE 107226
// sExp := true ;
107218: LD_ADDR_EXP 155
107222: PUSH
107223: LD_INT 1
107225: ST_TO_ADDR
// if p3 = 13 then
107226: LD_VAR 0 3
107230: PUSH
107231: LD_INT 13
107233: EQUAL
107234: IFFALSE 107244
// sDepot := true ;
107236: LD_ADDR_EXP 156
107240: PUSH
107241: LD_INT 1
107243: ST_TO_ADDR
// if p3 = 14 then
107244: LD_VAR 0 3
107248: PUSH
107249: LD_INT 14
107251: EQUAL
107252: IFFALSE 107262
// sFlag := true ;
107254: LD_ADDR_EXP 157
107258: PUSH
107259: LD_INT 1
107261: ST_TO_ADDR
// if p3 = 15 then
107262: LD_VAR 0 3
107266: PUSH
107267: LD_INT 15
107269: EQUAL
107270: IFFALSE 107280
// sKamikadze := true ;
107272: LD_ADDR_EXP 165
107276: PUSH
107277: LD_INT 1
107279: ST_TO_ADDR
// if p3 = 16 then
107280: LD_VAR 0 3
107284: PUSH
107285: LD_INT 16
107287: EQUAL
107288: IFFALSE 107298
// sTroll := true ;
107290: LD_ADDR_EXP 166
107294: PUSH
107295: LD_INT 1
107297: ST_TO_ADDR
// if p3 = 17 then
107298: LD_VAR 0 3
107302: PUSH
107303: LD_INT 17
107305: EQUAL
107306: IFFALSE 107316
// sSlow := true ;
107308: LD_ADDR_EXP 167
107312: PUSH
107313: LD_INT 1
107315: ST_TO_ADDR
// if p3 = 18 then
107316: LD_VAR 0 3
107320: PUSH
107321: LD_INT 18
107323: EQUAL
107324: IFFALSE 107334
// sLack := true ;
107326: LD_ADDR_EXP 168
107330: PUSH
107331: LD_INT 1
107333: ST_TO_ADDR
// if p3 = 19 then
107334: LD_VAR 0 3
107338: PUSH
107339: LD_INT 19
107341: EQUAL
107342: IFFALSE 107352
// sTank := true ;
107344: LD_ADDR_EXP 170
107348: PUSH
107349: LD_INT 1
107351: ST_TO_ADDR
// if p3 = 20 then
107352: LD_VAR 0 3
107356: PUSH
107357: LD_INT 20
107359: EQUAL
107360: IFFALSE 107370
// sRemote := true ;
107362: LD_ADDR_EXP 171
107366: PUSH
107367: LD_INT 1
107369: ST_TO_ADDR
// if p3 = 21 then
107370: LD_VAR 0 3
107374: PUSH
107375: LD_INT 21
107377: EQUAL
107378: IFFALSE 107388
// sPowell := true ;
107380: LD_ADDR_EXP 172
107384: PUSH
107385: LD_INT 1
107387: ST_TO_ADDR
// if p3 = 22 then
107388: LD_VAR 0 3
107392: PUSH
107393: LD_INT 22
107395: EQUAL
107396: IFFALSE 107406
// sTeleport := true ;
107398: LD_ADDR_EXP 175
107402: PUSH
107403: LD_INT 1
107405: ST_TO_ADDR
// if p3 = 23 then
107406: LD_VAR 0 3
107410: PUSH
107411: LD_INT 23
107413: EQUAL
107414: IFFALSE 107424
// sOilTower := true ;
107416: LD_ADDR_EXP 177
107420: PUSH
107421: LD_INT 1
107423: ST_TO_ADDR
// if p3 = 24 then
107424: LD_VAR 0 3
107428: PUSH
107429: LD_INT 24
107431: EQUAL
107432: IFFALSE 107442
// sShovel := true ;
107434: LD_ADDR_EXP 178
107438: PUSH
107439: LD_INT 1
107441: ST_TO_ADDR
// if p3 = 25 then
107442: LD_VAR 0 3
107446: PUSH
107447: LD_INT 25
107449: EQUAL
107450: IFFALSE 107460
// sSheik := true ;
107452: LD_ADDR_EXP 179
107456: PUSH
107457: LD_INT 1
107459: ST_TO_ADDR
// if p3 = 26 then
107460: LD_VAR 0 3
107464: PUSH
107465: LD_INT 26
107467: EQUAL
107468: IFFALSE 107478
// sEarthquake := true ;
107470: LD_ADDR_EXP 181
107474: PUSH
107475: LD_INT 1
107477: ST_TO_ADDR
// if p3 = 27 then
107478: LD_VAR 0 3
107482: PUSH
107483: LD_INT 27
107485: EQUAL
107486: IFFALSE 107496
// sAI := true ;
107488: LD_ADDR_EXP 182
107492: PUSH
107493: LD_INT 1
107495: ST_TO_ADDR
// if p3 = 28 then
107496: LD_VAR 0 3
107500: PUSH
107501: LD_INT 28
107503: EQUAL
107504: IFFALSE 107514
// sCargo := true ;
107506: LD_ADDR_EXP 185
107510: PUSH
107511: LD_INT 1
107513: ST_TO_ADDR
// if p3 = 29 then
107514: LD_VAR 0 3
107518: PUSH
107519: LD_INT 29
107521: EQUAL
107522: IFFALSE 107532
// sDLaser := true ;
107524: LD_ADDR_EXP 186
107528: PUSH
107529: LD_INT 1
107531: ST_TO_ADDR
// if p3 = 30 then
107532: LD_VAR 0 3
107536: PUSH
107537: LD_INT 30
107539: EQUAL
107540: IFFALSE 107550
// sExchange := true ;
107542: LD_ADDR_EXP 187
107546: PUSH
107547: LD_INT 1
107549: ST_TO_ADDR
// if p3 = 31 then
107550: LD_VAR 0 3
107554: PUSH
107555: LD_INT 31
107557: EQUAL
107558: IFFALSE 107568
// sFac := true ;
107560: LD_ADDR_EXP 188
107564: PUSH
107565: LD_INT 1
107567: ST_TO_ADDR
// if p3 = 32 then
107568: LD_VAR 0 3
107572: PUSH
107573: LD_INT 32
107575: EQUAL
107576: IFFALSE 107586
// sPower := true ;
107578: LD_ADDR_EXP 189
107582: PUSH
107583: LD_INT 1
107585: ST_TO_ADDR
// if p3 = 33 then
107586: LD_VAR 0 3
107590: PUSH
107591: LD_INT 33
107593: EQUAL
107594: IFFALSE 107604
// sRandom := true ;
107596: LD_ADDR_EXP 190
107600: PUSH
107601: LD_INT 1
107603: ST_TO_ADDR
// if p3 = 34 then
107604: LD_VAR 0 3
107608: PUSH
107609: LD_INT 34
107611: EQUAL
107612: IFFALSE 107622
// sShield := true ;
107614: LD_ADDR_EXP 191
107618: PUSH
107619: LD_INT 1
107621: ST_TO_ADDR
// if p3 = 35 then
107622: LD_VAR 0 3
107626: PUSH
107627: LD_INT 35
107629: EQUAL
107630: IFFALSE 107640
// sTime := true ;
107632: LD_ADDR_EXP 192
107636: PUSH
107637: LD_INT 1
107639: ST_TO_ADDR
// if p3 = 36 then
107640: LD_VAR 0 3
107644: PUSH
107645: LD_INT 36
107647: EQUAL
107648: IFFALSE 107658
// sTools := true ;
107650: LD_ADDR_EXP 193
107654: PUSH
107655: LD_INT 1
107657: ST_TO_ADDR
// if p3 = 101 then
107658: LD_VAR 0 3
107662: PUSH
107663: LD_INT 101
107665: EQUAL
107666: IFFALSE 107676
// sSold := true ;
107668: LD_ADDR_EXP 158
107672: PUSH
107673: LD_INT 1
107675: ST_TO_ADDR
// if p3 = 102 then
107676: LD_VAR 0 3
107680: PUSH
107681: LD_INT 102
107683: EQUAL
107684: IFFALSE 107694
// sDiff := true ;
107686: LD_ADDR_EXP 159
107690: PUSH
107691: LD_INT 1
107693: ST_TO_ADDR
// if p3 = 103 then
107694: LD_VAR 0 3
107698: PUSH
107699: LD_INT 103
107701: EQUAL
107702: IFFALSE 107712
// sFog := true ;
107704: LD_ADDR_EXP 162
107708: PUSH
107709: LD_INT 1
107711: ST_TO_ADDR
// if p3 = 104 then
107712: LD_VAR 0 3
107716: PUSH
107717: LD_INT 104
107719: EQUAL
107720: IFFALSE 107730
// sReset := true ;
107722: LD_ADDR_EXP 163
107726: PUSH
107727: LD_INT 1
107729: ST_TO_ADDR
// if p3 = 105 then
107730: LD_VAR 0 3
107734: PUSH
107735: LD_INT 105
107737: EQUAL
107738: IFFALSE 107748
// sSun := true ;
107740: LD_ADDR_EXP 164
107744: PUSH
107745: LD_INT 1
107747: ST_TO_ADDR
// if p3 = 106 then
107748: LD_VAR 0 3
107752: PUSH
107753: LD_INT 106
107755: EQUAL
107756: IFFALSE 107766
// sTiger := true ;
107758: LD_ADDR_EXP 160
107762: PUSH
107763: LD_INT 1
107765: ST_TO_ADDR
// if p3 = 107 then
107766: LD_VAR 0 3
107770: PUSH
107771: LD_INT 107
107773: EQUAL
107774: IFFALSE 107784
// sBomb := true ;
107776: LD_ADDR_EXP 161
107780: PUSH
107781: LD_INT 1
107783: ST_TO_ADDR
// if p3 = 108 then
107784: LD_VAR 0 3
107788: PUSH
107789: LD_INT 108
107791: EQUAL
107792: IFFALSE 107802
// sWound := true ;
107794: LD_ADDR_EXP 169
107798: PUSH
107799: LD_INT 1
107801: ST_TO_ADDR
// if p3 = 109 then
107802: LD_VAR 0 3
107806: PUSH
107807: LD_INT 109
107809: EQUAL
107810: IFFALSE 107820
// sBetray := true ;
107812: LD_ADDR_EXP 173
107816: PUSH
107817: LD_INT 1
107819: ST_TO_ADDR
// if p3 = 110 then
107820: LD_VAR 0 3
107824: PUSH
107825: LD_INT 110
107827: EQUAL
107828: IFFALSE 107838
// sContamin := true ;
107830: LD_ADDR_EXP 174
107834: PUSH
107835: LD_INT 1
107837: ST_TO_ADDR
// if p3 = 111 then
107838: LD_VAR 0 3
107842: PUSH
107843: LD_INT 111
107845: EQUAL
107846: IFFALSE 107856
// sOil := true ;
107848: LD_ADDR_EXP 176
107852: PUSH
107853: LD_INT 1
107855: ST_TO_ADDR
// if p3 = 112 then
107856: LD_VAR 0 3
107860: PUSH
107861: LD_INT 112
107863: EQUAL
107864: IFFALSE 107874
// sStu := true ;
107866: LD_ADDR_EXP 180
107870: PUSH
107871: LD_INT 1
107873: ST_TO_ADDR
// if p3 = 113 then
107874: LD_VAR 0 3
107878: PUSH
107879: LD_INT 113
107881: EQUAL
107882: IFFALSE 107892
// sBazooka := true ;
107884: LD_ADDR_EXP 183
107888: PUSH
107889: LD_INT 1
107891: ST_TO_ADDR
// if p3 = 114 then
107892: LD_VAR 0 3
107896: PUSH
107897: LD_INT 114
107899: EQUAL
107900: IFFALSE 107910
// sMortar := true ;
107902: LD_ADDR_EXP 184
107906: PUSH
107907: LD_INT 1
107909: ST_TO_ADDR
// if p3 = 115 then
107910: LD_VAR 0 3
107914: PUSH
107915: LD_INT 115
107917: EQUAL
107918: IFFALSE 107928
// sRanger := true ;
107920: LD_ADDR_EXP 194
107924: PUSH
107925: LD_INT 1
107927: ST_TO_ADDR
// if p3 = 116 then
107928: LD_VAR 0 3
107932: PUSH
107933: LD_INT 116
107935: EQUAL
107936: IFFALSE 107946
// sComputer := true ;
107938: LD_ADDR_EXP 195
107942: PUSH
107943: LD_INT 1
107945: ST_TO_ADDR
// if p3 = 117 then
107946: LD_VAR 0 3
107950: PUSH
107951: LD_INT 117
107953: EQUAL
107954: IFFALSE 107964
// s30 := true ;
107956: LD_ADDR_EXP 196
107960: PUSH
107961: LD_INT 1
107963: ST_TO_ADDR
// if p3 = 118 then
107964: LD_VAR 0 3
107968: PUSH
107969: LD_INT 118
107971: EQUAL
107972: IFFALSE 107982
// s60 := true ;
107974: LD_ADDR_EXP 197
107978: PUSH
107979: LD_INT 1
107981: ST_TO_ADDR
// end ; if p2 = 101 then
107982: LD_VAR 0 2
107986: PUSH
107987: LD_INT 101
107989: EQUAL
107990: IFFALSE 108118
// begin case p3 of 1 :
107992: LD_VAR 0 3
107996: PUSH
107997: LD_INT 1
107999: DOUBLE
108000: EQUAL
108001: IFTRUE 108005
108003: GO 108012
108005: POP
// hHackUnlimitedResources ; 2 :
108006: CALL 120216 0 0
108010: GO 108118
108012: LD_INT 2
108014: DOUBLE
108015: EQUAL
108016: IFTRUE 108020
108018: GO 108027
108020: POP
// hHackSetLevel10 ; 3 :
108021: CALL 120349 0 0
108025: GO 108118
108027: LD_INT 3
108029: DOUBLE
108030: EQUAL
108031: IFTRUE 108035
108033: GO 108042
108035: POP
// hHackSetLevel10YourUnits ; 4 :
108036: CALL 120434 0 0
108040: GO 108118
108042: LD_INT 4
108044: DOUBLE
108045: EQUAL
108046: IFTRUE 108050
108048: GO 108057
108050: POP
// hHackInvincible ; 5 :
108051: CALL 120882 0 0
108055: GO 108118
108057: LD_INT 5
108059: DOUBLE
108060: EQUAL
108061: IFTRUE 108065
108063: GO 108072
108065: POP
// hHackInvisible ; 6 :
108066: CALL 120993 0 0
108070: GO 108118
108072: LD_INT 6
108074: DOUBLE
108075: EQUAL
108076: IFTRUE 108080
108078: GO 108087
108080: POP
// hHackChangeYourSide ; 7 :
108081: CALL 121050 0 0
108085: GO 108118
108087: LD_INT 7
108089: DOUBLE
108090: EQUAL
108091: IFTRUE 108095
108093: GO 108102
108095: POP
// hHackChangeUnitSide ; 8 :
108096: CALL 121092 0 0
108100: GO 108118
108102: LD_INT 8
108104: DOUBLE
108105: EQUAL
108106: IFTRUE 108110
108108: GO 108117
108110: POP
// hHackFog ; end ;
108111: CALL 121193 0 0
108115: GO 108118
108117: POP
// end ; end ;
108118: LD_VAR 0 7
108122: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
108123: GO 108125
108125: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108126: LD_STRING initStreamRollete();
108128: PPUSH
108129: CALL_OW 559
// InitStreamMode ;
108133: CALL 108145 0 0
// DefineStreamItems ( false ) ;
108137: LD_INT 0
108139: PPUSH
108140: CALL 108609 0 1
// end ;
108144: END
// function InitStreamMode ; begin
108145: LD_INT 0
108147: PPUSH
// streamModeActive := false ;
108148: LD_ADDR_EXP 141
108152: PUSH
108153: LD_INT 0
108155: ST_TO_ADDR
// normalCounter := 36 ;
108156: LD_ADDR_EXP 142
108160: PUSH
108161: LD_INT 36
108163: ST_TO_ADDR
// hardcoreCounter := 18 ;
108164: LD_ADDR_EXP 143
108168: PUSH
108169: LD_INT 18
108171: ST_TO_ADDR
// sRocket := false ;
108172: LD_ADDR_EXP 146
108176: PUSH
108177: LD_INT 0
108179: ST_TO_ADDR
// sSpeed := false ;
108180: LD_ADDR_EXP 145
108184: PUSH
108185: LD_INT 0
108187: ST_TO_ADDR
// sEngine := false ;
108188: LD_ADDR_EXP 147
108192: PUSH
108193: LD_INT 0
108195: ST_TO_ADDR
// sSpec := false ;
108196: LD_ADDR_EXP 144
108200: PUSH
108201: LD_INT 0
108203: ST_TO_ADDR
// sLevel := false ;
108204: LD_ADDR_EXP 148
108208: PUSH
108209: LD_INT 0
108211: ST_TO_ADDR
// sArmoury := false ;
108212: LD_ADDR_EXP 149
108216: PUSH
108217: LD_INT 0
108219: ST_TO_ADDR
// sRadar := false ;
108220: LD_ADDR_EXP 150
108224: PUSH
108225: LD_INT 0
108227: ST_TO_ADDR
// sBunker := false ;
108228: LD_ADDR_EXP 151
108232: PUSH
108233: LD_INT 0
108235: ST_TO_ADDR
// sHack := false ;
108236: LD_ADDR_EXP 152
108240: PUSH
108241: LD_INT 0
108243: ST_TO_ADDR
// sFire := false ;
108244: LD_ADDR_EXP 153
108248: PUSH
108249: LD_INT 0
108251: ST_TO_ADDR
// sRefresh := false ;
108252: LD_ADDR_EXP 154
108256: PUSH
108257: LD_INT 0
108259: ST_TO_ADDR
// sExp := false ;
108260: LD_ADDR_EXP 155
108264: PUSH
108265: LD_INT 0
108267: ST_TO_ADDR
// sDepot := false ;
108268: LD_ADDR_EXP 156
108272: PUSH
108273: LD_INT 0
108275: ST_TO_ADDR
// sFlag := false ;
108276: LD_ADDR_EXP 157
108280: PUSH
108281: LD_INT 0
108283: ST_TO_ADDR
// sKamikadze := false ;
108284: LD_ADDR_EXP 165
108288: PUSH
108289: LD_INT 0
108291: ST_TO_ADDR
// sTroll := false ;
108292: LD_ADDR_EXP 166
108296: PUSH
108297: LD_INT 0
108299: ST_TO_ADDR
// sSlow := false ;
108300: LD_ADDR_EXP 167
108304: PUSH
108305: LD_INT 0
108307: ST_TO_ADDR
// sLack := false ;
108308: LD_ADDR_EXP 168
108312: PUSH
108313: LD_INT 0
108315: ST_TO_ADDR
// sTank := false ;
108316: LD_ADDR_EXP 170
108320: PUSH
108321: LD_INT 0
108323: ST_TO_ADDR
// sRemote := false ;
108324: LD_ADDR_EXP 171
108328: PUSH
108329: LD_INT 0
108331: ST_TO_ADDR
// sPowell := false ;
108332: LD_ADDR_EXP 172
108336: PUSH
108337: LD_INT 0
108339: ST_TO_ADDR
// sTeleport := false ;
108340: LD_ADDR_EXP 175
108344: PUSH
108345: LD_INT 0
108347: ST_TO_ADDR
// sOilTower := false ;
108348: LD_ADDR_EXP 177
108352: PUSH
108353: LD_INT 0
108355: ST_TO_ADDR
// sShovel := false ;
108356: LD_ADDR_EXP 178
108360: PUSH
108361: LD_INT 0
108363: ST_TO_ADDR
// sSheik := false ;
108364: LD_ADDR_EXP 179
108368: PUSH
108369: LD_INT 0
108371: ST_TO_ADDR
// sEarthquake := false ;
108372: LD_ADDR_EXP 181
108376: PUSH
108377: LD_INT 0
108379: ST_TO_ADDR
// sAI := false ;
108380: LD_ADDR_EXP 182
108384: PUSH
108385: LD_INT 0
108387: ST_TO_ADDR
// sCargo := false ;
108388: LD_ADDR_EXP 185
108392: PUSH
108393: LD_INT 0
108395: ST_TO_ADDR
// sDLaser := false ;
108396: LD_ADDR_EXP 186
108400: PUSH
108401: LD_INT 0
108403: ST_TO_ADDR
// sExchange := false ;
108404: LD_ADDR_EXP 187
108408: PUSH
108409: LD_INT 0
108411: ST_TO_ADDR
// sFac := false ;
108412: LD_ADDR_EXP 188
108416: PUSH
108417: LD_INT 0
108419: ST_TO_ADDR
// sPower := false ;
108420: LD_ADDR_EXP 189
108424: PUSH
108425: LD_INT 0
108427: ST_TO_ADDR
// sRandom := false ;
108428: LD_ADDR_EXP 190
108432: PUSH
108433: LD_INT 0
108435: ST_TO_ADDR
// sShield := false ;
108436: LD_ADDR_EXP 191
108440: PUSH
108441: LD_INT 0
108443: ST_TO_ADDR
// sTime := false ;
108444: LD_ADDR_EXP 192
108448: PUSH
108449: LD_INT 0
108451: ST_TO_ADDR
// sTools := false ;
108452: LD_ADDR_EXP 193
108456: PUSH
108457: LD_INT 0
108459: ST_TO_ADDR
// sSold := false ;
108460: LD_ADDR_EXP 158
108464: PUSH
108465: LD_INT 0
108467: ST_TO_ADDR
// sDiff := false ;
108468: LD_ADDR_EXP 159
108472: PUSH
108473: LD_INT 0
108475: ST_TO_ADDR
// sFog := false ;
108476: LD_ADDR_EXP 162
108480: PUSH
108481: LD_INT 0
108483: ST_TO_ADDR
// sReset := false ;
108484: LD_ADDR_EXP 163
108488: PUSH
108489: LD_INT 0
108491: ST_TO_ADDR
// sSun := false ;
108492: LD_ADDR_EXP 164
108496: PUSH
108497: LD_INT 0
108499: ST_TO_ADDR
// sTiger := false ;
108500: LD_ADDR_EXP 160
108504: PUSH
108505: LD_INT 0
108507: ST_TO_ADDR
// sBomb := false ;
108508: LD_ADDR_EXP 161
108512: PUSH
108513: LD_INT 0
108515: ST_TO_ADDR
// sWound := false ;
108516: LD_ADDR_EXP 169
108520: PUSH
108521: LD_INT 0
108523: ST_TO_ADDR
// sBetray := false ;
108524: LD_ADDR_EXP 173
108528: PUSH
108529: LD_INT 0
108531: ST_TO_ADDR
// sContamin := false ;
108532: LD_ADDR_EXP 174
108536: PUSH
108537: LD_INT 0
108539: ST_TO_ADDR
// sOil := false ;
108540: LD_ADDR_EXP 176
108544: PUSH
108545: LD_INT 0
108547: ST_TO_ADDR
// sStu := false ;
108548: LD_ADDR_EXP 180
108552: PUSH
108553: LD_INT 0
108555: ST_TO_ADDR
// sBazooka := false ;
108556: LD_ADDR_EXP 183
108560: PUSH
108561: LD_INT 0
108563: ST_TO_ADDR
// sMortar := false ;
108564: LD_ADDR_EXP 184
108568: PUSH
108569: LD_INT 0
108571: ST_TO_ADDR
// sRanger := false ;
108572: LD_ADDR_EXP 194
108576: PUSH
108577: LD_INT 0
108579: ST_TO_ADDR
// sComputer := false ;
108580: LD_ADDR_EXP 195
108584: PUSH
108585: LD_INT 0
108587: ST_TO_ADDR
// s30 := false ;
108588: LD_ADDR_EXP 196
108592: PUSH
108593: LD_INT 0
108595: ST_TO_ADDR
// s60 := false ;
108596: LD_ADDR_EXP 197
108600: PUSH
108601: LD_INT 0
108603: ST_TO_ADDR
// end ;
108604: LD_VAR 0 1
108608: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
108609: LD_INT 0
108611: PPUSH
108612: PPUSH
108613: PPUSH
108614: PPUSH
108615: PPUSH
108616: PPUSH
108617: PPUSH
// result := [ ] ;
108618: LD_ADDR_VAR 0 2
108622: PUSH
108623: EMPTY
108624: ST_TO_ADDR
// if campaign_id = 1 then
108625: LD_OWVAR 69
108629: PUSH
108630: LD_INT 1
108632: EQUAL
108633: IFFALSE 111799
// begin case mission_number of 1 :
108635: LD_OWVAR 70
108639: PUSH
108640: LD_INT 1
108642: DOUBLE
108643: EQUAL
108644: IFTRUE 108648
108646: GO 108724
108648: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
108649: LD_ADDR_VAR 0 2
108653: PUSH
108654: LD_INT 2
108656: PUSH
108657: LD_INT 4
108659: PUSH
108660: LD_INT 11
108662: PUSH
108663: LD_INT 12
108665: PUSH
108666: LD_INT 15
108668: PUSH
108669: LD_INT 16
108671: PUSH
108672: LD_INT 22
108674: PUSH
108675: LD_INT 23
108677: PUSH
108678: LD_INT 26
108680: PUSH
108681: EMPTY
108682: LIST
108683: LIST
108684: LIST
108685: LIST
108686: LIST
108687: LIST
108688: LIST
108689: LIST
108690: LIST
108691: PUSH
108692: LD_INT 101
108694: PUSH
108695: LD_INT 102
108697: PUSH
108698: LD_INT 106
108700: PUSH
108701: LD_INT 116
108703: PUSH
108704: LD_INT 117
108706: PUSH
108707: LD_INT 118
108709: PUSH
108710: EMPTY
108711: LIST
108712: LIST
108713: LIST
108714: LIST
108715: LIST
108716: LIST
108717: PUSH
108718: EMPTY
108719: LIST
108720: LIST
108721: ST_TO_ADDR
108722: GO 111797
108724: LD_INT 2
108726: DOUBLE
108727: EQUAL
108728: IFTRUE 108732
108730: GO 108816
108732: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
108733: LD_ADDR_VAR 0 2
108737: PUSH
108738: LD_INT 2
108740: PUSH
108741: LD_INT 4
108743: PUSH
108744: LD_INT 11
108746: PUSH
108747: LD_INT 12
108749: PUSH
108750: LD_INT 15
108752: PUSH
108753: LD_INT 16
108755: PUSH
108756: LD_INT 22
108758: PUSH
108759: LD_INT 23
108761: PUSH
108762: LD_INT 26
108764: PUSH
108765: EMPTY
108766: LIST
108767: LIST
108768: LIST
108769: LIST
108770: LIST
108771: LIST
108772: LIST
108773: LIST
108774: LIST
108775: PUSH
108776: LD_INT 101
108778: PUSH
108779: LD_INT 102
108781: PUSH
108782: LD_INT 105
108784: PUSH
108785: LD_INT 106
108787: PUSH
108788: LD_INT 108
108790: PUSH
108791: LD_INT 116
108793: PUSH
108794: LD_INT 117
108796: PUSH
108797: LD_INT 118
108799: PUSH
108800: EMPTY
108801: LIST
108802: LIST
108803: LIST
108804: LIST
108805: LIST
108806: LIST
108807: LIST
108808: LIST
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: ST_TO_ADDR
108814: GO 111797
108816: LD_INT 3
108818: DOUBLE
108819: EQUAL
108820: IFTRUE 108824
108822: GO 108912
108824: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
108825: LD_ADDR_VAR 0 2
108829: PUSH
108830: LD_INT 2
108832: PUSH
108833: LD_INT 4
108835: PUSH
108836: LD_INT 5
108838: PUSH
108839: LD_INT 11
108841: PUSH
108842: LD_INT 12
108844: PUSH
108845: LD_INT 15
108847: PUSH
108848: LD_INT 16
108850: PUSH
108851: LD_INT 22
108853: PUSH
108854: LD_INT 26
108856: PUSH
108857: LD_INT 36
108859: PUSH
108860: EMPTY
108861: LIST
108862: LIST
108863: LIST
108864: LIST
108865: LIST
108866: LIST
108867: LIST
108868: LIST
108869: LIST
108870: LIST
108871: PUSH
108872: LD_INT 101
108874: PUSH
108875: LD_INT 102
108877: PUSH
108878: LD_INT 105
108880: PUSH
108881: LD_INT 106
108883: PUSH
108884: LD_INT 108
108886: PUSH
108887: LD_INT 116
108889: PUSH
108890: LD_INT 117
108892: PUSH
108893: LD_INT 118
108895: PUSH
108896: EMPTY
108897: LIST
108898: LIST
108899: LIST
108900: LIST
108901: LIST
108902: LIST
108903: LIST
108904: LIST
108905: PUSH
108906: EMPTY
108907: LIST
108908: LIST
108909: ST_TO_ADDR
108910: GO 111797
108912: LD_INT 4
108914: DOUBLE
108915: EQUAL
108916: IFTRUE 108920
108918: GO 109016
108920: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
108921: LD_ADDR_VAR 0 2
108925: PUSH
108926: LD_INT 2
108928: PUSH
108929: LD_INT 4
108931: PUSH
108932: LD_INT 5
108934: PUSH
108935: LD_INT 8
108937: PUSH
108938: LD_INT 11
108940: PUSH
108941: LD_INT 12
108943: PUSH
108944: LD_INT 15
108946: PUSH
108947: LD_INT 16
108949: PUSH
108950: LD_INT 22
108952: PUSH
108953: LD_INT 23
108955: PUSH
108956: LD_INT 26
108958: PUSH
108959: LD_INT 36
108961: PUSH
108962: EMPTY
108963: LIST
108964: LIST
108965: LIST
108966: LIST
108967: LIST
108968: LIST
108969: LIST
108970: LIST
108971: LIST
108972: LIST
108973: LIST
108974: LIST
108975: PUSH
108976: LD_INT 101
108978: PUSH
108979: LD_INT 102
108981: PUSH
108982: LD_INT 105
108984: PUSH
108985: LD_INT 106
108987: PUSH
108988: LD_INT 108
108990: PUSH
108991: LD_INT 116
108993: PUSH
108994: LD_INT 117
108996: PUSH
108997: LD_INT 118
108999: PUSH
109000: EMPTY
109001: LIST
109002: LIST
109003: LIST
109004: LIST
109005: LIST
109006: LIST
109007: LIST
109008: LIST
109009: PUSH
109010: EMPTY
109011: LIST
109012: LIST
109013: ST_TO_ADDR
109014: GO 111797
109016: LD_INT 5
109018: DOUBLE
109019: EQUAL
109020: IFTRUE 109024
109022: GO 109136
109024: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
109025: LD_ADDR_VAR 0 2
109029: PUSH
109030: LD_INT 2
109032: PUSH
109033: LD_INT 4
109035: PUSH
109036: LD_INT 5
109038: PUSH
109039: LD_INT 6
109041: PUSH
109042: LD_INT 8
109044: PUSH
109045: LD_INT 11
109047: PUSH
109048: LD_INT 12
109050: PUSH
109051: LD_INT 15
109053: PUSH
109054: LD_INT 16
109056: PUSH
109057: LD_INT 22
109059: PUSH
109060: LD_INT 23
109062: PUSH
109063: LD_INT 25
109065: PUSH
109066: LD_INT 26
109068: PUSH
109069: LD_INT 36
109071: PUSH
109072: EMPTY
109073: LIST
109074: LIST
109075: LIST
109076: LIST
109077: LIST
109078: LIST
109079: LIST
109080: LIST
109081: LIST
109082: LIST
109083: LIST
109084: LIST
109085: LIST
109086: LIST
109087: PUSH
109088: LD_INT 101
109090: PUSH
109091: LD_INT 102
109093: PUSH
109094: LD_INT 105
109096: PUSH
109097: LD_INT 106
109099: PUSH
109100: LD_INT 108
109102: PUSH
109103: LD_INT 109
109105: PUSH
109106: LD_INT 112
109108: PUSH
109109: LD_INT 116
109111: PUSH
109112: LD_INT 117
109114: PUSH
109115: LD_INT 118
109117: PUSH
109118: EMPTY
109119: LIST
109120: LIST
109121: LIST
109122: LIST
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: ST_TO_ADDR
109134: GO 111797
109136: LD_INT 6
109138: DOUBLE
109139: EQUAL
109140: IFTRUE 109144
109142: GO 109276
109144: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
109145: LD_ADDR_VAR 0 2
109149: PUSH
109150: LD_INT 2
109152: PUSH
109153: LD_INT 4
109155: PUSH
109156: LD_INT 5
109158: PUSH
109159: LD_INT 6
109161: PUSH
109162: LD_INT 8
109164: PUSH
109165: LD_INT 11
109167: PUSH
109168: LD_INT 12
109170: PUSH
109171: LD_INT 15
109173: PUSH
109174: LD_INT 16
109176: PUSH
109177: LD_INT 20
109179: PUSH
109180: LD_INT 21
109182: PUSH
109183: LD_INT 22
109185: PUSH
109186: LD_INT 23
109188: PUSH
109189: LD_INT 25
109191: PUSH
109192: LD_INT 26
109194: PUSH
109195: LD_INT 30
109197: PUSH
109198: LD_INT 31
109200: PUSH
109201: LD_INT 32
109203: PUSH
109204: LD_INT 36
109206: PUSH
109207: EMPTY
109208: LIST
109209: LIST
109210: LIST
109211: LIST
109212: LIST
109213: LIST
109214: LIST
109215: LIST
109216: LIST
109217: LIST
109218: LIST
109219: LIST
109220: LIST
109221: LIST
109222: LIST
109223: LIST
109224: LIST
109225: LIST
109226: LIST
109227: PUSH
109228: LD_INT 101
109230: PUSH
109231: LD_INT 102
109233: PUSH
109234: LD_INT 105
109236: PUSH
109237: LD_INT 106
109239: PUSH
109240: LD_INT 108
109242: PUSH
109243: LD_INT 109
109245: PUSH
109246: LD_INT 112
109248: PUSH
109249: LD_INT 116
109251: PUSH
109252: LD_INT 117
109254: PUSH
109255: LD_INT 118
109257: PUSH
109258: EMPTY
109259: LIST
109260: LIST
109261: LIST
109262: LIST
109263: LIST
109264: LIST
109265: LIST
109266: LIST
109267: LIST
109268: LIST
109269: PUSH
109270: EMPTY
109271: LIST
109272: LIST
109273: ST_TO_ADDR
109274: GO 111797
109276: LD_INT 7
109278: DOUBLE
109279: EQUAL
109280: IFTRUE 109284
109282: GO 109396
109284: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
109285: LD_ADDR_VAR 0 2
109289: PUSH
109290: LD_INT 2
109292: PUSH
109293: LD_INT 4
109295: PUSH
109296: LD_INT 5
109298: PUSH
109299: LD_INT 7
109301: PUSH
109302: LD_INT 11
109304: PUSH
109305: LD_INT 12
109307: PUSH
109308: LD_INT 15
109310: PUSH
109311: LD_INT 16
109313: PUSH
109314: LD_INT 20
109316: PUSH
109317: LD_INT 21
109319: PUSH
109320: LD_INT 22
109322: PUSH
109323: LD_INT 23
109325: PUSH
109326: LD_INT 25
109328: PUSH
109329: LD_INT 26
109331: PUSH
109332: EMPTY
109333: LIST
109334: LIST
109335: LIST
109336: LIST
109337: LIST
109338: LIST
109339: LIST
109340: LIST
109341: LIST
109342: LIST
109343: LIST
109344: LIST
109345: LIST
109346: LIST
109347: PUSH
109348: LD_INT 101
109350: PUSH
109351: LD_INT 102
109353: PUSH
109354: LD_INT 103
109356: PUSH
109357: LD_INT 105
109359: PUSH
109360: LD_INT 106
109362: PUSH
109363: LD_INT 108
109365: PUSH
109366: LD_INT 112
109368: PUSH
109369: LD_INT 116
109371: PUSH
109372: LD_INT 117
109374: PUSH
109375: LD_INT 118
109377: PUSH
109378: EMPTY
109379: LIST
109380: LIST
109381: LIST
109382: LIST
109383: LIST
109384: LIST
109385: LIST
109386: LIST
109387: LIST
109388: LIST
109389: PUSH
109390: EMPTY
109391: LIST
109392: LIST
109393: ST_TO_ADDR
109394: GO 111797
109396: LD_INT 8
109398: DOUBLE
109399: EQUAL
109400: IFTRUE 109404
109402: GO 109544
109404: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
109405: LD_ADDR_VAR 0 2
109409: PUSH
109410: LD_INT 2
109412: PUSH
109413: LD_INT 4
109415: PUSH
109416: LD_INT 5
109418: PUSH
109419: LD_INT 6
109421: PUSH
109422: LD_INT 7
109424: PUSH
109425: LD_INT 8
109427: PUSH
109428: LD_INT 11
109430: PUSH
109431: LD_INT 12
109433: PUSH
109434: LD_INT 15
109436: PUSH
109437: LD_INT 16
109439: PUSH
109440: LD_INT 20
109442: PUSH
109443: LD_INT 21
109445: PUSH
109446: LD_INT 22
109448: PUSH
109449: LD_INT 23
109451: PUSH
109452: LD_INT 25
109454: PUSH
109455: LD_INT 26
109457: PUSH
109458: LD_INT 30
109460: PUSH
109461: LD_INT 31
109463: PUSH
109464: LD_INT 32
109466: PUSH
109467: LD_INT 36
109469: PUSH
109470: EMPTY
109471: LIST
109472: LIST
109473: LIST
109474: LIST
109475: LIST
109476: LIST
109477: LIST
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: PUSH
109492: LD_INT 101
109494: PUSH
109495: LD_INT 102
109497: PUSH
109498: LD_INT 103
109500: PUSH
109501: LD_INT 105
109503: PUSH
109504: LD_INT 106
109506: PUSH
109507: LD_INT 108
109509: PUSH
109510: LD_INT 109
109512: PUSH
109513: LD_INT 112
109515: PUSH
109516: LD_INT 116
109518: PUSH
109519: LD_INT 117
109521: PUSH
109522: LD_INT 118
109524: PUSH
109525: EMPTY
109526: LIST
109527: LIST
109528: LIST
109529: LIST
109530: LIST
109531: LIST
109532: LIST
109533: LIST
109534: LIST
109535: LIST
109536: LIST
109537: PUSH
109538: EMPTY
109539: LIST
109540: LIST
109541: ST_TO_ADDR
109542: GO 111797
109544: LD_INT 9
109546: DOUBLE
109547: EQUAL
109548: IFTRUE 109552
109550: GO 109700
109552: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
109553: LD_ADDR_VAR 0 2
109557: PUSH
109558: LD_INT 2
109560: PUSH
109561: LD_INT 4
109563: PUSH
109564: LD_INT 5
109566: PUSH
109567: LD_INT 6
109569: PUSH
109570: LD_INT 7
109572: PUSH
109573: LD_INT 8
109575: PUSH
109576: LD_INT 11
109578: PUSH
109579: LD_INT 12
109581: PUSH
109582: LD_INT 15
109584: PUSH
109585: LD_INT 16
109587: PUSH
109588: LD_INT 20
109590: PUSH
109591: LD_INT 21
109593: PUSH
109594: LD_INT 22
109596: PUSH
109597: LD_INT 23
109599: PUSH
109600: LD_INT 25
109602: PUSH
109603: LD_INT 26
109605: PUSH
109606: LD_INT 28
109608: PUSH
109609: LD_INT 30
109611: PUSH
109612: LD_INT 31
109614: PUSH
109615: LD_INT 32
109617: PUSH
109618: LD_INT 36
109620: PUSH
109621: EMPTY
109622: LIST
109623: LIST
109624: LIST
109625: LIST
109626: LIST
109627: LIST
109628: LIST
109629: LIST
109630: LIST
109631: LIST
109632: LIST
109633: LIST
109634: LIST
109635: LIST
109636: LIST
109637: LIST
109638: LIST
109639: LIST
109640: LIST
109641: LIST
109642: LIST
109643: PUSH
109644: LD_INT 101
109646: PUSH
109647: LD_INT 102
109649: PUSH
109650: LD_INT 103
109652: PUSH
109653: LD_INT 105
109655: PUSH
109656: LD_INT 106
109658: PUSH
109659: LD_INT 108
109661: PUSH
109662: LD_INT 109
109664: PUSH
109665: LD_INT 112
109667: PUSH
109668: LD_INT 114
109670: PUSH
109671: LD_INT 116
109673: PUSH
109674: LD_INT 117
109676: PUSH
109677: LD_INT 118
109679: PUSH
109680: EMPTY
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: LIST
109687: LIST
109688: LIST
109689: LIST
109690: LIST
109691: LIST
109692: LIST
109693: PUSH
109694: EMPTY
109695: LIST
109696: LIST
109697: ST_TO_ADDR
109698: GO 111797
109700: LD_INT 10
109702: DOUBLE
109703: EQUAL
109704: IFTRUE 109708
109706: GO 109904
109708: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
109709: LD_ADDR_VAR 0 2
109713: PUSH
109714: LD_INT 2
109716: PUSH
109717: LD_INT 4
109719: PUSH
109720: LD_INT 5
109722: PUSH
109723: LD_INT 6
109725: PUSH
109726: LD_INT 7
109728: PUSH
109729: LD_INT 8
109731: PUSH
109732: LD_INT 9
109734: PUSH
109735: LD_INT 10
109737: PUSH
109738: LD_INT 11
109740: PUSH
109741: LD_INT 12
109743: PUSH
109744: LD_INT 13
109746: PUSH
109747: LD_INT 14
109749: PUSH
109750: LD_INT 15
109752: PUSH
109753: LD_INT 16
109755: PUSH
109756: LD_INT 17
109758: PUSH
109759: LD_INT 18
109761: PUSH
109762: LD_INT 19
109764: PUSH
109765: LD_INT 20
109767: PUSH
109768: LD_INT 21
109770: PUSH
109771: LD_INT 22
109773: PUSH
109774: LD_INT 23
109776: PUSH
109777: LD_INT 24
109779: PUSH
109780: LD_INT 25
109782: PUSH
109783: LD_INT 26
109785: PUSH
109786: LD_INT 28
109788: PUSH
109789: LD_INT 30
109791: PUSH
109792: LD_INT 31
109794: PUSH
109795: LD_INT 32
109797: PUSH
109798: LD_INT 36
109800: PUSH
109801: EMPTY
109802: LIST
109803: LIST
109804: LIST
109805: LIST
109806: LIST
109807: LIST
109808: LIST
109809: LIST
109810: LIST
109811: LIST
109812: LIST
109813: LIST
109814: LIST
109815: LIST
109816: LIST
109817: LIST
109818: LIST
109819: LIST
109820: LIST
109821: LIST
109822: LIST
109823: LIST
109824: LIST
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: LIST
109831: PUSH
109832: LD_INT 101
109834: PUSH
109835: LD_INT 102
109837: PUSH
109838: LD_INT 103
109840: PUSH
109841: LD_INT 104
109843: PUSH
109844: LD_INT 105
109846: PUSH
109847: LD_INT 106
109849: PUSH
109850: LD_INT 107
109852: PUSH
109853: LD_INT 108
109855: PUSH
109856: LD_INT 109
109858: PUSH
109859: LD_INT 110
109861: PUSH
109862: LD_INT 111
109864: PUSH
109865: LD_INT 112
109867: PUSH
109868: LD_INT 114
109870: PUSH
109871: LD_INT 116
109873: PUSH
109874: LD_INT 117
109876: PUSH
109877: LD_INT 118
109879: PUSH
109880: EMPTY
109881: LIST
109882: LIST
109883: LIST
109884: LIST
109885: LIST
109886: LIST
109887: LIST
109888: LIST
109889: LIST
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: PUSH
109898: EMPTY
109899: LIST
109900: LIST
109901: ST_TO_ADDR
109902: GO 111797
109904: LD_INT 11
109906: DOUBLE
109907: EQUAL
109908: IFTRUE 109912
109910: GO 110116
109912: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
109913: LD_ADDR_VAR 0 2
109917: PUSH
109918: LD_INT 2
109920: PUSH
109921: LD_INT 3
109923: PUSH
109924: LD_INT 4
109926: PUSH
109927: LD_INT 5
109929: PUSH
109930: LD_INT 6
109932: PUSH
109933: LD_INT 7
109935: PUSH
109936: LD_INT 8
109938: PUSH
109939: LD_INT 9
109941: PUSH
109942: LD_INT 10
109944: PUSH
109945: LD_INT 11
109947: PUSH
109948: LD_INT 12
109950: PUSH
109951: LD_INT 13
109953: PUSH
109954: LD_INT 14
109956: PUSH
109957: LD_INT 15
109959: PUSH
109960: LD_INT 16
109962: PUSH
109963: LD_INT 17
109965: PUSH
109966: LD_INT 18
109968: PUSH
109969: LD_INT 19
109971: PUSH
109972: LD_INT 20
109974: PUSH
109975: LD_INT 21
109977: PUSH
109978: LD_INT 22
109980: PUSH
109981: LD_INT 23
109983: PUSH
109984: LD_INT 24
109986: PUSH
109987: LD_INT 25
109989: PUSH
109990: LD_INT 26
109992: PUSH
109993: LD_INT 28
109995: PUSH
109996: LD_INT 30
109998: PUSH
109999: LD_INT 31
110001: PUSH
110002: LD_INT 32
110004: PUSH
110005: LD_INT 34
110007: PUSH
110008: LD_INT 36
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: LIST
110015: LIST
110016: LIST
110017: LIST
110018: LIST
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: LIST
110039: LIST
110040: LIST
110041: LIST
110042: LIST
110043: PUSH
110044: LD_INT 101
110046: PUSH
110047: LD_INT 102
110049: PUSH
110050: LD_INT 103
110052: PUSH
110053: LD_INT 104
110055: PUSH
110056: LD_INT 105
110058: PUSH
110059: LD_INT 106
110061: PUSH
110062: LD_INT 107
110064: PUSH
110065: LD_INT 108
110067: PUSH
110068: LD_INT 109
110070: PUSH
110071: LD_INT 110
110073: PUSH
110074: LD_INT 111
110076: PUSH
110077: LD_INT 112
110079: PUSH
110080: LD_INT 114
110082: PUSH
110083: LD_INT 116
110085: PUSH
110086: LD_INT 117
110088: PUSH
110089: LD_INT 118
110091: PUSH
110092: EMPTY
110093: LIST
110094: LIST
110095: LIST
110096: LIST
110097: LIST
110098: LIST
110099: LIST
110100: LIST
110101: LIST
110102: LIST
110103: LIST
110104: LIST
110105: LIST
110106: LIST
110107: LIST
110108: LIST
110109: PUSH
110110: EMPTY
110111: LIST
110112: LIST
110113: ST_TO_ADDR
110114: GO 111797
110116: LD_INT 12
110118: DOUBLE
110119: EQUAL
110120: IFTRUE 110124
110122: GO 110344
110124: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
110125: LD_ADDR_VAR 0 2
110129: PUSH
110130: LD_INT 1
110132: PUSH
110133: LD_INT 2
110135: PUSH
110136: LD_INT 3
110138: PUSH
110139: LD_INT 4
110141: PUSH
110142: LD_INT 5
110144: PUSH
110145: LD_INT 6
110147: PUSH
110148: LD_INT 7
110150: PUSH
110151: LD_INT 8
110153: PUSH
110154: LD_INT 9
110156: PUSH
110157: LD_INT 10
110159: PUSH
110160: LD_INT 11
110162: PUSH
110163: LD_INT 12
110165: PUSH
110166: LD_INT 13
110168: PUSH
110169: LD_INT 14
110171: PUSH
110172: LD_INT 15
110174: PUSH
110175: LD_INT 16
110177: PUSH
110178: LD_INT 17
110180: PUSH
110181: LD_INT 18
110183: PUSH
110184: LD_INT 19
110186: PUSH
110187: LD_INT 20
110189: PUSH
110190: LD_INT 21
110192: PUSH
110193: LD_INT 22
110195: PUSH
110196: LD_INT 23
110198: PUSH
110199: LD_INT 24
110201: PUSH
110202: LD_INT 25
110204: PUSH
110205: LD_INT 26
110207: PUSH
110208: LD_INT 27
110210: PUSH
110211: LD_INT 28
110213: PUSH
110214: LD_INT 30
110216: PUSH
110217: LD_INT 31
110219: PUSH
110220: LD_INT 32
110222: PUSH
110223: LD_INT 33
110225: PUSH
110226: LD_INT 34
110228: PUSH
110229: LD_INT 36
110231: PUSH
110232: EMPTY
110233: LIST
110234: LIST
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: LIST
110254: LIST
110255: LIST
110256: LIST
110257: LIST
110258: LIST
110259: LIST
110260: LIST
110261: LIST
110262: LIST
110263: LIST
110264: LIST
110265: LIST
110266: LIST
110267: PUSH
110268: LD_INT 101
110270: PUSH
110271: LD_INT 102
110273: PUSH
110274: LD_INT 103
110276: PUSH
110277: LD_INT 104
110279: PUSH
110280: LD_INT 105
110282: PUSH
110283: LD_INT 106
110285: PUSH
110286: LD_INT 107
110288: PUSH
110289: LD_INT 108
110291: PUSH
110292: LD_INT 109
110294: PUSH
110295: LD_INT 110
110297: PUSH
110298: LD_INT 111
110300: PUSH
110301: LD_INT 112
110303: PUSH
110304: LD_INT 113
110306: PUSH
110307: LD_INT 114
110309: PUSH
110310: LD_INT 116
110312: PUSH
110313: LD_INT 117
110315: PUSH
110316: LD_INT 118
110318: PUSH
110319: EMPTY
110320: LIST
110321: LIST
110322: LIST
110323: LIST
110324: LIST
110325: LIST
110326: LIST
110327: LIST
110328: LIST
110329: LIST
110330: LIST
110331: LIST
110332: LIST
110333: LIST
110334: LIST
110335: LIST
110336: LIST
110337: PUSH
110338: EMPTY
110339: LIST
110340: LIST
110341: ST_TO_ADDR
110342: GO 111797
110344: LD_INT 13
110346: DOUBLE
110347: EQUAL
110348: IFTRUE 110352
110350: GO 110560
110352: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
110353: LD_ADDR_VAR 0 2
110357: PUSH
110358: LD_INT 1
110360: PUSH
110361: LD_INT 2
110363: PUSH
110364: LD_INT 3
110366: PUSH
110367: LD_INT 4
110369: PUSH
110370: LD_INT 5
110372: PUSH
110373: LD_INT 8
110375: PUSH
110376: LD_INT 9
110378: PUSH
110379: LD_INT 10
110381: PUSH
110382: LD_INT 11
110384: PUSH
110385: LD_INT 12
110387: PUSH
110388: LD_INT 14
110390: PUSH
110391: LD_INT 15
110393: PUSH
110394: LD_INT 16
110396: PUSH
110397: LD_INT 17
110399: PUSH
110400: LD_INT 18
110402: PUSH
110403: LD_INT 19
110405: PUSH
110406: LD_INT 20
110408: PUSH
110409: LD_INT 21
110411: PUSH
110412: LD_INT 22
110414: PUSH
110415: LD_INT 23
110417: PUSH
110418: LD_INT 24
110420: PUSH
110421: LD_INT 25
110423: PUSH
110424: LD_INT 26
110426: PUSH
110427: LD_INT 27
110429: PUSH
110430: LD_INT 28
110432: PUSH
110433: LD_INT 30
110435: PUSH
110436: LD_INT 31
110438: PUSH
110439: LD_INT 32
110441: PUSH
110442: LD_INT 33
110444: PUSH
110445: LD_INT 34
110447: PUSH
110448: LD_INT 36
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: LIST
110455: LIST
110456: LIST
110457: LIST
110458: LIST
110459: LIST
110460: LIST
110461: LIST
110462: LIST
110463: LIST
110464: LIST
110465: LIST
110466: LIST
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: LIST
110477: LIST
110478: LIST
110479: LIST
110480: LIST
110481: LIST
110482: LIST
110483: PUSH
110484: LD_INT 101
110486: PUSH
110487: LD_INT 102
110489: PUSH
110490: LD_INT 103
110492: PUSH
110493: LD_INT 104
110495: PUSH
110496: LD_INT 105
110498: PUSH
110499: LD_INT 106
110501: PUSH
110502: LD_INT 107
110504: PUSH
110505: LD_INT 108
110507: PUSH
110508: LD_INT 109
110510: PUSH
110511: LD_INT 110
110513: PUSH
110514: LD_INT 111
110516: PUSH
110517: LD_INT 112
110519: PUSH
110520: LD_INT 113
110522: PUSH
110523: LD_INT 114
110525: PUSH
110526: LD_INT 116
110528: PUSH
110529: LD_INT 117
110531: PUSH
110532: LD_INT 118
110534: PUSH
110535: EMPTY
110536: LIST
110537: LIST
110538: LIST
110539: LIST
110540: LIST
110541: LIST
110542: LIST
110543: LIST
110544: LIST
110545: LIST
110546: LIST
110547: LIST
110548: LIST
110549: LIST
110550: LIST
110551: LIST
110552: LIST
110553: PUSH
110554: EMPTY
110555: LIST
110556: LIST
110557: ST_TO_ADDR
110558: GO 111797
110560: LD_INT 14
110562: DOUBLE
110563: EQUAL
110564: IFTRUE 110568
110566: GO 110792
110568: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
110569: LD_ADDR_VAR 0 2
110573: PUSH
110574: LD_INT 1
110576: PUSH
110577: LD_INT 2
110579: PUSH
110580: LD_INT 3
110582: PUSH
110583: LD_INT 4
110585: PUSH
110586: LD_INT 5
110588: PUSH
110589: LD_INT 6
110591: PUSH
110592: LD_INT 7
110594: PUSH
110595: LD_INT 8
110597: PUSH
110598: LD_INT 9
110600: PUSH
110601: LD_INT 10
110603: PUSH
110604: LD_INT 11
110606: PUSH
110607: LD_INT 12
110609: PUSH
110610: LD_INT 13
110612: PUSH
110613: LD_INT 14
110615: PUSH
110616: LD_INT 15
110618: PUSH
110619: LD_INT 16
110621: PUSH
110622: LD_INT 17
110624: PUSH
110625: LD_INT 18
110627: PUSH
110628: LD_INT 19
110630: PUSH
110631: LD_INT 20
110633: PUSH
110634: LD_INT 21
110636: PUSH
110637: LD_INT 22
110639: PUSH
110640: LD_INT 23
110642: PUSH
110643: LD_INT 24
110645: PUSH
110646: LD_INT 25
110648: PUSH
110649: LD_INT 26
110651: PUSH
110652: LD_INT 27
110654: PUSH
110655: LD_INT 28
110657: PUSH
110658: LD_INT 29
110660: PUSH
110661: LD_INT 30
110663: PUSH
110664: LD_INT 31
110666: PUSH
110667: LD_INT 32
110669: PUSH
110670: LD_INT 33
110672: PUSH
110673: LD_INT 34
110675: PUSH
110676: LD_INT 36
110678: PUSH
110679: EMPTY
110680: LIST
110681: LIST
110682: LIST
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: LIST
110692: LIST
110693: LIST
110694: LIST
110695: LIST
110696: LIST
110697: LIST
110698: LIST
110699: LIST
110700: LIST
110701: LIST
110702: LIST
110703: LIST
110704: LIST
110705: LIST
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: LIST
110711: LIST
110712: LIST
110713: LIST
110714: LIST
110715: PUSH
110716: LD_INT 101
110718: PUSH
110719: LD_INT 102
110721: PUSH
110722: LD_INT 103
110724: PUSH
110725: LD_INT 104
110727: PUSH
110728: LD_INT 105
110730: PUSH
110731: LD_INT 106
110733: PUSH
110734: LD_INT 107
110736: PUSH
110737: LD_INT 108
110739: PUSH
110740: LD_INT 109
110742: PUSH
110743: LD_INT 110
110745: PUSH
110746: LD_INT 111
110748: PUSH
110749: LD_INT 112
110751: PUSH
110752: LD_INT 113
110754: PUSH
110755: LD_INT 114
110757: PUSH
110758: LD_INT 116
110760: PUSH
110761: LD_INT 117
110763: PUSH
110764: LD_INT 118
110766: PUSH
110767: EMPTY
110768: LIST
110769: LIST
110770: LIST
110771: LIST
110772: LIST
110773: LIST
110774: LIST
110775: LIST
110776: LIST
110777: LIST
110778: LIST
110779: LIST
110780: LIST
110781: LIST
110782: LIST
110783: LIST
110784: LIST
110785: PUSH
110786: EMPTY
110787: LIST
110788: LIST
110789: ST_TO_ADDR
110790: GO 111797
110792: LD_INT 15
110794: DOUBLE
110795: EQUAL
110796: IFTRUE 110800
110798: GO 111024
110800: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
110801: LD_ADDR_VAR 0 2
110805: PUSH
110806: LD_INT 1
110808: PUSH
110809: LD_INT 2
110811: PUSH
110812: LD_INT 3
110814: PUSH
110815: LD_INT 4
110817: PUSH
110818: LD_INT 5
110820: PUSH
110821: LD_INT 6
110823: PUSH
110824: LD_INT 7
110826: PUSH
110827: LD_INT 8
110829: PUSH
110830: LD_INT 9
110832: PUSH
110833: LD_INT 10
110835: PUSH
110836: LD_INT 11
110838: PUSH
110839: LD_INT 12
110841: PUSH
110842: LD_INT 13
110844: PUSH
110845: LD_INT 14
110847: PUSH
110848: LD_INT 15
110850: PUSH
110851: LD_INT 16
110853: PUSH
110854: LD_INT 17
110856: PUSH
110857: LD_INT 18
110859: PUSH
110860: LD_INT 19
110862: PUSH
110863: LD_INT 20
110865: PUSH
110866: LD_INT 21
110868: PUSH
110869: LD_INT 22
110871: PUSH
110872: LD_INT 23
110874: PUSH
110875: LD_INT 24
110877: PUSH
110878: LD_INT 25
110880: PUSH
110881: LD_INT 26
110883: PUSH
110884: LD_INT 27
110886: PUSH
110887: LD_INT 28
110889: PUSH
110890: LD_INT 29
110892: PUSH
110893: LD_INT 30
110895: PUSH
110896: LD_INT 31
110898: PUSH
110899: LD_INT 32
110901: PUSH
110902: LD_INT 33
110904: PUSH
110905: LD_INT 34
110907: PUSH
110908: LD_INT 36
110910: PUSH
110911: EMPTY
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: LIST
110929: LIST
110930: LIST
110931: LIST
110932: LIST
110933: LIST
110934: LIST
110935: LIST
110936: LIST
110937: LIST
110938: LIST
110939: LIST
110940: LIST
110941: LIST
110942: LIST
110943: LIST
110944: LIST
110945: LIST
110946: LIST
110947: PUSH
110948: LD_INT 101
110950: PUSH
110951: LD_INT 102
110953: PUSH
110954: LD_INT 103
110956: PUSH
110957: LD_INT 104
110959: PUSH
110960: LD_INT 105
110962: PUSH
110963: LD_INT 106
110965: PUSH
110966: LD_INT 107
110968: PUSH
110969: LD_INT 108
110971: PUSH
110972: LD_INT 109
110974: PUSH
110975: LD_INT 110
110977: PUSH
110978: LD_INT 111
110980: PUSH
110981: LD_INT 112
110983: PUSH
110984: LD_INT 113
110986: PUSH
110987: LD_INT 114
110989: PUSH
110990: LD_INT 116
110992: PUSH
110993: LD_INT 117
110995: PUSH
110996: LD_INT 118
110998: PUSH
110999: EMPTY
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: LIST
111005: LIST
111006: LIST
111007: LIST
111008: LIST
111009: LIST
111010: LIST
111011: LIST
111012: LIST
111013: LIST
111014: LIST
111015: LIST
111016: LIST
111017: PUSH
111018: EMPTY
111019: LIST
111020: LIST
111021: ST_TO_ADDR
111022: GO 111797
111024: LD_INT 16
111026: DOUBLE
111027: EQUAL
111028: IFTRUE 111032
111030: GO 111168
111032: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
111033: LD_ADDR_VAR 0 2
111037: PUSH
111038: LD_INT 2
111040: PUSH
111041: LD_INT 4
111043: PUSH
111044: LD_INT 5
111046: PUSH
111047: LD_INT 7
111049: PUSH
111050: LD_INT 11
111052: PUSH
111053: LD_INT 12
111055: PUSH
111056: LD_INT 15
111058: PUSH
111059: LD_INT 16
111061: PUSH
111062: LD_INT 20
111064: PUSH
111065: LD_INT 21
111067: PUSH
111068: LD_INT 22
111070: PUSH
111071: LD_INT 23
111073: PUSH
111074: LD_INT 25
111076: PUSH
111077: LD_INT 26
111079: PUSH
111080: LD_INT 30
111082: PUSH
111083: LD_INT 31
111085: PUSH
111086: LD_INT 32
111088: PUSH
111089: LD_INT 33
111091: PUSH
111092: LD_INT 34
111094: PUSH
111095: EMPTY
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: LIST
111106: LIST
111107: LIST
111108: LIST
111109: LIST
111110: LIST
111111: LIST
111112: LIST
111113: LIST
111114: LIST
111115: PUSH
111116: LD_INT 101
111118: PUSH
111119: LD_INT 102
111121: PUSH
111122: LD_INT 103
111124: PUSH
111125: LD_INT 106
111127: PUSH
111128: LD_INT 108
111130: PUSH
111131: LD_INT 112
111133: PUSH
111134: LD_INT 113
111136: PUSH
111137: LD_INT 114
111139: PUSH
111140: LD_INT 116
111142: PUSH
111143: LD_INT 117
111145: PUSH
111146: LD_INT 118
111148: PUSH
111149: EMPTY
111150: LIST
111151: LIST
111152: LIST
111153: LIST
111154: LIST
111155: LIST
111156: LIST
111157: LIST
111158: LIST
111159: LIST
111160: LIST
111161: PUSH
111162: EMPTY
111163: LIST
111164: LIST
111165: ST_TO_ADDR
111166: GO 111797
111168: LD_INT 17
111170: DOUBLE
111171: EQUAL
111172: IFTRUE 111176
111174: GO 111400
111176: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
111177: LD_ADDR_VAR 0 2
111181: PUSH
111182: LD_INT 1
111184: PUSH
111185: LD_INT 2
111187: PUSH
111188: LD_INT 3
111190: PUSH
111191: LD_INT 4
111193: PUSH
111194: LD_INT 5
111196: PUSH
111197: LD_INT 6
111199: PUSH
111200: LD_INT 7
111202: PUSH
111203: LD_INT 8
111205: PUSH
111206: LD_INT 9
111208: PUSH
111209: LD_INT 10
111211: PUSH
111212: LD_INT 11
111214: PUSH
111215: LD_INT 12
111217: PUSH
111218: LD_INT 13
111220: PUSH
111221: LD_INT 14
111223: PUSH
111224: LD_INT 15
111226: PUSH
111227: LD_INT 16
111229: PUSH
111230: LD_INT 17
111232: PUSH
111233: LD_INT 18
111235: PUSH
111236: LD_INT 19
111238: PUSH
111239: LD_INT 20
111241: PUSH
111242: LD_INT 21
111244: PUSH
111245: LD_INT 22
111247: PUSH
111248: LD_INT 23
111250: PUSH
111251: LD_INT 24
111253: PUSH
111254: LD_INT 25
111256: PUSH
111257: LD_INT 26
111259: PUSH
111260: LD_INT 27
111262: PUSH
111263: LD_INT 28
111265: PUSH
111266: LD_INT 29
111268: PUSH
111269: LD_INT 30
111271: PUSH
111272: LD_INT 31
111274: PUSH
111275: LD_INT 32
111277: PUSH
111278: LD_INT 33
111280: PUSH
111281: LD_INT 34
111283: PUSH
111284: LD_INT 36
111286: PUSH
111287: EMPTY
111288: LIST
111289: LIST
111290: LIST
111291: LIST
111292: LIST
111293: LIST
111294: LIST
111295: LIST
111296: LIST
111297: LIST
111298: LIST
111299: LIST
111300: LIST
111301: LIST
111302: LIST
111303: LIST
111304: LIST
111305: LIST
111306: LIST
111307: LIST
111308: LIST
111309: LIST
111310: LIST
111311: LIST
111312: LIST
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: LIST
111318: LIST
111319: LIST
111320: LIST
111321: LIST
111322: LIST
111323: PUSH
111324: LD_INT 101
111326: PUSH
111327: LD_INT 102
111329: PUSH
111330: LD_INT 103
111332: PUSH
111333: LD_INT 104
111335: PUSH
111336: LD_INT 105
111338: PUSH
111339: LD_INT 106
111341: PUSH
111342: LD_INT 107
111344: PUSH
111345: LD_INT 108
111347: PUSH
111348: LD_INT 109
111350: PUSH
111351: LD_INT 110
111353: PUSH
111354: LD_INT 111
111356: PUSH
111357: LD_INT 112
111359: PUSH
111360: LD_INT 113
111362: PUSH
111363: LD_INT 114
111365: PUSH
111366: LD_INT 116
111368: PUSH
111369: LD_INT 117
111371: PUSH
111372: LD_INT 118
111374: PUSH
111375: EMPTY
111376: LIST
111377: LIST
111378: LIST
111379: LIST
111380: LIST
111381: LIST
111382: LIST
111383: LIST
111384: LIST
111385: LIST
111386: LIST
111387: LIST
111388: LIST
111389: LIST
111390: LIST
111391: LIST
111392: LIST
111393: PUSH
111394: EMPTY
111395: LIST
111396: LIST
111397: ST_TO_ADDR
111398: GO 111797
111400: LD_INT 18
111402: DOUBLE
111403: EQUAL
111404: IFTRUE 111408
111406: GO 111556
111408: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
111409: LD_ADDR_VAR 0 2
111413: PUSH
111414: LD_INT 2
111416: PUSH
111417: LD_INT 4
111419: PUSH
111420: LD_INT 5
111422: PUSH
111423: LD_INT 7
111425: PUSH
111426: LD_INT 11
111428: PUSH
111429: LD_INT 12
111431: PUSH
111432: LD_INT 15
111434: PUSH
111435: LD_INT 16
111437: PUSH
111438: LD_INT 20
111440: PUSH
111441: LD_INT 21
111443: PUSH
111444: LD_INT 22
111446: PUSH
111447: LD_INT 23
111449: PUSH
111450: LD_INT 25
111452: PUSH
111453: LD_INT 26
111455: PUSH
111456: LD_INT 30
111458: PUSH
111459: LD_INT 31
111461: PUSH
111462: LD_INT 32
111464: PUSH
111465: LD_INT 33
111467: PUSH
111468: LD_INT 34
111470: PUSH
111471: LD_INT 35
111473: PUSH
111474: LD_INT 36
111476: PUSH
111477: EMPTY
111478: LIST
111479: LIST
111480: LIST
111481: LIST
111482: LIST
111483: LIST
111484: LIST
111485: LIST
111486: LIST
111487: LIST
111488: LIST
111489: LIST
111490: LIST
111491: LIST
111492: LIST
111493: LIST
111494: LIST
111495: LIST
111496: LIST
111497: LIST
111498: LIST
111499: PUSH
111500: LD_INT 101
111502: PUSH
111503: LD_INT 102
111505: PUSH
111506: LD_INT 103
111508: PUSH
111509: LD_INT 106
111511: PUSH
111512: LD_INT 108
111514: PUSH
111515: LD_INT 112
111517: PUSH
111518: LD_INT 113
111520: PUSH
111521: LD_INT 114
111523: PUSH
111524: LD_INT 115
111526: PUSH
111527: LD_INT 116
111529: PUSH
111530: LD_INT 117
111532: PUSH
111533: LD_INT 118
111535: PUSH
111536: EMPTY
111537: LIST
111538: LIST
111539: LIST
111540: LIST
111541: LIST
111542: LIST
111543: LIST
111544: LIST
111545: LIST
111546: LIST
111547: LIST
111548: LIST
111549: PUSH
111550: EMPTY
111551: LIST
111552: LIST
111553: ST_TO_ADDR
111554: GO 111797
111556: LD_INT 19
111558: DOUBLE
111559: EQUAL
111560: IFTRUE 111564
111562: GO 111796
111564: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
111565: LD_ADDR_VAR 0 2
111569: PUSH
111570: LD_INT 1
111572: PUSH
111573: LD_INT 2
111575: PUSH
111576: LD_INT 3
111578: PUSH
111579: LD_INT 4
111581: PUSH
111582: LD_INT 5
111584: PUSH
111585: LD_INT 6
111587: PUSH
111588: LD_INT 7
111590: PUSH
111591: LD_INT 8
111593: PUSH
111594: LD_INT 9
111596: PUSH
111597: LD_INT 10
111599: PUSH
111600: LD_INT 11
111602: PUSH
111603: LD_INT 12
111605: PUSH
111606: LD_INT 13
111608: PUSH
111609: LD_INT 14
111611: PUSH
111612: LD_INT 15
111614: PUSH
111615: LD_INT 16
111617: PUSH
111618: LD_INT 17
111620: PUSH
111621: LD_INT 18
111623: PUSH
111624: LD_INT 19
111626: PUSH
111627: LD_INT 20
111629: PUSH
111630: LD_INT 21
111632: PUSH
111633: LD_INT 22
111635: PUSH
111636: LD_INT 23
111638: PUSH
111639: LD_INT 24
111641: PUSH
111642: LD_INT 25
111644: PUSH
111645: LD_INT 26
111647: PUSH
111648: LD_INT 27
111650: PUSH
111651: LD_INT 28
111653: PUSH
111654: LD_INT 29
111656: PUSH
111657: LD_INT 30
111659: PUSH
111660: LD_INT 31
111662: PUSH
111663: LD_INT 32
111665: PUSH
111666: LD_INT 33
111668: PUSH
111669: LD_INT 34
111671: PUSH
111672: LD_INT 35
111674: PUSH
111675: LD_INT 36
111677: PUSH
111678: EMPTY
111679: LIST
111680: LIST
111681: LIST
111682: LIST
111683: LIST
111684: LIST
111685: LIST
111686: LIST
111687: LIST
111688: LIST
111689: LIST
111690: LIST
111691: LIST
111692: LIST
111693: LIST
111694: LIST
111695: LIST
111696: LIST
111697: LIST
111698: LIST
111699: LIST
111700: LIST
111701: LIST
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: LIST
111709: LIST
111710: LIST
111711: LIST
111712: LIST
111713: LIST
111714: LIST
111715: PUSH
111716: LD_INT 101
111718: PUSH
111719: LD_INT 102
111721: PUSH
111722: LD_INT 103
111724: PUSH
111725: LD_INT 104
111727: PUSH
111728: LD_INT 105
111730: PUSH
111731: LD_INT 106
111733: PUSH
111734: LD_INT 107
111736: PUSH
111737: LD_INT 108
111739: PUSH
111740: LD_INT 109
111742: PUSH
111743: LD_INT 110
111745: PUSH
111746: LD_INT 111
111748: PUSH
111749: LD_INT 112
111751: PUSH
111752: LD_INT 113
111754: PUSH
111755: LD_INT 114
111757: PUSH
111758: LD_INT 115
111760: PUSH
111761: LD_INT 116
111763: PUSH
111764: LD_INT 117
111766: PUSH
111767: LD_INT 118
111769: PUSH
111770: EMPTY
111771: LIST
111772: LIST
111773: LIST
111774: LIST
111775: LIST
111776: LIST
111777: LIST
111778: LIST
111779: LIST
111780: LIST
111781: LIST
111782: LIST
111783: LIST
111784: LIST
111785: LIST
111786: LIST
111787: LIST
111788: LIST
111789: PUSH
111790: EMPTY
111791: LIST
111792: LIST
111793: ST_TO_ADDR
111794: GO 111797
111796: POP
// end else
111797: GO 112028
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
111799: LD_ADDR_VAR 0 2
111803: PUSH
111804: LD_INT 1
111806: PUSH
111807: LD_INT 2
111809: PUSH
111810: LD_INT 3
111812: PUSH
111813: LD_INT 4
111815: PUSH
111816: LD_INT 5
111818: PUSH
111819: LD_INT 6
111821: PUSH
111822: LD_INT 7
111824: PUSH
111825: LD_INT 8
111827: PUSH
111828: LD_INT 9
111830: PUSH
111831: LD_INT 10
111833: PUSH
111834: LD_INT 11
111836: PUSH
111837: LD_INT 12
111839: PUSH
111840: LD_INT 13
111842: PUSH
111843: LD_INT 14
111845: PUSH
111846: LD_INT 15
111848: PUSH
111849: LD_INT 16
111851: PUSH
111852: LD_INT 17
111854: PUSH
111855: LD_INT 18
111857: PUSH
111858: LD_INT 19
111860: PUSH
111861: LD_INT 20
111863: PUSH
111864: LD_INT 21
111866: PUSH
111867: LD_INT 22
111869: PUSH
111870: LD_INT 23
111872: PUSH
111873: LD_INT 24
111875: PUSH
111876: LD_INT 25
111878: PUSH
111879: LD_INT 26
111881: PUSH
111882: LD_INT 27
111884: PUSH
111885: LD_INT 28
111887: PUSH
111888: LD_INT 29
111890: PUSH
111891: LD_INT 30
111893: PUSH
111894: LD_INT 31
111896: PUSH
111897: LD_INT 32
111899: PUSH
111900: LD_INT 33
111902: PUSH
111903: LD_INT 34
111905: PUSH
111906: LD_INT 35
111908: PUSH
111909: LD_INT 36
111911: PUSH
111912: EMPTY
111913: LIST
111914: LIST
111915: LIST
111916: LIST
111917: LIST
111918: LIST
111919: LIST
111920: LIST
111921: LIST
111922: LIST
111923: LIST
111924: LIST
111925: LIST
111926: LIST
111927: LIST
111928: LIST
111929: LIST
111930: LIST
111931: LIST
111932: LIST
111933: LIST
111934: LIST
111935: LIST
111936: LIST
111937: LIST
111938: LIST
111939: LIST
111940: LIST
111941: LIST
111942: LIST
111943: LIST
111944: LIST
111945: LIST
111946: LIST
111947: LIST
111948: LIST
111949: PUSH
111950: LD_INT 101
111952: PUSH
111953: LD_INT 102
111955: PUSH
111956: LD_INT 103
111958: PUSH
111959: LD_INT 104
111961: PUSH
111962: LD_INT 105
111964: PUSH
111965: LD_INT 106
111967: PUSH
111968: LD_INT 107
111970: PUSH
111971: LD_INT 108
111973: PUSH
111974: LD_INT 109
111976: PUSH
111977: LD_INT 110
111979: PUSH
111980: LD_INT 111
111982: PUSH
111983: LD_INT 112
111985: PUSH
111986: LD_INT 113
111988: PUSH
111989: LD_INT 114
111991: PUSH
111992: LD_INT 115
111994: PUSH
111995: LD_INT 116
111997: PUSH
111998: LD_INT 117
112000: PUSH
112001: LD_INT 118
112003: PUSH
112004: EMPTY
112005: LIST
112006: LIST
112007: LIST
112008: LIST
112009: LIST
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: LIST
112021: LIST
112022: LIST
112023: PUSH
112024: EMPTY
112025: LIST
112026: LIST
112027: ST_TO_ADDR
// if result then
112028: LD_VAR 0 2
112032: IFFALSE 112818
// begin normal :=  ;
112034: LD_ADDR_VAR 0 5
112038: PUSH
112039: LD_STRING 
112041: ST_TO_ADDR
// hardcore :=  ;
112042: LD_ADDR_VAR 0 6
112046: PUSH
112047: LD_STRING 
112049: ST_TO_ADDR
// active :=  ;
112050: LD_ADDR_VAR 0 7
112054: PUSH
112055: LD_STRING 
112057: ST_TO_ADDR
// for i = 1 to normalCounter do
112058: LD_ADDR_VAR 0 8
112062: PUSH
112063: DOUBLE
112064: LD_INT 1
112066: DEC
112067: ST_TO_ADDR
112068: LD_EXP 142
112072: PUSH
112073: FOR_TO
112074: IFFALSE 112175
// begin tmp := 0 ;
112076: LD_ADDR_VAR 0 3
112080: PUSH
112081: LD_STRING 0
112083: ST_TO_ADDR
// if result [ 1 ] then
112084: LD_VAR 0 2
112088: PUSH
112089: LD_INT 1
112091: ARRAY
112092: IFFALSE 112157
// if result [ 1 ] [ 1 ] = i then
112094: LD_VAR 0 2
112098: PUSH
112099: LD_INT 1
112101: ARRAY
112102: PUSH
112103: LD_INT 1
112105: ARRAY
112106: PUSH
112107: LD_VAR 0 8
112111: EQUAL
112112: IFFALSE 112157
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
112114: LD_ADDR_VAR 0 2
112118: PUSH
112119: LD_VAR 0 2
112123: PPUSH
112124: LD_INT 1
112126: PPUSH
112127: LD_VAR 0 2
112131: PUSH
112132: LD_INT 1
112134: ARRAY
112135: PPUSH
112136: LD_INT 1
112138: PPUSH
112139: CALL_OW 3
112143: PPUSH
112144: CALL_OW 1
112148: ST_TO_ADDR
// tmp := 1 ;
112149: LD_ADDR_VAR 0 3
112153: PUSH
112154: LD_STRING 1
112156: ST_TO_ADDR
// end ; normal := normal & tmp ;
112157: LD_ADDR_VAR 0 5
112161: PUSH
112162: LD_VAR 0 5
112166: PUSH
112167: LD_VAR 0 3
112171: STR
112172: ST_TO_ADDR
// end ;
112173: GO 112073
112175: POP
112176: POP
// for i = 1 to hardcoreCounter do
112177: LD_ADDR_VAR 0 8
112181: PUSH
112182: DOUBLE
112183: LD_INT 1
112185: DEC
112186: ST_TO_ADDR
112187: LD_EXP 143
112191: PUSH
112192: FOR_TO
112193: IFFALSE 112298
// begin tmp := 0 ;
112195: LD_ADDR_VAR 0 3
112199: PUSH
112200: LD_STRING 0
112202: ST_TO_ADDR
// if result [ 2 ] then
112203: LD_VAR 0 2
112207: PUSH
112208: LD_INT 2
112210: ARRAY
112211: IFFALSE 112280
// if result [ 2 ] [ 1 ] = 100 + i then
112213: LD_VAR 0 2
112217: PUSH
112218: LD_INT 2
112220: ARRAY
112221: PUSH
112222: LD_INT 1
112224: ARRAY
112225: PUSH
112226: LD_INT 100
112228: PUSH
112229: LD_VAR 0 8
112233: PLUS
112234: EQUAL
112235: IFFALSE 112280
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
112237: LD_ADDR_VAR 0 2
112241: PUSH
112242: LD_VAR 0 2
112246: PPUSH
112247: LD_INT 2
112249: PPUSH
112250: LD_VAR 0 2
112254: PUSH
112255: LD_INT 2
112257: ARRAY
112258: PPUSH
112259: LD_INT 1
112261: PPUSH
112262: CALL_OW 3
112266: PPUSH
112267: CALL_OW 1
112271: ST_TO_ADDR
// tmp := 1 ;
112272: LD_ADDR_VAR 0 3
112276: PUSH
112277: LD_STRING 1
112279: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
112280: LD_ADDR_VAR 0 6
112284: PUSH
112285: LD_VAR 0 6
112289: PUSH
112290: LD_VAR 0 3
112294: STR
112295: ST_TO_ADDR
// end ;
112296: GO 112192
112298: POP
112299: POP
// if isGameLoad then
112300: LD_VAR 0 1
112304: IFFALSE 112779
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
112306: LD_ADDR_VAR 0 4
112310: PUSH
112311: LD_EXP 146
112315: PUSH
112316: LD_EXP 145
112320: PUSH
112321: LD_EXP 147
112325: PUSH
112326: LD_EXP 144
112330: PUSH
112331: LD_EXP 148
112335: PUSH
112336: LD_EXP 149
112340: PUSH
112341: LD_EXP 150
112345: PUSH
112346: LD_EXP 151
112350: PUSH
112351: LD_EXP 152
112355: PUSH
112356: LD_EXP 153
112360: PUSH
112361: LD_EXP 154
112365: PUSH
112366: LD_EXP 155
112370: PUSH
112371: LD_EXP 156
112375: PUSH
112376: LD_EXP 157
112380: PUSH
112381: LD_EXP 165
112385: PUSH
112386: LD_EXP 166
112390: PUSH
112391: LD_EXP 167
112395: PUSH
112396: LD_EXP 168
112400: PUSH
112401: LD_EXP 170
112405: PUSH
112406: LD_EXP 171
112410: PUSH
112411: LD_EXP 172
112415: PUSH
112416: LD_EXP 175
112420: PUSH
112421: LD_EXP 177
112425: PUSH
112426: LD_EXP 178
112430: PUSH
112431: LD_EXP 179
112435: PUSH
112436: LD_EXP 181
112440: PUSH
112441: LD_EXP 182
112445: PUSH
112446: LD_EXP 185
112450: PUSH
112451: LD_EXP 186
112455: PUSH
112456: LD_EXP 187
112460: PUSH
112461: LD_EXP 188
112465: PUSH
112466: LD_EXP 189
112470: PUSH
112471: LD_EXP 190
112475: PUSH
112476: LD_EXP 191
112480: PUSH
112481: LD_EXP 192
112485: PUSH
112486: LD_EXP 193
112490: PUSH
112491: LD_EXP 158
112495: PUSH
112496: LD_EXP 159
112500: PUSH
112501: LD_EXP 162
112505: PUSH
112506: LD_EXP 163
112510: PUSH
112511: LD_EXP 164
112515: PUSH
112516: LD_EXP 160
112520: PUSH
112521: LD_EXP 161
112525: PUSH
112526: LD_EXP 169
112530: PUSH
112531: LD_EXP 173
112535: PUSH
112536: LD_EXP 174
112540: PUSH
112541: LD_EXP 176
112545: PUSH
112546: LD_EXP 180
112550: PUSH
112551: LD_EXP 183
112555: PUSH
112556: LD_EXP 184
112560: PUSH
112561: LD_EXP 194
112565: PUSH
112566: LD_EXP 195
112570: PUSH
112571: LD_EXP 196
112575: PUSH
112576: LD_EXP 197
112580: PUSH
112581: EMPTY
112582: LIST
112583: LIST
112584: LIST
112585: LIST
112586: LIST
112587: LIST
112588: LIST
112589: LIST
112590: LIST
112591: LIST
112592: LIST
112593: LIST
112594: LIST
112595: LIST
112596: LIST
112597: LIST
112598: LIST
112599: LIST
112600: LIST
112601: LIST
112602: LIST
112603: LIST
112604: LIST
112605: LIST
112606: LIST
112607: LIST
112608: LIST
112609: LIST
112610: LIST
112611: LIST
112612: LIST
112613: LIST
112614: LIST
112615: LIST
112616: LIST
112617: LIST
112618: LIST
112619: LIST
112620: LIST
112621: LIST
112622: LIST
112623: LIST
112624: LIST
112625: LIST
112626: LIST
112627: LIST
112628: LIST
112629: LIST
112630: LIST
112631: LIST
112632: LIST
112633: LIST
112634: LIST
112635: LIST
112636: ST_TO_ADDR
// tmp :=  ;
112637: LD_ADDR_VAR 0 3
112641: PUSH
112642: LD_STRING 
112644: ST_TO_ADDR
// for i = 1 to normalCounter do
112645: LD_ADDR_VAR 0 8
112649: PUSH
112650: DOUBLE
112651: LD_INT 1
112653: DEC
112654: ST_TO_ADDR
112655: LD_EXP 142
112659: PUSH
112660: FOR_TO
112661: IFFALSE 112697
// begin if flags [ i ] then
112663: LD_VAR 0 4
112667: PUSH
112668: LD_VAR 0 8
112672: ARRAY
112673: IFFALSE 112695
// tmp := tmp & i & ; ;
112675: LD_ADDR_VAR 0 3
112679: PUSH
112680: LD_VAR 0 3
112684: PUSH
112685: LD_VAR 0 8
112689: STR
112690: PUSH
112691: LD_STRING ;
112693: STR
112694: ST_TO_ADDR
// end ;
112695: GO 112660
112697: POP
112698: POP
// for i = 1 to hardcoreCounter do
112699: LD_ADDR_VAR 0 8
112703: PUSH
112704: DOUBLE
112705: LD_INT 1
112707: DEC
112708: ST_TO_ADDR
112709: LD_EXP 143
112713: PUSH
112714: FOR_TO
112715: IFFALSE 112761
// begin if flags [ normalCounter + i ] then
112717: LD_VAR 0 4
112721: PUSH
112722: LD_EXP 142
112726: PUSH
112727: LD_VAR 0 8
112731: PLUS
112732: ARRAY
112733: IFFALSE 112759
// tmp := tmp & ( 100 + i ) & ; ;
112735: LD_ADDR_VAR 0 3
112739: PUSH
112740: LD_VAR 0 3
112744: PUSH
112745: LD_INT 100
112747: PUSH
112748: LD_VAR 0 8
112752: PLUS
112753: STR
112754: PUSH
112755: LD_STRING ;
112757: STR
112758: ST_TO_ADDR
// end ;
112759: GO 112714
112761: POP
112762: POP
// if tmp then
112763: LD_VAR 0 3
112767: IFFALSE 112779
// active := tmp ;
112769: LD_ADDR_VAR 0 7
112773: PUSH
112774: LD_VAR 0 3
112778: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
112779: LD_STRING getStreamItemsFromMission("
112781: PUSH
112782: LD_VAR 0 5
112786: STR
112787: PUSH
112788: LD_STRING ","
112790: STR
112791: PUSH
112792: LD_VAR 0 6
112796: STR
112797: PUSH
112798: LD_STRING ","
112800: STR
112801: PUSH
112802: LD_VAR 0 7
112806: STR
112807: PUSH
112808: LD_STRING ")
112810: STR
112811: PPUSH
112812: CALL_OW 559
// end else
112816: GO 112825
// ToLua ( getStreamItemsFromMission("","","") ) ;
112818: LD_STRING getStreamItemsFromMission("","","")
112820: PPUSH
112821: CALL_OW 559
// end ;
112825: LD_VAR 0 2
112829: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
112830: LD_EXP 141
112834: PUSH
112835: LD_EXP 146
112839: AND
112840: IFFALSE 112964
112842: GO 112844
112844: DISABLE
112845: LD_INT 0
112847: PPUSH
112848: PPUSH
// begin enable ;
112849: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
112850: LD_ADDR_VAR 0 2
112854: PUSH
112855: LD_INT 22
112857: PUSH
112858: LD_OWVAR 2
112862: PUSH
112863: EMPTY
112864: LIST
112865: LIST
112866: PUSH
112867: LD_INT 2
112869: PUSH
112870: LD_INT 34
112872: PUSH
112873: LD_INT 7
112875: PUSH
112876: EMPTY
112877: LIST
112878: LIST
112879: PUSH
112880: LD_INT 34
112882: PUSH
112883: LD_INT 45
112885: PUSH
112886: EMPTY
112887: LIST
112888: LIST
112889: PUSH
112890: LD_INT 34
112892: PUSH
112893: LD_INT 28
112895: PUSH
112896: EMPTY
112897: LIST
112898: LIST
112899: PUSH
112900: LD_INT 34
112902: PUSH
112903: LD_INT 47
112905: PUSH
112906: EMPTY
112907: LIST
112908: LIST
112909: PUSH
112910: EMPTY
112911: LIST
112912: LIST
112913: LIST
112914: LIST
112915: LIST
112916: PUSH
112917: EMPTY
112918: LIST
112919: LIST
112920: PPUSH
112921: CALL_OW 69
112925: ST_TO_ADDR
// if not tmp then
112926: LD_VAR 0 2
112930: NOT
112931: IFFALSE 112935
// exit ;
112933: GO 112964
// for i in tmp do
112935: LD_ADDR_VAR 0 1
112939: PUSH
112940: LD_VAR 0 2
112944: PUSH
112945: FOR_IN
112946: IFFALSE 112962
// begin SetLives ( i , 0 ) ;
112948: LD_VAR 0 1
112952: PPUSH
112953: LD_INT 0
112955: PPUSH
112956: CALL_OW 234
// end ;
112960: GO 112945
112962: POP
112963: POP
// end ;
112964: PPOPN 2
112966: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
112967: LD_EXP 141
112971: PUSH
112972: LD_EXP 147
112976: AND
112977: IFFALSE 113061
112979: GO 112981
112981: DISABLE
112982: LD_INT 0
112984: PPUSH
112985: PPUSH
// begin enable ;
112986: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
112987: LD_ADDR_VAR 0 2
112991: PUSH
112992: LD_INT 22
112994: PUSH
112995: LD_OWVAR 2
112999: PUSH
113000: EMPTY
113001: LIST
113002: LIST
113003: PUSH
113004: LD_INT 32
113006: PUSH
113007: LD_INT 3
113009: PUSH
113010: EMPTY
113011: LIST
113012: LIST
113013: PUSH
113014: EMPTY
113015: LIST
113016: LIST
113017: PPUSH
113018: CALL_OW 69
113022: ST_TO_ADDR
// if not tmp then
113023: LD_VAR 0 2
113027: NOT
113028: IFFALSE 113032
// exit ;
113030: GO 113061
// for i in tmp do
113032: LD_ADDR_VAR 0 1
113036: PUSH
113037: LD_VAR 0 2
113041: PUSH
113042: FOR_IN
113043: IFFALSE 113059
// begin SetLives ( i , 0 ) ;
113045: LD_VAR 0 1
113049: PPUSH
113050: LD_INT 0
113052: PPUSH
113053: CALL_OW 234
// end ;
113057: GO 113042
113059: POP
113060: POP
// end ;
113061: PPOPN 2
113063: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113064: LD_EXP 141
113068: PUSH
113069: LD_EXP 144
113073: AND
113074: IFFALSE 113167
113076: GO 113078
113078: DISABLE
113079: LD_INT 0
113081: PPUSH
// begin enable ;
113082: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113083: LD_ADDR_VAR 0 1
113087: PUSH
113088: LD_INT 22
113090: PUSH
113091: LD_OWVAR 2
113095: PUSH
113096: EMPTY
113097: LIST
113098: LIST
113099: PUSH
113100: LD_INT 2
113102: PUSH
113103: LD_INT 25
113105: PUSH
113106: LD_INT 5
113108: PUSH
113109: EMPTY
113110: LIST
113111: LIST
113112: PUSH
113113: LD_INT 25
113115: PUSH
113116: LD_INT 9
113118: PUSH
113119: EMPTY
113120: LIST
113121: LIST
113122: PUSH
113123: LD_INT 25
113125: PUSH
113126: LD_INT 8
113128: PUSH
113129: EMPTY
113130: LIST
113131: LIST
113132: PUSH
113133: EMPTY
113134: LIST
113135: LIST
113136: LIST
113137: LIST
113138: PUSH
113139: EMPTY
113140: LIST
113141: LIST
113142: PPUSH
113143: CALL_OW 69
113147: PUSH
113148: FOR_IN
113149: IFFALSE 113165
// begin SetClass ( i , 1 ) ;
113151: LD_VAR 0 1
113155: PPUSH
113156: LD_INT 1
113158: PPUSH
113159: CALL_OW 336
// end ;
113163: GO 113148
113165: POP
113166: POP
// end ;
113167: PPOPN 1
113169: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113170: LD_EXP 141
113174: PUSH
113175: LD_EXP 145
113179: AND
113180: PUSH
113181: LD_OWVAR 65
113185: PUSH
113186: LD_INT 7
113188: LESS
113189: AND
113190: IFFALSE 113204
113192: GO 113194
113194: DISABLE
// begin enable ;
113195: ENABLE
// game_speed := 7 ;
113196: LD_ADDR_OWVAR 65
113200: PUSH
113201: LD_INT 7
113203: ST_TO_ADDR
// end ;
113204: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113205: LD_EXP 141
113209: PUSH
113210: LD_EXP 148
113214: AND
113215: IFFALSE 113417
113217: GO 113219
113219: DISABLE
113220: LD_INT 0
113222: PPUSH
113223: PPUSH
113224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113225: LD_ADDR_VAR 0 3
113229: PUSH
113230: LD_INT 81
113232: PUSH
113233: LD_OWVAR 2
113237: PUSH
113238: EMPTY
113239: LIST
113240: LIST
113241: PUSH
113242: LD_INT 21
113244: PUSH
113245: LD_INT 1
113247: PUSH
113248: EMPTY
113249: LIST
113250: LIST
113251: PUSH
113252: EMPTY
113253: LIST
113254: LIST
113255: PPUSH
113256: CALL_OW 69
113260: ST_TO_ADDR
// if not tmp then
113261: LD_VAR 0 3
113265: NOT
113266: IFFALSE 113270
// exit ;
113268: GO 113417
// if tmp > 5 then
113270: LD_VAR 0 3
113274: PUSH
113275: LD_INT 5
113277: GREATER
113278: IFFALSE 113290
// k := 5 else
113280: LD_ADDR_VAR 0 2
113284: PUSH
113285: LD_INT 5
113287: ST_TO_ADDR
113288: GO 113300
// k := tmp ;
113290: LD_ADDR_VAR 0 2
113294: PUSH
113295: LD_VAR 0 3
113299: ST_TO_ADDR
// for i := 1 to k do
113300: LD_ADDR_VAR 0 1
113304: PUSH
113305: DOUBLE
113306: LD_INT 1
113308: DEC
113309: ST_TO_ADDR
113310: LD_VAR 0 2
113314: PUSH
113315: FOR_TO
113316: IFFALSE 113415
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113318: LD_VAR 0 3
113322: PUSH
113323: LD_VAR 0 1
113327: ARRAY
113328: PPUSH
113329: LD_VAR 0 1
113333: PUSH
113334: LD_INT 4
113336: MOD
113337: PUSH
113338: LD_INT 1
113340: PLUS
113341: PPUSH
113342: CALL_OW 259
113346: PUSH
113347: LD_INT 10
113349: LESS
113350: IFFALSE 113413
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113352: LD_VAR 0 3
113356: PUSH
113357: LD_VAR 0 1
113361: ARRAY
113362: PPUSH
113363: LD_VAR 0 1
113367: PUSH
113368: LD_INT 4
113370: MOD
113371: PUSH
113372: LD_INT 1
113374: PLUS
113375: PPUSH
113376: LD_VAR 0 3
113380: PUSH
113381: LD_VAR 0 1
113385: ARRAY
113386: PPUSH
113387: LD_VAR 0 1
113391: PUSH
113392: LD_INT 4
113394: MOD
113395: PUSH
113396: LD_INT 1
113398: PLUS
113399: PPUSH
113400: CALL_OW 259
113404: PUSH
113405: LD_INT 1
113407: PLUS
113408: PPUSH
113409: CALL_OW 237
113413: GO 113315
113415: POP
113416: POP
// end ;
113417: PPOPN 3
113419: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113420: LD_EXP 141
113424: PUSH
113425: LD_EXP 149
113429: AND
113430: IFFALSE 113450
113432: GO 113434
113434: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113435: LD_INT 4
113437: PPUSH
113438: LD_OWVAR 2
113442: PPUSH
113443: LD_INT 0
113445: PPUSH
113446: CALL_OW 324
113450: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113451: LD_EXP 141
113455: PUSH
113456: LD_EXP 178
113460: AND
113461: IFFALSE 113481
113463: GO 113465
113465: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113466: LD_INT 19
113468: PPUSH
113469: LD_OWVAR 2
113473: PPUSH
113474: LD_INT 0
113476: PPUSH
113477: CALL_OW 324
113481: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113482: LD_EXP 141
113486: PUSH
113487: LD_EXP 150
113491: AND
113492: IFFALSE 113594
113494: GO 113496
113496: DISABLE
113497: LD_INT 0
113499: PPUSH
113500: PPUSH
// begin enable ;
113501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113502: LD_ADDR_VAR 0 2
113506: PUSH
113507: LD_INT 22
113509: PUSH
113510: LD_OWVAR 2
113514: PUSH
113515: EMPTY
113516: LIST
113517: LIST
113518: PUSH
113519: LD_INT 2
113521: PUSH
113522: LD_INT 34
113524: PUSH
113525: LD_INT 11
113527: PUSH
113528: EMPTY
113529: LIST
113530: LIST
113531: PUSH
113532: LD_INT 34
113534: PUSH
113535: LD_INT 30
113537: PUSH
113538: EMPTY
113539: LIST
113540: LIST
113541: PUSH
113542: EMPTY
113543: LIST
113544: LIST
113545: LIST
113546: PUSH
113547: EMPTY
113548: LIST
113549: LIST
113550: PPUSH
113551: CALL_OW 69
113555: ST_TO_ADDR
// if not tmp then
113556: LD_VAR 0 2
113560: NOT
113561: IFFALSE 113565
// exit ;
113563: GO 113594
// for i in tmp do
113565: LD_ADDR_VAR 0 1
113569: PUSH
113570: LD_VAR 0 2
113574: PUSH
113575: FOR_IN
113576: IFFALSE 113592
// begin SetLives ( i , 0 ) ;
113578: LD_VAR 0 1
113582: PPUSH
113583: LD_INT 0
113585: PPUSH
113586: CALL_OW 234
// end ;
113590: GO 113575
113592: POP
113593: POP
// end ;
113594: PPOPN 2
113596: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113597: LD_EXP 141
113601: PUSH
113602: LD_EXP 151
113606: AND
113607: IFFALSE 113627
113609: GO 113611
113611: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113612: LD_INT 32
113614: PPUSH
113615: LD_OWVAR 2
113619: PPUSH
113620: LD_INT 0
113622: PPUSH
113623: CALL_OW 324
113627: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113628: LD_EXP 141
113632: PUSH
113633: LD_EXP 152
113637: AND
113638: IFFALSE 113819
113640: GO 113642
113642: DISABLE
113643: LD_INT 0
113645: PPUSH
113646: PPUSH
113647: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113648: LD_ADDR_VAR 0 2
113652: PUSH
113653: LD_INT 22
113655: PUSH
113656: LD_OWVAR 2
113660: PUSH
113661: EMPTY
113662: LIST
113663: LIST
113664: PUSH
113665: LD_INT 33
113667: PUSH
113668: LD_INT 3
113670: PUSH
113671: EMPTY
113672: LIST
113673: LIST
113674: PUSH
113675: EMPTY
113676: LIST
113677: LIST
113678: PPUSH
113679: CALL_OW 69
113683: ST_TO_ADDR
// if not tmp then
113684: LD_VAR 0 2
113688: NOT
113689: IFFALSE 113693
// exit ;
113691: GO 113819
// side := 0 ;
113693: LD_ADDR_VAR 0 3
113697: PUSH
113698: LD_INT 0
113700: ST_TO_ADDR
// for i := 1 to 8 do
113701: LD_ADDR_VAR 0 1
113705: PUSH
113706: DOUBLE
113707: LD_INT 1
113709: DEC
113710: ST_TO_ADDR
113711: LD_INT 8
113713: PUSH
113714: FOR_TO
113715: IFFALSE 113763
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113717: LD_OWVAR 2
113721: PUSH
113722: LD_VAR 0 1
113726: NONEQUAL
113727: PUSH
113728: LD_OWVAR 2
113732: PPUSH
113733: LD_VAR 0 1
113737: PPUSH
113738: CALL_OW 81
113742: PUSH
113743: LD_INT 2
113745: EQUAL
113746: AND
113747: IFFALSE 113761
// begin side := i ;
113749: LD_ADDR_VAR 0 3
113753: PUSH
113754: LD_VAR 0 1
113758: ST_TO_ADDR
// break ;
113759: GO 113763
// end ;
113761: GO 113714
113763: POP
113764: POP
// if not side then
113765: LD_VAR 0 3
113769: NOT
113770: IFFALSE 113774
// exit ;
113772: GO 113819
// for i := 1 to tmp do
113774: LD_ADDR_VAR 0 1
113778: PUSH
113779: DOUBLE
113780: LD_INT 1
113782: DEC
113783: ST_TO_ADDR
113784: LD_VAR 0 2
113788: PUSH
113789: FOR_TO
113790: IFFALSE 113817
// if Prob ( 60 ) then
113792: LD_INT 60
113794: PPUSH
113795: CALL_OW 13
113799: IFFALSE 113815
// SetSide ( i , side ) ;
113801: LD_VAR 0 1
113805: PPUSH
113806: LD_VAR 0 3
113810: PPUSH
113811: CALL_OW 235
113815: GO 113789
113817: POP
113818: POP
// end ;
113819: PPOPN 3
113821: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
113822: LD_EXP 141
113826: PUSH
113827: LD_EXP 154
113831: AND
113832: IFFALSE 113951
113834: GO 113836
113836: DISABLE
113837: LD_INT 0
113839: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
113840: LD_ADDR_VAR 0 1
113844: PUSH
113845: LD_INT 22
113847: PUSH
113848: LD_OWVAR 2
113852: PUSH
113853: EMPTY
113854: LIST
113855: LIST
113856: PUSH
113857: LD_INT 21
113859: PUSH
113860: LD_INT 1
113862: PUSH
113863: EMPTY
113864: LIST
113865: LIST
113866: PUSH
113867: LD_INT 3
113869: PUSH
113870: LD_INT 23
113872: PUSH
113873: LD_INT 0
113875: PUSH
113876: EMPTY
113877: LIST
113878: LIST
113879: PUSH
113880: EMPTY
113881: LIST
113882: LIST
113883: PUSH
113884: EMPTY
113885: LIST
113886: LIST
113887: LIST
113888: PPUSH
113889: CALL_OW 69
113893: PUSH
113894: FOR_IN
113895: IFFALSE 113949
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
113897: LD_VAR 0 1
113901: PPUSH
113902: CALL_OW 257
113906: PUSH
113907: LD_INT 1
113909: PUSH
113910: LD_INT 2
113912: PUSH
113913: LD_INT 3
113915: PUSH
113916: LD_INT 4
113918: PUSH
113919: EMPTY
113920: LIST
113921: LIST
113922: LIST
113923: LIST
113924: IN
113925: IFFALSE 113947
// SetClass ( un , rand ( 1 , 4 ) ) ;
113927: LD_VAR 0 1
113931: PPUSH
113932: LD_INT 1
113934: PPUSH
113935: LD_INT 4
113937: PPUSH
113938: CALL_OW 12
113942: PPUSH
113943: CALL_OW 336
113947: GO 113894
113949: POP
113950: POP
// end ;
113951: PPOPN 1
113953: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
113954: LD_EXP 141
113958: PUSH
113959: LD_EXP 153
113963: AND
113964: IFFALSE 114043
113966: GO 113968
113968: DISABLE
113969: LD_INT 0
113971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
113972: LD_ADDR_VAR 0 1
113976: PUSH
113977: LD_INT 22
113979: PUSH
113980: LD_OWVAR 2
113984: PUSH
113985: EMPTY
113986: LIST
113987: LIST
113988: PUSH
113989: LD_INT 21
113991: PUSH
113992: LD_INT 3
113994: PUSH
113995: EMPTY
113996: LIST
113997: LIST
113998: PUSH
113999: EMPTY
114000: LIST
114001: LIST
114002: PPUSH
114003: CALL_OW 69
114007: ST_TO_ADDR
// if not tmp then
114008: LD_VAR 0 1
114012: NOT
114013: IFFALSE 114017
// exit ;
114015: GO 114043
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114017: LD_VAR 0 1
114021: PUSH
114022: LD_INT 1
114024: PPUSH
114025: LD_VAR 0 1
114029: PPUSH
114030: CALL_OW 12
114034: ARRAY
114035: PPUSH
114036: LD_INT 100
114038: PPUSH
114039: CALL_OW 234
// end ;
114043: PPOPN 1
114045: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114046: LD_EXP 141
114050: PUSH
114051: LD_EXP 155
114055: AND
114056: IFFALSE 114154
114058: GO 114060
114060: DISABLE
114061: LD_INT 0
114063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114064: LD_ADDR_VAR 0 1
114068: PUSH
114069: LD_INT 22
114071: PUSH
114072: LD_OWVAR 2
114076: PUSH
114077: EMPTY
114078: LIST
114079: LIST
114080: PUSH
114081: LD_INT 21
114083: PUSH
114084: LD_INT 1
114086: PUSH
114087: EMPTY
114088: LIST
114089: LIST
114090: PUSH
114091: EMPTY
114092: LIST
114093: LIST
114094: PPUSH
114095: CALL_OW 69
114099: ST_TO_ADDR
// if not tmp then
114100: LD_VAR 0 1
114104: NOT
114105: IFFALSE 114109
// exit ;
114107: GO 114154
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114109: LD_VAR 0 1
114113: PUSH
114114: LD_INT 1
114116: PPUSH
114117: LD_VAR 0 1
114121: PPUSH
114122: CALL_OW 12
114126: ARRAY
114127: PPUSH
114128: LD_INT 1
114130: PPUSH
114131: LD_INT 4
114133: PPUSH
114134: CALL_OW 12
114138: PPUSH
114139: LD_INT 3000
114141: PPUSH
114142: LD_INT 9000
114144: PPUSH
114145: CALL_OW 12
114149: PPUSH
114150: CALL_OW 492
// end ;
114154: PPOPN 1
114156: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114157: LD_EXP 141
114161: PUSH
114162: LD_EXP 156
114166: AND
114167: IFFALSE 114187
114169: GO 114171
114171: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114172: LD_INT 1
114174: PPUSH
114175: LD_OWVAR 2
114179: PPUSH
114180: LD_INT 0
114182: PPUSH
114183: CALL_OW 324
114187: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114188: LD_EXP 141
114192: PUSH
114193: LD_EXP 157
114197: AND
114198: IFFALSE 114281
114200: GO 114202
114202: DISABLE
114203: LD_INT 0
114205: PPUSH
114206: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114207: LD_ADDR_VAR 0 2
114211: PUSH
114212: LD_INT 22
114214: PUSH
114215: LD_OWVAR 2
114219: PUSH
114220: EMPTY
114221: LIST
114222: LIST
114223: PUSH
114224: LD_INT 21
114226: PUSH
114227: LD_INT 3
114229: PUSH
114230: EMPTY
114231: LIST
114232: LIST
114233: PUSH
114234: EMPTY
114235: LIST
114236: LIST
114237: PPUSH
114238: CALL_OW 69
114242: ST_TO_ADDR
// if not tmp then
114243: LD_VAR 0 2
114247: NOT
114248: IFFALSE 114252
// exit ;
114250: GO 114281
// for i in tmp do
114252: LD_ADDR_VAR 0 1
114256: PUSH
114257: LD_VAR 0 2
114261: PUSH
114262: FOR_IN
114263: IFFALSE 114279
// SetBLevel ( i , 10 ) ;
114265: LD_VAR 0 1
114269: PPUSH
114270: LD_INT 10
114272: PPUSH
114273: CALL_OW 241
114277: GO 114262
114279: POP
114280: POP
// end ;
114281: PPOPN 2
114283: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114284: LD_EXP 141
114288: PUSH
114289: LD_EXP 158
114293: AND
114294: IFFALSE 114405
114296: GO 114298
114298: DISABLE
114299: LD_INT 0
114301: PPUSH
114302: PPUSH
114303: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114304: LD_ADDR_VAR 0 3
114308: PUSH
114309: LD_INT 22
114311: PUSH
114312: LD_OWVAR 2
114316: PUSH
114317: EMPTY
114318: LIST
114319: LIST
114320: PUSH
114321: LD_INT 25
114323: PUSH
114324: LD_INT 1
114326: PUSH
114327: EMPTY
114328: LIST
114329: LIST
114330: PUSH
114331: EMPTY
114332: LIST
114333: LIST
114334: PPUSH
114335: CALL_OW 69
114339: ST_TO_ADDR
// if not tmp then
114340: LD_VAR 0 3
114344: NOT
114345: IFFALSE 114349
// exit ;
114347: GO 114405
// un := tmp [ rand ( 1 , tmp ) ] ;
114349: LD_ADDR_VAR 0 2
114353: PUSH
114354: LD_VAR 0 3
114358: PUSH
114359: LD_INT 1
114361: PPUSH
114362: LD_VAR 0 3
114366: PPUSH
114367: CALL_OW 12
114371: ARRAY
114372: ST_TO_ADDR
// if Crawls ( un ) then
114373: LD_VAR 0 2
114377: PPUSH
114378: CALL_OW 318
114382: IFFALSE 114393
// ComWalk ( un ) ;
114384: LD_VAR 0 2
114388: PPUSH
114389: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114393: LD_VAR 0 2
114397: PPUSH
114398: LD_INT 5
114400: PPUSH
114401: CALL_OW 336
// end ;
114405: PPOPN 3
114407: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
114408: LD_EXP 141
114412: PUSH
114413: LD_EXP 159
114417: AND
114418: PUSH
114419: LD_OWVAR 67
114423: PUSH
114424: LD_INT 4
114426: LESS
114427: AND
114428: IFFALSE 114447
114430: GO 114432
114432: DISABLE
// begin Difficulty := Difficulty + 1 ;
114433: LD_ADDR_OWVAR 67
114437: PUSH
114438: LD_OWVAR 67
114442: PUSH
114443: LD_INT 1
114445: PLUS
114446: ST_TO_ADDR
// end ;
114447: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114448: LD_EXP 141
114452: PUSH
114453: LD_EXP 160
114457: AND
114458: IFFALSE 114561
114460: GO 114462
114462: DISABLE
114463: LD_INT 0
114465: PPUSH
// begin for i := 1 to 5 do
114466: LD_ADDR_VAR 0 1
114470: PUSH
114471: DOUBLE
114472: LD_INT 1
114474: DEC
114475: ST_TO_ADDR
114476: LD_INT 5
114478: PUSH
114479: FOR_TO
114480: IFFALSE 114559
// begin uc_nation := nation_nature ;
114482: LD_ADDR_OWVAR 21
114486: PUSH
114487: LD_INT 0
114489: ST_TO_ADDR
// uc_side := 0 ;
114490: LD_ADDR_OWVAR 20
114494: PUSH
114495: LD_INT 0
114497: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114498: LD_ADDR_OWVAR 29
114502: PUSH
114503: LD_INT 12
114505: PUSH
114506: LD_INT 12
114508: PUSH
114509: EMPTY
114510: LIST
114511: LIST
114512: ST_TO_ADDR
// hc_agressivity := 20 ;
114513: LD_ADDR_OWVAR 35
114517: PUSH
114518: LD_INT 20
114520: ST_TO_ADDR
// hc_class := class_tiger ;
114521: LD_ADDR_OWVAR 28
114525: PUSH
114526: LD_INT 14
114528: ST_TO_ADDR
// hc_gallery :=  ;
114529: LD_ADDR_OWVAR 33
114533: PUSH
114534: LD_STRING 
114536: ST_TO_ADDR
// hc_name :=  ;
114537: LD_ADDR_OWVAR 26
114541: PUSH
114542: LD_STRING 
114544: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114545: CALL_OW 44
114549: PPUSH
114550: LD_INT 0
114552: PPUSH
114553: CALL_OW 51
// end ;
114557: GO 114479
114559: POP
114560: POP
// end ;
114561: PPOPN 1
114563: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114564: LD_EXP 141
114568: PUSH
114569: LD_EXP 161
114573: AND
114574: IFFALSE 114583
114576: GO 114578
114578: DISABLE
// StreamSibBomb ;
114579: CALL 114584 0 0
114583: END
// export function StreamSibBomb ; var i , x , y ; begin
114584: LD_INT 0
114586: PPUSH
114587: PPUSH
114588: PPUSH
114589: PPUSH
// result := false ;
114590: LD_ADDR_VAR 0 1
114594: PUSH
114595: LD_INT 0
114597: ST_TO_ADDR
// for i := 1 to 16 do
114598: LD_ADDR_VAR 0 2
114602: PUSH
114603: DOUBLE
114604: LD_INT 1
114606: DEC
114607: ST_TO_ADDR
114608: LD_INT 16
114610: PUSH
114611: FOR_TO
114612: IFFALSE 114811
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114614: LD_ADDR_VAR 0 3
114618: PUSH
114619: LD_INT 10
114621: PUSH
114622: LD_INT 20
114624: PUSH
114625: LD_INT 30
114627: PUSH
114628: LD_INT 40
114630: PUSH
114631: LD_INT 50
114633: PUSH
114634: LD_INT 60
114636: PUSH
114637: LD_INT 70
114639: PUSH
114640: LD_INT 80
114642: PUSH
114643: LD_INT 90
114645: PUSH
114646: LD_INT 100
114648: PUSH
114649: LD_INT 110
114651: PUSH
114652: LD_INT 120
114654: PUSH
114655: LD_INT 130
114657: PUSH
114658: LD_INT 140
114660: PUSH
114661: LD_INT 150
114663: PUSH
114664: EMPTY
114665: LIST
114666: LIST
114667: LIST
114668: LIST
114669: LIST
114670: LIST
114671: LIST
114672: LIST
114673: LIST
114674: LIST
114675: LIST
114676: LIST
114677: LIST
114678: LIST
114679: LIST
114680: PUSH
114681: LD_INT 1
114683: PPUSH
114684: LD_INT 15
114686: PPUSH
114687: CALL_OW 12
114691: ARRAY
114692: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114693: LD_ADDR_VAR 0 4
114697: PUSH
114698: LD_INT 10
114700: PUSH
114701: LD_INT 20
114703: PUSH
114704: LD_INT 30
114706: PUSH
114707: LD_INT 40
114709: PUSH
114710: LD_INT 50
114712: PUSH
114713: LD_INT 60
114715: PUSH
114716: LD_INT 70
114718: PUSH
114719: LD_INT 80
114721: PUSH
114722: LD_INT 90
114724: PUSH
114725: LD_INT 100
114727: PUSH
114728: LD_INT 110
114730: PUSH
114731: LD_INT 120
114733: PUSH
114734: LD_INT 130
114736: PUSH
114737: LD_INT 140
114739: PUSH
114740: LD_INT 150
114742: PUSH
114743: EMPTY
114744: LIST
114745: LIST
114746: LIST
114747: LIST
114748: LIST
114749: LIST
114750: LIST
114751: LIST
114752: LIST
114753: LIST
114754: LIST
114755: LIST
114756: LIST
114757: LIST
114758: LIST
114759: PUSH
114760: LD_INT 1
114762: PPUSH
114763: LD_INT 15
114765: PPUSH
114766: CALL_OW 12
114770: ARRAY
114771: ST_TO_ADDR
// if ValidHex ( x , y ) then
114772: LD_VAR 0 3
114776: PPUSH
114777: LD_VAR 0 4
114781: PPUSH
114782: CALL_OW 488
114786: IFFALSE 114809
// begin result := [ x , y ] ;
114788: LD_ADDR_VAR 0 1
114792: PUSH
114793: LD_VAR 0 3
114797: PUSH
114798: LD_VAR 0 4
114802: PUSH
114803: EMPTY
114804: LIST
114805: LIST
114806: ST_TO_ADDR
// break ;
114807: GO 114811
// end ; end ;
114809: GO 114611
114811: POP
114812: POP
// if result then
114813: LD_VAR 0 1
114817: IFFALSE 114877
// begin ToLua ( playSibBomb() ) ;
114819: LD_STRING playSibBomb()
114821: PPUSH
114822: CALL_OW 559
// wait ( 0 0$14 ) ;
114826: LD_INT 490
114828: PPUSH
114829: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
114833: LD_VAR 0 1
114837: PUSH
114838: LD_INT 1
114840: ARRAY
114841: PPUSH
114842: LD_VAR 0 1
114846: PUSH
114847: LD_INT 2
114849: ARRAY
114850: PPUSH
114851: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
114855: LD_VAR 0 1
114859: PUSH
114860: LD_INT 1
114862: ARRAY
114863: PPUSH
114864: LD_VAR 0 1
114868: PUSH
114869: LD_INT 2
114871: ARRAY
114872: PPUSH
114873: CALL_OW 429
// end ; end ;
114877: LD_VAR 0 1
114881: RET
// every 0 0$1 trigger StreamModeActive and sReset do
114882: LD_EXP 141
114886: PUSH
114887: LD_EXP 163
114891: AND
114892: IFFALSE 114904
114894: GO 114896
114896: DISABLE
// YouLost (  ) ;
114897: LD_STRING 
114899: PPUSH
114900: CALL_OW 104
114904: END
// every 0 0$1 trigger StreamModeActive and sFog do
114905: LD_EXP 141
114909: PUSH
114910: LD_EXP 162
114914: AND
114915: IFFALSE 114929
114917: GO 114919
114919: DISABLE
// FogOff ( your_side ) ;
114920: LD_OWVAR 2
114924: PPUSH
114925: CALL_OW 344
114929: END
// every 0 0$1 trigger StreamModeActive and sSun do
114930: LD_EXP 141
114934: PUSH
114935: LD_EXP 164
114939: AND
114940: IFFALSE 114968
114942: GO 114944
114944: DISABLE
// begin solar_recharge_percent := 0 ;
114945: LD_ADDR_OWVAR 79
114949: PUSH
114950: LD_INT 0
114952: ST_TO_ADDR
// wait ( 5 5$00 ) ;
114953: LD_INT 10500
114955: PPUSH
114956: CALL_OW 67
// solar_recharge_percent := 100 ;
114960: LD_ADDR_OWVAR 79
114964: PUSH
114965: LD_INT 100
114967: ST_TO_ADDR
// end ;
114968: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
114969: LD_EXP 141
114973: PUSH
114974: LD_EXP 165
114978: AND
114979: IFFALSE 115218
114981: GO 114983
114983: DISABLE
114984: LD_INT 0
114986: PPUSH
114987: PPUSH
114988: PPUSH
// begin tmp := [ ] ;
114989: LD_ADDR_VAR 0 3
114993: PUSH
114994: EMPTY
114995: ST_TO_ADDR
// for i := 1 to 6 do
114996: LD_ADDR_VAR 0 1
115000: PUSH
115001: DOUBLE
115002: LD_INT 1
115004: DEC
115005: ST_TO_ADDR
115006: LD_INT 6
115008: PUSH
115009: FOR_TO
115010: IFFALSE 115115
// begin uc_nation := nation_nature ;
115012: LD_ADDR_OWVAR 21
115016: PUSH
115017: LD_INT 0
115019: ST_TO_ADDR
// uc_side := 0 ;
115020: LD_ADDR_OWVAR 20
115024: PUSH
115025: LD_INT 0
115027: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115028: LD_ADDR_OWVAR 29
115032: PUSH
115033: LD_INT 12
115035: PUSH
115036: LD_INT 12
115038: PUSH
115039: EMPTY
115040: LIST
115041: LIST
115042: ST_TO_ADDR
// hc_agressivity := 20 ;
115043: LD_ADDR_OWVAR 35
115047: PUSH
115048: LD_INT 20
115050: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115051: LD_ADDR_OWVAR 28
115055: PUSH
115056: LD_INT 17
115058: ST_TO_ADDR
// hc_gallery :=  ;
115059: LD_ADDR_OWVAR 33
115063: PUSH
115064: LD_STRING 
115066: ST_TO_ADDR
// hc_name :=  ;
115067: LD_ADDR_OWVAR 26
115071: PUSH
115072: LD_STRING 
115074: ST_TO_ADDR
// un := CreateHuman ;
115075: LD_ADDR_VAR 0 2
115079: PUSH
115080: CALL_OW 44
115084: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115085: LD_VAR 0 2
115089: PPUSH
115090: LD_INT 1
115092: PPUSH
115093: CALL_OW 51
// tmp := tmp ^ un ;
115097: LD_ADDR_VAR 0 3
115101: PUSH
115102: LD_VAR 0 3
115106: PUSH
115107: LD_VAR 0 2
115111: ADD
115112: ST_TO_ADDR
// end ;
115113: GO 115009
115115: POP
115116: POP
// repeat wait ( 0 0$1 ) ;
115117: LD_INT 35
115119: PPUSH
115120: CALL_OW 67
// for un in tmp do
115124: LD_ADDR_VAR 0 2
115128: PUSH
115129: LD_VAR 0 3
115133: PUSH
115134: FOR_IN
115135: IFFALSE 115209
// begin if IsDead ( un ) then
115137: LD_VAR 0 2
115141: PPUSH
115142: CALL_OW 301
115146: IFFALSE 115166
// begin tmp := tmp diff un ;
115148: LD_ADDR_VAR 0 3
115152: PUSH
115153: LD_VAR 0 3
115157: PUSH
115158: LD_VAR 0 2
115162: DIFF
115163: ST_TO_ADDR
// continue ;
115164: GO 115134
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115166: LD_VAR 0 2
115170: PPUSH
115171: LD_INT 3
115173: PUSH
115174: LD_INT 22
115176: PUSH
115177: LD_INT 0
115179: PUSH
115180: EMPTY
115181: LIST
115182: LIST
115183: PUSH
115184: EMPTY
115185: LIST
115186: LIST
115187: PPUSH
115188: CALL_OW 69
115192: PPUSH
115193: LD_VAR 0 2
115197: PPUSH
115198: CALL_OW 74
115202: PPUSH
115203: CALL_OW 115
// end ;
115207: GO 115134
115209: POP
115210: POP
// until not tmp ;
115211: LD_VAR 0 3
115215: NOT
115216: IFFALSE 115117
// end ;
115218: PPOPN 3
115220: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115221: LD_EXP 141
115225: PUSH
115226: LD_EXP 166
115230: AND
115231: IFFALSE 115285
115233: GO 115235
115235: DISABLE
// begin ToLua ( displayTroll(); ) ;
115236: LD_STRING displayTroll();
115238: PPUSH
115239: CALL_OW 559
// wait ( 3 3$00 ) ;
115243: LD_INT 6300
115245: PPUSH
115246: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115250: LD_STRING hideTroll();
115252: PPUSH
115253: CALL_OW 559
// wait ( 1 1$00 ) ;
115257: LD_INT 2100
115259: PPUSH
115260: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115264: LD_STRING displayTroll();
115266: PPUSH
115267: CALL_OW 559
// wait ( 1 1$00 ) ;
115271: LD_INT 2100
115273: PPUSH
115274: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115278: LD_STRING hideTroll();
115280: PPUSH
115281: CALL_OW 559
// end ;
115285: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115286: LD_EXP 141
115290: PUSH
115291: LD_EXP 167
115295: AND
115296: IFFALSE 115359
115298: GO 115300
115300: DISABLE
115301: LD_INT 0
115303: PPUSH
// begin p := 0 ;
115304: LD_ADDR_VAR 0 1
115308: PUSH
115309: LD_INT 0
115311: ST_TO_ADDR
// repeat game_speed := 1 ;
115312: LD_ADDR_OWVAR 65
115316: PUSH
115317: LD_INT 1
115319: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115320: LD_INT 35
115322: PPUSH
115323: CALL_OW 67
// p := p + 1 ;
115327: LD_ADDR_VAR 0 1
115331: PUSH
115332: LD_VAR 0 1
115336: PUSH
115337: LD_INT 1
115339: PLUS
115340: ST_TO_ADDR
// until p >= 60 ;
115341: LD_VAR 0 1
115345: PUSH
115346: LD_INT 60
115348: GREATEREQUAL
115349: IFFALSE 115312
// game_speed := 4 ;
115351: LD_ADDR_OWVAR 65
115355: PUSH
115356: LD_INT 4
115358: ST_TO_ADDR
// end ;
115359: PPOPN 1
115361: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115362: LD_EXP 141
115366: PUSH
115367: LD_EXP 168
115371: AND
115372: IFFALSE 115518
115374: GO 115376
115376: DISABLE
115377: LD_INT 0
115379: PPUSH
115380: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115381: LD_ADDR_VAR 0 1
115385: PUSH
115386: LD_INT 22
115388: PUSH
115389: LD_OWVAR 2
115393: PUSH
115394: EMPTY
115395: LIST
115396: LIST
115397: PUSH
115398: LD_INT 2
115400: PUSH
115401: LD_INT 30
115403: PUSH
115404: LD_INT 0
115406: PUSH
115407: EMPTY
115408: LIST
115409: LIST
115410: PUSH
115411: LD_INT 30
115413: PUSH
115414: LD_INT 1
115416: PUSH
115417: EMPTY
115418: LIST
115419: LIST
115420: PUSH
115421: EMPTY
115422: LIST
115423: LIST
115424: LIST
115425: PUSH
115426: EMPTY
115427: LIST
115428: LIST
115429: PPUSH
115430: CALL_OW 69
115434: ST_TO_ADDR
// if not depot then
115435: LD_VAR 0 1
115439: NOT
115440: IFFALSE 115444
// exit ;
115442: GO 115518
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115444: LD_ADDR_VAR 0 2
115448: PUSH
115449: LD_VAR 0 1
115453: PUSH
115454: LD_INT 1
115456: PPUSH
115457: LD_VAR 0 1
115461: PPUSH
115462: CALL_OW 12
115466: ARRAY
115467: PPUSH
115468: CALL_OW 274
115472: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115473: LD_VAR 0 2
115477: PPUSH
115478: LD_INT 1
115480: PPUSH
115481: LD_INT 0
115483: PPUSH
115484: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115488: LD_VAR 0 2
115492: PPUSH
115493: LD_INT 2
115495: PPUSH
115496: LD_INT 0
115498: PPUSH
115499: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115503: LD_VAR 0 2
115507: PPUSH
115508: LD_INT 3
115510: PPUSH
115511: LD_INT 0
115513: PPUSH
115514: CALL_OW 277
// end ;
115518: PPOPN 2
115520: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115521: LD_EXP 141
115525: PUSH
115526: LD_EXP 169
115530: AND
115531: IFFALSE 115628
115533: GO 115535
115535: DISABLE
115536: LD_INT 0
115538: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115539: LD_ADDR_VAR 0 1
115543: PUSH
115544: LD_INT 22
115546: PUSH
115547: LD_OWVAR 2
115551: PUSH
115552: EMPTY
115553: LIST
115554: LIST
115555: PUSH
115556: LD_INT 21
115558: PUSH
115559: LD_INT 1
115561: PUSH
115562: EMPTY
115563: LIST
115564: LIST
115565: PUSH
115566: LD_INT 3
115568: PUSH
115569: LD_INT 23
115571: PUSH
115572: LD_INT 0
115574: PUSH
115575: EMPTY
115576: LIST
115577: LIST
115578: PUSH
115579: EMPTY
115580: LIST
115581: LIST
115582: PUSH
115583: EMPTY
115584: LIST
115585: LIST
115586: LIST
115587: PPUSH
115588: CALL_OW 69
115592: ST_TO_ADDR
// if not tmp then
115593: LD_VAR 0 1
115597: NOT
115598: IFFALSE 115602
// exit ;
115600: GO 115628
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115602: LD_VAR 0 1
115606: PUSH
115607: LD_INT 1
115609: PPUSH
115610: LD_VAR 0 1
115614: PPUSH
115615: CALL_OW 12
115619: ARRAY
115620: PPUSH
115621: LD_INT 200
115623: PPUSH
115624: CALL_OW 234
// end ;
115628: PPOPN 1
115630: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115631: LD_EXP 141
115635: PUSH
115636: LD_EXP 170
115640: AND
115641: IFFALSE 115720
115643: GO 115645
115645: DISABLE
115646: LD_INT 0
115648: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115649: LD_ADDR_VAR 0 1
115653: PUSH
115654: LD_INT 22
115656: PUSH
115657: LD_OWVAR 2
115661: PUSH
115662: EMPTY
115663: LIST
115664: LIST
115665: PUSH
115666: LD_INT 21
115668: PUSH
115669: LD_INT 2
115671: PUSH
115672: EMPTY
115673: LIST
115674: LIST
115675: PUSH
115676: EMPTY
115677: LIST
115678: LIST
115679: PPUSH
115680: CALL_OW 69
115684: ST_TO_ADDR
// if not tmp then
115685: LD_VAR 0 1
115689: NOT
115690: IFFALSE 115694
// exit ;
115692: GO 115720
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115694: LD_VAR 0 1
115698: PUSH
115699: LD_INT 1
115701: PPUSH
115702: LD_VAR 0 1
115706: PPUSH
115707: CALL_OW 12
115711: ARRAY
115712: PPUSH
115713: LD_INT 60
115715: PPUSH
115716: CALL_OW 234
// end ;
115720: PPOPN 1
115722: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115723: LD_EXP 141
115727: PUSH
115728: LD_EXP 171
115732: AND
115733: IFFALSE 115832
115735: GO 115737
115737: DISABLE
115738: LD_INT 0
115740: PPUSH
115741: PPUSH
// begin enable ;
115742: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115743: LD_ADDR_VAR 0 1
115747: PUSH
115748: LD_INT 22
115750: PUSH
115751: LD_OWVAR 2
115755: PUSH
115756: EMPTY
115757: LIST
115758: LIST
115759: PUSH
115760: LD_INT 61
115762: PUSH
115763: EMPTY
115764: LIST
115765: PUSH
115766: LD_INT 33
115768: PUSH
115769: LD_INT 2
115771: PUSH
115772: EMPTY
115773: LIST
115774: LIST
115775: PUSH
115776: EMPTY
115777: LIST
115778: LIST
115779: LIST
115780: PPUSH
115781: CALL_OW 69
115785: ST_TO_ADDR
// if not tmp then
115786: LD_VAR 0 1
115790: NOT
115791: IFFALSE 115795
// exit ;
115793: GO 115832
// for i in tmp do
115795: LD_ADDR_VAR 0 2
115799: PUSH
115800: LD_VAR 0 1
115804: PUSH
115805: FOR_IN
115806: IFFALSE 115830
// if IsControledBy ( i ) then
115808: LD_VAR 0 2
115812: PPUSH
115813: CALL_OW 312
115817: IFFALSE 115828
// ComUnlink ( i ) ;
115819: LD_VAR 0 2
115823: PPUSH
115824: CALL_OW 136
115828: GO 115805
115830: POP
115831: POP
// end ;
115832: PPOPN 2
115834: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
115835: LD_EXP 141
115839: PUSH
115840: LD_EXP 172
115844: AND
115845: IFFALSE 115985
115847: GO 115849
115849: DISABLE
115850: LD_INT 0
115852: PPUSH
115853: PPUSH
// begin ToLua ( displayPowell(); ) ;
115854: LD_STRING displayPowell();
115856: PPUSH
115857: CALL_OW 559
// uc_side := 0 ;
115861: LD_ADDR_OWVAR 20
115865: PUSH
115866: LD_INT 0
115868: ST_TO_ADDR
// uc_nation := 2 ;
115869: LD_ADDR_OWVAR 21
115873: PUSH
115874: LD_INT 2
115876: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
115877: LD_ADDR_OWVAR 37
115881: PUSH
115882: LD_INT 14
115884: ST_TO_ADDR
// vc_engine := engine_siberite ;
115885: LD_ADDR_OWVAR 39
115889: PUSH
115890: LD_INT 3
115892: ST_TO_ADDR
// vc_control := control_apeman ;
115893: LD_ADDR_OWVAR 38
115897: PUSH
115898: LD_INT 5
115900: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
115901: LD_ADDR_OWVAR 40
115905: PUSH
115906: LD_INT 29
115908: ST_TO_ADDR
// un := CreateVehicle ;
115909: LD_ADDR_VAR 0 2
115913: PUSH
115914: CALL_OW 45
115918: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115919: LD_VAR 0 2
115923: PPUSH
115924: LD_INT 1
115926: PPUSH
115927: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115931: LD_INT 35
115933: PPUSH
115934: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115938: LD_VAR 0 2
115942: PPUSH
115943: LD_INT 22
115945: PUSH
115946: LD_OWVAR 2
115950: PUSH
115951: EMPTY
115952: LIST
115953: LIST
115954: PPUSH
115955: CALL_OW 69
115959: PPUSH
115960: LD_VAR 0 2
115964: PPUSH
115965: CALL_OW 74
115969: PPUSH
115970: CALL_OW 115
// until IsDead ( un ) ;
115974: LD_VAR 0 2
115978: PPUSH
115979: CALL_OW 301
115983: IFFALSE 115931
// end ;
115985: PPOPN 2
115987: END
// every 0 0$1 trigger StreamModeActive and sStu do
115988: LD_EXP 141
115992: PUSH
115993: LD_EXP 180
115997: AND
115998: IFFALSE 116014
116000: GO 116002
116002: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116003: LD_STRING displayStucuk();
116005: PPUSH
116006: CALL_OW 559
// ResetFog ;
116010: CALL_OW 335
// end ;
116014: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116015: LD_EXP 141
116019: PUSH
116020: LD_EXP 173
116024: AND
116025: IFFALSE 116166
116027: GO 116029
116029: DISABLE
116030: LD_INT 0
116032: PPUSH
116033: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116034: LD_ADDR_VAR 0 2
116038: PUSH
116039: LD_INT 22
116041: PUSH
116042: LD_OWVAR 2
116046: PUSH
116047: EMPTY
116048: LIST
116049: LIST
116050: PUSH
116051: LD_INT 21
116053: PUSH
116054: LD_INT 1
116056: PUSH
116057: EMPTY
116058: LIST
116059: LIST
116060: PUSH
116061: EMPTY
116062: LIST
116063: LIST
116064: PPUSH
116065: CALL_OW 69
116069: ST_TO_ADDR
// if not tmp then
116070: LD_VAR 0 2
116074: NOT
116075: IFFALSE 116079
// exit ;
116077: GO 116166
// un := tmp [ rand ( 1 , tmp ) ] ;
116079: LD_ADDR_VAR 0 1
116083: PUSH
116084: LD_VAR 0 2
116088: PUSH
116089: LD_INT 1
116091: PPUSH
116092: LD_VAR 0 2
116096: PPUSH
116097: CALL_OW 12
116101: ARRAY
116102: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116103: LD_VAR 0 1
116107: PPUSH
116108: LD_INT 0
116110: PPUSH
116111: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116115: LD_VAR 0 1
116119: PPUSH
116120: LD_OWVAR 3
116124: PUSH
116125: LD_VAR 0 1
116129: DIFF
116130: PPUSH
116131: LD_VAR 0 1
116135: PPUSH
116136: CALL_OW 74
116140: PPUSH
116141: CALL_OW 115
// wait ( 0 0$20 ) ;
116145: LD_INT 700
116147: PPUSH
116148: CALL_OW 67
// SetSide ( un , your_side ) ;
116152: LD_VAR 0 1
116156: PPUSH
116157: LD_OWVAR 2
116161: PPUSH
116162: CALL_OW 235
// end ;
116166: PPOPN 2
116168: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116169: LD_EXP 141
116173: PUSH
116174: LD_EXP 174
116178: AND
116179: IFFALSE 116285
116181: GO 116183
116183: DISABLE
116184: LD_INT 0
116186: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116187: LD_ADDR_VAR 0 1
116191: PUSH
116192: LD_INT 22
116194: PUSH
116195: LD_OWVAR 2
116199: PUSH
116200: EMPTY
116201: LIST
116202: LIST
116203: PUSH
116204: LD_INT 2
116206: PUSH
116207: LD_INT 30
116209: PUSH
116210: LD_INT 0
116212: PUSH
116213: EMPTY
116214: LIST
116215: LIST
116216: PUSH
116217: LD_INT 30
116219: PUSH
116220: LD_INT 1
116222: PUSH
116223: EMPTY
116224: LIST
116225: LIST
116226: PUSH
116227: EMPTY
116228: LIST
116229: LIST
116230: LIST
116231: PUSH
116232: EMPTY
116233: LIST
116234: LIST
116235: PPUSH
116236: CALL_OW 69
116240: ST_TO_ADDR
// if not depot then
116241: LD_VAR 0 1
116245: NOT
116246: IFFALSE 116250
// exit ;
116248: GO 116285
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116250: LD_VAR 0 1
116254: PUSH
116255: LD_INT 1
116257: ARRAY
116258: PPUSH
116259: CALL_OW 250
116263: PPUSH
116264: LD_VAR 0 1
116268: PUSH
116269: LD_INT 1
116271: ARRAY
116272: PPUSH
116273: CALL_OW 251
116277: PPUSH
116278: LD_INT 70
116280: PPUSH
116281: CALL_OW 495
// end ;
116285: PPOPN 1
116287: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116288: LD_EXP 141
116292: PUSH
116293: LD_EXP 175
116297: AND
116298: IFFALSE 116509
116300: GO 116302
116302: DISABLE
116303: LD_INT 0
116305: PPUSH
116306: PPUSH
116307: PPUSH
116308: PPUSH
116309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116310: LD_ADDR_VAR 0 5
116314: PUSH
116315: LD_INT 22
116317: PUSH
116318: LD_OWVAR 2
116322: PUSH
116323: EMPTY
116324: LIST
116325: LIST
116326: PUSH
116327: LD_INT 21
116329: PUSH
116330: LD_INT 1
116332: PUSH
116333: EMPTY
116334: LIST
116335: LIST
116336: PUSH
116337: EMPTY
116338: LIST
116339: LIST
116340: PPUSH
116341: CALL_OW 69
116345: ST_TO_ADDR
// if not tmp then
116346: LD_VAR 0 5
116350: NOT
116351: IFFALSE 116355
// exit ;
116353: GO 116509
// for i in tmp do
116355: LD_ADDR_VAR 0 1
116359: PUSH
116360: LD_VAR 0 5
116364: PUSH
116365: FOR_IN
116366: IFFALSE 116507
// begin d := rand ( 0 , 5 ) ;
116368: LD_ADDR_VAR 0 4
116372: PUSH
116373: LD_INT 0
116375: PPUSH
116376: LD_INT 5
116378: PPUSH
116379: CALL_OW 12
116383: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116384: LD_ADDR_VAR 0 2
116388: PUSH
116389: LD_VAR 0 1
116393: PPUSH
116394: CALL_OW 250
116398: PPUSH
116399: LD_VAR 0 4
116403: PPUSH
116404: LD_INT 3
116406: PPUSH
116407: LD_INT 12
116409: PPUSH
116410: CALL_OW 12
116414: PPUSH
116415: CALL_OW 272
116419: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116420: LD_ADDR_VAR 0 3
116424: PUSH
116425: LD_VAR 0 1
116429: PPUSH
116430: CALL_OW 251
116434: PPUSH
116435: LD_VAR 0 4
116439: PPUSH
116440: LD_INT 3
116442: PPUSH
116443: LD_INT 12
116445: PPUSH
116446: CALL_OW 12
116450: PPUSH
116451: CALL_OW 273
116455: ST_TO_ADDR
// if ValidHex ( x , y ) then
116456: LD_VAR 0 2
116460: PPUSH
116461: LD_VAR 0 3
116465: PPUSH
116466: CALL_OW 488
116470: IFFALSE 116505
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116472: LD_VAR 0 1
116476: PPUSH
116477: LD_VAR 0 2
116481: PPUSH
116482: LD_VAR 0 3
116486: PPUSH
116487: LD_INT 3
116489: PPUSH
116490: LD_INT 6
116492: PPUSH
116493: CALL_OW 12
116497: PPUSH
116498: LD_INT 1
116500: PPUSH
116501: CALL_OW 483
// end ;
116505: GO 116365
116507: POP
116508: POP
// end ;
116509: PPOPN 5
116511: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116512: LD_EXP 141
116516: PUSH
116517: LD_EXP 176
116521: AND
116522: IFFALSE 116616
116524: GO 116526
116526: DISABLE
116527: LD_INT 0
116529: PPUSH
116530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116531: LD_ADDR_VAR 0 2
116535: PUSH
116536: LD_INT 22
116538: PUSH
116539: LD_OWVAR 2
116543: PUSH
116544: EMPTY
116545: LIST
116546: LIST
116547: PUSH
116548: LD_INT 32
116550: PUSH
116551: LD_INT 1
116553: PUSH
116554: EMPTY
116555: LIST
116556: LIST
116557: PUSH
116558: LD_INT 21
116560: PUSH
116561: LD_INT 2
116563: PUSH
116564: EMPTY
116565: LIST
116566: LIST
116567: PUSH
116568: EMPTY
116569: LIST
116570: LIST
116571: LIST
116572: PPUSH
116573: CALL_OW 69
116577: ST_TO_ADDR
// if not tmp then
116578: LD_VAR 0 2
116582: NOT
116583: IFFALSE 116587
// exit ;
116585: GO 116616
// for i in tmp do
116587: LD_ADDR_VAR 0 1
116591: PUSH
116592: LD_VAR 0 2
116596: PUSH
116597: FOR_IN
116598: IFFALSE 116614
// SetFuel ( i , 0 ) ;
116600: LD_VAR 0 1
116604: PPUSH
116605: LD_INT 0
116607: PPUSH
116608: CALL_OW 240
116612: GO 116597
116614: POP
116615: POP
// end ;
116616: PPOPN 2
116618: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116619: LD_EXP 141
116623: PUSH
116624: LD_EXP 177
116628: AND
116629: IFFALSE 116695
116631: GO 116633
116633: DISABLE
116634: LD_INT 0
116636: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116637: LD_ADDR_VAR 0 1
116641: PUSH
116642: LD_INT 22
116644: PUSH
116645: LD_OWVAR 2
116649: PUSH
116650: EMPTY
116651: LIST
116652: LIST
116653: PUSH
116654: LD_INT 30
116656: PUSH
116657: LD_INT 29
116659: PUSH
116660: EMPTY
116661: LIST
116662: LIST
116663: PUSH
116664: EMPTY
116665: LIST
116666: LIST
116667: PPUSH
116668: CALL_OW 69
116672: ST_TO_ADDR
// if not tmp then
116673: LD_VAR 0 1
116677: NOT
116678: IFFALSE 116682
// exit ;
116680: GO 116695
// DestroyUnit ( tmp [ 1 ] ) ;
116682: LD_VAR 0 1
116686: PUSH
116687: LD_INT 1
116689: ARRAY
116690: PPUSH
116691: CALL_OW 65
// end ;
116695: PPOPN 1
116697: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116698: LD_EXP 141
116702: PUSH
116703: LD_EXP 179
116707: AND
116708: IFFALSE 116837
116710: GO 116712
116712: DISABLE
116713: LD_INT 0
116715: PPUSH
// begin uc_side := 0 ;
116716: LD_ADDR_OWVAR 20
116720: PUSH
116721: LD_INT 0
116723: ST_TO_ADDR
// uc_nation := nation_arabian ;
116724: LD_ADDR_OWVAR 21
116728: PUSH
116729: LD_INT 2
116731: ST_TO_ADDR
// hc_gallery :=  ;
116732: LD_ADDR_OWVAR 33
116736: PUSH
116737: LD_STRING 
116739: ST_TO_ADDR
// hc_name :=  ;
116740: LD_ADDR_OWVAR 26
116744: PUSH
116745: LD_STRING 
116747: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116748: LD_INT 1
116750: PPUSH
116751: LD_INT 11
116753: PPUSH
116754: LD_INT 10
116756: PPUSH
116757: CALL_OW 380
// un := CreateHuman ;
116761: LD_ADDR_VAR 0 1
116765: PUSH
116766: CALL_OW 44
116770: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116771: LD_VAR 0 1
116775: PPUSH
116776: LD_INT 1
116778: PPUSH
116779: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116783: LD_INT 35
116785: PPUSH
116786: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116790: LD_VAR 0 1
116794: PPUSH
116795: LD_INT 22
116797: PUSH
116798: LD_OWVAR 2
116802: PUSH
116803: EMPTY
116804: LIST
116805: LIST
116806: PPUSH
116807: CALL_OW 69
116811: PPUSH
116812: LD_VAR 0 1
116816: PPUSH
116817: CALL_OW 74
116821: PPUSH
116822: CALL_OW 115
// until IsDead ( un ) ;
116826: LD_VAR 0 1
116830: PPUSH
116831: CALL_OW 301
116835: IFFALSE 116783
// end ;
116837: PPOPN 1
116839: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
116840: LD_EXP 141
116844: PUSH
116845: LD_EXP 181
116849: AND
116850: IFFALSE 116862
116852: GO 116854
116854: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
116855: LD_STRING earthquake(getX(game), 0, 32)
116857: PPUSH
116858: CALL_OW 559
116862: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
116863: LD_EXP 141
116867: PUSH
116868: LD_EXP 182
116872: AND
116873: IFFALSE 116964
116875: GO 116877
116877: DISABLE
116878: LD_INT 0
116880: PPUSH
// begin enable ;
116881: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
116882: LD_ADDR_VAR 0 1
116886: PUSH
116887: LD_INT 22
116889: PUSH
116890: LD_OWVAR 2
116894: PUSH
116895: EMPTY
116896: LIST
116897: LIST
116898: PUSH
116899: LD_INT 21
116901: PUSH
116902: LD_INT 2
116904: PUSH
116905: EMPTY
116906: LIST
116907: LIST
116908: PUSH
116909: LD_INT 33
116911: PUSH
116912: LD_INT 3
116914: PUSH
116915: EMPTY
116916: LIST
116917: LIST
116918: PUSH
116919: EMPTY
116920: LIST
116921: LIST
116922: LIST
116923: PPUSH
116924: CALL_OW 69
116928: ST_TO_ADDR
// if not tmp then
116929: LD_VAR 0 1
116933: NOT
116934: IFFALSE 116938
// exit ;
116936: GO 116964
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116938: LD_VAR 0 1
116942: PUSH
116943: LD_INT 1
116945: PPUSH
116946: LD_VAR 0 1
116950: PPUSH
116951: CALL_OW 12
116955: ARRAY
116956: PPUSH
116957: LD_INT 1
116959: PPUSH
116960: CALL_OW 234
// end ;
116964: PPOPN 1
116966: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
116967: LD_EXP 141
116971: PUSH
116972: LD_EXP 183
116976: AND
116977: IFFALSE 117118
116979: GO 116981
116981: DISABLE
116982: LD_INT 0
116984: PPUSH
116985: PPUSH
116986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116987: LD_ADDR_VAR 0 3
116991: PUSH
116992: LD_INT 22
116994: PUSH
116995: LD_OWVAR 2
116999: PUSH
117000: EMPTY
117001: LIST
117002: LIST
117003: PUSH
117004: LD_INT 25
117006: PUSH
117007: LD_INT 1
117009: PUSH
117010: EMPTY
117011: LIST
117012: LIST
117013: PUSH
117014: EMPTY
117015: LIST
117016: LIST
117017: PPUSH
117018: CALL_OW 69
117022: ST_TO_ADDR
// if not tmp then
117023: LD_VAR 0 3
117027: NOT
117028: IFFALSE 117032
// exit ;
117030: GO 117118
// un := tmp [ rand ( 1 , tmp ) ] ;
117032: LD_ADDR_VAR 0 2
117036: PUSH
117037: LD_VAR 0 3
117041: PUSH
117042: LD_INT 1
117044: PPUSH
117045: LD_VAR 0 3
117049: PPUSH
117050: CALL_OW 12
117054: ARRAY
117055: ST_TO_ADDR
// if Crawls ( un ) then
117056: LD_VAR 0 2
117060: PPUSH
117061: CALL_OW 318
117065: IFFALSE 117076
// ComWalk ( un ) ;
117067: LD_VAR 0 2
117071: PPUSH
117072: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117076: LD_VAR 0 2
117080: PPUSH
117081: LD_INT 9
117083: PPUSH
117084: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117088: LD_INT 28
117090: PPUSH
117091: LD_OWVAR 2
117095: PPUSH
117096: LD_INT 2
117098: PPUSH
117099: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117103: LD_INT 29
117105: PPUSH
117106: LD_OWVAR 2
117110: PPUSH
117111: LD_INT 2
117113: PPUSH
117114: CALL_OW 322
// end ;
117118: PPOPN 3
117120: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117121: LD_EXP 141
117125: PUSH
117126: LD_EXP 184
117130: AND
117131: IFFALSE 117242
117133: GO 117135
117135: DISABLE
117136: LD_INT 0
117138: PPUSH
117139: PPUSH
117140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117141: LD_ADDR_VAR 0 3
117145: PUSH
117146: LD_INT 22
117148: PUSH
117149: LD_OWVAR 2
117153: PUSH
117154: EMPTY
117155: LIST
117156: LIST
117157: PUSH
117158: LD_INT 25
117160: PUSH
117161: LD_INT 1
117163: PUSH
117164: EMPTY
117165: LIST
117166: LIST
117167: PUSH
117168: EMPTY
117169: LIST
117170: LIST
117171: PPUSH
117172: CALL_OW 69
117176: ST_TO_ADDR
// if not tmp then
117177: LD_VAR 0 3
117181: NOT
117182: IFFALSE 117186
// exit ;
117184: GO 117242
// un := tmp [ rand ( 1 , tmp ) ] ;
117186: LD_ADDR_VAR 0 2
117190: PUSH
117191: LD_VAR 0 3
117195: PUSH
117196: LD_INT 1
117198: PPUSH
117199: LD_VAR 0 3
117203: PPUSH
117204: CALL_OW 12
117208: ARRAY
117209: ST_TO_ADDR
// if Crawls ( un ) then
117210: LD_VAR 0 2
117214: PPUSH
117215: CALL_OW 318
117219: IFFALSE 117230
// ComWalk ( un ) ;
117221: LD_VAR 0 2
117225: PPUSH
117226: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117230: LD_VAR 0 2
117234: PPUSH
117235: LD_INT 8
117237: PPUSH
117238: CALL_OW 336
// end ;
117242: PPOPN 3
117244: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117245: LD_EXP 141
117249: PUSH
117250: LD_EXP 185
117254: AND
117255: IFFALSE 117399
117257: GO 117259
117259: DISABLE
117260: LD_INT 0
117262: PPUSH
117263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117264: LD_ADDR_VAR 0 2
117268: PUSH
117269: LD_INT 22
117271: PUSH
117272: LD_OWVAR 2
117276: PUSH
117277: EMPTY
117278: LIST
117279: LIST
117280: PUSH
117281: LD_INT 21
117283: PUSH
117284: LD_INT 2
117286: PUSH
117287: EMPTY
117288: LIST
117289: LIST
117290: PUSH
117291: LD_INT 2
117293: PUSH
117294: LD_INT 34
117296: PUSH
117297: LD_INT 12
117299: PUSH
117300: EMPTY
117301: LIST
117302: LIST
117303: PUSH
117304: LD_INT 34
117306: PUSH
117307: LD_INT 51
117309: PUSH
117310: EMPTY
117311: LIST
117312: LIST
117313: PUSH
117314: LD_INT 34
117316: PUSH
117317: LD_INT 32
117319: PUSH
117320: EMPTY
117321: LIST
117322: LIST
117323: PUSH
117324: EMPTY
117325: LIST
117326: LIST
117327: LIST
117328: LIST
117329: PUSH
117330: EMPTY
117331: LIST
117332: LIST
117333: LIST
117334: PPUSH
117335: CALL_OW 69
117339: ST_TO_ADDR
// if not tmp then
117340: LD_VAR 0 2
117344: NOT
117345: IFFALSE 117349
// exit ;
117347: GO 117399
// for i in tmp do
117349: LD_ADDR_VAR 0 1
117353: PUSH
117354: LD_VAR 0 2
117358: PUSH
117359: FOR_IN
117360: IFFALSE 117397
// if GetCargo ( i , mat_artifact ) = 0 then
117362: LD_VAR 0 1
117366: PPUSH
117367: LD_INT 4
117369: PPUSH
117370: CALL_OW 289
117374: PUSH
117375: LD_INT 0
117377: EQUAL
117378: IFFALSE 117395
// SetCargo ( i , mat_siberit , 100 ) ;
117380: LD_VAR 0 1
117384: PPUSH
117385: LD_INT 3
117387: PPUSH
117388: LD_INT 100
117390: PPUSH
117391: CALL_OW 290
117395: GO 117359
117397: POP
117398: POP
// end ;
117399: PPOPN 2
117401: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117402: LD_EXP 141
117406: PUSH
117407: LD_EXP 186
117411: AND
117412: IFFALSE 117595
117414: GO 117416
117416: DISABLE
117417: LD_INT 0
117419: PPUSH
117420: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117421: LD_ADDR_VAR 0 2
117425: PUSH
117426: LD_INT 22
117428: PUSH
117429: LD_OWVAR 2
117433: PUSH
117434: EMPTY
117435: LIST
117436: LIST
117437: PPUSH
117438: CALL_OW 69
117442: ST_TO_ADDR
// if not tmp then
117443: LD_VAR 0 2
117447: NOT
117448: IFFALSE 117452
// exit ;
117450: GO 117595
// for i := 1 to 2 do
117452: LD_ADDR_VAR 0 1
117456: PUSH
117457: DOUBLE
117458: LD_INT 1
117460: DEC
117461: ST_TO_ADDR
117462: LD_INT 2
117464: PUSH
117465: FOR_TO
117466: IFFALSE 117593
// begin uc_side := your_side ;
117468: LD_ADDR_OWVAR 20
117472: PUSH
117473: LD_OWVAR 2
117477: ST_TO_ADDR
// uc_nation := nation_american ;
117478: LD_ADDR_OWVAR 21
117482: PUSH
117483: LD_INT 1
117485: ST_TO_ADDR
// vc_chassis := us_morphling ;
117486: LD_ADDR_OWVAR 37
117490: PUSH
117491: LD_INT 5
117493: ST_TO_ADDR
// vc_engine := engine_siberite ;
117494: LD_ADDR_OWVAR 39
117498: PUSH
117499: LD_INT 3
117501: ST_TO_ADDR
// vc_control := control_computer ;
117502: LD_ADDR_OWVAR 38
117506: PUSH
117507: LD_INT 3
117509: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117510: LD_ADDR_OWVAR 40
117514: PUSH
117515: LD_INT 10
117517: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
117518: LD_VAR 0 2
117522: PUSH
117523: LD_INT 1
117525: ARRAY
117526: PPUSH
117527: CALL_OW 310
117531: NOT
117532: IFFALSE 117579
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
117534: CALL_OW 45
117538: PPUSH
117539: LD_VAR 0 2
117543: PUSH
117544: LD_INT 1
117546: ARRAY
117547: PPUSH
117548: CALL_OW 250
117552: PPUSH
117553: LD_VAR 0 2
117557: PUSH
117558: LD_INT 1
117560: ARRAY
117561: PPUSH
117562: CALL_OW 251
117566: PPUSH
117567: LD_INT 12
117569: PPUSH
117570: LD_INT 1
117572: PPUSH
117573: CALL_OW 50
117577: GO 117591
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
117579: CALL_OW 45
117583: PPUSH
117584: LD_INT 1
117586: PPUSH
117587: CALL_OW 51
// end ;
117591: GO 117465
117593: POP
117594: POP
// end ;
117595: PPOPN 2
117597: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117598: LD_EXP 141
117602: PUSH
117603: LD_EXP 187
117607: AND
117608: IFFALSE 117830
117610: GO 117612
117612: DISABLE
117613: LD_INT 0
117615: PPUSH
117616: PPUSH
117617: PPUSH
117618: PPUSH
117619: PPUSH
117620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117621: LD_ADDR_VAR 0 6
117625: PUSH
117626: LD_INT 22
117628: PUSH
117629: LD_OWVAR 2
117633: PUSH
117634: EMPTY
117635: LIST
117636: LIST
117637: PUSH
117638: LD_INT 21
117640: PUSH
117641: LD_INT 1
117643: PUSH
117644: EMPTY
117645: LIST
117646: LIST
117647: PUSH
117648: LD_INT 3
117650: PUSH
117651: LD_INT 23
117653: PUSH
117654: LD_INT 0
117656: PUSH
117657: EMPTY
117658: LIST
117659: LIST
117660: PUSH
117661: EMPTY
117662: LIST
117663: LIST
117664: PUSH
117665: EMPTY
117666: LIST
117667: LIST
117668: LIST
117669: PPUSH
117670: CALL_OW 69
117674: ST_TO_ADDR
// if not tmp then
117675: LD_VAR 0 6
117679: NOT
117680: IFFALSE 117684
// exit ;
117682: GO 117830
// s1 := rand ( 1 , 4 ) ;
117684: LD_ADDR_VAR 0 2
117688: PUSH
117689: LD_INT 1
117691: PPUSH
117692: LD_INT 4
117694: PPUSH
117695: CALL_OW 12
117699: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117700: LD_ADDR_VAR 0 4
117704: PUSH
117705: LD_VAR 0 6
117709: PUSH
117710: LD_INT 1
117712: ARRAY
117713: PPUSH
117714: LD_VAR 0 2
117718: PPUSH
117719: CALL_OW 259
117723: ST_TO_ADDR
// if s1 = 1 then
117724: LD_VAR 0 2
117728: PUSH
117729: LD_INT 1
117731: EQUAL
117732: IFFALSE 117752
// s2 := rand ( 2 , 4 ) else
117734: LD_ADDR_VAR 0 3
117738: PUSH
117739: LD_INT 2
117741: PPUSH
117742: LD_INT 4
117744: PPUSH
117745: CALL_OW 12
117749: ST_TO_ADDR
117750: GO 117760
// s2 := 1 ;
117752: LD_ADDR_VAR 0 3
117756: PUSH
117757: LD_INT 1
117759: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117760: LD_ADDR_VAR 0 5
117764: PUSH
117765: LD_VAR 0 6
117769: PUSH
117770: LD_INT 1
117772: ARRAY
117773: PPUSH
117774: LD_VAR 0 3
117778: PPUSH
117779: CALL_OW 259
117783: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
117784: LD_VAR 0 6
117788: PUSH
117789: LD_INT 1
117791: ARRAY
117792: PPUSH
117793: LD_VAR 0 2
117797: PPUSH
117798: LD_VAR 0 5
117802: PPUSH
117803: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
117807: LD_VAR 0 6
117811: PUSH
117812: LD_INT 1
117814: ARRAY
117815: PPUSH
117816: LD_VAR 0 3
117820: PPUSH
117821: LD_VAR 0 4
117825: PPUSH
117826: CALL_OW 237
// end ;
117830: PPOPN 6
117832: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
117833: LD_EXP 141
117837: PUSH
117838: LD_EXP 188
117842: AND
117843: IFFALSE 117922
117845: GO 117847
117847: DISABLE
117848: LD_INT 0
117850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
117851: LD_ADDR_VAR 0 1
117855: PUSH
117856: LD_INT 22
117858: PUSH
117859: LD_OWVAR 2
117863: PUSH
117864: EMPTY
117865: LIST
117866: LIST
117867: PUSH
117868: LD_INT 30
117870: PUSH
117871: LD_INT 3
117873: PUSH
117874: EMPTY
117875: LIST
117876: LIST
117877: PUSH
117878: EMPTY
117879: LIST
117880: LIST
117881: PPUSH
117882: CALL_OW 69
117886: ST_TO_ADDR
// if not tmp then
117887: LD_VAR 0 1
117891: NOT
117892: IFFALSE 117896
// exit ;
117894: GO 117922
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117896: LD_VAR 0 1
117900: PUSH
117901: LD_INT 1
117903: PPUSH
117904: LD_VAR 0 1
117908: PPUSH
117909: CALL_OW 12
117913: ARRAY
117914: PPUSH
117915: LD_INT 1
117917: PPUSH
117918: CALL_OW 234
// end ;
117922: PPOPN 1
117924: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
117925: LD_EXP 141
117929: PUSH
117930: LD_EXP 189
117934: AND
117935: IFFALSE 118047
117937: GO 117939
117939: DISABLE
117940: LD_INT 0
117942: PPUSH
117943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
117944: LD_ADDR_VAR 0 2
117948: PUSH
117949: LD_INT 22
117951: PUSH
117952: LD_OWVAR 2
117956: PUSH
117957: EMPTY
117958: LIST
117959: LIST
117960: PUSH
117961: LD_INT 2
117963: PUSH
117964: LD_INT 30
117966: PUSH
117967: LD_INT 27
117969: PUSH
117970: EMPTY
117971: LIST
117972: LIST
117973: PUSH
117974: LD_INT 30
117976: PUSH
117977: LD_INT 26
117979: PUSH
117980: EMPTY
117981: LIST
117982: LIST
117983: PUSH
117984: LD_INT 30
117986: PUSH
117987: LD_INT 28
117989: PUSH
117990: EMPTY
117991: LIST
117992: LIST
117993: PUSH
117994: EMPTY
117995: LIST
117996: LIST
117997: LIST
117998: LIST
117999: PUSH
118000: EMPTY
118001: LIST
118002: LIST
118003: PPUSH
118004: CALL_OW 69
118008: ST_TO_ADDR
// if not tmp then
118009: LD_VAR 0 2
118013: NOT
118014: IFFALSE 118018
// exit ;
118016: GO 118047
// for i in tmp do
118018: LD_ADDR_VAR 0 1
118022: PUSH
118023: LD_VAR 0 2
118027: PUSH
118028: FOR_IN
118029: IFFALSE 118045
// SetLives ( i , 1 ) ;
118031: LD_VAR 0 1
118035: PPUSH
118036: LD_INT 1
118038: PPUSH
118039: CALL_OW 234
118043: GO 118028
118045: POP
118046: POP
// end ;
118047: PPOPN 2
118049: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118050: LD_EXP 141
118054: PUSH
118055: LD_EXP 190
118059: AND
118060: IFFALSE 118347
118062: GO 118064
118064: DISABLE
118065: LD_INT 0
118067: PPUSH
118068: PPUSH
118069: PPUSH
// begin i := rand ( 1 , 7 ) ;
118070: LD_ADDR_VAR 0 1
118074: PUSH
118075: LD_INT 1
118077: PPUSH
118078: LD_INT 7
118080: PPUSH
118081: CALL_OW 12
118085: ST_TO_ADDR
// case i of 1 :
118086: LD_VAR 0 1
118090: PUSH
118091: LD_INT 1
118093: DOUBLE
118094: EQUAL
118095: IFTRUE 118099
118097: GO 118109
118099: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118100: LD_STRING earthquake(getX(game), 0, 32)
118102: PPUSH
118103: CALL_OW 559
118107: GO 118347
118109: LD_INT 2
118111: DOUBLE
118112: EQUAL
118113: IFTRUE 118117
118115: GO 118131
118117: POP
// begin ToLua ( displayStucuk(); ) ;
118118: LD_STRING displayStucuk();
118120: PPUSH
118121: CALL_OW 559
// ResetFog ;
118125: CALL_OW 335
// end ; 3 :
118129: GO 118347
118131: LD_INT 3
118133: DOUBLE
118134: EQUAL
118135: IFTRUE 118139
118137: GO 118243
118139: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118140: LD_ADDR_VAR 0 2
118144: PUSH
118145: LD_INT 22
118147: PUSH
118148: LD_OWVAR 2
118152: PUSH
118153: EMPTY
118154: LIST
118155: LIST
118156: PUSH
118157: LD_INT 25
118159: PUSH
118160: LD_INT 1
118162: PUSH
118163: EMPTY
118164: LIST
118165: LIST
118166: PUSH
118167: EMPTY
118168: LIST
118169: LIST
118170: PPUSH
118171: CALL_OW 69
118175: ST_TO_ADDR
// if not tmp then
118176: LD_VAR 0 2
118180: NOT
118181: IFFALSE 118185
// exit ;
118183: GO 118347
// un := tmp [ rand ( 1 , tmp ) ] ;
118185: LD_ADDR_VAR 0 3
118189: PUSH
118190: LD_VAR 0 2
118194: PUSH
118195: LD_INT 1
118197: PPUSH
118198: LD_VAR 0 2
118202: PPUSH
118203: CALL_OW 12
118207: ARRAY
118208: ST_TO_ADDR
// if Crawls ( un ) then
118209: LD_VAR 0 3
118213: PPUSH
118214: CALL_OW 318
118218: IFFALSE 118229
// ComWalk ( un ) ;
118220: LD_VAR 0 3
118224: PPUSH
118225: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118229: LD_VAR 0 3
118233: PPUSH
118234: LD_INT 8
118236: PPUSH
118237: CALL_OW 336
// end ; 4 :
118241: GO 118347
118243: LD_INT 4
118245: DOUBLE
118246: EQUAL
118247: IFTRUE 118251
118249: GO 118325
118251: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118252: LD_ADDR_VAR 0 2
118256: PUSH
118257: LD_INT 22
118259: PUSH
118260: LD_OWVAR 2
118264: PUSH
118265: EMPTY
118266: LIST
118267: LIST
118268: PUSH
118269: LD_INT 30
118271: PUSH
118272: LD_INT 29
118274: PUSH
118275: EMPTY
118276: LIST
118277: LIST
118278: PUSH
118279: EMPTY
118280: LIST
118281: LIST
118282: PPUSH
118283: CALL_OW 69
118287: ST_TO_ADDR
// if not tmp then
118288: LD_VAR 0 2
118292: NOT
118293: IFFALSE 118297
// exit ;
118295: GO 118347
// CenterNowOnUnits ( tmp [ 1 ] ) ;
118297: LD_VAR 0 2
118301: PUSH
118302: LD_INT 1
118304: ARRAY
118305: PPUSH
118306: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
118310: LD_VAR 0 2
118314: PUSH
118315: LD_INT 1
118317: ARRAY
118318: PPUSH
118319: CALL_OW 65
// end ; 5 .. 7 :
118323: GO 118347
118325: LD_INT 5
118327: DOUBLE
118328: GREATEREQUAL
118329: IFFALSE 118337
118331: LD_INT 7
118333: DOUBLE
118334: LESSEQUAL
118335: IFTRUE 118339
118337: GO 118346
118339: POP
// StreamSibBomb ; end ;
118340: CALL 114584 0 0
118344: GO 118347
118346: POP
// end ;
118347: PPOPN 3
118349: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118350: LD_EXP 141
118354: PUSH
118355: LD_EXP 191
118359: AND
118360: IFFALSE 118516
118362: GO 118364
118364: DISABLE
118365: LD_INT 0
118367: PPUSH
118368: PPUSH
118369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118370: LD_ADDR_VAR 0 2
118374: PUSH
118375: LD_INT 81
118377: PUSH
118378: LD_OWVAR 2
118382: PUSH
118383: EMPTY
118384: LIST
118385: LIST
118386: PUSH
118387: LD_INT 2
118389: PUSH
118390: LD_INT 21
118392: PUSH
118393: LD_INT 1
118395: PUSH
118396: EMPTY
118397: LIST
118398: LIST
118399: PUSH
118400: LD_INT 21
118402: PUSH
118403: LD_INT 2
118405: PUSH
118406: EMPTY
118407: LIST
118408: LIST
118409: PUSH
118410: EMPTY
118411: LIST
118412: LIST
118413: LIST
118414: PUSH
118415: EMPTY
118416: LIST
118417: LIST
118418: PPUSH
118419: CALL_OW 69
118423: ST_TO_ADDR
// if not tmp then
118424: LD_VAR 0 2
118428: NOT
118429: IFFALSE 118433
// exit ;
118431: GO 118516
// p := 0 ;
118433: LD_ADDR_VAR 0 3
118437: PUSH
118438: LD_INT 0
118440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118441: LD_INT 35
118443: PPUSH
118444: CALL_OW 67
// p := p + 1 ;
118448: LD_ADDR_VAR 0 3
118452: PUSH
118453: LD_VAR 0 3
118457: PUSH
118458: LD_INT 1
118460: PLUS
118461: ST_TO_ADDR
// for i in tmp do
118462: LD_ADDR_VAR 0 1
118466: PUSH
118467: LD_VAR 0 2
118471: PUSH
118472: FOR_IN
118473: IFFALSE 118504
// if GetLives ( i ) < 1000 then
118475: LD_VAR 0 1
118479: PPUSH
118480: CALL_OW 256
118484: PUSH
118485: LD_INT 1000
118487: LESS
118488: IFFALSE 118502
// SetLives ( i , 1000 ) ;
118490: LD_VAR 0 1
118494: PPUSH
118495: LD_INT 1000
118497: PPUSH
118498: CALL_OW 234
118502: GO 118472
118504: POP
118505: POP
// until p > 20 ;
118506: LD_VAR 0 3
118510: PUSH
118511: LD_INT 20
118513: GREATER
118514: IFFALSE 118441
// end ;
118516: PPOPN 3
118518: END
// every 0 0$1 trigger StreamModeActive and sTime do
118519: LD_EXP 141
118523: PUSH
118524: LD_EXP 192
118528: AND
118529: IFFALSE 118564
118531: GO 118533
118533: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118534: LD_INT 28
118536: PPUSH
118537: LD_OWVAR 2
118541: PPUSH
118542: LD_INT 2
118544: PPUSH
118545: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118549: LD_INT 30
118551: PPUSH
118552: LD_OWVAR 2
118556: PPUSH
118557: LD_INT 2
118559: PPUSH
118560: CALL_OW 322
// end ;
118564: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118565: LD_EXP 141
118569: PUSH
118570: LD_EXP 193
118574: AND
118575: IFFALSE 118696
118577: GO 118579
118579: DISABLE
118580: LD_INT 0
118582: PPUSH
118583: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118584: LD_ADDR_VAR 0 2
118588: PUSH
118589: LD_INT 22
118591: PUSH
118592: LD_OWVAR 2
118596: PUSH
118597: EMPTY
118598: LIST
118599: LIST
118600: PUSH
118601: LD_INT 21
118603: PUSH
118604: LD_INT 1
118606: PUSH
118607: EMPTY
118608: LIST
118609: LIST
118610: PUSH
118611: LD_INT 3
118613: PUSH
118614: LD_INT 23
118616: PUSH
118617: LD_INT 0
118619: PUSH
118620: EMPTY
118621: LIST
118622: LIST
118623: PUSH
118624: EMPTY
118625: LIST
118626: LIST
118627: PUSH
118628: EMPTY
118629: LIST
118630: LIST
118631: LIST
118632: PPUSH
118633: CALL_OW 69
118637: ST_TO_ADDR
// if not tmp then
118638: LD_VAR 0 2
118642: NOT
118643: IFFALSE 118647
// exit ;
118645: GO 118696
// for i in tmp do
118647: LD_ADDR_VAR 0 1
118651: PUSH
118652: LD_VAR 0 2
118656: PUSH
118657: FOR_IN
118658: IFFALSE 118694
// begin if Crawls ( i ) then
118660: LD_VAR 0 1
118664: PPUSH
118665: CALL_OW 318
118669: IFFALSE 118680
// ComWalk ( i ) ;
118671: LD_VAR 0 1
118675: PPUSH
118676: CALL_OW 138
// SetClass ( i , 2 ) ;
118680: LD_VAR 0 1
118684: PPUSH
118685: LD_INT 2
118687: PPUSH
118688: CALL_OW 336
// end ;
118692: GO 118657
118694: POP
118695: POP
// end ;
118696: PPOPN 2
118698: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118699: LD_EXP 141
118703: PUSH
118704: LD_EXP 194
118708: AND
118709: IFFALSE 118997
118711: GO 118713
118713: DISABLE
118714: LD_INT 0
118716: PPUSH
118717: PPUSH
118718: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118719: LD_OWVAR 2
118723: PPUSH
118724: LD_INT 9
118726: PPUSH
118727: LD_INT 1
118729: PPUSH
118730: LD_INT 1
118732: PPUSH
118733: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118737: LD_INT 9
118739: PPUSH
118740: LD_OWVAR 2
118744: PPUSH
118745: CALL_OW 343
// uc_side := 9 ;
118749: LD_ADDR_OWVAR 20
118753: PUSH
118754: LD_INT 9
118756: ST_TO_ADDR
// uc_nation := 2 ;
118757: LD_ADDR_OWVAR 21
118761: PUSH
118762: LD_INT 2
118764: ST_TO_ADDR
// hc_name := Dark Warrior ;
118765: LD_ADDR_OWVAR 26
118769: PUSH
118770: LD_STRING Dark Warrior
118772: ST_TO_ADDR
// hc_gallery :=  ;
118773: LD_ADDR_OWVAR 33
118777: PUSH
118778: LD_STRING 
118780: ST_TO_ADDR
// hc_noskilllimit := true ;
118781: LD_ADDR_OWVAR 76
118785: PUSH
118786: LD_INT 1
118788: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
118789: LD_ADDR_OWVAR 31
118793: PUSH
118794: LD_INT 30
118796: PUSH
118797: LD_INT 30
118799: PUSH
118800: LD_INT 30
118802: PUSH
118803: LD_INT 30
118805: PUSH
118806: EMPTY
118807: LIST
118808: LIST
118809: LIST
118810: LIST
118811: ST_TO_ADDR
// un := CreateHuman ;
118812: LD_ADDR_VAR 0 3
118816: PUSH
118817: CALL_OW 44
118821: ST_TO_ADDR
// hc_noskilllimit := false ;
118822: LD_ADDR_OWVAR 76
118826: PUSH
118827: LD_INT 0
118829: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118830: LD_VAR 0 3
118834: PPUSH
118835: LD_INT 1
118837: PPUSH
118838: CALL_OW 51
// ToLua ( playRanger() ) ;
118842: LD_STRING playRanger()
118844: PPUSH
118845: CALL_OW 559
// p := 0 ;
118849: LD_ADDR_VAR 0 2
118853: PUSH
118854: LD_INT 0
118856: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118857: LD_INT 35
118859: PPUSH
118860: CALL_OW 67
// p := p + 1 ;
118864: LD_ADDR_VAR 0 2
118868: PUSH
118869: LD_VAR 0 2
118873: PUSH
118874: LD_INT 1
118876: PLUS
118877: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118878: LD_VAR 0 3
118882: PPUSH
118883: CALL_OW 256
118887: PUSH
118888: LD_INT 1000
118890: LESS
118891: IFFALSE 118905
// SetLives ( un , 1000 ) ;
118893: LD_VAR 0 3
118897: PPUSH
118898: LD_INT 1000
118900: PPUSH
118901: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
118905: LD_VAR 0 3
118909: PPUSH
118910: LD_INT 81
118912: PUSH
118913: LD_OWVAR 2
118917: PUSH
118918: EMPTY
118919: LIST
118920: LIST
118921: PUSH
118922: LD_INT 91
118924: PUSH
118925: LD_VAR 0 3
118929: PUSH
118930: LD_INT 30
118932: PUSH
118933: EMPTY
118934: LIST
118935: LIST
118936: LIST
118937: PUSH
118938: EMPTY
118939: LIST
118940: LIST
118941: PPUSH
118942: CALL_OW 69
118946: PPUSH
118947: LD_VAR 0 3
118951: PPUSH
118952: CALL_OW 74
118956: PPUSH
118957: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
118961: LD_VAR 0 2
118965: PUSH
118966: LD_INT 80
118968: GREATER
118969: PUSH
118970: LD_VAR 0 3
118974: PPUSH
118975: CALL_OW 301
118979: OR
118980: IFFALSE 118857
// if un then
118982: LD_VAR 0 3
118986: IFFALSE 118997
// RemoveUnit ( un ) ;
118988: LD_VAR 0 3
118992: PPUSH
118993: CALL_OW 64
// end ;
118997: PPOPN 3
118999: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
119000: LD_EXP 195
119004: IFFALSE 119120
119006: GO 119008
119008: DISABLE
119009: LD_INT 0
119011: PPUSH
119012: PPUSH
119013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119014: LD_ADDR_VAR 0 2
119018: PUSH
119019: LD_INT 81
119021: PUSH
119022: LD_OWVAR 2
119026: PUSH
119027: EMPTY
119028: LIST
119029: LIST
119030: PUSH
119031: LD_INT 21
119033: PUSH
119034: LD_INT 1
119036: PUSH
119037: EMPTY
119038: LIST
119039: LIST
119040: PUSH
119041: EMPTY
119042: LIST
119043: LIST
119044: PPUSH
119045: CALL_OW 69
119049: ST_TO_ADDR
// ToLua ( playComputer() ) ;
119050: LD_STRING playComputer()
119052: PPUSH
119053: CALL_OW 559
// if not tmp then
119057: LD_VAR 0 2
119061: NOT
119062: IFFALSE 119066
// exit ;
119064: GO 119120
// for i in tmp do
119066: LD_ADDR_VAR 0 1
119070: PUSH
119071: LD_VAR 0 2
119075: PUSH
119076: FOR_IN
119077: IFFALSE 119118
// for j := 1 to 4 do
119079: LD_ADDR_VAR 0 3
119083: PUSH
119084: DOUBLE
119085: LD_INT 1
119087: DEC
119088: ST_TO_ADDR
119089: LD_INT 4
119091: PUSH
119092: FOR_TO
119093: IFFALSE 119114
// SetSkill ( i , j , 10 ) ;
119095: LD_VAR 0 1
119099: PPUSH
119100: LD_VAR 0 3
119104: PPUSH
119105: LD_INT 10
119107: PPUSH
119108: CALL_OW 237
119112: GO 119092
119114: POP
119115: POP
119116: GO 119076
119118: POP
119119: POP
// end ;
119120: PPOPN 3
119122: END
// every 0 0$1 trigger s30 do var i , tmp ;
119123: LD_EXP 196
119127: IFFALSE 119196
119129: GO 119131
119131: DISABLE
119132: LD_INT 0
119134: PPUSH
119135: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119136: LD_ADDR_VAR 0 2
119140: PUSH
119141: LD_INT 22
119143: PUSH
119144: LD_OWVAR 2
119148: PUSH
119149: EMPTY
119150: LIST
119151: LIST
119152: PPUSH
119153: CALL_OW 69
119157: ST_TO_ADDR
// if not tmp then
119158: LD_VAR 0 2
119162: NOT
119163: IFFALSE 119167
// exit ;
119165: GO 119196
// for i in tmp do
119167: LD_ADDR_VAR 0 1
119171: PUSH
119172: LD_VAR 0 2
119176: PUSH
119177: FOR_IN
119178: IFFALSE 119194
// SetLives ( i , 300 ) ;
119180: LD_VAR 0 1
119184: PPUSH
119185: LD_INT 300
119187: PPUSH
119188: CALL_OW 234
119192: GO 119177
119194: POP
119195: POP
// end ;
119196: PPOPN 2
119198: END
// every 0 0$1 trigger s60 do var i , tmp ;
119199: LD_EXP 197
119203: IFFALSE 119272
119205: GO 119207
119207: DISABLE
119208: LD_INT 0
119210: PPUSH
119211: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119212: LD_ADDR_VAR 0 2
119216: PUSH
119217: LD_INT 22
119219: PUSH
119220: LD_OWVAR 2
119224: PUSH
119225: EMPTY
119226: LIST
119227: LIST
119228: PPUSH
119229: CALL_OW 69
119233: ST_TO_ADDR
// if not tmp then
119234: LD_VAR 0 2
119238: NOT
119239: IFFALSE 119243
// exit ;
119241: GO 119272
// for i in tmp do
119243: LD_ADDR_VAR 0 1
119247: PUSH
119248: LD_VAR 0 2
119252: PUSH
119253: FOR_IN
119254: IFFALSE 119270
// SetLives ( i , 600 ) ;
119256: LD_VAR 0 1
119260: PPUSH
119261: LD_INT 600
119263: PPUSH
119264: CALL_OW 234
119268: GO 119253
119270: POP
119271: POP
// end ;
119272: PPOPN 2
119274: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
119275: LD_INT 0
119277: PPUSH
// case cmd of 301 :
119278: LD_VAR 0 1
119282: PUSH
119283: LD_INT 301
119285: DOUBLE
119286: EQUAL
119287: IFTRUE 119291
119289: GO 119323
119291: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
119292: LD_VAR 0 6
119296: PPUSH
119297: LD_VAR 0 7
119301: PPUSH
119302: LD_VAR 0 8
119306: PPUSH
119307: LD_VAR 0 4
119311: PPUSH
119312: LD_VAR 0 5
119316: PPUSH
119317: CALL 120524 0 5
119321: GO 119444
119323: LD_INT 302
119325: DOUBLE
119326: EQUAL
119327: IFTRUE 119331
119329: GO 119368
119331: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
119332: LD_VAR 0 6
119336: PPUSH
119337: LD_VAR 0 7
119341: PPUSH
119342: LD_VAR 0 8
119346: PPUSH
119347: LD_VAR 0 9
119351: PPUSH
119352: LD_VAR 0 4
119356: PPUSH
119357: LD_VAR 0 5
119361: PPUSH
119362: CALL 120615 0 6
119366: GO 119444
119368: LD_INT 303
119370: DOUBLE
119371: EQUAL
119372: IFTRUE 119376
119374: GO 119413
119376: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
119377: LD_VAR 0 6
119381: PPUSH
119382: LD_VAR 0 7
119386: PPUSH
119387: LD_VAR 0 8
119391: PPUSH
119392: LD_VAR 0 9
119396: PPUSH
119397: LD_VAR 0 4
119401: PPUSH
119402: LD_VAR 0 5
119406: PPUSH
119407: CALL 119449 0 6
119411: GO 119444
119413: LD_INT 304
119415: DOUBLE
119416: EQUAL
119417: IFTRUE 119421
119419: GO 119443
119421: POP
// hHackTeleport ( unit , x , y ) ; end ;
119422: LD_VAR 0 2
119426: PPUSH
119427: LD_VAR 0 4
119431: PPUSH
119432: LD_VAR 0 5
119436: PPUSH
119437: CALL 121208 0 3
119441: GO 119444
119443: POP
// end ;
119444: LD_VAR 0 12
119448: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
119449: LD_INT 0
119451: PPUSH
119452: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
119453: LD_VAR 0 1
119457: PUSH
119458: LD_INT 1
119460: LESS
119461: PUSH
119462: LD_VAR 0 1
119466: PUSH
119467: LD_INT 3
119469: GREATER
119470: OR
119471: PUSH
119472: LD_VAR 0 5
119476: PPUSH
119477: LD_VAR 0 6
119481: PPUSH
119482: CALL_OW 428
119486: OR
119487: IFFALSE 119491
// exit ;
119489: GO 120211
// uc_side := your_side ;
119491: LD_ADDR_OWVAR 20
119495: PUSH
119496: LD_OWVAR 2
119500: ST_TO_ADDR
// uc_nation := nation ;
119501: LD_ADDR_OWVAR 21
119505: PUSH
119506: LD_VAR 0 1
119510: ST_TO_ADDR
// bc_level = 1 ;
119511: LD_ADDR_OWVAR 43
119515: PUSH
119516: LD_INT 1
119518: ST_TO_ADDR
// case btype of 1 :
119519: LD_VAR 0 2
119523: PUSH
119524: LD_INT 1
119526: DOUBLE
119527: EQUAL
119528: IFTRUE 119532
119530: GO 119543
119532: POP
// bc_type := b_depot ; 2 :
119533: LD_ADDR_OWVAR 42
119537: PUSH
119538: LD_INT 0
119540: ST_TO_ADDR
119541: GO 120155
119543: LD_INT 2
119545: DOUBLE
119546: EQUAL
119547: IFTRUE 119551
119549: GO 119562
119551: POP
// bc_type := b_warehouse ; 3 :
119552: LD_ADDR_OWVAR 42
119556: PUSH
119557: LD_INT 1
119559: ST_TO_ADDR
119560: GO 120155
119562: LD_INT 3
119564: DOUBLE
119565: EQUAL
119566: IFTRUE 119570
119568: GO 119581
119570: POP
// bc_type := b_lab ; 4 .. 9 :
119571: LD_ADDR_OWVAR 42
119575: PUSH
119576: LD_INT 6
119578: ST_TO_ADDR
119579: GO 120155
119581: LD_INT 4
119583: DOUBLE
119584: GREATEREQUAL
119585: IFFALSE 119593
119587: LD_INT 9
119589: DOUBLE
119590: LESSEQUAL
119591: IFTRUE 119595
119593: GO 119647
119595: POP
// begin bc_type := b_lab_half ;
119596: LD_ADDR_OWVAR 42
119600: PUSH
119601: LD_INT 7
119603: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
119604: LD_ADDR_OWVAR 44
119608: PUSH
119609: LD_INT 10
119611: PUSH
119612: LD_INT 11
119614: PUSH
119615: LD_INT 12
119617: PUSH
119618: LD_INT 15
119620: PUSH
119621: LD_INT 14
119623: PUSH
119624: LD_INT 13
119626: PUSH
119627: EMPTY
119628: LIST
119629: LIST
119630: LIST
119631: LIST
119632: LIST
119633: LIST
119634: PUSH
119635: LD_VAR 0 2
119639: PUSH
119640: LD_INT 3
119642: MINUS
119643: ARRAY
119644: ST_TO_ADDR
// end ; 10 .. 13 :
119645: GO 120155
119647: LD_INT 10
119649: DOUBLE
119650: GREATEREQUAL
119651: IFFALSE 119659
119653: LD_INT 13
119655: DOUBLE
119656: LESSEQUAL
119657: IFTRUE 119661
119659: GO 119738
119661: POP
// begin bc_type := b_lab_full ;
119662: LD_ADDR_OWVAR 42
119666: PUSH
119667: LD_INT 8
119669: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
119670: LD_ADDR_OWVAR 44
119674: PUSH
119675: LD_INT 10
119677: PUSH
119678: LD_INT 12
119680: PUSH
119681: LD_INT 14
119683: PUSH
119684: LD_INT 13
119686: PUSH
119687: EMPTY
119688: LIST
119689: LIST
119690: LIST
119691: LIST
119692: PUSH
119693: LD_VAR 0 2
119697: PUSH
119698: LD_INT 9
119700: MINUS
119701: ARRAY
119702: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
119703: LD_ADDR_OWVAR 45
119707: PUSH
119708: LD_INT 11
119710: PUSH
119711: LD_INT 15
119713: PUSH
119714: LD_INT 12
119716: PUSH
119717: LD_INT 15
119719: PUSH
119720: EMPTY
119721: LIST
119722: LIST
119723: LIST
119724: LIST
119725: PUSH
119726: LD_VAR 0 2
119730: PUSH
119731: LD_INT 9
119733: MINUS
119734: ARRAY
119735: ST_TO_ADDR
// end ; 14 :
119736: GO 120155
119738: LD_INT 14
119740: DOUBLE
119741: EQUAL
119742: IFTRUE 119746
119744: GO 119757
119746: POP
// bc_type := b_workshop ; 15 :
119747: LD_ADDR_OWVAR 42
119751: PUSH
119752: LD_INT 2
119754: ST_TO_ADDR
119755: GO 120155
119757: LD_INT 15
119759: DOUBLE
119760: EQUAL
119761: IFTRUE 119765
119763: GO 119776
119765: POP
// bc_type := b_factory ; 16 :
119766: LD_ADDR_OWVAR 42
119770: PUSH
119771: LD_INT 3
119773: ST_TO_ADDR
119774: GO 120155
119776: LD_INT 16
119778: DOUBLE
119779: EQUAL
119780: IFTRUE 119784
119782: GO 119795
119784: POP
// bc_type := b_ext_gun ; 17 :
119785: LD_ADDR_OWVAR 42
119789: PUSH
119790: LD_INT 17
119792: ST_TO_ADDR
119793: GO 120155
119795: LD_INT 17
119797: DOUBLE
119798: EQUAL
119799: IFTRUE 119803
119801: GO 119831
119803: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
119804: LD_ADDR_OWVAR 42
119808: PUSH
119809: LD_INT 19
119811: PUSH
119812: LD_INT 23
119814: PUSH
119815: LD_INT 19
119817: PUSH
119818: EMPTY
119819: LIST
119820: LIST
119821: LIST
119822: PUSH
119823: LD_VAR 0 1
119827: ARRAY
119828: ST_TO_ADDR
119829: GO 120155
119831: LD_INT 18
119833: DOUBLE
119834: EQUAL
119835: IFTRUE 119839
119837: GO 119850
119839: POP
// bc_type := b_ext_radar ; 19 :
119840: LD_ADDR_OWVAR 42
119844: PUSH
119845: LD_INT 20
119847: ST_TO_ADDR
119848: GO 120155
119850: LD_INT 19
119852: DOUBLE
119853: EQUAL
119854: IFTRUE 119858
119856: GO 119869
119858: POP
// bc_type := b_ext_radio ; 20 :
119859: LD_ADDR_OWVAR 42
119863: PUSH
119864: LD_INT 22
119866: ST_TO_ADDR
119867: GO 120155
119869: LD_INT 20
119871: DOUBLE
119872: EQUAL
119873: IFTRUE 119877
119875: GO 119888
119877: POP
// bc_type := b_ext_siberium ; 21 :
119878: LD_ADDR_OWVAR 42
119882: PUSH
119883: LD_INT 21
119885: ST_TO_ADDR
119886: GO 120155
119888: LD_INT 21
119890: DOUBLE
119891: EQUAL
119892: IFTRUE 119896
119894: GO 119907
119896: POP
// bc_type := b_ext_computer ; 22 :
119897: LD_ADDR_OWVAR 42
119901: PUSH
119902: LD_INT 24
119904: ST_TO_ADDR
119905: GO 120155
119907: LD_INT 22
119909: DOUBLE
119910: EQUAL
119911: IFTRUE 119915
119913: GO 119926
119915: POP
// bc_type := b_ext_track ; 23 :
119916: LD_ADDR_OWVAR 42
119920: PUSH
119921: LD_INT 16
119923: ST_TO_ADDR
119924: GO 120155
119926: LD_INT 23
119928: DOUBLE
119929: EQUAL
119930: IFTRUE 119934
119932: GO 119945
119934: POP
// bc_type := b_ext_laser ; 24 :
119935: LD_ADDR_OWVAR 42
119939: PUSH
119940: LD_INT 25
119942: ST_TO_ADDR
119943: GO 120155
119945: LD_INT 24
119947: DOUBLE
119948: EQUAL
119949: IFTRUE 119953
119951: GO 119964
119953: POP
// bc_type := b_control_tower ; 25 :
119954: LD_ADDR_OWVAR 42
119958: PUSH
119959: LD_INT 36
119961: ST_TO_ADDR
119962: GO 120155
119964: LD_INT 25
119966: DOUBLE
119967: EQUAL
119968: IFTRUE 119972
119970: GO 119983
119972: POP
// bc_type := b_breastwork ; 26 :
119973: LD_ADDR_OWVAR 42
119977: PUSH
119978: LD_INT 31
119980: ST_TO_ADDR
119981: GO 120155
119983: LD_INT 26
119985: DOUBLE
119986: EQUAL
119987: IFTRUE 119991
119989: GO 120002
119991: POP
// bc_type := b_bunker ; 27 :
119992: LD_ADDR_OWVAR 42
119996: PUSH
119997: LD_INT 32
119999: ST_TO_ADDR
120000: GO 120155
120002: LD_INT 27
120004: DOUBLE
120005: EQUAL
120006: IFTRUE 120010
120008: GO 120021
120010: POP
// bc_type := b_turret ; 28 :
120011: LD_ADDR_OWVAR 42
120015: PUSH
120016: LD_INT 33
120018: ST_TO_ADDR
120019: GO 120155
120021: LD_INT 28
120023: DOUBLE
120024: EQUAL
120025: IFTRUE 120029
120027: GO 120040
120029: POP
// bc_type := b_armoury ; 29 :
120030: LD_ADDR_OWVAR 42
120034: PUSH
120035: LD_INT 4
120037: ST_TO_ADDR
120038: GO 120155
120040: LD_INT 29
120042: DOUBLE
120043: EQUAL
120044: IFTRUE 120048
120046: GO 120059
120048: POP
// bc_type := b_barracks ; 30 :
120049: LD_ADDR_OWVAR 42
120053: PUSH
120054: LD_INT 5
120056: ST_TO_ADDR
120057: GO 120155
120059: LD_INT 30
120061: DOUBLE
120062: EQUAL
120063: IFTRUE 120067
120065: GO 120078
120067: POP
// bc_type := b_solar_power ; 31 :
120068: LD_ADDR_OWVAR 42
120072: PUSH
120073: LD_INT 27
120075: ST_TO_ADDR
120076: GO 120155
120078: LD_INT 31
120080: DOUBLE
120081: EQUAL
120082: IFTRUE 120086
120084: GO 120097
120086: POP
// bc_type := b_oil_power ; 32 :
120087: LD_ADDR_OWVAR 42
120091: PUSH
120092: LD_INT 26
120094: ST_TO_ADDR
120095: GO 120155
120097: LD_INT 32
120099: DOUBLE
120100: EQUAL
120101: IFTRUE 120105
120103: GO 120116
120105: POP
// bc_type := b_siberite_power ; 33 :
120106: LD_ADDR_OWVAR 42
120110: PUSH
120111: LD_INT 28
120113: ST_TO_ADDR
120114: GO 120155
120116: LD_INT 33
120118: DOUBLE
120119: EQUAL
120120: IFTRUE 120124
120122: GO 120135
120124: POP
// bc_type := b_oil_mine ; 34 :
120125: LD_ADDR_OWVAR 42
120129: PUSH
120130: LD_INT 29
120132: ST_TO_ADDR
120133: GO 120155
120135: LD_INT 34
120137: DOUBLE
120138: EQUAL
120139: IFTRUE 120143
120141: GO 120154
120143: POP
// bc_type := b_siberite_mine ; end ;
120144: LD_ADDR_OWVAR 42
120148: PUSH
120149: LD_INT 30
120151: ST_TO_ADDR
120152: GO 120155
120154: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
120155: LD_ADDR_VAR 0 8
120159: PUSH
120160: LD_VAR 0 5
120164: PPUSH
120165: LD_VAR 0 6
120169: PPUSH
120170: LD_VAR 0 3
120174: PPUSH
120175: CALL_OW 47
120179: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
120180: LD_OWVAR 42
120184: PUSH
120185: LD_INT 32
120187: PUSH
120188: LD_INT 33
120190: PUSH
120191: EMPTY
120192: LIST
120193: LIST
120194: IN
120195: IFFALSE 120211
// PlaceWeaponTurret ( b , weapon ) ;
120197: LD_VAR 0 8
120201: PPUSH
120202: LD_VAR 0 4
120206: PPUSH
120207: CALL_OW 431
// end ;
120211: LD_VAR 0 7
120215: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
120216: LD_INT 0
120218: PPUSH
120219: PPUSH
120220: PPUSH
120221: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120222: LD_ADDR_VAR 0 4
120226: PUSH
120227: LD_INT 22
120229: PUSH
120230: LD_OWVAR 2
120234: PUSH
120235: EMPTY
120236: LIST
120237: LIST
120238: PUSH
120239: LD_INT 2
120241: PUSH
120242: LD_INT 30
120244: PUSH
120245: LD_INT 0
120247: PUSH
120248: EMPTY
120249: LIST
120250: LIST
120251: PUSH
120252: LD_INT 30
120254: PUSH
120255: LD_INT 1
120257: PUSH
120258: EMPTY
120259: LIST
120260: LIST
120261: PUSH
120262: EMPTY
120263: LIST
120264: LIST
120265: LIST
120266: PUSH
120267: EMPTY
120268: LIST
120269: LIST
120270: PPUSH
120271: CALL_OW 69
120275: ST_TO_ADDR
// if not tmp then
120276: LD_VAR 0 4
120280: NOT
120281: IFFALSE 120285
// exit ;
120283: GO 120344
// for i in tmp do
120285: LD_ADDR_VAR 0 2
120289: PUSH
120290: LD_VAR 0 4
120294: PUSH
120295: FOR_IN
120296: IFFALSE 120342
// for j = 1 to 3 do
120298: LD_ADDR_VAR 0 3
120302: PUSH
120303: DOUBLE
120304: LD_INT 1
120306: DEC
120307: ST_TO_ADDR
120308: LD_INT 3
120310: PUSH
120311: FOR_TO
120312: IFFALSE 120338
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
120314: LD_VAR 0 2
120318: PPUSH
120319: CALL_OW 274
120323: PPUSH
120324: LD_VAR 0 3
120328: PPUSH
120329: LD_INT 99999
120331: PPUSH
120332: CALL_OW 277
120336: GO 120311
120338: POP
120339: POP
120340: GO 120295
120342: POP
120343: POP
// end ;
120344: LD_VAR 0 1
120348: RET
// export function hHackSetLevel10 ; var i , j ; begin
120349: LD_INT 0
120351: PPUSH
120352: PPUSH
120353: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
120354: LD_ADDR_VAR 0 2
120358: PUSH
120359: LD_INT 21
120361: PUSH
120362: LD_INT 1
120364: PUSH
120365: EMPTY
120366: LIST
120367: LIST
120368: PPUSH
120369: CALL_OW 69
120373: PUSH
120374: FOR_IN
120375: IFFALSE 120427
// if IsSelected ( i ) then
120377: LD_VAR 0 2
120381: PPUSH
120382: CALL_OW 306
120386: IFFALSE 120425
// begin for j := 1 to 4 do
120388: LD_ADDR_VAR 0 3
120392: PUSH
120393: DOUBLE
120394: LD_INT 1
120396: DEC
120397: ST_TO_ADDR
120398: LD_INT 4
120400: PUSH
120401: FOR_TO
120402: IFFALSE 120423
// SetSkill ( i , j , 10 ) ;
120404: LD_VAR 0 2
120408: PPUSH
120409: LD_VAR 0 3
120413: PPUSH
120414: LD_INT 10
120416: PPUSH
120417: CALL_OW 237
120421: GO 120401
120423: POP
120424: POP
// end ;
120425: GO 120374
120427: POP
120428: POP
// end ;
120429: LD_VAR 0 1
120433: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
120434: LD_INT 0
120436: PPUSH
120437: PPUSH
120438: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
120439: LD_ADDR_VAR 0 2
120443: PUSH
120444: LD_INT 22
120446: PUSH
120447: LD_OWVAR 2
120451: PUSH
120452: EMPTY
120453: LIST
120454: LIST
120455: PUSH
120456: LD_INT 21
120458: PUSH
120459: LD_INT 1
120461: PUSH
120462: EMPTY
120463: LIST
120464: LIST
120465: PUSH
120466: EMPTY
120467: LIST
120468: LIST
120469: PPUSH
120470: CALL_OW 69
120474: PUSH
120475: FOR_IN
120476: IFFALSE 120517
// begin for j := 1 to 4 do
120478: LD_ADDR_VAR 0 3
120482: PUSH
120483: DOUBLE
120484: LD_INT 1
120486: DEC
120487: ST_TO_ADDR
120488: LD_INT 4
120490: PUSH
120491: FOR_TO
120492: IFFALSE 120513
// SetSkill ( i , j , 10 ) ;
120494: LD_VAR 0 2
120498: PPUSH
120499: LD_VAR 0 3
120503: PPUSH
120504: LD_INT 10
120506: PPUSH
120507: CALL_OW 237
120511: GO 120491
120513: POP
120514: POP
// end ;
120515: GO 120475
120517: POP
120518: POP
// end ;
120519: LD_VAR 0 1
120523: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
120524: LD_INT 0
120526: PPUSH
// uc_side := your_side ;
120527: LD_ADDR_OWVAR 20
120531: PUSH
120532: LD_OWVAR 2
120536: ST_TO_ADDR
// uc_nation := nation ;
120537: LD_ADDR_OWVAR 21
120541: PUSH
120542: LD_VAR 0 1
120546: ST_TO_ADDR
// InitHc ;
120547: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
120551: LD_INT 0
120553: PPUSH
120554: LD_VAR 0 2
120558: PPUSH
120559: LD_VAR 0 3
120563: PPUSH
120564: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
120568: LD_VAR 0 4
120572: PPUSH
120573: LD_VAR 0 5
120577: PPUSH
120578: CALL_OW 428
120582: PUSH
120583: LD_INT 0
120585: EQUAL
120586: IFFALSE 120610
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
120588: CALL_OW 44
120592: PPUSH
120593: LD_VAR 0 4
120597: PPUSH
120598: LD_VAR 0 5
120602: PPUSH
120603: LD_INT 1
120605: PPUSH
120606: CALL_OW 48
// end ;
120610: LD_VAR 0 6
120614: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
120615: LD_INT 0
120617: PPUSH
120618: PPUSH
// uc_side := your_side ;
120619: LD_ADDR_OWVAR 20
120623: PUSH
120624: LD_OWVAR 2
120628: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
120629: LD_VAR 0 1
120633: PUSH
120634: LD_INT 1
120636: PUSH
120637: LD_INT 2
120639: PUSH
120640: LD_INT 3
120642: PUSH
120643: LD_INT 4
120645: PUSH
120646: LD_INT 5
120648: PUSH
120649: EMPTY
120650: LIST
120651: LIST
120652: LIST
120653: LIST
120654: LIST
120655: IN
120656: IFFALSE 120668
// uc_nation := nation_american else
120658: LD_ADDR_OWVAR 21
120662: PUSH
120663: LD_INT 1
120665: ST_TO_ADDR
120666: GO 120711
// if chassis in [ 11 , 12 , 13 , 14 ] then
120668: LD_VAR 0 1
120672: PUSH
120673: LD_INT 11
120675: PUSH
120676: LD_INT 12
120678: PUSH
120679: LD_INT 13
120681: PUSH
120682: LD_INT 14
120684: PUSH
120685: EMPTY
120686: LIST
120687: LIST
120688: LIST
120689: LIST
120690: IN
120691: IFFALSE 120703
// uc_nation := nation_arabian else
120693: LD_ADDR_OWVAR 21
120697: PUSH
120698: LD_INT 2
120700: ST_TO_ADDR
120701: GO 120711
// uc_nation := nation_russian ;
120703: LD_ADDR_OWVAR 21
120707: PUSH
120708: LD_INT 3
120710: ST_TO_ADDR
// vc_chassis := chassis ;
120711: LD_ADDR_OWVAR 37
120715: PUSH
120716: LD_VAR 0 1
120720: ST_TO_ADDR
// vc_engine := engine ;
120721: LD_ADDR_OWVAR 39
120725: PUSH
120726: LD_VAR 0 2
120730: ST_TO_ADDR
// vc_control := control ;
120731: LD_ADDR_OWVAR 38
120735: PUSH
120736: LD_VAR 0 3
120740: ST_TO_ADDR
// vc_weapon := weapon ;
120741: LD_ADDR_OWVAR 40
120745: PUSH
120746: LD_VAR 0 4
120750: ST_TO_ADDR
// un := CreateVehicle ;
120751: LD_ADDR_VAR 0 8
120755: PUSH
120756: CALL_OW 45
120760: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
120761: LD_VAR 0 8
120765: PPUSH
120766: LD_INT 0
120768: PPUSH
120769: LD_INT 5
120771: PPUSH
120772: CALL_OW 12
120776: PPUSH
120777: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
120781: LD_VAR 0 8
120785: PPUSH
120786: LD_VAR 0 5
120790: PPUSH
120791: LD_VAR 0 6
120795: PPUSH
120796: LD_INT 1
120798: PPUSH
120799: CALL_OW 48
// end ;
120803: LD_VAR 0 7
120807: RET
// export hInvincible ; every 1 do
120808: GO 120810
120810: DISABLE
// hInvincible := [ ] ;
120811: LD_ADDR_EXP 198
120815: PUSH
120816: EMPTY
120817: ST_TO_ADDR
120818: END
// every 10 do var i ;
120819: GO 120821
120821: DISABLE
120822: LD_INT 0
120824: PPUSH
// begin enable ;
120825: ENABLE
// if not hInvincible then
120826: LD_EXP 198
120830: NOT
120831: IFFALSE 120835
// exit ;
120833: GO 120879
// for i in hInvincible do
120835: LD_ADDR_VAR 0 1
120839: PUSH
120840: LD_EXP 198
120844: PUSH
120845: FOR_IN
120846: IFFALSE 120877
// if GetLives ( i ) < 1000 then
120848: LD_VAR 0 1
120852: PPUSH
120853: CALL_OW 256
120857: PUSH
120858: LD_INT 1000
120860: LESS
120861: IFFALSE 120875
// SetLives ( i , 1000 ) ;
120863: LD_VAR 0 1
120867: PPUSH
120868: LD_INT 1000
120870: PPUSH
120871: CALL_OW 234
120875: GO 120845
120877: POP
120878: POP
// end ;
120879: PPOPN 1
120881: END
// export function hHackInvincible ; var i ; begin
120882: LD_INT 0
120884: PPUSH
120885: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
120886: LD_ADDR_VAR 0 2
120890: PUSH
120891: LD_INT 2
120893: PUSH
120894: LD_INT 21
120896: PUSH
120897: LD_INT 1
120899: PUSH
120900: EMPTY
120901: LIST
120902: LIST
120903: PUSH
120904: LD_INT 21
120906: PUSH
120907: LD_INT 2
120909: PUSH
120910: EMPTY
120911: LIST
120912: LIST
120913: PUSH
120914: EMPTY
120915: LIST
120916: LIST
120917: LIST
120918: PPUSH
120919: CALL_OW 69
120923: PUSH
120924: FOR_IN
120925: IFFALSE 120986
// if IsSelected ( i ) then
120927: LD_VAR 0 2
120931: PPUSH
120932: CALL_OW 306
120936: IFFALSE 120984
// begin if i in hInvincible then
120938: LD_VAR 0 2
120942: PUSH
120943: LD_EXP 198
120947: IN
120948: IFFALSE 120968
// hInvincible := hInvincible diff i else
120950: LD_ADDR_EXP 198
120954: PUSH
120955: LD_EXP 198
120959: PUSH
120960: LD_VAR 0 2
120964: DIFF
120965: ST_TO_ADDR
120966: GO 120984
// hInvincible := hInvincible union i ;
120968: LD_ADDR_EXP 198
120972: PUSH
120973: LD_EXP 198
120977: PUSH
120978: LD_VAR 0 2
120982: UNION
120983: ST_TO_ADDR
// end ;
120984: GO 120924
120986: POP
120987: POP
// end ;
120988: LD_VAR 0 1
120992: RET
// export function hHackInvisible ; var i , j ; begin
120993: LD_INT 0
120995: PPUSH
120996: PPUSH
120997: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
120998: LD_ADDR_VAR 0 2
121002: PUSH
121003: LD_INT 21
121005: PUSH
121006: LD_INT 1
121008: PUSH
121009: EMPTY
121010: LIST
121011: LIST
121012: PPUSH
121013: CALL_OW 69
121017: PUSH
121018: FOR_IN
121019: IFFALSE 121043
// if IsSelected ( i ) then
121021: LD_VAR 0 2
121025: PPUSH
121026: CALL_OW 306
121030: IFFALSE 121041
// ComForceInvisible ( i ) ;
121032: LD_VAR 0 2
121036: PPUSH
121037: CALL_OW 496
121041: GO 121018
121043: POP
121044: POP
// end ;
121045: LD_VAR 0 1
121049: RET
// export function hHackChangeYourSide ; begin
121050: LD_INT 0
121052: PPUSH
// if your_side = 8 then
121053: LD_OWVAR 2
121057: PUSH
121058: LD_INT 8
121060: EQUAL
121061: IFFALSE 121073
// your_side := 0 else
121063: LD_ADDR_OWVAR 2
121067: PUSH
121068: LD_INT 0
121070: ST_TO_ADDR
121071: GO 121087
// your_side := your_side + 1 ;
121073: LD_ADDR_OWVAR 2
121077: PUSH
121078: LD_OWVAR 2
121082: PUSH
121083: LD_INT 1
121085: PLUS
121086: ST_TO_ADDR
// end ;
121087: LD_VAR 0 1
121091: RET
// export function hHackChangeUnitSide ; var i , j ; begin
121092: LD_INT 0
121094: PPUSH
121095: PPUSH
121096: PPUSH
// for i in all_units do
121097: LD_ADDR_VAR 0 2
121101: PUSH
121102: LD_OWVAR 3
121106: PUSH
121107: FOR_IN
121108: IFFALSE 121186
// if IsSelected ( i ) then
121110: LD_VAR 0 2
121114: PPUSH
121115: CALL_OW 306
121119: IFFALSE 121184
// begin j := GetSide ( i ) ;
121121: LD_ADDR_VAR 0 3
121125: PUSH
121126: LD_VAR 0 2
121130: PPUSH
121131: CALL_OW 255
121135: ST_TO_ADDR
// if j = 8 then
121136: LD_VAR 0 3
121140: PUSH
121141: LD_INT 8
121143: EQUAL
121144: IFFALSE 121156
// j := 0 else
121146: LD_ADDR_VAR 0 3
121150: PUSH
121151: LD_INT 0
121153: ST_TO_ADDR
121154: GO 121170
// j := j + 1 ;
121156: LD_ADDR_VAR 0 3
121160: PUSH
121161: LD_VAR 0 3
121165: PUSH
121166: LD_INT 1
121168: PLUS
121169: ST_TO_ADDR
// SetSide ( i , j ) ;
121170: LD_VAR 0 2
121174: PPUSH
121175: LD_VAR 0 3
121179: PPUSH
121180: CALL_OW 235
// end ;
121184: GO 121107
121186: POP
121187: POP
// end ;
121188: LD_VAR 0 1
121192: RET
// export function hHackFog ; begin
121193: LD_INT 0
121195: PPUSH
// FogOff ( true ) ;
121196: LD_INT 1
121198: PPUSH
121199: CALL_OW 344
// end ;
121203: LD_VAR 0 1
121207: RET
// export function hHackTeleport ( unit , x , y ) ; begin
121208: LD_INT 0
121210: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
121211: LD_VAR 0 1
121215: PPUSH
121216: LD_VAR 0 2
121220: PPUSH
121221: LD_VAR 0 3
121225: PPUSH
121226: LD_INT 1
121228: PPUSH
121229: LD_INT 1
121231: PPUSH
121232: CALL_OW 483
// CenterOnXY ( x , y ) ;
121236: LD_VAR 0 2
121240: PPUSH
121241: LD_VAR 0 3
121245: PPUSH
121246: CALL_OW 84
// end ;
121250: LD_VAR 0 4
121254: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
121255: LD_INT 0
121257: PPUSH
121258: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
121259: LD_VAR 0 1
121263: NOT
121264: PUSH
121265: LD_VAR 0 2
121269: PPUSH
121270: LD_VAR 0 3
121274: PPUSH
121275: CALL_OW 488
121279: NOT
121280: OR
121281: PUSH
121282: LD_VAR 0 1
121286: PPUSH
121287: CALL_OW 266
121291: PUSH
121292: LD_INT 3
121294: NONEQUAL
121295: PUSH
121296: LD_VAR 0 1
121300: PPUSH
121301: CALL_OW 247
121305: PUSH
121306: LD_INT 1
121308: EQUAL
121309: NOT
121310: AND
121311: OR
121312: IFFALSE 121316
// exit ;
121314: GO 121465
// if GetType ( factory ) = unit_human then
121316: LD_VAR 0 1
121320: PPUSH
121321: CALL_OW 247
121325: PUSH
121326: LD_INT 1
121328: EQUAL
121329: IFFALSE 121346
// factory := IsInUnit ( factory ) ;
121331: LD_ADDR_VAR 0 1
121335: PUSH
121336: LD_VAR 0 1
121340: PPUSH
121341: CALL_OW 310
121345: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
121346: LD_VAR 0 1
121350: PPUSH
121351: CALL_OW 266
121355: PUSH
121356: LD_INT 3
121358: NONEQUAL
121359: IFFALSE 121363
// exit ;
121361: GO 121465
// if HexInfo ( x , y ) = factory then
121363: LD_VAR 0 2
121367: PPUSH
121368: LD_VAR 0 3
121372: PPUSH
121373: CALL_OW 428
121377: PUSH
121378: LD_VAR 0 1
121382: EQUAL
121383: IFFALSE 121410
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
121385: LD_ADDR_EXP 199
121389: PUSH
121390: LD_EXP 199
121394: PPUSH
121395: LD_VAR 0 1
121399: PPUSH
121400: LD_INT 0
121402: PPUSH
121403: CALL_OW 1
121407: ST_TO_ADDR
121408: GO 121461
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
121410: LD_ADDR_EXP 199
121414: PUSH
121415: LD_EXP 199
121419: PPUSH
121420: LD_VAR 0 1
121424: PPUSH
121425: LD_VAR 0 1
121429: PPUSH
121430: CALL_OW 255
121434: PUSH
121435: LD_VAR 0 1
121439: PUSH
121440: LD_VAR 0 2
121444: PUSH
121445: LD_VAR 0 3
121449: PUSH
121450: EMPTY
121451: LIST
121452: LIST
121453: LIST
121454: LIST
121455: PPUSH
121456: CALL_OW 1
121460: ST_TO_ADDR
// UpdateFactoryWaypoints ;
121461: CALL 121470 0 0
// end ;
121465: LD_VAR 0 4
121469: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
121470: LD_INT 0
121472: PPUSH
121473: PPUSH
121474: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
121475: LD_STRING resetFactoryWaypoint();
121477: PPUSH
121478: CALL_OW 559
// if factoryWaypoints then
121482: LD_EXP 199
121486: IFFALSE 121612
// begin list := PrepareArray ( factoryWaypoints ) ;
121488: LD_ADDR_VAR 0 3
121492: PUSH
121493: LD_EXP 199
121497: PPUSH
121498: CALL 106866 0 1
121502: ST_TO_ADDR
// for i := 1 to list do
121503: LD_ADDR_VAR 0 2
121507: PUSH
121508: DOUBLE
121509: LD_INT 1
121511: DEC
121512: ST_TO_ADDR
121513: LD_VAR 0 3
121517: PUSH
121518: FOR_TO
121519: IFFALSE 121610
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
121521: LD_STRING setFactoryWaypointXY(
121523: PUSH
121524: LD_VAR 0 3
121528: PUSH
121529: LD_VAR 0 2
121533: ARRAY
121534: PUSH
121535: LD_INT 1
121537: ARRAY
121538: STR
121539: PUSH
121540: LD_STRING ,
121542: STR
121543: PUSH
121544: LD_VAR 0 3
121548: PUSH
121549: LD_VAR 0 2
121553: ARRAY
121554: PUSH
121555: LD_INT 2
121557: ARRAY
121558: STR
121559: PUSH
121560: LD_STRING ,
121562: STR
121563: PUSH
121564: LD_VAR 0 3
121568: PUSH
121569: LD_VAR 0 2
121573: ARRAY
121574: PUSH
121575: LD_INT 3
121577: ARRAY
121578: STR
121579: PUSH
121580: LD_STRING ,
121582: STR
121583: PUSH
121584: LD_VAR 0 3
121588: PUSH
121589: LD_VAR 0 2
121593: ARRAY
121594: PUSH
121595: LD_INT 4
121597: ARRAY
121598: STR
121599: PUSH
121600: LD_STRING )
121602: STR
121603: PPUSH
121604: CALL_OW 559
121608: GO 121518
121610: POP
121611: POP
// end ; end ;
121612: LD_VAR 0 1
121616: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
121617: LD_INT 0
121619: PPUSH
// if HexInfo ( x , y ) = warehouse then
121620: LD_VAR 0 2
121624: PPUSH
121625: LD_VAR 0 3
121629: PPUSH
121630: CALL_OW 428
121634: PUSH
121635: LD_VAR 0 1
121639: EQUAL
121640: IFFALSE 121667
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
121642: LD_ADDR_EXP 200
121646: PUSH
121647: LD_EXP 200
121651: PPUSH
121652: LD_VAR 0 1
121656: PPUSH
121657: LD_INT 0
121659: PPUSH
121660: CALL_OW 1
121664: ST_TO_ADDR
121665: GO 121718
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
121667: LD_ADDR_EXP 200
121671: PUSH
121672: LD_EXP 200
121676: PPUSH
121677: LD_VAR 0 1
121681: PPUSH
121682: LD_VAR 0 1
121686: PPUSH
121687: CALL_OW 255
121691: PUSH
121692: LD_VAR 0 1
121696: PUSH
121697: LD_VAR 0 2
121701: PUSH
121702: LD_VAR 0 3
121706: PUSH
121707: EMPTY
121708: LIST
121709: LIST
121710: LIST
121711: LIST
121712: PPUSH
121713: CALL_OW 1
121717: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
121718: CALL 121727 0 0
// end ;
121722: LD_VAR 0 4
121726: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
121727: LD_INT 0
121729: PPUSH
121730: PPUSH
121731: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
121732: LD_STRING resetWarehouseGatheringPoints();
121734: PPUSH
121735: CALL_OW 559
// if warehouseGatheringPoints then
121739: LD_EXP 200
121743: IFFALSE 121869
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
121745: LD_ADDR_VAR 0 3
121749: PUSH
121750: LD_EXP 200
121754: PPUSH
121755: CALL 106866 0 1
121759: ST_TO_ADDR
// for i := 1 to list do
121760: LD_ADDR_VAR 0 2
121764: PUSH
121765: DOUBLE
121766: LD_INT 1
121768: DEC
121769: ST_TO_ADDR
121770: LD_VAR 0 3
121774: PUSH
121775: FOR_TO
121776: IFFALSE 121867
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
121778: LD_STRING setWarehouseGatheringPointXY(
121780: PUSH
121781: LD_VAR 0 3
121785: PUSH
121786: LD_VAR 0 2
121790: ARRAY
121791: PUSH
121792: LD_INT 1
121794: ARRAY
121795: STR
121796: PUSH
121797: LD_STRING ,
121799: STR
121800: PUSH
121801: LD_VAR 0 3
121805: PUSH
121806: LD_VAR 0 2
121810: ARRAY
121811: PUSH
121812: LD_INT 2
121814: ARRAY
121815: STR
121816: PUSH
121817: LD_STRING ,
121819: STR
121820: PUSH
121821: LD_VAR 0 3
121825: PUSH
121826: LD_VAR 0 2
121830: ARRAY
121831: PUSH
121832: LD_INT 3
121834: ARRAY
121835: STR
121836: PUSH
121837: LD_STRING ,
121839: STR
121840: PUSH
121841: LD_VAR 0 3
121845: PUSH
121846: LD_VAR 0 2
121850: ARRAY
121851: PUSH
121852: LD_INT 4
121854: ARRAY
121855: STR
121856: PUSH
121857: LD_STRING )
121859: STR
121860: PPUSH
121861: CALL_OW 559
121865: GO 121775
121867: POP
121868: POP
// end ; end ;
121869: LD_VAR 0 1
121873: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
121874: LD_EXP 200
121878: IFFALSE 122563
121880: GO 121882
121882: DISABLE
121883: LD_INT 0
121885: PPUSH
121886: PPUSH
121887: PPUSH
121888: PPUSH
121889: PPUSH
121890: PPUSH
121891: PPUSH
121892: PPUSH
121893: PPUSH
// begin enable ;
121894: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
121895: LD_ADDR_VAR 0 3
121899: PUSH
121900: LD_EXP 200
121904: PPUSH
121905: CALL 106866 0 1
121909: ST_TO_ADDR
// if not list then
121910: LD_VAR 0 3
121914: NOT
121915: IFFALSE 121919
// exit ;
121917: GO 122563
// for i := 1 to list do
121919: LD_ADDR_VAR 0 1
121923: PUSH
121924: DOUBLE
121925: LD_INT 1
121927: DEC
121928: ST_TO_ADDR
121929: LD_VAR 0 3
121933: PUSH
121934: FOR_TO
121935: IFFALSE 122561
// begin depot := list [ i ] [ 2 ] ;
121937: LD_ADDR_VAR 0 8
121941: PUSH
121942: LD_VAR 0 3
121946: PUSH
121947: LD_VAR 0 1
121951: ARRAY
121952: PUSH
121953: LD_INT 2
121955: ARRAY
121956: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
121957: LD_ADDR_VAR 0 5
121961: PUSH
121962: LD_VAR 0 3
121966: PUSH
121967: LD_VAR 0 1
121971: ARRAY
121972: PUSH
121973: LD_INT 1
121975: ARRAY
121976: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
121977: LD_VAR 0 8
121981: PPUSH
121982: CALL_OW 301
121986: PUSH
121987: LD_VAR 0 5
121991: PUSH
121992: LD_VAR 0 8
121996: PPUSH
121997: CALL_OW 255
122001: NONEQUAL
122002: OR
122003: IFFALSE 122032
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
122005: LD_ADDR_EXP 200
122009: PUSH
122010: LD_EXP 200
122014: PPUSH
122015: LD_VAR 0 8
122019: PPUSH
122020: LD_INT 0
122022: PPUSH
122023: CALL_OW 1
122027: ST_TO_ADDR
// exit ;
122028: POP
122029: POP
122030: GO 122563
// end ; x := list [ i ] [ 3 ] ;
122032: LD_ADDR_VAR 0 6
122036: PUSH
122037: LD_VAR 0 3
122041: PUSH
122042: LD_VAR 0 1
122046: ARRAY
122047: PUSH
122048: LD_INT 3
122050: ARRAY
122051: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
122052: LD_ADDR_VAR 0 7
122056: PUSH
122057: LD_VAR 0 3
122061: PUSH
122062: LD_VAR 0 1
122066: ARRAY
122067: PUSH
122068: LD_INT 4
122070: ARRAY
122071: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
122072: LD_ADDR_VAR 0 9
122076: PUSH
122077: LD_VAR 0 6
122081: PPUSH
122082: LD_VAR 0 7
122086: PPUSH
122087: LD_INT 16
122089: PPUSH
122090: CALL 105454 0 3
122094: ST_TO_ADDR
// if not cratesNearbyPoint then
122095: LD_VAR 0 9
122099: NOT
122100: IFFALSE 122106
// exit ;
122102: POP
122103: POP
122104: GO 122563
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
122106: LD_ADDR_VAR 0 4
122110: PUSH
122111: LD_INT 22
122113: PUSH
122114: LD_VAR 0 5
122118: PUSH
122119: EMPTY
122120: LIST
122121: LIST
122122: PUSH
122123: LD_INT 3
122125: PUSH
122126: LD_INT 60
122128: PUSH
122129: EMPTY
122130: LIST
122131: PUSH
122132: EMPTY
122133: LIST
122134: LIST
122135: PUSH
122136: LD_INT 91
122138: PUSH
122139: LD_VAR 0 8
122143: PUSH
122144: LD_INT 6
122146: PUSH
122147: EMPTY
122148: LIST
122149: LIST
122150: LIST
122151: PUSH
122152: LD_INT 2
122154: PUSH
122155: LD_INT 25
122157: PUSH
122158: LD_INT 2
122160: PUSH
122161: EMPTY
122162: LIST
122163: LIST
122164: PUSH
122165: LD_INT 25
122167: PUSH
122168: LD_INT 16
122170: PUSH
122171: EMPTY
122172: LIST
122173: LIST
122174: PUSH
122175: EMPTY
122176: LIST
122177: LIST
122178: LIST
122179: PUSH
122180: EMPTY
122181: LIST
122182: LIST
122183: LIST
122184: LIST
122185: PPUSH
122186: CALL_OW 69
122190: PUSH
122191: LD_VAR 0 8
122195: PPUSH
122196: CALL_OW 313
122200: PPUSH
122201: LD_INT 3
122203: PUSH
122204: LD_INT 60
122206: PUSH
122207: EMPTY
122208: LIST
122209: PUSH
122210: EMPTY
122211: LIST
122212: LIST
122213: PUSH
122214: LD_INT 2
122216: PUSH
122217: LD_INT 25
122219: PUSH
122220: LD_INT 2
122222: PUSH
122223: EMPTY
122224: LIST
122225: LIST
122226: PUSH
122227: LD_INT 25
122229: PUSH
122230: LD_INT 16
122232: PUSH
122233: EMPTY
122234: LIST
122235: LIST
122236: PUSH
122237: EMPTY
122238: LIST
122239: LIST
122240: LIST
122241: PUSH
122242: EMPTY
122243: LIST
122244: LIST
122245: PPUSH
122246: CALL_OW 72
122250: UNION
122251: ST_TO_ADDR
// if tmp then
122252: LD_VAR 0 4
122256: IFFALSE 122336
// begin tmp := ShrinkArray ( tmp , 3 ) ;
122258: LD_ADDR_VAR 0 4
122262: PUSH
122263: LD_VAR 0 4
122267: PPUSH
122268: LD_INT 3
122270: PPUSH
122271: CALL 103423 0 2
122275: ST_TO_ADDR
// for j in tmp do
122276: LD_ADDR_VAR 0 2
122280: PUSH
122281: LD_VAR 0 4
122285: PUSH
122286: FOR_IN
122287: IFFALSE 122330
// begin if IsInUnit ( j ) then
122289: LD_VAR 0 2
122293: PPUSH
122294: CALL_OW 310
122298: IFFALSE 122309
// ComExit ( j ) ;
122300: LD_VAR 0 2
122304: PPUSH
122305: CALL 103506 0 1
// AddComCollect ( j , x , y ) ;
122309: LD_VAR 0 2
122313: PPUSH
122314: LD_VAR 0 6
122318: PPUSH
122319: LD_VAR 0 7
122323: PPUSH
122324: CALL_OW 177
// end ;
122328: GO 122286
122330: POP
122331: POP
// exit ;
122332: POP
122333: POP
122334: GO 122563
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
122336: LD_ADDR_VAR 0 4
122340: PUSH
122341: LD_INT 22
122343: PUSH
122344: LD_VAR 0 5
122348: PUSH
122349: EMPTY
122350: LIST
122351: LIST
122352: PUSH
122353: LD_INT 91
122355: PUSH
122356: LD_VAR 0 8
122360: PUSH
122361: LD_INT 8
122363: PUSH
122364: EMPTY
122365: LIST
122366: LIST
122367: LIST
122368: PUSH
122369: LD_INT 2
122371: PUSH
122372: LD_INT 34
122374: PUSH
122375: LD_INT 12
122377: PUSH
122378: EMPTY
122379: LIST
122380: LIST
122381: PUSH
122382: LD_INT 34
122384: PUSH
122385: LD_INT 51
122387: PUSH
122388: EMPTY
122389: LIST
122390: LIST
122391: PUSH
122392: LD_INT 34
122394: PUSH
122395: LD_INT 32
122397: PUSH
122398: EMPTY
122399: LIST
122400: LIST
122401: PUSH
122402: LD_INT 34
122404: PUSH
122405: LD_INT 89
122407: PUSH
122408: EMPTY
122409: LIST
122410: LIST
122411: PUSH
122412: EMPTY
122413: LIST
122414: LIST
122415: LIST
122416: LIST
122417: LIST
122418: PUSH
122419: EMPTY
122420: LIST
122421: LIST
122422: LIST
122423: PPUSH
122424: CALL_OW 69
122428: ST_TO_ADDR
// if tmp then
122429: LD_VAR 0 4
122433: IFFALSE 122559
// begin for j in tmp do
122435: LD_ADDR_VAR 0 2
122439: PUSH
122440: LD_VAR 0 4
122444: PUSH
122445: FOR_IN
122446: IFFALSE 122557
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
122448: LD_VAR 0 2
122452: PPUSH
122453: CALL_OW 262
122457: PUSH
122458: LD_INT 3
122460: EQUAL
122461: PUSH
122462: LD_VAR 0 2
122466: PPUSH
122467: CALL_OW 261
122471: PUSH
122472: LD_INT 20
122474: GREATER
122475: OR
122476: PUSH
122477: LD_VAR 0 2
122481: PPUSH
122482: CALL_OW 314
122486: NOT
122487: AND
122488: PUSH
122489: LD_VAR 0 2
122493: PPUSH
122494: CALL_OW 263
122498: PUSH
122499: LD_INT 1
122501: NONEQUAL
122502: PUSH
122503: LD_VAR 0 2
122507: PPUSH
122508: CALL_OW 311
122512: OR
122513: AND
122514: IFFALSE 122555
// begin ComCollect ( j , x , y ) ;
122516: LD_VAR 0 2
122520: PPUSH
122521: LD_VAR 0 6
122525: PPUSH
122526: LD_VAR 0 7
122530: PPUSH
122531: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
122535: LD_VAR 0 2
122539: PPUSH
122540: LD_VAR 0 8
122544: PPUSH
122545: CALL_OW 172
// exit ;
122549: POP
122550: POP
122551: POP
122552: POP
122553: GO 122563
// end ;
122555: GO 122445
122557: POP
122558: POP
// end ; end ;
122559: GO 121934
122561: POP
122562: POP
// end ; end_of_file
122563: PPOPN 9
122565: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
122566: LD_INT 0
122568: PPUSH
122569: PPUSH
122570: PPUSH
122571: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
122572: LD_VAR 0 1
122576: PPUSH
122577: CALL_OW 264
122581: PUSH
122582: LD_INT 91
122584: EQUAL
122585: IFFALSE 122657
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
122587: LD_INT 68
122589: PPUSH
122590: LD_VAR 0 1
122594: PPUSH
122595: CALL_OW 255
122599: PPUSH
122600: CALL_OW 321
122604: PUSH
122605: LD_INT 2
122607: EQUAL
122608: IFFALSE 122620
// eff := 70 else
122610: LD_ADDR_VAR 0 4
122614: PUSH
122615: LD_INT 70
122617: ST_TO_ADDR
122618: GO 122628
// eff := 30 ;
122620: LD_ADDR_VAR 0 4
122624: PUSH
122625: LD_INT 30
122627: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
122628: LD_VAR 0 1
122632: PPUSH
122633: CALL_OW 250
122637: PPUSH
122638: LD_VAR 0 1
122642: PPUSH
122643: CALL_OW 251
122647: PPUSH
122648: LD_VAR 0 4
122652: PPUSH
122653: CALL_OW 495
// end ; end ;
122657: LD_VAR 0 2
122661: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
122662: LD_INT 0
122664: PPUSH
// end ;
122665: LD_VAR 0 4
122669: RET
// export function SOS_Command ( cmd ) ; begin
122670: LD_INT 0
122672: PPUSH
// end ;
122673: LD_VAR 0 2
122677: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
122678: LD_INT 0
122680: PPUSH
// end ;
122681: LD_VAR 0 6
122685: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
122686: LD_INT 0
122688: PPUSH
122689: PPUSH
// if not vehicle or not factory then
122690: LD_VAR 0 1
122694: NOT
122695: PUSH
122696: LD_VAR 0 2
122700: NOT
122701: OR
122702: IFFALSE 122706
// exit ;
122704: GO 122937
// if factoryWaypoints >= factory then
122706: LD_EXP 199
122710: PUSH
122711: LD_VAR 0 2
122715: GREATEREQUAL
122716: IFFALSE 122937
// if factoryWaypoints [ factory ] then
122718: LD_EXP 199
122722: PUSH
122723: LD_VAR 0 2
122727: ARRAY
122728: IFFALSE 122937
// begin if GetControl ( vehicle ) = control_manual then
122730: LD_VAR 0 1
122734: PPUSH
122735: CALL_OW 263
122739: PUSH
122740: LD_INT 1
122742: EQUAL
122743: IFFALSE 122824
// begin driver := IsDrivenBy ( vehicle ) ;
122745: LD_ADDR_VAR 0 4
122749: PUSH
122750: LD_VAR 0 1
122754: PPUSH
122755: CALL_OW 311
122759: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
122760: LD_VAR 0 4
122764: PPUSH
122765: LD_EXP 199
122769: PUSH
122770: LD_VAR 0 2
122774: ARRAY
122775: PUSH
122776: LD_INT 3
122778: ARRAY
122779: PPUSH
122780: LD_EXP 199
122784: PUSH
122785: LD_VAR 0 2
122789: ARRAY
122790: PUSH
122791: LD_INT 4
122793: ARRAY
122794: PPUSH
122795: CALL_OW 171
// AddComExitVehicle ( driver ) ;
122799: LD_VAR 0 4
122803: PPUSH
122804: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
122808: LD_VAR 0 4
122812: PPUSH
122813: LD_VAR 0 2
122817: PPUSH
122818: CALL_OW 180
// end else
122822: GO 122937
// if GetControl ( vehicle ) = control_remote then
122824: LD_VAR 0 1
122828: PPUSH
122829: CALL_OW 263
122833: PUSH
122834: LD_INT 2
122836: EQUAL
122837: IFFALSE 122898
// begin wait ( 0 0$2 ) ;
122839: LD_INT 70
122841: PPUSH
122842: CALL_OW 67
// if Connect ( vehicle ) then
122846: LD_VAR 0 1
122850: PPUSH
122851: CALL 73838 0 1
122855: IFFALSE 122896
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
122857: LD_VAR 0 1
122861: PPUSH
122862: LD_EXP 199
122866: PUSH
122867: LD_VAR 0 2
122871: ARRAY
122872: PUSH
122873: LD_INT 3
122875: ARRAY
122876: PPUSH
122877: LD_EXP 199
122881: PUSH
122882: LD_VAR 0 2
122886: ARRAY
122887: PUSH
122888: LD_INT 4
122890: ARRAY
122891: PPUSH
122892: CALL_OW 171
// end else
122896: GO 122937
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
122898: LD_VAR 0 1
122902: PPUSH
122903: LD_EXP 199
122907: PUSH
122908: LD_VAR 0 2
122912: ARRAY
122913: PUSH
122914: LD_INT 3
122916: ARRAY
122917: PPUSH
122918: LD_EXP 199
122922: PUSH
122923: LD_VAR 0 2
122927: ARRAY
122928: PUSH
122929: LD_INT 4
122931: ARRAY
122932: PPUSH
122933: CALL_OW 171
// end ; end ;
122937: LD_VAR 0 3
122941: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
122942: LD_INT 0
122944: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
122945: LD_VAR 0 1
122949: PUSH
122950: LD_INT 250
122952: EQUAL
122953: PUSH
122954: LD_VAR 0 2
122958: PPUSH
122959: CALL_OW 264
122963: PUSH
122964: LD_INT 81
122966: EQUAL
122967: AND
122968: IFFALSE 122989
// MinerPlaceMine ( unit , x , y ) ;
122970: LD_VAR 0 2
122974: PPUSH
122975: LD_VAR 0 4
122979: PPUSH
122980: LD_VAR 0 5
122984: PPUSH
122985: CALL 125374 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
122989: LD_VAR 0 1
122993: PUSH
122994: LD_INT 251
122996: EQUAL
122997: PUSH
122998: LD_VAR 0 2
123002: PPUSH
123003: CALL_OW 264
123007: PUSH
123008: LD_INT 81
123010: EQUAL
123011: AND
123012: IFFALSE 123033
// MinerDetonateMine ( unit , x , y ) ;
123014: LD_VAR 0 2
123018: PPUSH
123019: LD_VAR 0 4
123023: PPUSH
123024: LD_VAR 0 5
123028: PPUSH
123029: CALL 125649 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
123033: LD_VAR 0 1
123037: PUSH
123038: LD_INT 252
123040: EQUAL
123041: PUSH
123042: LD_VAR 0 2
123046: PPUSH
123047: CALL_OW 264
123051: PUSH
123052: LD_INT 81
123054: EQUAL
123055: AND
123056: IFFALSE 123077
// MinerCreateMinefield ( unit , x , y ) ;
123058: LD_VAR 0 2
123062: PPUSH
123063: LD_VAR 0 4
123067: PPUSH
123068: LD_VAR 0 5
123072: PPUSH
123073: CALL 126066 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
123077: LD_VAR 0 1
123081: PUSH
123082: LD_INT 253
123084: EQUAL
123085: PUSH
123086: LD_VAR 0 2
123090: PPUSH
123091: CALL_OW 257
123095: PUSH
123096: LD_INT 5
123098: EQUAL
123099: AND
123100: IFFALSE 123121
// ComBinocular ( unit , x , y ) ;
123102: LD_VAR 0 2
123106: PPUSH
123107: LD_VAR 0 4
123111: PPUSH
123112: LD_VAR 0 5
123116: PPUSH
123117: CALL 126435 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
123121: LD_VAR 0 1
123125: PUSH
123126: LD_INT 254
123128: EQUAL
123129: PUSH
123130: LD_VAR 0 2
123134: PPUSH
123135: CALL_OW 264
123139: PUSH
123140: LD_INT 99
123142: EQUAL
123143: AND
123144: PUSH
123145: LD_VAR 0 3
123149: PPUSH
123150: CALL_OW 263
123154: PUSH
123155: LD_INT 3
123157: EQUAL
123158: AND
123159: IFFALSE 123175
// HackDestroyVehicle ( unit , selectedUnit ) ;
123161: LD_VAR 0 2
123165: PPUSH
123166: LD_VAR 0 3
123170: PPUSH
123171: CALL 124738 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
123175: LD_VAR 0 1
123179: PUSH
123180: LD_INT 255
123182: EQUAL
123183: PUSH
123184: LD_VAR 0 2
123188: PPUSH
123189: CALL_OW 264
123193: PUSH
123194: LD_INT 14
123196: PUSH
123197: LD_INT 53
123199: PUSH
123200: EMPTY
123201: LIST
123202: LIST
123203: IN
123204: AND
123205: PUSH
123206: LD_VAR 0 4
123210: PPUSH
123211: LD_VAR 0 5
123215: PPUSH
123216: CALL_OW 488
123220: AND
123221: IFFALSE 123245
// CutTreeXYR ( unit , x , y , 12 ) ;
123223: LD_VAR 0 2
123227: PPUSH
123228: LD_VAR 0 4
123232: PPUSH
123233: LD_VAR 0 5
123237: PPUSH
123238: LD_INT 12
123240: PPUSH
123241: CALL 123308 0 4
// if cmd = 256 then
123245: LD_VAR 0 1
123249: PUSH
123250: LD_INT 256
123252: EQUAL
123253: IFFALSE 123274
// SetFactoryWaypoint ( unit , x , y ) ;
123255: LD_VAR 0 2
123259: PPUSH
123260: LD_VAR 0 4
123264: PPUSH
123265: LD_VAR 0 5
123269: PPUSH
123270: CALL 121255 0 3
// if cmd = 257 then
123274: LD_VAR 0 1
123278: PUSH
123279: LD_INT 257
123281: EQUAL
123282: IFFALSE 123303
// SetWarehouseGatheringPoint ( unit , x , y ) ;
123284: LD_VAR 0 2
123288: PPUSH
123289: LD_VAR 0 4
123293: PPUSH
123294: LD_VAR 0 5
123298: PPUSH
123299: CALL 121617 0 3
// end ;
123303: LD_VAR 0 6
123307: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
123308: LD_INT 0
123310: PPUSH
123311: PPUSH
123312: PPUSH
123313: PPUSH
123314: PPUSH
123315: PPUSH
123316: PPUSH
123317: PPUSH
123318: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
123319: LD_VAR 0 1
123323: NOT
123324: PUSH
123325: LD_VAR 0 2
123329: PPUSH
123330: LD_VAR 0 3
123334: PPUSH
123335: CALL_OW 488
123339: NOT
123340: OR
123341: PUSH
123342: LD_VAR 0 4
123346: NOT
123347: OR
123348: IFFALSE 123352
// exit ;
123350: GO 123692
// list := [ ] ;
123352: LD_ADDR_VAR 0 13
123356: PUSH
123357: EMPTY
123358: ST_TO_ADDR
// if x - r < 0 then
123359: LD_VAR 0 2
123363: PUSH
123364: LD_VAR 0 4
123368: MINUS
123369: PUSH
123370: LD_INT 0
123372: LESS
123373: IFFALSE 123385
// min_x := 0 else
123375: LD_ADDR_VAR 0 7
123379: PUSH
123380: LD_INT 0
123382: ST_TO_ADDR
123383: GO 123401
// min_x := x - r ;
123385: LD_ADDR_VAR 0 7
123389: PUSH
123390: LD_VAR 0 2
123394: PUSH
123395: LD_VAR 0 4
123399: MINUS
123400: ST_TO_ADDR
// if y - r < 0 then
123401: LD_VAR 0 3
123405: PUSH
123406: LD_VAR 0 4
123410: MINUS
123411: PUSH
123412: LD_INT 0
123414: LESS
123415: IFFALSE 123427
// min_y := 0 else
123417: LD_ADDR_VAR 0 8
123421: PUSH
123422: LD_INT 0
123424: ST_TO_ADDR
123425: GO 123443
// min_y := y - r ;
123427: LD_ADDR_VAR 0 8
123431: PUSH
123432: LD_VAR 0 3
123436: PUSH
123437: LD_VAR 0 4
123441: MINUS
123442: ST_TO_ADDR
// max_x := x + r ;
123443: LD_ADDR_VAR 0 9
123447: PUSH
123448: LD_VAR 0 2
123452: PUSH
123453: LD_VAR 0 4
123457: PLUS
123458: ST_TO_ADDR
// max_y := y + r ;
123459: LD_ADDR_VAR 0 10
123463: PUSH
123464: LD_VAR 0 3
123468: PUSH
123469: LD_VAR 0 4
123473: PLUS
123474: ST_TO_ADDR
// for _x = min_x to max_x do
123475: LD_ADDR_VAR 0 11
123479: PUSH
123480: DOUBLE
123481: LD_VAR 0 7
123485: DEC
123486: ST_TO_ADDR
123487: LD_VAR 0 9
123491: PUSH
123492: FOR_TO
123493: IFFALSE 123610
// for _y = min_y to max_y do
123495: LD_ADDR_VAR 0 12
123499: PUSH
123500: DOUBLE
123501: LD_VAR 0 8
123505: DEC
123506: ST_TO_ADDR
123507: LD_VAR 0 10
123511: PUSH
123512: FOR_TO
123513: IFFALSE 123606
// begin if not ValidHex ( _x , _y ) then
123515: LD_VAR 0 11
123519: PPUSH
123520: LD_VAR 0 12
123524: PPUSH
123525: CALL_OW 488
123529: NOT
123530: IFFALSE 123534
// continue ;
123532: GO 123512
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
123534: LD_VAR 0 11
123538: PPUSH
123539: LD_VAR 0 12
123543: PPUSH
123544: CALL_OW 351
123548: PUSH
123549: LD_VAR 0 11
123553: PPUSH
123554: LD_VAR 0 12
123558: PPUSH
123559: CALL_OW 554
123563: AND
123564: IFFALSE 123604
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
123566: LD_ADDR_VAR 0 13
123570: PUSH
123571: LD_VAR 0 13
123575: PPUSH
123576: LD_VAR 0 13
123580: PUSH
123581: LD_INT 1
123583: PLUS
123584: PPUSH
123585: LD_VAR 0 11
123589: PUSH
123590: LD_VAR 0 12
123594: PUSH
123595: EMPTY
123596: LIST
123597: LIST
123598: PPUSH
123599: CALL_OW 2
123603: ST_TO_ADDR
// end ;
123604: GO 123512
123606: POP
123607: POP
123608: GO 123492
123610: POP
123611: POP
// if not list then
123612: LD_VAR 0 13
123616: NOT
123617: IFFALSE 123621
// exit ;
123619: GO 123692
// for i in list do
123621: LD_ADDR_VAR 0 6
123625: PUSH
123626: LD_VAR 0 13
123630: PUSH
123631: FOR_IN
123632: IFFALSE 123690
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
123634: LD_VAR 0 1
123638: PPUSH
123639: LD_STRING M
123641: PUSH
123642: LD_VAR 0 6
123646: PUSH
123647: LD_INT 1
123649: ARRAY
123650: PUSH
123651: LD_VAR 0 6
123655: PUSH
123656: LD_INT 2
123658: ARRAY
123659: PUSH
123660: LD_INT 0
123662: PUSH
123663: LD_INT 0
123665: PUSH
123666: LD_INT 0
123668: PUSH
123669: LD_INT 0
123671: PUSH
123672: EMPTY
123673: LIST
123674: LIST
123675: LIST
123676: LIST
123677: LIST
123678: LIST
123679: LIST
123680: PUSH
123681: EMPTY
123682: LIST
123683: PPUSH
123684: CALL_OW 447
123688: GO 123631
123690: POP
123691: POP
// end ;
123692: LD_VAR 0 5
123696: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
123697: LD_EXP 202
123701: NOT
123702: IFFALSE 123752
123704: GO 123706
123706: DISABLE
// begin initHack := true ;
123707: LD_ADDR_EXP 202
123711: PUSH
123712: LD_INT 1
123714: ST_TO_ADDR
// hackTanks := [ ] ;
123715: LD_ADDR_EXP 203
123719: PUSH
123720: EMPTY
123721: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
123722: LD_ADDR_EXP 204
123726: PUSH
123727: EMPTY
123728: ST_TO_ADDR
// hackLimit := 3 ;
123729: LD_ADDR_EXP 205
123733: PUSH
123734: LD_INT 3
123736: ST_TO_ADDR
// hackDist := 12 ;
123737: LD_ADDR_EXP 206
123741: PUSH
123742: LD_INT 12
123744: ST_TO_ADDR
// hackCounter := [ ] ;
123745: LD_ADDR_EXP 207
123749: PUSH
123750: EMPTY
123751: ST_TO_ADDR
// end ;
123752: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
123753: LD_EXP 202
123757: PUSH
123758: LD_INT 34
123760: PUSH
123761: LD_INT 99
123763: PUSH
123764: EMPTY
123765: LIST
123766: LIST
123767: PPUSH
123768: CALL_OW 69
123772: AND
123773: IFFALSE 124026
123775: GO 123777
123777: DISABLE
123778: LD_INT 0
123780: PPUSH
123781: PPUSH
// begin enable ;
123782: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
123783: LD_ADDR_VAR 0 1
123787: PUSH
123788: LD_INT 34
123790: PUSH
123791: LD_INT 99
123793: PUSH
123794: EMPTY
123795: LIST
123796: LIST
123797: PPUSH
123798: CALL_OW 69
123802: PUSH
123803: FOR_IN
123804: IFFALSE 124024
// begin if not i in hackTanks then
123806: LD_VAR 0 1
123810: PUSH
123811: LD_EXP 203
123815: IN
123816: NOT
123817: IFFALSE 123900
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
123819: LD_ADDR_EXP 203
123823: PUSH
123824: LD_EXP 203
123828: PPUSH
123829: LD_EXP 203
123833: PUSH
123834: LD_INT 1
123836: PLUS
123837: PPUSH
123838: LD_VAR 0 1
123842: PPUSH
123843: CALL_OW 1
123847: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
123848: LD_ADDR_EXP 204
123852: PUSH
123853: LD_EXP 204
123857: PPUSH
123858: LD_EXP 204
123862: PUSH
123863: LD_INT 1
123865: PLUS
123866: PPUSH
123867: EMPTY
123868: PPUSH
123869: CALL_OW 1
123873: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
123874: LD_ADDR_EXP 207
123878: PUSH
123879: LD_EXP 207
123883: PPUSH
123884: LD_EXP 207
123888: PUSH
123889: LD_INT 1
123891: PLUS
123892: PPUSH
123893: EMPTY
123894: PPUSH
123895: CALL_OW 1
123899: ST_TO_ADDR
// end ; if not IsOk ( i ) then
123900: LD_VAR 0 1
123904: PPUSH
123905: CALL_OW 302
123909: NOT
123910: IFFALSE 123923
// begin HackUnlinkAll ( i ) ;
123912: LD_VAR 0 1
123916: PPUSH
123917: CALL 124029 0 1
// continue ;
123921: GO 123803
// end ; HackCheckCapturedStatus ( i ) ;
123923: LD_VAR 0 1
123927: PPUSH
123928: CALL 124472 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
123932: LD_ADDR_VAR 0 2
123936: PUSH
123937: LD_INT 81
123939: PUSH
123940: LD_VAR 0 1
123944: PPUSH
123945: CALL_OW 255
123949: PUSH
123950: EMPTY
123951: LIST
123952: LIST
123953: PUSH
123954: LD_INT 33
123956: PUSH
123957: LD_INT 3
123959: PUSH
123960: EMPTY
123961: LIST
123962: LIST
123963: PUSH
123964: LD_INT 91
123966: PUSH
123967: LD_VAR 0 1
123971: PUSH
123972: LD_EXP 206
123976: PUSH
123977: EMPTY
123978: LIST
123979: LIST
123980: LIST
123981: PUSH
123982: LD_INT 50
123984: PUSH
123985: EMPTY
123986: LIST
123987: PUSH
123988: EMPTY
123989: LIST
123990: LIST
123991: LIST
123992: LIST
123993: PPUSH
123994: CALL_OW 69
123998: ST_TO_ADDR
// if not tmp then
123999: LD_VAR 0 2
124003: NOT
124004: IFFALSE 124008
// continue ;
124006: GO 123803
// HackLink ( i , tmp ) ;
124008: LD_VAR 0 1
124012: PPUSH
124013: LD_VAR 0 2
124017: PPUSH
124018: CALL 124165 0 2
// end ;
124022: GO 123803
124024: POP
124025: POP
// end ;
124026: PPOPN 2
124028: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
124029: LD_INT 0
124031: PPUSH
124032: PPUSH
124033: PPUSH
// if not hack in hackTanks then
124034: LD_VAR 0 1
124038: PUSH
124039: LD_EXP 203
124043: IN
124044: NOT
124045: IFFALSE 124049
// exit ;
124047: GO 124160
// index := GetElementIndex ( hackTanks , hack ) ;
124049: LD_ADDR_VAR 0 4
124053: PUSH
124054: LD_EXP 203
124058: PPUSH
124059: LD_VAR 0 1
124063: PPUSH
124064: CALL 70654 0 2
124068: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
124069: LD_EXP 204
124073: PUSH
124074: LD_VAR 0 4
124078: ARRAY
124079: IFFALSE 124160
// begin for i in hackTanksCaptured [ index ] do
124081: LD_ADDR_VAR 0 3
124085: PUSH
124086: LD_EXP 204
124090: PUSH
124091: LD_VAR 0 4
124095: ARRAY
124096: PUSH
124097: FOR_IN
124098: IFFALSE 124124
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
124100: LD_VAR 0 3
124104: PUSH
124105: LD_INT 1
124107: ARRAY
124108: PPUSH
124109: LD_VAR 0 3
124113: PUSH
124114: LD_INT 2
124116: ARRAY
124117: PPUSH
124118: CALL_OW 235
124122: GO 124097
124124: POP
124125: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
124126: LD_ADDR_EXP 204
124130: PUSH
124131: LD_EXP 204
124135: PPUSH
124136: LD_VAR 0 4
124140: PPUSH
124141: EMPTY
124142: PPUSH
124143: CALL_OW 1
124147: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
124148: LD_VAR 0 1
124152: PPUSH
124153: LD_INT 0
124155: PPUSH
124156: CALL_OW 505
// end ; end ;
124160: LD_VAR 0 2
124164: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
124165: LD_INT 0
124167: PPUSH
124168: PPUSH
124169: PPUSH
// if not hack in hackTanks or not vehicles then
124170: LD_VAR 0 1
124174: PUSH
124175: LD_EXP 203
124179: IN
124180: NOT
124181: PUSH
124182: LD_VAR 0 2
124186: NOT
124187: OR
124188: IFFALSE 124192
// exit ;
124190: GO 124467
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
124192: LD_ADDR_VAR 0 2
124196: PUSH
124197: LD_VAR 0 1
124201: PPUSH
124202: LD_VAR 0 2
124206: PPUSH
124207: LD_INT 1
124209: PPUSH
124210: LD_INT 1
124212: PPUSH
124213: CALL 71304 0 4
124217: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
124218: LD_ADDR_VAR 0 5
124222: PUSH
124223: LD_EXP 203
124227: PPUSH
124228: LD_VAR 0 1
124232: PPUSH
124233: CALL 70654 0 2
124237: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
124238: LD_EXP 204
124242: PUSH
124243: LD_VAR 0 5
124247: ARRAY
124248: PUSH
124249: LD_EXP 205
124253: LESS
124254: IFFALSE 124443
// begin for i := 1 to vehicles do
124256: LD_ADDR_VAR 0 4
124260: PUSH
124261: DOUBLE
124262: LD_INT 1
124264: DEC
124265: ST_TO_ADDR
124266: LD_VAR 0 2
124270: PUSH
124271: FOR_TO
124272: IFFALSE 124441
// begin if hackTanksCaptured [ index ] = hackLimit then
124274: LD_EXP 204
124278: PUSH
124279: LD_VAR 0 5
124283: ARRAY
124284: PUSH
124285: LD_EXP 205
124289: EQUAL
124290: IFFALSE 124294
// break ;
124292: GO 124441
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
124294: LD_ADDR_EXP 207
124298: PUSH
124299: LD_EXP 207
124303: PPUSH
124304: LD_VAR 0 5
124308: PPUSH
124309: LD_EXP 207
124313: PUSH
124314: LD_VAR 0 5
124318: ARRAY
124319: PUSH
124320: LD_INT 1
124322: PLUS
124323: PPUSH
124324: CALL_OW 1
124328: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
124329: LD_ADDR_EXP 204
124333: PUSH
124334: LD_EXP 204
124338: PPUSH
124339: LD_VAR 0 5
124343: PUSH
124344: LD_EXP 204
124348: PUSH
124349: LD_VAR 0 5
124353: ARRAY
124354: PUSH
124355: LD_INT 1
124357: PLUS
124358: PUSH
124359: EMPTY
124360: LIST
124361: LIST
124362: PPUSH
124363: LD_VAR 0 2
124367: PUSH
124368: LD_VAR 0 4
124372: ARRAY
124373: PUSH
124374: LD_VAR 0 2
124378: PUSH
124379: LD_VAR 0 4
124383: ARRAY
124384: PPUSH
124385: CALL_OW 255
124389: PUSH
124390: EMPTY
124391: LIST
124392: LIST
124393: PPUSH
124394: CALL 70869 0 3
124398: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
124399: LD_VAR 0 2
124403: PUSH
124404: LD_VAR 0 4
124408: ARRAY
124409: PPUSH
124410: LD_VAR 0 1
124414: PPUSH
124415: CALL_OW 255
124419: PPUSH
124420: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
124424: LD_VAR 0 2
124428: PUSH
124429: LD_VAR 0 4
124433: ARRAY
124434: PPUSH
124435: CALL_OW 141
// end ;
124439: GO 124271
124441: POP
124442: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
124443: LD_VAR 0 1
124447: PPUSH
124448: LD_EXP 204
124452: PUSH
124453: LD_VAR 0 5
124457: ARRAY
124458: PUSH
124459: LD_INT 0
124461: PLUS
124462: PPUSH
124463: CALL_OW 505
// end ;
124467: LD_VAR 0 3
124471: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
124472: LD_INT 0
124474: PPUSH
124475: PPUSH
124476: PPUSH
124477: PPUSH
// if not hack in hackTanks then
124478: LD_VAR 0 1
124482: PUSH
124483: LD_EXP 203
124487: IN
124488: NOT
124489: IFFALSE 124493
// exit ;
124491: GO 124733
// index := GetElementIndex ( hackTanks , hack ) ;
124493: LD_ADDR_VAR 0 4
124497: PUSH
124498: LD_EXP 203
124502: PPUSH
124503: LD_VAR 0 1
124507: PPUSH
124508: CALL 70654 0 2
124512: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
124513: LD_ADDR_VAR 0 3
124517: PUSH
124518: DOUBLE
124519: LD_EXP 204
124523: PUSH
124524: LD_VAR 0 4
124528: ARRAY
124529: INC
124530: ST_TO_ADDR
124531: LD_INT 1
124533: PUSH
124534: FOR_DOWNTO
124535: IFFALSE 124707
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
124537: LD_ADDR_VAR 0 5
124541: PUSH
124542: LD_EXP 204
124546: PUSH
124547: LD_VAR 0 4
124551: ARRAY
124552: PUSH
124553: LD_VAR 0 3
124557: ARRAY
124558: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
124559: LD_VAR 0 5
124563: PUSH
124564: LD_INT 1
124566: ARRAY
124567: PPUSH
124568: CALL_OW 302
124572: NOT
124573: PUSH
124574: LD_VAR 0 5
124578: PUSH
124579: LD_INT 1
124581: ARRAY
124582: PPUSH
124583: CALL_OW 255
124587: PUSH
124588: LD_VAR 0 1
124592: PPUSH
124593: CALL_OW 255
124597: NONEQUAL
124598: OR
124599: IFFALSE 124705
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
124601: LD_VAR 0 5
124605: PUSH
124606: LD_INT 1
124608: ARRAY
124609: PPUSH
124610: CALL_OW 305
124614: PUSH
124615: LD_VAR 0 5
124619: PUSH
124620: LD_INT 1
124622: ARRAY
124623: PPUSH
124624: CALL_OW 255
124628: PUSH
124629: LD_VAR 0 1
124633: PPUSH
124634: CALL_OW 255
124638: EQUAL
124639: AND
124640: IFFALSE 124664
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
124642: LD_VAR 0 5
124646: PUSH
124647: LD_INT 1
124649: ARRAY
124650: PPUSH
124651: LD_VAR 0 5
124655: PUSH
124656: LD_INT 2
124658: ARRAY
124659: PPUSH
124660: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
124664: LD_ADDR_EXP 204
124668: PUSH
124669: LD_EXP 204
124673: PPUSH
124674: LD_VAR 0 4
124678: PPUSH
124679: LD_EXP 204
124683: PUSH
124684: LD_VAR 0 4
124688: ARRAY
124689: PPUSH
124690: LD_VAR 0 3
124694: PPUSH
124695: CALL_OW 3
124699: PPUSH
124700: CALL_OW 1
124704: ST_TO_ADDR
// end ; end ;
124705: GO 124534
124707: POP
124708: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
124709: LD_VAR 0 1
124713: PPUSH
124714: LD_EXP 204
124718: PUSH
124719: LD_VAR 0 4
124723: ARRAY
124724: PUSH
124725: LD_INT 0
124727: PLUS
124728: PPUSH
124729: CALL_OW 505
// end ;
124733: LD_VAR 0 2
124737: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
124738: LD_INT 0
124740: PPUSH
124741: PPUSH
124742: PPUSH
124743: PPUSH
// if not hack in hackTanks then
124744: LD_VAR 0 1
124748: PUSH
124749: LD_EXP 203
124753: IN
124754: NOT
124755: IFFALSE 124759
// exit ;
124757: GO 124844
// index := GetElementIndex ( hackTanks , hack ) ;
124759: LD_ADDR_VAR 0 5
124763: PUSH
124764: LD_EXP 203
124768: PPUSH
124769: LD_VAR 0 1
124773: PPUSH
124774: CALL 70654 0 2
124778: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
124779: LD_ADDR_VAR 0 4
124783: PUSH
124784: DOUBLE
124785: LD_INT 1
124787: DEC
124788: ST_TO_ADDR
124789: LD_EXP 204
124793: PUSH
124794: LD_VAR 0 5
124798: ARRAY
124799: PUSH
124800: FOR_TO
124801: IFFALSE 124842
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
124803: LD_EXP 204
124807: PUSH
124808: LD_VAR 0 5
124812: ARRAY
124813: PUSH
124814: LD_VAR 0 4
124818: ARRAY
124819: PUSH
124820: LD_INT 1
124822: ARRAY
124823: PUSH
124824: LD_VAR 0 2
124828: EQUAL
124829: IFFALSE 124840
// KillUnit ( vehicle ) ;
124831: LD_VAR 0 2
124835: PPUSH
124836: CALL_OW 66
124840: GO 124800
124842: POP
124843: POP
// end ;
124844: LD_VAR 0 3
124848: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
124849: LD_EXP 208
124853: NOT
124854: IFFALSE 124889
124856: GO 124858
124858: DISABLE
// begin initMiner := true ;
124859: LD_ADDR_EXP 208
124863: PUSH
124864: LD_INT 1
124866: ST_TO_ADDR
// minersList := [ ] ;
124867: LD_ADDR_EXP 209
124871: PUSH
124872: EMPTY
124873: ST_TO_ADDR
// minerMinesList := [ ] ;
124874: LD_ADDR_EXP 210
124878: PUSH
124879: EMPTY
124880: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
124881: LD_ADDR_EXP 211
124885: PUSH
124886: LD_INT 5
124888: ST_TO_ADDR
// end ;
124889: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
124890: LD_EXP 208
124894: PUSH
124895: LD_INT 34
124897: PUSH
124898: LD_INT 81
124900: PUSH
124901: EMPTY
124902: LIST
124903: LIST
124904: PPUSH
124905: CALL_OW 69
124909: AND
124910: IFFALSE 125371
124912: GO 124914
124914: DISABLE
124915: LD_INT 0
124917: PPUSH
124918: PPUSH
124919: PPUSH
124920: PPUSH
// begin enable ;
124921: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
124922: LD_ADDR_VAR 0 1
124926: PUSH
124927: LD_INT 34
124929: PUSH
124930: LD_INT 81
124932: PUSH
124933: EMPTY
124934: LIST
124935: LIST
124936: PPUSH
124937: CALL_OW 69
124941: PUSH
124942: FOR_IN
124943: IFFALSE 125015
// begin if not i in minersList then
124945: LD_VAR 0 1
124949: PUSH
124950: LD_EXP 209
124954: IN
124955: NOT
124956: IFFALSE 125013
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
124958: LD_ADDR_EXP 209
124962: PUSH
124963: LD_EXP 209
124967: PPUSH
124968: LD_EXP 209
124972: PUSH
124973: LD_INT 1
124975: PLUS
124976: PPUSH
124977: LD_VAR 0 1
124981: PPUSH
124982: CALL_OW 1
124986: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
124987: LD_ADDR_EXP 210
124991: PUSH
124992: LD_EXP 210
124996: PPUSH
124997: LD_EXP 210
125001: PUSH
125002: LD_INT 1
125004: PLUS
125005: PPUSH
125006: EMPTY
125007: PPUSH
125008: CALL_OW 1
125012: ST_TO_ADDR
// end end ;
125013: GO 124942
125015: POP
125016: POP
// for i := minerMinesList downto 1 do
125017: LD_ADDR_VAR 0 1
125021: PUSH
125022: DOUBLE
125023: LD_EXP 210
125027: INC
125028: ST_TO_ADDR
125029: LD_INT 1
125031: PUSH
125032: FOR_DOWNTO
125033: IFFALSE 125369
// begin if IsLive ( minersList [ i ] ) then
125035: LD_EXP 209
125039: PUSH
125040: LD_VAR 0 1
125044: ARRAY
125045: PPUSH
125046: CALL_OW 300
125050: IFFALSE 125078
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
125052: LD_EXP 209
125056: PUSH
125057: LD_VAR 0 1
125061: ARRAY
125062: PPUSH
125063: LD_EXP 210
125067: PUSH
125068: LD_VAR 0 1
125072: ARRAY
125073: PPUSH
125074: CALL_OW 505
// if not minerMinesList [ i ] then
125078: LD_EXP 210
125082: PUSH
125083: LD_VAR 0 1
125087: ARRAY
125088: NOT
125089: IFFALSE 125093
// continue ;
125091: GO 125032
// for j := minerMinesList [ i ] downto 1 do
125093: LD_ADDR_VAR 0 2
125097: PUSH
125098: DOUBLE
125099: LD_EXP 210
125103: PUSH
125104: LD_VAR 0 1
125108: ARRAY
125109: INC
125110: ST_TO_ADDR
125111: LD_INT 1
125113: PUSH
125114: FOR_DOWNTO
125115: IFFALSE 125365
// begin side := GetSide ( minersList [ i ] ) ;
125117: LD_ADDR_VAR 0 3
125121: PUSH
125122: LD_EXP 209
125126: PUSH
125127: LD_VAR 0 1
125131: ARRAY
125132: PPUSH
125133: CALL_OW 255
125137: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
125138: LD_ADDR_VAR 0 4
125142: PUSH
125143: LD_EXP 210
125147: PUSH
125148: LD_VAR 0 1
125152: ARRAY
125153: PUSH
125154: LD_VAR 0 2
125158: ARRAY
125159: PUSH
125160: LD_INT 1
125162: ARRAY
125163: PPUSH
125164: LD_EXP 210
125168: PUSH
125169: LD_VAR 0 1
125173: ARRAY
125174: PUSH
125175: LD_VAR 0 2
125179: ARRAY
125180: PUSH
125181: LD_INT 2
125183: ARRAY
125184: PPUSH
125185: CALL_OW 428
125189: ST_TO_ADDR
// if not tmp then
125190: LD_VAR 0 4
125194: NOT
125195: IFFALSE 125199
// continue ;
125197: GO 125114
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
125199: LD_VAR 0 4
125203: PUSH
125204: LD_INT 81
125206: PUSH
125207: LD_VAR 0 3
125211: PUSH
125212: EMPTY
125213: LIST
125214: LIST
125215: PPUSH
125216: CALL_OW 69
125220: IN
125221: PUSH
125222: LD_EXP 210
125226: PUSH
125227: LD_VAR 0 1
125231: ARRAY
125232: PUSH
125233: LD_VAR 0 2
125237: ARRAY
125238: PUSH
125239: LD_INT 1
125241: ARRAY
125242: PPUSH
125243: LD_EXP 210
125247: PUSH
125248: LD_VAR 0 1
125252: ARRAY
125253: PUSH
125254: LD_VAR 0 2
125258: ARRAY
125259: PUSH
125260: LD_INT 2
125262: ARRAY
125263: PPUSH
125264: CALL_OW 458
125268: AND
125269: IFFALSE 125363
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
125271: LD_EXP 210
125275: PUSH
125276: LD_VAR 0 1
125280: ARRAY
125281: PUSH
125282: LD_VAR 0 2
125286: ARRAY
125287: PUSH
125288: LD_INT 1
125290: ARRAY
125291: PPUSH
125292: LD_EXP 210
125296: PUSH
125297: LD_VAR 0 1
125301: ARRAY
125302: PUSH
125303: LD_VAR 0 2
125307: ARRAY
125308: PUSH
125309: LD_INT 2
125311: ARRAY
125312: PPUSH
125313: LD_VAR 0 3
125317: PPUSH
125318: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
125322: LD_ADDR_EXP 210
125326: PUSH
125327: LD_EXP 210
125331: PPUSH
125332: LD_VAR 0 1
125336: PPUSH
125337: LD_EXP 210
125341: PUSH
125342: LD_VAR 0 1
125346: ARRAY
125347: PPUSH
125348: LD_VAR 0 2
125352: PPUSH
125353: CALL_OW 3
125357: PPUSH
125358: CALL_OW 1
125362: ST_TO_ADDR
// end ; end ;
125363: GO 125114
125365: POP
125366: POP
// end ;
125367: GO 125032
125369: POP
125370: POP
// end ;
125371: PPOPN 4
125373: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
125374: LD_INT 0
125376: PPUSH
125377: PPUSH
// result := false ;
125378: LD_ADDR_VAR 0 4
125382: PUSH
125383: LD_INT 0
125385: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
125386: LD_VAR 0 1
125390: PPUSH
125391: CALL_OW 264
125395: PUSH
125396: LD_INT 81
125398: EQUAL
125399: NOT
125400: IFFALSE 125404
// exit ;
125402: GO 125644
// index := GetElementIndex ( minersList , unit ) ;
125404: LD_ADDR_VAR 0 5
125408: PUSH
125409: LD_EXP 209
125413: PPUSH
125414: LD_VAR 0 1
125418: PPUSH
125419: CALL 70654 0 2
125423: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
125424: LD_EXP 210
125428: PUSH
125429: LD_VAR 0 5
125433: ARRAY
125434: PUSH
125435: LD_EXP 211
125439: GREATEREQUAL
125440: IFFALSE 125444
// exit ;
125442: GO 125644
// ComMoveXY ( unit , x , y ) ;
125444: LD_VAR 0 1
125448: PPUSH
125449: LD_VAR 0 2
125453: PPUSH
125454: LD_VAR 0 3
125458: PPUSH
125459: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
125463: LD_INT 35
125465: PPUSH
125466: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
125470: LD_VAR 0 1
125474: PPUSH
125475: LD_VAR 0 2
125479: PPUSH
125480: LD_VAR 0 3
125484: PPUSH
125485: CALL 101917 0 3
125489: NOT
125490: PUSH
125491: LD_VAR 0 1
125495: PPUSH
125496: CALL_OW 314
125500: AND
125501: IFFALSE 125505
// exit ;
125503: GO 125644
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
125505: LD_VAR 0 2
125509: PPUSH
125510: LD_VAR 0 3
125514: PPUSH
125515: CALL_OW 428
125519: PUSH
125520: LD_VAR 0 1
125524: EQUAL
125525: PUSH
125526: LD_VAR 0 1
125530: PPUSH
125531: CALL_OW 314
125535: NOT
125536: AND
125537: IFFALSE 125463
// PlaySoundXY ( x , y , PlantMine ) ;
125539: LD_VAR 0 2
125543: PPUSH
125544: LD_VAR 0 3
125548: PPUSH
125549: LD_STRING PlantMine
125551: PPUSH
125552: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
125556: LD_VAR 0 2
125560: PPUSH
125561: LD_VAR 0 3
125565: PPUSH
125566: LD_VAR 0 1
125570: PPUSH
125571: CALL_OW 255
125575: PPUSH
125576: LD_INT 0
125578: PPUSH
125579: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
125583: LD_ADDR_EXP 210
125587: PUSH
125588: LD_EXP 210
125592: PPUSH
125593: LD_VAR 0 5
125597: PUSH
125598: LD_EXP 210
125602: PUSH
125603: LD_VAR 0 5
125607: ARRAY
125608: PUSH
125609: LD_INT 1
125611: PLUS
125612: PUSH
125613: EMPTY
125614: LIST
125615: LIST
125616: PPUSH
125617: LD_VAR 0 2
125621: PUSH
125622: LD_VAR 0 3
125626: PUSH
125627: EMPTY
125628: LIST
125629: LIST
125630: PPUSH
125631: CALL 70869 0 3
125635: ST_TO_ADDR
// result := true ;
125636: LD_ADDR_VAR 0 4
125640: PUSH
125641: LD_INT 1
125643: ST_TO_ADDR
// end ;
125644: LD_VAR 0 4
125648: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
125649: LD_INT 0
125651: PPUSH
125652: PPUSH
125653: PPUSH
// if not unit in minersList then
125654: LD_VAR 0 1
125658: PUSH
125659: LD_EXP 209
125663: IN
125664: NOT
125665: IFFALSE 125669
// exit ;
125667: GO 126061
// index := GetElementIndex ( minersList , unit ) ;
125669: LD_ADDR_VAR 0 6
125673: PUSH
125674: LD_EXP 209
125678: PPUSH
125679: LD_VAR 0 1
125683: PPUSH
125684: CALL 70654 0 2
125688: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
125689: LD_ADDR_VAR 0 5
125693: PUSH
125694: DOUBLE
125695: LD_EXP 210
125699: PUSH
125700: LD_VAR 0 6
125704: ARRAY
125705: INC
125706: ST_TO_ADDR
125707: LD_INT 1
125709: PUSH
125710: FOR_DOWNTO
125711: IFFALSE 125872
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
125713: LD_EXP 210
125717: PUSH
125718: LD_VAR 0 6
125722: ARRAY
125723: PUSH
125724: LD_VAR 0 5
125728: ARRAY
125729: PUSH
125730: LD_INT 1
125732: ARRAY
125733: PUSH
125734: LD_VAR 0 2
125738: EQUAL
125739: PUSH
125740: LD_EXP 210
125744: PUSH
125745: LD_VAR 0 6
125749: ARRAY
125750: PUSH
125751: LD_VAR 0 5
125755: ARRAY
125756: PUSH
125757: LD_INT 2
125759: ARRAY
125760: PUSH
125761: LD_VAR 0 3
125765: EQUAL
125766: AND
125767: IFFALSE 125870
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
125769: LD_EXP 210
125773: PUSH
125774: LD_VAR 0 6
125778: ARRAY
125779: PUSH
125780: LD_VAR 0 5
125784: ARRAY
125785: PUSH
125786: LD_INT 1
125788: ARRAY
125789: PPUSH
125790: LD_EXP 210
125794: PUSH
125795: LD_VAR 0 6
125799: ARRAY
125800: PUSH
125801: LD_VAR 0 5
125805: ARRAY
125806: PUSH
125807: LD_INT 2
125809: ARRAY
125810: PPUSH
125811: LD_VAR 0 1
125815: PPUSH
125816: CALL_OW 255
125820: PPUSH
125821: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
125825: LD_ADDR_EXP 210
125829: PUSH
125830: LD_EXP 210
125834: PPUSH
125835: LD_VAR 0 6
125839: PPUSH
125840: LD_EXP 210
125844: PUSH
125845: LD_VAR 0 6
125849: ARRAY
125850: PPUSH
125851: LD_VAR 0 5
125855: PPUSH
125856: CALL_OW 3
125860: PPUSH
125861: CALL_OW 1
125865: ST_TO_ADDR
// exit ;
125866: POP
125867: POP
125868: GO 126061
// end ; end ;
125870: GO 125710
125872: POP
125873: POP
// for i := minerMinesList [ index ] downto 1 do
125874: LD_ADDR_VAR 0 5
125878: PUSH
125879: DOUBLE
125880: LD_EXP 210
125884: PUSH
125885: LD_VAR 0 6
125889: ARRAY
125890: INC
125891: ST_TO_ADDR
125892: LD_INT 1
125894: PUSH
125895: FOR_DOWNTO
125896: IFFALSE 126059
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
125898: LD_EXP 210
125902: PUSH
125903: LD_VAR 0 6
125907: ARRAY
125908: PUSH
125909: LD_VAR 0 5
125913: ARRAY
125914: PUSH
125915: LD_INT 1
125917: ARRAY
125918: PPUSH
125919: LD_EXP 210
125923: PUSH
125924: LD_VAR 0 6
125928: ARRAY
125929: PUSH
125930: LD_VAR 0 5
125934: ARRAY
125935: PUSH
125936: LD_INT 2
125938: ARRAY
125939: PPUSH
125940: LD_VAR 0 2
125944: PPUSH
125945: LD_VAR 0 3
125949: PPUSH
125950: CALL_OW 298
125954: PUSH
125955: LD_INT 6
125957: LESS
125958: IFFALSE 126057
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
125960: LD_EXP 210
125964: PUSH
125965: LD_VAR 0 6
125969: ARRAY
125970: PUSH
125971: LD_VAR 0 5
125975: ARRAY
125976: PUSH
125977: LD_INT 1
125979: ARRAY
125980: PPUSH
125981: LD_EXP 210
125985: PUSH
125986: LD_VAR 0 6
125990: ARRAY
125991: PUSH
125992: LD_VAR 0 5
125996: ARRAY
125997: PUSH
125998: LD_INT 2
126000: ARRAY
126001: PPUSH
126002: LD_VAR 0 1
126006: PPUSH
126007: CALL_OW 255
126011: PPUSH
126012: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
126016: LD_ADDR_EXP 210
126020: PUSH
126021: LD_EXP 210
126025: PPUSH
126026: LD_VAR 0 6
126030: PPUSH
126031: LD_EXP 210
126035: PUSH
126036: LD_VAR 0 6
126040: ARRAY
126041: PPUSH
126042: LD_VAR 0 5
126046: PPUSH
126047: CALL_OW 3
126051: PPUSH
126052: CALL_OW 1
126056: ST_TO_ADDR
// end ; end ;
126057: GO 125895
126059: POP
126060: POP
// end ;
126061: LD_VAR 0 4
126065: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
126066: LD_INT 0
126068: PPUSH
126069: PPUSH
126070: PPUSH
126071: PPUSH
126072: PPUSH
126073: PPUSH
126074: PPUSH
126075: PPUSH
126076: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
126077: LD_VAR 0 1
126081: PPUSH
126082: CALL_OW 264
126086: PUSH
126087: LD_INT 81
126089: EQUAL
126090: NOT
126091: PUSH
126092: LD_VAR 0 1
126096: PUSH
126097: LD_EXP 209
126101: IN
126102: NOT
126103: OR
126104: IFFALSE 126108
// exit ;
126106: GO 126430
// index := GetElementIndex ( minersList , unit ) ;
126108: LD_ADDR_VAR 0 6
126112: PUSH
126113: LD_EXP 209
126117: PPUSH
126118: LD_VAR 0 1
126122: PPUSH
126123: CALL 70654 0 2
126127: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
126128: LD_ADDR_VAR 0 8
126132: PUSH
126133: LD_EXP 211
126137: PUSH
126138: LD_EXP 210
126142: PUSH
126143: LD_VAR 0 6
126147: ARRAY
126148: MINUS
126149: ST_TO_ADDR
// if not minesFreeAmount then
126150: LD_VAR 0 8
126154: NOT
126155: IFFALSE 126159
// exit ;
126157: GO 126430
// tmp := [ ] ;
126159: LD_ADDR_VAR 0 7
126163: PUSH
126164: EMPTY
126165: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
126166: LD_ADDR_VAR 0 5
126170: PUSH
126171: DOUBLE
126172: LD_INT 1
126174: DEC
126175: ST_TO_ADDR
126176: LD_VAR 0 8
126180: PUSH
126181: FOR_TO
126182: IFFALSE 126377
// begin _d := rand ( 0 , 5 ) ;
126184: LD_ADDR_VAR 0 11
126188: PUSH
126189: LD_INT 0
126191: PPUSH
126192: LD_INT 5
126194: PPUSH
126195: CALL_OW 12
126199: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
126200: LD_ADDR_VAR 0 12
126204: PUSH
126205: LD_INT 2
126207: PPUSH
126208: LD_INT 6
126210: PPUSH
126211: CALL_OW 12
126215: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
126216: LD_ADDR_VAR 0 9
126220: PUSH
126221: LD_VAR 0 2
126225: PPUSH
126226: LD_VAR 0 11
126230: PPUSH
126231: LD_VAR 0 12
126235: PPUSH
126236: CALL_OW 272
126240: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
126241: LD_ADDR_VAR 0 10
126245: PUSH
126246: LD_VAR 0 3
126250: PPUSH
126251: LD_VAR 0 11
126255: PPUSH
126256: LD_VAR 0 12
126260: PPUSH
126261: CALL_OW 273
126265: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
126266: LD_VAR 0 9
126270: PPUSH
126271: LD_VAR 0 10
126275: PPUSH
126276: CALL_OW 488
126280: PUSH
126281: LD_VAR 0 9
126285: PUSH
126286: LD_VAR 0 10
126290: PUSH
126291: EMPTY
126292: LIST
126293: LIST
126294: PUSH
126295: LD_VAR 0 7
126299: IN
126300: NOT
126301: AND
126302: PUSH
126303: LD_VAR 0 9
126307: PPUSH
126308: LD_VAR 0 10
126312: PPUSH
126313: CALL_OW 458
126317: NOT
126318: AND
126319: IFFALSE 126361
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
126321: LD_ADDR_VAR 0 7
126325: PUSH
126326: LD_VAR 0 7
126330: PPUSH
126331: LD_VAR 0 7
126335: PUSH
126336: LD_INT 1
126338: PLUS
126339: PPUSH
126340: LD_VAR 0 9
126344: PUSH
126345: LD_VAR 0 10
126349: PUSH
126350: EMPTY
126351: LIST
126352: LIST
126353: PPUSH
126354: CALL_OW 1
126358: ST_TO_ADDR
126359: GO 126375
// i := i - 1 ;
126361: LD_ADDR_VAR 0 5
126365: PUSH
126366: LD_VAR 0 5
126370: PUSH
126371: LD_INT 1
126373: MINUS
126374: ST_TO_ADDR
// end ;
126375: GO 126181
126377: POP
126378: POP
// for i in tmp do
126379: LD_ADDR_VAR 0 5
126383: PUSH
126384: LD_VAR 0 7
126388: PUSH
126389: FOR_IN
126390: IFFALSE 126428
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
126392: LD_VAR 0 1
126396: PPUSH
126397: LD_VAR 0 5
126401: PUSH
126402: LD_INT 1
126404: ARRAY
126405: PPUSH
126406: LD_VAR 0 5
126410: PUSH
126411: LD_INT 2
126413: ARRAY
126414: PPUSH
126415: CALL 125374 0 3
126419: NOT
126420: IFFALSE 126426
// exit ;
126422: POP
126423: POP
126424: GO 126430
126426: GO 126389
126428: POP
126429: POP
// end ;
126430: LD_VAR 0 4
126434: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
126435: LD_INT 0
126437: PPUSH
126438: PPUSH
126439: PPUSH
126440: PPUSH
126441: PPUSH
126442: PPUSH
126443: PPUSH
// if not GetClass ( unit ) = class_sniper then
126444: LD_VAR 0 1
126448: PPUSH
126449: CALL_OW 257
126453: PUSH
126454: LD_INT 5
126456: EQUAL
126457: NOT
126458: IFFALSE 126462
// exit ;
126460: GO 126850
// dist := 8 ;
126462: LD_ADDR_VAR 0 5
126466: PUSH
126467: LD_INT 8
126469: ST_TO_ADDR
// viewRange := 12 ;
126470: LD_ADDR_VAR 0 7
126474: PUSH
126475: LD_INT 12
126477: ST_TO_ADDR
// side := GetSide ( unit ) ;
126478: LD_ADDR_VAR 0 6
126482: PUSH
126483: LD_VAR 0 1
126487: PPUSH
126488: CALL_OW 255
126492: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
126493: LD_INT 61
126495: PPUSH
126496: LD_VAR 0 6
126500: PPUSH
126501: CALL_OW 321
126505: PUSH
126506: LD_INT 2
126508: EQUAL
126509: IFFALSE 126519
// viewRange := 16 ;
126511: LD_ADDR_VAR 0 7
126515: PUSH
126516: LD_INT 16
126518: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
126519: LD_VAR 0 1
126523: PPUSH
126524: LD_VAR 0 2
126528: PPUSH
126529: LD_VAR 0 3
126533: PPUSH
126534: CALL_OW 297
126538: PUSH
126539: LD_VAR 0 5
126543: GREATER
126544: IFFALSE 126623
// begin ComMoveXY ( unit , x , y ) ;
126546: LD_VAR 0 1
126550: PPUSH
126551: LD_VAR 0 2
126555: PPUSH
126556: LD_VAR 0 3
126560: PPUSH
126561: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
126565: LD_INT 35
126567: PPUSH
126568: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
126572: LD_VAR 0 1
126576: PPUSH
126577: LD_VAR 0 2
126581: PPUSH
126582: LD_VAR 0 3
126586: PPUSH
126587: CALL 101917 0 3
126591: NOT
126592: IFFALSE 126596
// exit ;
126594: GO 126850
// until GetDistUnitXY ( unit , x , y ) < dist ;
126596: LD_VAR 0 1
126600: PPUSH
126601: LD_VAR 0 2
126605: PPUSH
126606: LD_VAR 0 3
126610: PPUSH
126611: CALL_OW 297
126615: PUSH
126616: LD_VAR 0 5
126620: LESS
126621: IFFALSE 126565
// end ; ComTurnXY ( unit , x , y ) ;
126623: LD_VAR 0 1
126627: PPUSH
126628: LD_VAR 0 2
126632: PPUSH
126633: LD_VAR 0 3
126637: PPUSH
126638: CALL_OW 118
// wait ( 5 ) ;
126642: LD_INT 5
126644: PPUSH
126645: CALL_OW 67
// _d := GetDir ( unit ) ;
126649: LD_ADDR_VAR 0 10
126653: PUSH
126654: LD_VAR 0 1
126658: PPUSH
126659: CALL_OW 254
126663: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
126664: LD_ADDR_VAR 0 8
126668: PUSH
126669: LD_VAR 0 1
126673: PPUSH
126674: CALL_OW 250
126678: PPUSH
126679: LD_VAR 0 10
126683: PPUSH
126684: LD_VAR 0 5
126688: PPUSH
126689: CALL_OW 272
126693: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
126694: LD_ADDR_VAR 0 9
126698: PUSH
126699: LD_VAR 0 1
126703: PPUSH
126704: CALL_OW 251
126708: PPUSH
126709: LD_VAR 0 10
126713: PPUSH
126714: LD_VAR 0 5
126718: PPUSH
126719: CALL_OW 273
126723: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
126724: LD_VAR 0 8
126728: PPUSH
126729: LD_VAR 0 9
126733: PPUSH
126734: CALL_OW 488
126738: NOT
126739: IFFALSE 126743
// exit ;
126741: GO 126850
// ComAnimCustom ( unit , 1 ) ;
126743: LD_VAR 0 1
126747: PPUSH
126748: LD_INT 1
126750: PPUSH
126751: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
126755: LD_VAR 0 8
126759: PPUSH
126760: LD_VAR 0 9
126764: PPUSH
126765: LD_VAR 0 6
126769: PPUSH
126770: LD_VAR 0 7
126774: PPUSH
126775: CALL_OW 330
// repeat wait ( 1 ) ;
126779: LD_INT 1
126781: PPUSH
126782: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
126786: LD_VAR 0 1
126790: PPUSH
126791: CALL_OW 316
126795: PUSH
126796: LD_VAR 0 1
126800: PPUSH
126801: CALL_OW 314
126805: OR
126806: PUSH
126807: LD_VAR 0 1
126811: PPUSH
126812: CALL_OW 302
126816: NOT
126817: OR
126818: PUSH
126819: LD_VAR 0 1
126823: PPUSH
126824: CALL_OW 301
126828: OR
126829: IFFALSE 126779
// RemoveSeeing ( _x , _y , side ) ;
126831: LD_VAR 0 8
126835: PPUSH
126836: LD_VAR 0 9
126840: PPUSH
126841: LD_VAR 0 6
126845: PPUSH
126846: CALL_OW 331
// end ; end_of_file
126850: LD_VAR 0 4
126854: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
126855: LD_INT 0
126857: PPUSH
126858: PPUSH
126859: PPUSH
126860: PPUSH
126861: PPUSH
126862: PPUSH
126863: PPUSH
126864: PPUSH
126865: PPUSH
126866: PPUSH
126867: PPUSH
126868: PPUSH
126869: PPUSH
126870: PPUSH
126871: PPUSH
126872: PPUSH
126873: PPUSH
126874: PPUSH
126875: PPUSH
126876: PPUSH
126877: PPUSH
126878: PPUSH
126879: PPUSH
126880: PPUSH
126881: PPUSH
126882: PPUSH
126883: PPUSH
126884: PPUSH
126885: PPUSH
126886: PPUSH
126887: PPUSH
126888: PPUSH
126889: PPUSH
126890: PPUSH
// if not list then
126891: LD_VAR 0 1
126895: NOT
126896: IFFALSE 126900
// exit ;
126898: GO 131559
// base := list [ 1 ] ;
126900: LD_ADDR_VAR 0 3
126904: PUSH
126905: LD_VAR 0 1
126909: PUSH
126910: LD_INT 1
126912: ARRAY
126913: ST_TO_ADDR
// group := list [ 2 ] ;
126914: LD_ADDR_VAR 0 4
126918: PUSH
126919: LD_VAR 0 1
126923: PUSH
126924: LD_INT 2
126926: ARRAY
126927: ST_TO_ADDR
// path := list [ 3 ] ;
126928: LD_ADDR_VAR 0 5
126932: PUSH
126933: LD_VAR 0 1
126937: PUSH
126938: LD_INT 3
126940: ARRAY
126941: ST_TO_ADDR
// flags := list [ 4 ] ;
126942: LD_ADDR_VAR 0 6
126946: PUSH
126947: LD_VAR 0 1
126951: PUSH
126952: LD_INT 4
126954: ARRAY
126955: ST_TO_ADDR
// mined := [ ] ;
126956: LD_ADDR_VAR 0 27
126960: PUSH
126961: EMPTY
126962: ST_TO_ADDR
// bombed := [ ] ;
126963: LD_ADDR_VAR 0 28
126967: PUSH
126968: EMPTY
126969: ST_TO_ADDR
// healers := [ ] ;
126970: LD_ADDR_VAR 0 31
126974: PUSH
126975: EMPTY
126976: ST_TO_ADDR
// to_heal := [ ] ;
126977: LD_ADDR_VAR 0 30
126981: PUSH
126982: EMPTY
126983: ST_TO_ADDR
// repairs := [ ] ;
126984: LD_ADDR_VAR 0 33
126988: PUSH
126989: EMPTY
126990: ST_TO_ADDR
// to_repair := [ ] ;
126991: LD_ADDR_VAR 0 32
126995: PUSH
126996: EMPTY
126997: ST_TO_ADDR
// if not group or not path then
126998: LD_VAR 0 4
127002: NOT
127003: PUSH
127004: LD_VAR 0 5
127008: NOT
127009: OR
127010: IFFALSE 127014
// exit ;
127012: GO 131559
// side := GetSide ( group [ 1 ] ) ;
127014: LD_ADDR_VAR 0 35
127018: PUSH
127019: LD_VAR 0 4
127023: PUSH
127024: LD_INT 1
127026: ARRAY
127027: PPUSH
127028: CALL_OW 255
127032: ST_TO_ADDR
// if flags then
127033: LD_VAR 0 6
127037: IFFALSE 127181
// begin f_ignore_area := flags [ 1 ] ;
127039: LD_ADDR_VAR 0 17
127043: PUSH
127044: LD_VAR 0 6
127048: PUSH
127049: LD_INT 1
127051: ARRAY
127052: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
127053: LD_ADDR_VAR 0 18
127057: PUSH
127058: LD_VAR 0 6
127062: PUSH
127063: LD_INT 2
127065: ARRAY
127066: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
127067: LD_ADDR_VAR 0 19
127071: PUSH
127072: LD_VAR 0 6
127076: PUSH
127077: LD_INT 3
127079: ARRAY
127080: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
127081: LD_ADDR_VAR 0 20
127085: PUSH
127086: LD_VAR 0 6
127090: PUSH
127091: LD_INT 4
127093: ARRAY
127094: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
127095: LD_ADDR_VAR 0 21
127099: PUSH
127100: LD_VAR 0 6
127104: PUSH
127105: LD_INT 5
127107: ARRAY
127108: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
127109: LD_ADDR_VAR 0 22
127113: PUSH
127114: LD_VAR 0 6
127118: PUSH
127119: LD_INT 6
127121: ARRAY
127122: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
127123: LD_ADDR_VAR 0 23
127127: PUSH
127128: LD_VAR 0 6
127132: PUSH
127133: LD_INT 7
127135: ARRAY
127136: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
127137: LD_ADDR_VAR 0 24
127141: PUSH
127142: LD_VAR 0 6
127146: PUSH
127147: LD_INT 8
127149: ARRAY
127150: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
127151: LD_ADDR_VAR 0 25
127155: PUSH
127156: LD_VAR 0 6
127160: PUSH
127161: LD_INT 9
127163: ARRAY
127164: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
127165: LD_ADDR_VAR 0 26
127169: PUSH
127170: LD_VAR 0 6
127174: PUSH
127175: LD_INT 10
127177: ARRAY
127178: ST_TO_ADDR
// end else
127179: GO 127261
// begin f_ignore_area := false ;
127181: LD_ADDR_VAR 0 17
127185: PUSH
127186: LD_INT 0
127188: ST_TO_ADDR
// f_capture := false ;
127189: LD_ADDR_VAR 0 18
127193: PUSH
127194: LD_INT 0
127196: ST_TO_ADDR
// f_ignore_civ := false ;
127197: LD_ADDR_VAR 0 19
127201: PUSH
127202: LD_INT 0
127204: ST_TO_ADDR
// f_murder := false ;
127205: LD_ADDR_VAR 0 20
127209: PUSH
127210: LD_INT 0
127212: ST_TO_ADDR
// f_mines := false ;
127213: LD_ADDR_VAR 0 21
127217: PUSH
127218: LD_INT 0
127220: ST_TO_ADDR
// f_repair := false ;
127221: LD_ADDR_VAR 0 22
127225: PUSH
127226: LD_INT 0
127228: ST_TO_ADDR
// f_heal := false ;
127229: LD_ADDR_VAR 0 23
127233: PUSH
127234: LD_INT 0
127236: ST_TO_ADDR
// f_spacetime := false ;
127237: LD_ADDR_VAR 0 24
127241: PUSH
127242: LD_INT 0
127244: ST_TO_ADDR
// f_attack_depot := false ;
127245: LD_ADDR_VAR 0 25
127249: PUSH
127250: LD_INT 0
127252: ST_TO_ADDR
// f_crawl := false ;
127253: LD_ADDR_VAR 0 26
127257: PUSH
127258: LD_INT 0
127260: ST_TO_ADDR
// end ; if f_heal then
127261: LD_VAR 0 23
127265: IFFALSE 127292
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
127267: LD_ADDR_VAR 0 31
127271: PUSH
127272: LD_VAR 0 4
127276: PPUSH
127277: LD_INT 25
127279: PUSH
127280: LD_INT 4
127282: PUSH
127283: EMPTY
127284: LIST
127285: LIST
127286: PPUSH
127287: CALL_OW 72
127291: ST_TO_ADDR
// if f_repair then
127292: LD_VAR 0 22
127296: IFFALSE 127323
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
127298: LD_ADDR_VAR 0 33
127302: PUSH
127303: LD_VAR 0 4
127307: PPUSH
127308: LD_INT 25
127310: PUSH
127311: LD_INT 3
127313: PUSH
127314: EMPTY
127315: LIST
127316: LIST
127317: PPUSH
127318: CALL_OW 72
127322: ST_TO_ADDR
// units_path := [ ] ;
127323: LD_ADDR_VAR 0 16
127327: PUSH
127328: EMPTY
127329: ST_TO_ADDR
// for i = 1 to group do
127330: LD_ADDR_VAR 0 7
127334: PUSH
127335: DOUBLE
127336: LD_INT 1
127338: DEC
127339: ST_TO_ADDR
127340: LD_VAR 0 4
127344: PUSH
127345: FOR_TO
127346: IFFALSE 127375
// units_path := Replace ( units_path , i , path ) ;
127348: LD_ADDR_VAR 0 16
127352: PUSH
127353: LD_VAR 0 16
127357: PPUSH
127358: LD_VAR 0 7
127362: PPUSH
127363: LD_VAR 0 5
127367: PPUSH
127368: CALL_OW 1
127372: ST_TO_ADDR
127373: GO 127345
127375: POP
127376: POP
// repeat for i = group downto 1 do
127377: LD_ADDR_VAR 0 7
127381: PUSH
127382: DOUBLE
127383: LD_VAR 0 4
127387: INC
127388: ST_TO_ADDR
127389: LD_INT 1
127391: PUSH
127392: FOR_DOWNTO
127393: IFFALSE 131515
// begin wait ( 5 ) ;
127395: LD_INT 5
127397: PPUSH
127398: CALL_OW 67
// tmp := [ ] ;
127402: LD_ADDR_VAR 0 14
127406: PUSH
127407: EMPTY
127408: ST_TO_ADDR
// attacking := false ;
127409: LD_ADDR_VAR 0 29
127413: PUSH
127414: LD_INT 0
127416: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
127417: LD_VAR 0 4
127421: PUSH
127422: LD_VAR 0 7
127426: ARRAY
127427: PPUSH
127428: CALL_OW 301
127432: PUSH
127433: LD_VAR 0 4
127437: PUSH
127438: LD_VAR 0 7
127442: ARRAY
127443: NOT
127444: OR
127445: IFFALSE 127554
// begin if GetType ( group [ i ] ) = unit_human then
127447: LD_VAR 0 4
127451: PUSH
127452: LD_VAR 0 7
127456: ARRAY
127457: PPUSH
127458: CALL_OW 247
127462: PUSH
127463: LD_INT 1
127465: EQUAL
127466: IFFALSE 127512
// begin to_heal := to_heal diff group [ i ] ;
127468: LD_ADDR_VAR 0 30
127472: PUSH
127473: LD_VAR 0 30
127477: PUSH
127478: LD_VAR 0 4
127482: PUSH
127483: LD_VAR 0 7
127487: ARRAY
127488: DIFF
127489: ST_TO_ADDR
// healers := healers diff group [ i ] ;
127490: LD_ADDR_VAR 0 31
127494: PUSH
127495: LD_VAR 0 31
127499: PUSH
127500: LD_VAR 0 4
127504: PUSH
127505: LD_VAR 0 7
127509: ARRAY
127510: DIFF
127511: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
127512: LD_ADDR_VAR 0 4
127516: PUSH
127517: LD_VAR 0 4
127521: PPUSH
127522: LD_VAR 0 7
127526: PPUSH
127527: CALL_OW 3
127531: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
127532: LD_ADDR_VAR 0 16
127536: PUSH
127537: LD_VAR 0 16
127541: PPUSH
127542: LD_VAR 0 7
127546: PPUSH
127547: CALL_OW 3
127551: ST_TO_ADDR
// continue ;
127552: GO 127392
// end ; if f_repair then
127554: LD_VAR 0 22
127558: IFFALSE 128047
// begin if GetType ( group [ i ] ) = unit_vehicle then
127560: LD_VAR 0 4
127564: PUSH
127565: LD_VAR 0 7
127569: ARRAY
127570: PPUSH
127571: CALL_OW 247
127575: PUSH
127576: LD_INT 2
127578: EQUAL
127579: IFFALSE 127769
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
127581: LD_VAR 0 4
127585: PUSH
127586: LD_VAR 0 7
127590: ARRAY
127591: PPUSH
127592: CALL_OW 256
127596: PUSH
127597: LD_INT 700
127599: LESS
127600: PUSH
127601: LD_VAR 0 4
127605: PUSH
127606: LD_VAR 0 7
127610: ARRAY
127611: PUSH
127612: LD_VAR 0 32
127616: IN
127617: NOT
127618: AND
127619: IFFALSE 127643
// to_repair := to_repair union group [ i ] ;
127621: LD_ADDR_VAR 0 32
127625: PUSH
127626: LD_VAR 0 32
127630: PUSH
127631: LD_VAR 0 4
127635: PUSH
127636: LD_VAR 0 7
127640: ARRAY
127641: UNION
127642: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
127643: LD_VAR 0 4
127647: PUSH
127648: LD_VAR 0 7
127652: ARRAY
127653: PPUSH
127654: CALL_OW 256
127658: PUSH
127659: LD_INT 1000
127661: EQUAL
127662: PUSH
127663: LD_VAR 0 4
127667: PUSH
127668: LD_VAR 0 7
127672: ARRAY
127673: PUSH
127674: LD_VAR 0 32
127678: IN
127679: AND
127680: IFFALSE 127704
// to_repair := to_repair diff group [ i ] ;
127682: LD_ADDR_VAR 0 32
127686: PUSH
127687: LD_VAR 0 32
127691: PUSH
127692: LD_VAR 0 4
127696: PUSH
127697: LD_VAR 0 7
127701: ARRAY
127702: DIFF
127703: ST_TO_ADDR
// if group [ i ] in to_repair then
127704: LD_VAR 0 4
127708: PUSH
127709: LD_VAR 0 7
127713: ARRAY
127714: PUSH
127715: LD_VAR 0 32
127719: IN
127720: IFFALSE 127767
// begin if not IsInArea ( group [ i ] , f_repair ) then
127722: LD_VAR 0 4
127726: PUSH
127727: LD_VAR 0 7
127731: ARRAY
127732: PPUSH
127733: LD_VAR 0 22
127737: PPUSH
127738: CALL_OW 308
127742: NOT
127743: IFFALSE 127765
// ComMoveToArea ( group [ i ] , f_repair ) ;
127745: LD_VAR 0 4
127749: PUSH
127750: LD_VAR 0 7
127754: ARRAY
127755: PPUSH
127756: LD_VAR 0 22
127760: PPUSH
127761: CALL_OW 113
// continue ;
127765: GO 127392
// end ; end else
127767: GO 128047
// if group [ i ] in repairs then
127769: LD_VAR 0 4
127773: PUSH
127774: LD_VAR 0 7
127778: ARRAY
127779: PUSH
127780: LD_VAR 0 33
127784: IN
127785: IFFALSE 128047
// begin if IsInUnit ( group [ i ] ) then
127787: LD_VAR 0 4
127791: PUSH
127792: LD_VAR 0 7
127796: ARRAY
127797: PPUSH
127798: CALL_OW 310
127802: IFFALSE 127870
// begin z := IsInUnit ( group [ i ] ) ;
127804: LD_ADDR_VAR 0 13
127808: PUSH
127809: LD_VAR 0 4
127813: PUSH
127814: LD_VAR 0 7
127818: ARRAY
127819: PPUSH
127820: CALL_OW 310
127824: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
127825: LD_VAR 0 13
127829: PUSH
127830: LD_VAR 0 32
127834: IN
127835: PUSH
127836: LD_VAR 0 13
127840: PPUSH
127841: LD_VAR 0 22
127845: PPUSH
127846: CALL_OW 308
127850: AND
127851: IFFALSE 127868
// ComExitVehicle ( group [ i ] ) ;
127853: LD_VAR 0 4
127857: PUSH
127858: LD_VAR 0 7
127862: ARRAY
127863: PPUSH
127864: CALL_OW 121
// end else
127868: GO 128047
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
127870: LD_ADDR_VAR 0 13
127874: PUSH
127875: LD_VAR 0 4
127879: PPUSH
127880: LD_INT 95
127882: PUSH
127883: LD_VAR 0 22
127887: PUSH
127888: EMPTY
127889: LIST
127890: LIST
127891: PUSH
127892: LD_INT 58
127894: PUSH
127895: EMPTY
127896: LIST
127897: PUSH
127898: EMPTY
127899: LIST
127900: LIST
127901: PPUSH
127902: CALL_OW 72
127906: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
127907: LD_VAR 0 4
127911: PUSH
127912: LD_VAR 0 7
127916: ARRAY
127917: PPUSH
127918: CALL_OW 314
127922: NOT
127923: IFFALSE 128045
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
127925: LD_ADDR_VAR 0 10
127929: PUSH
127930: LD_VAR 0 13
127934: PPUSH
127935: LD_VAR 0 4
127939: PUSH
127940: LD_VAR 0 7
127944: ARRAY
127945: PPUSH
127946: CALL_OW 74
127950: ST_TO_ADDR
// if not x then
127951: LD_VAR 0 10
127955: NOT
127956: IFFALSE 127960
// continue ;
127958: GO 127392
// if GetLives ( x ) < 1000 then
127960: LD_VAR 0 10
127964: PPUSH
127965: CALL_OW 256
127969: PUSH
127970: LD_INT 1000
127972: LESS
127973: IFFALSE 127997
// ComRepairVehicle ( group [ i ] , x ) else
127975: LD_VAR 0 4
127979: PUSH
127980: LD_VAR 0 7
127984: ARRAY
127985: PPUSH
127986: LD_VAR 0 10
127990: PPUSH
127991: CALL_OW 129
127995: GO 128045
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
127997: LD_VAR 0 23
128001: PUSH
128002: LD_VAR 0 4
128006: PUSH
128007: LD_VAR 0 7
128011: ARRAY
128012: PPUSH
128013: CALL_OW 256
128017: PUSH
128018: LD_INT 1000
128020: LESS
128021: AND
128022: NOT
128023: IFFALSE 128045
// ComEnterUnit ( group [ i ] , x ) ;
128025: LD_VAR 0 4
128029: PUSH
128030: LD_VAR 0 7
128034: ARRAY
128035: PPUSH
128036: LD_VAR 0 10
128040: PPUSH
128041: CALL_OW 120
// end ; continue ;
128045: GO 127392
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
128047: LD_VAR 0 23
128051: PUSH
128052: LD_VAR 0 4
128056: PUSH
128057: LD_VAR 0 7
128061: ARRAY
128062: PPUSH
128063: CALL_OW 247
128067: PUSH
128068: LD_INT 1
128070: EQUAL
128071: AND
128072: IFFALSE 128550
// begin if group [ i ] in healers then
128074: LD_VAR 0 4
128078: PUSH
128079: LD_VAR 0 7
128083: ARRAY
128084: PUSH
128085: LD_VAR 0 31
128089: IN
128090: IFFALSE 128363
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
128092: LD_VAR 0 4
128096: PUSH
128097: LD_VAR 0 7
128101: ARRAY
128102: PPUSH
128103: LD_VAR 0 23
128107: PPUSH
128108: CALL_OW 308
128112: NOT
128113: PUSH
128114: LD_VAR 0 4
128118: PUSH
128119: LD_VAR 0 7
128123: ARRAY
128124: PPUSH
128125: CALL_OW 314
128129: NOT
128130: AND
128131: IFFALSE 128155
// ComMoveToArea ( group [ i ] , f_heal ) else
128133: LD_VAR 0 4
128137: PUSH
128138: LD_VAR 0 7
128142: ARRAY
128143: PPUSH
128144: LD_VAR 0 23
128148: PPUSH
128149: CALL_OW 113
128153: GO 128361
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
128155: LD_VAR 0 4
128159: PUSH
128160: LD_VAR 0 7
128164: ARRAY
128165: PPUSH
128166: CALL 100493 0 1
128170: PPUSH
128171: CALL_OW 256
128175: PUSH
128176: LD_INT 1000
128178: EQUAL
128179: IFFALSE 128198
// ComStop ( group [ i ] ) else
128181: LD_VAR 0 4
128185: PUSH
128186: LD_VAR 0 7
128190: ARRAY
128191: PPUSH
128192: CALL_OW 141
128196: GO 128361
// if not HasTask ( group [ i ] ) and to_heal then
128198: LD_VAR 0 4
128202: PUSH
128203: LD_VAR 0 7
128207: ARRAY
128208: PPUSH
128209: CALL_OW 314
128213: NOT
128214: PUSH
128215: LD_VAR 0 30
128219: AND
128220: IFFALSE 128361
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
128222: LD_ADDR_VAR 0 13
128226: PUSH
128227: LD_VAR 0 30
128231: PPUSH
128232: LD_INT 3
128234: PUSH
128235: LD_INT 54
128237: PUSH
128238: EMPTY
128239: LIST
128240: PUSH
128241: EMPTY
128242: LIST
128243: LIST
128244: PPUSH
128245: CALL_OW 72
128249: PPUSH
128250: LD_VAR 0 4
128254: PUSH
128255: LD_VAR 0 7
128259: ARRAY
128260: PPUSH
128261: CALL_OW 74
128265: ST_TO_ADDR
// if z then
128266: LD_VAR 0 13
128270: IFFALSE 128361
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
128272: LD_INT 91
128274: PUSH
128275: LD_VAR 0 13
128279: PUSH
128280: LD_INT 10
128282: PUSH
128283: EMPTY
128284: LIST
128285: LIST
128286: LIST
128287: PUSH
128288: LD_INT 81
128290: PUSH
128291: LD_VAR 0 13
128295: PPUSH
128296: CALL_OW 255
128300: PUSH
128301: EMPTY
128302: LIST
128303: LIST
128304: PUSH
128305: EMPTY
128306: LIST
128307: LIST
128308: PPUSH
128309: CALL_OW 69
128313: PUSH
128314: LD_INT 0
128316: EQUAL
128317: IFFALSE 128341
// ComHeal ( group [ i ] , z ) else
128319: LD_VAR 0 4
128323: PUSH
128324: LD_VAR 0 7
128328: ARRAY
128329: PPUSH
128330: LD_VAR 0 13
128334: PPUSH
128335: CALL_OW 128
128339: GO 128361
// ComMoveToArea ( group [ i ] , f_heal ) ;
128341: LD_VAR 0 4
128345: PUSH
128346: LD_VAR 0 7
128350: ARRAY
128351: PPUSH
128352: LD_VAR 0 23
128356: PPUSH
128357: CALL_OW 113
// end ; continue ;
128361: GO 127392
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
128363: LD_VAR 0 4
128367: PUSH
128368: LD_VAR 0 7
128372: ARRAY
128373: PPUSH
128374: CALL_OW 256
128378: PUSH
128379: LD_INT 700
128381: LESS
128382: PUSH
128383: LD_VAR 0 4
128387: PUSH
128388: LD_VAR 0 7
128392: ARRAY
128393: PUSH
128394: LD_VAR 0 30
128398: IN
128399: NOT
128400: AND
128401: IFFALSE 128425
// to_heal := to_heal union group [ i ] ;
128403: LD_ADDR_VAR 0 30
128407: PUSH
128408: LD_VAR 0 30
128412: PUSH
128413: LD_VAR 0 4
128417: PUSH
128418: LD_VAR 0 7
128422: ARRAY
128423: UNION
128424: ST_TO_ADDR
// if group [ i ] in to_heal then
128425: LD_VAR 0 4
128429: PUSH
128430: LD_VAR 0 7
128434: ARRAY
128435: PUSH
128436: LD_VAR 0 30
128440: IN
128441: IFFALSE 128550
// begin if GetLives ( group [ i ] ) = 1000 then
128443: LD_VAR 0 4
128447: PUSH
128448: LD_VAR 0 7
128452: ARRAY
128453: PPUSH
128454: CALL_OW 256
128458: PUSH
128459: LD_INT 1000
128461: EQUAL
128462: IFFALSE 128488
// to_heal := to_heal diff group [ i ] else
128464: LD_ADDR_VAR 0 30
128468: PUSH
128469: LD_VAR 0 30
128473: PUSH
128474: LD_VAR 0 4
128478: PUSH
128479: LD_VAR 0 7
128483: ARRAY
128484: DIFF
128485: ST_TO_ADDR
128486: GO 128550
// begin if not IsInArea ( group [ i ] , to_heal ) then
128488: LD_VAR 0 4
128492: PUSH
128493: LD_VAR 0 7
128497: ARRAY
128498: PPUSH
128499: LD_VAR 0 30
128503: PPUSH
128504: CALL_OW 308
128508: NOT
128509: IFFALSE 128533
// ComMoveToArea ( group [ i ] , f_heal ) else
128511: LD_VAR 0 4
128515: PUSH
128516: LD_VAR 0 7
128520: ARRAY
128521: PPUSH
128522: LD_VAR 0 23
128526: PPUSH
128527: CALL_OW 113
128531: GO 128548
// ComHold ( group [ i ] ) ;
128533: LD_VAR 0 4
128537: PUSH
128538: LD_VAR 0 7
128542: ARRAY
128543: PPUSH
128544: CALL_OW 140
// continue ;
128548: GO 127392
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
128550: LD_VAR 0 4
128554: PUSH
128555: LD_VAR 0 7
128559: ARRAY
128560: PPUSH
128561: LD_INT 10
128563: PPUSH
128564: CALL 98363 0 2
128568: NOT
128569: PUSH
128570: LD_VAR 0 16
128574: PUSH
128575: LD_VAR 0 7
128579: ARRAY
128580: PUSH
128581: EMPTY
128582: EQUAL
128583: NOT
128584: AND
128585: IFFALSE 128851
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
128587: LD_VAR 0 4
128591: PUSH
128592: LD_VAR 0 7
128596: ARRAY
128597: PPUSH
128598: CALL_OW 262
128602: PUSH
128603: LD_INT 1
128605: PUSH
128606: LD_INT 2
128608: PUSH
128609: EMPTY
128610: LIST
128611: LIST
128612: IN
128613: IFFALSE 128654
// if GetFuel ( group [ i ] ) < 10 then
128615: LD_VAR 0 4
128619: PUSH
128620: LD_VAR 0 7
128624: ARRAY
128625: PPUSH
128626: CALL_OW 261
128630: PUSH
128631: LD_INT 10
128633: LESS
128634: IFFALSE 128654
// SetFuel ( group [ i ] , 12 ) ;
128636: LD_VAR 0 4
128640: PUSH
128641: LD_VAR 0 7
128645: ARRAY
128646: PPUSH
128647: LD_INT 12
128649: PPUSH
128650: CALL_OW 240
// if units_path [ i ] then
128654: LD_VAR 0 16
128658: PUSH
128659: LD_VAR 0 7
128663: ARRAY
128664: IFFALSE 128849
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
128666: LD_VAR 0 4
128670: PUSH
128671: LD_VAR 0 7
128675: ARRAY
128676: PPUSH
128677: LD_VAR 0 16
128681: PUSH
128682: LD_VAR 0 7
128686: ARRAY
128687: PUSH
128688: LD_INT 1
128690: ARRAY
128691: PUSH
128692: LD_INT 1
128694: ARRAY
128695: PPUSH
128696: LD_VAR 0 16
128700: PUSH
128701: LD_VAR 0 7
128705: ARRAY
128706: PUSH
128707: LD_INT 1
128709: ARRAY
128710: PUSH
128711: LD_INT 2
128713: ARRAY
128714: PPUSH
128715: CALL_OW 297
128719: PUSH
128720: LD_INT 6
128722: GREATER
128723: IFFALSE 128798
// begin if not HasTask ( group [ i ] ) then
128725: LD_VAR 0 4
128729: PUSH
128730: LD_VAR 0 7
128734: ARRAY
128735: PPUSH
128736: CALL_OW 314
128740: NOT
128741: IFFALSE 128796
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
128743: LD_VAR 0 4
128747: PUSH
128748: LD_VAR 0 7
128752: ARRAY
128753: PPUSH
128754: LD_VAR 0 16
128758: PUSH
128759: LD_VAR 0 7
128763: ARRAY
128764: PUSH
128765: LD_INT 1
128767: ARRAY
128768: PUSH
128769: LD_INT 1
128771: ARRAY
128772: PPUSH
128773: LD_VAR 0 16
128777: PUSH
128778: LD_VAR 0 7
128782: ARRAY
128783: PUSH
128784: LD_INT 1
128786: ARRAY
128787: PUSH
128788: LD_INT 2
128790: ARRAY
128791: PPUSH
128792: CALL_OW 114
// end else
128796: GO 128849
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
128798: LD_ADDR_VAR 0 15
128802: PUSH
128803: LD_VAR 0 16
128807: PUSH
128808: LD_VAR 0 7
128812: ARRAY
128813: PPUSH
128814: LD_INT 1
128816: PPUSH
128817: CALL_OW 3
128821: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
128822: LD_ADDR_VAR 0 16
128826: PUSH
128827: LD_VAR 0 16
128831: PPUSH
128832: LD_VAR 0 7
128836: PPUSH
128837: LD_VAR 0 15
128841: PPUSH
128842: CALL_OW 1
128846: ST_TO_ADDR
// continue ;
128847: GO 127392
// end ; end ; end else
128849: GO 131513
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
128851: LD_ADDR_VAR 0 14
128855: PUSH
128856: LD_INT 81
128858: PUSH
128859: LD_VAR 0 4
128863: PUSH
128864: LD_VAR 0 7
128868: ARRAY
128869: PPUSH
128870: CALL_OW 255
128874: PUSH
128875: EMPTY
128876: LIST
128877: LIST
128878: PPUSH
128879: CALL_OW 69
128883: ST_TO_ADDR
// if not tmp then
128884: LD_VAR 0 14
128888: NOT
128889: IFFALSE 128893
// continue ;
128891: GO 127392
// if f_ignore_area then
128893: LD_VAR 0 17
128897: IFFALSE 128985
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
128899: LD_ADDR_VAR 0 15
128903: PUSH
128904: LD_VAR 0 14
128908: PPUSH
128909: LD_INT 3
128911: PUSH
128912: LD_INT 92
128914: PUSH
128915: LD_VAR 0 17
128919: PUSH
128920: LD_INT 1
128922: ARRAY
128923: PUSH
128924: LD_VAR 0 17
128928: PUSH
128929: LD_INT 2
128931: ARRAY
128932: PUSH
128933: LD_VAR 0 17
128937: PUSH
128938: LD_INT 3
128940: ARRAY
128941: PUSH
128942: EMPTY
128943: LIST
128944: LIST
128945: LIST
128946: LIST
128947: PUSH
128948: EMPTY
128949: LIST
128950: LIST
128951: PPUSH
128952: CALL_OW 72
128956: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
128957: LD_VAR 0 14
128961: PUSH
128962: LD_VAR 0 15
128966: DIFF
128967: IFFALSE 128985
// tmp := tmp diff tmp2 ;
128969: LD_ADDR_VAR 0 14
128973: PUSH
128974: LD_VAR 0 14
128978: PUSH
128979: LD_VAR 0 15
128983: DIFF
128984: ST_TO_ADDR
// end ; if not f_murder then
128985: LD_VAR 0 20
128989: NOT
128990: IFFALSE 129048
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
128992: LD_ADDR_VAR 0 15
128996: PUSH
128997: LD_VAR 0 14
129001: PPUSH
129002: LD_INT 3
129004: PUSH
129005: LD_INT 50
129007: PUSH
129008: EMPTY
129009: LIST
129010: PUSH
129011: EMPTY
129012: LIST
129013: LIST
129014: PPUSH
129015: CALL_OW 72
129019: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
129020: LD_VAR 0 14
129024: PUSH
129025: LD_VAR 0 15
129029: DIFF
129030: IFFALSE 129048
// tmp := tmp diff tmp2 ;
129032: LD_ADDR_VAR 0 14
129036: PUSH
129037: LD_VAR 0 14
129041: PUSH
129042: LD_VAR 0 15
129046: DIFF
129047: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
129048: LD_ADDR_VAR 0 14
129052: PUSH
129053: LD_VAR 0 4
129057: PUSH
129058: LD_VAR 0 7
129062: ARRAY
129063: PPUSH
129064: LD_VAR 0 14
129068: PPUSH
129069: LD_INT 1
129071: PPUSH
129072: LD_INT 1
129074: PPUSH
129075: CALL 71304 0 4
129079: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
129080: LD_VAR 0 4
129084: PUSH
129085: LD_VAR 0 7
129089: ARRAY
129090: PPUSH
129091: CALL_OW 257
129095: PUSH
129096: LD_INT 1
129098: EQUAL
129099: IFFALSE 129547
// begin if WantPlant ( group [ i ] ) then
129101: LD_VAR 0 4
129105: PUSH
129106: LD_VAR 0 7
129110: ARRAY
129111: PPUSH
129112: CALL 70805 0 1
129116: IFFALSE 129120
// continue ;
129118: GO 127392
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
129120: LD_VAR 0 18
129124: PUSH
129125: LD_VAR 0 4
129129: PUSH
129130: LD_VAR 0 7
129134: ARRAY
129135: PPUSH
129136: CALL_OW 310
129140: NOT
129141: AND
129142: PUSH
129143: LD_VAR 0 14
129147: PUSH
129148: LD_INT 1
129150: ARRAY
129151: PUSH
129152: LD_VAR 0 14
129156: PPUSH
129157: LD_INT 21
129159: PUSH
129160: LD_INT 2
129162: PUSH
129163: EMPTY
129164: LIST
129165: LIST
129166: PUSH
129167: LD_INT 58
129169: PUSH
129170: EMPTY
129171: LIST
129172: PUSH
129173: EMPTY
129174: LIST
129175: LIST
129176: PPUSH
129177: CALL_OW 72
129181: IN
129182: AND
129183: IFFALSE 129219
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
129185: LD_VAR 0 4
129189: PUSH
129190: LD_VAR 0 7
129194: ARRAY
129195: PPUSH
129196: LD_VAR 0 14
129200: PUSH
129201: LD_INT 1
129203: ARRAY
129204: PPUSH
129205: CALL_OW 120
// attacking := true ;
129209: LD_ADDR_VAR 0 29
129213: PUSH
129214: LD_INT 1
129216: ST_TO_ADDR
// continue ;
129217: GO 127392
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
129219: LD_VAR 0 26
129223: PUSH
129224: LD_VAR 0 4
129228: PUSH
129229: LD_VAR 0 7
129233: ARRAY
129234: PPUSH
129235: CALL_OW 257
129239: PUSH
129240: LD_INT 1
129242: EQUAL
129243: AND
129244: PUSH
129245: LD_VAR 0 4
129249: PUSH
129250: LD_VAR 0 7
129254: ARRAY
129255: PPUSH
129256: CALL_OW 256
129260: PUSH
129261: LD_INT 800
129263: LESS
129264: AND
129265: PUSH
129266: LD_VAR 0 4
129270: PUSH
129271: LD_VAR 0 7
129275: ARRAY
129276: PPUSH
129277: CALL_OW 318
129281: NOT
129282: AND
129283: IFFALSE 129300
// ComCrawl ( group [ i ] ) ;
129285: LD_VAR 0 4
129289: PUSH
129290: LD_VAR 0 7
129294: ARRAY
129295: PPUSH
129296: CALL_OW 137
// if f_mines then
129300: LD_VAR 0 21
129304: IFFALSE 129547
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
129306: LD_VAR 0 14
129310: PUSH
129311: LD_INT 1
129313: ARRAY
129314: PPUSH
129315: CALL_OW 247
129319: PUSH
129320: LD_INT 3
129322: EQUAL
129323: PUSH
129324: LD_VAR 0 14
129328: PUSH
129329: LD_INT 1
129331: ARRAY
129332: PUSH
129333: LD_VAR 0 27
129337: IN
129338: NOT
129339: AND
129340: IFFALSE 129547
// begin x := GetX ( tmp [ 1 ] ) ;
129342: LD_ADDR_VAR 0 10
129346: PUSH
129347: LD_VAR 0 14
129351: PUSH
129352: LD_INT 1
129354: ARRAY
129355: PPUSH
129356: CALL_OW 250
129360: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
129361: LD_ADDR_VAR 0 11
129365: PUSH
129366: LD_VAR 0 14
129370: PUSH
129371: LD_INT 1
129373: ARRAY
129374: PPUSH
129375: CALL_OW 251
129379: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
129380: LD_ADDR_VAR 0 12
129384: PUSH
129385: LD_VAR 0 4
129389: PUSH
129390: LD_VAR 0 7
129394: ARRAY
129395: PPUSH
129396: CALL 98448 0 1
129400: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
129401: LD_VAR 0 4
129405: PUSH
129406: LD_VAR 0 7
129410: ARRAY
129411: PPUSH
129412: LD_VAR 0 10
129416: PPUSH
129417: LD_VAR 0 11
129421: PPUSH
129422: LD_VAR 0 14
129426: PUSH
129427: LD_INT 1
129429: ARRAY
129430: PPUSH
129431: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
129435: LD_VAR 0 4
129439: PUSH
129440: LD_VAR 0 7
129444: ARRAY
129445: PPUSH
129446: LD_VAR 0 10
129450: PPUSH
129451: LD_VAR 0 12
129455: PPUSH
129456: LD_INT 7
129458: PPUSH
129459: CALL_OW 272
129463: PPUSH
129464: LD_VAR 0 11
129468: PPUSH
129469: LD_VAR 0 12
129473: PPUSH
129474: LD_INT 7
129476: PPUSH
129477: CALL_OW 273
129481: PPUSH
129482: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
129486: LD_VAR 0 4
129490: PUSH
129491: LD_VAR 0 7
129495: ARRAY
129496: PPUSH
129497: LD_INT 71
129499: PPUSH
129500: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
129504: LD_ADDR_VAR 0 27
129508: PUSH
129509: LD_VAR 0 27
129513: PPUSH
129514: LD_VAR 0 27
129518: PUSH
129519: LD_INT 1
129521: PLUS
129522: PPUSH
129523: LD_VAR 0 14
129527: PUSH
129528: LD_INT 1
129530: ARRAY
129531: PPUSH
129532: CALL_OW 1
129536: ST_TO_ADDR
// attacking := true ;
129537: LD_ADDR_VAR 0 29
129541: PUSH
129542: LD_INT 1
129544: ST_TO_ADDR
// continue ;
129545: GO 127392
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
129547: LD_VAR 0 4
129551: PUSH
129552: LD_VAR 0 7
129556: ARRAY
129557: PPUSH
129558: CALL_OW 257
129562: PUSH
129563: LD_INT 17
129565: EQUAL
129566: PUSH
129567: LD_VAR 0 4
129571: PUSH
129572: LD_VAR 0 7
129576: ARRAY
129577: PPUSH
129578: CALL_OW 110
129582: PUSH
129583: LD_INT 71
129585: EQUAL
129586: NOT
129587: AND
129588: IFFALSE 129734
// begin attacking := false ;
129590: LD_ADDR_VAR 0 29
129594: PUSH
129595: LD_INT 0
129597: ST_TO_ADDR
// k := 5 ;
129598: LD_ADDR_VAR 0 9
129602: PUSH
129603: LD_INT 5
129605: ST_TO_ADDR
// if tmp < k then
129606: LD_VAR 0 14
129610: PUSH
129611: LD_VAR 0 9
129615: LESS
129616: IFFALSE 129628
// k := tmp ;
129618: LD_ADDR_VAR 0 9
129622: PUSH
129623: LD_VAR 0 14
129627: ST_TO_ADDR
// for j = 1 to k do
129628: LD_ADDR_VAR 0 8
129632: PUSH
129633: DOUBLE
129634: LD_INT 1
129636: DEC
129637: ST_TO_ADDR
129638: LD_VAR 0 9
129642: PUSH
129643: FOR_TO
129644: IFFALSE 129732
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
129646: LD_VAR 0 14
129650: PUSH
129651: LD_VAR 0 8
129655: ARRAY
129656: PUSH
129657: LD_VAR 0 14
129661: PPUSH
129662: LD_INT 58
129664: PUSH
129665: EMPTY
129666: LIST
129667: PPUSH
129668: CALL_OW 72
129672: IN
129673: NOT
129674: IFFALSE 129730
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
129676: LD_VAR 0 4
129680: PUSH
129681: LD_VAR 0 7
129685: ARRAY
129686: PPUSH
129687: LD_VAR 0 14
129691: PUSH
129692: LD_VAR 0 8
129696: ARRAY
129697: PPUSH
129698: CALL_OW 115
// attacking := true ;
129702: LD_ADDR_VAR 0 29
129706: PUSH
129707: LD_INT 1
129709: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
129710: LD_VAR 0 4
129714: PUSH
129715: LD_VAR 0 7
129719: ARRAY
129720: PPUSH
129721: LD_INT 71
129723: PPUSH
129724: CALL_OW 109
// continue ;
129728: GO 129643
// end ; end ;
129730: GO 129643
129732: POP
129733: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
129734: LD_VAR 0 4
129738: PUSH
129739: LD_VAR 0 7
129743: ARRAY
129744: PPUSH
129745: CALL_OW 257
129749: PUSH
129750: LD_INT 8
129752: EQUAL
129753: PUSH
129754: LD_VAR 0 4
129758: PUSH
129759: LD_VAR 0 7
129763: ARRAY
129764: PPUSH
129765: CALL_OW 264
129769: PUSH
129770: LD_INT 28
129772: PUSH
129773: LD_INT 45
129775: PUSH
129776: LD_INT 7
129778: PUSH
129779: LD_INT 47
129781: PUSH
129782: EMPTY
129783: LIST
129784: LIST
129785: LIST
129786: LIST
129787: IN
129788: OR
129789: IFFALSE 130045
// begin attacking := false ;
129791: LD_ADDR_VAR 0 29
129795: PUSH
129796: LD_INT 0
129798: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
129799: LD_VAR 0 14
129803: PUSH
129804: LD_INT 1
129806: ARRAY
129807: PPUSH
129808: CALL_OW 266
129812: PUSH
129813: LD_INT 32
129815: PUSH
129816: LD_INT 31
129818: PUSH
129819: LD_INT 33
129821: PUSH
129822: LD_INT 4
129824: PUSH
129825: LD_INT 5
129827: PUSH
129828: EMPTY
129829: LIST
129830: LIST
129831: LIST
129832: LIST
129833: LIST
129834: IN
129835: IFFALSE 130021
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
129837: LD_ADDR_VAR 0 9
129841: PUSH
129842: LD_VAR 0 14
129846: PUSH
129847: LD_INT 1
129849: ARRAY
129850: PPUSH
129851: CALL_OW 266
129855: PPUSH
129856: LD_VAR 0 14
129860: PUSH
129861: LD_INT 1
129863: ARRAY
129864: PPUSH
129865: CALL_OW 250
129869: PPUSH
129870: LD_VAR 0 14
129874: PUSH
129875: LD_INT 1
129877: ARRAY
129878: PPUSH
129879: CALL_OW 251
129883: PPUSH
129884: LD_VAR 0 14
129888: PUSH
129889: LD_INT 1
129891: ARRAY
129892: PPUSH
129893: CALL_OW 254
129897: PPUSH
129898: LD_VAR 0 14
129902: PUSH
129903: LD_INT 1
129905: ARRAY
129906: PPUSH
129907: CALL_OW 248
129911: PPUSH
129912: LD_INT 0
129914: PPUSH
129915: CALL 79818 0 6
129919: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
129920: LD_ADDR_VAR 0 8
129924: PUSH
129925: LD_VAR 0 4
129929: PUSH
129930: LD_VAR 0 7
129934: ARRAY
129935: PPUSH
129936: LD_VAR 0 9
129940: PPUSH
129941: CALL 98488 0 2
129945: ST_TO_ADDR
// if j then
129946: LD_VAR 0 8
129950: IFFALSE 130019
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
129952: LD_VAR 0 8
129956: PUSH
129957: LD_INT 1
129959: ARRAY
129960: PPUSH
129961: LD_VAR 0 8
129965: PUSH
129966: LD_INT 2
129968: ARRAY
129969: PPUSH
129970: CALL_OW 488
129974: IFFALSE 130019
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
129976: LD_VAR 0 4
129980: PUSH
129981: LD_VAR 0 7
129985: ARRAY
129986: PPUSH
129987: LD_VAR 0 8
129991: PUSH
129992: LD_INT 1
129994: ARRAY
129995: PPUSH
129996: LD_VAR 0 8
130000: PUSH
130001: LD_INT 2
130003: ARRAY
130004: PPUSH
130005: CALL_OW 116
// attacking := true ;
130009: LD_ADDR_VAR 0 29
130013: PUSH
130014: LD_INT 1
130016: ST_TO_ADDR
// continue ;
130017: GO 127392
// end ; end else
130019: GO 130045
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130021: LD_VAR 0 4
130025: PUSH
130026: LD_VAR 0 7
130030: ARRAY
130031: PPUSH
130032: LD_VAR 0 14
130036: PUSH
130037: LD_INT 1
130039: ARRAY
130040: PPUSH
130041: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
130045: LD_VAR 0 4
130049: PUSH
130050: LD_VAR 0 7
130054: ARRAY
130055: PPUSH
130056: CALL_OW 265
130060: PUSH
130061: LD_INT 11
130063: EQUAL
130064: IFFALSE 130342
// begin k := 10 ;
130066: LD_ADDR_VAR 0 9
130070: PUSH
130071: LD_INT 10
130073: ST_TO_ADDR
// x := 0 ;
130074: LD_ADDR_VAR 0 10
130078: PUSH
130079: LD_INT 0
130081: ST_TO_ADDR
// if tmp < k then
130082: LD_VAR 0 14
130086: PUSH
130087: LD_VAR 0 9
130091: LESS
130092: IFFALSE 130104
// k := tmp ;
130094: LD_ADDR_VAR 0 9
130098: PUSH
130099: LD_VAR 0 14
130103: ST_TO_ADDR
// for j = k downto 1 do
130104: LD_ADDR_VAR 0 8
130108: PUSH
130109: DOUBLE
130110: LD_VAR 0 9
130114: INC
130115: ST_TO_ADDR
130116: LD_INT 1
130118: PUSH
130119: FOR_DOWNTO
130120: IFFALSE 130195
// begin if GetType ( tmp [ j ] ) = unit_human then
130122: LD_VAR 0 14
130126: PUSH
130127: LD_VAR 0 8
130131: ARRAY
130132: PPUSH
130133: CALL_OW 247
130137: PUSH
130138: LD_INT 1
130140: EQUAL
130141: IFFALSE 130193
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
130143: LD_VAR 0 4
130147: PUSH
130148: LD_VAR 0 7
130152: ARRAY
130153: PPUSH
130154: LD_VAR 0 14
130158: PUSH
130159: LD_VAR 0 8
130163: ARRAY
130164: PPUSH
130165: CALL 98742 0 2
// x := tmp [ j ] ;
130169: LD_ADDR_VAR 0 10
130173: PUSH
130174: LD_VAR 0 14
130178: PUSH
130179: LD_VAR 0 8
130183: ARRAY
130184: ST_TO_ADDR
// attacking := true ;
130185: LD_ADDR_VAR 0 29
130189: PUSH
130190: LD_INT 1
130192: ST_TO_ADDR
// end ; end ;
130193: GO 130119
130195: POP
130196: POP
// if not x then
130197: LD_VAR 0 10
130201: NOT
130202: IFFALSE 130342
// begin attacking := true ;
130204: LD_ADDR_VAR 0 29
130208: PUSH
130209: LD_INT 1
130211: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
130212: LD_VAR 0 4
130216: PUSH
130217: LD_VAR 0 7
130221: ARRAY
130222: PPUSH
130223: CALL_OW 250
130227: PPUSH
130228: LD_VAR 0 4
130232: PUSH
130233: LD_VAR 0 7
130237: ARRAY
130238: PPUSH
130239: CALL_OW 251
130243: PPUSH
130244: CALL_OW 546
130248: PUSH
130249: LD_INT 2
130251: ARRAY
130252: PUSH
130253: LD_VAR 0 14
130257: PUSH
130258: LD_INT 1
130260: ARRAY
130261: PPUSH
130262: CALL_OW 250
130266: PPUSH
130267: LD_VAR 0 14
130271: PUSH
130272: LD_INT 1
130274: ARRAY
130275: PPUSH
130276: CALL_OW 251
130280: PPUSH
130281: CALL_OW 546
130285: PUSH
130286: LD_INT 2
130288: ARRAY
130289: EQUAL
130290: IFFALSE 130318
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
130292: LD_VAR 0 4
130296: PUSH
130297: LD_VAR 0 7
130301: ARRAY
130302: PPUSH
130303: LD_VAR 0 14
130307: PUSH
130308: LD_INT 1
130310: ARRAY
130311: PPUSH
130312: CALL 98742 0 2
130316: GO 130342
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130318: LD_VAR 0 4
130322: PUSH
130323: LD_VAR 0 7
130327: ARRAY
130328: PPUSH
130329: LD_VAR 0 14
130333: PUSH
130334: LD_INT 1
130336: ARRAY
130337: PPUSH
130338: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
130342: LD_VAR 0 4
130346: PUSH
130347: LD_VAR 0 7
130351: ARRAY
130352: PPUSH
130353: CALL_OW 264
130357: PUSH
130358: LD_INT 29
130360: EQUAL
130361: IFFALSE 130727
// begin if WantsToAttack ( group [ i ] ) in bombed then
130363: LD_VAR 0 4
130367: PUSH
130368: LD_VAR 0 7
130372: ARRAY
130373: PPUSH
130374: CALL_OW 319
130378: PUSH
130379: LD_VAR 0 28
130383: IN
130384: IFFALSE 130388
// continue ;
130386: GO 127392
// k := 8 ;
130388: LD_ADDR_VAR 0 9
130392: PUSH
130393: LD_INT 8
130395: ST_TO_ADDR
// x := 0 ;
130396: LD_ADDR_VAR 0 10
130400: PUSH
130401: LD_INT 0
130403: ST_TO_ADDR
// if tmp < k then
130404: LD_VAR 0 14
130408: PUSH
130409: LD_VAR 0 9
130413: LESS
130414: IFFALSE 130426
// k := tmp ;
130416: LD_ADDR_VAR 0 9
130420: PUSH
130421: LD_VAR 0 14
130425: ST_TO_ADDR
// for j = 1 to k do
130426: LD_ADDR_VAR 0 8
130430: PUSH
130431: DOUBLE
130432: LD_INT 1
130434: DEC
130435: ST_TO_ADDR
130436: LD_VAR 0 9
130440: PUSH
130441: FOR_TO
130442: IFFALSE 130574
// begin if GetType ( tmp [ j ] ) = unit_building then
130444: LD_VAR 0 14
130448: PUSH
130449: LD_VAR 0 8
130453: ARRAY
130454: PPUSH
130455: CALL_OW 247
130459: PUSH
130460: LD_INT 3
130462: EQUAL
130463: IFFALSE 130572
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
130465: LD_VAR 0 14
130469: PUSH
130470: LD_VAR 0 8
130474: ARRAY
130475: PUSH
130476: LD_VAR 0 28
130480: IN
130481: NOT
130482: PUSH
130483: LD_VAR 0 14
130487: PUSH
130488: LD_VAR 0 8
130492: ARRAY
130493: PPUSH
130494: CALL_OW 313
130498: AND
130499: IFFALSE 130572
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
130501: LD_VAR 0 4
130505: PUSH
130506: LD_VAR 0 7
130510: ARRAY
130511: PPUSH
130512: LD_VAR 0 14
130516: PUSH
130517: LD_VAR 0 8
130521: ARRAY
130522: PPUSH
130523: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
130527: LD_ADDR_VAR 0 28
130531: PUSH
130532: LD_VAR 0 28
130536: PPUSH
130537: LD_VAR 0 28
130541: PUSH
130542: LD_INT 1
130544: PLUS
130545: PPUSH
130546: LD_VAR 0 14
130550: PUSH
130551: LD_VAR 0 8
130555: ARRAY
130556: PPUSH
130557: CALL_OW 1
130561: ST_TO_ADDR
// attacking := true ;
130562: LD_ADDR_VAR 0 29
130566: PUSH
130567: LD_INT 1
130569: ST_TO_ADDR
// break ;
130570: GO 130574
// end ; end ;
130572: GO 130441
130574: POP
130575: POP
// if not attacking and f_attack_depot then
130576: LD_VAR 0 29
130580: NOT
130581: PUSH
130582: LD_VAR 0 25
130586: AND
130587: IFFALSE 130682
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
130589: LD_ADDR_VAR 0 13
130593: PUSH
130594: LD_VAR 0 14
130598: PPUSH
130599: LD_INT 2
130601: PUSH
130602: LD_INT 30
130604: PUSH
130605: LD_INT 0
130607: PUSH
130608: EMPTY
130609: LIST
130610: LIST
130611: PUSH
130612: LD_INT 30
130614: PUSH
130615: LD_INT 1
130617: PUSH
130618: EMPTY
130619: LIST
130620: LIST
130621: PUSH
130622: EMPTY
130623: LIST
130624: LIST
130625: LIST
130626: PPUSH
130627: CALL_OW 72
130631: ST_TO_ADDR
// if z then
130632: LD_VAR 0 13
130636: IFFALSE 130682
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
130638: LD_VAR 0 4
130642: PUSH
130643: LD_VAR 0 7
130647: ARRAY
130648: PPUSH
130649: LD_VAR 0 13
130653: PPUSH
130654: LD_VAR 0 4
130658: PUSH
130659: LD_VAR 0 7
130663: ARRAY
130664: PPUSH
130665: CALL_OW 74
130669: PPUSH
130670: CALL_OW 115
// attacking := true ;
130674: LD_ADDR_VAR 0 29
130678: PUSH
130679: LD_INT 1
130681: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
130682: LD_VAR 0 4
130686: PUSH
130687: LD_VAR 0 7
130691: ARRAY
130692: PPUSH
130693: CALL_OW 256
130697: PUSH
130698: LD_INT 500
130700: LESS
130701: IFFALSE 130727
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130703: LD_VAR 0 4
130707: PUSH
130708: LD_VAR 0 7
130712: ARRAY
130713: PPUSH
130714: LD_VAR 0 14
130718: PUSH
130719: LD_INT 1
130721: ARRAY
130722: PPUSH
130723: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
130727: LD_VAR 0 4
130731: PUSH
130732: LD_VAR 0 7
130736: ARRAY
130737: PPUSH
130738: CALL_OW 264
130742: PUSH
130743: LD_INT 49
130745: EQUAL
130746: IFFALSE 130867
// begin if not HasTask ( group [ i ] ) then
130748: LD_VAR 0 4
130752: PUSH
130753: LD_VAR 0 7
130757: ARRAY
130758: PPUSH
130759: CALL_OW 314
130763: NOT
130764: IFFALSE 130867
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
130766: LD_ADDR_VAR 0 9
130770: PUSH
130771: LD_INT 81
130773: PUSH
130774: LD_VAR 0 4
130778: PUSH
130779: LD_VAR 0 7
130783: ARRAY
130784: PPUSH
130785: CALL_OW 255
130789: PUSH
130790: EMPTY
130791: LIST
130792: LIST
130793: PPUSH
130794: CALL_OW 69
130798: PPUSH
130799: LD_VAR 0 4
130803: PUSH
130804: LD_VAR 0 7
130808: ARRAY
130809: PPUSH
130810: CALL_OW 74
130814: ST_TO_ADDR
// if k then
130815: LD_VAR 0 9
130819: IFFALSE 130867
// if GetDistUnits ( group [ i ] , k ) > 10 then
130821: LD_VAR 0 4
130825: PUSH
130826: LD_VAR 0 7
130830: ARRAY
130831: PPUSH
130832: LD_VAR 0 9
130836: PPUSH
130837: CALL_OW 296
130841: PUSH
130842: LD_INT 10
130844: GREATER
130845: IFFALSE 130867
// ComMoveUnit ( group [ i ] , k ) ;
130847: LD_VAR 0 4
130851: PUSH
130852: LD_VAR 0 7
130856: ARRAY
130857: PPUSH
130858: LD_VAR 0 9
130862: PPUSH
130863: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
130867: LD_VAR 0 4
130871: PUSH
130872: LD_VAR 0 7
130876: ARRAY
130877: PPUSH
130878: CALL_OW 256
130882: PUSH
130883: LD_INT 250
130885: LESS
130886: PUSH
130887: LD_VAR 0 4
130891: PUSH
130892: LD_VAR 0 7
130896: ARRAY
130897: PUSH
130898: LD_INT 21
130900: PUSH
130901: LD_INT 2
130903: PUSH
130904: EMPTY
130905: LIST
130906: LIST
130907: PUSH
130908: LD_INT 23
130910: PUSH
130911: LD_INT 2
130913: PUSH
130914: EMPTY
130915: LIST
130916: LIST
130917: PUSH
130918: EMPTY
130919: LIST
130920: LIST
130921: PPUSH
130922: CALL_OW 69
130926: IN
130927: AND
130928: IFFALSE 131053
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
130930: LD_ADDR_VAR 0 9
130934: PUSH
130935: LD_OWVAR 3
130939: PUSH
130940: LD_VAR 0 4
130944: PUSH
130945: LD_VAR 0 7
130949: ARRAY
130950: DIFF
130951: PPUSH
130952: LD_VAR 0 4
130956: PUSH
130957: LD_VAR 0 7
130961: ARRAY
130962: PPUSH
130963: CALL_OW 74
130967: ST_TO_ADDR
// if not k then
130968: LD_VAR 0 9
130972: NOT
130973: IFFALSE 130977
// continue ;
130975: GO 127392
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
130977: LD_VAR 0 9
130981: PUSH
130982: LD_INT 81
130984: PUSH
130985: LD_VAR 0 4
130989: PUSH
130990: LD_VAR 0 7
130994: ARRAY
130995: PPUSH
130996: CALL_OW 255
131000: PUSH
131001: EMPTY
131002: LIST
131003: LIST
131004: PPUSH
131005: CALL_OW 69
131009: IN
131010: PUSH
131011: LD_VAR 0 9
131015: PPUSH
131016: LD_VAR 0 4
131020: PUSH
131021: LD_VAR 0 7
131025: ARRAY
131026: PPUSH
131027: CALL_OW 296
131031: PUSH
131032: LD_INT 5
131034: LESS
131035: AND
131036: IFFALSE 131053
// ComAutodestruct ( group [ i ] ) ;
131038: LD_VAR 0 4
131042: PUSH
131043: LD_VAR 0 7
131047: ARRAY
131048: PPUSH
131049: CALL 98640 0 1
// end ; if f_attack_depot then
131053: LD_VAR 0 25
131057: IFFALSE 131169
// begin k := 6 ;
131059: LD_ADDR_VAR 0 9
131063: PUSH
131064: LD_INT 6
131066: ST_TO_ADDR
// if tmp < k then
131067: LD_VAR 0 14
131071: PUSH
131072: LD_VAR 0 9
131076: LESS
131077: IFFALSE 131089
// k := tmp ;
131079: LD_ADDR_VAR 0 9
131083: PUSH
131084: LD_VAR 0 14
131088: ST_TO_ADDR
// for j = 1 to k do
131089: LD_ADDR_VAR 0 8
131093: PUSH
131094: DOUBLE
131095: LD_INT 1
131097: DEC
131098: ST_TO_ADDR
131099: LD_VAR 0 9
131103: PUSH
131104: FOR_TO
131105: IFFALSE 131167
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
131107: LD_VAR 0 8
131111: PPUSH
131112: CALL_OW 266
131116: PUSH
131117: LD_INT 0
131119: PUSH
131120: LD_INT 1
131122: PUSH
131123: EMPTY
131124: LIST
131125: LIST
131126: IN
131127: IFFALSE 131165
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131129: LD_VAR 0 4
131133: PUSH
131134: LD_VAR 0 7
131138: ARRAY
131139: PPUSH
131140: LD_VAR 0 14
131144: PUSH
131145: LD_VAR 0 8
131149: ARRAY
131150: PPUSH
131151: CALL_OW 115
// attacking := true ;
131155: LD_ADDR_VAR 0 29
131159: PUSH
131160: LD_INT 1
131162: ST_TO_ADDR
// break ;
131163: GO 131167
// end ;
131165: GO 131104
131167: POP
131168: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
131169: LD_VAR 0 4
131173: PUSH
131174: LD_VAR 0 7
131178: ARRAY
131179: PPUSH
131180: CALL_OW 302
131184: PUSH
131185: LD_VAR 0 29
131189: NOT
131190: AND
131191: IFFALSE 131513
// begin if GetTag ( group [ i ] ) = 71 then
131193: LD_VAR 0 4
131197: PUSH
131198: LD_VAR 0 7
131202: ARRAY
131203: PPUSH
131204: CALL_OW 110
131208: PUSH
131209: LD_INT 71
131211: EQUAL
131212: IFFALSE 131253
// begin if HasTask ( group [ i ] ) then
131214: LD_VAR 0 4
131218: PUSH
131219: LD_VAR 0 7
131223: ARRAY
131224: PPUSH
131225: CALL_OW 314
131229: IFFALSE 131235
// continue else
131231: GO 127392
131233: GO 131253
// SetTag ( group [ i ] , 0 ) ;
131235: LD_VAR 0 4
131239: PUSH
131240: LD_VAR 0 7
131244: ARRAY
131245: PPUSH
131246: LD_INT 0
131248: PPUSH
131249: CALL_OW 109
// end ; k := 8 ;
131253: LD_ADDR_VAR 0 9
131257: PUSH
131258: LD_INT 8
131260: ST_TO_ADDR
// x := 0 ;
131261: LD_ADDR_VAR 0 10
131265: PUSH
131266: LD_INT 0
131268: ST_TO_ADDR
// if tmp < k then
131269: LD_VAR 0 14
131273: PUSH
131274: LD_VAR 0 9
131278: LESS
131279: IFFALSE 131291
// k := tmp ;
131281: LD_ADDR_VAR 0 9
131285: PUSH
131286: LD_VAR 0 14
131290: ST_TO_ADDR
// for j = 1 to k do
131291: LD_ADDR_VAR 0 8
131295: PUSH
131296: DOUBLE
131297: LD_INT 1
131299: DEC
131300: ST_TO_ADDR
131301: LD_VAR 0 9
131305: PUSH
131306: FOR_TO
131307: IFFALSE 131405
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
131309: LD_VAR 0 14
131313: PUSH
131314: LD_VAR 0 8
131318: ARRAY
131319: PPUSH
131320: CALL_OW 247
131324: PUSH
131325: LD_INT 1
131327: EQUAL
131328: PUSH
131329: LD_VAR 0 14
131333: PUSH
131334: LD_VAR 0 8
131338: ARRAY
131339: PPUSH
131340: CALL_OW 256
131344: PUSH
131345: LD_INT 250
131347: LESS
131348: PUSH
131349: LD_VAR 0 20
131353: AND
131354: PUSH
131355: LD_VAR 0 20
131359: NOT
131360: PUSH
131361: LD_VAR 0 14
131365: PUSH
131366: LD_VAR 0 8
131370: ARRAY
131371: PPUSH
131372: CALL_OW 256
131376: PUSH
131377: LD_INT 250
131379: GREATEREQUAL
131380: AND
131381: OR
131382: AND
131383: IFFALSE 131403
// begin x := tmp [ j ] ;
131385: LD_ADDR_VAR 0 10
131389: PUSH
131390: LD_VAR 0 14
131394: PUSH
131395: LD_VAR 0 8
131399: ARRAY
131400: ST_TO_ADDR
// break ;
131401: GO 131405
// end ;
131403: GO 131306
131405: POP
131406: POP
// if x then
131407: LD_VAR 0 10
131411: IFFALSE 131435
// ComAttackUnit ( group [ i ] , x ) else
131413: LD_VAR 0 4
131417: PUSH
131418: LD_VAR 0 7
131422: ARRAY
131423: PPUSH
131424: LD_VAR 0 10
131428: PPUSH
131429: CALL_OW 115
131433: GO 131459
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131435: LD_VAR 0 4
131439: PUSH
131440: LD_VAR 0 7
131444: ARRAY
131445: PPUSH
131446: LD_VAR 0 14
131450: PUSH
131451: LD_INT 1
131453: ARRAY
131454: PPUSH
131455: CALL_OW 115
// if not HasTask ( group [ i ] ) then
131459: LD_VAR 0 4
131463: PUSH
131464: LD_VAR 0 7
131468: ARRAY
131469: PPUSH
131470: CALL_OW 314
131474: NOT
131475: IFFALSE 131513
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
131477: LD_VAR 0 4
131481: PUSH
131482: LD_VAR 0 7
131486: ARRAY
131487: PPUSH
131488: LD_VAR 0 14
131492: PPUSH
131493: LD_VAR 0 4
131497: PUSH
131498: LD_VAR 0 7
131502: ARRAY
131503: PPUSH
131504: CALL_OW 74
131508: PPUSH
131509: CALL_OW 115
// end ; end ; end ;
131513: GO 127392
131515: POP
131516: POP
// wait ( 0 0$2 ) ;
131517: LD_INT 70
131519: PPUSH
131520: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
131524: LD_VAR 0 4
131528: NOT
131529: PUSH
131530: LD_VAR 0 4
131534: PUSH
131535: EMPTY
131536: EQUAL
131537: OR
131538: PUSH
131539: LD_INT 81
131541: PUSH
131542: LD_VAR 0 35
131546: PUSH
131547: EMPTY
131548: LIST
131549: LIST
131550: PPUSH
131551: CALL_OW 69
131555: NOT
131556: OR
131557: IFFALSE 127377
// end ;
131559: LD_VAR 0 2
131563: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
131564: LD_INT 0
131566: PPUSH
131567: PPUSH
131568: PPUSH
131569: PPUSH
131570: PPUSH
131571: PPUSH
// if not base or not mc_bases [ base ] or not solds then
131572: LD_VAR 0 1
131576: NOT
131577: PUSH
131578: LD_EXP 97
131582: PUSH
131583: LD_VAR 0 1
131587: ARRAY
131588: NOT
131589: OR
131590: PUSH
131591: LD_VAR 0 2
131595: NOT
131596: OR
131597: IFFALSE 131601
// exit ;
131599: GO 132155
// side := mc_sides [ base ] ;
131601: LD_ADDR_VAR 0 6
131605: PUSH
131606: LD_EXP 123
131610: PUSH
131611: LD_VAR 0 1
131615: ARRAY
131616: ST_TO_ADDR
// if not side then
131617: LD_VAR 0 6
131621: NOT
131622: IFFALSE 131626
// exit ;
131624: GO 132155
// for i in solds do
131626: LD_ADDR_VAR 0 7
131630: PUSH
131631: LD_VAR 0 2
131635: PUSH
131636: FOR_IN
131637: IFFALSE 131698
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
131639: LD_VAR 0 7
131643: PPUSH
131644: CALL_OW 310
131648: PPUSH
131649: CALL_OW 266
131653: PUSH
131654: LD_INT 32
131656: PUSH
131657: LD_INT 31
131659: PUSH
131660: EMPTY
131661: LIST
131662: LIST
131663: IN
131664: IFFALSE 131684
// solds := solds diff i else
131666: LD_ADDR_VAR 0 2
131670: PUSH
131671: LD_VAR 0 2
131675: PUSH
131676: LD_VAR 0 7
131680: DIFF
131681: ST_TO_ADDR
131682: GO 131696
// SetTag ( i , 18 ) ;
131684: LD_VAR 0 7
131688: PPUSH
131689: LD_INT 18
131691: PPUSH
131692: CALL_OW 109
131696: GO 131636
131698: POP
131699: POP
// if not solds then
131700: LD_VAR 0 2
131704: NOT
131705: IFFALSE 131709
// exit ;
131707: GO 132155
// repeat wait ( 0 0$2 ) ;
131709: LD_INT 70
131711: PPUSH
131712: CALL_OW 67
// enemy := mc_scan [ base ] ;
131716: LD_ADDR_VAR 0 4
131720: PUSH
131721: LD_EXP 120
131725: PUSH
131726: LD_VAR 0 1
131730: ARRAY
131731: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
131732: LD_EXP 97
131736: PUSH
131737: LD_VAR 0 1
131741: ARRAY
131742: NOT
131743: PUSH
131744: LD_EXP 97
131748: PUSH
131749: LD_VAR 0 1
131753: ARRAY
131754: PUSH
131755: EMPTY
131756: EQUAL
131757: OR
131758: IFFALSE 131795
// begin for i in solds do
131760: LD_ADDR_VAR 0 7
131764: PUSH
131765: LD_VAR 0 2
131769: PUSH
131770: FOR_IN
131771: IFFALSE 131784
// ComStop ( i ) ;
131773: LD_VAR 0 7
131777: PPUSH
131778: CALL_OW 141
131782: GO 131770
131784: POP
131785: POP
// solds := [ ] ;
131786: LD_ADDR_VAR 0 2
131790: PUSH
131791: EMPTY
131792: ST_TO_ADDR
// exit ;
131793: GO 132155
// end ; for i in solds do
131795: LD_ADDR_VAR 0 7
131799: PUSH
131800: LD_VAR 0 2
131804: PUSH
131805: FOR_IN
131806: IFFALSE 132127
// begin if IsInUnit ( i ) then
131808: LD_VAR 0 7
131812: PPUSH
131813: CALL_OW 310
131817: IFFALSE 131828
// ComExitBuilding ( i ) ;
131819: LD_VAR 0 7
131823: PPUSH
131824: CALL_OW 122
// if GetLives ( i ) > 500 then
131828: LD_VAR 0 7
131832: PPUSH
131833: CALL_OW 256
131837: PUSH
131838: LD_INT 500
131840: GREATER
131841: IFFALSE 131894
// begin e := NearestUnitToUnit ( enemy , i ) ;
131843: LD_ADDR_VAR 0 5
131847: PUSH
131848: LD_VAR 0 4
131852: PPUSH
131853: LD_VAR 0 7
131857: PPUSH
131858: CALL_OW 74
131862: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
131863: LD_VAR 0 7
131867: PPUSH
131868: LD_VAR 0 5
131872: PPUSH
131873: CALL_OW 250
131877: PPUSH
131878: LD_VAR 0 5
131882: PPUSH
131883: CALL_OW 251
131887: PPUSH
131888: CALL_OW 114
// end else
131892: GO 132125
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
131894: LD_VAR 0 7
131898: PPUSH
131899: LD_EXP 97
131903: PUSH
131904: LD_VAR 0 1
131908: ARRAY
131909: PPUSH
131910: LD_INT 2
131912: PUSH
131913: LD_INT 30
131915: PUSH
131916: LD_INT 0
131918: PUSH
131919: EMPTY
131920: LIST
131921: LIST
131922: PUSH
131923: LD_INT 30
131925: PUSH
131926: LD_INT 1
131928: PUSH
131929: EMPTY
131930: LIST
131931: LIST
131932: PUSH
131933: LD_INT 30
131935: PUSH
131936: LD_INT 6
131938: PUSH
131939: EMPTY
131940: LIST
131941: LIST
131942: PUSH
131943: EMPTY
131944: LIST
131945: LIST
131946: LIST
131947: LIST
131948: PPUSH
131949: CALL_OW 72
131953: PPUSH
131954: LD_VAR 0 7
131958: PPUSH
131959: CALL_OW 74
131963: PPUSH
131964: CALL_OW 296
131968: PUSH
131969: LD_INT 10
131971: GREATER
131972: IFFALSE 132125
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
131974: LD_ADDR_VAR 0 8
131978: PUSH
131979: LD_EXP 97
131983: PUSH
131984: LD_VAR 0 1
131988: ARRAY
131989: PPUSH
131990: LD_INT 2
131992: PUSH
131993: LD_INT 30
131995: PUSH
131996: LD_INT 0
131998: PUSH
131999: EMPTY
132000: LIST
132001: LIST
132002: PUSH
132003: LD_INT 30
132005: PUSH
132006: LD_INT 1
132008: PUSH
132009: EMPTY
132010: LIST
132011: LIST
132012: PUSH
132013: LD_INT 30
132015: PUSH
132016: LD_INT 6
132018: PUSH
132019: EMPTY
132020: LIST
132021: LIST
132022: PUSH
132023: EMPTY
132024: LIST
132025: LIST
132026: LIST
132027: LIST
132028: PPUSH
132029: CALL_OW 72
132033: PPUSH
132034: LD_VAR 0 7
132038: PPUSH
132039: CALL_OW 74
132043: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
132044: LD_VAR 0 7
132048: PPUSH
132049: LD_VAR 0 8
132053: PPUSH
132054: CALL_OW 250
132058: PPUSH
132059: LD_INT 3
132061: PPUSH
132062: LD_INT 5
132064: PPUSH
132065: CALL_OW 272
132069: PPUSH
132070: LD_VAR 0 8
132074: PPUSH
132075: CALL_OW 251
132079: PPUSH
132080: LD_INT 3
132082: PPUSH
132083: LD_INT 5
132085: PPUSH
132086: CALL_OW 273
132090: PPUSH
132091: CALL_OW 111
// SetTag ( i , 0 ) ;
132095: LD_VAR 0 7
132099: PPUSH
132100: LD_INT 0
132102: PPUSH
132103: CALL_OW 109
// solds := solds diff i ;
132107: LD_ADDR_VAR 0 2
132111: PUSH
132112: LD_VAR 0 2
132116: PUSH
132117: LD_VAR 0 7
132121: DIFF
132122: ST_TO_ADDR
// continue ;
132123: GO 131805
// end ; end ;
132125: GO 131805
132127: POP
132128: POP
// until not solds or not enemy ;
132129: LD_VAR 0 2
132133: NOT
132134: PUSH
132135: LD_VAR 0 4
132139: NOT
132140: OR
132141: IFFALSE 131709
// MC_Reset ( base , 18 ) ;
132143: LD_VAR 0 1
132147: PPUSH
132148: LD_INT 18
132150: PPUSH
132151: CALL 39282 0 2
// end ;
132155: LD_VAR 0 3
132159: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
132160: LD_INT 0
132162: PPUSH
132163: PPUSH
132164: PPUSH
132165: PPUSH
132166: PPUSH
132167: PPUSH
132168: PPUSH
132169: PPUSH
132170: PPUSH
132171: PPUSH
132172: PPUSH
132173: PPUSH
132174: PPUSH
132175: PPUSH
132176: PPUSH
132177: PPUSH
132178: PPUSH
132179: PPUSH
132180: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
132181: LD_ADDR_VAR 0 12
132185: PUSH
132186: LD_EXP 97
132190: PUSH
132191: LD_VAR 0 1
132195: ARRAY
132196: PPUSH
132197: LD_INT 25
132199: PUSH
132200: LD_INT 3
132202: PUSH
132203: EMPTY
132204: LIST
132205: LIST
132206: PPUSH
132207: CALL_OW 72
132211: ST_TO_ADDR
// if mc_remote_driver [ base ] then
132212: LD_EXP 137
132216: PUSH
132217: LD_VAR 0 1
132221: ARRAY
132222: IFFALSE 132246
// mechs := mechs diff mc_remote_driver [ base ] ;
132224: LD_ADDR_VAR 0 12
132228: PUSH
132229: LD_VAR 0 12
132233: PUSH
132234: LD_EXP 137
132238: PUSH
132239: LD_VAR 0 1
132243: ARRAY
132244: DIFF
132245: ST_TO_ADDR
// for i in mechs do
132246: LD_ADDR_VAR 0 4
132250: PUSH
132251: LD_VAR 0 12
132255: PUSH
132256: FOR_IN
132257: IFFALSE 132292
// if GetTag ( i ) > 0 then
132259: LD_VAR 0 4
132263: PPUSH
132264: CALL_OW 110
132268: PUSH
132269: LD_INT 0
132271: GREATER
132272: IFFALSE 132290
// mechs := mechs diff i ;
132274: LD_ADDR_VAR 0 12
132278: PUSH
132279: LD_VAR 0 12
132283: PUSH
132284: LD_VAR 0 4
132288: DIFF
132289: ST_TO_ADDR
132290: GO 132256
132292: POP
132293: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
132294: LD_ADDR_VAR 0 8
132298: PUSH
132299: LD_EXP 97
132303: PUSH
132304: LD_VAR 0 1
132308: ARRAY
132309: PPUSH
132310: LD_INT 2
132312: PUSH
132313: LD_INT 25
132315: PUSH
132316: LD_INT 1
132318: PUSH
132319: EMPTY
132320: LIST
132321: LIST
132322: PUSH
132323: LD_INT 25
132325: PUSH
132326: LD_INT 5
132328: PUSH
132329: EMPTY
132330: LIST
132331: LIST
132332: PUSH
132333: LD_INT 25
132335: PUSH
132336: LD_INT 8
132338: PUSH
132339: EMPTY
132340: LIST
132341: LIST
132342: PUSH
132343: LD_INT 25
132345: PUSH
132346: LD_INT 9
132348: PUSH
132349: EMPTY
132350: LIST
132351: LIST
132352: PUSH
132353: EMPTY
132354: LIST
132355: LIST
132356: LIST
132357: LIST
132358: LIST
132359: PPUSH
132360: CALL_OW 72
132364: ST_TO_ADDR
// if not defenders and not solds then
132365: LD_VAR 0 2
132369: NOT
132370: PUSH
132371: LD_VAR 0 8
132375: NOT
132376: AND
132377: IFFALSE 132381
// exit ;
132379: GO 134151
// depot_under_attack := false ;
132381: LD_ADDR_VAR 0 16
132385: PUSH
132386: LD_INT 0
132388: ST_TO_ADDR
// sold_defenders := [ ] ;
132389: LD_ADDR_VAR 0 17
132393: PUSH
132394: EMPTY
132395: ST_TO_ADDR
// if mechs then
132396: LD_VAR 0 12
132400: IFFALSE 132553
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
132402: LD_ADDR_VAR 0 4
132406: PUSH
132407: LD_VAR 0 2
132411: PPUSH
132412: LD_INT 21
132414: PUSH
132415: LD_INT 2
132417: PUSH
132418: EMPTY
132419: LIST
132420: LIST
132421: PPUSH
132422: CALL_OW 72
132426: PUSH
132427: FOR_IN
132428: IFFALSE 132551
// begin if GetTag ( i ) <> 20 then
132430: LD_VAR 0 4
132434: PPUSH
132435: CALL_OW 110
132439: PUSH
132440: LD_INT 20
132442: NONEQUAL
132443: IFFALSE 132457
// SetTag ( i , 20 ) ;
132445: LD_VAR 0 4
132449: PPUSH
132450: LD_INT 20
132452: PPUSH
132453: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
132457: LD_VAR 0 4
132461: PPUSH
132462: CALL_OW 263
132466: PUSH
132467: LD_INT 1
132469: EQUAL
132470: PUSH
132471: LD_VAR 0 4
132475: PPUSH
132476: CALL_OW 311
132480: NOT
132481: AND
132482: IFFALSE 132549
// begin un := mechs [ 1 ] ;
132484: LD_ADDR_VAR 0 10
132488: PUSH
132489: LD_VAR 0 12
132493: PUSH
132494: LD_INT 1
132496: ARRAY
132497: ST_TO_ADDR
// ComExit ( un ) ;
132498: LD_VAR 0 10
132502: PPUSH
132503: CALL 103506 0 1
// AddComEnterUnit ( un , i ) ;
132507: LD_VAR 0 10
132511: PPUSH
132512: LD_VAR 0 4
132516: PPUSH
132517: CALL_OW 180
// SetTag ( un , 19 ) ;
132521: LD_VAR 0 10
132525: PPUSH
132526: LD_INT 19
132528: PPUSH
132529: CALL_OW 109
// mechs := mechs diff un ;
132533: LD_ADDR_VAR 0 12
132537: PUSH
132538: LD_VAR 0 12
132542: PUSH
132543: LD_VAR 0 10
132547: DIFF
132548: ST_TO_ADDR
// end ; end ;
132549: GO 132427
132551: POP
132552: POP
// if solds then
132553: LD_VAR 0 8
132557: IFFALSE 132616
// for i in solds do
132559: LD_ADDR_VAR 0 4
132563: PUSH
132564: LD_VAR 0 8
132568: PUSH
132569: FOR_IN
132570: IFFALSE 132614
// if not GetTag ( i ) then
132572: LD_VAR 0 4
132576: PPUSH
132577: CALL_OW 110
132581: NOT
132582: IFFALSE 132612
// begin defenders := defenders union i ;
132584: LD_ADDR_VAR 0 2
132588: PUSH
132589: LD_VAR 0 2
132593: PUSH
132594: LD_VAR 0 4
132598: UNION
132599: ST_TO_ADDR
// SetTag ( i , 18 ) ;
132600: LD_VAR 0 4
132604: PPUSH
132605: LD_INT 18
132607: PPUSH
132608: CALL_OW 109
// end ;
132612: GO 132569
132614: POP
132615: POP
// repeat wait ( 0 0$2 ) ;
132616: LD_INT 70
132618: PPUSH
132619: CALL_OW 67
// enemy := mc_scan [ base ] ;
132623: LD_ADDR_VAR 0 21
132627: PUSH
132628: LD_EXP 120
132632: PUSH
132633: LD_VAR 0 1
132637: ARRAY
132638: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
132639: LD_EXP 97
132643: PUSH
132644: LD_VAR 0 1
132648: ARRAY
132649: NOT
132650: PUSH
132651: LD_EXP 97
132655: PUSH
132656: LD_VAR 0 1
132660: ARRAY
132661: PUSH
132662: EMPTY
132663: EQUAL
132664: OR
132665: IFFALSE 132702
// begin for i in defenders do
132667: LD_ADDR_VAR 0 4
132671: PUSH
132672: LD_VAR 0 2
132676: PUSH
132677: FOR_IN
132678: IFFALSE 132691
// ComStop ( i ) ;
132680: LD_VAR 0 4
132684: PPUSH
132685: CALL_OW 141
132689: GO 132677
132691: POP
132692: POP
// defenders := [ ] ;
132693: LD_ADDR_VAR 0 2
132697: PUSH
132698: EMPTY
132699: ST_TO_ADDR
// exit ;
132700: GO 134151
// end ; for i in defenders do
132702: LD_ADDR_VAR 0 4
132706: PUSH
132707: LD_VAR 0 2
132711: PUSH
132712: FOR_IN
132713: IFFALSE 133611
// begin e := NearestUnitToUnit ( enemy , i ) ;
132715: LD_ADDR_VAR 0 13
132719: PUSH
132720: LD_VAR 0 21
132724: PPUSH
132725: LD_VAR 0 4
132729: PPUSH
132730: CALL_OW 74
132734: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132735: LD_ADDR_VAR 0 7
132739: PUSH
132740: LD_EXP 97
132744: PUSH
132745: LD_VAR 0 1
132749: ARRAY
132750: PPUSH
132751: LD_INT 2
132753: PUSH
132754: LD_INT 30
132756: PUSH
132757: LD_INT 0
132759: PUSH
132760: EMPTY
132761: LIST
132762: LIST
132763: PUSH
132764: LD_INT 30
132766: PUSH
132767: LD_INT 1
132769: PUSH
132770: EMPTY
132771: LIST
132772: LIST
132773: PUSH
132774: EMPTY
132775: LIST
132776: LIST
132777: LIST
132778: PPUSH
132779: CALL_OW 72
132783: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
132784: LD_ADDR_VAR 0 16
132788: PUSH
132789: LD_VAR 0 7
132793: NOT
132794: PUSH
132795: LD_VAR 0 7
132799: PPUSH
132800: LD_INT 3
132802: PUSH
132803: LD_INT 24
132805: PUSH
132806: LD_INT 600
132808: PUSH
132809: EMPTY
132810: LIST
132811: LIST
132812: PUSH
132813: EMPTY
132814: LIST
132815: LIST
132816: PPUSH
132817: CALL_OW 72
132821: OR
132822: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
132823: LD_VAR 0 4
132827: PPUSH
132828: CALL_OW 247
132832: PUSH
132833: LD_INT 2
132835: DOUBLE
132836: EQUAL
132837: IFTRUE 132841
132839: GO 133237
132841: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
132842: LD_VAR 0 4
132846: PPUSH
132847: CALL_OW 256
132851: PUSH
132852: LD_INT 1000
132854: EQUAL
132855: PUSH
132856: LD_VAR 0 4
132860: PPUSH
132861: LD_VAR 0 13
132865: PPUSH
132866: CALL_OW 296
132870: PUSH
132871: LD_INT 40
132873: LESS
132874: PUSH
132875: LD_VAR 0 13
132879: PPUSH
132880: LD_EXP 122
132884: PUSH
132885: LD_VAR 0 1
132889: ARRAY
132890: PPUSH
132891: CALL_OW 308
132895: OR
132896: AND
132897: IFFALSE 133019
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
132899: LD_VAR 0 4
132903: PPUSH
132904: CALL_OW 262
132908: PUSH
132909: LD_INT 1
132911: EQUAL
132912: PUSH
132913: LD_VAR 0 4
132917: PPUSH
132918: CALL_OW 261
132922: PUSH
132923: LD_INT 30
132925: LESS
132926: AND
132927: PUSH
132928: LD_VAR 0 7
132932: AND
132933: IFFALSE 133003
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
132935: LD_VAR 0 4
132939: PPUSH
132940: LD_VAR 0 7
132944: PPUSH
132945: LD_VAR 0 4
132949: PPUSH
132950: CALL_OW 74
132954: PPUSH
132955: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
132959: LD_VAR 0 4
132963: PPUSH
132964: LD_VAR 0 7
132968: PPUSH
132969: LD_VAR 0 4
132973: PPUSH
132974: CALL_OW 74
132978: PPUSH
132979: CALL_OW 296
132983: PUSH
132984: LD_INT 6
132986: LESS
132987: IFFALSE 133001
// SetFuel ( i , 100 ) ;
132989: LD_VAR 0 4
132993: PPUSH
132994: LD_INT 100
132996: PPUSH
132997: CALL_OW 240
// end else
133001: GO 133017
// ComAttackUnit ( i , e ) ;
133003: LD_VAR 0 4
133007: PPUSH
133008: LD_VAR 0 13
133012: PPUSH
133013: CALL_OW 115
// end else
133017: GO 133120
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
133019: LD_VAR 0 13
133023: PPUSH
133024: LD_EXP 122
133028: PUSH
133029: LD_VAR 0 1
133033: ARRAY
133034: PPUSH
133035: CALL_OW 308
133039: NOT
133040: PUSH
133041: LD_VAR 0 4
133045: PPUSH
133046: LD_VAR 0 13
133050: PPUSH
133051: CALL_OW 296
133055: PUSH
133056: LD_INT 40
133058: GREATEREQUAL
133059: AND
133060: PUSH
133061: LD_VAR 0 4
133065: PPUSH
133066: CALL_OW 256
133070: PUSH
133071: LD_INT 650
133073: LESSEQUAL
133074: OR
133075: PUSH
133076: LD_VAR 0 4
133080: PPUSH
133081: LD_EXP 121
133085: PUSH
133086: LD_VAR 0 1
133090: ARRAY
133091: PPUSH
133092: CALL_OW 308
133096: NOT
133097: AND
133098: IFFALSE 133120
// ComMoveToArea ( i , mc_parking [ base ] ) ;
133100: LD_VAR 0 4
133104: PPUSH
133105: LD_EXP 121
133109: PUSH
133110: LD_VAR 0 1
133114: ARRAY
133115: PPUSH
133116: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
133120: LD_VAR 0 4
133124: PPUSH
133125: CALL_OW 256
133129: PUSH
133130: LD_INT 1000
133132: LESS
133133: PUSH
133134: LD_VAR 0 4
133138: PPUSH
133139: CALL_OW 263
133143: PUSH
133144: LD_INT 1
133146: EQUAL
133147: AND
133148: PUSH
133149: LD_VAR 0 4
133153: PPUSH
133154: CALL_OW 311
133158: AND
133159: PUSH
133160: LD_VAR 0 4
133164: PPUSH
133165: LD_EXP 121
133169: PUSH
133170: LD_VAR 0 1
133174: ARRAY
133175: PPUSH
133176: CALL_OW 308
133180: AND
133181: IFFALSE 133235
// begin mech := IsDrivenBy ( i ) ;
133183: LD_ADDR_VAR 0 9
133187: PUSH
133188: LD_VAR 0 4
133192: PPUSH
133193: CALL_OW 311
133197: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
133198: LD_VAR 0 9
133202: PPUSH
133203: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
133207: LD_VAR 0 9
133211: PPUSH
133212: LD_VAR 0 4
133216: PPUSH
133217: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
133221: LD_VAR 0 9
133225: PPUSH
133226: LD_VAR 0 4
133230: PPUSH
133231: CALL_OW 180
// end ; end ; unit_human :
133235: GO 133582
133237: LD_INT 1
133239: DOUBLE
133240: EQUAL
133241: IFTRUE 133245
133243: GO 133581
133245: POP
// begin b := IsInUnit ( i ) ;
133246: LD_ADDR_VAR 0 18
133250: PUSH
133251: LD_VAR 0 4
133255: PPUSH
133256: CALL_OW 310
133260: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
133261: LD_ADDR_VAR 0 19
133265: PUSH
133266: LD_VAR 0 18
133270: NOT
133271: PUSH
133272: LD_VAR 0 18
133276: PPUSH
133277: CALL_OW 266
133281: PUSH
133282: LD_INT 32
133284: PUSH
133285: LD_INT 31
133287: PUSH
133288: EMPTY
133289: LIST
133290: LIST
133291: IN
133292: OR
133293: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
133294: LD_VAR 0 18
133298: PPUSH
133299: CALL_OW 266
133303: PUSH
133304: LD_INT 5
133306: EQUAL
133307: PUSH
133308: LD_VAR 0 4
133312: PPUSH
133313: CALL_OW 257
133317: PUSH
133318: LD_INT 1
133320: PUSH
133321: LD_INT 2
133323: PUSH
133324: LD_INT 3
133326: PUSH
133327: LD_INT 4
133329: PUSH
133330: EMPTY
133331: LIST
133332: LIST
133333: LIST
133334: LIST
133335: IN
133336: AND
133337: IFFALSE 133374
// begin class := AllowSpecClass ( i ) ;
133339: LD_ADDR_VAR 0 20
133343: PUSH
133344: LD_VAR 0 4
133348: PPUSH
133349: CALL 67518 0 1
133353: ST_TO_ADDR
// if class then
133354: LD_VAR 0 20
133358: IFFALSE 133374
// ComChangeProfession ( i , class ) ;
133360: LD_VAR 0 4
133364: PPUSH
133365: LD_VAR 0 20
133369: PPUSH
133370: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
133374: LD_VAR 0 16
133378: PUSH
133379: LD_VAR 0 2
133383: PPUSH
133384: LD_INT 21
133386: PUSH
133387: LD_INT 2
133389: PUSH
133390: EMPTY
133391: LIST
133392: LIST
133393: PPUSH
133394: CALL_OW 72
133398: PUSH
133399: LD_INT 1
133401: LESSEQUAL
133402: OR
133403: PUSH
133404: LD_VAR 0 19
133408: AND
133409: PUSH
133410: LD_VAR 0 4
133414: PUSH
133415: LD_VAR 0 17
133419: IN
133420: NOT
133421: AND
133422: IFFALSE 133515
// begin if b then
133424: LD_VAR 0 18
133428: IFFALSE 133477
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
133430: LD_VAR 0 18
133434: PPUSH
133435: LD_VAR 0 21
133439: PPUSH
133440: LD_VAR 0 18
133444: PPUSH
133445: CALL_OW 74
133449: PPUSH
133450: CALL_OW 296
133454: PUSH
133455: LD_INT 10
133457: LESS
133458: PUSH
133459: LD_VAR 0 18
133463: PPUSH
133464: CALL_OW 461
133468: PUSH
133469: LD_INT 7
133471: NONEQUAL
133472: AND
133473: IFFALSE 133477
// continue ;
133475: GO 132712
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
133477: LD_ADDR_VAR 0 17
133481: PUSH
133482: LD_VAR 0 17
133486: PPUSH
133487: LD_VAR 0 17
133491: PUSH
133492: LD_INT 1
133494: PLUS
133495: PPUSH
133496: LD_VAR 0 4
133500: PPUSH
133501: CALL_OW 1
133505: ST_TO_ADDR
// ComExitBuilding ( i ) ;
133506: LD_VAR 0 4
133510: PPUSH
133511: CALL_OW 122
// end ; if sold_defenders then
133515: LD_VAR 0 17
133519: IFFALSE 133579
// if i in sold_defenders then
133521: LD_VAR 0 4
133525: PUSH
133526: LD_VAR 0 17
133530: IN
133531: IFFALSE 133579
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
133533: LD_VAR 0 4
133537: PPUSH
133538: CALL_OW 314
133542: NOT
133543: PUSH
133544: LD_VAR 0 4
133548: PPUSH
133549: LD_VAR 0 13
133553: PPUSH
133554: CALL_OW 296
133558: PUSH
133559: LD_INT 30
133561: LESS
133562: AND
133563: IFFALSE 133579
// ComAttackUnit ( i , e ) ;
133565: LD_VAR 0 4
133569: PPUSH
133570: LD_VAR 0 13
133574: PPUSH
133575: CALL_OW 115
// end ; end ; end ;
133579: GO 133582
133581: POP
// if IsDead ( i ) then
133582: LD_VAR 0 4
133586: PPUSH
133587: CALL_OW 301
133591: IFFALSE 133609
// defenders := defenders diff i ;
133593: LD_ADDR_VAR 0 2
133597: PUSH
133598: LD_VAR 0 2
133602: PUSH
133603: LD_VAR 0 4
133607: DIFF
133608: ST_TO_ADDR
// end ;
133609: GO 132712
133611: POP
133612: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
133613: LD_VAR 0 21
133617: NOT
133618: PUSH
133619: LD_VAR 0 2
133623: NOT
133624: OR
133625: PUSH
133626: LD_EXP 97
133630: PUSH
133631: LD_VAR 0 1
133635: ARRAY
133636: NOT
133637: OR
133638: IFFALSE 132616
// MC_Reset ( base , 18 ) ;
133640: LD_VAR 0 1
133644: PPUSH
133645: LD_INT 18
133647: PPUSH
133648: CALL 39282 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
133652: LD_ADDR_VAR 0 2
133656: PUSH
133657: LD_VAR 0 2
133661: PUSH
133662: LD_VAR 0 2
133666: PPUSH
133667: LD_INT 2
133669: PUSH
133670: LD_INT 25
133672: PUSH
133673: LD_INT 1
133675: PUSH
133676: EMPTY
133677: LIST
133678: LIST
133679: PUSH
133680: LD_INT 25
133682: PUSH
133683: LD_INT 5
133685: PUSH
133686: EMPTY
133687: LIST
133688: LIST
133689: PUSH
133690: LD_INT 25
133692: PUSH
133693: LD_INT 8
133695: PUSH
133696: EMPTY
133697: LIST
133698: LIST
133699: PUSH
133700: LD_INT 25
133702: PUSH
133703: LD_INT 9
133705: PUSH
133706: EMPTY
133707: LIST
133708: LIST
133709: PUSH
133710: EMPTY
133711: LIST
133712: LIST
133713: LIST
133714: LIST
133715: LIST
133716: PPUSH
133717: CALL_OW 72
133721: DIFF
133722: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
133723: LD_VAR 0 21
133727: NOT
133728: PUSH
133729: LD_VAR 0 2
133733: PPUSH
133734: LD_INT 21
133736: PUSH
133737: LD_INT 2
133739: PUSH
133740: EMPTY
133741: LIST
133742: LIST
133743: PPUSH
133744: CALL_OW 72
133748: AND
133749: IFFALSE 134087
// begin tmp := FilterByTag ( defenders , 19 ) ;
133751: LD_ADDR_VAR 0 11
133755: PUSH
133756: LD_VAR 0 2
133760: PPUSH
133761: LD_INT 19
133763: PPUSH
133764: CALL 100682 0 2
133768: ST_TO_ADDR
// if tmp then
133769: LD_VAR 0 11
133773: IFFALSE 133843
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
133775: LD_ADDR_VAR 0 11
133779: PUSH
133780: LD_VAR 0 11
133784: PPUSH
133785: LD_INT 25
133787: PUSH
133788: LD_INT 3
133790: PUSH
133791: EMPTY
133792: LIST
133793: LIST
133794: PPUSH
133795: CALL_OW 72
133799: ST_TO_ADDR
// if tmp then
133800: LD_VAR 0 11
133804: IFFALSE 133843
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
133806: LD_ADDR_EXP 109
133810: PUSH
133811: LD_EXP 109
133815: PPUSH
133816: LD_VAR 0 1
133820: PPUSH
133821: LD_EXP 109
133825: PUSH
133826: LD_VAR 0 1
133830: ARRAY
133831: PUSH
133832: LD_VAR 0 11
133836: UNION
133837: PPUSH
133838: CALL_OW 1
133842: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
133843: LD_VAR 0 1
133847: PPUSH
133848: LD_INT 19
133850: PPUSH
133851: CALL 39282 0 2
// repeat wait ( 0 0$1 ) ;
133855: LD_INT 35
133857: PPUSH
133858: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133862: LD_EXP 97
133866: PUSH
133867: LD_VAR 0 1
133871: ARRAY
133872: NOT
133873: PUSH
133874: LD_EXP 97
133878: PUSH
133879: LD_VAR 0 1
133883: ARRAY
133884: PUSH
133885: EMPTY
133886: EQUAL
133887: OR
133888: IFFALSE 133925
// begin for i in defenders do
133890: LD_ADDR_VAR 0 4
133894: PUSH
133895: LD_VAR 0 2
133899: PUSH
133900: FOR_IN
133901: IFFALSE 133914
// ComStop ( i ) ;
133903: LD_VAR 0 4
133907: PPUSH
133908: CALL_OW 141
133912: GO 133900
133914: POP
133915: POP
// defenders := [ ] ;
133916: LD_ADDR_VAR 0 2
133920: PUSH
133921: EMPTY
133922: ST_TO_ADDR
// exit ;
133923: GO 134151
// end ; for i in defenders do
133925: LD_ADDR_VAR 0 4
133929: PUSH
133930: LD_VAR 0 2
133934: PUSH
133935: FOR_IN
133936: IFFALSE 134025
// begin if not IsInArea ( i , mc_parking [ base ] ) then
133938: LD_VAR 0 4
133942: PPUSH
133943: LD_EXP 121
133947: PUSH
133948: LD_VAR 0 1
133952: ARRAY
133953: PPUSH
133954: CALL_OW 308
133958: NOT
133959: IFFALSE 133983
// ComMoveToArea ( i , mc_parking [ base ] ) else
133961: LD_VAR 0 4
133965: PPUSH
133966: LD_EXP 121
133970: PUSH
133971: LD_VAR 0 1
133975: ARRAY
133976: PPUSH
133977: CALL_OW 113
133981: GO 134023
// if GetControl ( i ) = control_manual then
133983: LD_VAR 0 4
133987: PPUSH
133988: CALL_OW 263
133992: PUSH
133993: LD_INT 1
133995: EQUAL
133996: IFFALSE 134023
// if IsDrivenBy ( i ) then
133998: LD_VAR 0 4
134002: PPUSH
134003: CALL_OW 311
134007: IFFALSE 134023
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
134009: LD_VAR 0 4
134013: PPUSH
134014: CALL_OW 311
134018: PPUSH
134019: CALL_OW 121
// end ;
134023: GO 133935
134025: POP
134026: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
134027: LD_VAR 0 2
134031: PPUSH
134032: LD_INT 95
134034: PUSH
134035: LD_EXP 121
134039: PUSH
134040: LD_VAR 0 1
134044: ARRAY
134045: PUSH
134046: EMPTY
134047: LIST
134048: LIST
134049: PPUSH
134050: CALL_OW 72
134054: PUSH
134055: LD_VAR 0 2
134059: EQUAL
134060: PUSH
134061: LD_EXP 120
134065: PUSH
134066: LD_VAR 0 1
134070: ARRAY
134071: OR
134072: PUSH
134073: LD_EXP 97
134077: PUSH
134078: LD_VAR 0 1
134082: ARRAY
134083: NOT
134084: OR
134085: IFFALSE 133855
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
134087: LD_ADDR_EXP 119
134091: PUSH
134092: LD_EXP 119
134096: PPUSH
134097: LD_VAR 0 1
134101: PPUSH
134102: LD_VAR 0 2
134106: PPUSH
134107: LD_INT 21
134109: PUSH
134110: LD_INT 2
134112: PUSH
134113: EMPTY
134114: LIST
134115: LIST
134116: PPUSH
134117: CALL_OW 72
134121: PPUSH
134122: CALL_OW 1
134126: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
134127: LD_VAR 0 1
134131: PPUSH
134132: LD_INT 19
134134: PPUSH
134135: CALL 39282 0 2
// MC_Reset ( base , 20 ) ;
134139: LD_VAR 0 1
134143: PPUSH
134144: LD_INT 20
134146: PPUSH
134147: CALL 39282 0 2
// end ; end_of_file
134151: LD_VAR 0 3
134155: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
134156: LD_VAR 0 1
134160: PUSH
134161: LD_INT 200
134163: DOUBLE
134164: GREATEREQUAL
134165: IFFALSE 134173
134167: LD_INT 299
134169: DOUBLE
134170: LESSEQUAL
134171: IFTRUE 134175
134173: GO 134207
134175: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
134176: LD_VAR 0 1
134180: PPUSH
134181: LD_VAR 0 2
134185: PPUSH
134186: LD_VAR 0 3
134190: PPUSH
134191: LD_VAR 0 4
134195: PPUSH
134196: LD_VAR 0 5
134200: PPUSH
134201: CALL 122942 0 5
134205: GO 134284
134207: LD_INT 300
134209: DOUBLE
134210: GREATEREQUAL
134211: IFFALSE 134219
134213: LD_INT 399
134215: DOUBLE
134216: LESSEQUAL
134217: IFTRUE 134221
134219: GO 134283
134221: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
134222: LD_VAR 0 1
134226: PPUSH
134227: LD_VAR 0 2
134231: PPUSH
134232: LD_VAR 0 3
134236: PPUSH
134237: LD_VAR 0 4
134241: PPUSH
134242: LD_VAR 0 5
134246: PPUSH
134247: LD_VAR 0 6
134251: PPUSH
134252: LD_VAR 0 7
134256: PPUSH
134257: LD_VAR 0 8
134261: PPUSH
134262: LD_VAR 0 9
134266: PPUSH
134267: LD_VAR 0 10
134271: PPUSH
134272: LD_VAR 0 11
134276: PPUSH
134277: CALL 119275 0 11
134281: GO 134284
134283: POP
// end ;
134284: PPOPN 11
134286: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
134287: LD_VAR 0 1
134291: PPUSH
134292: LD_VAR 0 2
134296: PPUSH
134297: LD_VAR 0 3
134301: PPUSH
134302: LD_VAR 0 4
134306: PPUSH
134307: LD_VAR 0 5
134311: PPUSH
134312: CALL 122678 0 5
// end ; end_of_file
134316: PPOPN 5
134318: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
134319: LD_VAR 0 1
134323: PPUSH
134324: LD_VAR 0 2
134328: PPUSH
134329: LD_VAR 0 3
134333: PPUSH
134334: LD_VAR 0 4
134338: PPUSH
134339: LD_VAR 0 5
134343: PPUSH
134344: LD_VAR 0 6
134348: PPUSH
134349: CALL 106968 0 6
// end ;
134353: PPOPN 6
134355: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
134356: LD_INT 0
134358: PPUSH
// begin if not units then
134359: LD_VAR 0 1
134363: NOT
134364: IFFALSE 134368
// exit ;
134366: GO 134368
// end ;
134368: PPOPN 7
134370: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
134371: CALL 106939 0 0
// end ;
134375: PPOPN 1
134377: END
