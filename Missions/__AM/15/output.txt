// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35134 0 0
// InitMacro ;
  19: CALL 35294 0 0
// InitNature ;
  23: CALL 35002 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11169 0 0
// PrepareRussian ;
  44: CALL 7025 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15084 0 0
// MC_Start ( ) ;
  64: CALL 37459 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 139
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 140
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60208 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60301 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59651 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59466 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60208 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60301 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59466 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59651 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 60081 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 59148 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60208 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60301 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 144
 963: PUSH
 964: LD_EXP 144
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59466 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60208 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60301 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59358 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60619 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59790 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 60081 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 60081 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60413 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59466 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 60032 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65920 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70937 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70937 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70937 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70937 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70937 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65920 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65920 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65920 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65920 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65920 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65920 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65920 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65920 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65920 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65920 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65920 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65920 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65920 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65920 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65920 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65920 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65920 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65920 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65920 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65920 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65920 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65920 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65920 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65920 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65920 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65920 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65920 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65920 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70937 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65920 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65920 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65920 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74383 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 115
4751: PUSH
4752: LD_EXP 115
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70937 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59651 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59514 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60932 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59514 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59514 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60932 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60932 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 134
6051: PUSH
6052: LD_EXP 134
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 134
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7022
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70937 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// if legionDestroyed then
6858: LD_EXP 22
6862: IFFALSE 6866
// exit ;
6864: GO 7022
// for i in tmp do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: LD_VAR 0 3
6875: PUSH
6876: FOR_IN
6877: IFFALSE 7013
// begin if GetLives ( i ) > 250 then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 256
6888: PUSH
6889: LD_INT 250
6891: GREATER
6892: IFFALSE 6984
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6894: LD_INT 81
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 91
6906: PUSH
6907: LD_VAR 0 1
6911: PUSH
6912: LD_INT 10
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PPUSH
6924: CALL_OW 69
6928: NOT
6929: IFFALSE 6948
// ComAgressiveMove ( i , 67 , 110 ) else
6931: LD_VAR 0 1
6935: PPUSH
6936: LD_INT 67
6938: PPUSH
6939: LD_INT 110
6941: PPUSH
6942: CALL_OW 114
6946: GO 6982
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6948: LD_VAR 0 1
6952: PPUSH
6953: LD_INT 81
6955: PUSH
6956: LD_INT 8
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PPUSH
6963: CALL_OW 69
6967: PPUSH
6968: LD_VAR 0 1
6972: PPUSH
6973: CALL_OW 74
6977: PPUSH
6978: CALL_OW 115
// end else
6982: GO 7011
// if IsDead ( i ) then
6984: LD_VAR 0 1
6988: PPUSH
6989: CALL_OW 301
6993: IFFALSE 7011
// tmp := tmp diff i ;
6995: LD_ADDR_VAR 0 3
6999: PUSH
7000: LD_VAR 0 3
7004: PUSH
7005: LD_VAR 0 1
7009: DIFF
7010: ST_TO_ADDR
// end ;
7011: GO 6876
7013: POP
7014: POP
// until not tmp ;
7015: LD_VAR 0 3
7019: NOT
7020: IFFALSE 6851
// end ; end_of_file
7022: PPOPN 3
7024: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7025: LD_INT 0
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
7035: PPUSH
// side := 3 ;
7036: LD_ADDR_VAR 0 6
7040: PUSH
7041: LD_INT 3
7043: ST_TO_ADDR
// uc_side := side ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_VAR 0 6
7053: ST_TO_ADDR
// uc_nation := 3 ;
7054: LD_ADDR_OWVAR 21
7058: PUSH
7059: LD_INT 3
7061: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7062: LD_ADDR_VAR 0 2
7066: PUSH
7067: LD_INT 22
7069: PUSH
7070: LD_VAR 0 6
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PUSH
7079: LD_INT 21
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PPUSH
7093: CALL_OW 69
7097: PUSH
7098: FOR_IN
7099: IFFALSE 7115
// SetBLevel ( i , 10 ) ;
7101: LD_VAR 0 2
7105: PPUSH
7106: LD_INT 10
7108: PPUSH
7109: CALL_OW 241
7113: GO 7098
7115: POP
7116: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7117: LD_ADDR_VAR 0 9
7121: PUSH
7122: LD_INT 22
7124: PUSH
7125: LD_VAR 0 6
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 30
7136: PUSH
7137: LD_INT 34
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: ST_TO_ADDR
// if teleport then
7153: LD_VAR 0 9
7157: IFFALSE 7178
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7159: LD_VAR 0 9
7163: PUSH
7164: LD_INT 1
7166: ARRAY
7167: PPUSH
7168: LD_INT 123
7170: PPUSH
7171: LD_INT 122
7173: PPUSH
7174: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7178: LD_ADDR_EXP 64
7182: PUSH
7183: LD_STRING Platonov
7185: PPUSH
7186: CALL_OW 25
7190: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7191: LD_ADDR_EXP 65
7195: PUSH
7196: LD_STRING Kovalyuk
7198: PPUSH
7199: CALL_OW 25
7203: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7204: LD_ADDR_EXP 67
7208: PUSH
7209: LD_STRING Yakotich
7211: PPUSH
7212: LD_EXP 1
7216: NOT
7217: PPUSH
7218: LD_STRING 09_
7220: PPUSH
7221: CALL 65920 0 3
7225: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7226: LD_ADDR_EXP 66
7230: PUSH
7231: LD_STRING Bystrov
7233: PPUSH
7234: CALL_OW 25
7238: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7239: LD_ADDR_EXP 68
7243: PUSH
7244: LD_STRING Gleb
7246: PPUSH
7247: CALL_OW 25
7251: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7252: LD_STRING 03_Cornel
7254: PPUSH
7255: CALL_OW 28
7259: IFFALSE 7307
// begin Bierezov := NewCharacter ( Mikhail ) ;
7261: LD_ADDR_EXP 69
7265: PUSH
7266: LD_STRING Mikhail
7268: PPUSH
7269: CALL_OW 25
7273: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7274: LD_EXP 69
7278: PPUSH
7279: LD_INT 197
7281: PPUSH
7282: LD_INT 111
7284: PPUSH
7285: LD_INT 9
7287: PPUSH
7288: LD_INT 0
7290: PPUSH
7291: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7295: LD_EXP 69
7299: PPUSH
7300: LD_INT 3
7302: PPUSH
7303: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7307: LD_EXP 64
7311: PPUSH
7312: LD_INT 126
7314: PPUSH
7315: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7319: LD_EXP 65
7323: PPUSH
7324: LD_INT 134
7326: PPUSH
7327: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7331: LD_EXP 67
7335: PPUSH
7336: LD_INT 197
7338: PPUSH
7339: LD_INT 111
7341: PPUSH
7342: LD_INT 9
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7352: LD_EXP 66
7356: PPUSH
7357: LD_INT 197
7359: PPUSH
7360: LD_INT 111
7362: PPUSH
7363: LD_INT 9
7365: PPUSH
7366: LD_INT 0
7368: PPUSH
7369: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7373: LD_EXP 68
7377: PPUSH
7378: LD_INT 197
7380: PPUSH
7381: LD_INT 111
7383: PPUSH
7384: LD_INT 9
7386: PPUSH
7387: LD_INT 0
7389: PPUSH
7390: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7394: LD_ADDR_VAR 0 5
7398: PUSH
7399: LD_INT 126
7401: PPUSH
7402: LD_INT 4
7404: PPUSH
7405: LD_STRING zhukov
7407: PPUSH
7408: LD_INT 9
7410: PUSH
7411: LD_INT 10
7413: PUSH
7414: LD_INT 10
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: LD_INT 90000
7434: PUSH
7435: LD_INT 1000
7437: PUSH
7438: LD_INT 300
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PPUSH
7446: LD_INT 18
7448: PUSH
7449: LD_INT 8
7451: PUSH
7452: LD_INT 13
7454: PUSH
7455: LD_INT 8
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL 74383 0 6
7468: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7469: LD_ADDR_VAR 0 4
7473: PUSH
7474: LD_INT 267
7476: PPUSH
7477: CALL_OW 274
7481: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 5000
7492: PPUSH
7493: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7497: LD_VAR 0 4
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: LD_INT 200
7507: PPUSH
7508: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7512: LD_VAR 0 4
7516: PPUSH
7517: LD_INT 3
7519: PPUSH
7520: LD_INT 200
7522: PPUSH
7523: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7527: LD_ADDR_EXP 115
7531: PUSH
7532: LD_EXP 115
7536: PPUSH
7537: LD_INT 2
7539: PPUSH
7540: LD_VAR 0 5
7544: PUSH
7545: LD_INT 22
7547: PUSH
7548: LD_VAR 0 6
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 3
7559: PUSH
7560: LD_INT 21
7562: PUSH
7563: LD_INT 2
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PPUSH
7578: CALL_OW 69
7582: UNION
7583: PUSH
7584: LD_EXP 64
7588: DIFF
7589: PPUSH
7590: CALL_OW 1
7594: ST_TO_ADDR
// behemoths := [ ] ;
7595: LD_ADDR_EXP 72
7599: PUSH
7600: EMPTY
7601: ST_TO_ADDR
// behemothBuilders := [ ] ;
7602: LD_ADDR_EXP 73
7606: PUSH
7607: EMPTY
7608: ST_TO_ADDR
// if Kovalyuk then
7609: LD_EXP 65
7613: IFFALSE 7635
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7615: LD_ADDR_EXP 73
7619: PUSH
7620: LD_EXP 73
7624: PPUSH
7625: LD_EXP 65
7629: PPUSH
7630: CALL 103321 0 2
7634: ST_TO_ADDR
// j := 3 ;
7635: LD_ADDR_VAR 0 3
7639: PUSH
7640: LD_INT 3
7642: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7643: LD_ADDR_VAR 0 2
7647: PUSH
7648: LD_INT 22
7650: PUSH
7651: LD_INT 3
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 3
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: PUSH
7677: LD_EXP 65
7681: DIFF
7682: PUSH
7683: FOR_IN
7684: IFFALSE 7734
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7686: LD_ADDR_EXP 73
7690: PUSH
7691: LD_EXP 73
7695: PPUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: CALL 103321 0 2
7705: ST_TO_ADDR
// j := j - 1 ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: MINUS
7719: ST_TO_ADDR
// if j = 0 then
7720: LD_VAR 0 3
7724: PUSH
7725: LD_INT 0
7727: EQUAL
7728: IFFALSE 7732
// break ;
7730: GO 7734
// end ;
7732: GO 7683
7734: POP
7735: POP
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7741: LD_INT 0
7743: PPUSH
7744: PPUSH
7745: PPUSH
7746: PPUSH
7747: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7748: LD_ADDR_VAR 0 4
7752: PUSH
7753: LD_INT 209
7755: PUSH
7756: LD_INT 149
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 219
7765: PUSH
7766: LD_INT 154
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: LD_INT 223
7775: PUSH
7776: LD_INT 149
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: LD_INT 232
7785: PUSH
7786: LD_INT 155
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: ST_TO_ADDR
// if not behemothBuilders then
7799: LD_EXP 73
7803: NOT
7804: IFFALSE 7808
// exit ;
7806: GO 7912
// j := 1 ;
7808: LD_ADDR_VAR 0 3
7812: PUSH
7813: LD_INT 1
7815: ST_TO_ADDR
// for i in behemothBuilders do
7816: LD_ADDR_VAR 0 2
7820: PUSH
7821: LD_EXP 73
7825: PUSH
7826: FOR_IN
7827: IFFALSE 7910
// begin if IsInUnit ( i ) then
7829: LD_VAR 0 2
7833: PPUSH
7834: CALL_OW 310
7838: IFFALSE 7849
// ComExitBuilding ( i ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7849: LD_VAR 0 2
7853: PPUSH
7854: LD_INT 37
7856: PPUSH
7857: LD_VAR 0 4
7861: PUSH
7862: LD_VAR 0 3
7866: ARRAY
7867: PUSH
7868: LD_INT 1
7870: ARRAY
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_VAR 0 3
7881: ARRAY
7882: PUSH
7883: LD_INT 2
7885: ARRAY
7886: PPUSH
7887: LD_INT 0
7889: PPUSH
7890: CALL_OW 230
// j := j + 1 ;
7894: LD_ADDR_VAR 0 3
7898: PUSH
7899: LD_VAR 0 3
7903: PUSH
7904: LD_INT 1
7906: PLUS
7907: ST_TO_ADDR
// end ;
7908: GO 7826
7910: POP
7911: POP
// end ;
7912: LD_VAR 0 1
7916: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7917: LD_INT 24
7919: PPUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 37
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 70
7934: IFFALSE 7947
7936: GO 7938
7938: DISABLE
// behemothUnderConstruct := true ;
7939: LD_ADDR_EXP 26
7943: PUSH
7944: LD_INT 1
7946: ST_TO_ADDR
7947: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7948: LD_INT 3
7950: PPUSH
7951: CALL 103382 0 1
7955: PUSH
7956: LD_INT 22
7958: PUSH
7959: LD_INT 3
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PUSH
7966: LD_INT 30
7968: PUSH
7969: LD_INT 37
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PPUSH
7980: CALL_OW 69
7984: NOT
7985: AND
7986: IFFALSE 8172
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: PPUSH
8004: CALL 103382 0 1
8008: ST_TO_ADDR
// for i in tmp do
8009: LD_ADDR_VAR 0 1
8013: PUSH
8014: LD_VAR 0 2
8018: PUSH
8019: FOR_IN
8020: IFFALSE 8170
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8022: LD_VAR 0 1
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL_OW 308
8034: PUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: CALL_OW 110
8044: PUSH
8045: LD_INT 2
8047: EQUAL
8048: NOT
8049: AND
8050: IFFALSE 8064
// SetTag ( i , 2 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 2
8059: PPUSH
8060: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8064: LD_INT 81
8066: PUSH
8067: LD_INT 3
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 91
8076: PUSH
8077: LD_VAR 0 1
8081: PUSH
8082: LD_INT 12
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: LIST
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PPUSH
8094: CALL_OW 69
8098: NOT
8099: PUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 110
8109: PUSH
8110: LD_INT 2
8112: EQUAL
8113: NOT
8114: AND
8115: IFFALSE 8134
// ComAgressiveMove ( i , 64 , 93 ) else
8117: LD_VAR 0 1
8121: PPUSH
8122: LD_INT 64
8124: PPUSH
8125: LD_INT 93
8127: PPUSH
8128: CALL_OW 114
8132: GO 8168
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8134: LD_VAR 0 1
8138: PPUSH
8139: LD_INT 81
8141: PUSH
8142: LD_INT 3
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 69
8153: PPUSH
8154: LD_VAR 0 1
8158: PPUSH
8159: CALL_OW 74
8163: PPUSH
8164: CALL_OW 115
// end ;
8168: GO 8019
8170: POP
8171: POP
// end ;
8172: PPOPN 2
8174: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8175: LD_INT 0
8177: PPUSH
8178: PPUSH
8179: PPUSH
// result := [ ] ;
8180: LD_ADDR_VAR 0 2
8184: PUSH
8185: EMPTY
8186: ST_TO_ADDR
// uc_side := 6 ;
8187: LD_ADDR_OWVAR 20
8191: PUSH
8192: LD_INT 6
8194: ST_TO_ADDR
// uc_nation := 3 ;
8195: LD_ADDR_OWVAR 21
8199: PUSH
8200: LD_INT 3
8202: ST_TO_ADDR
// case strength of 1 :
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: DOUBLE
8211: EQUAL
8212: IFTRUE 8216
8214: GO 8358
8216: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8217: LD_ADDR_VAR 0 3
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_INT 4
8229: PUSH
8230: LD_INT 5
8232: PUSH
8233: LD_INT 6
8235: PUSH
8236: LD_INT 7
8238: PUSH
8239: EMPTY
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: PUSH
8245: LD_OWVAR 67
8249: ARRAY
8250: PUSH
8251: FOR_TO
8252: IFFALSE 8354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8254: LD_INT 22
8256: PUSH
8257: LD_INT 24
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: LD_VAR 0 3
8268: PUSH
8269: LD_INT 2
8271: MOD
8272: PUSH
8273: LD_INT 1
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: LD_INT 1
8280: PUSH
8281: LD_INT 3
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: LD_INT 2
8293: PPUSH
8294: CALL_OW 12
8298: ARRAY
8299: PPUSH
8300: LD_INT 3
8302: PPUSH
8303: LD_INT 43
8305: PUSH
8306: LD_INT 44
8308: PUSH
8309: LD_INT 45
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_INT 3
8322: PPUSH
8323: CALL_OW 12
8327: ARRAY
8328: PPUSH
8329: LD_INT 80
8331: PPUSH
8332: CALL 70937 0 5
// result := result union CreateVehicle ;
8336: LD_ADDR_VAR 0 2
8340: PUSH
8341: LD_VAR 0 2
8345: PUSH
8346: CALL_OW 45
8350: UNION
8351: ST_TO_ADDR
// end ;
8352: GO 8251
8354: POP
8355: POP
// end ; 2 :
8356: GO 9321
8358: LD_INT 2
8360: DOUBLE
8361: EQUAL
8362: IFTRUE 8366
8364: GO 8526
8366: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: DOUBLE
8373: LD_INT 1
8375: DEC
8376: ST_TO_ADDR
8377: LD_INT 5
8379: PUSH
8380: LD_INT 6
8382: PUSH
8383: LD_INT 7
8385: PUSH
8386: LD_INT 8
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: LD_OWVAR 67
8399: ARRAY
8400: PUSH
8401: FOR_TO
8402: IFFALSE 8522
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8404: LD_INT 22
8406: PUSH
8407: LD_INT 24
8409: PUSH
8410: LD_INT 24
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: LIST
8417: PUSH
8418: LD_VAR 0 3
8422: PUSH
8423: LD_INT 3
8425: MOD
8426: PUSH
8427: LD_INT 1
8429: PLUS
8430: ARRAY
8431: PPUSH
8432: LD_INT 1
8434: PUSH
8435: LD_INT 3
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: LD_INT 1
8444: PPUSH
8445: LD_INT 2
8447: PPUSH
8448: CALL_OW 12
8452: ARRAY
8453: PPUSH
8454: LD_INT 3
8456: PPUSH
8457: LD_INT 43
8459: PUSH
8460: LD_INT 44
8462: PUSH
8463: LD_INT 45
8465: PUSH
8466: LD_INT 44
8468: PUSH
8469: LD_INT 46
8471: PUSH
8472: LD_INT 46
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PUSH
8483: LD_VAR 0 3
8487: PUSH
8488: LD_INT 6
8490: MOD
8491: PUSH
8492: LD_INT 1
8494: PLUS
8495: ARRAY
8496: PPUSH
8497: LD_INT 80
8499: PPUSH
8500: CALL 70937 0 5
// result := result union CreateVehicle ;
8504: LD_ADDR_VAR 0 2
8508: PUSH
8509: LD_VAR 0 2
8513: PUSH
8514: CALL_OW 45
8518: UNION
8519: ST_TO_ADDR
// end ;
8520: GO 8401
8522: POP
8523: POP
// end ; 3 :
8524: GO 9321
8526: LD_INT 3
8528: DOUBLE
8529: EQUAL
8530: IFTRUE 8534
8532: GO 8694
8534: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 5
8547: PUSH
8548: LD_INT 7
8550: PUSH
8551: LD_INT 8
8553: PUSH
8554: LD_INT 9
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: PUSH
8563: LD_OWVAR 67
8567: ARRAY
8568: PUSH
8569: FOR_TO
8570: IFFALSE 8690
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8572: LD_INT 22
8574: PUSH
8575: LD_INT 24
8577: PUSH
8578: LD_INT 24
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 3
8593: MOD
8594: PUSH
8595: LD_INT 1
8597: PLUS
8598: ARRAY
8599: PPUSH
8600: LD_INT 1
8602: PUSH
8603: LD_INT 3
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 2
8615: PPUSH
8616: CALL_OW 12
8620: ARRAY
8621: PPUSH
8622: LD_INT 3
8624: PPUSH
8625: LD_INT 43
8627: PUSH
8628: LD_INT 47
8630: PUSH
8631: LD_INT 45
8633: PUSH
8634: LD_INT 45
8636: PUSH
8637: LD_INT 46
8639: PUSH
8640: LD_INT 46
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: PUSH
8651: LD_VAR 0 3
8655: PUSH
8656: LD_INT 6
8658: MOD
8659: PUSH
8660: LD_INT 1
8662: PLUS
8663: ARRAY
8664: PPUSH
8665: LD_INT 80
8667: PPUSH
8668: CALL 70937 0 5
// result := result union CreateVehicle ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_VAR 0 2
8681: PUSH
8682: CALL_OW 45
8686: UNION
8687: ST_TO_ADDR
// end ;
8688: GO 8569
8690: POP
8691: POP
// end ; 4 :
8692: GO 9321
8694: LD_INT 4
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 9320
8702: POP
// begin uc_nation := 3 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 3
8710: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8711: LD_ADDR_VAR 0 3
8715: PUSH
8716: DOUBLE
8717: LD_INT 1
8719: DEC
8720: ST_TO_ADDR
8721: LD_INT 6
8723: PUSH
8724: LD_INT 8
8726: PUSH
8727: LD_INT 9
8729: PUSH
8730: LD_INT 10
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: LD_OWVAR 67
8743: ARRAY
8744: PUSH
8745: FOR_TO
8746: IFFALSE 8866
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8748: LD_INT 22
8750: PUSH
8751: LD_INT 24
8753: PUSH
8754: LD_INT 24
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: LIST
8761: PUSH
8762: LD_VAR 0 3
8766: PUSH
8767: LD_INT 3
8769: MOD
8770: PUSH
8771: LD_INT 1
8773: PLUS
8774: ARRAY
8775: PPUSH
8776: LD_INT 1
8778: PUSH
8779: LD_INT 3
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: PUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 2
8791: PPUSH
8792: CALL_OW 12
8796: ARRAY
8797: PPUSH
8798: LD_INT 3
8800: PPUSH
8801: LD_INT 45
8803: PUSH
8804: LD_INT 47
8806: PUSH
8807: LD_INT 47
8809: PUSH
8810: LD_INT 45
8812: PUSH
8813: LD_INT 46
8815: PUSH
8816: LD_INT 46
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_VAR 0 3
8831: PUSH
8832: LD_INT 6
8834: MOD
8835: PUSH
8836: LD_INT 1
8838: PLUS
8839: ARRAY
8840: PPUSH
8841: LD_INT 80
8843: PPUSH
8844: CALL 70937 0 5
// result := result union CreateVehicle ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_VAR 0 2
8857: PUSH
8858: CALL_OW 45
8862: UNION
8863: ST_TO_ADDR
// end ;
8864: GO 8745
8866: POP
8867: POP
// if not KappaStatus then
8868: LD_EXP 2
8872: NOT
8873: IFFALSE 9108
// begin uc_nation := 1 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// for i = 1 to 3 do
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_INT 3
8895: PUSH
8896: FOR_TO
8897: IFFALSE 9033
// begin j := rand ( 0 , 1 ) ;
8899: LD_ADDR_VAR 0 4
8903: PUSH
8904: LD_INT 0
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 12
8914: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8915: LD_INT 3
8917: PUSH
8918: LD_INT 5
8920: PUSH
8921: LD_INT 5
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: CALL_OW 12
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_INT 9
8978: PUSH
8979: LD_INT 7
8981: PUSH
8982: LD_INT 6
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PUSH
8990: LD_VAR 0 4
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: PLUS
9006: ARRAY
9007: PPUSH
9008: LD_INT 85
9010: PPUSH
9011: CALL 70937 0 5
// result := result union CreateVehicle ;
9015: LD_ADDR_VAR 0 2
9019: PUSH
9020: LD_VAR 0 2
9024: PUSH
9025: CALL_OW 45
9029: UNION
9030: ST_TO_ADDR
// end ;
9031: GO 8896
9033: POP
9034: POP
// if vsevolodFirstAttack then
9035: LD_EXP 24
9039: IFFALSE 9106
// begin vsevolodFirstAttack := false ;
9041: LD_ADDR_EXP 24
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9049: LD_INT 5
9051: PPUSH
9052: LD_INT 3
9054: PPUSH
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 6
9060: PPUSH
9061: LD_INT 100
9063: PPUSH
9064: CALL 70937 0 5
// sewiVeh := CreateVehicle ;
9068: LD_ADDR_EXP 71
9072: PUSH
9073: CALL_OW 45
9077: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9078: LD_EXP 71
9082: PPUSH
9083: LD_INT 1
9085: PPUSH
9086: CALL_OW 242
// result := result union sewiVeh ;
9090: LD_ADDR_VAR 0 2
9094: PUSH
9095: LD_VAR 0 2
9099: PUSH
9100: LD_EXP 71
9104: UNION
9105: ST_TO_ADDR
// end ; end else
9106: GO 9318
// if vsevolodFirstAttack then
9108: LD_EXP 24
9112: IFFALSE 9318
// begin vsevolodFirstAttack := false ;
9114: LD_ADDR_EXP 24
9118: PUSH
9119: LD_INT 0
9121: ST_TO_ADDR
// uc_nation := 3 ;
9122: LD_ADDR_OWVAR 21
9126: PUSH
9127: LD_INT 3
9129: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9130: LD_ADDR_VAR 0 3
9134: PUSH
9135: DOUBLE
9136: LD_INT 1
9138: DEC
9139: ST_TO_ADDR
9140: LD_INT 2
9142: PUSH
9143: LD_OWVAR 67
9147: PLUS
9148: PUSH
9149: FOR_TO
9150: IFFALSE 9258
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9152: LD_INT 22
9154: PUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 24
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: PUSH
9166: LD_VAR 0 3
9170: PUSH
9171: LD_INT 3
9173: MOD
9174: PUSH
9175: LD_INT 1
9177: PLUS
9178: ARRAY
9179: PPUSH
9180: LD_INT 1
9182: PUSH
9183: LD_INT 3
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: LD_INT 1
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 12
9200: ARRAY
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 45
9207: PUSH
9208: LD_INT 47
9210: PUSH
9211: LD_INT 47
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: LIST
9218: PUSH
9219: LD_VAR 0 3
9223: PUSH
9224: LD_INT 3
9226: MOD
9227: PUSH
9228: LD_INT 1
9230: PLUS
9231: ARRAY
9232: PPUSH
9233: LD_INT 80
9235: PPUSH
9236: CALL 70937 0 5
// result := result union CreateVehicle ;
9240: LD_ADDR_VAR 0 2
9244: PUSH
9245: LD_VAR 0 2
9249: PUSH
9250: CALL_OW 45
9254: UNION
9255: ST_TO_ADDR
// end ;
9256: GO 9149
9258: POP
9259: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9260: LD_INT 24
9262: PPUSH
9263: LD_INT 3
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: LD_INT 47
9271: PPUSH
9272: LD_INT 100
9274: PPUSH
9275: CALL 70937 0 5
// sewiVeh := CreateVehicle ;
9279: LD_ADDR_EXP 71
9283: PUSH
9284: CALL_OW 45
9288: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9289: LD_EXP 71
9293: PPUSH
9294: LD_INT 6
9296: NEG
9297: PPUSH
9298: CALL_OW 242
// result := result union sewiVeh ;
9302: LD_ADDR_VAR 0 2
9306: PUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_EXP 71
9316: UNION
9317: ST_TO_ADDR
// end ; end ; end ;
9318: GO 9321
9320: POP
// end ;
9321: LD_VAR 0 2
9325: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9326: LD_EXP 16
9330: IFFALSE 10175
9332: GO 9334
9334: DISABLE
9335: LD_INT 0
9337: PPUSH
9338: PPUSH
9339: PPUSH
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9343: LD_ADDR_VAR 0 4
9347: PUSH
9348: LD_INT 11
9350: PUSH
9351: LD_INT 12
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_INT 11550
9365: PUSH
9366: LD_INT 10150
9368: PUSH
9369: LD_INT 9800
9371: PUSH
9372: LD_INT 9450
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: PUSH
9381: LD_OWVAR 67
9385: ARRAY
9386: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9387: LD_ADDR_VAR 0 6
9391: PUSH
9392: LD_INT 70
9394: PUSH
9395: LD_INT 118
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 78
9404: PUSH
9405: LD_INT 31
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// repeat if missionStage = 2 then
9416: LD_EXP 15
9420: PUSH
9421: LD_INT 2
9423: EQUAL
9424: IFFALSE 9435
// wait ( 1 1$30 ) else
9426: LD_INT 3150
9428: PPUSH
9429: CALL_OW 67
9433: GO 9444
// wait ( time ) ;
9435: LD_VAR 0 3
9439: PPUSH
9440: CALL_OW 67
// if missionStage = 6 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 6
9451: EQUAL
9452: IFFALSE 9480
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9454: LD_INT 51
9456: PPUSH
9457: LD_INT 6
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9467: LD_INT 57
9469: PPUSH
9470: LD_INT 6
9472: PPUSH
9473: LD_INT 2
9475: PPUSH
9476: CALL_OW 322
// end ; if missionStage = 8 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 8
9487: EQUAL
9488: IFFALSE 9516
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9490: LD_INT 52
9492: PPUSH
9493: LD_INT 6
9495: PPUSH
9496: LD_INT 2
9498: PPUSH
9499: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9503: LD_INT 58
9505: PPUSH
9506: LD_INT 6
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9516: LD_EXP 15
9520: PUSH
9521: LD_INT 10
9523: EQUAL
9524: PUSH
9525: LD_OWVAR 67
9529: PUSH
9530: LD_INT 1
9532: GREATER
9533: AND
9534: IFFALSE 9562
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9536: LD_INT 53
9538: PPUSH
9539: LD_INT 6
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9549: LD_INT 59
9551: PPUSH
9552: LD_INT 6
9554: PPUSH
9555: LD_INT 2
9557: PPUSH
9558: CALL_OW 322
// end ; if activeAttacks then
9562: LD_EXP 16
9566: IFFALSE 10169
// begin if missionStage = 2 then
9568: LD_EXP 15
9572: PUSH
9573: LD_INT 2
9575: EQUAL
9576: IFFALSE 9586
// strength := 1 ;
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_INT 1
9585: ST_TO_ADDR
// if missionStage > 2 then
9586: LD_EXP 15
9590: PUSH
9591: LD_INT 2
9593: GREATER
9594: IFFALSE 9604
// strength := 2 ;
9596: LD_ADDR_VAR 0 5
9600: PUSH
9601: LD_INT 2
9603: ST_TO_ADDR
// if missionStage > 6 then
9604: LD_EXP 15
9608: PUSH
9609: LD_INT 6
9611: GREATER
9612: IFFALSE 9622
// strength := 3 ;
9614: LD_ADDR_VAR 0 5
9618: PUSH
9619: LD_INT 3
9621: ST_TO_ADDR
// if missionStage > 10 then
9622: LD_EXP 15
9626: PUSH
9627: LD_INT 10
9629: GREATER
9630: IFFALSE 9640
// strength := 4 ;
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: LD_INT 4
9639: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9640: LD_ADDR_VAR 0 2
9644: PUSH
9645: LD_VAR 0 5
9649: PPUSH
9650: CALL 8175 0 1
9654: ST_TO_ADDR
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9849
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9668: LD_VAR 0 1
9672: PPUSH
9673: LD_VAR 0 4
9677: PUSH
9678: LD_INT 1
9680: PPUSH
9681: LD_INT 2
9683: PPUSH
9684: CALL_OW 12
9688: ARRAY
9689: PPUSH
9690: LD_INT 0
9692: PPUSH
9693: CALL_OW 49
// if i = sewiVeh then
9697: LD_VAR 0 1
9701: PUSH
9702: LD_EXP 71
9706: EQUAL
9707: IFFALSE 9744
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9709: LD_ADDR_EXP 70
9713: PUSH
9714: LD_STRING Vsevolod
9716: PPUSH
9717: LD_INT 0
9719: PPUSH
9720: LD_STRING 
9722: PPUSH
9723: CALL 65920 0 3
9727: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9728: LD_EXP 70
9732: PPUSH
9733: LD_VAR 0 1
9737: PPUSH
9738: CALL_OW 52
// end else
9742: GO 9825
// if GetControl ( i ) = control_manual then
9744: LD_VAR 0 1
9748: PPUSH
9749: CALL_OW 263
9753: PUSH
9754: LD_INT 1
9756: EQUAL
9757: IFFALSE 9825
// begin uc_side := 6 ;
9759: LD_ADDR_OWVAR 20
9763: PUSH
9764: LD_INT 6
9766: ST_TO_ADDR
// uc_nation := 3 ;
9767: LD_ADDR_OWVAR 21
9771: PUSH
9772: LD_INT 3
9774: ST_TO_ADDR
// hc_gallery :=  ;
9775: LD_ADDR_OWVAR 33
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// hc_name :=  ;
9783: LD_ADDR_OWVAR 26
9787: PUSH
9788: LD_STRING 
9790: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9791: LD_INT 0
9793: PPUSH
9794: LD_INT 3
9796: PPUSH
9797: LD_INT 10
9799: PPUSH
9800: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9804: CALL_OW 44
9808: PPUSH
9809: LD_VAR 0 1
9813: PPUSH
9814: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9818: LD_INT 10
9820: PPUSH
9821: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_INT 111
9832: PPUSH
9833: LD_INT 197
9835: PPUSH
9836: CALL_OW 111
// wait ( 0 0$2 ) ;
9840: LD_INT 70
9842: PPUSH
9843: CALL_OW 67
// end ;
9847: GO 9665
9849: POP
9850: POP
// repeat wait ( 0 0$1 ) ;
9851: LD_INT 35
9853: PPUSH
9854: CALL_OW 67
// for i in tmp do
9858: LD_ADDR_VAR 0 1
9862: PUSH
9863: LD_VAR 0 2
9867: PUSH
9868: FOR_IN
9869: IFFALSE 10150
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9871: LD_INT 81
9873: PUSH
9874: LD_INT 6
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: LD_INT 91
9883: PUSH
9884: LD_VAR 0 1
9888: PUSH
9889: LD_INT 12
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL_OW 69
9905: IFFALSE 9963
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PUSH
9922: LD_INT 91
9924: PUSH
9925: LD_VAR 0 1
9929: PUSH
9930: LD_INT 12
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 69
9946: PPUSH
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL_OW 74
9956: PPUSH
9957: CALL_OW 115
9961: GO 10148
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9963: LD_INT 9
9965: PPUSH
9966: LD_INT 81
9968: PUSH
9969: LD_INT 6
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PPUSH
9976: CALL_OW 70
9980: IFFALSE 10114
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ARRAY
9995: PUSH
9996: LD_INT 1
9998: ARRAY
9999: PPUSH
10000: LD_VAR 0 6
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PUSH
10009: LD_INT 2
10011: ARRAY
10012: PPUSH
10013: CALL_OW 297
10017: PUSH
10018: LD_INT 10
10020: GREATER
10021: PUSH
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_INT 9
10029: PPUSH
10030: CALL_OW 308
10034: NOT
10035: AND
10036: IFFALSE 10075
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10038: LD_VAR 0 1
10042: PPUSH
10043: LD_VAR 0 6
10047: PUSH
10048: LD_INT 1
10050: ARRAY
10051: PUSH
10052: LD_INT 1
10054: ARRAY
10055: PPUSH
10056: LD_VAR 0 6
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PUSH
10065: LD_INT 2
10067: ARRAY
10068: PPUSH
10069: CALL_OW 114
10073: GO 10112
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10075: LD_VAR 0 1
10079: PPUSH
10080: LD_INT 9
10082: PPUSH
10083: LD_INT 81
10085: PUSH
10086: LD_INT 6
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PPUSH
10093: CALL_OW 70
10097: PPUSH
10098: LD_VAR 0 1
10102: PPUSH
10103: CALL_OW 74
10107: PPUSH
10108: CALL_OW 115
// end else
10112: GO 10148
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: LD_INT 81
10121: PUSH
10122: LD_INT 6
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PPUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: CALL_OW 74
10143: PPUSH
10144: CALL_OW 115
// end ;
10148: GO 9868
10150: POP
10151: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10152: LD_INT 22
10154: PUSH
10155: LD_INT 6
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: NOT
10167: IFFALSE 9851
// end ; until russianDestroyed ;
10169: LD_EXP 21
10173: IFFALSE 9416
// end ;
10175: PPOPN 6
10177: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10178: LD_EXP 21
10182: NOT
10183: PUSH
10184: LD_EXP 15
10188: PUSH
10189: LD_INT 6
10191: GREATEREQUAL
10192: AND
10193: PUSH
10194: LD_INT 2
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: CALL 60932 0 2
10204: NOT
10205: AND
10206: IFFALSE 11166
10208: GO 10210
10210: DISABLE
10211: LD_INT 0
10213: PPUSH
10214: PPUSH
10215: PPUSH
10216: PPUSH
// begin enable ;
10217: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10218: LD_INT 22
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 30
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: NOT
10247: IFFALSE 10251
// exit ;
10249: GO 11166
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10251: LD_ADDR_VAR 0 4
10255: PUSH
10256: LD_INT 22
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: LD_INT 30
10268: PUSH
10269: LD_INT 34
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PPUSH
10280: CALL_OW 69
10284: ST_TO_ADDR
// if Prob ( 40 ) then
10285: LD_INT 40
10287: PPUSH
10288: CALL_OW 13
10292: IFFALSE 10419
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10294: LD_INT 2
10296: PPUSH
10297: LD_INT 22
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 49
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 22
10317: PUSH
10318: LD_INT 3
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 49
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_INT 3
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 49
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 24
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 46
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PUSH
10369: LD_INT 24
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 46
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 24
10389: PUSH
10390: LD_INT 3
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 46
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL 59514 0 2
// end else
10417: GO 10542
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10419: LD_INT 2
10421: PPUSH
10422: LD_INT 24
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 3
10430: PUSH
10431: LD_INT 47
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 24
10442: PUSH
10443: LD_INT 3
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 47
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: PUSH
10458: LD_INT 24
10460: PUSH
10461: LD_INT 3
10463: PUSH
10464: LD_INT 3
10466: PUSH
10467: LD_INT 47
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: PUSH
10476: LD_INT 24
10478: PUSH
10479: LD_INT 3
10481: PUSH
10482: LD_INT 3
10484: PUSH
10485: LD_INT 46
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 24
10496: PUSH
10497: LD_INT 3
10499: PUSH
10500: LD_INT 3
10502: PUSH
10503: LD_INT 46
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 24
10514: PUSH
10515: LD_INT 3
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: LD_INT 46
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL 59514 0 2
// end ; if Difficulty > 1 then
10542: LD_OWVAR 67
10546: PUSH
10547: LD_INT 1
10549: GREATER
10550: IFFALSE 10580
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10552: LD_INT 2
10554: PPUSH
10555: LD_INT 24
10557: PUSH
10558: LD_INT 3
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: LD_INT 47
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: PPUSH
10576: CALL 59514 0 2
// repeat wait ( 0 0$1 ) ;
10580: LD_INT 35
10582: PPUSH
10583: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10587: LD_INT 2
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL 60932 0 2
10597: PUSH
10598: LD_INT 6
10600: PUSH
10601: LD_INT 7
10603: PUSH
10604: LD_INT 7
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_OWVAR 67
10620: ARRAY
10621: GREATEREQUAL
10622: IFFALSE 10580
// wait ( 0 0$30 ) ;
10624: LD_INT 1050
10626: PPUSH
10627: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: LD_INT 2
10638: PPUSH
10639: LD_INT 1
10641: PPUSH
10642: CALL 60932 0 2
10646: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10647: LD_ADDR_EXP 134
10651: PUSH
10652: LD_EXP 134
10656: PPUSH
10657: LD_INT 2
10659: PPUSH
10660: LD_EXP 134
10664: PUSH
10665: LD_INT 2
10667: ARRAY
10668: PUSH
10669: LD_VAR 0 2
10673: DIFF
10674: PPUSH
10675: CALL_OW 1
10679: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: LD_INT 0
10687: PPUSH
10688: LD_INT 1
10690: PPUSH
10691: CALL_OW 12
10695: ST_TO_ADDR
// if target then
10696: LD_VAR 0 3
10700: IFFALSE 10828
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10702: LD_ADDR_VAR 0 2
10706: PUSH
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_INT 24
10714: PUSH
10715: LD_INT 250
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PPUSH
10722: CALL_OW 72
10726: ST_TO_ADDR
// for i in tmp do
10727: LD_ADDR_VAR 0 1
10731: PUSH
10732: LD_VAR 0 2
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10778
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_INT 139
10747: PPUSH
10748: LD_INT 89
10750: PPUSH
10751: CALL_OW 297
10755: PUSH
10756: LD_INT 9
10758: GREATER
10759: IFFALSE 10776
// ComMoveXY ( i , 139 , 89 ) ;
10761: LD_VAR 0 1
10765: PPUSH
10766: LD_INT 139
10768: PPUSH
10769: LD_INT 89
10771: PPUSH
10772: CALL_OW 111
10776: GO 10737
10778: POP
10779: POP
// wait ( 0 0$1 ) ;
10780: LD_INT 35
10782: PPUSH
10783: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10787: LD_VAR 0 2
10791: PPUSH
10792: LD_INT 92
10794: PUSH
10795: LD_INT 139
10797: PUSH
10798: LD_INT 89
10800: PUSH
10801: LD_INT 9
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PPUSH
10810: CALL_OW 72
10814: PUSH
10815: LD_VAR 0 2
10819: PUSH
10820: LD_INT 1
10822: MINUS
10823: GREATEREQUAL
10824: IFFALSE 10702
// end else
10826: GO 10970
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_VAR 0 4
10837: PUSH
10838: LD_INT 1
10840: ARRAY
10841: PPUSH
10842: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_VAR 0 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 250
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 72
10870: ST_TO_ADDR
// for i in tmp do
10871: LD_ADDR_VAR 0 1
10875: PUSH
10876: LD_VAR 0 2
10880: PUSH
10881: FOR_IN
10882: IFFALSE 10922
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10884: LD_VAR 0 1
10888: PPUSH
10889: LD_INT 124
10891: PPUSH
10892: LD_INT 139
10894: PPUSH
10895: CALL_OW 297
10899: PUSH
10900: LD_INT 9
10902: GREATER
10903: IFFALSE 10920
// ComMoveXY ( i , 124 , 139 ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: LD_INT 124
10912: PPUSH
10913: LD_INT 139
10915: PPUSH
10916: CALL_OW 111
10920: GO 10881
10922: POP
10923: POP
// wait ( 0 0$1 ) ;
10924: LD_INT 35
10926: PPUSH
10927: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10931: LD_VAR 0 2
10935: PPUSH
10936: LD_INT 92
10938: PUSH
10939: LD_INT 124
10941: PUSH
10942: LD_INT 139
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: PPUSH
10954: CALL_OW 72
10958: PUSH
10959: LD_VAR 0 2
10963: PUSH
10964: LD_INT 1
10966: MINUS
10967: GREATEREQUAL
10968: IFFALSE 10846
// end ; repeat wait ( 0 0$1 ) ;
10970: LD_INT 35
10972: PPUSH
10973: CALL_OW 67
// for i in tmp do
10977: LD_ADDR_VAR 0 1
10981: PUSH
10982: LD_VAR 0 2
10986: PUSH
10987: FOR_IN
10988: IFFALSE 11157
// begin if GetLives ( i ) > 251 then
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 256
10999: PUSH
11000: LD_INT 251
11002: GREATER
11003: IFFALSE 11128
// begin if GetWeapon ( i ) = ru_time_lapser then
11005: LD_VAR 0 1
11009: PPUSH
11010: CALL_OW 264
11014: PUSH
11015: LD_INT 49
11017: EQUAL
11018: IFFALSE 11074
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11020: LD_VAR 0 1
11024: PPUSH
11025: LD_INT 2
11027: PUSH
11028: LD_INT 22
11030: PUSH
11031: LD_INT 1
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 8
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: PPUSH
11058: LD_VAR 0 1
11062: PPUSH
11063: CALL_OW 74
11067: PPUSH
11068: CALL_OW 112
11072: GO 11126
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11074: LD_VAR 0 1
11078: PPUSH
11079: LD_INT 2
11081: PUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 1
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 8
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: PPUSH
11107: CALL_OW 69
11111: PPUSH
11112: LD_VAR 0 1
11116: PPUSH
11117: CALL_OW 74
11121: PPUSH
11122: CALL_OW 115
// end else
11126: GO 11155
// if IsDead ( i ) then
11128: LD_VAR 0 1
11132: PPUSH
11133: CALL_OW 301
11137: IFFALSE 11155
// tmp := tmp diff i ;
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_VAR 0 2
11148: PUSH
11149: LD_VAR 0 1
11153: DIFF
11154: ST_TO_ADDR
// end ;
11155: GO 10987
11157: POP
11158: POP
// until not tmp ;
11159: LD_VAR 0 2
11163: NOT
11164: IFFALSE 10970
// end ; end_of_file
11166: PPOPN 4
11168: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11169: LD_INT 0
11171: PPUSH
11172: PPUSH
11173: PPUSH
11174: PPUSH
11175: PPUSH
11176: PPUSH
// side := 7 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 7
11184: ST_TO_ADDR
// uc_side := side ;
11185: LD_ADDR_OWVAR 20
11189: PUSH
11190: LD_VAR 0 5
11194: ST_TO_ADDR
// uc_nation := 1 ;
11195: LD_ADDR_OWVAR 21
11199: PUSH
11200: LD_INT 1
11202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11203: LD_ADDR_VAR 0 2
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_VAR 0 5
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 21
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PPUSH
11234: CALL_OW 69
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11256
// SetBLevel ( i , 10 ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: LD_INT 10
11249: PPUSH
11250: CALL_OW 241
11254: GO 11239
11256: POP
11257: POP
// base := GetBase ( al_depot ) ;
11258: LD_ADDR_VAR 0 4
11262: PUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 274
11270: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11271: LD_ADDR_VAR 0 6
11275: PUSH
11276: LD_INT 22
11278: PUSH
11279: LD_VAR 0 5
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 30
11290: PUSH
11291: LD_INT 34
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PPUSH
11302: CALL_OW 69
11306: ST_TO_ADDR
// if teleport then
11307: LD_VAR 0 6
11311: IFFALSE 11332
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11313: LD_VAR 0 6
11317: PUSH
11318: LD_INT 1
11320: ARRAY
11321: PPUSH
11322: LD_INT 262
11324: PPUSH
11325: LD_INT 119
11327: PPUSH
11328: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11332: LD_VAR 0 4
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: LD_INT 19500
11342: PPUSH
11343: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11347: LD_VAR 0 4
11351: PPUSH
11352: LD_INT 2
11354: PPUSH
11355: LD_INT 200
11357: PPUSH
11358: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11362: LD_VAR 0 4
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 650
11372: PPUSH
11373: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11377: LD_ADDR_EXP 74
11381: PUSH
11382: LD_STRING Roth
11384: PPUSH
11385: CALL_OW 25
11389: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11390: LD_ADDR_EXP 75
11394: PUSH
11395: LD_STRING Simms
11397: PPUSH
11398: LD_EXP 1
11402: NOT
11403: PPUSH
11404: LD_STRING 10c_
11406: PPUSH
11407: CALL 65920 0 3
11411: ST_TO_ADDR
// if not Simms then
11412: LD_EXP 75
11416: NOT
11417: IFFALSE 11447
// begin uc_nation := 1 ;
11419: LD_ADDR_OWVAR 21
11423: PUSH
11424: LD_INT 1
11426: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11427: LD_INT 2
11429: PPUSH
11430: LD_INT 10
11432: PPUSH
11433: CALL_OW 384
// Simms := CreateHuman ;
11437: LD_ADDR_EXP 75
11441: PUSH
11442: CALL_OW 44
11446: ST_TO_ADDR
// end ; uc_nation := 3 ;
11447: LD_ADDR_OWVAR 21
11451: PUSH
11452: LD_INT 3
11454: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11455: LD_ADDR_EXP 76
11459: PUSH
11460: LD_STRING Kirilenkova
11462: PPUSH
11463: CALL_OW 25
11467: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11468: LD_ADDR_EXP 90
11472: PUSH
11473: LD_STRING Oblukov
11475: PPUSH
11476: CALL_OW 25
11480: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11481: LD_ADDR_EXP 77
11485: PUSH
11486: LD_STRING Dolgov
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11494: LD_ADDR_EXP 78
11498: PUSH
11499: LD_STRING Petrosyan
11501: PPUSH
11502: CALL_OW 25
11506: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11507: LD_ADDR_EXP 89
11511: PUSH
11512: LD_STRING Scholtze
11514: PPUSH
11515: CALL_OW 25
11519: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11520: LD_ADDR_EXP 88
11524: PUSH
11525: LD_STRING Kapitsova
11527: PPUSH
11528: CALL_OW 25
11532: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11533: LD_ADDR_EXP 79
11537: PUSH
11538: LD_STRING Petrovova
11540: PPUSH
11541: CALL_OW 25
11545: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11546: LD_ADDR_EXP 80
11550: PUSH
11551: LD_STRING Kuzmov
11553: PPUSH
11554: CALL_OW 25
11558: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11559: LD_ADDR_EXP 87
11563: PUSH
11564: LD_STRING Karamazov
11566: PPUSH
11567: CALL_OW 25
11571: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11572: LD_STRING 13_Lipshchin_1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 30
11582: IFFALSE 11597
// Lipshchin := NewCharacter ( Lipshchin ) ;
11584: LD_ADDR_EXP 81
11588: PUSH
11589: LD_STRING Lipshchin
11591: PPUSH
11592: CALL_OW 25
11596: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11597: LD_STRING 13_Titov_1
11599: PPUSH
11600: LD_INT 0
11602: PPUSH
11603: CALL_OW 30
11607: IFFALSE 11622
// Titov := NewCharacter ( Titov ) ;
11609: LD_ADDR_EXP 83
11613: PUSH
11614: LD_STRING Titov
11616: PPUSH
11617: CALL_OW 25
11621: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11622: LD_STRING 13_Gnyevko_1
11624: PPUSH
11625: LD_INT 0
11627: PPUSH
11628: CALL_OW 30
11632: IFFALSE 11647
// Gnyevko := NewCharacter ( Gnyevko ) ;
11634: LD_ADDR_EXP 82
11638: PUSH
11639: LD_STRING Gnyevko
11641: PPUSH
11642: CALL_OW 25
11646: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11647: LD_STRING 13_Xavier_1
11649: PPUSH
11650: LD_INT 0
11652: PPUSH
11653: CALL_OW 30
11657: IFFALSE 11672
// Xavier := NewCharacter ( Xavier2 ) ;
11659: LD_ADDR_EXP 84
11663: PUSH
11664: LD_STRING Xavier2
11666: PPUSH
11667: CALL_OW 25
11671: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11672: LD_STRING 13_Belkov_1
11674: PPUSH
11675: LD_INT 0
11677: PPUSH
11678: CALL_OW 30
11682: IFFALSE 11697
// Belkov := NewCharacter ( Belkov ) ;
11684: LD_ADDR_EXP 85
11688: PUSH
11689: LD_STRING Belkov
11691: PPUSH
11692: CALL_OW 25
11696: ST_TO_ADDR
// if not BurlakStatus then
11697: LD_EXP 9
11701: NOT
11702: IFFALSE 11717
// Burlak = NewCharacter ( Burlak ) ;
11704: LD_ADDR_EXP 86
11708: PUSH
11709: LD_STRING Burlak
11711: PPUSH
11712: CALL_OW 25
11716: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11717: LD_ADDR_VAR 0 3
11721: PUSH
11722: LD_EXP 74
11726: PUSH
11727: LD_EXP 76
11731: PUSH
11732: LD_EXP 90
11736: PUSH
11737: LD_EXP 77
11741: PUSH
11742: LD_EXP 78
11746: PUSH
11747: LD_EXP 89
11751: PUSH
11752: LD_EXP 88
11756: PUSH
11757: LD_EXP 79
11761: PUSH
11762: LD_EXP 80
11766: PUSH
11767: LD_EXP 87
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: ST_TO_ADDR
// if Simms then
11784: LD_EXP 75
11788: IFFALSE 11806
// tmp := tmp ^ Simms ;
11790: LD_ADDR_VAR 0 3
11794: PUSH
11795: LD_VAR 0 3
11799: PUSH
11800: LD_EXP 75
11804: ADD
11805: ST_TO_ADDR
// if Titov then
11806: LD_EXP 83
11810: IFFALSE 11828
// tmp := tmp ^ Titov ;
11812: LD_ADDR_VAR 0 3
11816: PUSH
11817: LD_VAR 0 3
11821: PUSH
11822: LD_EXP 83
11826: ADD
11827: ST_TO_ADDR
// if Lipshchin then
11828: LD_EXP 81
11832: IFFALSE 11850
// tmp := tmp ^ Lipshchin ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_VAR 0 3
11843: PUSH
11844: LD_EXP 81
11848: ADD
11849: ST_TO_ADDR
// if Gnyevko then
11850: LD_EXP 82
11854: IFFALSE 11872
// tmp := tmp ^ Gnyevko ;
11856: LD_ADDR_VAR 0 3
11860: PUSH
11861: LD_VAR 0 3
11865: PUSH
11866: LD_EXP 82
11870: ADD
11871: ST_TO_ADDR
// if Xavier then
11872: LD_EXP 84
11876: IFFALSE 11894
// tmp := tmp ^ Xavier ;
11878: LD_ADDR_VAR 0 3
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: LD_EXP 84
11892: ADD
11893: ST_TO_ADDR
// if Belkov then
11894: LD_EXP 85
11898: IFFALSE 11916
// tmp := tmp ^ Belkov ;
11900: LD_ADDR_VAR 0 3
11904: PUSH
11905: LD_VAR 0 3
11909: PUSH
11910: LD_EXP 85
11914: ADD
11915: ST_TO_ADDR
// if Burlak then
11916: LD_EXP 86
11920: IFFALSE 11938
// tmp := tmp ^ Burlak ;
11922: LD_ADDR_VAR 0 3
11926: PUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_EXP 86
11936: ADD
11937: ST_TO_ADDR
// for i = 1 to 11 do
11938: LD_ADDR_VAR 0 2
11942: PUSH
11943: DOUBLE
11944: LD_INT 1
11946: DEC
11947: ST_TO_ADDR
11948: LD_INT 11
11950: PUSH
11951: FOR_TO
11952: IFFALSE 12018
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11954: LD_ADDR_OWVAR 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: LD_INT 3
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 1
11971: PPUSH
11972: LD_INT 2
11974: PPUSH
11975: CALL_OW 12
11979: ARRAY
11980: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11981: LD_INT 0
11983: PPUSH
11984: LD_VAR 0 2
11988: PUSH
11989: LD_INT 2
11991: DIV
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12000: LD_ADDR_VAR 0 3
12004: PUSH
12005: LD_VAR 0 3
12009: PUSH
12010: CALL_OW 44
12014: ADD
12015: ST_TO_ADDR
// end ;
12016: GO 11951
12018: POP
12019: POP
// for i in tmp do
12020: LD_ADDR_VAR 0 2
12024: PUSH
12025: LD_VAR 0 3
12029: PUSH
12030: FOR_IN
12031: IFFALSE 12056
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12033: LD_VAR 0 2
12037: PPUSH
12038: LD_INT 260
12040: PPUSH
12041: LD_INT 235
12043: PPUSH
12044: LD_INT 8
12046: PPUSH
12047: LD_INT 0
12049: PPUSH
12050: CALL_OW 50
12054: GO 12030
12056: POP
12057: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12058: LD_ADDR_EXP 115
12062: PUSH
12063: LD_EXP 115
12067: PPUSH
12068: LD_INT 1
12070: PPUSH
12071: LD_INT 22
12073: PUSH
12074: LD_VAR 0 5
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 3
12085: PUSH
12086: LD_INT 21
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PPUSH
12104: CALL_OW 69
12108: PUSH
12109: LD_EXP 74
12113: PUSH
12114: LD_EXP 75
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: DIFF
12123: PPUSH
12124: CALL_OW 1
12128: ST_TO_ADDR
// uc_side := 0 ;
12129: LD_ADDR_OWVAR 20
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// uc_nation := 0 ;
12137: LD_ADDR_OWVAR 21
12141: PUSH
12142: LD_INT 0
12144: ST_TO_ADDR
// for i = 1 to 5 do
12145: LD_ADDR_VAR 0 2
12149: PUSH
12150: DOUBLE
12151: LD_INT 1
12153: DEC
12154: ST_TO_ADDR
12155: LD_INT 5
12157: PUSH
12158: FOR_TO
12159: IFFALSE 12196
// begin InitHc ;
12161: CALL_OW 19
// hc_class := class_apeman ;
12165: LD_ADDR_OWVAR 28
12169: PUSH
12170: LD_INT 12
12172: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12173: CALL_OW 44
12177: PPUSH
12178: LD_INT 299
12180: PPUSH
12181: LD_INT 229
12183: PPUSH
12184: LD_INT 10
12186: PPUSH
12187: LD_INT 0
12189: PPUSH
12190: CALL_OW 50
// end ;
12194: GO 12158
12196: POP
12197: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12198: LD_EXP 74
12202: PPUSH
12203: LD_INT 259
12205: PPUSH
12206: LD_INT 235
12208: PPUSH
12209: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12213: LD_EXP 74
12217: PPUSH
12218: LD_INT 262
12220: PPUSH
12221: LD_INT 235
12223: PPUSH
12224: CALL_OW 178
// if Simms then
12228: LD_EXP 75
12232: IFFALSE 12263
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12234: LD_EXP 75
12238: PPUSH
12239: LD_INT 262
12241: PPUSH
12242: LD_INT 235
12244: PPUSH
12245: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12249: LD_EXP 75
12253: PPUSH
12254: LD_EXP 74
12258: PPUSH
12259: CALL_OW 179
// end ; end ;
12263: LD_VAR 0 1
12267: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12268: LD_EXP 31
12272: PUSH
12273: LD_EXP 23
12277: NOT
12278: AND
12279: IFFALSE 12455
12281: GO 12283
12283: DISABLE
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
12288: PPUSH
// begin enable ;
12289: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12290: LD_ADDR_VAR 0 2
12294: PUSH
12295: LD_INT 81
12297: PUSH
12298: LD_INT 7
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 2
12307: PUSH
12308: LD_INT 32
12310: PUSH
12311: LD_INT 3
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 30
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 30
12330: PUSH
12331: LD_INT 28
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 34
12340: PUSH
12341: LD_INT 49
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 34
12350: PUSH
12351: LD_INT 10
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 34
12360: PUSH
12361: LD_INT 8
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: ST_TO_ADDR
// if not tmp then
12386: LD_VAR 0 2
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12455
// target := tmp [ rand ( 1 , tmp ) ] ;
12395: LD_ADDR_VAR 0 3
12399: PUSH
12400: LD_VAR 0 2
12404: PUSH
12405: LD_INT 1
12407: PPUSH
12408: LD_VAR 0 2
12412: PPUSH
12413: CALL_OW 12
12417: ARRAY
12418: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12419: LD_VAR 0 3
12423: PPUSH
12424: CALL_OW 255
12428: PUSH
12429: LD_INT 1
12431: EQUAL
12432: IFFALSE 12443
// CenterNowOnUnits ( target ) ;
12434: LD_VAR 0 3
12438: PPUSH
12439: CALL_OW 87
// SetLives ( target , 0 ) ;
12443: LD_VAR 0 3
12447: PPUSH
12448: LD_INT 0
12450: PPUSH
12451: CALL_OW 234
// end ;
12455: PPOPN 3
12457: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12458: LD_EXP 23
12462: NOT
12463: PUSH
12464: LD_EXP 31
12468: AND
12469: IFFALSE 12995
12471: GO 12473
12473: DISABLE
12474: LD_INT 0
12476: PPUSH
12477: PPUSH
12478: PPUSH
// begin uc_side := 7 ;
12479: LD_ADDR_OWVAR 20
12483: PUSH
12484: LD_INT 7
12486: ST_TO_ADDR
// uc_nation := 1 ;
12487: LD_ADDR_OWVAR 21
12491: PUSH
12492: LD_INT 1
12494: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12495: LD_ADDR_VAR 0 3
12499: PUSH
12500: LD_INT 125
12502: PUSH
12503: LD_INT 163
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: LD_INT 185
12512: PUSH
12513: LD_INT 168
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 111
12522: PUSH
12523: LD_INT 97
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL 103426 0 1
12539: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12540: LD_ADDR_EXP 91
12544: PUSH
12545: EMPTY
12546: ST_TO_ADDR
// for i = 1 to Difficulty do
12547: LD_ADDR_VAR 0 1
12551: PUSH
12552: DOUBLE
12553: LD_INT 1
12555: DEC
12556: ST_TO_ADDR
12557: LD_OWVAR 67
12561: PUSH
12562: FOR_TO
12563: IFFALSE 12721
// begin InitHc ;
12565: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12569: LD_INT 0
12571: PPUSH
12572: LD_INT 8
12574: PPUSH
12575: CALL_OW 381
// un := CreateHuman ;
12579: LD_ADDR_VAR 0 2
12583: PUSH
12584: CALL_OW 44
12588: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12589: LD_VAR 0 2
12593: PPUSH
12594: LD_INT 258
12596: PPUSH
12597: LD_INT 267
12599: PPUSH
12600: LD_INT 4
12602: PPUSH
12603: LD_INT 0
12605: PPUSH
12606: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12610: LD_ADDR_EXP 91
12614: PUSH
12615: LD_EXP 91
12619: PUSH
12620: LD_VAR 0 2
12624: UNION
12625: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PUSH
12636: LD_VAR 0 1
12640: ARRAY
12641: PUSH
12642: LD_INT 1
12644: ARRAY
12645: PPUSH
12646: LD_VAR 0 3
12650: PUSH
12651: LD_VAR 0 1
12655: ARRAY
12656: PUSH
12657: LD_INT 2
12659: ARRAY
12660: PPUSH
12661: LD_INT 4
12663: PPUSH
12664: LD_INT 1
12666: PPUSH
12667: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12671: LD_VAR 0 2
12675: PPUSH
12676: LD_VAR 0 3
12680: PUSH
12681: LD_VAR 0 1
12685: ARRAY
12686: PUSH
12687: LD_INT 1
12689: ARRAY
12690: PPUSH
12691: LD_VAR 0 3
12695: PUSH
12696: LD_VAR 0 1
12700: ARRAY
12701: PUSH
12702: LD_INT 2
12704: ARRAY
12705: PPUSH
12706: CALL_OW 171
// AddComInvisible ( un ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: CALL_OW 212
// end ;
12719: GO 12562
12721: POP
12722: POP
// repeat wait ( 0 0$20 ) ;
12723: LD_INT 700
12725: PPUSH
12726: CALL_OW 67
// for i in allianceSpecialForce do
12730: LD_ADDR_VAR 0 1
12734: PUSH
12735: LD_EXP 91
12739: PUSH
12740: FOR_IN
12741: IFFALSE 12980
// begin if IsInvisible ( i ) then
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 571
12752: IFFALSE 12949
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12754: LD_ADDR_VAR 0 3
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_INT 1
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PUSH
12769: LD_INT 50
12771: PUSH
12772: EMPTY
12773: LIST
12774: PUSH
12775: LD_INT 56
12777: PUSH
12778: EMPTY
12779: LIST
12780: PUSH
12781: LD_INT 91
12783: PUSH
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 25
12791: PUSH
12792: LD_INT 30
12794: PUSH
12795: LD_INT 35
12797: PUSH
12798: LD_INT 40
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: PUSH
12807: LD_OWVAR 67
12811: ARRAY
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 2
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 1
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 25
12833: PUSH
12834: LD_INT 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 25
12843: PUSH
12844: LD_INT 3
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 25
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 25
12863: PUSH
12864: LD_INT 5
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 25
12873: PUSH
12874: LD_INT 8
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PPUSH
12897: CALL_OW 69
12901: ST_TO_ADDR
// if not tmp then
12902: LD_VAR 0 3
12906: NOT
12907: IFFALSE 12911
// continue ;
12909: GO 12740
// if Prob ( 30 * Difficulty ) then
12911: LD_INT 30
12913: PUSH
12914: LD_OWVAR 67
12918: MUL
12919: PPUSH
12920: CALL_OW 13
12924: IFFALSE 12949
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12926: LD_VAR 0 3
12930: PUSH
12931: LD_INT 1
12933: PPUSH
12934: LD_VAR 0 3
12938: PPUSH
12939: CALL_OW 12
12943: ARRAY
12944: PPUSH
12945: CALL 31298 0 1
// end ; if IsDead ( i ) then
12949: LD_VAR 0 1
12953: PPUSH
12954: CALL_OW 301
12958: IFFALSE 12978
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12960: LD_ADDR_EXP 91
12964: PUSH
12965: LD_EXP 91
12969: PUSH
12970: LD_VAR 0 1
12974: DIFF
12975: ST_TO_ADDR
// continue ;
12976: GO 12740
// end ; end ;
12978: GO 12740
12980: POP
12981: POP
// until allianceDestroyed or not allianceSpecialForce ;
12982: LD_EXP 23
12986: PUSH
12987: LD_EXP 91
12991: NOT
12992: OR
12993: IFFALSE 12723
// end ;
12995: PPOPN 3
12997: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12998: LD_EXP 23
13002: NOT
13003: PUSH
13004: LD_EXP 31
13008: AND
13009: IFFALSE 13980
13011: GO 13013
13013: DISABLE
13014: LD_INT 0
13016: PPUSH
13017: PPUSH
13018: PPUSH
13019: PPUSH
// begin enable ;
13020: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13021: LD_INT 22
13023: PUSH
13024: LD_INT 7
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PUSH
13031: LD_INT 30
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 69
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13980
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13054: LD_ADDR_VAR 0 4
13058: PUSH
13059: LD_INT 22
13061: PUSH
13062: LD_INT 7
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 34
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PPUSH
13083: CALL_OW 69
13087: ST_TO_ADDR
// if Prob ( 40 ) then
13088: LD_INT 40
13090: PPUSH
13091: CALL_OW 13
13095: IFFALSE 13222
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13097: LD_INT 1
13099: PPUSH
13100: LD_INT 5
13102: PUSH
13103: LD_INT 3
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: LD_INT 6
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 3
13123: PUSH
13124: LD_INT 2
13126: PUSH
13127: LD_INT 6
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 5
13138: PUSH
13139: LD_INT 3
13141: PUSH
13142: LD_INT 2
13144: PUSH
13145: LD_INT 6
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: PUSH
13154: LD_INT 24
13156: PUSH
13157: LD_INT 3
13159: PUSH
13160: LD_INT 3
13162: PUSH
13163: LD_INT 45
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 24
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: LD_INT 3
13180: PUSH
13181: LD_INT 47
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: LD_INT 24
13192: PUSH
13193: LD_INT 3
13195: PUSH
13196: LD_INT 3
13198: PUSH
13199: LD_INT 45
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: PPUSH
13216: CALL 59514 0 2
// end else
13220: GO 13345
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13222: LD_INT 1
13224: PPUSH
13225: LD_INT 24
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 3
13233: PUSH
13234: LD_INT 47
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 24
13245: PUSH
13246: LD_INT 3
13248: PUSH
13249: LD_INT 3
13251: PUSH
13252: LD_INT 47
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: PUSH
13261: LD_INT 5
13263: PUSH
13264: LD_INT 3
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: LD_INT 3
13284: PUSH
13285: LD_INT 2
13287: PUSH
13288: LD_INT 9
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: LD_INT 1
13302: PUSH
13303: LD_INT 3
13305: PUSH
13306: LD_INT 45
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: LD_INT 24
13317: PUSH
13318: LD_INT 1
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: LD_INT 45
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL 59514 0 2
// end ; if Difficulty > 1 then
13345: LD_OWVAR 67
13349: PUSH
13350: LD_INT 1
13352: GREATER
13353: IFFALSE 13383
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13355: LD_INT 1
13357: PPUSH
13358: LD_INT 24
13360: PUSH
13361: LD_INT 3
13363: PUSH
13364: LD_INT 3
13366: PUSH
13367: LD_INT 47
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: PUSH
13376: EMPTY
13377: LIST
13378: PPUSH
13379: CALL 59514 0 2
// repeat wait ( 0 0$1 ) ;
13383: LD_INT 35
13385: PPUSH
13386: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13390: LD_INT 1
13392: PPUSH
13393: LD_INT 1
13395: PPUSH
13396: CALL 60932 0 2
13400: PUSH
13401: LD_INT 6
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: LD_INT 7
13409: PUSH
13410: LD_INT 7
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: PUSH
13419: LD_OWVAR 67
13423: ARRAY
13424: GREATEREQUAL
13425: IFFALSE 13383
// wait ( 0 0$40 ) ;
13427: LD_INT 1400
13429: PPUSH
13430: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_INT 1
13444: PPUSH
13445: CALL 60932 0 2
13449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13450: LD_ADDR_EXP 134
13454: PUSH
13455: LD_EXP 134
13459: PPUSH
13460: LD_INT 1
13462: PPUSH
13463: LD_EXP 134
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: PUSH
13472: LD_VAR 0 2
13476: DIFF
13477: PPUSH
13478: CALL_OW 1
13482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13483: LD_ADDR_VAR 0 3
13487: PUSH
13488: LD_INT 0
13490: PPUSH
13491: LD_INT 1
13493: PPUSH
13494: CALL_OW 12
13498: ST_TO_ADDR
// if target then
13499: LD_VAR 0 3
13503: IFFALSE 13669
// begin for i in tmp do
13505: LD_ADDR_VAR 0 1
13509: PUSH
13510: LD_VAR 0 2
13514: PUSH
13515: FOR_IN
13516: IFFALSE 13541
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13518: LD_VAR 0 1
13522: PPUSH
13523: LD_INT 179
13525: PPUSH
13526: LD_INT 209
13528: PPUSH
13529: LD_INT 8
13531: PPUSH
13532: LD_INT 1
13534: PPUSH
13535: CALL_OW 483
13539: GO 13515
13541: POP
13542: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13543: LD_ADDR_VAR 0 2
13547: PUSH
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 24
13555: PUSH
13556: LD_INT 250
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PPUSH
13563: CALL_OW 72
13567: ST_TO_ADDR
// for i in tmp do
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13619
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13581: LD_VAR 0 1
13585: PPUSH
13586: LD_INT 179
13588: PPUSH
13589: LD_INT 209
13591: PPUSH
13592: CALL_OW 297
13596: PUSH
13597: LD_INT 9
13599: GREATER
13600: IFFALSE 13617
// ComMoveXY ( i , 179 , 209 ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 179
13609: PPUSH
13610: LD_INT 209
13612: PPUSH
13613: CALL_OW 111
13617: GO 13578
13619: POP
13620: POP
// wait ( 0 0$1 ) ;
13621: LD_INT 35
13623: PPUSH
13624: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: LD_INT 92
13635: PUSH
13636: LD_INT 179
13638: PUSH
13639: LD_INT 209
13641: PUSH
13642: LD_INT 9
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PPUSH
13651: CALL_OW 72
13655: PUSH
13656: LD_VAR 0 2
13660: PUSH
13661: LD_INT 1
13663: MINUS
13664: GREATEREQUAL
13665: IFFALSE 13543
// end else
13667: GO 13831
// begin for i in tmp do
13669: LD_ADDR_VAR 0 1
13673: PUSH
13674: LD_VAR 0 2
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13705
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 285
13689: PPUSH
13690: LD_INT 163
13692: PPUSH
13693: LD_INT 8
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: CALL_OW 483
13703: GO 13679
13705: POP
13706: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 24
13719: PUSH
13720: LD_INT 250
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 72
13731: ST_TO_ADDR
// for i in tmp do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_VAR 0 2
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13783
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13745: LD_VAR 0 1
13749: PPUSH
13750: LD_INT 285
13752: PPUSH
13753: LD_INT 163
13755: PPUSH
13756: CALL_OW 297
13760: PUSH
13761: LD_INT 9
13763: GREATER
13764: IFFALSE 13781
// ComMoveXY ( i , 285 , 163 ) ;
13766: LD_VAR 0 1
13770: PPUSH
13771: LD_INT 285
13773: PPUSH
13774: LD_INT 163
13776: PPUSH
13777: CALL_OW 111
13781: GO 13742
13783: POP
13784: POP
// wait ( 0 0$1 ) ;
13785: LD_INT 35
13787: PPUSH
13788: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13792: LD_VAR 0 2
13796: PPUSH
13797: LD_INT 92
13799: PUSH
13800: LD_INT 285
13802: PUSH
13803: LD_INT 163
13805: PUSH
13806: LD_INT 9
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 72
13819: PUSH
13820: LD_VAR 0 2
13824: PUSH
13825: LD_INT 1
13827: MINUS
13828: GREATEREQUAL
13829: IFFALSE 13707
// end ; repeat wait ( 0 0$1 ) ;
13831: LD_INT 35
13833: PPUSH
13834: CALL_OW 67
// for i in tmp do
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_VAR 0 2
13847: PUSH
13848: FOR_IN
13849: IFFALSE 13971
// if GetLives ( i ) > 251 then
13851: LD_VAR 0 1
13855: PPUSH
13856: CALL_OW 256
13860: PUSH
13861: LD_INT 251
13863: GREATER
13864: IFFALSE 13953
// begin if GetWeapon ( i ) = ru_time_lapser then
13866: LD_VAR 0 1
13870: PPUSH
13871: CALL_OW 264
13875: PUSH
13876: LD_INT 49
13878: EQUAL
13879: IFFALSE 13917
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13881: LD_VAR 0 1
13885: PPUSH
13886: LD_INT 81
13888: PUSH
13889: LD_INT 7
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PPUSH
13896: CALL_OW 69
13900: PPUSH
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 74
13910: PPUSH
13911: CALL_OW 112
13915: GO 13951
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13917: LD_VAR 0 1
13921: PPUSH
13922: LD_INT 81
13924: PUSH
13925: LD_INT 7
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PPUSH
13932: CALL_OW 69
13936: PPUSH
13937: LD_VAR 0 1
13941: PPUSH
13942: CALL_OW 74
13946: PPUSH
13947: CALL_OW 115
// end else
13951: GO 13969
// tmp := tmp diff i ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_VAR 0 2
13962: PUSH
13963: LD_VAR 0 1
13967: DIFF
13968: ST_TO_ADDR
13969: GO 13848
13971: POP
13972: POP
// until not tmp ;
13973: LD_VAR 0 2
13977: NOT
13978: IFFALSE 13831
// end ; end_of_file
13980: PPOPN 4
13982: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13983: LD_INT 0
13985: PPUSH
13986: PPUSH
13987: PPUSH
13988: PPUSH
// missionStage := 13 ;
13989: LD_ADDR_EXP 15
13993: PUSH
13994: LD_INT 13
13996: ST_TO_ADDR
// uc_side := 2 ;
13997: LD_ADDR_OWVAR 20
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// uc_nation := 2 ;
14005: LD_ADDR_OWVAR 21
14009: PUSH
14010: LD_INT 2
14012: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14013: LD_ADDR_EXP 92
14017: PUSH
14018: LD_STRING Omar
14020: PPUSH
14021: CALL_OW 25
14025: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14026: LD_EXP 92
14030: PPUSH
14031: LD_INT 4
14033: PPUSH
14034: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14038: LD_EXP 92
14042: PPUSH
14043: LD_INT 242
14045: PPUSH
14046: LD_INT 75
14048: PPUSH
14049: LD_INT 0
14051: PPUSH
14052: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14056: LD_ADDR_EXP 93
14060: PUSH
14061: LD_STRING Heike
14063: PPUSH
14064: CALL_OW 25
14068: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14069: LD_INT 14
14071: PPUSH
14072: LD_INT 3
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 27
14080: PPUSH
14081: LD_INT 100
14083: PPUSH
14084: CALL 70937 0 5
// veh := CreateVehicle ;
14088: LD_ADDR_VAR 0 3
14092: PUSH
14093: CALL_OW 45
14097: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14098: LD_VAR 0 3
14102: PPUSH
14103: LD_INT 2
14105: NEG
14106: PPUSH
14107: CALL_OW 242
// SetDir ( veh , 4 ) ;
14111: LD_VAR 0 3
14115: PPUSH
14116: LD_INT 4
14118: PPUSH
14119: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14123: LD_VAR 0 3
14127: PPUSH
14128: LD_INT 241
14130: PPUSH
14131: LD_INT 72
14133: PPUSH
14134: LD_INT 0
14136: PPUSH
14137: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14141: LD_EXP 93
14145: PPUSH
14146: LD_VAR 0 3
14150: PPUSH
14151: CALL_OW 52
// if KhatamStatus then
14155: LD_EXP 8
14159: IFFALSE 14222
// begin Khatam := NewCharacter ( Khatam ) ;
14161: LD_ADDR_EXP 94
14165: PUSH
14166: LD_STRING Khatam
14168: PPUSH
14169: CALL_OW 25
14173: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14174: LD_EXP 94
14178: PPUSH
14179: LD_INT 245
14181: PPUSH
14182: LD_INT 78
14184: PPUSH
14185: LD_INT 3
14187: PPUSH
14188: LD_INT 0
14190: PPUSH
14191: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14195: LD_EXP 94
14199: PPUSH
14200: LD_INT 4
14202: PPUSH
14203: LD_INT 10
14205: PPUSH
14206: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14210: LD_EXP 94
14214: PPUSH
14215: LD_INT 4
14217: PPUSH
14218: CALL_OW 336
// end ; for i = 1 to Difficulty do
14222: LD_ADDR_VAR 0 2
14226: PUSH
14227: DOUBLE
14228: LD_INT 1
14230: DEC
14231: ST_TO_ADDR
14232: LD_OWVAR 67
14236: PUSH
14237: FOR_TO
14238: IFFALSE 14304
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14240: LD_INT 0
14242: PPUSH
14243: LD_INT 7
14245: PUSH
14246: LD_OWVAR 67
14250: PLUS
14251: PPUSH
14252: CALL_OW 384
// un := CreateHuman ;
14256: LD_ADDR_VAR 0 4
14260: PUSH
14261: CALL_OW 44
14265: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14266: LD_VAR 0 4
14270: PPUSH
14271: LD_INT 28
14273: PUSH
14274: LD_INT 29
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_VAR 0 2
14285: PUSH
14286: LD_INT 2
14288: MOD
14289: PUSH
14290: LD_INT 1
14292: PLUS
14293: ARRAY
14294: PPUSH
14295: LD_INT 0
14297: PPUSH
14298: CALL_OW 49
// end ;
14302: GO 14237
14304: POP
14305: POP
// for i = 1 to 6 do
14306: LD_ADDR_VAR 0 2
14310: PUSH
14311: DOUBLE
14312: LD_INT 1
14314: DEC
14315: ST_TO_ADDR
14316: LD_INT 6
14318: PUSH
14319: FOR_TO
14320: IFFALSE 14365
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14322: LD_INT 0
14324: PPUSH
14325: LD_INT 7
14327: PUSH
14328: LD_OWVAR 67
14332: PLUS
14333: PPUSH
14334: CALL_OW 381
// un := CreateHuman ;
14338: LD_ADDR_VAR 0 4
14342: PUSH
14343: CALL_OW 44
14347: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14348: LD_VAR 0 4
14352: PPUSH
14353: LD_INT 28
14355: PPUSH
14356: LD_INT 0
14358: PPUSH
14359: CALL_OW 49
// end ;
14363: GO 14319
14365: POP
14366: POP
// for i = 1 to 3 do
14367: LD_ADDR_VAR 0 2
14371: PUSH
14372: DOUBLE
14373: LD_INT 1
14375: DEC
14376: ST_TO_ADDR
14377: LD_INT 3
14379: PUSH
14380: FOR_TO
14381: IFFALSE 14429
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14383: LD_INT 0
14385: PPUSH
14386: LD_INT 8
14388: PPUSH
14389: LD_INT 7
14391: PUSH
14392: LD_OWVAR 67
14396: PLUS
14397: PPUSH
14398: CALL_OW 380
// un := CreateHuman ;
14402: LD_ADDR_VAR 0 4
14406: PUSH
14407: CALL_OW 44
14411: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14412: LD_VAR 0 4
14416: PPUSH
14417: LD_INT 28
14419: PPUSH
14420: LD_INT 0
14422: PPUSH
14423: CALL_OW 49
// end ;
14427: GO 14380
14429: POP
14430: POP
// for i = 1 to 3 do
14431: LD_ADDR_VAR 0 2
14435: PUSH
14436: DOUBLE
14437: LD_INT 1
14439: DEC
14440: ST_TO_ADDR
14441: LD_INT 3
14443: PUSH
14444: FOR_TO
14445: IFFALSE 14535
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14447: LD_INT 14
14449: PPUSH
14450: LD_INT 2
14452: PPUSH
14453: LD_INT 1
14455: PPUSH
14456: LD_INT 28
14458: PPUSH
14459: LD_INT 80
14461: PPUSH
14462: CALL 70937 0 5
// veh := CreateVehicle ;
14466: LD_ADDR_VAR 0 3
14470: PUSH
14471: CALL_OW 45
14475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14476: LD_VAR 0 3
14480: PPUSH
14481: LD_INT 3
14483: PPUSH
14484: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: LD_INT 29
14495: PPUSH
14496: LD_INT 0
14498: PPUSH
14499: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14503: LD_INT 0
14505: PPUSH
14506: LD_INT 7
14508: PUSH
14509: LD_OWVAR 67
14513: PLUS
14514: PPUSH
14515: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14519: CALL_OW 44
14523: PPUSH
14524: LD_VAR 0 3
14528: PPUSH
14529: CALL_OW 52
// end ;
14533: GO 14444
14535: POP
14536: POP
// for i = 1 to 5 + Difficulty do
14537: LD_ADDR_VAR 0 2
14541: PUSH
14542: DOUBLE
14543: LD_INT 1
14545: DEC
14546: ST_TO_ADDR
14547: LD_INT 5
14549: PUSH
14550: LD_OWVAR 67
14554: PLUS
14555: PUSH
14556: FOR_TO
14557: IFFALSE 14684
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14559: LD_INT 14
14561: PPUSH
14562: LD_INT 1
14564: PPUSH
14565: LD_INT 3
14567: PPUSH
14568: CALL_OW 12
14572: PPUSH
14573: LD_INT 1
14575: PPUSH
14576: LD_INT 28
14578: PUSH
14579: LD_INT 26
14581: PUSH
14582: LD_INT 27
14584: PUSH
14585: LD_INT 25
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: PUSH
14594: LD_VAR 0 2
14598: PUSH
14599: LD_INT 4
14601: MOD
14602: PUSH
14603: LD_INT 1
14605: PLUS
14606: ARRAY
14607: PPUSH
14608: LD_INT 80
14610: PPUSH
14611: CALL 70937 0 5
// veh := CreateVehicle ;
14615: LD_ADDR_VAR 0 3
14619: PUSH
14620: CALL_OW 45
14624: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 4
14632: PPUSH
14633: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14637: LD_VAR 0 3
14641: PPUSH
14642: LD_INT 28
14644: PPUSH
14645: LD_INT 0
14647: PPUSH
14648: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14652: LD_INT 0
14654: PPUSH
14655: LD_INT 7
14657: PUSH
14658: LD_OWVAR 67
14662: PLUS
14663: PPUSH
14664: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14668: CALL_OW 44
14672: PPUSH
14673: LD_VAR 0 3
14677: PPUSH
14678: CALL_OW 52
// end ;
14682: GO 14556
14684: POP
14685: POP
// for i = 1 to 3 do
14686: LD_ADDR_VAR 0 2
14690: PUSH
14691: DOUBLE
14692: LD_INT 1
14694: DEC
14695: ST_TO_ADDR
14696: LD_INT 3
14698: PUSH
14699: FOR_TO
14700: IFFALSE 14760
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14702: LD_INT 14
14704: PPUSH
14705: LD_INT 3
14707: PPUSH
14708: LD_INT 5
14710: PPUSH
14711: LD_INT 29
14713: PPUSH
14714: LD_INT 80
14716: PPUSH
14717: CALL 70937 0 5
// veh := CreateVehicle ;
14721: LD_ADDR_VAR 0 3
14725: PUSH
14726: CALL_OW 45
14730: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14731: LD_VAR 0 3
14735: PPUSH
14736: LD_INT 4
14738: PPUSH
14739: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14743: LD_VAR 0 3
14747: PPUSH
14748: LD_INT 28
14750: PPUSH
14751: LD_INT 0
14753: PPUSH
14754: CALL_OW 49
// end ;
14758: GO 14699
14760: POP
14761: POP
// end ;
14762: LD_VAR 0 1
14766: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14767: LD_INT 22
14769: PUSH
14770: LD_INT 2
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PPUSH
14777: CALL_OW 69
14781: IFFALSE 15081
14783: GO 14785
14785: DISABLE
14786: LD_INT 0
14788: PPUSH
14789: PPUSH
14790: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: LD_INT 22
14798: PUSH
14799: LD_INT 2
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PUSH
14806: LD_INT 25
14808: PUSH
14809: LD_INT 4
14811: PUSH
14812: EMPTY
14813: LIST
14814: LIST
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: PPUSH
14820: CALL_OW 69
14824: PUSH
14825: LD_EXP 94
14829: DIFF
14830: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14831: LD_ADDR_VAR 0 2
14835: PUSH
14836: LD_INT 22
14838: PUSH
14839: LD_INT 2
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: PPUSH
14846: CALL_OW 69
14850: PUSH
14851: LD_EXP 94
14855: PUSH
14856: LD_VAR 0 3
14860: UNION
14861: DIFF
14862: ST_TO_ADDR
// if Khatam then
14863: LD_EXP 94
14867: IFFALSE 14884
// ComMoveXY ( Khatam , 211 , 92 ) ;
14869: LD_EXP 94
14873: PPUSH
14874: LD_INT 211
14876: PPUSH
14877: LD_INT 92
14879: PPUSH
14880: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14884: LD_INT 197
14886: PPUSH
14887: LD_INT 80
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14897: LD_INT 213
14899: PPUSH
14900: LD_INT 90
14902: PPUSH
14903: LD_INT 2
14905: PPUSH
14906: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14910: LD_INT 215
14912: PPUSH
14913: LD_INT 129
14915: PPUSH
14916: LD_INT 2
14918: PPUSH
14919: CALL_OW 441
// if sci then
14923: LD_VAR 0 3
14927: IFFALSE 14948
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14929: LD_VAR 0 3
14933: PUSH
14934: LD_INT 1
14936: ARRAY
14937: PPUSH
14938: LD_INT 197
14940: PPUSH
14941: LD_INT 80
14943: PPUSH
14944: CALL_OW 158
// if sci > 1 then
14948: LD_VAR 0 3
14952: PUSH
14953: LD_INT 1
14955: GREATER
14956: IFFALSE 14977
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14958: LD_VAR 0 3
14962: PUSH
14963: LD_INT 2
14965: ARRAY
14966: PPUSH
14967: LD_INT 213
14969: PPUSH
14970: LD_INT 90
14972: PPUSH
14973: CALL_OW 158
// if sci > 2 then
14977: LD_VAR 0 3
14981: PUSH
14982: LD_INT 2
14984: GREATER
14985: IFFALSE 15006
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14987: LD_VAR 0 3
14991: PUSH
14992: LD_INT 3
14994: ARRAY
14995: PPUSH
14996: LD_INT 215
14998: PPUSH
14999: LD_INT 129
15001: PPUSH
15002: CALL_OW 158
// repeat wait ( 0 0$2 ) ;
15006: LD_INT 70
15008: PPUSH
15009: CALL_OW 67
// for i in tmp do
15013: LD_ADDR_VAR 0 1
15017: PUSH
15018: LD_VAR 0 2
15022: PUSH
15023: FOR_IN
15024: IFFALSE 15062
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15026: LD_VAR 0 1
15030: PPUSH
15031: LD_INT 81
15033: PUSH
15034: LD_INT 2
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 69
15045: PPUSH
15046: LD_VAR 0 1
15050: PPUSH
15051: CALL_OW 74
15055: PPUSH
15056: CALL_OW 115
15060: GO 15023
15062: POP
15063: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15064: LD_INT 22
15066: PUSH
15067: LD_INT 2
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: NOT
15079: IFFALSE 15006
// end ; end_of_file
15081: PPOPN 3
15083: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15084: LD_INT 0
15086: PPUSH
15087: PPUSH
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
15093: PPUSH
15094: PPUSH
// Video ( true ) ;
15095: LD_INT 1
15097: PPUSH
15098: CALL 103293 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15102: LD_ADDR_VAR 0 5
15106: PUSH
15107: LD_INT 7
15109: PPUSH
15110: LD_INT 0
15112: PPUSH
15113: CALL_OW 517
15117: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15118: LD_ADDR_VAR 0 2
15122: PUSH
15123: DOUBLE
15124: LD_INT 1
15126: DEC
15127: ST_TO_ADDR
15128: LD_VAR 0 5
15132: PUSH
15133: LD_INT 1
15135: ARRAY
15136: PUSH
15137: FOR_TO
15138: IFFALSE 15183
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15140: LD_VAR 0 5
15144: PUSH
15145: LD_INT 1
15147: ARRAY
15148: PUSH
15149: LD_VAR 0 2
15153: ARRAY
15154: PPUSH
15155: LD_VAR 0 5
15159: PUSH
15160: LD_INT 2
15162: ARRAY
15163: PUSH
15164: LD_VAR 0 2
15168: ARRAY
15169: PPUSH
15170: LD_INT 1
15172: PPUSH
15173: LD_INT 15
15175: NEG
15176: PPUSH
15177: CALL 103207 0 4
15181: GO 15137
15183: POP
15184: POP
// CenterNowOnUnits ( Powell ) ;
15185: LD_EXP 58
15189: PPUSH
15190: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15194: LD_ADDR_VAR 0 5
15198: PUSH
15199: LD_EXP 56
15203: PUSH
15204: EMPTY
15205: LIST
15206: ST_TO_ADDR
// if GirlNewVeh then
15207: LD_EXP 57
15211: IFFALSE 15229
// tmp := tmp ^ GirlNewVeh ;
15213: LD_ADDR_VAR 0 5
15217: PUSH
15218: LD_VAR 0 5
15222: PUSH
15223: LD_EXP 57
15227: ADD
15228: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15229: LD_VAR 0 5
15233: PPUSH
15234: LD_INT 60
15236: PPUSH
15237: LD_INT 109
15239: PPUSH
15240: CALL_OW 111
// if KappaStatus then
15244: LD_EXP 2
15248: IFFALSE 15300
// begin Say ( JMM , D1nT-JMM-1 ) ;
15250: LD_EXP 39
15254: PPUSH
15255: LD_STRING D1nT-JMM-1
15257: PPUSH
15258: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15262: LD_EXP 58
15266: PPUSH
15267: LD_STRING D1T-Pow-1
15269: PPUSH
15270: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15274: LD_EXP 39
15278: PPUSH
15279: LD_STRING D1T-JMM-2
15281: PPUSH
15282: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15286: LD_EXP 58
15290: PPUSH
15291: LD_STRING D1T-Pow-2
15293: PPUSH
15294: CALL_OW 88
// end else
15298: GO 15506
// if JMMGirlStatus then
15300: LD_EXP 6
15304: IFFALSE 15449
// begin Say ( JMM , D1T-JMM-1 ) ;
15306: LD_EXP 39
15310: PPUSH
15311: LD_STRING D1T-JMM-1
15313: PPUSH
15314: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15318: LD_EXP 58
15322: PPUSH
15323: LD_STRING D1T-Pow-1
15325: PPUSH
15326: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15330: LD_EXP 39
15334: PPUSH
15335: LD_STRING D1T-JMM-3
15337: PPUSH
15338: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-3
15349: PPUSH
15350: CALL_OW 88
// if JMMGirl then
15354: LD_EXP 7
15358: IFFALSE 15447
// begin case JMMGirl of 1 :
15360: LD_EXP 7
15364: PUSH
15365: LD_INT 1
15367: DOUBLE
15368: EQUAL
15369: IFTRUE 15373
15371: GO 15388
15373: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15374: LD_EXP 40
15378: PPUSH
15379: LD_STRING D1T-Joan-3
15381: PPUSH
15382: CALL_OW 88
15386: GO 15435
15388: LD_INT 2
15390: DOUBLE
15391: EQUAL
15392: IFTRUE 15396
15394: GO 15411
15396: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15397: LD_EXP 42
15401: PPUSH
15402: LD_STRING D1T-Lisa-3
15404: PPUSH
15405: CALL_OW 88
15409: GO 15435
15411: LD_INT 3
15413: DOUBLE
15414: EQUAL
15415: IFTRUE 15419
15417: GO 15434
15419: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15420: LD_EXP 54
15424: PPUSH
15425: LD_STRING D1T-Con-3
15427: PPUSH
15428: CALL_OW 88
15432: GO 15435
15434: POP
// Say ( Powell , D1T-Pow-4 ) ;
15435: LD_EXP 58
15439: PPUSH
15440: LD_STRING D1T-Pow-4
15442: PPUSH
15443: CALL_OW 88
// end ; end else
15447: GO 15506
// if not FastEnd then
15449: LD_EXP 11
15453: NOT
15454: IFFALSE 15482
// begin Say ( JMM , D1T-JMM-4 ) ;
15456: LD_EXP 39
15460: PPUSH
15461: LD_STRING D1T-JMM-4
15463: PPUSH
15464: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15468: LD_EXP 58
15472: PPUSH
15473: LD_STRING D1T-Pow-5
15475: PPUSH
15476: CALL_OW 88
// end else
15480: GO 15506
// begin Say ( JMM , D1nT-JMM-1 ) ;
15482: LD_EXP 39
15486: PPUSH
15487: LD_STRING D1nT-JMM-1
15489: PPUSH
15490: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15494: LD_EXP 58
15498: PPUSH
15499: LD_STRING D1nT-Pow-1
15501: PPUSH
15502: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15506: LD_INT 35
15508: PPUSH
15509: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15513: LD_EXP 56
15517: PPUSH
15518: CALL_OW 314
15522: NOT
15523: IFFALSE 15506
// ComExitVehicle ( JMM ) ;
15525: LD_EXP 39
15529: PPUSH
15530: CALL_OW 121
// wait ( 3 ) ;
15534: LD_INT 3
15536: PPUSH
15537: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15541: LD_EXP 39
15545: PPUSH
15546: LD_INT 60
15548: PPUSH
15549: LD_INT 94
15551: PPUSH
15552: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15556: LD_EXP 39
15560: PPUSH
15561: LD_EXP 58
15565: PPUSH
15566: CALL_OW 179
// if Joan then
15570: LD_EXP 40
15574: IFFALSE 15628
// begin ComExitVehicle ( Joan ) ;
15576: LD_EXP 40
15580: PPUSH
15581: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15585: LD_EXP 40
15589: PPUSH
15590: LD_INT 35
15592: PPUSH
15593: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15597: LD_EXP 40
15601: PPUSH
15602: LD_INT 65
15604: PPUSH
15605: LD_INT 104
15607: PPUSH
15608: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15612: LD_EXP 40
15616: PPUSH
15617: LD_EXP 39
15621: PPUSH
15622: CALL_OW 179
// end else
15626: GO 15762
// if Lisa and JMMGirl = 2 then
15628: LD_EXP 42
15632: PUSH
15633: LD_EXP 7
15637: PUSH
15638: LD_INT 2
15640: EQUAL
15641: AND
15642: IFFALSE 15696
// begin ComExitVehicle ( Lisa ) ;
15644: LD_EXP 42
15648: PPUSH
15649: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15653: LD_EXP 42
15657: PPUSH
15658: LD_INT 35
15660: PPUSH
15661: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15665: LD_EXP 42
15669: PPUSH
15670: LD_INT 65
15672: PPUSH
15673: LD_INT 104
15675: PPUSH
15676: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15680: LD_EXP 42
15684: PPUSH
15685: LD_EXP 39
15689: PPUSH
15690: CALL_OW 179
// end else
15694: GO 15762
// if Connie and JMMGirl = 3 then
15696: LD_EXP 54
15700: PUSH
15701: LD_EXP 7
15705: PUSH
15706: LD_INT 3
15708: EQUAL
15709: AND
15710: IFFALSE 15762
// begin ComExitVehicle ( Connie ) ;
15712: LD_EXP 54
15716: PPUSH
15717: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15721: LD_EXP 54
15725: PPUSH
15726: LD_INT 35
15728: PPUSH
15729: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15733: LD_EXP 54
15737: PPUSH
15738: LD_INT 65
15740: PPUSH
15741: LD_INT 104
15743: PPUSH
15744: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15748: LD_EXP 54
15752: PPUSH
15753: LD_EXP 39
15757: PPUSH
15758: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15762: LD_INT 35
15764: PPUSH
15765: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15769: LD_EXP 39
15773: PPUSH
15774: LD_EXP 58
15778: PPUSH
15779: CALL_OW 296
15783: PUSH
15784: LD_INT 6
15786: LESS
15787: IFFALSE 15762
// wait ( 0 0$0.5 ) ;
15789: LD_INT 18
15791: PPUSH
15792: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15796: LD_EXP 39
15800: PPUSH
15801: LD_STRING D1-JMM-1
15803: PPUSH
15804: CALL_OW 88
// async ;
15808: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15809: LD_EXP 58
15813: PPUSH
15814: LD_STRING D1-Pow-1
15816: PPUSH
15817: CALL_OW 88
// if not dialogue_skipped then
15821: LD_OWVAR 59
15825: NOT
15826: IFFALSE 15835
// wait ( 0 0$2 ) ;
15828: LD_INT 70
15830: PPUSH
15831: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15835: LD_INT 170
15837: PPUSH
15838: LD_INT 99
15840: PPUSH
15841: LD_INT 1
15843: PPUSH
15844: LD_INT 6
15846: NEG
15847: PPUSH
15848: CALL 103207 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15852: LD_INT 174
15854: PPUSH
15855: LD_INT 115
15857: PPUSH
15858: LD_INT 1
15860: PPUSH
15861: LD_INT 6
15863: NEG
15864: PPUSH
15865: CALL 103207 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15869: LD_INT 169
15871: PPUSH
15872: LD_INT 71
15874: PPUSH
15875: LD_INT 1
15877: PPUSH
15878: LD_INT 6
15880: NEG
15881: PPUSH
15882: CALL 103207 0 4
// if not dialogue_skipped then
15886: LD_OWVAR 59
15890: NOT
15891: IFFALSE 15910
// begin CenterOnXY ( 170 , 99 ) ;
15893: LD_INT 170
15895: PPUSH
15896: LD_INT 99
15898: PPUSH
15899: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15903: LD_INT 80
15905: PPUSH
15906: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15910: LD_INT 75
15912: PPUSH
15913: LD_INT 53
15915: PPUSH
15916: LD_INT 1
15918: PPUSH
15919: LD_INT 9
15921: NEG
15922: PPUSH
15923: CALL 103207 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15927: LD_INT 54
15929: PPUSH
15930: LD_INT 42
15932: PPUSH
15933: LD_INT 1
15935: PPUSH
15936: LD_INT 9
15938: NEG
15939: PPUSH
15940: CALL 103207 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15944: LD_INT 62
15946: PPUSH
15947: LD_INT 51
15949: PPUSH
15950: LD_INT 1
15952: PPUSH
15953: LD_INT 9
15955: NEG
15956: PPUSH
15957: CALL 103207 0 4
// if not dialogue_skipped then
15961: LD_OWVAR 59
15965: NOT
15966: IFFALSE 15985
// begin CenterOnXY ( 75 , 53 ) ;
15968: LD_INT 75
15970: PPUSH
15971: LD_INT 53
15973: PPUSH
15974: CALL_OW 84
// wait ( 0 0$4 ) ;
15978: LD_INT 140
15980: PPUSH
15981: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15985: LD_EXP 58
15989: PPUSH
15990: CALL_OW 87
// if not dialogue_skipped then
15994: LD_OWVAR 59
15998: NOT
15999: IFFALSE 16008
// wait ( 0 0$2 ) ;
16001: LD_INT 70
16003: PPUSH
16004: CALL_OW 67
// sync ;
16008: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16009: LD_EXP 39
16013: PPUSH
16014: LD_STRING D1-JMM-2
16016: PPUSH
16017: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16021: LD_EXP 58
16025: PPUSH
16026: LD_STRING D1-Pow-2
16028: PPUSH
16029: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16033: LD_EXP 39
16037: PPUSH
16038: LD_STRING D1-JMM-3
16040: PPUSH
16041: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16045: LD_EXP 58
16049: PPUSH
16050: LD_STRING D1-Pow-3
16052: PPUSH
16053: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16057: LD_EXP 39
16061: PPUSH
16062: LD_STRING D1-JMM-4
16064: PPUSH
16065: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16069: LD_EXP 58
16073: PPUSH
16074: LD_STRING D1-Pow-4
16076: PPUSH
16077: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16081: LD_EXP 39
16085: PPUSH
16086: LD_STRING D1-JMM-5
16088: PPUSH
16089: CALL_OW 88
// async ;
16093: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16094: LD_EXP 58
16098: PPUSH
16099: LD_STRING D1-Pow-5
16101: PPUSH
16102: CALL_OW 88
// if not dialogue_skipped then
16106: LD_OWVAR 59
16110: NOT
16111: IFFALSE 16120
// wait ( 0 0$3.6 ) ;
16113: LD_INT 126
16115: PPUSH
16116: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16120: LD_INT 134
16122: PPUSH
16123: LD_INT 210
16125: PPUSH
16126: LD_INT 1
16128: PPUSH
16129: LD_INT 11
16131: NEG
16132: PPUSH
16133: CALL 103207 0 4
// if not dialogue_skipped then
16137: LD_OWVAR 59
16141: NOT
16142: IFFALSE 16161
// begin CenterOnXY ( 134 , 210 ) ;
16144: LD_INT 134
16146: PPUSH
16147: LD_INT 210
16149: PPUSH
16150: CALL_OW 84
// wait ( 0 0$2 ) ;
16154: LD_INT 70
16156: PPUSH
16157: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16161: LD_INT 101
16163: PPUSH
16164: LD_INT 159
16166: PPUSH
16167: LD_INT 1
16169: PPUSH
16170: LD_INT 10
16172: NEG
16173: PPUSH
16174: CALL 103207 0 4
// if not dialogue_skipped then
16178: LD_OWVAR 59
16182: NOT
16183: IFFALSE 16202
// begin CenterOnXY ( 101 , 159 ) ;
16185: LD_INT 101
16187: PPUSH
16188: LD_INT 159
16190: PPUSH
16191: CALL_OW 84
// wait ( 0 0$2 ) ;
16195: LD_INT 70
16197: PPUSH
16198: CALL_OW 67
// end ; sync ;
16202: SYNC
// CenterNowOnUnits ( Powell ) ;
16203: LD_EXP 58
16207: PPUSH
16208: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16212: LD_ADDR_VAR 0 6
16216: PUSH
16217: LD_INT 1
16219: PUSH
16220: LD_INT 2
16222: PUSH
16223: LD_INT 3
16225: PUSH
16226: LD_INT 4
16228: PUSH
16229: LD_INT 5
16231: PUSH
16232: LD_INT 6
16234: PUSH
16235: EMPTY
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: ST_TO_ADDR
// if not dialogue_skipped then
16243: LD_OWVAR 59
16247: NOT
16248: IFFALSE 16417
// begin game_speed := 4 ;
16250: LD_ADDR_OWVAR 65
16254: PUSH
16255: LD_INT 4
16257: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16258: LD_INT 210
16260: PPUSH
16261: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16265: LD_ADDR_VAR 0 7
16269: PUSH
16270: LD_STRING Q1
16272: PPUSH
16273: LD_VAR 0 6
16277: PPUSH
16278: CALL_OW 98
16282: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1
16290: PPUSH
16291: LD_VAR 0 6
16295: PPUSH
16296: CALL_OW 98
16300: ST_TO_ADDR
// options = options diff dec ;
16301: LD_ADDR_VAR 0 6
16305: PUSH
16306: LD_VAR 0 6
16310: PUSH
16311: LD_VAR 0 7
16315: DIFF
16316: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16317: LD_VAR 0 7
16321: PPUSH
16322: LD_VAR 0 6
16326: PPUSH
16327: CALL 17889 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16331: LD_VAR 0 7
16335: PUSH
16336: LD_INT 5
16338: PUSH
16339: LD_INT 6
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: IN
16346: PUSH
16347: LD_VAR 0 6
16351: PUSH
16352: LD_INT 2
16354: EQUAL
16355: OR
16356: IFFALSE 16283
// if not ( dec in [ 5 , 6 ] ) then
16358: LD_VAR 0 7
16362: PUSH
16363: LD_INT 5
16365: PUSH
16366: LD_INT 6
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: IN
16373: NOT
16374: IFFALSE 16417
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16376: LD_ADDR_VAR 0 7
16380: PUSH
16381: LD_STRING Q1a
16383: PPUSH
16384: LD_INT 1
16386: PUSH
16387: LD_INT 2
16389: PUSH
16390: EMPTY
16391: LIST
16392: LIST
16393: PPUSH
16394: CALL_OW 98
16398: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16399: LD_VAR 0 7
16403: PUSH
16404: LD_INT 4
16406: PLUS
16407: PPUSH
16408: LD_VAR 0 6
16412: PPUSH
16413: CALL 17889 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16417: LD_INT 81
16419: PPUSH
16420: LD_INT 127
16422: PPUSH
16423: CALL_OW 84
// amount := 5 ;
16427: LD_ADDR_VAR 0 8
16431: PUSH
16432: LD_INT 5
16434: ST_TO_ADDR
// macmilan_squad := [ ] ;
16435: LD_ADDR_VAR 0 9
16439: PUSH
16440: EMPTY
16441: ST_TO_ADDR
// if vip < amount then
16442: LD_EXP 59
16446: PUSH
16447: LD_VAR 0 8
16451: LESS
16452: IFFALSE 16496
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16454: LD_ADDR_VAR 0 5
16458: PUSH
16459: LD_EXP 59
16463: PUSH
16464: LD_INT 22
16466: PUSH
16467: LD_INT 4
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: PUSH
16474: LD_INT 21
16476: PUSH
16477: LD_INT 1
16479: PUSH
16480: EMPTY
16481: LIST
16482: LIST
16483: PUSH
16484: EMPTY
16485: LIST
16486: LIST
16487: PPUSH
16488: CALL_OW 69
16492: UNION
16493: ST_TO_ADDR
16494: GO 16506
// tmp := vip ;
16496: LD_ADDR_VAR 0 5
16500: PUSH
16501: LD_EXP 59
16505: ST_TO_ADDR
// tmp := tmp diff Powell ;
16506: LD_ADDR_VAR 0 5
16510: PUSH
16511: LD_VAR 0 5
16515: PUSH
16516: LD_EXP 58
16520: DIFF
16521: ST_TO_ADDR
// if tmp < amount then
16522: LD_VAR 0 5
16526: PUSH
16527: LD_VAR 0 8
16531: LESS
16532: IFFALSE 16544
// amount := tmp ;
16534: LD_ADDR_VAR 0 8
16538: PUSH
16539: LD_VAR 0 5
16543: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16544: LD_VAR 0 5
16548: PUSH
16549: LD_INT 1
16551: ARRAY
16552: PPUSH
16553: CALL_OW 257
16557: PUSH
16558: LD_INT 2
16560: NONEQUAL
16561: IFFALSE 16623
// begin if IsInUnit ( tmp [ 1 ] ) then
16563: LD_VAR 0 5
16567: PUSH
16568: LD_INT 1
16570: ARRAY
16571: PPUSH
16572: CALL_OW 310
16576: IFFALSE 16591
// ComExitBuilding ( tmp [ 1 ] ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16591: LD_VAR 0 5
16595: PUSH
16596: LD_INT 1
16598: ARRAY
16599: PPUSH
16600: LD_INT 387
16602: PPUSH
16603: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16607: LD_VAR 0 5
16611: PUSH
16612: LD_INT 1
16614: ARRAY
16615: PPUSH
16616: LD_INT 2
16618: PPUSH
16619: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16623: LD_EXP 39
16627: PPUSH
16628: LD_INT 82
16630: PPUSH
16631: LD_INT 129
16633: PPUSH
16634: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16638: LD_EXP 39
16642: PPUSH
16643: LD_EXP 58
16647: PPUSH
16648: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16652: LD_INT 22
16654: PUSH
16655: LD_INT 1
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: PPUSH
16662: CALL_OW 69
16666: PUSH
16667: LD_EXP 39
16671: DIFF
16672: PPUSH
16673: LD_INT 84
16675: PPUSH
16676: LD_INT 128
16678: PPUSH
16679: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16683: LD_INT 22
16685: PUSH
16686: LD_INT 1
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PPUSH
16693: CALL_OW 69
16697: PUSH
16698: LD_EXP 39
16702: DIFF
16703: PPUSH
16704: LD_EXP 39
16708: PPUSH
16709: CALL_OW 179
// for i = 1 to amount do
16713: LD_ADDR_VAR 0 2
16717: PUSH
16718: DOUBLE
16719: LD_INT 1
16721: DEC
16722: ST_TO_ADDR
16723: LD_VAR 0 8
16727: PUSH
16728: FOR_TO
16729: IFFALSE 16897
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16731: LD_ADDR_VAR 0 9
16735: PUSH
16736: LD_VAR 0 9
16740: PUSH
16741: LD_VAR 0 5
16745: PUSH
16746: LD_VAR 0 2
16750: ARRAY
16751: ADD
16752: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16753: LD_VAR 0 5
16757: PUSH
16758: LD_VAR 0 2
16762: ARRAY
16763: PPUSH
16764: CALL_OW 310
16768: IFFALSE 16785
// AddComExitBuilding ( tmp [ i ] ) ;
16770: LD_VAR 0 5
16774: PUSH
16775: LD_VAR 0 2
16779: ARRAY
16780: PPUSH
16781: CALL_OW 182
// if i = 2 and JMMNewVeh then
16785: LD_VAR 0 2
16789: PUSH
16790: LD_INT 2
16792: EQUAL
16793: PUSH
16794: LD_EXP 56
16798: AND
16799: IFFALSE 16857
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16801: LD_VAR 0 5
16805: PUSH
16806: LD_VAR 0 2
16810: ARRAY
16811: PPUSH
16812: LD_EXP 56
16816: PPUSH
16817: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16821: LD_VAR 0 5
16825: PUSH
16826: LD_VAR 0 2
16830: ARRAY
16831: PPUSH
16832: LD_INT 86
16834: PPUSH
16835: LD_INT 133
16837: PPUSH
16838: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16842: LD_VAR 0 5
16846: PUSH
16847: LD_VAR 0 2
16851: ARRAY
16852: PPUSH
16853: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16857: LD_VAR 0 5
16861: PUSH
16862: LD_VAR 0 2
16866: ARRAY
16867: PPUSH
16868: LD_INT 8
16870: PPUSH
16871: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16875: LD_VAR 0 5
16879: PUSH
16880: LD_VAR 0 2
16884: ARRAY
16885: PPUSH
16886: LD_EXP 39
16890: PPUSH
16891: CALL_OW 179
// end ;
16895: GO 16728
16897: POP
16898: POP
// if GirlNewVeh then
16899: LD_EXP 57
16903: IFFALSE 16917
// SetSide ( GirlNewVeh , 4 ) ;
16905: LD_EXP 57
16909: PPUSH
16910: LD_INT 4
16912: PPUSH
16913: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16917: LD_INT 35
16919: PPUSH
16920: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16924: LD_VAR 0 9
16928: PPUSH
16929: LD_INT 95
16931: PUSH
16932: LD_INT 9
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PPUSH
16939: CALL_OW 72
16943: PUSH
16944: LD_INT 0
16946: EQUAL
16947: PUSH
16948: LD_EXP 39
16952: PPUSH
16953: LD_INT 9
16955: PPUSH
16956: CALL_OW 308
16960: NOT
16961: AND
16962: IFFALSE 16917
// wait ( 0 0$2 ) ;
16964: LD_INT 70
16966: PPUSH
16967: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16971: LD_VAR 0 9
16975: PPUSH
16976: LD_INT 1
16978: PPUSH
16979: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16983: LD_INT 21
16985: PUSH
16986: LD_INT 2
16988: PUSH
16989: EMPTY
16990: LIST
16991: LIST
16992: PUSH
16993: LD_INT 92
16995: PUSH
16996: LD_INT 83
16998: PUSH
16999: LD_INT 130
17001: PUSH
17002: LD_INT 10
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: PPUSH
17015: CALL_OW 69
17019: PPUSH
17020: LD_INT 1
17022: PPUSH
17023: CALL_OW 235
// Video ( false ) ;
17027: LD_INT 0
17029: PPUSH
17030: CALL 103293 0 1
// ChangeMissionObjectives ( M1 ) ;
17034: LD_STRING M1
17036: PPUSH
17037: CALL_OW 337
// SaveForQuickRestart ;
17041: CALL_OW 22
// missionStart := true ;
17045: LD_ADDR_EXP 13
17049: PUSH
17050: LD_INT 1
17052: ST_TO_ADDR
// missionStage := 2 ;
17053: LD_ADDR_EXP 15
17057: PUSH
17058: LD_INT 2
17060: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17061: LD_INT 105
17063: PPUSH
17064: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17068: LD_ADDR_VAR 0 5
17072: PUSH
17073: LD_INT 22
17075: PUSH
17076: LD_INT 4
17078: PUSH
17079: EMPTY
17080: LIST
17081: LIST
17082: PUSH
17083: LD_INT 21
17085: PUSH
17086: LD_INT 1
17088: PUSH
17089: EMPTY
17090: LIST
17091: LIST
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: PPUSH
17097: CALL_OW 69
17101: PUSH
17102: LD_EXP 58
17106: DIFF
17107: ST_TO_ADDR
// if not tmp then
17108: LD_VAR 0 5
17112: NOT
17113: IFFALSE 17128
// tmp := [ Powell ] ;
17115: LD_ADDR_VAR 0 5
17119: PUSH
17120: LD_EXP 58
17124: PUSH
17125: EMPTY
17126: LIST
17127: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17128: LD_ADDR_EXP 115
17132: PUSH
17133: LD_EXP 115
17137: PPUSH
17138: LD_INT 4
17140: PPUSH
17141: LD_INT 22
17143: PUSH
17144: LD_INT 4
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: PUSH
17151: LD_INT 23
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: LD_INT 3
17163: PUSH
17164: LD_INT 21
17166: PUSH
17167: LD_INT 2
17169: PUSH
17170: EMPTY
17171: LIST
17172: LIST
17173: PUSH
17174: EMPTY
17175: LIST
17176: LIST
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: PPUSH
17183: CALL_OW 69
17187: PUSH
17188: LD_EXP 58
17192: DIFF
17193: PPUSH
17194: CALL_OW 1
17198: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17199: LD_ADDR_VAR 0 4
17203: PUSH
17204: LD_INT 22
17206: PUSH
17207: LD_INT 4
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: LD_INT 34
17216: PUSH
17217: LD_INT 12
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: PUSH
17224: EMPTY
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL_OW 69
17232: PUSH
17233: LD_INT 1
17235: ARRAY
17236: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17237: LD_VAR 0 5
17241: PUSH
17242: LD_INT 1
17244: ARRAY
17245: PPUSH
17246: CALL_OW 310
17250: IFFALSE 17265
// ComExitBuilding ( tmp [ 1 ] ) ;
17252: LD_VAR 0 5
17256: PUSH
17257: LD_INT 1
17259: ARRAY
17260: PPUSH
17261: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17265: LD_VAR 0 5
17269: PUSH
17270: LD_INT 1
17272: ARRAY
17273: PPUSH
17274: LD_VAR 0 4
17278: PPUSH
17279: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17283: LD_VAR 0 5
17287: PUSH
17288: LD_INT 1
17290: ARRAY
17291: PPUSH
17292: LD_INT 80
17294: PPUSH
17295: LD_INT 136
17297: PPUSH
17298: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17302: LD_VAR 0 5
17306: PUSH
17307: LD_INT 1
17309: ARRAY
17310: PPUSH
17311: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17315: LD_VAR 0 5
17319: PUSH
17320: LD_INT 1
17322: ARRAY
17323: PPUSH
17324: LD_INT 59
17326: PPUSH
17327: LD_INT 112
17329: PPUSH
17330: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17334: LD_VAR 0 5
17338: PUSH
17339: LD_INT 1
17341: ARRAY
17342: PPUSH
17343: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17347: LD_EXP 40
17351: PUSH
17352: LD_EXP 40
17356: PPUSH
17357: CALL_OW 255
17361: PUSH
17362: LD_INT 1
17364: EQUAL
17365: AND
17366: IFFALSE 17392
// begin Say ( Joan , D3W-Joan-1 ) ;
17368: LD_EXP 40
17372: PPUSH
17373: LD_STRING D3W-Joan-1
17375: PPUSH
17376: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17380: LD_EXP 39
17384: PPUSH
17385: LD_STRING D3W-JMM-1
17387: PPUSH
17388: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17392: LD_EXP 42
17396: PUSH
17397: LD_EXP 42
17401: PPUSH
17402: CALL_OW 255
17406: PUSH
17407: LD_INT 1
17409: EQUAL
17410: AND
17411: PUSH
17412: LD_EXP 42
17416: PUSH
17417: LD_EXP 59
17421: IN
17422: NOT
17423: AND
17424: IFFALSE 17450
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17426: LD_EXP 42
17430: PPUSH
17431: LD_STRING D3W-Lisa-1
17433: PPUSH
17434: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17438: LD_EXP 39
17442: PPUSH
17443: LD_STRING D3W-JMM-1
17445: PPUSH
17446: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17450: LD_EXP 54
17454: PUSH
17455: LD_EXP 54
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17495
// begin Say ( Connie , D3W-Con-1 ) ;
17471: LD_EXP 54
17475: PPUSH
17476: LD_STRING D3W-Con-1
17478: PPUSH
17479: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17483: LD_EXP 39
17487: PPUSH
17488: LD_STRING D3W-JMM-1
17490: PPUSH
17491: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17495: LD_EXP 42
17499: PUSH
17500: LD_EXP 59
17504: IN
17505: PUSH
17506: LD_EXP 42
17510: PPUSH
17511: CALL_OW 255
17515: PUSH
17516: LD_INT 1
17518: EQUAL
17519: AND
17520: IFFALSE 17536
// Say ( Lisa , D3nW-Lisa-1 ) else
17522: LD_EXP 42
17526: PPUSH
17527: LD_STRING D3nW-Lisa-1
17529: PPUSH
17530: CALL_OW 88
17534: GO 17780
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17536: LD_EXP 45
17540: PUSH
17541: LD_EXP 59
17545: IN
17546: PUSH
17547: LD_EXP 45
17551: PPUSH
17552: CALL_OW 255
17556: PUSH
17557: LD_INT 1
17559: EQUAL
17560: AND
17561: IFFALSE 17577
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17563: LD_EXP 45
17567: PPUSH
17568: LD_STRING D3nW-Cyrus-1
17570: PPUSH
17571: CALL_OW 88
17575: GO 17780
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17577: LD_EXP 44
17581: PUSH
17582: LD_EXP 59
17586: IN
17587: PUSH
17588: LD_EXP 44
17592: PPUSH
17593: CALL_OW 255
17597: PUSH
17598: LD_INT 1
17600: EQUAL
17601: AND
17602: IFFALSE 17618
// Say ( Bobby , D3nW-Bobby-1 ) else
17604: LD_EXP 44
17608: PPUSH
17609: LD_STRING D3nW-Bobby-1
17611: PPUSH
17612: CALL_OW 88
17616: GO 17780
// if Gary in vip and GetSide ( Gary ) = 1 then
17618: LD_EXP 51
17622: PUSH
17623: LD_EXP 59
17627: IN
17628: PUSH
17629: LD_EXP 51
17633: PPUSH
17634: CALL_OW 255
17638: PUSH
17639: LD_INT 1
17641: EQUAL
17642: AND
17643: IFFALSE 17659
// Say ( Gary , D3nW-Gary-1 ) else
17645: LD_EXP 51
17649: PPUSH
17650: LD_STRING D3nW-Gary-1
17652: PPUSH
17653: CALL_OW 88
17657: GO 17780
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17659: LD_EXP 43
17663: PUSH
17664: LD_EXP 59
17668: IN
17669: PUSH
17670: LD_EXP 43
17674: PPUSH
17675: CALL_OW 255
17679: PUSH
17680: LD_INT 1
17682: EQUAL
17683: AND
17684: IFFALSE 17700
// Say ( Donaldson , D3nW-Don-1 ) else
17686: LD_EXP 43
17690: PPUSH
17691: LD_STRING D3nW-Don-1
17693: PPUSH
17694: CALL_OW 88
17698: GO 17780
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17700: LD_EXP 50
17704: PUSH
17705: LD_EXP 59
17709: IN
17710: PUSH
17711: LD_EXP 50
17715: PPUSH
17716: CALL_OW 255
17720: PUSH
17721: LD_INT 1
17723: EQUAL
17724: AND
17725: IFFALSE 17741
// Say ( Cornel , D3nW-Corn-1 ) else
17727: LD_EXP 50
17731: PPUSH
17732: LD_STRING D3nW-Corn-1
17734: PPUSH
17735: CALL_OW 88
17739: GO 17780
// if Frank in vip and GetSide ( Frank ) = 1 then
17741: LD_EXP 52
17745: PUSH
17746: LD_EXP 59
17750: IN
17751: PUSH
17752: LD_EXP 52
17756: PPUSH
17757: CALL_OW 255
17761: PUSH
17762: LD_INT 1
17764: EQUAL
17765: AND
17766: IFFALSE 17780
// Say ( Frank , D3nW-Frank-1 ) ;
17768: LD_EXP 52
17772: PPUSH
17773: LD_STRING D3nW-Frank-1
17775: PPUSH
17776: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17780: LD_EXP 59
17784: PPUSH
17785: LD_INT 22
17787: PUSH
17788: LD_INT 1
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: PPUSH
17795: CALL_OW 72
17799: IFFALSE 17825
// begin Say ( JMM , D3nW-JMM-1 ) ;
17801: LD_EXP 39
17805: PPUSH
17806: LD_STRING D3nW-JMM-1
17808: PPUSH
17809: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D3nW-JMM-1a
17820: PPUSH
17821: CALL_OW 88
// end ; t := 0 0$00 ;
17825: LD_ADDR_VAR 0 3
17829: PUSH
17830: LD_INT 0
17832: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17833: LD_INT 35
17835: PPUSH
17836: CALL_OW 67
// t := t + 0 0$1 ;
17840: LD_ADDR_VAR 0 3
17844: PUSH
17845: LD_VAR 0 3
17849: PUSH
17850: LD_INT 35
17852: PLUS
17853: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17854: LD_INT 59
17856: PPUSH
17857: LD_INT 112
17859: PPUSH
17860: CALL_OW 428
17864: PUSH
17865: LD_VAR 0 3
17869: PUSH
17870: LD_INT 2100
17872: GREATER
17873: OR
17874: IFFALSE 17833
// activeAttacks := true ;
17876: LD_ADDR_EXP 16
17880: PUSH
17881: LD_INT 1
17883: ST_TO_ADDR
// end ;
17884: LD_VAR 0 1
17888: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17889: LD_INT 0
17891: PPUSH
// case question of 1 :
17892: LD_VAR 0 1
17896: PUSH
17897: LD_INT 1
17899: DOUBLE
17900: EQUAL
17901: IFTRUE 17905
17903: GO 17956
17905: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17906: LD_EXP 39
17910: PPUSH
17911: LD_STRING D2Mot-JMM-1
17913: PPUSH
17914: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17918: LD_EXP 58
17922: PPUSH
17923: LD_STRING D2Mot-Pow-1
17925: PPUSH
17926: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17930: LD_EXP 39
17934: PPUSH
17935: LD_STRING D2Mot-JMM-2
17937: PPUSH
17938: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17942: LD_EXP 58
17946: PPUSH
17947: LD_STRING D2Mot-Pow-2
17949: PPUSH
17950: CALL_OW 88
// end ; 2 :
17954: GO 18307
17956: LD_INT 2
17958: DOUBLE
17959: EQUAL
17960: IFTRUE 17964
17962: GO 18040
17964: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Rus-JMM-1
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Rus-Pow-1
17984: PPUSH
17985: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Rus-JMM-2
17996: PPUSH
17997: CALL_OW 88
// if not ( 3 in list_of_q ) then
18001: LD_INT 3
18003: PUSH
18004: LD_VAR 0 2
18008: IN
18009: NOT
18010: IFFALSE 18026
// Say ( Powell , D2Rus-Pow-2 ) else
18012: LD_EXP 58
18016: PPUSH
18017: LD_STRING D2Rus-Pow-2
18019: PPUSH
18020: CALL_OW 88
18024: GO 18038
// Say ( Powell , D2Rus-Pow-2a ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Rus-Pow-2a
18033: PPUSH
18034: CALL_OW 88
// end ; 3 :
18038: GO 18307
18040: LD_INT 3
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18133
18048: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Leg-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Leg-Pow-1
18068: PPUSH
18069: CALL_OW 88
// if 2 in list_of_q then
18073: LD_INT 2
18075: PUSH
18076: LD_VAR 0 2
18080: IN
18081: IFFALSE 18107
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18083: LD_EXP 39
18087: PPUSH
18088: LD_STRING D2Leg-JMM-2
18090: PPUSH
18091: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18095: LD_EXP 58
18099: PPUSH
18100: LD_STRING D2Leg-Pow-2
18102: PPUSH
18103: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Leg-JMM-3
18114: PPUSH
18115: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18119: LD_EXP 58
18123: PPUSH
18124: LD_STRING D2Leg-Pow-3
18126: PPUSH
18127: CALL_OW 88
// end ; 4 :
18131: GO 18307
18133: LD_INT 4
18135: DOUBLE
18136: EQUAL
18137: IFTRUE 18141
18139: GO 18216
18141: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18142: LD_EXP 39
18146: PPUSH
18147: LD_STRING D2Ar-JMM-1
18149: PPUSH
18150: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18154: LD_EXP 58
18158: PPUSH
18159: LD_STRING D2Ar-Pow-1
18161: PPUSH
18162: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18166: LD_EXP 39
18170: PPUSH
18171: LD_STRING D2Ar-JMM-2
18173: PPUSH
18174: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18178: LD_EXP 58
18182: PPUSH
18183: LD_STRING D2Ar-Pow-2
18185: PPUSH
18186: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18190: LD_EXP 39
18194: PPUSH
18195: LD_STRING D2Ar-JMM-3
18197: PPUSH
18198: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18202: LD_EXP 58
18206: PPUSH
18207: LD_STRING D2Ar-Pow-3
18209: PPUSH
18210: CALL_OW 88
// end ; 5 :
18214: GO 18307
18216: LD_INT 5
18218: DOUBLE
18219: EQUAL
18220: IFTRUE 18224
18222: GO 18239
18224: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18225: LD_EXP 39
18229: PPUSH
18230: LD_STRING D2Conf-JMM-1
18232: PPUSH
18233: CALL_OW 88
18237: GO 18307
18239: LD_INT 6
18241: DOUBLE
18242: EQUAL
18243: IFTRUE 18247
18245: GO 18306
18247: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18248: LD_EXP 39
18252: PPUSH
18253: LD_STRING D2Com-JMM-1
18255: PPUSH
18256: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18260: LD_EXP 58
18264: PPUSH
18265: LD_STRING D2Com-Pow-1
18267: PPUSH
18268: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18272: LD_EXP 39
18276: PPUSH
18277: LD_STRING D2Com-JMM-2
18279: PPUSH
18280: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18284: LD_EXP 58
18288: PPUSH
18289: LD_STRING D2Com-Pow-2
18291: PPUSH
18292: CALL_OW 88
// powellAngerQuery := true ;
18296: LD_ADDR_EXP 36
18300: PUSH
18301: LD_INT 1
18303: ST_TO_ADDR
// end ; end ;
18304: GO 18307
18306: POP
// end ;
18307: LD_VAR 0 3
18311: RET
// every 0 0$5 trigger missionStart do var tmp ;
18312: LD_EXP 13
18316: IFFALSE 18599
18318: GO 18320
18320: DISABLE
18321: LD_INT 0
18323: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18324: LD_INT 35
18326: PPUSH
18327: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18331: LD_INT 14
18333: PPUSH
18334: LD_INT 22
18336: PUSH
18337: LD_INT 1
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: PPUSH
18344: CALL_OW 70
18348: PUSH
18349: LD_EXP 15
18353: PUSH
18354: LD_INT 2
18356: PUSH
18357: LD_INT 3
18359: PUSH
18360: LD_INT 4
18362: PUSH
18363: LD_INT 5
18365: PUSH
18366: EMPTY
18367: LIST
18368: LIST
18369: LIST
18370: LIST
18371: IN
18372: AND
18373: IFFALSE 18589
// begin powellAnger := powellAnger + 1 ;
18375: LD_ADDR_EXP 17
18379: PUSH
18380: LD_EXP 17
18384: PUSH
18385: LD_INT 1
18387: PLUS
18388: ST_TO_ADDR
// Video ( true ) ;
18389: LD_INT 1
18391: PPUSH
18392: CALL 103293 0 1
// CenterNowOnUnits ( tmp ) ;
18396: LD_VAR 0 1
18400: PPUSH
18401: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18405: LD_INT 14
18407: PPUSH
18408: LD_INT 22
18410: PUSH
18411: LD_INT 1
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: PPUSH
18418: CALL_OW 70
18422: PPUSH
18423: LD_INT 86
18425: PPUSH
18426: LD_INT 133
18428: PPUSH
18429: CALL_OW 111
// async ;
18433: ASYNC
// case powellAnger of 1 :
18434: LD_EXP 17
18438: PUSH
18439: LD_INT 1
18441: DOUBLE
18442: EQUAL
18443: IFTRUE 18447
18445: GO 18462
18447: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18448: LD_EXP 58
18452: PPUSH
18453: LD_STRING DBack1-Pow-1
18455: PPUSH
18456: CALL_OW 88
18460: GO 18509
18462: LD_INT 2
18464: DOUBLE
18465: EQUAL
18466: IFTRUE 18470
18468: GO 18485
18470: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18471: LD_EXP 58
18475: PPUSH
18476: LD_STRING DBack2-Pow-1
18478: PPUSH
18479: CALL_OW 88
18483: GO 18509
18485: LD_INT 3
18487: DOUBLE
18488: EQUAL
18489: IFTRUE 18493
18491: GO 18508
18493: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18494: LD_EXP 58
18498: PPUSH
18499: LD_STRING DBack3-Pow-1
18501: PPUSH
18502: CALL_OW 88
18506: GO 18509
18508: POP
// sync ;
18509: SYNC
// repeat wait ( 0 0$1 ) ;
18510: LD_INT 35
18512: PPUSH
18513: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18517: LD_INT 14
18519: PPUSH
18520: LD_INT 22
18522: PUSH
18523: LD_INT 1
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PPUSH
18530: CALL_OW 70
18534: PPUSH
18535: LD_INT 86
18537: PPUSH
18538: LD_INT 133
18540: PPUSH
18541: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18545: LD_INT 14
18547: PPUSH
18548: LD_INT 22
18550: PUSH
18551: LD_INT 1
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PPUSH
18558: CALL_OW 70
18562: NOT
18563: IFFALSE 18510
// if powellAnger >= 3 then
18565: LD_EXP 17
18569: PUSH
18570: LD_INT 3
18572: GREATEREQUAL
18573: IFFALSE 18582
// YouLost ( Dismissed ) ;
18575: LD_STRING Dismissed
18577: PPUSH
18578: CALL_OW 104
// Video ( false ) ;
18582: LD_INT 0
18584: PPUSH
18585: CALL 103293 0 1
// end ; until missionStage > 5 ;
18589: LD_EXP 15
18593: PUSH
18594: LD_INT 5
18596: GREATER
18597: IFFALSE 18324
// end ;
18599: PPOPN 1
18601: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18602: LD_EXP 13
18606: PUSH
18607: LD_INT 22
18609: PUSH
18610: LD_INT 4
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 21
18619: PUSH
18620: LD_INT 2
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: PPUSH
18631: CALL_OW 69
18635: PUSH
18636: LD_INT 4
18638: GREATEREQUAL
18639: AND
18640: PUSH
18641: LD_EXP 15
18645: PUSH
18646: LD_INT 2
18648: EQUAL
18649: AND
18650: IFFALSE 20473
18652: GO 18654
18654: DISABLE
18655: LD_INT 0
18657: PPUSH
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
// begin missionStage := 3 ;
18665: LD_ADDR_EXP 15
18669: PUSH
18670: LD_INT 3
18672: ST_TO_ADDR
// retreat := false ;
18673: LD_ADDR_VAR 0 4
18677: PUSH
18678: LD_INT 0
18680: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18681: LD_ADDR_VAR 0 5
18685: PUSH
18686: LD_INT 22
18688: PUSH
18689: LD_INT 4
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: PUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 4
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: PPUSH
18710: CALL_OW 69
18714: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18715: LD_ADDR_VAR 0 6
18719: PUSH
18720: LD_INT 22
18722: PUSH
18723: LD_INT 4
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: PUSH
18730: LD_INT 30
18732: PUSH
18733: LD_INT 5
18735: PUSH
18736: EMPTY
18737: LIST
18738: LIST
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PPUSH
18744: CALL_OW 69
18748: ST_TO_ADDR
// if not bar then
18749: LD_VAR 0 6
18753: NOT
18754: IFFALSE 18807
// begin repeat wait ( 0 0$1 ) ;
18756: LD_INT 35
18758: PPUSH
18759: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18763: LD_INT 22
18765: PUSH
18766: LD_INT 4
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: PUSH
18773: LD_INT 3
18775: PUSH
18776: LD_INT 57
18778: PUSH
18779: EMPTY
18780: LIST
18781: PUSH
18782: EMPTY
18783: LIST
18784: LIST
18785: PUSH
18786: LD_INT 30
18788: PUSH
18789: LD_INT 5
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: PUSH
18796: EMPTY
18797: LIST
18798: LIST
18799: LIST
18800: PPUSH
18801: CALL_OW 69
18805: IFFALSE 18756
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18807: LD_ADDR_VAR 0 6
18811: PUSH
18812: LD_INT 22
18814: PUSH
18815: LD_INT 4
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 30
18824: PUSH
18825: LD_INT 5
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: PUSH
18832: EMPTY
18833: LIST
18834: LIST
18835: PPUSH
18836: CALL_OW 69
18840: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18841: LD_INT 35
18843: PPUSH
18844: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18848: LD_EXP 134
18852: PUSH
18853: LD_INT 4
18855: ARRAY
18856: PUSH
18857: LD_INT 4
18859: GREATEREQUAL
18860: IFFALSE 18841
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18862: LD_ADDR_VAR 0 2
18866: PUSH
18867: LD_INT 22
18869: PUSH
18870: LD_INT 4
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PUSH
18877: LD_INT 2
18879: PUSH
18880: LD_INT 25
18882: PUSH
18883: LD_INT 1
18885: PUSH
18886: EMPTY
18887: LIST
18888: LIST
18889: PUSH
18890: LD_INT 25
18892: PUSH
18893: LD_INT 2
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: PUSH
18900: LD_INT 25
18902: PUSH
18903: LD_INT 3
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: PUSH
18910: LD_INT 25
18912: PUSH
18913: LD_INT 4
18915: PUSH
18916: EMPTY
18917: LIST
18918: LIST
18919: PUSH
18920: LD_INT 25
18922: PUSH
18923: LD_INT 5
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: LIST
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: PPUSH
18942: CALL_OW 69
18946: PUSH
18947: LD_EXP 58
18951: PUSH
18952: LD_EXP 59
18956: ADD
18957: DIFF
18958: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18959: LD_ADDR_VAR 0 3
18963: PUSH
18964: LD_VAR 0 2
18968: PPUSH
18969: LD_INT 26
18971: PUSH
18972: LD_INT 1
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PPUSH
18979: CALL_OW 72
18983: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18984: LD_ADDR_VAR 0 2
18988: PUSH
18989: LD_VAR 0 2
18993: PUSH
18994: LD_VAR 0 3
18998: DIFF
18999: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
19000: LD_ADDR_VAR 0 2
19004: PUSH
19005: LD_VAR 0 2
19009: PPUSH
19010: LD_INT 1
19012: PPUSH
19013: CALL 101830 0 2
19017: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
19018: LD_ADDR_VAR 0 3
19022: PUSH
19023: LD_VAR 0 3
19027: PPUSH
19028: LD_INT 1
19030: PPUSH
19031: CALL 101830 0 2
19035: ST_TO_ADDR
// for i = 1 to 4 do
19036: LD_ADDR_VAR 0 1
19040: PUSH
19041: DOUBLE
19042: LD_INT 1
19044: DEC
19045: ST_TO_ADDR
19046: LD_INT 4
19048: PUSH
19049: FOR_TO
19050: IFFALSE 19216
// begin if tmp2 then
19052: LD_VAR 0 3
19056: IFFALSE 19137
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19058: LD_ADDR_EXP 18
19062: PUSH
19063: LD_EXP 18
19067: PPUSH
19068: LD_INT 1
19070: PPUSH
19071: LD_EXP 18
19075: PUSH
19076: LD_INT 1
19078: ARRAY
19079: PUSH
19080: LD_VAR 0 3
19084: PUSH
19085: LD_VAR 0 3
19089: ARRAY
19090: ADD
19091: PPUSH
19092: CALL_OW 1
19096: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19097: LD_VAR 0 3
19101: PUSH
19102: LD_VAR 0 3
19106: ARRAY
19107: PPUSH
19108: LD_INT 1
19110: PPUSH
19111: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19115: LD_ADDR_VAR 0 3
19119: PUSH
19120: LD_VAR 0 3
19124: PPUSH
19125: LD_VAR 0 3
19129: PPUSH
19130: CALL_OW 3
19134: ST_TO_ADDR
// end else
19135: GO 19214
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19137: LD_ADDR_EXP 18
19141: PUSH
19142: LD_EXP 18
19146: PPUSH
19147: LD_INT 1
19149: PPUSH
19150: LD_EXP 18
19154: PUSH
19155: LD_INT 1
19157: ARRAY
19158: PUSH
19159: LD_VAR 0 2
19163: PUSH
19164: LD_VAR 0 2
19168: ARRAY
19169: ADD
19170: PPUSH
19171: CALL_OW 1
19175: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19176: LD_VAR 0 2
19180: PUSH
19181: LD_VAR 0 2
19185: ARRAY
19186: PPUSH
19187: LD_INT 1
19189: PPUSH
19190: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19194: LD_ADDR_VAR 0 2
19198: PUSH
19199: LD_VAR 0 2
19203: PPUSH
19204: LD_VAR 0 2
19208: PPUSH
19209: CALL_OW 3
19213: ST_TO_ADDR
// end ; end ;
19214: GO 19049
19216: POP
19217: POP
// if tmp2 then
19218: LD_VAR 0 3
19222: IFFALSE 19240
// tmp := tmp union tmp2 ;
19224: LD_ADDR_VAR 0 2
19228: PUSH
19229: LD_VAR 0 2
19233: PUSH
19234: LD_VAR 0 3
19238: UNION
19239: ST_TO_ADDR
// for i = 1 to 4 do
19240: LD_ADDR_VAR 0 1
19244: PUSH
19245: DOUBLE
19246: LD_INT 1
19248: DEC
19249: ST_TO_ADDR
19250: LD_INT 4
19252: PUSH
19253: FOR_TO
19254: IFFALSE 19303
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19256: LD_ADDR_EXP 18
19260: PUSH
19261: LD_EXP 18
19265: PPUSH
19266: LD_INT 2
19268: PPUSH
19269: LD_EXP 18
19273: PUSH
19274: LD_INT 2
19276: ARRAY
19277: PUSH
19278: LD_VAR 0 2
19282: PUSH
19283: LD_VAR 0 2
19287: PUSH
19288: LD_VAR 0 1
19292: MINUS
19293: ARRAY
19294: ADD
19295: PPUSH
19296: CALL_OW 1
19300: ST_TO_ADDR
19301: GO 19253
19303: POP
19304: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19305: LD_ADDR_EXP 115
19309: PUSH
19310: LD_EXP 115
19314: PPUSH
19315: LD_INT 4
19317: PPUSH
19318: LD_EXP 115
19322: PUSH
19323: LD_INT 4
19325: ARRAY
19326: PUSH
19327: LD_EXP 18
19331: PUSH
19332: LD_INT 1
19334: ARRAY
19335: DIFF
19336: PPUSH
19337: CALL_OW 1
19341: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19342: LD_VAR 0 5
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: PPUSH
19351: CALL_OW 313
19355: IFFALSE 19410
// begin for i in UnitsInside ( arm [ 1 ] ) do
19357: LD_ADDR_VAR 0 1
19361: PUSH
19362: LD_VAR 0 5
19366: PUSH
19367: LD_INT 1
19369: ARRAY
19370: PPUSH
19371: CALL_OW 313
19375: PUSH
19376: FOR_IN
19377: IFFALSE 19408
// begin ComExitBuilding ( i ) ;
19379: LD_VAR 0 1
19383: PPUSH
19384: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19388: LD_VAR 0 1
19392: PPUSH
19393: LD_VAR 0 6
19397: PUSH
19398: LD_INT 1
19400: ARRAY
19401: PPUSH
19402: CALL_OW 180
// end ;
19406: GO 19376
19408: POP
19409: POP
// end ; wait ( 0 0$3 ) ;
19410: LD_INT 105
19412: PPUSH
19413: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19417: LD_ADDR_VAR 0 1
19421: PUSH
19422: LD_EXP 18
19426: PUSH
19427: LD_INT 1
19429: ARRAY
19430: PUSH
19431: FOR_IN
19432: IFFALSE 19539
// begin if IsInUnit ( i ) then
19434: LD_VAR 0 1
19438: PPUSH
19439: CALL_OW 310
19443: IFFALSE 19454
// ComExitBuilding ( i ) ;
19445: LD_VAR 0 1
19449: PPUSH
19450: CALL_OW 122
// if GetClass ( i ) <> 1 then
19454: LD_VAR 0 1
19458: PPUSH
19459: CALL_OW 257
19463: PUSH
19464: LD_INT 1
19466: NONEQUAL
19467: IFFALSE 19508
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19469: LD_VAR 0 1
19473: PPUSH
19474: LD_VAR 0 5
19478: PUSH
19479: LD_INT 1
19481: ARRAY
19482: PPUSH
19483: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19487: LD_VAR 0 1
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL_OW 183
// AddComExitBuilding ( i ) ;
19499: LD_VAR 0 1
19503: PPUSH
19504: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19508: LD_VAR 0 1
19512: PPUSH
19513: LD_INT 60
19515: PPUSH
19516: LD_INT 94
19518: PPUSH
19519: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19523: LD_VAR 0 1
19527: PPUSH
19528: LD_EXP 58
19532: PPUSH
19533: CALL_OW 179
// end ;
19537: GO 19431
19539: POP
19540: POP
// wait ( 0 0$15 ) ;
19541: LD_INT 525
19543: PPUSH
19544: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19548: LD_EXP 58
19552: PPUSH
19553: LD_STRING D4-Pow-1
19555: PPUSH
19556: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19560: LD_ADDR_VAR 0 2
19564: PUSH
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PPUSH
19574: LD_INT 26
19576: PUSH
19577: LD_INT 1
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PPUSH
19584: CALL_OW 72
19588: ST_TO_ADDR
// if tmp then
19589: LD_VAR 0 2
19593: IFFALSE 19611
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19595: LD_VAR 0 2
19599: PUSH
19600: LD_INT 1
19602: ARRAY
19603: PPUSH
19604: LD_STRING D4-Sol1-1
19606: PPUSH
19607: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19611: LD_EXP 58
19615: PPUSH
19616: LD_STRING D4-Pow-2
19618: PPUSH
19619: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19623: LD_ADDR_VAR 0 1
19627: PUSH
19628: DOUBLE
19629: LD_INT 1
19631: DEC
19632: ST_TO_ADDR
19633: LD_EXP 18
19637: PUSH
19638: LD_INT 1
19640: ARRAY
19641: PUSH
19642: FOR_TO
19643: IFFALSE 19736
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19645: LD_EXP 18
19649: PUSH
19650: LD_INT 1
19652: ARRAY
19653: PUSH
19654: LD_VAR 0 1
19658: ARRAY
19659: PPUSH
19660: LD_EXP 134
19664: PUSH
19665: LD_INT 4
19667: ARRAY
19668: PUSH
19669: LD_INT 1
19671: ARRAY
19672: PPUSH
19673: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19677: LD_ADDR_EXP 134
19681: PUSH
19682: LD_EXP 134
19686: PPUSH
19687: LD_INT 4
19689: PPUSH
19690: LD_EXP 134
19694: PUSH
19695: LD_INT 4
19697: ARRAY
19698: PPUSH
19699: LD_INT 1
19701: PPUSH
19702: CALL_OW 3
19706: PPUSH
19707: CALL_OW 1
19711: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19712: LD_INT 8
19714: PPUSH
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PUSH
19724: LD_VAR 0 1
19728: ARRAY
19729: PPUSH
19730: CALL_OW 471
// end ;
19734: GO 19642
19736: POP
19737: POP
// repeat wait ( 0 0$1 ) ;
19738: LD_INT 35
19740: PPUSH
19741: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19745: LD_EXP 18
19749: PUSH
19750: LD_INT 1
19752: ARRAY
19753: PPUSH
19754: LD_INT 55
19756: PUSH
19757: EMPTY
19758: LIST
19759: PPUSH
19760: CALL_OW 72
19764: PUSH
19765: LD_INT 4
19767: GREATEREQUAL
19768: IFFALSE 19738
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19770: LD_EXP 18
19774: PUSH
19775: LD_INT 1
19777: ARRAY
19778: PPUSH
19779: LD_INT 69
19781: PPUSH
19782: LD_INT 94
19784: PPUSH
19785: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19789: LD_EXP 18
19793: PUSH
19794: LD_INT 1
19796: ARRAY
19797: PPUSH
19798: LD_INT 82
19800: PPUSH
19801: LD_INT 83
19803: PPUSH
19804: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19808: LD_EXP 18
19812: PUSH
19813: LD_INT 1
19815: ARRAY
19816: PPUSH
19817: LD_INT 77
19819: PPUSH
19820: LD_INT 69
19822: PPUSH
19823: CALL_OW 174
// repeat wait ( 3 ) ;
19827: LD_INT 3
19829: PPUSH
19830: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19834: LD_ADDR_VAR 0 1
19838: PUSH
19839: LD_EXP 18
19843: PUSH
19844: LD_INT 1
19846: ARRAY
19847: PUSH
19848: FOR_IN
19849: IFFALSE 19985
// begin if GetLives ( i ) < 990 then
19851: LD_VAR 0 1
19855: PPUSH
19856: CALL_OW 256
19860: PUSH
19861: LD_INT 990
19863: LESS
19864: IFFALSE 19878
// SetLives ( i , 1000 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_INT 1000
19873: PPUSH
19874: CALL_OW 234
// if not IsInUnit ( i ) then
19878: LD_VAR 0 1
19882: PPUSH
19883: CALL_OW 310
19887: NOT
19888: IFFALSE 19983
// begin if not HasTask ( i ) then
19890: LD_VAR 0 1
19894: PPUSH
19895: CALL_OW 314
19899: NOT
19900: IFFALSE 19917
// ComMoveXY ( i , 64 , 93 ) ;
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_INT 64
19909: PPUSH
19910: LD_INT 93
19912: PPUSH
19913: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19917: LD_VAR 0 4
19921: NOT
19922: PUSH
19923: LD_VAR 0 1
19927: PPUSH
19928: CALL_OW 258
19932: PUSH
19933: LD_INT 1
19935: EQUAL
19936: AND
19937: IFFALSE 19983
// begin retreat := true ;
19939: LD_ADDR_VAR 0 4
19943: PUSH
19944: LD_INT 1
19946: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 2
19954: PPUSH
19955: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19959: LD_VAR 0 1
19963: PPUSH
19964: LD_STRING D4a-Sol1-1
19966: PPUSH
19967: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19971: LD_EXP 58
19975: PPUSH
19976: LD_STRING D4a-Pow-1
19978: PPUSH
19979: CALL_OW 88
// end ; end ; end ;
19983: GO 19848
19985: POP
19986: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19987: LD_EXP 18
19991: PUSH
19992: LD_INT 1
19994: ARRAY
19995: PPUSH
19996: LD_INT 95
19998: PUSH
19999: LD_INT 9
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: LD_INT 3
20008: PUSH
20009: LD_INT 55
20011: PUSH
20012: EMPTY
20013: LIST
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: PPUSH
20023: CALL_OW 72
20027: PUSH
20028: LD_INT 4
20030: GREATEREQUAL
20031: IFFALSE 19827
// for i in powellSquadAttack [ 1 ] do
20033: LD_ADDR_VAR 0 1
20037: PUSH
20038: LD_EXP 18
20042: PUSH
20043: LD_INT 1
20045: ARRAY
20046: PUSH
20047: FOR_IN
20048: IFFALSE 20184
// begin if GetTag ( i ) = 2 then
20050: LD_VAR 0 1
20054: PPUSH
20055: CALL_OW 110
20059: PUSH
20060: LD_INT 2
20062: EQUAL
20063: IFFALSE 20125
// begin ComMoveXY ( i , 60 , 94 ) ;
20065: LD_VAR 0 1
20069: PPUSH
20070: LD_INT 60
20072: PPUSH
20073: LD_INT 94
20075: PPUSH
20076: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20080: LD_VAR 0 1
20084: PPUSH
20085: LD_EXP 58
20089: PPUSH
20090: CALL_OW 179
// wait ( 0 0$3 ) ;
20094: LD_INT 105
20096: PPUSH
20097: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20101: LD_VAR 0 1
20105: PPUSH
20106: LD_STRING D4a-Sol1-2
20108: PPUSH
20109: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20113: LD_EXP 58
20117: PPUSH
20118: LD_STRING D4a-Pow-2
20120: PPUSH
20121: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20125: LD_VAR 0 1
20129: PPUSH
20130: LD_INT 0
20132: PPUSH
20133: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20137: LD_ADDR_EXP 115
20141: PUSH
20142: LD_EXP 115
20146: PPUSH
20147: LD_INT 4
20149: PPUSH
20150: LD_EXP 115
20154: PUSH
20155: LD_INT 4
20157: ARRAY
20158: PUSH
20159: LD_VAR 0 1
20163: UNION
20164: PPUSH
20165: CALL_OW 1
20169: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20170: LD_INT 8
20172: PPUSH
20173: LD_VAR 0 1
20177: PPUSH
20178: CALL_OW 472
// end ;
20182: GO 20047
20184: POP
20185: POP
// wait ( 4 4$00 ) ;
20186: LD_INT 8400
20188: PPUSH
20189: CALL_OW 67
// uc_side := 6 ;
20193: LD_ADDR_OWVAR 20
20197: PUSH
20198: LD_INT 6
20200: ST_TO_ADDR
// uc_nation := 3 ;
20201: LD_ADDR_OWVAR 21
20205: PUSH
20206: LD_INT 3
20208: ST_TO_ADDR
// ru := [ ] ;
20209: LD_ADDR_VAR 0 7
20213: PUSH
20214: EMPTY
20215: ST_TO_ADDR
// for i = 1 to 4 do
20216: LD_ADDR_VAR 0 1
20220: PUSH
20221: DOUBLE
20222: LD_INT 1
20224: DEC
20225: ST_TO_ADDR
20226: LD_INT 4
20228: PUSH
20229: FOR_TO
20230: IFFALSE 20331
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20232: LD_INT 22
20234: PPUSH
20235: LD_INT 1
20237: PPUSH
20238: LD_INT 3
20240: PPUSH
20241: LD_INT 43
20243: PUSH
20244: LD_INT 44
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 1
20253: PPUSH
20254: LD_INT 2
20256: PPUSH
20257: CALL_OW 12
20261: ARRAY
20262: PPUSH
20263: LD_INT 89
20265: PPUSH
20266: CALL 70937 0 5
// un := CreateVehicle ;
20270: LD_ADDR_VAR 0 8
20274: PUSH
20275: CALL_OW 45
20279: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20280: LD_VAR 0 8
20284: PPUSH
20285: LD_INT 4
20287: PPUSH
20288: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20292: LD_VAR 0 8
20296: PPUSH
20297: LD_INT 136
20299: PPUSH
20300: LD_INT 90
20302: PPUSH
20303: LD_INT 8
20305: PPUSH
20306: LD_INT 0
20308: PPUSH
20309: CALL_OW 50
// ru := ru ^ un ;
20313: LD_ADDR_VAR 0 7
20317: PUSH
20318: LD_VAR 0 7
20322: PUSH
20323: LD_VAR 0 8
20327: ADD
20328: ST_TO_ADDR
// end ;
20329: GO 20229
20331: POP
20332: POP
// if ru then
20333: LD_VAR 0 7
20337: IFFALSE 20354
// ComAgressiveMove ( ru , 80 , 92 ) ;
20339: LD_VAR 0 7
20343: PPUSH
20344: LD_INT 80
20346: PPUSH
20347: LD_INT 92
20349: PPUSH
20350: CALL_OW 114
// wait ( 8 8$00 ) ;
20354: LD_INT 16800
20356: PPUSH
20357: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20361: LD_INT 4
20363: PPUSH
20364: LD_INT 3
20366: PUSH
20367: LD_INT 1
20369: PUSH
20370: LD_INT 1
20372: PUSH
20373: LD_INT 5
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: LIST
20380: LIST
20381: PUSH
20382: LD_INT 4
20384: PUSH
20385: LD_INT 1
20387: PUSH
20388: LD_INT 1
20390: PUSH
20391: LD_INT 6
20393: PUSH
20394: EMPTY
20395: LIST
20396: LIST
20397: LIST
20398: LIST
20399: PUSH
20400: LD_INT 4
20402: PUSH
20403: LD_INT 1
20405: PUSH
20406: LD_INT 1
20408: PUSH
20409: LD_INT 7
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: LIST
20416: LIST
20417: PUSH
20418: LD_INT 3
20420: PUSH
20421: LD_INT 1
20423: PUSH
20424: LD_INT 1
20426: PUSH
20427: LD_INT 7
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 3
20438: PUSH
20439: LD_INT 1
20441: PUSH
20442: LD_INT 1
20444: PUSH
20445: LD_INT 5
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: LIST
20453: PUSH
20454: EMPTY
20455: LIST
20456: LIST
20457: LIST
20458: LIST
20459: LIST
20460: PPUSH
20461: CALL 59466 0 2
// missionStage := 4 ;
20465: LD_ADDR_EXP 15
20469: PUSH
20470: LD_INT 4
20472: ST_TO_ADDR
// end ;
20473: PPOPN 8
20475: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20476: LD_EXP 15
20480: PUSH
20481: LD_INT 4
20483: EQUAL
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 2
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: EMPTY
20506: LIST
20507: LIST
20508: PPUSH
20509: CALL_OW 69
20513: PUSH
20514: LD_INT 5
20516: GREATEREQUAL
20517: AND
20518: IFFALSE 24646
20520: GO 20522
20522: DISABLE
20523: LD_INT 0
20525: PPUSH
20526: PPUSH
20527: PPUSH
20528: PPUSH
20529: PPUSH
20530: PPUSH
20531: PPUSH
20532: PPUSH
20533: PPUSH
20534: PPUSH
20535: PPUSH
20536: PPUSH
20537: PPUSH
// begin wait ( 0 0$30 ) ;
20538: LD_INT 1050
20540: PPUSH
20541: CALL_OW 67
// missionStage := 5 ;
20545: LD_ADDR_EXP 15
20549: PUSH
20550: LD_INT 5
20552: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20553: LD_ADDR_VAR 0 10
20557: PUSH
20558: LD_INT 22
20560: PUSH
20561: LD_INT 4
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: LD_INT 2
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 4
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: LD_INT 30
20583: PUSH
20584: LD_INT 5
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: PUSH
20591: EMPTY
20592: LIST
20593: LIST
20594: LIST
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: PPUSH
20600: CALL_OW 69
20604: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20605: LD_ADDR_VAR 0 6
20609: PUSH
20610: LD_INT 22
20612: PUSH
20613: LD_INT 4
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 21
20622: PUSH
20623: LD_INT 1
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: PUSH
20630: LD_INT 3
20632: PUSH
20633: LD_INT 25
20635: PUSH
20636: LD_INT 16
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: PUSH
20647: LD_INT 3
20649: PUSH
20650: LD_INT 25
20652: PUSH
20653: LD_INT 12
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: PPUSH
20670: CALL_OW 69
20674: PUSH
20675: LD_EXP 58
20679: DIFF
20680: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20681: LD_ADDR_VAR 0 9
20685: PUSH
20686: LD_INT 22
20688: PUSH
20689: LD_INT 4
20691: PUSH
20692: EMPTY
20693: LIST
20694: LIST
20695: PUSH
20696: LD_INT 30
20698: PUSH
20699: LD_INT 3
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: PUSH
20706: EMPTY
20707: LIST
20708: LIST
20709: PPUSH
20710: CALL_OW 69
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20719: LD_INT 35
20721: PPUSH
20722: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20726: LD_EXP 134
20730: PUSH
20731: LD_INT 4
20733: ARRAY
20734: PUSH
20735: LD_INT 5
20737: GREATEREQUAL
20738: PUSH
20739: LD_EXP 134
20743: PUSH
20744: LD_INT 4
20746: ARRAY
20747: PPUSH
20748: LD_INT 58
20750: PUSH
20751: EMPTY
20752: LIST
20753: PPUSH
20754: CALL_OW 72
20758: PUSH
20759: LD_INT 5
20761: GREATEREQUAL
20762: AND
20763: IFFALSE 20719
// powellAllowRetreat := false ;
20765: LD_ADDR_EXP 19
20769: PUSH
20770: LD_INT 0
20772: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20773: LD_INT 700
20775: PPUSH
20776: CALL_OW 67
// activeAttacks := false ;
20780: LD_ADDR_EXP 16
20784: PUSH
20785: LD_INT 0
20787: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20788: LD_INT 35
20790: PPUSH
20791: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20795: LD_INT 22
20797: PUSH
20798: LD_INT 6
20800: PUSH
20801: EMPTY
20802: LIST
20803: LIST
20804: PPUSH
20805: CALL_OW 69
20809: PUSH
20810: LD_INT 0
20812: EQUAL
20813: IFFALSE 20788
// tmp := mc_vehicles [ 4 ] ;
20815: LD_ADDR_VAR 0 3
20819: PUSH
20820: LD_EXP 134
20824: PUSH
20825: LD_INT 4
20827: ARRAY
20828: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20829: LD_ADDR_VAR 0 1
20833: PUSH
20834: DOUBLE
20835: LD_INT 1
20837: DEC
20838: ST_TO_ADDR
20839: LD_EXP 18
20843: PUSH
20844: FOR_TO
20845: IFFALSE 21106
// begin for j in powellSquadAttack [ i ] do
20847: LD_ADDR_VAR 0 2
20851: PUSH
20852: LD_EXP 18
20856: PUSH
20857: LD_VAR 0 1
20861: ARRAY
20862: PUSH
20863: FOR_IN
20864: IFFALSE 21102
// begin forces := forces diff j ;
20866: LD_ADDR_VAR 0 6
20870: PUSH
20871: LD_VAR 0 6
20875: PUSH
20876: LD_VAR 0 2
20880: DIFF
20881: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20882: LD_VAR 0 2
20886: PPUSH
20887: LD_INT 1
20889: PPUSH
20890: CALL_OW 109
// wait ( 0 0$2 ) ;
20894: LD_INT 70
20896: PPUSH
20897: CALL_OW 67
// if IsInUnit ( j ) then
20901: LD_VAR 0 2
20905: PPUSH
20906: CALL_OW 310
20910: IFFALSE 20921
// ComExitBuilding ( j ) ;
20912: LD_VAR 0 2
20916: PPUSH
20917: CALL_OW 122
// if GetClass ( j ) <> 1 then
20921: LD_VAR 0 2
20925: PPUSH
20926: CALL_OW 257
20930: PUSH
20931: LD_INT 1
20933: NONEQUAL
20934: IFFALSE 21014
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20936: LD_VAR 0 10
20940: PUSH
20941: LD_INT 1
20943: ARRAY
20944: PPUSH
20945: CALL_OW 313
20949: PUSH
20950: LD_INT 5
20952: GREATEREQUAL
20953: IFFALSE 20975
// AddComEnterUnit ( j , arm [ 2 ] ) else
20955: LD_VAR 0 2
20959: PPUSH
20960: LD_VAR 0 10
20964: PUSH
20965: LD_INT 2
20967: ARRAY
20968: PPUSH
20969: CALL_OW 180
20973: GO 20993
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20975: LD_VAR 0 2
20979: PPUSH
20980: LD_VAR 0 10
20984: PUSH
20985: LD_INT 1
20987: ARRAY
20988: PPUSH
20989: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20993: LD_VAR 0 2
20997: PPUSH
20998: LD_INT 1
21000: PPUSH
21001: CALL_OW 183
// AddComExitBuilding ( j ) ;
21005: LD_VAR 0 2
21009: PPUSH
21010: CALL_OW 182
// end ; if i = 2 then
21014: LD_VAR 0 1
21018: PUSH
21019: LD_INT 2
21021: EQUAL
21022: IFFALSE 21039
// AddComMoveXY ( j , 61 , 93 ) ;
21024: LD_VAR 0 2
21028: PPUSH
21029: LD_INT 61
21031: PPUSH
21032: LD_INT 93
21034: PPUSH
21035: CALL_OW 171
// if i = 1 then
21039: LD_VAR 0 1
21043: PUSH
21044: LD_INT 1
21046: EQUAL
21047: IFFALSE 21100
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21049: LD_VAR 0 2
21053: PPUSH
21054: LD_VAR 0 3
21058: PUSH
21059: LD_INT 1
21061: ARRAY
21062: PPUSH
21063: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21067: LD_ADDR_VAR 0 3
21071: PUSH
21072: LD_VAR 0 3
21076: PPUSH
21077: LD_INT 1
21079: PPUSH
21080: CALL_OW 3
21084: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21085: LD_VAR 0 2
21089: PPUSH
21090: LD_INT 69
21092: PPUSH
21093: LD_INT 94
21095: PPUSH
21096: CALL_OW 171
// end ; end ;
21100: GO 20863
21102: POP
21103: POP
// end ;
21104: GO 20844
21106: POP
21107: POP
// wait ( 0 0$55 ) ;
21108: LD_INT 1925
21110: PPUSH
21111: CALL_OW 67
// MC_Kill ( 4 ) ;
21115: LD_INT 4
21117: PPUSH
21118: CALL 35536 0 1
// tmp := UnitsInside ( fac ) ;
21122: LD_ADDR_VAR 0 3
21126: PUSH
21127: LD_VAR 0 9
21131: PPUSH
21132: CALL_OW 313
21136: ST_TO_ADDR
// if tmp then
21137: LD_VAR 0 3
21141: IFFALSE 21262
// for i in tmp do
21143: LD_ADDR_VAR 0 1
21147: PUSH
21148: LD_VAR 0 3
21152: PUSH
21153: FOR_IN
21154: IFFALSE 21260
// begin ComExitBuilding ( i ) ;
21156: LD_VAR 0 1
21160: PPUSH
21161: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21165: LD_VAR 0 10
21169: PUSH
21170: LD_INT 2
21172: ARRAY
21173: PPUSH
21174: CALL_OW 313
21178: PUSH
21179: LD_INT 6
21181: LESS
21182: IFFALSE 21204
// AddComEnterUnit ( i , arm [ 2 ] ) else
21184: LD_VAR 0 1
21188: PPUSH
21189: LD_VAR 0 10
21193: PUSH
21194: LD_INT 2
21196: ARRAY
21197: PPUSH
21198: CALL_OW 180
21202: GO 21258
// if UnitsInside ( arm [ 1 ] ) < 6 then
21204: LD_VAR 0 10
21208: PUSH
21209: LD_INT 1
21211: ARRAY
21212: PPUSH
21213: CALL_OW 313
21217: PUSH
21218: LD_INT 6
21220: LESS
21221: IFFALSE 21243
// AddComEnterUnit ( i , arm [ 1 ] ) else
21223: LD_VAR 0 1
21227: PPUSH
21228: LD_VAR 0 10
21232: PUSH
21233: LD_INT 1
21235: ARRAY
21236: PPUSH
21237: CALL_OW 180
21241: GO 21258
// AddComMoveXY ( i , 37 , 68 ) ;
21243: LD_VAR 0 1
21247: PPUSH
21248: LD_INT 37
21250: PPUSH
21251: LD_INT 68
21253: PPUSH
21254: CALL_OW 171
// end ;
21258: GO 21153
21260: POP
21261: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21262: LD_ADDR_VAR 0 11
21266: PUSH
21267: LD_VAR 0 6
21271: PPUSH
21272: LD_INT 26
21274: PUSH
21275: LD_INT 1
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: PPUSH
21282: CALL_OW 72
21286: PUSH
21287: LD_EXP 59
21291: DIFF
21292: ST_TO_ADDR
// if not speaker then
21293: LD_VAR 0 11
21297: NOT
21298: IFFALSE 21325
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21300: LD_ADDR_VAR 0 11
21304: PUSH
21305: LD_VAR 0 6
21309: PPUSH
21310: LD_INT 26
21312: PUSH
21313: LD_INT 1
21315: PUSH
21316: EMPTY
21317: LIST
21318: LIST
21319: PPUSH
21320: CALL_OW 72
21324: ST_TO_ADDR
// if speaker then
21325: LD_VAR 0 11
21329: IFFALSE 21345
// speaker := speaker [ 1 ] ;
21331: LD_ADDR_VAR 0 11
21335: PUSH
21336: LD_VAR 0 11
21340: PUSH
21341: LD_INT 1
21343: ARRAY
21344: ST_TO_ADDR
// Video ( true ) ;
21345: LD_INT 1
21347: PPUSH
21348: CALL 103293 0 1
// CenterNowOnUnits ( Powell ) ;
21352: LD_EXP 58
21356: PPUSH
21357: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21361: LD_ADDR_VAR 0 3
21365: PUSH
21366: LD_VAR 0 6
21370: PPUSH
21371: LD_INT 3
21373: PUSH
21374: LD_INT 25
21376: PUSH
21377: LD_INT 1
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: PPUSH
21388: CALL_OW 72
21392: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21393: LD_ADDR_VAR 0 12
21397: PUSH
21398: LD_INT 22
21400: PUSH
21401: LD_INT 4
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: PUSH
21408: LD_INT 30
21410: PUSH
21411: LD_INT 32
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: PUSH
21418: LD_INT 58
21420: PUSH
21421: EMPTY
21422: LIST
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: ST_TO_ADDR
// for i = 1 to 6 do
21434: LD_ADDR_VAR 0 1
21438: PUSH
21439: DOUBLE
21440: LD_INT 1
21442: DEC
21443: ST_TO_ADDR
21444: LD_INT 6
21446: PUSH
21447: FOR_TO
21448: IFFALSE 21589
// begin if IsInUnit ( tmp [ i ] ) then
21450: LD_VAR 0 3
21454: PUSH
21455: LD_VAR 0 1
21459: ARRAY
21460: PPUSH
21461: CALL_OW 310
21465: IFFALSE 21482
// ComExitBuilding ( tmp [ i ] ) ;
21467: LD_VAR 0 3
21471: PUSH
21472: LD_VAR 0 1
21476: ARRAY
21477: PPUSH
21478: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21482: LD_VAR 0 3
21486: PUSH
21487: LD_VAR 0 1
21491: ARRAY
21492: PPUSH
21493: LD_VAR 0 10
21497: PUSH
21498: LD_INT 1
21500: ARRAY
21501: PPUSH
21502: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21506: LD_VAR 0 3
21510: PUSH
21511: LD_VAR 0 1
21515: ARRAY
21516: PPUSH
21517: LD_INT 1
21519: PPUSH
21520: CALL_OW 183
// if emp_towers then
21524: LD_VAR 0 12
21528: IFFALSE 21587
// begin AddComExitBuilding ( tmp [ i ] ) ;
21530: LD_VAR 0 3
21534: PUSH
21535: LD_VAR 0 1
21539: ARRAY
21540: PPUSH
21541: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21545: LD_VAR 0 3
21549: PUSH
21550: LD_VAR 0 1
21554: ARRAY
21555: PPUSH
21556: LD_VAR 0 12
21560: PUSH
21561: LD_INT 1
21563: ARRAY
21564: PPUSH
21565: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21569: LD_ADDR_VAR 0 12
21573: PUSH
21574: LD_VAR 0 12
21578: PPUSH
21579: LD_INT 1
21581: PPUSH
21582: CALL_OW 3
21586: ST_TO_ADDR
// end ; end ;
21587: GO 21447
21589: POP
21590: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21591: LD_ADDR_VAR 0 3
21595: PUSH
21596: LD_EXP 18
21600: PUSH
21601: LD_INT 1
21603: ARRAY
21604: PUSH
21605: LD_EXP 18
21609: PUSH
21610: LD_INT 2
21612: ARRAY
21613: ADD
21614: PPUSH
21615: LD_INT 26
21617: PUSH
21618: LD_INT 1
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PPUSH
21625: CALL_OW 72
21629: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21630: LD_ADDR_VAR 0 1
21634: PUSH
21635: LD_EXP 18
21639: PUSH
21640: LD_INT 2
21642: ARRAY
21643: PUSH
21644: FOR_IN
21645: IFFALSE 21663
// ComTurnUnit ( i , Powell ) ;
21647: LD_VAR 0 1
21651: PPUSH
21652: LD_EXP 58
21656: PPUSH
21657: CALL_OW 119
21661: GO 21644
21663: POP
21664: POP
// Say ( Powell , D5-Pow-1 ) ;
21665: LD_EXP 58
21669: PPUSH
21670: LD_STRING D5-Pow-1
21672: PPUSH
21673: CALL_OW 88
// if tmp then
21677: LD_VAR 0 3
21681: IFFALSE 21699
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21683: LD_VAR 0 3
21687: PUSH
21688: LD_INT 1
21690: ARRAY
21691: PPUSH
21692: LD_STRING D5-Sol2-1
21694: PPUSH
21695: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21699: LD_EXP 58
21703: PPUSH
21704: LD_STRING D5-Pow-2
21706: PPUSH
21707: CALL_OW 88
// if tmp > 1 then
21711: LD_VAR 0 3
21715: PUSH
21716: LD_INT 1
21718: GREATER
21719: IFFALSE 21737
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21721: LD_VAR 0 3
21725: PUSH
21726: LD_INT 2
21728: ARRAY
21729: PPUSH
21730: LD_STRING D5-Sol2-2
21732: PPUSH
21733: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21737: LD_EXP 58
21741: PPUSH
21742: LD_STRING D5-Pow-3
21744: PPUSH
21745: CALL_OW 88
// wait ( 0 0$1 ) ;
21749: LD_INT 35
21751: PPUSH
21752: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21756: LD_ADDR_VAR 0 3
21760: PUSH
21761: LD_EXP 18
21765: PUSH
21766: LD_INT 1
21768: ARRAY
21769: PUSH
21770: LD_EXP 18
21774: PUSH
21775: LD_INT 2
21777: ARRAY
21778: UNION
21779: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21780: LD_VAR 0 3
21784: PPUSH
21785: LD_INT 80
21787: PPUSH
21788: LD_INT 67
21790: PPUSH
21791: CALL_OW 114
// wait ( 0 0$2 ) ;
21795: LD_INT 70
21797: PPUSH
21798: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21802: LD_INT 79
21804: PPUSH
21805: LD_INT 72
21807: PPUSH
21808: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21812: LD_INT 35
21814: PPUSH
21815: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21819: LD_VAR 0 3
21823: PPUSH
21824: LD_INT 3
21826: PUSH
21827: LD_INT 24
21829: PUSH
21830: LD_INT 1000
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: PPUSH
21841: CALL_OW 72
21845: IFFALSE 21812
// Say ( Powell , D5a-Pow-1 ) ;
21847: LD_EXP 58
21851: PPUSH
21852: LD_STRING D5a-Pow-1
21854: PPUSH
21855: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21859: LD_EXP 58
21863: PPUSH
21864: LD_STRING D5a-Pow-1a
21866: PPUSH
21867: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21871: LD_INT 10
21873: PPUSH
21874: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21878: LD_EXP 58
21882: PPUSH
21883: LD_STRING D5a-Pow-1b
21885: PPUSH
21886: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21890: LD_EXP 58
21894: PPUSH
21895: LD_STRING D5a-Pow-1c
21897: PPUSH
21898: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21902: LD_EXP 58
21906: PPUSH
21907: LD_STRING D5a-Pow-1d
21909: PPUSH
21910: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21914: LD_INT 35
21916: PPUSH
21917: CALL_OW 67
// if not HasTask ( tmp ) then
21921: LD_VAR 0 3
21925: PPUSH
21926: CALL_OW 314
21930: NOT
21931: IFFALSE 21948
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21933: LD_VAR 0 3
21937: PPUSH
21938: LD_INT 80
21940: PPUSH
21941: LD_INT 67
21943: PPUSH
21944: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21948: LD_VAR 0 3
21952: PPUSH
21953: LD_INT 24
21955: PUSH
21956: LD_INT 1
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: PPUSH
21963: CALL_OW 72
21967: NOT
21968: IFFALSE 21914
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: LD_INT 22
21977: PUSH
21978: LD_INT 4
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: PUSH
21985: LD_INT 92
21987: PUSH
21988: LD_INT 60
21990: PUSH
21991: LD_INT 93
21993: PUSH
21994: LD_INT 10
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: LIST
22001: LIST
22002: PUSH
22003: LD_INT 3
22005: PUSH
22006: LD_INT 54
22008: PUSH
22009: EMPTY
22010: LIST
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: LIST
22020: PPUSH
22021: CALL_OW 69
22025: PUSH
22026: LD_EXP 58
22030: DIFF
22031: ST_TO_ADDR
// if tmp then
22032: LD_VAR 0 3
22036: IFFALSE 22070
// for i in tmp do
22038: LD_ADDR_VAR 0 1
22042: PUSH
22043: LD_VAR 0 3
22047: PUSH
22048: FOR_IN
22049: IFFALSE 22068
// ComMoveXY ( i , 36 , 67 ) ;
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_INT 36
22058: PPUSH
22059: LD_INT 67
22061: PPUSH
22062: CALL_OW 111
22066: GO 22048
22068: POP
22069: POP
// wait ( 0 0$3 ) ;
22070: LD_INT 105
22072: PPUSH
22073: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22077: LD_VAR 0 11
22081: PPUSH
22082: LD_STRING D6-Sol3-1
22084: PPUSH
22085: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22089: LD_EXP 58
22093: PPUSH
22094: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22098: LD_EXP 58
22102: PPUSH
22103: LD_STRING D6-Pow-1
22105: PPUSH
22106: CALL_OW 88
// tmp := [ ] ;
22110: LD_ADDR_VAR 0 3
22114: PUSH
22115: EMPTY
22116: ST_TO_ADDR
// for i = 1 to 2 do
22117: LD_ADDR_VAR 0 1
22121: PUSH
22122: DOUBLE
22123: LD_INT 1
22125: DEC
22126: ST_TO_ADDR
22127: LD_INT 2
22129: PUSH
22130: FOR_TO
22131: IFFALSE 22245
// begin uc_side := 8 ;
22133: LD_ADDR_OWVAR 20
22137: PUSH
22138: LD_INT 8
22140: ST_TO_ADDR
// uc_nation := 2 ;
22141: LD_ADDR_OWVAR 21
22145: PUSH
22146: LD_INT 2
22148: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22149: LD_INT 14
22151: PPUSH
22152: LD_INT 3
22154: PPUSH
22155: LD_INT 2
22157: PPUSH
22158: LD_INT 29
22160: PPUSH
22161: LD_INT 100
22163: PPUSH
22164: CALL 70937 0 5
// veh := CreateVehicle ;
22168: LD_ADDR_VAR 0 13
22172: PUSH
22173: CALL_OW 45
22177: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22178: LD_VAR 0 13
22182: PPUSH
22183: LD_INT 4
22185: PPUSH
22186: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22190: LD_VAR 0 13
22194: PPUSH
22195: LD_INT 99
22197: PPUSH
22198: LD_INT 83
22200: PPUSH
22201: LD_INT 6
22203: PPUSH
22204: LD_INT 0
22206: PPUSH
22207: CALL_OW 50
// wait ( 3 ) ;
22211: LD_INT 3
22213: PPUSH
22214: CALL_OW 67
// Connect ( veh ) ;
22218: LD_VAR 0 13
22222: PPUSH
22223: CALL 74030 0 1
// tmp := tmp ^ veh ;
22227: LD_ADDR_VAR 0 3
22231: PUSH
22232: LD_VAR 0 3
22236: PUSH
22237: LD_VAR 0 13
22241: ADD
22242: ST_TO_ADDR
// end ;
22243: GO 22130
22245: POP
22246: POP
// wait ( 0 0$1 ) ;
22247: LD_INT 35
22249: PPUSH
22250: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22254: LD_INT 99
22256: PPUSH
22257: LD_INT 83
22259: PPUSH
22260: LD_INT 1
22262: PPUSH
22263: LD_INT 10
22265: PPUSH
22266: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22270: LD_INT 99
22272: PPUSH
22273: LD_INT 83
22275: PPUSH
22276: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22280: LD_VAR 0 11
22284: PPUSH
22285: LD_STRING D6-Sol3-2
22287: PPUSH
22288: CALL_OW 88
// async ;
22292: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22293: LD_EXP 58
22297: PPUSH
22298: LD_STRING D6-Pow-2
22300: PPUSH
22301: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22305: LD_VAR 0 3
22309: PUSH
22310: LD_INT 1
22312: ARRAY
22313: PPUSH
22314: LD_VAR 0 9
22318: PPUSH
22319: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22323: LD_VAR 0 3
22327: PUSH
22328: LD_INT 2
22330: ARRAY
22331: PPUSH
22332: LD_INT 22
22334: PUSH
22335: LD_INT 4
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PUSH
22342: LD_INT 21
22344: PUSH
22345: LD_INT 3
22347: PUSH
22348: EMPTY
22349: LIST
22350: LIST
22351: PUSH
22352: EMPTY
22353: LIST
22354: LIST
22355: PPUSH
22356: CALL_OW 69
22360: PPUSH
22361: LD_VAR 0 3
22365: PUSH
22366: LD_INT 2
22368: ARRAY
22369: PPUSH
22370: CALL_OW 74
22374: PPUSH
22375: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22379: LD_EXP 58
22383: PPUSH
22384: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22388: LD_INT 99
22390: PPUSH
22391: LD_INT 83
22393: PPUSH
22394: LD_INT 1
22396: PPUSH
22397: CALL_OW 331
// repeat wait ( 4 ) ;
22401: LD_INT 4
22403: PPUSH
22404: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22408: LD_VAR 0 3
22412: PUSH
22413: LD_INT 1
22415: ARRAY
22416: PPUSH
22417: CALL_OW 256
22421: PUSH
22422: LD_INT 1000
22424: LESS
22425: IFFALSE 22443
// SetLives ( tmp [ 1 ] , 1000 ) ;
22427: LD_VAR 0 3
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PPUSH
22436: LD_INT 1000
22438: PPUSH
22439: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22443: LD_INT 22
22445: PUSH
22446: LD_INT 4
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: PUSH
22453: LD_INT 30
22455: PUSH
22456: LD_INT 3
22458: PUSH
22459: EMPTY
22460: LIST
22461: LIST
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: PPUSH
22467: CALL_OW 69
22471: PUSH
22472: LD_INT 0
22474: EQUAL
22475: IFFALSE 22401
// skirmish := false ;
22477: LD_ADDR_EXP 113
22481: PUSH
22482: LD_INT 0
22484: ST_TO_ADDR
// sync ;
22485: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22486: LD_EXP 58
22490: PPUSH
22491: LD_STRING D6a-Pow-1
22493: PPUSH
22494: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22498: LD_VAR 0 11
22502: PPUSH
22503: LD_STRING D6a-Sol3-1
22505: PPUSH
22506: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22510: LD_EXP 58
22514: PPUSH
22515: LD_STRING D6a-Pow-2
22517: PPUSH
22518: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22522: LD_VAR 0 11
22526: PPUSH
22527: LD_STRING D6a-Sol3-2
22529: PPUSH
22530: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22534: LD_EXP 58
22538: PPUSH
22539: LD_STRING D6a-Pow-3
22541: PPUSH
22542: CALL_OW 88
// powellCenterCameraMode := true ;
22546: LD_ADDR_EXP 20
22550: PUSH
22551: LD_INT 1
22553: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22554: LD_ADDR_VAR 0 1
22558: PUSH
22559: LD_INT 22
22561: PUSH
22562: LD_INT 8
22564: PUSH
22565: EMPTY
22566: LIST
22567: LIST
22568: PUSH
22569: LD_INT 25
22571: PUSH
22572: LD_INT 2
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: PUSH
22579: EMPTY
22580: LIST
22581: LIST
22582: PPUSH
22583: CALL_OW 69
22587: PUSH
22588: FOR_IN
22589: IFFALSE 22644
// begin SetTag ( i , 1 ) ;
22591: LD_VAR 0 1
22595: PPUSH
22596: LD_INT 1
22598: PPUSH
22599: CALL_OW 109
// ComExitBuilding ( i ) ;
22603: LD_VAR 0 1
22607: PPUSH
22608: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22612: LD_VAR 0 1
22616: PPUSH
22617: LD_INT 35
22619: PPUSH
22620: LD_INT 6
22622: PPUSH
22623: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22627: LD_VAR 0 1
22631: PPUSH
22632: LD_INT 53
22634: PPUSH
22635: LD_INT 4
22637: PPUSH
22638: CALL_OW 171
// end ;
22642: GO 22588
22644: POP
22645: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22646: LD_ADDR_VAR 0 3
22650: PUSH
22651: LD_INT 22
22653: PUSH
22654: LD_INT 4
22656: PUSH
22657: EMPTY
22658: LIST
22659: LIST
22660: PUSH
22661: LD_INT 21
22663: PUSH
22664: LD_INT 2
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: PUSH
22671: LD_INT 3
22673: PUSH
22674: LD_INT 34
22676: PUSH
22677: LD_INT 12
22679: PUSH
22680: EMPTY
22681: LIST
22682: LIST
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: LIST
22692: PPUSH
22693: CALL_OW 69
22697: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22698: LD_EXP 58
22702: PPUSH
22703: LD_VAR 0 3
22707: PPUSH
22708: LD_EXP 58
22712: PPUSH
22713: CALL_OW 74
22717: PPUSH
22718: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22722: LD_EXP 58
22726: PPUSH
22727: LD_INT 100
22729: PPUSH
22730: LD_INT 88
22732: PPUSH
22733: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22737: LD_EXP 58
22741: PPUSH
22742: LD_INT 100
22744: PPUSH
22745: LD_INT 75
22747: PPUSH
22748: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22752: LD_EXP 58
22756: PPUSH
22757: LD_INT 88
22759: PPUSH
22760: LD_INT 53
22762: PPUSH
22763: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22767: LD_INT 8
22769: PPUSH
22770: LD_EXP 58
22774: PPUSH
22775: CALL_OW 471
// repeat wait ( 3 ) ;
22779: LD_INT 3
22781: PPUSH
22782: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22786: LD_INT 22
22788: PUSH
22789: LD_INT 4
22791: PUSH
22792: EMPTY
22793: LIST
22794: LIST
22795: PUSH
22796: LD_INT 92
22798: PUSH
22799: LD_INT 100
22801: PUSH
22802: LD_INT 75
22804: PUSH
22805: LD_INT 6
22807: PUSH
22808: EMPTY
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PPUSH
22818: CALL_OW 69
22822: IFFALSE 22779
// async ;
22824: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22825: LD_EXP 58
22829: PPUSH
22830: LD_STRING D6b-Pow-1
22832: PPUSH
22833: CALL_OW 88
// repeat wait ( 3 ) ;
22837: LD_INT 3
22839: PPUSH
22840: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22844: LD_EXP 58
22848: PPUSH
22849: CALL_OW 310
22853: PPUSH
22854: CALL_OW 256
22858: PUSH
22859: LD_INT 1000
22861: LESS
22862: IFFALSE 22881
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22864: LD_EXP 58
22868: PPUSH
22869: CALL_OW 310
22873: PPUSH
22874: LD_INT 1000
22876: PPUSH
22877: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22881: LD_EXP 58
22885: PPUSH
22886: CALL_OW 256
22890: PUSH
22891: LD_INT 1000
22893: LESS
22894: IFFALSE 22908
// SetLives ( Powell , 1000 ) ;
22896: LD_EXP 58
22900: PPUSH
22901: LD_INT 1000
22903: PPUSH
22904: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22908: LD_EXP 58
22912: PPUSH
22913: LD_EXP 63
22917: PPUSH
22918: CALL_OW 296
22922: PUSH
22923: LD_INT 5
22925: LESS
22926: PUSH
22927: LD_EXP 58
22931: PPUSH
22932: CALL_OW 310
22936: PPUSH
22937: LD_EXP 63
22941: PPUSH
22942: CALL_OW 296
22946: PUSH
22947: LD_INT 5
22949: LESS
22950: OR
22951: IFFALSE 22970
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22953: LD_EXP 58
22957: PPUSH
22958: CALL_OW 310
22962: PPUSH
22963: LD_INT 100
22965: PPUSH
22966: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22970: LD_EXP 58
22974: PPUSH
22975: CALL_OW 310
22979: NOT
22980: IFFALSE 22837
// DoNotAttack ( 8 , powellBomb ) ;
22982: LD_INT 8
22984: PPUSH
22985: LD_EXP 63
22989: PPUSH
22990: CALL_OW 471
// game_speed := 4 ;
22994: LD_ADDR_OWVAR 65
22998: PUSH
22999: LD_INT 4
23001: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
23002: LD_EXP 58
23006: PPUSH
23007: LD_STRING D6b-Pow-1a
23009: PPUSH
23010: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
23014: LD_EXP 58
23018: PPUSH
23019: LD_EXP 63
23023: PPUSH
23024: CALL_OW 180
// sync ;
23028: SYNC
// repeat wait ( 0 0$1 ) ;
23029: LD_INT 35
23031: PPUSH
23032: CALL_OW 67
// until IsInUnit ( Powell ) ;
23036: LD_EXP 58
23040: PPUSH
23041: CALL_OW 310
23045: IFFALSE 23029
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23047: LD_INT 8
23049: PPUSH
23050: LD_EXP 58
23054: PPUSH
23055: CALL_OW 310
23059: PPUSH
23060: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23064: LD_EXP 58
23068: PPUSH
23069: LD_INT 91
23071: PPUSH
23072: LD_INT 44
23074: PPUSH
23075: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23079: LD_EXP 58
23083: PPUSH
23084: LD_INT 96
23086: PPUSH
23087: LD_INT 44
23089: PPUSH
23090: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23094: LD_EXP 58
23098: PPUSH
23099: LD_INT 96
23101: PPUSH
23102: LD_INT 41
23104: PPUSH
23105: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23109: LD_EXP 58
23113: PPUSH
23114: LD_INT 92
23116: PPUSH
23117: LD_INT 39
23119: PPUSH
23120: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23124: LD_EXP 58
23128: PPUSH
23129: LD_INT 88
23131: PPUSH
23132: LD_INT 41
23134: PPUSH
23135: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23139: LD_EXP 58
23143: PPUSH
23144: LD_INT 91
23146: PPUSH
23147: LD_INT 44
23149: PPUSH
23150: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23154: LD_EXP 58
23158: PPUSH
23159: LD_INT 96
23161: PPUSH
23162: LD_INT 44
23164: PPUSH
23165: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23169: LD_EXP 58
23173: PPUSH
23174: LD_INT 96
23176: PPUSH
23177: LD_INT 41
23179: PPUSH
23180: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23184: LD_EXP 58
23188: PPUSH
23189: LD_INT 92
23191: PPUSH
23192: LD_INT 39
23194: PPUSH
23195: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23199: LD_EXP 58
23203: PPUSH
23204: LD_INT 88
23206: PPUSH
23207: LD_INT 41
23209: PPUSH
23210: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23214: LD_EXP 58
23218: PPUSH
23219: LD_INT 91
23221: PPUSH
23222: LD_INT 44
23224: PPUSH
23225: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23229: LD_EXP 58
23233: PPUSH
23234: LD_INT 93
23236: PPUSH
23237: LD_INT 39
23239: PPUSH
23240: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23244: LD_EXP 58
23248: PPUSH
23249: LD_INT 93
23251: PPUSH
23252: LD_INT 36
23254: PPUSH
23255: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23259: LD_INT 122
23261: PPUSH
23262: CALL_OW 67
// game_speed := 4 ;
23266: LD_ADDR_OWVAR 65
23270: PUSH
23271: LD_INT 4
23273: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23274: LD_EXP 58
23278: PPUSH
23279: LD_STRING D6b-Pow-1b
23281: PPUSH
23282: CALL_OW 88
// tmp := [ ] ;
23286: LD_ADDR_VAR 0 3
23290: PUSH
23291: EMPTY
23292: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23293: LD_ADDR_VAR 0 5
23297: PUSH
23298: LD_INT 78
23300: PUSH
23301: LD_INT 47
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 106
23310: PUSH
23311: LD_INT 53
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23322: LD_ADDR_VAR 0 1
23326: PUSH
23327: LD_INT 22
23329: PUSH
23330: LD_INT 8
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: PUSH
23337: LD_INT 21
23339: PUSH
23340: LD_INT 3
23342: PUSH
23343: EMPTY
23344: LIST
23345: LIST
23346: PUSH
23347: LD_INT 92
23349: PUSH
23350: LD_INT 90
23352: PUSH
23353: LD_INT 52
23355: PUSH
23356: LD_INT 12
23358: PUSH
23359: EMPTY
23360: LIST
23361: LIST
23362: LIST
23363: LIST
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: LIST
23369: PPUSH
23370: CALL_OW 69
23374: PUSH
23375: FOR_IN
23376: IFFALSE 23401
// tmp := tmp ^ UnitsInside ( i ) ;
23378: LD_ADDR_VAR 0 3
23382: PUSH
23383: LD_VAR 0 3
23387: PUSH
23388: LD_VAR 0 1
23392: PPUSH
23393: CALL_OW 313
23397: ADD
23398: ST_TO_ADDR
23399: GO 23375
23401: POP
23402: POP
// for i in tmp do
23403: LD_ADDR_VAR 0 1
23407: PUSH
23408: LD_VAR 0 3
23412: PUSH
23413: FOR_IN
23414: IFFALSE 23576
// begin dist := 9999 ;
23416: LD_ADDR_VAR 0 8
23420: PUSH
23421: LD_INT 9999
23423: ST_TO_ADDR
// _xy := [ ] ;
23424: LD_ADDR_VAR 0 7
23428: PUSH
23429: EMPTY
23430: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23431: LD_VAR 0 1
23435: PPUSH
23436: LD_INT 1
23438: PPUSH
23439: CALL_OW 109
// ComExitBuilding ( i ) ;
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 122
// for j in xy do
23452: LD_ADDR_VAR 0 2
23456: PUSH
23457: LD_VAR 0 5
23461: PUSH
23462: FOR_IN
23463: IFFALSE 23545
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23465: LD_VAR 0 1
23469: PPUSH
23470: LD_VAR 0 2
23474: PUSH
23475: LD_INT 1
23477: ARRAY
23478: PPUSH
23479: LD_VAR 0 2
23483: PUSH
23484: LD_INT 2
23486: ARRAY
23487: PPUSH
23488: CALL_OW 297
23492: PUSH
23493: LD_VAR 0 8
23497: LESS
23498: IFFALSE 23543
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23500: LD_ADDR_VAR 0 8
23504: PUSH
23505: LD_VAR 0 1
23509: PPUSH
23510: LD_VAR 0 2
23514: PUSH
23515: LD_INT 1
23517: ARRAY
23518: PPUSH
23519: LD_VAR 0 2
23523: PUSH
23524: LD_INT 2
23526: ARRAY
23527: PPUSH
23528: CALL_OW 297
23532: ST_TO_ADDR
// _xy := j ;
23533: LD_ADDR_VAR 0 7
23537: PUSH
23538: LD_VAR 0 2
23542: ST_TO_ADDR
// end ;
23543: GO 23462
23545: POP
23546: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23547: LD_VAR 0 1
23551: PPUSH
23552: LD_VAR 0 7
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_VAR 0 7
23565: PUSH
23566: LD_INT 2
23568: ARRAY
23569: PPUSH
23570: CALL_OW 171
// end ;
23574: GO 23413
23576: POP
23577: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23578: LD_ADDR_VAR 0 4
23582: PUSH
23583: LD_VAR 0 3
23587: PPUSH
23588: LD_INT 26
23590: PUSH
23591: LD_INT 1
23593: PUSH
23594: EMPTY
23595: LIST
23596: LIST
23597: PUSH
23598: LD_INT 25
23600: PUSH
23601: LD_INT 1
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: EMPTY
23609: LIST
23610: LIST
23611: PPUSH
23612: CALL_OW 72
23616: ST_TO_ADDR
// if tmp2 < 2 then
23617: LD_VAR 0 4
23621: PUSH
23622: LD_INT 2
23624: LESS
23625: IFFALSE 23694
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23627: LD_ADDR_VAR 0 4
23631: PUSH
23632: LD_INT 22
23634: PUSH
23635: LD_INT 8
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: LD_INT 26
23644: PUSH
23645: LD_INT 1
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PUSH
23652: LD_INT 3
23654: PUSH
23655: LD_INT 25
23657: PUSH
23658: LD_INT 15
23660: PUSH
23661: EMPTY
23662: LIST
23663: LIST
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: LIST
23673: PPUSH
23674: CALL_OW 69
23678: PUSH
23679: LD_EXP 60
23683: PUSH
23684: LD_EXP 61
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: DIFF
23693: ST_TO_ADDR
// if tmp2 then
23694: LD_VAR 0 4
23698: IFFALSE 23716
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 1
23707: ARRAY
23708: PPUSH
23709: LD_STRING D6b-ArSol1-1
23711: PPUSH
23712: CALL_OW 88
// async ;
23716: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23717: LD_EXP 58
23721: PPUSH
23722: LD_STRING D6b-Pow-2
23724: PPUSH
23725: CALL_OW 88
// wait ( 0 0$1 ) ;
23729: LD_INT 35
23731: PPUSH
23732: CALL_OW 67
// if tmp2 > 1 then
23736: LD_VAR 0 4
23740: PUSH
23741: LD_INT 1
23743: GREATER
23744: IFFALSE 23762
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23746: LD_VAR 0 4
23750: PUSH
23751: LD_INT 2
23753: ARRAY
23754: PPUSH
23755: LD_STRING D6b-ArSol2-1
23757: PPUSH
23758: CALL_OW 88
// sync ;
23762: SYNC
// repeat wait ( 5 ) ;
23763: LD_INT 5
23765: PPUSH
23766: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23770: LD_INT 93
23772: PPUSH
23773: LD_INT 36
23775: PPUSH
23776: CALL_OW 428
23780: PPUSH
23781: CALL_OW 255
23785: PUSH
23786: LD_INT 4
23788: EQUAL
23789: IFFALSE 23763
// DialogueOn ;
23791: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23795: LD_INT 10
23797: PPUSH
23798: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23802: LD_EXP 58
23806: PPUSH
23807: LD_STRING D6b-Pow-2a
23809: PPUSH
23810: CALL_OW 88
// DialogueOff ;
23814: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23818: LD_EXP 58
23822: PPUSH
23823: CALL_OW 310
23827: PPUSH
23828: LD_INT 332
23830: PPUSH
23831: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23835: LD_INT 93
23837: PPUSH
23838: LD_INT 35
23840: PPUSH
23841: LD_INT 1
23843: PPUSH
23844: LD_INT 6
23846: NEG
23847: PPUSH
23848: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23852: LD_INT 35
23854: PPUSH
23855: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23859: LD_INT 332
23861: PPUSH
23862: CALL_OW 256
23866: PUSH
23867: LD_INT 1000
23869: LESS
23870: PUSH
23871: LD_INT 332
23873: PPUSH
23874: CALL_OW 300
23878: AND
23879: IFFALSE 23891
// SetLives ( kozlov_fac , 0 ) ;
23881: LD_INT 332
23883: PPUSH
23884: LD_INT 0
23886: PPUSH
23887: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23891: LD_INT 332
23893: PPUSH
23894: CALL_OW 301
23898: PUSH
23899: LD_EXP 58
23903: PPUSH
23904: CALL_OW 301
23908: OR
23909: IFFALSE 23852
// game_speed := 4 ;
23911: LD_ADDR_OWVAR 65
23915: PUSH
23916: LD_INT 4
23918: ST_TO_ADDR
// powellCenterCameraMode := false ;
23919: LD_ADDR_EXP 20
23923: PUSH
23924: LD_INT 0
23926: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23927: LD_ADDR_VAR 0 1
23931: PUSH
23932: LD_VAR 0 3
23936: PUSH
23937: LD_INT 22
23939: PUSH
23940: LD_INT 8
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: PUSH
23947: LD_INT 25
23949: PUSH
23950: LD_INT 2
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: PPUSH
23961: CALL_OW 69
23965: UNION
23966: PUSH
23967: FOR_IN
23968: IFFALSE 23984
// SetTag ( i , 0 ) ;
23970: LD_VAR 0 1
23974: PPUSH
23975: LD_INT 0
23977: PPUSH
23978: CALL_OW 109
23982: GO 23967
23984: POP
23985: POP
// wait ( 0 0$3 ) ;
23986: LD_INT 105
23988: PPUSH
23989: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23993: LD_INT 93
23995: PPUSH
23996: LD_INT 35
23998: PPUSH
23999: LD_INT 1
24001: PPUSH
24002: CALL_OW 331
// DialogueOn ;
24006: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
24010: LD_VAR 0 11
24014: PPUSH
24015: LD_STRING D6c-Sol3-1
24017: PPUSH
24018: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24022: LD_INT 10
24024: PPUSH
24025: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24029: LD_EXP 39
24033: PPUSH
24034: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24038: LD_EXP 39
24042: PPUSH
24043: LD_STRING D6c-JMM-1
24045: PPUSH
24046: CALL_OW 88
// if Cyrus then
24050: LD_EXP 45
24054: IFFALSE 24068
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24056: LD_EXP 45
24060: PPUSH
24061: LD_STRING D6c-Cyrus-1
24063: PPUSH
24064: CALL_OW 88
// if Bobby then
24068: LD_EXP 44
24072: IFFALSE 24086
// Say ( Bobby , D6c-Bobby-1 ) ;
24074: LD_EXP 44
24078: PPUSH
24079: LD_STRING D6c-Bobby-1
24081: PPUSH
24082: CALL_OW 88
// if Cornel then
24086: LD_EXP 50
24090: IFFALSE 24104
// Say ( Cornel , D6c-Corn-1 ) ;
24092: LD_EXP 50
24096: PPUSH
24097: LD_STRING D6c-Corn-1
24099: PPUSH
24100: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24104: LD_ADDR_VAR 0 4
24108: PUSH
24109: LD_INT 2
24111: PUSH
24112: LD_INT 22
24114: PUSH
24115: LD_INT 1
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: PUSH
24122: LD_INT 22
24124: PUSH
24125: LD_INT 4
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: LIST
24136: PUSH
24137: LD_INT 26
24139: PUSH
24140: LD_INT 1
24142: PUSH
24143: EMPTY
24144: LIST
24145: LIST
24146: PUSH
24147: LD_INT 3
24149: PUSH
24150: LD_INT 25
24152: PUSH
24153: LD_INT 16
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: LD_INT 25
24162: PUSH
24163: LD_INT 12
24165: PUSH
24166: EMPTY
24167: LIST
24168: LIST
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: LIST
24174: PUSH
24175: EMPTY
24176: LIST
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 69
24184: PUSH
24185: LD_VAR 0 11
24189: PUSH
24190: LD_EXP 39
24194: UNION
24195: PUSH
24196: LD_EXP 59
24200: UNION
24201: PUSH
24202: EMPTY
24203: LIST
24204: DIFF
24205: ST_TO_ADDR
// if tmp2 then
24206: LD_VAR 0 4
24210: IFFALSE 24228
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24212: LD_VAR 0 4
24216: PUSH
24217: LD_INT 1
24219: ARRAY
24220: PPUSH
24221: LD_STRING D6c-Sol1-1
24223: PPUSH
24224: CALL_OW 88
// if Lisa then
24228: LD_EXP 42
24232: IFFALSE 24246
// Say ( Lisa , D6c-Lisa-1 ) ;
24234: LD_EXP 42
24238: PPUSH
24239: LD_STRING D6c-Lisa-1
24241: PPUSH
24242: CALL_OW 88
// if Gary then
24246: LD_EXP 51
24250: IFFALSE 24264
// Say ( Gary , D6c-Gary-1 ) ;
24252: LD_EXP 51
24256: PPUSH
24257: LD_STRING D6c-Gary-1
24259: PPUSH
24260: CALL_OW 88
// if Donaldson then
24264: LD_EXP 43
24268: IFFALSE 24282
// Say ( Donaldson , D6c-Don-1 ) ;
24270: LD_EXP 43
24274: PPUSH
24275: LD_STRING D6c-Don-1
24277: PPUSH
24278: CALL_OW 88
// if tmp2 > 1 then
24282: LD_VAR 0 4
24286: PUSH
24287: LD_INT 1
24289: GREATER
24290: IFFALSE 24308
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24292: LD_VAR 0 4
24296: PUSH
24297: LD_INT 2
24299: ARRAY
24300: PPUSH
24301: LD_STRING D6c-Sol2-1
24303: PPUSH
24304: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24308: LD_VAR 0 11
24312: PPUSH
24313: LD_STRING D6c-Sol3-2
24315: PPUSH
24316: CALL_OW 88
// dwait ( 0 0$1 ) ;
24320: LD_INT 35
24322: PPUSH
24323: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24327: LD_EXP 39
24331: PPUSH
24332: LD_STRING D6c-JMM-2
24334: PPUSH
24335: CALL_OW 88
// DialogueOff ;
24339: CALL_OW 7
// Video ( false ) ;
24343: LD_INT 0
24345: PPUSH
24346: CALL 103293 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24350: LD_INT 22
24352: PUSH
24353: LD_INT 4
24355: PUSH
24356: EMPTY
24357: LIST
24358: LIST
24359: PPUSH
24360: CALL_OW 69
24364: PPUSH
24365: LD_INT 1
24367: PPUSH
24368: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24372: LD_INT 4
24374: PPUSH
24375: LD_INT 4
24377: PPUSH
24378: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24382: LD_ADDR_VAR 0 1
24386: PUSH
24387: LD_INT 4
24389: PPUSH
24390: LD_INT 1
24392: PPUSH
24393: LD_INT 2
24395: PPUSH
24396: CALL 65983 0 3
24400: PUSH
24401: FOR_IN
24402: IFFALSE 24439
// if GetTech ( i , 1 ) <> state_researched then
24404: LD_VAR 0 1
24408: PPUSH
24409: LD_INT 1
24411: PPUSH
24412: CALL_OW 321
24416: PUSH
24417: LD_INT 2
24419: NONEQUAL
24420: IFFALSE 24437
// SetTech ( i , 1 , state_researched ) ;
24422: LD_VAR 0 1
24426: PPUSH
24427: LD_INT 1
24429: PPUSH
24430: LD_INT 2
24432: PPUSH
24433: CALL_OW 322
24437: GO 24401
24439: POP
24440: POP
// missionStage := 6 ;
24441: LD_ADDR_EXP 15
24445: PUSH
24446: LD_INT 6
24448: ST_TO_ADDR
// activeAttacks := true ;
24449: LD_ADDR_EXP 16
24453: PUSH
24454: LD_INT 1
24456: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24457: LD_STRING M2
24459: PPUSH
24460: CALL_OW 337
// SaveForQuickRestart ;
24464: CALL_OW 22
// wait ( 0 0$40 ) ;
24468: LD_INT 1400
24470: PPUSH
24471: CALL_OW 67
// DialogueOn ;
24475: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24479: LD_EXP 62
24483: PPUSH
24484: LD_STRING D7-Friend-1
24486: PPUSH
24487: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24491: LD_EXP 39
24495: PPUSH
24496: LD_STRING D7-JMM-1
24498: PPUSH
24499: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24503: LD_EXP 62
24507: PPUSH
24508: LD_STRING D7-Friend-2
24510: PPUSH
24511: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24515: LD_EXP 39
24519: PPUSH
24520: LD_STRING D7-JMM-2
24522: PPUSH
24523: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24527: LD_EXP 62
24531: PPUSH
24532: LD_STRING D7-Friend-3
24534: PPUSH
24535: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24539: LD_EXP 39
24543: PPUSH
24544: LD_STRING D7-JMM-3
24546: PPUSH
24547: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24551: LD_EXP 62
24555: PPUSH
24556: LD_STRING D7-Friend-4
24558: PPUSH
24559: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24563: LD_EXP 39
24567: PPUSH
24568: LD_STRING D7-JMM-4
24570: PPUSH
24571: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24575: LD_EXP 62
24579: PPUSH
24580: LD_STRING D7-Friend-5
24582: PPUSH
24583: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24587: LD_EXP 39
24591: PPUSH
24592: LD_STRING D7-JMM-5
24594: PPUSH
24595: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24599: LD_EXP 62
24603: PPUSH
24604: LD_STRING D7-Friend-6
24606: PPUSH
24607: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24611: LD_EXP 39
24615: PPUSH
24616: LD_STRING D7-JMM-6
24618: PPUSH
24619: CALL_OW 88
// DialogueOff ;
24623: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24627: LD_STRING Mlegion
24629: PPUSH
24630: CALL_OW 337
// skirmish := true ;
24634: LD_ADDR_EXP 113
24638: PUSH
24639: LD_INT 1
24641: ST_TO_ADDR
// RebuildKozlovFactory ;
24642: CALL 4892 0 0
// end ;
24646: PPOPN 13
24648: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24649: LD_EXP 20
24653: PUSH
24654: LD_EXP 58
24658: PPUSH
24659: CALL_OW 300
24663: AND
24664: IFFALSE 24706
24666: GO 24668
24668: DISABLE
// begin enable ;
24669: ENABLE
// if IsInUnit ( Powell ) then
24670: LD_EXP 58
24674: PPUSH
24675: CALL_OW 310
24679: IFFALSE 24697
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24681: LD_EXP 58
24685: PPUSH
24686: CALL_OW 310
24690: PPUSH
24691: CALL_OW 85
24695: GO 24706
// CenterOnUnits ( Powell ) ;
24697: LD_EXP 58
24701: PPUSH
24702: CALL_OW 85
// end ;
24706: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24707: LD_INT 22
24709: PUSH
24710: LD_INT 8
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 34
24719: PUSH
24720: LD_INT 48
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PPUSH
24731: CALL_OW 69
24735: IFFALSE 25009
24737: GO 24739
24739: DISABLE
24740: LD_INT 0
24742: PPUSH
24743: PPUSH
// begin if missionStage < 9 then
24744: LD_EXP 15
24748: PUSH
24749: LD_INT 9
24751: LESS
24752: IFFALSE 24762
// missionStage := 9 ;
24754: LD_ADDR_EXP 15
24758: PUSH
24759: LD_INT 9
24761: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24762: LD_ADDR_VAR 0 1
24766: PUSH
24767: LD_INT 22
24769: PUSH
24770: LD_INT 8
24772: PUSH
24773: EMPTY
24774: LIST
24775: LIST
24776: PUSH
24777: LD_INT 34
24779: PUSH
24780: LD_INT 48
24782: PUSH
24783: EMPTY
24784: LIST
24785: LIST
24786: PUSH
24787: EMPTY
24788: LIST
24789: LIST
24790: PPUSH
24791: CALL_OW 69
24795: PUSH
24796: LD_INT 1
24798: ARRAY
24799: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24800: LD_INT 175
24802: PPUSH
24803: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24807: LD_EXP 12
24811: PUSH
24812: LD_EXP 3
24816: PUSH
24817: LD_INT 0
24819: PUSH
24820: LD_INT 2
24822: PUSH
24823: EMPTY
24824: LIST
24825: LIST
24826: IN
24827: OR
24828: IFFALSE 24851
// target := [ 68 , 108 , 1 ] else
24830: LD_ADDR_VAR 0 2
24834: PUSH
24835: LD_INT 68
24837: PUSH
24838: LD_INT 108
24840: PUSH
24841: LD_INT 1
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: LIST
24848: ST_TO_ADDR
24849: GO 24870
// target := [ 181 , 88 , 2 ] ;
24851: LD_ADDR_VAR 0 2
24855: PUSH
24856: LD_INT 181
24858: PUSH
24859: LD_INT 88
24861: PUSH
24862: LD_INT 2
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: LIST
24869: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24870: LD_VAR 0 1
24874: PPUSH
24875: LD_VAR 0 2
24879: PUSH
24880: LD_INT 1
24882: ARRAY
24883: PPUSH
24884: LD_VAR 0 2
24888: PUSH
24889: LD_INT 2
24891: ARRAY
24892: PPUSH
24893: CALL_OW 176
// if target [ 3 ] = 1 then
24897: LD_VAR 0 2
24901: PUSH
24902: LD_INT 3
24904: ARRAY
24905: PUSH
24906: LD_INT 1
24908: EQUAL
24909: IFFALSE 24925
// SayRadio ( Kurt , D12-Kurt-1 ) else
24911: LD_EXP 60
24915: PPUSH
24916: LD_STRING D12-Kurt-1
24918: PPUSH
24919: CALL_OW 94
24923: GO 24949
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24925: LD_EXP 60
24929: PPUSH
24930: LD_STRING D12a-Kurt-1
24932: PPUSH
24933: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24937: LD_EXP 74
24941: PPUSH
24942: LD_STRING D12a-Roth-1
24944: PPUSH
24945: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24949: LD_INT 350
24951: PPUSH
24952: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24956: LD_VAR 0 1
24960: PPUSH
24961: LD_INT 22
24963: PUSH
24964: LD_INT 8
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PUSH
24971: LD_INT 23
24973: PUSH
24974: LD_INT 2
24976: PUSH
24977: EMPTY
24978: LIST
24979: LIST
24980: PUSH
24981: LD_INT 30
24983: PUSH
24984: LD_INT 3
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: PUSH
25001: LD_INT 1
25003: ARRAY
25004: PPUSH
25005: CALL_OW 228
// end ;
25009: PPOPN 2
25011: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
25012: LD_EXP 60
25016: PPUSH
25017: CALL_OW 256
25021: PUSH
25022: LD_INT 999
25024: LESS
25025: PUSH
25026: LD_INT 22
25028: PUSH
25029: LD_INT 8
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PUSH
25036: LD_INT 21
25038: PUSH
25039: LD_INT 1
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: LD_INT 23
25048: PUSH
25049: LD_INT 2
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: LIST
25060: PPUSH
25061: CALL_OW 69
25065: PUSH
25066: LD_INT 9
25068: PUSH
25069: LD_INT 8
25071: PUSH
25072: LD_INT 7
25074: PUSH
25075: LD_INT 6
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: LIST
25082: LIST
25083: PUSH
25084: LD_OWVAR 67
25088: ARRAY
25089: LESSEQUAL
25090: OR
25091: PUSH
25092: LD_INT 22
25094: PUSH
25095: LD_INT 8
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 34
25104: PUSH
25105: LD_INT 48
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: PPUSH
25116: CALL_OW 69
25120: NOT
25121: AND
25122: PUSH
25123: LD_EXP 60
25127: PPUSH
25128: CALL_OW 302
25132: AND
25133: PUSH
25134: LD_INT 5
25136: PPUSH
25137: LD_INT 22
25139: PUSH
25140: LD_INT 1
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: PPUSH
25147: CALL_OW 70
25151: AND
25152: IFFALSE 25865
25154: GO 25156
25156: DISABLE
25157: LD_INT 0
25159: PPUSH
25160: PPUSH
25161: PPUSH
// begin legionDestroyed := true ;
25162: LD_ADDR_EXP 22
25166: PUSH
25167: LD_INT 1
25169: ST_TO_ADDR
// DialogueOn ;
25170: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25174: LD_EXP 39
25178: PPUSH
25179: LD_STRING D13-JMM-1
25181: PPUSH
25182: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25186: LD_EXP 60
25190: PPUSH
25191: LD_STRING D13-Kurt-1
25193: PPUSH
25194: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25198: LD_EXP 39
25202: PPUSH
25203: LD_STRING D13-JMM-2
25205: PPUSH
25206: CALL_OW 88
// if FakeInfo then
25210: LD_EXP 12
25214: IFFALSE 25234
// begin Say ( Kurt , D13-Kurt-2 ) ;
25216: LD_EXP 60
25220: PPUSH
25221: LD_STRING D13-Kurt-2
25223: PPUSH
25224: CALL_OW 88
// DialogueOff ;
25228: CALL_OW 7
// exit ;
25232: GO 25865
// end ; if not KurtStatus then
25234: LD_EXP 3
25238: NOT
25239: IFFALSE 25255
// Say ( Kurt , D13-Kurt-2b ) else
25241: LD_EXP 60
25245: PPUSH
25246: LD_STRING D13-Kurt-2b
25248: PPUSH
25249: CALL_OW 88
25253: GO 25267
// Say ( Kurt , D13-Kurt-2a ) ;
25255: LD_EXP 60
25259: PPUSH
25260: LD_STRING D13-Kurt-2a
25262: PPUSH
25263: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25267: LD_EXP 39
25271: PPUSH
25272: LD_STRING D13-JMM-3
25274: PPUSH
25275: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25279: LD_EXP 60
25283: PPUSH
25284: LD_STRING D13-Kurt-3
25286: PPUSH
25287: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25291: LD_EXP 39
25295: PPUSH
25296: LD_STRING D13-JMM-4
25298: PPUSH
25299: CALL_OW 88
// DialogueOff ;
25303: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25307: LD_STRING MlegionOut
25309: PPUSH
25310: CALL_OW 337
// MC_Kill ( 3 ) ;
25314: LD_INT 3
25316: PPUSH
25317: CALL 35536 0 1
// KillUnit ( Kozlov ) ;
25321: LD_EXP 61
25325: PPUSH
25326: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25330: LD_ADDR_VAR 0 1
25334: PUSH
25335: LD_INT 22
25337: PUSH
25338: LD_INT 8
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_INT 23
25347: PUSH
25348: LD_INT 3
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: PUSH
25355: LD_INT 3
25357: PUSH
25358: LD_INT 21
25360: PUSH
25361: LD_INT 33
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: LIST
25376: PPUSH
25377: CALL_OW 69
25381: PUSH
25382: FOR_IN
25383: IFFALSE 25396
// KillUnit ( i ) ;
25385: LD_VAR 0 1
25389: PPUSH
25390: CALL_OW 66
25394: GO 25382
25396: POP
25397: POP
// ChangeSideFog ( 8 , 1 ) ;
25398: LD_INT 8
25400: PPUSH
25401: LD_INT 1
25403: PPUSH
25404: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25408: LD_ADDR_VAR 0 2
25412: PUSH
25413: LD_INT 22
25415: PUSH
25416: LD_INT 8
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 21
25425: PUSH
25426: LD_INT 1
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PPUSH
25437: CALL_OW 69
25441: PUSH
25442: LD_EXP 61
25446: PUSH
25447: LD_EXP 60
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: DIFF
25456: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_INT 6
25464: PUSH
25465: LD_INT 5
25467: PUSH
25468: LD_INT 4
25470: PUSH
25471: LD_INT 3
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: PUSH
25480: LD_OWVAR 67
25484: ARRAY
25485: GREATEREQUAL
25486: IFFALSE 25664
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25488: LD_ADDR_VAR 0 3
25492: PUSH
25493: LD_INT 6
25495: PUSH
25496: LD_INT 5
25498: PUSH
25499: LD_INT 4
25501: PUSH
25502: LD_INT 3
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: LIST
25509: LIST
25510: PUSH
25511: LD_OWVAR 67
25515: ARRAY
25516: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25517: LD_ADDR_VAR 0 1
25521: PUSH
25522: DOUBLE
25523: LD_VAR 0 2
25527: PUSH
25528: LD_VAR 0 3
25532: PUSH
25533: LD_INT 1
25535: PLUS
25536: MINUS
25537: INC
25538: ST_TO_ADDR
25539: LD_INT 1
25541: PUSH
25542: FOR_DOWNTO
25543: IFFALSE 25660
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25545: LD_ADDR_EXP 38
25549: PUSH
25550: LD_EXP 38
25554: PUSH
25555: LD_VAR 0 2
25559: PUSH
25560: LD_VAR 0 1
25564: ARRAY
25565: ADD
25566: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25567: LD_VAR 0 2
25571: PUSH
25572: LD_VAR 0 1
25576: ARRAY
25577: PPUSH
25578: CALL_OW 310
25582: IFFALSE 25599
// ComExitBuilding ( tmp [ i ] ) ;
25584: LD_VAR 0 2
25588: PUSH
25589: LD_VAR 0 1
25593: ARRAY
25594: PPUSH
25595: CALL_OW 122
// if IsInUnit ( i ) then
25599: LD_VAR 0 1
25603: PPUSH
25604: CALL_OW 310
25608: IFFALSE 25625
// ComExitVehicle ( tmp [ i ] ) ;
25610: LD_VAR 0 2
25614: PUSH
25615: LD_VAR 0 1
25619: ARRAY
25620: PPUSH
25621: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25625: LD_VAR 0 2
25629: PUSH
25630: LD_VAR 0 1
25634: ARRAY
25635: PPUSH
25636: LD_INT 34
25638: PUSH
25639: LD_INT 0
25641: PPUSH
25642: LD_INT 6
25644: PPUSH
25645: CALL_OW 12
25649: PLUS
25650: PPUSH
25651: LD_INT 1
25653: PPUSH
25654: CALL_OW 171
// end ;
25658: GO 25542
25660: POP
25661: POP
// end else
25662: GO 25674
// x := tmp ;
25664: LD_ADDR_VAR 0 3
25668: PUSH
25669: LD_VAR 0 2
25673: ST_TO_ADDR
// for i := tmp downto tmp - x do
25674: LD_ADDR_VAR 0 1
25678: PUSH
25679: DOUBLE
25680: LD_VAR 0 2
25684: INC
25685: ST_TO_ADDR
25686: LD_VAR 0 2
25690: PUSH
25691: LD_VAR 0 3
25695: MINUS
25696: PUSH
25697: FOR_DOWNTO
25698: IFFALSE 25752
// begin if IsInUnit ( tmp [ i ] ) then
25700: LD_VAR 0 2
25704: PUSH
25705: LD_VAR 0 1
25709: ARRAY
25710: PPUSH
25711: CALL_OW 310
25715: IFFALSE 25732
// ComExitVehicle ( tmp [ i ] ) ;
25717: LD_VAR 0 2
25721: PUSH
25722: LD_VAR 0 1
25726: ARRAY
25727: PPUSH
25728: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25732: LD_VAR 0 2
25736: PUSH
25737: LD_VAR 0 1
25741: ARRAY
25742: PPUSH
25743: LD_INT 1
25745: PPUSH
25746: CALL_OW 235
// end ;
25750: GO 25697
25752: POP
25753: POP
// SetSide ( Kurt , 1 ) ;
25754: LD_EXP 60
25758: PPUSH
25759: LD_INT 1
25761: PPUSH
25762: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25766: LD_INT 22
25768: PUSH
25769: LD_INT 8
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 21
25778: PUSH
25779: LD_INT 3
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: EMPTY
25787: LIST
25788: LIST
25789: PPUSH
25790: CALL_OW 69
25794: PPUSH
25795: LD_INT 1
25797: PPUSH
25798: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25802: LD_INT 8
25804: PPUSH
25805: LD_INT 1
25807: PPUSH
25808: LD_INT 1
25810: PPUSH
25811: LD_INT 1
25813: PPUSH
25814: CALL_OW 80
// wait ( 1 1$20 ) ;
25818: LD_INT 2800
25820: PPUSH
25821: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25825: LD_EXP 62
25829: PPUSH
25830: LD_INT 37
25832: PPUSH
25833: LD_INT 1
25835: PPUSH
25836: LD_INT 0
25838: PPUSH
25839: CALL_OW 48
// wait ( 0 0$1 ) ;
25843: LD_INT 35
25845: PPUSH
25846: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25850: LD_EXP 62
25854: PPUSH
25855: LD_INT 60
25857: PPUSH
25858: LD_INT 95
25860: PPUSH
25861: CALL_OW 111
// end ;
25865: PPOPN 3
25867: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25868: LD_EXP 22
25872: NOT
25873: PUSH
25874: LD_INT 22
25876: PUSH
25877: LD_INT 8
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 21
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: PPUSH
25898: CALL_OW 69
25902: PUSH
25903: LD_INT 0
25905: EQUAL
25906: AND
25907: IFFALSE 25927
25909: GO 25911
25911: DISABLE
// begin legionDestroyed := true ;
25912: LD_ADDR_EXP 22
25916: PUSH
25917: LD_INT 1
25919: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25920: LD_STRING MlegionOut
25922: PPUSH
25923: CALL_OW 337
// end ;
25927: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25928: LD_EXP 38
25932: IFFALSE 26007
25934: GO 25936
25936: DISABLE
25937: LD_INT 0
25939: PPUSH
// begin enable ;
25940: ENABLE
// for i in legionEscapeUnits do
25941: LD_ADDR_VAR 0 1
25945: PUSH
25946: LD_EXP 38
25950: PUSH
25951: FOR_IN
25952: IFFALSE 26005
// begin if IsInArea ( i , legionEscapeArea ) then
25954: LD_VAR 0 1
25958: PPUSH
25959: LD_INT 31
25961: PPUSH
25962: CALL_OW 308
25966: IFFALSE 25979
// RemoveUnit ( i ) else
25968: LD_VAR 0 1
25972: PPUSH
25973: CALL_OW 64
25977: GO 26003
// if not HasTask ( i ) then
25979: LD_VAR 0 1
25983: PPUSH
25984: CALL_OW 314
25988: NOT
25989: IFFALSE 26003
// ComMoveToArea ( i , legionEscapeArea ) ;
25991: LD_VAR 0 1
25995: PPUSH
25996: LD_INT 31
25998: PPUSH
25999: CALL_OW 113
// end ;
26003: GO 25951
26005: POP
26006: POP
// end ;
26007: PPOPN 1
26009: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
26010: LD_INT 1
26012: PPUSH
26013: LD_EXP 62
26017: PPUSH
26018: CALL_OW 292
26022: IFFALSE 26320
26024: GO 26026
26026: DISABLE
26027: LD_INT 0
26029: PPUSH
// begin wait ( 0 0$2 ) ;
26030: LD_INT 70
26032: PPUSH
26033: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26037: LD_EXP 62
26041: PPUSH
26042: CALL_OW 87
// DialogueOn ;
26046: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26050: LD_EXP 39
26054: PPUSH
26055: LD_STRING D14-JMM-1
26057: PPUSH
26058: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26062: LD_EXP 62
26066: PPUSH
26067: LD_STRING D14-Friend-1
26069: PPUSH
26070: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26074: LD_EXP 39
26078: PPUSH
26079: LD_STRING D14-JMM-2
26081: PPUSH
26082: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26086: LD_EXP 62
26090: PPUSH
26091: LD_STRING D14-Friend-2
26093: PPUSH
26094: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26098: LD_EXP 39
26102: PPUSH
26103: LD_STRING D14-JMM-3
26105: PPUSH
26106: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26110: LD_EXP 62
26114: PPUSH
26115: LD_STRING D14-Friend-3
26117: PPUSH
26118: CALL_OW 88
// DialogueOff ;
26122: CALL_OW 7
// dec = Query ( Q14 ) ;
26126: LD_ADDR_VAR 0 1
26130: PUSH
26131: LD_STRING Q14
26133: PPUSH
26134: CALL_OW 97
26138: ST_TO_ADDR
// if dec = 1 then
26139: LD_VAR 0 1
26143: PUSH
26144: LD_INT 1
26146: EQUAL
26147: IFFALSE 26181
// begin DialogueOn ;
26149: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26153: LD_EXP 39
26157: PPUSH
26158: LD_STRING D14a-JMM-1
26160: PPUSH
26161: CALL_OW 88
// DialogueOff ;
26165: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26169: LD_EXP 62
26173: PPUSH
26174: LD_INT 1
26176: PPUSH
26177: CALL_OW 235
// end ; if dec = 2 then
26181: LD_VAR 0 1
26185: PUSH
26186: LD_INT 2
26188: EQUAL
26189: IFFALSE 26242
// begin DialogueOn ;
26191: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26195: LD_EXP 39
26199: PPUSH
26200: LD_STRING D14b-JMM-1
26202: PPUSH
26203: CALL_OW 88
// DialogueOff ;
26207: CALL_OW 7
// wait ( 0 0$1 ) ;
26211: LD_INT 35
26213: PPUSH
26214: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26218: LD_EXP 62
26222: PPUSH
26223: LD_INT 9
26225: PPUSH
26226: LD_INT 2
26228: PPUSH
26229: CALL_OW 111
// AddComHold ( Friend ) ;
26233: LD_EXP 62
26237: PPUSH
26238: CALL_OW 200
// end ; if dec = 3 then
26242: LD_VAR 0 1
26246: PUSH
26247: LD_INT 3
26249: EQUAL
26250: IFFALSE 26320
// begin DialogueOn ;
26252: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26256: LD_EXP 39
26260: PPUSH
26261: LD_STRING D14c-JMM-1
26263: PPUSH
26264: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26268: LD_EXP 62
26272: PPUSH
26273: LD_STRING D14c-Friend-1
26275: PPUSH
26276: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26280: LD_EXP 39
26284: PPUSH
26285: LD_STRING D14c-JMM-2
26287: PPUSH
26288: CALL_OW 88
// DialogueOff ;
26292: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26296: LD_EXP 62
26300: PPUSH
26301: LD_INT 9
26303: PPUSH
26304: LD_INT 2
26306: PPUSH
26307: CALL_OW 111
// AddComHold ( Friend ) ;
26311: LD_EXP 62
26315: PPUSH
26316: CALL_OW 200
// end ; end ;
26320: PPOPN 1
26322: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26323: LD_INT 9
26325: PPUSH
26326: LD_INT 2
26328: PPUSH
26329: CALL_OW 428
26333: PUSH
26334: LD_EXP 62
26338: EQUAL
26339: PUSH
26340: LD_EXP 62
26344: PPUSH
26345: CALL_OW 255
26349: PUSH
26350: LD_INT 8
26352: EQUAL
26353: AND
26354: IFFALSE 26368
26356: GO 26358
26358: DISABLE
// RemoveUnit ( Friend ) ;
26359: LD_EXP 62
26363: PPUSH
26364: CALL_OW 64
26368: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26369: LD_EXP 14
26373: PUSH
26374: LD_INT 31500
26376: GREATEREQUAL
26377: PUSH
26378: LD_EXP 7
26382: AND
26383: PUSH
26384: LD_EXP 2
26388: AND
26389: IFFALSE 26819
26391: GO 26393
26393: DISABLE
26394: LD_INT 0
26396: PPUSH
26397: PPUSH
26398: PPUSH
// begin missionStage := 7 ;
26399: LD_ADDR_EXP 15
26403: PUSH
26404: LD_INT 7
26406: ST_TO_ADDR
// uc_side = 1 ;
26407: LD_ADDR_OWVAR 20
26411: PUSH
26412: LD_INT 1
26414: ST_TO_ADDR
// uc_nation = 1 ;
26415: LD_ADDR_OWVAR 21
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// for i = 1 to 5 do
26423: LD_ADDR_VAR 0 1
26427: PUSH
26428: DOUBLE
26429: LD_INT 1
26431: DEC
26432: ST_TO_ADDR
26433: LD_INT 5
26435: PUSH
26436: FOR_TO
26437: IFFALSE 26533
// begin vc_engine = 3 ;
26439: LD_ADDR_OWVAR 39
26443: PUSH
26444: LD_INT 3
26446: ST_TO_ADDR
// vc_control = 3 ;
26447: LD_ADDR_OWVAR 38
26451: PUSH
26452: LD_INT 3
26454: ST_TO_ADDR
// vc_chassis = 3 ;
26455: LD_ADDR_OWVAR 37
26459: PUSH
26460: LD_INT 3
26462: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26463: LD_ADDR_OWVAR 40
26467: PUSH
26468: LD_INT 5
26470: PUSH
26471: LD_INT 9
26473: PUSH
26474: LD_INT 7
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 1
26484: PPUSH
26485: LD_INT 3
26487: PPUSH
26488: CALL_OW 12
26492: ARRAY
26493: ST_TO_ADDR
// veh = CreateVehicle ;
26494: LD_ADDR_VAR 0 2
26498: PUSH
26499: CALL_OW 45
26503: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26504: LD_VAR 0 2
26508: PPUSH
26509: LD_INT 1
26511: PPUSH
26512: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26516: LD_VAR 0 2
26520: PPUSH
26521: LD_INT 19
26523: PPUSH
26524: LD_INT 0
26526: PPUSH
26527: CALL_OW 49
// end ;
26531: GO 26436
26533: POP
26534: POP
// vc_engine = 3 ;
26535: LD_ADDR_OWVAR 39
26539: PUSH
26540: LD_INT 3
26542: ST_TO_ADDR
// vc_control = 1 ;
26543: LD_ADDR_OWVAR 38
26547: PUSH
26548: LD_INT 1
26550: ST_TO_ADDR
// vc_chassis = 3 ;
26551: LD_ADDR_OWVAR 37
26555: PUSH
26556: LD_INT 3
26558: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26559: LD_ADDR_OWVAR 40
26563: PUSH
26564: LD_INT 5
26566: PUSH
26567: LD_INT 9
26569: PUSH
26570: LD_INT 7
26572: PUSH
26573: EMPTY
26574: LIST
26575: LIST
26576: LIST
26577: PUSH
26578: LD_INT 1
26580: PPUSH
26581: LD_INT 3
26583: PPUSH
26584: CALL_OW 12
26588: ARRAY
26589: ST_TO_ADDR
// vehG = CreateVehicle ;
26590: LD_ADDR_VAR 0 3
26594: PUSH
26595: CALL_OW 45
26599: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26600: LD_VAR 0 3
26604: PPUSH
26605: LD_INT 1
26607: PPUSH
26608: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26612: LD_VAR 0 3
26616: PPUSH
26617: LD_INT 19
26619: PPUSH
26620: LD_INT 0
26622: PPUSH
26623: CALL_OW 49
// if JMMGirl = 1 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 1
26634: EQUAL
26635: IFFALSE 26691
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26637: LD_ADDR_EXP 40
26641: PUSH
26642: LD_STRING Joan
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65920 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26656: LD_EXP 40
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26679: LD_EXP 40
26683: PPUSH
26684: LD_STRING D10BW-Joan-1
26686: PPUSH
26687: CALL_OW 94
// end ; if JMMGirl = 2 then
26691: LD_EXP 7
26695: PUSH
26696: LD_INT 2
26698: EQUAL
26699: IFFALSE 26755
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26701: LD_ADDR_EXP 42
26705: PUSH
26706: LD_STRING Lisa
26708: PPUSH
26709: LD_INT 1
26711: PPUSH
26712: LD_STRING 14_
26714: PPUSH
26715: CALL 65920 0 3
26719: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26720: LD_EXP 42
26724: PPUSH
26725: LD_VAR 0 3
26729: PPUSH
26730: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26734: LD_VAR 0 3
26738: PPUSH
26739: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26743: LD_EXP 42
26747: PPUSH
26748: LD_STRING D10BW-Lisa-1
26750: PPUSH
26751: CALL_OW 94
// end ; if JMMGirl = 3 then
26755: LD_EXP 7
26759: PUSH
26760: LD_INT 3
26762: EQUAL
26763: IFFALSE 26819
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26765: LD_ADDR_EXP 54
26769: PUSH
26770: LD_STRING Connie
26772: PPUSH
26773: LD_INT 1
26775: PPUSH
26776: LD_STRING 14_
26778: PPUSH
26779: CALL 65920 0 3
26783: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26784: LD_EXP 54
26788: PPUSH
26789: LD_VAR 0 3
26793: PPUSH
26794: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26798: LD_VAR 0 3
26802: PPUSH
26803: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26807: LD_EXP 54
26811: PPUSH
26812: LD_STRING D10BW-Con-1
26814: PPUSH
26815: CALL_OW 94
// end ; end ;
26819: PPOPN 3
26821: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26822: LD_EXP 14
26826: PUSH
26827: LD_INT 94500
26829: GREATEREQUAL
26830: IFFALSE 27242
26832: GO 26834
26834: DISABLE
26835: LD_INT 0
26837: PPUSH
26838: PPUSH
26839: PPUSH
// begin tmp := PrepareStevensSquad ;
26840: LD_ADDR_VAR 0 3
26844: PUSH
26845: CALL 2226 0 0
26849: ST_TO_ADDR
// if not tmp then
26850: LD_VAR 0 3
26854: NOT
26855: IFFALSE 26859
// exit ;
26857: GO 27242
// uc_side := 1 ;
26859: LD_ADDR_OWVAR 20
26863: PUSH
26864: LD_INT 1
26866: ST_TO_ADDR
// uc_nation := 1 ;
26867: LD_ADDR_OWVAR 21
26871: PUSH
26872: LD_INT 1
26874: ST_TO_ADDR
// for i in tmp do
26875: LD_ADDR_VAR 0 1
26879: PUSH
26880: LD_VAR 0 3
26884: PUSH
26885: FOR_IN
26886: IFFALSE 26983
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26888: LD_INT 3
26890: PPUSH
26891: LD_INT 3
26893: PPUSH
26894: LD_INT 1
26896: PPUSH
26897: LD_INT 5
26899: PUSH
26900: LD_INT 9
26902: PUSH
26903: LD_INT 7
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: LIST
26910: PUSH
26911: LD_INT 1
26913: PPUSH
26914: LD_INT 3
26916: PPUSH
26917: CALL_OW 12
26921: ARRAY
26922: PPUSH
26923: LD_INT 40
26925: PPUSH
26926: CALL 70937 0 5
// veh := CreateVehicle ;
26930: LD_ADDR_VAR 0 2
26934: PUSH
26935: CALL_OW 45
26939: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26940: LD_VAR 0 2
26944: PPUSH
26945: LD_INT 1
26947: PPUSH
26948: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26952: LD_VAR 0 2
26956: PPUSH
26957: LD_INT 19
26959: PPUSH
26960: LD_INT 0
26962: PPUSH
26963: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26967: LD_VAR 0 1
26971: PPUSH
26972: LD_VAR 0 2
26976: PPUSH
26977: CALL_OW 52
// end ;
26981: GO 26885
26983: POP
26984: POP
// missionStage := 8 ;
26985: LD_ADDR_EXP 15
26989: PUSH
26990: LD_INT 8
26992: ST_TO_ADDR
// DialogueOn ;
26993: CALL_OW 6
// if Stevens then
26997: LD_EXP 41
27001: IFFALSE 27115
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
27003: LD_EXP 41
27007: PPUSH
27008: CALL_OW 310
27012: PPUSH
27013: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
27017: LD_EXP 41
27021: PPUSH
27022: LD_STRING D8-Huck-1
27024: PPUSH
27025: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27029: LD_EXP 39
27033: PPUSH
27034: LD_STRING D8-JMM-1
27036: PPUSH
27037: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27041: LD_EXP 41
27045: PPUSH
27046: LD_STRING D8-Huck-2
27048: PPUSH
27049: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27053: LD_EXP 39
27057: PPUSH
27058: LD_STRING D8-JMM-2
27060: PPUSH
27061: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27065: LD_EXP 41
27069: PPUSH
27070: LD_STRING D8-Huck-3
27072: PPUSH
27073: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27077: LD_EXP 39
27081: PPUSH
27082: LD_STRING D8-JMM-3
27084: PPUSH
27085: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27089: LD_EXP 41
27093: PPUSH
27094: LD_STRING D8-Huck-4
27096: PPUSH
27097: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27101: LD_EXP 39
27105: PPUSH
27106: LD_STRING D8-JMM-4
27108: PPUSH
27109: CALL_OW 88
// end else
27113: GO 27225
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27115: LD_EXP 55
27119: PPUSH
27120: CALL_OW 310
27124: PPUSH
27125: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27129: LD_EXP 55
27133: PPUSH
27134: LD_STRING D8-Huck-1
27136: PPUSH
27137: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27141: LD_EXP 39
27145: PPUSH
27146: LD_STRING D8-JMM-1a
27148: PPUSH
27149: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27153: LD_EXP 55
27157: PPUSH
27158: LD_STRING D8-Huck-2
27160: PPUSH
27161: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27165: LD_EXP 39
27169: PPUSH
27170: LD_STRING D8-JMM-2
27172: PPUSH
27173: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27177: LD_EXP 55
27181: PPUSH
27182: LD_STRING D8-Huck-3
27184: PPUSH
27185: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27189: LD_EXP 39
27193: PPUSH
27194: LD_STRING D8-JMM-3
27196: PPUSH
27197: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27201: LD_EXP 55
27205: PPUSH
27206: LD_STRING D8-Huck-4
27208: PPUSH
27209: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27213: LD_EXP 39
27217: PPUSH
27218: LD_STRING D8-JMM-4
27220: PPUSH
27221: CALL_OW 88
// end ; DialogueOff ;
27225: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27229: LD_INT 25
27231: PPUSH
27232: LD_INT 1
27234: PPUSH
27235: LD_INT 1
27237: PPUSH
27238: CALL_OW 322
// end ;
27242: PPOPN 3
27244: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27245: LD_INT 1
27247: PPUSH
27248: LD_EXP 71
27252: PPUSH
27253: CALL_OW 292
27257: IFFALSE 27508
27259: GO 27261
27261: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27262: LD_EXP 71
27266: PPUSH
27267: CALL_OW 87
// DialogueOn ;
27271: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27275: LD_EXP 39
27279: PPUSH
27280: LD_STRING D10nB-JMM-1
27282: PPUSH
27283: CALL_OW 88
// if BurlakStatus = 1 then
27287: LD_EXP 9
27291: PUSH
27292: LD_INT 1
27294: EQUAL
27295: IFFALSE 27309
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27297: LD_EXP 70
27301: PPUSH
27302: LD_STRING D10nB-Vse-1a
27304: PPUSH
27305: CALL_OW 94
// end ; if BurlakStatus = 0 then
27309: LD_EXP 9
27313: PUSH
27314: LD_INT 0
27316: EQUAL
27317: IFFALSE 27331
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27319: LD_EXP 70
27323: PPUSH
27324: LD_STRING D10nB-Vse-1
27326: PPUSH
27327: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27331: LD_EXP 39
27335: PPUSH
27336: LD_STRING D10nB-JMM-2
27338: PPUSH
27339: CALL_OW 88
// if KappaStatus then
27343: LD_EXP 2
27347: IFFALSE 27361
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27349: LD_EXP 70
27353: PPUSH
27354: LD_STRING D10nB-Vse-5a
27356: PPUSH
27357: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27361: LD_EXP 2
27365: NOT
27366: PUSH
27367: LD_EXP 6
27371: PUSH
27372: LD_INT 0
27374: EQUAL
27375: AND
27376: IFFALSE 27504
// begin if JMMGirl = 1 then
27378: LD_EXP 7
27382: PUSH
27383: LD_INT 1
27385: EQUAL
27386: IFFALSE 27436
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27388: LD_EXP 70
27392: PPUSH
27393: LD_STRING D10nB-Vse-2
27395: PPUSH
27396: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27400: LD_EXP 39
27404: PPUSH
27405: LD_STRING D10nB-JMM-3
27407: PPUSH
27408: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27412: LD_EXP 70
27416: PPUSH
27417: LD_STRING D10nB-Vse-3
27419: PPUSH
27420: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27424: LD_EXP 39
27428: PPUSH
27429: LD_STRING D10nB-JMM-4
27431: PPUSH
27432: CALL_OW 88
// end ; if JMMGirl = 2 then
27436: LD_EXP 7
27440: PUSH
27441: LD_INT 2
27443: EQUAL
27444: IFFALSE 27470
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27446: LD_EXP 70
27450: PPUSH
27451: LD_STRING D10nB-Vse-4
27453: PPUSH
27454: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27458: LD_EXP 39
27462: PPUSH
27463: LD_STRING D10nB-JMM-5
27465: PPUSH
27466: CALL_OW 88
// end ; if JMMGirl = 3 then
27470: LD_EXP 7
27474: PUSH
27475: LD_INT 3
27477: EQUAL
27478: IFFALSE 27504
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27480: LD_EXP 70
27484: PPUSH
27485: LD_STRING D10nB-Vse-5
27487: PPUSH
27488: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27492: LD_EXP 39
27496: PPUSH
27497: LD_STRING D10nB-JMM-6
27499: PPUSH
27500: CALL_OW 88
// end ; end ; DialogueOff ;
27504: CALL_OW 7
// end ;
27508: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27509: LD_EXP 14
27513: PUSH
27514: LD_INT 115500
27516: GREATEREQUAL
27517: IFFALSE 27893
27519: GO 27521
27521: DISABLE
27522: LD_INT 0
27524: PPUSH
// begin missionStage := 10 ;
27525: LD_ADDR_EXP 15
27529: PUSH
27530: LD_INT 10
27532: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27533: LD_ADDR_VAR 0 1
27537: PUSH
27538: LD_INT 22
27540: PUSH
27541: LD_INT 1
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 23
27550: PUSH
27551: LD_INT 1
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 26
27560: PUSH
27561: LD_INT 1
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 3
27570: PUSH
27571: LD_INT 25
27573: PUSH
27574: LD_INT 12
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 3
27587: PUSH
27588: LD_INT 25
27590: PUSH
27591: LD_INT 16
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: EMPTY
27599: LIST
27600: LIST
27601: PUSH
27602: EMPTY
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: PPUSH
27609: CALL_OW 69
27613: PUSH
27614: LD_EXP 39
27618: PUSH
27619: LD_EXP 60
27623: PUSH
27624: LD_EXP 41
27628: PUSH
27629: LD_EXP 55
27633: PUSH
27634: LD_EXP 42
27638: PUSH
27639: LD_EXP 43
27643: PUSH
27644: LD_EXP 44
27648: PUSH
27649: LD_EXP 45
27653: PUSH
27654: LD_EXP 46
27658: PUSH
27659: LD_EXP 47
27663: PUSH
27664: LD_EXP 48
27668: PUSH
27669: LD_EXP 49
27673: PUSH
27674: LD_EXP 50
27678: PUSH
27679: LD_EXP 51
27683: PUSH
27684: LD_EXP 52
27688: PUSH
27689: LD_EXP 53
27693: PUSH
27694: EMPTY
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: DIFF
27712: ST_TO_ADDR
// if not tmp and Brown then
27713: LD_VAR 0 1
27717: NOT
27718: PUSH
27719: LD_EXP 47
27723: AND
27724: IFFALSE 27739
// tmp := [ Brown ] ;
27726: LD_ADDR_VAR 0 1
27730: PUSH
27731: LD_EXP 47
27735: PUSH
27736: EMPTY
27737: LIST
27738: ST_TO_ADDR
// DialogueOn ;
27739: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27743: LD_VAR 0 1
27747: PUSH
27748: LD_INT 1
27750: ARRAY
27751: PPUSH
27752: LD_STRING D11-Sol1-1
27754: PPUSH
27755: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27759: LD_EXP 64
27763: PPUSH
27764: LD_STRING D11-Pla-1
27766: PPUSH
27767: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27771: LD_EXP 65
27775: PPUSH
27776: LD_STRING D11-Kov-1
27778: PPUSH
27779: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27783: LD_EXP 64
27787: PPUSH
27788: LD_STRING D11-Pla-2
27790: PPUSH
27791: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27795: LD_VAR 0 1
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: LD_STRING D11-Sol1-2
27806: PPUSH
27807: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27811: LD_EXP 39
27815: PPUSH
27816: LD_STRING D11-JMM-2
27818: PPUSH
27819: CALL_OW 88
// DialogueOff ;
27823: CALL_OW 7
// allowBehemothConstruct := true ;
27827: LD_ADDR_EXP 25
27831: PUSH
27832: LD_INT 1
27834: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27835: LD_STRING M4
27837: PPUSH
27838: CALL_OW 337
// BuildBehemoths ;
27842: CALL 7741 0 0
// repeat wait ( 15 15$00 ) ;
27846: LD_INT 31500
27848: PPUSH
27849: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27853: LD_EXP 27
27857: IFFALSE 27861
// break ;
27859: GO 27893
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27861: LD_INT 267
27863: PPUSH
27864: CALL_OW 274
27868: PPUSH
27869: LD_INT 1
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_INT 1000
27879: GREATEREQUAL
27880: IFFALSE 27886
// BuildBehemoths ;
27882: CALL 7741 0 0
// until not behemothBuilders ;
27886: LD_EXP 73
27890: NOT
27891: IFFALSE 27846
// end ;
27893: PPOPN 1
27895: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27896: LD_EXP 73
27900: NOT
27901: PUSH
27902: LD_EXP 28
27906: NOT
27907: AND
27908: PUSH
27909: LD_EXP 25
27913: AND
27914: IFFALSE 27934
27916: GO 27918
27918: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27919: LD_STRING M4a
27921: PPUSH
27922: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27926: LD_ADDR_EXP 27
27930: PUSH
27931: LD_INT 1
27933: ST_TO_ADDR
// end ;
27934: END
// every 0 0$1 trigger behemothDone do
27935: LD_EXP 28
27939: IFFALSE 27951
27941: GO 27943
27943: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27944: LD_STRING M4b
27946: PPUSH
27947: CALL_OW 337
27951: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27952: LD_EXP 29
27956: NOT
27957: IFFALSE 28153
27959: GO 27961
27961: DISABLE
27962: LD_INT 0
27964: PPUSH
27965: PPUSH
// begin enable ;
27966: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27967: LD_ADDR_VAR 0 1
27971: PUSH
27972: LD_INT 3
27974: PPUSH
27975: CALL 103382 0 1
27979: ST_TO_ADDR
// if not tmp and not behemothDone then
27980: LD_VAR 0 1
27984: NOT
27985: PUSH
27986: LD_EXP 28
27990: NOT
27991: AND
27992: IFFALSE 28028
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27994: LD_ADDR_VAR 0 1
27998: PUSH
27999: LD_INT 22
28001: PUSH
28002: LD_INT 3
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: PUSH
28009: LD_INT 30
28011: PUSH
28012: LD_INT 37
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PPUSH
28023: CALL_OW 69
28027: ST_TO_ADDR
// if not tmp then
28028: LD_VAR 0 1
28032: NOT
28033: IFFALSE 28037
// exit ;
28035: GO 28153
// for i in tmp do
28037: LD_ADDR_VAR 0 2
28041: PUSH
28042: LD_VAR 0 1
28046: PUSH
28047: FOR_IN
28048: IFFALSE 28151
// if See ( 1 , i ) then
28050: LD_INT 1
28052: PPUSH
28053: LD_VAR 0 2
28057: PPUSH
28058: CALL_OW 292
28062: IFFALSE 28149
// begin if GetType ( i ) = unit_building then
28064: LD_VAR 0 2
28068: PPUSH
28069: CALL_OW 247
28073: PUSH
28074: LD_INT 3
28076: EQUAL
28077: IFFALSE 28115
// begin CenterNowOnUnits ( i ) ;
28079: LD_VAR 0 2
28083: PPUSH
28084: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28088: LD_EXP 39
28092: PPUSH
28093: LD_STRING D17a-JMM-1
28095: PPUSH
28096: CALL_OW 88
// seeBehemoth := true ;
28100: LD_ADDR_EXP 29
28104: PUSH
28105: LD_INT 1
28107: ST_TO_ADDR
// disable ;
28108: DISABLE
// exit ;
28109: POP
28110: POP
28111: GO 28153
// end else
28113: GO 28149
// begin CenterNowOnUnits ( i ) ;
28115: LD_VAR 0 2
28119: PPUSH
28120: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28124: LD_EXP 39
28128: PPUSH
28129: LD_STRING D17b-JMM-1
28131: PPUSH
28132: CALL_OW 88
// seeBehemoth := true ;
28136: LD_ADDR_EXP 29
28140: PUSH
28141: LD_INT 1
28143: ST_TO_ADDR
// disable ;
28144: DISABLE
// exit ;
28145: POP
28146: POP
28147: GO 28153
// end ; end ;
28149: GO 28047
28151: POP
28152: POP
// end ;
28153: PPOPN 2
28155: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28156: LD_EXP 14
28160: PUSH
28161: LD_INT 123200
28163: GREATEREQUAL
28164: IFFALSE 29340
28166: GO 28168
28168: DISABLE
28169: LD_INT 0
28171: PPUSH
28172: PPUSH
28173: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28174: LD_INT 2
28176: PPUSH
28177: LD_INT 23
28179: PUSH
28180: LD_INT 3
28182: PUSH
28183: LD_INT 3
28185: PUSH
28186: LD_INT 48
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: PUSH
28195: EMPTY
28196: LIST
28197: PPUSH
28198: CALL 59514 0 2
// repeat wait ( 0 0$1 ) ;
28202: LD_INT 35
28204: PPUSH
28205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28209: LD_INT 22
28211: PUSH
28212: LD_INT 3
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 34
28221: PUSH
28222: LD_INT 48
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PPUSH
28233: CALL_OW 69
28237: IFFALSE 28202
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28239: LD_ADDR_VAR 0 1
28243: PUSH
28244: LD_INT 22
28246: PUSH
28247: LD_INT 3
28249: PUSH
28250: EMPTY
28251: LIST
28252: LIST
28253: PUSH
28254: LD_INT 34
28256: PUSH
28257: LD_INT 48
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PPUSH
28268: CALL_OW 69
28272: PUSH
28273: LD_INT 1
28275: ARRAY
28276: ST_TO_ADDR
// missionStage := 12 ;
28277: LD_ADDR_EXP 15
28281: PUSH
28282: LD_INT 12
28284: ST_TO_ADDR
// platonovHasBomb := true ;
28285: LD_ADDR_EXP 30
28289: PUSH
28290: LD_INT 1
28292: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28293: LD_VAR 0 1
28297: PPUSH
28298: LD_INT 181
28300: PPUSH
28301: LD_INT 86
28303: PPUSH
28304: CALL_OW 171
// AddComHold ( bomb ) ;
28308: LD_VAR 0 1
28312: PPUSH
28313: CALL_OW 200
// wait ( 0 0$10 ) ;
28317: LD_INT 350
28319: PPUSH
28320: CALL_OW 67
// DialogueOn ;
28324: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28328: LD_EXP 64
28332: PPUSH
28333: LD_STRING D15-Pla-1
28335: PPUSH
28336: CALL_OW 94
// dec = Query ( Q15a ) ;
28340: LD_ADDR_VAR 0 2
28344: PUSH
28345: LD_STRING Q15a
28347: PPUSH
28348: CALL_OW 97
28352: ST_TO_ADDR
// if dec = 1 then
28353: LD_VAR 0 2
28357: PUSH
28358: LD_INT 1
28360: EQUAL
28361: IFFALSE 28384
// begin Say ( JMM , D15a-JMM-1 ) ;
28363: LD_EXP 39
28367: PPUSH
28368: LD_STRING D15a-JMM-1
28370: PPUSH
28371: CALL_OW 88
// YouLost ( Surrender ) ;
28375: LD_STRING Surrender
28377: PPUSH
28378: CALL_OW 104
// exit ;
28382: GO 29340
// end ; if dec = 2 then
28384: LD_VAR 0 2
28388: PUSH
28389: LD_INT 2
28391: EQUAL
28392: IFFALSE 28461
// begin Say ( JMM , D15b-JMM-1 ) ;
28394: LD_EXP 39
28398: PPUSH
28399: LD_STRING D15b-JMM-1
28401: PPUSH
28402: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28406: LD_EXP 64
28410: PPUSH
28411: LD_STRING D15b-Pla-1
28413: PPUSH
28414: CALL_OW 94
// DialogueOff ;
28418: CALL_OW 7
// wait ( 3 3$00 ) ;
28422: LD_INT 6300
28424: PPUSH
28425: CALL_OW 67
// DialogueOn ;
28429: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28433: LD_EXP 39
28437: PPUSH
28438: LD_STRING D15d-JMM-1a
28440: PPUSH
28441: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28445: LD_EXP 64
28449: PPUSH
28450: LD_STRING D15d-Pla-1
28452: PPUSH
28453: CALL_OW 94
// DialogueOff ;
28457: CALL_OW 7
// end ; if dec = 3 then
28461: LD_VAR 0 2
28465: PUSH
28466: LD_INT 3
28468: EQUAL
28469: IFFALSE 28523
// begin Say ( JMM , D15c-JMM-1 ) ;
28471: LD_EXP 39
28475: PPUSH
28476: LD_STRING D15c-JMM-1
28478: PPUSH
28479: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28483: LD_EXP 64
28487: PPUSH
28488: LD_STRING D15c-Pla-1
28490: PPUSH
28491: CALL_OW 94
// DialogueOff ;
28495: CALL_OW 7
// wait ( 0 0$15 ) ;
28499: LD_INT 525
28501: PPUSH
28502: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28506: LD_VAR 0 1
28510: PPUSH
28511: LD_INT 60
28513: PPUSH
28514: LD_INT 95
28516: PPUSH
28517: CALL_OW 116
// exit ;
28521: GO 29340
// end ; if dec = 4 then
28523: LD_VAR 0 2
28527: PUSH
28528: LD_INT 4
28530: EQUAL
28531: IFFALSE 28561
// begin Say ( JMM , D15d-JMM-1 ) ;
28533: LD_EXP 39
28537: PPUSH
28538: LD_STRING D15d-JMM-1
28540: PPUSH
28541: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28545: LD_EXP 64
28549: PPUSH
28550: LD_STRING D15d-Pla-1
28552: PPUSH
28553: CALL_OW 94
// DialogueOff ;
28557: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28561: LD_EXP 62
28565: PPUSH
28566: CALL_OW 302
28570: PUSH
28571: LD_EXP 62
28575: PPUSH
28576: CALL_OW 255
28580: PUSH
28581: LD_INT 1
28583: EQUAL
28584: AND
28585: PUSH
28586: LD_INT 22
28588: PUSH
28589: LD_INT 1
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: LD_INT 34
28598: PUSH
28599: LD_INT 8
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PPUSH
28610: CALL_OW 69
28614: NOT
28615: AND
28616: IFFALSE 29241
// begin SetSide ( Friend , 8 ) ;
28618: LD_EXP 62
28622: PPUSH
28623: LD_INT 8
28625: PPUSH
28626: CALL_OW 235
// if IsInUnit ( Friend ) then
28630: LD_EXP 62
28634: PPUSH
28635: CALL_OW 310
28639: IFFALSE 28650
// ComExitBuilding ( Friend ) ;
28641: LD_EXP 62
28645: PPUSH
28646: CALL_OW 122
// if IsDriver ( Friend ) then
28650: LD_EXP 62
28654: PPUSH
28655: CALL 100930 0 1
28659: IFFALSE 28670
// ComExitVehicle ( Friend ) ;
28661: LD_EXP 62
28665: PPUSH
28666: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28670: LD_EXP 62
28674: PPUSH
28675: LD_INT 9
28677: PPUSH
28678: LD_INT 2
28680: PPUSH
28681: CALL_OW 171
// wait ( 0 0$05 ) ;
28685: LD_INT 175
28687: PPUSH
28688: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28692: LD_EXP 62
28696: PPUSH
28697: CALL_OW 87
// DialogueOn ;
28701: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28705: LD_EXP 39
28709: PPUSH
28710: LD_STRING D16-JMM-1
28712: PPUSH
28713: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28717: LD_EXP 62
28721: PPUSH
28722: LD_STRING D16-Friend-1
28724: PPUSH
28725: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28729: LD_EXP 39
28733: PPUSH
28734: LD_STRING D16-JMM-2
28736: PPUSH
28737: CALL_OW 88
// DialogueOff ;
28741: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28745: LD_EXP 62
28749: PPUSH
28750: LD_INT 1
28752: PPUSH
28753: CALL_OW 235
// ComHold ( Friend ) ;
28757: LD_EXP 62
28761: PPUSH
28762: CALL_OW 140
// wait ( 0 0$20 ) ;
28766: LD_INT 700
28768: PPUSH
28769: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28773: LD_EXP 62
28777: PPUSH
28778: LD_INT 9
28780: PPUSH
28781: LD_INT 2
28783: PPUSH
28784: CALL_OW 297
28788: PUSH
28789: LD_INT 30
28791: LESS
28792: IFFALSE 28861
// begin SetSide ( Friend , 8 ) ;
28794: LD_EXP 62
28798: PPUSH
28799: LD_INT 8
28801: PPUSH
28802: CALL_OW 235
// if IsInUnit ( Friend ) then
28806: LD_EXP 62
28810: PPUSH
28811: CALL_OW 310
28815: IFFALSE 28826
// ComExitBuilding ( Friend ) ;
28817: LD_EXP 62
28821: PPUSH
28822: CALL_OW 122
// if IsDriver ( Friend ) then
28826: LD_EXP 62
28830: PPUSH
28831: CALL 100930 0 1
28835: IFFALSE 28846
// ComExitVehicle ( Friend ) ;
28837: LD_EXP 62
28841: PPUSH
28842: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28846: LD_EXP 62
28850: PPUSH
28851: LD_INT 9
28853: PPUSH
28854: LD_INT 2
28856: PPUSH
28857: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28861: LD_INT 1050
28863: PPUSH
28864: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28868: LD_INT 22
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 34
28880: PUSH
28881: LD_INT 8
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PPUSH
28892: CALL_OW 69
28896: NOT
28897: IFFALSE 29219
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28899: LD_ADDR_VAR 0 3
28903: PUSH
28904: LD_INT 22
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 26
28916: PUSH
28917: LD_INT 1
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 3
28926: PUSH
28927: LD_INT 25
28929: PUSH
28930: LD_INT 12
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 25
28939: PUSH
28940: LD_INT 16
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: LIST
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: LIST
28956: PPUSH
28957: CALL_OW 69
28961: PUSH
28962: LD_EXP 39
28966: PUSH
28967: LD_EXP 41
28971: PUSH
28972: LD_EXP 55
28976: PUSH
28977: LD_EXP 42
28981: PUSH
28982: LD_EXP 43
28986: PUSH
28987: LD_EXP 44
28991: PUSH
28992: LD_EXP 45
28996: PUSH
28997: LD_EXP 46
29001: PUSH
29002: LD_EXP 47
29006: PUSH
29007: LD_EXP 48
29011: PUSH
29012: LD_EXP 49
29016: PUSH
29017: LD_EXP 50
29021: PUSH
29022: LD_EXP 51
29026: PUSH
29027: LD_EXP 52
29031: PUSH
29032: LD_EXP 53
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: DIFF
29054: ST_TO_ADDR
// DialogueOn ;
29055: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29059: LD_EXP 64
29063: PPUSH
29064: LD_STRING D16a-Pla-1
29066: PPUSH
29067: CALL_OW 94
// if Stevens then
29071: LD_EXP 41
29075: IFFALSE 29091
// Say ( Stevens , D16a-Huck-1 ) else
29077: LD_EXP 41
29081: PPUSH
29082: LD_STRING D16a-Huck-1
29084: PPUSH
29085: CALL_OW 88
29089: GO 29133
// if Baker then
29091: LD_EXP 55
29095: IFFALSE 29111
// Say ( Baker , D16a-Huck-1 ) else
29097: LD_EXP 55
29101: PPUSH
29102: LD_STRING D16a-Huck-1
29104: PPUSH
29105: CALL_OW 88
29109: GO 29133
// if tmp then
29111: LD_VAR 0 3
29115: IFFALSE 29133
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29117: LD_VAR 0 3
29121: PUSH
29122: LD_INT 1
29124: ARRAY
29125: PPUSH
29126: LD_STRING D16a-Sol1-1
29128: PPUSH
29129: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29133: LD_EXP 62
29137: PPUSH
29138: CALL_OW 255
29142: PUSH
29143: LD_INT 8
29145: EQUAL
29146: IFFALSE 29162
// Say ( JMM , D16a-JMM-1 ) else
29148: LD_EXP 39
29152: PPUSH
29153: LD_STRING D16a-JMM-1
29155: PPUSH
29156: CALL_OW 88
29160: GO 29198
// begin Say ( JMM , D16a-JMM-1a ) ;
29162: LD_EXP 39
29166: PPUSH
29167: LD_STRING D16a-JMM-1a
29169: PPUSH
29170: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29174: LD_EXP 62
29178: PPUSH
29179: LD_STRING D16a-Friend-1
29181: PPUSH
29182: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29186: LD_EXP 62
29190: PPUSH
29191: LD_INT 3
29193: PPUSH
29194: CALL_OW 235
// end ; DialogueOff ;
29198: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29202: LD_VAR 0 1
29206: PPUSH
29207: LD_INT 60
29209: PPUSH
29210: LD_INT 95
29212: PPUSH
29213: CALL_OW 116
// end else
29217: GO 29239
// begin DialogueOn ;
29219: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29223: LD_EXP 64
29227: PPUSH
29228: LD_STRING D16c-Pla-
29230: PPUSH
29231: CALL_OW 94
// DialogueOff ;
29235: CALL_OW 7
// end ; end else
29239: GO 29340
// begin wait ( 3 3$00 ) ;
29241: LD_INT 6300
29243: PPUSH
29244: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29248: LD_INT 22
29250: PUSH
29251: LD_INT 1
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 34
29260: PUSH
29261: LD_INT 8
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PPUSH
29272: CALL_OW 69
29276: NOT
29277: IFFALSE 29320
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29279: LD_EXP 64
29283: PPUSH
29284: LD_STRING D16b-Pla-1
29286: PPUSH
29287: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29291: LD_EXP 39
29295: PPUSH
29296: LD_STRING D16b-JMM-
29298: PPUSH
29299: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29303: LD_VAR 0 1
29307: PPUSH
29308: LD_INT 60
29310: PPUSH
29311: LD_INT 95
29313: PPUSH
29314: CALL_OW 116
// end else
29318: GO 29340
// begin DialogueOn ;
29320: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29324: LD_EXP 64
29328: PPUSH
29329: LD_STRING D16c-Pla-
29331: PPUSH
29332: CALL_OW 94
// DialogueOff ;
29336: CALL_OW 7
// end ; end ; end ;
29340: PPOPN 3
29342: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29343: LD_EXP 14
29347: PUSH
29348: LD_INT 126000
29350: GREATEREQUAL
29351: PUSH
29352: LD_EXP 23
29356: NOT
29357: AND
29358: PUSH
29359: LD_EXP 74
29363: PPUSH
29364: CALL_OW 302
29368: AND
29369: IFFALSE 29727
29371: GO 29373
29373: DISABLE
29374: LD_INT 0
29376: PPUSH
// begin missionStage = 11 ;
29377: LD_ADDR_EXP 15
29381: PUSH
29382: LD_INT 11
29384: ST_TO_ADDR
// DialogueOn ;
29385: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9-Roth-1
29396: PPUSH
29397: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29401: LD_EXP 39
29405: PPUSH
29406: LD_STRING D9-JMM-1
29408: PPUSH
29409: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29413: LD_EXP 74
29417: PPUSH
29418: LD_STRING D9-Roth-2
29420: PPUSH
29421: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29425: LD_EXP 74
29429: PPUSH
29430: LD_STRING D9-Roth-2a
29432: PPUSH
29433: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29437: LD_EXP 64
29441: PPUSH
29442: LD_STRING D9-Pla-2
29444: PPUSH
29445: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29449: LD_EXP 74
29453: PPUSH
29454: LD_STRING D9-Roth-3
29456: PPUSH
29457: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29461: LD_EXP 64
29465: PPUSH
29466: LD_STRING D9-Pla-3
29468: PPUSH
29469: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29473: LD_EXP 74
29477: PPUSH
29478: LD_STRING D9-Roth-4
29480: PPUSH
29481: CALL_OW 94
// dec = Query ( Q9 ) ;
29485: LD_ADDR_VAR 0 1
29489: PUSH
29490: LD_STRING Q9
29492: PPUSH
29493: CALL_OW 97
29497: ST_TO_ADDR
// if dec = 1 then
29498: LD_VAR 0 1
29502: PUSH
29503: LD_INT 1
29505: EQUAL
29506: IFFALSE 29520
// SayRadio ( Roth , D9a-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9a-Roth-1
29515: PPUSH
29516: CALL_OW 94
// if dec = 2 then
29520: LD_VAR 0 1
29524: PUSH
29525: LD_INT 2
29527: EQUAL
29528: IFFALSE 29554
// begin Say ( JMM , D9b-JMM-1 ) ;
29530: LD_EXP 39
29534: PPUSH
29535: LD_STRING D9b-JMM-1
29537: PPUSH
29538: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29542: LD_EXP 74
29546: PPUSH
29547: LD_STRING D9b-Roth-1
29549: PPUSH
29550: CALL_OW 94
// end ; if dec = 3 then
29554: LD_VAR 0 1
29558: PUSH
29559: LD_INT 3
29561: EQUAL
29562: IFFALSE 29624
// begin Say ( JMM , D9c-JMM-1 ) ;
29564: LD_EXP 39
29568: PPUSH
29569: LD_STRING D9c-JMM-1
29571: PPUSH
29572: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29576: LD_EXP 74
29580: PPUSH
29581: LD_STRING D9c-Roth-1
29583: PPUSH
29584: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29588: LD_EXP 39
29592: PPUSH
29593: LD_STRING D9c-JMM-2
29595: PPUSH
29596: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29600: LD_EXP 74
29604: PPUSH
29605: LD_STRING D9c-Roth-2
29607: PPUSH
29608: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29612: LD_EXP 39
29616: PPUSH
29617: LD_STRING D9c-JMM-3
29619: PPUSH
29620: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29624: LD_EXP 74
29628: PPUSH
29629: LD_STRING D9c-Roth-3
29631: PPUSH
29632: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29636: LD_EXP 74
29640: PPUSH
29641: LD_STRING D9cont-Roth-1
29643: PPUSH
29644: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29648: LD_EXP 39
29652: PPUSH
29653: LD_STRING D9cont-JMM-1
29655: PPUSH
29656: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29660: LD_EXP 74
29664: PPUSH
29665: LD_STRING D9cont-Roth-2
29667: PPUSH
29668: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29672: LD_EXP 39
29676: PPUSH
29677: LD_STRING D9cont-JMM-2
29679: PPUSH
29680: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29684: LD_EXP 74
29688: PPUSH
29689: LD_STRING D9cont-Roth-3
29691: PPUSH
29692: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29696: LD_EXP 39
29700: PPUSH
29701: LD_STRING D9cont-JMM-3
29703: PPUSH
29704: CALL_OW 88
// DialogueOff ;
29708: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29712: LD_STRING M3
29714: PPUSH
29715: CALL_OW 337
// allianceActive := true ;
29719: LD_ADDR_EXP 31
29723: PUSH
29724: LD_INT 1
29726: ST_TO_ADDR
// end ;
29727: PPOPN 1
29729: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29730: LD_INT 1
29732: PPUSH
29733: LD_INT 126
29735: PPUSH
29736: CALL_OW 292
29740: PUSH
29741: LD_EXP 64
29745: PPUSH
29746: CALL_OW 310
29750: AND
29751: IFFALSE 29831
29753: GO 29755
29755: DISABLE
29756: LD_INT 0
29758: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29759: LD_EXP 64
29763: PPUSH
29764: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29768: LD_ADDR_VAR 0 1
29772: PUSH
29773: LD_INT 4
29775: PPUSH
29776: LD_INT 22
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PPUSH
29786: CALL_OW 70
29790: PPUSH
29791: LD_EXP 64
29795: PPUSH
29796: CALL_OW 74
29800: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29801: LD_EXP 64
29805: PPUSH
29806: LD_VAR 0 1
29810: PUSH
29811: LD_INT 1
29813: ARRAY
29814: PPUSH
29815: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29819: LD_EXP 64
29823: PPUSH
29824: LD_STRING D18-Pla-1
29826: PPUSH
29827: CALL_OW 88
// end ;
29831: PPOPN 1
29833: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29834: LD_EXP 64
29838: PPUSH
29839: CALL_OW 301
29843: PUSH
29844: LD_EXP 67
29848: PPUSH
29849: CALL_OW 301
29853: AND
29854: PUSH
29855: LD_INT 22
29857: PUSH
29858: LD_INT 3
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 21
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 50
29877: PUSH
29878: EMPTY
29879: LIST
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: LIST
29885: PPUSH
29886: CALL_OW 69
29890: PUSH
29891: LD_INT 7
29893: PUSH
29894: LD_INT 8
29896: PUSH
29897: LD_INT 9
29899: PUSH
29900: LD_INT 10
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: PUSH
29909: LD_OWVAR 67
29913: ARRAY
29914: LESS
29915: AND
29916: IFFALSE 30687
29918: GO 29920
29920: DISABLE
29921: LD_INT 0
29923: PPUSH
29924: PPUSH
29925: PPUSH
29926: PPUSH
// begin MC_Kill ( 2 ) ;
29927: LD_INT 2
29929: PPUSH
29930: CALL 35536 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29934: LD_INT 1
29936: PPUSH
29937: LD_INT 3
29939: PPUSH
29940: LD_INT 1
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29950: LD_ADDR_VAR 0 1
29954: PUSH
29955: LD_INT 22
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 21
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 24
29977: PUSH
29978: LD_INT 900
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 69
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30027
// if GetSex ( i ) = sex_male then
29998: LD_VAR 0 1
30002: PPUSH
30003: CALL_OW 258
30007: PUSH
30008: LD_INT 1
30010: EQUAL
30011: IFFALSE 30025
// begin tmp = i ;
30013: LD_ADDR_VAR 0 2
30017: PUSH
30018: LD_VAR 0 1
30022: ST_TO_ADDR
// break ;
30023: GO 30027
// end ;
30025: GO 29995
30027: POP
30028: POP
// if tmp = 0 then
30029: LD_VAR 0 2
30033: PUSH
30034: LD_INT 0
30036: EQUAL
30037: IFFALSE 30091
// begin uc_side = 3 ;
30039: LD_ADDR_OWVAR 20
30043: PUSH
30044: LD_INT 3
30046: ST_TO_ADDR
// uc_nation = 3 ;
30047: LD_ADDR_OWVAR 21
30051: PUSH
30052: LD_INT 3
30054: ST_TO_ADDR
// hc_name =  ;
30055: LD_ADDR_OWVAR 26
30059: PUSH
30060: LD_STRING 
30062: ST_TO_ADDR
// hc_gallery =  ;
30063: LD_ADDR_OWVAR 33
30067: PUSH
30068: LD_STRING 
30070: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30071: LD_INT 1
30073: PPUSH
30074: LD_INT 10
30076: PPUSH
30077: CALL_OW 381
// tmp = CreateHuman ;
30081: LD_ADDR_VAR 0 2
30085: PUSH
30086: CALL_OW 44
30090: ST_TO_ADDR
// end ; DialogueOn ;
30091: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30095: LD_VAR 0 2
30099: PPUSH
30100: LD_STRING DSurrenderRussians-RSol1-1a
30102: PPUSH
30103: CALL_OW 94
// DialogueOff ;
30107: CALL_OW 7
// russianDestroyed := true ;
30111: LD_ADDR_EXP 21
30115: PUSH
30116: LD_INT 1
30118: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30119: LD_INT 22
30121: PUSH
30122: LD_INT 3
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 21
30131: PUSH
30132: LD_INT 1
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PPUSH
30143: CALL_OW 69
30147: PPUSH
30148: CALL_OW 122
// wait ( 0 0$1 ) ;
30152: LD_INT 35
30154: PPUSH
30155: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30159: LD_INT 22
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 21
30171: PUSH
30172: LD_INT 1
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PPUSH
30183: CALL_OW 69
30187: PPUSH
30188: LD_INT 25
30190: PPUSH
30191: CALL_OW 173
// wait ( 0 0$10 ) ;
30195: LD_INT 350
30197: PPUSH
30198: CALL_OW 67
// PrepareOmarInvasion ;
30202: CALL 13983 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30206: LD_ADDR_VAR 0 2
30210: PUSH
30211: LD_EXP 92
30215: PPUSH
30216: CALL_OW 250
30220: PUSH
30221: LD_EXP 92
30225: PPUSH
30226: CALL_OW 251
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30235: LD_VAR 0 2
30239: PUSH
30240: LD_INT 1
30242: ARRAY
30243: PPUSH
30244: LD_VAR 0 2
30248: PUSH
30249: LD_INT 2
30251: ARRAY
30252: PPUSH
30253: LD_INT 1
30255: PPUSH
30256: LD_INT 8
30258: NEG
30259: PPUSH
30260: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30264: LD_EXP 92
30268: PPUSH
30269: CALL_OW 87
// DialogueOn ;
30273: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30277: LD_EXP 39
30281: PPUSH
30282: LD_STRING D19-JMM-1
30284: PPUSH
30285: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30289: LD_ADDR_VAR 0 3
30293: PUSH
30294: LD_INT 22
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 26
30306: PUSH
30307: LD_INT 1
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: LD_INT 25
30319: PUSH
30320: LD_INT 1
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 25
30329: PUSH
30330: LD_INT 2
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 25
30339: PUSH
30340: LD_INT 3
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 25
30349: PUSH
30350: LD_INT 4
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 25
30359: PUSH
30360: LD_INT 5
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 25
30369: PUSH
30370: LD_INT 8
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: LIST
30390: PPUSH
30391: CALL_OW 69
30395: PUSH
30396: LD_EXP 39
30400: PUSH
30401: LD_EXP 40
30405: PUSH
30406: LD_EXP 41
30410: PUSH
30411: LD_EXP 42
30415: PUSH
30416: LD_EXP 43
30420: PUSH
30421: LD_EXP 44
30425: PUSH
30426: LD_EXP 45
30430: PUSH
30431: LD_EXP 46
30435: PUSH
30436: LD_EXP 47
30440: PUSH
30441: LD_EXP 48
30445: PUSH
30446: LD_EXP 49
30450: PUSH
30451: LD_EXP 50
30455: PUSH
30456: LD_EXP 51
30460: PUSH
30461: LD_EXP 52
30465: PUSH
30466: LD_EXP 53
30470: PUSH
30471: LD_EXP 54
30475: PUSH
30476: LD_EXP 55
30480: PUSH
30481: EMPTY
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: DIFF
30500: ST_TO_ADDR
// if tmp2 then
30501: LD_VAR 0 3
30505: IFFALSE 30523
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30507: LD_VAR 0 3
30511: PUSH
30512: LD_INT 1
30514: ARRAY
30515: PPUSH
30516: LD_STRING D19-Sol1-1
30518: PPUSH
30519: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30523: LD_EXP 39
30527: PPUSH
30528: LD_STRING D19-JMM-2
30530: PPUSH
30531: CALL_OW 88
// DialogueOff ;
30535: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30539: LD_VAR 0 2
30543: PUSH
30544: LD_INT 1
30546: ARRAY
30547: PPUSH
30548: LD_VAR 0 2
30552: PUSH
30553: LD_INT 2
30555: ARRAY
30556: PPUSH
30557: LD_INT 1
30559: PPUSH
30560: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30564: LD_STRING M5
30566: PPUSH
30567: CALL_OW 337
// omarOnMotherLode := false ;
30571: LD_ADDR_VAR 0 4
30575: PUSH
30576: LD_INT 0
30578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30579: LD_INT 35
30581: PPUSH
30582: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30586: LD_EXP 92
30590: PPUSH
30591: LD_INT 215
30593: PPUSH
30594: LD_INT 100
30596: PPUSH
30597: CALL_OW 297
30601: PUSH
30602: LD_INT 10
30604: LESS
30605: PUSH
30606: LD_VAR 0 4
30610: NOT
30611: AND
30612: IFFALSE 30646
// begin omarOnMotherLode := true ;
30614: LD_ADDR_VAR 0 4
30618: PUSH
30619: LD_INT 1
30621: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30622: LD_EXP 39
30626: PPUSH
30627: LD_STRING D19b-JMM-1
30629: PPUSH
30630: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30634: LD_EXP 92
30638: PPUSH
30639: LD_STRING DOmarContam-Omar-1
30641: PPUSH
30642: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30646: LD_EXP 92
30650: PPUSH
30651: CALL_OW 301
30655: IFFALSE 30579
// Say ( JMM , D19a-JMM-1 ) ;
30657: LD_EXP 39
30661: PPUSH
30662: LD_STRING D19a-JMM-1
30664: PPUSH
30665: CALL_OW 88
// if Heike then
30669: LD_EXP 93
30673: IFFALSE 30687
// Say ( Heike , D19a-Hke-1 ) ;
30675: LD_EXP 93
30679: PPUSH
30680: LD_STRING D19a-Hke-1
30682: PPUSH
30683: CALL_OW 88
// end ;
30687: PPOPN 4
30689: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30690: LD_INT 22
30692: PUSH
30693: LD_INT 3
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 21
30702: PUSH
30703: LD_INT 1
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PPUSH
30714: CALL_OW 69
30718: PUSH
30719: LD_EXP 21
30723: AND
30724: IFFALSE 30792
30726: GO 30728
30728: DISABLE
30729: LD_INT 0
30731: PPUSH
30732: PPUSH
// begin enable ;
30733: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30734: LD_ADDR_VAR 0 2
30738: PUSH
30739: LD_INT 25
30741: PPUSH
30742: LD_INT 22
30744: PUSH
30745: LD_INT 3
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PPUSH
30752: CALL_OW 70
30756: ST_TO_ADDR
// if not tmp then
30757: LD_VAR 0 2
30761: NOT
30762: IFFALSE 30766
// exit ;
30764: GO 30792
// for i in tmp do
30766: LD_ADDR_VAR 0 1
30770: PUSH
30771: LD_VAR 0 2
30775: PUSH
30776: FOR_IN
30777: IFFALSE 30790
// RemoveUnit ( i ) ;
30779: LD_VAR 0 1
30783: PPUSH
30784: CALL_OW 64
30788: GO 30776
30790: POP
30791: POP
// end ;
30792: PPOPN 2
30794: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30795: LD_INT 22
30797: PUSH
30798: LD_INT 7
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: LD_INT 21
30807: PUSH
30808: LD_INT 1
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PPUSH
30819: CALL_OW 69
30823: PUSH
30824: LD_INT 6
30826: LESS
30827: IFFALSE 31295
30829: GO 30831
30831: DISABLE
30832: LD_INT 0
30834: PPUSH
30835: PPUSH
// begin MC_Kill ( 1 ) ;
30836: LD_INT 1
30838: PPUSH
30839: CALL 35536 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30843: LD_INT 7
30845: PPUSH
30846: LD_INT 1
30848: PPUSH
30849: LD_INT 1
30851: PPUSH
30852: LD_INT 1
30854: PPUSH
30855: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30859: LD_ADDR_VAR 0 1
30863: PUSH
30864: LD_INT 22
30866: PUSH
30867: LD_INT 7
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: LD_INT 26
30876: PUSH
30877: LD_INT 1
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PPUSH
30888: CALL_OW 69
30892: PUSH
30893: LD_EXP 74
30897: DIFF
30898: ST_TO_ADDR
// if tmp then
30899: LD_VAR 0 1
30903: IFFALSE 30921
// tmp := tmp [ 1 ] else
30905: LD_ADDR_VAR 0 1
30909: PUSH
30910: LD_VAR 0 1
30914: PUSH
30915: LD_INT 1
30917: ARRAY
30918: ST_TO_ADDR
30919: GO 30957
// begin uc_side := 7 ;
30921: LD_ADDR_OWVAR 20
30925: PUSH
30926: LD_INT 7
30928: ST_TO_ADDR
// uc_nation := 1 ;
30929: LD_ADDR_OWVAR 21
30933: PUSH
30934: LD_INT 1
30936: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30937: LD_INT 1
30939: PPUSH
30940: LD_INT 8
30942: PPUSH
30943: CALL_OW 384
// tmp := CreateHuman ;
30947: LD_ADDR_VAR 0 1
30951: PUSH
30952: CALL_OW 44
30956: ST_TO_ADDR
// end ; DialogueOn ;
30957: CALL_OW 6
// if IsOK ( Roth ) then
30961: LD_EXP 74
30965: PPUSH
30966: CALL_OW 302
30970: IFFALSE 30984
// Say ( JMM , DAb-JMM-1 ) ;
30972: LD_EXP 39
30976: PPUSH
30977: LD_STRING DAb-JMM-1
30979: PPUSH
30980: CALL_OW 88
// if IsOK ( Roth ) then
30984: LD_EXP 74
30988: PPUSH
30989: CALL_OW 302
30993: IFFALSE 31017
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30995: LD_EXP 74
30999: PPUSH
31000: LD_STRING DSurrenderAlliance-Roth-1
31002: PPUSH
31003: CALL_OW 88
// RothCaptured := true ;
31007: LD_ADDR_EXP 33
31011: PUSH
31012: LD_INT 1
31014: ST_TO_ADDR
// end else
31015: GO 31029
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
31017: LD_VAR 0 1
31021: PPUSH
31022: LD_STRING DSurrenderAlliance-Sci1-1
31024: PPUSH
31025: CALL_OW 88
// DialogueOff ;
31029: CALL_OW 7
// allianceDestroyed := true ;
31033: LD_ADDR_EXP 23
31037: PUSH
31038: LD_INT 1
31040: ST_TO_ADDR
// if capturedUnit = 0 then
31041: LD_EXP 34
31045: PUSH
31046: LD_INT 0
31048: EQUAL
31049: IFFALSE 31058
// SetAchievement ( ACH_ALLIANCE ) ;
31051: LD_STRING ACH_ALLIANCE
31053: PPUSH
31054: CALL_OW 543
// if trueAmericans then
31058: LD_EXP 35
31062: IFFALSE 31138
// begin if trueAmericans = 1 then
31064: LD_EXP 35
31068: PUSH
31069: LD_INT 1
31071: EQUAL
31072: IFFALSE 31088
// Say ( JMM , DAb-JMM-1a ) else
31074: LD_EXP 39
31078: PPUSH
31079: LD_STRING DAb-JMM-1a
31081: PPUSH
31082: CALL_OW 88
31086: GO 31100
// Say ( JMM , DAb-JMM-1b ) ;
31088: LD_EXP 39
31092: PPUSH
31093: LD_STRING DAb-JMM-1b
31095: PPUSH
31096: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31100: LD_EXP 35
31104: PPUSH
31105: CALL_OW 87
// for i in trueAmericans do
31109: LD_ADDR_VAR 0 2
31113: PUSH
31114: LD_EXP 35
31118: PUSH
31119: FOR_IN
31120: IFFALSE 31136
// SetSide ( i , 1 ) ;
31122: LD_VAR 0 2
31126: PPUSH
31127: LD_INT 1
31129: PPUSH
31130: CALL_OW 235
31134: GO 31119
31136: POP
31137: POP
// end ; repeat wait ( 0 0$1 ) ;
31138: LD_INT 35
31140: PPUSH
31141: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31145: LD_ADDR_VAR 0 2
31149: PUSH
31150: LD_INT 22
31152: PUSH
31153: LD_INT 7
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 21
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PPUSH
31174: CALL_OW 69
31178: PUSH
31179: FOR_IN
31180: IFFALSE 31262
// begin if IsInUnit ( i ) then
31182: LD_VAR 0 2
31186: PPUSH
31187: CALL_OW 310
31191: IFFALSE 31202
// ComExitBuilding ( i ) ;
31193: LD_VAR 0 2
31197: PPUSH
31198: CALL_OW 122
// if IsDriver ( i ) then
31202: LD_VAR 0 2
31206: PPUSH
31207: CALL 100930 0 1
31211: IFFALSE 31222
// ComExitVehicle ( i ) ;
31213: LD_VAR 0 2
31217: PPUSH
31218: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31222: LD_VAR 0 2
31226: PPUSH
31227: LD_INT 26
31229: PPUSH
31230: CALL_OW 308
31234: NOT
31235: IFFALSE 31251
// AddComMoveToArea ( i , allianceEscapeArea ) else
31237: LD_VAR 0 2
31241: PPUSH
31242: LD_INT 26
31244: PPUSH
31245: CALL_OW 173
31249: GO 31260
// RemoveUnit ( i ) ;
31251: LD_VAR 0 2
31255: PPUSH
31256: CALL_OW 64
// end ;
31260: GO 31179
31262: POP
31263: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31264: LD_INT 22
31266: PUSH
31267: LD_INT 7
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 21
31276: PUSH
31277: LD_INT 1
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: EMPTY
31285: LIST
31286: LIST
31287: PPUSH
31288: CALL_OW 69
31292: NOT
31293: IFFALSE 31138
// end ;
31295: PPOPN 2
31297: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31298: LD_INT 0
31300: PPUSH
31301: PPUSH
// if not unit then
31302: LD_VAR 0 1
31306: NOT
31307: IFFALSE 31311
// exit ;
31309: GO 32809
// DoNotAttack ( 7 , unit ) ;
31311: LD_INT 7
31313: PPUSH
31314: LD_VAR 0 1
31318: PPUSH
31319: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31323: LD_VAR 0 1
31327: PPUSH
31328: LD_INT 260
31330: PPUSH
31331: LD_INT 235
31333: PPUSH
31334: LD_INT 3
31336: PPUSH
31337: LD_INT 1
31339: PPUSH
31340: CALL_OW 483
// SetSide ( unit , 4 ) ;
31344: LD_VAR 0 1
31348: PPUSH
31349: LD_INT 4
31351: PPUSH
31352: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31356: LD_ADDR_EXP 34
31360: PUSH
31361: LD_EXP 34
31365: PUSH
31366: LD_INT 1
31368: PLUS
31369: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31370: LD_INT 70
31372: PPUSH
31373: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31377: LD_INT 260
31379: PPUSH
31380: LD_INT 235
31382: PPUSH
31383: LD_INT 1
31385: PPUSH
31386: LD_INT 8
31388: NEG
31389: PPUSH
31390: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31394: LD_VAR 0 1
31398: PPUSH
31399: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31403: LD_VAR 0 1
31407: PPUSH
31408: LD_EXP 74
31412: PPUSH
31413: CALL_OW 119
// DialogueOn ;
31417: CALL_OW 6
// case unit of JMM :
31421: LD_VAR 0 1
31425: PUSH
31426: LD_EXP 39
31430: DOUBLE
31431: EQUAL
31432: IFTRUE 31436
31434: GO 31451
31436: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31437: LD_EXP 39
31441: PPUSH
31442: LD_STRING DA1-JMM-1
31444: PPUSH
31445: CALL_OW 91
31449: GO 31893
31451: LD_EXP 40
31455: DOUBLE
31456: EQUAL
31457: IFTRUE 31461
31459: GO 31476
31461: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31462: LD_EXP 40
31466: PPUSH
31467: LD_STRING DA1-Joan-1
31469: PPUSH
31470: CALL_OW 91
31474: GO 31893
31476: LD_EXP 42
31480: DOUBLE
31481: EQUAL
31482: IFTRUE 31486
31484: GO 31501
31486: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31487: LD_EXP 42
31491: PPUSH
31492: LD_STRING DA1-Lisa-1
31494: PPUSH
31495: CALL_OW 91
31499: GO 31893
31501: LD_EXP 43
31505: DOUBLE
31506: EQUAL
31507: IFTRUE 31511
31509: GO 31526
31511: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31512: LD_EXP 43
31516: PPUSH
31517: LD_STRING DA1-Don-1
31519: PPUSH
31520: CALL_OW 91
31524: GO 31893
31526: LD_EXP 50
31530: DOUBLE
31531: EQUAL
31532: IFTRUE 31536
31534: GO 31551
31536: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31537: LD_EXP 50
31541: PPUSH
31542: LD_STRING DA1-Corn-1
31544: PPUSH
31545: CALL_OW 91
31549: GO 31893
31551: LD_EXP 46
31555: DOUBLE
31556: EQUAL
31557: IFTRUE 31561
31559: GO 31576
31561: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31562: LD_EXP 46
31566: PPUSH
31567: LD_STRING DA1-Den-1
31569: PPUSH
31570: CALL_OW 91
31574: GO 31893
31576: LD_EXP 44
31580: DOUBLE
31581: EQUAL
31582: IFTRUE 31586
31584: GO 31601
31586: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31587: LD_EXP 44
31591: PPUSH
31592: LD_STRING DA1-Bobby-1
31594: PPUSH
31595: CALL_OW 91
31599: GO 31893
31601: LD_EXP 48
31605: DOUBLE
31606: EQUAL
31607: IFTRUE 31611
31609: GO 31626
31611: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31612: LD_EXP 48
31616: PPUSH
31617: LD_STRING DA1-Glad-1
31619: PPUSH
31620: CALL_OW 91
31624: GO 31893
31626: LD_EXP 45
31630: DOUBLE
31631: EQUAL
31632: IFTRUE 31636
31634: GO 31651
31636: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31637: LD_EXP 45
31641: PPUSH
31642: LD_STRING DA1-Cyrus-1
31644: PPUSH
31645: CALL_OW 91
31649: GO 31893
31651: LD_EXP 41
31655: DOUBLE
31656: EQUAL
31657: IFTRUE 31661
31659: GO 31676
31661: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31662: LD_EXP 41
31666: PPUSH
31667: LD_STRING DA1-Huck-1
31669: PPUSH
31670: CALL_OW 91
31674: GO 31893
31676: LD_EXP 55
31680: DOUBLE
31681: EQUAL
31682: IFTRUE 31686
31684: GO 31701
31686: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31687: LD_EXP 55
31691: PPUSH
31692: LD_STRING DA1-Huck-1
31694: PPUSH
31695: CALL_OW 91
31699: GO 31893
31701: LD_EXP 47
31705: DOUBLE
31706: EQUAL
31707: IFTRUE 31711
31709: GO 31726
31711: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31712: LD_EXP 47
31716: PPUSH
31717: LD_STRING DA1-Brown-1
31719: PPUSH
31720: CALL_OW 91
31724: GO 31893
31726: LD_EXP 51
31730: DOUBLE
31731: EQUAL
31732: IFTRUE 31736
31734: GO 31751
31736: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31737: LD_EXP 51
31741: PPUSH
31742: LD_STRING DA1-Gary-1
31744: PPUSH
31745: CALL_OW 91
31749: GO 31893
31751: LD_EXP 54
31755: DOUBLE
31756: EQUAL
31757: IFTRUE 31761
31759: GO 31776
31761: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31762: LD_EXP 54
31766: PPUSH
31767: LD_STRING DA1-Con-1
31769: PPUSH
31770: CALL_OW 91
31774: GO 31893
31776: LD_EXP 60
31780: DOUBLE
31781: EQUAL
31782: IFTRUE 31786
31784: GO 31801
31786: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31787: LD_EXP 60
31791: PPUSH
31792: LD_STRING DA1-Kurt-1
31794: PPUSH
31795: CALL_OW 91
31799: GO 31893
31801: LD_EXP 53
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31812: LD_EXP 53
31816: PPUSH
31817: LD_STRING DA1-Yam-1
31819: PPUSH
31820: CALL_OW 91
31824: GO 31893
31826: LD_EXP 52
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31837: LD_EXP 52
31841: PPUSH
31842: LD_STRING DA1-Frank-1
31844: PPUSH
31845: CALL_OW 91
31849: GO 31893
31851: POP
// begin if GetSex ( unit ) = sex_male then
31852: LD_VAR 0 1
31856: PPUSH
31857: CALL_OW 258
31861: PUSH
31862: LD_INT 1
31864: EQUAL
31865: IFFALSE 31881
// ForceSay ( unit , DA1-Sol1-1 ) else
31867: LD_VAR 0 1
31871: PPUSH
31872: LD_STRING DA1-Sol1-1
31874: PPUSH
31875: CALL_OW 91
31879: GO 31893
// ForceSay ( unit , DA1-FSol1-1 ) ;
31881: LD_VAR 0 1
31885: PPUSH
31886: LD_STRING DA1-FSol1-1
31888: PPUSH
31889: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31893: LD_EXP 74
31897: PPUSH
31898: LD_STRING DA-Roth-1
31900: PPUSH
31901: CALL_OW 88
// if capturedUnit = 1 then
31905: LD_EXP 34
31909: PUSH
31910: LD_INT 1
31912: EQUAL
31913: IFFALSE 31941
// begin Say ( Simms , DA-Sim-1 ) ;
31915: LD_EXP 75
31919: PPUSH
31920: LD_STRING DA-Sim-1
31922: PPUSH
31923: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31927: LD_EXP 74
31931: PPUSH
31932: LD_STRING DA-Roth-2
31934: PPUSH
31935: CALL_OW 88
// end else
31939: GO 31953
// Say ( Simms , DA-Sim-2 ) ;
31941: LD_EXP 75
31945: PPUSH
31946: LD_STRING DA-Sim-2
31948: PPUSH
31949: CALL_OW 88
// case unit of JMM :
31953: LD_VAR 0 1
31957: PUSH
31958: LD_EXP 39
31962: DOUBLE
31963: EQUAL
31964: IFTRUE 31968
31966: GO 31983
31968: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31969: LD_EXP 39
31973: PPUSH
31974: LD_STRING DA1-JMM-1a
31976: PPUSH
31977: CALL_OW 91
31981: GO 32490
31983: LD_EXP 40
31987: DOUBLE
31988: EQUAL
31989: IFTRUE 31993
31991: GO 32008
31993: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31994: LD_EXP 40
31998: PPUSH
31999: LD_STRING DA1-Joan-1a
32001: PPUSH
32002: CALL_OW 91
32006: GO 32490
32008: LD_EXP 42
32012: DOUBLE
32013: EQUAL
32014: IFTRUE 32018
32016: GO 32033
32018: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
32019: LD_EXP 42
32023: PPUSH
32024: LD_STRING DA1-Lisa-1a
32026: PPUSH
32027: CALL_OW 91
32031: GO 32490
32033: LD_EXP 43
32037: DOUBLE
32038: EQUAL
32039: IFTRUE 32043
32041: GO 32058
32043: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32044: LD_EXP 43
32048: PPUSH
32049: LD_STRING DA1-Don-1a
32051: PPUSH
32052: CALL_OW 91
32056: GO 32490
32058: LD_EXP 50
32062: DOUBLE
32063: EQUAL
32064: IFTRUE 32068
32066: GO 32083
32068: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32069: LD_EXP 50
32073: PPUSH
32074: LD_STRING DA1-Corn-1a
32076: PPUSH
32077: CALL_OW 91
32081: GO 32490
32083: LD_EXP 46
32087: DOUBLE
32088: EQUAL
32089: IFTRUE 32093
32091: GO 32108
32093: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32094: LD_EXP 46
32098: PPUSH
32099: LD_STRING DA1-Den-1a
32101: PPUSH
32102: CALL_OW 91
32106: GO 32490
32108: LD_EXP 44
32112: DOUBLE
32113: EQUAL
32114: IFTRUE 32118
32116: GO 32133
32118: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32119: LD_EXP 44
32123: PPUSH
32124: LD_STRING DA1-Bobby-1a
32126: PPUSH
32127: CALL_OW 91
32131: GO 32490
32133: LD_EXP 48
32137: DOUBLE
32138: EQUAL
32139: IFTRUE 32143
32141: GO 32158
32143: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32144: LD_EXP 48
32148: PPUSH
32149: LD_STRING DA1-Glad-1a
32151: PPUSH
32152: CALL_OW 91
32156: GO 32490
32158: LD_EXP 45
32162: DOUBLE
32163: EQUAL
32164: IFTRUE 32168
32166: GO 32183
32168: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32169: LD_EXP 45
32173: PPUSH
32174: LD_STRING DA1-Cyrus-1a
32176: PPUSH
32177: CALL_OW 91
32181: GO 32490
32183: LD_EXP 41
32187: DOUBLE
32188: EQUAL
32189: IFTRUE 32193
32191: GO 32208
32193: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32194: LD_EXP 41
32198: PPUSH
32199: LD_STRING DA1-Huck-1a
32201: PPUSH
32202: CALL_OW 91
32206: GO 32490
32208: LD_EXP 55
32212: DOUBLE
32213: EQUAL
32214: IFTRUE 32218
32216: GO 32233
32218: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32219: LD_EXP 55
32223: PPUSH
32224: LD_STRING DA1-Huck-1a
32226: PPUSH
32227: CALL_OW 91
32231: GO 32490
32233: LD_EXP 47
32237: DOUBLE
32238: EQUAL
32239: IFTRUE 32243
32241: GO 32258
32243: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32244: LD_EXP 47
32248: PPUSH
32249: LD_STRING DA1-Brown-1a
32251: PPUSH
32252: CALL_OW 91
32256: GO 32490
32258: LD_EXP 51
32262: DOUBLE
32263: EQUAL
32264: IFTRUE 32268
32266: GO 32283
32268: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32269: LD_EXP 51
32273: PPUSH
32274: LD_STRING DA1-Gary-1a
32276: PPUSH
32277: CALL_OW 91
32281: GO 32490
32283: LD_EXP 54
32287: DOUBLE
32288: EQUAL
32289: IFTRUE 32293
32291: GO 32308
32293: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32294: LD_EXP 54
32298: PPUSH
32299: LD_STRING DA1-Con-1a
32301: PPUSH
32302: CALL_OW 91
32306: GO 32490
32308: LD_EXP 60
32312: DOUBLE
32313: EQUAL
32314: IFTRUE 32318
32316: GO 32333
32318: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32319: LD_EXP 60
32323: PPUSH
32324: LD_STRING DA1-Kurt-1a
32326: PPUSH
32327: CALL_OW 91
32331: GO 32490
32333: LD_EXP 53
32337: DOUBLE
32338: EQUAL
32339: IFTRUE 32343
32341: GO 32358
32343: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32344: LD_EXP 53
32348: PPUSH
32349: LD_STRING DA1-Yam-1a
32351: PPUSH
32352: CALL_OW 91
32356: GO 32490
32358: LD_EXP 52
32362: DOUBLE
32363: EQUAL
32364: IFTRUE 32368
32366: GO 32383
32368: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32369: LD_EXP 52
32373: PPUSH
32374: LD_STRING DA1-Frank-1a
32376: PPUSH
32377: CALL_OW 91
32381: GO 32490
32383: POP
// begin join := rand ( 0 , 1 ) ;
32384: LD_ADDR_VAR 0 3
32388: PUSH
32389: LD_INT 0
32391: PPUSH
32392: LD_INT 1
32394: PPUSH
32395: CALL_OW 12
32399: ST_TO_ADDR
// if join then
32400: LD_VAR 0 3
32404: IFFALSE 32449
// begin if GetSex ( unit ) = sex_male then
32406: LD_VAR 0 1
32410: PPUSH
32411: CALL_OW 258
32415: PUSH
32416: LD_INT 1
32418: EQUAL
32419: IFFALSE 32435
// ForceSay ( unit , DA1-Sol1-1b ) else
32421: LD_VAR 0 1
32425: PPUSH
32426: LD_STRING DA1-Sol1-1b
32428: PPUSH
32429: CALL_OW 91
32433: GO 32447
// ForceSay ( unit , DA1-FSol1-1b ) ;
32435: LD_VAR 0 1
32439: PPUSH
32440: LD_STRING DA1-FSol1-1b
32442: PPUSH
32443: CALL_OW 91
// end else
32447: GO 32490
// begin if GetSex ( unit ) = sex_male then
32449: LD_VAR 0 1
32453: PPUSH
32454: CALL_OW 258
32458: PUSH
32459: LD_INT 1
32461: EQUAL
32462: IFFALSE 32478
// ForceSay ( unit , DA1-Sol1-1a ) else
32464: LD_VAR 0 1
32468: PPUSH
32469: LD_STRING DA1-Sol1-1a
32471: PPUSH
32472: CALL_OW 91
32476: GO 32490
// ForceSay ( unit , DA1-FSol1-1a ) ;
32478: LD_VAR 0 1
32482: PPUSH
32483: LD_STRING DA1-FSol1-1a
32485: PPUSH
32486: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32490: LD_VAR 0 1
32494: PUSH
32495: LD_EXP 39
32499: EQUAL
32500: IFFALSE 32511
// begin YouLost ( JMMCaptured ) ;
32502: LD_STRING JMMCaptured
32504: PPUSH
32505: CALL_OW 104
// exit ;
32509: GO 32809
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32511: LD_VAR 0 1
32515: PUSH
32516: LD_EXP 43
32520: PUSH
32521: LD_EXP 46
32525: PUSH
32526: LD_EXP 44
32530: PUSH
32531: LD_EXP 41
32535: PUSH
32536: LD_EXP 55
32540: PUSH
32541: LD_EXP 47
32545: PUSH
32546: LD_EXP 53
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: IN
32560: PUSH
32561: LD_VAR 0 3
32565: OR
32566: IFFALSE 32665
// begin Say ( Roth , DA-Roth-3 ) ;
32568: LD_EXP 74
32572: PPUSH
32573: LD_STRING DA-Roth-3
32575: PPUSH
32576: CALL_OW 88
// SetSide ( unit , 7 ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: LD_INT 7
32587: PPUSH
32588: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32592: LD_ADDR_EXP 115
32596: PUSH
32597: LD_EXP 115
32601: PPUSH
32602: LD_INT 1
32604: PPUSH
32605: LD_EXP 115
32609: PUSH
32610: LD_INT 1
32612: ARRAY
32613: PUSH
32614: LD_VAR 0 1
32618: ADD
32619: PPUSH
32620: CALL_OW 1
32624: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32625: LD_INT 260
32627: PPUSH
32628: LD_INT 235
32630: PPUSH
32631: LD_INT 1
32633: PPUSH
32634: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32638: LD_VAR 0 1
32642: PPUSH
32643: LD_INT 1000
32645: PPUSH
32646: CALL_OW 234
// DialogueOff ;
32650: CALL_OW 7
// ComFree ( unit ) ;
32654: LD_VAR 0 1
32658: PPUSH
32659: CALL_OW 139
// end else
32663: GO 32746
// begin Say ( Roth , DA-Roth-3a ) ;
32665: LD_EXP 74
32669: PPUSH
32670: LD_STRING DA-Roth-3a
32672: PPUSH
32673: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32677: LD_ADDR_EXP 35
32681: PUSH
32682: LD_EXP 35
32686: PUSH
32687: LD_VAR 0 1
32691: ADD
32692: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32693: LD_INT 260
32695: PPUSH
32696: LD_INT 235
32698: PPUSH
32699: LD_INT 1
32701: PPUSH
32702: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32706: LD_VAR 0 1
32710: PPUSH
32711: LD_INT 1000
32713: PPUSH
32714: CALL_OW 234
// DialogueOff ;
32718: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32722: LD_VAR 0 1
32726: PPUSH
32727: LD_INT 272
32729: PPUSH
32730: LD_INT 254
32732: PPUSH
32733: CALL_OW 111
// AddComHold ( unit ) ;
32737: LD_VAR 0 1
32741: PPUSH
32742: CALL_OW 200
// end ; if capturedUnit = 1 then
32746: LD_EXP 34
32750: PUSH
32751: LD_INT 1
32753: EQUAL
32754: IFFALSE 32809
// begin DialogueOn ;
32756: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32760: LD_EXP 39
32764: PPUSH
32765: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32769: LD_EXP 39
32773: PPUSH
32774: LD_STRING DAa-JMM-1
32776: PPUSH
32777: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32781: LD_EXP 39
32785: PPUSH
32786: LD_STRING DAa-JMM-1a
32788: PPUSH
32789: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32793: LD_EXP 39
32797: PPUSH
32798: LD_STRING DAa-JMM-1b
32800: PPUSH
32801: CALL_OW 88
// DialogueOff ;
32805: CALL_OW 7
// end ; end ;
32809: LD_VAR 0 2
32813: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32814: LD_EXP 15
32818: PUSH
32819: LD_INT 13
32821: GREATEREQUAL
32822: PUSH
32823: LD_INT 22
32825: PUSH
32826: LD_INT 2
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 21
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PPUSH
32847: CALL_OW 69
32851: PUSH
32852: LD_INT 0
32854: EQUAL
32855: AND
32856: PUSH
32857: LD_INT 22
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 33
32869: PUSH
32870: LD_INT 5
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 21
32879: PUSH
32880: LD_INT 2
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 50
32889: PUSH
32890: EMPTY
32891: LIST
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: PPUSH
32899: CALL_OW 69
32903: PUSH
32904: LD_INT 0
32906: EQUAL
32907: AND
32908: PUSH
32909: LD_EXP 21
32913: AND
32914: PUSH
32915: LD_EXP 22
32919: AND
32920: PUSH
32921: LD_EXP 23
32925: AND
32926: IFFALSE 33575
32928: GO 32930
32930: DISABLE
32931: LD_INT 0
32933: PPUSH
32934: PPUSH
32935: PPUSH
// begin m1 := false ;
32936: LD_ADDR_VAR 0 1
32940: PUSH
32941: LD_INT 0
32943: ST_TO_ADDR
// m2 := false ;
32944: LD_ADDR_VAR 0 2
32948: PUSH
32949: LD_INT 0
32951: ST_TO_ADDR
// m3 := false ;
32952: LD_ADDR_VAR 0 3
32956: PUSH
32957: LD_INT 0
32959: ST_TO_ADDR
// if not bombExploded then
32960: LD_EXP 37
32964: NOT
32965: IFFALSE 32974
// SetAchievement ( ACH_SIBROCKET ) ;
32967: LD_STRING ACH_SIBROCKET
32969: PPUSH
32970: CALL_OW 543
// if tick <= 120 120$00 then
32974: LD_OWVAR 1
32978: PUSH
32979: LD_INT 252000
32981: LESSEQUAL
32982: IFFALSE 32998
// begin wait ( 3 ) ;
32984: LD_INT 3
32986: PPUSH
32987: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32991: LD_STRING ACH_ASPEED_15
32993: PPUSH
32994: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32998: LD_EXP 39
33002: PPUSH
33003: CALL_OW 87
// music_class := 5 ;
33007: LD_ADDR_OWVAR 72
33011: PUSH
33012: LD_INT 5
33014: ST_TO_ADDR
// music_nat := 5 ;
33015: LD_ADDR_OWVAR 71
33019: PUSH
33020: LD_INT 5
33022: ST_TO_ADDR
// DialogueOn ;
33023: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33027: LD_EXP 39
33031: PPUSH
33032: LD_STRING D20-JMM-1
33034: PPUSH
33035: CALL_OW 88
// if IsOK ( Joan ) then
33039: LD_EXP 40
33043: PPUSH
33044: CALL_OW 302
33048: IFFALSE 33062
// Say ( Joan , D20-Joan-1 ) ;
33050: LD_EXP 40
33054: PPUSH
33055: LD_STRING D20-Joan-1
33057: PPUSH
33058: CALL_OW 88
// if IsOk ( Lisa ) then
33062: LD_EXP 42
33066: PPUSH
33067: CALL_OW 302
33071: IFFALSE 33085
// Say ( Lisa , D20-Lisa-1 ) ;
33073: LD_EXP 42
33077: PPUSH
33078: LD_STRING D20-Lisa-1
33080: PPUSH
33081: CALL_OW 88
// if IsOk ( Donaldson ) then
33085: LD_EXP 43
33089: PPUSH
33090: CALL_OW 302
33094: IFFALSE 33108
// Say ( Donaldson , D20-Don-1 ) ;
33096: LD_EXP 43
33100: PPUSH
33101: LD_STRING D20-Don-1
33103: PPUSH
33104: CALL_OW 88
// if IsOK ( Cornel ) then
33108: LD_EXP 50
33112: PPUSH
33113: CALL_OW 302
33117: IFFALSE 33131
// Say ( Cornel , D20-Corn-1 ) ;
33119: LD_EXP 50
33123: PPUSH
33124: LD_STRING D20-Corn-1
33126: PPUSH
33127: CALL_OW 88
// if IsOk ( Denis ) then
33131: LD_EXP 46
33135: PPUSH
33136: CALL_OW 302
33140: IFFALSE 33154
// Say ( Denis , D20-Den-1 ) ;
33142: LD_EXP 46
33146: PPUSH
33147: LD_STRING D20-Den-1
33149: PPUSH
33150: CALL_OW 88
// if IsOk ( Bobby ) then
33154: LD_EXP 44
33158: PPUSH
33159: CALL_OW 302
33163: IFFALSE 33177
// Say ( Bobby , D20-Bobby-1 ) ;
33165: LD_EXP 44
33169: PPUSH
33170: LD_STRING D20-Bobby-1
33172: PPUSH
33173: CALL_OW 88
// if IsOk ( Gladstone ) then
33177: LD_EXP 48
33181: PPUSH
33182: CALL_OW 302
33186: IFFALSE 33200
// Say ( Gladstone , D20-Glad-1 ) ;
33188: LD_EXP 48
33192: PPUSH
33193: LD_STRING D20-Glad-1
33195: PPUSH
33196: CALL_OW 88
// if IsOk ( Cyrus ) then
33200: LD_EXP 45
33204: PPUSH
33205: CALL_OW 302
33209: IFFALSE 33223
// Say ( Cyrus , D20-Cyrus-1 ) ;
33211: LD_EXP 45
33215: PPUSH
33216: LD_STRING D20-Cyrus-1
33218: PPUSH
33219: CALL_OW 88
// if IsOk ( Stevens ) then
33223: LD_EXP 41
33227: PPUSH
33228: CALL_OW 302
33232: IFFALSE 33246
// Say ( Stevens , D20-Huck-1 ) ;
33234: LD_EXP 41
33238: PPUSH
33239: LD_STRING D20-Huck-1
33241: PPUSH
33242: CALL_OW 88
// if IsOk ( Brown ) then
33246: LD_EXP 47
33250: PPUSH
33251: CALL_OW 302
33255: IFFALSE 33269
// Say ( Brown , D20-Brown-1 ) ;
33257: LD_EXP 47
33261: PPUSH
33262: LD_STRING D20-Brown-1
33264: PPUSH
33265: CALL_OW 88
// if IsOk ( Gary ) then
33269: LD_EXP 51
33273: PPUSH
33274: CALL_OW 302
33278: IFFALSE 33292
// Say ( Gary , D20-Gary-1 ) ;
33280: LD_EXP 51
33284: PPUSH
33285: LD_STRING D20-Gary-1
33287: PPUSH
33288: CALL_OW 88
// if IsOk ( Connie ) then
33292: LD_EXP 54
33296: PPUSH
33297: CALL_OW 302
33301: IFFALSE 33315
// Say ( Connie , D20-Con-1 ) ;
33303: LD_EXP 54
33307: PPUSH
33308: LD_STRING D20-Con-1
33310: PPUSH
33311: CALL_OW 88
// if IsOk ( Kurt ) then
33315: LD_EXP 60
33319: PPUSH
33320: CALL_OW 302
33324: IFFALSE 33338
// Say ( Kurt , D20-Kurt-1 ) ;
33326: LD_EXP 60
33330: PPUSH
33331: LD_STRING D20-Kurt-1
33333: PPUSH
33334: CALL_OW 88
// if IsOk ( Kikuchi ) then
33338: LD_EXP 53
33342: PPUSH
33343: CALL_OW 302
33347: IFFALSE 33361
// Say ( Kikuchi , D20-Yam-1 ) ;
33349: LD_EXP 53
33353: PPUSH
33354: LD_STRING D20-Yam-1
33356: PPUSH
33357: CALL_OW 88
// if IsOk ( Frank ) then
33361: LD_EXP 52
33365: PPUSH
33366: CALL_OW 302
33370: IFFALSE 33384
// Say ( Frank , D20-Frank-1 ) ;
33372: LD_EXP 52
33376: PPUSH
33377: LD_STRING D20-Frank-1
33379: PPUSH
33380: CALL_OW 88
// DialogueOff ;
33384: CALL_OW 7
// if RothCaptured then
33388: LD_EXP 33
33392: IFFALSE 33414
// begin m1 := true ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_INT 1
33401: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33402: LD_STRING Roth
33404: PPUSH
33405: LD_INT 1
33407: PPUSH
33408: CALL_OW 101
// end else
33412: GO 33425
// AddMedal ( Roth , - 1 ) ;
33414: LD_STRING Roth
33416: PPUSH
33417: LD_INT 1
33419: NEG
33420: PPUSH
33421: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33425: LD_EXP 25
33429: NOT
33430: PUSH
33431: LD_EXP 27
33435: OR
33436: IFFALSE 33458
// begin m2 := true ;
33438: LD_ADDR_VAR 0 2
33442: PUSH
33443: LD_INT 1
33445: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33446: LD_STRING Project
33448: PPUSH
33449: LD_INT 1
33451: PPUSH
33452: CALL_OW 101
// end else
33456: GO 33469
// AddMedal ( Project , - 1 ) ;
33458: LD_STRING Project
33460: PPUSH
33461: LD_INT 1
33463: NEG
33464: PPUSH
33465: CALL_OW 101
// if lostCounter = 0 then
33469: LD_EXP 32
33473: PUSH
33474: LD_INT 0
33476: EQUAL
33477: IFFALSE 33499
// begin m3 := true ;
33479: LD_ADDR_VAR 0 3
33483: PUSH
33484: LD_INT 1
33486: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33487: LD_STRING NoLosses
33489: PPUSH
33490: LD_INT 1
33492: PPUSH
33493: CALL_OW 101
// end else
33497: GO 33510
// AddMedal ( NoLosses , - 1 ) ;
33499: LD_STRING NoLosses
33501: PPUSH
33502: LD_INT 1
33504: NEG
33505: PPUSH
33506: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33510: LD_VAR 0 1
33514: PUSH
33515: LD_VAR 0 2
33519: AND
33520: PUSH
33521: LD_VAR 0 3
33525: AND
33526: PUSH
33527: LD_OWVAR 67
33531: PUSH
33532: LD_INT 3
33534: GREATEREQUAL
33535: AND
33536: IFFALSE 33548
// SetAchievementEX ( ACH_AMER , 15 ) ;
33538: LD_STRING ACH_AMER
33540: PPUSH
33541: LD_INT 15
33543: PPUSH
33544: CALL_OW 564
// GiveMedals ( MAIN ) ;
33548: LD_STRING MAIN
33550: PPUSH
33551: CALL_OW 102
// music_class := 4 ;
33555: LD_ADDR_OWVAR 72
33559: PUSH
33560: LD_INT 4
33562: ST_TO_ADDR
// music_nat := 1 ;
33563: LD_ADDR_OWVAR 71
33567: PUSH
33568: LD_INT 1
33570: ST_TO_ADDR
// YouWin ;
33571: CALL_OW 103
// end ; end_of_file
33575: PPOPN 3
33577: END
// export function CustomEvent ( event ) ; begin
33578: LD_INT 0
33580: PPUSH
// end ;
33581: LD_VAR 0 2
33585: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33586: LD_VAR 0 1
33590: PUSH
33591: LD_INT 1
33593: EQUAL
33594: PUSH
33595: LD_VAR 0 2
33599: PUSH
33600: LD_INT 4
33602: EQUAL
33603: AND
33604: PUSH
33605: LD_EXP 58
33609: PPUSH
33610: CALL_OW 300
33614: AND
33615: IFFALSE 33631
// begin wait ( 0 0$2 ) ;
33617: LD_INT 70
33619: PPUSH
33620: CALL_OW 67
// YouLost ( Dismissed ) ;
33624: LD_STRING Dismissed
33626: PPUSH
33627: CALL_OW 104
// end ; end ;
33631: PPOPN 2
33633: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33634: LD_VAR 0 2
33638: PPUSH
33639: LD_VAR 0 3
33643: PPUSH
33644: LD_INT 18
33646: PPUSH
33647: CALL_OW 309
33651: IFFALSE 33660
// YouLost ( Motherlode3 ) ;
33653: LD_STRING Motherlode3
33655: PPUSH
33656: CALL_OW 104
// end ;
33660: PPOPN 3
33662: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33663: LD_EXP 27
33667: NOT
33668: IFFALSE 33678
// behemothDone := true ;
33670: LD_ADDR_EXP 28
33674: PUSH
33675: LD_INT 1
33677: ST_TO_ADDR
// end ;
33678: PPOPN 1
33680: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33681: LD_VAR 0 1
33685: PPUSH
33686: CALL_OW 255
33690: PUSH
33691: LD_INT 1
33693: EQUAL
33694: IFFALSE 33704
// bombExploded := true ;
33696: LD_ADDR_EXP 37
33700: PUSH
33701: LD_INT 1
33703: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33704: LD_VAR 0 1
33708: PPUSH
33709: CALL_OW 255
33713: PUSH
33714: LD_INT 1
33716: EQUAL
33717: PUSH
33718: LD_EXP 30
33722: AND
33723: PUSH
33724: LD_INT 22
33726: PUSH
33727: LD_INT 3
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 34
33736: PUSH
33737: LD_INT 48
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PPUSH
33748: CALL_OW 69
33752: AND
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 34
33766: PUSH
33767: LD_INT 8
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PPUSH
33778: CALL_OW 69
33782: NOT
33783: AND
33784: IFFALSE 33836
// begin wait ( 0 0$5 ) ;
33786: LD_INT 175
33788: PPUSH
33789: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33793: LD_INT 22
33795: PUSH
33796: LD_INT 3
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 34
33805: PUSH
33806: LD_INT 48
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PPUSH
33817: CALL_OW 69
33821: PUSH
33822: LD_INT 1
33824: ARRAY
33825: PPUSH
33826: LD_INT 60
33828: PPUSH
33829: LD_INT 95
33831: PPUSH
33832: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33836: LD_VAR 0 2
33840: PPUSH
33841: LD_VAR 0 3
33845: PPUSH
33846: LD_INT 18
33848: PPUSH
33849: CALL_OW 309
33853: IFFALSE 33900
// begin if GetSide ( unit ) = 1 then
33855: LD_VAR 0 1
33859: PPUSH
33860: CALL_OW 255
33864: PUSH
33865: LD_INT 1
33867: EQUAL
33868: IFFALSE 33886
// begin wait ( 0 0$6 ) ;
33870: LD_INT 210
33872: PPUSH
33873: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33877: LD_STRING Motherlode2
33879: PPUSH
33880: CALL_OW 104
// end else
33884: GO 33900
// begin wait ( 0 0$6 ) ;
33886: LD_INT 210
33888: PPUSH
33889: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33893: LD_STRING Motherlode1
33895: PPUSH
33896: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 255
33909: PUSH
33910: LD_INT 3
33912: EQUAL
33913: IFFALSE 33934
// begin wait ( 0 0$5 ) ;
33915: LD_INT 175
33917: PPUSH
33918: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33922: LD_EXP 64
33926: PPUSH
33927: LD_STRING D18-Pla-1
33929: PPUSH
33930: CALL_OW 94
// end ; end ;
33934: PPOPN 3
33936: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL 122787 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33946: LD_VAR 0 1
33950: PUSH
33951: LD_INT 22
33953: PUSH
33954: LD_INT 1
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 21
33963: PUSH
33964: LD_INT 1
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 23
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: LIST
33985: PPUSH
33986: CALL_OW 69
33990: IN
33991: IFFALSE 34007
// lostCounter := lostCounter + 1 ;
33993: LD_ADDR_EXP 32
33997: PUSH
33998: LD_EXP 32
34002: PUSH
34003: LD_INT 1
34005: PLUS
34006: ST_TO_ADDR
// if un in behemothBuilders then
34007: LD_VAR 0 1
34011: PUSH
34012: LD_EXP 73
34016: IN
34017: IFFALSE 34037
// begin behemothBuilders := behemothBuilders diff un ;
34019: LD_ADDR_EXP 73
34023: PUSH
34024: LD_EXP 73
34028: PUSH
34029: LD_VAR 0 1
34033: DIFF
34034: ST_TO_ADDR
// exit ;
34035: GO 34067
// end ; if un = JMM then
34037: LD_VAR 0 1
34041: PUSH
34042: LD_EXP 39
34046: EQUAL
34047: IFFALSE 34058
// begin YouLost ( JMM ) ;
34049: LD_STRING JMM
34051: PPUSH
34052: CALL_OW 104
// exit ;
34056: GO 34067
// end ; MCE_UnitDestroyed ( un ) ;
34058: LD_VAR 0 1
34062: PPUSH
34063: CALL 62934 0 1
// end ;
34067: PPOPN 1
34069: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34070: LD_VAR 0 1
34074: PPUSH
34075: LD_VAR 0 2
34079: PPUSH
34080: CALL 65268 0 2
// end ;
34084: PPOPN 2
34086: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34087: LD_VAR 0 1
34091: PPUSH
34092: CALL 64336 0 1
// end ;
34096: PPOPN 1
34098: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34099: LD_VAR 0 1
34103: PUSH
34104: LD_INT 22
34106: PUSH
34107: LD_INT 8
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 30
34116: PUSH
34117: LD_INT 2
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: LD_INT 23
34126: PUSH
34127: LD_INT 3
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: LIST
34138: PPUSH
34139: CALL_OW 69
34143: IN
34144: IFFALSE 34171
// begin ComUpgrade ( building ) ;
34146: LD_VAR 0 1
34150: PPUSH
34151: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34155: LD_EXP 61
34159: PPUSH
34160: LD_VAR 0 1
34164: PPUSH
34165: CALL 73922 0 2
// exit ;
34169: GO 34180
// end ; MCE_BuildingComplete ( building ) ;
34171: LD_VAR 0 1
34175: PPUSH
34176: CALL 64577 0 1
// end ;
34180: PPOPN 1
34182: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34183: LD_VAR 0 1
34187: PPUSH
34188: LD_VAR 0 2
34192: PPUSH
34193: CALL 62630 0 2
// end ;
34197: PPOPN 2
34199: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34200: LD_VAR 0 1
34204: PPUSH
34205: LD_VAR 0 2
34209: PPUSH
34210: LD_VAR 0 3
34214: PPUSH
34215: LD_VAR 0 4
34219: PPUSH
34220: LD_VAR 0 5
34224: PPUSH
34225: CALL 62250 0 5
// end ;
34229: PPOPN 5
34231: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
34232: LD_VAR 0 1
34236: PPUSH
34237: LD_VAR 0 2
34241: PPUSH
34242: CALL 122909 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
34246: LD_VAR 0 1
34250: PPUSH
34251: LD_VAR 0 2
34255: PPUSH
34256: CALL 61831 0 2
// end ;
34260: PPOPN 2
34262: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34263: LD_VAR 0 1
34267: PPUSH
34268: LD_VAR 0 2
34272: PPUSH
34273: LD_VAR 0 3
34277: PPUSH
34278: LD_VAR 0 4
34282: PPUSH
34283: CALL 61669 0 4
// end ;
34287: PPOPN 4
34289: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34290: LD_VAR 0 1
34294: PPUSH
34295: LD_VAR 0 2
34299: PPUSH
34300: LD_VAR 0 3
34304: PPUSH
34305: CALL 61444 0 3
// end ;
34309: PPOPN 3
34311: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34312: LD_VAR 0 1
34316: PPUSH
34317: LD_VAR 0 2
34321: PPUSH
34322: CALL 61329 0 2
// end ;
34326: PPOPN 2
34328: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34329: LD_VAR 0 1
34333: PPUSH
34334: LD_VAR 0 2
34338: PPUSH
34339: CALL 65563 0 2
// end ;
34343: PPOPN 2
34345: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34346: LD_VAR 0 1
34350: PPUSH
34351: CALL_OW 255
34355: PUSH
34356: LD_INT 4
34358: EQUAL
34359: PUSH
34360: LD_VAR 0 1
34364: PUSH
34365: LD_EXP 18
34369: PUSH
34370: LD_INT 1
34372: ARRAY
34373: IN
34374: AND
34375: PUSH
34376: LD_EXP 19
34380: AND
34381: IFFALSE 34400
// begin ComMoveXY ( driver , 61 , 93 ) ;
34383: LD_VAR 0 1
34387: PPUSH
34388: LD_INT 61
34390: PPUSH
34391: LD_INT 93
34393: PPUSH
34394: CALL_OW 111
// exit ;
34398: GO 34424
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34400: LD_VAR 0 1
34404: PPUSH
34405: LD_VAR 0 2
34409: PPUSH
34410: LD_VAR 0 3
34414: PPUSH
34415: LD_VAR 0 4
34419: PPUSH
34420: CALL 65779 0 4
// end ;
34424: PPOPN 4
34426: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34427: LD_VAR 0 1
34431: PPUSH
34432: LD_VAR 0 2
34436: PPUSH
34437: CALL 61138 0 2
// end ;
34441: PPOPN 2
34443: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34444: LD_VAR 0 1
34448: PPUSH
34449: CALL 122893 0 1
// end ; end_of_file
34453: PPOPN 1
34455: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34456: LD_EXP 15
34460: PUSH
34461: LD_INT 2
34463: EQUAL
34464: IFFALSE 34947
34466: GO 34468
34468: DISABLE
34469: LD_INT 0
34471: PPUSH
// begin time := 0 0$40 ;
34472: LD_ADDR_VAR 0 1
34476: PUSH
34477: LD_INT 1400
34479: ST_TO_ADDR
// repeat wait ( time ) ;
34480: LD_VAR 0 1
34484: PPUSH
34485: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34489: LD_INT 1
34491: PPUSH
34492: LD_INT 5
34494: PPUSH
34495: CALL_OW 12
34499: PPUSH
34500: LD_INT 106
34502: PPUSH
34503: LD_INT 150
34505: PPUSH
34506: LD_INT 19
34508: PPUSH
34509: LD_INT 1
34511: PPUSH
34512: CALL_OW 56
// time := time + 0 0$9 ;
34516: LD_ADDR_VAR 0 1
34520: PUSH
34521: LD_VAR 0 1
34525: PUSH
34526: LD_INT 315
34528: PLUS
34529: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34530: LD_INT 455
34532: PPUSH
34533: LD_INT 840
34535: PPUSH
34536: CALL_OW 12
34540: PPUSH
34541: CALL_OW 67
// if Prob ( 50 ) then
34545: LD_INT 50
34547: PPUSH
34548: CALL_OW 13
34552: IFFALSE 34581
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34554: LD_INT 1
34556: PPUSH
34557: LD_INT 5
34559: PPUSH
34560: CALL_OW 12
34564: PPUSH
34565: LD_INT 62
34567: PPUSH
34568: LD_INT 108
34570: PPUSH
34571: LD_INT 10
34573: PPUSH
34574: LD_INT 1
34576: PPUSH
34577: CALL_OW 56
// until missionStage > 4 ;
34581: LD_EXP 15
34585: PUSH
34586: LD_INT 4
34588: GREATER
34589: IFFALSE 34480
// repeat wait ( 0 0$1 ) ;
34591: LD_INT 35
34593: PPUSH
34594: CALL_OW 67
// until missionStage = 6 ;
34598: LD_EXP 15
34602: PUSH
34603: LD_INT 6
34605: EQUAL
34606: IFFALSE 34591
// time := 0 0$50 ;
34608: LD_ADDR_VAR 0 1
34612: PUSH
34613: LD_INT 1750
34615: ST_TO_ADDR
// repeat wait ( time ) ;
34616: LD_VAR 0 1
34620: PPUSH
34621: CALL_OW 67
// if Prob ( 50 ) then
34625: LD_INT 50
34627: PPUSH
34628: CALL_OW 13
34632: IFFALSE 34661
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34634: LD_INT 1
34636: PPUSH
34637: LD_INT 5
34639: PPUSH
34640: CALL_OW 12
34644: PPUSH
34645: LD_INT 106
34647: PPUSH
34648: LD_INT 89
34650: PPUSH
34651: LD_INT 45
34653: PPUSH
34654: LD_INT 1
34656: PPUSH
34657: CALL_OW 56
// time := time + 0 0$2 ;
34661: LD_ADDR_VAR 0 1
34665: PUSH
34666: LD_VAR 0 1
34670: PUSH
34671: LD_INT 70
34673: PLUS
34674: ST_TO_ADDR
// if Prob ( 30 ) then
34675: LD_INT 30
34677: PPUSH
34678: CALL_OW 13
34682: IFFALSE 34728
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34684: LD_INT 385
34686: PPUSH
34687: LD_INT 945
34689: PPUSH
34690: CALL_OW 12
34694: PPUSH
34695: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34699: LD_INT 1
34701: PPUSH
34702: LD_INT 5
34704: PPUSH
34705: CALL_OW 12
34709: PPUSH
34710: LD_INT 21
34712: PPUSH
34713: LD_INT 26
34715: PPUSH
34716: LD_INT 12
34718: PPUSH
34719: LD_INT 1
34721: PPUSH
34722: CALL_OW 56
// end else
34726: GO 34764
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34728: LD_INT 700
34730: PPUSH
34731: LD_INT 1225
34733: PPUSH
34734: CALL_OW 12
34738: PPUSH
34739: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34743: LD_INT 1
34745: PPUSH
34746: LD_INT 5
34748: PPUSH
34749: CALL_OW 12
34753: PPUSH
34754: LD_INT 16
34756: PPUSH
34757: LD_INT 1
34759: PPUSH
34760: CALL_OW 55
// end ; if Prob ( 50 ) then
34764: LD_INT 50
34766: PPUSH
34767: CALL_OW 13
34771: IFFALSE 34817
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34773: LD_INT 700
34775: PPUSH
34776: LD_INT 1050
34778: PPUSH
34779: CALL_OW 12
34783: PPUSH
34784: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34788: LD_INT 1
34790: PPUSH
34791: LD_INT 5
34793: PPUSH
34794: CALL_OW 12
34798: PPUSH
34799: LD_INT 181
34801: PPUSH
34802: LD_INT 218
34804: PPUSH
34805: LD_INT 16
34807: PPUSH
34808: LD_INT 1
34810: PPUSH
34811: CALL_OW 56
// end else
34815: GO 34853
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34817: LD_INT 350
34819: PPUSH
34820: LD_INT 525
34822: PPUSH
34823: CALL_OW 12
34827: PPUSH
34828: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34832: LD_INT 1
34834: PPUSH
34835: LD_INT 5
34837: PPUSH
34838: CALL_OW 12
34842: PPUSH
34843: LD_INT 15
34845: PPUSH
34846: LD_INT 1
34848: PPUSH
34849: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34853: LD_INT 45
34855: PUSH
34856: LD_INT 32
34858: PUSH
34859: LD_INT 25
34861: PUSH
34862: LD_INT 22
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: LIST
34869: LIST
34870: PUSH
34871: LD_OWVAR 67
34875: ARRAY
34876: PPUSH
34877: CALL_OW 13
34881: IFFALSE 34925
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34883: LD_INT 175
34885: PPUSH
34886: LD_INT 315
34888: PPUSH
34889: CALL_OW 12
34893: PPUSH
34894: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34898: LD_INT 1
34900: PPUSH
34901: LD_INT 5
34903: PPUSH
34904: CALL_OW 12
34908: PPUSH
34909: LD_INT 103
34911: PPUSH
34912: LD_INT 140
34914: PPUSH
34915: LD_INT 20
34917: PPUSH
34918: LD_INT 1
34920: PPUSH
34921: CALL_OW 56
// end ; if time > 1 1$20 then
34925: LD_VAR 0 1
34929: PUSH
34930: LD_INT 2800
34932: GREATER
34933: IFFALSE 34943
// time := 0 0$30 ;
34935: LD_ADDR_VAR 0 1
34939: PUSH
34940: LD_INT 1050
34942: ST_TO_ADDR
// until false ;
34943: LD_INT 0
34945: IFFALSE 34616
// end ; end_of_file
34947: PPOPN 1
34949: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34950: LD_EXP 13
34954: PUSH
34955: LD_EXP 15
34959: PUSH
34960: LD_INT 6
34962: GREATEREQUAL
34963: AND
34964: IFFALSE 35001
34966: GO 34968
34968: DISABLE
// begin enable ;
34969: ENABLE
// missionTime := missionTime + 0 0$1 ;
34970: LD_ADDR_EXP 14
34974: PUSH
34975: LD_EXP 14
34979: PUSH
34980: LD_INT 35
34982: PLUS
34983: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34984: LD_ADDR_OWVAR 47
34988: PUSH
34989: LD_STRING #Am15-1
34991: PUSH
34992: LD_EXP 14
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: ST_TO_ADDR
// end ; end_of_file
35001: END
// export function InitNature ; begin
35002: LD_INT 0
35004: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
35005: LD_INT 3
35007: PPUSH
35008: LD_INT 3
35010: PPUSH
35011: LD_INT 2
35013: PPUSH
35014: LD_INT 1
35016: PPUSH
35017: LD_INT 1
35019: PPUSH
35020: LD_INT 0
35022: PPUSH
35023: LD_INT 0
35025: PPUSH
35026: LD_INT 20
35028: PPUSH
35029: LD_INT 0
35031: PPUSH
35032: CALL 100003 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
35036: LD_INT 2
35038: PPUSH
35039: LD_INT 1
35041: PPUSH
35042: LD_INT 1
35044: PPUSH
35045: LD_INT 1
35047: PPUSH
35048: LD_INT 1
35050: PPUSH
35051: LD_INT 0
35053: PPUSH
35054: LD_INT 0
35056: PPUSH
35057: LD_INT 21
35059: PPUSH
35060: LD_INT 0
35062: PPUSH
35063: CALL 100003 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35067: LD_INT 4
35069: PPUSH
35070: LD_INT 1
35072: PPUSH
35073: LD_INT 2
35075: PPUSH
35076: LD_INT 4
35078: PPUSH
35079: LD_INT 2
35081: PPUSH
35082: LD_INT 1
35084: PPUSH
35085: LD_INT 0
35087: PPUSH
35088: LD_INT 22
35090: PPUSH
35091: LD_INT 0
35093: PPUSH
35094: CALL 100003 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35098: LD_INT 0
35100: PPUSH
35101: LD_INT 0
35103: PPUSH
35104: LD_INT 0
35106: PPUSH
35107: LD_INT 0
35109: PPUSH
35110: LD_INT 0
35112: PPUSH
35113: LD_INT 0
35115: PPUSH
35116: LD_INT 9
35118: PPUSH
35119: LD_INT 0
35121: PPUSH
35122: LD_INT 23
35124: PPUSH
35125: CALL 100003 0 9
// end ; end_of_file
35129: LD_VAR 0 1
35133: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
35134: LD_INT 0
35136: PPUSH
// ar_miner := 81 ;
35137: LD_ADDR_EXP 102
35141: PUSH
35142: LD_INT 81
35144: ST_TO_ADDR
// ar_crane := 88 ;
35145: LD_ADDR_EXP 101
35149: PUSH
35150: LD_INT 88
35152: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35153: LD_ADDR_EXP 96
35157: PUSH
35158: LD_INT 89
35160: ST_TO_ADDR
// us_hack := 99 ;
35161: LD_ADDR_EXP 97
35165: PUSH
35166: LD_INT 99
35168: ST_TO_ADDR
// us_artillery := 97 ;
35169: LD_ADDR_EXP 98
35173: PUSH
35174: LD_INT 97
35176: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35177: LD_ADDR_EXP 99
35181: PUSH
35182: LD_INT 91
35184: ST_TO_ADDR
// ar_mortar := 92 ;
35185: LD_ADDR_EXP 100
35189: PUSH
35190: LD_INT 92
35192: ST_TO_ADDR
// ru_flamethrower := 93 ;
35193: LD_ADDR_EXP 103
35197: PUSH
35198: LD_INT 93
35200: ST_TO_ADDR
// ru_radar := 98 ;
35201: LD_ADDR_EXP 95
35205: PUSH
35206: LD_INT 98
35208: ST_TO_ADDR
// tech_Artillery := 80 ;
35209: LD_ADDR_EXP 104
35213: PUSH
35214: LD_INT 80
35216: ST_TO_ADDR
// tech_RadMat := 81 ;
35217: LD_ADDR_EXP 105
35221: PUSH
35222: LD_INT 81
35224: ST_TO_ADDR
// tech_BasicTools := 82 ;
35225: LD_ADDR_EXP 106
35229: PUSH
35230: LD_INT 82
35232: ST_TO_ADDR
// tech_Cargo := 83 ;
35233: LD_ADDR_EXP 107
35237: PUSH
35238: LD_INT 83
35240: ST_TO_ADDR
// tech_Track := 84 ;
35241: LD_ADDR_EXP 108
35245: PUSH
35246: LD_INT 84
35248: ST_TO_ADDR
// tech_Crane := 85 ;
35249: LD_ADDR_EXP 109
35253: PUSH
35254: LD_INT 85
35256: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35257: LD_ADDR_EXP 110
35261: PUSH
35262: LD_INT 86
35264: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35265: LD_ADDR_EXP 111
35269: PUSH
35270: LD_INT 87
35272: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35273: LD_ADDR_EXP 112
35277: PUSH
35278: LD_INT 88
35280: ST_TO_ADDR
// end ;
35281: LD_VAR 0 1
35285: RET
// every 1 do
35286: GO 35288
35288: DISABLE
// InitGlobalVariables ; end_of_file
35289: CALL 35134 0 0
35293: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35294: LD_INT 0
35296: PPUSH
35297: PPUSH
// skirmish := false ;
35298: LD_ADDR_EXP 113
35302: PUSH
35303: LD_INT 0
35305: ST_TO_ADDR
// debug_mc := false ;
35306: LD_ADDR_EXP 114
35310: PUSH
35311: LD_INT 0
35313: ST_TO_ADDR
// mc_bases := [ ] ;
35314: LD_ADDR_EXP 115
35318: PUSH
35319: EMPTY
35320: ST_TO_ADDR
// mc_sides := [ ] ;
35321: LD_ADDR_EXP 141
35325: PUSH
35326: EMPTY
35327: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35328: LD_ADDR_EXP 116
35332: PUSH
35333: EMPTY
35334: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35335: LD_ADDR_EXP 117
35339: PUSH
35340: EMPTY
35341: ST_TO_ADDR
// mc_need_heal := [ ] ;
35342: LD_ADDR_EXP 118
35346: PUSH
35347: EMPTY
35348: ST_TO_ADDR
// mc_healers := [ ] ;
35349: LD_ADDR_EXP 119
35353: PUSH
35354: EMPTY
35355: ST_TO_ADDR
// mc_build_list := [ ] ;
35356: LD_ADDR_EXP 120
35360: PUSH
35361: EMPTY
35362: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35363: LD_ADDR_EXP 147
35367: PUSH
35368: EMPTY
35369: ST_TO_ADDR
// mc_builders := [ ] ;
35370: LD_ADDR_EXP 121
35374: PUSH
35375: EMPTY
35376: ST_TO_ADDR
// mc_construct_list := [ ] ;
35377: LD_ADDR_EXP 122
35381: PUSH
35382: EMPTY
35383: ST_TO_ADDR
// mc_turret_list := [ ] ;
35384: LD_ADDR_EXP 123
35388: PUSH
35389: EMPTY
35390: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35391: LD_ADDR_EXP 124
35395: PUSH
35396: EMPTY
35397: ST_TO_ADDR
// mc_miners := [ ] ;
35398: LD_ADDR_EXP 129
35402: PUSH
35403: EMPTY
35404: ST_TO_ADDR
// mc_mines := [ ] ;
35405: LD_ADDR_EXP 128
35409: PUSH
35410: EMPTY
35411: ST_TO_ADDR
// mc_minefields := [ ] ;
35412: LD_ADDR_EXP 130
35416: PUSH
35417: EMPTY
35418: ST_TO_ADDR
// mc_crates := [ ] ;
35419: LD_ADDR_EXP 131
35423: PUSH
35424: EMPTY
35425: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35426: LD_ADDR_EXP 132
35430: PUSH
35431: EMPTY
35432: ST_TO_ADDR
// mc_crates_area := [ ] ;
35433: LD_ADDR_EXP 133
35437: PUSH
35438: EMPTY
35439: ST_TO_ADDR
// mc_vehicles := [ ] ;
35440: LD_ADDR_EXP 134
35444: PUSH
35445: EMPTY
35446: ST_TO_ADDR
// mc_attack := [ ] ;
35447: LD_ADDR_EXP 135
35451: PUSH
35452: EMPTY
35453: ST_TO_ADDR
// mc_produce := [ ] ;
35454: LD_ADDR_EXP 136
35458: PUSH
35459: EMPTY
35460: ST_TO_ADDR
// mc_defender := [ ] ;
35461: LD_ADDR_EXP 137
35465: PUSH
35466: EMPTY
35467: ST_TO_ADDR
// mc_parking := [ ] ;
35468: LD_ADDR_EXP 139
35472: PUSH
35473: EMPTY
35474: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35475: LD_ADDR_EXP 125
35479: PUSH
35480: EMPTY
35481: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35482: LD_ADDR_EXP 127
35486: PUSH
35487: EMPTY
35488: ST_TO_ADDR
// mc_scan := [ ] ;
35489: LD_ADDR_EXP 138
35493: PUSH
35494: EMPTY
35495: ST_TO_ADDR
// mc_scan_area := [ ] ;
35496: LD_ADDR_EXP 140
35500: PUSH
35501: EMPTY
35502: ST_TO_ADDR
// mc_tech := [ ] ;
35503: LD_ADDR_EXP 142
35507: PUSH
35508: EMPTY
35509: ST_TO_ADDR
// mc_class := [ ] ;
35510: LD_ADDR_EXP 156
35514: PUSH
35515: EMPTY
35516: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35517: LD_ADDR_EXP 157
35521: PUSH
35522: EMPTY
35523: ST_TO_ADDR
// mc_is_defending := [ ] ;
35524: LD_ADDR_EXP 158
35528: PUSH
35529: EMPTY
35530: ST_TO_ADDR
// end ;
35531: LD_VAR 0 1
35535: RET
// export function MC_Kill ( base ) ; begin
35536: LD_INT 0
35538: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35539: LD_ADDR_EXP 115
35543: PUSH
35544: LD_EXP 115
35548: PPUSH
35549: LD_VAR 0 1
35553: PPUSH
35554: EMPTY
35555: PPUSH
35556: CALL_OW 1
35560: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35561: LD_ADDR_EXP 116
35565: PUSH
35566: LD_EXP 116
35570: PPUSH
35571: LD_VAR 0 1
35575: PPUSH
35576: EMPTY
35577: PPUSH
35578: CALL_OW 1
35582: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35583: LD_ADDR_EXP 117
35587: PUSH
35588: LD_EXP 117
35592: PPUSH
35593: LD_VAR 0 1
35597: PPUSH
35598: EMPTY
35599: PPUSH
35600: CALL_OW 1
35604: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35605: LD_ADDR_EXP 118
35609: PUSH
35610: LD_EXP 118
35614: PPUSH
35615: LD_VAR 0 1
35619: PPUSH
35620: EMPTY
35621: PPUSH
35622: CALL_OW 1
35626: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35627: LD_ADDR_EXP 119
35631: PUSH
35632: LD_EXP 119
35636: PPUSH
35637: LD_VAR 0 1
35641: PPUSH
35642: EMPTY
35643: PPUSH
35644: CALL_OW 1
35648: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35649: LD_ADDR_EXP 120
35653: PUSH
35654: LD_EXP 120
35658: PPUSH
35659: LD_VAR 0 1
35663: PPUSH
35664: EMPTY
35665: PPUSH
35666: CALL_OW 1
35670: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35671: LD_ADDR_EXP 121
35675: PUSH
35676: LD_EXP 121
35680: PPUSH
35681: LD_VAR 0 1
35685: PPUSH
35686: EMPTY
35687: PPUSH
35688: CALL_OW 1
35692: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35693: LD_ADDR_EXP 122
35697: PUSH
35698: LD_EXP 122
35702: PPUSH
35703: LD_VAR 0 1
35707: PPUSH
35708: EMPTY
35709: PPUSH
35710: CALL_OW 1
35714: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35715: LD_ADDR_EXP 123
35719: PUSH
35720: LD_EXP 123
35724: PPUSH
35725: LD_VAR 0 1
35729: PPUSH
35730: EMPTY
35731: PPUSH
35732: CALL_OW 1
35736: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35737: LD_ADDR_EXP 124
35741: PUSH
35742: LD_EXP 124
35746: PPUSH
35747: LD_VAR 0 1
35751: PPUSH
35752: EMPTY
35753: PPUSH
35754: CALL_OW 1
35758: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35759: LD_ADDR_EXP 125
35763: PUSH
35764: LD_EXP 125
35768: PPUSH
35769: LD_VAR 0 1
35773: PPUSH
35774: EMPTY
35775: PPUSH
35776: CALL_OW 1
35780: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35781: LD_ADDR_EXP 126
35785: PUSH
35786: LD_EXP 126
35790: PPUSH
35791: LD_VAR 0 1
35795: PPUSH
35796: LD_INT 0
35798: PPUSH
35799: CALL_OW 1
35803: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35804: LD_ADDR_EXP 127
35808: PUSH
35809: LD_EXP 127
35813: PPUSH
35814: LD_VAR 0 1
35818: PPUSH
35819: EMPTY
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35826: LD_ADDR_EXP 128
35830: PUSH
35831: LD_EXP 128
35835: PPUSH
35836: LD_VAR 0 1
35840: PPUSH
35841: EMPTY
35842: PPUSH
35843: CALL_OW 1
35847: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35848: LD_ADDR_EXP 129
35852: PUSH
35853: LD_EXP 129
35857: PPUSH
35858: LD_VAR 0 1
35862: PPUSH
35863: EMPTY
35864: PPUSH
35865: CALL_OW 1
35869: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35870: LD_ADDR_EXP 130
35874: PUSH
35875: LD_EXP 130
35879: PPUSH
35880: LD_VAR 0 1
35884: PPUSH
35885: EMPTY
35886: PPUSH
35887: CALL_OW 1
35891: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35892: LD_ADDR_EXP 131
35896: PUSH
35897: LD_EXP 131
35901: PPUSH
35902: LD_VAR 0 1
35906: PPUSH
35907: EMPTY
35908: PPUSH
35909: CALL_OW 1
35913: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35914: LD_ADDR_EXP 132
35918: PUSH
35919: LD_EXP 132
35923: PPUSH
35924: LD_VAR 0 1
35928: PPUSH
35929: EMPTY
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35936: LD_ADDR_EXP 133
35940: PUSH
35941: LD_EXP 133
35945: PPUSH
35946: LD_VAR 0 1
35950: PPUSH
35951: EMPTY
35952: PPUSH
35953: CALL_OW 1
35957: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35958: LD_ADDR_EXP 134
35962: PUSH
35963: LD_EXP 134
35967: PPUSH
35968: LD_VAR 0 1
35972: PPUSH
35973: EMPTY
35974: PPUSH
35975: CALL_OW 1
35979: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35980: LD_ADDR_EXP 135
35984: PUSH
35985: LD_EXP 135
35989: PPUSH
35990: LD_VAR 0 1
35994: PPUSH
35995: EMPTY
35996: PPUSH
35997: CALL_OW 1
36001: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36002: LD_ADDR_EXP 136
36006: PUSH
36007: LD_EXP 136
36011: PPUSH
36012: LD_VAR 0 1
36016: PPUSH
36017: EMPTY
36018: PPUSH
36019: CALL_OW 1
36023: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36024: LD_ADDR_EXP 137
36028: PUSH
36029: LD_EXP 137
36033: PPUSH
36034: LD_VAR 0 1
36038: PPUSH
36039: EMPTY
36040: PPUSH
36041: CALL_OW 1
36045: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36046: LD_ADDR_EXP 138
36050: PUSH
36051: LD_EXP 138
36055: PPUSH
36056: LD_VAR 0 1
36060: PPUSH
36061: EMPTY
36062: PPUSH
36063: CALL_OW 1
36067: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36068: LD_ADDR_EXP 139
36072: PUSH
36073: LD_EXP 139
36077: PPUSH
36078: LD_VAR 0 1
36082: PPUSH
36083: EMPTY
36084: PPUSH
36085: CALL_OW 1
36089: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36090: LD_ADDR_EXP 140
36094: PUSH
36095: LD_EXP 140
36099: PPUSH
36100: LD_VAR 0 1
36104: PPUSH
36105: EMPTY
36106: PPUSH
36107: CALL_OW 1
36111: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36112: LD_ADDR_EXP 142
36116: PUSH
36117: LD_EXP 142
36121: PPUSH
36122: LD_VAR 0 1
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL_OW 1
36133: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36134: LD_ADDR_EXP 144
36138: PUSH
36139: LD_EXP 144
36143: PPUSH
36144: LD_VAR 0 1
36148: PPUSH
36149: EMPTY
36150: PPUSH
36151: CALL_OW 1
36155: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36156: LD_ADDR_EXP 145
36160: PUSH
36161: LD_EXP 145
36165: PPUSH
36166: LD_VAR 0 1
36170: PPUSH
36171: EMPTY
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36178: LD_ADDR_EXP 146
36182: PUSH
36183: LD_EXP 146
36187: PPUSH
36188: LD_VAR 0 1
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36200: LD_ADDR_EXP 147
36204: PUSH
36205: LD_EXP 147
36209: PPUSH
36210: LD_VAR 0 1
36214: PPUSH
36215: EMPTY
36216: PPUSH
36217: CALL_OW 1
36221: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36222: LD_ADDR_EXP 148
36226: PUSH
36227: LD_EXP 148
36231: PPUSH
36232: LD_VAR 0 1
36236: PPUSH
36237: EMPTY
36238: PPUSH
36239: CALL_OW 1
36243: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36244: LD_ADDR_EXP 149
36248: PUSH
36249: LD_EXP 149
36253: PPUSH
36254: LD_VAR 0 1
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36266: LD_ADDR_EXP 150
36270: PUSH
36271: LD_EXP 150
36275: PPUSH
36276: LD_VAR 0 1
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL_OW 1
36287: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36288: LD_ADDR_EXP 151
36292: PUSH
36293: LD_EXP 151
36297: PPUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36310: LD_ADDR_EXP 152
36314: PUSH
36315: LD_EXP 152
36319: PPUSH
36320: LD_VAR 0 1
36324: PPUSH
36325: EMPTY
36326: PPUSH
36327: CALL_OW 1
36331: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36332: LD_ADDR_EXP 153
36336: PUSH
36337: LD_EXP 153
36341: PPUSH
36342: LD_VAR 0 1
36346: PPUSH
36347: EMPTY
36348: PPUSH
36349: CALL_OW 1
36353: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36354: LD_ADDR_EXP 154
36358: PUSH
36359: LD_EXP 154
36363: PPUSH
36364: LD_VAR 0 1
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36376: LD_ADDR_EXP 155
36380: PUSH
36381: LD_EXP 155
36385: PPUSH
36386: LD_VAR 0 1
36390: PPUSH
36391: EMPTY
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36398: LD_ADDR_EXP 156
36402: PUSH
36403: LD_EXP 156
36407: PPUSH
36408: LD_VAR 0 1
36412: PPUSH
36413: EMPTY
36414: PPUSH
36415: CALL_OW 1
36419: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36420: LD_ADDR_EXP 157
36424: PUSH
36425: LD_EXP 157
36429: PPUSH
36430: LD_VAR 0 1
36434: PPUSH
36435: LD_INT 0
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36443: LD_ADDR_EXP 158
36447: PUSH
36448: LD_EXP 158
36452: PPUSH
36453: LD_VAR 0 1
36457: PPUSH
36458: LD_INT 0
36460: PPUSH
36461: CALL_OW 1
36465: ST_TO_ADDR
// end ;
36466: LD_VAR 0 2
36470: RET
// export function MC_Add ( side , units ) ; var base ; begin
36471: LD_INT 0
36473: PPUSH
36474: PPUSH
// base := mc_bases + 1 ;
36475: LD_ADDR_VAR 0 4
36479: PUSH
36480: LD_EXP 115
36484: PUSH
36485: LD_INT 1
36487: PLUS
36488: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36489: LD_ADDR_EXP 141
36493: PUSH
36494: LD_EXP 141
36498: PPUSH
36499: LD_VAR 0 4
36503: PPUSH
36504: LD_VAR 0 1
36508: PPUSH
36509: CALL_OW 1
36513: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36514: LD_ADDR_EXP 115
36518: PUSH
36519: LD_EXP 115
36523: PPUSH
36524: LD_VAR 0 4
36528: PPUSH
36529: LD_VAR 0 2
36533: PPUSH
36534: CALL_OW 1
36538: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36539: LD_ADDR_EXP 116
36543: PUSH
36544: LD_EXP 116
36548: PPUSH
36549: LD_VAR 0 4
36553: PPUSH
36554: EMPTY
36555: PPUSH
36556: CALL_OW 1
36560: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36561: LD_ADDR_EXP 117
36565: PUSH
36566: LD_EXP 117
36570: PPUSH
36571: LD_VAR 0 4
36575: PPUSH
36576: EMPTY
36577: PPUSH
36578: CALL_OW 1
36582: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36583: LD_ADDR_EXP 118
36587: PUSH
36588: LD_EXP 118
36592: PPUSH
36593: LD_VAR 0 4
36597: PPUSH
36598: EMPTY
36599: PPUSH
36600: CALL_OW 1
36604: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36605: LD_ADDR_EXP 119
36609: PUSH
36610: LD_EXP 119
36614: PPUSH
36615: LD_VAR 0 4
36619: PPUSH
36620: EMPTY
36621: PPUSH
36622: CALL_OW 1
36626: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36627: LD_ADDR_EXP 120
36631: PUSH
36632: LD_EXP 120
36636: PPUSH
36637: LD_VAR 0 4
36641: PPUSH
36642: EMPTY
36643: PPUSH
36644: CALL_OW 1
36648: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36649: LD_ADDR_EXP 121
36653: PUSH
36654: LD_EXP 121
36658: PPUSH
36659: LD_VAR 0 4
36663: PPUSH
36664: EMPTY
36665: PPUSH
36666: CALL_OW 1
36670: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36671: LD_ADDR_EXP 122
36675: PUSH
36676: LD_EXP 122
36680: PPUSH
36681: LD_VAR 0 4
36685: PPUSH
36686: EMPTY
36687: PPUSH
36688: CALL_OW 1
36692: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36693: LD_ADDR_EXP 123
36697: PUSH
36698: LD_EXP 123
36702: PPUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: EMPTY
36709: PPUSH
36710: CALL_OW 1
36714: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36715: LD_ADDR_EXP 124
36719: PUSH
36720: LD_EXP 124
36724: PPUSH
36725: LD_VAR 0 4
36729: PPUSH
36730: EMPTY
36731: PPUSH
36732: CALL_OW 1
36736: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36737: LD_ADDR_EXP 125
36741: PUSH
36742: LD_EXP 125
36746: PPUSH
36747: LD_VAR 0 4
36751: PPUSH
36752: EMPTY
36753: PPUSH
36754: CALL_OW 1
36758: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36759: LD_ADDR_EXP 126
36763: PUSH
36764: LD_EXP 126
36768: PPUSH
36769: LD_VAR 0 4
36773: PPUSH
36774: LD_INT 0
36776: PPUSH
36777: CALL_OW 1
36781: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36782: LD_ADDR_EXP 127
36786: PUSH
36787: LD_EXP 127
36791: PPUSH
36792: LD_VAR 0 4
36796: PPUSH
36797: EMPTY
36798: PPUSH
36799: CALL_OW 1
36803: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36804: LD_ADDR_EXP 128
36808: PUSH
36809: LD_EXP 128
36813: PPUSH
36814: LD_VAR 0 4
36818: PPUSH
36819: EMPTY
36820: PPUSH
36821: CALL_OW 1
36825: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36826: LD_ADDR_EXP 129
36830: PUSH
36831: LD_EXP 129
36835: PPUSH
36836: LD_VAR 0 4
36840: PPUSH
36841: EMPTY
36842: PPUSH
36843: CALL_OW 1
36847: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36848: LD_ADDR_EXP 130
36852: PUSH
36853: LD_EXP 130
36857: PPUSH
36858: LD_VAR 0 4
36862: PPUSH
36863: EMPTY
36864: PPUSH
36865: CALL_OW 1
36869: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36870: LD_ADDR_EXP 131
36874: PUSH
36875: LD_EXP 131
36879: PPUSH
36880: LD_VAR 0 4
36884: PPUSH
36885: EMPTY
36886: PPUSH
36887: CALL_OW 1
36891: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36892: LD_ADDR_EXP 132
36896: PUSH
36897: LD_EXP 132
36901: PPUSH
36902: LD_VAR 0 4
36906: PPUSH
36907: EMPTY
36908: PPUSH
36909: CALL_OW 1
36913: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36914: LD_ADDR_EXP 133
36918: PUSH
36919: LD_EXP 133
36923: PPUSH
36924: LD_VAR 0 4
36928: PPUSH
36929: EMPTY
36930: PPUSH
36931: CALL_OW 1
36935: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36936: LD_ADDR_EXP 134
36940: PUSH
36941: LD_EXP 134
36945: PPUSH
36946: LD_VAR 0 4
36950: PPUSH
36951: EMPTY
36952: PPUSH
36953: CALL_OW 1
36957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36958: LD_ADDR_EXP 135
36962: PUSH
36963: LD_EXP 135
36967: PPUSH
36968: LD_VAR 0 4
36972: PPUSH
36973: EMPTY
36974: PPUSH
36975: CALL_OW 1
36979: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36980: LD_ADDR_EXP 136
36984: PUSH
36985: LD_EXP 136
36989: PPUSH
36990: LD_VAR 0 4
36994: PPUSH
36995: EMPTY
36996: PPUSH
36997: CALL_OW 1
37001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37002: LD_ADDR_EXP 137
37006: PUSH
37007: LD_EXP 137
37011: PPUSH
37012: LD_VAR 0 4
37016: PPUSH
37017: EMPTY
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37024: LD_ADDR_EXP 138
37028: PUSH
37029: LD_EXP 138
37033: PPUSH
37034: LD_VAR 0 4
37038: PPUSH
37039: EMPTY
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37046: LD_ADDR_EXP 139
37050: PUSH
37051: LD_EXP 139
37055: PPUSH
37056: LD_VAR 0 4
37060: PPUSH
37061: EMPTY
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37068: LD_ADDR_EXP 140
37072: PUSH
37073: LD_EXP 140
37077: PPUSH
37078: LD_VAR 0 4
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37090: LD_ADDR_EXP 142
37094: PUSH
37095: LD_EXP 142
37099: PPUSH
37100: LD_VAR 0 4
37104: PPUSH
37105: EMPTY
37106: PPUSH
37107: CALL_OW 1
37111: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37112: LD_ADDR_EXP 144
37116: PUSH
37117: LD_EXP 144
37121: PPUSH
37122: LD_VAR 0 4
37126: PPUSH
37127: EMPTY
37128: PPUSH
37129: CALL_OW 1
37133: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37134: LD_ADDR_EXP 145
37138: PUSH
37139: LD_EXP 145
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: EMPTY
37150: PPUSH
37151: CALL_OW 1
37155: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37156: LD_ADDR_EXP 146
37160: PUSH
37161: LD_EXP 146
37165: PPUSH
37166: LD_VAR 0 4
37170: PPUSH
37171: EMPTY
37172: PPUSH
37173: CALL_OW 1
37177: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37178: LD_ADDR_EXP 147
37182: PUSH
37183: LD_EXP 147
37187: PPUSH
37188: LD_VAR 0 4
37192: PPUSH
37193: EMPTY
37194: PPUSH
37195: CALL_OW 1
37199: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37200: LD_ADDR_EXP 148
37204: PUSH
37205: LD_EXP 148
37209: PPUSH
37210: LD_VAR 0 4
37214: PPUSH
37215: EMPTY
37216: PPUSH
37217: CALL_OW 1
37221: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37222: LD_ADDR_EXP 149
37226: PUSH
37227: LD_EXP 149
37231: PPUSH
37232: LD_VAR 0 4
37236: PPUSH
37237: EMPTY
37238: PPUSH
37239: CALL_OW 1
37243: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37244: LD_ADDR_EXP 150
37248: PUSH
37249: LD_EXP 150
37253: PPUSH
37254: LD_VAR 0 4
37258: PPUSH
37259: EMPTY
37260: PPUSH
37261: CALL_OW 1
37265: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37266: LD_ADDR_EXP 151
37270: PUSH
37271: LD_EXP 151
37275: PPUSH
37276: LD_VAR 0 4
37280: PPUSH
37281: EMPTY
37282: PPUSH
37283: CALL_OW 1
37287: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37288: LD_ADDR_EXP 152
37292: PUSH
37293: LD_EXP 152
37297: PPUSH
37298: LD_VAR 0 4
37302: PPUSH
37303: EMPTY
37304: PPUSH
37305: CALL_OW 1
37309: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37310: LD_ADDR_EXP 153
37314: PUSH
37315: LD_EXP 153
37319: PPUSH
37320: LD_VAR 0 4
37324: PPUSH
37325: EMPTY
37326: PPUSH
37327: CALL_OW 1
37331: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37332: LD_ADDR_EXP 154
37336: PUSH
37337: LD_EXP 154
37341: PPUSH
37342: LD_VAR 0 4
37346: PPUSH
37347: EMPTY
37348: PPUSH
37349: CALL_OW 1
37353: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37354: LD_ADDR_EXP 155
37358: PUSH
37359: LD_EXP 155
37363: PPUSH
37364: LD_VAR 0 4
37368: PPUSH
37369: EMPTY
37370: PPUSH
37371: CALL_OW 1
37375: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37376: LD_ADDR_EXP 156
37380: PUSH
37381: LD_EXP 156
37385: PPUSH
37386: LD_VAR 0 4
37390: PPUSH
37391: EMPTY
37392: PPUSH
37393: CALL_OW 1
37397: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37398: LD_ADDR_EXP 157
37402: PUSH
37403: LD_EXP 157
37407: PPUSH
37408: LD_VAR 0 4
37412: PPUSH
37413: LD_INT 0
37415: PPUSH
37416: CALL_OW 1
37420: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37421: LD_ADDR_EXP 158
37425: PUSH
37426: LD_EXP 158
37430: PPUSH
37431: LD_VAR 0 4
37435: PPUSH
37436: LD_INT 0
37438: PPUSH
37439: CALL_OW 1
37443: ST_TO_ADDR
// result := base ;
37444: LD_ADDR_VAR 0 3
37448: PUSH
37449: LD_VAR 0 4
37453: ST_TO_ADDR
// end ;
37454: LD_VAR 0 3
37458: RET
// export function MC_Start ( ) ; var i ; begin
37459: LD_INT 0
37461: PPUSH
37462: PPUSH
// for i = 1 to mc_bases do
37463: LD_ADDR_VAR 0 2
37467: PUSH
37468: DOUBLE
37469: LD_INT 1
37471: DEC
37472: ST_TO_ADDR
37473: LD_EXP 115
37477: PUSH
37478: FOR_TO
37479: IFFALSE 38579
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37481: LD_ADDR_EXP 115
37485: PUSH
37486: LD_EXP 115
37490: PPUSH
37491: LD_VAR 0 2
37495: PPUSH
37496: LD_EXP 115
37500: PUSH
37501: LD_VAR 0 2
37505: ARRAY
37506: PUSH
37507: LD_INT 0
37509: DIFF
37510: PPUSH
37511: CALL_OW 1
37515: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37516: LD_ADDR_EXP 116
37520: PUSH
37521: LD_EXP 116
37525: PPUSH
37526: LD_VAR 0 2
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL_OW 1
37537: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37538: LD_ADDR_EXP 117
37542: PUSH
37543: LD_EXP 117
37547: PPUSH
37548: LD_VAR 0 2
37552: PPUSH
37553: EMPTY
37554: PPUSH
37555: CALL_OW 1
37559: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37560: LD_ADDR_EXP 118
37564: PUSH
37565: LD_EXP 118
37569: PPUSH
37570: LD_VAR 0 2
37574: PPUSH
37575: EMPTY
37576: PPUSH
37577: CALL_OW 1
37581: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37582: LD_ADDR_EXP 119
37586: PUSH
37587: LD_EXP 119
37591: PPUSH
37592: LD_VAR 0 2
37596: PPUSH
37597: EMPTY
37598: PUSH
37599: EMPTY
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PPUSH
37605: CALL_OW 1
37609: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37610: LD_ADDR_EXP 120
37614: PUSH
37615: LD_EXP 120
37619: PPUSH
37620: LD_VAR 0 2
37624: PPUSH
37625: EMPTY
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37632: LD_ADDR_EXP 147
37636: PUSH
37637: LD_EXP 147
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37654: LD_ADDR_EXP 121
37658: PUSH
37659: LD_EXP 121
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL_OW 1
37675: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37676: LD_ADDR_EXP 122
37680: PUSH
37681: LD_EXP 122
37685: PPUSH
37686: LD_VAR 0 2
37690: PPUSH
37691: EMPTY
37692: PPUSH
37693: CALL_OW 1
37697: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37698: LD_ADDR_EXP 123
37702: PUSH
37703: LD_EXP 123
37707: PPUSH
37708: LD_VAR 0 2
37712: PPUSH
37713: LD_EXP 115
37717: PUSH
37718: LD_VAR 0 2
37722: ARRAY
37723: PPUSH
37724: LD_INT 2
37726: PUSH
37727: LD_INT 30
37729: PUSH
37730: LD_INT 32
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 30
37739: PUSH
37740: LD_INT 33
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: LIST
37751: PPUSH
37752: CALL_OW 72
37756: PPUSH
37757: CALL_OW 1
37761: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37762: LD_ADDR_EXP 124
37766: PUSH
37767: LD_EXP 124
37771: PPUSH
37772: LD_VAR 0 2
37776: PPUSH
37777: LD_EXP 115
37781: PUSH
37782: LD_VAR 0 2
37786: ARRAY
37787: PPUSH
37788: LD_INT 2
37790: PUSH
37791: LD_INT 30
37793: PUSH
37794: LD_INT 32
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 30
37803: PUSH
37804: LD_INT 31
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 58
37818: PUSH
37819: EMPTY
37820: LIST
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PPUSH
37826: CALL_OW 72
37830: PPUSH
37831: CALL_OW 1
37835: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37836: LD_ADDR_EXP 125
37840: PUSH
37841: LD_EXP 125
37845: PPUSH
37846: LD_VAR 0 2
37850: PPUSH
37851: EMPTY
37852: PPUSH
37853: CALL_OW 1
37857: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37858: LD_ADDR_EXP 129
37862: PUSH
37863: LD_EXP 129
37867: PPUSH
37868: LD_VAR 0 2
37872: PPUSH
37873: EMPTY
37874: PPUSH
37875: CALL_OW 1
37879: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37880: LD_ADDR_EXP 128
37884: PUSH
37885: LD_EXP 128
37889: PPUSH
37890: LD_VAR 0 2
37894: PPUSH
37895: EMPTY
37896: PPUSH
37897: CALL_OW 1
37901: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37902: LD_ADDR_EXP 130
37906: PUSH
37907: LD_EXP 130
37911: PPUSH
37912: LD_VAR 0 2
37916: PPUSH
37917: EMPTY
37918: PPUSH
37919: CALL_OW 1
37923: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37924: LD_ADDR_EXP 131
37928: PUSH
37929: LD_EXP 131
37933: PPUSH
37934: LD_VAR 0 2
37938: PPUSH
37939: EMPTY
37940: PPUSH
37941: CALL_OW 1
37945: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37946: LD_ADDR_EXP 132
37950: PUSH
37951: LD_EXP 132
37955: PPUSH
37956: LD_VAR 0 2
37960: PPUSH
37961: EMPTY
37962: PPUSH
37963: CALL_OW 1
37967: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37968: LD_ADDR_EXP 133
37972: PUSH
37973: LD_EXP 133
37977: PPUSH
37978: LD_VAR 0 2
37982: PPUSH
37983: EMPTY
37984: PPUSH
37985: CALL_OW 1
37989: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37990: LD_ADDR_EXP 134
37994: PUSH
37995: LD_EXP 134
37999: PPUSH
38000: LD_VAR 0 2
38004: PPUSH
38005: EMPTY
38006: PPUSH
38007: CALL_OW 1
38011: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38012: LD_ADDR_EXP 135
38016: PUSH
38017: LD_EXP 135
38021: PPUSH
38022: LD_VAR 0 2
38026: PPUSH
38027: EMPTY
38028: PPUSH
38029: CALL_OW 1
38033: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
38034: LD_ADDR_EXP 136
38038: PUSH
38039: LD_EXP 136
38043: PPUSH
38044: LD_VAR 0 2
38048: PPUSH
38049: EMPTY
38050: PPUSH
38051: CALL_OW 1
38055: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38056: LD_ADDR_EXP 137
38060: PUSH
38061: LD_EXP 137
38065: PPUSH
38066: LD_VAR 0 2
38070: PPUSH
38071: EMPTY
38072: PPUSH
38073: CALL_OW 1
38077: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38078: LD_ADDR_EXP 126
38082: PUSH
38083: LD_EXP 126
38087: PPUSH
38088: LD_VAR 0 2
38092: PPUSH
38093: LD_INT 0
38095: PPUSH
38096: CALL_OW 1
38100: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38101: LD_ADDR_EXP 139
38105: PUSH
38106: LD_EXP 139
38110: PPUSH
38111: LD_VAR 0 2
38115: PPUSH
38116: LD_INT 0
38118: PPUSH
38119: CALL_OW 1
38123: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38124: LD_ADDR_EXP 127
38128: PUSH
38129: LD_EXP 127
38133: PPUSH
38134: LD_VAR 0 2
38138: PPUSH
38139: EMPTY
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38146: LD_ADDR_EXP 138
38150: PUSH
38151: LD_EXP 138
38155: PPUSH
38156: LD_VAR 0 2
38160: PPUSH
38161: LD_INT 0
38163: PPUSH
38164: CALL_OW 1
38168: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38169: LD_ADDR_EXP 140
38173: PUSH
38174: LD_EXP 140
38178: PPUSH
38179: LD_VAR 0 2
38183: PPUSH
38184: EMPTY
38185: PPUSH
38186: CALL_OW 1
38190: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38191: LD_ADDR_EXP 143
38195: PUSH
38196: LD_EXP 143
38200: PPUSH
38201: LD_VAR 0 2
38205: PPUSH
38206: LD_INT 0
38208: PPUSH
38209: CALL_OW 1
38213: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38214: LD_ADDR_EXP 144
38218: PUSH
38219: LD_EXP 144
38223: PPUSH
38224: LD_VAR 0 2
38228: PPUSH
38229: EMPTY
38230: PPUSH
38231: CALL_OW 1
38235: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38236: LD_ADDR_EXP 145
38240: PUSH
38241: LD_EXP 145
38245: PPUSH
38246: LD_VAR 0 2
38250: PPUSH
38251: EMPTY
38252: PPUSH
38253: CALL_OW 1
38257: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38258: LD_ADDR_EXP 146
38262: PUSH
38263: LD_EXP 146
38267: PPUSH
38268: LD_VAR 0 2
38272: PPUSH
38273: EMPTY
38274: PPUSH
38275: CALL_OW 1
38279: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38280: LD_ADDR_EXP 148
38284: PUSH
38285: LD_EXP 148
38289: PPUSH
38290: LD_VAR 0 2
38294: PPUSH
38295: LD_EXP 115
38299: PUSH
38300: LD_VAR 0 2
38304: ARRAY
38305: PPUSH
38306: LD_INT 2
38308: PUSH
38309: LD_INT 30
38311: PUSH
38312: LD_INT 6
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 30
38321: PUSH
38322: LD_INT 7
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 30
38331: PUSH
38332: LD_INT 8
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: PPUSH
38345: CALL_OW 72
38349: PPUSH
38350: CALL_OW 1
38354: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38355: LD_ADDR_EXP 149
38359: PUSH
38360: LD_EXP 149
38364: PPUSH
38365: LD_VAR 0 2
38369: PPUSH
38370: EMPTY
38371: PPUSH
38372: CALL_OW 1
38376: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38377: LD_ADDR_EXP 150
38381: PUSH
38382: LD_EXP 150
38386: PPUSH
38387: LD_VAR 0 2
38391: PPUSH
38392: EMPTY
38393: PPUSH
38394: CALL_OW 1
38398: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38399: LD_ADDR_EXP 151
38403: PUSH
38404: LD_EXP 151
38408: PPUSH
38409: LD_VAR 0 2
38413: PPUSH
38414: EMPTY
38415: PPUSH
38416: CALL_OW 1
38420: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38421: LD_ADDR_EXP 152
38425: PUSH
38426: LD_EXP 152
38430: PPUSH
38431: LD_VAR 0 2
38435: PPUSH
38436: EMPTY
38437: PPUSH
38438: CALL_OW 1
38442: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38443: LD_ADDR_EXP 153
38447: PUSH
38448: LD_EXP 153
38452: PPUSH
38453: LD_VAR 0 2
38457: PPUSH
38458: EMPTY
38459: PPUSH
38460: CALL_OW 1
38464: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38465: LD_ADDR_EXP 154
38469: PUSH
38470: LD_EXP 154
38474: PPUSH
38475: LD_VAR 0 2
38479: PPUSH
38480: EMPTY
38481: PPUSH
38482: CALL_OW 1
38486: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38487: LD_ADDR_EXP 155
38491: PUSH
38492: LD_EXP 155
38496: PPUSH
38497: LD_VAR 0 2
38501: PPUSH
38502: EMPTY
38503: PPUSH
38504: CALL_OW 1
38508: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38509: LD_ADDR_EXP 156
38513: PUSH
38514: LD_EXP 156
38518: PPUSH
38519: LD_VAR 0 2
38523: PPUSH
38524: EMPTY
38525: PPUSH
38526: CALL_OW 1
38530: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38531: LD_ADDR_EXP 157
38535: PUSH
38536: LD_EXP 157
38540: PPUSH
38541: LD_VAR 0 2
38545: PPUSH
38546: LD_INT 0
38548: PPUSH
38549: CALL_OW 1
38553: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38554: LD_ADDR_EXP 158
38558: PUSH
38559: LD_EXP 158
38563: PPUSH
38564: LD_VAR 0 2
38568: PPUSH
38569: LD_INT 0
38571: PPUSH
38572: CALL_OW 1
38576: ST_TO_ADDR
// end ;
38577: GO 37478
38579: POP
38580: POP
// MC_InitSides ( ) ;
38581: CALL 38867 0 0
// MC_InitResearch ( ) ;
38585: CALL 38606 0 0
// CustomInitMacro ( ) ;
38589: CALL 471 0 0
// skirmish := true ;
38593: LD_ADDR_EXP 113
38597: PUSH
38598: LD_INT 1
38600: ST_TO_ADDR
// end ;
38601: LD_VAR 0 1
38605: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38606: LD_INT 0
38608: PPUSH
38609: PPUSH
38610: PPUSH
38611: PPUSH
38612: PPUSH
38613: PPUSH
// if not mc_bases then
38614: LD_EXP 115
38618: NOT
38619: IFFALSE 38623
// exit ;
38621: GO 38862
// for i = 1 to 8 do
38623: LD_ADDR_VAR 0 2
38627: PUSH
38628: DOUBLE
38629: LD_INT 1
38631: DEC
38632: ST_TO_ADDR
38633: LD_INT 8
38635: PUSH
38636: FOR_TO
38637: IFFALSE 38663
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38639: LD_ADDR_EXP 142
38643: PUSH
38644: LD_EXP 142
38648: PPUSH
38649: LD_VAR 0 2
38653: PPUSH
38654: EMPTY
38655: PPUSH
38656: CALL_OW 1
38660: ST_TO_ADDR
38661: GO 38636
38663: POP
38664: POP
// tmp := [ ] ;
38665: LD_ADDR_VAR 0 5
38669: PUSH
38670: EMPTY
38671: ST_TO_ADDR
// for i = 1 to mc_sides do
38672: LD_ADDR_VAR 0 2
38676: PUSH
38677: DOUBLE
38678: LD_INT 1
38680: DEC
38681: ST_TO_ADDR
38682: LD_EXP 141
38686: PUSH
38687: FOR_TO
38688: IFFALSE 38746
// if not mc_sides [ i ] in tmp then
38690: LD_EXP 141
38694: PUSH
38695: LD_VAR 0 2
38699: ARRAY
38700: PUSH
38701: LD_VAR 0 5
38705: IN
38706: NOT
38707: IFFALSE 38744
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38709: LD_ADDR_VAR 0 5
38713: PUSH
38714: LD_VAR 0 5
38718: PPUSH
38719: LD_VAR 0 5
38723: PUSH
38724: LD_INT 1
38726: PLUS
38727: PPUSH
38728: LD_EXP 141
38732: PUSH
38733: LD_VAR 0 2
38737: ARRAY
38738: PPUSH
38739: CALL_OW 2
38743: ST_TO_ADDR
38744: GO 38687
38746: POP
38747: POP
// if not tmp then
38748: LD_VAR 0 5
38752: NOT
38753: IFFALSE 38757
// exit ;
38755: GO 38862
// for j in tmp do
38757: LD_ADDR_VAR 0 3
38761: PUSH
38762: LD_VAR 0 5
38766: PUSH
38767: FOR_IN
38768: IFFALSE 38860
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38770: LD_ADDR_VAR 0 6
38774: PUSH
38775: LD_INT 22
38777: PUSH
38778: LD_VAR 0 3
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PPUSH
38787: CALL_OW 69
38791: ST_TO_ADDR
// if not un then
38792: LD_VAR 0 6
38796: NOT
38797: IFFALSE 38801
// continue ;
38799: GO 38767
// nation := GetNation ( un [ 1 ] ) ;
38801: LD_ADDR_VAR 0 4
38805: PUSH
38806: LD_VAR 0 6
38810: PUSH
38811: LD_INT 1
38813: ARRAY
38814: PPUSH
38815: CALL_OW 248
38819: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38820: LD_ADDR_EXP 142
38824: PUSH
38825: LD_EXP 142
38829: PPUSH
38830: LD_VAR 0 3
38834: PPUSH
38835: LD_VAR 0 3
38839: PPUSH
38840: LD_VAR 0 4
38844: PPUSH
38845: LD_INT 1
38847: PPUSH
38848: CALL 65983 0 3
38852: PPUSH
38853: CALL_OW 1
38857: ST_TO_ADDR
// end ;
38858: GO 38767
38860: POP
38861: POP
// end ;
38862: LD_VAR 0 1
38866: RET
// export function MC_InitSides ( ) ; var i ; begin
38867: LD_INT 0
38869: PPUSH
38870: PPUSH
// if not mc_bases then
38871: LD_EXP 115
38875: NOT
38876: IFFALSE 38880
// exit ;
38878: GO 38954
// for i = 1 to mc_bases do
38880: LD_ADDR_VAR 0 2
38884: PUSH
38885: DOUBLE
38886: LD_INT 1
38888: DEC
38889: ST_TO_ADDR
38890: LD_EXP 115
38894: PUSH
38895: FOR_TO
38896: IFFALSE 38952
// if mc_bases [ i ] then
38898: LD_EXP 115
38902: PUSH
38903: LD_VAR 0 2
38907: ARRAY
38908: IFFALSE 38950
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38910: LD_ADDR_EXP 141
38914: PUSH
38915: LD_EXP 141
38919: PPUSH
38920: LD_VAR 0 2
38924: PPUSH
38925: LD_EXP 115
38929: PUSH
38930: LD_VAR 0 2
38934: ARRAY
38935: PUSH
38936: LD_INT 1
38938: ARRAY
38939: PPUSH
38940: CALL_OW 255
38944: PPUSH
38945: CALL_OW 1
38949: ST_TO_ADDR
38950: GO 38895
38952: POP
38953: POP
// end ;
38954: LD_VAR 0 1
38958: RET
// every 0 0$03 trigger skirmish do
38959: LD_EXP 113
38963: IFFALSE 39117
38965: GO 38967
38967: DISABLE
// begin enable ;
38968: ENABLE
// MC_CheckBuildings ( ) ;
38969: CALL 43615 0 0
// MC_CheckPeopleLife ( ) ;
38973: CALL 43776 0 0
// RaiseSailEvent ( 100 ) ;
38977: LD_INT 100
38979: PPUSH
38980: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38984: LD_INT 103
38986: PPUSH
38987: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38991: LD_INT 104
38993: PPUSH
38994: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38998: LD_INT 105
39000: PPUSH
39001: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
39005: LD_INT 106
39007: PPUSH
39008: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
39012: LD_INT 107
39014: PPUSH
39015: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
39019: LD_INT 108
39021: PPUSH
39022: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
39026: LD_INT 109
39028: PPUSH
39029: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
39033: LD_INT 110
39035: PPUSH
39036: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
39040: LD_INT 111
39042: PPUSH
39043: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39047: LD_INT 112
39049: PPUSH
39050: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39054: LD_INT 113
39056: PPUSH
39057: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39061: LD_INT 120
39063: PPUSH
39064: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39068: LD_INT 121
39070: PPUSH
39071: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39075: LD_INT 122
39077: PPUSH
39078: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39082: LD_INT 123
39084: PPUSH
39085: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39089: LD_INT 124
39091: PPUSH
39092: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39096: LD_INT 125
39098: PPUSH
39099: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39103: LD_INT 126
39105: PPUSH
39106: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39110: LD_INT 200
39112: PPUSH
39113: CALL_OW 427
// end ;
39117: END
// on SailEvent ( event ) do begin if event < 100 then
39118: LD_VAR 0 1
39122: PUSH
39123: LD_INT 100
39125: LESS
39126: IFFALSE 39137
// CustomEvent ( event ) ;
39128: LD_VAR 0 1
39132: PPUSH
39133: CALL 33578 0 1
// if event = 100 then
39137: LD_VAR 0 1
39141: PUSH
39142: LD_INT 100
39144: EQUAL
39145: IFFALSE 39151
// MC_ClassManager ( ) ;
39147: CALL 39543 0 0
// if event = 101 then
39151: LD_VAR 0 1
39155: PUSH
39156: LD_INT 101
39158: EQUAL
39159: IFFALSE 39165
// MC_RepairBuildings ( ) ;
39161: CALL 44361 0 0
// if event = 102 then
39165: LD_VAR 0 1
39169: PUSH
39170: LD_INT 102
39172: EQUAL
39173: IFFALSE 39179
// MC_Heal ( ) ;
39175: CALL 45268 0 0
// if event = 103 then
39179: LD_VAR 0 1
39183: PUSH
39184: LD_INT 103
39186: EQUAL
39187: IFFALSE 39193
// MC_Build ( ) ;
39189: CALL 45690 0 0
// if event = 104 then
39193: LD_VAR 0 1
39197: PUSH
39198: LD_INT 104
39200: EQUAL
39201: IFFALSE 39207
// MC_TurretWeapon ( ) ;
39203: CALL 47331 0 0
// if event = 105 then
39207: LD_VAR 0 1
39211: PUSH
39212: LD_INT 105
39214: EQUAL
39215: IFFALSE 39221
// MC_BuildUpgrade ( ) ;
39217: CALL 46882 0 0
// if event = 106 then
39221: LD_VAR 0 1
39225: PUSH
39226: LD_INT 106
39228: EQUAL
39229: IFFALSE 39235
// MC_PlantMines ( ) ;
39231: CALL 47761 0 0
// if event = 107 then
39235: LD_VAR 0 1
39239: PUSH
39240: LD_INT 107
39242: EQUAL
39243: IFFALSE 39249
// MC_CollectCrates ( ) ;
39245: CALL 48552 0 0
// if event = 108 then
39249: LD_VAR 0 1
39253: PUSH
39254: LD_INT 108
39256: EQUAL
39257: IFFALSE 39263
// MC_LinkRemoteControl ( ) ;
39259: CALL 50402 0 0
// if event = 109 then
39263: LD_VAR 0 1
39267: PUSH
39268: LD_INT 109
39270: EQUAL
39271: IFFALSE 39277
// MC_ProduceVehicle ( ) ;
39273: CALL 50583 0 0
// if event = 110 then
39277: LD_VAR 0 1
39281: PUSH
39282: LD_INT 110
39284: EQUAL
39285: IFFALSE 39291
// MC_SendAttack ( ) ;
39287: CALL 51049 0 0
// if event = 111 then
39291: LD_VAR 0 1
39295: PUSH
39296: LD_INT 111
39298: EQUAL
39299: IFFALSE 39305
// MC_Defend ( ) ;
39301: CALL 51157 0 0
// if event = 112 then
39305: LD_VAR 0 1
39309: PUSH
39310: LD_INT 112
39312: EQUAL
39313: IFFALSE 39319
// MC_Research ( ) ;
39315: CALL 52037 0 0
// if event = 113 then
39319: LD_VAR 0 1
39323: PUSH
39324: LD_INT 113
39326: EQUAL
39327: IFFALSE 39333
// MC_MinesTrigger ( ) ;
39329: CALL 53151 0 0
// if event = 120 then
39333: LD_VAR 0 1
39337: PUSH
39338: LD_INT 120
39340: EQUAL
39341: IFFALSE 39347
// MC_RepairVehicle ( ) ;
39343: CALL 53250 0 0
// if event = 121 then
39347: LD_VAR 0 1
39351: PUSH
39352: LD_INT 121
39354: EQUAL
39355: IFFALSE 39361
// MC_TameApe ( ) ;
39357: CALL 53991 0 0
// if event = 122 then
39361: LD_VAR 0 1
39365: PUSH
39366: LD_INT 122
39368: EQUAL
39369: IFFALSE 39375
// MC_ChangeApeClass ( ) ;
39371: CALL 54820 0 0
// if event = 123 then
39375: LD_VAR 0 1
39379: PUSH
39380: LD_INT 123
39382: EQUAL
39383: IFFALSE 39389
// MC_Bazooka ( ) ;
39385: CALL 55470 0 0
// if event = 124 then
39389: LD_VAR 0 1
39393: PUSH
39394: LD_INT 124
39396: EQUAL
39397: IFFALSE 39403
// MC_TeleportExit ( ) ;
39399: CALL 55668 0 0
// if event = 125 then
39403: LD_VAR 0 1
39407: PUSH
39408: LD_INT 125
39410: EQUAL
39411: IFFALSE 39417
// MC_Deposits ( ) ;
39413: CALL 56315 0 0
// if event = 126 then
39417: LD_VAR 0 1
39421: PUSH
39422: LD_INT 126
39424: EQUAL
39425: IFFALSE 39431
// MC_RemoteDriver ( ) ;
39427: CALL 56940 0 0
// if event = 200 then
39431: LD_VAR 0 1
39435: PUSH
39436: LD_INT 200
39438: EQUAL
39439: IFFALSE 39445
// MC_Idle ( ) ;
39441: CALL 58889 0 0
// end ;
39445: PPOPN 1
39447: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39448: LD_INT 0
39450: PPUSH
39451: PPUSH
// if not mc_bases [ base ] or not tag then
39452: LD_EXP 115
39456: PUSH
39457: LD_VAR 0 1
39461: ARRAY
39462: NOT
39463: PUSH
39464: LD_VAR 0 2
39468: NOT
39469: OR
39470: IFFALSE 39474
// exit ;
39472: GO 39538
// for i in mc_bases [ base ] union mc_ape [ base ] do
39474: LD_ADDR_VAR 0 4
39478: PUSH
39479: LD_EXP 115
39483: PUSH
39484: LD_VAR 0 1
39488: ARRAY
39489: PUSH
39490: LD_EXP 144
39494: PUSH
39495: LD_VAR 0 1
39499: ARRAY
39500: UNION
39501: PUSH
39502: FOR_IN
39503: IFFALSE 39536
// if GetTag ( i ) = tag then
39505: LD_VAR 0 4
39509: PPUSH
39510: CALL_OW 110
39514: PUSH
39515: LD_VAR 0 2
39519: EQUAL
39520: IFFALSE 39534
// SetTag ( i , 0 ) ;
39522: LD_VAR 0 4
39526: PPUSH
39527: LD_INT 0
39529: PPUSH
39530: CALL_OW 109
39534: GO 39502
39536: POP
39537: POP
// end ;
39538: LD_VAR 0 3
39542: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39543: LD_INT 0
39545: PPUSH
39546: PPUSH
39547: PPUSH
39548: PPUSH
39549: PPUSH
39550: PPUSH
39551: PPUSH
39552: PPUSH
// if not mc_bases then
39553: LD_EXP 115
39557: NOT
39558: IFFALSE 39562
// exit ;
39560: GO 40020
// for i = 1 to mc_bases do
39562: LD_ADDR_VAR 0 2
39566: PUSH
39567: DOUBLE
39568: LD_INT 1
39570: DEC
39571: ST_TO_ADDR
39572: LD_EXP 115
39576: PUSH
39577: FOR_TO
39578: IFFALSE 40018
// begin tmp := MC_ClassCheckReq ( i ) ;
39580: LD_ADDR_VAR 0 4
39584: PUSH
39585: LD_VAR 0 2
39589: PPUSH
39590: CALL 40025 0 1
39594: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39595: LD_ADDR_EXP 156
39599: PUSH
39600: LD_EXP 156
39604: PPUSH
39605: LD_VAR 0 2
39609: PPUSH
39610: LD_VAR 0 4
39614: PPUSH
39615: CALL_OW 1
39619: ST_TO_ADDR
// if not tmp then
39620: LD_VAR 0 4
39624: NOT
39625: IFFALSE 39629
// continue ;
39627: GO 39577
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39629: LD_ADDR_VAR 0 6
39633: PUSH
39634: LD_EXP 115
39638: PUSH
39639: LD_VAR 0 2
39643: ARRAY
39644: PPUSH
39645: LD_INT 2
39647: PUSH
39648: LD_INT 30
39650: PUSH
39651: LD_INT 4
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 30
39660: PUSH
39661: LD_INT 5
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: LIST
39672: PPUSH
39673: CALL_OW 72
39677: PUSH
39678: LD_EXP 115
39682: PUSH
39683: LD_VAR 0 2
39687: ARRAY
39688: PPUSH
39689: LD_INT 2
39691: PUSH
39692: LD_INT 30
39694: PUSH
39695: LD_INT 0
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 30
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: LIST
39716: PPUSH
39717: CALL_OW 72
39721: PUSH
39722: LD_EXP 115
39726: PUSH
39727: LD_VAR 0 2
39731: ARRAY
39732: PPUSH
39733: LD_INT 30
39735: PUSH
39736: LD_INT 3
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PPUSH
39743: CALL_OW 72
39747: PUSH
39748: LD_EXP 115
39752: PUSH
39753: LD_VAR 0 2
39757: ARRAY
39758: PPUSH
39759: LD_INT 2
39761: PUSH
39762: LD_INT 30
39764: PUSH
39765: LD_INT 6
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: PUSH
39772: LD_INT 30
39774: PUSH
39775: LD_INT 7
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 30
39784: PUSH
39785: LD_INT 8
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: PPUSH
39798: CALL_OW 72
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: ST_TO_ADDR
// for j = 1 to 4 do
39809: LD_ADDR_VAR 0 3
39813: PUSH
39814: DOUBLE
39815: LD_INT 1
39817: DEC
39818: ST_TO_ADDR
39819: LD_INT 4
39821: PUSH
39822: FOR_TO
39823: IFFALSE 40014
// begin if not tmp [ j ] then
39825: LD_VAR 0 4
39829: PUSH
39830: LD_VAR 0 3
39834: ARRAY
39835: NOT
39836: IFFALSE 39840
// continue ;
39838: GO 39822
// for p in tmp [ j ] do
39840: LD_ADDR_VAR 0 5
39844: PUSH
39845: LD_VAR 0 4
39849: PUSH
39850: LD_VAR 0 3
39854: ARRAY
39855: PUSH
39856: FOR_IN
39857: IFFALSE 40010
// begin if not b [ j ] then
39859: LD_VAR 0 6
39863: PUSH
39864: LD_VAR 0 3
39868: ARRAY
39869: NOT
39870: IFFALSE 39874
// break ;
39872: GO 40010
// e := 0 ;
39874: LD_ADDR_VAR 0 7
39878: PUSH
39879: LD_INT 0
39881: ST_TO_ADDR
// for k in b [ j ] do
39882: LD_ADDR_VAR 0 8
39886: PUSH
39887: LD_VAR 0 6
39891: PUSH
39892: LD_VAR 0 3
39896: ARRAY
39897: PUSH
39898: FOR_IN
39899: IFFALSE 39926
// if IsNotFull ( k ) then
39901: LD_VAR 0 8
39905: PPUSH
39906: CALL 68136 0 1
39910: IFFALSE 39924
// begin e := k ;
39912: LD_ADDR_VAR 0 7
39916: PUSH
39917: LD_VAR 0 8
39921: ST_TO_ADDR
// break ;
39922: GO 39926
// end ;
39924: GO 39898
39926: POP
39927: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39928: LD_VAR 0 7
39932: PUSH
39933: LD_VAR 0 5
39937: PPUSH
39938: LD_VAR 0 7
39942: PPUSH
39943: CALL 101967 0 2
39947: NOT
39948: AND
39949: IFFALSE 40008
// begin if IsInUnit ( p ) then
39951: LD_VAR 0 5
39955: PPUSH
39956: CALL_OW 310
39960: IFFALSE 39971
// ComExitBuilding ( p ) ;
39962: LD_VAR 0 5
39966: PPUSH
39967: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39971: LD_VAR 0 5
39975: PPUSH
39976: LD_VAR 0 7
39980: PPUSH
39981: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39985: LD_VAR 0 5
39989: PPUSH
39990: LD_VAR 0 3
39994: PPUSH
39995: CALL_OW 183
// AddComExitBuilding ( p ) ;
39999: LD_VAR 0 5
40003: PPUSH
40004: CALL_OW 182
// end ; end ;
40008: GO 39856
40010: POP
40011: POP
// end ;
40012: GO 39822
40014: POP
40015: POP
// end ;
40016: GO 39577
40018: POP
40019: POP
// end ;
40020: LD_VAR 0 1
40024: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
40025: LD_INT 0
40027: PPUSH
40028: PPUSH
40029: PPUSH
40030: PPUSH
40031: PPUSH
40032: PPUSH
40033: PPUSH
40034: PPUSH
40035: PPUSH
40036: PPUSH
40037: PPUSH
40038: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40039: LD_VAR 0 1
40043: NOT
40044: PUSH
40045: LD_EXP 115
40049: PUSH
40050: LD_VAR 0 1
40054: ARRAY
40055: NOT
40056: OR
40057: PUSH
40058: LD_EXP 115
40062: PUSH
40063: LD_VAR 0 1
40067: ARRAY
40068: PPUSH
40069: LD_INT 2
40071: PUSH
40072: LD_INT 30
40074: PUSH
40075: LD_INT 0
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 30
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: LIST
40096: PPUSH
40097: CALL_OW 72
40101: NOT
40102: OR
40103: IFFALSE 40107
// exit ;
40105: GO 43610
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40107: LD_ADDR_VAR 0 4
40111: PUSH
40112: LD_EXP 115
40116: PUSH
40117: LD_VAR 0 1
40121: ARRAY
40122: PPUSH
40123: LD_INT 2
40125: PUSH
40126: LD_INT 25
40128: PUSH
40129: LD_INT 1
40131: PUSH
40132: EMPTY
40133: LIST
40134: LIST
40135: PUSH
40136: LD_INT 25
40138: PUSH
40139: LD_INT 2
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 25
40148: PUSH
40149: LD_INT 3
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 25
40158: PUSH
40159: LD_INT 4
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 25
40168: PUSH
40169: LD_INT 5
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 25
40178: PUSH
40179: LD_INT 8
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 25
40188: PUSH
40189: LD_INT 9
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: PPUSH
40206: CALL_OW 72
40210: ST_TO_ADDR
// if not tmp then
40211: LD_VAR 0 4
40215: NOT
40216: IFFALSE 40220
// exit ;
40218: GO 43610
// for i in tmp do
40220: LD_ADDR_VAR 0 3
40224: PUSH
40225: LD_VAR 0 4
40229: PUSH
40230: FOR_IN
40231: IFFALSE 40262
// if GetTag ( i ) then
40233: LD_VAR 0 3
40237: PPUSH
40238: CALL_OW 110
40242: IFFALSE 40260
// tmp := tmp diff i ;
40244: LD_ADDR_VAR 0 4
40248: PUSH
40249: LD_VAR 0 4
40253: PUSH
40254: LD_VAR 0 3
40258: DIFF
40259: ST_TO_ADDR
40260: GO 40230
40262: POP
40263: POP
// if not tmp then
40264: LD_VAR 0 4
40268: NOT
40269: IFFALSE 40273
// exit ;
40271: GO 43610
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40273: LD_ADDR_VAR 0 5
40277: PUSH
40278: LD_EXP 115
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PPUSH
40289: LD_INT 2
40291: PUSH
40292: LD_INT 25
40294: PUSH
40295: LD_INT 1
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 25
40304: PUSH
40305: LD_INT 5
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 25
40314: PUSH
40315: LD_INT 8
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 25
40324: PUSH
40325: LD_INT 9
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: PPUSH
40339: CALL_OW 72
40343: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40344: LD_ADDR_VAR 0 6
40348: PUSH
40349: LD_EXP 115
40353: PUSH
40354: LD_VAR 0 1
40358: ARRAY
40359: PPUSH
40360: LD_INT 25
40362: PUSH
40363: LD_INT 2
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PPUSH
40370: CALL_OW 72
40374: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40375: LD_ADDR_VAR 0 7
40379: PUSH
40380: LD_EXP 115
40384: PUSH
40385: LD_VAR 0 1
40389: ARRAY
40390: PPUSH
40391: LD_INT 25
40393: PUSH
40394: LD_INT 3
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PPUSH
40401: CALL_OW 72
40405: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40406: LD_ADDR_VAR 0 8
40410: PUSH
40411: LD_EXP 115
40415: PUSH
40416: LD_VAR 0 1
40420: ARRAY
40421: PPUSH
40422: LD_INT 25
40424: PUSH
40425: LD_INT 4
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 24
40434: PUSH
40435: LD_INT 251
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PPUSH
40446: CALL_OW 72
40450: ST_TO_ADDR
// if mc_is_defending [ base ] then
40451: LD_EXP 158
40455: PUSH
40456: LD_VAR 0 1
40460: ARRAY
40461: IFFALSE 40922
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40463: LD_ADDR_EXP 157
40467: PUSH
40468: LD_EXP 157
40472: PPUSH
40473: LD_VAR 0 1
40477: PPUSH
40478: LD_INT 4
40480: PPUSH
40481: CALL_OW 1
40485: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40486: LD_ADDR_VAR 0 12
40490: PUSH
40491: LD_EXP 115
40495: PUSH
40496: LD_VAR 0 1
40500: ARRAY
40501: PPUSH
40502: LD_INT 2
40504: PUSH
40505: LD_INT 30
40507: PUSH
40508: LD_INT 4
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 30
40517: PUSH
40518: LD_INT 5
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: LIST
40529: PPUSH
40530: CALL_OW 72
40534: ST_TO_ADDR
// if not b then
40535: LD_VAR 0 12
40539: NOT
40540: IFFALSE 40544
// exit ;
40542: GO 43610
// p := [ ] ;
40544: LD_ADDR_VAR 0 11
40548: PUSH
40549: EMPTY
40550: ST_TO_ADDR
// if sci >= 2 then
40551: LD_VAR 0 8
40555: PUSH
40556: LD_INT 2
40558: GREATEREQUAL
40559: IFFALSE 40590
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40561: LD_ADDR_VAR 0 8
40565: PUSH
40566: LD_VAR 0 8
40570: PUSH
40571: LD_INT 1
40573: ARRAY
40574: PUSH
40575: LD_VAR 0 8
40579: PUSH
40580: LD_INT 2
40582: ARRAY
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: ST_TO_ADDR
40588: GO 40651
// if sci = 1 then
40590: LD_VAR 0 8
40594: PUSH
40595: LD_INT 1
40597: EQUAL
40598: IFFALSE 40619
// sci := [ sci [ 1 ] ] else
40600: LD_ADDR_VAR 0 8
40604: PUSH
40605: LD_VAR 0 8
40609: PUSH
40610: LD_INT 1
40612: ARRAY
40613: PUSH
40614: EMPTY
40615: LIST
40616: ST_TO_ADDR
40617: GO 40651
// if sci = 0 then
40619: LD_VAR 0 8
40623: PUSH
40624: LD_INT 0
40626: EQUAL
40627: IFFALSE 40651
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40629: LD_ADDR_VAR 0 11
40633: PUSH
40634: LD_VAR 0 4
40638: PPUSH
40639: LD_INT 4
40641: PPUSH
40642: CALL 101830 0 2
40646: PUSH
40647: LD_INT 1
40649: ARRAY
40650: ST_TO_ADDR
// if eng > 4 then
40651: LD_VAR 0 6
40655: PUSH
40656: LD_INT 4
40658: GREATER
40659: IFFALSE 40705
// for i = eng downto 4 do
40661: LD_ADDR_VAR 0 3
40665: PUSH
40666: DOUBLE
40667: LD_VAR 0 6
40671: INC
40672: ST_TO_ADDR
40673: LD_INT 4
40675: PUSH
40676: FOR_DOWNTO
40677: IFFALSE 40703
// eng := eng diff eng [ i ] ;
40679: LD_ADDR_VAR 0 6
40683: PUSH
40684: LD_VAR 0 6
40688: PUSH
40689: LD_VAR 0 6
40693: PUSH
40694: LD_VAR 0 3
40698: ARRAY
40699: DIFF
40700: ST_TO_ADDR
40701: GO 40676
40703: POP
40704: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40705: LD_ADDR_VAR 0 4
40709: PUSH
40710: LD_VAR 0 4
40714: PUSH
40715: LD_VAR 0 5
40719: PUSH
40720: LD_VAR 0 6
40724: UNION
40725: PUSH
40726: LD_VAR 0 7
40730: UNION
40731: PUSH
40732: LD_VAR 0 8
40736: UNION
40737: DIFF
40738: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40739: LD_ADDR_VAR 0 13
40743: PUSH
40744: LD_EXP 115
40748: PUSH
40749: LD_VAR 0 1
40753: ARRAY
40754: PPUSH
40755: LD_INT 2
40757: PUSH
40758: LD_INT 30
40760: PUSH
40761: LD_INT 32
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 30
40770: PUSH
40771: LD_INT 31
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: LIST
40782: PPUSH
40783: CALL_OW 72
40787: PUSH
40788: LD_EXP 115
40792: PUSH
40793: LD_VAR 0 1
40797: ARRAY
40798: PPUSH
40799: LD_INT 2
40801: PUSH
40802: LD_INT 30
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 30
40814: PUSH
40815: LD_INT 5
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: LIST
40826: PPUSH
40827: CALL_OW 72
40831: PUSH
40832: LD_INT 6
40834: MUL
40835: PLUS
40836: ST_TO_ADDR
// if bcount < tmp then
40837: LD_VAR 0 13
40841: PUSH
40842: LD_VAR 0 4
40846: LESS
40847: IFFALSE 40893
// for i = tmp downto bcount do
40849: LD_ADDR_VAR 0 3
40853: PUSH
40854: DOUBLE
40855: LD_VAR 0 4
40859: INC
40860: ST_TO_ADDR
40861: LD_VAR 0 13
40865: PUSH
40866: FOR_DOWNTO
40867: IFFALSE 40891
// tmp := Delete ( tmp , tmp ) ;
40869: LD_ADDR_VAR 0 4
40873: PUSH
40874: LD_VAR 0 4
40878: PPUSH
40879: LD_VAR 0 4
40883: PPUSH
40884: CALL_OW 3
40888: ST_TO_ADDR
40889: GO 40866
40891: POP
40892: POP
// result := [ tmp , 0 , 0 , p ] ;
40893: LD_ADDR_VAR 0 2
40897: PUSH
40898: LD_VAR 0 4
40902: PUSH
40903: LD_INT 0
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: LD_VAR 0 11
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: ST_TO_ADDR
// exit ;
40920: GO 43610
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40922: LD_EXP 115
40926: PUSH
40927: LD_VAR 0 1
40931: ARRAY
40932: PPUSH
40933: LD_INT 2
40935: PUSH
40936: LD_INT 30
40938: PUSH
40939: LD_INT 6
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 30
40948: PUSH
40949: LD_INT 7
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: LD_INT 30
40958: PUSH
40959: LD_INT 8
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL_OW 72
40976: NOT
40977: PUSH
40978: LD_EXP 115
40982: PUSH
40983: LD_VAR 0 1
40987: ARRAY
40988: PPUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 3
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL_OW 72
41003: NOT
41004: AND
41005: IFFALSE 41077
// begin if eng = tmp then
41007: LD_VAR 0 6
41011: PUSH
41012: LD_VAR 0 4
41016: EQUAL
41017: IFFALSE 41021
// exit ;
41019: GO 43610
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
41021: LD_ADDR_EXP 157
41025: PUSH
41026: LD_EXP 157
41030: PPUSH
41031: LD_VAR 0 1
41035: PPUSH
41036: LD_INT 1
41038: PPUSH
41039: CALL_OW 1
41043: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41044: LD_ADDR_VAR 0 2
41048: PUSH
41049: LD_INT 0
41051: PUSH
41052: LD_VAR 0 4
41056: PUSH
41057: LD_VAR 0 6
41061: DIFF
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: LD_INT 0
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// exit ;
41075: GO 43610
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41077: LD_EXP 142
41081: PUSH
41082: LD_EXP 141
41086: PUSH
41087: LD_VAR 0 1
41091: ARRAY
41092: ARRAY
41093: PUSH
41094: LD_EXP 115
41098: PUSH
41099: LD_VAR 0 1
41103: ARRAY
41104: PPUSH
41105: LD_INT 2
41107: PUSH
41108: LD_INT 30
41110: PUSH
41111: LD_INT 6
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 30
41120: PUSH
41121: LD_INT 7
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 30
41130: PUSH
41131: LD_INT 8
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: PPUSH
41144: CALL_OW 72
41148: AND
41149: PUSH
41150: LD_EXP 115
41154: PUSH
41155: LD_VAR 0 1
41159: ARRAY
41160: PPUSH
41161: LD_INT 30
41163: PUSH
41164: LD_INT 3
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PPUSH
41171: CALL_OW 72
41175: NOT
41176: AND
41177: IFFALSE 41391
// begin if sci >= 6 then
41179: LD_VAR 0 8
41183: PUSH
41184: LD_INT 6
41186: GREATEREQUAL
41187: IFFALSE 41191
// exit ;
41189: GO 43610
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41191: LD_ADDR_EXP 157
41195: PUSH
41196: LD_EXP 157
41200: PPUSH
41201: LD_VAR 0 1
41205: PPUSH
41206: LD_INT 2
41208: PPUSH
41209: CALL_OW 1
41213: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41214: LD_ADDR_VAR 0 9
41218: PUSH
41219: LD_VAR 0 4
41223: PUSH
41224: LD_VAR 0 8
41228: DIFF
41229: PPUSH
41230: LD_INT 4
41232: PPUSH
41233: CALL 101830 0 2
41237: ST_TO_ADDR
// p := [ ] ;
41238: LD_ADDR_VAR 0 11
41242: PUSH
41243: EMPTY
41244: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41245: LD_VAR 0 8
41249: PUSH
41250: LD_INT 6
41252: LESS
41253: PUSH
41254: LD_VAR 0 9
41258: PUSH
41259: LD_INT 6
41261: GREATER
41262: AND
41263: IFFALSE 41344
// begin for i = 1 to 6 - sci do
41265: LD_ADDR_VAR 0 3
41269: PUSH
41270: DOUBLE
41271: LD_INT 1
41273: DEC
41274: ST_TO_ADDR
41275: LD_INT 6
41277: PUSH
41278: LD_VAR 0 8
41282: MINUS
41283: PUSH
41284: FOR_TO
41285: IFFALSE 41340
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41287: LD_ADDR_VAR 0 11
41291: PUSH
41292: LD_VAR 0 11
41296: PPUSH
41297: LD_VAR 0 11
41301: PUSH
41302: LD_INT 1
41304: PLUS
41305: PPUSH
41306: LD_VAR 0 9
41310: PUSH
41311: LD_INT 1
41313: ARRAY
41314: PPUSH
41315: CALL_OW 2
41319: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41320: LD_ADDR_VAR 0 9
41324: PUSH
41325: LD_VAR 0 9
41329: PPUSH
41330: LD_INT 1
41332: PPUSH
41333: CALL_OW 3
41337: ST_TO_ADDR
// end ;
41338: GO 41284
41340: POP
41341: POP
// end else
41342: GO 41364
// if sort then
41344: LD_VAR 0 9
41348: IFFALSE 41364
// p := sort [ 1 ] ;
41350: LD_ADDR_VAR 0 11
41354: PUSH
41355: LD_VAR 0 9
41359: PUSH
41360: LD_INT 1
41362: ARRAY
41363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41364: LD_ADDR_VAR 0 2
41368: PUSH
41369: LD_INT 0
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: LD_INT 0
41377: PUSH
41378: LD_VAR 0 11
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: ST_TO_ADDR
// exit ;
41389: GO 43610
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41391: LD_EXP 142
41395: PUSH
41396: LD_EXP 141
41400: PUSH
41401: LD_VAR 0 1
41405: ARRAY
41406: ARRAY
41407: PUSH
41408: LD_EXP 115
41412: PUSH
41413: LD_VAR 0 1
41417: ARRAY
41418: PPUSH
41419: LD_INT 2
41421: PUSH
41422: LD_INT 30
41424: PUSH
41425: LD_INT 6
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 30
41434: PUSH
41435: LD_INT 7
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 30
41444: PUSH
41445: LD_INT 8
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: PPUSH
41458: CALL_OW 72
41462: AND
41463: PUSH
41464: LD_EXP 115
41468: PUSH
41469: LD_VAR 0 1
41473: ARRAY
41474: PPUSH
41475: LD_INT 30
41477: PUSH
41478: LD_INT 3
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PPUSH
41485: CALL_OW 72
41489: AND
41490: IFFALSE 42224
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41492: LD_ADDR_EXP 157
41496: PUSH
41497: LD_EXP 157
41501: PPUSH
41502: LD_VAR 0 1
41506: PPUSH
41507: LD_INT 3
41509: PPUSH
41510: CALL_OW 1
41514: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41515: LD_ADDR_VAR 0 2
41519: PUSH
41520: LD_INT 0
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: LD_INT 0
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: ST_TO_ADDR
// if not eng then
41538: LD_VAR 0 6
41542: NOT
41543: IFFALSE 41606
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41545: LD_ADDR_VAR 0 11
41549: PUSH
41550: LD_VAR 0 4
41554: PPUSH
41555: LD_INT 2
41557: PPUSH
41558: CALL 101830 0 2
41562: PUSH
41563: LD_INT 1
41565: ARRAY
41566: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41567: LD_ADDR_VAR 0 2
41571: PUSH
41572: LD_VAR 0 2
41576: PPUSH
41577: LD_INT 2
41579: PPUSH
41580: LD_VAR 0 11
41584: PPUSH
41585: CALL_OW 1
41589: ST_TO_ADDR
// tmp := tmp diff p ;
41590: LD_ADDR_VAR 0 4
41594: PUSH
41595: LD_VAR 0 4
41599: PUSH
41600: LD_VAR 0 11
41604: DIFF
41605: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41606: LD_VAR 0 4
41610: PUSH
41611: LD_VAR 0 8
41615: PUSH
41616: LD_INT 6
41618: LESS
41619: AND
41620: IFFALSE 41808
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41622: LD_ADDR_VAR 0 9
41626: PUSH
41627: LD_VAR 0 4
41631: PUSH
41632: LD_VAR 0 8
41636: PUSH
41637: LD_VAR 0 7
41641: UNION
41642: DIFF
41643: PPUSH
41644: LD_INT 4
41646: PPUSH
41647: CALL 101830 0 2
41651: ST_TO_ADDR
// p := [ ] ;
41652: LD_ADDR_VAR 0 11
41656: PUSH
41657: EMPTY
41658: ST_TO_ADDR
// if sort then
41659: LD_VAR 0 9
41663: IFFALSE 41779
// for i = 1 to 6 - sci do
41665: LD_ADDR_VAR 0 3
41669: PUSH
41670: DOUBLE
41671: LD_INT 1
41673: DEC
41674: ST_TO_ADDR
41675: LD_INT 6
41677: PUSH
41678: LD_VAR 0 8
41682: MINUS
41683: PUSH
41684: FOR_TO
41685: IFFALSE 41777
// begin if i = sort then
41687: LD_VAR 0 3
41691: PUSH
41692: LD_VAR 0 9
41696: EQUAL
41697: IFFALSE 41701
// break ;
41699: GO 41777
// if GetClass ( i ) = 4 then
41701: LD_VAR 0 3
41705: PPUSH
41706: CALL_OW 257
41710: PUSH
41711: LD_INT 4
41713: EQUAL
41714: IFFALSE 41718
// continue ;
41716: GO 41684
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41718: LD_ADDR_VAR 0 11
41722: PUSH
41723: LD_VAR 0 11
41727: PPUSH
41728: LD_VAR 0 11
41732: PUSH
41733: LD_INT 1
41735: PLUS
41736: PPUSH
41737: LD_VAR 0 9
41741: PUSH
41742: LD_VAR 0 3
41746: ARRAY
41747: PPUSH
41748: CALL_OW 2
41752: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41753: LD_ADDR_VAR 0 4
41757: PUSH
41758: LD_VAR 0 4
41762: PUSH
41763: LD_VAR 0 9
41767: PUSH
41768: LD_VAR 0 3
41772: ARRAY
41773: DIFF
41774: ST_TO_ADDR
// end ;
41775: GO 41684
41777: POP
41778: POP
// if p then
41779: LD_VAR 0 11
41783: IFFALSE 41808
// result := Replace ( result , 4 , p ) ;
41785: LD_ADDR_VAR 0 2
41789: PUSH
41790: LD_VAR 0 2
41794: PPUSH
41795: LD_INT 4
41797: PPUSH
41798: LD_VAR 0 11
41802: PPUSH
41803: CALL_OW 1
41807: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41808: LD_VAR 0 4
41812: PUSH
41813: LD_VAR 0 7
41817: PUSH
41818: LD_INT 6
41820: LESS
41821: AND
41822: IFFALSE 42010
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41824: LD_ADDR_VAR 0 9
41828: PUSH
41829: LD_VAR 0 4
41833: PUSH
41834: LD_VAR 0 8
41838: PUSH
41839: LD_VAR 0 7
41843: UNION
41844: DIFF
41845: PPUSH
41846: LD_INT 3
41848: PPUSH
41849: CALL 101830 0 2
41853: ST_TO_ADDR
// p := [ ] ;
41854: LD_ADDR_VAR 0 11
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// if sort then
41861: LD_VAR 0 9
41865: IFFALSE 41981
// for i = 1 to 6 - mech do
41867: LD_ADDR_VAR 0 3
41871: PUSH
41872: DOUBLE
41873: LD_INT 1
41875: DEC
41876: ST_TO_ADDR
41877: LD_INT 6
41879: PUSH
41880: LD_VAR 0 7
41884: MINUS
41885: PUSH
41886: FOR_TO
41887: IFFALSE 41979
// begin if i = sort then
41889: LD_VAR 0 3
41893: PUSH
41894: LD_VAR 0 9
41898: EQUAL
41899: IFFALSE 41903
// break ;
41901: GO 41979
// if GetClass ( i ) = 3 then
41903: LD_VAR 0 3
41907: PPUSH
41908: CALL_OW 257
41912: PUSH
41913: LD_INT 3
41915: EQUAL
41916: IFFALSE 41920
// continue ;
41918: GO 41886
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41920: LD_ADDR_VAR 0 11
41924: PUSH
41925: LD_VAR 0 11
41929: PPUSH
41930: LD_VAR 0 11
41934: PUSH
41935: LD_INT 1
41937: PLUS
41938: PPUSH
41939: LD_VAR 0 9
41943: PUSH
41944: LD_VAR 0 3
41948: ARRAY
41949: PPUSH
41950: CALL_OW 2
41954: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41955: LD_ADDR_VAR 0 4
41959: PUSH
41960: LD_VAR 0 4
41964: PUSH
41965: LD_VAR 0 9
41969: PUSH
41970: LD_VAR 0 3
41974: ARRAY
41975: DIFF
41976: ST_TO_ADDR
// end ;
41977: GO 41886
41979: POP
41980: POP
// if p then
41981: LD_VAR 0 11
41985: IFFALSE 42010
// result := Replace ( result , 3 , p ) ;
41987: LD_ADDR_VAR 0 2
41991: PUSH
41992: LD_VAR 0 2
41996: PPUSH
41997: LD_INT 3
41999: PPUSH
42000: LD_VAR 0 11
42004: PPUSH
42005: CALL_OW 1
42009: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
42010: LD_VAR 0 4
42014: PUSH
42015: LD_INT 6
42017: GREATER
42018: PUSH
42019: LD_VAR 0 6
42023: PUSH
42024: LD_INT 6
42026: LESS
42027: AND
42028: IFFALSE 42222
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42030: LD_ADDR_VAR 0 9
42034: PUSH
42035: LD_VAR 0 4
42039: PUSH
42040: LD_VAR 0 8
42044: PUSH
42045: LD_VAR 0 7
42049: UNION
42050: PUSH
42051: LD_VAR 0 6
42055: UNION
42056: DIFF
42057: PPUSH
42058: LD_INT 2
42060: PPUSH
42061: CALL 101830 0 2
42065: ST_TO_ADDR
// p := [ ] ;
42066: LD_ADDR_VAR 0 11
42070: PUSH
42071: EMPTY
42072: ST_TO_ADDR
// if sort then
42073: LD_VAR 0 9
42077: IFFALSE 42193
// for i = 1 to 6 - eng do
42079: LD_ADDR_VAR 0 3
42083: PUSH
42084: DOUBLE
42085: LD_INT 1
42087: DEC
42088: ST_TO_ADDR
42089: LD_INT 6
42091: PUSH
42092: LD_VAR 0 6
42096: MINUS
42097: PUSH
42098: FOR_TO
42099: IFFALSE 42191
// begin if i = sort then
42101: LD_VAR 0 3
42105: PUSH
42106: LD_VAR 0 9
42110: EQUAL
42111: IFFALSE 42115
// break ;
42113: GO 42191
// if GetClass ( i ) = 2 then
42115: LD_VAR 0 3
42119: PPUSH
42120: CALL_OW 257
42124: PUSH
42125: LD_INT 2
42127: EQUAL
42128: IFFALSE 42132
// continue ;
42130: GO 42098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42132: LD_ADDR_VAR 0 11
42136: PUSH
42137: LD_VAR 0 11
42141: PPUSH
42142: LD_VAR 0 11
42146: PUSH
42147: LD_INT 1
42149: PLUS
42150: PPUSH
42151: LD_VAR 0 9
42155: PUSH
42156: LD_VAR 0 3
42160: ARRAY
42161: PPUSH
42162: CALL_OW 2
42166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42167: LD_ADDR_VAR 0 4
42171: PUSH
42172: LD_VAR 0 4
42176: PUSH
42177: LD_VAR 0 9
42181: PUSH
42182: LD_VAR 0 3
42186: ARRAY
42187: DIFF
42188: ST_TO_ADDR
// end ;
42189: GO 42098
42191: POP
42192: POP
// if p then
42193: LD_VAR 0 11
42197: IFFALSE 42222
// result := Replace ( result , 2 , p ) ;
42199: LD_ADDR_VAR 0 2
42203: PUSH
42204: LD_VAR 0 2
42208: PPUSH
42209: LD_INT 2
42211: PPUSH
42212: LD_VAR 0 11
42216: PPUSH
42217: CALL_OW 1
42221: ST_TO_ADDR
// end ; exit ;
42222: GO 43610
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42224: LD_EXP 142
42228: PUSH
42229: LD_EXP 141
42233: PUSH
42234: LD_VAR 0 1
42238: ARRAY
42239: ARRAY
42240: NOT
42241: PUSH
42242: LD_EXP 115
42246: PUSH
42247: LD_VAR 0 1
42251: ARRAY
42252: PPUSH
42253: LD_INT 30
42255: PUSH
42256: LD_INT 3
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PPUSH
42263: CALL_OW 72
42267: AND
42268: PUSH
42269: LD_EXP 120
42273: PUSH
42274: LD_VAR 0 1
42278: ARRAY
42279: AND
42280: IFFALSE 42888
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42282: LD_ADDR_EXP 157
42286: PUSH
42287: LD_EXP 157
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: LD_INT 5
42299: PPUSH
42300: CALL_OW 1
42304: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42305: LD_ADDR_VAR 0 2
42309: PUSH
42310: LD_INT 0
42312: PUSH
42313: LD_INT 0
42315: PUSH
42316: LD_INT 0
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: ST_TO_ADDR
// if sci > 1 then
42328: LD_VAR 0 8
42332: PUSH
42333: LD_INT 1
42335: GREATER
42336: IFFALSE 42364
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42338: LD_ADDR_VAR 0 4
42342: PUSH
42343: LD_VAR 0 4
42347: PUSH
42348: LD_VAR 0 8
42352: PUSH
42353: LD_VAR 0 8
42357: PUSH
42358: LD_INT 1
42360: ARRAY
42361: DIFF
42362: DIFF
42363: ST_TO_ADDR
// if tmp and not sci then
42364: LD_VAR 0 4
42368: PUSH
42369: LD_VAR 0 8
42373: NOT
42374: AND
42375: IFFALSE 42444
// begin sort := SortBySkill ( tmp , 4 ) ;
42377: LD_ADDR_VAR 0 9
42381: PUSH
42382: LD_VAR 0 4
42386: PPUSH
42387: LD_INT 4
42389: PPUSH
42390: CALL 101830 0 2
42394: ST_TO_ADDR
// if sort then
42395: LD_VAR 0 9
42399: IFFALSE 42415
// p := sort [ 1 ] ;
42401: LD_ADDR_VAR 0 11
42405: PUSH
42406: LD_VAR 0 9
42410: PUSH
42411: LD_INT 1
42413: ARRAY
42414: ST_TO_ADDR
// if p then
42415: LD_VAR 0 11
42419: IFFALSE 42444
// result := Replace ( result , 4 , p ) ;
42421: LD_ADDR_VAR 0 2
42425: PUSH
42426: LD_VAR 0 2
42430: PPUSH
42431: LD_INT 4
42433: PPUSH
42434: LD_VAR 0 11
42438: PPUSH
42439: CALL_OW 1
42443: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42444: LD_ADDR_VAR 0 4
42448: PUSH
42449: LD_VAR 0 4
42453: PUSH
42454: LD_VAR 0 7
42458: DIFF
42459: ST_TO_ADDR
// if tmp and mech < 6 then
42460: LD_VAR 0 4
42464: PUSH
42465: LD_VAR 0 7
42469: PUSH
42470: LD_INT 6
42472: LESS
42473: AND
42474: IFFALSE 42662
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42476: LD_ADDR_VAR 0 9
42480: PUSH
42481: LD_VAR 0 4
42485: PUSH
42486: LD_VAR 0 8
42490: PUSH
42491: LD_VAR 0 7
42495: UNION
42496: DIFF
42497: PPUSH
42498: LD_INT 3
42500: PPUSH
42501: CALL 101830 0 2
42505: ST_TO_ADDR
// p := [ ] ;
42506: LD_ADDR_VAR 0 11
42510: PUSH
42511: EMPTY
42512: ST_TO_ADDR
// if sort then
42513: LD_VAR 0 9
42517: IFFALSE 42633
// for i = 1 to 6 - mech do
42519: LD_ADDR_VAR 0 3
42523: PUSH
42524: DOUBLE
42525: LD_INT 1
42527: DEC
42528: ST_TO_ADDR
42529: LD_INT 6
42531: PUSH
42532: LD_VAR 0 7
42536: MINUS
42537: PUSH
42538: FOR_TO
42539: IFFALSE 42631
// begin if i = sort then
42541: LD_VAR 0 3
42545: PUSH
42546: LD_VAR 0 9
42550: EQUAL
42551: IFFALSE 42555
// break ;
42553: GO 42631
// if GetClass ( i ) = 3 then
42555: LD_VAR 0 3
42559: PPUSH
42560: CALL_OW 257
42564: PUSH
42565: LD_INT 3
42567: EQUAL
42568: IFFALSE 42572
// continue ;
42570: GO 42538
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42572: LD_ADDR_VAR 0 11
42576: PUSH
42577: LD_VAR 0 11
42581: PPUSH
42582: LD_VAR 0 11
42586: PUSH
42587: LD_INT 1
42589: PLUS
42590: PPUSH
42591: LD_VAR 0 9
42595: PUSH
42596: LD_VAR 0 3
42600: ARRAY
42601: PPUSH
42602: CALL_OW 2
42606: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42607: LD_ADDR_VAR 0 4
42611: PUSH
42612: LD_VAR 0 4
42616: PUSH
42617: LD_VAR 0 9
42621: PUSH
42622: LD_VAR 0 3
42626: ARRAY
42627: DIFF
42628: ST_TO_ADDR
// end ;
42629: GO 42538
42631: POP
42632: POP
// if p then
42633: LD_VAR 0 11
42637: IFFALSE 42662
// result := Replace ( result , 3 , p ) ;
42639: LD_ADDR_VAR 0 2
42643: PUSH
42644: LD_VAR 0 2
42648: PPUSH
42649: LD_INT 3
42651: PPUSH
42652: LD_VAR 0 11
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42662: LD_ADDR_VAR 0 4
42666: PUSH
42667: LD_VAR 0 4
42671: PUSH
42672: LD_VAR 0 6
42676: DIFF
42677: ST_TO_ADDR
// if tmp and eng < 6 then
42678: LD_VAR 0 4
42682: PUSH
42683: LD_VAR 0 6
42687: PUSH
42688: LD_INT 6
42690: LESS
42691: AND
42692: IFFALSE 42886
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42694: LD_ADDR_VAR 0 9
42698: PUSH
42699: LD_VAR 0 4
42703: PUSH
42704: LD_VAR 0 8
42708: PUSH
42709: LD_VAR 0 7
42713: UNION
42714: PUSH
42715: LD_VAR 0 6
42719: UNION
42720: DIFF
42721: PPUSH
42722: LD_INT 2
42724: PPUSH
42725: CALL 101830 0 2
42729: ST_TO_ADDR
// p := [ ] ;
42730: LD_ADDR_VAR 0 11
42734: PUSH
42735: EMPTY
42736: ST_TO_ADDR
// if sort then
42737: LD_VAR 0 9
42741: IFFALSE 42857
// for i = 1 to 6 - eng do
42743: LD_ADDR_VAR 0 3
42747: PUSH
42748: DOUBLE
42749: LD_INT 1
42751: DEC
42752: ST_TO_ADDR
42753: LD_INT 6
42755: PUSH
42756: LD_VAR 0 6
42760: MINUS
42761: PUSH
42762: FOR_TO
42763: IFFALSE 42855
// begin if i = sort then
42765: LD_VAR 0 3
42769: PUSH
42770: LD_VAR 0 9
42774: EQUAL
42775: IFFALSE 42779
// break ;
42777: GO 42855
// if GetClass ( i ) = 2 then
42779: LD_VAR 0 3
42783: PPUSH
42784: CALL_OW 257
42788: PUSH
42789: LD_INT 2
42791: EQUAL
42792: IFFALSE 42796
// continue ;
42794: GO 42762
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42796: LD_ADDR_VAR 0 11
42800: PUSH
42801: LD_VAR 0 11
42805: PPUSH
42806: LD_VAR 0 11
42810: PUSH
42811: LD_INT 1
42813: PLUS
42814: PPUSH
42815: LD_VAR 0 9
42819: PUSH
42820: LD_VAR 0 3
42824: ARRAY
42825: PPUSH
42826: CALL_OW 2
42830: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42831: LD_ADDR_VAR 0 4
42835: PUSH
42836: LD_VAR 0 4
42840: PUSH
42841: LD_VAR 0 9
42845: PUSH
42846: LD_VAR 0 3
42850: ARRAY
42851: DIFF
42852: ST_TO_ADDR
// end ;
42853: GO 42762
42855: POP
42856: POP
// if p then
42857: LD_VAR 0 11
42861: IFFALSE 42886
// result := Replace ( result , 2 , p ) ;
42863: LD_ADDR_VAR 0 2
42867: PUSH
42868: LD_VAR 0 2
42872: PPUSH
42873: LD_INT 2
42875: PPUSH
42876: LD_VAR 0 11
42880: PPUSH
42881: CALL_OW 1
42885: ST_TO_ADDR
// end ; exit ;
42886: GO 43610
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42888: LD_EXP 142
42892: PUSH
42893: LD_EXP 141
42897: PUSH
42898: LD_VAR 0 1
42902: ARRAY
42903: ARRAY
42904: NOT
42905: PUSH
42906: LD_EXP 115
42910: PUSH
42911: LD_VAR 0 1
42915: ARRAY
42916: PPUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 3
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PPUSH
42927: CALL_OW 72
42931: AND
42932: PUSH
42933: LD_EXP 120
42937: PUSH
42938: LD_VAR 0 1
42942: ARRAY
42943: NOT
42944: AND
42945: IFFALSE 43610
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42947: LD_ADDR_EXP 157
42951: PUSH
42952: LD_EXP 157
42956: PPUSH
42957: LD_VAR 0 1
42961: PPUSH
42962: LD_INT 6
42964: PPUSH
42965: CALL_OW 1
42969: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42970: LD_ADDR_VAR 0 2
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: LD_INT 0
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: ST_TO_ADDR
// if sci >= 1 then
42993: LD_VAR 0 8
42997: PUSH
42998: LD_INT 1
43000: GREATEREQUAL
43001: IFFALSE 43023
// tmp := tmp diff sci [ 1 ] ;
43003: LD_ADDR_VAR 0 4
43007: PUSH
43008: LD_VAR 0 4
43012: PUSH
43013: LD_VAR 0 8
43017: PUSH
43018: LD_INT 1
43020: ARRAY
43021: DIFF
43022: ST_TO_ADDR
// if tmp and not sci then
43023: LD_VAR 0 4
43027: PUSH
43028: LD_VAR 0 8
43032: NOT
43033: AND
43034: IFFALSE 43103
// begin sort := SortBySkill ( tmp , 4 ) ;
43036: LD_ADDR_VAR 0 9
43040: PUSH
43041: LD_VAR 0 4
43045: PPUSH
43046: LD_INT 4
43048: PPUSH
43049: CALL 101830 0 2
43053: ST_TO_ADDR
// if sort then
43054: LD_VAR 0 9
43058: IFFALSE 43074
// p := sort [ 1 ] ;
43060: LD_ADDR_VAR 0 11
43064: PUSH
43065: LD_VAR 0 9
43069: PUSH
43070: LD_INT 1
43072: ARRAY
43073: ST_TO_ADDR
// if p then
43074: LD_VAR 0 11
43078: IFFALSE 43103
// result := Replace ( result , 4 , p ) ;
43080: LD_ADDR_VAR 0 2
43084: PUSH
43085: LD_VAR 0 2
43089: PPUSH
43090: LD_INT 4
43092: PPUSH
43093: LD_VAR 0 11
43097: PPUSH
43098: CALL_OW 1
43102: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43103: LD_ADDR_VAR 0 4
43107: PUSH
43108: LD_VAR 0 4
43112: PUSH
43113: LD_VAR 0 7
43117: DIFF
43118: ST_TO_ADDR
// if tmp and mech < 6 then
43119: LD_VAR 0 4
43123: PUSH
43124: LD_VAR 0 7
43128: PUSH
43129: LD_INT 6
43131: LESS
43132: AND
43133: IFFALSE 43315
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43135: LD_ADDR_VAR 0 9
43139: PUSH
43140: LD_VAR 0 4
43144: PUSH
43145: LD_VAR 0 7
43149: DIFF
43150: PPUSH
43151: LD_INT 3
43153: PPUSH
43154: CALL 101830 0 2
43158: ST_TO_ADDR
// p := [ ] ;
43159: LD_ADDR_VAR 0 11
43163: PUSH
43164: EMPTY
43165: ST_TO_ADDR
// if sort then
43166: LD_VAR 0 9
43170: IFFALSE 43286
// for i = 1 to 6 - mech do
43172: LD_ADDR_VAR 0 3
43176: PUSH
43177: DOUBLE
43178: LD_INT 1
43180: DEC
43181: ST_TO_ADDR
43182: LD_INT 6
43184: PUSH
43185: LD_VAR 0 7
43189: MINUS
43190: PUSH
43191: FOR_TO
43192: IFFALSE 43284
// begin if i = sort then
43194: LD_VAR 0 3
43198: PUSH
43199: LD_VAR 0 9
43203: EQUAL
43204: IFFALSE 43208
// break ;
43206: GO 43284
// if GetClass ( i ) = 3 then
43208: LD_VAR 0 3
43212: PPUSH
43213: CALL_OW 257
43217: PUSH
43218: LD_INT 3
43220: EQUAL
43221: IFFALSE 43225
// continue ;
43223: GO 43191
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43225: LD_ADDR_VAR 0 11
43229: PUSH
43230: LD_VAR 0 11
43234: PPUSH
43235: LD_VAR 0 11
43239: PUSH
43240: LD_INT 1
43242: PLUS
43243: PPUSH
43244: LD_VAR 0 9
43248: PUSH
43249: LD_VAR 0 3
43253: ARRAY
43254: PPUSH
43255: CALL_OW 2
43259: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43260: LD_ADDR_VAR 0 4
43264: PUSH
43265: LD_VAR 0 4
43269: PUSH
43270: LD_VAR 0 9
43274: PUSH
43275: LD_VAR 0 3
43279: ARRAY
43280: DIFF
43281: ST_TO_ADDR
// end ;
43282: GO 43191
43284: POP
43285: POP
// if p then
43286: LD_VAR 0 11
43290: IFFALSE 43315
// result := Replace ( result , 3 , p ) ;
43292: LD_ADDR_VAR 0 2
43296: PUSH
43297: LD_VAR 0 2
43301: PPUSH
43302: LD_INT 3
43304: PPUSH
43305: LD_VAR 0 11
43309: PPUSH
43310: CALL_OW 1
43314: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43315: LD_ADDR_VAR 0 4
43319: PUSH
43320: LD_VAR 0 4
43324: PUSH
43325: LD_VAR 0 6
43329: DIFF
43330: ST_TO_ADDR
// if tmp and eng < 4 then
43331: LD_VAR 0 4
43335: PUSH
43336: LD_VAR 0 6
43340: PUSH
43341: LD_INT 4
43343: LESS
43344: AND
43345: IFFALSE 43535
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43347: LD_ADDR_VAR 0 9
43351: PUSH
43352: LD_VAR 0 4
43356: PUSH
43357: LD_VAR 0 7
43361: PUSH
43362: LD_VAR 0 6
43366: UNION
43367: DIFF
43368: PPUSH
43369: LD_INT 2
43371: PPUSH
43372: CALL 101830 0 2
43376: ST_TO_ADDR
// p := [ ] ;
43377: LD_ADDR_VAR 0 11
43381: PUSH
43382: EMPTY
43383: ST_TO_ADDR
// if sort then
43384: LD_VAR 0 9
43388: IFFALSE 43504
// for i = 1 to 4 - eng do
43390: LD_ADDR_VAR 0 3
43394: PUSH
43395: DOUBLE
43396: LD_INT 1
43398: DEC
43399: ST_TO_ADDR
43400: LD_INT 4
43402: PUSH
43403: LD_VAR 0 6
43407: MINUS
43408: PUSH
43409: FOR_TO
43410: IFFALSE 43502
// begin if i = sort then
43412: LD_VAR 0 3
43416: PUSH
43417: LD_VAR 0 9
43421: EQUAL
43422: IFFALSE 43426
// break ;
43424: GO 43502
// if GetClass ( i ) = 2 then
43426: LD_VAR 0 3
43430: PPUSH
43431: CALL_OW 257
43435: PUSH
43436: LD_INT 2
43438: EQUAL
43439: IFFALSE 43443
// continue ;
43441: GO 43409
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43443: LD_ADDR_VAR 0 11
43447: PUSH
43448: LD_VAR 0 11
43452: PPUSH
43453: LD_VAR 0 11
43457: PUSH
43458: LD_INT 1
43460: PLUS
43461: PPUSH
43462: LD_VAR 0 9
43466: PUSH
43467: LD_VAR 0 3
43471: ARRAY
43472: PPUSH
43473: CALL_OW 2
43477: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43478: LD_ADDR_VAR 0 4
43482: PUSH
43483: LD_VAR 0 4
43487: PUSH
43488: LD_VAR 0 9
43492: PUSH
43493: LD_VAR 0 3
43497: ARRAY
43498: DIFF
43499: ST_TO_ADDR
// end ;
43500: GO 43409
43502: POP
43503: POP
// if p then
43504: LD_VAR 0 11
43508: IFFALSE 43533
// result := Replace ( result , 2 , p ) ;
43510: LD_ADDR_VAR 0 2
43514: PUSH
43515: LD_VAR 0 2
43519: PPUSH
43520: LD_INT 2
43522: PPUSH
43523: LD_VAR 0 11
43527: PPUSH
43528: CALL_OW 1
43532: ST_TO_ADDR
// end else
43533: GO 43579
// for i = eng downto 5 do
43535: LD_ADDR_VAR 0 3
43539: PUSH
43540: DOUBLE
43541: LD_VAR 0 6
43545: INC
43546: ST_TO_ADDR
43547: LD_INT 5
43549: PUSH
43550: FOR_DOWNTO
43551: IFFALSE 43577
// tmp := tmp union eng [ i ] ;
43553: LD_ADDR_VAR 0 4
43557: PUSH
43558: LD_VAR 0 4
43562: PUSH
43563: LD_VAR 0 6
43567: PUSH
43568: LD_VAR 0 3
43572: ARRAY
43573: UNION
43574: ST_TO_ADDR
43575: GO 43550
43577: POP
43578: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43579: LD_ADDR_VAR 0 2
43583: PUSH
43584: LD_VAR 0 2
43588: PPUSH
43589: LD_INT 1
43591: PPUSH
43592: LD_VAR 0 4
43596: PUSH
43597: LD_VAR 0 5
43601: DIFF
43602: PPUSH
43603: CALL_OW 1
43607: ST_TO_ADDR
// exit ;
43608: GO 43610
// end ; end ;
43610: LD_VAR 0 2
43614: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43615: LD_INT 0
43617: PPUSH
43618: PPUSH
43619: PPUSH
// if not mc_bases then
43620: LD_EXP 115
43624: NOT
43625: IFFALSE 43629
// exit ;
43627: GO 43771
// for i = 1 to mc_bases do
43629: LD_ADDR_VAR 0 2
43633: PUSH
43634: DOUBLE
43635: LD_INT 1
43637: DEC
43638: ST_TO_ADDR
43639: LD_EXP 115
43643: PUSH
43644: FOR_TO
43645: IFFALSE 43762
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43647: LD_ADDR_VAR 0 3
43651: PUSH
43652: LD_EXP 115
43656: PUSH
43657: LD_VAR 0 2
43661: ARRAY
43662: PPUSH
43663: LD_INT 21
43665: PUSH
43666: LD_INT 3
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 2
43678: PUSH
43679: LD_INT 30
43681: PUSH
43682: LD_INT 29
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 30
43691: PUSH
43692: LD_INT 30
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: LIST
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 3
43710: PUSH
43711: LD_INT 24
43713: PUSH
43714: LD_INT 1000
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: LIST
43729: PPUSH
43730: CALL_OW 72
43734: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43735: LD_ADDR_EXP 116
43739: PUSH
43740: LD_EXP 116
43744: PPUSH
43745: LD_VAR 0 2
43749: PPUSH
43750: LD_VAR 0 3
43754: PPUSH
43755: CALL_OW 1
43759: ST_TO_ADDR
// end ;
43760: GO 43644
43762: POP
43763: POP
// RaiseSailEvent ( 101 ) ;
43764: LD_INT 101
43766: PPUSH
43767: CALL_OW 427
// end ;
43771: LD_VAR 0 1
43775: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43776: LD_INT 0
43778: PPUSH
43779: PPUSH
43780: PPUSH
43781: PPUSH
43782: PPUSH
43783: PPUSH
43784: PPUSH
// if not mc_bases then
43785: LD_EXP 115
43789: NOT
43790: IFFALSE 43794
// exit ;
43792: GO 44356
// for i = 1 to mc_bases do
43794: LD_ADDR_VAR 0 2
43798: PUSH
43799: DOUBLE
43800: LD_INT 1
43802: DEC
43803: ST_TO_ADDR
43804: LD_EXP 115
43808: PUSH
43809: FOR_TO
43810: IFFALSE 44347
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43812: LD_ADDR_VAR 0 5
43816: PUSH
43817: LD_EXP 115
43821: PUSH
43822: LD_VAR 0 2
43826: ARRAY
43827: PUSH
43828: LD_EXP 144
43832: PUSH
43833: LD_VAR 0 2
43837: ARRAY
43838: UNION
43839: PPUSH
43840: LD_INT 21
43842: PUSH
43843: LD_INT 1
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: PUSH
43850: LD_INT 1
43852: PUSH
43853: LD_INT 3
43855: PUSH
43856: LD_INT 54
43858: PUSH
43859: EMPTY
43860: LIST
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 3
43868: PUSH
43869: LD_INT 24
43871: PUSH
43872: LD_INT 1000
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: LIST
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PPUSH
43892: CALL_OW 72
43896: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43897: LD_ADDR_VAR 0 6
43901: PUSH
43902: LD_EXP 115
43906: PUSH
43907: LD_VAR 0 2
43911: ARRAY
43912: PPUSH
43913: LD_INT 21
43915: PUSH
43916: LD_INT 1
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 1
43925: PUSH
43926: LD_INT 3
43928: PUSH
43929: LD_INT 54
43931: PUSH
43932: EMPTY
43933: LIST
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 3
43941: PUSH
43942: LD_INT 24
43944: PUSH
43945: LD_INT 250
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: LIST
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PPUSH
43965: CALL_OW 72
43969: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43970: LD_ADDR_VAR 0 7
43974: PUSH
43975: LD_VAR 0 5
43979: PUSH
43980: LD_VAR 0 6
43984: DIFF
43985: ST_TO_ADDR
// if not need_heal_1 then
43986: LD_VAR 0 6
43990: NOT
43991: IFFALSE 44024
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43993: LD_ADDR_EXP 118
43997: PUSH
43998: LD_EXP 118
44002: PPUSH
44003: LD_VAR 0 2
44007: PUSH
44008: LD_INT 1
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PPUSH
44015: EMPTY
44016: PPUSH
44017: CALL 71059 0 3
44021: ST_TO_ADDR
44022: GO 44094
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
44024: LD_ADDR_EXP 118
44028: PUSH
44029: LD_EXP 118
44033: PPUSH
44034: LD_VAR 0 2
44038: PUSH
44039: LD_INT 1
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PPUSH
44046: LD_EXP 118
44050: PUSH
44051: LD_VAR 0 2
44055: ARRAY
44056: PUSH
44057: LD_INT 1
44059: ARRAY
44060: PPUSH
44061: LD_INT 3
44063: PUSH
44064: LD_INT 24
44066: PUSH
44067: LD_INT 1000
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PPUSH
44078: CALL_OW 72
44082: PUSH
44083: LD_VAR 0 6
44087: UNION
44088: PPUSH
44089: CALL 71059 0 3
44093: ST_TO_ADDR
// if not need_heal_2 then
44094: LD_VAR 0 7
44098: NOT
44099: IFFALSE 44132
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44101: LD_ADDR_EXP 118
44105: PUSH
44106: LD_EXP 118
44110: PPUSH
44111: LD_VAR 0 2
44115: PUSH
44116: LD_INT 2
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PPUSH
44123: EMPTY
44124: PPUSH
44125: CALL 71059 0 3
44129: ST_TO_ADDR
44130: GO 44164
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44132: LD_ADDR_EXP 118
44136: PUSH
44137: LD_EXP 118
44141: PPUSH
44142: LD_VAR 0 2
44146: PUSH
44147: LD_INT 2
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PPUSH
44154: LD_VAR 0 7
44158: PPUSH
44159: CALL 71059 0 3
44163: ST_TO_ADDR
// if need_heal_2 then
44164: LD_VAR 0 7
44168: IFFALSE 44329
// for j in need_heal_2 do
44170: LD_ADDR_VAR 0 3
44174: PUSH
44175: LD_VAR 0 7
44179: PUSH
44180: FOR_IN
44181: IFFALSE 44327
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44183: LD_ADDR_VAR 0 5
44187: PUSH
44188: LD_EXP 115
44192: PUSH
44193: LD_VAR 0 2
44197: ARRAY
44198: PPUSH
44199: LD_INT 2
44201: PUSH
44202: LD_INT 30
44204: PUSH
44205: LD_INT 6
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 30
44214: PUSH
44215: LD_INT 7
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 30
44224: PUSH
44225: LD_INT 8
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 30
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 30
44244: PUSH
44245: LD_INT 1
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: PPUSH
44260: CALL_OW 72
44264: ST_TO_ADDR
// if tmp then
44265: LD_VAR 0 5
44269: IFFALSE 44325
// begin k := NearestUnitToUnit ( tmp , j ) ;
44271: LD_ADDR_VAR 0 4
44275: PUSH
44276: LD_VAR 0 5
44280: PPUSH
44281: LD_VAR 0 3
44285: PPUSH
44286: CALL_OW 74
44290: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44291: LD_VAR 0 3
44295: PPUSH
44296: LD_VAR 0 4
44300: PPUSH
44301: CALL_OW 296
44305: PUSH
44306: LD_INT 5
44308: GREATER
44309: IFFALSE 44325
// ComMoveToNearbyEntrance ( j , k ) ;
44311: LD_VAR 0 3
44315: PPUSH
44316: LD_VAR 0 4
44320: PPUSH
44321: CALL 104198 0 2
// end ; end ;
44325: GO 44180
44327: POP
44328: POP
// if not need_heal_1 and not need_heal_2 then
44329: LD_VAR 0 6
44333: NOT
44334: PUSH
44335: LD_VAR 0 7
44339: NOT
44340: AND
44341: IFFALSE 44345
// continue ;
44343: GO 43809
// end ;
44345: GO 43809
44347: POP
44348: POP
// RaiseSailEvent ( 102 ) ;
44349: LD_INT 102
44351: PPUSH
44352: CALL_OW 427
// end ;
44356: LD_VAR 0 1
44360: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44361: LD_INT 0
44363: PPUSH
44364: PPUSH
44365: PPUSH
44366: PPUSH
44367: PPUSH
44368: PPUSH
44369: PPUSH
44370: PPUSH
// if not mc_bases then
44371: LD_EXP 115
44375: NOT
44376: IFFALSE 44380
// exit ;
44378: GO 45263
// for i = 1 to mc_bases do
44380: LD_ADDR_VAR 0 2
44384: PUSH
44385: DOUBLE
44386: LD_INT 1
44388: DEC
44389: ST_TO_ADDR
44390: LD_EXP 115
44394: PUSH
44395: FOR_TO
44396: IFFALSE 45261
// begin if not mc_building_need_repair [ i ] then
44398: LD_EXP 116
44402: PUSH
44403: LD_VAR 0 2
44407: ARRAY
44408: NOT
44409: IFFALSE 44596
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44411: LD_ADDR_VAR 0 6
44415: PUSH
44416: LD_EXP 134
44420: PUSH
44421: LD_VAR 0 2
44425: ARRAY
44426: PPUSH
44427: LD_INT 3
44429: PUSH
44430: LD_INT 24
44432: PUSH
44433: LD_INT 1000
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 2
44446: PUSH
44447: LD_INT 34
44449: PUSH
44450: LD_INT 13
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 34
44459: PUSH
44460: LD_INT 52
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 34
44469: PUSH
44470: LD_EXP 101
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: LIST
44483: LIST
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PPUSH
44489: CALL_OW 72
44493: ST_TO_ADDR
// if cranes then
44494: LD_VAR 0 6
44498: IFFALSE 44560
// for j in cranes do
44500: LD_ADDR_VAR 0 3
44504: PUSH
44505: LD_VAR 0 6
44509: PUSH
44510: FOR_IN
44511: IFFALSE 44558
// if not IsInArea ( j , mc_parking [ i ] ) then
44513: LD_VAR 0 3
44517: PPUSH
44518: LD_EXP 139
44522: PUSH
44523: LD_VAR 0 2
44527: ARRAY
44528: PPUSH
44529: CALL_OW 308
44533: NOT
44534: IFFALSE 44556
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44536: LD_VAR 0 3
44540: PPUSH
44541: LD_EXP 139
44545: PUSH
44546: LD_VAR 0 2
44550: ARRAY
44551: PPUSH
44552: CALL_OW 113
44556: GO 44510
44558: POP
44559: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44560: LD_ADDR_EXP 117
44564: PUSH
44565: LD_EXP 117
44569: PPUSH
44570: LD_VAR 0 2
44574: PPUSH
44575: EMPTY
44576: PPUSH
44577: CALL_OW 1
44581: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44582: LD_VAR 0 2
44586: PPUSH
44587: LD_INT 101
44589: PPUSH
44590: CALL 39448 0 2
// continue ;
44594: GO 44395
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44596: LD_ADDR_EXP 121
44600: PUSH
44601: LD_EXP 121
44605: PPUSH
44606: LD_VAR 0 2
44610: PPUSH
44611: EMPTY
44612: PPUSH
44613: CALL_OW 1
44617: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44618: LD_VAR 0 2
44622: PPUSH
44623: LD_INT 103
44625: PPUSH
44626: CALL 39448 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44630: LD_ADDR_VAR 0 5
44634: PUSH
44635: LD_EXP 115
44639: PUSH
44640: LD_VAR 0 2
44644: ARRAY
44645: PUSH
44646: LD_EXP 144
44650: PUSH
44651: LD_VAR 0 2
44655: ARRAY
44656: UNION
44657: PPUSH
44658: LD_INT 2
44660: PUSH
44661: LD_INT 25
44663: PUSH
44664: LD_INT 2
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 25
44673: PUSH
44674: LD_INT 16
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: LIST
44685: PUSH
44686: EMPTY
44687: LIST
44688: PPUSH
44689: CALL_OW 72
44693: ST_TO_ADDR
// if mc_need_heal [ i ] then
44694: LD_EXP 118
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: IFFALSE 44748
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44706: LD_ADDR_VAR 0 5
44710: PUSH
44711: LD_VAR 0 5
44715: PUSH
44716: LD_EXP 118
44720: PUSH
44721: LD_VAR 0 2
44725: ARRAY
44726: PUSH
44727: LD_INT 1
44729: ARRAY
44730: PUSH
44731: LD_EXP 118
44735: PUSH
44736: LD_VAR 0 2
44740: ARRAY
44741: PUSH
44742: LD_INT 2
44744: ARRAY
44745: UNION
44746: DIFF
44747: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44748: LD_ADDR_VAR 0 6
44752: PUSH
44753: LD_EXP 134
44757: PUSH
44758: LD_VAR 0 2
44762: ARRAY
44763: PPUSH
44764: LD_INT 2
44766: PUSH
44767: LD_INT 34
44769: PUSH
44770: LD_INT 13
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 34
44779: PUSH
44780: LD_INT 52
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 34
44789: PUSH
44790: LD_EXP 101
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: PPUSH
44805: CALL_OW 72
44809: ST_TO_ADDR
// if cranes then
44810: LD_VAR 0 6
44814: IFFALSE 44950
// begin for j in cranes do
44816: LD_ADDR_VAR 0 3
44820: PUSH
44821: LD_VAR 0 6
44825: PUSH
44826: FOR_IN
44827: IFFALSE 44948
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44829: LD_VAR 0 3
44833: PPUSH
44834: CALL_OW 256
44838: PUSH
44839: LD_INT 1000
44841: EQUAL
44842: PUSH
44843: LD_VAR 0 3
44847: PPUSH
44848: CALL_OW 314
44852: NOT
44853: AND
44854: IFFALSE 44888
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44856: LD_VAR 0 3
44860: PPUSH
44861: LD_EXP 116
44865: PUSH
44866: LD_VAR 0 2
44870: ARRAY
44871: PPUSH
44872: LD_VAR 0 3
44876: PPUSH
44877: CALL_OW 74
44881: PPUSH
44882: CALL_OW 130
44886: GO 44946
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44888: LD_VAR 0 3
44892: PPUSH
44893: CALL_OW 256
44897: PUSH
44898: LD_INT 500
44900: LESS
44901: PUSH
44902: LD_VAR 0 3
44906: PPUSH
44907: LD_EXP 139
44911: PUSH
44912: LD_VAR 0 2
44916: ARRAY
44917: PPUSH
44918: CALL_OW 308
44922: NOT
44923: AND
44924: IFFALSE 44946
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44926: LD_VAR 0 3
44930: PPUSH
44931: LD_EXP 139
44935: PUSH
44936: LD_VAR 0 2
44940: ARRAY
44941: PPUSH
44942: CALL_OW 113
// end ;
44946: GO 44826
44948: POP
44949: POP
// end ; if tmp > 3 then
44950: LD_VAR 0 5
44954: PUSH
44955: LD_INT 3
44957: GREATER
44958: IFFALSE 44978
// tmp := ShrinkArray ( tmp , 4 ) ;
44960: LD_ADDR_VAR 0 5
44964: PUSH
44965: LD_VAR 0 5
44969: PPUSH
44970: LD_INT 4
44972: PPUSH
44973: CALL 103636 0 2
44977: ST_TO_ADDR
// if not tmp then
44978: LD_VAR 0 5
44982: NOT
44983: IFFALSE 44987
// continue ;
44985: GO 44395
// for j in tmp do
44987: LD_ADDR_VAR 0 3
44991: PUSH
44992: LD_VAR 0 5
44996: PUSH
44997: FOR_IN
44998: IFFALSE 45257
// begin if IsInUnit ( j ) then
45000: LD_VAR 0 3
45004: PPUSH
45005: CALL_OW 310
45009: IFFALSE 45020
// ComExitBuilding ( j ) ;
45011: LD_VAR 0 3
45015: PPUSH
45016: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
45020: LD_VAR 0 3
45024: PUSH
45025: LD_EXP 117
45029: PUSH
45030: LD_VAR 0 2
45034: ARRAY
45035: IN
45036: NOT
45037: IFFALSE 45095
// begin SetTag ( j , 101 ) ;
45039: LD_VAR 0 3
45043: PPUSH
45044: LD_INT 101
45046: PPUSH
45047: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45051: LD_ADDR_EXP 117
45055: PUSH
45056: LD_EXP 117
45060: PPUSH
45061: LD_VAR 0 2
45065: PUSH
45066: LD_EXP 117
45070: PUSH
45071: LD_VAR 0 2
45075: ARRAY
45076: PUSH
45077: LD_INT 1
45079: PLUS
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PPUSH
45085: LD_VAR 0 3
45089: PPUSH
45090: CALL 71059 0 3
45094: ST_TO_ADDR
// end ; wait ( 1 ) ;
45095: LD_INT 1
45097: PPUSH
45098: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45102: LD_ADDR_VAR 0 7
45106: PUSH
45107: LD_EXP 116
45111: PUSH
45112: LD_VAR 0 2
45116: ARRAY
45117: ST_TO_ADDR
// if mc_scan [ i ] then
45118: LD_EXP 138
45122: PUSH
45123: LD_VAR 0 2
45127: ARRAY
45128: IFFALSE 45190
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45130: LD_ADDR_VAR 0 7
45134: PUSH
45135: LD_EXP 116
45139: PUSH
45140: LD_VAR 0 2
45144: ARRAY
45145: PPUSH
45146: LD_INT 3
45148: PUSH
45149: LD_INT 30
45151: PUSH
45152: LD_INT 32
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 30
45161: PUSH
45162: LD_INT 33
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 30
45171: PUSH
45172: LD_INT 31
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: PPUSH
45185: CALL_OW 72
45189: ST_TO_ADDR
// if not to_repair_tmp then
45190: LD_VAR 0 7
45194: NOT
45195: IFFALSE 45199
// continue ;
45197: GO 44997
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45199: LD_ADDR_VAR 0 8
45203: PUSH
45204: LD_VAR 0 7
45208: PPUSH
45209: LD_VAR 0 3
45213: PPUSH
45214: CALL_OW 74
45218: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45219: LD_VAR 0 8
45223: PPUSH
45224: LD_INT 16
45226: PPUSH
45227: CALL 73658 0 2
45231: PUSH
45232: LD_INT 4
45234: ARRAY
45235: PUSH
45236: LD_INT 10
45238: LESS
45239: IFFALSE 45255
// ComRepairBuilding ( j , to_repair ) ;
45241: LD_VAR 0 3
45245: PPUSH
45246: LD_VAR 0 8
45250: PPUSH
45251: CALL_OW 130
// end ;
45255: GO 44997
45257: POP
45258: POP
// end ;
45259: GO 44395
45261: POP
45262: POP
// end ;
45263: LD_VAR 0 1
45267: RET
// export function MC_Heal ; var i , j , tmp ; begin
45268: LD_INT 0
45270: PPUSH
45271: PPUSH
45272: PPUSH
45273: PPUSH
// if not mc_bases then
45274: LD_EXP 115
45278: NOT
45279: IFFALSE 45283
// exit ;
45281: GO 45685
// for i = 1 to mc_bases do
45283: LD_ADDR_VAR 0 2
45287: PUSH
45288: DOUBLE
45289: LD_INT 1
45291: DEC
45292: ST_TO_ADDR
45293: LD_EXP 115
45297: PUSH
45298: FOR_TO
45299: IFFALSE 45683
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45301: LD_EXP 118
45305: PUSH
45306: LD_VAR 0 2
45310: ARRAY
45311: PUSH
45312: LD_INT 1
45314: ARRAY
45315: NOT
45316: PUSH
45317: LD_EXP 118
45321: PUSH
45322: LD_VAR 0 2
45326: ARRAY
45327: PUSH
45328: LD_INT 2
45330: ARRAY
45331: NOT
45332: AND
45333: IFFALSE 45371
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45335: LD_ADDR_EXP 119
45339: PUSH
45340: LD_EXP 119
45344: PPUSH
45345: LD_VAR 0 2
45349: PPUSH
45350: EMPTY
45351: PPUSH
45352: CALL_OW 1
45356: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45357: LD_VAR 0 2
45361: PPUSH
45362: LD_INT 102
45364: PPUSH
45365: CALL 39448 0 2
// continue ;
45369: GO 45298
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45371: LD_ADDR_VAR 0 4
45375: PUSH
45376: LD_EXP 115
45380: PUSH
45381: LD_VAR 0 2
45385: ARRAY
45386: PPUSH
45387: LD_INT 25
45389: PUSH
45390: LD_INT 4
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PPUSH
45397: CALL_OW 72
45401: ST_TO_ADDR
// if not tmp then
45402: LD_VAR 0 4
45406: NOT
45407: IFFALSE 45411
// continue ;
45409: GO 45298
// if mc_taming [ i ] then
45411: LD_EXP 146
45415: PUSH
45416: LD_VAR 0 2
45420: ARRAY
45421: IFFALSE 45445
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45423: LD_ADDR_EXP 146
45427: PUSH
45428: LD_EXP 146
45432: PPUSH
45433: LD_VAR 0 2
45437: PPUSH
45438: EMPTY
45439: PPUSH
45440: CALL_OW 1
45444: ST_TO_ADDR
// for j in tmp do
45445: LD_ADDR_VAR 0 3
45449: PUSH
45450: LD_VAR 0 4
45454: PUSH
45455: FOR_IN
45456: IFFALSE 45679
// begin if IsInUnit ( j ) then
45458: LD_VAR 0 3
45462: PPUSH
45463: CALL_OW 310
45467: IFFALSE 45478
// ComExitBuilding ( j ) ;
45469: LD_VAR 0 3
45473: PPUSH
45474: CALL_OW 122
// if not j in mc_healers [ i ] then
45478: LD_VAR 0 3
45482: PUSH
45483: LD_EXP 119
45487: PUSH
45488: LD_VAR 0 2
45492: ARRAY
45493: IN
45494: NOT
45495: IFFALSE 45541
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45497: LD_ADDR_EXP 119
45501: PUSH
45502: LD_EXP 119
45506: PPUSH
45507: LD_VAR 0 2
45511: PUSH
45512: LD_EXP 119
45516: PUSH
45517: LD_VAR 0 2
45521: ARRAY
45522: PUSH
45523: LD_INT 1
45525: PLUS
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PPUSH
45531: LD_VAR 0 3
45535: PPUSH
45536: CALL 71059 0 3
45540: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45541: LD_VAR 0 3
45545: PPUSH
45546: CALL_OW 110
45550: PUSH
45551: LD_INT 102
45553: NONEQUAL
45554: IFFALSE 45568
// SetTag ( j , 102 ) ;
45556: LD_VAR 0 3
45560: PPUSH
45561: LD_INT 102
45563: PPUSH
45564: CALL_OW 109
// Wait ( 3 ) ;
45568: LD_INT 3
45570: PPUSH
45571: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45575: LD_EXP 118
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: PUSH
45586: LD_INT 1
45588: ARRAY
45589: IFFALSE 45621
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45591: LD_VAR 0 3
45595: PPUSH
45596: LD_EXP 118
45600: PUSH
45601: LD_VAR 0 2
45605: ARRAY
45606: PUSH
45607: LD_INT 1
45609: ARRAY
45610: PUSH
45611: LD_INT 1
45613: ARRAY
45614: PPUSH
45615: CALL_OW 128
45619: GO 45677
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45621: LD_VAR 0 3
45625: PPUSH
45626: CALL_OW 314
45630: NOT
45631: PUSH
45632: LD_EXP 118
45636: PUSH
45637: LD_VAR 0 2
45641: ARRAY
45642: PUSH
45643: LD_INT 2
45645: ARRAY
45646: AND
45647: IFFALSE 45677
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45649: LD_VAR 0 3
45653: PPUSH
45654: LD_EXP 118
45658: PUSH
45659: LD_VAR 0 2
45663: ARRAY
45664: PUSH
45665: LD_INT 2
45667: ARRAY
45668: PUSH
45669: LD_INT 1
45671: ARRAY
45672: PPUSH
45673: CALL_OW 128
// end ;
45677: GO 45455
45679: POP
45680: POP
// end ;
45681: GO 45298
45683: POP
45684: POP
// end ;
45685: LD_VAR 0 1
45689: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45690: LD_INT 0
45692: PPUSH
45693: PPUSH
45694: PPUSH
45695: PPUSH
45696: PPUSH
// if not mc_bases then
45697: LD_EXP 115
45701: NOT
45702: IFFALSE 45706
// exit ;
45704: GO 46877
// for i = 1 to mc_bases do
45706: LD_ADDR_VAR 0 2
45710: PUSH
45711: DOUBLE
45712: LD_INT 1
45714: DEC
45715: ST_TO_ADDR
45716: LD_EXP 115
45720: PUSH
45721: FOR_TO
45722: IFFALSE 46875
// begin if mc_scan [ i ] then
45724: LD_EXP 138
45728: PUSH
45729: LD_VAR 0 2
45733: ARRAY
45734: IFFALSE 45738
// continue ;
45736: GO 45721
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45738: LD_EXP 120
45742: PUSH
45743: LD_VAR 0 2
45747: ARRAY
45748: NOT
45749: PUSH
45750: LD_EXP 122
45754: PUSH
45755: LD_VAR 0 2
45759: ARRAY
45760: NOT
45761: AND
45762: PUSH
45763: LD_EXP 121
45767: PUSH
45768: LD_VAR 0 2
45772: ARRAY
45773: AND
45774: IFFALSE 45812
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45776: LD_ADDR_EXP 121
45780: PUSH
45781: LD_EXP 121
45785: PPUSH
45786: LD_VAR 0 2
45790: PPUSH
45791: EMPTY
45792: PPUSH
45793: CALL_OW 1
45797: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45798: LD_VAR 0 2
45802: PPUSH
45803: LD_INT 103
45805: PPUSH
45806: CALL 39448 0 2
// continue ;
45810: GO 45721
// end ; if mc_construct_list [ i ] then
45812: LD_EXP 122
45816: PUSH
45817: LD_VAR 0 2
45821: ARRAY
45822: IFFALSE 46042
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45824: LD_ADDR_VAR 0 4
45828: PUSH
45829: LD_EXP 115
45833: PUSH
45834: LD_VAR 0 2
45838: ARRAY
45839: PPUSH
45840: LD_INT 25
45842: PUSH
45843: LD_INT 2
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: PPUSH
45850: CALL_OW 72
45854: PUSH
45855: LD_EXP 117
45859: PUSH
45860: LD_VAR 0 2
45864: ARRAY
45865: DIFF
45866: ST_TO_ADDR
// if not tmp then
45867: LD_VAR 0 4
45871: NOT
45872: IFFALSE 45876
// continue ;
45874: GO 45721
// for j in tmp do
45876: LD_ADDR_VAR 0 3
45880: PUSH
45881: LD_VAR 0 4
45885: PUSH
45886: FOR_IN
45887: IFFALSE 46038
// begin if not mc_builders [ i ] then
45889: LD_EXP 121
45893: PUSH
45894: LD_VAR 0 2
45898: ARRAY
45899: NOT
45900: IFFALSE 45958
// begin SetTag ( j , 103 ) ;
45902: LD_VAR 0 3
45906: PPUSH
45907: LD_INT 103
45909: PPUSH
45910: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45914: LD_ADDR_EXP 121
45918: PUSH
45919: LD_EXP 121
45923: PPUSH
45924: LD_VAR 0 2
45928: PUSH
45929: LD_EXP 121
45933: PUSH
45934: LD_VAR 0 2
45938: ARRAY
45939: PUSH
45940: LD_INT 1
45942: PLUS
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PPUSH
45948: LD_VAR 0 3
45952: PPUSH
45953: CALL 71059 0 3
45957: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45958: LD_VAR 0 3
45962: PPUSH
45963: CALL_OW 310
45967: IFFALSE 45978
// ComExitBuilding ( j ) ;
45969: LD_VAR 0 3
45973: PPUSH
45974: CALL_OW 122
// wait ( 3 ) ;
45978: LD_INT 3
45980: PPUSH
45981: CALL_OW 67
// if not mc_construct_list [ i ] then
45985: LD_EXP 122
45989: PUSH
45990: LD_VAR 0 2
45994: ARRAY
45995: NOT
45996: IFFALSE 46000
// break ;
45998: GO 46038
// if not HasTask ( j ) then
46000: LD_VAR 0 3
46004: PPUSH
46005: CALL_OW 314
46009: NOT
46010: IFFALSE 46036
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
46012: LD_VAR 0 3
46016: PPUSH
46017: LD_EXP 122
46021: PUSH
46022: LD_VAR 0 2
46026: ARRAY
46027: PUSH
46028: LD_INT 1
46030: ARRAY
46031: PPUSH
46032: CALL 73922 0 2
// end ;
46036: GO 45886
46038: POP
46039: POP
// end else
46040: GO 46873
// if mc_build_list [ i ] then
46042: LD_EXP 120
46046: PUSH
46047: LD_VAR 0 2
46051: ARRAY
46052: IFFALSE 46873
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46054: LD_ADDR_VAR 0 5
46058: PUSH
46059: LD_EXP 115
46063: PUSH
46064: LD_VAR 0 2
46068: ARRAY
46069: PPUSH
46070: LD_INT 2
46072: PUSH
46073: LD_INT 30
46075: PUSH
46076: LD_INT 0
46078: PUSH
46079: EMPTY
46080: LIST
46081: LIST
46082: PUSH
46083: LD_INT 30
46085: PUSH
46086: LD_INT 1
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: EMPTY
46094: LIST
46095: LIST
46096: LIST
46097: PPUSH
46098: CALL_OW 72
46102: ST_TO_ADDR
// if depot then
46103: LD_VAR 0 5
46107: IFFALSE 46125
// depot := depot [ 1 ] else
46109: LD_ADDR_VAR 0 5
46113: PUSH
46114: LD_VAR 0 5
46118: PUSH
46119: LD_INT 1
46121: ARRAY
46122: ST_TO_ADDR
46123: GO 46133
// depot := 0 ;
46125: LD_ADDR_VAR 0 5
46129: PUSH
46130: LD_INT 0
46132: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46133: LD_EXP 120
46137: PUSH
46138: LD_VAR 0 2
46142: ARRAY
46143: PUSH
46144: LD_INT 1
46146: ARRAY
46147: PUSH
46148: LD_INT 1
46150: ARRAY
46151: PPUSH
46152: CALL 73746 0 1
46156: PUSH
46157: LD_EXP 115
46161: PUSH
46162: LD_VAR 0 2
46166: ARRAY
46167: PPUSH
46168: LD_INT 2
46170: PUSH
46171: LD_INT 30
46173: PUSH
46174: LD_INT 2
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: PUSH
46181: LD_INT 30
46183: PUSH
46184: LD_INT 3
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: LIST
46195: PPUSH
46196: CALL_OW 72
46200: NOT
46201: AND
46202: IFFALSE 46307
// begin for j = 1 to mc_build_list [ i ] do
46204: LD_ADDR_VAR 0 3
46208: PUSH
46209: DOUBLE
46210: LD_INT 1
46212: DEC
46213: ST_TO_ADDR
46214: LD_EXP 120
46218: PUSH
46219: LD_VAR 0 2
46223: ARRAY
46224: PUSH
46225: FOR_TO
46226: IFFALSE 46305
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46228: LD_EXP 120
46232: PUSH
46233: LD_VAR 0 2
46237: ARRAY
46238: PUSH
46239: LD_VAR 0 3
46243: ARRAY
46244: PUSH
46245: LD_INT 1
46247: ARRAY
46248: PUSH
46249: LD_INT 2
46251: EQUAL
46252: IFFALSE 46303
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46254: LD_ADDR_EXP 120
46258: PUSH
46259: LD_EXP 120
46263: PPUSH
46264: LD_VAR 0 2
46268: PPUSH
46269: LD_EXP 120
46273: PUSH
46274: LD_VAR 0 2
46278: ARRAY
46279: PPUSH
46280: LD_VAR 0 3
46284: PPUSH
46285: LD_INT 1
46287: PPUSH
46288: LD_INT 0
46290: PPUSH
46291: CALL 70477 0 4
46295: PPUSH
46296: CALL_OW 1
46300: ST_TO_ADDR
// break ;
46301: GO 46305
// end ;
46303: GO 46225
46305: POP
46306: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46307: LD_EXP 120
46311: PUSH
46312: LD_VAR 0 2
46316: ARRAY
46317: PUSH
46318: LD_INT 1
46320: ARRAY
46321: PUSH
46322: LD_INT 1
46324: ARRAY
46325: PUSH
46326: LD_INT 0
46328: EQUAL
46329: PUSH
46330: LD_VAR 0 5
46334: PUSH
46335: LD_VAR 0 5
46339: PPUSH
46340: LD_EXP 120
46344: PUSH
46345: LD_VAR 0 2
46349: ARRAY
46350: PUSH
46351: LD_INT 1
46353: ARRAY
46354: PUSH
46355: LD_INT 1
46357: ARRAY
46358: PPUSH
46359: LD_EXP 120
46363: PUSH
46364: LD_VAR 0 2
46368: ARRAY
46369: PUSH
46370: LD_INT 1
46372: ARRAY
46373: PUSH
46374: LD_INT 2
46376: ARRAY
46377: PPUSH
46378: LD_EXP 120
46382: PUSH
46383: LD_VAR 0 2
46387: ARRAY
46388: PUSH
46389: LD_INT 1
46391: ARRAY
46392: PUSH
46393: LD_INT 3
46395: ARRAY
46396: PPUSH
46397: LD_EXP 120
46401: PUSH
46402: LD_VAR 0 2
46406: ARRAY
46407: PUSH
46408: LD_INT 1
46410: ARRAY
46411: PUSH
46412: LD_INT 4
46414: ARRAY
46415: PPUSH
46416: CALL 79162 0 5
46420: AND
46421: OR
46422: IFFALSE 46703
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46424: LD_ADDR_VAR 0 4
46428: PUSH
46429: LD_EXP 115
46433: PUSH
46434: LD_VAR 0 2
46438: ARRAY
46439: PPUSH
46440: LD_INT 25
46442: PUSH
46443: LD_INT 2
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PPUSH
46450: CALL_OW 72
46454: PUSH
46455: LD_EXP 117
46459: PUSH
46460: LD_VAR 0 2
46464: ARRAY
46465: DIFF
46466: ST_TO_ADDR
// if not tmp then
46467: LD_VAR 0 4
46471: NOT
46472: IFFALSE 46476
// continue ;
46474: GO 45721
// for j in tmp do
46476: LD_ADDR_VAR 0 3
46480: PUSH
46481: LD_VAR 0 4
46485: PUSH
46486: FOR_IN
46487: IFFALSE 46699
// begin if not mc_builders [ i ] then
46489: LD_EXP 121
46493: PUSH
46494: LD_VAR 0 2
46498: ARRAY
46499: NOT
46500: IFFALSE 46558
// begin SetTag ( j , 103 ) ;
46502: LD_VAR 0 3
46506: PPUSH
46507: LD_INT 103
46509: PPUSH
46510: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46514: LD_ADDR_EXP 121
46518: PUSH
46519: LD_EXP 121
46523: PPUSH
46524: LD_VAR 0 2
46528: PUSH
46529: LD_EXP 121
46533: PUSH
46534: LD_VAR 0 2
46538: ARRAY
46539: PUSH
46540: LD_INT 1
46542: PLUS
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PPUSH
46548: LD_VAR 0 3
46552: PPUSH
46553: CALL 71059 0 3
46557: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46558: LD_VAR 0 3
46562: PPUSH
46563: CALL_OW 310
46567: IFFALSE 46578
// ComExitBuilding ( j ) ;
46569: LD_VAR 0 3
46573: PPUSH
46574: CALL_OW 122
// wait ( 3 ) ;
46578: LD_INT 3
46580: PPUSH
46581: CALL_OW 67
// if not mc_build_list [ i ] then
46585: LD_EXP 120
46589: PUSH
46590: LD_VAR 0 2
46594: ARRAY
46595: NOT
46596: IFFALSE 46600
// break ;
46598: GO 46699
// if not HasTask ( j ) then
46600: LD_VAR 0 3
46604: PPUSH
46605: CALL_OW 314
46609: NOT
46610: IFFALSE 46697
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46612: LD_VAR 0 3
46616: PPUSH
46617: LD_EXP 120
46621: PUSH
46622: LD_VAR 0 2
46626: ARRAY
46627: PUSH
46628: LD_INT 1
46630: ARRAY
46631: PUSH
46632: LD_INT 1
46634: ARRAY
46635: PPUSH
46636: LD_EXP 120
46640: PUSH
46641: LD_VAR 0 2
46645: ARRAY
46646: PUSH
46647: LD_INT 1
46649: ARRAY
46650: PUSH
46651: LD_INT 2
46653: ARRAY
46654: PPUSH
46655: LD_EXP 120
46659: PUSH
46660: LD_VAR 0 2
46664: ARRAY
46665: PUSH
46666: LD_INT 1
46668: ARRAY
46669: PUSH
46670: LD_INT 3
46672: ARRAY
46673: PPUSH
46674: LD_EXP 120
46678: PUSH
46679: LD_VAR 0 2
46683: ARRAY
46684: PUSH
46685: LD_INT 1
46687: ARRAY
46688: PUSH
46689: LD_INT 4
46691: ARRAY
46692: PPUSH
46693: CALL_OW 145
// end ;
46697: GO 46486
46699: POP
46700: POP
// end else
46701: GO 46873
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46703: LD_EXP 115
46707: PUSH
46708: LD_VAR 0 2
46712: ARRAY
46713: PPUSH
46714: LD_EXP 120
46718: PUSH
46719: LD_VAR 0 2
46723: ARRAY
46724: PUSH
46725: LD_INT 1
46727: ARRAY
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PPUSH
46733: LD_EXP 120
46737: PUSH
46738: LD_VAR 0 2
46742: ARRAY
46743: PUSH
46744: LD_INT 1
46746: ARRAY
46747: PUSH
46748: LD_INT 2
46750: ARRAY
46751: PPUSH
46752: LD_EXP 120
46756: PUSH
46757: LD_VAR 0 2
46761: ARRAY
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: PUSH
46767: LD_INT 3
46769: ARRAY
46770: PPUSH
46771: LD_EXP 120
46775: PUSH
46776: LD_VAR 0 2
46780: ARRAY
46781: PUSH
46782: LD_INT 1
46784: ARRAY
46785: PUSH
46786: LD_INT 4
46788: ARRAY
46789: PPUSH
46790: LD_EXP 115
46794: PUSH
46795: LD_VAR 0 2
46799: ARRAY
46800: PPUSH
46801: LD_INT 21
46803: PUSH
46804: LD_INT 3
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PPUSH
46811: CALL_OW 72
46815: PPUSH
46816: EMPTY
46817: PPUSH
46818: CALL 77912 0 7
46822: NOT
46823: IFFALSE 46873
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46825: LD_ADDR_EXP 120
46829: PUSH
46830: LD_EXP 120
46834: PPUSH
46835: LD_VAR 0 2
46839: PPUSH
46840: LD_EXP 120
46844: PUSH
46845: LD_VAR 0 2
46849: ARRAY
46850: PPUSH
46851: LD_INT 1
46853: PPUSH
46854: LD_INT 1
46856: NEG
46857: PPUSH
46858: LD_INT 0
46860: PPUSH
46861: CALL 70477 0 4
46865: PPUSH
46866: CALL_OW 1
46870: ST_TO_ADDR
// continue ;
46871: GO 45721
// end ; end ; end ;
46873: GO 45721
46875: POP
46876: POP
// end ;
46877: LD_VAR 0 1
46881: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46882: LD_INT 0
46884: PPUSH
46885: PPUSH
46886: PPUSH
46887: PPUSH
46888: PPUSH
46889: PPUSH
// if not mc_bases then
46890: LD_EXP 115
46894: NOT
46895: IFFALSE 46899
// exit ;
46897: GO 47326
// for i = 1 to mc_bases do
46899: LD_ADDR_VAR 0 2
46903: PUSH
46904: DOUBLE
46905: LD_INT 1
46907: DEC
46908: ST_TO_ADDR
46909: LD_EXP 115
46913: PUSH
46914: FOR_TO
46915: IFFALSE 47324
// begin tmp := mc_build_upgrade [ i ] ;
46917: LD_ADDR_VAR 0 4
46921: PUSH
46922: LD_EXP 147
46926: PUSH
46927: LD_VAR 0 2
46931: ARRAY
46932: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46933: LD_ADDR_VAR 0 6
46937: PUSH
46938: LD_EXP 148
46942: PUSH
46943: LD_VAR 0 2
46947: ARRAY
46948: PPUSH
46949: LD_INT 2
46951: PUSH
46952: LD_INT 30
46954: PUSH
46955: LD_INT 6
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PUSH
46962: LD_INT 30
46964: PUSH
46965: LD_INT 7
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: LIST
46976: PPUSH
46977: CALL_OW 72
46981: ST_TO_ADDR
// if not tmp and not lab then
46982: LD_VAR 0 4
46986: NOT
46987: PUSH
46988: LD_VAR 0 6
46992: NOT
46993: AND
46994: IFFALSE 46998
// continue ;
46996: GO 46914
// if tmp then
46998: LD_VAR 0 4
47002: IFFALSE 47122
// for j in tmp do
47004: LD_ADDR_VAR 0 3
47008: PUSH
47009: LD_VAR 0 4
47013: PUSH
47014: FOR_IN
47015: IFFALSE 47120
// begin if UpgradeCost ( j ) then
47017: LD_VAR 0 3
47021: PPUSH
47022: CALL 77572 0 1
47026: IFFALSE 47118
// begin ComUpgrade ( j ) ;
47028: LD_VAR 0 3
47032: PPUSH
47033: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
47037: LD_ADDR_EXP 147
47041: PUSH
47042: LD_EXP 147
47046: PPUSH
47047: LD_VAR 0 2
47051: PPUSH
47052: LD_EXP 147
47056: PUSH
47057: LD_VAR 0 2
47061: ARRAY
47062: PUSH
47063: LD_VAR 0 3
47067: DIFF
47068: PPUSH
47069: CALL_OW 1
47073: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47074: LD_ADDR_EXP 122
47078: PUSH
47079: LD_EXP 122
47083: PPUSH
47084: LD_VAR 0 2
47088: PUSH
47089: LD_EXP 122
47093: PUSH
47094: LD_VAR 0 2
47098: ARRAY
47099: PUSH
47100: LD_INT 1
47102: PLUS
47103: PUSH
47104: EMPTY
47105: LIST
47106: LIST
47107: PPUSH
47108: LD_VAR 0 3
47112: PPUSH
47113: CALL 71059 0 3
47117: ST_TO_ADDR
// end ; end ;
47118: GO 47014
47120: POP
47121: POP
// if not lab or not mc_lab_upgrade [ i ] then
47122: LD_VAR 0 6
47126: NOT
47127: PUSH
47128: LD_EXP 149
47132: PUSH
47133: LD_VAR 0 2
47137: ARRAY
47138: NOT
47139: OR
47140: IFFALSE 47144
// continue ;
47142: GO 46914
// for j in lab do
47144: LD_ADDR_VAR 0 3
47148: PUSH
47149: LD_VAR 0 6
47153: PUSH
47154: FOR_IN
47155: IFFALSE 47320
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47157: LD_VAR 0 3
47161: PPUSH
47162: CALL_OW 266
47166: PUSH
47167: LD_INT 6
47169: PUSH
47170: LD_INT 7
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: IN
47177: PUSH
47178: LD_VAR 0 3
47182: PPUSH
47183: CALL_OW 461
47187: PUSH
47188: LD_INT 1
47190: NONEQUAL
47191: AND
47192: IFFALSE 47318
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47194: LD_VAR 0 3
47198: PPUSH
47199: LD_EXP 149
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: PUSH
47210: LD_INT 1
47212: ARRAY
47213: PPUSH
47214: CALL 77777 0 2
47218: IFFALSE 47318
// begin ComCancel ( j ) ;
47220: LD_VAR 0 3
47224: PPUSH
47225: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47229: LD_VAR 0 3
47233: PPUSH
47234: LD_EXP 149
47238: PUSH
47239: LD_VAR 0 2
47243: ARRAY
47244: PUSH
47245: LD_INT 1
47247: ARRAY
47248: PPUSH
47249: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47253: LD_VAR 0 3
47257: PUSH
47258: LD_EXP 122
47262: PUSH
47263: LD_VAR 0 2
47267: ARRAY
47268: IN
47269: NOT
47270: IFFALSE 47316
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47272: LD_ADDR_EXP 122
47276: PUSH
47277: LD_EXP 122
47281: PPUSH
47282: LD_VAR 0 2
47286: PUSH
47287: LD_EXP 122
47291: PUSH
47292: LD_VAR 0 2
47296: ARRAY
47297: PUSH
47298: LD_INT 1
47300: PLUS
47301: PUSH
47302: EMPTY
47303: LIST
47304: LIST
47305: PPUSH
47306: LD_VAR 0 3
47310: PPUSH
47311: CALL 71059 0 3
47315: ST_TO_ADDR
// break ;
47316: GO 47320
// end ; end ; end ;
47318: GO 47154
47320: POP
47321: POP
// end ;
47322: GO 46914
47324: POP
47325: POP
// end ;
47326: LD_VAR 0 1
47330: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47331: LD_INT 0
47333: PPUSH
47334: PPUSH
47335: PPUSH
47336: PPUSH
47337: PPUSH
47338: PPUSH
47339: PPUSH
47340: PPUSH
47341: PPUSH
// if not mc_bases then
47342: LD_EXP 115
47346: NOT
47347: IFFALSE 47351
// exit ;
47349: GO 47756
// for i = 1 to mc_bases do
47351: LD_ADDR_VAR 0 2
47355: PUSH
47356: DOUBLE
47357: LD_INT 1
47359: DEC
47360: ST_TO_ADDR
47361: LD_EXP 115
47365: PUSH
47366: FOR_TO
47367: IFFALSE 47754
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47369: LD_EXP 123
47373: PUSH
47374: LD_VAR 0 2
47378: ARRAY
47379: NOT
47380: PUSH
47381: LD_EXP 115
47385: PUSH
47386: LD_VAR 0 2
47390: ARRAY
47391: PPUSH
47392: LD_INT 30
47394: PUSH
47395: LD_INT 3
47397: PUSH
47398: EMPTY
47399: LIST
47400: LIST
47401: PPUSH
47402: CALL_OW 72
47406: NOT
47407: OR
47408: IFFALSE 47412
// continue ;
47410: GO 47366
// busy := false ;
47412: LD_ADDR_VAR 0 8
47416: PUSH
47417: LD_INT 0
47419: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47420: LD_ADDR_VAR 0 4
47424: PUSH
47425: LD_EXP 115
47429: PUSH
47430: LD_VAR 0 2
47434: ARRAY
47435: PPUSH
47436: LD_INT 30
47438: PUSH
47439: LD_INT 3
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: PPUSH
47446: CALL_OW 72
47450: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47451: LD_ADDR_VAR 0 6
47455: PUSH
47456: LD_EXP 123
47460: PUSH
47461: LD_VAR 0 2
47465: ARRAY
47466: PPUSH
47467: LD_INT 2
47469: PUSH
47470: LD_INT 30
47472: PUSH
47473: LD_INT 32
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PUSH
47480: LD_INT 30
47482: PUSH
47483: LD_INT 33
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: LIST
47494: PPUSH
47495: CALL_OW 72
47499: ST_TO_ADDR
// if not t then
47500: LD_VAR 0 6
47504: NOT
47505: IFFALSE 47509
// continue ;
47507: GO 47366
// for j in tmp do
47509: LD_ADDR_VAR 0 3
47513: PUSH
47514: LD_VAR 0 4
47518: PUSH
47519: FOR_IN
47520: IFFALSE 47550
// if not BuildingStatus ( j ) = bs_idle then
47522: LD_VAR 0 3
47526: PPUSH
47527: CALL_OW 461
47531: PUSH
47532: LD_INT 2
47534: EQUAL
47535: NOT
47536: IFFALSE 47548
// begin busy := true ;
47538: LD_ADDR_VAR 0 8
47542: PUSH
47543: LD_INT 1
47545: ST_TO_ADDR
// break ;
47546: GO 47550
// end ;
47548: GO 47519
47550: POP
47551: POP
// if busy then
47552: LD_VAR 0 8
47556: IFFALSE 47560
// continue ;
47558: GO 47366
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47560: LD_ADDR_VAR 0 7
47564: PUSH
47565: LD_VAR 0 6
47569: PPUSH
47570: LD_INT 35
47572: PUSH
47573: LD_INT 0
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PPUSH
47580: CALL_OW 72
47584: ST_TO_ADDR
// if tw then
47585: LD_VAR 0 7
47589: IFFALSE 47666
// begin tw := tw [ 1 ] ;
47591: LD_ADDR_VAR 0 7
47595: PUSH
47596: LD_VAR 0 7
47600: PUSH
47601: LD_INT 1
47603: ARRAY
47604: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47605: LD_ADDR_VAR 0 9
47609: PUSH
47610: LD_VAR 0 7
47614: PPUSH
47615: LD_EXP 140
47619: PUSH
47620: LD_VAR 0 2
47624: ARRAY
47625: PPUSH
47626: CALL 76069 0 2
47630: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47631: LD_EXP 154
47635: PUSH
47636: LD_VAR 0 2
47640: ARRAY
47641: IFFALSE 47664
// if not weapon in mc_allowed_tower_weapons [ i ] then
47643: LD_VAR 0 9
47647: PUSH
47648: LD_EXP 154
47652: PUSH
47653: LD_VAR 0 2
47657: ARRAY
47658: IN
47659: NOT
47660: IFFALSE 47664
// continue ;
47662: GO 47366
// end else
47664: GO 47729
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47666: LD_ADDR_VAR 0 5
47670: PUSH
47671: LD_EXP 123
47675: PUSH
47676: LD_VAR 0 2
47680: ARRAY
47681: PPUSH
47682: LD_VAR 0 4
47686: PPUSH
47687: CALL 102869 0 2
47691: ST_TO_ADDR
// if not tmp2 then
47692: LD_VAR 0 5
47696: NOT
47697: IFFALSE 47701
// continue ;
47699: GO 47366
// tw := tmp2 [ 1 ] ;
47701: LD_ADDR_VAR 0 7
47705: PUSH
47706: LD_VAR 0 5
47710: PUSH
47711: LD_INT 1
47713: ARRAY
47714: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47715: LD_ADDR_VAR 0 9
47719: PUSH
47720: LD_VAR 0 5
47724: PUSH
47725: LD_INT 2
47727: ARRAY
47728: ST_TO_ADDR
// end ; if not weapon then
47729: LD_VAR 0 9
47733: NOT
47734: IFFALSE 47738
// continue ;
47736: GO 47366
// ComPlaceWeapon ( tw , weapon ) ;
47738: LD_VAR 0 7
47742: PPUSH
47743: LD_VAR 0 9
47747: PPUSH
47748: CALL_OW 148
// end ;
47752: GO 47366
47754: POP
47755: POP
// end ;
47756: LD_VAR 0 1
47760: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47761: LD_INT 0
47763: PPUSH
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
// if not mc_bases then
47770: LD_EXP 115
47774: NOT
47775: IFFALSE 47779
// exit ;
47777: GO 48547
// for i = 1 to mc_bases do
47779: LD_ADDR_VAR 0 2
47783: PUSH
47784: DOUBLE
47785: LD_INT 1
47787: DEC
47788: ST_TO_ADDR
47789: LD_EXP 115
47793: PUSH
47794: FOR_TO
47795: IFFALSE 48545
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47797: LD_EXP 128
47801: PUSH
47802: LD_VAR 0 2
47806: ARRAY
47807: NOT
47808: PUSH
47809: LD_EXP 128
47813: PUSH
47814: LD_VAR 0 2
47818: ARRAY
47819: PUSH
47820: LD_EXP 129
47824: PUSH
47825: LD_VAR 0 2
47829: ARRAY
47830: EQUAL
47831: OR
47832: PUSH
47833: LD_EXP 138
47837: PUSH
47838: LD_VAR 0 2
47842: ARRAY
47843: OR
47844: IFFALSE 47848
// continue ;
47846: GO 47794
// if mc_miners [ i ] then
47848: LD_EXP 129
47852: PUSH
47853: LD_VAR 0 2
47857: ARRAY
47858: IFFALSE 48232
// begin for j = mc_miners [ i ] downto 1 do
47860: LD_ADDR_VAR 0 3
47864: PUSH
47865: DOUBLE
47866: LD_EXP 129
47870: PUSH
47871: LD_VAR 0 2
47875: ARRAY
47876: INC
47877: ST_TO_ADDR
47878: LD_INT 1
47880: PUSH
47881: FOR_DOWNTO
47882: IFFALSE 48230
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47884: LD_EXP 129
47888: PUSH
47889: LD_VAR 0 2
47893: ARRAY
47894: PUSH
47895: LD_VAR 0 3
47899: ARRAY
47900: PPUSH
47901: CALL_OW 301
47905: PUSH
47906: LD_EXP 129
47910: PUSH
47911: LD_VAR 0 2
47915: ARRAY
47916: PUSH
47917: LD_VAR 0 3
47921: ARRAY
47922: PPUSH
47923: CALL_OW 257
47927: PUSH
47928: LD_INT 1
47930: NONEQUAL
47931: OR
47932: IFFALSE 47995
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47934: LD_ADDR_VAR 0 5
47938: PUSH
47939: LD_EXP 129
47943: PUSH
47944: LD_VAR 0 2
47948: ARRAY
47949: PUSH
47950: LD_EXP 129
47954: PUSH
47955: LD_VAR 0 2
47959: ARRAY
47960: PUSH
47961: LD_VAR 0 3
47965: ARRAY
47966: DIFF
47967: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47968: LD_ADDR_EXP 129
47972: PUSH
47973: LD_EXP 129
47977: PPUSH
47978: LD_VAR 0 2
47982: PPUSH
47983: LD_VAR 0 5
47987: PPUSH
47988: CALL_OW 1
47992: ST_TO_ADDR
// continue ;
47993: GO 47881
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47995: LD_EXP 129
47999: PUSH
48000: LD_VAR 0 2
48004: ARRAY
48005: PUSH
48006: LD_VAR 0 3
48010: ARRAY
48011: PPUSH
48012: CALL_OW 257
48016: PUSH
48017: LD_INT 1
48019: EQUAL
48020: PUSH
48021: LD_EXP 129
48025: PUSH
48026: LD_VAR 0 2
48030: ARRAY
48031: PUSH
48032: LD_VAR 0 3
48036: ARRAY
48037: PPUSH
48038: CALL_OW 459
48042: NOT
48043: AND
48044: PUSH
48045: LD_EXP 129
48049: PUSH
48050: LD_VAR 0 2
48054: ARRAY
48055: PUSH
48056: LD_VAR 0 3
48060: ARRAY
48061: PPUSH
48062: CALL_OW 314
48066: NOT
48067: AND
48068: IFFALSE 48228
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48070: LD_EXP 129
48074: PUSH
48075: LD_VAR 0 2
48079: ARRAY
48080: PUSH
48081: LD_VAR 0 3
48085: ARRAY
48086: PPUSH
48087: CALL_OW 310
48091: IFFALSE 48114
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48093: LD_EXP 129
48097: PUSH
48098: LD_VAR 0 2
48102: ARRAY
48103: PUSH
48104: LD_VAR 0 3
48108: ARRAY
48109: PPUSH
48110: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48114: LD_EXP 129
48118: PUSH
48119: LD_VAR 0 2
48123: ARRAY
48124: PUSH
48125: LD_VAR 0 3
48129: ARRAY
48130: PPUSH
48131: CALL_OW 314
48135: NOT
48136: IFFALSE 48228
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48138: LD_ADDR_VAR 0 7
48142: PUSH
48143: LD_INT 1
48145: PPUSH
48146: LD_EXP 128
48150: PUSH
48151: LD_VAR 0 2
48155: ARRAY
48156: PPUSH
48157: CALL_OW 12
48161: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48162: LD_EXP 129
48166: PUSH
48167: LD_VAR 0 2
48171: ARRAY
48172: PUSH
48173: LD_VAR 0 3
48177: ARRAY
48178: PPUSH
48179: LD_EXP 128
48183: PUSH
48184: LD_VAR 0 2
48188: ARRAY
48189: PUSH
48190: LD_VAR 0 7
48194: ARRAY
48195: PUSH
48196: LD_INT 1
48198: ARRAY
48199: PPUSH
48200: LD_EXP 128
48204: PUSH
48205: LD_VAR 0 2
48209: ARRAY
48210: PUSH
48211: LD_VAR 0 7
48215: ARRAY
48216: PUSH
48217: LD_INT 2
48219: ARRAY
48220: PPUSH
48221: LD_INT 0
48223: PPUSH
48224: CALL_OW 193
// end ; end ; end ;
48228: GO 47881
48230: POP
48231: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48232: LD_ADDR_VAR 0 5
48236: PUSH
48237: LD_EXP 115
48241: PUSH
48242: LD_VAR 0 2
48246: ARRAY
48247: PPUSH
48248: LD_INT 2
48250: PUSH
48251: LD_INT 30
48253: PUSH
48254: LD_INT 4
48256: PUSH
48257: EMPTY
48258: LIST
48259: LIST
48260: PUSH
48261: LD_INT 30
48263: PUSH
48264: LD_INT 5
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: PUSH
48271: LD_INT 30
48273: PUSH
48274: LD_INT 32
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: PPUSH
48287: CALL_OW 72
48291: ST_TO_ADDR
// if not tmp then
48292: LD_VAR 0 5
48296: NOT
48297: IFFALSE 48301
// continue ;
48299: GO 47794
// list := [ ] ;
48301: LD_ADDR_VAR 0 6
48305: PUSH
48306: EMPTY
48307: ST_TO_ADDR
// for j in tmp do
48308: LD_ADDR_VAR 0 3
48312: PUSH
48313: LD_VAR 0 5
48317: PUSH
48318: FOR_IN
48319: IFFALSE 48388
// begin for k in UnitsInside ( j ) do
48321: LD_ADDR_VAR 0 4
48325: PUSH
48326: LD_VAR 0 3
48330: PPUSH
48331: CALL_OW 313
48335: PUSH
48336: FOR_IN
48337: IFFALSE 48384
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48339: LD_VAR 0 4
48343: PPUSH
48344: CALL_OW 257
48348: PUSH
48349: LD_INT 1
48351: EQUAL
48352: PUSH
48353: LD_VAR 0 4
48357: PPUSH
48358: CALL_OW 459
48362: NOT
48363: AND
48364: IFFALSE 48382
// list := list ^ k ;
48366: LD_ADDR_VAR 0 6
48370: PUSH
48371: LD_VAR 0 6
48375: PUSH
48376: LD_VAR 0 4
48380: ADD
48381: ST_TO_ADDR
48382: GO 48336
48384: POP
48385: POP
// end ;
48386: GO 48318
48388: POP
48389: POP
// list := list diff mc_miners [ i ] ;
48390: LD_ADDR_VAR 0 6
48394: PUSH
48395: LD_VAR 0 6
48399: PUSH
48400: LD_EXP 129
48404: PUSH
48405: LD_VAR 0 2
48409: ARRAY
48410: DIFF
48411: ST_TO_ADDR
// if not list then
48412: LD_VAR 0 6
48416: NOT
48417: IFFALSE 48421
// continue ;
48419: GO 47794
// k := mc_mines [ i ] - mc_miners [ i ] ;
48421: LD_ADDR_VAR 0 4
48425: PUSH
48426: LD_EXP 128
48430: PUSH
48431: LD_VAR 0 2
48435: ARRAY
48436: PUSH
48437: LD_EXP 129
48441: PUSH
48442: LD_VAR 0 2
48446: ARRAY
48447: MINUS
48448: ST_TO_ADDR
// if k > list then
48449: LD_VAR 0 4
48453: PUSH
48454: LD_VAR 0 6
48458: GREATER
48459: IFFALSE 48471
// k := list ;
48461: LD_ADDR_VAR 0 4
48465: PUSH
48466: LD_VAR 0 6
48470: ST_TO_ADDR
// for j = 1 to k do
48471: LD_ADDR_VAR 0 3
48475: PUSH
48476: DOUBLE
48477: LD_INT 1
48479: DEC
48480: ST_TO_ADDR
48481: LD_VAR 0 4
48485: PUSH
48486: FOR_TO
48487: IFFALSE 48541
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48489: LD_ADDR_EXP 129
48493: PUSH
48494: LD_EXP 129
48498: PPUSH
48499: LD_VAR 0 2
48503: PUSH
48504: LD_EXP 129
48508: PUSH
48509: LD_VAR 0 2
48513: ARRAY
48514: PUSH
48515: LD_INT 1
48517: PLUS
48518: PUSH
48519: EMPTY
48520: LIST
48521: LIST
48522: PPUSH
48523: LD_VAR 0 6
48527: PUSH
48528: LD_VAR 0 3
48532: ARRAY
48533: PPUSH
48534: CALL 71059 0 3
48538: ST_TO_ADDR
48539: GO 48486
48541: POP
48542: POP
// end ;
48543: GO 47794
48545: POP
48546: POP
// end ;
48547: LD_VAR 0 1
48551: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48552: LD_INT 0
48554: PPUSH
48555: PPUSH
48556: PPUSH
48557: PPUSH
48558: PPUSH
48559: PPUSH
48560: PPUSH
48561: PPUSH
48562: PPUSH
48563: PPUSH
48564: PPUSH
// if not mc_bases then
48565: LD_EXP 115
48569: NOT
48570: IFFALSE 48574
// exit ;
48572: GO 50397
// for i = 1 to mc_bases do
48574: LD_ADDR_VAR 0 2
48578: PUSH
48579: DOUBLE
48580: LD_INT 1
48582: DEC
48583: ST_TO_ADDR
48584: LD_EXP 115
48588: PUSH
48589: FOR_TO
48590: IFFALSE 50395
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48592: LD_EXP 115
48596: PUSH
48597: LD_VAR 0 2
48601: ARRAY
48602: NOT
48603: PUSH
48604: LD_EXP 122
48608: PUSH
48609: LD_VAR 0 2
48613: ARRAY
48614: OR
48615: IFFALSE 48619
// continue ;
48617: GO 48589
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48619: LD_EXP 131
48623: PUSH
48624: LD_VAR 0 2
48628: ARRAY
48629: NOT
48630: PUSH
48631: LD_EXP 132
48635: PUSH
48636: LD_VAR 0 2
48640: ARRAY
48641: AND
48642: IFFALSE 48680
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48644: LD_ADDR_EXP 132
48648: PUSH
48649: LD_EXP 132
48653: PPUSH
48654: LD_VAR 0 2
48658: PPUSH
48659: EMPTY
48660: PPUSH
48661: CALL_OW 1
48665: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48666: LD_VAR 0 2
48670: PPUSH
48671: LD_INT 107
48673: PPUSH
48674: CALL 39448 0 2
// continue ;
48678: GO 48589
// end ; target := [ ] ;
48680: LD_ADDR_VAR 0 7
48684: PUSH
48685: EMPTY
48686: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48687: LD_ADDR_VAR 0 6
48691: PUSH
48692: LD_EXP 115
48696: PUSH
48697: LD_VAR 0 2
48701: ARRAY
48702: PUSH
48703: LD_INT 1
48705: ARRAY
48706: PPUSH
48707: CALL_OW 255
48711: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48712: LD_ADDR_VAR 0 9
48716: PUSH
48717: LD_EXP 115
48721: PUSH
48722: LD_VAR 0 2
48726: ARRAY
48727: PPUSH
48728: LD_INT 2
48730: PUSH
48731: LD_INT 30
48733: PUSH
48734: LD_INT 0
48736: PUSH
48737: EMPTY
48738: LIST
48739: LIST
48740: PUSH
48741: LD_INT 30
48743: PUSH
48744: LD_INT 1
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: PUSH
48751: EMPTY
48752: LIST
48753: LIST
48754: LIST
48755: PPUSH
48756: CALL_OW 72
48760: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48761: LD_ADDR_VAR 0 3
48765: PUSH
48766: DOUBLE
48767: LD_EXP 131
48771: PUSH
48772: LD_VAR 0 2
48776: ARRAY
48777: INC
48778: ST_TO_ADDR
48779: LD_INT 1
48781: PUSH
48782: FOR_DOWNTO
48783: IFFALSE 49028
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48785: LD_EXP 131
48789: PUSH
48790: LD_VAR 0 2
48794: ARRAY
48795: PUSH
48796: LD_VAR 0 3
48800: ARRAY
48801: PUSH
48802: LD_INT 2
48804: ARRAY
48805: PPUSH
48806: LD_EXP 131
48810: PUSH
48811: LD_VAR 0 2
48815: ARRAY
48816: PUSH
48817: LD_VAR 0 3
48821: ARRAY
48822: PUSH
48823: LD_INT 3
48825: ARRAY
48826: PPUSH
48827: CALL_OW 488
48831: PUSH
48832: LD_EXP 131
48836: PUSH
48837: LD_VAR 0 2
48841: ARRAY
48842: PUSH
48843: LD_VAR 0 3
48847: ARRAY
48848: PUSH
48849: LD_INT 2
48851: ARRAY
48852: PPUSH
48853: LD_EXP 131
48857: PUSH
48858: LD_VAR 0 2
48862: ARRAY
48863: PUSH
48864: LD_VAR 0 3
48868: ARRAY
48869: PUSH
48870: LD_INT 3
48872: ARRAY
48873: PPUSH
48874: CALL_OW 284
48878: PUSH
48879: LD_INT 0
48881: EQUAL
48882: AND
48883: IFFALSE 48938
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48885: LD_ADDR_VAR 0 5
48889: PUSH
48890: LD_EXP 131
48894: PUSH
48895: LD_VAR 0 2
48899: ARRAY
48900: PPUSH
48901: LD_VAR 0 3
48905: PPUSH
48906: CALL_OW 3
48910: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48911: LD_ADDR_EXP 131
48915: PUSH
48916: LD_EXP 131
48920: PPUSH
48921: LD_VAR 0 2
48925: PPUSH
48926: LD_VAR 0 5
48930: PPUSH
48931: CALL_OW 1
48935: ST_TO_ADDR
// continue ;
48936: GO 48782
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48938: LD_VAR 0 6
48942: PPUSH
48943: LD_EXP 131
48947: PUSH
48948: LD_VAR 0 2
48952: ARRAY
48953: PUSH
48954: LD_VAR 0 3
48958: ARRAY
48959: PUSH
48960: LD_INT 2
48962: ARRAY
48963: PPUSH
48964: LD_EXP 131
48968: PUSH
48969: LD_VAR 0 2
48973: ARRAY
48974: PUSH
48975: LD_VAR 0 3
48979: ARRAY
48980: PUSH
48981: LD_INT 3
48983: ARRAY
48984: PPUSH
48985: LD_INT 30
48987: PPUSH
48988: CALL 71955 0 4
48992: PUSH
48993: LD_INT 4
48995: ARRAY
48996: PUSH
48997: LD_INT 0
48999: EQUAL
49000: IFFALSE 49026
// begin target := mc_crates [ i ] [ j ] ;
49002: LD_ADDR_VAR 0 7
49006: PUSH
49007: LD_EXP 131
49011: PUSH
49012: LD_VAR 0 2
49016: ARRAY
49017: PUSH
49018: LD_VAR 0 3
49022: ARRAY
49023: ST_TO_ADDR
// break ;
49024: GO 49028
// end ; end ;
49026: GO 48782
49028: POP
49029: POP
// if not target then
49030: LD_VAR 0 7
49034: NOT
49035: IFFALSE 49039
// continue ;
49037: GO 48589
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
49039: LD_ADDR_VAR 0 8
49043: PUSH
49044: LD_EXP 134
49048: PUSH
49049: LD_VAR 0 2
49053: ARRAY
49054: PPUSH
49055: LD_INT 2
49057: PUSH
49058: LD_INT 3
49060: PUSH
49061: LD_INT 58
49063: PUSH
49064: EMPTY
49065: LIST
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: PUSH
49071: LD_INT 61
49073: PUSH
49074: EMPTY
49075: LIST
49076: PUSH
49077: LD_INT 33
49079: PUSH
49080: LD_INT 5
49082: PUSH
49083: EMPTY
49084: LIST
49085: LIST
49086: PUSH
49087: LD_INT 33
49089: PUSH
49090: LD_INT 3
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 2
49106: PUSH
49107: LD_INT 34
49109: PUSH
49110: LD_INT 32
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 34
49119: PUSH
49120: LD_INT 51
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 34
49129: PUSH
49130: LD_INT 12
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PPUSH
49147: CALL_OW 72
49151: ST_TO_ADDR
// if not cargo then
49152: LD_VAR 0 8
49156: NOT
49157: IFFALSE 49863
// begin if mc_crates_collector [ i ] < 5 then
49159: LD_EXP 132
49163: PUSH
49164: LD_VAR 0 2
49168: ARRAY
49169: PUSH
49170: LD_INT 5
49172: LESS
49173: IFFALSE 49539
// begin if mc_ape [ i ] then
49175: LD_EXP 144
49179: PUSH
49180: LD_VAR 0 2
49184: ARRAY
49185: IFFALSE 49232
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49187: LD_ADDR_VAR 0 5
49191: PUSH
49192: LD_EXP 144
49196: PUSH
49197: LD_VAR 0 2
49201: ARRAY
49202: PPUSH
49203: LD_INT 25
49205: PUSH
49206: LD_INT 16
49208: PUSH
49209: EMPTY
49210: LIST
49211: LIST
49212: PUSH
49213: LD_INT 24
49215: PUSH
49216: LD_INT 750
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PUSH
49223: EMPTY
49224: LIST
49225: LIST
49226: PPUSH
49227: CALL_OW 72
49231: ST_TO_ADDR
// if not tmp then
49232: LD_VAR 0 5
49236: NOT
49237: IFFALSE 49284
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49239: LD_ADDR_VAR 0 5
49243: PUSH
49244: LD_EXP 115
49248: PUSH
49249: LD_VAR 0 2
49253: ARRAY
49254: PPUSH
49255: LD_INT 25
49257: PUSH
49258: LD_INT 2
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: PUSH
49265: LD_INT 24
49267: PUSH
49268: LD_INT 750
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: PPUSH
49279: CALL_OW 72
49283: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49284: LD_EXP 144
49288: PUSH
49289: LD_VAR 0 2
49293: ARRAY
49294: PUSH
49295: LD_EXP 115
49299: PUSH
49300: LD_VAR 0 2
49304: ARRAY
49305: PPUSH
49306: LD_INT 25
49308: PUSH
49309: LD_INT 2
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: PUSH
49316: LD_INT 24
49318: PUSH
49319: LD_INT 750
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: EMPTY
49327: LIST
49328: LIST
49329: PPUSH
49330: CALL_OW 72
49334: AND
49335: PUSH
49336: LD_VAR 0 5
49340: PUSH
49341: LD_INT 5
49343: LESS
49344: AND
49345: IFFALSE 49427
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49347: LD_ADDR_VAR 0 3
49351: PUSH
49352: LD_EXP 115
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: PPUSH
49363: LD_INT 25
49365: PUSH
49366: LD_INT 2
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: PUSH
49373: LD_INT 24
49375: PUSH
49376: LD_INT 750
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: PUSH
49383: EMPTY
49384: LIST
49385: LIST
49386: PPUSH
49387: CALL_OW 72
49391: PUSH
49392: FOR_IN
49393: IFFALSE 49425
// begin tmp := tmp union j ;
49395: LD_ADDR_VAR 0 5
49399: PUSH
49400: LD_VAR 0 5
49404: PUSH
49405: LD_VAR 0 3
49409: UNION
49410: ST_TO_ADDR
// if tmp >= 5 then
49411: LD_VAR 0 5
49415: PUSH
49416: LD_INT 5
49418: GREATEREQUAL
49419: IFFALSE 49423
// break ;
49421: GO 49425
// end ;
49423: GO 49392
49425: POP
49426: POP
// end ; if not tmp then
49427: LD_VAR 0 5
49431: NOT
49432: IFFALSE 49436
// continue ;
49434: GO 48589
// for j in tmp do
49436: LD_ADDR_VAR 0 3
49440: PUSH
49441: LD_VAR 0 5
49445: PUSH
49446: FOR_IN
49447: IFFALSE 49537
// if not GetTag ( j ) then
49449: LD_VAR 0 3
49453: PPUSH
49454: CALL_OW 110
49458: NOT
49459: IFFALSE 49535
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49461: LD_ADDR_EXP 132
49465: PUSH
49466: LD_EXP 132
49470: PPUSH
49471: LD_VAR 0 2
49475: PUSH
49476: LD_EXP 132
49480: PUSH
49481: LD_VAR 0 2
49485: ARRAY
49486: PUSH
49487: LD_INT 1
49489: PLUS
49490: PUSH
49491: EMPTY
49492: LIST
49493: LIST
49494: PPUSH
49495: LD_VAR 0 3
49499: PPUSH
49500: CALL 71059 0 3
49504: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49505: LD_VAR 0 3
49509: PPUSH
49510: LD_INT 107
49512: PPUSH
49513: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49517: LD_EXP 132
49521: PUSH
49522: LD_VAR 0 2
49526: ARRAY
49527: PUSH
49528: LD_INT 5
49530: GREATEREQUAL
49531: IFFALSE 49535
// break ;
49533: GO 49537
// end ;
49535: GO 49446
49537: POP
49538: POP
// end ; if mc_crates_collector [ i ] and target then
49539: LD_EXP 132
49543: PUSH
49544: LD_VAR 0 2
49548: ARRAY
49549: PUSH
49550: LD_VAR 0 7
49554: AND
49555: IFFALSE 49861
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49557: LD_EXP 132
49561: PUSH
49562: LD_VAR 0 2
49566: ARRAY
49567: PUSH
49568: LD_VAR 0 7
49572: PUSH
49573: LD_INT 1
49575: ARRAY
49576: LESS
49577: IFFALSE 49597
// tmp := mc_crates_collector [ i ] else
49579: LD_ADDR_VAR 0 5
49583: PUSH
49584: LD_EXP 132
49588: PUSH
49589: LD_VAR 0 2
49593: ARRAY
49594: ST_TO_ADDR
49595: GO 49611
// tmp := target [ 1 ] ;
49597: LD_ADDR_VAR 0 5
49601: PUSH
49602: LD_VAR 0 7
49606: PUSH
49607: LD_INT 1
49609: ARRAY
49610: ST_TO_ADDR
// k := 0 ;
49611: LD_ADDR_VAR 0 4
49615: PUSH
49616: LD_INT 0
49618: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49619: LD_ADDR_VAR 0 3
49623: PUSH
49624: LD_EXP 132
49628: PUSH
49629: LD_VAR 0 2
49633: ARRAY
49634: PUSH
49635: FOR_IN
49636: IFFALSE 49859
// begin k := k + 1 ;
49638: LD_ADDR_VAR 0 4
49642: PUSH
49643: LD_VAR 0 4
49647: PUSH
49648: LD_INT 1
49650: PLUS
49651: ST_TO_ADDR
// if k > tmp then
49652: LD_VAR 0 4
49656: PUSH
49657: LD_VAR 0 5
49661: GREATER
49662: IFFALSE 49666
// break ;
49664: GO 49859
// if not GetClass ( j ) in [ 2 , 16 ] then
49666: LD_VAR 0 3
49670: PPUSH
49671: CALL_OW 257
49675: PUSH
49676: LD_INT 2
49678: PUSH
49679: LD_INT 16
49681: PUSH
49682: EMPTY
49683: LIST
49684: LIST
49685: IN
49686: NOT
49687: IFFALSE 49740
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49689: LD_ADDR_EXP 132
49693: PUSH
49694: LD_EXP 132
49698: PPUSH
49699: LD_VAR 0 2
49703: PPUSH
49704: LD_EXP 132
49708: PUSH
49709: LD_VAR 0 2
49713: ARRAY
49714: PUSH
49715: LD_VAR 0 3
49719: DIFF
49720: PPUSH
49721: CALL_OW 1
49725: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49726: LD_VAR 0 3
49730: PPUSH
49731: LD_INT 0
49733: PPUSH
49734: CALL_OW 109
// continue ;
49738: GO 49635
// end ; if IsInUnit ( j ) then
49740: LD_VAR 0 3
49744: PPUSH
49745: CALL_OW 310
49749: IFFALSE 49760
// ComExitBuilding ( j ) ;
49751: LD_VAR 0 3
49755: PPUSH
49756: CALL_OW 122
// wait ( 3 ) ;
49760: LD_INT 3
49762: PPUSH
49763: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49767: LD_VAR 0 3
49771: PPUSH
49772: CALL_OW 314
49776: PUSH
49777: LD_VAR 0 6
49781: PPUSH
49782: LD_VAR 0 7
49786: PUSH
49787: LD_INT 2
49789: ARRAY
49790: PPUSH
49791: LD_VAR 0 7
49795: PUSH
49796: LD_INT 3
49798: ARRAY
49799: PPUSH
49800: LD_INT 30
49802: PPUSH
49803: CALL 71955 0 4
49807: PUSH
49808: LD_INT 4
49810: ARRAY
49811: AND
49812: IFFALSE 49830
// ComStandNearbyBuilding ( j , depot ) else
49814: LD_VAR 0 3
49818: PPUSH
49819: LD_VAR 0 9
49823: PPUSH
49824: CALL 67484 0 2
49828: GO 49857
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49830: LD_VAR 0 3
49834: PPUSH
49835: LD_VAR 0 7
49839: PUSH
49840: LD_INT 2
49842: ARRAY
49843: PPUSH
49844: LD_VAR 0 7
49848: PUSH
49849: LD_INT 3
49851: ARRAY
49852: PPUSH
49853: CALL_OW 117
// end ;
49857: GO 49635
49859: POP
49860: POP
// end ; end else
49861: GO 50393
// begin for j in cargo do
49863: LD_ADDR_VAR 0 3
49867: PUSH
49868: LD_VAR 0 8
49872: PUSH
49873: FOR_IN
49874: IFFALSE 50391
// begin if GetTag ( j ) <> 0 then
49876: LD_VAR 0 3
49880: PPUSH
49881: CALL_OW 110
49885: PUSH
49886: LD_INT 0
49888: NONEQUAL
49889: IFFALSE 49893
// continue ;
49891: GO 49873
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49893: LD_VAR 0 3
49897: PPUSH
49898: CALL_OW 256
49902: PUSH
49903: LD_INT 1000
49905: LESS
49906: PUSH
49907: LD_VAR 0 3
49911: PPUSH
49912: LD_EXP 139
49916: PUSH
49917: LD_VAR 0 2
49921: ARRAY
49922: PPUSH
49923: CALL_OW 308
49927: NOT
49928: AND
49929: IFFALSE 49951
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49931: LD_VAR 0 3
49935: PPUSH
49936: LD_EXP 139
49940: PUSH
49941: LD_VAR 0 2
49945: ARRAY
49946: PPUSH
49947: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49951: LD_VAR 0 3
49955: PPUSH
49956: CALL_OW 256
49960: PUSH
49961: LD_INT 1000
49963: LESS
49964: PUSH
49965: LD_VAR 0 3
49969: PPUSH
49970: LD_EXP 139
49974: PUSH
49975: LD_VAR 0 2
49979: ARRAY
49980: PPUSH
49981: CALL_OW 308
49985: AND
49986: IFFALSE 49990
// continue ;
49988: GO 49873
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49990: LD_VAR 0 3
49994: PPUSH
49995: CALL_OW 262
49999: PUSH
50000: LD_INT 2
50002: EQUAL
50003: PUSH
50004: LD_VAR 0 3
50008: PPUSH
50009: CALL_OW 261
50013: PUSH
50014: LD_INT 15
50016: LESS
50017: AND
50018: IFFALSE 50022
// continue ;
50020: GO 49873
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
50022: LD_VAR 0 3
50026: PPUSH
50027: CALL_OW 262
50031: PUSH
50032: LD_INT 1
50034: EQUAL
50035: PUSH
50036: LD_VAR 0 3
50040: PPUSH
50041: CALL_OW 261
50045: PUSH
50046: LD_INT 10
50048: LESS
50049: AND
50050: IFFALSE 50330
// begin if not depot then
50052: LD_VAR 0 9
50056: NOT
50057: IFFALSE 50061
// continue ;
50059: GO 49873
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50061: LD_VAR 0 3
50065: PPUSH
50066: LD_VAR 0 9
50070: PPUSH
50071: LD_VAR 0 3
50075: PPUSH
50076: CALL_OW 74
50080: PPUSH
50081: CALL_OW 296
50085: PUSH
50086: LD_INT 6
50088: LESS
50089: IFFALSE 50105
// SetFuel ( j , 100 ) else
50091: LD_VAR 0 3
50095: PPUSH
50096: LD_INT 100
50098: PPUSH
50099: CALL_OW 240
50103: GO 50330
// if GetFuel ( j ) = 0 then
50105: LD_VAR 0 3
50109: PPUSH
50110: CALL_OW 261
50114: PUSH
50115: LD_INT 0
50117: EQUAL
50118: IFFALSE 50330
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50120: LD_ADDR_EXP 134
50124: PUSH
50125: LD_EXP 134
50129: PPUSH
50130: LD_VAR 0 2
50134: PPUSH
50135: LD_EXP 134
50139: PUSH
50140: LD_VAR 0 2
50144: ARRAY
50145: PUSH
50146: LD_VAR 0 3
50150: DIFF
50151: PPUSH
50152: CALL_OW 1
50156: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50157: LD_VAR 0 3
50161: PPUSH
50162: CALL_OW 263
50166: PUSH
50167: LD_INT 1
50169: EQUAL
50170: IFFALSE 50186
// ComExitVehicle ( IsInUnit ( j ) ) ;
50172: LD_VAR 0 3
50176: PPUSH
50177: CALL_OW 310
50181: PPUSH
50182: CALL_OW 121
// if GetControl ( j ) = control_remote then
50186: LD_VAR 0 3
50190: PPUSH
50191: CALL_OW 263
50195: PUSH
50196: LD_INT 2
50198: EQUAL
50199: IFFALSE 50210
// ComUnlink ( j ) ;
50201: LD_VAR 0 3
50205: PPUSH
50206: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50210: LD_ADDR_VAR 0 10
50214: PUSH
50215: LD_VAR 0 2
50219: PPUSH
50220: LD_INT 3
50222: PPUSH
50223: CALL 59969 0 2
50227: ST_TO_ADDR
// if fac then
50228: LD_VAR 0 10
50232: IFFALSE 50328
// begin for k in fac do
50234: LD_ADDR_VAR 0 4
50238: PUSH
50239: LD_VAR 0 10
50243: PUSH
50244: FOR_IN
50245: IFFALSE 50326
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50247: LD_ADDR_VAR 0 11
50251: PUSH
50252: LD_VAR 0 10
50256: PPUSH
50257: LD_VAR 0 3
50261: PPUSH
50262: CALL_OW 265
50266: PPUSH
50267: LD_VAR 0 3
50271: PPUSH
50272: CALL_OW 262
50276: PPUSH
50277: LD_VAR 0 3
50281: PPUSH
50282: CALL_OW 263
50286: PPUSH
50287: LD_VAR 0 3
50291: PPUSH
50292: CALL_OW 264
50296: PPUSH
50297: CALL 68555 0 5
50301: ST_TO_ADDR
// if components then
50302: LD_VAR 0 11
50306: IFFALSE 50324
// begin MC_InsertProduceList ( i , components ) ;
50308: LD_VAR 0 2
50312: PPUSH
50313: LD_VAR 0 11
50317: PPUSH
50318: CALL 59514 0 2
// break ;
50322: GO 50326
// end ; end ;
50324: GO 50244
50326: POP
50327: POP
// end ; continue ;
50328: GO 49873
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50330: LD_VAR 0 3
50334: PPUSH
50335: LD_INT 1
50337: PPUSH
50338: CALL_OW 289
50342: PUSH
50343: LD_INT 100
50345: LESS
50346: PUSH
50347: LD_VAR 0 3
50351: PPUSH
50352: CALL_OW 314
50356: NOT
50357: AND
50358: IFFALSE 50387
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50360: LD_VAR 0 3
50364: PPUSH
50365: LD_VAR 0 7
50369: PUSH
50370: LD_INT 2
50372: ARRAY
50373: PPUSH
50374: LD_VAR 0 7
50378: PUSH
50379: LD_INT 3
50381: ARRAY
50382: PPUSH
50383: CALL_OW 117
// break ;
50387: GO 50391
// end ;
50389: GO 49873
50391: POP
50392: POP
// end ; end ;
50393: GO 48589
50395: POP
50396: POP
// end ;
50397: LD_VAR 0 1
50401: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50402: LD_INT 0
50404: PPUSH
50405: PPUSH
50406: PPUSH
50407: PPUSH
// if not mc_bases then
50408: LD_EXP 115
50412: NOT
50413: IFFALSE 50417
// exit ;
50415: GO 50578
// for i = 1 to mc_bases do
50417: LD_ADDR_VAR 0 2
50421: PUSH
50422: DOUBLE
50423: LD_INT 1
50425: DEC
50426: ST_TO_ADDR
50427: LD_EXP 115
50431: PUSH
50432: FOR_TO
50433: IFFALSE 50576
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50435: LD_ADDR_VAR 0 4
50439: PUSH
50440: LD_EXP 134
50444: PUSH
50445: LD_VAR 0 2
50449: ARRAY
50450: PUSH
50451: LD_EXP 137
50455: PUSH
50456: LD_VAR 0 2
50460: ARRAY
50461: UNION
50462: PPUSH
50463: LD_INT 33
50465: PUSH
50466: LD_INT 2
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: PPUSH
50473: CALL_OW 72
50477: ST_TO_ADDR
// if tmp then
50478: LD_VAR 0 4
50482: IFFALSE 50574
// for j in tmp do
50484: LD_ADDR_VAR 0 3
50488: PUSH
50489: LD_VAR 0 4
50493: PUSH
50494: FOR_IN
50495: IFFALSE 50572
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50497: LD_VAR 0 3
50501: PPUSH
50502: CALL_OW 312
50506: NOT
50507: PUSH
50508: LD_VAR 0 3
50512: PPUSH
50513: CALL_OW 256
50517: PUSH
50518: LD_INT 250
50520: GREATEREQUAL
50521: AND
50522: IFFALSE 50535
// Connect ( j ) else
50524: LD_VAR 0 3
50528: PPUSH
50529: CALL 74030 0 1
50533: GO 50570
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50535: LD_VAR 0 3
50539: PPUSH
50540: CALL_OW 256
50544: PUSH
50545: LD_INT 250
50547: LESS
50548: PUSH
50549: LD_VAR 0 3
50553: PPUSH
50554: CALL_OW 312
50558: AND
50559: IFFALSE 50570
// ComUnlink ( j ) ;
50561: LD_VAR 0 3
50565: PPUSH
50566: CALL_OW 136
50570: GO 50494
50572: POP
50573: POP
// end ;
50574: GO 50432
50576: POP
50577: POP
// end ;
50578: LD_VAR 0 1
50582: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50583: LD_INT 0
50585: PPUSH
50586: PPUSH
50587: PPUSH
50588: PPUSH
50589: PPUSH
// if not mc_bases then
50590: LD_EXP 115
50594: NOT
50595: IFFALSE 50599
// exit ;
50597: GO 51044
// for i = 1 to mc_bases do
50599: LD_ADDR_VAR 0 2
50603: PUSH
50604: DOUBLE
50605: LD_INT 1
50607: DEC
50608: ST_TO_ADDR
50609: LD_EXP 115
50613: PUSH
50614: FOR_TO
50615: IFFALSE 51042
// begin if not mc_produce [ i ] then
50617: LD_EXP 136
50621: PUSH
50622: LD_VAR 0 2
50626: ARRAY
50627: NOT
50628: IFFALSE 50632
// continue ;
50630: GO 50614
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50632: LD_ADDR_VAR 0 5
50636: PUSH
50637: LD_EXP 115
50641: PUSH
50642: LD_VAR 0 2
50646: ARRAY
50647: PPUSH
50648: LD_INT 30
50650: PUSH
50651: LD_INT 3
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PPUSH
50658: CALL_OW 72
50662: ST_TO_ADDR
// if not fac then
50663: LD_VAR 0 5
50667: NOT
50668: IFFALSE 50672
// continue ;
50670: GO 50614
// for j in fac do
50672: LD_ADDR_VAR 0 3
50676: PUSH
50677: LD_VAR 0 5
50681: PUSH
50682: FOR_IN
50683: IFFALSE 51038
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50685: LD_VAR 0 3
50689: PPUSH
50690: CALL_OW 461
50694: PUSH
50695: LD_INT 2
50697: NONEQUAL
50698: PUSH
50699: LD_VAR 0 3
50703: PPUSH
50704: LD_INT 15
50706: PPUSH
50707: CALL 73658 0 2
50711: PUSH
50712: LD_INT 4
50714: ARRAY
50715: OR
50716: IFFALSE 50720
// continue ;
50718: GO 50682
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50720: LD_VAR 0 3
50724: PPUSH
50725: LD_EXP 136
50729: PUSH
50730: LD_VAR 0 2
50734: ARRAY
50735: PUSH
50736: LD_INT 1
50738: ARRAY
50739: PUSH
50740: LD_INT 1
50742: ARRAY
50743: PPUSH
50744: LD_EXP 136
50748: PUSH
50749: LD_VAR 0 2
50753: ARRAY
50754: PUSH
50755: LD_INT 1
50757: ARRAY
50758: PUSH
50759: LD_INT 2
50761: ARRAY
50762: PPUSH
50763: LD_EXP 136
50767: PUSH
50768: LD_VAR 0 2
50772: ARRAY
50773: PUSH
50774: LD_INT 1
50776: ARRAY
50777: PUSH
50778: LD_INT 3
50780: ARRAY
50781: PPUSH
50782: LD_EXP 136
50786: PUSH
50787: LD_VAR 0 2
50791: ARRAY
50792: PUSH
50793: LD_INT 1
50795: ARRAY
50796: PUSH
50797: LD_INT 4
50799: ARRAY
50800: PPUSH
50801: CALL_OW 448
50805: PUSH
50806: LD_VAR 0 3
50810: PPUSH
50811: LD_EXP 136
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PUSH
50826: LD_INT 1
50828: ARRAY
50829: PUSH
50830: LD_EXP 136
50834: PUSH
50835: LD_VAR 0 2
50839: ARRAY
50840: PUSH
50841: LD_INT 1
50843: ARRAY
50844: PUSH
50845: LD_INT 2
50847: ARRAY
50848: PUSH
50849: LD_EXP 136
50853: PUSH
50854: LD_VAR 0 2
50858: ARRAY
50859: PUSH
50860: LD_INT 1
50862: ARRAY
50863: PUSH
50864: LD_INT 3
50866: ARRAY
50867: PUSH
50868: LD_EXP 136
50872: PUSH
50873: LD_VAR 0 2
50877: ARRAY
50878: PUSH
50879: LD_INT 1
50881: ARRAY
50882: PUSH
50883: LD_INT 4
50885: ARRAY
50886: PUSH
50887: EMPTY
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: PPUSH
50893: CALL 77425 0 2
50897: AND
50898: IFFALSE 51036
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50900: LD_VAR 0 3
50904: PPUSH
50905: LD_EXP 136
50909: PUSH
50910: LD_VAR 0 2
50914: ARRAY
50915: PUSH
50916: LD_INT 1
50918: ARRAY
50919: PUSH
50920: LD_INT 1
50922: ARRAY
50923: PPUSH
50924: LD_EXP 136
50928: PUSH
50929: LD_VAR 0 2
50933: ARRAY
50934: PUSH
50935: LD_INT 1
50937: ARRAY
50938: PUSH
50939: LD_INT 2
50941: ARRAY
50942: PPUSH
50943: LD_EXP 136
50947: PUSH
50948: LD_VAR 0 2
50952: ARRAY
50953: PUSH
50954: LD_INT 1
50956: ARRAY
50957: PUSH
50958: LD_INT 3
50960: ARRAY
50961: PPUSH
50962: LD_EXP 136
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: PUSH
50973: LD_INT 1
50975: ARRAY
50976: PUSH
50977: LD_INT 4
50979: ARRAY
50980: PPUSH
50981: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50985: LD_ADDR_VAR 0 4
50989: PUSH
50990: LD_EXP 136
50994: PUSH
50995: LD_VAR 0 2
50999: ARRAY
51000: PPUSH
51001: LD_INT 1
51003: PPUSH
51004: CALL_OW 3
51008: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51009: LD_ADDR_EXP 136
51013: PUSH
51014: LD_EXP 136
51018: PPUSH
51019: LD_VAR 0 2
51023: PPUSH
51024: LD_VAR 0 4
51028: PPUSH
51029: CALL_OW 1
51033: ST_TO_ADDR
// break ;
51034: GO 51038
// end ; end ;
51036: GO 50682
51038: POP
51039: POP
// end ;
51040: GO 50614
51042: POP
51043: POP
// end ;
51044: LD_VAR 0 1
51048: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51049: LD_INT 0
51051: PPUSH
51052: PPUSH
51053: PPUSH
// if not mc_bases then
51054: LD_EXP 115
51058: NOT
51059: IFFALSE 51063
// exit ;
51061: GO 51152
// for i = 1 to mc_bases do
51063: LD_ADDR_VAR 0 2
51067: PUSH
51068: DOUBLE
51069: LD_INT 1
51071: DEC
51072: ST_TO_ADDR
51073: LD_EXP 115
51077: PUSH
51078: FOR_TO
51079: IFFALSE 51150
// begin if mc_attack [ i ] then
51081: LD_EXP 135
51085: PUSH
51086: LD_VAR 0 2
51090: ARRAY
51091: IFFALSE 51148
// begin tmp := mc_attack [ i ] [ 1 ] ;
51093: LD_ADDR_VAR 0 3
51097: PUSH
51098: LD_EXP 135
51102: PUSH
51103: LD_VAR 0 2
51107: ARRAY
51108: PUSH
51109: LD_INT 1
51111: ARRAY
51112: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51113: LD_ADDR_EXP 135
51117: PUSH
51118: LD_EXP 135
51122: PPUSH
51123: LD_VAR 0 2
51127: PPUSH
51128: EMPTY
51129: PPUSH
51130: CALL_OW 1
51134: ST_TO_ADDR
// Attack ( tmp ) ;
51135: LD_VAR 0 3
51139: PPUSH
51140: CALL 127098 0 1
// exit ;
51144: POP
51145: POP
51146: GO 51152
// end ; end ;
51148: GO 51078
51150: POP
51151: POP
// end ;
51152: LD_VAR 0 1
51156: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51157: LD_INT 0
51159: PPUSH
51160: PPUSH
51161: PPUSH
51162: PPUSH
51163: PPUSH
51164: PPUSH
51165: PPUSH
// if not mc_bases then
51166: LD_EXP 115
51170: NOT
51171: IFFALSE 51175
// exit ;
51173: GO 52032
// for i = 1 to mc_bases do
51175: LD_ADDR_VAR 0 2
51179: PUSH
51180: DOUBLE
51181: LD_INT 1
51183: DEC
51184: ST_TO_ADDR
51185: LD_EXP 115
51189: PUSH
51190: FOR_TO
51191: IFFALSE 52030
// begin if not mc_bases [ i ] then
51193: LD_EXP 115
51197: PUSH
51198: LD_VAR 0 2
51202: ARRAY
51203: NOT
51204: IFFALSE 51208
// continue ;
51206: GO 51190
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51208: LD_ADDR_VAR 0 7
51212: PUSH
51213: LD_EXP 115
51217: PUSH
51218: LD_VAR 0 2
51222: ARRAY
51223: PUSH
51224: LD_INT 1
51226: ARRAY
51227: PPUSH
51228: CALL 67706 0 1
51232: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51233: LD_ADDR_EXP 138
51237: PUSH
51238: LD_EXP 138
51242: PPUSH
51243: LD_VAR 0 2
51247: PPUSH
51248: LD_EXP 115
51252: PUSH
51253: LD_VAR 0 2
51257: ARRAY
51258: PUSH
51259: LD_INT 1
51261: ARRAY
51262: PPUSH
51263: CALL_OW 255
51267: PPUSH
51268: LD_EXP 140
51272: PUSH
51273: LD_VAR 0 2
51277: ARRAY
51278: PPUSH
51279: CALL 67671 0 2
51283: PPUSH
51284: CALL_OW 1
51288: ST_TO_ADDR
// if not mc_scan [ i ] then
51289: LD_EXP 138
51293: PUSH
51294: LD_VAR 0 2
51298: ARRAY
51299: NOT
51300: IFFALSE 51478
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51302: LD_ADDR_EXP 158
51306: PUSH
51307: LD_EXP 158
51311: PPUSH
51312: LD_VAR 0 2
51316: PPUSH
51317: LD_INT 0
51319: PPUSH
51320: CALL_OW 1
51324: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51325: LD_ADDR_VAR 0 4
51329: PUSH
51330: LD_EXP 115
51334: PUSH
51335: LD_VAR 0 2
51339: ARRAY
51340: PPUSH
51341: LD_INT 2
51343: PUSH
51344: LD_INT 25
51346: PUSH
51347: LD_INT 5
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: PUSH
51354: LD_INT 25
51356: PUSH
51357: LD_INT 8
51359: PUSH
51360: EMPTY
51361: LIST
51362: LIST
51363: PUSH
51364: LD_INT 25
51366: PUSH
51367: LD_INT 9
51369: PUSH
51370: EMPTY
51371: LIST
51372: LIST
51373: PUSH
51374: EMPTY
51375: LIST
51376: LIST
51377: LIST
51378: LIST
51379: PPUSH
51380: CALL_OW 72
51384: ST_TO_ADDR
// if not tmp then
51385: LD_VAR 0 4
51389: NOT
51390: IFFALSE 51394
// continue ;
51392: GO 51190
// for j in tmp do
51394: LD_ADDR_VAR 0 3
51398: PUSH
51399: LD_VAR 0 4
51403: PUSH
51404: FOR_IN
51405: IFFALSE 51476
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51407: LD_VAR 0 3
51411: PPUSH
51412: CALL_OW 310
51416: PPUSH
51417: CALL_OW 266
51421: PUSH
51422: LD_INT 5
51424: EQUAL
51425: PUSH
51426: LD_VAR 0 3
51430: PPUSH
51431: CALL_OW 257
51435: PUSH
51436: LD_INT 1
51438: EQUAL
51439: AND
51440: PUSH
51441: LD_VAR 0 3
51445: PPUSH
51446: CALL_OW 459
51450: NOT
51451: AND
51452: PUSH
51453: LD_VAR 0 7
51457: AND
51458: IFFALSE 51474
// ComChangeProfession ( j , class ) ;
51460: LD_VAR 0 3
51464: PPUSH
51465: LD_VAR 0 7
51469: PPUSH
51470: CALL_OW 123
51474: GO 51404
51476: POP
51477: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51478: LD_EXP 138
51482: PUSH
51483: LD_VAR 0 2
51487: ARRAY
51488: PUSH
51489: LD_EXP 158
51493: PUSH
51494: LD_VAR 0 2
51498: ARRAY
51499: NOT
51500: AND
51501: PUSH
51502: LD_EXP 137
51506: PUSH
51507: LD_VAR 0 2
51511: ARRAY
51512: NOT
51513: AND
51514: PUSH
51515: LD_EXP 115
51519: PUSH
51520: LD_VAR 0 2
51524: ARRAY
51525: PPUSH
51526: LD_INT 50
51528: PUSH
51529: EMPTY
51530: LIST
51531: PUSH
51532: LD_INT 2
51534: PUSH
51535: LD_INT 30
51537: PUSH
51538: LD_INT 32
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: PUSH
51545: LD_INT 30
51547: PUSH
51548: LD_INT 33
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: PUSH
51555: LD_INT 30
51557: PUSH
51558: LD_INT 4
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: PUSH
51565: LD_INT 30
51567: PUSH
51568: LD_INT 5
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: EMPTY
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: LIST
51581: PUSH
51582: EMPTY
51583: LIST
51584: LIST
51585: PPUSH
51586: CALL_OW 72
51590: PUSH
51591: LD_INT 4
51593: LESS
51594: PUSH
51595: LD_EXP 115
51599: PUSH
51600: LD_VAR 0 2
51604: ARRAY
51605: PPUSH
51606: LD_INT 3
51608: PUSH
51609: LD_INT 24
51611: PUSH
51612: LD_INT 1000
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PUSH
51623: LD_INT 2
51625: PUSH
51626: LD_INT 30
51628: PUSH
51629: LD_INT 0
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: PUSH
51636: LD_INT 30
51638: PUSH
51639: LD_INT 1
51641: PUSH
51642: EMPTY
51643: LIST
51644: LIST
51645: PUSH
51646: EMPTY
51647: LIST
51648: LIST
51649: LIST
51650: PUSH
51651: EMPTY
51652: LIST
51653: LIST
51654: PPUSH
51655: CALL_OW 72
51659: OR
51660: AND
51661: IFFALSE 51912
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51663: LD_ADDR_EXP 158
51667: PUSH
51668: LD_EXP 158
51672: PPUSH
51673: LD_VAR 0 2
51677: PPUSH
51678: LD_INT 1
51680: PPUSH
51681: CALL_OW 1
51685: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51686: LD_ADDR_VAR 0 4
51690: PUSH
51691: LD_EXP 115
51695: PUSH
51696: LD_VAR 0 2
51700: ARRAY
51701: PPUSH
51702: LD_INT 2
51704: PUSH
51705: LD_INT 25
51707: PUSH
51708: LD_INT 1
51710: PUSH
51711: EMPTY
51712: LIST
51713: LIST
51714: PUSH
51715: LD_INT 25
51717: PUSH
51718: LD_INT 5
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: PUSH
51725: LD_INT 25
51727: PUSH
51728: LD_INT 8
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: PUSH
51735: LD_INT 25
51737: PUSH
51738: LD_INT 9
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: LIST
51749: LIST
51750: LIST
51751: PPUSH
51752: CALL_OW 72
51756: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51757: LD_ADDR_VAR 0 4
51761: PUSH
51762: LD_VAR 0 4
51766: PUSH
51767: LD_VAR 0 4
51771: PPUSH
51772: LD_INT 18
51774: PPUSH
51775: CALL 100895 0 2
51779: DIFF
51780: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51781: LD_VAR 0 4
51785: NOT
51786: PUSH
51787: LD_EXP 115
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PPUSH
51798: LD_INT 2
51800: PUSH
51801: LD_INT 30
51803: PUSH
51804: LD_INT 4
51806: PUSH
51807: EMPTY
51808: LIST
51809: LIST
51810: PUSH
51811: LD_INT 30
51813: PUSH
51814: LD_INT 5
51816: PUSH
51817: EMPTY
51818: LIST
51819: LIST
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: LIST
51825: PPUSH
51826: CALL_OW 72
51830: NOT
51831: AND
51832: IFFALSE 51894
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51834: LD_ADDR_VAR 0 4
51838: PUSH
51839: LD_EXP 115
51843: PUSH
51844: LD_VAR 0 2
51848: ARRAY
51849: PPUSH
51850: LD_INT 2
51852: PUSH
51853: LD_INT 25
51855: PUSH
51856: LD_INT 2
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PUSH
51863: LD_INT 25
51865: PUSH
51866: LD_INT 3
51868: PUSH
51869: EMPTY
51870: LIST
51871: LIST
51872: PUSH
51873: LD_INT 25
51875: PUSH
51876: LD_INT 4
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: PUSH
51883: EMPTY
51884: LIST
51885: LIST
51886: LIST
51887: LIST
51888: PPUSH
51889: CALL_OW 72
51893: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51894: LD_VAR 0 2
51898: PPUSH
51899: LD_VAR 0 4
51903: PPUSH
51904: CALL 131807 0 2
// exit ;
51908: POP
51909: POP
51910: GO 52032
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51912: LD_EXP 138
51916: PUSH
51917: LD_VAR 0 2
51921: ARRAY
51922: PUSH
51923: LD_EXP 158
51927: PUSH
51928: LD_VAR 0 2
51932: ARRAY
51933: NOT
51934: AND
51935: PUSH
51936: LD_EXP 137
51940: PUSH
51941: LD_VAR 0 2
51945: ARRAY
51946: AND
51947: IFFALSE 52028
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51949: LD_ADDR_EXP 158
51953: PUSH
51954: LD_EXP 158
51958: PPUSH
51959: LD_VAR 0 2
51963: PPUSH
51964: LD_INT 1
51966: PPUSH
51967: CALL_OW 1
51971: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51972: LD_ADDR_VAR 0 4
51976: PUSH
51977: LD_EXP 137
51981: PUSH
51982: LD_VAR 0 2
51986: ARRAY
51987: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51988: LD_ADDR_EXP 137
51992: PUSH
51993: LD_EXP 137
51997: PPUSH
51998: LD_VAR 0 2
52002: PPUSH
52003: EMPTY
52004: PPUSH
52005: CALL_OW 1
52009: ST_TO_ADDR
// Defend ( i , tmp ) ;
52010: LD_VAR 0 2
52014: PPUSH
52015: LD_VAR 0 4
52019: PPUSH
52020: CALL 132403 0 2
// exit ;
52024: POP
52025: POP
52026: GO 52032
// end ; end ;
52028: GO 51190
52030: POP
52031: POP
// end ;
52032: LD_VAR 0 1
52036: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
52037: LD_INT 0
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
52044: PPUSH
52045: PPUSH
52046: PPUSH
52047: PPUSH
52048: PPUSH
52049: PPUSH
// if not mc_bases then
52050: LD_EXP 115
52054: NOT
52055: IFFALSE 52059
// exit ;
52057: GO 53146
// for i = 1 to mc_bases do
52059: LD_ADDR_VAR 0 2
52063: PUSH
52064: DOUBLE
52065: LD_INT 1
52067: DEC
52068: ST_TO_ADDR
52069: LD_EXP 115
52073: PUSH
52074: FOR_TO
52075: IFFALSE 53144
// begin tmp := mc_lab [ i ] ;
52077: LD_ADDR_VAR 0 6
52081: PUSH
52082: LD_EXP 148
52086: PUSH
52087: LD_VAR 0 2
52091: ARRAY
52092: ST_TO_ADDR
// if not tmp then
52093: LD_VAR 0 6
52097: NOT
52098: IFFALSE 52102
// continue ;
52100: GO 52074
// idle_lab := 0 ;
52102: LD_ADDR_VAR 0 11
52106: PUSH
52107: LD_INT 0
52109: ST_TO_ADDR
// for j in tmp do
52110: LD_ADDR_VAR 0 3
52114: PUSH
52115: LD_VAR 0 6
52119: PUSH
52120: FOR_IN
52121: IFFALSE 53140
// begin researching := false ;
52123: LD_ADDR_VAR 0 10
52127: PUSH
52128: LD_INT 0
52130: ST_TO_ADDR
// side := GetSide ( j ) ;
52131: LD_ADDR_VAR 0 4
52135: PUSH
52136: LD_VAR 0 3
52140: PPUSH
52141: CALL_OW 255
52145: ST_TO_ADDR
// if not mc_tech [ side ] then
52146: LD_EXP 142
52150: PUSH
52151: LD_VAR 0 4
52155: ARRAY
52156: NOT
52157: IFFALSE 52161
// continue ;
52159: GO 52120
// if BuildingStatus ( j ) = bs_idle then
52161: LD_VAR 0 3
52165: PPUSH
52166: CALL_OW 461
52170: PUSH
52171: LD_INT 2
52173: EQUAL
52174: IFFALSE 52362
// begin if idle_lab and UnitsInside ( j ) < 6 then
52176: LD_VAR 0 11
52180: PUSH
52181: LD_VAR 0 3
52185: PPUSH
52186: CALL_OW 313
52190: PUSH
52191: LD_INT 6
52193: LESS
52194: AND
52195: IFFALSE 52266
// begin tmp2 := UnitsInside ( idle_lab ) ;
52197: LD_ADDR_VAR 0 9
52201: PUSH
52202: LD_VAR 0 11
52206: PPUSH
52207: CALL_OW 313
52211: ST_TO_ADDR
// if tmp2 then
52212: LD_VAR 0 9
52216: IFFALSE 52258
// for x in tmp2 do
52218: LD_ADDR_VAR 0 7
52222: PUSH
52223: LD_VAR 0 9
52227: PUSH
52228: FOR_IN
52229: IFFALSE 52256
// begin ComExitBuilding ( x ) ;
52231: LD_VAR 0 7
52235: PPUSH
52236: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52240: LD_VAR 0 7
52244: PPUSH
52245: LD_VAR 0 3
52249: PPUSH
52250: CALL_OW 180
// end ;
52254: GO 52228
52256: POP
52257: POP
// idle_lab := 0 ;
52258: LD_ADDR_VAR 0 11
52262: PUSH
52263: LD_INT 0
52265: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52266: LD_ADDR_VAR 0 5
52270: PUSH
52271: LD_EXP 142
52275: PUSH
52276: LD_VAR 0 4
52280: ARRAY
52281: PUSH
52282: FOR_IN
52283: IFFALSE 52343
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52285: LD_VAR 0 3
52289: PPUSH
52290: LD_VAR 0 5
52294: PPUSH
52295: CALL_OW 430
52299: PUSH
52300: LD_VAR 0 4
52304: PPUSH
52305: LD_VAR 0 5
52309: PPUSH
52310: CALL 66776 0 2
52314: AND
52315: IFFALSE 52341
// begin researching := true ;
52317: LD_ADDR_VAR 0 10
52321: PUSH
52322: LD_INT 1
52324: ST_TO_ADDR
// ComResearch ( j , t ) ;
52325: LD_VAR 0 3
52329: PPUSH
52330: LD_VAR 0 5
52334: PPUSH
52335: CALL_OW 124
// break ;
52339: GO 52343
// end ;
52341: GO 52282
52343: POP
52344: POP
// if not researching then
52345: LD_VAR 0 10
52349: NOT
52350: IFFALSE 52362
// idle_lab := j ;
52352: LD_ADDR_VAR 0 11
52356: PUSH
52357: LD_VAR 0 3
52361: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52362: LD_VAR 0 3
52366: PPUSH
52367: CALL_OW 461
52371: PUSH
52372: LD_INT 10
52374: EQUAL
52375: IFFALSE 52963
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52377: LD_EXP 144
52381: PUSH
52382: LD_VAR 0 2
52386: ARRAY
52387: NOT
52388: PUSH
52389: LD_EXP 145
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: NOT
52400: AND
52401: PUSH
52402: LD_EXP 142
52406: PUSH
52407: LD_VAR 0 4
52411: ARRAY
52412: PUSH
52413: LD_INT 1
52415: GREATER
52416: AND
52417: IFFALSE 52548
// begin ComCancel ( j ) ;
52419: LD_VAR 0 3
52423: PPUSH
52424: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52428: LD_ADDR_EXP 142
52432: PUSH
52433: LD_EXP 142
52437: PPUSH
52438: LD_VAR 0 4
52442: PPUSH
52443: LD_EXP 142
52447: PUSH
52448: LD_VAR 0 4
52452: ARRAY
52453: PPUSH
52454: LD_EXP 142
52458: PUSH
52459: LD_VAR 0 4
52463: ARRAY
52464: PUSH
52465: LD_INT 1
52467: MINUS
52468: PPUSH
52469: LD_EXP 142
52473: PUSH
52474: LD_VAR 0 4
52478: ARRAY
52479: PPUSH
52480: LD_INT 0
52482: PPUSH
52483: CALL 70477 0 4
52487: PPUSH
52488: CALL_OW 1
52492: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52493: LD_ADDR_EXP 142
52497: PUSH
52498: LD_EXP 142
52502: PPUSH
52503: LD_VAR 0 4
52507: PPUSH
52508: LD_EXP 142
52512: PUSH
52513: LD_VAR 0 4
52517: ARRAY
52518: PPUSH
52519: LD_EXP 142
52523: PUSH
52524: LD_VAR 0 4
52528: ARRAY
52529: PPUSH
52530: LD_INT 1
52532: PPUSH
52533: LD_INT 0
52535: PPUSH
52536: CALL 70477 0 4
52540: PPUSH
52541: CALL_OW 1
52545: ST_TO_ADDR
// continue ;
52546: GO 52120
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52548: LD_EXP 144
52552: PUSH
52553: LD_VAR 0 2
52557: ARRAY
52558: PUSH
52559: LD_EXP 145
52563: PUSH
52564: LD_VAR 0 2
52568: ARRAY
52569: NOT
52570: AND
52571: IFFALSE 52698
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52573: LD_ADDR_EXP 145
52577: PUSH
52578: LD_EXP 145
52582: PPUSH
52583: LD_VAR 0 2
52587: PUSH
52588: LD_EXP 145
52592: PUSH
52593: LD_VAR 0 2
52597: ARRAY
52598: PUSH
52599: LD_INT 1
52601: PLUS
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: PPUSH
52607: LD_EXP 144
52611: PUSH
52612: LD_VAR 0 2
52616: ARRAY
52617: PUSH
52618: LD_INT 1
52620: ARRAY
52621: PPUSH
52622: CALL 71059 0 3
52626: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52627: LD_EXP 144
52631: PUSH
52632: LD_VAR 0 2
52636: ARRAY
52637: PUSH
52638: LD_INT 1
52640: ARRAY
52641: PPUSH
52642: LD_INT 112
52644: PPUSH
52645: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52649: LD_ADDR_VAR 0 9
52653: PUSH
52654: LD_EXP 144
52658: PUSH
52659: LD_VAR 0 2
52663: ARRAY
52664: PPUSH
52665: LD_INT 1
52667: PPUSH
52668: CALL_OW 3
52672: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52673: LD_ADDR_EXP 144
52677: PUSH
52678: LD_EXP 144
52682: PPUSH
52683: LD_VAR 0 2
52687: PPUSH
52688: LD_VAR 0 9
52692: PPUSH
52693: CALL_OW 1
52697: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52698: LD_EXP 144
52702: PUSH
52703: LD_VAR 0 2
52707: ARRAY
52708: PUSH
52709: LD_EXP 145
52713: PUSH
52714: LD_VAR 0 2
52718: ARRAY
52719: AND
52720: PUSH
52721: LD_EXP 145
52725: PUSH
52726: LD_VAR 0 2
52730: ARRAY
52731: PUSH
52732: LD_INT 1
52734: ARRAY
52735: PPUSH
52736: CALL_OW 310
52740: NOT
52741: AND
52742: PUSH
52743: LD_VAR 0 3
52747: PPUSH
52748: CALL_OW 313
52752: PUSH
52753: LD_INT 6
52755: EQUAL
52756: AND
52757: IFFALSE 52813
// begin tmp2 := UnitsInside ( j ) ;
52759: LD_ADDR_VAR 0 9
52763: PUSH
52764: LD_VAR 0 3
52768: PPUSH
52769: CALL_OW 313
52773: ST_TO_ADDR
// if tmp2 = 6 then
52774: LD_VAR 0 9
52778: PUSH
52779: LD_INT 6
52781: EQUAL
52782: IFFALSE 52813
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52784: LD_VAR 0 9
52788: PUSH
52789: LD_INT 1
52791: ARRAY
52792: PPUSH
52793: LD_INT 112
52795: PPUSH
52796: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52800: LD_VAR 0 9
52804: PUSH
52805: LD_INT 1
52807: ARRAY
52808: PPUSH
52809: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52813: LD_EXP 145
52817: PUSH
52818: LD_VAR 0 2
52822: ARRAY
52823: PUSH
52824: LD_EXP 145
52828: PUSH
52829: LD_VAR 0 2
52833: ARRAY
52834: PUSH
52835: LD_INT 1
52837: ARRAY
52838: PPUSH
52839: CALL_OW 314
52843: NOT
52844: AND
52845: PUSH
52846: LD_EXP 145
52850: PUSH
52851: LD_VAR 0 2
52855: ARRAY
52856: PUSH
52857: LD_INT 1
52859: ARRAY
52860: PPUSH
52861: CALL_OW 310
52865: NOT
52866: AND
52867: IFFALSE 52893
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52869: LD_EXP 145
52873: PUSH
52874: LD_VAR 0 2
52878: ARRAY
52879: PUSH
52880: LD_INT 1
52882: ARRAY
52883: PPUSH
52884: LD_VAR 0 3
52888: PPUSH
52889: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52893: LD_EXP 145
52897: PUSH
52898: LD_VAR 0 2
52902: ARRAY
52903: PUSH
52904: LD_INT 1
52906: ARRAY
52907: PPUSH
52908: CALL_OW 310
52912: PUSH
52913: LD_EXP 145
52917: PUSH
52918: LD_VAR 0 2
52922: ARRAY
52923: PUSH
52924: LD_INT 1
52926: ARRAY
52927: PPUSH
52928: CALL_OW 310
52932: PPUSH
52933: CALL_OW 461
52937: PUSH
52938: LD_INT 3
52940: NONEQUAL
52941: AND
52942: IFFALSE 52963
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52944: LD_EXP 145
52948: PUSH
52949: LD_VAR 0 2
52953: ARRAY
52954: PUSH
52955: LD_INT 1
52957: ARRAY
52958: PPUSH
52959: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52963: LD_VAR 0 3
52967: PPUSH
52968: CALL_OW 461
52972: PUSH
52973: LD_INT 6
52975: EQUAL
52976: PUSH
52977: LD_VAR 0 6
52981: PUSH
52982: LD_INT 1
52984: GREATER
52985: AND
52986: IFFALSE 53138
// begin sci := [ ] ;
52988: LD_ADDR_VAR 0 8
52992: PUSH
52993: EMPTY
52994: ST_TO_ADDR
// for x in ( tmp diff j ) do
52995: LD_ADDR_VAR 0 7
52999: PUSH
53000: LD_VAR 0 6
53004: PUSH
53005: LD_VAR 0 3
53009: DIFF
53010: PUSH
53011: FOR_IN
53012: IFFALSE 53064
// begin if sci = 6 then
53014: LD_VAR 0 8
53018: PUSH
53019: LD_INT 6
53021: EQUAL
53022: IFFALSE 53026
// break ;
53024: GO 53064
// if BuildingStatus ( x ) = bs_idle then
53026: LD_VAR 0 7
53030: PPUSH
53031: CALL_OW 461
53035: PUSH
53036: LD_INT 2
53038: EQUAL
53039: IFFALSE 53062
// sci := sci ^ UnitsInside ( x ) ;
53041: LD_ADDR_VAR 0 8
53045: PUSH
53046: LD_VAR 0 8
53050: PUSH
53051: LD_VAR 0 7
53055: PPUSH
53056: CALL_OW 313
53060: ADD
53061: ST_TO_ADDR
// end ;
53062: GO 53011
53064: POP
53065: POP
// if not sci then
53066: LD_VAR 0 8
53070: NOT
53071: IFFALSE 53075
// continue ;
53073: GO 52120
// for x in sci do
53075: LD_ADDR_VAR 0 7
53079: PUSH
53080: LD_VAR 0 8
53084: PUSH
53085: FOR_IN
53086: IFFALSE 53136
// if IsInUnit ( x ) and not HasTask ( x ) then
53088: LD_VAR 0 7
53092: PPUSH
53093: CALL_OW 310
53097: PUSH
53098: LD_VAR 0 7
53102: PPUSH
53103: CALL_OW 314
53107: NOT
53108: AND
53109: IFFALSE 53134
// begin ComExitBuilding ( x ) ;
53111: LD_VAR 0 7
53115: PPUSH
53116: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53120: LD_VAR 0 7
53124: PPUSH
53125: LD_VAR 0 3
53129: PPUSH
53130: CALL_OW 180
// end ;
53134: GO 53085
53136: POP
53137: POP
// end ; end ;
53138: GO 52120
53140: POP
53141: POP
// end ;
53142: GO 52074
53144: POP
53145: POP
// end ;
53146: LD_VAR 0 1
53150: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53151: LD_INT 0
53153: PPUSH
53154: PPUSH
// if not mc_bases then
53155: LD_EXP 115
53159: NOT
53160: IFFALSE 53164
// exit ;
53162: GO 53245
// for i = 1 to mc_bases do
53164: LD_ADDR_VAR 0 2
53168: PUSH
53169: DOUBLE
53170: LD_INT 1
53172: DEC
53173: ST_TO_ADDR
53174: LD_EXP 115
53178: PUSH
53179: FOR_TO
53180: IFFALSE 53243
// if mc_mines [ i ] and mc_miners [ i ] then
53182: LD_EXP 128
53186: PUSH
53187: LD_VAR 0 2
53191: ARRAY
53192: PUSH
53193: LD_EXP 129
53197: PUSH
53198: LD_VAR 0 2
53202: ARRAY
53203: AND
53204: IFFALSE 53241
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53206: LD_EXP 129
53210: PUSH
53211: LD_VAR 0 2
53215: ARRAY
53216: PUSH
53217: LD_INT 1
53219: ARRAY
53220: PPUSH
53221: CALL_OW 255
53225: PPUSH
53226: LD_EXP 128
53230: PUSH
53231: LD_VAR 0 2
53235: ARRAY
53236: PPUSH
53237: CALL 67859 0 2
53241: GO 53179
53243: POP
53244: POP
// end ;
53245: LD_VAR 0 1
53249: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53250: LD_INT 0
53252: PPUSH
53253: PPUSH
53254: PPUSH
53255: PPUSH
53256: PPUSH
53257: PPUSH
53258: PPUSH
53259: PPUSH
// if not mc_bases or not mc_parking then
53260: LD_EXP 115
53264: NOT
53265: PUSH
53266: LD_EXP 139
53270: NOT
53271: OR
53272: IFFALSE 53276
// exit ;
53274: GO 53986
// for i = 1 to mc_bases do
53276: LD_ADDR_VAR 0 2
53280: PUSH
53281: DOUBLE
53282: LD_INT 1
53284: DEC
53285: ST_TO_ADDR
53286: LD_EXP 115
53290: PUSH
53291: FOR_TO
53292: IFFALSE 53984
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53294: LD_EXP 115
53298: PUSH
53299: LD_VAR 0 2
53303: ARRAY
53304: NOT
53305: PUSH
53306: LD_EXP 139
53310: PUSH
53311: LD_VAR 0 2
53315: ARRAY
53316: NOT
53317: OR
53318: IFFALSE 53322
// continue ;
53320: GO 53291
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53322: LD_ADDR_VAR 0 5
53326: PUSH
53327: LD_EXP 115
53331: PUSH
53332: LD_VAR 0 2
53336: ARRAY
53337: PUSH
53338: LD_INT 1
53340: ARRAY
53341: PPUSH
53342: CALL_OW 255
53346: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53347: LD_ADDR_VAR 0 6
53351: PUSH
53352: LD_EXP 115
53356: PUSH
53357: LD_VAR 0 2
53361: ARRAY
53362: PPUSH
53363: LD_INT 30
53365: PUSH
53366: LD_INT 3
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: PPUSH
53373: CALL_OW 72
53377: ST_TO_ADDR
// if not fac then
53378: LD_VAR 0 6
53382: NOT
53383: IFFALSE 53434
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53385: LD_ADDR_VAR 0 6
53389: PUSH
53390: LD_EXP 115
53394: PUSH
53395: LD_VAR 0 2
53399: ARRAY
53400: PPUSH
53401: LD_INT 2
53403: PUSH
53404: LD_INT 30
53406: PUSH
53407: LD_INT 0
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: PUSH
53414: LD_INT 30
53416: PUSH
53417: LD_INT 1
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: LIST
53428: PPUSH
53429: CALL_OW 72
53433: ST_TO_ADDR
// if not fac then
53434: LD_VAR 0 6
53438: NOT
53439: IFFALSE 53443
// continue ;
53441: GO 53291
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53443: LD_ADDR_VAR 0 7
53447: PUSH
53448: LD_EXP 139
53452: PUSH
53453: LD_VAR 0 2
53457: ARRAY
53458: PPUSH
53459: LD_INT 22
53461: PUSH
53462: LD_VAR 0 5
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PUSH
53471: LD_INT 21
53473: PUSH
53474: LD_INT 2
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: PUSH
53481: LD_INT 3
53483: PUSH
53484: LD_INT 24
53486: PUSH
53487: LD_INT 1000
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: PUSH
53498: EMPTY
53499: LIST
53500: LIST
53501: LIST
53502: PPUSH
53503: CALL_OW 70
53507: ST_TO_ADDR
// for j in fac do
53508: LD_ADDR_VAR 0 3
53512: PUSH
53513: LD_VAR 0 6
53517: PUSH
53518: FOR_IN
53519: IFFALSE 53600
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53521: LD_ADDR_VAR 0 7
53525: PUSH
53526: LD_VAR 0 7
53530: PUSH
53531: LD_INT 22
53533: PUSH
53534: LD_VAR 0 5
53538: PUSH
53539: EMPTY
53540: LIST
53541: LIST
53542: PUSH
53543: LD_INT 91
53545: PUSH
53546: LD_VAR 0 3
53550: PUSH
53551: LD_INT 15
53553: PUSH
53554: EMPTY
53555: LIST
53556: LIST
53557: LIST
53558: PUSH
53559: LD_INT 21
53561: PUSH
53562: LD_INT 2
53564: PUSH
53565: EMPTY
53566: LIST
53567: LIST
53568: PUSH
53569: LD_INT 3
53571: PUSH
53572: LD_INT 24
53574: PUSH
53575: LD_INT 1000
53577: PUSH
53578: EMPTY
53579: LIST
53580: LIST
53581: PUSH
53582: EMPTY
53583: LIST
53584: LIST
53585: PUSH
53586: EMPTY
53587: LIST
53588: LIST
53589: LIST
53590: LIST
53591: PPUSH
53592: CALL_OW 69
53596: UNION
53597: ST_TO_ADDR
53598: GO 53518
53600: POP
53601: POP
// if not vehs then
53602: LD_VAR 0 7
53606: NOT
53607: IFFALSE 53633
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53609: LD_ADDR_EXP 127
53613: PUSH
53614: LD_EXP 127
53618: PPUSH
53619: LD_VAR 0 2
53623: PPUSH
53624: EMPTY
53625: PPUSH
53626: CALL_OW 1
53630: ST_TO_ADDR
// continue ;
53631: GO 53291
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53633: LD_ADDR_VAR 0 8
53637: PUSH
53638: LD_EXP 115
53642: PUSH
53643: LD_VAR 0 2
53647: ARRAY
53648: PPUSH
53649: LD_INT 30
53651: PUSH
53652: LD_INT 3
53654: PUSH
53655: EMPTY
53656: LIST
53657: LIST
53658: PPUSH
53659: CALL_OW 72
53663: ST_TO_ADDR
// if tmp then
53664: LD_VAR 0 8
53668: IFFALSE 53771
// begin for j in tmp do
53670: LD_ADDR_VAR 0 3
53674: PUSH
53675: LD_VAR 0 8
53679: PUSH
53680: FOR_IN
53681: IFFALSE 53769
// for k in UnitsInside ( j ) do
53683: LD_ADDR_VAR 0 4
53687: PUSH
53688: LD_VAR 0 3
53692: PPUSH
53693: CALL_OW 313
53697: PUSH
53698: FOR_IN
53699: IFFALSE 53765
// if k then
53701: LD_VAR 0 4
53705: IFFALSE 53763
// if not k in mc_repair_vehicle [ i ] then
53707: LD_VAR 0 4
53711: PUSH
53712: LD_EXP 127
53716: PUSH
53717: LD_VAR 0 2
53721: ARRAY
53722: IN
53723: NOT
53724: IFFALSE 53763
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53726: LD_ADDR_EXP 127
53730: PUSH
53731: LD_EXP 127
53735: PPUSH
53736: LD_VAR 0 2
53740: PPUSH
53741: LD_EXP 127
53745: PUSH
53746: LD_VAR 0 2
53750: ARRAY
53751: PUSH
53752: LD_VAR 0 4
53756: UNION
53757: PPUSH
53758: CALL_OW 1
53762: ST_TO_ADDR
53763: GO 53698
53765: POP
53766: POP
53767: GO 53680
53769: POP
53770: POP
// end ; if not mc_repair_vehicle [ i ] then
53771: LD_EXP 127
53775: PUSH
53776: LD_VAR 0 2
53780: ARRAY
53781: NOT
53782: IFFALSE 53786
// continue ;
53784: GO 53291
// for j in mc_repair_vehicle [ i ] do
53786: LD_ADDR_VAR 0 3
53790: PUSH
53791: LD_EXP 127
53795: PUSH
53796: LD_VAR 0 2
53800: ARRAY
53801: PUSH
53802: FOR_IN
53803: IFFALSE 53980
// begin if GetClass ( j ) <> 3 then
53805: LD_VAR 0 3
53809: PPUSH
53810: CALL_OW 257
53814: PUSH
53815: LD_INT 3
53817: NONEQUAL
53818: IFFALSE 53859
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53820: LD_ADDR_EXP 127
53824: PUSH
53825: LD_EXP 127
53829: PPUSH
53830: LD_VAR 0 2
53834: PPUSH
53835: LD_EXP 127
53839: PUSH
53840: LD_VAR 0 2
53844: ARRAY
53845: PUSH
53846: LD_VAR 0 3
53850: DIFF
53851: PPUSH
53852: CALL_OW 1
53856: ST_TO_ADDR
// continue ;
53857: GO 53802
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53859: LD_VAR 0 3
53863: PPUSH
53864: CALL_OW 311
53868: NOT
53869: PUSH
53870: LD_VAR 0 3
53874: PUSH
53875: LD_EXP 118
53879: PUSH
53880: LD_VAR 0 2
53884: ARRAY
53885: PUSH
53886: LD_INT 1
53888: ARRAY
53889: IN
53890: NOT
53891: AND
53892: PUSH
53893: LD_VAR 0 3
53897: PUSH
53898: LD_EXP 118
53902: PUSH
53903: LD_VAR 0 2
53907: ARRAY
53908: PUSH
53909: LD_INT 2
53911: ARRAY
53912: IN
53913: NOT
53914: AND
53915: IFFALSE 53978
// begin if IsInUnit ( j ) then
53917: LD_VAR 0 3
53921: PPUSH
53922: CALL_OW 310
53926: IFFALSE 53939
// ComExitBuilding ( j ) else
53928: LD_VAR 0 3
53932: PPUSH
53933: CALL_OW 122
53937: GO 53978
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53939: LD_VAR 0 3
53943: PPUSH
53944: LD_VAR 0 7
53948: PUSH
53949: LD_INT 1
53951: ARRAY
53952: PPUSH
53953: CALL 105388 0 2
53957: NOT
53958: IFFALSE 53978
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53960: LD_VAR 0 3
53964: PPUSH
53965: LD_VAR 0 7
53969: PUSH
53970: LD_INT 1
53972: ARRAY
53973: PPUSH
53974: CALL_OW 129
// end ; end ;
53978: GO 53802
53980: POP
53981: POP
// end ;
53982: GO 53291
53984: POP
53985: POP
// end ;
53986: LD_VAR 0 1
53990: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53991: LD_INT 0
53993: PPUSH
53994: PPUSH
53995: PPUSH
53996: PPUSH
53997: PPUSH
53998: PPUSH
53999: PPUSH
54000: PPUSH
54001: PPUSH
54002: PPUSH
54003: PPUSH
// if not mc_bases then
54004: LD_EXP 115
54008: NOT
54009: IFFALSE 54013
// exit ;
54011: GO 54815
// for i = 1 to mc_bases do
54013: LD_ADDR_VAR 0 2
54017: PUSH
54018: DOUBLE
54019: LD_INT 1
54021: DEC
54022: ST_TO_ADDR
54023: LD_EXP 115
54027: PUSH
54028: FOR_TO
54029: IFFALSE 54813
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
54031: LD_EXP 143
54035: PUSH
54036: LD_VAR 0 2
54040: ARRAY
54041: NOT
54042: PUSH
54043: LD_EXP 118
54047: PUSH
54048: LD_VAR 0 2
54052: ARRAY
54053: PUSH
54054: LD_INT 1
54056: ARRAY
54057: OR
54058: PUSH
54059: LD_EXP 118
54063: PUSH
54064: LD_VAR 0 2
54068: ARRAY
54069: PUSH
54070: LD_INT 2
54072: ARRAY
54073: OR
54074: PUSH
54075: LD_EXP 141
54079: PUSH
54080: LD_VAR 0 2
54084: ARRAY
54085: PPUSH
54086: LD_INT 1
54088: PPUSH
54089: CALL_OW 325
54093: NOT
54094: OR
54095: PUSH
54096: LD_EXP 138
54100: PUSH
54101: LD_VAR 0 2
54105: ARRAY
54106: OR
54107: IFFALSE 54111
// continue ;
54109: GO 54028
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54111: LD_ADDR_VAR 0 8
54115: PUSH
54116: LD_EXP 115
54120: PUSH
54121: LD_VAR 0 2
54125: ARRAY
54126: PPUSH
54127: LD_INT 25
54129: PUSH
54130: LD_INT 4
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: PUSH
54137: LD_INT 50
54139: PUSH
54140: EMPTY
54141: LIST
54142: PUSH
54143: LD_INT 3
54145: PUSH
54146: LD_INT 60
54148: PUSH
54149: EMPTY
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: PUSH
54156: EMPTY
54157: LIST
54158: LIST
54159: LIST
54160: PPUSH
54161: CALL_OW 72
54165: PUSH
54166: LD_EXP 119
54170: PUSH
54171: LD_VAR 0 2
54175: ARRAY
54176: DIFF
54177: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54178: LD_ADDR_VAR 0 9
54182: PUSH
54183: LD_EXP 115
54187: PUSH
54188: LD_VAR 0 2
54192: ARRAY
54193: PPUSH
54194: LD_INT 2
54196: PUSH
54197: LD_INT 30
54199: PUSH
54200: LD_INT 0
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PUSH
54207: LD_INT 30
54209: PUSH
54210: LD_INT 1
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: LIST
54221: PPUSH
54222: CALL_OW 72
54226: ST_TO_ADDR
// if not tmp or not dep then
54227: LD_VAR 0 8
54231: NOT
54232: PUSH
54233: LD_VAR 0 9
54237: NOT
54238: OR
54239: IFFALSE 54243
// continue ;
54241: GO 54028
// side := GetSide ( tmp [ 1 ] ) ;
54243: LD_ADDR_VAR 0 11
54247: PUSH
54248: LD_VAR 0 8
54252: PUSH
54253: LD_INT 1
54255: ARRAY
54256: PPUSH
54257: CALL_OW 255
54261: ST_TO_ADDR
// dep := dep [ 1 ] ;
54262: LD_ADDR_VAR 0 9
54266: PUSH
54267: LD_VAR 0 9
54271: PUSH
54272: LD_INT 1
54274: ARRAY
54275: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54276: LD_ADDR_VAR 0 7
54280: PUSH
54281: LD_EXP 143
54285: PUSH
54286: LD_VAR 0 2
54290: ARRAY
54291: PPUSH
54292: LD_INT 22
54294: PUSH
54295: LD_INT 0
54297: PUSH
54298: EMPTY
54299: LIST
54300: LIST
54301: PUSH
54302: LD_INT 25
54304: PUSH
54305: LD_INT 12
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: PUSH
54312: EMPTY
54313: LIST
54314: LIST
54315: PPUSH
54316: CALL_OW 70
54320: PUSH
54321: LD_INT 22
54323: PUSH
54324: LD_INT 0
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: PUSH
54331: LD_INT 25
54333: PUSH
54334: LD_INT 12
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PUSH
54341: LD_INT 91
54343: PUSH
54344: LD_VAR 0 9
54348: PUSH
54349: LD_INT 20
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: LIST
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: PPUSH
54362: CALL_OW 69
54366: UNION
54367: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54368: LD_ADDR_VAR 0 10
54372: PUSH
54373: LD_EXP 143
54377: PUSH
54378: LD_VAR 0 2
54382: ARRAY
54383: PPUSH
54384: LD_INT 81
54386: PUSH
54387: LD_VAR 0 11
54391: PUSH
54392: EMPTY
54393: LIST
54394: LIST
54395: PPUSH
54396: CALL_OW 70
54400: ST_TO_ADDR
// if not apes or danger_at_area then
54401: LD_VAR 0 7
54405: NOT
54406: PUSH
54407: LD_VAR 0 10
54411: OR
54412: IFFALSE 54462
// begin if mc_taming [ i ] then
54414: LD_EXP 146
54418: PUSH
54419: LD_VAR 0 2
54423: ARRAY
54424: IFFALSE 54460
// begin MC_Reset ( i , 121 ) ;
54426: LD_VAR 0 2
54430: PPUSH
54431: LD_INT 121
54433: PPUSH
54434: CALL 39448 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54438: LD_ADDR_EXP 146
54442: PUSH
54443: LD_EXP 146
54447: PPUSH
54448: LD_VAR 0 2
54452: PPUSH
54453: EMPTY
54454: PPUSH
54455: CALL_OW 1
54459: ST_TO_ADDR
// end ; continue ;
54460: GO 54028
// end ; for j in tmp do
54462: LD_ADDR_VAR 0 3
54466: PUSH
54467: LD_VAR 0 8
54471: PUSH
54472: FOR_IN
54473: IFFALSE 54809
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54475: LD_VAR 0 3
54479: PUSH
54480: LD_EXP 146
54484: PUSH
54485: LD_VAR 0 2
54489: ARRAY
54490: IN
54491: NOT
54492: PUSH
54493: LD_EXP 146
54497: PUSH
54498: LD_VAR 0 2
54502: ARRAY
54503: PUSH
54504: LD_INT 3
54506: LESS
54507: AND
54508: IFFALSE 54566
// begin SetTag ( j , 121 ) ;
54510: LD_VAR 0 3
54514: PPUSH
54515: LD_INT 121
54517: PPUSH
54518: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54522: LD_ADDR_EXP 146
54526: PUSH
54527: LD_EXP 146
54531: PPUSH
54532: LD_VAR 0 2
54536: PUSH
54537: LD_EXP 146
54541: PUSH
54542: LD_VAR 0 2
54546: ARRAY
54547: PUSH
54548: LD_INT 1
54550: PLUS
54551: PUSH
54552: EMPTY
54553: LIST
54554: LIST
54555: PPUSH
54556: LD_VAR 0 3
54560: PPUSH
54561: CALL 71059 0 3
54565: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54566: LD_VAR 0 3
54570: PUSH
54571: LD_EXP 146
54575: PUSH
54576: LD_VAR 0 2
54580: ARRAY
54581: IN
54582: IFFALSE 54807
// begin if GetClass ( j ) <> 4 then
54584: LD_VAR 0 3
54588: PPUSH
54589: CALL_OW 257
54593: PUSH
54594: LD_INT 4
54596: NONEQUAL
54597: IFFALSE 54650
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54599: LD_ADDR_EXP 146
54603: PUSH
54604: LD_EXP 146
54608: PPUSH
54609: LD_VAR 0 2
54613: PPUSH
54614: LD_EXP 146
54618: PUSH
54619: LD_VAR 0 2
54623: ARRAY
54624: PUSH
54625: LD_VAR 0 3
54629: DIFF
54630: PPUSH
54631: CALL_OW 1
54635: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54636: LD_VAR 0 3
54640: PPUSH
54641: LD_INT 0
54643: PPUSH
54644: CALL_OW 109
// continue ;
54648: GO 54472
// end ; if IsInUnit ( j ) then
54650: LD_VAR 0 3
54654: PPUSH
54655: CALL_OW 310
54659: IFFALSE 54670
// ComExitBuilding ( j ) ;
54661: LD_VAR 0 3
54665: PPUSH
54666: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54670: LD_ADDR_VAR 0 6
54674: PUSH
54675: LD_VAR 0 7
54679: PPUSH
54680: LD_VAR 0 3
54684: PPUSH
54685: CALL_OW 74
54689: ST_TO_ADDR
// if not ape then
54690: LD_VAR 0 6
54694: NOT
54695: IFFALSE 54699
// break ;
54697: GO 54809
// x := GetX ( ape ) ;
54699: LD_ADDR_VAR 0 4
54703: PUSH
54704: LD_VAR 0 6
54708: PPUSH
54709: CALL_OW 250
54713: ST_TO_ADDR
// y := GetY ( ape ) ;
54714: LD_ADDR_VAR 0 5
54718: PUSH
54719: LD_VAR 0 6
54723: PPUSH
54724: CALL_OW 251
54728: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54729: LD_VAR 0 4
54733: PPUSH
54734: LD_VAR 0 5
54738: PPUSH
54739: CALL_OW 488
54743: NOT
54744: PUSH
54745: LD_VAR 0 11
54749: PPUSH
54750: LD_VAR 0 4
54754: PPUSH
54755: LD_VAR 0 5
54759: PPUSH
54760: LD_INT 20
54762: PPUSH
54763: CALL 71955 0 4
54767: PUSH
54768: LD_INT 4
54770: ARRAY
54771: OR
54772: IFFALSE 54776
// break ;
54774: GO 54809
// if not HasTask ( j ) then
54776: LD_VAR 0 3
54780: PPUSH
54781: CALL_OW 314
54785: NOT
54786: IFFALSE 54807
// ComTameXY ( j , x , y ) ;
54788: LD_VAR 0 3
54792: PPUSH
54793: LD_VAR 0 4
54797: PPUSH
54798: LD_VAR 0 5
54802: PPUSH
54803: CALL_OW 131
// end ; end ;
54807: GO 54472
54809: POP
54810: POP
// end ;
54811: GO 54028
54813: POP
54814: POP
// end ;
54815: LD_VAR 0 1
54819: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54820: LD_INT 0
54822: PPUSH
54823: PPUSH
54824: PPUSH
54825: PPUSH
54826: PPUSH
54827: PPUSH
54828: PPUSH
54829: PPUSH
// if not mc_bases then
54830: LD_EXP 115
54834: NOT
54835: IFFALSE 54839
// exit ;
54837: GO 55465
// for i = 1 to mc_bases do
54839: LD_ADDR_VAR 0 2
54843: PUSH
54844: DOUBLE
54845: LD_INT 1
54847: DEC
54848: ST_TO_ADDR
54849: LD_EXP 115
54853: PUSH
54854: FOR_TO
54855: IFFALSE 55463
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54857: LD_EXP 144
54861: PUSH
54862: LD_VAR 0 2
54866: ARRAY
54867: NOT
54868: PUSH
54869: LD_EXP 144
54873: PUSH
54874: LD_VAR 0 2
54878: ARRAY
54879: PPUSH
54880: LD_INT 25
54882: PUSH
54883: LD_INT 12
54885: PUSH
54886: EMPTY
54887: LIST
54888: LIST
54889: PPUSH
54890: CALL_OW 72
54894: NOT
54895: OR
54896: IFFALSE 54900
// continue ;
54898: GO 54854
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54900: LD_ADDR_VAR 0 5
54904: PUSH
54905: LD_EXP 144
54909: PUSH
54910: LD_VAR 0 2
54914: ARRAY
54915: PUSH
54916: LD_INT 1
54918: ARRAY
54919: PPUSH
54920: CALL_OW 255
54924: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54925: LD_VAR 0 5
54929: PPUSH
54930: LD_INT 2
54932: PPUSH
54933: CALL_OW 325
54937: IFFALSE 55190
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54939: LD_ADDR_VAR 0 4
54943: PUSH
54944: LD_EXP 144
54948: PUSH
54949: LD_VAR 0 2
54953: ARRAY
54954: PPUSH
54955: LD_INT 25
54957: PUSH
54958: LD_INT 16
54960: PUSH
54961: EMPTY
54962: LIST
54963: LIST
54964: PPUSH
54965: CALL_OW 72
54969: ST_TO_ADDR
// if tmp < 6 then
54970: LD_VAR 0 4
54974: PUSH
54975: LD_INT 6
54977: LESS
54978: IFFALSE 55190
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54980: LD_ADDR_VAR 0 6
54984: PUSH
54985: LD_EXP 115
54989: PUSH
54990: LD_VAR 0 2
54994: ARRAY
54995: PPUSH
54996: LD_INT 2
54998: PUSH
54999: LD_INT 30
55001: PUSH
55002: LD_INT 0
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PUSH
55009: LD_INT 30
55011: PUSH
55012: LD_INT 1
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: LIST
55023: PPUSH
55024: CALL_OW 72
55028: ST_TO_ADDR
// if depot then
55029: LD_VAR 0 6
55033: IFFALSE 55190
// begin selected := 0 ;
55035: LD_ADDR_VAR 0 7
55039: PUSH
55040: LD_INT 0
55042: ST_TO_ADDR
// for j in depot do
55043: LD_ADDR_VAR 0 3
55047: PUSH
55048: LD_VAR 0 6
55052: PUSH
55053: FOR_IN
55054: IFFALSE 55085
// begin if UnitsInside ( j ) < 6 then
55056: LD_VAR 0 3
55060: PPUSH
55061: CALL_OW 313
55065: PUSH
55066: LD_INT 6
55068: LESS
55069: IFFALSE 55083
// begin selected := j ;
55071: LD_ADDR_VAR 0 7
55075: PUSH
55076: LD_VAR 0 3
55080: ST_TO_ADDR
// break ;
55081: GO 55085
// end ; end ;
55083: GO 55053
55085: POP
55086: POP
// if selected then
55087: LD_VAR 0 7
55091: IFFALSE 55190
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55093: LD_ADDR_VAR 0 3
55097: PUSH
55098: LD_EXP 144
55102: PUSH
55103: LD_VAR 0 2
55107: ARRAY
55108: PPUSH
55109: LD_INT 25
55111: PUSH
55112: LD_INT 12
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: PPUSH
55119: CALL_OW 72
55123: PUSH
55124: FOR_IN
55125: IFFALSE 55188
// if not HasTask ( j ) then
55127: LD_VAR 0 3
55131: PPUSH
55132: CALL_OW 314
55136: NOT
55137: IFFALSE 55186
// begin if not IsInUnit ( j ) then
55139: LD_VAR 0 3
55143: PPUSH
55144: CALL_OW 310
55148: NOT
55149: IFFALSE 55165
// ComEnterUnit ( j , selected ) ;
55151: LD_VAR 0 3
55155: PPUSH
55156: LD_VAR 0 7
55160: PPUSH
55161: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55165: LD_VAR 0 3
55169: PPUSH
55170: LD_INT 16
55172: PPUSH
55173: CALL_OW 183
// AddComExitBuilding ( j ) ;
55177: LD_VAR 0 3
55181: PPUSH
55182: CALL_OW 182
// end ;
55186: GO 55124
55188: POP
55189: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55190: LD_VAR 0 5
55194: PPUSH
55195: LD_INT 11
55197: PPUSH
55198: CALL_OW 325
55202: IFFALSE 55461
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55204: LD_ADDR_VAR 0 4
55208: PUSH
55209: LD_EXP 144
55213: PUSH
55214: LD_VAR 0 2
55218: ARRAY
55219: PPUSH
55220: LD_INT 25
55222: PUSH
55223: LD_INT 16
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: PPUSH
55230: CALL_OW 72
55234: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55235: LD_VAR 0 4
55239: PUSH
55240: LD_INT 6
55242: GREATEREQUAL
55243: PUSH
55244: LD_VAR 0 5
55248: PPUSH
55249: LD_INT 2
55251: PPUSH
55252: CALL_OW 325
55256: NOT
55257: OR
55258: IFFALSE 55461
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55260: LD_ADDR_VAR 0 8
55264: PUSH
55265: LD_EXP 115
55269: PUSH
55270: LD_VAR 0 2
55274: ARRAY
55275: PPUSH
55276: LD_INT 2
55278: PUSH
55279: LD_INT 30
55281: PUSH
55282: LD_INT 4
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: PUSH
55289: LD_INT 30
55291: PUSH
55292: LD_INT 5
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: LIST
55303: PPUSH
55304: CALL_OW 72
55308: ST_TO_ADDR
// if barracks then
55309: LD_VAR 0 8
55313: IFFALSE 55461
// begin selected := 0 ;
55315: LD_ADDR_VAR 0 7
55319: PUSH
55320: LD_INT 0
55322: ST_TO_ADDR
// for j in barracks do
55323: LD_ADDR_VAR 0 3
55327: PUSH
55328: LD_VAR 0 8
55332: PUSH
55333: FOR_IN
55334: IFFALSE 55365
// begin if UnitsInside ( j ) < 6 then
55336: LD_VAR 0 3
55340: PPUSH
55341: CALL_OW 313
55345: PUSH
55346: LD_INT 6
55348: LESS
55349: IFFALSE 55363
// begin selected := j ;
55351: LD_ADDR_VAR 0 7
55355: PUSH
55356: LD_VAR 0 3
55360: ST_TO_ADDR
// break ;
55361: GO 55365
// end ; end ;
55363: GO 55333
55365: POP
55366: POP
// if selected then
55367: LD_VAR 0 7
55371: IFFALSE 55461
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55373: LD_ADDR_VAR 0 3
55377: PUSH
55378: LD_EXP 144
55382: PUSH
55383: LD_VAR 0 2
55387: ARRAY
55388: PPUSH
55389: LD_INT 25
55391: PUSH
55392: LD_INT 12
55394: PUSH
55395: EMPTY
55396: LIST
55397: LIST
55398: PPUSH
55399: CALL_OW 72
55403: PUSH
55404: FOR_IN
55405: IFFALSE 55459
// if not IsInUnit ( j ) and not HasTask ( j ) then
55407: LD_VAR 0 3
55411: PPUSH
55412: CALL_OW 310
55416: NOT
55417: PUSH
55418: LD_VAR 0 3
55422: PPUSH
55423: CALL_OW 314
55427: NOT
55428: AND
55429: IFFALSE 55457
// begin ComEnterUnit ( j , selected ) ;
55431: LD_VAR 0 3
55435: PPUSH
55436: LD_VAR 0 7
55440: PPUSH
55441: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55445: LD_VAR 0 3
55449: PPUSH
55450: LD_INT 15
55452: PPUSH
55453: CALL_OW 183
// end ;
55457: GO 55404
55459: POP
55460: POP
// end ; end ; end ; end ; end ;
55461: GO 54854
55463: POP
55464: POP
// end ;
55465: LD_VAR 0 1
55469: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55470: LD_INT 0
55472: PPUSH
55473: PPUSH
55474: PPUSH
55475: PPUSH
// if not mc_bases then
55476: LD_EXP 115
55480: NOT
55481: IFFALSE 55485
// exit ;
55483: GO 55663
// for i = 1 to mc_bases do
55485: LD_ADDR_VAR 0 2
55489: PUSH
55490: DOUBLE
55491: LD_INT 1
55493: DEC
55494: ST_TO_ADDR
55495: LD_EXP 115
55499: PUSH
55500: FOR_TO
55501: IFFALSE 55661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55503: LD_ADDR_VAR 0 4
55507: PUSH
55508: LD_EXP 115
55512: PUSH
55513: LD_VAR 0 2
55517: ARRAY
55518: PPUSH
55519: LD_INT 25
55521: PUSH
55522: LD_INT 9
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PPUSH
55529: CALL_OW 72
55533: ST_TO_ADDR
// if not tmp then
55534: LD_VAR 0 4
55538: NOT
55539: IFFALSE 55543
// continue ;
55541: GO 55500
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55543: LD_EXP 141
55547: PUSH
55548: LD_VAR 0 2
55552: ARRAY
55553: PPUSH
55554: LD_INT 29
55556: PPUSH
55557: CALL_OW 325
55561: NOT
55562: PUSH
55563: LD_EXP 141
55567: PUSH
55568: LD_VAR 0 2
55572: ARRAY
55573: PPUSH
55574: LD_INT 28
55576: PPUSH
55577: CALL_OW 325
55581: NOT
55582: AND
55583: IFFALSE 55587
// continue ;
55585: GO 55500
// for j in tmp do
55587: LD_ADDR_VAR 0 3
55591: PUSH
55592: LD_VAR 0 4
55596: PUSH
55597: FOR_IN
55598: IFFALSE 55657
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55600: LD_VAR 0 3
55604: PUSH
55605: LD_EXP 118
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: PUSH
55616: LD_INT 1
55618: ARRAY
55619: IN
55620: NOT
55621: PUSH
55622: LD_VAR 0 3
55626: PUSH
55627: LD_EXP 118
55631: PUSH
55632: LD_VAR 0 2
55636: ARRAY
55637: PUSH
55638: LD_INT 2
55640: ARRAY
55641: IN
55642: NOT
55643: AND
55644: IFFALSE 55655
// ComSpaceTimeShoot ( j ) ;
55646: LD_VAR 0 3
55650: PPUSH
55651: CALL 66867 0 1
55655: GO 55597
55657: POP
55658: POP
// end ;
55659: GO 55500
55661: POP
55662: POP
// end ;
55663: LD_VAR 0 1
55667: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55668: LD_INT 0
55670: PPUSH
55671: PPUSH
55672: PPUSH
55673: PPUSH
55674: PPUSH
55675: PPUSH
55676: PPUSH
55677: PPUSH
55678: PPUSH
// if not mc_bases then
55679: LD_EXP 115
55683: NOT
55684: IFFALSE 55688
// exit ;
55686: GO 56310
// for i = 1 to mc_bases do
55688: LD_ADDR_VAR 0 2
55692: PUSH
55693: DOUBLE
55694: LD_INT 1
55696: DEC
55697: ST_TO_ADDR
55698: LD_EXP 115
55702: PUSH
55703: FOR_TO
55704: IFFALSE 56308
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55706: LD_EXP 150
55710: PUSH
55711: LD_VAR 0 2
55715: ARRAY
55716: NOT
55717: PUSH
55718: LD_INT 38
55720: PPUSH
55721: LD_EXP 141
55725: PUSH
55726: LD_VAR 0 2
55730: ARRAY
55731: PPUSH
55732: CALL_OW 321
55736: PUSH
55737: LD_INT 2
55739: NONEQUAL
55740: OR
55741: IFFALSE 55745
// continue ;
55743: GO 55703
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55745: LD_ADDR_VAR 0 8
55749: PUSH
55750: LD_EXP 115
55754: PUSH
55755: LD_VAR 0 2
55759: ARRAY
55760: PPUSH
55761: LD_INT 30
55763: PUSH
55764: LD_INT 34
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PPUSH
55771: CALL_OW 72
55775: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55776: LD_ADDR_VAR 0 9
55780: PUSH
55781: LD_EXP 115
55785: PUSH
55786: LD_VAR 0 2
55790: ARRAY
55791: PPUSH
55792: LD_INT 25
55794: PUSH
55795: LD_INT 4
55797: PUSH
55798: EMPTY
55799: LIST
55800: LIST
55801: PPUSH
55802: CALL_OW 72
55806: PPUSH
55807: LD_INT 0
55809: PPUSH
55810: CALL 100895 0 2
55814: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55815: LD_VAR 0 9
55819: NOT
55820: PUSH
55821: LD_VAR 0 8
55825: NOT
55826: OR
55827: PUSH
55828: LD_EXP 115
55832: PUSH
55833: LD_VAR 0 2
55837: ARRAY
55838: PPUSH
55839: LD_INT 124
55841: PPUSH
55842: CALL 100895 0 2
55846: OR
55847: IFFALSE 55851
// continue ;
55849: GO 55703
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55851: LD_EXP 151
55855: PUSH
55856: LD_VAR 0 2
55860: ARRAY
55861: PUSH
55862: LD_EXP 150
55866: PUSH
55867: LD_VAR 0 2
55871: ARRAY
55872: LESS
55873: PUSH
55874: LD_EXP 151
55878: PUSH
55879: LD_VAR 0 2
55883: ARRAY
55884: PUSH
55885: LD_VAR 0 8
55889: LESS
55890: AND
55891: IFFALSE 56306
// begin tmp := sci [ 1 ] ;
55893: LD_ADDR_VAR 0 7
55897: PUSH
55898: LD_VAR 0 9
55902: PUSH
55903: LD_INT 1
55905: ARRAY
55906: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55907: LD_VAR 0 7
55911: PPUSH
55912: LD_INT 124
55914: PPUSH
55915: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55919: LD_ADDR_VAR 0 3
55923: PUSH
55924: DOUBLE
55925: LD_EXP 150
55929: PUSH
55930: LD_VAR 0 2
55934: ARRAY
55935: INC
55936: ST_TO_ADDR
55937: LD_EXP 150
55941: PUSH
55942: LD_VAR 0 2
55946: ARRAY
55947: PUSH
55948: FOR_DOWNTO
55949: IFFALSE 56292
// begin if IsInUnit ( tmp ) then
55951: LD_VAR 0 7
55955: PPUSH
55956: CALL_OW 310
55960: IFFALSE 55971
// ComExitBuilding ( tmp ) ;
55962: LD_VAR 0 7
55966: PPUSH
55967: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55971: LD_INT 35
55973: PPUSH
55974: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55978: LD_VAR 0 7
55982: PPUSH
55983: CALL_OW 310
55987: NOT
55988: PUSH
55989: LD_VAR 0 7
55993: PPUSH
55994: CALL_OW 314
55998: NOT
55999: AND
56000: IFFALSE 55971
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
56002: LD_ADDR_VAR 0 6
56006: PUSH
56007: LD_VAR 0 7
56011: PPUSH
56012: CALL_OW 250
56016: PUSH
56017: LD_VAR 0 7
56021: PPUSH
56022: CALL_OW 251
56026: PUSH
56027: EMPTY
56028: LIST
56029: LIST
56030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
56031: LD_INT 35
56033: PPUSH
56034: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
56038: LD_ADDR_VAR 0 4
56042: PUSH
56043: LD_EXP 150
56047: PUSH
56048: LD_VAR 0 2
56052: ARRAY
56053: PUSH
56054: LD_VAR 0 3
56058: ARRAY
56059: PUSH
56060: LD_INT 1
56062: ARRAY
56063: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56064: LD_ADDR_VAR 0 5
56068: PUSH
56069: LD_EXP 150
56073: PUSH
56074: LD_VAR 0 2
56078: ARRAY
56079: PUSH
56080: LD_VAR 0 3
56084: ARRAY
56085: PUSH
56086: LD_INT 2
56088: ARRAY
56089: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56090: LD_VAR 0 7
56094: PPUSH
56095: LD_INT 10
56097: PPUSH
56098: CALL 73658 0 2
56102: PUSH
56103: LD_INT 4
56105: ARRAY
56106: IFFALSE 56144
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56108: LD_VAR 0 7
56112: PPUSH
56113: LD_VAR 0 6
56117: PUSH
56118: LD_INT 1
56120: ARRAY
56121: PPUSH
56122: LD_VAR 0 6
56126: PUSH
56127: LD_INT 2
56129: ARRAY
56130: PPUSH
56131: CALL_OW 111
// wait ( 0 0$10 ) ;
56135: LD_INT 350
56137: PPUSH
56138: CALL_OW 67
// end else
56142: GO 56170
// begin ComMoveXY ( tmp , x , y ) ;
56144: LD_VAR 0 7
56148: PPUSH
56149: LD_VAR 0 4
56153: PPUSH
56154: LD_VAR 0 5
56158: PPUSH
56159: CALL_OW 111
// wait ( 0 0$3 ) ;
56163: LD_INT 105
56165: PPUSH
56166: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56170: LD_VAR 0 7
56174: PPUSH
56175: LD_VAR 0 4
56179: PPUSH
56180: LD_VAR 0 5
56184: PPUSH
56185: CALL_OW 307
56189: IFFALSE 56031
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56191: LD_VAR 0 7
56195: PPUSH
56196: LD_VAR 0 4
56200: PPUSH
56201: LD_VAR 0 5
56205: PPUSH
56206: LD_VAR 0 8
56210: PUSH
56211: LD_VAR 0 3
56215: ARRAY
56216: PPUSH
56217: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56221: LD_INT 35
56223: PPUSH
56224: CALL_OW 67
// until not HasTask ( tmp ) ;
56228: LD_VAR 0 7
56232: PPUSH
56233: CALL_OW 314
56237: NOT
56238: IFFALSE 56221
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56240: LD_ADDR_EXP 151
56244: PUSH
56245: LD_EXP 151
56249: PPUSH
56250: LD_VAR 0 2
56254: PUSH
56255: LD_EXP 151
56259: PUSH
56260: LD_VAR 0 2
56264: ARRAY
56265: PUSH
56266: LD_INT 1
56268: PLUS
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: PPUSH
56274: LD_VAR 0 8
56278: PUSH
56279: LD_VAR 0 3
56283: ARRAY
56284: PPUSH
56285: CALL 71059 0 3
56289: ST_TO_ADDR
// end ;
56290: GO 55948
56292: POP
56293: POP
// MC_Reset ( i , 124 ) ;
56294: LD_VAR 0 2
56298: PPUSH
56299: LD_INT 124
56301: PPUSH
56302: CALL 39448 0 2
// end ; end ;
56306: GO 55703
56308: POP
56309: POP
// end ;
56310: LD_VAR 0 1
56314: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56315: LD_INT 0
56317: PPUSH
56318: PPUSH
56319: PPUSH
// if not mc_bases then
56320: LD_EXP 115
56324: NOT
56325: IFFALSE 56329
// exit ;
56327: GO 56935
// for i = 1 to mc_bases do
56329: LD_ADDR_VAR 0 2
56333: PUSH
56334: DOUBLE
56335: LD_INT 1
56337: DEC
56338: ST_TO_ADDR
56339: LD_EXP 115
56343: PUSH
56344: FOR_TO
56345: IFFALSE 56933
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56347: LD_ADDR_VAR 0 3
56351: PUSH
56352: LD_EXP 115
56356: PUSH
56357: LD_VAR 0 2
56361: ARRAY
56362: PPUSH
56363: LD_INT 25
56365: PUSH
56366: LD_INT 4
56368: PUSH
56369: EMPTY
56370: LIST
56371: LIST
56372: PPUSH
56373: CALL_OW 72
56377: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56378: LD_VAR 0 3
56382: NOT
56383: PUSH
56384: LD_EXP 152
56388: PUSH
56389: LD_VAR 0 2
56393: ARRAY
56394: NOT
56395: OR
56396: PUSH
56397: LD_EXP 115
56401: PUSH
56402: LD_VAR 0 2
56406: ARRAY
56407: PPUSH
56408: LD_INT 2
56410: PUSH
56411: LD_INT 30
56413: PUSH
56414: LD_INT 0
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PUSH
56421: LD_INT 30
56423: PUSH
56424: LD_INT 1
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: LIST
56435: PPUSH
56436: CALL_OW 72
56440: NOT
56441: OR
56442: IFFALSE 56492
// begin if mc_deposits_finder [ i ] then
56444: LD_EXP 153
56448: PUSH
56449: LD_VAR 0 2
56453: ARRAY
56454: IFFALSE 56490
// begin MC_Reset ( i , 125 ) ;
56456: LD_VAR 0 2
56460: PPUSH
56461: LD_INT 125
56463: PPUSH
56464: CALL 39448 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56468: LD_ADDR_EXP 153
56472: PUSH
56473: LD_EXP 153
56477: PPUSH
56478: LD_VAR 0 2
56482: PPUSH
56483: EMPTY
56484: PPUSH
56485: CALL_OW 1
56489: ST_TO_ADDR
// end ; continue ;
56490: GO 56344
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56492: LD_EXP 152
56496: PUSH
56497: LD_VAR 0 2
56501: ARRAY
56502: PUSH
56503: LD_INT 1
56505: ARRAY
56506: PUSH
56507: LD_INT 3
56509: ARRAY
56510: PUSH
56511: LD_INT 1
56513: EQUAL
56514: PUSH
56515: LD_INT 20
56517: PPUSH
56518: LD_EXP 141
56522: PUSH
56523: LD_VAR 0 2
56527: ARRAY
56528: PPUSH
56529: CALL_OW 321
56533: PUSH
56534: LD_INT 2
56536: NONEQUAL
56537: AND
56538: IFFALSE 56588
// begin if mc_deposits_finder [ i ] then
56540: LD_EXP 153
56544: PUSH
56545: LD_VAR 0 2
56549: ARRAY
56550: IFFALSE 56586
// begin MC_Reset ( i , 125 ) ;
56552: LD_VAR 0 2
56556: PPUSH
56557: LD_INT 125
56559: PPUSH
56560: CALL 39448 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56564: LD_ADDR_EXP 153
56568: PUSH
56569: LD_EXP 153
56573: PPUSH
56574: LD_VAR 0 2
56578: PPUSH
56579: EMPTY
56580: PPUSH
56581: CALL_OW 1
56585: ST_TO_ADDR
// end ; continue ;
56586: GO 56344
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56588: LD_EXP 152
56592: PUSH
56593: LD_VAR 0 2
56597: ARRAY
56598: PUSH
56599: LD_INT 1
56601: ARRAY
56602: PUSH
56603: LD_INT 1
56605: ARRAY
56606: PPUSH
56607: LD_EXP 152
56611: PUSH
56612: LD_VAR 0 2
56616: ARRAY
56617: PUSH
56618: LD_INT 1
56620: ARRAY
56621: PUSH
56622: LD_INT 2
56624: ARRAY
56625: PPUSH
56626: LD_EXP 141
56630: PUSH
56631: LD_VAR 0 2
56635: ARRAY
56636: PPUSH
56637: CALL_OW 440
56641: IFFALSE 56684
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56643: LD_ADDR_EXP 152
56647: PUSH
56648: LD_EXP 152
56652: PPUSH
56653: LD_VAR 0 2
56657: PPUSH
56658: LD_EXP 152
56662: PUSH
56663: LD_VAR 0 2
56667: ARRAY
56668: PPUSH
56669: LD_INT 1
56671: PPUSH
56672: CALL_OW 3
56676: PPUSH
56677: CALL_OW 1
56681: ST_TO_ADDR
56682: GO 56931
// begin if not mc_deposits_finder [ i ] then
56684: LD_EXP 153
56688: PUSH
56689: LD_VAR 0 2
56693: ARRAY
56694: NOT
56695: IFFALSE 56747
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56697: LD_ADDR_EXP 153
56701: PUSH
56702: LD_EXP 153
56706: PPUSH
56707: LD_VAR 0 2
56711: PPUSH
56712: LD_VAR 0 3
56716: PUSH
56717: LD_INT 1
56719: ARRAY
56720: PUSH
56721: EMPTY
56722: LIST
56723: PPUSH
56724: CALL_OW 1
56728: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56729: LD_VAR 0 3
56733: PUSH
56734: LD_INT 1
56736: ARRAY
56737: PPUSH
56738: LD_INT 125
56740: PPUSH
56741: CALL_OW 109
// end else
56745: GO 56931
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56747: LD_EXP 153
56751: PUSH
56752: LD_VAR 0 2
56756: ARRAY
56757: PUSH
56758: LD_INT 1
56760: ARRAY
56761: PPUSH
56762: CALL_OW 310
56766: IFFALSE 56789
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56768: LD_EXP 153
56772: PUSH
56773: LD_VAR 0 2
56777: ARRAY
56778: PUSH
56779: LD_INT 1
56781: ARRAY
56782: PPUSH
56783: CALL_OW 122
56787: GO 56931
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56789: LD_EXP 153
56793: PUSH
56794: LD_VAR 0 2
56798: ARRAY
56799: PUSH
56800: LD_INT 1
56802: ARRAY
56803: PPUSH
56804: CALL_OW 314
56808: NOT
56809: PUSH
56810: LD_EXP 153
56814: PUSH
56815: LD_VAR 0 2
56819: ARRAY
56820: PUSH
56821: LD_INT 1
56823: ARRAY
56824: PPUSH
56825: LD_EXP 152
56829: PUSH
56830: LD_VAR 0 2
56834: ARRAY
56835: PUSH
56836: LD_INT 1
56838: ARRAY
56839: PUSH
56840: LD_INT 1
56842: ARRAY
56843: PPUSH
56844: LD_EXP 152
56848: PUSH
56849: LD_VAR 0 2
56853: ARRAY
56854: PUSH
56855: LD_INT 1
56857: ARRAY
56858: PUSH
56859: LD_INT 2
56861: ARRAY
56862: PPUSH
56863: CALL_OW 297
56867: PUSH
56868: LD_INT 6
56870: GREATER
56871: AND
56872: IFFALSE 56931
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56874: LD_EXP 153
56878: PUSH
56879: LD_VAR 0 2
56883: ARRAY
56884: PUSH
56885: LD_INT 1
56887: ARRAY
56888: PPUSH
56889: LD_EXP 152
56893: PUSH
56894: LD_VAR 0 2
56898: ARRAY
56899: PUSH
56900: LD_INT 1
56902: ARRAY
56903: PUSH
56904: LD_INT 1
56906: ARRAY
56907: PPUSH
56908: LD_EXP 152
56912: PUSH
56913: LD_VAR 0 2
56917: ARRAY
56918: PUSH
56919: LD_INT 1
56921: ARRAY
56922: PUSH
56923: LD_INT 2
56925: ARRAY
56926: PPUSH
56927: CALL_OW 111
// end ; end ; end ;
56931: GO 56344
56933: POP
56934: POP
// end ;
56935: LD_VAR 0 1
56939: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56940: LD_INT 0
56942: PPUSH
56943: PPUSH
56944: PPUSH
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
56949: PPUSH
56950: PPUSH
56951: PPUSH
56952: PPUSH
// if not mc_bases then
56953: LD_EXP 115
56957: NOT
56958: IFFALSE 56962
// exit ;
56960: GO 57902
// for i = 1 to mc_bases do
56962: LD_ADDR_VAR 0 2
56966: PUSH
56967: DOUBLE
56968: LD_INT 1
56970: DEC
56971: ST_TO_ADDR
56972: LD_EXP 115
56976: PUSH
56977: FOR_TO
56978: IFFALSE 57900
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56980: LD_EXP 115
56984: PUSH
56985: LD_VAR 0 2
56989: ARRAY
56990: NOT
56991: PUSH
56992: LD_EXP 138
56996: PUSH
56997: LD_VAR 0 2
57001: ARRAY
57002: OR
57003: IFFALSE 57007
// continue ;
57005: GO 56977
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
57007: LD_ADDR_VAR 0 7
57011: PUSH
57012: LD_EXP 115
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: PUSH
57023: LD_INT 1
57025: ARRAY
57026: PPUSH
57027: CALL_OW 248
57031: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
57032: LD_VAR 0 7
57036: PUSH
57037: LD_INT 3
57039: EQUAL
57040: PUSH
57041: LD_EXP 134
57045: PUSH
57046: LD_VAR 0 2
57050: ARRAY
57051: PUSH
57052: LD_EXP 137
57056: PUSH
57057: LD_VAR 0 2
57061: ARRAY
57062: UNION
57063: PPUSH
57064: LD_INT 33
57066: PUSH
57067: LD_INT 2
57069: PUSH
57070: EMPTY
57071: LIST
57072: LIST
57073: PPUSH
57074: CALL_OW 72
57078: NOT
57079: OR
57080: IFFALSE 57084
// continue ;
57082: GO 56977
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57084: LD_ADDR_VAR 0 9
57088: PUSH
57089: LD_EXP 115
57093: PUSH
57094: LD_VAR 0 2
57098: ARRAY
57099: PPUSH
57100: LD_INT 30
57102: PUSH
57103: LD_INT 36
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: PPUSH
57110: CALL_OW 72
57114: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57115: LD_ADDR_VAR 0 10
57119: PUSH
57120: LD_EXP 134
57124: PUSH
57125: LD_VAR 0 2
57129: ARRAY
57130: PPUSH
57131: LD_INT 34
57133: PUSH
57134: LD_INT 31
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PPUSH
57141: CALL_OW 72
57145: ST_TO_ADDR
// if not cts and not mcts then
57146: LD_VAR 0 9
57150: NOT
57151: PUSH
57152: LD_VAR 0 10
57156: NOT
57157: AND
57158: IFFALSE 57162
// continue ;
57160: GO 56977
// x := cts ;
57162: LD_ADDR_VAR 0 11
57166: PUSH
57167: LD_VAR 0 9
57171: ST_TO_ADDR
// if not x then
57172: LD_VAR 0 11
57176: NOT
57177: IFFALSE 57189
// x := mcts ;
57179: LD_ADDR_VAR 0 11
57183: PUSH
57184: LD_VAR 0 10
57188: ST_TO_ADDR
// if not x then
57189: LD_VAR 0 11
57193: NOT
57194: IFFALSE 57198
// continue ;
57196: GO 56977
// if mc_remote_driver [ i ] then
57198: LD_EXP 155
57202: PUSH
57203: LD_VAR 0 2
57207: ARRAY
57208: IFFALSE 57595
// for j in mc_remote_driver [ i ] do
57210: LD_ADDR_VAR 0 3
57214: PUSH
57215: LD_EXP 155
57219: PUSH
57220: LD_VAR 0 2
57224: ARRAY
57225: PUSH
57226: FOR_IN
57227: IFFALSE 57593
// begin if GetClass ( j ) <> 3 then
57229: LD_VAR 0 3
57233: PPUSH
57234: CALL_OW 257
57238: PUSH
57239: LD_INT 3
57241: NONEQUAL
57242: IFFALSE 57295
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57244: LD_ADDR_EXP 155
57248: PUSH
57249: LD_EXP 155
57253: PPUSH
57254: LD_VAR 0 2
57258: PPUSH
57259: LD_EXP 155
57263: PUSH
57264: LD_VAR 0 2
57268: ARRAY
57269: PUSH
57270: LD_VAR 0 3
57274: DIFF
57275: PPUSH
57276: CALL_OW 1
57280: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57281: LD_VAR 0 3
57285: PPUSH
57286: LD_INT 0
57288: PPUSH
57289: CALL_OW 109
// continue ;
57293: GO 57226
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57295: LD_EXP 134
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PPUSH
57306: LD_INT 34
57308: PUSH
57309: LD_INT 31
57311: PUSH
57312: EMPTY
57313: LIST
57314: LIST
57315: PUSH
57316: LD_INT 58
57318: PUSH
57319: EMPTY
57320: LIST
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: PPUSH
57326: CALL_OW 72
57330: PUSH
57331: LD_VAR 0 3
57335: PPUSH
57336: CALL 100930 0 1
57340: NOT
57341: AND
57342: IFFALSE 57413
// begin if IsInUnit ( j ) then
57344: LD_VAR 0 3
57348: PPUSH
57349: CALL_OW 310
57353: IFFALSE 57364
// ComExitBuilding ( j ) ;
57355: LD_VAR 0 3
57359: PPUSH
57360: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57364: LD_VAR 0 3
57368: PPUSH
57369: LD_EXP 134
57373: PUSH
57374: LD_VAR 0 2
57378: ARRAY
57379: PPUSH
57380: LD_INT 34
57382: PUSH
57383: LD_INT 31
57385: PUSH
57386: EMPTY
57387: LIST
57388: LIST
57389: PUSH
57390: LD_INT 58
57392: PUSH
57393: EMPTY
57394: LIST
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: PPUSH
57400: CALL_OW 72
57404: PUSH
57405: LD_INT 1
57407: ARRAY
57408: PPUSH
57409: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57413: LD_VAR 0 3
57417: PPUSH
57418: CALL_OW 310
57422: NOT
57423: PUSH
57424: LD_VAR 0 3
57428: PPUSH
57429: CALL_OW 310
57433: PPUSH
57434: CALL_OW 266
57438: PUSH
57439: LD_INT 36
57441: NONEQUAL
57442: PUSH
57443: LD_VAR 0 3
57447: PPUSH
57448: CALL 100930 0 1
57452: NOT
57453: AND
57454: OR
57455: IFFALSE 57591
// begin if IsInUnit ( j ) then
57457: LD_VAR 0 3
57461: PPUSH
57462: CALL_OW 310
57466: IFFALSE 57477
// ComExitBuilding ( j ) ;
57468: LD_VAR 0 3
57472: PPUSH
57473: CALL_OW 122
// ct := 0 ;
57477: LD_ADDR_VAR 0 8
57481: PUSH
57482: LD_INT 0
57484: ST_TO_ADDR
// for k in x do
57485: LD_ADDR_VAR 0 4
57489: PUSH
57490: LD_VAR 0 11
57494: PUSH
57495: FOR_IN
57496: IFFALSE 57569
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57498: LD_VAR 0 4
57502: PPUSH
57503: CALL_OW 264
57507: PUSH
57508: LD_INT 31
57510: EQUAL
57511: PUSH
57512: LD_VAR 0 4
57516: PPUSH
57517: CALL_OW 311
57521: NOT
57522: AND
57523: PUSH
57524: LD_VAR 0 4
57528: PPUSH
57529: CALL_OW 266
57533: PUSH
57534: LD_INT 36
57536: EQUAL
57537: PUSH
57538: LD_VAR 0 4
57542: PPUSH
57543: CALL_OW 313
57547: PUSH
57548: LD_INT 3
57550: LESS
57551: AND
57552: OR
57553: IFFALSE 57567
// begin ct := k ;
57555: LD_ADDR_VAR 0 8
57559: PUSH
57560: LD_VAR 0 4
57564: ST_TO_ADDR
// break ;
57565: GO 57569
// end ;
57567: GO 57495
57569: POP
57570: POP
// if ct then
57571: LD_VAR 0 8
57575: IFFALSE 57591
// ComEnterUnit ( j , ct ) ;
57577: LD_VAR 0 3
57581: PPUSH
57582: LD_VAR 0 8
57586: PPUSH
57587: CALL_OW 120
// end ; end ;
57591: GO 57226
57593: POP
57594: POP
// places := 0 ;
57595: LD_ADDR_VAR 0 5
57599: PUSH
57600: LD_INT 0
57602: ST_TO_ADDR
// for j = 1 to x do
57603: LD_ADDR_VAR 0 3
57607: PUSH
57608: DOUBLE
57609: LD_INT 1
57611: DEC
57612: ST_TO_ADDR
57613: LD_VAR 0 11
57617: PUSH
57618: FOR_TO
57619: IFFALSE 57695
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57621: LD_VAR 0 11
57625: PUSH
57626: LD_VAR 0 3
57630: ARRAY
57631: PPUSH
57632: CALL_OW 264
57636: PUSH
57637: LD_INT 31
57639: EQUAL
57640: IFFALSE 57658
// places := places + 1 else
57642: LD_ADDR_VAR 0 5
57646: PUSH
57647: LD_VAR 0 5
57651: PUSH
57652: LD_INT 1
57654: PLUS
57655: ST_TO_ADDR
57656: GO 57693
// if GetBType ( x [ j ] ) = b_control_tower then
57658: LD_VAR 0 11
57662: PUSH
57663: LD_VAR 0 3
57667: ARRAY
57668: PPUSH
57669: CALL_OW 266
57673: PUSH
57674: LD_INT 36
57676: EQUAL
57677: IFFALSE 57693
// places := places + 3 ;
57679: LD_ADDR_VAR 0 5
57683: PUSH
57684: LD_VAR 0 5
57688: PUSH
57689: LD_INT 3
57691: PLUS
57692: ST_TO_ADDR
57693: GO 57618
57695: POP
57696: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57697: LD_VAR 0 5
57701: PUSH
57702: LD_INT 0
57704: EQUAL
57705: PUSH
57706: LD_VAR 0 5
57710: PUSH
57711: LD_EXP 155
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: LESSEQUAL
57722: OR
57723: IFFALSE 57727
// continue ;
57725: GO 56977
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57727: LD_ADDR_VAR 0 6
57731: PUSH
57732: LD_EXP 115
57736: PUSH
57737: LD_VAR 0 2
57741: ARRAY
57742: PPUSH
57743: LD_INT 25
57745: PUSH
57746: LD_INT 3
57748: PUSH
57749: EMPTY
57750: LIST
57751: LIST
57752: PPUSH
57753: CALL_OW 72
57757: PUSH
57758: LD_EXP 155
57762: PUSH
57763: LD_VAR 0 2
57767: ARRAY
57768: DIFF
57769: PPUSH
57770: LD_INT 3
57772: PPUSH
57773: CALL 101830 0 2
57777: ST_TO_ADDR
// for j in tmp do
57778: LD_ADDR_VAR 0 3
57782: PUSH
57783: LD_VAR 0 6
57787: PUSH
57788: FOR_IN
57789: IFFALSE 57824
// if GetTag ( j ) > 0 then
57791: LD_VAR 0 3
57795: PPUSH
57796: CALL_OW 110
57800: PUSH
57801: LD_INT 0
57803: GREATER
57804: IFFALSE 57822
// tmp := tmp diff j ;
57806: LD_ADDR_VAR 0 6
57810: PUSH
57811: LD_VAR 0 6
57815: PUSH
57816: LD_VAR 0 3
57820: DIFF
57821: ST_TO_ADDR
57822: GO 57788
57824: POP
57825: POP
// if not tmp then
57826: LD_VAR 0 6
57830: NOT
57831: IFFALSE 57835
// continue ;
57833: GO 56977
// if places then
57835: LD_VAR 0 5
57839: IFFALSE 57898
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57841: LD_ADDR_EXP 155
57845: PUSH
57846: LD_EXP 155
57850: PPUSH
57851: LD_VAR 0 2
57855: PPUSH
57856: LD_EXP 155
57860: PUSH
57861: LD_VAR 0 2
57865: ARRAY
57866: PUSH
57867: LD_VAR 0 6
57871: PUSH
57872: LD_INT 1
57874: ARRAY
57875: UNION
57876: PPUSH
57877: CALL_OW 1
57881: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57882: LD_VAR 0 6
57886: PUSH
57887: LD_INT 1
57889: ARRAY
57890: PPUSH
57891: LD_INT 126
57893: PPUSH
57894: CALL_OW 109
// end ; end ;
57898: GO 56977
57900: POP
57901: POP
// end ;
57902: LD_VAR 0 1
57906: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57907: LD_INT 0
57909: PPUSH
57910: PPUSH
57911: PPUSH
57912: PPUSH
57913: PPUSH
57914: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57915: LD_VAR 0 1
57919: NOT
57920: PUSH
57921: LD_VAR 0 2
57925: NOT
57926: OR
57927: PUSH
57928: LD_VAR 0 3
57932: NOT
57933: OR
57934: PUSH
57935: LD_VAR 0 4
57939: PUSH
57940: LD_INT 1
57942: PUSH
57943: LD_INT 2
57945: PUSH
57946: LD_INT 3
57948: PUSH
57949: LD_INT 4
57951: PUSH
57952: LD_INT 5
57954: PUSH
57955: LD_INT 8
57957: PUSH
57958: LD_INT 9
57960: PUSH
57961: LD_INT 15
57963: PUSH
57964: LD_INT 16
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: LIST
57971: LIST
57972: LIST
57973: LIST
57974: LIST
57975: LIST
57976: LIST
57977: IN
57978: NOT
57979: OR
57980: IFFALSE 57984
// exit ;
57982: GO 58884
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57984: LD_ADDR_VAR 0 2
57988: PUSH
57989: LD_VAR 0 2
57993: PPUSH
57994: LD_INT 21
57996: PUSH
57997: LD_INT 3
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PUSH
58004: LD_INT 24
58006: PUSH
58007: LD_INT 250
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: PPUSH
58018: CALL_OW 72
58022: ST_TO_ADDR
// case class of 1 , 15 :
58023: LD_VAR 0 4
58027: PUSH
58028: LD_INT 1
58030: DOUBLE
58031: EQUAL
58032: IFTRUE 58042
58034: LD_INT 15
58036: DOUBLE
58037: EQUAL
58038: IFTRUE 58042
58040: GO 58127
58042: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58043: LD_ADDR_VAR 0 8
58047: PUSH
58048: LD_VAR 0 2
58052: PPUSH
58053: LD_INT 2
58055: PUSH
58056: LD_INT 30
58058: PUSH
58059: LD_INT 32
58061: PUSH
58062: EMPTY
58063: LIST
58064: LIST
58065: PUSH
58066: LD_INT 30
58068: PUSH
58069: LD_INT 31
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: PUSH
58076: EMPTY
58077: LIST
58078: LIST
58079: LIST
58080: PPUSH
58081: CALL_OW 72
58085: PUSH
58086: LD_VAR 0 2
58090: PPUSH
58091: LD_INT 2
58093: PUSH
58094: LD_INT 30
58096: PUSH
58097: LD_INT 4
58099: PUSH
58100: EMPTY
58101: LIST
58102: LIST
58103: PUSH
58104: LD_INT 30
58106: PUSH
58107: LD_INT 5
58109: PUSH
58110: EMPTY
58111: LIST
58112: LIST
58113: PUSH
58114: EMPTY
58115: LIST
58116: LIST
58117: LIST
58118: PPUSH
58119: CALL_OW 72
58123: ADD
58124: ST_TO_ADDR
58125: GO 58373
58127: LD_INT 2
58129: DOUBLE
58130: EQUAL
58131: IFTRUE 58141
58133: LD_INT 16
58135: DOUBLE
58136: EQUAL
58137: IFTRUE 58141
58139: GO 58187
58141: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58142: LD_ADDR_VAR 0 8
58146: PUSH
58147: LD_VAR 0 2
58151: PPUSH
58152: LD_INT 2
58154: PUSH
58155: LD_INT 30
58157: PUSH
58158: LD_INT 0
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: PUSH
58165: LD_INT 30
58167: PUSH
58168: LD_INT 1
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PUSH
58175: EMPTY
58176: LIST
58177: LIST
58178: LIST
58179: PPUSH
58180: CALL_OW 72
58184: ST_TO_ADDR
58185: GO 58373
58187: LD_INT 3
58189: DOUBLE
58190: EQUAL
58191: IFTRUE 58195
58193: GO 58241
58195: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58196: LD_ADDR_VAR 0 8
58200: PUSH
58201: LD_VAR 0 2
58205: PPUSH
58206: LD_INT 2
58208: PUSH
58209: LD_INT 30
58211: PUSH
58212: LD_INT 2
58214: PUSH
58215: EMPTY
58216: LIST
58217: LIST
58218: PUSH
58219: LD_INT 30
58221: PUSH
58222: LD_INT 3
58224: PUSH
58225: EMPTY
58226: LIST
58227: LIST
58228: PUSH
58229: EMPTY
58230: LIST
58231: LIST
58232: LIST
58233: PPUSH
58234: CALL_OW 72
58238: ST_TO_ADDR
58239: GO 58373
58241: LD_INT 4
58243: DOUBLE
58244: EQUAL
58245: IFTRUE 58249
58247: GO 58306
58249: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58250: LD_ADDR_VAR 0 8
58254: PUSH
58255: LD_VAR 0 2
58259: PPUSH
58260: LD_INT 2
58262: PUSH
58263: LD_INT 30
58265: PUSH
58266: LD_INT 6
58268: PUSH
58269: EMPTY
58270: LIST
58271: LIST
58272: PUSH
58273: LD_INT 30
58275: PUSH
58276: LD_INT 7
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: PUSH
58283: LD_INT 30
58285: PUSH
58286: LD_INT 8
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: PUSH
58293: EMPTY
58294: LIST
58295: LIST
58296: LIST
58297: LIST
58298: PPUSH
58299: CALL_OW 72
58303: ST_TO_ADDR
58304: GO 58373
58306: LD_INT 5
58308: DOUBLE
58309: EQUAL
58310: IFTRUE 58326
58312: LD_INT 8
58314: DOUBLE
58315: EQUAL
58316: IFTRUE 58326
58318: LD_INT 9
58320: DOUBLE
58321: EQUAL
58322: IFTRUE 58326
58324: GO 58372
58326: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58327: LD_ADDR_VAR 0 8
58331: PUSH
58332: LD_VAR 0 2
58336: PPUSH
58337: LD_INT 2
58339: PUSH
58340: LD_INT 30
58342: PUSH
58343: LD_INT 4
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PUSH
58350: LD_INT 30
58352: PUSH
58353: LD_INT 5
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: LIST
58364: PPUSH
58365: CALL_OW 72
58369: ST_TO_ADDR
58370: GO 58373
58372: POP
// if not tmp then
58373: LD_VAR 0 8
58377: NOT
58378: IFFALSE 58382
// exit ;
58380: GO 58884
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58382: LD_VAR 0 4
58386: PUSH
58387: LD_INT 1
58389: PUSH
58390: LD_INT 15
58392: PUSH
58393: EMPTY
58394: LIST
58395: LIST
58396: IN
58397: PUSH
58398: LD_EXP 124
58402: PUSH
58403: LD_VAR 0 1
58407: ARRAY
58408: AND
58409: IFFALSE 58565
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58411: LD_ADDR_VAR 0 9
58415: PUSH
58416: LD_EXP 124
58420: PUSH
58421: LD_VAR 0 1
58425: ARRAY
58426: PUSH
58427: LD_INT 1
58429: ARRAY
58430: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58431: LD_VAR 0 9
58435: PUSH
58436: LD_EXP 125
58440: PUSH
58441: LD_VAR 0 1
58445: ARRAY
58446: IN
58447: NOT
58448: IFFALSE 58563
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58450: LD_ADDR_EXP 125
58454: PUSH
58455: LD_EXP 125
58459: PPUSH
58460: LD_VAR 0 1
58464: PUSH
58465: LD_EXP 125
58469: PUSH
58470: LD_VAR 0 1
58474: ARRAY
58475: PUSH
58476: LD_INT 1
58478: PLUS
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: PPUSH
58484: LD_VAR 0 9
58488: PPUSH
58489: CALL 71059 0 3
58493: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58494: LD_ADDR_EXP 124
58498: PUSH
58499: LD_EXP 124
58503: PPUSH
58504: LD_VAR 0 1
58508: PPUSH
58509: LD_EXP 124
58513: PUSH
58514: LD_VAR 0 1
58518: ARRAY
58519: PUSH
58520: LD_VAR 0 9
58524: DIFF
58525: PPUSH
58526: CALL_OW 1
58530: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58531: LD_VAR 0 3
58535: PPUSH
58536: LD_EXP 125
58540: PUSH
58541: LD_VAR 0 1
58545: ARRAY
58546: PUSH
58547: LD_EXP 125
58551: PUSH
58552: LD_VAR 0 1
58556: ARRAY
58557: ARRAY
58558: PPUSH
58559: CALL_OW 120
// end ; exit ;
58563: GO 58884
// end ; if tmp > 1 then
58565: LD_VAR 0 8
58569: PUSH
58570: LD_INT 1
58572: GREATER
58573: IFFALSE 58677
// for i = 2 to tmp do
58575: LD_ADDR_VAR 0 6
58579: PUSH
58580: DOUBLE
58581: LD_INT 2
58583: DEC
58584: ST_TO_ADDR
58585: LD_VAR 0 8
58589: PUSH
58590: FOR_TO
58591: IFFALSE 58675
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58593: LD_VAR 0 8
58597: PUSH
58598: LD_VAR 0 6
58602: ARRAY
58603: PPUSH
58604: CALL_OW 461
58608: PUSH
58609: LD_INT 6
58611: EQUAL
58612: IFFALSE 58673
// begin x := tmp [ i ] ;
58614: LD_ADDR_VAR 0 9
58618: PUSH
58619: LD_VAR 0 8
58623: PUSH
58624: LD_VAR 0 6
58628: ARRAY
58629: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58630: LD_ADDR_VAR 0 8
58634: PUSH
58635: LD_VAR 0 8
58639: PPUSH
58640: LD_VAR 0 6
58644: PPUSH
58645: CALL_OW 3
58649: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58650: LD_ADDR_VAR 0 8
58654: PUSH
58655: LD_VAR 0 8
58659: PPUSH
58660: LD_INT 1
58662: PPUSH
58663: LD_VAR 0 9
58667: PPUSH
58668: CALL_OW 2
58672: ST_TO_ADDR
// end ;
58673: GO 58590
58675: POP
58676: POP
// for i in tmp do
58677: LD_ADDR_VAR 0 6
58681: PUSH
58682: LD_VAR 0 8
58686: PUSH
58687: FOR_IN
58688: IFFALSE 58757
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58690: LD_VAR 0 6
58694: PPUSH
58695: CALL_OW 313
58699: PUSH
58700: LD_INT 6
58702: LESS
58703: PUSH
58704: LD_VAR 0 6
58708: PPUSH
58709: CALL_OW 266
58713: PUSH
58714: LD_INT 31
58716: PUSH
58717: LD_INT 32
58719: PUSH
58720: EMPTY
58721: LIST
58722: LIST
58723: IN
58724: NOT
58725: AND
58726: PUSH
58727: LD_VAR 0 6
58731: PPUSH
58732: CALL_OW 313
58736: PUSH
58737: LD_INT 0
58739: EQUAL
58740: OR
58741: IFFALSE 58755
// begin j := i ;
58743: LD_ADDR_VAR 0 7
58747: PUSH
58748: LD_VAR 0 6
58752: ST_TO_ADDR
// break ;
58753: GO 58757
// end ; end ;
58755: GO 58687
58757: POP
58758: POP
// if j then
58759: LD_VAR 0 7
58763: IFFALSE 58781
// ComEnterUnit ( unit , j ) else
58765: LD_VAR 0 3
58769: PPUSH
58770: LD_VAR 0 7
58774: PPUSH
58775: CALL_OW 120
58779: GO 58884
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58781: LD_ADDR_VAR 0 10
58785: PUSH
58786: LD_VAR 0 2
58790: PPUSH
58791: LD_INT 2
58793: PUSH
58794: LD_INT 30
58796: PUSH
58797: LD_INT 0
58799: PUSH
58800: EMPTY
58801: LIST
58802: LIST
58803: PUSH
58804: LD_INT 30
58806: PUSH
58807: LD_INT 1
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: PUSH
58814: EMPTY
58815: LIST
58816: LIST
58817: LIST
58818: PPUSH
58819: CALL_OW 72
58823: ST_TO_ADDR
// if depot then
58824: LD_VAR 0 10
58828: IFFALSE 58884
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58830: LD_ADDR_VAR 0 10
58834: PUSH
58835: LD_VAR 0 10
58839: PPUSH
58840: LD_VAR 0 3
58844: PPUSH
58845: CALL_OW 74
58849: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58850: LD_VAR 0 3
58854: PPUSH
58855: LD_VAR 0 10
58859: PPUSH
58860: CALL_OW 296
58864: PUSH
58865: LD_INT 10
58867: GREATER
58868: IFFALSE 58884
// ComStandNearbyBuilding ( unit , depot ) ;
58870: LD_VAR 0 3
58874: PPUSH
58875: LD_VAR 0 10
58879: PPUSH
58880: CALL 67484 0 2
// end ; end ; end ;
58884: LD_VAR 0 5
58888: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58889: LD_INT 0
58891: PPUSH
58892: PPUSH
58893: PPUSH
58894: PPUSH
// if not mc_bases then
58895: LD_EXP 115
58899: NOT
58900: IFFALSE 58904
// exit ;
58902: GO 59143
// for i = 1 to mc_bases do
58904: LD_ADDR_VAR 0 2
58908: PUSH
58909: DOUBLE
58910: LD_INT 1
58912: DEC
58913: ST_TO_ADDR
58914: LD_EXP 115
58918: PUSH
58919: FOR_TO
58920: IFFALSE 59141
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58922: LD_ADDR_VAR 0 4
58926: PUSH
58927: LD_EXP 115
58931: PUSH
58932: LD_VAR 0 2
58936: ARRAY
58937: PPUSH
58938: LD_INT 21
58940: PUSH
58941: LD_INT 1
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: PPUSH
58948: CALL_OW 72
58952: PUSH
58953: LD_EXP 144
58957: PUSH
58958: LD_VAR 0 2
58962: ARRAY
58963: UNION
58964: ST_TO_ADDR
// if not tmp then
58965: LD_VAR 0 4
58969: NOT
58970: IFFALSE 58974
// continue ;
58972: GO 58919
// for j in tmp do
58974: LD_ADDR_VAR 0 3
58978: PUSH
58979: LD_VAR 0 4
58983: PUSH
58984: FOR_IN
58985: IFFALSE 59137
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58987: LD_VAR 0 3
58991: PPUSH
58992: CALL_OW 110
58996: NOT
58997: PUSH
58998: LD_VAR 0 3
59002: PPUSH
59003: CALL_OW 314
59007: NOT
59008: AND
59009: PUSH
59010: LD_VAR 0 3
59014: PPUSH
59015: CALL_OW 311
59019: NOT
59020: AND
59021: PUSH
59022: LD_VAR 0 3
59026: PPUSH
59027: CALL_OW 310
59031: NOT
59032: AND
59033: PUSH
59034: LD_VAR 0 3
59038: PUSH
59039: LD_EXP 118
59043: PUSH
59044: LD_VAR 0 2
59048: ARRAY
59049: PUSH
59050: LD_INT 1
59052: ARRAY
59053: IN
59054: NOT
59055: AND
59056: PUSH
59057: LD_VAR 0 3
59061: PUSH
59062: LD_EXP 118
59066: PUSH
59067: LD_VAR 0 2
59071: ARRAY
59072: PUSH
59073: LD_INT 2
59075: ARRAY
59076: IN
59077: NOT
59078: AND
59079: PUSH
59080: LD_VAR 0 3
59084: PUSH
59085: LD_EXP 127
59089: PUSH
59090: LD_VAR 0 2
59094: ARRAY
59095: IN
59096: NOT
59097: AND
59098: IFFALSE 59135
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59100: LD_VAR 0 2
59104: PPUSH
59105: LD_EXP 115
59109: PUSH
59110: LD_VAR 0 2
59114: ARRAY
59115: PPUSH
59116: LD_VAR 0 3
59120: PPUSH
59121: LD_VAR 0 3
59125: PPUSH
59126: CALL_OW 257
59130: PPUSH
59131: CALL 57907 0 4
// end ;
59135: GO 58984
59137: POP
59138: POP
// end ;
59139: GO 58919
59141: POP
59142: POP
// end ;
59143: LD_VAR 0 1
59147: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59148: LD_INT 0
59150: PPUSH
59151: PPUSH
59152: PPUSH
59153: PPUSH
59154: PPUSH
59155: PPUSH
// if not mc_bases [ base ] then
59156: LD_EXP 115
59160: PUSH
59161: LD_VAR 0 1
59165: ARRAY
59166: NOT
59167: IFFALSE 59171
// exit ;
59169: GO 59353
// tmp := [ ] ;
59171: LD_ADDR_VAR 0 6
59175: PUSH
59176: EMPTY
59177: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59178: LD_ADDR_VAR 0 7
59182: PUSH
59183: LD_VAR 0 3
59187: PPUSH
59188: LD_INT 0
59190: PPUSH
59191: CALL_OW 517
59195: ST_TO_ADDR
// if not list then
59196: LD_VAR 0 7
59200: NOT
59201: IFFALSE 59205
// exit ;
59203: GO 59353
// for i = 1 to amount do
59205: LD_ADDR_VAR 0 5
59209: PUSH
59210: DOUBLE
59211: LD_INT 1
59213: DEC
59214: ST_TO_ADDR
59215: LD_VAR 0 2
59219: PUSH
59220: FOR_TO
59221: IFFALSE 59301
// begin x := rand ( 1 , list [ 1 ] ) ;
59223: LD_ADDR_VAR 0 8
59227: PUSH
59228: LD_INT 1
59230: PPUSH
59231: LD_VAR 0 7
59235: PUSH
59236: LD_INT 1
59238: ARRAY
59239: PPUSH
59240: CALL_OW 12
59244: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59245: LD_ADDR_VAR 0 6
59249: PUSH
59250: LD_VAR 0 6
59254: PPUSH
59255: LD_VAR 0 5
59259: PPUSH
59260: LD_VAR 0 7
59264: PUSH
59265: LD_INT 1
59267: ARRAY
59268: PUSH
59269: LD_VAR 0 8
59273: ARRAY
59274: PUSH
59275: LD_VAR 0 7
59279: PUSH
59280: LD_INT 2
59282: ARRAY
59283: PUSH
59284: LD_VAR 0 8
59288: ARRAY
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PPUSH
59294: CALL_OW 1
59298: ST_TO_ADDR
// end ;
59299: GO 59220
59301: POP
59302: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59303: LD_ADDR_EXP 128
59307: PUSH
59308: LD_EXP 128
59312: PPUSH
59313: LD_VAR 0 1
59317: PPUSH
59318: LD_VAR 0 6
59322: PPUSH
59323: CALL_OW 1
59327: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59328: LD_ADDR_EXP 130
59332: PUSH
59333: LD_EXP 130
59337: PPUSH
59338: LD_VAR 0 1
59342: PPUSH
59343: LD_VAR 0 3
59347: PPUSH
59348: CALL_OW 1
59352: ST_TO_ADDR
// end ;
59353: LD_VAR 0 4
59357: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59358: LD_INT 0
59360: PPUSH
// if not mc_bases [ base ] then
59361: LD_EXP 115
59365: PUSH
59366: LD_VAR 0 1
59370: ARRAY
59371: NOT
59372: IFFALSE 59376
// exit ;
59374: GO 59401
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59376: LD_ADDR_EXP 120
59380: PUSH
59381: LD_EXP 120
59385: PPUSH
59386: LD_VAR 0 1
59390: PPUSH
59391: LD_VAR 0 2
59395: PPUSH
59396: CALL_OW 1
59400: ST_TO_ADDR
// end ;
59401: LD_VAR 0 3
59405: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59406: LD_INT 0
59408: PPUSH
// if not mc_bases [ base ] then
59409: LD_EXP 115
59413: PUSH
59414: LD_VAR 0 1
59418: ARRAY
59419: NOT
59420: IFFALSE 59424
// exit ;
59422: GO 59461
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59424: LD_ADDR_EXP 120
59428: PUSH
59429: LD_EXP 120
59433: PPUSH
59434: LD_VAR 0 1
59438: PPUSH
59439: LD_EXP 120
59443: PUSH
59444: LD_VAR 0 1
59448: ARRAY
59449: PUSH
59450: LD_VAR 0 2
59454: UNION
59455: PPUSH
59456: CALL_OW 1
59460: ST_TO_ADDR
// end ;
59461: LD_VAR 0 3
59465: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59466: LD_INT 0
59468: PPUSH
// if not mc_bases [ base ] then
59469: LD_EXP 115
59473: PUSH
59474: LD_VAR 0 1
59478: ARRAY
59479: NOT
59480: IFFALSE 59484
// exit ;
59482: GO 59509
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59484: LD_ADDR_EXP 136
59488: PUSH
59489: LD_EXP 136
59493: PPUSH
59494: LD_VAR 0 1
59498: PPUSH
59499: LD_VAR 0 2
59503: PPUSH
59504: CALL_OW 1
59508: ST_TO_ADDR
// end ;
59509: LD_VAR 0 3
59513: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59514: LD_INT 0
59516: PPUSH
// if not mc_bases [ base ] then
59517: LD_EXP 115
59521: PUSH
59522: LD_VAR 0 1
59526: ARRAY
59527: NOT
59528: IFFALSE 59532
// exit ;
59530: GO 59569
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59532: LD_ADDR_EXP 136
59536: PUSH
59537: LD_EXP 136
59541: PPUSH
59542: LD_VAR 0 1
59546: PPUSH
59547: LD_EXP 136
59551: PUSH
59552: LD_VAR 0 1
59556: ARRAY
59557: PUSH
59558: LD_VAR 0 2
59562: ADD
59563: PPUSH
59564: CALL_OW 1
59568: ST_TO_ADDR
// end ;
59569: LD_VAR 0 3
59573: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59574: LD_INT 0
59576: PPUSH
// if not mc_bases [ base ] then
59577: LD_EXP 115
59581: PUSH
59582: LD_VAR 0 1
59586: ARRAY
59587: NOT
59588: IFFALSE 59592
// exit ;
59590: GO 59646
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59592: LD_ADDR_EXP 137
59596: PUSH
59597: LD_EXP 137
59601: PPUSH
59602: LD_VAR 0 1
59606: PPUSH
59607: LD_VAR 0 2
59611: PPUSH
59612: CALL_OW 1
59616: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59617: LD_ADDR_EXP 126
59621: PUSH
59622: LD_EXP 126
59626: PPUSH
59627: LD_VAR 0 1
59631: PPUSH
59632: LD_VAR 0 2
59636: PUSH
59637: LD_INT 0
59639: PLUS
59640: PPUSH
59641: CALL_OW 1
59645: ST_TO_ADDR
// end ;
59646: LD_VAR 0 3
59650: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59651: LD_INT 0
59653: PPUSH
// if not mc_bases [ base ] then
59654: LD_EXP 115
59658: PUSH
59659: LD_VAR 0 1
59663: ARRAY
59664: NOT
59665: IFFALSE 59669
// exit ;
59667: GO 59694
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59669: LD_ADDR_EXP 126
59673: PUSH
59674: LD_EXP 126
59678: PPUSH
59679: LD_VAR 0 1
59683: PPUSH
59684: LD_VAR 0 2
59688: PPUSH
59689: CALL_OW 1
59693: ST_TO_ADDR
// end ;
59694: LD_VAR 0 3
59698: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59699: LD_INT 0
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
// if not mc_bases [ base ] then
59705: LD_EXP 115
59709: PUSH
59710: LD_VAR 0 1
59714: ARRAY
59715: NOT
59716: IFFALSE 59720
// exit ;
59718: GO 59785
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59720: LD_ADDR_EXP 135
59724: PUSH
59725: LD_EXP 135
59729: PPUSH
59730: LD_VAR 0 1
59734: PUSH
59735: LD_EXP 135
59739: PUSH
59740: LD_VAR 0 1
59744: ARRAY
59745: PUSH
59746: LD_INT 1
59748: PLUS
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: LD_VAR 0 1
59758: PUSH
59759: LD_VAR 0 2
59763: PUSH
59764: LD_VAR 0 3
59768: PUSH
59769: LD_VAR 0 4
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: LIST
59778: LIST
59779: PPUSH
59780: CALL 71059 0 3
59784: ST_TO_ADDR
// end ;
59785: LD_VAR 0 5
59789: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59790: LD_INT 0
59792: PPUSH
// if not mc_bases [ base ] then
59793: LD_EXP 115
59797: PUSH
59798: LD_VAR 0 1
59802: ARRAY
59803: NOT
59804: IFFALSE 59808
// exit ;
59806: GO 59833
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59808: LD_ADDR_EXP 152
59812: PUSH
59813: LD_EXP 152
59817: PPUSH
59818: LD_VAR 0 1
59822: PPUSH
59823: LD_VAR 0 2
59827: PPUSH
59828: CALL_OW 1
59832: ST_TO_ADDR
// end ;
59833: LD_VAR 0 3
59837: RET
// export function MC_GetMinesField ( base ) ; begin
59838: LD_INT 0
59840: PPUSH
// result := mc_mines [ base ] ;
59841: LD_ADDR_VAR 0 2
59845: PUSH
59846: LD_EXP 128
59850: PUSH
59851: LD_VAR 0 1
59855: ARRAY
59856: ST_TO_ADDR
// end ;
59857: LD_VAR 0 2
59861: RET
// export function MC_GetProduceList ( base ) ; begin
59862: LD_INT 0
59864: PPUSH
// result := mc_produce [ base ] ;
59865: LD_ADDR_VAR 0 2
59869: PUSH
59870: LD_EXP 136
59874: PUSH
59875: LD_VAR 0 1
59879: ARRAY
59880: ST_TO_ADDR
// end ;
59881: LD_VAR 0 2
59885: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59886: LD_INT 0
59888: PPUSH
59889: PPUSH
// if not mc_bases then
59890: LD_EXP 115
59894: NOT
59895: IFFALSE 59899
// exit ;
59897: GO 59964
// if mc_bases [ base ] then
59899: LD_EXP 115
59903: PUSH
59904: LD_VAR 0 1
59908: ARRAY
59909: IFFALSE 59964
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59911: LD_ADDR_VAR 0 3
59915: PUSH
59916: LD_EXP 115
59920: PUSH
59921: LD_VAR 0 1
59925: ARRAY
59926: PPUSH
59927: LD_INT 30
59929: PUSH
59930: LD_VAR 0 2
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: PPUSH
59939: CALL_OW 72
59943: ST_TO_ADDR
// if result then
59944: LD_VAR 0 3
59948: IFFALSE 59964
// result := result [ 1 ] ;
59950: LD_ADDR_VAR 0 3
59954: PUSH
59955: LD_VAR 0 3
59959: PUSH
59960: LD_INT 1
59962: ARRAY
59963: ST_TO_ADDR
// end ; end ;
59964: LD_VAR 0 3
59968: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59969: LD_INT 0
59971: PPUSH
59972: PPUSH
// if not mc_bases then
59973: LD_EXP 115
59977: NOT
59978: IFFALSE 59982
// exit ;
59980: GO 60027
// if mc_bases [ base ] then
59982: LD_EXP 115
59986: PUSH
59987: LD_VAR 0 1
59991: ARRAY
59992: IFFALSE 60027
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59994: LD_ADDR_VAR 0 3
59998: PUSH
59999: LD_EXP 115
60003: PUSH
60004: LD_VAR 0 1
60008: ARRAY
60009: PPUSH
60010: LD_INT 30
60012: PUSH
60013: LD_VAR 0 2
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PPUSH
60022: CALL_OW 72
60026: ST_TO_ADDR
// end ;
60027: LD_VAR 0 3
60031: RET
// export function MC_SetTame ( base , area ) ; begin
60032: LD_INT 0
60034: PPUSH
// if not mc_bases or not base then
60035: LD_EXP 115
60039: NOT
60040: PUSH
60041: LD_VAR 0 1
60045: NOT
60046: OR
60047: IFFALSE 60051
// exit ;
60049: GO 60076
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60051: LD_ADDR_EXP 143
60055: PUSH
60056: LD_EXP 143
60060: PPUSH
60061: LD_VAR 0 1
60065: PPUSH
60066: LD_VAR 0 2
60070: PPUSH
60071: CALL_OW 1
60075: ST_TO_ADDR
// end ;
60076: LD_VAR 0 3
60080: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60081: LD_INT 0
60083: PPUSH
60084: PPUSH
// if not mc_bases or not base then
60085: LD_EXP 115
60089: NOT
60090: PUSH
60091: LD_VAR 0 1
60095: NOT
60096: OR
60097: IFFALSE 60101
// exit ;
60099: GO 60203
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60101: LD_ADDR_VAR 0 4
60105: PUSH
60106: LD_EXP 115
60110: PUSH
60111: LD_VAR 0 1
60115: ARRAY
60116: PPUSH
60117: LD_INT 30
60119: PUSH
60120: LD_VAR 0 2
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: PPUSH
60129: CALL_OW 72
60133: ST_TO_ADDR
// if not tmp then
60134: LD_VAR 0 4
60138: NOT
60139: IFFALSE 60143
// exit ;
60141: GO 60203
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60143: LD_ADDR_EXP 147
60147: PUSH
60148: LD_EXP 147
60152: PPUSH
60153: LD_VAR 0 1
60157: PPUSH
60158: LD_EXP 147
60162: PUSH
60163: LD_VAR 0 1
60167: ARRAY
60168: PPUSH
60169: LD_EXP 147
60173: PUSH
60174: LD_VAR 0 1
60178: ARRAY
60179: PUSH
60180: LD_INT 1
60182: PLUS
60183: PPUSH
60184: LD_VAR 0 4
60188: PUSH
60189: LD_INT 1
60191: ARRAY
60192: PPUSH
60193: CALL_OW 2
60197: PPUSH
60198: CALL_OW 1
60202: ST_TO_ADDR
// end ;
60203: LD_VAR 0 3
60207: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60208: LD_INT 0
60210: PPUSH
60211: PPUSH
// if not mc_bases or not base or not kinds then
60212: LD_EXP 115
60216: NOT
60217: PUSH
60218: LD_VAR 0 1
60222: NOT
60223: OR
60224: PUSH
60225: LD_VAR 0 2
60229: NOT
60230: OR
60231: IFFALSE 60235
// exit ;
60233: GO 60296
// for i in kinds do
60235: LD_ADDR_VAR 0 4
60239: PUSH
60240: LD_VAR 0 2
60244: PUSH
60245: FOR_IN
60246: IFFALSE 60294
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60248: LD_ADDR_EXP 149
60252: PUSH
60253: LD_EXP 149
60257: PPUSH
60258: LD_VAR 0 1
60262: PUSH
60263: LD_EXP 149
60267: PUSH
60268: LD_VAR 0 1
60272: ARRAY
60273: PUSH
60274: LD_INT 1
60276: PLUS
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: PPUSH
60282: LD_VAR 0 4
60286: PPUSH
60287: CALL 71059 0 3
60291: ST_TO_ADDR
60292: GO 60245
60294: POP
60295: POP
// end ;
60296: LD_VAR 0 3
60300: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60301: LD_INT 0
60303: PPUSH
// if not mc_bases or not base or not areas then
60304: LD_EXP 115
60308: NOT
60309: PUSH
60310: LD_VAR 0 1
60314: NOT
60315: OR
60316: PUSH
60317: LD_VAR 0 2
60321: NOT
60322: OR
60323: IFFALSE 60327
// exit ;
60325: GO 60352
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60327: LD_ADDR_EXP 133
60331: PUSH
60332: LD_EXP 133
60336: PPUSH
60337: LD_VAR 0 1
60341: PPUSH
60342: LD_VAR 0 2
60346: PPUSH
60347: CALL_OW 1
60351: ST_TO_ADDR
// end ;
60352: LD_VAR 0 3
60356: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60357: LD_INT 0
60359: PPUSH
// if not mc_bases or not base or not teleports_exit then
60360: LD_EXP 115
60364: NOT
60365: PUSH
60366: LD_VAR 0 1
60370: NOT
60371: OR
60372: PUSH
60373: LD_VAR 0 2
60377: NOT
60378: OR
60379: IFFALSE 60383
// exit ;
60381: GO 60408
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60383: LD_ADDR_EXP 150
60387: PUSH
60388: LD_EXP 150
60392: PPUSH
60393: LD_VAR 0 1
60397: PPUSH
60398: LD_VAR 0 2
60402: PPUSH
60403: CALL_OW 1
60407: ST_TO_ADDR
// end ;
60408: LD_VAR 0 3
60412: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60413: LD_INT 0
60415: PPUSH
60416: PPUSH
60417: PPUSH
// if not mc_bases or not base or not ext_list then
60418: LD_EXP 115
60422: NOT
60423: PUSH
60424: LD_VAR 0 1
60428: NOT
60429: OR
60430: PUSH
60431: LD_VAR 0 5
60435: NOT
60436: OR
60437: IFFALSE 60441
// exit ;
60439: GO 60614
// tmp := GetFacExtXYD ( x , y , d ) ;
60441: LD_ADDR_VAR 0 8
60445: PUSH
60446: LD_VAR 0 2
60450: PPUSH
60451: LD_VAR 0 3
60455: PPUSH
60456: LD_VAR 0 4
60460: PPUSH
60461: CALL 100960 0 3
60465: ST_TO_ADDR
// if not tmp then
60466: LD_VAR 0 8
60470: NOT
60471: IFFALSE 60475
// exit ;
60473: GO 60614
// for i in tmp do
60475: LD_ADDR_VAR 0 7
60479: PUSH
60480: LD_VAR 0 8
60484: PUSH
60485: FOR_IN
60486: IFFALSE 60612
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60488: LD_ADDR_EXP 120
60492: PUSH
60493: LD_EXP 120
60497: PPUSH
60498: LD_VAR 0 1
60502: PPUSH
60503: LD_EXP 120
60507: PUSH
60508: LD_VAR 0 1
60512: ARRAY
60513: PPUSH
60514: LD_EXP 120
60518: PUSH
60519: LD_VAR 0 1
60523: ARRAY
60524: PUSH
60525: LD_INT 1
60527: PLUS
60528: PPUSH
60529: LD_VAR 0 5
60533: PUSH
60534: LD_INT 1
60536: ARRAY
60537: PUSH
60538: LD_VAR 0 7
60542: PUSH
60543: LD_INT 1
60545: ARRAY
60546: PUSH
60547: LD_VAR 0 7
60551: PUSH
60552: LD_INT 2
60554: ARRAY
60555: PUSH
60556: LD_VAR 0 7
60560: PUSH
60561: LD_INT 3
60563: ARRAY
60564: PUSH
60565: EMPTY
60566: LIST
60567: LIST
60568: LIST
60569: LIST
60570: PPUSH
60571: CALL_OW 2
60575: PPUSH
60576: CALL_OW 1
60580: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60581: LD_ADDR_VAR 0 5
60585: PUSH
60586: LD_VAR 0 5
60590: PPUSH
60591: LD_INT 1
60593: PPUSH
60594: CALL_OW 3
60598: ST_TO_ADDR
// if not ext_list then
60599: LD_VAR 0 5
60603: NOT
60604: IFFALSE 60610
// exit ;
60606: POP
60607: POP
60608: GO 60614
// end ;
60610: GO 60485
60612: POP
60613: POP
// end ;
60614: LD_VAR 0 6
60618: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60619: LD_INT 0
60621: PPUSH
// if not mc_bases or not base or not weapon_list then
60622: LD_EXP 115
60626: NOT
60627: PUSH
60628: LD_VAR 0 1
60632: NOT
60633: OR
60634: PUSH
60635: LD_VAR 0 2
60639: NOT
60640: OR
60641: IFFALSE 60645
// exit ;
60643: GO 60670
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60645: LD_ADDR_EXP 154
60649: PUSH
60650: LD_EXP 154
60654: PPUSH
60655: LD_VAR 0 1
60659: PPUSH
60660: LD_VAR 0 2
60664: PPUSH
60665: CALL_OW 1
60669: ST_TO_ADDR
// end ;
60670: LD_VAR 0 3
60674: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60675: LD_INT 0
60677: PPUSH
// if not mc_bases or not base or not tech_list then
60678: LD_EXP 115
60682: NOT
60683: PUSH
60684: LD_VAR 0 1
60688: NOT
60689: OR
60690: PUSH
60691: LD_VAR 0 2
60695: NOT
60696: OR
60697: IFFALSE 60701
// exit ;
60699: GO 60726
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60701: LD_ADDR_EXP 142
60705: PUSH
60706: LD_EXP 142
60710: PPUSH
60711: LD_VAR 0 1
60715: PPUSH
60716: LD_VAR 0 2
60720: PPUSH
60721: CALL_OW 1
60725: ST_TO_ADDR
// end ;
60726: LD_VAR 0 3
60730: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60731: LD_INT 0
60733: PPUSH
// if not mc_bases or not parking_area or not base then
60734: LD_EXP 115
60738: NOT
60739: PUSH
60740: LD_VAR 0 2
60744: NOT
60745: OR
60746: PUSH
60747: LD_VAR 0 1
60751: NOT
60752: OR
60753: IFFALSE 60757
// exit ;
60755: GO 60782
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60757: LD_ADDR_EXP 139
60761: PUSH
60762: LD_EXP 139
60766: PPUSH
60767: LD_VAR 0 1
60771: PPUSH
60772: LD_VAR 0 2
60776: PPUSH
60777: CALL_OW 1
60781: ST_TO_ADDR
// end ;
60782: LD_VAR 0 3
60786: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60787: LD_INT 0
60789: PPUSH
// if not mc_bases or not base or not scan_area then
60790: LD_EXP 115
60794: NOT
60795: PUSH
60796: LD_VAR 0 1
60800: NOT
60801: OR
60802: PUSH
60803: LD_VAR 0 2
60807: NOT
60808: OR
60809: IFFALSE 60813
// exit ;
60811: GO 60838
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60813: LD_ADDR_EXP 140
60817: PUSH
60818: LD_EXP 140
60822: PPUSH
60823: LD_VAR 0 1
60827: PPUSH
60828: LD_VAR 0 2
60832: PPUSH
60833: CALL_OW 1
60837: ST_TO_ADDR
// end ;
60838: LD_VAR 0 3
60842: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60843: LD_INT 0
60845: PPUSH
60846: PPUSH
// if not mc_bases or not base then
60847: LD_EXP 115
60851: NOT
60852: PUSH
60853: LD_VAR 0 1
60857: NOT
60858: OR
60859: IFFALSE 60863
// exit ;
60861: GO 60927
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60863: LD_ADDR_VAR 0 3
60867: PUSH
60868: LD_INT 1
60870: PUSH
60871: LD_INT 2
60873: PUSH
60874: LD_INT 3
60876: PUSH
60877: LD_INT 4
60879: PUSH
60880: LD_INT 11
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60890: LD_ADDR_EXP 142
60894: PUSH
60895: LD_EXP 142
60899: PPUSH
60900: LD_VAR 0 1
60904: PPUSH
60905: LD_EXP 142
60909: PUSH
60910: LD_VAR 0 1
60914: ARRAY
60915: PUSH
60916: LD_VAR 0 3
60920: DIFF
60921: PPUSH
60922: CALL_OW 1
60926: ST_TO_ADDR
// end ;
60927: LD_VAR 0 2
60931: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60932: LD_INT 0
60934: PPUSH
// result := mc_vehicles [ base ] ;
60935: LD_ADDR_VAR 0 3
60939: PUSH
60940: LD_EXP 134
60944: PUSH
60945: LD_VAR 0 1
60949: ARRAY
60950: ST_TO_ADDR
// if onlyCombat then
60951: LD_VAR 0 2
60955: IFFALSE 61133
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60957: LD_ADDR_VAR 0 3
60961: PUSH
60962: LD_VAR 0 3
60966: PUSH
60967: LD_VAR 0 3
60971: PPUSH
60972: LD_INT 2
60974: PUSH
60975: LD_INT 34
60977: PUSH
60978: LD_INT 12
60980: PUSH
60981: EMPTY
60982: LIST
60983: LIST
60984: PUSH
60985: LD_INT 34
60987: PUSH
60988: LD_INT 51
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: PUSH
60995: LD_INT 34
60997: PUSH
60998: LD_EXP 96
61002: PUSH
61003: EMPTY
61004: LIST
61005: LIST
61006: PUSH
61007: LD_INT 34
61009: PUSH
61010: LD_INT 32
61012: PUSH
61013: EMPTY
61014: LIST
61015: LIST
61016: PUSH
61017: LD_INT 34
61019: PUSH
61020: LD_INT 13
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PUSH
61027: LD_INT 34
61029: PUSH
61030: LD_INT 52
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: PUSH
61037: LD_INT 34
61039: PUSH
61040: LD_EXP 101
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PUSH
61049: LD_INT 34
61051: PUSH
61052: LD_INT 14
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 34
61061: PUSH
61062: LD_INT 53
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: LD_INT 34
61071: PUSH
61072: LD_EXP 95
61076: PUSH
61077: EMPTY
61078: LIST
61079: LIST
61080: PUSH
61081: LD_INT 34
61083: PUSH
61084: LD_INT 31
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PUSH
61091: LD_INT 34
61093: PUSH
61094: LD_INT 48
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: PUSH
61101: LD_INT 34
61103: PUSH
61104: LD_INT 8
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: LIST
61124: LIST
61125: LIST
61126: PPUSH
61127: CALL_OW 72
61131: DIFF
61132: ST_TO_ADDR
// end ; end_of_file
61133: LD_VAR 0 3
61137: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61138: LD_INT 0
61140: PPUSH
61141: PPUSH
61142: PPUSH
// if not mc_bases or not skirmish then
61143: LD_EXP 115
61147: NOT
61148: PUSH
61149: LD_EXP 113
61153: NOT
61154: OR
61155: IFFALSE 61159
// exit ;
61157: GO 61324
// for i = 1 to mc_bases do
61159: LD_ADDR_VAR 0 4
61163: PUSH
61164: DOUBLE
61165: LD_INT 1
61167: DEC
61168: ST_TO_ADDR
61169: LD_EXP 115
61173: PUSH
61174: FOR_TO
61175: IFFALSE 61322
// begin if sci in mc_bases [ i ] then
61177: LD_VAR 0 2
61181: PUSH
61182: LD_EXP 115
61186: PUSH
61187: LD_VAR 0 4
61191: ARRAY
61192: IN
61193: IFFALSE 61320
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61195: LD_ADDR_EXP 144
61199: PUSH
61200: LD_EXP 144
61204: PPUSH
61205: LD_VAR 0 4
61209: PUSH
61210: LD_EXP 144
61214: PUSH
61215: LD_VAR 0 4
61219: ARRAY
61220: PUSH
61221: LD_INT 1
61223: PLUS
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: PPUSH
61229: LD_VAR 0 1
61233: PPUSH
61234: CALL 71059 0 3
61238: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61239: LD_ADDR_VAR 0 5
61243: PUSH
61244: LD_EXP 115
61248: PUSH
61249: LD_VAR 0 4
61253: ARRAY
61254: PPUSH
61255: LD_INT 2
61257: PUSH
61258: LD_INT 30
61260: PUSH
61261: LD_INT 0
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PUSH
61268: LD_INT 30
61270: PUSH
61271: LD_INT 1
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: EMPTY
61279: LIST
61280: LIST
61281: LIST
61282: PPUSH
61283: CALL_OW 72
61287: PPUSH
61288: LD_VAR 0 1
61292: PPUSH
61293: CALL_OW 74
61297: ST_TO_ADDR
// if tmp then
61298: LD_VAR 0 5
61302: IFFALSE 61318
// ComStandNearbyBuilding ( ape , tmp ) ;
61304: LD_VAR 0 1
61308: PPUSH
61309: LD_VAR 0 5
61313: PPUSH
61314: CALL 67484 0 2
// break ;
61318: GO 61322
// end ; end ;
61320: GO 61174
61322: POP
61323: POP
// end ;
61324: LD_VAR 0 3
61328: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61329: LD_INT 0
61331: PPUSH
61332: PPUSH
61333: PPUSH
// if not mc_bases or not skirmish then
61334: LD_EXP 115
61338: NOT
61339: PUSH
61340: LD_EXP 113
61344: NOT
61345: OR
61346: IFFALSE 61350
// exit ;
61348: GO 61439
// for i = 1 to mc_bases do
61350: LD_ADDR_VAR 0 4
61354: PUSH
61355: DOUBLE
61356: LD_INT 1
61358: DEC
61359: ST_TO_ADDR
61360: LD_EXP 115
61364: PUSH
61365: FOR_TO
61366: IFFALSE 61437
// begin if building in mc_busy_turret_list [ i ] then
61368: LD_VAR 0 1
61372: PUSH
61373: LD_EXP 125
61377: PUSH
61378: LD_VAR 0 4
61382: ARRAY
61383: IN
61384: IFFALSE 61435
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61386: LD_ADDR_VAR 0 5
61390: PUSH
61391: LD_EXP 125
61395: PUSH
61396: LD_VAR 0 4
61400: ARRAY
61401: PUSH
61402: LD_VAR 0 1
61406: DIFF
61407: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61408: LD_ADDR_EXP 125
61412: PUSH
61413: LD_EXP 125
61417: PPUSH
61418: LD_VAR 0 4
61422: PPUSH
61423: LD_VAR 0 5
61427: PPUSH
61428: CALL_OW 1
61432: ST_TO_ADDR
// break ;
61433: GO 61437
// end ; end ;
61435: GO 61365
61437: POP
61438: POP
// end ;
61439: LD_VAR 0 3
61443: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61444: LD_INT 0
61446: PPUSH
61447: PPUSH
61448: PPUSH
// if not mc_bases or not skirmish then
61449: LD_EXP 115
61453: NOT
61454: PUSH
61455: LD_EXP 113
61459: NOT
61460: OR
61461: IFFALSE 61465
// exit ;
61463: GO 61664
// for i = 1 to mc_bases do
61465: LD_ADDR_VAR 0 5
61469: PUSH
61470: DOUBLE
61471: LD_INT 1
61473: DEC
61474: ST_TO_ADDR
61475: LD_EXP 115
61479: PUSH
61480: FOR_TO
61481: IFFALSE 61662
// if building in mc_bases [ i ] then
61483: LD_VAR 0 1
61487: PUSH
61488: LD_EXP 115
61492: PUSH
61493: LD_VAR 0 5
61497: ARRAY
61498: IN
61499: IFFALSE 61660
// begin tmp := mc_bases [ i ] diff building ;
61501: LD_ADDR_VAR 0 6
61505: PUSH
61506: LD_EXP 115
61510: PUSH
61511: LD_VAR 0 5
61515: ARRAY
61516: PUSH
61517: LD_VAR 0 1
61521: DIFF
61522: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61523: LD_ADDR_EXP 115
61527: PUSH
61528: LD_EXP 115
61532: PPUSH
61533: LD_VAR 0 5
61537: PPUSH
61538: LD_VAR 0 6
61542: PPUSH
61543: CALL_OW 1
61547: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61548: LD_VAR 0 1
61552: PUSH
61553: LD_EXP 123
61557: PUSH
61558: LD_VAR 0 5
61562: ARRAY
61563: IN
61564: IFFALSE 61603
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61566: LD_ADDR_EXP 123
61570: PUSH
61571: LD_EXP 123
61575: PPUSH
61576: LD_VAR 0 5
61580: PPUSH
61581: LD_EXP 123
61585: PUSH
61586: LD_VAR 0 5
61590: ARRAY
61591: PUSH
61592: LD_VAR 0 1
61596: DIFF
61597: PPUSH
61598: CALL_OW 1
61602: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61603: LD_VAR 0 1
61607: PUSH
61608: LD_EXP 124
61612: PUSH
61613: LD_VAR 0 5
61617: ARRAY
61618: IN
61619: IFFALSE 61658
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61621: LD_ADDR_EXP 124
61625: PUSH
61626: LD_EXP 124
61630: PPUSH
61631: LD_VAR 0 5
61635: PPUSH
61636: LD_EXP 124
61640: PUSH
61641: LD_VAR 0 5
61645: ARRAY
61646: PUSH
61647: LD_VAR 0 1
61651: DIFF
61652: PPUSH
61653: CALL_OW 1
61657: ST_TO_ADDR
// break ;
61658: GO 61662
// end ;
61660: GO 61480
61662: POP
61663: POP
// end ;
61664: LD_VAR 0 4
61668: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61669: LD_INT 0
61671: PPUSH
61672: PPUSH
61673: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61674: LD_EXP 115
61678: NOT
61679: PUSH
61680: LD_EXP 113
61684: NOT
61685: OR
61686: PUSH
61687: LD_VAR 0 3
61691: PUSH
61692: LD_EXP 141
61696: IN
61697: NOT
61698: OR
61699: IFFALSE 61703
// exit ;
61701: GO 61826
// for i = 1 to mc_vehicles do
61703: LD_ADDR_VAR 0 6
61707: PUSH
61708: DOUBLE
61709: LD_INT 1
61711: DEC
61712: ST_TO_ADDR
61713: LD_EXP 134
61717: PUSH
61718: FOR_TO
61719: IFFALSE 61824
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61721: LD_VAR 0 2
61725: PUSH
61726: LD_EXP 134
61730: PUSH
61731: LD_VAR 0 6
61735: ARRAY
61736: IN
61737: PUSH
61738: LD_VAR 0 1
61742: PUSH
61743: LD_EXP 134
61747: PUSH
61748: LD_VAR 0 6
61752: ARRAY
61753: IN
61754: OR
61755: IFFALSE 61822
// begin tmp := mc_vehicles [ i ] diff old ;
61757: LD_ADDR_VAR 0 7
61761: PUSH
61762: LD_EXP 134
61766: PUSH
61767: LD_VAR 0 6
61771: ARRAY
61772: PUSH
61773: LD_VAR 0 2
61777: DIFF
61778: ST_TO_ADDR
// tmp := tmp diff new ;
61779: LD_ADDR_VAR 0 7
61783: PUSH
61784: LD_VAR 0 7
61788: PUSH
61789: LD_VAR 0 1
61793: DIFF
61794: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61795: LD_ADDR_EXP 134
61799: PUSH
61800: LD_EXP 134
61804: PPUSH
61805: LD_VAR 0 6
61809: PPUSH
61810: LD_VAR 0 7
61814: PPUSH
61815: CALL_OW 1
61819: ST_TO_ADDR
// break ;
61820: GO 61824
// end ;
61822: GO 61718
61824: POP
61825: POP
// end ;
61826: LD_VAR 0 5
61830: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61831: LD_INT 0
61833: PPUSH
61834: PPUSH
61835: PPUSH
61836: PPUSH
// if not mc_bases or not skirmish then
61837: LD_EXP 115
61841: NOT
61842: PUSH
61843: LD_EXP 113
61847: NOT
61848: OR
61849: IFFALSE 61853
// exit ;
61851: GO 62245
// side := GetSide ( vehicle ) ;
61853: LD_ADDR_VAR 0 5
61857: PUSH
61858: LD_VAR 0 1
61862: PPUSH
61863: CALL_OW 255
61867: ST_TO_ADDR
// for i = 1 to mc_bases do
61868: LD_ADDR_VAR 0 4
61872: PUSH
61873: DOUBLE
61874: LD_INT 1
61876: DEC
61877: ST_TO_ADDR
61878: LD_EXP 115
61882: PUSH
61883: FOR_TO
61884: IFFALSE 62243
// begin if factory in mc_bases [ i ] then
61886: LD_VAR 0 2
61890: PUSH
61891: LD_EXP 115
61895: PUSH
61896: LD_VAR 0 4
61900: ARRAY
61901: IN
61902: IFFALSE 62241
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61904: LD_EXP 137
61908: PUSH
61909: LD_VAR 0 4
61913: ARRAY
61914: PUSH
61915: LD_EXP 126
61919: PUSH
61920: LD_VAR 0 4
61924: ARRAY
61925: LESS
61926: PUSH
61927: LD_VAR 0 1
61931: PPUSH
61932: CALL_OW 264
61936: PUSH
61937: LD_INT 31
61939: PUSH
61940: LD_INT 32
61942: PUSH
61943: LD_INT 51
61945: PUSH
61946: LD_EXP 96
61950: PUSH
61951: LD_INT 12
61953: PUSH
61954: LD_INT 30
61956: PUSH
61957: LD_EXP 95
61961: PUSH
61962: LD_INT 11
61964: PUSH
61965: LD_INT 53
61967: PUSH
61968: LD_INT 14
61970: PUSH
61971: LD_EXP 99
61975: PUSH
61976: LD_INT 29
61978: PUSH
61979: LD_EXP 97
61983: PUSH
61984: LD_INT 13
61986: PUSH
61987: LD_INT 52
61989: PUSH
61990: LD_EXP 101
61994: PUSH
61995: LD_INT 48
61997: PUSH
61998: LD_INT 8
62000: PUSH
62001: EMPTY
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: LIST
62016: LIST
62017: LIST
62018: LIST
62019: LIST
62020: IN
62021: NOT
62022: AND
62023: IFFALSE 62071
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
62025: LD_ADDR_EXP 137
62029: PUSH
62030: LD_EXP 137
62034: PPUSH
62035: LD_VAR 0 4
62039: PUSH
62040: LD_EXP 137
62044: PUSH
62045: LD_VAR 0 4
62049: ARRAY
62050: PUSH
62051: LD_INT 1
62053: PLUS
62054: PUSH
62055: EMPTY
62056: LIST
62057: LIST
62058: PPUSH
62059: LD_VAR 0 1
62063: PPUSH
62064: CALL 71059 0 3
62068: ST_TO_ADDR
62069: GO 62115
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62071: LD_ADDR_EXP 134
62075: PUSH
62076: LD_EXP 134
62080: PPUSH
62081: LD_VAR 0 4
62085: PUSH
62086: LD_EXP 134
62090: PUSH
62091: LD_VAR 0 4
62095: ARRAY
62096: PUSH
62097: LD_INT 1
62099: PLUS
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: PPUSH
62105: LD_VAR 0 1
62109: PPUSH
62110: CALL 71059 0 3
62114: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62115: LD_VAR 0 1
62119: PPUSH
62120: CALL_OW 263
62124: PUSH
62125: LD_INT 2
62127: EQUAL
62128: IFFALSE 62157
// begin repeat wait ( 0 0$3 ) ;
62130: LD_INT 105
62132: PPUSH
62133: CALL_OW 67
// Connect ( vehicle ) ;
62137: LD_VAR 0 1
62141: PPUSH
62142: CALL 74030 0 1
// until IsControledBy ( vehicle ) ;
62146: LD_VAR 0 1
62150: PPUSH
62151: CALL_OW 312
62155: IFFALSE 62130
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62157: LD_VAR 0 1
62161: PPUSH
62162: LD_EXP 139
62166: PUSH
62167: LD_VAR 0 4
62171: ARRAY
62172: PPUSH
62173: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62177: LD_VAR 0 1
62181: PPUSH
62182: CALL_OW 263
62186: PUSH
62187: LD_INT 1
62189: NONEQUAL
62190: IFFALSE 62194
// break ;
62192: GO 62243
// repeat wait ( 0 0$1 ) ;
62194: LD_INT 35
62196: PPUSH
62197: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62201: LD_VAR 0 1
62205: PPUSH
62206: LD_EXP 139
62210: PUSH
62211: LD_VAR 0 4
62215: ARRAY
62216: PPUSH
62217: CALL_OW 308
62221: IFFALSE 62194
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62223: LD_VAR 0 1
62227: PPUSH
62228: CALL_OW 311
62232: PPUSH
62233: CALL_OW 121
// exit ;
62237: POP
62238: POP
62239: GO 62245
// end ; end ;
62241: GO 61883
62243: POP
62244: POP
// end ;
62245: LD_VAR 0 3
62249: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62250: LD_INT 0
62252: PPUSH
62253: PPUSH
62254: PPUSH
62255: PPUSH
// if not mc_bases or not skirmish then
62256: LD_EXP 115
62260: NOT
62261: PUSH
62262: LD_EXP 113
62266: NOT
62267: OR
62268: IFFALSE 62272
// exit ;
62270: GO 62625
// repeat wait ( 0 0$1 ) ;
62272: LD_INT 35
62274: PPUSH
62275: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62279: LD_VAR 0 2
62283: PPUSH
62284: LD_VAR 0 3
62288: PPUSH
62289: CALL_OW 284
62293: IFFALSE 62272
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62295: LD_VAR 0 2
62299: PPUSH
62300: LD_VAR 0 3
62304: PPUSH
62305: CALL_OW 283
62309: PUSH
62310: LD_INT 4
62312: EQUAL
62313: IFFALSE 62317
// exit ;
62315: GO 62625
// for i = 1 to mc_bases do
62317: LD_ADDR_VAR 0 7
62321: PUSH
62322: DOUBLE
62323: LD_INT 1
62325: DEC
62326: ST_TO_ADDR
62327: LD_EXP 115
62331: PUSH
62332: FOR_TO
62333: IFFALSE 62623
// begin if mc_crates_area [ i ] then
62335: LD_EXP 133
62339: PUSH
62340: LD_VAR 0 7
62344: ARRAY
62345: IFFALSE 62456
// for j in mc_crates_area [ i ] do
62347: LD_ADDR_VAR 0 8
62351: PUSH
62352: LD_EXP 133
62356: PUSH
62357: LD_VAR 0 7
62361: ARRAY
62362: PUSH
62363: FOR_IN
62364: IFFALSE 62454
// if InArea ( x , y , j ) then
62366: LD_VAR 0 2
62370: PPUSH
62371: LD_VAR 0 3
62375: PPUSH
62376: LD_VAR 0 8
62380: PPUSH
62381: CALL_OW 309
62385: IFFALSE 62452
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62387: LD_ADDR_EXP 131
62391: PUSH
62392: LD_EXP 131
62396: PPUSH
62397: LD_VAR 0 7
62401: PUSH
62402: LD_EXP 131
62406: PUSH
62407: LD_VAR 0 7
62411: ARRAY
62412: PUSH
62413: LD_INT 1
62415: PLUS
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PPUSH
62421: LD_VAR 0 4
62425: PUSH
62426: LD_VAR 0 2
62430: PUSH
62431: LD_VAR 0 3
62435: PUSH
62436: EMPTY
62437: LIST
62438: LIST
62439: LIST
62440: PPUSH
62441: CALL 71059 0 3
62445: ST_TO_ADDR
// exit ;
62446: POP
62447: POP
62448: POP
62449: POP
62450: GO 62625
// end ;
62452: GO 62363
62454: POP
62455: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62456: LD_ADDR_VAR 0 9
62460: PUSH
62461: LD_EXP 115
62465: PUSH
62466: LD_VAR 0 7
62470: ARRAY
62471: PPUSH
62472: LD_INT 2
62474: PUSH
62475: LD_INT 30
62477: PUSH
62478: LD_INT 0
62480: PUSH
62481: EMPTY
62482: LIST
62483: LIST
62484: PUSH
62485: LD_INT 30
62487: PUSH
62488: LD_INT 1
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: LIST
62499: PPUSH
62500: CALL_OW 72
62504: ST_TO_ADDR
// if not depot then
62505: LD_VAR 0 9
62509: NOT
62510: IFFALSE 62514
// continue ;
62512: GO 62332
// for j in depot do
62514: LD_ADDR_VAR 0 8
62518: PUSH
62519: LD_VAR 0 9
62523: PUSH
62524: FOR_IN
62525: IFFALSE 62619
// if GetDistUnitXY ( j , x , y ) < 30 then
62527: LD_VAR 0 8
62531: PPUSH
62532: LD_VAR 0 2
62536: PPUSH
62537: LD_VAR 0 3
62541: PPUSH
62542: CALL_OW 297
62546: PUSH
62547: LD_INT 30
62549: LESS
62550: IFFALSE 62617
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62552: LD_ADDR_EXP 131
62556: PUSH
62557: LD_EXP 131
62561: PPUSH
62562: LD_VAR 0 7
62566: PUSH
62567: LD_EXP 131
62571: PUSH
62572: LD_VAR 0 7
62576: ARRAY
62577: PUSH
62578: LD_INT 1
62580: PLUS
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PPUSH
62586: LD_VAR 0 4
62590: PUSH
62591: LD_VAR 0 2
62595: PUSH
62596: LD_VAR 0 3
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: LIST
62605: PPUSH
62606: CALL 71059 0 3
62610: ST_TO_ADDR
// exit ;
62611: POP
62612: POP
62613: POP
62614: POP
62615: GO 62625
// end ;
62617: GO 62524
62619: POP
62620: POP
// end ;
62621: GO 62332
62623: POP
62624: POP
// end ;
62625: LD_VAR 0 6
62629: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62630: LD_INT 0
62632: PPUSH
62633: PPUSH
62634: PPUSH
62635: PPUSH
// if not mc_bases or not skirmish then
62636: LD_EXP 115
62640: NOT
62641: PUSH
62642: LD_EXP 113
62646: NOT
62647: OR
62648: IFFALSE 62652
// exit ;
62650: GO 62929
// side := GetSide ( lab ) ;
62652: LD_ADDR_VAR 0 4
62656: PUSH
62657: LD_VAR 0 2
62661: PPUSH
62662: CALL_OW 255
62666: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62667: LD_VAR 0 4
62671: PUSH
62672: LD_EXP 141
62676: IN
62677: NOT
62678: PUSH
62679: LD_EXP 142
62683: NOT
62684: OR
62685: PUSH
62686: LD_EXP 115
62690: NOT
62691: OR
62692: IFFALSE 62696
// exit ;
62694: GO 62929
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62696: LD_ADDR_EXP 142
62700: PUSH
62701: LD_EXP 142
62705: PPUSH
62706: LD_VAR 0 4
62710: PPUSH
62711: LD_EXP 142
62715: PUSH
62716: LD_VAR 0 4
62720: ARRAY
62721: PUSH
62722: LD_VAR 0 1
62726: DIFF
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// for i = 1 to mc_bases do
62733: LD_ADDR_VAR 0 5
62737: PUSH
62738: DOUBLE
62739: LD_INT 1
62741: DEC
62742: ST_TO_ADDR
62743: LD_EXP 115
62747: PUSH
62748: FOR_TO
62749: IFFALSE 62927
// begin if lab in mc_bases [ i ] then
62751: LD_VAR 0 2
62755: PUSH
62756: LD_EXP 115
62760: PUSH
62761: LD_VAR 0 5
62765: ARRAY
62766: IN
62767: IFFALSE 62925
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62769: LD_VAR 0 1
62773: PUSH
62774: LD_INT 11
62776: PUSH
62777: LD_INT 4
62779: PUSH
62780: LD_INT 3
62782: PUSH
62783: LD_INT 2
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: IN
62792: PUSH
62793: LD_EXP 145
62797: PUSH
62798: LD_VAR 0 5
62802: ARRAY
62803: AND
62804: IFFALSE 62925
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62806: LD_ADDR_VAR 0 6
62810: PUSH
62811: LD_EXP 145
62815: PUSH
62816: LD_VAR 0 5
62820: ARRAY
62821: PUSH
62822: LD_INT 1
62824: ARRAY
62825: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62826: LD_ADDR_EXP 145
62830: PUSH
62831: LD_EXP 145
62835: PPUSH
62836: LD_VAR 0 5
62840: PPUSH
62841: EMPTY
62842: PPUSH
62843: CALL_OW 1
62847: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62848: LD_VAR 0 6
62852: PPUSH
62853: LD_INT 0
62855: PPUSH
62856: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62860: LD_VAR 0 6
62864: PPUSH
62865: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62869: LD_ADDR_EXP 144
62873: PUSH
62874: LD_EXP 144
62878: PPUSH
62879: LD_VAR 0 5
62883: PPUSH
62884: LD_EXP 144
62888: PUSH
62889: LD_VAR 0 5
62893: ARRAY
62894: PPUSH
62895: LD_INT 1
62897: PPUSH
62898: LD_VAR 0 6
62902: PPUSH
62903: CALL_OW 2
62907: PPUSH
62908: CALL_OW 1
62912: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62913: LD_VAR 0 5
62917: PPUSH
62918: LD_INT 112
62920: PPUSH
62921: CALL 39448 0 2
// end ; end ; end ;
62925: GO 62748
62927: POP
62928: POP
// end ;
62929: LD_VAR 0 3
62933: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62934: LD_INT 0
62936: PPUSH
62937: PPUSH
62938: PPUSH
62939: PPUSH
62940: PPUSH
62941: PPUSH
62942: PPUSH
62943: PPUSH
// if not mc_bases or not skirmish then
62944: LD_EXP 115
62948: NOT
62949: PUSH
62950: LD_EXP 113
62954: NOT
62955: OR
62956: IFFALSE 62960
// exit ;
62958: GO 64331
// for i = 1 to mc_bases do
62960: LD_ADDR_VAR 0 3
62964: PUSH
62965: DOUBLE
62966: LD_INT 1
62968: DEC
62969: ST_TO_ADDR
62970: LD_EXP 115
62974: PUSH
62975: FOR_TO
62976: IFFALSE 64329
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62978: LD_VAR 0 1
62982: PUSH
62983: LD_EXP 115
62987: PUSH
62988: LD_VAR 0 3
62992: ARRAY
62993: IN
62994: PUSH
62995: LD_VAR 0 1
62999: PUSH
63000: LD_EXP 122
63004: PUSH
63005: LD_VAR 0 3
63009: ARRAY
63010: IN
63011: OR
63012: PUSH
63013: LD_VAR 0 1
63017: PUSH
63018: LD_EXP 137
63022: PUSH
63023: LD_VAR 0 3
63027: ARRAY
63028: IN
63029: OR
63030: PUSH
63031: LD_VAR 0 1
63035: PUSH
63036: LD_EXP 134
63040: PUSH
63041: LD_VAR 0 3
63045: ARRAY
63046: IN
63047: OR
63048: PUSH
63049: LD_VAR 0 1
63053: PUSH
63054: LD_EXP 144
63058: PUSH
63059: LD_VAR 0 3
63063: ARRAY
63064: IN
63065: OR
63066: PUSH
63067: LD_VAR 0 1
63071: PUSH
63072: LD_EXP 145
63076: PUSH
63077: LD_VAR 0 3
63081: ARRAY
63082: IN
63083: OR
63084: IFFALSE 64327
// begin if un in mc_ape [ i ] then
63086: LD_VAR 0 1
63090: PUSH
63091: LD_EXP 144
63095: PUSH
63096: LD_VAR 0 3
63100: ARRAY
63101: IN
63102: IFFALSE 63141
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63104: LD_ADDR_EXP 144
63108: PUSH
63109: LD_EXP 144
63113: PPUSH
63114: LD_VAR 0 3
63118: PPUSH
63119: LD_EXP 144
63123: PUSH
63124: LD_VAR 0 3
63128: ARRAY
63129: PUSH
63130: LD_VAR 0 1
63134: DIFF
63135: PPUSH
63136: CALL_OW 1
63140: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63141: LD_VAR 0 1
63145: PUSH
63146: LD_EXP 145
63150: PUSH
63151: LD_VAR 0 3
63155: ARRAY
63156: IN
63157: IFFALSE 63181
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63159: LD_ADDR_EXP 145
63163: PUSH
63164: LD_EXP 145
63168: PPUSH
63169: LD_VAR 0 3
63173: PPUSH
63174: EMPTY
63175: PPUSH
63176: CALL_OW 1
63180: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63181: LD_VAR 0 1
63185: PPUSH
63186: CALL_OW 247
63190: PUSH
63191: LD_INT 2
63193: EQUAL
63194: PUSH
63195: LD_VAR 0 1
63199: PPUSH
63200: CALL_OW 110
63204: PUSH
63205: LD_INT 20
63207: EQUAL
63208: PUSH
63209: LD_VAR 0 1
63213: PUSH
63214: LD_EXP 137
63218: PUSH
63219: LD_VAR 0 3
63223: ARRAY
63224: IN
63225: OR
63226: PUSH
63227: LD_VAR 0 1
63231: PPUSH
63232: CALL_OW 264
63236: PUSH
63237: LD_INT 12
63239: PUSH
63240: LD_INT 51
63242: PUSH
63243: LD_EXP 96
63247: PUSH
63248: LD_INT 32
63250: PUSH
63251: LD_INT 13
63253: PUSH
63254: LD_INT 52
63256: PUSH
63257: LD_INT 31
63259: PUSH
63260: EMPTY
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: IN
63269: OR
63270: AND
63271: IFFALSE 63579
// begin if un in mc_defender [ i ] then
63273: LD_VAR 0 1
63277: PUSH
63278: LD_EXP 137
63282: PUSH
63283: LD_VAR 0 3
63287: ARRAY
63288: IN
63289: IFFALSE 63328
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63291: LD_ADDR_EXP 137
63295: PUSH
63296: LD_EXP 137
63300: PPUSH
63301: LD_VAR 0 3
63305: PPUSH
63306: LD_EXP 137
63310: PUSH
63311: LD_VAR 0 3
63315: ARRAY
63316: PUSH
63317: LD_VAR 0 1
63321: DIFF
63322: PPUSH
63323: CALL_OW 1
63327: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63328: LD_ADDR_VAR 0 8
63332: PUSH
63333: LD_VAR 0 3
63337: PPUSH
63338: LD_INT 3
63340: PPUSH
63341: CALL 59969 0 2
63345: ST_TO_ADDR
// if fac then
63346: LD_VAR 0 8
63350: IFFALSE 63579
// begin for j in fac do
63352: LD_ADDR_VAR 0 4
63356: PUSH
63357: LD_VAR 0 8
63361: PUSH
63362: FOR_IN
63363: IFFALSE 63577
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63365: LD_ADDR_VAR 0 9
63369: PUSH
63370: LD_VAR 0 8
63374: PPUSH
63375: LD_VAR 0 1
63379: PPUSH
63380: CALL_OW 265
63384: PPUSH
63385: LD_VAR 0 1
63389: PPUSH
63390: CALL_OW 262
63394: PPUSH
63395: LD_VAR 0 1
63399: PPUSH
63400: CALL_OW 263
63404: PPUSH
63405: LD_VAR 0 1
63409: PPUSH
63410: CALL_OW 264
63414: PPUSH
63415: CALL 68555 0 5
63419: ST_TO_ADDR
// if components then
63420: LD_VAR 0 9
63424: IFFALSE 63575
// begin if GetWeapon ( un ) = ar_control_tower then
63426: LD_VAR 0 1
63430: PPUSH
63431: CALL_OW 264
63435: PUSH
63436: LD_INT 31
63438: EQUAL
63439: IFFALSE 63556
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63441: LD_VAR 0 1
63445: PPUSH
63446: CALL_OW 311
63450: PPUSH
63451: LD_INT 0
63453: PPUSH
63454: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63458: LD_ADDR_EXP 155
63462: PUSH
63463: LD_EXP 155
63467: PPUSH
63468: LD_VAR 0 3
63472: PPUSH
63473: LD_EXP 155
63477: PUSH
63478: LD_VAR 0 3
63482: ARRAY
63483: PUSH
63484: LD_VAR 0 1
63488: PPUSH
63489: CALL_OW 311
63493: DIFF
63494: PPUSH
63495: CALL_OW 1
63499: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63500: LD_ADDR_VAR 0 7
63504: PUSH
63505: LD_EXP 136
63509: PUSH
63510: LD_VAR 0 3
63514: ARRAY
63515: PPUSH
63516: LD_INT 1
63518: PPUSH
63519: LD_VAR 0 9
63523: PPUSH
63524: CALL_OW 2
63528: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63529: LD_ADDR_EXP 136
63533: PUSH
63534: LD_EXP 136
63538: PPUSH
63539: LD_VAR 0 3
63543: PPUSH
63544: LD_VAR 0 7
63548: PPUSH
63549: CALL_OW 1
63553: ST_TO_ADDR
// end else
63554: GO 63573
// MC_InsertProduceList ( i , [ components ] ) ;
63556: LD_VAR 0 3
63560: PPUSH
63561: LD_VAR 0 9
63565: PUSH
63566: EMPTY
63567: LIST
63568: PPUSH
63569: CALL 59514 0 2
// break ;
63573: GO 63577
// end ; end ;
63575: GO 63362
63577: POP
63578: POP
// end ; end ; if GetType ( un ) = unit_building then
63579: LD_VAR 0 1
63583: PPUSH
63584: CALL_OW 247
63588: PUSH
63589: LD_INT 3
63591: EQUAL
63592: IFFALSE 63995
// begin btype := GetBType ( un ) ;
63594: LD_ADDR_VAR 0 5
63598: PUSH
63599: LD_VAR 0 1
63603: PPUSH
63604: CALL_OW 266
63608: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63609: LD_VAR 0 5
63613: PUSH
63614: LD_INT 29
63616: PUSH
63617: LD_INT 30
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: IN
63624: IFFALSE 63697
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63626: LD_VAR 0 1
63630: PPUSH
63631: CALL_OW 250
63635: PPUSH
63636: LD_VAR 0 1
63640: PPUSH
63641: CALL_OW 251
63645: PPUSH
63646: LD_VAR 0 1
63650: PPUSH
63651: CALL_OW 255
63655: PPUSH
63656: CALL_OW 440
63660: NOT
63661: IFFALSE 63697
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63663: LD_VAR 0 1
63667: PPUSH
63668: CALL_OW 250
63672: PPUSH
63673: LD_VAR 0 1
63677: PPUSH
63678: CALL_OW 251
63682: PPUSH
63683: LD_VAR 0 1
63687: PPUSH
63688: CALL_OW 255
63692: PPUSH
63693: CALL_OW 441
// end ; if btype = b_warehouse then
63697: LD_VAR 0 5
63701: PUSH
63702: LD_INT 1
63704: EQUAL
63705: IFFALSE 63723
// begin btype := b_depot ;
63707: LD_ADDR_VAR 0 5
63711: PUSH
63712: LD_INT 0
63714: ST_TO_ADDR
// pos := 1 ;
63715: LD_ADDR_VAR 0 6
63719: PUSH
63720: LD_INT 1
63722: ST_TO_ADDR
// end ; if btype = b_factory then
63723: LD_VAR 0 5
63727: PUSH
63728: LD_INT 3
63730: EQUAL
63731: IFFALSE 63749
// begin btype := b_workshop ;
63733: LD_ADDR_VAR 0 5
63737: PUSH
63738: LD_INT 2
63740: ST_TO_ADDR
// pos := 1 ;
63741: LD_ADDR_VAR 0 6
63745: PUSH
63746: LD_INT 1
63748: ST_TO_ADDR
// end ; if btype = b_barracks then
63749: LD_VAR 0 5
63753: PUSH
63754: LD_INT 5
63756: EQUAL
63757: IFFALSE 63767
// btype := b_armoury ;
63759: LD_ADDR_VAR 0 5
63763: PUSH
63764: LD_INT 4
63766: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63767: LD_VAR 0 5
63771: PUSH
63772: LD_INT 7
63774: PUSH
63775: LD_INT 8
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: IN
63782: IFFALSE 63792
// btype := b_lab ;
63784: LD_ADDR_VAR 0 5
63788: PUSH
63789: LD_INT 6
63791: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63792: LD_ADDR_EXP 120
63796: PUSH
63797: LD_EXP 120
63801: PPUSH
63802: LD_VAR 0 3
63806: PUSH
63807: LD_EXP 120
63811: PUSH
63812: LD_VAR 0 3
63816: ARRAY
63817: PUSH
63818: LD_INT 1
63820: PLUS
63821: PUSH
63822: EMPTY
63823: LIST
63824: LIST
63825: PPUSH
63826: LD_VAR 0 5
63830: PUSH
63831: LD_VAR 0 1
63835: PPUSH
63836: CALL_OW 250
63840: PUSH
63841: LD_VAR 0 1
63845: PPUSH
63846: CALL_OW 251
63850: PUSH
63851: LD_VAR 0 1
63855: PPUSH
63856: CALL_OW 254
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: PPUSH
63867: CALL 71059 0 3
63871: ST_TO_ADDR
// if pos = 1 then
63872: LD_VAR 0 6
63876: PUSH
63877: LD_INT 1
63879: EQUAL
63880: IFFALSE 63995
// begin tmp := mc_build_list [ i ] ;
63882: LD_ADDR_VAR 0 7
63886: PUSH
63887: LD_EXP 120
63891: PUSH
63892: LD_VAR 0 3
63896: ARRAY
63897: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63898: LD_VAR 0 7
63902: PPUSH
63903: LD_INT 2
63905: PUSH
63906: LD_INT 30
63908: PUSH
63909: LD_INT 0
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 30
63918: PUSH
63919: LD_INT 1
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: LIST
63930: PPUSH
63931: CALL_OW 72
63935: IFFALSE 63945
// pos := 2 ;
63937: LD_ADDR_VAR 0 6
63941: PUSH
63942: LD_INT 2
63944: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63945: LD_ADDR_VAR 0 7
63949: PUSH
63950: LD_VAR 0 7
63954: PPUSH
63955: LD_VAR 0 6
63959: PPUSH
63960: LD_VAR 0 7
63964: PPUSH
63965: CALL 71385 0 3
63969: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63970: LD_ADDR_EXP 120
63974: PUSH
63975: LD_EXP 120
63979: PPUSH
63980: LD_VAR 0 3
63984: PPUSH
63985: LD_VAR 0 7
63989: PPUSH
63990: CALL_OW 1
63994: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63995: LD_VAR 0 1
63999: PUSH
64000: LD_EXP 115
64004: PUSH
64005: LD_VAR 0 3
64009: ARRAY
64010: IN
64011: IFFALSE 64050
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
64013: LD_ADDR_EXP 115
64017: PUSH
64018: LD_EXP 115
64022: PPUSH
64023: LD_VAR 0 3
64027: PPUSH
64028: LD_EXP 115
64032: PUSH
64033: LD_VAR 0 3
64037: ARRAY
64038: PUSH
64039: LD_VAR 0 1
64043: DIFF
64044: PPUSH
64045: CALL_OW 1
64049: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64050: LD_VAR 0 1
64054: PUSH
64055: LD_EXP 122
64059: PUSH
64060: LD_VAR 0 3
64064: ARRAY
64065: IN
64066: IFFALSE 64105
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64068: LD_ADDR_EXP 122
64072: PUSH
64073: LD_EXP 122
64077: PPUSH
64078: LD_VAR 0 3
64082: PPUSH
64083: LD_EXP 122
64087: PUSH
64088: LD_VAR 0 3
64092: ARRAY
64093: PUSH
64094: LD_VAR 0 1
64098: DIFF
64099: PPUSH
64100: CALL_OW 1
64104: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64105: LD_VAR 0 1
64109: PUSH
64110: LD_EXP 134
64114: PUSH
64115: LD_VAR 0 3
64119: ARRAY
64120: IN
64121: IFFALSE 64160
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64123: LD_ADDR_EXP 134
64127: PUSH
64128: LD_EXP 134
64132: PPUSH
64133: LD_VAR 0 3
64137: PPUSH
64138: LD_EXP 134
64142: PUSH
64143: LD_VAR 0 3
64147: ARRAY
64148: PUSH
64149: LD_VAR 0 1
64153: DIFF
64154: PPUSH
64155: CALL_OW 1
64159: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64160: LD_VAR 0 1
64164: PUSH
64165: LD_EXP 137
64169: PUSH
64170: LD_VAR 0 3
64174: ARRAY
64175: IN
64176: IFFALSE 64215
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64178: LD_ADDR_EXP 137
64182: PUSH
64183: LD_EXP 137
64187: PPUSH
64188: LD_VAR 0 3
64192: PPUSH
64193: LD_EXP 137
64197: PUSH
64198: LD_VAR 0 3
64202: ARRAY
64203: PUSH
64204: LD_VAR 0 1
64208: DIFF
64209: PPUSH
64210: CALL_OW 1
64214: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64215: LD_VAR 0 1
64219: PUSH
64220: LD_EXP 124
64224: PUSH
64225: LD_VAR 0 3
64229: ARRAY
64230: IN
64231: IFFALSE 64270
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64233: LD_ADDR_EXP 124
64237: PUSH
64238: LD_EXP 124
64242: PPUSH
64243: LD_VAR 0 3
64247: PPUSH
64248: LD_EXP 124
64252: PUSH
64253: LD_VAR 0 3
64257: ARRAY
64258: PUSH
64259: LD_VAR 0 1
64263: DIFF
64264: PPUSH
64265: CALL_OW 1
64269: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64270: LD_VAR 0 1
64274: PUSH
64275: LD_EXP 123
64279: PUSH
64280: LD_VAR 0 3
64284: ARRAY
64285: IN
64286: IFFALSE 64325
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64288: LD_ADDR_EXP 123
64292: PUSH
64293: LD_EXP 123
64297: PPUSH
64298: LD_VAR 0 3
64302: PPUSH
64303: LD_EXP 123
64307: PUSH
64308: LD_VAR 0 3
64312: ARRAY
64313: PUSH
64314: LD_VAR 0 1
64318: DIFF
64319: PPUSH
64320: CALL_OW 1
64324: ST_TO_ADDR
// end ; break ;
64325: GO 64329
// end ;
64327: GO 62975
64329: POP
64330: POP
// end ;
64331: LD_VAR 0 2
64335: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64336: LD_INT 0
64338: PPUSH
64339: PPUSH
64340: PPUSH
// if not mc_bases or not skirmish then
64341: LD_EXP 115
64345: NOT
64346: PUSH
64347: LD_EXP 113
64351: NOT
64352: OR
64353: IFFALSE 64357
// exit ;
64355: GO 64572
// for i = 1 to mc_bases do
64357: LD_ADDR_VAR 0 3
64361: PUSH
64362: DOUBLE
64363: LD_INT 1
64365: DEC
64366: ST_TO_ADDR
64367: LD_EXP 115
64371: PUSH
64372: FOR_TO
64373: IFFALSE 64570
// begin if building in mc_construct_list [ i ] then
64375: LD_VAR 0 1
64379: PUSH
64380: LD_EXP 122
64384: PUSH
64385: LD_VAR 0 3
64389: ARRAY
64390: IN
64391: IFFALSE 64568
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64393: LD_ADDR_EXP 122
64397: PUSH
64398: LD_EXP 122
64402: PPUSH
64403: LD_VAR 0 3
64407: PPUSH
64408: LD_EXP 122
64412: PUSH
64413: LD_VAR 0 3
64417: ARRAY
64418: PUSH
64419: LD_VAR 0 1
64423: DIFF
64424: PPUSH
64425: CALL_OW 1
64429: ST_TO_ADDR
// if building in mc_lab [ i ] then
64430: LD_VAR 0 1
64434: PUSH
64435: LD_EXP 148
64439: PUSH
64440: LD_VAR 0 3
64444: ARRAY
64445: IN
64446: IFFALSE 64501
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64448: LD_ADDR_EXP 149
64452: PUSH
64453: LD_EXP 149
64457: PPUSH
64458: LD_VAR 0 3
64462: PPUSH
64463: LD_EXP 149
64467: PUSH
64468: LD_VAR 0 3
64472: ARRAY
64473: PPUSH
64474: LD_INT 1
64476: PPUSH
64477: LD_EXP 149
64481: PUSH
64482: LD_VAR 0 3
64486: ARRAY
64487: PPUSH
64488: LD_INT 0
64490: PPUSH
64491: CALL 70477 0 4
64495: PPUSH
64496: CALL_OW 1
64500: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64501: LD_VAR 0 1
64505: PUSH
64506: LD_EXP 115
64510: PUSH
64511: LD_VAR 0 3
64515: ARRAY
64516: IN
64517: NOT
64518: IFFALSE 64564
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64520: LD_ADDR_EXP 115
64524: PUSH
64525: LD_EXP 115
64529: PPUSH
64530: LD_VAR 0 3
64534: PUSH
64535: LD_EXP 115
64539: PUSH
64540: LD_VAR 0 3
64544: ARRAY
64545: PUSH
64546: LD_INT 1
64548: PLUS
64549: PUSH
64550: EMPTY
64551: LIST
64552: LIST
64553: PPUSH
64554: LD_VAR 0 1
64558: PPUSH
64559: CALL 71059 0 3
64563: ST_TO_ADDR
// exit ;
64564: POP
64565: POP
64566: GO 64572
// end ; end ;
64568: GO 64372
64570: POP
64571: POP
// end ;
64572: LD_VAR 0 2
64576: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64577: LD_INT 0
64579: PPUSH
64580: PPUSH
64581: PPUSH
64582: PPUSH
64583: PPUSH
64584: PPUSH
64585: PPUSH
// if not mc_bases or not skirmish then
64586: LD_EXP 115
64590: NOT
64591: PUSH
64592: LD_EXP 113
64596: NOT
64597: OR
64598: IFFALSE 64602
// exit ;
64600: GO 65263
// for i = 1 to mc_bases do
64602: LD_ADDR_VAR 0 3
64606: PUSH
64607: DOUBLE
64608: LD_INT 1
64610: DEC
64611: ST_TO_ADDR
64612: LD_EXP 115
64616: PUSH
64617: FOR_TO
64618: IFFALSE 65261
// begin if building in mc_construct_list [ i ] then
64620: LD_VAR 0 1
64624: PUSH
64625: LD_EXP 122
64629: PUSH
64630: LD_VAR 0 3
64634: ARRAY
64635: IN
64636: IFFALSE 65259
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64638: LD_ADDR_EXP 122
64642: PUSH
64643: LD_EXP 122
64647: PPUSH
64648: LD_VAR 0 3
64652: PPUSH
64653: LD_EXP 122
64657: PUSH
64658: LD_VAR 0 3
64662: ARRAY
64663: PUSH
64664: LD_VAR 0 1
64668: DIFF
64669: PPUSH
64670: CALL_OW 1
64674: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64675: LD_ADDR_EXP 115
64679: PUSH
64680: LD_EXP 115
64684: PPUSH
64685: LD_VAR 0 3
64689: PUSH
64690: LD_EXP 115
64694: PUSH
64695: LD_VAR 0 3
64699: ARRAY
64700: PUSH
64701: LD_INT 1
64703: PLUS
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PPUSH
64709: LD_VAR 0 1
64713: PPUSH
64714: CALL 71059 0 3
64718: ST_TO_ADDR
// btype := GetBType ( building ) ;
64719: LD_ADDR_VAR 0 5
64723: PUSH
64724: LD_VAR 0 1
64728: PPUSH
64729: CALL_OW 266
64733: ST_TO_ADDR
// side := GetSide ( building ) ;
64734: LD_ADDR_VAR 0 8
64738: PUSH
64739: LD_VAR 0 1
64743: PPUSH
64744: CALL_OW 255
64748: ST_TO_ADDR
// if btype = b_lab then
64749: LD_VAR 0 5
64753: PUSH
64754: LD_INT 6
64756: EQUAL
64757: IFFALSE 64807
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64759: LD_ADDR_EXP 148
64763: PUSH
64764: LD_EXP 148
64768: PPUSH
64769: LD_VAR 0 3
64773: PUSH
64774: LD_EXP 148
64778: PUSH
64779: LD_VAR 0 3
64783: ARRAY
64784: PUSH
64785: LD_INT 1
64787: PLUS
64788: PUSH
64789: EMPTY
64790: LIST
64791: LIST
64792: PPUSH
64793: LD_VAR 0 1
64797: PPUSH
64798: CALL 71059 0 3
64802: ST_TO_ADDR
// exit ;
64803: POP
64804: POP
64805: GO 65263
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64807: LD_VAR 0 5
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: LD_INT 2
64817: PUSH
64818: LD_INT 4
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: LIST
64825: IN
64826: IFFALSE 64950
// begin if btype = b_armoury then
64828: LD_VAR 0 5
64832: PUSH
64833: LD_INT 4
64835: EQUAL
64836: IFFALSE 64846
// btype := b_barracks ;
64838: LD_ADDR_VAR 0 5
64842: PUSH
64843: LD_INT 5
64845: ST_TO_ADDR
// if btype = b_depot then
64846: LD_VAR 0 5
64850: PUSH
64851: LD_INT 0
64853: EQUAL
64854: IFFALSE 64864
// btype := b_warehouse ;
64856: LD_ADDR_VAR 0 5
64860: PUSH
64861: LD_INT 1
64863: ST_TO_ADDR
// if btype = b_workshop then
64864: LD_VAR 0 5
64868: PUSH
64869: LD_INT 2
64871: EQUAL
64872: IFFALSE 64882
// btype := b_factory ;
64874: LD_ADDR_VAR 0 5
64878: PUSH
64879: LD_INT 3
64881: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64882: LD_VAR 0 5
64886: PPUSH
64887: LD_VAR 0 8
64891: PPUSH
64892: CALL_OW 323
64896: PUSH
64897: LD_INT 1
64899: EQUAL
64900: IFFALSE 64946
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64902: LD_ADDR_EXP 147
64906: PUSH
64907: LD_EXP 147
64911: PPUSH
64912: LD_VAR 0 3
64916: PUSH
64917: LD_EXP 147
64921: PUSH
64922: LD_VAR 0 3
64926: ARRAY
64927: PUSH
64928: LD_INT 1
64930: PLUS
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PPUSH
64936: LD_VAR 0 1
64940: PPUSH
64941: CALL 71059 0 3
64945: ST_TO_ADDR
// exit ;
64946: POP
64947: POP
64948: GO 65263
// end ; if btype in [ b_bunker , b_turret ] then
64950: LD_VAR 0 5
64954: PUSH
64955: LD_INT 32
64957: PUSH
64958: LD_INT 33
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: IN
64965: IFFALSE 65255
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64967: LD_ADDR_EXP 123
64971: PUSH
64972: LD_EXP 123
64976: PPUSH
64977: LD_VAR 0 3
64981: PUSH
64982: LD_EXP 123
64986: PUSH
64987: LD_VAR 0 3
64991: ARRAY
64992: PUSH
64993: LD_INT 1
64995: PLUS
64996: PUSH
64997: EMPTY
64998: LIST
64999: LIST
65000: PPUSH
65001: LD_VAR 0 1
65005: PPUSH
65006: CALL 71059 0 3
65010: ST_TO_ADDR
// if btype = b_bunker then
65011: LD_VAR 0 5
65015: PUSH
65016: LD_INT 32
65018: EQUAL
65019: IFFALSE 65255
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65021: LD_ADDR_EXP 124
65025: PUSH
65026: LD_EXP 124
65030: PPUSH
65031: LD_VAR 0 3
65035: PUSH
65036: LD_EXP 124
65040: PUSH
65041: LD_VAR 0 3
65045: ARRAY
65046: PUSH
65047: LD_INT 1
65049: PLUS
65050: PUSH
65051: EMPTY
65052: LIST
65053: LIST
65054: PPUSH
65055: LD_VAR 0 1
65059: PPUSH
65060: CALL 71059 0 3
65064: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65065: LD_ADDR_VAR 0 6
65069: PUSH
65070: LD_EXP 115
65074: PUSH
65075: LD_VAR 0 3
65079: ARRAY
65080: PPUSH
65081: LD_INT 25
65083: PUSH
65084: LD_INT 1
65086: PUSH
65087: EMPTY
65088: LIST
65089: LIST
65090: PUSH
65091: LD_INT 3
65093: PUSH
65094: LD_INT 54
65096: PUSH
65097: EMPTY
65098: LIST
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PPUSH
65108: CALL_OW 72
65112: ST_TO_ADDR
// if tmp then
65113: LD_VAR 0 6
65117: IFFALSE 65123
// exit ;
65119: POP
65120: POP
65121: GO 65263
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65123: LD_ADDR_VAR 0 6
65127: PUSH
65128: LD_EXP 115
65132: PUSH
65133: LD_VAR 0 3
65137: ARRAY
65138: PPUSH
65139: LD_INT 2
65141: PUSH
65142: LD_INT 30
65144: PUSH
65145: LD_INT 4
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 30
65154: PUSH
65155: LD_INT 5
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: LIST
65166: PPUSH
65167: CALL_OW 72
65171: ST_TO_ADDR
// if not tmp then
65172: LD_VAR 0 6
65176: NOT
65177: IFFALSE 65183
// exit ;
65179: POP
65180: POP
65181: GO 65263
// for j in tmp do
65183: LD_ADDR_VAR 0 4
65187: PUSH
65188: LD_VAR 0 6
65192: PUSH
65193: FOR_IN
65194: IFFALSE 65253
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65196: LD_ADDR_VAR 0 7
65200: PUSH
65201: LD_VAR 0 4
65205: PPUSH
65206: CALL_OW 313
65210: PPUSH
65211: LD_INT 25
65213: PUSH
65214: LD_INT 1
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PPUSH
65221: CALL_OW 72
65225: ST_TO_ADDR
// if units then
65226: LD_VAR 0 7
65230: IFFALSE 65251
// begin ComExitBuilding ( units [ 1 ] ) ;
65232: LD_VAR 0 7
65236: PUSH
65237: LD_INT 1
65239: ARRAY
65240: PPUSH
65241: CALL_OW 122
// exit ;
65245: POP
65246: POP
65247: POP
65248: POP
65249: GO 65263
// end ; end ;
65251: GO 65193
65253: POP
65254: POP
// end ; end ; exit ;
65255: POP
65256: POP
65257: GO 65263
// end ; end ;
65259: GO 64617
65261: POP
65262: POP
// end ;
65263: LD_VAR 0 2
65267: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65268: LD_INT 0
65270: PPUSH
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
// if not mc_bases or not skirmish then
65277: LD_EXP 115
65281: NOT
65282: PUSH
65283: LD_EXP 113
65287: NOT
65288: OR
65289: IFFALSE 65293
// exit ;
65291: GO 65558
// btype := GetBType ( building ) ;
65293: LD_ADDR_VAR 0 6
65297: PUSH
65298: LD_VAR 0 1
65302: PPUSH
65303: CALL_OW 266
65307: ST_TO_ADDR
// x := GetX ( building ) ;
65308: LD_ADDR_VAR 0 7
65312: PUSH
65313: LD_VAR 0 1
65317: PPUSH
65318: CALL_OW 250
65322: ST_TO_ADDR
// y := GetY ( building ) ;
65323: LD_ADDR_VAR 0 8
65327: PUSH
65328: LD_VAR 0 1
65332: PPUSH
65333: CALL_OW 251
65337: ST_TO_ADDR
// d := GetDir ( building ) ;
65338: LD_ADDR_VAR 0 9
65342: PUSH
65343: LD_VAR 0 1
65347: PPUSH
65348: CALL_OW 254
65352: ST_TO_ADDR
// for i = 1 to mc_bases do
65353: LD_ADDR_VAR 0 4
65357: PUSH
65358: DOUBLE
65359: LD_INT 1
65361: DEC
65362: ST_TO_ADDR
65363: LD_EXP 115
65367: PUSH
65368: FOR_TO
65369: IFFALSE 65556
// begin if not mc_build_list [ i ] then
65371: LD_EXP 120
65375: PUSH
65376: LD_VAR 0 4
65380: ARRAY
65381: NOT
65382: IFFALSE 65386
// continue ;
65384: GO 65368
// for j := 1 to mc_build_list [ i ] do
65386: LD_ADDR_VAR 0 5
65390: PUSH
65391: DOUBLE
65392: LD_INT 1
65394: DEC
65395: ST_TO_ADDR
65396: LD_EXP 120
65400: PUSH
65401: LD_VAR 0 4
65405: ARRAY
65406: PUSH
65407: FOR_TO
65408: IFFALSE 65552
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65410: LD_VAR 0 6
65414: PUSH
65415: LD_VAR 0 7
65419: PUSH
65420: LD_VAR 0 8
65424: PUSH
65425: LD_VAR 0 9
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: LIST
65434: LIST
65435: PPUSH
65436: LD_EXP 120
65440: PUSH
65441: LD_VAR 0 4
65445: ARRAY
65446: PUSH
65447: LD_VAR 0 5
65451: ARRAY
65452: PPUSH
65453: CALL 77241 0 2
65457: IFFALSE 65550
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65459: LD_ADDR_EXP 120
65463: PUSH
65464: LD_EXP 120
65468: PPUSH
65469: LD_VAR 0 4
65473: PPUSH
65474: LD_EXP 120
65478: PUSH
65479: LD_VAR 0 4
65483: ARRAY
65484: PPUSH
65485: LD_VAR 0 5
65489: PPUSH
65490: CALL_OW 3
65494: PPUSH
65495: CALL_OW 1
65499: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65500: LD_ADDR_EXP 122
65504: PUSH
65505: LD_EXP 122
65509: PPUSH
65510: LD_VAR 0 4
65514: PUSH
65515: LD_EXP 122
65519: PUSH
65520: LD_VAR 0 4
65524: ARRAY
65525: PUSH
65526: LD_INT 1
65528: PLUS
65529: PUSH
65530: EMPTY
65531: LIST
65532: LIST
65533: PPUSH
65534: LD_VAR 0 1
65538: PPUSH
65539: CALL 71059 0 3
65543: ST_TO_ADDR
// exit ;
65544: POP
65545: POP
65546: POP
65547: POP
65548: GO 65558
// end ;
65550: GO 65407
65552: POP
65553: POP
// end ;
65554: GO 65368
65556: POP
65557: POP
// end ;
65558: LD_VAR 0 3
65562: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65563: LD_INT 0
65565: PPUSH
65566: PPUSH
65567: PPUSH
// if not mc_bases or not skirmish then
65568: LD_EXP 115
65572: NOT
65573: PUSH
65574: LD_EXP 113
65578: NOT
65579: OR
65580: IFFALSE 65584
// exit ;
65582: GO 65774
// for i = 1 to mc_bases do
65584: LD_ADDR_VAR 0 4
65588: PUSH
65589: DOUBLE
65590: LD_INT 1
65592: DEC
65593: ST_TO_ADDR
65594: LD_EXP 115
65598: PUSH
65599: FOR_TO
65600: IFFALSE 65687
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65602: LD_VAR 0 1
65606: PUSH
65607: LD_EXP 123
65611: PUSH
65612: LD_VAR 0 4
65616: ARRAY
65617: IN
65618: PUSH
65619: LD_VAR 0 1
65623: PUSH
65624: LD_EXP 124
65628: PUSH
65629: LD_VAR 0 4
65633: ARRAY
65634: IN
65635: NOT
65636: AND
65637: IFFALSE 65685
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65639: LD_ADDR_EXP 124
65643: PUSH
65644: LD_EXP 124
65648: PPUSH
65649: LD_VAR 0 4
65653: PUSH
65654: LD_EXP 124
65658: PUSH
65659: LD_VAR 0 4
65663: ARRAY
65664: PUSH
65665: LD_INT 1
65667: PLUS
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: PPUSH
65673: LD_VAR 0 1
65677: PPUSH
65678: CALL 71059 0 3
65682: ST_TO_ADDR
// break ;
65683: GO 65687
// end ; end ;
65685: GO 65599
65687: POP
65688: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65689: LD_VAR 0 1
65693: PPUSH
65694: CALL_OW 257
65698: PUSH
65699: LD_EXP 141
65703: IN
65704: PUSH
65705: LD_VAR 0 1
65709: PPUSH
65710: CALL_OW 266
65714: PUSH
65715: LD_INT 5
65717: EQUAL
65718: AND
65719: PUSH
65720: LD_VAR 0 2
65724: PPUSH
65725: CALL_OW 110
65729: PUSH
65730: LD_INT 18
65732: NONEQUAL
65733: AND
65734: IFFALSE 65774
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65736: LD_VAR 0 2
65740: PPUSH
65741: CALL_OW 257
65745: PUSH
65746: LD_INT 5
65748: PUSH
65749: LD_INT 8
65751: PUSH
65752: LD_INT 9
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: LIST
65759: IN
65760: IFFALSE 65774
// SetClass ( unit , 1 ) ;
65762: LD_VAR 0 2
65766: PPUSH
65767: LD_INT 1
65769: PPUSH
65770: CALL_OW 336
// end ;
65774: LD_VAR 0 3
65778: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65779: LD_INT 0
65781: PPUSH
65782: PPUSH
// if not mc_bases or not skirmish then
65783: LD_EXP 115
65787: NOT
65788: PUSH
65789: LD_EXP 113
65793: NOT
65794: OR
65795: IFFALSE 65799
// exit ;
65797: GO 65915
// if GetLives ( abandoned_vehicle ) > 250 then
65799: LD_VAR 0 2
65803: PPUSH
65804: CALL_OW 256
65808: PUSH
65809: LD_INT 250
65811: GREATER
65812: IFFALSE 65816
// exit ;
65814: GO 65915
// for i = 1 to mc_bases do
65816: LD_ADDR_VAR 0 6
65820: PUSH
65821: DOUBLE
65822: LD_INT 1
65824: DEC
65825: ST_TO_ADDR
65826: LD_EXP 115
65830: PUSH
65831: FOR_TO
65832: IFFALSE 65913
// begin if driver in mc_bases [ i ] then
65834: LD_VAR 0 1
65838: PUSH
65839: LD_EXP 115
65843: PUSH
65844: LD_VAR 0 6
65848: ARRAY
65849: IN
65850: IFFALSE 65911
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65852: LD_VAR 0 1
65856: PPUSH
65857: LD_EXP 115
65861: PUSH
65862: LD_VAR 0 6
65866: ARRAY
65867: PPUSH
65868: LD_INT 2
65870: PUSH
65871: LD_INT 30
65873: PUSH
65874: LD_INT 0
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 30
65883: PUSH
65884: LD_INT 1
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: LIST
65895: PPUSH
65896: CALL_OW 72
65900: PUSH
65901: LD_INT 1
65903: ARRAY
65904: PPUSH
65905: CALL 104198 0 2
// break ;
65909: GO 65913
// end ; end ;
65911: GO 65831
65913: POP
65914: POP
// end ; end_of_file
65915: LD_VAR 0 5
65919: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65920: LD_INT 0
65922: PPUSH
65923: PPUSH
// if exist_mode then
65924: LD_VAR 0 2
65928: IFFALSE 65953
// unit := CreateCharacter ( prefix & ident ) else
65930: LD_ADDR_VAR 0 5
65934: PUSH
65935: LD_VAR 0 3
65939: PUSH
65940: LD_VAR 0 1
65944: STR
65945: PPUSH
65946: CALL_OW 34
65950: ST_TO_ADDR
65951: GO 65968
// unit := NewCharacter ( ident ) ;
65953: LD_ADDR_VAR 0 5
65957: PUSH
65958: LD_VAR 0 1
65962: PPUSH
65963: CALL_OW 25
65967: ST_TO_ADDR
// result := unit ;
65968: LD_ADDR_VAR 0 4
65972: PUSH
65973: LD_VAR 0 5
65977: ST_TO_ADDR
// end ;
65978: LD_VAR 0 4
65982: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65983: LD_INT 0
65985: PPUSH
65986: PPUSH
// if not side or not nation then
65987: LD_VAR 0 1
65991: NOT
65992: PUSH
65993: LD_VAR 0 2
65997: NOT
65998: OR
65999: IFFALSE 66003
// exit ;
66001: GO 66771
// case nation of nation_american :
66003: LD_VAR 0 2
66007: PUSH
66008: LD_INT 1
66010: DOUBLE
66011: EQUAL
66012: IFTRUE 66016
66014: GO 66230
66016: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
66017: LD_ADDR_VAR 0 4
66021: PUSH
66022: LD_INT 35
66024: PUSH
66025: LD_INT 45
66027: PUSH
66028: LD_INT 46
66030: PUSH
66031: LD_INT 47
66033: PUSH
66034: LD_INT 82
66036: PUSH
66037: LD_INT 83
66039: PUSH
66040: LD_INT 84
66042: PUSH
66043: LD_INT 85
66045: PUSH
66046: LD_INT 86
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: LD_INT 6
66057: PUSH
66058: LD_INT 15
66060: PUSH
66061: LD_INT 16
66063: PUSH
66064: LD_INT 7
66066: PUSH
66067: LD_INT 12
66069: PUSH
66070: LD_INT 13
66072: PUSH
66073: LD_INT 10
66075: PUSH
66076: LD_INT 14
66078: PUSH
66079: LD_INT 20
66081: PUSH
66082: LD_INT 21
66084: PUSH
66085: LD_INT 22
66087: PUSH
66088: LD_INT 25
66090: PUSH
66091: LD_INT 32
66093: PUSH
66094: LD_INT 27
66096: PUSH
66097: LD_INT 36
66099: PUSH
66100: LD_INT 69
66102: PUSH
66103: LD_INT 39
66105: PUSH
66106: LD_INT 34
66108: PUSH
66109: LD_INT 40
66111: PUSH
66112: LD_INT 48
66114: PUSH
66115: LD_INT 49
66117: PUSH
66118: LD_INT 50
66120: PUSH
66121: LD_INT 51
66123: PUSH
66124: LD_INT 52
66126: PUSH
66127: LD_INT 53
66129: PUSH
66130: LD_INT 54
66132: PUSH
66133: LD_INT 55
66135: PUSH
66136: LD_INT 56
66138: PUSH
66139: LD_INT 57
66141: PUSH
66142: LD_INT 58
66144: PUSH
66145: LD_INT 59
66147: PUSH
66148: LD_INT 60
66150: PUSH
66151: LD_INT 61
66153: PUSH
66154: LD_INT 62
66156: PUSH
66157: LD_INT 80
66159: PUSH
66160: LD_INT 82
66162: PUSH
66163: LD_INT 83
66165: PUSH
66166: LD_INT 84
66168: PUSH
66169: LD_INT 85
66171: PUSH
66172: LD_INT 86
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: ST_TO_ADDR
66228: GO 66695
66230: LD_INT 2
66232: DOUBLE
66233: EQUAL
66234: IFTRUE 66238
66236: GO 66464
66238: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66239: LD_ADDR_VAR 0 4
66243: PUSH
66244: LD_INT 35
66246: PUSH
66247: LD_INT 45
66249: PUSH
66250: LD_INT 46
66252: PUSH
66253: LD_INT 47
66255: PUSH
66256: LD_INT 82
66258: PUSH
66259: LD_INT 83
66261: PUSH
66262: LD_INT 84
66264: PUSH
66265: LD_INT 85
66267: PUSH
66268: LD_INT 87
66270: PUSH
66271: LD_INT 70
66273: PUSH
66274: LD_INT 1
66276: PUSH
66277: LD_INT 11
66279: PUSH
66280: LD_INT 3
66282: PUSH
66283: LD_INT 4
66285: PUSH
66286: LD_INT 5
66288: PUSH
66289: LD_INT 6
66291: PUSH
66292: LD_INT 15
66294: PUSH
66295: LD_INT 18
66297: PUSH
66298: LD_INT 7
66300: PUSH
66301: LD_INT 17
66303: PUSH
66304: LD_INT 8
66306: PUSH
66307: LD_INT 20
66309: PUSH
66310: LD_INT 21
66312: PUSH
66313: LD_INT 22
66315: PUSH
66316: LD_INT 72
66318: PUSH
66319: LD_INT 26
66321: PUSH
66322: LD_INT 69
66324: PUSH
66325: LD_INT 39
66327: PUSH
66328: LD_INT 40
66330: PUSH
66331: LD_INT 41
66333: PUSH
66334: LD_INT 42
66336: PUSH
66337: LD_INT 43
66339: PUSH
66340: LD_INT 48
66342: PUSH
66343: LD_INT 49
66345: PUSH
66346: LD_INT 50
66348: PUSH
66349: LD_INT 51
66351: PUSH
66352: LD_INT 52
66354: PUSH
66355: LD_INT 53
66357: PUSH
66358: LD_INT 54
66360: PUSH
66361: LD_INT 55
66363: PUSH
66364: LD_INT 56
66366: PUSH
66367: LD_INT 60
66369: PUSH
66370: LD_INT 61
66372: PUSH
66373: LD_INT 62
66375: PUSH
66376: LD_INT 66
66378: PUSH
66379: LD_INT 67
66381: PUSH
66382: LD_INT 68
66384: PUSH
66385: LD_INT 81
66387: PUSH
66388: LD_INT 82
66390: PUSH
66391: LD_INT 83
66393: PUSH
66394: LD_INT 84
66396: PUSH
66397: LD_INT 85
66399: PUSH
66400: LD_INT 87
66402: PUSH
66403: LD_INT 88
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: LIST
66427: LIST
66428: LIST
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: ST_TO_ADDR
66462: GO 66695
66464: LD_INT 3
66466: DOUBLE
66467: EQUAL
66468: IFTRUE 66472
66470: GO 66694
66472: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66473: LD_ADDR_VAR 0 4
66477: PUSH
66478: LD_INT 46
66480: PUSH
66481: LD_INT 47
66483: PUSH
66484: LD_INT 1
66486: PUSH
66487: LD_INT 2
66489: PUSH
66490: LD_INT 82
66492: PUSH
66493: LD_INT 83
66495: PUSH
66496: LD_INT 84
66498: PUSH
66499: LD_INT 85
66501: PUSH
66502: LD_INT 86
66504: PUSH
66505: LD_INT 11
66507: PUSH
66508: LD_INT 9
66510: PUSH
66511: LD_INT 20
66513: PUSH
66514: LD_INT 19
66516: PUSH
66517: LD_INT 21
66519: PUSH
66520: LD_INT 24
66522: PUSH
66523: LD_INT 22
66525: PUSH
66526: LD_INT 25
66528: PUSH
66529: LD_INT 28
66531: PUSH
66532: LD_INT 29
66534: PUSH
66535: LD_INT 30
66537: PUSH
66538: LD_INT 31
66540: PUSH
66541: LD_INT 37
66543: PUSH
66544: LD_INT 38
66546: PUSH
66547: LD_INT 32
66549: PUSH
66550: LD_INT 27
66552: PUSH
66553: LD_INT 33
66555: PUSH
66556: LD_INT 69
66558: PUSH
66559: LD_INT 39
66561: PUSH
66562: LD_INT 34
66564: PUSH
66565: LD_INT 40
66567: PUSH
66568: LD_INT 71
66570: PUSH
66571: LD_INT 23
66573: PUSH
66574: LD_INT 44
66576: PUSH
66577: LD_INT 48
66579: PUSH
66580: LD_INT 49
66582: PUSH
66583: LD_INT 50
66585: PUSH
66586: LD_INT 51
66588: PUSH
66589: LD_INT 52
66591: PUSH
66592: LD_INT 53
66594: PUSH
66595: LD_INT 54
66597: PUSH
66598: LD_INT 55
66600: PUSH
66601: LD_INT 56
66603: PUSH
66604: LD_INT 57
66606: PUSH
66607: LD_INT 58
66609: PUSH
66610: LD_INT 59
66612: PUSH
66613: LD_INT 63
66615: PUSH
66616: LD_INT 64
66618: PUSH
66619: LD_INT 65
66621: PUSH
66622: LD_INT 82
66624: PUSH
66625: LD_INT 83
66627: PUSH
66628: LD_INT 84
66630: PUSH
66631: LD_INT 85
66633: PUSH
66634: LD_INT 86
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: ST_TO_ADDR
66692: GO 66695
66694: POP
// if state > - 1 and state < 3 then
66695: LD_VAR 0 3
66699: PUSH
66700: LD_INT 1
66702: NEG
66703: GREATER
66704: PUSH
66705: LD_VAR 0 3
66709: PUSH
66710: LD_INT 3
66712: LESS
66713: AND
66714: IFFALSE 66771
// for i in result do
66716: LD_ADDR_VAR 0 5
66720: PUSH
66721: LD_VAR 0 4
66725: PUSH
66726: FOR_IN
66727: IFFALSE 66769
// if GetTech ( i , side ) <> state then
66729: LD_VAR 0 5
66733: PPUSH
66734: LD_VAR 0 1
66738: PPUSH
66739: CALL_OW 321
66743: PUSH
66744: LD_VAR 0 3
66748: NONEQUAL
66749: IFFALSE 66767
// result := result diff i ;
66751: LD_ADDR_VAR 0 4
66755: PUSH
66756: LD_VAR 0 4
66760: PUSH
66761: LD_VAR 0 5
66765: DIFF
66766: ST_TO_ADDR
66767: GO 66726
66769: POP
66770: POP
// end ;
66771: LD_VAR 0 4
66775: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66776: LD_INT 0
66778: PPUSH
66779: PPUSH
66780: PPUSH
// result := true ;
66781: LD_ADDR_VAR 0 3
66785: PUSH
66786: LD_INT 1
66788: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66789: LD_ADDR_VAR 0 5
66793: PUSH
66794: LD_VAR 0 2
66798: PPUSH
66799: CALL_OW 480
66803: ST_TO_ADDR
// if not tmp then
66804: LD_VAR 0 5
66808: NOT
66809: IFFALSE 66813
// exit ;
66811: GO 66862
// for i in tmp do
66813: LD_ADDR_VAR 0 4
66817: PUSH
66818: LD_VAR 0 5
66822: PUSH
66823: FOR_IN
66824: IFFALSE 66860
// if GetTech ( i , side ) <> state_researched then
66826: LD_VAR 0 4
66830: PPUSH
66831: LD_VAR 0 1
66835: PPUSH
66836: CALL_OW 321
66840: PUSH
66841: LD_INT 2
66843: NONEQUAL
66844: IFFALSE 66858
// begin result := false ;
66846: LD_ADDR_VAR 0 3
66850: PUSH
66851: LD_INT 0
66853: ST_TO_ADDR
// exit ;
66854: POP
66855: POP
66856: GO 66862
// end ;
66858: GO 66823
66860: POP
66861: POP
// end ;
66862: LD_VAR 0 3
66866: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66867: LD_INT 0
66869: PPUSH
66870: PPUSH
66871: PPUSH
66872: PPUSH
66873: PPUSH
66874: PPUSH
66875: PPUSH
66876: PPUSH
66877: PPUSH
66878: PPUSH
66879: PPUSH
66880: PPUSH
66881: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66882: LD_VAR 0 1
66886: NOT
66887: PUSH
66888: LD_VAR 0 1
66892: PPUSH
66893: CALL_OW 257
66897: PUSH
66898: LD_INT 9
66900: NONEQUAL
66901: OR
66902: IFFALSE 66906
// exit ;
66904: GO 67479
// side := GetSide ( unit ) ;
66906: LD_ADDR_VAR 0 9
66910: PUSH
66911: LD_VAR 0 1
66915: PPUSH
66916: CALL_OW 255
66920: ST_TO_ADDR
// tech_space := tech_spacanom ;
66921: LD_ADDR_VAR 0 12
66925: PUSH
66926: LD_INT 29
66928: ST_TO_ADDR
// tech_time := tech_taurad ;
66929: LD_ADDR_VAR 0 13
66933: PUSH
66934: LD_INT 28
66936: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66937: LD_ADDR_VAR 0 11
66941: PUSH
66942: LD_VAR 0 1
66946: PPUSH
66947: CALL_OW 310
66951: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66952: LD_VAR 0 11
66956: PPUSH
66957: CALL_OW 247
66961: PUSH
66962: LD_INT 2
66964: EQUAL
66965: IFFALSE 66969
// exit ;
66967: GO 67479
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66969: LD_ADDR_VAR 0 8
66973: PUSH
66974: LD_INT 81
66976: PUSH
66977: LD_VAR 0 9
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: LD_INT 3
66988: PUSH
66989: LD_INT 21
66991: PUSH
66992: LD_INT 3
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PPUSH
67007: CALL_OW 69
67011: ST_TO_ADDR
// if not tmp then
67012: LD_VAR 0 8
67016: NOT
67017: IFFALSE 67021
// exit ;
67019: GO 67479
// if in_unit then
67021: LD_VAR 0 11
67025: IFFALSE 67049
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
67027: LD_ADDR_VAR 0 10
67031: PUSH
67032: LD_VAR 0 8
67036: PPUSH
67037: LD_VAR 0 11
67041: PPUSH
67042: CALL_OW 74
67046: ST_TO_ADDR
67047: GO 67069
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67049: LD_ADDR_VAR 0 10
67053: PUSH
67054: LD_VAR 0 8
67058: PPUSH
67059: LD_VAR 0 1
67063: PPUSH
67064: CALL_OW 74
67068: ST_TO_ADDR
// if not enemy then
67069: LD_VAR 0 10
67073: NOT
67074: IFFALSE 67078
// exit ;
67076: GO 67479
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67078: LD_VAR 0 11
67082: PUSH
67083: LD_VAR 0 11
67087: PPUSH
67088: LD_VAR 0 10
67092: PPUSH
67093: CALL_OW 296
67097: PUSH
67098: LD_INT 13
67100: GREATER
67101: AND
67102: PUSH
67103: LD_VAR 0 1
67107: PPUSH
67108: LD_VAR 0 10
67112: PPUSH
67113: CALL_OW 296
67117: PUSH
67118: LD_INT 12
67120: GREATER
67121: OR
67122: IFFALSE 67126
// exit ;
67124: GO 67479
// missile := [ 1 ] ;
67126: LD_ADDR_VAR 0 14
67130: PUSH
67131: LD_INT 1
67133: PUSH
67134: EMPTY
67135: LIST
67136: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67137: LD_VAR 0 9
67141: PPUSH
67142: LD_VAR 0 12
67146: PPUSH
67147: CALL_OW 325
67151: IFFALSE 67180
// missile := Replace ( missile , missile + 1 , 2 ) ;
67153: LD_ADDR_VAR 0 14
67157: PUSH
67158: LD_VAR 0 14
67162: PPUSH
67163: LD_VAR 0 14
67167: PUSH
67168: LD_INT 1
67170: PLUS
67171: PPUSH
67172: LD_INT 2
67174: PPUSH
67175: CALL_OW 1
67179: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67180: LD_VAR 0 9
67184: PPUSH
67185: LD_VAR 0 13
67189: PPUSH
67190: CALL_OW 325
67194: PUSH
67195: LD_VAR 0 10
67199: PPUSH
67200: CALL_OW 255
67204: PPUSH
67205: LD_VAR 0 13
67209: PPUSH
67210: CALL_OW 325
67214: NOT
67215: AND
67216: IFFALSE 67245
// missile := Replace ( missile , missile + 1 , 3 ) ;
67218: LD_ADDR_VAR 0 14
67222: PUSH
67223: LD_VAR 0 14
67227: PPUSH
67228: LD_VAR 0 14
67232: PUSH
67233: LD_INT 1
67235: PLUS
67236: PPUSH
67237: LD_INT 3
67239: PPUSH
67240: CALL_OW 1
67244: ST_TO_ADDR
// if missile < 2 then
67245: LD_VAR 0 14
67249: PUSH
67250: LD_INT 2
67252: LESS
67253: IFFALSE 67257
// exit ;
67255: GO 67479
// x := GetX ( enemy ) ;
67257: LD_ADDR_VAR 0 4
67261: PUSH
67262: LD_VAR 0 10
67266: PPUSH
67267: CALL_OW 250
67271: ST_TO_ADDR
// y := GetY ( enemy ) ;
67272: LD_ADDR_VAR 0 5
67276: PUSH
67277: LD_VAR 0 10
67281: PPUSH
67282: CALL_OW 251
67286: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67287: LD_ADDR_VAR 0 6
67291: PUSH
67292: LD_VAR 0 4
67296: PUSH
67297: LD_INT 1
67299: NEG
67300: PPUSH
67301: LD_INT 1
67303: PPUSH
67304: CALL_OW 12
67308: PLUS
67309: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67310: LD_ADDR_VAR 0 7
67314: PUSH
67315: LD_VAR 0 5
67319: PUSH
67320: LD_INT 1
67322: NEG
67323: PPUSH
67324: LD_INT 1
67326: PPUSH
67327: CALL_OW 12
67331: PLUS
67332: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67333: LD_VAR 0 6
67337: PPUSH
67338: LD_VAR 0 7
67342: PPUSH
67343: CALL_OW 488
67347: NOT
67348: IFFALSE 67370
// begin _x := x ;
67350: LD_ADDR_VAR 0 6
67354: PUSH
67355: LD_VAR 0 4
67359: ST_TO_ADDR
// _y := y ;
67360: LD_ADDR_VAR 0 7
67364: PUSH
67365: LD_VAR 0 5
67369: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67370: LD_ADDR_VAR 0 3
67374: PUSH
67375: LD_INT 1
67377: PPUSH
67378: LD_VAR 0 14
67382: PPUSH
67383: CALL_OW 12
67387: ST_TO_ADDR
// case i of 1 :
67388: LD_VAR 0 3
67392: PUSH
67393: LD_INT 1
67395: DOUBLE
67396: EQUAL
67397: IFTRUE 67401
67399: GO 67418
67401: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67402: LD_VAR 0 1
67406: PPUSH
67407: LD_VAR 0 10
67411: PPUSH
67412: CALL_OW 115
67416: GO 67479
67418: LD_INT 2
67420: DOUBLE
67421: EQUAL
67422: IFTRUE 67426
67424: GO 67448
67426: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67427: LD_VAR 0 1
67431: PPUSH
67432: LD_VAR 0 6
67436: PPUSH
67437: LD_VAR 0 7
67441: PPUSH
67442: CALL_OW 153
67446: GO 67479
67448: LD_INT 3
67450: DOUBLE
67451: EQUAL
67452: IFTRUE 67456
67454: GO 67478
67456: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67457: LD_VAR 0 1
67461: PPUSH
67462: LD_VAR 0 6
67466: PPUSH
67467: LD_VAR 0 7
67471: PPUSH
67472: CALL_OW 154
67476: GO 67479
67478: POP
// end ;
67479: LD_VAR 0 2
67483: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67484: LD_INT 0
67486: PPUSH
67487: PPUSH
67488: PPUSH
67489: PPUSH
67490: PPUSH
67491: PPUSH
// if not unit or not building then
67492: LD_VAR 0 1
67496: NOT
67497: PUSH
67498: LD_VAR 0 2
67502: NOT
67503: OR
67504: IFFALSE 67508
// exit ;
67506: GO 67666
// x := GetX ( building ) ;
67508: LD_ADDR_VAR 0 5
67512: PUSH
67513: LD_VAR 0 2
67517: PPUSH
67518: CALL_OW 250
67522: ST_TO_ADDR
// y := GetY ( building ) ;
67523: LD_ADDR_VAR 0 6
67527: PUSH
67528: LD_VAR 0 2
67532: PPUSH
67533: CALL_OW 251
67537: ST_TO_ADDR
// for i = 0 to 5 do
67538: LD_ADDR_VAR 0 4
67542: PUSH
67543: DOUBLE
67544: LD_INT 0
67546: DEC
67547: ST_TO_ADDR
67548: LD_INT 5
67550: PUSH
67551: FOR_TO
67552: IFFALSE 67664
// begin _x := ShiftX ( x , i , 3 ) ;
67554: LD_ADDR_VAR 0 7
67558: PUSH
67559: LD_VAR 0 5
67563: PPUSH
67564: LD_VAR 0 4
67568: PPUSH
67569: LD_INT 3
67571: PPUSH
67572: CALL_OW 272
67576: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67577: LD_ADDR_VAR 0 8
67581: PUSH
67582: LD_VAR 0 6
67586: PPUSH
67587: LD_VAR 0 4
67591: PPUSH
67592: LD_INT 3
67594: PPUSH
67595: CALL_OW 273
67599: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67600: LD_VAR 0 7
67604: PPUSH
67605: LD_VAR 0 8
67609: PPUSH
67610: CALL_OW 488
67614: NOT
67615: IFFALSE 67619
// continue ;
67617: GO 67551
// if HexInfo ( _x , _y ) = 0 then
67619: LD_VAR 0 7
67623: PPUSH
67624: LD_VAR 0 8
67628: PPUSH
67629: CALL_OW 428
67633: PUSH
67634: LD_INT 0
67636: EQUAL
67637: IFFALSE 67662
// begin ComMoveXY ( unit , _x , _y ) ;
67639: LD_VAR 0 1
67643: PPUSH
67644: LD_VAR 0 7
67648: PPUSH
67649: LD_VAR 0 8
67653: PPUSH
67654: CALL_OW 111
// exit ;
67658: POP
67659: POP
67660: GO 67666
// end ; end ;
67662: GO 67551
67664: POP
67665: POP
// end ;
67666: LD_VAR 0 3
67670: RET
// export function ScanBase ( side , base_area ) ; begin
67671: LD_INT 0
67673: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67674: LD_ADDR_VAR 0 3
67678: PUSH
67679: LD_VAR 0 2
67683: PPUSH
67684: LD_INT 81
67686: PUSH
67687: LD_VAR 0 1
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PPUSH
67696: CALL_OW 70
67700: ST_TO_ADDR
// end ;
67701: LD_VAR 0 3
67705: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67706: LD_INT 0
67708: PPUSH
67709: PPUSH
67710: PPUSH
67711: PPUSH
// result := false ;
67712: LD_ADDR_VAR 0 2
67716: PUSH
67717: LD_INT 0
67719: ST_TO_ADDR
// side := GetSide ( unit ) ;
67720: LD_ADDR_VAR 0 3
67724: PUSH
67725: LD_VAR 0 1
67729: PPUSH
67730: CALL_OW 255
67734: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67735: LD_ADDR_VAR 0 4
67739: PUSH
67740: LD_VAR 0 1
67744: PPUSH
67745: CALL_OW 248
67749: ST_TO_ADDR
// case nat of 1 :
67750: LD_VAR 0 4
67754: PUSH
67755: LD_INT 1
67757: DOUBLE
67758: EQUAL
67759: IFTRUE 67763
67761: GO 67774
67763: POP
// tech := tech_lassight ; 2 :
67764: LD_ADDR_VAR 0 5
67768: PUSH
67769: LD_INT 12
67771: ST_TO_ADDR
67772: GO 67813
67774: LD_INT 2
67776: DOUBLE
67777: EQUAL
67778: IFTRUE 67782
67780: GO 67793
67782: POP
// tech := tech_mortar ; 3 :
67783: LD_ADDR_VAR 0 5
67787: PUSH
67788: LD_INT 41
67790: ST_TO_ADDR
67791: GO 67813
67793: LD_INT 3
67795: DOUBLE
67796: EQUAL
67797: IFTRUE 67801
67799: GO 67812
67801: POP
// tech := tech_bazooka ; end ;
67802: LD_ADDR_VAR 0 5
67806: PUSH
67807: LD_INT 44
67809: ST_TO_ADDR
67810: GO 67813
67812: POP
// if Researched ( side , tech ) then
67813: LD_VAR 0 3
67817: PPUSH
67818: LD_VAR 0 5
67822: PPUSH
67823: CALL_OW 325
67827: IFFALSE 67854
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67829: LD_ADDR_VAR 0 2
67833: PUSH
67834: LD_INT 5
67836: PUSH
67837: LD_INT 8
67839: PUSH
67840: LD_INT 9
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: LIST
67847: PUSH
67848: LD_VAR 0 4
67852: ARRAY
67853: ST_TO_ADDR
// end ;
67854: LD_VAR 0 2
67858: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67859: LD_INT 0
67861: PPUSH
67862: PPUSH
67863: PPUSH
// if not mines then
67864: LD_VAR 0 2
67868: NOT
67869: IFFALSE 67873
// exit ;
67871: GO 68017
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67873: LD_ADDR_VAR 0 5
67877: PUSH
67878: LD_INT 81
67880: PUSH
67881: LD_VAR 0 1
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 3
67892: PUSH
67893: LD_INT 21
67895: PUSH
67896: LD_INT 3
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PPUSH
67911: CALL_OW 69
67915: ST_TO_ADDR
// for i in mines do
67916: LD_ADDR_VAR 0 4
67920: PUSH
67921: LD_VAR 0 2
67925: PUSH
67926: FOR_IN
67927: IFFALSE 68015
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67929: LD_VAR 0 4
67933: PUSH
67934: LD_INT 1
67936: ARRAY
67937: PPUSH
67938: LD_VAR 0 4
67942: PUSH
67943: LD_INT 2
67945: ARRAY
67946: PPUSH
67947: CALL_OW 458
67951: NOT
67952: IFFALSE 67956
// continue ;
67954: GO 67926
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67956: LD_VAR 0 4
67960: PUSH
67961: LD_INT 1
67963: ARRAY
67964: PPUSH
67965: LD_VAR 0 4
67969: PUSH
67970: LD_INT 2
67972: ARRAY
67973: PPUSH
67974: CALL_OW 428
67978: PUSH
67979: LD_VAR 0 5
67983: IN
67984: IFFALSE 68013
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67986: LD_VAR 0 4
67990: PUSH
67991: LD_INT 1
67993: ARRAY
67994: PPUSH
67995: LD_VAR 0 4
67999: PUSH
68000: LD_INT 2
68002: ARRAY
68003: PPUSH
68004: LD_VAR 0 1
68008: PPUSH
68009: CALL_OW 456
// end ;
68013: GO 67926
68015: POP
68016: POP
// end ;
68017: LD_VAR 0 3
68021: RET
// export function Count ( array ) ; var i ; begin
68022: LD_INT 0
68024: PPUSH
68025: PPUSH
// result := 0 ;
68026: LD_ADDR_VAR 0 2
68030: PUSH
68031: LD_INT 0
68033: ST_TO_ADDR
// for i in array do
68034: LD_ADDR_VAR 0 3
68038: PUSH
68039: LD_VAR 0 1
68043: PUSH
68044: FOR_IN
68045: IFFALSE 68069
// if i then
68047: LD_VAR 0 3
68051: IFFALSE 68067
// result := result + 1 ;
68053: LD_ADDR_VAR 0 2
68057: PUSH
68058: LD_VAR 0 2
68062: PUSH
68063: LD_INT 1
68065: PLUS
68066: ST_TO_ADDR
68067: GO 68044
68069: POP
68070: POP
// end ;
68071: LD_VAR 0 2
68075: RET
// export function IsEmpty ( building ) ; begin
68076: LD_INT 0
68078: PPUSH
// if not building then
68079: LD_VAR 0 1
68083: NOT
68084: IFFALSE 68088
// exit ;
68086: GO 68131
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68088: LD_ADDR_VAR 0 2
68092: PUSH
68093: LD_VAR 0 1
68097: PUSH
68098: LD_INT 22
68100: PUSH
68101: LD_VAR 0 1
68105: PPUSH
68106: CALL_OW 255
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 58
68117: PUSH
68118: EMPTY
68119: LIST
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PPUSH
68125: CALL_OW 69
68129: IN
68130: ST_TO_ADDR
// end ;
68131: LD_VAR 0 2
68135: RET
// export function IsNotFull ( building ) ; var places ; begin
68136: LD_INT 0
68138: PPUSH
68139: PPUSH
// if not building then
68140: LD_VAR 0 1
68144: NOT
68145: IFFALSE 68149
// exit ;
68147: GO 68320
// result := false ;
68149: LD_ADDR_VAR 0 2
68153: PUSH
68154: LD_INT 0
68156: ST_TO_ADDR
// places := 0 ;
68157: LD_ADDR_VAR 0 3
68161: PUSH
68162: LD_INT 0
68164: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
68165: LD_VAR 0 1
68169: PPUSH
68170: CALL_OW 266
68174: PUSH
68175: LD_INT 0
68177: DOUBLE
68178: EQUAL
68179: IFTRUE 68237
68181: LD_INT 1
68183: DOUBLE
68184: EQUAL
68185: IFTRUE 68237
68187: LD_INT 6
68189: DOUBLE
68190: EQUAL
68191: IFTRUE 68237
68193: LD_INT 7
68195: DOUBLE
68196: EQUAL
68197: IFTRUE 68237
68199: LD_INT 8
68201: DOUBLE
68202: EQUAL
68203: IFTRUE 68237
68205: LD_INT 4
68207: DOUBLE
68208: EQUAL
68209: IFTRUE 68237
68211: LD_INT 5
68213: DOUBLE
68214: EQUAL
68215: IFTRUE 68237
68217: LD_INT 2
68219: DOUBLE
68220: EQUAL
68221: IFTRUE 68237
68223: LD_INT 3
68225: DOUBLE
68226: EQUAL
68227: IFTRUE 68237
68229: LD_INT 35
68231: DOUBLE
68232: EQUAL
68233: IFTRUE 68237
68235: GO 68248
68237: POP
// places := 6 ; b_bunker , b_breastwork :
68238: LD_ADDR_VAR 0 3
68242: PUSH
68243: LD_INT 6
68245: ST_TO_ADDR
68246: GO 68293
68248: LD_INT 32
68250: DOUBLE
68251: EQUAL
68252: IFTRUE 68262
68254: LD_INT 31
68256: DOUBLE
68257: EQUAL
68258: IFTRUE 68262
68260: GO 68273
68262: POP
// places := 1 ; b_control_tower :
68263: LD_ADDR_VAR 0 3
68267: PUSH
68268: LD_INT 1
68270: ST_TO_ADDR
68271: GO 68293
68273: LD_INT 36
68275: DOUBLE
68276: EQUAL
68277: IFTRUE 68281
68279: GO 68292
68281: POP
// places := 3 ; end ;
68282: LD_ADDR_VAR 0 3
68286: PUSH
68287: LD_INT 3
68289: ST_TO_ADDR
68290: GO 68293
68292: POP
// if places then
68293: LD_VAR 0 3
68297: IFFALSE 68320
// result := UnitsInside ( building ) < places ;
68299: LD_ADDR_VAR 0 2
68303: PUSH
68304: LD_VAR 0 1
68308: PPUSH
68309: CALL_OW 313
68313: PUSH
68314: LD_VAR 0 3
68318: LESS
68319: ST_TO_ADDR
// end ;
68320: LD_VAR 0 2
68324: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68325: LD_INT 0
68327: PPUSH
68328: PPUSH
68329: PPUSH
68330: PPUSH
// tmp := [ ] ;
68331: LD_ADDR_VAR 0 3
68335: PUSH
68336: EMPTY
68337: ST_TO_ADDR
// list := [ ] ;
68338: LD_ADDR_VAR 0 5
68342: PUSH
68343: EMPTY
68344: ST_TO_ADDR
// for i = 16 to 25 do
68345: LD_ADDR_VAR 0 4
68349: PUSH
68350: DOUBLE
68351: LD_INT 16
68353: DEC
68354: ST_TO_ADDR
68355: LD_INT 25
68357: PUSH
68358: FOR_TO
68359: IFFALSE 68432
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68361: LD_ADDR_VAR 0 3
68365: PUSH
68366: LD_VAR 0 3
68370: PUSH
68371: LD_INT 22
68373: PUSH
68374: LD_VAR 0 1
68378: PPUSH
68379: CALL_OW 255
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 91
68390: PUSH
68391: LD_VAR 0 1
68395: PUSH
68396: LD_INT 6
68398: PUSH
68399: EMPTY
68400: LIST
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 30
68406: PUSH
68407: LD_VAR 0 4
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PUSH
68416: EMPTY
68417: LIST
68418: LIST
68419: LIST
68420: PUSH
68421: EMPTY
68422: LIST
68423: PPUSH
68424: CALL_OW 69
68428: ADD
68429: ST_TO_ADDR
68430: GO 68358
68432: POP
68433: POP
// for i = 1 to tmp do
68434: LD_ADDR_VAR 0 4
68438: PUSH
68439: DOUBLE
68440: LD_INT 1
68442: DEC
68443: ST_TO_ADDR
68444: LD_VAR 0 3
68448: PUSH
68449: FOR_TO
68450: IFFALSE 68538
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68452: LD_ADDR_VAR 0 5
68456: PUSH
68457: LD_VAR 0 5
68461: PUSH
68462: LD_VAR 0 3
68466: PUSH
68467: LD_VAR 0 4
68471: ARRAY
68472: PPUSH
68473: CALL_OW 266
68477: PUSH
68478: LD_VAR 0 3
68482: PUSH
68483: LD_VAR 0 4
68487: ARRAY
68488: PPUSH
68489: CALL_OW 250
68493: PUSH
68494: LD_VAR 0 3
68498: PUSH
68499: LD_VAR 0 4
68503: ARRAY
68504: PPUSH
68505: CALL_OW 251
68509: PUSH
68510: LD_VAR 0 3
68514: PUSH
68515: LD_VAR 0 4
68519: ARRAY
68520: PPUSH
68521: CALL_OW 254
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: PUSH
68532: EMPTY
68533: LIST
68534: ADD
68535: ST_TO_ADDR
68536: GO 68449
68538: POP
68539: POP
// result := list ;
68540: LD_ADDR_VAR 0 2
68544: PUSH
68545: LD_VAR 0 5
68549: ST_TO_ADDR
// end ;
68550: LD_VAR 0 2
68554: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68555: LD_INT 0
68557: PPUSH
68558: PPUSH
68559: PPUSH
68560: PPUSH
68561: PPUSH
68562: PPUSH
68563: PPUSH
// if not factory then
68564: LD_VAR 0 1
68568: NOT
68569: IFFALSE 68573
// exit ;
68571: GO 69166
// if control = control_apeman then
68573: LD_VAR 0 4
68577: PUSH
68578: LD_INT 5
68580: EQUAL
68581: IFFALSE 68690
// begin tmp := UnitsInside ( factory ) ;
68583: LD_ADDR_VAR 0 8
68587: PUSH
68588: LD_VAR 0 1
68592: PPUSH
68593: CALL_OW 313
68597: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68598: LD_VAR 0 8
68602: PPUSH
68603: LD_INT 25
68605: PUSH
68606: LD_INT 12
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PPUSH
68613: CALL_OW 72
68617: NOT
68618: IFFALSE 68628
// control := control_manual ;
68620: LD_ADDR_VAR 0 4
68624: PUSH
68625: LD_INT 1
68627: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68628: LD_ADDR_VAR 0 8
68632: PUSH
68633: LD_VAR 0 1
68637: PPUSH
68638: CALL 68325 0 1
68642: ST_TO_ADDR
// if tmp then
68643: LD_VAR 0 8
68647: IFFALSE 68690
// begin for i in tmp do
68649: LD_ADDR_VAR 0 7
68653: PUSH
68654: LD_VAR 0 8
68658: PUSH
68659: FOR_IN
68660: IFFALSE 68688
// if i [ 1 ] = b_ext_radio then
68662: LD_VAR 0 7
68666: PUSH
68667: LD_INT 1
68669: ARRAY
68670: PUSH
68671: LD_INT 22
68673: EQUAL
68674: IFFALSE 68686
// begin control := control_remote ;
68676: LD_ADDR_VAR 0 4
68680: PUSH
68681: LD_INT 2
68683: ST_TO_ADDR
// break ;
68684: GO 68688
// end ;
68686: GO 68659
68688: POP
68689: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68690: LD_VAR 0 1
68694: PPUSH
68695: LD_VAR 0 2
68699: PPUSH
68700: LD_VAR 0 3
68704: PPUSH
68705: LD_VAR 0 4
68709: PPUSH
68710: LD_VAR 0 5
68714: PPUSH
68715: CALL_OW 448
68719: IFFALSE 68754
// begin result := [ chassis , engine , control , weapon ] ;
68721: LD_ADDR_VAR 0 6
68725: PUSH
68726: LD_VAR 0 2
68730: PUSH
68731: LD_VAR 0 3
68735: PUSH
68736: LD_VAR 0 4
68740: PUSH
68741: LD_VAR 0 5
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: LIST
68750: LIST
68751: ST_TO_ADDR
// exit ;
68752: GO 69166
// end ; _chassis := AvailableChassisList ( factory ) ;
68754: LD_ADDR_VAR 0 9
68758: PUSH
68759: LD_VAR 0 1
68763: PPUSH
68764: CALL_OW 475
68768: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68769: LD_ADDR_VAR 0 11
68773: PUSH
68774: LD_VAR 0 1
68778: PPUSH
68779: CALL_OW 476
68783: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68784: LD_ADDR_VAR 0 12
68788: PUSH
68789: LD_VAR 0 1
68793: PPUSH
68794: CALL_OW 477
68798: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68799: LD_ADDR_VAR 0 10
68803: PUSH
68804: LD_VAR 0 1
68808: PPUSH
68809: CALL_OW 478
68813: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68814: LD_VAR 0 9
68818: NOT
68819: PUSH
68820: LD_VAR 0 11
68824: NOT
68825: OR
68826: PUSH
68827: LD_VAR 0 12
68831: NOT
68832: OR
68833: PUSH
68834: LD_VAR 0 10
68838: NOT
68839: OR
68840: IFFALSE 68875
// begin result := [ chassis , engine , control , weapon ] ;
68842: LD_ADDR_VAR 0 6
68846: PUSH
68847: LD_VAR 0 2
68851: PUSH
68852: LD_VAR 0 3
68856: PUSH
68857: LD_VAR 0 4
68861: PUSH
68862: LD_VAR 0 5
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: ST_TO_ADDR
// exit ;
68873: GO 69166
// end ; if not chassis in _chassis then
68875: LD_VAR 0 2
68879: PUSH
68880: LD_VAR 0 9
68884: IN
68885: NOT
68886: IFFALSE 68912
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68888: LD_ADDR_VAR 0 2
68892: PUSH
68893: LD_VAR 0 9
68897: PUSH
68898: LD_INT 1
68900: PPUSH
68901: LD_VAR 0 9
68905: PPUSH
68906: CALL_OW 12
68910: ARRAY
68911: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68912: LD_VAR 0 2
68916: PPUSH
68917: LD_VAR 0 3
68921: PPUSH
68922: CALL 69171 0 2
68926: NOT
68927: IFFALSE 68986
// repeat engine := _engine [ 1 ] ;
68929: LD_ADDR_VAR 0 3
68933: PUSH
68934: LD_VAR 0 11
68938: PUSH
68939: LD_INT 1
68941: ARRAY
68942: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68943: LD_ADDR_VAR 0 11
68947: PUSH
68948: LD_VAR 0 11
68952: PPUSH
68953: LD_INT 1
68955: PPUSH
68956: CALL_OW 3
68960: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68961: LD_VAR 0 2
68965: PPUSH
68966: LD_VAR 0 3
68970: PPUSH
68971: CALL 69171 0 2
68975: PUSH
68976: LD_VAR 0 11
68980: PUSH
68981: EMPTY
68982: EQUAL
68983: OR
68984: IFFALSE 68929
// if not control in _control then
68986: LD_VAR 0 4
68990: PUSH
68991: LD_VAR 0 12
68995: IN
68996: NOT
68997: IFFALSE 69023
// control := _control [ rand ( 1 , _control ) ] ;
68999: LD_ADDR_VAR 0 4
69003: PUSH
69004: LD_VAR 0 12
69008: PUSH
69009: LD_INT 1
69011: PPUSH
69012: LD_VAR 0 12
69016: PPUSH
69017: CALL_OW 12
69021: ARRAY
69022: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69023: LD_VAR 0 2
69027: PPUSH
69028: LD_VAR 0 5
69032: PPUSH
69033: CALL 69391 0 2
69037: NOT
69038: IFFALSE 69097
// repeat weapon := _weapon [ 1 ] ;
69040: LD_ADDR_VAR 0 5
69044: PUSH
69045: LD_VAR 0 10
69049: PUSH
69050: LD_INT 1
69052: ARRAY
69053: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69054: LD_ADDR_VAR 0 10
69058: PUSH
69059: LD_VAR 0 10
69063: PPUSH
69064: LD_INT 1
69066: PPUSH
69067: CALL_OW 3
69071: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69072: LD_VAR 0 2
69076: PPUSH
69077: LD_VAR 0 5
69081: PPUSH
69082: CALL 69391 0 2
69086: PUSH
69087: LD_VAR 0 10
69091: PUSH
69092: EMPTY
69093: EQUAL
69094: OR
69095: IFFALSE 69040
// result := [ ] ;
69097: LD_ADDR_VAR 0 6
69101: PUSH
69102: EMPTY
69103: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69104: LD_VAR 0 1
69108: PPUSH
69109: LD_VAR 0 2
69113: PPUSH
69114: LD_VAR 0 3
69118: PPUSH
69119: LD_VAR 0 4
69123: PPUSH
69124: LD_VAR 0 5
69128: PPUSH
69129: CALL_OW 448
69133: IFFALSE 69166
// result := [ chassis , engine , control , weapon ] ;
69135: LD_ADDR_VAR 0 6
69139: PUSH
69140: LD_VAR 0 2
69144: PUSH
69145: LD_VAR 0 3
69149: PUSH
69150: LD_VAR 0 4
69154: PUSH
69155: LD_VAR 0 5
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: ST_TO_ADDR
// end ;
69166: LD_VAR 0 6
69170: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69171: LD_INT 0
69173: PPUSH
// if not chassis or not engine then
69174: LD_VAR 0 1
69178: NOT
69179: PUSH
69180: LD_VAR 0 2
69184: NOT
69185: OR
69186: IFFALSE 69190
// exit ;
69188: GO 69386
// case engine of engine_solar :
69190: LD_VAR 0 2
69194: PUSH
69195: LD_INT 2
69197: DOUBLE
69198: EQUAL
69199: IFTRUE 69203
69201: GO 69241
69203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69204: LD_ADDR_VAR 0 3
69208: PUSH
69209: LD_INT 11
69211: PUSH
69212: LD_INT 12
69214: PUSH
69215: LD_INT 13
69217: PUSH
69218: LD_INT 14
69220: PUSH
69221: LD_INT 1
69223: PUSH
69224: LD_INT 2
69226: PUSH
69227: LD_INT 3
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: LIST
69234: LIST
69235: LIST
69236: LIST
69237: LIST
69238: ST_TO_ADDR
69239: GO 69370
69241: LD_INT 1
69243: DOUBLE
69244: EQUAL
69245: IFTRUE 69249
69247: GO 69311
69249: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69250: LD_ADDR_VAR 0 3
69254: PUSH
69255: LD_INT 11
69257: PUSH
69258: LD_INT 12
69260: PUSH
69261: LD_INT 13
69263: PUSH
69264: LD_INT 14
69266: PUSH
69267: LD_INT 1
69269: PUSH
69270: LD_INT 2
69272: PUSH
69273: LD_INT 3
69275: PUSH
69276: LD_INT 4
69278: PUSH
69279: LD_INT 5
69281: PUSH
69282: LD_INT 21
69284: PUSH
69285: LD_INT 23
69287: PUSH
69288: LD_INT 22
69290: PUSH
69291: LD_INT 24
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: ST_TO_ADDR
69309: GO 69370
69311: LD_INT 3
69313: DOUBLE
69314: EQUAL
69315: IFTRUE 69319
69317: GO 69369
69319: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69320: LD_ADDR_VAR 0 3
69324: PUSH
69325: LD_INT 13
69327: PUSH
69328: LD_INT 14
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: LD_INT 3
69336: PUSH
69337: LD_INT 4
69339: PUSH
69340: LD_INT 5
69342: PUSH
69343: LD_INT 21
69345: PUSH
69346: LD_INT 22
69348: PUSH
69349: LD_INT 23
69351: PUSH
69352: LD_INT 24
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: ST_TO_ADDR
69367: GO 69370
69369: POP
// result := ( chassis in result ) ;
69370: LD_ADDR_VAR 0 3
69374: PUSH
69375: LD_VAR 0 1
69379: PUSH
69380: LD_VAR 0 3
69384: IN
69385: ST_TO_ADDR
// end ;
69386: LD_VAR 0 3
69390: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69391: LD_INT 0
69393: PPUSH
// if not chassis or not weapon then
69394: LD_VAR 0 1
69398: NOT
69399: PUSH
69400: LD_VAR 0 2
69404: NOT
69405: OR
69406: IFFALSE 69410
// exit ;
69408: GO 70472
// case weapon of us_machine_gun :
69410: LD_VAR 0 2
69414: PUSH
69415: LD_INT 2
69417: DOUBLE
69418: EQUAL
69419: IFTRUE 69423
69421: GO 69453
69423: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69424: LD_ADDR_VAR 0 3
69428: PUSH
69429: LD_INT 1
69431: PUSH
69432: LD_INT 2
69434: PUSH
69435: LD_INT 3
69437: PUSH
69438: LD_INT 4
69440: PUSH
69441: LD_INT 5
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: LIST
69448: LIST
69449: LIST
69450: ST_TO_ADDR
69451: GO 70456
69453: LD_INT 3
69455: DOUBLE
69456: EQUAL
69457: IFTRUE 69461
69459: GO 69491
69461: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69462: LD_ADDR_VAR 0 3
69466: PUSH
69467: LD_INT 1
69469: PUSH
69470: LD_INT 2
69472: PUSH
69473: LD_INT 3
69475: PUSH
69476: LD_INT 4
69478: PUSH
69479: LD_INT 5
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: ST_TO_ADDR
69489: GO 70456
69491: LD_INT 11
69493: DOUBLE
69494: EQUAL
69495: IFTRUE 69499
69497: GO 69529
69499: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69500: LD_ADDR_VAR 0 3
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: LD_INT 2
69510: PUSH
69511: LD_INT 3
69513: PUSH
69514: LD_INT 4
69516: PUSH
69517: LD_INT 5
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: LIST
69526: ST_TO_ADDR
69527: GO 70456
69529: LD_INT 4
69531: DOUBLE
69532: EQUAL
69533: IFTRUE 69537
69535: GO 69563
69537: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69538: LD_ADDR_VAR 0 3
69542: PUSH
69543: LD_INT 2
69545: PUSH
69546: LD_INT 3
69548: PUSH
69549: LD_INT 4
69551: PUSH
69552: LD_INT 5
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: LIST
69559: LIST
69560: ST_TO_ADDR
69561: GO 70456
69563: LD_INT 5
69565: DOUBLE
69566: EQUAL
69567: IFTRUE 69571
69569: GO 69597
69571: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69572: LD_ADDR_VAR 0 3
69576: PUSH
69577: LD_INT 2
69579: PUSH
69580: LD_INT 3
69582: PUSH
69583: LD_INT 4
69585: PUSH
69586: LD_INT 5
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: ST_TO_ADDR
69595: GO 70456
69597: LD_INT 9
69599: DOUBLE
69600: EQUAL
69601: IFTRUE 69605
69603: GO 69631
69605: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69606: LD_ADDR_VAR 0 3
69610: PUSH
69611: LD_INT 2
69613: PUSH
69614: LD_INT 3
69616: PUSH
69617: LD_INT 4
69619: PUSH
69620: LD_INT 5
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: ST_TO_ADDR
69629: GO 70456
69631: LD_INT 7
69633: DOUBLE
69634: EQUAL
69635: IFTRUE 69639
69637: GO 69665
69639: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69640: LD_ADDR_VAR 0 3
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 3
69650: PUSH
69651: LD_INT 4
69653: PUSH
69654: LD_INT 5
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: LIST
69661: LIST
69662: ST_TO_ADDR
69663: GO 70456
69665: LD_INT 12
69667: DOUBLE
69668: EQUAL
69669: IFTRUE 69673
69671: GO 69699
69673: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69674: LD_ADDR_VAR 0 3
69678: PUSH
69679: LD_INT 2
69681: PUSH
69682: LD_INT 3
69684: PUSH
69685: LD_INT 4
69687: PUSH
69688: LD_INT 5
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: ST_TO_ADDR
69697: GO 70456
69699: LD_INT 13
69701: DOUBLE
69702: EQUAL
69703: IFTRUE 69707
69705: GO 69733
69707: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69708: LD_ADDR_VAR 0 3
69712: PUSH
69713: LD_INT 2
69715: PUSH
69716: LD_INT 3
69718: PUSH
69719: LD_INT 4
69721: PUSH
69722: LD_INT 5
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: ST_TO_ADDR
69731: GO 70456
69733: LD_INT 14
69735: DOUBLE
69736: EQUAL
69737: IFTRUE 69741
69739: GO 69759
69741: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69742: LD_ADDR_VAR 0 3
69746: PUSH
69747: LD_INT 4
69749: PUSH
69750: LD_INT 5
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: ST_TO_ADDR
69757: GO 70456
69759: LD_INT 6
69761: DOUBLE
69762: EQUAL
69763: IFTRUE 69767
69765: GO 69785
69767: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69768: LD_ADDR_VAR 0 3
69772: PUSH
69773: LD_INT 4
69775: PUSH
69776: LD_INT 5
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: ST_TO_ADDR
69783: GO 70456
69785: LD_INT 10
69787: DOUBLE
69788: EQUAL
69789: IFTRUE 69793
69791: GO 69811
69793: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69794: LD_ADDR_VAR 0 3
69798: PUSH
69799: LD_INT 4
69801: PUSH
69802: LD_INT 5
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: ST_TO_ADDR
69809: GO 70456
69811: LD_INT 22
69813: DOUBLE
69814: EQUAL
69815: IFTRUE 69819
69817: GO 69845
69819: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69820: LD_ADDR_VAR 0 3
69824: PUSH
69825: LD_INT 11
69827: PUSH
69828: LD_INT 12
69830: PUSH
69831: LD_INT 13
69833: PUSH
69834: LD_INT 14
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: ST_TO_ADDR
69843: GO 70456
69845: LD_INT 23
69847: DOUBLE
69848: EQUAL
69849: IFTRUE 69853
69851: GO 69879
69853: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69854: LD_ADDR_VAR 0 3
69858: PUSH
69859: LD_INT 11
69861: PUSH
69862: LD_INT 12
69864: PUSH
69865: LD_INT 13
69867: PUSH
69868: LD_INT 14
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: ST_TO_ADDR
69877: GO 70456
69879: LD_INT 24
69881: DOUBLE
69882: EQUAL
69883: IFTRUE 69887
69885: GO 69913
69887: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69888: LD_ADDR_VAR 0 3
69892: PUSH
69893: LD_INT 11
69895: PUSH
69896: LD_INT 12
69898: PUSH
69899: LD_INT 13
69901: PUSH
69902: LD_INT 14
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: ST_TO_ADDR
69911: GO 70456
69913: LD_INT 30
69915: DOUBLE
69916: EQUAL
69917: IFTRUE 69921
69919: GO 69947
69921: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69922: LD_ADDR_VAR 0 3
69926: PUSH
69927: LD_INT 11
69929: PUSH
69930: LD_INT 12
69932: PUSH
69933: LD_INT 13
69935: PUSH
69936: LD_INT 14
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: ST_TO_ADDR
69945: GO 70456
69947: LD_INT 25
69949: DOUBLE
69950: EQUAL
69951: IFTRUE 69955
69953: GO 69973
69955: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69956: LD_ADDR_VAR 0 3
69960: PUSH
69961: LD_INT 13
69963: PUSH
69964: LD_INT 14
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: ST_TO_ADDR
69971: GO 70456
69973: LD_INT 27
69975: DOUBLE
69976: EQUAL
69977: IFTRUE 69981
69979: GO 69999
69981: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69982: LD_ADDR_VAR 0 3
69986: PUSH
69987: LD_INT 13
69989: PUSH
69990: LD_INT 14
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: ST_TO_ADDR
69997: GO 70456
69999: LD_EXP 100
70003: DOUBLE
70004: EQUAL
70005: IFTRUE 70009
70007: GO 70035
70009: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70010: LD_ADDR_VAR 0 3
70014: PUSH
70015: LD_INT 11
70017: PUSH
70018: LD_INT 12
70020: PUSH
70021: LD_INT 13
70023: PUSH
70024: LD_INT 14
70026: PUSH
70027: EMPTY
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: ST_TO_ADDR
70033: GO 70456
70035: LD_INT 28
70037: DOUBLE
70038: EQUAL
70039: IFTRUE 70043
70041: GO 70061
70043: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70044: LD_ADDR_VAR 0 3
70048: PUSH
70049: LD_INT 13
70051: PUSH
70052: LD_INT 14
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: ST_TO_ADDR
70059: GO 70456
70061: LD_INT 29
70063: DOUBLE
70064: EQUAL
70065: IFTRUE 70069
70067: GO 70087
70069: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70070: LD_ADDR_VAR 0 3
70074: PUSH
70075: LD_INT 13
70077: PUSH
70078: LD_INT 14
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: ST_TO_ADDR
70085: GO 70456
70087: LD_INT 31
70089: DOUBLE
70090: EQUAL
70091: IFTRUE 70095
70093: GO 70113
70095: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70096: LD_ADDR_VAR 0 3
70100: PUSH
70101: LD_INT 13
70103: PUSH
70104: LD_INT 14
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: ST_TO_ADDR
70111: GO 70456
70113: LD_INT 26
70115: DOUBLE
70116: EQUAL
70117: IFTRUE 70121
70119: GO 70139
70121: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70122: LD_ADDR_VAR 0 3
70126: PUSH
70127: LD_INT 13
70129: PUSH
70130: LD_INT 14
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: ST_TO_ADDR
70137: GO 70456
70139: LD_INT 42
70141: DOUBLE
70142: EQUAL
70143: IFTRUE 70147
70145: GO 70173
70147: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70148: LD_ADDR_VAR 0 3
70152: PUSH
70153: LD_INT 21
70155: PUSH
70156: LD_INT 22
70158: PUSH
70159: LD_INT 23
70161: PUSH
70162: LD_INT 24
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: LIST
70169: LIST
70170: ST_TO_ADDR
70171: GO 70456
70173: LD_INT 43
70175: DOUBLE
70176: EQUAL
70177: IFTRUE 70181
70179: GO 70207
70181: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70182: LD_ADDR_VAR 0 3
70186: PUSH
70187: LD_INT 21
70189: PUSH
70190: LD_INT 22
70192: PUSH
70193: LD_INT 23
70195: PUSH
70196: LD_INT 24
70198: PUSH
70199: EMPTY
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: ST_TO_ADDR
70205: GO 70456
70207: LD_INT 44
70209: DOUBLE
70210: EQUAL
70211: IFTRUE 70215
70213: GO 70241
70215: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70216: LD_ADDR_VAR 0 3
70220: PUSH
70221: LD_INT 21
70223: PUSH
70224: LD_INT 22
70226: PUSH
70227: LD_INT 23
70229: PUSH
70230: LD_INT 24
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: ST_TO_ADDR
70239: GO 70456
70241: LD_INT 45
70243: DOUBLE
70244: EQUAL
70245: IFTRUE 70249
70247: GO 70275
70249: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70250: LD_ADDR_VAR 0 3
70254: PUSH
70255: LD_INT 21
70257: PUSH
70258: LD_INT 22
70260: PUSH
70261: LD_INT 23
70263: PUSH
70264: LD_INT 24
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: ST_TO_ADDR
70273: GO 70456
70275: LD_INT 49
70277: DOUBLE
70278: EQUAL
70279: IFTRUE 70283
70281: GO 70309
70283: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70284: LD_ADDR_VAR 0 3
70288: PUSH
70289: LD_INT 21
70291: PUSH
70292: LD_INT 22
70294: PUSH
70295: LD_INT 23
70297: PUSH
70298: LD_INT 24
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: ST_TO_ADDR
70307: GO 70456
70309: LD_INT 51
70311: DOUBLE
70312: EQUAL
70313: IFTRUE 70317
70315: GO 70343
70317: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70318: LD_ADDR_VAR 0 3
70322: PUSH
70323: LD_INT 21
70325: PUSH
70326: LD_INT 22
70328: PUSH
70329: LD_INT 23
70331: PUSH
70332: LD_INT 24
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: ST_TO_ADDR
70341: GO 70456
70343: LD_INT 52
70345: DOUBLE
70346: EQUAL
70347: IFTRUE 70351
70349: GO 70377
70351: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70352: LD_ADDR_VAR 0 3
70356: PUSH
70357: LD_INT 21
70359: PUSH
70360: LD_INT 22
70362: PUSH
70363: LD_INT 23
70365: PUSH
70366: LD_INT 24
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: LIST
70373: LIST
70374: ST_TO_ADDR
70375: GO 70456
70377: LD_INT 53
70379: DOUBLE
70380: EQUAL
70381: IFTRUE 70385
70383: GO 70403
70385: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70386: LD_ADDR_VAR 0 3
70390: PUSH
70391: LD_INT 23
70393: PUSH
70394: LD_INT 24
70396: PUSH
70397: EMPTY
70398: LIST
70399: LIST
70400: ST_TO_ADDR
70401: GO 70456
70403: LD_INT 46
70405: DOUBLE
70406: EQUAL
70407: IFTRUE 70411
70409: GO 70429
70411: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70412: LD_ADDR_VAR 0 3
70416: PUSH
70417: LD_INT 23
70419: PUSH
70420: LD_INT 24
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: ST_TO_ADDR
70427: GO 70456
70429: LD_INT 47
70431: DOUBLE
70432: EQUAL
70433: IFTRUE 70437
70435: GO 70455
70437: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70438: LD_ADDR_VAR 0 3
70442: PUSH
70443: LD_INT 23
70445: PUSH
70446: LD_INT 24
70448: PUSH
70449: EMPTY
70450: LIST
70451: LIST
70452: ST_TO_ADDR
70453: GO 70456
70455: POP
// result := ( chassis in result ) ;
70456: LD_ADDR_VAR 0 3
70460: PUSH
70461: LD_VAR 0 1
70465: PUSH
70466: LD_VAR 0 3
70470: IN
70471: ST_TO_ADDR
// end ;
70472: LD_VAR 0 3
70476: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70477: LD_INT 0
70479: PPUSH
70480: PPUSH
70481: PPUSH
70482: PPUSH
70483: PPUSH
70484: PPUSH
70485: PPUSH
// result := array ;
70486: LD_ADDR_VAR 0 5
70490: PUSH
70491: LD_VAR 0 1
70495: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70496: LD_VAR 0 1
70500: NOT
70501: PUSH
70502: LD_VAR 0 2
70506: NOT
70507: OR
70508: PUSH
70509: LD_VAR 0 3
70513: NOT
70514: OR
70515: PUSH
70516: LD_VAR 0 2
70520: PUSH
70521: LD_VAR 0 1
70525: GREATER
70526: OR
70527: PUSH
70528: LD_VAR 0 3
70532: PUSH
70533: LD_VAR 0 1
70537: GREATER
70538: OR
70539: IFFALSE 70543
// exit ;
70541: GO 70839
// if direction then
70543: LD_VAR 0 4
70547: IFFALSE 70611
// begin d := 1 ;
70549: LD_ADDR_VAR 0 9
70553: PUSH
70554: LD_INT 1
70556: ST_TO_ADDR
// if i_from > i_to then
70557: LD_VAR 0 2
70561: PUSH
70562: LD_VAR 0 3
70566: GREATER
70567: IFFALSE 70593
// length := ( array - i_from ) + i_to else
70569: LD_ADDR_VAR 0 11
70573: PUSH
70574: LD_VAR 0 1
70578: PUSH
70579: LD_VAR 0 2
70583: MINUS
70584: PUSH
70585: LD_VAR 0 3
70589: PLUS
70590: ST_TO_ADDR
70591: GO 70609
// length := i_to - i_from ;
70593: LD_ADDR_VAR 0 11
70597: PUSH
70598: LD_VAR 0 3
70602: PUSH
70603: LD_VAR 0 2
70607: MINUS
70608: ST_TO_ADDR
// end else
70609: GO 70672
// begin d := - 1 ;
70611: LD_ADDR_VAR 0 9
70615: PUSH
70616: LD_INT 1
70618: NEG
70619: ST_TO_ADDR
// if i_from > i_to then
70620: LD_VAR 0 2
70624: PUSH
70625: LD_VAR 0 3
70629: GREATER
70630: IFFALSE 70650
// length := i_from - i_to else
70632: LD_ADDR_VAR 0 11
70636: PUSH
70637: LD_VAR 0 2
70641: PUSH
70642: LD_VAR 0 3
70646: MINUS
70647: ST_TO_ADDR
70648: GO 70672
// length := ( array - i_to ) + i_from ;
70650: LD_ADDR_VAR 0 11
70654: PUSH
70655: LD_VAR 0 1
70659: PUSH
70660: LD_VAR 0 3
70664: MINUS
70665: PUSH
70666: LD_VAR 0 2
70670: PLUS
70671: ST_TO_ADDR
// end ; if not length then
70672: LD_VAR 0 11
70676: NOT
70677: IFFALSE 70681
// exit ;
70679: GO 70839
// tmp := array ;
70681: LD_ADDR_VAR 0 10
70685: PUSH
70686: LD_VAR 0 1
70690: ST_TO_ADDR
// for i = 1 to length do
70691: LD_ADDR_VAR 0 6
70695: PUSH
70696: DOUBLE
70697: LD_INT 1
70699: DEC
70700: ST_TO_ADDR
70701: LD_VAR 0 11
70705: PUSH
70706: FOR_TO
70707: IFFALSE 70827
// begin for j = 1 to array do
70709: LD_ADDR_VAR 0 7
70713: PUSH
70714: DOUBLE
70715: LD_INT 1
70717: DEC
70718: ST_TO_ADDR
70719: LD_VAR 0 1
70723: PUSH
70724: FOR_TO
70725: IFFALSE 70813
// begin k := j + d ;
70727: LD_ADDR_VAR 0 8
70731: PUSH
70732: LD_VAR 0 7
70736: PUSH
70737: LD_VAR 0 9
70741: PLUS
70742: ST_TO_ADDR
// if k > array then
70743: LD_VAR 0 8
70747: PUSH
70748: LD_VAR 0 1
70752: GREATER
70753: IFFALSE 70763
// k := 1 ;
70755: LD_ADDR_VAR 0 8
70759: PUSH
70760: LD_INT 1
70762: ST_TO_ADDR
// if not k then
70763: LD_VAR 0 8
70767: NOT
70768: IFFALSE 70780
// k := array ;
70770: LD_ADDR_VAR 0 8
70774: PUSH
70775: LD_VAR 0 1
70779: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70780: LD_ADDR_VAR 0 10
70784: PUSH
70785: LD_VAR 0 10
70789: PPUSH
70790: LD_VAR 0 8
70794: PPUSH
70795: LD_VAR 0 1
70799: PUSH
70800: LD_VAR 0 7
70804: ARRAY
70805: PPUSH
70806: CALL_OW 1
70810: ST_TO_ADDR
// end ;
70811: GO 70724
70813: POP
70814: POP
// array := tmp ;
70815: LD_ADDR_VAR 0 1
70819: PUSH
70820: LD_VAR 0 10
70824: ST_TO_ADDR
// end ;
70825: GO 70706
70827: POP
70828: POP
// result := array ;
70829: LD_ADDR_VAR 0 5
70833: PUSH
70834: LD_VAR 0 1
70838: ST_TO_ADDR
// end ;
70839: LD_VAR 0 5
70843: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70844: LD_INT 0
70846: PPUSH
70847: PPUSH
// result := 0 ;
70848: LD_ADDR_VAR 0 3
70852: PUSH
70853: LD_INT 0
70855: ST_TO_ADDR
// if not array or not value in array then
70856: LD_VAR 0 1
70860: NOT
70861: PUSH
70862: LD_VAR 0 2
70866: PUSH
70867: LD_VAR 0 1
70871: IN
70872: NOT
70873: OR
70874: IFFALSE 70878
// exit ;
70876: GO 70932
// for i = 1 to array do
70878: LD_ADDR_VAR 0 4
70882: PUSH
70883: DOUBLE
70884: LD_INT 1
70886: DEC
70887: ST_TO_ADDR
70888: LD_VAR 0 1
70892: PUSH
70893: FOR_TO
70894: IFFALSE 70930
// if value = array [ i ] then
70896: LD_VAR 0 2
70900: PUSH
70901: LD_VAR 0 1
70905: PUSH
70906: LD_VAR 0 4
70910: ARRAY
70911: EQUAL
70912: IFFALSE 70928
// begin result := i ;
70914: LD_ADDR_VAR 0 3
70918: PUSH
70919: LD_VAR 0 4
70923: ST_TO_ADDR
// exit ;
70924: POP
70925: POP
70926: GO 70932
// end ;
70928: GO 70893
70930: POP
70931: POP
// end ;
70932: LD_VAR 0 3
70936: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70937: LD_INT 0
70939: PPUSH
// vc_chassis := chassis ;
70940: LD_ADDR_OWVAR 37
70944: PUSH
70945: LD_VAR 0 1
70949: ST_TO_ADDR
// vc_engine := engine ;
70950: LD_ADDR_OWVAR 39
70954: PUSH
70955: LD_VAR 0 2
70959: ST_TO_ADDR
// vc_control := control ;
70960: LD_ADDR_OWVAR 38
70964: PUSH
70965: LD_VAR 0 3
70969: ST_TO_ADDR
// vc_weapon := weapon ;
70970: LD_ADDR_OWVAR 40
70974: PUSH
70975: LD_VAR 0 4
70979: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70980: LD_ADDR_OWVAR 41
70984: PUSH
70985: LD_VAR 0 5
70989: ST_TO_ADDR
// end ;
70990: LD_VAR 0 6
70994: RET
// export function WantPlant ( unit ) ; var task ; begin
70995: LD_INT 0
70997: PPUSH
70998: PPUSH
// result := false ;
70999: LD_ADDR_VAR 0 2
71003: PUSH
71004: LD_INT 0
71006: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71007: LD_ADDR_VAR 0 3
71011: PUSH
71012: LD_VAR 0 1
71016: PPUSH
71017: CALL_OW 437
71021: ST_TO_ADDR
// if task then
71022: LD_VAR 0 3
71026: IFFALSE 71054
// if task [ 1 ] [ 1 ] = p then
71028: LD_VAR 0 3
71032: PUSH
71033: LD_INT 1
71035: ARRAY
71036: PUSH
71037: LD_INT 1
71039: ARRAY
71040: PUSH
71041: LD_STRING p
71043: EQUAL
71044: IFFALSE 71054
// result := true ;
71046: LD_ADDR_VAR 0 2
71050: PUSH
71051: LD_INT 1
71053: ST_TO_ADDR
// end ;
71054: LD_VAR 0 2
71058: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71059: LD_INT 0
71061: PPUSH
71062: PPUSH
71063: PPUSH
71064: PPUSH
// if pos < 1 then
71065: LD_VAR 0 2
71069: PUSH
71070: LD_INT 1
71072: LESS
71073: IFFALSE 71077
// exit ;
71075: GO 71380
// if pos = 1 then
71077: LD_VAR 0 2
71081: PUSH
71082: LD_INT 1
71084: EQUAL
71085: IFFALSE 71118
// result := Replace ( arr , pos [ 1 ] , value ) else
71087: LD_ADDR_VAR 0 4
71091: PUSH
71092: LD_VAR 0 1
71096: PPUSH
71097: LD_VAR 0 2
71101: PUSH
71102: LD_INT 1
71104: ARRAY
71105: PPUSH
71106: LD_VAR 0 3
71110: PPUSH
71111: CALL_OW 1
71115: ST_TO_ADDR
71116: GO 71380
// begin tmp := arr ;
71118: LD_ADDR_VAR 0 6
71122: PUSH
71123: LD_VAR 0 1
71127: ST_TO_ADDR
// s_arr := [ tmp ] ;
71128: LD_ADDR_VAR 0 7
71132: PUSH
71133: LD_VAR 0 6
71137: PUSH
71138: EMPTY
71139: LIST
71140: ST_TO_ADDR
// for i = 1 to pos - 1 do
71141: LD_ADDR_VAR 0 5
71145: PUSH
71146: DOUBLE
71147: LD_INT 1
71149: DEC
71150: ST_TO_ADDR
71151: LD_VAR 0 2
71155: PUSH
71156: LD_INT 1
71158: MINUS
71159: PUSH
71160: FOR_TO
71161: IFFALSE 71206
// begin tmp := tmp [ pos [ i ] ] ;
71163: LD_ADDR_VAR 0 6
71167: PUSH
71168: LD_VAR 0 6
71172: PUSH
71173: LD_VAR 0 2
71177: PUSH
71178: LD_VAR 0 5
71182: ARRAY
71183: ARRAY
71184: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71185: LD_ADDR_VAR 0 7
71189: PUSH
71190: LD_VAR 0 7
71194: PUSH
71195: LD_VAR 0 6
71199: PUSH
71200: EMPTY
71201: LIST
71202: ADD
71203: ST_TO_ADDR
// end ;
71204: GO 71160
71206: POP
71207: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71208: LD_ADDR_VAR 0 6
71212: PUSH
71213: LD_VAR 0 6
71217: PPUSH
71218: LD_VAR 0 2
71222: PUSH
71223: LD_VAR 0 2
71227: ARRAY
71228: PPUSH
71229: LD_VAR 0 3
71233: PPUSH
71234: CALL_OW 1
71238: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71239: LD_ADDR_VAR 0 7
71243: PUSH
71244: LD_VAR 0 7
71248: PPUSH
71249: LD_VAR 0 7
71253: PPUSH
71254: LD_VAR 0 6
71258: PPUSH
71259: CALL_OW 1
71263: ST_TO_ADDR
// for i = s_arr downto 2 do
71264: LD_ADDR_VAR 0 5
71268: PUSH
71269: DOUBLE
71270: LD_VAR 0 7
71274: INC
71275: ST_TO_ADDR
71276: LD_INT 2
71278: PUSH
71279: FOR_DOWNTO
71280: IFFALSE 71364
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71282: LD_ADDR_VAR 0 6
71286: PUSH
71287: LD_VAR 0 7
71291: PUSH
71292: LD_VAR 0 5
71296: PUSH
71297: LD_INT 1
71299: MINUS
71300: ARRAY
71301: PPUSH
71302: LD_VAR 0 2
71306: PUSH
71307: LD_VAR 0 5
71311: PUSH
71312: LD_INT 1
71314: MINUS
71315: ARRAY
71316: PPUSH
71317: LD_VAR 0 7
71321: PUSH
71322: LD_VAR 0 5
71326: ARRAY
71327: PPUSH
71328: CALL_OW 1
71332: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71333: LD_ADDR_VAR 0 7
71337: PUSH
71338: LD_VAR 0 7
71342: PPUSH
71343: LD_VAR 0 5
71347: PUSH
71348: LD_INT 1
71350: MINUS
71351: PPUSH
71352: LD_VAR 0 6
71356: PPUSH
71357: CALL_OW 1
71361: ST_TO_ADDR
// end ;
71362: GO 71279
71364: POP
71365: POP
// result := s_arr [ 1 ] ;
71366: LD_ADDR_VAR 0 4
71370: PUSH
71371: LD_VAR 0 7
71375: PUSH
71376: LD_INT 1
71378: ARRAY
71379: ST_TO_ADDR
// end ; end ;
71380: LD_VAR 0 4
71384: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71385: LD_INT 0
71387: PPUSH
71388: PPUSH
// if not list then
71389: LD_VAR 0 1
71393: NOT
71394: IFFALSE 71398
// exit ;
71396: GO 71489
// i := list [ pos1 ] ;
71398: LD_ADDR_VAR 0 5
71402: PUSH
71403: LD_VAR 0 1
71407: PUSH
71408: LD_VAR 0 2
71412: ARRAY
71413: ST_TO_ADDR
// if not i then
71414: LD_VAR 0 5
71418: NOT
71419: IFFALSE 71423
// exit ;
71421: GO 71489
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71423: LD_ADDR_VAR 0 1
71427: PUSH
71428: LD_VAR 0 1
71432: PPUSH
71433: LD_VAR 0 2
71437: PPUSH
71438: LD_VAR 0 1
71442: PUSH
71443: LD_VAR 0 3
71447: ARRAY
71448: PPUSH
71449: CALL_OW 1
71453: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71454: LD_ADDR_VAR 0 1
71458: PUSH
71459: LD_VAR 0 1
71463: PPUSH
71464: LD_VAR 0 3
71468: PPUSH
71469: LD_VAR 0 5
71473: PPUSH
71474: CALL_OW 1
71478: ST_TO_ADDR
// result := list ;
71479: LD_ADDR_VAR 0 4
71483: PUSH
71484: LD_VAR 0 1
71488: ST_TO_ADDR
// end ;
71489: LD_VAR 0 4
71493: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71494: LD_INT 0
71496: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71497: LD_ADDR_VAR 0 5
71501: PUSH
71502: LD_VAR 0 1
71506: PPUSH
71507: CALL_OW 250
71511: PPUSH
71512: LD_VAR 0 1
71516: PPUSH
71517: CALL_OW 251
71521: PPUSH
71522: LD_VAR 0 2
71526: PPUSH
71527: LD_VAR 0 3
71531: PPUSH
71532: LD_VAR 0 4
71536: PPUSH
71537: CALL 71547 0 5
71541: ST_TO_ADDR
// end ;
71542: LD_VAR 0 5
71546: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71547: LD_INT 0
71549: PPUSH
71550: PPUSH
71551: PPUSH
71552: PPUSH
// if not list then
71553: LD_VAR 0 3
71557: NOT
71558: IFFALSE 71562
// exit ;
71560: GO 71950
// result := [ ] ;
71562: LD_ADDR_VAR 0 6
71566: PUSH
71567: EMPTY
71568: ST_TO_ADDR
// for i in list do
71569: LD_ADDR_VAR 0 7
71573: PUSH
71574: LD_VAR 0 3
71578: PUSH
71579: FOR_IN
71580: IFFALSE 71782
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71582: LD_ADDR_VAR 0 9
71586: PUSH
71587: LD_VAR 0 7
71591: PPUSH
71592: LD_VAR 0 1
71596: PPUSH
71597: LD_VAR 0 2
71601: PPUSH
71602: CALL_OW 297
71606: ST_TO_ADDR
// if not result then
71607: LD_VAR 0 6
71611: NOT
71612: IFFALSE 71638
// result := [ [ i , tmp ] ] else
71614: LD_ADDR_VAR 0 6
71618: PUSH
71619: LD_VAR 0 7
71623: PUSH
71624: LD_VAR 0 9
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: PUSH
71633: EMPTY
71634: LIST
71635: ST_TO_ADDR
71636: GO 71780
// begin if result [ result ] [ 2 ] < tmp then
71638: LD_VAR 0 6
71642: PUSH
71643: LD_VAR 0 6
71647: ARRAY
71648: PUSH
71649: LD_INT 2
71651: ARRAY
71652: PUSH
71653: LD_VAR 0 9
71657: LESS
71658: IFFALSE 71700
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71660: LD_ADDR_VAR 0 6
71664: PUSH
71665: LD_VAR 0 6
71669: PPUSH
71670: LD_VAR 0 6
71674: PUSH
71675: LD_INT 1
71677: PLUS
71678: PPUSH
71679: LD_VAR 0 7
71683: PUSH
71684: LD_VAR 0 9
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PPUSH
71693: CALL_OW 2
71697: ST_TO_ADDR
71698: GO 71780
// for j = 1 to result do
71700: LD_ADDR_VAR 0 8
71704: PUSH
71705: DOUBLE
71706: LD_INT 1
71708: DEC
71709: ST_TO_ADDR
71710: LD_VAR 0 6
71714: PUSH
71715: FOR_TO
71716: IFFALSE 71778
// begin if tmp < result [ j ] [ 2 ] then
71718: LD_VAR 0 9
71722: PUSH
71723: LD_VAR 0 6
71727: PUSH
71728: LD_VAR 0 8
71732: ARRAY
71733: PUSH
71734: LD_INT 2
71736: ARRAY
71737: LESS
71738: IFFALSE 71776
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71740: LD_ADDR_VAR 0 6
71744: PUSH
71745: LD_VAR 0 6
71749: PPUSH
71750: LD_VAR 0 8
71754: PPUSH
71755: LD_VAR 0 7
71759: PUSH
71760: LD_VAR 0 9
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PPUSH
71769: CALL_OW 2
71773: ST_TO_ADDR
// break ;
71774: GO 71778
// end ; end ;
71776: GO 71715
71778: POP
71779: POP
// end ; end ;
71780: GO 71579
71782: POP
71783: POP
// if result and not asc then
71784: LD_VAR 0 6
71788: PUSH
71789: LD_VAR 0 4
71793: NOT
71794: AND
71795: IFFALSE 71870
// begin tmp := result ;
71797: LD_ADDR_VAR 0 9
71801: PUSH
71802: LD_VAR 0 6
71806: ST_TO_ADDR
// for i = tmp downto 1 do
71807: LD_ADDR_VAR 0 7
71811: PUSH
71812: DOUBLE
71813: LD_VAR 0 9
71817: INC
71818: ST_TO_ADDR
71819: LD_INT 1
71821: PUSH
71822: FOR_DOWNTO
71823: IFFALSE 71868
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71825: LD_ADDR_VAR 0 6
71829: PUSH
71830: LD_VAR 0 6
71834: PPUSH
71835: LD_VAR 0 9
71839: PUSH
71840: LD_VAR 0 7
71844: MINUS
71845: PUSH
71846: LD_INT 1
71848: PLUS
71849: PPUSH
71850: LD_VAR 0 9
71854: PUSH
71855: LD_VAR 0 7
71859: ARRAY
71860: PPUSH
71861: CALL_OW 1
71865: ST_TO_ADDR
71866: GO 71822
71868: POP
71869: POP
// end ; tmp := [ ] ;
71870: LD_ADDR_VAR 0 9
71874: PUSH
71875: EMPTY
71876: ST_TO_ADDR
// if mode then
71877: LD_VAR 0 5
71881: IFFALSE 71950
// begin for i = 1 to result do
71883: LD_ADDR_VAR 0 7
71887: PUSH
71888: DOUBLE
71889: LD_INT 1
71891: DEC
71892: ST_TO_ADDR
71893: LD_VAR 0 6
71897: PUSH
71898: FOR_TO
71899: IFFALSE 71938
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71901: LD_ADDR_VAR 0 9
71905: PUSH
71906: LD_VAR 0 9
71910: PPUSH
71911: LD_VAR 0 7
71915: PPUSH
71916: LD_VAR 0 6
71920: PUSH
71921: LD_VAR 0 7
71925: ARRAY
71926: PUSH
71927: LD_INT 1
71929: ARRAY
71930: PPUSH
71931: CALL_OW 1
71935: ST_TO_ADDR
71936: GO 71898
71938: POP
71939: POP
// result := tmp ;
71940: LD_ADDR_VAR 0 6
71944: PUSH
71945: LD_VAR 0 9
71949: ST_TO_ADDR
// end ; end ;
71950: LD_VAR 0 6
71954: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71955: LD_INT 0
71957: PPUSH
71958: PPUSH
71959: PPUSH
71960: PPUSH
71961: PPUSH
71962: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71963: LD_ADDR_VAR 0 5
71967: PUSH
71968: LD_INT 0
71970: PUSH
71971: LD_INT 0
71973: PUSH
71974: LD_INT 0
71976: PUSH
71977: EMPTY
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: ST_TO_ADDR
// if not x or not y then
71985: LD_VAR 0 2
71989: NOT
71990: PUSH
71991: LD_VAR 0 3
71995: NOT
71996: OR
71997: IFFALSE 72001
// exit ;
71999: GO 73653
// if not range then
72001: LD_VAR 0 4
72005: NOT
72006: IFFALSE 72016
// range := 10 ;
72008: LD_ADDR_VAR 0 4
72012: PUSH
72013: LD_INT 10
72015: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72016: LD_ADDR_VAR 0 8
72020: PUSH
72021: LD_INT 81
72023: PUSH
72024: LD_VAR 0 1
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 92
72035: PUSH
72036: LD_VAR 0 2
72040: PUSH
72041: LD_VAR 0 3
72045: PUSH
72046: LD_VAR 0 4
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 3
72059: PUSH
72060: LD_INT 21
72062: PUSH
72063: LD_INT 3
72065: PUSH
72066: EMPTY
72067: LIST
72068: LIST
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: LIST
72078: PPUSH
72079: CALL_OW 69
72083: ST_TO_ADDR
// if not tmp then
72084: LD_VAR 0 8
72088: NOT
72089: IFFALSE 72093
// exit ;
72091: GO 73653
// for i in tmp do
72093: LD_ADDR_VAR 0 6
72097: PUSH
72098: LD_VAR 0 8
72102: PUSH
72103: FOR_IN
72104: IFFALSE 73628
// begin points := [ 0 , 0 , 0 ] ;
72106: LD_ADDR_VAR 0 9
72110: PUSH
72111: LD_INT 0
72113: PUSH
72114: LD_INT 0
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: EMPTY
72121: LIST
72122: LIST
72123: LIST
72124: ST_TO_ADDR
// bpoints := 1 ;
72125: LD_ADDR_VAR 0 10
72129: PUSH
72130: LD_INT 1
72132: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72133: LD_VAR 0 6
72137: PPUSH
72138: CALL_OW 247
72142: PUSH
72143: LD_INT 1
72145: DOUBLE
72146: EQUAL
72147: IFTRUE 72151
72149: GO 72729
72151: POP
// begin if GetClass ( i ) = 1 then
72152: LD_VAR 0 6
72156: PPUSH
72157: CALL_OW 257
72161: PUSH
72162: LD_INT 1
72164: EQUAL
72165: IFFALSE 72186
// points := [ 10 , 5 , 3 ] ;
72167: LD_ADDR_VAR 0 9
72171: PUSH
72172: LD_INT 10
72174: PUSH
72175: LD_INT 5
72177: PUSH
72178: LD_INT 3
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: LIST
72185: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72186: LD_VAR 0 6
72190: PPUSH
72191: CALL_OW 257
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: LD_INT 3
72201: PUSH
72202: LD_INT 4
72204: PUSH
72205: EMPTY
72206: LIST
72207: LIST
72208: LIST
72209: IN
72210: IFFALSE 72231
// points := [ 3 , 2 , 1 ] ;
72212: LD_ADDR_VAR 0 9
72216: PUSH
72217: LD_INT 3
72219: PUSH
72220: LD_INT 2
72222: PUSH
72223: LD_INT 1
72225: PUSH
72226: EMPTY
72227: LIST
72228: LIST
72229: LIST
72230: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72231: LD_VAR 0 6
72235: PPUSH
72236: CALL_OW 257
72240: PUSH
72241: LD_INT 5
72243: EQUAL
72244: IFFALSE 72265
// points := [ 130 , 5 , 2 ] ;
72246: LD_ADDR_VAR 0 9
72250: PUSH
72251: LD_INT 130
72253: PUSH
72254: LD_INT 5
72256: PUSH
72257: LD_INT 2
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: LIST
72264: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72265: LD_VAR 0 6
72269: PPUSH
72270: CALL_OW 257
72274: PUSH
72275: LD_INT 8
72277: EQUAL
72278: IFFALSE 72299
// points := [ 35 , 35 , 30 ] ;
72280: LD_ADDR_VAR 0 9
72284: PUSH
72285: LD_INT 35
72287: PUSH
72288: LD_INT 35
72290: PUSH
72291: LD_INT 30
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: LIST
72298: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72299: LD_VAR 0 6
72303: PPUSH
72304: CALL_OW 257
72308: PUSH
72309: LD_INT 9
72311: EQUAL
72312: IFFALSE 72333
// points := [ 20 , 55 , 40 ] ;
72314: LD_ADDR_VAR 0 9
72318: PUSH
72319: LD_INT 20
72321: PUSH
72322: LD_INT 55
72324: PUSH
72325: LD_INT 40
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: LIST
72332: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72333: LD_VAR 0 6
72337: PPUSH
72338: CALL_OW 257
72342: PUSH
72343: LD_INT 12
72345: PUSH
72346: LD_INT 16
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: IN
72353: IFFALSE 72374
// points := [ 5 , 3 , 2 ] ;
72355: LD_ADDR_VAR 0 9
72359: PUSH
72360: LD_INT 5
72362: PUSH
72363: LD_INT 3
72365: PUSH
72366: LD_INT 2
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: LIST
72373: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72374: LD_VAR 0 6
72378: PPUSH
72379: CALL_OW 257
72383: PUSH
72384: LD_INT 17
72386: EQUAL
72387: IFFALSE 72408
// points := [ 100 , 50 , 75 ] ;
72389: LD_ADDR_VAR 0 9
72393: PUSH
72394: LD_INT 100
72396: PUSH
72397: LD_INT 50
72399: PUSH
72400: LD_INT 75
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: LIST
72407: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72408: LD_VAR 0 6
72412: PPUSH
72413: CALL_OW 257
72417: PUSH
72418: LD_INT 15
72420: EQUAL
72421: IFFALSE 72442
// points := [ 10 , 5 , 3 ] ;
72423: LD_ADDR_VAR 0 9
72427: PUSH
72428: LD_INT 10
72430: PUSH
72431: LD_INT 5
72433: PUSH
72434: LD_INT 3
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72442: LD_VAR 0 6
72446: PPUSH
72447: CALL_OW 257
72451: PUSH
72452: LD_INT 14
72454: EQUAL
72455: IFFALSE 72476
// points := [ 10 , 0 , 0 ] ;
72457: LD_ADDR_VAR 0 9
72461: PUSH
72462: LD_INT 10
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: LD_INT 0
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: LIST
72475: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72476: LD_VAR 0 6
72480: PPUSH
72481: CALL_OW 257
72485: PUSH
72486: LD_INT 11
72488: EQUAL
72489: IFFALSE 72510
// points := [ 30 , 10 , 5 ] ;
72491: LD_ADDR_VAR 0 9
72495: PUSH
72496: LD_INT 30
72498: PUSH
72499: LD_INT 10
72501: PUSH
72502: LD_INT 5
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: LIST
72509: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72510: LD_VAR 0 1
72514: PPUSH
72515: LD_INT 5
72517: PPUSH
72518: CALL_OW 321
72522: PUSH
72523: LD_INT 2
72525: EQUAL
72526: IFFALSE 72543
// bpoints := bpoints * 1.8 ;
72528: LD_ADDR_VAR 0 10
72532: PUSH
72533: LD_VAR 0 10
72537: PUSH
72538: LD_REAL  1.80000000000000E+0000
72541: MUL
72542: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72543: LD_VAR 0 6
72547: PPUSH
72548: CALL_OW 257
72552: PUSH
72553: LD_INT 1
72555: PUSH
72556: LD_INT 2
72558: PUSH
72559: LD_INT 3
72561: PUSH
72562: LD_INT 4
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: IN
72571: PUSH
72572: LD_VAR 0 1
72576: PPUSH
72577: LD_INT 51
72579: PPUSH
72580: CALL_OW 321
72584: PUSH
72585: LD_INT 2
72587: EQUAL
72588: AND
72589: IFFALSE 72606
// bpoints := bpoints * 1.2 ;
72591: LD_ADDR_VAR 0 10
72595: PUSH
72596: LD_VAR 0 10
72600: PUSH
72601: LD_REAL  1.20000000000000E+0000
72604: MUL
72605: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72606: LD_VAR 0 6
72610: PPUSH
72611: CALL_OW 257
72615: PUSH
72616: LD_INT 5
72618: PUSH
72619: LD_INT 7
72621: PUSH
72622: LD_INT 9
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: LIST
72629: IN
72630: PUSH
72631: LD_VAR 0 1
72635: PPUSH
72636: LD_INT 52
72638: PPUSH
72639: CALL_OW 321
72643: PUSH
72644: LD_INT 2
72646: EQUAL
72647: AND
72648: IFFALSE 72665
// bpoints := bpoints * 1.5 ;
72650: LD_ADDR_VAR 0 10
72654: PUSH
72655: LD_VAR 0 10
72659: PUSH
72660: LD_REAL  1.50000000000000E+0000
72663: MUL
72664: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72665: LD_VAR 0 1
72669: PPUSH
72670: LD_INT 66
72672: PPUSH
72673: CALL_OW 321
72677: PUSH
72678: LD_INT 2
72680: EQUAL
72681: IFFALSE 72698
// bpoints := bpoints * 1.1 ;
72683: LD_ADDR_VAR 0 10
72687: PUSH
72688: LD_VAR 0 10
72692: PUSH
72693: LD_REAL  1.10000000000000E+0000
72696: MUL
72697: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72698: LD_ADDR_VAR 0 10
72702: PUSH
72703: LD_VAR 0 10
72707: PUSH
72708: LD_VAR 0 6
72712: PPUSH
72713: LD_INT 1
72715: PPUSH
72716: CALL_OW 259
72720: PUSH
72721: LD_REAL  1.15000000000000E+0000
72724: MUL
72725: MUL
72726: ST_TO_ADDR
// end ; unit_vehicle :
72727: GO 73557
72729: LD_INT 2
72731: DOUBLE
72732: EQUAL
72733: IFTRUE 72737
72735: GO 73545
72737: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72738: LD_VAR 0 6
72742: PPUSH
72743: CALL_OW 264
72747: PUSH
72748: LD_INT 2
72750: PUSH
72751: LD_INT 42
72753: PUSH
72754: LD_INT 24
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: LIST
72761: IN
72762: IFFALSE 72783
// points := [ 25 , 5 , 3 ] ;
72764: LD_ADDR_VAR 0 9
72768: PUSH
72769: LD_INT 25
72771: PUSH
72772: LD_INT 5
72774: PUSH
72775: LD_INT 3
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: LIST
72782: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72783: LD_VAR 0 6
72787: PPUSH
72788: CALL_OW 264
72792: PUSH
72793: LD_INT 4
72795: PUSH
72796: LD_INT 43
72798: PUSH
72799: LD_INT 25
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: LIST
72806: IN
72807: IFFALSE 72828
// points := [ 40 , 15 , 5 ] ;
72809: LD_ADDR_VAR 0 9
72813: PUSH
72814: LD_INT 40
72816: PUSH
72817: LD_INT 15
72819: PUSH
72820: LD_INT 5
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: LIST
72827: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72828: LD_VAR 0 6
72832: PPUSH
72833: CALL_OW 264
72837: PUSH
72838: LD_INT 3
72840: PUSH
72841: LD_INT 23
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: IN
72848: IFFALSE 72869
// points := [ 7 , 25 , 8 ] ;
72850: LD_ADDR_VAR 0 9
72854: PUSH
72855: LD_INT 7
72857: PUSH
72858: LD_INT 25
72860: PUSH
72861: LD_INT 8
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: LIST
72868: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72869: LD_VAR 0 6
72873: PPUSH
72874: CALL_OW 264
72878: PUSH
72879: LD_INT 5
72881: PUSH
72882: LD_INT 27
72884: PUSH
72885: LD_INT 44
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: LIST
72892: IN
72893: IFFALSE 72914
// points := [ 14 , 50 , 16 ] ;
72895: LD_ADDR_VAR 0 9
72899: PUSH
72900: LD_INT 14
72902: PUSH
72903: LD_INT 50
72905: PUSH
72906: LD_INT 16
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: LIST
72913: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72914: LD_VAR 0 6
72918: PPUSH
72919: CALL_OW 264
72923: PUSH
72924: LD_INT 6
72926: PUSH
72927: LD_INT 46
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: IN
72934: IFFALSE 72955
// points := [ 32 , 120 , 70 ] ;
72936: LD_ADDR_VAR 0 9
72940: PUSH
72941: LD_INT 32
72943: PUSH
72944: LD_INT 120
72946: PUSH
72947: LD_INT 70
72949: PUSH
72950: EMPTY
72951: LIST
72952: LIST
72953: LIST
72954: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72955: LD_VAR 0 6
72959: PPUSH
72960: CALL_OW 264
72964: PUSH
72965: LD_INT 7
72967: PUSH
72968: LD_INT 28
72970: PUSH
72971: LD_INT 45
72973: PUSH
72974: LD_EXP 100
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: LIST
72983: LIST
72984: IN
72985: IFFALSE 73006
// points := [ 35 , 20 , 45 ] ;
72987: LD_ADDR_VAR 0 9
72991: PUSH
72992: LD_INT 35
72994: PUSH
72995: LD_INT 20
72997: PUSH
72998: LD_INT 45
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: LIST
73005: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73006: LD_VAR 0 6
73010: PPUSH
73011: CALL_OW 264
73015: PUSH
73016: LD_INT 47
73018: PUSH
73019: EMPTY
73020: LIST
73021: IN
73022: IFFALSE 73043
// points := [ 67 , 45 , 75 ] ;
73024: LD_ADDR_VAR 0 9
73028: PUSH
73029: LD_INT 67
73031: PUSH
73032: LD_INT 45
73034: PUSH
73035: LD_INT 75
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: LIST
73042: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73043: LD_VAR 0 6
73047: PPUSH
73048: CALL_OW 264
73052: PUSH
73053: LD_INT 26
73055: PUSH
73056: EMPTY
73057: LIST
73058: IN
73059: IFFALSE 73080
// points := [ 120 , 30 , 80 ] ;
73061: LD_ADDR_VAR 0 9
73065: PUSH
73066: LD_INT 120
73068: PUSH
73069: LD_INT 30
73071: PUSH
73072: LD_INT 80
73074: PUSH
73075: EMPTY
73076: LIST
73077: LIST
73078: LIST
73079: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73080: LD_VAR 0 6
73084: PPUSH
73085: CALL_OW 264
73089: PUSH
73090: LD_INT 22
73092: PUSH
73093: EMPTY
73094: LIST
73095: IN
73096: IFFALSE 73117
// points := [ 40 , 1 , 1 ] ;
73098: LD_ADDR_VAR 0 9
73102: PUSH
73103: LD_INT 40
73105: PUSH
73106: LD_INT 1
73108: PUSH
73109: LD_INT 1
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: LIST
73116: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73117: LD_VAR 0 6
73121: PPUSH
73122: CALL_OW 264
73126: PUSH
73127: LD_INT 29
73129: PUSH
73130: EMPTY
73131: LIST
73132: IN
73133: IFFALSE 73154
// points := [ 70 , 200 , 400 ] ;
73135: LD_ADDR_VAR 0 9
73139: PUSH
73140: LD_INT 70
73142: PUSH
73143: LD_INT 200
73145: PUSH
73146: LD_INT 400
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: LIST
73153: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73154: LD_VAR 0 6
73158: PPUSH
73159: CALL_OW 264
73163: PUSH
73164: LD_INT 14
73166: PUSH
73167: LD_INT 53
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: IN
73174: IFFALSE 73195
// points := [ 40 , 10 , 20 ] ;
73176: LD_ADDR_VAR 0 9
73180: PUSH
73181: LD_INT 40
73183: PUSH
73184: LD_INT 10
73186: PUSH
73187: LD_INT 20
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: LIST
73194: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73195: LD_VAR 0 6
73199: PPUSH
73200: CALL_OW 264
73204: PUSH
73205: LD_INT 9
73207: PUSH
73208: EMPTY
73209: LIST
73210: IN
73211: IFFALSE 73232
// points := [ 5 , 70 , 20 ] ;
73213: LD_ADDR_VAR 0 9
73217: PUSH
73218: LD_INT 5
73220: PUSH
73221: LD_INT 70
73223: PUSH
73224: LD_INT 20
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: LIST
73231: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73232: LD_VAR 0 6
73236: PPUSH
73237: CALL_OW 264
73241: PUSH
73242: LD_INT 10
73244: PUSH
73245: EMPTY
73246: LIST
73247: IN
73248: IFFALSE 73269
// points := [ 35 , 110 , 70 ] ;
73250: LD_ADDR_VAR 0 9
73254: PUSH
73255: LD_INT 35
73257: PUSH
73258: LD_INT 110
73260: PUSH
73261: LD_INT 70
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: LIST
73268: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73269: LD_VAR 0 6
73273: PPUSH
73274: CALL_OW 265
73278: PUSH
73279: LD_INT 25
73281: EQUAL
73282: IFFALSE 73303
// points := [ 80 , 65 , 100 ] ;
73284: LD_ADDR_VAR 0 9
73288: PUSH
73289: LD_INT 80
73291: PUSH
73292: LD_INT 65
73294: PUSH
73295: LD_INT 100
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: LIST
73302: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73303: LD_VAR 0 6
73307: PPUSH
73308: CALL_OW 263
73312: PUSH
73313: LD_INT 1
73315: EQUAL
73316: IFFALSE 73351
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73318: LD_ADDR_VAR 0 10
73322: PUSH
73323: LD_VAR 0 10
73327: PUSH
73328: LD_VAR 0 6
73332: PPUSH
73333: CALL_OW 311
73337: PPUSH
73338: LD_INT 3
73340: PPUSH
73341: CALL_OW 259
73345: PUSH
73346: LD_INT 4
73348: MUL
73349: MUL
73350: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73351: LD_VAR 0 6
73355: PPUSH
73356: CALL_OW 263
73360: PUSH
73361: LD_INT 2
73363: EQUAL
73364: IFFALSE 73415
// begin j := IsControledBy ( i ) ;
73366: LD_ADDR_VAR 0 7
73370: PUSH
73371: LD_VAR 0 6
73375: PPUSH
73376: CALL_OW 312
73380: ST_TO_ADDR
// if j then
73381: LD_VAR 0 7
73385: IFFALSE 73415
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73387: LD_ADDR_VAR 0 10
73391: PUSH
73392: LD_VAR 0 10
73396: PUSH
73397: LD_VAR 0 7
73401: PPUSH
73402: LD_INT 3
73404: PPUSH
73405: CALL_OW 259
73409: PUSH
73410: LD_INT 3
73412: MUL
73413: MUL
73414: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73415: LD_VAR 0 6
73419: PPUSH
73420: CALL_OW 264
73424: PUSH
73425: LD_INT 5
73427: PUSH
73428: LD_INT 6
73430: PUSH
73431: LD_INT 46
73433: PUSH
73434: LD_INT 44
73436: PUSH
73437: LD_INT 47
73439: PUSH
73440: LD_INT 45
73442: PUSH
73443: LD_INT 28
73445: PUSH
73446: LD_INT 7
73448: PUSH
73449: LD_INT 27
73451: PUSH
73452: LD_INT 29
73454: PUSH
73455: EMPTY
73456: LIST
73457: LIST
73458: LIST
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: IN
73467: PUSH
73468: LD_VAR 0 1
73472: PPUSH
73473: LD_INT 52
73475: PPUSH
73476: CALL_OW 321
73480: PUSH
73481: LD_INT 2
73483: EQUAL
73484: AND
73485: IFFALSE 73502
// bpoints := bpoints * 1.2 ;
73487: LD_ADDR_VAR 0 10
73491: PUSH
73492: LD_VAR 0 10
73496: PUSH
73497: LD_REAL  1.20000000000000E+0000
73500: MUL
73501: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73502: LD_VAR 0 6
73506: PPUSH
73507: CALL_OW 264
73511: PUSH
73512: LD_INT 6
73514: PUSH
73515: LD_INT 46
73517: PUSH
73518: LD_INT 47
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: LIST
73525: IN
73526: IFFALSE 73543
// bpoints := bpoints * 1.2 ;
73528: LD_ADDR_VAR 0 10
73532: PUSH
73533: LD_VAR 0 10
73537: PUSH
73538: LD_REAL  1.20000000000000E+0000
73541: MUL
73542: ST_TO_ADDR
// end ; unit_building :
73543: GO 73557
73545: LD_INT 3
73547: DOUBLE
73548: EQUAL
73549: IFTRUE 73553
73551: GO 73556
73553: POP
// ; end ;
73554: GO 73557
73556: POP
// for j = 1 to 3 do
73557: LD_ADDR_VAR 0 7
73561: PUSH
73562: DOUBLE
73563: LD_INT 1
73565: DEC
73566: ST_TO_ADDR
73567: LD_INT 3
73569: PUSH
73570: FOR_TO
73571: IFFALSE 73624
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73573: LD_ADDR_VAR 0 5
73577: PUSH
73578: LD_VAR 0 5
73582: PPUSH
73583: LD_VAR 0 7
73587: PPUSH
73588: LD_VAR 0 5
73592: PUSH
73593: LD_VAR 0 7
73597: ARRAY
73598: PUSH
73599: LD_VAR 0 9
73603: PUSH
73604: LD_VAR 0 7
73608: ARRAY
73609: PUSH
73610: LD_VAR 0 10
73614: MUL
73615: PLUS
73616: PPUSH
73617: CALL_OW 1
73621: ST_TO_ADDR
73622: GO 73570
73624: POP
73625: POP
// end ;
73626: GO 72103
73628: POP
73629: POP
// result := Replace ( result , 4 , tmp ) ;
73630: LD_ADDR_VAR 0 5
73634: PUSH
73635: LD_VAR 0 5
73639: PPUSH
73640: LD_INT 4
73642: PPUSH
73643: LD_VAR 0 8
73647: PPUSH
73648: CALL_OW 1
73652: ST_TO_ADDR
// end ;
73653: LD_VAR 0 5
73657: RET
// export function DangerAtRange ( unit , range ) ; begin
73658: LD_INT 0
73660: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73661: LD_ADDR_VAR 0 3
73665: PUSH
73666: LD_VAR 0 1
73670: PPUSH
73671: CALL_OW 255
73675: PPUSH
73676: LD_VAR 0 1
73680: PPUSH
73681: CALL_OW 250
73685: PPUSH
73686: LD_VAR 0 1
73690: PPUSH
73691: CALL_OW 251
73695: PPUSH
73696: LD_VAR 0 2
73700: PPUSH
73701: CALL 71955 0 4
73705: ST_TO_ADDR
// end ;
73706: LD_VAR 0 3
73710: RET
// export function DangerInArea ( side , area ) ; begin
73711: LD_INT 0
73713: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73714: LD_ADDR_VAR 0 3
73718: PUSH
73719: LD_VAR 0 2
73723: PPUSH
73724: LD_INT 81
73726: PUSH
73727: LD_VAR 0 1
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PPUSH
73736: CALL_OW 70
73740: ST_TO_ADDR
// end ;
73741: LD_VAR 0 3
73745: RET
// export function IsExtension ( b ) ; begin
73746: LD_INT 0
73748: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73749: LD_ADDR_VAR 0 2
73753: PUSH
73754: LD_VAR 0 1
73758: PUSH
73759: LD_INT 23
73761: PUSH
73762: LD_INT 20
73764: PUSH
73765: LD_INT 22
73767: PUSH
73768: LD_INT 17
73770: PUSH
73771: LD_INT 24
73773: PUSH
73774: LD_INT 21
73776: PUSH
73777: LD_INT 19
73779: PUSH
73780: LD_INT 16
73782: PUSH
73783: LD_INT 25
73785: PUSH
73786: LD_INT 18
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: LIST
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: LIST
73798: LIST
73799: LIST
73800: IN
73801: ST_TO_ADDR
// end ;
73802: LD_VAR 0 2
73806: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73807: LD_INT 0
73809: PPUSH
73810: PPUSH
73811: PPUSH
// result := [ ] ;
73812: LD_ADDR_VAR 0 4
73816: PUSH
73817: EMPTY
73818: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73819: LD_ADDR_VAR 0 5
73823: PUSH
73824: LD_VAR 0 2
73828: PPUSH
73829: LD_INT 21
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PPUSH
73839: CALL_OW 70
73843: ST_TO_ADDR
// if not tmp then
73844: LD_VAR 0 5
73848: NOT
73849: IFFALSE 73853
// exit ;
73851: GO 73917
// if checkLink then
73853: LD_VAR 0 3
73857: IFFALSE 73907
// begin for i in tmp do
73859: LD_ADDR_VAR 0 6
73863: PUSH
73864: LD_VAR 0 5
73868: PUSH
73869: FOR_IN
73870: IFFALSE 73905
// if GetBase ( i ) <> base then
73872: LD_VAR 0 6
73876: PPUSH
73877: CALL_OW 274
73881: PUSH
73882: LD_VAR 0 1
73886: NONEQUAL
73887: IFFALSE 73903
// ComLinkToBase ( base , i ) ;
73889: LD_VAR 0 1
73893: PPUSH
73894: LD_VAR 0 6
73898: PPUSH
73899: CALL_OW 169
73903: GO 73869
73905: POP
73906: POP
// end ; result := tmp ;
73907: LD_ADDR_VAR 0 4
73911: PUSH
73912: LD_VAR 0 5
73916: ST_TO_ADDR
// end ;
73917: LD_VAR 0 4
73921: RET
// export function ComComplete ( units , b ) ; var i ; begin
73922: LD_INT 0
73924: PPUSH
73925: PPUSH
// if not units then
73926: LD_VAR 0 1
73930: NOT
73931: IFFALSE 73935
// exit ;
73933: GO 74025
// for i in units do
73935: LD_ADDR_VAR 0 4
73939: PUSH
73940: LD_VAR 0 1
73944: PUSH
73945: FOR_IN
73946: IFFALSE 74023
// if BuildingStatus ( b ) = bs_build then
73948: LD_VAR 0 2
73952: PPUSH
73953: CALL_OW 461
73957: PUSH
73958: LD_INT 1
73960: EQUAL
73961: IFFALSE 74021
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73963: LD_VAR 0 4
73967: PPUSH
73968: LD_STRING h
73970: PUSH
73971: LD_VAR 0 2
73975: PPUSH
73976: CALL_OW 250
73980: PUSH
73981: LD_VAR 0 2
73985: PPUSH
73986: CALL_OW 251
73990: PUSH
73991: LD_VAR 0 2
73995: PUSH
73996: LD_INT 0
73998: PUSH
73999: LD_INT 0
74001: PUSH
74002: LD_INT 0
74004: PUSH
74005: EMPTY
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: PUSH
74014: EMPTY
74015: LIST
74016: PPUSH
74017: CALL_OW 446
74021: GO 73945
74023: POP
74024: POP
// end ;
74025: LD_VAR 0 3
74029: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74030: LD_INT 0
74032: PPUSH
74033: PPUSH
74034: PPUSH
74035: PPUSH
74036: PPUSH
74037: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
74038: LD_VAR 0 1
74042: NOT
74043: PUSH
74044: LD_VAR 0 1
74048: PPUSH
74049: CALL_OW 263
74053: PUSH
74054: LD_INT 2
74056: NONEQUAL
74057: OR
74058: IFFALSE 74062
// exit ;
74060: GO 74378
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74062: LD_ADDR_VAR 0 6
74066: PUSH
74067: LD_INT 22
74069: PUSH
74070: LD_VAR 0 1
74074: PPUSH
74075: CALL_OW 255
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 2
74086: PUSH
74087: LD_INT 30
74089: PUSH
74090: LD_INT 36
74092: PUSH
74093: EMPTY
74094: LIST
74095: LIST
74096: PUSH
74097: LD_INT 34
74099: PUSH
74100: LD_INT 31
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: LIST
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PPUSH
74116: CALL_OW 69
74120: ST_TO_ADDR
// if not tmp then
74121: LD_VAR 0 6
74125: NOT
74126: IFFALSE 74130
// exit ;
74128: GO 74378
// result := [ ] ;
74130: LD_ADDR_VAR 0 2
74134: PUSH
74135: EMPTY
74136: ST_TO_ADDR
// for i in tmp do
74137: LD_ADDR_VAR 0 3
74141: PUSH
74142: LD_VAR 0 6
74146: PUSH
74147: FOR_IN
74148: IFFALSE 74219
// begin t := UnitsInside ( i ) ;
74150: LD_ADDR_VAR 0 4
74154: PUSH
74155: LD_VAR 0 3
74159: PPUSH
74160: CALL_OW 313
74164: ST_TO_ADDR
// if t then
74165: LD_VAR 0 4
74169: IFFALSE 74217
// for j in t do
74171: LD_ADDR_VAR 0 7
74175: PUSH
74176: LD_VAR 0 4
74180: PUSH
74181: FOR_IN
74182: IFFALSE 74215
// result := Replace ( result , result + 1 , j ) ;
74184: LD_ADDR_VAR 0 2
74188: PUSH
74189: LD_VAR 0 2
74193: PPUSH
74194: LD_VAR 0 2
74198: PUSH
74199: LD_INT 1
74201: PLUS
74202: PPUSH
74203: LD_VAR 0 7
74207: PPUSH
74208: CALL_OW 1
74212: ST_TO_ADDR
74213: GO 74181
74215: POP
74216: POP
// end ;
74217: GO 74147
74219: POP
74220: POP
// if not result then
74221: LD_VAR 0 2
74225: NOT
74226: IFFALSE 74230
// exit ;
74228: GO 74378
// mech := result [ 1 ] ;
74230: LD_ADDR_VAR 0 5
74234: PUSH
74235: LD_VAR 0 2
74239: PUSH
74240: LD_INT 1
74242: ARRAY
74243: ST_TO_ADDR
// if result > 1 then
74244: LD_VAR 0 2
74248: PUSH
74249: LD_INT 1
74251: GREATER
74252: IFFALSE 74364
// begin for i = 2 to result do
74254: LD_ADDR_VAR 0 3
74258: PUSH
74259: DOUBLE
74260: LD_INT 2
74262: DEC
74263: ST_TO_ADDR
74264: LD_VAR 0 2
74268: PUSH
74269: FOR_TO
74270: IFFALSE 74362
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74272: LD_ADDR_VAR 0 4
74276: PUSH
74277: LD_VAR 0 2
74281: PUSH
74282: LD_VAR 0 3
74286: ARRAY
74287: PPUSH
74288: LD_INT 3
74290: PPUSH
74291: CALL_OW 259
74295: PUSH
74296: LD_VAR 0 2
74300: PUSH
74301: LD_VAR 0 3
74305: ARRAY
74306: PPUSH
74307: CALL_OW 432
74311: MINUS
74312: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74313: LD_VAR 0 4
74317: PUSH
74318: LD_VAR 0 5
74322: PPUSH
74323: LD_INT 3
74325: PPUSH
74326: CALL_OW 259
74330: PUSH
74331: LD_VAR 0 5
74335: PPUSH
74336: CALL_OW 432
74340: MINUS
74341: GREATEREQUAL
74342: IFFALSE 74360
// mech := result [ i ] ;
74344: LD_ADDR_VAR 0 5
74348: PUSH
74349: LD_VAR 0 2
74353: PUSH
74354: LD_VAR 0 3
74358: ARRAY
74359: ST_TO_ADDR
// end ;
74360: GO 74269
74362: POP
74363: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74364: LD_VAR 0 1
74368: PPUSH
74369: LD_VAR 0 5
74373: PPUSH
74374: CALL_OW 135
// end ;
74378: LD_VAR 0 2
74382: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74383: LD_INT 0
74385: PPUSH
74386: PPUSH
74387: PPUSH
74388: PPUSH
74389: PPUSH
74390: PPUSH
74391: PPUSH
74392: PPUSH
74393: PPUSH
74394: PPUSH
74395: PPUSH
74396: PPUSH
74397: PPUSH
// result := [ ] ;
74398: LD_ADDR_VAR 0 7
74402: PUSH
74403: EMPTY
74404: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74405: LD_VAR 0 1
74409: PPUSH
74410: CALL_OW 266
74414: PUSH
74415: LD_INT 0
74417: PUSH
74418: LD_INT 1
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: IN
74425: NOT
74426: IFFALSE 74430
// exit ;
74428: GO 76064
// if name then
74430: LD_VAR 0 3
74434: IFFALSE 74450
// SetBName ( base_dep , name ) ;
74436: LD_VAR 0 1
74440: PPUSH
74441: LD_VAR 0 3
74445: PPUSH
74446: CALL_OW 500
// base := GetBase ( base_dep ) ;
74450: LD_ADDR_VAR 0 15
74454: PUSH
74455: LD_VAR 0 1
74459: PPUSH
74460: CALL_OW 274
74464: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74465: LD_ADDR_VAR 0 16
74469: PUSH
74470: LD_VAR 0 1
74474: PPUSH
74475: CALL_OW 255
74479: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74480: LD_ADDR_VAR 0 17
74484: PUSH
74485: LD_VAR 0 1
74489: PPUSH
74490: CALL_OW 248
74494: ST_TO_ADDR
// if sources then
74495: LD_VAR 0 5
74499: IFFALSE 74546
// for i = 1 to 3 do
74501: LD_ADDR_VAR 0 8
74505: PUSH
74506: DOUBLE
74507: LD_INT 1
74509: DEC
74510: ST_TO_ADDR
74511: LD_INT 3
74513: PUSH
74514: FOR_TO
74515: IFFALSE 74544
// AddResourceType ( base , i , sources [ i ] ) ;
74517: LD_VAR 0 15
74521: PPUSH
74522: LD_VAR 0 8
74526: PPUSH
74527: LD_VAR 0 5
74531: PUSH
74532: LD_VAR 0 8
74536: ARRAY
74537: PPUSH
74538: CALL_OW 276
74542: GO 74514
74544: POP
74545: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74546: LD_ADDR_VAR 0 18
74550: PUSH
74551: LD_VAR 0 15
74555: PPUSH
74556: LD_VAR 0 2
74560: PPUSH
74561: LD_INT 1
74563: PPUSH
74564: CALL 73807 0 3
74568: ST_TO_ADDR
// InitHc ;
74569: CALL_OW 19
// InitUc ;
74573: CALL_OW 18
// uc_side := side ;
74577: LD_ADDR_OWVAR 20
74581: PUSH
74582: LD_VAR 0 16
74586: ST_TO_ADDR
// uc_nation := nation ;
74587: LD_ADDR_OWVAR 21
74591: PUSH
74592: LD_VAR 0 17
74596: ST_TO_ADDR
// if buildings then
74597: LD_VAR 0 18
74601: IFFALSE 75923
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74603: LD_ADDR_VAR 0 19
74607: PUSH
74608: LD_VAR 0 18
74612: PPUSH
74613: LD_INT 2
74615: PUSH
74616: LD_INT 30
74618: PUSH
74619: LD_INT 29
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 30
74628: PUSH
74629: LD_INT 30
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: EMPTY
74637: LIST
74638: LIST
74639: LIST
74640: PPUSH
74641: CALL_OW 72
74645: ST_TO_ADDR
// if tmp then
74646: LD_VAR 0 19
74650: IFFALSE 74698
// for i in tmp do
74652: LD_ADDR_VAR 0 8
74656: PUSH
74657: LD_VAR 0 19
74661: PUSH
74662: FOR_IN
74663: IFFALSE 74696
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74665: LD_VAR 0 8
74669: PPUSH
74670: CALL_OW 250
74674: PPUSH
74675: LD_VAR 0 8
74679: PPUSH
74680: CALL_OW 251
74684: PPUSH
74685: LD_VAR 0 16
74689: PPUSH
74690: CALL_OW 441
74694: GO 74662
74696: POP
74697: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74698: LD_VAR 0 18
74702: PPUSH
74703: LD_INT 2
74705: PUSH
74706: LD_INT 30
74708: PUSH
74709: LD_INT 32
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PUSH
74716: LD_INT 30
74718: PUSH
74719: LD_INT 33
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: LIST
74730: PPUSH
74731: CALL_OW 72
74735: IFFALSE 74823
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74737: LD_ADDR_VAR 0 8
74741: PUSH
74742: LD_VAR 0 18
74746: PPUSH
74747: LD_INT 2
74749: PUSH
74750: LD_INT 30
74752: PUSH
74753: LD_INT 32
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 30
74762: PUSH
74763: LD_INT 33
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: LIST
74774: PPUSH
74775: CALL_OW 72
74779: PUSH
74780: FOR_IN
74781: IFFALSE 74821
// begin if not GetBWeapon ( i ) then
74783: LD_VAR 0 8
74787: PPUSH
74788: CALL_OW 269
74792: NOT
74793: IFFALSE 74819
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74795: LD_VAR 0 8
74799: PPUSH
74800: LD_VAR 0 8
74804: PPUSH
74805: LD_VAR 0 2
74809: PPUSH
74810: CALL 76069 0 2
74814: PPUSH
74815: CALL_OW 431
// end ;
74819: GO 74780
74821: POP
74822: POP
// end ; for i = 1 to personel do
74823: LD_ADDR_VAR 0 8
74827: PUSH
74828: DOUBLE
74829: LD_INT 1
74831: DEC
74832: ST_TO_ADDR
74833: LD_VAR 0 6
74837: PUSH
74838: FOR_TO
74839: IFFALSE 75903
// begin if i > 4 then
74841: LD_VAR 0 8
74845: PUSH
74846: LD_INT 4
74848: GREATER
74849: IFFALSE 74853
// break ;
74851: GO 75903
// case i of 1 :
74853: LD_VAR 0 8
74857: PUSH
74858: LD_INT 1
74860: DOUBLE
74861: EQUAL
74862: IFTRUE 74866
74864: GO 74946
74866: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74867: LD_ADDR_VAR 0 12
74871: PUSH
74872: LD_VAR 0 18
74876: PPUSH
74877: LD_INT 22
74879: PUSH
74880: LD_VAR 0 16
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: LD_INT 58
74891: PUSH
74892: EMPTY
74893: LIST
74894: PUSH
74895: LD_INT 2
74897: PUSH
74898: LD_INT 30
74900: PUSH
74901: LD_INT 32
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 30
74910: PUSH
74911: LD_INT 4
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 30
74920: PUSH
74921: LD_INT 5
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: LIST
74932: LIST
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: LIST
74938: PPUSH
74939: CALL_OW 72
74943: ST_TO_ADDR
74944: GO 75168
74946: LD_INT 2
74948: DOUBLE
74949: EQUAL
74950: IFTRUE 74954
74952: GO 75016
74954: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74955: LD_ADDR_VAR 0 12
74959: PUSH
74960: LD_VAR 0 18
74964: PPUSH
74965: LD_INT 22
74967: PUSH
74968: LD_VAR 0 16
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: LD_INT 2
74979: PUSH
74980: LD_INT 30
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 30
74992: PUSH
74993: LD_INT 1
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PPUSH
75009: CALL_OW 72
75013: ST_TO_ADDR
75014: GO 75168
75016: LD_INT 3
75018: DOUBLE
75019: EQUAL
75020: IFTRUE 75024
75022: GO 75086
75024: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75025: LD_ADDR_VAR 0 12
75029: PUSH
75030: LD_VAR 0 18
75034: PPUSH
75035: LD_INT 22
75037: PUSH
75038: LD_VAR 0 16
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 2
75049: PUSH
75050: LD_INT 30
75052: PUSH
75053: LD_INT 2
75055: PUSH
75056: EMPTY
75057: LIST
75058: LIST
75059: PUSH
75060: LD_INT 30
75062: PUSH
75063: LD_INT 3
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: LIST
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PPUSH
75079: CALL_OW 72
75083: ST_TO_ADDR
75084: GO 75168
75086: LD_INT 4
75088: DOUBLE
75089: EQUAL
75090: IFTRUE 75094
75092: GO 75167
75094: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75095: LD_ADDR_VAR 0 12
75099: PUSH
75100: LD_VAR 0 18
75104: PPUSH
75105: LD_INT 22
75107: PUSH
75108: LD_VAR 0 16
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 2
75119: PUSH
75120: LD_INT 30
75122: PUSH
75123: LD_INT 6
75125: PUSH
75126: EMPTY
75127: LIST
75128: LIST
75129: PUSH
75130: LD_INT 30
75132: PUSH
75133: LD_INT 7
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 30
75142: PUSH
75143: LD_INT 8
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PPUSH
75160: CALL_OW 72
75164: ST_TO_ADDR
75165: GO 75168
75167: POP
// if i = 1 then
75168: LD_VAR 0 8
75172: PUSH
75173: LD_INT 1
75175: EQUAL
75176: IFFALSE 75287
// begin tmp := [ ] ;
75178: LD_ADDR_VAR 0 19
75182: PUSH
75183: EMPTY
75184: ST_TO_ADDR
// for j in f do
75185: LD_ADDR_VAR 0 9
75189: PUSH
75190: LD_VAR 0 12
75194: PUSH
75195: FOR_IN
75196: IFFALSE 75269
// if GetBType ( j ) = b_bunker then
75198: LD_VAR 0 9
75202: PPUSH
75203: CALL_OW 266
75207: PUSH
75208: LD_INT 32
75210: EQUAL
75211: IFFALSE 75238
// tmp := Insert ( tmp , 1 , j ) else
75213: LD_ADDR_VAR 0 19
75217: PUSH
75218: LD_VAR 0 19
75222: PPUSH
75223: LD_INT 1
75225: PPUSH
75226: LD_VAR 0 9
75230: PPUSH
75231: CALL_OW 2
75235: ST_TO_ADDR
75236: GO 75267
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75238: LD_ADDR_VAR 0 19
75242: PUSH
75243: LD_VAR 0 19
75247: PPUSH
75248: LD_VAR 0 19
75252: PUSH
75253: LD_INT 1
75255: PLUS
75256: PPUSH
75257: LD_VAR 0 9
75261: PPUSH
75262: CALL_OW 2
75266: ST_TO_ADDR
75267: GO 75195
75269: POP
75270: POP
// if tmp then
75271: LD_VAR 0 19
75275: IFFALSE 75287
// f := tmp ;
75277: LD_ADDR_VAR 0 12
75281: PUSH
75282: LD_VAR 0 19
75286: ST_TO_ADDR
// end ; x := personel [ i ] ;
75287: LD_ADDR_VAR 0 13
75291: PUSH
75292: LD_VAR 0 6
75296: PUSH
75297: LD_VAR 0 8
75301: ARRAY
75302: ST_TO_ADDR
// if x = - 1 then
75303: LD_VAR 0 13
75307: PUSH
75308: LD_INT 1
75310: NEG
75311: EQUAL
75312: IFFALSE 75521
// begin for j in f do
75314: LD_ADDR_VAR 0 9
75318: PUSH
75319: LD_VAR 0 12
75323: PUSH
75324: FOR_IN
75325: IFFALSE 75517
// repeat InitHc ;
75327: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75331: LD_VAR 0 9
75335: PPUSH
75336: CALL_OW 266
75340: PUSH
75341: LD_INT 5
75343: EQUAL
75344: IFFALSE 75414
// begin if UnitsInside ( j ) < 3 then
75346: LD_VAR 0 9
75350: PPUSH
75351: CALL_OW 313
75355: PUSH
75356: LD_INT 3
75358: LESS
75359: IFFALSE 75395
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75361: LD_INT 0
75363: PPUSH
75364: LD_INT 5
75366: PUSH
75367: LD_INT 8
75369: PUSH
75370: LD_INT 9
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: LIST
75377: PUSH
75378: LD_VAR 0 17
75382: ARRAY
75383: PPUSH
75384: LD_VAR 0 4
75388: PPUSH
75389: CALL_OW 380
75393: GO 75412
// PrepareHuman ( false , i , skill ) ;
75395: LD_INT 0
75397: PPUSH
75398: LD_VAR 0 8
75402: PPUSH
75403: LD_VAR 0 4
75407: PPUSH
75408: CALL_OW 380
// end else
75412: GO 75431
// PrepareHuman ( false , i , skill ) ;
75414: LD_INT 0
75416: PPUSH
75417: LD_VAR 0 8
75421: PPUSH
75422: LD_VAR 0 4
75426: PPUSH
75427: CALL_OW 380
// un := CreateHuman ;
75431: LD_ADDR_VAR 0 14
75435: PUSH
75436: CALL_OW 44
75440: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75441: LD_ADDR_VAR 0 7
75445: PUSH
75446: LD_VAR 0 7
75450: PPUSH
75451: LD_INT 1
75453: PPUSH
75454: LD_VAR 0 14
75458: PPUSH
75459: CALL_OW 2
75463: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75464: LD_VAR 0 14
75468: PPUSH
75469: LD_VAR 0 9
75473: PPUSH
75474: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75478: LD_VAR 0 9
75482: PPUSH
75483: CALL_OW 313
75487: PUSH
75488: LD_INT 6
75490: EQUAL
75491: PUSH
75492: LD_VAR 0 9
75496: PPUSH
75497: CALL_OW 266
75501: PUSH
75502: LD_INT 32
75504: PUSH
75505: LD_INT 31
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: IN
75512: OR
75513: IFFALSE 75327
75515: GO 75324
75517: POP
75518: POP
// end else
75519: GO 75901
// for j = 1 to x do
75521: LD_ADDR_VAR 0 9
75525: PUSH
75526: DOUBLE
75527: LD_INT 1
75529: DEC
75530: ST_TO_ADDR
75531: LD_VAR 0 13
75535: PUSH
75536: FOR_TO
75537: IFFALSE 75899
// begin InitHc ;
75539: CALL_OW 19
// if not f then
75543: LD_VAR 0 12
75547: NOT
75548: IFFALSE 75637
// begin PrepareHuman ( false , i , skill ) ;
75550: LD_INT 0
75552: PPUSH
75553: LD_VAR 0 8
75557: PPUSH
75558: LD_VAR 0 4
75562: PPUSH
75563: CALL_OW 380
// un := CreateHuman ;
75567: LD_ADDR_VAR 0 14
75571: PUSH
75572: CALL_OW 44
75576: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75577: LD_ADDR_VAR 0 7
75581: PUSH
75582: LD_VAR 0 7
75586: PPUSH
75587: LD_INT 1
75589: PPUSH
75590: LD_VAR 0 14
75594: PPUSH
75595: CALL_OW 2
75599: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75600: LD_VAR 0 14
75604: PPUSH
75605: LD_VAR 0 1
75609: PPUSH
75610: CALL_OW 250
75614: PPUSH
75615: LD_VAR 0 1
75619: PPUSH
75620: CALL_OW 251
75624: PPUSH
75625: LD_INT 10
75627: PPUSH
75628: LD_INT 0
75630: PPUSH
75631: CALL_OW 50
// continue ;
75635: GO 75536
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75637: LD_VAR 0 12
75641: PUSH
75642: LD_INT 1
75644: ARRAY
75645: PPUSH
75646: CALL_OW 313
75650: PUSH
75651: LD_VAR 0 12
75655: PUSH
75656: LD_INT 1
75658: ARRAY
75659: PPUSH
75660: CALL_OW 266
75664: PUSH
75665: LD_INT 32
75667: PUSH
75668: LD_INT 31
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: IN
75675: AND
75676: PUSH
75677: LD_VAR 0 12
75681: PUSH
75682: LD_INT 1
75684: ARRAY
75685: PPUSH
75686: CALL_OW 313
75690: PUSH
75691: LD_INT 6
75693: EQUAL
75694: OR
75695: IFFALSE 75715
// f := Delete ( f , 1 ) ;
75697: LD_ADDR_VAR 0 12
75701: PUSH
75702: LD_VAR 0 12
75706: PPUSH
75707: LD_INT 1
75709: PPUSH
75710: CALL_OW 3
75714: ST_TO_ADDR
// if not f then
75715: LD_VAR 0 12
75719: NOT
75720: IFFALSE 75738
// begin x := x + 2 ;
75722: LD_ADDR_VAR 0 13
75726: PUSH
75727: LD_VAR 0 13
75731: PUSH
75732: LD_INT 2
75734: PLUS
75735: ST_TO_ADDR
// continue ;
75736: GO 75536
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75738: LD_VAR 0 12
75742: PUSH
75743: LD_INT 1
75745: ARRAY
75746: PPUSH
75747: CALL_OW 266
75751: PUSH
75752: LD_INT 5
75754: EQUAL
75755: IFFALSE 75829
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75757: LD_VAR 0 12
75761: PUSH
75762: LD_INT 1
75764: ARRAY
75765: PPUSH
75766: CALL_OW 313
75770: PUSH
75771: LD_INT 3
75773: LESS
75774: IFFALSE 75810
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75776: LD_INT 0
75778: PPUSH
75779: LD_INT 5
75781: PUSH
75782: LD_INT 8
75784: PUSH
75785: LD_INT 9
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: LIST
75792: PUSH
75793: LD_VAR 0 17
75797: ARRAY
75798: PPUSH
75799: LD_VAR 0 4
75803: PPUSH
75804: CALL_OW 380
75808: GO 75827
// PrepareHuman ( false , i , skill ) ;
75810: LD_INT 0
75812: PPUSH
75813: LD_VAR 0 8
75817: PPUSH
75818: LD_VAR 0 4
75822: PPUSH
75823: CALL_OW 380
// end else
75827: GO 75846
// PrepareHuman ( false , i , skill ) ;
75829: LD_INT 0
75831: PPUSH
75832: LD_VAR 0 8
75836: PPUSH
75837: LD_VAR 0 4
75841: PPUSH
75842: CALL_OW 380
// un := CreateHuman ;
75846: LD_ADDR_VAR 0 14
75850: PUSH
75851: CALL_OW 44
75855: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75856: LD_ADDR_VAR 0 7
75860: PUSH
75861: LD_VAR 0 7
75865: PPUSH
75866: LD_INT 1
75868: PPUSH
75869: LD_VAR 0 14
75873: PPUSH
75874: CALL_OW 2
75878: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75879: LD_VAR 0 14
75883: PPUSH
75884: LD_VAR 0 12
75888: PUSH
75889: LD_INT 1
75891: ARRAY
75892: PPUSH
75893: CALL_OW 52
// end ;
75897: GO 75536
75899: POP
75900: POP
// end ;
75901: GO 74838
75903: POP
75904: POP
// result := result ^ buildings ;
75905: LD_ADDR_VAR 0 7
75909: PUSH
75910: LD_VAR 0 7
75914: PUSH
75915: LD_VAR 0 18
75919: ADD
75920: ST_TO_ADDR
// end else
75921: GO 76064
// begin for i = 1 to personel do
75923: LD_ADDR_VAR 0 8
75927: PUSH
75928: DOUBLE
75929: LD_INT 1
75931: DEC
75932: ST_TO_ADDR
75933: LD_VAR 0 6
75937: PUSH
75938: FOR_TO
75939: IFFALSE 76062
// begin if i > 4 then
75941: LD_VAR 0 8
75945: PUSH
75946: LD_INT 4
75948: GREATER
75949: IFFALSE 75953
// break ;
75951: GO 76062
// x := personel [ i ] ;
75953: LD_ADDR_VAR 0 13
75957: PUSH
75958: LD_VAR 0 6
75962: PUSH
75963: LD_VAR 0 8
75967: ARRAY
75968: ST_TO_ADDR
// if x = - 1 then
75969: LD_VAR 0 13
75973: PUSH
75974: LD_INT 1
75976: NEG
75977: EQUAL
75978: IFFALSE 75982
// continue ;
75980: GO 75938
// PrepareHuman ( false , i , skill ) ;
75982: LD_INT 0
75984: PPUSH
75985: LD_VAR 0 8
75989: PPUSH
75990: LD_VAR 0 4
75994: PPUSH
75995: CALL_OW 380
// un := CreateHuman ;
75999: LD_ADDR_VAR 0 14
76003: PUSH
76004: CALL_OW 44
76008: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76009: LD_VAR 0 14
76013: PPUSH
76014: LD_VAR 0 1
76018: PPUSH
76019: CALL_OW 250
76023: PPUSH
76024: LD_VAR 0 1
76028: PPUSH
76029: CALL_OW 251
76033: PPUSH
76034: LD_INT 10
76036: PPUSH
76037: LD_INT 0
76039: PPUSH
76040: CALL_OW 50
// result := result ^ un ;
76044: LD_ADDR_VAR 0 7
76048: PUSH
76049: LD_VAR 0 7
76053: PUSH
76054: LD_VAR 0 14
76058: ADD
76059: ST_TO_ADDR
// end ;
76060: GO 75938
76062: POP
76063: POP
// end ; end ;
76064: LD_VAR 0 7
76068: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76069: LD_INT 0
76071: PPUSH
76072: PPUSH
76073: PPUSH
76074: PPUSH
76075: PPUSH
76076: PPUSH
76077: PPUSH
76078: PPUSH
76079: PPUSH
76080: PPUSH
76081: PPUSH
76082: PPUSH
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
// result := false ;
76087: LD_ADDR_VAR 0 3
76091: PUSH
76092: LD_INT 0
76094: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76095: LD_VAR 0 1
76099: NOT
76100: PUSH
76101: LD_VAR 0 1
76105: PPUSH
76106: CALL_OW 266
76110: PUSH
76111: LD_INT 32
76113: PUSH
76114: LD_INT 33
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: IN
76121: NOT
76122: OR
76123: IFFALSE 76127
// exit ;
76125: GO 77236
// nat := GetNation ( tower ) ;
76127: LD_ADDR_VAR 0 12
76131: PUSH
76132: LD_VAR 0 1
76136: PPUSH
76137: CALL_OW 248
76141: ST_TO_ADDR
// side := GetSide ( tower ) ;
76142: LD_ADDR_VAR 0 16
76146: PUSH
76147: LD_VAR 0 1
76151: PPUSH
76152: CALL_OW 255
76156: ST_TO_ADDR
// x := GetX ( tower ) ;
76157: LD_ADDR_VAR 0 10
76161: PUSH
76162: LD_VAR 0 1
76166: PPUSH
76167: CALL_OW 250
76171: ST_TO_ADDR
// y := GetY ( tower ) ;
76172: LD_ADDR_VAR 0 11
76176: PUSH
76177: LD_VAR 0 1
76181: PPUSH
76182: CALL_OW 251
76186: ST_TO_ADDR
// if not x or not y then
76187: LD_VAR 0 10
76191: NOT
76192: PUSH
76193: LD_VAR 0 11
76197: NOT
76198: OR
76199: IFFALSE 76203
// exit ;
76201: GO 77236
// weapon := 0 ;
76203: LD_ADDR_VAR 0 18
76207: PUSH
76208: LD_INT 0
76210: ST_TO_ADDR
// fac_list := [ ] ;
76211: LD_ADDR_VAR 0 17
76215: PUSH
76216: EMPTY
76217: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76218: LD_ADDR_VAR 0 6
76222: PUSH
76223: LD_VAR 0 1
76227: PPUSH
76228: CALL_OW 274
76232: PPUSH
76233: LD_VAR 0 2
76237: PPUSH
76238: LD_INT 0
76240: PPUSH
76241: CALL 73807 0 3
76245: PPUSH
76246: LD_INT 30
76248: PUSH
76249: LD_INT 3
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PPUSH
76256: CALL_OW 72
76260: ST_TO_ADDR
// if not factories then
76261: LD_VAR 0 6
76265: NOT
76266: IFFALSE 76270
// exit ;
76268: GO 77236
// for i in factories do
76270: LD_ADDR_VAR 0 8
76274: PUSH
76275: LD_VAR 0 6
76279: PUSH
76280: FOR_IN
76281: IFFALSE 76306
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76283: LD_ADDR_VAR 0 17
76287: PUSH
76288: LD_VAR 0 17
76292: PUSH
76293: LD_VAR 0 8
76297: PPUSH
76298: CALL_OW 478
76302: UNION
76303: ST_TO_ADDR
76304: GO 76280
76306: POP
76307: POP
// if not fac_list then
76308: LD_VAR 0 17
76312: NOT
76313: IFFALSE 76317
// exit ;
76315: GO 77236
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76317: LD_ADDR_VAR 0 5
76321: PUSH
76322: LD_INT 4
76324: PUSH
76325: LD_INT 5
76327: PUSH
76328: LD_INT 9
76330: PUSH
76331: LD_INT 10
76333: PUSH
76334: LD_INT 6
76336: PUSH
76337: LD_INT 7
76339: PUSH
76340: LD_INT 11
76342: PUSH
76343: EMPTY
76344: LIST
76345: LIST
76346: LIST
76347: LIST
76348: LIST
76349: LIST
76350: LIST
76351: PUSH
76352: LD_INT 27
76354: PUSH
76355: LD_INT 28
76357: PUSH
76358: LD_INT 26
76360: PUSH
76361: LD_INT 30
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 43
76372: PUSH
76373: LD_INT 44
76375: PUSH
76376: LD_INT 46
76378: PUSH
76379: LD_INT 45
76381: PUSH
76382: LD_INT 47
76384: PUSH
76385: LD_INT 49
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: LIST
76392: LIST
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: LIST
76400: PUSH
76401: LD_VAR 0 12
76405: ARRAY
76406: ST_TO_ADDR
// list := list isect fac_list ;
76407: LD_ADDR_VAR 0 5
76411: PUSH
76412: LD_VAR 0 5
76416: PUSH
76417: LD_VAR 0 17
76421: ISECT
76422: ST_TO_ADDR
// if not list then
76423: LD_VAR 0 5
76427: NOT
76428: IFFALSE 76432
// exit ;
76430: GO 77236
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76432: LD_VAR 0 12
76436: PUSH
76437: LD_INT 3
76439: EQUAL
76440: PUSH
76441: LD_INT 49
76443: PUSH
76444: LD_VAR 0 5
76448: IN
76449: AND
76450: PUSH
76451: LD_INT 31
76453: PPUSH
76454: LD_VAR 0 16
76458: PPUSH
76459: CALL_OW 321
76463: PUSH
76464: LD_INT 2
76466: EQUAL
76467: AND
76468: IFFALSE 76528
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76470: LD_INT 22
76472: PUSH
76473: LD_VAR 0 16
76477: PUSH
76478: EMPTY
76479: LIST
76480: LIST
76481: PUSH
76482: LD_INT 35
76484: PUSH
76485: LD_INT 49
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 91
76494: PUSH
76495: LD_VAR 0 1
76499: PUSH
76500: LD_INT 10
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: LIST
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: LIST
76512: PPUSH
76513: CALL_OW 69
76517: NOT
76518: IFFALSE 76528
// weapon := ru_time_lapser ;
76520: LD_ADDR_VAR 0 18
76524: PUSH
76525: LD_INT 49
76527: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76528: LD_VAR 0 12
76532: PUSH
76533: LD_INT 1
76535: PUSH
76536: LD_INT 2
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: IN
76543: PUSH
76544: LD_INT 11
76546: PUSH
76547: LD_VAR 0 5
76551: IN
76552: PUSH
76553: LD_INT 30
76555: PUSH
76556: LD_VAR 0 5
76560: IN
76561: OR
76562: AND
76563: PUSH
76564: LD_INT 6
76566: PPUSH
76567: LD_VAR 0 16
76571: PPUSH
76572: CALL_OW 321
76576: PUSH
76577: LD_INT 2
76579: EQUAL
76580: AND
76581: IFFALSE 76746
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76583: LD_INT 22
76585: PUSH
76586: LD_VAR 0 16
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 2
76597: PUSH
76598: LD_INT 35
76600: PUSH
76601: LD_INT 11
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: LD_INT 35
76610: PUSH
76611: LD_INT 30
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: LIST
76622: PUSH
76623: LD_INT 91
76625: PUSH
76626: LD_VAR 0 1
76630: PUSH
76631: LD_INT 18
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: LIST
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: LIST
76643: PPUSH
76644: CALL_OW 69
76648: NOT
76649: PUSH
76650: LD_INT 22
76652: PUSH
76653: LD_VAR 0 16
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 2
76664: PUSH
76665: LD_INT 30
76667: PUSH
76668: LD_INT 32
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 30
76677: PUSH
76678: LD_INT 33
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 91
76692: PUSH
76693: LD_VAR 0 1
76697: PUSH
76698: LD_INT 12
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: LIST
76710: PUSH
76711: EMPTY
76712: LIST
76713: PPUSH
76714: CALL_OW 69
76718: PUSH
76719: LD_INT 2
76721: GREATER
76722: AND
76723: IFFALSE 76746
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76725: LD_ADDR_VAR 0 18
76729: PUSH
76730: LD_INT 11
76732: PUSH
76733: LD_INT 30
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_VAR 0 12
76744: ARRAY
76745: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76746: LD_VAR 0 18
76750: NOT
76751: PUSH
76752: LD_INT 40
76754: PPUSH
76755: LD_VAR 0 16
76759: PPUSH
76760: CALL_OW 321
76764: PUSH
76765: LD_INT 2
76767: EQUAL
76768: AND
76769: PUSH
76770: LD_INT 7
76772: PUSH
76773: LD_VAR 0 5
76777: IN
76778: PUSH
76779: LD_INT 28
76781: PUSH
76782: LD_VAR 0 5
76786: IN
76787: OR
76788: PUSH
76789: LD_INT 45
76791: PUSH
76792: LD_VAR 0 5
76796: IN
76797: OR
76798: AND
76799: IFFALSE 77053
// begin hex := GetHexInfo ( x , y ) ;
76801: LD_ADDR_VAR 0 4
76805: PUSH
76806: LD_VAR 0 10
76810: PPUSH
76811: LD_VAR 0 11
76815: PPUSH
76816: CALL_OW 546
76820: ST_TO_ADDR
// if hex [ 1 ] then
76821: LD_VAR 0 4
76825: PUSH
76826: LD_INT 1
76828: ARRAY
76829: IFFALSE 76833
// exit ;
76831: GO 77236
// height := hex [ 2 ] ;
76833: LD_ADDR_VAR 0 15
76837: PUSH
76838: LD_VAR 0 4
76842: PUSH
76843: LD_INT 2
76845: ARRAY
76846: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76847: LD_ADDR_VAR 0 14
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: LD_INT 2
76857: PUSH
76858: LD_INT 3
76860: PUSH
76861: LD_INT 5
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: ST_TO_ADDR
// for i in tmp do
76870: LD_ADDR_VAR 0 8
76874: PUSH
76875: LD_VAR 0 14
76879: PUSH
76880: FOR_IN
76881: IFFALSE 77051
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76883: LD_ADDR_VAR 0 9
76887: PUSH
76888: LD_VAR 0 10
76892: PPUSH
76893: LD_VAR 0 8
76897: PPUSH
76898: LD_INT 5
76900: PPUSH
76901: CALL_OW 272
76905: PUSH
76906: LD_VAR 0 11
76910: PPUSH
76911: LD_VAR 0 8
76915: PPUSH
76916: LD_INT 5
76918: PPUSH
76919: CALL_OW 273
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76928: LD_VAR 0 9
76932: PUSH
76933: LD_INT 1
76935: ARRAY
76936: PPUSH
76937: LD_VAR 0 9
76941: PUSH
76942: LD_INT 2
76944: ARRAY
76945: PPUSH
76946: CALL_OW 488
76950: IFFALSE 77049
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76952: LD_ADDR_VAR 0 4
76956: PUSH
76957: LD_VAR 0 9
76961: PUSH
76962: LD_INT 1
76964: ARRAY
76965: PPUSH
76966: LD_VAR 0 9
76970: PUSH
76971: LD_INT 2
76973: ARRAY
76974: PPUSH
76975: CALL_OW 546
76979: ST_TO_ADDR
// if hex [ 1 ] then
76980: LD_VAR 0 4
76984: PUSH
76985: LD_INT 1
76987: ARRAY
76988: IFFALSE 76992
// continue ;
76990: GO 76880
// h := hex [ 2 ] ;
76992: LD_ADDR_VAR 0 13
76996: PUSH
76997: LD_VAR 0 4
77001: PUSH
77002: LD_INT 2
77004: ARRAY
77005: ST_TO_ADDR
// if h + 7 < height then
77006: LD_VAR 0 13
77010: PUSH
77011: LD_INT 7
77013: PLUS
77014: PUSH
77015: LD_VAR 0 15
77019: LESS
77020: IFFALSE 77049
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77022: LD_ADDR_VAR 0 18
77026: PUSH
77027: LD_INT 7
77029: PUSH
77030: LD_INT 28
77032: PUSH
77033: LD_INT 45
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: LIST
77040: PUSH
77041: LD_VAR 0 12
77045: ARRAY
77046: ST_TO_ADDR
// break ;
77047: GO 77051
// end ; end ; end ;
77049: GO 76880
77051: POP
77052: POP
// end ; if not weapon then
77053: LD_VAR 0 18
77057: NOT
77058: IFFALSE 77118
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77060: LD_ADDR_VAR 0 5
77064: PUSH
77065: LD_VAR 0 5
77069: PUSH
77070: LD_INT 11
77072: PUSH
77073: LD_INT 30
77075: PUSH
77076: LD_INT 49
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: LIST
77083: DIFF
77084: ST_TO_ADDR
// if not list then
77085: LD_VAR 0 5
77089: NOT
77090: IFFALSE 77094
// exit ;
77092: GO 77236
// weapon := list [ rand ( 1 , list ) ] ;
77094: LD_ADDR_VAR 0 18
77098: PUSH
77099: LD_VAR 0 5
77103: PUSH
77104: LD_INT 1
77106: PPUSH
77107: LD_VAR 0 5
77111: PPUSH
77112: CALL_OW 12
77116: ARRAY
77117: ST_TO_ADDR
// end ; if weapon then
77118: LD_VAR 0 18
77122: IFFALSE 77236
// begin tmp := CostOfWeapon ( weapon ) ;
77124: LD_ADDR_VAR 0 14
77128: PUSH
77129: LD_VAR 0 18
77133: PPUSH
77134: CALL_OW 451
77138: ST_TO_ADDR
// j := GetBase ( tower ) ;
77139: LD_ADDR_VAR 0 9
77143: PUSH
77144: LD_VAR 0 1
77148: PPUSH
77149: CALL_OW 274
77153: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77154: LD_VAR 0 9
77158: PPUSH
77159: LD_INT 1
77161: PPUSH
77162: CALL_OW 275
77166: PUSH
77167: LD_VAR 0 14
77171: PUSH
77172: LD_INT 1
77174: ARRAY
77175: GREATEREQUAL
77176: PUSH
77177: LD_VAR 0 9
77181: PPUSH
77182: LD_INT 2
77184: PPUSH
77185: CALL_OW 275
77189: PUSH
77190: LD_VAR 0 14
77194: PUSH
77195: LD_INT 2
77197: ARRAY
77198: GREATEREQUAL
77199: AND
77200: PUSH
77201: LD_VAR 0 9
77205: PPUSH
77206: LD_INT 3
77208: PPUSH
77209: CALL_OW 275
77213: PUSH
77214: LD_VAR 0 14
77218: PUSH
77219: LD_INT 3
77221: ARRAY
77222: GREATEREQUAL
77223: AND
77224: IFFALSE 77236
// result := weapon ;
77226: LD_ADDR_VAR 0 3
77230: PUSH
77231: LD_VAR 0 18
77235: ST_TO_ADDR
// end ; end ;
77236: LD_VAR 0 3
77240: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77241: LD_INT 0
77243: PPUSH
77244: PPUSH
// result := true ;
77245: LD_ADDR_VAR 0 3
77249: PUSH
77250: LD_INT 1
77252: ST_TO_ADDR
// if array1 = array2 then
77253: LD_VAR 0 1
77257: PUSH
77258: LD_VAR 0 2
77262: EQUAL
77263: IFFALSE 77323
// begin for i = 1 to array1 do
77265: LD_ADDR_VAR 0 4
77269: PUSH
77270: DOUBLE
77271: LD_INT 1
77273: DEC
77274: ST_TO_ADDR
77275: LD_VAR 0 1
77279: PUSH
77280: FOR_TO
77281: IFFALSE 77319
// if array1 [ i ] <> array2 [ i ] then
77283: LD_VAR 0 1
77287: PUSH
77288: LD_VAR 0 4
77292: ARRAY
77293: PUSH
77294: LD_VAR 0 2
77298: PUSH
77299: LD_VAR 0 4
77303: ARRAY
77304: NONEQUAL
77305: IFFALSE 77317
// begin result := false ;
77307: LD_ADDR_VAR 0 3
77311: PUSH
77312: LD_INT 0
77314: ST_TO_ADDR
// break ;
77315: GO 77319
// end ;
77317: GO 77280
77319: POP
77320: POP
// end else
77321: GO 77331
// result := false ;
77323: LD_ADDR_VAR 0 3
77327: PUSH
77328: LD_INT 0
77330: ST_TO_ADDR
// end ;
77331: LD_VAR 0 3
77335: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77336: LD_INT 0
77338: PPUSH
77339: PPUSH
// if not array1 or not array2 then
77340: LD_VAR 0 1
77344: NOT
77345: PUSH
77346: LD_VAR 0 2
77350: NOT
77351: OR
77352: IFFALSE 77356
// exit ;
77354: GO 77420
// result := true ;
77356: LD_ADDR_VAR 0 3
77360: PUSH
77361: LD_INT 1
77363: ST_TO_ADDR
// for i = 1 to array1 do
77364: LD_ADDR_VAR 0 4
77368: PUSH
77369: DOUBLE
77370: LD_INT 1
77372: DEC
77373: ST_TO_ADDR
77374: LD_VAR 0 1
77378: PUSH
77379: FOR_TO
77380: IFFALSE 77418
// if array1 [ i ] <> array2 [ i ] then
77382: LD_VAR 0 1
77386: PUSH
77387: LD_VAR 0 4
77391: ARRAY
77392: PUSH
77393: LD_VAR 0 2
77397: PUSH
77398: LD_VAR 0 4
77402: ARRAY
77403: NONEQUAL
77404: IFFALSE 77416
// begin result := false ;
77406: LD_ADDR_VAR 0 3
77410: PUSH
77411: LD_INT 0
77413: ST_TO_ADDR
// break ;
77414: GO 77418
// end ;
77416: GO 77379
77418: POP
77419: POP
// end ;
77420: LD_VAR 0 3
77424: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77425: LD_INT 0
77427: PPUSH
77428: PPUSH
77429: PPUSH
// pom := GetBase ( fac ) ;
77430: LD_ADDR_VAR 0 5
77434: PUSH
77435: LD_VAR 0 1
77439: PPUSH
77440: CALL_OW 274
77444: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77445: LD_ADDR_VAR 0 4
77449: PUSH
77450: LD_VAR 0 2
77454: PUSH
77455: LD_INT 1
77457: ARRAY
77458: PPUSH
77459: LD_VAR 0 2
77463: PUSH
77464: LD_INT 2
77466: ARRAY
77467: PPUSH
77468: LD_VAR 0 2
77472: PUSH
77473: LD_INT 3
77475: ARRAY
77476: PPUSH
77477: LD_VAR 0 2
77481: PUSH
77482: LD_INT 4
77484: ARRAY
77485: PPUSH
77486: CALL_OW 449
77490: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77491: LD_ADDR_VAR 0 3
77495: PUSH
77496: LD_VAR 0 5
77500: PPUSH
77501: LD_INT 1
77503: PPUSH
77504: CALL_OW 275
77508: PUSH
77509: LD_VAR 0 4
77513: PUSH
77514: LD_INT 1
77516: ARRAY
77517: GREATEREQUAL
77518: PUSH
77519: LD_VAR 0 5
77523: PPUSH
77524: LD_INT 2
77526: PPUSH
77527: CALL_OW 275
77531: PUSH
77532: LD_VAR 0 4
77536: PUSH
77537: LD_INT 2
77539: ARRAY
77540: GREATEREQUAL
77541: AND
77542: PUSH
77543: LD_VAR 0 5
77547: PPUSH
77548: LD_INT 3
77550: PPUSH
77551: CALL_OW 275
77555: PUSH
77556: LD_VAR 0 4
77560: PUSH
77561: LD_INT 3
77563: ARRAY
77564: GREATEREQUAL
77565: AND
77566: ST_TO_ADDR
// end ;
77567: LD_VAR 0 3
77571: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77572: LD_INT 0
77574: PPUSH
77575: PPUSH
77576: PPUSH
77577: PPUSH
// pom := GetBase ( building ) ;
77578: LD_ADDR_VAR 0 3
77582: PUSH
77583: LD_VAR 0 1
77587: PPUSH
77588: CALL_OW 274
77592: ST_TO_ADDR
// if not pom then
77593: LD_VAR 0 3
77597: NOT
77598: IFFALSE 77602
// exit ;
77600: GO 77772
// btype := GetBType ( building ) ;
77602: LD_ADDR_VAR 0 5
77606: PUSH
77607: LD_VAR 0 1
77611: PPUSH
77612: CALL_OW 266
77616: ST_TO_ADDR
// if btype = b_armoury then
77617: LD_VAR 0 5
77621: PUSH
77622: LD_INT 4
77624: EQUAL
77625: IFFALSE 77635
// btype := b_barracks ;
77627: LD_ADDR_VAR 0 5
77631: PUSH
77632: LD_INT 5
77634: ST_TO_ADDR
// if btype = b_depot then
77635: LD_VAR 0 5
77639: PUSH
77640: LD_INT 0
77642: EQUAL
77643: IFFALSE 77653
// btype := b_warehouse ;
77645: LD_ADDR_VAR 0 5
77649: PUSH
77650: LD_INT 1
77652: ST_TO_ADDR
// if btype = b_workshop then
77653: LD_VAR 0 5
77657: PUSH
77658: LD_INT 2
77660: EQUAL
77661: IFFALSE 77671
// btype := b_factory ;
77663: LD_ADDR_VAR 0 5
77667: PUSH
77668: LD_INT 3
77670: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77671: LD_ADDR_VAR 0 4
77675: PUSH
77676: LD_VAR 0 5
77680: PPUSH
77681: LD_VAR 0 1
77685: PPUSH
77686: CALL_OW 248
77690: PPUSH
77691: CALL_OW 450
77695: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77696: LD_ADDR_VAR 0 2
77700: PUSH
77701: LD_VAR 0 3
77705: PPUSH
77706: LD_INT 1
77708: PPUSH
77709: CALL_OW 275
77713: PUSH
77714: LD_VAR 0 4
77718: PUSH
77719: LD_INT 1
77721: ARRAY
77722: GREATEREQUAL
77723: PUSH
77724: LD_VAR 0 3
77728: PPUSH
77729: LD_INT 2
77731: PPUSH
77732: CALL_OW 275
77736: PUSH
77737: LD_VAR 0 4
77741: PUSH
77742: LD_INT 2
77744: ARRAY
77745: GREATEREQUAL
77746: AND
77747: PUSH
77748: LD_VAR 0 3
77752: PPUSH
77753: LD_INT 3
77755: PPUSH
77756: CALL_OW 275
77760: PUSH
77761: LD_VAR 0 4
77765: PUSH
77766: LD_INT 3
77768: ARRAY
77769: GREATEREQUAL
77770: AND
77771: ST_TO_ADDR
// end ;
77772: LD_VAR 0 2
77776: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77777: LD_INT 0
77779: PPUSH
77780: PPUSH
77781: PPUSH
// pom := GetBase ( building ) ;
77782: LD_ADDR_VAR 0 4
77786: PUSH
77787: LD_VAR 0 1
77791: PPUSH
77792: CALL_OW 274
77796: ST_TO_ADDR
// if not pom then
77797: LD_VAR 0 4
77801: NOT
77802: IFFALSE 77806
// exit ;
77804: GO 77907
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77806: LD_ADDR_VAR 0 5
77810: PUSH
77811: LD_VAR 0 2
77815: PPUSH
77816: LD_VAR 0 1
77820: PPUSH
77821: CALL_OW 248
77825: PPUSH
77826: CALL_OW 450
77830: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77831: LD_ADDR_VAR 0 3
77835: PUSH
77836: LD_VAR 0 4
77840: PPUSH
77841: LD_INT 1
77843: PPUSH
77844: CALL_OW 275
77848: PUSH
77849: LD_VAR 0 5
77853: PUSH
77854: LD_INT 1
77856: ARRAY
77857: GREATEREQUAL
77858: PUSH
77859: LD_VAR 0 4
77863: PPUSH
77864: LD_INT 2
77866: PPUSH
77867: CALL_OW 275
77871: PUSH
77872: LD_VAR 0 5
77876: PUSH
77877: LD_INT 2
77879: ARRAY
77880: GREATEREQUAL
77881: AND
77882: PUSH
77883: LD_VAR 0 4
77887: PPUSH
77888: LD_INT 3
77890: PPUSH
77891: CALL_OW 275
77895: PUSH
77896: LD_VAR 0 5
77900: PUSH
77901: LD_INT 3
77903: ARRAY
77904: GREATEREQUAL
77905: AND
77906: ST_TO_ADDR
// end ;
77907: LD_VAR 0 3
77911: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77912: LD_INT 0
77914: PPUSH
77915: PPUSH
77916: PPUSH
77917: PPUSH
77918: PPUSH
77919: PPUSH
77920: PPUSH
77921: PPUSH
77922: PPUSH
77923: PPUSH
77924: PPUSH
// result := false ;
77925: LD_ADDR_VAR 0 8
77929: PUSH
77930: LD_INT 0
77932: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77933: LD_VAR 0 5
77937: NOT
77938: PUSH
77939: LD_VAR 0 1
77943: NOT
77944: OR
77945: PUSH
77946: LD_VAR 0 2
77950: NOT
77951: OR
77952: PUSH
77953: LD_VAR 0 3
77957: NOT
77958: OR
77959: IFFALSE 77963
// exit ;
77961: GO 78777
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77963: LD_ADDR_VAR 0 14
77967: PUSH
77968: LD_VAR 0 1
77972: PPUSH
77973: LD_VAR 0 2
77977: PPUSH
77978: LD_VAR 0 3
77982: PPUSH
77983: LD_VAR 0 4
77987: PPUSH
77988: LD_VAR 0 5
77992: PUSH
77993: LD_INT 1
77995: ARRAY
77996: PPUSH
77997: CALL_OW 248
78001: PPUSH
78002: LD_INT 0
78004: PPUSH
78005: CALL 80014 0 6
78009: ST_TO_ADDR
// if not hexes then
78010: LD_VAR 0 14
78014: NOT
78015: IFFALSE 78019
// exit ;
78017: GO 78777
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78019: LD_ADDR_VAR 0 17
78023: PUSH
78024: LD_VAR 0 5
78028: PPUSH
78029: LD_INT 22
78031: PUSH
78032: LD_VAR 0 13
78036: PPUSH
78037: CALL_OW 255
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 2
78048: PUSH
78049: LD_INT 30
78051: PUSH
78052: LD_INT 0
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 30
78061: PUSH
78062: LD_INT 1
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: LIST
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PPUSH
78078: CALL_OW 72
78082: ST_TO_ADDR
// for i = 1 to hexes do
78083: LD_ADDR_VAR 0 9
78087: PUSH
78088: DOUBLE
78089: LD_INT 1
78091: DEC
78092: ST_TO_ADDR
78093: LD_VAR 0 14
78097: PUSH
78098: FOR_TO
78099: IFFALSE 78775
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78101: LD_ADDR_VAR 0 13
78105: PUSH
78106: LD_VAR 0 14
78110: PUSH
78111: LD_VAR 0 9
78115: ARRAY
78116: PUSH
78117: LD_INT 1
78119: ARRAY
78120: PPUSH
78121: LD_VAR 0 14
78125: PUSH
78126: LD_VAR 0 9
78130: ARRAY
78131: PUSH
78132: LD_INT 2
78134: ARRAY
78135: PPUSH
78136: CALL_OW 428
78140: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78141: LD_VAR 0 14
78145: PUSH
78146: LD_VAR 0 9
78150: ARRAY
78151: PUSH
78152: LD_INT 1
78154: ARRAY
78155: PPUSH
78156: LD_VAR 0 14
78160: PUSH
78161: LD_VAR 0 9
78165: ARRAY
78166: PUSH
78167: LD_INT 2
78169: ARRAY
78170: PPUSH
78171: CALL_OW 351
78175: PUSH
78176: LD_VAR 0 14
78180: PUSH
78181: LD_VAR 0 9
78185: ARRAY
78186: PUSH
78187: LD_INT 1
78189: ARRAY
78190: PPUSH
78191: LD_VAR 0 14
78195: PUSH
78196: LD_VAR 0 9
78200: ARRAY
78201: PUSH
78202: LD_INT 2
78204: ARRAY
78205: PPUSH
78206: CALL_OW 488
78210: NOT
78211: OR
78212: PUSH
78213: LD_VAR 0 13
78217: PPUSH
78218: CALL_OW 247
78222: PUSH
78223: LD_INT 3
78225: EQUAL
78226: OR
78227: IFFALSE 78233
// exit ;
78229: POP
78230: POP
78231: GO 78777
// if not tmp then
78233: LD_VAR 0 13
78237: NOT
78238: IFFALSE 78242
// continue ;
78240: GO 78098
// result := true ;
78242: LD_ADDR_VAR 0 8
78246: PUSH
78247: LD_INT 1
78249: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78250: LD_VAR 0 6
78254: PUSH
78255: LD_VAR 0 13
78259: PPUSH
78260: CALL_OW 247
78264: PUSH
78265: LD_INT 2
78267: EQUAL
78268: AND
78269: PUSH
78270: LD_VAR 0 13
78274: PPUSH
78275: CALL_OW 263
78279: PUSH
78280: LD_INT 1
78282: EQUAL
78283: AND
78284: IFFALSE 78448
// begin if IsDrivenBy ( tmp ) then
78286: LD_VAR 0 13
78290: PPUSH
78291: CALL_OW 311
78295: IFFALSE 78299
// continue ;
78297: GO 78098
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78299: LD_VAR 0 6
78303: PPUSH
78304: LD_INT 3
78306: PUSH
78307: LD_INT 60
78309: PUSH
78310: EMPTY
78311: LIST
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 3
78319: PUSH
78320: LD_INT 55
78322: PUSH
78323: EMPTY
78324: LIST
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PPUSH
78334: CALL_OW 72
78338: IFFALSE 78446
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78340: LD_ADDR_VAR 0 18
78344: PUSH
78345: LD_VAR 0 6
78349: PPUSH
78350: LD_INT 3
78352: PUSH
78353: LD_INT 60
78355: PUSH
78356: EMPTY
78357: LIST
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 3
78365: PUSH
78366: LD_INT 55
78368: PUSH
78369: EMPTY
78370: LIST
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PPUSH
78380: CALL_OW 72
78384: PUSH
78385: LD_INT 1
78387: ARRAY
78388: ST_TO_ADDR
// if IsInUnit ( driver ) then
78389: LD_VAR 0 18
78393: PPUSH
78394: CALL_OW 310
78398: IFFALSE 78409
// ComExit ( driver ) ;
78400: LD_VAR 0 18
78404: PPUSH
78405: CALL 103719 0 1
// AddComEnterUnit ( driver , tmp ) ;
78409: LD_VAR 0 18
78413: PPUSH
78414: LD_VAR 0 13
78418: PPUSH
78419: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78423: LD_VAR 0 18
78427: PPUSH
78428: LD_VAR 0 7
78432: PPUSH
78433: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78437: LD_VAR 0 18
78441: PPUSH
78442: CALL_OW 181
// end ; continue ;
78446: GO 78098
// end ; if not cleaners or not tmp in cleaners then
78448: LD_VAR 0 6
78452: NOT
78453: PUSH
78454: LD_VAR 0 13
78458: PUSH
78459: LD_VAR 0 6
78463: IN
78464: NOT
78465: OR
78466: IFFALSE 78773
// begin if dep then
78468: LD_VAR 0 17
78472: IFFALSE 78608
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78474: LD_ADDR_VAR 0 16
78478: PUSH
78479: LD_VAR 0 17
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: PPUSH
78488: CALL_OW 250
78492: PPUSH
78493: LD_VAR 0 17
78497: PUSH
78498: LD_INT 1
78500: ARRAY
78501: PPUSH
78502: CALL_OW 254
78506: PPUSH
78507: LD_INT 5
78509: PPUSH
78510: CALL_OW 272
78514: PUSH
78515: LD_VAR 0 17
78519: PUSH
78520: LD_INT 1
78522: ARRAY
78523: PPUSH
78524: CALL_OW 251
78528: PPUSH
78529: LD_VAR 0 17
78533: PUSH
78534: LD_INT 1
78536: ARRAY
78537: PPUSH
78538: CALL_OW 254
78542: PPUSH
78543: LD_INT 5
78545: PPUSH
78546: CALL_OW 273
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78555: LD_VAR 0 16
78559: PUSH
78560: LD_INT 1
78562: ARRAY
78563: PPUSH
78564: LD_VAR 0 16
78568: PUSH
78569: LD_INT 2
78571: ARRAY
78572: PPUSH
78573: CALL_OW 488
78577: IFFALSE 78608
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78579: LD_VAR 0 13
78583: PPUSH
78584: LD_VAR 0 16
78588: PUSH
78589: LD_INT 1
78591: ARRAY
78592: PPUSH
78593: LD_VAR 0 16
78597: PUSH
78598: LD_INT 2
78600: ARRAY
78601: PPUSH
78602: CALL_OW 111
// continue ;
78606: GO 78098
// end ; end ; r := GetDir ( tmp ) ;
78608: LD_ADDR_VAR 0 15
78612: PUSH
78613: LD_VAR 0 13
78617: PPUSH
78618: CALL_OW 254
78622: ST_TO_ADDR
// if r = 5 then
78623: LD_VAR 0 15
78627: PUSH
78628: LD_INT 5
78630: EQUAL
78631: IFFALSE 78641
// r := 0 ;
78633: LD_ADDR_VAR 0 15
78637: PUSH
78638: LD_INT 0
78640: ST_TO_ADDR
// for j = r to 5 do
78641: LD_ADDR_VAR 0 10
78645: PUSH
78646: DOUBLE
78647: LD_VAR 0 15
78651: DEC
78652: ST_TO_ADDR
78653: LD_INT 5
78655: PUSH
78656: FOR_TO
78657: IFFALSE 78771
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78659: LD_ADDR_VAR 0 11
78663: PUSH
78664: LD_VAR 0 13
78668: PPUSH
78669: CALL_OW 250
78673: PPUSH
78674: LD_VAR 0 10
78678: PPUSH
78679: LD_INT 2
78681: PPUSH
78682: CALL_OW 272
78686: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78687: LD_ADDR_VAR 0 12
78691: PUSH
78692: LD_VAR 0 13
78696: PPUSH
78697: CALL_OW 251
78701: PPUSH
78702: LD_VAR 0 10
78706: PPUSH
78707: LD_INT 2
78709: PPUSH
78710: CALL_OW 273
78714: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78715: LD_VAR 0 11
78719: PPUSH
78720: LD_VAR 0 12
78724: PPUSH
78725: CALL_OW 488
78729: PUSH
78730: LD_VAR 0 11
78734: PPUSH
78735: LD_VAR 0 12
78739: PPUSH
78740: CALL_OW 428
78744: NOT
78745: AND
78746: IFFALSE 78769
// begin ComMoveXY ( tmp , _x , _y ) ;
78748: LD_VAR 0 13
78752: PPUSH
78753: LD_VAR 0 11
78757: PPUSH
78758: LD_VAR 0 12
78762: PPUSH
78763: CALL_OW 111
// break ;
78767: GO 78771
// end ; end ;
78769: GO 78656
78771: POP
78772: POP
// end ; end ;
78773: GO 78098
78775: POP
78776: POP
// end ;
78777: LD_VAR 0 8
78781: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78782: LD_INT 0
78784: PPUSH
// result := true ;
78785: LD_ADDR_VAR 0 3
78789: PUSH
78790: LD_INT 1
78792: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78793: LD_VAR 0 2
78797: PUSH
78798: LD_INT 24
78800: DOUBLE
78801: EQUAL
78802: IFTRUE 78812
78804: LD_INT 33
78806: DOUBLE
78807: EQUAL
78808: IFTRUE 78812
78810: GO 78837
78812: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78813: LD_ADDR_VAR 0 3
78817: PUSH
78818: LD_INT 32
78820: PPUSH
78821: LD_VAR 0 1
78825: PPUSH
78826: CALL_OW 321
78830: PUSH
78831: LD_INT 2
78833: EQUAL
78834: ST_TO_ADDR
78835: GO 79157
78837: LD_INT 20
78839: DOUBLE
78840: EQUAL
78841: IFTRUE 78845
78843: GO 78870
78845: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78846: LD_ADDR_VAR 0 3
78850: PUSH
78851: LD_INT 6
78853: PPUSH
78854: LD_VAR 0 1
78858: PPUSH
78859: CALL_OW 321
78863: PUSH
78864: LD_INT 2
78866: EQUAL
78867: ST_TO_ADDR
78868: GO 79157
78870: LD_INT 22
78872: DOUBLE
78873: EQUAL
78874: IFTRUE 78884
78876: LD_INT 36
78878: DOUBLE
78879: EQUAL
78880: IFTRUE 78884
78882: GO 78909
78884: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78885: LD_ADDR_VAR 0 3
78889: PUSH
78890: LD_INT 15
78892: PPUSH
78893: LD_VAR 0 1
78897: PPUSH
78898: CALL_OW 321
78902: PUSH
78903: LD_INT 2
78905: EQUAL
78906: ST_TO_ADDR
78907: GO 79157
78909: LD_INT 30
78911: DOUBLE
78912: EQUAL
78913: IFTRUE 78917
78915: GO 78942
78917: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78918: LD_ADDR_VAR 0 3
78922: PUSH
78923: LD_INT 20
78925: PPUSH
78926: LD_VAR 0 1
78930: PPUSH
78931: CALL_OW 321
78935: PUSH
78936: LD_INT 2
78938: EQUAL
78939: ST_TO_ADDR
78940: GO 79157
78942: LD_INT 28
78944: DOUBLE
78945: EQUAL
78946: IFTRUE 78956
78948: LD_INT 21
78950: DOUBLE
78951: EQUAL
78952: IFTRUE 78956
78954: GO 78981
78956: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78957: LD_ADDR_VAR 0 3
78961: PUSH
78962: LD_INT 21
78964: PPUSH
78965: LD_VAR 0 1
78969: PPUSH
78970: CALL_OW 321
78974: PUSH
78975: LD_INT 2
78977: EQUAL
78978: ST_TO_ADDR
78979: GO 79157
78981: LD_INT 16
78983: DOUBLE
78984: EQUAL
78985: IFTRUE 78989
78987: GO 79016
78989: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78990: LD_ADDR_VAR 0 3
78994: PUSH
78995: LD_EXP 108
78999: PPUSH
79000: LD_VAR 0 1
79004: PPUSH
79005: CALL_OW 321
79009: PUSH
79010: LD_INT 2
79012: EQUAL
79013: ST_TO_ADDR
79014: GO 79157
79016: LD_INT 19
79018: DOUBLE
79019: EQUAL
79020: IFTRUE 79030
79022: LD_INT 23
79024: DOUBLE
79025: EQUAL
79026: IFTRUE 79030
79028: GO 79057
79030: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
79031: LD_ADDR_VAR 0 3
79035: PUSH
79036: LD_EXP 107
79040: PPUSH
79041: LD_VAR 0 1
79045: PPUSH
79046: CALL_OW 321
79050: PUSH
79051: LD_INT 2
79053: EQUAL
79054: ST_TO_ADDR
79055: GO 79157
79057: LD_INT 17
79059: DOUBLE
79060: EQUAL
79061: IFTRUE 79065
79063: GO 79090
79065: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
79066: LD_ADDR_VAR 0 3
79070: PUSH
79071: LD_INT 39
79073: PPUSH
79074: LD_VAR 0 1
79078: PPUSH
79079: CALL_OW 321
79083: PUSH
79084: LD_INT 2
79086: EQUAL
79087: ST_TO_ADDR
79088: GO 79157
79090: LD_INT 18
79092: DOUBLE
79093: EQUAL
79094: IFTRUE 79098
79096: GO 79123
79098: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
79099: LD_ADDR_VAR 0 3
79103: PUSH
79104: LD_INT 40
79106: PPUSH
79107: LD_VAR 0 1
79111: PPUSH
79112: CALL_OW 321
79116: PUSH
79117: LD_INT 2
79119: EQUAL
79120: ST_TO_ADDR
79121: GO 79157
79123: LD_INT 27
79125: DOUBLE
79126: EQUAL
79127: IFTRUE 79131
79129: GO 79156
79131: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
79132: LD_ADDR_VAR 0 3
79136: PUSH
79137: LD_INT 35
79139: PPUSH
79140: LD_VAR 0 1
79144: PPUSH
79145: CALL_OW 321
79149: PUSH
79150: LD_INT 2
79152: EQUAL
79153: ST_TO_ADDR
79154: GO 79157
79156: POP
// end ;
79157: LD_VAR 0 3
79161: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
79162: LD_INT 0
79164: PPUSH
79165: PPUSH
79166: PPUSH
79167: PPUSH
79168: PPUSH
79169: PPUSH
79170: PPUSH
79171: PPUSH
79172: PPUSH
79173: PPUSH
79174: PPUSH
// result := false ;
79175: LD_ADDR_VAR 0 6
79179: PUSH
79180: LD_INT 0
79182: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79183: LD_VAR 0 1
79187: NOT
79188: PUSH
79189: LD_VAR 0 1
79193: PPUSH
79194: CALL_OW 266
79198: PUSH
79199: LD_INT 0
79201: PUSH
79202: LD_INT 1
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: IN
79209: NOT
79210: OR
79211: PUSH
79212: LD_VAR 0 2
79216: NOT
79217: OR
79218: PUSH
79219: LD_VAR 0 5
79223: PUSH
79224: LD_INT 0
79226: PUSH
79227: LD_INT 1
79229: PUSH
79230: LD_INT 2
79232: PUSH
79233: LD_INT 3
79235: PUSH
79236: LD_INT 4
79238: PUSH
79239: LD_INT 5
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: IN
79250: NOT
79251: OR
79252: PUSH
79253: LD_VAR 0 3
79257: PPUSH
79258: LD_VAR 0 4
79262: PPUSH
79263: CALL_OW 488
79267: NOT
79268: OR
79269: IFFALSE 79273
// exit ;
79271: GO 80009
// side := GetSide ( depot ) ;
79273: LD_ADDR_VAR 0 9
79277: PUSH
79278: LD_VAR 0 1
79282: PPUSH
79283: CALL_OW 255
79287: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79288: LD_VAR 0 9
79292: PPUSH
79293: LD_VAR 0 2
79297: PPUSH
79298: CALL 78782 0 2
79302: NOT
79303: IFFALSE 79307
// exit ;
79305: GO 80009
// pom := GetBase ( depot ) ;
79307: LD_ADDR_VAR 0 10
79311: PUSH
79312: LD_VAR 0 1
79316: PPUSH
79317: CALL_OW 274
79321: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79322: LD_ADDR_VAR 0 11
79326: PUSH
79327: LD_VAR 0 2
79331: PPUSH
79332: LD_VAR 0 1
79336: PPUSH
79337: CALL_OW 248
79341: PPUSH
79342: CALL_OW 450
79346: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79347: LD_VAR 0 10
79351: PPUSH
79352: LD_INT 1
79354: PPUSH
79355: CALL_OW 275
79359: PUSH
79360: LD_VAR 0 11
79364: PUSH
79365: LD_INT 1
79367: ARRAY
79368: GREATEREQUAL
79369: PUSH
79370: LD_VAR 0 10
79374: PPUSH
79375: LD_INT 2
79377: PPUSH
79378: CALL_OW 275
79382: PUSH
79383: LD_VAR 0 11
79387: PUSH
79388: LD_INT 2
79390: ARRAY
79391: GREATEREQUAL
79392: AND
79393: PUSH
79394: LD_VAR 0 10
79398: PPUSH
79399: LD_INT 3
79401: PPUSH
79402: CALL_OW 275
79406: PUSH
79407: LD_VAR 0 11
79411: PUSH
79412: LD_INT 3
79414: ARRAY
79415: GREATEREQUAL
79416: AND
79417: NOT
79418: IFFALSE 79422
// exit ;
79420: GO 80009
// if GetBType ( depot ) = b_depot then
79422: LD_VAR 0 1
79426: PPUSH
79427: CALL_OW 266
79431: PUSH
79432: LD_INT 0
79434: EQUAL
79435: IFFALSE 79447
// dist := 28 else
79437: LD_ADDR_VAR 0 14
79441: PUSH
79442: LD_INT 28
79444: ST_TO_ADDR
79445: GO 79455
// dist := 36 ;
79447: LD_ADDR_VAR 0 14
79451: PUSH
79452: LD_INT 36
79454: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79455: LD_VAR 0 1
79459: PPUSH
79460: LD_VAR 0 3
79464: PPUSH
79465: LD_VAR 0 4
79469: PPUSH
79470: CALL_OW 297
79474: PUSH
79475: LD_VAR 0 14
79479: GREATER
79480: IFFALSE 79484
// exit ;
79482: GO 80009
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79484: LD_ADDR_VAR 0 12
79488: PUSH
79489: LD_VAR 0 2
79493: PPUSH
79494: LD_VAR 0 3
79498: PPUSH
79499: LD_VAR 0 4
79503: PPUSH
79504: LD_VAR 0 5
79508: PPUSH
79509: LD_VAR 0 1
79513: PPUSH
79514: CALL_OW 248
79518: PPUSH
79519: LD_INT 0
79521: PPUSH
79522: CALL 80014 0 6
79526: ST_TO_ADDR
// if not hexes then
79527: LD_VAR 0 12
79531: NOT
79532: IFFALSE 79536
// exit ;
79534: GO 80009
// hex := GetHexInfo ( x , y ) ;
79536: LD_ADDR_VAR 0 15
79540: PUSH
79541: LD_VAR 0 3
79545: PPUSH
79546: LD_VAR 0 4
79550: PPUSH
79551: CALL_OW 546
79555: ST_TO_ADDR
// if hex [ 1 ] then
79556: LD_VAR 0 15
79560: PUSH
79561: LD_INT 1
79563: ARRAY
79564: IFFALSE 79568
// exit ;
79566: GO 80009
// height := hex [ 2 ] ;
79568: LD_ADDR_VAR 0 13
79572: PUSH
79573: LD_VAR 0 15
79577: PUSH
79578: LD_INT 2
79580: ARRAY
79581: ST_TO_ADDR
// for i = 1 to hexes do
79582: LD_ADDR_VAR 0 7
79586: PUSH
79587: DOUBLE
79588: LD_INT 1
79590: DEC
79591: ST_TO_ADDR
79592: LD_VAR 0 12
79596: PUSH
79597: FOR_TO
79598: IFFALSE 79928
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79600: LD_VAR 0 12
79604: PUSH
79605: LD_VAR 0 7
79609: ARRAY
79610: PUSH
79611: LD_INT 1
79613: ARRAY
79614: PPUSH
79615: LD_VAR 0 12
79619: PUSH
79620: LD_VAR 0 7
79624: ARRAY
79625: PUSH
79626: LD_INT 2
79628: ARRAY
79629: PPUSH
79630: CALL_OW 488
79634: NOT
79635: PUSH
79636: LD_VAR 0 12
79640: PUSH
79641: LD_VAR 0 7
79645: ARRAY
79646: PUSH
79647: LD_INT 1
79649: ARRAY
79650: PPUSH
79651: LD_VAR 0 12
79655: PUSH
79656: LD_VAR 0 7
79660: ARRAY
79661: PUSH
79662: LD_INT 2
79664: ARRAY
79665: PPUSH
79666: CALL_OW 428
79670: PUSH
79671: LD_INT 0
79673: GREATER
79674: OR
79675: PUSH
79676: LD_VAR 0 12
79680: PUSH
79681: LD_VAR 0 7
79685: ARRAY
79686: PUSH
79687: LD_INT 1
79689: ARRAY
79690: PPUSH
79691: LD_VAR 0 12
79695: PUSH
79696: LD_VAR 0 7
79700: ARRAY
79701: PUSH
79702: LD_INT 2
79704: ARRAY
79705: PPUSH
79706: CALL_OW 351
79710: OR
79711: IFFALSE 79717
// exit ;
79713: POP
79714: POP
79715: GO 80009
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79717: LD_ADDR_VAR 0 8
79721: PUSH
79722: LD_VAR 0 12
79726: PUSH
79727: LD_VAR 0 7
79731: ARRAY
79732: PUSH
79733: LD_INT 1
79735: ARRAY
79736: PPUSH
79737: LD_VAR 0 12
79741: PUSH
79742: LD_VAR 0 7
79746: ARRAY
79747: PUSH
79748: LD_INT 2
79750: ARRAY
79751: PPUSH
79752: CALL_OW 546
79756: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79757: LD_VAR 0 8
79761: PUSH
79762: LD_INT 1
79764: ARRAY
79765: PUSH
79766: LD_VAR 0 8
79770: PUSH
79771: LD_INT 2
79773: ARRAY
79774: PUSH
79775: LD_VAR 0 13
79779: PUSH
79780: LD_INT 2
79782: PLUS
79783: GREATER
79784: OR
79785: PUSH
79786: LD_VAR 0 8
79790: PUSH
79791: LD_INT 2
79793: ARRAY
79794: PUSH
79795: LD_VAR 0 13
79799: PUSH
79800: LD_INT 2
79802: MINUS
79803: LESS
79804: OR
79805: PUSH
79806: LD_VAR 0 8
79810: PUSH
79811: LD_INT 3
79813: ARRAY
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: LD_INT 8
79820: PUSH
79821: LD_INT 9
79823: PUSH
79824: LD_INT 10
79826: PUSH
79827: LD_INT 11
79829: PUSH
79830: LD_INT 12
79832: PUSH
79833: LD_INT 13
79835: PUSH
79836: LD_INT 16
79838: PUSH
79839: LD_INT 17
79841: PUSH
79842: LD_INT 18
79844: PUSH
79845: LD_INT 19
79847: PUSH
79848: LD_INT 20
79850: PUSH
79851: LD_INT 21
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: IN
79869: NOT
79870: OR
79871: PUSH
79872: LD_VAR 0 8
79876: PUSH
79877: LD_INT 5
79879: ARRAY
79880: NOT
79881: OR
79882: PUSH
79883: LD_VAR 0 8
79887: PUSH
79888: LD_INT 6
79890: ARRAY
79891: PUSH
79892: LD_INT 1
79894: PUSH
79895: LD_INT 2
79897: PUSH
79898: LD_INT 7
79900: PUSH
79901: LD_INT 9
79903: PUSH
79904: LD_INT 10
79906: PUSH
79907: LD_INT 11
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: IN
79918: NOT
79919: OR
79920: IFFALSE 79926
// exit ;
79922: POP
79923: POP
79924: GO 80009
// end ;
79926: GO 79597
79928: POP
79929: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79930: LD_VAR 0 9
79934: PPUSH
79935: LD_VAR 0 3
79939: PPUSH
79940: LD_VAR 0 4
79944: PPUSH
79945: LD_INT 20
79947: PPUSH
79948: CALL 71955 0 4
79952: PUSH
79953: LD_INT 4
79955: ARRAY
79956: IFFALSE 79960
// exit ;
79958: GO 80009
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79960: LD_VAR 0 2
79964: PUSH
79965: LD_INT 29
79967: PUSH
79968: LD_INT 30
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: IN
79975: PUSH
79976: LD_VAR 0 3
79980: PPUSH
79981: LD_VAR 0 4
79985: PPUSH
79986: LD_VAR 0 9
79990: PPUSH
79991: CALL_OW 440
79995: NOT
79996: AND
79997: IFFALSE 80001
// exit ;
79999: GO 80009
// result := true ;
80001: LD_ADDR_VAR 0 6
80005: PUSH
80006: LD_INT 1
80008: ST_TO_ADDR
// end ;
80009: LD_VAR 0 6
80013: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
80014: LD_INT 0
80016: PPUSH
80017: PPUSH
80018: PPUSH
80019: PPUSH
80020: PPUSH
80021: PPUSH
80022: PPUSH
80023: PPUSH
80024: PPUSH
80025: PPUSH
80026: PPUSH
80027: PPUSH
80028: PPUSH
80029: PPUSH
80030: PPUSH
80031: PPUSH
80032: PPUSH
80033: PPUSH
80034: PPUSH
80035: PPUSH
80036: PPUSH
80037: PPUSH
80038: PPUSH
80039: PPUSH
80040: PPUSH
80041: PPUSH
80042: PPUSH
80043: PPUSH
80044: PPUSH
80045: PPUSH
80046: PPUSH
80047: PPUSH
80048: PPUSH
80049: PPUSH
80050: PPUSH
80051: PPUSH
80052: PPUSH
80053: PPUSH
80054: PPUSH
80055: PPUSH
80056: PPUSH
80057: PPUSH
80058: PPUSH
80059: PPUSH
80060: PPUSH
80061: PPUSH
80062: PPUSH
80063: PPUSH
80064: PPUSH
80065: PPUSH
80066: PPUSH
80067: PPUSH
80068: PPUSH
80069: PPUSH
80070: PPUSH
80071: PPUSH
80072: PPUSH
80073: PPUSH
// result = [ ] ;
80074: LD_ADDR_VAR 0 7
80078: PUSH
80079: EMPTY
80080: ST_TO_ADDR
// temp_list = [ ] ;
80081: LD_ADDR_VAR 0 9
80085: PUSH
80086: EMPTY
80087: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80088: LD_VAR 0 4
80092: PUSH
80093: LD_INT 0
80095: PUSH
80096: LD_INT 1
80098: PUSH
80099: LD_INT 2
80101: PUSH
80102: LD_INT 3
80104: PUSH
80105: LD_INT 4
80107: PUSH
80108: LD_INT 5
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: IN
80119: NOT
80120: PUSH
80121: LD_VAR 0 1
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: IN
80136: PUSH
80137: LD_VAR 0 5
80141: PUSH
80142: LD_INT 1
80144: PUSH
80145: LD_INT 2
80147: PUSH
80148: LD_INT 3
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: LIST
80155: IN
80156: NOT
80157: AND
80158: OR
80159: IFFALSE 80163
// exit ;
80161: GO 98554
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80163: LD_VAR 0 1
80167: PUSH
80168: LD_INT 6
80170: PUSH
80171: LD_INT 7
80173: PUSH
80174: LD_INT 8
80176: PUSH
80177: LD_INT 13
80179: PUSH
80180: LD_INT 12
80182: PUSH
80183: LD_INT 15
80185: PUSH
80186: LD_INT 11
80188: PUSH
80189: LD_INT 14
80191: PUSH
80192: LD_INT 10
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: LIST
80202: LIST
80203: LIST
80204: LIST
80205: IN
80206: IFFALSE 80216
// btype = b_lab ;
80208: LD_ADDR_VAR 0 1
80212: PUSH
80213: LD_INT 6
80215: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80216: LD_VAR 0 6
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: LD_INT 1
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: LIST
80234: IN
80235: NOT
80236: PUSH
80237: LD_VAR 0 1
80241: PUSH
80242: LD_INT 0
80244: PUSH
80245: LD_INT 1
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: LD_INT 3
80253: PUSH
80254: LD_INT 6
80256: PUSH
80257: LD_INT 36
80259: PUSH
80260: LD_INT 4
80262: PUSH
80263: LD_INT 5
80265: PUSH
80266: LD_INT 31
80268: PUSH
80269: LD_INT 32
80271: PUSH
80272: LD_INT 33
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: IN
80288: NOT
80289: PUSH
80290: LD_VAR 0 6
80294: PUSH
80295: LD_INT 1
80297: EQUAL
80298: AND
80299: OR
80300: PUSH
80301: LD_VAR 0 1
80305: PUSH
80306: LD_INT 2
80308: PUSH
80309: LD_INT 3
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: IN
80316: NOT
80317: PUSH
80318: LD_VAR 0 6
80322: PUSH
80323: LD_INT 2
80325: EQUAL
80326: AND
80327: OR
80328: IFFALSE 80338
// mode = 0 ;
80330: LD_ADDR_VAR 0 6
80334: PUSH
80335: LD_INT 0
80337: ST_TO_ADDR
// case mode of 0 :
80338: LD_VAR 0 6
80342: PUSH
80343: LD_INT 0
80345: DOUBLE
80346: EQUAL
80347: IFTRUE 80351
80349: GO 91804
80351: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80352: LD_ADDR_VAR 0 11
80356: PUSH
80357: LD_INT 0
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 0
80369: PUSH
80370: LD_INT 1
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 1
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: LD_INT 1
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 0
80400: PUSH
80401: LD_INT 1
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: LD_INT 0
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 1
80421: NEG
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: LD_INT 2
80437: NEG
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 0
80445: PUSH
80446: LD_INT 2
80448: NEG
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 1
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 1
80467: PUSH
80468: LD_INT 2
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: LD_INT 2
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 1
80487: NEG
80488: PUSH
80489: LD_INT 1
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 1
80498: PUSH
80499: LD_INT 3
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 0
80508: PUSH
80509: LD_INT 3
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 1
80518: NEG
80519: PUSH
80520: LD_INT 2
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80545: LD_ADDR_VAR 0 12
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 0
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 0
80562: PUSH
80563: LD_INT 1
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 1
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 1
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: NEG
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 1
80626: PUSH
80627: LD_INT 1
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 2
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 2
80647: PUSH
80648: LD_INT 1
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: LD_INT 1
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 2
80668: NEG
80669: PUSH
80670: LD_INT 0
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: NEG
80680: PUSH
80681: LD_INT 1
80683: NEG
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: LD_INT 1
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 3
80702: NEG
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 3
80713: NEG
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80741: LD_ADDR_VAR 0 13
80745: PUSH
80746: LD_INT 0
80748: PUSH
80749: LD_INT 0
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 0
80758: PUSH
80759: LD_INT 1
80761: NEG
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 1
80769: PUSH
80770: LD_INT 0
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 1
80779: PUSH
80780: LD_INT 1
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 1
80799: NEG
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: NEG
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 1
80822: NEG
80823: PUSH
80824: LD_INT 2
80826: NEG
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 2
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 2
80844: PUSH
80845: LD_INT 2
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 1
80854: PUSH
80855: LD_INT 2
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: NEG
80865: PUSH
80866: LD_INT 1
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 2
80876: NEG
80877: PUSH
80878: LD_INT 2
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 2
80888: NEG
80889: PUSH
80890: LD_INT 3
80892: NEG
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 3
80900: NEG
80901: PUSH
80902: LD_INT 2
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 3
80912: NEG
80913: PUSH
80914: LD_INT 3
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80940: LD_ADDR_VAR 0 14
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 1
80960: NEG
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 2
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 0
81033: PUSH
81034: LD_INT 2
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 1
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: LD_INT 2
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: LD_INT 1
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 1
81086: NEG
81087: PUSH
81088: LD_INT 3
81090: NEG
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 0
81098: PUSH
81099: LD_INT 3
81101: NEG
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: LD_INT 2
81112: NEG
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81136: LD_ADDR_VAR 0 15
81140: PUSH
81141: LD_INT 0
81143: PUSH
81144: LD_INT 0
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 0
81153: PUSH
81154: LD_INT 1
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: LD_INT 0
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: LD_INT 1
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 0
81184: PUSH
81185: LD_INT 1
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 1
81194: NEG
81195: PUSH
81196: LD_INT 0
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: PUSH
81203: LD_INT 1
81205: NEG
81206: PUSH
81207: LD_INT 1
81209: NEG
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 2
81228: PUSH
81229: LD_INT 0
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 2
81238: PUSH
81239: LD_INT 1
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 1
81248: NEG
81249: PUSH
81250: LD_INT 1
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 2
81259: NEG
81260: PUSH
81261: LD_INT 0
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: LD_INT 1
81274: NEG
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 2
81282: PUSH
81283: LD_INT 1
81285: NEG
81286: PUSH
81287: EMPTY
81288: LIST
81289: LIST
81290: PUSH
81291: LD_INT 3
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 3
81303: PUSH
81304: LD_INT 1
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81329: LD_ADDR_VAR 0 16
81333: PUSH
81334: LD_INT 0
81336: PUSH
81337: LD_INT 0
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 1
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: LD_INT 0
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: LD_INT 1
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 0
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 1
81387: NEG
81388: PUSH
81389: LD_INT 0
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 1
81398: NEG
81399: PUSH
81400: LD_INT 1
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: NEG
81411: PUSH
81412: LD_INT 2
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 2
81422: PUSH
81423: LD_INT 1
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 2
81432: PUSH
81433: LD_INT 2
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 1
81442: PUSH
81443: LD_INT 2
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 2
81452: NEG
81453: PUSH
81454: LD_INT 1
81456: NEG
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: PUSH
81462: LD_INT 2
81464: NEG
81465: PUSH
81466: LD_INT 2
81468: NEG
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 3
81476: PUSH
81477: LD_INT 2
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 3
81486: PUSH
81487: LD_INT 3
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 2
81496: PUSH
81497: LD_INT 3
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81522: LD_ADDR_VAR 0 17
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 0
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 0
81539: PUSH
81540: LD_INT 1
81542: NEG
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 1
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: EMPTY
81555: LIST
81556: LIST
81557: PUSH
81558: LD_INT 1
81560: PUSH
81561: LD_INT 1
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: LD_INT 1
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 1
81580: NEG
81581: PUSH
81582: LD_INT 0
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 1
81591: NEG
81592: PUSH
81593: LD_INT 1
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 1
81603: NEG
81604: PUSH
81605: LD_INT 2
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 0
81615: PUSH
81616: LD_INT 2
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 1
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: LD_INT 2
81637: PUSH
81638: LD_INT 0
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 2
81647: PUSH
81648: LD_INT 1
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 2
81657: PUSH
81658: LD_INT 2
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 1
81667: PUSH
81668: LD_INT 2
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: LD_INT 2
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 1
81687: NEG
81688: PUSH
81689: LD_INT 1
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 2
81698: NEG
81699: PUSH
81700: LD_INT 0
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 2
81709: NEG
81710: PUSH
81711: LD_INT 1
81713: NEG
81714: PUSH
81715: EMPTY
81716: LIST
81717: LIST
81718: PUSH
81719: LD_INT 2
81721: NEG
81722: PUSH
81723: LD_INT 2
81725: NEG
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81752: LD_ADDR_VAR 0 18
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: LD_INT 0
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: LD_INT 1
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 1
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 1
81790: PUSH
81791: LD_INT 1
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: LD_INT 0
81800: PUSH
81801: LD_INT 1
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 1
81810: NEG
81811: PUSH
81812: LD_INT 0
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 1
81821: NEG
81822: PUSH
81823: LD_INT 1
81825: NEG
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: LD_INT 2
81837: NEG
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 0
81845: PUSH
81846: LD_INT 2
81848: NEG
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 1
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 2
81867: PUSH
81868: LD_INT 0
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 2
81877: PUSH
81878: LD_INT 1
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: LD_INT 2
81890: PUSH
81891: EMPTY
81892: LIST
81893: LIST
81894: PUSH
81895: LD_INT 1
81897: PUSH
81898: LD_INT 2
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 0
81907: PUSH
81908: LD_INT 2
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 1
81917: NEG
81918: PUSH
81919: LD_INT 1
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: LD_INT 0
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 2
81939: NEG
81940: PUSH
81941: LD_INT 1
81943: NEG
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PUSH
81949: LD_INT 2
81951: NEG
81952: PUSH
81953: LD_INT 2
81955: NEG
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81982: LD_ADDR_VAR 0 19
81986: PUSH
81987: LD_INT 0
81989: PUSH
81990: LD_INT 0
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: LD_INT 1
82002: NEG
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: PUSH
82008: LD_INT 1
82010: PUSH
82011: LD_INT 0
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 1
82020: PUSH
82021: LD_INT 1
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: LD_INT 1
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 1
82040: NEG
82041: PUSH
82042: LD_INT 0
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 1
82051: NEG
82052: PUSH
82053: LD_INT 1
82055: NEG
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 1
82063: NEG
82064: PUSH
82065: LD_INT 2
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 0
82075: PUSH
82076: LD_INT 2
82078: NEG
82079: PUSH
82080: EMPTY
82081: LIST
82082: LIST
82083: PUSH
82084: LD_INT 1
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 2
82097: PUSH
82098: LD_INT 0
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: LD_INT 2
82107: PUSH
82108: LD_INT 1
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 2
82117: PUSH
82118: LD_INT 2
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 1
82127: PUSH
82128: LD_INT 2
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 0
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 2
82158: NEG
82159: PUSH
82160: LD_INT 0
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 2
82169: NEG
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 2
82181: NEG
82182: PUSH
82183: LD_INT 2
82185: NEG
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82212: LD_ADDR_VAR 0 20
82216: PUSH
82217: LD_INT 0
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: LD_INT 1
82232: NEG
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 1
82240: PUSH
82241: LD_INT 0
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: LD_INT 1
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 1
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 1
82270: NEG
82271: PUSH
82272: LD_INT 0
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 1
82281: NEG
82282: PUSH
82283: LD_INT 1
82285: NEG
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 1
82293: NEG
82294: PUSH
82295: LD_INT 2
82297: NEG
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 0
82305: PUSH
82306: LD_INT 2
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 1
82316: PUSH
82317: LD_INT 1
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 2
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 2
82337: PUSH
82338: LD_INT 1
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 2
82347: PUSH
82348: LD_INT 2
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 1
82357: PUSH
82358: LD_INT 2
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: LD_INT 2
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: NEG
82378: PUSH
82379: LD_INT 1
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 2
82388: NEG
82389: PUSH
82390: LD_INT 0
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 2
82399: NEG
82400: PUSH
82401: LD_INT 1
82403: NEG
82404: PUSH
82405: EMPTY
82406: LIST
82407: LIST
82408: PUSH
82409: LD_INT 2
82411: NEG
82412: PUSH
82413: LD_INT 2
82415: NEG
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82442: LD_ADDR_VAR 0 21
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: LD_INT 0
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: LD_INT 1
82462: NEG
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 1
82470: PUSH
82471: LD_INT 0
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: LD_INT 1
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: LD_INT 1
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: LD_INT 0
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 1
82511: NEG
82512: PUSH
82513: LD_INT 1
82515: NEG
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: LD_INT 1
82523: NEG
82524: PUSH
82525: LD_INT 2
82527: NEG
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 0
82535: PUSH
82536: LD_INT 2
82538: NEG
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 1
82546: PUSH
82547: LD_INT 1
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 2
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: PUSH
82568: LD_INT 1
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: LD_INT 2
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 1
82587: PUSH
82588: LD_INT 2
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 2
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 1
82607: NEG
82608: PUSH
82609: LD_INT 1
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: LD_INT 0
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 2
82629: NEG
82630: PUSH
82631: LD_INT 1
82633: NEG
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 2
82641: NEG
82642: PUSH
82643: LD_INT 2
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82672: LD_ADDR_VAR 0 22
82676: PUSH
82677: LD_INT 0
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: LD_INT 1
82692: NEG
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 1
82700: PUSH
82701: LD_INT 0
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 1
82710: PUSH
82711: LD_INT 1
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: LD_INT 1
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 1
82730: NEG
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 1
82741: NEG
82742: PUSH
82743: LD_INT 1
82745: NEG
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: NEG
82754: PUSH
82755: LD_INT 2
82757: NEG
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 0
82765: PUSH
82766: LD_INT 2
82768: NEG
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: PUSH
82777: LD_INT 1
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 2
82787: PUSH
82788: LD_INT 0
82790: PUSH
82791: EMPTY
82792: LIST
82793: LIST
82794: PUSH
82795: LD_INT 2
82797: PUSH
82798: LD_INT 1
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 2
82807: PUSH
82808: LD_INT 2
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 1
82817: PUSH
82818: LD_INT 2
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 0
82827: PUSH
82828: LD_INT 2
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 1
82837: NEG
82838: PUSH
82839: LD_INT 1
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 2
82848: NEG
82849: PUSH
82850: LD_INT 0
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 2
82859: NEG
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 2
82871: NEG
82872: PUSH
82873: LD_INT 2
82875: NEG
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82902: LD_ADDR_VAR 0 23
82906: PUSH
82907: LD_INT 0
82909: PUSH
82910: LD_INT 0
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: LD_INT 1
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: PUSH
82931: LD_INT 0
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 1
82940: PUSH
82941: LD_INT 1
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: LD_INT 1
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: LD_INT 0
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 1
82971: NEG
82972: PUSH
82973: LD_INT 1
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 1
82983: NEG
82984: PUSH
82985: LD_INT 2
82987: NEG
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 0
82995: PUSH
82996: LD_INT 2
82998: NEG
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 1
83006: PUSH
83007: LD_INT 1
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 2
83017: PUSH
83018: LD_INT 0
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 2
83027: PUSH
83028: LD_INT 1
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 2
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: PUSH
83048: LD_INT 2
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 0
83057: PUSH
83058: LD_INT 2
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 1
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 2
83078: NEG
83079: PUSH
83080: LD_INT 0
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 2
83089: NEG
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: NEG
83102: PUSH
83103: LD_INT 2
83105: NEG
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 2
83113: NEG
83114: PUSH
83115: LD_INT 3
83117: NEG
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 1
83125: NEG
83126: PUSH
83127: LD_INT 3
83129: NEG
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 1
83137: PUSH
83138: LD_INT 2
83140: NEG
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 2
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83182: LD_ADDR_VAR 0 24
83186: PUSH
83187: LD_INT 0
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: LD_INT 1
83202: NEG
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 1
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 1
83220: PUSH
83221: LD_INT 1
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 0
83230: PUSH
83231: LD_INT 1
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 1
83240: NEG
83241: PUSH
83242: LD_INT 0
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: NEG
83252: PUSH
83253: LD_INT 1
83255: NEG
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 1
83263: NEG
83264: PUSH
83265: LD_INT 2
83267: NEG
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 0
83275: PUSH
83276: LD_INT 2
83278: NEG
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 1
83286: PUSH
83287: LD_INT 1
83289: NEG
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 2
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 2
83307: PUSH
83308: LD_INT 1
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: PUSH
83318: LD_INT 2
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: LD_INT 2
83330: PUSH
83331: EMPTY
83332: LIST
83333: LIST
83334: PUSH
83335: LD_INT 0
83337: PUSH
83338: LD_INT 2
83340: PUSH
83341: EMPTY
83342: LIST
83343: LIST
83344: PUSH
83345: LD_INT 1
83347: NEG
83348: PUSH
83349: LD_INT 1
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 2
83358: NEG
83359: PUSH
83360: LD_INT 0
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 2
83369: NEG
83370: PUSH
83371: LD_INT 1
83373: NEG
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 2
83381: NEG
83382: PUSH
83383: LD_INT 2
83385: NEG
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PUSH
83391: LD_INT 1
83393: PUSH
83394: LD_INT 2
83396: NEG
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 2
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 3
83415: PUSH
83416: LD_INT 1
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 3
83425: PUSH
83426: LD_INT 2
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83458: LD_ADDR_VAR 0 25
83462: PUSH
83463: LD_INT 0
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 0
83475: PUSH
83476: LD_INT 1
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 1
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 1
83496: PUSH
83497: LD_INT 1
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: LD_INT 1
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: NEG
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 1
83527: NEG
83528: PUSH
83529: LD_INT 1
83531: NEG
83532: PUSH
83533: EMPTY
83534: LIST
83535: LIST
83536: PUSH
83537: LD_INT 1
83539: NEG
83540: PUSH
83541: LD_INT 2
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: LD_INT 2
83554: NEG
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: LD_INT 1
83565: NEG
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_INT 2
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 2
83583: PUSH
83584: LD_INT 1
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 2
83593: PUSH
83594: LD_INT 2
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 2
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 0
83613: PUSH
83614: LD_INT 2
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 1
83623: NEG
83624: PUSH
83625: LD_INT 1
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 2
83634: NEG
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 2
83645: NEG
83646: PUSH
83647: LD_INT 1
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 2
83657: NEG
83658: PUSH
83659: LD_INT 2
83661: NEG
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 3
83669: PUSH
83670: LD_INT 1
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 3
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 2
83689: PUSH
83690: LD_INT 3
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 1
83699: PUSH
83700: LD_INT 3
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83732: LD_ADDR_VAR 0 26
83736: PUSH
83737: LD_INT 0
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 0
83749: PUSH
83750: LD_INT 1
83752: NEG
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 1
83760: PUSH
83761: LD_INT 0
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PUSH
83768: LD_INT 1
83770: PUSH
83771: LD_INT 1
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: LD_INT 0
83780: PUSH
83781: LD_INT 1
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 1
83790: NEG
83791: PUSH
83792: LD_INT 0
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: NEG
83802: PUSH
83803: LD_INT 1
83805: NEG
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 1
83813: NEG
83814: PUSH
83815: LD_INT 2
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 0
83825: PUSH
83826: LD_INT 2
83828: NEG
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 1
83836: PUSH
83837: LD_INT 1
83839: NEG
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 2
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PUSH
83855: LD_INT 2
83857: PUSH
83858: LD_INT 1
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 2
83867: PUSH
83868: LD_INT 2
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 1
83877: PUSH
83878: LD_INT 2
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: LD_INT 2
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 1
83897: NEG
83898: PUSH
83899: LD_INT 1
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: LD_INT 0
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 2
83919: NEG
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 2
83931: NEG
83932: PUSH
83933: LD_INT 2
83935: NEG
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 2
83943: PUSH
83944: LD_INT 3
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: PUSH
83954: LD_INT 3
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: LD_INT 2
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 2
83974: NEG
83975: PUSH
83976: LD_INT 1
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84008: LD_ADDR_VAR 0 27
84012: PUSH
84013: LD_INT 0
84015: PUSH
84016: LD_INT 0
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 0
84025: PUSH
84026: LD_INT 1
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 1
84036: PUSH
84037: LD_INT 0
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 1
84046: PUSH
84047: LD_INT 1
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 0
84056: PUSH
84057: LD_INT 1
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 1
84066: NEG
84067: PUSH
84068: LD_INT 0
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 1
84077: NEG
84078: PUSH
84079: LD_INT 1
84081: NEG
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 1
84089: NEG
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 0
84101: PUSH
84102: LD_INT 2
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 1
84112: PUSH
84113: LD_INT 1
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 2
84123: PUSH
84124: LD_INT 0
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: LD_INT 2
84133: PUSH
84134: LD_INT 1
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 2
84143: PUSH
84144: LD_INT 2
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: PUSH
84151: LD_INT 1
84153: PUSH
84154: LD_INT 2
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: LD_INT 0
84163: PUSH
84164: LD_INT 2
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: NEG
84174: PUSH
84175: LD_INT 1
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 2
84184: NEG
84185: PUSH
84186: LD_INT 0
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 2
84195: NEG
84196: PUSH
84197: LD_INT 1
84199: NEG
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 2
84207: NEG
84208: PUSH
84209: LD_INT 2
84211: NEG
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: PUSH
84217: LD_INT 1
84219: NEG
84220: PUSH
84221: LD_INT 2
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 3
84241: NEG
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 3
84253: NEG
84254: PUSH
84255: LD_INT 2
84257: NEG
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84288: LD_ADDR_VAR 0 28
84292: PUSH
84293: LD_INT 0
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 0
84305: PUSH
84306: LD_INT 1
84308: NEG
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: LD_INT 1
84316: PUSH
84317: LD_INT 0
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 1
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: EMPTY
84331: LIST
84332: LIST
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: LD_INT 1
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: LD_INT 0
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 1
84357: NEG
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: LD_INT 2
84373: NEG
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 0
84381: PUSH
84382: LD_INT 2
84384: NEG
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: PUSH
84393: LD_INT 1
84395: NEG
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 2
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 2
84413: PUSH
84414: LD_INT 1
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: PUSH
84421: LD_INT 2
84423: PUSH
84424: LD_INT 2
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 1
84433: PUSH
84434: LD_INT 2
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 0
84443: PUSH
84444: LD_INT 2
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 1
84453: NEG
84454: PUSH
84455: LD_INT 1
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 2
84464: NEG
84465: PUSH
84466: LD_INT 0
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 2
84475: NEG
84476: PUSH
84477: LD_INT 1
84479: NEG
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 2
84487: NEG
84488: PUSH
84489: LD_INT 2
84491: NEG
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 2
84499: NEG
84500: PUSH
84501: LD_INT 3
84503: NEG
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 1
84511: NEG
84512: PUSH
84513: LD_INT 3
84515: NEG
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 3
84523: NEG
84524: PUSH
84525: LD_INT 1
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 3
84535: NEG
84536: PUSH
84537: LD_INT 2
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84570: LD_ADDR_VAR 0 29
84574: PUSH
84575: LD_INT 0
84577: PUSH
84578: LD_INT 0
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: LD_INT 1
84590: NEG
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: LD_INT 0
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 1
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: LD_INT 1
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 1
84639: NEG
84640: PUSH
84641: LD_INT 1
84643: NEG
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 1
84651: NEG
84652: PUSH
84653: LD_INT 2
84655: NEG
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 0
84663: PUSH
84664: LD_INT 2
84666: NEG
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: LD_INT 1
84677: NEG
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 2
84685: PUSH
84686: LD_INT 0
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 2
84695: PUSH
84696: LD_INT 1
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 1
84705: PUSH
84706: LD_INT 2
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 1
84725: NEG
84726: PUSH
84727: LD_INT 1
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 2
84736: NEG
84737: PUSH
84738: LD_INT 1
84740: NEG
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 2
84748: NEG
84749: PUSH
84750: LD_INT 2
84752: NEG
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 2
84760: NEG
84761: PUSH
84762: LD_INT 3
84764: NEG
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 2
84772: PUSH
84773: LD_INT 1
84775: NEG
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 3
84783: PUSH
84784: LD_INT 1
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 1
84793: PUSH
84794: LD_INT 3
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 1
84803: NEG
84804: PUSH
84805: LD_INT 2
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 3
84814: NEG
84815: PUSH
84816: LD_INT 2
84818: NEG
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84849: LD_ADDR_VAR 0 30
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 0
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: NEG
84931: PUSH
84932: LD_INT 2
84934: NEG
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 0
84942: PUSH
84943: LD_INT 2
84945: NEG
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 1
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 0
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 2
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 1
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: EMPTY
85010: LIST
85011: LIST
85012: PUSH
85013: LD_INT 2
85015: NEG
85016: PUSH
85017: LD_INT 0
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: PUSH
85024: LD_INT 2
85026: NEG
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: EMPTY
85033: LIST
85034: LIST
85035: PUSH
85036: LD_INT 1
85038: NEG
85039: PUSH
85040: LD_INT 3
85042: NEG
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 1
85050: PUSH
85051: LD_INT 2
85053: NEG
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 3
85061: PUSH
85062: LD_INT 2
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 2
85071: PUSH
85072: LD_INT 3
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 2
85081: NEG
85082: PUSH
85083: LD_INT 1
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 3
85092: NEG
85093: PUSH
85094: LD_INT 1
85096: NEG
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85127: LD_ADDR_VAR 0 31
85131: PUSH
85132: LD_INT 0
85134: PUSH
85135: LD_INT 0
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: LD_INT 1
85147: NEG
85148: PUSH
85149: EMPTY
85150: LIST
85151: LIST
85152: PUSH
85153: LD_INT 1
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 1
85165: PUSH
85166: LD_INT 1
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 0
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 1
85185: NEG
85186: PUSH
85187: LD_INT 0
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 1
85196: NEG
85197: PUSH
85198: LD_INT 1
85200: NEG
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 1
85208: NEG
85209: PUSH
85210: LD_INT 2
85212: NEG
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 1
85220: PUSH
85221: LD_INT 1
85223: NEG
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 2
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 2
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 2
85251: PUSH
85252: LD_INT 2
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: NEG
85282: PUSH
85283: LD_INT 1
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 2
85292: NEG
85293: PUSH
85294: LD_INT 1
85296: NEG
85297: PUSH
85298: EMPTY
85299: LIST
85300: LIST
85301: PUSH
85302: LD_INT 2
85304: NEG
85305: PUSH
85306: LD_INT 2
85308: NEG
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 2
85316: NEG
85317: PUSH
85318: LD_INT 3
85320: NEG
85321: PUSH
85322: EMPTY
85323: LIST
85324: LIST
85325: PUSH
85326: LD_INT 2
85328: PUSH
85329: LD_INT 1
85331: NEG
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: LD_INT 3
85339: PUSH
85340: LD_INT 1
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: PUSH
85347: LD_INT 1
85349: PUSH
85350: LD_INT 3
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: PUSH
85357: LD_INT 1
85359: NEG
85360: PUSH
85361: LD_INT 2
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 3
85370: NEG
85371: PUSH
85372: LD_INT 2
85374: NEG
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85405: LD_ADDR_VAR 0 32
85409: PUSH
85410: LD_INT 0
85412: PUSH
85413: LD_INT 0
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 1
85433: PUSH
85434: LD_INT 0
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: PUSH
85444: LD_INT 1
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: LD_INT 0
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 1
85463: NEG
85464: PUSH
85465: LD_INT 0
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: NEG
85475: PUSH
85476: LD_INT 1
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 1
85486: NEG
85487: PUSH
85488: LD_INT 2
85490: NEG
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: LD_INT 2
85501: NEG
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 2
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 2
85530: PUSH
85531: LD_INT 2
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: PUSH
85538: LD_INT 1
85540: PUSH
85541: LD_INT 2
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 0
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 1
85560: NEG
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 2
85571: NEG
85572: PUSH
85573: LD_INT 0
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 2
85582: NEG
85583: PUSH
85584: LD_INT 1
85586: NEG
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 1
85594: NEG
85595: PUSH
85596: LD_INT 3
85598: NEG
85599: PUSH
85600: EMPTY
85601: LIST
85602: LIST
85603: PUSH
85604: LD_INT 1
85606: PUSH
85607: LD_INT 2
85609: NEG
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 3
85617: PUSH
85618: LD_INT 2
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: PUSH
85625: LD_INT 2
85627: PUSH
85628: LD_INT 3
85630: PUSH
85631: EMPTY
85632: LIST
85633: LIST
85634: PUSH
85635: LD_INT 2
85637: NEG
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 3
85648: NEG
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85683: LD_ADDR_VAR 0 33
85687: PUSH
85688: LD_INT 0
85690: PUSH
85691: LD_INT 0
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: LD_INT 1
85703: NEG
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PUSH
85709: LD_INT 1
85711: PUSH
85712: LD_INT 0
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: LD_INT 1
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 0
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 1
85752: NEG
85753: PUSH
85754: LD_INT 1
85756: NEG
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 1
85764: NEG
85765: PUSH
85766: LD_INT 2
85768: NEG
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: PUSH
85777: LD_INT 1
85779: NEG
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 2
85787: PUSH
85788: LD_INT 0
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 2
85797: PUSH
85798: LD_INT 1
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 1
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: NEG
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 2
85849: NEG
85850: PUSH
85851: LD_INT 1
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 2
85861: NEG
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 2
85873: NEG
85874: PUSH
85875: LD_INT 3
85877: NEG
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 2
85885: PUSH
85886: LD_INT 1
85888: NEG
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 3
85896: PUSH
85897: LD_INT 1
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 1
85906: PUSH
85907: LD_INT 3
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 2
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 3
85927: NEG
85928: PUSH
85929: LD_INT 2
85931: NEG
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85962: LD_ADDR_VAR 0 34
85966: PUSH
85967: LD_INT 0
85969: PUSH
85970: LD_INT 0
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 0
85979: PUSH
85980: LD_INT 1
85982: NEG
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 1
85990: PUSH
85991: LD_INT 0
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: PUSH
86001: LD_INT 1
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 1
86020: NEG
86021: PUSH
86022: LD_INT 0
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 1
86043: NEG
86044: PUSH
86045: LD_INT 2
86047: NEG
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 0
86055: PUSH
86056: LD_INT 2
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 1
86066: PUSH
86067: LD_INT 1
86069: NEG
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 2
86077: PUSH
86078: LD_INT 1
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 2
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 2
86118: NEG
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: NEG
86130: PUSH
86131: LD_INT 1
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 2
86141: NEG
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 1
86153: NEG
86154: PUSH
86155: LD_INT 3
86157: NEG
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 1
86165: PUSH
86166: LD_INT 2
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 3
86176: PUSH
86177: LD_INT 2
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 2
86186: PUSH
86187: LD_INT 3
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 2
86196: NEG
86197: PUSH
86198: LD_INT 1
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: PUSH
86205: LD_INT 3
86207: NEG
86208: PUSH
86209: LD_INT 1
86211: NEG
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86242: LD_ADDR_VAR 0 35
86246: PUSH
86247: LD_INT 0
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 0
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: EMPTY
86275: LIST
86276: LIST
86277: PUSH
86278: LD_INT 1
86280: PUSH
86281: LD_INT 1
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 0
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: LD_INT 1
86300: NEG
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: LD_INT 1
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 2
86333: NEG
86334: PUSH
86335: LD_INT 1
86337: NEG
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86354: LD_ADDR_VAR 0 36
86358: PUSH
86359: LD_INT 0
86361: PUSH
86362: LD_INT 0
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: LD_INT 1
86374: NEG
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 1
86382: PUSH
86383: LD_INT 0
86385: PUSH
86386: EMPTY
86387: LIST
86388: LIST
86389: PUSH
86390: LD_INT 1
86392: PUSH
86393: LD_INT 1
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: PUSH
86400: LD_INT 0
86402: PUSH
86403: LD_INT 1
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: LD_INT 1
86412: NEG
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: LD_INT 1
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 1
86435: NEG
86436: PUSH
86437: LD_INT 2
86439: NEG
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 1
86447: PUSH
86448: LD_INT 2
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86466: LD_ADDR_VAR 0 37
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: LD_INT 0
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: LD_INT 0
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: LD_INT 1
86507: PUSH
86508: EMPTY
86509: LIST
86510: LIST
86511: PUSH
86512: LD_INT 0
86514: PUSH
86515: LD_INT 1
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: LD_INT 1
86524: NEG
86525: PUSH
86526: LD_INT 0
86528: PUSH
86529: EMPTY
86530: LIST
86531: LIST
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: LD_INT 1
86539: NEG
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 1
86547: PUSH
86548: LD_INT 1
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 1
86558: NEG
86559: PUSH
86560: LD_INT 1
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86578: LD_ADDR_VAR 0 38
86582: PUSH
86583: LD_INT 0
86585: PUSH
86586: LD_INT 0
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 0
86595: PUSH
86596: LD_INT 1
86598: NEG
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 1
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: LD_INT 1
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 0
86626: PUSH
86627: LD_INT 1
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: NEG
86637: PUSH
86638: LD_INT 0
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 1
86647: NEG
86648: PUSH
86649: LD_INT 1
86651: NEG
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 2
86669: NEG
86670: PUSH
86671: LD_INT 1
86673: NEG
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86690: LD_ADDR_VAR 0 39
86694: PUSH
86695: LD_INT 0
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 0
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: LD_INT 0
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 1
86728: PUSH
86729: LD_INT 1
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 0
86738: PUSH
86739: LD_INT 1
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 1
86748: NEG
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 1
86759: NEG
86760: PUSH
86761: LD_INT 1
86763: NEG
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: NEG
86772: PUSH
86773: LD_INT 2
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: LD_INT 2
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86802: LD_ADDR_VAR 0 40
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: LD_INT 0
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 0
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 1
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 0
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 1
86860: NEG
86861: PUSH
86862: LD_INT 0
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 1
86871: NEG
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 1
86883: PUSH
86884: LD_INT 1
86886: NEG
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 1
86894: NEG
86895: PUSH
86896: LD_INT 1
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86914: LD_ADDR_VAR 0 41
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: LD_INT 0
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 0
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 1
86942: PUSH
86943: LD_INT 0
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 0
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: NEG
86973: PUSH
86974: LD_INT 0
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 1
86983: NEG
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: LD_INT 2
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 1
87007: PUSH
87008: LD_INT 1
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 2
87018: PUSH
87019: LD_INT 0
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PUSH
87026: LD_INT 2
87028: PUSH
87029: LD_INT 1
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 2
87038: PUSH
87039: LD_INT 2
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: LD_INT 2
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 2
87069: NEG
87070: PUSH
87071: LD_INT 0
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 2
87080: NEG
87081: PUSH
87082: LD_INT 1
87084: NEG
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 2
87092: NEG
87093: PUSH
87094: LD_INT 2
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 2
87104: NEG
87105: PUSH
87106: LD_INT 3
87108: NEG
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 2
87116: PUSH
87117: LD_INT 1
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 3
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 3
87137: PUSH
87138: LD_INT 1
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 3
87147: PUSH
87148: LD_INT 2
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 3
87157: PUSH
87158: LD_INT 3
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 2
87167: PUSH
87168: LD_INT 3
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 2
87177: NEG
87178: PUSH
87179: LD_INT 1
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 3
87188: NEG
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 3
87199: NEG
87200: PUSH
87201: LD_INT 1
87203: NEG
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 3
87211: NEG
87212: PUSH
87213: LD_INT 2
87215: NEG
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 3
87223: NEG
87224: PUSH
87225: LD_INT 3
87227: NEG
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87264: LD_ADDR_VAR 0 42
87268: PUSH
87269: LD_INT 0
87271: PUSH
87272: LD_INT 0
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 0
87281: PUSH
87282: LD_INT 1
87284: NEG
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 1
87292: PUSH
87293: LD_INT 0
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: LD_INT 1
87302: PUSH
87303: LD_INT 1
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 0
87312: PUSH
87313: LD_INT 1
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 1
87322: NEG
87323: PUSH
87324: LD_INT 0
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: LD_INT 1
87337: NEG
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 1
87345: NEG
87346: PUSH
87347: LD_INT 2
87349: NEG
87350: PUSH
87351: EMPTY
87352: LIST
87353: LIST
87354: PUSH
87355: LD_INT 0
87357: PUSH
87358: LD_INT 2
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 1
87368: PUSH
87369: LD_INT 1
87371: NEG
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 2
87379: PUSH
87380: LD_INT 1
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 2
87389: PUSH
87390: LD_INT 2
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 1
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 0
87409: PUSH
87410: LD_INT 2
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: LD_INT 1
87423: PUSH
87424: EMPTY
87425: LIST
87426: LIST
87427: PUSH
87428: LD_INT 2
87430: NEG
87431: PUSH
87432: LD_INT 1
87434: NEG
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 2
87442: NEG
87443: PUSH
87444: LD_INT 2
87446: NEG
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 2
87454: NEG
87455: PUSH
87456: LD_INT 3
87458: NEG
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: LD_INT 3
87470: NEG
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 0
87478: PUSH
87479: LD_INT 3
87481: NEG
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 1
87489: PUSH
87490: LD_INT 2
87492: NEG
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 3
87500: PUSH
87501: LD_INT 2
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 3
87510: PUSH
87511: LD_INT 3
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 2
87520: PUSH
87521: LD_INT 3
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: LD_INT 3
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: LD_INT 3
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 1
87550: NEG
87551: PUSH
87552: LD_INT 2
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 3
87561: NEG
87562: PUSH
87563: LD_INT 2
87565: NEG
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 3
87573: NEG
87574: PUSH
87575: LD_INT 3
87577: NEG
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87614: LD_ADDR_VAR 0 43
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: LD_INT 0
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 0
87631: PUSH
87632: LD_INT 1
87634: NEG
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 1
87652: PUSH
87653: LD_INT 1
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 0
87662: PUSH
87663: LD_INT 1
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: NEG
87673: PUSH
87674: LD_INT 0
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: LD_INT 1
87687: NEG
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: PUSH
87693: LD_INT 1
87695: NEG
87696: PUSH
87697: LD_INT 2
87699: NEG
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 0
87707: PUSH
87708: LD_INT 2
87710: NEG
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 1
87718: PUSH
87719: LD_INT 1
87721: NEG
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 2
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: PUSH
87737: LD_INT 2
87739: PUSH
87740: LD_INT 1
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 1
87749: PUSH
87750: LD_INT 2
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: LD_INT 0
87759: PUSH
87760: LD_INT 2
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: LD_INT 1
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: PUSH
87778: LD_INT 2
87780: NEG
87781: PUSH
87782: LD_INT 0
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 2
87791: NEG
87792: PUSH
87793: LD_INT 1
87795: NEG
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 1
87803: NEG
87804: PUSH
87805: LD_INT 3
87807: NEG
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 0
87815: PUSH
87816: LD_INT 3
87818: NEG
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 1
87826: PUSH
87827: LD_INT 2
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: LD_INT 1
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 3
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 3
87858: PUSH
87859: LD_INT 1
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: LD_INT 3
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: LD_INT 3
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 2
87899: NEG
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 3
87910: NEG
87911: PUSH
87912: LD_INT 0
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 3
87921: NEG
87922: PUSH
87923: LD_INT 1
87925: NEG
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: LIST
87938: LIST
87939: LIST
87940: LIST
87941: LIST
87942: LIST
87943: LIST
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: LIST
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87962: LD_ADDR_VAR 0 44
87966: PUSH
87967: LD_INT 0
87969: PUSH
87970: LD_INT 0
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 0
87979: PUSH
87980: LD_INT 1
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 1
87990: PUSH
87991: LD_INT 0
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: LD_INT 1
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 1
88020: NEG
88021: PUSH
88022: LD_INT 0
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 1
88031: NEG
88032: PUSH
88033: LD_INT 1
88035: NEG
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 1
88043: NEG
88044: PUSH
88045: LD_INT 2
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 2
88066: PUSH
88067: LD_INT 0
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 2
88076: PUSH
88077: LD_INT 1
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 2
88086: PUSH
88087: LD_INT 2
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 1
88096: PUSH
88097: LD_INT 2
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: LD_INT 1
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 2
88117: NEG
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 2
88128: NEG
88129: PUSH
88130: LD_INT 1
88132: NEG
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 2
88140: NEG
88141: PUSH
88142: LD_INT 2
88144: NEG
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 2
88152: NEG
88153: PUSH
88154: LD_INT 3
88156: NEG
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 2
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 3
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 3
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 3
88195: PUSH
88196: LD_INT 2
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 3
88205: PUSH
88206: LD_INT 3
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 2
88215: PUSH
88216: LD_INT 3
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: LD_INT 2
88225: NEG
88226: PUSH
88227: LD_INT 1
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: PUSH
88234: LD_INT 3
88236: NEG
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 3
88247: NEG
88248: PUSH
88249: LD_INT 1
88251: NEG
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 3
88259: NEG
88260: PUSH
88261: LD_INT 2
88263: NEG
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 3
88271: NEG
88272: PUSH
88273: LD_INT 3
88275: NEG
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88312: LD_ADDR_VAR 0 45
88316: PUSH
88317: LD_INT 0
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: LD_INT 1
88332: NEG
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 1
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 1
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 0
88360: PUSH
88361: LD_INT 1
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 1
88370: NEG
88371: PUSH
88372: LD_INT 0
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 1
88381: NEG
88382: PUSH
88383: LD_INT 1
88385: NEG
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: LD_INT 1
88393: NEG
88394: PUSH
88395: LD_INT 2
88397: NEG
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: PUSH
88403: LD_INT 0
88405: PUSH
88406: LD_INT 2
88408: NEG
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 1
88416: PUSH
88417: LD_INT 1
88419: NEG
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 2
88427: PUSH
88428: LD_INT 1
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 2
88437: PUSH
88438: LD_INT 2
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: PUSH
88455: LD_INT 0
88457: PUSH
88458: LD_INT 2
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 1
88467: NEG
88468: PUSH
88469: LD_INT 1
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: PUSH
88476: LD_INT 2
88478: NEG
88479: PUSH
88480: LD_INT 1
88482: NEG
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 2
88490: NEG
88491: PUSH
88492: LD_INT 2
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 2
88502: NEG
88503: PUSH
88504: LD_INT 3
88506: NEG
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 1
88514: NEG
88515: PUSH
88516: LD_INT 3
88518: NEG
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 0
88526: PUSH
88527: LD_INT 3
88529: NEG
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 1
88537: PUSH
88538: LD_INT 2
88540: NEG
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 3
88548: PUSH
88549: LD_INT 2
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 3
88558: PUSH
88559: LD_INT 3
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 2
88568: PUSH
88569: LD_INT 3
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 1
88578: PUSH
88579: LD_INT 3
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 0
88588: PUSH
88589: LD_INT 3
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 1
88598: NEG
88599: PUSH
88600: LD_INT 2
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 3
88609: NEG
88610: PUSH
88611: LD_INT 2
88613: NEG
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 3
88621: NEG
88622: PUSH
88623: LD_INT 3
88625: NEG
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88662: LD_ADDR_VAR 0 46
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: LD_INT 0
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: LD_INT 1
88682: NEG
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: LD_INT 0
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 1
88700: PUSH
88701: LD_INT 1
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_INT 1
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 1
88720: NEG
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 1
88731: NEG
88732: PUSH
88733: LD_INT 1
88735: NEG
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: PUSH
88741: LD_INT 1
88743: NEG
88744: PUSH
88745: LD_INT 2
88747: NEG
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: LD_INT 2
88758: NEG
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 1
88766: PUSH
88767: LD_INT 1
88769: NEG
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 2
88777: PUSH
88778: LD_INT 0
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 2
88787: PUSH
88788: LD_INT 1
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 1
88797: PUSH
88798: LD_INT 2
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 0
88807: PUSH
88808: LD_INT 2
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 2
88828: NEG
88829: PUSH
88830: LD_INT 0
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 2
88839: NEG
88840: PUSH
88841: LD_INT 1
88843: NEG
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 1
88851: NEG
88852: PUSH
88853: LD_INT 3
88855: NEG
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 0
88863: PUSH
88864: LD_INT 3
88866: NEG
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 1
88874: PUSH
88875: LD_INT 2
88877: NEG
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PUSH
88883: LD_INT 2
88885: PUSH
88886: LD_INT 1
88888: NEG
88889: PUSH
88890: EMPTY
88891: LIST
88892: LIST
88893: PUSH
88894: LD_INT 3
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 3
88906: PUSH
88907: LD_INT 1
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 1
88916: PUSH
88917: LD_INT 3
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: LD_INT 3
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 2
88947: NEG
88948: PUSH
88949: LD_INT 1
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 3
88958: NEG
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 3
88969: NEG
88970: PUSH
88971: LD_INT 1
88973: NEG
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89010: LD_ADDR_VAR 0 47
89014: PUSH
89015: LD_INT 0
89017: PUSH
89018: LD_INT 0
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: LD_INT 1
89030: NEG
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: LD_INT 1
89038: PUSH
89039: LD_INT 0
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: PUSH
89049: LD_INT 1
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: LD_INT 1
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: LD_INT 1
89068: NEG
89069: PUSH
89070: LD_INT 0
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 1
89083: NEG
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 1
89091: NEG
89092: PUSH
89093: LD_INT 2
89095: NEG
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: LD_INT 2
89106: NEG
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 1
89114: PUSH
89115: LD_INT 1
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 2
89125: NEG
89126: PUSH
89127: LD_INT 1
89129: NEG
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 2
89137: NEG
89138: PUSH
89139: LD_INT 2
89141: NEG
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89161: LD_ADDR_VAR 0 48
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 0
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 0
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 1
89199: PUSH
89200: LD_INT 1
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 0
89209: PUSH
89210: LD_INT 1
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: LD_INT 1
89219: NEG
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 1
89230: NEG
89231: PUSH
89232: LD_INT 1
89234: NEG
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: NEG
89243: PUSH
89244: LD_INT 2
89246: NEG
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: LD_INT 2
89257: NEG
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 1
89265: PUSH
89266: LD_INT 1
89268: NEG
89269: PUSH
89270: EMPTY
89271: LIST
89272: LIST
89273: PUSH
89274: LD_INT 2
89276: PUSH
89277: LD_INT 0
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 2
89286: PUSH
89287: LD_INT 1
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89308: LD_ADDR_VAR 0 49
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 0
89325: PUSH
89326: LD_INT 1
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 1
89336: PUSH
89337: LD_INT 0
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: PUSH
89344: LD_INT 1
89346: PUSH
89347: LD_INT 1
89349: PUSH
89350: EMPTY
89351: LIST
89352: LIST
89353: PUSH
89354: LD_INT 0
89356: PUSH
89357: LD_INT 1
89359: PUSH
89360: EMPTY
89361: LIST
89362: LIST
89363: PUSH
89364: LD_INT 1
89366: NEG
89367: PUSH
89368: LD_INT 0
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 1
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: NEG
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: LD_INT 1
89392: NEG
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 2
89400: PUSH
89401: LD_INT 0
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 2
89410: PUSH
89411: LD_INT 1
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 2
89420: PUSH
89421: LD_INT 2
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 1
89430: PUSH
89431: LD_INT 2
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89452: LD_ADDR_VAR 0 50
89456: PUSH
89457: LD_INT 0
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: LD_INT 1
89472: NEG
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: LD_INT 0
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 1
89490: PUSH
89491: LD_INT 1
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 0
89500: PUSH
89501: LD_INT 1
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: PUSH
89508: LD_INT 1
89510: NEG
89511: PUSH
89512: LD_INT 0
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 1
89521: NEG
89522: PUSH
89523: LD_INT 1
89525: NEG
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 2
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 2
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 1
89553: PUSH
89554: LD_INT 2
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 0
89563: PUSH
89564: LD_INT 2
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 1
89573: NEG
89574: PUSH
89575: LD_INT 1
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89596: LD_ADDR_VAR 0 51
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 0
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: LD_INT 0
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 1
89665: NEG
89666: PUSH
89667: LD_INT 1
89669: NEG
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 1
89677: PUSH
89678: LD_INT 2
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: LD_INT 2
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 1
89697: NEG
89698: PUSH
89699: LD_INT 1
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 2
89708: NEG
89709: PUSH
89710: LD_INT 0
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 2
89719: NEG
89720: PUSH
89721: LD_INT 1
89723: NEG
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89743: LD_ADDR_VAR 0 52
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: LD_INT 0
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: LD_INT 1
89763: NEG
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: PUSH
89772: LD_INT 0
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 1
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: LD_INT 1
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 1
89801: NEG
89802: PUSH
89803: LD_INT 0
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 1
89812: NEG
89813: PUSH
89814: LD_INT 1
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 1
89824: NEG
89825: PUSH
89826: LD_INT 2
89828: NEG
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 1
89836: NEG
89837: PUSH
89838: LD_INT 1
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 2
89847: NEG
89848: PUSH
89849: LD_INT 0
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 2
89858: NEG
89859: PUSH
89860: LD_INT 1
89862: NEG
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 2
89870: NEG
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89894: LD_ADDR_VAR 0 53
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 0
89911: PUSH
89912: LD_INT 1
89914: NEG
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: PUSH
89920: LD_INT 1
89922: PUSH
89923: LD_INT 0
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 1
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: LD_INT 1
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 1
89952: NEG
89953: PUSH
89954: LD_INT 0
89956: PUSH
89957: EMPTY
89958: LIST
89959: LIST
89960: PUSH
89961: LD_INT 1
89963: NEG
89964: PUSH
89965: LD_INT 1
89967: NEG
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 1
89975: NEG
89976: PUSH
89977: LD_INT 2
89979: NEG
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: LD_INT 2
89990: NEG
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 1
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 2
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 2
90019: PUSH
90020: LD_INT 1
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 2
90029: PUSH
90030: LD_INT 2
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: LD_INT 1
90039: PUSH
90040: LD_INT 2
90042: PUSH
90043: EMPTY
90044: LIST
90045: LIST
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: LD_INT 2
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 1
90059: NEG
90060: PUSH
90061: LD_INT 1
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 2
90070: NEG
90071: PUSH
90072: LD_INT 0
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: NEG
90082: PUSH
90083: LD_INT 1
90085: NEG
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 2
90093: NEG
90094: PUSH
90095: LD_INT 2
90097: NEG
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90124: LD_ADDR_VAR 0 54
90128: PUSH
90129: LD_INT 0
90131: PUSH
90132: LD_INT 0
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 0
90141: PUSH
90142: LD_INT 1
90144: NEG
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 1
90152: PUSH
90153: LD_INT 0
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 1
90162: PUSH
90163: LD_INT 1
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 0
90172: PUSH
90173: LD_INT 1
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 1
90182: NEG
90183: PUSH
90184: LD_INT 0
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 1
90193: NEG
90194: PUSH
90195: LD_INT 1
90197: NEG
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: LD_INT 1
90205: NEG
90206: PUSH
90207: LD_INT 2
90209: NEG
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 0
90217: PUSH
90218: LD_INT 2
90220: NEG
90221: PUSH
90222: EMPTY
90223: LIST
90224: LIST
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: LD_INT 1
90231: NEG
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: LD_INT 2
90239: PUSH
90240: LD_INT 0
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: LD_INT 2
90249: PUSH
90250: LD_INT 1
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 2
90259: PUSH
90260: LD_INT 2
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 1
90269: PUSH
90270: LD_INT 2
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PUSH
90277: LD_INT 0
90279: PUSH
90280: LD_INT 2
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 1
90289: NEG
90290: PUSH
90291: LD_INT 1
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: PUSH
90298: LD_INT 2
90300: NEG
90301: PUSH
90302: LD_INT 0
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 2
90311: NEG
90312: PUSH
90313: LD_INT 1
90315: NEG
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 2
90323: NEG
90324: PUSH
90325: LD_INT 2
90327: NEG
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90354: LD_ADDR_VAR 0 55
90358: PUSH
90359: LD_INT 0
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 1
90382: PUSH
90383: LD_INT 0
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 1
90392: PUSH
90393: LD_INT 1
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 0
90402: PUSH
90403: LD_INT 1
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 1
90412: NEG
90413: PUSH
90414: LD_INT 0
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: LD_INT 1
90423: NEG
90424: PUSH
90425: LD_INT 1
90427: NEG
90428: PUSH
90429: EMPTY
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: LD_INT 2
90439: NEG
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 0
90447: PUSH
90448: LD_INT 2
90450: NEG
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: PUSH
90456: LD_INT 1
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 2
90469: PUSH
90470: LD_INT 0
90472: PUSH
90473: EMPTY
90474: LIST
90475: LIST
90476: PUSH
90477: LD_INT 2
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 2
90489: PUSH
90490: LD_INT 2
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 1
90499: PUSH
90500: LD_INT 2
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 0
90509: PUSH
90510: LD_INT 2
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 1
90519: NEG
90520: PUSH
90521: LD_INT 1
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: PUSH
90528: LD_INT 2
90530: NEG
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 2
90541: NEG
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 2
90553: NEG
90554: PUSH
90555: LD_INT 2
90557: NEG
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90584: LD_ADDR_VAR 0 56
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: LD_INT 0
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: LD_INT 1
90604: NEG
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_INT 1
90612: PUSH
90613: LD_INT 0
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: PUSH
90620: LD_INT 1
90622: PUSH
90623: LD_INT 1
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 0
90632: PUSH
90633: LD_INT 1
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 1
90642: NEG
90643: PUSH
90644: LD_INT 0
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 1
90653: NEG
90654: PUSH
90655: LD_INT 1
90657: NEG
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 1
90665: NEG
90666: PUSH
90667: LD_INT 2
90669: NEG
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 0
90677: PUSH
90678: LD_INT 2
90680: NEG
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PUSH
90686: LD_INT 1
90688: PUSH
90689: LD_INT 1
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 2
90699: PUSH
90700: LD_INT 0
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: LD_INT 2
90709: PUSH
90710: LD_INT 1
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 2
90719: PUSH
90720: LD_INT 2
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 1
90729: PUSH
90730: LD_INT 2
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PUSH
90737: LD_INT 0
90739: PUSH
90740: LD_INT 2
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: LD_INT 1
90749: NEG
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 2
90760: NEG
90761: PUSH
90762: LD_INT 0
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 2
90771: NEG
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 2
90783: NEG
90784: PUSH
90785: LD_INT 2
90787: NEG
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90814: LD_ADDR_VAR 0 57
90818: PUSH
90819: LD_INT 0
90821: PUSH
90822: LD_INT 0
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: LD_INT 1
90834: NEG
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 1
90842: PUSH
90843: LD_INT 0
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 1
90852: PUSH
90853: LD_INT 1
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: LD_INT 1
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 1
90872: NEG
90873: PUSH
90874: LD_INT 0
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 1
90883: NEG
90884: PUSH
90885: LD_INT 1
90887: NEG
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 1
90895: NEG
90896: PUSH
90897: LD_INT 2
90899: NEG
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 0
90907: PUSH
90908: LD_INT 2
90910: NEG
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 1
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 2
90929: PUSH
90930: LD_INT 0
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 2
90939: PUSH
90940: LD_INT 1
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 2
90949: PUSH
90950: LD_INT 2
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 1
90959: PUSH
90960: LD_INT 2
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 0
90969: PUSH
90970: LD_INT 2
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 1
90979: NEG
90980: PUSH
90981: LD_INT 1
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 2
90990: NEG
90991: PUSH
90992: LD_INT 0
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 2
91001: NEG
91002: PUSH
91003: LD_INT 1
91005: NEG
91006: PUSH
91007: EMPTY
91008: LIST
91009: LIST
91010: PUSH
91011: LD_INT 2
91013: NEG
91014: PUSH
91015: LD_INT 2
91017: NEG
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91044: LD_ADDR_VAR 0 58
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 0
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: LD_INT 1
91064: NEG
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 1
91072: PUSH
91073: LD_INT 0
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 1
91082: PUSH
91083: LD_INT 1
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: LD_INT 1
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 1
91102: NEG
91103: PUSH
91104: LD_INT 0
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: NEG
91114: PUSH
91115: LD_INT 1
91117: NEG
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 1
91125: NEG
91126: PUSH
91127: LD_INT 2
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 0
91137: PUSH
91138: LD_INT 2
91140: NEG
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PUSH
91146: LD_INT 1
91148: PUSH
91149: LD_INT 1
91151: NEG
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 2
91159: PUSH
91160: LD_INT 0
91162: PUSH
91163: EMPTY
91164: LIST
91165: LIST
91166: PUSH
91167: LD_INT 2
91169: PUSH
91170: LD_INT 1
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: PUSH
91177: LD_INT 2
91179: PUSH
91180: LD_INT 2
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 1
91189: PUSH
91190: LD_INT 2
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 0
91199: PUSH
91200: LD_INT 2
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 1
91209: NEG
91210: PUSH
91211: LD_INT 1
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: PUSH
91218: LD_INT 2
91220: NEG
91221: PUSH
91222: LD_INT 0
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 2
91231: NEG
91232: PUSH
91233: LD_INT 1
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 2
91243: NEG
91244: PUSH
91245: LD_INT 2
91247: NEG
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: LIST
91273: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91274: LD_ADDR_VAR 0 59
91278: PUSH
91279: LD_INT 0
91281: PUSH
91282: LD_INT 0
91284: PUSH
91285: EMPTY
91286: LIST
91287: LIST
91288: PUSH
91289: LD_INT 0
91291: PUSH
91292: LD_INT 1
91294: NEG
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: PUSH
91300: LD_INT 1
91302: PUSH
91303: LD_INT 0
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 1
91312: PUSH
91313: LD_INT 1
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 0
91322: PUSH
91323: LD_INT 1
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 1
91332: NEG
91333: PUSH
91334: LD_INT 0
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 1
91343: NEG
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91362: LD_ADDR_VAR 0 60
91366: PUSH
91367: LD_INT 0
91369: PUSH
91370: LD_INT 0
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 0
91379: PUSH
91380: LD_INT 1
91382: NEG
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 1
91390: PUSH
91391: LD_INT 0
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 1
91400: PUSH
91401: LD_INT 1
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: LD_INT 1
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 1
91420: NEG
91421: PUSH
91422: LD_INT 0
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 1
91431: NEG
91432: PUSH
91433: LD_INT 1
91435: NEG
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91450: LD_ADDR_VAR 0 61
91454: PUSH
91455: LD_INT 0
91457: PUSH
91458: LD_INT 0
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: LD_INT 0
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 1
91478: PUSH
91479: LD_INT 0
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: EMPTY
91493: LIST
91494: LIST
91495: PUSH
91496: LD_INT 0
91498: PUSH
91499: LD_INT 1
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 1
91508: NEG
91509: PUSH
91510: LD_INT 0
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: LD_INT 1
91523: NEG
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91538: LD_ADDR_VAR 0 62
91542: PUSH
91543: LD_INT 0
91545: PUSH
91546: LD_INT 0
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 0
91555: PUSH
91556: LD_INT 1
91558: NEG
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 1
91566: PUSH
91567: LD_INT 0
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 1
91576: PUSH
91577: LD_INT 1
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: LD_INT 0
91586: PUSH
91587: LD_INT 1
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 1
91596: NEG
91597: PUSH
91598: LD_INT 0
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 1
91607: NEG
91608: PUSH
91609: LD_INT 1
91611: NEG
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91626: LD_ADDR_VAR 0 63
91630: PUSH
91631: LD_INT 0
91633: PUSH
91634: LD_INT 0
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: LD_INT 1
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 1
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 1
91664: PUSH
91665: LD_INT 1
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: LD_INT 0
91674: PUSH
91675: LD_INT 1
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: LD_INT 0
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: LD_INT 1
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91714: LD_ADDR_VAR 0 64
91718: PUSH
91719: LD_INT 0
91721: PUSH
91722: LD_INT 0
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 0
91731: PUSH
91732: LD_INT 1
91734: NEG
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 1
91742: PUSH
91743: LD_INT 0
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 1
91752: PUSH
91753: LD_INT 1
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 0
91762: PUSH
91763: LD_INT 1
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 1
91772: NEG
91773: PUSH
91774: LD_INT 0
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: LD_INT 1
91783: NEG
91784: PUSH
91785: LD_INT 1
91787: NEG
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: ST_TO_ADDR
// end ; 1 :
91802: GO 97699
91804: LD_INT 1
91806: DOUBLE
91807: EQUAL
91808: IFTRUE 91812
91810: GO 94435
91812: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91813: LD_ADDR_VAR 0 11
91817: PUSH
91818: LD_INT 1
91820: NEG
91821: PUSH
91822: LD_INT 3
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 0
91832: PUSH
91833: LD_INT 3
91835: NEG
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 1
91843: PUSH
91844: LD_INT 2
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: LIST
91856: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91857: LD_ADDR_VAR 0 12
91861: PUSH
91862: LD_INT 2
91864: PUSH
91865: LD_INT 1
91867: NEG
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 3
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 3
91885: PUSH
91886: LD_INT 1
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: LIST
91897: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91898: LD_ADDR_VAR 0 13
91902: PUSH
91903: LD_INT 3
91905: PUSH
91906: LD_INT 2
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 3
91915: PUSH
91916: LD_INT 3
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 2
91925: PUSH
91926: LD_INT 3
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: EMPTY
91934: LIST
91935: LIST
91936: LIST
91937: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91938: LD_ADDR_VAR 0 14
91942: PUSH
91943: LD_INT 1
91945: PUSH
91946: LD_INT 3
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 0
91955: PUSH
91956: LD_INT 3
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 1
91965: NEG
91966: PUSH
91967: LD_INT 2
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: LIST
91978: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91979: LD_ADDR_VAR 0 15
91983: PUSH
91984: LD_INT 2
91986: NEG
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 3
91997: NEG
91998: PUSH
91999: LD_INT 0
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 3
92008: NEG
92009: PUSH
92010: LD_INT 1
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: LIST
92022: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92023: LD_ADDR_VAR 0 16
92027: PUSH
92028: LD_INT 2
92030: NEG
92031: PUSH
92032: LD_INT 3
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 3
92042: NEG
92043: PUSH
92044: LD_INT 2
92046: NEG
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 3
92054: NEG
92055: PUSH
92056: LD_INT 3
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: LIST
92068: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92069: LD_ADDR_VAR 0 17
92073: PUSH
92074: LD_INT 1
92076: NEG
92077: PUSH
92078: LD_INT 3
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 1
92099: PUSH
92100: LD_INT 2
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: LIST
92112: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92113: LD_ADDR_VAR 0 18
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: LD_INT 1
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 3
92131: PUSH
92132: LD_INT 0
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 3
92141: PUSH
92142: LD_INT 1
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: LIST
92153: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92154: LD_ADDR_VAR 0 19
92158: PUSH
92159: LD_INT 3
92161: PUSH
92162: LD_INT 2
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 3
92171: PUSH
92172: LD_INT 3
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: PUSH
92179: LD_INT 2
92181: PUSH
92182: LD_INT 3
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: LIST
92193: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92194: LD_ADDR_VAR 0 20
92198: PUSH
92199: LD_INT 1
92201: PUSH
92202: LD_INT 3
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: LD_INT 3
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: PUSH
92219: LD_INT 1
92221: NEG
92222: PUSH
92223: LD_INT 2
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: LIST
92234: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92235: LD_ADDR_VAR 0 21
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: LD_INT 1
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 3
92253: NEG
92254: PUSH
92255: LD_INT 0
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 3
92264: NEG
92265: PUSH
92266: LD_INT 1
92268: NEG
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: LIST
92278: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92279: LD_ADDR_VAR 0 22
92283: PUSH
92284: LD_INT 2
92286: NEG
92287: PUSH
92288: LD_INT 3
92290: NEG
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: PUSH
92296: LD_INT 3
92298: NEG
92299: PUSH
92300: LD_INT 2
92302: NEG
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: LD_INT 3
92314: NEG
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: LIST
92324: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92325: LD_ADDR_VAR 0 23
92329: PUSH
92330: LD_INT 0
92332: PUSH
92333: LD_INT 3
92335: NEG
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 1
92343: NEG
92344: PUSH
92345: LD_INT 4
92347: NEG
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: LIST
92368: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92369: LD_ADDR_VAR 0 24
92373: PUSH
92374: LD_INT 3
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: LD_INT 3
92386: PUSH
92387: LD_INT 1
92389: NEG
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 4
92397: PUSH
92398: LD_INT 1
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: LIST
92409: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92410: LD_ADDR_VAR 0 25
92414: PUSH
92415: LD_INT 3
92417: PUSH
92418: LD_INT 3
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 4
92427: PUSH
92428: LD_INT 3
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 3
92437: PUSH
92438: LD_INT 4
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: LIST
92449: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92450: LD_ADDR_VAR 0 26
92454: PUSH
92455: LD_INT 0
92457: PUSH
92458: LD_INT 3
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 1
92467: PUSH
92468: LD_INT 4
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: LD_INT 3
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: LIST
92490: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92491: LD_ADDR_VAR 0 27
92495: PUSH
92496: LD_INT 3
92498: NEG
92499: PUSH
92500: LD_INT 0
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: PUSH
92507: LD_INT 3
92509: NEG
92510: PUSH
92511: LD_INT 1
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 4
92520: NEG
92521: PUSH
92522: LD_INT 1
92524: NEG
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: LIST
92534: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92535: LD_ADDR_VAR 0 28
92539: PUSH
92540: LD_INT 3
92542: NEG
92543: PUSH
92544: LD_INT 3
92546: NEG
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 3
92554: NEG
92555: PUSH
92556: LD_INT 4
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 4
92566: NEG
92567: PUSH
92568: LD_INT 3
92570: NEG
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: LIST
92580: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92581: LD_ADDR_VAR 0 29
92585: PUSH
92586: LD_INT 1
92588: NEG
92589: PUSH
92590: LD_INT 3
92592: NEG
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: LD_INT 3
92603: NEG
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 1
92611: PUSH
92612: LD_INT 2
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 1
92622: NEG
92623: PUSH
92624: LD_INT 4
92626: NEG
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 0
92634: PUSH
92635: LD_INT 4
92637: NEG
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: LD_INT 1
92645: PUSH
92646: LD_INT 3
92648: NEG
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 1
92656: NEG
92657: PUSH
92658: LD_INT 5
92660: NEG
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 0
92668: PUSH
92669: LD_INT 5
92671: NEG
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 1
92679: PUSH
92680: LD_INT 4
92682: NEG
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: NEG
92691: PUSH
92692: LD_INT 6
92694: NEG
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 0
92702: PUSH
92703: LD_INT 6
92705: NEG
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 1
92713: PUSH
92714: LD_INT 5
92716: NEG
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92736: LD_ADDR_VAR 0 30
92740: PUSH
92741: LD_INT 2
92743: PUSH
92744: LD_INT 1
92746: NEG
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 3
92754: PUSH
92755: LD_INT 0
92757: PUSH
92758: EMPTY
92759: LIST
92760: LIST
92761: PUSH
92762: LD_INT 3
92764: PUSH
92765: LD_INT 1
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: LD_INT 3
92774: PUSH
92775: LD_INT 1
92777: NEG
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 4
92785: PUSH
92786: LD_INT 0
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 4
92795: PUSH
92796: LD_INT 1
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: PUSH
92803: LD_INT 4
92805: PUSH
92806: LD_INT 1
92808: NEG
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 5
92816: PUSH
92817: LD_INT 0
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: LD_INT 5
92826: PUSH
92827: LD_INT 1
92829: PUSH
92830: EMPTY
92831: LIST
92832: LIST
92833: PUSH
92834: LD_INT 5
92836: PUSH
92837: LD_INT 1
92839: NEG
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 6
92847: PUSH
92848: LD_INT 0
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 6
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92879: LD_ADDR_VAR 0 31
92883: PUSH
92884: LD_INT 3
92886: PUSH
92887: LD_INT 2
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 3
92896: PUSH
92897: LD_INT 3
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: LD_INT 2
92906: PUSH
92907: LD_INT 3
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: PUSH
92914: LD_INT 4
92916: PUSH
92917: LD_INT 3
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: LD_INT 4
92926: PUSH
92927: LD_INT 4
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 3
92936: PUSH
92937: LD_INT 4
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PUSH
92944: LD_INT 5
92946: PUSH
92947: LD_INT 4
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 5
92956: PUSH
92957: LD_INT 5
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 4
92966: PUSH
92967: LD_INT 5
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 6
92976: PUSH
92977: LD_INT 5
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 6
92986: PUSH
92987: LD_INT 6
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: LD_INT 5
92996: PUSH
92997: LD_INT 6
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93018: LD_ADDR_VAR 0 32
93022: PUSH
93023: LD_INT 1
93025: PUSH
93026: LD_INT 3
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 0
93035: PUSH
93036: LD_INT 3
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 1
93045: NEG
93046: PUSH
93047: LD_INT 2
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 1
93056: PUSH
93057: LD_INT 4
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 0
93066: PUSH
93067: LD_INT 4
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 1
93076: NEG
93077: PUSH
93078: LD_INT 3
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: LD_INT 1
93087: PUSH
93088: LD_INT 5
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: LD_INT 0
93097: PUSH
93098: LD_INT 5
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: LD_INT 1
93107: NEG
93108: PUSH
93109: LD_INT 4
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: LD_INT 1
93118: PUSH
93119: LD_INT 6
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 0
93128: PUSH
93129: LD_INT 6
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 1
93138: NEG
93139: PUSH
93140: LD_INT 5
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: LIST
93160: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93161: LD_ADDR_VAR 0 33
93165: PUSH
93166: LD_INT 2
93168: NEG
93169: PUSH
93170: LD_INT 1
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 3
93179: NEG
93180: PUSH
93181: LD_INT 0
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 3
93190: NEG
93191: PUSH
93192: LD_INT 1
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 3
93202: NEG
93203: PUSH
93204: LD_INT 1
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 4
93213: NEG
93214: PUSH
93215: LD_INT 0
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 4
93224: NEG
93225: PUSH
93226: LD_INT 1
93228: NEG
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 4
93236: NEG
93237: PUSH
93238: LD_INT 1
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_INT 5
93247: NEG
93248: PUSH
93249: LD_INT 0
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 5
93258: NEG
93259: PUSH
93260: LD_INT 1
93262: NEG
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 5
93270: NEG
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 6
93281: NEG
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 6
93292: NEG
93293: PUSH
93294: LD_INT 1
93296: NEG
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93316: LD_ADDR_VAR 0 34
93320: PUSH
93321: LD_INT 2
93323: NEG
93324: PUSH
93325: LD_INT 3
93327: NEG
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 3
93335: NEG
93336: PUSH
93337: LD_INT 2
93339: NEG
93340: PUSH
93341: EMPTY
93342: LIST
93343: LIST
93344: PUSH
93345: LD_INT 3
93347: NEG
93348: PUSH
93349: LD_INT 3
93351: NEG
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: LD_INT 3
93359: NEG
93360: PUSH
93361: LD_INT 4
93363: NEG
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: LD_INT 4
93371: NEG
93372: PUSH
93373: LD_INT 3
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 4
93383: NEG
93384: PUSH
93385: LD_INT 4
93387: NEG
93388: PUSH
93389: EMPTY
93390: LIST
93391: LIST
93392: PUSH
93393: LD_INT 4
93395: NEG
93396: PUSH
93397: LD_INT 5
93399: NEG
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 5
93407: NEG
93408: PUSH
93409: LD_INT 4
93411: NEG
93412: PUSH
93413: EMPTY
93414: LIST
93415: LIST
93416: PUSH
93417: LD_INT 5
93419: NEG
93420: PUSH
93421: LD_INT 5
93423: NEG
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 5
93431: NEG
93432: PUSH
93433: LD_INT 6
93435: NEG
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 6
93443: NEG
93444: PUSH
93445: LD_INT 5
93447: NEG
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 6
93455: NEG
93456: PUSH
93457: LD_INT 6
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93479: LD_ADDR_VAR 0 41
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: LD_INT 2
93489: NEG
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 1
93497: NEG
93498: PUSH
93499: LD_INT 3
93501: NEG
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 1
93509: PUSH
93510: LD_INT 2
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: LIST
93522: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93523: LD_ADDR_VAR 0 42
93527: PUSH
93528: LD_INT 2
93530: PUSH
93531: LD_INT 0
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: LD_INT 2
93540: PUSH
93541: LD_INT 1
93543: NEG
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: PUSH
93549: LD_INT 3
93551: PUSH
93552: LD_INT 1
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: LIST
93563: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93564: LD_ADDR_VAR 0 43
93568: PUSH
93569: LD_INT 2
93571: PUSH
93572: LD_INT 2
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 3
93581: PUSH
93582: LD_INT 2
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 2
93591: PUSH
93592: LD_INT 3
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: LIST
93603: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93604: LD_ADDR_VAR 0 44
93608: PUSH
93609: LD_INT 0
93611: PUSH
93612: LD_INT 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 1
93621: PUSH
93622: LD_INT 3
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 1
93631: NEG
93632: PUSH
93633: LD_INT 2
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: LIST
93644: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93645: LD_ADDR_VAR 0 45
93649: PUSH
93650: LD_INT 2
93652: NEG
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 2
93663: NEG
93664: PUSH
93665: LD_INT 1
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: LD_INT 3
93674: NEG
93675: PUSH
93676: LD_INT 1
93678: NEG
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: LIST
93688: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93689: LD_ADDR_VAR 0 46
93693: PUSH
93694: LD_INT 2
93696: NEG
93697: PUSH
93698: LD_INT 2
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 2
93708: NEG
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 3
93720: NEG
93721: PUSH
93722: LD_INT 2
93724: NEG
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: LIST
93734: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93735: LD_ADDR_VAR 0 47
93739: PUSH
93740: LD_INT 2
93742: NEG
93743: PUSH
93744: LD_INT 3
93746: NEG
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 1
93754: NEG
93755: PUSH
93756: LD_INT 3
93758: NEG
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93768: LD_ADDR_VAR 0 48
93772: PUSH
93773: LD_INT 1
93775: PUSH
93776: LD_INT 2
93778: NEG
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 2
93786: PUSH
93787: LD_INT 1
93789: NEG
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93799: LD_ADDR_VAR 0 49
93803: PUSH
93804: LD_INT 3
93806: PUSH
93807: LD_INT 1
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 3
93816: PUSH
93817: LD_INT 2
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93828: LD_ADDR_VAR 0 50
93832: PUSH
93833: LD_INT 2
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 1
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93857: LD_ADDR_VAR 0 51
93861: PUSH
93862: LD_INT 1
93864: NEG
93865: PUSH
93866: LD_INT 2
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 2
93875: NEG
93876: PUSH
93877: LD_INT 1
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93888: LD_ADDR_VAR 0 52
93892: PUSH
93893: LD_INT 3
93895: NEG
93896: PUSH
93897: LD_INT 1
93899: NEG
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 3
93907: NEG
93908: PUSH
93909: LD_INT 2
93911: NEG
93912: PUSH
93913: EMPTY
93914: LIST
93915: LIST
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93921: LD_ADDR_VAR 0 53
93925: PUSH
93926: LD_INT 1
93928: NEG
93929: PUSH
93930: LD_INT 3
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 0
93940: PUSH
93941: LD_INT 3
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 1
93951: PUSH
93952: LD_INT 2
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: LIST
93964: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93965: LD_ADDR_VAR 0 54
93969: PUSH
93970: LD_INT 2
93972: PUSH
93973: LD_INT 1
93975: NEG
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 3
93983: PUSH
93984: LD_INT 0
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: PUSH
93991: LD_INT 3
93993: PUSH
93994: LD_INT 1
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: LIST
94005: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94006: LD_ADDR_VAR 0 55
94010: PUSH
94011: LD_INT 3
94013: PUSH
94014: LD_INT 2
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 3
94023: PUSH
94024: LD_INT 3
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: PUSH
94031: LD_INT 2
94033: PUSH
94034: LD_INT 3
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: LIST
94045: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94046: LD_ADDR_VAR 0 56
94050: PUSH
94051: LD_INT 1
94053: PUSH
94054: LD_INT 3
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: LD_INT 0
94063: PUSH
94064: LD_INT 3
94066: PUSH
94067: EMPTY
94068: LIST
94069: LIST
94070: PUSH
94071: LD_INT 1
94073: NEG
94074: PUSH
94075: LD_INT 2
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: LIST
94086: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94087: LD_ADDR_VAR 0 57
94091: PUSH
94092: LD_INT 2
94094: NEG
94095: PUSH
94096: LD_INT 1
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 3
94105: NEG
94106: PUSH
94107: LD_INT 0
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 3
94116: NEG
94117: PUSH
94118: LD_INT 1
94120: NEG
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: LIST
94130: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94131: LD_ADDR_VAR 0 58
94135: PUSH
94136: LD_INT 2
94138: NEG
94139: PUSH
94140: LD_INT 3
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 3
94150: NEG
94151: PUSH
94152: LD_INT 2
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 3
94162: NEG
94163: PUSH
94164: LD_INT 3
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: LIST
94176: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94177: LD_ADDR_VAR 0 59
94181: PUSH
94182: LD_INT 1
94184: NEG
94185: PUSH
94186: LD_INT 2
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 0
94196: PUSH
94197: LD_INT 2
94199: NEG
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 1
94207: PUSH
94208: LD_INT 1
94210: NEG
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: LIST
94220: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94221: LD_ADDR_VAR 0 60
94225: PUSH
94226: LD_INT 1
94228: PUSH
94229: LD_INT 1
94231: NEG
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PUSH
94237: LD_INT 2
94239: PUSH
94240: LD_INT 0
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: PUSH
94247: LD_INT 2
94249: PUSH
94250: LD_INT 1
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: LIST
94261: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94262: LD_ADDR_VAR 0 61
94266: PUSH
94267: LD_INT 2
94269: PUSH
94270: LD_INT 1
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 2
94279: PUSH
94280: LD_INT 2
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 1
94289: PUSH
94290: LD_INT 2
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: LIST
94301: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94302: LD_ADDR_VAR 0 62
94306: PUSH
94307: LD_INT 1
94309: PUSH
94310: LD_INT 2
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 0
94319: PUSH
94320: LD_INT 2
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 1
94329: NEG
94330: PUSH
94331: LD_INT 1
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: LIST
94342: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94343: LD_ADDR_VAR 0 63
94347: PUSH
94348: LD_INT 1
94350: NEG
94351: PUSH
94352: LD_INT 1
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 2
94361: NEG
94362: PUSH
94363: LD_INT 0
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 2
94372: NEG
94373: PUSH
94374: LD_INT 1
94376: NEG
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: LIST
94386: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94387: LD_ADDR_VAR 0 64
94391: PUSH
94392: LD_INT 1
94394: NEG
94395: PUSH
94396: LD_INT 2
94398: NEG
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 2
94406: NEG
94407: PUSH
94408: LD_INT 1
94410: NEG
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 2
94418: NEG
94419: PUSH
94420: LD_INT 2
94422: NEG
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: LIST
94432: ST_TO_ADDR
// end ; 2 :
94433: GO 97699
94435: LD_INT 2
94437: DOUBLE
94438: EQUAL
94439: IFTRUE 94443
94441: GO 97698
94443: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94444: LD_ADDR_VAR 0 29
94448: PUSH
94449: LD_INT 4
94451: PUSH
94452: LD_INT 0
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: LD_INT 1
94464: NEG
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 5
94472: PUSH
94473: LD_INT 0
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 5
94482: PUSH
94483: LD_INT 1
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 4
94492: PUSH
94493: LD_INT 1
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: LD_INT 3
94502: PUSH
94503: LD_INT 0
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 3
94512: PUSH
94513: LD_INT 1
94515: NEG
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: LD_INT 3
94523: PUSH
94524: LD_INT 2
94526: NEG
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 5
94534: PUSH
94535: LD_INT 2
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: LD_INT 3
94544: PUSH
94545: LD_INT 3
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: PUSH
94552: LD_INT 3
94554: PUSH
94555: LD_INT 2
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: LD_INT 4
94564: PUSH
94565: LD_INT 3
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 4
94574: PUSH
94575: LD_INT 4
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 3
94584: PUSH
94585: LD_INT 4
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 2
94594: PUSH
94595: LD_INT 3
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 2
94604: PUSH
94605: LD_INT 2
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 4
94614: PUSH
94615: LD_INT 2
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 2
94624: PUSH
94625: LD_INT 4
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 0
94634: PUSH
94635: LD_INT 4
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 0
94644: PUSH
94645: LD_INT 3
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: LD_INT 1
94654: PUSH
94655: LD_INT 4
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 1
94664: PUSH
94665: LD_INT 5
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: LD_INT 5
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 1
94684: NEG
94685: PUSH
94686: LD_INT 4
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 1
94695: NEG
94696: PUSH
94697: LD_INT 3
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: LD_INT 5
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: LD_INT 2
94716: NEG
94717: PUSH
94718: LD_INT 3
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: PUSH
94725: LD_INT 3
94727: NEG
94728: PUSH
94729: LD_INT 0
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: LD_INT 3
94738: NEG
94739: PUSH
94740: LD_INT 1
94742: NEG
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 2
94750: NEG
94751: PUSH
94752: LD_INT 0
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 2
94761: NEG
94762: PUSH
94763: LD_INT 1
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 3
94772: NEG
94773: PUSH
94774: LD_INT 1
94776: PUSH
94777: EMPTY
94778: LIST
94779: LIST
94780: PUSH
94781: LD_INT 4
94783: NEG
94784: PUSH
94785: LD_INT 0
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 4
94794: NEG
94795: PUSH
94796: LD_INT 1
94798: NEG
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 4
94806: NEG
94807: PUSH
94808: LD_INT 2
94810: NEG
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 2
94818: NEG
94819: PUSH
94820: LD_INT 2
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: LD_INT 4
94829: NEG
94830: PUSH
94831: LD_INT 4
94833: NEG
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PUSH
94839: LD_INT 4
94841: NEG
94842: PUSH
94843: LD_INT 5
94845: NEG
94846: PUSH
94847: EMPTY
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 3
94853: NEG
94854: PUSH
94855: LD_INT 4
94857: NEG
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: PUSH
94863: LD_INT 3
94865: NEG
94866: PUSH
94867: LD_INT 3
94869: NEG
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 4
94877: NEG
94878: PUSH
94879: LD_INT 3
94881: NEG
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 5
94889: NEG
94890: PUSH
94891: LD_INT 4
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 5
94901: NEG
94902: PUSH
94903: LD_INT 5
94905: NEG
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: PUSH
94911: LD_INT 3
94913: NEG
94914: PUSH
94915: LD_INT 5
94917: NEG
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: LD_INT 5
94925: NEG
94926: PUSH
94927: LD_INT 3
94929: NEG
94930: PUSH
94931: EMPTY
94932: LIST
94933: LIST
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94982: LD_ADDR_VAR 0 30
94986: PUSH
94987: LD_INT 4
94989: PUSH
94990: LD_INT 4
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 4
94999: PUSH
95000: LD_INT 3
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: PUSH
95007: LD_INT 5
95009: PUSH
95010: LD_INT 4
95012: PUSH
95013: EMPTY
95014: LIST
95015: LIST
95016: PUSH
95017: LD_INT 5
95019: PUSH
95020: LD_INT 5
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 4
95029: PUSH
95030: LD_INT 5
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 3
95039: PUSH
95040: LD_INT 4
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: LD_INT 3
95049: PUSH
95050: LD_INT 3
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 5
95059: PUSH
95060: LD_INT 3
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: PUSH
95067: LD_INT 3
95069: PUSH
95070: LD_INT 5
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 0
95079: PUSH
95080: LD_INT 3
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 0
95089: PUSH
95090: LD_INT 2
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 1
95099: PUSH
95100: LD_INT 3
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_INT 1
95109: PUSH
95110: LD_INT 4
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 0
95119: PUSH
95120: LD_INT 4
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 1
95129: NEG
95130: PUSH
95131: LD_INT 3
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 1
95140: NEG
95141: PUSH
95142: LD_INT 2
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: PUSH
95149: LD_INT 2
95151: PUSH
95152: LD_INT 4
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: LD_INT 2
95161: NEG
95162: PUSH
95163: LD_INT 2
95165: PUSH
95166: EMPTY
95167: LIST
95168: LIST
95169: PUSH
95170: LD_INT 4
95172: NEG
95173: PUSH
95174: LD_INT 0
95176: PUSH
95177: EMPTY
95178: LIST
95179: LIST
95180: PUSH
95181: LD_INT 4
95183: NEG
95184: PUSH
95185: LD_INT 1
95187: NEG
95188: PUSH
95189: EMPTY
95190: LIST
95191: LIST
95192: PUSH
95193: LD_INT 3
95195: NEG
95196: PUSH
95197: LD_INT 0
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 3
95206: NEG
95207: PUSH
95208: LD_INT 1
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 4
95217: NEG
95218: PUSH
95219: LD_INT 1
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 5
95228: NEG
95229: PUSH
95230: LD_INT 0
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 5
95239: NEG
95240: PUSH
95241: LD_INT 1
95243: NEG
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: PUSH
95249: LD_INT 5
95251: NEG
95252: PUSH
95253: LD_INT 2
95255: NEG
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: PUSH
95261: LD_INT 3
95263: NEG
95264: PUSH
95265: LD_INT 2
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: PUSH
95272: LD_INT 3
95274: NEG
95275: PUSH
95276: LD_INT 3
95278: NEG
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 3
95286: NEG
95287: PUSH
95288: LD_INT 4
95290: NEG
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: LD_INT 2
95298: NEG
95299: PUSH
95300: LD_INT 3
95302: NEG
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: LD_INT 2
95310: NEG
95311: PUSH
95312: LD_INT 2
95314: NEG
95315: PUSH
95316: EMPTY
95317: LIST
95318: LIST
95319: PUSH
95320: LD_INT 3
95322: NEG
95323: PUSH
95324: LD_INT 2
95326: NEG
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 4
95334: NEG
95335: PUSH
95336: LD_INT 3
95338: NEG
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 4
95346: NEG
95347: PUSH
95348: LD_INT 4
95350: NEG
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 2
95358: NEG
95359: PUSH
95360: LD_INT 4
95362: NEG
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 4
95370: NEG
95371: PUSH
95372: LD_INT 2
95374: NEG
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 0
95382: PUSH
95383: LD_INT 4
95385: NEG
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 0
95393: PUSH
95394: LD_INT 5
95396: NEG
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: LD_INT 1
95404: PUSH
95405: LD_INT 4
95407: NEG
95408: PUSH
95409: EMPTY
95410: LIST
95411: LIST
95412: PUSH
95413: LD_INT 1
95415: PUSH
95416: LD_INT 3
95418: NEG
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: LD_INT 3
95429: NEG
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 1
95437: NEG
95438: PUSH
95439: LD_INT 4
95441: NEG
95442: PUSH
95443: EMPTY
95444: LIST
95445: LIST
95446: PUSH
95447: LD_INT 1
95449: NEG
95450: PUSH
95451: LD_INT 5
95453: NEG
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 2
95461: PUSH
95462: LD_INT 3
95464: NEG
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 2
95472: NEG
95473: PUSH
95474: LD_INT 5
95476: NEG
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95529: LD_ADDR_VAR 0 31
95533: PUSH
95534: LD_INT 0
95536: PUSH
95537: LD_INT 4
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 0
95546: PUSH
95547: LD_INT 3
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 1
95556: PUSH
95557: LD_INT 4
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: LD_INT 1
95566: PUSH
95567: LD_INT 5
95569: PUSH
95570: EMPTY
95571: LIST
95572: LIST
95573: PUSH
95574: LD_INT 0
95576: PUSH
95577: LD_INT 5
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 1
95586: NEG
95587: PUSH
95588: LD_INT 4
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 1
95597: NEG
95598: PUSH
95599: LD_INT 3
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: LD_INT 2
95608: PUSH
95609: LD_INT 5
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 2
95618: NEG
95619: PUSH
95620: LD_INT 3
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: PUSH
95627: LD_INT 3
95629: NEG
95630: PUSH
95631: LD_INT 0
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 3
95640: NEG
95641: PUSH
95642: LD_INT 1
95644: NEG
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 2
95652: NEG
95653: PUSH
95654: LD_INT 0
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 2
95663: NEG
95664: PUSH
95665: LD_INT 1
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 3
95674: NEG
95675: PUSH
95676: LD_INT 1
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 4
95685: NEG
95686: PUSH
95687: LD_INT 0
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 4
95696: NEG
95697: PUSH
95698: LD_INT 1
95700: NEG
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: PUSH
95706: LD_INT 4
95708: NEG
95709: PUSH
95710: LD_INT 2
95712: NEG
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 2
95720: NEG
95721: PUSH
95722: LD_INT 2
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_INT 4
95731: NEG
95732: PUSH
95733: LD_INT 4
95735: NEG
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: PUSH
95741: LD_INT 4
95743: NEG
95744: PUSH
95745: LD_INT 5
95747: NEG
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: PUSH
95753: LD_INT 3
95755: NEG
95756: PUSH
95757: LD_INT 4
95759: NEG
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 3
95767: NEG
95768: PUSH
95769: LD_INT 3
95771: NEG
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 4
95779: NEG
95780: PUSH
95781: LD_INT 3
95783: NEG
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: PUSH
95789: LD_INT 5
95791: NEG
95792: PUSH
95793: LD_INT 4
95795: NEG
95796: PUSH
95797: EMPTY
95798: LIST
95799: LIST
95800: PUSH
95801: LD_INT 5
95803: NEG
95804: PUSH
95805: LD_INT 5
95807: NEG
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 3
95815: NEG
95816: PUSH
95817: LD_INT 5
95819: NEG
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 5
95827: NEG
95828: PUSH
95829: LD_INT 3
95831: NEG
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: LD_INT 3
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: LD_INT 4
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 1
95861: PUSH
95862: LD_INT 3
95864: NEG
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 1
95872: PUSH
95873: LD_INT 2
95875: NEG
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 0
95883: PUSH
95884: LD_INT 2
95886: NEG
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: LD_INT 1
95894: NEG
95895: PUSH
95896: LD_INT 3
95898: NEG
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 1
95906: NEG
95907: PUSH
95908: LD_INT 4
95910: NEG
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 2
95918: PUSH
95919: LD_INT 2
95921: NEG
95922: PUSH
95923: EMPTY
95924: LIST
95925: LIST
95926: PUSH
95927: LD_INT 2
95929: NEG
95930: PUSH
95931: LD_INT 4
95933: NEG
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 4
95941: PUSH
95942: LD_INT 0
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 4
95951: PUSH
95952: LD_INT 1
95954: NEG
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 5
95962: PUSH
95963: LD_INT 0
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 5
95972: PUSH
95973: LD_INT 1
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 4
95982: PUSH
95983: LD_INT 1
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 3
95992: PUSH
95993: LD_INT 0
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 3
96002: PUSH
96003: LD_INT 1
96005: NEG
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: LD_INT 2
96016: NEG
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 5
96024: PUSH
96025: LD_INT 2
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96079: LD_ADDR_VAR 0 32
96083: PUSH
96084: LD_INT 4
96086: NEG
96087: PUSH
96088: LD_INT 0
96090: PUSH
96091: EMPTY
96092: LIST
96093: LIST
96094: PUSH
96095: LD_INT 4
96097: NEG
96098: PUSH
96099: LD_INT 1
96101: NEG
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 3
96109: NEG
96110: PUSH
96111: LD_INT 0
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: NEG
96121: PUSH
96122: LD_INT 1
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 4
96131: NEG
96132: PUSH
96133: LD_INT 1
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 5
96142: NEG
96143: PUSH
96144: LD_INT 0
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 5
96153: NEG
96154: PUSH
96155: LD_INT 1
96157: NEG
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 5
96165: NEG
96166: PUSH
96167: LD_INT 2
96169: NEG
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 3
96177: NEG
96178: PUSH
96179: LD_INT 2
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 3
96188: NEG
96189: PUSH
96190: LD_INT 3
96192: NEG
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: LD_INT 3
96200: NEG
96201: PUSH
96202: LD_INT 4
96204: NEG
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 2
96212: NEG
96213: PUSH
96214: LD_INT 3
96216: NEG
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: LD_INT 2
96224: NEG
96225: PUSH
96226: LD_INT 2
96228: NEG
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 3
96236: NEG
96237: PUSH
96238: LD_INT 2
96240: NEG
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 4
96248: NEG
96249: PUSH
96250: LD_INT 3
96252: NEG
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 4
96260: NEG
96261: PUSH
96262: LD_INT 4
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 2
96272: NEG
96273: PUSH
96274: LD_INT 4
96276: NEG
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 4
96284: NEG
96285: PUSH
96286: LD_INT 2
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 0
96296: PUSH
96297: LD_INT 4
96299: NEG
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 0
96307: PUSH
96308: LD_INT 5
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: LD_INT 4
96321: NEG
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: LD_INT 3
96332: NEG
96333: PUSH
96334: EMPTY
96335: LIST
96336: LIST
96337: PUSH
96338: LD_INT 0
96340: PUSH
96341: LD_INT 3
96343: NEG
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: PUSH
96349: LD_INT 1
96351: NEG
96352: PUSH
96353: LD_INT 4
96355: NEG
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 1
96363: NEG
96364: PUSH
96365: LD_INT 5
96367: NEG
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 2
96375: PUSH
96376: LD_INT 3
96378: NEG
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 2
96386: NEG
96387: PUSH
96388: LD_INT 5
96390: NEG
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 3
96398: PUSH
96399: LD_INT 0
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 3
96408: PUSH
96409: LD_INT 1
96411: NEG
96412: PUSH
96413: EMPTY
96414: LIST
96415: LIST
96416: PUSH
96417: LD_INT 4
96419: PUSH
96420: LD_INT 0
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: PUSH
96427: LD_INT 4
96429: PUSH
96430: LD_INT 1
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 3
96439: PUSH
96440: LD_INT 1
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 2
96449: PUSH
96450: LD_INT 0
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 2
96459: PUSH
96460: LD_INT 1
96462: NEG
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 2
96470: PUSH
96471: LD_INT 2
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 4
96481: PUSH
96482: LD_INT 2
96484: PUSH
96485: EMPTY
96486: LIST
96487: LIST
96488: PUSH
96489: LD_INT 4
96491: PUSH
96492: LD_INT 4
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: PUSH
96499: LD_INT 4
96501: PUSH
96502: LD_INT 3
96504: PUSH
96505: EMPTY
96506: LIST
96507: LIST
96508: PUSH
96509: LD_INT 5
96511: PUSH
96512: LD_INT 4
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 5
96521: PUSH
96522: LD_INT 5
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 4
96531: PUSH
96532: LD_INT 5
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 3
96541: PUSH
96542: LD_INT 4
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 3
96551: PUSH
96552: LD_INT 3
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: LD_INT 5
96561: PUSH
96562: LD_INT 3
96564: PUSH
96565: EMPTY
96566: LIST
96567: LIST
96568: PUSH
96569: LD_INT 3
96571: PUSH
96572: LD_INT 5
96574: PUSH
96575: EMPTY
96576: LIST
96577: LIST
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96626: LD_ADDR_VAR 0 33
96630: PUSH
96631: LD_INT 4
96633: NEG
96634: PUSH
96635: LD_INT 4
96637: NEG
96638: PUSH
96639: EMPTY
96640: LIST
96641: LIST
96642: PUSH
96643: LD_INT 4
96645: NEG
96646: PUSH
96647: LD_INT 5
96649: NEG
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 3
96657: NEG
96658: PUSH
96659: LD_INT 4
96661: NEG
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_INT 3
96669: NEG
96670: PUSH
96671: LD_INT 3
96673: NEG
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: LD_INT 4
96681: NEG
96682: PUSH
96683: LD_INT 3
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 5
96693: NEG
96694: PUSH
96695: LD_INT 4
96697: NEG
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_INT 5
96705: NEG
96706: PUSH
96707: LD_INT 5
96709: NEG
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 3
96717: NEG
96718: PUSH
96719: LD_INT 5
96721: NEG
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 5
96729: NEG
96730: PUSH
96731: LD_INT 3
96733: NEG
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: LD_INT 0
96741: PUSH
96742: LD_INT 3
96744: NEG
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 0
96752: PUSH
96753: LD_INT 4
96755: NEG
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: PUSH
96761: LD_INT 1
96763: PUSH
96764: LD_INT 3
96766: NEG
96767: PUSH
96768: EMPTY
96769: LIST
96770: LIST
96771: PUSH
96772: LD_INT 1
96774: PUSH
96775: LD_INT 2
96777: NEG
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: PUSH
96783: LD_INT 0
96785: PUSH
96786: LD_INT 2
96788: NEG
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: PUSH
96794: LD_INT 1
96796: NEG
96797: PUSH
96798: LD_INT 3
96800: NEG
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 1
96808: NEG
96809: PUSH
96810: LD_INT 4
96812: NEG
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 2
96820: PUSH
96821: LD_INT 2
96823: NEG
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PUSH
96829: LD_INT 2
96831: NEG
96832: PUSH
96833: LD_INT 4
96835: NEG
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 4
96843: PUSH
96844: LD_INT 0
96846: PUSH
96847: EMPTY
96848: LIST
96849: LIST
96850: PUSH
96851: LD_INT 4
96853: PUSH
96854: LD_INT 1
96856: NEG
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 5
96864: PUSH
96865: LD_INT 0
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: PUSH
96872: LD_INT 5
96874: PUSH
96875: LD_INT 1
96877: PUSH
96878: EMPTY
96879: LIST
96880: LIST
96881: PUSH
96882: LD_INT 4
96884: PUSH
96885: LD_INT 1
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: PUSH
96892: LD_INT 3
96894: PUSH
96895: LD_INT 0
96897: PUSH
96898: EMPTY
96899: LIST
96900: LIST
96901: PUSH
96902: LD_INT 3
96904: PUSH
96905: LD_INT 1
96907: NEG
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 3
96915: PUSH
96916: LD_INT 2
96918: NEG
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 5
96926: PUSH
96927: LD_INT 2
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: LD_INT 3
96936: PUSH
96937: LD_INT 3
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 3
96946: PUSH
96947: LD_INT 2
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 4
96956: PUSH
96957: LD_INT 3
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 4
96966: PUSH
96967: LD_INT 4
96969: PUSH
96970: EMPTY
96971: LIST
96972: LIST
96973: PUSH
96974: LD_INT 3
96976: PUSH
96977: LD_INT 4
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: PUSH
96984: LD_INT 2
96986: PUSH
96987: LD_INT 3
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 2
96996: PUSH
96997: LD_INT 2
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 4
97006: PUSH
97007: LD_INT 2
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 2
97016: PUSH
97017: LD_INT 4
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 0
97026: PUSH
97027: LD_INT 4
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 0
97036: PUSH
97037: LD_INT 3
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PUSH
97044: LD_INT 1
97046: PUSH
97047: LD_INT 4
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: PUSH
97054: LD_INT 1
97056: PUSH
97057: LD_INT 5
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: LD_INT 0
97066: PUSH
97067: LD_INT 5
97069: PUSH
97070: EMPTY
97071: LIST
97072: LIST
97073: PUSH
97074: LD_INT 1
97076: NEG
97077: PUSH
97078: LD_INT 4
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: PUSH
97085: LD_INT 1
97087: NEG
97088: PUSH
97089: LD_INT 3
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 2
97098: PUSH
97099: LD_INT 5
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 2
97108: NEG
97109: PUSH
97110: LD_INT 3
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97164: LD_ADDR_VAR 0 34
97168: PUSH
97169: LD_INT 0
97171: PUSH
97172: LD_INT 4
97174: NEG
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PUSH
97180: LD_INT 0
97182: PUSH
97183: LD_INT 5
97185: NEG
97186: PUSH
97187: EMPTY
97188: LIST
97189: LIST
97190: PUSH
97191: LD_INT 1
97193: PUSH
97194: LD_INT 4
97196: NEG
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 1
97204: PUSH
97205: LD_INT 3
97207: NEG
97208: PUSH
97209: EMPTY
97210: LIST
97211: LIST
97212: PUSH
97213: LD_INT 0
97215: PUSH
97216: LD_INT 3
97218: NEG
97219: PUSH
97220: EMPTY
97221: LIST
97222: LIST
97223: PUSH
97224: LD_INT 1
97226: NEG
97227: PUSH
97228: LD_INT 4
97230: NEG
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 1
97238: NEG
97239: PUSH
97240: LD_INT 5
97242: NEG
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: PUSH
97248: LD_INT 2
97250: PUSH
97251: LD_INT 3
97253: NEG
97254: PUSH
97255: EMPTY
97256: LIST
97257: LIST
97258: PUSH
97259: LD_INT 2
97261: NEG
97262: PUSH
97263: LD_INT 5
97265: NEG
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 3
97273: PUSH
97274: LD_INT 0
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: PUSH
97281: LD_INT 3
97283: PUSH
97284: LD_INT 1
97286: NEG
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 4
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PUSH
97302: LD_INT 4
97304: PUSH
97305: LD_INT 1
97307: PUSH
97308: EMPTY
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 3
97314: PUSH
97315: LD_INT 1
97317: PUSH
97318: EMPTY
97319: LIST
97320: LIST
97321: PUSH
97322: LD_INT 2
97324: PUSH
97325: LD_INT 0
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: PUSH
97332: LD_INT 2
97334: PUSH
97335: LD_INT 1
97337: NEG
97338: PUSH
97339: EMPTY
97340: LIST
97341: LIST
97342: PUSH
97343: LD_INT 2
97345: PUSH
97346: LD_INT 2
97348: NEG
97349: PUSH
97350: EMPTY
97351: LIST
97352: LIST
97353: PUSH
97354: LD_INT 4
97356: PUSH
97357: LD_INT 2
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 4
97366: PUSH
97367: LD_INT 4
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 4
97376: PUSH
97377: LD_INT 3
97379: PUSH
97380: EMPTY
97381: LIST
97382: LIST
97383: PUSH
97384: LD_INT 5
97386: PUSH
97387: LD_INT 4
97389: PUSH
97390: EMPTY
97391: LIST
97392: LIST
97393: PUSH
97394: LD_INT 5
97396: PUSH
97397: LD_INT 5
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: LD_INT 4
97406: PUSH
97407: LD_INT 5
97409: PUSH
97410: EMPTY
97411: LIST
97412: LIST
97413: PUSH
97414: LD_INT 3
97416: PUSH
97417: LD_INT 4
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 3
97426: PUSH
97427: LD_INT 3
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: LD_INT 5
97436: PUSH
97437: LD_INT 3
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: PUSH
97444: LD_INT 3
97446: PUSH
97447: LD_INT 5
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PUSH
97454: LD_INT 0
97456: PUSH
97457: LD_INT 3
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: PUSH
97464: LD_INT 0
97466: PUSH
97467: LD_INT 2
97469: PUSH
97470: EMPTY
97471: LIST
97472: LIST
97473: PUSH
97474: LD_INT 1
97476: PUSH
97477: LD_INT 3
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: LD_INT 1
97486: PUSH
97487: LD_INT 4
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: PUSH
97494: LD_INT 0
97496: PUSH
97497: LD_INT 4
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PUSH
97504: LD_INT 1
97506: NEG
97507: PUSH
97508: LD_INT 3
97510: PUSH
97511: EMPTY
97512: LIST
97513: LIST
97514: PUSH
97515: LD_INT 1
97517: NEG
97518: PUSH
97519: LD_INT 2
97521: PUSH
97522: EMPTY
97523: LIST
97524: LIST
97525: PUSH
97526: LD_INT 2
97528: PUSH
97529: LD_INT 4
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PUSH
97536: LD_INT 2
97538: NEG
97539: PUSH
97540: LD_INT 2
97542: PUSH
97543: EMPTY
97544: LIST
97545: LIST
97546: PUSH
97547: LD_INT 4
97549: NEG
97550: PUSH
97551: LD_INT 0
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: PUSH
97558: LD_INT 4
97560: NEG
97561: PUSH
97562: LD_INT 1
97564: NEG
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 3
97572: NEG
97573: PUSH
97574: LD_INT 0
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 3
97583: NEG
97584: PUSH
97585: LD_INT 1
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: PUSH
97592: LD_INT 4
97594: NEG
97595: PUSH
97596: LD_INT 1
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: LD_INT 5
97605: NEG
97606: PUSH
97607: LD_INT 0
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: PUSH
97614: LD_INT 5
97616: NEG
97617: PUSH
97618: LD_INT 1
97620: NEG
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: PUSH
97626: LD_INT 5
97628: NEG
97629: PUSH
97630: LD_INT 2
97632: NEG
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: PUSH
97638: LD_INT 3
97640: NEG
97641: PUSH
97642: LD_INT 2
97644: PUSH
97645: EMPTY
97646: LIST
97647: LIST
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: ST_TO_ADDR
// end ; end ;
97696: GO 97699
97698: POP
// case btype of b_depot , b_warehouse :
97699: LD_VAR 0 1
97703: PUSH
97704: LD_INT 0
97706: DOUBLE
97707: EQUAL
97708: IFTRUE 97718
97710: LD_INT 1
97712: DOUBLE
97713: EQUAL
97714: IFTRUE 97718
97716: GO 97919
97718: POP
// case nation of nation_american :
97719: LD_VAR 0 5
97723: PUSH
97724: LD_INT 1
97726: DOUBLE
97727: EQUAL
97728: IFTRUE 97732
97730: GO 97788
97732: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97733: LD_ADDR_VAR 0 9
97737: PUSH
97738: LD_VAR 0 11
97742: PUSH
97743: LD_VAR 0 12
97747: PUSH
97748: LD_VAR 0 13
97752: PUSH
97753: LD_VAR 0 14
97757: PUSH
97758: LD_VAR 0 15
97762: PUSH
97763: LD_VAR 0 16
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: PUSH
97776: LD_VAR 0 4
97780: PUSH
97781: LD_INT 1
97783: PLUS
97784: ARRAY
97785: ST_TO_ADDR
97786: GO 97917
97788: LD_INT 2
97790: DOUBLE
97791: EQUAL
97792: IFTRUE 97796
97794: GO 97852
97796: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97797: LD_ADDR_VAR 0 9
97801: PUSH
97802: LD_VAR 0 17
97806: PUSH
97807: LD_VAR 0 18
97811: PUSH
97812: LD_VAR 0 19
97816: PUSH
97817: LD_VAR 0 20
97821: PUSH
97822: LD_VAR 0 21
97826: PUSH
97827: LD_VAR 0 22
97831: PUSH
97832: EMPTY
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: PUSH
97840: LD_VAR 0 4
97844: PUSH
97845: LD_INT 1
97847: PLUS
97848: ARRAY
97849: ST_TO_ADDR
97850: GO 97917
97852: LD_INT 3
97854: DOUBLE
97855: EQUAL
97856: IFTRUE 97860
97858: GO 97916
97860: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97861: LD_ADDR_VAR 0 9
97865: PUSH
97866: LD_VAR 0 23
97870: PUSH
97871: LD_VAR 0 24
97875: PUSH
97876: LD_VAR 0 25
97880: PUSH
97881: LD_VAR 0 26
97885: PUSH
97886: LD_VAR 0 27
97890: PUSH
97891: LD_VAR 0 28
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: PUSH
97904: LD_VAR 0 4
97908: PUSH
97909: LD_INT 1
97911: PLUS
97912: ARRAY
97913: ST_TO_ADDR
97914: GO 97917
97916: POP
97917: GO 98472
97919: LD_INT 2
97921: DOUBLE
97922: EQUAL
97923: IFTRUE 97933
97925: LD_INT 3
97927: DOUBLE
97928: EQUAL
97929: IFTRUE 97933
97931: GO 97989
97933: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97934: LD_ADDR_VAR 0 9
97938: PUSH
97939: LD_VAR 0 29
97943: PUSH
97944: LD_VAR 0 30
97948: PUSH
97949: LD_VAR 0 31
97953: PUSH
97954: LD_VAR 0 32
97958: PUSH
97959: LD_VAR 0 33
97963: PUSH
97964: LD_VAR 0 34
97968: PUSH
97969: EMPTY
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: PUSH
97977: LD_VAR 0 4
97981: PUSH
97982: LD_INT 1
97984: PLUS
97985: ARRAY
97986: ST_TO_ADDR
97987: GO 98472
97989: LD_INT 16
97991: DOUBLE
97992: EQUAL
97993: IFTRUE 98051
97995: LD_INT 17
97997: DOUBLE
97998: EQUAL
97999: IFTRUE 98051
98001: LD_INT 18
98003: DOUBLE
98004: EQUAL
98005: IFTRUE 98051
98007: LD_INT 19
98009: DOUBLE
98010: EQUAL
98011: IFTRUE 98051
98013: LD_INT 22
98015: DOUBLE
98016: EQUAL
98017: IFTRUE 98051
98019: LD_INT 20
98021: DOUBLE
98022: EQUAL
98023: IFTRUE 98051
98025: LD_INT 21
98027: DOUBLE
98028: EQUAL
98029: IFTRUE 98051
98031: LD_INT 23
98033: DOUBLE
98034: EQUAL
98035: IFTRUE 98051
98037: LD_INT 24
98039: DOUBLE
98040: EQUAL
98041: IFTRUE 98051
98043: LD_INT 25
98045: DOUBLE
98046: EQUAL
98047: IFTRUE 98051
98049: GO 98107
98051: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98052: LD_ADDR_VAR 0 9
98056: PUSH
98057: LD_VAR 0 35
98061: PUSH
98062: LD_VAR 0 36
98066: PUSH
98067: LD_VAR 0 37
98071: PUSH
98072: LD_VAR 0 38
98076: PUSH
98077: LD_VAR 0 39
98081: PUSH
98082: LD_VAR 0 40
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: PUSH
98095: LD_VAR 0 4
98099: PUSH
98100: LD_INT 1
98102: PLUS
98103: ARRAY
98104: ST_TO_ADDR
98105: GO 98472
98107: LD_INT 6
98109: DOUBLE
98110: EQUAL
98111: IFTRUE 98163
98113: LD_INT 7
98115: DOUBLE
98116: EQUAL
98117: IFTRUE 98163
98119: LD_INT 8
98121: DOUBLE
98122: EQUAL
98123: IFTRUE 98163
98125: LD_INT 13
98127: DOUBLE
98128: EQUAL
98129: IFTRUE 98163
98131: LD_INT 12
98133: DOUBLE
98134: EQUAL
98135: IFTRUE 98163
98137: LD_INT 15
98139: DOUBLE
98140: EQUAL
98141: IFTRUE 98163
98143: LD_INT 11
98145: DOUBLE
98146: EQUAL
98147: IFTRUE 98163
98149: LD_INT 14
98151: DOUBLE
98152: EQUAL
98153: IFTRUE 98163
98155: LD_INT 10
98157: DOUBLE
98158: EQUAL
98159: IFTRUE 98163
98161: GO 98219
98163: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
98164: LD_ADDR_VAR 0 9
98168: PUSH
98169: LD_VAR 0 41
98173: PUSH
98174: LD_VAR 0 42
98178: PUSH
98179: LD_VAR 0 43
98183: PUSH
98184: LD_VAR 0 44
98188: PUSH
98189: LD_VAR 0 45
98193: PUSH
98194: LD_VAR 0 46
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: PUSH
98207: LD_VAR 0 4
98211: PUSH
98212: LD_INT 1
98214: PLUS
98215: ARRAY
98216: ST_TO_ADDR
98217: GO 98472
98219: LD_INT 36
98221: DOUBLE
98222: EQUAL
98223: IFTRUE 98227
98225: GO 98283
98227: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98228: LD_ADDR_VAR 0 9
98232: PUSH
98233: LD_VAR 0 47
98237: PUSH
98238: LD_VAR 0 48
98242: PUSH
98243: LD_VAR 0 49
98247: PUSH
98248: LD_VAR 0 50
98252: PUSH
98253: LD_VAR 0 51
98257: PUSH
98258: LD_VAR 0 52
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: PUSH
98271: LD_VAR 0 4
98275: PUSH
98276: LD_INT 1
98278: PLUS
98279: ARRAY
98280: ST_TO_ADDR
98281: GO 98472
98283: LD_INT 4
98285: DOUBLE
98286: EQUAL
98287: IFTRUE 98309
98289: LD_INT 5
98291: DOUBLE
98292: EQUAL
98293: IFTRUE 98309
98295: LD_INT 34
98297: DOUBLE
98298: EQUAL
98299: IFTRUE 98309
98301: LD_INT 37
98303: DOUBLE
98304: EQUAL
98305: IFTRUE 98309
98307: GO 98365
98309: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98310: LD_ADDR_VAR 0 9
98314: PUSH
98315: LD_VAR 0 53
98319: PUSH
98320: LD_VAR 0 54
98324: PUSH
98325: LD_VAR 0 55
98329: PUSH
98330: LD_VAR 0 56
98334: PUSH
98335: LD_VAR 0 57
98339: PUSH
98340: LD_VAR 0 58
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: PUSH
98353: LD_VAR 0 4
98357: PUSH
98358: LD_INT 1
98360: PLUS
98361: ARRAY
98362: ST_TO_ADDR
98363: GO 98472
98365: LD_INT 31
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98415
98371: LD_INT 32
98373: DOUBLE
98374: EQUAL
98375: IFTRUE 98415
98377: LD_INT 33
98379: DOUBLE
98380: EQUAL
98381: IFTRUE 98415
98383: LD_INT 27
98385: DOUBLE
98386: EQUAL
98387: IFTRUE 98415
98389: LD_INT 26
98391: DOUBLE
98392: EQUAL
98393: IFTRUE 98415
98395: LD_INT 28
98397: DOUBLE
98398: EQUAL
98399: IFTRUE 98415
98401: LD_INT 29
98403: DOUBLE
98404: EQUAL
98405: IFTRUE 98415
98407: LD_INT 30
98409: DOUBLE
98410: EQUAL
98411: IFTRUE 98415
98413: GO 98471
98415: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98416: LD_ADDR_VAR 0 9
98420: PUSH
98421: LD_VAR 0 59
98425: PUSH
98426: LD_VAR 0 60
98430: PUSH
98431: LD_VAR 0 61
98435: PUSH
98436: LD_VAR 0 62
98440: PUSH
98441: LD_VAR 0 63
98445: PUSH
98446: LD_VAR 0 64
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: PUSH
98459: LD_VAR 0 4
98463: PUSH
98464: LD_INT 1
98466: PLUS
98467: ARRAY
98468: ST_TO_ADDR
98469: GO 98472
98471: POP
// temp_list2 = [ ] ;
98472: LD_ADDR_VAR 0 10
98476: PUSH
98477: EMPTY
98478: ST_TO_ADDR
// for i in temp_list do
98479: LD_ADDR_VAR 0 8
98483: PUSH
98484: LD_VAR 0 9
98488: PUSH
98489: FOR_IN
98490: IFFALSE 98542
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98492: LD_ADDR_VAR 0 10
98496: PUSH
98497: LD_VAR 0 10
98501: PUSH
98502: LD_VAR 0 8
98506: PUSH
98507: LD_INT 1
98509: ARRAY
98510: PUSH
98511: LD_VAR 0 2
98515: PLUS
98516: PUSH
98517: LD_VAR 0 8
98521: PUSH
98522: LD_INT 2
98524: ARRAY
98525: PUSH
98526: LD_VAR 0 3
98530: PLUS
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: EMPTY
98537: LIST
98538: ADD
98539: ST_TO_ADDR
98540: GO 98489
98542: POP
98543: POP
// result = temp_list2 ;
98544: LD_ADDR_VAR 0 7
98548: PUSH
98549: LD_VAR 0 10
98553: ST_TO_ADDR
// end ;
98554: LD_VAR 0 7
98558: RET
// export function EnemyInRange ( unit , dist ) ; begin
98559: LD_INT 0
98561: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98562: LD_ADDR_VAR 0 3
98566: PUSH
98567: LD_VAR 0 1
98571: PPUSH
98572: CALL_OW 255
98576: PPUSH
98577: LD_VAR 0 1
98581: PPUSH
98582: CALL_OW 250
98586: PPUSH
98587: LD_VAR 0 1
98591: PPUSH
98592: CALL_OW 251
98596: PPUSH
98597: LD_VAR 0 2
98601: PPUSH
98602: CALL 71955 0 4
98606: PUSH
98607: LD_INT 4
98609: ARRAY
98610: ST_TO_ADDR
// end ;
98611: LD_VAR 0 3
98615: RET
// export function PlayerSeeMe ( unit ) ; begin
98616: LD_INT 0
98618: PPUSH
// result := See ( your_side , unit ) ;
98619: LD_ADDR_VAR 0 2
98623: PUSH
98624: LD_OWVAR 2
98628: PPUSH
98629: LD_VAR 0 1
98633: PPUSH
98634: CALL_OW 292
98638: ST_TO_ADDR
// end ;
98639: LD_VAR 0 2
98643: RET
// export function ReverseDir ( unit ) ; begin
98644: LD_INT 0
98646: PPUSH
// if not unit then
98647: LD_VAR 0 1
98651: NOT
98652: IFFALSE 98656
// exit ;
98654: GO 98679
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98656: LD_ADDR_VAR 0 2
98660: PUSH
98661: LD_VAR 0 1
98665: PPUSH
98666: CALL_OW 254
98670: PUSH
98671: LD_INT 3
98673: PLUS
98674: PUSH
98675: LD_INT 6
98677: MOD
98678: ST_TO_ADDR
// end ;
98679: LD_VAR 0 2
98683: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98684: LD_INT 0
98686: PPUSH
98687: PPUSH
98688: PPUSH
98689: PPUSH
98690: PPUSH
// if not hexes then
98691: LD_VAR 0 2
98695: NOT
98696: IFFALSE 98700
// exit ;
98698: GO 98848
// dist := 9999 ;
98700: LD_ADDR_VAR 0 5
98704: PUSH
98705: LD_INT 9999
98707: ST_TO_ADDR
// for i = 1 to hexes do
98708: LD_ADDR_VAR 0 4
98712: PUSH
98713: DOUBLE
98714: LD_INT 1
98716: DEC
98717: ST_TO_ADDR
98718: LD_VAR 0 2
98722: PUSH
98723: FOR_TO
98724: IFFALSE 98836
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98726: LD_VAR 0 1
98730: PPUSH
98731: LD_VAR 0 2
98735: PUSH
98736: LD_VAR 0 4
98740: ARRAY
98741: PUSH
98742: LD_INT 1
98744: ARRAY
98745: PPUSH
98746: LD_VAR 0 2
98750: PUSH
98751: LD_VAR 0 4
98755: ARRAY
98756: PUSH
98757: LD_INT 2
98759: ARRAY
98760: PPUSH
98761: CALL_OW 297
98765: PUSH
98766: LD_VAR 0 5
98770: LESS
98771: IFFALSE 98834
// begin hex := hexes [ i ] ;
98773: LD_ADDR_VAR 0 7
98777: PUSH
98778: LD_VAR 0 2
98782: PUSH
98783: LD_VAR 0 4
98787: ARRAY
98788: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98789: LD_ADDR_VAR 0 5
98793: PUSH
98794: LD_VAR 0 1
98798: PPUSH
98799: LD_VAR 0 2
98803: PUSH
98804: LD_VAR 0 4
98808: ARRAY
98809: PUSH
98810: LD_INT 1
98812: ARRAY
98813: PPUSH
98814: LD_VAR 0 2
98818: PUSH
98819: LD_VAR 0 4
98823: ARRAY
98824: PUSH
98825: LD_INT 2
98827: ARRAY
98828: PPUSH
98829: CALL_OW 297
98833: ST_TO_ADDR
// end ; end ;
98834: GO 98723
98836: POP
98837: POP
// result := hex ;
98838: LD_ADDR_VAR 0 3
98842: PUSH
98843: LD_VAR 0 7
98847: ST_TO_ADDR
// end ;
98848: LD_VAR 0 3
98852: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98853: LD_INT 0
98855: PPUSH
98856: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98857: LD_VAR 0 1
98861: NOT
98862: PUSH
98863: LD_VAR 0 1
98867: PUSH
98868: LD_INT 21
98870: PUSH
98871: LD_INT 2
98873: PUSH
98874: EMPTY
98875: LIST
98876: LIST
98877: PUSH
98878: LD_INT 23
98880: PUSH
98881: LD_INT 2
98883: PUSH
98884: EMPTY
98885: LIST
98886: LIST
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PPUSH
98892: CALL_OW 69
98896: IN
98897: NOT
98898: OR
98899: IFFALSE 98903
// exit ;
98901: GO 98950
// for i = 1 to 3 do
98903: LD_ADDR_VAR 0 3
98907: PUSH
98908: DOUBLE
98909: LD_INT 1
98911: DEC
98912: ST_TO_ADDR
98913: LD_INT 3
98915: PUSH
98916: FOR_TO
98917: IFFALSE 98948
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98919: LD_VAR 0 1
98923: PPUSH
98924: CALL_OW 250
98928: PPUSH
98929: LD_VAR 0 1
98933: PPUSH
98934: CALL_OW 251
98938: PPUSH
98939: LD_INT 1
98941: PPUSH
98942: CALL_OW 453
98946: GO 98916
98948: POP
98949: POP
// end ;
98950: LD_VAR 0 2
98954: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98955: LD_INT 0
98957: PPUSH
98958: PPUSH
98959: PPUSH
98960: PPUSH
98961: PPUSH
98962: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98963: LD_VAR 0 1
98967: NOT
98968: PUSH
98969: LD_VAR 0 2
98973: NOT
98974: OR
98975: PUSH
98976: LD_VAR 0 1
98980: PPUSH
98981: CALL_OW 314
98985: OR
98986: IFFALSE 98990
// exit ;
98988: GO 99431
// x := GetX ( enemy_unit ) ;
98990: LD_ADDR_VAR 0 7
98994: PUSH
98995: LD_VAR 0 2
98999: PPUSH
99000: CALL_OW 250
99004: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99005: LD_ADDR_VAR 0 8
99009: PUSH
99010: LD_VAR 0 2
99014: PPUSH
99015: CALL_OW 251
99019: ST_TO_ADDR
// if not x or not y then
99020: LD_VAR 0 7
99024: NOT
99025: PUSH
99026: LD_VAR 0 8
99030: NOT
99031: OR
99032: IFFALSE 99036
// exit ;
99034: GO 99431
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99036: LD_ADDR_VAR 0 6
99040: PUSH
99041: LD_VAR 0 7
99045: PPUSH
99046: LD_INT 0
99048: PPUSH
99049: LD_INT 4
99051: PPUSH
99052: CALL_OW 272
99056: PUSH
99057: LD_VAR 0 8
99061: PPUSH
99062: LD_INT 0
99064: PPUSH
99065: LD_INT 4
99067: PPUSH
99068: CALL_OW 273
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: PUSH
99077: LD_VAR 0 7
99081: PPUSH
99082: LD_INT 1
99084: PPUSH
99085: LD_INT 4
99087: PPUSH
99088: CALL_OW 272
99092: PUSH
99093: LD_VAR 0 8
99097: PPUSH
99098: LD_INT 1
99100: PPUSH
99101: LD_INT 4
99103: PPUSH
99104: CALL_OW 273
99108: PUSH
99109: EMPTY
99110: LIST
99111: LIST
99112: PUSH
99113: LD_VAR 0 7
99117: PPUSH
99118: LD_INT 2
99120: PPUSH
99121: LD_INT 4
99123: PPUSH
99124: CALL_OW 272
99128: PUSH
99129: LD_VAR 0 8
99133: PPUSH
99134: LD_INT 2
99136: PPUSH
99137: LD_INT 4
99139: PPUSH
99140: CALL_OW 273
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_VAR 0 7
99153: PPUSH
99154: LD_INT 3
99156: PPUSH
99157: LD_INT 4
99159: PPUSH
99160: CALL_OW 272
99164: PUSH
99165: LD_VAR 0 8
99169: PPUSH
99170: LD_INT 3
99172: PPUSH
99173: LD_INT 4
99175: PPUSH
99176: CALL_OW 273
99180: PUSH
99181: EMPTY
99182: LIST
99183: LIST
99184: PUSH
99185: LD_VAR 0 7
99189: PPUSH
99190: LD_INT 4
99192: PPUSH
99193: LD_INT 4
99195: PPUSH
99196: CALL_OW 272
99200: PUSH
99201: LD_VAR 0 8
99205: PPUSH
99206: LD_INT 4
99208: PPUSH
99209: LD_INT 4
99211: PPUSH
99212: CALL_OW 273
99216: PUSH
99217: EMPTY
99218: LIST
99219: LIST
99220: PUSH
99221: LD_VAR 0 7
99225: PPUSH
99226: LD_INT 5
99228: PPUSH
99229: LD_INT 4
99231: PPUSH
99232: CALL_OW 272
99236: PUSH
99237: LD_VAR 0 8
99241: PPUSH
99242: LD_INT 5
99244: PPUSH
99245: LD_INT 4
99247: PPUSH
99248: CALL_OW 273
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: ST_TO_ADDR
// for i = tmp downto 1 do
99265: LD_ADDR_VAR 0 4
99269: PUSH
99270: DOUBLE
99271: LD_VAR 0 6
99275: INC
99276: ST_TO_ADDR
99277: LD_INT 1
99279: PUSH
99280: FOR_DOWNTO
99281: IFFALSE 99382
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99283: LD_VAR 0 6
99287: PUSH
99288: LD_VAR 0 4
99292: ARRAY
99293: PUSH
99294: LD_INT 1
99296: ARRAY
99297: PPUSH
99298: LD_VAR 0 6
99302: PUSH
99303: LD_VAR 0 4
99307: ARRAY
99308: PUSH
99309: LD_INT 2
99311: ARRAY
99312: PPUSH
99313: CALL_OW 488
99317: NOT
99318: PUSH
99319: LD_VAR 0 6
99323: PUSH
99324: LD_VAR 0 4
99328: ARRAY
99329: PUSH
99330: LD_INT 1
99332: ARRAY
99333: PPUSH
99334: LD_VAR 0 6
99338: PUSH
99339: LD_VAR 0 4
99343: ARRAY
99344: PUSH
99345: LD_INT 2
99347: ARRAY
99348: PPUSH
99349: CALL_OW 428
99353: PUSH
99354: LD_INT 0
99356: NONEQUAL
99357: OR
99358: IFFALSE 99380
// tmp := Delete ( tmp , i ) ;
99360: LD_ADDR_VAR 0 6
99364: PUSH
99365: LD_VAR 0 6
99369: PPUSH
99370: LD_VAR 0 4
99374: PPUSH
99375: CALL_OW 3
99379: ST_TO_ADDR
99380: GO 99280
99382: POP
99383: POP
// j := GetClosestHex ( unit , tmp ) ;
99384: LD_ADDR_VAR 0 5
99388: PUSH
99389: LD_VAR 0 1
99393: PPUSH
99394: LD_VAR 0 6
99398: PPUSH
99399: CALL 98684 0 2
99403: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99404: LD_VAR 0 1
99408: PPUSH
99409: LD_VAR 0 5
99413: PUSH
99414: LD_INT 1
99416: ARRAY
99417: PPUSH
99418: LD_VAR 0 5
99422: PUSH
99423: LD_INT 2
99425: ARRAY
99426: PPUSH
99427: CALL_OW 111
// end ;
99431: LD_VAR 0 3
99435: RET
// export function PrepareApemanSoldier ( ) ; begin
99436: LD_INT 0
99438: PPUSH
// uc_nation := 0 ;
99439: LD_ADDR_OWVAR 21
99443: PUSH
99444: LD_INT 0
99446: ST_TO_ADDR
// hc_sex := sex_male ;
99447: LD_ADDR_OWVAR 27
99451: PUSH
99452: LD_INT 1
99454: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
99455: LD_ADDR_OWVAR 28
99459: PUSH
99460: LD_INT 15
99462: ST_TO_ADDR
// hc_gallery :=  ;
99463: LD_ADDR_OWVAR 33
99467: PUSH
99468: LD_STRING 
99470: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99471: LD_ADDR_OWVAR 31
99475: PUSH
99476: LD_INT 0
99478: PPUSH
99479: LD_INT 3
99481: PPUSH
99482: CALL_OW 12
99486: PUSH
99487: LD_INT 0
99489: PPUSH
99490: LD_INT 3
99492: PPUSH
99493: CALL_OW 12
99497: PUSH
99498: LD_INT 0
99500: PUSH
99501: LD_INT 0
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: LIST
99508: LIST
99509: ST_TO_ADDR
// end ;
99510: LD_VAR 0 1
99514: RET
// export function PrepareApemanEngineer ( ) ; begin
99515: LD_INT 0
99517: PPUSH
// uc_nation := 0 ;
99518: LD_ADDR_OWVAR 21
99522: PUSH
99523: LD_INT 0
99525: ST_TO_ADDR
// hc_sex := sex_male ;
99526: LD_ADDR_OWVAR 27
99530: PUSH
99531: LD_INT 1
99533: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
99534: LD_ADDR_OWVAR 28
99538: PUSH
99539: LD_INT 16
99541: ST_TO_ADDR
// hc_gallery :=  ;
99542: LD_ADDR_OWVAR 33
99546: PUSH
99547: LD_STRING 
99549: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99550: LD_ADDR_OWVAR 31
99554: PUSH
99555: LD_INT 0
99557: PPUSH
99558: LD_INT 3
99560: PPUSH
99561: CALL_OW 12
99565: PUSH
99566: LD_INT 0
99568: PPUSH
99569: LD_INT 3
99571: PPUSH
99572: CALL_OW 12
99576: PUSH
99577: LD_INT 0
99579: PUSH
99580: LD_INT 0
99582: PUSH
99583: EMPTY
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: ST_TO_ADDR
// end ;
99589: LD_VAR 0 1
99593: RET
// export function PrepareApeman ( agressivity ) ; begin
99594: LD_INT 0
99596: PPUSH
// uc_side := 0 ;
99597: LD_ADDR_OWVAR 20
99601: PUSH
99602: LD_INT 0
99604: ST_TO_ADDR
// uc_nation := 0 ;
99605: LD_ADDR_OWVAR 21
99609: PUSH
99610: LD_INT 0
99612: ST_TO_ADDR
// hc_sex := sex_male ;
99613: LD_ADDR_OWVAR 27
99617: PUSH
99618: LD_INT 1
99620: ST_TO_ADDR
// hc_class := class_apeman ;
99621: LD_ADDR_OWVAR 28
99625: PUSH
99626: LD_INT 12
99628: ST_TO_ADDR
// hc_gallery :=  ;
99629: LD_ADDR_OWVAR 33
99633: PUSH
99634: LD_STRING 
99636: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99637: LD_ADDR_OWVAR 35
99641: PUSH
99642: LD_VAR 0 1
99646: NEG
99647: PPUSH
99648: LD_VAR 0 1
99652: PPUSH
99653: CALL_OW 12
99657: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
99658: LD_ADDR_OWVAR 31
99662: PUSH
99663: LD_INT 0
99665: PPUSH
99666: LD_INT 3
99668: PPUSH
99669: CALL_OW 12
99673: PUSH
99674: LD_INT 0
99676: PPUSH
99677: LD_INT 3
99679: PPUSH
99680: CALL_OW 12
99684: PUSH
99685: LD_INT 0
99687: PUSH
99688: LD_INT 0
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: LIST
99695: LIST
99696: ST_TO_ADDR
// end ;
99697: LD_VAR 0 2
99701: RET
// export function PrepareTiger ( agressivity ) ; begin
99702: LD_INT 0
99704: PPUSH
// uc_side := 0 ;
99705: LD_ADDR_OWVAR 20
99709: PUSH
99710: LD_INT 0
99712: ST_TO_ADDR
// uc_nation := 0 ;
99713: LD_ADDR_OWVAR 21
99717: PUSH
99718: LD_INT 0
99720: ST_TO_ADDR
// hc_class := class_tiger ;
99721: LD_ADDR_OWVAR 28
99725: PUSH
99726: LD_INT 14
99728: ST_TO_ADDR
// hc_gallery :=  ;
99729: LD_ADDR_OWVAR 33
99733: PUSH
99734: LD_STRING 
99736: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
99737: LD_ADDR_OWVAR 35
99741: PUSH
99742: LD_VAR 0 1
99746: NEG
99747: PPUSH
99748: LD_VAR 0 1
99752: PPUSH
99753: CALL_OW 12
99757: ST_TO_ADDR
// end ;
99758: LD_VAR 0 2
99762: RET
// export function PrepareEnchidna ( ) ; begin
99763: LD_INT 0
99765: PPUSH
// uc_side := 0 ;
99766: LD_ADDR_OWVAR 20
99770: PUSH
99771: LD_INT 0
99773: ST_TO_ADDR
// uc_nation := 0 ;
99774: LD_ADDR_OWVAR 21
99778: PUSH
99779: LD_INT 0
99781: ST_TO_ADDR
// hc_class := class_baggie ;
99782: LD_ADDR_OWVAR 28
99786: PUSH
99787: LD_INT 13
99789: ST_TO_ADDR
// hc_gallery :=  ;
99790: LD_ADDR_OWVAR 33
99794: PUSH
99795: LD_STRING 
99797: ST_TO_ADDR
// end ;
99798: LD_VAR 0 1
99802: RET
// export function PrepareFrog ( ) ; begin
99803: LD_INT 0
99805: PPUSH
// uc_side := 0 ;
99806: LD_ADDR_OWVAR 20
99810: PUSH
99811: LD_INT 0
99813: ST_TO_ADDR
// uc_nation := 0 ;
99814: LD_ADDR_OWVAR 21
99818: PUSH
99819: LD_INT 0
99821: ST_TO_ADDR
// hc_class := class_frog ;
99822: LD_ADDR_OWVAR 28
99826: PUSH
99827: LD_INT 19
99829: ST_TO_ADDR
// hc_gallery :=  ;
99830: LD_ADDR_OWVAR 33
99834: PUSH
99835: LD_STRING 
99837: ST_TO_ADDR
// end ;
99838: LD_VAR 0 1
99842: RET
// export function PrepareFish ( ) ; begin
99843: LD_INT 0
99845: PPUSH
// uc_side := 0 ;
99846: LD_ADDR_OWVAR 20
99850: PUSH
99851: LD_INT 0
99853: ST_TO_ADDR
// uc_nation := 0 ;
99854: LD_ADDR_OWVAR 21
99858: PUSH
99859: LD_INT 0
99861: ST_TO_ADDR
// hc_class := class_fish ;
99862: LD_ADDR_OWVAR 28
99866: PUSH
99867: LD_INT 20
99869: ST_TO_ADDR
// hc_gallery :=  ;
99870: LD_ADDR_OWVAR 33
99874: PUSH
99875: LD_STRING 
99877: ST_TO_ADDR
// end ;
99878: LD_VAR 0 1
99882: RET
// export function PrepareBird ( ) ; begin
99883: LD_INT 0
99885: PPUSH
// uc_side := 0 ;
99886: LD_ADDR_OWVAR 20
99890: PUSH
99891: LD_INT 0
99893: ST_TO_ADDR
// uc_nation := 0 ;
99894: LD_ADDR_OWVAR 21
99898: PUSH
99899: LD_INT 0
99901: ST_TO_ADDR
// hc_class := class_phororhacos ;
99902: LD_ADDR_OWVAR 28
99906: PUSH
99907: LD_INT 18
99909: ST_TO_ADDR
// hc_gallery :=  ;
99910: LD_ADDR_OWVAR 33
99914: PUSH
99915: LD_STRING 
99917: ST_TO_ADDR
// end ;
99918: LD_VAR 0 1
99922: RET
// export function PrepareHorse ( ) ; begin
99923: LD_INT 0
99925: PPUSH
// uc_side := 0 ;
99926: LD_ADDR_OWVAR 20
99930: PUSH
99931: LD_INT 0
99933: ST_TO_ADDR
// uc_nation := 0 ;
99934: LD_ADDR_OWVAR 21
99938: PUSH
99939: LD_INT 0
99941: ST_TO_ADDR
// hc_class := class_horse ;
99942: LD_ADDR_OWVAR 28
99946: PUSH
99947: LD_INT 21
99949: ST_TO_ADDR
// hc_gallery :=  ;
99950: LD_ADDR_OWVAR 33
99954: PUSH
99955: LD_STRING 
99957: ST_TO_ADDR
// end ;
99958: LD_VAR 0 1
99962: RET
// export function PrepareMastodont ( ) ; begin
99963: LD_INT 0
99965: PPUSH
// uc_side := 0 ;
99966: LD_ADDR_OWVAR 20
99970: PUSH
99971: LD_INT 0
99973: ST_TO_ADDR
// uc_nation := 0 ;
99974: LD_ADDR_OWVAR 21
99978: PUSH
99979: LD_INT 0
99981: ST_TO_ADDR
// vc_chassis := class_mastodont ;
99982: LD_ADDR_OWVAR 37
99986: PUSH
99987: LD_INT 31
99989: ST_TO_ADDR
// vc_control := control_rider ;
99990: LD_ADDR_OWVAR 38
99994: PUSH
99995: LD_INT 4
99997: ST_TO_ADDR
// end ;
99998: LD_VAR 0 1
100002: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
100003: LD_INT 0
100005: PPUSH
100006: PPUSH
100007: PPUSH
// uc_side = 0 ;
100008: LD_ADDR_OWVAR 20
100012: PUSH
100013: LD_INT 0
100015: ST_TO_ADDR
// uc_nation = 0 ;
100016: LD_ADDR_OWVAR 21
100020: PUSH
100021: LD_INT 0
100023: ST_TO_ADDR
// InitHc_All ( ) ;
100024: CALL_OW 584
// InitVc ;
100028: CALL_OW 20
// if mastodonts then
100032: LD_VAR 0 6
100036: IFFALSE 100103
// for i = 1 to mastodonts do
100038: LD_ADDR_VAR 0 11
100042: PUSH
100043: DOUBLE
100044: LD_INT 1
100046: DEC
100047: ST_TO_ADDR
100048: LD_VAR 0 6
100052: PUSH
100053: FOR_TO
100054: IFFALSE 100101
// begin vc_chassis := 31 ;
100056: LD_ADDR_OWVAR 37
100060: PUSH
100061: LD_INT 31
100063: ST_TO_ADDR
// vc_control := control_rider ;
100064: LD_ADDR_OWVAR 38
100068: PUSH
100069: LD_INT 4
100071: ST_TO_ADDR
// animal := CreateVehicle ;
100072: LD_ADDR_VAR 0 12
100076: PUSH
100077: CALL_OW 45
100081: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100082: LD_VAR 0 12
100086: PPUSH
100087: LD_VAR 0 8
100091: PPUSH
100092: LD_INT 0
100094: PPUSH
100095: CALL 102238 0 3
// end ;
100099: GO 100053
100101: POP
100102: POP
// if horses then
100103: LD_VAR 0 5
100107: IFFALSE 100174
// for i = 1 to horses do
100109: LD_ADDR_VAR 0 11
100113: PUSH
100114: DOUBLE
100115: LD_INT 1
100117: DEC
100118: ST_TO_ADDR
100119: LD_VAR 0 5
100123: PUSH
100124: FOR_TO
100125: IFFALSE 100172
// begin hc_class := 21 ;
100127: LD_ADDR_OWVAR 28
100131: PUSH
100132: LD_INT 21
100134: ST_TO_ADDR
// hc_gallery :=  ;
100135: LD_ADDR_OWVAR 33
100139: PUSH
100140: LD_STRING 
100142: ST_TO_ADDR
// animal := CreateHuman ;
100143: LD_ADDR_VAR 0 12
100147: PUSH
100148: CALL_OW 44
100152: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100153: LD_VAR 0 12
100157: PPUSH
100158: LD_VAR 0 8
100162: PPUSH
100163: LD_INT 0
100165: PPUSH
100166: CALL 102238 0 3
// end ;
100170: GO 100124
100172: POP
100173: POP
// if birds then
100174: LD_VAR 0 1
100178: IFFALSE 100245
// for i = 1 to birds do
100180: LD_ADDR_VAR 0 11
100184: PUSH
100185: DOUBLE
100186: LD_INT 1
100188: DEC
100189: ST_TO_ADDR
100190: LD_VAR 0 1
100194: PUSH
100195: FOR_TO
100196: IFFALSE 100243
// begin hc_class = 18 ;
100198: LD_ADDR_OWVAR 28
100202: PUSH
100203: LD_INT 18
100205: ST_TO_ADDR
// hc_gallery =  ;
100206: LD_ADDR_OWVAR 33
100210: PUSH
100211: LD_STRING 
100213: ST_TO_ADDR
// animal := CreateHuman ;
100214: LD_ADDR_VAR 0 12
100218: PUSH
100219: CALL_OW 44
100223: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100224: LD_VAR 0 12
100228: PPUSH
100229: LD_VAR 0 8
100233: PPUSH
100234: LD_INT 0
100236: PPUSH
100237: CALL 102238 0 3
// end ;
100241: GO 100195
100243: POP
100244: POP
// if tigers then
100245: LD_VAR 0 2
100249: IFFALSE 100333
// for i = 1 to tigers do
100251: LD_ADDR_VAR 0 11
100255: PUSH
100256: DOUBLE
100257: LD_INT 1
100259: DEC
100260: ST_TO_ADDR
100261: LD_VAR 0 2
100265: PUSH
100266: FOR_TO
100267: IFFALSE 100331
// begin hc_class = class_tiger ;
100269: LD_ADDR_OWVAR 28
100273: PUSH
100274: LD_INT 14
100276: ST_TO_ADDR
// hc_gallery =  ;
100277: LD_ADDR_OWVAR 33
100281: PUSH
100282: LD_STRING 
100284: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100285: LD_ADDR_OWVAR 35
100289: PUSH
100290: LD_INT 7
100292: NEG
100293: PPUSH
100294: LD_INT 7
100296: PPUSH
100297: CALL_OW 12
100301: ST_TO_ADDR
// animal := CreateHuman ;
100302: LD_ADDR_VAR 0 12
100306: PUSH
100307: CALL_OW 44
100311: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100312: LD_VAR 0 12
100316: PPUSH
100317: LD_VAR 0 8
100321: PPUSH
100322: LD_INT 0
100324: PPUSH
100325: CALL 102238 0 3
// end ;
100329: GO 100266
100331: POP
100332: POP
// if apemans then
100333: LD_VAR 0 3
100337: IFFALSE 100460
// for i = 1 to apemans do
100339: LD_ADDR_VAR 0 11
100343: PUSH
100344: DOUBLE
100345: LD_INT 1
100347: DEC
100348: ST_TO_ADDR
100349: LD_VAR 0 3
100353: PUSH
100354: FOR_TO
100355: IFFALSE 100458
// begin hc_class = class_apeman ;
100357: LD_ADDR_OWVAR 28
100361: PUSH
100362: LD_INT 12
100364: ST_TO_ADDR
// hc_gallery =  ;
100365: LD_ADDR_OWVAR 33
100369: PUSH
100370: LD_STRING 
100372: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
100373: LD_ADDR_OWVAR 35
100377: PUSH
100378: LD_INT 2
100380: NEG
100381: PPUSH
100382: LD_INT 2
100384: PPUSH
100385: CALL_OW 12
100389: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100390: LD_ADDR_OWVAR 31
100394: PUSH
100395: LD_INT 1
100397: PPUSH
100398: LD_INT 3
100400: PPUSH
100401: CALL_OW 12
100405: PUSH
100406: LD_INT 1
100408: PPUSH
100409: LD_INT 3
100411: PPUSH
100412: CALL_OW 12
100416: PUSH
100417: LD_INT 0
100419: PUSH
100420: LD_INT 0
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: ST_TO_ADDR
// animal := CreateHuman ;
100429: LD_ADDR_VAR 0 12
100433: PUSH
100434: CALL_OW 44
100438: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100439: LD_VAR 0 12
100443: PPUSH
100444: LD_VAR 0 8
100448: PPUSH
100449: LD_INT 0
100451: PPUSH
100452: CALL 102238 0 3
// end ;
100456: GO 100354
100458: POP
100459: POP
// if enchidnas then
100460: LD_VAR 0 4
100464: IFFALSE 100531
// for i = 1 to enchidnas do
100466: LD_ADDR_VAR 0 11
100470: PUSH
100471: DOUBLE
100472: LD_INT 1
100474: DEC
100475: ST_TO_ADDR
100476: LD_VAR 0 4
100480: PUSH
100481: FOR_TO
100482: IFFALSE 100529
// begin hc_class = 13 ;
100484: LD_ADDR_OWVAR 28
100488: PUSH
100489: LD_INT 13
100491: ST_TO_ADDR
// hc_gallery =  ;
100492: LD_ADDR_OWVAR 33
100496: PUSH
100497: LD_STRING 
100499: ST_TO_ADDR
// animal := CreateHuman ;
100500: LD_ADDR_VAR 0 12
100504: PUSH
100505: CALL_OW 44
100509: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100510: LD_VAR 0 12
100514: PPUSH
100515: LD_VAR 0 8
100519: PPUSH
100520: LD_INT 0
100522: PPUSH
100523: CALL 102238 0 3
// end ;
100527: GO 100481
100529: POP
100530: POP
// if fishes then
100531: LD_VAR 0 7
100535: IFFALSE 100602
// for i = 1 to fishes do
100537: LD_ADDR_VAR 0 11
100541: PUSH
100542: DOUBLE
100543: LD_INT 1
100545: DEC
100546: ST_TO_ADDR
100547: LD_VAR 0 7
100551: PUSH
100552: FOR_TO
100553: IFFALSE 100600
// begin hc_class = 20 ;
100555: LD_ADDR_OWVAR 28
100559: PUSH
100560: LD_INT 20
100562: ST_TO_ADDR
// hc_gallery =  ;
100563: LD_ADDR_OWVAR 33
100567: PUSH
100568: LD_STRING 
100570: ST_TO_ADDR
// animal := CreateHuman ;
100571: LD_ADDR_VAR 0 12
100575: PUSH
100576: CALL_OW 44
100580: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100581: LD_VAR 0 12
100585: PPUSH
100586: LD_VAR 0 9
100590: PPUSH
100591: LD_INT 0
100593: PPUSH
100594: CALL 102238 0 3
// end ;
100598: GO 100552
100600: POP
100601: POP
// end ;
100602: LD_VAR 0 10
100606: RET
// export function WantHeal ( sci , unit ) ; begin
100607: LD_INT 0
100609: PPUSH
// if GetTaskList ( sci ) > 0 then
100610: LD_VAR 0 1
100614: PPUSH
100615: CALL_OW 437
100619: PUSH
100620: LD_INT 0
100622: GREATER
100623: IFFALSE 100693
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100625: LD_VAR 0 1
100629: PPUSH
100630: CALL_OW 437
100634: PUSH
100635: LD_INT 1
100637: ARRAY
100638: PUSH
100639: LD_INT 1
100641: ARRAY
100642: PUSH
100643: LD_STRING l
100645: EQUAL
100646: PUSH
100647: LD_VAR 0 1
100651: PPUSH
100652: CALL_OW 437
100656: PUSH
100657: LD_INT 1
100659: ARRAY
100660: PUSH
100661: LD_INT 4
100663: ARRAY
100664: PUSH
100665: LD_VAR 0 2
100669: EQUAL
100670: AND
100671: IFFALSE 100683
// result := true else
100673: LD_ADDR_VAR 0 3
100677: PUSH
100678: LD_INT 1
100680: ST_TO_ADDR
100681: GO 100691
// result := false ;
100683: LD_ADDR_VAR 0 3
100687: PUSH
100688: LD_INT 0
100690: ST_TO_ADDR
// end else
100691: GO 100701
// result := false ;
100693: LD_ADDR_VAR 0 3
100697: PUSH
100698: LD_INT 0
100700: ST_TO_ADDR
// end ;
100701: LD_VAR 0 3
100705: RET
// export function HealTarget ( sci ) ; begin
100706: LD_INT 0
100708: PPUSH
// if not sci then
100709: LD_VAR 0 1
100713: NOT
100714: IFFALSE 100718
// exit ;
100716: GO 100783
// result := 0 ;
100718: LD_ADDR_VAR 0 2
100722: PUSH
100723: LD_INT 0
100725: ST_TO_ADDR
// if GetTaskList ( sci ) then
100726: LD_VAR 0 1
100730: PPUSH
100731: CALL_OW 437
100735: IFFALSE 100783
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100737: LD_VAR 0 1
100741: PPUSH
100742: CALL_OW 437
100746: PUSH
100747: LD_INT 1
100749: ARRAY
100750: PUSH
100751: LD_INT 1
100753: ARRAY
100754: PUSH
100755: LD_STRING l
100757: EQUAL
100758: IFFALSE 100783
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100760: LD_ADDR_VAR 0 2
100764: PUSH
100765: LD_VAR 0 1
100769: PPUSH
100770: CALL_OW 437
100774: PUSH
100775: LD_INT 1
100777: ARRAY
100778: PUSH
100779: LD_INT 4
100781: ARRAY
100782: ST_TO_ADDR
// end ;
100783: LD_VAR 0 2
100787: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100788: LD_INT 0
100790: PPUSH
100791: PPUSH
100792: PPUSH
100793: PPUSH
// if not base_units then
100794: LD_VAR 0 1
100798: NOT
100799: IFFALSE 100803
// exit ;
100801: GO 100890
// result := false ;
100803: LD_ADDR_VAR 0 2
100807: PUSH
100808: LD_INT 0
100810: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100811: LD_ADDR_VAR 0 5
100815: PUSH
100816: LD_VAR 0 1
100820: PPUSH
100821: LD_INT 21
100823: PUSH
100824: LD_INT 3
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: PPUSH
100831: CALL_OW 72
100835: ST_TO_ADDR
// if not tmp then
100836: LD_VAR 0 5
100840: NOT
100841: IFFALSE 100845
// exit ;
100843: GO 100890
// for i in tmp do
100845: LD_ADDR_VAR 0 3
100849: PUSH
100850: LD_VAR 0 5
100854: PUSH
100855: FOR_IN
100856: IFFALSE 100888
// begin result := EnemyInRange ( i , 22 ) ;
100858: LD_ADDR_VAR 0 2
100862: PUSH
100863: LD_VAR 0 3
100867: PPUSH
100868: LD_INT 22
100870: PPUSH
100871: CALL 98559 0 2
100875: ST_TO_ADDR
// if result then
100876: LD_VAR 0 2
100880: IFFALSE 100886
// exit ;
100882: POP
100883: POP
100884: GO 100890
// end ;
100886: GO 100855
100888: POP
100889: POP
// end ;
100890: LD_VAR 0 2
100894: RET
// export function FilterByTag ( units , tag ) ; begin
100895: LD_INT 0
100897: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
100898: LD_ADDR_VAR 0 3
100902: PUSH
100903: LD_VAR 0 1
100907: PPUSH
100908: LD_INT 120
100910: PUSH
100911: LD_VAR 0 2
100915: PUSH
100916: EMPTY
100917: LIST
100918: LIST
100919: PPUSH
100920: CALL_OW 72
100924: ST_TO_ADDR
// end ;
100925: LD_VAR 0 3
100929: RET
// export function IsDriver ( un ) ; begin
100930: LD_INT 0
100932: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100933: LD_ADDR_VAR 0 2
100937: PUSH
100938: LD_VAR 0 1
100942: PUSH
100943: LD_INT 55
100945: PUSH
100946: EMPTY
100947: LIST
100948: PPUSH
100949: CALL_OW 69
100953: IN
100954: ST_TO_ADDR
// end ;
100955: LD_VAR 0 2
100959: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100960: LD_INT 0
100962: PPUSH
100963: PPUSH
// list := [ ] ;
100964: LD_ADDR_VAR 0 5
100968: PUSH
100969: EMPTY
100970: ST_TO_ADDR
// case d of 0 :
100971: LD_VAR 0 3
100975: PUSH
100976: LD_INT 0
100978: DOUBLE
100979: EQUAL
100980: IFTRUE 100984
100982: GO 101117
100984: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100985: LD_ADDR_VAR 0 5
100989: PUSH
100990: LD_VAR 0 1
100994: PUSH
100995: LD_INT 4
100997: MINUS
100998: PUSH
100999: LD_VAR 0 2
101003: PUSH
101004: LD_INT 4
101006: MINUS
101007: PUSH
101008: LD_INT 2
101010: PUSH
101011: EMPTY
101012: LIST
101013: LIST
101014: LIST
101015: PUSH
101016: LD_VAR 0 1
101020: PUSH
101021: LD_INT 3
101023: MINUS
101024: PUSH
101025: LD_VAR 0 2
101029: PUSH
101030: LD_INT 1
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: LIST
101037: PUSH
101038: LD_VAR 0 1
101042: PUSH
101043: LD_INT 4
101045: PLUS
101046: PUSH
101047: LD_VAR 0 2
101051: PUSH
101052: LD_INT 4
101054: PUSH
101055: EMPTY
101056: LIST
101057: LIST
101058: LIST
101059: PUSH
101060: LD_VAR 0 1
101064: PUSH
101065: LD_INT 3
101067: PLUS
101068: PUSH
101069: LD_VAR 0 2
101073: PUSH
101074: LD_INT 3
101076: PLUS
101077: PUSH
101078: LD_INT 5
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: LIST
101085: PUSH
101086: LD_VAR 0 1
101090: PUSH
101091: LD_VAR 0 2
101095: PUSH
101096: LD_INT 4
101098: PLUS
101099: PUSH
101100: LD_INT 0
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: LIST
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: LIST
101112: LIST
101113: LIST
101114: ST_TO_ADDR
// end ; 1 :
101115: GO 101815
101117: LD_INT 1
101119: DOUBLE
101120: EQUAL
101121: IFTRUE 101125
101123: GO 101258
101125: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
101126: LD_ADDR_VAR 0 5
101130: PUSH
101131: LD_VAR 0 1
101135: PUSH
101136: LD_VAR 0 2
101140: PUSH
101141: LD_INT 4
101143: MINUS
101144: PUSH
101145: LD_INT 3
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: LIST
101152: PUSH
101153: LD_VAR 0 1
101157: PUSH
101158: LD_INT 3
101160: MINUS
101161: PUSH
101162: LD_VAR 0 2
101166: PUSH
101167: LD_INT 3
101169: MINUS
101170: PUSH
101171: LD_INT 2
101173: PUSH
101174: EMPTY
101175: LIST
101176: LIST
101177: LIST
101178: PUSH
101179: LD_VAR 0 1
101183: PUSH
101184: LD_INT 4
101186: MINUS
101187: PUSH
101188: LD_VAR 0 2
101192: PUSH
101193: LD_INT 1
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: LIST
101200: PUSH
101201: LD_VAR 0 1
101205: PUSH
101206: LD_VAR 0 2
101210: PUSH
101211: LD_INT 3
101213: PLUS
101214: PUSH
101215: LD_INT 0
101217: PUSH
101218: EMPTY
101219: LIST
101220: LIST
101221: LIST
101222: PUSH
101223: LD_VAR 0 1
101227: PUSH
101228: LD_INT 4
101230: PLUS
101231: PUSH
101232: LD_VAR 0 2
101236: PUSH
101237: LD_INT 4
101239: PLUS
101240: PUSH
101241: LD_INT 5
101243: PUSH
101244: EMPTY
101245: LIST
101246: LIST
101247: LIST
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: LIST
101253: LIST
101254: LIST
101255: ST_TO_ADDR
// end ; 2 :
101256: GO 101815
101258: LD_INT 2
101260: DOUBLE
101261: EQUAL
101262: IFTRUE 101266
101264: GO 101395
101266: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
101267: LD_ADDR_VAR 0 5
101271: PUSH
101272: LD_VAR 0 1
101276: PUSH
101277: LD_VAR 0 2
101281: PUSH
101282: LD_INT 3
101284: MINUS
101285: PUSH
101286: LD_INT 3
101288: PUSH
101289: EMPTY
101290: LIST
101291: LIST
101292: LIST
101293: PUSH
101294: LD_VAR 0 1
101298: PUSH
101299: LD_INT 4
101301: PLUS
101302: PUSH
101303: LD_VAR 0 2
101307: PUSH
101308: LD_INT 4
101310: PUSH
101311: EMPTY
101312: LIST
101313: LIST
101314: LIST
101315: PUSH
101316: LD_VAR 0 1
101320: PUSH
101321: LD_VAR 0 2
101325: PUSH
101326: LD_INT 4
101328: PLUS
101329: PUSH
101330: LD_INT 0
101332: PUSH
101333: EMPTY
101334: LIST
101335: LIST
101336: LIST
101337: PUSH
101338: LD_VAR 0 1
101342: PUSH
101343: LD_INT 3
101345: MINUS
101346: PUSH
101347: LD_VAR 0 2
101351: PUSH
101352: LD_INT 1
101354: PUSH
101355: EMPTY
101356: LIST
101357: LIST
101358: LIST
101359: PUSH
101360: LD_VAR 0 1
101364: PUSH
101365: LD_INT 4
101367: MINUS
101368: PUSH
101369: LD_VAR 0 2
101373: PUSH
101374: LD_INT 4
101376: MINUS
101377: PUSH
101378: LD_INT 2
101380: PUSH
101381: EMPTY
101382: LIST
101383: LIST
101384: LIST
101385: PUSH
101386: EMPTY
101387: LIST
101388: LIST
101389: LIST
101390: LIST
101391: LIST
101392: ST_TO_ADDR
// end ; 3 :
101393: GO 101815
101395: LD_INT 3
101397: DOUBLE
101398: EQUAL
101399: IFTRUE 101403
101401: GO 101536
101403: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
101404: LD_ADDR_VAR 0 5
101408: PUSH
101409: LD_VAR 0 1
101413: PUSH
101414: LD_INT 3
101416: PLUS
101417: PUSH
101418: LD_VAR 0 2
101422: PUSH
101423: LD_INT 4
101425: PUSH
101426: EMPTY
101427: LIST
101428: LIST
101429: LIST
101430: PUSH
101431: LD_VAR 0 1
101435: PUSH
101436: LD_INT 4
101438: PLUS
101439: PUSH
101440: LD_VAR 0 2
101444: PUSH
101445: LD_INT 4
101447: PLUS
101448: PUSH
101449: LD_INT 5
101451: PUSH
101452: EMPTY
101453: LIST
101454: LIST
101455: LIST
101456: PUSH
101457: LD_VAR 0 1
101461: PUSH
101462: LD_INT 4
101464: MINUS
101465: PUSH
101466: LD_VAR 0 2
101470: PUSH
101471: LD_INT 1
101473: PUSH
101474: EMPTY
101475: LIST
101476: LIST
101477: LIST
101478: PUSH
101479: LD_VAR 0 1
101483: PUSH
101484: LD_VAR 0 2
101488: PUSH
101489: LD_INT 4
101491: MINUS
101492: PUSH
101493: LD_INT 3
101495: PUSH
101496: EMPTY
101497: LIST
101498: LIST
101499: LIST
101500: PUSH
101501: LD_VAR 0 1
101505: PUSH
101506: LD_INT 3
101508: MINUS
101509: PUSH
101510: LD_VAR 0 2
101514: PUSH
101515: LD_INT 3
101517: MINUS
101518: PUSH
101519: LD_INT 2
101521: PUSH
101522: EMPTY
101523: LIST
101524: LIST
101525: LIST
101526: PUSH
101527: EMPTY
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: ST_TO_ADDR
// end ; 4 :
101534: GO 101815
101536: LD_INT 4
101538: DOUBLE
101539: EQUAL
101540: IFTRUE 101544
101542: GO 101677
101544: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
101545: LD_ADDR_VAR 0 5
101549: PUSH
101550: LD_VAR 0 1
101554: PUSH
101555: LD_VAR 0 2
101559: PUSH
101560: LD_INT 4
101562: PLUS
101563: PUSH
101564: LD_INT 0
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: LIST
101571: PUSH
101572: LD_VAR 0 1
101576: PUSH
101577: LD_INT 3
101579: PLUS
101580: PUSH
101581: LD_VAR 0 2
101585: PUSH
101586: LD_INT 3
101588: PLUS
101589: PUSH
101590: LD_INT 5
101592: PUSH
101593: EMPTY
101594: LIST
101595: LIST
101596: LIST
101597: PUSH
101598: LD_VAR 0 1
101602: PUSH
101603: LD_INT 4
101605: PLUS
101606: PUSH
101607: LD_VAR 0 2
101611: PUSH
101612: LD_INT 4
101614: PUSH
101615: EMPTY
101616: LIST
101617: LIST
101618: LIST
101619: PUSH
101620: LD_VAR 0 1
101624: PUSH
101625: LD_VAR 0 2
101629: PUSH
101630: LD_INT 3
101632: MINUS
101633: PUSH
101634: LD_INT 3
101636: PUSH
101637: EMPTY
101638: LIST
101639: LIST
101640: LIST
101641: PUSH
101642: LD_VAR 0 1
101646: PUSH
101647: LD_INT 4
101649: MINUS
101650: PUSH
101651: LD_VAR 0 2
101655: PUSH
101656: LD_INT 4
101658: MINUS
101659: PUSH
101660: LD_INT 2
101662: PUSH
101663: EMPTY
101664: LIST
101665: LIST
101666: LIST
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: LIST
101672: LIST
101673: LIST
101674: ST_TO_ADDR
// end ; 5 :
101675: GO 101815
101677: LD_INT 5
101679: DOUBLE
101680: EQUAL
101681: IFTRUE 101685
101683: GO 101814
101685: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
101686: LD_ADDR_VAR 0 5
101690: PUSH
101691: LD_VAR 0 1
101695: PUSH
101696: LD_INT 4
101698: MINUS
101699: PUSH
101700: LD_VAR 0 2
101704: PUSH
101705: LD_INT 1
101707: PUSH
101708: EMPTY
101709: LIST
101710: LIST
101711: LIST
101712: PUSH
101713: LD_VAR 0 1
101717: PUSH
101718: LD_VAR 0 2
101722: PUSH
101723: LD_INT 4
101725: MINUS
101726: PUSH
101727: LD_INT 3
101729: PUSH
101730: EMPTY
101731: LIST
101732: LIST
101733: LIST
101734: PUSH
101735: LD_VAR 0 1
101739: PUSH
101740: LD_INT 4
101742: PLUS
101743: PUSH
101744: LD_VAR 0 2
101748: PUSH
101749: LD_INT 4
101751: PLUS
101752: PUSH
101753: LD_INT 5
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: LIST
101760: PUSH
101761: LD_VAR 0 1
101765: PUSH
101766: LD_INT 3
101768: PLUS
101769: PUSH
101770: LD_VAR 0 2
101774: PUSH
101775: LD_INT 4
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: LIST
101782: PUSH
101783: LD_VAR 0 1
101787: PUSH
101788: LD_VAR 0 2
101792: PUSH
101793: LD_INT 3
101795: PLUS
101796: PUSH
101797: LD_INT 0
101799: PUSH
101800: EMPTY
101801: LIST
101802: LIST
101803: LIST
101804: PUSH
101805: EMPTY
101806: LIST
101807: LIST
101808: LIST
101809: LIST
101810: LIST
101811: ST_TO_ADDR
// end ; end ;
101812: GO 101815
101814: POP
// result := list ;
101815: LD_ADDR_VAR 0 4
101819: PUSH
101820: LD_VAR 0 5
101824: ST_TO_ADDR
// end ;
101825: LD_VAR 0 4
101829: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101830: LD_INT 0
101832: PPUSH
101833: PPUSH
101834: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101835: LD_VAR 0 1
101839: NOT
101840: PUSH
101841: LD_VAR 0 2
101845: PUSH
101846: LD_INT 1
101848: PUSH
101849: LD_INT 2
101851: PUSH
101852: LD_INT 3
101854: PUSH
101855: LD_INT 4
101857: PUSH
101858: EMPTY
101859: LIST
101860: LIST
101861: LIST
101862: LIST
101863: IN
101864: NOT
101865: OR
101866: IFFALSE 101870
// exit ;
101868: GO 101962
// tmp := [ ] ;
101870: LD_ADDR_VAR 0 5
101874: PUSH
101875: EMPTY
101876: ST_TO_ADDR
// for i in units do
101877: LD_ADDR_VAR 0 4
101881: PUSH
101882: LD_VAR 0 1
101886: PUSH
101887: FOR_IN
101888: IFFALSE 101931
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101890: LD_ADDR_VAR 0 5
101894: PUSH
101895: LD_VAR 0 5
101899: PPUSH
101900: LD_VAR 0 5
101904: PUSH
101905: LD_INT 1
101907: PLUS
101908: PPUSH
101909: LD_VAR 0 4
101913: PPUSH
101914: LD_VAR 0 2
101918: PPUSH
101919: CALL_OW 259
101923: PPUSH
101924: CALL_OW 2
101928: ST_TO_ADDR
101929: GO 101887
101931: POP
101932: POP
// if not tmp then
101933: LD_VAR 0 5
101937: NOT
101938: IFFALSE 101942
// exit ;
101940: GO 101962
// result := SortListByListDesc ( units , tmp ) ;
101942: LD_ADDR_VAR 0 3
101946: PUSH
101947: LD_VAR 0 1
101951: PPUSH
101952: LD_VAR 0 5
101956: PPUSH
101957: CALL_OW 77
101961: ST_TO_ADDR
// end ;
101962: LD_VAR 0 3
101966: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101967: LD_INT 0
101969: PPUSH
101970: PPUSH
101971: PPUSH
// result := false ;
101972: LD_ADDR_VAR 0 3
101976: PUSH
101977: LD_INT 0
101979: ST_TO_ADDR
// x := GetX ( building ) ;
101980: LD_ADDR_VAR 0 4
101984: PUSH
101985: LD_VAR 0 2
101989: PPUSH
101990: CALL_OW 250
101994: ST_TO_ADDR
// y := GetY ( building ) ;
101995: LD_ADDR_VAR 0 5
101999: PUSH
102000: LD_VAR 0 2
102004: PPUSH
102005: CALL_OW 251
102009: ST_TO_ADDR
// if not building or not x or not y then
102010: LD_VAR 0 2
102014: NOT
102015: PUSH
102016: LD_VAR 0 4
102020: NOT
102021: OR
102022: PUSH
102023: LD_VAR 0 5
102027: NOT
102028: OR
102029: IFFALSE 102033
// exit ;
102031: GO 102125
// if GetTaskList ( unit ) then
102033: LD_VAR 0 1
102037: PPUSH
102038: CALL_OW 437
102042: IFFALSE 102125
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102044: LD_STRING e
102046: PUSH
102047: LD_VAR 0 1
102051: PPUSH
102052: CALL_OW 437
102056: PUSH
102057: LD_INT 1
102059: ARRAY
102060: PUSH
102061: LD_INT 1
102063: ARRAY
102064: EQUAL
102065: PUSH
102066: LD_VAR 0 4
102070: PUSH
102071: LD_VAR 0 1
102075: PPUSH
102076: CALL_OW 437
102080: PUSH
102081: LD_INT 1
102083: ARRAY
102084: PUSH
102085: LD_INT 2
102087: ARRAY
102088: EQUAL
102089: AND
102090: PUSH
102091: LD_VAR 0 5
102095: PUSH
102096: LD_VAR 0 1
102100: PPUSH
102101: CALL_OW 437
102105: PUSH
102106: LD_INT 1
102108: ARRAY
102109: PUSH
102110: LD_INT 3
102112: ARRAY
102113: EQUAL
102114: AND
102115: IFFALSE 102125
// result := true end ;
102117: LD_ADDR_VAR 0 3
102121: PUSH
102122: LD_INT 1
102124: ST_TO_ADDR
// end ;
102125: LD_VAR 0 3
102129: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
102130: LD_INT 0
102132: PPUSH
// result := false ;
102133: LD_ADDR_VAR 0 4
102137: PUSH
102138: LD_INT 0
102140: ST_TO_ADDR
// if GetTaskList ( unit ) then
102141: LD_VAR 0 1
102145: PPUSH
102146: CALL_OW 437
102150: IFFALSE 102233
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
102152: LD_STRING M
102154: PUSH
102155: LD_VAR 0 1
102159: PPUSH
102160: CALL_OW 437
102164: PUSH
102165: LD_INT 1
102167: ARRAY
102168: PUSH
102169: LD_INT 1
102171: ARRAY
102172: EQUAL
102173: PUSH
102174: LD_VAR 0 2
102178: PUSH
102179: LD_VAR 0 1
102183: PPUSH
102184: CALL_OW 437
102188: PUSH
102189: LD_INT 1
102191: ARRAY
102192: PUSH
102193: LD_INT 2
102195: ARRAY
102196: EQUAL
102197: AND
102198: PUSH
102199: LD_VAR 0 3
102203: PUSH
102204: LD_VAR 0 1
102208: PPUSH
102209: CALL_OW 437
102213: PUSH
102214: LD_INT 1
102216: ARRAY
102217: PUSH
102218: LD_INT 3
102220: ARRAY
102221: EQUAL
102222: AND
102223: IFFALSE 102233
// result := true ;
102225: LD_ADDR_VAR 0 4
102229: PUSH
102230: LD_INT 1
102232: ST_TO_ADDR
// end ; end ;
102233: LD_VAR 0 4
102237: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
102238: LD_INT 0
102240: PPUSH
102241: PPUSH
102242: PPUSH
102243: PPUSH
// if not unit or not area then
102244: LD_VAR 0 1
102248: NOT
102249: PUSH
102250: LD_VAR 0 2
102254: NOT
102255: OR
102256: IFFALSE 102260
// exit ;
102258: GO 102424
// tmp := AreaToList ( area , i ) ;
102260: LD_ADDR_VAR 0 6
102264: PUSH
102265: LD_VAR 0 2
102269: PPUSH
102270: LD_VAR 0 5
102274: PPUSH
102275: CALL_OW 517
102279: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
102280: LD_ADDR_VAR 0 5
102284: PUSH
102285: DOUBLE
102286: LD_INT 1
102288: DEC
102289: ST_TO_ADDR
102290: LD_VAR 0 6
102294: PUSH
102295: LD_INT 1
102297: ARRAY
102298: PUSH
102299: FOR_TO
102300: IFFALSE 102422
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
102302: LD_ADDR_VAR 0 7
102306: PUSH
102307: LD_VAR 0 6
102311: PUSH
102312: LD_INT 1
102314: ARRAY
102315: PUSH
102316: LD_VAR 0 5
102320: ARRAY
102321: PUSH
102322: LD_VAR 0 6
102326: PUSH
102327: LD_INT 2
102329: ARRAY
102330: PUSH
102331: LD_VAR 0 5
102335: ARRAY
102336: PUSH
102337: EMPTY
102338: LIST
102339: LIST
102340: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
102341: LD_VAR 0 7
102345: PUSH
102346: LD_INT 1
102348: ARRAY
102349: PPUSH
102350: LD_VAR 0 7
102354: PUSH
102355: LD_INT 2
102357: ARRAY
102358: PPUSH
102359: CALL_OW 428
102363: PUSH
102364: LD_INT 0
102366: EQUAL
102367: IFFALSE 102420
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
102369: LD_VAR 0 1
102373: PPUSH
102374: LD_VAR 0 7
102378: PUSH
102379: LD_INT 1
102381: ARRAY
102382: PPUSH
102383: LD_VAR 0 7
102387: PUSH
102388: LD_INT 2
102390: ARRAY
102391: PPUSH
102392: LD_VAR 0 3
102396: PPUSH
102397: CALL_OW 48
// result := IsPlaced ( unit ) ;
102401: LD_ADDR_VAR 0 4
102405: PUSH
102406: LD_VAR 0 1
102410: PPUSH
102411: CALL_OW 305
102415: ST_TO_ADDR
// exit ;
102416: POP
102417: POP
102418: GO 102424
// end ; end ;
102420: GO 102299
102422: POP
102423: POP
// end ;
102424: LD_VAR 0 4
102428: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
102429: LD_INT 0
102431: PPUSH
102432: PPUSH
102433: PPUSH
// if not side or side > 8 then
102434: LD_VAR 0 1
102438: NOT
102439: PUSH
102440: LD_VAR 0 1
102444: PUSH
102445: LD_INT 8
102447: GREATER
102448: OR
102449: IFFALSE 102453
// exit ;
102451: GO 102640
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
102453: LD_ADDR_VAR 0 4
102457: PUSH
102458: LD_INT 22
102460: PUSH
102461: LD_VAR 0 1
102465: PUSH
102466: EMPTY
102467: LIST
102468: LIST
102469: PUSH
102470: LD_INT 21
102472: PUSH
102473: LD_INT 3
102475: PUSH
102476: EMPTY
102477: LIST
102478: LIST
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PPUSH
102484: CALL_OW 69
102488: ST_TO_ADDR
// if not tmp then
102489: LD_VAR 0 4
102493: NOT
102494: IFFALSE 102498
// exit ;
102496: GO 102640
// enable_addtolog := true ;
102498: LD_ADDR_OWVAR 81
102502: PUSH
102503: LD_INT 1
102505: ST_TO_ADDR
// AddToLog ( [ ) ;
102506: LD_STRING [
102508: PPUSH
102509: CALL_OW 561
// for i in tmp do
102513: LD_ADDR_VAR 0 3
102517: PUSH
102518: LD_VAR 0 4
102522: PUSH
102523: FOR_IN
102524: IFFALSE 102631
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
102526: LD_STRING [
102528: PUSH
102529: LD_VAR 0 3
102533: PPUSH
102534: CALL_OW 266
102538: STR
102539: PUSH
102540: LD_STRING , 
102542: STR
102543: PUSH
102544: LD_VAR 0 3
102548: PPUSH
102549: CALL_OW 250
102553: STR
102554: PUSH
102555: LD_STRING , 
102557: STR
102558: PUSH
102559: LD_VAR 0 3
102563: PPUSH
102564: CALL_OW 251
102568: STR
102569: PUSH
102570: LD_STRING , 
102572: STR
102573: PUSH
102574: LD_VAR 0 3
102578: PPUSH
102579: CALL_OW 254
102583: STR
102584: PUSH
102585: LD_STRING , 
102587: STR
102588: PUSH
102589: LD_VAR 0 3
102593: PPUSH
102594: LD_INT 1
102596: PPUSH
102597: CALL_OW 268
102601: STR
102602: PUSH
102603: LD_STRING , 
102605: STR
102606: PUSH
102607: LD_VAR 0 3
102611: PPUSH
102612: LD_INT 2
102614: PPUSH
102615: CALL_OW 268
102619: STR
102620: PUSH
102621: LD_STRING ],
102623: STR
102624: PPUSH
102625: CALL_OW 561
// end ;
102629: GO 102523
102631: POP
102632: POP
// AddToLog ( ]; ) ;
102633: LD_STRING ];
102635: PPUSH
102636: CALL_OW 561
// end ;
102640: LD_VAR 0 2
102644: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
102645: LD_INT 0
102647: PPUSH
102648: PPUSH
102649: PPUSH
102650: PPUSH
102651: PPUSH
// if not area or not rate or not max then
102652: LD_VAR 0 1
102656: NOT
102657: PUSH
102658: LD_VAR 0 2
102662: NOT
102663: OR
102664: PUSH
102665: LD_VAR 0 4
102669: NOT
102670: OR
102671: IFFALSE 102675
// exit ;
102673: GO 102864
// while 1 do
102675: LD_INT 1
102677: IFFALSE 102864
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
102679: LD_ADDR_VAR 0 9
102683: PUSH
102684: LD_VAR 0 1
102688: PPUSH
102689: LD_INT 1
102691: PPUSH
102692: CALL_OW 287
102696: PUSH
102697: LD_INT 10
102699: MUL
102700: ST_TO_ADDR
// r := rate / 10 ;
102701: LD_ADDR_VAR 0 7
102705: PUSH
102706: LD_VAR 0 2
102710: PUSH
102711: LD_INT 10
102713: DIVREAL
102714: ST_TO_ADDR
// time := 1 1$00 ;
102715: LD_ADDR_VAR 0 8
102719: PUSH
102720: LD_INT 2100
102722: ST_TO_ADDR
// if amount < min then
102723: LD_VAR 0 9
102727: PUSH
102728: LD_VAR 0 3
102732: LESS
102733: IFFALSE 102751
// r := r * 2 else
102735: LD_ADDR_VAR 0 7
102739: PUSH
102740: LD_VAR 0 7
102744: PUSH
102745: LD_INT 2
102747: MUL
102748: ST_TO_ADDR
102749: GO 102777
// if amount > max then
102751: LD_VAR 0 9
102755: PUSH
102756: LD_VAR 0 4
102760: GREATER
102761: IFFALSE 102777
// r := r / 2 ;
102763: LD_ADDR_VAR 0 7
102767: PUSH
102768: LD_VAR 0 7
102772: PUSH
102773: LD_INT 2
102775: DIVREAL
102776: ST_TO_ADDR
// time := time / r ;
102777: LD_ADDR_VAR 0 8
102781: PUSH
102782: LD_VAR 0 8
102786: PUSH
102787: LD_VAR 0 7
102791: DIVREAL
102792: ST_TO_ADDR
// if time < 0 then
102793: LD_VAR 0 8
102797: PUSH
102798: LD_INT 0
102800: LESS
102801: IFFALSE 102818
// time := time * - 1 ;
102803: LD_ADDR_VAR 0 8
102807: PUSH
102808: LD_VAR 0 8
102812: PUSH
102813: LD_INT 1
102815: NEG
102816: MUL
102817: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
102818: LD_VAR 0 8
102822: PUSH
102823: LD_INT 35
102825: PPUSH
102826: LD_INT 875
102828: PPUSH
102829: CALL_OW 12
102833: PLUS
102834: PPUSH
102835: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102839: LD_INT 1
102841: PPUSH
102842: LD_INT 5
102844: PPUSH
102845: CALL_OW 12
102849: PPUSH
102850: LD_VAR 0 1
102854: PPUSH
102855: LD_INT 1
102857: PPUSH
102858: CALL_OW 55
// end ;
102862: GO 102675
// end ;
102864: LD_VAR 0 5
102868: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102869: LD_INT 0
102871: PPUSH
102872: PPUSH
102873: PPUSH
102874: PPUSH
102875: PPUSH
102876: PPUSH
102877: PPUSH
102878: PPUSH
// if not turrets or not factories then
102879: LD_VAR 0 1
102883: NOT
102884: PUSH
102885: LD_VAR 0 2
102889: NOT
102890: OR
102891: IFFALSE 102895
// exit ;
102893: GO 103202
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102895: LD_ADDR_VAR 0 10
102899: PUSH
102900: LD_INT 5
102902: PUSH
102903: LD_INT 6
102905: PUSH
102906: EMPTY
102907: LIST
102908: LIST
102909: PUSH
102910: LD_INT 2
102912: PUSH
102913: LD_INT 4
102915: PUSH
102916: EMPTY
102917: LIST
102918: LIST
102919: PUSH
102920: LD_INT 3
102922: PUSH
102923: LD_INT 5
102925: PUSH
102926: EMPTY
102927: LIST
102928: LIST
102929: PUSH
102930: EMPTY
102931: LIST
102932: LIST
102933: LIST
102934: PUSH
102935: LD_INT 24
102937: PUSH
102938: LD_INT 25
102940: PUSH
102941: EMPTY
102942: LIST
102943: LIST
102944: PUSH
102945: LD_INT 23
102947: PUSH
102948: LD_INT 27
102950: PUSH
102951: EMPTY
102952: LIST
102953: LIST
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: PUSH
102959: LD_INT 42
102961: PUSH
102962: LD_INT 43
102964: PUSH
102965: EMPTY
102966: LIST
102967: LIST
102968: PUSH
102969: LD_INT 44
102971: PUSH
102972: LD_INT 46
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: PUSH
102979: LD_INT 45
102981: PUSH
102982: LD_INT 47
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: PUSH
102989: EMPTY
102990: LIST
102991: LIST
102992: LIST
102993: PUSH
102994: EMPTY
102995: LIST
102996: LIST
102997: LIST
102998: ST_TO_ADDR
// result := [ ] ;
102999: LD_ADDR_VAR 0 3
103003: PUSH
103004: EMPTY
103005: ST_TO_ADDR
// for i in turrets do
103006: LD_ADDR_VAR 0 4
103010: PUSH
103011: LD_VAR 0 1
103015: PUSH
103016: FOR_IN
103017: IFFALSE 103200
// begin nat := GetNation ( i ) ;
103019: LD_ADDR_VAR 0 7
103023: PUSH
103024: LD_VAR 0 4
103028: PPUSH
103029: CALL_OW 248
103033: ST_TO_ADDR
// weapon := 0 ;
103034: LD_ADDR_VAR 0 8
103038: PUSH
103039: LD_INT 0
103041: ST_TO_ADDR
// if not nat then
103042: LD_VAR 0 7
103046: NOT
103047: IFFALSE 103051
// continue ;
103049: GO 103016
// for j in list [ nat ] do
103051: LD_ADDR_VAR 0 5
103055: PUSH
103056: LD_VAR 0 10
103060: PUSH
103061: LD_VAR 0 7
103065: ARRAY
103066: PUSH
103067: FOR_IN
103068: IFFALSE 103109
// if GetBWeapon ( i ) = j [ 1 ] then
103070: LD_VAR 0 4
103074: PPUSH
103075: CALL_OW 269
103079: PUSH
103080: LD_VAR 0 5
103084: PUSH
103085: LD_INT 1
103087: ARRAY
103088: EQUAL
103089: IFFALSE 103107
// begin weapon := j [ 2 ] ;
103091: LD_ADDR_VAR 0 8
103095: PUSH
103096: LD_VAR 0 5
103100: PUSH
103101: LD_INT 2
103103: ARRAY
103104: ST_TO_ADDR
// break ;
103105: GO 103109
// end ;
103107: GO 103067
103109: POP
103110: POP
// if not weapon then
103111: LD_VAR 0 8
103115: NOT
103116: IFFALSE 103120
// continue ;
103118: GO 103016
// for k in factories do
103120: LD_ADDR_VAR 0 6
103124: PUSH
103125: LD_VAR 0 2
103129: PUSH
103130: FOR_IN
103131: IFFALSE 103196
// begin weapons := AvailableWeaponList ( k ) ;
103133: LD_ADDR_VAR 0 9
103137: PUSH
103138: LD_VAR 0 6
103142: PPUSH
103143: CALL_OW 478
103147: ST_TO_ADDR
// if not weapons then
103148: LD_VAR 0 9
103152: NOT
103153: IFFALSE 103157
// continue ;
103155: GO 103130
// if weapon in weapons then
103157: LD_VAR 0 8
103161: PUSH
103162: LD_VAR 0 9
103166: IN
103167: IFFALSE 103194
// begin result := [ i , weapon ] ;
103169: LD_ADDR_VAR 0 3
103173: PUSH
103174: LD_VAR 0 4
103178: PUSH
103179: LD_VAR 0 8
103183: PUSH
103184: EMPTY
103185: LIST
103186: LIST
103187: ST_TO_ADDR
// exit ;
103188: POP
103189: POP
103190: POP
103191: POP
103192: GO 103202
// end ; end ;
103194: GO 103130
103196: POP
103197: POP
// end ;
103198: GO 103016
103200: POP
103201: POP
// end ;
103202: LD_VAR 0 3
103206: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
103207: LD_INT 0
103209: PPUSH
// if not side or side > 8 then
103210: LD_VAR 0 3
103214: NOT
103215: PUSH
103216: LD_VAR 0 3
103220: PUSH
103221: LD_INT 8
103223: GREATER
103224: OR
103225: IFFALSE 103229
// exit ;
103227: GO 103288
// if not range then
103229: LD_VAR 0 4
103233: NOT
103234: IFFALSE 103245
// range := - 12 ;
103236: LD_ADDR_VAR 0 4
103240: PUSH
103241: LD_INT 12
103243: NEG
103244: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
103245: LD_VAR 0 1
103249: PPUSH
103250: LD_VAR 0 2
103254: PPUSH
103255: LD_VAR 0 3
103259: PPUSH
103260: LD_VAR 0 4
103264: PPUSH
103265: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
103269: LD_VAR 0 1
103273: PPUSH
103274: LD_VAR 0 2
103278: PPUSH
103279: LD_VAR 0 3
103283: PPUSH
103284: CALL_OW 331
// end ;
103288: LD_VAR 0 5
103292: RET
// export function Video ( mode ) ; begin
103293: LD_INT 0
103295: PPUSH
// ingame_video = mode ;
103296: LD_ADDR_OWVAR 52
103300: PUSH
103301: LD_VAR 0 1
103305: ST_TO_ADDR
// interface_hidden = mode ;
103306: LD_ADDR_OWVAR 54
103310: PUSH
103311: LD_VAR 0 1
103315: ST_TO_ADDR
// end ;
103316: LD_VAR 0 2
103320: RET
// export function Join ( array , element ) ; begin
103321: LD_INT 0
103323: PPUSH
// result := Replace ( array , array + 1 , element ) ;
103324: LD_ADDR_VAR 0 3
103328: PUSH
103329: LD_VAR 0 1
103333: PPUSH
103334: LD_VAR 0 1
103338: PUSH
103339: LD_INT 1
103341: PLUS
103342: PPUSH
103343: LD_VAR 0 2
103347: PPUSH
103348: CALL_OW 1
103352: ST_TO_ADDR
// end ;
103353: LD_VAR 0 3
103357: RET
// export function JoinUnion ( array , element ) ; begin
103358: LD_INT 0
103360: PPUSH
// result := array union element ;
103361: LD_ADDR_VAR 0 3
103365: PUSH
103366: LD_VAR 0 1
103370: PUSH
103371: LD_VAR 0 2
103375: UNION
103376: ST_TO_ADDR
// end ;
103377: LD_VAR 0 3
103381: RET
// export function GetBehemoths ( side ) ; begin
103382: LD_INT 0
103384: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
103385: LD_ADDR_VAR 0 2
103389: PUSH
103390: LD_INT 22
103392: PUSH
103393: LD_VAR 0 1
103397: PUSH
103398: EMPTY
103399: LIST
103400: LIST
103401: PUSH
103402: LD_INT 31
103404: PUSH
103405: LD_INT 25
103407: PUSH
103408: EMPTY
103409: LIST
103410: LIST
103411: PUSH
103412: EMPTY
103413: LIST
103414: LIST
103415: PPUSH
103416: CALL_OW 69
103420: ST_TO_ADDR
// end ;
103421: LD_VAR 0 2
103425: RET
// export function Shuffle ( array ) ; var i , index ; begin
103426: LD_INT 0
103428: PPUSH
103429: PPUSH
103430: PPUSH
// result := [ ] ;
103431: LD_ADDR_VAR 0 2
103435: PUSH
103436: EMPTY
103437: ST_TO_ADDR
// if not array then
103438: LD_VAR 0 1
103442: NOT
103443: IFFALSE 103447
// exit ;
103445: GO 103546
// Randomize ;
103447: CALL_OW 10
// for i = array downto 1 do
103451: LD_ADDR_VAR 0 3
103455: PUSH
103456: DOUBLE
103457: LD_VAR 0 1
103461: INC
103462: ST_TO_ADDR
103463: LD_INT 1
103465: PUSH
103466: FOR_DOWNTO
103467: IFFALSE 103544
// begin index := rand ( 1 , array ) ;
103469: LD_ADDR_VAR 0 4
103473: PUSH
103474: LD_INT 1
103476: PPUSH
103477: LD_VAR 0 1
103481: PPUSH
103482: CALL_OW 12
103486: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
103487: LD_ADDR_VAR 0 2
103491: PUSH
103492: LD_VAR 0 2
103496: PPUSH
103497: LD_VAR 0 2
103501: PUSH
103502: LD_INT 1
103504: PLUS
103505: PPUSH
103506: LD_VAR 0 1
103510: PUSH
103511: LD_VAR 0 4
103515: ARRAY
103516: PPUSH
103517: CALL_OW 2
103521: ST_TO_ADDR
// array := Delete ( array , index ) ;
103522: LD_ADDR_VAR 0 1
103526: PUSH
103527: LD_VAR 0 1
103531: PPUSH
103532: LD_VAR 0 4
103536: PPUSH
103537: CALL_OW 3
103541: ST_TO_ADDR
// end ;
103542: GO 103466
103544: POP
103545: POP
// end ;
103546: LD_VAR 0 2
103550: RET
// export function GetBaseMaterials ( base ) ; begin
103551: LD_INT 0
103553: PPUSH
// result := [ 0 , 0 , 0 ] ;
103554: LD_ADDR_VAR 0 2
103558: PUSH
103559: LD_INT 0
103561: PUSH
103562: LD_INT 0
103564: PUSH
103565: LD_INT 0
103567: PUSH
103568: EMPTY
103569: LIST
103570: LIST
103571: LIST
103572: ST_TO_ADDR
// if not base then
103573: LD_VAR 0 1
103577: NOT
103578: IFFALSE 103582
// exit ;
103580: GO 103631
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
103582: LD_ADDR_VAR 0 2
103586: PUSH
103587: LD_VAR 0 1
103591: PPUSH
103592: LD_INT 1
103594: PPUSH
103595: CALL_OW 275
103599: PUSH
103600: LD_VAR 0 1
103604: PPUSH
103605: LD_INT 2
103607: PPUSH
103608: CALL_OW 275
103612: PUSH
103613: LD_VAR 0 1
103617: PPUSH
103618: LD_INT 3
103620: PPUSH
103621: CALL_OW 275
103625: PUSH
103626: EMPTY
103627: LIST
103628: LIST
103629: LIST
103630: ST_TO_ADDR
// end ;
103631: LD_VAR 0 2
103635: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
103636: LD_INT 0
103638: PPUSH
103639: PPUSH
// result := array ;
103640: LD_ADDR_VAR 0 3
103644: PUSH
103645: LD_VAR 0 1
103649: ST_TO_ADDR
// if size >= result then
103650: LD_VAR 0 2
103654: PUSH
103655: LD_VAR 0 3
103659: GREATEREQUAL
103660: IFFALSE 103664
// exit ;
103662: GO 103714
// if size then
103664: LD_VAR 0 2
103668: IFFALSE 103714
// for i := array downto size do
103670: LD_ADDR_VAR 0 4
103674: PUSH
103675: DOUBLE
103676: LD_VAR 0 1
103680: INC
103681: ST_TO_ADDR
103682: LD_VAR 0 2
103686: PUSH
103687: FOR_DOWNTO
103688: IFFALSE 103712
// result := Delete ( result , result ) ;
103690: LD_ADDR_VAR 0 3
103694: PUSH
103695: LD_VAR 0 3
103699: PPUSH
103700: LD_VAR 0 3
103704: PPUSH
103705: CALL_OW 3
103709: ST_TO_ADDR
103710: GO 103687
103712: POP
103713: POP
// end ;
103714: LD_VAR 0 3
103718: RET
// export function ComExit ( unit ) ; var tmp ; begin
103719: LD_INT 0
103721: PPUSH
103722: PPUSH
// if not IsInUnit ( unit ) then
103723: LD_VAR 0 1
103727: PPUSH
103728: CALL_OW 310
103732: NOT
103733: IFFALSE 103737
// exit ;
103735: GO 103797
// tmp := IsInUnit ( unit ) ;
103737: LD_ADDR_VAR 0 3
103741: PUSH
103742: LD_VAR 0 1
103746: PPUSH
103747: CALL_OW 310
103751: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103752: LD_VAR 0 3
103756: PPUSH
103757: CALL_OW 247
103761: PUSH
103762: LD_INT 2
103764: EQUAL
103765: IFFALSE 103778
// ComExitVehicle ( unit ) else
103767: LD_VAR 0 1
103771: PPUSH
103772: CALL_OW 121
103776: GO 103787
// ComExitBuilding ( unit ) ;
103778: LD_VAR 0 1
103782: PPUSH
103783: CALL_OW 122
// result := tmp ;
103787: LD_ADDR_VAR 0 2
103791: PUSH
103792: LD_VAR 0 3
103796: ST_TO_ADDR
// end ;
103797: LD_VAR 0 2
103801: RET
// export function ComExitAll ( units ) ; var i ; begin
103802: LD_INT 0
103804: PPUSH
103805: PPUSH
// if not units then
103806: LD_VAR 0 1
103810: NOT
103811: IFFALSE 103815
// exit ;
103813: GO 103841
// for i in units do
103815: LD_ADDR_VAR 0 3
103819: PUSH
103820: LD_VAR 0 1
103824: PUSH
103825: FOR_IN
103826: IFFALSE 103839
// ComExit ( i ) ;
103828: LD_VAR 0 3
103832: PPUSH
103833: CALL 103719 0 1
103837: GO 103825
103839: POP
103840: POP
// end ;
103841: LD_VAR 0 2
103845: RET
// export function ResetHc ; begin
103846: LD_INT 0
103848: PPUSH
// InitHc ;
103849: CALL_OW 19
// hc_importance := 0 ;
103853: LD_ADDR_OWVAR 32
103857: PUSH
103858: LD_INT 0
103860: ST_TO_ADDR
// end ;
103861: LD_VAR 0 1
103865: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103866: LD_INT 0
103868: PPUSH
103869: PPUSH
103870: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103871: LD_ADDR_VAR 0 6
103875: PUSH
103876: LD_VAR 0 1
103880: PUSH
103881: LD_VAR 0 3
103885: PLUS
103886: PUSH
103887: LD_INT 2
103889: DIV
103890: ST_TO_ADDR
// if _x < 0 then
103891: LD_VAR 0 6
103895: PUSH
103896: LD_INT 0
103898: LESS
103899: IFFALSE 103916
// _x := _x * - 1 ;
103901: LD_ADDR_VAR 0 6
103905: PUSH
103906: LD_VAR 0 6
103910: PUSH
103911: LD_INT 1
103913: NEG
103914: MUL
103915: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103916: LD_ADDR_VAR 0 7
103920: PUSH
103921: LD_VAR 0 2
103925: PUSH
103926: LD_VAR 0 4
103930: PLUS
103931: PUSH
103932: LD_INT 2
103934: DIV
103935: ST_TO_ADDR
// if _y < 0 then
103936: LD_VAR 0 7
103940: PUSH
103941: LD_INT 0
103943: LESS
103944: IFFALSE 103961
// _y := _y * - 1 ;
103946: LD_ADDR_VAR 0 7
103950: PUSH
103951: LD_VAR 0 7
103955: PUSH
103956: LD_INT 1
103958: NEG
103959: MUL
103960: ST_TO_ADDR
// result := [ _x , _y ] ;
103961: LD_ADDR_VAR 0 5
103965: PUSH
103966: LD_VAR 0 6
103970: PUSH
103971: LD_VAR 0 7
103975: PUSH
103976: EMPTY
103977: LIST
103978: LIST
103979: ST_TO_ADDR
// end ;
103980: LD_VAR 0 5
103984: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103985: LD_INT 0
103987: PPUSH
103988: PPUSH
103989: PPUSH
103990: PPUSH
// task := GetTaskList ( unit ) ;
103991: LD_ADDR_VAR 0 7
103995: PUSH
103996: LD_VAR 0 1
104000: PPUSH
104001: CALL_OW 437
104005: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
104006: LD_VAR 0 7
104010: NOT
104011: PUSH
104012: LD_VAR 0 1
104016: PPUSH
104017: LD_VAR 0 2
104021: PPUSH
104022: CALL_OW 308
104026: NOT
104027: AND
104028: IFFALSE 104032
// exit ;
104030: GO 104150
// if IsInArea ( unit , area ) then
104032: LD_VAR 0 1
104036: PPUSH
104037: LD_VAR 0 2
104041: PPUSH
104042: CALL_OW 308
104046: IFFALSE 104064
// begin ComMoveToArea ( unit , goAway ) ;
104048: LD_VAR 0 1
104052: PPUSH
104053: LD_VAR 0 3
104057: PPUSH
104058: CALL_OW 113
// exit ;
104062: GO 104150
// end ; if task [ 1 ] [ 1 ] <> M then
104064: LD_VAR 0 7
104068: PUSH
104069: LD_INT 1
104071: ARRAY
104072: PUSH
104073: LD_INT 1
104075: ARRAY
104076: PUSH
104077: LD_STRING M
104079: NONEQUAL
104080: IFFALSE 104084
// exit ;
104082: GO 104150
// x := task [ 1 ] [ 2 ] ;
104084: LD_ADDR_VAR 0 5
104088: PUSH
104089: LD_VAR 0 7
104093: PUSH
104094: LD_INT 1
104096: ARRAY
104097: PUSH
104098: LD_INT 2
104100: ARRAY
104101: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
104102: LD_ADDR_VAR 0 6
104106: PUSH
104107: LD_VAR 0 7
104111: PUSH
104112: LD_INT 1
104114: ARRAY
104115: PUSH
104116: LD_INT 3
104118: ARRAY
104119: ST_TO_ADDR
// if InArea ( x , y , area ) then
104120: LD_VAR 0 5
104124: PPUSH
104125: LD_VAR 0 6
104129: PPUSH
104130: LD_VAR 0 2
104134: PPUSH
104135: CALL_OW 309
104139: IFFALSE 104150
// ComStop ( unit ) ;
104141: LD_VAR 0 1
104145: PPUSH
104146: CALL_OW 141
// end ;
104150: LD_VAR 0 4
104154: RET
// export function Abs ( value ) ; begin
104155: LD_INT 0
104157: PPUSH
// result := value ;
104158: LD_ADDR_VAR 0 2
104162: PUSH
104163: LD_VAR 0 1
104167: ST_TO_ADDR
// if value < 0 then
104168: LD_VAR 0 1
104172: PUSH
104173: LD_INT 0
104175: LESS
104176: IFFALSE 104193
// result := value * - 1 ;
104178: LD_ADDR_VAR 0 2
104182: PUSH
104183: LD_VAR 0 1
104187: PUSH
104188: LD_INT 1
104190: NEG
104191: MUL
104192: ST_TO_ADDR
// end ;
104193: LD_VAR 0 2
104197: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
104198: LD_INT 0
104200: PPUSH
104201: PPUSH
104202: PPUSH
104203: PPUSH
104204: PPUSH
104205: PPUSH
104206: PPUSH
104207: PPUSH
// if not unit or not building then
104208: LD_VAR 0 1
104212: NOT
104213: PUSH
104214: LD_VAR 0 2
104218: NOT
104219: OR
104220: IFFALSE 104224
// exit ;
104222: GO 104450
// x := GetX ( building ) ;
104224: LD_ADDR_VAR 0 4
104228: PUSH
104229: LD_VAR 0 2
104233: PPUSH
104234: CALL_OW 250
104238: ST_TO_ADDR
// y := GetY ( building ) ;
104239: LD_ADDR_VAR 0 6
104243: PUSH
104244: LD_VAR 0 2
104248: PPUSH
104249: CALL_OW 251
104253: ST_TO_ADDR
// d := GetDir ( building ) ;
104254: LD_ADDR_VAR 0 8
104258: PUSH
104259: LD_VAR 0 2
104263: PPUSH
104264: CALL_OW 254
104268: ST_TO_ADDR
// r := 4 ;
104269: LD_ADDR_VAR 0 9
104273: PUSH
104274: LD_INT 4
104276: ST_TO_ADDR
// for i := 1 to 5 do
104277: LD_ADDR_VAR 0 10
104281: PUSH
104282: DOUBLE
104283: LD_INT 1
104285: DEC
104286: ST_TO_ADDR
104287: LD_INT 5
104289: PUSH
104290: FOR_TO
104291: IFFALSE 104448
// begin _x := ShiftX ( x , d , r + i ) ;
104293: LD_ADDR_VAR 0 5
104297: PUSH
104298: LD_VAR 0 4
104302: PPUSH
104303: LD_VAR 0 8
104307: PPUSH
104308: LD_VAR 0 9
104312: PUSH
104313: LD_VAR 0 10
104317: PLUS
104318: PPUSH
104319: CALL_OW 272
104323: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
104324: LD_ADDR_VAR 0 7
104328: PUSH
104329: LD_VAR 0 6
104333: PPUSH
104334: LD_VAR 0 8
104338: PPUSH
104339: LD_VAR 0 9
104343: PUSH
104344: LD_VAR 0 10
104348: PLUS
104349: PPUSH
104350: CALL_OW 273
104354: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
104355: LD_VAR 0 5
104359: PPUSH
104360: LD_VAR 0 7
104364: PPUSH
104365: CALL_OW 488
104369: PUSH
104370: LD_VAR 0 5
104374: PPUSH
104375: LD_VAR 0 7
104379: PPUSH
104380: CALL_OW 428
104384: PPUSH
104385: CALL_OW 247
104389: PUSH
104390: LD_INT 3
104392: PUSH
104393: LD_INT 2
104395: PUSH
104396: EMPTY
104397: LIST
104398: LIST
104399: IN
104400: NOT
104401: AND
104402: IFFALSE 104446
// begin ComMoveXY ( unit , _x , _y ) ;
104404: LD_VAR 0 1
104408: PPUSH
104409: LD_VAR 0 5
104413: PPUSH
104414: LD_VAR 0 7
104418: PPUSH
104419: CALL_OW 111
// result := [ _x , _y ] ;
104423: LD_ADDR_VAR 0 3
104427: PUSH
104428: LD_VAR 0 5
104432: PUSH
104433: LD_VAR 0 7
104437: PUSH
104438: EMPTY
104439: LIST
104440: LIST
104441: ST_TO_ADDR
// exit ;
104442: POP
104443: POP
104444: GO 104450
// end ; end ;
104446: GO 104290
104448: POP
104449: POP
// end ;
104450: LD_VAR 0 3
104454: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
104455: LD_INT 0
104457: PPUSH
104458: PPUSH
104459: PPUSH
// result := 0 ;
104460: LD_ADDR_VAR 0 3
104464: PUSH
104465: LD_INT 0
104467: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
104468: LD_VAR 0 1
104472: PUSH
104473: LD_INT 0
104475: LESS
104476: PUSH
104477: LD_VAR 0 1
104481: PUSH
104482: LD_INT 8
104484: GREATER
104485: OR
104486: PUSH
104487: LD_VAR 0 2
104491: PUSH
104492: LD_INT 0
104494: LESS
104495: OR
104496: PUSH
104497: LD_VAR 0 2
104501: PUSH
104502: LD_INT 8
104504: GREATER
104505: OR
104506: IFFALSE 104510
// exit ;
104508: GO 104585
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
104510: LD_ADDR_VAR 0 4
104514: PUSH
104515: LD_INT 22
104517: PUSH
104518: LD_VAR 0 2
104522: PUSH
104523: EMPTY
104524: LIST
104525: LIST
104526: PPUSH
104527: CALL_OW 69
104531: PUSH
104532: FOR_IN
104533: IFFALSE 104583
// begin un := UnitShoot ( i ) ;
104535: LD_ADDR_VAR 0 5
104539: PUSH
104540: LD_VAR 0 4
104544: PPUSH
104545: CALL_OW 504
104549: ST_TO_ADDR
// if GetSide ( un ) = side1 then
104550: LD_VAR 0 5
104554: PPUSH
104555: CALL_OW 255
104559: PUSH
104560: LD_VAR 0 1
104564: EQUAL
104565: IFFALSE 104581
// begin result := un ;
104567: LD_ADDR_VAR 0 3
104571: PUSH
104572: LD_VAR 0 5
104576: ST_TO_ADDR
// exit ;
104577: POP
104578: POP
104579: GO 104585
// end ; end ;
104581: GO 104532
104583: POP
104584: POP
// end ;
104585: LD_VAR 0 3
104589: RET
// export function GetCargoBay ( units ) ; begin
104590: LD_INT 0
104592: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
104593: LD_ADDR_VAR 0 2
104597: PUSH
104598: LD_VAR 0 1
104602: PPUSH
104603: LD_INT 2
104605: PUSH
104606: LD_INT 34
104608: PUSH
104609: LD_INT 12
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: PUSH
104616: LD_INT 34
104618: PUSH
104619: LD_INT 51
104621: PUSH
104622: EMPTY
104623: LIST
104624: LIST
104625: PUSH
104626: LD_INT 34
104628: PUSH
104629: LD_INT 32
104631: PUSH
104632: EMPTY
104633: LIST
104634: LIST
104635: PUSH
104636: LD_INT 34
104638: PUSH
104639: LD_EXP 96
104643: PUSH
104644: EMPTY
104645: LIST
104646: LIST
104647: PUSH
104648: EMPTY
104649: LIST
104650: LIST
104651: LIST
104652: LIST
104653: LIST
104654: PPUSH
104655: CALL_OW 72
104659: ST_TO_ADDR
// end ;
104660: LD_VAR 0 2
104664: RET
// export function Negate ( value ) ; begin
104665: LD_INT 0
104667: PPUSH
// result := not value ;
104668: LD_ADDR_VAR 0 2
104672: PUSH
104673: LD_VAR 0 1
104677: NOT
104678: ST_TO_ADDR
// end ;
104679: LD_VAR 0 2
104683: RET
// export function Inc ( value ) ; begin
104684: LD_INT 0
104686: PPUSH
// result := value + 1 ;
104687: LD_ADDR_VAR 0 2
104691: PUSH
104692: LD_VAR 0 1
104696: PUSH
104697: LD_INT 1
104699: PLUS
104700: ST_TO_ADDR
// end ;
104701: LD_VAR 0 2
104705: RET
// export function Dec ( value ) ; begin
104706: LD_INT 0
104708: PPUSH
// result := value - 1 ;
104709: LD_ADDR_VAR 0 2
104713: PUSH
104714: LD_VAR 0 1
104718: PUSH
104719: LD_INT 1
104721: MINUS
104722: ST_TO_ADDR
// end ;
104723: LD_VAR 0 2
104727: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
104728: LD_INT 0
104730: PPUSH
104731: PPUSH
104732: PPUSH
104733: PPUSH
104734: PPUSH
104735: PPUSH
104736: PPUSH
104737: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
104738: LD_VAR 0 1
104742: PPUSH
104743: LD_VAR 0 2
104747: PPUSH
104748: CALL_OW 488
104752: NOT
104753: PUSH
104754: LD_VAR 0 3
104758: PPUSH
104759: LD_VAR 0 4
104763: PPUSH
104764: CALL_OW 488
104768: NOT
104769: OR
104770: IFFALSE 104783
// begin result := - 1 ;
104772: LD_ADDR_VAR 0 5
104776: PUSH
104777: LD_INT 1
104779: NEG
104780: ST_TO_ADDR
// exit ;
104781: GO 105018
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
104783: LD_ADDR_VAR 0 12
104787: PUSH
104788: LD_VAR 0 1
104792: PPUSH
104793: LD_VAR 0 2
104797: PPUSH
104798: LD_VAR 0 3
104802: PPUSH
104803: LD_VAR 0 4
104807: PPUSH
104808: CALL 103866 0 4
104812: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
104813: LD_ADDR_VAR 0 11
104817: PUSH
104818: LD_VAR 0 1
104822: PPUSH
104823: LD_VAR 0 2
104827: PPUSH
104828: LD_VAR 0 12
104832: PUSH
104833: LD_INT 1
104835: ARRAY
104836: PPUSH
104837: LD_VAR 0 12
104841: PUSH
104842: LD_INT 2
104844: ARRAY
104845: PPUSH
104846: CALL_OW 298
104850: ST_TO_ADDR
// distance := 9999 ;
104851: LD_ADDR_VAR 0 10
104855: PUSH
104856: LD_INT 9999
104858: ST_TO_ADDR
// for i := 0 to 5 do
104859: LD_ADDR_VAR 0 6
104863: PUSH
104864: DOUBLE
104865: LD_INT 0
104867: DEC
104868: ST_TO_ADDR
104869: LD_INT 5
104871: PUSH
104872: FOR_TO
104873: IFFALSE 105016
// begin _x := ShiftX ( x1 , i , centerDist ) ;
104875: LD_ADDR_VAR 0 7
104879: PUSH
104880: LD_VAR 0 1
104884: PPUSH
104885: LD_VAR 0 6
104889: PPUSH
104890: LD_VAR 0 11
104894: PPUSH
104895: CALL_OW 272
104899: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
104900: LD_ADDR_VAR 0 8
104904: PUSH
104905: LD_VAR 0 2
104909: PPUSH
104910: LD_VAR 0 6
104914: PPUSH
104915: LD_VAR 0 11
104919: PPUSH
104920: CALL_OW 273
104924: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104925: LD_VAR 0 7
104929: PPUSH
104930: LD_VAR 0 8
104934: PPUSH
104935: CALL_OW 488
104939: NOT
104940: IFFALSE 104944
// continue ;
104942: GO 104872
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
104944: LD_ADDR_VAR 0 9
104948: PUSH
104949: LD_VAR 0 12
104953: PUSH
104954: LD_INT 1
104956: ARRAY
104957: PPUSH
104958: LD_VAR 0 12
104962: PUSH
104963: LD_INT 2
104965: ARRAY
104966: PPUSH
104967: LD_VAR 0 7
104971: PPUSH
104972: LD_VAR 0 8
104976: PPUSH
104977: CALL_OW 298
104981: ST_TO_ADDR
// if tmp < distance then
104982: LD_VAR 0 9
104986: PUSH
104987: LD_VAR 0 10
104991: LESS
104992: IFFALSE 105014
// begin result := i ;
104994: LD_ADDR_VAR 0 5
104998: PUSH
104999: LD_VAR 0 6
105003: ST_TO_ADDR
// distance := tmp ;
105004: LD_ADDR_VAR 0 10
105008: PUSH
105009: LD_VAR 0 9
105013: ST_TO_ADDR
// end ; end ;
105014: GO 104872
105016: POP
105017: POP
// end ;
105018: LD_VAR 0 5
105022: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
105023: LD_INT 0
105025: PPUSH
105026: PPUSH
// if not driver or not IsInUnit ( driver ) then
105027: LD_VAR 0 1
105031: NOT
105032: PUSH
105033: LD_VAR 0 1
105037: PPUSH
105038: CALL_OW 310
105042: NOT
105043: OR
105044: IFFALSE 105048
// exit ;
105046: GO 105138
// vehicle := IsInUnit ( driver ) ;
105048: LD_ADDR_VAR 0 3
105052: PUSH
105053: LD_VAR 0 1
105057: PPUSH
105058: CALL_OW 310
105062: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
105063: LD_VAR 0 1
105067: PPUSH
105068: LD_STRING \
105070: PUSH
105071: LD_INT 0
105073: PUSH
105074: LD_INT 0
105076: PUSH
105077: LD_INT 0
105079: PUSH
105080: LD_INT 0
105082: PUSH
105083: LD_INT 0
105085: PUSH
105086: LD_INT 0
105088: PUSH
105089: EMPTY
105090: LIST
105091: LIST
105092: LIST
105093: LIST
105094: LIST
105095: LIST
105096: LIST
105097: PUSH
105098: LD_STRING E
105100: PUSH
105101: LD_INT 0
105103: PUSH
105104: LD_INT 0
105106: PUSH
105107: LD_VAR 0 3
105111: PUSH
105112: LD_INT 0
105114: PUSH
105115: LD_INT 0
105117: PUSH
105118: LD_INT 0
105120: PUSH
105121: EMPTY
105122: LIST
105123: LIST
105124: LIST
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: PUSH
105130: EMPTY
105131: LIST
105132: LIST
105133: PPUSH
105134: CALL_OW 446
// end ;
105138: LD_VAR 0 2
105142: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
105143: LD_INT 0
105145: PPUSH
105146: PPUSH
// if not driver or not IsInUnit ( driver ) then
105147: LD_VAR 0 1
105151: NOT
105152: PUSH
105153: LD_VAR 0 1
105157: PPUSH
105158: CALL_OW 310
105162: NOT
105163: OR
105164: IFFALSE 105168
// exit ;
105166: GO 105258
// vehicle := IsInUnit ( driver ) ;
105168: LD_ADDR_VAR 0 3
105172: PUSH
105173: LD_VAR 0 1
105177: PPUSH
105178: CALL_OW 310
105182: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
105183: LD_VAR 0 1
105187: PPUSH
105188: LD_STRING \
105190: PUSH
105191: LD_INT 0
105193: PUSH
105194: LD_INT 0
105196: PUSH
105197: LD_INT 0
105199: PUSH
105200: LD_INT 0
105202: PUSH
105203: LD_INT 0
105205: PUSH
105206: LD_INT 0
105208: PUSH
105209: EMPTY
105210: LIST
105211: LIST
105212: LIST
105213: LIST
105214: LIST
105215: LIST
105216: LIST
105217: PUSH
105218: LD_STRING E
105220: PUSH
105221: LD_INT 0
105223: PUSH
105224: LD_INT 0
105226: PUSH
105227: LD_VAR 0 3
105231: PUSH
105232: LD_INT 0
105234: PUSH
105235: LD_INT 0
105237: PUSH
105238: LD_INT 0
105240: PUSH
105241: EMPTY
105242: LIST
105243: LIST
105244: LIST
105245: LIST
105246: LIST
105247: LIST
105248: LIST
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: PPUSH
105254: CALL_OW 447
// end ;
105258: LD_VAR 0 2
105262: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
105263: LD_INT 0
105265: PPUSH
105266: PPUSH
105267: PPUSH
// tmp := [ ] ;
105268: LD_ADDR_VAR 0 5
105272: PUSH
105273: EMPTY
105274: ST_TO_ADDR
// for i in units do
105275: LD_ADDR_VAR 0 4
105279: PUSH
105280: LD_VAR 0 1
105284: PUSH
105285: FOR_IN
105286: IFFALSE 105324
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
105288: LD_ADDR_VAR 0 5
105292: PUSH
105293: LD_VAR 0 5
105297: PPUSH
105298: LD_VAR 0 5
105302: PUSH
105303: LD_INT 1
105305: PLUS
105306: PPUSH
105307: LD_VAR 0 4
105311: PPUSH
105312: CALL_OW 256
105316: PPUSH
105317: CALL_OW 2
105321: ST_TO_ADDR
105322: GO 105285
105324: POP
105325: POP
// if not tmp then
105326: LD_VAR 0 5
105330: NOT
105331: IFFALSE 105335
// exit ;
105333: GO 105383
// if asc then
105335: LD_VAR 0 2
105339: IFFALSE 105363
// result := SortListByListAsc ( units , tmp ) else
105341: LD_ADDR_VAR 0 3
105345: PUSH
105346: LD_VAR 0 1
105350: PPUSH
105351: LD_VAR 0 5
105355: PPUSH
105356: CALL_OW 76
105360: ST_TO_ADDR
105361: GO 105383
// result := SortListByListDesc ( units , tmp ) ;
105363: LD_ADDR_VAR 0 3
105367: PUSH
105368: LD_VAR 0 1
105372: PPUSH
105373: LD_VAR 0 5
105377: PPUSH
105378: CALL_OW 77
105382: ST_TO_ADDR
// end ;
105383: LD_VAR 0 3
105387: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
105388: LD_INT 0
105390: PPUSH
105391: PPUSH
// task := GetTaskList ( mech ) ;
105392: LD_ADDR_VAR 0 4
105396: PUSH
105397: LD_VAR 0 1
105401: PPUSH
105402: CALL_OW 437
105406: ST_TO_ADDR
// if not task then
105407: LD_VAR 0 4
105411: NOT
105412: IFFALSE 105416
// exit ;
105414: GO 105458
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
105416: LD_ADDR_VAR 0 3
105420: PUSH
105421: LD_VAR 0 4
105425: PUSH
105426: LD_INT 1
105428: ARRAY
105429: PUSH
105430: LD_INT 1
105432: ARRAY
105433: PUSH
105434: LD_STRING r
105436: EQUAL
105437: PUSH
105438: LD_VAR 0 4
105442: PUSH
105443: LD_INT 1
105445: ARRAY
105446: PUSH
105447: LD_INT 4
105449: ARRAY
105450: PUSH
105451: LD_VAR 0 2
105455: EQUAL
105456: AND
105457: ST_TO_ADDR
// end ;
105458: LD_VAR 0 3
105462: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
105463: LD_INT 0
105465: PPUSH
// SetDir ( unit , d ) ;
105466: LD_VAR 0 1
105470: PPUSH
105471: LD_VAR 0 4
105475: PPUSH
105476: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
105480: LD_VAR 0 1
105484: PPUSH
105485: LD_VAR 0 2
105489: PPUSH
105490: LD_VAR 0 3
105494: PPUSH
105495: LD_VAR 0 5
105499: PPUSH
105500: CALL_OW 48
// end ;
105504: LD_VAR 0 6
105508: RET
// export function ToNaturalNumber ( number ) ; begin
105509: LD_INT 0
105511: PPUSH
// result := number div 1 ;
105512: LD_ADDR_VAR 0 2
105516: PUSH
105517: LD_VAR 0 1
105521: PUSH
105522: LD_INT 1
105524: DIV
105525: ST_TO_ADDR
// if number < 0 then
105526: LD_VAR 0 1
105530: PUSH
105531: LD_INT 0
105533: LESS
105534: IFFALSE 105544
// result := 0 ;
105536: LD_ADDR_VAR 0 2
105540: PUSH
105541: LD_INT 0
105543: ST_TO_ADDR
// end ;
105544: LD_VAR 0 2
105548: RET
// export function SortByClass ( units , class ) ; var un ; begin
105549: LD_INT 0
105551: PPUSH
105552: PPUSH
// if not units or not class then
105553: LD_VAR 0 1
105557: NOT
105558: PUSH
105559: LD_VAR 0 2
105563: NOT
105564: OR
105565: IFFALSE 105569
// exit ;
105567: GO 105664
// result := [ ] ;
105569: LD_ADDR_VAR 0 3
105573: PUSH
105574: EMPTY
105575: ST_TO_ADDR
// for un in units do
105576: LD_ADDR_VAR 0 4
105580: PUSH
105581: LD_VAR 0 1
105585: PUSH
105586: FOR_IN
105587: IFFALSE 105662
// if GetClass ( un ) = class then
105589: LD_VAR 0 4
105593: PPUSH
105594: CALL_OW 257
105598: PUSH
105599: LD_VAR 0 2
105603: EQUAL
105604: IFFALSE 105631
// result := Insert ( result , 1 , un ) else
105606: LD_ADDR_VAR 0 3
105610: PUSH
105611: LD_VAR 0 3
105615: PPUSH
105616: LD_INT 1
105618: PPUSH
105619: LD_VAR 0 4
105623: PPUSH
105624: CALL_OW 2
105628: ST_TO_ADDR
105629: GO 105660
// result := Replace ( result , result + 1 , un ) ;
105631: LD_ADDR_VAR 0 3
105635: PUSH
105636: LD_VAR 0 3
105640: PPUSH
105641: LD_VAR 0 3
105645: PUSH
105646: LD_INT 1
105648: PLUS
105649: PPUSH
105650: LD_VAR 0 4
105654: PPUSH
105655: CALL_OW 1
105659: ST_TO_ADDR
105660: GO 105586
105662: POP
105663: POP
// end ;
105664: LD_VAR 0 3
105668: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
105669: LD_INT 0
105671: PPUSH
105672: PPUSH
105673: PPUSH
105674: PPUSH
105675: PPUSH
105676: PPUSH
105677: PPUSH
// result := [ ] ;
105678: LD_ADDR_VAR 0 4
105682: PUSH
105683: EMPTY
105684: ST_TO_ADDR
// if x - r < 0 then
105685: LD_VAR 0 1
105689: PUSH
105690: LD_VAR 0 3
105694: MINUS
105695: PUSH
105696: LD_INT 0
105698: LESS
105699: IFFALSE 105711
// min_x := 0 else
105701: LD_ADDR_VAR 0 8
105705: PUSH
105706: LD_INT 0
105708: ST_TO_ADDR
105709: GO 105727
// min_x := x - r ;
105711: LD_ADDR_VAR 0 8
105715: PUSH
105716: LD_VAR 0 1
105720: PUSH
105721: LD_VAR 0 3
105725: MINUS
105726: ST_TO_ADDR
// if y - r < 0 then
105727: LD_VAR 0 2
105731: PUSH
105732: LD_VAR 0 3
105736: MINUS
105737: PUSH
105738: LD_INT 0
105740: LESS
105741: IFFALSE 105753
// min_y := 0 else
105743: LD_ADDR_VAR 0 7
105747: PUSH
105748: LD_INT 0
105750: ST_TO_ADDR
105751: GO 105769
// min_y := y - r ;
105753: LD_ADDR_VAR 0 7
105757: PUSH
105758: LD_VAR 0 2
105762: PUSH
105763: LD_VAR 0 3
105767: MINUS
105768: ST_TO_ADDR
// max_x := x + r ;
105769: LD_ADDR_VAR 0 9
105773: PUSH
105774: LD_VAR 0 1
105778: PUSH
105779: LD_VAR 0 3
105783: PLUS
105784: ST_TO_ADDR
// max_y := y + r ;
105785: LD_ADDR_VAR 0 10
105789: PUSH
105790: LD_VAR 0 2
105794: PUSH
105795: LD_VAR 0 3
105799: PLUS
105800: ST_TO_ADDR
// for _x = min_x to max_x do
105801: LD_ADDR_VAR 0 5
105805: PUSH
105806: DOUBLE
105807: LD_VAR 0 8
105811: DEC
105812: ST_TO_ADDR
105813: LD_VAR 0 9
105817: PUSH
105818: FOR_TO
105819: IFFALSE 105920
// for _y = min_y to max_y do
105821: LD_ADDR_VAR 0 6
105825: PUSH
105826: DOUBLE
105827: LD_VAR 0 7
105831: DEC
105832: ST_TO_ADDR
105833: LD_VAR 0 10
105837: PUSH
105838: FOR_TO
105839: IFFALSE 105916
// begin if not ValidHex ( _x , _y ) then
105841: LD_VAR 0 5
105845: PPUSH
105846: LD_VAR 0 6
105850: PPUSH
105851: CALL_OW 488
105855: NOT
105856: IFFALSE 105860
// continue ;
105858: GO 105838
// if GetResourceTypeXY ( _x , _y ) then
105860: LD_VAR 0 5
105864: PPUSH
105865: LD_VAR 0 6
105869: PPUSH
105870: CALL_OW 283
105874: IFFALSE 105914
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
105876: LD_ADDR_VAR 0 4
105880: PUSH
105881: LD_VAR 0 4
105885: PPUSH
105886: LD_VAR 0 4
105890: PUSH
105891: LD_INT 1
105893: PLUS
105894: PPUSH
105895: LD_VAR 0 5
105899: PUSH
105900: LD_VAR 0 6
105904: PUSH
105905: EMPTY
105906: LIST
105907: LIST
105908: PPUSH
105909: CALL_OW 1
105913: ST_TO_ADDR
// end ;
105914: GO 105838
105916: POP
105917: POP
105918: GO 105818
105920: POP
105921: POP
// end ;
105922: LD_VAR 0 4
105926: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
105927: LD_INT 0
105929: PPUSH
105930: PPUSH
105931: PPUSH
105932: PPUSH
105933: PPUSH
105934: PPUSH
105935: PPUSH
105936: PPUSH
// if not units then
105937: LD_VAR 0 1
105941: NOT
105942: IFFALSE 105946
// exit ;
105944: GO 106472
// result := UnitFilter ( units , [ f_ok ] ) ;
105946: LD_ADDR_VAR 0 3
105950: PUSH
105951: LD_VAR 0 1
105955: PPUSH
105956: LD_INT 50
105958: PUSH
105959: EMPTY
105960: LIST
105961: PPUSH
105962: CALL_OW 72
105966: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105967: LD_ADDR_VAR 0 8
105971: PUSH
105972: LD_VAR 0 1
105976: PUSH
105977: LD_INT 1
105979: ARRAY
105980: PPUSH
105981: CALL_OW 255
105985: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
105986: LD_ADDR_VAR 0 10
105990: PUSH
105991: LD_INT 29
105993: PUSH
105994: LD_EXP 99
105998: PUSH
105999: LD_INT 49
106001: PUSH
106002: EMPTY
106003: LIST
106004: LIST
106005: LIST
106006: ST_TO_ADDR
// if not result then
106007: LD_VAR 0 3
106011: NOT
106012: IFFALSE 106016
// exit ;
106014: GO 106472
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
106016: LD_ADDR_VAR 0 5
106020: PUSH
106021: LD_INT 81
106023: PUSH
106024: LD_VAR 0 8
106028: PUSH
106029: EMPTY
106030: LIST
106031: LIST
106032: PPUSH
106033: CALL_OW 69
106037: ST_TO_ADDR
// for i in result do
106038: LD_ADDR_VAR 0 4
106042: PUSH
106043: LD_VAR 0 3
106047: PUSH
106048: FOR_IN
106049: IFFALSE 106470
// begin tag := GetTag ( i ) + 1 ;
106051: LD_ADDR_VAR 0 9
106055: PUSH
106056: LD_VAR 0 4
106060: PPUSH
106061: CALL_OW 110
106065: PUSH
106066: LD_INT 1
106068: PLUS
106069: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
106070: LD_ADDR_VAR 0 7
106074: PUSH
106075: LD_VAR 0 4
106079: PPUSH
106080: CALL_OW 250
106084: PPUSH
106085: LD_VAR 0 4
106089: PPUSH
106090: CALL_OW 251
106094: PPUSH
106095: LD_INT 6
106097: PPUSH
106098: CALL 105669 0 3
106102: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
106103: LD_VAR 0 4
106107: PPUSH
106108: CALL_OW 247
106112: PUSH
106113: LD_INT 2
106115: EQUAL
106116: PUSH
106117: LD_VAR 0 7
106121: AND
106122: PUSH
106123: LD_VAR 0 4
106127: PPUSH
106128: CALL_OW 264
106132: PUSH
106133: LD_VAR 0 10
106137: IN
106138: NOT
106139: AND
106140: IFFALSE 106179
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
106142: LD_VAR 0 4
106146: PPUSH
106147: LD_VAR 0 7
106151: PUSH
106152: LD_INT 1
106154: ARRAY
106155: PUSH
106156: LD_INT 1
106158: ARRAY
106159: PPUSH
106160: LD_VAR 0 7
106164: PUSH
106165: LD_INT 1
106167: ARRAY
106168: PUSH
106169: LD_INT 2
106171: ARRAY
106172: PPUSH
106173: CALL_OW 116
106177: GO 106468
// if path > tag then
106179: LD_VAR 0 2
106183: PUSH
106184: LD_VAR 0 9
106188: GREATER
106189: IFFALSE 106397
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
106191: LD_ADDR_VAR 0 6
106195: PUSH
106196: LD_VAR 0 5
106200: PPUSH
106201: LD_INT 91
106203: PUSH
106204: LD_VAR 0 4
106208: PUSH
106209: LD_INT 8
106211: PUSH
106212: EMPTY
106213: LIST
106214: LIST
106215: LIST
106216: PPUSH
106217: CALL_OW 72
106221: ST_TO_ADDR
// if nearEnemy then
106222: LD_VAR 0 6
106226: IFFALSE 106295
// begin if GetWeapon ( i ) = ru_time_lapser then
106228: LD_VAR 0 4
106232: PPUSH
106233: CALL_OW 264
106237: PUSH
106238: LD_INT 49
106240: EQUAL
106241: IFFALSE 106269
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
106243: LD_VAR 0 4
106247: PPUSH
106248: LD_VAR 0 6
106252: PPUSH
106253: LD_VAR 0 4
106257: PPUSH
106258: CALL_OW 74
106262: PPUSH
106263: CALL_OW 112
106267: GO 106293
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
106269: LD_VAR 0 4
106273: PPUSH
106274: LD_VAR 0 6
106278: PPUSH
106279: LD_VAR 0 4
106283: PPUSH
106284: CALL_OW 74
106288: PPUSH
106289: CALL_OW 115
// end else
106293: GO 106395
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
106295: LD_VAR 0 4
106299: PPUSH
106300: LD_VAR 0 2
106304: PUSH
106305: LD_VAR 0 9
106309: ARRAY
106310: PUSH
106311: LD_INT 1
106313: ARRAY
106314: PPUSH
106315: LD_VAR 0 2
106319: PUSH
106320: LD_VAR 0 9
106324: ARRAY
106325: PUSH
106326: LD_INT 2
106328: ARRAY
106329: PPUSH
106330: CALL_OW 297
106334: PUSH
106335: LD_INT 6
106337: GREATER
106338: IFFALSE 106381
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
106340: LD_VAR 0 4
106344: PPUSH
106345: LD_VAR 0 2
106349: PUSH
106350: LD_VAR 0 9
106354: ARRAY
106355: PUSH
106356: LD_INT 1
106358: ARRAY
106359: PPUSH
106360: LD_VAR 0 2
106364: PUSH
106365: LD_VAR 0 9
106369: ARRAY
106370: PUSH
106371: LD_INT 2
106373: ARRAY
106374: PPUSH
106375: CALL_OW 114
106379: GO 106395
// SetTag ( i , tag ) ;
106381: LD_VAR 0 4
106385: PPUSH
106386: LD_VAR 0 9
106390: PPUSH
106391: CALL_OW 109
// end else
106395: GO 106468
// if enemy then
106397: LD_VAR 0 5
106401: IFFALSE 106468
// begin if GetWeapon ( i ) = ru_time_lapser then
106403: LD_VAR 0 4
106407: PPUSH
106408: CALL_OW 264
106412: PUSH
106413: LD_INT 49
106415: EQUAL
106416: IFFALSE 106444
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
106418: LD_VAR 0 4
106422: PPUSH
106423: LD_VAR 0 5
106427: PPUSH
106428: LD_VAR 0 4
106432: PPUSH
106433: CALL_OW 74
106437: PPUSH
106438: CALL_OW 112
106442: GO 106468
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
106444: LD_VAR 0 4
106448: PPUSH
106449: LD_VAR 0 5
106453: PPUSH
106454: LD_VAR 0 4
106458: PPUSH
106459: CALL_OW 74
106463: PPUSH
106464: CALL_OW 115
// end ; end ;
106468: GO 106048
106470: POP
106471: POP
// end ;
106472: LD_VAR 0 3
106476: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
106477: LD_INT 0
106479: PPUSH
106480: PPUSH
106481: PPUSH
// if not unit or IsInUnit ( unit ) then
106482: LD_VAR 0 1
106486: NOT
106487: PUSH
106488: LD_VAR 0 1
106492: PPUSH
106493: CALL_OW 310
106497: OR
106498: IFFALSE 106502
// exit ;
106500: GO 106593
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
106502: LD_ADDR_VAR 0 4
106506: PUSH
106507: LD_VAR 0 1
106511: PPUSH
106512: CALL_OW 250
106516: PPUSH
106517: LD_VAR 0 2
106521: PPUSH
106522: LD_INT 1
106524: PPUSH
106525: CALL_OW 272
106529: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
106530: LD_ADDR_VAR 0 5
106534: PUSH
106535: LD_VAR 0 1
106539: PPUSH
106540: CALL_OW 251
106544: PPUSH
106545: LD_VAR 0 2
106549: PPUSH
106550: LD_INT 1
106552: PPUSH
106553: CALL_OW 273
106557: ST_TO_ADDR
// if ValidHex ( x , y ) then
106558: LD_VAR 0 4
106562: PPUSH
106563: LD_VAR 0 5
106567: PPUSH
106568: CALL_OW 488
106572: IFFALSE 106593
// ComTurnXY ( unit , x , y ) ;
106574: LD_VAR 0 1
106578: PPUSH
106579: LD_VAR 0 4
106583: PPUSH
106584: LD_VAR 0 5
106588: PPUSH
106589: CALL_OW 118
// end ;
106593: LD_VAR 0 3
106597: RET
// export function SeeUnits ( side , units ) ; var i ; begin
106598: LD_INT 0
106600: PPUSH
106601: PPUSH
// result := false ;
106602: LD_ADDR_VAR 0 3
106606: PUSH
106607: LD_INT 0
106609: ST_TO_ADDR
// if not units then
106610: LD_VAR 0 2
106614: NOT
106615: IFFALSE 106619
// exit ;
106617: GO 106664
// for i in units do
106619: LD_ADDR_VAR 0 4
106623: PUSH
106624: LD_VAR 0 2
106628: PUSH
106629: FOR_IN
106630: IFFALSE 106662
// if See ( side , i ) then
106632: LD_VAR 0 1
106636: PPUSH
106637: LD_VAR 0 4
106641: PPUSH
106642: CALL_OW 292
106646: IFFALSE 106660
// begin result := true ;
106648: LD_ADDR_VAR 0 3
106652: PUSH
106653: LD_INT 1
106655: ST_TO_ADDR
// exit ;
106656: POP
106657: POP
106658: GO 106664
// end ;
106660: GO 106629
106662: POP
106663: POP
// end ;
106664: LD_VAR 0 3
106668: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
106669: LD_INT 0
106671: PPUSH
106672: PPUSH
106673: PPUSH
106674: PPUSH
// if not unit or not points then
106675: LD_VAR 0 1
106679: NOT
106680: PUSH
106681: LD_VAR 0 2
106685: NOT
106686: OR
106687: IFFALSE 106691
// exit ;
106689: GO 106781
// dist := 99999 ;
106691: LD_ADDR_VAR 0 5
106695: PUSH
106696: LD_INT 99999
106698: ST_TO_ADDR
// for i in points do
106699: LD_ADDR_VAR 0 4
106703: PUSH
106704: LD_VAR 0 2
106708: PUSH
106709: FOR_IN
106710: IFFALSE 106779
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
106712: LD_ADDR_VAR 0 6
106716: PUSH
106717: LD_VAR 0 1
106721: PPUSH
106722: LD_VAR 0 4
106726: PUSH
106727: LD_INT 1
106729: ARRAY
106730: PPUSH
106731: LD_VAR 0 4
106735: PUSH
106736: LD_INT 2
106738: ARRAY
106739: PPUSH
106740: CALL_OW 297
106744: ST_TO_ADDR
// if tmpDist < dist then
106745: LD_VAR 0 6
106749: PUSH
106750: LD_VAR 0 5
106754: LESS
106755: IFFALSE 106777
// begin result := i ;
106757: LD_ADDR_VAR 0 3
106761: PUSH
106762: LD_VAR 0 4
106766: ST_TO_ADDR
// dist := tmpDist ;
106767: LD_ADDR_VAR 0 5
106771: PUSH
106772: LD_VAR 0 6
106776: ST_TO_ADDR
// end ; end ;
106777: GO 106709
106779: POP
106780: POP
// end ;
106781: LD_VAR 0 3
106785: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
106786: LD_INT 0
106788: PPUSH
// uc_side := side ;
106789: LD_ADDR_OWVAR 20
106793: PUSH
106794: LD_VAR 0 1
106798: ST_TO_ADDR
// uc_nation := 3 ;
106799: LD_ADDR_OWVAR 21
106803: PUSH
106804: LD_INT 3
106806: ST_TO_ADDR
// vc_chassis := 25 ;
106807: LD_ADDR_OWVAR 37
106811: PUSH
106812: LD_INT 25
106814: ST_TO_ADDR
// vc_engine := engine_siberite ;
106815: LD_ADDR_OWVAR 39
106819: PUSH
106820: LD_INT 3
106822: ST_TO_ADDR
// vc_control := control_computer ;
106823: LD_ADDR_OWVAR 38
106827: PUSH
106828: LD_INT 3
106830: ST_TO_ADDR
// vc_weapon := 59 ;
106831: LD_ADDR_OWVAR 40
106835: PUSH
106836: LD_INT 59
106838: ST_TO_ADDR
// result := CreateVehicle ;
106839: LD_ADDR_VAR 0 5
106843: PUSH
106844: CALL_OW 45
106848: ST_TO_ADDR
// SetDir ( result , d ) ;
106849: LD_VAR 0 5
106853: PPUSH
106854: LD_VAR 0 4
106858: PPUSH
106859: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
106863: LD_VAR 0 5
106867: PPUSH
106868: LD_VAR 0 2
106872: PPUSH
106873: LD_VAR 0 3
106877: PPUSH
106878: LD_INT 0
106880: PPUSH
106881: CALL_OW 48
// end ;
106885: LD_VAR 0 5
106889: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
106890: LD_INT 0
106892: PPUSH
106893: PPUSH
106894: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
106895: LD_ADDR_VAR 0 2
106899: PUSH
106900: LD_INT 0
106902: PUSH
106903: LD_INT 0
106905: PUSH
106906: LD_INT 0
106908: PUSH
106909: LD_INT 0
106911: PUSH
106912: EMPTY
106913: LIST
106914: LIST
106915: LIST
106916: LIST
106917: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
106918: LD_VAR 0 1
106922: NOT
106923: PUSH
106924: LD_VAR 0 1
106928: PPUSH
106929: CALL_OW 264
106933: PUSH
106934: LD_INT 12
106936: PUSH
106937: LD_INT 51
106939: PUSH
106940: LD_INT 32
106942: PUSH
106943: LD_EXP 96
106947: PUSH
106948: EMPTY
106949: LIST
106950: LIST
106951: LIST
106952: LIST
106953: IN
106954: NOT
106955: OR
106956: IFFALSE 106960
// exit ;
106958: GO 107058
// for i := 1 to 3 do
106960: LD_ADDR_VAR 0 3
106964: PUSH
106965: DOUBLE
106966: LD_INT 1
106968: DEC
106969: ST_TO_ADDR
106970: LD_INT 3
106972: PUSH
106973: FOR_TO
106974: IFFALSE 107056
// begin tmp := GetCargo ( cargo , i ) ;
106976: LD_ADDR_VAR 0 4
106980: PUSH
106981: LD_VAR 0 1
106985: PPUSH
106986: LD_VAR 0 3
106990: PPUSH
106991: CALL_OW 289
106995: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
106996: LD_ADDR_VAR 0 2
107000: PUSH
107001: LD_VAR 0 2
107005: PPUSH
107006: LD_VAR 0 3
107010: PPUSH
107011: LD_VAR 0 4
107015: PPUSH
107016: CALL_OW 1
107020: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
107021: LD_ADDR_VAR 0 2
107025: PUSH
107026: LD_VAR 0 2
107030: PPUSH
107031: LD_INT 4
107033: PPUSH
107034: LD_VAR 0 2
107038: PUSH
107039: LD_INT 4
107041: ARRAY
107042: PUSH
107043: LD_VAR 0 4
107047: PLUS
107048: PPUSH
107049: CALL_OW 1
107053: ST_TO_ADDR
// end ;
107054: GO 106973
107056: POP
107057: POP
// end ;
107058: LD_VAR 0 2
107062: RET
// export function Length ( array ) ; begin
107063: LD_INT 0
107065: PPUSH
// result := array + 0 ;
107066: LD_ADDR_VAR 0 2
107070: PUSH
107071: LD_VAR 0 1
107075: PUSH
107076: LD_INT 0
107078: PLUS
107079: ST_TO_ADDR
// end ;
107080: LD_VAR 0 2
107084: RET
// export function PrepareArray ( array ) ; begin
107085: LD_INT 0
107087: PPUSH
// result := array diff 0 ;
107088: LD_ADDR_VAR 0 2
107092: PUSH
107093: LD_VAR 0 1
107097: PUSH
107098: LD_INT 0
107100: DIFF
107101: ST_TO_ADDR
// if not result [ 1 ] then
107102: LD_VAR 0 2
107106: PUSH
107107: LD_INT 1
107109: ARRAY
107110: NOT
107111: IFFALSE 107131
// result := Delete ( result , 1 ) ;
107113: LD_ADDR_VAR 0 2
107117: PUSH
107118: LD_VAR 0 2
107122: PPUSH
107123: LD_INT 1
107125: PPUSH
107126: CALL_OW 3
107130: ST_TO_ADDR
// end ; end_of_file end_of_file
107131: LD_VAR 0 2
107135: RET
// every 0 0$1 do
107136: GO 107138
107138: DISABLE
// begin enable ;
107139: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
107140: LD_STRING updateTimer(
107142: PUSH
107143: LD_OWVAR 1
107147: STR
107148: PUSH
107149: LD_STRING );
107151: STR
107152: PPUSH
107153: CALL_OW 559
// end ;
107157: END
// export function SOS_MapStart ( ) ; begin
107158: LD_INT 0
107160: PPUSH
// if streamModeActive then
107161: LD_EXP 159
107165: IFFALSE 107174
// DefineStreamItems ( true ) ;
107167: LD_INT 1
107169: PPUSH
107170: CALL 108828 0 1
// UpdateFactoryWaypoints ( ) ;
107174: CALL 121689 0 0
// UpdateWarehouseGatheringPoints ( ) ;
107178: CALL 121946 0 0
// end ;
107182: LD_VAR 0 1
107186: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107187: LD_INT 0
107189: PPUSH
// if p2 = 100 then
107190: LD_VAR 0 2
107194: PUSH
107195: LD_INT 100
107197: EQUAL
107198: IFFALSE 108201
// begin if not StreamModeActive then
107200: LD_EXP 159
107204: NOT
107205: IFFALSE 107215
// StreamModeActive := true ;
107207: LD_ADDR_EXP 159
107211: PUSH
107212: LD_INT 1
107214: ST_TO_ADDR
// if p3 = 0 then
107215: LD_VAR 0 3
107219: PUSH
107220: LD_INT 0
107222: EQUAL
107223: IFFALSE 107229
// InitStreamMode ;
107225: CALL 108364 0 0
// if p3 = 1 then
107229: LD_VAR 0 3
107233: PUSH
107234: LD_INT 1
107236: EQUAL
107237: IFFALSE 107247
// sRocket := true ;
107239: LD_ADDR_EXP 164
107243: PUSH
107244: LD_INT 1
107246: ST_TO_ADDR
// if p3 = 2 then
107247: LD_VAR 0 3
107251: PUSH
107252: LD_INT 2
107254: EQUAL
107255: IFFALSE 107265
// sSpeed := true ;
107257: LD_ADDR_EXP 163
107261: PUSH
107262: LD_INT 1
107264: ST_TO_ADDR
// if p3 = 3 then
107265: LD_VAR 0 3
107269: PUSH
107270: LD_INT 3
107272: EQUAL
107273: IFFALSE 107283
// sEngine := true ;
107275: LD_ADDR_EXP 165
107279: PUSH
107280: LD_INT 1
107282: ST_TO_ADDR
// if p3 = 4 then
107283: LD_VAR 0 3
107287: PUSH
107288: LD_INT 4
107290: EQUAL
107291: IFFALSE 107301
// sSpec := true ;
107293: LD_ADDR_EXP 162
107297: PUSH
107298: LD_INT 1
107300: ST_TO_ADDR
// if p3 = 5 then
107301: LD_VAR 0 3
107305: PUSH
107306: LD_INT 5
107308: EQUAL
107309: IFFALSE 107319
// sLevel := true ;
107311: LD_ADDR_EXP 166
107315: PUSH
107316: LD_INT 1
107318: ST_TO_ADDR
// if p3 = 6 then
107319: LD_VAR 0 3
107323: PUSH
107324: LD_INT 6
107326: EQUAL
107327: IFFALSE 107337
// sArmoury := true ;
107329: LD_ADDR_EXP 167
107333: PUSH
107334: LD_INT 1
107336: ST_TO_ADDR
// if p3 = 7 then
107337: LD_VAR 0 3
107341: PUSH
107342: LD_INT 7
107344: EQUAL
107345: IFFALSE 107355
// sRadar := true ;
107347: LD_ADDR_EXP 168
107351: PUSH
107352: LD_INT 1
107354: ST_TO_ADDR
// if p3 = 8 then
107355: LD_VAR 0 3
107359: PUSH
107360: LD_INT 8
107362: EQUAL
107363: IFFALSE 107373
// sBunker := true ;
107365: LD_ADDR_EXP 169
107369: PUSH
107370: LD_INT 1
107372: ST_TO_ADDR
// if p3 = 9 then
107373: LD_VAR 0 3
107377: PUSH
107378: LD_INT 9
107380: EQUAL
107381: IFFALSE 107391
// sHack := true ;
107383: LD_ADDR_EXP 170
107387: PUSH
107388: LD_INT 1
107390: ST_TO_ADDR
// if p3 = 10 then
107391: LD_VAR 0 3
107395: PUSH
107396: LD_INT 10
107398: EQUAL
107399: IFFALSE 107409
// sFire := true ;
107401: LD_ADDR_EXP 171
107405: PUSH
107406: LD_INT 1
107408: ST_TO_ADDR
// if p3 = 11 then
107409: LD_VAR 0 3
107413: PUSH
107414: LD_INT 11
107416: EQUAL
107417: IFFALSE 107427
// sRefresh := true ;
107419: LD_ADDR_EXP 172
107423: PUSH
107424: LD_INT 1
107426: ST_TO_ADDR
// if p3 = 12 then
107427: LD_VAR 0 3
107431: PUSH
107432: LD_INT 12
107434: EQUAL
107435: IFFALSE 107445
// sExp := true ;
107437: LD_ADDR_EXP 173
107441: PUSH
107442: LD_INT 1
107444: ST_TO_ADDR
// if p3 = 13 then
107445: LD_VAR 0 3
107449: PUSH
107450: LD_INT 13
107452: EQUAL
107453: IFFALSE 107463
// sDepot := true ;
107455: LD_ADDR_EXP 174
107459: PUSH
107460: LD_INT 1
107462: ST_TO_ADDR
// if p3 = 14 then
107463: LD_VAR 0 3
107467: PUSH
107468: LD_INT 14
107470: EQUAL
107471: IFFALSE 107481
// sFlag := true ;
107473: LD_ADDR_EXP 175
107477: PUSH
107478: LD_INT 1
107480: ST_TO_ADDR
// if p3 = 15 then
107481: LD_VAR 0 3
107485: PUSH
107486: LD_INT 15
107488: EQUAL
107489: IFFALSE 107499
// sKamikadze := true ;
107491: LD_ADDR_EXP 183
107495: PUSH
107496: LD_INT 1
107498: ST_TO_ADDR
// if p3 = 16 then
107499: LD_VAR 0 3
107503: PUSH
107504: LD_INT 16
107506: EQUAL
107507: IFFALSE 107517
// sTroll := true ;
107509: LD_ADDR_EXP 184
107513: PUSH
107514: LD_INT 1
107516: ST_TO_ADDR
// if p3 = 17 then
107517: LD_VAR 0 3
107521: PUSH
107522: LD_INT 17
107524: EQUAL
107525: IFFALSE 107535
// sSlow := true ;
107527: LD_ADDR_EXP 185
107531: PUSH
107532: LD_INT 1
107534: ST_TO_ADDR
// if p3 = 18 then
107535: LD_VAR 0 3
107539: PUSH
107540: LD_INT 18
107542: EQUAL
107543: IFFALSE 107553
// sLack := true ;
107545: LD_ADDR_EXP 186
107549: PUSH
107550: LD_INT 1
107552: ST_TO_ADDR
// if p3 = 19 then
107553: LD_VAR 0 3
107557: PUSH
107558: LD_INT 19
107560: EQUAL
107561: IFFALSE 107571
// sTank := true ;
107563: LD_ADDR_EXP 188
107567: PUSH
107568: LD_INT 1
107570: ST_TO_ADDR
// if p3 = 20 then
107571: LD_VAR 0 3
107575: PUSH
107576: LD_INT 20
107578: EQUAL
107579: IFFALSE 107589
// sRemote := true ;
107581: LD_ADDR_EXP 189
107585: PUSH
107586: LD_INT 1
107588: ST_TO_ADDR
// if p3 = 21 then
107589: LD_VAR 0 3
107593: PUSH
107594: LD_INT 21
107596: EQUAL
107597: IFFALSE 107607
// sPowell := true ;
107599: LD_ADDR_EXP 190
107603: PUSH
107604: LD_INT 1
107606: ST_TO_ADDR
// if p3 = 22 then
107607: LD_VAR 0 3
107611: PUSH
107612: LD_INT 22
107614: EQUAL
107615: IFFALSE 107625
// sTeleport := true ;
107617: LD_ADDR_EXP 193
107621: PUSH
107622: LD_INT 1
107624: ST_TO_ADDR
// if p3 = 23 then
107625: LD_VAR 0 3
107629: PUSH
107630: LD_INT 23
107632: EQUAL
107633: IFFALSE 107643
// sOilTower := true ;
107635: LD_ADDR_EXP 195
107639: PUSH
107640: LD_INT 1
107642: ST_TO_ADDR
// if p3 = 24 then
107643: LD_VAR 0 3
107647: PUSH
107648: LD_INT 24
107650: EQUAL
107651: IFFALSE 107661
// sShovel := true ;
107653: LD_ADDR_EXP 196
107657: PUSH
107658: LD_INT 1
107660: ST_TO_ADDR
// if p3 = 25 then
107661: LD_VAR 0 3
107665: PUSH
107666: LD_INT 25
107668: EQUAL
107669: IFFALSE 107679
// sSheik := true ;
107671: LD_ADDR_EXP 197
107675: PUSH
107676: LD_INT 1
107678: ST_TO_ADDR
// if p3 = 26 then
107679: LD_VAR 0 3
107683: PUSH
107684: LD_INT 26
107686: EQUAL
107687: IFFALSE 107697
// sEarthquake := true ;
107689: LD_ADDR_EXP 199
107693: PUSH
107694: LD_INT 1
107696: ST_TO_ADDR
// if p3 = 27 then
107697: LD_VAR 0 3
107701: PUSH
107702: LD_INT 27
107704: EQUAL
107705: IFFALSE 107715
// sAI := true ;
107707: LD_ADDR_EXP 200
107711: PUSH
107712: LD_INT 1
107714: ST_TO_ADDR
// if p3 = 28 then
107715: LD_VAR 0 3
107719: PUSH
107720: LD_INT 28
107722: EQUAL
107723: IFFALSE 107733
// sCargo := true ;
107725: LD_ADDR_EXP 203
107729: PUSH
107730: LD_INT 1
107732: ST_TO_ADDR
// if p3 = 29 then
107733: LD_VAR 0 3
107737: PUSH
107738: LD_INT 29
107740: EQUAL
107741: IFFALSE 107751
// sDLaser := true ;
107743: LD_ADDR_EXP 204
107747: PUSH
107748: LD_INT 1
107750: ST_TO_ADDR
// if p3 = 30 then
107751: LD_VAR 0 3
107755: PUSH
107756: LD_INT 30
107758: EQUAL
107759: IFFALSE 107769
// sExchange := true ;
107761: LD_ADDR_EXP 205
107765: PUSH
107766: LD_INT 1
107768: ST_TO_ADDR
// if p3 = 31 then
107769: LD_VAR 0 3
107773: PUSH
107774: LD_INT 31
107776: EQUAL
107777: IFFALSE 107787
// sFac := true ;
107779: LD_ADDR_EXP 206
107783: PUSH
107784: LD_INT 1
107786: ST_TO_ADDR
// if p3 = 32 then
107787: LD_VAR 0 3
107791: PUSH
107792: LD_INT 32
107794: EQUAL
107795: IFFALSE 107805
// sPower := true ;
107797: LD_ADDR_EXP 207
107801: PUSH
107802: LD_INT 1
107804: ST_TO_ADDR
// if p3 = 33 then
107805: LD_VAR 0 3
107809: PUSH
107810: LD_INT 33
107812: EQUAL
107813: IFFALSE 107823
// sRandom := true ;
107815: LD_ADDR_EXP 208
107819: PUSH
107820: LD_INT 1
107822: ST_TO_ADDR
// if p3 = 34 then
107823: LD_VAR 0 3
107827: PUSH
107828: LD_INT 34
107830: EQUAL
107831: IFFALSE 107841
// sShield := true ;
107833: LD_ADDR_EXP 209
107837: PUSH
107838: LD_INT 1
107840: ST_TO_ADDR
// if p3 = 35 then
107841: LD_VAR 0 3
107845: PUSH
107846: LD_INT 35
107848: EQUAL
107849: IFFALSE 107859
// sTime := true ;
107851: LD_ADDR_EXP 210
107855: PUSH
107856: LD_INT 1
107858: ST_TO_ADDR
// if p3 = 36 then
107859: LD_VAR 0 3
107863: PUSH
107864: LD_INT 36
107866: EQUAL
107867: IFFALSE 107877
// sTools := true ;
107869: LD_ADDR_EXP 211
107873: PUSH
107874: LD_INT 1
107876: ST_TO_ADDR
// if p3 = 101 then
107877: LD_VAR 0 3
107881: PUSH
107882: LD_INT 101
107884: EQUAL
107885: IFFALSE 107895
// sSold := true ;
107887: LD_ADDR_EXP 176
107891: PUSH
107892: LD_INT 1
107894: ST_TO_ADDR
// if p3 = 102 then
107895: LD_VAR 0 3
107899: PUSH
107900: LD_INT 102
107902: EQUAL
107903: IFFALSE 107913
// sDiff := true ;
107905: LD_ADDR_EXP 177
107909: PUSH
107910: LD_INT 1
107912: ST_TO_ADDR
// if p3 = 103 then
107913: LD_VAR 0 3
107917: PUSH
107918: LD_INT 103
107920: EQUAL
107921: IFFALSE 107931
// sFog := true ;
107923: LD_ADDR_EXP 180
107927: PUSH
107928: LD_INT 1
107930: ST_TO_ADDR
// if p3 = 104 then
107931: LD_VAR 0 3
107935: PUSH
107936: LD_INT 104
107938: EQUAL
107939: IFFALSE 107949
// sReset := true ;
107941: LD_ADDR_EXP 181
107945: PUSH
107946: LD_INT 1
107948: ST_TO_ADDR
// if p3 = 105 then
107949: LD_VAR 0 3
107953: PUSH
107954: LD_INT 105
107956: EQUAL
107957: IFFALSE 107967
// sSun := true ;
107959: LD_ADDR_EXP 182
107963: PUSH
107964: LD_INT 1
107966: ST_TO_ADDR
// if p3 = 106 then
107967: LD_VAR 0 3
107971: PUSH
107972: LD_INT 106
107974: EQUAL
107975: IFFALSE 107985
// sTiger := true ;
107977: LD_ADDR_EXP 178
107981: PUSH
107982: LD_INT 1
107984: ST_TO_ADDR
// if p3 = 107 then
107985: LD_VAR 0 3
107989: PUSH
107990: LD_INT 107
107992: EQUAL
107993: IFFALSE 108003
// sBomb := true ;
107995: LD_ADDR_EXP 179
107999: PUSH
108000: LD_INT 1
108002: ST_TO_ADDR
// if p3 = 108 then
108003: LD_VAR 0 3
108007: PUSH
108008: LD_INT 108
108010: EQUAL
108011: IFFALSE 108021
// sWound := true ;
108013: LD_ADDR_EXP 187
108017: PUSH
108018: LD_INT 1
108020: ST_TO_ADDR
// if p3 = 109 then
108021: LD_VAR 0 3
108025: PUSH
108026: LD_INT 109
108028: EQUAL
108029: IFFALSE 108039
// sBetray := true ;
108031: LD_ADDR_EXP 191
108035: PUSH
108036: LD_INT 1
108038: ST_TO_ADDR
// if p3 = 110 then
108039: LD_VAR 0 3
108043: PUSH
108044: LD_INT 110
108046: EQUAL
108047: IFFALSE 108057
// sContamin := true ;
108049: LD_ADDR_EXP 192
108053: PUSH
108054: LD_INT 1
108056: ST_TO_ADDR
// if p3 = 111 then
108057: LD_VAR 0 3
108061: PUSH
108062: LD_INT 111
108064: EQUAL
108065: IFFALSE 108075
// sOil := true ;
108067: LD_ADDR_EXP 194
108071: PUSH
108072: LD_INT 1
108074: ST_TO_ADDR
// if p3 = 112 then
108075: LD_VAR 0 3
108079: PUSH
108080: LD_INT 112
108082: EQUAL
108083: IFFALSE 108093
// sStu := true ;
108085: LD_ADDR_EXP 198
108089: PUSH
108090: LD_INT 1
108092: ST_TO_ADDR
// if p3 = 113 then
108093: LD_VAR 0 3
108097: PUSH
108098: LD_INT 113
108100: EQUAL
108101: IFFALSE 108111
// sBazooka := true ;
108103: LD_ADDR_EXP 201
108107: PUSH
108108: LD_INT 1
108110: ST_TO_ADDR
// if p3 = 114 then
108111: LD_VAR 0 3
108115: PUSH
108116: LD_INT 114
108118: EQUAL
108119: IFFALSE 108129
// sMortar := true ;
108121: LD_ADDR_EXP 202
108125: PUSH
108126: LD_INT 1
108128: ST_TO_ADDR
// if p3 = 115 then
108129: LD_VAR 0 3
108133: PUSH
108134: LD_INT 115
108136: EQUAL
108137: IFFALSE 108147
// sRanger := true ;
108139: LD_ADDR_EXP 212
108143: PUSH
108144: LD_INT 1
108146: ST_TO_ADDR
// if p3 = 116 then
108147: LD_VAR 0 3
108151: PUSH
108152: LD_INT 116
108154: EQUAL
108155: IFFALSE 108165
// sComputer := true ;
108157: LD_ADDR_EXP 213
108161: PUSH
108162: LD_INT 1
108164: ST_TO_ADDR
// if p3 = 117 then
108165: LD_VAR 0 3
108169: PUSH
108170: LD_INT 117
108172: EQUAL
108173: IFFALSE 108183
// s30 := true ;
108175: LD_ADDR_EXP 214
108179: PUSH
108180: LD_INT 1
108182: ST_TO_ADDR
// if p3 = 118 then
108183: LD_VAR 0 3
108187: PUSH
108188: LD_INT 118
108190: EQUAL
108191: IFFALSE 108201
// s60 := true ;
108193: LD_ADDR_EXP 215
108197: PUSH
108198: LD_INT 1
108200: ST_TO_ADDR
// end ; if p2 = 101 then
108201: LD_VAR 0 2
108205: PUSH
108206: LD_INT 101
108208: EQUAL
108209: IFFALSE 108337
// begin case p3 of 1 :
108211: LD_VAR 0 3
108215: PUSH
108216: LD_INT 1
108218: DOUBLE
108219: EQUAL
108220: IFTRUE 108224
108222: GO 108231
108224: POP
// hHackUnlimitedResources ; 2 :
108225: CALL 120435 0 0
108229: GO 108337
108231: LD_INT 2
108233: DOUBLE
108234: EQUAL
108235: IFTRUE 108239
108237: GO 108246
108239: POP
// hHackSetLevel10 ; 3 :
108240: CALL 120568 0 0
108244: GO 108337
108246: LD_INT 3
108248: DOUBLE
108249: EQUAL
108250: IFTRUE 108254
108252: GO 108261
108254: POP
// hHackSetLevel10YourUnits ; 4 :
108255: CALL 120653 0 0
108259: GO 108337
108261: LD_INT 4
108263: DOUBLE
108264: EQUAL
108265: IFTRUE 108269
108267: GO 108276
108269: POP
// hHackInvincible ; 5 :
108270: CALL 121101 0 0
108274: GO 108337
108276: LD_INT 5
108278: DOUBLE
108279: EQUAL
108280: IFTRUE 108284
108282: GO 108291
108284: POP
// hHackInvisible ; 6 :
108285: CALL 121212 0 0
108289: GO 108337
108291: LD_INT 6
108293: DOUBLE
108294: EQUAL
108295: IFTRUE 108299
108297: GO 108306
108299: POP
// hHackChangeYourSide ; 7 :
108300: CALL 121269 0 0
108304: GO 108337
108306: LD_INT 7
108308: DOUBLE
108309: EQUAL
108310: IFTRUE 108314
108312: GO 108321
108314: POP
// hHackChangeUnitSide ; 8 :
108315: CALL 121311 0 0
108319: GO 108337
108321: LD_INT 8
108323: DOUBLE
108324: EQUAL
108325: IFTRUE 108329
108327: GO 108336
108329: POP
// hHackFog ; end ;
108330: CALL 121412 0 0
108334: GO 108337
108336: POP
// end ; end ;
108337: LD_VAR 0 7
108341: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
108342: GO 108344
108344: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108345: LD_STRING initStreamRollete();
108347: PPUSH
108348: CALL_OW 559
// InitStreamMode ;
108352: CALL 108364 0 0
// DefineStreamItems ( false ) ;
108356: LD_INT 0
108358: PPUSH
108359: CALL 108828 0 1
// end ;
108363: END
// function InitStreamMode ; begin
108364: LD_INT 0
108366: PPUSH
// streamModeActive := false ;
108367: LD_ADDR_EXP 159
108371: PUSH
108372: LD_INT 0
108374: ST_TO_ADDR
// normalCounter := 36 ;
108375: LD_ADDR_EXP 160
108379: PUSH
108380: LD_INT 36
108382: ST_TO_ADDR
// hardcoreCounter := 18 ;
108383: LD_ADDR_EXP 161
108387: PUSH
108388: LD_INT 18
108390: ST_TO_ADDR
// sRocket := false ;
108391: LD_ADDR_EXP 164
108395: PUSH
108396: LD_INT 0
108398: ST_TO_ADDR
// sSpeed := false ;
108399: LD_ADDR_EXP 163
108403: PUSH
108404: LD_INT 0
108406: ST_TO_ADDR
// sEngine := false ;
108407: LD_ADDR_EXP 165
108411: PUSH
108412: LD_INT 0
108414: ST_TO_ADDR
// sSpec := false ;
108415: LD_ADDR_EXP 162
108419: PUSH
108420: LD_INT 0
108422: ST_TO_ADDR
// sLevel := false ;
108423: LD_ADDR_EXP 166
108427: PUSH
108428: LD_INT 0
108430: ST_TO_ADDR
// sArmoury := false ;
108431: LD_ADDR_EXP 167
108435: PUSH
108436: LD_INT 0
108438: ST_TO_ADDR
// sRadar := false ;
108439: LD_ADDR_EXP 168
108443: PUSH
108444: LD_INT 0
108446: ST_TO_ADDR
// sBunker := false ;
108447: LD_ADDR_EXP 169
108451: PUSH
108452: LD_INT 0
108454: ST_TO_ADDR
// sHack := false ;
108455: LD_ADDR_EXP 170
108459: PUSH
108460: LD_INT 0
108462: ST_TO_ADDR
// sFire := false ;
108463: LD_ADDR_EXP 171
108467: PUSH
108468: LD_INT 0
108470: ST_TO_ADDR
// sRefresh := false ;
108471: LD_ADDR_EXP 172
108475: PUSH
108476: LD_INT 0
108478: ST_TO_ADDR
// sExp := false ;
108479: LD_ADDR_EXP 173
108483: PUSH
108484: LD_INT 0
108486: ST_TO_ADDR
// sDepot := false ;
108487: LD_ADDR_EXP 174
108491: PUSH
108492: LD_INT 0
108494: ST_TO_ADDR
// sFlag := false ;
108495: LD_ADDR_EXP 175
108499: PUSH
108500: LD_INT 0
108502: ST_TO_ADDR
// sKamikadze := false ;
108503: LD_ADDR_EXP 183
108507: PUSH
108508: LD_INT 0
108510: ST_TO_ADDR
// sTroll := false ;
108511: LD_ADDR_EXP 184
108515: PUSH
108516: LD_INT 0
108518: ST_TO_ADDR
// sSlow := false ;
108519: LD_ADDR_EXP 185
108523: PUSH
108524: LD_INT 0
108526: ST_TO_ADDR
// sLack := false ;
108527: LD_ADDR_EXP 186
108531: PUSH
108532: LD_INT 0
108534: ST_TO_ADDR
// sTank := false ;
108535: LD_ADDR_EXP 188
108539: PUSH
108540: LD_INT 0
108542: ST_TO_ADDR
// sRemote := false ;
108543: LD_ADDR_EXP 189
108547: PUSH
108548: LD_INT 0
108550: ST_TO_ADDR
// sPowell := false ;
108551: LD_ADDR_EXP 190
108555: PUSH
108556: LD_INT 0
108558: ST_TO_ADDR
// sTeleport := false ;
108559: LD_ADDR_EXP 193
108563: PUSH
108564: LD_INT 0
108566: ST_TO_ADDR
// sOilTower := false ;
108567: LD_ADDR_EXP 195
108571: PUSH
108572: LD_INT 0
108574: ST_TO_ADDR
// sShovel := false ;
108575: LD_ADDR_EXP 196
108579: PUSH
108580: LD_INT 0
108582: ST_TO_ADDR
// sSheik := false ;
108583: LD_ADDR_EXP 197
108587: PUSH
108588: LD_INT 0
108590: ST_TO_ADDR
// sEarthquake := false ;
108591: LD_ADDR_EXP 199
108595: PUSH
108596: LD_INT 0
108598: ST_TO_ADDR
// sAI := false ;
108599: LD_ADDR_EXP 200
108603: PUSH
108604: LD_INT 0
108606: ST_TO_ADDR
// sCargo := false ;
108607: LD_ADDR_EXP 203
108611: PUSH
108612: LD_INT 0
108614: ST_TO_ADDR
// sDLaser := false ;
108615: LD_ADDR_EXP 204
108619: PUSH
108620: LD_INT 0
108622: ST_TO_ADDR
// sExchange := false ;
108623: LD_ADDR_EXP 205
108627: PUSH
108628: LD_INT 0
108630: ST_TO_ADDR
// sFac := false ;
108631: LD_ADDR_EXP 206
108635: PUSH
108636: LD_INT 0
108638: ST_TO_ADDR
// sPower := false ;
108639: LD_ADDR_EXP 207
108643: PUSH
108644: LD_INT 0
108646: ST_TO_ADDR
// sRandom := false ;
108647: LD_ADDR_EXP 208
108651: PUSH
108652: LD_INT 0
108654: ST_TO_ADDR
// sShield := false ;
108655: LD_ADDR_EXP 209
108659: PUSH
108660: LD_INT 0
108662: ST_TO_ADDR
// sTime := false ;
108663: LD_ADDR_EXP 210
108667: PUSH
108668: LD_INT 0
108670: ST_TO_ADDR
// sTools := false ;
108671: LD_ADDR_EXP 211
108675: PUSH
108676: LD_INT 0
108678: ST_TO_ADDR
// sSold := false ;
108679: LD_ADDR_EXP 176
108683: PUSH
108684: LD_INT 0
108686: ST_TO_ADDR
// sDiff := false ;
108687: LD_ADDR_EXP 177
108691: PUSH
108692: LD_INT 0
108694: ST_TO_ADDR
// sFog := false ;
108695: LD_ADDR_EXP 180
108699: PUSH
108700: LD_INT 0
108702: ST_TO_ADDR
// sReset := false ;
108703: LD_ADDR_EXP 181
108707: PUSH
108708: LD_INT 0
108710: ST_TO_ADDR
// sSun := false ;
108711: LD_ADDR_EXP 182
108715: PUSH
108716: LD_INT 0
108718: ST_TO_ADDR
// sTiger := false ;
108719: LD_ADDR_EXP 178
108723: PUSH
108724: LD_INT 0
108726: ST_TO_ADDR
// sBomb := false ;
108727: LD_ADDR_EXP 179
108731: PUSH
108732: LD_INT 0
108734: ST_TO_ADDR
// sWound := false ;
108735: LD_ADDR_EXP 187
108739: PUSH
108740: LD_INT 0
108742: ST_TO_ADDR
// sBetray := false ;
108743: LD_ADDR_EXP 191
108747: PUSH
108748: LD_INT 0
108750: ST_TO_ADDR
// sContamin := false ;
108751: LD_ADDR_EXP 192
108755: PUSH
108756: LD_INT 0
108758: ST_TO_ADDR
// sOil := false ;
108759: LD_ADDR_EXP 194
108763: PUSH
108764: LD_INT 0
108766: ST_TO_ADDR
// sStu := false ;
108767: LD_ADDR_EXP 198
108771: PUSH
108772: LD_INT 0
108774: ST_TO_ADDR
// sBazooka := false ;
108775: LD_ADDR_EXP 201
108779: PUSH
108780: LD_INT 0
108782: ST_TO_ADDR
// sMortar := false ;
108783: LD_ADDR_EXP 202
108787: PUSH
108788: LD_INT 0
108790: ST_TO_ADDR
// sRanger := false ;
108791: LD_ADDR_EXP 212
108795: PUSH
108796: LD_INT 0
108798: ST_TO_ADDR
// sComputer := false ;
108799: LD_ADDR_EXP 213
108803: PUSH
108804: LD_INT 0
108806: ST_TO_ADDR
// s30 := false ;
108807: LD_ADDR_EXP 214
108811: PUSH
108812: LD_INT 0
108814: ST_TO_ADDR
// s60 := false ;
108815: LD_ADDR_EXP 215
108819: PUSH
108820: LD_INT 0
108822: ST_TO_ADDR
// end ;
108823: LD_VAR 0 1
108827: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
108828: LD_INT 0
108830: PPUSH
108831: PPUSH
108832: PPUSH
108833: PPUSH
108834: PPUSH
108835: PPUSH
108836: PPUSH
// result := [ ] ;
108837: LD_ADDR_VAR 0 2
108841: PUSH
108842: EMPTY
108843: ST_TO_ADDR
// if campaign_id = 1 then
108844: LD_OWVAR 69
108848: PUSH
108849: LD_INT 1
108851: EQUAL
108852: IFFALSE 112018
// begin case mission_number of 1 :
108854: LD_OWVAR 70
108858: PUSH
108859: LD_INT 1
108861: DOUBLE
108862: EQUAL
108863: IFTRUE 108867
108865: GO 108943
108867: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
108868: LD_ADDR_VAR 0 2
108872: PUSH
108873: LD_INT 2
108875: PUSH
108876: LD_INT 4
108878: PUSH
108879: LD_INT 11
108881: PUSH
108882: LD_INT 12
108884: PUSH
108885: LD_INT 15
108887: PUSH
108888: LD_INT 16
108890: PUSH
108891: LD_INT 22
108893: PUSH
108894: LD_INT 23
108896: PUSH
108897: LD_INT 26
108899: PUSH
108900: EMPTY
108901: LIST
108902: LIST
108903: LIST
108904: LIST
108905: LIST
108906: LIST
108907: LIST
108908: LIST
108909: LIST
108910: PUSH
108911: LD_INT 101
108913: PUSH
108914: LD_INT 102
108916: PUSH
108917: LD_INT 106
108919: PUSH
108920: LD_INT 116
108922: PUSH
108923: LD_INT 117
108925: PUSH
108926: LD_INT 118
108928: PUSH
108929: EMPTY
108930: LIST
108931: LIST
108932: LIST
108933: LIST
108934: LIST
108935: LIST
108936: PUSH
108937: EMPTY
108938: LIST
108939: LIST
108940: ST_TO_ADDR
108941: GO 112016
108943: LD_INT 2
108945: DOUBLE
108946: EQUAL
108947: IFTRUE 108951
108949: GO 109035
108951: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
108952: LD_ADDR_VAR 0 2
108956: PUSH
108957: LD_INT 2
108959: PUSH
108960: LD_INT 4
108962: PUSH
108963: LD_INT 11
108965: PUSH
108966: LD_INT 12
108968: PUSH
108969: LD_INT 15
108971: PUSH
108972: LD_INT 16
108974: PUSH
108975: LD_INT 22
108977: PUSH
108978: LD_INT 23
108980: PUSH
108981: LD_INT 26
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: LIST
108990: LIST
108991: LIST
108992: LIST
108993: LIST
108994: PUSH
108995: LD_INT 101
108997: PUSH
108998: LD_INT 102
109000: PUSH
109001: LD_INT 105
109003: PUSH
109004: LD_INT 106
109006: PUSH
109007: LD_INT 108
109009: PUSH
109010: LD_INT 116
109012: PUSH
109013: LD_INT 117
109015: PUSH
109016: LD_INT 118
109018: PUSH
109019: EMPTY
109020: LIST
109021: LIST
109022: LIST
109023: LIST
109024: LIST
109025: LIST
109026: LIST
109027: LIST
109028: PUSH
109029: EMPTY
109030: LIST
109031: LIST
109032: ST_TO_ADDR
109033: GO 112016
109035: LD_INT 3
109037: DOUBLE
109038: EQUAL
109039: IFTRUE 109043
109041: GO 109131
109043: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
109044: LD_ADDR_VAR 0 2
109048: PUSH
109049: LD_INT 2
109051: PUSH
109052: LD_INT 4
109054: PUSH
109055: LD_INT 5
109057: PUSH
109058: LD_INT 11
109060: PUSH
109061: LD_INT 12
109063: PUSH
109064: LD_INT 15
109066: PUSH
109067: LD_INT 16
109069: PUSH
109070: LD_INT 22
109072: PUSH
109073: LD_INT 26
109075: PUSH
109076: LD_INT 36
109078: PUSH
109079: EMPTY
109080: LIST
109081: LIST
109082: LIST
109083: LIST
109084: LIST
109085: LIST
109086: LIST
109087: LIST
109088: LIST
109089: LIST
109090: PUSH
109091: LD_INT 101
109093: PUSH
109094: LD_INT 102
109096: PUSH
109097: LD_INT 105
109099: PUSH
109100: LD_INT 106
109102: PUSH
109103: LD_INT 108
109105: PUSH
109106: LD_INT 116
109108: PUSH
109109: LD_INT 117
109111: PUSH
109112: LD_INT 118
109114: PUSH
109115: EMPTY
109116: LIST
109117: LIST
109118: LIST
109119: LIST
109120: LIST
109121: LIST
109122: LIST
109123: LIST
109124: PUSH
109125: EMPTY
109126: LIST
109127: LIST
109128: ST_TO_ADDR
109129: GO 112016
109131: LD_INT 4
109133: DOUBLE
109134: EQUAL
109135: IFTRUE 109139
109137: GO 109235
109139: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
109140: LD_ADDR_VAR 0 2
109144: PUSH
109145: LD_INT 2
109147: PUSH
109148: LD_INT 4
109150: PUSH
109151: LD_INT 5
109153: PUSH
109154: LD_INT 8
109156: PUSH
109157: LD_INT 11
109159: PUSH
109160: LD_INT 12
109162: PUSH
109163: LD_INT 15
109165: PUSH
109166: LD_INT 16
109168: PUSH
109169: LD_INT 22
109171: PUSH
109172: LD_INT 23
109174: PUSH
109175: LD_INT 26
109177: PUSH
109178: LD_INT 36
109180: PUSH
109181: EMPTY
109182: LIST
109183: LIST
109184: LIST
109185: LIST
109186: LIST
109187: LIST
109188: LIST
109189: LIST
109190: LIST
109191: LIST
109192: LIST
109193: LIST
109194: PUSH
109195: LD_INT 101
109197: PUSH
109198: LD_INT 102
109200: PUSH
109201: LD_INT 105
109203: PUSH
109204: LD_INT 106
109206: PUSH
109207: LD_INT 108
109209: PUSH
109210: LD_INT 116
109212: PUSH
109213: LD_INT 117
109215: PUSH
109216: LD_INT 118
109218: PUSH
109219: EMPTY
109220: LIST
109221: LIST
109222: LIST
109223: LIST
109224: LIST
109225: LIST
109226: LIST
109227: LIST
109228: PUSH
109229: EMPTY
109230: LIST
109231: LIST
109232: ST_TO_ADDR
109233: GO 112016
109235: LD_INT 5
109237: DOUBLE
109238: EQUAL
109239: IFTRUE 109243
109241: GO 109355
109243: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
109244: LD_ADDR_VAR 0 2
109248: PUSH
109249: LD_INT 2
109251: PUSH
109252: LD_INT 4
109254: PUSH
109255: LD_INT 5
109257: PUSH
109258: LD_INT 6
109260: PUSH
109261: LD_INT 8
109263: PUSH
109264: LD_INT 11
109266: PUSH
109267: LD_INT 12
109269: PUSH
109270: LD_INT 15
109272: PUSH
109273: LD_INT 16
109275: PUSH
109276: LD_INT 22
109278: PUSH
109279: LD_INT 23
109281: PUSH
109282: LD_INT 25
109284: PUSH
109285: LD_INT 26
109287: PUSH
109288: LD_INT 36
109290: PUSH
109291: EMPTY
109292: LIST
109293: LIST
109294: LIST
109295: LIST
109296: LIST
109297: LIST
109298: LIST
109299: LIST
109300: LIST
109301: LIST
109302: LIST
109303: LIST
109304: LIST
109305: LIST
109306: PUSH
109307: LD_INT 101
109309: PUSH
109310: LD_INT 102
109312: PUSH
109313: LD_INT 105
109315: PUSH
109316: LD_INT 106
109318: PUSH
109319: LD_INT 108
109321: PUSH
109322: LD_INT 109
109324: PUSH
109325: LD_INT 112
109327: PUSH
109328: LD_INT 116
109330: PUSH
109331: LD_INT 117
109333: PUSH
109334: LD_INT 118
109336: PUSH
109337: EMPTY
109338: LIST
109339: LIST
109340: LIST
109341: LIST
109342: LIST
109343: LIST
109344: LIST
109345: LIST
109346: LIST
109347: LIST
109348: PUSH
109349: EMPTY
109350: LIST
109351: LIST
109352: ST_TO_ADDR
109353: GO 112016
109355: LD_INT 6
109357: DOUBLE
109358: EQUAL
109359: IFTRUE 109363
109361: GO 109495
109363: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
109364: LD_ADDR_VAR 0 2
109368: PUSH
109369: LD_INT 2
109371: PUSH
109372: LD_INT 4
109374: PUSH
109375: LD_INT 5
109377: PUSH
109378: LD_INT 6
109380: PUSH
109381: LD_INT 8
109383: PUSH
109384: LD_INT 11
109386: PUSH
109387: LD_INT 12
109389: PUSH
109390: LD_INT 15
109392: PUSH
109393: LD_INT 16
109395: PUSH
109396: LD_INT 20
109398: PUSH
109399: LD_INT 21
109401: PUSH
109402: LD_INT 22
109404: PUSH
109405: LD_INT 23
109407: PUSH
109408: LD_INT 25
109410: PUSH
109411: LD_INT 26
109413: PUSH
109414: LD_INT 30
109416: PUSH
109417: LD_INT 31
109419: PUSH
109420: LD_INT 32
109422: PUSH
109423: LD_INT 36
109425: PUSH
109426: EMPTY
109427: LIST
109428: LIST
109429: LIST
109430: LIST
109431: LIST
109432: LIST
109433: LIST
109434: LIST
109435: LIST
109436: LIST
109437: LIST
109438: LIST
109439: LIST
109440: LIST
109441: LIST
109442: LIST
109443: LIST
109444: LIST
109445: LIST
109446: PUSH
109447: LD_INT 101
109449: PUSH
109450: LD_INT 102
109452: PUSH
109453: LD_INT 105
109455: PUSH
109456: LD_INT 106
109458: PUSH
109459: LD_INT 108
109461: PUSH
109462: LD_INT 109
109464: PUSH
109465: LD_INT 112
109467: PUSH
109468: LD_INT 116
109470: PUSH
109471: LD_INT 117
109473: PUSH
109474: LD_INT 118
109476: PUSH
109477: EMPTY
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: PUSH
109489: EMPTY
109490: LIST
109491: LIST
109492: ST_TO_ADDR
109493: GO 112016
109495: LD_INT 7
109497: DOUBLE
109498: EQUAL
109499: IFTRUE 109503
109501: GO 109615
109503: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
109504: LD_ADDR_VAR 0 2
109508: PUSH
109509: LD_INT 2
109511: PUSH
109512: LD_INT 4
109514: PUSH
109515: LD_INT 5
109517: PUSH
109518: LD_INT 7
109520: PUSH
109521: LD_INT 11
109523: PUSH
109524: LD_INT 12
109526: PUSH
109527: LD_INT 15
109529: PUSH
109530: LD_INT 16
109532: PUSH
109533: LD_INT 20
109535: PUSH
109536: LD_INT 21
109538: PUSH
109539: LD_INT 22
109541: PUSH
109542: LD_INT 23
109544: PUSH
109545: LD_INT 25
109547: PUSH
109548: LD_INT 26
109550: PUSH
109551: EMPTY
109552: LIST
109553: LIST
109554: LIST
109555: LIST
109556: LIST
109557: LIST
109558: LIST
109559: LIST
109560: LIST
109561: LIST
109562: LIST
109563: LIST
109564: LIST
109565: LIST
109566: PUSH
109567: LD_INT 101
109569: PUSH
109570: LD_INT 102
109572: PUSH
109573: LD_INT 103
109575: PUSH
109576: LD_INT 105
109578: PUSH
109579: LD_INT 106
109581: PUSH
109582: LD_INT 108
109584: PUSH
109585: LD_INT 112
109587: PUSH
109588: LD_INT 116
109590: PUSH
109591: LD_INT 117
109593: PUSH
109594: LD_INT 118
109596: PUSH
109597: EMPTY
109598: LIST
109599: LIST
109600: LIST
109601: LIST
109602: LIST
109603: LIST
109604: LIST
109605: LIST
109606: LIST
109607: LIST
109608: PUSH
109609: EMPTY
109610: LIST
109611: LIST
109612: ST_TO_ADDR
109613: GO 112016
109615: LD_INT 8
109617: DOUBLE
109618: EQUAL
109619: IFTRUE 109623
109621: GO 109763
109623: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
109624: LD_ADDR_VAR 0 2
109628: PUSH
109629: LD_INT 2
109631: PUSH
109632: LD_INT 4
109634: PUSH
109635: LD_INT 5
109637: PUSH
109638: LD_INT 6
109640: PUSH
109641: LD_INT 7
109643: PUSH
109644: LD_INT 8
109646: PUSH
109647: LD_INT 11
109649: PUSH
109650: LD_INT 12
109652: PUSH
109653: LD_INT 15
109655: PUSH
109656: LD_INT 16
109658: PUSH
109659: LD_INT 20
109661: PUSH
109662: LD_INT 21
109664: PUSH
109665: LD_INT 22
109667: PUSH
109668: LD_INT 23
109670: PUSH
109671: LD_INT 25
109673: PUSH
109674: LD_INT 26
109676: PUSH
109677: LD_INT 30
109679: PUSH
109680: LD_INT 31
109682: PUSH
109683: LD_INT 32
109685: PUSH
109686: LD_INT 36
109688: PUSH
109689: EMPTY
109690: LIST
109691: LIST
109692: LIST
109693: LIST
109694: LIST
109695: LIST
109696: LIST
109697: LIST
109698: LIST
109699: LIST
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: LIST
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: PUSH
109711: LD_INT 101
109713: PUSH
109714: LD_INT 102
109716: PUSH
109717: LD_INT 103
109719: PUSH
109720: LD_INT 105
109722: PUSH
109723: LD_INT 106
109725: PUSH
109726: LD_INT 108
109728: PUSH
109729: LD_INT 109
109731: PUSH
109732: LD_INT 112
109734: PUSH
109735: LD_INT 116
109737: PUSH
109738: LD_INT 117
109740: PUSH
109741: LD_INT 118
109743: PUSH
109744: EMPTY
109745: LIST
109746: LIST
109747: LIST
109748: LIST
109749: LIST
109750: LIST
109751: LIST
109752: LIST
109753: LIST
109754: LIST
109755: LIST
109756: PUSH
109757: EMPTY
109758: LIST
109759: LIST
109760: ST_TO_ADDR
109761: GO 112016
109763: LD_INT 9
109765: DOUBLE
109766: EQUAL
109767: IFTRUE 109771
109769: GO 109919
109771: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
109772: LD_ADDR_VAR 0 2
109776: PUSH
109777: LD_INT 2
109779: PUSH
109780: LD_INT 4
109782: PUSH
109783: LD_INT 5
109785: PUSH
109786: LD_INT 6
109788: PUSH
109789: LD_INT 7
109791: PUSH
109792: LD_INT 8
109794: PUSH
109795: LD_INT 11
109797: PUSH
109798: LD_INT 12
109800: PUSH
109801: LD_INT 15
109803: PUSH
109804: LD_INT 16
109806: PUSH
109807: LD_INT 20
109809: PUSH
109810: LD_INT 21
109812: PUSH
109813: LD_INT 22
109815: PUSH
109816: LD_INT 23
109818: PUSH
109819: LD_INT 25
109821: PUSH
109822: LD_INT 26
109824: PUSH
109825: LD_INT 28
109827: PUSH
109828: LD_INT 30
109830: PUSH
109831: LD_INT 31
109833: PUSH
109834: LD_INT 32
109836: PUSH
109837: LD_INT 36
109839: PUSH
109840: EMPTY
109841: LIST
109842: LIST
109843: LIST
109844: LIST
109845: LIST
109846: LIST
109847: LIST
109848: LIST
109849: LIST
109850: LIST
109851: LIST
109852: LIST
109853: LIST
109854: LIST
109855: LIST
109856: LIST
109857: LIST
109858: LIST
109859: LIST
109860: LIST
109861: LIST
109862: PUSH
109863: LD_INT 101
109865: PUSH
109866: LD_INT 102
109868: PUSH
109869: LD_INT 103
109871: PUSH
109872: LD_INT 105
109874: PUSH
109875: LD_INT 106
109877: PUSH
109878: LD_INT 108
109880: PUSH
109881: LD_INT 109
109883: PUSH
109884: LD_INT 112
109886: PUSH
109887: LD_INT 114
109889: PUSH
109890: LD_INT 116
109892: PUSH
109893: LD_INT 117
109895: PUSH
109896: LD_INT 118
109898: PUSH
109899: EMPTY
109900: LIST
109901: LIST
109902: LIST
109903: LIST
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: LIST
109909: LIST
109910: LIST
109911: LIST
109912: PUSH
109913: EMPTY
109914: LIST
109915: LIST
109916: ST_TO_ADDR
109917: GO 112016
109919: LD_INT 10
109921: DOUBLE
109922: EQUAL
109923: IFTRUE 109927
109925: GO 110123
109927: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
109928: LD_ADDR_VAR 0 2
109932: PUSH
109933: LD_INT 2
109935: PUSH
109936: LD_INT 4
109938: PUSH
109939: LD_INT 5
109941: PUSH
109942: LD_INT 6
109944: PUSH
109945: LD_INT 7
109947: PUSH
109948: LD_INT 8
109950: PUSH
109951: LD_INT 9
109953: PUSH
109954: LD_INT 10
109956: PUSH
109957: LD_INT 11
109959: PUSH
109960: LD_INT 12
109962: PUSH
109963: LD_INT 13
109965: PUSH
109966: LD_INT 14
109968: PUSH
109969: LD_INT 15
109971: PUSH
109972: LD_INT 16
109974: PUSH
109975: LD_INT 17
109977: PUSH
109978: LD_INT 18
109980: PUSH
109981: LD_INT 19
109983: PUSH
109984: LD_INT 20
109986: PUSH
109987: LD_INT 21
109989: PUSH
109990: LD_INT 22
109992: PUSH
109993: LD_INT 23
109995: PUSH
109996: LD_INT 24
109998: PUSH
109999: LD_INT 25
110001: PUSH
110002: LD_INT 26
110004: PUSH
110005: LD_INT 28
110007: PUSH
110008: LD_INT 30
110010: PUSH
110011: LD_INT 31
110013: PUSH
110014: LD_INT 32
110016: PUSH
110017: LD_INT 36
110019: PUSH
110020: EMPTY
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: LIST
110039: LIST
110040: LIST
110041: LIST
110042: LIST
110043: LIST
110044: LIST
110045: LIST
110046: LIST
110047: LIST
110048: LIST
110049: LIST
110050: PUSH
110051: LD_INT 101
110053: PUSH
110054: LD_INT 102
110056: PUSH
110057: LD_INT 103
110059: PUSH
110060: LD_INT 104
110062: PUSH
110063: LD_INT 105
110065: PUSH
110066: LD_INT 106
110068: PUSH
110069: LD_INT 107
110071: PUSH
110072: LD_INT 108
110074: PUSH
110075: LD_INT 109
110077: PUSH
110078: LD_INT 110
110080: PUSH
110081: LD_INT 111
110083: PUSH
110084: LD_INT 112
110086: PUSH
110087: LD_INT 114
110089: PUSH
110090: LD_INT 116
110092: PUSH
110093: LD_INT 117
110095: PUSH
110096: LD_INT 118
110098: PUSH
110099: EMPTY
110100: LIST
110101: LIST
110102: LIST
110103: LIST
110104: LIST
110105: LIST
110106: LIST
110107: LIST
110108: LIST
110109: LIST
110110: LIST
110111: LIST
110112: LIST
110113: LIST
110114: LIST
110115: LIST
110116: PUSH
110117: EMPTY
110118: LIST
110119: LIST
110120: ST_TO_ADDR
110121: GO 112016
110123: LD_INT 11
110125: DOUBLE
110126: EQUAL
110127: IFTRUE 110131
110129: GO 110335
110131: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
110132: LD_ADDR_VAR 0 2
110136: PUSH
110137: LD_INT 2
110139: PUSH
110140: LD_INT 3
110142: PUSH
110143: LD_INT 4
110145: PUSH
110146: LD_INT 5
110148: PUSH
110149: LD_INT 6
110151: PUSH
110152: LD_INT 7
110154: PUSH
110155: LD_INT 8
110157: PUSH
110158: LD_INT 9
110160: PUSH
110161: LD_INT 10
110163: PUSH
110164: LD_INT 11
110166: PUSH
110167: LD_INT 12
110169: PUSH
110170: LD_INT 13
110172: PUSH
110173: LD_INT 14
110175: PUSH
110176: LD_INT 15
110178: PUSH
110179: LD_INT 16
110181: PUSH
110182: LD_INT 17
110184: PUSH
110185: LD_INT 18
110187: PUSH
110188: LD_INT 19
110190: PUSH
110191: LD_INT 20
110193: PUSH
110194: LD_INT 21
110196: PUSH
110197: LD_INT 22
110199: PUSH
110200: LD_INT 23
110202: PUSH
110203: LD_INT 24
110205: PUSH
110206: LD_INT 25
110208: PUSH
110209: LD_INT 26
110211: PUSH
110212: LD_INT 28
110214: PUSH
110215: LD_INT 30
110217: PUSH
110218: LD_INT 31
110220: PUSH
110221: LD_INT 32
110223: PUSH
110224: LD_INT 34
110226: PUSH
110227: LD_INT 36
110229: PUSH
110230: EMPTY
110231: LIST
110232: LIST
110233: LIST
110234: LIST
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: LIST
110254: LIST
110255: LIST
110256: LIST
110257: LIST
110258: LIST
110259: LIST
110260: LIST
110261: LIST
110262: PUSH
110263: LD_INT 101
110265: PUSH
110266: LD_INT 102
110268: PUSH
110269: LD_INT 103
110271: PUSH
110272: LD_INT 104
110274: PUSH
110275: LD_INT 105
110277: PUSH
110278: LD_INT 106
110280: PUSH
110281: LD_INT 107
110283: PUSH
110284: LD_INT 108
110286: PUSH
110287: LD_INT 109
110289: PUSH
110290: LD_INT 110
110292: PUSH
110293: LD_INT 111
110295: PUSH
110296: LD_INT 112
110298: PUSH
110299: LD_INT 114
110301: PUSH
110302: LD_INT 116
110304: PUSH
110305: LD_INT 117
110307: PUSH
110308: LD_INT 118
110310: PUSH
110311: EMPTY
110312: LIST
110313: LIST
110314: LIST
110315: LIST
110316: LIST
110317: LIST
110318: LIST
110319: LIST
110320: LIST
110321: LIST
110322: LIST
110323: LIST
110324: LIST
110325: LIST
110326: LIST
110327: LIST
110328: PUSH
110329: EMPTY
110330: LIST
110331: LIST
110332: ST_TO_ADDR
110333: GO 112016
110335: LD_INT 12
110337: DOUBLE
110338: EQUAL
110339: IFTRUE 110343
110341: GO 110563
110343: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
110344: LD_ADDR_VAR 0 2
110348: PUSH
110349: LD_INT 1
110351: PUSH
110352: LD_INT 2
110354: PUSH
110355: LD_INT 3
110357: PUSH
110358: LD_INT 4
110360: PUSH
110361: LD_INT 5
110363: PUSH
110364: LD_INT 6
110366: PUSH
110367: LD_INT 7
110369: PUSH
110370: LD_INT 8
110372: PUSH
110373: LD_INT 9
110375: PUSH
110376: LD_INT 10
110378: PUSH
110379: LD_INT 11
110381: PUSH
110382: LD_INT 12
110384: PUSH
110385: LD_INT 13
110387: PUSH
110388: LD_INT 14
110390: PUSH
110391: LD_INT 15
110393: PUSH
110394: LD_INT 16
110396: PUSH
110397: LD_INT 17
110399: PUSH
110400: LD_INT 18
110402: PUSH
110403: LD_INT 19
110405: PUSH
110406: LD_INT 20
110408: PUSH
110409: LD_INT 21
110411: PUSH
110412: LD_INT 22
110414: PUSH
110415: LD_INT 23
110417: PUSH
110418: LD_INT 24
110420: PUSH
110421: LD_INT 25
110423: PUSH
110424: LD_INT 26
110426: PUSH
110427: LD_INT 27
110429: PUSH
110430: LD_INT 28
110432: PUSH
110433: LD_INT 30
110435: PUSH
110436: LD_INT 31
110438: PUSH
110439: LD_INT 32
110441: PUSH
110442: LD_INT 33
110444: PUSH
110445: LD_INT 34
110447: PUSH
110448: LD_INT 36
110450: PUSH
110451: EMPTY
110452: LIST
110453: LIST
110454: LIST
110455: LIST
110456: LIST
110457: LIST
110458: LIST
110459: LIST
110460: LIST
110461: LIST
110462: LIST
110463: LIST
110464: LIST
110465: LIST
110466: LIST
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: LIST
110472: LIST
110473: LIST
110474: LIST
110475: LIST
110476: LIST
110477: LIST
110478: LIST
110479: LIST
110480: LIST
110481: LIST
110482: LIST
110483: LIST
110484: LIST
110485: LIST
110486: PUSH
110487: LD_INT 101
110489: PUSH
110490: LD_INT 102
110492: PUSH
110493: LD_INT 103
110495: PUSH
110496: LD_INT 104
110498: PUSH
110499: LD_INT 105
110501: PUSH
110502: LD_INT 106
110504: PUSH
110505: LD_INT 107
110507: PUSH
110508: LD_INT 108
110510: PUSH
110511: LD_INT 109
110513: PUSH
110514: LD_INT 110
110516: PUSH
110517: LD_INT 111
110519: PUSH
110520: LD_INT 112
110522: PUSH
110523: LD_INT 113
110525: PUSH
110526: LD_INT 114
110528: PUSH
110529: LD_INT 116
110531: PUSH
110532: LD_INT 117
110534: PUSH
110535: LD_INT 118
110537: PUSH
110538: EMPTY
110539: LIST
110540: LIST
110541: LIST
110542: LIST
110543: LIST
110544: LIST
110545: LIST
110546: LIST
110547: LIST
110548: LIST
110549: LIST
110550: LIST
110551: LIST
110552: LIST
110553: LIST
110554: LIST
110555: LIST
110556: PUSH
110557: EMPTY
110558: LIST
110559: LIST
110560: ST_TO_ADDR
110561: GO 112016
110563: LD_INT 13
110565: DOUBLE
110566: EQUAL
110567: IFTRUE 110571
110569: GO 110779
110571: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
110572: LD_ADDR_VAR 0 2
110576: PUSH
110577: LD_INT 1
110579: PUSH
110580: LD_INT 2
110582: PUSH
110583: LD_INT 3
110585: PUSH
110586: LD_INT 4
110588: PUSH
110589: LD_INT 5
110591: PUSH
110592: LD_INT 8
110594: PUSH
110595: LD_INT 9
110597: PUSH
110598: LD_INT 10
110600: PUSH
110601: LD_INT 11
110603: PUSH
110604: LD_INT 12
110606: PUSH
110607: LD_INT 14
110609: PUSH
110610: LD_INT 15
110612: PUSH
110613: LD_INT 16
110615: PUSH
110616: LD_INT 17
110618: PUSH
110619: LD_INT 18
110621: PUSH
110622: LD_INT 19
110624: PUSH
110625: LD_INT 20
110627: PUSH
110628: LD_INT 21
110630: PUSH
110631: LD_INT 22
110633: PUSH
110634: LD_INT 23
110636: PUSH
110637: LD_INT 24
110639: PUSH
110640: LD_INT 25
110642: PUSH
110643: LD_INT 26
110645: PUSH
110646: LD_INT 27
110648: PUSH
110649: LD_INT 28
110651: PUSH
110652: LD_INT 30
110654: PUSH
110655: LD_INT 31
110657: PUSH
110658: LD_INT 32
110660: PUSH
110661: LD_INT 33
110663: PUSH
110664: LD_INT 34
110666: PUSH
110667: LD_INT 36
110669: PUSH
110670: EMPTY
110671: LIST
110672: LIST
110673: LIST
110674: LIST
110675: LIST
110676: LIST
110677: LIST
110678: LIST
110679: LIST
110680: LIST
110681: LIST
110682: LIST
110683: LIST
110684: LIST
110685: LIST
110686: LIST
110687: LIST
110688: LIST
110689: LIST
110690: LIST
110691: LIST
110692: LIST
110693: LIST
110694: LIST
110695: LIST
110696: LIST
110697: LIST
110698: LIST
110699: LIST
110700: LIST
110701: LIST
110702: PUSH
110703: LD_INT 101
110705: PUSH
110706: LD_INT 102
110708: PUSH
110709: LD_INT 103
110711: PUSH
110712: LD_INT 104
110714: PUSH
110715: LD_INT 105
110717: PUSH
110718: LD_INT 106
110720: PUSH
110721: LD_INT 107
110723: PUSH
110724: LD_INT 108
110726: PUSH
110727: LD_INT 109
110729: PUSH
110730: LD_INT 110
110732: PUSH
110733: LD_INT 111
110735: PUSH
110736: LD_INT 112
110738: PUSH
110739: LD_INT 113
110741: PUSH
110742: LD_INT 114
110744: PUSH
110745: LD_INT 116
110747: PUSH
110748: LD_INT 117
110750: PUSH
110751: LD_INT 118
110753: PUSH
110754: EMPTY
110755: LIST
110756: LIST
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: LIST
110762: LIST
110763: LIST
110764: LIST
110765: LIST
110766: LIST
110767: LIST
110768: LIST
110769: LIST
110770: LIST
110771: LIST
110772: PUSH
110773: EMPTY
110774: LIST
110775: LIST
110776: ST_TO_ADDR
110777: GO 112016
110779: LD_INT 14
110781: DOUBLE
110782: EQUAL
110783: IFTRUE 110787
110785: GO 111011
110787: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
110788: LD_ADDR_VAR 0 2
110792: PUSH
110793: LD_INT 1
110795: PUSH
110796: LD_INT 2
110798: PUSH
110799: LD_INT 3
110801: PUSH
110802: LD_INT 4
110804: PUSH
110805: LD_INT 5
110807: PUSH
110808: LD_INT 6
110810: PUSH
110811: LD_INT 7
110813: PUSH
110814: LD_INT 8
110816: PUSH
110817: LD_INT 9
110819: PUSH
110820: LD_INT 10
110822: PUSH
110823: LD_INT 11
110825: PUSH
110826: LD_INT 12
110828: PUSH
110829: LD_INT 13
110831: PUSH
110832: LD_INT 14
110834: PUSH
110835: LD_INT 15
110837: PUSH
110838: LD_INT 16
110840: PUSH
110841: LD_INT 17
110843: PUSH
110844: LD_INT 18
110846: PUSH
110847: LD_INT 19
110849: PUSH
110850: LD_INT 20
110852: PUSH
110853: LD_INT 21
110855: PUSH
110856: LD_INT 22
110858: PUSH
110859: LD_INT 23
110861: PUSH
110862: LD_INT 24
110864: PUSH
110865: LD_INT 25
110867: PUSH
110868: LD_INT 26
110870: PUSH
110871: LD_INT 27
110873: PUSH
110874: LD_INT 28
110876: PUSH
110877: LD_INT 29
110879: PUSH
110880: LD_INT 30
110882: PUSH
110883: LD_INT 31
110885: PUSH
110886: LD_INT 32
110888: PUSH
110889: LD_INT 33
110891: PUSH
110892: LD_INT 34
110894: PUSH
110895: LD_INT 36
110897: PUSH
110898: EMPTY
110899: LIST
110900: LIST
110901: LIST
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: LIST
110929: LIST
110930: LIST
110931: LIST
110932: LIST
110933: LIST
110934: PUSH
110935: LD_INT 101
110937: PUSH
110938: LD_INT 102
110940: PUSH
110941: LD_INT 103
110943: PUSH
110944: LD_INT 104
110946: PUSH
110947: LD_INT 105
110949: PUSH
110950: LD_INT 106
110952: PUSH
110953: LD_INT 107
110955: PUSH
110956: LD_INT 108
110958: PUSH
110959: LD_INT 109
110961: PUSH
110962: LD_INT 110
110964: PUSH
110965: LD_INT 111
110967: PUSH
110968: LD_INT 112
110970: PUSH
110971: LD_INT 113
110973: PUSH
110974: LD_INT 114
110976: PUSH
110977: LD_INT 116
110979: PUSH
110980: LD_INT 117
110982: PUSH
110983: LD_INT 118
110985: PUSH
110986: EMPTY
110987: LIST
110988: LIST
110989: LIST
110990: LIST
110991: LIST
110992: LIST
110993: LIST
110994: LIST
110995: LIST
110996: LIST
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: PUSH
111005: EMPTY
111006: LIST
111007: LIST
111008: ST_TO_ADDR
111009: GO 112016
111011: LD_INT 15
111013: DOUBLE
111014: EQUAL
111015: IFTRUE 111019
111017: GO 111243
111019: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
111020: LD_ADDR_VAR 0 2
111024: PUSH
111025: LD_INT 1
111027: PUSH
111028: LD_INT 2
111030: PUSH
111031: LD_INT 3
111033: PUSH
111034: LD_INT 4
111036: PUSH
111037: LD_INT 5
111039: PUSH
111040: LD_INT 6
111042: PUSH
111043: LD_INT 7
111045: PUSH
111046: LD_INT 8
111048: PUSH
111049: LD_INT 9
111051: PUSH
111052: LD_INT 10
111054: PUSH
111055: LD_INT 11
111057: PUSH
111058: LD_INT 12
111060: PUSH
111061: LD_INT 13
111063: PUSH
111064: LD_INT 14
111066: PUSH
111067: LD_INT 15
111069: PUSH
111070: LD_INT 16
111072: PUSH
111073: LD_INT 17
111075: PUSH
111076: LD_INT 18
111078: PUSH
111079: LD_INT 19
111081: PUSH
111082: LD_INT 20
111084: PUSH
111085: LD_INT 21
111087: PUSH
111088: LD_INT 22
111090: PUSH
111091: LD_INT 23
111093: PUSH
111094: LD_INT 24
111096: PUSH
111097: LD_INT 25
111099: PUSH
111100: LD_INT 26
111102: PUSH
111103: LD_INT 27
111105: PUSH
111106: LD_INT 28
111108: PUSH
111109: LD_INT 29
111111: PUSH
111112: LD_INT 30
111114: PUSH
111115: LD_INT 31
111117: PUSH
111118: LD_INT 32
111120: PUSH
111121: LD_INT 33
111123: PUSH
111124: LD_INT 34
111126: PUSH
111127: LD_INT 36
111129: PUSH
111130: EMPTY
111131: LIST
111132: LIST
111133: LIST
111134: LIST
111135: LIST
111136: LIST
111137: LIST
111138: LIST
111139: LIST
111140: LIST
111141: LIST
111142: LIST
111143: LIST
111144: LIST
111145: LIST
111146: LIST
111147: LIST
111148: LIST
111149: LIST
111150: LIST
111151: LIST
111152: LIST
111153: LIST
111154: LIST
111155: LIST
111156: LIST
111157: LIST
111158: LIST
111159: LIST
111160: LIST
111161: LIST
111162: LIST
111163: LIST
111164: LIST
111165: LIST
111166: PUSH
111167: LD_INT 101
111169: PUSH
111170: LD_INT 102
111172: PUSH
111173: LD_INT 103
111175: PUSH
111176: LD_INT 104
111178: PUSH
111179: LD_INT 105
111181: PUSH
111182: LD_INT 106
111184: PUSH
111185: LD_INT 107
111187: PUSH
111188: LD_INT 108
111190: PUSH
111191: LD_INT 109
111193: PUSH
111194: LD_INT 110
111196: PUSH
111197: LD_INT 111
111199: PUSH
111200: LD_INT 112
111202: PUSH
111203: LD_INT 113
111205: PUSH
111206: LD_INT 114
111208: PUSH
111209: LD_INT 116
111211: PUSH
111212: LD_INT 117
111214: PUSH
111215: LD_INT 118
111217: PUSH
111218: EMPTY
111219: LIST
111220: LIST
111221: LIST
111222: LIST
111223: LIST
111224: LIST
111225: LIST
111226: LIST
111227: LIST
111228: LIST
111229: LIST
111230: LIST
111231: LIST
111232: LIST
111233: LIST
111234: LIST
111235: LIST
111236: PUSH
111237: EMPTY
111238: LIST
111239: LIST
111240: ST_TO_ADDR
111241: GO 112016
111243: LD_INT 16
111245: DOUBLE
111246: EQUAL
111247: IFTRUE 111251
111249: GO 111387
111251: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
111252: LD_ADDR_VAR 0 2
111256: PUSH
111257: LD_INT 2
111259: PUSH
111260: LD_INT 4
111262: PUSH
111263: LD_INT 5
111265: PUSH
111266: LD_INT 7
111268: PUSH
111269: LD_INT 11
111271: PUSH
111272: LD_INT 12
111274: PUSH
111275: LD_INT 15
111277: PUSH
111278: LD_INT 16
111280: PUSH
111281: LD_INT 20
111283: PUSH
111284: LD_INT 21
111286: PUSH
111287: LD_INT 22
111289: PUSH
111290: LD_INT 23
111292: PUSH
111293: LD_INT 25
111295: PUSH
111296: LD_INT 26
111298: PUSH
111299: LD_INT 30
111301: PUSH
111302: LD_INT 31
111304: PUSH
111305: LD_INT 32
111307: PUSH
111308: LD_INT 33
111310: PUSH
111311: LD_INT 34
111313: PUSH
111314: EMPTY
111315: LIST
111316: LIST
111317: LIST
111318: LIST
111319: LIST
111320: LIST
111321: LIST
111322: LIST
111323: LIST
111324: LIST
111325: LIST
111326: LIST
111327: LIST
111328: LIST
111329: LIST
111330: LIST
111331: LIST
111332: LIST
111333: LIST
111334: PUSH
111335: LD_INT 101
111337: PUSH
111338: LD_INT 102
111340: PUSH
111341: LD_INT 103
111343: PUSH
111344: LD_INT 106
111346: PUSH
111347: LD_INT 108
111349: PUSH
111350: LD_INT 112
111352: PUSH
111353: LD_INT 113
111355: PUSH
111356: LD_INT 114
111358: PUSH
111359: LD_INT 116
111361: PUSH
111362: LD_INT 117
111364: PUSH
111365: LD_INT 118
111367: PUSH
111368: EMPTY
111369: LIST
111370: LIST
111371: LIST
111372: LIST
111373: LIST
111374: LIST
111375: LIST
111376: LIST
111377: LIST
111378: LIST
111379: LIST
111380: PUSH
111381: EMPTY
111382: LIST
111383: LIST
111384: ST_TO_ADDR
111385: GO 112016
111387: LD_INT 17
111389: DOUBLE
111390: EQUAL
111391: IFTRUE 111395
111393: GO 111619
111395: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
111396: LD_ADDR_VAR 0 2
111400: PUSH
111401: LD_INT 1
111403: PUSH
111404: LD_INT 2
111406: PUSH
111407: LD_INT 3
111409: PUSH
111410: LD_INT 4
111412: PUSH
111413: LD_INT 5
111415: PUSH
111416: LD_INT 6
111418: PUSH
111419: LD_INT 7
111421: PUSH
111422: LD_INT 8
111424: PUSH
111425: LD_INT 9
111427: PUSH
111428: LD_INT 10
111430: PUSH
111431: LD_INT 11
111433: PUSH
111434: LD_INT 12
111436: PUSH
111437: LD_INT 13
111439: PUSH
111440: LD_INT 14
111442: PUSH
111443: LD_INT 15
111445: PUSH
111446: LD_INT 16
111448: PUSH
111449: LD_INT 17
111451: PUSH
111452: LD_INT 18
111454: PUSH
111455: LD_INT 19
111457: PUSH
111458: LD_INT 20
111460: PUSH
111461: LD_INT 21
111463: PUSH
111464: LD_INT 22
111466: PUSH
111467: LD_INT 23
111469: PUSH
111470: LD_INT 24
111472: PUSH
111473: LD_INT 25
111475: PUSH
111476: LD_INT 26
111478: PUSH
111479: LD_INT 27
111481: PUSH
111482: LD_INT 28
111484: PUSH
111485: LD_INT 29
111487: PUSH
111488: LD_INT 30
111490: PUSH
111491: LD_INT 31
111493: PUSH
111494: LD_INT 32
111496: PUSH
111497: LD_INT 33
111499: PUSH
111500: LD_INT 34
111502: PUSH
111503: LD_INT 36
111505: PUSH
111506: EMPTY
111507: LIST
111508: LIST
111509: LIST
111510: LIST
111511: LIST
111512: LIST
111513: LIST
111514: LIST
111515: LIST
111516: LIST
111517: LIST
111518: LIST
111519: LIST
111520: LIST
111521: LIST
111522: LIST
111523: LIST
111524: LIST
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: LIST
111531: LIST
111532: LIST
111533: LIST
111534: LIST
111535: LIST
111536: LIST
111537: LIST
111538: LIST
111539: LIST
111540: LIST
111541: LIST
111542: PUSH
111543: LD_INT 101
111545: PUSH
111546: LD_INT 102
111548: PUSH
111549: LD_INT 103
111551: PUSH
111552: LD_INT 104
111554: PUSH
111555: LD_INT 105
111557: PUSH
111558: LD_INT 106
111560: PUSH
111561: LD_INT 107
111563: PUSH
111564: LD_INT 108
111566: PUSH
111567: LD_INT 109
111569: PUSH
111570: LD_INT 110
111572: PUSH
111573: LD_INT 111
111575: PUSH
111576: LD_INT 112
111578: PUSH
111579: LD_INT 113
111581: PUSH
111582: LD_INT 114
111584: PUSH
111585: LD_INT 116
111587: PUSH
111588: LD_INT 117
111590: PUSH
111591: LD_INT 118
111593: PUSH
111594: EMPTY
111595: LIST
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: LIST
111604: LIST
111605: LIST
111606: LIST
111607: LIST
111608: LIST
111609: LIST
111610: LIST
111611: LIST
111612: PUSH
111613: EMPTY
111614: LIST
111615: LIST
111616: ST_TO_ADDR
111617: GO 112016
111619: LD_INT 18
111621: DOUBLE
111622: EQUAL
111623: IFTRUE 111627
111625: GO 111775
111627: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
111628: LD_ADDR_VAR 0 2
111632: PUSH
111633: LD_INT 2
111635: PUSH
111636: LD_INT 4
111638: PUSH
111639: LD_INT 5
111641: PUSH
111642: LD_INT 7
111644: PUSH
111645: LD_INT 11
111647: PUSH
111648: LD_INT 12
111650: PUSH
111651: LD_INT 15
111653: PUSH
111654: LD_INT 16
111656: PUSH
111657: LD_INT 20
111659: PUSH
111660: LD_INT 21
111662: PUSH
111663: LD_INT 22
111665: PUSH
111666: LD_INT 23
111668: PUSH
111669: LD_INT 25
111671: PUSH
111672: LD_INT 26
111674: PUSH
111675: LD_INT 30
111677: PUSH
111678: LD_INT 31
111680: PUSH
111681: LD_INT 32
111683: PUSH
111684: LD_INT 33
111686: PUSH
111687: LD_INT 34
111689: PUSH
111690: LD_INT 35
111692: PUSH
111693: LD_INT 36
111695: PUSH
111696: EMPTY
111697: LIST
111698: LIST
111699: LIST
111700: LIST
111701: LIST
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: LIST
111709: LIST
111710: LIST
111711: LIST
111712: LIST
111713: LIST
111714: LIST
111715: LIST
111716: LIST
111717: LIST
111718: PUSH
111719: LD_INT 101
111721: PUSH
111722: LD_INT 102
111724: PUSH
111725: LD_INT 103
111727: PUSH
111728: LD_INT 106
111730: PUSH
111731: LD_INT 108
111733: PUSH
111734: LD_INT 112
111736: PUSH
111737: LD_INT 113
111739: PUSH
111740: LD_INT 114
111742: PUSH
111743: LD_INT 115
111745: PUSH
111746: LD_INT 116
111748: PUSH
111749: LD_INT 117
111751: PUSH
111752: LD_INT 118
111754: PUSH
111755: EMPTY
111756: LIST
111757: LIST
111758: LIST
111759: LIST
111760: LIST
111761: LIST
111762: LIST
111763: LIST
111764: LIST
111765: LIST
111766: LIST
111767: LIST
111768: PUSH
111769: EMPTY
111770: LIST
111771: LIST
111772: ST_TO_ADDR
111773: GO 112016
111775: LD_INT 19
111777: DOUBLE
111778: EQUAL
111779: IFTRUE 111783
111781: GO 112015
111783: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
111784: LD_ADDR_VAR 0 2
111788: PUSH
111789: LD_INT 1
111791: PUSH
111792: LD_INT 2
111794: PUSH
111795: LD_INT 3
111797: PUSH
111798: LD_INT 4
111800: PUSH
111801: LD_INT 5
111803: PUSH
111804: LD_INT 6
111806: PUSH
111807: LD_INT 7
111809: PUSH
111810: LD_INT 8
111812: PUSH
111813: LD_INT 9
111815: PUSH
111816: LD_INT 10
111818: PUSH
111819: LD_INT 11
111821: PUSH
111822: LD_INT 12
111824: PUSH
111825: LD_INT 13
111827: PUSH
111828: LD_INT 14
111830: PUSH
111831: LD_INT 15
111833: PUSH
111834: LD_INT 16
111836: PUSH
111837: LD_INT 17
111839: PUSH
111840: LD_INT 18
111842: PUSH
111843: LD_INT 19
111845: PUSH
111846: LD_INT 20
111848: PUSH
111849: LD_INT 21
111851: PUSH
111852: LD_INT 22
111854: PUSH
111855: LD_INT 23
111857: PUSH
111858: LD_INT 24
111860: PUSH
111861: LD_INT 25
111863: PUSH
111864: LD_INT 26
111866: PUSH
111867: LD_INT 27
111869: PUSH
111870: LD_INT 28
111872: PUSH
111873: LD_INT 29
111875: PUSH
111876: LD_INT 30
111878: PUSH
111879: LD_INT 31
111881: PUSH
111882: LD_INT 32
111884: PUSH
111885: LD_INT 33
111887: PUSH
111888: LD_INT 34
111890: PUSH
111891: LD_INT 35
111893: PUSH
111894: LD_INT 36
111896: PUSH
111897: EMPTY
111898: LIST
111899: LIST
111900: LIST
111901: LIST
111902: LIST
111903: LIST
111904: LIST
111905: LIST
111906: LIST
111907: LIST
111908: LIST
111909: LIST
111910: LIST
111911: LIST
111912: LIST
111913: LIST
111914: LIST
111915: LIST
111916: LIST
111917: LIST
111918: LIST
111919: LIST
111920: LIST
111921: LIST
111922: LIST
111923: LIST
111924: LIST
111925: LIST
111926: LIST
111927: LIST
111928: LIST
111929: LIST
111930: LIST
111931: LIST
111932: LIST
111933: LIST
111934: PUSH
111935: LD_INT 101
111937: PUSH
111938: LD_INT 102
111940: PUSH
111941: LD_INT 103
111943: PUSH
111944: LD_INT 104
111946: PUSH
111947: LD_INT 105
111949: PUSH
111950: LD_INT 106
111952: PUSH
111953: LD_INT 107
111955: PUSH
111956: LD_INT 108
111958: PUSH
111959: LD_INT 109
111961: PUSH
111962: LD_INT 110
111964: PUSH
111965: LD_INT 111
111967: PUSH
111968: LD_INT 112
111970: PUSH
111971: LD_INT 113
111973: PUSH
111974: LD_INT 114
111976: PUSH
111977: LD_INT 115
111979: PUSH
111980: LD_INT 116
111982: PUSH
111983: LD_INT 117
111985: PUSH
111986: LD_INT 118
111988: PUSH
111989: EMPTY
111990: LIST
111991: LIST
111992: LIST
111993: LIST
111994: LIST
111995: LIST
111996: LIST
111997: LIST
111998: LIST
111999: LIST
112000: LIST
112001: LIST
112002: LIST
112003: LIST
112004: LIST
112005: LIST
112006: LIST
112007: LIST
112008: PUSH
112009: EMPTY
112010: LIST
112011: LIST
112012: ST_TO_ADDR
112013: GO 112016
112015: POP
// end else
112016: GO 112247
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
112018: LD_ADDR_VAR 0 2
112022: PUSH
112023: LD_INT 1
112025: PUSH
112026: LD_INT 2
112028: PUSH
112029: LD_INT 3
112031: PUSH
112032: LD_INT 4
112034: PUSH
112035: LD_INT 5
112037: PUSH
112038: LD_INT 6
112040: PUSH
112041: LD_INT 7
112043: PUSH
112044: LD_INT 8
112046: PUSH
112047: LD_INT 9
112049: PUSH
112050: LD_INT 10
112052: PUSH
112053: LD_INT 11
112055: PUSH
112056: LD_INT 12
112058: PUSH
112059: LD_INT 13
112061: PUSH
112062: LD_INT 14
112064: PUSH
112065: LD_INT 15
112067: PUSH
112068: LD_INT 16
112070: PUSH
112071: LD_INT 17
112073: PUSH
112074: LD_INT 18
112076: PUSH
112077: LD_INT 19
112079: PUSH
112080: LD_INT 20
112082: PUSH
112083: LD_INT 21
112085: PUSH
112086: LD_INT 22
112088: PUSH
112089: LD_INT 23
112091: PUSH
112092: LD_INT 24
112094: PUSH
112095: LD_INT 25
112097: PUSH
112098: LD_INT 26
112100: PUSH
112101: LD_INT 27
112103: PUSH
112104: LD_INT 28
112106: PUSH
112107: LD_INT 29
112109: PUSH
112110: LD_INT 30
112112: PUSH
112113: LD_INT 31
112115: PUSH
112116: LD_INT 32
112118: PUSH
112119: LD_INT 33
112121: PUSH
112122: LD_INT 34
112124: PUSH
112125: LD_INT 35
112127: PUSH
112128: LD_INT 36
112130: PUSH
112131: EMPTY
112132: LIST
112133: LIST
112134: LIST
112135: LIST
112136: LIST
112137: LIST
112138: LIST
112139: LIST
112140: LIST
112141: LIST
112142: LIST
112143: LIST
112144: LIST
112145: LIST
112146: LIST
112147: LIST
112148: LIST
112149: LIST
112150: LIST
112151: LIST
112152: LIST
112153: LIST
112154: LIST
112155: LIST
112156: LIST
112157: LIST
112158: LIST
112159: LIST
112160: LIST
112161: LIST
112162: LIST
112163: LIST
112164: LIST
112165: LIST
112166: LIST
112167: LIST
112168: PUSH
112169: LD_INT 101
112171: PUSH
112172: LD_INT 102
112174: PUSH
112175: LD_INT 103
112177: PUSH
112178: LD_INT 104
112180: PUSH
112181: LD_INT 105
112183: PUSH
112184: LD_INT 106
112186: PUSH
112187: LD_INT 107
112189: PUSH
112190: LD_INT 108
112192: PUSH
112193: LD_INT 109
112195: PUSH
112196: LD_INT 110
112198: PUSH
112199: LD_INT 111
112201: PUSH
112202: LD_INT 112
112204: PUSH
112205: LD_INT 113
112207: PUSH
112208: LD_INT 114
112210: PUSH
112211: LD_INT 115
112213: PUSH
112214: LD_INT 116
112216: PUSH
112217: LD_INT 117
112219: PUSH
112220: LD_INT 118
112222: PUSH
112223: EMPTY
112224: LIST
112225: LIST
112226: LIST
112227: LIST
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: LIST
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: PUSH
112243: EMPTY
112244: LIST
112245: LIST
112246: ST_TO_ADDR
// if result then
112247: LD_VAR 0 2
112251: IFFALSE 113037
// begin normal :=  ;
112253: LD_ADDR_VAR 0 5
112257: PUSH
112258: LD_STRING 
112260: ST_TO_ADDR
// hardcore :=  ;
112261: LD_ADDR_VAR 0 6
112265: PUSH
112266: LD_STRING 
112268: ST_TO_ADDR
// active :=  ;
112269: LD_ADDR_VAR 0 7
112273: PUSH
112274: LD_STRING 
112276: ST_TO_ADDR
// for i = 1 to normalCounter do
112277: LD_ADDR_VAR 0 8
112281: PUSH
112282: DOUBLE
112283: LD_INT 1
112285: DEC
112286: ST_TO_ADDR
112287: LD_EXP 160
112291: PUSH
112292: FOR_TO
112293: IFFALSE 112394
// begin tmp := 0 ;
112295: LD_ADDR_VAR 0 3
112299: PUSH
112300: LD_STRING 0
112302: ST_TO_ADDR
// if result [ 1 ] then
112303: LD_VAR 0 2
112307: PUSH
112308: LD_INT 1
112310: ARRAY
112311: IFFALSE 112376
// if result [ 1 ] [ 1 ] = i then
112313: LD_VAR 0 2
112317: PUSH
112318: LD_INT 1
112320: ARRAY
112321: PUSH
112322: LD_INT 1
112324: ARRAY
112325: PUSH
112326: LD_VAR 0 8
112330: EQUAL
112331: IFFALSE 112376
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
112333: LD_ADDR_VAR 0 2
112337: PUSH
112338: LD_VAR 0 2
112342: PPUSH
112343: LD_INT 1
112345: PPUSH
112346: LD_VAR 0 2
112350: PUSH
112351: LD_INT 1
112353: ARRAY
112354: PPUSH
112355: LD_INT 1
112357: PPUSH
112358: CALL_OW 3
112362: PPUSH
112363: CALL_OW 1
112367: ST_TO_ADDR
// tmp := 1 ;
112368: LD_ADDR_VAR 0 3
112372: PUSH
112373: LD_STRING 1
112375: ST_TO_ADDR
// end ; normal := normal & tmp ;
112376: LD_ADDR_VAR 0 5
112380: PUSH
112381: LD_VAR 0 5
112385: PUSH
112386: LD_VAR 0 3
112390: STR
112391: ST_TO_ADDR
// end ;
112392: GO 112292
112394: POP
112395: POP
// for i = 1 to hardcoreCounter do
112396: LD_ADDR_VAR 0 8
112400: PUSH
112401: DOUBLE
112402: LD_INT 1
112404: DEC
112405: ST_TO_ADDR
112406: LD_EXP 161
112410: PUSH
112411: FOR_TO
112412: IFFALSE 112517
// begin tmp := 0 ;
112414: LD_ADDR_VAR 0 3
112418: PUSH
112419: LD_STRING 0
112421: ST_TO_ADDR
// if result [ 2 ] then
112422: LD_VAR 0 2
112426: PUSH
112427: LD_INT 2
112429: ARRAY
112430: IFFALSE 112499
// if result [ 2 ] [ 1 ] = 100 + i then
112432: LD_VAR 0 2
112436: PUSH
112437: LD_INT 2
112439: ARRAY
112440: PUSH
112441: LD_INT 1
112443: ARRAY
112444: PUSH
112445: LD_INT 100
112447: PUSH
112448: LD_VAR 0 8
112452: PLUS
112453: EQUAL
112454: IFFALSE 112499
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
112456: LD_ADDR_VAR 0 2
112460: PUSH
112461: LD_VAR 0 2
112465: PPUSH
112466: LD_INT 2
112468: PPUSH
112469: LD_VAR 0 2
112473: PUSH
112474: LD_INT 2
112476: ARRAY
112477: PPUSH
112478: LD_INT 1
112480: PPUSH
112481: CALL_OW 3
112485: PPUSH
112486: CALL_OW 1
112490: ST_TO_ADDR
// tmp := 1 ;
112491: LD_ADDR_VAR 0 3
112495: PUSH
112496: LD_STRING 1
112498: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
112499: LD_ADDR_VAR 0 6
112503: PUSH
112504: LD_VAR 0 6
112508: PUSH
112509: LD_VAR 0 3
112513: STR
112514: ST_TO_ADDR
// end ;
112515: GO 112411
112517: POP
112518: POP
// if isGameLoad then
112519: LD_VAR 0 1
112523: IFFALSE 112998
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
112525: LD_ADDR_VAR 0 4
112529: PUSH
112530: LD_EXP 164
112534: PUSH
112535: LD_EXP 163
112539: PUSH
112540: LD_EXP 165
112544: PUSH
112545: LD_EXP 162
112549: PUSH
112550: LD_EXP 166
112554: PUSH
112555: LD_EXP 167
112559: PUSH
112560: LD_EXP 168
112564: PUSH
112565: LD_EXP 169
112569: PUSH
112570: LD_EXP 170
112574: PUSH
112575: LD_EXP 171
112579: PUSH
112580: LD_EXP 172
112584: PUSH
112585: LD_EXP 173
112589: PUSH
112590: LD_EXP 174
112594: PUSH
112595: LD_EXP 175
112599: PUSH
112600: LD_EXP 183
112604: PUSH
112605: LD_EXP 184
112609: PUSH
112610: LD_EXP 185
112614: PUSH
112615: LD_EXP 186
112619: PUSH
112620: LD_EXP 188
112624: PUSH
112625: LD_EXP 189
112629: PUSH
112630: LD_EXP 190
112634: PUSH
112635: LD_EXP 193
112639: PUSH
112640: LD_EXP 195
112644: PUSH
112645: LD_EXP 196
112649: PUSH
112650: LD_EXP 197
112654: PUSH
112655: LD_EXP 199
112659: PUSH
112660: LD_EXP 200
112664: PUSH
112665: LD_EXP 203
112669: PUSH
112670: LD_EXP 204
112674: PUSH
112675: LD_EXP 205
112679: PUSH
112680: LD_EXP 206
112684: PUSH
112685: LD_EXP 207
112689: PUSH
112690: LD_EXP 208
112694: PUSH
112695: LD_EXP 209
112699: PUSH
112700: LD_EXP 210
112704: PUSH
112705: LD_EXP 211
112709: PUSH
112710: LD_EXP 176
112714: PUSH
112715: LD_EXP 177
112719: PUSH
112720: LD_EXP 180
112724: PUSH
112725: LD_EXP 181
112729: PUSH
112730: LD_EXP 182
112734: PUSH
112735: LD_EXP 178
112739: PUSH
112740: LD_EXP 179
112744: PUSH
112745: LD_EXP 187
112749: PUSH
112750: LD_EXP 191
112754: PUSH
112755: LD_EXP 192
112759: PUSH
112760: LD_EXP 194
112764: PUSH
112765: LD_EXP 198
112769: PUSH
112770: LD_EXP 201
112774: PUSH
112775: LD_EXP 202
112779: PUSH
112780: LD_EXP 212
112784: PUSH
112785: LD_EXP 213
112789: PUSH
112790: LD_EXP 214
112794: PUSH
112795: LD_EXP 215
112799: PUSH
112800: EMPTY
112801: LIST
112802: LIST
112803: LIST
112804: LIST
112805: LIST
112806: LIST
112807: LIST
112808: LIST
112809: LIST
112810: LIST
112811: LIST
112812: LIST
112813: LIST
112814: LIST
112815: LIST
112816: LIST
112817: LIST
112818: LIST
112819: LIST
112820: LIST
112821: LIST
112822: LIST
112823: LIST
112824: LIST
112825: LIST
112826: LIST
112827: LIST
112828: LIST
112829: LIST
112830: LIST
112831: LIST
112832: LIST
112833: LIST
112834: LIST
112835: LIST
112836: LIST
112837: LIST
112838: LIST
112839: LIST
112840: LIST
112841: LIST
112842: LIST
112843: LIST
112844: LIST
112845: LIST
112846: LIST
112847: LIST
112848: LIST
112849: LIST
112850: LIST
112851: LIST
112852: LIST
112853: LIST
112854: LIST
112855: ST_TO_ADDR
// tmp :=  ;
112856: LD_ADDR_VAR 0 3
112860: PUSH
112861: LD_STRING 
112863: ST_TO_ADDR
// for i = 1 to normalCounter do
112864: LD_ADDR_VAR 0 8
112868: PUSH
112869: DOUBLE
112870: LD_INT 1
112872: DEC
112873: ST_TO_ADDR
112874: LD_EXP 160
112878: PUSH
112879: FOR_TO
112880: IFFALSE 112916
// begin if flags [ i ] then
112882: LD_VAR 0 4
112886: PUSH
112887: LD_VAR 0 8
112891: ARRAY
112892: IFFALSE 112914
// tmp := tmp & i & ; ;
112894: LD_ADDR_VAR 0 3
112898: PUSH
112899: LD_VAR 0 3
112903: PUSH
112904: LD_VAR 0 8
112908: STR
112909: PUSH
112910: LD_STRING ;
112912: STR
112913: ST_TO_ADDR
// end ;
112914: GO 112879
112916: POP
112917: POP
// for i = 1 to hardcoreCounter do
112918: LD_ADDR_VAR 0 8
112922: PUSH
112923: DOUBLE
112924: LD_INT 1
112926: DEC
112927: ST_TO_ADDR
112928: LD_EXP 161
112932: PUSH
112933: FOR_TO
112934: IFFALSE 112980
// begin if flags [ normalCounter + i ] then
112936: LD_VAR 0 4
112940: PUSH
112941: LD_EXP 160
112945: PUSH
112946: LD_VAR 0 8
112950: PLUS
112951: ARRAY
112952: IFFALSE 112978
// tmp := tmp & ( 100 + i ) & ; ;
112954: LD_ADDR_VAR 0 3
112958: PUSH
112959: LD_VAR 0 3
112963: PUSH
112964: LD_INT 100
112966: PUSH
112967: LD_VAR 0 8
112971: PLUS
112972: STR
112973: PUSH
112974: LD_STRING ;
112976: STR
112977: ST_TO_ADDR
// end ;
112978: GO 112933
112980: POP
112981: POP
// if tmp then
112982: LD_VAR 0 3
112986: IFFALSE 112998
// active := tmp ;
112988: LD_ADDR_VAR 0 7
112992: PUSH
112993: LD_VAR 0 3
112997: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
112998: LD_STRING getStreamItemsFromMission("
113000: PUSH
113001: LD_VAR 0 5
113005: STR
113006: PUSH
113007: LD_STRING ","
113009: STR
113010: PUSH
113011: LD_VAR 0 6
113015: STR
113016: PUSH
113017: LD_STRING ","
113019: STR
113020: PUSH
113021: LD_VAR 0 7
113025: STR
113026: PUSH
113027: LD_STRING ")
113029: STR
113030: PPUSH
113031: CALL_OW 559
// end else
113035: GO 113044
// ToLua ( getStreamItemsFromMission("","","") ) ;
113037: LD_STRING getStreamItemsFromMission("","","")
113039: PPUSH
113040: CALL_OW 559
// end ;
113044: LD_VAR 0 2
113048: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
113049: LD_EXP 159
113053: PUSH
113054: LD_EXP 164
113058: AND
113059: IFFALSE 113183
113061: GO 113063
113063: DISABLE
113064: LD_INT 0
113066: PPUSH
113067: PPUSH
// begin enable ;
113068: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
113069: LD_ADDR_VAR 0 2
113073: PUSH
113074: LD_INT 22
113076: PUSH
113077: LD_OWVAR 2
113081: PUSH
113082: EMPTY
113083: LIST
113084: LIST
113085: PUSH
113086: LD_INT 2
113088: PUSH
113089: LD_INT 34
113091: PUSH
113092: LD_INT 7
113094: PUSH
113095: EMPTY
113096: LIST
113097: LIST
113098: PUSH
113099: LD_INT 34
113101: PUSH
113102: LD_INT 45
113104: PUSH
113105: EMPTY
113106: LIST
113107: LIST
113108: PUSH
113109: LD_INT 34
113111: PUSH
113112: LD_INT 28
113114: PUSH
113115: EMPTY
113116: LIST
113117: LIST
113118: PUSH
113119: LD_INT 34
113121: PUSH
113122: LD_INT 47
113124: PUSH
113125: EMPTY
113126: LIST
113127: LIST
113128: PUSH
113129: EMPTY
113130: LIST
113131: LIST
113132: LIST
113133: LIST
113134: LIST
113135: PUSH
113136: EMPTY
113137: LIST
113138: LIST
113139: PPUSH
113140: CALL_OW 69
113144: ST_TO_ADDR
// if not tmp then
113145: LD_VAR 0 2
113149: NOT
113150: IFFALSE 113154
// exit ;
113152: GO 113183
// for i in tmp do
113154: LD_ADDR_VAR 0 1
113158: PUSH
113159: LD_VAR 0 2
113163: PUSH
113164: FOR_IN
113165: IFFALSE 113181
// begin SetLives ( i , 0 ) ;
113167: LD_VAR 0 1
113171: PPUSH
113172: LD_INT 0
113174: PPUSH
113175: CALL_OW 234
// end ;
113179: GO 113164
113181: POP
113182: POP
// end ;
113183: PPOPN 2
113185: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
113186: LD_EXP 159
113190: PUSH
113191: LD_EXP 165
113195: AND
113196: IFFALSE 113280
113198: GO 113200
113200: DISABLE
113201: LD_INT 0
113203: PPUSH
113204: PPUSH
// begin enable ;
113205: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
113206: LD_ADDR_VAR 0 2
113210: PUSH
113211: LD_INT 22
113213: PUSH
113214: LD_OWVAR 2
113218: PUSH
113219: EMPTY
113220: LIST
113221: LIST
113222: PUSH
113223: LD_INT 32
113225: PUSH
113226: LD_INT 3
113228: PUSH
113229: EMPTY
113230: LIST
113231: LIST
113232: PUSH
113233: EMPTY
113234: LIST
113235: LIST
113236: PPUSH
113237: CALL_OW 69
113241: ST_TO_ADDR
// if not tmp then
113242: LD_VAR 0 2
113246: NOT
113247: IFFALSE 113251
// exit ;
113249: GO 113280
// for i in tmp do
113251: LD_ADDR_VAR 0 1
113255: PUSH
113256: LD_VAR 0 2
113260: PUSH
113261: FOR_IN
113262: IFFALSE 113278
// begin SetLives ( i , 0 ) ;
113264: LD_VAR 0 1
113268: PPUSH
113269: LD_INT 0
113271: PPUSH
113272: CALL_OW 234
// end ;
113276: GO 113261
113278: POP
113279: POP
// end ;
113280: PPOPN 2
113282: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113283: LD_EXP 159
113287: PUSH
113288: LD_EXP 162
113292: AND
113293: IFFALSE 113386
113295: GO 113297
113297: DISABLE
113298: LD_INT 0
113300: PPUSH
// begin enable ;
113301: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113302: LD_ADDR_VAR 0 1
113306: PUSH
113307: LD_INT 22
113309: PUSH
113310: LD_OWVAR 2
113314: PUSH
113315: EMPTY
113316: LIST
113317: LIST
113318: PUSH
113319: LD_INT 2
113321: PUSH
113322: LD_INT 25
113324: PUSH
113325: LD_INT 5
113327: PUSH
113328: EMPTY
113329: LIST
113330: LIST
113331: PUSH
113332: LD_INT 25
113334: PUSH
113335: LD_INT 9
113337: PUSH
113338: EMPTY
113339: LIST
113340: LIST
113341: PUSH
113342: LD_INT 25
113344: PUSH
113345: LD_INT 8
113347: PUSH
113348: EMPTY
113349: LIST
113350: LIST
113351: PUSH
113352: EMPTY
113353: LIST
113354: LIST
113355: LIST
113356: LIST
113357: PUSH
113358: EMPTY
113359: LIST
113360: LIST
113361: PPUSH
113362: CALL_OW 69
113366: PUSH
113367: FOR_IN
113368: IFFALSE 113384
// begin SetClass ( i , 1 ) ;
113370: LD_VAR 0 1
113374: PPUSH
113375: LD_INT 1
113377: PPUSH
113378: CALL_OW 336
// end ;
113382: GO 113367
113384: POP
113385: POP
// end ;
113386: PPOPN 1
113388: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113389: LD_EXP 159
113393: PUSH
113394: LD_EXP 163
113398: AND
113399: PUSH
113400: LD_OWVAR 65
113404: PUSH
113405: LD_INT 7
113407: LESS
113408: AND
113409: IFFALSE 113423
113411: GO 113413
113413: DISABLE
// begin enable ;
113414: ENABLE
// game_speed := 7 ;
113415: LD_ADDR_OWVAR 65
113419: PUSH
113420: LD_INT 7
113422: ST_TO_ADDR
// end ;
113423: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113424: LD_EXP 159
113428: PUSH
113429: LD_EXP 166
113433: AND
113434: IFFALSE 113636
113436: GO 113438
113438: DISABLE
113439: LD_INT 0
113441: PPUSH
113442: PPUSH
113443: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113444: LD_ADDR_VAR 0 3
113448: PUSH
113449: LD_INT 81
113451: PUSH
113452: LD_OWVAR 2
113456: PUSH
113457: EMPTY
113458: LIST
113459: LIST
113460: PUSH
113461: LD_INT 21
113463: PUSH
113464: LD_INT 1
113466: PUSH
113467: EMPTY
113468: LIST
113469: LIST
113470: PUSH
113471: EMPTY
113472: LIST
113473: LIST
113474: PPUSH
113475: CALL_OW 69
113479: ST_TO_ADDR
// if not tmp then
113480: LD_VAR 0 3
113484: NOT
113485: IFFALSE 113489
// exit ;
113487: GO 113636
// if tmp > 5 then
113489: LD_VAR 0 3
113493: PUSH
113494: LD_INT 5
113496: GREATER
113497: IFFALSE 113509
// k := 5 else
113499: LD_ADDR_VAR 0 2
113503: PUSH
113504: LD_INT 5
113506: ST_TO_ADDR
113507: GO 113519
// k := tmp ;
113509: LD_ADDR_VAR 0 2
113513: PUSH
113514: LD_VAR 0 3
113518: ST_TO_ADDR
// for i := 1 to k do
113519: LD_ADDR_VAR 0 1
113523: PUSH
113524: DOUBLE
113525: LD_INT 1
113527: DEC
113528: ST_TO_ADDR
113529: LD_VAR 0 2
113533: PUSH
113534: FOR_TO
113535: IFFALSE 113634
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113537: LD_VAR 0 3
113541: PUSH
113542: LD_VAR 0 1
113546: ARRAY
113547: PPUSH
113548: LD_VAR 0 1
113552: PUSH
113553: LD_INT 4
113555: MOD
113556: PUSH
113557: LD_INT 1
113559: PLUS
113560: PPUSH
113561: CALL_OW 259
113565: PUSH
113566: LD_INT 10
113568: LESS
113569: IFFALSE 113632
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113571: LD_VAR 0 3
113575: PUSH
113576: LD_VAR 0 1
113580: ARRAY
113581: PPUSH
113582: LD_VAR 0 1
113586: PUSH
113587: LD_INT 4
113589: MOD
113590: PUSH
113591: LD_INT 1
113593: PLUS
113594: PPUSH
113595: LD_VAR 0 3
113599: PUSH
113600: LD_VAR 0 1
113604: ARRAY
113605: PPUSH
113606: LD_VAR 0 1
113610: PUSH
113611: LD_INT 4
113613: MOD
113614: PUSH
113615: LD_INT 1
113617: PLUS
113618: PPUSH
113619: CALL_OW 259
113623: PUSH
113624: LD_INT 1
113626: PLUS
113627: PPUSH
113628: CALL_OW 237
113632: GO 113534
113634: POP
113635: POP
// end ;
113636: PPOPN 3
113638: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113639: LD_EXP 159
113643: PUSH
113644: LD_EXP 167
113648: AND
113649: IFFALSE 113669
113651: GO 113653
113653: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113654: LD_INT 4
113656: PPUSH
113657: LD_OWVAR 2
113661: PPUSH
113662: LD_INT 0
113664: PPUSH
113665: CALL_OW 324
113669: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113670: LD_EXP 159
113674: PUSH
113675: LD_EXP 196
113679: AND
113680: IFFALSE 113700
113682: GO 113684
113684: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113685: LD_INT 19
113687: PPUSH
113688: LD_OWVAR 2
113692: PPUSH
113693: LD_INT 0
113695: PPUSH
113696: CALL_OW 324
113700: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113701: LD_EXP 159
113705: PUSH
113706: LD_EXP 168
113710: AND
113711: IFFALSE 113813
113713: GO 113715
113715: DISABLE
113716: LD_INT 0
113718: PPUSH
113719: PPUSH
// begin enable ;
113720: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113721: LD_ADDR_VAR 0 2
113725: PUSH
113726: LD_INT 22
113728: PUSH
113729: LD_OWVAR 2
113733: PUSH
113734: EMPTY
113735: LIST
113736: LIST
113737: PUSH
113738: LD_INT 2
113740: PUSH
113741: LD_INT 34
113743: PUSH
113744: LD_INT 11
113746: PUSH
113747: EMPTY
113748: LIST
113749: LIST
113750: PUSH
113751: LD_INT 34
113753: PUSH
113754: LD_INT 30
113756: PUSH
113757: EMPTY
113758: LIST
113759: LIST
113760: PUSH
113761: EMPTY
113762: LIST
113763: LIST
113764: LIST
113765: PUSH
113766: EMPTY
113767: LIST
113768: LIST
113769: PPUSH
113770: CALL_OW 69
113774: ST_TO_ADDR
// if not tmp then
113775: LD_VAR 0 2
113779: NOT
113780: IFFALSE 113784
// exit ;
113782: GO 113813
// for i in tmp do
113784: LD_ADDR_VAR 0 1
113788: PUSH
113789: LD_VAR 0 2
113793: PUSH
113794: FOR_IN
113795: IFFALSE 113811
// begin SetLives ( i , 0 ) ;
113797: LD_VAR 0 1
113801: PPUSH
113802: LD_INT 0
113804: PPUSH
113805: CALL_OW 234
// end ;
113809: GO 113794
113811: POP
113812: POP
// end ;
113813: PPOPN 2
113815: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113816: LD_EXP 159
113820: PUSH
113821: LD_EXP 169
113825: AND
113826: IFFALSE 113846
113828: GO 113830
113830: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113831: LD_INT 32
113833: PPUSH
113834: LD_OWVAR 2
113838: PPUSH
113839: LD_INT 0
113841: PPUSH
113842: CALL_OW 324
113846: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113847: LD_EXP 159
113851: PUSH
113852: LD_EXP 170
113856: AND
113857: IFFALSE 114038
113859: GO 113861
113861: DISABLE
113862: LD_INT 0
113864: PPUSH
113865: PPUSH
113866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113867: LD_ADDR_VAR 0 2
113871: PUSH
113872: LD_INT 22
113874: PUSH
113875: LD_OWVAR 2
113879: PUSH
113880: EMPTY
113881: LIST
113882: LIST
113883: PUSH
113884: LD_INT 33
113886: PUSH
113887: LD_INT 3
113889: PUSH
113890: EMPTY
113891: LIST
113892: LIST
113893: PUSH
113894: EMPTY
113895: LIST
113896: LIST
113897: PPUSH
113898: CALL_OW 69
113902: ST_TO_ADDR
// if not tmp then
113903: LD_VAR 0 2
113907: NOT
113908: IFFALSE 113912
// exit ;
113910: GO 114038
// side := 0 ;
113912: LD_ADDR_VAR 0 3
113916: PUSH
113917: LD_INT 0
113919: ST_TO_ADDR
// for i := 1 to 8 do
113920: LD_ADDR_VAR 0 1
113924: PUSH
113925: DOUBLE
113926: LD_INT 1
113928: DEC
113929: ST_TO_ADDR
113930: LD_INT 8
113932: PUSH
113933: FOR_TO
113934: IFFALSE 113982
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113936: LD_OWVAR 2
113940: PUSH
113941: LD_VAR 0 1
113945: NONEQUAL
113946: PUSH
113947: LD_OWVAR 2
113951: PPUSH
113952: LD_VAR 0 1
113956: PPUSH
113957: CALL_OW 81
113961: PUSH
113962: LD_INT 2
113964: EQUAL
113965: AND
113966: IFFALSE 113980
// begin side := i ;
113968: LD_ADDR_VAR 0 3
113972: PUSH
113973: LD_VAR 0 1
113977: ST_TO_ADDR
// break ;
113978: GO 113982
// end ;
113980: GO 113933
113982: POP
113983: POP
// if not side then
113984: LD_VAR 0 3
113988: NOT
113989: IFFALSE 113993
// exit ;
113991: GO 114038
// for i := 1 to tmp do
113993: LD_ADDR_VAR 0 1
113997: PUSH
113998: DOUBLE
113999: LD_INT 1
114001: DEC
114002: ST_TO_ADDR
114003: LD_VAR 0 2
114007: PUSH
114008: FOR_TO
114009: IFFALSE 114036
// if Prob ( 60 ) then
114011: LD_INT 60
114013: PPUSH
114014: CALL_OW 13
114018: IFFALSE 114034
// SetSide ( i , side ) ;
114020: LD_VAR 0 1
114024: PPUSH
114025: LD_VAR 0 3
114029: PPUSH
114030: CALL_OW 235
114034: GO 114008
114036: POP
114037: POP
// end ;
114038: PPOPN 3
114040: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
114041: LD_EXP 159
114045: PUSH
114046: LD_EXP 172
114050: AND
114051: IFFALSE 114170
114053: GO 114055
114055: DISABLE
114056: LD_INT 0
114058: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
114059: LD_ADDR_VAR 0 1
114063: PUSH
114064: LD_INT 22
114066: PUSH
114067: LD_OWVAR 2
114071: PUSH
114072: EMPTY
114073: LIST
114074: LIST
114075: PUSH
114076: LD_INT 21
114078: PUSH
114079: LD_INT 1
114081: PUSH
114082: EMPTY
114083: LIST
114084: LIST
114085: PUSH
114086: LD_INT 3
114088: PUSH
114089: LD_INT 23
114091: PUSH
114092: LD_INT 0
114094: PUSH
114095: EMPTY
114096: LIST
114097: LIST
114098: PUSH
114099: EMPTY
114100: LIST
114101: LIST
114102: PUSH
114103: EMPTY
114104: LIST
114105: LIST
114106: LIST
114107: PPUSH
114108: CALL_OW 69
114112: PUSH
114113: FOR_IN
114114: IFFALSE 114168
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
114116: LD_VAR 0 1
114120: PPUSH
114121: CALL_OW 257
114125: PUSH
114126: LD_INT 1
114128: PUSH
114129: LD_INT 2
114131: PUSH
114132: LD_INT 3
114134: PUSH
114135: LD_INT 4
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: LIST
114142: LIST
114143: IN
114144: IFFALSE 114166
// SetClass ( un , rand ( 1 , 4 ) ) ;
114146: LD_VAR 0 1
114150: PPUSH
114151: LD_INT 1
114153: PPUSH
114154: LD_INT 4
114156: PPUSH
114157: CALL_OW 12
114161: PPUSH
114162: CALL_OW 336
114166: GO 114113
114168: POP
114169: POP
// end ;
114170: PPOPN 1
114172: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
114173: LD_EXP 159
114177: PUSH
114178: LD_EXP 171
114182: AND
114183: IFFALSE 114262
114185: GO 114187
114187: DISABLE
114188: LD_INT 0
114190: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114191: LD_ADDR_VAR 0 1
114195: PUSH
114196: LD_INT 22
114198: PUSH
114199: LD_OWVAR 2
114203: PUSH
114204: EMPTY
114205: LIST
114206: LIST
114207: PUSH
114208: LD_INT 21
114210: PUSH
114211: LD_INT 3
114213: PUSH
114214: EMPTY
114215: LIST
114216: LIST
114217: PUSH
114218: EMPTY
114219: LIST
114220: LIST
114221: PPUSH
114222: CALL_OW 69
114226: ST_TO_ADDR
// if not tmp then
114227: LD_VAR 0 1
114231: NOT
114232: IFFALSE 114236
// exit ;
114234: GO 114262
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114236: LD_VAR 0 1
114240: PUSH
114241: LD_INT 1
114243: PPUSH
114244: LD_VAR 0 1
114248: PPUSH
114249: CALL_OW 12
114253: ARRAY
114254: PPUSH
114255: LD_INT 100
114257: PPUSH
114258: CALL_OW 234
// end ;
114262: PPOPN 1
114264: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114265: LD_EXP 159
114269: PUSH
114270: LD_EXP 173
114274: AND
114275: IFFALSE 114373
114277: GO 114279
114279: DISABLE
114280: LD_INT 0
114282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114283: LD_ADDR_VAR 0 1
114287: PUSH
114288: LD_INT 22
114290: PUSH
114291: LD_OWVAR 2
114295: PUSH
114296: EMPTY
114297: LIST
114298: LIST
114299: PUSH
114300: LD_INT 21
114302: PUSH
114303: LD_INT 1
114305: PUSH
114306: EMPTY
114307: LIST
114308: LIST
114309: PUSH
114310: EMPTY
114311: LIST
114312: LIST
114313: PPUSH
114314: CALL_OW 69
114318: ST_TO_ADDR
// if not tmp then
114319: LD_VAR 0 1
114323: NOT
114324: IFFALSE 114328
// exit ;
114326: GO 114373
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114328: LD_VAR 0 1
114332: PUSH
114333: LD_INT 1
114335: PPUSH
114336: LD_VAR 0 1
114340: PPUSH
114341: CALL_OW 12
114345: ARRAY
114346: PPUSH
114347: LD_INT 1
114349: PPUSH
114350: LD_INT 4
114352: PPUSH
114353: CALL_OW 12
114357: PPUSH
114358: LD_INT 3000
114360: PPUSH
114361: LD_INT 9000
114363: PPUSH
114364: CALL_OW 12
114368: PPUSH
114369: CALL_OW 492
// end ;
114373: PPOPN 1
114375: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114376: LD_EXP 159
114380: PUSH
114381: LD_EXP 174
114385: AND
114386: IFFALSE 114406
114388: GO 114390
114390: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114391: LD_INT 1
114393: PPUSH
114394: LD_OWVAR 2
114398: PPUSH
114399: LD_INT 0
114401: PPUSH
114402: CALL_OW 324
114406: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114407: LD_EXP 159
114411: PUSH
114412: LD_EXP 175
114416: AND
114417: IFFALSE 114500
114419: GO 114421
114421: DISABLE
114422: LD_INT 0
114424: PPUSH
114425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114426: LD_ADDR_VAR 0 2
114430: PUSH
114431: LD_INT 22
114433: PUSH
114434: LD_OWVAR 2
114438: PUSH
114439: EMPTY
114440: LIST
114441: LIST
114442: PUSH
114443: LD_INT 21
114445: PUSH
114446: LD_INT 3
114448: PUSH
114449: EMPTY
114450: LIST
114451: LIST
114452: PUSH
114453: EMPTY
114454: LIST
114455: LIST
114456: PPUSH
114457: CALL_OW 69
114461: ST_TO_ADDR
// if not tmp then
114462: LD_VAR 0 2
114466: NOT
114467: IFFALSE 114471
// exit ;
114469: GO 114500
// for i in tmp do
114471: LD_ADDR_VAR 0 1
114475: PUSH
114476: LD_VAR 0 2
114480: PUSH
114481: FOR_IN
114482: IFFALSE 114498
// SetBLevel ( i , 10 ) ;
114484: LD_VAR 0 1
114488: PPUSH
114489: LD_INT 10
114491: PPUSH
114492: CALL_OW 241
114496: GO 114481
114498: POP
114499: POP
// end ;
114500: PPOPN 2
114502: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114503: LD_EXP 159
114507: PUSH
114508: LD_EXP 176
114512: AND
114513: IFFALSE 114624
114515: GO 114517
114517: DISABLE
114518: LD_INT 0
114520: PPUSH
114521: PPUSH
114522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114523: LD_ADDR_VAR 0 3
114527: PUSH
114528: LD_INT 22
114530: PUSH
114531: LD_OWVAR 2
114535: PUSH
114536: EMPTY
114537: LIST
114538: LIST
114539: PUSH
114540: LD_INT 25
114542: PUSH
114543: LD_INT 1
114545: PUSH
114546: EMPTY
114547: LIST
114548: LIST
114549: PUSH
114550: EMPTY
114551: LIST
114552: LIST
114553: PPUSH
114554: CALL_OW 69
114558: ST_TO_ADDR
// if not tmp then
114559: LD_VAR 0 3
114563: NOT
114564: IFFALSE 114568
// exit ;
114566: GO 114624
// un := tmp [ rand ( 1 , tmp ) ] ;
114568: LD_ADDR_VAR 0 2
114572: PUSH
114573: LD_VAR 0 3
114577: PUSH
114578: LD_INT 1
114580: PPUSH
114581: LD_VAR 0 3
114585: PPUSH
114586: CALL_OW 12
114590: ARRAY
114591: ST_TO_ADDR
// if Crawls ( un ) then
114592: LD_VAR 0 2
114596: PPUSH
114597: CALL_OW 318
114601: IFFALSE 114612
// ComWalk ( un ) ;
114603: LD_VAR 0 2
114607: PPUSH
114608: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114612: LD_VAR 0 2
114616: PPUSH
114617: LD_INT 5
114619: PPUSH
114620: CALL_OW 336
// end ;
114624: PPOPN 3
114626: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
114627: LD_EXP 159
114631: PUSH
114632: LD_EXP 177
114636: AND
114637: PUSH
114638: LD_OWVAR 67
114642: PUSH
114643: LD_INT 4
114645: LESS
114646: AND
114647: IFFALSE 114666
114649: GO 114651
114651: DISABLE
// begin Difficulty := Difficulty + 1 ;
114652: LD_ADDR_OWVAR 67
114656: PUSH
114657: LD_OWVAR 67
114661: PUSH
114662: LD_INT 1
114664: PLUS
114665: ST_TO_ADDR
// end ;
114666: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114667: LD_EXP 159
114671: PUSH
114672: LD_EXP 178
114676: AND
114677: IFFALSE 114780
114679: GO 114681
114681: DISABLE
114682: LD_INT 0
114684: PPUSH
// begin for i := 1 to 5 do
114685: LD_ADDR_VAR 0 1
114689: PUSH
114690: DOUBLE
114691: LD_INT 1
114693: DEC
114694: ST_TO_ADDR
114695: LD_INT 5
114697: PUSH
114698: FOR_TO
114699: IFFALSE 114778
// begin uc_nation := nation_nature ;
114701: LD_ADDR_OWVAR 21
114705: PUSH
114706: LD_INT 0
114708: ST_TO_ADDR
// uc_side := 0 ;
114709: LD_ADDR_OWVAR 20
114713: PUSH
114714: LD_INT 0
114716: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114717: LD_ADDR_OWVAR 29
114721: PUSH
114722: LD_INT 12
114724: PUSH
114725: LD_INT 12
114727: PUSH
114728: EMPTY
114729: LIST
114730: LIST
114731: ST_TO_ADDR
// hc_agressivity := 20 ;
114732: LD_ADDR_OWVAR 35
114736: PUSH
114737: LD_INT 20
114739: ST_TO_ADDR
// hc_class := class_tiger ;
114740: LD_ADDR_OWVAR 28
114744: PUSH
114745: LD_INT 14
114747: ST_TO_ADDR
// hc_gallery :=  ;
114748: LD_ADDR_OWVAR 33
114752: PUSH
114753: LD_STRING 
114755: ST_TO_ADDR
// hc_name :=  ;
114756: LD_ADDR_OWVAR 26
114760: PUSH
114761: LD_STRING 
114763: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114764: CALL_OW 44
114768: PPUSH
114769: LD_INT 0
114771: PPUSH
114772: CALL_OW 51
// end ;
114776: GO 114698
114778: POP
114779: POP
// end ;
114780: PPOPN 1
114782: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114783: LD_EXP 159
114787: PUSH
114788: LD_EXP 179
114792: AND
114793: IFFALSE 114802
114795: GO 114797
114797: DISABLE
// StreamSibBomb ;
114798: CALL 114803 0 0
114802: END
// export function StreamSibBomb ; var i , x , y ; begin
114803: LD_INT 0
114805: PPUSH
114806: PPUSH
114807: PPUSH
114808: PPUSH
// result := false ;
114809: LD_ADDR_VAR 0 1
114813: PUSH
114814: LD_INT 0
114816: ST_TO_ADDR
// for i := 1 to 16 do
114817: LD_ADDR_VAR 0 2
114821: PUSH
114822: DOUBLE
114823: LD_INT 1
114825: DEC
114826: ST_TO_ADDR
114827: LD_INT 16
114829: PUSH
114830: FOR_TO
114831: IFFALSE 115030
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114833: LD_ADDR_VAR 0 3
114837: PUSH
114838: LD_INT 10
114840: PUSH
114841: LD_INT 20
114843: PUSH
114844: LD_INT 30
114846: PUSH
114847: LD_INT 40
114849: PUSH
114850: LD_INT 50
114852: PUSH
114853: LD_INT 60
114855: PUSH
114856: LD_INT 70
114858: PUSH
114859: LD_INT 80
114861: PUSH
114862: LD_INT 90
114864: PUSH
114865: LD_INT 100
114867: PUSH
114868: LD_INT 110
114870: PUSH
114871: LD_INT 120
114873: PUSH
114874: LD_INT 130
114876: PUSH
114877: LD_INT 140
114879: PUSH
114880: LD_INT 150
114882: PUSH
114883: EMPTY
114884: LIST
114885: LIST
114886: LIST
114887: LIST
114888: LIST
114889: LIST
114890: LIST
114891: LIST
114892: LIST
114893: LIST
114894: LIST
114895: LIST
114896: LIST
114897: LIST
114898: LIST
114899: PUSH
114900: LD_INT 1
114902: PPUSH
114903: LD_INT 15
114905: PPUSH
114906: CALL_OW 12
114910: ARRAY
114911: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114912: LD_ADDR_VAR 0 4
114916: PUSH
114917: LD_INT 10
114919: PUSH
114920: LD_INT 20
114922: PUSH
114923: LD_INT 30
114925: PUSH
114926: LD_INT 40
114928: PUSH
114929: LD_INT 50
114931: PUSH
114932: LD_INT 60
114934: PUSH
114935: LD_INT 70
114937: PUSH
114938: LD_INT 80
114940: PUSH
114941: LD_INT 90
114943: PUSH
114944: LD_INT 100
114946: PUSH
114947: LD_INT 110
114949: PUSH
114950: LD_INT 120
114952: PUSH
114953: LD_INT 130
114955: PUSH
114956: LD_INT 140
114958: PUSH
114959: LD_INT 150
114961: PUSH
114962: EMPTY
114963: LIST
114964: LIST
114965: LIST
114966: LIST
114967: LIST
114968: LIST
114969: LIST
114970: LIST
114971: LIST
114972: LIST
114973: LIST
114974: LIST
114975: LIST
114976: LIST
114977: LIST
114978: PUSH
114979: LD_INT 1
114981: PPUSH
114982: LD_INT 15
114984: PPUSH
114985: CALL_OW 12
114989: ARRAY
114990: ST_TO_ADDR
// if ValidHex ( x , y ) then
114991: LD_VAR 0 3
114995: PPUSH
114996: LD_VAR 0 4
115000: PPUSH
115001: CALL_OW 488
115005: IFFALSE 115028
// begin result := [ x , y ] ;
115007: LD_ADDR_VAR 0 1
115011: PUSH
115012: LD_VAR 0 3
115016: PUSH
115017: LD_VAR 0 4
115021: PUSH
115022: EMPTY
115023: LIST
115024: LIST
115025: ST_TO_ADDR
// break ;
115026: GO 115030
// end ; end ;
115028: GO 114830
115030: POP
115031: POP
// if result then
115032: LD_VAR 0 1
115036: IFFALSE 115096
// begin ToLua ( playSibBomb() ) ;
115038: LD_STRING playSibBomb()
115040: PPUSH
115041: CALL_OW 559
// wait ( 0 0$14 ) ;
115045: LD_INT 490
115047: PPUSH
115048: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
115052: LD_VAR 0 1
115056: PUSH
115057: LD_INT 1
115059: ARRAY
115060: PPUSH
115061: LD_VAR 0 1
115065: PUSH
115066: LD_INT 2
115068: ARRAY
115069: PPUSH
115070: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
115074: LD_VAR 0 1
115078: PUSH
115079: LD_INT 1
115081: ARRAY
115082: PPUSH
115083: LD_VAR 0 1
115087: PUSH
115088: LD_INT 2
115090: ARRAY
115091: PPUSH
115092: CALL_OW 429
// end ; end ;
115096: LD_VAR 0 1
115100: RET
// every 0 0$1 trigger StreamModeActive and sReset do
115101: LD_EXP 159
115105: PUSH
115106: LD_EXP 181
115110: AND
115111: IFFALSE 115123
115113: GO 115115
115115: DISABLE
// YouLost (  ) ;
115116: LD_STRING 
115118: PPUSH
115119: CALL_OW 104
115123: END
// every 0 0$1 trigger StreamModeActive and sFog do
115124: LD_EXP 159
115128: PUSH
115129: LD_EXP 180
115133: AND
115134: IFFALSE 115148
115136: GO 115138
115138: DISABLE
// FogOff ( your_side ) ;
115139: LD_OWVAR 2
115143: PPUSH
115144: CALL_OW 344
115148: END
// every 0 0$1 trigger StreamModeActive and sSun do
115149: LD_EXP 159
115153: PUSH
115154: LD_EXP 182
115158: AND
115159: IFFALSE 115187
115161: GO 115163
115163: DISABLE
// begin solar_recharge_percent := 0 ;
115164: LD_ADDR_OWVAR 79
115168: PUSH
115169: LD_INT 0
115171: ST_TO_ADDR
// wait ( 5 5$00 ) ;
115172: LD_INT 10500
115174: PPUSH
115175: CALL_OW 67
// solar_recharge_percent := 100 ;
115179: LD_ADDR_OWVAR 79
115183: PUSH
115184: LD_INT 100
115186: ST_TO_ADDR
// end ;
115187: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
115188: LD_EXP 159
115192: PUSH
115193: LD_EXP 183
115197: AND
115198: IFFALSE 115437
115200: GO 115202
115202: DISABLE
115203: LD_INT 0
115205: PPUSH
115206: PPUSH
115207: PPUSH
// begin tmp := [ ] ;
115208: LD_ADDR_VAR 0 3
115212: PUSH
115213: EMPTY
115214: ST_TO_ADDR
// for i := 1 to 6 do
115215: LD_ADDR_VAR 0 1
115219: PUSH
115220: DOUBLE
115221: LD_INT 1
115223: DEC
115224: ST_TO_ADDR
115225: LD_INT 6
115227: PUSH
115228: FOR_TO
115229: IFFALSE 115334
// begin uc_nation := nation_nature ;
115231: LD_ADDR_OWVAR 21
115235: PUSH
115236: LD_INT 0
115238: ST_TO_ADDR
// uc_side := 0 ;
115239: LD_ADDR_OWVAR 20
115243: PUSH
115244: LD_INT 0
115246: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115247: LD_ADDR_OWVAR 29
115251: PUSH
115252: LD_INT 12
115254: PUSH
115255: LD_INT 12
115257: PUSH
115258: EMPTY
115259: LIST
115260: LIST
115261: ST_TO_ADDR
// hc_agressivity := 20 ;
115262: LD_ADDR_OWVAR 35
115266: PUSH
115267: LD_INT 20
115269: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115270: LD_ADDR_OWVAR 28
115274: PUSH
115275: LD_INT 17
115277: ST_TO_ADDR
// hc_gallery :=  ;
115278: LD_ADDR_OWVAR 33
115282: PUSH
115283: LD_STRING 
115285: ST_TO_ADDR
// hc_name :=  ;
115286: LD_ADDR_OWVAR 26
115290: PUSH
115291: LD_STRING 
115293: ST_TO_ADDR
// un := CreateHuman ;
115294: LD_ADDR_VAR 0 2
115298: PUSH
115299: CALL_OW 44
115303: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115304: LD_VAR 0 2
115308: PPUSH
115309: LD_INT 1
115311: PPUSH
115312: CALL_OW 51
// tmp := tmp ^ un ;
115316: LD_ADDR_VAR 0 3
115320: PUSH
115321: LD_VAR 0 3
115325: PUSH
115326: LD_VAR 0 2
115330: ADD
115331: ST_TO_ADDR
// end ;
115332: GO 115228
115334: POP
115335: POP
// repeat wait ( 0 0$1 ) ;
115336: LD_INT 35
115338: PPUSH
115339: CALL_OW 67
// for un in tmp do
115343: LD_ADDR_VAR 0 2
115347: PUSH
115348: LD_VAR 0 3
115352: PUSH
115353: FOR_IN
115354: IFFALSE 115428
// begin if IsDead ( un ) then
115356: LD_VAR 0 2
115360: PPUSH
115361: CALL_OW 301
115365: IFFALSE 115385
// begin tmp := tmp diff un ;
115367: LD_ADDR_VAR 0 3
115371: PUSH
115372: LD_VAR 0 3
115376: PUSH
115377: LD_VAR 0 2
115381: DIFF
115382: ST_TO_ADDR
// continue ;
115383: GO 115353
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115385: LD_VAR 0 2
115389: PPUSH
115390: LD_INT 3
115392: PUSH
115393: LD_INT 22
115395: PUSH
115396: LD_INT 0
115398: PUSH
115399: EMPTY
115400: LIST
115401: LIST
115402: PUSH
115403: EMPTY
115404: LIST
115405: LIST
115406: PPUSH
115407: CALL_OW 69
115411: PPUSH
115412: LD_VAR 0 2
115416: PPUSH
115417: CALL_OW 74
115421: PPUSH
115422: CALL_OW 115
// end ;
115426: GO 115353
115428: POP
115429: POP
// until not tmp ;
115430: LD_VAR 0 3
115434: NOT
115435: IFFALSE 115336
// end ;
115437: PPOPN 3
115439: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115440: LD_EXP 159
115444: PUSH
115445: LD_EXP 184
115449: AND
115450: IFFALSE 115504
115452: GO 115454
115454: DISABLE
// begin ToLua ( displayTroll(); ) ;
115455: LD_STRING displayTroll();
115457: PPUSH
115458: CALL_OW 559
// wait ( 3 3$00 ) ;
115462: LD_INT 6300
115464: PPUSH
115465: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115469: LD_STRING hideTroll();
115471: PPUSH
115472: CALL_OW 559
// wait ( 1 1$00 ) ;
115476: LD_INT 2100
115478: PPUSH
115479: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115483: LD_STRING displayTroll();
115485: PPUSH
115486: CALL_OW 559
// wait ( 1 1$00 ) ;
115490: LD_INT 2100
115492: PPUSH
115493: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115497: LD_STRING hideTroll();
115499: PPUSH
115500: CALL_OW 559
// end ;
115504: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115505: LD_EXP 159
115509: PUSH
115510: LD_EXP 185
115514: AND
115515: IFFALSE 115578
115517: GO 115519
115519: DISABLE
115520: LD_INT 0
115522: PPUSH
// begin p := 0 ;
115523: LD_ADDR_VAR 0 1
115527: PUSH
115528: LD_INT 0
115530: ST_TO_ADDR
// repeat game_speed := 1 ;
115531: LD_ADDR_OWVAR 65
115535: PUSH
115536: LD_INT 1
115538: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115539: LD_INT 35
115541: PPUSH
115542: CALL_OW 67
// p := p + 1 ;
115546: LD_ADDR_VAR 0 1
115550: PUSH
115551: LD_VAR 0 1
115555: PUSH
115556: LD_INT 1
115558: PLUS
115559: ST_TO_ADDR
// until p >= 60 ;
115560: LD_VAR 0 1
115564: PUSH
115565: LD_INT 60
115567: GREATEREQUAL
115568: IFFALSE 115531
// game_speed := 4 ;
115570: LD_ADDR_OWVAR 65
115574: PUSH
115575: LD_INT 4
115577: ST_TO_ADDR
// end ;
115578: PPOPN 1
115580: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115581: LD_EXP 159
115585: PUSH
115586: LD_EXP 186
115590: AND
115591: IFFALSE 115737
115593: GO 115595
115595: DISABLE
115596: LD_INT 0
115598: PPUSH
115599: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115600: LD_ADDR_VAR 0 1
115604: PUSH
115605: LD_INT 22
115607: PUSH
115608: LD_OWVAR 2
115612: PUSH
115613: EMPTY
115614: LIST
115615: LIST
115616: PUSH
115617: LD_INT 2
115619: PUSH
115620: LD_INT 30
115622: PUSH
115623: LD_INT 0
115625: PUSH
115626: EMPTY
115627: LIST
115628: LIST
115629: PUSH
115630: LD_INT 30
115632: PUSH
115633: LD_INT 1
115635: PUSH
115636: EMPTY
115637: LIST
115638: LIST
115639: PUSH
115640: EMPTY
115641: LIST
115642: LIST
115643: LIST
115644: PUSH
115645: EMPTY
115646: LIST
115647: LIST
115648: PPUSH
115649: CALL_OW 69
115653: ST_TO_ADDR
// if not depot then
115654: LD_VAR 0 1
115658: NOT
115659: IFFALSE 115663
// exit ;
115661: GO 115737
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115663: LD_ADDR_VAR 0 2
115667: PUSH
115668: LD_VAR 0 1
115672: PUSH
115673: LD_INT 1
115675: PPUSH
115676: LD_VAR 0 1
115680: PPUSH
115681: CALL_OW 12
115685: ARRAY
115686: PPUSH
115687: CALL_OW 274
115691: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115692: LD_VAR 0 2
115696: PPUSH
115697: LD_INT 1
115699: PPUSH
115700: LD_INT 0
115702: PPUSH
115703: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115707: LD_VAR 0 2
115711: PPUSH
115712: LD_INT 2
115714: PPUSH
115715: LD_INT 0
115717: PPUSH
115718: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115722: LD_VAR 0 2
115726: PPUSH
115727: LD_INT 3
115729: PPUSH
115730: LD_INT 0
115732: PPUSH
115733: CALL_OW 277
// end ;
115737: PPOPN 2
115739: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115740: LD_EXP 159
115744: PUSH
115745: LD_EXP 187
115749: AND
115750: IFFALSE 115847
115752: GO 115754
115754: DISABLE
115755: LD_INT 0
115757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115758: LD_ADDR_VAR 0 1
115762: PUSH
115763: LD_INT 22
115765: PUSH
115766: LD_OWVAR 2
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: PUSH
115775: LD_INT 21
115777: PUSH
115778: LD_INT 1
115780: PUSH
115781: EMPTY
115782: LIST
115783: LIST
115784: PUSH
115785: LD_INT 3
115787: PUSH
115788: LD_INT 23
115790: PUSH
115791: LD_INT 0
115793: PUSH
115794: EMPTY
115795: LIST
115796: LIST
115797: PUSH
115798: EMPTY
115799: LIST
115800: LIST
115801: PUSH
115802: EMPTY
115803: LIST
115804: LIST
115805: LIST
115806: PPUSH
115807: CALL_OW 69
115811: ST_TO_ADDR
// if not tmp then
115812: LD_VAR 0 1
115816: NOT
115817: IFFALSE 115821
// exit ;
115819: GO 115847
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115821: LD_VAR 0 1
115825: PUSH
115826: LD_INT 1
115828: PPUSH
115829: LD_VAR 0 1
115833: PPUSH
115834: CALL_OW 12
115838: ARRAY
115839: PPUSH
115840: LD_INT 200
115842: PPUSH
115843: CALL_OW 234
// end ;
115847: PPOPN 1
115849: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115850: LD_EXP 159
115854: PUSH
115855: LD_EXP 188
115859: AND
115860: IFFALSE 115939
115862: GO 115864
115864: DISABLE
115865: LD_INT 0
115867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115868: LD_ADDR_VAR 0 1
115872: PUSH
115873: LD_INT 22
115875: PUSH
115876: LD_OWVAR 2
115880: PUSH
115881: EMPTY
115882: LIST
115883: LIST
115884: PUSH
115885: LD_INT 21
115887: PUSH
115888: LD_INT 2
115890: PUSH
115891: EMPTY
115892: LIST
115893: LIST
115894: PUSH
115895: EMPTY
115896: LIST
115897: LIST
115898: PPUSH
115899: CALL_OW 69
115903: ST_TO_ADDR
// if not tmp then
115904: LD_VAR 0 1
115908: NOT
115909: IFFALSE 115913
// exit ;
115911: GO 115939
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115913: LD_VAR 0 1
115917: PUSH
115918: LD_INT 1
115920: PPUSH
115921: LD_VAR 0 1
115925: PPUSH
115926: CALL_OW 12
115930: ARRAY
115931: PPUSH
115932: LD_INT 60
115934: PPUSH
115935: CALL_OW 234
// end ;
115939: PPOPN 1
115941: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115942: LD_EXP 159
115946: PUSH
115947: LD_EXP 189
115951: AND
115952: IFFALSE 116051
115954: GO 115956
115956: DISABLE
115957: LD_INT 0
115959: PPUSH
115960: PPUSH
// begin enable ;
115961: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115962: LD_ADDR_VAR 0 1
115966: PUSH
115967: LD_INT 22
115969: PUSH
115970: LD_OWVAR 2
115974: PUSH
115975: EMPTY
115976: LIST
115977: LIST
115978: PUSH
115979: LD_INT 61
115981: PUSH
115982: EMPTY
115983: LIST
115984: PUSH
115985: LD_INT 33
115987: PUSH
115988: LD_INT 2
115990: PUSH
115991: EMPTY
115992: LIST
115993: LIST
115994: PUSH
115995: EMPTY
115996: LIST
115997: LIST
115998: LIST
115999: PPUSH
116000: CALL_OW 69
116004: ST_TO_ADDR
// if not tmp then
116005: LD_VAR 0 1
116009: NOT
116010: IFFALSE 116014
// exit ;
116012: GO 116051
// for i in tmp do
116014: LD_ADDR_VAR 0 2
116018: PUSH
116019: LD_VAR 0 1
116023: PUSH
116024: FOR_IN
116025: IFFALSE 116049
// if IsControledBy ( i ) then
116027: LD_VAR 0 2
116031: PPUSH
116032: CALL_OW 312
116036: IFFALSE 116047
// ComUnlink ( i ) ;
116038: LD_VAR 0 2
116042: PPUSH
116043: CALL_OW 136
116047: GO 116024
116049: POP
116050: POP
// end ;
116051: PPOPN 2
116053: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
116054: LD_EXP 159
116058: PUSH
116059: LD_EXP 190
116063: AND
116064: IFFALSE 116204
116066: GO 116068
116068: DISABLE
116069: LD_INT 0
116071: PPUSH
116072: PPUSH
// begin ToLua ( displayPowell(); ) ;
116073: LD_STRING displayPowell();
116075: PPUSH
116076: CALL_OW 559
// uc_side := 0 ;
116080: LD_ADDR_OWVAR 20
116084: PUSH
116085: LD_INT 0
116087: ST_TO_ADDR
// uc_nation := 2 ;
116088: LD_ADDR_OWVAR 21
116092: PUSH
116093: LD_INT 2
116095: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
116096: LD_ADDR_OWVAR 37
116100: PUSH
116101: LD_INT 14
116103: ST_TO_ADDR
// vc_engine := engine_siberite ;
116104: LD_ADDR_OWVAR 39
116108: PUSH
116109: LD_INT 3
116111: ST_TO_ADDR
// vc_control := control_apeman ;
116112: LD_ADDR_OWVAR 38
116116: PUSH
116117: LD_INT 5
116119: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
116120: LD_ADDR_OWVAR 40
116124: PUSH
116125: LD_INT 29
116127: ST_TO_ADDR
// un := CreateVehicle ;
116128: LD_ADDR_VAR 0 2
116132: PUSH
116133: CALL_OW 45
116137: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116138: LD_VAR 0 2
116142: PPUSH
116143: LD_INT 1
116145: PPUSH
116146: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116150: LD_INT 35
116152: PPUSH
116153: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116157: LD_VAR 0 2
116161: PPUSH
116162: LD_INT 22
116164: PUSH
116165: LD_OWVAR 2
116169: PUSH
116170: EMPTY
116171: LIST
116172: LIST
116173: PPUSH
116174: CALL_OW 69
116178: PPUSH
116179: LD_VAR 0 2
116183: PPUSH
116184: CALL_OW 74
116188: PPUSH
116189: CALL_OW 115
// until IsDead ( un ) ;
116193: LD_VAR 0 2
116197: PPUSH
116198: CALL_OW 301
116202: IFFALSE 116150
// end ;
116204: PPOPN 2
116206: END
// every 0 0$1 trigger StreamModeActive and sStu do
116207: LD_EXP 159
116211: PUSH
116212: LD_EXP 198
116216: AND
116217: IFFALSE 116233
116219: GO 116221
116221: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116222: LD_STRING displayStucuk();
116224: PPUSH
116225: CALL_OW 559
// ResetFog ;
116229: CALL_OW 335
// end ;
116233: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116234: LD_EXP 159
116238: PUSH
116239: LD_EXP 191
116243: AND
116244: IFFALSE 116385
116246: GO 116248
116248: DISABLE
116249: LD_INT 0
116251: PPUSH
116252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116253: LD_ADDR_VAR 0 2
116257: PUSH
116258: LD_INT 22
116260: PUSH
116261: LD_OWVAR 2
116265: PUSH
116266: EMPTY
116267: LIST
116268: LIST
116269: PUSH
116270: LD_INT 21
116272: PUSH
116273: LD_INT 1
116275: PUSH
116276: EMPTY
116277: LIST
116278: LIST
116279: PUSH
116280: EMPTY
116281: LIST
116282: LIST
116283: PPUSH
116284: CALL_OW 69
116288: ST_TO_ADDR
// if not tmp then
116289: LD_VAR 0 2
116293: NOT
116294: IFFALSE 116298
// exit ;
116296: GO 116385
// un := tmp [ rand ( 1 , tmp ) ] ;
116298: LD_ADDR_VAR 0 1
116302: PUSH
116303: LD_VAR 0 2
116307: PUSH
116308: LD_INT 1
116310: PPUSH
116311: LD_VAR 0 2
116315: PPUSH
116316: CALL_OW 12
116320: ARRAY
116321: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116322: LD_VAR 0 1
116326: PPUSH
116327: LD_INT 0
116329: PPUSH
116330: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116334: LD_VAR 0 1
116338: PPUSH
116339: LD_OWVAR 3
116343: PUSH
116344: LD_VAR 0 1
116348: DIFF
116349: PPUSH
116350: LD_VAR 0 1
116354: PPUSH
116355: CALL_OW 74
116359: PPUSH
116360: CALL_OW 115
// wait ( 0 0$20 ) ;
116364: LD_INT 700
116366: PPUSH
116367: CALL_OW 67
// SetSide ( un , your_side ) ;
116371: LD_VAR 0 1
116375: PPUSH
116376: LD_OWVAR 2
116380: PPUSH
116381: CALL_OW 235
// end ;
116385: PPOPN 2
116387: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116388: LD_EXP 159
116392: PUSH
116393: LD_EXP 192
116397: AND
116398: IFFALSE 116504
116400: GO 116402
116402: DISABLE
116403: LD_INT 0
116405: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116406: LD_ADDR_VAR 0 1
116410: PUSH
116411: LD_INT 22
116413: PUSH
116414: LD_OWVAR 2
116418: PUSH
116419: EMPTY
116420: LIST
116421: LIST
116422: PUSH
116423: LD_INT 2
116425: PUSH
116426: LD_INT 30
116428: PUSH
116429: LD_INT 0
116431: PUSH
116432: EMPTY
116433: LIST
116434: LIST
116435: PUSH
116436: LD_INT 30
116438: PUSH
116439: LD_INT 1
116441: PUSH
116442: EMPTY
116443: LIST
116444: LIST
116445: PUSH
116446: EMPTY
116447: LIST
116448: LIST
116449: LIST
116450: PUSH
116451: EMPTY
116452: LIST
116453: LIST
116454: PPUSH
116455: CALL_OW 69
116459: ST_TO_ADDR
// if not depot then
116460: LD_VAR 0 1
116464: NOT
116465: IFFALSE 116469
// exit ;
116467: GO 116504
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116469: LD_VAR 0 1
116473: PUSH
116474: LD_INT 1
116476: ARRAY
116477: PPUSH
116478: CALL_OW 250
116482: PPUSH
116483: LD_VAR 0 1
116487: PUSH
116488: LD_INT 1
116490: ARRAY
116491: PPUSH
116492: CALL_OW 251
116496: PPUSH
116497: LD_INT 70
116499: PPUSH
116500: CALL_OW 495
// end ;
116504: PPOPN 1
116506: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116507: LD_EXP 159
116511: PUSH
116512: LD_EXP 193
116516: AND
116517: IFFALSE 116728
116519: GO 116521
116521: DISABLE
116522: LD_INT 0
116524: PPUSH
116525: PPUSH
116526: PPUSH
116527: PPUSH
116528: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116529: LD_ADDR_VAR 0 5
116533: PUSH
116534: LD_INT 22
116536: PUSH
116537: LD_OWVAR 2
116541: PUSH
116542: EMPTY
116543: LIST
116544: LIST
116545: PUSH
116546: LD_INT 21
116548: PUSH
116549: LD_INT 1
116551: PUSH
116552: EMPTY
116553: LIST
116554: LIST
116555: PUSH
116556: EMPTY
116557: LIST
116558: LIST
116559: PPUSH
116560: CALL_OW 69
116564: ST_TO_ADDR
// if not tmp then
116565: LD_VAR 0 5
116569: NOT
116570: IFFALSE 116574
// exit ;
116572: GO 116728
// for i in tmp do
116574: LD_ADDR_VAR 0 1
116578: PUSH
116579: LD_VAR 0 5
116583: PUSH
116584: FOR_IN
116585: IFFALSE 116726
// begin d := rand ( 0 , 5 ) ;
116587: LD_ADDR_VAR 0 4
116591: PUSH
116592: LD_INT 0
116594: PPUSH
116595: LD_INT 5
116597: PPUSH
116598: CALL_OW 12
116602: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116603: LD_ADDR_VAR 0 2
116607: PUSH
116608: LD_VAR 0 1
116612: PPUSH
116613: CALL_OW 250
116617: PPUSH
116618: LD_VAR 0 4
116622: PPUSH
116623: LD_INT 3
116625: PPUSH
116626: LD_INT 12
116628: PPUSH
116629: CALL_OW 12
116633: PPUSH
116634: CALL_OW 272
116638: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116639: LD_ADDR_VAR 0 3
116643: PUSH
116644: LD_VAR 0 1
116648: PPUSH
116649: CALL_OW 251
116653: PPUSH
116654: LD_VAR 0 4
116658: PPUSH
116659: LD_INT 3
116661: PPUSH
116662: LD_INT 12
116664: PPUSH
116665: CALL_OW 12
116669: PPUSH
116670: CALL_OW 273
116674: ST_TO_ADDR
// if ValidHex ( x , y ) then
116675: LD_VAR 0 2
116679: PPUSH
116680: LD_VAR 0 3
116684: PPUSH
116685: CALL_OW 488
116689: IFFALSE 116724
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116691: LD_VAR 0 1
116695: PPUSH
116696: LD_VAR 0 2
116700: PPUSH
116701: LD_VAR 0 3
116705: PPUSH
116706: LD_INT 3
116708: PPUSH
116709: LD_INT 6
116711: PPUSH
116712: CALL_OW 12
116716: PPUSH
116717: LD_INT 1
116719: PPUSH
116720: CALL_OW 483
// end ;
116724: GO 116584
116726: POP
116727: POP
// end ;
116728: PPOPN 5
116730: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116731: LD_EXP 159
116735: PUSH
116736: LD_EXP 194
116740: AND
116741: IFFALSE 116835
116743: GO 116745
116745: DISABLE
116746: LD_INT 0
116748: PPUSH
116749: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116750: LD_ADDR_VAR 0 2
116754: PUSH
116755: LD_INT 22
116757: PUSH
116758: LD_OWVAR 2
116762: PUSH
116763: EMPTY
116764: LIST
116765: LIST
116766: PUSH
116767: LD_INT 32
116769: PUSH
116770: LD_INT 1
116772: PUSH
116773: EMPTY
116774: LIST
116775: LIST
116776: PUSH
116777: LD_INT 21
116779: PUSH
116780: LD_INT 2
116782: PUSH
116783: EMPTY
116784: LIST
116785: LIST
116786: PUSH
116787: EMPTY
116788: LIST
116789: LIST
116790: LIST
116791: PPUSH
116792: CALL_OW 69
116796: ST_TO_ADDR
// if not tmp then
116797: LD_VAR 0 2
116801: NOT
116802: IFFALSE 116806
// exit ;
116804: GO 116835
// for i in tmp do
116806: LD_ADDR_VAR 0 1
116810: PUSH
116811: LD_VAR 0 2
116815: PUSH
116816: FOR_IN
116817: IFFALSE 116833
// SetFuel ( i , 0 ) ;
116819: LD_VAR 0 1
116823: PPUSH
116824: LD_INT 0
116826: PPUSH
116827: CALL_OW 240
116831: GO 116816
116833: POP
116834: POP
// end ;
116835: PPOPN 2
116837: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116838: LD_EXP 159
116842: PUSH
116843: LD_EXP 195
116847: AND
116848: IFFALSE 116914
116850: GO 116852
116852: DISABLE
116853: LD_INT 0
116855: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116856: LD_ADDR_VAR 0 1
116860: PUSH
116861: LD_INT 22
116863: PUSH
116864: LD_OWVAR 2
116868: PUSH
116869: EMPTY
116870: LIST
116871: LIST
116872: PUSH
116873: LD_INT 30
116875: PUSH
116876: LD_INT 29
116878: PUSH
116879: EMPTY
116880: LIST
116881: LIST
116882: PUSH
116883: EMPTY
116884: LIST
116885: LIST
116886: PPUSH
116887: CALL_OW 69
116891: ST_TO_ADDR
// if not tmp then
116892: LD_VAR 0 1
116896: NOT
116897: IFFALSE 116901
// exit ;
116899: GO 116914
// DestroyUnit ( tmp [ 1 ] ) ;
116901: LD_VAR 0 1
116905: PUSH
116906: LD_INT 1
116908: ARRAY
116909: PPUSH
116910: CALL_OW 65
// end ;
116914: PPOPN 1
116916: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116917: LD_EXP 159
116921: PUSH
116922: LD_EXP 197
116926: AND
116927: IFFALSE 117056
116929: GO 116931
116931: DISABLE
116932: LD_INT 0
116934: PPUSH
// begin uc_side := 0 ;
116935: LD_ADDR_OWVAR 20
116939: PUSH
116940: LD_INT 0
116942: ST_TO_ADDR
// uc_nation := nation_arabian ;
116943: LD_ADDR_OWVAR 21
116947: PUSH
116948: LD_INT 2
116950: ST_TO_ADDR
// hc_gallery :=  ;
116951: LD_ADDR_OWVAR 33
116955: PUSH
116956: LD_STRING 
116958: ST_TO_ADDR
// hc_name :=  ;
116959: LD_ADDR_OWVAR 26
116963: PUSH
116964: LD_STRING 
116966: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116967: LD_INT 1
116969: PPUSH
116970: LD_INT 11
116972: PPUSH
116973: LD_INT 10
116975: PPUSH
116976: CALL_OW 380
// un := CreateHuman ;
116980: LD_ADDR_VAR 0 1
116984: PUSH
116985: CALL_OW 44
116989: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116990: LD_VAR 0 1
116994: PPUSH
116995: LD_INT 1
116997: PPUSH
116998: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117002: LD_INT 35
117004: PPUSH
117005: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117009: LD_VAR 0 1
117013: PPUSH
117014: LD_INT 22
117016: PUSH
117017: LD_OWVAR 2
117021: PUSH
117022: EMPTY
117023: LIST
117024: LIST
117025: PPUSH
117026: CALL_OW 69
117030: PPUSH
117031: LD_VAR 0 1
117035: PPUSH
117036: CALL_OW 74
117040: PPUSH
117041: CALL_OW 115
// until IsDead ( un ) ;
117045: LD_VAR 0 1
117049: PPUSH
117050: CALL_OW 301
117054: IFFALSE 117002
// end ;
117056: PPOPN 1
117058: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
117059: LD_EXP 159
117063: PUSH
117064: LD_EXP 199
117068: AND
117069: IFFALSE 117081
117071: GO 117073
117073: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
117074: LD_STRING earthquake(getX(game), 0, 32)
117076: PPUSH
117077: CALL_OW 559
117081: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
117082: LD_EXP 159
117086: PUSH
117087: LD_EXP 200
117091: AND
117092: IFFALSE 117183
117094: GO 117096
117096: DISABLE
117097: LD_INT 0
117099: PPUSH
// begin enable ;
117100: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
117101: LD_ADDR_VAR 0 1
117105: PUSH
117106: LD_INT 22
117108: PUSH
117109: LD_OWVAR 2
117113: PUSH
117114: EMPTY
117115: LIST
117116: LIST
117117: PUSH
117118: LD_INT 21
117120: PUSH
117121: LD_INT 2
117123: PUSH
117124: EMPTY
117125: LIST
117126: LIST
117127: PUSH
117128: LD_INT 33
117130: PUSH
117131: LD_INT 3
117133: PUSH
117134: EMPTY
117135: LIST
117136: LIST
117137: PUSH
117138: EMPTY
117139: LIST
117140: LIST
117141: LIST
117142: PPUSH
117143: CALL_OW 69
117147: ST_TO_ADDR
// if not tmp then
117148: LD_VAR 0 1
117152: NOT
117153: IFFALSE 117157
// exit ;
117155: GO 117183
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117157: LD_VAR 0 1
117161: PUSH
117162: LD_INT 1
117164: PPUSH
117165: LD_VAR 0 1
117169: PPUSH
117170: CALL_OW 12
117174: ARRAY
117175: PPUSH
117176: LD_INT 1
117178: PPUSH
117179: CALL_OW 234
// end ;
117183: PPOPN 1
117185: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
117186: LD_EXP 159
117190: PUSH
117191: LD_EXP 201
117195: AND
117196: IFFALSE 117337
117198: GO 117200
117200: DISABLE
117201: LD_INT 0
117203: PPUSH
117204: PPUSH
117205: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117206: LD_ADDR_VAR 0 3
117210: PUSH
117211: LD_INT 22
117213: PUSH
117214: LD_OWVAR 2
117218: PUSH
117219: EMPTY
117220: LIST
117221: LIST
117222: PUSH
117223: LD_INT 25
117225: PUSH
117226: LD_INT 1
117228: PUSH
117229: EMPTY
117230: LIST
117231: LIST
117232: PUSH
117233: EMPTY
117234: LIST
117235: LIST
117236: PPUSH
117237: CALL_OW 69
117241: ST_TO_ADDR
// if not tmp then
117242: LD_VAR 0 3
117246: NOT
117247: IFFALSE 117251
// exit ;
117249: GO 117337
// un := tmp [ rand ( 1 , tmp ) ] ;
117251: LD_ADDR_VAR 0 2
117255: PUSH
117256: LD_VAR 0 3
117260: PUSH
117261: LD_INT 1
117263: PPUSH
117264: LD_VAR 0 3
117268: PPUSH
117269: CALL_OW 12
117273: ARRAY
117274: ST_TO_ADDR
// if Crawls ( un ) then
117275: LD_VAR 0 2
117279: PPUSH
117280: CALL_OW 318
117284: IFFALSE 117295
// ComWalk ( un ) ;
117286: LD_VAR 0 2
117290: PPUSH
117291: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117295: LD_VAR 0 2
117299: PPUSH
117300: LD_INT 9
117302: PPUSH
117303: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117307: LD_INT 28
117309: PPUSH
117310: LD_OWVAR 2
117314: PPUSH
117315: LD_INT 2
117317: PPUSH
117318: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117322: LD_INT 29
117324: PPUSH
117325: LD_OWVAR 2
117329: PPUSH
117330: LD_INT 2
117332: PPUSH
117333: CALL_OW 322
// end ;
117337: PPOPN 3
117339: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117340: LD_EXP 159
117344: PUSH
117345: LD_EXP 202
117349: AND
117350: IFFALSE 117461
117352: GO 117354
117354: DISABLE
117355: LD_INT 0
117357: PPUSH
117358: PPUSH
117359: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117360: LD_ADDR_VAR 0 3
117364: PUSH
117365: LD_INT 22
117367: PUSH
117368: LD_OWVAR 2
117372: PUSH
117373: EMPTY
117374: LIST
117375: LIST
117376: PUSH
117377: LD_INT 25
117379: PUSH
117380: LD_INT 1
117382: PUSH
117383: EMPTY
117384: LIST
117385: LIST
117386: PUSH
117387: EMPTY
117388: LIST
117389: LIST
117390: PPUSH
117391: CALL_OW 69
117395: ST_TO_ADDR
// if not tmp then
117396: LD_VAR 0 3
117400: NOT
117401: IFFALSE 117405
// exit ;
117403: GO 117461
// un := tmp [ rand ( 1 , tmp ) ] ;
117405: LD_ADDR_VAR 0 2
117409: PUSH
117410: LD_VAR 0 3
117414: PUSH
117415: LD_INT 1
117417: PPUSH
117418: LD_VAR 0 3
117422: PPUSH
117423: CALL_OW 12
117427: ARRAY
117428: ST_TO_ADDR
// if Crawls ( un ) then
117429: LD_VAR 0 2
117433: PPUSH
117434: CALL_OW 318
117438: IFFALSE 117449
// ComWalk ( un ) ;
117440: LD_VAR 0 2
117444: PPUSH
117445: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117449: LD_VAR 0 2
117453: PPUSH
117454: LD_INT 8
117456: PPUSH
117457: CALL_OW 336
// end ;
117461: PPOPN 3
117463: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117464: LD_EXP 159
117468: PUSH
117469: LD_EXP 203
117473: AND
117474: IFFALSE 117618
117476: GO 117478
117478: DISABLE
117479: LD_INT 0
117481: PPUSH
117482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117483: LD_ADDR_VAR 0 2
117487: PUSH
117488: LD_INT 22
117490: PUSH
117491: LD_OWVAR 2
117495: PUSH
117496: EMPTY
117497: LIST
117498: LIST
117499: PUSH
117500: LD_INT 21
117502: PUSH
117503: LD_INT 2
117505: PUSH
117506: EMPTY
117507: LIST
117508: LIST
117509: PUSH
117510: LD_INT 2
117512: PUSH
117513: LD_INT 34
117515: PUSH
117516: LD_INT 12
117518: PUSH
117519: EMPTY
117520: LIST
117521: LIST
117522: PUSH
117523: LD_INT 34
117525: PUSH
117526: LD_INT 51
117528: PUSH
117529: EMPTY
117530: LIST
117531: LIST
117532: PUSH
117533: LD_INT 34
117535: PUSH
117536: LD_INT 32
117538: PUSH
117539: EMPTY
117540: LIST
117541: LIST
117542: PUSH
117543: EMPTY
117544: LIST
117545: LIST
117546: LIST
117547: LIST
117548: PUSH
117549: EMPTY
117550: LIST
117551: LIST
117552: LIST
117553: PPUSH
117554: CALL_OW 69
117558: ST_TO_ADDR
// if not tmp then
117559: LD_VAR 0 2
117563: NOT
117564: IFFALSE 117568
// exit ;
117566: GO 117618
// for i in tmp do
117568: LD_ADDR_VAR 0 1
117572: PUSH
117573: LD_VAR 0 2
117577: PUSH
117578: FOR_IN
117579: IFFALSE 117616
// if GetCargo ( i , mat_artifact ) = 0 then
117581: LD_VAR 0 1
117585: PPUSH
117586: LD_INT 4
117588: PPUSH
117589: CALL_OW 289
117593: PUSH
117594: LD_INT 0
117596: EQUAL
117597: IFFALSE 117614
// SetCargo ( i , mat_siberit , 100 ) ;
117599: LD_VAR 0 1
117603: PPUSH
117604: LD_INT 3
117606: PPUSH
117607: LD_INT 100
117609: PPUSH
117610: CALL_OW 290
117614: GO 117578
117616: POP
117617: POP
// end ;
117618: PPOPN 2
117620: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117621: LD_EXP 159
117625: PUSH
117626: LD_EXP 204
117630: AND
117631: IFFALSE 117814
117633: GO 117635
117635: DISABLE
117636: LD_INT 0
117638: PPUSH
117639: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117640: LD_ADDR_VAR 0 2
117644: PUSH
117645: LD_INT 22
117647: PUSH
117648: LD_OWVAR 2
117652: PUSH
117653: EMPTY
117654: LIST
117655: LIST
117656: PPUSH
117657: CALL_OW 69
117661: ST_TO_ADDR
// if not tmp then
117662: LD_VAR 0 2
117666: NOT
117667: IFFALSE 117671
// exit ;
117669: GO 117814
// for i := 1 to 2 do
117671: LD_ADDR_VAR 0 1
117675: PUSH
117676: DOUBLE
117677: LD_INT 1
117679: DEC
117680: ST_TO_ADDR
117681: LD_INT 2
117683: PUSH
117684: FOR_TO
117685: IFFALSE 117812
// begin uc_side := your_side ;
117687: LD_ADDR_OWVAR 20
117691: PUSH
117692: LD_OWVAR 2
117696: ST_TO_ADDR
// uc_nation := nation_american ;
117697: LD_ADDR_OWVAR 21
117701: PUSH
117702: LD_INT 1
117704: ST_TO_ADDR
// vc_chassis := us_morphling ;
117705: LD_ADDR_OWVAR 37
117709: PUSH
117710: LD_INT 5
117712: ST_TO_ADDR
// vc_engine := engine_siberite ;
117713: LD_ADDR_OWVAR 39
117717: PUSH
117718: LD_INT 3
117720: ST_TO_ADDR
// vc_control := control_computer ;
117721: LD_ADDR_OWVAR 38
117725: PUSH
117726: LD_INT 3
117728: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117729: LD_ADDR_OWVAR 40
117733: PUSH
117734: LD_INT 10
117736: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
117737: LD_VAR 0 2
117741: PUSH
117742: LD_INT 1
117744: ARRAY
117745: PPUSH
117746: CALL_OW 310
117750: NOT
117751: IFFALSE 117798
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
117753: CALL_OW 45
117757: PPUSH
117758: LD_VAR 0 2
117762: PUSH
117763: LD_INT 1
117765: ARRAY
117766: PPUSH
117767: CALL_OW 250
117771: PPUSH
117772: LD_VAR 0 2
117776: PUSH
117777: LD_INT 1
117779: ARRAY
117780: PPUSH
117781: CALL_OW 251
117785: PPUSH
117786: LD_INT 12
117788: PPUSH
117789: LD_INT 1
117791: PPUSH
117792: CALL_OW 50
117796: GO 117810
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
117798: CALL_OW 45
117802: PPUSH
117803: LD_INT 1
117805: PPUSH
117806: CALL_OW 51
// end ;
117810: GO 117684
117812: POP
117813: POP
// end ;
117814: PPOPN 2
117816: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117817: LD_EXP 159
117821: PUSH
117822: LD_EXP 205
117826: AND
117827: IFFALSE 118049
117829: GO 117831
117831: DISABLE
117832: LD_INT 0
117834: PPUSH
117835: PPUSH
117836: PPUSH
117837: PPUSH
117838: PPUSH
117839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117840: LD_ADDR_VAR 0 6
117844: PUSH
117845: LD_INT 22
117847: PUSH
117848: LD_OWVAR 2
117852: PUSH
117853: EMPTY
117854: LIST
117855: LIST
117856: PUSH
117857: LD_INT 21
117859: PUSH
117860: LD_INT 1
117862: PUSH
117863: EMPTY
117864: LIST
117865: LIST
117866: PUSH
117867: LD_INT 3
117869: PUSH
117870: LD_INT 23
117872: PUSH
117873: LD_INT 0
117875: PUSH
117876: EMPTY
117877: LIST
117878: LIST
117879: PUSH
117880: EMPTY
117881: LIST
117882: LIST
117883: PUSH
117884: EMPTY
117885: LIST
117886: LIST
117887: LIST
117888: PPUSH
117889: CALL_OW 69
117893: ST_TO_ADDR
// if not tmp then
117894: LD_VAR 0 6
117898: NOT
117899: IFFALSE 117903
// exit ;
117901: GO 118049
// s1 := rand ( 1 , 4 ) ;
117903: LD_ADDR_VAR 0 2
117907: PUSH
117908: LD_INT 1
117910: PPUSH
117911: LD_INT 4
117913: PPUSH
117914: CALL_OW 12
117918: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117919: LD_ADDR_VAR 0 4
117923: PUSH
117924: LD_VAR 0 6
117928: PUSH
117929: LD_INT 1
117931: ARRAY
117932: PPUSH
117933: LD_VAR 0 2
117937: PPUSH
117938: CALL_OW 259
117942: ST_TO_ADDR
// if s1 = 1 then
117943: LD_VAR 0 2
117947: PUSH
117948: LD_INT 1
117950: EQUAL
117951: IFFALSE 117971
// s2 := rand ( 2 , 4 ) else
117953: LD_ADDR_VAR 0 3
117957: PUSH
117958: LD_INT 2
117960: PPUSH
117961: LD_INT 4
117963: PPUSH
117964: CALL_OW 12
117968: ST_TO_ADDR
117969: GO 117979
// s2 := 1 ;
117971: LD_ADDR_VAR 0 3
117975: PUSH
117976: LD_INT 1
117978: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117979: LD_ADDR_VAR 0 5
117983: PUSH
117984: LD_VAR 0 6
117988: PUSH
117989: LD_INT 1
117991: ARRAY
117992: PPUSH
117993: LD_VAR 0 3
117997: PPUSH
117998: CALL_OW 259
118002: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
118003: LD_VAR 0 6
118007: PUSH
118008: LD_INT 1
118010: ARRAY
118011: PPUSH
118012: LD_VAR 0 2
118016: PPUSH
118017: LD_VAR 0 5
118021: PPUSH
118022: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
118026: LD_VAR 0 6
118030: PUSH
118031: LD_INT 1
118033: ARRAY
118034: PPUSH
118035: LD_VAR 0 3
118039: PPUSH
118040: LD_VAR 0 4
118044: PPUSH
118045: CALL_OW 237
// end ;
118049: PPOPN 6
118051: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
118052: LD_EXP 159
118056: PUSH
118057: LD_EXP 206
118061: AND
118062: IFFALSE 118141
118064: GO 118066
118066: DISABLE
118067: LD_INT 0
118069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
118070: LD_ADDR_VAR 0 1
118074: PUSH
118075: LD_INT 22
118077: PUSH
118078: LD_OWVAR 2
118082: PUSH
118083: EMPTY
118084: LIST
118085: LIST
118086: PUSH
118087: LD_INT 30
118089: PUSH
118090: LD_INT 3
118092: PUSH
118093: EMPTY
118094: LIST
118095: LIST
118096: PUSH
118097: EMPTY
118098: LIST
118099: LIST
118100: PPUSH
118101: CALL_OW 69
118105: ST_TO_ADDR
// if not tmp then
118106: LD_VAR 0 1
118110: NOT
118111: IFFALSE 118115
// exit ;
118113: GO 118141
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118115: LD_VAR 0 1
118119: PUSH
118120: LD_INT 1
118122: PPUSH
118123: LD_VAR 0 1
118127: PPUSH
118128: CALL_OW 12
118132: ARRAY
118133: PPUSH
118134: LD_INT 1
118136: PPUSH
118137: CALL_OW 234
// end ;
118141: PPOPN 1
118143: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
118144: LD_EXP 159
118148: PUSH
118149: LD_EXP 207
118153: AND
118154: IFFALSE 118266
118156: GO 118158
118158: DISABLE
118159: LD_INT 0
118161: PPUSH
118162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
118163: LD_ADDR_VAR 0 2
118167: PUSH
118168: LD_INT 22
118170: PUSH
118171: LD_OWVAR 2
118175: PUSH
118176: EMPTY
118177: LIST
118178: LIST
118179: PUSH
118180: LD_INT 2
118182: PUSH
118183: LD_INT 30
118185: PUSH
118186: LD_INT 27
118188: PUSH
118189: EMPTY
118190: LIST
118191: LIST
118192: PUSH
118193: LD_INT 30
118195: PUSH
118196: LD_INT 26
118198: PUSH
118199: EMPTY
118200: LIST
118201: LIST
118202: PUSH
118203: LD_INT 30
118205: PUSH
118206: LD_INT 28
118208: PUSH
118209: EMPTY
118210: LIST
118211: LIST
118212: PUSH
118213: EMPTY
118214: LIST
118215: LIST
118216: LIST
118217: LIST
118218: PUSH
118219: EMPTY
118220: LIST
118221: LIST
118222: PPUSH
118223: CALL_OW 69
118227: ST_TO_ADDR
// if not tmp then
118228: LD_VAR 0 2
118232: NOT
118233: IFFALSE 118237
// exit ;
118235: GO 118266
// for i in tmp do
118237: LD_ADDR_VAR 0 1
118241: PUSH
118242: LD_VAR 0 2
118246: PUSH
118247: FOR_IN
118248: IFFALSE 118264
// SetLives ( i , 1 ) ;
118250: LD_VAR 0 1
118254: PPUSH
118255: LD_INT 1
118257: PPUSH
118258: CALL_OW 234
118262: GO 118247
118264: POP
118265: POP
// end ;
118266: PPOPN 2
118268: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118269: LD_EXP 159
118273: PUSH
118274: LD_EXP 208
118278: AND
118279: IFFALSE 118566
118281: GO 118283
118283: DISABLE
118284: LD_INT 0
118286: PPUSH
118287: PPUSH
118288: PPUSH
// begin i := rand ( 1 , 7 ) ;
118289: LD_ADDR_VAR 0 1
118293: PUSH
118294: LD_INT 1
118296: PPUSH
118297: LD_INT 7
118299: PPUSH
118300: CALL_OW 12
118304: ST_TO_ADDR
// case i of 1 :
118305: LD_VAR 0 1
118309: PUSH
118310: LD_INT 1
118312: DOUBLE
118313: EQUAL
118314: IFTRUE 118318
118316: GO 118328
118318: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118319: LD_STRING earthquake(getX(game), 0, 32)
118321: PPUSH
118322: CALL_OW 559
118326: GO 118566
118328: LD_INT 2
118330: DOUBLE
118331: EQUAL
118332: IFTRUE 118336
118334: GO 118350
118336: POP
// begin ToLua ( displayStucuk(); ) ;
118337: LD_STRING displayStucuk();
118339: PPUSH
118340: CALL_OW 559
// ResetFog ;
118344: CALL_OW 335
// end ; 3 :
118348: GO 118566
118350: LD_INT 3
118352: DOUBLE
118353: EQUAL
118354: IFTRUE 118358
118356: GO 118462
118358: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118359: LD_ADDR_VAR 0 2
118363: PUSH
118364: LD_INT 22
118366: PUSH
118367: LD_OWVAR 2
118371: PUSH
118372: EMPTY
118373: LIST
118374: LIST
118375: PUSH
118376: LD_INT 25
118378: PUSH
118379: LD_INT 1
118381: PUSH
118382: EMPTY
118383: LIST
118384: LIST
118385: PUSH
118386: EMPTY
118387: LIST
118388: LIST
118389: PPUSH
118390: CALL_OW 69
118394: ST_TO_ADDR
// if not tmp then
118395: LD_VAR 0 2
118399: NOT
118400: IFFALSE 118404
// exit ;
118402: GO 118566
// un := tmp [ rand ( 1 , tmp ) ] ;
118404: LD_ADDR_VAR 0 3
118408: PUSH
118409: LD_VAR 0 2
118413: PUSH
118414: LD_INT 1
118416: PPUSH
118417: LD_VAR 0 2
118421: PPUSH
118422: CALL_OW 12
118426: ARRAY
118427: ST_TO_ADDR
// if Crawls ( un ) then
118428: LD_VAR 0 3
118432: PPUSH
118433: CALL_OW 318
118437: IFFALSE 118448
// ComWalk ( un ) ;
118439: LD_VAR 0 3
118443: PPUSH
118444: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118448: LD_VAR 0 3
118452: PPUSH
118453: LD_INT 8
118455: PPUSH
118456: CALL_OW 336
// end ; 4 :
118460: GO 118566
118462: LD_INT 4
118464: DOUBLE
118465: EQUAL
118466: IFTRUE 118470
118468: GO 118544
118470: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118471: LD_ADDR_VAR 0 2
118475: PUSH
118476: LD_INT 22
118478: PUSH
118479: LD_OWVAR 2
118483: PUSH
118484: EMPTY
118485: LIST
118486: LIST
118487: PUSH
118488: LD_INT 30
118490: PUSH
118491: LD_INT 29
118493: PUSH
118494: EMPTY
118495: LIST
118496: LIST
118497: PUSH
118498: EMPTY
118499: LIST
118500: LIST
118501: PPUSH
118502: CALL_OW 69
118506: ST_TO_ADDR
// if not tmp then
118507: LD_VAR 0 2
118511: NOT
118512: IFFALSE 118516
// exit ;
118514: GO 118566
// CenterNowOnUnits ( tmp [ 1 ] ) ;
118516: LD_VAR 0 2
118520: PUSH
118521: LD_INT 1
118523: ARRAY
118524: PPUSH
118525: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
118529: LD_VAR 0 2
118533: PUSH
118534: LD_INT 1
118536: ARRAY
118537: PPUSH
118538: CALL_OW 65
// end ; 5 .. 7 :
118542: GO 118566
118544: LD_INT 5
118546: DOUBLE
118547: GREATEREQUAL
118548: IFFALSE 118556
118550: LD_INT 7
118552: DOUBLE
118553: LESSEQUAL
118554: IFTRUE 118558
118556: GO 118565
118558: POP
// StreamSibBomb ; end ;
118559: CALL 114803 0 0
118563: GO 118566
118565: POP
// end ;
118566: PPOPN 3
118568: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118569: LD_EXP 159
118573: PUSH
118574: LD_EXP 209
118578: AND
118579: IFFALSE 118735
118581: GO 118583
118583: DISABLE
118584: LD_INT 0
118586: PPUSH
118587: PPUSH
118588: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118589: LD_ADDR_VAR 0 2
118593: PUSH
118594: LD_INT 81
118596: PUSH
118597: LD_OWVAR 2
118601: PUSH
118602: EMPTY
118603: LIST
118604: LIST
118605: PUSH
118606: LD_INT 2
118608: PUSH
118609: LD_INT 21
118611: PUSH
118612: LD_INT 1
118614: PUSH
118615: EMPTY
118616: LIST
118617: LIST
118618: PUSH
118619: LD_INT 21
118621: PUSH
118622: LD_INT 2
118624: PUSH
118625: EMPTY
118626: LIST
118627: LIST
118628: PUSH
118629: EMPTY
118630: LIST
118631: LIST
118632: LIST
118633: PUSH
118634: EMPTY
118635: LIST
118636: LIST
118637: PPUSH
118638: CALL_OW 69
118642: ST_TO_ADDR
// if not tmp then
118643: LD_VAR 0 2
118647: NOT
118648: IFFALSE 118652
// exit ;
118650: GO 118735
// p := 0 ;
118652: LD_ADDR_VAR 0 3
118656: PUSH
118657: LD_INT 0
118659: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118660: LD_INT 35
118662: PPUSH
118663: CALL_OW 67
// p := p + 1 ;
118667: LD_ADDR_VAR 0 3
118671: PUSH
118672: LD_VAR 0 3
118676: PUSH
118677: LD_INT 1
118679: PLUS
118680: ST_TO_ADDR
// for i in tmp do
118681: LD_ADDR_VAR 0 1
118685: PUSH
118686: LD_VAR 0 2
118690: PUSH
118691: FOR_IN
118692: IFFALSE 118723
// if GetLives ( i ) < 1000 then
118694: LD_VAR 0 1
118698: PPUSH
118699: CALL_OW 256
118703: PUSH
118704: LD_INT 1000
118706: LESS
118707: IFFALSE 118721
// SetLives ( i , 1000 ) ;
118709: LD_VAR 0 1
118713: PPUSH
118714: LD_INT 1000
118716: PPUSH
118717: CALL_OW 234
118721: GO 118691
118723: POP
118724: POP
// until p > 20 ;
118725: LD_VAR 0 3
118729: PUSH
118730: LD_INT 20
118732: GREATER
118733: IFFALSE 118660
// end ;
118735: PPOPN 3
118737: END
// every 0 0$1 trigger StreamModeActive and sTime do
118738: LD_EXP 159
118742: PUSH
118743: LD_EXP 210
118747: AND
118748: IFFALSE 118783
118750: GO 118752
118752: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118753: LD_INT 28
118755: PPUSH
118756: LD_OWVAR 2
118760: PPUSH
118761: LD_INT 2
118763: PPUSH
118764: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118768: LD_INT 30
118770: PPUSH
118771: LD_OWVAR 2
118775: PPUSH
118776: LD_INT 2
118778: PPUSH
118779: CALL_OW 322
// end ;
118783: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118784: LD_EXP 159
118788: PUSH
118789: LD_EXP 211
118793: AND
118794: IFFALSE 118915
118796: GO 118798
118798: DISABLE
118799: LD_INT 0
118801: PPUSH
118802: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118803: LD_ADDR_VAR 0 2
118807: PUSH
118808: LD_INT 22
118810: PUSH
118811: LD_OWVAR 2
118815: PUSH
118816: EMPTY
118817: LIST
118818: LIST
118819: PUSH
118820: LD_INT 21
118822: PUSH
118823: LD_INT 1
118825: PUSH
118826: EMPTY
118827: LIST
118828: LIST
118829: PUSH
118830: LD_INT 3
118832: PUSH
118833: LD_INT 23
118835: PUSH
118836: LD_INT 0
118838: PUSH
118839: EMPTY
118840: LIST
118841: LIST
118842: PUSH
118843: EMPTY
118844: LIST
118845: LIST
118846: PUSH
118847: EMPTY
118848: LIST
118849: LIST
118850: LIST
118851: PPUSH
118852: CALL_OW 69
118856: ST_TO_ADDR
// if not tmp then
118857: LD_VAR 0 2
118861: NOT
118862: IFFALSE 118866
// exit ;
118864: GO 118915
// for i in tmp do
118866: LD_ADDR_VAR 0 1
118870: PUSH
118871: LD_VAR 0 2
118875: PUSH
118876: FOR_IN
118877: IFFALSE 118913
// begin if Crawls ( i ) then
118879: LD_VAR 0 1
118883: PPUSH
118884: CALL_OW 318
118888: IFFALSE 118899
// ComWalk ( i ) ;
118890: LD_VAR 0 1
118894: PPUSH
118895: CALL_OW 138
// SetClass ( i , 2 ) ;
118899: LD_VAR 0 1
118903: PPUSH
118904: LD_INT 2
118906: PPUSH
118907: CALL_OW 336
// end ;
118911: GO 118876
118913: POP
118914: POP
// end ;
118915: PPOPN 2
118917: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118918: LD_EXP 159
118922: PUSH
118923: LD_EXP 212
118927: AND
118928: IFFALSE 119216
118930: GO 118932
118932: DISABLE
118933: LD_INT 0
118935: PPUSH
118936: PPUSH
118937: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118938: LD_OWVAR 2
118942: PPUSH
118943: LD_INT 9
118945: PPUSH
118946: LD_INT 1
118948: PPUSH
118949: LD_INT 1
118951: PPUSH
118952: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118956: LD_INT 9
118958: PPUSH
118959: LD_OWVAR 2
118963: PPUSH
118964: CALL_OW 343
// uc_side := 9 ;
118968: LD_ADDR_OWVAR 20
118972: PUSH
118973: LD_INT 9
118975: ST_TO_ADDR
// uc_nation := 2 ;
118976: LD_ADDR_OWVAR 21
118980: PUSH
118981: LD_INT 2
118983: ST_TO_ADDR
// hc_name := Dark Warrior ;
118984: LD_ADDR_OWVAR 26
118988: PUSH
118989: LD_STRING Dark Warrior
118991: ST_TO_ADDR
// hc_gallery :=  ;
118992: LD_ADDR_OWVAR 33
118996: PUSH
118997: LD_STRING 
118999: ST_TO_ADDR
// hc_noskilllimit := true ;
119000: LD_ADDR_OWVAR 76
119004: PUSH
119005: LD_INT 1
119007: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
119008: LD_ADDR_OWVAR 31
119012: PUSH
119013: LD_INT 30
119015: PUSH
119016: LD_INT 30
119018: PUSH
119019: LD_INT 30
119021: PUSH
119022: LD_INT 30
119024: PUSH
119025: EMPTY
119026: LIST
119027: LIST
119028: LIST
119029: LIST
119030: ST_TO_ADDR
// un := CreateHuman ;
119031: LD_ADDR_VAR 0 3
119035: PUSH
119036: CALL_OW 44
119040: ST_TO_ADDR
// hc_noskilllimit := false ;
119041: LD_ADDR_OWVAR 76
119045: PUSH
119046: LD_INT 0
119048: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119049: LD_VAR 0 3
119053: PPUSH
119054: LD_INT 1
119056: PPUSH
119057: CALL_OW 51
// ToLua ( playRanger() ) ;
119061: LD_STRING playRanger()
119063: PPUSH
119064: CALL_OW 559
// p := 0 ;
119068: LD_ADDR_VAR 0 2
119072: PUSH
119073: LD_INT 0
119075: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
119076: LD_INT 35
119078: PPUSH
119079: CALL_OW 67
// p := p + 1 ;
119083: LD_ADDR_VAR 0 2
119087: PUSH
119088: LD_VAR 0 2
119092: PUSH
119093: LD_INT 1
119095: PLUS
119096: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
119097: LD_VAR 0 3
119101: PPUSH
119102: CALL_OW 256
119106: PUSH
119107: LD_INT 1000
119109: LESS
119110: IFFALSE 119124
// SetLives ( un , 1000 ) ;
119112: LD_VAR 0 3
119116: PPUSH
119117: LD_INT 1000
119119: PPUSH
119120: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
119124: LD_VAR 0 3
119128: PPUSH
119129: LD_INT 81
119131: PUSH
119132: LD_OWVAR 2
119136: PUSH
119137: EMPTY
119138: LIST
119139: LIST
119140: PUSH
119141: LD_INT 91
119143: PUSH
119144: LD_VAR 0 3
119148: PUSH
119149: LD_INT 30
119151: PUSH
119152: EMPTY
119153: LIST
119154: LIST
119155: LIST
119156: PUSH
119157: EMPTY
119158: LIST
119159: LIST
119160: PPUSH
119161: CALL_OW 69
119165: PPUSH
119166: LD_VAR 0 3
119170: PPUSH
119171: CALL_OW 74
119175: PPUSH
119176: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
119180: LD_VAR 0 2
119184: PUSH
119185: LD_INT 80
119187: GREATER
119188: PUSH
119189: LD_VAR 0 3
119193: PPUSH
119194: CALL_OW 301
119198: OR
119199: IFFALSE 119076
// if un then
119201: LD_VAR 0 3
119205: IFFALSE 119216
// RemoveUnit ( un ) ;
119207: LD_VAR 0 3
119211: PPUSH
119212: CALL_OW 64
// end ;
119216: PPOPN 3
119218: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
119219: LD_EXP 213
119223: IFFALSE 119339
119225: GO 119227
119227: DISABLE
119228: LD_INT 0
119230: PPUSH
119231: PPUSH
119232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119233: LD_ADDR_VAR 0 2
119237: PUSH
119238: LD_INT 81
119240: PUSH
119241: LD_OWVAR 2
119245: PUSH
119246: EMPTY
119247: LIST
119248: LIST
119249: PUSH
119250: LD_INT 21
119252: PUSH
119253: LD_INT 1
119255: PUSH
119256: EMPTY
119257: LIST
119258: LIST
119259: PUSH
119260: EMPTY
119261: LIST
119262: LIST
119263: PPUSH
119264: CALL_OW 69
119268: ST_TO_ADDR
// ToLua ( playComputer() ) ;
119269: LD_STRING playComputer()
119271: PPUSH
119272: CALL_OW 559
// if not tmp then
119276: LD_VAR 0 2
119280: NOT
119281: IFFALSE 119285
// exit ;
119283: GO 119339
// for i in tmp do
119285: LD_ADDR_VAR 0 1
119289: PUSH
119290: LD_VAR 0 2
119294: PUSH
119295: FOR_IN
119296: IFFALSE 119337
// for j := 1 to 4 do
119298: LD_ADDR_VAR 0 3
119302: PUSH
119303: DOUBLE
119304: LD_INT 1
119306: DEC
119307: ST_TO_ADDR
119308: LD_INT 4
119310: PUSH
119311: FOR_TO
119312: IFFALSE 119333
// SetSkill ( i , j , 10 ) ;
119314: LD_VAR 0 1
119318: PPUSH
119319: LD_VAR 0 3
119323: PPUSH
119324: LD_INT 10
119326: PPUSH
119327: CALL_OW 237
119331: GO 119311
119333: POP
119334: POP
119335: GO 119295
119337: POP
119338: POP
// end ;
119339: PPOPN 3
119341: END
// every 0 0$1 trigger s30 do var i , tmp ;
119342: LD_EXP 214
119346: IFFALSE 119415
119348: GO 119350
119350: DISABLE
119351: LD_INT 0
119353: PPUSH
119354: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119355: LD_ADDR_VAR 0 2
119359: PUSH
119360: LD_INT 22
119362: PUSH
119363: LD_OWVAR 2
119367: PUSH
119368: EMPTY
119369: LIST
119370: LIST
119371: PPUSH
119372: CALL_OW 69
119376: ST_TO_ADDR
// if not tmp then
119377: LD_VAR 0 2
119381: NOT
119382: IFFALSE 119386
// exit ;
119384: GO 119415
// for i in tmp do
119386: LD_ADDR_VAR 0 1
119390: PUSH
119391: LD_VAR 0 2
119395: PUSH
119396: FOR_IN
119397: IFFALSE 119413
// SetLives ( i , 300 ) ;
119399: LD_VAR 0 1
119403: PPUSH
119404: LD_INT 300
119406: PPUSH
119407: CALL_OW 234
119411: GO 119396
119413: POP
119414: POP
// end ;
119415: PPOPN 2
119417: END
// every 0 0$1 trigger s60 do var i , tmp ;
119418: LD_EXP 215
119422: IFFALSE 119491
119424: GO 119426
119426: DISABLE
119427: LD_INT 0
119429: PPUSH
119430: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119431: LD_ADDR_VAR 0 2
119435: PUSH
119436: LD_INT 22
119438: PUSH
119439: LD_OWVAR 2
119443: PUSH
119444: EMPTY
119445: LIST
119446: LIST
119447: PPUSH
119448: CALL_OW 69
119452: ST_TO_ADDR
// if not tmp then
119453: LD_VAR 0 2
119457: NOT
119458: IFFALSE 119462
// exit ;
119460: GO 119491
// for i in tmp do
119462: LD_ADDR_VAR 0 1
119466: PUSH
119467: LD_VAR 0 2
119471: PUSH
119472: FOR_IN
119473: IFFALSE 119489
// SetLives ( i , 600 ) ;
119475: LD_VAR 0 1
119479: PPUSH
119480: LD_INT 600
119482: PPUSH
119483: CALL_OW 234
119487: GO 119472
119489: POP
119490: POP
// end ;
119491: PPOPN 2
119493: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
119494: LD_INT 0
119496: PPUSH
// case cmd of 301 :
119497: LD_VAR 0 1
119501: PUSH
119502: LD_INT 301
119504: DOUBLE
119505: EQUAL
119506: IFTRUE 119510
119508: GO 119542
119510: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
119511: LD_VAR 0 6
119515: PPUSH
119516: LD_VAR 0 7
119520: PPUSH
119521: LD_VAR 0 8
119525: PPUSH
119526: LD_VAR 0 4
119530: PPUSH
119531: LD_VAR 0 5
119535: PPUSH
119536: CALL 120743 0 5
119540: GO 119663
119542: LD_INT 302
119544: DOUBLE
119545: EQUAL
119546: IFTRUE 119550
119548: GO 119587
119550: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
119551: LD_VAR 0 6
119555: PPUSH
119556: LD_VAR 0 7
119560: PPUSH
119561: LD_VAR 0 8
119565: PPUSH
119566: LD_VAR 0 9
119570: PPUSH
119571: LD_VAR 0 4
119575: PPUSH
119576: LD_VAR 0 5
119580: PPUSH
119581: CALL 120834 0 6
119585: GO 119663
119587: LD_INT 303
119589: DOUBLE
119590: EQUAL
119591: IFTRUE 119595
119593: GO 119632
119595: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
119596: LD_VAR 0 6
119600: PPUSH
119601: LD_VAR 0 7
119605: PPUSH
119606: LD_VAR 0 8
119610: PPUSH
119611: LD_VAR 0 9
119615: PPUSH
119616: LD_VAR 0 4
119620: PPUSH
119621: LD_VAR 0 5
119625: PPUSH
119626: CALL 119668 0 6
119630: GO 119663
119632: LD_INT 304
119634: DOUBLE
119635: EQUAL
119636: IFTRUE 119640
119638: GO 119662
119640: POP
// hHackTeleport ( unit , x , y ) ; end ;
119641: LD_VAR 0 2
119645: PPUSH
119646: LD_VAR 0 4
119650: PPUSH
119651: LD_VAR 0 5
119655: PPUSH
119656: CALL 121427 0 3
119660: GO 119663
119662: POP
// end ;
119663: LD_VAR 0 12
119667: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
119668: LD_INT 0
119670: PPUSH
119671: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
119672: LD_VAR 0 1
119676: PUSH
119677: LD_INT 1
119679: LESS
119680: PUSH
119681: LD_VAR 0 1
119685: PUSH
119686: LD_INT 3
119688: GREATER
119689: OR
119690: PUSH
119691: LD_VAR 0 5
119695: PPUSH
119696: LD_VAR 0 6
119700: PPUSH
119701: CALL_OW 428
119705: OR
119706: IFFALSE 119710
// exit ;
119708: GO 120430
// uc_side := your_side ;
119710: LD_ADDR_OWVAR 20
119714: PUSH
119715: LD_OWVAR 2
119719: ST_TO_ADDR
// uc_nation := nation ;
119720: LD_ADDR_OWVAR 21
119724: PUSH
119725: LD_VAR 0 1
119729: ST_TO_ADDR
// bc_level = 1 ;
119730: LD_ADDR_OWVAR 43
119734: PUSH
119735: LD_INT 1
119737: ST_TO_ADDR
// case btype of 1 :
119738: LD_VAR 0 2
119742: PUSH
119743: LD_INT 1
119745: DOUBLE
119746: EQUAL
119747: IFTRUE 119751
119749: GO 119762
119751: POP
// bc_type := b_depot ; 2 :
119752: LD_ADDR_OWVAR 42
119756: PUSH
119757: LD_INT 0
119759: ST_TO_ADDR
119760: GO 120374
119762: LD_INT 2
119764: DOUBLE
119765: EQUAL
119766: IFTRUE 119770
119768: GO 119781
119770: POP
// bc_type := b_warehouse ; 3 :
119771: LD_ADDR_OWVAR 42
119775: PUSH
119776: LD_INT 1
119778: ST_TO_ADDR
119779: GO 120374
119781: LD_INT 3
119783: DOUBLE
119784: EQUAL
119785: IFTRUE 119789
119787: GO 119800
119789: POP
// bc_type := b_lab ; 4 .. 9 :
119790: LD_ADDR_OWVAR 42
119794: PUSH
119795: LD_INT 6
119797: ST_TO_ADDR
119798: GO 120374
119800: LD_INT 4
119802: DOUBLE
119803: GREATEREQUAL
119804: IFFALSE 119812
119806: LD_INT 9
119808: DOUBLE
119809: LESSEQUAL
119810: IFTRUE 119814
119812: GO 119866
119814: POP
// begin bc_type := b_lab_half ;
119815: LD_ADDR_OWVAR 42
119819: PUSH
119820: LD_INT 7
119822: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
119823: LD_ADDR_OWVAR 44
119827: PUSH
119828: LD_INT 10
119830: PUSH
119831: LD_INT 11
119833: PUSH
119834: LD_INT 12
119836: PUSH
119837: LD_INT 15
119839: PUSH
119840: LD_INT 14
119842: PUSH
119843: LD_INT 13
119845: PUSH
119846: EMPTY
119847: LIST
119848: LIST
119849: LIST
119850: LIST
119851: LIST
119852: LIST
119853: PUSH
119854: LD_VAR 0 2
119858: PUSH
119859: LD_INT 3
119861: MINUS
119862: ARRAY
119863: ST_TO_ADDR
// end ; 10 .. 13 :
119864: GO 120374
119866: LD_INT 10
119868: DOUBLE
119869: GREATEREQUAL
119870: IFFALSE 119878
119872: LD_INT 13
119874: DOUBLE
119875: LESSEQUAL
119876: IFTRUE 119880
119878: GO 119957
119880: POP
// begin bc_type := b_lab_full ;
119881: LD_ADDR_OWVAR 42
119885: PUSH
119886: LD_INT 8
119888: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
119889: LD_ADDR_OWVAR 44
119893: PUSH
119894: LD_INT 10
119896: PUSH
119897: LD_INT 12
119899: PUSH
119900: LD_INT 14
119902: PUSH
119903: LD_INT 13
119905: PUSH
119906: EMPTY
119907: LIST
119908: LIST
119909: LIST
119910: LIST
119911: PUSH
119912: LD_VAR 0 2
119916: PUSH
119917: LD_INT 9
119919: MINUS
119920: ARRAY
119921: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
119922: LD_ADDR_OWVAR 45
119926: PUSH
119927: LD_INT 11
119929: PUSH
119930: LD_INT 15
119932: PUSH
119933: LD_INT 12
119935: PUSH
119936: LD_INT 15
119938: PUSH
119939: EMPTY
119940: LIST
119941: LIST
119942: LIST
119943: LIST
119944: PUSH
119945: LD_VAR 0 2
119949: PUSH
119950: LD_INT 9
119952: MINUS
119953: ARRAY
119954: ST_TO_ADDR
// end ; 14 :
119955: GO 120374
119957: LD_INT 14
119959: DOUBLE
119960: EQUAL
119961: IFTRUE 119965
119963: GO 119976
119965: POP
// bc_type := b_workshop ; 15 :
119966: LD_ADDR_OWVAR 42
119970: PUSH
119971: LD_INT 2
119973: ST_TO_ADDR
119974: GO 120374
119976: LD_INT 15
119978: DOUBLE
119979: EQUAL
119980: IFTRUE 119984
119982: GO 119995
119984: POP
// bc_type := b_factory ; 16 :
119985: LD_ADDR_OWVAR 42
119989: PUSH
119990: LD_INT 3
119992: ST_TO_ADDR
119993: GO 120374
119995: LD_INT 16
119997: DOUBLE
119998: EQUAL
119999: IFTRUE 120003
120001: GO 120014
120003: POP
// bc_type := b_ext_gun ; 17 :
120004: LD_ADDR_OWVAR 42
120008: PUSH
120009: LD_INT 17
120011: ST_TO_ADDR
120012: GO 120374
120014: LD_INT 17
120016: DOUBLE
120017: EQUAL
120018: IFTRUE 120022
120020: GO 120050
120022: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
120023: LD_ADDR_OWVAR 42
120027: PUSH
120028: LD_INT 19
120030: PUSH
120031: LD_INT 23
120033: PUSH
120034: LD_INT 19
120036: PUSH
120037: EMPTY
120038: LIST
120039: LIST
120040: LIST
120041: PUSH
120042: LD_VAR 0 1
120046: ARRAY
120047: ST_TO_ADDR
120048: GO 120374
120050: LD_INT 18
120052: DOUBLE
120053: EQUAL
120054: IFTRUE 120058
120056: GO 120069
120058: POP
// bc_type := b_ext_radar ; 19 :
120059: LD_ADDR_OWVAR 42
120063: PUSH
120064: LD_INT 20
120066: ST_TO_ADDR
120067: GO 120374
120069: LD_INT 19
120071: DOUBLE
120072: EQUAL
120073: IFTRUE 120077
120075: GO 120088
120077: POP
// bc_type := b_ext_radio ; 20 :
120078: LD_ADDR_OWVAR 42
120082: PUSH
120083: LD_INT 22
120085: ST_TO_ADDR
120086: GO 120374
120088: LD_INT 20
120090: DOUBLE
120091: EQUAL
120092: IFTRUE 120096
120094: GO 120107
120096: POP
// bc_type := b_ext_siberium ; 21 :
120097: LD_ADDR_OWVAR 42
120101: PUSH
120102: LD_INT 21
120104: ST_TO_ADDR
120105: GO 120374
120107: LD_INT 21
120109: DOUBLE
120110: EQUAL
120111: IFTRUE 120115
120113: GO 120126
120115: POP
// bc_type := b_ext_computer ; 22 :
120116: LD_ADDR_OWVAR 42
120120: PUSH
120121: LD_INT 24
120123: ST_TO_ADDR
120124: GO 120374
120126: LD_INT 22
120128: DOUBLE
120129: EQUAL
120130: IFTRUE 120134
120132: GO 120145
120134: POP
// bc_type := b_ext_track ; 23 :
120135: LD_ADDR_OWVAR 42
120139: PUSH
120140: LD_INT 16
120142: ST_TO_ADDR
120143: GO 120374
120145: LD_INT 23
120147: DOUBLE
120148: EQUAL
120149: IFTRUE 120153
120151: GO 120164
120153: POP
// bc_type := b_ext_laser ; 24 :
120154: LD_ADDR_OWVAR 42
120158: PUSH
120159: LD_INT 25
120161: ST_TO_ADDR
120162: GO 120374
120164: LD_INT 24
120166: DOUBLE
120167: EQUAL
120168: IFTRUE 120172
120170: GO 120183
120172: POP
// bc_type := b_control_tower ; 25 :
120173: LD_ADDR_OWVAR 42
120177: PUSH
120178: LD_INT 36
120180: ST_TO_ADDR
120181: GO 120374
120183: LD_INT 25
120185: DOUBLE
120186: EQUAL
120187: IFTRUE 120191
120189: GO 120202
120191: POP
// bc_type := b_breastwork ; 26 :
120192: LD_ADDR_OWVAR 42
120196: PUSH
120197: LD_INT 31
120199: ST_TO_ADDR
120200: GO 120374
120202: LD_INT 26
120204: DOUBLE
120205: EQUAL
120206: IFTRUE 120210
120208: GO 120221
120210: POP
// bc_type := b_bunker ; 27 :
120211: LD_ADDR_OWVAR 42
120215: PUSH
120216: LD_INT 32
120218: ST_TO_ADDR
120219: GO 120374
120221: LD_INT 27
120223: DOUBLE
120224: EQUAL
120225: IFTRUE 120229
120227: GO 120240
120229: POP
// bc_type := b_turret ; 28 :
120230: LD_ADDR_OWVAR 42
120234: PUSH
120235: LD_INT 33
120237: ST_TO_ADDR
120238: GO 120374
120240: LD_INT 28
120242: DOUBLE
120243: EQUAL
120244: IFTRUE 120248
120246: GO 120259
120248: POP
// bc_type := b_armoury ; 29 :
120249: LD_ADDR_OWVAR 42
120253: PUSH
120254: LD_INT 4
120256: ST_TO_ADDR
120257: GO 120374
120259: LD_INT 29
120261: DOUBLE
120262: EQUAL
120263: IFTRUE 120267
120265: GO 120278
120267: POP
// bc_type := b_barracks ; 30 :
120268: LD_ADDR_OWVAR 42
120272: PUSH
120273: LD_INT 5
120275: ST_TO_ADDR
120276: GO 120374
120278: LD_INT 30
120280: DOUBLE
120281: EQUAL
120282: IFTRUE 120286
120284: GO 120297
120286: POP
// bc_type := b_solar_power ; 31 :
120287: LD_ADDR_OWVAR 42
120291: PUSH
120292: LD_INT 27
120294: ST_TO_ADDR
120295: GO 120374
120297: LD_INT 31
120299: DOUBLE
120300: EQUAL
120301: IFTRUE 120305
120303: GO 120316
120305: POP
// bc_type := b_oil_power ; 32 :
120306: LD_ADDR_OWVAR 42
120310: PUSH
120311: LD_INT 26
120313: ST_TO_ADDR
120314: GO 120374
120316: LD_INT 32
120318: DOUBLE
120319: EQUAL
120320: IFTRUE 120324
120322: GO 120335
120324: POP
// bc_type := b_siberite_power ; 33 :
120325: LD_ADDR_OWVAR 42
120329: PUSH
120330: LD_INT 28
120332: ST_TO_ADDR
120333: GO 120374
120335: LD_INT 33
120337: DOUBLE
120338: EQUAL
120339: IFTRUE 120343
120341: GO 120354
120343: POP
// bc_type := b_oil_mine ; 34 :
120344: LD_ADDR_OWVAR 42
120348: PUSH
120349: LD_INT 29
120351: ST_TO_ADDR
120352: GO 120374
120354: LD_INT 34
120356: DOUBLE
120357: EQUAL
120358: IFTRUE 120362
120360: GO 120373
120362: POP
// bc_type := b_siberite_mine ; end ;
120363: LD_ADDR_OWVAR 42
120367: PUSH
120368: LD_INT 30
120370: ST_TO_ADDR
120371: GO 120374
120373: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
120374: LD_ADDR_VAR 0 8
120378: PUSH
120379: LD_VAR 0 5
120383: PPUSH
120384: LD_VAR 0 6
120388: PPUSH
120389: LD_VAR 0 3
120393: PPUSH
120394: CALL_OW 47
120398: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
120399: LD_OWVAR 42
120403: PUSH
120404: LD_INT 32
120406: PUSH
120407: LD_INT 33
120409: PUSH
120410: EMPTY
120411: LIST
120412: LIST
120413: IN
120414: IFFALSE 120430
// PlaceWeaponTurret ( b , weapon ) ;
120416: LD_VAR 0 8
120420: PPUSH
120421: LD_VAR 0 4
120425: PPUSH
120426: CALL_OW 431
// end ;
120430: LD_VAR 0 7
120434: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
120435: LD_INT 0
120437: PPUSH
120438: PPUSH
120439: PPUSH
120440: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120441: LD_ADDR_VAR 0 4
120445: PUSH
120446: LD_INT 22
120448: PUSH
120449: LD_OWVAR 2
120453: PUSH
120454: EMPTY
120455: LIST
120456: LIST
120457: PUSH
120458: LD_INT 2
120460: PUSH
120461: LD_INT 30
120463: PUSH
120464: LD_INT 0
120466: PUSH
120467: EMPTY
120468: LIST
120469: LIST
120470: PUSH
120471: LD_INT 30
120473: PUSH
120474: LD_INT 1
120476: PUSH
120477: EMPTY
120478: LIST
120479: LIST
120480: PUSH
120481: EMPTY
120482: LIST
120483: LIST
120484: LIST
120485: PUSH
120486: EMPTY
120487: LIST
120488: LIST
120489: PPUSH
120490: CALL_OW 69
120494: ST_TO_ADDR
// if not tmp then
120495: LD_VAR 0 4
120499: NOT
120500: IFFALSE 120504
// exit ;
120502: GO 120563
// for i in tmp do
120504: LD_ADDR_VAR 0 2
120508: PUSH
120509: LD_VAR 0 4
120513: PUSH
120514: FOR_IN
120515: IFFALSE 120561
// for j = 1 to 3 do
120517: LD_ADDR_VAR 0 3
120521: PUSH
120522: DOUBLE
120523: LD_INT 1
120525: DEC
120526: ST_TO_ADDR
120527: LD_INT 3
120529: PUSH
120530: FOR_TO
120531: IFFALSE 120557
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
120533: LD_VAR 0 2
120537: PPUSH
120538: CALL_OW 274
120542: PPUSH
120543: LD_VAR 0 3
120547: PPUSH
120548: LD_INT 99999
120550: PPUSH
120551: CALL_OW 277
120555: GO 120530
120557: POP
120558: POP
120559: GO 120514
120561: POP
120562: POP
// end ;
120563: LD_VAR 0 1
120567: RET
// export function hHackSetLevel10 ; var i , j ; begin
120568: LD_INT 0
120570: PPUSH
120571: PPUSH
120572: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
120573: LD_ADDR_VAR 0 2
120577: PUSH
120578: LD_INT 21
120580: PUSH
120581: LD_INT 1
120583: PUSH
120584: EMPTY
120585: LIST
120586: LIST
120587: PPUSH
120588: CALL_OW 69
120592: PUSH
120593: FOR_IN
120594: IFFALSE 120646
// if IsSelected ( i ) then
120596: LD_VAR 0 2
120600: PPUSH
120601: CALL_OW 306
120605: IFFALSE 120644
// begin for j := 1 to 4 do
120607: LD_ADDR_VAR 0 3
120611: PUSH
120612: DOUBLE
120613: LD_INT 1
120615: DEC
120616: ST_TO_ADDR
120617: LD_INT 4
120619: PUSH
120620: FOR_TO
120621: IFFALSE 120642
// SetSkill ( i , j , 10 ) ;
120623: LD_VAR 0 2
120627: PPUSH
120628: LD_VAR 0 3
120632: PPUSH
120633: LD_INT 10
120635: PPUSH
120636: CALL_OW 237
120640: GO 120620
120642: POP
120643: POP
// end ;
120644: GO 120593
120646: POP
120647: POP
// end ;
120648: LD_VAR 0 1
120652: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
120653: LD_INT 0
120655: PPUSH
120656: PPUSH
120657: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
120658: LD_ADDR_VAR 0 2
120662: PUSH
120663: LD_INT 22
120665: PUSH
120666: LD_OWVAR 2
120670: PUSH
120671: EMPTY
120672: LIST
120673: LIST
120674: PUSH
120675: LD_INT 21
120677: PUSH
120678: LD_INT 1
120680: PUSH
120681: EMPTY
120682: LIST
120683: LIST
120684: PUSH
120685: EMPTY
120686: LIST
120687: LIST
120688: PPUSH
120689: CALL_OW 69
120693: PUSH
120694: FOR_IN
120695: IFFALSE 120736
// begin for j := 1 to 4 do
120697: LD_ADDR_VAR 0 3
120701: PUSH
120702: DOUBLE
120703: LD_INT 1
120705: DEC
120706: ST_TO_ADDR
120707: LD_INT 4
120709: PUSH
120710: FOR_TO
120711: IFFALSE 120732
// SetSkill ( i , j , 10 ) ;
120713: LD_VAR 0 2
120717: PPUSH
120718: LD_VAR 0 3
120722: PPUSH
120723: LD_INT 10
120725: PPUSH
120726: CALL_OW 237
120730: GO 120710
120732: POP
120733: POP
// end ;
120734: GO 120694
120736: POP
120737: POP
// end ;
120738: LD_VAR 0 1
120742: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
120743: LD_INT 0
120745: PPUSH
// uc_side := your_side ;
120746: LD_ADDR_OWVAR 20
120750: PUSH
120751: LD_OWVAR 2
120755: ST_TO_ADDR
// uc_nation := nation ;
120756: LD_ADDR_OWVAR 21
120760: PUSH
120761: LD_VAR 0 1
120765: ST_TO_ADDR
// InitHc ;
120766: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
120770: LD_INT 0
120772: PPUSH
120773: LD_VAR 0 2
120777: PPUSH
120778: LD_VAR 0 3
120782: PPUSH
120783: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
120787: LD_VAR 0 4
120791: PPUSH
120792: LD_VAR 0 5
120796: PPUSH
120797: CALL_OW 428
120801: PUSH
120802: LD_INT 0
120804: EQUAL
120805: IFFALSE 120829
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
120807: CALL_OW 44
120811: PPUSH
120812: LD_VAR 0 4
120816: PPUSH
120817: LD_VAR 0 5
120821: PPUSH
120822: LD_INT 1
120824: PPUSH
120825: CALL_OW 48
// end ;
120829: LD_VAR 0 6
120833: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
120834: LD_INT 0
120836: PPUSH
120837: PPUSH
// uc_side := your_side ;
120838: LD_ADDR_OWVAR 20
120842: PUSH
120843: LD_OWVAR 2
120847: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
120848: LD_VAR 0 1
120852: PUSH
120853: LD_INT 1
120855: PUSH
120856: LD_INT 2
120858: PUSH
120859: LD_INT 3
120861: PUSH
120862: LD_INT 4
120864: PUSH
120865: LD_INT 5
120867: PUSH
120868: EMPTY
120869: LIST
120870: LIST
120871: LIST
120872: LIST
120873: LIST
120874: IN
120875: IFFALSE 120887
// uc_nation := nation_american else
120877: LD_ADDR_OWVAR 21
120881: PUSH
120882: LD_INT 1
120884: ST_TO_ADDR
120885: GO 120930
// if chassis in [ 11 , 12 , 13 , 14 ] then
120887: LD_VAR 0 1
120891: PUSH
120892: LD_INT 11
120894: PUSH
120895: LD_INT 12
120897: PUSH
120898: LD_INT 13
120900: PUSH
120901: LD_INT 14
120903: PUSH
120904: EMPTY
120905: LIST
120906: LIST
120907: LIST
120908: LIST
120909: IN
120910: IFFALSE 120922
// uc_nation := nation_arabian else
120912: LD_ADDR_OWVAR 21
120916: PUSH
120917: LD_INT 2
120919: ST_TO_ADDR
120920: GO 120930
// uc_nation := nation_russian ;
120922: LD_ADDR_OWVAR 21
120926: PUSH
120927: LD_INT 3
120929: ST_TO_ADDR
// vc_chassis := chassis ;
120930: LD_ADDR_OWVAR 37
120934: PUSH
120935: LD_VAR 0 1
120939: ST_TO_ADDR
// vc_engine := engine ;
120940: LD_ADDR_OWVAR 39
120944: PUSH
120945: LD_VAR 0 2
120949: ST_TO_ADDR
// vc_control := control ;
120950: LD_ADDR_OWVAR 38
120954: PUSH
120955: LD_VAR 0 3
120959: ST_TO_ADDR
// vc_weapon := weapon ;
120960: LD_ADDR_OWVAR 40
120964: PUSH
120965: LD_VAR 0 4
120969: ST_TO_ADDR
// un := CreateVehicle ;
120970: LD_ADDR_VAR 0 8
120974: PUSH
120975: CALL_OW 45
120979: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
120980: LD_VAR 0 8
120984: PPUSH
120985: LD_INT 0
120987: PPUSH
120988: LD_INT 5
120990: PPUSH
120991: CALL_OW 12
120995: PPUSH
120996: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
121000: LD_VAR 0 8
121004: PPUSH
121005: LD_VAR 0 5
121009: PPUSH
121010: LD_VAR 0 6
121014: PPUSH
121015: LD_INT 1
121017: PPUSH
121018: CALL_OW 48
// end ;
121022: LD_VAR 0 7
121026: RET
// export hInvincible ; every 1 do
121027: GO 121029
121029: DISABLE
// hInvincible := [ ] ;
121030: LD_ADDR_EXP 216
121034: PUSH
121035: EMPTY
121036: ST_TO_ADDR
121037: END
// every 10 do var i ;
121038: GO 121040
121040: DISABLE
121041: LD_INT 0
121043: PPUSH
// begin enable ;
121044: ENABLE
// if not hInvincible then
121045: LD_EXP 216
121049: NOT
121050: IFFALSE 121054
// exit ;
121052: GO 121098
// for i in hInvincible do
121054: LD_ADDR_VAR 0 1
121058: PUSH
121059: LD_EXP 216
121063: PUSH
121064: FOR_IN
121065: IFFALSE 121096
// if GetLives ( i ) < 1000 then
121067: LD_VAR 0 1
121071: PPUSH
121072: CALL_OW 256
121076: PUSH
121077: LD_INT 1000
121079: LESS
121080: IFFALSE 121094
// SetLives ( i , 1000 ) ;
121082: LD_VAR 0 1
121086: PPUSH
121087: LD_INT 1000
121089: PPUSH
121090: CALL_OW 234
121094: GO 121064
121096: POP
121097: POP
// end ;
121098: PPOPN 1
121100: END
// export function hHackInvincible ; var i ; begin
121101: LD_INT 0
121103: PPUSH
121104: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
121105: LD_ADDR_VAR 0 2
121109: PUSH
121110: LD_INT 2
121112: PUSH
121113: LD_INT 21
121115: PUSH
121116: LD_INT 1
121118: PUSH
121119: EMPTY
121120: LIST
121121: LIST
121122: PUSH
121123: LD_INT 21
121125: PUSH
121126: LD_INT 2
121128: PUSH
121129: EMPTY
121130: LIST
121131: LIST
121132: PUSH
121133: EMPTY
121134: LIST
121135: LIST
121136: LIST
121137: PPUSH
121138: CALL_OW 69
121142: PUSH
121143: FOR_IN
121144: IFFALSE 121205
// if IsSelected ( i ) then
121146: LD_VAR 0 2
121150: PPUSH
121151: CALL_OW 306
121155: IFFALSE 121203
// begin if i in hInvincible then
121157: LD_VAR 0 2
121161: PUSH
121162: LD_EXP 216
121166: IN
121167: IFFALSE 121187
// hInvincible := hInvincible diff i else
121169: LD_ADDR_EXP 216
121173: PUSH
121174: LD_EXP 216
121178: PUSH
121179: LD_VAR 0 2
121183: DIFF
121184: ST_TO_ADDR
121185: GO 121203
// hInvincible := hInvincible union i ;
121187: LD_ADDR_EXP 216
121191: PUSH
121192: LD_EXP 216
121196: PUSH
121197: LD_VAR 0 2
121201: UNION
121202: ST_TO_ADDR
// end ;
121203: GO 121143
121205: POP
121206: POP
// end ;
121207: LD_VAR 0 1
121211: RET
// export function hHackInvisible ; var i , j ; begin
121212: LD_INT 0
121214: PPUSH
121215: PPUSH
121216: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
121217: LD_ADDR_VAR 0 2
121221: PUSH
121222: LD_INT 21
121224: PUSH
121225: LD_INT 1
121227: PUSH
121228: EMPTY
121229: LIST
121230: LIST
121231: PPUSH
121232: CALL_OW 69
121236: PUSH
121237: FOR_IN
121238: IFFALSE 121262
// if IsSelected ( i ) then
121240: LD_VAR 0 2
121244: PPUSH
121245: CALL_OW 306
121249: IFFALSE 121260
// ComForceInvisible ( i ) ;
121251: LD_VAR 0 2
121255: PPUSH
121256: CALL_OW 496
121260: GO 121237
121262: POP
121263: POP
// end ;
121264: LD_VAR 0 1
121268: RET
// export function hHackChangeYourSide ; begin
121269: LD_INT 0
121271: PPUSH
// if your_side = 8 then
121272: LD_OWVAR 2
121276: PUSH
121277: LD_INT 8
121279: EQUAL
121280: IFFALSE 121292
// your_side := 0 else
121282: LD_ADDR_OWVAR 2
121286: PUSH
121287: LD_INT 0
121289: ST_TO_ADDR
121290: GO 121306
// your_side := your_side + 1 ;
121292: LD_ADDR_OWVAR 2
121296: PUSH
121297: LD_OWVAR 2
121301: PUSH
121302: LD_INT 1
121304: PLUS
121305: ST_TO_ADDR
// end ;
121306: LD_VAR 0 1
121310: RET
// export function hHackChangeUnitSide ; var i , j ; begin
121311: LD_INT 0
121313: PPUSH
121314: PPUSH
121315: PPUSH
// for i in all_units do
121316: LD_ADDR_VAR 0 2
121320: PUSH
121321: LD_OWVAR 3
121325: PUSH
121326: FOR_IN
121327: IFFALSE 121405
// if IsSelected ( i ) then
121329: LD_VAR 0 2
121333: PPUSH
121334: CALL_OW 306
121338: IFFALSE 121403
// begin j := GetSide ( i ) ;
121340: LD_ADDR_VAR 0 3
121344: PUSH
121345: LD_VAR 0 2
121349: PPUSH
121350: CALL_OW 255
121354: ST_TO_ADDR
// if j = 8 then
121355: LD_VAR 0 3
121359: PUSH
121360: LD_INT 8
121362: EQUAL
121363: IFFALSE 121375
// j := 0 else
121365: LD_ADDR_VAR 0 3
121369: PUSH
121370: LD_INT 0
121372: ST_TO_ADDR
121373: GO 121389
// j := j + 1 ;
121375: LD_ADDR_VAR 0 3
121379: PUSH
121380: LD_VAR 0 3
121384: PUSH
121385: LD_INT 1
121387: PLUS
121388: ST_TO_ADDR
// SetSide ( i , j ) ;
121389: LD_VAR 0 2
121393: PPUSH
121394: LD_VAR 0 3
121398: PPUSH
121399: CALL_OW 235
// end ;
121403: GO 121326
121405: POP
121406: POP
// end ;
121407: LD_VAR 0 1
121411: RET
// export function hHackFog ; begin
121412: LD_INT 0
121414: PPUSH
// FogOff ( true ) ;
121415: LD_INT 1
121417: PPUSH
121418: CALL_OW 344
// end ;
121422: LD_VAR 0 1
121426: RET
// export function hHackTeleport ( unit , x , y ) ; begin
121427: LD_INT 0
121429: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
121430: LD_VAR 0 1
121434: PPUSH
121435: LD_VAR 0 2
121439: PPUSH
121440: LD_VAR 0 3
121444: PPUSH
121445: LD_INT 1
121447: PPUSH
121448: LD_INT 1
121450: PPUSH
121451: CALL_OW 483
// CenterOnXY ( x , y ) ;
121455: LD_VAR 0 2
121459: PPUSH
121460: LD_VAR 0 3
121464: PPUSH
121465: CALL_OW 84
// end ;
121469: LD_VAR 0 4
121473: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
121474: LD_INT 0
121476: PPUSH
121477: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
121478: LD_VAR 0 1
121482: NOT
121483: PUSH
121484: LD_VAR 0 2
121488: PPUSH
121489: LD_VAR 0 3
121493: PPUSH
121494: CALL_OW 488
121498: NOT
121499: OR
121500: PUSH
121501: LD_VAR 0 1
121505: PPUSH
121506: CALL_OW 266
121510: PUSH
121511: LD_INT 3
121513: NONEQUAL
121514: PUSH
121515: LD_VAR 0 1
121519: PPUSH
121520: CALL_OW 247
121524: PUSH
121525: LD_INT 1
121527: EQUAL
121528: NOT
121529: AND
121530: OR
121531: IFFALSE 121535
// exit ;
121533: GO 121684
// if GetType ( factory ) = unit_human then
121535: LD_VAR 0 1
121539: PPUSH
121540: CALL_OW 247
121544: PUSH
121545: LD_INT 1
121547: EQUAL
121548: IFFALSE 121565
// factory := IsInUnit ( factory ) ;
121550: LD_ADDR_VAR 0 1
121554: PUSH
121555: LD_VAR 0 1
121559: PPUSH
121560: CALL_OW 310
121564: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
121565: LD_VAR 0 1
121569: PPUSH
121570: CALL_OW 266
121574: PUSH
121575: LD_INT 3
121577: NONEQUAL
121578: IFFALSE 121582
// exit ;
121580: GO 121684
// if HexInfo ( x , y ) = factory then
121582: LD_VAR 0 2
121586: PPUSH
121587: LD_VAR 0 3
121591: PPUSH
121592: CALL_OW 428
121596: PUSH
121597: LD_VAR 0 1
121601: EQUAL
121602: IFFALSE 121629
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
121604: LD_ADDR_EXP 217
121608: PUSH
121609: LD_EXP 217
121613: PPUSH
121614: LD_VAR 0 1
121618: PPUSH
121619: LD_INT 0
121621: PPUSH
121622: CALL_OW 1
121626: ST_TO_ADDR
121627: GO 121680
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
121629: LD_ADDR_EXP 217
121633: PUSH
121634: LD_EXP 217
121638: PPUSH
121639: LD_VAR 0 1
121643: PPUSH
121644: LD_VAR 0 1
121648: PPUSH
121649: CALL_OW 255
121653: PUSH
121654: LD_VAR 0 1
121658: PUSH
121659: LD_VAR 0 2
121663: PUSH
121664: LD_VAR 0 3
121668: PUSH
121669: EMPTY
121670: LIST
121671: LIST
121672: LIST
121673: LIST
121674: PPUSH
121675: CALL_OW 1
121679: ST_TO_ADDR
// UpdateFactoryWaypoints ;
121680: CALL 121689 0 0
// end ;
121684: LD_VAR 0 4
121688: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
121689: LD_INT 0
121691: PPUSH
121692: PPUSH
121693: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
121694: LD_STRING resetFactoryWaypoint();
121696: PPUSH
121697: CALL_OW 559
// if factoryWaypoints then
121701: LD_EXP 217
121705: IFFALSE 121831
// begin list := PrepareArray ( factoryWaypoints ) ;
121707: LD_ADDR_VAR 0 3
121711: PUSH
121712: LD_EXP 217
121716: PPUSH
121717: CALL 107085 0 1
121721: ST_TO_ADDR
// for i := 1 to list do
121722: LD_ADDR_VAR 0 2
121726: PUSH
121727: DOUBLE
121728: LD_INT 1
121730: DEC
121731: ST_TO_ADDR
121732: LD_VAR 0 3
121736: PUSH
121737: FOR_TO
121738: IFFALSE 121829
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
121740: LD_STRING setFactoryWaypointXY(
121742: PUSH
121743: LD_VAR 0 3
121747: PUSH
121748: LD_VAR 0 2
121752: ARRAY
121753: PUSH
121754: LD_INT 1
121756: ARRAY
121757: STR
121758: PUSH
121759: LD_STRING ,
121761: STR
121762: PUSH
121763: LD_VAR 0 3
121767: PUSH
121768: LD_VAR 0 2
121772: ARRAY
121773: PUSH
121774: LD_INT 2
121776: ARRAY
121777: STR
121778: PUSH
121779: LD_STRING ,
121781: STR
121782: PUSH
121783: LD_VAR 0 3
121787: PUSH
121788: LD_VAR 0 2
121792: ARRAY
121793: PUSH
121794: LD_INT 3
121796: ARRAY
121797: STR
121798: PUSH
121799: LD_STRING ,
121801: STR
121802: PUSH
121803: LD_VAR 0 3
121807: PUSH
121808: LD_VAR 0 2
121812: ARRAY
121813: PUSH
121814: LD_INT 4
121816: ARRAY
121817: STR
121818: PUSH
121819: LD_STRING )
121821: STR
121822: PPUSH
121823: CALL_OW 559
121827: GO 121737
121829: POP
121830: POP
// end ; end ;
121831: LD_VAR 0 1
121835: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
121836: LD_INT 0
121838: PPUSH
// if HexInfo ( x , y ) = warehouse then
121839: LD_VAR 0 2
121843: PPUSH
121844: LD_VAR 0 3
121848: PPUSH
121849: CALL_OW 428
121853: PUSH
121854: LD_VAR 0 1
121858: EQUAL
121859: IFFALSE 121886
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
121861: LD_ADDR_EXP 218
121865: PUSH
121866: LD_EXP 218
121870: PPUSH
121871: LD_VAR 0 1
121875: PPUSH
121876: LD_INT 0
121878: PPUSH
121879: CALL_OW 1
121883: ST_TO_ADDR
121884: GO 121937
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
121886: LD_ADDR_EXP 218
121890: PUSH
121891: LD_EXP 218
121895: PPUSH
121896: LD_VAR 0 1
121900: PPUSH
121901: LD_VAR 0 1
121905: PPUSH
121906: CALL_OW 255
121910: PUSH
121911: LD_VAR 0 1
121915: PUSH
121916: LD_VAR 0 2
121920: PUSH
121921: LD_VAR 0 3
121925: PUSH
121926: EMPTY
121927: LIST
121928: LIST
121929: LIST
121930: LIST
121931: PPUSH
121932: CALL_OW 1
121936: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
121937: CALL 121946 0 0
// end ;
121941: LD_VAR 0 4
121945: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
121946: LD_INT 0
121948: PPUSH
121949: PPUSH
121950: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
121951: LD_STRING resetWarehouseGatheringPoints();
121953: PPUSH
121954: CALL_OW 559
// if warehouseGatheringPoints then
121958: LD_EXP 218
121962: IFFALSE 122088
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
121964: LD_ADDR_VAR 0 3
121968: PUSH
121969: LD_EXP 218
121973: PPUSH
121974: CALL 107085 0 1
121978: ST_TO_ADDR
// for i := 1 to list do
121979: LD_ADDR_VAR 0 2
121983: PUSH
121984: DOUBLE
121985: LD_INT 1
121987: DEC
121988: ST_TO_ADDR
121989: LD_VAR 0 3
121993: PUSH
121994: FOR_TO
121995: IFFALSE 122086
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
121997: LD_STRING setWarehouseGatheringPointXY(
121999: PUSH
122000: LD_VAR 0 3
122004: PUSH
122005: LD_VAR 0 2
122009: ARRAY
122010: PUSH
122011: LD_INT 1
122013: ARRAY
122014: STR
122015: PUSH
122016: LD_STRING ,
122018: STR
122019: PUSH
122020: LD_VAR 0 3
122024: PUSH
122025: LD_VAR 0 2
122029: ARRAY
122030: PUSH
122031: LD_INT 2
122033: ARRAY
122034: STR
122035: PUSH
122036: LD_STRING ,
122038: STR
122039: PUSH
122040: LD_VAR 0 3
122044: PUSH
122045: LD_VAR 0 2
122049: ARRAY
122050: PUSH
122051: LD_INT 3
122053: ARRAY
122054: STR
122055: PUSH
122056: LD_STRING ,
122058: STR
122059: PUSH
122060: LD_VAR 0 3
122064: PUSH
122065: LD_VAR 0 2
122069: ARRAY
122070: PUSH
122071: LD_INT 4
122073: ARRAY
122074: STR
122075: PUSH
122076: LD_STRING )
122078: STR
122079: PPUSH
122080: CALL_OW 559
122084: GO 121994
122086: POP
122087: POP
// end ; end ;
122088: LD_VAR 0 1
122092: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
122093: LD_EXP 218
122097: IFFALSE 122784
122099: GO 122101
122101: DISABLE
122102: LD_INT 0
122104: PPUSH
122105: PPUSH
122106: PPUSH
122107: PPUSH
122108: PPUSH
122109: PPUSH
122110: PPUSH
122111: PPUSH
122112: PPUSH
// begin enable ;
122113: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
122114: LD_ADDR_VAR 0 3
122118: PUSH
122119: LD_EXP 218
122123: PPUSH
122124: CALL 107085 0 1
122128: ST_TO_ADDR
// if not list then
122129: LD_VAR 0 3
122133: NOT
122134: IFFALSE 122138
// exit ;
122136: GO 122784
// for i := 1 to list do
122138: LD_ADDR_VAR 0 1
122142: PUSH
122143: DOUBLE
122144: LD_INT 1
122146: DEC
122147: ST_TO_ADDR
122148: LD_VAR 0 3
122152: PUSH
122153: FOR_TO
122154: IFFALSE 122782
// begin depot := list [ i ] [ 2 ] ;
122156: LD_ADDR_VAR 0 8
122160: PUSH
122161: LD_VAR 0 3
122165: PUSH
122166: LD_VAR 0 1
122170: ARRAY
122171: PUSH
122172: LD_INT 2
122174: ARRAY
122175: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
122176: LD_ADDR_VAR 0 5
122180: PUSH
122181: LD_VAR 0 3
122185: PUSH
122186: LD_VAR 0 1
122190: ARRAY
122191: PUSH
122192: LD_INT 1
122194: ARRAY
122195: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
122196: LD_VAR 0 8
122200: PPUSH
122201: CALL_OW 301
122205: PUSH
122206: LD_VAR 0 5
122210: PUSH
122211: LD_VAR 0 8
122215: PPUSH
122216: CALL_OW 255
122220: NONEQUAL
122221: OR
122222: IFFALSE 122251
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
122224: LD_ADDR_EXP 218
122228: PUSH
122229: LD_EXP 218
122233: PPUSH
122234: LD_VAR 0 8
122238: PPUSH
122239: LD_INT 0
122241: PPUSH
122242: CALL_OW 1
122246: ST_TO_ADDR
// exit ;
122247: POP
122248: POP
122249: GO 122784
// end ; x := list [ i ] [ 3 ] ;
122251: LD_ADDR_VAR 0 6
122255: PUSH
122256: LD_VAR 0 3
122260: PUSH
122261: LD_VAR 0 1
122265: ARRAY
122266: PUSH
122267: LD_INT 3
122269: ARRAY
122270: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
122271: LD_ADDR_VAR 0 7
122275: PUSH
122276: LD_VAR 0 3
122280: PUSH
122281: LD_VAR 0 1
122285: ARRAY
122286: PUSH
122287: LD_INT 4
122289: ARRAY
122290: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
122291: LD_ADDR_VAR 0 9
122295: PUSH
122296: LD_VAR 0 6
122300: PPUSH
122301: LD_VAR 0 7
122305: PPUSH
122306: LD_INT 16
122308: PPUSH
122309: CALL 105669 0 3
122313: ST_TO_ADDR
// if not cratesNearbyPoint then
122314: LD_VAR 0 9
122318: NOT
122319: IFFALSE 122325
// exit ;
122321: POP
122322: POP
122323: GO 122784
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
122325: LD_ADDR_VAR 0 4
122329: PUSH
122330: LD_INT 22
122332: PUSH
122333: LD_VAR 0 5
122337: PUSH
122338: EMPTY
122339: LIST
122340: LIST
122341: PUSH
122342: LD_INT 3
122344: PUSH
122345: LD_INT 60
122347: PUSH
122348: EMPTY
122349: LIST
122350: PUSH
122351: EMPTY
122352: LIST
122353: LIST
122354: PUSH
122355: LD_INT 91
122357: PUSH
122358: LD_VAR 0 8
122362: PUSH
122363: LD_INT 6
122365: PUSH
122366: EMPTY
122367: LIST
122368: LIST
122369: LIST
122370: PUSH
122371: LD_INT 2
122373: PUSH
122374: LD_INT 25
122376: PUSH
122377: LD_INT 2
122379: PUSH
122380: EMPTY
122381: LIST
122382: LIST
122383: PUSH
122384: LD_INT 25
122386: PUSH
122387: LD_INT 16
122389: PUSH
122390: EMPTY
122391: LIST
122392: LIST
122393: PUSH
122394: EMPTY
122395: LIST
122396: LIST
122397: LIST
122398: PUSH
122399: EMPTY
122400: LIST
122401: LIST
122402: LIST
122403: LIST
122404: PPUSH
122405: CALL_OW 69
122409: PUSH
122410: LD_VAR 0 8
122414: PPUSH
122415: CALL_OW 313
122419: PPUSH
122420: LD_INT 3
122422: PUSH
122423: LD_INT 60
122425: PUSH
122426: EMPTY
122427: LIST
122428: PUSH
122429: EMPTY
122430: LIST
122431: LIST
122432: PUSH
122433: LD_INT 2
122435: PUSH
122436: LD_INT 25
122438: PUSH
122439: LD_INT 2
122441: PUSH
122442: EMPTY
122443: LIST
122444: LIST
122445: PUSH
122446: LD_INT 25
122448: PUSH
122449: LD_INT 16
122451: PUSH
122452: EMPTY
122453: LIST
122454: LIST
122455: PUSH
122456: EMPTY
122457: LIST
122458: LIST
122459: LIST
122460: PUSH
122461: EMPTY
122462: LIST
122463: LIST
122464: PPUSH
122465: CALL_OW 72
122469: UNION
122470: ST_TO_ADDR
// if tmp then
122471: LD_VAR 0 4
122475: IFFALSE 122555
// begin tmp := ShrinkArray ( tmp , 3 ) ;
122477: LD_ADDR_VAR 0 4
122481: PUSH
122482: LD_VAR 0 4
122486: PPUSH
122487: LD_INT 3
122489: PPUSH
122490: CALL 103636 0 2
122494: ST_TO_ADDR
// for j in tmp do
122495: LD_ADDR_VAR 0 2
122499: PUSH
122500: LD_VAR 0 4
122504: PUSH
122505: FOR_IN
122506: IFFALSE 122549
// begin if IsInUnit ( j ) then
122508: LD_VAR 0 2
122512: PPUSH
122513: CALL_OW 310
122517: IFFALSE 122528
// ComExit ( j ) ;
122519: LD_VAR 0 2
122523: PPUSH
122524: CALL 103719 0 1
// AddComCollect ( j , x , y ) ;
122528: LD_VAR 0 2
122532: PPUSH
122533: LD_VAR 0 6
122537: PPUSH
122538: LD_VAR 0 7
122542: PPUSH
122543: CALL_OW 177
// end ;
122547: GO 122505
122549: POP
122550: POP
// exit ;
122551: POP
122552: POP
122553: GO 122784
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
122555: LD_ADDR_VAR 0 4
122559: PUSH
122560: LD_INT 22
122562: PUSH
122563: LD_VAR 0 5
122567: PUSH
122568: EMPTY
122569: LIST
122570: LIST
122571: PUSH
122572: LD_INT 91
122574: PUSH
122575: LD_VAR 0 8
122579: PUSH
122580: LD_INT 8
122582: PUSH
122583: EMPTY
122584: LIST
122585: LIST
122586: LIST
122587: PUSH
122588: LD_INT 2
122590: PUSH
122591: LD_INT 34
122593: PUSH
122594: LD_INT 12
122596: PUSH
122597: EMPTY
122598: LIST
122599: LIST
122600: PUSH
122601: LD_INT 34
122603: PUSH
122604: LD_INT 51
122606: PUSH
122607: EMPTY
122608: LIST
122609: LIST
122610: PUSH
122611: LD_INT 34
122613: PUSH
122614: LD_INT 32
122616: PUSH
122617: EMPTY
122618: LIST
122619: LIST
122620: PUSH
122621: LD_INT 34
122623: PUSH
122624: LD_EXP 96
122628: PUSH
122629: EMPTY
122630: LIST
122631: LIST
122632: PUSH
122633: EMPTY
122634: LIST
122635: LIST
122636: LIST
122637: LIST
122638: LIST
122639: PUSH
122640: EMPTY
122641: LIST
122642: LIST
122643: LIST
122644: PPUSH
122645: CALL_OW 69
122649: ST_TO_ADDR
// if tmp then
122650: LD_VAR 0 4
122654: IFFALSE 122780
// begin for j in tmp do
122656: LD_ADDR_VAR 0 2
122660: PUSH
122661: LD_VAR 0 4
122665: PUSH
122666: FOR_IN
122667: IFFALSE 122778
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
122669: LD_VAR 0 2
122673: PPUSH
122674: CALL_OW 262
122678: PUSH
122679: LD_INT 3
122681: EQUAL
122682: PUSH
122683: LD_VAR 0 2
122687: PPUSH
122688: CALL_OW 261
122692: PUSH
122693: LD_INT 20
122695: GREATER
122696: OR
122697: PUSH
122698: LD_VAR 0 2
122702: PPUSH
122703: CALL_OW 314
122707: NOT
122708: AND
122709: PUSH
122710: LD_VAR 0 2
122714: PPUSH
122715: CALL_OW 263
122719: PUSH
122720: LD_INT 1
122722: NONEQUAL
122723: PUSH
122724: LD_VAR 0 2
122728: PPUSH
122729: CALL_OW 311
122733: OR
122734: AND
122735: IFFALSE 122776
// begin ComCollect ( j , x , y ) ;
122737: LD_VAR 0 2
122741: PPUSH
122742: LD_VAR 0 6
122746: PPUSH
122747: LD_VAR 0 7
122751: PPUSH
122752: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
122756: LD_VAR 0 2
122760: PPUSH
122761: LD_VAR 0 8
122765: PPUSH
122766: CALL_OW 172
// exit ;
122770: POP
122771: POP
122772: POP
122773: POP
122774: GO 122784
// end ;
122776: GO 122666
122778: POP
122779: POP
// end ; end ;
122780: GO 122153
122782: POP
122783: POP
// end ; end_of_file
122784: PPOPN 9
122786: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
122787: LD_INT 0
122789: PPUSH
122790: PPUSH
122791: PPUSH
122792: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
122793: LD_VAR 0 1
122797: PPUSH
122798: CALL_OW 264
122802: PUSH
122803: LD_EXP 99
122807: EQUAL
122808: IFFALSE 122880
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
122810: LD_INT 68
122812: PPUSH
122813: LD_VAR 0 1
122817: PPUSH
122818: CALL_OW 255
122822: PPUSH
122823: CALL_OW 321
122827: PUSH
122828: LD_INT 2
122830: EQUAL
122831: IFFALSE 122843
// eff := 70 else
122833: LD_ADDR_VAR 0 4
122837: PUSH
122838: LD_INT 70
122840: ST_TO_ADDR
122841: GO 122851
// eff := 30 ;
122843: LD_ADDR_VAR 0 4
122847: PUSH
122848: LD_INT 30
122850: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
122851: LD_VAR 0 1
122855: PPUSH
122856: CALL_OW 250
122860: PPUSH
122861: LD_VAR 0 1
122865: PPUSH
122866: CALL_OW 251
122870: PPUSH
122871: LD_VAR 0 4
122875: PPUSH
122876: CALL_OW 495
// end ; end ;
122880: LD_VAR 0 2
122884: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
122885: LD_INT 0
122887: PPUSH
// end ;
122888: LD_VAR 0 4
122892: RET
// export function SOS_Command ( cmd ) ; begin
122893: LD_INT 0
122895: PPUSH
// end ;
122896: LD_VAR 0 2
122900: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
122901: LD_INT 0
122903: PPUSH
// end ;
122904: LD_VAR 0 6
122908: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
122909: LD_INT 0
122911: PPUSH
122912: PPUSH
// if not vehicle or not factory then
122913: LD_VAR 0 1
122917: NOT
122918: PUSH
122919: LD_VAR 0 2
122923: NOT
122924: OR
122925: IFFALSE 122929
// exit ;
122927: GO 123160
// if factoryWaypoints >= factory then
122929: LD_EXP 217
122933: PUSH
122934: LD_VAR 0 2
122938: GREATEREQUAL
122939: IFFALSE 123160
// if factoryWaypoints [ factory ] then
122941: LD_EXP 217
122945: PUSH
122946: LD_VAR 0 2
122950: ARRAY
122951: IFFALSE 123160
// begin if GetControl ( vehicle ) = control_manual then
122953: LD_VAR 0 1
122957: PPUSH
122958: CALL_OW 263
122962: PUSH
122963: LD_INT 1
122965: EQUAL
122966: IFFALSE 123047
// begin driver := IsDrivenBy ( vehicle ) ;
122968: LD_ADDR_VAR 0 4
122972: PUSH
122973: LD_VAR 0 1
122977: PPUSH
122978: CALL_OW 311
122982: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
122983: LD_VAR 0 4
122987: PPUSH
122988: LD_EXP 217
122992: PUSH
122993: LD_VAR 0 2
122997: ARRAY
122998: PUSH
122999: LD_INT 3
123001: ARRAY
123002: PPUSH
123003: LD_EXP 217
123007: PUSH
123008: LD_VAR 0 2
123012: ARRAY
123013: PUSH
123014: LD_INT 4
123016: ARRAY
123017: PPUSH
123018: CALL_OW 171
// AddComExitVehicle ( driver ) ;
123022: LD_VAR 0 4
123026: PPUSH
123027: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
123031: LD_VAR 0 4
123035: PPUSH
123036: LD_VAR 0 2
123040: PPUSH
123041: CALL_OW 180
// end else
123045: GO 123160
// if GetControl ( vehicle ) = control_remote then
123047: LD_VAR 0 1
123051: PPUSH
123052: CALL_OW 263
123056: PUSH
123057: LD_INT 2
123059: EQUAL
123060: IFFALSE 123121
// begin wait ( 0 0$2 ) ;
123062: LD_INT 70
123064: PPUSH
123065: CALL_OW 67
// if Connect ( vehicle ) then
123069: LD_VAR 0 1
123073: PPUSH
123074: CALL 74030 0 1
123078: IFFALSE 123119
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
123080: LD_VAR 0 1
123084: PPUSH
123085: LD_EXP 217
123089: PUSH
123090: LD_VAR 0 2
123094: ARRAY
123095: PUSH
123096: LD_INT 3
123098: ARRAY
123099: PPUSH
123100: LD_EXP 217
123104: PUSH
123105: LD_VAR 0 2
123109: ARRAY
123110: PUSH
123111: LD_INT 4
123113: ARRAY
123114: PPUSH
123115: CALL_OW 171
// end else
123119: GO 123160
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
123121: LD_VAR 0 1
123125: PPUSH
123126: LD_EXP 217
123130: PUSH
123131: LD_VAR 0 2
123135: ARRAY
123136: PUSH
123137: LD_INT 3
123139: ARRAY
123140: PPUSH
123141: LD_EXP 217
123145: PUSH
123146: LD_VAR 0 2
123150: ARRAY
123151: PUSH
123152: LD_INT 4
123154: ARRAY
123155: PPUSH
123156: CALL_OW 171
// end ; end ;
123160: LD_VAR 0 3
123164: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
123165: LD_INT 0
123167: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
123168: LD_VAR 0 1
123172: PUSH
123173: LD_INT 250
123175: EQUAL
123176: PUSH
123177: LD_VAR 0 2
123181: PPUSH
123182: CALL_OW 264
123186: PUSH
123187: LD_EXP 102
123191: EQUAL
123192: AND
123193: IFFALSE 123214
// MinerPlaceMine ( unit , x , y ) ;
123195: LD_VAR 0 2
123199: PPUSH
123200: LD_VAR 0 4
123204: PPUSH
123205: LD_VAR 0 5
123209: PPUSH
123210: CALL 125613 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
123214: LD_VAR 0 1
123218: PUSH
123219: LD_INT 251
123221: EQUAL
123222: PUSH
123223: LD_VAR 0 2
123227: PPUSH
123228: CALL_OW 264
123232: PUSH
123233: LD_EXP 102
123237: EQUAL
123238: AND
123239: IFFALSE 123260
// MinerDetonateMine ( unit , x , y ) ;
123241: LD_VAR 0 2
123245: PPUSH
123246: LD_VAR 0 4
123250: PPUSH
123251: LD_VAR 0 5
123255: PPUSH
123256: CALL 125890 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
123260: LD_VAR 0 1
123264: PUSH
123265: LD_INT 252
123267: EQUAL
123268: PUSH
123269: LD_VAR 0 2
123273: PPUSH
123274: CALL_OW 264
123278: PUSH
123279: LD_EXP 102
123283: EQUAL
123284: AND
123285: IFFALSE 123306
// MinerCreateMinefield ( unit , x , y ) ;
123287: LD_VAR 0 2
123291: PPUSH
123292: LD_VAR 0 4
123296: PPUSH
123297: LD_VAR 0 5
123301: PPUSH
123302: CALL 126307 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
123306: LD_VAR 0 1
123310: PUSH
123311: LD_INT 253
123313: EQUAL
123314: PUSH
123315: LD_VAR 0 2
123319: PPUSH
123320: CALL_OW 257
123324: PUSH
123325: LD_INT 5
123327: EQUAL
123328: AND
123329: IFFALSE 123350
// ComBinocular ( unit , x , y ) ;
123331: LD_VAR 0 2
123335: PPUSH
123336: LD_VAR 0 4
123340: PPUSH
123341: LD_VAR 0 5
123345: PPUSH
123346: CALL 126678 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
123350: LD_VAR 0 1
123354: PUSH
123355: LD_INT 254
123357: EQUAL
123358: PUSH
123359: LD_VAR 0 2
123363: PPUSH
123364: CALL_OW 264
123368: PUSH
123369: LD_EXP 97
123373: EQUAL
123374: AND
123375: PUSH
123376: LD_VAR 0 3
123380: PPUSH
123381: CALL_OW 263
123385: PUSH
123386: LD_INT 3
123388: EQUAL
123389: AND
123390: IFFALSE 123406
// HackDestroyVehicle ( unit , selectedUnit ) ;
123392: LD_VAR 0 2
123396: PPUSH
123397: LD_VAR 0 3
123401: PPUSH
123402: CALL 124973 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
123406: LD_VAR 0 1
123410: PUSH
123411: LD_INT 255
123413: EQUAL
123414: PUSH
123415: LD_VAR 0 2
123419: PPUSH
123420: CALL_OW 264
123424: PUSH
123425: LD_INT 14
123427: PUSH
123428: LD_INT 53
123430: PUSH
123431: EMPTY
123432: LIST
123433: LIST
123434: IN
123435: AND
123436: PUSH
123437: LD_VAR 0 4
123441: PPUSH
123442: LD_VAR 0 5
123446: PPUSH
123447: CALL_OW 488
123451: AND
123452: IFFALSE 123476
// CutTreeXYR ( unit , x , y , 12 ) ;
123454: LD_VAR 0 2
123458: PPUSH
123459: LD_VAR 0 4
123463: PPUSH
123464: LD_VAR 0 5
123468: PPUSH
123469: LD_INT 12
123471: PPUSH
123472: CALL 123539 0 4
// if cmd = 256 then
123476: LD_VAR 0 1
123480: PUSH
123481: LD_INT 256
123483: EQUAL
123484: IFFALSE 123505
// SetFactoryWaypoint ( unit , x , y ) ;
123486: LD_VAR 0 2
123490: PPUSH
123491: LD_VAR 0 4
123495: PPUSH
123496: LD_VAR 0 5
123500: PPUSH
123501: CALL 121474 0 3
// if cmd = 257 then
123505: LD_VAR 0 1
123509: PUSH
123510: LD_INT 257
123512: EQUAL
123513: IFFALSE 123534
// SetWarehouseGatheringPoint ( unit , x , y ) ;
123515: LD_VAR 0 2
123519: PPUSH
123520: LD_VAR 0 4
123524: PPUSH
123525: LD_VAR 0 5
123529: PPUSH
123530: CALL 121836 0 3
// end ;
123534: LD_VAR 0 6
123538: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
123539: LD_INT 0
123541: PPUSH
123542: PPUSH
123543: PPUSH
123544: PPUSH
123545: PPUSH
123546: PPUSH
123547: PPUSH
123548: PPUSH
123549: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
123550: LD_VAR 0 1
123554: NOT
123555: PUSH
123556: LD_VAR 0 2
123560: PPUSH
123561: LD_VAR 0 3
123565: PPUSH
123566: CALL_OW 488
123570: NOT
123571: OR
123572: PUSH
123573: LD_VAR 0 4
123577: NOT
123578: OR
123579: IFFALSE 123583
// exit ;
123581: GO 123923
// list := [ ] ;
123583: LD_ADDR_VAR 0 13
123587: PUSH
123588: EMPTY
123589: ST_TO_ADDR
// if x - r < 0 then
123590: LD_VAR 0 2
123594: PUSH
123595: LD_VAR 0 4
123599: MINUS
123600: PUSH
123601: LD_INT 0
123603: LESS
123604: IFFALSE 123616
// min_x := 0 else
123606: LD_ADDR_VAR 0 7
123610: PUSH
123611: LD_INT 0
123613: ST_TO_ADDR
123614: GO 123632
// min_x := x - r ;
123616: LD_ADDR_VAR 0 7
123620: PUSH
123621: LD_VAR 0 2
123625: PUSH
123626: LD_VAR 0 4
123630: MINUS
123631: ST_TO_ADDR
// if y - r < 0 then
123632: LD_VAR 0 3
123636: PUSH
123637: LD_VAR 0 4
123641: MINUS
123642: PUSH
123643: LD_INT 0
123645: LESS
123646: IFFALSE 123658
// min_y := 0 else
123648: LD_ADDR_VAR 0 8
123652: PUSH
123653: LD_INT 0
123655: ST_TO_ADDR
123656: GO 123674
// min_y := y - r ;
123658: LD_ADDR_VAR 0 8
123662: PUSH
123663: LD_VAR 0 3
123667: PUSH
123668: LD_VAR 0 4
123672: MINUS
123673: ST_TO_ADDR
// max_x := x + r ;
123674: LD_ADDR_VAR 0 9
123678: PUSH
123679: LD_VAR 0 2
123683: PUSH
123684: LD_VAR 0 4
123688: PLUS
123689: ST_TO_ADDR
// max_y := y + r ;
123690: LD_ADDR_VAR 0 10
123694: PUSH
123695: LD_VAR 0 3
123699: PUSH
123700: LD_VAR 0 4
123704: PLUS
123705: ST_TO_ADDR
// for _x = min_x to max_x do
123706: LD_ADDR_VAR 0 11
123710: PUSH
123711: DOUBLE
123712: LD_VAR 0 7
123716: DEC
123717: ST_TO_ADDR
123718: LD_VAR 0 9
123722: PUSH
123723: FOR_TO
123724: IFFALSE 123841
// for _y = min_y to max_y do
123726: LD_ADDR_VAR 0 12
123730: PUSH
123731: DOUBLE
123732: LD_VAR 0 8
123736: DEC
123737: ST_TO_ADDR
123738: LD_VAR 0 10
123742: PUSH
123743: FOR_TO
123744: IFFALSE 123837
// begin if not ValidHex ( _x , _y ) then
123746: LD_VAR 0 11
123750: PPUSH
123751: LD_VAR 0 12
123755: PPUSH
123756: CALL_OW 488
123760: NOT
123761: IFFALSE 123765
// continue ;
123763: GO 123743
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
123765: LD_VAR 0 11
123769: PPUSH
123770: LD_VAR 0 12
123774: PPUSH
123775: CALL_OW 351
123779: PUSH
123780: LD_VAR 0 11
123784: PPUSH
123785: LD_VAR 0 12
123789: PPUSH
123790: CALL_OW 554
123794: AND
123795: IFFALSE 123835
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
123797: LD_ADDR_VAR 0 13
123801: PUSH
123802: LD_VAR 0 13
123806: PPUSH
123807: LD_VAR 0 13
123811: PUSH
123812: LD_INT 1
123814: PLUS
123815: PPUSH
123816: LD_VAR 0 11
123820: PUSH
123821: LD_VAR 0 12
123825: PUSH
123826: EMPTY
123827: LIST
123828: LIST
123829: PPUSH
123830: CALL_OW 2
123834: ST_TO_ADDR
// end ;
123835: GO 123743
123837: POP
123838: POP
123839: GO 123723
123841: POP
123842: POP
// if not list then
123843: LD_VAR 0 13
123847: NOT
123848: IFFALSE 123852
// exit ;
123850: GO 123923
// for i in list do
123852: LD_ADDR_VAR 0 6
123856: PUSH
123857: LD_VAR 0 13
123861: PUSH
123862: FOR_IN
123863: IFFALSE 123921
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
123865: LD_VAR 0 1
123869: PPUSH
123870: LD_STRING M
123872: PUSH
123873: LD_VAR 0 6
123877: PUSH
123878: LD_INT 1
123880: ARRAY
123881: PUSH
123882: LD_VAR 0 6
123886: PUSH
123887: LD_INT 2
123889: ARRAY
123890: PUSH
123891: LD_INT 0
123893: PUSH
123894: LD_INT 0
123896: PUSH
123897: LD_INT 0
123899: PUSH
123900: LD_INT 0
123902: PUSH
123903: EMPTY
123904: LIST
123905: LIST
123906: LIST
123907: LIST
123908: LIST
123909: LIST
123910: LIST
123911: PUSH
123912: EMPTY
123913: LIST
123914: PPUSH
123915: CALL_OW 447
123919: GO 123862
123921: POP
123922: POP
// end ;
123923: LD_VAR 0 5
123927: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
123928: LD_EXP 220
123932: NOT
123933: IFFALSE 123983
123935: GO 123937
123937: DISABLE
// begin initHack := true ;
123938: LD_ADDR_EXP 220
123942: PUSH
123943: LD_INT 1
123945: ST_TO_ADDR
// hackTanks := [ ] ;
123946: LD_ADDR_EXP 221
123950: PUSH
123951: EMPTY
123952: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
123953: LD_ADDR_EXP 222
123957: PUSH
123958: EMPTY
123959: ST_TO_ADDR
// hackLimit := 3 ;
123960: LD_ADDR_EXP 223
123964: PUSH
123965: LD_INT 3
123967: ST_TO_ADDR
// hackDist := 12 ;
123968: LD_ADDR_EXP 224
123972: PUSH
123973: LD_INT 12
123975: ST_TO_ADDR
// hackCounter := [ ] ;
123976: LD_ADDR_EXP 225
123980: PUSH
123981: EMPTY
123982: ST_TO_ADDR
// end ;
123983: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
123984: LD_EXP 220
123988: PUSH
123989: LD_INT 34
123991: PUSH
123992: LD_EXP 97
123996: PUSH
123997: EMPTY
123998: LIST
123999: LIST
124000: PPUSH
124001: CALL_OW 69
124005: AND
124006: IFFALSE 124261
124008: GO 124010
124010: DISABLE
124011: LD_INT 0
124013: PPUSH
124014: PPUSH
// begin enable ;
124015: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
124016: LD_ADDR_VAR 0 1
124020: PUSH
124021: LD_INT 34
124023: PUSH
124024: LD_EXP 97
124028: PUSH
124029: EMPTY
124030: LIST
124031: LIST
124032: PPUSH
124033: CALL_OW 69
124037: PUSH
124038: FOR_IN
124039: IFFALSE 124259
// begin if not i in hackTanks then
124041: LD_VAR 0 1
124045: PUSH
124046: LD_EXP 221
124050: IN
124051: NOT
124052: IFFALSE 124135
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
124054: LD_ADDR_EXP 221
124058: PUSH
124059: LD_EXP 221
124063: PPUSH
124064: LD_EXP 221
124068: PUSH
124069: LD_INT 1
124071: PLUS
124072: PPUSH
124073: LD_VAR 0 1
124077: PPUSH
124078: CALL_OW 1
124082: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
124083: LD_ADDR_EXP 222
124087: PUSH
124088: LD_EXP 222
124092: PPUSH
124093: LD_EXP 222
124097: PUSH
124098: LD_INT 1
124100: PLUS
124101: PPUSH
124102: EMPTY
124103: PPUSH
124104: CALL_OW 1
124108: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
124109: LD_ADDR_EXP 225
124113: PUSH
124114: LD_EXP 225
124118: PPUSH
124119: LD_EXP 225
124123: PUSH
124124: LD_INT 1
124126: PLUS
124127: PPUSH
124128: EMPTY
124129: PPUSH
124130: CALL_OW 1
124134: ST_TO_ADDR
// end ; if not IsOk ( i ) then
124135: LD_VAR 0 1
124139: PPUSH
124140: CALL_OW 302
124144: NOT
124145: IFFALSE 124158
// begin HackUnlinkAll ( i ) ;
124147: LD_VAR 0 1
124151: PPUSH
124152: CALL 124264 0 1
// continue ;
124156: GO 124038
// end ; HackCheckCapturedStatus ( i ) ;
124158: LD_VAR 0 1
124162: PPUSH
124163: CALL 124707 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
124167: LD_ADDR_VAR 0 2
124171: PUSH
124172: LD_INT 81
124174: PUSH
124175: LD_VAR 0 1
124179: PPUSH
124180: CALL_OW 255
124184: PUSH
124185: EMPTY
124186: LIST
124187: LIST
124188: PUSH
124189: LD_INT 33
124191: PUSH
124192: LD_INT 3
124194: PUSH
124195: EMPTY
124196: LIST
124197: LIST
124198: PUSH
124199: LD_INT 91
124201: PUSH
124202: LD_VAR 0 1
124206: PUSH
124207: LD_EXP 224
124211: PUSH
124212: EMPTY
124213: LIST
124214: LIST
124215: LIST
124216: PUSH
124217: LD_INT 50
124219: PUSH
124220: EMPTY
124221: LIST
124222: PUSH
124223: EMPTY
124224: LIST
124225: LIST
124226: LIST
124227: LIST
124228: PPUSH
124229: CALL_OW 69
124233: ST_TO_ADDR
// if not tmp then
124234: LD_VAR 0 2
124238: NOT
124239: IFFALSE 124243
// continue ;
124241: GO 124038
// HackLink ( i , tmp ) ;
124243: LD_VAR 0 1
124247: PPUSH
124248: LD_VAR 0 2
124252: PPUSH
124253: CALL 124400 0 2
// end ;
124257: GO 124038
124259: POP
124260: POP
// end ;
124261: PPOPN 2
124263: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
124264: LD_INT 0
124266: PPUSH
124267: PPUSH
124268: PPUSH
// if not hack in hackTanks then
124269: LD_VAR 0 1
124273: PUSH
124274: LD_EXP 221
124278: IN
124279: NOT
124280: IFFALSE 124284
// exit ;
124282: GO 124395
// index := GetElementIndex ( hackTanks , hack ) ;
124284: LD_ADDR_VAR 0 4
124288: PUSH
124289: LD_EXP 221
124293: PPUSH
124294: LD_VAR 0 1
124298: PPUSH
124299: CALL 70844 0 2
124303: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
124304: LD_EXP 222
124308: PUSH
124309: LD_VAR 0 4
124313: ARRAY
124314: IFFALSE 124395
// begin for i in hackTanksCaptured [ index ] do
124316: LD_ADDR_VAR 0 3
124320: PUSH
124321: LD_EXP 222
124325: PUSH
124326: LD_VAR 0 4
124330: ARRAY
124331: PUSH
124332: FOR_IN
124333: IFFALSE 124359
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
124335: LD_VAR 0 3
124339: PUSH
124340: LD_INT 1
124342: ARRAY
124343: PPUSH
124344: LD_VAR 0 3
124348: PUSH
124349: LD_INT 2
124351: ARRAY
124352: PPUSH
124353: CALL_OW 235
124357: GO 124332
124359: POP
124360: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
124361: LD_ADDR_EXP 222
124365: PUSH
124366: LD_EXP 222
124370: PPUSH
124371: LD_VAR 0 4
124375: PPUSH
124376: EMPTY
124377: PPUSH
124378: CALL_OW 1
124382: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
124383: LD_VAR 0 1
124387: PPUSH
124388: LD_INT 0
124390: PPUSH
124391: CALL_OW 505
// end ; end ;
124395: LD_VAR 0 2
124399: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
124400: LD_INT 0
124402: PPUSH
124403: PPUSH
124404: PPUSH
// if not hack in hackTanks or not vehicles then
124405: LD_VAR 0 1
124409: PUSH
124410: LD_EXP 221
124414: IN
124415: NOT
124416: PUSH
124417: LD_VAR 0 2
124421: NOT
124422: OR
124423: IFFALSE 124427
// exit ;
124425: GO 124702
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
124427: LD_ADDR_VAR 0 2
124431: PUSH
124432: LD_VAR 0 1
124436: PPUSH
124437: LD_VAR 0 2
124441: PPUSH
124442: LD_INT 1
124444: PPUSH
124445: LD_INT 1
124447: PPUSH
124448: CALL 71494 0 4
124452: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
124453: LD_ADDR_VAR 0 5
124457: PUSH
124458: LD_EXP 221
124462: PPUSH
124463: LD_VAR 0 1
124467: PPUSH
124468: CALL 70844 0 2
124472: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
124473: LD_EXP 222
124477: PUSH
124478: LD_VAR 0 5
124482: ARRAY
124483: PUSH
124484: LD_EXP 223
124488: LESS
124489: IFFALSE 124678
// begin for i := 1 to vehicles do
124491: LD_ADDR_VAR 0 4
124495: PUSH
124496: DOUBLE
124497: LD_INT 1
124499: DEC
124500: ST_TO_ADDR
124501: LD_VAR 0 2
124505: PUSH
124506: FOR_TO
124507: IFFALSE 124676
// begin if hackTanksCaptured [ index ] = hackLimit then
124509: LD_EXP 222
124513: PUSH
124514: LD_VAR 0 5
124518: ARRAY
124519: PUSH
124520: LD_EXP 223
124524: EQUAL
124525: IFFALSE 124529
// break ;
124527: GO 124676
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
124529: LD_ADDR_EXP 225
124533: PUSH
124534: LD_EXP 225
124538: PPUSH
124539: LD_VAR 0 5
124543: PPUSH
124544: LD_EXP 225
124548: PUSH
124549: LD_VAR 0 5
124553: ARRAY
124554: PUSH
124555: LD_INT 1
124557: PLUS
124558: PPUSH
124559: CALL_OW 1
124563: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
124564: LD_ADDR_EXP 222
124568: PUSH
124569: LD_EXP 222
124573: PPUSH
124574: LD_VAR 0 5
124578: PUSH
124579: LD_EXP 222
124583: PUSH
124584: LD_VAR 0 5
124588: ARRAY
124589: PUSH
124590: LD_INT 1
124592: PLUS
124593: PUSH
124594: EMPTY
124595: LIST
124596: LIST
124597: PPUSH
124598: LD_VAR 0 2
124602: PUSH
124603: LD_VAR 0 4
124607: ARRAY
124608: PUSH
124609: LD_VAR 0 2
124613: PUSH
124614: LD_VAR 0 4
124618: ARRAY
124619: PPUSH
124620: CALL_OW 255
124624: PUSH
124625: EMPTY
124626: LIST
124627: LIST
124628: PPUSH
124629: CALL 71059 0 3
124633: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
124634: LD_VAR 0 2
124638: PUSH
124639: LD_VAR 0 4
124643: ARRAY
124644: PPUSH
124645: LD_VAR 0 1
124649: PPUSH
124650: CALL_OW 255
124654: PPUSH
124655: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
124659: LD_VAR 0 2
124663: PUSH
124664: LD_VAR 0 4
124668: ARRAY
124669: PPUSH
124670: CALL_OW 141
// end ;
124674: GO 124506
124676: POP
124677: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
124678: LD_VAR 0 1
124682: PPUSH
124683: LD_EXP 222
124687: PUSH
124688: LD_VAR 0 5
124692: ARRAY
124693: PUSH
124694: LD_INT 0
124696: PLUS
124697: PPUSH
124698: CALL_OW 505
// end ;
124702: LD_VAR 0 3
124706: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
124707: LD_INT 0
124709: PPUSH
124710: PPUSH
124711: PPUSH
124712: PPUSH
// if not hack in hackTanks then
124713: LD_VAR 0 1
124717: PUSH
124718: LD_EXP 221
124722: IN
124723: NOT
124724: IFFALSE 124728
// exit ;
124726: GO 124968
// index := GetElementIndex ( hackTanks , hack ) ;
124728: LD_ADDR_VAR 0 4
124732: PUSH
124733: LD_EXP 221
124737: PPUSH
124738: LD_VAR 0 1
124742: PPUSH
124743: CALL 70844 0 2
124747: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
124748: LD_ADDR_VAR 0 3
124752: PUSH
124753: DOUBLE
124754: LD_EXP 222
124758: PUSH
124759: LD_VAR 0 4
124763: ARRAY
124764: INC
124765: ST_TO_ADDR
124766: LD_INT 1
124768: PUSH
124769: FOR_DOWNTO
124770: IFFALSE 124942
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
124772: LD_ADDR_VAR 0 5
124776: PUSH
124777: LD_EXP 222
124781: PUSH
124782: LD_VAR 0 4
124786: ARRAY
124787: PUSH
124788: LD_VAR 0 3
124792: ARRAY
124793: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
124794: LD_VAR 0 5
124798: PUSH
124799: LD_INT 1
124801: ARRAY
124802: PPUSH
124803: CALL_OW 302
124807: NOT
124808: PUSH
124809: LD_VAR 0 5
124813: PUSH
124814: LD_INT 1
124816: ARRAY
124817: PPUSH
124818: CALL_OW 255
124822: PUSH
124823: LD_VAR 0 1
124827: PPUSH
124828: CALL_OW 255
124832: NONEQUAL
124833: OR
124834: IFFALSE 124940
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
124836: LD_VAR 0 5
124840: PUSH
124841: LD_INT 1
124843: ARRAY
124844: PPUSH
124845: CALL_OW 305
124849: PUSH
124850: LD_VAR 0 5
124854: PUSH
124855: LD_INT 1
124857: ARRAY
124858: PPUSH
124859: CALL_OW 255
124863: PUSH
124864: LD_VAR 0 1
124868: PPUSH
124869: CALL_OW 255
124873: EQUAL
124874: AND
124875: IFFALSE 124899
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
124877: LD_VAR 0 5
124881: PUSH
124882: LD_INT 1
124884: ARRAY
124885: PPUSH
124886: LD_VAR 0 5
124890: PUSH
124891: LD_INT 2
124893: ARRAY
124894: PPUSH
124895: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
124899: LD_ADDR_EXP 222
124903: PUSH
124904: LD_EXP 222
124908: PPUSH
124909: LD_VAR 0 4
124913: PPUSH
124914: LD_EXP 222
124918: PUSH
124919: LD_VAR 0 4
124923: ARRAY
124924: PPUSH
124925: LD_VAR 0 3
124929: PPUSH
124930: CALL_OW 3
124934: PPUSH
124935: CALL_OW 1
124939: ST_TO_ADDR
// end ; end ;
124940: GO 124769
124942: POP
124943: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
124944: LD_VAR 0 1
124948: PPUSH
124949: LD_EXP 222
124953: PUSH
124954: LD_VAR 0 4
124958: ARRAY
124959: PUSH
124960: LD_INT 0
124962: PLUS
124963: PPUSH
124964: CALL_OW 505
// end ;
124968: LD_VAR 0 2
124972: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
124973: LD_INT 0
124975: PPUSH
124976: PPUSH
124977: PPUSH
124978: PPUSH
// if not hack in hackTanks then
124979: LD_VAR 0 1
124983: PUSH
124984: LD_EXP 221
124988: IN
124989: NOT
124990: IFFALSE 124994
// exit ;
124992: GO 125079
// index := GetElementIndex ( hackTanks , hack ) ;
124994: LD_ADDR_VAR 0 5
124998: PUSH
124999: LD_EXP 221
125003: PPUSH
125004: LD_VAR 0 1
125008: PPUSH
125009: CALL 70844 0 2
125013: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
125014: LD_ADDR_VAR 0 4
125018: PUSH
125019: DOUBLE
125020: LD_INT 1
125022: DEC
125023: ST_TO_ADDR
125024: LD_EXP 222
125028: PUSH
125029: LD_VAR 0 5
125033: ARRAY
125034: PUSH
125035: FOR_TO
125036: IFFALSE 125077
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
125038: LD_EXP 222
125042: PUSH
125043: LD_VAR 0 5
125047: ARRAY
125048: PUSH
125049: LD_VAR 0 4
125053: ARRAY
125054: PUSH
125055: LD_INT 1
125057: ARRAY
125058: PUSH
125059: LD_VAR 0 2
125063: EQUAL
125064: IFFALSE 125075
// KillUnit ( vehicle ) ;
125066: LD_VAR 0 2
125070: PPUSH
125071: CALL_OW 66
125075: GO 125035
125077: POP
125078: POP
// end ;
125079: LD_VAR 0 3
125083: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
125084: LD_EXP 226
125088: NOT
125089: IFFALSE 125124
125091: GO 125093
125093: DISABLE
// begin initMiner := true ;
125094: LD_ADDR_EXP 226
125098: PUSH
125099: LD_INT 1
125101: ST_TO_ADDR
// minersList := [ ] ;
125102: LD_ADDR_EXP 227
125106: PUSH
125107: EMPTY
125108: ST_TO_ADDR
// minerMinesList := [ ] ;
125109: LD_ADDR_EXP 228
125113: PUSH
125114: EMPTY
125115: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
125116: LD_ADDR_EXP 229
125120: PUSH
125121: LD_INT 5
125123: ST_TO_ADDR
// end ;
125124: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
125125: LD_EXP 226
125129: PUSH
125130: LD_INT 34
125132: PUSH
125133: LD_EXP 102
125137: PUSH
125138: EMPTY
125139: LIST
125140: LIST
125141: PPUSH
125142: CALL_OW 69
125146: AND
125147: IFFALSE 125610
125149: GO 125151
125151: DISABLE
125152: LD_INT 0
125154: PPUSH
125155: PPUSH
125156: PPUSH
125157: PPUSH
// begin enable ;
125158: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
125159: LD_ADDR_VAR 0 1
125163: PUSH
125164: LD_INT 34
125166: PUSH
125167: LD_EXP 102
125171: PUSH
125172: EMPTY
125173: LIST
125174: LIST
125175: PPUSH
125176: CALL_OW 69
125180: PUSH
125181: FOR_IN
125182: IFFALSE 125254
// begin if not i in minersList then
125184: LD_VAR 0 1
125188: PUSH
125189: LD_EXP 227
125193: IN
125194: NOT
125195: IFFALSE 125252
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
125197: LD_ADDR_EXP 227
125201: PUSH
125202: LD_EXP 227
125206: PPUSH
125207: LD_EXP 227
125211: PUSH
125212: LD_INT 1
125214: PLUS
125215: PPUSH
125216: LD_VAR 0 1
125220: PPUSH
125221: CALL_OW 1
125225: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
125226: LD_ADDR_EXP 228
125230: PUSH
125231: LD_EXP 228
125235: PPUSH
125236: LD_EXP 228
125240: PUSH
125241: LD_INT 1
125243: PLUS
125244: PPUSH
125245: EMPTY
125246: PPUSH
125247: CALL_OW 1
125251: ST_TO_ADDR
// end end ;
125252: GO 125181
125254: POP
125255: POP
// for i := minerMinesList downto 1 do
125256: LD_ADDR_VAR 0 1
125260: PUSH
125261: DOUBLE
125262: LD_EXP 228
125266: INC
125267: ST_TO_ADDR
125268: LD_INT 1
125270: PUSH
125271: FOR_DOWNTO
125272: IFFALSE 125608
// begin if IsLive ( minersList [ i ] ) then
125274: LD_EXP 227
125278: PUSH
125279: LD_VAR 0 1
125283: ARRAY
125284: PPUSH
125285: CALL_OW 300
125289: IFFALSE 125317
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
125291: LD_EXP 227
125295: PUSH
125296: LD_VAR 0 1
125300: ARRAY
125301: PPUSH
125302: LD_EXP 228
125306: PUSH
125307: LD_VAR 0 1
125311: ARRAY
125312: PPUSH
125313: CALL_OW 505
// if not minerMinesList [ i ] then
125317: LD_EXP 228
125321: PUSH
125322: LD_VAR 0 1
125326: ARRAY
125327: NOT
125328: IFFALSE 125332
// continue ;
125330: GO 125271
// for j := minerMinesList [ i ] downto 1 do
125332: LD_ADDR_VAR 0 2
125336: PUSH
125337: DOUBLE
125338: LD_EXP 228
125342: PUSH
125343: LD_VAR 0 1
125347: ARRAY
125348: INC
125349: ST_TO_ADDR
125350: LD_INT 1
125352: PUSH
125353: FOR_DOWNTO
125354: IFFALSE 125604
// begin side := GetSide ( minersList [ i ] ) ;
125356: LD_ADDR_VAR 0 3
125360: PUSH
125361: LD_EXP 227
125365: PUSH
125366: LD_VAR 0 1
125370: ARRAY
125371: PPUSH
125372: CALL_OW 255
125376: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
125377: LD_ADDR_VAR 0 4
125381: PUSH
125382: LD_EXP 228
125386: PUSH
125387: LD_VAR 0 1
125391: ARRAY
125392: PUSH
125393: LD_VAR 0 2
125397: ARRAY
125398: PUSH
125399: LD_INT 1
125401: ARRAY
125402: PPUSH
125403: LD_EXP 228
125407: PUSH
125408: LD_VAR 0 1
125412: ARRAY
125413: PUSH
125414: LD_VAR 0 2
125418: ARRAY
125419: PUSH
125420: LD_INT 2
125422: ARRAY
125423: PPUSH
125424: CALL_OW 428
125428: ST_TO_ADDR
// if not tmp then
125429: LD_VAR 0 4
125433: NOT
125434: IFFALSE 125438
// continue ;
125436: GO 125353
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
125438: LD_VAR 0 4
125442: PUSH
125443: LD_INT 81
125445: PUSH
125446: LD_VAR 0 3
125450: PUSH
125451: EMPTY
125452: LIST
125453: LIST
125454: PPUSH
125455: CALL_OW 69
125459: IN
125460: PUSH
125461: LD_EXP 228
125465: PUSH
125466: LD_VAR 0 1
125470: ARRAY
125471: PUSH
125472: LD_VAR 0 2
125476: ARRAY
125477: PUSH
125478: LD_INT 1
125480: ARRAY
125481: PPUSH
125482: LD_EXP 228
125486: PUSH
125487: LD_VAR 0 1
125491: ARRAY
125492: PUSH
125493: LD_VAR 0 2
125497: ARRAY
125498: PUSH
125499: LD_INT 2
125501: ARRAY
125502: PPUSH
125503: CALL_OW 458
125507: AND
125508: IFFALSE 125602
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
125510: LD_EXP 228
125514: PUSH
125515: LD_VAR 0 1
125519: ARRAY
125520: PUSH
125521: LD_VAR 0 2
125525: ARRAY
125526: PUSH
125527: LD_INT 1
125529: ARRAY
125530: PPUSH
125531: LD_EXP 228
125535: PUSH
125536: LD_VAR 0 1
125540: ARRAY
125541: PUSH
125542: LD_VAR 0 2
125546: ARRAY
125547: PUSH
125548: LD_INT 2
125550: ARRAY
125551: PPUSH
125552: LD_VAR 0 3
125556: PPUSH
125557: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
125561: LD_ADDR_EXP 228
125565: PUSH
125566: LD_EXP 228
125570: PPUSH
125571: LD_VAR 0 1
125575: PPUSH
125576: LD_EXP 228
125580: PUSH
125581: LD_VAR 0 1
125585: ARRAY
125586: PPUSH
125587: LD_VAR 0 2
125591: PPUSH
125592: CALL_OW 3
125596: PPUSH
125597: CALL_OW 1
125601: ST_TO_ADDR
// end ; end ;
125602: GO 125353
125604: POP
125605: POP
// end ;
125606: GO 125271
125608: POP
125609: POP
// end ;
125610: PPOPN 4
125612: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
125613: LD_INT 0
125615: PPUSH
125616: PPUSH
// result := false ;
125617: LD_ADDR_VAR 0 4
125621: PUSH
125622: LD_INT 0
125624: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
125625: LD_VAR 0 1
125629: PPUSH
125630: CALL_OW 264
125634: PUSH
125635: LD_EXP 102
125639: EQUAL
125640: NOT
125641: IFFALSE 125645
// exit ;
125643: GO 125885
// index := GetElementIndex ( minersList , unit ) ;
125645: LD_ADDR_VAR 0 5
125649: PUSH
125650: LD_EXP 227
125654: PPUSH
125655: LD_VAR 0 1
125659: PPUSH
125660: CALL 70844 0 2
125664: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
125665: LD_EXP 228
125669: PUSH
125670: LD_VAR 0 5
125674: ARRAY
125675: PUSH
125676: LD_EXP 229
125680: GREATEREQUAL
125681: IFFALSE 125685
// exit ;
125683: GO 125885
// ComMoveXY ( unit , x , y ) ;
125685: LD_VAR 0 1
125689: PPUSH
125690: LD_VAR 0 2
125694: PPUSH
125695: LD_VAR 0 3
125699: PPUSH
125700: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
125704: LD_INT 35
125706: PPUSH
125707: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
125711: LD_VAR 0 1
125715: PPUSH
125716: LD_VAR 0 2
125720: PPUSH
125721: LD_VAR 0 3
125725: PPUSH
125726: CALL 102130 0 3
125730: NOT
125731: PUSH
125732: LD_VAR 0 1
125736: PPUSH
125737: CALL_OW 314
125741: AND
125742: IFFALSE 125746
// exit ;
125744: GO 125885
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
125746: LD_VAR 0 2
125750: PPUSH
125751: LD_VAR 0 3
125755: PPUSH
125756: CALL_OW 428
125760: PUSH
125761: LD_VAR 0 1
125765: EQUAL
125766: PUSH
125767: LD_VAR 0 1
125771: PPUSH
125772: CALL_OW 314
125776: NOT
125777: AND
125778: IFFALSE 125704
// PlaySoundXY ( x , y , PlantMine ) ;
125780: LD_VAR 0 2
125784: PPUSH
125785: LD_VAR 0 3
125789: PPUSH
125790: LD_STRING PlantMine
125792: PPUSH
125793: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
125797: LD_VAR 0 2
125801: PPUSH
125802: LD_VAR 0 3
125806: PPUSH
125807: LD_VAR 0 1
125811: PPUSH
125812: CALL_OW 255
125816: PPUSH
125817: LD_INT 0
125819: PPUSH
125820: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
125824: LD_ADDR_EXP 228
125828: PUSH
125829: LD_EXP 228
125833: PPUSH
125834: LD_VAR 0 5
125838: PUSH
125839: LD_EXP 228
125843: PUSH
125844: LD_VAR 0 5
125848: ARRAY
125849: PUSH
125850: LD_INT 1
125852: PLUS
125853: PUSH
125854: EMPTY
125855: LIST
125856: LIST
125857: PPUSH
125858: LD_VAR 0 2
125862: PUSH
125863: LD_VAR 0 3
125867: PUSH
125868: EMPTY
125869: LIST
125870: LIST
125871: PPUSH
125872: CALL 71059 0 3
125876: ST_TO_ADDR
// result := true ;
125877: LD_ADDR_VAR 0 4
125881: PUSH
125882: LD_INT 1
125884: ST_TO_ADDR
// end ;
125885: LD_VAR 0 4
125889: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
125890: LD_INT 0
125892: PPUSH
125893: PPUSH
125894: PPUSH
// if not unit in minersList then
125895: LD_VAR 0 1
125899: PUSH
125900: LD_EXP 227
125904: IN
125905: NOT
125906: IFFALSE 125910
// exit ;
125908: GO 126302
// index := GetElementIndex ( minersList , unit ) ;
125910: LD_ADDR_VAR 0 6
125914: PUSH
125915: LD_EXP 227
125919: PPUSH
125920: LD_VAR 0 1
125924: PPUSH
125925: CALL 70844 0 2
125929: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
125930: LD_ADDR_VAR 0 5
125934: PUSH
125935: DOUBLE
125936: LD_EXP 228
125940: PUSH
125941: LD_VAR 0 6
125945: ARRAY
125946: INC
125947: ST_TO_ADDR
125948: LD_INT 1
125950: PUSH
125951: FOR_DOWNTO
125952: IFFALSE 126113
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
125954: LD_EXP 228
125958: PUSH
125959: LD_VAR 0 6
125963: ARRAY
125964: PUSH
125965: LD_VAR 0 5
125969: ARRAY
125970: PUSH
125971: LD_INT 1
125973: ARRAY
125974: PUSH
125975: LD_VAR 0 2
125979: EQUAL
125980: PUSH
125981: LD_EXP 228
125985: PUSH
125986: LD_VAR 0 6
125990: ARRAY
125991: PUSH
125992: LD_VAR 0 5
125996: ARRAY
125997: PUSH
125998: LD_INT 2
126000: ARRAY
126001: PUSH
126002: LD_VAR 0 3
126006: EQUAL
126007: AND
126008: IFFALSE 126111
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
126010: LD_EXP 228
126014: PUSH
126015: LD_VAR 0 6
126019: ARRAY
126020: PUSH
126021: LD_VAR 0 5
126025: ARRAY
126026: PUSH
126027: LD_INT 1
126029: ARRAY
126030: PPUSH
126031: LD_EXP 228
126035: PUSH
126036: LD_VAR 0 6
126040: ARRAY
126041: PUSH
126042: LD_VAR 0 5
126046: ARRAY
126047: PUSH
126048: LD_INT 2
126050: ARRAY
126051: PPUSH
126052: LD_VAR 0 1
126056: PPUSH
126057: CALL_OW 255
126061: PPUSH
126062: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
126066: LD_ADDR_EXP 228
126070: PUSH
126071: LD_EXP 228
126075: PPUSH
126076: LD_VAR 0 6
126080: PPUSH
126081: LD_EXP 228
126085: PUSH
126086: LD_VAR 0 6
126090: ARRAY
126091: PPUSH
126092: LD_VAR 0 5
126096: PPUSH
126097: CALL_OW 3
126101: PPUSH
126102: CALL_OW 1
126106: ST_TO_ADDR
// exit ;
126107: POP
126108: POP
126109: GO 126302
// end ; end ;
126111: GO 125951
126113: POP
126114: POP
// for i := minerMinesList [ index ] downto 1 do
126115: LD_ADDR_VAR 0 5
126119: PUSH
126120: DOUBLE
126121: LD_EXP 228
126125: PUSH
126126: LD_VAR 0 6
126130: ARRAY
126131: INC
126132: ST_TO_ADDR
126133: LD_INT 1
126135: PUSH
126136: FOR_DOWNTO
126137: IFFALSE 126300
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
126139: LD_EXP 228
126143: PUSH
126144: LD_VAR 0 6
126148: ARRAY
126149: PUSH
126150: LD_VAR 0 5
126154: ARRAY
126155: PUSH
126156: LD_INT 1
126158: ARRAY
126159: PPUSH
126160: LD_EXP 228
126164: PUSH
126165: LD_VAR 0 6
126169: ARRAY
126170: PUSH
126171: LD_VAR 0 5
126175: ARRAY
126176: PUSH
126177: LD_INT 2
126179: ARRAY
126180: PPUSH
126181: LD_VAR 0 2
126185: PPUSH
126186: LD_VAR 0 3
126190: PPUSH
126191: CALL_OW 298
126195: PUSH
126196: LD_INT 6
126198: LESS
126199: IFFALSE 126298
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
126201: LD_EXP 228
126205: PUSH
126206: LD_VAR 0 6
126210: ARRAY
126211: PUSH
126212: LD_VAR 0 5
126216: ARRAY
126217: PUSH
126218: LD_INT 1
126220: ARRAY
126221: PPUSH
126222: LD_EXP 228
126226: PUSH
126227: LD_VAR 0 6
126231: ARRAY
126232: PUSH
126233: LD_VAR 0 5
126237: ARRAY
126238: PUSH
126239: LD_INT 2
126241: ARRAY
126242: PPUSH
126243: LD_VAR 0 1
126247: PPUSH
126248: CALL_OW 255
126252: PPUSH
126253: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
126257: LD_ADDR_EXP 228
126261: PUSH
126262: LD_EXP 228
126266: PPUSH
126267: LD_VAR 0 6
126271: PPUSH
126272: LD_EXP 228
126276: PUSH
126277: LD_VAR 0 6
126281: ARRAY
126282: PPUSH
126283: LD_VAR 0 5
126287: PPUSH
126288: CALL_OW 3
126292: PPUSH
126293: CALL_OW 1
126297: ST_TO_ADDR
// end ; end ;
126298: GO 126136
126300: POP
126301: POP
// end ;
126302: LD_VAR 0 4
126306: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
126307: LD_INT 0
126309: PPUSH
126310: PPUSH
126311: PPUSH
126312: PPUSH
126313: PPUSH
126314: PPUSH
126315: PPUSH
126316: PPUSH
126317: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
126318: LD_VAR 0 1
126322: PPUSH
126323: CALL_OW 264
126327: PUSH
126328: LD_EXP 102
126332: EQUAL
126333: NOT
126334: PUSH
126335: LD_VAR 0 1
126339: PUSH
126340: LD_EXP 227
126344: IN
126345: NOT
126346: OR
126347: IFFALSE 126351
// exit ;
126349: GO 126673
// index := GetElementIndex ( minersList , unit ) ;
126351: LD_ADDR_VAR 0 6
126355: PUSH
126356: LD_EXP 227
126360: PPUSH
126361: LD_VAR 0 1
126365: PPUSH
126366: CALL 70844 0 2
126370: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
126371: LD_ADDR_VAR 0 8
126375: PUSH
126376: LD_EXP 229
126380: PUSH
126381: LD_EXP 228
126385: PUSH
126386: LD_VAR 0 6
126390: ARRAY
126391: MINUS
126392: ST_TO_ADDR
// if not minesFreeAmount then
126393: LD_VAR 0 8
126397: NOT
126398: IFFALSE 126402
// exit ;
126400: GO 126673
// tmp := [ ] ;
126402: LD_ADDR_VAR 0 7
126406: PUSH
126407: EMPTY
126408: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
126409: LD_ADDR_VAR 0 5
126413: PUSH
126414: DOUBLE
126415: LD_INT 1
126417: DEC
126418: ST_TO_ADDR
126419: LD_VAR 0 8
126423: PUSH
126424: FOR_TO
126425: IFFALSE 126620
// begin _d := rand ( 0 , 5 ) ;
126427: LD_ADDR_VAR 0 11
126431: PUSH
126432: LD_INT 0
126434: PPUSH
126435: LD_INT 5
126437: PPUSH
126438: CALL_OW 12
126442: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
126443: LD_ADDR_VAR 0 12
126447: PUSH
126448: LD_INT 2
126450: PPUSH
126451: LD_INT 6
126453: PPUSH
126454: CALL_OW 12
126458: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
126459: LD_ADDR_VAR 0 9
126463: PUSH
126464: LD_VAR 0 2
126468: PPUSH
126469: LD_VAR 0 11
126473: PPUSH
126474: LD_VAR 0 12
126478: PPUSH
126479: CALL_OW 272
126483: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
126484: LD_ADDR_VAR 0 10
126488: PUSH
126489: LD_VAR 0 3
126493: PPUSH
126494: LD_VAR 0 11
126498: PPUSH
126499: LD_VAR 0 12
126503: PPUSH
126504: CALL_OW 273
126508: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
126509: LD_VAR 0 9
126513: PPUSH
126514: LD_VAR 0 10
126518: PPUSH
126519: CALL_OW 488
126523: PUSH
126524: LD_VAR 0 9
126528: PUSH
126529: LD_VAR 0 10
126533: PUSH
126534: EMPTY
126535: LIST
126536: LIST
126537: PUSH
126538: LD_VAR 0 7
126542: IN
126543: NOT
126544: AND
126545: PUSH
126546: LD_VAR 0 9
126550: PPUSH
126551: LD_VAR 0 10
126555: PPUSH
126556: CALL_OW 458
126560: NOT
126561: AND
126562: IFFALSE 126604
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
126564: LD_ADDR_VAR 0 7
126568: PUSH
126569: LD_VAR 0 7
126573: PPUSH
126574: LD_VAR 0 7
126578: PUSH
126579: LD_INT 1
126581: PLUS
126582: PPUSH
126583: LD_VAR 0 9
126587: PUSH
126588: LD_VAR 0 10
126592: PUSH
126593: EMPTY
126594: LIST
126595: LIST
126596: PPUSH
126597: CALL_OW 1
126601: ST_TO_ADDR
126602: GO 126618
// i := i - 1 ;
126604: LD_ADDR_VAR 0 5
126608: PUSH
126609: LD_VAR 0 5
126613: PUSH
126614: LD_INT 1
126616: MINUS
126617: ST_TO_ADDR
// end ;
126618: GO 126424
126620: POP
126621: POP
// for i in tmp do
126622: LD_ADDR_VAR 0 5
126626: PUSH
126627: LD_VAR 0 7
126631: PUSH
126632: FOR_IN
126633: IFFALSE 126671
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
126635: LD_VAR 0 1
126639: PPUSH
126640: LD_VAR 0 5
126644: PUSH
126645: LD_INT 1
126647: ARRAY
126648: PPUSH
126649: LD_VAR 0 5
126653: PUSH
126654: LD_INT 2
126656: ARRAY
126657: PPUSH
126658: CALL 125613 0 3
126662: NOT
126663: IFFALSE 126669
// exit ;
126665: POP
126666: POP
126667: GO 126673
126669: GO 126632
126671: POP
126672: POP
// end ;
126673: LD_VAR 0 4
126677: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
126678: LD_INT 0
126680: PPUSH
126681: PPUSH
126682: PPUSH
126683: PPUSH
126684: PPUSH
126685: PPUSH
126686: PPUSH
// if not GetClass ( unit ) = class_sniper then
126687: LD_VAR 0 1
126691: PPUSH
126692: CALL_OW 257
126696: PUSH
126697: LD_INT 5
126699: EQUAL
126700: NOT
126701: IFFALSE 126705
// exit ;
126703: GO 127093
// dist := 8 ;
126705: LD_ADDR_VAR 0 5
126709: PUSH
126710: LD_INT 8
126712: ST_TO_ADDR
// viewRange := 12 ;
126713: LD_ADDR_VAR 0 7
126717: PUSH
126718: LD_INT 12
126720: ST_TO_ADDR
// side := GetSide ( unit ) ;
126721: LD_ADDR_VAR 0 6
126725: PUSH
126726: LD_VAR 0 1
126730: PPUSH
126731: CALL_OW 255
126735: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
126736: LD_INT 61
126738: PPUSH
126739: LD_VAR 0 6
126743: PPUSH
126744: CALL_OW 321
126748: PUSH
126749: LD_INT 2
126751: EQUAL
126752: IFFALSE 126762
// viewRange := 16 ;
126754: LD_ADDR_VAR 0 7
126758: PUSH
126759: LD_INT 16
126761: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
126762: LD_VAR 0 1
126766: PPUSH
126767: LD_VAR 0 2
126771: PPUSH
126772: LD_VAR 0 3
126776: PPUSH
126777: CALL_OW 297
126781: PUSH
126782: LD_VAR 0 5
126786: GREATER
126787: IFFALSE 126866
// begin ComMoveXY ( unit , x , y ) ;
126789: LD_VAR 0 1
126793: PPUSH
126794: LD_VAR 0 2
126798: PPUSH
126799: LD_VAR 0 3
126803: PPUSH
126804: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
126808: LD_INT 35
126810: PPUSH
126811: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
126815: LD_VAR 0 1
126819: PPUSH
126820: LD_VAR 0 2
126824: PPUSH
126825: LD_VAR 0 3
126829: PPUSH
126830: CALL 102130 0 3
126834: NOT
126835: IFFALSE 126839
// exit ;
126837: GO 127093
// until GetDistUnitXY ( unit , x , y ) < dist ;
126839: LD_VAR 0 1
126843: PPUSH
126844: LD_VAR 0 2
126848: PPUSH
126849: LD_VAR 0 3
126853: PPUSH
126854: CALL_OW 297
126858: PUSH
126859: LD_VAR 0 5
126863: LESS
126864: IFFALSE 126808
// end ; ComTurnXY ( unit , x , y ) ;
126866: LD_VAR 0 1
126870: PPUSH
126871: LD_VAR 0 2
126875: PPUSH
126876: LD_VAR 0 3
126880: PPUSH
126881: CALL_OW 118
// wait ( 5 ) ;
126885: LD_INT 5
126887: PPUSH
126888: CALL_OW 67
// _d := GetDir ( unit ) ;
126892: LD_ADDR_VAR 0 10
126896: PUSH
126897: LD_VAR 0 1
126901: PPUSH
126902: CALL_OW 254
126906: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
126907: LD_ADDR_VAR 0 8
126911: PUSH
126912: LD_VAR 0 1
126916: PPUSH
126917: CALL_OW 250
126921: PPUSH
126922: LD_VAR 0 10
126926: PPUSH
126927: LD_VAR 0 5
126931: PPUSH
126932: CALL_OW 272
126936: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
126937: LD_ADDR_VAR 0 9
126941: PUSH
126942: LD_VAR 0 1
126946: PPUSH
126947: CALL_OW 251
126951: PPUSH
126952: LD_VAR 0 10
126956: PPUSH
126957: LD_VAR 0 5
126961: PPUSH
126962: CALL_OW 273
126966: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
126967: LD_VAR 0 8
126971: PPUSH
126972: LD_VAR 0 9
126976: PPUSH
126977: CALL_OW 488
126981: NOT
126982: IFFALSE 126986
// exit ;
126984: GO 127093
// ComAnimCustom ( unit , 1 ) ;
126986: LD_VAR 0 1
126990: PPUSH
126991: LD_INT 1
126993: PPUSH
126994: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
126998: LD_VAR 0 8
127002: PPUSH
127003: LD_VAR 0 9
127007: PPUSH
127008: LD_VAR 0 6
127012: PPUSH
127013: LD_VAR 0 7
127017: PPUSH
127018: CALL_OW 330
// repeat wait ( 1 ) ;
127022: LD_INT 1
127024: PPUSH
127025: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
127029: LD_VAR 0 1
127033: PPUSH
127034: CALL_OW 316
127038: PUSH
127039: LD_VAR 0 1
127043: PPUSH
127044: CALL_OW 314
127048: OR
127049: PUSH
127050: LD_VAR 0 1
127054: PPUSH
127055: CALL_OW 302
127059: NOT
127060: OR
127061: PUSH
127062: LD_VAR 0 1
127066: PPUSH
127067: CALL_OW 301
127071: OR
127072: IFFALSE 127022
// RemoveSeeing ( _x , _y , side ) ;
127074: LD_VAR 0 8
127078: PPUSH
127079: LD_VAR 0 9
127083: PPUSH
127084: LD_VAR 0 6
127088: PPUSH
127089: CALL_OW 331
// end ; end_of_file
127093: LD_VAR 0 4
127097: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
127098: LD_INT 0
127100: PPUSH
127101: PPUSH
127102: PPUSH
127103: PPUSH
127104: PPUSH
127105: PPUSH
127106: PPUSH
127107: PPUSH
127108: PPUSH
127109: PPUSH
127110: PPUSH
127111: PPUSH
127112: PPUSH
127113: PPUSH
127114: PPUSH
127115: PPUSH
127116: PPUSH
127117: PPUSH
127118: PPUSH
127119: PPUSH
127120: PPUSH
127121: PPUSH
127122: PPUSH
127123: PPUSH
127124: PPUSH
127125: PPUSH
127126: PPUSH
127127: PPUSH
127128: PPUSH
127129: PPUSH
127130: PPUSH
127131: PPUSH
127132: PPUSH
127133: PPUSH
// if not list then
127134: LD_VAR 0 1
127138: NOT
127139: IFFALSE 127143
// exit ;
127141: GO 131802
// base := list [ 1 ] ;
127143: LD_ADDR_VAR 0 3
127147: PUSH
127148: LD_VAR 0 1
127152: PUSH
127153: LD_INT 1
127155: ARRAY
127156: ST_TO_ADDR
// group := list [ 2 ] ;
127157: LD_ADDR_VAR 0 4
127161: PUSH
127162: LD_VAR 0 1
127166: PUSH
127167: LD_INT 2
127169: ARRAY
127170: ST_TO_ADDR
// path := list [ 3 ] ;
127171: LD_ADDR_VAR 0 5
127175: PUSH
127176: LD_VAR 0 1
127180: PUSH
127181: LD_INT 3
127183: ARRAY
127184: ST_TO_ADDR
// flags := list [ 4 ] ;
127185: LD_ADDR_VAR 0 6
127189: PUSH
127190: LD_VAR 0 1
127194: PUSH
127195: LD_INT 4
127197: ARRAY
127198: ST_TO_ADDR
// mined := [ ] ;
127199: LD_ADDR_VAR 0 27
127203: PUSH
127204: EMPTY
127205: ST_TO_ADDR
// bombed := [ ] ;
127206: LD_ADDR_VAR 0 28
127210: PUSH
127211: EMPTY
127212: ST_TO_ADDR
// healers := [ ] ;
127213: LD_ADDR_VAR 0 31
127217: PUSH
127218: EMPTY
127219: ST_TO_ADDR
// to_heal := [ ] ;
127220: LD_ADDR_VAR 0 30
127224: PUSH
127225: EMPTY
127226: ST_TO_ADDR
// repairs := [ ] ;
127227: LD_ADDR_VAR 0 33
127231: PUSH
127232: EMPTY
127233: ST_TO_ADDR
// to_repair := [ ] ;
127234: LD_ADDR_VAR 0 32
127238: PUSH
127239: EMPTY
127240: ST_TO_ADDR
// if not group or not path then
127241: LD_VAR 0 4
127245: NOT
127246: PUSH
127247: LD_VAR 0 5
127251: NOT
127252: OR
127253: IFFALSE 127257
// exit ;
127255: GO 131802
// side := GetSide ( group [ 1 ] ) ;
127257: LD_ADDR_VAR 0 35
127261: PUSH
127262: LD_VAR 0 4
127266: PUSH
127267: LD_INT 1
127269: ARRAY
127270: PPUSH
127271: CALL_OW 255
127275: ST_TO_ADDR
// if flags then
127276: LD_VAR 0 6
127280: IFFALSE 127424
// begin f_ignore_area := flags [ 1 ] ;
127282: LD_ADDR_VAR 0 17
127286: PUSH
127287: LD_VAR 0 6
127291: PUSH
127292: LD_INT 1
127294: ARRAY
127295: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
127296: LD_ADDR_VAR 0 18
127300: PUSH
127301: LD_VAR 0 6
127305: PUSH
127306: LD_INT 2
127308: ARRAY
127309: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
127310: LD_ADDR_VAR 0 19
127314: PUSH
127315: LD_VAR 0 6
127319: PUSH
127320: LD_INT 3
127322: ARRAY
127323: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
127324: LD_ADDR_VAR 0 20
127328: PUSH
127329: LD_VAR 0 6
127333: PUSH
127334: LD_INT 4
127336: ARRAY
127337: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
127338: LD_ADDR_VAR 0 21
127342: PUSH
127343: LD_VAR 0 6
127347: PUSH
127348: LD_INT 5
127350: ARRAY
127351: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
127352: LD_ADDR_VAR 0 22
127356: PUSH
127357: LD_VAR 0 6
127361: PUSH
127362: LD_INT 6
127364: ARRAY
127365: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
127366: LD_ADDR_VAR 0 23
127370: PUSH
127371: LD_VAR 0 6
127375: PUSH
127376: LD_INT 7
127378: ARRAY
127379: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
127380: LD_ADDR_VAR 0 24
127384: PUSH
127385: LD_VAR 0 6
127389: PUSH
127390: LD_INT 8
127392: ARRAY
127393: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
127394: LD_ADDR_VAR 0 25
127398: PUSH
127399: LD_VAR 0 6
127403: PUSH
127404: LD_INT 9
127406: ARRAY
127407: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
127408: LD_ADDR_VAR 0 26
127412: PUSH
127413: LD_VAR 0 6
127417: PUSH
127418: LD_INT 10
127420: ARRAY
127421: ST_TO_ADDR
// end else
127422: GO 127504
// begin f_ignore_area := false ;
127424: LD_ADDR_VAR 0 17
127428: PUSH
127429: LD_INT 0
127431: ST_TO_ADDR
// f_capture := false ;
127432: LD_ADDR_VAR 0 18
127436: PUSH
127437: LD_INT 0
127439: ST_TO_ADDR
// f_ignore_civ := false ;
127440: LD_ADDR_VAR 0 19
127444: PUSH
127445: LD_INT 0
127447: ST_TO_ADDR
// f_murder := false ;
127448: LD_ADDR_VAR 0 20
127452: PUSH
127453: LD_INT 0
127455: ST_TO_ADDR
// f_mines := false ;
127456: LD_ADDR_VAR 0 21
127460: PUSH
127461: LD_INT 0
127463: ST_TO_ADDR
// f_repair := false ;
127464: LD_ADDR_VAR 0 22
127468: PUSH
127469: LD_INT 0
127471: ST_TO_ADDR
// f_heal := false ;
127472: LD_ADDR_VAR 0 23
127476: PUSH
127477: LD_INT 0
127479: ST_TO_ADDR
// f_spacetime := false ;
127480: LD_ADDR_VAR 0 24
127484: PUSH
127485: LD_INT 0
127487: ST_TO_ADDR
// f_attack_depot := false ;
127488: LD_ADDR_VAR 0 25
127492: PUSH
127493: LD_INT 0
127495: ST_TO_ADDR
// f_crawl := false ;
127496: LD_ADDR_VAR 0 26
127500: PUSH
127501: LD_INT 0
127503: ST_TO_ADDR
// end ; if f_heal then
127504: LD_VAR 0 23
127508: IFFALSE 127535
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
127510: LD_ADDR_VAR 0 31
127514: PUSH
127515: LD_VAR 0 4
127519: PPUSH
127520: LD_INT 25
127522: PUSH
127523: LD_INT 4
127525: PUSH
127526: EMPTY
127527: LIST
127528: LIST
127529: PPUSH
127530: CALL_OW 72
127534: ST_TO_ADDR
// if f_repair then
127535: LD_VAR 0 22
127539: IFFALSE 127566
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
127541: LD_ADDR_VAR 0 33
127545: PUSH
127546: LD_VAR 0 4
127550: PPUSH
127551: LD_INT 25
127553: PUSH
127554: LD_INT 3
127556: PUSH
127557: EMPTY
127558: LIST
127559: LIST
127560: PPUSH
127561: CALL_OW 72
127565: ST_TO_ADDR
// units_path := [ ] ;
127566: LD_ADDR_VAR 0 16
127570: PUSH
127571: EMPTY
127572: ST_TO_ADDR
// for i = 1 to group do
127573: LD_ADDR_VAR 0 7
127577: PUSH
127578: DOUBLE
127579: LD_INT 1
127581: DEC
127582: ST_TO_ADDR
127583: LD_VAR 0 4
127587: PUSH
127588: FOR_TO
127589: IFFALSE 127618
// units_path := Replace ( units_path , i , path ) ;
127591: LD_ADDR_VAR 0 16
127595: PUSH
127596: LD_VAR 0 16
127600: PPUSH
127601: LD_VAR 0 7
127605: PPUSH
127606: LD_VAR 0 5
127610: PPUSH
127611: CALL_OW 1
127615: ST_TO_ADDR
127616: GO 127588
127618: POP
127619: POP
// repeat for i = group downto 1 do
127620: LD_ADDR_VAR 0 7
127624: PUSH
127625: DOUBLE
127626: LD_VAR 0 4
127630: INC
127631: ST_TO_ADDR
127632: LD_INT 1
127634: PUSH
127635: FOR_DOWNTO
127636: IFFALSE 131758
// begin wait ( 5 ) ;
127638: LD_INT 5
127640: PPUSH
127641: CALL_OW 67
// tmp := [ ] ;
127645: LD_ADDR_VAR 0 14
127649: PUSH
127650: EMPTY
127651: ST_TO_ADDR
// attacking := false ;
127652: LD_ADDR_VAR 0 29
127656: PUSH
127657: LD_INT 0
127659: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
127660: LD_VAR 0 4
127664: PUSH
127665: LD_VAR 0 7
127669: ARRAY
127670: PPUSH
127671: CALL_OW 301
127675: PUSH
127676: LD_VAR 0 4
127680: PUSH
127681: LD_VAR 0 7
127685: ARRAY
127686: NOT
127687: OR
127688: IFFALSE 127797
// begin if GetType ( group [ i ] ) = unit_human then
127690: LD_VAR 0 4
127694: PUSH
127695: LD_VAR 0 7
127699: ARRAY
127700: PPUSH
127701: CALL_OW 247
127705: PUSH
127706: LD_INT 1
127708: EQUAL
127709: IFFALSE 127755
// begin to_heal := to_heal diff group [ i ] ;
127711: LD_ADDR_VAR 0 30
127715: PUSH
127716: LD_VAR 0 30
127720: PUSH
127721: LD_VAR 0 4
127725: PUSH
127726: LD_VAR 0 7
127730: ARRAY
127731: DIFF
127732: ST_TO_ADDR
// healers := healers diff group [ i ] ;
127733: LD_ADDR_VAR 0 31
127737: PUSH
127738: LD_VAR 0 31
127742: PUSH
127743: LD_VAR 0 4
127747: PUSH
127748: LD_VAR 0 7
127752: ARRAY
127753: DIFF
127754: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
127755: LD_ADDR_VAR 0 4
127759: PUSH
127760: LD_VAR 0 4
127764: PPUSH
127765: LD_VAR 0 7
127769: PPUSH
127770: CALL_OW 3
127774: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
127775: LD_ADDR_VAR 0 16
127779: PUSH
127780: LD_VAR 0 16
127784: PPUSH
127785: LD_VAR 0 7
127789: PPUSH
127790: CALL_OW 3
127794: ST_TO_ADDR
// continue ;
127795: GO 127635
// end ; if f_repair then
127797: LD_VAR 0 22
127801: IFFALSE 128290
// begin if GetType ( group [ i ] ) = unit_vehicle then
127803: LD_VAR 0 4
127807: PUSH
127808: LD_VAR 0 7
127812: ARRAY
127813: PPUSH
127814: CALL_OW 247
127818: PUSH
127819: LD_INT 2
127821: EQUAL
127822: IFFALSE 128012
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
127824: LD_VAR 0 4
127828: PUSH
127829: LD_VAR 0 7
127833: ARRAY
127834: PPUSH
127835: CALL_OW 256
127839: PUSH
127840: LD_INT 700
127842: LESS
127843: PUSH
127844: LD_VAR 0 4
127848: PUSH
127849: LD_VAR 0 7
127853: ARRAY
127854: PUSH
127855: LD_VAR 0 32
127859: IN
127860: NOT
127861: AND
127862: IFFALSE 127886
// to_repair := to_repair union group [ i ] ;
127864: LD_ADDR_VAR 0 32
127868: PUSH
127869: LD_VAR 0 32
127873: PUSH
127874: LD_VAR 0 4
127878: PUSH
127879: LD_VAR 0 7
127883: ARRAY
127884: UNION
127885: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
127886: LD_VAR 0 4
127890: PUSH
127891: LD_VAR 0 7
127895: ARRAY
127896: PPUSH
127897: CALL_OW 256
127901: PUSH
127902: LD_INT 1000
127904: EQUAL
127905: PUSH
127906: LD_VAR 0 4
127910: PUSH
127911: LD_VAR 0 7
127915: ARRAY
127916: PUSH
127917: LD_VAR 0 32
127921: IN
127922: AND
127923: IFFALSE 127947
// to_repair := to_repair diff group [ i ] ;
127925: LD_ADDR_VAR 0 32
127929: PUSH
127930: LD_VAR 0 32
127934: PUSH
127935: LD_VAR 0 4
127939: PUSH
127940: LD_VAR 0 7
127944: ARRAY
127945: DIFF
127946: ST_TO_ADDR
// if group [ i ] in to_repair then
127947: LD_VAR 0 4
127951: PUSH
127952: LD_VAR 0 7
127956: ARRAY
127957: PUSH
127958: LD_VAR 0 32
127962: IN
127963: IFFALSE 128010
// begin if not IsInArea ( group [ i ] , f_repair ) then
127965: LD_VAR 0 4
127969: PUSH
127970: LD_VAR 0 7
127974: ARRAY
127975: PPUSH
127976: LD_VAR 0 22
127980: PPUSH
127981: CALL_OW 308
127985: NOT
127986: IFFALSE 128008
// ComMoveToArea ( group [ i ] , f_repair ) ;
127988: LD_VAR 0 4
127992: PUSH
127993: LD_VAR 0 7
127997: ARRAY
127998: PPUSH
127999: LD_VAR 0 22
128003: PPUSH
128004: CALL_OW 113
// continue ;
128008: GO 127635
// end ; end else
128010: GO 128290
// if group [ i ] in repairs then
128012: LD_VAR 0 4
128016: PUSH
128017: LD_VAR 0 7
128021: ARRAY
128022: PUSH
128023: LD_VAR 0 33
128027: IN
128028: IFFALSE 128290
// begin if IsInUnit ( group [ i ] ) then
128030: LD_VAR 0 4
128034: PUSH
128035: LD_VAR 0 7
128039: ARRAY
128040: PPUSH
128041: CALL_OW 310
128045: IFFALSE 128113
// begin z := IsInUnit ( group [ i ] ) ;
128047: LD_ADDR_VAR 0 13
128051: PUSH
128052: LD_VAR 0 4
128056: PUSH
128057: LD_VAR 0 7
128061: ARRAY
128062: PPUSH
128063: CALL_OW 310
128067: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
128068: LD_VAR 0 13
128072: PUSH
128073: LD_VAR 0 32
128077: IN
128078: PUSH
128079: LD_VAR 0 13
128083: PPUSH
128084: LD_VAR 0 22
128088: PPUSH
128089: CALL_OW 308
128093: AND
128094: IFFALSE 128111
// ComExitVehicle ( group [ i ] ) ;
128096: LD_VAR 0 4
128100: PUSH
128101: LD_VAR 0 7
128105: ARRAY
128106: PPUSH
128107: CALL_OW 121
// end else
128111: GO 128290
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
128113: LD_ADDR_VAR 0 13
128117: PUSH
128118: LD_VAR 0 4
128122: PPUSH
128123: LD_INT 95
128125: PUSH
128126: LD_VAR 0 22
128130: PUSH
128131: EMPTY
128132: LIST
128133: LIST
128134: PUSH
128135: LD_INT 58
128137: PUSH
128138: EMPTY
128139: LIST
128140: PUSH
128141: EMPTY
128142: LIST
128143: LIST
128144: PPUSH
128145: CALL_OW 72
128149: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
128150: LD_VAR 0 4
128154: PUSH
128155: LD_VAR 0 7
128159: ARRAY
128160: PPUSH
128161: CALL_OW 314
128165: NOT
128166: IFFALSE 128288
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
128168: LD_ADDR_VAR 0 10
128172: PUSH
128173: LD_VAR 0 13
128177: PPUSH
128178: LD_VAR 0 4
128182: PUSH
128183: LD_VAR 0 7
128187: ARRAY
128188: PPUSH
128189: CALL_OW 74
128193: ST_TO_ADDR
// if not x then
128194: LD_VAR 0 10
128198: NOT
128199: IFFALSE 128203
// continue ;
128201: GO 127635
// if GetLives ( x ) < 1000 then
128203: LD_VAR 0 10
128207: PPUSH
128208: CALL_OW 256
128212: PUSH
128213: LD_INT 1000
128215: LESS
128216: IFFALSE 128240
// ComRepairVehicle ( group [ i ] , x ) else
128218: LD_VAR 0 4
128222: PUSH
128223: LD_VAR 0 7
128227: ARRAY
128228: PPUSH
128229: LD_VAR 0 10
128233: PPUSH
128234: CALL_OW 129
128238: GO 128288
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
128240: LD_VAR 0 23
128244: PUSH
128245: LD_VAR 0 4
128249: PUSH
128250: LD_VAR 0 7
128254: ARRAY
128255: PPUSH
128256: CALL_OW 256
128260: PUSH
128261: LD_INT 1000
128263: LESS
128264: AND
128265: NOT
128266: IFFALSE 128288
// ComEnterUnit ( group [ i ] , x ) ;
128268: LD_VAR 0 4
128272: PUSH
128273: LD_VAR 0 7
128277: ARRAY
128278: PPUSH
128279: LD_VAR 0 10
128283: PPUSH
128284: CALL_OW 120
// end ; continue ;
128288: GO 127635
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
128290: LD_VAR 0 23
128294: PUSH
128295: LD_VAR 0 4
128299: PUSH
128300: LD_VAR 0 7
128304: ARRAY
128305: PPUSH
128306: CALL_OW 247
128310: PUSH
128311: LD_INT 1
128313: EQUAL
128314: AND
128315: IFFALSE 128793
// begin if group [ i ] in healers then
128317: LD_VAR 0 4
128321: PUSH
128322: LD_VAR 0 7
128326: ARRAY
128327: PUSH
128328: LD_VAR 0 31
128332: IN
128333: IFFALSE 128606
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
128335: LD_VAR 0 4
128339: PUSH
128340: LD_VAR 0 7
128344: ARRAY
128345: PPUSH
128346: LD_VAR 0 23
128350: PPUSH
128351: CALL_OW 308
128355: NOT
128356: PUSH
128357: LD_VAR 0 4
128361: PUSH
128362: LD_VAR 0 7
128366: ARRAY
128367: PPUSH
128368: CALL_OW 314
128372: NOT
128373: AND
128374: IFFALSE 128398
// ComMoveToArea ( group [ i ] , f_heal ) else
128376: LD_VAR 0 4
128380: PUSH
128381: LD_VAR 0 7
128385: ARRAY
128386: PPUSH
128387: LD_VAR 0 23
128391: PPUSH
128392: CALL_OW 113
128396: GO 128604
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
128398: LD_VAR 0 4
128402: PUSH
128403: LD_VAR 0 7
128407: ARRAY
128408: PPUSH
128409: CALL 100706 0 1
128413: PPUSH
128414: CALL_OW 256
128418: PUSH
128419: LD_INT 1000
128421: EQUAL
128422: IFFALSE 128441
// ComStop ( group [ i ] ) else
128424: LD_VAR 0 4
128428: PUSH
128429: LD_VAR 0 7
128433: ARRAY
128434: PPUSH
128435: CALL_OW 141
128439: GO 128604
// if not HasTask ( group [ i ] ) and to_heal then
128441: LD_VAR 0 4
128445: PUSH
128446: LD_VAR 0 7
128450: ARRAY
128451: PPUSH
128452: CALL_OW 314
128456: NOT
128457: PUSH
128458: LD_VAR 0 30
128462: AND
128463: IFFALSE 128604
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
128465: LD_ADDR_VAR 0 13
128469: PUSH
128470: LD_VAR 0 30
128474: PPUSH
128475: LD_INT 3
128477: PUSH
128478: LD_INT 54
128480: PUSH
128481: EMPTY
128482: LIST
128483: PUSH
128484: EMPTY
128485: LIST
128486: LIST
128487: PPUSH
128488: CALL_OW 72
128492: PPUSH
128493: LD_VAR 0 4
128497: PUSH
128498: LD_VAR 0 7
128502: ARRAY
128503: PPUSH
128504: CALL_OW 74
128508: ST_TO_ADDR
// if z then
128509: LD_VAR 0 13
128513: IFFALSE 128604
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
128515: LD_INT 91
128517: PUSH
128518: LD_VAR 0 13
128522: PUSH
128523: LD_INT 10
128525: PUSH
128526: EMPTY
128527: LIST
128528: LIST
128529: LIST
128530: PUSH
128531: LD_INT 81
128533: PUSH
128534: LD_VAR 0 13
128538: PPUSH
128539: CALL_OW 255
128543: PUSH
128544: EMPTY
128545: LIST
128546: LIST
128547: PUSH
128548: EMPTY
128549: LIST
128550: LIST
128551: PPUSH
128552: CALL_OW 69
128556: PUSH
128557: LD_INT 0
128559: EQUAL
128560: IFFALSE 128584
// ComHeal ( group [ i ] , z ) else
128562: LD_VAR 0 4
128566: PUSH
128567: LD_VAR 0 7
128571: ARRAY
128572: PPUSH
128573: LD_VAR 0 13
128577: PPUSH
128578: CALL_OW 128
128582: GO 128604
// ComMoveToArea ( group [ i ] , f_heal ) ;
128584: LD_VAR 0 4
128588: PUSH
128589: LD_VAR 0 7
128593: ARRAY
128594: PPUSH
128595: LD_VAR 0 23
128599: PPUSH
128600: CALL_OW 113
// end ; continue ;
128604: GO 127635
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
128606: LD_VAR 0 4
128610: PUSH
128611: LD_VAR 0 7
128615: ARRAY
128616: PPUSH
128617: CALL_OW 256
128621: PUSH
128622: LD_INT 700
128624: LESS
128625: PUSH
128626: LD_VAR 0 4
128630: PUSH
128631: LD_VAR 0 7
128635: ARRAY
128636: PUSH
128637: LD_VAR 0 30
128641: IN
128642: NOT
128643: AND
128644: IFFALSE 128668
// to_heal := to_heal union group [ i ] ;
128646: LD_ADDR_VAR 0 30
128650: PUSH
128651: LD_VAR 0 30
128655: PUSH
128656: LD_VAR 0 4
128660: PUSH
128661: LD_VAR 0 7
128665: ARRAY
128666: UNION
128667: ST_TO_ADDR
// if group [ i ] in to_heal then
128668: LD_VAR 0 4
128672: PUSH
128673: LD_VAR 0 7
128677: ARRAY
128678: PUSH
128679: LD_VAR 0 30
128683: IN
128684: IFFALSE 128793
// begin if GetLives ( group [ i ] ) = 1000 then
128686: LD_VAR 0 4
128690: PUSH
128691: LD_VAR 0 7
128695: ARRAY
128696: PPUSH
128697: CALL_OW 256
128701: PUSH
128702: LD_INT 1000
128704: EQUAL
128705: IFFALSE 128731
// to_heal := to_heal diff group [ i ] else
128707: LD_ADDR_VAR 0 30
128711: PUSH
128712: LD_VAR 0 30
128716: PUSH
128717: LD_VAR 0 4
128721: PUSH
128722: LD_VAR 0 7
128726: ARRAY
128727: DIFF
128728: ST_TO_ADDR
128729: GO 128793
// begin if not IsInArea ( group [ i ] , to_heal ) then
128731: LD_VAR 0 4
128735: PUSH
128736: LD_VAR 0 7
128740: ARRAY
128741: PPUSH
128742: LD_VAR 0 30
128746: PPUSH
128747: CALL_OW 308
128751: NOT
128752: IFFALSE 128776
// ComMoveToArea ( group [ i ] , f_heal ) else
128754: LD_VAR 0 4
128758: PUSH
128759: LD_VAR 0 7
128763: ARRAY
128764: PPUSH
128765: LD_VAR 0 23
128769: PPUSH
128770: CALL_OW 113
128774: GO 128791
// ComHold ( group [ i ] ) ;
128776: LD_VAR 0 4
128780: PUSH
128781: LD_VAR 0 7
128785: ARRAY
128786: PPUSH
128787: CALL_OW 140
// continue ;
128791: GO 127635
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
128793: LD_VAR 0 4
128797: PUSH
128798: LD_VAR 0 7
128802: ARRAY
128803: PPUSH
128804: LD_INT 10
128806: PPUSH
128807: CALL 98559 0 2
128811: NOT
128812: PUSH
128813: LD_VAR 0 16
128817: PUSH
128818: LD_VAR 0 7
128822: ARRAY
128823: PUSH
128824: EMPTY
128825: EQUAL
128826: NOT
128827: AND
128828: IFFALSE 129094
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
128830: LD_VAR 0 4
128834: PUSH
128835: LD_VAR 0 7
128839: ARRAY
128840: PPUSH
128841: CALL_OW 262
128845: PUSH
128846: LD_INT 1
128848: PUSH
128849: LD_INT 2
128851: PUSH
128852: EMPTY
128853: LIST
128854: LIST
128855: IN
128856: IFFALSE 128897
// if GetFuel ( group [ i ] ) < 10 then
128858: LD_VAR 0 4
128862: PUSH
128863: LD_VAR 0 7
128867: ARRAY
128868: PPUSH
128869: CALL_OW 261
128873: PUSH
128874: LD_INT 10
128876: LESS
128877: IFFALSE 128897
// SetFuel ( group [ i ] , 12 ) ;
128879: LD_VAR 0 4
128883: PUSH
128884: LD_VAR 0 7
128888: ARRAY
128889: PPUSH
128890: LD_INT 12
128892: PPUSH
128893: CALL_OW 240
// if units_path [ i ] then
128897: LD_VAR 0 16
128901: PUSH
128902: LD_VAR 0 7
128906: ARRAY
128907: IFFALSE 129092
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
128909: LD_VAR 0 4
128913: PUSH
128914: LD_VAR 0 7
128918: ARRAY
128919: PPUSH
128920: LD_VAR 0 16
128924: PUSH
128925: LD_VAR 0 7
128929: ARRAY
128930: PUSH
128931: LD_INT 1
128933: ARRAY
128934: PUSH
128935: LD_INT 1
128937: ARRAY
128938: PPUSH
128939: LD_VAR 0 16
128943: PUSH
128944: LD_VAR 0 7
128948: ARRAY
128949: PUSH
128950: LD_INT 1
128952: ARRAY
128953: PUSH
128954: LD_INT 2
128956: ARRAY
128957: PPUSH
128958: CALL_OW 297
128962: PUSH
128963: LD_INT 6
128965: GREATER
128966: IFFALSE 129041
// begin if not HasTask ( group [ i ] ) then
128968: LD_VAR 0 4
128972: PUSH
128973: LD_VAR 0 7
128977: ARRAY
128978: PPUSH
128979: CALL_OW 314
128983: NOT
128984: IFFALSE 129039
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
128986: LD_VAR 0 4
128990: PUSH
128991: LD_VAR 0 7
128995: ARRAY
128996: PPUSH
128997: LD_VAR 0 16
129001: PUSH
129002: LD_VAR 0 7
129006: ARRAY
129007: PUSH
129008: LD_INT 1
129010: ARRAY
129011: PUSH
129012: LD_INT 1
129014: ARRAY
129015: PPUSH
129016: LD_VAR 0 16
129020: PUSH
129021: LD_VAR 0 7
129025: ARRAY
129026: PUSH
129027: LD_INT 1
129029: ARRAY
129030: PUSH
129031: LD_INT 2
129033: ARRAY
129034: PPUSH
129035: CALL_OW 114
// end else
129039: GO 129092
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
129041: LD_ADDR_VAR 0 15
129045: PUSH
129046: LD_VAR 0 16
129050: PUSH
129051: LD_VAR 0 7
129055: ARRAY
129056: PPUSH
129057: LD_INT 1
129059: PPUSH
129060: CALL_OW 3
129064: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
129065: LD_ADDR_VAR 0 16
129069: PUSH
129070: LD_VAR 0 16
129074: PPUSH
129075: LD_VAR 0 7
129079: PPUSH
129080: LD_VAR 0 15
129084: PPUSH
129085: CALL_OW 1
129089: ST_TO_ADDR
// continue ;
129090: GO 127635
// end ; end ; end else
129092: GO 131756
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
129094: LD_ADDR_VAR 0 14
129098: PUSH
129099: LD_INT 81
129101: PUSH
129102: LD_VAR 0 4
129106: PUSH
129107: LD_VAR 0 7
129111: ARRAY
129112: PPUSH
129113: CALL_OW 255
129117: PUSH
129118: EMPTY
129119: LIST
129120: LIST
129121: PPUSH
129122: CALL_OW 69
129126: ST_TO_ADDR
// if not tmp then
129127: LD_VAR 0 14
129131: NOT
129132: IFFALSE 129136
// continue ;
129134: GO 127635
// if f_ignore_area then
129136: LD_VAR 0 17
129140: IFFALSE 129228
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
129142: LD_ADDR_VAR 0 15
129146: PUSH
129147: LD_VAR 0 14
129151: PPUSH
129152: LD_INT 3
129154: PUSH
129155: LD_INT 92
129157: PUSH
129158: LD_VAR 0 17
129162: PUSH
129163: LD_INT 1
129165: ARRAY
129166: PUSH
129167: LD_VAR 0 17
129171: PUSH
129172: LD_INT 2
129174: ARRAY
129175: PUSH
129176: LD_VAR 0 17
129180: PUSH
129181: LD_INT 3
129183: ARRAY
129184: PUSH
129185: EMPTY
129186: LIST
129187: LIST
129188: LIST
129189: LIST
129190: PUSH
129191: EMPTY
129192: LIST
129193: LIST
129194: PPUSH
129195: CALL_OW 72
129199: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
129200: LD_VAR 0 14
129204: PUSH
129205: LD_VAR 0 15
129209: DIFF
129210: IFFALSE 129228
// tmp := tmp diff tmp2 ;
129212: LD_ADDR_VAR 0 14
129216: PUSH
129217: LD_VAR 0 14
129221: PUSH
129222: LD_VAR 0 15
129226: DIFF
129227: ST_TO_ADDR
// end ; if not f_murder then
129228: LD_VAR 0 20
129232: NOT
129233: IFFALSE 129291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
129235: LD_ADDR_VAR 0 15
129239: PUSH
129240: LD_VAR 0 14
129244: PPUSH
129245: LD_INT 3
129247: PUSH
129248: LD_INT 50
129250: PUSH
129251: EMPTY
129252: LIST
129253: PUSH
129254: EMPTY
129255: LIST
129256: LIST
129257: PPUSH
129258: CALL_OW 72
129262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
129263: LD_VAR 0 14
129267: PUSH
129268: LD_VAR 0 15
129272: DIFF
129273: IFFALSE 129291
// tmp := tmp diff tmp2 ;
129275: LD_ADDR_VAR 0 14
129279: PUSH
129280: LD_VAR 0 14
129284: PUSH
129285: LD_VAR 0 15
129289: DIFF
129290: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
129291: LD_ADDR_VAR 0 14
129295: PUSH
129296: LD_VAR 0 4
129300: PUSH
129301: LD_VAR 0 7
129305: ARRAY
129306: PPUSH
129307: LD_VAR 0 14
129311: PPUSH
129312: LD_INT 1
129314: PPUSH
129315: LD_INT 1
129317: PPUSH
129318: CALL 71494 0 4
129322: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
129323: LD_VAR 0 4
129327: PUSH
129328: LD_VAR 0 7
129332: ARRAY
129333: PPUSH
129334: CALL_OW 257
129338: PUSH
129339: LD_INT 1
129341: EQUAL
129342: IFFALSE 129790
// begin if WantPlant ( group [ i ] ) then
129344: LD_VAR 0 4
129348: PUSH
129349: LD_VAR 0 7
129353: ARRAY
129354: PPUSH
129355: CALL 70995 0 1
129359: IFFALSE 129363
// continue ;
129361: GO 127635
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
129363: LD_VAR 0 18
129367: PUSH
129368: LD_VAR 0 4
129372: PUSH
129373: LD_VAR 0 7
129377: ARRAY
129378: PPUSH
129379: CALL_OW 310
129383: NOT
129384: AND
129385: PUSH
129386: LD_VAR 0 14
129390: PUSH
129391: LD_INT 1
129393: ARRAY
129394: PUSH
129395: LD_VAR 0 14
129399: PPUSH
129400: LD_INT 21
129402: PUSH
129403: LD_INT 2
129405: PUSH
129406: EMPTY
129407: LIST
129408: LIST
129409: PUSH
129410: LD_INT 58
129412: PUSH
129413: EMPTY
129414: LIST
129415: PUSH
129416: EMPTY
129417: LIST
129418: LIST
129419: PPUSH
129420: CALL_OW 72
129424: IN
129425: AND
129426: IFFALSE 129462
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
129428: LD_VAR 0 4
129432: PUSH
129433: LD_VAR 0 7
129437: ARRAY
129438: PPUSH
129439: LD_VAR 0 14
129443: PUSH
129444: LD_INT 1
129446: ARRAY
129447: PPUSH
129448: CALL_OW 120
// attacking := true ;
129452: LD_ADDR_VAR 0 29
129456: PUSH
129457: LD_INT 1
129459: ST_TO_ADDR
// continue ;
129460: GO 127635
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
129462: LD_VAR 0 26
129466: PUSH
129467: LD_VAR 0 4
129471: PUSH
129472: LD_VAR 0 7
129476: ARRAY
129477: PPUSH
129478: CALL_OW 257
129482: PUSH
129483: LD_INT 1
129485: EQUAL
129486: AND
129487: PUSH
129488: LD_VAR 0 4
129492: PUSH
129493: LD_VAR 0 7
129497: ARRAY
129498: PPUSH
129499: CALL_OW 256
129503: PUSH
129504: LD_INT 800
129506: LESS
129507: AND
129508: PUSH
129509: LD_VAR 0 4
129513: PUSH
129514: LD_VAR 0 7
129518: ARRAY
129519: PPUSH
129520: CALL_OW 318
129524: NOT
129525: AND
129526: IFFALSE 129543
// ComCrawl ( group [ i ] ) ;
129528: LD_VAR 0 4
129532: PUSH
129533: LD_VAR 0 7
129537: ARRAY
129538: PPUSH
129539: CALL_OW 137
// if f_mines then
129543: LD_VAR 0 21
129547: IFFALSE 129790
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
129549: LD_VAR 0 14
129553: PUSH
129554: LD_INT 1
129556: ARRAY
129557: PPUSH
129558: CALL_OW 247
129562: PUSH
129563: LD_INT 3
129565: EQUAL
129566: PUSH
129567: LD_VAR 0 14
129571: PUSH
129572: LD_INT 1
129574: ARRAY
129575: PUSH
129576: LD_VAR 0 27
129580: IN
129581: NOT
129582: AND
129583: IFFALSE 129790
// begin x := GetX ( tmp [ 1 ] ) ;
129585: LD_ADDR_VAR 0 10
129589: PUSH
129590: LD_VAR 0 14
129594: PUSH
129595: LD_INT 1
129597: ARRAY
129598: PPUSH
129599: CALL_OW 250
129603: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
129604: LD_ADDR_VAR 0 11
129608: PUSH
129609: LD_VAR 0 14
129613: PUSH
129614: LD_INT 1
129616: ARRAY
129617: PPUSH
129618: CALL_OW 251
129622: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
129623: LD_ADDR_VAR 0 12
129627: PUSH
129628: LD_VAR 0 4
129632: PUSH
129633: LD_VAR 0 7
129637: ARRAY
129638: PPUSH
129639: CALL 98644 0 1
129643: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
129644: LD_VAR 0 4
129648: PUSH
129649: LD_VAR 0 7
129653: ARRAY
129654: PPUSH
129655: LD_VAR 0 10
129659: PPUSH
129660: LD_VAR 0 11
129664: PPUSH
129665: LD_VAR 0 14
129669: PUSH
129670: LD_INT 1
129672: ARRAY
129673: PPUSH
129674: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
129678: LD_VAR 0 4
129682: PUSH
129683: LD_VAR 0 7
129687: ARRAY
129688: PPUSH
129689: LD_VAR 0 10
129693: PPUSH
129694: LD_VAR 0 12
129698: PPUSH
129699: LD_INT 7
129701: PPUSH
129702: CALL_OW 272
129706: PPUSH
129707: LD_VAR 0 11
129711: PPUSH
129712: LD_VAR 0 12
129716: PPUSH
129717: LD_INT 7
129719: PPUSH
129720: CALL_OW 273
129724: PPUSH
129725: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
129729: LD_VAR 0 4
129733: PUSH
129734: LD_VAR 0 7
129738: ARRAY
129739: PPUSH
129740: LD_INT 71
129742: PPUSH
129743: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
129747: LD_ADDR_VAR 0 27
129751: PUSH
129752: LD_VAR 0 27
129756: PPUSH
129757: LD_VAR 0 27
129761: PUSH
129762: LD_INT 1
129764: PLUS
129765: PPUSH
129766: LD_VAR 0 14
129770: PUSH
129771: LD_INT 1
129773: ARRAY
129774: PPUSH
129775: CALL_OW 1
129779: ST_TO_ADDR
// attacking := true ;
129780: LD_ADDR_VAR 0 29
129784: PUSH
129785: LD_INT 1
129787: ST_TO_ADDR
// continue ;
129788: GO 127635
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
129790: LD_VAR 0 4
129794: PUSH
129795: LD_VAR 0 7
129799: ARRAY
129800: PPUSH
129801: CALL_OW 257
129805: PUSH
129806: LD_INT 17
129808: EQUAL
129809: PUSH
129810: LD_VAR 0 4
129814: PUSH
129815: LD_VAR 0 7
129819: ARRAY
129820: PPUSH
129821: CALL_OW 110
129825: PUSH
129826: LD_INT 71
129828: EQUAL
129829: NOT
129830: AND
129831: IFFALSE 129977
// begin attacking := false ;
129833: LD_ADDR_VAR 0 29
129837: PUSH
129838: LD_INT 0
129840: ST_TO_ADDR
// k := 5 ;
129841: LD_ADDR_VAR 0 9
129845: PUSH
129846: LD_INT 5
129848: ST_TO_ADDR
// if tmp < k then
129849: LD_VAR 0 14
129853: PUSH
129854: LD_VAR 0 9
129858: LESS
129859: IFFALSE 129871
// k := tmp ;
129861: LD_ADDR_VAR 0 9
129865: PUSH
129866: LD_VAR 0 14
129870: ST_TO_ADDR
// for j = 1 to k do
129871: LD_ADDR_VAR 0 8
129875: PUSH
129876: DOUBLE
129877: LD_INT 1
129879: DEC
129880: ST_TO_ADDR
129881: LD_VAR 0 9
129885: PUSH
129886: FOR_TO
129887: IFFALSE 129975
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
129889: LD_VAR 0 14
129893: PUSH
129894: LD_VAR 0 8
129898: ARRAY
129899: PUSH
129900: LD_VAR 0 14
129904: PPUSH
129905: LD_INT 58
129907: PUSH
129908: EMPTY
129909: LIST
129910: PPUSH
129911: CALL_OW 72
129915: IN
129916: NOT
129917: IFFALSE 129973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
129919: LD_VAR 0 4
129923: PUSH
129924: LD_VAR 0 7
129928: ARRAY
129929: PPUSH
129930: LD_VAR 0 14
129934: PUSH
129935: LD_VAR 0 8
129939: ARRAY
129940: PPUSH
129941: CALL_OW 115
// attacking := true ;
129945: LD_ADDR_VAR 0 29
129949: PUSH
129950: LD_INT 1
129952: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
129953: LD_VAR 0 4
129957: PUSH
129958: LD_VAR 0 7
129962: ARRAY
129963: PPUSH
129964: LD_INT 71
129966: PPUSH
129967: CALL_OW 109
// continue ;
129971: GO 129886
// end ; end ;
129973: GO 129886
129975: POP
129976: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
129977: LD_VAR 0 4
129981: PUSH
129982: LD_VAR 0 7
129986: ARRAY
129987: PPUSH
129988: CALL_OW 257
129992: PUSH
129993: LD_INT 8
129995: EQUAL
129996: PUSH
129997: LD_VAR 0 4
130001: PUSH
130002: LD_VAR 0 7
130006: ARRAY
130007: PPUSH
130008: CALL_OW 264
130012: PUSH
130013: LD_INT 28
130015: PUSH
130016: LD_INT 45
130018: PUSH
130019: LD_INT 7
130021: PUSH
130022: LD_INT 47
130024: PUSH
130025: EMPTY
130026: LIST
130027: LIST
130028: LIST
130029: LIST
130030: IN
130031: OR
130032: IFFALSE 130288
// begin attacking := false ;
130034: LD_ADDR_VAR 0 29
130038: PUSH
130039: LD_INT 0
130041: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
130042: LD_VAR 0 14
130046: PUSH
130047: LD_INT 1
130049: ARRAY
130050: PPUSH
130051: CALL_OW 266
130055: PUSH
130056: LD_INT 32
130058: PUSH
130059: LD_INT 31
130061: PUSH
130062: LD_INT 33
130064: PUSH
130065: LD_INT 4
130067: PUSH
130068: LD_INT 5
130070: PUSH
130071: EMPTY
130072: LIST
130073: LIST
130074: LIST
130075: LIST
130076: LIST
130077: IN
130078: IFFALSE 130264
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
130080: LD_ADDR_VAR 0 9
130084: PUSH
130085: LD_VAR 0 14
130089: PUSH
130090: LD_INT 1
130092: ARRAY
130093: PPUSH
130094: CALL_OW 266
130098: PPUSH
130099: LD_VAR 0 14
130103: PUSH
130104: LD_INT 1
130106: ARRAY
130107: PPUSH
130108: CALL_OW 250
130112: PPUSH
130113: LD_VAR 0 14
130117: PUSH
130118: LD_INT 1
130120: ARRAY
130121: PPUSH
130122: CALL_OW 251
130126: PPUSH
130127: LD_VAR 0 14
130131: PUSH
130132: LD_INT 1
130134: ARRAY
130135: PPUSH
130136: CALL_OW 254
130140: PPUSH
130141: LD_VAR 0 14
130145: PUSH
130146: LD_INT 1
130148: ARRAY
130149: PPUSH
130150: CALL_OW 248
130154: PPUSH
130155: LD_INT 0
130157: PPUSH
130158: CALL 80014 0 6
130162: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
130163: LD_ADDR_VAR 0 8
130167: PUSH
130168: LD_VAR 0 4
130172: PUSH
130173: LD_VAR 0 7
130177: ARRAY
130178: PPUSH
130179: LD_VAR 0 9
130183: PPUSH
130184: CALL 98684 0 2
130188: ST_TO_ADDR
// if j then
130189: LD_VAR 0 8
130193: IFFALSE 130262
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
130195: LD_VAR 0 8
130199: PUSH
130200: LD_INT 1
130202: ARRAY
130203: PPUSH
130204: LD_VAR 0 8
130208: PUSH
130209: LD_INT 2
130211: ARRAY
130212: PPUSH
130213: CALL_OW 488
130217: IFFALSE 130262
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
130219: LD_VAR 0 4
130223: PUSH
130224: LD_VAR 0 7
130228: ARRAY
130229: PPUSH
130230: LD_VAR 0 8
130234: PUSH
130235: LD_INT 1
130237: ARRAY
130238: PPUSH
130239: LD_VAR 0 8
130243: PUSH
130244: LD_INT 2
130246: ARRAY
130247: PPUSH
130248: CALL_OW 116
// attacking := true ;
130252: LD_ADDR_VAR 0 29
130256: PUSH
130257: LD_INT 1
130259: ST_TO_ADDR
// continue ;
130260: GO 127635
// end ; end else
130262: GO 130288
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130264: LD_VAR 0 4
130268: PUSH
130269: LD_VAR 0 7
130273: ARRAY
130274: PPUSH
130275: LD_VAR 0 14
130279: PUSH
130280: LD_INT 1
130282: ARRAY
130283: PPUSH
130284: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
130288: LD_VAR 0 4
130292: PUSH
130293: LD_VAR 0 7
130297: ARRAY
130298: PPUSH
130299: CALL_OW 265
130303: PUSH
130304: LD_INT 11
130306: EQUAL
130307: IFFALSE 130585
// begin k := 10 ;
130309: LD_ADDR_VAR 0 9
130313: PUSH
130314: LD_INT 10
130316: ST_TO_ADDR
// x := 0 ;
130317: LD_ADDR_VAR 0 10
130321: PUSH
130322: LD_INT 0
130324: ST_TO_ADDR
// if tmp < k then
130325: LD_VAR 0 14
130329: PUSH
130330: LD_VAR 0 9
130334: LESS
130335: IFFALSE 130347
// k := tmp ;
130337: LD_ADDR_VAR 0 9
130341: PUSH
130342: LD_VAR 0 14
130346: ST_TO_ADDR
// for j = k downto 1 do
130347: LD_ADDR_VAR 0 8
130351: PUSH
130352: DOUBLE
130353: LD_VAR 0 9
130357: INC
130358: ST_TO_ADDR
130359: LD_INT 1
130361: PUSH
130362: FOR_DOWNTO
130363: IFFALSE 130438
// begin if GetType ( tmp [ j ] ) = unit_human then
130365: LD_VAR 0 14
130369: PUSH
130370: LD_VAR 0 8
130374: ARRAY
130375: PPUSH
130376: CALL_OW 247
130380: PUSH
130381: LD_INT 1
130383: EQUAL
130384: IFFALSE 130436
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
130386: LD_VAR 0 4
130390: PUSH
130391: LD_VAR 0 7
130395: ARRAY
130396: PPUSH
130397: LD_VAR 0 14
130401: PUSH
130402: LD_VAR 0 8
130406: ARRAY
130407: PPUSH
130408: CALL 98955 0 2
// x := tmp [ j ] ;
130412: LD_ADDR_VAR 0 10
130416: PUSH
130417: LD_VAR 0 14
130421: PUSH
130422: LD_VAR 0 8
130426: ARRAY
130427: ST_TO_ADDR
// attacking := true ;
130428: LD_ADDR_VAR 0 29
130432: PUSH
130433: LD_INT 1
130435: ST_TO_ADDR
// end ; end ;
130436: GO 130362
130438: POP
130439: POP
// if not x then
130440: LD_VAR 0 10
130444: NOT
130445: IFFALSE 130585
// begin attacking := true ;
130447: LD_ADDR_VAR 0 29
130451: PUSH
130452: LD_INT 1
130454: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
130455: LD_VAR 0 4
130459: PUSH
130460: LD_VAR 0 7
130464: ARRAY
130465: PPUSH
130466: CALL_OW 250
130470: PPUSH
130471: LD_VAR 0 4
130475: PUSH
130476: LD_VAR 0 7
130480: ARRAY
130481: PPUSH
130482: CALL_OW 251
130486: PPUSH
130487: CALL_OW 546
130491: PUSH
130492: LD_INT 2
130494: ARRAY
130495: PUSH
130496: LD_VAR 0 14
130500: PUSH
130501: LD_INT 1
130503: ARRAY
130504: PPUSH
130505: CALL_OW 250
130509: PPUSH
130510: LD_VAR 0 14
130514: PUSH
130515: LD_INT 1
130517: ARRAY
130518: PPUSH
130519: CALL_OW 251
130523: PPUSH
130524: CALL_OW 546
130528: PUSH
130529: LD_INT 2
130531: ARRAY
130532: EQUAL
130533: IFFALSE 130561
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
130535: LD_VAR 0 4
130539: PUSH
130540: LD_VAR 0 7
130544: ARRAY
130545: PPUSH
130546: LD_VAR 0 14
130550: PUSH
130551: LD_INT 1
130553: ARRAY
130554: PPUSH
130555: CALL 98955 0 2
130559: GO 130585
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130561: LD_VAR 0 4
130565: PUSH
130566: LD_VAR 0 7
130570: ARRAY
130571: PPUSH
130572: LD_VAR 0 14
130576: PUSH
130577: LD_INT 1
130579: ARRAY
130580: PPUSH
130581: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
130585: LD_VAR 0 4
130589: PUSH
130590: LD_VAR 0 7
130594: ARRAY
130595: PPUSH
130596: CALL_OW 264
130600: PUSH
130601: LD_INT 29
130603: EQUAL
130604: IFFALSE 130970
// begin if WantsToAttack ( group [ i ] ) in bombed then
130606: LD_VAR 0 4
130610: PUSH
130611: LD_VAR 0 7
130615: ARRAY
130616: PPUSH
130617: CALL_OW 319
130621: PUSH
130622: LD_VAR 0 28
130626: IN
130627: IFFALSE 130631
// continue ;
130629: GO 127635
// k := 8 ;
130631: LD_ADDR_VAR 0 9
130635: PUSH
130636: LD_INT 8
130638: ST_TO_ADDR
// x := 0 ;
130639: LD_ADDR_VAR 0 10
130643: PUSH
130644: LD_INT 0
130646: ST_TO_ADDR
// if tmp < k then
130647: LD_VAR 0 14
130651: PUSH
130652: LD_VAR 0 9
130656: LESS
130657: IFFALSE 130669
// k := tmp ;
130659: LD_ADDR_VAR 0 9
130663: PUSH
130664: LD_VAR 0 14
130668: ST_TO_ADDR
// for j = 1 to k do
130669: LD_ADDR_VAR 0 8
130673: PUSH
130674: DOUBLE
130675: LD_INT 1
130677: DEC
130678: ST_TO_ADDR
130679: LD_VAR 0 9
130683: PUSH
130684: FOR_TO
130685: IFFALSE 130817
// begin if GetType ( tmp [ j ] ) = unit_building then
130687: LD_VAR 0 14
130691: PUSH
130692: LD_VAR 0 8
130696: ARRAY
130697: PPUSH
130698: CALL_OW 247
130702: PUSH
130703: LD_INT 3
130705: EQUAL
130706: IFFALSE 130815
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
130708: LD_VAR 0 14
130712: PUSH
130713: LD_VAR 0 8
130717: ARRAY
130718: PUSH
130719: LD_VAR 0 28
130723: IN
130724: NOT
130725: PUSH
130726: LD_VAR 0 14
130730: PUSH
130731: LD_VAR 0 8
130735: ARRAY
130736: PPUSH
130737: CALL_OW 313
130741: AND
130742: IFFALSE 130815
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
130744: LD_VAR 0 4
130748: PUSH
130749: LD_VAR 0 7
130753: ARRAY
130754: PPUSH
130755: LD_VAR 0 14
130759: PUSH
130760: LD_VAR 0 8
130764: ARRAY
130765: PPUSH
130766: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
130770: LD_ADDR_VAR 0 28
130774: PUSH
130775: LD_VAR 0 28
130779: PPUSH
130780: LD_VAR 0 28
130784: PUSH
130785: LD_INT 1
130787: PLUS
130788: PPUSH
130789: LD_VAR 0 14
130793: PUSH
130794: LD_VAR 0 8
130798: ARRAY
130799: PPUSH
130800: CALL_OW 1
130804: ST_TO_ADDR
// attacking := true ;
130805: LD_ADDR_VAR 0 29
130809: PUSH
130810: LD_INT 1
130812: ST_TO_ADDR
// break ;
130813: GO 130817
// end ; end ;
130815: GO 130684
130817: POP
130818: POP
// if not attacking and f_attack_depot then
130819: LD_VAR 0 29
130823: NOT
130824: PUSH
130825: LD_VAR 0 25
130829: AND
130830: IFFALSE 130925
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
130832: LD_ADDR_VAR 0 13
130836: PUSH
130837: LD_VAR 0 14
130841: PPUSH
130842: LD_INT 2
130844: PUSH
130845: LD_INT 30
130847: PUSH
130848: LD_INT 0
130850: PUSH
130851: EMPTY
130852: LIST
130853: LIST
130854: PUSH
130855: LD_INT 30
130857: PUSH
130858: LD_INT 1
130860: PUSH
130861: EMPTY
130862: LIST
130863: LIST
130864: PUSH
130865: EMPTY
130866: LIST
130867: LIST
130868: LIST
130869: PPUSH
130870: CALL_OW 72
130874: ST_TO_ADDR
// if z then
130875: LD_VAR 0 13
130879: IFFALSE 130925
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
130881: LD_VAR 0 4
130885: PUSH
130886: LD_VAR 0 7
130890: ARRAY
130891: PPUSH
130892: LD_VAR 0 13
130896: PPUSH
130897: LD_VAR 0 4
130901: PUSH
130902: LD_VAR 0 7
130906: ARRAY
130907: PPUSH
130908: CALL_OW 74
130912: PPUSH
130913: CALL_OW 115
// attacking := true ;
130917: LD_ADDR_VAR 0 29
130921: PUSH
130922: LD_INT 1
130924: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
130925: LD_VAR 0 4
130929: PUSH
130930: LD_VAR 0 7
130934: ARRAY
130935: PPUSH
130936: CALL_OW 256
130940: PUSH
130941: LD_INT 500
130943: LESS
130944: IFFALSE 130970
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
130946: LD_VAR 0 4
130950: PUSH
130951: LD_VAR 0 7
130955: ARRAY
130956: PPUSH
130957: LD_VAR 0 14
130961: PUSH
130962: LD_INT 1
130964: ARRAY
130965: PPUSH
130966: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
130970: LD_VAR 0 4
130974: PUSH
130975: LD_VAR 0 7
130979: ARRAY
130980: PPUSH
130981: CALL_OW 264
130985: PUSH
130986: LD_INT 49
130988: EQUAL
130989: IFFALSE 131110
// begin if not HasTask ( group [ i ] ) then
130991: LD_VAR 0 4
130995: PUSH
130996: LD_VAR 0 7
131000: ARRAY
131001: PPUSH
131002: CALL_OW 314
131006: NOT
131007: IFFALSE 131110
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
131009: LD_ADDR_VAR 0 9
131013: PUSH
131014: LD_INT 81
131016: PUSH
131017: LD_VAR 0 4
131021: PUSH
131022: LD_VAR 0 7
131026: ARRAY
131027: PPUSH
131028: CALL_OW 255
131032: PUSH
131033: EMPTY
131034: LIST
131035: LIST
131036: PPUSH
131037: CALL_OW 69
131041: PPUSH
131042: LD_VAR 0 4
131046: PUSH
131047: LD_VAR 0 7
131051: ARRAY
131052: PPUSH
131053: CALL_OW 74
131057: ST_TO_ADDR
// if k then
131058: LD_VAR 0 9
131062: IFFALSE 131110
// if GetDistUnits ( group [ i ] , k ) > 10 then
131064: LD_VAR 0 4
131068: PUSH
131069: LD_VAR 0 7
131073: ARRAY
131074: PPUSH
131075: LD_VAR 0 9
131079: PPUSH
131080: CALL_OW 296
131084: PUSH
131085: LD_INT 10
131087: GREATER
131088: IFFALSE 131110
// ComMoveUnit ( group [ i ] , k ) ;
131090: LD_VAR 0 4
131094: PUSH
131095: LD_VAR 0 7
131099: ARRAY
131100: PPUSH
131101: LD_VAR 0 9
131105: PPUSH
131106: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
131110: LD_VAR 0 4
131114: PUSH
131115: LD_VAR 0 7
131119: ARRAY
131120: PPUSH
131121: CALL_OW 256
131125: PUSH
131126: LD_INT 250
131128: LESS
131129: PUSH
131130: LD_VAR 0 4
131134: PUSH
131135: LD_VAR 0 7
131139: ARRAY
131140: PUSH
131141: LD_INT 21
131143: PUSH
131144: LD_INT 2
131146: PUSH
131147: EMPTY
131148: LIST
131149: LIST
131150: PUSH
131151: LD_INT 23
131153: PUSH
131154: LD_INT 2
131156: PUSH
131157: EMPTY
131158: LIST
131159: LIST
131160: PUSH
131161: EMPTY
131162: LIST
131163: LIST
131164: PPUSH
131165: CALL_OW 69
131169: IN
131170: AND
131171: IFFALSE 131296
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
131173: LD_ADDR_VAR 0 9
131177: PUSH
131178: LD_OWVAR 3
131182: PUSH
131183: LD_VAR 0 4
131187: PUSH
131188: LD_VAR 0 7
131192: ARRAY
131193: DIFF
131194: PPUSH
131195: LD_VAR 0 4
131199: PUSH
131200: LD_VAR 0 7
131204: ARRAY
131205: PPUSH
131206: CALL_OW 74
131210: ST_TO_ADDR
// if not k then
131211: LD_VAR 0 9
131215: NOT
131216: IFFALSE 131220
// continue ;
131218: GO 127635
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
131220: LD_VAR 0 9
131224: PUSH
131225: LD_INT 81
131227: PUSH
131228: LD_VAR 0 4
131232: PUSH
131233: LD_VAR 0 7
131237: ARRAY
131238: PPUSH
131239: CALL_OW 255
131243: PUSH
131244: EMPTY
131245: LIST
131246: LIST
131247: PPUSH
131248: CALL_OW 69
131252: IN
131253: PUSH
131254: LD_VAR 0 9
131258: PPUSH
131259: LD_VAR 0 4
131263: PUSH
131264: LD_VAR 0 7
131268: ARRAY
131269: PPUSH
131270: CALL_OW 296
131274: PUSH
131275: LD_INT 5
131277: LESS
131278: AND
131279: IFFALSE 131296
// ComAutodestruct ( group [ i ] ) ;
131281: LD_VAR 0 4
131285: PUSH
131286: LD_VAR 0 7
131290: ARRAY
131291: PPUSH
131292: CALL 98853 0 1
// end ; if f_attack_depot then
131296: LD_VAR 0 25
131300: IFFALSE 131412
// begin k := 6 ;
131302: LD_ADDR_VAR 0 9
131306: PUSH
131307: LD_INT 6
131309: ST_TO_ADDR
// if tmp < k then
131310: LD_VAR 0 14
131314: PUSH
131315: LD_VAR 0 9
131319: LESS
131320: IFFALSE 131332
// k := tmp ;
131322: LD_ADDR_VAR 0 9
131326: PUSH
131327: LD_VAR 0 14
131331: ST_TO_ADDR
// for j = 1 to k do
131332: LD_ADDR_VAR 0 8
131336: PUSH
131337: DOUBLE
131338: LD_INT 1
131340: DEC
131341: ST_TO_ADDR
131342: LD_VAR 0 9
131346: PUSH
131347: FOR_TO
131348: IFFALSE 131410
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
131350: LD_VAR 0 8
131354: PPUSH
131355: CALL_OW 266
131359: PUSH
131360: LD_INT 0
131362: PUSH
131363: LD_INT 1
131365: PUSH
131366: EMPTY
131367: LIST
131368: LIST
131369: IN
131370: IFFALSE 131408
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131372: LD_VAR 0 4
131376: PUSH
131377: LD_VAR 0 7
131381: ARRAY
131382: PPUSH
131383: LD_VAR 0 14
131387: PUSH
131388: LD_VAR 0 8
131392: ARRAY
131393: PPUSH
131394: CALL_OW 115
// attacking := true ;
131398: LD_ADDR_VAR 0 29
131402: PUSH
131403: LD_INT 1
131405: ST_TO_ADDR
// break ;
131406: GO 131410
// end ;
131408: GO 131347
131410: POP
131411: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
131412: LD_VAR 0 4
131416: PUSH
131417: LD_VAR 0 7
131421: ARRAY
131422: PPUSH
131423: CALL_OW 302
131427: PUSH
131428: LD_VAR 0 29
131432: NOT
131433: AND
131434: IFFALSE 131756
// begin if GetTag ( group [ i ] ) = 71 then
131436: LD_VAR 0 4
131440: PUSH
131441: LD_VAR 0 7
131445: ARRAY
131446: PPUSH
131447: CALL_OW 110
131451: PUSH
131452: LD_INT 71
131454: EQUAL
131455: IFFALSE 131496
// begin if HasTask ( group [ i ] ) then
131457: LD_VAR 0 4
131461: PUSH
131462: LD_VAR 0 7
131466: ARRAY
131467: PPUSH
131468: CALL_OW 314
131472: IFFALSE 131478
// continue else
131474: GO 127635
131476: GO 131496
// SetTag ( group [ i ] , 0 ) ;
131478: LD_VAR 0 4
131482: PUSH
131483: LD_VAR 0 7
131487: ARRAY
131488: PPUSH
131489: LD_INT 0
131491: PPUSH
131492: CALL_OW 109
// end ; k := 8 ;
131496: LD_ADDR_VAR 0 9
131500: PUSH
131501: LD_INT 8
131503: ST_TO_ADDR
// x := 0 ;
131504: LD_ADDR_VAR 0 10
131508: PUSH
131509: LD_INT 0
131511: ST_TO_ADDR
// if tmp < k then
131512: LD_VAR 0 14
131516: PUSH
131517: LD_VAR 0 9
131521: LESS
131522: IFFALSE 131534
// k := tmp ;
131524: LD_ADDR_VAR 0 9
131528: PUSH
131529: LD_VAR 0 14
131533: ST_TO_ADDR
// for j = 1 to k do
131534: LD_ADDR_VAR 0 8
131538: PUSH
131539: DOUBLE
131540: LD_INT 1
131542: DEC
131543: ST_TO_ADDR
131544: LD_VAR 0 9
131548: PUSH
131549: FOR_TO
131550: IFFALSE 131648
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
131552: LD_VAR 0 14
131556: PUSH
131557: LD_VAR 0 8
131561: ARRAY
131562: PPUSH
131563: CALL_OW 247
131567: PUSH
131568: LD_INT 1
131570: EQUAL
131571: PUSH
131572: LD_VAR 0 14
131576: PUSH
131577: LD_VAR 0 8
131581: ARRAY
131582: PPUSH
131583: CALL_OW 256
131587: PUSH
131588: LD_INT 250
131590: LESS
131591: PUSH
131592: LD_VAR 0 20
131596: AND
131597: PUSH
131598: LD_VAR 0 20
131602: NOT
131603: PUSH
131604: LD_VAR 0 14
131608: PUSH
131609: LD_VAR 0 8
131613: ARRAY
131614: PPUSH
131615: CALL_OW 256
131619: PUSH
131620: LD_INT 250
131622: GREATEREQUAL
131623: AND
131624: OR
131625: AND
131626: IFFALSE 131646
// begin x := tmp [ j ] ;
131628: LD_ADDR_VAR 0 10
131632: PUSH
131633: LD_VAR 0 14
131637: PUSH
131638: LD_VAR 0 8
131642: ARRAY
131643: ST_TO_ADDR
// break ;
131644: GO 131648
// end ;
131646: GO 131549
131648: POP
131649: POP
// if x then
131650: LD_VAR 0 10
131654: IFFALSE 131678
// ComAttackUnit ( group [ i ] , x ) else
131656: LD_VAR 0 4
131660: PUSH
131661: LD_VAR 0 7
131665: ARRAY
131666: PPUSH
131667: LD_VAR 0 10
131671: PPUSH
131672: CALL_OW 115
131676: GO 131702
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131678: LD_VAR 0 4
131682: PUSH
131683: LD_VAR 0 7
131687: ARRAY
131688: PPUSH
131689: LD_VAR 0 14
131693: PUSH
131694: LD_INT 1
131696: ARRAY
131697: PPUSH
131698: CALL_OW 115
// if not HasTask ( group [ i ] ) then
131702: LD_VAR 0 4
131706: PUSH
131707: LD_VAR 0 7
131711: ARRAY
131712: PPUSH
131713: CALL_OW 314
131717: NOT
131718: IFFALSE 131756
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
131720: LD_VAR 0 4
131724: PUSH
131725: LD_VAR 0 7
131729: ARRAY
131730: PPUSH
131731: LD_VAR 0 14
131735: PPUSH
131736: LD_VAR 0 4
131740: PUSH
131741: LD_VAR 0 7
131745: ARRAY
131746: PPUSH
131747: CALL_OW 74
131751: PPUSH
131752: CALL_OW 115
// end ; end ; end ;
131756: GO 127635
131758: POP
131759: POP
// wait ( 0 0$2 ) ;
131760: LD_INT 70
131762: PPUSH
131763: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
131767: LD_VAR 0 4
131771: NOT
131772: PUSH
131773: LD_VAR 0 4
131777: PUSH
131778: EMPTY
131779: EQUAL
131780: OR
131781: PUSH
131782: LD_INT 81
131784: PUSH
131785: LD_VAR 0 35
131789: PUSH
131790: EMPTY
131791: LIST
131792: LIST
131793: PPUSH
131794: CALL_OW 69
131798: NOT
131799: OR
131800: IFFALSE 127620
// end ;
131802: LD_VAR 0 2
131806: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
131807: LD_INT 0
131809: PPUSH
131810: PPUSH
131811: PPUSH
131812: PPUSH
131813: PPUSH
131814: PPUSH
// if not base or not mc_bases [ base ] or not solds then
131815: LD_VAR 0 1
131819: NOT
131820: PUSH
131821: LD_EXP 115
131825: PUSH
131826: LD_VAR 0 1
131830: ARRAY
131831: NOT
131832: OR
131833: PUSH
131834: LD_VAR 0 2
131838: NOT
131839: OR
131840: IFFALSE 131844
// exit ;
131842: GO 132398
// side := mc_sides [ base ] ;
131844: LD_ADDR_VAR 0 6
131848: PUSH
131849: LD_EXP 141
131853: PUSH
131854: LD_VAR 0 1
131858: ARRAY
131859: ST_TO_ADDR
// if not side then
131860: LD_VAR 0 6
131864: NOT
131865: IFFALSE 131869
// exit ;
131867: GO 132398
// for i in solds do
131869: LD_ADDR_VAR 0 7
131873: PUSH
131874: LD_VAR 0 2
131878: PUSH
131879: FOR_IN
131880: IFFALSE 131941
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
131882: LD_VAR 0 7
131886: PPUSH
131887: CALL_OW 310
131891: PPUSH
131892: CALL_OW 266
131896: PUSH
131897: LD_INT 32
131899: PUSH
131900: LD_INT 31
131902: PUSH
131903: EMPTY
131904: LIST
131905: LIST
131906: IN
131907: IFFALSE 131927
// solds := solds diff i else
131909: LD_ADDR_VAR 0 2
131913: PUSH
131914: LD_VAR 0 2
131918: PUSH
131919: LD_VAR 0 7
131923: DIFF
131924: ST_TO_ADDR
131925: GO 131939
// SetTag ( i , 18 ) ;
131927: LD_VAR 0 7
131931: PPUSH
131932: LD_INT 18
131934: PPUSH
131935: CALL_OW 109
131939: GO 131879
131941: POP
131942: POP
// if not solds then
131943: LD_VAR 0 2
131947: NOT
131948: IFFALSE 131952
// exit ;
131950: GO 132398
// repeat wait ( 0 0$2 ) ;
131952: LD_INT 70
131954: PPUSH
131955: CALL_OW 67
// enemy := mc_scan [ base ] ;
131959: LD_ADDR_VAR 0 4
131963: PUSH
131964: LD_EXP 138
131968: PUSH
131969: LD_VAR 0 1
131973: ARRAY
131974: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
131975: LD_EXP 115
131979: PUSH
131980: LD_VAR 0 1
131984: ARRAY
131985: NOT
131986: PUSH
131987: LD_EXP 115
131991: PUSH
131992: LD_VAR 0 1
131996: ARRAY
131997: PUSH
131998: EMPTY
131999: EQUAL
132000: OR
132001: IFFALSE 132038
// begin for i in solds do
132003: LD_ADDR_VAR 0 7
132007: PUSH
132008: LD_VAR 0 2
132012: PUSH
132013: FOR_IN
132014: IFFALSE 132027
// ComStop ( i ) ;
132016: LD_VAR 0 7
132020: PPUSH
132021: CALL_OW 141
132025: GO 132013
132027: POP
132028: POP
// solds := [ ] ;
132029: LD_ADDR_VAR 0 2
132033: PUSH
132034: EMPTY
132035: ST_TO_ADDR
// exit ;
132036: GO 132398
// end ; for i in solds do
132038: LD_ADDR_VAR 0 7
132042: PUSH
132043: LD_VAR 0 2
132047: PUSH
132048: FOR_IN
132049: IFFALSE 132370
// begin if IsInUnit ( i ) then
132051: LD_VAR 0 7
132055: PPUSH
132056: CALL_OW 310
132060: IFFALSE 132071
// ComExitBuilding ( i ) ;
132062: LD_VAR 0 7
132066: PPUSH
132067: CALL_OW 122
// if GetLives ( i ) > 500 then
132071: LD_VAR 0 7
132075: PPUSH
132076: CALL_OW 256
132080: PUSH
132081: LD_INT 500
132083: GREATER
132084: IFFALSE 132137
// begin e := NearestUnitToUnit ( enemy , i ) ;
132086: LD_ADDR_VAR 0 5
132090: PUSH
132091: LD_VAR 0 4
132095: PPUSH
132096: LD_VAR 0 7
132100: PPUSH
132101: CALL_OW 74
132105: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
132106: LD_VAR 0 7
132110: PPUSH
132111: LD_VAR 0 5
132115: PPUSH
132116: CALL_OW 250
132120: PPUSH
132121: LD_VAR 0 5
132125: PPUSH
132126: CALL_OW 251
132130: PPUSH
132131: CALL_OW 114
// end else
132135: GO 132368
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
132137: LD_VAR 0 7
132141: PPUSH
132142: LD_EXP 115
132146: PUSH
132147: LD_VAR 0 1
132151: ARRAY
132152: PPUSH
132153: LD_INT 2
132155: PUSH
132156: LD_INT 30
132158: PUSH
132159: LD_INT 0
132161: PUSH
132162: EMPTY
132163: LIST
132164: LIST
132165: PUSH
132166: LD_INT 30
132168: PUSH
132169: LD_INT 1
132171: PUSH
132172: EMPTY
132173: LIST
132174: LIST
132175: PUSH
132176: LD_INT 30
132178: PUSH
132179: LD_INT 6
132181: PUSH
132182: EMPTY
132183: LIST
132184: LIST
132185: PUSH
132186: EMPTY
132187: LIST
132188: LIST
132189: LIST
132190: LIST
132191: PPUSH
132192: CALL_OW 72
132196: PPUSH
132197: LD_VAR 0 7
132201: PPUSH
132202: CALL_OW 74
132206: PPUSH
132207: CALL_OW 296
132211: PUSH
132212: LD_INT 10
132214: GREATER
132215: IFFALSE 132368
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
132217: LD_ADDR_VAR 0 8
132221: PUSH
132222: LD_EXP 115
132226: PUSH
132227: LD_VAR 0 1
132231: ARRAY
132232: PPUSH
132233: LD_INT 2
132235: PUSH
132236: LD_INT 30
132238: PUSH
132239: LD_INT 0
132241: PUSH
132242: EMPTY
132243: LIST
132244: LIST
132245: PUSH
132246: LD_INT 30
132248: PUSH
132249: LD_INT 1
132251: PUSH
132252: EMPTY
132253: LIST
132254: LIST
132255: PUSH
132256: LD_INT 30
132258: PUSH
132259: LD_INT 6
132261: PUSH
132262: EMPTY
132263: LIST
132264: LIST
132265: PUSH
132266: EMPTY
132267: LIST
132268: LIST
132269: LIST
132270: LIST
132271: PPUSH
132272: CALL_OW 72
132276: PPUSH
132277: LD_VAR 0 7
132281: PPUSH
132282: CALL_OW 74
132286: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
132287: LD_VAR 0 7
132291: PPUSH
132292: LD_VAR 0 8
132296: PPUSH
132297: CALL_OW 250
132301: PPUSH
132302: LD_INT 3
132304: PPUSH
132305: LD_INT 5
132307: PPUSH
132308: CALL_OW 272
132312: PPUSH
132313: LD_VAR 0 8
132317: PPUSH
132318: CALL_OW 251
132322: PPUSH
132323: LD_INT 3
132325: PPUSH
132326: LD_INT 5
132328: PPUSH
132329: CALL_OW 273
132333: PPUSH
132334: CALL_OW 111
// SetTag ( i , 0 ) ;
132338: LD_VAR 0 7
132342: PPUSH
132343: LD_INT 0
132345: PPUSH
132346: CALL_OW 109
// solds := solds diff i ;
132350: LD_ADDR_VAR 0 2
132354: PUSH
132355: LD_VAR 0 2
132359: PUSH
132360: LD_VAR 0 7
132364: DIFF
132365: ST_TO_ADDR
// continue ;
132366: GO 132048
// end ; end ;
132368: GO 132048
132370: POP
132371: POP
// until not solds or not enemy ;
132372: LD_VAR 0 2
132376: NOT
132377: PUSH
132378: LD_VAR 0 4
132382: NOT
132383: OR
132384: IFFALSE 131952
// MC_Reset ( base , 18 ) ;
132386: LD_VAR 0 1
132390: PPUSH
132391: LD_INT 18
132393: PPUSH
132394: CALL 39448 0 2
// end ;
132398: LD_VAR 0 3
132402: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
132403: LD_INT 0
132405: PPUSH
132406: PPUSH
132407: PPUSH
132408: PPUSH
132409: PPUSH
132410: PPUSH
132411: PPUSH
132412: PPUSH
132413: PPUSH
132414: PPUSH
132415: PPUSH
132416: PPUSH
132417: PPUSH
132418: PPUSH
132419: PPUSH
132420: PPUSH
132421: PPUSH
132422: PPUSH
132423: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
132424: LD_ADDR_VAR 0 12
132428: PUSH
132429: LD_EXP 115
132433: PUSH
132434: LD_VAR 0 1
132438: ARRAY
132439: PPUSH
132440: LD_INT 25
132442: PUSH
132443: LD_INT 3
132445: PUSH
132446: EMPTY
132447: LIST
132448: LIST
132449: PPUSH
132450: CALL_OW 72
132454: ST_TO_ADDR
// if mc_remote_driver [ base ] then
132455: LD_EXP 155
132459: PUSH
132460: LD_VAR 0 1
132464: ARRAY
132465: IFFALSE 132489
// mechs := mechs diff mc_remote_driver [ base ] ;
132467: LD_ADDR_VAR 0 12
132471: PUSH
132472: LD_VAR 0 12
132476: PUSH
132477: LD_EXP 155
132481: PUSH
132482: LD_VAR 0 1
132486: ARRAY
132487: DIFF
132488: ST_TO_ADDR
// for i in mechs do
132489: LD_ADDR_VAR 0 4
132493: PUSH
132494: LD_VAR 0 12
132498: PUSH
132499: FOR_IN
132500: IFFALSE 132535
// if GetTag ( i ) > 0 then
132502: LD_VAR 0 4
132506: PPUSH
132507: CALL_OW 110
132511: PUSH
132512: LD_INT 0
132514: GREATER
132515: IFFALSE 132533
// mechs := mechs diff i ;
132517: LD_ADDR_VAR 0 12
132521: PUSH
132522: LD_VAR 0 12
132526: PUSH
132527: LD_VAR 0 4
132531: DIFF
132532: ST_TO_ADDR
132533: GO 132499
132535: POP
132536: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
132537: LD_ADDR_VAR 0 8
132541: PUSH
132542: LD_EXP 115
132546: PUSH
132547: LD_VAR 0 1
132551: ARRAY
132552: PPUSH
132553: LD_INT 2
132555: PUSH
132556: LD_INT 25
132558: PUSH
132559: LD_INT 1
132561: PUSH
132562: EMPTY
132563: LIST
132564: LIST
132565: PUSH
132566: LD_INT 25
132568: PUSH
132569: LD_INT 5
132571: PUSH
132572: EMPTY
132573: LIST
132574: LIST
132575: PUSH
132576: LD_INT 25
132578: PUSH
132579: LD_INT 8
132581: PUSH
132582: EMPTY
132583: LIST
132584: LIST
132585: PUSH
132586: LD_INT 25
132588: PUSH
132589: LD_INT 9
132591: PUSH
132592: EMPTY
132593: LIST
132594: LIST
132595: PUSH
132596: EMPTY
132597: LIST
132598: LIST
132599: LIST
132600: LIST
132601: LIST
132602: PPUSH
132603: CALL_OW 72
132607: ST_TO_ADDR
// if not defenders and not solds then
132608: LD_VAR 0 2
132612: NOT
132613: PUSH
132614: LD_VAR 0 8
132618: NOT
132619: AND
132620: IFFALSE 132624
// exit ;
132622: GO 134394
// depot_under_attack := false ;
132624: LD_ADDR_VAR 0 16
132628: PUSH
132629: LD_INT 0
132631: ST_TO_ADDR
// sold_defenders := [ ] ;
132632: LD_ADDR_VAR 0 17
132636: PUSH
132637: EMPTY
132638: ST_TO_ADDR
// if mechs then
132639: LD_VAR 0 12
132643: IFFALSE 132796
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
132645: LD_ADDR_VAR 0 4
132649: PUSH
132650: LD_VAR 0 2
132654: PPUSH
132655: LD_INT 21
132657: PUSH
132658: LD_INT 2
132660: PUSH
132661: EMPTY
132662: LIST
132663: LIST
132664: PPUSH
132665: CALL_OW 72
132669: PUSH
132670: FOR_IN
132671: IFFALSE 132794
// begin if GetTag ( i ) <> 20 then
132673: LD_VAR 0 4
132677: PPUSH
132678: CALL_OW 110
132682: PUSH
132683: LD_INT 20
132685: NONEQUAL
132686: IFFALSE 132700
// SetTag ( i , 20 ) ;
132688: LD_VAR 0 4
132692: PPUSH
132693: LD_INT 20
132695: PPUSH
132696: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
132700: LD_VAR 0 4
132704: PPUSH
132705: CALL_OW 263
132709: PUSH
132710: LD_INT 1
132712: EQUAL
132713: PUSH
132714: LD_VAR 0 4
132718: PPUSH
132719: CALL_OW 311
132723: NOT
132724: AND
132725: IFFALSE 132792
// begin un := mechs [ 1 ] ;
132727: LD_ADDR_VAR 0 10
132731: PUSH
132732: LD_VAR 0 12
132736: PUSH
132737: LD_INT 1
132739: ARRAY
132740: ST_TO_ADDR
// ComExit ( un ) ;
132741: LD_VAR 0 10
132745: PPUSH
132746: CALL 103719 0 1
// AddComEnterUnit ( un , i ) ;
132750: LD_VAR 0 10
132754: PPUSH
132755: LD_VAR 0 4
132759: PPUSH
132760: CALL_OW 180
// SetTag ( un , 19 ) ;
132764: LD_VAR 0 10
132768: PPUSH
132769: LD_INT 19
132771: PPUSH
132772: CALL_OW 109
// mechs := mechs diff un ;
132776: LD_ADDR_VAR 0 12
132780: PUSH
132781: LD_VAR 0 12
132785: PUSH
132786: LD_VAR 0 10
132790: DIFF
132791: ST_TO_ADDR
// end ; end ;
132792: GO 132670
132794: POP
132795: POP
// if solds then
132796: LD_VAR 0 8
132800: IFFALSE 132859
// for i in solds do
132802: LD_ADDR_VAR 0 4
132806: PUSH
132807: LD_VAR 0 8
132811: PUSH
132812: FOR_IN
132813: IFFALSE 132857
// if not GetTag ( i ) then
132815: LD_VAR 0 4
132819: PPUSH
132820: CALL_OW 110
132824: NOT
132825: IFFALSE 132855
// begin defenders := defenders union i ;
132827: LD_ADDR_VAR 0 2
132831: PUSH
132832: LD_VAR 0 2
132836: PUSH
132837: LD_VAR 0 4
132841: UNION
132842: ST_TO_ADDR
// SetTag ( i , 18 ) ;
132843: LD_VAR 0 4
132847: PPUSH
132848: LD_INT 18
132850: PPUSH
132851: CALL_OW 109
// end ;
132855: GO 132812
132857: POP
132858: POP
// repeat wait ( 0 0$2 ) ;
132859: LD_INT 70
132861: PPUSH
132862: CALL_OW 67
// enemy := mc_scan [ base ] ;
132866: LD_ADDR_VAR 0 21
132870: PUSH
132871: LD_EXP 138
132875: PUSH
132876: LD_VAR 0 1
132880: ARRAY
132881: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
132882: LD_EXP 115
132886: PUSH
132887: LD_VAR 0 1
132891: ARRAY
132892: NOT
132893: PUSH
132894: LD_EXP 115
132898: PUSH
132899: LD_VAR 0 1
132903: ARRAY
132904: PUSH
132905: EMPTY
132906: EQUAL
132907: OR
132908: IFFALSE 132945
// begin for i in defenders do
132910: LD_ADDR_VAR 0 4
132914: PUSH
132915: LD_VAR 0 2
132919: PUSH
132920: FOR_IN
132921: IFFALSE 132934
// ComStop ( i ) ;
132923: LD_VAR 0 4
132927: PPUSH
132928: CALL_OW 141
132932: GO 132920
132934: POP
132935: POP
// defenders := [ ] ;
132936: LD_ADDR_VAR 0 2
132940: PUSH
132941: EMPTY
132942: ST_TO_ADDR
// exit ;
132943: GO 134394
// end ; for i in defenders do
132945: LD_ADDR_VAR 0 4
132949: PUSH
132950: LD_VAR 0 2
132954: PUSH
132955: FOR_IN
132956: IFFALSE 133854
// begin e := NearestUnitToUnit ( enemy , i ) ;
132958: LD_ADDR_VAR 0 13
132962: PUSH
132963: LD_VAR 0 21
132967: PPUSH
132968: LD_VAR 0 4
132972: PPUSH
132973: CALL_OW 74
132977: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132978: LD_ADDR_VAR 0 7
132982: PUSH
132983: LD_EXP 115
132987: PUSH
132988: LD_VAR 0 1
132992: ARRAY
132993: PPUSH
132994: LD_INT 2
132996: PUSH
132997: LD_INT 30
132999: PUSH
133000: LD_INT 0
133002: PUSH
133003: EMPTY
133004: LIST
133005: LIST
133006: PUSH
133007: LD_INT 30
133009: PUSH
133010: LD_INT 1
133012: PUSH
133013: EMPTY
133014: LIST
133015: LIST
133016: PUSH
133017: EMPTY
133018: LIST
133019: LIST
133020: LIST
133021: PPUSH
133022: CALL_OW 72
133026: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
133027: LD_ADDR_VAR 0 16
133031: PUSH
133032: LD_VAR 0 7
133036: NOT
133037: PUSH
133038: LD_VAR 0 7
133042: PPUSH
133043: LD_INT 3
133045: PUSH
133046: LD_INT 24
133048: PUSH
133049: LD_INT 600
133051: PUSH
133052: EMPTY
133053: LIST
133054: LIST
133055: PUSH
133056: EMPTY
133057: LIST
133058: LIST
133059: PPUSH
133060: CALL_OW 72
133064: OR
133065: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
133066: LD_VAR 0 4
133070: PPUSH
133071: CALL_OW 247
133075: PUSH
133076: LD_INT 2
133078: DOUBLE
133079: EQUAL
133080: IFTRUE 133084
133082: GO 133480
133084: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
133085: LD_VAR 0 4
133089: PPUSH
133090: CALL_OW 256
133094: PUSH
133095: LD_INT 1000
133097: EQUAL
133098: PUSH
133099: LD_VAR 0 4
133103: PPUSH
133104: LD_VAR 0 13
133108: PPUSH
133109: CALL_OW 296
133113: PUSH
133114: LD_INT 40
133116: LESS
133117: PUSH
133118: LD_VAR 0 13
133122: PPUSH
133123: LD_EXP 140
133127: PUSH
133128: LD_VAR 0 1
133132: ARRAY
133133: PPUSH
133134: CALL_OW 308
133138: OR
133139: AND
133140: IFFALSE 133262
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
133142: LD_VAR 0 4
133146: PPUSH
133147: CALL_OW 262
133151: PUSH
133152: LD_INT 1
133154: EQUAL
133155: PUSH
133156: LD_VAR 0 4
133160: PPUSH
133161: CALL_OW 261
133165: PUSH
133166: LD_INT 30
133168: LESS
133169: AND
133170: PUSH
133171: LD_VAR 0 7
133175: AND
133176: IFFALSE 133246
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
133178: LD_VAR 0 4
133182: PPUSH
133183: LD_VAR 0 7
133187: PPUSH
133188: LD_VAR 0 4
133192: PPUSH
133193: CALL_OW 74
133197: PPUSH
133198: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
133202: LD_VAR 0 4
133206: PPUSH
133207: LD_VAR 0 7
133211: PPUSH
133212: LD_VAR 0 4
133216: PPUSH
133217: CALL_OW 74
133221: PPUSH
133222: CALL_OW 296
133226: PUSH
133227: LD_INT 6
133229: LESS
133230: IFFALSE 133244
// SetFuel ( i , 100 ) ;
133232: LD_VAR 0 4
133236: PPUSH
133237: LD_INT 100
133239: PPUSH
133240: CALL_OW 240
// end else
133244: GO 133260
// ComAttackUnit ( i , e ) ;
133246: LD_VAR 0 4
133250: PPUSH
133251: LD_VAR 0 13
133255: PPUSH
133256: CALL_OW 115
// end else
133260: GO 133363
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
133262: LD_VAR 0 13
133266: PPUSH
133267: LD_EXP 140
133271: PUSH
133272: LD_VAR 0 1
133276: ARRAY
133277: PPUSH
133278: CALL_OW 308
133282: NOT
133283: PUSH
133284: LD_VAR 0 4
133288: PPUSH
133289: LD_VAR 0 13
133293: PPUSH
133294: CALL_OW 296
133298: PUSH
133299: LD_INT 40
133301: GREATEREQUAL
133302: AND
133303: PUSH
133304: LD_VAR 0 4
133308: PPUSH
133309: CALL_OW 256
133313: PUSH
133314: LD_INT 650
133316: LESSEQUAL
133317: OR
133318: PUSH
133319: LD_VAR 0 4
133323: PPUSH
133324: LD_EXP 139
133328: PUSH
133329: LD_VAR 0 1
133333: ARRAY
133334: PPUSH
133335: CALL_OW 308
133339: NOT
133340: AND
133341: IFFALSE 133363
// ComMoveToArea ( i , mc_parking [ base ] ) ;
133343: LD_VAR 0 4
133347: PPUSH
133348: LD_EXP 139
133352: PUSH
133353: LD_VAR 0 1
133357: ARRAY
133358: PPUSH
133359: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
133363: LD_VAR 0 4
133367: PPUSH
133368: CALL_OW 256
133372: PUSH
133373: LD_INT 1000
133375: LESS
133376: PUSH
133377: LD_VAR 0 4
133381: PPUSH
133382: CALL_OW 263
133386: PUSH
133387: LD_INT 1
133389: EQUAL
133390: AND
133391: PUSH
133392: LD_VAR 0 4
133396: PPUSH
133397: CALL_OW 311
133401: AND
133402: PUSH
133403: LD_VAR 0 4
133407: PPUSH
133408: LD_EXP 139
133412: PUSH
133413: LD_VAR 0 1
133417: ARRAY
133418: PPUSH
133419: CALL_OW 308
133423: AND
133424: IFFALSE 133478
// begin mech := IsDrivenBy ( i ) ;
133426: LD_ADDR_VAR 0 9
133430: PUSH
133431: LD_VAR 0 4
133435: PPUSH
133436: CALL_OW 311
133440: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
133441: LD_VAR 0 9
133445: PPUSH
133446: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
133450: LD_VAR 0 9
133454: PPUSH
133455: LD_VAR 0 4
133459: PPUSH
133460: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
133464: LD_VAR 0 9
133468: PPUSH
133469: LD_VAR 0 4
133473: PPUSH
133474: CALL_OW 180
// end ; end ; unit_human :
133478: GO 133825
133480: LD_INT 1
133482: DOUBLE
133483: EQUAL
133484: IFTRUE 133488
133486: GO 133824
133488: POP
// begin b := IsInUnit ( i ) ;
133489: LD_ADDR_VAR 0 18
133493: PUSH
133494: LD_VAR 0 4
133498: PPUSH
133499: CALL_OW 310
133503: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
133504: LD_ADDR_VAR 0 19
133508: PUSH
133509: LD_VAR 0 18
133513: NOT
133514: PUSH
133515: LD_VAR 0 18
133519: PPUSH
133520: CALL_OW 266
133524: PUSH
133525: LD_INT 32
133527: PUSH
133528: LD_INT 31
133530: PUSH
133531: EMPTY
133532: LIST
133533: LIST
133534: IN
133535: OR
133536: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
133537: LD_VAR 0 18
133541: PPUSH
133542: CALL_OW 266
133546: PUSH
133547: LD_INT 5
133549: EQUAL
133550: PUSH
133551: LD_VAR 0 4
133555: PPUSH
133556: CALL_OW 257
133560: PUSH
133561: LD_INT 1
133563: PUSH
133564: LD_INT 2
133566: PUSH
133567: LD_INT 3
133569: PUSH
133570: LD_INT 4
133572: PUSH
133573: EMPTY
133574: LIST
133575: LIST
133576: LIST
133577: LIST
133578: IN
133579: AND
133580: IFFALSE 133617
// begin class := AllowSpecClass ( i ) ;
133582: LD_ADDR_VAR 0 20
133586: PUSH
133587: LD_VAR 0 4
133591: PPUSH
133592: CALL 67706 0 1
133596: ST_TO_ADDR
// if class then
133597: LD_VAR 0 20
133601: IFFALSE 133617
// ComChangeProfession ( i , class ) ;
133603: LD_VAR 0 4
133607: PPUSH
133608: LD_VAR 0 20
133612: PPUSH
133613: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
133617: LD_VAR 0 16
133621: PUSH
133622: LD_VAR 0 2
133626: PPUSH
133627: LD_INT 21
133629: PUSH
133630: LD_INT 2
133632: PUSH
133633: EMPTY
133634: LIST
133635: LIST
133636: PPUSH
133637: CALL_OW 72
133641: PUSH
133642: LD_INT 1
133644: LESSEQUAL
133645: OR
133646: PUSH
133647: LD_VAR 0 19
133651: AND
133652: PUSH
133653: LD_VAR 0 4
133657: PUSH
133658: LD_VAR 0 17
133662: IN
133663: NOT
133664: AND
133665: IFFALSE 133758
// begin if b then
133667: LD_VAR 0 18
133671: IFFALSE 133720
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
133673: LD_VAR 0 18
133677: PPUSH
133678: LD_VAR 0 21
133682: PPUSH
133683: LD_VAR 0 18
133687: PPUSH
133688: CALL_OW 74
133692: PPUSH
133693: CALL_OW 296
133697: PUSH
133698: LD_INT 10
133700: LESS
133701: PUSH
133702: LD_VAR 0 18
133706: PPUSH
133707: CALL_OW 461
133711: PUSH
133712: LD_INT 7
133714: NONEQUAL
133715: AND
133716: IFFALSE 133720
// continue ;
133718: GO 132955
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
133720: LD_ADDR_VAR 0 17
133724: PUSH
133725: LD_VAR 0 17
133729: PPUSH
133730: LD_VAR 0 17
133734: PUSH
133735: LD_INT 1
133737: PLUS
133738: PPUSH
133739: LD_VAR 0 4
133743: PPUSH
133744: CALL_OW 1
133748: ST_TO_ADDR
// ComExitBuilding ( i ) ;
133749: LD_VAR 0 4
133753: PPUSH
133754: CALL_OW 122
// end ; if sold_defenders then
133758: LD_VAR 0 17
133762: IFFALSE 133822
// if i in sold_defenders then
133764: LD_VAR 0 4
133768: PUSH
133769: LD_VAR 0 17
133773: IN
133774: IFFALSE 133822
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
133776: LD_VAR 0 4
133780: PPUSH
133781: CALL_OW 314
133785: NOT
133786: PUSH
133787: LD_VAR 0 4
133791: PPUSH
133792: LD_VAR 0 13
133796: PPUSH
133797: CALL_OW 296
133801: PUSH
133802: LD_INT 30
133804: LESS
133805: AND
133806: IFFALSE 133822
// ComAttackUnit ( i , e ) ;
133808: LD_VAR 0 4
133812: PPUSH
133813: LD_VAR 0 13
133817: PPUSH
133818: CALL_OW 115
// end ; end ; end ;
133822: GO 133825
133824: POP
// if IsDead ( i ) then
133825: LD_VAR 0 4
133829: PPUSH
133830: CALL_OW 301
133834: IFFALSE 133852
// defenders := defenders diff i ;
133836: LD_ADDR_VAR 0 2
133840: PUSH
133841: LD_VAR 0 2
133845: PUSH
133846: LD_VAR 0 4
133850: DIFF
133851: ST_TO_ADDR
// end ;
133852: GO 132955
133854: POP
133855: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
133856: LD_VAR 0 21
133860: NOT
133861: PUSH
133862: LD_VAR 0 2
133866: NOT
133867: OR
133868: PUSH
133869: LD_EXP 115
133873: PUSH
133874: LD_VAR 0 1
133878: ARRAY
133879: NOT
133880: OR
133881: IFFALSE 132859
// MC_Reset ( base , 18 ) ;
133883: LD_VAR 0 1
133887: PPUSH
133888: LD_INT 18
133890: PPUSH
133891: CALL 39448 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
133895: LD_ADDR_VAR 0 2
133899: PUSH
133900: LD_VAR 0 2
133904: PUSH
133905: LD_VAR 0 2
133909: PPUSH
133910: LD_INT 2
133912: PUSH
133913: LD_INT 25
133915: PUSH
133916: LD_INT 1
133918: PUSH
133919: EMPTY
133920: LIST
133921: LIST
133922: PUSH
133923: LD_INT 25
133925: PUSH
133926: LD_INT 5
133928: PUSH
133929: EMPTY
133930: LIST
133931: LIST
133932: PUSH
133933: LD_INT 25
133935: PUSH
133936: LD_INT 8
133938: PUSH
133939: EMPTY
133940: LIST
133941: LIST
133942: PUSH
133943: LD_INT 25
133945: PUSH
133946: LD_INT 9
133948: PUSH
133949: EMPTY
133950: LIST
133951: LIST
133952: PUSH
133953: EMPTY
133954: LIST
133955: LIST
133956: LIST
133957: LIST
133958: LIST
133959: PPUSH
133960: CALL_OW 72
133964: DIFF
133965: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
133966: LD_VAR 0 21
133970: NOT
133971: PUSH
133972: LD_VAR 0 2
133976: PPUSH
133977: LD_INT 21
133979: PUSH
133980: LD_INT 2
133982: PUSH
133983: EMPTY
133984: LIST
133985: LIST
133986: PPUSH
133987: CALL_OW 72
133991: AND
133992: IFFALSE 134330
// begin tmp := FilterByTag ( defenders , 19 ) ;
133994: LD_ADDR_VAR 0 11
133998: PUSH
133999: LD_VAR 0 2
134003: PPUSH
134004: LD_INT 19
134006: PPUSH
134007: CALL 100895 0 2
134011: ST_TO_ADDR
// if tmp then
134012: LD_VAR 0 11
134016: IFFALSE 134086
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
134018: LD_ADDR_VAR 0 11
134022: PUSH
134023: LD_VAR 0 11
134027: PPUSH
134028: LD_INT 25
134030: PUSH
134031: LD_INT 3
134033: PUSH
134034: EMPTY
134035: LIST
134036: LIST
134037: PPUSH
134038: CALL_OW 72
134042: ST_TO_ADDR
// if tmp then
134043: LD_VAR 0 11
134047: IFFALSE 134086
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
134049: LD_ADDR_EXP 127
134053: PUSH
134054: LD_EXP 127
134058: PPUSH
134059: LD_VAR 0 1
134063: PPUSH
134064: LD_EXP 127
134068: PUSH
134069: LD_VAR 0 1
134073: ARRAY
134074: PUSH
134075: LD_VAR 0 11
134079: UNION
134080: PPUSH
134081: CALL_OW 1
134085: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
134086: LD_VAR 0 1
134090: PPUSH
134091: LD_INT 19
134093: PPUSH
134094: CALL 39448 0 2
// repeat wait ( 0 0$1 ) ;
134098: LD_INT 35
134100: PPUSH
134101: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134105: LD_EXP 115
134109: PUSH
134110: LD_VAR 0 1
134114: ARRAY
134115: NOT
134116: PUSH
134117: LD_EXP 115
134121: PUSH
134122: LD_VAR 0 1
134126: ARRAY
134127: PUSH
134128: EMPTY
134129: EQUAL
134130: OR
134131: IFFALSE 134168
// begin for i in defenders do
134133: LD_ADDR_VAR 0 4
134137: PUSH
134138: LD_VAR 0 2
134142: PUSH
134143: FOR_IN
134144: IFFALSE 134157
// ComStop ( i ) ;
134146: LD_VAR 0 4
134150: PPUSH
134151: CALL_OW 141
134155: GO 134143
134157: POP
134158: POP
// defenders := [ ] ;
134159: LD_ADDR_VAR 0 2
134163: PUSH
134164: EMPTY
134165: ST_TO_ADDR
// exit ;
134166: GO 134394
// end ; for i in defenders do
134168: LD_ADDR_VAR 0 4
134172: PUSH
134173: LD_VAR 0 2
134177: PUSH
134178: FOR_IN
134179: IFFALSE 134268
// begin if not IsInArea ( i , mc_parking [ base ] ) then
134181: LD_VAR 0 4
134185: PPUSH
134186: LD_EXP 139
134190: PUSH
134191: LD_VAR 0 1
134195: ARRAY
134196: PPUSH
134197: CALL_OW 308
134201: NOT
134202: IFFALSE 134226
// ComMoveToArea ( i , mc_parking [ base ] ) else
134204: LD_VAR 0 4
134208: PPUSH
134209: LD_EXP 139
134213: PUSH
134214: LD_VAR 0 1
134218: ARRAY
134219: PPUSH
134220: CALL_OW 113
134224: GO 134266
// if GetControl ( i ) = control_manual then
134226: LD_VAR 0 4
134230: PPUSH
134231: CALL_OW 263
134235: PUSH
134236: LD_INT 1
134238: EQUAL
134239: IFFALSE 134266
// if IsDrivenBy ( i ) then
134241: LD_VAR 0 4
134245: PPUSH
134246: CALL_OW 311
134250: IFFALSE 134266
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
134252: LD_VAR 0 4
134256: PPUSH
134257: CALL_OW 311
134261: PPUSH
134262: CALL_OW 121
// end ;
134266: GO 134178
134268: POP
134269: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
134270: LD_VAR 0 2
134274: PPUSH
134275: LD_INT 95
134277: PUSH
134278: LD_EXP 139
134282: PUSH
134283: LD_VAR 0 1
134287: ARRAY
134288: PUSH
134289: EMPTY
134290: LIST
134291: LIST
134292: PPUSH
134293: CALL_OW 72
134297: PUSH
134298: LD_VAR 0 2
134302: EQUAL
134303: PUSH
134304: LD_EXP 138
134308: PUSH
134309: LD_VAR 0 1
134313: ARRAY
134314: OR
134315: PUSH
134316: LD_EXP 115
134320: PUSH
134321: LD_VAR 0 1
134325: ARRAY
134326: NOT
134327: OR
134328: IFFALSE 134098
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
134330: LD_ADDR_EXP 137
134334: PUSH
134335: LD_EXP 137
134339: PPUSH
134340: LD_VAR 0 1
134344: PPUSH
134345: LD_VAR 0 2
134349: PPUSH
134350: LD_INT 21
134352: PUSH
134353: LD_INT 2
134355: PUSH
134356: EMPTY
134357: LIST
134358: LIST
134359: PPUSH
134360: CALL_OW 72
134364: PPUSH
134365: CALL_OW 1
134369: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
134370: LD_VAR 0 1
134374: PPUSH
134375: LD_INT 19
134377: PPUSH
134378: CALL 39448 0 2
// MC_Reset ( base , 20 ) ;
134382: LD_VAR 0 1
134386: PPUSH
134387: LD_INT 20
134389: PPUSH
134390: CALL 39448 0 2
// end ; end_of_file
134394: LD_VAR 0 3
134398: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
134399: LD_VAR 0 1
134403: PUSH
134404: LD_INT 200
134406: DOUBLE
134407: GREATEREQUAL
134408: IFFALSE 134416
134410: LD_INT 299
134412: DOUBLE
134413: LESSEQUAL
134414: IFTRUE 134418
134416: GO 134450
134418: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
134419: LD_VAR 0 1
134423: PPUSH
134424: LD_VAR 0 2
134428: PPUSH
134429: LD_VAR 0 3
134433: PPUSH
134434: LD_VAR 0 4
134438: PPUSH
134439: LD_VAR 0 5
134443: PPUSH
134444: CALL 123165 0 5
134448: GO 134527
134450: LD_INT 300
134452: DOUBLE
134453: GREATEREQUAL
134454: IFFALSE 134462
134456: LD_INT 399
134458: DOUBLE
134459: LESSEQUAL
134460: IFTRUE 134464
134462: GO 134526
134464: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
134465: LD_VAR 0 1
134469: PPUSH
134470: LD_VAR 0 2
134474: PPUSH
134475: LD_VAR 0 3
134479: PPUSH
134480: LD_VAR 0 4
134484: PPUSH
134485: LD_VAR 0 5
134489: PPUSH
134490: LD_VAR 0 6
134494: PPUSH
134495: LD_VAR 0 7
134499: PPUSH
134500: LD_VAR 0 8
134504: PPUSH
134505: LD_VAR 0 9
134509: PPUSH
134510: LD_VAR 0 10
134514: PPUSH
134515: LD_VAR 0 11
134519: PPUSH
134520: CALL 119494 0 11
134524: GO 134527
134526: POP
// end ;
134527: PPOPN 11
134529: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
134530: LD_VAR 0 1
134534: PPUSH
134535: LD_VAR 0 2
134539: PPUSH
134540: LD_VAR 0 3
134544: PPUSH
134545: LD_VAR 0 4
134549: PPUSH
134550: LD_VAR 0 5
134554: PPUSH
134555: CALL 122901 0 5
// end ; end_of_file
134559: PPOPN 5
134561: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
134562: LD_VAR 0 1
134566: PPUSH
134567: LD_VAR 0 2
134571: PPUSH
134572: LD_VAR 0 3
134576: PPUSH
134577: LD_VAR 0 4
134581: PPUSH
134582: LD_VAR 0 5
134586: PPUSH
134587: LD_VAR 0 6
134591: PPUSH
134592: CALL 107187 0 6
// end ;
134596: PPOPN 6
134598: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
134599: LD_INT 0
134601: PPUSH
// begin if not units then
134602: LD_VAR 0 1
134606: NOT
134607: IFFALSE 134611
// exit ;
134609: GO 134611
// end ;
134611: PPOPN 7
134613: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
134614: CALL 107158 0 0
// end ;
134618: PPOPN 1
134620: END
