// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36665 0 0
// InitNature ;
  19: CALL 36533 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11799 0 0
// PrepareRussian ;
  40: CALL 7071 0 0
// PrepareLegion ;
  44: CALL 4242 0 0
// PreparePowell ;
  48: CALL 3044 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15878 0 0
// MC_Start ( ) ;
  60: CALL 38837 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 123
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 124
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61635 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61728 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61078 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 60893 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61635 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61728 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 60893 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61078 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61508 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60575 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61635 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61728 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 128
 971: PUSH
 972: LD_EXP 128
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 60893 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61635 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61728 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60785 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62046 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61217 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61508 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61508 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 61840 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 60893 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61459 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67329 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72344 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72344 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 57
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 57
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72344 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 57
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 57
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 57
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 57
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72344 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72344 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 58
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 58
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 58
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67329 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 58
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67329 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 58
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67329 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 58
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67329 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2433
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery =  ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING 
2394: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2395: LD_INT 1
2397: PPUSH
2398: LD_INT 10
2400: PPUSH
2401: CALL_OW 384
// Baker = CreateHuman ;
2405: LD_ADDR_EXP 56
2409: PUSH
2410: CALL_OW 44
2414: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: LD_VAR 0 2
2424: PUSH
2425: LD_EXP 56
2429: ADD
2430: ST_TO_ADDR
// end else
2431: GO 2449
// tmp := tmp ^ Stevens ;
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: LD_EXP 42
2447: ADD
2448: ST_TO_ADDR
// if not Lisa then
2449: LD_EXP 43
2453: NOT
2454: IFFALSE 2500
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2456: LD_ADDR_EXP 43
2460: PUSH
2461: LD_STRING Lisa
2463: PPUSH
2464: LD_EXP 1
2468: NOT
2469: PPUSH
2470: LD_STRING 13f_
2472: PPUSH
2473: CALL 67329 0 3
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 43
2482: IFFALSE 2500
// tmp := tmp ^ Lisa ;
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_EXP 43
2498: ADD
2499: ST_TO_ADDR
// end ; if not Donaldson then
2500: LD_EXP 44
2504: NOT
2505: IFFALSE 2551
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2507: LD_ADDR_EXP 44
2511: PUSH
2512: LD_STRING Donaldson
2514: PPUSH
2515: LD_EXP 1
2519: NOT
2520: PPUSH
2521: LD_STRING 13f_
2523: PPUSH
2524: CALL 67329 0 3
2528: ST_TO_ADDR
// if Donaldson then
2529: LD_EXP 44
2533: IFFALSE 2551
// tmp := tmp ^ Donaldson ;
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_EXP 44
2549: ADD
2550: ST_TO_ADDR
// end ; if not Bobby then
2551: LD_EXP 45
2555: NOT
2556: IFFALSE 2602
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2558: LD_ADDR_EXP 45
2562: PUSH
2563: LD_STRING Bobby
2565: PPUSH
2566: LD_EXP 1
2570: NOT
2571: PPUSH
2572: LD_STRING 13f_
2574: PPUSH
2575: CALL 67329 0 3
2579: ST_TO_ADDR
// if Bobby then
2580: LD_EXP 45
2584: IFFALSE 2602
// tmp := tmp ^ Bobby ;
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_VAR 0 2
2595: PUSH
2596: LD_EXP 45
2600: ADD
2601: ST_TO_ADDR
// end ; if not Cyrus then
2602: LD_EXP 46
2606: NOT
2607: IFFALSE 2653
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2609: LD_ADDR_EXP 46
2613: PUSH
2614: LD_STRING Cyrus
2616: PPUSH
2617: LD_EXP 1
2621: NOT
2622: PPUSH
2623: LD_STRING 13f_
2625: PPUSH
2626: CALL 67329 0 3
2630: ST_TO_ADDR
// if Cyrus then
2631: LD_EXP 46
2635: IFFALSE 2653
// tmp := tmp ^ Cyrus ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_VAR 0 2
2646: PUSH
2647: LD_EXP 46
2651: ADD
2652: ST_TO_ADDR
// end ; if not Brown then
2653: LD_EXP 48
2657: NOT
2658: IFFALSE 2704
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2660: LD_ADDR_EXP 48
2664: PUSH
2665: LD_STRING Brown
2667: PPUSH
2668: LD_EXP 1
2672: NOT
2673: PPUSH
2674: LD_STRING 13f_
2676: PPUSH
2677: CALL 67329 0 3
2681: ST_TO_ADDR
// if Brown then
2682: LD_EXP 48
2686: IFFALSE 2704
// tmp := tmp ^ Brown ;
2688: LD_ADDR_VAR 0 2
2692: PUSH
2693: LD_VAR 0 2
2697: PUSH
2698: LD_EXP 48
2702: ADD
2703: ST_TO_ADDR
// end ; if not Gladstone then
2704: LD_EXP 49
2708: NOT
2709: IFFALSE 2755
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2711: LD_ADDR_EXP 49
2715: PUSH
2716: LD_STRING Gladstone
2718: PPUSH
2719: LD_EXP 1
2723: NOT
2724: PPUSH
2725: LD_STRING 13f_
2727: PPUSH
2728: CALL 67329 0 3
2732: ST_TO_ADDR
// if Gladstone then
2733: LD_EXP 49
2737: IFFALSE 2755
// tmp := tmp ^ Gladstone ;
2739: LD_ADDR_VAR 0 2
2743: PUSH
2744: LD_VAR 0 2
2748: PUSH
2749: LD_EXP 49
2753: ADD
2754: ST_TO_ADDR
// end ; if not Houten then
2755: LD_EXP 50
2759: NOT
2760: IFFALSE 2806
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2762: LD_ADDR_EXP 50
2766: PUSH
2767: LD_STRING Houten
2769: PPUSH
2770: LD_EXP 1
2774: NOT
2775: PPUSH
2776: LD_STRING 13f_
2778: PPUSH
2779: CALL 67329 0 3
2783: ST_TO_ADDR
// if Houten then
2784: LD_EXP 50
2788: IFFALSE 2806
// tmp := tmp ^ Houten ;
2790: LD_ADDR_VAR 0 2
2794: PUSH
2795: LD_VAR 0 2
2799: PUSH
2800: LD_EXP 50
2804: ADD
2805: ST_TO_ADDR
// end ; if not Cornel then
2806: LD_EXP 51
2810: NOT
2811: IFFALSE 2857
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2813: LD_ADDR_EXP 51
2817: PUSH
2818: LD_STRING Cornell
2820: PPUSH
2821: LD_EXP 1
2825: NOT
2826: PPUSH
2827: LD_STRING 13f_
2829: PPUSH
2830: CALL 67329 0 3
2834: ST_TO_ADDR
// if Cornel then
2835: LD_EXP 51
2839: IFFALSE 2857
// tmp := tmp ^ Cornel ;
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: LD_VAR 0 2
2850: PUSH
2851: LD_EXP 51
2855: ADD
2856: ST_TO_ADDR
// end ; if not Gary then
2857: LD_EXP 52
2861: NOT
2862: IFFALSE 2908
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2864: LD_ADDR_EXP 52
2868: PUSH
2869: LD_STRING Gary
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13f_
2880: PPUSH
2881: CALL 67329 0 3
2885: ST_TO_ADDR
// if Gary then
2886: LD_EXP 52
2890: IFFALSE 2908
// tmp := tmp ^ Gary ;
2892: LD_ADDR_VAR 0 2
2896: PUSH
2897: LD_VAR 0 2
2901: PUSH
2902: LD_EXP 52
2906: ADD
2907: ST_TO_ADDR
// end ; if not Frank then
2908: LD_EXP 53
2912: NOT
2913: IFFALSE 2959
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2915: LD_ADDR_EXP 53
2919: PUSH
2920: LD_STRING Frank
2922: PPUSH
2923: LD_EXP 1
2927: NOT
2928: PPUSH
2929: LD_STRING 13f_
2931: PPUSH
2932: CALL 67329 0 3
2936: ST_TO_ADDR
// if Frank then
2937: LD_EXP 53
2941: IFFALSE 2959
// tmp := tmp ^ Frank ;
2943: LD_ADDR_VAR 0 2
2947: PUSH
2948: LD_VAR 0 2
2952: PUSH
2953: LD_EXP 53
2957: ADD
2958: ST_TO_ADDR
// end ; if not Kikuchi then
2959: LD_EXP 54
2963: NOT
2964: IFFALSE 3010
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2966: LD_ADDR_EXP 54
2970: PUSH
2971: LD_STRING Kikuchi
2973: PPUSH
2974: LD_EXP 1
2978: NOT
2979: PPUSH
2980: LD_STRING 13f_
2982: PPUSH
2983: CALL 67329 0 3
2987: ST_TO_ADDR
// if Kikuchi then
2988: LD_EXP 54
2992: IFFALSE 3010
// tmp := tmp ^ Kikuchi ;
2994: LD_ADDR_VAR 0 2
2998: PUSH
2999: LD_VAR 0 2
3003: PUSH
3004: LD_EXP 54
3008: ADD
3009: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3010: LD_ADDR_VAR 0 2
3014: PUSH
3015: LD_VAR 0 2
3019: PUSH
3020: LD_STRING 13_other_survivors
3022: PPUSH
3023: CALL_OW 31
3027: UNION
3028: ST_TO_ADDR
// result := tmp ;
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_VAR 0 2
3038: ST_TO_ADDR
// end ; end_of_file
3039: LD_VAR 0 1
3043: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3044: LD_INT 0
3046: PPUSH
3047: PPUSH
3048: PPUSH
3049: PPUSH
3050: PPUSH
3051: PPUSH
3052: PPUSH
3053: PPUSH
3054: PPUSH
3055: PPUSH
// uc_side := 4 ;
3056: LD_ADDR_OWVAR 20
3060: PUSH
3061: LD_INT 4
3063: ST_TO_ADDR
// uc_nation := 1 ;
3064: LD_ADDR_OWVAR 21
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3072: LD_INT 387
3074: PPUSH
3075: CALL_OW 274
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: LD_INT 3500
3085: PUSH
3086: LD_INT 3000
3088: PUSH
3089: LD_INT 2500
3091: PUSH
3092: LD_INT 2000
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PPUSH
3107: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3111: LD_INT 387
3113: PPUSH
3114: CALL_OW 274
3118: PPUSH
3119: LD_INT 2
3121: PPUSH
3122: LD_INT 400
3124: PPUSH
3125: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3129: LD_INT 387
3131: PPUSH
3132: CALL_OW 274
3136: PPUSH
3137: LD_INT 3
3139: PPUSH
3140: LD_INT 10
3142: PPUSH
3143: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3147: LD_ADDR_EXP 59
3151: PUSH
3152: LD_STRING Powell
3154: PPUSH
3155: CALL_OW 25
3159: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3160: LD_EXP 59
3164: PPUSH
3165: LD_INT 57
3167: PPUSH
3168: LD_INT 94
3170: PPUSH
3171: LD_INT 0
3173: PPUSH
3174: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3178: LD_EXP 59
3182: PPUSH
3183: LD_INT 58
3185: PPUSH
3186: LD_INT 94
3188: PPUSH
3189: CALL_OW 118
// vip := [ ] ;
3193: LD_ADDR_EXP 60
3197: PUSH
3198: EMPTY
3199: ST_TO_ADDR
// tmp := [ ] ;
3200: LD_ADDR_VAR 0 5
3204: PUSH
3205: EMPTY
3206: ST_TO_ADDR
// if JMMGirl <> 2 then
3207: LD_EXP 7
3211: PUSH
3212: LD_INT 2
3214: NONEQUAL
3215: IFFALSE 3239
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 43
3221: PUSH
3222: LD_STRING Lisa
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 67329 0 3
3238: ST_TO_ADDR
// if Lisa then
3239: LD_EXP 43
3243: IFFALSE 3261
// tmp := tmp ^ Lisa ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_VAR 0 5
3254: PUSH
3255: LD_EXP 43
3259: ADD
3260: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 44
3265: PUSH
3266: LD_STRING Donaldson
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 67329 0 3
3282: ST_TO_ADDR
// if Donaldson then
3283: LD_EXP 44
3287: IFFALSE 3305
// tmp := tmp ^ Donaldson ;
3289: LD_ADDR_VAR 0 5
3293: PUSH
3294: LD_VAR 0 5
3298: PUSH
3299: LD_EXP 44
3303: ADD
3304: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 45
3309: PUSH
3310: LD_STRING Bobby
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 67329 0 3
3326: ST_TO_ADDR
// if Bobby then
3327: LD_EXP 45
3331: IFFALSE 3349
// tmp := tmp ^ Bobby ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: LD_EXP 45
3347: ADD
3348: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 46
3353: PUSH
3354: LD_STRING Cyrus
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 67329 0 3
3370: ST_TO_ADDR
// if Cyrus then
3371: LD_EXP 46
3375: IFFALSE 3393
// tmp := tmp ^ Cyrus ;
3377: LD_ADDR_VAR 0 5
3381: PUSH
3382: LD_VAR 0 5
3386: PUSH
3387: LD_EXP 46
3391: ADD
3392: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 47
3397: PUSH
3398: LD_STRING Denis
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 67329 0 3
3414: ST_TO_ADDR
// if not Denis then
3415: LD_EXP 47
3419: NOT
3420: IFFALSE 3444
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3422: LD_ADDR_EXP 47
3426: PUSH
3427: LD_STRING Denis
3429: PPUSH
3430: LD_EXP 1
3434: NOT
3435: PPUSH
3436: LD_STRING 13f_
3438: PPUSH
3439: CALL 67329 0 3
3443: ST_TO_ADDR
// if Denis then
3444: LD_EXP 47
3448: IFFALSE 3466
// tmp := tmp ^ Denis ;
3450: LD_ADDR_VAR 0 5
3454: PUSH
3455: LD_VAR 0 5
3459: PUSH
3460: LD_EXP 47
3464: ADD
3465: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3466: LD_ADDR_EXP 48
3470: PUSH
3471: LD_STRING Brown
3473: PPUSH
3474: LD_EXP 1
3478: NOT
3479: PPUSH
3480: LD_STRING 13s_
3482: PPUSH
3483: CALL 67329 0 3
3487: ST_TO_ADDR
// if Brown then
3488: LD_EXP 48
3492: IFFALSE 3510
// tmp := tmp ^ Brown ;
3494: LD_ADDR_VAR 0 5
3498: PUSH
3499: LD_VAR 0 5
3503: PUSH
3504: LD_EXP 48
3508: ADD
3509: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3510: LD_ADDR_EXP 49
3514: PUSH
3515: LD_STRING Gladstone
3517: PPUSH
3518: LD_EXP 1
3522: NOT
3523: PPUSH
3524: LD_STRING 13s_
3526: PPUSH
3527: CALL 67329 0 3
3531: ST_TO_ADDR
// if Gladstone then
3532: LD_EXP 49
3536: IFFALSE 3554
// tmp := tmp ^ Gladstone ;
3538: LD_ADDR_VAR 0 5
3542: PUSH
3543: LD_VAR 0 5
3547: PUSH
3548: LD_EXP 49
3552: ADD
3553: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3554: LD_ADDR_EXP 50
3558: PUSH
3559: LD_STRING Houten
3561: PPUSH
3562: LD_EXP 1
3566: NOT
3567: PPUSH
3568: LD_STRING 13s_
3570: PPUSH
3571: CALL 67329 0 3
3575: ST_TO_ADDR
// if Houten then
3576: LD_EXP 50
3580: IFFALSE 3598
// tmp := tmp ^ Houten ;
3582: LD_ADDR_VAR 0 5
3586: PUSH
3587: LD_VAR 0 5
3591: PUSH
3592: LD_EXP 50
3596: ADD
3597: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3598: LD_ADDR_EXP 51
3602: PUSH
3603: LD_STRING Cornel
3605: PPUSH
3606: LD_EXP 1
3610: NOT
3611: PPUSH
3612: LD_STRING 13s_
3614: PPUSH
3615: CALL 67329 0 3
3619: ST_TO_ADDR
// if Cornel then
3620: LD_EXP 51
3624: IFFALSE 3642
// tmp := tmp ^ Cornel ;
3626: LD_ADDR_VAR 0 5
3630: PUSH
3631: LD_VAR 0 5
3635: PUSH
3636: LD_EXP 51
3640: ADD
3641: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3642: LD_ADDR_EXP 52
3646: PUSH
3647: LD_STRING Gary
3649: PPUSH
3650: LD_EXP 1
3654: NOT
3655: PPUSH
3656: LD_STRING 13s_
3658: PPUSH
3659: CALL 67329 0 3
3663: ST_TO_ADDR
// if Gary then
3664: LD_EXP 52
3668: IFFALSE 3686
// tmp := tmp ^ Gary ;
3670: LD_ADDR_VAR 0 5
3674: PUSH
3675: LD_VAR 0 5
3679: PUSH
3680: LD_EXP 52
3684: ADD
3685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3686: LD_ADDR_EXP 53
3690: PUSH
3691: LD_STRING Frank
3693: PPUSH
3694: LD_EXP 1
3698: NOT
3699: PPUSH
3700: LD_STRING 13s_
3702: PPUSH
3703: CALL 67329 0 3
3707: ST_TO_ADDR
// if Frank then
3708: LD_EXP 53
3712: IFFALSE 3730
// tmp := tmp ^ Frank ;
3714: LD_ADDR_VAR 0 5
3718: PUSH
3719: LD_VAR 0 5
3723: PUSH
3724: LD_EXP 53
3728: ADD
3729: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3730: LD_ADDR_EXP 54
3734: PUSH
3735: LD_STRING Kikuchi
3737: PPUSH
3738: LD_EXP 1
3742: NOT
3743: PPUSH
3744: LD_STRING 13s_
3746: PPUSH
3747: CALL 67329 0 3
3751: ST_TO_ADDR
// if Kikuchi then
3752: LD_EXP 54
3756: IFFALSE 3774
// tmp := tmp ^ Kikuchi ;
3758: LD_ADDR_VAR 0 5
3762: PUSH
3763: LD_VAR 0 5
3767: PUSH
3768: LD_EXP 54
3772: ADD
3773: ST_TO_ADDR
// vip := tmp ;
3774: LD_ADDR_EXP 60
3778: PUSH
3779: LD_VAR 0 5
3783: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3784: LD_ADDR_VAR 0 5
3788: PUSH
3789: LD_VAR 0 5
3793: PUSH
3794: LD_STRING 13s_others
3796: PPUSH
3797: CALL_OW 31
3801: UNION
3802: ST_TO_ADDR
// if tmp < 18 then
3803: LD_VAR 0 5
3807: PUSH
3808: LD_INT 18
3810: LESS
3811: IFFALSE 3904
// for i = 1 to 18 - tmp do
3813: LD_ADDR_VAR 0 2
3817: PUSH
3818: DOUBLE
3819: LD_INT 1
3821: DEC
3822: ST_TO_ADDR
3823: LD_INT 18
3825: PUSH
3826: LD_VAR 0 5
3830: MINUS
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3902
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3835: LD_INT 1
3837: PPUSH
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 4
3845: MOD
3846: PUSH
3847: LD_INT 1
3849: PLUS
3850: PPUSH
3851: LD_INT 4
3853: PPUSH
3854: CALL_OW 380
// un := CreateHuman ;
3858: LD_ADDR_VAR 0 10
3862: PUSH
3863: CALL_OW 44
3867: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3868: LD_ADDR_VAR 0 5
3872: PUSH
3873: LD_VAR 0 5
3877: PPUSH
3878: LD_VAR 0 10
3882: PPUSH
3883: CALL 104778 0 2
3887: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3888: LD_VAR 0 10
3892: PPUSH
3893: LD_INT 1
3895: PPUSH
3896: CALL_OW 109
// end ;
3900: GO 3832
3902: POP
3903: POP
// depot := HexInfo ( 53 , 94 ) ;
3904: LD_ADDR_VAR 0 6
3908: PUSH
3909: LD_INT 53
3911: PPUSH
3912: LD_INT 94
3914: PPUSH
3915: CALL_OW 428
3919: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
3920: LD_ADDR_VAR 0 7
3924: PUSH
3925: LD_INT 56
3927: PPUSH
3928: LD_INT 101
3930: PPUSH
3931: CALL_OW 428
3935: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
3936: LD_ADDR_VAR 0 8
3940: PUSH
3941: LD_INT 67
3943: PPUSH
3944: LD_INT 101
3946: PPUSH
3947: CALL_OW 428
3951: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
3952: LD_ADDR_VAR 0 9
3956: PUSH
3957: LD_INT 54
3959: PPUSH
3960: LD_INT 85
3962: PPUSH
3963: CALL_OW 428
3967: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
3968: LD_ADDR_VAR 0 3
3972: PUSH
3973: LD_VAR 0 8
3977: PUSH
3978: LD_VAR 0 6
3982: PUSH
3983: LD_VAR 0 9
3987: PUSH
3988: LD_VAR 0 7
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: LIST
3997: LIST
3998: ST_TO_ADDR
// for i in tmp do
3999: LD_ADDR_VAR 0 2
4003: PUSH
4004: LD_VAR 0 5
4008: PUSH
4009: FOR_IN
4010: IFFALSE 4098
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4012: LD_VAR 0 3
4016: PUSH
4017: LD_INT 1
4019: ARRAY
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: EQUAL
4029: IFFALSE 4049
// b := Delete ( b , 1 ) ;
4031: LD_ADDR_VAR 0 3
4035: PUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 3
4048: ST_TO_ADDR
// if b then
4049: LD_VAR 0 3
4053: IFFALSE 4075
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4055: LD_VAR 0 2
4059: PPUSH
4060: LD_VAR 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: CALL_OW 52
4073: GO 4096
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4075: LD_VAR 0 2
4079: PPUSH
4080: LD_INT 61
4082: PPUSH
4083: LD_INT 89
4085: PPUSH
4086: LD_INT 8
4088: PPUSH
4089: LD_INT 0
4091: PPUSH
4092: CALL_OW 50
// end ;
4096: GO 4009
4098: POP
4099: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4100: LD_INT 2
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 12
4111: PPUSH
4112: LD_INT 100
4114: PPUSH
4115: CALL 72344 0 5
// veh := CreateVehicle ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: CALL_OW 45
4128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4129: LD_VAR 0 4
4133: PPUSH
4134: LD_INT 4
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 49
4148: PPUSH
4149: LD_INT 88
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4159: LD_VAR 0 4
4163: PPUSH
4164: LD_INT 1
4166: PPUSH
4167: LD_INT 100
4169: PPUSH
4170: CALL_OW 290
// uc_side := 0 ;
4174: LD_ADDR_OWVAR 20
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// uc_nation := 0 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// for i := 1 to 3 do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: DOUBLE
4196: LD_INT 1
4198: DEC
4199: ST_TO_ADDR
4200: LD_INT 3
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4235
// begin InitHc ;
4206: CALL_OW 19
// hc_class := class_apeman ;
4210: LD_ADDR_OWVAR 28
4214: PUSH
4215: LD_INT 12
4217: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4218: CALL_OW 44
4222: PPUSH
4223: LD_INT 13
4225: PPUSH
4226: LD_INT 0
4228: PPUSH
4229: CALL_OW 49
// end ;
4233: GO 4203
4235: POP
4236: POP
// end ; end_of_file
4237: LD_VAR 0 1
4241: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4242: LD_INT 0
4244: PPUSH
4245: PPUSH
4246: PPUSH
4247: PPUSH
4248: PPUSH
// side := 8 ;
4249: LD_ADDR_VAR 0 3
4253: PUSH
4254: LD_INT 8
4256: ST_TO_ADDR
// uc_side := side ;
4257: LD_ADDR_OWVAR 20
4261: PUSH
4262: LD_VAR 0 3
4266: ST_TO_ADDR
// uc_nation := 2 ;
4267: LD_ADDR_OWVAR 21
4271: PUSH
4272: LD_INT 2
4274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4275: LD_ADDR_VAR 0 2
4279: PUSH
4280: LD_INT 22
4282: PUSH
4283: LD_VAR 0 3
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: LD_INT 21
4294: PUSH
4295: LD_INT 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PPUSH
4306: CALL_OW 69
4310: PUSH
4311: FOR_IN
4312: IFFALSE 4328
// SetBLevel ( i , 10 ) ;
4314: LD_VAR 0 2
4318: PPUSH
4319: LD_INT 10
4321: PPUSH
4322: CALL_OW 241
4326: GO 4311
4328: POP
4329: POP
// if KurtStatus then
4330: LD_EXP 3
4334: IFFALSE 4357
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4336: LD_ADDR_EXP 61
4340: PUSH
4341: LD_STRING Kurt
4343: PPUSH
4344: LD_INT 0
4346: PPUSH
4347: LD_STRING 
4349: PPUSH
4350: CALL 67329 0 3
4354: ST_TO_ADDR
4355: GO 4379
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4357: LD_ADDR_EXP 61
4361: PUSH
4362: LD_STRING AltKurt
4364: PPUSH
4365: LD_EXP 1
4369: NOT
4370: PPUSH
4371: LD_STRING 
4373: PPUSH
4374: CALL 67329 0 3
4378: ST_TO_ADDR
// if not Kurt then
4379: LD_EXP 61
4383: NOT
4384: IFFALSE 4410
// begin InitHc ;
4386: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4390: LD_INT 1
4392: PPUSH
4393: LD_INT 10
4395: PPUSH
4396: CALL_OW 381
// Kurt := CreateHuman ;
4400: LD_ADDR_EXP 61
4404: PUSH
4405: CALL_OW 44
4409: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4410: LD_EXP 61
4414: PPUSH
4415: LD_INT 324
4417: PPUSH
4418: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4422: LD_ADDR_EXP 62
4426: PUSH
4427: LD_STRING Kozlov
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: LD_STRING 
4435: PPUSH
4436: CALL 67329 0 3
4440: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4441: LD_EXP 62
4445: PPUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 8
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 23
4458: PUSH
4459: LD_INT 3
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 30
4468: PUSH
4469: LD_INT 8
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PPUSH
4490: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4494: LD_EXP 62
4498: PPUSH
4499: LD_INT 3
4501: PPUSH
4502: LD_INT 10
4504: PPUSH
4505: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4509: LD_EXP 62
4513: PPUSH
4514: LD_INT 4
4516: PPUSH
4517: LD_INT 10
4519: PPUSH
4520: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4524: LD_ADDR_VAR 0 5
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_VAR 0 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 30
4543: PUSH
4544: LD_INT 32
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 58
4553: PUSH
4554: EMPTY
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 69
4566: ST_TO_ADDR
// for i = 1 to 10 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 10
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4653
// begin uc_nation := nation_nature ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 0
4590: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4591: LD_ADDR_OWVAR 28
4595: PUSH
4596: LD_INT 15
4598: ST_TO_ADDR
// hc_gallery :=  ;
4599: LD_ADDR_OWVAR 33
4603: PUSH
4604: LD_STRING 
4606: ST_TO_ADDR
// hc_name :=  ;
4607: LD_ADDR_OWVAR 26
4611: PUSH
4612: LD_STRING 
4614: ST_TO_ADDR
// un := CreateHuman ;
4615: LD_ADDR_VAR 0 4
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4625: LD_VAR 0 4
4629: PPUSH
4630: LD_VAR 0 5
4634: PUSH
4635: LD_VAR 0 5
4639: PUSH
4640: LD_VAR 0 2
4644: MINUS
4645: ARRAY
4646: PPUSH
4647: CALL_OW 52
// end ;
4651: GO 4580
4653: POP
4654: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4655: LD_ADDR_VAR 0 5
4659: PUSH
4660: LD_STRING 12_kurt_squad
4662: PPUSH
4663: CALL_OW 31
4667: ST_TO_ADDR
// if tmp then
4668: LD_VAR 0 5
4672: IFFALSE 4706
// for i in tmp do
4674: LD_ADDR_VAR 0 2
4678: PUSH
4679: LD_VAR 0 5
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4704
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4687: LD_VAR 0 2
4691: PPUSH
4692: LD_INT 5
4694: PPUSH
4695: LD_INT 0
4697: PPUSH
4698: CALL_OW 49
4702: GO 4684
4704: POP
4705: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4706: LD_INT 324
4708: PPUSH
4709: LD_INT 5
4711: PPUSH
4712: LD_STRING 
4714: PPUSH
4715: LD_INT 8
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: LD_INT 10
4723: PUSH
4724: LD_INT 10
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_OWVAR 67
4737: ARRAY
4738: PPUSH
4739: LD_INT 3000
4741: PUSH
4742: LD_INT 500
4744: PUSH
4745: LD_INT 150
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: LIST
4752: PPUSH
4753: LD_INT 16
4755: PUSH
4756: LD_INT 6
4758: PUSH
4759: LD_INT 6
4761: PUSH
4762: LD_INT 8
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: PPUSH
4771: CALL 75788 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4775: LD_ADDR_EXP 99
4779: PUSH
4780: LD_EXP 99
4784: PPUSH
4785: LD_INT 3
4787: PPUSH
4788: LD_INT 22
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 23
4802: PUSH
4803: LD_INT 2
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: PUSH
4810: LD_INT 3
4812: PUSH
4813: LD_INT 21
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 69
4836: PUSH
4837: LD_EXP 61
4841: DIFF
4842: PPUSH
4843: CALL_OW 1
4847: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4848: LD_INT 1
4850: PPUSH
4851: LD_INT 7
4853: PPUSH
4854: CALL_OW 383
// Friend := CreateHuman ;
4858: LD_ADDR_EXP 63
4862: PUSH
4863: CALL_OW 44
4867: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4868: LD_INT 14
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 29
4879: PPUSH
4880: LD_INT 100
4882: PPUSH
4883: CALL 72344 0 5
// powellBomb := CreateVehicle ;
4887: LD_ADDR_EXP 64
4891: PUSH
4892: CALL_OW 45
4896: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4897: LD_EXP 64
4901: PPUSH
4902: LD_INT 90
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: LD_INT 0
4910: PPUSH
4911: CALL_OW 48
// end ;
4915: LD_VAR 0 1
4919: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4920: LD_INT 0
4922: PPUSH
4923: PPUSH
4924: PPUSH
// if IsLive ( kozlov_fac ) then
4925: LD_INT 332
4927: PPUSH
4928: CALL_OW 300
4932: IFFALSE 4936
// exit ;
4934: GO 5503
// ComExitBuilding ( Kozlov ) ;
4936: LD_EXP 62
4940: PPUSH
4941: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4945: LD_EXP 62
4949: PPUSH
4950: CALL_OW 257
4954: PUSH
4955: LD_INT 2
4957: NONEQUAL
4958: IFFALSE 4993
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4960: LD_EXP 62
4964: PPUSH
4965: LD_INT 324
4967: PPUSH
4968: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4972: LD_EXP 62
4976: PPUSH
4977: LD_INT 2
4979: PPUSH
4980: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4984: LD_EXP 62
4988: PPUSH
4989: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4993: LD_EXP 62
4997: PPUSH
4998: LD_INT 2
5000: PPUSH
5001: LD_INT 93
5003: PPUSH
5004: LD_INT 32
5006: PPUSH
5007: LD_INT 3
5009: PPUSH
5010: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5014: LD_INT 35
5016: PPUSH
5017: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 23
5043: PUSH
5044: LD_INT 3
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 57
5053: PUSH
5054: EMPTY
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: IFFALSE 5014
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5069: LD_ADDR_VAR 0 2
5073: PUSH
5074: LD_INT 22
5076: PUSH
5077: LD_INT 8
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 30
5086: PUSH
5087: LD_INT 3
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 23
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 57
5106: PUSH
5107: EMPTY
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: PPUSH
5116: CALL_OW 69
5120: PUSH
5121: LD_INT 1
5123: ARRAY
5124: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5125: LD_INT 22
5127: PUSH
5128: LD_INT 8
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 23
5137: PUSH
5138: LD_INT 3
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 30
5147: PUSH
5148: LD_INT 21
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: PPUSH
5160: CALL_OW 69
5164: NOT
5165: IFFALSE 5243
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5167: LD_EXP 62
5171: PPUSH
5172: LD_INT 21
5174: PPUSH
5175: LD_INT 97
5177: PPUSH
5178: LD_INT 36
5180: PPUSH
5181: LD_INT 5
5183: PPUSH
5184: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5195: LD_INT 22
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: PUSH
5205: LD_INT 23
5207: PUSH
5208: LD_INT 3
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 21
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 57
5227: PUSH
5228: EMPTY
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 69
5241: IFFALSE 5188
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5243: LD_INT 22
5245: PUSH
5246: LD_INT 8
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 23
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 30
5265: PUSH
5266: LD_INT 18
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PPUSH
5278: CALL_OW 69
5282: NOT
5283: IFFALSE 5361
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5285: LD_EXP 62
5289: PPUSH
5290: LD_INT 18
5292: PPUSH
5293: LD_INT 89
5295: PPUSH
5296: LD_INT 32
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5306: LD_INT 35
5308: PPUSH
5309: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5313: LD_INT 22
5315: PUSH
5316: LD_INT 8
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 23
5325: PUSH
5326: LD_INT 3
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PUSH
5333: LD_INT 30
5335: PUSH
5336: LD_INT 18
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 57
5345: PUSH
5346: EMPTY
5347: LIST
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: PPUSH
5355: CALL_OW 69
5359: IFFALSE 5306
// end ; lab := kozlov_lab ;
5361: LD_ADDR_VAR 0 3
5365: PUSH
5366: LD_INT 336
5368: ST_TO_ADDR
// if not lab then
5369: LD_VAR 0 3
5373: NOT
5374: IFFALSE 5378
// exit ;
5376: GO 5503
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5378: LD_EXP 62
5382: PPUSH
5383: LD_VAR 0 3
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5396: LD_EXP 62
5400: PPUSH
5401: LD_INT 4
5403: PPUSH
5404: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5408: LD_VAR 0 3
5412: PUSH
5413: LD_INT 1
5415: ARRAY
5416: PPUSH
5417: LD_INT 25
5419: PPUSH
5420: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5424: LD_INT 35
5426: PPUSH
5427: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5431: LD_INT 25
5433: PPUSH
5434: LD_INT 8
5436: PPUSH
5437: CALL_OW 321
5441: PUSH
5442: LD_INT 2
5444: EQUAL
5445: IFFALSE 5424
// ComExitBuilding ( Kozlov ) ;
5447: LD_EXP 62
5451: PPUSH
5452: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5456: LD_EXP 62
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5470: LD_EXP 62
5474: PPUSH
5475: LD_INT 3
5477: PPUSH
5478: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5482: LD_VAR 0 2
5486: PPUSH
5487: LD_INT 23
5489: PPUSH
5490: LD_INT 3
5492: PPUSH
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 48
5498: PPUSH
5499: CALL_OW 125
// end ;
5503: LD_VAR 0 1
5507: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: IFFALSE 5604
5525: GO 5527
5527: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 3
5533: PPUSH
5534: CALL 61078 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5538: LD_INT 3
5540: PPUSH
5541: LD_INT 14
5543: PUSH
5544: LD_INT 1
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: LD_INT 28
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 14
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_INT 14
5579: PUSH
5580: LD_INT 1
5582: PUSH
5583: LD_INT 1
5585: PUSH
5586: LD_INT 28
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: PPUSH
5600: CALL 60941 0 2
// end ;
5604: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5605: LD_EXP 22
5609: NOT
5610: PUSH
5611: LD_EXP 15
5615: PUSH
5616: LD_INT 6
5618: GREATEREQUAL
5619: AND
5620: PUSH
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 1
5626: PPUSH
5627: CALL 62359 0 2
5631: NOT
5632: AND
5633: IFFALSE 6507
5635: GO 5637
5637: DISABLE
5638: LD_INT 0
5640: PPUSH
5641: PPUSH
5642: PPUSH
// begin enable ;
5643: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5644: LD_INT 22
5646: PUSH
5647: LD_INT 8
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: LD_INT 23
5656: PUSH
5657: LD_INT 2
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 30
5666: PUSH
5667: LD_INT 3
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: NOT
5684: IFFALSE 5688
// exit ;
5686: GO 6507
// if Prob ( 40 ) then
5688: LD_INT 40
5690: PPUSH
5691: CALL_OW 13
5695: IFFALSE 5822
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5697: LD_INT 3
5699: PPUSH
5700: LD_INT 14
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: LD_INT 2
5708: PUSH
5709: LD_INT 28
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 14
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: LD_INT 2
5726: PUSH
5727: LD_INT 28
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 14
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 28
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: LIST
5753: PUSH
5754: LD_INT 14
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: LD_INT 2
5762: PUSH
5763: LD_INT 28
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 14
5774: PUSH
5775: LD_INT 1
5777: PUSH
5778: LD_INT 2
5780: PUSH
5781: LD_INT 28
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 14
5792: PUSH
5793: LD_INT 1
5795: PUSH
5796: LD_INT 2
5798: PUSH
5799: LD_INT 26
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL 60941 0 2
// end else
5820: GO 6029
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5822: LD_INT 3
5824: PPUSH
5825: LD_INT 14
5827: PUSH
5828: LD_INT 1
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: LD_INT 27
5836: PUSH
5837: LD_INT 26
5839: PUSH
5840: LD_INT 26
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 14
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: LD_INT 26
5878: PUSH
5879: LD_INT 26
5881: PUSH
5882: LD_INT 26
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: PUSH
5891: LD_OWVAR 67
5895: ARRAY
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: LD_INT 29
5920: PUSH
5921: LD_INT 29
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 13
5944: PUSH
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 26
5953: PUSH
5954: LD_INT 29
5956: PUSH
5957: LD_INT 29
5959: PUSH
5960: LD_INT 29
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PUSH
5969: LD_OWVAR 67
5973: ARRAY
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 13
5983: PUSH
5984: LD_INT 1
5986: PUSH
5987: LD_INT 2
5989: PUSH
5990: LD_INT 29
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 14
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL 60941 0 2
// end ; repeat wait ( 0 0$1 ) ;
6029: LD_INT 35
6031: PPUSH
6032: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 62359 0 2
6046: PUSH
6047: LD_INT 6
6049: GREATEREQUAL
6050: IFFALSE 6029
// wait ( 0 0$30 ) ;
6052: LD_INT 1050
6054: PPUSH
6055: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 3
6066: PPUSH
6067: LD_INT 1
6069: PPUSH
6070: CALL 62359 0 2
6074: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6075: LD_ADDR_EXP 118
6079: PUSH
6080: LD_EXP 118
6084: PPUSH
6085: LD_INT 3
6087: PPUSH
6088: LD_EXP 118
6092: PUSH
6093: LD_INT 3
6095: ARRAY
6096: PUSH
6097: LD_VAR 0 2
6101: DIFF
6102: PPUSH
6103: CALL_OW 1
6107: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6108: LD_ADDR_VAR 0 3
6112: PUSH
6113: LD_INT 0
6115: PPUSH
6116: LD_INT 2
6118: PPUSH
6119: CALL_OW 12
6123: ST_TO_ADDR
// if target then
6124: LD_VAR 0 3
6128: IFFALSE 6265
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6130: LD_ADDR_VAR 0 2
6134: PUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: LD_INT 24
6142: PUSH
6143: LD_INT 250
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL_OW 72
6154: ST_TO_ADDR
// if not tmp then
6155: LD_VAR 0 2
6159: NOT
6160: IFFALSE 6164
// break ;
6162: GO 6263
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 89
6184: PPUSH
6185: LD_INT 71
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 89 , 71 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 89
6205: PPUSH
6206: LD_INT 71
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 89
6234: PUSH
6235: LD_INT 71
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6130
// end else
6263: GO 6398
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6265: LD_ADDR_VAR 0 2
6269: PUSH
6270: LD_VAR 0 2
6274: PPUSH
6275: LD_INT 24
6277: PUSH
6278: LD_INT 250
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// if not tmp then
6290: LD_VAR 0 2
6294: NOT
6295: IFFALSE 6299
// break ;
6297: GO 6398
// for i in tmp do
6299: LD_ADDR_VAR 0 1
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: FOR_IN
6310: IFFALSE 6350
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6312: LD_VAR 0 1
6316: PPUSH
6317: LD_INT 125
6319: PPUSH
6320: LD_INT 129
6322: PPUSH
6323: CALL_OW 297
6327: PUSH
6328: LD_INT 9
6330: GREATER
6331: IFFALSE 6348
// ComMoveXY ( i , 125 , 129 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 125
6340: PPUSH
6341: LD_INT 129
6343: PPUSH
6344: CALL_OW 111
6348: GO 6309
6350: POP
6351: POP
// wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6359: LD_VAR 0 2
6363: PPUSH
6364: LD_INT 92
6366: PUSH
6367: LD_INT 125
6369: PUSH
6370: LD_INT 129
6372: PUSH
6373: LD_INT 9
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: PPUSH
6382: CALL_OW 72
6386: PUSH
6387: LD_VAR 0 2
6391: PUSH
6392: LD_INT 1
6394: MINUS
6395: GREATEREQUAL
6396: IFFALSE 6265
// end ; repeat wait ( 0 0$1 ) ;
6398: LD_INT 35
6400: PPUSH
6401: CALL_OW 67
// for i in tmp do
6405: LD_ADDR_VAR 0 1
6409: PUSH
6410: LD_VAR 0 2
6414: PUSH
6415: FOR_IN
6416: IFFALSE 6498
// begin if GetLives ( i ) > 251 then
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 256
6427: PUSH
6428: LD_INT 251
6430: GREATER
6431: IFFALSE 6469
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6433: LD_VAR 0 1
6437: PPUSH
6438: LD_INT 81
6440: PUSH
6441: LD_INT 8
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 69
6452: PPUSH
6453: LD_VAR 0 1
6457: PPUSH
6458: CALL_OW 74
6462: PPUSH
6463: CALL_OW 115
6467: GO 6496
// if IsDead ( i ) then
6469: LD_VAR 0 1
6473: PPUSH
6474: CALL_OW 301
6478: IFFALSE 6496
// tmp := tmp diff i ;
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: LD_VAR 0 2
6489: PUSH
6490: LD_VAR 0 1
6494: DIFF
6495: ST_TO_ADDR
// end ;
6496: GO 6415
6498: POP
6499: POP
// until not tmp ;
6500: LD_VAR 0 2
6504: NOT
6505: IFFALSE 6398
// end ;
6507: PPOPN 3
6509: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6510: LD_EXP 22
6514: NOT
6515: PUSH
6516: LD_EXP 15
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: AND
6525: PUSH
6526: LD_OWVAR 67
6530: PUSH
6531: LD_INT 1
6533: GREATER
6534: AND
6535: IFFALSE 7068
6537: GO 6539
6539: DISABLE
6540: LD_INT 0
6542: PPUSH
6543: PPUSH
6544: PPUSH
// begin enable ;
6545: ENABLE
// tmp := [ ] ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: EMPTY
6552: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: DOUBLE
6559: LD_INT 1
6561: DEC
6562: ST_TO_ADDR
6563: LD_INT 4
6565: PUSH
6566: LD_INT 6
6568: PUSH
6569: LD_INT 7
6571: PUSH
6572: LD_INT 8
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PUSH
6587: FOR_TO
6588: IFFALSE 6748
// begin uc_side := 8 ;
6590: LD_ADDR_OWVAR 20
6594: PUSH
6595: LD_INT 8
6597: ST_TO_ADDR
// uc_nation := 2 ;
6598: LD_ADDR_OWVAR 21
6602: PUSH
6603: LD_INT 2
6605: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6606: LD_INT 13
6608: PUSH
6609: LD_INT 14
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 1
6618: PPUSH
6619: LD_INT 2
6621: PPUSH
6622: CALL_OW 12
6626: ARRAY
6627: PPUSH
6628: LD_INT 1
6630: PPUSH
6631: LD_INT 5
6633: PPUSH
6634: LD_INT 27
6636: PUSH
6637: LD_INT 28
6639: PUSH
6640: LD_INT 26
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 4
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: LD_INT 88
6666: PPUSH
6667: CALL 72344 0 5
// un := CreateVehicle ;
6671: LD_ADDR_VAR 0 2
6675: PUSH
6676: CALL_OW 45
6680: ST_TO_ADDR
// tmp := tmp ^ un ;
6681: LD_ADDR_VAR 0 3
6685: PUSH
6686: LD_VAR 0 3
6690: PUSH
6691: LD_VAR 0 2
6695: ADD
6696: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 3
6704: PPUSH
6705: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6709: LD_VAR 0 2
6713: PPUSH
6714: LD_INT 30
6716: PPUSH
6717: LD_INT 0
6719: PPUSH
6720: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6724: LD_VAR 0 2
6728: PPUSH
6729: LD_INT 16
6731: PPUSH
6732: LD_INT 11
6734: PPUSH
6735: CALL_OW 111
// wait ( 0 0$2 ) ;
6739: LD_INT 70
6741: PPUSH
6742: CALL_OW 67
// end ;
6746: GO 6587
6748: POP
6749: POP
// for i = 1 to Difficulty do
6750: LD_ADDR_VAR 0 1
6754: PUSH
6755: DOUBLE
6756: LD_INT 1
6758: DEC
6759: ST_TO_ADDR
6760: LD_OWVAR 67
6764: PUSH
6765: FOR_TO
6766: IFFALSE 6895
// begin uc_side := 8 ;
6768: LD_ADDR_OWVAR 20
6772: PUSH
6773: LD_INT 8
6775: ST_TO_ADDR
// uc_nation := 2 ;
6776: LD_ADDR_OWVAR 21
6780: PUSH
6781: LD_INT 2
6783: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6784: LD_INT 0
6786: PPUSH
6787: LD_INT 8
6789: PPUSH
6790: LD_INT 8
6792: PUSH
6793: LD_INT 8
6795: PUSH
6796: LD_INT 9
6798: PUSH
6799: LD_INT 10
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_OWVAR 67
6812: ARRAY
6813: PPUSH
6814: CALL_OW 380
// un := CreateHuman ;
6818: LD_ADDR_VAR 0 2
6822: PUSH
6823: CALL_OW 44
6827: ST_TO_ADDR
// tmp := tmp ^ un ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_VAR 0 3
6837: PUSH
6838: LD_VAR 0 2
6842: ADD
6843: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 3
6851: PPUSH
6852: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6856: LD_VAR 0 2
6860: PPUSH
6861: LD_INT 30
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 16
6878: PPUSH
6879: LD_INT 11
6881: PPUSH
6882: CALL_OW 111
// wait ( 0 0$2 ) ;
6886: LD_INT 70
6888: PPUSH
6889: CALL_OW 67
// end ;
6893: GO 6765
6895: POP
6896: POP
// repeat wait ( 0 0$1 ) ;
6897: LD_INT 35
6899: PPUSH
6900: CALL_OW 67
// if legionDestroyed then
6904: LD_EXP 22
6908: IFFALSE 6912
// exit ;
6910: GO 7068
// for i in tmp do
6912: LD_ADDR_VAR 0 1
6916: PUSH
6917: LD_VAR 0 3
6921: PUSH
6922: FOR_IN
6923: IFFALSE 7059
// begin if GetLives ( i ) > 250 then
6925: LD_VAR 0 1
6929: PPUSH
6930: CALL_OW 256
6934: PUSH
6935: LD_INT 250
6937: GREATER
6938: IFFALSE 7030
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6940: LD_INT 81
6942: PUSH
6943: LD_INT 8
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 91
6952: PUSH
6953: LD_VAR 0 1
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PPUSH
6970: CALL_OW 69
6974: NOT
6975: IFFALSE 6994
// ComAgressiveMove ( i , 67 , 110 ) else
6977: LD_VAR 0 1
6981: PPUSH
6982: LD_INT 67
6984: PPUSH
6985: LD_INT 110
6987: PPUSH
6988: CALL_OW 114
6992: GO 7028
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_INT 81
7001: PUSH
7002: LD_INT 8
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PPUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: CALL_OW 74
7023: PPUSH
7024: CALL_OW 115
// end else
7028: GO 7057
// if IsDead ( i ) then
7030: LD_VAR 0 1
7034: PPUSH
7035: CALL_OW 301
7039: IFFALSE 7057
// tmp := tmp diff i ;
7041: LD_ADDR_VAR 0 3
7045: PUSH
7046: LD_VAR 0 3
7050: PUSH
7051: LD_VAR 0 1
7055: DIFF
7056: ST_TO_ADDR
// end ;
7057: GO 6922
7059: POP
7060: POP
// until not tmp ;
7061: LD_VAR 0 3
7065: NOT
7066: IFFALSE 6897
// end ; end_of_file
7068: PPOPN 3
7070: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
7080: PPUSH
7081: PPUSH
// side := 3 ;
7082: LD_ADDR_VAR 0 6
7086: PUSH
7087: LD_INT 3
7089: ST_TO_ADDR
// uc_side := side ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_VAR 0 6
7099: ST_TO_ADDR
// uc_nation := 3 ;
7100: LD_ADDR_OWVAR 21
7104: PUSH
7105: LD_INT 3
7107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_VAR 0 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 21
7127: PUSH
7128: LD_INT 3
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: FOR_IN
7145: IFFALSE 7161
// SetBLevel ( i , 10 ) ;
7147: LD_VAR 0 2
7151: PPUSH
7152: LD_INT 10
7154: PPUSH
7155: CALL_OW 241
7159: GO 7144
7161: POP
7162: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7163: LD_ADDR_VAR 0 9
7167: PUSH
7168: LD_INT 22
7170: PUSH
7171: LD_VAR 0 6
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 30
7182: PUSH
7183: LD_INT 34
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: ST_TO_ADDR
// if teleport then
7199: LD_VAR 0 9
7203: IFFALSE 7224
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7205: LD_VAR 0 9
7209: PUSH
7210: LD_INT 1
7212: ARRAY
7213: PPUSH
7214: LD_INT 123
7216: PPUSH
7217: LD_INT 122
7219: PPUSH
7220: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7224: LD_ADDR_EXP 65
7228: PUSH
7229: LD_STRING Platonov
7231: PPUSH
7232: CALL_OW 25
7236: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7237: LD_ADDR_EXP 66
7241: PUSH
7242: LD_STRING Kovalyuk
7244: PPUSH
7245: CALL_OW 25
7249: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7250: LD_ADDR_EXP 68
7254: PUSH
7255: LD_STRING Yakotich
7257: PPUSH
7258: LD_EXP 1
7262: NOT
7263: PPUSH
7264: LD_STRING 09_
7266: PPUSH
7267: CALL 67329 0 3
7271: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7272: LD_ADDR_EXP 67
7276: PUSH
7277: LD_STRING Bystrov
7279: PPUSH
7280: CALL_OW 25
7284: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7285: LD_ADDR_EXP 69
7289: PUSH
7290: LD_STRING Gleb
7292: PPUSH
7293: CALL_OW 25
7297: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7298: LD_STRING 03_Cornel
7300: PPUSH
7301: CALL_OW 28
7305: IFFALSE 7353
// begin Bierezov := NewCharacter ( Mikhail ) ;
7307: LD_ADDR_EXP 70
7311: PUSH
7312: LD_STRING Mikhail
7314: PPUSH
7315: CALL_OW 25
7319: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7320: LD_EXP 70
7324: PPUSH
7325: LD_INT 197
7327: PPUSH
7328: LD_INT 111
7330: PPUSH
7331: LD_INT 9
7333: PPUSH
7334: LD_INT 0
7336: PPUSH
7337: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7341: LD_EXP 70
7345: PPUSH
7346: LD_INT 3
7348: PPUSH
7349: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7353: LD_EXP 65
7357: PPUSH
7358: LD_INT 126
7360: PPUSH
7361: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7365: LD_EXP 66
7369: PPUSH
7370: LD_INT 134
7372: PPUSH
7373: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7377: LD_EXP 68
7381: PPUSH
7382: LD_INT 197
7384: PPUSH
7385: LD_INT 111
7387: PPUSH
7388: LD_INT 9
7390: PPUSH
7391: LD_INT 0
7393: PPUSH
7394: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7398: LD_EXP 67
7402: PPUSH
7403: LD_INT 197
7405: PPUSH
7406: LD_INT 111
7408: PPUSH
7409: LD_INT 9
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7419: LD_EXP 69
7423: PPUSH
7424: LD_INT 197
7426: PPUSH
7427: LD_INT 111
7429: PPUSH
7430: LD_INT 9
7432: PPUSH
7433: LD_INT 0
7435: PPUSH
7436: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7440: LD_ADDR_VAR 0 5
7444: PUSH
7445: LD_INT 126
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: LD_STRING zhukov
7453: PPUSH
7454: LD_INT 9
7456: PUSH
7457: LD_INT 10
7459: PUSH
7460: LD_INT 10
7462: PUSH
7463: LD_INT 10
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_OWVAR 67
7476: ARRAY
7477: PPUSH
7478: LD_INT 90000
7480: PUSH
7481: LD_INT 1000
7483: PUSH
7484: LD_INT 300
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: PPUSH
7492: LD_INT 18
7494: PUSH
7495: LD_INT 8
7497: PUSH
7498: LD_INT 13
7500: PUSH
7501: LD_INT 8
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PPUSH
7510: CALL 75788 0 6
7514: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7515: LD_ADDR_VAR 0 4
7519: PUSH
7520: LD_INT 267
7522: PPUSH
7523: CALL_OW 274
7527: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7528: LD_VAR 0 4
7532: PPUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 5000
7538: PPUSH
7539: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7543: LD_VAR 0 4
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: LD_INT 200
7553: PPUSH
7554: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_INT 200
7568: PPUSH
7569: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7573: LD_ADDR_EXP 99
7577: PUSH
7578: LD_EXP 99
7582: PPUSH
7583: LD_INT 2
7585: PPUSH
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_VAR 0 6
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: LD_INT 21
7608: PUSH
7609: LD_INT 2
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: UNION
7629: PUSH
7630: LD_EXP 65
7634: DIFF
7635: PPUSH
7636: CALL_OW 1
7640: ST_TO_ADDR
// behemoths := [ ] ;
7641: LD_ADDR_EXP 73
7645: PUSH
7646: EMPTY
7647: ST_TO_ADDR
// behemothBuilders := [ ] ;
7648: LD_ADDR_EXP 74
7652: PUSH
7653: EMPTY
7654: ST_TO_ADDR
// if Kovalyuk then
7655: LD_EXP 66
7659: IFFALSE 7681
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7661: LD_ADDR_EXP 74
7665: PUSH
7666: LD_EXP 74
7670: PPUSH
7671: LD_EXP 66
7675: PPUSH
7676: CALL 104778 0 2
7680: ST_TO_ADDR
// j := 3 ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 3
7688: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7689: LD_ADDR_VAR 0 2
7693: PUSH
7694: LD_INT 22
7696: PUSH
7697: LD_INT 3
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: PUSH
7723: LD_EXP 66
7727: DIFF
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7780
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7732: LD_ADDR_EXP 74
7736: PUSH
7737: LD_EXP 74
7741: PPUSH
7742: LD_VAR 0 2
7746: PPUSH
7747: CALL 104778 0 2
7751: ST_TO_ADDR
// j := j - 1 ;
7752: LD_ADDR_VAR 0 3
7756: PUSH
7757: LD_VAR 0 3
7761: PUSH
7762: LD_INT 1
7764: MINUS
7765: ST_TO_ADDR
// if j = 0 then
7766: LD_VAR 0 3
7770: PUSH
7771: LD_INT 0
7773: EQUAL
7774: IFFALSE 7778
// break ;
7776: GO 7780
// end ;
7778: GO 7729
7780: POP
7781: POP
// end ;
7782: LD_VAR 0 1
7786: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7787: LD_INT 0
7789: PPUSH
7790: PPUSH
7791: PPUSH
7792: PPUSH
7793: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7794: LD_ADDR_VAR 0 4
7798: PUSH
7799: LD_INT 209
7801: PUSH
7802: LD_INT 149
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 219
7811: PUSH
7812: LD_INT 154
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 223
7821: PUSH
7822: LD_INT 149
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 232
7831: PUSH
7832: LD_INT 155
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: ST_TO_ADDR
// if not behemothBuilders then
7845: LD_EXP 74
7849: NOT
7850: IFFALSE 7854
// exit ;
7852: GO 7985
// j := 1 ;
7854: LD_ADDR_VAR 0 3
7858: PUSH
7859: LD_INT 1
7861: ST_TO_ADDR
// for i in behemothBuilders do
7862: LD_ADDR_VAR 0 2
7866: PUSH
7867: LD_EXP 74
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7983
// begin if GetClass ( i ) <> class_mechanic then
7875: LD_VAR 0 2
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: NONEQUAL
7888: IFFALSE 7902
// SetClass ( i , class_mechanic ) ;
7890: LD_VAR 0 2
7894: PPUSH
7895: LD_INT 3
7897: PPUSH
7898: CALL_OW 336
// if IsInUnit ( i ) then
7902: LD_VAR 0 2
7906: PPUSH
7907: CALL_OW 310
7911: IFFALSE 7922
// ComExitBuilding ( i ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 37
7929: PPUSH
7930: LD_VAR 0 4
7934: PUSH
7935: LD_VAR 0 3
7939: ARRAY
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_VAR 0 4
7949: PUSH
7950: LD_VAR 0 3
7954: ARRAY
7955: PUSH
7956: LD_INT 2
7958: ARRAY
7959: PPUSH
7960: LD_INT 0
7962: PPUSH
7963: CALL_OW 230
// j := j + 1 ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: LD_VAR 0 3
7976: PUSH
7977: LD_INT 1
7979: PLUS
7980: ST_TO_ADDR
// end ;
7981: GO 7872
7983: POP
7984: POP
// end ;
7985: LD_VAR 0 1
7989: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7990: LD_INT 24
7992: PPUSH
7993: LD_INT 30
7995: PUSH
7996: LD_INT 37
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PPUSH
8003: CALL_OW 70
8007: IFFALSE 8020
8009: GO 8011
8011: DISABLE
// behemothUnderConstruct := true ;
8012: LD_ADDR_EXP 26
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
8020: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8021: LD_INT 3
8023: PPUSH
8024: CALL 104839 0 1
8028: PUSH
8029: LD_INT 22
8031: PUSH
8032: LD_INT 3
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 30
8041: PUSH
8042: LD_INT 37
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PPUSH
8053: CALL_OW 69
8057: NOT
8058: AND
8059: IFFALSE 8245
8061: GO 8063
8063: DISABLE
8064: LD_INT 0
8066: PPUSH
8067: PPUSH
// begin enable ;
8068: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8069: LD_ADDR_VAR 0 2
8073: PUSH
8074: LD_INT 3
8076: PPUSH
8077: CALL 104839 0 1
8081: ST_TO_ADDR
// for i in tmp do
8082: LD_ADDR_VAR 0 1
8086: PUSH
8087: LD_VAR 0 2
8091: PUSH
8092: FOR_IN
8093: IFFALSE 8243
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8095: LD_VAR 0 1
8099: PPUSH
8100: LD_INT 9
8102: PPUSH
8103: CALL_OW 308
8107: PUSH
8108: LD_VAR 0 1
8112: PPUSH
8113: CALL_OW 110
8117: PUSH
8118: LD_INT 2
8120: EQUAL
8121: NOT
8122: AND
8123: IFFALSE 8137
// SetTag ( i , 2 ) ;
8125: LD_VAR 0 1
8129: PPUSH
8130: LD_INT 2
8132: PPUSH
8133: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8137: LD_INT 81
8139: PUSH
8140: LD_INT 3
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PUSH
8147: LD_INT 91
8149: PUSH
8150: LD_VAR 0 1
8154: PUSH
8155: LD_INT 12
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: LIST
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: NOT
8172: PUSH
8173: LD_VAR 0 1
8177: PPUSH
8178: CALL_OW 110
8182: PUSH
8183: LD_INT 2
8185: EQUAL
8186: NOT
8187: AND
8188: IFFALSE 8207
// ComAgressiveMove ( i , 64 , 93 ) else
8190: LD_VAR 0 1
8194: PPUSH
8195: LD_INT 64
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: CALL_OW 114
8205: GO 8241
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8207: LD_VAR 0 1
8211: PPUSH
8212: LD_INT 81
8214: PUSH
8215: LD_INT 3
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: PPUSH
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 74
8236: PPUSH
8237: CALL_OW 115
// end ;
8241: GO 8092
8243: POP
8244: POP
// end ;
8245: PPOPN 2
8247: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
// result := [ ] ;
8253: LD_ADDR_VAR 0 2
8257: PUSH
8258: EMPTY
8259: ST_TO_ADDR
// uc_side := 6 ;
8260: LD_ADDR_OWVAR 20
8264: PUSH
8265: LD_INT 6
8267: ST_TO_ADDR
// uc_nation := 3 ;
8268: LD_ADDR_OWVAR 21
8272: PUSH
8273: LD_INT 3
8275: ST_TO_ADDR
// case strength of 1 :
8276: LD_VAR 0 1
8280: PUSH
8281: LD_INT 1
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8431
8289: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 4
8302: PUSH
8303: LD_INT 5
8305: PUSH
8306: LD_INT 6
8308: PUSH
8309: LD_INT 7
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_OWVAR 67
8322: ARRAY
8323: PUSH
8324: FOR_TO
8325: IFFALSE 8427
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8327: LD_INT 22
8329: PUSH
8330: LD_INT 24
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 2
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 1
8392: PPUSH
8393: LD_INT 3
8395: PPUSH
8396: CALL_OW 12
8400: ARRAY
8401: PPUSH
8402: LD_INT 80
8404: PPUSH
8405: CALL 72344 0 5
// result := result union CreateVehicle ;
8409: LD_ADDR_VAR 0 2
8413: PUSH
8414: LD_VAR 0 2
8418: PUSH
8419: CALL_OW 45
8423: UNION
8424: ST_TO_ADDR
// end ;
8425: GO 8324
8427: POP
8428: POP
// end ; 2 :
8429: GO 9426
8431: LD_INT 2
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8607
8439: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8440: LD_ADDR_VAR 0 3
8444: PUSH
8445: DOUBLE
8446: LD_INT 1
8448: DEC
8449: ST_TO_ADDR
8450: LD_INT 5
8452: PUSH
8453: LD_INT 6
8455: PUSH
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_OWVAR 67
8472: ARRAY
8473: PUSH
8474: FOR_TO
8475: IFFALSE 8603
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8477: LD_INT 22
8479: PUSH
8480: LD_INT 24
8482: PUSH
8483: LD_INT 24
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: LIST
8490: PUSH
8491: LD_VAR 0 3
8495: PUSH
8496: LD_INT 3
8498: MOD
8499: PUSH
8500: LD_INT 1
8502: PLUS
8503: ARRAY
8504: PPUSH
8505: LD_INT 1
8507: PUSH
8508: LD_INT 3
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: PUSH
8515: LD_INT 1
8517: PPUSH
8518: LD_INT 2
8520: PPUSH
8521: CALL_OW 12
8525: ARRAY
8526: PPUSH
8527: LD_INT 3
8529: PPUSH
8530: LD_INT 43
8532: PUSH
8533: LD_INT 44
8535: PUSH
8536: LD_INT 45
8538: PUSH
8539: LD_INT 44
8541: PUSH
8542: LD_INT 46
8544: PUSH
8545: LD_INT 46
8547: PUSH
8548: LD_INT 49
8550: PUSH
8551: LD_INT 49
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_VAR 0 3
8568: PUSH
8569: LD_INT 8
8571: MOD
8572: PUSH
8573: LD_INT 1
8575: PLUS
8576: ARRAY
8577: PPUSH
8578: LD_INT 80
8580: PPUSH
8581: CALL 72344 0 5
// result := result union CreateVehicle ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: CALL_OW 45
8599: UNION
8600: ST_TO_ADDR
// end ;
8601: GO 8474
8603: POP
8604: POP
// end ; 3 :
8605: GO 9426
8607: LD_INT 3
8609: DOUBLE
8610: EQUAL
8611: IFTRUE 8615
8613: GO 8787
8615: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8616: LD_ADDR_VAR 0 3
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_INT 6
8628: PUSH
8629: LD_INT 7
8631: PUSH
8632: LD_INT 8
8634: PUSH
8635: LD_INT 9
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: FOR_TO
8651: IFFALSE 8783
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8653: LD_INT 22
8655: PUSH
8656: LD_INT 24
8658: PUSH
8659: LD_INT 24
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: LIST
8666: PUSH
8667: LD_VAR 0 3
8671: PUSH
8672: LD_INT 3
8674: MOD
8675: PUSH
8676: LD_INT 1
8678: PLUS
8679: ARRAY
8680: PPUSH
8681: LD_INT 1
8683: PUSH
8684: LD_INT 3
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 1
8693: PPUSH
8694: LD_INT 2
8696: PPUSH
8697: CALL_OW 12
8701: ARRAY
8702: PPUSH
8703: LD_INT 3
8705: PPUSH
8706: LD_INT 43
8708: PUSH
8709: LD_INT 47
8711: PUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 45
8717: PUSH
8718: LD_INT 46
8720: PUSH
8721: LD_INT 46
8723: PUSH
8724: LD_INT 49
8726: PUSH
8727: LD_INT 49
8729: PUSH
8730: LD_INT 49
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 9
8751: MOD
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: ARRAY
8757: PPUSH
8758: LD_INT 80
8760: PPUSH
8761: CALL 72344 0 5
// result := result union CreateVehicle ;
8765: LD_ADDR_VAR 0 2
8769: PUSH
8770: LD_VAR 0 2
8774: PUSH
8775: CALL_OW 45
8779: UNION
8780: ST_TO_ADDR
// end ;
8781: GO 8650
8783: POP
8784: POP
// end ; 4 :
8785: GO 9426
8787: LD_INT 4
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 9425
8795: POP
// begin uc_nation := 3 ;
8796: LD_ADDR_OWVAR 21
8800: PUSH
8801: LD_INT 3
8803: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_INT 6
8816: PUSH
8817: LD_INT 8
8819: PUSH
8820: LD_INT 9
8822: PUSH
8823: LD_INT 10
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_OWVAR 67
8836: ARRAY
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8971
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8841: LD_INT 22
8843: PUSH
8844: LD_INT 24
8846: PUSH
8847: LD_INT 24
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 3
8862: MOD
8863: PUSH
8864: LD_INT 1
8866: PLUS
8867: ARRAY
8868: PPUSH
8869: LD_INT 1
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 1
8881: PPUSH
8882: LD_INT 2
8884: PPUSH
8885: CALL_OW 12
8889: ARRAY
8890: PPUSH
8891: LD_INT 3
8893: PPUSH
8894: LD_INT 45
8896: PUSH
8897: LD_INT 47
8899: PUSH
8900: LD_INT 47
8902: PUSH
8903: LD_INT 45
8905: PUSH
8906: LD_INT 46
8908: PUSH
8909: LD_INT 46
8911: PUSH
8912: LD_INT 49
8914: PUSH
8915: LD_INT 49
8917: PUSH
8918: LD_INT 49
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: LD_INT 9
8939: MOD
8940: PUSH
8941: LD_INT 1
8943: PLUS
8944: ARRAY
8945: PPUSH
8946: LD_INT 80
8948: PPUSH
8949: CALL 72344 0 5
// result := result union CreateVehicle ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: CALL_OW 45
8967: UNION
8968: ST_TO_ADDR
// end ;
8969: GO 8838
8971: POP
8972: POP
// if not KappaStatus then
8973: LD_EXP 2
8977: NOT
8978: IFFALSE 9213
// begin uc_nation := 1 ;
8980: LD_ADDR_OWVAR 21
8984: PUSH
8985: LD_INT 1
8987: ST_TO_ADDR
// for i = 1 to 3 do
8988: LD_ADDR_VAR 0 3
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_INT 3
9000: PUSH
9001: FOR_TO
9002: IFFALSE 9138
// begin j := rand ( 0 , 1 ) ;
9004: LD_ADDR_VAR 0 4
9008: PUSH
9009: LD_INT 0
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 12
9019: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9020: LD_INT 3
9022: PUSH
9023: LD_INT 5
9025: PUSH
9026: LD_INT 5
9028: PUSH
9029: LD_INT 4
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: LIST
9036: LIST
9037: PUSH
9038: LD_VAR 0 4
9042: PUSH
9043: LD_INT 1
9045: PPUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL_OW 12
9053: PLUS
9054: ARRAY
9055: PPUSH
9056: LD_INT 1
9058: PUSH
9059: LD_INT 3
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 1
9068: PPUSH
9069: LD_INT 2
9071: PPUSH
9072: CALL_OW 12
9076: ARRAY
9077: PPUSH
9078: LD_INT 3
9080: PPUSH
9081: LD_INT 9
9083: PUSH
9084: LD_INT 7
9086: PUSH
9087: LD_INT 6
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_VAR 0 4
9099: PUSH
9100: LD_INT 1
9102: PPUSH
9103: LD_INT 2
9105: PPUSH
9106: CALL_OW 12
9110: PLUS
9111: ARRAY
9112: PPUSH
9113: LD_INT 85
9115: PPUSH
9116: CALL 72344 0 5
// result := result union CreateVehicle ;
9120: LD_ADDR_VAR 0 2
9124: PUSH
9125: LD_VAR 0 2
9129: PUSH
9130: CALL_OW 45
9134: UNION
9135: ST_TO_ADDR
// end ;
9136: GO 9001
9138: POP
9139: POP
// if vsevolodFirstAttack then
9140: LD_EXP 24
9144: IFFALSE 9211
// begin vsevolodFirstAttack := false ;
9146: LD_ADDR_EXP 24
9150: PUSH
9151: LD_INT 0
9153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9154: LD_INT 5
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: LD_INT 1
9162: PPUSH
9163: LD_INT 6
9165: PPUSH
9166: LD_INT 100
9168: PPUSH
9169: CALL 72344 0 5
// sewiVeh := CreateVehicle ;
9173: LD_ADDR_EXP 72
9177: PUSH
9178: CALL_OW 45
9182: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9183: LD_EXP 72
9187: PPUSH
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 242
// result := result union sewiVeh ;
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: LD_VAR 0 2
9204: PUSH
9205: LD_EXP 72
9209: UNION
9210: ST_TO_ADDR
// end ; end else
9211: GO 9423
// if vsevolodFirstAttack then
9213: LD_EXP 24
9217: IFFALSE 9423
// begin vsevolodFirstAttack := false ;
9219: LD_ADDR_EXP 24
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// uc_nation := 3 ;
9227: LD_ADDR_OWVAR 21
9231: PUSH
9232: LD_INT 3
9234: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9235: LD_ADDR_VAR 0 3
9239: PUSH
9240: DOUBLE
9241: LD_INT 1
9243: DEC
9244: ST_TO_ADDR
9245: LD_INT 2
9247: PUSH
9248: LD_OWVAR 67
9252: PLUS
9253: PUSH
9254: FOR_TO
9255: IFFALSE 9363
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9257: LD_INT 22
9259: PUSH
9260: LD_INT 24
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: LIST
9270: PUSH
9271: LD_VAR 0 3
9275: PUSH
9276: LD_INT 3
9278: MOD
9279: PUSH
9280: LD_INT 1
9282: PLUS
9283: ARRAY
9284: PPUSH
9285: LD_INT 1
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 1
9297: PPUSH
9298: LD_INT 2
9300: PPUSH
9301: CALL_OW 12
9305: ARRAY
9306: PPUSH
9307: LD_INT 1
9309: PPUSH
9310: LD_INT 45
9312: PUSH
9313: LD_INT 47
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: LD_VAR 0 3
9328: PUSH
9329: LD_INT 3
9331: MOD
9332: PUSH
9333: LD_INT 1
9335: PLUS
9336: ARRAY
9337: PPUSH
9338: LD_INT 80
9340: PPUSH
9341: CALL 72344 0 5
// result := result union CreateVehicle ;
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: LD_VAR 0 2
9354: PUSH
9355: CALL_OW 45
9359: UNION
9360: ST_TO_ADDR
// end ;
9361: GO 9254
9363: POP
9364: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9365: LD_INT 24
9367: PPUSH
9368: LD_INT 3
9370: PPUSH
9371: LD_INT 1
9373: PPUSH
9374: LD_INT 47
9376: PPUSH
9377: LD_INT 100
9379: PPUSH
9380: CALL 72344 0 5
// sewiVeh := CreateVehicle ;
9384: LD_ADDR_EXP 72
9388: PUSH
9389: CALL_OW 45
9393: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9394: LD_EXP 72
9398: PPUSH
9399: LD_INT 6
9401: NEG
9402: PPUSH
9403: CALL_OW 242
// result := result union sewiVeh ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_VAR 0 2
9416: PUSH
9417: LD_EXP 72
9421: UNION
9422: ST_TO_ADDR
// end ; end ; end ;
9423: GO 9426
9425: POP
// end ;
9426: LD_VAR 0 2
9430: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9431: LD_EXP 16
9435: IFFALSE 10106
9437: GO 9439
9439: DISABLE
9440: LD_INT 0
9442: PPUSH
9443: PPUSH
9444: PPUSH
9445: PPUSH
9446: PPUSH
9447: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9448: LD_ADDR_VAR 0 4
9452: PUSH
9453: LD_INT 11
9455: PUSH
9456: LD_INT 12
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9463: LD_ADDR_VAR 0 3
9467: PUSH
9468: LD_INT 11550
9470: PUSH
9471: LD_INT 10150
9473: PUSH
9474: LD_INT 9800
9476: PUSH
9477: LD_INT 9450
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_OWVAR 67
9490: ARRAY
9491: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9492: LD_ADDR_VAR 0 6
9496: PUSH
9497: LD_INT 70
9499: PUSH
9500: LD_INT 118
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 78
9509: PUSH
9510: LD_INT 31
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// repeat if missionStage = 2 then
9521: LD_EXP 15
9525: PUSH
9526: LD_INT 2
9528: EQUAL
9529: IFFALSE 9540
// wait ( 1 1$30 ) else
9531: LD_INT 3150
9533: PPUSH
9534: CALL_OW 67
9538: GO 9549
// wait ( time ) ;
9540: LD_VAR 0 3
9544: PPUSH
9545: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9549: LD_EXP 15
9553: PUSH
9554: LD_INT 6
9556: EQUAL
9557: PUSH
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 2
9565: GREATER
9566: OR
9567: IFFALSE 9595
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9569: LD_INT 51
9571: PPUSH
9572: LD_INT 6
9574: PPUSH
9575: LD_INT 2
9577: PPUSH
9578: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9582: LD_INT 57
9584: PPUSH
9585: LD_INT 6
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 322
// end ; if missionStage = 8 then
9595: LD_EXP 15
9599: PUSH
9600: LD_INT 8
9602: EQUAL
9603: IFFALSE 9631
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9605: LD_INT 52
9607: PPUSH
9608: LD_INT 6
9610: PPUSH
9611: LD_INT 2
9613: PPUSH
9614: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9618: LD_INT 58
9620: PPUSH
9621: LD_INT 6
9623: PPUSH
9624: LD_INT 2
9626: PPUSH
9627: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9631: LD_EXP 15
9635: PUSH
9636: LD_INT 10
9638: EQUAL
9639: PUSH
9640: LD_OWVAR 67
9644: PUSH
9645: LD_INT 1
9647: GREATER
9648: AND
9649: IFFALSE 9677
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9651: LD_INT 53
9653: PPUSH
9654: LD_INT 6
9656: PPUSH
9657: LD_INT 2
9659: PPUSH
9660: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9664: LD_INT 59
9666: PPUSH
9667: LD_INT 6
9669: PPUSH
9670: LD_INT 2
9672: PPUSH
9673: CALL_OW 322
// end ; if activeAttacks then
9677: LD_EXP 16
9681: IFFALSE 10100
// begin if missionStage = 2 then
9683: LD_EXP 15
9687: PUSH
9688: LD_INT 2
9690: EQUAL
9691: IFFALSE 9701
// strength := 1 ;
9693: LD_ADDR_VAR 0 5
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// if missionStage > 2 then
9701: LD_EXP 15
9705: PUSH
9706: LD_INT 2
9708: GREATER
9709: IFFALSE 9719
// strength := 2 ;
9711: LD_ADDR_VAR 0 5
9715: PUSH
9716: LD_INT 2
9718: ST_TO_ADDR
// if missionStage > 6 then
9719: LD_EXP 15
9723: PUSH
9724: LD_INT 6
9726: GREATER
9727: IFFALSE 9737
// strength := 3 ;
9729: LD_ADDR_VAR 0 5
9733: PUSH
9734: LD_INT 3
9736: ST_TO_ADDR
// if missionStage > 10 then
9737: LD_EXP 15
9741: PUSH
9742: LD_INT 10
9744: GREATER
9745: IFFALSE 9755
// strength := 4 ;
9747: LD_ADDR_VAR 0 5
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: LD_VAR 0 5
9764: PPUSH
9765: CALL 8248 0 1
9769: ST_TO_ADDR
// for i in tmp do
9770: LD_ADDR_VAR 0 1
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: FOR_IN
9781: IFFALSE 9990
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_VAR 0 4
9792: PUSH
9793: LD_INT 1
9795: PPUSH
9796: LD_INT 2
9798: PPUSH
9799: CALL_OW 12
9803: ARRAY
9804: PPUSH
9805: LD_INT 0
9807: PPUSH
9808: CALL_OW 49
// if i = sewiVeh then
9812: LD_VAR 0 1
9816: PUSH
9817: LD_EXP 72
9821: EQUAL
9822: IFFALSE 9859
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9824: LD_ADDR_EXP 71
9828: PUSH
9829: LD_STRING Vsevolod
9831: PPUSH
9832: LD_INT 0
9834: PPUSH
9835: LD_STRING 
9837: PPUSH
9838: CALL 67329 0 3
9842: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9843: LD_EXP 71
9847: PPUSH
9848: LD_VAR 0 1
9852: PPUSH
9853: CALL_OW 52
// end else
9857: GO 9940
// if GetControl ( i ) = control_manual then
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 263
9868: PUSH
9869: LD_INT 1
9871: EQUAL
9872: IFFALSE 9940
// begin uc_side := 6 ;
9874: LD_ADDR_OWVAR 20
9878: PUSH
9879: LD_INT 6
9881: ST_TO_ADDR
// uc_nation := 3 ;
9882: LD_ADDR_OWVAR 21
9886: PUSH
9887: LD_INT 3
9889: ST_TO_ADDR
// hc_gallery :=  ;
9890: LD_ADDR_OWVAR 33
9894: PUSH
9895: LD_STRING 
9897: ST_TO_ADDR
// hc_name :=  ;
9898: LD_ADDR_OWVAR 26
9902: PUSH
9903: LD_STRING 
9905: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9906: LD_INT 0
9908: PPUSH
9909: LD_INT 3
9911: PPUSH
9912: LD_INT 10
9914: PPUSH
9915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9919: CALL_OW 44
9923: PPUSH
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9933: LD_INT 10
9935: PPUSH
9936: CALL_OW 67
// end ; if Prob ( 50 ) then
9940: LD_INT 50
9942: PPUSH
9943: CALL_OW 13
9947: IFFALSE 9966
// ComMoveXY ( i , 111 , 197 ) else
9949: LD_VAR 0 1
9953: PPUSH
9954: LD_INT 111
9956: PPUSH
9957: LD_INT 197
9959: PPUSH
9960: CALL_OW 111
9964: GO 9981
// ComMoveXY ( i , 91 , 165 ) ;
9966: LD_VAR 0 1
9970: PPUSH
9971: LD_INT 91
9973: PPUSH
9974: LD_INT 165
9976: PPUSH
9977: CALL_OW 111
// wait ( 0 0$2 ) ;
9981: LD_INT 70
9983: PPUSH
9984: CALL_OW 67
// end ;
9988: GO 9780
9990: POP
9991: POP
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
9999: LD_ADDR_VAR 0 1
10003: PUSH
10004: LD_VAR 0 2
10008: PPUSH
10009: LD_INT 50
10011: PUSH
10012: EMPTY
10013: LIST
10014: PPUSH
10015: CALL_OW 72
10019: PUSH
10020: FOR_IN
10021: IFFALSE 10080
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10023: LD_VAR 0 1
10027: PPUSH
10028: LD_INT 108
10030: PUSH
10031: LD_INT 153
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: LD_INT 105
10040: PUSH
10041: LD_INT 149
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 85
10050: PUSH
10051: LD_INT 131
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 64
10060: PUSH
10061: LD_INT 105
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PPUSH
10074: CALL 107382 0 2
10078: GO 10020
10080: POP
10081: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10082: LD_VAR 0 2
10086: PPUSH
10087: LD_INT 50
10089: PUSH
10090: EMPTY
10091: LIST
10092: PPUSH
10093: CALL_OW 72
10097: NOT
10098: IFFALSE 9992
// end ; until russianDestroyed ;
10100: LD_EXP 21
10104: IFFALSE 9521
// end ;
10106: PPOPN 6
10108: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10109: LD_EXP 21
10113: NOT
10114: PUSH
10115: LD_EXP 15
10119: PUSH
10120: LD_INT 6
10122: GREATEREQUAL
10123: AND
10124: PUSH
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 1
10130: PPUSH
10131: CALL 62359 0 2
10135: NOT
10136: AND
10137: IFFALSE 11076
10139: GO 10141
10141: DISABLE
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
10147: PPUSH
// begin enable ;
10148: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10149: LD_INT 22
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: LD_INT 30
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: NOT
10178: IFFALSE 10182
// exit ;
10180: GO 11076
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10182: LD_ADDR_VAR 0 4
10186: PUSH
10187: LD_INT 22
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 30
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: ST_TO_ADDR
// if Prob ( 40 ) then
10216: LD_INT 40
10218: PPUSH
10219: CALL_OW 13
10223: IFFALSE 10369
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10225: LD_INT 2
10227: PPUSH
10228: LD_INT 22
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 49
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 49
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 3
10272: PUSH
10273: LD_INT 49
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 24
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 3
10290: PUSH
10291: LD_INT 46
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 24
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: LD_INT 46
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 24
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 46
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL 60941 0 2
// end else
10367: GO 10511
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10369: LD_INT 2
10371: PPUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 47
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 46
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: LD_INT 24
10482: PUSH
10483: LD_INT 3
10485: PUSH
10486: LD_INT 3
10488: PUSH
10489: LD_INT 46
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL 60941 0 2
// end ; repeat wait ( 0 0$1 ) ;
10511: LD_INT 35
10513: PPUSH
10514: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10518: LD_INT 2
10520: PPUSH
10521: LD_INT 1
10523: PPUSH
10524: CALL 62359 0 2
10528: PUSH
10529: LD_INT 7
10531: GREATEREQUAL
10532: IFFALSE 10511
// wait ( 0 0$10 ) ;
10534: LD_INT 350
10536: PPUSH
10537: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_INT 2
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 62359 0 2
10556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10557: LD_ADDR_EXP 118
10561: PUSH
10562: LD_EXP 118
10566: PPUSH
10567: LD_INT 2
10569: PPUSH
10570: LD_EXP 118
10574: PUSH
10575: LD_INT 2
10577: ARRAY
10578: PUSH
10579: LD_VAR 0 2
10583: DIFF
10584: PPUSH
10585: CALL_OW 1
10589: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10590: LD_ADDR_VAR 0 3
10594: PUSH
10595: LD_INT 0
10597: PPUSH
10598: LD_INT 1
10600: PPUSH
10601: CALL_OW 12
10605: ST_TO_ADDR
// if target then
10606: LD_VAR 0 3
10610: IFFALSE 10738
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10612: LD_ADDR_VAR 0 2
10616: PUSH
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_INT 24
10624: PUSH
10625: LD_INT 250
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 72
10636: ST_TO_ADDR
// for i in tmp do
10637: LD_ADDR_VAR 0 1
10641: PUSH
10642: LD_VAR 0 2
10646: PUSH
10647: FOR_IN
10648: IFFALSE 10688
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 139
10657: PPUSH
10658: LD_INT 89
10660: PPUSH
10661: CALL_OW 297
10665: PUSH
10666: LD_INT 9
10668: GREATER
10669: IFFALSE 10686
// ComMoveXY ( i , 139 , 89 ) ;
10671: LD_VAR 0 1
10675: PPUSH
10676: LD_INT 139
10678: PPUSH
10679: LD_INT 89
10681: PPUSH
10682: CALL_OW 111
10686: GO 10647
10688: POP
10689: POP
// wait ( 0 0$1 ) ;
10690: LD_INT 35
10692: PPUSH
10693: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10697: LD_VAR 0 2
10701: PPUSH
10702: LD_INT 92
10704: PUSH
10705: LD_INT 139
10707: PUSH
10708: LD_INT 89
10710: PUSH
10711: LD_INT 9
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 72
10724: PUSH
10725: LD_VAR 0 2
10729: PUSH
10730: LD_INT 1
10732: MINUS
10733: GREATEREQUAL
10734: IFFALSE 10612
// end else
10736: GO 10880
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10738: LD_VAR 0 2
10742: PPUSH
10743: LD_VAR 0 4
10747: PUSH
10748: LD_INT 1
10750: ARRAY
10751: PPUSH
10752: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10756: LD_ADDR_VAR 0 2
10760: PUSH
10761: LD_VAR 0 2
10765: PPUSH
10766: LD_INT 24
10768: PUSH
10769: LD_INT 250
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PPUSH
10776: CALL_OW 72
10780: ST_TO_ADDR
// for i in tmp do
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 2
10790: PUSH
10791: FOR_IN
10792: IFFALSE 10832
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10794: LD_VAR 0 1
10798: PPUSH
10799: LD_INT 124
10801: PPUSH
10802: LD_INT 139
10804: PPUSH
10805: CALL_OW 297
10809: PUSH
10810: LD_INT 9
10812: GREATER
10813: IFFALSE 10830
// ComMoveXY ( i , 124 , 139 ) ;
10815: LD_VAR 0 1
10819: PPUSH
10820: LD_INT 124
10822: PPUSH
10823: LD_INT 139
10825: PPUSH
10826: CALL_OW 111
10830: GO 10791
10832: POP
10833: POP
// wait ( 0 0$1 ) ;
10834: LD_INT 35
10836: PPUSH
10837: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10841: LD_VAR 0 2
10845: PPUSH
10846: LD_INT 92
10848: PUSH
10849: LD_INT 124
10851: PUSH
10852: LD_INT 139
10854: PUSH
10855: LD_INT 9
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PPUSH
10864: CALL_OW 72
10868: PUSH
10869: LD_VAR 0 2
10873: PUSH
10874: LD_INT 1
10876: MINUS
10877: GREATEREQUAL
10878: IFFALSE 10756
// end ; repeat wait ( 0 0$1 ) ;
10880: LD_INT 35
10882: PPUSH
10883: CALL_OW 67
// for i in tmp do
10887: LD_ADDR_VAR 0 1
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: FOR_IN
10898: IFFALSE 11067
// begin if GetLives ( i ) > 251 then
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 256
10909: PUSH
10910: LD_INT 251
10912: GREATER
10913: IFFALSE 11038
// begin if GetWeapon ( i ) = ru_time_lapser then
10915: LD_VAR 0 1
10919: PPUSH
10920: CALL_OW 264
10924: PUSH
10925: LD_INT 49
10927: EQUAL
10928: IFFALSE 10984
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_INT 2
10937: PUSH
10938: LD_INT 22
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 8
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: PPUSH
10968: LD_VAR 0 1
10972: PPUSH
10973: CALL_OW 74
10977: PPUSH
10978: CALL_OW 112
10982: GO 11036
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10984: LD_VAR 0 1
10988: PPUSH
10989: LD_INT 2
10991: PUSH
10992: LD_INT 22
10994: PUSH
10995: LD_INT 1
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 8
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: PPUSH
11022: LD_VAR 0 1
11026: PPUSH
11027: CALL_OW 74
11031: PPUSH
11032: CALL_OW 115
// end else
11036: GO 11065
// if IsDead ( i ) then
11038: LD_VAR 0 1
11042: PPUSH
11043: CALL_OW 301
11047: IFFALSE 11065
// tmp := tmp diff i ;
11049: LD_ADDR_VAR 0 2
11053: PUSH
11054: LD_VAR 0 2
11058: PUSH
11059: LD_VAR 0 1
11063: DIFF
11064: ST_TO_ADDR
// end ;
11065: GO 10897
11067: POP
11068: POP
// until not tmp ;
11069: LD_VAR 0 2
11073: NOT
11074: IFFALSE 10880
// end ;
11076: PPOPN 4
11078: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11079: LD_EXP 15
11083: PUSH
11084: LD_INT 8
11086: GREATEREQUAL
11087: PUSH
11088: LD_OWVAR 67
11092: PUSH
11093: LD_INT 1
11095: GREATER
11096: AND
11097: IFFALSE 11281
11099: GO 11101
11101: DISABLE
11102: LD_INT 0
11104: PPUSH
11105: PPUSH
11106: PPUSH
// begin ruMobile := [ ] ;
11107: LD_ADDR_EXP 75
11111: PUSH
11112: EMPTY
11113: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: DOUBLE
11120: LD_INT 1
11122: DEC
11123: ST_TO_ADDR
11124: LD_INT 3
11126: PUSH
11127: LD_INT 4
11129: PUSH
11130: LD_INT 5
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: PUSH
11138: LD_OWVAR 67
11142: PUSH
11143: LD_INT 1
11145: MINUS
11146: ARRAY
11147: PUSH
11148: FOR_TO
11149: IFFALSE 11279
// begin uc_side := 3 ;
11151: LD_ADDR_OWVAR 20
11155: PUSH
11156: LD_INT 3
11158: ST_TO_ADDR
// uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11167: LD_INT 21
11169: PPUSH
11170: LD_INT 3
11172: PPUSH
11173: LD_INT 1
11175: PPUSH
11176: LD_INT 45
11178: PPUSH
11179: LD_INT 100
11181: PPUSH
11182: CALL 72344 0 5
// veh := CreateVehicle ;
11186: LD_ADDR_VAR 0 2
11190: PUSH
11191: CALL_OW 45
11195: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 3
11203: PPUSH
11204: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 29
11215: PPUSH
11216: LD_INT 0
11218: PPUSH
11219: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11223: LD_INT 0
11225: PPUSH
11226: LD_INT 10
11228: PPUSH
11229: CALL_OW 383
// un := CreateHuman ;
11233: LD_ADDR_VAR 0 3
11237: PUSH
11238: CALL_OW 44
11242: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11243: LD_VAR 0 3
11247: PPUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11257: LD_ADDR_EXP 75
11261: PUSH
11262: LD_EXP 75
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 104778 0 2
11276: ST_TO_ADDR
// end ;
11277: GO 11148
11279: POP
11280: POP
// end ;
11281: PPOPN 3
11283: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11284: LD_EXP 75
11288: IFFALSE 11796
11290: GO 11292
11292: DISABLE
11293: LD_INT 0
11295: PPUSH
11296: PPUSH
11297: PPUSH
// begin enable ;
11298: ENABLE
// if not ruMobile then
11299: LD_EXP 75
11303: NOT
11304: IFFALSE 11308
// exit ;
11306: GO 11796
// for i in ruMobile do
11308: LD_ADDR_VAR 0 1
11312: PUSH
11313: LD_EXP 75
11317: PUSH
11318: FOR_IN
11319: IFFALSE 11794
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 302
11330: NOT
11331: PUSH
11332: LD_VAR 0 1
11336: PPUSH
11337: CALL_OW 255
11341: PUSH
11342: LD_INT 3
11344: NONEQUAL
11345: OR
11346: IFFALSE 11366
// begin ruMobile := ruMobile diff i ;
11348: LD_ADDR_EXP 75
11352: PUSH
11353: LD_EXP 75
11357: PUSH
11358: LD_VAR 0 1
11362: DIFF
11363: ST_TO_ADDR
// continue ;
11364: GO 11318
// end ; if GetTag ( i ) = 300 then
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 110
11375: PUSH
11376: LD_INT 300
11378: EQUAL
11379: IFFALSE 11429
// begin ComMoveXY ( i , 160 , 81 ) ;
11381: LD_VAR 0 1
11385: PPUSH
11386: LD_INT 160
11388: PPUSH
11389: LD_INT 81
11391: PPUSH
11392: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11396: LD_VAR 0 1
11400: PPUSH
11401: LD_INT 160
11403: PPUSH
11404: LD_INT 81
11406: PPUSH
11407: CALL_OW 297
11411: PUSH
11412: LD_INT 8
11414: LESS
11415: IFFALSE 11429
// SetTag ( i , 301 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_INT 301
11424: PPUSH
11425: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 110
11438: PUSH
11439: LD_INT 301
11441: EQUAL
11442: IFFALSE 11485
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_INT 33
11451: PPUSH
11452: CALL_OW 308
11456: NOT
11457: IFFALSE 11473
// ComMoveToArea ( i , ruMobileParkingArea ) else
11459: LD_VAR 0 1
11463: PPUSH
11464: LD_INT 33
11466: PPUSH
11467: CALL_OW 113
11471: GO 11485
// SetTag ( i , 302 ) ;
11473: LD_VAR 0 1
11477: PPUSH
11478: LD_INT 302
11480: PPUSH
11481: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11485: LD_VAR 0 1
11489: PPUSH
11490: CALL_OW 110
11494: PUSH
11495: LD_INT 302
11497: EQUAL
11498: IFFALSE 11628
// begin if GetLives ( i ) < 1000 then
11500: LD_VAR 0 1
11504: PPUSH
11505: CALL_OW 256
11509: PUSH
11510: LD_INT 1000
11512: LESS
11513: IFFALSE 11605
// begin if not IsDrivenBy ( i ) then
11515: LD_VAR 0 1
11519: PPUSH
11520: CALL_OW 311
11524: NOT
11525: IFFALSE 11529
// continue ;
11527: GO 11318
// mech := IsDrivenBy ( i ) ;
11529: LD_ADDR_VAR 0 2
11533: PUSH
11534: LD_VAR 0 1
11538: PPUSH
11539: CALL_OW 311
11543: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11544: LD_VAR 0 2
11548: PPUSH
11549: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11553: LD_VAR 0 2
11557: PPUSH
11558: LD_VAR 0 1
11562: PPUSH
11563: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11567: LD_INT 35
11569: PPUSH
11570: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL_OW 256
11583: PUSH
11584: LD_INT 1000
11586: EQUAL
11587: IFFALSE 11567
// ComEnterUnit ( mech , i ) ;
11589: LD_VAR 0 2
11593: PPUSH
11594: LD_VAR 0 1
11598: PPUSH
11599: CALL_OW 120
// end else
11603: GO 11628
// if IsDrivenBy ( i ) then
11605: LD_VAR 0 1
11609: PPUSH
11610: CALL_OW 311
11614: IFFALSE 11628
// SetTag ( i , 0 ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11628: LD_VAR 0 1
11632: PPUSH
11633: CALL_OW 110
11637: PUSH
11638: LD_INT 300
11640: LESS
11641: IFFALSE 11792
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_INT 4
11650: PPUSH
11651: LD_INT 81
11653: PUSH
11654: LD_INT 3
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 70
11665: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 256
11675: PUSH
11676: LD_INT 650
11678: LESS
11679: IFFALSE 11704
// begin ComStop ( i ) ;
11681: LD_VAR 0 1
11685: PPUSH
11686: CALL_OW 141
// SetTag ( i , 300 ) ;
11690: LD_VAR 0 1
11694: PPUSH
11695: LD_INT 300
11697: PPUSH
11698: CALL_OW 109
// continue ;
11702: GO 11318
// end ; if enemy then
11704: LD_VAR 0 3
11708: IFFALSE 11748
// begin if not HasTask ( i ) then
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 314
11719: NOT
11720: IFFALSE 11746
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_VAR 0 3
11731: PPUSH
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 74
11741: PPUSH
11742: CALL_OW 115
// end else
11746: GO 11792
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11748: LD_VAR 0 1
11752: PPUSH
11753: LD_INT 158
11755: PUSH
11756: LD_INT 61
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 98
11765: PUSH
11766: LD_INT 100
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 78
11775: PUSH
11776: LD_INT 93
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL 107382 0 2
// end ; end ;
11792: GO 11318
11794: POP
11795: POP
// end ; end_of_file
11796: PPOPN 3
11798: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11799: LD_INT 0
11801: PPUSH
11802: PPUSH
11803: PPUSH
11804: PPUSH
11805: PPUSH
11806: PPUSH
// side := 7 ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_INT 7
11814: ST_TO_ADDR
// uc_side := side ;
11815: LD_ADDR_OWVAR 20
11819: PUSH
11820: LD_VAR 0 5
11824: ST_TO_ADDR
// uc_nation := 1 ;
11825: LD_ADDR_OWVAR 21
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11833: LD_ADDR_VAR 0 2
11837: PUSH
11838: LD_INT 22
11840: PUSH
11841: LD_VAR 0 5
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 69
11868: PUSH
11869: FOR_IN
11870: IFFALSE 11886
// SetBLevel ( i , 10 ) ;
11872: LD_VAR 0 2
11876: PPUSH
11877: LD_INT 10
11879: PPUSH
11880: CALL_OW 241
11884: GO 11869
11886: POP
11887: POP
// base := GetBase ( al_depot ) ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 2
11895: PPUSH
11896: CALL_OW 274
11900: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11901: LD_ADDR_VAR 0 6
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_VAR 0 5
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 30
11920: PUSH
11921: LD_INT 34
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PPUSH
11932: CALL_OW 69
11936: ST_TO_ADDR
// if teleport then
11937: LD_VAR 0 6
11941: IFFALSE 11962
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11943: LD_VAR 0 6
11947: PUSH
11948: LD_INT 1
11950: ARRAY
11951: PPUSH
11952: LD_INT 262
11954: PPUSH
11955: LD_INT 119
11957: PPUSH
11958: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11962: LD_VAR 0 4
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_INT 19500
11972: PPUSH
11973: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11977: LD_VAR 0 4
11981: PPUSH
11982: LD_INT 2
11984: PPUSH
11985: LD_INT 200
11987: PPUSH
11988: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11992: LD_VAR 0 4
11996: PPUSH
11997: LD_INT 3
11999: PPUSH
12000: LD_INT 650
12002: PPUSH
12003: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12007: LD_ADDR_EXP 76
12011: PUSH
12012: LD_STRING Roth
12014: PPUSH
12015: CALL_OW 25
12019: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12020: LD_ADDR_EXP 77
12024: PUSH
12025: LD_STRING Simms
12027: PPUSH
12028: LD_EXP 1
12032: NOT
12033: PPUSH
12034: LD_STRING 10c_
12036: PPUSH
12037: CALL 67329 0 3
12041: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12042: LD_EXP 77
12046: PPUSH
12047: LD_INT 4
12049: PPUSH
12050: CALL_OW 336
// if not Simms then
12054: LD_EXP 77
12058: NOT
12059: IFFALSE 12089
// begin uc_nation := 1 ;
12061: LD_ADDR_OWVAR 21
12065: PUSH
12066: LD_INT 1
12068: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12069: LD_INT 2
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: CALL_OW 384
// Simms := CreateHuman ;
12079: LD_ADDR_EXP 77
12083: PUSH
12084: CALL_OW 44
12088: ST_TO_ADDR
// end ; uc_nation := 3 ;
12089: LD_ADDR_OWVAR 21
12093: PUSH
12094: LD_INT 3
12096: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12097: LD_ADDR_EXP 78
12101: PUSH
12102: LD_STRING Kirilenkova
12104: PPUSH
12105: CALL_OW 25
12109: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12110: LD_ADDR_EXP 92
12114: PUSH
12115: LD_STRING Oblukov
12117: PPUSH
12118: CALL_OW 25
12122: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12123: LD_ADDR_EXP 79
12127: PUSH
12128: LD_STRING Dolgov
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12136: LD_ADDR_EXP 80
12140: PUSH
12141: LD_STRING Petrosyan
12143: PPUSH
12144: CALL_OW 25
12148: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12149: LD_ADDR_EXP 91
12153: PUSH
12154: LD_STRING Scholtze
12156: PPUSH
12157: CALL_OW 25
12161: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12162: LD_ADDR_EXP 90
12166: PUSH
12167: LD_STRING Kapitsova
12169: PPUSH
12170: CALL_OW 25
12174: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12175: LD_ADDR_EXP 81
12179: PUSH
12180: LD_STRING Petrovova
12182: PPUSH
12183: CALL_OW 25
12187: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12188: LD_ADDR_EXP 82
12192: PUSH
12193: LD_STRING Kuzmov
12195: PPUSH
12196: CALL_OW 25
12200: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12201: LD_ADDR_EXP 89
12205: PUSH
12206: LD_STRING Karamazov
12208: PPUSH
12209: CALL_OW 25
12213: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12214: LD_STRING 13_Lipshchin_1
12216: PPUSH
12217: LD_INT 0
12219: PPUSH
12220: CALL_OW 30
12224: IFFALSE 12239
// Lipshchin := NewCharacter ( Lipshchin ) ;
12226: LD_ADDR_EXP 83
12230: PUSH
12231: LD_STRING Lipshchin
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12239: LD_STRING 13_Titov_1
12241: PPUSH
12242: LD_INT 0
12244: PPUSH
12245: CALL_OW 30
12249: IFFALSE 12264
// Titov := NewCharacter ( Titov ) ;
12251: LD_ADDR_EXP 85
12255: PUSH
12256: LD_STRING Titov
12258: PPUSH
12259: CALL_OW 25
12263: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12264: LD_STRING 13_Gnyevko_1
12266: PPUSH
12267: LD_INT 0
12269: PPUSH
12270: CALL_OW 30
12274: IFFALSE 12289
// Gnyevko := NewCharacter ( Gnyevko ) ;
12276: LD_ADDR_EXP 84
12280: PUSH
12281: LD_STRING Gnyevko
12283: PPUSH
12284: CALL_OW 25
12288: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12289: LD_STRING 13_Xavier_1
12291: PPUSH
12292: LD_INT 0
12294: PPUSH
12295: CALL_OW 30
12299: IFFALSE 12314
// Xavier := NewCharacter ( Xavier2 ) ;
12301: LD_ADDR_EXP 86
12305: PUSH
12306: LD_STRING Xavier2
12308: PPUSH
12309: CALL_OW 25
12313: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12314: LD_STRING 13_Belkov_1
12316: PPUSH
12317: LD_INT 0
12319: PPUSH
12320: CALL_OW 30
12324: IFFALSE 12339
// Belkov := NewCharacter ( Belkov ) ;
12326: LD_ADDR_EXP 87
12330: PUSH
12331: LD_STRING Belkov
12333: PPUSH
12334: CALL_OW 25
12338: ST_TO_ADDR
// if not BurlakStatus then
12339: LD_EXP 9
12343: NOT
12344: IFFALSE 12359
// Burlak = NewCharacter ( Burlak ) ;
12346: LD_ADDR_EXP 88
12350: PUSH
12351: LD_STRING Burlak
12353: PPUSH
12354: CALL_OW 25
12358: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12359: LD_ADDR_VAR 0 3
12363: PUSH
12364: LD_EXP 76
12368: PUSH
12369: LD_EXP 78
12373: PUSH
12374: LD_EXP 92
12378: PUSH
12379: LD_EXP 79
12383: PUSH
12384: LD_EXP 80
12388: PUSH
12389: LD_EXP 91
12393: PUSH
12394: LD_EXP 90
12398: PUSH
12399: LD_EXP 81
12403: PUSH
12404: LD_EXP 82
12408: PUSH
12409: LD_EXP 89
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: LIST
12423: LIST
12424: LIST
12425: ST_TO_ADDR
// if Simms then
12426: LD_EXP 77
12430: IFFALSE 12448
// tmp := tmp ^ Simms ;
12432: LD_ADDR_VAR 0 3
12436: PUSH
12437: LD_VAR 0 3
12441: PUSH
12442: LD_EXP 77
12446: ADD
12447: ST_TO_ADDR
// if Titov then
12448: LD_EXP 85
12452: IFFALSE 12470
// tmp := tmp ^ Titov ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_VAR 0 3
12463: PUSH
12464: LD_EXP 85
12468: ADD
12469: ST_TO_ADDR
// if Lipshchin then
12470: LD_EXP 83
12474: IFFALSE 12492
// tmp := tmp ^ Lipshchin ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_VAR 0 3
12485: PUSH
12486: LD_EXP 83
12490: ADD
12491: ST_TO_ADDR
// if Gnyevko then
12492: LD_EXP 84
12496: IFFALSE 12514
// tmp := tmp ^ Gnyevko ;
12498: LD_ADDR_VAR 0 3
12502: PUSH
12503: LD_VAR 0 3
12507: PUSH
12508: LD_EXP 84
12512: ADD
12513: ST_TO_ADDR
// if Xavier then
12514: LD_EXP 86
12518: IFFALSE 12536
// tmp := tmp ^ Xavier ;
12520: LD_ADDR_VAR 0 3
12524: PUSH
12525: LD_VAR 0 3
12529: PUSH
12530: LD_EXP 86
12534: ADD
12535: ST_TO_ADDR
// if Belkov then
12536: LD_EXP 87
12540: IFFALSE 12558
// tmp := tmp ^ Belkov ;
12542: LD_ADDR_VAR 0 3
12546: PUSH
12547: LD_VAR 0 3
12551: PUSH
12552: LD_EXP 87
12556: ADD
12557: ST_TO_ADDR
// if Burlak then
12558: LD_EXP 88
12562: IFFALSE 12580
// tmp := tmp ^ Burlak ;
12564: LD_ADDR_VAR 0 3
12568: PUSH
12569: LD_VAR 0 3
12573: PUSH
12574: LD_EXP 88
12578: ADD
12579: ST_TO_ADDR
// for i = 1 to 11 do
12580: LD_ADDR_VAR 0 2
12584: PUSH
12585: DOUBLE
12586: LD_INT 1
12588: DEC
12589: ST_TO_ADDR
12590: LD_INT 11
12592: PUSH
12593: FOR_TO
12594: IFFALSE 12660
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12596: LD_ADDR_OWVAR 21
12600: PUSH
12601: LD_INT 1
12603: PUSH
12604: LD_INT 3
12606: PUSH
12607: EMPTY
12608: LIST
12609: LIST
12610: PUSH
12611: LD_INT 1
12613: PPUSH
12614: LD_INT 2
12616: PPUSH
12617: CALL_OW 12
12621: ARRAY
12622: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12623: LD_INT 0
12625: PPUSH
12626: LD_VAR 0 2
12630: PUSH
12631: LD_INT 2
12633: DIV
12634: PPUSH
12635: LD_INT 10
12637: PPUSH
12638: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_VAR 0 3
12651: PUSH
12652: CALL_OW 44
12656: ADD
12657: ST_TO_ADDR
// end ;
12658: GO 12593
12660: POP
12661: POP
// for i in tmp do
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 3
12671: PUSH
12672: FOR_IN
12673: IFFALSE 12698
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12675: LD_VAR 0 2
12679: PPUSH
12680: LD_INT 260
12682: PPUSH
12683: LD_INT 235
12685: PPUSH
12686: LD_INT 8
12688: PPUSH
12689: LD_INT 0
12691: PPUSH
12692: CALL_OW 50
12696: GO 12672
12698: POP
12699: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12700: LD_ADDR_EXP 99
12704: PUSH
12705: LD_EXP 99
12709: PPUSH
12710: LD_INT 1
12712: PPUSH
12713: LD_INT 22
12715: PUSH
12716: LD_VAR 0 5
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 3
12727: PUSH
12728: LD_INT 21
12730: PUSH
12731: LD_INT 2
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PPUSH
12746: CALL_OW 69
12750: PUSH
12751: LD_EXP 76
12755: PUSH
12756: LD_EXP 77
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: DIFF
12765: PPUSH
12766: CALL_OW 1
12770: ST_TO_ADDR
// uc_side := 0 ;
12771: LD_ADDR_OWVAR 20
12775: PUSH
12776: LD_INT 0
12778: ST_TO_ADDR
// uc_nation := 0 ;
12779: LD_ADDR_OWVAR 21
12783: PUSH
12784: LD_INT 0
12786: ST_TO_ADDR
// for i = 1 to 5 do
12787: LD_ADDR_VAR 0 2
12791: PUSH
12792: DOUBLE
12793: LD_INT 1
12795: DEC
12796: ST_TO_ADDR
12797: LD_INT 5
12799: PUSH
12800: FOR_TO
12801: IFFALSE 12838
// begin InitHc ;
12803: CALL_OW 19
// hc_class := class_apeman ;
12807: LD_ADDR_OWVAR 28
12811: PUSH
12812: LD_INT 12
12814: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12815: CALL_OW 44
12819: PPUSH
12820: LD_INT 299
12822: PPUSH
12823: LD_INT 229
12825: PPUSH
12826: LD_INT 10
12828: PPUSH
12829: LD_INT 0
12831: PPUSH
12832: CALL_OW 50
// end ;
12836: GO 12800
12838: POP
12839: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12840: LD_EXP 76
12844: PPUSH
12845: LD_INT 259
12847: PPUSH
12848: LD_INT 235
12850: PPUSH
12851: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12855: LD_EXP 76
12859: PPUSH
12860: LD_INT 262
12862: PPUSH
12863: LD_INT 235
12865: PPUSH
12866: CALL_OW 178
// if Simms then
12870: LD_EXP 77
12874: IFFALSE 12905
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12876: LD_EXP 77
12880: PPUSH
12881: LD_INT 262
12883: PPUSH
12884: LD_INT 235
12886: PPUSH
12887: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12891: LD_EXP 77
12895: PPUSH
12896: LD_EXP 76
12900: PPUSH
12901: CALL_OW 179
// end ; end ;
12905: LD_VAR 0 1
12909: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12910: LD_EXP 31
12914: PUSH
12915: LD_EXP 23
12919: NOT
12920: AND
12921: IFFALSE 13149
12923: GO 12925
12925: DISABLE
12926: LD_INT 0
12928: PPUSH
12929: PPUSH
12930: PPUSH
// begin enable ;
12931: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12932: LD_ADDR_VAR 0 2
12936: PUSH
12937: LD_INT 81
12939: PUSH
12940: LD_INT 7
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 2
12949: PUSH
12950: LD_INT 32
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: LD_INT 30
12962: PUSH
12963: LD_INT 30
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 30
12972: PUSH
12973: LD_INT 28
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 34
12982: PUSH
12983: LD_INT 49
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: LD_INT 34
12992: PUSH
12993: LD_INT 10
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 34
13002: PUSH
13003: LD_INT 8
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: PPUSH
13023: CALL_OW 69
13027: ST_TO_ADDR
// if not tmp then
13028: LD_VAR 0 2
13032: NOT
13033: IFFALSE 13037
// exit ;
13035: GO 13149
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13037: LD_VAR 0 2
13041: PPUSH
13042: LD_INT 34
13044: PUSH
13045: LD_INT 8
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: PPUSH
13052: CALL_OW 72
13056: IFFALSE 13089
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13058: LD_ADDR_VAR 0 3
13062: PUSH
13063: LD_VAR 0 2
13067: PPUSH
13068: LD_INT 34
13070: PUSH
13071: LD_INT 8
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PPUSH
13078: CALL_OW 72
13082: PUSH
13083: LD_INT 1
13085: ARRAY
13086: ST_TO_ADDR
13087: GO 13113
// target := tmp [ rand ( 1 , tmp ) ] ;
13089: LD_ADDR_VAR 0 3
13093: PUSH
13094: LD_VAR 0 2
13098: PUSH
13099: LD_INT 1
13101: PPUSH
13102: LD_VAR 0 2
13106: PPUSH
13107: CALL_OW 12
13111: ARRAY
13112: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13113: LD_VAR 0 3
13117: PPUSH
13118: CALL_OW 255
13122: PUSH
13123: LD_INT 1
13125: EQUAL
13126: IFFALSE 13137
// CenterNowOnUnits ( target ) ;
13128: LD_VAR 0 3
13132: PPUSH
13133: CALL_OW 87
// SetLives ( target , 0 ) ;
13137: LD_VAR 0 3
13141: PPUSH
13142: LD_INT 0
13144: PPUSH
13145: CALL_OW 234
// end ;
13149: PPOPN 3
13151: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13152: LD_EXP 23
13156: NOT
13157: PUSH
13158: LD_EXP 31
13162: AND
13163: IFFALSE 13689
13165: GO 13167
13167: DISABLE
13168: LD_INT 0
13170: PPUSH
13171: PPUSH
13172: PPUSH
// begin uc_side := 7 ;
13173: LD_ADDR_OWVAR 20
13177: PUSH
13178: LD_INT 7
13180: ST_TO_ADDR
// uc_nation := 1 ;
13181: LD_ADDR_OWVAR 21
13185: PUSH
13186: LD_INT 1
13188: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13189: LD_ADDR_VAR 0 3
13193: PUSH
13194: LD_INT 125
13196: PUSH
13197: LD_INT 163
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: PUSH
13204: LD_INT 185
13206: PUSH
13207: LD_INT 168
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 111
13216: PUSH
13217: LD_INT 97
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: LIST
13228: PPUSH
13229: CALL 104883 0 1
13233: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13234: LD_ADDR_EXP 93
13238: PUSH
13239: EMPTY
13240: ST_TO_ADDR
// for i = 1 to Difficulty do
13241: LD_ADDR_VAR 0 1
13245: PUSH
13246: DOUBLE
13247: LD_INT 1
13249: DEC
13250: ST_TO_ADDR
13251: LD_OWVAR 67
13255: PUSH
13256: FOR_TO
13257: IFFALSE 13415
// begin InitHc ;
13259: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13263: LD_INT 0
13265: PPUSH
13266: LD_INT 8
13268: PPUSH
13269: CALL_OW 381
// un := CreateHuman ;
13273: LD_ADDR_VAR 0 2
13277: PUSH
13278: CALL_OW 44
13282: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13283: LD_VAR 0 2
13287: PPUSH
13288: LD_INT 258
13290: PPUSH
13291: LD_INT 267
13293: PPUSH
13294: LD_INT 4
13296: PPUSH
13297: LD_INT 0
13299: PPUSH
13300: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13304: LD_ADDR_EXP 93
13308: PUSH
13309: LD_EXP 93
13313: PUSH
13314: LD_VAR 0 2
13318: UNION
13319: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13320: LD_VAR 0 2
13324: PPUSH
13325: LD_VAR 0 3
13329: PUSH
13330: LD_VAR 0 1
13334: ARRAY
13335: PUSH
13336: LD_INT 1
13338: ARRAY
13339: PPUSH
13340: LD_VAR 0 3
13344: PUSH
13345: LD_VAR 0 1
13349: ARRAY
13350: PUSH
13351: LD_INT 2
13353: ARRAY
13354: PPUSH
13355: LD_INT 4
13357: PPUSH
13358: LD_INT 1
13360: PPUSH
13361: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13365: LD_VAR 0 2
13369: PPUSH
13370: LD_VAR 0 3
13374: PUSH
13375: LD_VAR 0 1
13379: ARRAY
13380: PUSH
13381: LD_INT 1
13383: ARRAY
13384: PPUSH
13385: LD_VAR 0 3
13389: PUSH
13390: LD_VAR 0 1
13394: ARRAY
13395: PUSH
13396: LD_INT 2
13398: ARRAY
13399: PPUSH
13400: CALL_OW 171
// AddComInvisible ( un ) ;
13404: LD_VAR 0 2
13408: PPUSH
13409: CALL_OW 212
// end ;
13413: GO 13256
13415: POP
13416: POP
// repeat wait ( 0 0$20 ) ;
13417: LD_INT 700
13419: PPUSH
13420: CALL_OW 67
// for i in allianceSpecialForce do
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_EXP 93
13433: PUSH
13434: FOR_IN
13435: IFFALSE 13674
// begin if IsInvisible ( i ) then
13437: LD_VAR 0 1
13441: PPUSH
13442: CALL_OW 571
13446: IFFALSE 13643
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13448: LD_ADDR_VAR 0 3
13452: PUSH
13453: LD_INT 22
13455: PUSH
13456: LD_INT 1
13458: PUSH
13459: EMPTY
13460: LIST
13461: LIST
13462: PUSH
13463: LD_INT 50
13465: PUSH
13466: EMPTY
13467: LIST
13468: PUSH
13469: LD_INT 56
13471: PUSH
13472: EMPTY
13473: LIST
13474: PUSH
13475: LD_INT 91
13477: PUSH
13478: LD_VAR 0 1
13482: PUSH
13483: LD_INT 25
13485: PUSH
13486: LD_INT 30
13488: PUSH
13489: LD_INT 35
13491: PUSH
13492: LD_INT 40
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: LIST
13499: LIST
13500: PUSH
13501: LD_OWVAR 67
13505: ARRAY
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 2
13514: PUSH
13515: LD_INT 25
13517: PUSH
13518: LD_INT 1
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 25
13527: PUSH
13528: LD_INT 2
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 25
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 25
13557: PUSH
13558: LD_INT 5
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 25
13567: PUSH
13568: LD_INT 8
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: PPUSH
13591: CALL_OW 69
13595: ST_TO_ADDR
// if not tmp then
13596: LD_VAR 0 3
13600: NOT
13601: IFFALSE 13605
// continue ;
13603: GO 13434
// if Prob ( 30 * Difficulty ) then
13605: LD_INT 30
13607: PUSH
13608: LD_OWVAR 67
13612: MUL
13613: PPUSH
13614: CALL_OW 13
13618: IFFALSE 13643
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13620: LD_VAR 0 3
13624: PUSH
13625: LD_INT 1
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: CALL_OW 12
13637: ARRAY
13638: PPUSH
13639: CALL 32677 0 1
// end ; if IsDead ( i ) then
13643: LD_VAR 0 1
13647: PPUSH
13648: CALL_OW 301
13652: IFFALSE 13672
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13654: LD_ADDR_EXP 93
13658: PUSH
13659: LD_EXP 93
13663: PUSH
13664: LD_VAR 0 1
13668: DIFF
13669: ST_TO_ADDR
// continue ;
13670: GO 13434
// end ; end ;
13672: GO 13434
13674: POP
13675: POP
// until allianceDestroyed or not allianceSpecialForce ;
13676: LD_EXP 23
13680: PUSH
13681: LD_EXP 93
13685: NOT
13686: OR
13687: IFFALSE 13417
// end ;
13689: PPOPN 3
13691: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13692: LD_EXP 23
13696: NOT
13697: PUSH
13698: LD_EXP 31
13702: AND
13703: IFFALSE 14653
13705: GO 13707
13707: DISABLE
13708: LD_INT 0
13710: PPUSH
13711: PPUSH
13712: PPUSH
13713: PPUSH
// begin enable ;
13714: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13715: LD_INT 22
13717: PUSH
13718: LD_INT 7
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: PUSH
13725: LD_INT 30
13727: PUSH
13728: LD_INT 3
13730: PUSH
13731: EMPTY
13732: LIST
13733: LIST
13734: PUSH
13735: EMPTY
13736: LIST
13737: LIST
13738: PPUSH
13739: CALL_OW 69
13743: NOT
13744: IFFALSE 13748
// exit ;
13746: GO 14653
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13748: LD_ADDR_VAR 0 4
13752: PUSH
13753: LD_INT 22
13755: PUSH
13756: LD_INT 7
13758: PUSH
13759: EMPTY
13760: LIST
13761: LIST
13762: PUSH
13763: LD_INT 30
13765: PUSH
13766: LD_INT 34
13768: PUSH
13769: EMPTY
13770: LIST
13771: LIST
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: PPUSH
13777: CALL_OW 69
13781: ST_TO_ADDR
// if Prob ( 40 ) then
13782: LD_INT 40
13784: PPUSH
13785: CALL_OW 13
13789: IFFALSE 13935
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13791: LD_INT 1
13793: PPUSH
13794: LD_INT 5
13796: PUSH
13797: LD_INT 3
13799: PUSH
13800: LD_INT 2
13802: PUSH
13803: LD_INT 6
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: LIST
13810: LIST
13811: PUSH
13812: LD_INT 5
13814: PUSH
13815: LD_INT 3
13817: PUSH
13818: LD_INT 2
13820: PUSH
13821: LD_INT 6
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: PUSH
13830: LD_INT 5
13832: PUSH
13833: LD_INT 3
13835: PUSH
13836: LD_INT 2
13838: PUSH
13839: LD_INT 6
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: PUSH
13848: LD_INT 5
13850: PUSH
13851: LD_INT 3
13853: PUSH
13854: LD_INT 2
13856: PUSH
13857: LD_INT 9
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: PUSH
13866: LD_INT 24
13868: PUSH
13869: LD_INT 3
13871: PUSH
13872: LD_INT 3
13874: PUSH
13875: LD_INT 45
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: PUSH
13884: LD_INT 24
13886: PUSH
13887: LD_INT 3
13889: PUSH
13890: LD_INT 3
13892: PUSH
13893: LD_INT 47
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: PUSH
13902: LD_INT 24
13904: PUSH
13905: LD_INT 3
13907: PUSH
13908: LD_INT 3
13910: PUSH
13911: LD_INT 45
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: PPUSH
13929: CALL 60941 0 2
// end else
13933: GO 14077
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13935: LD_INT 1
13937: PPUSH
13938: LD_INT 24
13940: PUSH
13941: LD_INT 3
13943: PUSH
13944: LD_INT 3
13946: PUSH
13947: LD_INT 47
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 24
13958: PUSH
13959: LD_INT 3
13961: PUSH
13962: LD_INT 3
13964: PUSH
13965: LD_INT 47
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: PUSH
13974: LD_INT 5
13976: PUSH
13977: LD_INT 3
13979: PUSH
13980: LD_INT 2
13982: PUSH
13983: LD_INT 9
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: PUSH
13992: LD_INT 5
13994: PUSH
13995: LD_INT 3
13997: PUSH
13998: LD_INT 2
14000: PUSH
14001: LD_INT 9
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 5
14012: PUSH
14013: LD_INT 3
14015: PUSH
14016: LD_INT 2
14018: PUSH
14019: LD_INT 9
14021: PUSH
14022: EMPTY
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: PUSH
14028: LD_INT 24
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: LD_INT 3
14036: PUSH
14037: LD_INT 45
14039: PUSH
14040: EMPTY
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: PUSH
14046: LD_INT 24
14048: PUSH
14049: LD_INT 1
14051: PUSH
14052: LD_INT 3
14054: PUSH
14055: LD_INT 45
14057: PUSH
14058: EMPTY
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: PPUSH
14073: CALL 60941 0 2
// end ; repeat wait ( 0 0$1 ) ;
14077: LD_INT 35
14079: PPUSH
14080: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14084: LD_INT 1
14086: PPUSH
14087: LD_INT 1
14089: PPUSH
14090: CALL 62359 0 2
14094: PUSH
14095: LD_INT 7
14097: GREATEREQUAL
14098: IFFALSE 14077
// wait ( 0 0$10 ) ;
14100: LD_INT 350
14102: PPUSH
14103: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14107: LD_ADDR_VAR 0 2
14111: PUSH
14112: LD_INT 1
14114: PPUSH
14115: LD_INT 1
14117: PPUSH
14118: CALL 62359 0 2
14122: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14123: LD_ADDR_EXP 118
14127: PUSH
14128: LD_EXP 118
14132: PPUSH
14133: LD_INT 1
14135: PPUSH
14136: LD_EXP 118
14140: PUSH
14141: LD_INT 1
14143: ARRAY
14144: PUSH
14145: LD_VAR 0 2
14149: DIFF
14150: PPUSH
14151: CALL_OW 1
14155: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14156: LD_ADDR_VAR 0 3
14160: PUSH
14161: LD_INT 0
14163: PPUSH
14164: LD_INT 1
14166: PPUSH
14167: CALL_OW 12
14171: ST_TO_ADDR
// if target then
14172: LD_VAR 0 3
14176: IFFALSE 14342
// begin for i in tmp do
14178: LD_ADDR_VAR 0 1
14182: PUSH
14183: LD_VAR 0 2
14187: PUSH
14188: FOR_IN
14189: IFFALSE 14214
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14191: LD_VAR 0 1
14195: PPUSH
14196: LD_INT 179
14198: PPUSH
14199: LD_INT 209
14201: PPUSH
14202: LD_INT 8
14204: PPUSH
14205: LD_INT 1
14207: PPUSH
14208: CALL_OW 483
14212: GO 14188
14214: POP
14215: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14216: LD_ADDR_VAR 0 2
14220: PUSH
14221: LD_VAR 0 2
14225: PPUSH
14226: LD_INT 24
14228: PUSH
14229: LD_INT 250
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: PPUSH
14236: CALL_OW 72
14240: ST_TO_ADDR
// for i in tmp do
14241: LD_ADDR_VAR 0 1
14245: PUSH
14246: LD_VAR 0 2
14250: PUSH
14251: FOR_IN
14252: IFFALSE 14292
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14254: LD_VAR 0 1
14258: PPUSH
14259: LD_INT 179
14261: PPUSH
14262: LD_INT 209
14264: PPUSH
14265: CALL_OW 297
14269: PUSH
14270: LD_INT 9
14272: GREATER
14273: IFFALSE 14290
// ComMoveXY ( i , 179 , 209 ) ;
14275: LD_VAR 0 1
14279: PPUSH
14280: LD_INT 179
14282: PPUSH
14283: LD_INT 209
14285: PPUSH
14286: CALL_OW 111
14290: GO 14251
14292: POP
14293: POP
// wait ( 0 0$1 ) ;
14294: LD_INT 35
14296: PPUSH
14297: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14301: LD_VAR 0 2
14305: PPUSH
14306: LD_INT 92
14308: PUSH
14309: LD_INT 179
14311: PUSH
14312: LD_INT 209
14314: PUSH
14315: LD_INT 9
14317: PUSH
14318: EMPTY
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: PPUSH
14324: CALL_OW 72
14328: PUSH
14329: LD_VAR 0 2
14333: PUSH
14334: LD_INT 1
14336: MINUS
14337: GREATEREQUAL
14338: IFFALSE 14216
// end else
14340: GO 14504
// begin for i in tmp do
14342: LD_ADDR_VAR 0 1
14346: PUSH
14347: LD_VAR 0 2
14351: PUSH
14352: FOR_IN
14353: IFFALSE 14378
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14355: LD_VAR 0 1
14359: PPUSH
14360: LD_INT 285
14362: PPUSH
14363: LD_INT 163
14365: PPUSH
14366: LD_INT 8
14368: PPUSH
14369: LD_INT 1
14371: PPUSH
14372: CALL_OW 483
14376: GO 14352
14378: POP
14379: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14380: LD_ADDR_VAR 0 2
14384: PUSH
14385: LD_VAR 0 2
14389: PPUSH
14390: LD_INT 24
14392: PUSH
14393: LD_INT 250
14395: PUSH
14396: EMPTY
14397: LIST
14398: LIST
14399: PPUSH
14400: CALL_OW 72
14404: ST_TO_ADDR
// for i in tmp do
14405: LD_ADDR_VAR 0 1
14409: PUSH
14410: LD_VAR 0 2
14414: PUSH
14415: FOR_IN
14416: IFFALSE 14456
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14418: LD_VAR 0 1
14422: PPUSH
14423: LD_INT 285
14425: PPUSH
14426: LD_INT 163
14428: PPUSH
14429: CALL_OW 297
14433: PUSH
14434: LD_INT 9
14436: GREATER
14437: IFFALSE 14454
// ComMoveXY ( i , 285 , 163 ) ;
14439: LD_VAR 0 1
14443: PPUSH
14444: LD_INT 285
14446: PPUSH
14447: LD_INT 163
14449: PPUSH
14450: CALL_OW 111
14454: GO 14415
14456: POP
14457: POP
// wait ( 0 0$1 ) ;
14458: LD_INT 35
14460: PPUSH
14461: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14465: LD_VAR 0 2
14469: PPUSH
14470: LD_INT 92
14472: PUSH
14473: LD_INT 285
14475: PUSH
14476: LD_INT 163
14478: PUSH
14479: LD_INT 9
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: PPUSH
14488: CALL_OW 72
14492: PUSH
14493: LD_VAR 0 2
14497: PUSH
14498: LD_INT 1
14500: MINUS
14501: GREATEREQUAL
14502: IFFALSE 14380
// end ; repeat wait ( 0 0$1 ) ;
14504: LD_INT 35
14506: PPUSH
14507: CALL_OW 67
// for i in tmp do
14511: LD_ADDR_VAR 0 1
14515: PUSH
14516: LD_VAR 0 2
14520: PUSH
14521: FOR_IN
14522: IFFALSE 14644
// if GetLives ( i ) > 251 then
14524: LD_VAR 0 1
14528: PPUSH
14529: CALL_OW 256
14533: PUSH
14534: LD_INT 251
14536: GREATER
14537: IFFALSE 14626
// begin if GetWeapon ( i ) = ru_time_lapser then
14539: LD_VAR 0 1
14543: PPUSH
14544: CALL_OW 264
14548: PUSH
14549: LD_INT 49
14551: EQUAL
14552: IFFALSE 14590
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14554: LD_VAR 0 1
14558: PPUSH
14559: LD_INT 81
14561: PUSH
14562: LD_INT 7
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PPUSH
14569: CALL_OW 69
14573: PPUSH
14574: LD_VAR 0 1
14578: PPUSH
14579: CALL_OW 74
14583: PPUSH
14584: CALL_OW 112
14588: GO 14624
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14590: LD_VAR 0 1
14594: PPUSH
14595: LD_INT 81
14597: PUSH
14598: LD_INT 7
14600: PUSH
14601: EMPTY
14602: LIST
14603: LIST
14604: PPUSH
14605: CALL_OW 69
14609: PPUSH
14610: LD_VAR 0 1
14614: PPUSH
14615: CALL_OW 74
14619: PPUSH
14620: CALL_OW 115
// end else
14624: GO 14642
// tmp := tmp diff i ;
14626: LD_ADDR_VAR 0 2
14630: PUSH
14631: LD_VAR 0 2
14635: PUSH
14636: LD_VAR 0 1
14640: DIFF
14641: ST_TO_ADDR
14642: GO 14521
14644: POP
14645: POP
// until not tmp ;
14646: LD_VAR 0 2
14650: NOT
14651: IFFALSE 14504
// end ; end_of_file
14653: PPOPN 4
14655: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14656: LD_INT 0
14658: PPUSH
14659: PPUSH
14660: PPUSH
14661: PPUSH
// missionStage := 13 ;
14662: LD_ADDR_EXP 15
14666: PUSH
14667: LD_INT 13
14669: ST_TO_ADDR
// uc_side := 2 ;
14670: LD_ADDR_OWVAR 20
14674: PUSH
14675: LD_INT 2
14677: ST_TO_ADDR
// uc_nation := 2 ;
14678: LD_ADDR_OWVAR 21
14682: PUSH
14683: LD_INT 2
14685: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14686: LD_ADDR_EXP 94
14690: PUSH
14691: LD_STRING Omar
14693: PPUSH
14694: CALL_OW 25
14698: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14699: LD_EXP 94
14703: PPUSH
14704: LD_INT 4
14706: PPUSH
14707: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14711: LD_EXP 94
14715: PPUSH
14716: LD_INT 242
14718: PPUSH
14719: LD_INT 75
14721: PPUSH
14722: LD_INT 0
14724: PPUSH
14725: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14729: LD_ADDR_EXP 95
14733: PUSH
14734: LD_STRING Heike
14736: PPUSH
14737: CALL_OW 25
14741: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14742: LD_INT 14
14744: PPUSH
14745: LD_INT 3
14747: PPUSH
14748: LD_INT 1
14750: PPUSH
14751: LD_INT 27
14753: PPUSH
14754: LD_INT 100
14756: PPUSH
14757: CALL 72344 0 5
// veh := CreateVehicle ;
14761: LD_ADDR_VAR 0 3
14765: PUSH
14766: CALL_OW 45
14770: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14771: LD_VAR 0 3
14775: PPUSH
14776: LD_INT 2
14778: NEG
14779: PPUSH
14780: CALL_OW 242
// SetDir ( veh , 4 ) ;
14784: LD_VAR 0 3
14788: PPUSH
14789: LD_INT 4
14791: PPUSH
14792: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14796: LD_VAR 0 3
14800: PPUSH
14801: LD_INT 241
14803: PPUSH
14804: LD_INT 72
14806: PPUSH
14807: LD_INT 0
14809: PPUSH
14810: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14814: LD_EXP 95
14818: PPUSH
14819: LD_VAR 0 3
14823: PPUSH
14824: CALL_OW 52
// if KhatamStatus then
14828: LD_EXP 8
14832: IFFALSE 14895
// begin Khatam := NewCharacter ( Khatam ) ;
14834: LD_ADDR_EXP 96
14838: PUSH
14839: LD_STRING Khatam
14841: PPUSH
14842: CALL_OW 25
14846: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14847: LD_EXP 96
14851: PPUSH
14852: LD_INT 245
14854: PPUSH
14855: LD_INT 78
14857: PPUSH
14858: LD_INT 3
14860: PPUSH
14861: LD_INT 0
14863: PPUSH
14864: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14868: LD_EXP 96
14872: PPUSH
14873: LD_INT 4
14875: PPUSH
14876: LD_INT 10
14878: PPUSH
14879: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14883: LD_EXP 96
14887: PPUSH
14888: LD_INT 4
14890: PPUSH
14891: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
14895: LD_ADDR_VAR 0 2
14899: PUSH
14900: DOUBLE
14901: LD_INT 1
14903: DEC
14904: ST_TO_ADDR
14905: LD_INT 2
14907: PUSH
14908: LD_INT 2
14910: PUSH
14911: LD_INT 3
14913: PUSH
14914: LD_INT 3
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: PUSH
14923: LD_OWVAR 67
14927: ARRAY
14928: PUSH
14929: FOR_TO
14930: IFFALSE 14996
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14932: LD_INT 0
14934: PPUSH
14935: LD_INT 6
14937: PUSH
14938: LD_OWVAR 67
14942: PLUS
14943: PPUSH
14944: CALL_OW 384
// un := CreateHuman ;
14948: LD_ADDR_VAR 0 4
14952: PUSH
14953: CALL_OW 44
14957: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14958: LD_VAR 0 4
14962: PPUSH
14963: LD_INT 28
14965: PUSH
14966: LD_INT 29
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: LD_VAR 0 2
14977: PUSH
14978: LD_INT 2
14980: MOD
14981: PUSH
14982: LD_INT 1
14984: PLUS
14985: ARRAY
14986: PPUSH
14987: LD_INT 0
14989: PPUSH
14990: CALL_OW 49
// end ;
14994: GO 14929
14996: POP
14997: POP
// for i = 1 to 6 do
14998: LD_ADDR_VAR 0 2
15002: PUSH
15003: DOUBLE
15004: LD_INT 1
15006: DEC
15007: ST_TO_ADDR
15008: LD_INT 6
15010: PUSH
15011: FOR_TO
15012: IFFALSE 15057
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15014: LD_INT 0
15016: PPUSH
15017: LD_INT 6
15019: PUSH
15020: LD_OWVAR 67
15024: PLUS
15025: PPUSH
15026: CALL_OW 381
// un := CreateHuman ;
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: CALL_OW 44
15039: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15040: LD_VAR 0 4
15044: PPUSH
15045: LD_INT 32
15047: PPUSH
15048: LD_INT 0
15050: PPUSH
15051: CALL_OW 49
// end ;
15055: GO 15011
15057: POP
15058: POP
// for i = 1 to 3 do
15059: LD_ADDR_VAR 0 2
15063: PUSH
15064: DOUBLE
15065: LD_INT 1
15067: DEC
15068: ST_TO_ADDR
15069: LD_INT 3
15071: PUSH
15072: FOR_TO
15073: IFFALSE 15121
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15075: LD_INT 0
15077: PPUSH
15078: LD_INT 8
15080: PPUSH
15081: LD_INT 6
15083: PUSH
15084: LD_OWVAR 67
15088: PLUS
15089: PPUSH
15090: CALL_OW 380
// un := CreateHuman ;
15094: LD_ADDR_VAR 0 4
15098: PUSH
15099: CALL_OW 44
15103: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15104: LD_VAR 0 4
15108: PPUSH
15109: LD_INT 32
15111: PPUSH
15112: LD_INT 0
15114: PPUSH
15115: CALL_OW 49
// end ;
15119: GO 15072
15121: POP
15122: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15123: LD_ADDR_VAR 0 2
15127: PUSH
15128: DOUBLE
15129: LD_INT 1
15131: DEC
15132: ST_TO_ADDR
15133: LD_INT 2
15135: PUSH
15136: LD_INT 3
15138: PUSH
15139: LD_INT 4
15141: PUSH
15142: LD_INT 4
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: PUSH
15151: LD_OWVAR 67
15155: ARRAY
15156: PUSH
15157: FOR_TO
15158: IFFALSE 15248
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15160: LD_INT 14
15162: PPUSH
15163: LD_INT 2
15165: PPUSH
15166: LD_INT 1
15168: PPUSH
15169: LD_INT 28
15171: PPUSH
15172: LD_INT 80
15174: PPUSH
15175: CALL 72344 0 5
// veh := CreateVehicle ;
15179: LD_ADDR_VAR 0 3
15183: PUSH
15184: CALL_OW 45
15188: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: LD_INT 3
15196: PPUSH
15197: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15201: LD_VAR 0 3
15205: PPUSH
15206: LD_INT 29
15208: PPUSH
15209: LD_INT 0
15211: PPUSH
15212: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15216: LD_INT 0
15218: PPUSH
15219: LD_INT 6
15221: PUSH
15222: LD_OWVAR 67
15226: PLUS
15227: PPUSH
15228: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15232: CALL_OW 44
15236: PPUSH
15237: LD_VAR 0 3
15241: PPUSH
15242: CALL_OW 52
// end ;
15246: GO 15157
15248: POP
15249: POP
// for i = 1 to 5 + Difficulty do
15250: LD_ADDR_VAR 0 2
15254: PUSH
15255: DOUBLE
15256: LD_INT 1
15258: DEC
15259: ST_TO_ADDR
15260: LD_INT 5
15262: PUSH
15263: LD_OWVAR 67
15267: PLUS
15268: PUSH
15269: FOR_TO
15270: IFFALSE 15397
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15272: LD_INT 14
15274: PPUSH
15275: LD_INT 1
15277: PPUSH
15278: LD_INT 3
15280: PPUSH
15281: CALL_OW 12
15285: PPUSH
15286: LD_INT 1
15288: PPUSH
15289: LD_INT 28
15291: PUSH
15292: LD_INT 26
15294: PUSH
15295: LD_INT 27
15297: PUSH
15298: LD_INT 25
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: PUSH
15307: LD_VAR 0 2
15311: PUSH
15312: LD_INT 4
15314: MOD
15315: PUSH
15316: LD_INT 1
15318: PLUS
15319: ARRAY
15320: PPUSH
15321: LD_INT 80
15323: PPUSH
15324: CALL 72344 0 5
// veh := CreateVehicle ;
15328: LD_ADDR_VAR 0 3
15332: PUSH
15333: CALL_OW 45
15337: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15338: LD_VAR 0 3
15342: PPUSH
15343: LD_INT 4
15345: PPUSH
15346: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15350: LD_VAR 0 3
15354: PPUSH
15355: LD_INT 28
15357: PPUSH
15358: LD_INT 0
15360: PPUSH
15361: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15365: LD_INT 0
15367: PPUSH
15368: LD_INT 6
15370: PUSH
15371: LD_OWVAR 67
15375: PLUS
15376: PPUSH
15377: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15381: CALL_OW 44
15385: PPUSH
15386: LD_VAR 0 3
15390: PPUSH
15391: CALL_OW 52
// end ;
15395: GO 15269
15397: POP
15398: POP
// for i = 1 to Difficulty do
15399: LD_ADDR_VAR 0 2
15403: PUSH
15404: DOUBLE
15405: LD_INT 1
15407: DEC
15408: ST_TO_ADDR
15409: LD_OWVAR 67
15413: PUSH
15414: FOR_TO
15415: IFFALSE 15475
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15417: LD_INT 14
15419: PPUSH
15420: LD_INT 3
15422: PPUSH
15423: LD_INT 5
15425: PPUSH
15426: LD_INT 29
15428: PPUSH
15429: LD_INT 80
15431: PPUSH
15432: CALL 72344 0 5
// veh := CreateVehicle ;
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: CALL_OW 45
15445: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15446: LD_VAR 0 3
15450: PPUSH
15451: LD_INT 4
15453: PPUSH
15454: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15458: LD_VAR 0 3
15462: PPUSH
15463: LD_INT 28
15465: PPUSH
15466: LD_INT 0
15468: PPUSH
15469: CALL_OW 49
// end ;
15473: GO 15414
15475: POP
15476: POP
// end ;
15477: LD_VAR 0 1
15481: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15482: LD_INT 22
15484: PUSH
15485: LD_INT 2
15487: PUSH
15488: EMPTY
15489: LIST
15490: LIST
15491: PPUSH
15492: CALL_OW 69
15496: IFFALSE 15875
15498: GO 15500
15500: DISABLE
15501: LD_INT 0
15503: PPUSH
15504: PPUSH
15505: PPUSH
15506: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15507: LD_ADDR_VAR 0 3
15511: PUSH
15512: LD_INT 22
15514: PUSH
15515: LD_INT 2
15517: PUSH
15518: EMPTY
15519: LIST
15520: LIST
15521: PUSH
15522: LD_INT 25
15524: PUSH
15525: LD_INT 4
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL_OW 69
15540: PUSH
15541: LD_EXP 96
15545: DIFF
15546: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 2
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: PUSH
15567: LD_EXP 96
15571: PUSH
15572: LD_VAR 0 3
15576: UNION
15577: DIFF
15578: ST_TO_ADDR
// if Khatam then
15579: LD_EXP 96
15583: IFFALSE 15600
// ComMoveXY ( Khatam , 211 , 92 ) ;
15585: LD_EXP 96
15589: PPUSH
15590: LD_INT 211
15592: PPUSH
15593: LD_INT 92
15595: PPUSH
15596: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15600: LD_INT 197
15602: PPUSH
15603: LD_INT 80
15605: PPUSH
15606: LD_INT 2
15608: PPUSH
15609: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15613: LD_INT 213
15615: PPUSH
15616: LD_INT 90
15618: PPUSH
15619: LD_INT 2
15621: PPUSH
15622: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15626: LD_INT 215
15628: PPUSH
15629: LD_INT 129
15631: PPUSH
15632: LD_INT 2
15634: PPUSH
15635: CALL_OW 441
// if sci then
15639: LD_VAR 0 3
15643: IFFALSE 15664
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15645: LD_VAR 0 3
15649: PUSH
15650: LD_INT 1
15652: ARRAY
15653: PPUSH
15654: LD_INT 197
15656: PPUSH
15657: LD_INT 80
15659: PPUSH
15660: CALL_OW 158
// if sci > 1 then
15664: LD_VAR 0 3
15668: PUSH
15669: LD_INT 1
15671: GREATER
15672: IFFALSE 15693
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15674: LD_VAR 0 3
15678: PUSH
15679: LD_INT 2
15681: ARRAY
15682: PPUSH
15683: LD_INT 213
15685: PPUSH
15686: LD_INT 90
15688: PPUSH
15689: CALL_OW 158
// if sci > 2 then
15693: LD_VAR 0 3
15697: PUSH
15698: LD_INT 2
15700: GREATER
15701: IFFALSE 15722
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15703: LD_VAR 0 3
15707: PUSH
15708: LD_INT 3
15710: ARRAY
15711: PPUSH
15712: LD_INT 215
15714: PPUSH
15715: LD_INT 129
15717: PPUSH
15718: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15722: LD_VAR 0 2
15726: PPUSH
15727: LD_INT 195
15729: PPUSH
15730: LD_INT 102
15732: PPUSH
15733: CALL_OW 114
// wait ( 0 0$5 ) ;
15737: LD_INT 175
15739: PPUSH
15740: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15744: LD_INT 70
15746: PPUSH
15747: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15751: LD_ADDR_VAR 0 4
15755: PUSH
15756: LD_INT 92
15758: PUSH
15759: LD_INT 195
15761: PUSH
15762: LD_INT 102
15764: PUSH
15765: LD_INT 36
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: PUSH
15774: LD_INT 22
15776: PUSH
15777: LD_INT 1
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PUSH
15784: EMPTY
15785: LIST
15786: LIST
15787: PPUSH
15788: CALL_OW 69
15792: ST_TO_ADDR
// for i in tmp do
15793: LD_ADDR_VAR 0 1
15797: PUSH
15798: LD_VAR 0 2
15802: PUSH
15803: FOR_IN
15804: IFFALSE 15855
// if enemy then
15806: LD_VAR 0 4
15810: IFFALSE 15838
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15812: LD_VAR 0 1
15816: PPUSH
15817: LD_VAR 0 4
15821: PPUSH
15822: LD_VAR 0 1
15826: PPUSH
15827: CALL_OW 74
15831: PPUSH
15832: CALL_OW 115
15836: GO 15853
// ComAgressiveMove ( i , 195 , 102 ) ;
15838: LD_VAR 0 1
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
15853: GO 15803
15855: POP
15856: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15857: LD_VAR 0 2
15861: PPUSH
15862: LD_INT 50
15864: PUSH
15865: EMPTY
15866: LIST
15867: PPUSH
15868: CALL_OW 72
15872: NOT
15873: IFFALSE 15744
// end ; end_of_file
15875: PPOPN 4
15877: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15878: LD_INT 0
15880: PPUSH
15881: PPUSH
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
15887: PPUSH
15888: PPUSH
// Video ( true ) ;
15889: LD_INT 1
15891: PPUSH
15892: CALL 104750 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15896: LD_ADDR_VAR 0 5
15900: PUSH
15901: LD_INT 7
15903: PPUSH
15904: LD_INT 0
15906: PPUSH
15907: CALL_OW 517
15911: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15912: LD_ADDR_VAR 0 2
15916: PUSH
15917: DOUBLE
15918: LD_INT 1
15920: DEC
15921: ST_TO_ADDR
15922: LD_VAR 0 5
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PUSH
15931: FOR_TO
15932: IFFALSE 15977
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15934: LD_VAR 0 5
15938: PUSH
15939: LD_INT 1
15941: ARRAY
15942: PUSH
15943: LD_VAR 0 2
15947: ARRAY
15948: PPUSH
15949: LD_VAR 0 5
15953: PUSH
15954: LD_INT 2
15956: ARRAY
15957: PUSH
15958: LD_VAR 0 2
15962: ARRAY
15963: PPUSH
15964: LD_INT 1
15966: PPUSH
15967: LD_INT 15
15969: NEG
15970: PPUSH
15971: CALL 104664 0 4
15975: GO 15931
15977: POP
15978: POP
// CenterNowOnUnits ( Powell ) ;
15979: LD_EXP 59
15983: PPUSH
15984: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15988: LD_ADDR_VAR 0 5
15992: PUSH
15993: LD_EXP 57
15997: PUSH
15998: EMPTY
15999: LIST
16000: ST_TO_ADDR
// if GirlNewVeh then
16001: LD_EXP 58
16005: IFFALSE 16023
// tmp := tmp ^ GirlNewVeh ;
16007: LD_ADDR_VAR 0 5
16011: PUSH
16012: LD_VAR 0 5
16016: PUSH
16017: LD_EXP 58
16021: ADD
16022: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16023: LD_VAR 0 5
16027: PPUSH
16028: LD_INT 60
16030: PPUSH
16031: LD_INT 109
16033: PPUSH
16034: CALL_OW 111
// if KappaStatus then
16038: LD_EXP 2
16042: IFFALSE 16094
// begin Say ( JMM , D1nT-JMM-1 ) ;
16044: LD_EXP 40
16048: PPUSH
16049: LD_STRING D1nT-JMM-1
16051: PPUSH
16052: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16056: LD_EXP 59
16060: PPUSH
16061: LD_STRING D1T-Pow-1
16063: PPUSH
16064: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16068: LD_EXP 40
16072: PPUSH
16073: LD_STRING D1T-JMM-2
16075: PPUSH
16076: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16080: LD_EXP 59
16084: PPUSH
16085: LD_STRING D1T-Pow-2
16087: PPUSH
16088: CALL_OW 88
// end else
16092: GO 16300
// if JMMGirlStatus then
16094: LD_EXP 6
16098: IFFALSE 16243
// begin Say ( JMM , D1T-JMM-1 ) ;
16100: LD_EXP 40
16104: PPUSH
16105: LD_STRING D1T-JMM-1
16107: PPUSH
16108: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16112: LD_EXP 59
16116: PPUSH
16117: LD_STRING D1T-Pow-1
16119: PPUSH
16120: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16124: LD_EXP 40
16128: PPUSH
16129: LD_STRING D1T-JMM-3
16131: PPUSH
16132: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16136: LD_EXP 59
16140: PPUSH
16141: LD_STRING D1T-Pow-3
16143: PPUSH
16144: CALL_OW 88
// if JMMGirl then
16148: LD_EXP 7
16152: IFFALSE 16241
// begin case JMMGirl of 1 :
16154: LD_EXP 7
16158: PUSH
16159: LD_INT 1
16161: DOUBLE
16162: EQUAL
16163: IFTRUE 16167
16165: GO 16182
16167: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16168: LD_EXP 41
16172: PPUSH
16173: LD_STRING D1T-Joan-3
16175: PPUSH
16176: CALL_OW 88
16180: GO 16229
16182: LD_INT 2
16184: DOUBLE
16185: EQUAL
16186: IFTRUE 16190
16188: GO 16205
16190: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16191: LD_EXP 43
16195: PPUSH
16196: LD_STRING D1T-Lisa-3
16198: PPUSH
16199: CALL_OW 88
16203: GO 16229
16205: LD_INT 3
16207: DOUBLE
16208: EQUAL
16209: IFTRUE 16213
16211: GO 16228
16213: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16214: LD_EXP 55
16218: PPUSH
16219: LD_STRING D1T-Con-3
16221: PPUSH
16222: CALL_OW 88
16226: GO 16229
16228: POP
// Say ( Powell , D1T-Pow-4 ) ;
16229: LD_EXP 59
16233: PPUSH
16234: LD_STRING D1T-Pow-4
16236: PPUSH
16237: CALL_OW 88
// end ; end else
16241: GO 16300
// if not FastEnd then
16243: LD_EXP 11
16247: NOT
16248: IFFALSE 16276
// begin Say ( JMM , D1T-JMM-4 ) ;
16250: LD_EXP 40
16254: PPUSH
16255: LD_STRING D1T-JMM-4
16257: PPUSH
16258: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16262: LD_EXP 59
16266: PPUSH
16267: LD_STRING D1T-Pow-5
16269: PPUSH
16270: CALL_OW 88
// end else
16274: GO 16300
// begin Say ( JMM , D1nT-JMM-1 ) ;
16276: LD_EXP 40
16280: PPUSH
16281: LD_STRING D1nT-JMM-1
16283: PPUSH
16284: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16288: LD_EXP 59
16292: PPUSH
16293: LD_STRING D1nT-Pow-1
16295: PPUSH
16296: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16300: LD_INT 3
16302: PPUSH
16303: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16307: LD_EXP 57
16311: PPUSH
16312: CALL_OW 314
16316: NOT
16317: IFFALSE 16300
// ComExitVehicle ( JMM ) ;
16319: LD_EXP 40
16323: PPUSH
16324: CALL_OW 121
// repeat wait ( 3 ) ;
16328: LD_INT 3
16330: PPUSH
16331: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16335: LD_EXP 40
16339: PPUSH
16340: CALL_OW 310
16344: NOT
16345: IFFALSE 16328
// ComMoveXY ( JMM , 60 , 94 ) ;
16347: LD_EXP 40
16351: PPUSH
16352: LD_INT 60
16354: PPUSH
16355: LD_INT 94
16357: PPUSH
16358: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16362: LD_EXP 40
16366: PPUSH
16367: LD_EXP 59
16371: PPUSH
16372: CALL_OW 179
// if Joan then
16376: LD_EXP 41
16380: IFFALSE 16434
// begin ComExitVehicle ( Joan ) ;
16382: LD_EXP 41
16386: PPUSH
16387: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16391: LD_EXP 41
16395: PPUSH
16396: LD_INT 35
16398: PPUSH
16399: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16403: LD_EXP 41
16407: PPUSH
16408: LD_INT 65
16410: PPUSH
16411: LD_INT 104
16413: PPUSH
16414: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16418: LD_EXP 41
16422: PPUSH
16423: LD_EXP 40
16427: PPUSH
16428: CALL_OW 179
// end else
16432: GO 16568
// if Lisa and JMMGirl = 2 then
16434: LD_EXP 43
16438: PUSH
16439: LD_EXP 7
16443: PUSH
16444: LD_INT 2
16446: EQUAL
16447: AND
16448: IFFALSE 16502
// begin ComExitVehicle ( Lisa ) ;
16450: LD_EXP 43
16454: PPUSH
16455: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16459: LD_EXP 43
16463: PPUSH
16464: LD_INT 35
16466: PPUSH
16467: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16471: LD_EXP 43
16475: PPUSH
16476: LD_INT 65
16478: PPUSH
16479: LD_INT 104
16481: PPUSH
16482: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16486: LD_EXP 43
16490: PPUSH
16491: LD_EXP 40
16495: PPUSH
16496: CALL_OW 179
// end else
16500: GO 16568
// if Connie and JMMGirl = 3 then
16502: LD_EXP 55
16506: PUSH
16507: LD_EXP 7
16511: PUSH
16512: LD_INT 3
16514: EQUAL
16515: AND
16516: IFFALSE 16568
// begin ComExitVehicle ( Connie ) ;
16518: LD_EXP 55
16522: PPUSH
16523: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16527: LD_EXP 55
16531: PPUSH
16532: LD_INT 35
16534: PPUSH
16535: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16539: LD_EXP 55
16543: PPUSH
16544: LD_INT 65
16546: PPUSH
16547: LD_INT 104
16549: PPUSH
16550: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16554: LD_EXP 55
16558: PPUSH
16559: LD_EXP 40
16563: PPUSH
16564: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16568: LD_INT 35
16570: PPUSH
16571: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16575: LD_EXP 40
16579: PPUSH
16580: LD_EXP 59
16584: PPUSH
16585: CALL_OW 296
16589: PUSH
16590: LD_INT 8
16592: LESS
16593: IFFALSE 16568
// wait ( 0 0$0.5 ) ;
16595: LD_INT 18
16597: PPUSH
16598: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16602: LD_EXP 40
16606: PPUSH
16607: LD_STRING D1-JMM-1
16609: PPUSH
16610: CALL_OW 88
// async ;
16614: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16615: LD_EXP 59
16619: PPUSH
16620: LD_STRING D1-Pow-1
16622: PPUSH
16623: CALL_OW 88
// if not dialogue_skipped then
16627: LD_OWVAR 59
16631: NOT
16632: IFFALSE 16641
// wait ( 0 0$2 ) ;
16634: LD_INT 70
16636: PPUSH
16637: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16641: LD_INT 170
16643: PPUSH
16644: LD_INT 99
16646: PPUSH
16647: LD_INT 1
16649: PPUSH
16650: LD_INT 6
16652: NEG
16653: PPUSH
16654: CALL 104664 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16658: LD_INT 174
16660: PPUSH
16661: LD_INT 115
16663: PPUSH
16664: LD_INT 1
16666: PPUSH
16667: LD_INT 6
16669: NEG
16670: PPUSH
16671: CALL 104664 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16675: LD_INT 169
16677: PPUSH
16678: LD_INT 71
16680: PPUSH
16681: LD_INT 1
16683: PPUSH
16684: LD_INT 6
16686: NEG
16687: PPUSH
16688: CALL 104664 0 4
// if not dialogue_skipped then
16692: LD_OWVAR 59
16696: NOT
16697: IFFALSE 16716
// begin CenterOnXY ( 170 , 99 ) ;
16699: LD_INT 170
16701: PPUSH
16702: LD_INT 99
16704: PPUSH
16705: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16709: LD_INT 80
16711: PPUSH
16712: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16716: LD_INT 75
16718: PPUSH
16719: LD_INT 53
16721: PPUSH
16722: LD_INT 1
16724: PPUSH
16725: LD_INT 9
16727: NEG
16728: PPUSH
16729: CALL 104664 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16733: LD_INT 54
16735: PPUSH
16736: LD_INT 42
16738: PPUSH
16739: LD_INT 1
16741: PPUSH
16742: LD_INT 9
16744: NEG
16745: PPUSH
16746: CALL 104664 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16750: LD_INT 62
16752: PPUSH
16753: LD_INT 51
16755: PPUSH
16756: LD_INT 1
16758: PPUSH
16759: LD_INT 9
16761: NEG
16762: PPUSH
16763: CALL 104664 0 4
// if not dialogue_skipped then
16767: LD_OWVAR 59
16771: NOT
16772: IFFALSE 16791
// begin CenterOnXY ( 75 , 53 ) ;
16774: LD_INT 75
16776: PPUSH
16777: LD_INT 53
16779: PPUSH
16780: CALL_OW 84
// wait ( 0 0$4 ) ;
16784: LD_INT 140
16786: PPUSH
16787: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16791: LD_EXP 59
16795: PPUSH
16796: CALL_OW 87
// if not dialogue_skipped then
16800: LD_OWVAR 59
16804: NOT
16805: IFFALSE 16814
// wait ( 0 0$2 ) ;
16807: LD_INT 70
16809: PPUSH
16810: CALL_OW 67
// sync ;
16814: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16815: LD_EXP 40
16819: PPUSH
16820: LD_STRING D1-JMM-2
16822: PPUSH
16823: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16827: LD_EXP 59
16831: PPUSH
16832: LD_STRING D1-Pow-2
16834: PPUSH
16835: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16839: LD_EXP 40
16843: PPUSH
16844: LD_STRING D1-JMM-3
16846: PPUSH
16847: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16851: LD_EXP 59
16855: PPUSH
16856: LD_STRING D1-Pow-3
16858: PPUSH
16859: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16863: LD_EXP 40
16867: PPUSH
16868: LD_STRING D1-JMM-4
16870: PPUSH
16871: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16875: LD_EXP 59
16879: PPUSH
16880: LD_STRING D1-Pow-4
16882: PPUSH
16883: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16887: LD_EXP 40
16891: PPUSH
16892: LD_STRING D1-JMM-5
16894: PPUSH
16895: CALL_OW 88
// async ;
16899: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16900: LD_EXP 59
16904: PPUSH
16905: LD_STRING D1-Pow-5
16907: PPUSH
16908: CALL_OW 88
// if not dialogue_skipped then
16912: LD_OWVAR 59
16916: NOT
16917: IFFALSE 16926
// wait ( 0 0$3.6 ) ;
16919: LD_INT 126
16921: PPUSH
16922: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16926: LD_INT 134
16928: PPUSH
16929: LD_INT 210
16931: PPUSH
16932: LD_INT 1
16934: PPUSH
16935: LD_INT 11
16937: NEG
16938: PPUSH
16939: CALL 104664 0 4
// if not dialogue_skipped then
16943: LD_OWVAR 59
16947: NOT
16948: IFFALSE 16967
// begin CenterOnXY ( 134 , 210 ) ;
16950: LD_INT 134
16952: PPUSH
16953: LD_INT 210
16955: PPUSH
16956: CALL_OW 84
// wait ( 0 0$2 ) ;
16960: LD_INT 70
16962: PPUSH
16963: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16967: LD_INT 101
16969: PPUSH
16970: LD_INT 159
16972: PPUSH
16973: LD_INT 1
16975: PPUSH
16976: LD_INT 10
16978: NEG
16979: PPUSH
16980: CALL 104664 0 4
// if not dialogue_skipped then
16984: LD_OWVAR 59
16988: NOT
16989: IFFALSE 17008
// begin CenterOnXY ( 101 , 159 ) ;
16991: LD_INT 101
16993: PPUSH
16994: LD_INT 159
16996: PPUSH
16997: CALL_OW 84
// wait ( 0 0$2 ) ;
17001: LD_INT 70
17003: PPUSH
17004: CALL_OW 67
// end ; sync ;
17008: SYNC
// CenterNowOnUnits ( Powell ) ;
17009: LD_EXP 59
17013: PPUSH
17014: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17018: LD_ADDR_VAR 0 6
17022: PUSH
17023: LD_INT 1
17025: PUSH
17026: LD_INT 2
17028: PUSH
17029: LD_INT 3
17031: PUSH
17032: LD_INT 4
17034: PUSH
17035: LD_INT 5
17037: PUSH
17038: LD_INT 6
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: LIST
17045: LIST
17046: LIST
17047: LIST
17048: ST_TO_ADDR
// if not dialogue_skipped then
17049: LD_OWVAR 59
17053: NOT
17054: IFFALSE 17223
// begin game_speed := 4 ;
17056: LD_ADDR_OWVAR 65
17060: PUSH
17061: LD_INT 4
17063: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17064: LD_INT 210
17066: PPUSH
17067: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17071: LD_ADDR_VAR 0 7
17075: PUSH
17076: LD_STRING Q1
17078: PPUSH
17079: LD_VAR 0 6
17083: PPUSH
17084: CALL_OW 98
17088: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17089: LD_ADDR_VAR 0 7
17093: PUSH
17094: LD_STRING Q1
17096: PPUSH
17097: LD_VAR 0 6
17101: PPUSH
17102: CALL_OW 98
17106: ST_TO_ADDR
// options := options diff dec ;
17107: LD_ADDR_VAR 0 6
17111: PUSH
17112: LD_VAR 0 6
17116: PUSH
17117: LD_VAR 0 7
17121: DIFF
17122: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17123: LD_VAR 0 7
17127: PPUSH
17128: LD_VAR 0 6
17132: PPUSH
17133: CALL 18739 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17137: LD_VAR 0 7
17141: PUSH
17142: LD_INT 5
17144: PUSH
17145: LD_INT 6
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: IN
17152: PUSH
17153: LD_VAR 0 6
17157: PUSH
17158: LD_INT 2
17160: EQUAL
17161: OR
17162: IFFALSE 17089
// if not ( dec in [ 5 , 6 ] ) then
17164: LD_VAR 0 7
17168: PUSH
17169: LD_INT 5
17171: PUSH
17172: LD_INT 6
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: IN
17179: NOT
17180: IFFALSE 17223
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17182: LD_ADDR_VAR 0 7
17186: PUSH
17187: LD_STRING Q1a
17189: PPUSH
17190: LD_INT 1
17192: PUSH
17193: LD_INT 2
17195: PUSH
17196: EMPTY
17197: LIST
17198: LIST
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17205: LD_VAR 0 7
17209: PUSH
17210: LD_INT 4
17212: PLUS
17213: PPUSH
17214: LD_VAR 0 6
17218: PPUSH
17219: CALL 18739 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17223: LD_INT 81
17225: PPUSH
17226: LD_INT 127
17228: PPUSH
17229: CALL_OW 84
// amount := 8 ;
17233: LD_ADDR_VAR 0 8
17237: PUSH
17238: LD_INT 8
17240: ST_TO_ADDR
// macmilan_squad := [ ] ;
17241: LD_ADDR_VAR 0 9
17245: PUSH
17246: EMPTY
17247: ST_TO_ADDR
// if vip < amount then
17248: LD_EXP 60
17252: PUSH
17253: LD_VAR 0 8
17257: LESS
17258: IFFALSE 17302
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17260: LD_ADDR_VAR 0 5
17264: PUSH
17265: LD_EXP 60
17269: PUSH
17270: LD_INT 22
17272: PUSH
17273: LD_INT 4
17275: PUSH
17276: EMPTY
17277: LIST
17278: LIST
17279: PUSH
17280: LD_INT 21
17282: PUSH
17283: LD_INT 1
17285: PUSH
17286: EMPTY
17287: LIST
17288: LIST
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PPUSH
17294: CALL_OW 69
17298: UNION
17299: ST_TO_ADDR
17300: GO 17312
// tmp := vip ;
17302: LD_ADDR_VAR 0 5
17306: PUSH
17307: LD_EXP 60
17311: ST_TO_ADDR
// tmp := tmp diff Powell ;
17312: LD_ADDR_VAR 0 5
17316: PUSH
17317: LD_VAR 0 5
17321: PUSH
17322: LD_EXP 59
17326: DIFF
17327: ST_TO_ADDR
// if tmp < amount then
17328: LD_VAR 0 5
17332: PUSH
17333: LD_VAR 0 8
17337: LESS
17338: IFFALSE 17350
// amount := tmp ;
17340: LD_ADDR_VAR 0 8
17344: PUSH
17345: LD_VAR 0 5
17349: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17350: LD_VAR 0 5
17354: PUSH
17355: LD_INT 1
17357: ARRAY
17358: PPUSH
17359: CALL_OW 257
17363: PUSH
17364: LD_INT 2
17366: NONEQUAL
17367: IFFALSE 17465
// begin if IsInUnit ( tmp [ 1 ] ) then
17369: LD_VAR 0 5
17373: PUSH
17374: LD_INT 1
17376: ARRAY
17377: PPUSH
17378: CALL_OW 310
17382: IFFALSE 17397
// ComExitBuilding ( tmp [ 1 ] ) ;
17384: LD_VAR 0 5
17388: PUSH
17389: LD_INT 1
17391: ARRAY
17392: PPUSH
17393: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17397: LD_INT 387
17399: PPUSH
17400: CALL_OW 313
17404: PUSH
17405: LD_INT 6
17407: EQUAL
17408: IFFALSE 17433
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17410: LD_INT 387
17412: PPUSH
17413: CALL_OW 313
17417: PUSH
17418: LD_INT 1
17420: ARRAY
17421: PPUSH
17422: CALL_OW 122
// wait ( 3 ) ;
17426: LD_INT 3
17428: PPUSH
17429: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17433: LD_VAR 0 5
17437: PUSH
17438: LD_INT 1
17440: ARRAY
17441: PPUSH
17442: LD_INT 387
17444: PPUSH
17445: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17449: LD_VAR 0 5
17453: PUSH
17454: LD_INT 1
17456: ARRAY
17457: PPUSH
17458: LD_INT 2
17460: PPUSH
17461: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17465: LD_EXP 40
17469: PPUSH
17470: LD_INT 82
17472: PPUSH
17473: LD_INT 129
17475: PPUSH
17476: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17480: LD_EXP 40
17484: PPUSH
17485: LD_EXP 59
17489: PPUSH
17490: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17494: LD_INT 22
17496: PUSH
17497: LD_INT 1
17499: PUSH
17500: EMPTY
17501: LIST
17502: LIST
17503: PPUSH
17504: CALL_OW 69
17508: PUSH
17509: LD_EXP 40
17513: DIFF
17514: PPUSH
17515: LD_INT 84
17517: PPUSH
17518: LD_INT 128
17520: PPUSH
17521: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17525: LD_INT 22
17527: PUSH
17528: LD_INT 1
17530: PUSH
17531: EMPTY
17532: LIST
17533: LIST
17534: PPUSH
17535: CALL_OW 69
17539: PUSH
17540: LD_EXP 40
17544: DIFF
17545: PPUSH
17546: LD_EXP 40
17550: PPUSH
17551: CALL_OW 179
// for i = 1 to amount do
17555: LD_ADDR_VAR 0 2
17559: PUSH
17560: DOUBLE
17561: LD_INT 1
17563: DEC
17564: ST_TO_ADDR
17565: LD_VAR 0 8
17569: PUSH
17570: FOR_TO
17571: IFFALSE 17739
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17573: LD_ADDR_VAR 0 9
17577: PUSH
17578: LD_VAR 0 9
17582: PUSH
17583: LD_VAR 0 5
17587: PUSH
17588: LD_VAR 0 2
17592: ARRAY
17593: ADD
17594: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17595: LD_VAR 0 5
17599: PUSH
17600: LD_VAR 0 2
17604: ARRAY
17605: PPUSH
17606: CALL_OW 310
17610: IFFALSE 17627
// AddComExitBuilding ( tmp [ i ] ) ;
17612: LD_VAR 0 5
17616: PUSH
17617: LD_VAR 0 2
17621: ARRAY
17622: PPUSH
17623: CALL_OW 182
// if i = 2 and JMMNewVeh then
17627: LD_VAR 0 2
17631: PUSH
17632: LD_INT 2
17634: EQUAL
17635: PUSH
17636: LD_EXP 57
17640: AND
17641: IFFALSE 17699
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17643: LD_VAR 0 5
17647: PUSH
17648: LD_VAR 0 2
17652: ARRAY
17653: PPUSH
17654: LD_EXP 57
17658: PPUSH
17659: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17663: LD_VAR 0 5
17667: PUSH
17668: LD_VAR 0 2
17672: ARRAY
17673: PPUSH
17674: LD_INT 86
17676: PPUSH
17677: LD_INT 133
17679: PPUSH
17680: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17684: LD_VAR 0 5
17688: PUSH
17689: LD_VAR 0 2
17693: ARRAY
17694: PPUSH
17695: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: PPUSH
17710: LD_INT 8
17712: PPUSH
17713: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17717: LD_VAR 0 5
17721: PUSH
17722: LD_VAR 0 2
17726: ARRAY
17727: PPUSH
17728: LD_EXP 40
17732: PPUSH
17733: CALL_OW 179
// end ;
17737: GO 17570
17739: POP
17740: POP
// if GirlNewVeh then
17741: LD_EXP 58
17745: IFFALSE 17759
// SetSide ( GirlNewVeh , 4 ) ;
17747: LD_EXP 58
17751: PPUSH
17752: LD_INT 4
17754: PPUSH
17755: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
17759: LD_INT 35
17761: PPUSH
17762: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17766: LD_VAR 0 9
17770: PPUSH
17771: LD_INT 95
17773: PUSH
17774: LD_INT 9
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 72
17785: PUSH
17786: LD_INT 0
17788: EQUAL
17789: PUSH
17790: LD_EXP 40
17794: PPUSH
17795: LD_INT 9
17797: PPUSH
17798: CALL_OW 308
17802: NOT
17803: AND
17804: IFFALSE 17759
// wait ( 0 0$2 ) ;
17806: LD_INT 70
17808: PPUSH
17809: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17813: LD_VAR 0 9
17817: PPUSH
17818: LD_INT 1
17820: PPUSH
17821: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17825: LD_INT 21
17827: PUSH
17828: LD_INT 2
17830: PUSH
17831: EMPTY
17832: LIST
17833: LIST
17834: PUSH
17835: LD_INT 92
17837: PUSH
17838: LD_INT 83
17840: PUSH
17841: LD_INT 130
17843: PUSH
17844: LD_INT 10
17846: PUSH
17847: EMPTY
17848: LIST
17849: LIST
17850: LIST
17851: LIST
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: PPUSH
17857: CALL_OW 69
17861: PPUSH
17862: LD_INT 1
17864: PPUSH
17865: CALL_OW 235
// tick := 0 ;
17869: LD_ADDR_OWVAR 1
17873: PUSH
17874: LD_INT 0
17876: ST_TO_ADDR
// Video ( false ) ;
17877: LD_INT 0
17879: PPUSH
17880: CALL 104750 0 1
// ChangeMissionObjectives ( M1 ) ;
17884: LD_STRING M1
17886: PPUSH
17887: CALL_OW 337
// SaveForQuickRestart ;
17891: CALL_OW 22
// missionStart := true ;
17895: LD_ADDR_EXP 13
17899: PUSH
17900: LD_INT 1
17902: ST_TO_ADDR
// missionStage := 2 ;
17903: LD_ADDR_EXP 15
17907: PUSH
17908: LD_INT 2
17910: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17911: LD_INT 35
17913: PPUSH
17914: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17918: LD_ADDR_VAR 0 5
17922: PUSH
17923: LD_INT 22
17925: PUSH
17926: LD_INT 4
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PUSH
17933: LD_INT 21
17935: PUSH
17936: LD_INT 1
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: PPUSH
17947: CALL_OW 69
17951: PUSH
17952: LD_EXP 59
17956: DIFF
17957: ST_TO_ADDR
// if not tmp then
17958: LD_VAR 0 5
17962: NOT
17963: IFFALSE 17978
// tmp := [ Powell ] ;
17965: LD_ADDR_VAR 0 5
17969: PUSH
17970: LD_EXP 59
17974: PUSH
17975: EMPTY
17976: LIST
17977: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17978: LD_ADDR_VAR 0 4
17982: PUSH
17983: LD_INT 22
17985: PUSH
17986: LD_INT 4
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 34
17995: PUSH
17996: LD_INT 12
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: PPUSH
18007: CALL_OW 69
18011: PUSH
18012: LD_INT 1
18014: ARRAY
18015: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18016: LD_VAR 0 5
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL_OW 310
18029: IFFALSE 18044
// ComExitBuilding ( tmp [ 1 ] ) ;
18031: LD_VAR 0 5
18035: PUSH
18036: LD_INT 1
18038: ARRAY
18039: PPUSH
18040: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18044: LD_VAR 0 5
18048: PUSH
18049: LD_INT 1
18051: ARRAY
18052: PPUSH
18053: LD_VAR 0 4
18057: PPUSH
18058: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18062: LD_VAR 0 5
18066: PUSH
18067: LD_INT 1
18069: ARRAY
18070: PPUSH
18071: LD_INT 80
18073: PPUSH
18074: LD_INT 136
18076: PPUSH
18077: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18081: LD_VAR 0 5
18085: PUSH
18086: LD_INT 1
18088: ARRAY
18089: PPUSH
18090: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18094: LD_VAR 0 5
18098: PUSH
18099: LD_INT 1
18101: ARRAY
18102: PPUSH
18103: LD_INT 59
18105: PPUSH
18106: LD_INT 112
18108: PPUSH
18109: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18113: LD_VAR 0 5
18117: PUSH
18118: LD_INT 1
18120: ARRAY
18121: PPUSH
18122: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18126: LD_EXP 41
18130: PUSH
18131: LD_EXP 41
18135: PPUSH
18136: CALL_OW 255
18140: PUSH
18141: LD_INT 1
18143: EQUAL
18144: AND
18145: IFFALSE 18171
// begin Say ( Joan , D3W-Joan-1 ) ;
18147: LD_EXP 41
18151: PPUSH
18152: LD_STRING D3W-Joan-1
18154: PPUSH
18155: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18159: LD_EXP 40
18163: PPUSH
18164: LD_STRING D3W-JMM-1
18166: PPUSH
18167: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18171: LD_EXP 43
18175: PUSH
18176: LD_EXP 43
18180: PPUSH
18181: CALL_OW 255
18185: PUSH
18186: LD_INT 1
18188: EQUAL
18189: AND
18190: PUSH
18191: LD_EXP 43
18195: PUSH
18196: LD_EXP 60
18200: IN
18201: NOT
18202: AND
18203: IFFALSE 18229
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18205: LD_EXP 43
18209: PPUSH
18210: LD_STRING D3W-Lisa-1
18212: PPUSH
18213: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18217: LD_EXP 40
18221: PPUSH
18222: LD_STRING D3W-JMM-1
18224: PPUSH
18225: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18229: LD_EXP 55
18233: PUSH
18234: LD_EXP 55
18238: PPUSH
18239: CALL_OW 255
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: AND
18248: IFFALSE 18274
// begin Say ( Connie , D3W-Con-1 ) ;
18250: LD_EXP 55
18254: PPUSH
18255: LD_STRING D3W-Con-1
18257: PPUSH
18258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18262: LD_EXP 40
18266: PPUSH
18267: LD_STRING D3W-JMM-1
18269: PPUSH
18270: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
18274: LD_EXP 43
18278: PUSH
18279: LD_EXP 60
18283: IN
18284: PUSH
18285: LD_EXP 43
18289: PPUSH
18290: CALL_OW 255
18294: PUSH
18295: LD_INT 1
18297: EQUAL
18298: AND
18299: IFFALSE 18315
// Say ( Lisa , D3nW-Lisa-1 ) else
18301: LD_EXP 43
18305: PPUSH
18306: LD_STRING D3nW-Lisa-1
18308: PPUSH
18309: CALL_OW 88
18313: GO 18559
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18315: LD_EXP 46
18319: PUSH
18320: LD_EXP 60
18324: IN
18325: PUSH
18326: LD_EXP 46
18330: PPUSH
18331: CALL_OW 255
18335: PUSH
18336: LD_INT 1
18338: EQUAL
18339: AND
18340: IFFALSE 18356
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18342: LD_EXP 46
18346: PPUSH
18347: LD_STRING D3nW-Cyrus-1
18349: PPUSH
18350: CALL_OW 88
18354: GO 18559
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18356: LD_EXP 45
18360: PUSH
18361: LD_EXP 60
18365: IN
18366: PUSH
18367: LD_EXP 45
18371: PPUSH
18372: CALL_OW 255
18376: PUSH
18377: LD_INT 1
18379: EQUAL
18380: AND
18381: IFFALSE 18397
// Say ( Bobby , D3nW-Bobby-1 ) else
18383: LD_EXP 45
18387: PPUSH
18388: LD_STRING D3nW-Bobby-1
18390: PPUSH
18391: CALL_OW 88
18395: GO 18559
// if Gary in vip and GetSide ( Gary ) = 1 then
18397: LD_EXP 52
18401: PUSH
18402: LD_EXP 60
18406: IN
18407: PUSH
18408: LD_EXP 52
18412: PPUSH
18413: CALL_OW 255
18417: PUSH
18418: LD_INT 1
18420: EQUAL
18421: AND
18422: IFFALSE 18438
// Say ( Gary , D3nW-Gary-1 ) else
18424: LD_EXP 52
18428: PPUSH
18429: LD_STRING D3nW-Gary-1
18431: PPUSH
18432: CALL_OW 88
18436: GO 18559
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18438: LD_EXP 44
18442: PUSH
18443: LD_EXP 60
18447: IN
18448: PUSH
18449: LD_EXP 44
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Donaldson , D3nW-Don-1 ) else
18465: LD_EXP 44
18469: PPUSH
18470: LD_STRING D3nW-Don-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18559
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18479: LD_EXP 51
18483: PUSH
18484: LD_EXP 60
18488: IN
18489: PUSH
18490: LD_EXP 51
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cornel , D3nW-Corn-1 ) else
18506: LD_EXP 51
18510: PPUSH
18511: LD_STRING D3nW-Corn-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18559
// if Frank in vip and GetSide ( Frank ) = 1 then
18520: LD_EXP 53
18524: PUSH
18525: LD_EXP 60
18529: IN
18530: PUSH
18531: LD_EXP 53
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18559
// Say ( Frank , D3nW-Frank-1 ) ;
18547: LD_EXP 53
18551: PPUSH
18552: LD_STRING D3nW-Frank-1
18554: PPUSH
18555: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18559: LD_EXP 60
18563: PPUSH
18564: LD_INT 22
18566: PUSH
18567: LD_INT 1
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PPUSH
18574: CALL_OW 72
18578: IFFALSE 18604
// begin Say ( JMM , D3nW-JMM-1 ) ;
18580: LD_EXP 40
18584: PPUSH
18585: LD_STRING D3nW-JMM-1
18587: PPUSH
18588: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18592: LD_EXP 40
18596: PPUSH
18597: LD_STRING D3nW-JMM-1a
18599: PPUSH
18600: CALL_OW 88
// end ; t := 0 0$00 ;
18604: LD_ADDR_VAR 0 3
18608: PUSH
18609: LD_INT 0
18611: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18612: LD_INT 35
18614: PPUSH
18615: CALL_OW 67
// t := t + 0 0$1 ;
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_VAR 0 3
18628: PUSH
18629: LD_INT 35
18631: PLUS
18632: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18633: LD_INT 59
18635: PPUSH
18636: LD_INT 112
18638: PPUSH
18639: CALL_OW 428
18643: PUSH
18644: LD_VAR 0 3
18648: PUSH
18649: LD_INT 2100
18651: GREATER
18652: OR
18653: IFFALSE 18612
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18655: LD_ADDR_EXP 99
18659: PUSH
18660: LD_EXP 99
18664: PPUSH
18665: LD_INT 4
18667: PPUSH
18668: LD_INT 22
18670: PUSH
18671: LD_INT 4
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: LD_INT 23
18680: PUSH
18681: LD_INT 1
18683: PUSH
18684: EMPTY
18685: LIST
18686: LIST
18687: PUSH
18688: LD_INT 3
18690: PUSH
18691: LD_INT 21
18693: PUSH
18694: LD_INT 2
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: PPUSH
18710: CALL_OW 69
18714: PUSH
18715: LD_EXP 59
18719: DIFF
18720: PPUSH
18721: CALL_OW 1
18725: ST_TO_ADDR
// activeAttacks := true ;
18726: LD_ADDR_EXP 16
18730: PUSH
18731: LD_INT 1
18733: ST_TO_ADDR
// end ;
18734: LD_VAR 0 1
18738: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18739: LD_INT 0
18741: PPUSH
// case question of 1 :
18742: LD_VAR 0 1
18746: PUSH
18747: LD_INT 1
18749: DOUBLE
18750: EQUAL
18751: IFTRUE 18755
18753: GO 18806
18755: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D2Mot-JMM-1
18763: PPUSH
18764: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18768: LD_EXP 59
18772: PPUSH
18773: LD_STRING D2Mot-Pow-1
18775: PPUSH
18776: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18780: LD_EXP 40
18784: PPUSH
18785: LD_STRING D2Mot-JMM-2
18787: PPUSH
18788: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18792: LD_EXP 59
18796: PPUSH
18797: LD_STRING D2Mot-Pow-2
18799: PPUSH
18800: CALL_OW 88
// end ; 2 :
18804: GO 19157
18806: LD_INT 2
18808: DOUBLE
18809: EQUAL
18810: IFTRUE 18814
18812: GO 18890
18814: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18815: LD_EXP 40
18819: PPUSH
18820: LD_STRING D2Rus-JMM-1
18822: PPUSH
18823: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18827: LD_EXP 59
18831: PPUSH
18832: LD_STRING D2Rus-Pow-1
18834: PPUSH
18835: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
18839: LD_EXP 40
18843: PPUSH
18844: LD_STRING D2Rus-JMM-2
18846: PPUSH
18847: CALL_OW 88
// if not ( 3 in list_of_q ) then
18851: LD_INT 3
18853: PUSH
18854: LD_VAR 0 2
18858: IN
18859: NOT
18860: IFFALSE 18876
// Say ( Powell , D2Rus-Pow-2 ) else
18862: LD_EXP 59
18866: PPUSH
18867: LD_STRING D2Rus-Pow-2
18869: PPUSH
18870: CALL_OW 88
18874: GO 18888
// Say ( Powell , D2Rus-Pow-2a ) ;
18876: LD_EXP 59
18880: PPUSH
18881: LD_STRING D2Rus-Pow-2a
18883: PPUSH
18884: CALL_OW 88
// end ; 3 :
18888: GO 19157
18890: LD_INT 3
18892: DOUBLE
18893: EQUAL
18894: IFTRUE 18898
18896: GO 18983
18898: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18899: LD_EXP 40
18903: PPUSH
18904: LD_STRING D2Leg-JMM-1
18906: PPUSH
18907: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18911: LD_EXP 59
18915: PPUSH
18916: LD_STRING D2Leg-Pow-1
18918: PPUSH
18919: CALL_OW 88
// if 2 in list_of_q then
18923: LD_INT 2
18925: PUSH
18926: LD_VAR 0 2
18930: IN
18931: IFFALSE 18957
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18933: LD_EXP 40
18937: PPUSH
18938: LD_STRING D2Leg-JMM-2
18940: PPUSH
18941: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18945: LD_EXP 59
18949: PPUSH
18950: LD_STRING D2Leg-Pow-2
18952: PPUSH
18953: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18957: LD_EXP 40
18961: PPUSH
18962: LD_STRING D2Leg-JMM-3
18964: PPUSH
18965: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18969: LD_EXP 59
18973: PPUSH
18974: LD_STRING D2Leg-Pow-3
18976: PPUSH
18977: CALL_OW 88
// end ; 4 :
18981: GO 19157
18983: LD_INT 4
18985: DOUBLE
18986: EQUAL
18987: IFTRUE 18991
18989: GO 19066
18991: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18992: LD_EXP 40
18996: PPUSH
18997: LD_STRING D2Ar-JMM-1
18999: PPUSH
19000: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19004: LD_EXP 59
19008: PPUSH
19009: LD_STRING D2Ar-Pow-1
19011: PPUSH
19012: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19016: LD_EXP 40
19020: PPUSH
19021: LD_STRING D2Ar-JMM-2
19023: PPUSH
19024: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19028: LD_EXP 59
19032: PPUSH
19033: LD_STRING D2Ar-Pow-2
19035: PPUSH
19036: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19040: LD_EXP 40
19044: PPUSH
19045: LD_STRING D2Ar-JMM-3
19047: PPUSH
19048: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19052: LD_EXP 59
19056: PPUSH
19057: LD_STRING D2Ar-Pow-3
19059: PPUSH
19060: CALL_OW 88
// end ; 5 :
19064: GO 19157
19066: LD_INT 5
19068: DOUBLE
19069: EQUAL
19070: IFTRUE 19074
19072: GO 19089
19074: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19075: LD_EXP 40
19079: PPUSH
19080: LD_STRING D2Conf-JMM-1
19082: PPUSH
19083: CALL_OW 88
19087: GO 19157
19089: LD_INT 6
19091: DOUBLE
19092: EQUAL
19093: IFTRUE 19097
19095: GO 19156
19097: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19098: LD_EXP 40
19102: PPUSH
19103: LD_STRING D2Com-JMM-1
19105: PPUSH
19106: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19110: LD_EXP 59
19114: PPUSH
19115: LD_STRING D2Com-Pow-1
19117: PPUSH
19118: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19122: LD_EXP 40
19126: PPUSH
19127: LD_STRING D2Com-JMM-2
19129: PPUSH
19130: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19134: LD_EXP 59
19138: PPUSH
19139: LD_STRING D2Com-Pow-2
19141: PPUSH
19142: CALL_OW 88
// powellAngerQuery := true ;
19146: LD_ADDR_EXP 36
19150: PUSH
19151: LD_INT 1
19153: ST_TO_ADDR
// end ; end ;
19154: GO 19157
19156: POP
// end ;
19157: LD_VAR 0 3
19161: RET
// every 0 0$5 trigger missionStart do var tmp ;
19162: LD_EXP 13
19166: IFFALSE 19449
19168: GO 19170
19170: DISABLE
19171: LD_INT 0
19173: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19174: LD_INT 35
19176: PPUSH
19177: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19181: LD_INT 14
19183: PPUSH
19184: LD_INT 22
19186: PUSH
19187: LD_INT 1
19189: PUSH
19190: EMPTY
19191: LIST
19192: LIST
19193: PPUSH
19194: CALL_OW 70
19198: PUSH
19199: LD_EXP 15
19203: PUSH
19204: LD_INT 2
19206: PUSH
19207: LD_INT 3
19209: PUSH
19210: LD_INT 4
19212: PUSH
19213: LD_INT 5
19215: PUSH
19216: EMPTY
19217: LIST
19218: LIST
19219: LIST
19220: LIST
19221: IN
19222: AND
19223: IFFALSE 19439
// begin powellAnger := powellAnger + 1 ;
19225: LD_ADDR_EXP 17
19229: PUSH
19230: LD_EXP 17
19234: PUSH
19235: LD_INT 1
19237: PLUS
19238: ST_TO_ADDR
// Video ( true ) ;
19239: LD_INT 1
19241: PPUSH
19242: CALL 104750 0 1
// CenterNowOnUnits ( tmp ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19255: LD_INT 14
19257: PPUSH
19258: LD_INT 22
19260: PUSH
19261: LD_INT 1
19263: PUSH
19264: EMPTY
19265: LIST
19266: LIST
19267: PPUSH
19268: CALL_OW 70
19272: PPUSH
19273: LD_INT 86
19275: PPUSH
19276: LD_INT 133
19278: PPUSH
19279: CALL_OW 111
// async ;
19283: ASYNC
// case powellAnger of 1 :
19284: LD_EXP 17
19288: PUSH
19289: LD_INT 1
19291: DOUBLE
19292: EQUAL
19293: IFTRUE 19297
19295: GO 19312
19297: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19298: LD_EXP 59
19302: PPUSH
19303: LD_STRING DBack1-Pow-1
19305: PPUSH
19306: CALL_OW 88
19310: GO 19359
19312: LD_INT 2
19314: DOUBLE
19315: EQUAL
19316: IFTRUE 19320
19318: GO 19335
19320: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19321: LD_EXP 59
19325: PPUSH
19326: LD_STRING DBack2-Pow-1
19328: PPUSH
19329: CALL_OW 88
19333: GO 19359
19335: LD_INT 3
19337: DOUBLE
19338: EQUAL
19339: IFTRUE 19343
19341: GO 19358
19343: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19344: LD_EXP 59
19348: PPUSH
19349: LD_STRING DBack3-Pow-1
19351: PPUSH
19352: CALL_OW 88
19356: GO 19359
19358: POP
// sync ;
19359: SYNC
// repeat wait ( 0 0$1 ) ;
19360: LD_INT 35
19362: PPUSH
19363: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19367: LD_INT 14
19369: PPUSH
19370: LD_INT 22
19372: PUSH
19373: LD_INT 1
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: PPUSH
19380: CALL_OW 70
19384: PPUSH
19385: LD_INT 86
19387: PPUSH
19388: LD_INT 133
19390: PPUSH
19391: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19395: LD_INT 14
19397: PPUSH
19398: LD_INT 22
19400: PUSH
19401: LD_INT 1
19403: PUSH
19404: EMPTY
19405: LIST
19406: LIST
19407: PPUSH
19408: CALL_OW 70
19412: NOT
19413: IFFALSE 19360
// if powellAnger >= 3 then
19415: LD_EXP 17
19419: PUSH
19420: LD_INT 3
19422: GREATEREQUAL
19423: IFFALSE 19432
// YouLost ( Dismissed ) ;
19425: LD_STRING Dismissed
19427: PPUSH
19428: CALL_OW 104
// Video ( false ) ;
19432: LD_INT 0
19434: PPUSH
19435: CALL 104750 0 1
// end ; until missionStage > 5 ;
19439: LD_EXP 15
19443: PUSH
19444: LD_INT 5
19446: GREATER
19447: IFFALSE 19174
// end ;
19449: PPOPN 1
19451: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19452: LD_EXP 13
19456: PUSH
19457: LD_INT 22
19459: PUSH
19460: LD_INT 4
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: PUSH
19467: LD_INT 21
19469: PUSH
19470: LD_INT 2
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: EMPTY
19478: LIST
19479: LIST
19480: PPUSH
19481: CALL_OW 69
19485: PUSH
19486: LD_INT 4
19488: GREATEREQUAL
19489: AND
19490: PUSH
19491: LD_EXP 15
19495: PUSH
19496: LD_INT 2
19498: EQUAL
19499: AND
19500: IFFALSE 21690
19502: GO 19504
19504: DISABLE
19505: LD_INT 0
19507: PPUSH
19508: PPUSH
19509: PPUSH
19510: PPUSH
19511: PPUSH
19512: PPUSH
19513: PPUSH
19514: PPUSH
19515: PPUSH
19516: PPUSH
// begin missionStage := 3 ;
19517: LD_ADDR_EXP 15
19521: PUSH
19522: LD_INT 3
19524: ST_TO_ADDR
// retreat := false ;
19525: LD_ADDR_VAR 0 4
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19533: LD_ADDR_VAR 0 5
19537: PUSH
19538: LD_INT 22
19540: PUSH
19541: LD_INT 4
19543: PUSH
19544: EMPTY
19545: LIST
19546: LIST
19547: PUSH
19548: LD_INT 30
19550: PUSH
19551: LD_INT 4
19553: PUSH
19554: EMPTY
19555: LIST
19556: LIST
19557: PUSH
19558: EMPTY
19559: LIST
19560: LIST
19561: PPUSH
19562: CALL_OW 69
19566: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19567: LD_ADDR_VAR 0 6
19571: PUSH
19572: LD_INT 22
19574: PUSH
19575: LD_INT 4
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 30
19584: PUSH
19585: LD_INT 5
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: PUSH
19592: EMPTY
19593: LIST
19594: LIST
19595: PPUSH
19596: CALL_OW 69
19600: ST_TO_ADDR
// if not bar then
19601: LD_VAR 0 6
19605: NOT
19606: IFFALSE 19659
// begin repeat wait ( 0 0$1 ) ;
19608: LD_INT 35
19610: PPUSH
19611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19615: LD_INT 22
19617: PUSH
19618: LD_INT 4
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 3
19627: PUSH
19628: LD_INT 57
19630: PUSH
19631: EMPTY
19632: LIST
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 30
19640: PUSH
19641: LD_INT 5
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: EMPTY
19649: LIST
19650: LIST
19651: LIST
19652: PPUSH
19653: CALL_OW 69
19657: IFFALSE 19608
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19659: LD_ADDR_VAR 0 6
19663: PUSH
19664: LD_INT 22
19666: PUSH
19667: LD_INT 4
19669: PUSH
19670: EMPTY
19671: LIST
19672: LIST
19673: PUSH
19674: LD_INT 30
19676: PUSH
19677: LD_INT 5
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PPUSH
19688: CALL_OW 69
19692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19693: LD_INT 35
19695: PPUSH
19696: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19700: LD_EXP 118
19704: PUSH
19705: LD_INT 4
19707: ARRAY
19708: PUSH
19709: LD_INT 4
19711: GREATEREQUAL
19712: IFFALSE 19693
// tmp := [ ] ;
19714: LD_ADDR_VAR 0 2
19718: PUSH
19719: EMPTY
19720: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19721: LD_ADDR_VAR 0 1
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_INT 4
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: PUSH
19736: LD_INT 2
19738: PUSH
19739: LD_INT 25
19741: PUSH
19742: LD_INT 1
19744: PUSH
19745: EMPTY
19746: LIST
19747: LIST
19748: PUSH
19749: LD_INT 25
19751: PUSH
19752: LD_INT 2
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: PUSH
19759: LD_INT 25
19761: PUSH
19762: LD_INT 3
19764: PUSH
19765: EMPTY
19766: LIST
19767: LIST
19768: PUSH
19769: LD_INT 25
19771: PUSH
19772: LD_INT 4
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: LD_INT 25
19781: PUSH
19782: LD_INT 5
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: PUSH
19797: EMPTY
19798: LIST
19799: LIST
19800: PPUSH
19801: CALL_OW 69
19805: PUSH
19806: LD_EXP 59
19810: PUSH
19811: LD_EXP 60
19815: ADD
19816: DIFF
19817: PUSH
19818: FOR_IN
19819: IFFALSE 19883
// if GetTag ( i ) = 1 then
19821: LD_VAR 0 1
19825: PPUSH
19826: CALL_OW 110
19830: PUSH
19831: LD_INT 1
19833: EQUAL
19834: IFFALSE 19858
// tmp := Join ( tmp , i ) else
19836: LD_ADDR_VAR 0 2
19840: PUSH
19841: LD_VAR 0 2
19845: PPUSH
19846: LD_VAR 0 1
19850: PPUSH
19851: CALL 104778 0 2
19855: ST_TO_ADDR
19856: GO 19881
// tmp := Insert ( tmp , 1 , i ) ;
19858: LD_ADDR_VAR 0 2
19862: PUSH
19863: LD_VAR 0 2
19867: PPUSH
19868: LD_INT 1
19870: PPUSH
19871: LD_VAR 0 1
19875: PPUSH
19876: CALL_OW 2
19880: ST_TO_ADDR
19881: GO 19818
19883: POP
19884: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
19885: LD_ADDR_VAR 0 3
19889: PUSH
19890: LD_VAR 0 2
19894: PPUSH
19895: LD_INT 26
19897: PUSH
19898: LD_INT 1
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
19910: LD_ADDR_VAR 0 2
19914: PUSH
19915: LD_VAR 0 2
19919: PUSH
19920: LD_VAR 0 3
19924: DIFF
19925: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
19926: LD_ADDR_VAR 0 2
19930: PUSH
19931: LD_VAR 0 2
19935: PPUSH
19936: LD_INT 3
19938: PPUSH
19939: CALL 103287 0 2
19943: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
19944: LD_ADDR_VAR 0 3
19948: PUSH
19949: LD_VAR 0 3
19953: PPUSH
19954: LD_INT 3
19956: PPUSH
19957: CALL 103287 0 2
19961: ST_TO_ADDR
// for i := 1 to 4 do
19962: LD_ADDR_VAR 0 1
19966: PUSH
19967: DOUBLE
19968: LD_INT 1
19970: DEC
19971: ST_TO_ADDR
19972: LD_INT 4
19974: PUSH
19975: FOR_TO
19976: IFFALSE 20129
// begin if tmp2 then
19978: LD_VAR 0 3
19982: IFFALSE 20050
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19984: LD_ADDR_EXP 18
19988: PUSH
19989: LD_EXP 18
19993: PPUSH
19994: LD_INT 1
19996: PPUSH
19997: LD_EXP 18
20001: PUSH
20002: LD_INT 1
20004: ARRAY
20005: PUSH
20006: LD_VAR 0 3
20010: PUSH
20011: LD_VAR 0 3
20015: ARRAY
20016: ADD
20017: PPUSH
20018: CALL_OW 1
20022: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20023: LD_VAR 0 3
20027: PUSH
20028: LD_VAR 0 3
20032: ARRAY
20033: PPUSH
20034: LD_INT 1
20036: PPUSH
20037: CALL_OW 109
// tmp2 := [ ] ;
20041: LD_ADDR_VAR 0 3
20045: PUSH
20046: EMPTY
20047: ST_TO_ADDR
// end else
20048: GO 20127
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20050: LD_ADDR_EXP 18
20054: PUSH
20055: LD_EXP 18
20059: PPUSH
20060: LD_INT 1
20062: PPUSH
20063: LD_EXP 18
20067: PUSH
20068: LD_INT 1
20070: ARRAY
20071: PUSH
20072: LD_VAR 0 2
20076: PUSH
20077: LD_VAR 0 2
20081: ARRAY
20082: ADD
20083: PPUSH
20084: CALL_OW 1
20088: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20089: LD_VAR 0 2
20093: PUSH
20094: LD_VAR 0 2
20098: ARRAY
20099: PPUSH
20100: LD_INT 1
20102: PPUSH
20103: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20107: LD_ADDR_VAR 0 2
20111: PUSH
20112: LD_VAR 0 2
20116: PPUSH
20117: LD_VAR 0 2
20121: PPUSH
20122: CALL_OW 3
20126: ST_TO_ADDR
// end ; end ;
20127: GO 19975
20129: POP
20130: POP
// if tmp2 then
20131: LD_VAR 0 3
20135: IFFALSE 20153
// tmp := tmp union tmp2 ;
20137: LD_ADDR_VAR 0 2
20141: PUSH
20142: LD_VAR 0 2
20146: PUSH
20147: LD_VAR 0 3
20151: UNION
20152: ST_TO_ADDR
// for i := 1 to 4 do
20153: LD_ADDR_VAR 0 1
20157: PUSH
20158: DOUBLE
20159: LD_INT 1
20161: DEC
20162: ST_TO_ADDR
20163: LD_INT 4
20165: PUSH
20166: FOR_TO
20167: IFFALSE 20216
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20169: LD_ADDR_EXP 18
20173: PUSH
20174: LD_EXP 18
20178: PPUSH
20179: LD_INT 2
20181: PPUSH
20182: LD_EXP 18
20186: PUSH
20187: LD_INT 2
20189: ARRAY
20190: PUSH
20191: LD_VAR 0 2
20195: PUSH
20196: LD_VAR 0 2
20200: PUSH
20201: LD_VAR 0 1
20205: MINUS
20206: ARRAY
20207: ADD
20208: PPUSH
20209: CALL_OW 1
20213: ST_TO_ADDR
20214: GO 20166
20216: POP
20217: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20218: LD_ADDR_EXP 99
20222: PUSH
20223: LD_EXP 99
20227: PPUSH
20228: LD_INT 4
20230: PPUSH
20231: LD_EXP 99
20235: PUSH
20236: LD_INT 4
20238: ARRAY
20239: PUSH
20240: LD_EXP 18
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: DIFF
20249: PPUSH
20250: CALL_OW 1
20254: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20255: LD_VAR 0 5
20259: PUSH
20260: LD_INT 1
20262: ARRAY
20263: PPUSH
20264: CALL_OW 313
20268: IFFALSE 20323
// begin for i in UnitsInside ( arm [ 1 ] ) do
20270: LD_ADDR_VAR 0 1
20274: PUSH
20275: LD_VAR 0 5
20279: PUSH
20280: LD_INT 1
20282: ARRAY
20283: PPUSH
20284: CALL_OW 313
20288: PUSH
20289: FOR_IN
20290: IFFALSE 20321
// begin ComExitBuilding ( i ) ;
20292: LD_VAR 0 1
20296: PPUSH
20297: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20301: LD_VAR 0 1
20305: PPUSH
20306: LD_VAR 0 6
20310: PUSH
20311: LD_INT 1
20313: ARRAY
20314: PPUSH
20315: CALL_OW 180
// end ;
20319: GO 20289
20321: POP
20322: POP
// end ; wait ( 0 0$3 ) ;
20323: LD_INT 105
20325: PPUSH
20326: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20330: LD_ADDR_VAR 0 1
20334: PUSH
20335: LD_EXP 18
20339: PUSH
20340: LD_INT 1
20342: ARRAY
20343: PUSH
20344: FOR_IN
20345: IFFALSE 20452
// begin if IsInUnit ( i ) then
20347: LD_VAR 0 1
20351: PPUSH
20352: CALL_OW 310
20356: IFFALSE 20367
// ComExitBuilding ( i ) ;
20358: LD_VAR 0 1
20362: PPUSH
20363: CALL_OW 122
// if GetClass ( i ) <> 1 then
20367: LD_VAR 0 1
20371: PPUSH
20372: CALL_OW 257
20376: PUSH
20377: LD_INT 1
20379: NONEQUAL
20380: IFFALSE 20421
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20382: LD_VAR 0 1
20386: PPUSH
20387: LD_VAR 0 5
20391: PUSH
20392: LD_INT 1
20394: ARRAY
20395: PPUSH
20396: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20400: LD_VAR 0 1
20404: PPUSH
20405: LD_INT 1
20407: PPUSH
20408: CALL_OW 183
// AddComExitBuilding ( i ) ;
20412: LD_VAR 0 1
20416: PPUSH
20417: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20421: LD_VAR 0 1
20425: PPUSH
20426: LD_INT 60
20428: PPUSH
20429: LD_INT 94
20431: PPUSH
20432: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20436: LD_VAR 0 1
20440: PPUSH
20441: LD_EXP 59
20445: PPUSH
20446: CALL_OW 179
// end ;
20450: GO 20344
20452: POP
20453: POP
// wait ( 0 0$10 ) ;
20454: LD_INT 350
20456: PPUSH
20457: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20461: LD_EXP 59
20465: PPUSH
20466: LD_STRING D4-Pow-1
20468: PPUSH
20469: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20473: LD_ADDR_VAR 0 2
20477: PUSH
20478: LD_EXP 18
20482: PUSH
20483: LD_INT 1
20485: ARRAY
20486: PPUSH
20487: LD_INT 26
20489: PUSH
20490: LD_INT 1
20492: PUSH
20493: EMPTY
20494: LIST
20495: LIST
20496: PPUSH
20497: CALL_OW 72
20501: ST_TO_ADDR
// if tmp then
20502: LD_VAR 0 2
20506: IFFALSE 20524
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20508: LD_VAR 0 2
20512: PUSH
20513: LD_INT 1
20515: ARRAY
20516: PPUSH
20517: LD_STRING D4-Sol1-1
20519: PPUSH
20520: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20524: LD_EXP 59
20528: PPUSH
20529: LD_STRING D4-Pow-2
20531: PPUSH
20532: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20536: LD_ADDR_VAR 0 1
20540: PUSH
20541: DOUBLE
20542: LD_INT 1
20544: DEC
20545: ST_TO_ADDR
20546: LD_EXP 18
20550: PUSH
20551: LD_INT 1
20553: ARRAY
20554: PUSH
20555: FOR_TO
20556: IFFALSE 20649
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20558: LD_EXP 18
20562: PUSH
20563: LD_INT 1
20565: ARRAY
20566: PUSH
20567: LD_VAR 0 1
20571: ARRAY
20572: PPUSH
20573: LD_EXP 118
20577: PUSH
20578: LD_INT 4
20580: ARRAY
20581: PUSH
20582: LD_INT 1
20584: ARRAY
20585: PPUSH
20586: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20590: LD_ADDR_EXP 118
20594: PUSH
20595: LD_EXP 118
20599: PPUSH
20600: LD_INT 4
20602: PPUSH
20603: LD_EXP 118
20607: PUSH
20608: LD_INT 4
20610: ARRAY
20611: PPUSH
20612: LD_INT 1
20614: PPUSH
20615: CALL_OW 3
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20625: LD_INT 8
20627: PPUSH
20628: LD_EXP 18
20632: PUSH
20633: LD_INT 1
20635: ARRAY
20636: PUSH
20637: LD_VAR 0 1
20641: ARRAY
20642: PPUSH
20643: CALL_OW 471
// end ;
20647: GO 20555
20649: POP
20650: POP
// repeat wait ( 0 0$1 ) ;
20651: LD_INT 35
20653: PPUSH
20654: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20658: LD_EXP 18
20662: PUSH
20663: LD_INT 1
20665: ARRAY
20666: PPUSH
20667: LD_INT 55
20669: PUSH
20670: EMPTY
20671: LIST
20672: PPUSH
20673: CALL_OW 72
20677: PUSH
20678: LD_INT 4
20680: GREATEREQUAL
20681: IFFALSE 20651
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20683: LD_EXP 18
20687: PUSH
20688: LD_INT 1
20690: ARRAY
20691: PPUSH
20692: LD_INT 69
20694: PPUSH
20695: LD_INT 94
20697: PPUSH
20698: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20702: LD_EXP 18
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: PPUSH
20711: LD_INT 82
20713: PPUSH
20714: LD_INT 83
20716: PPUSH
20717: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20721: LD_EXP 18
20725: PUSH
20726: LD_INT 1
20728: ARRAY
20729: PPUSH
20730: LD_INT 77
20732: PPUSH
20733: LD_INT 69
20735: PPUSH
20736: CALL_OW 174
// repeat wait ( 3 ) ;
20740: LD_INT 3
20742: PPUSH
20743: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20747: LD_ADDR_VAR 0 1
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_INT 1
20759: ARRAY
20760: PUSH
20761: FOR_IN
20762: IFFALSE 20898
// begin if GetLives ( i ) < 990 then
20764: LD_VAR 0 1
20768: PPUSH
20769: CALL_OW 256
20773: PUSH
20774: LD_INT 990
20776: LESS
20777: IFFALSE 20791
// SetLives ( i , 1000 ) ;
20779: LD_VAR 0 1
20783: PPUSH
20784: LD_INT 1000
20786: PPUSH
20787: CALL_OW 234
// if not IsInUnit ( i ) then
20791: LD_VAR 0 1
20795: PPUSH
20796: CALL_OW 310
20800: NOT
20801: IFFALSE 20896
// begin if not HasTask ( i ) then
20803: LD_VAR 0 1
20807: PPUSH
20808: CALL_OW 314
20812: NOT
20813: IFFALSE 20830
// ComMoveXY ( i , 64 , 93 ) ;
20815: LD_VAR 0 1
20819: PPUSH
20820: LD_INT 64
20822: PPUSH
20823: LD_INT 93
20825: PPUSH
20826: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20830: LD_VAR 0 4
20834: NOT
20835: PUSH
20836: LD_VAR 0 1
20840: PPUSH
20841: CALL_OW 258
20845: PUSH
20846: LD_INT 1
20848: EQUAL
20849: AND
20850: IFFALSE 20896
// begin retreat := true ;
20852: LD_ADDR_VAR 0 4
20856: PUSH
20857: LD_INT 1
20859: ST_TO_ADDR
// SetTag ( i , 2 ) ;
20860: LD_VAR 0 1
20864: PPUSH
20865: LD_INT 2
20867: PPUSH
20868: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
20872: LD_VAR 0 1
20876: PPUSH
20877: LD_STRING D4a-Sol1-1
20879: PPUSH
20880: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
20884: LD_EXP 59
20888: PPUSH
20889: LD_STRING D4a-Pow-1
20891: PPUSH
20892: CALL_OW 88
// end ; end ; end ;
20896: GO 20761
20898: POP
20899: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
20900: LD_EXP 18
20904: PUSH
20905: LD_INT 1
20907: ARRAY
20908: PPUSH
20909: LD_INT 95
20911: PUSH
20912: LD_INT 9
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 3
20921: PUSH
20922: LD_INT 55
20924: PUSH
20925: EMPTY
20926: LIST
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: PUSH
20932: EMPTY
20933: LIST
20934: LIST
20935: PPUSH
20936: CALL_OW 72
20940: PUSH
20941: LD_INT 4
20943: GREATEREQUAL
20944: IFFALSE 20740
// for i in powellSquadAttack [ 1 ] do
20946: LD_ADDR_VAR 0 1
20950: PUSH
20951: LD_EXP 18
20955: PUSH
20956: LD_INT 1
20958: ARRAY
20959: PUSH
20960: FOR_IN
20961: IFFALSE 21097
// begin if GetTag ( i ) = 2 then
20963: LD_VAR 0 1
20967: PPUSH
20968: CALL_OW 110
20972: PUSH
20973: LD_INT 2
20975: EQUAL
20976: IFFALSE 21038
// begin ComMoveXY ( i , 60 , 94 ) ;
20978: LD_VAR 0 1
20982: PPUSH
20983: LD_INT 60
20985: PPUSH
20986: LD_INT 94
20988: PPUSH
20989: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20993: LD_VAR 0 1
20997: PPUSH
20998: LD_EXP 59
21002: PPUSH
21003: CALL_OW 179
// wait ( 0 0$3 ) ;
21007: LD_INT 105
21009: PPUSH
21010: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21014: LD_VAR 0 1
21018: PPUSH
21019: LD_STRING D4a-Sol1-2
21021: PPUSH
21022: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21026: LD_EXP 59
21030: PPUSH
21031: LD_STRING D4a-Pow-2
21033: PPUSH
21034: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 0
21045: PPUSH
21046: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21050: LD_ADDR_EXP 99
21054: PUSH
21055: LD_EXP 99
21059: PPUSH
21060: LD_INT 4
21062: PPUSH
21063: LD_EXP 99
21067: PUSH
21068: LD_INT 4
21070: ARRAY
21071: PUSH
21072: LD_VAR 0 1
21076: UNION
21077: PPUSH
21078: CALL_OW 1
21082: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21083: LD_INT 8
21085: PPUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: CALL_OW 472
// end ;
21095: GO 20960
21097: POP
21098: POP
// wait ( 2 2$00 ) ;
21099: LD_INT 4200
21101: PPUSH
21102: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21106: LD_ADDR_VAR 0 9
21110: PUSH
21111: LD_INT 22
21113: PUSH
21114: LD_INT 4
21116: PUSH
21117: EMPTY
21118: LIST
21119: LIST
21120: PUSH
21121: LD_INT 30
21123: PUSH
21124: LD_INT 32
21126: PUSH
21127: EMPTY
21128: LIST
21129: LIST
21130: PUSH
21131: LD_INT 58
21133: PUSH
21134: EMPTY
21135: LIST
21136: PUSH
21137: EMPTY
21138: LIST
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 69
21146: ST_TO_ADDR
// if tmp then
21147: LD_VAR 0 2
21151: IFFALSE 21391
// begin for i := 1 to tmp do
21153: LD_ADDR_VAR 0 1
21157: PUSH
21158: DOUBLE
21159: LD_INT 1
21161: DEC
21162: ST_TO_ADDR
21163: LD_VAR 0 2
21167: PUSH
21168: FOR_TO
21169: IFFALSE 21382
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21171: LD_ADDR_EXP 99
21175: PUSH
21176: LD_EXP 99
21180: PPUSH
21181: LD_INT 4
21183: PPUSH
21184: LD_EXP 99
21188: PUSH
21189: LD_INT 4
21191: ARRAY
21192: PUSH
21193: LD_VAR 0 2
21197: PUSH
21198: LD_VAR 0 1
21202: ARRAY
21203: DIFF
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21210: LD_ADDR_VAR 0 10
21214: PUSH
21215: LD_VAR 0 2
21219: PUSH
21220: LD_VAR 0 1
21224: ARRAY
21225: PPUSH
21226: CALL_OW 310
21230: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21231: LD_VAR 0 10
21235: PUSH
21236: LD_VAR 0 10
21240: PPUSH
21241: CALL_OW 266
21245: PUSH
21246: LD_INT 32
21248: EQUAL
21249: AND
21250: IFFALSE 21254
// continue ;
21252: GO 21168
// if t then
21254: LD_VAR 0 10
21258: IFFALSE 21275
// ComExitBuilding ( tmp [ i ] ) ;
21260: LD_VAR 0 2
21264: PUSH
21265: LD_VAR 0 1
21269: ARRAY
21270: PPUSH
21271: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21275: LD_VAR 0 2
21279: PUSH
21280: LD_VAR 0 1
21284: ARRAY
21285: PPUSH
21286: LD_VAR 0 5
21290: PUSH
21291: LD_INT 1
21293: ARRAY
21294: PPUSH
21295: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21299: LD_VAR 0 2
21303: PUSH
21304: LD_VAR 0 1
21308: ARRAY
21309: PPUSH
21310: LD_INT 1
21312: PPUSH
21313: CALL_OW 183
// if emptyTowers then
21317: LD_VAR 0 9
21321: IFFALSE 21380
// begin AddComExitBuilding ( tmp [ i ] ) ;
21323: LD_VAR 0 2
21327: PUSH
21328: LD_VAR 0 1
21332: ARRAY
21333: PPUSH
21334: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21338: LD_VAR 0 2
21342: PUSH
21343: LD_VAR 0 1
21347: ARRAY
21348: PPUSH
21349: LD_VAR 0 9
21353: PUSH
21354: LD_INT 1
21356: ARRAY
21357: PPUSH
21358: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21362: LD_ADDR_VAR 0 9
21366: PUSH
21367: LD_VAR 0 9
21371: PPUSH
21372: LD_INT 1
21374: PPUSH
21375: CALL_OW 3
21379: ST_TO_ADDR
// end ; end ;
21380: GO 21168
21382: POP
21383: POP
// wait ( 0 0$30 ) ;
21384: LD_INT 1050
21386: PPUSH
21387: CALL_OW 67
// end ; uc_side := 6 ;
21391: LD_ADDR_OWVAR 20
21395: PUSH
21396: LD_INT 6
21398: ST_TO_ADDR
// uc_nation := 3 ;
21399: LD_ADDR_OWVAR 21
21403: PUSH
21404: LD_INT 3
21406: ST_TO_ADDR
// ru := [ ] ;
21407: LD_ADDR_VAR 0 7
21411: PUSH
21412: EMPTY
21413: ST_TO_ADDR
// for i = 1 to 5 do
21414: LD_ADDR_VAR 0 1
21418: PUSH
21419: DOUBLE
21420: LD_INT 1
21422: DEC
21423: ST_TO_ADDR
21424: LD_INT 5
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21548
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21430: LD_INT 22
21432: PUSH
21433: LD_INT 23
21435: PUSH
21436: EMPTY
21437: LIST
21438: LIST
21439: PUSH
21440: LD_INT 1
21442: PPUSH
21443: LD_INT 2
21445: PPUSH
21446: CALL_OW 12
21450: ARRAY
21451: PPUSH
21452: LD_INT 1
21454: PPUSH
21455: LD_INT 3
21457: PPUSH
21458: LD_INT 43
21460: PUSH
21461: LD_INT 44
21463: PUSH
21464: EMPTY
21465: LIST
21466: LIST
21467: PUSH
21468: LD_INT 1
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: CALL_OW 12
21478: ARRAY
21479: PPUSH
21480: LD_INT 89
21482: PPUSH
21483: CALL 72344 0 5
// un := CreateVehicle ;
21487: LD_ADDR_VAR 0 8
21491: PUSH
21492: CALL_OW 45
21496: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21497: LD_VAR 0 8
21501: PPUSH
21502: LD_INT 4
21504: PPUSH
21505: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21509: LD_VAR 0 8
21513: PPUSH
21514: LD_INT 136
21516: PPUSH
21517: LD_INT 90
21519: PPUSH
21520: LD_INT 8
21522: PPUSH
21523: LD_INT 0
21525: PPUSH
21526: CALL_OW 50
// ru := ru ^ un ;
21530: LD_ADDR_VAR 0 7
21534: PUSH
21535: LD_VAR 0 7
21539: PUSH
21540: LD_VAR 0 8
21544: ADD
21545: ST_TO_ADDR
// end ;
21546: GO 21427
21548: POP
21549: POP
// if ru then
21550: LD_VAR 0 7
21554: IFFALSE 21571
// ComAgressiveMove ( ru , 57 , 94 ) ;
21556: LD_VAR 0 7
21560: PPUSH
21561: LD_INT 57
21563: PPUSH
21564: LD_INT 94
21566: PPUSH
21567: CALL_OW 114
// wait ( 3 3$00 ) ;
21571: LD_INT 6300
21573: PPUSH
21574: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21578: LD_INT 4
21580: PPUSH
21581: LD_INT 3
21583: PUSH
21584: LD_INT 1
21586: PUSH
21587: LD_INT 1
21589: PUSH
21590: LD_INT 5
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 4
21601: PUSH
21602: LD_INT 1
21604: PUSH
21605: LD_INT 1
21607: PUSH
21608: LD_INT 6
21610: PUSH
21611: EMPTY
21612: LIST
21613: LIST
21614: LIST
21615: LIST
21616: PUSH
21617: LD_INT 4
21619: PUSH
21620: LD_INT 1
21622: PUSH
21623: LD_INT 1
21625: PUSH
21626: LD_INT 7
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: PUSH
21635: LD_INT 3
21637: PUSH
21638: LD_INT 1
21640: PUSH
21641: LD_INT 1
21643: PUSH
21644: LD_INT 7
21646: PUSH
21647: EMPTY
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: PUSH
21653: LD_INT 3
21655: PUSH
21656: LD_INT 1
21658: PUSH
21659: LD_INT 1
21661: PUSH
21662: LD_INT 5
21664: PUSH
21665: EMPTY
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: PUSH
21671: EMPTY
21672: LIST
21673: LIST
21674: LIST
21675: LIST
21676: LIST
21677: PPUSH
21678: CALL 60893 0 2
// missionStage := 4 ;
21682: LD_ADDR_EXP 15
21686: PUSH
21687: LD_INT 4
21689: ST_TO_ADDR
// end ;
21690: PPOPN 10
21692: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21693: LD_EXP 15
21697: PUSH
21698: LD_INT 4
21700: EQUAL
21701: PUSH
21702: LD_INT 22
21704: PUSH
21705: LD_INT 4
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: LD_INT 21
21714: PUSH
21715: LD_INT 2
21717: PUSH
21718: EMPTY
21719: LIST
21720: LIST
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: PPUSH
21726: CALL_OW 69
21730: PUSH
21731: LD_INT 5
21733: GREATEREQUAL
21734: AND
21735: IFFALSE 25948
21737: GO 21739
21739: DISABLE
21740: LD_INT 0
21742: PPUSH
21743: PPUSH
21744: PPUSH
21745: PPUSH
21746: PPUSH
21747: PPUSH
21748: PPUSH
21749: PPUSH
21750: PPUSH
21751: PPUSH
21752: PPUSH
21753: PPUSH
21754: PPUSH
// begin wait ( 0 0$10 ) ;
21755: LD_INT 350
21757: PPUSH
21758: CALL_OW 67
// missionStage := 5 ;
21762: LD_ADDR_EXP 15
21766: PUSH
21767: LD_INT 5
21769: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21770: LD_ADDR_VAR 0 10
21774: PUSH
21775: LD_INT 22
21777: PUSH
21778: LD_INT 4
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: PUSH
21785: LD_INT 2
21787: PUSH
21788: LD_INT 30
21790: PUSH
21791: LD_INT 4
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: PUSH
21798: LD_INT 30
21800: PUSH
21801: LD_INT 5
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: LIST
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PPUSH
21817: CALL_OW 69
21821: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21822: LD_ADDR_VAR 0 6
21826: PUSH
21827: LD_INT 22
21829: PUSH
21830: LD_INT 4
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 21
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: LD_INT 3
21849: PUSH
21850: LD_INT 25
21852: PUSH
21853: LD_INT 16
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: EMPTY
21861: LIST
21862: LIST
21863: PUSH
21864: LD_INT 3
21866: PUSH
21867: LD_INT 25
21869: PUSH
21870: LD_INT 12
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: PPUSH
21887: CALL_OW 69
21891: PUSH
21892: LD_EXP 59
21896: DIFF
21897: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
21898: LD_ADDR_VAR 0 9
21902: PUSH
21903: LD_INT 22
21905: PUSH
21906: LD_INT 4
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: PUSH
21913: LD_INT 30
21915: PUSH
21916: LD_INT 3
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: PPUSH
21927: CALL_OW 69
21931: PUSH
21932: LD_INT 1
21934: ARRAY
21935: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
21936: LD_INT 350
21938: PPUSH
21939: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
21943: LD_EXP 118
21947: PUSH
21948: LD_INT 4
21950: ARRAY
21951: PUSH
21952: LD_INT 5
21954: LESS
21955: PUSH
21956: LD_VAR 0 9
21960: PPUSH
21961: CALL_OW 461
21965: PUSH
21966: LD_INT 2
21968: EQUAL
21969: AND
21970: IFFALSE 22000
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21972: LD_INT 4
21974: PPUSH
21975: LD_INT 3
21977: PUSH
21978: LD_INT 1
21980: PUSH
21981: LD_INT 1
21983: PUSH
21984: LD_INT 5
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: PPUSH
21996: CALL 60941 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22000: LD_EXP 118
22004: PUSH
22005: LD_INT 4
22007: ARRAY
22008: PUSH
22009: LD_INT 5
22011: GREATEREQUAL
22012: PUSH
22013: LD_EXP 118
22017: PUSH
22018: LD_INT 4
22020: ARRAY
22021: PPUSH
22022: LD_INT 58
22024: PUSH
22025: EMPTY
22026: LIST
22027: PPUSH
22028: CALL_OW 72
22032: PUSH
22033: LD_INT 5
22035: GREATEREQUAL
22036: AND
22037: IFFALSE 21936
// powellAllowRetreat := false ;
22039: LD_ADDR_EXP 19
22043: PUSH
22044: LD_INT 0
22046: ST_TO_ADDR
// activeAttacks := false ;
22047: LD_ADDR_EXP 16
22051: PUSH
22052: LD_INT 0
22054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22055: LD_INT 35
22057: PPUSH
22058: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22062: LD_INT 22
22064: PUSH
22065: LD_INT 6
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: PPUSH
22072: CALL_OW 69
22076: PUSH
22077: LD_INT 0
22079: EQUAL
22080: IFFALSE 22055
// tmp := mc_vehicles [ 4 ] ;
22082: LD_ADDR_VAR 0 3
22086: PUSH
22087: LD_EXP 118
22091: PUSH
22092: LD_INT 4
22094: ARRAY
22095: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22096: LD_ADDR_VAR 0 1
22100: PUSH
22101: DOUBLE
22102: LD_INT 1
22104: DEC
22105: ST_TO_ADDR
22106: LD_EXP 18
22110: PUSH
22111: FOR_TO
22112: IFFALSE 22373
// begin for j in powellSquadAttack [ i ] do
22114: LD_ADDR_VAR 0 2
22118: PUSH
22119: LD_EXP 18
22123: PUSH
22124: LD_VAR 0 1
22128: ARRAY
22129: PUSH
22130: FOR_IN
22131: IFFALSE 22369
// begin forces := forces diff j ;
22133: LD_ADDR_VAR 0 6
22137: PUSH
22138: LD_VAR 0 6
22142: PUSH
22143: LD_VAR 0 2
22147: DIFF
22148: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22149: LD_VAR 0 2
22153: PPUSH
22154: LD_INT 1
22156: PPUSH
22157: CALL_OW 109
// wait ( 0 0$2 ) ;
22161: LD_INT 70
22163: PPUSH
22164: CALL_OW 67
// if IsInUnit ( j ) then
22168: LD_VAR 0 2
22172: PPUSH
22173: CALL_OW 310
22177: IFFALSE 22188
// ComExitBuilding ( j ) ;
22179: LD_VAR 0 2
22183: PPUSH
22184: CALL_OW 122
// if GetClass ( j ) <> 1 then
22188: LD_VAR 0 2
22192: PPUSH
22193: CALL_OW 257
22197: PUSH
22198: LD_INT 1
22200: NONEQUAL
22201: IFFALSE 22281
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22203: LD_VAR 0 10
22207: PUSH
22208: LD_INT 1
22210: ARRAY
22211: PPUSH
22212: CALL_OW 313
22216: PUSH
22217: LD_INT 5
22219: GREATEREQUAL
22220: IFFALSE 22242
// AddComEnterUnit ( j , arm [ 2 ] ) else
22222: LD_VAR 0 2
22226: PPUSH
22227: LD_VAR 0 10
22231: PUSH
22232: LD_INT 2
22234: ARRAY
22235: PPUSH
22236: CALL_OW 180
22240: GO 22260
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22242: LD_VAR 0 2
22246: PPUSH
22247: LD_VAR 0 10
22251: PUSH
22252: LD_INT 1
22254: ARRAY
22255: PPUSH
22256: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22260: LD_VAR 0 2
22264: PPUSH
22265: LD_INT 1
22267: PPUSH
22268: CALL_OW 183
// AddComExitBuilding ( j ) ;
22272: LD_VAR 0 2
22276: PPUSH
22277: CALL_OW 182
// end ; if i = 2 then
22281: LD_VAR 0 1
22285: PUSH
22286: LD_INT 2
22288: EQUAL
22289: IFFALSE 22306
// AddComMoveXY ( j , 61 , 93 ) ;
22291: LD_VAR 0 2
22295: PPUSH
22296: LD_INT 61
22298: PPUSH
22299: LD_INT 93
22301: PPUSH
22302: CALL_OW 171
// if i = 1 then
22306: LD_VAR 0 1
22310: PUSH
22311: LD_INT 1
22313: EQUAL
22314: IFFALSE 22367
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22316: LD_VAR 0 2
22320: PPUSH
22321: LD_VAR 0 3
22325: PUSH
22326: LD_INT 1
22328: ARRAY
22329: PPUSH
22330: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22334: LD_ADDR_VAR 0 3
22338: PUSH
22339: LD_VAR 0 3
22343: PPUSH
22344: LD_INT 1
22346: PPUSH
22347: CALL_OW 3
22351: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22352: LD_VAR 0 2
22356: PPUSH
22357: LD_INT 69
22359: PPUSH
22360: LD_INT 94
22362: PPUSH
22363: CALL_OW 171
// end ; end ;
22367: GO 22130
22369: POP
22370: POP
// end ;
22371: GO 22111
22373: POP
22374: POP
// wait ( 0 0$30 ) ;
22375: LD_INT 1050
22377: PPUSH
22378: CALL_OW 67
// MC_Kill ( 4 ) ;
22382: LD_INT 4
22384: PPUSH
22385: CALL 36914 0 1
// tmp := UnitsInside ( fac ) ;
22389: LD_ADDR_VAR 0 3
22393: PUSH
22394: LD_VAR 0 9
22398: PPUSH
22399: CALL_OW 313
22403: ST_TO_ADDR
// if tmp then
22404: LD_VAR 0 3
22408: IFFALSE 22529
// for i in tmp do
22410: LD_ADDR_VAR 0 1
22414: PUSH
22415: LD_VAR 0 3
22419: PUSH
22420: FOR_IN
22421: IFFALSE 22527
// begin ComExitBuilding ( i ) ;
22423: LD_VAR 0 1
22427: PPUSH
22428: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22432: LD_VAR 0 10
22436: PUSH
22437: LD_INT 2
22439: ARRAY
22440: PPUSH
22441: CALL_OW 313
22445: PUSH
22446: LD_INT 6
22448: LESS
22449: IFFALSE 22471
// AddComEnterUnit ( i , arm [ 2 ] ) else
22451: LD_VAR 0 1
22455: PPUSH
22456: LD_VAR 0 10
22460: PUSH
22461: LD_INT 2
22463: ARRAY
22464: PPUSH
22465: CALL_OW 180
22469: GO 22525
// if UnitsInside ( arm [ 1 ] ) < 6 then
22471: LD_VAR 0 10
22475: PUSH
22476: LD_INT 1
22478: ARRAY
22479: PPUSH
22480: CALL_OW 313
22484: PUSH
22485: LD_INT 6
22487: LESS
22488: IFFALSE 22510
// AddComEnterUnit ( i , arm [ 1 ] ) else
22490: LD_VAR 0 1
22494: PPUSH
22495: LD_VAR 0 10
22499: PUSH
22500: LD_INT 1
22502: ARRAY
22503: PPUSH
22504: CALL_OW 180
22508: GO 22525
// AddComMoveXY ( i , 37 , 68 ) ;
22510: LD_VAR 0 1
22514: PPUSH
22515: LD_INT 37
22517: PPUSH
22518: LD_INT 68
22520: PPUSH
22521: CALL_OW 171
// end ;
22525: GO 22420
22527: POP
22528: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22529: LD_ADDR_VAR 0 11
22533: PUSH
22534: LD_VAR 0 6
22538: PPUSH
22539: LD_INT 26
22541: PUSH
22542: LD_INT 1
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: PPUSH
22549: CALL_OW 72
22553: PUSH
22554: LD_EXP 60
22558: DIFF
22559: ST_TO_ADDR
// if not speaker then
22560: LD_VAR 0 11
22564: NOT
22565: IFFALSE 22592
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22567: LD_ADDR_VAR 0 11
22571: PUSH
22572: LD_VAR 0 6
22576: PPUSH
22577: LD_INT 26
22579: PUSH
22580: LD_INT 1
22582: PUSH
22583: EMPTY
22584: LIST
22585: LIST
22586: PPUSH
22587: CALL_OW 72
22591: ST_TO_ADDR
// if speaker then
22592: LD_VAR 0 11
22596: IFFALSE 22612
// speaker := speaker [ 1 ] ;
22598: LD_ADDR_VAR 0 11
22602: PUSH
22603: LD_VAR 0 11
22607: PUSH
22608: LD_INT 1
22610: ARRAY
22611: ST_TO_ADDR
// Video ( true ) ;
22612: LD_INT 1
22614: PPUSH
22615: CALL 104750 0 1
// CenterNowOnUnits ( Powell ) ;
22619: LD_EXP 59
22623: PPUSH
22624: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22628: LD_ADDR_VAR 0 3
22632: PUSH
22633: LD_VAR 0 6
22637: PPUSH
22638: LD_INT 3
22640: PUSH
22641: LD_INT 25
22643: PUSH
22644: LD_INT 1
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: EMPTY
22652: LIST
22653: LIST
22654: PPUSH
22655: CALL_OW 72
22659: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22660: LD_ADDR_VAR 0 12
22664: PUSH
22665: LD_INT 22
22667: PUSH
22668: LD_INT 4
22670: PUSH
22671: EMPTY
22672: LIST
22673: LIST
22674: PUSH
22675: LD_INT 30
22677: PUSH
22678: LD_INT 32
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PUSH
22685: LD_INT 58
22687: PUSH
22688: EMPTY
22689: LIST
22690: PUSH
22691: EMPTY
22692: LIST
22693: LIST
22694: LIST
22695: PPUSH
22696: CALL_OW 69
22700: ST_TO_ADDR
// for i := 1 to 4 do
22701: LD_ADDR_VAR 0 1
22705: PUSH
22706: DOUBLE
22707: LD_INT 1
22709: DEC
22710: ST_TO_ADDR
22711: LD_INT 4
22713: PUSH
22714: FOR_TO
22715: IFFALSE 22856
// begin if IsInUnit ( tmp [ i ] ) then
22717: LD_VAR 0 3
22721: PUSH
22722: LD_VAR 0 1
22726: ARRAY
22727: PPUSH
22728: CALL_OW 310
22732: IFFALSE 22749
// ComExitBuilding ( tmp [ i ] ) ;
22734: LD_VAR 0 3
22738: PUSH
22739: LD_VAR 0 1
22743: ARRAY
22744: PPUSH
22745: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22749: LD_VAR 0 3
22753: PUSH
22754: LD_VAR 0 1
22758: ARRAY
22759: PPUSH
22760: LD_VAR 0 10
22764: PUSH
22765: LD_INT 1
22767: ARRAY
22768: PPUSH
22769: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22773: LD_VAR 0 3
22777: PUSH
22778: LD_VAR 0 1
22782: ARRAY
22783: PPUSH
22784: LD_INT 1
22786: PPUSH
22787: CALL_OW 183
// if emp_towers then
22791: LD_VAR 0 12
22795: IFFALSE 22854
// begin AddComExitBuilding ( tmp [ i ] ) ;
22797: LD_VAR 0 3
22801: PUSH
22802: LD_VAR 0 1
22806: ARRAY
22807: PPUSH
22808: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22812: LD_VAR 0 3
22816: PUSH
22817: LD_VAR 0 1
22821: ARRAY
22822: PPUSH
22823: LD_VAR 0 12
22827: PUSH
22828: LD_INT 1
22830: ARRAY
22831: PPUSH
22832: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
22836: LD_ADDR_VAR 0 12
22840: PUSH
22841: LD_VAR 0 12
22845: PPUSH
22846: LD_INT 1
22848: PPUSH
22849: CALL_OW 3
22853: ST_TO_ADDR
// end ; end ;
22854: GO 22714
22856: POP
22857: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
22858: LD_ADDR_VAR 0 3
22862: PUSH
22863: LD_EXP 18
22867: PUSH
22868: LD_INT 1
22870: ARRAY
22871: PUSH
22872: LD_EXP 18
22876: PUSH
22877: LD_INT 2
22879: ARRAY
22880: ADD
22881: PPUSH
22882: LD_INT 26
22884: PUSH
22885: LD_INT 1
22887: PUSH
22888: EMPTY
22889: LIST
22890: LIST
22891: PPUSH
22892: CALL_OW 72
22896: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
22897: LD_ADDR_VAR 0 1
22901: PUSH
22902: LD_EXP 18
22906: PUSH
22907: LD_INT 2
22909: ARRAY
22910: PUSH
22911: FOR_IN
22912: IFFALSE 22930
// ComTurnUnit ( i , Powell ) ;
22914: LD_VAR 0 1
22918: PPUSH
22919: LD_EXP 59
22923: PPUSH
22924: CALL_OW 119
22928: GO 22911
22930: POP
22931: POP
// Say ( Powell , D5-Pow-1 ) ;
22932: LD_EXP 59
22936: PPUSH
22937: LD_STRING D5-Pow-1
22939: PPUSH
22940: CALL_OW 88
// if tmp then
22944: LD_VAR 0 3
22948: IFFALSE 22966
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
22950: LD_VAR 0 3
22954: PUSH
22955: LD_INT 1
22957: ARRAY
22958: PPUSH
22959: LD_STRING D5-Sol2-1
22961: PPUSH
22962: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
22966: LD_EXP 59
22970: PPUSH
22971: LD_STRING D5-Pow-2
22973: PPUSH
22974: CALL_OW 88
// if tmp > 1 then
22978: LD_VAR 0 3
22982: PUSH
22983: LD_INT 1
22985: GREATER
22986: IFFALSE 23004
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
22988: LD_VAR 0 3
22992: PUSH
22993: LD_INT 2
22995: ARRAY
22996: PPUSH
22997: LD_STRING D5-Sol2-2
22999: PPUSH
23000: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23004: LD_EXP 59
23008: PPUSH
23009: LD_STRING D5-Pow-3
23011: PPUSH
23012: CALL_OW 88
// wait ( 0 0$1 ) ;
23016: LD_INT 35
23018: PPUSH
23019: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23023: LD_ADDR_VAR 0 3
23027: PUSH
23028: LD_EXP 18
23032: PUSH
23033: LD_INT 1
23035: ARRAY
23036: PUSH
23037: LD_EXP 18
23041: PUSH
23042: LD_INT 2
23044: ARRAY
23045: UNION
23046: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23047: LD_VAR 0 3
23051: PPUSH
23052: LD_INT 80
23054: PPUSH
23055: LD_INT 67
23057: PPUSH
23058: CALL_OW 114
// wait ( 0 0$2 ) ;
23062: LD_INT 70
23064: PPUSH
23065: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23069: LD_INT 79
23071: PPUSH
23072: LD_INT 72
23074: PPUSH
23075: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23079: LD_INT 70
23081: PPUSH
23082: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23086: LD_VAR 0 3
23090: PPUSH
23091: LD_INT 3
23093: PUSH
23094: LD_INT 24
23096: PUSH
23097: LD_INT 1000
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PPUSH
23108: CALL_OW 72
23112: IFFALSE 23079
// Say ( Powell , D5a-Pow-1 ) ;
23114: LD_EXP 59
23118: PPUSH
23119: LD_STRING D5a-Pow-1
23121: PPUSH
23122: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23126: LD_EXP 59
23130: PPUSH
23131: LD_STRING D5a-Pow-1a
23133: PPUSH
23134: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23138: LD_INT 24
23140: PPUSH
23141: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23145: LD_EXP 59
23149: PPUSH
23150: LD_STRING D5a-Pow-1b
23152: PPUSH
23153: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23157: LD_INT 10
23159: PPUSH
23160: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23164: LD_EXP 59
23168: PPUSH
23169: LD_STRING D5a-Pow-1c
23171: PPUSH
23172: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23176: LD_VAR 0 3
23180: PPUSH
23181: LD_INT 68
23183: PPUSH
23184: LD_INT 63
23186: PPUSH
23187: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23191: LD_INT 18
23193: PPUSH
23194: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23198: LD_EXP 59
23202: PPUSH
23203: LD_STRING D5a-Pow-1d
23205: PPUSH
23206: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23210: LD_INT 35
23212: PPUSH
23213: CALL_OW 67
// if not HasTask ( tmp ) then
23217: LD_VAR 0 3
23221: PPUSH
23222: CALL_OW 314
23226: NOT
23227: IFFALSE 23244
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23229: LD_VAR 0 3
23233: PPUSH
23234: LD_INT 68
23236: PPUSH
23237: LD_INT 63
23239: PPUSH
23240: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23244: LD_VAR 0 3
23248: PPUSH
23249: LD_INT 24
23251: PUSH
23252: LD_INT 1
23254: PUSH
23255: EMPTY
23256: LIST
23257: LIST
23258: PPUSH
23259: CALL_OW 72
23263: NOT
23264: IFFALSE 23210
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23266: LD_ADDR_VAR 0 3
23270: PUSH
23271: LD_INT 22
23273: PUSH
23274: LD_INT 4
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: LD_INT 92
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: LD_INT 93
23289: PUSH
23290: LD_INT 10
23292: PUSH
23293: EMPTY
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: PUSH
23299: LD_INT 3
23301: PUSH
23302: LD_INT 54
23304: PUSH
23305: EMPTY
23306: LIST
23307: PUSH
23308: EMPTY
23309: LIST
23310: LIST
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: LIST
23316: PPUSH
23317: CALL_OW 69
23321: PUSH
23322: LD_EXP 59
23326: DIFF
23327: ST_TO_ADDR
// if tmp then
23328: LD_VAR 0 3
23332: IFFALSE 23366
// for i in tmp do
23334: LD_ADDR_VAR 0 1
23338: PUSH
23339: LD_VAR 0 3
23343: PUSH
23344: FOR_IN
23345: IFFALSE 23364
// ComMoveXY ( i , 36 , 67 ) ;
23347: LD_VAR 0 1
23351: PPUSH
23352: LD_INT 36
23354: PPUSH
23355: LD_INT 67
23357: PPUSH
23358: CALL_OW 111
23362: GO 23344
23364: POP
23365: POP
// wait ( 0 0$3 ) ;
23366: LD_INT 105
23368: PPUSH
23369: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23373: LD_VAR 0 11
23377: PPUSH
23378: LD_STRING D6-Sol3-1
23380: PPUSH
23381: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23385: LD_EXP 59
23389: PPUSH
23390: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23394: LD_EXP 59
23398: PPUSH
23399: LD_STRING D6-Pow-1
23401: PPUSH
23402: CALL_OW 88
// tmp := [ ] ;
23406: LD_ADDR_VAR 0 3
23410: PUSH
23411: EMPTY
23412: ST_TO_ADDR
// for i = 1 to 2 do
23413: LD_ADDR_VAR 0 1
23417: PUSH
23418: DOUBLE
23419: LD_INT 1
23421: DEC
23422: ST_TO_ADDR
23423: LD_INT 2
23425: PUSH
23426: FOR_TO
23427: IFFALSE 23541
// begin uc_side := 8 ;
23429: LD_ADDR_OWVAR 20
23433: PUSH
23434: LD_INT 8
23436: ST_TO_ADDR
// uc_nation := 2 ;
23437: LD_ADDR_OWVAR 21
23441: PUSH
23442: LD_INT 2
23444: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23445: LD_INT 14
23447: PPUSH
23448: LD_INT 3
23450: PPUSH
23451: LD_INT 2
23453: PPUSH
23454: LD_INT 29
23456: PPUSH
23457: LD_INT 100
23459: PPUSH
23460: CALL 72344 0 5
// veh := CreateVehicle ;
23464: LD_ADDR_VAR 0 13
23468: PUSH
23469: CALL_OW 45
23473: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23474: LD_VAR 0 13
23478: PPUSH
23479: LD_INT 4
23481: PPUSH
23482: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23486: LD_VAR 0 13
23490: PPUSH
23491: LD_INT 99
23493: PPUSH
23494: LD_INT 83
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: LD_INT 0
23502: PPUSH
23503: CALL_OW 50
// wait ( 3 ) ;
23507: LD_INT 3
23509: PPUSH
23510: CALL_OW 67
// Connect ( veh ) ;
23514: LD_VAR 0 13
23518: PPUSH
23519: CALL 75435 0 1
// tmp := tmp ^ veh ;
23523: LD_ADDR_VAR 0 3
23527: PUSH
23528: LD_VAR 0 3
23532: PUSH
23533: LD_VAR 0 13
23537: ADD
23538: ST_TO_ADDR
// end ;
23539: GO 23426
23541: POP
23542: POP
// wait ( 0 0$1 ) ;
23543: LD_INT 35
23545: PPUSH
23546: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23550: LD_INT 99
23552: PPUSH
23553: LD_INT 83
23555: PPUSH
23556: LD_INT 1
23558: PPUSH
23559: LD_INT 10
23561: PPUSH
23562: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23566: LD_INT 99
23568: PPUSH
23569: LD_INT 83
23571: PPUSH
23572: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23576: LD_VAR 0 11
23580: PPUSH
23581: LD_STRING D6-Sol3-2
23583: PPUSH
23584: CALL_OW 88
// async ;
23588: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23589: LD_EXP 59
23593: PPUSH
23594: LD_STRING D6-Pow-2
23596: PPUSH
23597: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23601: LD_VAR 0 3
23605: PUSH
23606: LD_INT 1
23608: ARRAY
23609: PPUSH
23610: LD_VAR 0 9
23614: PPUSH
23615: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23619: LD_VAR 0 3
23623: PUSH
23624: LD_INT 2
23626: ARRAY
23627: PPUSH
23628: LD_INT 22
23630: PUSH
23631: LD_INT 4
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 21
23640: PUSH
23641: LD_INT 3
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: PPUSH
23652: CALL_OW 69
23656: PPUSH
23657: LD_VAR 0 3
23661: PUSH
23662: LD_INT 2
23664: ARRAY
23665: PPUSH
23666: CALL_OW 74
23670: PPUSH
23671: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23675: LD_EXP 59
23679: PPUSH
23680: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23684: LD_INT 99
23686: PPUSH
23687: LD_INT 83
23689: PPUSH
23690: LD_INT 1
23692: PPUSH
23693: CALL_OW 331
// repeat wait ( 4 ) ;
23697: LD_INT 4
23699: PPUSH
23700: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23704: LD_VAR 0 3
23708: PUSH
23709: LD_INT 1
23711: ARRAY
23712: PPUSH
23713: CALL_OW 256
23717: PUSH
23718: LD_INT 1000
23720: LESS
23721: IFFALSE 23739
// SetLives ( tmp [ 1 ] , 1000 ) ;
23723: LD_VAR 0 3
23727: PUSH
23728: LD_INT 1
23730: ARRAY
23731: PPUSH
23732: LD_INT 1000
23734: PPUSH
23735: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23739: LD_INT 22
23741: PUSH
23742: LD_INT 4
23744: PUSH
23745: EMPTY
23746: LIST
23747: LIST
23748: PUSH
23749: LD_INT 30
23751: PUSH
23752: LD_INT 3
23754: PUSH
23755: EMPTY
23756: LIST
23757: LIST
23758: PUSH
23759: EMPTY
23760: LIST
23761: LIST
23762: PPUSH
23763: CALL_OW 69
23767: PUSH
23768: LD_INT 0
23770: EQUAL
23771: IFFALSE 23697
// skirmish := false ;
23773: LD_ADDR_EXP 97
23777: PUSH
23778: LD_INT 0
23780: ST_TO_ADDR
// sync ;
23781: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23782: LD_EXP 59
23786: PPUSH
23787: LD_STRING D6a-Pow-1
23789: PPUSH
23790: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23794: LD_VAR 0 11
23798: PPUSH
23799: LD_STRING D6a-Sol3-1
23801: PPUSH
23802: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23806: LD_EXP 59
23810: PPUSH
23811: LD_STRING D6a-Pow-2
23813: PPUSH
23814: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23818: LD_VAR 0 11
23822: PPUSH
23823: LD_STRING D6a-Sol3-2
23825: PPUSH
23826: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23830: LD_EXP 59
23834: PPUSH
23835: LD_STRING D6a-Pow-3
23837: PPUSH
23838: CALL_OW 88
// powellCenterCameraMode := true ;
23842: LD_ADDR_EXP 20
23846: PUSH
23847: LD_INT 1
23849: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23850: LD_ADDR_VAR 0 1
23854: PUSH
23855: LD_INT 22
23857: PUSH
23858: LD_INT 8
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 25
23867: PUSH
23868: LD_INT 2
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PPUSH
23879: CALL_OW 69
23883: PUSH
23884: FOR_IN
23885: IFFALSE 23940
// begin SetTag ( i , 1 ) ;
23887: LD_VAR 0 1
23891: PPUSH
23892: LD_INT 1
23894: PPUSH
23895: CALL_OW 109
// ComExitBuilding ( i ) ;
23899: LD_VAR 0 1
23903: PPUSH
23904: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
23908: LD_VAR 0 1
23912: PPUSH
23913: LD_INT 35
23915: PPUSH
23916: LD_INT 6
23918: PPUSH
23919: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
23923: LD_VAR 0 1
23927: PPUSH
23928: LD_INT 53
23930: PPUSH
23931: LD_INT 4
23933: PPUSH
23934: CALL_OW 171
// end ;
23938: GO 23884
23940: POP
23941: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
23942: LD_ADDR_VAR 0 3
23946: PUSH
23947: LD_INT 22
23949: PUSH
23950: LD_INT 4
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: LD_INT 21
23959: PUSH
23960: LD_INT 2
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: PUSH
23967: LD_INT 3
23969: PUSH
23970: LD_INT 34
23972: PUSH
23973: LD_INT 12
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PPUSH
23989: CALL_OW 69
23993: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
23994: LD_EXP 59
23998: PPUSH
23999: LD_VAR 0 3
24003: PPUSH
24004: LD_EXP 59
24008: PPUSH
24009: CALL_OW 74
24013: PPUSH
24014: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24018: LD_EXP 59
24022: PPUSH
24023: LD_INT 100
24025: PPUSH
24026: LD_INT 88
24028: PPUSH
24029: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24033: LD_EXP 59
24037: PPUSH
24038: LD_INT 100
24040: PPUSH
24041: LD_INT 75
24043: PPUSH
24044: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24048: LD_EXP 59
24052: PPUSH
24053: LD_INT 88
24055: PPUSH
24056: LD_INT 53
24058: PPUSH
24059: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24063: LD_INT 8
24065: PPUSH
24066: LD_EXP 59
24070: PPUSH
24071: CALL_OW 471
// repeat wait ( 3 ) ;
24075: LD_INT 3
24077: PPUSH
24078: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24082: LD_INT 22
24084: PUSH
24085: LD_INT 4
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: PUSH
24092: LD_INT 92
24094: PUSH
24095: LD_INT 100
24097: PUSH
24098: LD_INT 75
24100: PUSH
24101: LD_INT 6
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: LIST
24108: LIST
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PPUSH
24114: CALL_OW 69
24118: IFFALSE 24075
// async ;
24120: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24121: LD_EXP 59
24125: PPUSH
24126: LD_STRING D6b-Pow-1
24128: PPUSH
24129: CALL_OW 88
// repeat wait ( 3 ) ;
24133: LD_INT 3
24135: PPUSH
24136: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24140: LD_EXP 59
24144: PPUSH
24145: CALL_OW 310
24149: PPUSH
24150: CALL_OW 256
24154: PUSH
24155: LD_INT 1000
24157: LESS
24158: IFFALSE 24177
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24160: LD_EXP 59
24164: PPUSH
24165: CALL_OW 310
24169: PPUSH
24170: LD_INT 1000
24172: PPUSH
24173: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24177: LD_EXP 59
24181: PPUSH
24182: CALL_OW 256
24186: PUSH
24187: LD_INT 1000
24189: LESS
24190: IFFALSE 24204
// SetLives ( Powell , 1000 ) ;
24192: LD_EXP 59
24196: PPUSH
24197: LD_INT 1000
24199: PPUSH
24200: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24204: LD_EXP 59
24208: PPUSH
24209: LD_EXP 64
24213: PPUSH
24214: CALL_OW 296
24218: PUSH
24219: LD_INT 5
24221: LESS
24222: PUSH
24223: LD_EXP 59
24227: PPUSH
24228: CALL_OW 310
24232: PPUSH
24233: LD_EXP 64
24237: PPUSH
24238: CALL_OW 296
24242: PUSH
24243: LD_INT 5
24245: LESS
24246: OR
24247: IFFALSE 24266
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24249: LD_EXP 59
24253: PPUSH
24254: CALL_OW 310
24258: PPUSH
24259: LD_INT 100
24261: PPUSH
24262: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24266: LD_EXP 59
24270: PPUSH
24271: CALL_OW 310
24275: NOT
24276: IFFALSE 24133
// DoNotAttack ( 8 , powellBomb ) ;
24278: LD_INT 8
24280: PPUSH
24281: LD_EXP 64
24285: PPUSH
24286: CALL_OW 471
// game_speed := 4 ;
24290: LD_ADDR_OWVAR 65
24294: PUSH
24295: LD_INT 4
24297: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24298: LD_EXP 59
24302: PPUSH
24303: LD_STRING D6b-Pow-1a
24305: PPUSH
24306: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24310: LD_EXP 59
24314: PPUSH
24315: LD_EXP 64
24319: PPUSH
24320: CALL_OW 180
// sync ;
24324: SYNC
// repeat wait ( 0 0$1 ) ;
24325: LD_INT 35
24327: PPUSH
24328: CALL_OW 67
// until IsInUnit ( Powell ) ;
24332: LD_EXP 59
24336: PPUSH
24337: CALL_OW 310
24341: IFFALSE 24325
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24343: LD_INT 8
24345: PPUSH
24346: LD_EXP 59
24350: PPUSH
24351: CALL_OW 310
24355: PPUSH
24356: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24360: LD_EXP 59
24364: PPUSH
24365: LD_INT 91
24367: PPUSH
24368: LD_INT 44
24370: PPUSH
24371: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24375: LD_EXP 59
24379: PPUSH
24380: LD_INT 96
24382: PPUSH
24383: LD_INT 44
24385: PPUSH
24386: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24390: LD_EXP 59
24394: PPUSH
24395: LD_INT 96
24397: PPUSH
24398: LD_INT 41
24400: PPUSH
24401: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24405: LD_EXP 59
24409: PPUSH
24410: LD_INT 92
24412: PPUSH
24413: LD_INT 39
24415: PPUSH
24416: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24420: LD_EXP 59
24424: PPUSH
24425: LD_INT 88
24427: PPUSH
24428: LD_INT 41
24430: PPUSH
24431: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24435: LD_EXP 59
24439: PPUSH
24440: LD_INT 91
24442: PPUSH
24443: LD_INT 44
24445: PPUSH
24446: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24450: LD_EXP 59
24454: PPUSH
24455: LD_INT 96
24457: PPUSH
24458: LD_INT 44
24460: PPUSH
24461: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24465: LD_EXP 59
24469: PPUSH
24470: LD_INT 96
24472: PPUSH
24473: LD_INT 41
24475: PPUSH
24476: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24480: LD_EXP 59
24484: PPUSH
24485: LD_INT 92
24487: PPUSH
24488: LD_INT 39
24490: PPUSH
24491: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24495: LD_EXP 59
24499: PPUSH
24500: LD_INT 88
24502: PPUSH
24503: LD_INT 41
24505: PPUSH
24506: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24510: LD_EXP 59
24514: PPUSH
24515: LD_INT 91
24517: PPUSH
24518: LD_INT 44
24520: PPUSH
24521: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24525: LD_EXP 59
24529: PPUSH
24530: LD_INT 93
24532: PPUSH
24533: LD_INT 39
24535: PPUSH
24536: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24540: LD_EXP 59
24544: PPUSH
24545: LD_INT 93
24547: PPUSH
24548: LD_INT 36
24550: PPUSH
24551: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24555: LD_INT 122
24557: PPUSH
24558: CALL_OW 67
// game_speed := 4 ;
24562: LD_ADDR_OWVAR 65
24566: PUSH
24567: LD_INT 4
24569: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24570: LD_EXP 59
24574: PPUSH
24575: LD_STRING D6b-Pow-1b
24577: PPUSH
24578: CALL_OW 88
// tmp := [ ] ;
24582: LD_ADDR_VAR 0 3
24586: PUSH
24587: EMPTY
24588: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24589: LD_ADDR_VAR 0 5
24593: PUSH
24594: LD_INT 78
24596: PUSH
24597: LD_INT 47
24599: PUSH
24600: EMPTY
24601: LIST
24602: LIST
24603: PUSH
24604: LD_INT 106
24606: PUSH
24607: LD_INT 53
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24618: LD_ADDR_VAR 0 1
24622: PUSH
24623: LD_INT 22
24625: PUSH
24626: LD_INT 8
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: LD_INT 21
24635: PUSH
24636: LD_INT 3
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 92
24645: PUSH
24646: LD_INT 90
24648: PUSH
24649: LD_INT 52
24651: PUSH
24652: LD_INT 12
24654: PUSH
24655: EMPTY
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: LIST
24665: PPUSH
24666: CALL_OW 69
24670: PUSH
24671: FOR_IN
24672: IFFALSE 24697
// tmp := tmp ^ UnitsInside ( i ) ;
24674: LD_ADDR_VAR 0 3
24678: PUSH
24679: LD_VAR 0 3
24683: PUSH
24684: LD_VAR 0 1
24688: PPUSH
24689: CALL_OW 313
24693: ADD
24694: ST_TO_ADDR
24695: GO 24671
24697: POP
24698: POP
// for i in tmp do
24699: LD_ADDR_VAR 0 1
24703: PUSH
24704: LD_VAR 0 3
24708: PUSH
24709: FOR_IN
24710: IFFALSE 24872
// begin dist := 9999 ;
24712: LD_ADDR_VAR 0 8
24716: PUSH
24717: LD_INT 9999
24719: ST_TO_ADDR
// _xy := [ ] ;
24720: LD_ADDR_VAR 0 7
24724: PUSH
24725: EMPTY
24726: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24727: LD_VAR 0 1
24731: PPUSH
24732: LD_INT 1
24734: PPUSH
24735: CALL_OW 109
// ComExitBuilding ( i ) ;
24739: LD_VAR 0 1
24743: PPUSH
24744: CALL_OW 122
// for j in xy do
24748: LD_ADDR_VAR 0 2
24752: PUSH
24753: LD_VAR 0 5
24757: PUSH
24758: FOR_IN
24759: IFFALSE 24841
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24761: LD_VAR 0 1
24765: PPUSH
24766: LD_VAR 0 2
24770: PUSH
24771: LD_INT 1
24773: ARRAY
24774: PPUSH
24775: LD_VAR 0 2
24779: PUSH
24780: LD_INT 2
24782: ARRAY
24783: PPUSH
24784: CALL_OW 297
24788: PUSH
24789: LD_VAR 0 8
24793: LESS
24794: IFFALSE 24839
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24796: LD_ADDR_VAR 0 8
24800: PUSH
24801: LD_VAR 0 1
24805: PPUSH
24806: LD_VAR 0 2
24810: PUSH
24811: LD_INT 1
24813: ARRAY
24814: PPUSH
24815: LD_VAR 0 2
24819: PUSH
24820: LD_INT 2
24822: ARRAY
24823: PPUSH
24824: CALL_OW 297
24828: ST_TO_ADDR
// _xy := j ;
24829: LD_ADDR_VAR 0 7
24833: PUSH
24834: LD_VAR 0 2
24838: ST_TO_ADDR
// end ;
24839: GO 24758
24841: POP
24842: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
24843: LD_VAR 0 1
24847: PPUSH
24848: LD_VAR 0 7
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PPUSH
24857: LD_VAR 0 7
24861: PUSH
24862: LD_INT 2
24864: ARRAY
24865: PPUSH
24866: CALL_OW 171
// end ;
24870: GO 24709
24872: POP
24873: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
24874: LD_ADDR_VAR 0 4
24878: PUSH
24879: LD_VAR 0 3
24883: PPUSH
24884: LD_INT 26
24886: PUSH
24887: LD_INT 1
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 25
24896: PUSH
24897: LD_INT 1
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL_OW 72
24912: ST_TO_ADDR
// if tmp2 < 2 then
24913: LD_VAR 0 4
24917: PUSH
24918: LD_INT 2
24920: LESS
24921: IFFALSE 24990
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
24923: LD_ADDR_VAR 0 4
24927: PUSH
24928: LD_INT 22
24930: PUSH
24931: LD_INT 8
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 26
24940: PUSH
24941: LD_INT 1
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: LD_INT 3
24950: PUSH
24951: LD_INT 25
24953: PUSH
24954: LD_INT 15
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: EMPTY
24966: LIST
24967: LIST
24968: LIST
24969: PPUSH
24970: CALL_OW 69
24974: PUSH
24975: LD_EXP 61
24979: PUSH
24980: LD_EXP 62
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: DIFF
24989: ST_TO_ADDR
// if tmp2 then
24990: LD_VAR 0 4
24994: IFFALSE 25012
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
24996: LD_VAR 0 4
25000: PUSH
25001: LD_INT 1
25003: ARRAY
25004: PPUSH
25005: LD_STRING D6b-ArSol1-1
25007: PPUSH
25008: CALL_OW 88
// async ;
25012: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25013: LD_EXP 59
25017: PPUSH
25018: LD_STRING D6b-Pow-2
25020: PPUSH
25021: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25025: LD_INT 18
25027: PPUSH
25028: CALL_OW 67
// if tmp2 > 1 then
25032: LD_VAR 0 4
25036: PUSH
25037: LD_INT 1
25039: GREATER
25040: IFFALSE 25058
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25042: LD_VAR 0 4
25046: PUSH
25047: LD_INT 2
25049: ARRAY
25050: PPUSH
25051: LD_STRING D6b-ArSol2-1
25053: PPUSH
25054: CALL_OW 88
// sync ;
25058: SYNC
// repeat wait ( 5 ) ;
25059: LD_INT 5
25061: PPUSH
25062: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25066: LD_INT 93
25068: PPUSH
25069: LD_INT 36
25071: PPUSH
25072: CALL_OW 428
25076: PPUSH
25077: CALL_OW 255
25081: PUSH
25082: LD_INT 4
25084: EQUAL
25085: IFFALSE 25059
// DialogueOn ;
25087: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25091: LD_INT 10
25093: PPUSH
25094: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25098: LD_EXP 59
25102: PPUSH
25103: LD_STRING D6b-Pow-2a
25105: PPUSH
25106: CALL_OW 88
// DialogueOff ;
25110: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25114: LD_EXP 59
25118: PPUSH
25119: CALL_OW 310
25123: PPUSH
25124: LD_INT 332
25126: PPUSH
25127: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25131: LD_INT 93
25133: PPUSH
25134: LD_INT 35
25136: PPUSH
25137: LD_INT 1
25139: PPUSH
25140: LD_INT 6
25142: NEG
25143: PPUSH
25144: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25148: LD_INT 35
25150: PPUSH
25151: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25155: LD_INT 332
25157: PPUSH
25158: CALL_OW 256
25162: PUSH
25163: LD_INT 1000
25165: LESS
25166: PUSH
25167: LD_INT 332
25169: PPUSH
25170: CALL_OW 300
25174: AND
25175: IFFALSE 25187
// SetLives ( kozlov_fac , 0 ) ;
25177: LD_INT 332
25179: PPUSH
25180: LD_INT 0
25182: PPUSH
25183: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25187: LD_INT 332
25189: PPUSH
25190: CALL_OW 301
25194: PUSH
25195: LD_EXP 59
25199: PPUSH
25200: CALL_OW 301
25204: OR
25205: IFFALSE 25148
// game_speed := 4 ;
25207: LD_ADDR_OWVAR 65
25211: PUSH
25212: LD_INT 4
25214: ST_TO_ADDR
// powellCenterCameraMode := false ;
25215: LD_ADDR_EXP 20
25219: PUSH
25220: LD_INT 0
25222: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25223: LD_ADDR_VAR 0 1
25227: PUSH
25228: LD_VAR 0 3
25232: PUSH
25233: LD_INT 22
25235: PUSH
25236: LD_INT 8
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: LD_INT 25
25245: PUSH
25246: LD_INT 2
25248: PUSH
25249: EMPTY
25250: LIST
25251: LIST
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: UNION
25262: PUSH
25263: FOR_IN
25264: IFFALSE 25280
// SetTag ( i , 0 ) ;
25266: LD_VAR 0 1
25270: PPUSH
25271: LD_INT 0
25273: PPUSH
25274: CALL_OW 109
25278: GO 25263
25280: POP
25281: POP
// wait ( 0 0$3 ) ;
25282: LD_INT 105
25284: PPUSH
25285: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25289: LD_INT 93
25291: PPUSH
25292: LD_INT 35
25294: PPUSH
25295: LD_INT 1
25297: PPUSH
25298: CALL_OW 331
// DialogueOn ;
25302: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25306: LD_VAR 0 11
25310: PPUSH
25311: LD_STRING D6c-Sol3-1
25313: PPUSH
25314: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25318: LD_INT 10
25320: PPUSH
25321: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25325: LD_EXP 40
25329: PPUSH
25330: LD_STRING D6c-JMM-1
25332: PPUSH
25333: CALL_OW 88
// if Cyrus then
25337: LD_EXP 46
25341: IFFALSE 25355
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25343: LD_EXP 46
25347: PPUSH
25348: LD_STRING D6c-Cyrus-1
25350: PPUSH
25351: CALL_OW 88
// if Bobby then
25355: LD_EXP 45
25359: IFFALSE 25373
// Say ( Bobby , D6c-Bobby-1 ) ;
25361: LD_EXP 45
25365: PPUSH
25366: LD_STRING D6c-Bobby-1
25368: PPUSH
25369: CALL_OW 88
// if Cornel then
25373: LD_EXP 51
25377: IFFALSE 25391
// Say ( Cornel , D6c-Corn-1 ) ;
25379: LD_EXP 51
25383: PPUSH
25384: LD_STRING D6c-Corn-1
25386: PPUSH
25387: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25391: LD_ADDR_VAR 0 4
25395: PUSH
25396: LD_INT 2
25398: PUSH
25399: LD_INT 22
25401: PUSH
25402: LD_INT 1
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 22
25411: PUSH
25412: LD_INT 4
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 26
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 23
25436: PUSH
25437: LD_INT 1
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: PUSH
25444: EMPTY
25445: LIST
25446: LIST
25447: LIST
25448: PPUSH
25449: CALL_OW 69
25453: PUSH
25454: LD_VAR 0 11
25458: PUSH
25459: LD_EXP 40
25463: UNION
25464: PUSH
25465: LD_EXP 60
25469: UNION
25470: DIFF
25471: ST_TO_ADDR
// if tmp2 then
25472: LD_VAR 0 4
25476: IFFALSE 25494
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25478: LD_VAR 0 4
25482: PUSH
25483: LD_INT 1
25485: ARRAY
25486: PPUSH
25487: LD_STRING D6c-Sol1-1
25489: PPUSH
25490: CALL_OW 88
// if Lisa then
25494: LD_EXP 43
25498: IFFALSE 25512
// Say ( Lisa , D6c-Lisa-1 ) ;
25500: LD_EXP 43
25504: PPUSH
25505: LD_STRING D6c-Lisa-1
25507: PPUSH
25508: CALL_OW 88
// if Gary then
25512: LD_EXP 52
25516: IFFALSE 25530
// Say ( Gary , D6c-Gary-1 ) ;
25518: LD_EXP 52
25522: PPUSH
25523: LD_STRING D6c-Gary-1
25525: PPUSH
25526: CALL_OW 88
// if Donaldson then
25530: LD_EXP 44
25534: IFFALSE 25548
// Say ( Donaldson , D6c-Don-1 ) ;
25536: LD_EXP 44
25540: PPUSH
25541: LD_STRING D6c-Don-1
25543: PPUSH
25544: CALL_OW 88
// if tmp2 > 1 then
25548: LD_VAR 0 4
25552: PUSH
25553: LD_INT 1
25555: GREATER
25556: IFFALSE 25574
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25558: LD_VAR 0 4
25562: PUSH
25563: LD_INT 2
25565: ARRAY
25566: PPUSH
25567: LD_STRING D6c-Sol2-1
25569: PPUSH
25570: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25574: LD_VAR 0 11
25578: PPUSH
25579: LD_STRING D6c-Sol3-2
25581: PPUSH
25582: CALL_OW 88
// if IsInUnit ( JMM ) then
25586: LD_EXP 40
25590: PPUSH
25591: CALL_OW 310
25595: IFFALSE 25613
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25597: LD_EXP 40
25601: PPUSH
25602: CALL_OW 310
25606: PPUSH
25607: CALL_OW 87
25611: GO 25622
// CenterNowOnUnits ( JMM ) ;
25613: LD_EXP 40
25617: PPUSH
25618: CALL_OW 87
// dwait ( 0 0$2 ) ;
25622: LD_INT 70
25624: PPUSH
25625: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25629: LD_EXP 40
25633: PPUSH
25634: LD_STRING D6c-JMM-2
25636: PPUSH
25637: CALL_OW 88
// DialogueOff ;
25641: CALL_OW 7
// Video ( false ) ;
25645: LD_INT 0
25647: PPUSH
25648: CALL 104750 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25652: LD_INT 22
25654: PUSH
25655: LD_INT 4
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25674: LD_INT 4
25676: PPUSH
25677: LD_INT 4
25679: PPUSH
25680: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25684: LD_ADDR_VAR 0 1
25688: PUSH
25689: LD_INT 4
25691: PPUSH
25692: LD_INT 1
25694: PPUSH
25695: LD_INT 2
25697: PPUSH
25698: CALL 67392 0 3
25702: PUSH
25703: FOR_IN
25704: IFFALSE 25741
// if GetTech ( i , 1 ) <> state_researched then
25706: LD_VAR 0 1
25710: PPUSH
25711: LD_INT 1
25713: PPUSH
25714: CALL_OW 321
25718: PUSH
25719: LD_INT 2
25721: NONEQUAL
25722: IFFALSE 25739
// SetTech ( i , 1 , state_researched ) ;
25724: LD_VAR 0 1
25728: PPUSH
25729: LD_INT 1
25731: PPUSH
25732: LD_INT 2
25734: PPUSH
25735: CALL_OW 322
25739: GO 25703
25741: POP
25742: POP
// missionStage := 6 ;
25743: LD_ADDR_EXP 15
25747: PUSH
25748: LD_INT 6
25750: ST_TO_ADDR
// activeAttacks := true ;
25751: LD_ADDR_EXP 16
25755: PUSH
25756: LD_INT 1
25758: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25759: LD_STRING M2
25761: PPUSH
25762: CALL_OW 337
// SaveForQuickRestart ;
25766: CALL_OW 22
// wait ( 0 0$40 ) ;
25770: LD_INT 1400
25772: PPUSH
25773: CALL_OW 67
// DialogueOn ;
25777: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
25781: LD_EXP 63
25785: PPUSH
25786: LD_STRING D7-Friend-1
25788: PPUSH
25789: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D7-JMM-1
25800: PPUSH
25801: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
25805: LD_EXP 63
25809: PPUSH
25810: LD_STRING D7-Friend-2
25812: PPUSH
25813: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
25817: LD_EXP 40
25821: PPUSH
25822: LD_STRING D7-JMM-2
25824: PPUSH
25825: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
25829: LD_EXP 63
25833: PPUSH
25834: LD_STRING D7-Friend-3
25836: PPUSH
25837: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
25841: LD_EXP 40
25845: PPUSH
25846: LD_STRING D7-JMM-3
25848: PPUSH
25849: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
25853: LD_EXP 63
25857: PPUSH
25858: LD_STRING D7-Friend-4
25860: PPUSH
25861: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
25865: LD_EXP 40
25869: PPUSH
25870: LD_STRING D7-JMM-4
25872: PPUSH
25873: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
25877: LD_EXP 63
25881: PPUSH
25882: LD_STRING D7-Friend-5
25884: PPUSH
25885: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
25889: LD_EXP 40
25893: PPUSH
25894: LD_STRING D7-JMM-5
25896: PPUSH
25897: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
25901: LD_EXP 63
25905: PPUSH
25906: LD_STRING D7-Friend-6
25908: PPUSH
25909: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
25913: LD_EXP 40
25917: PPUSH
25918: LD_STRING D7-JMM-6
25920: PPUSH
25921: CALL_OW 88
// DialogueOff ;
25925: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
25929: LD_STRING Mlegion
25931: PPUSH
25932: CALL_OW 337
// skirmish := true ;
25936: LD_ADDR_EXP 97
25940: PUSH
25941: LD_INT 1
25943: ST_TO_ADDR
// RebuildKozlovFactory ;
25944: CALL 4920 0 0
// end ;
25948: PPOPN 13
25950: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
25951: LD_EXP 20
25955: PUSH
25956: LD_EXP 59
25960: PPUSH
25961: CALL_OW 300
25965: AND
25966: IFFALSE 26008
25968: GO 25970
25970: DISABLE
// begin enable ;
25971: ENABLE
// if IsInUnit ( Powell ) then
25972: LD_EXP 59
25976: PPUSH
25977: CALL_OW 310
25981: IFFALSE 25999
// CenterOnUnits ( IsInUnit ( Powell ) ) else
25983: LD_EXP 59
25987: PPUSH
25988: CALL_OW 310
25992: PPUSH
25993: CALL_OW 85
25997: GO 26008
// CenterOnUnits ( Powell ) ;
25999: LD_EXP 59
26003: PPUSH
26004: CALL_OW 85
// end ;
26008: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26009: LD_INT 22
26011: PUSH
26012: LD_INT 8
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 34
26021: PUSH
26022: LD_INT 48
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PPUSH
26033: CALL_OW 69
26037: IFFALSE 26311
26039: GO 26041
26041: DISABLE
26042: LD_INT 0
26044: PPUSH
26045: PPUSH
// begin if missionStage < 9 then
26046: LD_EXP 15
26050: PUSH
26051: LD_INT 9
26053: LESS
26054: IFFALSE 26064
// missionStage := 9 ;
26056: LD_ADDR_EXP 15
26060: PUSH
26061: LD_INT 9
26063: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26064: LD_ADDR_VAR 0 1
26068: PUSH
26069: LD_INT 22
26071: PUSH
26072: LD_INT 8
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 34
26081: PUSH
26082: LD_INT 48
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PPUSH
26093: CALL_OW 69
26097: PUSH
26098: LD_INT 1
26100: ARRAY
26101: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26102: LD_INT 175
26104: PPUSH
26105: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26109: LD_EXP 12
26113: PUSH
26114: LD_EXP 3
26118: PUSH
26119: LD_INT 0
26121: PUSH
26122: LD_INT 2
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: IN
26129: OR
26130: IFFALSE 26153
// target := [ 68 , 108 , 1 ] else
26132: LD_ADDR_VAR 0 2
26136: PUSH
26137: LD_INT 68
26139: PUSH
26140: LD_INT 108
26142: PUSH
26143: LD_INT 1
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: LIST
26150: ST_TO_ADDR
26151: GO 26172
// target := [ 181 , 88 , 2 ] ;
26153: LD_ADDR_VAR 0 2
26157: PUSH
26158: LD_INT 181
26160: PUSH
26161: LD_INT 88
26163: PUSH
26164: LD_INT 2
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: LIST
26171: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26172: LD_VAR 0 1
26176: PPUSH
26177: LD_VAR 0 2
26181: PUSH
26182: LD_INT 1
26184: ARRAY
26185: PPUSH
26186: LD_VAR 0 2
26190: PUSH
26191: LD_INT 2
26193: ARRAY
26194: PPUSH
26195: CALL_OW 176
// if target [ 3 ] = 1 then
26199: LD_VAR 0 2
26203: PUSH
26204: LD_INT 3
26206: ARRAY
26207: PUSH
26208: LD_INT 1
26210: EQUAL
26211: IFFALSE 26227
// SayRadio ( Kurt , D12-Kurt-1 ) else
26213: LD_EXP 61
26217: PPUSH
26218: LD_STRING D12-Kurt-1
26220: PPUSH
26221: CALL_OW 94
26225: GO 26251
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26227: LD_EXP 61
26231: PPUSH
26232: LD_STRING D12a-Kurt-1
26234: PPUSH
26235: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26239: LD_EXP 76
26243: PPUSH
26244: LD_STRING D12a-Roth-1
26246: PPUSH
26247: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26251: LD_INT 350
26253: PPUSH
26254: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26258: LD_VAR 0 1
26262: PPUSH
26263: LD_INT 22
26265: PUSH
26266: LD_INT 8
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: PUSH
26273: LD_INT 23
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 30
26285: PUSH
26286: LD_INT 3
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: LIST
26297: PPUSH
26298: CALL_OW 69
26302: PUSH
26303: LD_INT 1
26305: ARRAY
26306: PPUSH
26307: CALL_OW 228
// end ;
26311: PPOPN 2
26313: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26314: LD_EXP 61
26318: PPUSH
26319: CALL_OW 256
26323: PUSH
26324: LD_INT 999
26326: LESS
26327: PUSH
26328: LD_INT 22
26330: PUSH
26331: LD_INT 8
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: LD_INT 21
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 23
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: PPUSH
26363: CALL_OW 69
26367: PUSH
26368: LD_INT 9
26370: PUSH
26371: LD_INT 8
26373: PUSH
26374: LD_INT 7
26376: PUSH
26377: LD_INT 6
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: LIST
26384: LIST
26385: PUSH
26386: LD_OWVAR 67
26390: ARRAY
26391: LESSEQUAL
26392: OR
26393: PUSH
26394: LD_INT 22
26396: PUSH
26397: LD_INT 8
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 34
26406: PUSH
26407: LD_INT 48
26409: PUSH
26410: EMPTY
26411: LIST
26412: LIST
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PPUSH
26418: CALL_OW 69
26422: NOT
26423: AND
26424: PUSH
26425: LD_EXP 61
26429: PPUSH
26430: CALL_OW 302
26434: AND
26435: PUSH
26436: LD_INT 5
26438: PPUSH
26439: LD_INT 22
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PPUSH
26449: CALL_OW 70
26453: AND
26454: IFFALSE 27198
26456: GO 26458
26458: DISABLE
26459: LD_INT 0
26461: PPUSH
26462: PPUSH
26463: PPUSH
// begin legionDestroyed := true ;
26464: LD_ADDR_EXP 22
26468: PUSH
26469: LD_INT 1
26471: ST_TO_ADDR
// DialogueOn ;
26472: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26476: LD_EXP 40
26480: PPUSH
26481: LD_STRING D13-JMM-1
26483: PPUSH
26484: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26488: LD_EXP 61
26492: PPUSH
26493: LD_STRING D13-Kurt-1
26495: PPUSH
26496: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26500: LD_EXP 40
26504: PPUSH
26505: LD_STRING D13-JMM-2
26507: PPUSH
26508: CALL_OW 88
// if FakeInfo then
26512: LD_EXP 12
26516: IFFALSE 26536
// begin Say ( Kurt , D13-Kurt-2 ) ;
26518: LD_EXP 61
26522: PPUSH
26523: LD_STRING D13-Kurt-2
26525: PPUSH
26526: CALL_OW 88
// DialogueOff ;
26530: CALL_OW 7
// exit ;
26534: GO 27198
// end ; if not KurtStatus then
26536: LD_EXP 3
26540: NOT
26541: IFFALSE 26557
// Say ( Kurt , D13-Kurt-2b ) else
26543: LD_EXP 61
26547: PPUSH
26548: LD_STRING D13-Kurt-2b
26550: PPUSH
26551: CALL_OW 88
26555: GO 26569
// Say ( Kurt , D13-Kurt-2a ) ;
26557: LD_EXP 61
26561: PPUSH
26562: LD_STRING D13-Kurt-2a
26564: PPUSH
26565: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26569: LD_EXP 40
26573: PPUSH
26574: LD_STRING D13-JMM-3
26576: PPUSH
26577: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26581: LD_EXP 61
26585: PPUSH
26586: LD_STRING D13-Kurt-3
26588: PPUSH
26589: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26593: LD_EXP 40
26597: PPUSH
26598: LD_STRING D13-JMM-4
26600: PPUSH
26601: CALL_OW 88
// DialogueOff ;
26605: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26609: LD_STRING MlegionOut
26611: PPUSH
26612: CALL_OW 337
// MC_Kill ( 3 ) ;
26616: LD_INT 3
26618: PPUSH
26619: CALL 36914 0 1
// KillUnit ( Kozlov ) ;
26623: LD_EXP 62
26627: PPUSH
26628: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26632: LD_ADDR_VAR 0 1
26636: PUSH
26637: LD_INT 22
26639: PUSH
26640: LD_INT 8
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 23
26649: PUSH
26650: LD_INT 3
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 3
26659: PUSH
26660: LD_INT 21
26662: PUSH
26663: LD_INT 33
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: LIST
26678: PPUSH
26679: CALL_OW 69
26683: PUSH
26684: FOR_IN
26685: IFFALSE 26698
// KillUnit ( i ) ;
26687: LD_VAR 0 1
26691: PPUSH
26692: CALL_OW 66
26696: GO 26684
26698: POP
26699: POP
// ChangeSideFog ( 8 , 1 ) ;
26700: LD_INT 8
26702: PPUSH
26703: LD_INT 1
26705: PPUSH
26706: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26710: LD_ADDR_VAR 0 2
26714: PUSH
26715: LD_INT 22
26717: PUSH
26718: LD_INT 8
26720: PUSH
26721: EMPTY
26722: LIST
26723: LIST
26724: PUSH
26725: LD_INT 21
26727: PUSH
26728: LD_INT 1
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL_OW 69
26743: PUSH
26744: LD_EXP 62
26748: PUSH
26749: LD_EXP 61
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: DIFF
26758: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26759: LD_VAR 0 2
26763: PUSH
26764: LD_INT 6
26766: PUSH
26767: LD_INT 5
26769: PUSH
26770: LD_INT 4
26772: PUSH
26773: LD_INT 3
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: PUSH
26782: LD_OWVAR 67
26786: ARRAY
26787: GREATEREQUAL
26788: IFFALSE 26940
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26790: LD_ADDR_VAR 0 3
26794: PUSH
26795: LD_INT 6
26797: PUSH
26798: LD_INT 5
26800: PUSH
26801: LD_INT 4
26803: PUSH
26804: LD_INT 3
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: PUSH
26813: LD_OWVAR 67
26817: ARRAY
26818: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26819: LD_ADDR_VAR 0 1
26823: PUSH
26824: DOUBLE
26825: LD_VAR 0 2
26829: PUSH
26830: LD_VAR 0 3
26834: PUSH
26835: LD_INT 1
26837: PLUS
26838: MINUS
26839: INC
26840: ST_TO_ADDR
26841: LD_INT 1
26843: PUSH
26844: FOR_DOWNTO
26845: IFFALSE 26936
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
26847: LD_ADDR_EXP 38
26851: PUSH
26852: LD_EXP 38
26856: PUSH
26857: LD_VAR 0 2
26861: PUSH
26862: LD_VAR 0 1
26866: ARRAY
26867: ADD
26868: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
26869: LD_VAR 0 2
26873: PUSH
26874: LD_VAR 0 1
26878: ARRAY
26879: PPUSH
26880: CALL_OW 310
26884: IFFALSE 26901
// ComExit ( tmp [ i ] ) ;
26886: LD_VAR 0 2
26890: PUSH
26891: LD_VAR 0 1
26895: ARRAY
26896: PPUSH
26897: CALL 105176 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
26901: LD_VAR 0 2
26905: PUSH
26906: LD_VAR 0 1
26910: ARRAY
26911: PPUSH
26912: LD_INT 34
26914: PUSH
26915: LD_INT 0
26917: PPUSH
26918: LD_INT 6
26920: PPUSH
26921: CALL_OW 12
26925: PLUS
26926: PPUSH
26927: LD_INT 1
26929: PPUSH
26930: CALL_OW 171
// end ;
26934: GO 26844
26936: POP
26937: POP
// end else
26938: GO 26950
// x := tmp ;
26940: LD_ADDR_VAR 0 3
26944: PUSH
26945: LD_VAR 0 2
26949: ST_TO_ADDR
// for i := tmp downto tmp - x do
26950: LD_ADDR_VAR 0 1
26954: PUSH
26955: DOUBLE
26956: LD_VAR 0 2
26960: INC
26961: ST_TO_ADDR
26962: LD_VAR 0 2
26966: PUSH
26967: LD_VAR 0 3
26971: MINUS
26972: PUSH
26973: FOR_DOWNTO
26974: IFFALSE 27028
// begin if IsInUnit ( tmp [ i ] ) then
26976: LD_VAR 0 2
26980: PUSH
26981: LD_VAR 0 1
26985: ARRAY
26986: PPUSH
26987: CALL_OW 310
26991: IFFALSE 27008
// ComExit ( tmp [ i ] ) ;
26993: LD_VAR 0 2
26997: PUSH
26998: LD_VAR 0 1
27002: ARRAY
27003: PPUSH
27004: CALL 105176 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27008: LD_VAR 0 2
27012: PUSH
27013: LD_VAR 0 1
27017: ARRAY
27018: PPUSH
27019: LD_INT 1
27021: PPUSH
27022: CALL_OW 235
// end ;
27026: GO 26973
27028: POP
27029: POP
// wait ( 0 0$0.3 ) ;
27030: LD_INT 10
27032: PPUSH
27033: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27037: LD_ADDR_VAR 0 1
27041: PUSH
27042: LD_INT 22
27044: PUSH
27045: LD_INT 8
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 21
27054: PUSH
27055: LD_INT 2
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PPUSH
27066: CALL_OW 69
27070: PUSH
27071: FOR_IN
27072: IFFALSE 27085
// KillUnit ( i ) ;
27074: LD_VAR 0 1
27078: PPUSH
27079: CALL_OW 66
27083: GO 27071
27085: POP
27086: POP
// SetSide ( Kurt , 1 ) ;
27087: LD_EXP 61
27091: PPUSH
27092: LD_INT 1
27094: PPUSH
27095: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27099: LD_INT 22
27101: PUSH
27102: LD_INT 8
27104: PUSH
27105: EMPTY
27106: LIST
27107: LIST
27108: PUSH
27109: LD_INT 21
27111: PUSH
27112: LD_INT 3
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PPUSH
27123: CALL_OW 69
27127: PPUSH
27128: LD_INT 1
27130: PPUSH
27131: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27135: LD_INT 8
27137: PPUSH
27138: LD_INT 1
27140: PPUSH
27141: LD_INT 1
27143: PPUSH
27144: LD_INT 1
27146: PPUSH
27147: CALL_OW 80
// wait ( 1 1$20 ) ;
27151: LD_INT 2800
27153: PPUSH
27154: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27158: LD_EXP 63
27162: PPUSH
27163: LD_INT 37
27165: PPUSH
27166: LD_INT 1
27168: PPUSH
27169: LD_INT 0
27171: PPUSH
27172: CALL_OW 48
// wait ( 0 0$1 ) ;
27176: LD_INT 35
27178: PPUSH
27179: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27183: LD_EXP 63
27187: PPUSH
27188: LD_INT 60
27190: PPUSH
27191: LD_INT 95
27193: PPUSH
27194: CALL_OW 111
// end ;
27198: PPOPN 3
27200: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27201: LD_EXP 22
27205: NOT
27206: PUSH
27207: LD_INT 22
27209: PUSH
27210: LD_INT 8
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 21
27219: PUSH
27220: LD_INT 1
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PPUSH
27231: CALL_OW 69
27235: PUSH
27236: LD_INT 0
27238: EQUAL
27239: AND
27240: IFFALSE 27260
27242: GO 27244
27244: DISABLE
// begin legionDestroyed := true ;
27245: LD_ADDR_EXP 22
27249: PUSH
27250: LD_INT 1
27252: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27253: LD_STRING MlegionOut
27255: PPUSH
27256: CALL_OW 337
// end ;
27260: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27261: LD_EXP 38
27265: IFFALSE 27340
27267: GO 27269
27269: DISABLE
27270: LD_INT 0
27272: PPUSH
// begin enable ;
27273: ENABLE
// for i in legionEscapeUnits do
27274: LD_ADDR_VAR 0 1
27278: PUSH
27279: LD_EXP 38
27283: PUSH
27284: FOR_IN
27285: IFFALSE 27338
// begin if IsInArea ( i , legionEscapeArea ) then
27287: LD_VAR 0 1
27291: PPUSH
27292: LD_INT 31
27294: PPUSH
27295: CALL_OW 308
27299: IFFALSE 27312
// RemoveUnit ( i ) else
27301: LD_VAR 0 1
27305: PPUSH
27306: CALL_OW 64
27310: GO 27336
// if not HasTask ( i ) then
27312: LD_VAR 0 1
27316: PPUSH
27317: CALL_OW 314
27321: NOT
27322: IFFALSE 27336
// ComMoveToArea ( i , legionEscapeArea ) ;
27324: LD_VAR 0 1
27328: PPUSH
27329: LD_INT 31
27331: PPUSH
27332: CALL_OW 113
// end ;
27336: GO 27284
27338: POP
27339: POP
// end ;
27340: PPOPN 1
27342: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27343: LD_INT 1
27345: PPUSH
27346: LD_EXP 63
27350: PPUSH
27351: CALL_OW 292
27355: IFFALSE 27653
27357: GO 27359
27359: DISABLE
27360: LD_INT 0
27362: PPUSH
// begin wait ( 0 0$2 ) ;
27363: LD_INT 70
27365: PPUSH
27366: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27370: LD_EXP 63
27374: PPUSH
27375: CALL_OW 87
// DialogueOn ;
27379: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27383: LD_EXP 40
27387: PPUSH
27388: LD_STRING D14-JMM-1
27390: PPUSH
27391: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27395: LD_EXP 63
27399: PPUSH
27400: LD_STRING D14-Friend-1
27402: PPUSH
27403: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27407: LD_EXP 40
27411: PPUSH
27412: LD_STRING D14-JMM-2
27414: PPUSH
27415: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27419: LD_EXP 63
27423: PPUSH
27424: LD_STRING D14-Friend-2
27426: PPUSH
27427: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27431: LD_EXP 40
27435: PPUSH
27436: LD_STRING D14-JMM-3
27438: PPUSH
27439: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27443: LD_EXP 63
27447: PPUSH
27448: LD_STRING D14-Friend-3
27450: PPUSH
27451: CALL_OW 88
// DialogueOff ;
27455: CALL_OW 7
// dec = Query ( Q14 ) ;
27459: LD_ADDR_VAR 0 1
27463: PUSH
27464: LD_STRING Q14
27466: PPUSH
27467: CALL_OW 97
27471: ST_TO_ADDR
// if dec = 1 then
27472: LD_VAR 0 1
27476: PUSH
27477: LD_INT 1
27479: EQUAL
27480: IFFALSE 27514
// begin DialogueOn ;
27482: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27486: LD_EXP 40
27490: PPUSH
27491: LD_STRING D14a-JMM-1
27493: PPUSH
27494: CALL_OW 88
// DialogueOff ;
27498: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27502: LD_EXP 63
27506: PPUSH
27507: LD_INT 1
27509: PPUSH
27510: CALL_OW 235
// end ; if dec = 2 then
27514: LD_VAR 0 1
27518: PUSH
27519: LD_INT 2
27521: EQUAL
27522: IFFALSE 27575
// begin DialogueOn ;
27524: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27528: LD_EXP 40
27532: PPUSH
27533: LD_STRING D14b-JMM-1
27535: PPUSH
27536: CALL_OW 88
// DialogueOff ;
27540: CALL_OW 7
// wait ( 0 0$1 ) ;
27544: LD_INT 35
27546: PPUSH
27547: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27551: LD_EXP 63
27555: PPUSH
27556: LD_INT 9
27558: PPUSH
27559: LD_INT 2
27561: PPUSH
27562: CALL_OW 111
// AddComHold ( Friend ) ;
27566: LD_EXP 63
27570: PPUSH
27571: CALL_OW 200
// end ; if dec = 3 then
27575: LD_VAR 0 1
27579: PUSH
27580: LD_INT 3
27582: EQUAL
27583: IFFALSE 27653
// begin DialogueOn ;
27585: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27589: LD_EXP 40
27593: PPUSH
27594: LD_STRING D14c-JMM-1
27596: PPUSH
27597: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27601: LD_EXP 63
27605: PPUSH
27606: LD_STRING D14c-Friend-1
27608: PPUSH
27609: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27613: LD_EXP 40
27617: PPUSH
27618: LD_STRING D14c-JMM-2
27620: PPUSH
27621: CALL_OW 88
// DialogueOff ;
27625: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27629: LD_EXP 63
27633: PPUSH
27634: LD_INT 9
27636: PPUSH
27637: LD_INT 2
27639: PPUSH
27640: CALL_OW 111
// AddComHold ( Friend ) ;
27644: LD_EXP 63
27648: PPUSH
27649: CALL_OW 200
// end ; end ;
27653: PPOPN 1
27655: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27656: LD_INT 9
27658: PPUSH
27659: LD_INT 2
27661: PPUSH
27662: CALL_OW 428
27666: PUSH
27667: LD_EXP 63
27671: EQUAL
27672: PUSH
27673: LD_EXP 63
27677: PPUSH
27678: CALL_OW 255
27682: PUSH
27683: LD_INT 8
27685: EQUAL
27686: AND
27687: IFFALSE 27701
27689: GO 27691
27691: DISABLE
// RemoveUnit ( Friend ) ;
27692: LD_EXP 63
27696: PPUSH
27697: CALL_OW 64
27701: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27702: LD_EXP 14
27706: PUSH
27707: LD_INT 31500
27709: GREATEREQUAL
27710: PUSH
27711: LD_EXP 7
27715: AND
27716: PUSH
27717: LD_EXP 2
27721: AND
27722: IFFALSE 28152
27724: GO 27726
27726: DISABLE
27727: LD_INT 0
27729: PPUSH
27730: PPUSH
27731: PPUSH
// begin missionStage := 7 ;
27732: LD_ADDR_EXP 15
27736: PUSH
27737: LD_INT 7
27739: ST_TO_ADDR
// uc_side = 1 ;
27740: LD_ADDR_OWVAR 20
27744: PUSH
27745: LD_INT 1
27747: ST_TO_ADDR
// uc_nation = 1 ;
27748: LD_ADDR_OWVAR 21
27752: PUSH
27753: LD_INT 1
27755: ST_TO_ADDR
// for i = 1 to 5 do
27756: LD_ADDR_VAR 0 1
27760: PUSH
27761: DOUBLE
27762: LD_INT 1
27764: DEC
27765: ST_TO_ADDR
27766: LD_INT 5
27768: PUSH
27769: FOR_TO
27770: IFFALSE 27866
// begin vc_engine = 3 ;
27772: LD_ADDR_OWVAR 39
27776: PUSH
27777: LD_INT 3
27779: ST_TO_ADDR
// vc_control = 3 ;
27780: LD_ADDR_OWVAR 38
27784: PUSH
27785: LD_INT 3
27787: ST_TO_ADDR
// vc_chassis = 3 ;
27788: LD_ADDR_OWVAR 37
27792: PUSH
27793: LD_INT 3
27795: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27796: LD_ADDR_OWVAR 40
27800: PUSH
27801: LD_INT 5
27803: PUSH
27804: LD_INT 9
27806: PUSH
27807: LD_INT 7
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: PPUSH
27818: LD_INT 3
27820: PPUSH
27821: CALL_OW 12
27825: ARRAY
27826: ST_TO_ADDR
// veh = CreateVehicle ;
27827: LD_ADDR_VAR 0 2
27831: PUSH
27832: CALL_OW 45
27836: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27837: LD_VAR 0 2
27841: PPUSH
27842: LD_INT 1
27844: PPUSH
27845: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27849: LD_VAR 0 2
27853: PPUSH
27854: LD_INT 19
27856: PPUSH
27857: LD_INT 0
27859: PPUSH
27860: CALL_OW 49
// end ;
27864: GO 27769
27866: POP
27867: POP
// vc_engine = 3 ;
27868: LD_ADDR_OWVAR 39
27872: PUSH
27873: LD_INT 3
27875: ST_TO_ADDR
// vc_control = 1 ;
27876: LD_ADDR_OWVAR 38
27880: PUSH
27881: LD_INT 1
27883: ST_TO_ADDR
// vc_chassis = 3 ;
27884: LD_ADDR_OWVAR 37
27888: PUSH
27889: LD_INT 3
27891: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27892: LD_ADDR_OWVAR 40
27896: PUSH
27897: LD_INT 5
27899: PUSH
27900: LD_INT 9
27902: PUSH
27903: LD_INT 7
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: PUSH
27911: LD_INT 1
27913: PPUSH
27914: LD_INT 3
27916: PPUSH
27917: CALL_OW 12
27921: ARRAY
27922: ST_TO_ADDR
// vehG = CreateVehicle ;
27923: LD_ADDR_VAR 0 3
27927: PUSH
27928: CALL_OW 45
27932: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
27933: LD_VAR 0 3
27937: PPUSH
27938: LD_INT 1
27940: PPUSH
27941: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
27945: LD_VAR 0 3
27949: PPUSH
27950: LD_INT 19
27952: PPUSH
27953: LD_INT 0
27955: PPUSH
27956: CALL_OW 49
// if JMMGirl = 1 then
27960: LD_EXP 7
27964: PUSH
27965: LD_INT 1
27967: EQUAL
27968: IFFALSE 28024
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
27970: LD_ADDR_EXP 41
27974: PUSH
27975: LD_STRING Joan
27977: PPUSH
27978: LD_INT 1
27980: PPUSH
27981: LD_STRING 14_
27983: PPUSH
27984: CALL 67329 0 3
27988: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
27989: LD_EXP 41
27993: PPUSH
27994: LD_VAR 0 3
27998: PPUSH
27999: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28003: LD_VAR 0 3
28007: PPUSH
28008: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28012: LD_EXP 41
28016: PPUSH
28017: LD_STRING D10BW-Joan-1
28019: PPUSH
28020: CALL_OW 94
// end ; if JMMGirl = 2 then
28024: LD_EXP 7
28028: PUSH
28029: LD_INT 2
28031: EQUAL
28032: IFFALSE 28088
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28034: LD_ADDR_EXP 43
28038: PUSH
28039: LD_STRING Lisa
28041: PPUSH
28042: LD_INT 1
28044: PPUSH
28045: LD_STRING 14_
28047: PPUSH
28048: CALL 67329 0 3
28052: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28053: LD_EXP 43
28057: PPUSH
28058: LD_VAR 0 3
28062: PPUSH
28063: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28067: LD_VAR 0 3
28071: PPUSH
28072: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28076: LD_EXP 43
28080: PPUSH
28081: LD_STRING D10BW-Lisa-1
28083: PPUSH
28084: CALL_OW 94
// end ; if JMMGirl = 3 then
28088: LD_EXP 7
28092: PUSH
28093: LD_INT 3
28095: EQUAL
28096: IFFALSE 28152
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28098: LD_ADDR_EXP 55
28102: PUSH
28103: LD_STRING Connie
28105: PPUSH
28106: LD_INT 1
28108: PPUSH
28109: LD_STRING 14_
28111: PPUSH
28112: CALL 67329 0 3
28116: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28117: LD_EXP 55
28121: PPUSH
28122: LD_VAR 0 3
28126: PPUSH
28127: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28131: LD_VAR 0 3
28135: PPUSH
28136: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28140: LD_EXP 55
28144: PPUSH
28145: LD_STRING D10BW-Con-1
28147: PPUSH
28148: CALL_OW 94
// end ; end ;
28152: PPOPN 3
28154: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28155: LD_EXP 14
28159: PUSH
28160: LD_INT 94500
28162: GREATEREQUAL
28163: IFFALSE 28575
28165: GO 28167
28167: DISABLE
28168: LD_INT 0
28170: PPUSH
28171: PPUSH
28172: PPUSH
// begin tmp := PrepareStevensSquad ;
28173: LD_ADDR_VAR 0 3
28177: PUSH
28178: CALL 2323 0 0
28182: ST_TO_ADDR
// if not tmp then
28183: LD_VAR 0 3
28187: NOT
28188: IFFALSE 28192
// exit ;
28190: GO 28575
// uc_side := 1 ;
28192: LD_ADDR_OWVAR 20
28196: PUSH
28197: LD_INT 1
28199: ST_TO_ADDR
// uc_nation := 1 ;
28200: LD_ADDR_OWVAR 21
28204: PUSH
28205: LD_INT 1
28207: ST_TO_ADDR
// for i in tmp do
28208: LD_ADDR_VAR 0 1
28212: PUSH
28213: LD_VAR 0 3
28217: PUSH
28218: FOR_IN
28219: IFFALSE 28316
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28221: LD_INT 3
28223: PPUSH
28224: LD_INT 3
28226: PPUSH
28227: LD_INT 1
28229: PPUSH
28230: LD_INT 5
28232: PUSH
28233: LD_INT 9
28235: PUSH
28236: LD_INT 7
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: PUSH
28244: LD_INT 1
28246: PPUSH
28247: LD_INT 3
28249: PPUSH
28250: CALL_OW 12
28254: ARRAY
28255: PPUSH
28256: LD_INT 40
28258: PPUSH
28259: CALL 72344 0 5
// veh := CreateVehicle ;
28263: LD_ADDR_VAR 0 2
28267: PUSH
28268: CALL_OW 45
28272: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28273: LD_VAR 0 2
28277: PPUSH
28278: LD_INT 1
28280: PPUSH
28281: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28285: LD_VAR 0 2
28289: PPUSH
28290: LD_INT 19
28292: PPUSH
28293: LD_INT 0
28295: PPUSH
28296: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28300: LD_VAR 0 1
28304: PPUSH
28305: LD_VAR 0 2
28309: PPUSH
28310: CALL_OW 52
// end ;
28314: GO 28218
28316: POP
28317: POP
// missionStage := 8 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 8
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// if Stevens then
28330: LD_EXP 42
28334: IFFALSE 28448
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28336: LD_EXP 42
28340: PPUSH
28341: CALL_OW 310
28345: PPUSH
28346: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28350: LD_EXP 42
28354: PPUSH
28355: LD_STRING D8-Huck-1
28357: PPUSH
28358: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28362: LD_EXP 40
28366: PPUSH
28367: LD_STRING D8-JMM-1
28369: PPUSH
28370: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28374: LD_EXP 42
28378: PPUSH
28379: LD_STRING D8-Huck-2
28381: PPUSH
28382: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28386: LD_EXP 40
28390: PPUSH
28391: LD_STRING D8-JMM-2
28393: PPUSH
28394: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28398: LD_EXP 42
28402: PPUSH
28403: LD_STRING D8-Huck-3
28405: PPUSH
28406: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28410: LD_EXP 40
28414: PPUSH
28415: LD_STRING D8-JMM-3
28417: PPUSH
28418: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28422: LD_EXP 42
28426: PPUSH
28427: LD_STRING D8-Huck-4
28429: PPUSH
28430: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28434: LD_EXP 40
28438: PPUSH
28439: LD_STRING D8-JMM-4
28441: PPUSH
28442: CALL_OW 88
// end else
28446: GO 28558
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28448: LD_EXP 56
28452: PPUSH
28453: CALL_OW 310
28457: PPUSH
28458: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28462: LD_EXP 56
28466: PPUSH
28467: LD_STRING D8-Huck-1
28469: PPUSH
28470: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28474: LD_EXP 40
28478: PPUSH
28479: LD_STRING D8-JMM-1a
28481: PPUSH
28482: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28486: LD_EXP 56
28490: PPUSH
28491: LD_STRING D8-Huck-2
28493: PPUSH
28494: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28498: LD_EXP 40
28502: PPUSH
28503: LD_STRING D8-JMM-2
28505: PPUSH
28506: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28510: LD_EXP 56
28514: PPUSH
28515: LD_STRING D8-Huck-3
28517: PPUSH
28518: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28522: LD_EXP 40
28526: PPUSH
28527: LD_STRING D8-JMM-3
28529: PPUSH
28530: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28534: LD_EXP 56
28538: PPUSH
28539: LD_STRING D8-Huck-4
28541: PPUSH
28542: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28546: LD_EXP 40
28550: PPUSH
28551: LD_STRING D8-JMM-4
28553: PPUSH
28554: CALL_OW 88
// end ; DialogueOff ;
28558: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28562: LD_INT 25
28564: PPUSH
28565: LD_INT 1
28567: PPUSH
28568: LD_INT 1
28570: PPUSH
28571: CALL_OW 322
// end ;
28575: PPOPN 3
28577: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
28578: LD_INT 1
28580: PPUSH
28581: LD_EXP 72
28585: PPUSH
28586: CALL_OW 292
28590: IFFALSE 28841
28592: GO 28594
28594: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28595: LD_EXP 72
28599: PPUSH
28600: CALL_OW 87
// DialogueOn ;
28604: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28608: LD_EXP 40
28612: PPUSH
28613: LD_STRING D10nB-JMM-1
28615: PPUSH
28616: CALL_OW 88
// if BurlakStatus = 1 then
28620: LD_EXP 9
28624: PUSH
28625: LD_INT 1
28627: EQUAL
28628: IFFALSE 28642
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28630: LD_EXP 71
28634: PPUSH
28635: LD_STRING D10nB-Vse-1a
28637: PPUSH
28638: CALL_OW 94
// end ; if BurlakStatus = 0 then
28642: LD_EXP 9
28646: PUSH
28647: LD_INT 0
28649: EQUAL
28650: IFFALSE 28664
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28652: LD_EXP 71
28656: PPUSH
28657: LD_STRING D10nB-Vse-1
28659: PPUSH
28660: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28664: LD_EXP 40
28668: PPUSH
28669: LD_STRING D10nB-JMM-2
28671: PPUSH
28672: CALL_OW 88
// if KappaStatus then
28676: LD_EXP 2
28680: IFFALSE 28694
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28682: LD_EXP 71
28686: PPUSH
28687: LD_STRING D10nB-Vse-5a
28689: PPUSH
28690: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28694: LD_EXP 2
28698: NOT
28699: PUSH
28700: LD_EXP 6
28704: PUSH
28705: LD_INT 0
28707: EQUAL
28708: AND
28709: IFFALSE 28837
// begin if JMMGirl = 1 then
28711: LD_EXP 7
28715: PUSH
28716: LD_INT 1
28718: EQUAL
28719: IFFALSE 28769
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28721: LD_EXP 71
28725: PPUSH
28726: LD_STRING D10nB-Vse-2
28728: PPUSH
28729: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28733: LD_EXP 40
28737: PPUSH
28738: LD_STRING D10nB-JMM-3
28740: PPUSH
28741: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28745: LD_EXP 71
28749: PPUSH
28750: LD_STRING D10nB-Vse-3
28752: PPUSH
28753: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28757: LD_EXP 40
28761: PPUSH
28762: LD_STRING D10nB-JMM-4
28764: PPUSH
28765: CALL_OW 88
// end ; if JMMGirl = 2 then
28769: LD_EXP 7
28773: PUSH
28774: LD_INT 2
28776: EQUAL
28777: IFFALSE 28803
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28779: LD_EXP 71
28783: PPUSH
28784: LD_STRING D10nB-Vse-4
28786: PPUSH
28787: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28791: LD_EXP 40
28795: PPUSH
28796: LD_STRING D10nB-JMM-5
28798: PPUSH
28799: CALL_OW 88
// end ; if JMMGirl = 3 then
28803: LD_EXP 7
28807: PUSH
28808: LD_INT 3
28810: EQUAL
28811: IFFALSE 28837
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28813: LD_EXP 71
28817: PPUSH
28818: LD_STRING D10nB-Vse-5
28820: PPUSH
28821: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
28825: LD_EXP 40
28829: PPUSH
28830: LD_STRING D10nB-JMM-6
28832: PPUSH
28833: CALL_OW 88
// end ; end ; DialogueOff ;
28837: CALL_OW 7
// end ;
28841: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
28842: LD_EXP 14
28846: PUSH
28847: LD_INT 115500
28849: GREATEREQUAL
28850: IFFALSE 29226
28852: GO 28854
28854: DISABLE
28855: LD_INT 0
28857: PPUSH
// begin missionStage := 10 ;
28858: LD_ADDR_EXP 15
28862: PUSH
28863: LD_INT 10
28865: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28866: LD_ADDR_VAR 0 1
28870: PUSH
28871: LD_INT 22
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 23
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 26
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 3
28903: PUSH
28904: LD_INT 25
28906: PUSH
28907: LD_INT 12
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 3
28920: PUSH
28921: LD_INT 25
28923: PUSH
28924: LD_INT 16
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: PPUSH
28942: CALL_OW 69
28946: PUSH
28947: LD_EXP 40
28951: PUSH
28952: LD_EXP 61
28956: PUSH
28957: LD_EXP 42
28961: PUSH
28962: LD_EXP 56
28966: PUSH
28967: LD_EXP 43
28971: PUSH
28972: LD_EXP 44
28976: PUSH
28977: LD_EXP 45
28981: PUSH
28982: LD_EXP 46
28986: PUSH
28987: LD_EXP 47
28991: PUSH
28992: LD_EXP 48
28996: PUSH
28997: LD_EXP 49
29001: PUSH
29002: LD_EXP 50
29006: PUSH
29007: LD_EXP 51
29011: PUSH
29012: LD_EXP 52
29016: PUSH
29017: LD_EXP 53
29021: PUSH
29022: LD_EXP 54
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: DIFF
29045: ST_TO_ADDR
// if not tmp and Brown then
29046: LD_VAR 0 1
29050: NOT
29051: PUSH
29052: LD_EXP 48
29056: AND
29057: IFFALSE 29072
// tmp := [ Brown ] ;
29059: LD_ADDR_VAR 0 1
29063: PUSH
29064: LD_EXP 48
29068: PUSH
29069: EMPTY
29070: LIST
29071: ST_TO_ADDR
// DialogueOn ;
29072: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29076: LD_VAR 0 1
29080: PUSH
29081: LD_INT 1
29083: ARRAY
29084: PPUSH
29085: LD_STRING D11-Sol1-1
29087: PPUSH
29088: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29092: LD_EXP 65
29096: PPUSH
29097: LD_STRING D11-Pla-1
29099: PPUSH
29100: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29104: LD_EXP 66
29108: PPUSH
29109: LD_STRING D11-Kov-1
29111: PPUSH
29112: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29116: LD_EXP 65
29120: PPUSH
29121: LD_STRING D11-Pla-2
29123: PPUSH
29124: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29128: LD_VAR 0 1
29132: PUSH
29133: LD_INT 1
29135: ARRAY
29136: PPUSH
29137: LD_STRING D11-Sol1-2
29139: PPUSH
29140: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29144: LD_EXP 40
29148: PPUSH
29149: LD_STRING D11-JMM-2
29151: PPUSH
29152: CALL_OW 88
// DialogueOff ;
29156: CALL_OW 7
// allowBehemothConstruct := true ;
29160: LD_ADDR_EXP 25
29164: PUSH
29165: LD_INT 1
29167: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29168: LD_STRING M4
29170: PPUSH
29171: CALL_OW 337
// BuildBehemoths ;
29175: CALL 7787 0 0
// repeat wait ( 15 15$00 ) ;
29179: LD_INT 31500
29181: PPUSH
29182: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29186: LD_EXP 27
29190: IFFALSE 29194
// break ;
29192: GO 29226
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29194: LD_INT 267
29196: PPUSH
29197: CALL_OW 274
29201: PPUSH
29202: LD_INT 1
29204: PPUSH
29205: CALL_OW 275
29209: PUSH
29210: LD_INT 1000
29212: GREATEREQUAL
29213: IFFALSE 29219
// BuildBehemoths ;
29215: CALL 7787 0 0
// until not behemothBuilders ;
29219: LD_EXP 74
29223: NOT
29224: IFFALSE 29179
// end ;
29226: PPOPN 1
29228: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29229: LD_EXP 74
29233: NOT
29234: PUSH
29235: LD_EXP 28
29239: NOT
29240: AND
29241: PUSH
29242: LD_EXP 25
29246: AND
29247: IFFALSE 29267
29249: GO 29251
29251: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29252: LD_STRING M4a
29254: PPUSH
29255: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29259: LD_ADDR_EXP 27
29263: PUSH
29264: LD_INT 1
29266: ST_TO_ADDR
// end ;
29267: END
// every 0 0$1 trigger behemothDone do
29268: LD_EXP 28
29272: IFFALSE 29284
29274: GO 29276
29276: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29277: LD_STRING M4b
29279: PPUSH
29280: CALL_OW 337
29284: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29285: LD_EXP 29
29289: NOT
29290: IFFALSE 29486
29292: GO 29294
29294: DISABLE
29295: LD_INT 0
29297: PPUSH
29298: PPUSH
// begin enable ;
29299: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29300: LD_ADDR_VAR 0 1
29304: PUSH
29305: LD_INT 3
29307: PPUSH
29308: CALL 104839 0 1
29312: ST_TO_ADDR
// if not tmp and not behemothDone then
29313: LD_VAR 0 1
29317: NOT
29318: PUSH
29319: LD_EXP 28
29323: NOT
29324: AND
29325: IFFALSE 29361
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29327: LD_ADDR_VAR 0 1
29331: PUSH
29332: LD_INT 22
29334: PUSH
29335: LD_INT 3
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 30
29344: PUSH
29345: LD_INT 37
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PPUSH
29356: CALL_OW 69
29360: ST_TO_ADDR
// if not tmp then
29361: LD_VAR 0 1
29365: NOT
29366: IFFALSE 29370
// exit ;
29368: GO 29486
// for i in tmp do
29370: LD_ADDR_VAR 0 2
29374: PUSH
29375: LD_VAR 0 1
29379: PUSH
29380: FOR_IN
29381: IFFALSE 29484
// if See ( 1 , i ) then
29383: LD_INT 1
29385: PPUSH
29386: LD_VAR 0 2
29390: PPUSH
29391: CALL_OW 292
29395: IFFALSE 29482
// begin if GetType ( i ) = unit_building then
29397: LD_VAR 0 2
29401: PPUSH
29402: CALL_OW 247
29406: PUSH
29407: LD_INT 3
29409: EQUAL
29410: IFFALSE 29448
// begin disable ;
29412: DISABLE
// CenterNowOnUnits ( i ) ;
29413: LD_VAR 0 2
29417: PPUSH
29418: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29422: LD_EXP 40
29426: PPUSH
29427: LD_STRING D17a-JMM-1
29429: PPUSH
29430: CALL_OW 88
// seeBehemoth := true ;
29434: LD_ADDR_EXP 29
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// exit ;
29442: POP
29443: POP
29444: GO 29486
// end else
29446: GO 29482
// begin disable ;
29448: DISABLE
// CenterNowOnUnits ( i ) ;
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29458: LD_EXP 40
29462: PPUSH
29463: LD_STRING D17b-JMM-1
29465: PPUSH
29466: CALL_OW 88
// seeBehemoth := true ;
29470: LD_ADDR_EXP 29
29474: PUSH
29475: LD_INT 1
29477: ST_TO_ADDR
// exit ;
29478: POP
29479: POP
29480: GO 29486
// end ; end ;
29482: GO 29380
29484: POP
29485: POP
// end ;
29486: PPOPN 2
29488: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29489: LD_EXP 14
29493: PUSH
29494: LD_INT 123200
29496: GREATEREQUAL
29497: IFFALSE 30697
29499: GO 29501
29501: DISABLE
29502: LD_INT 0
29504: PPUSH
29505: PPUSH
29506: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29507: LD_INT 2
29509: PPUSH
29510: LD_INT 23
29512: PUSH
29513: LD_INT 3
29515: PUSH
29516: LD_INT 3
29518: PUSH
29519: LD_INT 48
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: PUSH
29528: EMPTY
29529: LIST
29530: PPUSH
29531: CALL 60941 0 2
// repeat wait ( 0 0$1 ) ;
29535: LD_INT 35
29537: PPUSH
29538: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29542: LD_INT 22
29544: PUSH
29545: LD_INT 3
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 34
29554: PUSH
29555: LD_INT 48
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PPUSH
29566: CALL_OW 69
29570: IFFALSE 29535
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29572: LD_ADDR_VAR 0 1
29576: PUSH
29577: LD_INT 22
29579: PUSH
29580: LD_INT 3
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 34
29589: PUSH
29590: LD_INT 48
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PPUSH
29601: CALL_OW 69
29605: PUSH
29606: LD_INT 1
29608: ARRAY
29609: ST_TO_ADDR
// missionStage := 12 ;
29610: LD_ADDR_EXP 15
29614: PUSH
29615: LD_INT 12
29617: ST_TO_ADDR
// platonovHasBomb := true ;
29618: LD_ADDR_EXP 30
29622: PUSH
29623: LD_INT 1
29625: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29626: LD_VAR 0 1
29630: PPUSH
29631: LD_INT 181
29633: PPUSH
29634: LD_INT 86
29636: PPUSH
29637: CALL_OW 171
// AddComHold ( bomb ) ;
29641: LD_VAR 0 1
29645: PPUSH
29646: CALL_OW 200
// wait ( 0 0$10 ) ;
29650: LD_INT 350
29652: PPUSH
29653: CALL_OW 67
// DialogueOn ;
29657: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29661: LD_EXP 65
29665: PPUSH
29666: LD_STRING D15-Pla-1
29668: PPUSH
29669: CALL_OW 94
// dec = Query ( Q15a ) ;
29673: LD_ADDR_VAR 0 2
29677: PUSH
29678: LD_STRING Q15a
29680: PPUSH
29681: CALL_OW 97
29685: ST_TO_ADDR
// if dec = 1 then
29686: LD_VAR 0 2
29690: PUSH
29691: LD_INT 1
29693: EQUAL
29694: IFFALSE 29717
// begin Say ( JMM , D15a-JMM-1 ) ;
29696: LD_EXP 40
29700: PPUSH
29701: LD_STRING D15a-JMM-1
29703: PPUSH
29704: CALL_OW 88
// YouLost ( Surrender ) ;
29708: LD_STRING Surrender
29710: PPUSH
29711: CALL_OW 104
// exit ;
29715: GO 30697
// end ; if dec = 2 then
29717: LD_VAR 0 2
29721: PUSH
29722: LD_INT 2
29724: EQUAL
29725: IFFALSE 29794
// begin Say ( JMM , D15b-JMM-1 ) ;
29727: LD_EXP 40
29731: PPUSH
29732: LD_STRING D15b-JMM-1
29734: PPUSH
29735: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29739: LD_EXP 65
29743: PPUSH
29744: LD_STRING D15b-Pla-1
29746: PPUSH
29747: CALL_OW 94
// DialogueOff ;
29751: CALL_OW 7
// wait ( 3 3$00 ) ;
29755: LD_INT 6300
29757: PPUSH
29758: CALL_OW 67
// DialogueOn ;
29762: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29766: LD_EXP 40
29770: PPUSH
29771: LD_STRING D15d-JMM-1a
29773: PPUSH
29774: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29778: LD_EXP 65
29782: PPUSH
29783: LD_STRING D15d-Pla-1
29785: PPUSH
29786: CALL_OW 94
// DialogueOff ;
29790: CALL_OW 7
// end ; if dec = 3 then
29794: LD_VAR 0 2
29798: PUSH
29799: LD_INT 3
29801: EQUAL
29802: IFFALSE 29856
// begin Say ( JMM , D15c-JMM-1 ) ;
29804: LD_EXP 40
29808: PPUSH
29809: LD_STRING D15c-JMM-1
29811: PPUSH
29812: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29816: LD_EXP 65
29820: PPUSH
29821: LD_STRING D15c-Pla-1
29823: PPUSH
29824: CALL_OW 94
// DialogueOff ;
29828: CALL_OW 7
// wait ( 0 0$15 ) ;
29832: LD_INT 525
29834: PPUSH
29835: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
29839: LD_VAR 0 1
29843: PPUSH
29844: LD_INT 60
29846: PPUSH
29847: LD_INT 95
29849: PPUSH
29850: CALL_OW 116
// exit ;
29854: GO 30697
// end ; if dec = 4 then
29856: LD_VAR 0 2
29860: PUSH
29861: LD_INT 4
29863: EQUAL
29864: IFFALSE 29894
// begin Say ( JMM , D15d-JMM-1 ) ;
29866: LD_EXP 40
29870: PPUSH
29871: LD_STRING D15d-JMM-1
29873: PPUSH
29874: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29878: LD_EXP 65
29882: PPUSH
29883: LD_STRING D15d-Pla-1
29885: PPUSH
29886: CALL_OW 94
// DialogueOff ;
29890: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29894: LD_EXP 63
29898: PPUSH
29899: CALL_OW 302
29903: PUSH
29904: LD_EXP 63
29908: PPUSH
29909: CALL_OW 255
29913: PUSH
29914: LD_INT 1
29916: EQUAL
29917: AND
29918: PUSH
29919: LD_INT 22
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 34
29931: PUSH
29932: LD_INT 8
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PPUSH
29943: CALL_OW 69
29947: NOT
29948: AND
29949: IFFALSE 30598
// begin SetSide ( Friend , 8 ) ;
29951: LD_EXP 63
29955: PPUSH
29956: LD_INT 8
29958: PPUSH
29959: CALL_OW 235
// if IsInUnit ( Friend ) then
29963: LD_EXP 63
29967: PPUSH
29968: CALL_OW 310
29972: IFFALSE 29983
// ComExitBuilding ( Friend ) ;
29974: LD_EXP 63
29978: PPUSH
29979: CALL_OW 122
// if IsDriver ( Friend ) then
29983: LD_EXP 63
29987: PPUSH
29988: CALL 102387 0 1
29992: IFFALSE 30003
// ComExitVehicle ( Friend ) ;
29994: LD_EXP 63
29998: PPUSH
29999: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30003: LD_EXP 63
30007: PPUSH
30008: LD_INT 9
30010: PPUSH
30011: LD_INT 2
30013: PPUSH
30014: CALL_OW 171
// wait ( 0 0$05 ) ;
30018: LD_INT 175
30020: PPUSH
30021: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30025: LD_EXP 63
30029: PPUSH
30030: CALL_OW 87
// DialogueOn ;
30034: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30038: LD_EXP 40
30042: PPUSH
30043: LD_STRING D16-JMM-1
30045: PPUSH
30046: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30050: LD_EXP 63
30054: PPUSH
30055: LD_STRING D16-Friend-1
30057: PPUSH
30058: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30062: LD_EXP 40
30066: PPUSH
30067: LD_STRING D16-JMM-2
30069: PPUSH
30070: CALL_OW 88
// DialogueOff ;
30074: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30078: LD_EXP 63
30082: PPUSH
30083: LD_INT 1
30085: PPUSH
30086: CALL_OW 235
// ComHold ( Friend ) ;
30090: LD_EXP 63
30094: PPUSH
30095: CALL_OW 140
// wait ( 0 0$20 ) ;
30099: LD_INT 700
30101: PPUSH
30102: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30106: LD_EXP 63
30110: PPUSH
30111: LD_INT 9
30113: PPUSH
30114: LD_INT 2
30116: PPUSH
30117: CALL_OW 297
30121: PUSH
30122: LD_INT 30
30124: LESS
30125: IFFALSE 30194
// begin SetSide ( Friend , 8 ) ;
30127: LD_EXP 63
30131: PPUSH
30132: LD_INT 8
30134: PPUSH
30135: CALL_OW 235
// if IsInUnit ( Friend ) then
30139: LD_EXP 63
30143: PPUSH
30144: CALL_OW 310
30148: IFFALSE 30159
// ComExitBuilding ( Friend ) ;
30150: LD_EXP 63
30154: PPUSH
30155: CALL_OW 122
// if IsDriver ( Friend ) then
30159: LD_EXP 63
30163: PPUSH
30164: CALL 102387 0 1
30168: IFFALSE 30179
// ComExitVehicle ( Friend ) ;
30170: LD_EXP 63
30174: PPUSH
30175: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30179: LD_EXP 63
30183: PPUSH
30184: LD_INT 9
30186: PPUSH
30187: LD_INT 2
30189: PPUSH
30190: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30194: LD_INT 1050
30196: PPUSH
30197: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30201: LD_INT 22
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 34
30213: PUSH
30214: LD_INT 8
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PPUSH
30225: CALL_OW 69
30229: NOT
30230: IFFALSE 30576
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30232: LD_ADDR_VAR 0 3
30236: PUSH
30237: LD_INT 22
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 26
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 3
30259: PUSH
30260: LD_INT 25
30262: PUSH
30263: LD_INT 12
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 25
30272: PUSH
30273: LD_INT 16
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: LIST
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: LIST
30289: PPUSH
30290: CALL_OW 69
30294: PUSH
30295: LD_EXP 40
30299: PUSH
30300: LD_EXP 42
30304: PUSH
30305: LD_EXP 56
30309: PUSH
30310: LD_EXP 43
30314: PUSH
30315: LD_EXP 44
30319: PUSH
30320: LD_EXP 45
30324: PUSH
30325: LD_EXP 46
30329: PUSH
30330: LD_EXP 47
30334: PUSH
30335: LD_EXP 48
30339: PUSH
30340: LD_EXP 49
30344: PUSH
30345: LD_EXP 50
30349: PUSH
30350: LD_EXP 51
30354: PUSH
30355: LD_EXP 52
30359: PUSH
30360: LD_EXP 53
30364: PUSH
30365: LD_EXP 54
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: LIST
30374: LIST
30375: LIST
30376: LIST
30377: LIST
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: DIFF
30387: ST_TO_ADDR
// DialogueOn ;
30388: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30392: LD_EXP 65
30396: PPUSH
30397: LD_STRING D16a-Pla-1
30399: PPUSH
30400: CALL_OW 94
// if Stevens then
30404: LD_EXP 42
30408: IFFALSE 30424
// Say ( Stevens , D16a-Huck-1 ) else
30410: LD_EXP 42
30414: PPUSH
30415: LD_STRING D16a-Huck-1
30417: PPUSH
30418: CALL_OW 88
30422: GO 30466
// if Baker then
30424: LD_EXP 56
30428: IFFALSE 30444
// Say ( Baker , D16a-Huck-1 ) else
30430: LD_EXP 56
30434: PPUSH
30435: LD_STRING D16a-Huck-1
30437: PPUSH
30438: CALL_OW 88
30442: GO 30466
// if tmp then
30444: LD_VAR 0 3
30448: IFFALSE 30466
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30450: LD_VAR 0 3
30454: PUSH
30455: LD_INT 1
30457: ARRAY
30458: PPUSH
30459: LD_STRING D16a-Sol1-1
30461: PPUSH
30462: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30466: LD_EXP 63
30470: PPUSH
30471: CALL_OW 255
30475: PUSH
30476: LD_INT 8
30478: EQUAL
30479: IFFALSE 30495
// Say ( JMM , D16a-JMM-1 ) else
30481: LD_EXP 40
30485: PPUSH
30486: LD_STRING D16a-JMM-1
30488: PPUSH
30489: CALL_OW 88
30493: GO 30555
// begin Say ( JMM , D16a-JMM-1a ) ;
30495: LD_EXP 40
30499: PPUSH
30500: LD_STRING D16a-JMM-1a
30502: PPUSH
30503: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30507: LD_EXP 63
30511: PPUSH
30512: LD_STRING D16a-Friend-1
30514: PPUSH
30515: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30519: LD_EXP 63
30523: PPUSH
30524: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30528: LD_EXP 63
30532: PPUSH
30533: LD_INT 191
30535: PPUSH
30536: LD_INT 103
30538: PPUSH
30539: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30543: LD_EXP 63
30547: PPUSH
30548: LD_INT 3
30550: PPUSH
30551: CALL_OW 235
// end ; DialogueOff ;
30555: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30559: LD_VAR 0 1
30563: PPUSH
30564: LD_INT 60
30566: PPUSH
30567: LD_INT 95
30569: PPUSH
30570: CALL_OW 116
// end else
30574: GO 30596
// begin DialogueOn ;
30576: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30580: LD_EXP 65
30584: PPUSH
30585: LD_STRING D16c-Pla-1
30587: PPUSH
30588: CALL_OW 94
// DialogueOff ;
30592: CALL_OW 7
// end ; end else
30596: GO 30697
// begin wait ( 3 3$00 ) ;
30598: LD_INT 6300
30600: PPUSH
30601: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30605: LD_INT 22
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 34
30617: PUSH
30618: LD_INT 8
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PPUSH
30629: CALL_OW 69
30633: NOT
30634: IFFALSE 30677
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30636: LD_EXP 65
30640: PPUSH
30641: LD_STRING D16b-Pla-1
30643: PPUSH
30644: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30648: LD_EXP 40
30652: PPUSH
30653: LD_STRING D16b-JMM-1
30655: PPUSH
30656: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30660: LD_VAR 0 1
30664: PPUSH
30665: LD_INT 60
30667: PPUSH
30668: LD_INT 95
30670: PPUSH
30671: CALL_OW 116
// end else
30675: GO 30697
// begin DialogueOn ;
30677: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30681: LD_EXP 65
30685: PPUSH
30686: LD_STRING D16c-Pla-1
30688: PPUSH
30689: CALL_OW 94
// DialogueOff ;
30693: CALL_OW 7
// end ; end ; end ;
30697: PPOPN 3
30699: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30700: LD_EXP 14
30704: PUSH
30705: LD_INT 126000
30707: GREATEREQUAL
30708: PUSH
30709: LD_EXP 23
30713: NOT
30714: AND
30715: PUSH
30716: LD_EXP 76
30720: PPUSH
30721: CALL_OW 302
30725: AND
30726: IFFALSE 31084
30728: GO 30730
30730: DISABLE
30731: LD_INT 0
30733: PPUSH
// begin missionStage = 11 ;
30734: LD_ADDR_EXP 15
30738: PUSH
30739: LD_INT 11
30741: ST_TO_ADDR
// DialogueOn ;
30742: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30746: LD_EXP 76
30750: PPUSH
30751: LD_STRING D9-Roth-1
30753: PPUSH
30754: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30758: LD_EXP 40
30762: PPUSH
30763: LD_STRING D9-JMM-1
30765: PPUSH
30766: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30770: LD_EXP 76
30774: PPUSH
30775: LD_STRING D9-Roth-2
30777: PPUSH
30778: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30782: LD_EXP 76
30786: PPUSH
30787: LD_STRING D9-Roth-2a
30789: PPUSH
30790: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30794: LD_EXP 65
30798: PPUSH
30799: LD_STRING D9-Pla-2
30801: PPUSH
30802: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30806: LD_EXP 76
30810: PPUSH
30811: LD_STRING D9-Roth-3
30813: PPUSH
30814: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30818: LD_EXP 65
30822: PPUSH
30823: LD_STRING D9-Pla-3
30825: PPUSH
30826: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
30830: LD_EXP 76
30834: PPUSH
30835: LD_STRING D9-Roth-4
30837: PPUSH
30838: CALL_OW 94
// dec = Query ( Q9 ) ;
30842: LD_ADDR_VAR 0 1
30846: PUSH
30847: LD_STRING Q9
30849: PPUSH
30850: CALL_OW 97
30854: ST_TO_ADDR
// if dec = 1 then
30855: LD_VAR 0 1
30859: PUSH
30860: LD_INT 1
30862: EQUAL
30863: IFFALSE 30877
// SayRadio ( Roth , D9a-Roth-1 ) ;
30865: LD_EXP 76
30869: PPUSH
30870: LD_STRING D9a-Roth-1
30872: PPUSH
30873: CALL_OW 94
// if dec = 2 then
30877: LD_VAR 0 1
30881: PUSH
30882: LD_INT 2
30884: EQUAL
30885: IFFALSE 30911
// begin Say ( JMM , D9b-JMM-1 ) ;
30887: LD_EXP 40
30891: PPUSH
30892: LD_STRING D9b-JMM-1
30894: PPUSH
30895: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
30899: LD_EXP 76
30903: PPUSH
30904: LD_STRING D9b-Roth-1
30906: PPUSH
30907: CALL_OW 94
// end ; if dec = 3 then
30911: LD_VAR 0 1
30915: PUSH
30916: LD_INT 3
30918: EQUAL
30919: IFFALSE 30981
// begin Say ( JMM , D9c-JMM-1 ) ;
30921: LD_EXP 40
30925: PPUSH
30926: LD_STRING D9c-JMM-1
30928: PPUSH
30929: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
30933: LD_EXP 76
30937: PPUSH
30938: LD_STRING D9c-Roth-1
30940: PPUSH
30941: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
30945: LD_EXP 40
30949: PPUSH
30950: LD_STRING D9c-JMM-2
30952: PPUSH
30953: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
30957: LD_EXP 76
30961: PPUSH
30962: LD_STRING D9c-Roth-2
30964: PPUSH
30965: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
30969: LD_EXP 40
30973: PPUSH
30974: LD_STRING D9c-JMM-3
30976: PPUSH
30977: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
30981: LD_EXP 76
30985: PPUSH
30986: LD_STRING D9c-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
30993: LD_EXP 76
30997: PPUSH
30998: LD_STRING D9cont-Roth-1
31000: PPUSH
31001: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31005: LD_EXP 40
31009: PPUSH
31010: LD_STRING D9cont-JMM-1
31012: PPUSH
31013: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31017: LD_EXP 76
31021: PPUSH
31022: LD_STRING D9cont-Roth-2
31024: PPUSH
31025: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31029: LD_EXP 40
31033: PPUSH
31034: LD_STRING D9cont-JMM-2
31036: PPUSH
31037: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31041: LD_EXP 76
31045: PPUSH
31046: LD_STRING D9cont-Roth-3
31048: PPUSH
31049: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31053: LD_EXP 40
31057: PPUSH
31058: LD_STRING D9cont-JMM-3
31060: PPUSH
31061: CALL_OW 88
// DialogueOff ;
31065: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31069: LD_STRING M3
31071: PPUSH
31072: CALL_OW 337
// allianceActive := true ;
31076: LD_ADDR_EXP 31
31080: PUSH
31081: LD_INT 1
31083: ST_TO_ADDR
// end ;
31084: PPOPN 1
31086: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31087: LD_INT 1
31089: PPUSH
31090: LD_INT 126
31092: PPUSH
31093: CALL_OW 292
31097: PUSH
31098: LD_EXP 65
31102: PPUSH
31103: CALL_OW 310
31107: AND
31108: IFFALSE 31188
31110: GO 31112
31112: DISABLE
31113: LD_INT 0
31115: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31116: LD_EXP 65
31120: PPUSH
31121: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31125: LD_ADDR_VAR 0 1
31129: PUSH
31130: LD_INT 4
31132: PPUSH
31133: LD_INT 22
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PPUSH
31143: CALL_OW 70
31147: PPUSH
31148: LD_EXP 65
31152: PPUSH
31153: CALL_OW 74
31157: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31158: LD_EXP 65
31162: PPUSH
31163: LD_VAR 0 1
31167: PUSH
31168: LD_INT 1
31170: ARRAY
31171: PPUSH
31172: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31176: LD_EXP 65
31180: PPUSH
31181: LD_STRING D18-Pla-1
31183: PPUSH
31184: CALL_OW 88
// end ;
31188: PPOPN 1
31190: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31191: LD_EXP 65
31195: PPUSH
31196: CALL_OW 301
31200: PUSH
31201: LD_EXP 68
31205: PPUSH
31206: CALL_OW 301
31210: AND
31211: PUSH
31212: LD_INT 22
31214: PUSH
31215: LD_INT 3
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 21
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 50
31234: PUSH
31235: EMPTY
31236: LIST
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: LIST
31242: PPUSH
31243: CALL_OW 69
31247: PUSH
31248: LD_INT 7
31250: PUSH
31251: LD_INT 8
31253: PUSH
31254: LD_INT 9
31256: PUSH
31257: LD_INT 10
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: PUSH
31266: LD_OWVAR 67
31270: ARRAY
31271: LESS
31272: AND
31273: IFFALSE 32066
31275: GO 31277
31277: DISABLE
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
// begin MC_Kill ( 2 ) ;
31284: LD_INT 2
31286: PPUSH
31287: CALL 36914 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31291: LD_INT 1
31293: PPUSH
31294: LD_INT 3
31296: PPUSH
31297: LD_INT 1
31299: PPUSH
31300: LD_INT 1
31302: PPUSH
31303: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31307: LD_ADDR_VAR 0 2
31311: PUSH
31312: LD_INT 22
31314: PUSH
31315: LD_INT 3
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 21
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 50
31334: PUSH
31335: EMPTY
31336: LIST
31337: PUSH
31338: LD_INT 26
31340: PUSH
31341: LD_INT 1
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: PPUSH
31354: CALL_OW 69
31358: ST_TO_ADDR
// if not tmp then
31359: LD_VAR 0 2
31363: NOT
31364: IFFALSE 31420
// begin uc_side = 3 ;
31366: LD_ADDR_OWVAR 20
31370: PUSH
31371: LD_INT 3
31373: ST_TO_ADDR
// uc_nation = 3 ;
31374: LD_ADDR_OWVAR 21
31378: PUSH
31379: LD_INT 3
31381: ST_TO_ADDR
// hc_name =  ;
31382: LD_ADDR_OWVAR 26
31386: PUSH
31387: LD_STRING 
31389: ST_TO_ADDR
// hc_gallery =  ;
31390: LD_ADDR_OWVAR 33
31394: PUSH
31395: LD_STRING 
31397: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31398: LD_INT 1
31400: PPUSH
31401: LD_INT 10
31403: PPUSH
31404: CALL_OW 381
// tmp = CreateHuman ;
31408: LD_ADDR_VAR 0 2
31412: PUSH
31413: CALL_OW 44
31417: ST_TO_ADDR
// end else
31418: GO 31434
// tmp := tmp [ 1 ] ;
31420: LD_ADDR_VAR 0 2
31424: PUSH
31425: LD_VAR 0 2
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: ST_TO_ADDR
// DialogueOn ;
31434: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31438: LD_VAR 0 2
31442: PPUSH
31443: LD_STRING DSurrenderRussians-RSol1-1a
31445: PPUSH
31446: CALL_OW 94
// DialogueOff ;
31450: CALL_OW 7
// russianDestroyed := true ;
31454: LD_ADDR_EXP 21
31458: PUSH
31459: LD_INT 1
31461: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31462: LD_ADDR_VAR 0 1
31466: PUSH
31467: LD_INT 22
31469: PUSH
31470: LD_INT 6
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PPUSH
31477: CALL_OW 69
31481: PUSH
31482: FOR_IN
31483: IFFALSE 31496
// KillUnit ( i ) ;
31485: LD_VAR 0 1
31489: PPUSH
31490: CALL_OW 66
31494: GO 31482
31496: POP
31497: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31498: LD_INT 22
31500: PUSH
31501: LD_INT 3
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 21
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PPUSH
31522: CALL_OW 69
31526: PPUSH
31527: CALL_OW 122
// wait ( 0 0$1 ) ;
31531: LD_INT 35
31533: PPUSH
31534: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31538: LD_INT 22
31540: PUSH
31541: LD_INT 3
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 21
31550: PUSH
31551: LD_INT 1
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PPUSH
31562: CALL_OW 69
31566: PPUSH
31567: LD_INT 25
31569: PPUSH
31570: CALL_OW 173
// wait ( 0 0$35 ) ;
31574: LD_INT 1225
31576: PPUSH
31577: CALL_OW 67
// PrepareOmarInvasion ;
31581: CALL 14656 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31585: LD_ADDR_VAR 0 2
31589: PUSH
31590: LD_EXP 94
31594: PPUSH
31595: CALL_OW 250
31599: PUSH
31600: LD_EXP 94
31604: PPUSH
31605: CALL_OW 251
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31614: LD_VAR 0 2
31618: PUSH
31619: LD_INT 1
31621: ARRAY
31622: PPUSH
31623: LD_VAR 0 2
31627: PUSH
31628: LD_INT 2
31630: ARRAY
31631: PPUSH
31632: LD_INT 1
31634: PPUSH
31635: LD_INT 8
31637: NEG
31638: PPUSH
31639: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31643: LD_EXP 94
31647: PPUSH
31648: CALL_OW 87
// DialogueOn ;
31652: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31656: LD_EXP 40
31660: PPUSH
31661: LD_STRING D19-JMM-1
31663: PPUSH
31664: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31668: LD_ADDR_VAR 0 3
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 26
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 2
31695: PUSH
31696: LD_INT 25
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 25
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 25
31718: PUSH
31719: LD_INT 3
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 25
31728: PUSH
31729: LD_INT 4
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 25
31738: PUSH
31739: LD_INT 5
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 25
31748: PUSH
31749: LD_INT 8
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: LIST
31769: PPUSH
31770: CALL_OW 69
31774: PUSH
31775: LD_EXP 40
31779: PUSH
31780: LD_EXP 41
31784: PUSH
31785: LD_EXP 42
31789: PUSH
31790: LD_EXP 43
31794: PUSH
31795: LD_EXP 44
31799: PUSH
31800: LD_EXP 45
31804: PUSH
31805: LD_EXP 46
31809: PUSH
31810: LD_EXP 47
31814: PUSH
31815: LD_EXP 48
31819: PUSH
31820: LD_EXP 49
31824: PUSH
31825: LD_EXP 50
31829: PUSH
31830: LD_EXP 51
31834: PUSH
31835: LD_EXP 52
31839: PUSH
31840: LD_EXP 53
31844: PUSH
31845: LD_EXP 54
31849: PUSH
31850: LD_EXP 55
31854: PUSH
31855: LD_EXP 56
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: DIFF
31879: ST_TO_ADDR
// if tmp2 then
31880: LD_VAR 0 3
31884: IFFALSE 31902
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
31886: LD_VAR 0 3
31890: PUSH
31891: LD_INT 1
31893: ARRAY
31894: PPUSH
31895: LD_STRING D19-Sol1-1
31897: PPUSH
31898: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
31902: LD_EXP 40
31906: PPUSH
31907: LD_STRING D19-JMM-2
31909: PPUSH
31910: CALL_OW 88
// DialogueOff ;
31914: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
31918: LD_VAR 0 2
31922: PUSH
31923: LD_INT 1
31925: ARRAY
31926: PPUSH
31927: LD_VAR 0 2
31931: PUSH
31932: LD_INT 2
31934: ARRAY
31935: PPUSH
31936: LD_INT 1
31938: PPUSH
31939: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
31943: LD_STRING M5
31945: PPUSH
31946: CALL_OW 337
// omarOnMotherLode := false ;
31950: LD_ADDR_VAR 0 4
31954: PUSH
31955: LD_INT 0
31957: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31958: LD_INT 35
31960: PPUSH
31961: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
31965: LD_EXP 94
31969: PPUSH
31970: LD_INT 215
31972: PPUSH
31973: LD_INT 100
31975: PPUSH
31976: CALL_OW 297
31980: PUSH
31981: LD_INT 10
31983: LESS
31984: PUSH
31985: LD_VAR 0 4
31989: NOT
31990: AND
31991: IFFALSE 32025
// begin omarOnMotherLode := true ;
31993: LD_ADDR_VAR 0 4
31997: PUSH
31998: LD_INT 1
32000: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32001: LD_EXP 40
32005: PPUSH
32006: LD_STRING D19b-JMM-1
32008: PPUSH
32009: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32013: LD_EXP 94
32017: PPUSH
32018: LD_STRING DOmarContam-Omar-1
32020: PPUSH
32021: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32025: LD_EXP 94
32029: PPUSH
32030: CALL_OW 301
32034: IFFALSE 31958
// Say ( JMM , D19a-JMM-1 ) ;
32036: LD_EXP 40
32040: PPUSH
32041: LD_STRING D19a-JMM-1
32043: PPUSH
32044: CALL_OW 88
// if Heike then
32048: LD_EXP 95
32052: IFFALSE 32066
// Say ( Heike , D19a-Hke-1 ) ;
32054: LD_EXP 95
32058: PPUSH
32059: LD_STRING D19a-Hke-1
32061: PPUSH
32062: CALL_OW 88
// end ;
32066: PPOPN 4
32068: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32069: LD_INT 22
32071: PUSH
32072: LD_INT 3
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 21
32081: PUSH
32082: LD_INT 1
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PPUSH
32093: CALL_OW 69
32097: PUSH
32098: LD_EXP 21
32102: AND
32103: IFFALSE 32171
32105: GO 32107
32107: DISABLE
32108: LD_INT 0
32110: PPUSH
32111: PPUSH
// begin enable ;
32112: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32113: LD_ADDR_VAR 0 2
32117: PUSH
32118: LD_INT 25
32120: PPUSH
32121: LD_INT 22
32123: PUSH
32124: LD_INT 3
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PPUSH
32131: CALL_OW 70
32135: ST_TO_ADDR
// if not tmp then
32136: LD_VAR 0 2
32140: NOT
32141: IFFALSE 32145
// exit ;
32143: GO 32171
// for i in tmp do
32145: LD_ADDR_VAR 0 1
32149: PUSH
32150: LD_VAR 0 2
32154: PUSH
32155: FOR_IN
32156: IFFALSE 32169
// RemoveUnit ( i ) ;
32158: LD_VAR 0 1
32162: PPUSH
32163: CALL_OW 64
32167: GO 32155
32169: POP
32170: POP
// end ;
32171: PPOPN 2
32173: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32174: LD_INT 22
32176: PUSH
32177: LD_INT 7
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 21
32186: PUSH
32187: LD_INT 1
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PPUSH
32198: CALL_OW 69
32202: PUSH
32203: LD_INT 6
32205: LESS
32206: IFFALSE 32674
32208: GO 32210
32210: DISABLE
32211: LD_INT 0
32213: PPUSH
32214: PPUSH
// begin MC_Kill ( 1 ) ;
32215: LD_INT 1
32217: PPUSH
32218: CALL 36914 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32222: LD_INT 7
32224: PPUSH
32225: LD_INT 1
32227: PPUSH
32228: LD_INT 1
32230: PPUSH
32231: LD_INT 1
32233: PPUSH
32234: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32238: LD_ADDR_VAR 0 1
32242: PUSH
32243: LD_INT 22
32245: PUSH
32246: LD_INT 7
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 26
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PPUSH
32267: CALL_OW 69
32271: PUSH
32272: LD_EXP 76
32276: DIFF
32277: ST_TO_ADDR
// if tmp then
32278: LD_VAR 0 1
32282: IFFALSE 32300
// tmp := tmp [ 1 ] else
32284: LD_ADDR_VAR 0 1
32288: PUSH
32289: LD_VAR 0 1
32293: PUSH
32294: LD_INT 1
32296: ARRAY
32297: ST_TO_ADDR
32298: GO 32336
// begin uc_side := 7 ;
32300: LD_ADDR_OWVAR 20
32304: PUSH
32305: LD_INT 7
32307: ST_TO_ADDR
// uc_nation := 1 ;
32308: LD_ADDR_OWVAR 21
32312: PUSH
32313: LD_INT 1
32315: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32316: LD_INT 1
32318: PPUSH
32319: LD_INT 8
32321: PPUSH
32322: CALL_OW 384
// tmp := CreateHuman ;
32326: LD_ADDR_VAR 0 1
32330: PUSH
32331: CALL_OW 44
32335: ST_TO_ADDR
// end ; DialogueOn ;
32336: CALL_OW 6
// if IsOK ( Roth ) then
32340: LD_EXP 76
32344: PPUSH
32345: CALL_OW 302
32349: IFFALSE 32363
// Say ( JMM , DAb-JMM-1 ) ;
32351: LD_EXP 40
32355: PPUSH
32356: LD_STRING DAb-JMM-1
32358: PPUSH
32359: CALL_OW 88
// if IsOK ( Roth ) then
32363: LD_EXP 76
32367: PPUSH
32368: CALL_OW 302
32372: IFFALSE 32396
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32374: LD_EXP 76
32378: PPUSH
32379: LD_STRING DSurrenderAlliance-Roth-1
32381: PPUSH
32382: CALL_OW 88
// RothCaptured := true ;
32386: LD_ADDR_EXP 33
32390: PUSH
32391: LD_INT 1
32393: ST_TO_ADDR
// end else
32394: GO 32408
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32396: LD_VAR 0 1
32400: PPUSH
32401: LD_STRING DSurrenderAlliance-Sci1-1
32403: PPUSH
32404: CALL_OW 88
// DialogueOff ;
32408: CALL_OW 7
// allianceDestroyed := true ;
32412: LD_ADDR_EXP 23
32416: PUSH
32417: LD_INT 1
32419: ST_TO_ADDR
// if capturedUnit = 0 then
32420: LD_EXP 34
32424: PUSH
32425: LD_INT 0
32427: EQUAL
32428: IFFALSE 32437
// SetAchievement ( ACH_ALLIANCE ) ;
32430: LD_STRING ACH_ALLIANCE
32432: PPUSH
32433: CALL_OW 543
// if trueAmericans then
32437: LD_EXP 35
32441: IFFALSE 32517
// begin if trueAmericans = 1 then
32443: LD_EXP 35
32447: PUSH
32448: LD_INT 1
32450: EQUAL
32451: IFFALSE 32467
// Say ( JMM , DAb-JMM-1a ) else
32453: LD_EXP 40
32457: PPUSH
32458: LD_STRING DAb-JMM-1a
32460: PPUSH
32461: CALL_OW 88
32465: GO 32479
// Say ( JMM , DAb-JMM-1b ) ;
32467: LD_EXP 40
32471: PPUSH
32472: LD_STRING DAb-JMM-1b
32474: PPUSH
32475: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32479: LD_EXP 35
32483: PPUSH
32484: CALL_OW 87
// for i in trueAmericans do
32488: LD_ADDR_VAR 0 2
32492: PUSH
32493: LD_EXP 35
32497: PUSH
32498: FOR_IN
32499: IFFALSE 32515
// SetSide ( i , 1 ) ;
32501: LD_VAR 0 2
32505: PPUSH
32506: LD_INT 1
32508: PPUSH
32509: CALL_OW 235
32513: GO 32498
32515: POP
32516: POP
// end ; repeat wait ( 0 0$1 ) ;
32517: LD_INT 35
32519: PPUSH
32520: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32524: LD_ADDR_VAR 0 2
32528: PUSH
32529: LD_INT 22
32531: PUSH
32532: LD_INT 7
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 21
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PPUSH
32553: CALL_OW 69
32557: PUSH
32558: FOR_IN
32559: IFFALSE 32641
// begin if IsInUnit ( i ) then
32561: LD_VAR 0 2
32565: PPUSH
32566: CALL_OW 310
32570: IFFALSE 32581
// ComExitBuilding ( i ) ;
32572: LD_VAR 0 2
32576: PPUSH
32577: CALL_OW 122
// if IsDriver ( i ) then
32581: LD_VAR 0 2
32585: PPUSH
32586: CALL 102387 0 1
32590: IFFALSE 32601
// ComExitVehicle ( i ) ;
32592: LD_VAR 0 2
32596: PPUSH
32597: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32601: LD_VAR 0 2
32605: PPUSH
32606: LD_INT 26
32608: PPUSH
32609: CALL_OW 308
32613: NOT
32614: IFFALSE 32630
// AddComMoveToArea ( i , allianceEscapeArea ) else
32616: LD_VAR 0 2
32620: PPUSH
32621: LD_INT 26
32623: PPUSH
32624: CALL_OW 173
32628: GO 32639
// RemoveUnit ( i ) ;
32630: LD_VAR 0 2
32634: PPUSH
32635: CALL_OW 64
// end ;
32639: GO 32558
32641: POP
32642: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32643: LD_INT 22
32645: PUSH
32646: LD_INT 7
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 21
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PPUSH
32667: CALL_OW 69
32671: NOT
32672: IFFALSE 32517
// end ;
32674: PPOPN 2
32676: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32677: LD_INT 0
32679: PPUSH
32680: PPUSH
// if not unit then
32681: LD_VAR 0 1
32685: NOT
32686: IFFALSE 32690
// exit ;
32688: GO 34188
// DoNotAttack ( 7 , unit ) ;
32690: LD_INT 7
32692: PPUSH
32693: LD_VAR 0 1
32697: PPUSH
32698: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32702: LD_VAR 0 1
32706: PPUSH
32707: LD_INT 260
32709: PPUSH
32710: LD_INT 235
32712: PPUSH
32713: LD_INT 3
32715: PPUSH
32716: LD_INT 1
32718: PPUSH
32719: CALL_OW 483
// SetSide ( unit , 4 ) ;
32723: LD_VAR 0 1
32727: PPUSH
32728: LD_INT 4
32730: PPUSH
32731: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32735: LD_ADDR_EXP 34
32739: PUSH
32740: LD_EXP 34
32744: PUSH
32745: LD_INT 1
32747: PLUS
32748: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32749: LD_INT 70
32751: PPUSH
32752: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32756: LD_INT 260
32758: PPUSH
32759: LD_INT 235
32761: PPUSH
32762: LD_INT 1
32764: PPUSH
32765: LD_INT 8
32767: NEG
32768: PPUSH
32769: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32773: LD_VAR 0 1
32777: PPUSH
32778: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32782: LD_VAR 0 1
32786: PPUSH
32787: LD_EXP 76
32791: PPUSH
32792: CALL_OW 119
// DialogueOn ;
32796: CALL_OW 6
// case unit of JMM :
32800: LD_VAR 0 1
32804: PUSH
32805: LD_EXP 40
32809: DOUBLE
32810: EQUAL
32811: IFTRUE 32815
32813: GO 32830
32815: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32816: LD_EXP 40
32820: PPUSH
32821: LD_STRING DA1-JMM-1
32823: PPUSH
32824: CALL_OW 91
32828: GO 33272
32830: LD_EXP 41
32834: DOUBLE
32835: EQUAL
32836: IFTRUE 32840
32838: GO 32855
32840: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
32841: LD_EXP 41
32845: PPUSH
32846: LD_STRING DA1-Joan-1
32848: PPUSH
32849: CALL_OW 91
32853: GO 33272
32855: LD_EXP 43
32859: DOUBLE
32860: EQUAL
32861: IFTRUE 32865
32863: GO 32880
32865: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
32866: LD_EXP 43
32870: PPUSH
32871: LD_STRING DA1-Lisa-1
32873: PPUSH
32874: CALL_OW 91
32878: GO 33272
32880: LD_EXP 44
32884: DOUBLE
32885: EQUAL
32886: IFTRUE 32890
32888: GO 32905
32890: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
32891: LD_EXP 44
32895: PPUSH
32896: LD_STRING DA1-Don-1
32898: PPUSH
32899: CALL_OW 91
32903: GO 33272
32905: LD_EXP 51
32909: DOUBLE
32910: EQUAL
32911: IFTRUE 32915
32913: GO 32930
32915: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
32916: LD_EXP 51
32920: PPUSH
32921: LD_STRING DA1-Corn-1
32923: PPUSH
32924: CALL_OW 91
32928: GO 33272
32930: LD_EXP 47
32934: DOUBLE
32935: EQUAL
32936: IFTRUE 32940
32938: GO 32955
32940: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
32941: LD_EXP 47
32945: PPUSH
32946: LD_STRING DA1-Den-1
32948: PPUSH
32949: CALL_OW 91
32953: GO 33272
32955: LD_EXP 45
32959: DOUBLE
32960: EQUAL
32961: IFTRUE 32965
32963: GO 32980
32965: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
32966: LD_EXP 45
32970: PPUSH
32971: LD_STRING DA1-Bobby-1
32973: PPUSH
32974: CALL_OW 91
32978: GO 33272
32980: LD_EXP 49
32984: DOUBLE
32985: EQUAL
32986: IFTRUE 32990
32988: GO 33005
32990: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
32991: LD_EXP 49
32995: PPUSH
32996: LD_STRING DA1-Glad-1
32998: PPUSH
32999: CALL_OW 91
33003: GO 33272
33005: LD_EXP 46
33009: DOUBLE
33010: EQUAL
33011: IFTRUE 33015
33013: GO 33030
33015: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33016: LD_EXP 46
33020: PPUSH
33021: LD_STRING DA1-Cyrus-1
33023: PPUSH
33024: CALL_OW 91
33028: GO 33272
33030: LD_EXP 42
33034: DOUBLE
33035: EQUAL
33036: IFTRUE 33040
33038: GO 33055
33040: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33041: LD_EXP 42
33045: PPUSH
33046: LD_STRING DA1-Huck-1
33048: PPUSH
33049: CALL_OW 91
33053: GO 33272
33055: LD_EXP 56
33059: DOUBLE
33060: EQUAL
33061: IFTRUE 33065
33063: GO 33080
33065: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33066: LD_EXP 56
33070: PPUSH
33071: LD_STRING DA1-Huck-1
33073: PPUSH
33074: CALL_OW 91
33078: GO 33272
33080: LD_EXP 48
33084: DOUBLE
33085: EQUAL
33086: IFTRUE 33090
33088: GO 33105
33090: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33091: LD_EXP 48
33095: PPUSH
33096: LD_STRING DA1-Brown-1
33098: PPUSH
33099: CALL_OW 91
33103: GO 33272
33105: LD_EXP 52
33109: DOUBLE
33110: EQUAL
33111: IFTRUE 33115
33113: GO 33130
33115: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33116: LD_EXP 52
33120: PPUSH
33121: LD_STRING DA1-Gary-1
33123: PPUSH
33124: CALL_OW 91
33128: GO 33272
33130: LD_EXP 55
33134: DOUBLE
33135: EQUAL
33136: IFTRUE 33140
33138: GO 33155
33140: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33141: LD_EXP 55
33145: PPUSH
33146: LD_STRING DA1-Con-1
33148: PPUSH
33149: CALL_OW 91
33153: GO 33272
33155: LD_EXP 61
33159: DOUBLE
33160: EQUAL
33161: IFTRUE 33165
33163: GO 33180
33165: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33166: LD_EXP 61
33170: PPUSH
33171: LD_STRING DA1-Kurt-1
33173: PPUSH
33174: CALL_OW 91
33178: GO 33272
33180: LD_EXP 54
33184: DOUBLE
33185: EQUAL
33186: IFTRUE 33190
33188: GO 33205
33190: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33191: LD_EXP 54
33195: PPUSH
33196: LD_STRING DA1-Yam-1
33198: PPUSH
33199: CALL_OW 91
33203: GO 33272
33205: LD_EXP 53
33209: DOUBLE
33210: EQUAL
33211: IFTRUE 33215
33213: GO 33230
33215: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33216: LD_EXP 53
33220: PPUSH
33221: LD_STRING DA1-Frank-1
33223: PPUSH
33224: CALL_OW 91
33228: GO 33272
33230: POP
// begin if GetSex ( unit ) = sex_male then
33231: LD_VAR 0 1
33235: PPUSH
33236: CALL_OW 258
33240: PUSH
33241: LD_INT 1
33243: EQUAL
33244: IFFALSE 33260
// ForceSay ( unit , DA1-Sol1-1 ) else
33246: LD_VAR 0 1
33250: PPUSH
33251: LD_STRING DA1-Sol1-1
33253: PPUSH
33254: CALL_OW 91
33258: GO 33272
// ForceSay ( unit , DA1-FSol1-1 ) ;
33260: LD_VAR 0 1
33264: PPUSH
33265: LD_STRING DA1-FSol1-1
33267: PPUSH
33268: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33272: LD_EXP 76
33276: PPUSH
33277: LD_STRING DA-Roth-1
33279: PPUSH
33280: CALL_OW 88
// if capturedUnit = 1 then
33284: LD_EXP 34
33288: PUSH
33289: LD_INT 1
33291: EQUAL
33292: IFFALSE 33320
// begin Say ( Simms , DA-Sim-1 ) ;
33294: LD_EXP 77
33298: PPUSH
33299: LD_STRING DA-Sim-1
33301: PPUSH
33302: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33306: LD_EXP 76
33310: PPUSH
33311: LD_STRING DA-Roth-2
33313: PPUSH
33314: CALL_OW 88
// end else
33318: GO 33332
// Say ( Simms , DA-Sim-2 ) ;
33320: LD_EXP 77
33324: PPUSH
33325: LD_STRING DA-Sim-2
33327: PPUSH
33328: CALL_OW 88
// case unit of JMM :
33332: LD_VAR 0 1
33336: PUSH
33337: LD_EXP 40
33341: DOUBLE
33342: EQUAL
33343: IFTRUE 33347
33345: GO 33362
33347: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33348: LD_EXP 40
33352: PPUSH
33353: LD_STRING DA1-JMM-1a
33355: PPUSH
33356: CALL_OW 91
33360: GO 33869
33362: LD_EXP 41
33366: DOUBLE
33367: EQUAL
33368: IFTRUE 33372
33370: GO 33387
33372: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33373: LD_EXP 41
33377: PPUSH
33378: LD_STRING DA1-Joan-1a
33380: PPUSH
33381: CALL_OW 91
33385: GO 33869
33387: LD_EXP 43
33391: DOUBLE
33392: EQUAL
33393: IFTRUE 33397
33395: GO 33412
33397: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33398: LD_EXP 43
33402: PPUSH
33403: LD_STRING DA1-Lisa-1a
33405: PPUSH
33406: CALL_OW 91
33410: GO 33869
33412: LD_EXP 44
33416: DOUBLE
33417: EQUAL
33418: IFTRUE 33422
33420: GO 33437
33422: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33423: LD_EXP 44
33427: PPUSH
33428: LD_STRING DA1-Don-1a
33430: PPUSH
33431: CALL_OW 91
33435: GO 33869
33437: LD_EXP 51
33441: DOUBLE
33442: EQUAL
33443: IFTRUE 33447
33445: GO 33462
33447: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33448: LD_EXP 51
33452: PPUSH
33453: LD_STRING DA1-Corn-1a
33455: PPUSH
33456: CALL_OW 91
33460: GO 33869
33462: LD_EXP 47
33466: DOUBLE
33467: EQUAL
33468: IFTRUE 33472
33470: GO 33487
33472: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33473: LD_EXP 47
33477: PPUSH
33478: LD_STRING DA1-Den-1a
33480: PPUSH
33481: CALL_OW 91
33485: GO 33869
33487: LD_EXP 45
33491: DOUBLE
33492: EQUAL
33493: IFTRUE 33497
33495: GO 33512
33497: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33498: LD_EXP 45
33502: PPUSH
33503: LD_STRING DA1-Bobby-1a
33505: PPUSH
33506: CALL_OW 91
33510: GO 33869
33512: LD_EXP 49
33516: DOUBLE
33517: EQUAL
33518: IFTRUE 33522
33520: GO 33537
33522: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33523: LD_EXP 49
33527: PPUSH
33528: LD_STRING DA1-Glad-1a
33530: PPUSH
33531: CALL_OW 91
33535: GO 33869
33537: LD_EXP 46
33541: DOUBLE
33542: EQUAL
33543: IFTRUE 33547
33545: GO 33562
33547: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33548: LD_EXP 46
33552: PPUSH
33553: LD_STRING DA1-Cyrus-1a
33555: PPUSH
33556: CALL_OW 91
33560: GO 33869
33562: LD_EXP 42
33566: DOUBLE
33567: EQUAL
33568: IFTRUE 33572
33570: GO 33587
33572: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33573: LD_EXP 42
33577: PPUSH
33578: LD_STRING DA1-Huck-1a
33580: PPUSH
33581: CALL_OW 91
33585: GO 33869
33587: LD_EXP 56
33591: DOUBLE
33592: EQUAL
33593: IFTRUE 33597
33595: GO 33612
33597: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33598: LD_EXP 56
33602: PPUSH
33603: LD_STRING DA1-Huck-1a
33605: PPUSH
33606: CALL_OW 91
33610: GO 33869
33612: LD_EXP 48
33616: DOUBLE
33617: EQUAL
33618: IFTRUE 33622
33620: GO 33637
33622: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33623: LD_EXP 48
33627: PPUSH
33628: LD_STRING DA1-Brown-1a
33630: PPUSH
33631: CALL_OW 91
33635: GO 33869
33637: LD_EXP 52
33641: DOUBLE
33642: EQUAL
33643: IFTRUE 33647
33645: GO 33662
33647: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33648: LD_EXP 52
33652: PPUSH
33653: LD_STRING DA1-Gary-1a
33655: PPUSH
33656: CALL_OW 91
33660: GO 33869
33662: LD_EXP 55
33666: DOUBLE
33667: EQUAL
33668: IFTRUE 33672
33670: GO 33687
33672: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33673: LD_EXP 55
33677: PPUSH
33678: LD_STRING DA1-Con-1a
33680: PPUSH
33681: CALL_OW 91
33685: GO 33869
33687: LD_EXP 61
33691: DOUBLE
33692: EQUAL
33693: IFTRUE 33697
33695: GO 33712
33697: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33698: LD_EXP 61
33702: PPUSH
33703: LD_STRING DA1-Kurt-1a
33705: PPUSH
33706: CALL_OW 91
33710: GO 33869
33712: LD_EXP 54
33716: DOUBLE
33717: EQUAL
33718: IFTRUE 33722
33720: GO 33737
33722: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33723: LD_EXP 54
33727: PPUSH
33728: LD_STRING DA1-Yam-1a
33730: PPUSH
33731: CALL_OW 91
33735: GO 33869
33737: LD_EXP 53
33741: DOUBLE
33742: EQUAL
33743: IFTRUE 33747
33745: GO 33762
33747: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33748: LD_EXP 53
33752: PPUSH
33753: LD_STRING DA1-Frank-1a
33755: PPUSH
33756: CALL_OW 91
33760: GO 33869
33762: POP
// begin join := rand ( 0 , 1 ) ;
33763: LD_ADDR_VAR 0 3
33767: PUSH
33768: LD_INT 0
33770: PPUSH
33771: LD_INT 1
33773: PPUSH
33774: CALL_OW 12
33778: ST_TO_ADDR
// if join then
33779: LD_VAR 0 3
33783: IFFALSE 33828
// begin if GetSex ( unit ) = sex_male then
33785: LD_VAR 0 1
33789: PPUSH
33790: CALL_OW 258
33794: PUSH
33795: LD_INT 1
33797: EQUAL
33798: IFFALSE 33814
// ForceSay ( unit , DA1-Sol1-1b ) else
33800: LD_VAR 0 1
33804: PPUSH
33805: LD_STRING DA1-Sol1-1b
33807: PPUSH
33808: CALL_OW 91
33812: GO 33826
// ForceSay ( unit , DA1-FSol1-1b ) ;
33814: LD_VAR 0 1
33818: PPUSH
33819: LD_STRING DA1-FSol1-1b
33821: PPUSH
33822: CALL_OW 91
// end else
33826: GO 33869
// begin if GetSex ( unit ) = sex_male then
33828: LD_VAR 0 1
33832: PPUSH
33833: CALL_OW 258
33837: PUSH
33838: LD_INT 1
33840: EQUAL
33841: IFFALSE 33857
// ForceSay ( unit , DA1-Sol1-1a ) else
33843: LD_VAR 0 1
33847: PPUSH
33848: LD_STRING DA1-Sol1-1a
33850: PPUSH
33851: CALL_OW 91
33855: GO 33869
// ForceSay ( unit , DA1-FSol1-1a ) ;
33857: LD_VAR 0 1
33861: PPUSH
33862: LD_STRING DA1-FSol1-1a
33864: PPUSH
33865: CALL_OW 91
// end ; end ; end ; if unit = JMM then
33869: LD_VAR 0 1
33873: PUSH
33874: LD_EXP 40
33878: EQUAL
33879: IFFALSE 33890
// begin YouLost ( JMMCaptured ) ;
33881: LD_STRING JMMCaptured
33883: PPUSH
33884: CALL_OW 104
// exit ;
33888: GO 34188
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
33890: LD_VAR 0 1
33894: PUSH
33895: LD_EXP 44
33899: PUSH
33900: LD_EXP 47
33904: PUSH
33905: LD_EXP 45
33909: PUSH
33910: LD_EXP 42
33914: PUSH
33915: LD_EXP 56
33919: PUSH
33920: LD_EXP 48
33924: PUSH
33925: LD_EXP 54
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: IN
33939: PUSH
33940: LD_VAR 0 3
33944: OR
33945: IFFALSE 34044
// begin Say ( Roth , DA-Roth-3 ) ;
33947: LD_EXP 76
33951: PPUSH
33952: LD_STRING DA-Roth-3
33954: PPUSH
33955: CALL_OW 88
// SetSide ( unit , 7 ) ;
33959: LD_VAR 0 1
33963: PPUSH
33964: LD_INT 7
33966: PPUSH
33967: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
33971: LD_ADDR_EXP 99
33975: PUSH
33976: LD_EXP 99
33980: PPUSH
33981: LD_INT 1
33983: PPUSH
33984: LD_EXP 99
33988: PUSH
33989: LD_INT 1
33991: ARRAY
33992: PUSH
33993: LD_VAR 0 1
33997: ADD
33998: PPUSH
33999: CALL_OW 1
34003: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34004: LD_INT 260
34006: PPUSH
34007: LD_INT 235
34009: PPUSH
34010: LD_INT 1
34012: PPUSH
34013: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34017: LD_VAR 0 1
34021: PPUSH
34022: LD_INT 1000
34024: PPUSH
34025: CALL_OW 234
// DialogueOff ;
34029: CALL_OW 7
// ComFree ( unit ) ;
34033: LD_VAR 0 1
34037: PPUSH
34038: CALL_OW 139
// end else
34042: GO 34125
// begin Say ( Roth , DA-Roth-3a ) ;
34044: LD_EXP 76
34048: PPUSH
34049: LD_STRING DA-Roth-3a
34051: PPUSH
34052: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34056: LD_ADDR_EXP 35
34060: PUSH
34061: LD_EXP 35
34065: PUSH
34066: LD_VAR 0 1
34070: ADD
34071: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34072: LD_INT 260
34074: PPUSH
34075: LD_INT 235
34077: PPUSH
34078: LD_INT 1
34080: PPUSH
34081: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34085: LD_VAR 0 1
34089: PPUSH
34090: LD_INT 1000
34092: PPUSH
34093: CALL_OW 234
// DialogueOff ;
34097: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34101: LD_VAR 0 1
34105: PPUSH
34106: LD_INT 272
34108: PPUSH
34109: LD_INT 254
34111: PPUSH
34112: CALL_OW 111
// AddComHold ( unit ) ;
34116: LD_VAR 0 1
34120: PPUSH
34121: CALL_OW 200
// end ; if capturedUnit = 1 then
34125: LD_EXP 34
34129: PUSH
34130: LD_INT 1
34132: EQUAL
34133: IFFALSE 34188
// begin DialogueOn ;
34135: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34139: LD_EXP 40
34143: PPUSH
34144: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34148: LD_EXP 40
34152: PPUSH
34153: LD_STRING DAa-JMM-1
34155: PPUSH
34156: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34160: LD_EXP 40
34164: PPUSH
34165: LD_STRING DAa-JMM-1a
34167: PPUSH
34168: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34172: LD_EXP 40
34176: PPUSH
34177: LD_STRING DAa-JMM-1b
34179: PPUSH
34180: CALL_OW 88
// DialogueOff ;
34184: CALL_OW 7
// end ; end ;
34188: LD_VAR 0 2
34192: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34193: LD_EXP 15
34197: PUSH
34198: LD_INT 13
34200: GREATEREQUAL
34201: PUSH
34202: LD_INT 22
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 21
34214: PUSH
34215: LD_INT 1
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PPUSH
34226: CALL_OW 69
34230: PUSH
34231: LD_INT 0
34233: EQUAL
34234: AND
34235: PUSH
34236: LD_INT 22
34238: PUSH
34239: LD_INT 2
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 33
34248: PUSH
34249: LD_INT 5
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 21
34258: PUSH
34259: LD_INT 2
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 50
34268: PUSH
34269: EMPTY
34270: LIST
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: PPUSH
34278: CALL_OW 69
34282: PUSH
34283: LD_INT 0
34285: EQUAL
34286: AND
34287: PUSH
34288: LD_EXP 21
34292: AND
34293: PUSH
34294: LD_EXP 22
34298: AND
34299: PUSH
34300: LD_EXP 23
34304: AND
34305: IFFALSE 34994
34307: GO 34309
34309: DISABLE
34310: LD_INT 0
34312: PPUSH
34313: PPUSH
34314: PPUSH
// begin m1 := false ;
34315: LD_ADDR_VAR 0 1
34319: PUSH
34320: LD_INT 0
34322: ST_TO_ADDR
// m2 := false ;
34323: LD_ADDR_VAR 0 2
34327: PUSH
34328: LD_INT 0
34330: ST_TO_ADDR
// m3 := false ;
34331: LD_ADDR_VAR 0 3
34335: PUSH
34336: LD_INT 0
34338: ST_TO_ADDR
// if not bombExploded then
34339: LD_EXP 37
34343: NOT
34344: IFFALSE 34353
// SetAchievement ( ACH_SIBROCKET ) ;
34346: LD_STRING ACH_SIBROCKET
34348: PPUSH
34349: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34353: LD_EXP 63
34357: PPUSH
34358: CALL_OW 255
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: PUSH
34367: LD_EXP 63
34371: PPUSH
34372: CALL_OW 302
34376: AND
34377: IFFALSE 34393
// begin wait ( 3 ) ;
34379: LD_INT 3
34381: PPUSH
34382: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34386: LD_STRING ACH_OPO
34388: PPUSH
34389: CALL_OW 543
// end ; if tick <= 120 120$00 then
34393: LD_OWVAR 1
34397: PUSH
34398: LD_INT 252000
34400: LESSEQUAL
34401: IFFALSE 34417
// begin wait ( 3 ) ;
34403: LD_INT 3
34405: PPUSH
34406: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34410: LD_STRING ACH_ASPEED_15
34412: PPUSH
34413: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34417: LD_EXP 40
34421: PPUSH
34422: CALL_OW 87
// music_class := 5 ;
34426: LD_ADDR_OWVAR 72
34430: PUSH
34431: LD_INT 5
34433: ST_TO_ADDR
// music_nat := 5 ;
34434: LD_ADDR_OWVAR 71
34438: PUSH
34439: LD_INT 5
34441: ST_TO_ADDR
// DialogueOn ;
34442: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34446: LD_EXP 40
34450: PPUSH
34451: LD_STRING D20-JMM-1
34453: PPUSH
34454: CALL_OW 88
// if IsOK ( Joan ) then
34458: LD_EXP 41
34462: PPUSH
34463: CALL_OW 302
34467: IFFALSE 34481
// Say ( Joan , D20-Joan-1 ) ;
34469: LD_EXP 41
34473: PPUSH
34474: LD_STRING D20-Joan-1
34476: PPUSH
34477: CALL_OW 88
// if IsOk ( Lisa ) then
34481: LD_EXP 43
34485: PPUSH
34486: CALL_OW 302
34490: IFFALSE 34504
// Say ( Lisa , D20-Lisa-1 ) ;
34492: LD_EXP 43
34496: PPUSH
34497: LD_STRING D20-Lisa-1
34499: PPUSH
34500: CALL_OW 88
// if IsOk ( Donaldson ) then
34504: LD_EXP 44
34508: PPUSH
34509: CALL_OW 302
34513: IFFALSE 34527
// Say ( Donaldson , D20-Don-1 ) ;
34515: LD_EXP 44
34519: PPUSH
34520: LD_STRING D20-Don-1
34522: PPUSH
34523: CALL_OW 88
// if IsOK ( Cornel ) then
34527: LD_EXP 51
34531: PPUSH
34532: CALL_OW 302
34536: IFFALSE 34550
// Say ( Cornel , D20-Corn-1 ) ;
34538: LD_EXP 51
34542: PPUSH
34543: LD_STRING D20-Corn-1
34545: PPUSH
34546: CALL_OW 88
// if IsOk ( Denis ) then
34550: LD_EXP 47
34554: PPUSH
34555: CALL_OW 302
34559: IFFALSE 34573
// Say ( Denis , D20-Den-1 ) ;
34561: LD_EXP 47
34565: PPUSH
34566: LD_STRING D20-Den-1
34568: PPUSH
34569: CALL_OW 88
// if IsOk ( Bobby ) then
34573: LD_EXP 45
34577: PPUSH
34578: CALL_OW 302
34582: IFFALSE 34596
// Say ( Bobby , D20-Bobby-1 ) ;
34584: LD_EXP 45
34588: PPUSH
34589: LD_STRING D20-Bobby-1
34591: PPUSH
34592: CALL_OW 88
// if IsOk ( Gladstone ) then
34596: LD_EXP 49
34600: PPUSH
34601: CALL_OW 302
34605: IFFALSE 34619
// Say ( Gladstone , D20-Glad-1 ) ;
34607: LD_EXP 49
34611: PPUSH
34612: LD_STRING D20-Glad-1
34614: PPUSH
34615: CALL_OW 88
// if IsOk ( Cyrus ) then
34619: LD_EXP 46
34623: PPUSH
34624: CALL_OW 302
34628: IFFALSE 34642
// Say ( Cyrus , D20-Cyrus-1 ) ;
34630: LD_EXP 46
34634: PPUSH
34635: LD_STRING D20-Cyrus-1
34637: PPUSH
34638: CALL_OW 88
// if IsOk ( Stevens ) then
34642: LD_EXP 42
34646: PPUSH
34647: CALL_OW 302
34651: IFFALSE 34665
// Say ( Stevens , D20-Huck-1 ) ;
34653: LD_EXP 42
34657: PPUSH
34658: LD_STRING D20-Huck-1
34660: PPUSH
34661: CALL_OW 88
// if IsOk ( Brown ) then
34665: LD_EXP 48
34669: PPUSH
34670: CALL_OW 302
34674: IFFALSE 34688
// Say ( Brown , D20-Brown-1 ) ;
34676: LD_EXP 48
34680: PPUSH
34681: LD_STRING D20-Brown-1
34683: PPUSH
34684: CALL_OW 88
// if IsOk ( Gary ) then
34688: LD_EXP 52
34692: PPUSH
34693: CALL_OW 302
34697: IFFALSE 34711
// Say ( Gary , D20-Gary-1 ) ;
34699: LD_EXP 52
34703: PPUSH
34704: LD_STRING D20-Gary-1
34706: PPUSH
34707: CALL_OW 88
// if IsOk ( Connie ) then
34711: LD_EXP 55
34715: PPUSH
34716: CALL_OW 302
34720: IFFALSE 34734
// Say ( Connie , D20-Con-1 ) ;
34722: LD_EXP 55
34726: PPUSH
34727: LD_STRING D20-Con-1
34729: PPUSH
34730: CALL_OW 88
// if IsOk ( Kurt ) then
34734: LD_EXP 61
34738: PPUSH
34739: CALL_OW 302
34743: IFFALSE 34757
// Say ( Kurt , D20-Kurt-1 ) ;
34745: LD_EXP 61
34749: PPUSH
34750: LD_STRING D20-Kurt-1
34752: PPUSH
34753: CALL_OW 88
// if IsOk ( Kikuchi ) then
34757: LD_EXP 54
34761: PPUSH
34762: CALL_OW 302
34766: IFFALSE 34780
// Say ( Kikuchi , D20-Yam-1 ) ;
34768: LD_EXP 54
34772: PPUSH
34773: LD_STRING D20-Yam-1
34775: PPUSH
34776: CALL_OW 88
// if IsOk ( Frank ) then
34780: LD_EXP 53
34784: PPUSH
34785: CALL_OW 302
34789: IFFALSE 34803
// Say ( Frank , D20-Frank-1 ) ;
34791: LD_EXP 53
34795: PPUSH
34796: LD_STRING D20-Frank-1
34798: PPUSH
34799: CALL_OW 88
// DialogueOff ;
34803: CALL_OW 7
// if RothCaptured then
34807: LD_EXP 33
34811: IFFALSE 34833
// begin m1 := true ;
34813: LD_ADDR_VAR 0 1
34817: PUSH
34818: LD_INT 1
34820: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
34821: LD_STRING Roth
34823: PPUSH
34824: LD_INT 1
34826: PPUSH
34827: CALL_OW 101
// end else
34831: GO 34844
// AddMedal ( Roth , - 1 ) ;
34833: LD_STRING Roth
34835: PPUSH
34836: LD_INT 1
34838: NEG
34839: PPUSH
34840: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
34844: LD_EXP 25
34848: NOT
34849: PUSH
34850: LD_EXP 27
34854: OR
34855: IFFALSE 34877
// begin m2 := true ;
34857: LD_ADDR_VAR 0 2
34861: PUSH
34862: LD_INT 1
34864: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
34865: LD_STRING Project
34867: PPUSH
34868: LD_INT 1
34870: PPUSH
34871: CALL_OW 101
// end else
34875: GO 34888
// AddMedal ( Project , - 1 ) ;
34877: LD_STRING Project
34879: PPUSH
34880: LD_INT 1
34882: NEG
34883: PPUSH
34884: CALL_OW 101
// if lostCounter = 0 then
34888: LD_EXP 32
34892: PUSH
34893: LD_INT 0
34895: EQUAL
34896: IFFALSE 34918
// begin m3 := true ;
34898: LD_ADDR_VAR 0 3
34902: PUSH
34903: LD_INT 1
34905: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
34906: LD_STRING NoLosses
34908: PPUSH
34909: LD_INT 1
34911: PPUSH
34912: CALL_OW 101
// end else
34916: GO 34929
// AddMedal ( NoLosses , - 1 ) ;
34918: LD_STRING NoLosses
34920: PPUSH
34921: LD_INT 1
34923: NEG
34924: PPUSH
34925: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
34929: LD_VAR 0 1
34933: PUSH
34934: LD_VAR 0 2
34938: AND
34939: PUSH
34940: LD_VAR 0 3
34944: AND
34945: PUSH
34946: LD_OWVAR 67
34950: PUSH
34951: LD_INT 3
34953: GREATEREQUAL
34954: AND
34955: IFFALSE 34967
// SetAchievementEX ( ACH_AMER , 15 ) ;
34957: LD_STRING ACH_AMER
34959: PPUSH
34960: LD_INT 15
34962: PPUSH
34963: CALL_OW 564
// GiveMedals ( MAIN ) ;
34967: LD_STRING MAIN
34969: PPUSH
34970: CALL_OW 102
// music_class := 4 ;
34974: LD_ADDR_OWVAR 72
34978: PUSH
34979: LD_INT 4
34981: ST_TO_ADDR
// music_nat := 1 ;
34982: LD_ADDR_OWVAR 71
34986: PUSH
34987: LD_INT 1
34989: ST_TO_ADDR
// YouWin ;
34990: CALL_OW 103
// end ; end_of_file
34994: PPOPN 3
34996: END
// export function CustomEvent ( event ) ; begin
34997: LD_INT 0
34999: PPUSH
// end ;
35000: LD_VAR 0 2
35004: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35005: LD_VAR 0 1
35009: PUSH
35010: LD_INT 1
35012: EQUAL
35013: PUSH
35014: LD_VAR 0 2
35018: PUSH
35019: LD_INT 4
35021: EQUAL
35022: AND
35023: PUSH
35024: LD_EXP 59
35028: PPUSH
35029: CALL_OW 300
35033: AND
35034: IFFALSE 35050
// begin wait ( 0 0$2 ) ;
35036: LD_INT 70
35038: PPUSH
35039: CALL_OW 67
// YouLost ( Dismissed ) ;
35043: LD_STRING Dismissed
35045: PPUSH
35046: CALL_OW 104
// end ; end ;
35050: PPOPN 2
35052: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35053: LD_VAR 0 2
35057: PPUSH
35058: LD_VAR 0 3
35062: PPUSH
35063: LD_INT 18
35065: PPUSH
35066: CALL_OW 309
35070: IFFALSE 35079
// YouLost ( Motherlode3 ) ;
35072: LD_STRING Motherlode3
35074: PPUSH
35075: CALL_OW 104
// end ;
35079: PPOPN 3
35081: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35082: LD_EXP 27
35086: NOT
35087: IFFALSE 35097
// behemothDone := true ;
35089: LD_ADDR_EXP 28
35093: PUSH
35094: LD_INT 1
35096: ST_TO_ADDR
// end ;
35097: PPOPN 1
35099: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35100: LD_VAR 0 1
35104: PPUSH
35105: CALL_OW 255
35109: PUSH
35110: LD_INT 1
35112: EQUAL
35113: IFFALSE 35123
// bombExploded := true ;
35115: LD_ADDR_EXP 37
35119: PUSH
35120: LD_INT 1
35122: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35123: LD_VAR 0 1
35127: PPUSH
35128: CALL_OW 255
35132: PUSH
35133: LD_INT 3
35135: EQUAL
35136: IFFALSE 35166
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35138: LD_INT 2
35140: PPUSH
35141: LD_INT 23
35143: PUSH
35144: LD_INT 3
35146: PUSH
35147: LD_INT 3
35149: PUSH
35150: LD_INT 48
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: PUSH
35159: EMPTY
35160: LIST
35161: PPUSH
35162: CALL 60941 0 2
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35166: LD_VAR 0 1
35170: PPUSH
35171: CALL_OW 255
35175: PUSH
35176: LD_INT 1
35178: EQUAL
35179: PUSH
35180: LD_EXP 30
35184: AND
35185: PUSH
35186: LD_INT 22
35188: PUSH
35189: LD_INT 3
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 34
35198: PUSH
35199: LD_INT 48
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PPUSH
35210: CALL_OW 69
35214: AND
35215: PUSH
35216: LD_INT 22
35218: PUSH
35219: LD_INT 1
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 34
35228: PUSH
35229: LD_INT 8
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PPUSH
35240: CALL_OW 69
35244: NOT
35245: AND
35246: IFFALSE 35298
// begin wait ( 0 0$5 ) ;
35248: LD_INT 175
35250: PPUSH
35251: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35255: LD_INT 22
35257: PUSH
35258: LD_INT 3
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 34
35267: PUSH
35268: LD_INT 48
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PPUSH
35279: CALL_OW 69
35283: PUSH
35284: LD_INT 1
35286: ARRAY
35287: PPUSH
35288: LD_INT 60
35290: PPUSH
35291: LD_INT 95
35293: PPUSH
35294: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35298: LD_VAR 0 2
35302: PPUSH
35303: LD_VAR 0 3
35307: PPUSH
35308: LD_INT 18
35310: PPUSH
35311: CALL_OW 309
35315: PUSH
35316: LD_VAR 0 2
35320: PPUSH
35321: LD_VAR 0 3
35325: PPUSH
35326: LD_INT 18
35328: PPUSH
35329: CALL 108587 0 3
35333: OR
35334: IFFALSE 35381
// begin if GetSide ( unit ) = 1 then
35336: LD_VAR 0 1
35340: PPUSH
35341: CALL_OW 255
35345: PUSH
35346: LD_INT 1
35348: EQUAL
35349: IFFALSE 35367
// begin wait ( 0 0$6 ) ;
35351: LD_INT 210
35353: PPUSH
35354: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35358: LD_STRING Motherlode2
35360: PPUSH
35361: CALL_OW 104
// end else
35365: GO 35381
// begin wait ( 0 0$6 ) ;
35367: LD_INT 210
35369: PPUSH
35370: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35374: LD_STRING Motherlode1
35376: PPUSH
35377: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35381: LD_VAR 0 1
35385: PPUSH
35386: CALL_OW 255
35390: PUSH
35391: LD_INT 3
35393: EQUAL
35394: IFFALSE 35415
// begin wait ( 0 0$5 ) ;
35396: LD_INT 175
35398: PPUSH
35399: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35403: LD_EXP 65
35407: PPUSH
35408: LD_STRING D18-Pla-1
35410: PPUSH
35411: CALL_OW 94
// end ; end ;
35415: PPOPN 3
35417: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35418: LD_VAR 0 1
35422: PPUSH
35423: CALL 124346 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35427: LD_VAR 0 1
35431: PUSH
35432: LD_INT 22
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 21
35444: PUSH
35445: LD_INT 1
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 23
35454: PUSH
35455: LD_INT 1
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: LIST
35466: PPUSH
35467: CALL_OW 69
35471: IN
35472: IFFALSE 35488
// lostCounter := lostCounter + 1 ;
35474: LD_ADDR_EXP 32
35478: PUSH
35479: LD_EXP 32
35483: PUSH
35484: LD_INT 1
35486: PLUS
35487: ST_TO_ADDR
// if un in behemothBuilders then
35488: LD_VAR 0 1
35492: PUSH
35493: LD_EXP 74
35497: IN
35498: IFFALSE 35518
// begin behemothBuilders := behemothBuilders diff un ;
35500: LD_ADDR_EXP 74
35504: PUSH
35505: LD_EXP 74
35509: PUSH
35510: LD_VAR 0 1
35514: DIFF
35515: ST_TO_ADDR
// exit ;
35516: GO 35548
// end ; if un = JMM then
35518: LD_VAR 0 1
35522: PUSH
35523: LD_EXP 40
35527: EQUAL
35528: IFFALSE 35539
// begin YouLost ( JMM ) ;
35530: LD_STRING JMM
35532: PPUSH
35533: CALL_OW 104
// exit ;
35537: GO 35548
// end ; MCE_UnitDestroyed ( un ) ;
35539: LD_VAR 0 1
35543: PPUSH
35544: CALL 64345 0 1
// end ;
35548: PPOPN 1
35550: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35551: LD_VAR 0 1
35555: PPUSH
35556: LD_VAR 0 2
35560: PPUSH
35561: CALL 66677 0 2
// end ;
35565: PPOPN 2
35567: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35568: LD_VAR 0 1
35572: PPUSH
35573: CALL 65745 0 1
// end ;
35577: PPOPN 1
35579: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35580: LD_VAR 0 1
35584: PUSH
35585: LD_INT 22
35587: PUSH
35588: LD_INT 8
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 30
35597: PUSH
35598: LD_INT 2
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 23
35607: PUSH
35608: LD_INT 3
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: LIST
35619: PPUSH
35620: CALL_OW 69
35624: IN
35625: IFFALSE 35652
// begin ComUpgrade ( building ) ;
35627: LD_VAR 0 1
35631: PPUSH
35632: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35636: LD_EXP 62
35640: PPUSH
35641: LD_VAR 0 1
35645: PPUSH
35646: CALL 75327 0 2
// exit ;
35650: GO 35661
// end ; MCE_BuildingComplete ( building ) ;
35652: LD_VAR 0 1
35656: PPUSH
35657: CALL 65986 0 1
// end ;
35661: PPOPN 1
35663: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35664: LD_VAR 0 1
35668: PPUSH
35669: LD_VAR 0 2
35673: PPUSH
35674: CALL 64041 0 2
// end ;
35678: PPOPN 2
35680: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35681: LD_VAR 0 1
35685: PPUSH
35686: LD_VAR 0 2
35690: PPUSH
35691: LD_VAR 0 3
35695: PPUSH
35696: LD_VAR 0 4
35700: PPUSH
35701: LD_VAR 0 5
35705: PPUSH
35706: CALL 63661 0 5
// end ;
35710: PPOPN 5
35712: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35713: LD_VAR 0 1
35717: PPUSH
35718: CALL_OW 255
35722: PUSH
35723: LD_INT 1
35725: EQUAL
35726: IFFALSE 35743
// amConstructCounter := Inc ( amConstructCounter ) ;
35728: LD_ADDR_EXP 39
35732: PUSH
35733: LD_EXP 39
35737: PPUSH
35738: CALL 106139 0 1
35742: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35743: LD_VAR 0 1
35747: PPUSH
35748: LD_VAR 0 2
35752: PPUSH
35753: CALL 124466 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35757: LD_VAR 0 1
35761: PPUSH
35762: LD_VAR 0 2
35766: PPUSH
35767: CALL 63252 0 2
// end ;
35771: PPOPN 2
35773: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35774: LD_VAR 0 1
35778: PPUSH
35779: LD_VAR 0 2
35783: PPUSH
35784: LD_VAR 0 3
35788: PPUSH
35789: LD_VAR 0 4
35793: PPUSH
35794: CALL 63090 0 4
// end ;
35798: PPOPN 4
35800: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35801: LD_VAR 0 1
35805: PPUSH
35806: LD_VAR 0 2
35810: PPUSH
35811: LD_VAR 0 3
35815: PPUSH
35816: CALL 62865 0 3
// end ;
35820: PPOPN 3
35822: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
35823: LD_VAR 0 1
35827: PPUSH
35828: LD_VAR 0 2
35832: PPUSH
35833: CALL 62750 0 2
// end ;
35837: PPOPN 2
35839: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
35840: LD_VAR 0 1
35844: PPUSH
35845: LD_VAR 0 2
35849: PPUSH
35850: CALL 66972 0 2
// end ;
35854: PPOPN 2
35856: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
35857: LD_VAR 0 1
35861: PPUSH
35862: CALL_OW 255
35866: PUSH
35867: LD_INT 4
35869: EQUAL
35870: PUSH
35871: LD_VAR 0 1
35875: PUSH
35876: LD_EXP 18
35880: PUSH
35881: LD_INT 1
35883: ARRAY
35884: IN
35885: AND
35886: PUSH
35887: LD_EXP 19
35891: AND
35892: IFFALSE 35911
// begin ComMoveXY ( driver , 61 , 93 ) ;
35894: LD_VAR 0 1
35898: PPUSH
35899: LD_INT 61
35901: PPUSH
35902: LD_INT 93
35904: PPUSH
35905: CALL_OW 111
// exit ;
35909: GO 35935
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
35911: LD_VAR 0 1
35915: PPUSH
35916: LD_VAR 0 2
35920: PPUSH
35921: LD_VAR 0 3
35925: PPUSH
35926: LD_VAR 0 4
35930: PPUSH
35931: CALL 67188 0 4
// end ;
35935: PPOPN 4
35937: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
35938: LD_VAR 0 1
35942: PPUSH
35943: LD_VAR 0 2
35947: PPUSH
35948: CALL 62559 0 2
// end ;
35952: PPOPN 2
35954: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
35955: LD_VAR 0 1
35959: PPUSH
35960: CALL 124450 0 1
// end ; end_of_file
35964: PPOPN 1
35966: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
35967: LD_EXP 15
35971: PUSH
35972: LD_INT 2
35974: EQUAL
35975: IFFALSE 36478
35977: GO 35979
35979: DISABLE
35980: LD_INT 0
35982: PPUSH
35983: PPUSH
// begin time := 0 0$35 ;
35984: LD_ADDR_VAR 0 2
35988: PUSH
35989: LD_INT 1225
35991: ST_TO_ADDR
// repeat wait ( time ) ;
35992: LD_VAR 0 2
35996: PPUSH
35997: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36001: LD_INT 1
36003: PPUSH
36004: LD_INT 5
36006: PPUSH
36007: CALL_OW 12
36011: PPUSH
36012: LD_INT 106
36014: PPUSH
36015: LD_INT 150
36017: PPUSH
36018: LD_INT 19
36020: PPUSH
36021: LD_INT 1
36023: PPUSH
36024: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36028: LD_INT 455
36030: PPUSH
36031: LD_INT 770
36033: PPUSH
36034: CALL_OW 12
36038: PPUSH
36039: CALL_OW 67
// if Prob ( 50 ) then
36043: LD_INT 50
36045: PPUSH
36046: CALL_OW 13
36050: IFFALSE 36079
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36052: LD_INT 1
36054: PPUSH
36055: LD_INT 5
36057: PPUSH
36058: CALL_OW 12
36062: PPUSH
36063: LD_INT 62
36065: PPUSH
36066: LD_INT 108
36068: PPUSH
36069: LD_INT 10
36071: PPUSH
36072: LD_INT 1
36074: PPUSH
36075: CALL_OW 56
// until missionStage > 4 ;
36079: LD_EXP 15
36083: PUSH
36084: LD_INT 4
36086: GREATER
36087: IFFALSE 35992
// repeat wait ( 0 0$1 ) ;
36089: LD_INT 35
36091: PPUSH
36092: CALL_OW 67
// until missionStage = 6 ;
36096: LD_EXP 15
36100: PUSH
36101: LD_INT 6
36103: EQUAL
36104: IFFALSE 36089
// time := 0 0$20 ;
36106: LD_ADDR_VAR 0 2
36110: PUSH
36111: LD_INT 700
36113: ST_TO_ADDR
// repeat wait ( time ) ;
36114: LD_VAR 0 2
36118: PPUSH
36119: CALL_OW 67
// if Prob ( 90 ) then
36123: LD_INT 90
36125: PPUSH
36126: CALL_OW 13
36130: IFFALSE 36173
// begin time := time + 0 0$2 ;
36132: LD_ADDR_VAR 0 2
36136: PUSH
36137: LD_VAR 0 2
36141: PUSH
36142: LD_INT 70
36144: PLUS
36145: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36146: LD_INT 1
36148: PPUSH
36149: LD_INT 5
36151: PPUSH
36152: CALL_OW 12
36156: PPUSH
36157: LD_INT 106
36159: PPUSH
36160: LD_INT 89
36162: PPUSH
36163: LD_INT 45
36165: PPUSH
36166: LD_INT 1
36168: PPUSH
36169: CALL_OW 56
// end ; if Prob ( 45 ) then
36173: LD_INT 45
36175: PPUSH
36176: CALL_OW 13
36180: IFFALSE 36236
// begin for i := 1 to 4 do
36182: LD_ADDR_VAR 0 1
36186: PUSH
36187: DOUBLE
36188: LD_INT 1
36190: DEC
36191: ST_TO_ADDR
36192: LD_INT 4
36194: PUSH
36195: FOR_TO
36196: IFFALSE 36234
// begin wait ( 0 0$5 ) ;
36198: LD_INT 175
36200: PPUSH
36201: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36205: LD_INT 1
36207: PPUSH
36208: LD_INT 5
36210: PPUSH
36211: CALL_OW 12
36215: PPUSH
36216: LD_INT 113
36218: PPUSH
36219: LD_INT 117
36221: PPUSH
36222: LD_INT 25
36224: PPUSH
36225: LD_INT 1
36227: PPUSH
36228: CALL_OW 56
// end ;
36232: GO 36195
36234: POP
36235: POP
// end ; if Prob ( 40 ) then
36236: LD_INT 40
36238: PPUSH
36239: CALL_OW 13
36243: IFFALSE 36289
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36245: LD_INT 385
36247: PPUSH
36248: LD_INT 945
36250: PPUSH
36251: CALL_OW 12
36255: PPUSH
36256: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36260: LD_INT 1
36262: PPUSH
36263: LD_INT 5
36265: PPUSH
36266: CALL_OW 12
36270: PPUSH
36271: LD_INT 21
36273: PPUSH
36274: LD_INT 26
36276: PPUSH
36277: LD_INT 12
36279: PPUSH
36280: LD_INT 1
36282: PPUSH
36283: CALL_OW 56
// end else
36287: GO 36325
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36289: LD_INT 700
36291: PPUSH
36292: LD_INT 1225
36294: PPUSH
36295: CALL_OW 12
36299: PPUSH
36300: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36304: LD_INT 1
36306: PPUSH
36307: LD_INT 5
36309: PPUSH
36310: CALL_OW 12
36314: PPUSH
36315: LD_INT 16
36317: PPUSH
36318: LD_INT 1
36320: PPUSH
36321: CALL_OW 55
// end ; if Prob ( 50 ) then
36325: LD_INT 50
36327: PPUSH
36328: CALL_OW 13
36332: IFFALSE 36378
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36334: LD_INT 700
36336: PPUSH
36337: LD_INT 1050
36339: PPUSH
36340: CALL_OW 12
36344: PPUSH
36345: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36349: LD_INT 1
36351: PPUSH
36352: LD_INT 5
36354: PPUSH
36355: CALL_OW 12
36359: PPUSH
36360: LD_INT 168
36362: PPUSH
36363: LD_INT 168
36365: PPUSH
36366: LD_INT 16
36368: PPUSH
36369: LD_INT 1
36371: PPUSH
36372: CALL_OW 56
// end else
36376: GO 36414
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36378: LD_INT 350
36380: PPUSH
36381: LD_INT 525
36383: PPUSH
36384: CALL_OW 12
36388: PPUSH
36389: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36393: LD_INT 1
36395: PPUSH
36396: LD_INT 5
36398: PPUSH
36399: CALL_OW 12
36403: PPUSH
36404: LD_INT 15
36406: PPUSH
36407: LD_INT 1
36409: PPUSH
36410: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36414: LD_INT 175
36416: PPUSH
36417: LD_INT 315
36419: PPUSH
36420: CALL_OW 12
36424: PPUSH
36425: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36429: LD_INT 1
36431: PPUSH
36432: LD_INT 5
36434: PPUSH
36435: CALL_OW 12
36439: PPUSH
36440: LD_INT 103
36442: PPUSH
36443: LD_INT 140
36445: PPUSH
36446: LD_INT 20
36448: PPUSH
36449: LD_INT 1
36451: PPUSH
36452: CALL_OW 56
// if time > 1 1$10 then
36456: LD_VAR 0 2
36460: PUSH
36461: LD_INT 2450
36463: GREATER
36464: IFFALSE 36474
// time := 0 0$30 ;
36466: LD_ADDR_VAR 0 2
36470: PUSH
36471: LD_INT 1050
36473: ST_TO_ADDR
// until false ;
36474: LD_INT 0
36476: IFFALSE 36114
// end ; end_of_file
36478: PPOPN 2
36480: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36481: LD_EXP 13
36485: PUSH
36486: LD_EXP 15
36490: PUSH
36491: LD_INT 6
36493: GREATEREQUAL
36494: AND
36495: IFFALSE 36532
36497: GO 36499
36499: DISABLE
// begin enable ;
36500: ENABLE
// missionTime := missionTime + 0 0$1 ;
36501: LD_ADDR_EXP 14
36505: PUSH
36506: LD_EXP 14
36510: PUSH
36511: LD_INT 35
36513: PLUS
36514: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36515: LD_ADDR_OWVAR 47
36519: PUSH
36520: LD_STRING #Am15-1
36522: PUSH
36523: LD_EXP 14
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: ST_TO_ADDR
// end ; end_of_file
36532: END
// export function InitNature ; begin
36533: LD_INT 0
36535: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36536: LD_INT 3
36538: PPUSH
36539: LD_INT 3
36541: PPUSH
36542: LD_INT 2
36544: PPUSH
36545: LD_INT 1
36547: PPUSH
36548: LD_INT 1
36550: PPUSH
36551: LD_INT 0
36553: PPUSH
36554: LD_INT 0
36556: PPUSH
36557: LD_INT 20
36559: PPUSH
36560: LD_INT 0
36562: PPUSH
36563: CALL 101460 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36567: LD_INT 2
36569: PPUSH
36570: LD_INT 1
36572: PPUSH
36573: LD_INT 1
36575: PPUSH
36576: LD_INT 1
36578: PPUSH
36579: LD_INT 1
36581: PPUSH
36582: LD_INT 0
36584: PPUSH
36585: LD_INT 0
36587: PPUSH
36588: LD_INT 21
36590: PPUSH
36591: LD_INT 0
36593: PPUSH
36594: CALL 101460 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36598: LD_INT 4
36600: PPUSH
36601: LD_INT 1
36603: PPUSH
36604: LD_INT 2
36606: PPUSH
36607: LD_INT 4
36609: PPUSH
36610: LD_INT 2
36612: PPUSH
36613: LD_INT 1
36615: PPUSH
36616: LD_INT 0
36618: PPUSH
36619: LD_INT 22
36621: PPUSH
36622: LD_INT 0
36624: PPUSH
36625: CALL 101460 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36629: LD_INT 0
36631: PPUSH
36632: LD_INT 0
36634: PPUSH
36635: LD_INT 0
36637: PPUSH
36638: LD_INT 0
36640: PPUSH
36641: LD_INT 0
36643: PPUSH
36644: LD_INT 0
36646: PPUSH
36647: LD_INT 9
36649: PPUSH
36650: LD_INT 0
36652: PPUSH
36653: LD_INT 23
36655: PPUSH
36656: CALL 101460 0 9
// end ; end_of_file
36660: LD_VAR 0 1
36664: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36665: LD_INT 0
36667: PPUSH
36668: PPUSH
// skirmish := false ;
36669: LD_ADDR_EXP 97
36673: PUSH
36674: LD_INT 0
36676: ST_TO_ADDR
// debug_mc := false ;
36677: LD_ADDR_EXP 98
36681: PUSH
36682: LD_INT 0
36684: ST_TO_ADDR
// mc_bases := [ ] ;
36685: LD_ADDR_EXP 99
36689: PUSH
36690: EMPTY
36691: ST_TO_ADDR
// mc_sides := [ ] ;
36692: LD_ADDR_EXP 125
36696: PUSH
36697: EMPTY
36698: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36699: LD_ADDR_EXP 100
36703: PUSH
36704: EMPTY
36705: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36706: LD_ADDR_EXP 101
36710: PUSH
36711: EMPTY
36712: ST_TO_ADDR
// mc_need_heal := [ ] ;
36713: LD_ADDR_EXP 102
36717: PUSH
36718: EMPTY
36719: ST_TO_ADDR
// mc_healers := [ ] ;
36720: LD_ADDR_EXP 103
36724: PUSH
36725: EMPTY
36726: ST_TO_ADDR
// mc_build_list := [ ] ;
36727: LD_ADDR_EXP 104
36731: PUSH
36732: EMPTY
36733: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36734: LD_ADDR_EXP 131
36738: PUSH
36739: EMPTY
36740: ST_TO_ADDR
// mc_builders := [ ] ;
36741: LD_ADDR_EXP 105
36745: PUSH
36746: EMPTY
36747: ST_TO_ADDR
// mc_construct_list := [ ] ;
36748: LD_ADDR_EXP 106
36752: PUSH
36753: EMPTY
36754: ST_TO_ADDR
// mc_turret_list := [ ] ;
36755: LD_ADDR_EXP 107
36759: PUSH
36760: EMPTY
36761: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36762: LD_ADDR_EXP 108
36766: PUSH
36767: EMPTY
36768: ST_TO_ADDR
// mc_miners := [ ] ;
36769: LD_ADDR_EXP 113
36773: PUSH
36774: EMPTY
36775: ST_TO_ADDR
// mc_mines := [ ] ;
36776: LD_ADDR_EXP 112
36780: PUSH
36781: EMPTY
36782: ST_TO_ADDR
// mc_minefields := [ ] ;
36783: LD_ADDR_EXP 114
36787: PUSH
36788: EMPTY
36789: ST_TO_ADDR
// mc_crates := [ ] ;
36790: LD_ADDR_EXP 115
36794: PUSH
36795: EMPTY
36796: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36797: LD_ADDR_EXP 116
36801: PUSH
36802: EMPTY
36803: ST_TO_ADDR
// mc_crates_area := [ ] ;
36804: LD_ADDR_EXP 117
36808: PUSH
36809: EMPTY
36810: ST_TO_ADDR
// mc_vehicles := [ ] ;
36811: LD_ADDR_EXP 118
36815: PUSH
36816: EMPTY
36817: ST_TO_ADDR
// mc_attack := [ ] ;
36818: LD_ADDR_EXP 119
36822: PUSH
36823: EMPTY
36824: ST_TO_ADDR
// mc_produce := [ ] ;
36825: LD_ADDR_EXP 120
36829: PUSH
36830: EMPTY
36831: ST_TO_ADDR
// mc_defender := [ ] ;
36832: LD_ADDR_EXP 121
36836: PUSH
36837: EMPTY
36838: ST_TO_ADDR
// mc_parking := [ ] ;
36839: LD_ADDR_EXP 123
36843: PUSH
36844: EMPTY
36845: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
36846: LD_ADDR_EXP 109
36850: PUSH
36851: EMPTY
36852: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
36853: LD_ADDR_EXP 111
36857: PUSH
36858: EMPTY
36859: ST_TO_ADDR
// mc_scan := [ ] ;
36860: LD_ADDR_EXP 122
36864: PUSH
36865: EMPTY
36866: ST_TO_ADDR
// mc_scan_area := [ ] ;
36867: LD_ADDR_EXP 124
36871: PUSH
36872: EMPTY
36873: ST_TO_ADDR
// mc_tech := [ ] ;
36874: LD_ADDR_EXP 126
36878: PUSH
36879: EMPTY
36880: ST_TO_ADDR
// mc_class := [ ] ;
36881: LD_ADDR_EXP 140
36885: PUSH
36886: EMPTY
36887: ST_TO_ADDR
// mc_class_case_use := [ ] ;
36888: LD_ADDR_EXP 141
36892: PUSH
36893: EMPTY
36894: ST_TO_ADDR
// mc_is_defending := [ ] ;
36895: LD_ADDR_EXP 142
36899: PUSH
36900: EMPTY
36901: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
36902: LD_ADDR_EXP 133
36906: PUSH
36907: EMPTY
36908: ST_TO_ADDR
// end ;
36909: LD_VAR 0 1
36913: RET
// export function MC_Kill ( base ) ; begin
36914: LD_INT 0
36916: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
36917: LD_ADDR_EXP 99
36921: PUSH
36922: LD_EXP 99
36926: PPUSH
36927: LD_VAR 0 1
36931: PPUSH
36932: EMPTY
36933: PPUSH
36934: CALL_OW 1
36938: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36939: LD_ADDR_EXP 100
36943: PUSH
36944: LD_EXP 100
36948: PPUSH
36949: LD_VAR 0 1
36953: PPUSH
36954: EMPTY
36955: PPUSH
36956: CALL_OW 1
36960: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36961: LD_ADDR_EXP 101
36965: PUSH
36966: LD_EXP 101
36970: PPUSH
36971: LD_VAR 0 1
36975: PPUSH
36976: EMPTY
36977: PPUSH
36978: CALL_OW 1
36982: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36983: LD_ADDR_EXP 102
36987: PUSH
36988: LD_EXP 102
36992: PPUSH
36993: LD_VAR 0 1
36997: PPUSH
36998: EMPTY
36999: PPUSH
37000: CALL_OW 1
37004: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37005: LD_ADDR_EXP 103
37009: PUSH
37010: LD_EXP 103
37014: PPUSH
37015: LD_VAR 0 1
37019: PPUSH
37020: EMPTY
37021: PPUSH
37022: CALL_OW 1
37026: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37027: LD_ADDR_EXP 104
37031: PUSH
37032: LD_EXP 104
37036: PPUSH
37037: LD_VAR 0 1
37041: PPUSH
37042: EMPTY
37043: PPUSH
37044: CALL_OW 1
37048: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37049: LD_ADDR_EXP 105
37053: PUSH
37054: LD_EXP 105
37058: PPUSH
37059: LD_VAR 0 1
37063: PPUSH
37064: EMPTY
37065: PPUSH
37066: CALL_OW 1
37070: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37071: LD_ADDR_EXP 106
37075: PUSH
37076: LD_EXP 106
37080: PPUSH
37081: LD_VAR 0 1
37085: PPUSH
37086: EMPTY
37087: PPUSH
37088: CALL_OW 1
37092: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37093: LD_ADDR_EXP 107
37097: PUSH
37098: LD_EXP 107
37102: PPUSH
37103: LD_VAR 0 1
37107: PPUSH
37108: EMPTY
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37115: LD_ADDR_EXP 108
37119: PUSH
37120: LD_EXP 108
37124: PPUSH
37125: LD_VAR 0 1
37129: PPUSH
37130: EMPTY
37131: PPUSH
37132: CALL_OW 1
37136: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37137: LD_ADDR_EXP 109
37141: PUSH
37142: LD_EXP 109
37146: PPUSH
37147: LD_VAR 0 1
37151: PPUSH
37152: EMPTY
37153: PPUSH
37154: CALL_OW 1
37158: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37159: LD_ADDR_EXP 110
37163: PUSH
37164: LD_EXP 110
37168: PPUSH
37169: LD_VAR 0 1
37173: PPUSH
37174: LD_INT 0
37176: PPUSH
37177: CALL_OW 1
37181: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37182: LD_ADDR_EXP 111
37186: PUSH
37187: LD_EXP 111
37191: PPUSH
37192: LD_VAR 0 1
37196: PPUSH
37197: EMPTY
37198: PPUSH
37199: CALL_OW 1
37203: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37204: LD_ADDR_EXP 112
37208: PUSH
37209: LD_EXP 112
37213: PPUSH
37214: LD_VAR 0 1
37218: PPUSH
37219: EMPTY
37220: PPUSH
37221: CALL_OW 1
37225: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37226: LD_ADDR_EXP 113
37230: PUSH
37231: LD_EXP 113
37235: PPUSH
37236: LD_VAR 0 1
37240: PPUSH
37241: EMPTY
37242: PPUSH
37243: CALL_OW 1
37247: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37248: LD_ADDR_EXP 114
37252: PUSH
37253: LD_EXP 114
37257: PPUSH
37258: LD_VAR 0 1
37262: PPUSH
37263: EMPTY
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37270: LD_ADDR_EXP 115
37274: PUSH
37275: LD_EXP 115
37279: PPUSH
37280: LD_VAR 0 1
37284: PPUSH
37285: EMPTY
37286: PPUSH
37287: CALL_OW 1
37291: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37292: LD_ADDR_EXP 116
37296: PUSH
37297: LD_EXP 116
37301: PPUSH
37302: LD_VAR 0 1
37306: PPUSH
37307: EMPTY
37308: PPUSH
37309: CALL_OW 1
37313: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37314: LD_ADDR_EXP 117
37318: PUSH
37319: LD_EXP 117
37323: PPUSH
37324: LD_VAR 0 1
37328: PPUSH
37329: EMPTY
37330: PPUSH
37331: CALL_OW 1
37335: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37336: LD_ADDR_EXP 118
37340: PUSH
37341: LD_EXP 118
37345: PPUSH
37346: LD_VAR 0 1
37350: PPUSH
37351: EMPTY
37352: PPUSH
37353: CALL_OW 1
37357: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37358: LD_ADDR_EXP 119
37362: PUSH
37363: LD_EXP 119
37367: PPUSH
37368: LD_VAR 0 1
37372: PPUSH
37373: EMPTY
37374: PPUSH
37375: CALL_OW 1
37379: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37380: LD_ADDR_EXP 120
37384: PUSH
37385: LD_EXP 120
37389: PPUSH
37390: LD_VAR 0 1
37394: PPUSH
37395: EMPTY
37396: PPUSH
37397: CALL_OW 1
37401: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37402: LD_ADDR_EXP 121
37406: PUSH
37407: LD_EXP 121
37411: PPUSH
37412: LD_VAR 0 1
37416: PPUSH
37417: EMPTY
37418: PPUSH
37419: CALL_OW 1
37423: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37424: LD_ADDR_EXP 122
37428: PUSH
37429: LD_EXP 122
37433: PPUSH
37434: LD_VAR 0 1
37438: PPUSH
37439: EMPTY
37440: PPUSH
37441: CALL_OW 1
37445: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37446: LD_ADDR_EXP 123
37450: PUSH
37451: LD_EXP 123
37455: PPUSH
37456: LD_VAR 0 1
37460: PPUSH
37461: EMPTY
37462: PPUSH
37463: CALL_OW 1
37467: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37468: LD_ADDR_EXP 124
37472: PUSH
37473: LD_EXP 124
37477: PPUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: EMPTY
37484: PPUSH
37485: CALL_OW 1
37489: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37490: LD_ADDR_EXP 126
37494: PUSH
37495: LD_EXP 126
37499: PPUSH
37500: LD_VAR 0 1
37504: PPUSH
37505: EMPTY
37506: PPUSH
37507: CALL_OW 1
37511: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37512: LD_ADDR_EXP 128
37516: PUSH
37517: LD_EXP 128
37521: PPUSH
37522: LD_VAR 0 1
37526: PPUSH
37527: EMPTY
37528: PPUSH
37529: CALL_OW 1
37533: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37534: LD_ADDR_EXP 129
37538: PUSH
37539: LD_EXP 129
37543: PPUSH
37544: LD_VAR 0 1
37548: PPUSH
37549: EMPTY
37550: PPUSH
37551: CALL_OW 1
37555: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37556: LD_ADDR_EXP 130
37560: PUSH
37561: LD_EXP 130
37565: PPUSH
37566: LD_VAR 0 1
37570: PPUSH
37571: EMPTY
37572: PPUSH
37573: CALL_OW 1
37577: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37578: LD_ADDR_EXP 131
37582: PUSH
37583: LD_EXP 131
37587: PPUSH
37588: LD_VAR 0 1
37592: PPUSH
37593: EMPTY
37594: PPUSH
37595: CALL_OW 1
37599: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37600: LD_ADDR_EXP 132
37604: PUSH
37605: LD_EXP 132
37609: PPUSH
37610: LD_VAR 0 1
37614: PPUSH
37615: EMPTY
37616: PPUSH
37617: CALL_OW 1
37621: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37622: LD_ADDR_EXP 133
37626: PUSH
37627: LD_EXP 133
37631: PPUSH
37632: LD_VAR 0 1
37636: PPUSH
37637: EMPTY
37638: PPUSH
37639: CALL_OW 1
37643: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37644: LD_ADDR_EXP 134
37648: PUSH
37649: LD_EXP 134
37653: PPUSH
37654: LD_VAR 0 1
37658: PPUSH
37659: EMPTY
37660: PPUSH
37661: CALL_OW 1
37665: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37666: LD_ADDR_EXP 135
37670: PUSH
37671: LD_EXP 135
37675: PPUSH
37676: LD_VAR 0 1
37680: PPUSH
37681: EMPTY
37682: PPUSH
37683: CALL_OW 1
37687: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37688: LD_ADDR_EXP 136
37692: PUSH
37693: LD_EXP 136
37697: PPUSH
37698: LD_VAR 0 1
37702: PPUSH
37703: EMPTY
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37710: LD_ADDR_EXP 137
37714: PUSH
37715: LD_EXP 137
37719: PPUSH
37720: LD_VAR 0 1
37724: PPUSH
37725: EMPTY
37726: PPUSH
37727: CALL_OW 1
37731: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37732: LD_ADDR_EXP 138
37736: PUSH
37737: LD_EXP 138
37741: PPUSH
37742: LD_VAR 0 1
37746: PPUSH
37747: EMPTY
37748: PPUSH
37749: CALL_OW 1
37753: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37754: LD_ADDR_EXP 139
37758: PUSH
37759: LD_EXP 139
37763: PPUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: EMPTY
37770: PPUSH
37771: CALL_OW 1
37775: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37776: LD_ADDR_EXP 140
37780: PUSH
37781: LD_EXP 140
37785: PPUSH
37786: LD_VAR 0 1
37790: PPUSH
37791: EMPTY
37792: PPUSH
37793: CALL_OW 1
37797: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37798: LD_ADDR_EXP 141
37802: PUSH
37803: LD_EXP 141
37807: PPUSH
37808: LD_VAR 0 1
37812: PPUSH
37813: LD_INT 0
37815: PPUSH
37816: CALL_OW 1
37820: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37821: LD_ADDR_EXP 142
37825: PUSH
37826: LD_EXP 142
37830: PPUSH
37831: LD_VAR 0 1
37835: PPUSH
37836: LD_INT 0
37838: PPUSH
37839: CALL_OW 1
37843: ST_TO_ADDR
// end ;
37844: LD_VAR 0 2
37848: RET
// export function MC_Add ( side , units ) ; var base ; begin
37849: LD_INT 0
37851: PPUSH
37852: PPUSH
// base := mc_bases + 1 ;
37853: LD_ADDR_VAR 0 4
37857: PUSH
37858: LD_EXP 99
37862: PUSH
37863: LD_INT 1
37865: PLUS
37866: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
37867: LD_ADDR_EXP 125
37871: PUSH
37872: LD_EXP 125
37876: PPUSH
37877: LD_VAR 0 4
37881: PPUSH
37882: LD_VAR 0 1
37886: PPUSH
37887: CALL_OW 1
37891: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
37892: LD_ADDR_EXP 99
37896: PUSH
37897: LD_EXP 99
37901: PPUSH
37902: LD_VAR 0 4
37906: PPUSH
37907: LD_VAR 0 2
37911: PPUSH
37912: CALL_OW 1
37916: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37917: LD_ADDR_EXP 100
37921: PUSH
37922: LD_EXP 100
37926: PPUSH
37927: LD_VAR 0 4
37931: PPUSH
37932: EMPTY
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37939: LD_ADDR_EXP 101
37943: PUSH
37944: LD_EXP 101
37948: PPUSH
37949: LD_VAR 0 4
37953: PPUSH
37954: EMPTY
37955: PPUSH
37956: CALL_OW 1
37960: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37961: LD_ADDR_EXP 102
37965: PUSH
37966: LD_EXP 102
37970: PPUSH
37971: LD_VAR 0 4
37975: PPUSH
37976: EMPTY
37977: PPUSH
37978: CALL_OW 1
37982: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37983: LD_ADDR_EXP 103
37987: PUSH
37988: LD_EXP 103
37992: PPUSH
37993: LD_VAR 0 4
37997: PPUSH
37998: EMPTY
37999: PPUSH
38000: CALL_OW 1
38004: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38005: LD_ADDR_EXP 104
38009: PUSH
38010: LD_EXP 104
38014: PPUSH
38015: LD_VAR 0 4
38019: PPUSH
38020: EMPTY
38021: PPUSH
38022: CALL_OW 1
38026: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38027: LD_ADDR_EXP 105
38031: PUSH
38032: LD_EXP 105
38036: PPUSH
38037: LD_VAR 0 4
38041: PPUSH
38042: EMPTY
38043: PPUSH
38044: CALL_OW 1
38048: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38049: LD_ADDR_EXP 106
38053: PUSH
38054: LD_EXP 106
38058: PPUSH
38059: LD_VAR 0 4
38063: PPUSH
38064: EMPTY
38065: PPUSH
38066: CALL_OW 1
38070: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38071: LD_ADDR_EXP 107
38075: PUSH
38076: LD_EXP 107
38080: PPUSH
38081: LD_VAR 0 4
38085: PPUSH
38086: EMPTY
38087: PPUSH
38088: CALL_OW 1
38092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38093: LD_ADDR_EXP 108
38097: PUSH
38098: LD_EXP 108
38102: PPUSH
38103: LD_VAR 0 4
38107: PPUSH
38108: EMPTY
38109: PPUSH
38110: CALL_OW 1
38114: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38115: LD_ADDR_EXP 109
38119: PUSH
38120: LD_EXP 109
38124: PPUSH
38125: LD_VAR 0 4
38129: PPUSH
38130: EMPTY
38131: PPUSH
38132: CALL_OW 1
38136: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38137: LD_ADDR_EXP 110
38141: PUSH
38142: LD_EXP 110
38146: PPUSH
38147: LD_VAR 0 4
38151: PPUSH
38152: LD_INT 0
38154: PPUSH
38155: CALL_OW 1
38159: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38160: LD_ADDR_EXP 111
38164: PUSH
38165: LD_EXP 111
38169: PPUSH
38170: LD_VAR 0 4
38174: PPUSH
38175: EMPTY
38176: PPUSH
38177: CALL_OW 1
38181: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38182: LD_ADDR_EXP 112
38186: PUSH
38187: LD_EXP 112
38191: PPUSH
38192: LD_VAR 0 4
38196: PPUSH
38197: EMPTY
38198: PPUSH
38199: CALL_OW 1
38203: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38204: LD_ADDR_EXP 113
38208: PUSH
38209: LD_EXP 113
38213: PPUSH
38214: LD_VAR 0 4
38218: PPUSH
38219: EMPTY
38220: PPUSH
38221: CALL_OW 1
38225: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38226: LD_ADDR_EXP 114
38230: PUSH
38231: LD_EXP 114
38235: PPUSH
38236: LD_VAR 0 4
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL_OW 1
38247: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38248: LD_ADDR_EXP 115
38252: PUSH
38253: LD_EXP 115
38257: PPUSH
38258: LD_VAR 0 4
38262: PPUSH
38263: EMPTY
38264: PPUSH
38265: CALL_OW 1
38269: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38270: LD_ADDR_EXP 116
38274: PUSH
38275: LD_EXP 116
38279: PPUSH
38280: LD_VAR 0 4
38284: PPUSH
38285: EMPTY
38286: PPUSH
38287: CALL_OW 1
38291: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38292: LD_ADDR_EXP 117
38296: PUSH
38297: LD_EXP 117
38301: PPUSH
38302: LD_VAR 0 4
38306: PPUSH
38307: EMPTY
38308: PPUSH
38309: CALL_OW 1
38313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38314: LD_ADDR_EXP 118
38318: PUSH
38319: LD_EXP 118
38323: PPUSH
38324: LD_VAR 0 4
38328: PPUSH
38329: EMPTY
38330: PPUSH
38331: CALL_OW 1
38335: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38336: LD_ADDR_EXP 119
38340: PUSH
38341: LD_EXP 119
38345: PPUSH
38346: LD_VAR 0 4
38350: PPUSH
38351: EMPTY
38352: PPUSH
38353: CALL_OW 1
38357: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38358: LD_ADDR_EXP 120
38362: PUSH
38363: LD_EXP 120
38367: PPUSH
38368: LD_VAR 0 4
38372: PPUSH
38373: EMPTY
38374: PPUSH
38375: CALL_OW 1
38379: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38380: LD_ADDR_EXP 121
38384: PUSH
38385: LD_EXP 121
38389: PPUSH
38390: LD_VAR 0 4
38394: PPUSH
38395: EMPTY
38396: PPUSH
38397: CALL_OW 1
38401: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38402: LD_ADDR_EXP 122
38406: PUSH
38407: LD_EXP 122
38411: PPUSH
38412: LD_VAR 0 4
38416: PPUSH
38417: EMPTY
38418: PPUSH
38419: CALL_OW 1
38423: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38424: LD_ADDR_EXP 123
38428: PUSH
38429: LD_EXP 123
38433: PPUSH
38434: LD_VAR 0 4
38438: PPUSH
38439: EMPTY
38440: PPUSH
38441: CALL_OW 1
38445: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38446: LD_ADDR_EXP 124
38450: PUSH
38451: LD_EXP 124
38455: PPUSH
38456: LD_VAR 0 4
38460: PPUSH
38461: EMPTY
38462: PPUSH
38463: CALL_OW 1
38467: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38468: LD_ADDR_EXP 126
38472: PUSH
38473: LD_EXP 126
38477: PPUSH
38478: LD_VAR 0 4
38482: PPUSH
38483: EMPTY
38484: PPUSH
38485: CALL_OW 1
38489: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38490: LD_ADDR_EXP 128
38494: PUSH
38495: LD_EXP 128
38499: PPUSH
38500: LD_VAR 0 4
38504: PPUSH
38505: EMPTY
38506: PPUSH
38507: CALL_OW 1
38511: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38512: LD_ADDR_EXP 129
38516: PUSH
38517: LD_EXP 129
38521: PPUSH
38522: LD_VAR 0 4
38526: PPUSH
38527: EMPTY
38528: PPUSH
38529: CALL_OW 1
38533: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38534: LD_ADDR_EXP 130
38538: PUSH
38539: LD_EXP 130
38543: PPUSH
38544: LD_VAR 0 4
38548: PPUSH
38549: EMPTY
38550: PPUSH
38551: CALL_OW 1
38555: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38556: LD_ADDR_EXP 131
38560: PUSH
38561: LD_EXP 131
38565: PPUSH
38566: LD_VAR 0 4
38570: PPUSH
38571: EMPTY
38572: PPUSH
38573: CALL_OW 1
38577: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38578: LD_ADDR_EXP 132
38582: PUSH
38583: LD_EXP 132
38587: PPUSH
38588: LD_VAR 0 4
38592: PPUSH
38593: EMPTY
38594: PPUSH
38595: CALL_OW 1
38599: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38600: LD_ADDR_EXP 133
38604: PUSH
38605: LD_EXP 133
38609: PPUSH
38610: LD_VAR 0 4
38614: PPUSH
38615: EMPTY
38616: PPUSH
38617: CALL_OW 1
38621: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38622: LD_ADDR_EXP 134
38626: PUSH
38627: LD_EXP 134
38631: PPUSH
38632: LD_VAR 0 4
38636: PPUSH
38637: EMPTY
38638: PPUSH
38639: CALL_OW 1
38643: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38644: LD_ADDR_EXP 135
38648: PUSH
38649: LD_EXP 135
38653: PPUSH
38654: LD_VAR 0 4
38658: PPUSH
38659: EMPTY
38660: PPUSH
38661: CALL_OW 1
38665: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38666: LD_ADDR_EXP 136
38670: PUSH
38671: LD_EXP 136
38675: PPUSH
38676: LD_VAR 0 4
38680: PPUSH
38681: EMPTY
38682: PPUSH
38683: CALL_OW 1
38687: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38688: LD_ADDR_EXP 137
38692: PUSH
38693: LD_EXP 137
38697: PPUSH
38698: LD_VAR 0 4
38702: PPUSH
38703: EMPTY
38704: PPUSH
38705: CALL_OW 1
38709: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38710: LD_ADDR_EXP 138
38714: PUSH
38715: LD_EXP 138
38719: PPUSH
38720: LD_VAR 0 4
38724: PPUSH
38725: EMPTY
38726: PPUSH
38727: CALL_OW 1
38731: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38732: LD_ADDR_EXP 139
38736: PUSH
38737: LD_EXP 139
38741: PPUSH
38742: LD_VAR 0 4
38746: PPUSH
38747: EMPTY
38748: PPUSH
38749: CALL_OW 1
38753: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38754: LD_ADDR_EXP 140
38758: PUSH
38759: LD_EXP 140
38763: PPUSH
38764: LD_VAR 0 4
38768: PPUSH
38769: EMPTY
38770: PPUSH
38771: CALL_OW 1
38775: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38776: LD_ADDR_EXP 141
38780: PUSH
38781: LD_EXP 141
38785: PPUSH
38786: LD_VAR 0 4
38790: PPUSH
38791: LD_INT 0
38793: PPUSH
38794: CALL_OW 1
38798: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38799: LD_ADDR_EXP 142
38803: PUSH
38804: LD_EXP 142
38808: PPUSH
38809: LD_VAR 0 4
38813: PPUSH
38814: LD_INT 0
38816: PPUSH
38817: CALL_OW 1
38821: ST_TO_ADDR
// result := base ;
38822: LD_ADDR_VAR 0 3
38826: PUSH
38827: LD_VAR 0 4
38831: ST_TO_ADDR
// end ;
38832: LD_VAR 0 3
38836: RET
// export function MC_Start ( ) ; var i ; begin
38837: LD_INT 0
38839: PPUSH
38840: PPUSH
// for i = 1 to mc_bases do
38841: LD_ADDR_VAR 0 2
38845: PUSH
38846: DOUBLE
38847: LD_INT 1
38849: DEC
38850: ST_TO_ADDR
38851: LD_EXP 99
38855: PUSH
38856: FOR_TO
38857: IFFALSE 39957
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
38859: LD_ADDR_EXP 99
38863: PUSH
38864: LD_EXP 99
38868: PPUSH
38869: LD_VAR 0 2
38873: PPUSH
38874: LD_EXP 99
38878: PUSH
38879: LD_VAR 0 2
38883: ARRAY
38884: PUSH
38885: LD_INT 0
38887: DIFF
38888: PPUSH
38889: CALL_OW 1
38893: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
38894: LD_ADDR_EXP 100
38898: PUSH
38899: LD_EXP 100
38903: PPUSH
38904: LD_VAR 0 2
38908: PPUSH
38909: EMPTY
38910: PPUSH
38911: CALL_OW 1
38915: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
38916: LD_ADDR_EXP 101
38920: PUSH
38921: LD_EXP 101
38925: PPUSH
38926: LD_VAR 0 2
38930: PPUSH
38931: EMPTY
38932: PPUSH
38933: CALL_OW 1
38937: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
38938: LD_ADDR_EXP 102
38942: PUSH
38943: LD_EXP 102
38947: PPUSH
38948: LD_VAR 0 2
38952: PPUSH
38953: EMPTY
38954: PPUSH
38955: CALL_OW 1
38959: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
38960: LD_ADDR_EXP 103
38964: PUSH
38965: LD_EXP 103
38969: PPUSH
38970: LD_VAR 0 2
38974: PPUSH
38975: EMPTY
38976: PUSH
38977: EMPTY
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PPUSH
38983: CALL_OW 1
38987: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
38988: LD_ADDR_EXP 104
38992: PUSH
38993: LD_EXP 104
38997: PPUSH
38998: LD_VAR 0 2
39002: PPUSH
39003: EMPTY
39004: PPUSH
39005: CALL_OW 1
39009: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39010: LD_ADDR_EXP 131
39014: PUSH
39015: LD_EXP 131
39019: PPUSH
39020: LD_VAR 0 2
39024: PPUSH
39025: EMPTY
39026: PPUSH
39027: CALL_OW 1
39031: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39032: LD_ADDR_EXP 105
39036: PUSH
39037: LD_EXP 105
39041: PPUSH
39042: LD_VAR 0 2
39046: PPUSH
39047: EMPTY
39048: PPUSH
39049: CALL_OW 1
39053: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39054: LD_ADDR_EXP 106
39058: PUSH
39059: LD_EXP 106
39063: PPUSH
39064: LD_VAR 0 2
39068: PPUSH
39069: EMPTY
39070: PPUSH
39071: CALL_OW 1
39075: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39076: LD_ADDR_EXP 107
39080: PUSH
39081: LD_EXP 107
39085: PPUSH
39086: LD_VAR 0 2
39090: PPUSH
39091: LD_EXP 99
39095: PUSH
39096: LD_VAR 0 2
39100: ARRAY
39101: PPUSH
39102: LD_INT 2
39104: PUSH
39105: LD_INT 30
39107: PUSH
39108: LD_INT 32
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 30
39117: PUSH
39118: LD_INT 33
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL_OW 72
39134: PPUSH
39135: CALL_OW 1
39139: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39140: LD_ADDR_EXP 108
39144: PUSH
39145: LD_EXP 108
39149: PPUSH
39150: LD_VAR 0 2
39154: PPUSH
39155: LD_EXP 99
39159: PUSH
39160: LD_VAR 0 2
39164: ARRAY
39165: PPUSH
39166: LD_INT 2
39168: PUSH
39169: LD_INT 30
39171: PUSH
39172: LD_INT 32
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 30
39181: PUSH
39182: LD_INT 31
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 58
39196: PUSH
39197: EMPTY
39198: LIST
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PPUSH
39204: CALL_OW 72
39208: PPUSH
39209: CALL_OW 1
39213: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39214: LD_ADDR_EXP 109
39218: PUSH
39219: LD_EXP 109
39223: PPUSH
39224: LD_VAR 0 2
39228: PPUSH
39229: EMPTY
39230: PPUSH
39231: CALL_OW 1
39235: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39236: LD_ADDR_EXP 113
39240: PUSH
39241: LD_EXP 113
39245: PPUSH
39246: LD_VAR 0 2
39250: PPUSH
39251: EMPTY
39252: PPUSH
39253: CALL_OW 1
39257: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39258: LD_ADDR_EXP 112
39262: PUSH
39263: LD_EXP 112
39267: PPUSH
39268: LD_VAR 0 2
39272: PPUSH
39273: EMPTY
39274: PPUSH
39275: CALL_OW 1
39279: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39280: LD_ADDR_EXP 114
39284: PUSH
39285: LD_EXP 114
39289: PPUSH
39290: LD_VAR 0 2
39294: PPUSH
39295: EMPTY
39296: PPUSH
39297: CALL_OW 1
39301: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39302: LD_ADDR_EXP 115
39306: PUSH
39307: LD_EXP 115
39311: PPUSH
39312: LD_VAR 0 2
39316: PPUSH
39317: EMPTY
39318: PPUSH
39319: CALL_OW 1
39323: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39324: LD_ADDR_EXP 116
39328: PUSH
39329: LD_EXP 116
39333: PPUSH
39334: LD_VAR 0 2
39338: PPUSH
39339: EMPTY
39340: PPUSH
39341: CALL_OW 1
39345: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39346: LD_ADDR_EXP 117
39350: PUSH
39351: LD_EXP 117
39355: PPUSH
39356: LD_VAR 0 2
39360: PPUSH
39361: EMPTY
39362: PPUSH
39363: CALL_OW 1
39367: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39368: LD_ADDR_EXP 118
39372: PUSH
39373: LD_EXP 118
39377: PPUSH
39378: LD_VAR 0 2
39382: PPUSH
39383: EMPTY
39384: PPUSH
39385: CALL_OW 1
39389: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39390: LD_ADDR_EXP 119
39394: PUSH
39395: LD_EXP 119
39399: PPUSH
39400: LD_VAR 0 2
39404: PPUSH
39405: EMPTY
39406: PPUSH
39407: CALL_OW 1
39411: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39412: LD_ADDR_EXP 120
39416: PUSH
39417: LD_EXP 120
39421: PPUSH
39422: LD_VAR 0 2
39426: PPUSH
39427: EMPTY
39428: PPUSH
39429: CALL_OW 1
39433: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39434: LD_ADDR_EXP 121
39438: PUSH
39439: LD_EXP 121
39443: PPUSH
39444: LD_VAR 0 2
39448: PPUSH
39449: EMPTY
39450: PPUSH
39451: CALL_OW 1
39455: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39456: LD_ADDR_EXP 110
39460: PUSH
39461: LD_EXP 110
39465: PPUSH
39466: LD_VAR 0 2
39470: PPUSH
39471: LD_INT 0
39473: PPUSH
39474: CALL_OW 1
39478: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39479: LD_ADDR_EXP 123
39483: PUSH
39484: LD_EXP 123
39488: PPUSH
39489: LD_VAR 0 2
39493: PPUSH
39494: LD_INT 0
39496: PPUSH
39497: CALL_OW 1
39501: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39502: LD_ADDR_EXP 111
39506: PUSH
39507: LD_EXP 111
39511: PPUSH
39512: LD_VAR 0 2
39516: PPUSH
39517: EMPTY
39518: PPUSH
39519: CALL_OW 1
39523: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39524: LD_ADDR_EXP 122
39528: PUSH
39529: LD_EXP 122
39533: PPUSH
39534: LD_VAR 0 2
39538: PPUSH
39539: LD_INT 0
39541: PPUSH
39542: CALL_OW 1
39546: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39547: LD_ADDR_EXP 124
39551: PUSH
39552: LD_EXP 124
39556: PPUSH
39557: LD_VAR 0 2
39561: PPUSH
39562: EMPTY
39563: PPUSH
39564: CALL_OW 1
39568: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39569: LD_ADDR_EXP 127
39573: PUSH
39574: LD_EXP 127
39578: PPUSH
39579: LD_VAR 0 2
39583: PPUSH
39584: LD_INT 0
39586: PPUSH
39587: CALL_OW 1
39591: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39592: LD_ADDR_EXP 128
39596: PUSH
39597: LD_EXP 128
39601: PPUSH
39602: LD_VAR 0 2
39606: PPUSH
39607: EMPTY
39608: PPUSH
39609: CALL_OW 1
39613: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39614: LD_ADDR_EXP 129
39618: PUSH
39619: LD_EXP 129
39623: PPUSH
39624: LD_VAR 0 2
39628: PPUSH
39629: EMPTY
39630: PPUSH
39631: CALL_OW 1
39635: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39636: LD_ADDR_EXP 130
39640: PUSH
39641: LD_EXP 130
39645: PPUSH
39646: LD_VAR 0 2
39650: PPUSH
39651: EMPTY
39652: PPUSH
39653: CALL_OW 1
39657: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39658: LD_ADDR_EXP 132
39662: PUSH
39663: LD_EXP 132
39667: PPUSH
39668: LD_VAR 0 2
39672: PPUSH
39673: LD_EXP 99
39677: PUSH
39678: LD_VAR 0 2
39682: ARRAY
39683: PPUSH
39684: LD_INT 2
39686: PUSH
39687: LD_INT 30
39689: PUSH
39690: LD_INT 6
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 30
39699: PUSH
39700: LD_INT 7
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 30
39709: PUSH
39710: LD_INT 8
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: PPUSH
39723: CALL_OW 72
39727: PPUSH
39728: CALL_OW 1
39732: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39733: LD_ADDR_EXP 133
39737: PUSH
39738: LD_EXP 133
39742: PPUSH
39743: LD_VAR 0 2
39747: PPUSH
39748: EMPTY
39749: PPUSH
39750: CALL_OW 1
39754: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39755: LD_ADDR_EXP 134
39759: PUSH
39760: LD_EXP 134
39764: PPUSH
39765: LD_VAR 0 2
39769: PPUSH
39770: EMPTY
39771: PPUSH
39772: CALL_OW 1
39776: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39777: LD_ADDR_EXP 135
39781: PUSH
39782: LD_EXP 135
39786: PPUSH
39787: LD_VAR 0 2
39791: PPUSH
39792: EMPTY
39793: PPUSH
39794: CALL_OW 1
39798: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39799: LD_ADDR_EXP 136
39803: PUSH
39804: LD_EXP 136
39808: PPUSH
39809: LD_VAR 0 2
39813: PPUSH
39814: EMPTY
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39821: LD_ADDR_EXP 137
39825: PUSH
39826: LD_EXP 137
39830: PPUSH
39831: LD_VAR 0 2
39835: PPUSH
39836: EMPTY
39837: PPUSH
39838: CALL_OW 1
39842: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
39843: LD_ADDR_EXP 138
39847: PUSH
39848: LD_EXP 138
39852: PPUSH
39853: LD_VAR 0 2
39857: PPUSH
39858: EMPTY
39859: PPUSH
39860: CALL_OW 1
39864: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
39865: LD_ADDR_EXP 139
39869: PUSH
39870: LD_EXP 139
39874: PPUSH
39875: LD_VAR 0 2
39879: PPUSH
39880: EMPTY
39881: PPUSH
39882: CALL_OW 1
39886: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
39887: LD_ADDR_EXP 140
39891: PUSH
39892: LD_EXP 140
39896: PPUSH
39897: LD_VAR 0 2
39901: PPUSH
39902: EMPTY
39903: PPUSH
39904: CALL_OW 1
39908: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
39909: LD_ADDR_EXP 141
39913: PUSH
39914: LD_EXP 141
39918: PPUSH
39919: LD_VAR 0 2
39923: PPUSH
39924: LD_INT 0
39926: PPUSH
39927: CALL_OW 1
39931: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39932: LD_ADDR_EXP 142
39936: PUSH
39937: LD_EXP 142
39941: PPUSH
39942: LD_VAR 0 2
39946: PPUSH
39947: LD_INT 0
39949: PPUSH
39950: CALL_OW 1
39954: ST_TO_ADDR
// end ;
39955: GO 38856
39957: POP
39958: POP
// MC_InitSides ( ) ;
39959: CALL 40245 0 0
// MC_InitResearch ( ) ;
39963: CALL 39984 0 0
// CustomInitMacro ( ) ;
39967: CALL 475 0 0
// skirmish := true ;
39971: LD_ADDR_EXP 97
39975: PUSH
39976: LD_INT 1
39978: ST_TO_ADDR
// end ;
39979: LD_VAR 0 1
39983: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
39984: LD_INT 0
39986: PPUSH
39987: PPUSH
39988: PPUSH
39989: PPUSH
39990: PPUSH
39991: PPUSH
// if not mc_bases then
39992: LD_EXP 99
39996: NOT
39997: IFFALSE 40001
// exit ;
39999: GO 40240
// for i = 1 to 8 do
40001: LD_ADDR_VAR 0 2
40005: PUSH
40006: DOUBLE
40007: LD_INT 1
40009: DEC
40010: ST_TO_ADDR
40011: LD_INT 8
40013: PUSH
40014: FOR_TO
40015: IFFALSE 40041
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40017: LD_ADDR_EXP 126
40021: PUSH
40022: LD_EXP 126
40026: PPUSH
40027: LD_VAR 0 2
40031: PPUSH
40032: EMPTY
40033: PPUSH
40034: CALL_OW 1
40038: ST_TO_ADDR
40039: GO 40014
40041: POP
40042: POP
// tmp := [ ] ;
40043: LD_ADDR_VAR 0 5
40047: PUSH
40048: EMPTY
40049: ST_TO_ADDR
// for i = 1 to mc_sides do
40050: LD_ADDR_VAR 0 2
40054: PUSH
40055: DOUBLE
40056: LD_INT 1
40058: DEC
40059: ST_TO_ADDR
40060: LD_EXP 125
40064: PUSH
40065: FOR_TO
40066: IFFALSE 40124
// if not mc_sides [ i ] in tmp then
40068: LD_EXP 125
40072: PUSH
40073: LD_VAR 0 2
40077: ARRAY
40078: PUSH
40079: LD_VAR 0 5
40083: IN
40084: NOT
40085: IFFALSE 40122
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40087: LD_ADDR_VAR 0 5
40091: PUSH
40092: LD_VAR 0 5
40096: PPUSH
40097: LD_VAR 0 5
40101: PUSH
40102: LD_INT 1
40104: PLUS
40105: PPUSH
40106: LD_EXP 125
40110: PUSH
40111: LD_VAR 0 2
40115: ARRAY
40116: PPUSH
40117: CALL_OW 2
40121: ST_TO_ADDR
40122: GO 40065
40124: POP
40125: POP
// if not tmp then
40126: LD_VAR 0 5
40130: NOT
40131: IFFALSE 40135
// exit ;
40133: GO 40240
// for j in tmp do
40135: LD_ADDR_VAR 0 3
40139: PUSH
40140: LD_VAR 0 5
40144: PUSH
40145: FOR_IN
40146: IFFALSE 40238
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40148: LD_ADDR_VAR 0 6
40152: PUSH
40153: LD_INT 22
40155: PUSH
40156: LD_VAR 0 3
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PPUSH
40165: CALL_OW 69
40169: ST_TO_ADDR
// if not un then
40170: LD_VAR 0 6
40174: NOT
40175: IFFALSE 40179
// continue ;
40177: GO 40145
// nation := GetNation ( un [ 1 ] ) ;
40179: LD_ADDR_VAR 0 4
40183: PUSH
40184: LD_VAR 0 6
40188: PUSH
40189: LD_INT 1
40191: ARRAY
40192: PPUSH
40193: CALL_OW 248
40197: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40198: LD_ADDR_EXP 126
40202: PUSH
40203: LD_EXP 126
40207: PPUSH
40208: LD_VAR 0 3
40212: PPUSH
40213: LD_VAR 0 3
40217: PPUSH
40218: LD_VAR 0 4
40222: PPUSH
40223: LD_INT 1
40225: PPUSH
40226: CALL 67392 0 3
40230: PPUSH
40231: CALL_OW 1
40235: ST_TO_ADDR
// end ;
40236: GO 40145
40238: POP
40239: POP
// end ;
40240: LD_VAR 0 1
40244: RET
// export function MC_InitSides ( ) ; var i ; begin
40245: LD_INT 0
40247: PPUSH
40248: PPUSH
// if not mc_bases then
40249: LD_EXP 99
40253: NOT
40254: IFFALSE 40258
// exit ;
40256: GO 40332
// for i = 1 to mc_bases do
40258: LD_ADDR_VAR 0 2
40262: PUSH
40263: DOUBLE
40264: LD_INT 1
40266: DEC
40267: ST_TO_ADDR
40268: LD_EXP 99
40272: PUSH
40273: FOR_TO
40274: IFFALSE 40330
// if mc_bases [ i ] then
40276: LD_EXP 99
40280: PUSH
40281: LD_VAR 0 2
40285: ARRAY
40286: IFFALSE 40328
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40288: LD_ADDR_EXP 125
40292: PUSH
40293: LD_EXP 125
40297: PPUSH
40298: LD_VAR 0 2
40302: PPUSH
40303: LD_EXP 99
40307: PUSH
40308: LD_VAR 0 2
40312: ARRAY
40313: PUSH
40314: LD_INT 1
40316: ARRAY
40317: PPUSH
40318: CALL_OW 255
40322: PPUSH
40323: CALL_OW 1
40327: ST_TO_ADDR
40328: GO 40273
40330: POP
40331: POP
// end ;
40332: LD_VAR 0 1
40336: RET
// every 0 0$03 trigger skirmish do
40337: LD_EXP 97
40341: IFFALSE 40495
40343: GO 40345
40345: DISABLE
// begin enable ;
40346: ENABLE
// MC_CheckBuildings ( ) ;
40347: CALL 44993 0 0
// MC_CheckPeopleLife ( ) ;
40351: CALL 45154 0 0
// RaiseSailEvent ( 100 ) ;
40355: LD_INT 100
40357: PPUSH
40358: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40362: LD_INT 103
40364: PPUSH
40365: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40369: LD_INT 104
40371: PPUSH
40372: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40376: LD_INT 105
40378: PPUSH
40379: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40383: LD_INT 106
40385: PPUSH
40386: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40390: LD_INT 107
40392: PPUSH
40393: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40397: LD_INT 108
40399: PPUSH
40400: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40404: LD_INT 109
40406: PPUSH
40407: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40411: LD_INT 110
40413: PPUSH
40414: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40418: LD_INT 111
40420: PPUSH
40421: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40425: LD_INT 112
40427: PPUSH
40428: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40432: LD_INT 113
40434: PPUSH
40435: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40439: LD_INT 120
40441: PPUSH
40442: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40446: LD_INT 121
40448: PPUSH
40449: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40453: LD_INT 122
40455: PPUSH
40456: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40460: LD_INT 123
40462: PPUSH
40463: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40467: LD_INT 124
40469: PPUSH
40470: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40474: LD_INT 125
40476: PPUSH
40477: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40481: LD_INT 126
40483: PPUSH
40484: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40488: LD_INT 200
40490: PPUSH
40491: CALL_OW 427
// end ;
40495: END
// on SailEvent ( event ) do begin if event < 100 then
40496: LD_VAR 0 1
40500: PUSH
40501: LD_INT 100
40503: LESS
40504: IFFALSE 40515
// CustomEvent ( event ) ;
40506: LD_VAR 0 1
40510: PPUSH
40511: CALL 34997 0 1
// if event = 100 then
40515: LD_VAR 0 1
40519: PUSH
40520: LD_INT 100
40522: EQUAL
40523: IFFALSE 40529
// MC_ClassManager ( ) ;
40525: CALL 40921 0 0
// if event = 101 then
40529: LD_VAR 0 1
40533: PUSH
40534: LD_INT 101
40536: EQUAL
40537: IFFALSE 40543
// MC_RepairBuildings ( ) ;
40539: CALL 45739 0 0
// if event = 102 then
40543: LD_VAR 0 1
40547: PUSH
40548: LD_INT 102
40550: EQUAL
40551: IFFALSE 40557
// MC_Heal ( ) ;
40553: CALL 46674 0 0
// if event = 103 then
40557: LD_VAR 0 1
40561: PUSH
40562: LD_INT 103
40564: EQUAL
40565: IFFALSE 40571
// MC_Build ( ) ;
40567: CALL 47096 0 0
// if event = 104 then
40571: LD_VAR 0 1
40575: PUSH
40576: LD_INT 104
40578: EQUAL
40579: IFFALSE 40585
// MC_TurretWeapon ( ) ;
40581: CALL 48730 0 0
// if event = 105 then
40585: LD_VAR 0 1
40589: PUSH
40590: LD_INT 105
40592: EQUAL
40593: IFFALSE 40599
// MC_BuildUpgrade ( ) ;
40595: CALL 48281 0 0
// if event = 106 then
40599: LD_VAR 0 1
40603: PUSH
40604: LD_INT 106
40606: EQUAL
40607: IFFALSE 40613
// MC_PlantMines ( ) ;
40609: CALL 49160 0 0
// if event = 107 then
40613: LD_VAR 0 1
40617: PUSH
40618: LD_INT 107
40620: EQUAL
40621: IFFALSE 40627
// MC_CollectCrates ( ) ;
40623: CALL 49951 0 0
// if event = 108 then
40627: LD_VAR 0 1
40631: PUSH
40632: LD_INT 108
40634: EQUAL
40635: IFFALSE 40641
// MC_LinkRemoteControl ( ) ;
40637: CALL 51801 0 0
// if event = 109 then
40641: LD_VAR 0 1
40645: PUSH
40646: LD_INT 109
40648: EQUAL
40649: IFFALSE 40655
// MC_ProduceVehicle ( ) ;
40651: CALL 51982 0 0
// if event = 110 then
40655: LD_VAR 0 1
40659: PUSH
40660: LD_INT 110
40662: EQUAL
40663: IFFALSE 40669
// MC_SendAttack ( ) ;
40665: CALL 52448 0 0
// if event = 111 then
40669: LD_VAR 0 1
40673: PUSH
40674: LD_INT 111
40676: EQUAL
40677: IFFALSE 40683
// MC_Defend ( ) ;
40679: CALL 52556 0 0
// if event = 112 then
40683: LD_VAR 0 1
40687: PUSH
40688: LD_INT 112
40690: EQUAL
40691: IFFALSE 40697
// MC_Research ( ) ;
40693: CALL 53436 0 0
// if event = 113 then
40697: LD_VAR 0 1
40701: PUSH
40702: LD_INT 113
40704: EQUAL
40705: IFFALSE 40711
// MC_MinesTrigger ( ) ;
40707: CALL 54550 0 0
// if event = 120 then
40711: LD_VAR 0 1
40715: PUSH
40716: LD_INT 120
40718: EQUAL
40719: IFFALSE 40725
// MC_RepairVehicle ( ) ;
40721: CALL 54649 0 0
// if event = 121 then
40725: LD_VAR 0 1
40729: PUSH
40730: LD_INT 121
40732: EQUAL
40733: IFFALSE 40739
// MC_TameApe ( ) ;
40735: CALL 55418 0 0
// if event = 122 then
40739: LD_VAR 0 1
40743: PUSH
40744: LD_INT 122
40746: EQUAL
40747: IFFALSE 40753
// MC_ChangeApeClass ( ) ;
40749: CALL 56247 0 0
// if event = 123 then
40753: LD_VAR 0 1
40757: PUSH
40758: LD_INT 123
40760: EQUAL
40761: IFFALSE 40767
// MC_Bazooka ( ) ;
40763: CALL 56897 0 0
// if event = 124 then
40767: LD_VAR 0 1
40771: PUSH
40772: LD_INT 124
40774: EQUAL
40775: IFFALSE 40781
// MC_TeleportExit ( ) ;
40777: CALL 57095 0 0
// if event = 125 then
40781: LD_VAR 0 1
40785: PUSH
40786: LD_INT 125
40788: EQUAL
40789: IFFALSE 40795
// MC_Deposits ( ) ;
40791: CALL 57742 0 0
// if event = 126 then
40795: LD_VAR 0 1
40799: PUSH
40800: LD_INT 126
40802: EQUAL
40803: IFFALSE 40809
// MC_RemoteDriver ( ) ;
40805: CALL 58367 0 0
// if event = 200 then
40809: LD_VAR 0 1
40813: PUSH
40814: LD_INT 200
40816: EQUAL
40817: IFFALSE 40823
// MC_Idle ( ) ;
40819: CALL 60316 0 0
// end ;
40823: PPOPN 1
40825: END
// export function MC_Reset ( base , tag ) ; var i ; begin
40826: LD_INT 0
40828: PPUSH
40829: PPUSH
// if not mc_bases [ base ] or not tag then
40830: LD_EXP 99
40834: PUSH
40835: LD_VAR 0 1
40839: ARRAY
40840: NOT
40841: PUSH
40842: LD_VAR 0 2
40846: NOT
40847: OR
40848: IFFALSE 40852
// exit ;
40850: GO 40916
// for i in mc_bases [ base ] union mc_ape [ base ] do
40852: LD_ADDR_VAR 0 4
40856: PUSH
40857: LD_EXP 99
40861: PUSH
40862: LD_VAR 0 1
40866: ARRAY
40867: PUSH
40868: LD_EXP 128
40872: PUSH
40873: LD_VAR 0 1
40877: ARRAY
40878: UNION
40879: PUSH
40880: FOR_IN
40881: IFFALSE 40914
// if GetTag ( i ) = tag then
40883: LD_VAR 0 4
40887: PPUSH
40888: CALL_OW 110
40892: PUSH
40893: LD_VAR 0 2
40897: EQUAL
40898: IFFALSE 40912
// SetTag ( i , 0 ) ;
40900: LD_VAR 0 4
40904: PPUSH
40905: LD_INT 0
40907: PPUSH
40908: CALL_OW 109
40912: GO 40880
40914: POP
40915: POP
// end ;
40916: LD_VAR 0 3
40920: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
40921: LD_INT 0
40923: PPUSH
40924: PPUSH
40925: PPUSH
40926: PPUSH
40927: PPUSH
40928: PPUSH
40929: PPUSH
40930: PPUSH
// if not mc_bases then
40931: LD_EXP 99
40935: NOT
40936: IFFALSE 40940
// exit ;
40938: GO 41398
// for i = 1 to mc_bases do
40940: LD_ADDR_VAR 0 2
40944: PUSH
40945: DOUBLE
40946: LD_INT 1
40948: DEC
40949: ST_TO_ADDR
40950: LD_EXP 99
40954: PUSH
40955: FOR_TO
40956: IFFALSE 41396
// begin tmp := MC_ClassCheckReq ( i ) ;
40958: LD_ADDR_VAR 0 4
40962: PUSH
40963: LD_VAR 0 2
40967: PPUSH
40968: CALL 41403 0 1
40972: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
40973: LD_ADDR_EXP 140
40977: PUSH
40978: LD_EXP 140
40982: PPUSH
40983: LD_VAR 0 2
40987: PPUSH
40988: LD_VAR 0 4
40992: PPUSH
40993: CALL_OW 1
40997: ST_TO_ADDR
// if not tmp then
40998: LD_VAR 0 4
41002: NOT
41003: IFFALSE 41007
// continue ;
41005: GO 40955
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41007: LD_ADDR_VAR 0 6
41011: PUSH
41012: LD_EXP 99
41016: PUSH
41017: LD_VAR 0 2
41021: ARRAY
41022: PPUSH
41023: LD_INT 2
41025: PUSH
41026: LD_INT 30
41028: PUSH
41029: LD_INT 4
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 30
41038: PUSH
41039: LD_INT 5
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: LIST
41050: PPUSH
41051: CALL_OW 72
41055: PUSH
41056: LD_EXP 99
41060: PUSH
41061: LD_VAR 0 2
41065: ARRAY
41066: PPUSH
41067: LD_INT 2
41069: PUSH
41070: LD_INT 30
41072: PUSH
41073: LD_INT 0
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 30
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: LIST
41094: PPUSH
41095: CALL_OW 72
41099: PUSH
41100: LD_EXP 99
41104: PUSH
41105: LD_VAR 0 2
41109: ARRAY
41110: PPUSH
41111: LD_INT 30
41113: PUSH
41114: LD_INT 3
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PPUSH
41121: CALL_OW 72
41125: PUSH
41126: LD_EXP 99
41130: PUSH
41131: LD_VAR 0 2
41135: ARRAY
41136: PPUSH
41137: LD_INT 2
41139: PUSH
41140: LD_INT 30
41142: PUSH
41143: LD_INT 6
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 30
41152: PUSH
41153: LD_INT 7
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 30
41162: PUSH
41163: LD_INT 8
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: LIST
41174: LIST
41175: PPUSH
41176: CALL_OW 72
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: LIST
41185: LIST
41186: ST_TO_ADDR
// for j = 1 to 4 do
41187: LD_ADDR_VAR 0 3
41191: PUSH
41192: DOUBLE
41193: LD_INT 1
41195: DEC
41196: ST_TO_ADDR
41197: LD_INT 4
41199: PUSH
41200: FOR_TO
41201: IFFALSE 41392
// begin if not tmp [ j ] then
41203: LD_VAR 0 4
41207: PUSH
41208: LD_VAR 0 3
41212: ARRAY
41213: NOT
41214: IFFALSE 41218
// continue ;
41216: GO 41200
// for p in tmp [ j ] do
41218: LD_ADDR_VAR 0 5
41222: PUSH
41223: LD_VAR 0 4
41227: PUSH
41228: LD_VAR 0 3
41232: ARRAY
41233: PUSH
41234: FOR_IN
41235: IFFALSE 41388
// begin if not b [ j ] then
41237: LD_VAR 0 6
41241: PUSH
41242: LD_VAR 0 3
41246: ARRAY
41247: NOT
41248: IFFALSE 41252
// break ;
41250: GO 41388
// e := 0 ;
41252: LD_ADDR_VAR 0 7
41256: PUSH
41257: LD_INT 0
41259: ST_TO_ADDR
// for k in b [ j ] do
41260: LD_ADDR_VAR 0 8
41264: PUSH
41265: LD_VAR 0 6
41269: PUSH
41270: LD_VAR 0 3
41274: ARRAY
41275: PUSH
41276: FOR_IN
41277: IFFALSE 41304
// if IsNotFull ( k ) then
41279: LD_VAR 0 8
41283: PPUSH
41284: CALL 69545 0 1
41288: IFFALSE 41302
// begin e := k ;
41290: LD_ADDR_VAR 0 7
41294: PUSH
41295: LD_VAR 0 8
41299: ST_TO_ADDR
// break ;
41300: GO 41304
// end ;
41302: GO 41276
41304: POP
41305: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41306: LD_VAR 0 7
41310: PUSH
41311: LD_VAR 0 5
41315: PPUSH
41316: LD_VAR 0 7
41320: PPUSH
41321: CALL 103424 0 2
41325: NOT
41326: AND
41327: IFFALSE 41386
// begin if IsInUnit ( p ) then
41329: LD_VAR 0 5
41333: PPUSH
41334: CALL_OW 310
41338: IFFALSE 41349
// ComExitBuilding ( p ) ;
41340: LD_VAR 0 5
41344: PPUSH
41345: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41349: LD_VAR 0 5
41353: PPUSH
41354: LD_VAR 0 7
41358: PPUSH
41359: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41363: LD_VAR 0 5
41367: PPUSH
41368: LD_VAR 0 3
41372: PPUSH
41373: CALL_OW 183
// AddComExitBuilding ( p ) ;
41377: LD_VAR 0 5
41381: PPUSH
41382: CALL_OW 182
// end ; end ;
41386: GO 41234
41388: POP
41389: POP
// end ;
41390: GO 41200
41392: POP
41393: POP
// end ;
41394: GO 40955
41396: POP
41397: POP
// end ;
41398: LD_VAR 0 1
41402: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41403: LD_INT 0
41405: PPUSH
41406: PPUSH
41407: PPUSH
41408: PPUSH
41409: PPUSH
41410: PPUSH
41411: PPUSH
41412: PPUSH
41413: PPUSH
41414: PPUSH
41415: PPUSH
41416: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41417: LD_VAR 0 1
41421: NOT
41422: PUSH
41423: LD_EXP 99
41427: PUSH
41428: LD_VAR 0 1
41432: ARRAY
41433: NOT
41434: OR
41435: PUSH
41436: LD_EXP 99
41440: PUSH
41441: LD_VAR 0 1
41445: ARRAY
41446: PPUSH
41447: LD_INT 2
41449: PUSH
41450: LD_INT 30
41452: PUSH
41453: LD_INT 0
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 30
41462: PUSH
41463: LD_INT 1
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: LIST
41474: PPUSH
41475: CALL_OW 72
41479: NOT
41480: OR
41481: IFFALSE 41485
// exit ;
41483: GO 44988
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41485: LD_ADDR_VAR 0 4
41489: PUSH
41490: LD_EXP 99
41494: PUSH
41495: LD_VAR 0 1
41499: ARRAY
41500: PPUSH
41501: LD_INT 2
41503: PUSH
41504: LD_INT 25
41506: PUSH
41507: LD_INT 1
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 25
41516: PUSH
41517: LD_INT 2
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 25
41526: PUSH
41527: LD_INT 3
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 25
41536: PUSH
41537: LD_INT 4
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 25
41546: PUSH
41547: LD_INT 5
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 25
41556: PUSH
41557: LD_INT 8
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 25
41566: PUSH
41567: LD_INT 9
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: PPUSH
41584: CALL_OW 72
41588: ST_TO_ADDR
// if not tmp then
41589: LD_VAR 0 4
41593: NOT
41594: IFFALSE 41598
// exit ;
41596: GO 44988
// for i in tmp do
41598: LD_ADDR_VAR 0 3
41602: PUSH
41603: LD_VAR 0 4
41607: PUSH
41608: FOR_IN
41609: IFFALSE 41640
// if GetTag ( i ) then
41611: LD_VAR 0 3
41615: PPUSH
41616: CALL_OW 110
41620: IFFALSE 41638
// tmp := tmp diff i ;
41622: LD_ADDR_VAR 0 4
41626: PUSH
41627: LD_VAR 0 4
41631: PUSH
41632: LD_VAR 0 3
41636: DIFF
41637: ST_TO_ADDR
41638: GO 41608
41640: POP
41641: POP
// if not tmp then
41642: LD_VAR 0 4
41646: NOT
41647: IFFALSE 41651
// exit ;
41649: GO 44988
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41651: LD_ADDR_VAR 0 5
41655: PUSH
41656: LD_EXP 99
41660: PUSH
41661: LD_VAR 0 1
41665: ARRAY
41666: PPUSH
41667: LD_INT 2
41669: PUSH
41670: LD_INT 25
41672: PUSH
41673: LD_INT 1
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 25
41682: PUSH
41683: LD_INT 5
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 25
41692: PUSH
41693: LD_INT 8
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 25
41702: PUSH
41703: LD_INT 9
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: PPUSH
41717: CALL_OW 72
41721: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41722: LD_ADDR_VAR 0 6
41726: PUSH
41727: LD_EXP 99
41731: PUSH
41732: LD_VAR 0 1
41736: ARRAY
41737: PPUSH
41738: LD_INT 25
41740: PUSH
41741: LD_INT 2
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PPUSH
41748: CALL_OW 72
41752: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41753: LD_ADDR_VAR 0 7
41757: PUSH
41758: LD_EXP 99
41762: PUSH
41763: LD_VAR 0 1
41767: ARRAY
41768: PPUSH
41769: LD_INT 25
41771: PUSH
41772: LD_INT 3
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PPUSH
41779: CALL_OW 72
41783: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41784: LD_ADDR_VAR 0 8
41788: PUSH
41789: LD_EXP 99
41793: PUSH
41794: LD_VAR 0 1
41798: ARRAY
41799: PPUSH
41800: LD_INT 25
41802: PUSH
41803: LD_INT 4
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 24
41812: PUSH
41813: LD_INT 251
41815: PUSH
41816: EMPTY
41817: LIST
41818: LIST
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PPUSH
41824: CALL_OW 72
41828: ST_TO_ADDR
// if mc_is_defending [ base ] then
41829: LD_EXP 142
41833: PUSH
41834: LD_VAR 0 1
41838: ARRAY
41839: IFFALSE 42300
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
41841: LD_ADDR_EXP 141
41845: PUSH
41846: LD_EXP 141
41850: PPUSH
41851: LD_VAR 0 1
41855: PPUSH
41856: LD_INT 4
41858: PPUSH
41859: CALL_OW 1
41863: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41864: LD_ADDR_VAR 0 12
41868: PUSH
41869: LD_EXP 99
41873: PUSH
41874: LD_VAR 0 1
41878: ARRAY
41879: PPUSH
41880: LD_INT 2
41882: PUSH
41883: LD_INT 30
41885: PUSH
41886: LD_INT 4
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 30
41895: PUSH
41896: LD_INT 5
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: LIST
41907: PPUSH
41908: CALL_OW 72
41912: ST_TO_ADDR
// if not b then
41913: LD_VAR 0 12
41917: NOT
41918: IFFALSE 41922
// exit ;
41920: GO 44988
// p := [ ] ;
41922: LD_ADDR_VAR 0 11
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// if sci >= 2 then
41929: LD_VAR 0 8
41933: PUSH
41934: LD_INT 2
41936: GREATEREQUAL
41937: IFFALSE 41968
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
41939: LD_ADDR_VAR 0 8
41943: PUSH
41944: LD_VAR 0 8
41948: PUSH
41949: LD_INT 1
41951: ARRAY
41952: PUSH
41953: LD_VAR 0 8
41957: PUSH
41958: LD_INT 2
41960: ARRAY
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: ST_TO_ADDR
41966: GO 42029
// if sci = 1 then
41968: LD_VAR 0 8
41972: PUSH
41973: LD_INT 1
41975: EQUAL
41976: IFFALSE 41997
// sci := [ sci [ 1 ] ] else
41978: LD_ADDR_VAR 0 8
41982: PUSH
41983: LD_VAR 0 8
41987: PUSH
41988: LD_INT 1
41990: ARRAY
41991: PUSH
41992: EMPTY
41993: LIST
41994: ST_TO_ADDR
41995: GO 42029
// if sci = 0 then
41997: LD_VAR 0 8
42001: PUSH
42002: LD_INT 0
42004: EQUAL
42005: IFFALSE 42029
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42007: LD_ADDR_VAR 0 11
42011: PUSH
42012: LD_VAR 0 4
42016: PPUSH
42017: LD_INT 4
42019: PPUSH
42020: CALL 103287 0 2
42024: PUSH
42025: LD_INT 1
42027: ARRAY
42028: ST_TO_ADDR
// if eng > 4 then
42029: LD_VAR 0 6
42033: PUSH
42034: LD_INT 4
42036: GREATER
42037: IFFALSE 42083
// for i = eng downto 4 do
42039: LD_ADDR_VAR 0 3
42043: PUSH
42044: DOUBLE
42045: LD_VAR 0 6
42049: INC
42050: ST_TO_ADDR
42051: LD_INT 4
42053: PUSH
42054: FOR_DOWNTO
42055: IFFALSE 42081
// eng := eng diff eng [ i ] ;
42057: LD_ADDR_VAR 0 6
42061: PUSH
42062: LD_VAR 0 6
42066: PUSH
42067: LD_VAR 0 6
42071: PUSH
42072: LD_VAR 0 3
42076: ARRAY
42077: DIFF
42078: ST_TO_ADDR
42079: GO 42054
42081: POP
42082: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42083: LD_ADDR_VAR 0 4
42087: PUSH
42088: LD_VAR 0 4
42092: PUSH
42093: LD_VAR 0 5
42097: PUSH
42098: LD_VAR 0 6
42102: UNION
42103: PUSH
42104: LD_VAR 0 7
42108: UNION
42109: PUSH
42110: LD_VAR 0 8
42114: UNION
42115: DIFF
42116: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42117: LD_ADDR_VAR 0 13
42121: PUSH
42122: LD_EXP 99
42126: PUSH
42127: LD_VAR 0 1
42131: ARRAY
42132: PPUSH
42133: LD_INT 2
42135: PUSH
42136: LD_INT 30
42138: PUSH
42139: LD_INT 32
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 30
42148: PUSH
42149: LD_INT 31
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: LIST
42160: PPUSH
42161: CALL_OW 72
42165: PUSH
42166: LD_EXP 99
42170: PUSH
42171: LD_VAR 0 1
42175: ARRAY
42176: PPUSH
42177: LD_INT 2
42179: PUSH
42180: LD_INT 30
42182: PUSH
42183: LD_INT 4
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 30
42192: PUSH
42193: LD_INT 5
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: LIST
42204: PPUSH
42205: CALL_OW 72
42209: PUSH
42210: LD_INT 6
42212: MUL
42213: PLUS
42214: ST_TO_ADDR
// if bcount < tmp then
42215: LD_VAR 0 13
42219: PUSH
42220: LD_VAR 0 4
42224: LESS
42225: IFFALSE 42271
// for i = tmp downto bcount do
42227: LD_ADDR_VAR 0 3
42231: PUSH
42232: DOUBLE
42233: LD_VAR 0 4
42237: INC
42238: ST_TO_ADDR
42239: LD_VAR 0 13
42243: PUSH
42244: FOR_DOWNTO
42245: IFFALSE 42269
// tmp := Delete ( tmp , tmp ) ;
42247: LD_ADDR_VAR 0 4
42251: PUSH
42252: LD_VAR 0 4
42256: PPUSH
42257: LD_VAR 0 4
42261: PPUSH
42262: CALL_OW 3
42266: ST_TO_ADDR
42267: GO 42244
42269: POP
42270: POP
// result := [ tmp , 0 , 0 , p ] ;
42271: LD_ADDR_VAR 0 2
42275: PUSH
42276: LD_VAR 0 4
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: LD_INT 0
42286: PUSH
42287: LD_VAR 0 11
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: ST_TO_ADDR
// exit ;
42298: GO 44988
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42300: LD_EXP 99
42304: PUSH
42305: LD_VAR 0 1
42309: ARRAY
42310: PPUSH
42311: LD_INT 2
42313: PUSH
42314: LD_INT 30
42316: PUSH
42317: LD_INT 6
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 30
42326: PUSH
42327: LD_INT 7
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 30
42336: PUSH
42337: LD_INT 8
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: PPUSH
42350: CALL_OW 72
42354: NOT
42355: PUSH
42356: LD_EXP 99
42360: PUSH
42361: LD_VAR 0 1
42365: ARRAY
42366: PPUSH
42367: LD_INT 30
42369: PUSH
42370: LD_INT 3
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PPUSH
42377: CALL_OW 72
42381: NOT
42382: AND
42383: IFFALSE 42455
// begin if eng = tmp then
42385: LD_VAR 0 6
42389: PUSH
42390: LD_VAR 0 4
42394: EQUAL
42395: IFFALSE 42399
// exit ;
42397: GO 44988
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42399: LD_ADDR_EXP 141
42403: PUSH
42404: LD_EXP 141
42408: PPUSH
42409: LD_VAR 0 1
42413: PPUSH
42414: LD_INT 1
42416: PPUSH
42417: CALL_OW 1
42421: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42422: LD_ADDR_VAR 0 2
42426: PUSH
42427: LD_INT 0
42429: PUSH
42430: LD_VAR 0 4
42434: PUSH
42435: LD_VAR 0 6
42439: DIFF
42440: PUSH
42441: LD_INT 0
42443: PUSH
42444: LD_INT 0
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// exit ;
42453: GO 44988
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42455: LD_EXP 126
42459: PUSH
42460: LD_EXP 125
42464: PUSH
42465: LD_VAR 0 1
42469: ARRAY
42470: ARRAY
42471: PUSH
42472: LD_EXP 99
42476: PUSH
42477: LD_VAR 0 1
42481: ARRAY
42482: PPUSH
42483: LD_INT 2
42485: PUSH
42486: LD_INT 30
42488: PUSH
42489: LD_INT 6
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 30
42498: PUSH
42499: LD_INT 7
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 30
42508: PUSH
42509: LD_INT 8
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: LIST
42520: LIST
42521: PPUSH
42522: CALL_OW 72
42526: AND
42527: PUSH
42528: LD_EXP 99
42532: PUSH
42533: LD_VAR 0 1
42537: ARRAY
42538: PPUSH
42539: LD_INT 30
42541: PUSH
42542: LD_INT 3
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PPUSH
42549: CALL_OW 72
42553: NOT
42554: AND
42555: IFFALSE 42769
// begin if sci >= 6 then
42557: LD_VAR 0 8
42561: PUSH
42562: LD_INT 6
42564: GREATEREQUAL
42565: IFFALSE 42569
// exit ;
42567: GO 44988
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42569: LD_ADDR_EXP 141
42573: PUSH
42574: LD_EXP 141
42578: PPUSH
42579: LD_VAR 0 1
42583: PPUSH
42584: LD_INT 2
42586: PPUSH
42587: CALL_OW 1
42591: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42592: LD_ADDR_VAR 0 9
42596: PUSH
42597: LD_VAR 0 4
42601: PUSH
42602: LD_VAR 0 8
42606: DIFF
42607: PPUSH
42608: LD_INT 4
42610: PPUSH
42611: CALL 103287 0 2
42615: ST_TO_ADDR
// p := [ ] ;
42616: LD_ADDR_VAR 0 11
42620: PUSH
42621: EMPTY
42622: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42623: LD_VAR 0 8
42627: PUSH
42628: LD_INT 6
42630: LESS
42631: PUSH
42632: LD_VAR 0 9
42636: PUSH
42637: LD_INT 6
42639: GREATER
42640: AND
42641: IFFALSE 42722
// begin for i = 1 to 6 - sci do
42643: LD_ADDR_VAR 0 3
42647: PUSH
42648: DOUBLE
42649: LD_INT 1
42651: DEC
42652: ST_TO_ADDR
42653: LD_INT 6
42655: PUSH
42656: LD_VAR 0 8
42660: MINUS
42661: PUSH
42662: FOR_TO
42663: IFFALSE 42718
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42665: LD_ADDR_VAR 0 11
42669: PUSH
42670: LD_VAR 0 11
42674: PPUSH
42675: LD_VAR 0 11
42679: PUSH
42680: LD_INT 1
42682: PLUS
42683: PPUSH
42684: LD_VAR 0 9
42688: PUSH
42689: LD_INT 1
42691: ARRAY
42692: PPUSH
42693: CALL_OW 2
42697: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42698: LD_ADDR_VAR 0 9
42702: PUSH
42703: LD_VAR 0 9
42707: PPUSH
42708: LD_INT 1
42710: PPUSH
42711: CALL_OW 3
42715: ST_TO_ADDR
// end ;
42716: GO 42662
42718: POP
42719: POP
// end else
42720: GO 42742
// if sort then
42722: LD_VAR 0 9
42726: IFFALSE 42742
// p := sort [ 1 ] ;
42728: LD_ADDR_VAR 0 11
42732: PUSH
42733: LD_VAR 0 9
42737: PUSH
42738: LD_INT 1
42740: ARRAY
42741: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42742: LD_ADDR_VAR 0 2
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: LD_INT 0
42752: PUSH
42753: LD_INT 0
42755: PUSH
42756: LD_VAR 0 11
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: ST_TO_ADDR
// exit ;
42767: GO 44988
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42769: LD_EXP 126
42773: PUSH
42774: LD_EXP 125
42778: PUSH
42779: LD_VAR 0 1
42783: ARRAY
42784: ARRAY
42785: PUSH
42786: LD_EXP 99
42790: PUSH
42791: LD_VAR 0 1
42795: ARRAY
42796: PPUSH
42797: LD_INT 2
42799: PUSH
42800: LD_INT 30
42802: PUSH
42803: LD_INT 6
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 30
42812: PUSH
42813: LD_INT 7
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 30
42822: PUSH
42823: LD_INT 8
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: PPUSH
42836: CALL_OW 72
42840: AND
42841: PUSH
42842: LD_EXP 99
42846: PUSH
42847: LD_VAR 0 1
42851: ARRAY
42852: PPUSH
42853: LD_INT 30
42855: PUSH
42856: LD_INT 3
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PPUSH
42863: CALL_OW 72
42867: AND
42868: IFFALSE 43602
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
42870: LD_ADDR_EXP 141
42874: PUSH
42875: LD_EXP 141
42879: PPUSH
42880: LD_VAR 0 1
42884: PPUSH
42885: LD_INT 3
42887: PPUSH
42888: CALL_OW 1
42892: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42893: LD_ADDR_VAR 0 2
42897: PUSH
42898: LD_INT 0
42900: PUSH
42901: LD_INT 0
42903: PUSH
42904: LD_INT 0
42906: PUSH
42907: LD_INT 0
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: ST_TO_ADDR
// if not eng then
42916: LD_VAR 0 6
42920: NOT
42921: IFFALSE 42984
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
42923: LD_ADDR_VAR 0 11
42927: PUSH
42928: LD_VAR 0 4
42932: PPUSH
42933: LD_INT 2
42935: PPUSH
42936: CALL 103287 0 2
42940: PUSH
42941: LD_INT 1
42943: ARRAY
42944: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
42945: LD_ADDR_VAR 0 2
42949: PUSH
42950: LD_VAR 0 2
42954: PPUSH
42955: LD_INT 2
42957: PPUSH
42958: LD_VAR 0 11
42962: PPUSH
42963: CALL_OW 1
42967: ST_TO_ADDR
// tmp := tmp diff p ;
42968: LD_ADDR_VAR 0 4
42972: PUSH
42973: LD_VAR 0 4
42977: PUSH
42978: LD_VAR 0 11
42982: DIFF
42983: ST_TO_ADDR
// end ; if tmp and sci < 6 then
42984: LD_VAR 0 4
42988: PUSH
42989: LD_VAR 0 8
42993: PUSH
42994: LD_INT 6
42996: LESS
42997: AND
42998: IFFALSE 43186
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43000: LD_ADDR_VAR 0 9
43004: PUSH
43005: LD_VAR 0 4
43009: PUSH
43010: LD_VAR 0 8
43014: PUSH
43015: LD_VAR 0 7
43019: UNION
43020: DIFF
43021: PPUSH
43022: LD_INT 4
43024: PPUSH
43025: CALL 103287 0 2
43029: ST_TO_ADDR
// p := [ ] ;
43030: LD_ADDR_VAR 0 11
43034: PUSH
43035: EMPTY
43036: ST_TO_ADDR
// if sort then
43037: LD_VAR 0 9
43041: IFFALSE 43157
// for i = 1 to 6 - sci do
43043: LD_ADDR_VAR 0 3
43047: PUSH
43048: DOUBLE
43049: LD_INT 1
43051: DEC
43052: ST_TO_ADDR
43053: LD_INT 6
43055: PUSH
43056: LD_VAR 0 8
43060: MINUS
43061: PUSH
43062: FOR_TO
43063: IFFALSE 43155
// begin if i = sort then
43065: LD_VAR 0 3
43069: PUSH
43070: LD_VAR 0 9
43074: EQUAL
43075: IFFALSE 43079
// break ;
43077: GO 43155
// if GetClass ( i ) = 4 then
43079: LD_VAR 0 3
43083: PPUSH
43084: CALL_OW 257
43088: PUSH
43089: LD_INT 4
43091: EQUAL
43092: IFFALSE 43096
// continue ;
43094: GO 43062
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43096: LD_ADDR_VAR 0 11
43100: PUSH
43101: LD_VAR 0 11
43105: PPUSH
43106: LD_VAR 0 11
43110: PUSH
43111: LD_INT 1
43113: PLUS
43114: PPUSH
43115: LD_VAR 0 9
43119: PUSH
43120: LD_VAR 0 3
43124: ARRAY
43125: PPUSH
43126: CALL_OW 2
43130: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43131: LD_ADDR_VAR 0 4
43135: PUSH
43136: LD_VAR 0 4
43140: PUSH
43141: LD_VAR 0 9
43145: PUSH
43146: LD_VAR 0 3
43150: ARRAY
43151: DIFF
43152: ST_TO_ADDR
// end ;
43153: GO 43062
43155: POP
43156: POP
// if p then
43157: LD_VAR 0 11
43161: IFFALSE 43186
// result := Replace ( result , 4 , p ) ;
43163: LD_ADDR_VAR 0 2
43167: PUSH
43168: LD_VAR 0 2
43172: PPUSH
43173: LD_INT 4
43175: PPUSH
43176: LD_VAR 0 11
43180: PPUSH
43181: CALL_OW 1
43185: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43186: LD_VAR 0 4
43190: PUSH
43191: LD_VAR 0 7
43195: PUSH
43196: LD_INT 6
43198: LESS
43199: AND
43200: IFFALSE 43388
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43202: LD_ADDR_VAR 0 9
43206: PUSH
43207: LD_VAR 0 4
43211: PUSH
43212: LD_VAR 0 8
43216: PUSH
43217: LD_VAR 0 7
43221: UNION
43222: DIFF
43223: PPUSH
43224: LD_INT 3
43226: PPUSH
43227: CALL 103287 0 2
43231: ST_TO_ADDR
// p := [ ] ;
43232: LD_ADDR_VAR 0 11
43236: PUSH
43237: EMPTY
43238: ST_TO_ADDR
// if sort then
43239: LD_VAR 0 9
43243: IFFALSE 43359
// for i = 1 to 6 - mech do
43245: LD_ADDR_VAR 0 3
43249: PUSH
43250: DOUBLE
43251: LD_INT 1
43253: DEC
43254: ST_TO_ADDR
43255: LD_INT 6
43257: PUSH
43258: LD_VAR 0 7
43262: MINUS
43263: PUSH
43264: FOR_TO
43265: IFFALSE 43357
// begin if i = sort then
43267: LD_VAR 0 3
43271: PUSH
43272: LD_VAR 0 9
43276: EQUAL
43277: IFFALSE 43281
// break ;
43279: GO 43357
// if GetClass ( i ) = 3 then
43281: LD_VAR 0 3
43285: PPUSH
43286: CALL_OW 257
43290: PUSH
43291: LD_INT 3
43293: EQUAL
43294: IFFALSE 43298
// continue ;
43296: GO 43264
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43298: LD_ADDR_VAR 0 11
43302: PUSH
43303: LD_VAR 0 11
43307: PPUSH
43308: LD_VAR 0 11
43312: PUSH
43313: LD_INT 1
43315: PLUS
43316: PPUSH
43317: LD_VAR 0 9
43321: PUSH
43322: LD_VAR 0 3
43326: ARRAY
43327: PPUSH
43328: CALL_OW 2
43332: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43333: LD_ADDR_VAR 0 4
43337: PUSH
43338: LD_VAR 0 4
43342: PUSH
43343: LD_VAR 0 9
43347: PUSH
43348: LD_VAR 0 3
43352: ARRAY
43353: DIFF
43354: ST_TO_ADDR
// end ;
43355: GO 43264
43357: POP
43358: POP
// if p then
43359: LD_VAR 0 11
43363: IFFALSE 43388
// result := Replace ( result , 3 , p ) ;
43365: LD_ADDR_VAR 0 2
43369: PUSH
43370: LD_VAR 0 2
43374: PPUSH
43375: LD_INT 3
43377: PPUSH
43378: LD_VAR 0 11
43382: PPUSH
43383: CALL_OW 1
43387: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43388: LD_VAR 0 4
43392: PUSH
43393: LD_INT 6
43395: GREATER
43396: PUSH
43397: LD_VAR 0 6
43401: PUSH
43402: LD_INT 6
43404: LESS
43405: AND
43406: IFFALSE 43600
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43408: LD_ADDR_VAR 0 9
43412: PUSH
43413: LD_VAR 0 4
43417: PUSH
43418: LD_VAR 0 8
43422: PUSH
43423: LD_VAR 0 7
43427: UNION
43428: PUSH
43429: LD_VAR 0 6
43433: UNION
43434: DIFF
43435: PPUSH
43436: LD_INT 2
43438: PPUSH
43439: CALL 103287 0 2
43443: ST_TO_ADDR
// p := [ ] ;
43444: LD_ADDR_VAR 0 11
43448: PUSH
43449: EMPTY
43450: ST_TO_ADDR
// if sort then
43451: LD_VAR 0 9
43455: IFFALSE 43571
// for i = 1 to 6 - eng do
43457: LD_ADDR_VAR 0 3
43461: PUSH
43462: DOUBLE
43463: LD_INT 1
43465: DEC
43466: ST_TO_ADDR
43467: LD_INT 6
43469: PUSH
43470: LD_VAR 0 6
43474: MINUS
43475: PUSH
43476: FOR_TO
43477: IFFALSE 43569
// begin if i = sort then
43479: LD_VAR 0 3
43483: PUSH
43484: LD_VAR 0 9
43488: EQUAL
43489: IFFALSE 43493
// break ;
43491: GO 43569
// if GetClass ( i ) = 2 then
43493: LD_VAR 0 3
43497: PPUSH
43498: CALL_OW 257
43502: PUSH
43503: LD_INT 2
43505: EQUAL
43506: IFFALSE 43510
// continue ;
43508: GO 43476
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43510: LD_ADDR_VAR 0 11
43514: PUSH
43515: LD_VAR 0 11
43519: PPUSH
43520: LD_VAR 0 11
43524: PUSH
43525: LD_INT 1
43527: PLUS
43528: PPUSH
43529: LD_VAR 0 9
43533: PUSH
43534: LD_VAR 0 3
43538: ARRAY
43539: PPUSH
43540: CALL_OW 2
43544: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43545: LD_ADDR_VAR 0 4
43549: PUSH
43550: LD_VAR 0 4
43554: PUSH
43555: LD_VAR 0 9
43559: PUSH
43560: LD_VAR 0 3
43564: ARRAY
43565: DIFF
43566: ST_TO_ADDR
// end ;
43567: GO 43476
43569: POP
43570: POP
// if p then
43571: LD_VAR 0 11
43575: IFFALSE 43600
// result := Replace ( result , 2 , p ) ;
43577: LD_ADDR_VAR 0 2
43581: PUSH
43582: LD_VAR 0 2
43586: PPUSH
43587: LD_INT 2
43589: PPUSH
43590: LD_VAR 0 11
43594: PPUSH
43595: CALL_OW 1
43599: ST_TO_ADDR
// end ; exit ;
43600: GO 44988
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43602: LD_EXP 126
43606: PUSH
43607: LD_EXP 125
43611: PUSH
43612: LD_VAR 0 1
43616: ARRAY
43617: ARRAY
43618: NOT
43619: PUSH
43620: LD_EXP 99
43624: PUSH
43625: LD_VAR 0 1
43629: ARRAY
43630: PPUSH
43631: LD_INT 30
43633: PUSH
43634: LD_INT 3
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PPUSH
43641: CALL_OW 72
43645: AND
43646: PUSH
43647: LD_EXP 104
43651: PUSH
43652: LD_VAR 0 1
43656: ARRAY
43657: AND
43658: IFFALSE 44266
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43660: LD_ADDR_EXP 141
43664: PUSH
43665: LD_EXP 141
43669: PPUSH
43670: LD_VAR 0 1
43674: PPUSH
43675: LD_INT 5
43677: PPUSH
43678: CALL_OW 1
43682: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43683: LD_ADDR_VAR 0 2
43687: PUSH
43688: LD_INT 0
43690: PUSH
43691: LD_INT 0
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: LD_INT 0
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: ST_TO_ADDR
// if sci > 1 then
43706: LD_VAR 0 8
43710: PUSH
43711: LD_INT 1
43713: GREATER
43714: IFFALSE 43742
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43716: LD_ADDR_VAR 0 4
43720: PUSH
43721: LD_VAR 0 4
43725: PUSH
43726: LD_VAR 0 8
43730: PUSH
43731: LD_VAR 0 8
43735: PUSH
43736: LD_INT 1
43738: ARRAY
43739: DIFF
43740: DIFF
43741: ST_TO_ADDR
// if tmp and not sci then
43742: LD_VAR 0 4
43746: PUSH
43747: LD_VAR 0 8
43751: NOT
43752: AND
43753: IFFALSE 43822
// begin sort := SortBySkill ( tmp , 4 ) ;
43755: LD_ADDR_VAR 0 9
43759: PUSH
43760: LD_VAR 0 4
43764: PPUSH
43765: LD_INT 4
43767: PPUSH
43768: CALL 103287 0 2
43772: ST_TO_ADDR
// if sort then
43773: LD_VAR 0 9
43777: IFFALSE 43793
// p := sort [ 1 ] ;
43779: LD_ADDR_VAR 0 11
43783: PUSH
43784: LD_VAR 0 9
43788: PUSH
43789: LD_INT 1
43791: ARRAY
43792: ST_TO_ADDR
// if p then
43793: LD_VAR 0 11
43797: IFFALSE 43822
// result := Replace ( result , 4 , p ) ;
43799: LD_ADDR_VAR 0 2
43803: PUSH
43804: LD_VAR 0 2
43808: PPUSH
43809: LD_INT 4
43811: PPUSH
43812: LD_VAR 0 11
43816: PPUSH
43817: CALL_OW 1
43821: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43822: LD_ADDR_VAR 0 4
43826: PUSH
43827: LD_VAR 0 4
43831: PUSH
43832: LD_VAR 0 7
43836: DIFF
43837: ST_TO_ADDR
// if tmp and mech < 6 then
43838: LD_VAR 0 4
43842: PUSH
43843: LD_VAR 0 7
43847: PUSH
43848: LD_INT 6
43850: LESS
43851: AND
43852: IFFALSE 44040
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43854: LD_ADDR_VAR 0 9
43858: PUSH
43859: LD_VAR 0 4
43863: PUSH
43864: LD_VAR 0 8
43868: PUSH
43869: LD_VAR 0 7
43873: UNION
43874: DIFF
43875: PPUSH
43876: LD_INT 3
43878: PPUSH
43879: CALL 103287 0 2
43883: ST_TO_ADDR
// p := [ ] ;
43884: LD_ADDR_VAR 0 11
43888: PUSH
43889: EMPTY
43890: ST_TO_ADDR
// if sort then
43891: LD_VAR 0 9
43895: IFFALSE 44011
// for i = 1 to 6 - mech do
43897: LD_ADDR_VAR 0 3
43901: PUSH
43902: DOUBLE
43903: LD_INT 1
43905: DEC
43906: ST_TO_ADDR
43907: LD_INT 6
43909: PUSH
43910: LD_VAR 0 7
43914: MINUS
43915: PUSH
43916: FOR_TO
43917: IFFALSE 44009
// begin if i = sort then
43919: LD_VAR 0 3
43923: PUSH
43924: LD_VAR 0 9
43928: EQUAL
43929: IFFALSE 43933
// break ;
43931: GO 44009
// if GetClass ( i ) = 3 then
43933: LD_VAR 0 3
43937: PPUSH
43938: CALL_OW 257
43942: PUSH
43943: LD_INT 3
43945: EQUAL
43946: IFFALSE 43950
// continue ;
43948: GO 43916
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43950: LD_ADDR_VAR 0 11
43954: PUSH
43955: LD_VAR 0 11
43959: PPUSH
43960: LD_VAR 0 11
43964: PUSH
43965: LD_INT 1
43967: PLUS
43968: PPUSH
43969: LD_VAR 0 9
43973: PUSH
43974: LD_VAR 0 3
43978: ARRAY
43979: PPUSH
43980: CALL_OW 2
43984: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43985: LD_ADDR_VAR 0 4
43989: PUSH
43990: LD_VAR 0 4
43994: PUSH
43995: LD_VAR 0 9
43999: PUSH
44000: LD_VAR 0 3
44004: ARRAY
44005: DIFF
44006: ST_TO_ADDR
// end ;
44007: GO 43916
44009: POP
44010: POP
// if p then
44011: LD_VAR 0 11
44015: IFFALSE 44040
// result := Replace ( result , 3 , p ) ;
44017: LD_ADDR_VAR 0 2
44021: PUSH
44022: LD_VAR 0 2
44026: PPUSH
44027: LD_INT 3
44029: PPUSH
44030: LD_VAR 0 11
44034: PPUSH
44035: CALL_OW 1
44039: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44040: LD_ADDR_VAR 0 4
44044: PUSH
44045: LD_VAR 0 4
44049: PUSH
44050: LD_VAR 0 6
44054: DIFF
44055: ST_TO_ADDR
// if tmp and eng < 6 then
44056: LD_VAR 0 4
44060: PUSH
44061: LD_VAR 0 6
44065: PUSH
44066: LD_INT 6
44068: LESS
44069: AND
44070: IFFALSE 44264
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44072: LD_ADDR_VAR 0 9
44076: PUSH
44077: LD_VAR 0 4
44081: PUSH
44082: LD_VAR 0 8
44086: PUSH
44087: LD_VAR 0 7
44091: UNION
44092: PUSH
44093: LD_VAR 0 6
44097: UNION
44098: DIFF
44099: PPUSH
44100: LD_INT 2
44102: PPUSH
44103: CALL 103287 0 2
44107: ST_TO_ADDR
// p := [ ] ;
44108: LD_ADDR_VAR 0 11
44112: PUSH
44113: EMPTY
44114: ST_TO_ADDR
// if sort then
44115: LD_VAR 0 9
44119: IFFALSE 44235
// for i = 1 to 6 - eng do
44121: LD_ADDR_VAR 0 3
44125: PUSH
44126: DOUBLE
44127: LD_INT 1
44129: DEC
44130: ST_TO_ADDR
44131: LD_INT 6
44133: PUSH
44134: LD_VAR 0 6
44138: MINUS
44139: PUSH
44140: FOR_TO
44141: IFFALSE 44233
// begin if i = sort then
44143: LD_VAR 0 3
44147: PUSH
44148: LD_VAR 0 9
44152: EQUAL
44153: IFFALSE 44157
// break ;
44155: GO 44233
// if GetClass ( i ) = 2 then
44157: LD_VAR 0 3
44161: PPUSH
44162: CALL_OW 257
44166: PUSH
44167: LD_INT 2
44169: EQUAL
44170: IFFALSE 44174
// continue ;
44172: GO 44140
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44174: LD_ADDR_VAR 0 11
44178: PUSH
44179: LD_VAR 0 11
44183: PPUSH
44184: LD_VAR 0 11
44188: PUSH
44189: LD_INT 1
44191: PLUS
44192: PPUSH
44193: LD_VAR 0 9
44197: PUSH
44198: LD_VAR 0 3
44202: ARRAY
44203: PPUSH
44204: CALL_OW 2
44208: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44209: LD_ADDR_VAR 0 4
44213: PUSH
44214: LD_VAR 0 4
44218: PUSH
44219: LD_VAR 0 9
44223: PUSH
44224: LD_VAR 0 3
44228: ARRAY
44229: DIFF
44230: ST_TO_ADDR
// end ;
44231: GO 44140
44233: POP
44234: POP
// if p then
44235: LD_VAR 0 11
44239: IFFALSE 44264
// result := Replace ( result , 2 , p ) ;
44241: LD_ADDR_VAR 0 2
44245: PUSH
44246: LD_VAR 0 2
44250: PPUSH
44251: LD_INT 2
44253: PPUSH
44254: LD_VAR 0 11
44258: PPUSH
44259: CALL_OW 1
44263: ST_TO_ADDR
// end ; exit ;
44264: GO 44988
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44266: LD_EXP 126
44270: PUSH
44271: LD_EXP 125
44275: PUSH
44276: LD_VAR 0 1
44280: ARRAY
44281: ARRAY
44282: NOT
44283: PUSH
44284: LD_EXP 99
44288: PUSH
44289: LD_VAR 0 1
44293: ARRAY
44294: PPUSH
44295: LD_INT 30
44297: PUSH
44298: LD_INT 3
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PPUSH
44305: CALL_OW 72
44309: AND
44310: PUSH
44311: LD_EXP 104
44315: PUSH
44316: LD_VAR 0 1
44320: ARRAY
44321: NOT
44322: AND
44323: IFFALSE 44988
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44325: LD_ADDR_EXP 141
44329: PUSH
44330: LD_EXP 141
44334: PPUSH
44335: LD_VAR 0 1
44339: PPUSH
44340: LD_INT 6
44342: PPUSH
44343: CALL_OW 1
44347: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44348: LD_ADDR_VAR 0 2
44352: PUSH
44353: LD_INT 0
44355: PUSH
44356: LD_INT 0
44358: PUSH
44359: LD_INT 0
44361: PUSH
44362: LD_INT 0
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: ST_TO_ADDR
// if sci >= 1 then
44371: LD_VAR 0 8
44375: PUSH
44376: LD_INT 1
44378: GREATEREQUAL
44379: IFFALSE 44401
// tmp := tmp diff sci [ 1 ] ;
44381: LD_ADDR_VAR 0 4
44385: PUSH
44386: LD_VAR 0 4
44390: PUSH
44391: LD_VAR 0 8
44395: PUSH
44396: LD_INT 1
44398: ARRAY
44399: DIFF
44400: ST_TO_ADDR
// if tmp and not sci then
44401: LD_VAR 0 4
44405: PUSH
44406: LD_VAR 0 8
44410: NOT
44411: AND
44412: IFFALSE 44481
// begin sort := SortBySkill ( tmp , 4 ) ;
44414: LD_ADDR_VAR 0 9
44418: PUSH
44419: LD_VAR 0 4
44423: PPUSH
44424: LD_INT 4
44426: PPUSH
44427: CALL 103287 0 2
44431: ST_TO_ADDR
// if sort then
44432: LD_VAR 0 9
44436: IFFALSE 44452
// p := sort [ 1 ] ;
44438: LD_ADDR_VAR 0 11
44442: PUSH
44443: LD_VAR 0 9
44447: PUSH
44448: LD_INT 1
44450: ARRAY
44451: ST_TO_ADDR
// if p then
44452: LD_VAR 0 11
44456: IFFALSE 44481
// result := Replace ( result , 4 , p ) ;
44458: LD_ADDR_VAR 0 2
44462: PUSH
44463: LD_VAR 0 2
44467: PPUSH
44468: LD_INT 4
44470: PPUSH
44471: LD_VAR 0 11
44475: PPUSH
44476: CALL_OW 1
44480: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44481: LD_ADDR_VAR 0 4
44485: PUSH
44486: LD_VAR 0 4
44490: PUSH
44491: LD_VAR 0 7
44495: DIFF
44496: ST_TO_ADDR
// if tmp and mech < 6 then
44497: LD_VAR 0 4
44501: PUSH
44502: LD_VAR 0 7
44506: PUSH
44507: LD_INT 6
44509: LESS
44510: AND
44511: IFFALSE 44693
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44513: LD_ADDR_VAR 0 9
44517: PUSH
44518: LD_VAR 0 4
44522: PUSH
44523: LD_VAR 0 7
44527: DIFF
44528: PPUSH
44529: LD_INT 3
44531: PPUSH
44532: CALL 103287 0 2
44536: ST_TO_ADDR
// p := [ ] ;
44537: LD_ADDR_VAR 0 11
44541: PUSH
44542: EMPTY
44543: ST_TO_ADDR
// if sort then
44544: LD_VAR 0 9
44548: IFFALSE 44664
// for i = 1 to 6 - mech do
44550: LD_ADDR_VAR 0 3
44554: PUSH
44555: DOUBLE
44556: LD_INT 1
44558: DEC
44559: ST_TO_ADDR
44560: LD_INT 6
44562: PUSH
44563: LD_VAR 0 7
44567: MINUS
44568: PUSH
44569: FOR_TO
44570: IFFALSE 44662
// begin if i = sort then
44572: LD_VAR 0 3
44576: PUSH
44577: LD_VAR 0 9
44581: EQUAL
44582: IFFALSE 44586
// break ;
44584: GO 44662
// if GetClass ( i ) = 3 then
44586: LD_VAR 0 3
44590: PPUSH
44591: CALL_OW 257
44595: PUSH
44596: LD_INT 3
44598: EQUAL
44599: IFFALSE 44603
// continue ;
44601: GO 44569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44603: LD_ADDR_VAR 0 11
44607: PUSH
44608: LD_VAR 0 11
44612: PPUSH
44613: LD_VAR 0 11
44617: PUSH
44618: LD_INT 1
44620: PLUS
44621: PPUSH
44622: LD_VAR 0 9
44626: PUSH
44627: LD_VAR 0 3
44631: ARRAY
44632: PPUSH
44633: CALL_OW 2
44637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44638: LD_ADDR_VAR 0 4
44642: PUSH
44643: LD_VAR 0 4
44647: PUSH
44648: LD_VAR 0 9
44652: PUSH
44653: LD_VAR 0 3
44657: ARRAY
44658: DIFF
44659: ST_TO_ADDR
// end ;
44660: GO 44569
44662: POP
44663: POP
// if p then
44664: LD_VAR 0 11
44668: IFFALSE 44693
// result := Replace ( result , 3 , p ) ;
44670: LD_ADDR_VAR 0 2
44674: PUSH
44675: LD_VAR 0 2
44679: PPUSH
44680: LD_INT 3
44682: PPUSH
44683: LD_VAR 0 11
44687: PPUSH
44688: CALL_OW 1
44692: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44693: LD_ADDR_VAR 0 4
44697: PUSH
44698: LD_VAR 0 4
44702: PUSH
44703: LD_VAR 0 6
44707: DIFF
44708: ST_TO_ADDR
// if tmp and eng < 4 then
44709: LD_VAR 0 4
44713: PUSH
44714: LD_VAR 0 6
44718: PUSH
44719: LD_INT 4
44721: LESS
44722: AND
44723: IFFALSE 44913
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44725: LD_ADDR_VAR 0 9
44729: PUSH
44730: LD_VAR 0 4
44734: PUSH
44735: LD_VAR 0 7
44739: PUSH
44740: LD_VAR 0 6
44744: UNION
44745: DIFF
44746: PPUSH
44747: LD_INT 2
44749: PPUSH
44750: CALL 103287 0 2
44754: ST_TO_ADDR
// p := [ ] ;
44755: LD_ADDR_VAR 0 11
44759: PUSH
44760: EMPTY
44761: ST_TO_ADDR
// if sort then
44762: LD_VAR 0 9
44766: IFFALSE 44882
// for i = 1 to 4 - eng do
44768: LD_ADDR_VAR 0 3
44772: PUSH
44773: DOUBLE
44774: LD_INT 1
44776: DEC
44777: ST_TO_ADDR
44778: LD_INT 4
44780: PUSH
44781: LD_VAR 0 6
44785: MINUS
44786: PUSH
44787: FOR_TO
44788: IFFALSE 44880
// begin if i = sort then
44790: LD_VAR 0 3
44794: PUSH
44795: LD_VAR 0 9
44799: EQUAL
44800: IFFALSE 44804
// break ;
44802: GO 44880
// if GetClass ( i ) = 2 then
44804: LD_VAR 0 3
44808: PPUSH
44809: CALL_OW 257
44813: PUSH
44814: LD_INT 2
44816: EQUAL
44817: IFFALSE 44821
// continue ;
44819: GO 44787
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44821: LD_ADDR_VAR 0 11
44825: PUSH
44826: LD_VAR 0 11
44830: PPUSH
44831: LD_VAR 0 11
44835: PUSH
44836: LD_INT 1
44838: PLUS
44839: PPUSH
44840: LD_VAR 0 9
44844: PUSH
44845: LD_VAR 0 3
44849: ARRAY
44850: PPUSH
44851: CALL_OW 2
44855: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44856: LD_ADDR_VAR 0 4
44860: PUSH
44861: LD_VAR 0 4
44865: PUSH
44866: LD_VAR 0 9
44870: PUSH
44871: LD_VAR 0 3
44875: ARRAY
44876: DIFF
44877: ST_TO_ADDR
// end ;
44878: GO 44787
44880: POP
44881: POP
// if p then
44882: LD_VAR 0 11
44886: IFFALSE 44911
// result := Replace ( result , 2 , p ) ;
44888: LD_ADDR_VAR 0 2
44892: PUSH
44893: LD_VAR 0 2
44897: PPUSH
44898: LD_INT 2
44900: PPUSH
44901: LD_VAR 0 11
44905: PPUSH
44906: CALL_OW 1
44910: ST_TO_ADDR
// end else
44911: GO 44957
// for i = eng downto 5 do
44913: LD_ADDR_VAR 0 3
44917: PUSH
44918: DOUBLE
44919: LD_VAR 0 6
44923: INC
44924: ST_TO_ADDR
44925: LD_INT 5
44927: PUSH
44928: FOR_DOWNTO
44929: IFFALSE 44955
// tmp := tmp union eng [ i ] ;
44931: LD_ADDR_VAR 0 4
44935: PUSH
44936: LD_VAR 0 4
44940: PUSH
44941: LD_VAR 0 6
44945: PUSH
44946: LD_VAR 0 3
44950: ARRAY
44951: UNION
44952: ST_TO_ADDR
44953: GO 44928
44955: POP
44956: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
44957: LD_ADDR_VAR 0 2
44961: PUSH
44962: LD_VAR 0 2
44966: PPUSH
44967: LD_INT 1
44969: PPUSH
44970: LD_VAR 0 4
44974: PUSH
44975: LD_VAR 0 5
44979: DIFF
44980: PPUSH
44981: CALL_OW 1
44985: ST_TO_ADDR
// exit ;
44986: GO 44988
// end ; end ;
44988: LD_VAR 0 2
44992: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
44993: LD_INT 0
44995: PPUSH
44996: PPUSH
44997: PPUSH
// if not mc_bases then
44998: LD_EXP 99
45002: NOT
45003: IFFALSE 45007
// exit ;
45005: GO 45149
// for i = 1 to mc_bases do
45007: LD_ADDR_VAR 0 2
45011: PUSH
45012: DOUBLE
45013: LD_INT 1
45015: DEC
45016: ST_TO_ADDR
45017: LD_EXP 99
45021: PUSH
45022: FOR_TO
45023: IFFALSE 45140
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45025: LD_ADDR_VAR 0 3
45029: PUSH
45030: LD_EXP 99
45034: PUSH
45035: LD_VAR 0 2
45039: ARRAY
45040: PPUSH
45041: LD_INT 21
45043: PUSH
45044: LD_INT 3
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 3
45053: PUSH
45054: LD_INT 2
45056: PUSH
45057: LD_INT 30
45059: PUSH
45060: LD_INT 29
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: PUSH
45067: LD_INT 30
45069: PUSH
45070: LD_INT 30
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: LIST
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 3
45088: PUSH
45089: LD_INT 24
45091: PUSH
45092: LD_INT 1000
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: LIST
45107: PPUSH
45108: CALL_OW 72
45112: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45113: LD_ADDR_EXP 100
45117: PUSH
45118: LD_EXP 100
45122: PPUSH
45123: LD_VAR 0 2
45127: PPUSH
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 1
45137: ST_TO_ADDR
// end ;
45138: GO 45022
45140: POP
45141: POP
// RaiseSailEvent ( 101 ) ;
45142: LD_INT 101
45144: PPUSH
45145: CALL_OW 427
// end ;
45149: LD_VAR 0 1
45153: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45154: LD_INT 0
45156: PPUSH
45157: PPUSH
45158: PPUSH
45159: PPUSH
45160: PPUSH
45161: PPUSH
45162: PPUSH
// if not mc_bases then
45163: LD_EXP 99
45167: NOT
45168: IFFALSE 45172
// exit ;
45170: GO 45734
// for i = 1 to mc_bases do
45172: LD_ADDR_VAR 0 2
45176: PUSH
45177: DOUBLE
45178: LD_INT 1
45180: DEC
45181: ST_TO_ADDR
45182: LD_EXP 99
45186: PUSH
45187: FOR_TO
45188: IFFALSE 45725
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45190: LD_ADDR_VAR 0 5
45194: PUSH
45195: LD_EXP 99
45199: PUSH
45200: LD_VAR 0 2
45204: ARRAY
45205: PUSH
45206: LD_EXP 128
45210: PUSH
45211: LD_VAR 0 2
45215: ARRAY
45216: UNION
45217: PPUSH
45218: LD_INT 21
45220: PUSH
45221: LD_INT 1
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 1
45230: PUSH
45231: LD_INT 3
45233: PUSH
45234: LD_INT 54
45236: PUSH
45237: EMPTY
45238: LIST
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 3
45246: PUSH
45247: LD_INT 24
45249: PUSH
45250: LD_INT 1000
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: LIST
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PPUSH
45270: CALL_OW 72
45274: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45275: LD_ADDR_VAR 0 6
45279: PUSH
45280: LD_EXP 99
45284: PUSH
45285: LD_VAR 0 2
45289: ARRAY
45290: PPUSH
45291: LD_INT 21
45293: PUSH
45294: LD_INT 1
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 1
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: LD_INT 54
45309: PUSH
45310: EMPTY
45311: LIST
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 24
45322: PUSH
45323: LD_INT 250
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: LIST
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PPUSH
45343: CALL_OW 72
45347: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45348: LD_ADDR_VAR 0 7
45352: PUSH
45353: LD_VAR 0 5
45357: PUSH
45358: LD_VAR 0 6
45362: DIFF
45363: ST_TO_ADDR
// if not need_heal_1 then
45364: LD_VAR 0 6
45368: NOT
45369: IFFALSE 45402
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45371: LD_ADDR_EXP 102
45375: PUSH
45376: LD_EXP 102
45380: PPUSH
45381: LD_VAR 0 2
45385: PUSH
45386: LD_INT 1
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PPUSH
45393: EMPTY
45394: PPUSH
45395: CALL 72466 0 3
45399: ST_TO_ADDR
45400: GO 45472
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45402: LD_ADDR_EXP 102
45406: PUSH
45407: LD_EXP 102
45411: PPUSH
45412: LD_VAR 0 2
45416: PUSH
45417: LD_INT 1
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PPUSH
45424: LD_EXP 102
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: PUSH
45435: LD_INT 1
45437: ARRAY
45438: PPUSH
45439: LD_INT 3
45441: PUSH
45442: LD_INT 24
45444: PUSH
45445: LD_INT 1000
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PPUSH
45456: CALL_OW 72
45460: PUSH
45461: LD_VAR 0 6
45465: UNION
45466: PPUSH
45467: CALL 72466 0 3
45471: ST_TO_ADDR
// if not need_heal_2 then
45472: LD_VAR 0 7
45476: NOT
45477: IFFALSE 45510
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45479: LD_ADDR_EXP 102
45483: PUSH
45484: LD_EXP 102
45488: PPUSH
45489: LD_VAR 0 2
45493: PUSH
45494: LD_INT 2
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: PPUSH
45501: EMPTY
45502: PPUSH
45503: CALL 72466 0 3
45507: ST_TO_ADDR
45508: GO 45542
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45510: LD_ADDR_EXP 102
45514: PUSH
45515: LD_EXP 102
45519: PPUSH
45520: LD_VAR 0 2
45524: PUSH
45525: LD_INT 2
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PPUSH
45532: LD_VAR 0 7
45536: PPUSH
45537: CALL 72466 0 3
45541: ST_TO_ADDR
// if need_heal_2 then
45542: LD_VAR 0 7
45546: IFFALSE 45707
// for j in need_heal_2 do
45548: LD_ADDR_VAR 0 3
45552: PUSH
45553: LD_VAR 0 7
45557: PUSH
45558: FOR_IN
45559: IFFALSE 45705
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45561: LD_ADDR_VAR 0 5
45565: PUSH
45566: LD_EXP 99
45570: PUSH
45571: LD_VAR 0 2
45575: ARRAY
45576: PPUSH
45577: LD_INT 2
45579: PUSH
45580: LD_INT 30
45582: PUSH
45583: LD_INT 6
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 30
45592: PUSH
45593: LD_INT 7
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PUSH
45600: LD_INT 30
45602: PUSH
45603: LD_INT 8
45605: PUSH
45606: EMPTY
45607: LIST
45608: LIST
45609: PUSH
45610: LD_INT 30
45612: PUSH
45613: LD_INT 0
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: PUSH
45620: LD_INT 30
45622: PUSH
45623: LD_INT 1
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: PPUSH
45638: CALL_OW 72
45642: ST_TO_ADDR
// if tmp then
45643: LD_VAR 0 5
45647: IFFALSE 45703
// begin k := NearestUnitToUnit ( tmp , j ) ;
45649: LD_ADDR_VAR 0 4
45653: PUSH
45654: LD_VAR 0 5
45658: PPUSH
45659: LD_VAR 0 3
45663: PPUSH
45664: CALL_OW 74
45668: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45669: LD_VAR 0 3
45673: PPUSH
45674: LD_VAR 0 4
45678: PPUSH
45679: CALL_OW 296
45683: PUSH
45684: LD_INT 5
45686: GREATER
45687: IFFALSE 45703
// ComMoveToNearbyEntrance ( j , k ) ;
45689: LD_VAR 0 3
45693: PPUSH
45694: LD_VAR 0 4
45698: PPUSH
45699: CALL 105655 0 2
// end ; end ;
45703: GO 45558
45705: POP
45706: POP
// if not need_heal_1 and not need_heal_2 then
45707: LD_VAR 0 6
45711: NOT
45712: PUSH
45713: LD_VAR 0 7
45717: NOT
45718: AND
45719: IFFALSE 45723
// continue ;
45721: GO 45187
// end ;
45723: GO 45187
45725: POP
45726: POP
// RaiseSailEvent ( 102 ) ;
45727: LD_INT 102
45729: PPUSH
45730: CALL_OW 427
// end ;
45734: LD_VAR 0 1
45738: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45739: LD_INT 0
45741: PPUSH
45742: PPUSH
45743: PPUSH
45744: PPUSH
45745: PPUSH
45746: PPUSH
45747: PPUSH
45748: PPUSH
// if not mc_bases then
45749: LD_EXP 99
45753: NOT
45754: IFFALSE 45758
// exit ;
45756: GO 46669
// for i = 1 to mc_bases do
45758: LD_ADDR_VAR 0 2
45762: PUSH
45763: DOUBLE
45764: LD_INT 1
45766: DEC
45767: ST_TO_ADDR
45768: LD_EXP 99
45772: PUSH
45773: FOR_TO
45774: IFFALSE 46667
// begin if not mc_building_need_repair [ i ] then
45776: LD_EXP 100
45780: PUSH
45781: LD_VAR 0 2
45785: ARRAY
45786: NOT
45787: IFFALSE 45972
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45789: LD_ADDR_VAR 0 6
45793: PUSH
45794: LD_EXP 118
45798: PUSH
45799: LD_VAR 0 2
45803: ARRAY
45804: PPUSH
45805: LD_INT 3
45807: PUSH
45808: LD_INT 24
45810: PUSH
45811: LD_INT 1000
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 2
45824: PUSH
45825: LD_INT 34
45827: PUSH
45828: LD_INT 13
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: PUSH
45835: LD_INT 34
45837: PUSH
45838: LD_INT 52
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: PUSH
45845: LD_INT 34
45847: PUSH
45848: LD_INT 88
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PPUSH
45865: CALL_OW 72
45869: ST_TO_ADDR
// if cranes then
45870: LD_VAR 0 6
45874: IFFALSE 45936
// for j in cranes do
45876: LD_ADDR_VAR 0 3
45880: PUSH
45881: LD_VAR 0 6
45885: PUSH
45886: FOR_IN
45887: IFFALSE 45934
// if not IsInArea ( j , mc_parking [ i ] ) then
45889: LD_VAR 0 3
45893: PPUSH
45894: LD_EXP 123
45898: PUSH
45899: LD_VAR 0 2
45903: ARRAY
45904: PPUSH
45905: CALL_OW 308
45909: NOT
45910: IFFALSE 45932
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45912: LD_VAR 0 3
45916: PPUSH
45917: LD_EXP 123
45921: PUSH
45922: LD_VAR 0 2
45926: ARRAY
45927: PPUSH
45928: CALL_OW 113
45932: GO 45886
45934: POP
45935: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
45936: LD_ADDR_EXP 101
45940: PUSH
45941: LD_EXP 101
45945: PPUSH
45946: LD_VAR 0 2
45950: PPUSH
45951: EMPTY
45952: PPUSH
45953: CALL_OW 1
45957: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
45958: LD_VAR 0 2
45962: PPUSH
45963: LD_INT 101
45965: PPUSH
45966: CALL 40826 0 2
// continue ;
45970: GO 45773
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
45972: LD_ADDR_EXP 105
45976: PUSH
45977: LD_EXP 105
45981: PPUSH
45982: LD_VAR 0 2
45986: PPUSH
45987: EMPTY
45988: PPUSH
45989: CALL_OW 1
45993: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45994: LD_VAR 0 2
45998: PPUSH
45999: LD_INT 103
46001: PPUSH
46002: CALL 40826 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46006: LD_ADDR_VAR 0 5
46010: PUSH
46011: LD_EXP 99
46015: PUSH
46016: LD_VAR 0 2
46020: ARRAY
46021: PUSH
46022: LD_EXP 128
46026: PUSH
46027: LD_VAR 0 2
46031: ARRAY
46032: UNION
46033: PPUSH
46034: LD_INT 2
46036: PUSH
46037: LD_INT 25
46039: PUSH
46040: LD_INT 2
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PUSH
46047: LD_INT 25
46049: PUSH
46050: LD_INT 16
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: LIST
46061: PUSH
46062: EMPTY
46063: LIST
46064: PPUSH
46065: CALL_OW 72
46069: ST_TO_ADDR
// if mc_need_heal [ i ] then
46070: LD_EXP 102
46074: PUSH
46075: LD_VAR 0 2
46079: ARRAY
46080: IFFALSE 46124
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46082: LD_ADDR_VAR 0 5
46086: PUSH
46087: LD_VAR 0 5
46091: PUSH
46092: LD_EXP 102
46096: PUSH
46097: LD_VAR 0 2
46101: ARRAY
46102: PUSH
46103: LD_INT 1
46105: ARRAY
46106: PUSH
46107: LD_EXP 102
46111: PUSH
46112: LD_VAR 0 2
46116: ARRAY
46117: PUSH
46118: LD_INT 2
46120: ARRAY
46121: UNION
46122: DIFF
46123: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46124: LD_ADDR_VAR 0 6
46128: PUSH
46129: LD_EXP 118
46133: PUSH
46134: LD_VAR 0 2
46138: ARRAY
46139: PPUSH
46140: LD_INT 2
46142: PUSH
46143: LD_INT 34
46145: PUSH
46146: LD_INT 13
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 34
46155: PUSH
46156: LD_INT 52
46158: PUSH
46159: EMPTY
46160: LIST
46161: LIST
46162: PUSH
46163: LD_INT 34
46165: PUSH
46166: LD_INT 88
46168: PUSH
46169: EMPTY
46170: LIST
46171: LIST
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: PPUSH
46179: CALL_OW 72
46183: ST_TO_ADDR
// if cranes then
46184: LD_VAR 0 6
46188: IFFALSE 46356
// begin for j in cranes do
46190: LD_ADDR_VAR 0 3
46194: PUSH
46195: LD_VAR 0 6
46199: PUSH
46200: FOR_IN
46201: IFFALSE 46354
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46203: LD_VAR 0 3
46207: PPUSH
46208: CALL_OW 256
46212: PUSH
46213: LD_INT 1000
46215: EQUAL
46216: PUSH
46217: LD_VAR 0 3
46221: PPUSH
46222: CALL_OW 314
46226: NOT
46227: AND
46228: IFFALSE 46294
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46230: LD_ADDR_VAR 0 8
46234: PUSH
46235: LD_EXP 100
46239: PUSH
46240: LD_VAR 0 2
46244: ARRAY
46245: PPUSH
46246: LD_VAR 0 3
46250: PPUSH
46251: CALL_OW 74
46255: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46256: LD_VAR 0 8
46260: PPUSH
46261: LD_INT 16
46263: PPUSH
46264: CALL 75063 0 2
46268: PUSH
46269: LD_INT 4
46271: ARRAY
46272: PUSH
46273: LD_INT 10
46275: LESS
46276: IFFALSE 46292
// ComRepairBuilding ( j , to_repair ) ;
46278: LD_VAR 0 3
46282: PPUSH
46283: LD_VAR 0 8
46287: PPUSH
46288: CALL_OW 130
// end else
46292: GO 46352
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46294: LD_VAR 0 3
46298: PPUSH
46299: CALL_OW 256
46303: PUSH
46304: LD_INT 500
46306: LESS
46307: PUSH
46308: LD_VAR 0 3
46312: PPUSH
46313: LD_EXP 123
46317: PUSH
46318: LD_VAR 0 2
46322: ARRAY
46323: PPUSH
46324: CALL_OW 308
46328: NOT
46329: AND
46330: IFFALSE 46352
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46332: LD_VAR 0 3
46336: PPUSH
46337: LD_EXP 123
46341: PUSH
46342: LD_VAR 0 2
46346: ARRAY
46347: PPUSH
46348: CALL_OW 113
// end ;
46352: GO 46200
46354: POP
46355: POP
// end ; if tmp > 3 then
46356: LD_VAR 0 5
46360: PUSH
46361: LD_INT 3
46363: GREATER
46364: IFFALSE 46384
// tmp := ShrinkArray ( tmp , 4 ) ;
46366: LD_ADDR_VAR 0 5
46370: PUSH
46371: LD_VAR 0 5
46375: PPUSH
46376: LD_INT 4
46378: PPUSH
46379: CALL 105093 0 2
46383: ST_TO_ADDR
// if not tmp then
46384: LD_VAR 0 5
46388: NOT
46389: IFFALSE 46393
// continue ;
46391: GO 45773
// for j in tmp do
46393: LD_ADDR_VAR 0 3
46397: PUSH
46398: LD_VAR 0 5
46402: PUSH
46403: FOR_IN
46404: IFFALSE 46663
// begin if IsInUnit ( j ) then
46406: LD_VAR 0 3
46410: PPUSH
46411: CALL_OW 310
46415: IFFALSE 46426
// ComExitBuilding ( j ) ;
46417: LD_VAR 0 3
46421: PPUSH
46422: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46426: LD_VAR 0 3
46430: PUSH
46431: LD_EXP 101
46435: PUSH
46436: LD_VAR 0 2
46440: ARRAY
46441: IN
46442: NOT
46443: IFFALSE 46501
// begin SetTag ( j , 101 ) ;
46445: LD_VAR 0 3
46449: PPUSH
46450: LD_INT 101
46452: PPUSH
46453: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46457: LD_ADDR_EXP 101
46461: PUSH
46462: LD_EXP 101
46466: PPUSH
46467: LD_VAR 0 2
46471: PUSH
46472: LD_EXP 101
46476: PUSH
46477: LD_VAR 0 2
46481: ARRAY
46482: PUSH
46483: LD_INT 1
46485: PLUS
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PPUSH
46491: LD_VAR 0 3
46495: PPUSH
46496: CALL 72466 0 3
46500: ST_TO_ADDR
// end ; wait ( 1 ) ;
46501: LD_INT 1
46503: PPUSH
46504: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46508: LD_ADDR_VAR 0 7
46512: PUSH
46513: LD_EXP 100
46517: PUSH
46518: LD_VAR 0 2
46522: ARRAY
46523: ST_TO_ADDR
// if mc_scan [ i ] then
46524: LD_EXP 122
46528: PUSH
46529: LD_VAR 0 2
46533: ARRAY
46534: IFFALSE 46596
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46536: LD_ADDR_VAR 0 7
46540: PUSH
46541: LD_EXP 100
46545: PUSH
46546: LD_VAR 0 2
46550: ARRAY
46551: PPUSH
46552: LD_INT 3
46554: PUSH
46555: LD_INT 30
46557: PUSH
46558: LD_INT 32
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 30
46567: PUSH
46568: LD_INT 33
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 30
46577: PUSH
46578: LD_INT 31
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: PPUSH
46591: CALL_OW 72
46595: ST_TO_ADDR
// if not to_repair_tmp then
46596: LD_VAR 0 7
46600: NOT
46601: IFFALSE 46605
// continue ;
46603: GO 46403
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46605: LD_ADDR_VAR 0 8
46609: PUSH
46610: LD_VAR 0 7
46614: PPUSH
46615: LD_VAR 0 3
46619: PPUSH
46620: CALL_OW 74
46624: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46625: LD_VAR 0 8
46629: PPUSH
46630: LD_INT 16
46632: PPUSH
46633: CALL 75063 0 2
46637: PUSH
46638: LD_INT 4
46640: ARRAY
46641: PUSH
46642: LD_INT 14
46644: LESS
46645: IFFALSE 46661
// ComRepairBuilding ( j , to_repair ) ;
46647: LD_VAR 0 3
46651: PPUSH
46652: LD_VAR 0 8
46656: PPUSH
46657: CALL_OW 130
// end ;
46661: GO 46403
46663: POP
46664: POP
// end ;
46665: GO 45773
46667: POP
46668: POP
// end ;
46669: LD_VAR 0 1
46673: RET
// export function MC_Heal ; var i , j , tmp ; begin
46674: LD_INT 0
46676: PPUSH
46677: PPUSH
46678: PPUSH
46679: PPUSH
// if not mc_bases then
46680: LD_EXP 99
46684: NOT
46685: IFFALSE 46689
// exit ;
46687: GO 47091
// for i = 1 to mc_bases do
46689: LD_ADDR_VAR 0 2
46693: PUSH
46694: DOUBLE
46695: LD_INT 1
46697: DEC
46698: ST_TO_ADDR
46699: LD_EXP 99
46703: PUSH
46704: FOR_TO
46705: IFFALSE 47089
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46707: LD_EXP 102
46711: PUSH
46712: LD_VAR 0 2
46716: ARRAY
46717: PUSH
46718: LD_INT 1
46720: ARRAY
46721: NOT
46722: PUSH
46723: LD_EXP 102
46727: PUSH
46728: LD_VAR 0 2
46732: ARRAY
46733: PUSH
46734: LD_INT 2
46736: ARRAY
46737: NOT
46738: AND
46739: IFFALSE 46777
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46741: LD_ADDR_EXP 103
46745: PUSH
46746: LD_EXP 103
46750: PPUSH
46751: LD_VAR 0 2
46755: PPUSH
46756: EMPTY
46757: PPUSH
46758: CALL_OW 1
46762: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46763: LD_VAR 0 2
46767: PPUSH
46768: LD_INT 102
46770: PPUSH
46771: CALL 40826 0 2
// continue ;
46775: GO 46704
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46777: LD_ADDR_VAR 0 4
46781: PUSH
46782: LD_EXP 99
46786: PUSH
46787: LD_VAR 0 2
46791: ARRAY
46792: PPUSH
46793: LD_INT 25
46795: PUSH
46796: LD_INT 4
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PPUSH
46803: CALL_OW 72
46807: ST_TO_ADDR
// if not tmp then
46808: LD_VAR 0 4
46812: NOT
46813: IFFALSE 46817
// continue ;
46815: GO 46704
// if mc_taming [ i ] then
46817: LD_EXP 130
46821: PUSH
46822: LD_VAR 0 2
46826: ARRAY
46827: IFFALSE 46851
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
46829: LD_ADDR_EXP 130
46833: PUSH
46834: LD_EXP 130
46838: PPUSH
46839: LD_VAR 0 2
46843: PPUSH
46844: EMPTY
46845: PPUSH
46846: CALL_OW 1
46850: ST_TO_ADDR
// for j in tmp do
46851: LD_ADDR_VAR 0 3
46855: PUSH
46856: LD_VAR 0 4
46860: PUSH
46861: FOR_IN
46862: IFFALSE 47085
// begin if IsInUnit ( j ) then
46864: LD_VAR 0 3
46868: PPUSH
46869: CALL_OW 310
46873: IFFALSE 46884
// ComExitBuilding ( j ) ;
46875: LD_VAR 0 3
46879: PPUSH
46880: CALL_OW 122
// if not j in mc_healers [ i ] then
46884: LD_VAR 0 3
46888: PUSH
46889: LD_EXP 103
46893: PUSH
46894: LD_VAR 0 2
46898: ARRAY
46899: IN
46900: NOT
46901: IFFALSE 46947
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
46903: LD_ADDR_EXP 103
46907: PUSH
46908: LD_EXP 103
46912: PPUSH
46913: LD_VAR 0 2
46917: PUSH
46918: LD_EXP 103
46922: PUSH
46923: LD_VAR 0 2
46927: ARRAY
46928: PUSH
46929: LD_INT 1
46931: PLUS
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PPUSH
46937: LD_VAR 0 3
46941: PPUSH
46942: CALL 72466 0 3
46946: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
46947: LD_VAR 0 3
46951: PPUSH
46952: CALL_OW 110
46956: PUSH
46957: LD_INT 102
46959: NONEQUAL
46960: IFFALSE 46974
// SetTag ( j , 102 ) ;
46962: LD_VAR 0 3
46966: PPUSH
46967: LD_INT 102
46969: PPUSH
46970: CALL_OW 109
// Wait ( 3 ) ;
46974: LD_INT 3
46976: PPUSH
46977: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
46981: LD_EXP 102
46985: PUSH
46986: LD_VAR 0 2
46990: ARRAY
46991: PUSH
46992: LD_INT 1
46994: ARRAY
46995: IFFALSE 47027
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
46997: LD_VAR 0 3
47001: PPUSH
47002: LD_EXP 102
47006: PUSH
47007: LD_VAR 0 2
47011: ARRAY
47012: PUSH
47013: LD_INT 1
47015: ARRAY
47016: PUSH
47017: LD_INT 1
47019: ARRAY
47020: PPUSH
47021: CALL_OW 128
47025: GO 47083
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47027: LD_VAR 0 3
47031: PPUSH
47032: CALL_OW 314
47036: NOT
47037: PUSH
47038: LD_EXP 102
47042: PUSH
47043: LD_VAR 0 2
47047: ARRAY
47048: PUSH
47049: LD_INT 2
47051: ARRAY
47052: AND
47053: IFFALSE 47083
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47055: LD_VAR 0 3
47059: PPUSH
47060: LD_EXP 102
47064: PUSH
47065: LD_VAR 0 2
47069: ARRAY
47070: PUSH
47071: LD_INT 2
47073: ARRAY
47074: PUSH
47075: LD_INT 1
47077: ARRAY
47078: PPUSH
47079: CALL_OW 128
// end ;
47083: GO 46861
47085: POP
47086: POP
// end ;
47087: GO 46704
47089: POP
47090: POP
// end ;
47091: LD_VAR 0 1
47095: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47096: LD_INT 0
47098: PPUSH
47099: PPUSH
47100: PPUSH
47101: PPUSH
47102: PPUSH
47103: PPUSH
// if not mc_bases then
47104: LD_EXP 99
47108: NOT
47109: IFFALSE 47113
// exit ;
47111: GO 48276
// for i = 1 to mc_bases do
47113: LD_ADDR_VAR 0 2
47117: PUSH
47118: DOUBLE
47119: LD_INT 1
47121: DEC
47122: ST_TO_ADDR
47123: LD_EXP 99
47127: PUSH
47128: FOR_TO
47129: IFFALSE 48274
// begin if mc_scan [ i ] then
47131: LD_EXP 122
47135: PUSH
47136: LD_VAR 0 2
47140: ARRAY
47141: IFFALSE 47145
// continue ;
47143: GO 47128
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47145: LD_EXP 104
47149: PUSH
47150: LD_VAR 0 2
47154: ARRAY
47155: NOT
47156: PUSH
47157: LD_EXP 106
47161: PUSH
47162: LD_VAR 0 2
47166: ARRAY
47167: NOT
47168: AND
47169: PUSH
47170: LD_EXP 105
47174: PUSH
47175: LD_VAR 0 2
47179: ARRAY
47180: AND
47181: IFFALSE 47219
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47183: LD_ADDR_EXP 105
47187: PUSH
47188: LD_EXP 105
47192: PPUSH
47193: LD_VAR 0 2
47197: PPUSH
47198: EMPTY
47199: PPUSH
47200: CALL_OW 1
47204: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47205: LD_VAR 0 2
47209: PPUSH
47210: LD_INT 103
47212: PPUSH
47213: CALL 40826 0 2
// continue ;
47217: GO 47128
// end ; if mc_construct_list [ i ] then
47219: LD_EXP 106
47223: PUSH
47224: LD_VAR 0 2
47228: ARRAY
47229: IFFALSE 47449
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47231: LD_ADDR_VAR 0 5
47235: PUSH
47236: LD_EXP 99
47240: PUSH
47241: LD_VAR 0 2
47245: ARRAY
47246: PPUSH
47247: LD_INT 25
47249: PUSH
47250: LD_INT 2
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: PPUSH
47257: CALL_OW 72
47261: PUSH
47262: LD_EXP 101
47266: PUSH
47267: LD_VAR 0 2
47271: ARRAY
47272: DIFF
47273: ST_TO_ADDR
// if not tmp then
47274: LD_VAR 0 5
47278: NOT
47279: IFFALSE 47283
// continue ;
47281: GO 47128
// for j in tmp do
47283: LD_ADDR_VAR 0 3
47287: PUSH
47288: LD_VAR 0 5
47292: PUSH
47293: FOR_IN
47294: IFFALSE 47445
// begin if not mc_builders [ i ] then
47296: LD_EXP 105
47300: PUSH
47301: LD_VAR 0 2
47305: ARRAY
47306: NOT
47307: IFFALSE 47365
// begin SetTag ( j , 103 ) ;
47309: LD_VAR 0 3
47313: PPUSH
47314: LD_INT 103
47316: PPUSH
47317: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47321: LD_ADDR_EXP 105
47325: PUSH
47326: LD_EXP 105
47330: PPUSH
47331: LD_VAR 0 2
47335: PUSH
47336: LD_EXP 105
47340: PUSH
47341: LD_VAR 0 2
47345: ARRAY
47346: PUSH
47347: LD_INT 1
47349: PLUS
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PPUSH
47355: LD_VAR 0 3
47359: PPUSH
47360: CALL 72466 0 3
47364: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47365: LD_VAR 0 3
47369: PPUSH
47370: CALL_OW 310
47374: IFFALSE 47385
// ComExitBuilding ( j ) ;
47376: LD_VAR 0 3
47380: PPUSH
47381: CALL_OW 122
// wait ( 3 ) ;
47385: LD_INT 3
47387: PPUSH
47388: CALL_OW 67
// if not mc_construct_list [ i ] then
47392: LD_EXP 106
47396: PUSH
47397: LD_VAR 0 2
47401: ARRAY
47402: NOT
47403: IFFALSE 47407
// break ;
47405: GO 47445
// if not HasTask ( j ) then
47407: LD_VAR 0 3
47411: PPUSH
47412: CALL_OW 314
47416: NOT
47417: IFFALSE 47443
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47419: LD_VAR 0 3
47423: PPUSH
47424: LD_EXP 106
47428: PUSH
47429: LD_VAR 0 2
47433: ARRAY
47434: PUSH
47435: LD_INT 1
47437: ARRAY
47438: PPUSH
47439: CALL 75327 0 2
// end ;
47443: GO 47293
47445: POP
47446: POP
// end else
47447: GO 48272
// if mc_build_list [ i ] then
47449: LD_EXP 104
47453: PUSH
47454: LD_VAR 0 2
47458: ARRAY
47459: IFFALSE 48272
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47461: LD_EXP 104
47465: PUSH
47466: LD_VAR 0 2
47470: ARRAY
47471: PUSH
47472: LD_INT 1
47474: ARRAY
47475: PUSH
47476: LD_INT 1
47478: ARRAY
47479: PPUSH
47480: CALL 75151 0 1
47484: PUSH
47485: LD_EXP 99
47489: PUSH
47490: LD_VAR 0 2
47494: ARRAY
47495: PPUSH
47496: LD_INT 2
47498: PUSH
47499: LD_INT 30
47501: PUSH
47502: LD_INT 2
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: PUSH
47509: LD_INT 30
47511: PUSH
47512: LD_INT 3
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: LIST
47523: PPUSH
47524: CALL_OW 72
47528: NOT
47529: AND
47530: IFFALSE 47635
// begin for j = 1 to mc_build_list [ i ] do
47532: LD_ADDR_VAR 0 3
47536: PUSH
47537: DOUBLE
47538: LD_INT 1
47540: DEC
47541: ST_TO_ADDR
47542: LD_EXP 104
47546: PUSH
47547: LD_VAR 0 2
47551: ARRAY
47552: PUSH
47553: FOR_TO
47554: IFFALSE 47633
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47556: LD_EXP 104
47560: PUSH
47561: LD_VAR 0 2
47565: ARRAY
47566: PUSH
47567: LD_VAR 0 3
47571: ARRAY
47572: PUSH
47573: LD_INT 1
47575: ARRAY
47576: PUSH
47577: LD_INT 2
47579: EQUAL
47580: IFFALSE 47631
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47582: LD_ADDR_EXP 104
47586: PUSH
47587: LD_EXP 104
47591: PPUSH
47592: LD_VAR 0 2
47596: PPUSH
47597: LD_EXP 104
47601: PUSH
47602: LD_VAR 0 2
47606: ARRAY
47607: PPUSH
47608: LD_VAR 0 3
47612: PPUSH
47613: LD_INT 1
47615: PPUSH
47616: LD_INT 0
47618: PPUSH
47619: CALL 71884 0 4
47623: PPUSH
47624: CALL_OW 1
47628: ST_TO_ADDR
// break ;
47629: GO 47633
// end ;
47631: GO 47553
47633: POP
47634: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47635: LD_ADDR_VAR 0 6
47639: PUSH
47640: LD_EXP 99
47644: PUSH
47645: LD_VAR 0 2
47649: ARRAY
47650: PPUSH
47651: LD_INT 2
47653: PUSH
47654: LD_INT 30
47656: PUSH
47657: LD_INT 0
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PUSH
47664: LD_INT 30
47666: PUSH
47667: LD_INT 1
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: EMPTY
47675: LIST
47676: LIST
47677: LIST
47678: PPUSH
47679: CALL_OW 72
47683: ST_TO_ADDR
// for k := 1 to depot do
47684: LD_ADDR_VAR 0 4
47688: PUSH
47689: DOUBLE
47690: LD_INT 1
47692: DEC
47693: ST_TO_ADDR
47694: LD_VAR 0 6
47698: PUSH
47699: FOR_TO
47700: IFFALSE 48270
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47702: LD_EXP 104
47706: PUSH
47707: LD_VAR 0 2
47711: ARRAY
47712: PUSH
47713: LD_INT 1
47715: ARRAY
47716: PUSH
47717: LD_INT 1
47719: ARRAY
47720: PUSH
47721: LD_INT 0
47723: EQUAL
47724: PUSH
47725: LD_VAR 0 6
47729: PUSH
47730: LD_VAR 0 4
47734: ARRAY
47735: PPUSH
47736: LD_EXP 104
47740: PUSH
47741: LD_VAR 0 2
47745: ARRAY
47746: PUSH
47747: LD_INT 1
47749: ARRAY
47750: PUSH
47751: LD_INT 1
47753: ARRAY
47754: PPUSH
47755: LD_EXP 104
47759: PUSH
47760: LD_VAR 0 2
47764: ARRAY
47765: PUSH
47766: LD_INT 1
47768: ARRAY
47769: PUSH
47770: LD_INT 2
47772: ARRAY
47773: PPUSH
47774: LD_EXP 104
47778: PUSH
47779: LD_VAR 0 2
47783: ARRAY
47784: PUSH
47785: LD_INT 1
47787: ARRAY
47788: PUSH
47789: LD_INT 3
47791: ARRAY
47792: PPUSH
47793: LD_EXP 104
47797: PUSH
47798: LD_VAR 0 2
47802: ARRAY
47803: PUSH
47804: LD_INT 1
47806: ARRAY
47807: PUSH
47808: LD_INT 4
47810: ARRAY
47811: PPUSH
47812: CALL 80563 0 5
47816: OR
47817: IFFALSE 48098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47819: LD_ADDR_VAR 0 5
47823: PUSH
47824: LD_EXP 99
47828: PUSH
47829: LD_VAR 0 2
47833: ARRAY
47834: PPUSH
47835: LD_INT 25
47837: PUSH
47838: LD_INT 2
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PPUSH
47845: CALL_OW 72
47849: PUSH
47850: LD_EXP 101
47854: PUSH
47855: LD_VAR 0 2
47859: ARRAY
47860: DIFF
47861: ST_TO_ADDR
// if not tmp then
47862: LD_VAR 0 5
47866: NOT
47867: IFFALSE 47871
// continue ;
47869: GO 47699
// for j in tmp do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: LD_VAR 0 5
47880: PUSH
47881: FOR_IN
47882: IFFALSE 48094
// begin if not mc_builders [ i ] then
47884: LD_EXP 105
47888: PUSH
47889: LD_VAR 0 2
47893: ARRAY
47894: NOT
47895: IFFALSE 47953
// begin SetTag ( j , 103 ) ;
47897: LD_VAR 0 3
47901: PPUSH
47902: LD_INT 103
47904: PPUSH
47905: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47909: LD_ADDR_EXP 105
47913: PUSH
47914: LD_EXP 105
47918: PPUSH
47919: LD_VAR 0 2
47923: PUSH
47924: LD_EXP 105
47928: PUSH
47929: LD_VAR 0 2
47933: ARRAY
47934: PUSH
47935: LD_INT 1
47937: PLUS
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PPUSH
47943: LD_VAR 0 3
47947: PPUSH
47948: CALL 72466 0 3
47952: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47953: LD_VAR 0 3
47957: PPUSH
47958: CALL_OW 310
47962: IFFALSE 47973
// ComExitBuilding ( j ) ;
47964: LD_VAR 0 3
47968: PPUSH
47969: CALL_OW 122
// wait ( 3 ) ;
47973: LD_INT 3
47975: PPUSH
47976: CALL_OW 67
// if not mc_build_list [ i ] then
47980: LD_EXP 104
47984: PUSH
47985: LD_VAR 0 2
47989: ARRAY
47990: NOT
47991: IFFALSE 47995
// break ;
47993: GO 48094
// if not HasTask ( j ) then
47995: LD_VAR 0 3
47999: PPUSH
48000: CALL_OW 314
48004: NOT
48005: IFFALSE 48092
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48007: LD_VAR 0 3
48011: PPUSH
48012: LD_EXP 104
48016: PUSH
48017: LD_VAR 0 2
48021: ARRAY
48022: PUSH
48023: LD_INT 1
48025: ARRAY
48026: PUSH
48027: LD_INT 1
48029: ARRAY
48030: PPUSH
48031: LD_EXP 104
48035: PUSH
48036: LD_VAR 0 2
48040: ARRAY
48041: PUSH
48042: LD_INT 1
48044: ARRAY
48045: PUSH
48046: LD_INT 2
48048: ARRAY
48049: PPUSH
48050: LD_EXP 104
48054: PUSH
48055: LD_VAR 0 2
48059: ARRAY
48060: PUSH
48061: LD_INT 1
48063: ARRAY
48064: PUSH
48065: LD_INT 3
48067: ARRAY
48068: PPUSH
48069: LD_EXP 104
48073: PUSH
48074: LD_VAR 0 2
48078: ARRAY
48079: PUSH
48080: LD_INT 1
48082: ARRAY
48083: PUSH
48084: LD_INT 4
48086: ARRAY
48087: PPUSH
48088: CALL_OW 145
// end ;
48092: GO 47881
48094: POP
48095: POP
// end else
48096: GO 48268
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48098: LD_EXP 99
48102: PUSH
48103: LD_VAR 0 2
48107: ARRAY
48108: PPUSH
48109: LD_EXP 104
48113: PUSH
48114: LD_VAR 0 2
48118: ARRAY
48119: PUSH
48120: LD_INT 1
48122: ARRAY
48123: PUSH
48124: LD_INT 1
48126: ARRAY
48127: PPUSH
48128: LD_EXP 104
48132: PUSH
48133: LD_VAR 0 2
48137: ARRAY
48138: PUSH
48139: LD_INT 1
48141: ARRAY
48142: PUSH
48143: LD_INT 2
48145: ARRAY
48146: PPUSH
48147: LD_EXP 104
48151: PUSH
48152: LD_VAR 0 2
48156: ARRAY
48157: PUSH
48158: LD_INT 1
48160: ARRAY
48161: PUSH
48162: LD_INT 3
48164: ARRAY
48165: PPUSH
48166: LD_EXP 104
48170: PUSH
48171: LD_VAR 0 2
48175: ARRAY
48176: PUSH
48177: LD_INT 1
48179: ARRAY
48180: PUSH
48181: LD_INT 4
48183: ARRAY
48184: PPUSH
48185: LD_EXP 99
48189: PUSH
48190: LD_VAR 0 2
48194: ARRAY
48195: PPUSH
48196: LD_INT 21
48198: PUSH
48199: LD_INT 3
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PPUSH
48206: CALL_OW 72
48210: PPUSH
48211: EMPTY
48212: PPUSH
48213: CALL 79317 0 7
48217: NOT
48218: IFFALSE 48268
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48220: LD_ADDR_EXP 104
48224: PUSH
48225: LD_EXP 104
48229: PPUSH
48230: LD_VAR 0 2
48234: PPUSH
48235: LD_EXP 104
48239: PUSH
48240: LD_VAR 0 2
48244: ARRAY
48245: PPUSH
48246: LD_INT 1
48248: PPUSH
48249: LD_INT 1
48251: NEG
48252: PPUSH
48253: LD_INT 0
48255: PPUSH
48256: CALL 71884 0 4
48260: PPUSH
48261: CALL_OW 1
48265: ST_TO_ADDR
// continue ;
48266: GO 47699
// end ; end ;
48268: GO 47699
48270: POP
48271: POP
// end ; end ;
48272: GO 47128
48274: POP
48275: POP
// end ;
48276: LD_VAR 0 1
48280: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48281: LD_INT 0
48283: PPUSH
48284: PPUSH
48285: PPUSH
48286: PPUSH
48287: PPUSH
48288: PPUSH
// if not mc_bases then
48289: LD_EXP 99
48293: NOT
48294: IFFALSE 48298
// exit ;
48296: GO 48725
// for i = 1 to mc_bases do
48298: LD_ADDR_VAR 0 2
48302: PUSH
48303: DOUBLE
48304: LD_INT 1
48306: DEC
48307: ST_TO_ADDR
48308: LD_EXP 99
48312: PUSH
48313: FOR_TO
48314: IFFALSE 48723
// begin tmp := mc_build_upgrade [ i ] ;
48316: LD_ADDR_VAR 0 4
48320: PUSH
48321: LD_EXP 131
48325: PUSH
48326: LD_VAR 0 2
48330: ARRAY
48331: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48332: LD_ADDR_VAR 0 6
48336: PUSH
48337: LD_EXP 132
48341: PUSH
48342: LD_VAR 0 2
48346: ARRAY
48347: PPUSH
48348: LD_INT 2
48350: PUSH
48351: LD_INT 30
48353: PUSH
48354: LD_INT 6
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: LD_INT 30
48363: PUSH
48364: LD_INT 7
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: LIST
48375: PPUSH
48376: CALL_OW 72
48380: ST_TO_ADDR
// if not tmp and not lab then
48381: LD_VAR 0 4
48385: NOT
48386: PUSH
48387: LD_VAR 0 6
48391: NOT
48392: AND
48393: IFFALSE 48397
// continue ;
48395: GO 48313
// if tmp then
48397: LD_VAR 0 4
48401: IFFALSE 48521
// for j in tmp do
48403: LD_ADDR_VAR 0 3
48407: PUSH
48408: LD_VAR 0 4
48412: PUSH
48413: FOR_IN
48414: IFFALSE 48519
// begin if UpgradeCost ( j ) then
48416: LD_VAR 0 3
48420: PPUSH
48421: CALL 78977 0 1
48425: IFFALSE 48517
// begin ComUpgrade ( j ) ;
48427: LD_VAR 0 3
48431: PPUSH
48432: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48436: LD_ADDR_EXP 131
48440: PUSH
48441: LD_EXP 131
48445: PPUSH
48446: LD_VAR 0 2
48450: PPUSH
48451: LD_EXP 131
48455: PUSH
48456: LD_VAR 0 2
48460: ARRAY
48461: PUSH
48462: LD_VAR 0 3
48466: DIFF
48467: PPUSH
48468: CALL_OW 1
48472: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48473: LD_ADDR_EXP 106
48477: PUSH
48478: LD_EXP 106
48482: PPUSH
48483: LD_VAR 0 2
48487: PUSH
48488: LD_EXP 106
48492: PUSH
48493: LD_VAR 0 2
48497: ARRAY
48498: PUSH
48499: LD_INT 1
48501: PLUS
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PPUSH
48507: LD_VAR 0 3
48511: PPUSH
48512: CALL 72466 0 3
48516: ST_TO_ADDR
// end ; end ;
48517: GO 48413
48519: POP
48520: POP
// if not lab or not mc_lab_upgrade [ i ] then
48521: LD_VAR 0 6
48525: NOT
48526: PUSH
48527: LD_EXP 133
48531: PUSH
48532: LD_VAR 0 2
48536: ARRAY
48537: NOT
48538: OR
48539: IFFALSE 48543
// continue ;
48541: GO 48313
// for j in lab do
48543: LD_ADDR_VAR 0 3
48547: PUSH
48548: LD_VAR 0 6
48552: PUSH
48553: FOR_IN
48554: IFFALSE 48719
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48556: LD_VAR 0 3
48560: PPUSH
48561: CALL_OW 266
48565: PUSH
48566: LD_INT 6
48568: PUSH
48569: LD_INT 7
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: IN
48576: PUSH
48577: LD_VAR 0 3
48581: PPUSH
48582: CALL_OW 461
48586: PUSH
48587: LD_INT 1
48589: NONEQUAL
48590: AND
48591: IFFALSE 48717
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48593: LD_VAR 0 3
48597: PPUSH
48598: LD_EXP 133
48602: PUSH
48603: LD_VAR 0 2
48607: ARRAY
48608: PUSH
48609: LD_INT 1
48611: ARRAY
48612: PPUSH
48613: CALL 79182 0 2
48617: IFFALSE 48717
// begin ComCancel ( j ) ;
48619: LD_VAR 0 3
48623: PPUSH
48624: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48628: LD_VAR 0 3
48632: PPUSH
48633: LD_EXP 133
48637: PUSH
48638: LD_VAR 0 2
48642: ARRAY
48643: PUSH
48644: LD_INT 1
48646: ARRAY
48647: PPUSH
48648: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48652: LD_VAR 0 3
48656: PUSH
48657: LD_EXP 106
48661: PUSH
48662: LD_VAR 0 2
48666: ARRAY
48667: IN
48668: NOT
48669: IFFALSE 48715
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48671: LD_ADDR_EXP 106
48675: PUSH
48676: LD_EXP 106
48680: PPUSH
48681: LD_VAR 0 2
48685: PUSH
48686: LD_EXP 106
48690: PUSH
48691: LD_VAR 0 2
48695: ARRAY
48696: PUSH
48697: LD_INT 1
48699: PLUS
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PPUSH
48705: LD_VAR 0 3
48709: PPUSH
48710: CALL 72466 0 3
48714: ST_TO_ADDR
// break ;
48715: GO 48719
// end ; end ; end ;
48717: GO 48553
48719: POP
48720: POP
// end ;
48721: GO 48313
48723: POP
48724: POP
// end ;
48725: LD_VAR 0 1
48729: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48730: LD_INT 0
48732: PPUSH
48733: PPUSH
48734: PPUSH
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
48740: PPUSH
// if not mc_bases then
48741: LD_EXP 99
48745: NOT
48746: IFFALSE 48750
// exit ;
48748: GO 49155
// for i = 1 to mc_bases do
48750: LD_ADDR_VAR 0 2
48754: PUSH
48755: DOUBLE
48756: LD_INT 1
48758: DEC
48759: ST_TO_ADDR
48760: LD_EXP 99
48764: PUSH
48765: FOR_TO
48766: IFFALSE 49153
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48768: LD_EXP 107
48772: PUSH
48773: LD_VAR 0 2
48777: ARRAY
48778: NOT
48779: PUSH
48780: LD_EXP 99
48784: PUSH
48785: LD_VAR 0 2
48789: ARRAY
48790: PPUSH
48791: LD_INT 30
48793: PUSH
48794: LD_INT 3
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PPUSH
48801: CALL_OW 72
48805: NOT
48806: OR
48807: IFFALSE 48811
// continue ;
48809: GO 48765
// busy := false ;
48811: LD_ADDR_VAR 0 8
48815: PUSH
48816: LD_INT 0
48818: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48819: LD_ADDR_VAR 0 4
48823: PUSH
48824: LD_EXP 99
48828: PUSH
48829: LD_VAR 0 2
48833: ARRAY
48834: PPUSH
48835: LD_INT 30
48837: PUSH
48838: LD_INT 3
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PPUSH
48845: CALL_OW 72
48849: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
48850: LD_ADDR_VAR 0 6
48854: PUSH
48855: LD_EXP 107
48859: PUSH
48860: LD_VAR 0 2
48864: ARRAY
48865: PPUSH
48866: LD_INT 2
48868: PUSH
48869: LD_INT 30
48871: PUSH
48872: LD_INT 32
48874: PUSH
48875: EMPTY
48876: LIST
48877: LIST
48878: PUSH
48879: LD_INT 30
48881: PUSH
48882: LD_INT 33
48884: PUSH
48885: EMPTY
48886: LIST
48887: LIST
48888: PUSH
48889: EMPTY
48890: LIST
48891: LIST
48892: LIST
48893: PPUSH
48894: CALL_OW 72
48898: ST_TO_ADDR
// if not t then
48899: LD_VAR 0 6
48903: NOT
48904: IFFALSE 48908
// continue ;
48906: GO 48765
// for j in tmp do
48908: LD_ADDR_VAR 0 3
48912: PUSH
48913: LD_VAR 0 4
48917: PUSH
48918: FOR_IN
48919: IFFALSE 48949
// if not BuildingStatus ( j ) = bs_idle then
48921: LD_VAR 0 3
48925: PPUSH
48926: CALL_OW 461
48930: PUSH
48931: LD_INT 2
48933: EQUAL
48934: NOT
48935: IFFALSE 48947
// begin busy := true ;
48937: LD_ADDR_VAR 0 8
48941: PUSH
48942: LD_INT 1
48944: ST_TO_ADDR
// break ;
48945: GO 48949
// end ;
48947: GO 48918
48949: POP
48950: POP
// if busy then
48951: LD_VAR 0 8
48955: IFFALSE 48959
// continue ;
48957: GO 48765
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
48959: LD_ADDR_VAR 0 7
48963: PUSH
48964: LD_VAR 0 6
48968: PPUSH
48969: LD_INT 35
48971: PUSH
48972: LD_INT 0
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PPUSH
48979: CALL_OW 72
48983: ST_TO_ADDR
// if tw then
48984: LD_VAR 0 7
48988: IFFALSE 49065
// begin tw := tw [ 1 ] ;
48990: LD_ADDR_VAR 0 7
48994: PUSH
48995: LD_VAR 0 7
48999: PUSH
49000: LD_INT 1
49002: ARRAY
49003: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49004: LD_ADDR_VAR 0 9
49008: PUSH
49009: LD_VAR 0 7
49013: PPUSH
49014: LD_EXP 124
49018: PUSH
49019: LD_VAR 0 2
49023: ARRAY
49024: PPUSH
49025: CALL 77474 0 2
49029: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49030: LD_EXP 138
49034: PUSH
49035: LD_VAR 0 2
49039: ARRAY
49040: IFFALSE 49063
// if not weapon in mc_allowed_tower_weapons [ i ] then
49042: LD_VAR 0 9
49046: PUSH
49047: LD_EXP 138
49051: PUSH
49052: LD_VAR 0 2
49056: ARRAY
49057: IN
49058: NOT
49059: IFFALSE 49063
// continue ;
49061: GO 48765
// end else
49063: GO 49128
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49065: LD_ADDR_VAR 0 5
49069: PUSH
49070: LD_EXP 107
49074: PUSH
49075: LD_VAR 0 2
49079: ARRAY
49080: PPUSH
49081: LD_VAR 0 4
49085: PPUSH
49086: CALL 104326 0 2
49090: ST_TO_ADDR
// if not tmp2 then
49091: LD_VAR 0 5
49095: NOT
49096: IFFALSE 49100
// continue ;
49098: GO 48765
// tw := tmp2 [ 1 ] ;
49100: LD_ADDR_VAR 0 7
49104: PUSH
49105: LD_VAR 0 5
49109: PUSH
49110: LD_INT 1
49112: ARRAY
49113: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49114: LD_ADDR_VAR 0 9
49118: PUSH
49119: LD_VAR 0 5
49123: PUSH
49124: LD_INT 2
49126: ARRAY
49127: ST_TO_ADDR
// end ; if not weapon then
49128: LD_VAR 0 9
49132: NOT
49133: IFFALSE 49137
// continue ;
49135: GO 48765
// ComPlaceWeapon ( tw , weapon ) ;
49137: LD_VAR 0 7
49141: PPUSH
49142: LD_VAR 0 9
49146: PPUSH
49147: CALL_OW 148
// end ;
49151: GO 48765
49153: POP
49154: POP
// end ;
49155: LD_VAR 0 1
49159: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49160: LD_INT 0
49162: PPUSH
49163: PPUSH
49164: PPUSH
49165: PPUSH
49166: PPUSH
49167: PPUSH
49168: PPUSH
// if not mc_bases then
49169: LD_EXP 99
49173: NOT
49174: IFFALSE 49178
// exit ;
49176: GO 49946
// for i = 1 to mc_bases do
49178: LD_ADDR_VAR 0 2
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_EXP 99
49192: PUSH
49193: FOR_TO
49194: IFFALSE 49944
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49196: LD_EXP 112
49200: PUSH
49201: LD_VAR 0 2
49205: ARRAY
49206: NOT
49207: PUSH
49208: LD_EXP 112
49212: PUSH
49213: LD_VAR 0 2
49217: ARRAY
49218: PUSH
49219: LD_EXP 113
49223: PUSH
49224: LD_VAR 0 2
49228: ARRAY
49229: EQUAL
49230: OR
49231: PUSH
49232: LD_EXP 122
49236: PUSH
49237: LD_VAR 0 2
49241: ARRAY
49242: OR
49243: IFFALSE 49247
// continue ;
49245: GO 49193
// if mc_miners [ i ] then
49247: LD_EXP 113
49251: PUSH
49252: LD_VAR 0 2
49256: ARRAY
49257: IFFALSE 49631
// begin for j = mc_miners [ i ] downto 1 do
49259: LD_ADDR_VAR 0 3
49263: PUSH
49264: DOUBLE
49265: LD_EXP 113
49269: PUSH
49270: LD_VAR 0 2
49274: ARRAY
49275: INC
49276: ST_TO_ADDR
49277: LD_INT 1
49279: PUSH
49280: FOR_DOWNTO
49281: IFFALSE 49629
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49283: LD_EXP 113
49287: PUSH
49288: LD_VAR 0 2
49292: ARRAY
49293: PUSH
49294: LD_VAR 0 3
49298: ARRAY
49299: PPUSH
49300: CALL_OW 301
49304: PUSH
49305: LD_EXP 113
49309: PUSH
49310: LD_VAR 0 2
49314: ARRAY
49315: PUSH
49316: LD_VAR 0 3
49320: ARRAY
49321: PPUSH
49322: CALL_OW 257
49326: PUSH
49327: LD_INT 1
49329: NONEQUAL
49330: OR
49331: IFFALSE 49394
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49333: LD_ADDR_VAR 0 5
49337: PUSH
49338: LD_EXP 113
49342: PUSH
49343: LD_VAR 0 2
49347: ARRAY
49348: PUSH
49349: LD_EXP 113
49353: PUSH
49354: LD_VAR 0 2
49358: ARRAY
49359: PUSH
49360: LD_VAR 0 3
49364: ARRAY
49365: DIFF
49366: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49367: LD_ADDR_EXP 113
49371: PUSH
49372: LD_EXP 113
49376: PPUSH
49377: LD_VAR 0 2
49381: PPUSH
49382: LD_VAR 0 5
49386: PPUSH
49387: CALL_OW 1
49391: ST_TO_ADDR
// continue ;
49392: GO 49280
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49394: LD_EXP 113
49398: PUSH
49399: LD_VAR 0 2
49403: ARRAY
49404: PUSH
49405: LD_VAR 0 3
49409: ARRAY
49410: PPUSH
49411: CALL_OW 257
49415: PUSH
49416: LD_INT 1
49418: EQUAL
49419: PUSH
49420: LD_EXP 113
49424: PUSH
49425: LD_VAR 0 2
49429: ARRAY
49430: PUSH
49431: LD_VAR 0 3
49435: ARRAY
49436: PPUSH
49437: CALL_OW 459
49441: NOT
49442: AND
49443: PUSH
49444: LD_EXP 113
49448: PUSH
49449: LD_VAR 0 2
49453: ARRAY
49454: PUSH
49455: LD_VAR 0 3
49459: ARRAY
49460: PPUSH
49461: CALL_OW 314
49465: NOT
49466: AND
49467: IFFALSE 49627
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49469: LD_EXP 113
49473: PUSH
49474: LD_VAR 0 2
49478: ARRAY
49479: PUSH
49480: LD_VAR 0 3
49484: ARRAY
49485: PPUSH
49486: CALL_OW 310
49490: IFFALSE 49513
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49492: LD_EXP 113
49496: PUSH
49497: LD_VAR 0 2
49501: ARRAY
49502: PUSH
49503: LD_VAR 0 3
49507: ARRAY
49508: PPUSH
49509: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49513: LD_EXP 113
49517: PUSH
49518: LD_VAR 0 2
49522: ARRAY
49523: PUSH
49524: LD_VAR 0 3
49528: ARRAY
49529: PPUSH
49530: CALL_OW 314
49534: NOT
49535: IFFALSE 49627
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49537: LD_ADDR_VAR 0 7
49541: PUSH
49542: LD_INT 1
49544: PPUSH
49545: LD_EXP 112
49549: PUSH
49550: LD_VAR 0 2
49554: ARRAY
49555: PPUSH
49556: CALL_OW 12
49560: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49561: LD_EXP 113
49565: PUSH
49566: LD_VAR 0 2
49570: ARRAY
49571: PUSH
49572: LD_VAR 0 3
49576: ARRAY
49577: PPUSH
49578: LD_EXP 112
49582: PUSH
49583: LD_VAR 0 2
49587: ARRAY
49588: PUSH
49589: LD_VAR 0 7
49593: ARRAY
49594: PUSH
49595: LD_INT 1
49597: ARRAY
49598: PPUSH
49599: LD_EXP 112
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PUSH
49610: LD_VAR 0 7
49614: ARRAY
49615: PUSH
49616: LD_INT 2
49618: ARRAY
49619: PPUSH
49620: LD_INT 0
49622: PPUSH
49623: CALL_OW 193
// end ; end ; end ;
49627: GO 49280
49629: POP
49630: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49631: LD_ADDR_VAR 0 5
49635: PUSH
49636: LD_EXP 99
49640: PUSH
49641: LD_VAR 0 2
49645: ARRAY
49646: PPUSH
49647: LD_INT 2
49649: PUSH
49650: LD_INT 30
49652: PUSH
49653: LD_INT 4
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: PUSH
49660: LD_INT 30
49662: PUSH
49663: LD_INT 5
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PUSH
49670: LD_INT 30
49672: PUSH
49673: LD_INT 32
49675: PUSH
49676: EMPTY
49677: LIST
49678: LIST
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: PPUSH
49686: CALL_OW 72
49690: ST_TO_ADDR
// if not tmp then
49691: LD_VAR 0 5
49695: NOT
49696: IFFALSE 49700
// continue ;
49698: GO 49193
// list := [ ] ;
49700: LD_ADDR_VAR 0 6
49704: PUSH
49705: EMPTY
49706: ST_TO_ADDR
// for j in tmp do
49707: LD_ADDR_VAR 0 3
49711: PUSH
49712: LD_VAR 0 5
49716: PUSH
49717: FOR_IN
49718: IFFALSE 49787
// begin for k in UnitsInside ( j ) do
49720: LD_ADDR_VAR 0 4
49724: PUSH
49725: LD_VAR 0 3
49729: PPUSH
49730: CALL_OW 313
49734: PUSH
49735: FOR_IN
49736: IFFALSE 49783
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49738: LD_VAR 0 4
49742: PPUSH
49743: CALL_OW 257
49747: PUSH
49748: LD_INT 1
49750: EQUAL
49751: PUSH
49752: LD_VAR 0 4
49756: PPUSH
49757: CALL_OW 459
49761: NOT
49762: AND
49763: IFFALSE 49781
// list := list ^ k ;
49765: LD_ADDR_VAR 0 6
49769: PUSH
49770: LD_VAR 0 6
49774: PUSH
49775: LD_VAR 0 4
49779: ADD
49780: ST_TO_ADDR
49781: GO 49735
49783: POP
49784: POP
// end ;
49785: GO 49717
49787: POP
49788: POP
// list := list diff mc_miners [ i ] ;
49789: LD_ADDR_VAR 0 6
49793: PUSH
49794: LD_VAR 0 6
49798: PUSH
49799: LD_EXP 113
49803: PUSH
49804: LD_VAR 0 2
49808: ARRAY
49809: DIFF
49810: ST_TO_ADDR
// if not list then
49811: LD_VAR 0 6
49815: NOT
49816: IFFALSE 49820
// continue ;
49818: GO 49193
// k := mc_mines [ i ] - mc_miners [ i ] ;
49820: LD_ADDR_VAR 0 4
49824: PUSH
49825: LD_EXP 112
49829: PUSH
49830: LD_VAR 0 2
49834: ARRAY
49835: PUSH
49836: LD_EXP 113
49840: PUSH
49841: LD_VAR 0 2
49845: ARRAY
49846: MINUS
49847: ST_TO_ADDR
// if k > list then
49848: LD_VAR 0 4
49852: PUSH
49853: LD_VAR 0 6
49857: GREATER
49858: IFFALSE 49870
// k := list ;
49860: LD_ADDR_VAR 0 4
49864: PUSH
49865: LD_VAR 0 6
49869: ST_TO_ADDR
// for j = 1 to k do
49870: LD_ADDR_VAR 0 3
49874: PUSH
49875: DOUBLE
49876: LD_INT 1
49878: DEC
49879: ST_TO_ADDR
49880: LD_VAR 0 4
49884: PUSH
49885: FOR_TO
49886: IFFALSE 49940
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
49888: LD_ADDR_EXP 113
49892: PUSH
49893: LD_EXP 113
49897: PPUSH
49898: LD_VAR 0 2
49902: PUSH
49903: LD_EXP 113
49907: PUSH
49908: LD_VAR 0 2
49912: ARRAY
49913: PUSH
49914: LD_INT 1
49916: PLUS
49917: PUSH
49918: EMPTY
49919: LIST
49920: LIST
49921: PPUSH
49922: LD_VAR 0 6
49926: PUSH
49927: LD_VAR 0 3
49931: ARRAY
49932: PPUSH
49933: CALL 72466 0 3
49937: ST_TO_ADDR
49938: GO 49885
49940: POP
49941: POP
// end ;
49942: GO 49193
49944: POP
49945: POP
// end ;
49946: LD_VAR 0 1
49950: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
49951: LD_INT 0
49953: PPUSH
49954: PPUSH
49955: PPUSH
49956: PPUSH
49957: PPUSH
49958: PPUSH
49959: PPUSH
49960: PPUSH
49961: PPUSH
49962: PPUSH
49963: PPUSH
// if not mc_bases then
49964: LD_EXP 99
49968: NOT
49969: IFFALSE 49973
// exit ;
49971: GO 51796
// for i = 1 to mc_bases do
49973: LD_ADDR_VAR 0 2
49977: PUSH
49978: DOUBLE
49979: LD_INT 1
49981: DEC
49982: ST_TO_ADDR
49983: LD_EXP 99
49987: PUSH
49988: FOR_TO
49989: IFFALSE 51794
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
49991: LD_EXP 99
49995: PUSH
49996: LD_VAR 0 2
50000: ARRAY
50001: NOT
50002: PUSH
50003: LD_EXP 106
50007: PUSH
50008: LD_VAR 0 2
50012: ARRAY
50013: OR
50014: IFFALSE 50018
// continue ;
50016: GO 49988
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50018: LD_EXP 115
50022: PUSH
50023: LD_VAR 0 2
50027: ARRAY
50028: NOT
50029: PUSH
50030: LD_EXP 116
50034: PUSH
50035: LD_VAR 0 2
50039: ARRAY
50040: AND
50041: IFFALSE 50079
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50043: LD_ADDR_EXP 116
50047: PUSH
50048: LD_EXP 116
50052: PPUSH
50053: LD_VAR 0 2
50057: PPUSH
50058: EMPTY
50059: PPUSH
50060: CALL_OW 1
50064: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50065: LD_VAR 0 2
50069: PPUSH
50070: LD_INT 107
50072: PPUSH
50073: CALL 40826 0 2
// continue ;
50077: GO 49988
// end ; target := [ ] ;
50079: LD_ADDR_VAR 0 7
50083: PUSH
50084: EMPTY
50085: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50086: LD_ADDR_VAR 0 6
50090: PUSH
50091: LD_EXP 99
50095: PUSH
50096: LD_VAR 0 2
50100: ARRAY
50101: PUSH
50102: LD_INT 1
50104: ARRAY
50105: PPUSH
50106: CALL_OW 255
50110: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50111: LD_ADDR_VAR 0 9
50115: PUSH
50116: LD_EXP 99
50120: PUSH
50121: LD_VAR 0 2
50125: ARRAY
50126: PPUSH
50127: LD_INT 2
50129: PUSH
50130: LD_INT 30
50132: PUSH
50133: LD_INT 0
50135: PUSH
50136: EMPTY
50137: LIST
50138: LIST
50139: PUSH
50140: LD_INT 30
50142: PUSH
50143: LD_INT 1
50145: PUSH
50146: EMPTY
50147: LIST
50148: LIST
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: LIST
50154: PPUSH
50155: CALL_OW 72
50159: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50160: LD_ADDR_VAR 0 3
50164: PUSH
50165: DOUBLE
50166: LD_EXP 115
50170: PUSH
50171: LD_VAR 0 2
50175: ARRAY
50176: INC
50177: ST_TO_ADDR
50178: LD_INT 1
50180: PUSH
50181: FOR_DOWNTO
50182: IFFALSE 50427
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50184: LD_EXP 115
50188: PUSH
50189: LD_VAR 0 2
50193: ARRAY
50194: PUSH
50195: LD_VAR 0 3
50199: ARRAY
50200: PUSH
50201: LD_INT 2
50203: ARRAY
50204: PPUSH
50205: LD_EXP 115
50209: PUSH
50210: LD_VAR 0 2
50214: ARRAY
50215: PUSH
50216: LD_VAR 0 3
50220: ARRAY
50221: PUSH
50222: LD_INT 3
50224: ARRAY
50225: PPUSH
50226: CALL_OW 488
50230: PUSH
50231: LD_EXP 115
50235: PUSH
50236: LD_VAR 0 2
50240: ARRAY
50241: PUSH
50242: LD_VAR 0 3
50246: ARRAY
50247: PUSH
50248: LD_INT 2
50250: ARRAY
50251: PPUSH
50252: LD_EXP 115
50256: PUSH
50257: LD_VAR 0 2
50261: ARRAY
50262: PUSH
50263: LD_VAR 0 3
50267: ARRAY
50268: PUSH
50269: LD_INT 3
50271: ARRAY
50272: PPUSH
50273: CALL_OW 284
50277: PUSH
50278: LD_INT 0
50280: EQUAL
50281: AND
50282: IFFALSE 50337
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50284: LD_ADDR_VAR 0 5
50288: PUSH
50289: LD_EXP 115
50293: PUSH
50294: LD_VAR 0 2
50298: ARRAY
50299: PPUSH
50300: LD_VAR 0 3
50304: PPUSH
50305: CALL_OW 3
50309: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50310: LD_ADDR_EXP 115
50314: PUSH
50315: LD_EXP 115
50319: PPUSH
50320: LD_VAR 0 2
50324: PPUSH
50325: LD_VAR 0 5
50329: PPUSH
50330: CALL_OW 1
50334: ST_TO_ADDR
// continue ;
50335: GO 50181
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50337: LD_VAR 0 6
50341: PPUSH
50342: LD_EXP 115
50346: PUSH
50347: LD_VAR 0 2
50351: ARRAY
50352: PUSH
50353: LD_VAR 0 3
50357: ARRAY
50358: PUSH
50359: LD_INT 2
50361: ARRAY
50362: PPUSH
50363: LD_EXP 115
50367: PUSH
50368: LD_VAR 0 2
50372: ARRAY
50373: PUSH
50374: LD_VAR 0 3
50378: ARRAY
50379: PUSH
50380: LD_INT 3
50382: ARRAY
50383: PPUSH
50384: LD_INT 30
50386: PPUSH
50387: CALL 73362 0 4
50391: PUSH
50392: LD_INT 4
50394: ARRAY
50395: PUSH
50396: LD_INT 0
50398: EQUAL
50399: IFFALSE 50425
// begin target := mc_crates [ i ] [ j ] ;
50401: LD_ADDR_VAR 0 7
50405: PUSH
50406: LD_EXP 115
50410: PUSH
50411: LD_VAR 0 2
50415: ARRAY
50416: PUSH
50417: LD_VAR 0 3
50421: ARRAY
50422: ST_TO_ADDR
// break ;
50423: GO 50427
// end ; end ;
50425: GO 50181
50427: POP
50428: POP
// if not target then
50429: LD_VAR 0 7
50433: NOT
50434: IFFALSE 50438
// continue ;
50436: GO 49988
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50438: LD_ADDR_VAR 0 8
50442: PUSH
50443: LD_EXP 118
50447: PUSH
50448: LD_VAR 0 2
50452: ARRAY
50453: PPUSH
50454: LD_INT 2
50456: PUSH
50457: LD_INT 3
50459: PUSH
50460: LD_INT 58
50462: PUSH
50463: EMPTY
50464: LIST
50465: PUSH
50466: EMPTY
50467: LIST
50468: LIST
50469: PUSH
50470: LD_INT 61
50472: PUSH
50473: EMPTY
50474: LIST
50475: PUSH
50476: LD_INT 33
50478: PUSH
50479: LD_INT 5
50481: PUSH
50482: EMPTY
50483: LIST
50484: LIST
50485: PUSH
50486: LD_INT 33
50488: PUSH
50489: LD_INT 3
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: PUSH
50503: LD_INT 2
50505: PUSH
50506: LD_INT 34
50508: PUSH
50509: LD_INT 32
50511: PUSH
50512: EMPTY
50513: LIST
50514: LIST
50515: PUSH
50516: LD_INT 34
50518: PUSH
50519: LD_INT 51
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: PUSH
50526: LD_INT 34
50528: PUSH
50529: LD_INT 12
50531: PUSH
50532: EMPTY
50533: LIST
50534: LIST
50535: PUSH
50536: EMPTY
50537: LIST
50538: LIST
50539: LIST
50540: LIST
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: PPUSH
50546: CALL_OW 72
50550: ST_TO_ADDR
// if not cargo then
50551: LD_VAR 0 8
50555: NOT
50556: IFFALSE 51262
// begin if mc_crates_collector [ i ] < 5 then
50558: LD_EXP 116
50562: PUSH
50563: LD_VAR 0 2
50567: ARRAY
50568: PUSH
50569: LD_INT 5
50571: LESS
50572: IFFALSE 50938
// begin if mc_ape [ i ] then
50574: LD_EXP 128
50578: PUSH
50579: LD_VAR 0 2
50583: ARRAY
50584: IFFALSE 50631
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50586: LD_ADDR_VAR 0 5
50590: PUSH
50591: LD_EXP 128
50595: PUSH
50596: LD_VAR 0 2
50600: ARRAY
50601: PPUSH
50602: LD_INT 25
50604: PUSH
50605: LD_INT 16
50607: PUSH
50608: EMPTY
50609: LIST
50610: LIST
50611: PUSH
50612: LD_INT 24
50614: PUSH
50615: LD_INT 750
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: EMPTY
50623: LIST
50624: LIST
50625: PPUSH
50626: CALL_OW 72
50630: ST_TO_ADDR
// if not tmp then
50631: LD_VAR 0 5
50635: NOT
50636: IFFALSE 50683
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50638: LD_ADDR_VAR 0 5
50642: PUSH
50643: LD_EXP 99
50647: PUSH
50648: LD_VAR 0 2
50652: ARRAY
50653: PPUSH
50654: LD_INT 25
50656: PUSH
50657: LD_INT 2
50659: PUSH
50660: EMPTY
50661: LIST
50662: LIST
50663: PUSH
50664: LD_INT 24
50666: PUSH
50667: LD_INT 750
50669: PUSH
50670: EMPTY
50671: LIST
50672: LIST
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PPUSH
50678: CALL_OW 72
50682: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50683: LD_EXP 128
50687: PUSH
50688: LD_VAR 0 2
50692: ARRAY
50693: PUSH
50694: LD_EXP 99
50698: PUSH
50699: LD_VAR 0 2
50703: ARRAY
50704: PPUSH
50705: LD_INT 25
50707: PUSH
50708: LD_INT 2
50710: PUSH
50711: EMPTY
50712: LIST
50713: LIST
50714: PUSH
50715: LD_INT 24
50717: PUSH
50718: LD_INT 750
50720: PUSH
50721: EMPTY
50722: LIST
50723: LIST
50724: PUSH
50725: EMPTY
50726: LIST
50727: LIST
50728: PPUSH
50729: CALL_OW 72
50733: AND
50734: PUSH
50735: LD_VAR 0 5
50739: PUSH
50740: LD_INT 5
50742: LESS
50743: AND
50744: IFFALSE 50826
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50746: LD_ADDR_VAR 0 3
50750: PUSH
50751: LD_EXP 99
50755: PUSH
50756: LD_VAR 0 2
50760: ARRAY
50761: PPUSH
50762: LD_INT 25
50764: PUSH
50765: LD_INT 2
50767: PUSH
50768: EMPTY
50769: LIST
50770: LIST
50771: PUSH
50772: LD_INT 24
50774: PUSH
50775: LD_INT 750
50777: PUSH
50778: EMPTY
50779: LIST
50780: LIST
50781: PUSH
50782: EMPTY
50783: LIST
50784: LIST
50785: PPUSH
50786: CALL_OW 72
50790: PUSH
50791: FOR_IN
50792: IFFALSE 50824
// begin tmp := tmp union j ;
50794: LD_ADDR_VAR 0 5
50798: PUSH
50799: LD_VAR 0 5
50803: PUSH
50804: LD_VAR 0 3
50808: UNION
50809: ST_TO_ADDR
// if tmp >= 5 then
50810: LD_VAR 0 5
50814: PUSH
50815: LD_INT 5
50817: GREATEREQUAL
50818: IFFALSE 50822
// break ;
50820: GO 50824
// end ;
50822: GO 50791
50824: POP
50825: POP
// end ; if not tmp then
50826: LD_VAR 0 5
50830: NOT
50831: IFFALSE 50835
// continue ;
50833: GO 49988
// for j in tmp do
50835: LD_ADDR_VAR 0 3
50839: PUSH
50840: LD_VAR 0 5
50844: PUSH
50845: FOR_IN
50846: IFFALSE 50936
// if not GetTag ( j ) then
50848: LD_VAR 0 3
50852: PPUSH
50853: CALL_OW 110
50857: NOT
50858: IFFALSE 50934
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
50860: LD_ADDR_EXP 116
50864: PUSH
50865: LD_EXP 116
50869: PPUSH
50870: LD_VAR 0 2
50874: PUSH
50875: LD_EXP 116
50879: PUSH
50880: LD_VAR 0 2
50884: ARRAY
50885: PUSH
50886: LD_INT 1
50888: PLUS
50889: PUSH
50890: EMPTY
50891: LIST
50892: LIST
50893: PPUSH
50894: LD_VAR 0 3
50898: PPUSH
50899: CALL 72466 0 3
50903: ST_TO_ADDR
// SetTag ( j , 107 ) ;
50904: LD_VAR 0 3
50908: PPUSH
50909: LD_INT 107
50911: PPUSH
50912: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
50916: LD_EXP 116
50920: PUSH
50921: LD_VAR 0 2
50925: ARRAY
50926: PUSH
50927: LD_INT 5
50929: GREATEREQUAL
50930: IFFALSE 50934
// break ;
50932: GO 50936
// end ;
50934: GO 50845
50936: POP
50937: POP
// end ; if mc_crates_collector [ i ] and target then
50938: LD_EXP 116
50942: PUSH
50943: LD_VAR 0 2
50947: ARRAY
50948: PUSH
50949: LD_VAR 0 7
50953: AND
50954: IFFALSE 51260
// begin if mc_crates_collector [ i ] < target [ 1 ] then
50956: LD_EXP 116
50960: PUSH
50961: LD_VAR 0 2
50965: ARRAY
50966: PUSH
50967: LD_VAR 0 7
50971: PUSH
50972: LD_INT 1
50974: ARRAY
50975: LESS
50976: IFFALSE 50996
// tmp := mc_crates_collector [ i ] else
50978: LD_ADDR_VAR 0 5
50982: PUSH
50983: LD_EXP 116
50987: PUSH
50988: LD_VAR 0 2
50992: ARRAY
50993: ST_TO_ADDR
50994: GO 51010
// tmp := target [ 1 ] ;
50996: LD_ADDR_VAR 0 5
51000: PUSH
51001: LD_VAR 0 7
51005: PUSH
51006: LD_INT 1
51008: ARRAY
51009: ST_TO_ADDR
// k := 0 ;
51010: LD_ADDR_VAR 0 4
51014: PUSH
51015: LD_INT 0
51017: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51018: LD_ADDR_VAR 0 3
51022: PUSH
51023: LD_EXP 116
51027: PUSH
51028: LD_VAR 0 2
51032: ARRAY
51033: PUSH
51034: FOR_IN
51035: IFFALSE 51258
// begin k := k + 1 ;
51037: LD_ADDR_VAR 0 4
51041: PUSH
51042: LD_VAR 0 4
51046: PUSH
51047: LD_INT 1
51049: PLUS
51050: ST_TO_ADDR
// if k > tmp then
51051: LD_VAR 0 4
51055: PUSH
51056: LD_VAR 0 5
51060: GREATER
51061: IFFALSE 51065
// break ;
51063: GO 51258
// if not GetClass ( j ) in [ 2 , 16 ] then
51065: LD_VAR 0 3
51069: PPUSH
51070: CALL_OW 257
51074: PUSH
51075: LD_INT 2
51077: PUSH
51078: LD_INT 16
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: IN
51085: NOT
51086: IFFALSE 51139
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51088: LD_ADDR_EXP 116
51092: PUSH
51093: LD_EXP 116
51097: PPUSH
51098: LD_VAR 0 2
51102: PPUSH
51103: LD_EXP 116
51107: PUSH
51108: LD_VAR 0 2
51112: ARRAY
51113: PUSH
51114: LD_VAR 0 3
51118: DIFF
51119: PPUSH
51120: CALL_OW 1
51124: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51125: LD_VAR 0 3
51129: PPUSH
51130: LD_INT 0
51132: PPUSH
51133: CALL_OW 109
// continue ;
51137: GO 51034
// end ; if IsInUnit ( j ) then
51139: LD_VAR 0 3
51143: PPUSH
51144: CALL_OW 310
51148: IFFALSE 51159
// ComExitBuilding ( j ) ;
51150: LD_VAR 0 3
51154: PPUSH
51155: CALL_OW 122
// wait ( 3 ) ;
51159: LD_INT 3
51161: PPUSH
51162: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51166: LD_VAR 0 3
51170: PPUSH
51171: CALL_OW 314
51175: PUSH
51176: LD_VAR 0 6
51180: PPUSH
51181: LD_VAR 0 7
51185: PUSH
51186: LD_INT 2
51188: ARRAY
51189: PPUSH
51190: LD_VAR 0 7
51194: PUSH
51195: LD_INT 3
51197: ARRAY
51198: PPUSH
51199: LD_INT 30
51201: PPUSH
51202: CALL 73362 0 4
51206: PUSH
51207: LD_INT 4
51209: ARRAY
51210: AND
51211: IFFALSE 51229
// ComStandNearbyBuilding ( j , depot ) else
51213: LD_VAR 0 3
51217: PPUSH
51218: LD_VAR 0 9
51222: PPUSH
51223: CALL 68893 0 2
51227: GO 51256
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51229: LD_VAR 0 3
51233: PPUSH
51234: LD_VAR 0 7
51238: PUSH
51239: LD_INT 2
51241: ARRAY
51242: PPUSH
51243: LD_VAR 0 7
51247: PUSH
51248: LD_INT 3
51250: ARRAY
51251: PPUSH
51252: CALL_OW 117
// end ;
51256: GO 51034
51258: POP
51259: POP
// end ; end else
51260: GO 51792
// begin for j in cargo do
51262: LD_ADDR_VAR 0 3
51266: PUSH
51267: LD_VAR 0 8
51271: PUSH
51272: FOR_IN
51273: IFFALSE 51790
// begin if GetTag ( j ) <> 0 then
51275: LD_VAR 0 3
51279: PPUSH
51280: CALL_OW 110
51284: PUSH
51285: LD_INT 0
51287: NONEQUAL
51288: IFFALSE 51292
// continue ;
51290: GO 51272
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51292: LD_VAR 0 3
51296: PPUSH
51297: CALL_OW 256
51301: PUSH
51302: LD_INT 1000
51304: LESS
51305: PUSH
51306: LD_VAR 0 3
51310: PPUSH
51311: LD_EXP 123
51315: PUSH
51316: LD_VAR 0 2
51320: ARRAY
51321: PPUSH
51322: CALL_OW 308
51326: NOT
51327: AND
51328: IFFALSE 51350
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51330: LD_VAR 0 3
51334: PPUSH
51335: LD_EXP 123
51339: PUSH
51340: LD_VAR 0 2
51344: ARRAY
51345: PPUSH
51346: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51350: LD_VAR 0 3
51354: PPUSH
51355: CALL_OW 256
51359: PUSH
51360: LD_INT 1000
51362: LESS
51363: PUSH
51364: LD_VAR 0 3
51368: PPUSH
51369: LD_EXP 123
51373: PUSH
51374: LD_VAR 0 2
51378: ARRAY
51379: PPUSH
51380: CALL_OW 308
51384: AND
51385: IFFALSE 51389
// continue ;
51387: GO 51272
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51389: LD_VAR 0 3
51393: PPUSH
51394: CALL_OW 262
51398: PUSH
51399: LD_INT 2
51401: EQUAL
51402: PUSH
51403: LD_VAR 0 3
51407: PPUSH
51408: CALL_OW 261
51412: PUSH
51413: LD_INT 15
51415: LESS
51416: AND
51417: IFFALSE 51421
// continue ;
51419: GO 51272
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51421: LD_VAR 0 3
51425: PPUSH
51426: CALL_OW 262
51430: PUSH
51431: LD_INT 1
51433: EQUAL
51434: PUSH
51435: LD_VAR 0 3
51439: PPUSH
51440: CALL_OW 261
51444: PUSH
51445: LD_INT 10
51447: LESS
51448: AND
51449: IFFALSE 51729
// begin if not depot then
51451: LD_VAR 0 9
51455: NOT
51456: IFFALSE 51460
// continue ;
51458: GO 51272
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51460: LD_VAR 0 3
51464: PPUSH
51465: LD_VAR 0 9
51469: PPUSH
51470: LD_VAR 0 3
51474: PPUSH
51475: CALL_OW 74
51479: PPUSH
51480: CALL_OW 296
51484: PUSH
51485: LD_INT 6
51487: LESS
51488: IFFALSE 51504
// SetFuel ( j , 100 ) else
51490: LD_VAR 0 3
51494: PPUSH
51495: LD_INT 100
51497: PPUSH
51498: CALL_OW 240
51502: GO 51729
// if GetFuel ( j ) = 0 then
51504: LD_VAR 0 3
51508: PPUSH
51509: CALL_OW 261
51513: PUSH
51514: LD_INT 0
51516: EQUAL
51517: IFFALSE 51729
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51519: LD_ADDR_EXP 118
51523: PUSH
51524: LD_EXP 118
51528: PPUSH
51529: LD_VAR 0 2
51533: PPUSH
51534: LD_EXP 118
51538: PUSH
51539: LD_VAR 0 2
51543: ARRAY
51544: PUSH
51545: LD_VAR 0 3
51549: DIFF
51550: PPUSH
51551: CALL_OW 1
51555: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51556: LD_VAR 0 3
51560: PPUSH
51561: CALL_OW 263
51565: PUSH
51566: LD_INT 1
51568: EQUAL
51569: IFFALSE 51585
// ComExitVehicle ( IsInUnit ( j ) ) ;
51571: LD_VAR 0 3
51575: PPUSH
51576: CALL_OW 310
51580: PPUSH
51581: CALL_OW 121
// if GetControl ( j ) = control_remote then
51585: LD_VAR 0 3
51589: PPUSH
51590: CALL_OW 263
51594: PUSH
51595: LD_INT 2
51597: EQUAL
51598: IFFALSE 51609
// ComUnlink ( j ) ;
51600: LD_VAR 0 3
51604: PPUSH
51605: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51609: LD_ADDR_VAR 0 10
51613: PUSH
51614: LD_VAR 0 2
51618: PPUSH
51619: LD_INT 3
51621: PPUSH
51622: CALL 61396 0 2
51626: ST_TO_ADDR
// if fac then
51627: LD_VAR 0 10
51631: IFFALSE 51727
// begin for k in fac do
51633: LD_ADDR_VAR 0 4
51637: PUSH
51638: LD_VAR 0 10
51642: PUSH
51643: FOR_IN
51644: IFFALSE 51725
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51646: LD_ADDR_VAR 0 11
51650: PUSH
51651: LD_VAR 0 10
51655: PPUSH
51656: LD_VAR 0 3
51660: PPUSH
51661: CALL_OW 265
51665: PPUSH
51666: LD_VAR 0 3
51670: PPUSH
51671: CALL_OW 262
51675: PPUSH
51676: LD_VAR 0 3
51680: PPUSH
51681: CALL_OW 263
51685: PPUSH
51686: LD_VAR 0 3
51690: PPUSH
51691: CALL_OW 264
51695: PPUSH
51696: CALL 69964 0 5
51700: ST_TO_ADDR
// if components then
51701: LD_VAR 0 11
51705: IFFALSE 51723
// begin MC_InsertProduceList ( i , components ) ;
51707: LD_VAR 0 2
51711: PPUSH
51712: LD_VAR 0 11
51716: PPUSH
51717: CALL 60941 0 2
// break ;
51721: GO 51725
// end ; end ;
51723: GO 51643
51725: POP
51726: POP
// end ; continue ;
51727: GO 51272
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51729: LD_VAR 0 3
51733: PPUSH
51734: LD_INT 1
51736: PPUSH
51737: CALL_OW 289
51741: PUSH
51742: LD_INT 100
51744: LESS
51745: PUSH
51746: LD_VAR 0 3
51750: PPUSH
51751: CALL_OW 314
51755: NOT
51756: AND
51757: IFFALSE 51786
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51759: LD_VAR 0 3
51763: PPUSH
51764: LD_VAR 0 7
51768: PUSH
51769: LD_INT 2
51771: ARRAY
51772: PPUSH
51773: LD_VAR 0 7
51777: PUSH
51778: LD_INT 3
51780: ARRAY
51781: PPUSH
51782: CALL_OW 117
// break ;
51786: GO 51790
// end ;
51788: GO 51272
51790: POP
51791: POP
// end ; end ;
51792: GO 49988
51794: POP
51795: POP
// end ;
51796: LD_VAR 0 1
51800: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51801: LD_INT 0
51803: PPUSH
51804: PPUSH
51805: PPUSH
51806: PPUSH
// if not mc_bases then
51807: LD_EXP 99
51811: NOT
51812: IFFALSE 51816
// exit ;
51814: GO 51977
// for i = 1 to mc_bases do
51816: LD_ADDR_VAR 0 2
51820: PUSH
51821: DOUBLE
51822: LD_INT 1
51824: DEC
51825: ST_TO_ADDR
51826: LD_EXP 99
51830: PUSH
51831: FOR_TO
51832: IFFALSE 51975
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
51834: LD_ADDR_VAR 0 4
51838: PUSH
51839: LD_EXP 118
51843: PUSH
51844: LD_VAR 0 2
51848: ARRAY
51849: PUSH
51850: LD_EXP 121
51854: PUSH
51855: LD_VAR 0 2
51859: ARRAY
51860: UNION
51861: PPUSH
51862: LD_INT 33
51864: PUSH
51865: LD_INT 2
51867: PUSH
51868: EMPTY
51869: LIST
51870: LIST
51871: PPUSH
51872: CALL_OW 72
51876: ST_TO_ADDR
// if tmp then
51877: LD_VAR 0 4
51881: IFFALSE 51973
// for j in tmp do
51883: LD_ADDR_VAR 0 3
51887: PUSH
51888: LD_VAR 0 4
51892: PUSH
51893: FOR_IN
51894: IFFALSE 51971
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
51896: LD_VAR 0 3
51900: PPUSH
51901: CALL_OW 312
51905: NOT
51906: PUSH
51907: LD_VAR 0 3
51911: PPUSH
51912: CALL_OW 256
51916: PUSH
51917: LD_INT 250
51919: GREATEREQUAL
51920: AND
51921: IFFALSE 51934
// Connect ( j ) else
51923: LD_VAR 0 3
51927: PPUSH
51928: CALL 75435 0 1
51932: GO 51969
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
51934: LD_VAR 0 3
51938: PPUSH
51939: CALL_OW 256
51943: PUSH
51944: LD_INT 250
51946: LESS
51947: PUSH
51948: LD_VAR 0 3
51952: PPUSH
51953: CALL_OW 312
51957: AND
51958: IFFALSE 51969
// ComUnlink ( j ) ;
51960: LD_VAR 0 3
51964: PPUSH
51965: CALL_OW 136
51969: GO 51893
51971: POP
51972: POP
// end ;
51973: GO 51831
51975: POP
51976: POP
// end ;
51977: LD_VAR 0 1
51981: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
51982: LD_INT 0
51984: PPUSH
51985: PPUSH
51986: PPUSH
51987: PPUSH
51988: PPUSH
// if not mc_bases then
51989: LD_EXP 99
51993: NOT
51994: IFFALSE 51998
// exit ;
51996: GO 52443
// for i = 1 to mc_bases do
51998: LD_ADDR_VAR 0 2
52002: PUSH
52003: DOUBLE
52004: LD_INT 1
52006: DEC
52007: ST_TO_ADDR
52008: LD_EXP 99
52012: PUSH
52013: FOR_TO
52014: IFFALSE 52441
// begin if not mc_produce [ i ] then
52016: LD_EXP 120
52020: PUSH
52021: LD_VAR 0 2
52025: ARRAY
52026: NOT
52027: IFFALSE 52031
// continue ;
52029: GO 52013
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52031: LD_ADDR_VAR 0 5
52035: PUSH
52036: LD_EXP 99
52040: PUSH
52041: LD_VAR 0 2
52045: ARRAY
52046: PPUSH
52047: LD_INT 30
52049: PUSH
52050: LD_INT 3
52052: PUSH
52053: EMPTY
52054: LIST
52055: LIST
52056: PPUSH
52057: CALL_OW 72
52061: ST_TO_ADDR
// if not fac then
52062: LD_VAR 0 5
52066: NOT
52067: IFFALSE 52071
// continue ;
52069: GO 52013
// for j in fac do
52071: LD_ADDR_VAR 0 3
52075: PUSH
52076: LD_VAR 0 5
52080: PUSH
52081: FOR_IN
52082: IFFALSE 52437
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52084: LD_VAR 0 3
52088: PPUSH
52089: CALL_OW 461
52093: PUSH
52094: LD_INT 2
52096: NONEQUAL
52097: PUSH
52098: LD_VAR 0 3
52102: PPUSH
52103: LD_INT 15
52105: PPUSH
52106: CALL 75063 0 2
52110: PUSH
52111: LD_INT 4
52113: ARRAY
52114: OR
52115: IFFALSE 52119
// continue ;
52117: GO 52081
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52119: LD_VAR 0 3
52123: PPUSH
52124: LD_EXP 120
52128: PUSH
52129: LD_VAR 0 2
52133: ARRAY
52134: PUSH
52135: LD_INT 1
52137: ARRAY
52138: PUSH
52139: LD_INT 1
52141: ARRAY
52142: PPUSH
52143: LD_EXP 120
52147: PUSH
52148: LD_VAR 0 2
52152: ARRAY
52153: PUSH
52154: LD_INT 1
52156: ARRAY
52157: PUSH
52158: LD_INT 2
52160: ARRAY
52161: PPUSH
52162: LD_EXP 120
52166: PUSH
52167: LD_VAR 0 2
52171: ARRAY
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PUSH
52177: LD_INT 3
52179: ARRAY
52180: PPUSH
52181: LD_EXP 120
52185: PUSH
52186: LD_VAR 0 2
52190: ARRAY
52191: PUSH
52192: LD_INT 1
52194: ARRAY
52195: PUSH
52196: LD_INT 4
52198: ARRAY
52199: PPUSH
52200: CALL_OW 448
52204: PUSH
52205: LD_VAR 0 3
52209: PPUSH
52210: LD_EXP 120
52214: PUSH
52215: LD_VAR 0 2
52219: ARRAY
52220: PUSH
52221: LD_INT 1
52223: ARRAY
52224: PUSH
52225: LD_INT 1
52227: ARRAY
52228: PUSH
52229: LD_EXP 120
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: PUSH
52240: LD_INT 1
52242: ARRAY
52243: PUSH
52244: LD_INT 2
52246: ARRAY
52247: PUSH
52248: LD_EXP 120
52252: PUSH
52253: LD_VAR 0 2
52257: ARRAY
52258: PUSH
52259: LD_INT 1
52261: ARRAY
52262: PUSH
52263: LD_INT 3
52265: ARRAY
52266: PUSH
52267: LD_EXP 120
52271: PUSH
52272: LD_VAR 0 2
52276: ARRAY
52277: PUSH
52278: LD_INT 1
52280: ARRAY
52281: PUSH
52282: LD_INT 4
52284: ARRAY
52285: PUSH
52286: EMPTY
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: PPUSH
52292: CALL 78830 0 2
52296: AND
52297: IFFALSE 52435
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52299: LD_VAR 0 3
52303: PPUSH
52304: LD_EXP 120
52308: PUSH
52309: LD_VAR 0 2
52313: ARRAY
52314: PUSH
52315: LD_INT 1
52317: ARRAY
52318: PUSH
52319: LD_INT 1
52321: ARRAY
52322: PPUSH
52323: LD_EXP 120
52327: PUSH
52328: LD_VAR 0 2
52332: ARRAY
52333: PUSH
52334: LD_INT 1
52336: ARRAY
52337: PUSH
52338: LD_INT 2
52340: ARRAY
52341: PPUSH
52342: LD_EXP 120
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: PUSH
52353: LD_INT 1
52355: ARRAY
52356: PUSH
52357: LD_INT 3
52359: ARRAY
52360: PPUSH
52361: LD_EXP 120
52365: PUSH
52366: LD_VAR 0 2
52370: ARRAY
52371: PUSH
52372: LD_INT 1
52374: ARRAY
52375: PUSH
52376: LD_INT 4
52378: ARRAY
52379: PPUSH
52380: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52384: LD_ADDR_VAR 0 4
52388: PUSH
52389: LD_EXP 120
52393: PUSH
52394: LD_VAR 0 2
52398: ARRAY
52399: PPUSH
52400: LD_INT 1
52402: PPUSH
52403: CALL_OW 3
52407: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52408: LD_ADDR_EXP 120
52412: PUSH
52413: LD_EXP 120
52417: PPUSH
52418: LD_VAR 0 2
52422: PPUSH
52423: LD_VAR 0 4
52427: PPUSH
52428: CALL_OW 1
52432: ST_TO_ADDR
// break ;
52433: GO 52437
// end ; end ;
52435: GO 52081
52437: POP
52438: POP
// end ;
52439: GO 52013
52441: POP
52442: POP
// end ;
52443: LD_VAR 0 1
52447: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52448: LD_INT 0
52450: PPUSH
52451: PPUSH
52452: PPUSH
// if not mc_bases then
52453: LD_EXP 99
52457: NOT
52458: IFFALSE 52462
// exit ;
52460: GO 52551
// for i = 1 to mc_bases do
52462: LD_ADDR_VAR 0 2
52466: PUSH
52467: DOUBLE
52468: LD_INT 1
52470: DEC
52471: ST_TO_ADDR
52472: LD_EXP 99
52476: PUSH
52477: FOR_TO
52478: IFFALSE 52549
// begin if mc_attack [ i ] then
52480: LD_EXP 119
52484: PUSH
52485: LD_VAR 0 2
52489: ARRAY
52490: IFFALSE 52547
// begin tmp := mc_attack [ i ] [ 1 ] ;
52492: LD_ADDR_VAR 0 3
52496: PUSH
52497: LD_EXP 119
52501: PUSH
52502: LD_VAR 0 2
52506: ARRAY
52507: PUSH
52508: LD_INT 1
52510: ARRAY
52511: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52512: LD_ADDR_EXP 119
52516: PUSH
52517: LD_EXP 119
52521: PPUSH
52522: LD_VAR 0 2
52526: PPUSH
52527: EMPTY
52528: PPUSH
52529: CALL_OW 1
52533: ST_TO_ADDR
// Attack ( tmp ) ;
52534: LD_VAR 0 3
52538: PPUSH
52539: CALL 128635 0 1
// exit ;
52543: POP
52544: POP
52545: GO 52551
// end ; end ;
52547: GO 52477
52549: POP
52550: POP
// end ;
52551: LD_VAR 0 1
52555: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52556: LD_INT 0
52558: PPUSH
52559: PPUSH
52560: PPUSH
52561: PPUSH
52562: PPUSH
52563: PPUSH
52564: PPUSH
// if not mc_bases then
52565: LD_EXP 99
52569: NOT
52570: IFFALSE 52574
// exit ;
52572: GO 53431
// for i = 1 to mc_bases do
52574: LD_ADDR_VAR 0 2
52578: PUSH
52579: DOUBLE
52580: LD_INT 1
52582: DEC
52583: ST_TO_ADDR
52584: LD_EXP 99
52588: PUSH
52589: FOR_TO
52590: IFFALSE 53429
// begin if not mc_bases [ i ] then
52592: LD_EXP 99
52596: PUSH
52597: LD_VAR 0 2
52601: ARRAY
52602: NOT
52603: IFFALSE 52607
// continue ;
52605: GO 52589
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52607: LD_ADDR_VAR 0 7
52611: PUSH
52612: LD_EXP 99
52616: PUSH
52617: LD_VAR 0 2
52621: ARRAY
52622: PUSH
52623: LD_INT 1
52625: ARRAY
52626: PPUSH
52627: CALL 69115 0 1
52631: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52632: LD_ADDR_EXP 122
52636: PUSH
52637: LD_EXP 122
52641: PPUSH
52642: LD_VAR 0 2
52646: PPUSH
52647: LD_EXP 99
52651: PUSH
52652: LD_VAR 0 2
52656: ARRAY
52657: PUSH
52658: LD_INT 1
52660: ARRAY
52661: PPUSH
52662: CALL_OW 255
52666: PPUSH
52667: LD_EXP 124
52671: PUSH
52672: LD_VAR 0 2
52676: ARRAY
52677: PPUSH
52678: CALL 69080 0 2
52682: PPUSH
52683: CALL_OW 1
52687: ST_TO_ADDR
// if not mc_scan [ i ] then
52688: LD_EXP 122
52692: PUSH
52693: LD_VAR 0 2
52697: ARRAY
52698: NOT
52699: IFFALSE 52877
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52701: LD_ADDR_EXP 142
52705: PUSH
52706: LD_EXP 142
52710: PPUSH
52711: LD_VAR 0 2
52715: PPUSH
52716: LD_INT 0
52718: PPUSH
52719: CALL_OW 1
52723: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52724: LD_ADDR_VAR 0 4
52728: PUSH
52729: LD_EXP 99
52733: PUSH
52734: LD_VAR 0 2
52738: ARRAY
52739: PPUSH
52740: LD_INT 2
52742: PUSH
52743: LD_INT 25
52745: PUSH
52746: LD_INT 5
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: PUSH
52753: LD_INT 25
52755: PUSH
52756: LD_INT 8
52758: PUSH
52759: EMPTY
52760: LIST
52761: LIST
52762: PUSH
52763: LD_INT 25
52765: PUSH
52766: LD_INT 9
52768: PUSH
52769: EMPTY
52770: LIST
52771: LIST
52772: PUSH
52773: EMPTY
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: PPUSH
52779: CALL_OW 72
52783: ST_TO_ADDR
// if not tmp then
52784: LD_VAR 0 4
52788: NOT
52789: IFFALSE 52793
// continue ;
52791: GO 52589
// for j in tmp do
52793: LD_ADDR_VAR 0 3
52797: PUSH
52798: LD_VAR 0 4
52802: PUSH
52803: FOR_IN
52804: IFFALSE 52875
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52806: LD_VAR 0 3
52810: PPUSH
52811: CALL_OW 310
52815: PPUSH
52816: CALL_OW 266
52820: PUSH
52821: LD_INT 5
52823: EQUAL
52824: PUSH
52825: LD_VAR 0 3
52829: PPUSH
52830: CALL_OW 257
52834: PUSH
52835: LD_INT 1
52837: EQUAL
52838: AND
52839: PUSH
52840: LD_VAR 0 3
52844: PPUSH
52845: CALL_OW 459
52849: NOT
52850: AND
52851: PUSH
52852: LD_VAR 0 7
52856: AND
52857: IFFALSE 52873
// ComChangeProfession ( j , class ) ;
52859: LD_VAR 0 3
52863: PPUSH
52864: LD_VAR 0 7
52868: PPUSH
52869: CALL_OW 123
52873: GO 52803
52875: POP
52876: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
52877: LD_EXP 122
52881: PUSH
52882: LD_VAR 0 2
52886: ARRAY
52887: PUSH
52888: LD_EXP 142
52892: PUSH
52893: LD_VAR 0 2
52897: ARRAY
52898: NOT
52899: AND
52900: PUSH
52901: LD_EXP 121
52905: PUSH
52906: LD_VAR 0 2
52910: ARRAY
52911: NOT
52912: AND
52913: PUSH
52914: LD_EXP 99
52918: PUSH
52919: LD_VAR 0 2
52923: ARRAY
52924: PPUSH
52925: LD_INT 50
52927: PUSH
52928: EMPTY
52929: LIST
52930: PUSH
52931: LD_INT 2
52933: PUSH
52934: LD_INT 30
52936: PUSH
52937: LD_INT 32
52939: PUSH
52940: EMPTY
52941: LIST
52942: LIST
52943: PUSH
52944: LD_INT 30
52946: PUSH
52947: LD_INT 33
52949: PUSH
52950: EMPTY
52951: LIST
52952: LIST
52953: PUSH
52954: LD_INT 30
52956: PUSH
52957: LD_INT 4
52959: PUSH
52960: EMPTY
52961: LIST
52962: LIST
52963: PUSH
52964: LD_INT 30
52966: PUSH
52967: LD_INT 5
52969: PUSH
52970: EMPTY
52971: LIST
52972: LIST
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: LIST
52978: LIST
52979: LIST
52980: PUSH
52981: EMPTY
52982: LIST
52983: LIST
52984: PPUSH
52985: CALL_OW 72
52989: PUSH
52990: LD_INT 4
52992: LESS
52993: PUSH
52994: LD_EXP 99
52998: PUSH
52999: LD_VAR 0 2
53003: ARRAY
53004: PPUSH
53005: LD_INT 3
53007: PUSH
53008: LD_INT 24
53010: PUSH
53011: LD_INT 1000
53013: PUSH
53014: EMPTY
53015: LIST
53016: LIST
53017: PUSH
53018: EMPTY
53019: LIST
53020: LIST
53021: PUSH
53022: LD_INT 2
53024: PUSH
53025: LD_INT 30
53027: PUSH
53028: LD_INT 0
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PUSH
53035: LD_INT 30
53037: PUSH
53038: LD_INT 1
53040: PUSH
53041: EMPTY
53042: LIST
53043: LIST
53044: PUSH
53045: EMPTY
53046: LIST
53047: LIST
53048: LIST
53049: PUSH
53050: EMPTY
53051: LIST
53052: LIST
53053: PPUSH
53054: CALL_OW 72
53058: OR
53059: AND
53060: IFFALSE 53311
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53062: LD_ADDR_EXP 142
53066: PUSH
53067: LD_EXP 142
53071: PPUSH
53072: LD_VAR 0 2
53076: PPUSH
53077: LD_INT 1
53079: PPUSH
53080: CALL_OW 1
53084: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53085: LD_ADDR_VAR 0 4
53089: PUSH
53090: LD_EXP 99
53094: PUSH
53095: LD_VAR 0 2
53099: ARRAY
53100: PPUSH
53101: LD_INT 2
53103: PUSH
53104: LD_INT 25
53106: PUSH
53107: LD_INT 1
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: PUSH
53114: LD_INT 25
53116: PUSH
53117: LD_INT 5
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PUSH
53124: LD_INT 25
53126: PUSH
53127: LD_INT 8
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: PUSH
53134: LD_INT 25
53136: PUSH
53137: LD_INT 9
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: LIST
53150: PPUSH
53151: CALL_OW 72
53155: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53156: LD_ADDR_VAR 0 4
53160: PUSH
53161: LD_VAR 0 4
53165: PUSH
53166: LD_VAR 0 4
53170: PPUSH
53171: LD_INT 18
53173: PPUSH
53174: CALL 102352 0 2
53178: DIFF
53179: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53180: LD_VAR 0 4
53184: NOT
53185: PUSH
53186: LD_EXP 99
53190: PUSH
53191: LD_VAR 0 2
53195: ARRAY
53196: PPUSH
53197: LD_INT 2
53199: PUSH
53200: LD_INT 30
53202: PUSH
53203: LD_INT 4
53205: PUSH
53206: EMPTY
53207: LIST
53208: LIST
53209: PUSH
53210: LD_INT 30
53212: PUSH
53213: LD_INT 5
53215: PUSH
53216: EMPTY
53217: LIST
53218: LIST
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: LIST
53224: PPUSH
53225: CALL_OW 72
53229: NOT
53230: AND
53231: IFFALSE 53293
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53233: LD_ADDR_VAR 0 4
53237: PUSH
53238: LD_EXP 99
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: PPUSH
53249: LD_INT 2
53251: PUSH
53252: LD_INT 25
53254: PUSH
53255: LD_INT 2
53257: PUSH
53258: EMPTY
53259: LIST
53260: LIST
53261: PUSH
53262: LD_INT 25
53264: PUSH
53265: LD_INT 3
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PUSH
53272: LD_INT 25
53274: PUSH
53275: LD_INT 4
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: LIST
53286: LIST
53287: PPUSH
53288: CALL_OW 72
53292: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53293: LD_VAR 0 2
53297: PPUSH
53298: LD_VAR 0 4
53302: PPUSH
53303: CALL 133344 0 2
// exit ;
53307: POP
53308: POP
53309: GO 53431
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53311: LD_EXP 122
53315: PUSH
53316: LD_VAR 0 2
53320: ARRAY
53321: PUSH
53322: LD_EXP 142
53326: PUSH
53327: LD_VAR 0 2
53331: ARRAY
53332: NOT
53333: AND
53334: PUSH
53335: LD_EXP 121
53339: PUSH
53340: LD_VAR 0 2
53344: ARRAY
53345: AND
53346: IFFALSE 53427
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53348: LD_ADDR_EXP 142
53352: PUSH
53353: LD_EXP 142
53357: PPUSH
53358: LD_VAR 0 2
53362: PPUSH
53363: LD_INT 1
53365: PPUSH
53366: CALL_OW 1
53370: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53371: LD_ADDR_VAR 0 4
53375: PUSH
53376: LD_EXP 121
53380: PUSH
53381: LD_VAR 0 2
53385: ARRAY
53386: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53387: LD_ADDR_EXP 121
53391: PUSH
53392: LD_EXP 121
53396: PPUSH
53397: LD_VAR 0 2
53401: PPUSH
53402: EMPTY
53403: PPUSH
53404: CALL_OW 1
53408: ST_TO_ADDR
// Defend ( i , tmp ) ;
53409: LD_VAR 0 2
53413: PPUSH
53414: LD_VAR 0 4
53418: PPUSH
53419: CALL 133940 0 2
// exit ;
53423: POP
53424: POP
53425: GO 53431
// end ; end ;
53427: GO 52589
53429: POP
53430: POP
// end ;
53431: LD_VAR 0 1
53435: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53436: LD_INT 0
53438: PPUSH
53439: PPUSH
53440: PPUSH
53441: PPUSH
53442: PPUSH
53443: PPUSH
53444: PPUSH
53445: PPUSH
53446: PPUSH
53447: PPUSH
53448: PPUSH
// if not mc_bases then
53449: LD_EXP 99
53453: NOT
53454: IFFALSE 53458
// exit ;
53456: GO 54545
// for i = 1 to mc_bases do
53458: LD_ADDR_VAR 0 2
53462: PUSH
53463: DOUBLE
53464: LD_INT 1
53466: DEC
53467: ST_TO_ADDR
53468: LD_EXP 99
53472: PUSH
53473: FOR_TO
53474: IFFALSE 54543
// begin tmp := mc_lab [ i ] ;
53476: LD_ADDR_VAR 0 6
53480: PUSH
53481: LD_EXP 132
53485: PUSH
53486: LD_VAR 0 2
53490: ARRAY
53491: ST_TO_ADDR
// if not tmp then
53492: LD_VAR 0 6
53496: NOT
53497: IFFALSE 53501
// continue ;
53499: GO 53473
// idle_lab := 0 ;
53501: LD_ADDR_VAR 0 11
53505: PUSH
53506: LD_INT 0
53508: ST_TO_ADDR
// for j in tmp do
53509: LD_ADDR_VAR 0 3
53513: PUSH
53514: LD_VAR 0 6
53518: PUSH
53519: FOR_IN
53520: IFFALSE 54539
// begin researching := false ;
53522: LD_ADDR_VAR 0 10
53526: PUSH
53527: LD_INT 0
53529: ST_TO_ADDR
// side := GetSide ( j ) ;
53530: LD_ADDR_VAR 0 4
53534: PUSH
53535: LD_VAR 0 3
53539: PPUSH
53540: CALL_OW 255
53544: ST_TO_ADDR
// if not mc_tech [ side ] then
53545: LD_EXP 126
53549: PUSH
53550: LD_VAR 0 4
53554: ARRAY
53555: NOT
53556: IFFALSE 53560
// continue ;
53558: GO 53519
// if BuildingStatus ( j ) = bs_idle then
53560: LD_VAR 0 3
53564: PPUSH
53565: CALL_OW 461
53569: PUSH
53570: LD_INT 2
53572: EQUAL
53573: IFFALSE 53761
// begin if idle_lab and UnitsInside ( j ) < 6 then
53575: LD_VAR 0 11
53579: PUSH
53580: LD_VAR 0 3
53584: PPUSH
53585: CALL_OW 313
53589: PUSH
53590: LD_INT 6
53592: LESS
53593: AND
53594: IFFALSE 53665
// begin tmp2 := UnitsInside ( idle_lab ) ;
53596: LD_ADDR_VAR 0 9
53600: PUSH
53601: LD_VAR 0 11
53605: PPUSH
53606: CALL_OW 313
53610: ST_TO_ADDR
// if tmp2 then
53611: LD_VAR 0 9
53615: IFFALSE 53657
// for x in tmp2 do
53617: LD_ADDR_VAR 0 7
53621: PUSH
53622: LD_VAR 0 9
53626: PUSH
53627: FOR_IN
53628: IFFALSE 53655
// begin ComExitBuilding ( x ) ;
53630: LD_VAR 0 7
53634: PPUSH
53635: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53639: LD_VAR 0 7
53643: PPUSH
53644: LD_VAR 0 3
53648: PPUSH
53649: CALL_OW 180
// end ;
53653: GO 53627
53655: POP
53656: POP
// idle_lab := 0 ;
53657: LD_ADDR_VAR 0 11
53661: PUSH
53662: LD_INT 0
53664: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53665: LD_ADDR_VAR 0 5
53669: PUSH
53670: LD_EXP 126
53674: PUSH
53675: LD_VAR 0 4
53679: ARRAY
53680: PUSH
53681: FOR_IN
53682: IFFALSE 53742
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53684: LD_VAR 0 3
53688: PPUSH
53689: LD_VAR 0 5
53693: PPUSH
53694: CALL_OW 430
53698: PUSH
53699: LD_VAR 0 4
53703: PPUSH
53704: LD_VAR 0 5
53708: PPUSH
53709: CALL 68185 0 2
53713: AND
53714: IFFALSE 53740
// begin researching := true ;
53716: LD_ADDR_VAR 0 10
53720: PUSH
53721: LD_INT 1
53723: ST_TO_ADDR
// ComResearch ( j , t ) ;
53724: LD_VAR 0 3
53728: PPUSH
53729: LD_VAR 0 5
53733: PPUSH
53734: CALL_OW 124
// break ;
53738: GO 53742
// end ;
53740: GO 53681
53742: POP
53743: POP
// if not researching then
53744: LD_VAR 0 10
53748: NOT
53749: IFFALSE 53761
// idle_lab := j ;
53751: LD_ADDR_VAR 0 11
53755: PUSH
53756: LD_VAR 0 3
53760: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53761: LD_VAR 0 3
53765: PPUSH
53766: CALL_OW 461
53770: PUSH
53771: LD_INT 10
53773: EQUAL
53774: IFFALSE 54362
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53776: LD_EXP 128
53780: PUSH
53781: LD_VAR 0 2
53785: ARRAY
53786: NOT
53787: PUSH
53788: LD_EXP 129
53792: PUSH
53793: LD_VAR 0 2
53797: ARRAY
53798: NOT
53799: AND
53800: PUSH
53801: LD_EXP 126
53805: PUSH
53806: LD_VAR 0 4
53810: ARRAY
53811: PUSH
53812: LD_INT 1
53814: GREATER
53815: AND
53816: IFFALSE 53947
// begin ComCancel ( j ) ;
53818: LD_VAR 0 3
53822: PPUSH
53823: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
53827: LD_ADDR_EXP 126
53831: PUSH
53832: LD_EXP 126
53836: PPUSH
53837: LD_VAR 0 4
53841: PPUSH
53842: LD_EXP 126
53846: PUSH
53847: LD_VAR 0 4
53851: ARRAY
53852: PPUSH
53853: LD_EXP 126
53857: PUSH
53858: LD_VAR 0 4
53862: ARRAY
53863: PUSH
53864: LD_INT 1
53866: MINUS
53867: PPUSH
53868: LD_EXP 126
53872: PUSH
53873: LD_VAR 0 4
53877: ARRAY
53878: PPUSH
53879: LD_INT 0
53881: PPUSH
53882: CALL 71884 0 4
53886: PPUSH
53887: CALL_OW 1
53891: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
53892: LD_ADDR_EXP 126
53896: PUSH
53897: LD_EXP 126
53901: PPUSH
53902: LD_VAR 0 4
53906: PPUSH
53907: LD_EXP 126
53911: PUSH
53912: LD_VAR 0 4
53916: ARRAY
53917: PPUSH
53918: LD_EXP 126
53922: PUSH
53923: LD_VAR 0 4
53927: ARRAY
53928: PPUSH
53929: LD_INT 1
53931: PPUSH
53932: LD_INT 0
53934: PPUSH
53935: CALL 71884 0 4
53939: PPUSH
53940: CALL_OW 1
53944: ST_TO_ADDR
// continue ;
53945: GO 53519
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
53947: LD_EXP 128
53951: PUSH
53952: LD_VAR 0 2
53956: ARRAY
53957: PUSH
53958: LD_EXP 129
53962: PUSH
53963: LD_VAR 0 2
53967: ARRAY
53968: NOT
53969: AND
53970: IFFALSE 54097
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
53972: LD_ADDR_EXP 129
53976: PUSH
53977: LD_EXP 129
53981: PPUSH
53982: LD_VAR 0 2
53986: PUSH
53987: LD_EXP 129
53991: PUSH
53992: LD_VAR 0 2
53996: ARRAY
53997: PUSH
53998: LD_INT 1
54000: PLUS
54001: PUSH
54002: EMPTY
54003: LIST
54004: LIST
54005: PPUSH
54006: LD_EXP 128
54010: PUSH
54011: LD_VAR 0 2
54015: ARRAY
54016: PUSH
54017: LD_INT 1
54019: ARRAY
54020: PPUSH
54021: CALL 72466 0 3
54025: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54026: LD_EXP 128
54030: PUSH
54031: LD_VAR 0 2
54035: ARRAY
54036: PUSH
54037: LD_INT 1
54039: ARRAY
54040: PPUSH
54041: LD_INT 112
54043: PPUSH
54044: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54048: LD_ADDR_VAR 0 9
54052: PUSH
54053: LD_EXP 128
54057: PUSH
54058: LD_VAR 0 2
54062: ARRAY
54063: PPUSH
54064: LD_INT 1
54066: PPUSH
54067: CALL_OW 3
54071: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54072: LD_ADDR_EXP 128
54076: PUSH
54077: LD_EXP 128
54081: PPUSH
54082: LD_VAR 0 2
54086: PPUSH
54087: LD_VAR 0 9
54091: PPUSH
54092: CALL_OW 1
54096: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54097: LD_EXP 128
54101: PUSH
54102: LD_VAR 0 2
54106: ARRAY
54107: PUSH
54108: LD_EXP 129
54112: PUSH
54113: LD_VAR 0 2
54117: ARRAY
54118: AND
54119: PUSH
54120: LD_EXP 129
54124: PUSH
54125: LD_VAR 0 2
54129: ARRAY
54130: PUSH
54131: LD_INT 1
54133: ARRAY
54134: PPUSH
54135: CALL_OW 310
54139: NOT
54140: AND
54141: PUSH
54142: LD_VAR 0 3
54146: PPUSH
54147: CALL_OW 313
54151: PUSH
54152: LD_INT 6
54154: EQUAL
54155: AND
54156: IFFALSE 54212
// begin tmp2 := UnitsInside ( j ) ;
54158: LD_ADDR_VAR 0 9
54162: PUSH
54163: LD_VAR 0 3
54167: PPUSH
54168: CALL_OW 313
54172: ST_TO_ADDR
// if tmp2 = 6 then
54173: LD_VAR 0 9
54177: PUSH
54178: LD_INT 6
54180: EQUAL
54181: IFFALSE 54212
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54183: LD_VAR 0 9
54187: PUSH
54188: LD_INT 1
54190: ARRAY
54191: PPUSH
54192: LD_INT 112
54194: PPUSH
54195: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54199: LD_VAR 0 9
54203: PUSH
54204: LD_INT 1
54206: ARRAY
54207: PPUSH
54208: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54212: LD_EXP 129
54216: PUSH
54217: LD_VAR 0 2
54221: ARRAY
54222: PUSH
54223: LD_EXP 129
54227: PUSH
54228: LD_VAR 0 2
54232: ARRAY
54233: PUSH
54234: LD_INT 1
54236: ARRAY
54237: PPUSH
54238: CALL_OW 314
54242: NOT
54243: AND
54244: PUSH
54245: LD_EXP 129
54249: PUSH
54250: LD_VAR 0 2
54254: ARRAY
54255: PUSH
54256: LD_INT 1
54258: ARRAY
54259: PPUSH
54260: CALL_OW 310
54264: NOT
54265: AND
54266: IFFALSE 54292
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54268: LD_EXP 129
54272: PUSH
54273: LD_VAR 0 2
54277: ARRAY
54278: PUSH
54279: LD_INT 1
54281: ARRAY
54282: PPUSH
54283: LD_VAR 0 3
54287: PPUSH
54288: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54292: LD_EXP 129
54296: PUSH
54297: LD_VAR 0 2
54301: ARRAY
54302: PUSH
54303: LD_INT 1
54305: ARRAY
54306: PPUSH
54307: CALL_OW 310
54311: PUSH
54312: LD_EXP 129
54316: PUSH
54317: LD_VAR 0 2
54321: ARRAY
54322: PUSH
54323: LD_INT 1
54325: ARRAY
54326: PPUSH
54327: CALL_OW 310
54331: PPUSH
54332: CALL_OW 461
54336: PUSH
54337: LD_INT 3
54339: NONEQUAL
54340: AND
54341: IFFALSE 54362
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54343: LD_EXP 129
54347: PUSH
54348: LD_VAR 0 2
54352: ARRAY
54353: PUSH
54354: LD_INT 1
54356: ARRAY
54357: PPUSH
54358: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54362: LD_VAR 0 3
54366: PPUSH
54367: CALL_OW 461
54371: PUSH
54372: LD_INT 6
54374: EQUAL
54375: PUSH
54376: LD_VAR 0 6
54380: PUSH
54381: LD_INT 1
54383: GREATER
54384: AND
54385: IFFALSE 54537
// begin sci := [ ] ;
54387: LD_ADDR_VAR 0 8
54391: PUSH
54392: EMPTY
54393: ST_TO_ADDR
// for x in ( tmp diff j ) do
54394: LD_ADDR_VAR 0 7
54398: PUSH
54399: LD_VAR 0 6
54403: PUSH
54404: LD_VAR 0 3
54408: DIFF
54409: PUSH
54410: FOR_IN
54411: IFFALSE 54463
// begin if sci = 6 then
54413: LD_VAR 0 8
54417: PUSH
54418: LD_INT 6
54420: EQUAL
54421: IFFALSE 54425
// break ;
54423: GO 54463
// if BuildingStatus ( x ) = bs_idle then
54425: LD_VAR 0 7
54429: PPUSH
54430: CALL_OW 461
54434: PUSH
54435: LD_INT 2
54437: EQUAL
54438: IFFALSE 54461
// sci := sci ^ UnitsInside ( x ) ;
54440: LD_ADDR_VAR 0 8
54444: PUSH
54445: LD_VAR 0 8
54449: PUSH
54450: LD_VAR 0 7
54454: PPUSH
54455: CALL_OW 313
54459: ADD
54460: ST_TO_ADDR
// end ;
54461: GO 54410
54463: POP
54464: POP
// if not sci then
54465: LD_VAR 0 8
54469: NOT
54470: IFFALSE 54474
// continue ;
54472: GO 53519
// for x in sci do
54474: LD_ADDR_VAR 0 7
54478: PUSH
54479: LD_VAR 0 8
54483: PUSH
54484: FOR_IN
54485: IFFALSE 54535
// if IsInUnit ( x ) and not HasTask ( x ) then
54487: LD_VAR 0 7
54491: PPUSH
54492: CALL_OW 310
54496: PUSH
54497: LD_VAR 0 7
54501: PPUSH
54502: CALL_OW 314
54506: NOT
54507: AND
54508: IFFALSE 54533
// begin ComExitBuilding ( x ) ;
54510: LD_VAR 0 7
54514: PPUSH
54515: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54519: LD_VAR 0 7
54523: PPUSH
54524: LD_VAR 0 3
54528: PPUSH
54529: CALL_OW 180
// end ;
54533: GO 54484
54535: POP
54536: POP
// end ; end ;
54537: GO 53519
54539: POP
54540: POP
// end ;
54541: GO 53473
54543: POP
54544: POP
// end ;
54545: LD_VAR 0 1
54549: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54550: LD_INT 0
54552: PPUSH
54553: PPUSH
// if not mc_bases then
54554: LD_EXP 99
54558: NOT
54559: IFFALSE 54563
// exit ;
54561: GO 54644
// for i = 1 to mc_bases do
54563: LD_ADDR_VAR 0 2
54567: PUSH
54568: DOUBLE
54569: LD_INT 1
54571: DEC
54572: ST_TO_ADDR
54573: LD_EXP 99
54577: PUSH
54578: FOR_TO
54579: IFFALSE 54642
// if mc_mines [ i ] and mc_miners [ i ] then
54581: LD_EXP 112
54585: PUSH
54586: LD_VAR 0 2
54590: ARRAY
54591: PUSH
54592: LD_EXP 113
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: AND
54603: IFFALSE 54640
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54605: LD_EXP 113
54609: PUSH
54610: LD_VAR 0 2
54614: ARRAY
54615: PUSH
54616: LD_INT 1
54618: ARRAY
54619: PPUSH
54620: CALL_OW 255
54624: PPUSH
54625: LD_EXP 112
54629: PUSH
54630: LD_VAR 0 2
54634: ARRAY
54635: PPUSH
54636: CALL 69268 0 2
54640: GO 54578
54642: POP
54643: POP
// end ;
54644: LD_VAR 0 1
54648: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54649: LD_INT 0
54651: PPUSH
54652: PPUSH
54653: PPUSH
54654: PPUSH
54655: PPUSH
54656: PPUSH
54657: PPUSH
54658: PPUSH
// if not mc_bases or not mc_parking then
54659: LD_EXP 99
54663: NOT
54664: PUSH
54665: LD_EXP 123
54669: NOT
54670: OR
54671: IFFALSE 54675
// exit ;
54673: GO 55413
// for i = 1 to mc_bases do
54675: LD_ADDR_VAR 0 2
54679: PUSH
54680: DOUBLE
54681: LD_INT 1
54683: DEC
54684: ST_TO_ADDR
54685: LD_EXP 99
54689: PUSH
54690: FOR_TO
54691: IFFALSE 55411
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54693: LD_EXP 99
54697: PUSH
54698: LD_VAR 0 2
54702: ARRAY
54703: NOT
54704: PUSH
54705: LD_EXP 123
54709: PUSH
54710: LD_VAR 0 2
54714: ARRAY
54715: NOT
54716: OR
54717: IFFALSE 54721
// continue ;
54719: GO 54690
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54721: LD_ADDR_VAR 0 5
54725: PUSH
54726: LD_EXP 99
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PUSH
54737: LD_INT 1
54739: ARRAY
54740: PPUSH
54741: CALL_OW 255
54745: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54746: LD_ADDR_VAR 0 6
54750: PUSH
54751: LD_EXP 99
54755: PUSH
54756: LD_VAR 0 2
54760: ARRAY
54761: PPUSH
54762: LD_INT 30
54764: PUSH
54765: LD_INT 3
54767: PUSH
54768: EMPTY
54769: LIST
54770: LIST
54771: PPUSH
54772: CALL_OW 72
54776: ST_TO_ADDR
// if not fac then
54777: LD_VAR 0 6
54781: NOT
54782: IFFALSE 54833
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54784: LD_ADDR_VAR 0 6
54788: PUSH
54789: LD_EXP 99
54793: PUSH
54794: LD_VAR 0 2
54798: ARRAY
54799: PPUSH
54800: LD_INT 2
54802: PUSH
54803: LD_INT 30
54805: PUSH
54806: LD_INT 0
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: PUSH
54813: LD_INT 30
54815: PUSH
54816: LD_INT 1
54818: PUSH
54819: EMPTY
54820: LIST
54821: LIST
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: PPUSH
54828: CALL_OW 72
54832: ST_TO_ADDR
// if not fac then
54833: LD_VAR 0 6
54837: NOT
54838: IFFALSE 54842
// continue ;
54840: GO 54690
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54842: LD_ADDR_VAR 0 7
54846: PUSH
54847: LD_EXP 123
54851: PUSH
54852: LD_VAR 0 2
54856: ARRAY
54857: PPUSH
54858: LD_INT 22
54860: PUSH
54861: LD_VAR 0 5
54865: PUSH
54866: EMPTY
54867: LIST
54868: LIST
54869: PUSH
54870: LD_INT 21
54872: PUSH
54873: LD_INT 2
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PUSH
54880: LD_INT 3
54882: PUSH
54883: LD_INT 60
54885: PUSH
54886: EMPTY
54887: LIST
54888: PUSH
54889: EMPTY
54890: LIST
54891: LIST
54892: PUSH
54893: LD_INT 3
54895: PUSH
54896: LD_INT 24
54898: PUSH
54899: LD_INT 1000
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PUSH
54910: EMPTY
54911: LIST
54912: LIST
54913: LIST
54914: LIST
54915: PPUSH
54916: CALL_OW 70
54920: ST_TO_ADDR
// for j in fac do
54921: LD_ADDR_VAR 0 3
54925: PUSH
54926: LD_VAR 0 6
54930: PUSH
54931: FOR_IN
54932: IFFALSE 55027
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54934: LD_ADDR_VAR 0 7
54938: PUSH
54939: LD_VAR 0 7
54943: PUSH
54944: LD_INT 22
54946: PUSH
54947: LD_VAR 0 5
54951: PUSH
54952: EMPTY
54953: LIST
54954: LIST
54955: PUSH
54956: LD_INT 91
54958: PUSH
54959: LD_VAR 0 3
54963: PUSH
54964: LD_INT 15
54966: PUSH
54967: EMPTY
54968: LIST
54969: LIST
54970: LIST
54971: PUSH
54972: LD_INT 21
54974: PUSH
54975: LD_INT 2
54977: PUSH
54978: EMPTY
54979: LIST
54980: LIST
54981: PUSH
54982: LD_INT 3
54984: PUSH
54985: LD_INT 60
54987: PUSH
54988: EMPTY
54989: LIST
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: PUSH
54995: LD_INT 3
54997: PUSH
54998: LD_INT 24
55000: PUSH
55001: LD_INT 1000
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: PUSH
55008: EMPTY
55009: LIST
55010: LIST
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: LIST
55016: LIST
55017: LIST
55018: PPUSH
55019: CALL_OW 69
55023: UNION
55024: ST_TO_ADDR
55025: GO 54931
55027: POP
55028: POP
// if not vehs then
55029: LD_VAR 0 7
55033: NOT
55034: IFFALSE 55060
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55036: LD_ADDR_EXP 111
55040: PUSH
55041: LD_EXP 111
55045: PPUSH
55046: LD_VAR 0 2
55050: PPUSH
55051: EMPTY
55052: PPUSH
55053: CALL_OW 1
55057: ST_TO_ADDR
// continue ;
55058: GO 54690
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55060: LD_ADDR_VAR 0 8
55064: PUSH
55065: LD_EXP 99
55069: PUSH
55070: LD_VAR 0 2
55074: ARRAY
55075: PPUSH
55076: LD_INT 30
55078: PUSH
55079: LD_INT 3
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: PPUSH
55086: CALL_OW 72
55090: ST_TO_ADDR
// if tmp then
55091: LD_VAR 0 8
55095: IFFALSE 55198
// begin for j in tmp do
55097: LD_ADDR_VAR 0 3
55101: PUSH
55102: LD_VAR 0 8
55106: PUSH
55107: FOR_IN
55108: IFFALSE 55196
// for k in UnitsInside ( j ) do
55110: LD_ADDR_VAR 0 4
55114: PUSH
55115: LD_VAR 0 3
55119: PPUSH
55120: CALL_OW 313
55124: PUSH
55125: FOR_IN
55126: IFFALSE 55192
// if k then
55128: LD_VAR 0 4
55132: IFFALSE 55190
// if not k in mc_repair_vehicle [ i ] then
55134: LD_VAR 0 4
55138: PUSH
55139: LD_EXP 111
55143: PUSH
55144: LD_VAR 0 2
55148: ARRAY
55149: IN
55150: NOT
55151: IFFALSE 55190
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55153: LD_ADDR_EXP 111
55157: PUSH
55158: LD_EXP 111
55162: PPUSH
55163: LD_VAR 0 2
55167: PPUSH
55168: LD_EXP 111
55172: PUSH
55173: LD_VAR 0 2
55177: ARRAY
55178: PUSH
55179: LD_VAR 0 4
55183: UNION
55184: PPUSH
55185: CALL_OW 1
55189: ST_TO_ADDR
55190: GO 55125
55192: POP
55193: POP
55194: GO 55107
55196: POP
55197: POP
// end ; if not mc_repair_vehicle [ i ] then
55198: LD_EXP 111
55202: PUSH
55203: LD_VAR 0 2
55207: ARRAY
55208: NOT
55209: IFFALSE 55213
// continue ;
55211: GO 54690
// for j in mc_repair_vehicle [ i ] do
55213: LD_ADDR_VAR 0 3
55217: PUSH
55218: LD_EXP 111
55222: PUSH
55223: LD_VAR 0 2
55227: ARRAY
55228: PUSH
55229: FOR_IN
55230: IFFALSE 55407
// begin if GetClass ( j ) <> 3 then
55232: LD_VAR 0 3
55236: PPUSH
55237: CALL_OW 257
55241: PUSH
55242: LD_INT 3
55244: NONEQUAL
55245: IFFALSE 55286
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55247: LD_ADDR_EXP 111
55251: PUSH
55252: LD_EXP 111
55256: PPUSH
55257: LD_VAR 0 2
55261: PPUSH
55262: LD_EXP 111
55266: PUSH
55267: LD_VAR 0 2
55271: ARRAY
55272: PUSH
55273: LD_VAR 0 3
55277: DIFF
55278: PPUSH
55279: CALL_OW 1
55283: ST_TO_ADDR
// continue ;
55284: GO 55229
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55286: LD_VAR 0 3
55290: PPUSH
55291: CALL_OW 311
55295: NOT
55296: PUSH
55297: LD_VAR 0 3
55301: PUSH
55302: LD_EXP 102
55306: PUSH
55307: LD_VAR 0 2
55311: ARRAY
55312: PUSH
55313: LD_INT 1
55315: ARRAY
55316: IN
55317: NOT
55318: AND
55319: PUSH
55320: LD_VAR 0 3
55324: PUSH
55325: LD_EXP 102
55329: PUSH
55330: LD_VAR 0 2
55334: ARRAY
55335: PUSH
55336: LD_INT 2
55338: ARRAY
55339: IN
55340: NOT
55341: AND
55342: IFFALSE 55405
// begin if IsInUnit ( j ) then
55344: LD_VAR 0 3
55348: PPUSH
55349: CALL_OW 310
55353: IFFALSE 55366
// ComExitBuilding ( j ) else
55355: LD_VAR 0 3
55359: PPUSH
55360: CALL_OW 122
55364: GO 55405
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55366: LD_VAR 0 3
55370: PPUSH
55371: LD_VAR 0 7
55375: PUSH
55376: LD_INT 1
55378: ARRAY
55379: PPUSH
55380: CALL 106843 0 2
55384: NOT
55385: IFFALSE 55405
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55387: LD_VAR 0 3
55391: PPUSH
55392: LD_VAR 0 7
55396: PUSH
55397: LD_INT 1
55399: ARRAY
55400: PPUSH
55401: CALL_OW 129
// end ; end ;
55405: GO 55229
55407: POP
55408: POP
// end ;
55409: GO 54690
55411: POP
55412: POP
// end ;
55413: LD_VAR 0 1
55417: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55418: LD_INT 0
55420: PPUSH
55421: PPUSH
55422: PPUSH
55423: PPUSH
55424: PPUSH
55425: PPUSH
55426: PPUSH
55427: PPUSH
55428: PPUSH
55429: PPUSH
55430: PPUSH
// if not mc_bases then
55431: LD_EXP 99
55435: NOT
55436: IFFALSE 55440
// exit ;
55438: GO 56242
// for i = 1 to mc_bases do
55440: LD_ADDR_VAR 0 2
55444: PUSH
55445: DOUBLE
55446: LD_INT 1
55448: DEC
55449: ST_TO_ADDR
55450: LD_EXP 99
55454: PUSH
55455: FOR_TO
55456: IFFALSE 56240
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55458: LD_EXP 127
55462: PUSH
55463: LD_VAR 0 2
55467: ARRAY
55468: NOT
55469: PUSH
55470: LD_EXP 102
55474: PUSH
55475: LD_VAR 0 2
55479: ARRAY
55480: PUSH
55481: LD_INT 1
55483: ARRAY
55484: OR
55485: PUSH
55486: LD_EXP 102
55490: PUSH
55491: LD_VAR 0 2
55495: ARRAY
55496: PUSH
55497: LD_INT 2
55499: ARRAY
55500: OR
55501: PUSH
55502: LD_EXP 125
55506: PUSH
55507: LD_VAR 0 2
55511: ARRAY
55512: PPUSH
55513: LD_INT 1
55515: PPUSH
55516: CALL_OW 325
55520: NOT
55521: OR
55522: PUSH
55523: LD_EXP 122
55527: PUSH
55528: LD_VAR 0 2
55532: ARRAY
55533: OR
55534: IFFALSE 55538
// continue ;
55536: GO 55455
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55538: LD_ADDR_VAR 0 8
55542: PUSH
55543: LD_EXP 99
55547: PUSH
55548: LD_VAR 0 2
55552: ARRAY
55553: PPUSH
55554: LD_INT 25
55556: PUSH
55557: LD_INT 4
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: LD_INT 50
55566: PUSH
55567: EMPTY
55568: LIST
55569: PUSH
55570: LD_INT 3
55572: PUSH
55573: LD_INT 60
55575: PUSH
55576: EMPTY
55577: LIST
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PUSH
55583: EMPTY
55584: LIST
55585: LIST
55586: LIST
55587: PPUSH
55588: CALL_OW 72
55592: PUSH
55593: LD_EXP 103
55597: PUSH
55598: LD_VAR 0 2
55602: ARRAY
55603: DIFF
55604: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55605: LD_ADDR_VAR 0 9
55609: PUSH
55610: LD_EXP 99
55614: PUSH
55615: LD_VAR 0 2
55619: ARRAY
55620: PPUSH
55621: LD_INT 2
55623: PUSH
55624: LD_INT 30
55626: PUSH
55627: LD_INT 0
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: PUSH
55634: LD_INT 30
55636: PUSH
55637: LD_INT 1
55639: PUSH
55640: EMPTY
55641: LIST
55642: LIST
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL_OW 72
55653: ST_TO_ADDR
// if not tmp or not dep then
55654: LD_VAR 0 8
55658: NOT
55659: PUSH
55660: LD_VAR 0 9
55664: NOT
55665: OR
55666: IFFALSE 55670
// continue ;
55668: GO 55455
// side := GetSide ( tmp [ 1 ] ) ;
55670: LD_ADDR_VAR 0 11
55674: PUSH
55675: LD_VAR 0 8
55679: PUSH
55680: LD_INT 1
55682: ARRAY
55683: PPUSH
55684: CALL_OW 255
55688: ST_TO_ADDR
// dep := dep [ 1 ] ;
55689: LD_ADDR_VAR 0 9
55693: PUSH
55694: LD_VAR 0 9
55698: PUSH
55699: LD_INT 1
55701: ARRAY
55702: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55703: LD_ADDR_VAR 0 7
55707: PUSH
55708: LD_EXP 127
55712: PUSH
55713: LD_VAR 0 2
55717: ARRAY
55718: PPUSH
55719: LD_INT 22
55721: PUSH
55722: LD_INT 0
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PUSH
55729: LD_INT 25
55731: PUSH
55732: LD_INT 12
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: PUSH
55739: EMPTY
55740: LIST
55741: LIST
55742: PPUSH
55743: CALL_OW 70
55747: PUSH
55748: LD_INT 22
55750: PUSH
55751: LD_INT 0
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: LD_INT 25
55760: PUSH
55761: LD_INT 12
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: PUSH
55768: LD_INT 91
55770: PUSH
55771: LD_VAR 0 9
55775: PUSH
55776: LD_INT 20
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: LIST
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: LIST
55788: PPUSH
55789: CALL_OW 69
55793: UNION
55794: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55795: LD_ADDR_VAR 0 10
55799: PUSH
55800: LD_EXP 127
55804: PUSH
55805: LD_VAR 0 2
55809: ARRAY
55810: PPUSH
55811: LD_INT 81
55813: PUSH
55814: LD_VAR 0 11
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PPUSH
55823: CALL_OW 70
55827: ST_TO_ADDR
// if not apes or danger_at_area then
55828: LD_VAR 0 7
55832: NOT
55833: PUSH
55834: LD_VAR 0 10
55838: OR
55839: IFFALSE 55889
// begin if mc_taming [ i ] then
55841: LD_EXP 130
55845: PUSH
55846: LD_VAR 0 2
55850: ARRAY
55851: IFFALSE 55887
// begin MC_Reset ( i , 121 ) ;
55853: LD_VAR 0 2
55857: PPUSH
55858: LD_INT 121
55860: PPUSH
55861: CALL 40826 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55865: LD_ADDR_EXP 130
55869: PUSH
55870: LD_EXP 130
55874: PPUSH
55875: LD_VAR 0 2
55879: PPUSH
55880: EMPTY
55881: PPUSH
55882: CALL_OW 1
55886: ST_TO_ADDR
// end ; continue ;
55887: GO 55455
// end ; for j in tmp do
55889: LD_ADDR_VAR 0 3
55893: PUSH
55894: LD_VAR 0 8
55898: PUSH
55899: FOR_IN
55900: IFFALSE 56236
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
55902: LD_VAR 0 3
55906: PUSH
55907: LD_EXP 130
55911: PUSH
55912: LD_VAR 0 2
55916: ARRAY
55917: IN
55918: NOT
55919: PUSH
55920: LD_EXP 130
55924: PUSH
55925: LD_VAR 0 2
55929: ARRAY
55930: PUSH
55931: LD_INT 3
55933: LESS
55934: AND
55935: IFFALSE 55993
// begin SetTag ( j , 121 ) ;
55937: LD_VAR 0 3
55941: PPUSH
55942: LD_INT 121
55944: PPUSH
55945: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
55949: LD_ADDR_EXP 130
55953: PUSH
55954: LD_EXP 130
55958: PPUSH
55959: LD_VAR 0 2
55963: PUSH
55964: LD_EXP 130
55968: PUSH
55969: LD_VAR 0 2
55973: ARRAY
55974: PUSH
55975: LD_INT 1
55977: PLUS
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: PPUSH
55983: LD_VAR 0 3
55987: PPUSH
55988: CALL 72466 0 3
55992: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
55993: LD_VAR 0 3
55997: PUSH
55998: LD_EXP 130
56002: PUSH
56003: LD_VAR 0 2
56007: ARRAY
56008: IN
56009: IFFALSE 56234
// begin if GetClass ( j ) <> 4 then
56011: LD_VAR 0 3
56015: PPUSH
56016: CALL_OW 257
56020: PUSH
56021: LD_INT 4
56023: NONEQUAL
56024: IFFALSE 56077
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56026: LD_ADDR_EXP 130
56030: PUSH
56031: LD_EXP 130
56035: PPUSH
56036: LD_VAR 0 2
56040: PPUSH
56041: LD_EXP 130
56045: PUSH
56046: LD_VAR 0 2
56050: ARRAY
56051: PUSH
56052: LD_VAR 0 3
56056: DIFF
56057: PPUSH
56058: CALL_OW 1
56062: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56063: LD_VAR 0 3
56067: PPUSH
56068: LD_INT 0
56070: PPUSH
56071: CALL_OW 109
// continue ;
56075: GO 55899
// end ; if IsInUnit ( j ) then
56077: LD_VAR 0 3
56081: PPUSH
56082: CALL_OW 310
56086: IFFALSE 56097
// ComExitBuilding ( j ) ;
56088: LD_VAR 0 3
56092: PPUSH
56093: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56097: LD_ADDR_VAR 0 6
56101: PUSH
56102: LD_VAR 0 7
56106: PPUSH
56107: LD_VAR 0 3
56111: PPUSH
56112: CALL_OW 74
56116: ST_TO_ADDR
// if not ape then
56117: LD_VAR 0 6
56121: NOT
56122: IFFALSE 56126
// break ;
56124: GO 56236
// x := GetX ( ape ) ;
56126: LD_ADDR_VAR 0 4
56130: PUSH
56131: LD_VAR 0 6
56135: PPUSH
56136: CALL_OW 250
56140: ST_TO_ADDR
// y := GetY ( ape ) ;
56141: LD_ADDR_VAR 0 5
56145: PUSH
56146: LD_VAR 0 6
56150: PPUSH
56151: CALL_OW 251
56155: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56156: LD_VAR 0 4
56160: PPUSH
56161: LD_VAR 0 5
56165: PPUSH
56166: CALL_OW 488
56170: NOT
56171: PUSH
56172: LD_VAR 0 11
56176: PPUSH
56177: LD_VAR 0 4
56181: PPUSH
56182: LD_VAR 0 5
56186: PPUSH
56187: LD_INT 20
56189: PPUSH
56190: CALL 73362 0 4
56194: PUSH
56195: LD_INT 4
56197: ARRAY
56198: OR
56199: IFFALSE 56203
// break ;
56201: GO 56236
// if not HasTask ( j ) then
56203: LD_VAR 0 3
56207: PPUSH
56208: CALL_OW 314
56212: NOT
56213: IFFALSE 56234
// ComTameXY ( j , x , y ) ;
56215: LD_VAR 0 3
56219: PPUSH
56220: LD_VAR 0 4
56224: PPUSH
56225: LD_VAR 0 5
56229: PPUSH
56230: CALL_OW 131
// end ; end ;
56234: GO 55899
56236: POP
56237: POP
// end ;
56238: GO 55455
56240: POP
56241: POP
// end ;
56242: LD_VAR 0 1
56246: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56247: LD_INT 0
56249: PPUSH
56250: PPUSH
56251: PPUSH
56252: PPUSH
56253: PPUSH
56254: PPUSH
56255: PPUSH
56256: PPUSH
// if not mc_bases then
56257: LD_EXP 99
56261: NOT
56262: IFFALSE 56266
// exit ;
56264: GO 56892
// for i = 1 to mc_bases do
56266: LD_ADDR_VAR 0 2
56270: PUSH
56271: DOUBLE
56272: LD_INT 1
56274: DEC
56275: ST_TO_ADDR
56276: LD_EXP 99
56280: PUSH
56281: FOR_TO
56282: IFFALSE 56890
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56284: LD_EXP 128
56288: PUSH
56289: LD_VAR 0 2
56293: ARRAY
56294: NOT
56295: PUSH
56296: LD_EXP 128
56300: PUSH
56301: LD_VAR 0 2
56305: ARRAY
56306: PPUSH
56307: LD_INT 25
56309: PUSH
56310: LD_INT 12
56312: PUSH
56313: EMPTY
56314: LIST
56315: LIST
56316: PPUSH
56317: CALL_OW 72
56321: NOT
56322: OR
56323: IFFALSE 56327
// continue ;
56325: GO 56281
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56327: LD_ADDR_VAR 0 5
56331: PUSH
56332: LD_EXP 128
56336: PUSH
56337: LD_VAR 0 2
56341: ARRAY
56342: PUSH
56343: LD_INT 1
56345: ARRAY
56346: PPUSH
56347: CALL_OW 255
56351: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56352: LD_VAR 0 5
56356: PPUSH
56357: LD_INT 2
56359: PPUSH
56360: CALL_OW 325
56364: IFFALSE 56617
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56366: LD_ADDR_VAR 0 4
56370: PUSH
56371: LD_EXP 128
56375: PUSH
56376: LD_VAR 0 2
56380: ARRAY
56381: PPUSH
56382: LD_INT 25
56384: PUSH
56385: LD_INT 16
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: PPUSH
56392: CALL_OW 72
56396: ST_TO_ADDR
// if tmp < 6 then
56397: LD_VAR 0 4
56401: PUSH
56402: LD_INT 6
56404: LESS
56405: IFFALSE 56617
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56407: LD_ADDR_VAR 0 6
56411: PUSH
56412: LD_EXP 99
56416: PUSH
56417: LD_VAR 0 2
56421: ARRAY
56422: PPUSH
56423: LD_INT 2
56425: PUSH
56426: LD_INT 30
56428: PUSH
56429: LD_INT 0
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: PUSH
56436: LD_INT 30
56438: PUSH
56439: LD_INT 1
56441: PUSH
56442: EMPTY
56443: LIST
56444: LIST
56445: PUSH
56446: EMPTY
56447: LIST
56448: LIST
56449: LIST
56450: PPUSH
56451: CALL_OW 72
56455: ST_TO_ADDR
// if depot then
56456: LD_VAR 0 6
56460: IFFALSE 56617
// begin selected := 0 ;
56462: LD_ADDR_VAR 0 7
56466: PUSH
56467: LD_INT 0
56469: ST_TO_ADDR
// for j in depot do
56470: LD_ADDR_VAR 0 3
56474: PUSH
56475: LD_VAR 0 6
56479: PUSH
56480: FOR_IN
56481: IFFALSE 56512
// begin if UnitsInside ( j ) < 6 then
56483: LD_VAR 0 3
56487: PPUSH
56488: CALL_OW 313
56492: PUSH
56493: LD_INT 6
56495: LESS
56496: IFFALSE 56510
// begin selected := j ;
56498: LD_ADDR_VAR 0 7
56502: PUSH
56503: LD_VAR 0 3
56507: ST_TO_ADDR
// break ;
56508: GO 56512
// end ; end ;
56510: GO 56480
56512: POP
56513: POP
// if selected then
56514: LD_VAR 0 7
56518: IFFALSE 56617
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56520: LD_ADDR_VAR 0 3
56524: PUSH
56525: LD_EXP 128
56529: PUSH
56530: LD_VAR 0 2
56534: ARRAY
56535: PPUSH
56536: LD_INT 25
56538: PUSH
56539: LD_INT 12
56541: PUSH
56542: EMPTY
56543: LIST
56544: LIST
56545: PPUSH
56546: CALL_OW 72
56550: PUSH
56551: FOR_IN
56552: IFFALSE 56615
// if not HasTask ( j ) then
56554: LD_VAR 0 3
56558: PPUSH
56559: CALL_OW 314
56563: NOT
56564: IFFALSE 56613
// begin if not IsInUnit ( j ) then
56566: LD_VAR 0 3
56570: PPUSH
56571: CALL_OW 310
56575: NOT
56576: IFFALSE 56592
// ComEnterUnit ( j , selected ) ;
56578: LD_VAR 0 3
56582: PPUSH
56583: LD_VAR 0 7
56587: PPUSH
56588: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56592: LD_VAR 0 3
56596: PPUSH
56597: LD_INT 16
56599: PPUSH
56600: CALL_OW 183
// AddComExitBuilding ( j ) ;
56604: LD_VAR 0 3
56608: PPUSH
56609: CALL_OW 182
// end ;
56613: GO 56551
56615: POP
56616: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56617: LD_VAR 0 5
56621: PPUSH
56622: LD_INT 11
56624: PPUSH
56625: CALL_OW 325
56629: IFFALSE 56888
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56631: LD_ADDR_VAR 0 4
56635: PUSH
56636: LD_EXP 128
56640: PUSH
56641: LD_VAR 0 2
56645: ARRAY
56646: PPUSH
56647: LD_INT 25
56649: PUSH
56650: LD_INT 16
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: PPUSH
56657: CALL_OW 72
56661: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56662: LD_VAR 0 4
56666: PUSH
56667: LD_INT 6
56669: GREATEREQUAL
56670: PUSH
56671: LD_VAR 0 5
56675: PPUSH
56676: LD_INT 2
56678: PPUSH
56679: CALL_OW 325
56683: NOT
56684: OR
56685: IFFALSE 56888
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56687: LD_ADDR_VAR 0 8
56691: PUSH
56692: LD_EXP 99
56696: PUSH
56697: LD_VAR 0 2
56701: ARRAY
56702: PPUSH
56703: LD_INT 2
56705: PUSH
56706: LD_INT 30
56708: PUSH
56709: LD_INT 4
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PUSH
56716: LD_INT 30
56718: PUSH
56719: LD_INT 5
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: EMPTY
56727: LIST
56728: LIST
56729: LIST
56730: PPUSH
56731: CALL_OW 72
56735: ST_TO_ADDR
// if barracks then
56736: LD_VAR 0 8
56740: IFFALSE 56888
// begin selected := 0 ;
56742: LD_ADDR_VAR 0 7
56746: PUSH
56747: LD_INT 0
56749: ST_TO_ADDR
// for j in barracks do
56750: LD_ADDR_VAR 0 3
56754: PUSH
56755: LD_VAR 0 8
56759: PUSH
56760: FOR_IN
56761: IFFALSE 56792
// begin if UnitsInside ( j ) < 6 then
56763: LD_VAR 0 3
56767: PPUSH
56768: CALL_OW 313
56772: PUSH
56773: LD_INT 6
56775: LESS
56776: IFFALSE 56790
// begin selected := j ;
56778: LD_ADDR_VAR 0 7
56782: PUSH
56783: LD_VAR 0 3
56787: ST_TO_ADDR
// break ;
56788: GO 56792
// end ; end ;
56790: GO 56760
56792: POP
56793: POP
// if selected then
56794: LD_VAR 0 7
56798: IFFALSE 56888
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56800: LD_ADDR_VAR 0 3
56804: PUSH
56805: LD_EXP 128
56809: PUSH
56810: LD_VAR 0 2
56814: ARRAY
56815: PPUSH
56816: LD_INT 25
56818: PUSH
56819: LD_INT 12
56821: PUSH
56822: EMPTY
56823: LIST
56824: LIST
56825: PPUSH
56826: CALL_OW 72
56830: PUSH
56831: FOR_IN
56832: IFFALSE 56886
// if not IsInUnit ( j ) and not HasTask ( j ) then
56834: LD_VAR 0 3
56838: PPUSH
56839: CALL_OW 310
56843: NOT
56844: PUSH
56845: LD_VAR 0 3
56849: PPUSH
56850: CALL_OW 314
56854: NOT
56855: AND
56856: IFFALSE 56884
// begin ComEnterUnit ( j , selected ) ;
56858: LD_VAR 0 3
56862: PPUSH
56863: LD_VAR 0 7
56867: PPUSH
56868: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
56872: LD_VAR 0 3
56876: PPUSH
56877: LD_INT 15
56879: PPUSH
56880: CALL_OW 183
// end ;
56884: GO 56831
56886: POP
56887: POP
// end ; end ; end ; end ; end ;
56888: GO 56281
56890: POP
56891: POP
// end ;
56892: LD_VAR 0 1
56896: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
56897: LD_INT 0
56899: PPUSH
56900: PPUSH
56901: PPUSH
56902: PPUSH
// if not mc_bases then
56903: LD_EXP 99
56907: NOT
56908: IFFALSE 56912
// exit ;
56910: GO 57090
// for i = 1 to mc_bases do
56912: LD_ADDR_VAR 0 2
56916: PUSH
56917: DOUBLE
56918: LD_INT 1
56920: DEC
56921: ST_TO_ADDR
56922: LD_EXP 99
56926: PUSH
56927: FOR_TO
56928: IFFALSE 57088
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
56930: LD_ADDR_VAR 0 4
56934: PUSH
56935: LD_EXP 99
56939: PUSH
56940: LD_VAR 0 2
56944: ARRAY
56945: PPUSH
56946: LD_INT 25
56948: PUSH
56949: LD_INT 9
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: PPUSH
56956: CALL_OW 72
56960: ST_TO_ADDR
// if not tmp then
56961: LD_VAR 0 4
56965: NOT
56966: IFFALSE 56970
// continue ;
56968: GO 56927
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
56970: LD_EXP 125
56974: PUSH
56975: LD_VAR 0 2
56979: ARRAY
56980: PPUSH
56981: LD_INT 29
56983: PPUSH
56984: CALL_OW 325
56988: NOT
56989: PUSH
56990: LD_EXP 125
56994: PUSH
56995: LD_VAR 0 2
56999: ARRAY
57000: PPUSH
57001: LD_INT 28
57003: PPUSH
57004: CALL_OW 325
57008: NOT
57009: AND
57010: IFFALSE 57014
// continue ;
57012: GO 56927
// for j in tmp do
57014: LD_ADDR_VAR 0 3
57018: PUSH
57019: LD_VAR 0 4
57023: PUSH
57024: FOR_IN
57025: IFFALSE 57084
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57027: LD_VAR 0 3
57031: PUSH
57032: LD_EXP 102
57036: PUSH
57037: LD_VAR 0 2
57041: ARRAY
57042: PUSH
57043: LD_INT 1
57045: ARRAY
57046: IN
57047: NOT
57048: PUSH
57049: LD_VAR 0 3
57053: PUSH
57054: LD_EXP 102
57058: PUSH
57059: LD_VAR 0 2
57063: ARRAY
57064: PUSH
57065: LD_INT 2
57067: ARRAY
57068: IN
57069: NOT
57070: AND
57071: IFFALSE 57082
// ComSpaceTimeShoot ( j ) ;
57073: LD_VAR 0 3
57077: PPUSH
57078: CALL 68276 0 1
57082: GO 57024
57084: POP
57085: POP
// end ;
57086: GO 56927
57088: POP
57089: POP
// end ;
57090: LD_VAR 0 1
57094: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57095: LD_INT 0
57097: PPUSH
57098: PPUSH
57099: PPUSH
57100: PPUSH
57101: PPUSH
57102: PPUSH
57103: PPUSH
57104: PPUSH
57105: PPUSH
// if not mc_bases then
57106: LD_EXP 99
57110: NOT
57111: IFFALSE 57115
// exit ;
57113: GO 57737
// for i = 1 to mc_bases do
57115: LD_ADDR_VAR 0 2
57119: PUSH
57120: DOUBLE
57121: LD_INT 1
57123: DEC
57124: ST_TO_ADDR
57125: LD_EXP 99
57129: PUSH
57130: FOR_TO
57131: IFFALSE 57735
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57133: LD_EXP 134
57137: PUSH
57138: LD_VAR 0 2
57142: ARRAY
57143: NOT
57144: PUSH
57145: LD_INT 38
57147: PPUSH
57148: LD_EXP 125
57152: PUSH
57153: LD_VAR 0 2
57157: ARRAY
57158: PPUSH
57159: CALL_OW 321
57163: PUSH
57164: LD_INT 2
57166: NONEQUAL
57167: OR
57168: IFFALSE 57172
// continue ;
57170: GO 57130
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57172: LD_ADDR_VAR 0 8
57176: PUSH
57177: LD_EXP 99
57181: PUSH
57182: LD_VAR 0 2
57186: ARRAY
57187: PPUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 34
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PPUSH
57198: CALL_OW 72
57202: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57203: LD_ADDR_VAR 0 9
57207: PUSH
57208: LD_EXP 99
57212: PUSH
57213: LD_VAR 0 2
57217: ARRAY
57218: PPUSH
57219: LD_INT 25
57221: PUSH
57222: LD_INT 4
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: PPUSH
57229: CALL_OW 72
57233: PPUSH
57234: LD_INT 0
57236: PPUSH
57237: CALL 102352 0 2
57241: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57242: LD_VAR 0 9
57246: NOT
57247: PUSH
57248: LD_VAR 0 8
57252: NOT
57253: OR
57254: PUSH
57255: LD_EXP 99
57259: PUSH
57260: LD_VAR 0 2
57264: ARRAY
57265: PPUSH
57266: LD_INT 124
57268: PPUSH
57269: CALL 102352 0 2
57273: OR
57274: IFFALSE 57278
// continue ;
57276: GO 57130
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57278: LD_EXP 135
57282: PUSH
57283: LD_VAR 0 2
57287: ARRAY
57288: PUSH
57289: LD_EXP 134
57293: PUSH
57294: LD_VAR 0 2
57298: ARRAY
57299: LESS
57300: PUSH
57301: LD_EXP 135
57305: PUSH
57306: LD_VAR 0 2
57310: ARRAY
57311: PUSH
57312: LD_VAR 0 8
57316: LESS
57317: AND
57318: IFFALSE 57733
// begin tmp := sci [ 1 ] ;
57320: LD_ADDR_VAR 0 7
57324: PUSH
57325: LD_VAR 0 9
57329: PUSH
57330: LD_INT 1
57332: ARRAY
57333: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57334: LD_VAR 0 7
57338: PPUSH
57339: LD_INT 124
57341: PPUSH
57342: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57346: LD_ADDR_VAR 0 3
57350: PUSH
57351: DOUBLE
57352: LD_EXP 134
57356: PUSH
57357: LD_VAR 0 2
57361: ARRAY
57362: INC
57363: ST_TO_ADDR
57364: LD_EXP 134
57368: PUSH
57369: LD_VAR 0 2
57373: ARRAY
57374: PUSH
57375: FOR_DOWNTO
57376: IFFALSE 57719
// begin if IsInUnit ( tmp ) then
57378: LD_VAR 0 7
57382: PPUSH
57383: CALL_OW 310
57387: IFFALSE 57398
// ComExitBuilding ( tmp ) ;
57389: LD_VAR 0 7
57393: PPUSH
57394: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57398: LD_INT 35
57400: PPUSH
57401: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57405: LD_VAR 0 7
57409: PPUSH
57410: CALL_OW 310
57414: NOT
57415: PUSH
57416: LD_VAR 0 7
57420: PPUSH
57421: CALL_OW 314
57425: NOT
57426: AND
57427: IFFALSE 57398
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57429: LD_ADDR_VAR 0 6
57433: PUSH
57434: LD_VAR 0 7
57438: PPUSH
57439: CALL_OW 250
57443: PUSH
57444: LD_VAR 0 7
57448: PPUSH
57449: CALL_OW 251
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57458: LD_INT 35
57460: PPUSH
57461: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57465: LD_ADDR_VAR 0 4
57469: PUSH
57470: LD_EXP 134
57474: PUSH
57475: LD_VAR 0 2
57479: ARRAY
57480: PUSH
57481: LD_VAR 0 3
57485: ARRAY
57486: PUSH
57487: LD_INT 1
57489: ARRAY
57490: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57491: LD_ADDR_VAR 0 5
57495: PUSH
57496: LD_EXP 134
57500: PUSH
57501: LD_VAR 0 2
57505: ARRAY
57506: PUSH
57507: LD_VAR 0 3
57511: ARRAY
57512: PUSH
57513: LD_INT 2
57515: ARRAY
57516: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57517: LD_VAR 0 7
57521: PPUSH
57522: LD_INT 10
57524: PPUSH
57525: CALL 75063 0 2
57529: PUSH
57530: LD_INT 4
57532: ARRAY
57533: IFFALSE 57571
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57535: LD_VAR 0 7
57539: PPUSH
57540: LD_VAR 0 6
57544: PUSH
57545: LD_INT 1
57547: ARRAY
57548: PPUSH
57549: LD_VAR 0 6
57553: PUSH
57554: LD_INT 2
57556: ARRAY
57557: PPUSH
57558: CALL_OW 111
// wait ( 0 0$10 ) ;
57562: LD_INT 350
57564: PPUSH
57565: CALL_OW 67
// end else
57569: GO 57597
// begin ComMoveXY ( tmp , x , y ) ;
57571: LD_VAR 0 7
57575: PPUSH
57576: LD_VAR 0 4
57580: PPUSH
57581: LD_VAR 0 5
57585: PPUSH
57586: CALL_OW 111
// wait ( 0 0$3 ) ;
57590: LD_INT 105
57592: PPUSH
57593: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57597: LD_VAR 0 7
57601: PPUSH
57602: LD_VAR 0 4
57606: PPUSH
57607: LD_VAR 0 5
57611: PPUSH
57612: CALL_OW 307
57616: IFFALSE 57458
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57618: LD_VAR 0 7
57622: PPUSH
57623: LD_VAR 0 4
57627: PPUSH
57628: LD_VAR 0 5
57632: PPUSH
57633: LD_VAR 0 8
57637: PUSH
57638: LD_VAR 0 3
57642: ARRAY
57643: PPUSH
57644: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57648: LD_INT 35
57650: PPUSH
57651: CALL_OW 67
// until not HasTask ( tmp ) ;
57655: LD_VAR 0 7
57659: PPUSH
57660: CALL_OW 314
57664: NOT
57665: IFFALSE 57648
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57667: LD_ADDR_EXP 135
57671: PUSH
57672: LD_EXP 135
57676: PPUSH
57677: LD_VAR 0 2
57681: PUSH
57682: LD_EXP 135
57686: PUSH
57687: LD_VAR 0 2
57691: ARRAY
57692: PUSH
57693: LD_INT 1
57695: PLUS
57696: PUSH
57697: EMPTY
57698: LIST
57699: LIST
57700: PPUSH
57701: LD_VAR 0 8
57705: PUSH
57706: LD_VAR 0 3
57710: ARRAY
57711: PPUSH
57712: CALL 72466 0 3
57716: ST_TO_ADDR
// end ;
57717: GO 57375
57719: POP
57720: POP
// MC_Reset ( i , 124 ) ;
57721: LD_VAR 0 2
57725: PPUSH
57726: LD_INT 124
57728: PPUSH
57729: CALL 40826 0 2
// end ; end ;
57733: GO 57130
57735: POP
57736: POP
// end ;
57737: LD_VAR 0 1
57741: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57742: LD_INT 0
57744: PPUSH
57745: PPUSH
57746: PPUSH
// if not mc_bases then
57747: LD_EXP 99
57751: NOT
57752: IFFALSE 57756
// exit ;
57754: GO 58362
// for i = 1 to mc_bases do
57756: LD_ADDR_VAR 0 2
57760: PUSH
57761: DOUBLE
57762: LD_INT 1
57764: DEC
57765: ST_TO_ADDR
57766: LD_EXP 99
57770: PUSH
57771: FOR_TO
57772: IFFALSE 58360
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57774: LD_ADDR_VAR 0 3
57778: PUSH
57779: LD_EXP 99
57783: PUSH
57784: LD_VAR 0 2
57788: ARRAY
57789: PPUSH
57790: LD_INT 25
57792: PUSH
57793: LD_INT 4
57795: PUSH
57796: EMPTY
57797: LIST
57798: LIST
57799: PPUSH
57800: CALL_OW 72
57804: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57805: LD_VAR 0 3
57809: NOT
57810: PUSH
57811: LD_EXP 136
57815: PUSH
57816: LD_VAR 0 2
57820: ARRAY
57821: NOT
57822: OR
57823: PUSH
57824: LD_EXP 99
57828: PUSH
57829: LD_VAR 0 2
57833: ARRAY
57834: PPUSH
57835: LD_INT 2
57837: PUSH
57838: LD_INT 30
57840: PUSH
57841: LD_INT 0
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PUSH
57848: LD_INT 30
57850: PUSH
57851: LD_INT 1
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: LIST
57862: PPUSH
57863: CALL_OW 72
57867: NOT
57868: OR
57869: IFFALSE 57919
// begin if mc_deposits_finder [ i ] then
57871: LD_EXP 137
57875: PUSH
57876: LD_VAR 0 2
57880: ARRAY
57881: IFFALSE 57917
// begin MC_Reset ( i , 125 ) ;
57883: LD_VAR 0 2
57887: PPUSH
57888: LD_INT 125
57890: PPUSH
57891: CALL 40826 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57895: LD_ADDR_EXP 137
57899: PUSH
57900: LD_EXP 137
57904: PPUSH
57905: LD_VAR 0 2
57909: PPUSH
57910: EMPTY
57911: PPUSH
57912: CALL_OW 1
57916: ST_TO_ADDR
// end ; continue ;
57917: GO 57771
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
57919: LD_EXP 136
57923: PUSH
57924: LD_VAR 0 2
57928: ARRAY
57929: PUSH
57930: LD_INT 1
57932: ARRAY
57933: PUSH
57934: LD_INT 3
57936: ARRAY
57937: PUSH
57938: LD_INT 1
57940: EQUAL
57941: PUSH
57942: LD_INT 20
57944: PPUSH
57945: LD_EXP 125
57949: PUSH
57950: LD_VAR 0 2
57954: ARRAY
57955: PPUSH
57956: CALL_OW 321
57960: PUSH
57961: LD_INT 2
57963: NONEQUAL
57964: AND
57965: IFFALSE 58015
// begin if mc_deposits_finder [ i ] then
57967: LD_EXP 137
57971: PUSH
57972: LD_VAR 0 2
57976: ARRAY
57977: IFFALSE 58013
// begin MC_Reset ( i , 125 ) ;
57979: LD_VAR 0 2
57983: PPUSH
57984: LD_INT 125
57986: PPUSH
57987: CALL 40826 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57991: LD_ADDR_EXP 137
57995: PUSH
57996: LD_EXP 137
58000: PPUSH
58001: LD_VAR 0 2
58005: PPUSH
58006: EMPTY
58007: PPUSH
58008: CALL_OW 1
58012: ST_TO_ADDR
// end ; continue ;
58013: GO 57771
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58015: LD_EXP 136
58019: PUSH
58020: LD_VAR 0 2
58024: ARRAY
58025: PUSH
58026: LD_INT 1
58028: ARRAY
58029: PUSH
58030: LD_INT 1
58032: ARRAY
58033: PPUSH
58034: LD_EXP 136
58038: PUSH
58039: LD_VAR 0 2
58043: ARRAY
58044: PUSH
58045: LD_INT 1
58047: ARRAY
58048: PUSH
58049: LD_INT 2
58051: ARRAY
58052: PPUSH
58053: LD_EXP 125
58057: PUSH
58058: LD_VAR 0 2
58062: ARRAY
58063: PPUSH
58064: CALL_OW 440
58068: IFFALSE 58111
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58070: LD_ADDR_EXP 136
58074: PUSH
58075: LD_EXP 136
58079: PPUSH
58080: LD_VAR 0 2
58084: PPUSH
58085: LD_EXP 136
58089: PUSH
58090: LD_VAR 0 2
58094: ARRAY
58095: PPUSH
58096: LD_INT 1
58098: PPUSH
58099: CALL_OW 3
58103: PPUSH
58104: CALL_OW 1
58108: ST_TO_ADDR
58109: GO 58358
// begin if not mc_deposits_finder [ i ] then
58111: LD_EXP 137
58115: PUSH
58116: LD_VAR 0 2
58120: ARRAY
58121: NOT
58122: IFFALSE 58174
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58124: LD_ADDR_EXP 137
58128: PUSH
58129: LD_EXP 137
58133: PPUSH
58134: LD_VAR 0 2
58138: PPUSH
58139: LD_VAR 0 3
58143: PUSH
58144: LD_INT 1
58146: ARRAY
58147: PUSH
58148: EMPTY
58149: LIST
58150: PPUSH
58151: CALL_OW 1
58155: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58156: LD_VAR 0 3
58160: PUSH
58161: LD_INT 1
58163: ARRAY
58164: PPUSH
58165: LD_INT 125
58167: PPUSH
58168: CALL_OW 109
// end else
58172: GO 58358
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58174: LD_EXP 137
58178: PUSH
58179: LD_VAR 0 2
58183: ARRAY
58184: PUSH
58185: LD_INT 1
58187: ARRAY
58188: PPUSH
58189: CALL_OW 310
58193: IFFALSE 58216
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58195: LD_EXP 137
58199: PUSH
58200: LD_VAR 0 2
58204: ARRAY
58205: PUSH
58206: LD_INT 1
58208: ARRAY
58209: PPUSH
58210: CALL_OW 122
58214: GO 58358
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58216: LD_EXP 137
58220: PUSH
58221: LD_VAR 0 2
58225: ARRAY
58226: PUSH
58227: LD_INT 1
58229: ARRAY
58230: PPUSH
58231: CALL_OW 314
58235: NOT
58236: PUSH
58237: LD_EXP 137
58241: PUSH
58242: LD_VAR 0 2
58246: ARRAY
58247: PUSH
58248: LD_INT 1
58250: ARRAY
58251: PPUSH
58252: LD_EXP 136
58256: PUSH
58257: LD_VAR 0 2
58261: ARRAY
58262: PUSH
58263: LD_INT 1
58265: ARRAY
58266: PUSH
58267: LD_INT 1
58269: ARRAY
58270: PPUSH
58271: LD_EXP 136
58275: PUSH
58276: LD_VAR 0 2
58280: ARRAY
58281: PUSH
58282: LD_INT 1
58284: ARRAY
58285: PUSH
58286: LD_INT 2
58288: ARRAY
58289: PPUSH
58290: CALL_OW 297
58294: PUSH
58295: LD_INT 6
58297: GREATER
58298: AND
58299: IFFALSE 58358
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58301: LD_EXP 137
58305: PUSH
58306: LD_VAR 0 2
58310: ARRAY
58311: PUSH
58312: LD_INT 1
58314: ARRAY
58315: PPUSH
58316: LD_EXP 136
58320: PUSH
58321: LD_VAR 0 2
58325: ARRAY
58326: PUSH
58327: LD_INT 1
58329: ARRAY
58330: PUSH
58331: LD_INT 1
58333: ARRAY
58334: PPUSH
58335: LD_EXP 136
58339: PUSH
58340: LD_VAR 0 2
58344: ARRAY
58345: PUSH
58346: LD_INT 1
58348: ARRAY
58349: PUSH
58350: LD_INT 2
58352: ARRAY
58353: PPUSH
58354: CALL_OW 111
// end ; end ; end ;
58358: GO 57771
58360: POP
58361: POP
// end ;
58362: LD_VAR 0 1
58366: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58367: LD_INT 0
58369: PPUSH
58370: PPUSH
58371: PPUSH
58372: PPUSH
58373: PPUSH
58374: PPUSH
58375: PPUSH
58376: PPUSH
58377: PPUSH
58378: PPUSH
58379: PPUSH
// if not mc_bases then
58380: LD_EXP 99
58384: NOT
58385: IFFALSE 58389
// exit ;
58387: GO 59329
// for i = 1 to mc_bases do
58389: LD_ADDR_VAR 0 2
58393: PUSH
58394: DOUBLE
58395: LD_INT 1
58397: DEC
58398: ST_TO_ADDR
58399: LD_EXP 99
58403: PUSH
58404: FOR_TO
58405: IFFALSE 59327
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58407: LD_EXP 99
58411: PUSH
58412: LD_VAR 0 2
58416: ARRAY
58417: NOT
58418: PUSH
58419: LD_EXP 122
58423: PUSH
58424: LD_VAR 0 2
58428: ARRAY
58429: OR
58430: IFFALSE 58434
// continue ;
58432: GO 58404
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58434: LD_ADDR_VAR 0 7
58438: PUSH
58439: LD_EXP 99
58443: PUSH
58444: LD_VAR 0 2
58448: ARRAY
58449: PUSH
58450: LD_INT 1
58452: ARRAY
58453: PPUSH
58454: CALL_OW 248
58458: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58459: LD_VAR 0 7
58463: PUSH
58464: LD_INT 3
58466: EQUAL
58467: PUSH
58468: LD_EXP 118
58472: PUSH
58473: LD_VAR 0 2
58477: ARRAY
58478: PUSH
58479: LD_EXP 121
58483: PUSH
58484: LD_VAR 0 2
58488: ARRAY
58489: UNION
58490: PPUSH
58491: LD_INT 33
58493: PUSH
58494: LD_INT 2
58496: PUSH
58497: EMPTY
58498: LIST
58499: LIST
58500: PPUSH
58501: CALL_OW 72
58505: NOT
58506: OR
58507: IFFALSE 58511
// continue ;
58509: GO 58404
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58511: LD_ADDR_VAR 0 9
58515: PUSH
58516: LD_EXP 99
58520: PUSH
58521: LD_VAR 0 2
58525: ARRAY
58526: PPUSH
58527: LD_INT 30
58529: PUSH
58530: LD_INT 36
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: PPUSH
58537: CALL_OW 72
58541: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58542: LD_ADDR_VAR 0 10
58546: PUSH
58547: LD_EXP 118
58551: PUSH
58552: LD_VAR 0 2
58556: ARRAY
58557: PPUSH
58558: LD_INT 34
58560: PUSH
58561: LD_INT 31
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: PPUSH
58568: CALL_OW 72
58572: ST_TO_ADDR
// if not cts and not mcts then
58573: LD_VAR 0 9
58577: NOT
58578: PUSH
58579: LD_VAR 0 10
58583: NOT
58584: AND
58585: IFFALSE 58589
// continue ;
58587: GO 58404
// x := cts ;
58589: LD_ADDR_VAR 0 11
58593: PUSH
58594: LD_VAR 0 9
58598: ST_TO_ADDR
// if not x then
58599: LD_VAR 0 11
58603: NOT
58604: IFFALSE 58616
// x := mcts ;
58606: LD_ADDR_VAR 0 11
58610: PUSH
58611: LD_VAR 0 10
58615: ST_TO_ADDR
// if not x then
58616: LD_VAR 0 11
58620: NOT
58621: IFFALSE 58625
// continue ;
58623: GO 58404
// if mc_remote_driver [ i ] then
58625: LD_EXP 139
58629: PUSH
58630: LD_VAR 0 2
58634: ARRAY
58635: IFFALSE 59022
// for j in mc_remote_driver [ i ] do
58637: LD_ADDR_VAR 0 3
58641: PUSH
58642: LD_EXP 139
58646: PUSH
58647: LD_VAR 0 2
58651: ARRAY
58652: PUSH
58653: FOR_IN
58654: IFFALSE 59020
// begin if GetClass ( j ) <> 3 then
58656: LD_VAR 0 3
58660: PPUSH
58661: CALL_OW 257
58665: PUSH
58666: LD_INT 3
58668: NONEQUAL
58669: IFFALSE 58722
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58671: LD_ADDR_EXP 139
58675: PUSH
58676: LD_EXP 139
58680: PPUSH
58681: LD_VAR 0 2
58685: PPUSH
58686: LD_EXP 139
58690: PUSH
58691: LD_VAR 0 2
58695: ARRAY
58696: PUSH
58697: LD_VAR 0 3
58701: DIFF
58702: PPUSH
58703: CALL_OW 1
58707: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58708: LD_VAR 0 3
58712: PPUSH
58713: LD_INT 0
58715: PPUSH
58716: CALL_OW 109
// continue ;
58720: GO 58653
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58722: LD_EXP 118
58726: PUSH
58727: LD_VAR 0 2
58731: ARRAY
58732: PPUSH
58733: LD_INT 34
58735: PUSH
58736: LD_INT 31
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: PUSH
58743: LD_INT 58
58745: PUSH
58746: EMPTY
58747: LIST
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: PPUSH
58753: CALL_OW 72
58757: PUSH
58758: LD_VAR 0 3
58762: PPUSH
58763: CALL 102387 0 1
58767: NOT
58768: AND
58769: IFFALSE 58840
// begin if IsInUnit ( j ) then
58771: LD_VAR 0 3
58775: PPUSH
58776: CALL_OW 310
58780: IFFALSE 58791
// ComExitBuilding ( j ) ;
58782: LD_VAR 0 3
58786: PPUSH
58787: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58791: LD_VAR 0 3
58795: PPUSH
58796: LD_EXP 118
58800: PUSH
58801: LD_VAR 0 2
58805: ARRAY
58806: PPUSH
58807: LD_INT 34
58809: PUSH
58810: LD_INT 31
58812: PUSH
58813: EMPTY
58814: LIST
58815: LIST
58816: PUSH
58817: LD_INT 58
58819: PUSH
58820: EMPTY
58821: LIST
58822: PUSH
58823: EMPTY
58824: LIST
58825: LIST
58826: PPUSH
58827: CALL_OW 72
58831: PUSH
58832: LD_INT 1
58834: ARRAY
58835: PPUSH
58836: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
58840: LD_VAR 0 3
58844: PPUSH
58845: CALL_OW 310
58849: NOT
58850: PUSH
58851: LD_VAR 0 3
58855: PPUSH
58856: CALL_OW 310
58860: PPUSH
58861: CALL_OW 266
58865: PUSH
58866: LD_INT 36
58868: NONEQUAL
58869: PUSH
58870: LD_VAR 0 3
58874: PPUSH
58875: CALL 102387 0 1
58879: NOT
58880: AND
58881: OR
58882: IFFALSE 59018
// begin if IsInUnit ( j ) then
58884: LD_VAR 0 3
58888: PPUSH
58889: CALL_OW 310
58893: IFFALSE 58904
// ComExitBuilding ( j ) ;
58895: LD_VAR 0 3
58899: PPUSH
58900: CALL_OW 122
// ct := 0 ;
58904: LD_ADDR_VAR 0 8
58908: PUSH
58909: LD_INT 0
58911: ST_TO_ADDR
// for k in x do
58912: LD_ADDR_VAR 0 4
58916: PUSH
58917: LD_VAR 0 11
58921: PUSH
58922: FOR_IN
58923: IFFALSE 58996
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
58925: LD_VAR 0 4
58929: PPUSH
58930: CALL_OW 264
58934: PUSH
58935: LD_INT 31
58937: EQUAL
58938: PUSH
58939: LD_VAR 0 4
58943: PPUSH
58944: CALL_OW 311
58948: NOT
58949: AND
58950: PUSH
58951: LD_VAR 0 4
58955: PPUSH
58956: CALL_OW 266
58960: PUSH
58961: LD_INT 36
58963: EQUAL
58964: PUSH
58965: LD_VAR 0 4
58969: PPUSH
58970: CALL_OW 313
58974: PUSH
58975: LD_INT 3
58977: LESS
58978: AND
58979: OR
58980: IFFALSE 58994
// begin ct := k ;
58982: LD_ADDR_VAR 0 8
58986: PUSH
58987: LD_VAR 0 4
58991: ST_TO_ADDR
// break ;
58992: GO 58996
// end ;
58994: GO 58922
58996: POP
58997: POP
// if ct then
58998: LD_VAR 0 8
59002: IFFALSE 59018
// ComEnterUnit ( j , ct ) ;
59004: LD_VAR 0 3
59008: PPUSH
59009: LD_VAR 0 8
59013: PPUSH
59014: CALL_OW 120
// end ; end ;
59018: GO 58653
59020: POP
59021: POP
// places := 0 ;
59022: LD_ADDR_VAR 0 5
59026: PUSH
59027: LD_INT 0
59029: ST_TO_ADDR
// for j = 1 to x do
59030: LD_ADDR_VAR 0 3
59034: PUSH
59035: DOUBLE
59036: LD_INT 1
59038: DEC
59039: ST_TO_ADDR
59040: LD_VAR 0 11
59044: PUSH
59045: FOR_TO
59046: IFFALSE 59122
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59048: LD_VAR 0 11
59052: PUSH
59053: LD_VAR 0 3
59057: ARRAY
59058: PPUSH
59059: CALL_OW 264
59063: PUSH
59064: LD_INT 31
59066: EQUAL
59067: IFFALSE 59085
// places := places + 1 else
59069: LD_ADDR_VAR 0 5
59073: PUSH
59074: LD_VAR 0 5
59078: PUSH
59079: LD_INT 1
59081: PLUS
59082: ST_TO_ADDR
59083: GO 59120
// if GetBType ( x [ j ] ) = b_control_tower then
59085: LD_VAR 0 11
59089: PUSH
59090: LD_VAR 0 3
59094: ARRAY
59095: PPUSH
59096: CALL_OW 266
59100: PUSH
59101: LD_INT 36
59103: EQUAL
59104: IFFALSE 59120
// places := places + 3 ;
59106: LD_ADDR_VAR 0 5
59110: PUSH
59111: LD_VAR 0 5
59115: PUSH
59116: LD_INT 3
59118: PLUS
59119: ST_TO_ADDR
59120: GO 59045
59122: POP
59123: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59124: LD_VAR 0 5
59128: PUSH
59129: LD_INT 0
59131: EQUAL
59132: PUSH
59133: LD_VAR 0 5
59137: PUSH
59138: LD_EXP 139
59142: PUSH
59143: LD_VAR 0 2
59147: ARRAY
59148: LESSEQUAL
59149: OR
59150: IFFALSE 59154
// continue ;
59152: GO 58404
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59154: LD_ADDR_VAR 0 6
59158: PUSH
59159: LD_EXP 99
59163: PUSH
59164: LD_VAR 0 2
59168: ARRAY
59169: PPUSH
59170: LD_INT 25
59172: PUSH
59173: LD_INT 3
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: PPUSH
59180: CALL_OW 72
59184: PUSH
59185: LD_EXP 139
59189: PUSH
59190: LD_VAR 0 2
59194: ARRAY
59195: DIFF
59196: PPUSH
59197: LD_INT 3
59199: PPUSH
59200: CALL 103287 0 2
59204: ST_TO_ADDR
// for j in tmp do
59205: LD_ADDR_VAR 0 3
59209: PUSH
59210: LD_VAR 0 6
59214: PUSH
59215: FOR_IN
59216: IFFALSE 59251
// if GetTag ( j ) > 0 then
59218: LD_VAR 0 3
59222: PPUSH
59223: CALL_OW 110
59227: PUSH
59228: LD_INT 0
59230: GREATER
59231: IFFALSE 59249
// tmp := tmp diff j ;
59233: LD_ADDR_VAR 0 6
59237: PUSH
59238: LD_VAR 0 6
59242: PUSH
59243: LD_VAR 0 3
59247: DIFF
59248: ST_TO_ADDR
59249: GO 59215
59251: POP
59252: POP
// if not tmp then
59253: LD_VAR 0 6
59257: NOT
59258: IFFALSE 59262
// continue ;
59260: GO 58404
// if places then
59262: LD_VAR 0 5
59266: IFFALSE 59325
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59268: LD_ADDR_EXP 139
59272: PUSH
59273: LD_EXP 139
59277: PPUSH
59278: LD_VAR 0 2
59282: PPUSH
59283: LD_EXP 139
59287: PUSH
59288: LD_VAR 0 2
59292: ARRAY
59293: PUSH
59294: LD_VAR 0 6
59298: PUSH
59299: LD_INT 1
59301: ARRAY
59302: UNION
59303: PPUSH
59304: CALL_OW 1
59308: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59309: LD_VAR 0 6
59313: PUSH
59314: LD_INT 1
59316: ARRAY
59317: PPUSH
59318: LD_INT 126
59320: PPUSH
59321: CALL_OW 109
// end ; end ;
59325: GO 58404
59327: POP
59328: POP
// end ;
59329: LD_VAR 0 1
59333: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59334: LD_INT 0
59336: PPUSH
59337: PPUSH
59338: PPUSH
59339: PPUSH
59340: PPUSH
59341: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59342: LD_VAR 0 1
59346: NOT
59347: PUSH
59348: LD_VAR 0 2
59352: NOT
59353: OR
59354: PUSH
59355: LD_VAR 0 3
59359: NOT
59360: OR
59361: PUSH
59362: LD_VAR 0 4
59366: PUSH
59367: LD_INT 1
59369: PUSH
59370: LD_INT 2
59372: PUSH
59373: LD_INT 3
59375: PUSH
59376: LD_INT 4
59378: PUSH
59379: LD_INT 5
59381: PUSH
59382: LD_INT 8
59384: PUSH
59385: LD_INT 9
59387: PUSH
59388: LD_INT 15
59390: PUSH
59391: LD_INT 16
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: LIST
59398: LIST
59399: LIST
59400: LIST
59401: LIST
59402: LIST
59403: LIST
59404: IN
59405: NOT
59406: OR
59407: IFFALSE 59411
// exit ;
59409: GO 60311
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59411: LD_ADDR_VAR 0 2
59415: PUSH
59416: LD_VAR 0 2
59420: PPUSH
59421: LD_INT 21
59423: PUSH
59424: LD_INT 3
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PUSH
59431: LD_INT 24
59433: PUSH
59434: LD_INT 250
59436: PUSH
59437: EMPTY
59438: LIST
59439: LIST
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PPUSH
59445: CALL_OW 72
59449: ST_TO_ADDR
// case class of 1 , 15 :
59450: LD_VAR 0 4
59454: PUSH
59455: LD_INT 1
59457: DOUBLE
59458: EQUAL
59459: IFTRUE 59469
59461: LD_INT 15
59463: DOUBLE
59464: EQUAL
59465: IFTRUE 59469
59467: GO 59554
59469: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59470: LD_ADDR_VAR 0 8
59474: PUSH
59475: LD_VAR 0 2
59479: PPUSH
59480: LD_INT 2
59482: PUSH
59483: LD_INT 30
59485: PUSH
59486: LD_INT 32
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: PUSH
59493: LD_INT 30
59495: PUSH
59496: LD_INT 31
59498: PUSH
59499: EMPTY
59500: LIST
59501: LIST
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: LIST
59507: PPUSH
59508: CALL_OW 72
59512: PUSH
59513: LD_VAR 0 2
59517: PPUSH
59518: LD_INT 2
59520: PUSH
59521: LD_INT 30
59523: PUSH
59524: LD_INT 4
59526: PUSH
59527: EMPTY
59528: LIST
59529: LIST
59530: PUSH
59531: LD_INT 30
59533: PUSH
59534: LD_INT 5
59536: PUSH
59537: EMPTY
59538: LIST
59539: LIST
59540: PUSH
59541: EMPTY
59542: LIST
59543: LIST
59544: LIST
59545: PPUSH
59546: CALL_OW 72
59550: ADD
59551: ST_TO_ADDR
59552: GO 59800
59554: LD_INT 2
59556: DOUBLE
59557: EQUAL
59558: IFTRUE 59568
59560: LD_INT 16
59562: DOUBLE
59563: EQUAL
59564: IFTRUE 59568
59566: GO 59614
59568: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59569: LD_ADDR_VAR 0 8
59573: PUSH
59574: LD_VAR 0 2
59578: PPUSH
59579: LD_INT 2
59581: PUSH
59582: LD_INT 30
59584: PUSH
59585: LD_INT 0
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: LD_INT 30
59594: PUSH
59595: LD_INT 1
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: LIST
59606: PPUSH
59607: CALL_OW 72
59611: ST_TO_ADDR
59612: GO 59800
59614: LD_INT 3
59616: DOUBLE
59617: EQUAL
59618: IFTRUE 59622
59620: GO 59668
59622: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59623: LD_ADDR_VAR 0 8
59627: PUSH
59628: LD_VAR 0 2
59632: PPUSH
59633: LD_INT 2
59635: PUSH
59636: LD_INT 30
59638: PUSH
59639: LD_INT 2
59641: PUSH
59642: EMPTY
59643: LIST
59644: LIST
59645: PUSH
59646: LD_INT 30
59648: PUSH
59649: LD_INT 3
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: LIST
59660: PPUSH
59661: CALL_OW 72
59665: ST_TO_ADDR
59666: GO 59800
59668: LD_INT 4
59670: DOUBLE
59671: EQUAL
59672: IFTRUE 59676
59674: GO 59733
59676: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59677: LD_ADDR_VAR 0 8
59681: PUSH
59682: LD_VAR 0 2
59686: PPUSH
59687: LD_INT 2
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 6
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: LD_INT 30
59702: PUSH
59703: LD_INT 7
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PUSH
59710: LD_INT 30
59712: PUSH
59713: LD_INT 8
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: LIST
59724: LIST
59725: PPUSH
59726: CALL_OW 72
59730: ST_TO_ADDR
59731: GO 59800
59733: LD_INT 5
59735: DOUBLE
59736: EQUAL
59737: IFTRUE 59753
59739: LD_INT 8
59741: DOUBLE
59742: EQUAL
59743: IFTRUE 59753
59745: LD_INT 9
59747: DOUBLE
59748: EQUAL
59749: IFTRUE 59753
59751: GO 59799
59753: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59754: LD_ADDR_VAR 0 8
59758: PUSH
59759: LD_VAR 0 2
59763: PPUSH
59764: LD_INT 2
59766: PUSH
59767: LD_INT 30
59769: PUSH
59770: LD_INT 4
59772: PUSH
59773: EMPTY
59774: LIST
59775: LIST
59776: PUSH
59777: LD_INT 30
59779: PUSH
59780: LD_INT 5
59782: PUSH
59783: EMPTY
59784: LIST
59785: LIST
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: LIST
59791: PPUSH
59792: CALL_OW 72
59796: ST_TO_ADDR
59797: GO 59800
59799: POP
// if not tmp then
59800: LD_VAR 0 8
59804: NOT
59805: IFFALSE 59809
// exit ;
59807: GO 60311
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59809: LD_VAR 0 4
59813: PUSH
59814: LD_INT 1
59816: PUSH
59817: LD_INT 15
59819: PUSH
59820: EMPTY
59821: LIST
59822: LIST
59823: IN
59824: PUSH
59825: LD_EXP 108
59829: PUSH
59830: LD_VAR 0 1
59834: ARRAY
59835: AND
59836: IFFALSE 59992
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
59838: LD_ADDR_VAR 0 9
59842: PUSH
59843: LD_EXP 108
59847: PUSH
59848: LD_VAR 0 1
59852: ARRAY
59853: PUSH
59854: LD_INT 1
59856: ARRAY
59857: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
59858: LD_VAR 0 9
59862: PUSH
59863: LD_EXP 109
59867: PUSH
59868: LD_VAR 0 1
59872: ARRAY
59873: IN
59874: NOT
59875: IFFALSE 59990
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
59877: LD_ADDR_EXP 109
59881: PUSH
59882: LD_EXP 109
59886: PPUSH
59887: LD_VAR 0 1
59891: PUSH
59892: LD_EXP 109
59896: PUSH
59897: LD_VAR 0 1
59901: ARRAY
59902: PUSH
59903: LD_INT 1
59905: PLUS
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PPUSH
59911: LD_VAR 0 9
59915: PPUSH
59916: CALL 72466 0 3
59920: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
59921: LD_ADDR_EXP 108
59925: PUSH
59926: LD_EXP 108
59930: PPUSH
59931: LD_VAR 0 1
59935: PPUSH
59936: LD_EXP 108
59940: PUSH
59941: LD_VAR 0 1
59945: ARRAY
59946: PUSH
59947: LD_VAR 0 9
59951: DIFF
59952: PPUSH
59953: CALL_OW 1
59957: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
59958: LD_VAR 0 3
59962: PPUSH
59963: LD_EXP 109
59967: PUSH
59968: LD_VAR 0 1
59972: ARRAY
59973: PUSH
59974: LD_EXP 109
59978: PUSH
59979: LD_VAR 0 1
59983: ARRAY
59984: ARRAY
59985: PPUSH
59986: CALL_OW 120
// end ; exit ;
59990: GO 60311
// end ; if tmp > 1 then
59992: LD_VAR 0 8
59996: PUSH
59997: LD_INT 1
59999: GREATER
60000: IFFALSE 60104
// for i = 2 to tmp do
60002: LD_ADDR_VAR 0 6
60006: PUSH
60007: DOUBLE
60008: LD_INT 2
60010: DEC
60011: ST_TO_ADDR
60012: LD_VAR 0 8
60016: PUSH
60017: FOR_TO
60018: IFFALSE 60102
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60020: LD_VAR 0 8
60024: PUSH
60025: LD_VAR 0 6
60029: ARRAY
60030: PPUSH
60031: CALL_OW 461
60035: PUSH
60036: LD_INT 6
60038: EQUAL
60039: IFFALSE 60100
// begin x := tmp [ i ] ;
60041: LD_ADDR_VAR 0 9
60045: PUSH
60046: LD_VAR 0 8
60050: PUSH
60051: LD_VAR 0 6
60055: ARRAY
60056: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60057: LD_ADDR_VAR 0 8
60061: PUSH
60062: LD_VAR 0 8
60066: PPUSH
60067: LD_VAR 0 6
60071: PPUSH
60072: CALL_OW 3
60076: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60077: LD_ADDR_VAR 0 8
60081: PUSH
60082: LD_VAR 0 8
60086: PPUSH
60087: LD_INT 1
60089: PPUSH
60090: LD_VAR 0 9
60094: PPUSH
60095: CALL_OW 2
60099: ST_TO_ADDR
// end ;
60100: GO 60017
60102: POP
60103: POP
// for i in tmp do
60104: LD_ADDR_VAR 0 6
60108: PUSH
60109: LD_VAR 0 8
60113: PUSH
60114: FOR_IN
60115: IFFALSE 60184
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60117: LD_VAR 0 6
60121: PPUSH
60122: CALL_OW 313
60126: PUSH
60127: LD_INT 6
60129: LESS
60130: PUSH
60131: LD_VAR 0 6
60135: PPUSH
60136: CALL_OW 266
60140: PUSH
60141: LD_INT 31
60143: PUSH
60144: LD_INT 32
60146: PUSH
60147: EMPTY
60148: LIST
60149: LIST
60150: IN
60151: NOT
60152: AND
60153: PUSH
60154: LD_VAR 0 6
60158: PPUSH
60159: CALL_OW 313
60163: PUSH
60164: LD_INT 0
60166: EQUAL
60167: OR
60168: IFFALSE 60182
// begin j := i ;
60170: LD_ADDR_VAR 0 7
60174: PUSH
60175: LD_VAR 0 6
60179: ST_TO_ADDR
// break ;
60180: GO 60184
// end ; end ;
60182: GO 60114
60184: POP
60185: POP
// if j then
60186: LD_VAR 0 7
60190: IFFALSE 60208
// ComEnterUnit ( unit , j ) else
60192: LD_VAR 0 3
60196: PPUSH
60197: LD_VAR 0 7
60201: PPUSH
60202: CALL_OW 120
60206: GO 60311
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60208: LD_ADDR_VAR 0 10
60212: PUSH
60213: LD_VAR 0 2
60217: PPUSH
60218: LD_INT 2
60220: PUSH
60221: LD_INT 30
60223: PUSH
60224: LD_INT 0
60226: PUSH
60227: EMPTY
60228: LIST
60229: LIST
60230: PUSH
60231: LD_INT 30
60233: PUSH
60234: LD_INT 1
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: LIST
60245: PPUSH
60246: CALL_OW 72
60250: ST_TO_ADDR
// if depot then
60251: LD_VAR 0 10
60255: IFFALSE 60311
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60257: LD_ADDR_VAR 0 10
60261: PUSH
60262: LD_VAR 0 10
60266: PPUSH
60267: LD_VAR 0 3
60271: PPUSH
60272: CALL_OW 74
60276: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60277: LD_VAR 0 3
60281: PPUSH
60282: LD_VAR 0 10
60286: PPUSH
60287: CALL_OW 296
60291: PUSH
60292: LD_INT 10
60294: GREATER
60295: IFFALSE 60311
// ComStandNearbyBuilding ( unit , depot ) ;
60297: LD_VAR 0 3
60301: PPUSH
60302: LD_VAR 0 10
60306: PPUSH
60307: CALL 68893 0 2
// end ; end ; end ;
60311: LD_VAR 0 5
60315: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60316: LD_INT 0
60318: PPUSH
60319: PPUSH
60320: PPUSH
60321: PPUSH
// if not mc_bases then
60322: LD_EXP 99
60326: NOT
60327: IFFALSE 60331
// exit ;
60329: GO 60570
// for i = 1 to mc_bases do
60331: LD_ADDR_VAR 0 2
60335: PUSH
60336: DOUBLE
60337: LD_INT 1
60339: DEC
60340: ST_TO_ADDR
60341: LD_EXP 99
60345: PUSH
60346: FOR_TO
60347: IFFALSE 60568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60349: LD_ADDR_VAR 0 4
60353: PUSH
60354: LD_EXP 99
60358: PUSH
60359: LD_VAR 0 2
60363: ARRAY
60364: PPUSH
60365: LD_INT 21
60367: PUSH
60368: LD_INT 1
60370: PUSH
60371: EMPTY
60372: LIST
60373: LIST
60374: PPUSH
60375: CALL_OW 72
60379: PUSH
60380: LD_EXP 128
60384: PUSH
60385: LD_VAR 0 2
60389: ARRAY
60390: UNION
60391: ST_TO_ADDR
// if not tmp then
60392: LD_VAR 0 4
60396: NOT
60397: IFFALSE 60401
// continue ;
60399: GO 60346
// for j in tmp do
60401: LD_ADDR_VAR 0 3
60405: PUSH
60406: LD_VAR 0 4
60410: PUSH
60411: FOR_IN
60412: IFFALSE 60564
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60414: LD_VAR 0 3
60418: PPUSH
60419: CALL_OW 110
60423: NOT
60424: PUSH
60425: LD_VAR 0 3
60429: PPUSH
60430: CALL_OW 314
60434: NOT
60435: AND
60436: PUSH
60437: LD_VAR 0 3
60441: PPUSH
60442: CALL_OW 311
60446: NOT
60447: AND
60448: PUSH
60449: LD_VAR 0 3
60453: PPUSH
60454: CALL_OW 310
60458: NOT
60459: AND
60460: PUSH
60461: LD_VAR 0 3
60465: PUSH
60466: LD_EXP 102
60470: PUSH
60471: LD_VAR 0 2
60475: ARRAY
60476: PUSH
60477: LD_INT 1
60479: ARRAY
60480: IN
60481: NOT
60482: AND
60483: PUSH
60484: LD_VAR 0 3
60488: PUSH
60489: LD_EXP 102
60493: PUSH
60494: LD_VAR 0 2
60498: ARRAY
60499: PUSH
60500: LD_INT 2
60502: ARRAY
60503: IN
60504: NOT
60505: AND
60506: PUSH
60507: LD_VAR 0 3
60511: PUSH
60512: LD_EXP 111
60516: PUSH
60517: LD_VAR 0 2
60521: ARRAY
60522: IN
60523: NOT
60524: AND
60525: IFFALSE 60562
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60527: LD_VAR 0 2
60531: PPUSH
60532: LD_EXP 99
60536: PUSH
60537: LD_VAR 0 2
60541: ARRAY
60542: PPUSH
60543: LD_VAR 0 3
60547: PPUSH
60548: LD_VAR 0 3
60552: PPUSH
60553: CALL_OW 257
60557: PPUSH
60558: CALL 59334 0 4
// end ;
60562: GO 60411
60564: POP
60565: POP
// end ;
60566: GO 60346
60568: POP
60569: POP
// end ;
60570: LD_VAR 0 1
60574: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60575: LD_INT 0
60577: PPUSH
60578: PPUSH
60579: PPUSH
60580: PPUSH
60581: PPUSH
60582: PPUSH
// if not mc_bases [ base ] then
60583: LD_EXP 99
60587: PUSH
60588: LD_VAR 0 1
60592: ARRAY
60593: NOT
60594: IFFALSE 60598
// exit ;
60596: GO 60780
// tmp := [ ] ;
60598: LD_ADDR_VAR 0 6
60602: PUSH
60603: EMPTY
60604: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60605: LD_ADDR_VAR 0 7
60609: PUSH
60610: LD_VAR 0 3
60614: PPUSH
60615: LD_INT 0
60617: PPUSH
60618: CALL_OW 517
60622: ST_TO_ADDR
// if not list then
60623: LD_VAR 0 7
60627: NOT
60628: IFFALSE 60632
// exit ;
60630: GO 60780
// for i = 1 to amount do
60632: LD_ADDR_VAR 0 5
60636: PUSH
60637: DOUBLE
60638: LD_INT 1
60640: DEC
60641: ST_TO_ADDR
60642: LD_VAR 0 2
60646: PUSH
60647: FOR_TO
60648: IFFALSE 60728
// begin x := rand ( 1 , list [ 1 ] ) ;
60650: LD_ADDR_VAR 0 8
60654: PUSH
60655: LD_INT 1
60657: PPUSH
60658: LD_VAR 0 7
60662: PUSH
60663: LD_INT 1
60665: ARRAY
60666: PPUSH
60667: CALL_OW 12
60671: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60672: LD_ADDR_VAR 0 6
60676: PUSH
60677: LD_VAR 0 6
60681: PPUSH
60682: LD_VAR 0 5
60686: PPUSH
60687: LD_VAR 0 7
60691: PUSH
60692: LD_INT 1
60694: ARRAY
60695: PUSH
60696: LD_VAR 0 8
60700: ARRAY
60701: PUSH
60702: LD_VAR 0 7
60706: PUSH
60707: LD_INT 2
60709: ARRAY
60710: PUSH
60711: LD_VAR 0 8
60715: ARRAY
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: PPUSH
60721: CALL_OW 1
60725: ST_TO_ADDR
// end ;
60726: GO 60647
60728: POP
60729: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60730: LD_ADDR_EXP 112
60734: PUSH
60735: LD_EXP 112
60739: PPUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: LD_VAR 0 6
60749: PPUSH
60750: CALL_OW 1
60754: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60755: LD_ADDR_EXP 114
60759: PUSH
60760: LD_EXP 114
60764: PPUSH
60765: LD_VAR 0 1
60769: PPUSH
60770: LD_VAR 0 3
60774: PPUSH
60775: CALL_OW 1
60779: ST_TO_ADDR
// end ;
60780: LD_VAR 0 4
60784: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60785: LD_INT 0
60787: PPUSH
// if not mc_bases [ base ] then
60788: LD_EXP 99
60792: PUSH
60793: LD_VAR 0 1
60797: ARRAY
60798: NOT
60799: IFFALSE 60803
// exit ;
60801: GO 60828
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60803: LD_ADDR_EXP 104
60807: PUSH
60808: LD_EXP 104
60812: PPUSH
60813: LD_VAR 0 1
60817: PPUSH
60818: LD_VAR 0 2
60822: PPUSH
60823: CALL_OW 1
60827: ST_TO_ADDR
// end ;
60828: LD_VAR 0 3
60832: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
60833: LD_INT 0
60835: PPUSH
// if not mc_bases [ base ] then
60836: LD_EXP 99
60840: PUSH
60841: LD_VAR 0 1
60845: ARRAY
60846: NOT
60847: IFFALSE 60851
// exit ;
60849: GO 60888
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
60851: LD_ADDR_EXP 104
60855: PUSH
60856: LD_EXP 104
60860: PPUSH
60861: LD_VAR 0 1
60865: PPUSH
60866: LD_EXP 104
60870: PUSH
60871: LD_VAR 0 1
60875: ARRAY
60876: PUSH
60877: LD_VAR 0 2
60881: UNION
60882: PPUSH
60883: CALL_OW 1
60887: ST_TO_ADDR
// end ;
60888: LD_VAR 0 3
60892: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
60893: LD_INT 0
60895: PPUSH
// if not mc_bases [ base ] then
60896: LD_EXP 99
60900: PUSH
60901: LD_VAR 0 1
60905: ARRAY
60906: NOT
60907: IFFALSE 60911
// exit ;
60909: GO 60936
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
60911: LD_ADDR_EXP 120
60915: PUSH
60916: LD_EXP 120
60920: PPUSH
60921: LD_VAR 0 1
60925: PPUSH
60926: LD_VAR 0 2
60930: PPUSH
60931: CALL_OW 1
60935: ST_TO_ADDR
// end ;
60936: LD_VAR 0 3
60940: RET
// export function MC_InsertProduceList ( base , components ) ; begin
60941: LD_INT 0
60943: PPUSH
// if not mc_bases [ base ] then
60944: LD_EXP 99
60948: PUSH
60949: LD_VAR 0 1
60953: ARRAY
60954: NOT
60955: IFFALSE 60959
// exit ;
60957: GO 60996
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
60959: LD_ADDR_EXP 120
60963: PUSH
60964: LD_EXP 120
60968: PPUSH
60969: LD_VAR 0 1
60973: PPUSH
60974: LD_EXP 120
60978: PUSH
60979: LD_VAR 0 1
60983: ARRAY
60984: PUSH
60985: LD_VAR 0 2
60989: ADD
60990: PPUSH
60991: CALL_OW 1
60995: ST_TO_ADDR
// end ;
60996: LD_VAR 0 3
61000: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61001: LD_INT 0
61003: PPUSH
// if not mc_bases [ base ] then
61004: LD_EXP 99
61008: PUSH
61009: LD_VAR 0 1
61013: ARRAY
61014: NOT
61015: IFFALSE 61019
// exit ;
61017: GO 61073
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61019: LD_ADDR_EXP 121
61023: PUSH
61024: LD_EXP 121
61028: PPUSH
61029: LD_VAR 0 1
61033: PPUSH
61034: LD_VAR 0 2
61038: PPUSH
61039: CALL_OW 1
61043: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61044: LD_ADDR_EXP 110
61048: PUSH
61049: LD_EXP 110
61053: PPUSH
61054: LD_VAR 0 1
61058: PPUSH
61059: LD_VAR 0 2
61063: PUSH
61064: LD_INT 0
61066: PLUS
61067: PPUSH
61068: CALL_OW 1
61072: ST_TO_ADDR
// end ;
61073: LD_VAR 0 3
61077: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61078: LD_INT 0
61080: PPUSH
// if not mc_bases [ base ] then
61081: LD_EXP 99
61085: PUSH
61086: LD_VAR 0 1
61090: ARRAY
61091: NOT
61092: IFFALSE 61096
// exit ;
61094: GO 61121
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61096: LD_ADDR_EXP 110
61100: PUSH
61101: LD_EXP 110
61105: PPUSH
61106: LD_VAR 0 1
61110: PPUSH
61111: LD_VAR 0 2
61115: PPUSH
61116: CALL_OW 1
61120: ST_TO_ADDR
// end ;
61121: LD_VAR 0 3
61125: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61126: LD_INT 0
61128: PPUSH
61129: PPUSH
61130: PPUSH
61131: PPUSH
// if not mc_bases [ base ] then
61132: LD_EXP 99
61136: PUSH
61137: LD_VAR 0 1
61141: ARRAY
61142: NOT
61143: IFFALSE 61147
// exit ;
61145: GO 61212
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61147: LD_ADDR_EXP 119
61151: PUSH
61152: LD_EXP 119
61156: PPUSH
61157: LD_VAR 0 1
61161: PUSH
61162: LD_EXP 119
61166: PUSH
61167: LD_VAR 0 1
61171: ARRAY
61172: PUSH
61173: LD_INT 1
61175: PLUS
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PPUSH
61181: LD_VAR 0 1
61185: PUSH
61186: LD_VAR 0 2
61190: PUSH
61191: LD_VAR 0 3
61195: PUSH
61196: LD_VAR 0 4
61200: PUSH
61201: EMPTY
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: PPUSH
61207: CALL 72466 0 3
61211: ST_TO_ADDR
// end ;
61212: LD_VAR 0 5
61216: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61217: LD_INT 0
61219: PPUSH
// if not mc_bases [ base ] then
61220: LD_EXP 99
61224: PUSH
61225: LD_VAR 0 1
61229: ARRAY
61230: NOT
61231: IFFALSE 61235
// exit ;
61233: GO 61260
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61235: LD_ADDR_EXP 136
61239: PUSH
61240: LD_EXP 136
61244: PPUSH
61245: LD_VAR 0 1
61249: PPUSH
61250: LD_VAR 0 2
61254: PPUSH
61255: CALL_OW 1
61259: ST_TO_ADDR
// end ;
61260: LD_VAR 0 3
61264: RET
// export function MC_GetMinesField ( base ) ; begin
61265: LD_INT 0
61267: PPUSH
// result := mc_mines [ base ] ;
61268: LD_ADDR_VAR 0 2
61272: PUSH
61273: LD_EXP 112
61277: PUSH
61278: LD_VAR 0 1
61282: ARRAY
61283: ST_TO_ADDR
// end ;
61284: LD_VAR 0 2
61288: RET
// export function MC_GetProduceList ( base ) ; begin
61289: LD_INT 0
61291: PPUSH
// result := mc_produce [ base ] ;
61292: LD_ADDR_VAR 0 2
61296: PUSH
61297: LD_EXP 120
61301: PUSH
61302: LD_VAR 0 1
61306: ARRAY
61307: ST_TO_ADDR
// end ;
61308: LD_VAR 0 2
61312: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61313: LD_INT 0
61315: PPUSH
61316: PPUSH
// if not mc_bases then
61317: LD_EXP 99
61321: NOT
61322: IFFALSE 61326
// exit ;
61324: GO 61391
// if mc_bases [ base ] then
61326: LD_EXP 99
61330: PUSH
61331: LD_VAR 0 1
61335: ARRAY
61336: IFFALSE 61391
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61338: LD_ADDR_VAR 0 3
61342: PUSH
61343: LD_EXP 99
61347: PUSH
61348: LD_VAR 0 1
61352: ARRAY
61353: PPUSH
61354: LD_INT 30
61356: PUSH
61357: LD_VAR 0 2
61361: PUSH
61362: EMPTY
61363: LIST
61364: LIST
61365: PPUSH
61366: CALL_OW 72
61370: ST_TO_ADDR
// if result then
61371: LD_VAR 0 3
61375: IFFALSE 61391
// result := result [ 1 ] ;
61377: LD_ADDR_VAR 0 3
61381: PUSH
61382: LD_VAR 0 3
61386: PUSH
61387: LD_INT 1
61389: ARRAY
61390: ST_TO_ADDR
// end ; end ;
61391: LD_VAR 0 3
61395: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61396: LD_INT 0
61398: PPUSH
61399: PPUSH
// if not mc_bases then
61400: LD_EXP 99
61404: NOT
61405: IFFALSE 61409
// exit ;
61407: GO 61454
// if mc_bases [ base ] then
61409: LD_EXP 99
61413: PUSH
61414: LD_VAR 0 1
61418: ARRAY
61419: IFFALSE 61454
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61421: LD_ADDR_VAR 0 3
61425: PUSH
61426: LD_EXP 99
61430: PUSH
61431: LD_VAR 0 1
61435: ARRAY
61436: PPUSH
61437: LD_INT 30
61439: PUSH
61440: LD_VAR 0 2
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PPUSH
61449: CALL_OW 72
61453: ST_TO_ADDR
// end ;
61454: LD_VAR 0 3
61458: RET
// export function MC_SetTame ( base , area ) ; begin
61459: LD_INT 0
61461: PPUSH
// if not mc_bases or not base then
61462: LD_EXP 99
61466: NOT
61467: PUSH
61468: LD_VAR 0 1
61472: NOT
61473: OR
61474: IFFALSE 61478
// exit ;
61476: GO 61503
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61478: LD_ADDR_EXP 127
61482: PUSH
61483: LD_EXP 127
61487: PPUSH
61488: LD_VAR 0 1
61492: PPUSH
61493: LD_VAR 0 2
61497: PPUSH
61498: CALL_OW 1
61502: ST_TO_ADDR
// end ;
61503: LD_VAR 0 3
61507: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61508: LD_INT 0
61510: PPUSH
61511: PPUSH
// if not mc_bases or not base then
61512: LD_EXP 99
61516: NOT
61517: PUSH
61518: LD_VAR 0 1
61522: NOT
61523: OR
61524: IFFALSE 61528
// exit ;
61526: GO 61630
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61528: LD_ADDR_VAR 0 4
61532: PUSH
61533: LD_EXP 99
61537: PUSH
61538: LD_VAR 0 1
61542: ARRAY
61543: PPUSH
61544: LD_INT 30
61546: PUSH
61547: LD_VAR 0 2
61551: PUSH
61552: EMPTY
61553: LIST
61554: LIST
61555: PPUSH
61556: CALL_OW 72
61560: ST_TO_ADDR
// if not tmp then
61561: LD_VAR 0 4
61565: NOT
61566: IFFALSE 61570
// exit ;
61568: GO 61630
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61570: LD_ADDR_EXP 131
61574: PUSH
61575: LD_EXP 131
61579: PPUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: LD_EXP 131
61589: PUSH
61590: LD_VAR 0 1
61594: ARRAY
61595: PPUSH
61596: LD_EXP 131
61600: PUSH
61601: LD_VAR 0 1
61605: ARRAY
61606: PUSH
61607: LD_INT 1
61609: PLUS
61610: PPUSH
61611: LD_VAR 0 4
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: CALL_OW 2
61624: PPUSH
61625: CALL_OW 1
61629: ST_TO_ADDR
// end ;
61630: LD_VAR 0 3
61634: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61635: LD_INT 0
61637: PPUSH
61638: PPUSH
// if not mc_bases or not base or not kinds then
61639: LD_EXP 99
61643: NOT
61644: PUSH
61645: LD_VAR 0 1
61649: NOT
61650: OR
61651: PUSH
61652: LD_VAR 0 2
61656: NOT
61657: OR
61658: IFFALSE 61662
// exit ;
61660: GO 61723
// for i in kinds do
61662: LD_ADDR_VAR 0 4
61666: PUSH
61667: LD_VAR 0 2
61671: PUSH
61672: FOR_IN
61673: IFFALSE 61721
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61675: LD_ADDR_EXP 133
61679: PUSH
61680: LD_EXP 133
61684: PPUSH
61685: LD_VAR 0 1
61689: PUSH
61690: LD_EXP 133
61694: PUSH
61695: LD_VAR 0 1
61699: ARRAY
61700: PUSH
61701: LD_INT 1
61703: PLUS
61704: PUSH
61705: EMPTY
61706: LIST
61707: LIST
61708: PPUSH
61709: LD_VAR 0 4
61713: PPUSH
61714: CALL 72466 0 3
61718: ST_TO_ADDR
61719: GO 61672
61721: POP
61722: POP
// end ;
61723: LD_VAR 0 3
61727: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61728: LD_INT 0
61730: PPUSH
// if not mc_bases or not base or not areas then
61731: LD_EXP 99
61735: NOT
61736: PUSH
61737: LD_VAR 0 1
61741: NOT
61742: OR
61743: PUSH
61744: LD_VAR 0 2
61748: NOT
61749: OR
61750: IFFALSE 61754
// exit ;
61752: GO 61779
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61754: LD_ADDR_EXP 117
61758: PUSH
61759: LD_EXP 117
61763: PPUSH
61764: LD_VAR 0 1
61768: PPUSH
61769: LD_VAR 0 2
61773: PPUSH
61774: CALL_OW 1
61778: ST_TO_ADDR
// end ;
61779: LD_VAR 0 3
61783: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61784: LD_INT 0
61786: PPUSH
// if not mc_bases or not base or not teleports_exit then
61787: LD_EXP 99
61791: NOT
61792: PUSH
61793: LD_VAR 0 1
61797: NOT
61798: OR
61799: PUSH
61800: LD_VAR 0 2
61804: NOT
61805: OR
61806: IFFALSE 61810
// exit ;
61808: GO 61835
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61810: LD_ADDR_EXP 134
61814: PUSH
61815: LD_EXP 134
61819: PPUSH
61820: LD_VAR 0 1
61824: PPUSH
61825: LD_VAR 0 2
61829: PPUSH
61830: CALL_OW 1
61834: ST_TO_ADDR
// end ;
61835: LD_VAR 0 3
61839: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
61840: LD_INT 0
61842: PPUSH
61843: PPUSH
61844: PPUSH
// if not mc_bases or not base or not ext_list then
61845: LD_EXP 99
61849: NOT
61850: PUSH
61851: LD_VAR 0 1
61855: NOT
61856: OR
61857: PUSH
61858: LD_VAR 0 5
61862: NOT
61863: OR
61864: IFFALSE 61868
// exit ;
61866: GO 62041
// tmp := GetFacExtXYD ( x , y , d ) ;
61868: LD_ADDR_VAR 0 8
61872: PUSH
61873: LD_VAR 0 2
61877: PPUSH
61878: LD_VAR 0 3
61882: PPUSH
61883: LD_VAR 0 4
61887: PPUSH
61888: CALL 102417 0 3
61892: ST_TO_ADDR
// if not tmp then
61893: LD_VAR 0 8
61897: NOT
61898: IFFALSE 61902
// exit ;
61900: GO 62041
// for i in tmp do
61902: LD_ADDR_VAR 0 7
61906: PUSH
61907: LD_VAR 0 8
61911: PUSH
61912: FOR_IN
61913: IFFALSE 62039
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
61915: LD_ADDR_EXP 104
61919: PUSH
61920: LD_EXP 104
61924: PPUSH
61925: LD_VAR 0 1
61929: PPUSH
61930: LD_EXP 104
61934: PUSH
61935: LD_VAR 0 1
61939: ARRAY
61940: PPUSH
61941: LD_EXP 104
61945: PUSH
61946: LD_VAR 0 1
61950: ARRAY
61951: PUSH
61952: LD_INT 1
61954: PLUS
61955: PPUSH
61956: LD_VAR 0 5
61960: PUSH
61961: LD_INT 1
61963: ARRAY
61964: PUSH
61965: LD_VAR 0 7
61969: PUSH
61970: LD_INT 1
61972: ARRAY
61973: PUSH
61974: LD_VAR 0 7
61978: PUSH
61979: LD_INT 2
61981: ARRAY
61982: PUSH
61983: LD_VAR 0 7
61987: PUSH
61988: LD_INT 3
61990: ARRAY
61991: PUSH
61992: EMPTY
61993: LIST
61994: LIST
61995: LIST
61996: LIST
61997: PPUSH
61998: CALL_OW 2
62002: PPUSH
62003: CALL_OW 1
62007: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62008: LD_ADDR_VAR 0 5
62012: PUSH
62013: LD_VAR 0 5
62017: PPUSH
62018: LD_INT 1
62020: PPUSH
62021: CALL_OW 3
62025: ST_TO_ADDR
// if not ext_list then
62026: LD_VAR 0 5
62030: NOT
62031: IFFALSE 62037
// exit ;
62033: POP
62034: POP
62035: GO 62041
// end ;
62037: GO 61912
62039: POP
62040: POP
// end ;
62041: LD_VAR 0 6
62045: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62046: LD_INT 0
62048: PPUSH
// if not mc_bases or not base or not weapon_list then
62049: LD_EXP 99
62053: NOT
62054: PUSH
62055: LD_VAR 0 1
62059: NOT
62060: OR
62061: PUSH
62062: LD_VAR 0 2
62066: NOT
62067: OR
62068: IFFALSE 62072
// exit ;
62070: GO 62097
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62072: LD_ADDR_EXP 138
62076: PUSH
62077: LD_EXP 138
62081: PPUSH
62082: LD_VAR 0 1
62086: PPUSH
62087: LD_VAR 0 2
62091: PPUSH
62092: CALL_OW 1
62096: ST_TO_ADDR
// end ;
62097: LD_VAR 0 3
62101: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62102: LD_INT 0
62104: PPUSH
// if not mc_bases or not base or not tech_list then
62105: LD_EXP 99
62109: NOT
62110: PUSH
62111: LD_VAR 0 1
62115: NOT
62116: OR
62117: PUSH
62118: LD_VAR 0 2
62122: NOT
62123: OR
62124: IFFALSE 62128
// exit ;
62126: GO 62153
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62128: LD_ADDR_EXP 126
62132: PUSH
62133: LD_EXP 126
62137: PPUSH
62138: LD_VAR 0 1
62142: PPUSH
62143: LD_VAR 0 2
62147: PPUSH
62148: CALL_OW 1
62152: ST_TO_ADDR
// end ;
62153: LD_VAR 0 3
62157: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62158: LD_INT 0
62160: PPUSH
// if not mc_bases or not parking_area or not base then
62161: LD_EXP 99
62165: NOT
62166: PUSH
62167: LD_VAR 0 2
62171: NOT
62172: OR
62173: PUSH
62174: LD_VAR 0 1
62178: NOT
62179: OR
62180: IFFALSE 62184
// exit ;
62182: GO 62209
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62184: LD_ADDR_EXP 123
62188: PUSH
62189: LD_EXP 123
62193: PPUSH
62194: LD_VAR 0 1
62198: PPUSH
62199: LD_VAR 0 2
62203: PPUSH
62204: CALL_OW 1
62208: ST_TO_ADDR
// end ;
62209: LD_VAR 0 3
62213: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62214: LD_INT 0
62216: PPUSH
// if not mc_bases or not base or not scan_area then
62217: LD_EXP 99
62221: NOT
62222: PUSH
62223: LD_VAR 0 1
62227: NOT
62228: OR
62229: PUSH
62230: LD_VAR 0 2
62234: NOT
62235: OR
62236: IFFALSE 62240
// exit ;
62238: GO 62265
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62240: LD_ADDR_EXP 124
62244: PUSH
62245: LD_EXP 124
62249: PPUSH
62250: LD_VAR 0 1
62254: PPUSH
62255: LD_VAR 0 2
62259: PPUSH
62260: CALL_OW 1
62264: ST_TO_ADDR
// end ;
62265: LD_VAR 0 3
62269: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62270: LD_INT 0
62272: PPUSH
62273: PPUSH
// if not mc_bases or not base then
62274: LD_EXP 99
62278: NOT
62279: PUSH
62280: LD_VAR 0 1
62284: NOT
62285: OR
62286: IFFALSE 62290
// exit ;
62288: GO 62354
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62290: LD_ADDR_VAR 0 3
62294: PUSH
62295: LD_INT 1
62297: PUSH
62298: LD_INT 2
62300: PUSH
62301: LD_INT 3
62303: PUSH
62304: LD_INT 4
62306: PUSH
62307: LD_INT 11
62309: PUSH
62310: EMPTY
62311: LIST
62312: LIST
62313: LIST
62314: LIST
62315: LIST
62316: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62317: LD_ADDR_EXP 126
62321: PUSH
62322: LD_EXP 126
62326: PPUSH
62327: LD_VAR 0 1
62331: PPUSH
62332: LD_EXP 126
62336: PUSH
62337: LD_VAR 0 1
62341: ARRAY
62342: PUSH
62343: LD_VAR 0 3
62347: DIFF
62348: PPUSH
62349: CALL_OW 1
62353: ST_TO_ADDR
// end ;
62354: LD_VAR 0 2
62358: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62359: LD_INT 0
62361: PPUSH
// result := mc_vehicles [ base ] ;
62362: LD_ADDR_VAR 0 3
62366: PUSH
62367: LD_EXP 118
62371: PUSH
62372: LD_VAR 0 1
62376: ARRAY
62377: ST_TO_ADDR
// if onlyCombat then
62378: LD_VAR 0 2
62382: IFFALSE 62554
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62384: LD_ADDR_VAR 0 3
62388: PUSH
62389: LD_VAR 0 3
62393: PUSH
62394: LD_VAR 0 3
62398: PPUSH
62399: LD_INT 2
62401: PUSH
62402: LD_INT 34
62404: PUSH
62405: LD_INT 12
62407: PUSH
62408: EMPTY
62409: LIST
62410: LIST
62411: PUSH
62412: LD_INT 34
62414: PUSH
62415: LD_INT 51
62417: PUSH
62418: EMPTY
62419: LIST
62420: LIST
62421: PUSH
62422: LD_INT 34
62424: PUSH
62425: LD_INT 89
62427: PUSH
62428: EMPTY
62429: LIST
62430: LIST
62431: PUSH
62432: LD_INT 34
62434: PUSH
62435: LD_INT 32
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: PUSH
62442: LD_INT 34
62444: PUSH
62445: LD_INT 13
62447: PUSH
62448: EMPTY
62449: LIST
62450: LIST
62451: PUSH
62452: LD_INT 34
62454: PUSH
62455: LD_INT 52
62457: PUSH
62458: EMPTY
62459: LIST
62460: LIST
62461: PUSH
62462: LD_INT 34
62464: PUSH
62465: LD_INT 88
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: PUSH
62472: LD_INT 34
62474: PUSH
62475: LD_INT 14
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: PUSH
62482: LD_INT 34
62484: PUSH
62485: LD_INT 53
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: PUSH
62492: LD_INT 34
62494: PUSH
62495: LD_INT 98
62497: PUSH
62498: EMPTY
62499: LIST
62500: LIST
62501: PUSH
62502: LD_INT 34
62504: PUSH
62505: LD_INT 31
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 34
62514: PUSH
62515: LD_INT 48
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PUSH
62522: LD_INT 34
62524: PUSH
62525: LD_INT 8
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: LIST
62546: LIST
62547: PPUSH
62548: CALL_OW 72
62552: DIFF
62553: ST_TO_ADDR
// end ; end_of_file
62554: LD_VAR 0 3
62558: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62559: LD_INT 0
62561: PPUSH
62562: PPUSH
62563: PPUSH
// if not mc_bases or not skirmish then
62564: LD_EXP 99
62568: NOT
62569: PUSH
62570: LD_EXP 97
62574: NOT
62575: OR
62576: IFFALSE 62580
// exit ;
62578: GO 62745
// for i = 1 to mc_bases do
62580: LD_ADDR_VAR 0 4
62584: PUSH
62585: DOUBLE
62586: LD_INT 1
62588: DEC
62589: ST_TO_ADDR
62590: LD_EXP 99
62594: PUSH
62595: FOR_TO
62596: IFFALSE 62743
// begin if sci in mc_bases [ i ] then
62598: LD_VAR 0 2
62602: PUSH
62603: LD_EXP 99
62607: PUSH
62608: LD_VAR 0 4
62612: ARRAY
62613: IN
62614: IFFALSE 62741
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62616: LD_ADDR_EXP 128
62620: PUSH
62621: LD_EXP 128
62625: PPUSH
62626: LD_VAR 0 4
62630: PUSH
62631: LD_EXP 128
62635: PUSH
62636: LD_VAR 0 4
62640: ARRAY
62641: PUSH
62642: LD_INT 1
62644: PLUS
62645: PUSH
62646: EMPTY
62647: LIST
62648: LIST
62649: PPUSH
62650: LD_VAR 0 1
62654: PPUSH
62655: CALL 72466 0 3
62659: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62660: LD_ADDR_VAR 0 5
62664: PUSH
62665: LD_EXP 99
62669: PUSH
62670: LD_VAR 0 4
62674: ARRAY
62675: PPUSH
62676: LD_INT 2
62678: PUSH
62679: LD_INT 30
62681: PUSH
62682: LD_INT 0
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: PUSH
62689: LD_INT 30
62691: PUSH
62692: LD_INT 1
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: LIST
62703: PPUSH
62704: CALL_OW 72
62708: PPUSH
62709: LD_VAR 0 1
62713: PPUSH
62714: CALL_OW 74
62718: ST_TO_ADDR
// if tmp then
62719: LD_VAR 0 5
62723: IFFALSE 62739
// ComStandNearbyBuilding ( ape , tmp ) ;
62725: LD_VAR 0 1
62729: PPUSH
62730: LD_VAR 0 5
62734: PPUSH
62735: CALL 68893 0 2
// break ;
62739: GO 62743
// end ; end ;
62741: GO 62595
62743: POP
62744: POP
// end ;
62745: LD_VAR 0 3
62749: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62750: LD_INT 0
62752: PPUSH
62753: PPUSH
62754: PPUSH
// if not mc_bases or not skirmish then
62755: LD_EXP 99
62759: NOT
62760: PUSH
62761: LD_EXP 97
62765: NOT
62766: OR
62767: IFFALSE 62771
// exit ;
62769: GO 62860
// for i = 1 to mc_bases do
62771: LD_ADDR_VAR 0 4
62775: PUSH
62776: DOUBLE
62777: LD_INT 1
62779: DEC
62780: ST_TO_ADDR
62781: LD_EXP 99
62785: PUSH
62786: FOR_TO
62787: IFFALSE 62858
// begin if building in mc_busy_turret_list [ i ] then
62789: LD_VAR 0 1
62793: PUSH
62794: LD_EXP 109
62798: PUSH
62799: LD_VAR 0 4
62803: ARRAY
62804: IN
62805: IFFALSE 62856
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62807: LD_ADDR_VAR 0 5
62811: PUSH
62812: LD_EXP 109
62816: PUSH
62817: LD_VAR 0 4
62821: ARRAY
62822: PUSH
62823: LD_VAR 0 1
62827: DIFF
62828: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
62829: LD_ADDR_EXP 109
62833: PUSH
62834: LD_EXP 109
62838: PPUSH
62839: LD_VAR 0 4
62843: PPUSH
62844: LD_VAR 0 5
62848: PPUSH
62849: CALL_OW 1
62853: ST_TO_ADDR
// break ;
62854: GO 62858
// end ; end ;
62856: GO 62786
62858: POP
62859: POP
// end ;
62860: LD_VAR 0 3
62864: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
62865: LD_INT 0
62867: PPUSH
62868: PPUSH
62869: PPUSH
// if not mc_bases or not skirmish then
62870: LD_EXP 99
62874: NOT
62875: PUSH
62876: LD_EXP 97
62880: NOT
62881: OR
62882: IFFALSE 62886
// exit ;
62884: GO 63085
// for i = 1 to mc_bases do
62886: LD_ADDR_VAR 0 5
62890: PUSH
62891: DOUBLE
62892: LD_INT 1
62894: DEC
62895: ST_TO_ADDR
62896: LD_EXP 99
62900: PUSH
62901: FOR_TO
62902: IFFALSE 63083
// if building in mc_bases [ i ] then
62904: LD_VAR 0 1
62908: PUSH
62909: LD_EXP 99
62913: PUSH
62914: LD_VAR 0 5
62918: ARRAY
62919: IN
62920: IFFALSE 63081
// begin tmp := mc_bases [ i ] diff building ;
62922: LD_ADDR_VAR 0 6
62926: PUSH
62927: LD_EXP 99
62931: PUSH
62932: LD_VAR 0 5
62936: ARRAY
62937: PUSH
62938: LD_VAR 0 1
62942: DIFF
62943: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
62944: LD_ADDR_EXP 99
62948: PUSH
62949: LD_EXP 99
62953: PPUSH
62954: LD_VAR 0 5
62958: PPUSH
62959: LD_VAR 0 6
62963: PPUSH
62964: CALL_OW 1
62968: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
62969: LD_VAR 0 1
62973: PUSH
62974: LD_EXP 107
62978: PUSH
62979: LD_VAR 0 5
62983: ARRAY
62984: IN
62985: IFFALSE 63024
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
62987: LD_ADDR_EXP 107
62991: PUSH
62992: LD_EXP 107
62996: PPUSH
62997: LD_VAR 0 5
63001: PPUSH
63002: LD_EXP 107
63006: PUSH
63007: LD_VAR 0 5
63011: ARRAY
63012: PUSH
63013: LD_VAR 0 1
63017: DIFF
63018: PPUSH
63019: CALL_OW 1
63023: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63024: LD_VAR 0 1
63028: PUSH
63029: LD_EXP 108
63033: PUSH
63034: LD_VAR 0 5
63038: ARRAY
63039: IN
63040: IFFALSE 63079
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63042: LD_ADDR_EXP 108
63046: PUSH
63047: LD_EXP 108
63051: PPUSH
63052: LD_VAR 0 5
63056: PPUSH
63057: LD_EXP 108
63061: PUSH
63062: LD_VAR 0 5
63066: ARRAY
63067: PUSH
63068: LD_VAR 0 1
63072: DIFF
63073: PPUSH
63074: CALL_OW 1
63078: ST_TO_ADDR
// break ;
63079: GO 63083
// end ;
63081: GO 62901
63083: POP
63084: POP
// end ;
63085: LD_VAR 0 4
63089: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63090: LD_INT 0
63092: PPUSH
63093: PPUSH
63094: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63095: LD_EXP 99
63099: NOT
63100: PUSH
63101: LD_EXP 97
63105: NOT
63106: OR
63107: PUSH
63108: LD_VAR 0 3
63112: PUSH
63113: LD_EXP 125
63117: IN
63118: NOT
63119: OR
63120: IFFALSE 63124
// exit ;
63122: GO 63247
// for i = 1 to mc_vehicles do
63124: LD_ADDR_VAR 0 6
63128: PUSH
63129: DOUBLE
63130: LD_INT 1
63132: DEC
63133: ST_TO_ADDR
63134: LD_EXP 118
63138: PUSH
63139: FOR_TO
63140: IFFALSE 63245
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63142: LD_VAR 0 2
63146: PUSH
63147: LD_EXP 118
63151: PUSH
63152: LD_VAR 0 6
63156: ARRAY
63157: IN
63158: PUSH
63159: LD_VAR 0 1
63163: PUSH
63164: LD_EXP 118
63168: PUSH
63169: LD_VAR 0 6
63173: ARRAY
63174: IN
63175: OR
63176: IFFALSE 63243
// begin tmp := mc_vehicles [ i ] diff old ;
63178: LD_ADDR_VAR 0 7
63182: PUSH
63183: LD_EXP 118
63187: PUSH
63188: LD_VAR 0 6
63192: ARRAY
63193: PUSH
63194: LD_VAR 0 2
63198: DIFF
63199: ST_TO_ADDR
// tmp := tmp diff new ;
63200: LD_ADDR_VAR 0 7
63204: PUSH
63205: LD_VAR 0 7
63209: PUSH
63210: LD_VAR 0 1
63214: DIFF
63215: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63216: LD_ADDR_EXP 118
63220: PUSH
63221: LD_EXP 118
63225: PPUSH
63226: LD_VAR 0 6
63230: PPUSH
63231: LD_VAR 0 7
63235: PPUSH
63236: CALL_OW 1
63240: ST_TO_ADDR
// break ;
63241: GO 63245
// end ;
63243: GO 63139
63245: POP
63246: POP
// end ;
63247: LD_VAR 0 5
63251: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63252: LD_INT 0
63254: PPUSH
63255: PPUSH
63256: PPUSH
63257: PPUSH
// if not mc_bases or not skirmish then
63258: LD_EXP 99
63262: NOT
63263: PUSH
63264: LD_EXP 97
63268: NOT
63269: OR
63270: IFFALSE 63274
// exit ;
63272: GO 63656
// side := GetSide ( vehicle ) ;
63274: LD_ADDR_VAR 0 5
63278: PUSH
63279: LD_VAR 0 1
63283: PPUSH
63284: CALL_OW 255
63288: ST_TO_ADDR
// for i = 1 to mc_bases do
63289: LD_ADDR_VAR 0 4
63293: PUSH
63294: DOUBLE
63295: LD_INT 1
63297: DEC
63298: ST_TO_ADDR
63299: LD_EXP 99
63303: PUSH
63304: FOR_TO
63305: IFFALSE 63654
// begin if factory in mc_bases [ i ] then
63307: LD_VAR 0 2
63311: PUSH
63312: LD_EXP 99
63316: PUSH
63317: LD_VAR 0 4
63321: ARRAY
63322: IN
63323: IFFALSE 63652
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63325: LD_EXP 121
63329: PUSH
63330: LD_VAR 0 4
63334: ARRAY
63335: PUSH
63336: LD_EXP 110
63340: PUSH
63341: LD_VAR 0 4
63345: ARRAY
63346: LESS
63347: PUSH
63348: LD_VAR 0 1
63352: PPUSH
63353: CALL_OW 264
63357: PUSH
63358: LD_INT 31
63360: PUSH
63361: LD_INT 32
63363: PUSH
63364: LD_INT 51
63366: PUSH
63367: LD_INT 89
63369: PUSH
63370: LD_INT 12
63372: PUSH
63373: LD_INT 30
63375: PUSH
63376: LD_INT 98
63378: PUSH
63379: LD_INT 11
63381: PUSH
63382: LD_INT 53
63384: PUSH
63385: LD_INT 14
63387: PUSH
63388: LD_INT 91
63390: PUSH
63391: LD_INT 29
63393: PUSH
63394: LD_INT 99
63396: PUSH
63397: LD_INT 13
63399: PUSH
63400: LD_INT 52
63402: PUSH
63403: LD_INT 88
63405: PUSH
63406: LD_INT 48
63408: PUSH
63409: LD_INT 8
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: LIST
63422: LIST
63423: LIST
63424: LIST
63425: LIST
63426: LIST
63427: LIST
63428: LIST
63429: LIST
63430: LIST
63431: IN
63432: NOT
63433: AND
63434: IFFALSE 63482
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63436: LD_ADDR_EXP 121
63440: PUSH
63441: LD_EXP 121
63445: PPUSH
63446: LD_VAR 0 4
63450: PUSH
63451: LD_EXP 121
63455: PUSH
63456: LD_VAR 0 4
63460: ARRAY
63461: PUSH
63462: LD_INT 1
63464: PLUS
63465: PUSH
63466: EMPTY
63467: LIST
63468: LIST
63469: PPUSH
63470: LD_VAR 0 1
63474: PPUSH
63475: CALL 72466 0 3
63479: ST_TO_ADDR
63480: GO 63526
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63482: LD_ADDR_EXP 118
63486: PUSH
63487: LD_EXP 118
63491: PPUSH
63492: LD_VAR 0 4
63496: PUSH
63497: LD_EXP 118
63501: PUSH
63502: LD_VAR 0 4
63506: ARRAY
63507: PUSH
63508: LD_INT 1
63510: PLUS
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PPUSH
63516: LD_VAR 0 1
63520: PPUSH
63521: CALL 72466 0 3
63525: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63526: LD_VAR 0 1
63530: PPUSH
63531: CALL_OW 263
63535: PUSH
63536: LD_INT 2
63538: EQUAL
63539: IFFALSE 63568
// begin repeat wait ( 0 0$3 ) ;
63541: LD_INT 105
63543: PPUSH
63544: CALL_OW 67
// Connect ( vehicle ) ;
63548: LD_VAR 0 1
63552: PPUSH
63553: CALL 75435 0 1
// until IsControledBy ( vehicle ) ;
63557: LD_VAR 0 1
63561: PPUSH
63562: CALL_OW 312
63566: IFFALSE 63541
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63568: LD_VAR 0 1
63572: PPUSH
63573: LD_EXP 123
63577: PUSH
63578: LD_VAR 0 4
63582: ARRAY
63583: PPUSH
63584: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63588: LD_VAR 0 1
63592: PPUSH
63593: CALL_OW 263
63597: PUSH
63598: LD_INT 1
63600: NONEQUAL
63601: IFFALSE 63605
// break ;
63603: GO 63654
// repeat wait ( 0 0$1 ) ;
63605: LD_INT 35
63607: PPUSH
63608: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63612: LD_VAR 0 1
63616: PPUSH
63617: LD_EXP 123
63621: PUSH
63622: LD_VAR 0 4
63626: ARRAY
63627: PPUSH
63628: CALL_OW 308
63632: IFFALSE 63605
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63634: LD_VAR 0 1
63638: PPUSH
63639: CALL_OW 311
63643: PPUSH
63644: CALL_OW 121
// exit ;
63648: POP
63649: POP
63650: GO 63656
// end ; end ;
63652: GO 63304
63654: POP
63655: POP
// end ;
63656: LD_VAR 0 3
63660: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63661: LD_INT 0
63663: PPUSH
63664: PPUSH
63665: PPUSH
63666: PPUSH
// if not mc_bases or not skirmish then
63667: LD_EXP 99
63671: NOT
63672: PUSH
63673: LD_EXP 97
63677: NOT
63678: OR
63679: IFFALSE 63683
// exit ;
63681: GO 64036
// repeat wait ( 0 0$1 ) ;
63683: LD_INT 35
63685: PPUSH
63686: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63690: LD_VAR 0 2
63694: PPUSH
63695: LD_VAR 0 3
63699: PPUSH
63700: CALL_OW 284
63704: IFFALSE 63683
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63706: LD_VAR 0 2
63710: PPUSH
63711: LD_VAR 0 3
63715: PPUSH
63716: CALL_OW 283
63720: PUSH
63721: LD_INT 4
63723: EQUAL
63724: IFFALSE 63728
// exit ;
63726: GO 64036
// for i = 1 to mc_bases do
63728: LD_ADDR_VAR 0 7
63732: PUSH
63733: DOUBLE
63734: LD_INT 1
63736: DEC
63737: ST_TO_ADDR
63738: LD_EXP 99
63742: PUSH
63743: FOR_TO
63744: IFFALSE 64034
// begin if mc_crates_area [ i ] then
63746: LD_EXP 117
63750: PUSH
63751: LD_VAR 0 7
63755: ARRAY
63756: IFFALSE 63867
// for j in mc_crates_area [ i ] do
63758: LD_ADDR_VAR 0 8
63762: PUSH
63763: LD_EXP 117
63767: PUSH
63768: LD_VAR 0 7
63772: ARRAY
63773: PUSH
63774: FOR_IN
63775: IFFALSE 63865
// if InArea ( x , y , j ) then
63777: LD_VAR 0 2
63781: PPUSH
63782: LD_VAR 0 3
63786: PPUSH
63787: LD_VAR 0 8
63791: PPUSH
63792: CALL_OW 309
63796: IFFALSE 63863
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63798: LD_ADDR_EXP 115
63802: PUSH
63803: LD_EXP 115
63807: PPUSH
63808: LD_VAR 0 7
63812: PUSH
63813: LD_EXP 115
63817: PUSH
63818: LD_VAR 0 7
63822: ARRAY
63823: PUSH
63824: LD_INT 1
63826: PLUS
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PPUSH
63832: LD_VAR 0 4
63836: PUSH
63837: LD_VAR 0 2
63841: PUSH
63842: LD_VAR 0 3
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: LIST
63851: PPUSH
63852: CALL 72466 0 3
63856: ST_TO_ADDR
// exit ;
63857: POP
63858: POP
63859: POP
63860: POP
63861: GO 64036
// end ;
63863: GO 63774
63865: POP
63866: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63867: LD_ADDR_VAR 0 9
63871: PUSH
63872: LD_EXP 99
63876: PUSH
63877: LD_VAR 0 7
63881: ARRAY
63882: PPUSH
63883: LD_INT 2
63885: PUSH
63886: LD_INT 30
63888: PUSH
63889: LD_INT 0
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 30
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: LIST
63910: PPUSH
63911: CALL_OW 72
63915: ST_TO_ADDR
// if not depot then
63916: LD_VAR 0 9
63920: NOT
63921: IFFALSE 63925
// continue ;
63923: GO 63743
// for j in depot do
63925: LD_ADDR_VAR 0 8
63929: PUSH
63930: LD_VAR 0 9
63934: PUSH
63935: FOR_IN
63936: IFFALSE 64030
// if GetDistUnitXY ( j , x , y ) < 30 then
63938: LD_VAR 0 8
63942: PPUSH
63943: LD_VAR 0 2
63947: PPUSH
63948: LD_VAR 0 3
63952: PPUSH
63953: CALL_OW 297
63957: PUSH
63958: LD_INT 30
63960: LESS
63961: IFFALSE 64028
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63963: LD_ADDR_EXP 115
63967: PUSH
63968: LD_EXP 115
63972: PPUSH
63973: LD_VAR 0 7
63977: PUSH
63978: LD_EXP 115
63982: PUSH
63983: LD_VAR 0 7
63987: ARRAY
63988: PUSH
63989: LD_INT 1
63991: PLUS
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PPUSH
63997: LD_VAR 0 4
64001: PUSH
64002: LD_VAR 0 2
64006: PUSH
64007: LD_VAR 0 3
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: LIST
64016: PPUSH
64017: CALL 72466 0 3
64021: ST_TO_ADDR
// exit ;
64022: POP
64023: POP
64024: POP
64025: POP
64026: GO 64036
// end ;
64028: GO 63935
64030: POP
64031: POP
// end ;
64032: GO 63743
64034: POP
64035: POP
// end ;
64036: LD_VAR 0 6
64040: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64041: LD_INT 0
64043: PPUSH
64044: PPUSH
64045: PPUSH
64046: PPUSH
// if not mc_bases or not skirmish then
64047: LD_EXP 99
64051: NOT
64052: PUSH
64053: LD_EXP 97
64057: NOT
64058: OR
64059: IFFALSE 64063
// exit ;
64061: GO 64340
// side := GetSide ( lab ) ;
64063: LD_ADDR_VAR 0 4
64067: PUSH
64068: LD_VAR 0 2
64072: PPUSH
64073: CALL_OW 255
64077: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64078: LD_VAR 0 4
64082: PUSH
64083: LD_EXP 125
64087: IN
64088: NOT
64089: PUSH
64090: LD_EXP 126
64094: NOT
64095: OR
64096: PUSH
64097: LD_EXP 99
64101: NOT
64102: OR
64103: IFFALSE 64107
// exit ;
64105: GO 64340
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64107: LD_ADDR_EXP 126
64111: PUSH
64112: LD_EXP 126
64116: PPUSH
64117: LD_VAR 0 4
64121: PPUSH
64122: LD_EXP 126
64126: PUSH
64127: LD_VAR 0 4
64131: ARRAY
64132: PUSH
64133: LD_VAR 0 1
64137: DIFF
64138: PPUSH
64139: CALL_OW 1
64143: ST_TO_ADDR
// for i = 1 to mc_bases do
64144: LD_ADDR_VAR 0 5
64148: PUSH
64149: DOUBLE
64150: LD_INT 1
64152: DEC
64153: ST_TO_ADDR
64154: LD_EXP 99
64158: PUSH
64159: FOR_TO
64160: IFFALSE 64338
// begin if lab in mc_bases [ i ] then
64162: LD_VAR 0 2
64166: PUSH
64167: LD_EXP 99
64171: PUSH
64172: LD_VAR 0 5
64176: ARRAY
64177: IN
64178: IFFALSE 64336
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64180: LD_VAR 0 1
64184: PUSH
64185: LD_INT 11
64187: PUSH
64188: LD_INT 4
64190: PUSH
64191: LD_INT 3
64193: PUSH
64194: LD_INT 2
64196: PUSH
64197: EMPTY
64198: LIST
64199: LIST
64200: LIST
64201: LIST
64202: IN
64203: PUSH
64204: LD_EXP 129
64208: PUSH
64209: LD_VAR 0 5
64213: ARRAY
64214: AND
64215: IFFALSE 64336
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64217: LD_ADDR_VAR 0 6
64221: PUSH
64222: LD_EXP 129
64226: PUSH
64227: LD_VAR 0 5
64231: ARRAY
64232: PUSH
64233: LD_INT 1
64235: ARRAY
64236: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64237: LD_ADDR_EXP 129
64241: PUSH
64242: LD_EXP 129
64246: PPUSH
64247: LD_VAR 0 5
64251: PPUSH
64252: EMPTY
64253: PPUSH
64254: CALL_OW 1
64258: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64259: LD_VAR 0 6
64263: PPUSH
64264: LD_INT 0
64266: PPUSH
64267: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64271: LD_VAR 0 6
64275: PPUSH
64276: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64280: LD_ADDR_EXP 128
64284: PUSH
64285: LD_EXP 128
64289: PPUSH
64290: LD_VAR 0 5
64294: PPUSH
64295: LD_EXP 128
64299: PUSH
64300: LD_VAR 0 5
64304: ARRAY
64305: PPUSH
64306: LD_INT 1
64308: PPUSH
64309: LD_VAR 0 6
64313: PPUSH
64314: CALL_OW 2
64318: PPUSH
64319: CALL_OW 1
64323: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64324: LD_VAR 0 5
64328: PPUSH
64329: LD_INT 112
64331: PPUSH
64332: CALL 40826 0 2
// end ; end ; end ;
64336: GO 64159
64338: POP
64339: POP
// end ;
64340: LD_VAR 0 3
64344: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64345: LD_INT 0
64347: PPUSH
64348: PPUSH
64349: PPUSH
64350: PPUSH
64351: PPUSH
64352: PPUSH
64353: PPUSH
64354: PPUSH
// if not mc_bases or not skirmish then
64355: LD_EXP 99
64359: NOT
64360: PUSH
64361: LD_EXP 97
64365: NOT
64366: OR
64367: IFFALSE 64371
// exit ;
64369: GO 65740
// for i = 1 to mc_bases do
64371: LD_ADDR_VAR 0 3
64375: PUSH
64376: DOUBLE
64377: LD_INT 1
64379: DEC
64380: ST_TO_ADDR
64381: LD_EXP 99
64385: PUSH
64386: FOR_TO
64387: IFFALSE 65738
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64389: LD_VAR 0 1
64393: PUSH
64394: LD_EXP 99
64398: PUSH
64399: LD_VAR 0 3
64403: ARRAY
64404: IN
64405: PUSH
64406: LD_VAR 0 1
64410: PUSH
64411: LD_EXP 106
64415: PUSH
64416: LD_VAR 0 3
64420: ARRAY
64421: IN
64422: OR
64423: PUSH
64424: LD_VAR 0 1
64428: PUSH
64429: LD_EXP 121
64433: PUSH
64434: LD_VAR 0 3
64438: ARRAY
64439: IN
64440: OR
64441: PUSH
64442: LD_VAR 0 1
64446: PUSH
64447: LD_EXP 118
64451: PUSH
64452: LD_VAR 0 3
64456: ARRAY
64457: IN
64458: OR
64459: PUSH
64460: LD_VAR 0 1
64464: PUSH
64465: LD_EXP 128
64469: PUSH
64470: LD_VAR 0 3
64474: ARRAY
64475: IN
64476: OR
64477: PUSH
64478: LD_VAR 0 1
64482: PUSH
64483: LD_EXP 129
64487: PUSH
64488: LD_VAR 0 3
64492: ARRAY
64493: IN
64494: OR
64495: IFFALSE 65736
// begin if un in mc_ape [ i ] then
64497: LD_VAR 0 1
64501: PUSH
64502: LD_EXP 128
64506: PUSH
64507: LD_VAR 0 3
64511: ARRAY
64512: IN
64513: IFFALSE 64552
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64515: LD_ADDR_EXP 128
64519: PUSH
64520: LD_EXP 128
64524: PPUSH
64525: LD_VAR 0 3
64529: PPUSH
64530: LD_EXP 128
64534: PUSH
64535: LD_VAR 0 3
64539: ARRAY
64540: PUSH
64541: LD_VAR 0 1
64545: DIFF
64546: PPUSH
64547: CALL_OW 1
64551: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64552: LD_VAR 0 1
64556: PUSH
64557: LD_EXP 129
64561: PUSH
64562: LD_VAR 0 3
64566: ARRAY
64567: IN
64568: IFFALSE 64592
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64570: LD_ADDR_EXP 129
64574: PUSH
64575: LD_EXP 129
64579: PPUSH
64580: LD_VAR 0 3
64584: PPUSH
64585: EMPTY
64586: PPUSH
64587: CALL_OW 1
64591: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64592: LD_VAR 0 1
64596: PPUSH
64597: CALL_OW 247
64601: PUSH
64602: LD_INT 2
64604: EQUAL
64605: PUSH
64606: LD_VAR 0 1
64610: PPUSH
64611: CALL_OW 110
64615: PUSH
64616: LD_INT 20
64618: EQUAL
64619: PUSH
64620: LD_VAR 0 1
64624: PUSH
64625: LD_EXP 121
64629: PUSH
64630: LD_VAR 0 3
64634: ARRAY
64635: IN
64636: OR
64637: PUSH
64638: LD_VAR 0 1
64642: PPUSH
64643: CALL_OW 264
64647: PUSH
64648: LD_INT 12
64650: PUSH
64651: LD_INT 51
64653: PUSH
64654: LD_INT 89
64656: PUSH
64657: LD_INT 32
64659: PUSH
64660: LD_INT 13
64662: PUSH
64663: LD_INT 52
64665: PUSH
64666: LD_INT 31
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: IN
64678: OR
64679: AND
64680: IFFALSE 64988
// begin if un in mc_defender [ i ] then
64682: LD_VAR 0 1
64686: PUSH
64687: LD_EXP 121
64691: PUSH
64692: LD_VAR 0 3
64696: ARRAY
64697: IN
64698: IFFALSE 64737
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64700: LD_ADDR_EXP 121
64704: PUSH
64705: LD_EXP 121
64709: PPUSH
64710: LD_VAR 0 3
64714: PPUSH
64715: LD_EXP 121
64719: PUSH
64720: LD_VAR 0 3
64724: ARRAY
64725: PUSH
64726: LD_VAR 0 1
64730: DIFF
64731: PPUSH
64732: CALL_OW 1
64736: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64737: LD_ADDR_VAR 0 8
64741: PUSH
64742: LD_VAR 0 3
64746: PPUSH
64747: LD_INT 3
64749: PPUSH
64750: CALL 61396 0 2
64754: ST_TO_ADDR
// if fac then
64755: LD_VAR 0 8
64759: IFFALSE 64988
// begin for j in fac do
64761: LD_ADDR_VAR 0 4
64765: PUSH
64766: LD_VAR 0 8
64770: PUSH
64771: FOR_IN
64772: IFFALSE 64986
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64774: LD_ADDR_VAR 0 9
64778: PUSH
64779: LD_VAR 0 8
64783: PPUSH
64784: LD_VAR 0 1
64788: PPUSH
64789: CALL_OW 265
64793: PPUSH
64794: LD_VAR 0 1
64798: PPUSH
64799: CALL_OW 262
64803: PPUSH
64804: LD_VAR 0 1
64808: PPUSH
64809: CALL_OW 263
64813: PPUSH
64814: LD_VAR 0 1
64818: PPUSH
64819: CALL_OW 264
64823: PPUSH
64824: CALL 69964 0 5
64828: ST_TO_ADDR
// if components then
64829: LD_VAR 0 9
64833: IFFALSE 64984
// begin if GetWeapon ( un ) = ar_control_tower then
64835: LD_VAR 0 1
64839: PPUSH
64840: CALL_OW 264
64844: PUSH
64845: LD_INT 31
64847: EQUAL
64848: IFFALSE 64965
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
64850: LD_VAR 0 1
64854: PPUSH
64855: CALL_OW 311
64859: PPUSH
64860: LD_INT 0
64862: PPUSH
64863: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
64867: LD_ADDR_EXP 139
64871: PUSH
64872: LD_EXP 139
64876: PPUSH
64877: LD_VAR 0 3
64881: PPUSH
64882: LD_EXP 139
64886: PUSH
64887: LD_VAR 0 3
64891: ARRAY
64892: PUSH
64893: LD_VAR 0 1
64897: PPUSH
64898: CALL_OW 311
64902: DIFF
64903: PPUSH
64904: CALL_OW 1
64908: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
64909: LD_ADDR_VAR 0 7
64913: PUSH
64914: LD_EXP 120
64918: PUSH
64919: LD_VAR 0 3
64923: ARRAY
64924: PPUSH
64925: LD_INT 1
64927: PPUSH
64928: LD_VAR 0 9
64932: PPUSH
64933: CALL_OW 2
64937: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64938: LD_ADDR_EXP 120
64942: PUSH
64943: LD_EXP 120
64947: PPUSH
64948: LD_VAR 0 3
64952: PPUSH
64953: LD_VAR 0 7
64957: PPUSH
64958: CALL_OW 1
64962: ST_TO_ADDR
// end else
64963: GO 64982
// MC_InsertProduceList ( i , [ components ] ) ;
64965: LD_VAR 0 3
64969: PPUSH
64970: LD_VAR 0 9
64974: PUSH
64975: EMPTY
64976: LIST
64977: PPUSH
64978: CALL 60941 0 2
// break ;
64982: GO 64986
// end ; end ;
64984: GO 64771
64986: POP
64987: POP
// end ; end ; if GetType ( un ) = unit_building then
64988: LD_VAR 0 1
64992: PPUSH
64993: CALL_OW 247
64997: PUSH
64998: LD_INT 3
65000: EQUAL
65001: IFFALSE 65404
// begin btype := GetBType ( un ) ;
65003: LD_ADDR_VAR 0 5
65007: PUSH
65008: LD_VAR 0 1
65012: PPUSH
65013: CALL_OW 266
65017: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65018: LD_VAR 0 5
65022: PUSH
65023: LD_INT 29
65025: PUSH
65026: LD_INT 30
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: IN
65033: IFFALSE 65106
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65035: LD_VAR 0 1
65039: PPUSH
65040: CALL_OW 250
65044: PPUSH
65045: LD_VAR 0 1
65049: PPUSH
65050: CALL_OW 251
65054: PPUSH
65055: LD_VAR 0 1
65059: PPUSH
65060: CALL_OW 255
65064: PPUSH
65065: CALL_OW 440
65069: NOT
65070: IFFALSE 65106
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65072: LD_VAR 0 1
65076: PPUSH
65077: CALL_OW 250
65081: PPUSH
65082: LD_VAR 0 1
65086: PPUSH
65087: CALL_OW 251
65091: PPUSH
65092: LD_VAR 0 1
65096: PPUSH
65097: CALL_OW 255
65101: PPUSH
65102: CALL_OW 441
// end ; if btype = b_warehouse then
65106: LD_VAR 0 5
65110: PUSH
65111: LD_INT 1
65113: EQUAL
65114: IFFALSE 65132
// begin btype := b_depot ;
65116: LD_ADDR_VAR 0 5
65120: PUSH
65121: LD_INT 0
65123: ST_TO_ADDR
// pos := 1 ;
65124: LD_ADDR_VAR 0 6
65128: PUSH
65129: LD_INT 1
65131: ST_TO_ADDR
// end ; if btype = b_factory then
65132: LD_VAR 0 5
65136: PUSH
65137: LD_INT 3
65139: EQUAL
65140: IFFALSE 65158
// begin btype := b_workshop ;
65142: LD_ADDR_VAR 0 5
65146: PUSH
65147: LD_INT 2
65149: ST_TO_ADDR
// pos := 1 ;
65150: LD_ADDR_VAR 0 6
65154: PUSH
65155: LD_INT 1
65157: ST_TO_ADDR
// end ; if btype = b_barracks then
65158: LD_VAR 0 5
65162: PUSH
65163: LD_INT 5
65165: EQUAL
65166: IFFALSE 65176
// btype := b_armoury ;
65168: LD_ADDR_VAR 0 5
65172: PUSH
65173: LD_INT 4
65175: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65176: LD_VAR 0 5
65180: PUSH
65181: LD_INT 7
65183: PUSH
65184: LD_INT 8
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: IN
65191: IFFALSE 65201
// btype := b_lab ;
65193: LD_ADDR_VAR 0 5
65197: PUSH
65198: LD_INT 6
65200: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65201: LD_ADDR_EXP 104
65205: PUSH
65206: LD_EXP 104
65210: PPUSH
65211: LD_VAR 0 3
65215: PUSH
65216: LD_EXP 104
65220: PUSH
65221: LD_VAR 0 3
65225: ARRAY
65226: PUSH
65227: LD_INT 1
65229: PLUS
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: PPUSH
65235: LD_VAR 0 5
65239: PUSH
65240: LD_VAR 0 1
65244: PPUSH
65245: CALL_OW 250
65249: PUSH
65250: LD_VAR 0 1
65254: PPUSH
65255: CALL_OW 251
65259: PUSH
65260: LD_VAR 0 1
65264: PPUSH
65265: CALL_OW 254
65269: PUSH
65270: EMPTY
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: PPUSH
65276: CALL 72466 0 3
65280: ST_TO_ADDR
// if pos = 1 then
65281: LD_VAR 0 6
65285: PUSH
65286: LD_INT 1
65288: EQUAL
65289: IFFALSE 65404
// begin tmp := mc_build_list [ i ] ;
65291: LD_ADDR_VAR 0 7
65295: PUSH
65296: LD_EXP 104
65300: PUSH
65301: LD_VAR 0 3
65305: ARRAY
65306: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65307: LD_VAR 0 7
65311: PPUSH
65312: LD_INT 2
65314: PUSH
65315: LD_INT 30
65317: PUSH
65318: LD_INT 0
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 30
65327: PUSH
65328: LD_INT 1
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: LIST
65339: PPUSH
65340: CALL_OW 72
65344: IFFALSE 65354
// pos := 2 ;
65346: LD_ADDR_VAR 0 6
65350: PUSH
65351: LD_INT 2
65353: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65354: LD_ADDR_VAR 0 7
65358: PUSH
65359: LD_VAR 0 7
65363: PPUSH
65364: LD_VAR 0 6
65368: PPUSH
65369: LD_VAR 0 7
65373: PPUSH
65374: CALL 72792 0 3
65378: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65379: LD_ADDR_EXP 104
65383: PUSH
65384: LD_EXP 104
65388: PPUSH
65389: LD_VAR 0 3
65393: PPUSH
65394: LD_VAR 0 7
65398: PPUSH
65399: CALL_OW 1
65403: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65404: LD_VAR 0 1
65408: PUSH
65409: LD_EXP 99
65413: PUSH
65414: LD_VAR 0 3
65418: ARRAY
65419: IN
65420: IFFALSE 65459
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65422: LD_ADDR_EXP 99
65426: PUSH
65427: LD_EXP 99
65431: PPUSH
65432: LD_VAR 0 3
65436: PPUSH
65437: LD_EXP 99
65441: PUSH
65442: LD_VAR 0 3
65446: ARRAY
65447: PUSH
65448: LD_VAR 0 1
65452: DIFF
65453: PPUSH
65454: CALL_OW 1
65458: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65459: LD_VAR 0 1
65463: PUSH
65464: LD_EXP 106
65468: PUSH
65469: LD_VAR 0 3
65473: ARRAY
65474: IN
65475: IFFALSE 65514
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65477: LD_ADDR_EXP 106
65481: PUSH
65482: LD_EXP 106
65486: PPUSH
65487: LD_VAR 0 3
65491: PPUSH
65492: LD_EXP 106
65496: PUSH
65497: LD_VAR 0 3
65501: ARRAY
65502: PUSH
65503: LD_VAR 0 1
65507: DIFF
65508: PPUSH
65509: CALL_OW 1
65513: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65514: LD_VAR 0 1
65518: PUSH
65519: LD_EXP 118
65523: PUSH
65524: LD_VAR 0 3
65528: ARRAY
65529: IN
65530: IFFALSE 65569
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65532: LD_ADDR_EXP 118
65536: PUSH
65537: LD_EXP 118
65541: PPUSH
65542: LD_VAR 0 3
65546: PPUSH
65547: LD_EXP 118
65551: PUSH
65552: LD_VAR 0 3
65556: ARRAY
65557: PUSH
65558: LD_VAR 0 1
65562: DIFF
65563: PPUSH
65564: CALL_OW 1
65568: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65569: LD_VAR 0 1
65573: PUSH
65574: LD_EXP 121
65578: PUSH
65579: LD_VAR 0 3
65583: ARRAY
65584: IN
65585: IFFALSE 65624
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65587: LD_ADDR_EXP 121
65591: PUSH
65592: LD_EXP 121
65596: PPUSH
65597: LD_VAR 0 3
65601: PPUSH
65602: LD_EXP 121
65606: PUSH
65607: LD_VAR 0 3
65611: ARRAY
65612: PUSH
65613: LD_VAR 0 1
65617: DIFF
65618: PPUSH
65619: CALL_OW 1
65623: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65624: LD_VAR 0 1
65628: PUSH
65629: LD_EXP 108
65633: PUSH
65634: LD_VAR 0 3
65638: ARRAY
65639: IN
65640: IFFALSE 65679
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65642: LD_ADDR_EXP 108
65646: PUSH
65647: LD_EXP 108
65651: PPUSH
65652: LD_VAR 0 3
65656: PPUSH
65657: LD_EXP 108
65661: PUSH
65662: LD_VAR 0 3
65666: ARRAY
65667: PUSH
65668: LD_VAR 0 1
65672: DIFF
65673: PPUSH
65674: CALL_OW 1
65678: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65679: LD_VAR 0 1
65683: PUSH
65684: LD_EXP 107
65688: PUSH
65689: LD_VAR 0 3
65693: ARRAY
65694: IN
65695: IFFALSE 65734
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65697: LD_ADDR_EXP 107
65701: PUSH
65702: LD_EXP 107
65706: PPUSH
65707: LD_VAR 0 3
65711: PPUSH
65712: LD_EXP 107
65716: PUSH
65717: LD_VAR 0 3
65721: ARRAY
65722: PUSH
65723: LD_VAR 0 1
65727: DIFF
65728: PPUSH
65729: CALL_OW 1
65733: ST_TO_ADDR
// end ; break ;
65734: GO 65738
// end ;
65736: GO 64386
65738: POP
65739: POP
// end ;
65740: LD_VAR 0 2
65744: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65745: LD_INT 0
65747: PPUSH
65748: PPUSH
65749: PPUSH
// if not mc_bases or not skirmish then
65750: LD_EXP 99
65754: NOT
65755: PUSH
65756: LD_EXP 97
65760: NOT
65761: OR
65762: IFFALSE 65766
// exit ;
65764: GO 65981
// for i = 1 to mc_bases do
65766: LD_ADDR_VAR 0 3
65770: PUSH
65771: DOUBLE
65772: LD_INT 1
65774: DEC
65775: ST_TO_ADDR
65776: LD_EXP 99
65780: PUSH
65781: FOR_TO
65782: IFFALSE 65979
// begin if building in mc_construct_list [ i ] then
65784: LD_VAR 0 1
65788: PUSH
65789: LD_EXP 106
65793: PUSH
65794: LD_VAR 0 3
65798: ARRAY
65799: IN
65800: IFFALSE 65977
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65802: LD_ADDR_EXP 106
65806: PUSH
65807: LD_EXP 106
65811: PPUSH
65812: LD_VAR 0 3
65816: PPUSH
65817: LD_EXP 106
65821: PUSH
65822: LD_VAR 0 3
65826: ARRAY
65827: PUSH
65828: LD_VAR 0 1
65832: DIFF
65833: PPUSH
65834: CALL_OW 1
65838: ST_TO_ADDR
// if building in mc_lab [ i ] then
65839: LD_VAR 0 1
65843: PUSH
65844: LD_EXP 132
65848: PUSH
65849: LD_VAR 0 3
65853: ARRAY
65854: IN
65855: IFFALSE 65910
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
65857: LD_ADDR_EXP 133
65861: PUSH
65862: LD_EXP 133
65866: PPUSH
65867: LD_VAR 0 3
65871: PPUSH
65872: LD_EXP 133
65876: PUSH
65877: LD_VAR 0 3
65881: ARRAY
65882: PPUSH
65883: LD_INT 1
65885: PPUSH
65886: LD_EXP 133
65890: PUSH
65891: LD_VAR 0 3
65895: ARRAY
65896: PPUSH
65897: LD_INT 0
65899: PPUSH
65900: CALL 71884 0 4
65904: PPUSH
65905: CALL_OW 1
65909: ST_TO_ADDR
// if not building in mc_bases [ i ] then
65910: LD_VAR 0 1
65914: PUSH
65915: LD_EXP 99
65919: PUSH
65920: LD_VAR 0 3
65924: ARRAY
65925: IN
65926: NOT
65927: IFFALSE 65973
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65929: LD_ADDR_EXP 99
65933: PUSH
65934: LD_EXP 99
65938: PPUSH
65939: LD_VAR 0 3
65943: PUSH
65944: LD_EXP 99
65948: PUSH
65949: LD_VAR 0 3
65953: ARRAY
65954: PUSH
65955: LD_INT 1
65957: PLUS
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PPUSH
65963: LD_VAR 0 1
65967: PPUSH
65968: CALL 72466 0 3
65972: ST_TO_ADDR
// exit ;
65973: POP
65974: POP
65975: GO 65981
// end ; end ;
65977: GO 65781
65979: POP
65980: POP
// end ;
65981: LD_VAR 0 2
65985: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
65986: LD_INT 0
65988: PPUSH
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
65994: PPUSH
// if not mc_bases or not skirmish then
65995: LD_EXP 99
65999: NOT
66000: PUSH
66001: LD_EXP 97
66005: NOT
66006: OR
66007: IFFALSE 66011
// exit ;
66009: GO 66672
// for i = 1 to mc_bases do
66011: LD_ADDR_VAR 0 3
66015: PUSH
66016: DOUBLE
66017: LD_INT 1
66019: DEC
66020: ST_TO_ADDR
66021: LD_EXP 99
66025: PUSH
66026: FOR_TO
66027: IFFALSE 66670
// begin if building in mc_construct_list [ i ] then
66029: LD_VAR 0 1
66033: PUSH
66034: LD_EXP 106
66038: PUSH
66039: LD_VAR 0 3
66043: ARRAY
66044: IN
66045: IFFALSE 66668
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66047: LD_ADDR_EXP 106
66051: PUSH
66052: LD_EXP 106
66056: PPUSH
66057: LD_VAR 0 3
66061: PPUSH
66062: LD_EXP 106
66066: PUSH
66067: LD_VAR 0 3
66071: ARRAY
66072: PUSH
66073: LD_VAR 0 1
66077: DIFF
66078: PPUSH
66079: CALL_OW 1
66083: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66084: LD_ADDR_EXP 99
66088: PUSH
66089: LD_EXP 99
66093: PPUSH
66094: LD_VAR 0 3
66098: PUSH
66099: LD_EXP 99
66103: PUSH
66104: LD_VAR 0 3
66108: ARRAY
66109: PUSH
66110: LD_INT 1
66112: PLUS
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PPUSH
66118: LD_VAR 0 1
66122: PPUSH
66123: CALL 72466 0 3
66127: ST_TO_ADDR
// btype := GetBType ( building ) ;
66128: LD_ADDR_VAR 0 5
66132: PUSH
66133: LD_VAR 0 1
66137: PPUSH
66138: CALL_OW 266
66142: ST_TO_ADDR
// side := GetSide ( building ) ;
66143: LD_ADDR_VAR 0 8
66147: PUSH
66148: LD_VAR 0 1
66152: PPUSH
66153: CALL_OW 255
66157: ST_TO_ADDR
// if btype = b_lab then
66158: LD_VAR 0 5
66162: PUSH
66163: LD_INT 6
66165: EQUAL
66166: IFFALSE 66216
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66168: LD_ADDR_EXP 132
66172: PUSH
66173: LD_EXP 132
66177: PPUSH
66178: LD_VAR 0 3
66182: PUSH
66183: LD_EXP 132
66187: PUSH
66188: LD_VAR 0 3
66192: ARRAY
66193: PUSH
66194: LD_INT 1
66196: PLUS
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PPUSH
66202: LD_VAR 0 1
66206: PPUSH
66207: CALL 72466 0 3
66211: ST_TO_ADDR
// exit ;
66212: POP
66213: POP
66214: GO 66672
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66216: LD_VAR 0 5
66220: PUSH
66221: LD_INT 0
66223: PUSH
66224: LD_INT 2
66226: PUSH
66227: LD_INT 4
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: LIST
66234: IN
66235: IFFALSE 66359
// begin if btype = b_armoury then
66237: LD_VAR 0 5
66241: PUSH
66242: LD_INT 4
66244: EQUAL
66245: IFFALSE 66255
// btype := b_barracks ;
66247: LD_ADDR_VAR 0 5
66251: PUSH
66252: LD_INT 5
66254: ST_TO_ADDR
// if btype = b_depot then
66255: LD_VAR 0 5
66259: PUSH
66260: LD_INT 0
66262: EQUAL
66263: IFFALSE 66273
// btype := b_warehouse ;
66265: LD_ADDR_VAR 0 5
66269: PUSH
66270: LD_INT 1
66272: ST_TO_ADDR
// if btype = b_workshop then
66273: LD_VAR 0 5
66277: PUSH
66278: LD_INT 2
66280: EQUAL
66281: IFFALSE 66291
// btype := b_factory ;
66283: LD_ADDR_VAR 0 5
66287: PUSH
66288: LD_INT 3
66290: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66291: LD_VAR 0 5
66295: PPUSH
66296: LD_VAR 0 8
66300: PPUSH
66301: CALL_OW 323
66305: PUSH
66306: LD_INT 1
66308: EQUAL
66309: IFFALSE 66355
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66311: LD_ADDR_EXP 131
66315: PUSH
66316: LD_EXP 131
66320: PPUSH
66321: LD_VAR 0 3
66325: PUSH
66326: LD_EXP 131
66330: PUSH
66331: LD_VAR 0 3
66335: ARRAY
66336: PUSH
66337: LD_INT 1
66339: PLUS
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PPUSH
66345: LD_VAR 0 1
66349: PPUSH
66350: CALL 72466 0 3
66354: ST_TO_ADDR
// exit ;
66355: POP
66356: POP
66357: GO 66672
// end ; if btype in [ b_bunker , b_turret ] then
66359: LD_VAR 0 5
66363: PUSH
66364: LD_INT 32
66366: PUSH
66367: LD_INT 33
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: IN
66374: IFFALSE 66664
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66376: LD_ADDR_EXP 107
66380: PUSH
66381: LD_EXP 107
66385: PPUSH
66386: LD_VAR 0 3
66390: PUSH
66391: LD_EXP 107
66395: PUSH
66396: LD_VAR 0 3
66400: ARRAY
66401: PUSH
66402: LD_INT 1
66404: PLUS
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PPUSH
66410: LD_VAR 0 1
66414: PPUSH
66415: CALL 72466 0 3
66419: ST_TO_ADDR
// if btype = b_bunker then
66420: LD_VAR 0 5
66424: PUSH
66425: LD_INT 32
66427: EQUAL
66428: IFFALSE 66664
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66430: LD_ADDR_EXP 108
66434: PUSH
66435: LD_EXP 108
66439: PPUSH
66440: LD_VAR 0 3
66444: PUSH
66445: LD_EXP 108
66449: PUSH
66450: LD_VAR 0 3
66454: ARRAY
66455: PUSH
66456: LD_INT 1
66458: PLUS
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PPUSH
66464: LD_VAR 0 1
66468: PPUSH
66469: CALL 72466 0 3
66473: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66474: LD_ADDR_VAR 0 6
66478: PUSH
66479: LD_EXP 99
66483: PUSH
66484: LD_VAR 0 3
66488: ARRAY
66489: PPUSH
66490: LD_INT 25
66492: PUSH
66493: LD_INT 1
66495: PUSH
66496: EMPTY
66497: LIST
66498: LIST
66499: PUSH
66500: LD_INT 3
66502: PUSH
66503: LD_INT 54
66505: PUSH
66506: EMPTY
66507: LIST
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PPUSH
66517: CALL_OW 72
66521: ST_TO_ADDR
// if tmp then
66522: LD_VAR 0 6
66526: IFFALSE 66532
// exit ;
66528: POP
66529: POP
66530: GO 66672
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66532: LD_ADDR_VAR 0 6
66536: PUSH
66537: LD_EXP 99
66541: PUSH
66542: LD_VAR 0 3
66546: ARRAY
66547: PPUSH
66548: LD_INT 2
66550: PUSH
66551: LD_INT 30
66553: PUSH
66554: LD_INT 4
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 30
66563: PUSH
66564: LD_INT 5
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: EMPTY
66572: LIST
66573: LIST
66574: LIST
66575: PPUSH
66576: CALL_OW 72
66580: ST_TO_ADDR
// if not tmp then
66581: LD_VAR 0 6
66585: NOT
66586: IFFALSE 66592
// exit ;
66588: POP
66589: POP
66590: GO 66672
// for j in tmp do
66592: LD_ADDR_VAR 0 4
66596: PUSH
66597: LD_VAR 0 6
66601: PUSH
66602: FOR_IN
66603: IFFALSE 66662
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66605: LD_ADDR_VAR 0 7
66609: PUSH
66610: LD_VAR 0 4
66614: PPUSH
66615: CALL_OW 313
66619: PPUSH
66620: LD_INT 25
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PPUSH
66630: CALL_OW 72
66634: ST_TO_ADDR
// if units then
66635: LD_VAR 0 7
66639: IFFALSE 66660
// begin ComExitBuilding ( units [ 1 ] ) ;
66641: LD_VAR 0 7
66645: PUSH
66646: LD_INT 1
66648: ARRAY
66649: PPUSH
66650: CALL_OW 122
// exit ;
66654: POP
66655: POP
66656: POP
66657: POP
66658: GO 66672
// end ; end ;
66660: GO 66602
66662: POP
66663: POP
// end ; end ; exit ;
66664: POP
66665: POP
66666: GO 66672
// end ; end ;
66668: GO 66026
66670: POP
66671: POP
// end ;
66672: LD_VAR 0 2
66676: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66677: LD_INT 0
66679: PPUSH
66680: PPUSH
66681: PPUSH
66682: PPUSH
66683: PPUSH
66684: PPUSH
66685: PPUSH
// if not mc_bases or not skirmish then
66686: LD_EXP 99
66690: NOT
66691: PUSH
66692: LD_EXP 97
66696: NOT
66697: OR
66698: IFFALSE 66702
// exit ;
66700: GO 66967
// btype := GetBType ( building ) ;
66702: LD_ADDR_VAR 0 6
66706: PUSH
66707: LD_VAR 0 1
66711: PPUSH
66712: CALL_OW 266
66716: ST_TO_ADDR
// x := GetX ( building ) ;
66717: LD_ADDR_VAR 0 7
66721: PUSH
66722: LD_VAR 0 1
66726: PPUSH
66727: CALL_OW 250
66731: ST_TO_ADDR
// y := GetY ( building ) ;
66732: LD_ADDR_VAR 0 8
66736: PUSH
66737: LD_VAR 0 1
66741: PPUSH
66742: CALL_OW 251
66746: ST_TO_ADDR
// d := GetDir ( building ) ;
66747: LD_ADDR_VAR 0 9
66751: PUSH
66752: LD_VAR 0 1
66756: PPUSH
66757: CALL_OW 254
66761: ST_TO_ADDR
// for i = 1 to mc_bases do
66762: LD_ADDR_VAR 0 4
66766: PUSH
66767: DOUBLE
66768: LD_INT 1
66770: DEC
66771: ST_TO_ADDR
66772: LD_EXP 99
66776: PUSH
66777: FOR_TO
66778: IFFALSE 66965
// begin if not mc_build_list [ i ] then
66780: LD_EXP 104
66784: PUSH
66785: LD_VAR 0 4
66789: ARRAY
66790: NOT
66791: IFFALSE 66795
// continue ;
66793: GO 66777
// for j := 1 to mc_build_list [ i ] do
66795: LD_ADDR_VAR 0 5
66799: PUSH
66800: DOUBLE
66801: LD_INT 1
66803: DEC
66804: ST_TO_ADDR
66805: LD_EXP 104
66809: PUSH
66810: LD_VAR 0 4
66814: ARRAY
66815: PUSH
66816: FOR_TO
66817: IFFALSE 66961
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
66819: LD_VAR 0 6
66823: PUSH
66824: LD_VAR 0 7
66828: PUSH
66829: LD_VAR 0 8
66833: PUSH
66834: LD_VAR 0 9
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: PPUSH
66845: LD_EXP 104
66849: PUSH
66850: LD_VAR 0 4
66854: ARRAY
66855: PUSH
66856: LD_VAR 0 5
66860: ARRAY
66861: PPUSH
66862: CALL 78646 0 2
66866: IFFALSE 66959
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
66868: LD_ADDR_EXP 104
66872: PUSH
66873: LD_EXP 104
66877: PPUSH
66878: LD_VAR 0 4
66882: PPUSH
66883: LD_EXP 104
66887: PUSH
66888: LD_VAR 0 4
66892: ARRAY
66893: PPUSH
66894: LD_VAR 0 5
66898: PPUSH
66899: CALL_OW 3
66903: PPUSH
66904: CALL_OW 1
66908: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
66909: LD_ADDR_EXP 106
66913: PUSH
66914: LD_EXP 106
66918: PPUSH
66919: LD_VAR 0 4
66923: PUSH
66924: LD_EXP 106
66928: PUSH
66929: LD_VAR 0 4
66933: ARRAY
66934: PUSH
66935: LD_INT 1
66937: PLUS
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PPUSH
66943: LD_VAR 0 1
66947: PPUSH
66948: CALL 72466 0 3
66952: ST_TO_ADDR
// exit ;
66953: POP
66954: POP
66955: POP
66956: POP
66957: GO 66967
// end ;
66959: GO 66816
66961: POP
66962: POP
// end ;
66963: GO 66777
66965: POP
66966: POP
// end ;
66967: LD_VAR 0 3
66971: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
66972: LD_INT 0
66974: PPUSH
66975: PPUSH
66976: PPUSH
// if not mc_bases or not skirmish then
66977: LD_EXP 99
66981: NOT
66982: PUSH
66983: LD_EXP 97
66987: NOT
66988: OR
66989: IFFALSE 66993
// exit ;
66991: GO 67183
// for i = 1 to mc_bases do
66993: LD_ADDR_VAR 0 4
66997: PUSH
66998: DOUBLE
66999: LD_INT 1
67001: DEC
67002: ST_TO_ADDR
67003: LD_EXP 99
67007: PUSH
67008: FOR_TO
67009: IFFALSE 67096
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67011: LD_VAR 0 1
67015: PUSH
67016: LD_EXP 107
67020: PUSH
67021: LD_VAR 0 4
67025: ARRAY
67026: IN
67027: PUSH
67028: LD_VAR 0 1
67032: PUSH
67033: LD_EXP 108
67037: PUSH
67038: LD_VAR 0 4
67042: ARRAY
67043: IN
67044: NOT
67045: AND
67046: IFFALSE 67094
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67048: LD_ADDR_EXP 108
67052: PUSH
67053: LD_EXP 108
67057: PPUSH
67058: LD_VAR 0 4
67062: PUSH
67063: LD_EXP 108
67067: PUSH
67068: LD_VAR 0 4
67072: ARRAY
67073: PUSH
67074: LD_INT 1
67076: PLUS
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PPUSH
67082: LD_VAR 0 1
67086: PPUSH
67087: CALL 72466 0 3
67091: ST_TO_ADDR
// break ;
67092: GO 67096
// end ; end ;
67094: GO 67008
67096: POP
67097: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67098: LD_VAR 0 1
67102: PPUSH
67103: CALL_OW 257
67107: PUSH
67108: LD_EXP 125
67112: IN
67113: PUSH
67114: LD_VAR 0 1
67118: PPUSH
67119: CALL_OW 266
67123: PUSH
67124: LD_INT 5
67126: EQUAL
67127: AND
67128: PUSH
67129: LD_VAR 0 2
67133: PPUSH
67134: CALL_OW 110
67138: PUSH
67139: LD_INT 18
67141: NONEQUAL
67142: AND
67143: IFFALSE 67183
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67145: LD_VAR 0 2
67149: PPUSH
67150: CALL_OW 257
67154: PUSH
67155: LD_INT 5
67157: PUSH
67158: LD_INT 8
67160: PUSH
67161: LD_INT 9
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: LIST
67168: IN
67169: IFFALSE 67183
// SetClass ( unit , 1 ) ;
67171: LD_VAR 0 2
67175: PPUSH
67176: LD_INT 1
67178: PPUSH
67179: CALL_OW 336
// end ;
67183: LD_VAR 0 3
67187: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67188: LD_INT 0
67190: PPUSH
67191: PPUSH
// if not mc_bases or not skirmish then
67192: LD_EXP 99
67196: NOT
67197: PUSH
67198: LD_EXP 97
67202: NOT
67203: OR
67204: IFFALSE 67208
// exit ;
67206: GO 67324
// if GetLives ( abandoned_vehicle ) > 250 then
67208: LD_VAR 0 2
67212: PPUSH
67213: CALL_OW 256
67217: PUSH
67218: LD_INT 250
67220: GREATER
67221: IFFALSE 67225
// exit ;
67223: GO 67324
// for i = 1 to mc_bases do
67225: LD_ADDR_VAR 0 6
67229: PUSH
67230: DOUBLE
67231: LD_INT 1
67233: DEC
67234: ST_TO_ADDR
67235: LD_EXP 99
67239: PUSH
67240: FOR_TO
67241: IFFALSE 67322
// begin if driver in mc_bases [ i ] then
67243: LD_VAR 0 1
67247: PUSH
67248: LD_EXP 99
67252: PUSH
67253: LD_VAR 0 6
67257: ARRAY
67258: IN
67259: IFFALSE 67320
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67261: LD_VAR 0 1
67265: PPUSH
67266: LD_EXP 99
67270: PUSH
67271: LD_VAR 0 6
67275: ARRAY
67276: PPUSH
67277: LD_INT 2
67279: PUSH
67280: LD_INT 30
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 30
67292: PUSH
67293: LD_INT 1
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: LIST
67304: PPUSH
67305: CALL_OW 72
67309: PUSH
67310: LD_INT 1
67312: ARRAY
67313: PPUSH
67314: CALL 105655 0 2
// break ;
67318: GO 67322
// end ; end ;
67320: GO 67240
67322: POP
67323: POP
// end ; end_of_file
67324: LD_VAR 0 5
67328: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67329: LD_INT 0
67331: PPUSH
67332: PPUSH
// if exist_mode then
67333: LD_VAR 0 2
67337: IFFALSE 67362
// unit := CreateCharacter ( prefix & ident ) else
67339: LD_ADDR_VAR 0 5
67343: PUSH
67344: LD_VAR 0 3
67348: PUSH
67349: LD_VAR 0 1
67353: STR
67354: PPUSH
67355: CALL_OW 34
67359: ST_TO_ADDR
67360: GO 67377
// unit := NewCharacter ( ident ) ;
67362: LD_ADDR_VAR 0 5
67366: PUSH
67367: LD_VAR 0 1
67371: PPUSH
67372: CALL_OW 25
67376: ST_TO_ADDR
// result := unit ;
67377: LD_ADDR_VAR 0 4
67381: PUSH
67382: LD_VAR 0 5
67386: ST_TO_ADDR
// end ;
67387: LD_VAR 0 4
67391: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67392: LD_INT 0
67394: PPUSH
67395: PPUSH
// if not side or not nation then
67396: LD_VAR 0 1
67400: NOT
67401: PUSH
67402: LD_VAR 0 2
67406: NOT
67407: OR
67408: IFFALSE 67412
// exit ;
67410: GO 68180
// case nation of nation_american :
67412: LD_VAR 0 2
67416: PUSH
67417: LD_INT 1
67419: DOUBLE
67420: EQUAL
67421: IFTRUE 67425
67423: GO 67639
67425: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67426: LD_ADDR_VAR 0 4
67430: PUSH
67431: LD_INT 35
67433: PUSH
67434: LD_INT 45
67436: PUSH
67437: LD_INT 46
67439: PUSH
67440: LD_INT 47
67442: PUSH
67443: LD_INT 82
67445: PUSH
67446: LD_INT 83
67448: PUSH
67449: LD_INT 84
67451: PUSH
67452: LD_INT 85
67454: PUSH
67455: LD_INT 86
67457: PUSH
67458: LD_INT 1
67460: PUSH
67461: LD_INT 2
67463: PUSH
67464: LD_INT 6
67466: PUSH
67467: LD_INT 15
67469: PUSH
67470: LD_INT 16
67472: PUSH
67473: LD_INT 7
67475: PUSH
67476: LD_INT 12
67478: PUSH
67479: LD_INT 13
67481: PUSH
67482: LD_INT 10
67484: PUSH
67485: LD_INT 14
67487: PUSH
67488: LD_INT 20
67490: PUSH
67491: LD_INT 21
67493: PUSH
67494: LD_INT 22
67496: PUSH
67497: LD_INT 25
67499: PUSH
67500: LD_INT 32
67502: PUSH
67503: LD_INT 27
67505: PUSH
67506: LD_INT 36
67508: PUSH
67509: LD_INT 69
67511: PUSH
67512: LD_INT 39
67514: PUSH
67515: LD_INT 34
67517: PUSH
67518: LD_INT 40
67520: PUSH
67521: LD_INT 48
67523: PUSH
67524: LD_INT 49
67526: PUSH
67527: LD_INT 50
67529: PUSH
67530: LD_INT 51
67532: PUSH
67533: LD_INT 52
67535: PUSH
67536: LD_INT 53
67538: PUSH
67539: LD_INT 54
67541: PUSH
67542: LD_INT 55
67544: PUSH
67545: LD_INT 56
67547: PUSH
67548: LD_INT 57
67550: PUSH
67551: LD_INT 58
67553: PUSH
67554: LD_INT 59
67556: PUSH
67557: LD_INT 60
67559: PUSH
67560: LD_INT 61
67562: PUSH
67563: LD_INT 62
67565: PUSH
67566: LD_INT 80
67568: PUSH
67569: LD_INT 82
67571: PUSH
67572: LD_INT 83
67574: PUSH
67575: LD_INT 84
67577: PUSH
67578: LD_INT 85
67580: PUSH
67581: LD_INT 86
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: ST_TO_ADDR
67637: GO 68104
67639: LD_INT 2
67641: DOUBLE
67642: EQUAL
67643: IFTRUE 67647
67645: GO 67873
67647: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67648: LD_ADDR_VAR 0 4
67652: PUSH
67653: LD_INT 35
67655: PUSH
67656: LD_INT 45
67658: PUSH
67659: LD_INT 46
67661: PUSH
67662: LD_INT 47
67664: PUSH
67665: LD_INT 82
67667: PUSH
67668: LD_INT 83
67670: PUSH
67671: LD_INT 84
67673: PUSH
67674: LD_INT 85
67676: PUSH
67677: LD_INT 87
67679: PUSH
67680: LD_INT 70
67682: PUSH
67683: LD_INT 1
67685: PUSH
67686: LD_INT 11
67688: PUSH
67689: LD_INT 3
67691: PUSH
67692: LD_INT 4
67694: PUSH
67695: LD_INT 5
67697: PUSH
67698: LD_INT 6
67700: PUSH
67701: LD_INT 15
67703: PUSH
67704: LD_INT 18
67706: PUSH
67707: LD_INT 7
67709: PUSH
67710: LD_INT 17
67712: PUSH
67713: LD_INT 8
67715: PUSH
67716: LD_INT 20
67718: PUSH
67719: LD_INT 21
67721: PUSH
67722: LD_INT 22
67724: PUSH
67725: LD_INT 72
67727: PUSH
67728: LD_INT 26
67730: PUSH
67731: LD_INT 69
67733: PUSH
67734: LD_INT 39
67736: PUSH
67737: LD_INT 40
67739: PUSH
67740: LD_INT 41
67742: PUSH
67743: LD_INT 42
67745: PUSH
67746: LD_INT 43
67748: PUSH
67749: LD_INT 48
67751: PUSH
67752: LD_INT 49
67754: PUSH
67755: LD_INT 50
67757: PUSH
67758: LD_INT 51
67760: PUSH
67761: LD_INT 52
67763: PUSH
67764: LD_INT 53
67766: PUSH
67767: LD_INT 54
67769: PUSH
67770: LD_INT 55
67772: PUSH
67773: LD_INT 56
67775: PUSH
67776: LD_INT 60
67778: PUSH
67779: LD_INT 61
67781: PUSH
67782: LD_INT 62
67784: PUSH
67785: LD_INT 66
67787: PUSH
67788: LD_INT 67
67790: PUSH
67791: LD_INT 68
67793: PUSH
67794: LD_INT 81
67796: PUSH
67797: LD_INT 82
67799: PUSH
67800: LD_INT 83
67802: PUSH
67803: LD_INT 84
67805: PUSH
67806: LD_INT 85
67808: PUSH
67809: LD_INT 87
67811: PUSH
67812: LD_INT 88
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: LIST
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: ST_TO_ADDR
67871: GO 68104
67873: LD_INT 3
67875: DOUBLE
67876: EQUAL
67877: IFTRUE 67881
67879: GO 68103
67881: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
67882: LD_ADDR_VAR 0 4
67886: PUSH
67887: LD_INT 46
67889: PUSH
67890: LD_INT 47
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: LD_INT 2
67898: PUSH
67899: LD_INT 82
67901: PUSH
67902: LD_INT 83
67904: PUSH
67905: LD_INT 84
67907: PUSH
67908: LD_INT 85
67910: PUSH
67911: LD_INT 86
67913: PUSH
67914: LD_INT 11
67916: PUSH
67917: LD_INT 9
67919: PUSH
67920: LD_INT 20
67922: PUSH
67923: LD_INT 19
67925: PUSH
67926: LD_INT 21
67928: PUSH
67929: LD_INT 24
67931: PUSH
67932: LD_INT 22
67934: PUSH
67935: LD_INT 25
67937: PUSH
67938: LD_INT 28
67940: PUSH
67941: LD_INT 29
67943: PUSH
67944: LD_INT 30
67946: PUSH
67947: LD_INT 31
67949: PUSH
67950: LD_INT 37
67952: PUSH
67953: LD_INT 38
67955: PUSH
67956: LD_INT 32
67958: PUSH
67959: LD_INT 27
67961: PUSH
67962: LD_INT 33
67964: PUSH
67965: LD_INT 69
67967: PUSH
67968: LD_INT 39
67970: PUSH
67971: LD_INT 34
67973: PUSH
67974: LD_INT 40
67976: PUSH
67977: LD_INT 71
67979: PUSH
67980: LD_INT 23
67982: PUSH
67983: LD_INT 44
67985: PUSH
67986: LD_INT 48
67988: PUSH
67989: LD_INT 49
67991: PUSH
67992: LD_INT 50
67994: PUSH
67995: LD_INT 51
67997: PUSH
67998: LD_INT 52
68000: PUSH
68001: LD_INT 53
68003: PUSH
68004: LD_INT 54
68006: PUSH
68007: LD_INT 55
68009: PUSH
68010: LD_INT 56
68012: PUSH
68013: LD_INT 57
68015: PUSH
68016: LD_INT 58
68018: PUSH
68019: LD_INT 59
68021: PUSH
68022: LD_INT 63
68024: PUSH
68025: LD_INT 64
68027: PUSH
68028: LD_INT 65
68030: PUSH
68031: LD_INT 82
68033: PUSH
68034: LD_INT 83
68036: PUSH
68037: LD_INT 84
68039: PUSH
68040: LD_INT 85
68042: PUSH
68043: LD_INT 86
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: ST_TO_ADDR
68101: GO 68104
68103: POP
// if state > - 1 and state < 3 then
68104: LD_VAR 0 3
68108: PUSH
68109: LD_INT 1
68111: NEG
68112: GREATER
68113: PUSH
68114: LD_VAR 0 3
68118: PUSH
68119: LD_INT 3
68121: LESS
68122: AND
68123: IFFALSE 68180
// for i in result do
68125: LD_ADDR_VAR 0 5
68129: PUSH
68130: LD_VAR 0 4
68134: PUSH
68135: FOR_IN
68136: IFFALSE 68178
// if GetTech ( i , side ) <> state then
68138: LD_VAR 0 5
68142: PPUSH
68143: LD_VAR 0 1
68147: PPUSH
68148: CALL_OW 321
68152: PUSH
68153: LD_VAR 0 3
68157: NONEQUAL
68158: IFFALSE 68176
// result := result diff i ;
68160: LD_ADDR_VAR 0 4
68164: PUSH
68165: LD_VAR 0 4
68169: PUSH
68170: LD_VAR 0 5
68174: DIFF
68175: ST_TO_ADDR
68176: GO 68135
68178: POP
68179: POP
// end ;
68180: LD_VAR 0 4
68184: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68185: LD_INT 0
68187: PPUSH
68188: PPUSH
68189: PPUSH
// result := true ;
68190: LD_ADDR_VAR 0 3
68194: PUSH
68195: LD_INT 1
68197: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68198: LD_ADDR_VAR 0 5
68202: PUSH
68203: LD_VAR 0 2
68207: PPUSH
68208: CALL_OW 480
68212: ST_TO_ADDR
// if not tmp then
68213: LD_VAR 0 5
68217: NOT
68218: IFFALSE 68222
// exit ;
68220: GO 68271
// for i in tmp do
68222: LD_ADDR_VAR 0 4
68226: PUSH
68227: LD_VAR 0 5
68231: PUSH
68232: FOR_IN
68233: IFFALSE 68269
// if GetTech ( i , side ) <> state_researched then
68235: LD_VAR 0 4
68239: PPUSH
68240: LD_VAR 0 1
68244: PPUSH
68245: CALL_OW 321
68249: PUSH
68250: LD_INT 2
68252: NONEQUAL
68253: IFFALSE 68267
// begin result := false ;
68255: LD_ADDR_VAR 0 3
68259: PUSH
68260: LD_INT 0
68262: ST_TO_ADDR
// exit ;
68263: POP
68264: POP
68265: GO 68271
// end ;
68267: GO 68232
68269: POP
68270: POP
// end ;
68271: LD_VAR 0 3
68275: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68276: LD_INT 0
68278: PPUSH
68279: PPUSH
68280: PPUSH
68281: PPUSH
68282: PPUSH
68283: PPUSH
68284: PPUSH
68285: PPUSH
68286: PPUSH
68287: PPUSH
68288: PPUSH
68289: PPUSH
68290: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68291: LD_VAR 0 1
68295: NOT
68296: PUSH
68297: LD_VAR 0 1
68301: PPUSH
68302: CALL_OW 257
68306: PUSH
68307: LD_INT 9
68309: NONEQUAL
68310: OR
68311: IFFALSE 68315
// exit ;
68313: GO 68888
// side := GetSide ( unit ) ;
68315: LD_ADDR_VAR 0 9
68319: PUSH
68320: LD_VAR 0 1
68324: PPUSH
68325: CALL_OW 255
68329: ST_TO_ADDR
// tech_space := tech_spacanom ;
68330: LD_ADDR_VAR 0 12
68334: PUSH
68335: LD_INT 29
68337: ST_TO_ADDR
// tech_time := tech_taurad ;
68338: LD_ADDR_VAR 0 13
68342: PUSH
68343: LD_INT 28
68345: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68346: LD_ADDR_VAR 0 11
68350: PUSH
68351: LD_VAR 0 1
68355: PPUSH
68356: CALL_OW 310
68360: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68361: LD_VAR 0 11
68365: PPUSH
68366: CALL_OW 247
68370: PUSH
68371: LD_INT 2
68373: EQUAL
68374: IFFALSE 68378
// exit ;
68376: GO 68888
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68378: LD_ADDR_VAR 0 8
68382: PUSH
68383: LD_INT 81
68385: PUSH
68386: LD_VAR 0 9
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 3
68397: PUSH
68398: LD_INT 21
68400: PUSH
68401: LD_INT 3
68403: PUSH
68404: EMPTY
68405: LIST
68406: LIST
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PPUSH
68416: CALL_OW 69
68420: ST_TO_ADDR
// if not tmp then
68421: LD_VAR 0 8
68425: NOT
68426: IFFALSE 68430
// exit ;
68428: GO 68888
// if in_unit then
68430: LD_VAR 0 11
68434: IFFALSE 68458
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68436: LD_ADDR_VAR 0 10
68440: PUSH
68441: LD_VAR 0 8
68445: PPUSH
68446: LD_VAR 0 11
68450: PPUSH
68451: CALL_OW 74
68455: ST_TO_ADDR
68456: GO 68478
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68458: LD_ADDR_VAR 0 10
68462: PUSH
68463: LD_VAR 0 8
68467: PPUSH
68468: LD_VAR 0 1
68472: PPUSH
68473: CALL_OW 74
68477: ST_TO_ADDR
// if not enemy then
68478: LD_VAR 0 10
68482: NOT
68483: IFFALSE 68487
// exit ;
68485: GO 68888
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68487: LD_VAR 0 11
68491: PUSH
68492: LD_VAR 0 11
68496: PPUSH
68497: LD_VAR 0 10
68501: PPUSH
68502: CALL_OW 296
68506: PUSH
68507: LD_INT 13
68509: GREATER
68510: AND
68511: PUSH
68512: LD_VAR 0 1
68516: PPUSH
68517: LD_VAR 0 10
68521: PPUSH
68522: CALL_OW 296
68526: PUSH
68527: LD_INT 12
68529: GREATER
68530: OR
68531: IFFALSE 68535
// exit ;
68533: GO 68888
// missile := [ 1 ] ;
68535: LD_ADDR_VAR 0 14
68539: PUSH
68540: LD_INT 1
68542: PUSH
68543: EMPTY
68544: LIST
68545: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68546: LD_VAR 0 9
68550: PPUSH
68551: LD_VAR 0 12
68555: PPUSH
68556: CALL_OW 325
68560: IFFALSE 68589
// missile := Replace ( missile , missile + 1 , 2 ) ;
68562: LD_ADDR_VAR 0 14
68566: PUSH
68567: LD_VAR 0 14
68571: PPUSH
68572: LD_VAR 0 14
68576: PUSH
68577: LD_INT 1
68579: PLUS
68580: PPUSH
68581: LD_INT 2
68583: PPUSH
68584: CALL_OW 1
68588: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68589: LD_VAR 0 9
68593: PPUSH
68594: LD_VAR 0 13
68598: PPUSH
68599: CALL_OW 325
68603: PUSH
68604: LD_VAR 0 10
68608: PPUSH
68609: CALL_OW 255
68613: PPUSH
68614: LD_VAR 0 13
68618: PPUSH
68619: CALL_OW 325
68623: NOT
68624: AND
68625: IFFALSE 68654
// missile := Replace ( missile , missile + 1 , 3 ) ;
68627: LD_ADDR_VAR 0 14
68631: PUSH
68632: LD_VAR 0 14
68636: PPUSH
68637: LD_VAR 0 14
68641: PUSH
68642: LD_INT 1
68644: PLUS
68645: PPUSH
68646: LD_INT 3
68648: PPUSH
68649: CALL_OW 1
68653: ST_TO_ADDR
// if missile < 2 then
68654: LD_VAR 0 14
68658: PUSH
68659: LD_INT 2
68661: LESS
68662: IFFALSE 68666
// exit ;
68664: GO 68888
// x := GetX ( enemy ) ;
68666: LD_ADDR_VAR 0 4
68670: PUSH
68671: LD_VAR 0 10
68675: PPUSH
68676: CALL_OW 250
68680: ST_TO_ADDR
// y := GetY ( enemy ) ;
68681: LD_ADDR_VAR 0 5
68685: PUSH
68686: LD_VAR 0 10
68690: PPUSH
68691: CALL_OW 251
68695: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68696: LD_ADDR_VAR 0 6
68700: PUSH
68701: LD_VAR 0 4
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PPUSH
68710: LD_INT 1
68712: PPUSH
68713: CALL_OW 12
68717: PLUS
68718: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68719: LD_ADDR_VAR 0 7
68723: PUSH
68724: LD_VAR 0 5
68728: PUSH
68729: LD_INT 1
68731: NEG
68732: PPUSH
68733: LD_INT 1
68735: PPUSH
68736: CALL_OW 12
68740: PLUS
68741: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68742: LD_VAR 0 6
68746: PPUSH
68747: LD_VAR 0 7
68751: PPUSH
68752: CALL_OW 488
68756: NOT
68757: IFFALSE 68779
// begin _x := x ;
68759: LD_ADDR_VAR 0 6
68763: PUSH
68764: LD_VAR 0 4
68768: ST_TO_ADDR
// _y := y ;
68769: LD_ADDR_VAR 0 7
68773: PUSH
68774: LD_VAR 0 5
68778: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68779: LD_ADDR_VAR 0 3
68783: PUSH
68784: LD_INT 1
68786: PPUSH
68787: LD_VAR 0 14
68791: PPUSH
68792: CALL_OW 12
68796: ST_TO_ADDR
// case i of 1 :
68797: LD_VAR 0 3
68801: PUSH
68802: LD_INT 1
68804: DOUBLE
68805: EQUAL
68806: IFTRUE 68810
68808: GO 68827
68810: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68811: LD_VAR 0 1
68815: PPUSH
68816: LD_VAR 0 10
68820: PPUSH
68821: CALL_OW 115
68825: GO 68888
68827: LD_INT 2
68829: DOUBLE
68830: EQUAL
68831: IFTRUE 68835
68833: GO 68857
68835: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
68836: LD_VAR 0 1
68840: PPUSH
68841: LD_VAR 0 6
68845: PPUSH
68846: LD_VAR 0 7
68850: PPUSH
68851: CALL_OW 153
68855: GO 68888
68857: LD_INT 3
68859: DOUBLE
68860: EQUAL
68861: IFTRUE 68865
68863: GO 68887
68865: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
68866: LD_VAR 0 1
68870: PPUSH
68871: LD_VAR 0 6
68875: PPUSH
68876: LD_VAR 0 7
68880: PPUSH
68881: CALL_OW 154
68885: GO 68888
68887: POP
// end ;
68888: LD_VAR 0 2
68892: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
68893: LD_INT 0
68895: PPUSH
68896: PPUSH
68897: PPUSH
68898: PPUSH
68899: PPUSH
68900: PPUSH
// if not unit or not building then
68901: LD_VAR 0 1
68905: NOT
68906: PUSH
68907: LD_VAR 0 2
68911: NOT
68912: OR
68913: IFFALSE 68917
// exit ;
68915: GO 69075
// x := GetX ( building ) ;
68917: LD_ADDR_VAR 0 5
68921: PUSH
68922: LD_VAR 0 2
68926: PPUSH
68927: CALL_OW 250
68931: ST_TO_ADDR
// y := GetY ( building ) ;
68932: LD_ADDR_VAR 0 6
68936: PUSH
68937: LD_VAR 0 2
68941: PPUSH
68942: CALL_OW 251
68946: ST_TO_ADDR
// for i = 0 to 5 do
68947: LD_ADDR_VAR 0 4
68951: PUSH
68952: DOUBLE
68953: LD_INT 0
68955: DEC
68956: ST_TO_ADDR
68957: LD_INT 5
68959: PUSH
68960: FOR_TO
68961: IFFALSE 69073
// begin _x := ShiftX ( x , i , 3 ) ;
68963: LD_ADDR_VAR 0 7
68967: PUSH
68968: LD_VAR 0 5
68972: PPUSH
68973: LD_VAR 0 4
68977: PPUSH
68978: LD_INT 3
68980: PPUSH
68981: CALL_OW 272
68985: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
68986: LD_ADDR_VAR 0 8
68990: PUSH
68991: LD_VAR 0 6
68995: PPUSH
68996: LD_VAR 0 4
69000: PPUSH
69001: LD_INT 3
69003: PPUSH
69004: CALL_OW 273
69008: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69009: LD_VAR 0 7
69013: PPUSH
69014: LD_VAR 0 8
69018: PPUSH
69019: CALL_OW 488
69023: NOT
69024: IFFALSE 69028
// continue ;
69026: GO 68960
// if HexInfo ( _x , _y ) = 0 then
69028: LD_VAR 0 7
69032: PPUSH
69033: LD_VAR 0 8
69037: PPUSH
69038: CALL_OW 428
69042: PUSH
69043: LD_INT 0
69045: EQUAL
69046: IFFALSE 69071
// begin ComMoveXY ( unit , _x , _y ) ;
69048: LD_VAR 0 1
69052: PPUSH
69053: LD_VAR 0 7
69057: PPUSH
69058: LD_VAR 0 8
69062: PPUSH
69063: CALL_OW 111
// exit ;
69067: POP
69068: POP
69069: GO 69075
// end ; end ;
69071: GO 68960
69073: POP
69074: POP
// end ;
69075: LD_VAR 0 3
69079: RET
// export function ScanBase ( side , base_area ) ; begin
69080: LD_INT 0
69082: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69083: LD_ADDR_VAR 0 3
69087: PUSH
69088: LD_VAR 0 2
69092: PPUSH
69093: LD_INT 81
69095: PUSH
69096: LD_VAR 0 1
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PPUSH
69105: CALL_OW 70
69109: ST_TO_ADDR
// end ;
69110: LD_VAR 0 3
69114: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69115: LD_INT 0
69117: PPUSH
69118: PPUSH
69119: PPUSH
69120: PPUSH
// result := false ;
69121: LD_ADDR_VAR 0 2
69125: PUSH
69126: LD_INT 0
69128: ST_TO_ADDR
// side := GetSide ( unit ) ;
69129: LD_ADDR_VAR 0 3
69133: PUSH
69134: LD_VAR 0 1
69138: PPUSH
69139: CALL_OW 255
69143: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69144: LD_ADDR_VAR 0 4
69148: PUSH
69149: LD_VAR 0 1
69153: PPUSH
69154: CALL_OW 248
69158: ST_TO_ADDR
// case nat of 1 :
69159: LD_VAR 0 4
69163: PUSH
69164: LD_INT 1
69166: DOUBLE
69167: EQUAL
69168: IFTRUE 69172
69170: GO 69183
69172: POP
// tech := tech_lassight ; 2 :
69173: LD_ADDR_VAR 0 5
69177: PUSH
69178: LD_INT 12
69180: ST_TO_ADDR
69181: GO 69222
69183: LD_INT 2
69185: DOUBLE
69186: EQUAL
69187: IFTRUE 69191
69189: GO 69202
69191: POP
// tech := tech_mortar ; 3 :
69192: LD_ADDR_VAR 0 5
69196: PUSH
69197: LD_INT 41
69199: ST_TO_ADDR
69200: GO 69222
69202: LD_INT 3
69204: DOUBLE
69205: EQUAL
69206: IFTRUE 69210
69208: GO 69221
69210: POP
// tech := tech_bazooka ; end ;
69211: LD_ADDR_VAR 0 5
69215: PUSH
69216: LD_INT 44
69218: ST_TO_ADDR
69219: GO 69222
69221: POP
// if Researched ( side , tech ) then
69222: LD_VAR 0 3
69226: PPUSH
69227: LD_VAR 0 5
69231: PPUSH
69232: CALL_OW 325
69236: IFFALSE 69263
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69238: LD_ADDR_VAR 0 2
69242: PUSH
69243: LD_INT 5
69245: PUSH
69246: LD_INT 8
69248: PUSH
69249: LD_INT 9
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: LIST
69256: PUSH
69257: LD_VAR 0 4
69261: ARRAY
69262: ST_TO_ADDR
// end ;
69263: LD_VAR 0 2
69267: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69268: LD_INT 0
69270: PPUSH
69271: PPUSH
69272: PPUSH
// if not mines then
69273: LD_VAR 0 2
69277: NOT
69278: IFFALSE 69282
// exit ;
69280: GO 69426
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69282: LD_ADDR_VAR 0 5
69286: PUSH
69287: LD_INT 81
69289: PUSH
69290: LD_VAR 0 1
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 3
69301: PUSH
69302: LD_INT 21
69304: PUSH
69305: LD_INT 3
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: EMPTY
69313: LIST
69314: LIST
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PPUSH
69320: CALL_OW 69
69324: ST_TO_ADDR
// for i in mines do
69325: LD_ADDR_VAR 0 4
69329: PUSH
69330: LD_VAR 0 2
69334: PUSH
69335: FOR_IN
69336: IFFALSE 69424
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69338: LD_VAR 0 4
69342: PUSH
69343: LD_INT 1
69345: ARRAY
69346: PPUSH
69347: LD_VAR 0 4
69351: PUSH
69352: LD_INT 2
69354: ARRAY
69355: PPUSH
69356: CALL_OW 458
69360: NOT
69361: IFFALSE 69365
// continue ;
69363: GO 69335
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69365: LD_VAR 0 4
69369: PUSH
69370: LD_INT 1
69372: ARRAY
69373: PPUSH
69374: LD_VAR 0 4
69378: PUSH
69379: LD_INT 2
69381: ARRAY
69382: PPUSH
69383: CALL_OW 428
69387: PUSH
69388: LD_VAR 0 5
69392: IN
69393: IFFALSE 69422
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69395: LD_VAR 0 4
69399: PUSH
69400: LD_INT 1
69402: ARRAY
69403: PPUSH
69404: LD_VAR 0 4
69408: PUSH
69409: LD_INT 2
69411: ARRAY
69412: PPUSH
69413: LD_VAR 0 1
69417: PPUSH
69418: CALL_OW 456
// end ;
69422: GO 69335
69424: POP
69425: POP
// end ;
69426: LD_VAR 0 3
69430: RET
// export function Count ( array ) ; var i ; begin
69431: LD_INT 0
69433: PPUSH
69434: PPUSH
// result := 0 ;
69435: LD_ADDR_VAR 0 2
69439: PUSH
69440: LD_INT 0
69442: ST_TO_ADDR
// for i in array do
69443: LD_ADDR_VAR 0 3
69447: PUSH
69448: LD_VAR 0 1
69452: PUSH
69453: FOR_IN
69454: IFFALSE 69478
// if i then
69456: LD_VAR 0 3
69460: IFFALSE 69476
// result := result + 1 ;
69462: LD_ADDR_VAR 0 2
69466: PUSH
69467: LD_VAR 0 2
69471: PUSH
69472: LD_INT 1
69474: PLUS
69475: ST_TO_ADDR
69476: GO 69453
69478: POP
69479: POP
// end ;
69480: LD_VAR 0 2
69484: RET
// export function IsEmpty ( building ) ; begin
69485: LD_INT 0
69487: PPUSH
// if not building then
69488: LD_VAR 0 1
69492: NOT
69493: IFFALSE 69497
// exit ;
69495: GO 69540
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69497: LD_ADDR_VAR 0 2
69501: PUSH
69502: LD_VAR 0 1
69506: PUSH
69507: LD_INT 22
69509: PUSH
69510: LD_VAR 0 1
69514: PPUSH
69515: CALL_OW 255
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 58
69526: PUSH
69527: EMPTY
69528: LIST
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PPUSH
69534: CALL_OW 69
69538: IN
69539: ST_TO_ADDR
// end ;
69540: LD_VAR 0 2
69544: RET
// export function IsNotFull ( building ) ; var places ; begin
69545: LD_INT 0
69547: PPUSH
69548: PPUSH
// if not building then
69549: LD_VAR 0 1
69553: NOT
69554: IFFALSE 69558
// exit ;
69556: GO 69729
// result := false ;
69558: LD_ADDR_VAR 0 2
69562: PUSH
69563: LD_INT 0
69565: ST_TO_ADDR
// places := 0 ;
69566: LD_ADDR_VAR 0 3
69570: PUSH
69571: LD_INT 0
69573: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69574: LD_VAR 0 1
69578: PPUSH
69579: CALL_OW 266
69583: PUSH
69584: LD_INT 0
69586: DOUBLE
69587: EQUAL
69588: IFTRUE 69646
69590: LD_INT 1
69592: DOUBLE
69593: EQUAL
69594: IFTRUE 69646
69596: LD_INT 6
69598: DOUBLE
69599: EQUAL
69600: IFTRUE 69646
69602: LD_INT 7
69604: DOUBLE
69605: EQUAL
69606: IFTRUE 69646
69608: LD_INT 8
69610: DOUBLE
69611: EQUAL
69612: IFTRUE 69646
69614: LD_INT 4
69616: DOUBLE
69617: EQUAL
69618: IFTRUE 69646
69620: LD_INT 5
69622: DOUBLE
69623: EQUAL
69624: IFTRUE 69646
69626: LD_INT 2
69628: DOUBLE
69629: EQUAL
69630: IFTRUE 69646
69632: LD_INT 3
69634: DOUBLE
69635: EQUAL
69636: IFTRUE 69646
69638: LD_INT 35
69640: DOUBLE
69641: EQUAL
69642: IFTRUE 69646
69644: GO 69657
69646: POP
// places := 6 ; b_bunker , b_breastwork :
69647: LD_ADDR_VAR 0 3
69651: PUSH
69652: LD_INT 6
69654: ST_TO_ADDR
69655: GO 69702
69657: LD_INT 32
69659: DOUBLE
69660: EQUAL
69661: IFTRUE 69671
69663: LD_INT 31
69665: DOUBLE
69666: EQUAL
69667: IFTRUE 69671
69669: GO 69682
69671: POP
// places := 1 ; b_control_tower :
69672: LD_ADDR_VAR 0 3
69676: PUSH
69677: LD_INT 1
69679: ST_TO_ADDR
69680: GO 69702
69682: LD_INT 36
69684: DOUBLE
69685: EQUAL
69686: IFTRUE 69690
69688: GO 69701
69690: POP
// places := 3 ; end ;
69691: LD_ADDR_VAR 0 3
69695: PUSH
69696: LD_INT 3
69698: ST_TO_ADDR
69699: GO 69702
69701: POP
// if places then
69702: LD_VAR 0 3
69706: IFFALSE 69729
// result := UnitsInside ( building ) < places ;
69708: LD_ADDR_VAR 0 2
69712: PUSH
69713: LD_VAR 0 1
69717: PPUSH
69718: CALL_OW 313
69722: PUSH
69723: LD_VAR 0 3
69727: LESS
69728: ST_TO_ADDR
// end ;
69729: LD_VAR 0 2
69733: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69734: LD_INT 0
69736: PPUSH
69737: PPUSH
69738: PPUSH
69739: PPUSH
// tmp := [ ] ;
69740: LD_ADDR_VAR 0 3
69744: PUSH
69745: EMPTY
69746: ST_TO_ADDR
// list := [ ] ;
69747: LD_ADDR_VAR 0 5
69751: PUSH
69752: EMPTY
69753: ST_TO_ADDR
// for i = 16 to 25 do
69754: LD_ADDR_VAR 0 4
69758: PUSH
69759: DOUBLE
69760: LD_INT 16
69762: DEC
69763: ST_TO_ADDR
69764: LD_INT 25
69766: PUSH
69767: FOR_TO
69768: IFFALSE 69841
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69770: LD_ADDR_VAR 0 3
69774: PUSH
69775: LD_VAR 0 3
69779: PUSH
69780: LD_INT 22
69782: PUSH
69783: LD_VAR 0 1
69787: PPUSH
69788: CALL_OW 255
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 91
69799: PUSH
69800: LD_VAR 0 1
69804: PUSH
69805: LD_INT 6
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 30
69815: PUSH
69816: LD_VAR 0 4
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: LIST
69829: PUSH
69830: EMPTY
69831: LIST
69832: PPUSH
69833: CALL_OW 69
69837: ADD
69838: ST_TO_ADDR
69839: GO 69767
69841: POP
69842: POP
// for i = 1 to tmp do
69843: LD_ADDR_VAR 0 4
69847: PUSH
69848: DOUBLE
69849: LD_INT 1
69851: DEC
69852: ST_TO_ADDR
69853: LD_VAR 0 3
69857: PUSH
69858: FOR_TO
69859: IFFALSE 69947
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69861: LD_ADDR_VAR 0 5
69865: PUSH
69866: LD_VAR 0 5
69870: PUSH
69871: LD_VAR 0 3
69875: PUSH
69876: LD_VAR 0 4
69880: ARRAY
69881: PPUSH
69882: CALL_OW 266
69886: PUSH
69887: LD_VAR 0 3
69891: PUSH
69892: LD_VAR 0 4
69896: ARRAY
69897: PPUSH
69898: CALL_OW 250
69902: PUSH
69903: LD_VAR 0 3
69907: PUSH
69908: LD_VAR 0 4
69912: ARRAY
69913: PPUSH
69914: CALL_OW 251
69918: PUSH
69919: LD_VAR 0 3
69923: PUSH
69924: LD_VAR 0 4
69928: ARRAY
69929: PPUSH
69930: CALL_OW 254
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: PUSH
69941: EMPTY
69942: LIST
69943: ADD
69944: ST_TO_ADDR
69945: GO 69858
69947: POP
69948: POP
// result := list ;
69949: LD_ADDR_VAR 0 2
69953: PUSH
69954: LD_VAR 0 5
69958: ST_TO_ADDR
// end ;
69959: LD_VAR 0 2
69963: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69964: LD_INT 0
69966: PPUSH
69967: PPUSH
69968: PPUSH
69969: PPUSH
69970: PPUSH
69971: PPUSH
69972: PPUSH
// if not factory then
69973: LD_VAR 0 1
69977: NOT
69978: IFFALSE 69982
// exit ;
69980: GO 70575
// if control = control_apeman then
69982: LD_VAR 0 4
69986: PUSH
69987: LD_INT 5
69989: EQUAL
69990: IFFALSE 70099
// begin tmp := UnitsInside ( factory ) ;
69992: LD_ADDR_VAR 0 8
69996: PUSH
69997: LD_VAR 0 1
70001: PPUSH
70002: CALL_OW 313
70006: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70007: LD_VAR 0 8
70011: PPUSH
70012: LD_INT 25
70014: PUSH
70015: LD_INT 12
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PPUSH
70022: CALL_OW 72
70026: NOT
70027: IFFALSE 70037
// control := control_manual ;
70029: LD_ADDR_VAR 0 4
70033: PUSH
70034: LD_INT 1
70036: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70037: LD_ADDR_VAR 0 8
70041: PUSH
70042: LD_VAR 0 1
70046: PPUSH
70047: CALL 69734 0 1
70051: ST_TO_ADDR
// if tmp then
70052: LD_VAR 0 8
70056: IFFALSE 70099
// begin for i in tmp do
70058: LD_ADDR_VAR 0 7
70062: PUSH
70063: LD_VAR 0 8
70067: PUSH
70068: FOR_IN
70069: IFFALSE 70097
// if i [ 1 ] = b_ext_radio then
70071: LD_VAR 0 7
70075: PUSH
70076: LD_INT 1
70078: ARRAY
70079: PUSH
70080: LD_INT 22
70082: EQUAL
70083: IFFALSE 70095
// begin control := control_remote ;
70085: LD_ADDR_VAR 0 4
70089: PUSH
70090: LD_INT 2
70092: ST_TO_ADDR
// break ;
70093: GO 70097
// end ;
70095: GO 70068
70097: POP
70098: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70099: LD_VAR 0 1
70103: PPUSH
70104: LD_VAR 0 2
70108: PPUSH
70109: LD_VAR 0 3
70113: PPUSH
70114: LD_VAR 0 4
70118: PPUSH
70119: LD_VAR 0 5
70123: PPUSH
70124: CALL_OW 448
70128: IFFALSE 70163
// begin result := [ chassis , engine , control , weapon ] ;
70130: LD_ADDR_VAR 0 6
70134: PUSH
70135: LD_VAR 0 2
70139: PUSH
70140: LD_VAR 0 3
70144: PUSH
70145: LD_VAR 0 4
70149: PUSH
70150: LD_VAR 0 5
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: ST_TO_ADDR
// exit ;
70161: GO 70575
// end ; _chassis := AvailableChassisList ( factory ) ;
70163: LD_ADDR_VAR 0 9
70167: PUSH
70168: LD_VAR 0 1
70172: PPUSH
70173: CALL_OW 475
70177: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70178: LD_ADDR_VAR 0 11
70182: PUSH
70183: LD_VAR 0 1
70187: PPUSH
70188: CALL_OW 476
70192: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70193: LD_ADDR_VAR 0 12
70197: PUSH
70198: LD_VAR 0 1
70202: PPUSH
70203: CALL_OW 477
70207: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70208: LD_ADDR_VAR 0 10
70212: PUSH
70213: LD_VAR 0 1
70217: PPUSH
70218: CALL_OW 478
70222: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70223: LD_VAR 0 9
70227: NOT
70228: PUSH
70229: LD_VAR 0 11
70233: NOT
70234: OR
70235: PUSH
70236: LD_VAR 0 12
70240: NOT
70241: OR
70242: PUSH
70243: LD_VAR 0 10
70247: NOT
70248: OR
70249: IFFALSE 70284
// begin result := [ chassis , engine , control , weapon ] ;
70251: LD_ADDR_VAR 0 6
70255: PUSH
70256: LD_VAR 0 2
70260: PUSH
70261: LD_VAR 0 3
70265: PUSH
70266: LD_VAR 0 4
70270: PUSH
70271: LD_VAR 0 5
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: ST_TO_ADDR
// exit ;
70282: GO 70575
// end ; if not chassis in _chassis then
70284: LD_VAR 0 2
70288: PUSH
70289: LD_VAR 0 9
70293: IN
70294: NOT
70295: IFFALSE 70321
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70297: LD_ADDR_VAR 0 2
70301: PUSH
70302: LD_VAR 0 9
70306: PUSH
70307: LD_INT 1
70309: PPUSH
70310: LD_VAR 0 9
70314: PPUSH
70315: CALL_OW 12
70319: ARRAY
70320: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70321: LD_VAR 0 2
70325: PPUSH
70326: LD_VAR 0 3
70330: PPUSH
70331: CALL 70580 0 2
70335: NOT
70336: IFFALSE 70395
// repeat engine := _engine [ 1 ] ;
70338: LD_ADDR_VAR 0 3
70342: PUSH
70343: LD_VAR 0 11
70347: PUSH
70348: LD_INT 1
70350: ARRAY
70351: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70352: LD_ADDR_VAR 0 11
70356: PUSH
70357: LD_VAR 0 11
70361: PPUSH
70362: LD_INT 1
70364: PPUSH
70365: CALL_OW 3
70369: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70370: LD_VAR 0 2
70374: PPUSH
70375: LD_VAR 0 3
70379: PPUSH
70380: CALL 70580 0 2
70384: PUSH
70385: LD_VAR 0 11
70389: PUSH
70390: EMPTY
70391: EQUAL
70392: OR
70393: IFFALSE 70338
// if not control in _control then
70395: LD_VAR 0 4
70399: PUSH
70400: LD_VAR 0 12
70404: IN
70405: NOT
70406: IFFALSE 70432
// control := _control [ rand ( 1 , _control ) ] ;
70408: LD_ADDR_VAR 0 4
70412: PUSH
70413: LD_VAR 0 12
70417: PUSH
70418: LD_INT 1
70420: PPUSH
70421: LD_VAR 0 12
70425: PPUSH
70426: CALL_OW 12
70430: ARRAY
70431: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70432: LD_VAR 0 2
70436: PPUSH
70437: LD_VAR 0 5
70441: PPUSH
70442: CALL 70800 0 2
70446: NOT
70447: IFFALSE 70506
// repeat weapon := _weapon [ 1 ] ;
70449: LD_ADDR_VAR 0 5
70453: PUSH
70454: LD_VAR 0 10
70458: PUSH
70459: LD_INT 1
70461: ARRAY
70462: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70463: LD_ADDR_VAR 0 10
70467: PUSH
70468: LD_VAR 0 10
70472: PPUSH
70473: LD_INT 1
70475: PPUSH
70476: CALL_OW 3
70480: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70481: LD_VAR 0 2
70485: PPUSH
70486: LD_VAR 0 5
70490: PPUSH
70491: CALL 70800 0 2
70495: PUSH
70496: LD_VAR 0 10
70500: PUSH
70501: EMPTY
70502: EQUAL
70503: OR
70504: IFFALSE 70449
// result := [ ] ;
70506: LD_ADDR_VAR 0 6
70510: PUSH
70511: EMPTY
70512: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70513: LD_VAR 0 1
70517: PPUSH
70518: LD_VAR 0 2
70522: PPUSH
70523: LD_VAR 0 3
70527: PPUSH
70528: LD_VAR 0 4
70532: PPUSH
70533: LD_VAR 0 5
70537: PPUSH
70538: CALL_OW 448
70542: IFFALSE 70575
// result := [ chassis , engine , control , weapon ] ;
70544: LD_ADDR_VAR 0 6
70548: PUSH
70549: LD_VAR 0 2
70553: PUSH
70554: LD_VAR 0 3
70558: PUSH
70559: LD_VAR 0 4
70563: PUSH
70564: LD_VAR 0 5
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: ST_TO_ADDR
// end ;
70575: LD_VAR 0 6
70579: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70580: LD_INT 0
70582: PPUSH
// if not chassis or not engine then
70583: LD_VAR 0 1
70587: NOT
70588: PUSH
70589: LD_VAR 0 2
70593: NOT
70594: OR
70595: IFFALSE 70599
// exit ;
70597: GO 70795
// case engine of engine_solar :
70599: LD_VAR 0 2
70603: PUSH
70604: LD_INT 2
70606: DOUBLE
70607: EQUAL
70608: IFTRUE 70612
70610: GO 70650
70612: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70613: LD_ADDR_VAR 0 3
70617: PUSH
70618: LD_INT 11
70620: PUSH
70621: LD_INT 12
70623: PUSH
70624: LD_INT 13
70626: PUSH
70627: LD_INT 14
70629: PUSH
70630: LD_INT 1
70632: PUSH
70633: LD_INT 2
70635: PUSH
70636: LD_INT 3
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: LIST
70647: ST_TO_ADDR
70648: GO 70779
70650: LD_INT 1
70652: DOUBLE
70653: EQUAL
70654: IFTRUE 70658
70656: GO 70720
70658: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70659: LD_ADDR_VAR 0 3
70663: PUSH
70664: LD_INT 11
70666: PUSH
70667: LD_INT 12
70669: PUSH
70670: LD_INT 13
70672: PUSH
70673: LD_INT 14
70675: PUSH
70676: LD_INT 1
70678: PUSH
70679: LD_INT 2
70681: PUSH
70682: LD_INT 3
70684: PUSH
70685: LD_INT 4
70687: PUSH
70688: LD_INT 5
70690: PUSH
70691: LD_INT 21
70693: PUSH
70694: LD_INT 23
70696: PUSH
70697: LD_INT 22
70699: PUSH
70700: LD_INT 24
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: ST_TO_ADDR
70718: GO 70779
70720: LD_INT 3
70722: DOUBLE
70723: EQUAL
70724: IFTRUE 70728
70726: GO 70778
70728: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70729: LD_ADDR_VAR 0 3
70733: PUSH
70734: LD_INT 13
70736: PUSH
70737: LD_INT 14
70739: PUSH
70740: LD_INT 2
70742: PUSH
70743: LD_INT 3
70745: PUSH
70746: LD_INT 4
70748: PUSH
70749: LD_INT 5
70751: PUSH
70752: LD_INT 21
70754: PUSH
70755: LD_INT 22
70757: PUSH
70758: LD_INT 23
70760: PUSH
70761: LD_INT 24
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: ST_TO_ADDR
70776: GO 70779
70778: POP
// result := ( chassis in result ) ;
70779: LD_ADDR_VAR 0 3
70783: PUSH
70784: LD_VAR 0 1
70788: PUSH
70789: LD_VAR 0 3
70793: IN
70794: ST_TO_ADDR
// end ;
70795: LD_VAR 0 3
70799: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70800: LD_INT 0
70802: PPUSH
// if not chassis or not weapon then
70803: LD_VAR 0 1
70807: NOT
70808: PUSH
70809: LD_VAR 0 2
70813: NOT
70814: OR
70815: IFFALSE 70819
// exit ;
70817: GO 71879
// case weapon of us_machine_gun :
70819: LD_VAR 0 2
70823: PUSH
70824: LD_INT 2
70826: DOUBLE
70827: EQUAL
70828: IFTRUE 70832
70830: GO 70862
70832: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70833: LD_ADDR_VAR 0 3
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: LD_INT 2
70843: PUSH
70844: LD_INT 3
70846: PUSH
70847: LD_INT 4
70849: PUSH
70850: LD_INT 5
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: ST_TO_ADDR
70860: GO 71863
70862: LD_INT 3
70864: DOUBLE
70865: EQUAL
70866: IFTRUE 70870
70868: GO 70900
70870: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70871: LD_ADDR_VAR 0 3
70875: PUSH
70876: LD_INT 1
70878: PUSH
70879: LD_INT 2
70881: PUSH
70882: LD_INT 3
70884: PUSH
70885: LD_INT 4
70887: PUSH
70888: LD_INT 5
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: ST_TO_ADDR
70898: GO 71863
70900: LD_INT 11
70902: DOUBLE
70903: EQUAL
70904: IFTRUE 70908
70906: GO 70938
70908: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70909: LD_ADDR_VAR 0 3
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: LD_INT 2
70919: PUSH
70920: LD_INT 3
70922: PUSH
70923: LD_INT 4
70925: PUSH
70926: LD_INT 5
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: ST_TO_ADDR
70936: GO 71863
70938: LD_INT 4
70940: DOUBLE
70941: EQUAL
70942: IFTRUE 70946
70944: GO 70972
70946: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70947: LD_ADDR_VAR 0 3
70951: PUSH
70952: LD_INT 2
70954: PUSH
70955: LD_INT 3
70957: PUSH
70958: LD_INT 4
70960: PUSH
70961: LD_INT 5
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: ST_TO_ADDR
70970: GO 71863
70972: LD_INT 5
70974: DOUBLE
70975: EQUAL
70976: IFTRUE 70980
70978: GO 71006
70980: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70981: LD_ADDR_VAR 0 3
70985: PUSH
70986: LD_INT 2
70988: PUSH
70989: LD_INT 3
70991: PUSH
70992: LD_INT 4
70994: PUSH
70995: LD_INT 5
70997: PUSH
70998: EMPTY
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: ST_TO_ADDR
71004: GO 71863
71006: LD_INT 9
71008: DOUBLE
71009: EQUAL
71010: IFTRUE 71014
71012: GO 71040
71014: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71015: LD_ADDR_VAR 0 3
71019: PUSH
71020: LD_INT 2
71022: PUSH
71023: LD_INT 3
71025: PUSH
71026: LD_INT 4
71028: PUSH
71029: LD_INT 5
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: ST_TO_ADDR
71038: GO 71863
71040: LD_INT 7
71042: DOUBLE
71043: EQUAL
71044: IFTRUE 71048
71046: GO 71074
71048: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71049: LD_ADDR_VAR 0 3
71053: PUSH
71054: LD_INT 2
71056: PUSH
71057: LD_INT 3
71059: PUSH
71060: LD_INT 4
71062: PUSH
71063: LD_INT 5
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: ST_TO_ADDR
71072: GO 71863
71074: LD_INT 12
71076: DOUBLE
71077: EQUAL
71078: IFTRUE 71082
71080: GO 71108
71082: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71083: LD_ADDR_VAR 0 3
71087: PUSH
71088: LD_INT 2
71090: PUSH
71091: LD_INT 3
71093: PUSH
71094: LD_INT 4
71096: PUSH
71097: LD_INT 5
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: LIST
71104: LIST
71105: ST_TO_ADDR
71106: GO 71863
71108: LD_INT 13
71110: DOUBLE
71111: EQUAL
71112: IFTRUE 71116
71114: GO 71142
71116: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71117: LD_ADDR_VAR 0 3
71121: PUSH
71122: LD_INT 2
71124: PUSH
71125: LD_INT 3
71127: PUSH
71128: LD_INT 4
71130: PUSH
71131: LD_INT 5
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: ST_TO_ADDR
71140: GO 71863
71142: LD_INT 14
71144: DOUBLE
71145: EQUAL
71146: IFTRUE 71150
71148: GO 71168
71150: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71151: LD_ADDR_VAR 0 3
71155: PUSH
71156: LD_INT 4
71158: PUSH
71159: LD_INT 5
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: ST_TO_ADDR
71166: GO 71863
71168: LD_INT 6
71170: DOUBLE
71171: EQUAL
71172: IFTRUE 71176
71174: GO 71194
71176: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71177: LD_ADDR_VAR 0 3
71181: PUSH
71182: LD_INT 4
71184: PUSH
71185: LD_INT 5
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: ST_TO_ADDR
71192: GO 71863
71194: LD_INT 10
71196: DOUBLE
71197: EQUAL
71198: IFTRUE 71202
71200: GO 71220
71202: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71203: LD_ADDR_VAR 0 3
71207: PUSH
71208: LD_INT 4
71210: PUSH
71211: LD_INT 5
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: ST_TO_ADDR
71218: GO 71863
71220: LD_INT 22
71222: DOUBLE
71223: EQUAL
71224: IFTRUE 71228
71226: GO 71254
71228: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71229: LD_ADDR_VAR 0 3
71233: PUSH
71234: LD_INT 11
71236: PUSH
71237: LD_INT 12
71239: PUSH
71240: LD_INT 13
71242: PUSH
71243: LD_INT 14
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: ST_TO_ADDR
71252: GO 71863
71254: LD_INT 23
71256: DOUBLE
71257: EQUAL
71258: IFTRUE 71262
71260: GO 71288
71262: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71263: LD_ADDR_VAR 0 3
71267: PUSH
71268: LD_INT 11
71270: PUSH
71271: LD_INT 12
71273: PUSH
71274: LD_INT 13
71276: PUSH
71277: LD_INT 14
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: ST_TO_ADDR
71286: GO 71863
71288: LD_INT 24
71290: DOUBLE
71291: EQUAL
71292: IFTRUE 71296
71294: GO 71322
71296: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71297: LD_ADDR_VAR 0 3
71301: PUSH
71302: LD_INT 11
71304: PUSH
71305: LD_INT 12
71307: PUSH
71308: LD_INT 13
71310: PUSH
71311: LD_INT 14
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: ST_TO_ADDR
71320: GO 71863
71322: LD_INT 30
71324: DOUBLE
71325: EQUAL
71326: IFTRUE 71330
71328: GO 71356
71330: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71331: LD_ADDR_VAR 0 3
71335: PUSH
71336: LD_INT 11
71338: PUSH
71339: LD_INT 12
71341: PUSH
71342: LD_INT 13
71344: PUSH
71345: LD_INT 14
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: ST_TO_ADDR
71354: GO 71863
71356: LD_INT 25
71358: DOUBLE
71359: EQUAL
71360: IFTRUE 71364
71362: GO 71382
71364: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71365: LD_ADDR_VAR 0 3
71369: PUSH
71370: LD_INT 13
71372: PUSH
71373: LD_INT 14
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: ST_TO_ADDR
71380: GO 71863
71382: LD_INT 27
71384: DOUBLE
71385: EQUAL
71386: IFTRUE 71390
71388: GO 71408
71390: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71391: LD_ADDR_VAR 0 3
71395: PUSH
71396: LD_INT 13
71398: PUSH
71399: LD_INT 14
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: ST_TO_ADDR
71406: GO 71863
71408: LD_INT 92
71410: DOUBLE
71411: EQUAL
71412: IFTRUE 71416
71414: GO 71442
71416: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71417: LD_ADDR_VAR 0 3
71421: PUSH
71422: LD_INT 11
71424: PUSH
71425: LD_INT 12
71427: PUSH
71428: LD_INT 13
71430: PUSH
71431: LD_INT 14
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: ST_TO_ADDR
71440: GO 71863
71442: LD_INT 28
71444: DOUBLE
71445: EQUAL
71446: IFTRUE 71450
71448: GO 71468
71450: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71451: LD_ADDR_VAR 0 3
71455: PUSH
71456: LD_INT 13
71458: PUSH
71459: LD_INT 14
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: ST_TO_ADDR
71466: GO 71863
71468: LD_INT 29
71470: DOUBLE
71471: EQUAL
71472: IFTRUE 71476
71474: GO 71494
71476: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71477: LD_ADDR_VAR 0 3
71481: PUSH
71482: LD_INT 13
71484: PUSH
71485: LD_INT 14
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: ST_TO_ADDR
71492: GO 71863
71494: LD_INT 31
71496: DOUBLE
71497: EQUAL
71498: IFTRUE 71502
71500: GO 71520
71502: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71503: LD_ADDR_VAR 0 3
71507: PUSH
71508: LD_INT 13
71510: PUSH
71511: LD_INT 14
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: ST_TO_ADDR
71518: GO 71863
71520: LD_INT 26
71522: DOUBLE
71523: EQUAL
71524: IFTRUE 71528
71526: GO 71546
71528: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71529: LD_ADDR_VAR 0 3
71533: PUSH
71534: LD_INT 13
71536: PUSH
71537: LD_INT 14
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: ST_TO_ADDR
71544: GO 71863
71546: LD_INT 42
71548: DOUBLE
71549: EQUAL
71550: IFTRUE 71554
71552: GO 71580
71554: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71555: LD_ADDR_VAR 0 3
71559: PUSH
71560: LD_INT 21
71562: PUSH
71563: LD_INT 22
71565: PUSH
71566: LD_INT 23
71568: PUSH
71569: LD_INT 24
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: ST_TO_ADDR
71578: GO 71863
71580: LD_INT 43
71582: DOUBLE
71583: EQUAL
71584: IFTRUE 71588
71586: GO 71614
71588: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71589: LD_ADDR_VAR 0 3
71593: PUSH
71594: LD_INT 21
71596: PUSH
71597: LD_INT 22
71599: PUSH
71600: LD_INT 23
71602: PUSH
71603: LD_INT 24
71605: PUSH
71606: EMPTY
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: ST_TO_ADDR
71612: GO 71863
71614: LD_INT 44
71616: DOUBLE
71617: EQUAL
71618: IFTRUE 71622
71620: GO 71648
71622: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71623: LD_ADDR_VAR 0 3
71627: PUSH
71628: LD_INT 21
71630: PUSH
71631: LD_INT 22
71633: PUSH
71634: LD_INT 23
71636: PUSH
71637: LD_INT 24
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: ST_TO_ADDR
71646: GO 71863
71648: LD_INT 45
71650: DOUBLE
71651: EQUAL
71652: IFTRUE 71656
71654: GO 71682
71656: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71657: LD_ADDR_VAR 0 3
71661: PUSH
71662: LD_INT 21
71664: PUSH
71665: LD_INT 22
71667: PUSH
71668: LD_INT 23
71670: PUSH
71671: LD_INT 24
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: ST_TO_ADDR
71680: GO 71863
71682: LD_INT 49
71684: DOUBLE
71685: EQUAL
71686: IFTRUE 71690
71688: GO 71716
71690: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71691: LD_ADDR_VAR 0 3
71695: PUSH
71696: LD_INT 21
71698: PUSH
71699: LD_INT 22
71701: PUSH
71702: LD_INT 23
71704: PUSH
71705: LD_INT 24
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: ST_TO_ADDR
71714: GO 71863
71716: LD_INT 51
71718: DOUBLE
71719: EQUAL
71720: IFTRUE 71724
71722: GO 71750
71724: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71725: LD_ADDR_VAR 0 3
71729: PUSH
71730: LD_INT 21
71732: PUSH
71733: LD_INT 22
71735: PUSH
71736: LD_INT 23
71738: PUSH
71739: LD_INT 24
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: LIST
71746: LIST
71747: ST_TO_ADDR
71748: GO 71863
71750: LD_INT 52
71752: DOUBLE
71753: EQUAL
71754: IFTRUE 71758
71756: GO 71784
71758: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71759: LD_ADDR_VAR 0 3
71763: PUSH
71764: LD_INT 21
71766: PUSH
71767: LD_INT 22
71769: PUSH
71770: LD_INT 23
71772: PUSH
71773: LD_INT 24
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: ST_TO_ADDR
71782: GO 71863
71784: LD_INT 53
71786: DOUBLE
71787: EQUAL
71788: IFTRUE 71792
71790: GO 71810
71792: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71793: LD_ADDR_VAR 0 3
71797: PUSH
71798: LD_INT 23
71800: PUSH
71801: LD_INT 24
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: ST_TO_ADDR
71808: GO 71863
71810: LD_INT 46
71812: DOUBLE
71813: EQUAL
71814: IFTRUE 71818
71816: GO 71836
71818: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71819: LD_ADDR_VAR 0 3
71823: PUSH
71824: LD_INT 23
71826: PUSH
71827: LD_INT 24
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: ST_TO_ADDR
71834: GO 71863
71836: LD_INT 47
71838: DOUBLE
71839: EQUAL
71840: IFTRUE 71844
71842: GO 71862
71844: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71845: LD_ADDR_VAR 0 3
71849: PUSH
71850: LD_INT 23
71852: PUSH
71853: LD_INT 24
71855: PUSH
71856: EMPTY
71857: LIST
71858: LIST
71859: ST_TO_ADDR
71860: GO 71863
71862: POP
// result := ( chassis in result ) ;
71863: LD_ADDR_VAR 0 3
71867: PUSH
71868: LD_VAR 0 1
71872: PUSH
71873: LD_VAR 0 3
71877: IN
71878: ST_TO_ADDR
// end ;
71879: LD_VAR 0 3
71883: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71884: LD_INT 0
71886: PPUSH
71887: PPUSH
71888: PPUSH
71889: PPUSH
71890: PPUSH
71891: PPUSH
71892: PPUSH
// result := array ;
71893: LD_ADDR_VAR 0 5
71897: PUSH
71898: LD_VAR 0 1
71902: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71903: LD_VAR 0 1
71907: NOT
71908: PUSH
71909: LD_VAR 0 2
71913: NOT
71914: OR
71915: PUSH
71916: LD_VAR 0 3
71920: NOT
71921: OR
71922: PUSH
71923: LD_VAR 0 2
71927: PUSH
71928: LD_VAR 0 1
71932: GREATER
71933: OR
71934: PUSH
71935: LD_VAR 0 3
71939: PUSH
71940: LD_VAR 0 1
71944: GREATER
71945: OR
71946: IFFALSE 71950
// exit ;
71948: GO 72246
// if direction then
71950: LD_VAR 0 4
71954: IFFALSE 72018
// begin d := 1 ;
71956: LD_ADDR_VAR 0 9
71960: PUSH
71961: LD_INT 1
71963: ST_TO_ADDR
// if i_from > i_to then
71964: LD_VAR 0 2
71968: PUSH
71969: LD_VAR 0 3
71973: GREATER
71974: IFFALSE 72000
// length := ( array - i_from ) + i_to else
71976: LD_ADDR_VAR 0 11
71980: PUSH
71981: LD_VAR 0 1
71985: PUSH
71986: LD_VAR 0 2
71990: MINUS
71991: PUSH
71992: LD_VAR 0 3
71996: PLUS
71997: ST_TO_ADDR
71998: GO 72016
// length := i_to - i_from ;
72000: LD_ADDR_VAR 0 11
72004: PUSH
72005: LD_VAR 0 3
72009: PUSH
72010: LD_VAR 0 2
72014: MINUS
72015: ST_TO_ADDR
// end else
72016: GO 72079
// begin d := - 1 ;
72018: LD_ADDR_VAR 0 9
72022: PUSH
72023: LD_INT 1
72025: NEG
72026: ST_TO_ADDR
// if i_from > i_to then
72027: LD_VAR 0 2
72031: PUSH
72032: LD_VAR 0 3
72036: GREATER
72037: IFFALSE 72057
// length := i_from - i_to else
72039: LD_ADDR_VAR 0 11
72043: PUSH
72044: LD_VAR 0 2
72048: PUSH
72049: LD_VAR 0 3
72053: MINUS
72054: ST_TO_ADDR
72055: GO 72079
// length := ( array - i_to ) + i_from ;
72057: LD_ADDR_VAR 0 11
72061: PUSH
72062: LD_VAR 0 1
72066: PUSH
72067: LD_VAR 0 3
72071: MINUS
72072: PUSH
72073: LD_VAR 0 2
72077: PLUS
72078: ST_TO_ADDR
// end ; if not length then
72079: LD_VAR 0 11
72083: NOT
72084: IFFALSE 72088
// exit ;
72086: GO 72246
// tmp := array ;
72088: LD_ADDR_VAR 0 10
72092: PUSH
72093: LD_VAR 0 1
72097: ST_TO_ADDR
// for i = 1 to length do
72098: LD_ADDR_VAR 0 6
72102: PUSH
72103: DOUBLE
72104: LD_INT 1
72106: DEC
72107: ST_TO_ADDR
72108: LD_VAR 0 11
72112: PUSH
72113: FOR_TO
72114: IFFALSE 72234
// begin for j = 1 to array do
72116: LD_ADDR_VAR 0 7
72120: PUSH
72121: DOUBLE
72122: LD_INT 1
72124: DEC
72125: ST_TO_ADDR
72126: LD_VAR 0 1
72130: PUSH
72131: FOR_TO
72132: IFFALSE 72220
// begin k := j + d ;
72134: LD_ADDR_VAR 0 8
72138: PUSH
72139: LD_VAR 0 7
72143: PUSH
72144: LD_VAR 0 9
72148: PLUS
72149: ST_TO_ADDR
// if k > array then
72150: LD_VAR 0 8
72154: PUSH
72155: LD_VAR 0 1
72159: GREATER
72160: IFFALSE 72170
// k := 1 ;
72162: LD_ADDR_VAR 0 8
72166: PUSH
72167: LD_INT 1
72169: ST_TO_ADDR
// if not k then
72170: LD_VAR 0 8
72174: NOT
72175: IFFALSE 72187
// k := array ;
72177: LD_ADDR_VAR 0 8
72181: PUSH
72182: LD_VAR 0 1
72186: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72187: LD_ADDR_VAR 0 10
72191: PUSH
72192: LD_VAR 0 10
72196: PPUSH
72197: LD_VAR 0 8
72201: PPUSH
72202: LD_VAR 0 1
72206: PUSH
72207: LD_VAR 0 7
72211: ARRAY
72212: PPUSH
72213: CALL_OW 1
72217: ST_TO_ADDR
// end ;
72218: GO 72131
72220: POP
72221: POP
// array := tmp ;
72222: LD_ADDR_VAR 0 1
72226: PUSH
72227: LD_VAR 0 10
72231: ST_TO_ADDR
// end ;
72232: GO 72113
72234: POP
72235: POP
// result := array ;
72236: LD_ADDR_VAR 0 5
72240: PUSH
72241: LD_VAR 0 1
72245: ST_TO_ADDR
// end ;
72246: LD_VAR 0 5
72250: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72251: LD_INT 0
72253: PPUSH
72254: PPUSH
// result := 0 ;
72255: LD_ADDR_VAR 0 3
72259: PUSH
72260: LD_INT 0
72262: ST_TO_ADDR
// if not array or not value in array then
72263: LD_VAR 0 1
72267: NOT
72268: PUSH
72269: LD_VAR 0 2
72273: PUSH
72274: LD_VAR 0 1
72278: IN
72279: NOT
72280: OR
72281: IFFALSE 72285
// exit ;
72283: GO 72339
// for i = 1 to array do
72285: LD_ADDR_VAR 0 4
72289: PUSH
72290: DOUBLE
72291: LD_INT 1
72293: DEC
72294: ST_TO_ADDR
72295: LD_VAR 0 1
72299: PUSH
72300: FOR_TO
72301: IFFALSE 72337
// if value = array [ i ] then
72303: LD_VAR 0 2
72307: PUSH
72308: LD_VAR 0 1
72312: PUSH
72313: LD_VAR 0 4
72317: ARRAY
72318: EQUAL
72319: IFFALSE 72335
// begin result := i ;
72321: LD_ADDR_VAR 0 3
72325: PUSH
72326: LD_VAR 0 4
72330: ST_TO_ADDR
// exit ;
72331: POP
72332: POP
72333: GO 72339
// end ;
72335: GO 72300
72337: POP
72338: POP
// end ;
72339: LD_VAR 0 3
72343: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72344: LD_INT 0
72346: PPUSH
// vc_chassis := chassis ;
72347: LD_ADDR_OWVAR 37
72351: PUSH
72352: LD_VAR 0 1
72356: ST_TO_ADDR
// vc_engine := engine ;
72357: LD_ADDR_OWVAR 39
72361: PUSH
72362: LD_VAR 0 2
72366: ST_TO_ADDR
// vc_control := control ;
72367: LD_ADDR_OWVAR 38
72371: PUSH
72372: LD_VAR 0 3
72376: ST_TO_ADDR
// vc_weapon := weapon ;
72377: LD_ADDR_OWVAR 40
72381: PUSH
72382: LD_VAR 0 4
72386: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72387: LD_ADDR_OWVAR 41
72391: PUSH
72392: LD_VAR 0 5
72396: ST_TO_ADDR
// end ;
72397: LD_VAR 0 6
72401: RET
// export function WantPlant ( unit ) ; var task ; begin
72402: LD_INT 0
72404: PPUSH
72405: PPUSH
// result := false ;
72406: LD_ADDR_VAR 0 2
72410: PUSH
72411: LD_INT 0
72413: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72414: LD_ADDR_VAR 0 3
72418: PUSH
72419: LD_VAR 0 1
72423: PPUSH
72424: CALL_OW 437
72428: ST_TO_ADDR
// if task then
72429: LD_VAR 0 3
72433: IFFALSE 72461
// if task [ 1 ] [ 1 ] = p then
72435: LD_VAR 0 3
72439: PUSH
72440: LD_INT 1
72442: ARRAY
72443: PUSH
72444: LD_INT 1
72446: ARRAY
72447: PUSH
72448: LD_STRING p
72450: EQUAL
72451: IFFALSE 72461
// result := true ;
72453: LD_ADDR_VAR 0 2
72457: PUSH
72458: LD_INT 1
72460: ST_TO_ADDR
// end ;
72461: LD_VAR 0 2
72465: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72466: LD_INT 0
72468: PPUSH
72469: PPUSH
72470: PPUSH
72471: PPUSH
// if pos < 1 then
72472: LD_VAR 0 2
72476: PUSH
72477: LD_INT 1
72479: LESS
72480: IFFALSE 72484
// exit ;
72482: GO 72787
// if pos = 1 then
72484: LD_VAR 0 2
72488: PUSH
72489: LD_INT 1
72491: EQUAL
72492: IFFALSE 72525
// result := Replace ( arr , pos [ 1 ] , value ) else
72494: LD_ADDR_VAR 0 4
72498: PUSH
72499: LD_VAR 0 1
72503: PPUSH
72504: LD_VAR 0 2
72508: PUSH
72509: LD_INT 1
72511: ARRAY
72512: PPUSH
72513: LD_VAR 0 3
72517: PPUSH
72518: CALL_OW 1
72522: ST_TO_ADDR
72523: GO 72787
// begin tmp := arr ;
72525: LD_ADDR_VAR 0 6
72529: PUSH
72530: LD_VAR 0 1
72534: ST_TO_ADDR
// s_arr := [ tmp ] ;
72535: LD_ADDR_VAR 0 7
72539: PUSH
72540: LD_VAR 0 6
72544: PUSH
72545: EMPTY
72546: LIST
72547: ST_TO_ADDR
// for i = 1 to pos - 1 do
72548: LD_ADDR_VAR 0 5
72552: PUSH
72553: DOUBLE
72554: LD_INT 1
72556: DEC
72557: ST_TO_ADDR
72558: LD_VAR 0 2
72562: PUSH
72563: LD_INT 1
72565: MINUS
72566: PUSH
72567: FOR_TO
72568: IFFALSE 72613
// begin tmp := tmp [ pos [ i ] ] ;
72570: LD_ADDR_VAR 0 6
72574: PUSH
72575: LD_VAR 0 6
72579: PUSH
72580: LD_VAR 0 2
72584: PUSH
72585: LD_VAR 0 5
72589: ARRAY
72590: ARRAY
72591: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72592: LD_ADDR_VAR 0 7
72596: PUSH
72597: LD_VAR 0 7
72601: PUSH
72602: LD_VAR 0 6
72606: PUSH
72607: EMPTY
72608: LIST
72609: ADD
72610: ST_TO_ADDR
// end ;
72611: GO 72567
72613: POP
72614: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72615: LD_ADDR_VAR 0 6
72619: PUSH
72620: LD_VAR 0 6
72624: PPUSH
72625: LD_VAR 0 2
72629: PUSH
72630: LD_VAR 0 2
72634: ARRAY
72635: PPUSH
72636: LD_VAR 0 3
72640: PPUSH
72641: CALL_OW 1
72645: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72646: LD_ADDR_VAR 0 7
72650: PUSH
72651: LD_VAR 0 7
72655: PPUSH
72656: LD_VAR 0 7
72660: PPUSH
72661: LD_VAR 0 6
72665: PPUSH
72666: CALL_OW 1
72670: ST_TO_ADDR
// for i = s_arr downto 2 do
72671: LD_ADDR_VAR 0 5
72675: PUSH
72676: DOUBLE
72677: LD_VAR 0 7
72681: INC
72682: ST_TO_ADDR
72683: LD_INT 2
72685: PUSH
72686: FOR_DOWNTO
72687: IFFALSE 72771
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72689: LD_ADDR_VAR 0 6
72693: PUSH
72694: LD_VAR 0 7
72698: PUSH
72699: LD_VAR 0 5
72703: PUSH
72704: LD_INT 1
72706: MINUS
72707: ARRAY
72708: PPUSH
72709: LD_VAR 0 2
72713: PUSH
72714: LD_VAR 0 5
72718: PUSH
72719: LD_INT 1
72721: MINUS
72722: ARRAY
72723: PPUSH
72724: LD_VAR 0 7
72728: PUSH
72729: LD_VAR 0 5
72733: ARRAY
72734: PPUSH
72735: CALL_OW 1
72739: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72740: LD_ADDR_VAR 0 7
72744: PUSH
72745: LD_VAR 0 7
72749: PPUSH
72750: LD_VAR 0 5
72754: PUSH
72755: LD_INT 1
72757: MINUS
72758: PPUSH
72759: LD_VAR 0 6
72763: PPUSH
72764: CALL_OW 1
72768: ST_TO_ADDR
// end ;
72769: GO 72686
72771: POP
72772: POP
// result := s_arr [ 1 ] ;
72773: LD_ADDR_VAR 0 4
72777: PUSH
72778: LD_VAR 0 7
72782: PUSH
72783: LD_INT 1
72785: ARRAY
72786: ST_TO_ADDR
// end ; end ;
72787: LD_VAR 0 4
72791: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72792: LD_INT 0
72794: PPUSH
72795: PPUSH
// if not list then
72796: LD_VAR 0 1
72800: NOT
72801: IFFALSE 72805
// exit ;
72803: GO 72896
// i := list [ pos1 ] ;
72805: LD_ADDR_VAR 0 5
72809: PUSH
72810: LD_VAR 0 1
72814: PUSH
72815: LD_VAR 0 2
72819: ARRAY
72820: ST_TO_ADDR
// if not i then
72821: LD_VAR 0 5
72825: NOT
72826: IFFALSE 72830
// exit ;
72828: GO 72896
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72830: LD_ADDR_VAR 0 1
72834: PUSH
72835: LD_VAR 0 1
72839: PPUSH
72840: LD_VAR 0 2
72844: PPUSH
72845: LD_VAR 0 1
72849: PUSH
72850: LD_VAR 0 3
72854: ARRAY
72855: PPUSH
72856: CALL_OW 1
72860: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72861: LD_ADDR_VAR 0 1
72865: PUSH
72866: LD_VAR 0 1
72870: PPUSH
72871: LD_VAR 0 3
72875: PPUSH
72876: LD_VAR 0 5
72880: PPUSH
72881: CALL_OW 1
72885: ST_TO_ADDR
// result := list ;
72886: LD_ADDR_VAR 0 4
72890: PUSH
72891: LD_VAR 0 1
72895: ST_TO_ADDR
// end ;
72896: LD_VAR 0 4
72900: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72901: LD_INT 0
72903: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72904: LD_ADDR_VAR 0 5
72908: PUSH
72909: LD_VAR 0 1
72913: PPUSH
72914: CALL_OW 250
72918: PPUSH
72919: LD_VAR 0 1
72923: PPUSH
72924: CALL_OW 251
72928: PPUSH
72929: LD_VAR 0 2
72933: PPUSH
72934: LD_VAR 0 3
72938: PPUSH
72939: LD_VAR 0 4
72943: PPUSH
72944: CALL 72954 0 5
72948: ST_TO_ADDR
// end ;
72949: LD_VAR 0 5
72953: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72954: LD_INT 0
72956: PPUSH
72957: PPUSH
72958: PPUSH
72959: PPUSH
// if not list then
72960: LD_VAR 0 3
72964: NOT
72965: IFFALSE 72969
// exit ;
72967: GO 73357
// result := [ ] ;
72969: LD_ADDR_VAR 0 6
72973: PUSH
72974: EMPTY
72975: ST_TO_ADDR
// for i in list do
72976: LD_ADDR_VAR 0 7
72980: PUSH
72981: LD_VAR 0 3
72985: PUSH
72986: FOR_IN
72987: IFFALSE 73189
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72989: LD_ADDR_VAR 0 9
72993: PUSH
72994: LD_VAR 0 7
72998: PPUSH
72999: LD_VAR 0 1
73003: PPUSH
73004: LD_VAR 0 2
73008: PPUSH
73009: CALL_OW 297
73013: ST_TO_ADDR
// if not result then
73014: LD_VAR 0 6
73018: NOT
73019: IFFALSE 73045
// result := [ [ i , tmp ] ] else
73021: LD_ADDR_VAR 0 6
73025: PUSH
73026: LD_VAR 0 7
73030: PUSH
73031: LD_VAR 0 9
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: EMPTY
73041: LIST
73042: ST_TO_ADDR
73043: GO 73187
// begin if result [ result ] [ 2 ] < tmp then
73045: LD_VAR 0 6
73049: PUSH
73050: LD_VAR 0 6
73054: ARRAY
73055: PUSH
73056: LD_INT 2
73058: ARRAY
73059: PUSH
73060: LD_VAR 0 9
73064: LESS
73065: IFFALSE 73107
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73067: LD_ADDR_VAR 0 6
73071: PUSH
73072: LD_VAR 0 6
73076: PPUSH
73077: LD_VAR 0 6
73081: PUSH
73082: LD_INT 1
73084: PLUS
73085: PPUSH
73086: LD_VAR 0 7
73090: PUSH
73091: LD_VAR 0 9
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PPUSH
73100: CALL_OW 2
73104: ST_TO_ADDR
73105: GO 73187
// for j = 1 to result do
73107: LD_ADDR_VAR 0 8
73111: PUSH
73112: DOUBLE
73113: LD_INT 1
73115: DEC
73116: ST_TO_ADDR
73117: LD_VAR 0 6
73121: PUSH
73122: FOR_TO
73123: IFFALSE 73185
// begin if tmp < result [ j ] [ 2 ] then
73125: LD_VAR 0 9
73129: PUSH
73130: LD_VAR 0 6
73134: PUSH
73135: LD_VAR 0 8
73139: ARRAY
73140: PUSH
73141: LD_INT 2
73143: ARRAY
73144: LESS
73145: IFFALSE 73183
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73147: LD_ADDR_VAR 0 6
73151: PUSH
73152: LD_VAR 0 6
73156: PPUSH
73157: LD_VAR 0 8
73161: PPUSH
73162: LD_VAR 0 7
73166: PUSH
73167: LD_VAR 0 9
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PPUSH
73176: CALL_OW 2
73180: ST_TO_ADDR
// break ;
73181: GO 73185
// end ; end ;
73183: GO 73122
73185: POP
73186: POP
// end ; end ;
73187: GO 72986
73189: POP
73190: POP
// if result and not asc then
73191: LD_VAR 0 6
73195: PUSH
73196: LD_VAR 0 4
73200: NOT
73201: AND
73202: IFFALSE 73277
// begin tmp := result ;
73204: LD_ADDR_VAR 0 9
73208: PUSH
73209: LD_VAR 0 6
73213: ST_TO_ADDR
// for i = tmp downto 1 do
73214: LD_ADDR_VAR 0 7
73218: PUSH
73219: DOUBLE
73220: LD_VAR 0 9
73224: INC
73225: ST_TO_ADDR
73226: LD_INT 1
73228: PUSH
73229: FOR_DOWNTO
73230: IFFALSE 73275
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73232: LD_ADDR_VAR 0 6
73236: PUSH
73237: LD_VAR 0 6
73241: PPUSH
73242: LD_VAR 0 9
73246: PUSH
73247: LD_VAR 0 7
73251: MINUS
73252: PUSH
73253: LD_INT 1
73255: PLUS
73256: PPUSH
73257: LD_VAR 0 9
73261: PUSH
73262: LD_VAR 0 7
73266: ARRAY
73267: PPUSH
73268: CALL_OW 1
73272: ST_TO_ADDR
73273: GO 73229
73275: POP
73276: POP
// end ; tmp := [ ] ;
73277: LD_ADDR_VAR 0 9
73281: PUSH
73282: EMPTY
73283: ST_TO_ADDR
// if mode then
73284: LD_VAR 0 5
73288: IFFALSE 73357
// begin for i = 1 to result do
73290: LD_ADDR_VAR 0 7
73294: PUSH
73295: DOUBLE
73296: LD_INT 1
73298: DEC
73299: ST_TO_ADDR
73300: LD_VAR 0 6
73304: PUSH
73305: FOR_TO
73306: IFFALSE 73345
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73308: LD_ADDR_VAR 0 9
73312: PUSH
73313: LD_VAR 0 9
73317: PPUSH
73318: LD_VAR 0 7
73322: PPUSH
73323: LD_VAR 0 6
73327: PUSH
73328: LD_VAR 0 7
73332: ARRAY
73333: PUSH
73334: LD_INT 1
73336: ARRAY
73337: PPUSH
73338: CALL_OW 1
73342: ST_TO_ADDR
73343: GO 73305
73345: POP
73346: POP
// result := tmp ;
73347: LD_ADDR_VAR 0 6
73351: PUSH
73352: LD_VAR 0 9
73356: ST_TO_ADDR
// end ; end ;
73357: LD_VAR 0 6
73361: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73362: LD_INT 0
73364: PPUSH
73365: PPUSH
73366: PPUSH
73367: PPUSH
73368: PPUSH
73369: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73370: LD_ADDR_VAR 0 5
73374: PUSH
73375: LD_INT 0
73377: PUSH
73378: LD_INT 0
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: ST_TO_ADDR
// if not x or not y then
73392: LD_VAR 0 2
73396: NOT
73397: PUSH
73398: LD_VAR 0 3
73402: NOT
73403: OR
73404: IFFALSE 73408
// exit ;
73406: GO 75058
// if not range then
73408: LD_VAR 0 4
73412: NOT
73413: IFFALSE 73423
// range := 10 ;
73415: LD_ADDR_VAR 0 4
73419: PUSH
73420: LD_INT 10
73422: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73423: LD_ADDR_VAR 0 8
73427: PUSH
73428: LD_INT 81
73430: PUSH
73431: LD_VAR 0 1
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 92
73442: PUSH
73443: LD_VAR 0 2
73447: PUSH
73448: LD_VAR 0 3
73452: PUSH
73453: LD_VAR 0 4
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 3
73466: PUSH
73467: LD_INT 21
73469: PUSH
73470: LD_INT 3
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: LIST
73485: PPUSH
73486: CALL_OW 69
73490: ST_TO_ADDR
// if not tmp then
73491: LD_VAR 0 8
73495: NOT
73496: IFFALSE 73500
// exit ;
73498: GO 75058
// for i in tmp do
73500: LD_ADDR_VAR 0 6
73504: PUSH
73505: LD_VAR 0 8
73509: PUSH
73510: FOR_IN
73511: IFFALSE 75033
// begin points := [ 0 , 0 , 0 ] ;
73513: LD_ADDR_VAR 0 9
73517: PUSH
73518: LD_INT 0
73520: PUSH
73521: LD_INT 0
73523: PUSH
73524: LD_INT 0
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: LIST
73531: ST_TO_ADDR
// bpoints := 1 ;
73532: LD_ADDR_VAR 0 10
73536: PUSH
73537: LD_INT 1
73539: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73540: LD_VAR 0 6
73544: PPUSH
73545: CALL_OW 247
73549: PUSH
73550: LD_INT 1
73552: DOUBLE
73553: EQUAL
73554: IFTRUE 73558
73556: GO 74136
73558: POP
// begin if GetClass ( i ) = 1 then
73559: LD_VAR 0 6
73563: PPUSH
73564: CALL_OW 257
73568: PUSH
73569: LD_INT 1
73571: EQUAL
73572: IFFALSE 73593
// points := [ 10 , 5 , 3 ] ;
73574: LD_ADDR_VAR 0 9
73578: PUSH
73579: LD_INT 10
73581: PUSH
73582: LD_INT 5
73584: PUSH
73585: LD_INT 3
73587: PUSH
73588: EMPTY
73589: LIST
73590: LIST
73591: LIST
73592: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73593: LD_VAR 0 6
73597: PPUSH
73598: CALL_OW 257
73602: PUSH
73603: LD_INT 2
73605: PUSH
73606: LD_INT 3
73608: PUSH
73609: LD_INT 4
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: LIST
73616: IN
73617: IFFALSE 73638
// points := [ 3 , 2 , 1 ] ;
73619: LD_ADDR_VAR 0 9
73623: PUSH
73624: LD_INT 3
73626: PUSH
73627: LD_INT 2
73629: PUSH
73630: LD_INT 1
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: LIST
73637: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73638: LD_VAR 0 6
73642: PPUSH
73643: CALL_OW 257
73647: PUSH
73648: LD_INT 5
73650: EQUAL
73651: IFFALSE 73672
// points := [ 130 , 5 , 2 ] ;
73653: LD_ADDR_VAR 0 9
73657: PUSH
73658: LD_INT 130
73660: PUSH
73661: LD_INT 5
73663: PUSH
73664: LD_INT 2
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: LIST
73671: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73672: LD_VAR 0 6
73676: PPUSH
73677: CALL_OW 257
73681: PUSH
73682: LD_INT 8
73684: EQUAL
73685: IFFALSE 73706
// points := [ 35 , 35 , 30 ] ;
73687: LD_ADDR_VAR 0 9
73691: PUSH
73692: LD_INT 35
73694: PUSH
73695: LD_INT 35
73697: PUSH
73698: LD_INT 30
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: LIST
73705: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73706: LD_VAR 0 6
73710: PPUSH
73711: CALL_OW 257
73715: PUSH
73716: LD_INT 9
73718: EQUAL
73719: IFFALSE 73740
// points := [ 20 , 55 , 40 ] ;
73721: LD_ADDR_VAR 0 9
73725: PUSH
73726: LD_INT 20
73728: PUSH
73729: LD_INT 55
73731: PUSH
73732: LD_INT 40
73734: PUSH
73735: EMPTY
73736: LIST
73737: LIST
73738: LIST
73739: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73740: LD_VAR 0 6
73744: PPUSH
73745: CALL_OW 257
73749: PUSH
73750: LD_INT 12
73752: PUSH
73753: LD_INT 16
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: IN
73760: IFFALSE 73781
// points := [ 5 , 3 , 2 ] ;
73762: LD_ADDR_VAR 0 9
73766: PUSH
73767: LD_INT 5
73769: PUSH
73770: LD_INT 3
73772: PUSH
73773: LD_INT 2
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: LIST
73780: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73781: LD_VAR 0 6
73785: PPUSH
73786: CALL_OW 257
73790: PUSH
73791: LD_INT 17
73793: EQUAL
73794: IFFALSE 73815
// points := [ 100 , 50 , 75 ] ;
73796: LD_ADDR_VAR 0 9
73800: PUSH
73801: LD_INT 100
73803: PUSH
73804: LD_INT 50
73806: PUSH
73807: LD_INT 75
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: LIST
73814: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73815: LD_VAR 0 6
73819: PPUSH
73820: CALL_OW 257
73824: PUSH
73825: LD_INT 15
73827: EQUAL
73828: IFFALSE 73849
// points := [ 10 , 5 , 3 ] ;
73830: LD_ADDR_VAR 0 9
73834: PUSH
73835: LD_INT 10
73837: PUSH
73838: LD_INT 5
73840: PUSH
73841: LD_INT 3
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: LIST
73848: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73849: LD_VAR 0 6
73853: PPUSH
73854: CALL_OW 257
73858: PUSH
73859: LD_INT 14
73861: EQUAL
73862: IFFALSE 73883
// points := [ 10 , 0 , 0 ] ;
73864: LD_ADDR_VAR 0 9
73868: PUSH
73869: LD_INT 10
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: LD_INT 0
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: LIST
73882: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73883: LD_VAR 0 6
73887: PPUSH
73888: CALL_OW 257
73892: PUSH
73893: LD_INT 11
73895: EQUAL
73896: IFFALSE 73917
// points := [ 30 , 10 , 5 ] ;
73898: LD_ADDR_VAR 0 9
73902: PUSH
73903: LD_INT 30
73905: PUSH
73906: LD_INT 10
73908: PUSH
73909: LD_INT 5
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73917: LD_VAR 0 1
73921: PPUSH
73922: LD_INT 5
73924: PPUSH
73925: CALL_OW 321
73929: PUSH
73930: LD_INT 2
73932: EQUAL
73933: IFFALSE 73950
// bpoints := bpoints * 1.8 ;
73935: LD_ADDR_VAR 0 10
73939: PUSH
73940: LD_VAR 0 10
73944: PUSH
73945: LD_REAL  1.80000000000000E+0000
73948: MUL
73949: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73950: LD_VAR 0 6
73954: PPUSH
73955: CALL_OW 257
73959: PUSH
73960: LD_INT 1
73962: PUSH
73963: LD_INT 2
73965: PUSH
73966: LD_INT 3
73968: PUSH
73969: LD_INT 4
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: IN
73978: PUSH
73979: LD_VAR 0 1
73983: PPUSH
73984: LD_INT 51
73986: PPUSH
73987: CALL_OW 321
73991: PUSH
73992: LD_INT 2
73994: EQUAL
73995: AND
73996: IFFALSE 74013
// bpoints := bpoints * 1.2 ;
73998: LD_ADDR_VAR 0 10
74002: PUSH
74003: LD_VAR 0 10
74007: PUSH
74008: LD_REAL  1.20000000000000E+0000
74011: MUL
74012: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74013: LD_VAR 0 6
74017: PPUSH
74018: CALL_OW 257
74022: PUSH
74023: LD_INT 5
74025: PUSH
74026: LD_INT 7
74028: PUSH
74029: LD_INT 9
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: LIST
74036: IN
74037: PUSH
74038: LD_VAR 0 1
74042: PPUSH
74043: LD_INT 52
74045: PPUSH
74046: CALL_OW 321
74050: PUSH
74051: LD_INT 2
74053: EQUAL
74054: AND
74055: IFFALSE 74072
// bpoints := bpoints * 1.5 ;
74057: LD_ADDR_VAR 0 10
74061: PUSH
74062: LD_VAR 0 10
74066: PUSH
74067: LD_REAL  1.50000000000000E+0000
74070: MUL
74071: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74072: LD_VAR 0 1
74076: PPUSH
74077: LD_INT 66
74079: PPUSH
74080: CALL_OW 321
74084: PUSH
74085: LD_INT 2
74087: EQUAL
74088: IFFALSE 74105
// bpoints := bpoints * 1.1 ;
74090: LD_ADDR_VAR 0 10
74094: PUSH
74095: LD_VAR 0 10
74099: PUSH
74100: LD_REAL  1.10000000000000E+0000
74103: MUL
74104: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74105: LD_ADDR_VAR 0 10
74109: PUSH
74110: LD_VAR 0 10
74114: PUSH
74115: LD_VAR 0 6
74119: PPUSH
74120: LD_INT 1
74122: PPUSH
74123: CALL_OW 259
74127: PUSH
74128: LD_REAL  1.15000000000000E+0000
74131: MUL
74132: MUL
74133: ST_TO_ADDR
// end ; unit_vehicle :
74134: GO 74962
74136: LD_INT 2
74138: DOUBLE
74139: EQUAL
74140: IFTRUE 74144
74142: GO 74950
74144: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74145: LD_VAR 0 6
74149: PPUSH
74150: CALL_OW 264
74154: PUSH
74155: LD_INT 2
74157: PUSH
74158: LD_INT 42
74160: PUSH
74161: LD_INT 24
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: LIST
74168: IN
74169: IFFALSE 74190
// points := [ 25 , 5 , 3 ] ;
74171: LD_ADDR_VAR 0 9
74175: PUSH
74176: LD_INT 25
74178: PUSH
74179: LD_INT 5
74181: PUSH
74182: LD_INT 3
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: LIST
74189: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74190: LD_VAR 0 6
74194: PPUSH
74195: CALL_OW 264
74199: PUSH
74200: LD_INT 4
74202: PUSH
74203: LD_INT 43
74205: PUSH
74206: LD_INT 25
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: LIST
74213: IN
74214: IFFALSE 74235
// points := [ 40 , 15 , 5 ] ;
74216: LD_ADDR_VAR 0 9
74220: PUSH
74221: LD_INT 40
74223: PUSH
74224: LD_INT 15
74226: PUSH
74227: LD_INT 5
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: LIST
74234: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74235: LD_VAR 0 6
74239: PPUSH
74240: CALL_OW 264
74244: PUSH
74245: LD_INT 3
74247: PUSH
74248: LD_INT 23
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: IN
74255: IFFALSE 74276
// points := [ 7 , 25 , 8 ] ;
74257: LD_ADDR_VAR 0 9
74261: PUSH
74262: LD_INT 7
74264: PUSH
74265: LD_INT 25
74267: PUSH
74268: LD_INT 8
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: LIST
74275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74276: LD_VAR 0 6
74280: PPUSH
74281: CALL_OW 264
74285: PUSH
74286: LD_INT 5
74288: PUSH
74289: LD_INT 27
74291: PUSH
74292: LD_INT 44
74294: PUSH
74295: EMPTY
74296: LIST
74297: LIST
74298: LIST
74299: IN
74300: IFFALSE 74321
// points := [ 14 , 50 , 16 ] ;
74302: LD_ADDR_VAR 0 9
74306: PUSH
74307: LD_INT 14
74309: PUSH
74310: LD_INT 50
74312: PUSH
74313: LD_INT 16
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: LIST
74320: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74321: LD_VAR 0 6
74325: PPUSH
74326: CALL_OW 264
74330: PUSH
74331: LD_INT 6
74333: PUSH
74334: LD_INT 46
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: IN
74341: IFFALSE 74362
// points := [ 32 , 120 , 70 ] ;
74343: LD_ADDR_VAR 0 9
74347: PUSH
74348: LD_INT 32
74350: PUSH
74351: LD_INT 120
74353: PUSH
74354: LD_INT 70
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: LIST
74361: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74362: LD_VAR 0 6
74366: PPUSH
74367: CALL_OW 264
74371: PUSH
74372: LD_INT 7
74374: PUSH
74375: LD_INT 28
74377: PUSH
74378: LD_INT 45
74380: PUSH
74381: LD_INT 92
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: IN
74390: IFFALSE 74411
// points := [ 35 , 20 , 45 ] ;
74392: LD_ADDR_VAR 0 9
74396: PUSH
74397: LD_INT 35
74399: PUSH
74400: LD_INT 20
74402: PUSH
74403: LD_INT 45
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: LIST
74410: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74411: LD_VAR 0 6
74415: PPUSH
74416: CALL_OW 264
74420: PUSH
74421: LD_INT 47
74423: PUSH
74424: EMPTY
74425: LIST
74426: IN
74427: IFFALSE 74448
// points := [ 67 , 45 , 75 ] ;
74429: LD_ADDR_VAR 0 9
74433: PUSH
74434: LD_INT 67
74436: PUSH
74437: LD_INT 45
74439: PUSH
74440: LD_INT 75
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: LIST
74447: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74448: LD_VAR 0 6
74452: PPUSH
74453: CALL_OW 264
74457: PUSH
74458: LD_INT 26
74460: PUSH
74461: EMPTY
74462: LIST
74463: IN
74464: IFFALSE 74485
// points := [ 120 , 30 , 80 ] ;
74466: LD_ADDR_VAR 0 9
74470: PUSH
74471: LD_INT 120
74473: PUSH
74474: LD_INT 30
74476: PUSH
74477: LD_INT 80
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: LIST
74484: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74485: LD_VAR 0 6
74489: PPUSH
74490: CALL_OW 264
74494: PUSH
74495: LD_INT 22
74497: PUSH
74498: EMPTY
74499: LIST
74500: IN
74501: IFFALSE 74522
// points := [ 40 , 1 , 1 ] ;
74503: LD_ADDR_VAR 0 9
74507: PUSH
74508: LD_INT 40
74510: PUSH
74511: LD_INT 1
74513: PUSH
74514: LD_INT 1
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: LIST
74521: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74522: LD_VAR 0 6
74526: PPUSH
74527: CALL_OW 264
74531: PUSH
74532: LD_INT 29
74534: PUSH
74535: EMPTY
74536: LIST
74537: IN
74538: IFFALSE 74559
// points := [ 70 , 200 , 400 ] ;
74540: LD_ADDR_VAR 0 9
74544: PUSH
74545: LD_INT 70
74547: PUSH
74548: LD_INT 200
74550: PUSH
74551: LD_INT 400
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: LIST
74558: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74559: LD_VAR 0 6
74563: PPUSH
74564: CALL_OW 264
74568: PUSH
74569: LD_INT 14
74571: PUSH
74572: LD_INT 53
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: IN
74579: IFFALSE 74600
// points := [ 40 , 10 , 20 ] ;
74581: LD_ADDR_VAR 0 9
74585: PUSH
74586: LD_INT 40
74588: PUSH
74589: LD_INT 10
74591: PUSH
74592: LD_INT 20
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: LIST
74599: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74600: LD_VAR 0 6
74604: PPUSH
74605: CALL_OW 264
74609: PUSH
74610: LD_INT 9
74612: PUSH
74613: EMPTY
74614: LIST
74615: IN
74616: IFFALSE 74637
// points := [ 5 , 70 , 20 ] ;
74618: LD_ADDR_VAR 0 9
74622: PUSH
74623: LD_INT 5
74625: PUSH
74626: LD_INT 70
74628: PUSH
74629: LD_INT 20
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: LIST
74636: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74637: LD_VAR 0 6
74641: PPUSH
74642: CALL_OW 264
74646: PUSH
74647: LD_INT 10
74649: PUSH
74650: EMPTY
74651: LIST
74652: IN
74653: IFFALSE 74674
// points := [ 35 , 110 , 70 ] ;
74655: LD_ADDR_VAR 0 9
74659: PUSH
74660: LD_INT 35
74662: PUSH
74663: LD_INT 110
74665: PUSH
74666: LD_INT 70
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: LIST
74673: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74674: LD_VAR 0 6
74678: PPUSH
74679: CALL_OW 265
74683: PUSH
74684: LD_INT 25
74686: EQUAL
74687: IFFALSE 74708
// points := [ 80 , 65 , 100 ] ;
74689: LD_ADDR_VAR 0 9
74693: PUSH
74694: LD_INT 80
74696: PUSH
74697: LD_INT 65
74699: PUSH
74700: LD_INT 100
74702: PUSH
74703: EMPTY
74704: LIST
74705: LIST
74706: LIST
74707: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74708: LD_VAR 0 6
74712: PPUSH
74713: CALL_OW 263
74717: PUSH
74718: LD_INT 1
74720: EQUAL
74721: IFFALSE 74756
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74723: LD_ADDR_VAR 0 10
74727: PUSH
74728: LD_VAR 0 10
74732: PUSH
74733: LD_VAR 0 6
74737: PPUSH
74738: CALL_OW 311
74742: PPUSH
74743: LD_INT 3
74745: PPUSH
74746: CALL_OW 259
74750: PUSH
74751: LD_INT 4
74753: MUL
74754: MUL
74755: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74756: LD_VAR 0 6
74760: PPUSH
74761: CALL_OW 263
74765: PUSH
74766: LD_INT 2
74768: EQUAL
74769: IFFALSE 74820
// begin j := IsControledBy ( i ) ;
74771: LD_ADDR_VAR 0 7
74775: PUSH
74776: LD_VAR 0 6
74780: PPUSH
74781: CALL_OW 312
74785: ST_TO_ADDR
// if j then
74786: LD_VAR 0 7
74790: IFFALSE 74820
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74792: LD_ADDR_VAR 0 10
74796: PUSH
74797: LD_VAR 0 10
74801: PUSH
74802: LD_VAR 0 7
74806: PPUSH
74807: LD_INT 3
74809: PPUSH
74810: CALL_OW 259
74814: PUSH
74815: LD_INT 3
74817: MUL
74818: MUL
74819: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74820: LD_VAR 0 6
74824: PPUSH
74825: CALL_OW 264
74829: PUSH
74830: LD_INT 5
74832: PUSH
74833: LD_INT 6
74835: PUSH
74836: LD_INT 46
74838: PUSH
74839: LD_INT 44
74841: PUSH
74842: LD_INT 47
74844: PUSH
74845: LD_INT 45
74847: PUSH
74848: LD_INT 28
74850: PUSH
74851: LD_INT 7
74853: PUSH
74854: LD_INT 27
74856: PUSH
74857: LD_INT 29
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: IN
74872: PUSH
74873: LD_VAR 0 1
74877: PPUSH
74878: LD_INT 52
74880: PPUSH
74881: CALL_OW 321
74885: PUSH
74886: LD_INT 2
74888: EQUAL
74889: AND
74890: IFFALSE 74907
// bpoints := bpoints * 1.2 ;
74892: LD_ADDR_VAR 0 10
74896: PUSH
74897: LD_VAR 0 10
74901: PUSH
74902: LD_REAL  1.20000000000000E+0000
74905: MUL
74906: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74907: LD_VAR 0 6
74911: PPUSH
74912: CALL_OW 264
74916: PUSH
74917: LD_INT 6
74919: PUSH
74920: LD_INT 46
74922: PUSH
74923: LD_INT 47
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: LIST
74930: IN
74931: IFFALSE 74948
// bpoints := bpoints * 1.2 ;
74933: LD_ADDR_VAR 0 10
74937: PUSH
74938: LD_VAR 0 10
74942: PUSH
74943: LD_REAL  1.20000000000000E+0000
74946: MUL
74947: ST_TO_ADDR
// end ; unit_building :
74948: GO 74962
74950: LD_INT 3
74952: DOUBLE
74953: EQUAL
74954: IFTRUE 74958
74956: GO 74961
74958: POP
// ; end ;
74959: GO 74962
74961: POP
// for j = 1 to 3 do
74962: LD_ADDR_VAR 0 7
74966: PUSH
74967: DOUBLE
74968: LD_INT 1
74970: DEC
74971: ST_TO_ADDR
74972: LD_INT 3
74974: PUSH
74975: FOR_TO
74976: IFFALSE 75029
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74978: LD_ADDR_VAR 0 5
74982: PUSH
74983: LD_VAR 0 5
74987: PPUSH
74988: LD_VAR 0 7
74992: PPUSH
74993: LD_VAR 0 5
74997: PUSH
74998: LD_VAR 0 7
75002: ARRAY
75003: PUSH
75004: LD_VAR 0 9
75008: PUSH
75009: LD_VAR 0 7
75013: ARRAY
75014: PUSH
75015: LD_VAR 0 10
75019: MUL
75020: PLUS
75021: PPUSH
75022: CALL_OW 1
75026: ST_TO_ADDR
75027: GO 74975
75029: POP
75030: POP
// end ;
75031: GO 73510
75033: POP
75034: POP
// result := Replace ( result , 4 , tmp ) ;
75035: LD_ADDR_VAR 0 5
75039: PUSH
75040: LD_VAR 0 5
75044: PPUSH
75045: LD_INT 4
75047: PPUSH
75048: LD_VAR 0 8
75052: PPUSH
75053: CALL_OW 1
75057: ST_TO_ADDR
// end ;
75058: LD_VAR 0 5
75062: RET
// export function DangerAtRange ( unit , range ) ; begin
75063: LD_INT 0
75065: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75066: LD_ADDR_VAR 0 3
75070: PUSH
75071: LD_VAR 0 1
75075: PPUSH
75076: CALL_OW 255
75080: PPUSH
75081: LD_VAR 0 1
75085: PPUSH
75086: CALL_OW 250
75090: PPUSH
75091: LD_VAR 0 1
75095: PPUSH
75096: CALL_OW 251
75100: PPUSH
75101: LD_VAR 0 2
75105: PPUSH
75106: CALL 73362 0 4
75110: ST_TO_ADDR
// end ;
75111: LD_VAR 0 3
75115: RET
// export function DangerInArea ( side , area ) ; begin
75116: LD_INT 0
75118: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75119: LD_ADDR_VAR 0 3
75123: PUSH
75124: LD_VAR 0 2
75128: PPUSH
75129: LD_INT 81
75131: PUSH
75132: LD_VAR 0 1
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PPUSH
75141: CALL_OW 70
75145: ST_TO_ADDR
// end ;
75146: LD_VAR 0 3
75150: RET
// export function IsExtension ( b ) ; begin
75151: LD_INT 0
75153: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75154: LD_ADDR_VAR 0 2
75158: PUSH
75159: LD_VAR 0 1
75163: PUSH
75164: LD_INT 23
75166: PUSH
75167: LD_INT 20
75169: PUSH
75170: LD_INT 22
75172: PUSH
75173: LD_INT 17
75175: PUSH
75176: LD_INT 24
75178: PUSH
75179: LD_INT 21
75181: PUSH
75182: LD_INT 19
75184: PUSH
75185: LD_INT 16
75187: PUSH
75188: LD_INT 25
75190: PUSH
75191: LD_INT 18
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: LIST
75198: LIST
75199: LIST
75200: LIST
75201: LIST
75202: LIST
75203: LIST
75204: LIST
75205: IN
75206: ST_TO_ADDR
// end ;
75207: LD_VAR 0 2
75211: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75212: LD_INT 0
75214: PPUSH
75215: PPUSH
75216: PPUSH
// result := [ ] ;
75217: LD_ADDR_VAR 0 4
75221: PUSH
75222: EMPTY
75223: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75224: LD_ADDR_VAR 0 5
75228: PUSH
75229: LD_VAR 0 2
75233: PPUSH
75234: LD_INT 21
75236: PUSH
75237: LD_INT 3
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PPUSH
75244: CALL_OW 70
75248: ST_TO_ADDR
// if not tmp then
75249: LD_VAR 0 5
75253: NOT
75254: IFFALSE 75258
// exit ;
75256: GO 75322
// if checkLink then
75258: LD_VAR 0 3
75262: IFFALSE 75312
// begin for i in tmp do
75264: LD_ADDR_VAR 0 6
75268: PUSH
75269: LD_VAR 0 5
75273: PUSH
75274: FOR_IN
75275: IFFALSE 75310
// if GetBase ( i ) <> base then
75277: LD_VAR 0 6
75281: PPUSH
75282: CALL_OW 274
75286: PUSH
75287: LD_VAR 0 1
75291: NONEQUAL
75292: IFFALSE 75308
// ComLinkToBase ( base , i ) ;
75294: LD_VAR 0 1
75298: PPUSH
75299: LD_VAR 0 6
75303: PPUSH
75304: CALL_OW 169
75308: GO 75274
75310: POP
75311: POP
// end ; result := tmp ;
75312: LD_ADDR_VAR 0 4
75316: PUSH
75317: LD_VAR 0 5
75321: ST_TO_ADDR
// end ;
75322: LD_VAR 0 4
75326: RET
// export function ComComplete ( units , b ) ; var i ; begin
75327: LD_INT 0
75329: PPUSH
75330: PPUSH
// if not units then
75331: LD_VAR 0 1
75335: NOT
75336: IFFALSE 75340
// exit ;
75338: GO 75430
// for i in units do
75340: LD_ADDR_VAR 0 4
75344: PUSH
75345: LD_VAR 0 1
75349: PUSH
75350: FOR_IN
75351: IFFALSE 75428
// if BuildingStatus ( b ) = bs_build then
75353: LD_VAR 0 2
75357: PPUSH
75358: CALL_OW 461
75362: PUSH
75363: LD_INT 1
75365: EQUAL
75366: IFFALSE 75426
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75368: LD_VAR 0 4
75372: PPUSH
75373: LD_STRING h
75375: PUSH
75376: LD_VAR 0 2
75380: PPUSH
75381: CALL_OW 250
75385: PUSH
75386: LD_VAR 0 2
75390: PPUSH
75391: CALL_OW 251
75395: PUSH
75396: LD_VAR 0 2
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: LD_INT 0
75406: PUSH
75407: LD_INT 0
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: LIST
75416: LIST
75417: LIST
75418: PUSH
75419: EMPTY
75420: LIST
75421: PPUSH
75422: CALL_OW 446
75426: GO 75350
75428: POP
75429: POP
// end ;
75430: LD_VAR 0 3
75434: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75435: LD_INT 0
75437: PPUSH
75438: PPUSH
75439: PPUSH
75440: PPUSH
75441: PPUSH
75442: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75443: LD_VAR 0 1
75447: NOT
75448: PUSH
75449: LD_VAR 0 1
75453: PPUSH
75454: CALL_OW 263
75458: PUSH
75459: LD_INT 2
75461: NONEQUAL
75462: OR
75463: IFFALSE 75467
// exit ;
75465: GO 75783
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75467: LD_ADDR_VAR 0 6
75471: PUSH
75472: LD_INT 22
75474: PUSH
75475: LD_VAR 0 1
75479: PPUSH
75480: CALL_OW 255
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 2
75491: PUSH
75492: LD_INT 30
75494: PUSH
75495: LD_INT 36
75497: PUSH
75498: EMPTY
75499: LIST
75500: LIST
75501: PUSH
75502: LD_INT 34
75504: PUSH
75505: LD_INT 31
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: LIST
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: PPUSH
75521: CALL_OW 69
75525: ST_TO_ADDR
// if not tmp then
75526: LD_VAR 0 6
75530: NOT
75531: IFFALSE 75535
// exit ;
75533: GO 75783
// result := [ ] ;
75535: LD_ADDR_VAR 0 2
75539: PUSH
75540: EMPTY
75541: ST_TO_ADDR
// for i in tmp do
75542: LD_ADDR_VAR 0 3
75546: PUSH
75547: LD_VAR 0 6
75551: PUSH
75552: FOR_IN
75553: IFFALSE 75624
// begin t := UnitsInside ( i ) ;
75555: LD_ADDR_VAR 0 4
75559: PUSH
75560: LD_VAR 0 3
75564: PPUSH
75565: CALL_OW 313
75569: ST_TO_ADDR
// if t then
75570: LD_VAR 0 4
75574: IFFALSE 75622
// for j in t do
75576: LD_ADDR_VAR 0 7
75580: PUSH
75581: LD_VAR 0 4
75585: PUSH
75586: FOR_IN
75587: IFFALSE 75620
// result := Replace ( result , result + 1 , j ) ;
75589: LD_ADDR_VAR 0 2
75593: PUSH
75594: LD_VAR 0 2
75598: PPUSH
75599: LD_VAR 0 2
75603: PUSH
75604: LD_INT 1
75606: PLUS
75607: PPUSH
75608: LD_VAR 0 7
75612: PPUSH
75613: CALL_OW 1
75617: ST_TO_ADDR
75618: GO 75586
75620: POP
75621: POP
// end ;
75622: GO 75552
75624: POP
75625: POP
// if not result then
75626: LD_VAR 0 2
75630: NOT
75631: IFFALSE 75635
// exit ;
75633: GO 75783
// mech := result [ 1 ] ;
75635: LD_ADDR_VAR 0 5
75639: PUSH
75640: LD_VAR 0 2
75644: PUSH
75645: LD_INT 1
75647: ARRAY
75648: ST_TO_ADDR
// if result > 1 then
75649: LD_VAR 0 2
75653: PUSH
75654: LD_INT 1
75656: GREATER
75657: IFFALSE 75769
// begin for i = 2 to result do
75659: LD_ADDR_VAR 0 3
75663: PUSH
75664: DOUBLE
75665: LD_INT 2
75667: DEC
75668: ST_TO_ADDR
75669: LD_VAR 0 2
75673: PUSH
75674: FOR_TO
75675: IFFALSE 75767
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75677: LD_ADDR_VAR 0 4
75681: PUSH
75682: LD_VAR 0 2
75686: PUSH
75687: LD_VAR 0 3
75691: ARRAY
75692: PPUSH
75693: LD_INT 3
75695: PPUSH
75696: CALL_OW 259
75700: PUSH
75701: LD_VAR 0 2
75705: PUSH
75706: LD_VAR 0 3
75710: ARRAY
75711: PPUSH
75712: CALL_OW 432
75716: MINUS
75717: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75718: LD_VAR 0 4
75722: PUSH
75723: LD_VAR 0 5
75727: PPUSH
75728: LD_INT 3
75730: PPUSH
75731: CALL_OW 259
75735: PUSH
75736: LD_VAR 0 5
75740: PPUSH
75741: CALL_OW 432
75745: MINUS
75746: GREATEREQUAL
75747: IFFALSE 75765
// mech := result [ i ] ;
75749: LD_ADDR_VAR 0 5
75753: PUSH
75754: LD_VAR 0 2
75758: PUSH
75759: LD_VAR 0 3
75763: ARRAY
75764: ST_TO_ADDR
// end ;
75765: GO 75674
75767: POP
75768: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75769: LD_VAR 0 1
75773: PPUSH
75774: LD_VAR 0 5
75778: PPUSH
75779: CALL_OW 135
// end ;
75783: LD_VAR 0 2
75787: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75788: LD_INT 0
75790: PPUSH
75791: PPUSH
75792: PPUSH
75793: PPUSH
75794: PPUSH
75795: PPUSH
75796: PPUSH
75797: PPUSH
75798: PPUSH
75799: PPUSH
75800: PPUSH
75801: PPUSH
75802: PPUSH
// result := [ ] ;
75803: LD_ADDR_VAR 0 7
75807: PUSH
75808: EMPTY
75809: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75810: LD_VAR 0 1
75814: PPUSH
75815: CALL_OW 266
75819: PUSH
75820: LD_INT 0
75822: PUSH
75823: LD_INT 1
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: IN
75830: NOT
75831: IFFALSE 75835
// exit ;
75833: GO 77469
// if name then
75835: LD_VAR 0 3
75839: IFFALSE 75855
// SetBName ( base_dep , name ) ;
75841: LD_VAR 0 1
75845: PPUSH
75846: LD_VAR 0 3
75850: PPUSH
75851: CALL_OW 500
// base := GetBase ( base_dep ) ;
75855: LD_ADDR_VAR 0 15
75859: PUSH
75860: LD_VAR 0 1
75864: PPUSH
75865: CALL_OW 274
75869: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75870: LD_ADDR_VAR 0 16
75874: PUSH
75875: LD_VAR 0 1
75879: PPUSH
75880: CALL_OW 255
75884: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75885: LD_ADDR_VAR 0 17
75889: PUSH
75890: LD_VAR 0 1
75894: PPUSH
75895: CALL_OW 248
75899: ST_TO_ADDR
// if sources then
75900: LD_VAR 0 5
75904: IFFALSE 75951
// for i = 1 to 3 do
75906: LD_ADDR_VAR 0 8
75910: PUSH
75911: DOUBLE
75912: LD_INT 1
75914: DEC
75915: ST_TO_ADDR
75916: LD_INT 3
75918: PUSH
75919: FOR_TO
75920: IFFALSE 75949
// AddResourceType ( base , i , sources [ i ] ) ;
75922: LD_VAR 0 15
75926: PPUSH
75927: LD_VAR 0 8
75931: PPUSH
75932: LD_VAR 0 5
75936: PUSH
75937: LD_VAR 0 8
75941: ARRAY
75942: PPUSH
75943: CALL_OW 276
75947: GO 75919
75949: POP
75950: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
75951: LD_ADDR_VAR 0 18
75955: PUSH
75956: LD_VAR 0 15
75960: PPUSH
75961: LD_VAR 0 2
75965: PPUSH
75966: LD_INT 1
75968: PPUSH
75969: CALL 75212 0 3
75973: ST_TO_ADDR
// InitHc ;
75974: CALL_OW 19
// InitUc ;
75978: CALL_OW 18
// uc_side := side ;
75982: LD_ADDR_OWVAR 20
75986: PUSH
75987: LD_VAR 0 16
75991: ST_TO_ADDR
// uc_nation := nation ;
75992: LD_ADDR_OWVAR 21
75996: PUSH
75997: LD_VAR 0 17
76001: ST_TO_ADDR
// if buildings then
76002: LD_VAR 0 18
76006: IFFALSE 77328
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76008: LD_ADDR_VAR 0 19
76012: PUSH
76013: LD_VAR 0 18
76017: PPUSH
76018: LD_INT 2
76020: PUSH
76021: LD_INT 30
76023: PUSH
76024: LD_INT 29
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 30
76033: PUSH
76034: LD_INT 30
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: LIST
76045: PPUSH
76046: CALL_OW 72
76050: ST_TO_ADDR
// if tmp then
76051: LD_VAR 0 19
76055: IFFALSE 76103
// for i in tmp do
76057: LD_ADDR_VAR 0 8
76061: PUSH
76062: LD_VAR 0 19
76066: PUSH
76067: FOR_IN
76068: IFFALSE 76101
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76070: LD_VAR 0 8
76074: PPUSH
76075: CALL_OW 250
76079: PPUSH
76080: LD_VAR 0 8
76084: PPUSH
76085: CALL_OW 251
76089: PPUSH
76090: LD_VAR 0 16
76094: PPUSH
76095: CALL_OW 441
76099: GO 76067
76101: POP
76102: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76103: LD_VAR 0 18
76107: PPUSH
76108: LD_INT 2
76110: PUSH
76111: LD_INT 30
76113: PUSH
76114: LD_INT 32
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 30
76123: PUSH
76124: LD_INT 33
76126: PUSH
76127: EMPTY
76128: LIST
76129: LIST
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: LIST
76135: PPUSH
76136: CALL_OW 72
76140: IFFALSE 76228
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76142: LD_ADDR_VAR 0 8
76146: PUSH
76147: LD_VAR 0 18
76151: PPUSH
76152: LD_INT 2
76154: PUSH
76155: LD_INT 30
76157: PUSH
76158: LD_INT 32
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 30
76167: PUSH
76168: LD_INT 33
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: LIST
76179: PPUSH
76180: CALL_OW 72
76184: PUSH
76185: FOR_IN
76186: IFFALSE 76226
// begin if not GetBWeapon ( i ) then
76188: LD_VAR 0 8
76192: PPUSH
76193: CALL_OW 269
76197: NOT
76198: IFFALSE 76224
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76200: LD_VAR 0 8
76204: PPUSH
76205: LD_VAR 0 8
76209: PPUSH
76210: LD_VAR 0 2
76214: PPUSH
76215: CALL 77474 0 2
76219: PPUSH
76220: CALL_OW 431
// end ;
76224: GO 76185
76226: POP
76227: POP
// end ; for i = 1 to personel do
76228: LD_ADDR_VAR 0 8
76232: PUSH
76233: DOUBLE
76234: LD_INT 1
76236: DEC
76237: ST_TO_ADDR
76238: LD_VAR 0 6
76242: PUSH
76243: FOR_TO
76244: IFFALSE 77308
// begin if i > 4 then
76246: LD_VAR 0 8
76250: PUSH
76251: LD_INT 4
76253: GREATER
76254: IFFALSE 76258
// break ;
76256: GO 77308
// case i of 1 :
76258: LD_VAR 0 8
76262: PUSH
76263: LD_INT 1
76265: DOUBLE
76266: EQUAL
76267: IFTRUE 76271
76269: GO 76351
76271: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76272: LD_ADDR_VAR 0 12
76276: PUSH
76277: LD_VAR 0 18
76281: PPUSH
76282: LD_INT 22
76284: PUSH
76285: LD_VAR 0 16
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 58
76296: PUSH
76297: EMPTY
76298: LIST
76299: PUSH
76300: LD_INT 2
76302: PUSH
76303: LD_INT 30
76305: PUSH
76306: LD_INT 32
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 30
76315: PUSH
76316: LD_INT 4
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 30
76325: PUSH
76326: LD_INT 5
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: LIST
76343: PPUSH
76344: CALL_OW 72
76348: ST_TO_ADDR
76349: GO 76573
76351: LD_INT 2
76353: DOUBLE
76354: EQUAL
76355: IFTRUE 76359
76357: GO 76421
76359: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76360: LD_ADDR_VAR 0 12
76364: PUSH
76365: LD_VAR 0 18
76369: PPUSH
76370: LD_INT 22
76372: PUSH
76373: LD_VAR 0 16
76377: PUSH
76378: EMPTY
76379: LIST
76380: LIST
76381: PUSH
76382: LD_INT 2
76384: PUSH
76385: LD_INT 30
76387: PUSH
76388: LD_INT 0
76390: PUSH
76391: EMPTY
76392: LIST
76393: LIST
76394: PUSH
76395: LD_INT 30
76397: PUSH
76398: LD_INT 1
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: LIST
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PPUSH
76414: CALL_OW 72
76418: ST_TO_ADDR
76419: GO 76573
76421: LD_INT 3
76423: DOUBLE
76424: EQUAL
76425: IFTRUE 76429
76427: GO 76491
76429: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76430: LD_ADDR_VAR 0 12
76434: PUSH
76435: LD_VAR 0 18
76439: PPUSH
76440: LD_INT 22
76442: PUSH
76443: LD_VAR 0 16
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: LD_INT 2
76454: PUSH
76455: LD_INT 30
76457: PUSH
76458: LD_INT 2
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: LD_INT 30
76467: PUSH
76468: LD_INT 3
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: LIST
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PPUSH
76484: CALL_OW 72
76488: ST_TO_ADDR
76489: GO 76573
76491: LD_INT 4
76493: DOUBLE
76494: EQUAL
76495: IFTRUE 76499
76497: GO 76572
76499: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76500: LD_ADDR_VAR 0 12
76504: PUSH
76505: LD_VAR 0 18
76509: PPUSH
76510: LD_INT 22
76512: PUSH
76513: LD_VAR 0 16
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 2
76524: PUSH
76525: LD_INT 30
76527: PUSH
76528: LD_INT 6
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PUSH
76535: LD_INT 30
76537: PUSH
76538: LD_INT 7
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: PUSH
76545: LD_INT 30
76547: PUSH
76548: LD_INT 8
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PPUSH
76565: CALL_OW 72
76569: ST_TO_ADDR
76570: GO 76573
76572: POP
// if i = 1 then
76573: LD_VAR 0 8
76577: PUSH
76578: LD_INT 1
76580: EQUAL
76581: IFFALSE 76692
// begin tmp := [ ] ;
76583: LD_ADDR_VAR 0 19
76587: PUSH
76588: EMPTY
76589: ST_TO_ADDR
// for j in f do
76590: LD_ADDR_VAR 0 9
76594: PUSH
76595: LD_VAR 0 12
76599: PUSH
76600: FOR_IN
76601: IFFALSE 76674
// if GetBType ( j ) = b_bunker then
76603: LD_VAR 0 9
76607: PPUSH
76608: CALL_OW 266
76612: PUSH
76613: LD_INT 32
76615: EQUAL
76616: IFFALSE 76643
// tmp := Insert ( tmp , 1 , j ) else
76618: LD_ADDR_VAR 0 19
76622: PUSH
76623: LD_VAR 0 19
76627: PPUSH
76628: LD_INT 1
76630: PPUSH
76631: LD_VAR 0 9
76635: PPUSH
76636: CALL_OW 2
76640: ST_TO_ADDR
76641: GO 76672
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76643: LD_ADDR_VAR 0 19
76647: PUSH
76648: LD_VAR 0 19
76652: PPUSH
76653: LD_VAR 0 19
76657: PUSH
76658: LD_INT 1
76660: PLUS
76661: PPUSH
76662: LD_VAR 0 9
76666: PPUSH
76667: CALL_OW 2
76671: ST_TO_ADDR
76672: GO 76600
76674: POP
76675: POP
// if tmp then
76676: LD_VAR 0 19
76680: IFFALSE 76692
// f := tmp ;
76682: LD_ADDR_VAR 0 12
76686: PUSH
76687: LD_VAR 0 19
76691: ST_TO_ADDR
// end ; x := personel [ i ] ;
76692: LD_ADDR_VAR 0 13
76696: PUSH
76697: LD_VAR 0 6
76701: PUSH
76702: LD_VAR 0 8
76706: ARRAY
76707: ST_TO_ADDR
// if x = - 1 then
76708: LD_VAR 0 13
76712: PUSH
76713: LD_INT 1
76715: NEG
76716: EQUAL
76717: IFFALSE 76926
// begin for j in f do
76719: LD_ADDR_VAR 0 9
76723: PUSH
76724: LD_VAR 0 12
76728: PUSH
76729: FOR_IN
76730: IFFALSE 76922
// repeat InitHc ;
76732: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76736: LD_VAR 0 9
76740: PPUSH
76741: CALL_OW 266
76745: PUSH
76746: LD_INT 5
76748: EQUAL
76749: IFFALSE 76819
// begin if UnitsInside ( j ) < 3 then
76751: LD_VAR 0 9
76755: PPUSH
76756: CALL_OW 313
76760: PUSH
76761: LD_INT 3
76763: LESS
76764: IFFALSE 76800
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76766: LD_INT 0
76768: PPUSH
76769: LD_INT 5
76771: PUSH
76772: LD_INT 8
76774: PUSH
76775: LD_INT 9
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: LIST
76782: PUSH
76783: LD_VAR 0 17
76787: ARRAY
76788: PPUSH
76789: LD_VAR 0 4
76793: PPUSH
76794: CALL_OW 380
76798: GO 76817
// PrepareHuman ( false , i , skill ) ;
76800: LD_INT 0
76802: PPUSH
76803: LD_VAR 0 8
76807: PPUSH
76808: LD_VAR 0 4
76812: PPUSH
76813: CALL_OW 380
// end else
76817: GO 76836
// PrepareHuman ( false , i , skill ) ;
76819: LD_INT 0
76821: PPUSH
76822: LD_VAR 0 8
76826: PPUSH
76827: LD_VAR 0 4
76831: PPUSH
76832: CALL_OW 380
// un := CreateHuman ;
76836: LD_ADDR_VAR 0 14
76840: PUSH
76841: CALL_OW 44
76845: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76846: LD_ADDR_VAR 0 7
76850: PUSH
76851: LD_VAR 0 7
76855: PPUSH
76856: LD_INT 1
76858: PPUSH
76859: LD_VAR 0 14
76863: PPUSH
76864: CALL_OW 2
76868: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76869: LD_VAR 0 14
76873: PPUSH
76874: LD_VAR 0 9
76878: PPUSH
76879: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76883: LD_VAR 0 9
76887: PPUSH
76888: CALL_OW 313
76892: PUSH
76893: LD_INT 6
76895: EQUAL
76896: PUSH
76897: LD_VAR 0 9
76901: PPUSH
76902: CALL_OW 266
76906: PUSH
76907: LD_INT 32
76909: PUSH
76910: LD_INT 31
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: IN
76917: OR
76918: IFFALSE 76732
76920: GO 76729
76922: POP
76923: POP
// end else
76924: GO 77306
// for j = 1 to x do
76926: LD_ADDR_VAR 0 9
76930: PUSH
76931: DOUBLE
76932: LD_INT 1
76934: DEC
76935: ST_TO_ADDR
76936: LD_VAR 0 13
76940: PUSH
76941: FOR_TO
76942: IFFALSE 77304
// begin InitHc ;
76944: CALL_OW 19
// if not f then
76948: LD_VAR 0 12
76952: NOT
76953: IFFALSE 77042
// begin PrepareHuman ( false , i , skill ) ;
76955: LD_INT 0
76957: PPUSH
76958: LD_VAR 0 8
76962: PPUSH
76963: LD_VAR 0 4
76967: PPUSH
76968: CALL_OW 380
// un := CreateHuman ;
76972: LD_ADDR_VAR 0 14
76976: PUSH
76977: CALL_OW 44
76981: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76982: LD_ADDR_VAR 0 7
76986: PUSH
76987: LD_VAR 0 7
76991: PPUSH
76992: LD_INT 1
76994: PPUSH
76995: LD_VAR 0 14
76999: PPUSH
77000: CALL_OW 2
77004: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77005: LD_VAR 0 14
77009: PPUSH
77010: LD_VAR 0 1
77014: PPUSH
77015: CALL_OW 250
77019: PPUSH
77020: LD_VAR 0 1
77024: PPUSH
77025: CALL_OW 251
77029: PPUSH
77030: LD_INT 10
77032: PPUSH
77033: LD_INT 0
77035: PPUSH
77036: CALL_OW 50
// continue ;
77040: GO 76941
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77042: LD_VAR 0 12
77046: PUSH
77047: LD_INT 1
77049: ARRAY
77050: PPUSH
77051: CALL_OW 313
77055: PUSH
77056: LD_VAR 0 12
77060: PUSH
77061: LD_INT 1
77063: ARRAY
77064: PPUSH
77065: CALL_OW 266
77069: PUSH
77070: LD_INT 32
77072: PUSH
77073: LD_INT 31
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: IN
77080: AND
77081: PUSH
77082: LD_VAR 0 12
77086: PUSH
77087: LD_INT 1
77089: ARRAY
77090: PPUSH
77091: CALL_OW 313
77095: PUSH
77096: LD_INT 6
77098: EQUAL
77099: OR
77100: IFFALSE 77120
// f := Delete ( f , 1 ) ;
77102: LD_ADDR_VAR 0 12
77106: PUSH
77107: LD_VAR 0 12
77111: PPUSH
77112: LD_INT 1
77114: PPUSH
77115: CALL_OW 3
77119: ST_TO_ADDR
// if not f then
77120: LD_VAR 0 12
77124: NOT
77125: IFFALSE 77143
// begin x := x + 2 ;
77127: LD_ADDR_VAR 0 13
77131: PUSH
77132: LD_VAR 0 13
77136: PUSH
77137: LD_INT 2
77139: PLUS
77140: ST_TO_ADDR
// continue ;
77141: GO 76941
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77143: LD_VAR 0 12
77147: PUSH
77148: LD_INT 1
77150: ARRAY
77151: PPUSH
77152: CALL_OW 266
77156: PUSH
77157: LD_INT 5
77159: EQUAL
77160: IFFALSE 77234
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77162: LD_VAR 0 12
77166: PUSH
77167: LD_INT 1
77169: ARRAY
77170: PPUSH
77171: CALL_OW 313
77175: PUSH
77176: LD_INT 3
77178: LESS
77179: IFFALSE 77215
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77181: LD_INT 0
77183: PPUSH
77184: LD_INT 5
77186: PUSH
77187: LD_INT 8
77189: PUSH
77190: LD_INT 9
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: LIST
77197: PUSH
77198: LD_VAR 0 17
77202: ARRAY
77203: PPUSH
77204: LD_VAR 0 4
77208: PPUSH
77209: CALL_OW 380
77213: GO 77232
// PrepareHuman ( false , i , skill ) ;
77215: LD_INT 0
77217: PPUSH
77218: LD_VAR 0 8
77222: PPUSH
77223: LD_VAR 0 4
77227: PPUSH
77228: CALL_OW 380
// end else
77232: GO 77251
// PrepareHuman ( false , i , skill ) ;
77234: LD_INT 0
77236: PPUSH
77237: LD_VAR 0 8
77241: PPUSH
77242: LD_VAR 0 4
77246: PPUSH
77247: CALL_OW 380
// un := CreateHuman ;
77251: LD_ADDR_VAR 0 14
77255: PUSH
77256: CALL_OW 44
77260: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77261: LD_ADDR_VAR 0 7
77265: PUSH
77266: LD_VAR 0 7
77270: PPUSH
77271: LD_INT 1
77273: PPUSH
77274: LD_VAR 0 14
77278: PPUSH
77279: CALL_OW 2
77283: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77284: LD_VAR 0 14
77288: PPUSH
77289: LD_VAR 0 12
77293: PUSH
77294: LD_INT 1
77296: ARRAY
77297: PPUSH
77298: CALL_OW 52
// end ;
77302: GO 76941
77304: POP
77305: POP
// end ;
77306: GO 76243
77308: POP
77309: POP
// result := result ^ buildings ;
77310: LD_ADDR_VAR 0 7
77314: PUSH
77315: LD_VAR 0 7
77319: PUSH
77320: LD_VAR 0 18
77324: ADD
77325: ST_TO_ADDR
// end else
77326: GO 77469
// begin for i = 1 to personel do
77328: LD_ADDR_VAR 0 8
77332: PUSH
77333: DOUBLE
77334: LD_INT 1
77336: DEC
77337: ST_TO_ADDR
77338: LD_VAR 0 6
77342: PUSH
77343: FOR_TO
77344: IFFALSE 77467
// begin if i > 4 then
77346: LD_VAR 0 8
77350: PUSH
77351: LD_INT 4
77353: GREATER
77354: IFFALSE 77358
// break ;
77356: GO 77467
// x := personel [ i ] ;
77358: LD_ADDR_VAR 0 13
77362: PUSH
77363: LD_VAR 0 6
77367: PUSH
77368: LD_VAR 0 8
77372: ARRAY
77373: ST_TO_ADDR
// if x = - 1 then
77374: LD_VAR 0 13
77378: PUSH
77379: LD_INT 1
77381: NEG
77382: EQUAL
77383: IFFALSE 77387
// continue ;
77385: GO 77343
// PrepareHuman ( false , i , skill ) ;
77387: LD_INT 0
77389: PPUSH
77390: LD_VAR 0 8
77394: PPUSH
77395: LD_VAR 0 4
77399: PPUSH
77400: CALL_OW 380
// un := CreateHuman ;
77404: LD_ADDR_VAR 0 14
77408: PUSH
77409: CALL_OW 44
77413: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77414: LD_VAR 0 14
77418: PPUSH
77419: LD_VAR 0 1
77423: PPUSH
77424: CALL_OW 250
77428: PPUSH
77429: LD_VAR 0 1
77433: PPUSH
77434: CALL_OW 251
77438: PPUSH
77439: LD_INT 10
77441: PPUSH
77442: LD_INT 0
77444: PPUSH
77445: CALL_OW 50
// result := result ^ un ;
77449: LD_ADDR_VAR 0 7
77453: PUSH
77454: LD_VAR 0 7
77458: PUSH
77459: LD_VAR 0 14
77463: ADD
77464: ST_TO_ADDR
// end ;
77465: GO 77343
77467: POP
77468: POP
// end ; end ;
77469: LD_VAR 0 7
77473: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77474: LD_INT 0
77476: PPUSH
77477: PPUSH
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
77487: PPUSH
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
// result := false ;
77492: LD_ADDR_VAR 0 3
77496: PUSH
77497: LD_INT 0
77499: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77500: LD_VAR 0 1
77504: NOT
77505: PUSH
77506: LD_VAR 0 1
77510: PPUSH
77511: CALL_OW 266
77515: PUSH
77516: LD_INT 32
77518: PUSH
77519: LD_INT 33
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: IN
77526: NOT
77527: OR
77528: IFFALSE 77532
// exit ;
77530: GO 78641
// nat := GetNation ( tower ) ;
77532: LD_ADDR_VAR 0 12
77536: PUSH
77537: LD_VAR 0 1
77541: PPUSH
77542: CALL_OW 248
77546: ST_TO_ADDR
// side := GetSide ( tower ) ;
77547: LD_ADDR_VAR 0 16
77551: PUSH
77552: LD_VAR 0 1
77556: PPUSH
77557: CALL_OW 255
77561: ST_TO_ADDR
// x := GetX ( tower ) ;
77562: LD_ADDR_VAR 0 10
77566: PUSH
77567: LD_VAR 0 1
77571: PPUSH
77572: CALL_OW 250
77576: ST_TO_ADDR
// y := GetY ( tower ) ;
77577: LD_ADDR_VAR 0 11
77581: PUSH
77582: LD_VAR 0 1
77586: PPUSH
77587: CALL_OW 251
77591: ST_TO_ADDR
// if not x or not y then
77592: LD_VAR 0 10
77596: NOT
77597: PUSH
77598: LD_VAR 0 11
77602: NOT
77603: OR
77604: IFFALSE 77608
// exit ;
77606: GO 78641
// weapon := 0 ;
77608: LD_ADDR_VAR 0 18
77612: PUSH
77613: LD_INT 0
77615: ST_TO_ADDR
// fac_list := [ ] ;
77616: LD_ADDR_VAR 0 17
77620: PUSH
77621: EMPTY
77622: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77623: LD_ADDR_VAR 0 6
77627: PUSH
77628: LD_VAR 0 1
77632: PPUSH
77633: CALL_OW 274
77637: PPUSH
77638: LD_VAR 0 2
77642: PPUSH
77643: LD_INT 0
77645: PPUSH
77646: CALL 75212 0 3
77650: PPUSH
77651: LD_INT 30
77653: PUSH
77654: LD_INT 3
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PPUSH
77661: CALL_OW 72
77665: ST_TO_ADDR
// if not factories then
77666: LD_VAR 0 6
77670: NOT
77671: IFFALSE 77675
// exit ;
77673: GO 78641
// for i in factories do
77675: LD_ADDR_VAR 0 8
77679: PUSH
77680: LD_VAR 0 6
77684: PUSH
77685: FOR_IN
77686: IFFALSE 77711
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77688: LD_ADDR_VAR 0 17
77692: PUSH
77693: LD_VAR 0 17
77697: PUSH
77698: LD_VAR 0 8
77702: PPUSH
77703: CALL_OW 478
77707: UNION
77708: ST_TO_ADDR
77709: GO 77685
77711: POP
77712: POP
// if not fac_list then
77713: LD_VAR 0 17
77717: NOT
77718: IFFALSE 77722
// exit ;
77720: GO 78641
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77722: LD_ADDR_VAR 0 5
77726: PUSH
77727: LD_INT 4
77729: PUSH
77730: LD_INT 5
77732: PUSH
77733: LD_INT 9
77735: PUSH
77736: LD_INT 10
77738: PUSH
77739: LD_INT 6
77741: PUSH
77742: LD_INT 7
77744: PUSH
77745: LD_INT 11
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 27
77759: PUSH
77760: LD_INT 28
77762: PUSH
77763: LD_INT 26
77765: PUSH
77766: LD_INT 30
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 43
77777: PUSH
77778: LD_INT 44
77780: PUSH
77781: LD_INT 46
77783: PUSH
77784: LD_INT 45
77786: PUSH
77787: LD_INT 47
77789: PUSH
77790: LD_INT 49
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: LIST
77797: LIST
77798: LIST
77799: LIST
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: LIST
77805: PUSH
77806: LD_VAR 0 12
77810: ARRAY
77811: ST_TO_ADDR
// list := list isect fac_list ;
77812: LD_ADDR_VAR 0 5
77816: PUSH
77817: LD_VAR 0 5
77821: PUSH
77822: LD_VAR 0 17
77826: ISECT
77827: ST_TO_ADDR
// if not list then
77828: LD_VAR 0 5
77832: NOT
77833: IFFALSE 77837
// exit ;
77835: GO 78641
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77837: LD_VAR 0 12
77841: PUSH
77842: LD_INT 3
77844: EQUAL
77845: PUSH
77846: LD_INT 49
77848: PUSH
77849: LD_VAR 0 5
77853: IN
77854: AND
77855: PUSH
77856: LD_INT 31
77858: PPUSH
77859: LD_VAR 0 16
77863: PPUSH
77864: CALL_OW 321
77868: PUSH
77869: LD_INT 2
77871: EQUAL
77872: AND
77873: IFFALSE 77933
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77875: LD_INT 22
77877: PUSH
77878: LD_VAR 0 16
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: PUSH
77887: LD_INT 35
77889: PUSH
77890: LD_INT 49
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 91
77899: PUSH
77900: LD_VAR 0 1
77904: PUSH
77905: LD_INT 10
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: LIST
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: LIST
77917: PPUSH
77918: CALL_OW 69
77922: NOT
77923: IFFALSE 77933
// weapon := ru_time_lapser ;
77925: LD_ADDR_VAR 0 18
77929: PUSH
77930: LD_INT 49
77932: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77933: LD_VAR 0 12
77937: PUSH
77938: LD_INT 1
77940: PUSH
77941: LD_INT 2
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: IN
77948: PUSH
77949: LD_INT 11
77951: PUSH
77952: LD_VAR 0 5
77956: IN
77957: PUSH
77958: LD_INT 30
77960: PUSH
77961: LD_VAR 0 5
77965: IN
77966: OR
77967: AND
77968: PUSH
77969: LD_INT 6
77971: PPUSH
77972: LD_VAR 0 16
77976: PPUSH
77977: CALL_OW 321
77981: PUSH
77982: LD_INT 2
77984: EQUAL
77985: AND
77986: IFFALSE 78151
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77988: LD_INT 22
77990: PUSH
77991: LD_VAR 0 16
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 2
78002: PUSH
78003: LD_INT 35
78005: PUSH
78006: LD_INT 11
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 35
78015: PUSH
78016: LD_INT 30
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 91
78030: PUSH
78031: LD_VAR 0 1
78035: PUSH
78036: LD_INT 18
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: LIST
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: LIST
78048: PPUSH
78049: CALL_OW 69
78053: NOT
78054: PUSH
78055: LD_INT 22
78057: PUSH
78058: LD_VAR 0 16
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 2
78069: PUSH
78070: LD_INT 30
78072: PUSH
78073: LD_INT 32
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 30
78082: PUSH
78083: LD_INT 33
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 91
78097: PUSH
78098: LD_VAR 0 1
78102: PUSH
78103: LD_INT 12
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: LIST
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: LIST
78115: PUSH
78116: EMPTY
78117: LIST
78118: PPUSH
78119: CALL_OW 69
78123: PUSH
78124: LD_INT 2
78126: GREATER
78127: AND
78128: IFFALSE 78151
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78130: LD_ADDR_VAR 0 18
78134: PUSH
78135: LD_INT 11
78137: PUSH
78138: LD_INT 30
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_VAR 0 12
78149: ARRAY
78150: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78151: LD_VAR 0 18
78155: NOT
78156: PUSH
78157: LD_INT 40
78159: PPUSH
78160: LD_VAR 0 16
78164: PPUSH
78165: CALL_OW 321
78169: PUSH
78170: LD_INT 2
78172: EQUAL
78173: AND
78174: PUSH
78175: LD_INT 7
78177: PUSH
78178: LD_VAR 0 5
78182: IN
78183: PUSH
78184: LD_INT 28
78186: PUSH
78187: LD_VAR 0 5
78191: IN
78192: OR
78193: PUSH
78194: LD_INT 45
78196: PUSH
78197: LD_VAR 0 5
78201: IN
78202: OR
78203: AND
78204: IFFALSE 78458
// begin hex := GetHexInfo ( x , y ) ;
78206: LD_ADDR_VAR 0 4
78210: PUSH
78211: LD_VAR 0 10
78215: PPUSH
78216: LD_VAR 0 11
78220: PPUSH
78221: CALL_OW 546
78225: ST_TO_ADDR
// if hex [ 1 ] then
78226: LD_VAR 0 4
78230: PUSH
78231: LD_INT 1
78233: ARRAY
78234: IFFALSE 78238
// exit ;
78236: GO 78641
// height := hex [ 2 ] ;
78238: LD_ADDR_VAR 0 15
78242: PUSH
78243: LD_VAR 0 4
78247: PUSH
78248: LD_INT 2
78250: ARRAY
78251: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78252: LD_ADDR_VAR 0 14
78256: PUSH
78257: LD_INT 0
78259: PUSH
78260: LD_INT 2
78262: PUSH
78263: LD_INT 3
78265: PUSH
78266: LD_INT 5
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: ST_TO_ADDR
// for i in tmp do
78275: LD_ADDR_VAR 0 8
78279: PUSH
78280: LD_VAR 0 14
78284: PUSH
78285: FOR_IN
78286: IFFALSE 78456
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78288: LD_ADDR_VAR 0 9
78292: PUSH
78293: LD_VAR 0 10
78297: PPUSH
78298: LD_VAR 0 8
78302: PPUSH
78303: LD_INT 5
78305: PPUSH
78306: CALL_OW 272
78310: PUSH
78311: LD_VAR 0 11
78315: PPUSH
78316: LD_VAR 0 8
78320: PPUSH
78321: LD_INT 5
78323: PPUSH
78324: CALL_OW 273
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78333: LD_VAR 0 9
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PPUSH
78342: LD_VAR 0 9
78346: PUSH
78347: LD_INT 2
78349: ARRAY
78350: PPUSH
78351: CALL_OW 488
78355: IFFALSE 78454
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78357: LD_ADDR_VAR 0 4
78361: PUSH
78362: LD_VAR 0 9
78366: PUSH
78367: LD_INT 1
78369: ARRAY
78370: PPUSH
78371: LD_VAR 0 9
78375: PUSH
78376: LD_INT 2
78378: ARRAY
78379: PPUSH
78380: CALL_OW 546
78384: ST_TO_ADDR
// if hex [ 1 ] then
78385: LD_VAR 0 4
78389: PUSH
78390: LD_INT 1
78392: ARRAY
78393: IFFALSE 78397
// continue ;
78395: GO 78285
// h := hex [ 2 ] ;
78397: LD_ADDR_VAR 0 13
78401: PUSH
78402: LD_VAR 0 4
78406: PUSH
78407: LD_INT 2
78409: ARRAY
78410: ST_TO_ADDR
// if h + 7 < height then
78411: LD_VAR 0 13
78415: PUSH
78416: LD_INT 7
78418: PLUS
78419: PUSH
78420: LD_VAR 0 15
78424: LESS
78425: IFFALSE 78454
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78427: LD_ADDR_VAR 0 18
78431: PUSH
78432: LD_INT 7
78434: PUSH
78435: LD_INT 28
78437: PUSH
78438: LD_INT 45
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: LIST
78445: PUSH
78446: LD_VAR 0 12
78450: ARRAY
78451: ST_TO_ADDR
// break ;
78452: GO 78456
// end ; end ; end ;
78454: GO 78285
78456: POP
78457: POP
// end ; if not weapon then
78458: LD_VAR 0 18
78462: NOT
78463: IFFALSE 78523
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78465: LD_ADDR_VAR 0 5
78469: PUSH
78470: LD_VAR 0 5
78474: PUSH
78475: LD_INT 11
78477: PUSH
78478: LD_INT 30
78480: PUSH
78481: LD_INT 49
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: LIST
78488: DIFF
78489: ST_TO_ADDR
// if not list then
78490: LD_VAR 0 5
78494: NOT
78495: IFFALSE 78499
// exit ;
78497: GO 78641
// weapon := list [ rand ( 1 , list ) ] ;
78499: LD_ADDR_VAR 0 18
78503: PUSH
78504: LD_VAR 0 5
78508: PUSH
78509: LD_INT 1
78511: PPUSH
78512: LD_VAR 0 5
78516: PPUSH
78517: CALL_OW 12
78521: ARRAY
78522: ST_TO_ADDR
// end ; if weapon then
78523: LD_VAR 0 18
78527: IFFALSE 78641
// begin tmp := CostOfWeapon ( weapon ) ;
78529: LD_ADDR_VAR 0 14
78533: PUSH
78534: LD_VAR 0 18
78538: PPUSH
78539: CALL_OW 451
78543: ST_TO_ADDR
// j := GetBase ( tower ) ;
78544: LD_ADDR_VAR 0 9
78548: PUSH
78549: LD_VAR 0 1
78553: PPUSH
78554: CALL_OW 274
78558: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78559: LD_VAR 0 9
78563: PPUSH
78564: LD_INT 1
78566: PPUSH
78567: CALL_OW 275
78571: PUSH
78572: LD_VAR 0 14
78576: PUSH
78577: LD_INT 1
78579: ARRAY
78580: GREATEREQUAL
78581: PUSH
78582: LD_VAR 0 9
78586: PPUSH
78587: LD_INT 2
78589: PPUSH
78590: CALL_OW 275
78594: PUSH
78595: LD_VAR 0 14
78599: PUSH
78600: LD_INT 2
78602: ARRAY
78603: GREATEREQUAL
78604: AND
78605: PUSH
78606: LD_VAR 0 9
78610: PPUSH
78611: LD_INT 3
78613: PPUSH
78614: CALL_OW 275
78618: PUSH
78619: LD_VAR 0 14
78623: PUSH
78624: LD_INT 3
78626: ARRAY
78627: GREATEREQUAL
78628: AND
78629: IFFALSE 78641
// result := weapon ;
78631: LD_ADDR_VAR 0 3
78635: PUSH
78636: LD_VAR 0 18
78640: ST_TO_ADDR
// end ; end ;
78641: LD_VAR 0 3
78645: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78646: LD_INT 0
78648: PPUSH
78649: PPUSH
// result := true ;
78650: LD_ADDR_VAR 0 3
78654: PUSH
78655: LD_INT 1
78657: ST_TO_ADDR
// if array1 = array2 then
78658: LD_VAR 0 1
78662: PUSH
78663: LD_VAR 0 2
78667: EQUAL
78668: IFFALSE 78728
// begin for i = 1 to array1 do
78670: LD_ADDR_VAR 0 4
78674: PUSH
78675: DOUBLE
78676: LD_INT 1
78678: DEC
78679: ST_TO_ADDR
78680: LD_VAR 0 1
78684: PUSH
78685: FOR_TO
78686: IFFALSE 78724
// if array1 [ i ] <> array2 [ i ] then
78688: LD_VAR 0 1
78692: PUSH
78693: LD_VAR 0 4
78697: ARRAY
78698: PUSH
78699: LD_VAR 0 2
78703: PUSH
78704: LD_VAR 0 4
78708: ARRAY
78709: NONEQUAL
78710: IFFALSE 78722
// begin result := false ;
78712: LD_ADDR_VAR 0 3
78716: PUSH
78717: LD_INT 0
78719: ST_TO_ADDR
// break ;
78720: GO 78724
// end ;
78722: GO 78685
78724: POP
78725: POP
// end else
78726: GO 78736
// result := false ;
78728: LD_ADDR_VAR 0 3
78732: PUSH
78733: LD_INT 0
78735: ST_TO_ADDR
// end ;
78736: LD_VAR 0 3
78740: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78741: LD_INT 0
78743: PPUSH
78744: PPUSH
// if not array1 or not array2 then
78745: LD_VAR 0 1
78749: NOT
78750: PUSH
78751: LD_VAR 0 2
78755: NOT
78756: OR
78757: IFFALSE 78761
// exit ;
78759: GO 78825
// result := true ;
78761: LD_ADDR_VAR 0 3
78765: PUSH
78766: LD_INT 1
78768: ST_TO_ADDR
// for i = 1 to array1 do
78769: LD_ADDR_VAR 0 4
78773: PUSH
78774: DOUBLE
78775: LD_INT 1
78777: DEC
78778: ST_TO_ADDR
78779: LD_VAR 0 1
78783: PUSH
78784: FOR_TO
78785: IFFALSE 78823
// if array1 [ i ] <> array2 [ i ] then
78787: LD_VAR 0 1
78791: PUSH
78792: LD_VAR 0 4
78796: ARRAY
78797: PUSH
78798: LD_VAR 0 2
78802: PUSH
78803: LD_VAR 0 4
78807: ARRAY
78808: NONEQUAL
78809: IFFALSE 78821
// begin result := false ;
78811: LD_ADDR_VAR 0 3
78815: PUSH
78816: LD_INT 0
78818: ST_TO_ADDR
// break ;
78819: GO 78823
// end ;
78821: GO 78784
78823: POP
78824: POP
// end ;
78825: LD_VAR 0 3
78829: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78830: LD_INT 0
78832: PPUSH
78833: PPUSH
78834: PPUSH
// pom := GetBase ( fac ) ;
78835: LD_ADDR_VAR 0 5
78839: PUSH
78840: LD_VAR 0 1
78844: PPUSH
78845: CALL_OW 274
78849: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78850: LD_ADDR_VAR 0 4
78854: PUSH
78855: LD_VAR 0 2
78859: PUSH
78860: LD_INT 1
78862: ARRAY
78863: PPUSH
78864: LD_VAR 0 2
78868: PUSH
78869: LD_INT 2
78871: ARRAY
78872: PPUSH
78873: LD_VAR 0 2
78877: PUSH
78878: LD_INT 3
78880: ARRAY
78881: PPUSH
78882: LD_VAR 0 2
78886: PUSH
78887: LD_INT 4
78889: ARRAY
78890: PPUSH
78891: CALL_OW 449
78895: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78896: LD_ADDR_VAR 0 3
78900: PUSH
78901: LD_VAR 0 5
78905: PPUSH
78906: LD_INT 1
78908: PPUSH
78909: CALL_OW 275
78913: PUSH
78914: LD_VAR 0 4
78918: PUSH
78919: LD_INT 1
78921: ARRAY
78922: GREATEREQUAL
78923: PUSH
78924: LD_VAR 0 5
78928: PPUSH
78929: LD_INT 2
78931: PPUSH
78932: CALL_OW 275
78936: PUSH
78937: LD_VAR 0 4
78941: PUSH
78942: LD_INT 2
78944: ARRAY
78945: GREATEREQUAL
78946: AND
78947: PUSH
78948: LD_VAR 0 5
78952: PPUSH
78953: LD_INT 3
78955: PPUSH
78956: CALL_OW 275
78960: PUSH
78961: LD_VAR 0 4
78965: PUSH
78966: LD_INT 3
78968: ARRAY
78969: GREATEREQUAL
78970: AND
78971: ST_TO_ADDR
// end ;
78972: LD_VAR 0 3
78976: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78977: LD_INT 0
78979: PPUSH
78980: PPUSH
78981: PPUSH
78982: PPUSH
// pom := GetBase ( building ) ;
78983: LD_ADDR_VAR 0 3
78987: PUSH
78988: LD_VAR 0 1
78992: PPUSH
78993: CALL_OW 274
78997: ST_TO_ADDR
// if not pom then
78998: LD_VAR 0 3
79002: NOT
79003: IFFALSE 79007
// exit ;
79005: GO 79177
// btype := GetBType ( building ) ;
79007: LD_ADDR_VAR 0 5
79011: PUSH
79012: LD_VAR 0 1
79016: PPUSH
79017: CALL_OW 266
79021: ST_TO_ADDR
// if btype = b_armoury then
79022: LD_VAR 0 5
79026: PUSH
79027: LD_INT 4
79029: EQUAL
79030: IFFALSE 79040
// btype := b_barracks ;
79032: LD_ADDR_VAR 0 5
79036: PUSH
79037: LD_INT 5
79039: ST_TO_ADDR
// if btype = b_depot then
79040: LD_VAR 0 5
79044: PUSH
79045: LD_INT 0
79047: EQUAL
79048: IFFALSE 79058
// btype := b_warehouse ;
79050: LD_ADDR_VAR 0 5
79054: PUSH
79055: LD_INT 1
79057: ST_TO_ADDR
// if btype = b_workshop then
79058: LD_VAR 0 5
79062: PUSH
79063: LD_INT 2
79065: EQUAL
79066: IFFALSE 79076
// btype := b_factory ;
79068: LD_ADDR_VAR 0 5
79072: PUSH
79073: LD_INT 3
79075: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79076: LD_ADDR_VAR 0 4
79080: PUSH
79081: LD_VAR 0 5
79085: PPUSH
79086: LD_VAR 0 1
79090: PPUSH
79091: CALL_OW 248
79095: PPUSH
79096: CALL_OW 450
79100: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79101: LD_ADDR_VAR 0 2
79105: PUSH
79106: LD_VAR 0 3
79110: PPUSH
79111: LD_INT 1
79113: PPUSH
79114: CALL_OW 275
79118: PUSH
79119: LD_VAR 0 4
79123: PUSH
79124: LD_INT 1
79126: ARRAY
79127: GREATEREQUAL
79128: PUSH
79129: LD_VAR 0 3
79133: PPUSH
79134: LD_INT 2
79136: PPUSH
79137: CALL_OW 275
79141: PUSH
79142: LD_VAR 0 4
79146: PUSH
79147: LD_INT 2
79149: ARRAY
79150: GREATEREQUAL
79151: AND
79152: PUSH
79153: LD_VAR 0 3
79157: PPUSH
79158: LD_INT 3
79160: PPUSH
79161: CALL_OW 275
79165: PUSH
79166: LD_VAR 0 4
79170: PUSH
79171: LD_INT 3
79173: ARRAY
79174: GREATEREQUAL
79175: AND
79176: ST_TO_ADDR
// end ;
79177: LD_VAR 0 2
79181: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79182: LD_INT 0
79184: PPUSH
79185: PPUSH
79186: PPUSH
// pom := GetBase ( building ) ;
79187: LD_ADDR_VAR 0 4
79191: PUSH
79192: LD_VAR 0 1
79196: PPUSH
79197: CALL_OW 274
79201: ST_TO_ADDR
// if not pom then
79202: LD_VAR 0 4
79206: NOT
79207: IFFALSE 79211
// exit ;
79209: GO 79312
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79211: LD_ADDR_VAR 0 5
79215: PUSH
79216: LD_VAR 0 2
79220: PPUSH
79221: LD_VAR 0 1
79225: PPUSH
79226: CALL_OW 248
79230: PPUSH
79231: CALL_OW 450
79235: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79236: LD_ADDR_VAR 0 3
79240: PUSH
79241: LD_VAR 0 4
79245: PPUSH
79246: LD_INT 1
79248: PPUSH
79249: CALL_OW 275
79253: PUSH
79254: LD_VAR 0 5
79258: PUSH
79259: LD_INT 1
79261: ARRAY
79262: GREATEREQUAL
79263: PUSH
79264: LD_VAR 0 4
79268: PPUSH
79269: LD_INT 2
79271: PPUSH
79272: CALL_OW 275
79276: PUSH
79277: LD_VAR 0 5
79281: PUSH
79282: LD_INT 2
79284: ARRAY
79285: GREATEREQUAL
79286: AND
79287: PUSH
79288: LD_VAR 0 4
79292: PPUSH
79293: LD_INT 3
79295: PPUSH
79296: CALL_OW 275
79300: PUSH
79301: LD_VAR 0 5
79305: PUSH
79306: LD_INT 3
79308: ARRAY
79309: GREATEREQUAL
79310: AND
79311: ST_TO_ADDR
// end ;
79312: LD_VAR 0 3
79316: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79317: LD_INT 0
79319: PPUSH
79320: PPUSH
79321: PPUSH
79322: PPUSH
79323: PPUSH
79324: PPUSH
79325: PPUSH
79326: PPUSH
79327: PPUSH
79328: PPUSH
79329: PPUSH
// result := false ;
79330: LD_ADDR_VAR 0 8
79334: PUSH
79335: LD_INT 0
79337: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79338: LD_VAR 0 5
79342: NOT
79343: PUSH
79344: LD_VAR 0 1
79348: NOT
79349: OR
79350: PUSH
79351: LD_VAR 0 2
79355: NOT
79356: OR
79357: PUSH
79358: LD_VAR 0 3
79362: NOT
79363: OR
79364: IFFALSE 79368
// exit ;
79366: GO 80182
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79368: LD_ADDR_VAR 0 14
79372: PUSH
79373: LD_VAR 0 1
79377: PPUSH
79378: LD_VAR 0 2
79382: PPUSH
79383: LD_VAR 0 3
79387: PPUSH
79388: LD_VAR 0 4
79392: PPUSH
79393: LD_VAR 0 5
79397: PUSH
79398: LD_INT 1
79400: ARRAY
79401: PPUSH
79402: CALL_OW 248
79406: PPUSH
79407: LD_INT 0
79409: PPUSH
79410: CALL 81415 0 6
79414: ST_TO_ADDR
// if not hexes then
79415: LD_VAR 0 14
79419: NOT
79420: IFFALSE 79424
// exit ;
79422: GO 80182
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79424: LD_ADDR_VAR 0 17
79428: PUSH
79429: LD_VAR 0 5
79433: PPUSH
79434: LD_INT 22
79436: PUSH
79437: LD_VAR 0 13
79441: PPUSH
79442: CALL_OW 255
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 2
79453: PUSH
79454: LD_INT 30
79456: PUSH
79457: LD_INT 0
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: PUSH
79464: LD_INT 30
79466: PUSH
79467: LD_INT 1
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: LIST
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PPUSH
79483: CALL_OW 72
79487: ST_TO_ADDR
// for i = 1 to hexes do
79488: LD_ADDR_VAR 0 9
79492: PUSH
79493: DOUBLE
79494: LD_INT 1
79496: DEC
79497: ST_TO_ADDR
79498: LD_VAR 0 14
79502: PUSH
79503: FOR_TO
79504: IFFALSE 80180
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79506: LD_ADDR_VAR 0 13
79510: PUSH
79511: LD_VAR 0 14
79515: PUSH
79516: LD_VAR 0 9
79520: ARRAY
79521: PUSH
79522: LD_INT 1
79524: ARRAY
79525: PPUSH
79526: LD_VAR 0 14
79530: PUSH
79531: LD_VAR 0 9
79535: ARRAY
79536: PUSH
79537: LD_INT 2
79539: ARRAY
79540: PPUSH
79541: CALL_OW 428
79545: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79546: LD_VAR 0 14
79550: PUSH
79551: LD_VAR 0 9
79555: ARRAY
79556: PUSH
79557: LD_INT 1
79559: ARRAY
79560: PPUSH
79561: LD_VAR 0 14
79565: PUSH
79566: LD_VAR 0 9
79570: ARRAY
79571: PUSH
79572: LD_INT 2
79574: ARRAY
79575: PPUSH
79576: CALL_OW 351
79580: PUSH
79581: LD_VAR 0 14
79585: PUSH
79586: LD_VAR 0 9
79590: ARRAY
79591: PUSH
79592: LD_INT 1
79594: ARRAY
79595: PPUSH
79596: LD_VAR 0 14
79600: PUSH
79601: LD_VAR 0 9
79605: ARRAY
79606: PUSH
79607: LD_INT 2
79609: ARRAY
79610: PPUSH
79611: CALL_OW 488
79615: NOT
79616: OR
79617: PUSH
79618: LD_VAR 0 13
79622: PPUSH
79623: CALL_OW 247
79627: PUSH
79628: LD_INT 3
79630: EQUAL
79631: OR
79632: IFFALSE 79638
// exit ;
79634: POP
79635: POP
79636: GO 80182
// if not tmp then
79638: LD_VAR 0 13
79642: NOT
79643: IFFALSE 79647
// continue ;
79645: GO 79503
// result := true ;
79647: LD_ADDR_VAR 0 8
79651: PUSH
79652: LD_INT 1
79654: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79655: LD_VAR 0 6
79659: PUSH
79660: LD_VAR 0 13
79664: PPUSH
79665: CALL_OW 247
79669: PUSH
79670: LD_INT 2
79672: EQUAL
79673: AND
79674: PUSH
79675: LD_VAR 0 13
79679: PPUSH
79680: CALL_OW 263
79684: PUSH
79685: LD_INT 1
79687: EQUAL
79688: AND
79689: IFFALSE 79853
// begin if IsDrivenBy ( tmp ) then
79691: LD_VAR 0 13
79695: PPUSH
79696: CALL_OW 311
79700: IFFALSE 79704
// continue ;
79702: GO 79503
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79704: LD_VAR 0 6
79708: PPUSH
79709: LD_INT 3
79711: PUSH
79712: LD_INT 60
79714: PUSH
79715: EMPTY
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: PUSH
79725: LD_INT 55
79727: PUSH
79728: EMPTY
79729: LIST
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PPUSH
79739: CALL_OW 72
79743: IFFALSE 79851
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79745: LD_ADDR_VAR 0 18
79749: PUSH
79750: LD_VAR 0 6
79754: PPUSH
79755: LD_INT 3
79757: PUSH
79758: LD_INT 60
79760: PUSH
79761: EMPTY
79762: LIST
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: LD_INT 55
79773: PUSH
79774: EMPTY
79775: LIST
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PPUSH
79785: CALL_OW 72
79789: PUSH
79790: LD_INT 1
79792: ARRAY
79793: ST_TO_ADDR
// if IsInUnit ( driver ) then
79794: LD_VAR 0 18
79798: PPUSH
79799: CALL_OW 310
79803: IFFALSE 79814
// ComExit ( driver ) ;
79805: LD_VAR 0 18
79809: PPUSH
79810: CALL 105176 0 1
// AddComEnterUnit ( driver , tmp ) ;
79814: LD_VAR 0 18
79818: PPUSH
79819: LD_VAR 0 13
79823: PPUSH
79824: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
79828: LD_VAR 0 18
79832: PPUSH
79833: LD_VAR 0 7
79837: PPUSH
79838: CALL_OW 173
// AddComExitVehicle ( driver ) ;
79842: LD_VAR 0 18
79846: PPUSH
79847: CALL_OW 181
// end ; continue ;
79851: GO 79503
// end ; if not cleaners or not tmp in cleaners then
79853: LD_VAR 0 6
79857: NOT
79858: PUSH
79859: LD_VAR 0 13
79863: PUSH
79864: LD_VAR 0 6
79868: IN
79869: NOT
79870: OR
79871: IFFALSE 80178
// begin if dep then
79873: LD_VAR 0 17
79877: IFFALSE 80013
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79879: LD_ADDR_VAR 0 16
79883: PUSH
79884: LD_VAR 0 17
79888: PUSH
79889: LD_INT 1
79891: ARRAY
79892: PPUSH
79893: CALL_OW 250
79897: PPUSH
79898: LD_VAR 0 17
79902: PUSH
79903: LD_INT 1
79905: ARRAY
79906: PPUSH
79907: CALL_OW 254
79911: PPUSH
79912: LD_INT 5
79914: PPUSH
79915: CALL_OW 272
79919: PUSH
79920: LD_VAR 0 17
79924: PUSH
79925: LD_INT 1
79927: ARRAY
79928: PPUSH
79929: CALL_OW 251
79933: PPUSH
79934: LD_VAR 0 17
79938: PUSH
79939: LD_INT 1
79941: ARRAY
79942: PPUSH
79943: CALL_OW 254
79947: PPUSH
79948: LD_INT 5
79950: PPUSH
79951: CALL_OW 273
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79960: LD_VAR 0 16
79964: PUSH
79965: LD_INT 1
79967: ARRAY
79968: PPUSH
79969: LD_VAR 0 16
79973: PUSH
79974: LD_INT 2
79976: ARRAY
79977: PPUSH
79978: CALL_OW 488
79982: IFFALSE 80013
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79984: LD_VAR 0 13
79988: PPUSH
79989: LD_VAR 0 16
79993: PUSH
79994: LD_INT 1
79996: ARRAY
79997: PPUSH
79998: LD_VAR 0 16
80002: PUSH
80003: LD_INT 2
80005: ARRAY
80006: PPUSH
80007: CALL_OW 111
// continue ;
80011: GO 79503
// end ; end ; r := GetDir ( tmp ) ;
80013: LD_ADDR_VAR 0 15
80017: PUSH
80018: LD_VAR 0 13
80022: PPUSH
80023: CALL_OW 254
80027: ST_TO_ADDR
// if r = 5 then
80028: LD_VAR 0 15
80032: PUSH
80033: LD_INT 5
80035: EQUAL
80036: IFFALSE 80046
// r := 0 ;
80038: LD_ADDR_VAR 0 15
80042: PUSH
80043: LD_INT 0
80045: ST_TO_ADDR
// for j = r to 5 do
80046: LD_ADDR_VAR 0 10
80050: PUSH
80051: DOUBLE
80052: LD_VAR 0 15
80056: DEC
80057: ST_TO_ADDR
80058: LD_INT 5
80060: PUSH
80061: FOR_TO
80062: IFFALSE 80176
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80064: LD_ADDR_VAR 0 11
80068: PUSH
80069: LD_VAR 0 13
80073: PPUSH
80074: CALL_OW 250
80078: PPUSH
80079: LD_VAR 0 10
80083: PPUSH
80084: LD_INT 2
80086: PPUSH
80087: CALL_OW 272
80091: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80092: LD_ADDR_VAR 0 12
80096: PUSH
80097: LD_VAR 0 13
80101: PPUSH
80102: CALL_OW 251
80106: PPUSH
80107: LD_VAR 0 10
80111: PPUSH
80112: LD_INT 2
80114: PPUSH
80115: CALL_OW 273
80119: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80120: LD_VAR 0 11
80124: PPUSH
80125: LD_VAR 0 12
80129: PPUSH
80130: CALL_OW 488
80134: PUSH
80135: LD_VAR 0 11
80139: PPUSH
80140: LD_VAR 0 12
80144: PPUSH
80145: CALL_OW 428
80149: NOT
80150: AND
80151: IFFALSE 80174
// begin ComMoveXY ( tmp , _x , _y ) ;
80153: LD_VAR 0 13
80157: PPUSH
80158: LD_VAR 0 11
80162: PPUSH
80163: LD_VAR 0 12
80167: PPUSH
80168: CALL_OW 111
// break ;
80172: GO 80176
// end ; end ;
80174: GO 80061
80176: POP
80177: POP
// end ; end ;
80178: GO 79503
80180: POP
80181: POP
// end ;
80182: LD_VAR 0 8
80186: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80187: LD_INT 0
80189: PPUSH
// result := true ;
80190: LD_ADDR_VAR 0 3
80194: PUSH
80195: LD_INT 1
80197: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80198: LD_VAR 0 2
80202: PUSH
80203: LD_INT 24
80205: DOUBLE
80206: EQUAL
80207: IFTRUE 80217
80209: LD_INT 33
80211: DOUBLE
80212: EQUAL
80213: IFTRUE 80217
80215: GO 80242
80217: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80218: LD_ADDR_VAR 0 3
80222: PUSH
80223: LD_INT 32
80225: PPUSH
80226: LD_VAR 0 1
80230: PPUSH
80231: CALL_OW 321
80235: PUSH
80236: LD_INT 2
80238: EQUAL
80239: ST_TO_ADDR
80240: GO 80558
80242: LD_INT 20
80244: DOUBLE
80245: EQUAL
80246: IFTRUE 80250
80248: GO 80275
80250: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80251: LD_ADDR_VAR 0 3
80255: PUSH
80256: LD_INT 6
80258: PPUSH
80259: LD_VAR 0 1
80263: PPUSH
80264: CALL_OW 321
80268: PUSH
80269: LD_INT 2
80271: EQUAL
80272: ST_TO_ADDR
80273: GO 80558
80275: LD_INT 22
80277: DOUBLE
80278: EQUAL
80279: IFTRUE 80289
80281: LD_INT 36
80283: DOUBLE
80284: EQUAL
80285: IFTRUE 80289
80287: GO 80314
80289: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80290: LD_ADDR_VAR 0 3
80294: PUSH
80295: LD_INT 15
80297: PPUSH
80298: LD_VAR 0 1
80302: PPUSH
80303: CALL_OW 321
80307: PUSH
80308: LD_INT 2
80310: EQUAL
80311: ST_TO_ADDR
80312: GO 80558
80314: LD_INT 30
80316: DOUBLE
80317: EQUAL
80318: IFTRUE 80322
80320: GO 80347
80322: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80323: LD_ADDR_VAR 0 3
80327: PUSH
80328: LD_INT 20
80330: PPUSH
80331: LD_VAR 0 1
80335: PPUSH
80336: CALL_OW 321
80340: PUSH
80341: LD_INT 2
80343: EQUAL
80344: ST_TO_ADDR
80345: GO 80558
80347: LD_INT 28
80349: DOUBLE
80350: EQUAL
80351: IFTRUE 80361
80353: LD_INT 21
80355: DOUBLE
80356: EQUAL
80357: IFTRUE 80361
80359: GO 80386
80361: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80362: LD_ADDR_VAR 0 3
80366: PUSH
80367: LD_INT 21
80369: PPUSH
80370: LD_VAR 0 1
80374: PPUSH
80375: CALL_OW 321
80379: PUSH
80380: LD_INT 2
80382: EQUAL
80383: ST_TO_ADDR
80384: GO 80558
80386: LD_INT 16
80388: DOUBLE
80389: EQUAL
80390: IFTRUE 80394
80392: GO 80419
80394: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80395: LD_ADDR_VAR 0 3
80399: PUSH
80400: LD_INT 84
80402: PPUSH
80403: LD_VAR 0 1
80407: PPUSH
80408: CALL_OW 321
80412: PUSH
80413: LD_INT 2
80415: EQUAL
80416: ST_TO_ADDR
80417: GO 80558
80419: LD_INT 19
80421: DOUBLE
80422: EQUAL
80423: IFTRUE 80433
80425: LD_INT 23
80427: DOUBLE
80428: EQUAL
80429: IFTRUE 80433
80431: GO 80458
80433: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80434: LD_ADDR_VAR 0 3
80438: PUSH
80439: LD_INT 83
80441: PPUSH
80442: LD_VAR 0 1
80446: PPUSH
80447: CALL_OW 321
80451: PUSH
80452: LD_INT 2
80454: EQUAL
80455: ST_TO_ADDR
80456: GO 80558
80458: LD_INT 17
80460: DOUBLE
80461: EQUAL
80462: IFTRUE 80466
80464: GO 80491
80466: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80467: LD_ADDR_VAR 0 3
80471: PUSH
80472: LD_INT 39
80474: PPUSH
80475: LD_VAR 0 1
80479: PPUSH
80480: CALL_OW 321
80484: PUSH
80485: LD_INT 2
80487: EQUAL
80488: ST_TO_ADDR
80489: GO 80558
80491: LD_INT 18
80493: DOUBLE
80494: EQUAL
80495: IFTRUE 80499
80497: GO 80524
80499: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80500: LD_ADDR_VAR 0 3
80504: PUSH
80505: LD_INT 40
80507: PPUSH
80508: LD_VAR 0 1
80512: PPUSH
80513: CALL_OW 321
80517: PUSH
80518: LD_INT 2
80520: EQUAL
80521: ST_TO_ADDR
80522: GO 80558
80524: LD_INT 27
80526: DOUBLE
80527: EQUAL
80528: IFTRUE 80532
80530: GO 80557
80532: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80533: LD_ADDR_VAR 0 3
80537: PUSH
80538: LD_INT 35
80540: PPUSH
80541: LD_VAR 0 1
80545: PPUSH
80546: CALL_OW 321
80550: PUSH
80551: LD_INT 2
80553: EQUAL
80554: ST_TO_ADDR
80555: GO 80558
80557: POP
// end ;
80558: LD_VAR 0 3
80562: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80563: LD_INT 0
80565: PPUSH
80566: PPUSH
80567: PPUSH
80568: PPUSH
80569: PPUSH
80570: PPUSH
80571: PPUSH
80572: PPUSH
80573: PPUSH
80574: PPUSH
80575: PPUSH
// result := false ;
80576: LD_ADDR_VAR 0 6
80580: PUSH
80581: LD_INT 0
80583: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80584: LD_VAR 0 1
80588: NOT
80589: PUSH
80590: LD_VAR 0 1
80594: PPUSH
80595: CALL_OW 266
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 1
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: IN
80610: NOT
80611: OR
80612: PUSH
80613: LD_VAR 0 2
80617: NOT
80618: OR
80619: PUSH
80620: LD_VAR 0 5
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 2
80633: PUSH
80634: LD_INT 3
80636: PUSH
80637: LD_INT 4
80639: PUSH
80640: LD_INT 5
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: IN
80651: NOT
80652: OR
80653: PUSH
80654: LD_VAR 0 3
80658: PPUSH
80659: LD_VAR 0 4
80663: PPUSH
80664: CALL_OW 488
80668: NOT
80669: OR
80670: IFFALSE 80674
// exit ;
80672: GO 81410
// side := GetSide ( depot ) ;
80674: LD_ADDR_VAR 0 9
80678: PUSH
80679: LD_VAR 0 1
80683: PPUSH
80684: CALL_OW 255
80688: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80689: LD_VAR 0 9
80693: PPUSH
80694: LD_VAR 0 2
80698: PPUSH
80699: CALL 80187 0 2
80703: NOT
80704: IFFALSE 80708
// exit ;
80706: GO 81410
// pom := GetBase ( depot ) ;
80708: LD_ADDR_VAR 0 10
80712: PUSH
80713: LD_VAR 0 1
80717: PPUSH
80718: CALL_OW 274
80722: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80723: LD_ADDR_VAR 0 11
80727: PUSH
80728: LD_VAR 0 2
80732: PPUSH
80733: LD_VAR 0 1
80737: PPUSH
80738: CALL_OW 248
80742: PPUSH
80743: CALL_OW 450
80747: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80748: LD_VAR 0 10
80752: PPUSH
80753: LD_INT 1
80755: PPUSH
80756: CALL_OW 275
80760: PUSH
80761: LD_VAR 0 11
80765: PUSH
80766: LD_INT 1
80768: ARRAY
80769: GREATEREQUAL
80770: PUSH
80771: LD_VAR 0 10
80775: PPUSH
80776: LD_INT 2
80778: PPUSH
80779: CALL_OW 275
80783: PUSH
80784: LD_VAR 0 11
80788: PUSH
80789: LD_INT 2
80791: ARRAY
80792: GREATEREQUAL
80793: AND
80794: PUSH
80795: LD_VAR 0 10
80799: PPUSH
80800: LD_INT 3
80802: PPUSH
80803: CALL_OW 275
80807: PUSH
80808: LD_VAR 0 11
80812: PUSH
80813: LD_INT 3
80815: ARRAY
80816: GREATEREQUAL
80817: AND
80818: NOT
80819: IFFALSE 80823
// exit ;
80821: GO 81410
// if GetBType ( depot ) = b_depot then
80823: LD_VAR 0 1
80827: PPUSH
80828: CALL_OW 266
80832: PUSH
80833: LD_INT 0
80835: EQUAL
80836: IFFALSE 80848
// dist := 28 else
80838: LD_ADDR_VAR 0 14
80842: PUSH
80843: LD_INT 28
80845: ST_TO_ADDR
80846: GO 80856
// dist := 36 ;
80848: LD_ADDR_VAR 0 14
80852: PUSH
80853: LD_INT 36
80855: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80856: LD_VAR 0 1
80860: PPUSH
80861: LD_VAR 0 3
80865: PPUSH
80866: LD_VAR 0 4
80870: PPUSH
80871: CALL_OW 297
80875: PUSH
80876: LD_VAR 0 14
80880: GREATER
80881: IFFALSE 80885
// exit ;
80883: GO 81410
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80885: LD_ADDR_VAR 0 12
80889: PUSH
80890: LD_VAR 0 2
80894: PPUSH
80895: LD_VAR 0 3
80899: PPUSH
80900: LD_VAR 0 4
80904: PPUSH
80905: LD_VAR 0 5
80909: PPUSH
80910: LD_VAR 0 1
80914: PPUSH
80915: CALL_OW 248
80919: PPUSH
80920: LD_INT 0
80922: PPUSH
80923: CALL 81415 0 6
80927: ST_TO_ADDR
// if not hexes then
80928: LD_VAR 0 12
80932: NOT
80933: IFFALSE 80937
// exit ;
80935: GO 81410
// hex := GetHexInfo ( x , y ) ;
80937: LD_ADDR_VAR 0 15
80941: PUSH
80942: LD_VAR 0 3
80946: PPUSH
80947: LD_VAR 0 4
80951: PPUSH
80952: CALL_OW 546
80956: ST_TO_ADDR
// if hex [ 1 ] then
80957: LD_VAR 0 15
80961: PUSH
80962: LD_INT 1
80964: ARRAY
80965: IFFALSE 80969
// exit ;
80967: GO 81410
// height := hex [ 2 ] ;
80969: LD_ADDR_VAR 0 13
80973: PUSH
80974: LD_VAR 0 15
80978: PUSH
80979: LD_INT 2
80981: ARRAY
80982: ST_TO_ADDR
// for i = 1 to hexes do
80983: LD_ADDR_VAR 0 7
80987: PUSH
80988: DOUBLE
80989: LD_INT 1
80991: DEC
80992: ST_TO_ADDR
80993: LD_VAR 0 12
80997: PUSH
80998: FOR_TO
80999: IFFALSE 81329
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81001: LD_VAR 0 12
81005: PUSH
81006: LD_VAR 0 7
81010: ARRAY
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: PPUSH
81016: LD_VAR 0 12
81020: PUSH
81021: LD_VAR 0 7
81025: ARRAY
81026: PUSH
81027: LD_INT 2
81029: ARRAY
81030: PPUSH
81031: CALL_OW 488
81035: NOT
81036: PUSH
81037: LD_VAR 0 12
81041: PUSH
81042: LD_VAR 0 7
81046: ARRAY
81047: PUSH
81048: LD_INT 1
81050: ARRAY
81051: PPUSH
81052: LD_VAR 0 12
81056: PUSH
81057: LD_VAR 0 7
81061: ARRAY
81062: PUSH
81063: LD_INT 2
81065: ARRAY
81066: PPUSH
81067: CALL_OW 428
81071: PUSH
81072: LD_INT 0
81074: GREATER
81075: OR
81076: PUSH
81077: LD_VAR 0 12
81081: PUSH
81082: LD_VAR 0 7
81086: ARRAY
81087: PUSH
81088: LD_INT 1
81090: ARRAY
81091: PPUSH
81092: LD_VAR 0 12
81096: PUSH
81097: LD_VAR 0 7
81101: ARRAY
81102: PUSH
81103: LD_INT 2
81105: ARRAY
81106: PPUSH
81107: CALL_OW 351
81111: OR
81112: IFFALSE 81118
// exit ;
81114: POP
81115: POP
81116: GO 81410
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81118: LD_ADDR_VAR 0 8
81122: PUSH
81123: LD_VAR 0 12
81127: PUSH
81128: LD_VAR 0 7
81132: ARRAY
81133: PUSH
81134: LD_INT 1
81136: ARRAY
81137: PPUSH
81138: LD_VAR 0 12
81142: PUSH
81143: LD_VAR 0 7
81147: ARRAY
81148: PUSH
81149: LD_INT 2
81151: ARRAY
81152: PPUSH
81153: CALL_OW 546
81157: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81158: LD_VAR 0 8
81162: PUSH
81163: LD_INT 1
81165: ARRAY
81166: PUSH
81167: LD_VAR 0 8
81171: PUSH
81172: LD_INT 2
81174: ARRAY
81175: PUSH
81176: LD_VAR 0 13
81180: PUSH
81181: LD_INT 2
81183: PLUS
81184: GREATER
81185: OR
81186: PUSH
81187: LD_VAR 0 8
81191: PUSH
81192: LD_INT 2
81194: ARRAY
81195: PUSH
81196: LD_VAR 0 13
81200: PUSH
81201: LD_INT 2
81203: MINUS
81204: LESS
81205: OR
81206: PUSH
81207: LD_VAR 0 8
81211: PUSH
81212: LD_INT 3
81214: ARRAY
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: LD_INT 8
81221: PUSH
81222: LD_INT 9
81224: PUSH
81225: LD_INT 10
81227: PUSH
81228: LD_INT 11
81230: PUSH
81231: LD_INT 12
81233: PUSH
81234: LD_INT 13
81236: PUSH
81237: LD_INT 16
81239: PUSH
81240: LD_INT 17
81242: PUSH
81243: LD_INT 18
81245: PUSH
81246: LD_INT 19
81248: PUSH
81249: LD_INT 20
81251: PUSH
81252: LD_INT 21
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: IN
81270: NOT
81271: OR
81272: PUSH
81273: LD_VAR 0 8
81277: PUSH
81278: LD_INT 5
81280: ARRAY
81281: NOT
81282: OR
81283: PUSH
81284: LD_VAR 0 8
81288: PUSH
81289: LD_INT 6
81291: ARRAY
81292: PUSH
81293: LD_INT 1
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: LD_INT 7
81301: PUSH
81302: LD_INT 9
81304: PUSH
81305: LD_INT 10
81307: PUSH
81308: LD_INT 11
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: IN
81319: NOT
81320: OR
81321: IFFALSE 81327
// exit ;
81323: POP
81324: POP
81325: GO 81410
// end ;
81327: GO 80998
81329: POP
81330: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81331: LD_VAR 0 9
81335: PPUSH
81336: LD_VAR 0 3
81340: PPUSH
81341: LD_VAR 0 4
81345: PPUSH
81346: LD_INT 20
81348: PPUSH
81349: CALL 73362 0 4
81353: PUSH
81354: LD_INT 4
81356: ARRAY
81357: IFFALSE 81361
// exit ;
81359: GO 81410
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81361: LD_VAR 0 2
81365: PUSH
81366: LD_INT 29
81368: PUSH
81369: LD_INT 30
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: IN
81376: PUSH
81377: LD_VAR 0 3
81381: PPUSH
81382: LD_VAR 0 4
81386: PPUSH
81387: LD_VAR 0 9
81391: PPUSH
81392: CALL_OW 440
81396: NOT
81397: AND
81398: IFFALSE 81402
// exit ;
81400: GO 81410
// result := true ;
81402: LD_ADDR_VAR 0 6
81406: PUSH
81407: LD_INT 1
81409: ST_TO_ADDR
// end ;
81410: LD_VAR 0 6
81414: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81415: LD_INT 0
81417: PPUSH
81418: PPUSH
81419: PPUSH
81420: PPUSH
81421: PPUSH
81422: PPUSH
81423: PPUSH
81424: PPUSH
81425: PPUSH
81426: PPUSH
81427: PPUSH
81428: PPUSH
81429: PPUSH
81430: PPUSH
81431: PPUSH
81432: PPUSH
81433: PPUSH
81434: PPUSH
81435: PPUSH
81436: PPUSH
81437: PPUSH
81438: PPUSH
81439: PPUSH
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
81445: PPUSH
81446: PPUSH
81447: PPUSH
81448: PPUSH
81449: PPUSH
81450: PPUSH
81451: PPUSH
81452: PPUSH
81453: PPUSH
81454: PPUSH
81455: PPUSH
81456: PPUSH
81457: PPUSH
81458: PPUSH
81459: PPUSH
81460: PPUSH
81461: PPUSH
81462: PPUSH
81463: PPUSH
81464: PPUSH
81465: PPUSH
81466: PPUSH
81467: PPUSH
81468: PPUSH
81469: PPUSH
81470: PPUSH
81471: PPUSH
81472: PPUSH
81473: PPUSH
81474: PPUSH
// result = [ ] ;
81475: LD_ADDR_VAR 0 7
81479: PUSH
81480: EMPTY
81481: ST_TO_ADDR
// temp_list = [ ] ;
81482: LD_ADDR_VAR 0 9
81486: PUSH
81487: EMPTY
81488: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81489: LD_VAR 0 4
81493: PUSH
81494: LD_INT 0
81496: PUSH
81497: LD_INT 1
81499: PUSH
81500: LD_INT 2
81502: PUSH
81503: LD_INT 3
81505: PUSH
81506: LD_INT 4
81508: PUSH
81509: LD_INT 5
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: IN
81520: NOT
81521: PUSH
81522: LD_VAR 0 1
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 1
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: IN
81537: PUSH
81538: LD_VAR 0 5
81542: PUSH
81543: LD_INT 1
81545: PUSH
81546: LD_INT 2
81548: PUSH
81549: LD_INT 3
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: LIST
81556: IN
81557: NOT
81558: AND
81559: OR
81560: IFFALSE 81564
// exit ;
81562: GO 99955
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81564: LD_VAR 0 1
81568: PUSH
81569: LD_INT 6
81571: PUSH
81572: LD_INT 7
81574: PUSH
81575: LD_INT 8
81577: PUSH
81578: LD_INT 13
81580: PUSH
81581: LD_INT 12
81583: PUSH
81584: LD_INT 15
81586: PUSH
81587: LD_INT 11
81589: PUSH
81590: LD_INT 14
81592: PUSH
81593: LD_INT 10
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: IN
81607: IFFALSE 81617
// btype = b_lab ;
81609: LD_ADDR_VAR 0 1
81613: PUSH
81614: LD_INT 6
81616: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81617: LD_VAR 0 6
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: LD_INT 1
81627: PUSH
81628: LD_INT 2
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: LIST
81635: IN
81636: NOT
81637: PUSH
81638: LD_VAR 0 1
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: LD_INT 1
81648: PUSH
81649: LD_INT 2
81651: PUSH
81652: LD_INT 3
81654: PUSH
81655: LD_INT 6
81657: PUSH
81658: LD_INT 36
81660: PUSH
81661: LD_INT 4
81663: PUSH
81664: LD_INT 5
81666: PUSH
81667: LD_INT 31
81669: PUSH
81670: LD_INT 32
81672: PUSH
81673: LD_INT 33
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: IN
81689: NOT
81690: PUSH
81691: LD_VAR 0 6
81695: PUSH
81696: LD_INT 1
81698: EQUAL
81699: AND
81700: OR
81701: PUSH
81702: LD_VAR 0 1
81706: PUSH
81707: LD_INT 2
81709: PUSH
81710: LD_INT 3
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: IN
81717: NOT
81718: PUSH
81719: LD_VAR 0 6
81723: PUSH
81724: LD_INT 2
81726: EQUAL
81727: AND
81728: OR
81729: IFFALSE 81739
// mode = 0 ;
81731: LD_ADDR_VAR 0 6
81735: PUSH
81736: LD_INT 0
81738: ST_TO_ADDR
// case mode of 0 :
81739: LD_VAR 0 6
81743: PUSH
81744: LD_INT 0
81746: DOUBLE
81747: EQUAL
81748: IFTRUE 81752
81750: GO 93205
81752: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81753: LD_ADDR_VAR 0 11
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: LD_INT 0
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 0
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 1
81781: PUSH
81782: LD_INT 0
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 1
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: LD_INT 1
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 1
81811: NEG
81812: PUSH
81813: LD_INT 0
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: NEG
81823: PUSH
81824: LD_INT 1
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: LD_INT 2
81838: NEG
81839: PUSH
81840: EMPTY
81841: LIST
81842: LIST
81843: PUSH
81844: LD_INT 0
81846: PUSH
81847: LD_INT 2
81849: NEG
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: LD_INT 1
81860: NEG
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 1
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 0
81878: PUSH
81879: LD_INT 2
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 1
81888: NEG
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 1
81899: PUSH
81900: LD_INT 3
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: LD_INT 3
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 1
81919: NEG
81920: PUSH
81921: LD_INT 2
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81946: LD_ADDR_VAR 0 12
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: LD_INT 0
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 0
81963: PUSH
81964: LD_INT 1
81966: NEG
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 1
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 1
81984: PUSH
81985: LD_INT 1
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: LD_INT 1
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 1
82004: NEG
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 1
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: LD_INT 1
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 2
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 2
82048: PUSH
82049: LD_INT 1
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 1
82058: NEG
82059: PUSH
82060: LD_INT 1
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 2
82069: NEG
82070: PUSH
82071: LD_INT 0
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 2
82080: NEG
82081: PUSH
82082: LD_INT 1
82084: NEG
82085: PUSH
82086: EMPTY
82087: LIST
82088: LIST
82089: PUSH
82090: LD_INT 2
82092: NEG
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 3
82103: NEG
82104: PUSH
82105: LD_INT 0
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 3
82114: NEG
82115: PUSH
82116: LD_INT 1
82118: NEG
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82142: LD_ADDR_VAR 0 13
82146: PUSH
82147: LD_INT 0
82149: PUSH
82150: LD_INT 0
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 0
82159: PUSH
82160: LD_INT 1
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 1
82170: PUSH
82171: LD_INT 0
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: LD_INT 1
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: LD_INT 1
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 1
82200: NEG
82201: PUSH
82202: LD_INT 0
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 1
82211: NEG
82212: PUSH
82213: LD_INT 1
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 1
82223: NEG
82224: PUSH
82225: LD_INT 2
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 2
82235: PUSH
82236: LD_INT 1
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 2
82245: PUSH
82246: LD_INT 2
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 1
82255: PUSH
82256: LD_INT 2
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 2
82265: NEG
82266: PUSH
82267: LD_INT 1
82269: NEG
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 2
82277: NEG
82278: PUSH
82279: LD_INT 2
82281: NEG
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 2
82289: NEG
82290: PUSH
82291: LD_INT 3
82293: NEG
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 3
82301: NEG
82302: PUSH
82303: LD_INT 2
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 3
82313: NEG
82314: PUSH
82315: LD_INT 3
82317: NEG
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82341: LD_ADDR_VAR 0 14
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 0
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 1
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 1
82379: PUSH
82380: LD_INT 1
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 0
82389: PUSH
82390: LD_INT 1
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: LD_INT 0
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 1
82410: NEG
82411: PUSH
82412: LD_INT 1
82414: NEG
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 1
82422: NEG
82423: PUSH
82424: LD_INT 2
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: LD_INT 2
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: PUSH
82446: LD_INT 1
82448: NEG
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: LD_INT 2
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 0
82466: PUSH
82467: LD_INT 2
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: LD_INT 3
82491: NEG
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 0
82499: PUSH
82500: LD_INT 3
82502: NEG
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82537: LD_ADDR_VAR 0 15
82541: PUSH
82542: LD_INT 0
82544: PUSH
82545: LD_INT 0
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 0
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: PUSH
82566: LD_INT 0
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: LD_INT 1
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 1
82606: NEG
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 1
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 2
82629: PUSH
82630: LD_INT 0
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 2
82639: PUSH
82640: LD_INT 1
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: LD_INT 1
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 2
82660: NEG
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 2
82671: NEG
82672: PUSH
82673: LD_INT 1
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 2
82683: PUSH
82684: LD_INT 1
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 3
82694: PUSH
82695: LD_INT 0
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 3
82704: PUSH
82705: LD_INT 1
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82730: LD_ADDR_VAR 0 16
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: LD_INT 0
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 0
82747: PUSH
82748: LD_INT 1
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 1
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 1
82768: PUSH
82769: LD_INT 1
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 0
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 0
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 1
82799: NEG
82800: PUSH
82801: LD_INT 1
82803: NEG
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 1
82811: NEG
82812: PUSH
82813: LD_INT 2
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 2
82823: PUSH
82824: LD_INT 1
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 2
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 1
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: EMPTY
82848: LIST
82849: LIST
82850: PUSH
82851: LD_INT 2
82853: NEG
82854: PUSH
82855: LD_INT 1
82857: NEG
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: PUSH
82863: LD_INT 2
82865: NEG
82866: PUSH
82867: LD_INT 2
82869: NEG
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 3
82877: PUSH
82878: LD_INT 2
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 3
82887: PUSH
82888: LD_INT 3
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 2
82897: PUSH
82898: LD_INT 3
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82923: LD_ADDR_VAR 0 17
82927: PUSH
82928: LD_INT 0
82930: PUSH
82931: LD_INT 0
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 0
82940: PUSH
82941: LD_INT 1
82943: NEG
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: LD_INT 0
82954: PUSH
82955: EMPTY
82956: LIST
82957: LIST
82958: PUSH
82959: LD_INT 1
82961: PUSH
82962: LD_INT 1
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: LD_INT 1
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: NEG
82982: PUSH
82983: LD_INT 0
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 1
82992: NEG
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 1
83004: NEG
83005: PUSH
83006: LD_INT 2
83008: NEG
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 2
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 1
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 2
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: EMPTY
83043: LIST
83044: LIST
83045: PUSH
83046: LD_INT 2
83048: PUSH
83049: LD_INT 1
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 2
83058: PUSH
83059: LD_INT 2
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 1
83068: PUSH
83069: LD_INT 2
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: LD_INT 2
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: NEG
83089: PUSH
83090: LD_INT 1
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 2
83099: NEG
83100: PUSH
83101: LD_INT 0
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 2
83110: NEG
83111: PUSH
83112: LD_INT 1
83114: NEG
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 2
83122: NEG
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83153: LD_ADDR_VAR 0 18
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 0
83170: PUSH
83171: LD_INT 1
83173: NEG
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: LD_INT 0
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 1
83191: PUSH
83192: LD_INT 1
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 0
83201: PUSH
83202: LD_INT 1
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 1
83211: NEG
83212: PUSH
83213: LD_INT 0
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: NEG
83223: PUSH
83224: LD_INT 1
83226: NEG
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: NEG
83235: PUSH
83236: LD_INT 2
83238: NEG
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 0
83246: PUSH
83247: LD_INT 2
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 1
83257: PUSH
83258: LD_INT 1
83260: NEG
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 2
83268: PUSH
83269: LD_INT 0
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 2
83278: PUSH
83279: LD_INT 1
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: LD_INT 2
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 1
83298: PUSH
83299: LD_INT 2
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 0
83308: PUSH
83309: LD_INT 2
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 1
83318: NEG
83319: PUSH
83320: LD_INT 1
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 2
83329: NEG
83330: PUSH
83331: LD_INT 0
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 2
83340: NEG
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 2
83352: NEG
83353: PUSH
83354: LD_INT 2
83356: NEG
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83383: LD_ADDR_VAR 0 19
83387: PUSH
83388: LD_INT 0
83390: PUSH
83391: LD_INT 0
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 0
83400: PUSH
83401: LD_INT 1
83403: NEG
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: LD_INT 0
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: PUSH
83422: LD_INT 1
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 0
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 1
83441: NEG
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: NEG
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: LD_INT 2
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 0
83476: PUSH
83477: LD_INT 2
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 1
83487: PUSH
83488: LD_INT 1
83490: NEG
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 2
83498: PUSH
83499: LD_INT 0
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: LD_INT 2
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 1
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 0
83538: PUSH
83539: LD_INT 2
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: NEG
83549: PUSH
83550: LD_INT 1
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 2
83570: NEG
83571: PUSH
83572: LD_INT 1
83574: NEG
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 2
83582: NEG
83583: PUSH
83584: LD_INT 2
83586: NEG
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83613: LD_ADDR_VAR 0 20
83617: PUSH
83618: LD_INT 0
83620: PUSH
83621: LD_INT 0
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: LD_INT 0
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: PUSH
83649: LD_INT 1
83651: PUSH
83652: LD_INT 1
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 0
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: NEG
83672: PUSH
83673: LD_INT 0
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: LD_INT 2
83698: NEG
83699: PUSH
83700: EMPTY
83701: LIST
83702: LIST
83703: PUSH
83704: LD_INT 0
83706: PUSH
83707: LD_INT 2
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: LD_INT 1
83720: NEG
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 2
83738: PUSH
83739: LD_INT 1
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 2
83748: PUSH
83749: LD_INT 2
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 1
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 0
83768: PUSH
83769: LD_INT 2
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: NEG
83779: PUSH
83780: LD_INT 1
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 2
83789: NEG
83790: PUSH
83791: LD_INT 0
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 2
83800: NEG
83801: PUSH
83802: LD_INT 1
83804: NEG
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 2
83812: NEG
83813: PUSH
83814: LD_INT 2
83816: NEG
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83843: LD_ADDR_VAR 0 21
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 1
83863: NEG
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: PUSH
83882: LD_INT 1
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 0
83891: PUSH
83892: LD_INT 1
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: PUSH
83910: LD_INT 1
83912: NEG
83913: PUSH
83914: LD_INT 1
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: NEG
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 0
83936: PUSH
83937: LD_INT 2
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: LD_INT 1
83950: NEG
83951: PUSH
83952: EMPTY
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: LD_INT 1
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: LD_INT 2
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 1
83988: PUSH
83989: LD_INT 2
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 0
83998: PUSH
83999: LD_INT 2
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 0
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 2
84030: NEG
84031: PUSH
84032: LD_INT 1
84034: NEG
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: NEG
84043: PUSH
84044: LD_INT 2
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: LIST
84060: LIST
84061: LIST
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84073: LD_ADDR_VAR 0 22
84077: PUSH
84078: LD_INT 0
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: LD_INT 0
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: LD_INT 1
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 0
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 1
84131: NEG
84132: PUSH
84133: LD_INT 0
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 1
84142: NEG
84143: PUSH
84144: LD_INT 1
84146: NEG
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: NEG
84155: PUSH
84156: LD_INT 2
84158: NEG
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 0
84166: PUSH
84167: LD_INT 2
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: PUSH
84178: LD_INT 1
84180: NEG
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 2
84188: PUSH
84189: LD_INT 0
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 2
84198: PUSH
84199: LD_INT 1
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 2
84208: PUSH
84209: LD_INT 2
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 1
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: PUSH
84226: LD_INT 0
84228: PUSH
84229: LD_INT 2
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 2
84249: NEG
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 2
84260: NEG
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 2
84272: NEG
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: LIST
84302: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84303: LD_ADDR_VAR 0 23
84307: PUSH
84308: LD_INT 0
84310: PUSH
84311: LD_INT 0
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 0
84320: PUSH
84321: LD_INT 1
84323: NEG
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 1
84331: PUSH
84332: LD_INT 0
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: PUSH
84342: LD_INT 1
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 0
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: NEG
84362: PUSH
84363: LD_INT 0
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 1
84372: NEG
84373: PUSH
84374: LD_INT 1
84376: NEG
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: LD_INT 2
84388: NEG
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: LD_INT 2
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: PUSH
84408: LD_INT 1
84410: NEG
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: LD_INT 0
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 2
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 2
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 1
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: EMPTY
84453: LIST
84454: LIST
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: LD_INT 2
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: LD_INT 1
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 0
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 2
84490: NEG
84491: PUSH
84492: LD_INT 1
84494: NEG
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 2
84502: NEG
84503: PUSH
84504: LD_INT 2
84506: NEG
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: LD_INT 2
84514: NEG
84515: PUSH
84516: LD_INT 3
84518: NEG
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: PUSH
84524: LD_INT 1
84526: NEG
84527: PUSH
84528: LD_INT 3
84530: NEG
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 1
84538: PUSH
84539: LD_INT 2
84541: NEG
84542: PUSH
84543: EMPTY
84544: LIST
84545: LIST
84546: PUSH
84547: LD_INT 2
84549: PUSH
84550: LD_INT 1
84552: NEG
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84583: LD_ADDR_VAR 0 24
84587: PUSH
84588: LD_INT 0
84590: PUSH
84591: LD_INT 0
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 0
84600: PUSH
84601: LD_INT 1
84603: NEG
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: PUSH
84609: LD_INT 1
84611: PUSH
84612: LD_INT 0
84614: PUSH
84615: EMPTY
84616: LIST
84617: LIST
84618: PUSH
84619: LD_INT 1
84621: PUSH
84622: LD_INT 1
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 0
84631: PUSH
84632: LD_INT 1
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: NEG
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 1
84652: NEG
84653: PUSH
84654: LD_INT 1
84656: NEG
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: PUSH
84662: LD_INT 1
84664: NEG
84665: PUSH
84666: LD_INT 2
84668: NEG
84669: PUSH
84670: EMPTY
84671: LIST
84672: LIST
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: LD_INT 2
84679: NEG
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 1
84687: PUSH
84688: LD_INT 1
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 2
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: PUSH
84706: LD_INT 2
84708: PUSH
84709: LD_INT 1
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 2
84718: PUSH
84719: LD_INT 2
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 1
84728: PUSH
84729: LD_INT 2
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 0
84738: PUSH
84739: LD_INT 2
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 1
84748: NEG
84749: PUSH
84750: LD_INT 1
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 2
84759: NEG
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 2
84770: NEG
84771: PUSH
84772: LD_INT 1
84774: NEG
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 2
84782: NEG
84783: PUSH
84784: LD_INT 2
84786: NEG
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: LD_INT 2
84797: NEG
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 2
84805: PUSH
84806: LD_INT 1
84808: NEG
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 3
84816: PUSH
84817: LD_INT 1
84819: PUSH
84820: EMPTY
84821: LIST
84822: LIST
84823: PUSH
84824: LD_INT 3
84826: PUSH
84827: LD_INT 2
84829: PUSH
84830: EMPTY
84831: LIST
84832: LIST
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84859: LD_ADDR_VAR 0 25
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 0
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 0
84876: PUSH
84877: LD_INT 1
84879: NEG
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 0
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 0
84907: PUSH
84908: LD_INT 1
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 1
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: NEG
84941: PUSH
84942: LD_INT 2
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: PUSH
84964: LD_INT 1
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: LD_INT 0
84977: PUSH
84978: EMPTY
84979: LIST
84980: LIST
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 1
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: LD_INT 2
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: LD_INT 1
85004: PUSH
85005: LD_INT 2
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: LD_INT 2
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: NEG
85025: PUSH
85026: LD_INT 1
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: LD_INT 0
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: PUSH
85044: LD_INT 2
85046: NEG
85047: PUSH
85048: LD_INT 1
85050: NEG
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 2
85058: NEG
85059: PUSH
85060: LD_INT 2
85062: NEG
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 3
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 3
85080: PUSH
85081: LD_INT 2
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 2
85090: PUSH
85091: LD_INT 3
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 1
85100: PUSH
85101: LD_INT 3
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85133: LD_ADDR_VAR 0 26
85137: PUSH
85138: LD_INT 0
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: LD_INT 0
85150: PUSH
85151: LD_INT 1
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: LD_INT 0
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: PUSH
85172: LD_INT 1
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 0
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PUSH
85189: LD_INT 1
85191: NEG
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 1
85202: NEG
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 1
85214: NEG
85215: PUSH
85216: LD_INT 2
85218: NEG
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: LD_INT 2
85229: NEG
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: LD_INT 1
85240: NEG
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 2
85248: PUSH
85249: LD_INT 0
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 2
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 2
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: PUSH
85279: LD_INT 2
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 0
85288: PUSH
85289: LD_INT 2
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 2
85309: NEG
85310: PUSH
85311: LD_INT 0
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: PUSH
85318: LD_INT 2
85320: NEG
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 2
85332: NEG
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 2
85344: PUSH
85345: LD_INT 3
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 1
85354: PUSH
85355: LD_INT 3
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: LD_INT 2
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85409: LD_ADDR_VAR 0 27
85413: PUSH
85414: LD_INT 0
85416: PUSH
85417: LD_INT 0
85419: PUSH
85420: EMPTY
85421: LIST
85422: LIST
85423: PUSH
85424: LD_INT 0
85426: PUSH
85427: LD_INT 1
85429: NEG
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: LD_INT 0
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PUSH
85445: LD_INT 1
85447: PUSH
85448: LD_INT 1
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 0
85457: PUSH
85458: LD_INT 1
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: LD_INT 0
85471: PUSH
85472: EMPTY
85473: LIST
85474: LIST
85475: PUSH
85476: LD_INT 1
85478: NEG
85479: PUSH
85480: LD_INT 1
85482: NEG
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 1
85490: NEG
85491: PUSH
85492: LD_INT 2
85494: NEG
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 0
85502: PUSH
85503: LD_INT 2
85505: NEG
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 1
85513: PUSH
85514: LD_INT 1
85516: NEG
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: LD_INT 2
85524: PUSH
85525: LD_INT 0
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 2
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: LD_INT 2
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 1
85554: PUSH
85555: LD_INT 2
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 0
85564: PUSH
85565: LD_INT 2
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 1
85574: NEG
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 2
85585: NEG
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 2
85608: NEG
85609: PUSH
85610: LD_INT 2
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 1
85620: NEG
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 2
85631: NEG
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 3
85642: NEG
85643: PUSH
85644: LD_INT 1
85646: NEG
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 3
85654: NEG
85655: PUSH
85656: LD_INT 2
85658: NEG
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85689: LD_ADDR_VAR 0 28
85693: PUSH
85694: LD_INT 0
85696: PUSH
85697: LD_INT 0
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: PUSH
85704: LD_INT 0
85706: PUSH
85707: LD_INT 1
85709: NEG
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 1
85717: PUSH
85718: LD_INT 0
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 1
85727: PUSH
85728: LD_INT 1
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 0
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: PUSH
85745: LD_INT 1
85747: NEG
85748: PUSH
85749: LD_INT 0
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: LD_INT 1
85762: NEG
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: LD_INT 2
85774: NEG
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 0
85782: PUSH
85783: LD_INT 2
85785: NEG
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 1
85793: PUSH
85794: LD_INT 1
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 2
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 2
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 2
85824: PUSH
85825: LD_INT 2
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 1
85834: PUSH
85835: LD_INT 2
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 0
85844: PUSH
85845: LD_INT 2
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 1
85854: NEG
85855: PUSH
85856: LD_INT 1
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: LD_INT 0
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: LD_INT 2
85876: NEG
85877: PUSH
85878: LD_INT 1
85880: NEG
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: PUSH
85886: LD_INT 2
85888: NEG
85889: PUSH
85890: LD_INT 2
85892: NEG
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 2
85900: NEG
85901: PUSH
85902: LD_INT 3
85904: NEG
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 1
85912: NEG
85913: PUSH
85914: LD_INT 3
85916: NEG
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 3
85924: NEG
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 3
85936: NEG
85937: PUSH
85938: LD_INT 2
85940: NEG
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85971: LD_ADDR_VAR 0 29
85975: PUSH
85976: LD_INT 0
85978: PUSH
85979: LD_INT 0
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 0
85988: PUSH
85989: LD_INT 1
85991: NEG
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: LD_INT 1
85999: PUSH
86000: LD_INT 0
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 1
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 0
86019: PUSH
86020: LD_INT 1
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 1
86029: NEG
86030: PUSH
86031: LD_INT 0
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: NEG
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: NEG
86053: PUSH
86054: LD_INT 2
86056: NEG
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: LD_INT 2
86067: NEG
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 1
86075: PUSH
86076: LD_INT 1
86078: NEG
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 2
86086: PUSH
86087: LD_INT 0
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: LD_INT 2
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: LD_INT 1
86106: PUSH
86107: LD_INT 2
86109: PUSH
86110: EMPTY
86111: LIST
86112: LIST
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 1
86126: NEG
86127: PUSH
86128: LD_INT 1
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: NEG
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 2
86149: NEG
86150: PUSH
86151: LD_INT 2
86153: NEG
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 2
86161: NEG
86162: PUSH
86163: LD_INT 3
86165: NEG
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 2
86173: PUSH
86174: LD_INT 1
86176: NEG
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 3
86184: PUSH
86185: LD_INT 1
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: LD_INT 1
86194: PUSH
86195: LD_INT 3
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 1
86204: NEG
86205: PUSH
86206: LD_INT 2
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PUSH
86213: LD_INT 3
86215: NEG
86216: PUSH
86217: LD_INT 2
86219: NEG
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86250: LD_ADDR_VAR 0 30
86254: PUSH
86255: LD_INT 0
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 0
86267: PUSH
86268: LD_INT 1
86270: NEG
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: PUSH
86279: LD_INT 0
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 1
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 0
86298: PUSH
86299: LD_INT 1
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: NEG
86309: PUSH
86310: LD_INT 0
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 1
86319: NEG
86320: PUSH
86321: LD_INT 1
86323: NEG
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 1
86331: NEG
86332: PUSH
86333: LD_INT 2
86335: NEG
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 0
86343: PUSH
86344: LD_INT 2
86346: NEG
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 1
86354: PUSH
86355: LD_INT 1
86357: NEG
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 2
86365: PUSH
86366: LD_INT 0
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: PUSH
86373: LD_INT 2
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 2
86385: PUSH
86386: LD_INT 2
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 1
86395: PUSH
86396: LD_INT 2
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: PUSH
86403: LD_INT 1
86405: NEG
86406: PUSH
86407: LD_INT 1
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 2
86416: NEG
86417: PUSH
86418: LD_INT 0
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 2
86427: NEG
86428: PUSH
86429: LD_INT 1
86431: NEG
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: LD_INT 1
86439: NEG
86440: PUSH
86441: LD_INT 3
86443: NEG
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: LD_INT 2
86454: NEG
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 3
86462: PUSH
86463: LD_INT 2
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: LD_INT 3
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 2
86482: NEG
86483: PUSH
86484: LD_INT 1
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 3
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86528: LD_ADDR_VAR 0 31
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: LD_INT 0
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: PUSH
86543: LD_INT 0
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: LD_INT 0
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: LD_INT 1
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 0
86576: PUSH
86577: LD_INT 1
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: NEG
86587: PUSH
86588: LD_INT 0
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 1
86597: NEG
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 1
86609: NEG
86610: PUSH
86611: LD_INT 2
86613: NEG
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: LD_INT 1
86621: PUSH
86622: LD_INT 1
86624: NEG
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: PUSH
86630: LD_INT 2
86632: PUSH
86633: LD_INT 0
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 2
86642: PUSH
86643: LD_INT 1
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 2
86652: PUSH
86653: LD_INT 2
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: LD_INT 2
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 0
86672: PUSH
86673: LD_INT 2
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 1
86682: NEG
86683: PUSH
86684: LD_INT 1
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PUSH
86691: LD_INT 2
86693: NEG
86694: PUSH
86695: LD_INT 1
86697: NEG
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 2
86705: NEG
86706: PUSH
86707: LD_INT 2
86709: NEG
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 2
86717: NEG
86718: PUSH
86719: LD_INT 3
86721: NEG
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 2
86729: PUSH
86730: LD_INT 1
86732: NEG
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 3
86740: PUSH
86741: LD_INT 1
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 1
86750: PUSH
86751: LD_INT 3
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 1
86760: NEG
86761: PUSH
86762: LD_INT 2
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 3
86771: NEG
86772: PUSH
86773: LD_INT 2
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86806: LD_ADDR_VAR 0 32
86810: PUSH
86811: LD_INT 0
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 0
86823: PUSH
86824: LD_INT 1
86826: NEG
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 1
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: PUSH
86842: LD_INT 1
86844: PUSH
86845: LD_INT 1
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 0
86854: PUSH
86855: LD_INT 1
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 1
86864: NEG
86865: PUSH
86866: LD_INT 0
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: LD_INT 1
86879: NEG
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 1
86887: NEG
86888: PUSH
86889: LD_INT 2
86891: NEG
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 0
86899: PUSH
86900: LD_INT 2
86902: NEG
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 1
86910: PUSH
86911: LD_INT 1
86913: NEG
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 2
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 2
86931: PUSH
86932: LD_INT 2
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 1
86941: PUSH
86942: LD_INT 2
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 0
86951: PUSH
86952: LD_INT 2
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 2
86972: NEG
86973: PUSH
86974: LD_INT 0
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 2
86983: NEG
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 1
86995: NEG
86996: PUSH
86997: LD_INT 3
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 1
87007: PUSH
87008: LD_INT 2
87010: NEG
87011: PUSH
87012: EMPTY
87013: LIST
87014: LIST
87015: PUSH
87016: LD_INT 3
87018: PUSH
87019: LD_INT 2
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PUSH
87026: LD_INT 2
87028: PUSH
87029: LD_INT 3
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 2
87038: NEG
87039: PUSH
87040: LD_INT 1
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 3
87049: NEG
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87084: LD_ADDR_VAR 0 33
87088: PUSH
87089: LD_INT 0
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 0
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 1
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 1
87153: NEG
87154: PUSH
87155: LD_INT 1
87157: NEG
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 1
87165: NEG
87166: PUSH
87167: LD_INT 2
87169: NEG
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 1
87177: PUSH
87178: LD_INT 1
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 2
87188: PUSH
87189: LD_INT 0
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 2
87198: PUSH
87199: LD_INT 1
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: PUSH
87206: LD_INT 1
87208: PUSH
87209: LD_INT 2
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 0
87218: PUSH
87219: LD_INT 2
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 1
87228: NEG
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 2
87239: NEG
87240: PUSH
87241: LD_INT 0
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PUSH
87248: LD_INT 2
87250: NEG
87251: PUSH
87252: LD_INT 1
87254: NEG
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 2
87262: NEG
87263: PUSH
87264: LD_INT 2
87266: NEG
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: LD_INT 2
87274: NEG
87275: PUSH
87276: LD_INT 3
87278: NEG
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 2
87286: PUSH
87287: LD_INT 1
87289: NEG
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 3
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: PUSH
87308: LD_INT 3
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 1
87317: NEG
87318: PUSH
87319: LD_INT 2
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 3
87328: NEG
87329: PUSH
87330: LD_INT 2
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87363: LD_ADDR_VAR 0 34
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: LD_INT 0
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: LD_INT 1
87383: NEG
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: PUSH
87392: LD_INT 0
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 1
87401: PUSH
87402: LD_INT 1
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 0
87411: PUSH
87412: LD_INT 1
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 1
87421: NEG
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: NEG
87433: PUSH
87434: LD_INT 1
87436: NEG
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: PUSH
87442: LD_INT 1
87444: NEG
87445: PUSH
87446: LD_INT 2
87448: NEG
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: LD_INT 2
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: LD_INT 1
87470: NEG
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 2
87478: PUSH
87479: LD_INT 1
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: PUSH
87486: LD_INT 2
87488: PUSH
87489: LD_INT 2
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: LD_INT 1
87498: PUSH
87499: LD_INT 2
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 1
87508: NEG
87509: PUSH
87510: LD_INT 1
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 2
87519: NEG
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 2
87530: NEG
87531: PUSH
87532: LD_INT 1
87534: NEG
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 2
87542: NEG
87543: PUSH
87544: LD_INT 2
87546: NEG
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 1
87554: NEG
87555: PUSH
87556: LD_INT 3
87558: NEG
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: PUSH
87564: LD_INT 1
87566: PUSH
87567: LD_INT 2
87569: NEG
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: LD_INT 3
87577: PUSH
87578: LD_INT 2
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: LD_INT 2
87587: PUSH
87588: LD_INT 3
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: PUSH
87595: LD_INT 2
87597: NEG
87598: PUSH
87599: LD_INT 1
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 3
87608: NEG
87609: PUSH
87610: LD_INT 1
87612: NEG
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87643: LD_ADDR_VAR 0 35
87647: PUSH
87648: LD_INT 0
87650: PUSH
87651: LD_INT 0
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 0
87660: PUSH
87661: LD_INT 1
87663: NEG
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: LD_INT 0
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 1
87681: PUSH
87682: LD_INT 1
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: LD_INT 1
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 1
87701: NEG
87702: PUSH
87703: LD_INT 0
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: NEG
87713: PUSH
87714: LD_INT 1
87716: NEG
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 2
87724: PUSH
87725: LD_INT 1
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 2
87734: NEG
87735: PUSH
87736: LD_INT 1
87738: NEG
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87755: LD_ADDR_VAR 0 36
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: LD_INT 1
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 1
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 0
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: NEG
87837: PUSH
87838: LD_INT 2
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: LD_INT 2
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87867: LD_ADDR_VAR 0 37
87871: PUSH
87872: LD_INT 0
87874: PUSH
87875: LD_INT 0
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_INT 1
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 1
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 1
87905: PUSH
87906: LD_INT 1
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: LD_INT 1
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: NEG
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: LD_INT 1
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: PUSH
87949: LD_INT 1
87951: NEG
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 1
87959: NEG
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87979: LD_ADDR_VAR 0 38
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 0
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 0
87996: PUSH
87997: LD_INT 1
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 1
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 1
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: LD_INT 1
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 1
88037: NEG
88038: PUSH
88039: LD_INT 0
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 2
88060: PUSH
88061: LD_INT 1
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 2
88070: NEG
88071: PUSH
88072: LD_INT 1
88074: NEG
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88091: LD_ADDR_VAR 0 39
88095: PUSH
88096: LD_INT 0
88098: PUSH
88099: LD_INT 0
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 0
88108: PUSH
88109: LD_INT 1
88111: NEG
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 1
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 1
88129: PUSH
88130: LD_INT 1
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 0
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 1
88149: NEG
88150: PUSH
88151: LD_INT 0
88153: PUSH
88154: EMPTY
88155: LIST
88156: LIST
88157: PUSH
88158: LD_INT 1
88160: NEG
88161: PUSH
88162: LD_INT 1
88164: NEG
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 1
88172: NEG
88173: PUSH
88174: LD_INT 2
88176: NEG
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: LD_INT 1
88184: PUSH
88185: LD_INT 2
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88203: LD_ADDR_VAR 0 40
88207: PUSH
88208: LD_INT 0
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 1
88241: PUSH
88242: LD_INT 1
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 0
88251: PUSH
88252: LD_INT 1
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 1
88261: NEG
88262: PUSH
88263: LD_INT 0
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 1
88272: NEG
88273: PUSH
88274: LD_INT 1
88276: NEG
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 1
88284: PUSH
88285: LD_INT 1
88287: NEG
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PUSH
88293: LD_INT 1
88295: NEG
88296: PUSH
88297: LD_INT 1
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88315: LD_ADDR_VAR 0 41
88319: PUSH
88320: LD_INT 0
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 0
88332: PUSH
88333: LD_INT 1
88335: NEG
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PUSH
88341: LD_INT 1
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: LD_INT 1
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 0
88363: PUSH
88364: LD_INT 1
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 1
88373: NEG
88374: PUSH
88375: LD_INT 0
88377: PUSH
88378: EMPTY
88379: LIST
88380: LIST
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: LD_INT 1
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 1
88396: NEG
88397: PUSH
88398: LD_INT 2
88400: NEG
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PUSH
88406: LD_INT 1
88408: PUSH
88409: LD_INT 1
88411: NEG
88412: PUSH
88413: EMPTY
88414: LIST
88415: LIST
88416: PUSH
88417: LD_INT 2
88419: PUSH
88420: LD_INT 0
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: PUSH
88427: LD_INT 2
88429: PUSH
88430: LD_INT 1
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: PUSH
88437: LD_INT 2
88439: PUSH
88440: LD_INT 2
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 1
88449: PUSH
88450: LD_INT 2
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 1
88459: NEG
88460: PUSH
88461: LD_INT 1
88463: PUSH
88464: EMPTY
88465: LIST
88466: LIST
88467: PUSH
88468: LD_INT 2
88470: NEG
88471: PUSH
88472: LD_INT 0
88474: PUSH
88475: EMPTY
88476: LIST
88477: LIST
88478: PUSH
88479: LD_INT 2
88481: NEG
88482: PUSH
88483: LD_INT 1
88485: NEG
88486: PUSH
88487: EMPTY
88488: LIST
88489: LIST
88490: PUSH
88491: LD_INT 2
88493: NEG
88494: PUSH
88495: LD_INT 2
88497: NEG
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PUSH
88503: LD_INT 2
88505: NEG
88506: PUSH
88507: LD_INT 3
88509: NEG
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 2
88517: PUSH
88518: LD_INT 1
88520: NEG
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 3
88528: PUSH
88529: LD_INT 0
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 3
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 3
88548: PUSH
88549: LD_INT 2
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 3
88558: PUSH
88559: LD_INT 3
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 2
88568: PUSH
88569: LD_INT 3
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 2
88578: NEG
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 3
88589: NEG
88590: PUSH
88591: LD_INT 0
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 3
88600: NEG
88601: PUSH
88602: LD_INT 1
88604: NEG
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 3
88612: NEG
88613: PUSH
88614: LD_INT 2
88616: NEG
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 3
88624: NEG
88625: PUSH
88626: LD_INT 3
88628: NEG
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88665: LD_ADDR_VAR 0 42
88669: PUSH
88670: LD_INT 0
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 0
88682: PUSH
88683: LD_INT 1
88685: NEG
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 1
88693: PUSH
88694: LD_INT 0
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: PUSH
88701: LD_INT 1
88703: PUSH
88704: LD_INT 1
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: LD_INT 1
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 1
88723: NEG
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 1
88734: NEG
88735: PUSH
88736: LD_INT 1
88738: NEG
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 1
88746: NEG
88747: PUSH
88748: LD_INT 2
88750: NEG
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: LD_INT 2
88761: NEG
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: LD_INT 1
88772: NEG
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 2
88780: PUSH
88781: LD_INT 1
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 2
88790: PUSH
88791: LD_INT 2
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: LD_INT 2
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: LD_INT 2
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 1
88820: NEG
88821: PUSH
88822: LD_INT 1
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 2
88831: NEG
88832: PUSH
88833: LD_INT 1
88835: NEG
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: LD_INT 2
88843: NEG
88844: PUSH
88845: LD_INT 2
88847: NEG
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PUSH
88853: LD_INT 2
88855: NEG
88856: PUSH
88857: LD_INT 3
88859: NEG
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 1
88867: NEG
88868: PUSH
88869: LD_INT 3
88871: NEG
88872: PUSH
88873: EMPTY
88874: LIST
88875: LIST
88876: PUSH
88877: LD_INT 0
88879: PUSH
88880: LD_INT 3
88882: NEG
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 1
88890: PUSH
88891: LD_INT 2
88893: NEG
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 3
88901: PUSH
88902: LD_INT 2
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 3
88911: PUSH
88912: LD_INT 3
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 2
88921: PUSH
88922: LD_INT 3
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 1
88931: PUSH
88932: LD_INT 3
88934: PUSH
88935: EMPTY
88936: LIST
88937: LIST
88938: PUSH
88939: LD_INT 0
88941: PUSH
88942: LD_INT 3
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 1
88951: NEG
88952: PUSH
88953: LD_INT 2
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 3
88962: NEG
88963: PUSH
88964: LD_INT 2
88966: NEG
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 3
88974: NEG
88975: PUSH
88976: LD_INT 3
88978: NEG
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89015: LD_ADDR_VAR 0 43
89019: PUSH
89020: LD_INT 0
89022: PUSH
89023: LD_INT 0
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: LD_INT 1
89035: NEG
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 1
89043: PUSH
89044: LD_INT 0
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 1
89053: PUSH
89054: LD_INT 1
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: LD_INT 1
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: NEG
89074: PUSH
89075: LD_INT 0
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: PUSH
89086: LD_INT 1
89088: NEG
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 1
89096: NEG
89097: PUSH
89098: LD_INT 2
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 0
89108: PUSH
89109: LD_INT 2
89111: NEG
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: PUSH
89120: LD_INT 1
89122: NEG
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: LD_INT 2
89130: PUSH
89131: LD_INT 0
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 2
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 1
89150: PUSH
89151: LD_INT 2
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 2
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 2
89181: NEG
89182: PUSH
89183: LD_INT 0
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 2
89192: NEG
89193: PUSH
89194: LD_INT 1
89196: NEG
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: LD_INT 3
89208: NEG
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 0
89216: PUSH
89217: LD_INT 3
89219: NEG
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 1
89227: PUSH
89228: LD_INT 2
89230: NEG
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: PUSH
89236: LD_INT 2
89238: PUSH
89239: LD_INT 1
89241: NEG
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 3
89249: PUSH
89250: LD_INT 0
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PUSH
89257: LD_INT 3
89259: PUSH
89260: LD_INT 1
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: PUSH
89267: LD_INT 1
89269: PUSH
89270: LD_INT 3
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 0
89279: PUSH
89280: LD_INT 3
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 1
89289: NEG
89290: PUSH
89291: LD_INT 2
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 2
89300: NEG
89301: PUSH
89302: LD_INT 1
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 3
89311: NEG
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 3
89322: NEG
89323: PUSH
89324: LD_INT 1
89326: NEG
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89363: LD_ADDR_VAR 0 44
89367: PUSH
89368: LD_INT 0
89370: PUSH
89371: LD_INT 0
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 0
89380: PUSH
89381: LD_INT 1
89383: NEG
89384: PUSH
89385: EMPTY
89386: LIST
89387: LIST
89388: PUSH
89389: LD_INT 1
89391: PUSH
89392: LD_INT 0
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: LD_INT 1
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 0
89411: PUSH
89412: LD_INT 1
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 1
89432: NEG
89433: PUSH
89434: LD_INT 1
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 1
89444: NEG
89445: PUSH
89446: LD_INT 2
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 1
89456: PUSH
89457: LD_INT 1
89459: NEG
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 2
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 2
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 2
89487: PUSH
89488: LD_INT 2
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 1
89497: PUSH
89498: LD_INT 2
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 1
89507: NEG
89508: PUSH
89509: LD_INT 1
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: LD_INT 2
89518: NEG
89519: PUSH
89520: LD_INT 0
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: LD_INT 2
89529: NEG
89530: PUSH
89531: LD_INT 1
89533: NEG
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 2
89541: NEG
89542: PUSH
89543: LD_INT 2
89545: NEG
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 2
89553: NEG
89554: PUSH
89555: LD_INT 3
89557: NEG
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 2
89565: PUSH
89566: LD_INT 1
89568: NEG
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 3
89576: PUSH
89577: LD_INT 0
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PUSH
89584: LD_INT 3
89586: PUSH
89587: LD_INT 1
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 3
89596: PUSH
89597: LD_INT 2
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 3
89606: PUSH
89607: LD_INT 3
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 2
89616: PUSH
89617: LD_INT 3
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: NEG
89627: PUSH
89628: LD_INT 1
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 3
89637: NEG
89638: PUSH
89639: LD_INT 0
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 3
89648: NEG
89649: PUSH
89650: LD_INT 1
89652: NEG
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 3
89660: NEG
89661: PUSH
89662: LD_INT 2
89664: NEG
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 3
89672: NEG
89673: PUSH
89674: LD_INT 3
89676: NEG
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89713: LD_ADDR_VAR 0 45
89717: PUSH
89718: LD_INT 0
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 0
89730: PUSH
89731: LD_INT 1
89733: NEG
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: LD_INT 0
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: LD_INT 1
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 1
89782: NEG
89783: PUSH
89784: LD_INT 1
89786: NEG
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 1
89794: NEG
89795: PUSH
89796: LD_INT 2
89798: NEG
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 0
89806: PUSH
89807: LD_INT 2
89809: NEG
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 1
89817: PUSH
89818: LD_INT 1
89820: NEG
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 2
89828: PUSH
89829: LD_INT 1
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 2
89838: PUSH
89839: LD_INT 2
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 1
89848: PUSH
89849: LD_INT 2
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: LD_INT 2
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 1
89868: NEG
89869: PUSH
89870: LD_INT 1
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: NEG
89880: PUSH
89881: LD_INT 1
89883: NEG
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 2
89891: NEG
89892: PUSH
89893: LD_INT 2
89895: NEG
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PUSH
89901: LD_INT 2
89903: NEG
89904: PUSH
89905: LD_INT 3
89907: NEG
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 1
89915: NEG
89916: PUSH
89917: LD_INT 3
89919: NEG
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 0
89927: PUSH
89928: LD_INT 3
89930: NEG
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 1
89938: PUSH
89939: LD_INT 2
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 3
89949: PUSH
89950: LD_INT 2
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 3
89959: PUSH
89960: LD_INT 3
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 2
89969: PUSH
89970: LD_INT 3
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 1
89979: PUSH
89980: LD_INT 3
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 0
89989: PUSH
89990: LD_INT 3
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: LD_INT 2
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 3
90010: NEG
90011: PUSH
90012: LD_INT 2
90014: NEG
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 3
90022: NEG
90023: PUSH
90024: LD_INT 3
90026: NEG
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90063: LD_ADDR_VAR 0 46
90067: PUSH
90068: LD_INT 0
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 0
90080: PUSH
90081: LD_INT 1
90083: NEG
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 1
90091: PUSH
90092: LD_INT 0
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 1
90101: PUSH
90102: LD_INT 1
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 0
90111: PUSH
90112: LD_INT 1
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 1
90121: NEG
90122: PUSH
90123: LD_INT 0
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 1
90132: NEG
90133: PUSH
90134: LD_INT 1
90136: NEG
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 1
90144: NEG
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 0
90156: PUSH
90157: LD_INT 2
90159: NEG
90160: PUSH
90161: EMPTY
90162: LIST
90163: LIST
90164: PUSH
90165: LD_INT 1
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 2
90178: PUSH
90179: LD_INT 0
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 2
90188: PUSH
90189: LD_INT 1
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 1
90198: PUSH
90199: LD_INT 2
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 0
90208: PUSH
90209: LD_INT 2
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: LD_INT 1
90218: NEG
90219: PUSH
90220: LD_INT 1
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: LD_INT 0
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 2
90240: NEG
90241: PUSH
90242: LD_INT 1
90244: NEG
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 1
90252: NEG
90253: PUSH
90254: LD_INT 3
90256: NEG
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: LD_INT 3
90267: NEG
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 1
90275: PUSH
90276: LD_INT 2
90278: NEG
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 2
90286: PUSH
90287: LD_INT 1
90289: NEG
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 3
90297: PUSH
90298: LD_INT 0
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 3
90307: PUSH
90308: LD_INT 1
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: LD_INT 1
90317: PUSH
90318: LD_INT 3
90320: PUSH
90321: EMPTY
90322: LIST
90323: LIST
90324: PUSH
90325: LD_INT 0
90327: PUSH
90328: LD_INT 3
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: NEG
90338: PUSH
90339: LD_INT 2
90341: PUSH
90342: EMPTY
90343: LIST
90344: LIST
90345: PUSH
90346: LD_INT 2
90348: NEG
90349: PUSH
90350: LD_INT 1
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 3
90359: NEG
90360: PUSH
90361: LD_INT 0
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 3
90370: NEG
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90411: LD_ADDR_VAR 0 47
90415: PUSH
90416: LD_INT 0
90418: PUSH
90419: LD_INT 0
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 0
90428: PUSH
90429: LD_INT 1
90431: NEG
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 1
90439: PUSH
90440: LD_INT 0
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 1
90449: PUSH
90450: LD_INT 1
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: LD_INT 1
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: NEG
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 2
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 2
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 2
90526: NEG
90527: PUSH
90528: LD_INT 1
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 2
90538: NEG
90539: PUSH
90540: LD_INT 2
90542: NEG
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90562: LD_ADDR_VAR 0 48
90566: PUSH
90567: LD_INT 0
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 0
90579: PUSH
90580: LD_INT 1
90582: NEG
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 1
90590: PUSH
90591: LD_INT 0
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 1
90600: PUSH
90601: LD_INT 1
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: LD_INT 1
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 1
90620: NEG
90621: PUSH
90622: LD_INT 0
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 1
90631: NEG
90632: PUSH
90633: LD_INT 1
90635: NEG
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 1
90643: NEG
90644: PUSH
90645: LD_INT 2
90647: NEG
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 0
90655: PUSH
90656: LD_INT 2
90658: NEG
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 1
90666: PUSH
90667: LD_INT 1
90669: NEG
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 2
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 2
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90709: LD_ADDR_VAR 0 49
90713: PUSH
90714: LD_INT 0
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 0
90726: PUSH
90727: LD_INT 1
90729: NEG
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 1
90737: PUSH
90738: LD_INT 0
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: LD_INT 1
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 0
90757: PUSH
90758: LD_INT 1
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 1
90767: NEG
90768: PUSH
90769: LD_INT 0
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 1
90778: NEG
90779: PUSH
90780: LD_INT 1
90782: NEG
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 1
90790: PUSH
90791: LD_INT 1
90793: NEG
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 2
90801: PUSH
90802: LD_INT 0
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 2
90811: PUSH
90812: LD_INT 1
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 2
90821: PUSH
90822: LD_INT 2
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 1
90831: PUSH
90832: LD_INT 2
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90853: LD_ADDR_VAR 0 50
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 0
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: PUSH
90882: LD_INT 0
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 1
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 0
90901: PUSH
90902: LD_INT 1
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 1
90911: NEG
90912: PUSH
90913: LD_INT 0
90915: PUSH
90916: EMPTY
90917: LIST
90918: LIST
90919: PUSH
90920: LD_INT 1
90922: NEG
90923: PUSH
90924: LD_INT 1
90926: NEG
90927: PUSH
90928: EMPTY
90929: LIST
90930: LIST
90931: PUSH
90932: LD_INT 2
90934: PUSH
90935: LD_INT 1
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 2
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 1
90954: PUSH
90955: LD_INT 2
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 0
90964: PUSH
90965: LD_INT 2
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: LD_INT 1
90974: NEG
90975: PUSH
90976: LD_INT 1
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90997: LD_ADDR_VAR 0 51
91001: PUSH
91002: LD_INT 0
91004: PUSH
91005: LD_INT 0
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 0
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 1
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 1
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 0
91045: PUSH
91046: LD_INT 1
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 1
91055: NEG
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 1
91066: NEG
91067: PUSH
91068: LD_INT 1
91070: NEG
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 1
91078: PUSH
91079: LD_INT 2
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 0
91088: PUSH
91089: LD_INT 2
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: LD_INT 1
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: PUSH
91107: LD_INT 2
91109: NEG
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 2
91120: NEG
91121: PUSH
91122: LD_INT 1
91124: NEG
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91144: LD_ADDR_VAR 0 52
91148: PUSH
91149: LD_INT 0
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 0
91161: PUSH
91162: LD_INT 1
91164: NEG
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 1
91172: PUSH
91173: LD_INT 0
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 1
91182: PUSH
91183: LD_INT 1
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 0
91192: PUSH
91193: LD_INT 1
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: NEG
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: LD_INT 1
91213: NEG
91214: PUSH
91215: LD_INT 1
91217: NEG
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 1
91225: NEG
91226: PUSH
91227: LD_INT 2
91229: NEG
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: LD_INT 1
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 2
91248: NEG
91249: PUSH
91250: LD_INT 0
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 2
91259: NEG
91260: PUSH
91261: LD_INT 1
91263: NEG
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 2
91271: NEG
91272: PUSH
91273: LD_INT 2
91275: NEG
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91295: LD_ADDR_VAR 0 53
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: LD_INT 0
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 0
91312: PUSH
91313: LD_INT 1
91315: NEG
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: PUSH
91324: LD_INT 0
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: LD_INT 1
91333: PUSH
91334: LD_INT 1
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 0
91343: PUSH
91344: LD_INT 1
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 1
91353: NEG
91354: PUSH
91355: LD_INT 0
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 1
91364: NEG
91365: PUSH
91366: LD_INT 1
91368: NEG
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: LD_INT 1
91376: NEG
91377: PUSH
91378: LD_INT 2
91380: NEG
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 0
91388: PUSH
91389: LD_INT 2
91391: NEG
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 1
91399: PUSH
91400: LD_INT 1
91402: NEG
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 2
91410: PUSH
91411: LD_INT 0
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 2
91420: PUSH
91421: LD_INT 1
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 2
91430: PUSH
91431: LD_INT 2
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 1
91440: PUSH
91441: LD_INT 2
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 0
91450: PUSH
91451: LD_INT 2
91453: PUSH
91454: EMPTY
91455: LIST
91456: LIST
91457: PUSH
91458: LD_INT 1
91460: NEG
91461: PUSH
91462: LD_INT 1
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: LD_INT 2
91471: NEG
91472: PUSH
91473: LD_INT 0
91475: PUSH
91476: EMPTY
91477: LIST
91478: LIST
91479: PUSH
91480: LD_INT 2
91482: NEG
91483: PUSH
91484: LD_INT 1
91486: NEG
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PUSH
91492: LD_INT 2
91494: NEG
91495: PUSH
91496: LD_INT 2
91498: NEG
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91525: LD_ADDR_VAR 0 54
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: LD_INT 0
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 0
91542: PUSH
91543: LD_INT 1
91545: NEG
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: LD_INT 0
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 1
91563: PUSH
91564: LD_INT 1
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 0
91573: PUSH
91574: LD_INT 1
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 1
91583: NEG
91584: PUSH
91585: LD_INT 0
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 1
91594: NEG
91595: PUSH
91596: LD_INT 1
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: NEG
91607: PUSH
91608: LD_INT 2
91610: NEG
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 0
91618: PUSH
91619: LD_INT 2
91621: NEG
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: LD_INT 1
91632: NEG
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: PUSH
91638: LD_INT 2
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 2
91650: PUSH
91651: LD_INT 1
91653: PUSH
91654: EMPTY
91655: LIST
91656: LIST
91657: PUSH
91658: LD_INT 2
91660: PUSH
91661: LD_INT 2
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 1
91670: PUSH
91671: LD_INT 2
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 0
91680: PUSH
91681: LD_INT 2
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 1
91690: NEG
91691: PUSH
91692: LD_INT 1
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 2
91701: NEG
91702: PUSH
91703: LD_INT 0
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 2
91712: NEG
91713: PUSH
91714: LD_INT 1
91716: NEG
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 2
91724: NEG
91725: PUSH
91726: LD_INT 2
91728: NEG
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91755: LD_ADDR_VAR 0 55
91759: PUSH
91760: LD_INT 0
91762: PUSH
91763: LD_INT 0
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 0
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: LD_INT 1
91783: PUSH
91784: LD_INT 0
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: PUSH
91791: LD_INT 1
91793: PUSH
91794: LD_INT 1
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 0
91803: PUSH
91804: LD_INT 1
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 1
91813: NEG
91814: PUSH
91815: LD_INT 0
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 1
91824: NEG
91825: PUSH
91826: LD_INT 1
91828: NEG
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: NEG
91837: PUSH
91838: LD_INT 2
91840: NEG
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 0
91848: PUSH
91849: LD_INT 2
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 1
91859: PUSH
91860: LD_INT 1
91862: NEG
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 2
91870: PUSH
91871: LD_INT 0
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 2
91880: PUSH
91881: LD_INT 1
91883: PUSH
91884: EMPTY
91885: LIST
91886: LIST
91887: PUSH
91888: LD_INT 2
91890: PUSH
91891: LD_INT 2
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 1
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: EMPTY
91905: LIST
91906: LIST
91907: PUSH
91908: LD_INT 0
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 1
91920: NEG
91921: PUSH
91922: LD_INT 1
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 2
91931: NEG
91932: PUSH
91933: LD_INT 0
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 2
91942: NEG
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 2
91954: NEG
91955: PUSH
91956: LD_INT 2
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91985: LD_ADDR_VAR 0 56
91989: PUSH
91990: LD_INT 0
91992: PUSH
91993: LD_INT 0
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: PUSH
92000: LD_INT 0
92002: PUSH
92003: LD_INT 1
92005: NEG
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: LD_INT 0
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 1
92023: PUSH
92024: LD_INT 1
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 0
92033: PUSH
92034: LD_INT 1
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 1
92043: NEG
92044: PUSH
92045: LD_INT 0
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 1
92054: NEG
92055: PUSH
92056: LD_INT 1
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 1
92066: NEG
92067: PUSH
92068: LD_INT 2
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 0
92078: PUSH
92079: LD_INT 2
92081: NEG
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: LD_INT 1
92092: NEG
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 2
92100: PUSH
92101: LD_INT 0
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 2
92110: PUSH
92111: LD_INT 1
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: LD_INT 2
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 1
92130: PUSH
92131: LD_INT 2
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 0
92140: PUSH
92141: LD_INT 2
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 1
92150: NEG
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 2
92161: NEG
92162: PUSH
92163: LD_INT 0
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: LD_INT 2
92172: NEG
92173: PUSH
92174: LD_INT 1
92176: NEG
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 2
92184: NEG
92185: PUSH
92186: LD_INT 2
92188: NEG
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: EMPTY
92195: LIST
92196: LIST
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92215: LD_ADDR_VAR 0 57
92219: PUSH
92220: LD_INT 0
92222: PUSH
92223: LD_INT 0
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 0
92232: PUSH
92233: LD_INT 1
92235: NEG
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: LD_INT 0
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 1
92253: PUSH
92254: LD_INT 1
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 0
92263: PUSH
92264: LD_INT 1
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 1
92273: NEG
92274: PUSH
92275: LD_INT 0
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 1
92284: NEG
92285: PUSH
92286: LD_INT 1
92288: NEG
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 1
92296: NEG
92297: PUSH
92298: LD_INT 2
92300: NEG
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: PUSH
92306: LD_INT 0
92308: PUSH
92309: LD_INT 2
92311: NEG
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 1
92319: PUSH
92320: LD_INT 1
92322: NEG
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PUSH
92328: LD_INT 2
92330: PUSH
92331: LD_INT 0
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: LD_INT 2
92340: PUSH
92341: LD_INT 1
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PUSH
92348: LD_INT 2
92350: PUSH
92351: LD_INT 2
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 1
92360: PUSH
92361: LD_INT 2
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 0
92370: PUSH
92371: LD_INT 2
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 1
92380: NEG
92381: PUSH
92382: LD_INT 1
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: LD_INT 2
92391: NEG
92392: PUSH
92393: LD_INT 0
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 2
92402: NEG
92403: PUSH
92404: LD_INT 1
92406: NEG
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 2
92414: NEG
92415: PUSH
92416: LD_INT 2
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92445: LD_ADDR_VAR 0 58
92449: PUSH
92450: LD_INT 0
92452: PUSH
92453: LD_INT 0
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: LD_INT 0
92462: PUSH
92463: LD_INT 1
92465: NEG
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: LD_INT 0
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 1
92483: PUSH
92484: LD_INT 1
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 0
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 1
92503: NEG
92504: PUSH
92505: LD_INT 0
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 1
92514: NEG
92515: PUSH
92516: LD_INT 1
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: NEG
92527: PUSH
92528: LD_INT 2
92530: NEG
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 0
92538: PUSH
92539: LD_INT 2
92541: NEG
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 1
92549: PUSH
92550: LD_INT 1
92552: NEG
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 2
92560: PUSH
92561: LD_INT 0
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: LD_INT 1
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 2
92580: PUSH
92581: LD_INT 2
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: LD_INT 2
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 1
92610: NEG
92611: PUSH
92612: LD_INT 1
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 2
92621: NEG
92622: PUSH
92623: LD_INT 0
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: NEG
92633: PUSH
92634: LD_INT 1
92636: NEG
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 2
92644: NEG
92645: PUSH
92646: LD_INT 2
92648: NEG
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92675: LD_ADDR_VAR 0 59
92679: PUSH
92680: LD_INT 0
92682: PUSH
92683: LD_INT 0
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 0
92692: PUSH
92693: LD_INT 1
92695: NEG
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: LD_INT 0
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 1
92713: PUSH
92714: LD_INT 1
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 0
92723: PUSH
92724: LD_INT 1
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 1
92733: NEG
92734: PUSH
92735: LD_INT 0
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 1
92744: NEG
92745: PUSH
92746: LD_INT 1
92748: NEG
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: EMPTY
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92763: LD_ADDR_VAR 0 60
92767: PUSH
92768: LD_INT 0
92770: PUSH
92771: LD_INT 0
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 0
92780: PUSH
92781: LD_INT 1
92783: NEG
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 1
92791: PUSH
92792: LD_INT 0
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 1
92801: PUSH
92802: LD_INT 1
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 0
92811: PUSH
92812: LD_INT 1
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 1
92821: NEG
92822: PUSH
92823: LD_INT 0
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 1
92832: NEG
92833: PUSH
92834: LD_INT 1
92836: NEG
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92851: LD_ADDR_VAR 0 61
92855: PUSH
92856: LD_INT 0
92858: PUSH
92859: LD_INT 0
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 0
92868: PUSH
92869: LD_INT 1
92871: NEG
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 1
92879: PUSH
92880: LD_INT 0
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 1
92889: PUSH
92890: LD_INT 1
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 0
92899: PUSH
92900: LD_INT 1
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 1
92909: NEG
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 1
92920: NEG
92921: PUSH
92922: LD_INT 1
92924: NEG
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92939: LD_ADDR_VAR 0 62
92943: PUSH
92944: LD_INT 0
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 0
92956: PUSH
92957: LD_INT 1
92959: NEG
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 1
92967: PUSH
92968: LD_INT 0
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 1
92977: PUSH
92978: LD_INT 1
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 0
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 1
92997: NEG
92998: PUSH
92999: LD_INT 0
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PUSH
93006: LD_INT 1
93008: NEG
93009: PUSH
93010: LD_INT 1
93012: NEG
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93027: LD_ADDR_VAR 0 63
93031: PUSH
93032: LD_INT 0
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 0
93044: PUSH
93045: LD_INT 1
93047: NEG
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 1
93055: PUSH
93056: LD_INT 0
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 1
93065: PUSH
93066: LD_INT 1
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: LD_INT 1
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 1
93085: NEG
93086: PUSH
93087: LD_INT 0
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 1
93096: NEG
93097: PUSH
93098: LD_INT 1
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: LIST
93110: LIST
93111: LIST
93112: LIST
93113: LIST
93114: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93115: LD_ADDR_VAR 0 64
93119: PUSH
93120: LD_INT 0
93122: PUSH
93123: LD_INT 0
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 0
93132: PUSH
93133: LD_INT 1
93135: NEG
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: PUSH
93141: LD_INT 1
93143: PUSH
93144: LD_INT 0
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 1
93153: PUSH
93154: LD_INT 1
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 0
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 1
93173: NEG
93174: PUSH
93175: LD_INT 0
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 1
93184: NEG
93185: PUSH
93186: LD_INT 1
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: ST_TO_ADDR
// end ; 1 :
93203: GO 99100
93205: LD_INT 1
93207: DOUBLE
93208: EQUAL
93209: IFTRUE 93213
93211: GO 95836
93213: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93214: LD_ADDR_VAR 0 11
93218: PUSH
93219: LD_INT 1
93221: NEG
93222: PUSH
93223: LD_INT 3
93225: NEG
93226: PUSH
93227: EMPTY
93228: LIST
93229: LIST
93230: PUSH
93231: LD_INT 0
93233: PUSH
93234: LD_INT 3
93236: NEG
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: PUSH
93242: LD_INT 1
93244: PUSH
93245: LD_INT 2
93247: NEG
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: LIST
93257: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93258: LD_ADDR_VAR 0 12
93262: PUSH
93263: LD_INT 2
93265: PUSH
93266: LD_INT 1
93268: NEG
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 3
93276: PUSH
93277: LD_INT 0
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 3
93286: PUSH
93287: LD_INT 1
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: LIST
93298: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93299: LD_ADDR_VAR 0 13
93303: PUSH
93304: LD_INT 3
93306: PUSH
93307: LD_INT 2
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 3
93316: PUSH
93317: LD_INT 3
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 2
93326: PUSH
93327: LD_INT 3
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: LIST
93338: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93339: LD_ADDR_VAR 0 14
93343: PUSH
93344: LD_INT 1
93346: PUSH
93347: LD_INT 3
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: PUSH
93354: LD_INT 0
93356: PUSH
93357: LD_INT 3
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 1
93366: NEG
93367: PUSH
93368: LD_INT 2
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: LIST
93379: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93380: LD_ADDR_VAR 0 15
93384: PUSH
93385: LD_INT 2
93387: NEG
93388: PUSH
93389: LD_INT 1
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 3
93398: NEG
93399: PUSH
93400: LD_INT 0
93402: PUSH
93403: EMPTY
93404: LIST
93405: LIST
93406: PUSH
93407: LD_INT 3
93409: NEG
93410: PUSH
93411: LD_INT 1
93413: NEG
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: LIST
93423: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93424: LD_ADDR_VAR 0 16
93428: PUSH
93429: LD_INT 2
93431: NEG
93432: PUSH
93433: LD_INT 3
93435: NEG
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 3
93443: NEG
93444: PUSH
93445: LD_INT 2
93447: NEG
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 3
93455: NEG
93456: PUSH
93457: LD_INT 3
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: LIST
93469: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93470: LD_ADDR_VAR 0 17
93474: PUSH
93475: LD_INT 1
93477: NEG
93478: PUSH
93479: LD_INT 3
93481: NEG
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 0
93489: PUSH
93490: LD_INT 3
93492: NEG
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 1
93500: PUSH
93501: LD_INT 2
93503: NEG
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: LIST
93513: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93514: LD_ADDR_VAR 0 18
93518: PUSH
93519: LD_INT 2
93521: PUSH
93522: LD_INT 1
93524: NEG
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 3
93532: PUSH
93533: LD_INT 0
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 3
93542: PUSH
93543: LD_INT 1
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: LIST
93554: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93555: LD_ADDR_VAR 0 19
93559: PUSH
93560: LD_INT 3
93562: PUSH
93563: LD_INT 2
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 3
93572: PUSH
93573: LD_INT 3
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: PUSH
93580: LD_INT 2
93582: PUSH
93583: LD_INT 3
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: LIST
93594: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93595: LD_ADDR_VAR 0 20
93599: PUSH
93600: LD_INT 1
93602: PUSH
93603: LD_INT 3
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 0
93612: PUSH
93613: LD_INT 3
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 1
93622: NEG
93623: PUSH
93624: LD_INT 2
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: LIST
93635: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93636: LD_ADDR_VAR 0 21
93640: PUSH
93641: LD_INT 2
93643: NEG
93644: PUSH
93645: LD_INT 1
93647: PUSH
93648: EMPTY
93649: LIST
93650: LIST
93651: PUSH
93652: LD_INT 3
93654: NEG
93655: PUSH
93656: LD_INT 0
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 3
93665: NEG
93666: PUSH
93667: LD_INT 1
93669: NEG
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: LIST
93679: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93680: LD_ADDR_VAR 0 22
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 3
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 2
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: LD_INT 3
93711: NEG
93712: PUSH
93713: LD_INT 3
93715: NEG
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: LIST
93725: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93726: LD_ADDR_VAR 0 23
93730: PUSH
93731: LD_INT 0
93733: PUSH
93734: LD_INT 3
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 1
93744: NEG
93745: PUSH
93746: LD_INT 4
93748: NEG
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 1
93756: PUSH
93757: LD_INT 3
93759: NEG
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: LIST
93769: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93770: LD_ADDR_VAR 0 24
93774: PUSH
93775: LD_INT 3
93777: PUSH
93778: LD_INT 0
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 3
93787: PUSH
93788: LD_INT 1
93790: NEG
93791: PUSH
93792: EMPTY
93793: LIST
93794: LIST
93795: PUSH
93796: LD_INT 4
93798: PUSH
93799: LD_INT 1
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: LIST
93810: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93811: LD_ADDR_VAR 0 25
93815: PUSH
93816: LD_INT 3
93818: PUSH
93819: LD_INT 3
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 4
93828: PUSH
93829: LD_INT 3
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: LD_INT 4
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: LIST
93850: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93851: LD_ADDR_VAR 0 26
93855: PUSH
93856: LD_INT 0
93858: PUSH
93859: LD_INT 3
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 1
93868: PUSH
93869: LD_INT 4
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: LD_INT 1
93878: NEG
93879: PUSH
93880: LD_INT 3
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: LIST
93891: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93892: LD_ADDR_VAR 0 27
93896: PUSH
93897: LD_INT 3
93899: NEG
93900: PUSH
93901: LD_INT 0
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 3
93910: NEG
93911: PUSH
93912: LD_INT 1
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 4
93921: NEG
93922: PUSH
93923: LD_INT 1
93925: NEG
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: EMPTY
93932: LIST
93933: LIST
93934: LIST
93935: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93936: LD_ADDR_VAR 0 28
93940: PUSH
93941: LD_INT 3
93943: NEG
93944: PUSH
93945: LD_INT 3
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 3
93955: NEG
93956: PUSH
93957: LD_INT 4
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 4
93967: NEG
93968: PUSH
93969: LD_INT 3
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: LIST
93981: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93982: LD_ADDR_VAR 0 29
93986: PUSH
93987: LD_INT 1
93989: NEG
93990: PUSH
93991: LD_INT 3
93993: NEG
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 0
94001: PUSH
94002: LD_INT 3
94004: NEG
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 1
94012: PUSH
94013: LD_INT 2
94015: NEG
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 1
94023: NEG
94024: PUSH
94025: LD_INT 4
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 0
94035: PUSH
94036: LD_INT 4
94038: NEG
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 1
94046: PUSH
94047: LD_INT 3
94049: NEG
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 1
94057: NEG
94058: PUSH
94059: LD_INT 5
94061: NEG
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: LD_INT 0
94069: PUSH
94070: LD_INT 5
94072: NEG
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: PUSH
94078: LD_INT 1
94080: PUSH
94081: LD_INT 4
94083: NEG
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 1
94091: NEG
94092: PUSH
94093: LD_INT 6
94095: NEG
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 0
94103: PUSH
94104: LD_INT 6
94106: NEG
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 1
94114: PUSH
94115: LD_INT 5
94117: NEG
94118: PUSH
94119: EMPTY
94120: LIST
94121: LIST
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94137: LD_ADDR_VAR 0 30
94141: PUSH
94142: LD_INT 2
94144: PUSH
94145: LD_INT 1
94147: NEG
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 3
94155: PUSH
94156: LD_INT 0
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 3
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 3
94175: PUSH
94176: LD_INT 1
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: LD_INT 4
94186: PUSH
94187: LD_INT 0
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 4
94196: PUSH
94197: LD_INT 1
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 4
94206: PUSH
94207: LD_INT 1
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 5
94217: PUSH
94218: LD_INT 0
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 5
94227: PUSH
94228: LD_INT 1
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 5
94237: PUSH
94238: LD_INT 1
94240: NEG
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 6
94248: PUSH
94249: LD_INT 0
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: PUSH
94256: LD_INT 6
94258: PUSH
94259: LD_INT 1
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94280: LD_ADDR_VAR 0 31
94284: PUSH
94285: LD_INT 3
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 3
94297: PUSH
94298: LD_INT 3
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 2
94307: PUSH
94308: LD_INT 3
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 4
94317: PUSH
94318: LD_INT 3
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 4
94327: PUSH
94328: LD_INT 4
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 3
94337: PUSH
94338: LD_INT 4
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 5
94347: PUSH
94348: LD_INT 4
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 5
94357: PUSH
94358: LD_INT 5
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 4
94367: PUSH
94368: LD_INT 5
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 6
94377: PUSH
94378: LD_INT 5
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 6
94387: PUSH
94388: LD_INT 6
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 5
94397: PUSH
94398: LD_INT 6
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94419: LD_ADDR_VAR 0 32
94423: PUSH
94424: LD_INT 1
94426: PUSH
94427: LD_INT 3
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 0
94436: PUSH
94437: LD_INT 3
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 1
94446: NEG
94447: PUSH
94448: LD_INT 2
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 1
94457: PUSH
94458: LD_INT 4
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 0
94467: PUSH
94468: LD_INT 4
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 1
94477: NEG
94478: PUSH
94479: LD_INT 3
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: PUSH
94489: LD_INT 5
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 0
94498: PUSH
94499: LD_INT 5
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 1
94508: NEG
94509: PUSH
94510: LD_INT 4
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 1
94519: PUSH
94520: LD_INT 6
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: LD_INT 0
94529: PUSH
94530: LD_INT 6
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 1
94539: NEG
94540: PUSH
94541: LD_INT 5
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94562: LD_ADDR_VAR 0 33
94566: PUSH
94567: LD_INT 2
94569: NEG
94570: PUSH
94571: LD_INT 1
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 3
94580: NEG
94581: PUSH
94582: LD_INT 0
94584: PUSH
94585: EMPTY
94586: LIST
94587: LIST
94588: PUSH
94589: LD_INT 3
94591: NEG
94592: PUSH
94593: LD_INT 1
94595: NEG
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 3
94603: NEG
94604: PUSH
94605: LD_INT 1
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 4
94614: NEG
94615: PUSH
94616: LD_INT 0
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: LD_INT 1
94629: NEG
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: LD_INT 1
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 5
94648: NEG
94649: PUSH
94650: LD_INT 0
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: PUSH
94657: LD_INT 5
94659: NEG
94660: PUSH
94661: LD_INT 1
94663: NEG
94664: PUSH
94665: EMPTY
94666: LIST
94667: LIST
94668: PUSH
94669: LD_INT 5
94671: NEG
94672: PUSH
94673: LD_INT 1
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: LD_INT 6
94682: NEG
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 6
94693: NEG
94694: PUSH
94695: LD_INT 1
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94717: LD_ADDR_VAR 0 34
94721: PUSH
94722: LD_INT 2
94724: NEG
94725: PUSH
94726: LD_INT 3
94728: NEG
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 3
94736: NEG
94737: PUSH
94738: LD_INT 2
94740: NEG
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 3
94748: NEG
94749: PUSH
94750: LD_INT 3
94752: NEG
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 3
94760: NEG
94761: PUSH
94762: LD_INT 4
94764: NEG
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 4
94772: NEG
94773: PUSH
94774: LD_INT 3
94776: NEG
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 4
94784: NEG
94785: PUSH
94786: LD_INT 4
94788: NEG
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 4
94796: NEG
94797: PUSH
94798: LD_INT 5
94800: NEG
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: LD_INT 5
94808: NEG
94809: PUSH
94810: LD_INT 4
94812: NEG
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 5
94820: NEG
94821: PUSH
94822: LD_INT 5
94824: NEG
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 5
94832: NEG
94833: PUSH
94834: LD_INT 6
94836: NEG
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 6
94844: NEG
94845: PUSH
94846: LD_INT 5
94848: NEG
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 6
94856: NEG
94857: PUSH
94858: LD_INT 6
94860: NEG
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94880: LD_ADDR_VAR 0 41
94884: PUSH
94885: LD_INT 0
94887: PUSH
94888: LD_INT 2
94890: NEG
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 1
94898: NEG
94899: PUSH
94900: LD_INT 3
94902: NEG
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: LD_INT 1
94910: PUSH
94911: LD_INT 2
94913: NEG
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: LIST
94923: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94924: LD_ADDR_VAR 0 42
94928: PUSH
94929: LD_INT 2
94931: PUSH
94932: LD_INT 0
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 2
94941: PUSH
94942: LD_INT 1
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 3
94952: PUSH
94953: LD_INT 1
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: LIST
94964: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94965: LD_ADDR_VAR 0 43
94969: PUSH
94970: LD_INT 2
94972: PUSH
94973: LD_INT 2
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 3
94982: PUSH
94983: LD_INT 2
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 2
94992: PUSH
94993: LD_INT 3
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: LIST
95004: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95005: LD_ADDR_VAR 0 44
95009: PUSH
95010: LD_INT 0
95012: PUSH
95013: LD_INT 2
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: LD_INT 1
95022: PUSH
95023: LD_INT 3
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: LD_INT 1
95032: NEG
95033: PUSH
95034: LD_INT 2
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: LIST
95045: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95046: LD_ADDR_VAR 0 45
95050: PUSH
95051: LD_INT 2
95053: NEG
95054: PUSH
95055: LD_INT 0
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 2
95064: NEG
95065: PUSH
95066: LD_INT 1
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 3
95075: NEG
95076: PUSH
95077: LD_INT 1
95079: NEG
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: LIST
95089: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95090: LD_ADDR_VAR 0 46
95094: PUSH
95095: LD_INT 2
95097: NEG
95098: PUSH
95099: LD_INT 2
95101: NEG
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_INT 2
95109: NEG
95110: PUSH
95111: LD_INT 3
95113: NEG
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 3
95121: NEG
95122: PUSH
95123: LD_INT 2
95125: NEG
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: LIST
95135: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95136: LD_ADDR_VAR 0 47
95140: PUSH
95141: LD_INT 2
95143: NEG
95144: PUSH
95145: LD_INT 3
95147: NEG
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 1
95155: NEG
95156: PUSH
95157: LD_INT 3
95159: NEG
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95169: LD_ADDR_VAR 0 48
95173: PUSH
95174: LD_INT 1
95176: PUSH
95177: LD_INT 2
95179: NEG
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 2
95187: PUSH
95188: LD_INT 1
95190: NEG
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95200: LD_ADDR_VAR 0 49
95204: PUSH
95205: LD_INT 3
95207: PUSH
95208: LD_INT 1
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 3
95217: PUSH
95218: LD_INT 2
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95229: LD_ADDR_VAR 0 50
95233: PUSH
95234: LD_INT 2
95236: PUSH
95237: LD_INT 3
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 1
95246: PUSH
95247: LD_INT 3
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95258: LD_ADDR_VAR 0 51
95262: PUSH
95263: LD_INT 1
95265: NEG
95266: PUSH
95267: LD_INT 2
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 2
95276: NEG
95277: PUSH
95278: LD_INT 1
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95289: LD_ADDR_VAR 0 52
95293: PUSH
95294: LD_INT 3
95296: NEG
95297: PUSH
95298: LD_INT 1
95300: NEG
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: PUSH
95306: LD_INT 3
95308: NEG
95309: PUSH
95310: LD_INT 2
95312: NEG
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95322: LD_ADDR_VAR 0 53
95326: PUSH
95327: LD_INT 1
95329: NEG
95330: PUSH
95331: LD_INT 3
95333: NEG
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: PUSH
95339: LD_INT 0
95341: PUSH
95342: LD_INT 3
95344: NEG
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 1
95352: PUSH
95353: LD_INT 2
95355: NEG
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: LIST
95365: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95366: LD_ADDR_VAR 0 54
95370: PUSH
95371: LD_INT 2
95373: PUSH
95374: LD_INT 1
95376: NEG
95377: PUSH
95378: EMPTY
95379: LIST
95380: LIST
95381: PUSH
95382: LD_INT 3
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 3
95394: PUSH
95395: LD_INT 1
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: LIST
95406: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95407: LD_ADDR_VAR 0 55
95411: PUSH
95412: LD_INT 3
95414: PUSH
95415: LD_INT 2
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 3
95424: PUSH
95425: LD_INT 3
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: LD_INT 2
95434: PUSH
95435: LD_INT 3
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: EMPTY
95443: LIST
95444: LIST
95445: LIST
95446: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95447: LD_ADDR_VAR 0 56
95451: PUSH
95452: LD_INT 1
95454: PUSH
95455: LD_INT 3
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 0
95464: PUSH
95465: LD_INT 3
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 1
95474: NEG
95475: PUSH
95476: LD_INT 2
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: LIST
95487: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95488: LD_ADDR_VAR 0 57
95492: PUSH
95493: LD_INT 2
95495: NEG
95496: PUSH
95497: LD_INT 1
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 3
95506: NEG
95507: PUSH
95508: LD_INT 0
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 3
95517: NEG
95518: PUSH
95519: LD_INT 1
95521: NEG
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: LIST
95531: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95532: LD_ADDR_VAR 0 58
95536: PUSH
95537: LD_INT 2
95539: NEG
95540: PUSH
95541: LD_INT 3
95543: NEG
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 3
95551: NEG
95552: PUSH
95553: LD_INT 2
95555: NEG
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 3
95563: NEG
95564: PUSH
95565: LD_INT 3
95567: NEG
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: LIST
95577: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95578: LD_ADDR_VAR 0 59
95582: PUSH
95583: LD_INT 1
95585: NEG
95586: PUSH
95587: LD_INT 2
95589: NEG
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 0
95597: PUSH
95598: LD_INT 2
95600: NEG
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: PUSH
95606: LD_INT 1
95608: PUSH
95609: LD_INT 1
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: LIST
95621: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95622: LD_ADDR_VAR 0 60
95626: PUSH
95627: LD_INT 1
95629: PUSH
95630: LD_INT 1
95632: NEG
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 2
95640: PUSH
95641: LD_INT 0
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 2
95650: PUSH
95651: LD_INT 1
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: EMPTY
95659: LIST
95660: LIST
95661: LIST
95662: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95663: LD_ADDR_VAR 0 61
95667: PUSH
95668: LD_INT 2
95670: PUSH
95671: LD_INT 1
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 2
95680: PUSH
95681: LD_INT 2
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 1
95690: PUSH
95691: LD_INT 2
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: LIST
95702: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95703: LD_ADDR_VAR 0 62
95707: PUSH
95708: LD_INT 1
95710: PUSH
95711: LD_INT 2
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 0
95720: PUSH
95721: LD_INT 2
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: PUSH
95728: LD_INT 1
95730: NEG
95731: PUSH
95732: LD_INT 1
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: EMPTY
95740: LIST
95741: LIST
95742: LIST
95743: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95744: LD_ADDR_VAR 0 63
95748: PUSH
95749: LD_INT 1
95751: NEG
95752: PUSH
95753: LD_INT 1
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: PUSH
95760: LD_INT 2
95762: NEG
95763: PUSH
95764: LD_INT 0
95766: PUSH
95767: EMPTY
95768: LIST
95769: LIST
95770: PUSH
95771: LD_INT 2
95773: NEG
95774: PUSH
95775: LD_INT 1
95777: NEG
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: LIST
95787: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95788: LD_ADDR_VAR 0 64
95792: PUSH
95793: LD_INT 1
95795: NEG
95796: PUSH
95797: LD_INT 2
95799: NEG
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 2
95807: NEG
95808: PUSH
95809: LD_INT 1
95811: NEG
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 2
95819: NEG
95820: PUSH
95821: LD_INT 2
95823: NEG
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: LIST
95833: ST_TO_ADDR
// end ; 2 :
95834: GO 99100
95836: LD_INT 2
95838: DOUBLE
95839: EQUAL
95840: IFTRUE 95844
95842: GO 99099
95844: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95845: LD_ADDR_VAR 0 29
95849: PUSH
95850: LD_INT 4
95852: PUSH
95853: LD_INT 0
95855: PUSH
95856: EMPTY
95857: LIST
95858: LIST
95859: PUSH
95860: LD_INT 4
95862: PUSH
95863: LD_INT 1
95865: NEG
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 5
95873: PUSH
95874: LD_INT 0
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 5
95883: PUSH
95884: LD_INT 1
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 4
95893: PUSH
95894: LD_INT 1
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: LD_INT 3
95903: PUSH
95904: LD_INT 0
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 3
95913: PUSH
95914: LD_INT 1
95916: NEG
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 3
95924: PUSH
95925: LD_INT 2
95927: NEG
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 5
95935: PUSH
95936: LD_INT 2
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 3
95945: PUSH
95946: LD_INT 3
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 3
95955: PUSH
95956: LD_INT 2
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 4
95965: PUSH
95966: LD_INT 3
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PUSH
95973: LD_INT 4
95975: PUSH
95976: LD_INT 4
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 3
95985: PUSH
95986: LD_INT 4
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 2
95995: PUSH
95996: LD_INT 3
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: LD_INT 2
96005: PUSH
96006: LD_INT 2
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 4
96015: PUSH
96016: LD_INT 2
96018: PUSH
96019: EMPTY
96020: LIST
96021: LIST
96022: PUSH
96023: LD_INT 2
96025: PUSH
96026: LD_INT 4
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: PUSH
96033: LD_INT 0
96035: PUSH
96036: LD_INT 4
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: PUSH
96043: LD_INT 0
96045: PUSH
96046: LD_INT 3
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 1
96055: PUSH
96056: LD_INT 4
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: LD_INT 1
96065: PUSH
96066: LD_INT 5
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 0
96075: PUSH
96076: LD_INT 5
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 1
96085: NEG
96086: PUSH
96087: LD_INT 4
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 1
96096: NEG
96097: PUSH
96098: LD_INT 3
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: LD_INT 2
96107: PUSH
96108: LD_INT 5
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 2
96117: NEG
96118: PUSH
96119: LD_INT 3
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PUSH
96126: LD_INT 3
96128: NEG
96129: PUSH
96130: LD_INT 0
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: PUSH
96137: LD_INT 3
96139: NEG
96140: PUSH
96141: LD_INT 1
96143: NEG
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: PUSH
96149: LD_INT 2
96151: NEG
96152: PUSH
96153: LD_INT 0
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 2
96162: NEG
96163: PUSH
96164: LD_INT 1
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: PUSH
96171: LD_INT 3
96173: NEG
96174: PUSH
96175: LD_INT 1
96177: PUSH
96178: EMPTY
96179: LIST
96180: LIST
96181: PUSH
96182: LD_INT 4
96184: NEG
96185: PUSH
96186: LD_INT 0
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 4
96195: NEG
96196: PUSH
96197: LD_INT 1
96199: NEG
96200: PUSH
96201: EMPTY
96202: LIST
96203: LIST
96204: PUSH
96205: LD_INT 4
96207: NEG
96208: PUSH
96209: LD_INT 2
96211: NEG
96212: PUSH
96213: EMPTY
96214: LIST
96215: LIST
96216: PUSH
96217: LD_INT 2
96219: NEG
96220: PUSH
96221: LD_INT 2
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 4
96230: NEG
96231: PUSH
96232: LD_INT 4
96234: NEG
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 4
96242: NEG
96243: PUSH
96244: LD_INT 5
96246: NEG
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 3
96254: NEG
96255: PUSH
96256: LD_INT 4
96258: NEG
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 3
96266: NEG
96267: PUSH
96268: LD_INT 3
96270: NEG
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 4
96278: NEG
96279: PUSH
96280: LD_INT 3
96282: NEG
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PUSH
96288: LD_INT 5
96290: NEG
96291: PUSH
96292: LD_INT 4
96294: NEG
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: PUSH
96300: LD_INT 5
96302: NEG
96303: PUSH
96304: LD_INT 5
96306: NEG
96307: PUSH
96308: EMPTY
96309: LIST
96310: LIST
96311: PUSH
96312: LD_INT 3
96314: NEG
96315: PUSH
96316: LD_INT 5
96318: NEG
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 5
96326: NEG
96327: PUSH
96328: LD_INT 3
96330: NEG
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96383: LD_ADDR_VAR 0 30
96387: PUSH
96388: LD_INT 4
96390: PUSH
96391: LD_INT 4
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 4
96400: PUSH
96401: LD_INT 3
96403: PUSH
96404: EMPTY
96405: LIST
96406: LIST
96407: PUSH
96408: LD_INT 5
96410: PUSH
96411: LD_INT 4
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: LD_INT 5
96420: PUSH
96421: LD_INT 5
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 4
96430: PUSH
96431: LD_INT 5
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 3
96440: PUSH
96441: LD_INT 4
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 3
96450: PUSH
96451: LD_INT 3
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 5
96460: PUSH
96461: LD_INT 3
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 3
96470: PUSH
96471: LD_INT 5
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: LD_INT 0
96480: PUSH
96481: LD_INT 3
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: LD_INT 0
96490: PUSH
96491: LD_INT 2
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 1
96500: PUSH
96501: LD_INT 3
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: PUSH
96508: LD_INT 1
96510: PUSH
96511: LD_INT 4
96513: PUSH
96514: EMPTY
96515: LIST
96516: LIST
96517: PUSH
96518: LD_INT 0
96520: PUSH
96521: LD_INT 4
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 1
96530: NEG
96531: PUSH
96532: LD_INT 3
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: LD_INT 2
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 2
96552: PUSH
96553: LD_INT 4
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 2
96562: NEG
96563: PUSH
96564: LD_INT 2
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: LD_INT 4
96573: NEG
96574: PUSH
96575: LD_INT 0
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 4
96584: NEG
96585: PUSH
96586: LD_INT 1
96588: NEG
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 3
96596: NEG
96597: PUSH
96598: LD_INT 0
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 3
96607: NEG
96608: PUSH
96609: LD_INT 1
96611: PUSH
96612: EMPTY
96613: LIST
96614: LIST
96615: PUSH
96616: LD_INT 4
96618: NEG
96619: PUSH
96620: LD_INT 1
96622: PUSH
96623: EMPTY
96624: LIST
96625: LIST
96626: PUSH
96627: LD_INT 5
96629: NEG
96630: PUSH
96631: LD_INT 0
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 5
96640: NEG
96641: PUSH
96642: LD_INT 1
96644: NEG
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: LD_INT 5
96652: NEG
96653: PUSH
96654: LD_INT 2
96656: NEG
96657: PUSH
96658: EMPTY
96659: LIST
96660: LIST
96661: PUSH
96662: LD_INT 3
96664: NEG
96665: PUSH
96666: LD_INT 2
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 3
96675: NEG
96676: PUSH
96677: LD_INT 3
96679: NEG
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: PUSH
96685: LD_INT 3
96687: NEG
96688: PUSH
96689: LD_INT 4
96691: NEG
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 2
96699: NEG
96700: PUSH
96701: LD_INT 3
96703: NEG
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 2
96711: NEG
96712: PUSH
96713: LD_INT 2
96715: NEG
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 3
96723: NEG
96724: PUSH
96725: LD_INT 2
96727: NEG
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 4
96735: NEG
96736: PUSH
96737: LD_INT 3
96739: NEG
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 4
96747: NEG
96748: PUSH
96749: LD_INT 4
96751: NEG
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: PUSH
96757: LD_INT 2
96759: NEG
96760: PUSH
96761: LD_INT 4
96763: NEG
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 4
96771: NEG
96772: PUSH
96773: LD_INT 2
96775: NEG
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 0
96783: PUSH
96784: LD_INT 4
96786: NEG
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 0
96794: PUSH
96795: LD_INT 5
96797: NEG
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 1
96805: PUSH
96806: LD_INT 4
96808: NEG
96809: PUSH
96810: EMPTY
96811: LIST
96812: LIST
96813: PUSH
96814: LD_INT 1
96816: PUSH
96817: LD_INT 3
96819: NEG
96820: PUSH
96821: EMPTY
96822: LIST
96823: LIST
96824: PUSH
96825: LD_INT 0
96827: PUSH
96828: LD_INT 3
96830: NEG
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 1
96838: NEG
96839: PUSH
96840: LD_INT 4
96842: NEG
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 1
96850: NEG
96851: PUSH
96852: LD_INT 5
96854: NEG
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: PUSH
96860: LD_INT 2
96862: PUSH
96863: LD_INT 3
96865: NEG
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 2
96873: NEG
96874: PUSH
96875: LD_INT 5
96877: NEG
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96930: LD_ADDR_VAR 0 31
96934: PUSH
96935: LD_INT 0
96937: PUSH
96938: LD_INT 4
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 0
96947: PUSH
96948: LD_INT 3
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 1
96957: PUSH
96958: LD_INT 4
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 1
96967: PUSH
96968: LD_INT 5
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 0
96977: PUSH
96978: LD_INT 5
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: PUSH
96985: LD_INT 1
96987: NEG
96988: PUSH
96989: LD_INT 4
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 1
96998: NEG
96999: PUSH
97000: LD_INT 3
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 2
97009: PUSH
97010: LD_INT 5
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 2
97019: NEG
97020: PUSH
97021: LD_INT 3
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 3
97030: NEG
97031: PUSH
97032: LD_INT 0
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: PUSH
97039: LD_INT 3
97041: NEG
97042: PUSH
97043: LD_INT 1
97045: NEG
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 2
97053: NEG
97054: PUSH
97055: LD_INT 0
97057: PUSH
97058: EMPTY
97059: LIST
97060: LIST
97061: PUSH
97062: LD_INT 2
97064: NEG
97065: PUSH
97066: LD_INT 1
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 3
97075: NEG
97076: PUSH
97077: LD_INT 1
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 4
97086: NEG
97087: PUSH
97088: LD_INT 0
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 4
97097: NEG
97098: PUSH
97099: LD_INT 1
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 4
97109: NEG
97110: PUSH
97111: LD_INT 2
97113: NEG
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 2
97121: NEG
97122: PUSH
97123: LD_INT 2
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: LD_INT 4
97132: NEG
97133: PUSH
97134: LD_INT 4
97136: NEG
97137: PUSH
97138: EMPTY
97139: LIST
97140: LIST
97141: PUSH
97142: LD_INT 4
97144: NEG
97145: PUSH
97146: LD_INT 5
97148: NEG
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PUSH
97154: LD_INT 3
97156: NEG
97157: PUSH
97158: LD_INT 4
97160: NEG
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: LD_INT 3
97168: NEG
97169: PUSH
97170: LD_INT 3
97172: NEG
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_INT 4
97180: NEG
97181: PUSH
97182: LD_INT 3
97184: NEG
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: PUSH
97190: LD_INT 5
97192: NEG
97193: PUSH
97194: LD_INT 4
97196: NEG
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 5
97204: NEG
97205: PUSH
97206: LD_INT 5
97208: NEG
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 3
97216: NEG
97217: PUSH
97218: LD_INT 5
97220: NEG
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 5
97228: NEG
97229: PUSH
97230: LD_INT 3
97232: NEG
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 0
97240: PUSH
97241: LD_INT 3
97243: NEG
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: LD_INT 0
97251: PUSH
97252: LD_INT 4
97254: NEG
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PUSH
97260: LD_INT 1
97262: PUSH
97263: LD_INT 3
97265: NEG
97266: PUSH
97267: EMPTY
97268: LIST
97269: LIST
97270: PUSH
97271: LD_INT 1
97273: PUSH
97274: LD_INT 2
97276: NEG
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PUSH
97282: LD_INT 0
97284: PUSH
97285: LD_INT 2
97287: NEG
97288: PUSH
97289: EMPTY
97290: LIST
97291: LIST
97292: PUSH
97293: LD_INT 1
97295: NEG
97296: PUSH
97297: LD_INT 3
97299: NEG
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: PUSH
97305: LD_INT 1
97307: NEG
97308: PUSH
97309: LD_INT 4
97311: NEG
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 2
97319: PUSH
97320: LD_INT 2
97322: NEG
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 2
97330: NEG
97331: PUSH
97332: LD_INT 4
97334: NEG
97335: PUSH
97336: EMPTY
97337: LIST
97338: LIST
97339: PUSH
97340: LD_INT 4
97342: PUSH
97343: LD_INT 0
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: LD_INT 4
97352: PUSH
97353: LD_INT 1
97355: NEG
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 5
97363: PUSH
97364: LD_INT 0
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: PUSH
97371: LD_INT 5
97373: PUSH
97374: LD_INT 1
97376: PUSH
97377: EMPTY
97378: LIST
97379: LIST
97380: PUSH
97381: LD_INT 4
97383: PUSH
97384: LD_INT 1
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: PUSH
97391: LD_INT 3
97393: PUSH
97394: LD_INT 0
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PUSH
97401: LD_INT 3
97403: PUSH
97404: LD_INT 1
97406: NEG
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_INT 3
97414: PUSH
97415: LD_INT 2
97417: NEG
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PUSH
97423: LD_INT 5
97425: PUSH
97426: LD_INT 2
97428: PUSH
97429: EMPTY
97430: LIST
97431: LIST
97432: PUSH
97433: EMPTY
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97480: LD_ADDR_VAR 0 32
97484: PUSH
97485: LD_INT 4
97487: NEG
97488: PUSH
97489: LD_INT 0
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: PUSH
97496: LD_INT 4
97498: NEG
97499: PUSH
97500: LD_INT 1
97502: NEG
97503: PUSH
97504: EMPTY
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 3
97510: NEG
97511: PUSH
97512: LD_INT 0
97514: PUSH
97515: EMPTY
97516: LIST
97517: LIST
97518: PUSH
97519: LD_INT 3
97521: NEG
97522: PUSH
97523: LD_INT 1
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: LD_INT 4
97532: NEG
97533: PUSH
97534: LD_INT 1
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 5
97543: NEG
97544: PUSH
97545: LD_INT 0
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 5
97554: NEG
97555: PUSH
97556: LD_INT 1
97558: NEG
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 5
97566: NEG
97567: PUSH
97568: LD_INT 2
97570: NEG
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PUSH
97576: LD_INT 3
97578: NEG
97579: PUSH
97580: LD_INT 2
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: LD_INT 3
97589: NEG
97590: PUSH
97591: LD_INT 3
97593: NEG
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 3
97601: NEG
97602: PUSH
97603: LD_INT 4
97605: NEG
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 2
97613: NEG
97614: PUSH
97615: LD_INT 3
97617: NEG
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 2
97625: NEG
97626: PUSH
97627: LD_INT 2
97629: NEG
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: PUSH
97635: LD_INT 3
97637: NEG
97638: PUSH
97639: LD_INT 2
97641: NEG
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: PUSH
97647: LD_INT 4
97649: NEG
97650: PUSH
97651: LD_INT 3
97653: NEG
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: PUSH
97659: LD_INT 4
97661: NEG
97662: PUSH
97663: LD_INT 4
97665: NEG
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 2
97673: NEG
97674: PUSH
97675: LD_INT 4
97677: NEG
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: PUSH
97683: LD_INT 4
97685: NEG
97686: PUSH
97687: LD_INT 2
97689: NEG
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 0
97697: PUSH
97698: LD_INT 4
97700: NEG
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: LD_INT 0
97708: PUSH
97709: LD_INT 5
97711: NEG
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: PUSH
97717: LD_INT 1
97719: PUSH
97720: LD_INT 4
97722: NEG
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 1
97730: PUSH
97731: LD_INT 3
97733: NEG
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: LD_INT 0
97741: PUSH
97742: LD_INT 3
97744: NEG
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: PUSH
97750: LD_INT 1
97752: NEG
97753: PUSH
97754: LD_INT 4
97756: NEG
97757: PUSH
97758: EMPTY
97759: LIST
97760: LIST
97761: PUSH
97762: LD_INT 1
97764: NEG
97765: PUSH
97766: LD_INT 5
97768: NEG
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PUSH
97774: LD_INT 2
97776: PUSH
97777: LD_INT 3
97779: NEG
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: PUSH
97785: LD_INT 2
97787: NEG
97788: PUSH
97789: LD_INT 5
97791: NEG
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 3
97799: PUSH
97800: LD_INT 0
97802: PUSH
97803: EMPTY
97804: LIST
97805: LIST
97806: PUSH
97807: LD_INT 3
97809: PUSH
97810: LD_INT 1
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 4
97820: PUSH
97821: LD_INT 0
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: PUSH
97828: LD_INT 4
97830: PUSH
97831: LD_INT 1
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: PUSH
97838: LD_INT 3
97840: PUSH
97841: LD_INT 1
97843: PUSH
97844: EMPTY
97845: LIST
97846: LIST
97847: PUSH
97848: LD_INT 2
97850: PUSH
97851: LD_INT 0
97853: PUSH
97854: EMPTY
97855: LIST
97856: LIST
97857: PUSH
97858: LD_INT 2
97860: PUSH
97861: LD_INT 1
97863: NEG
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PUSH
97869: LD_INT 2
97871: PUSH
97872: LD_INT 2
97874: NEG
97875: PUSH
97876: EMPTY
97877: LIST
97878: LIST
97879: PUSH
97880: LD_INT 4
97882: PUSH
97883: LD_INT 2
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 4
97892: PUSH
97893: LD_INT 4
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PUSH
97900: LD_INT 4
97902: PUSH
97903: LD_INT 3
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 5
97912: PUSH
97913: LD_INT 4
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PUSH
97920: LD_INT 5
97922: PUSH
97923: LD_INT 5
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 4
97932: PUSH
97933: LD_INT 5
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: PUSH
97940: LD_INT 3
97942: PUSH
97943: LD_INT 4
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 3
97952: PUSH
97953: LD_INT 3
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: PUSH
97960: LD_INT 5
97962: PUSH
97963: LD_INT 3
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: PUSH
97970: LD_INT 3
97972: PUSH
97973: LD_INT 5
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: LIST
97998: LIST
97999: LIST
98000: LIST
98001: LIST
98002: LIST
98003: LIST
98004: LIST
98005: LIST
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98027: LD_ADDR_VAR 0 33
98031: PUSH
98032: LD_INT 4
98034: NEG
98035: PUSH
98036: LD_INT 4
98038: NEG
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: LD_INT 4
98046: NEG
98047: PUSH
98048: LD_INT 5
98050: NEG
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 3
98058: NEG
98059: PUSH
98060: LD_INT 4
98062: NEG
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: PUSH
98068: LD_INT 3
98070: NEG
98071: PUSH
98072: LD_INT 3
98074: NEG
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: PUSH
98080: LD_INT 4
98082: NEG
98083: PUSH
98084: LD_INT 3
98086: NEG
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 5
98094: NEG
98095: PUSH
98096: LD_INT 4
98098: NEG
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_INT 5
98106: NEG
98107: PUSH
98108: LD_INT 5
98110: NEG
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 3
98118: NEG
98119: PUSH
98120: LD_INT 5
98122: NEG
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 5
98130: NEG
98131: PUSH
98132: LD_INT 3
98134: NEG
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 0
98142: PUSH
98143: LD_INT 3
98145: NEG
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 0
98153: PUSH
98154: LD_INT 4
98156: NEG
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: LD_INT 1
98164: PUSH
98165: LD_INT 3
98167: NEG
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: LD_INT 1
98175: PUSH
98176: LD_INT 2
98178: NEG
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: LD_INT 0
98186: PUSH
98187: LD_INT 2
98189: NEG
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 1
98197: NEG
98198: PUSH
98199: LD_INT 3
98201: NEG
98202: PUSH
98203: EMPTY
98204: LIST
98205: LIST
98206: PUSH
98207: LD_INT 1
98209: NEG
98210: PUSH
98211: LD_INT 4
98213: NEG
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: LD_INT 2
98221: PUSH
98222: LD_INT 2
98224: NEG
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: LD_INT 2
98232: NEG
98233: PUSH
98234: LD_INT 4
98236: NEG
98237: PUSH
98238: EMPTY
98239: LIST
98240: LIST
98241: PUSH
98242: LD_INT 4
98244: PUSH
98245: LD_INT 0
98247: PUSH
98248: EMPTY
98249: LIST
98250: LIST
98251: PUSH
98252: LD_INT 4
98254: PUSH
98255: LD_INT 1
98257: NEG
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: PUSH
98263: LD_INT 5
98265: PUSH
98266: LD_INT 0
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PUSH
98273: LD_INT 5
98275: PUSH
98276: LD_INT 1
98278: PUSH
98279: EMPTY
98280: LIST
98281: LIST
98282: PUSH
98283: LD_INT 4
98285: PUSH
98286: LD_INT 1
98288: PUSH
98289: EMPTY
98290: LIST
98291: LIST
98292: PUSH
98293: LD_INT 3
98295: PUSH
98296: LD_INT 0
98298: PUSH
98299: EMPTY
98300: LIST
98301: LIST
98302: PUSH
98303: LD_INT 3
98305: PUSH
98306: LD_INT 1
98308: NEG
98309: PUSH
98310: EMPTY
98311: LIST
98312: LIST
98313: PUSH
98314: LD_INT 3
98316: PUSH
98317: LD_INT 2
98319: NEG
98320: PUSH
98321: EMPTY
98322: LIST
98323: LIST
98324: PUSH
98325: LD_INT 5
98327: PUSH
98328: LD_INT 2
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 3
98337: PUSH
98338: LD_INT 3
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: PUSH
98345: LD_INT 3
98347: PUSH
98348: LD_INT 2
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: PUSH
98355: LD_INT 4
98357: PUSH
98358: LD_INT 3
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PUSH
98365: LD_INT 4
98367: PUSH
98368: LD_INT 4
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: PUSH
98375: LD_INT 3
98377: PUSH
98378: LD_INT 4
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: PUSH
98385: LD_INT 2
98387: PUSH
98388: LD_INT 3
98390: PUSH
98391: EMPTY
98392: LIST
98393: LIST
98394: PUSH
98395: LD_INT 2
98397: PUSH
98398: LD_INT 2
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: PUSH
98405: LD_INT 4
98407: PUSH
98408: LD_INT 2
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: PUSH
98415: LD_INT 2
98417: PUSH
98418: LD_INT 4
98420: PUSH
98421: EMPTY
98422: LIST
98423: LIST
98424: PUSH
98425: LD_INT 0
98427: PUSH
98428: LD_INT 4
98430: PUSH
98431: EMPTY
98432: LIST
98433: LIST
98434: PUSH
98435: LD_INT 0
98437: PUSH
98438: LD_INT 3
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: PUSH
98445: LD_INT 1
98447: PUSH
98448: LD_INT 4
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: PUSH
98455: LD_INT 1
98457: PUSH
98458: LD_INT 5
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: PUSH
98465: LD_INT 0
98467: PUSH
98468: LD_INT 5
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: PUSH
98475: LD_INT 1
98477: NEG
98478: PUSH
98479: LD_INT 4
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: LD_INT 1
98488: NEG
98489: PUSH
98490: LD_INT 3
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 2
98499: PUSH
98500: LD_INT 5
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: PUSH
98507: LD_INT 2
98509: NEG
98510: PUSH
98511: LD_INT 3
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: PUSH
98518: EMPTY
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98565: LD_ADDR_VAR 0 34
98569: PUSH
98570: LD_INT 0
98572: PUSH
98573: LD_INT 4
98575: NEG
98576: PUSH
98577: EMPTY
98578: LIST
98579: LIST
98580: PUSH
98581: LD_INT 0
98583: PUSH
98584: LD_INT 5
98586: NEG
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 1
98594: PUSH
98595: LD_INT 4
98597: NEG
98598: PUSH
98599: EMPTY
98600: LIST
98601: LIST
98602: PUSH
98603: LD_INT 1
98605: PUSH
98606: LD_INT 3
98608: NEG
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: LD_INT 0
98616: PUSH
98617: LD_INT 3
98619: NEG
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PUSH
98625: LD_INT 1
98627: NEG
98628: PUSH
98629: LD_INT 4
98631: NEG
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_INT 1
98639: NEG
98640: PUSH
98641: LD_INT 5
98643: NEG
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: PUSH
98649: LD_INT 2
98651: PUSH
98652: LD_INT 3
98654: NEG
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: PUSH
98660: LD_INT 2
98662: NEG
98663: PUSH
98664: LD_INT 5
98666: NEG
98667: PUSH
98668: EMPTY
98669: LIST
98670: LIST
98671: PUSH
98672: LD_INT 3
98674: PUSH
98675: LD_INT 0
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: LD_INT 3
98684: PUSH
98685: LD_INT 1
98687: NEG
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: PUSH
98693: LD_INT 4
98695: PUSH
98696: LD_INT 0
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: PUSH
98703: LD_INT 4
98705: PUSH
98706: LD_INT 1
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: PUSH
98713: LD_INT 3
98715: PUSH
98716: LD_INT 1
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: LD_INT 2
98725: PUSH
98726: LD_INT 0
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: LD_INT 2
98735: PUSH
98736: LD_INT 1
98738: NEG
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: PUSH
98744: LD_INT 2
98746: PUSH
98747: LD_INT 2
98749: NEG
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: LD_INT 4
98757: PUSH
98758: LD_INT 2
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 4
98767: PUSH
98768: LD_INT 4
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PUSH
98775: LD_INT 4
98777: PUSH
98778: LD_INT 3
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: PUSH
98785: LD_INT 5
98787: PUSH
98788: LD_INT 4
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 5
98797: PUSH
98798: LD_INT 5
98800: PUSH
98801: EMPTY
98802: LIST
98803: LIST
98804: PUSH
98805: LD_INT 4
98807: PUSH
98808: LD_INT 5
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 3
98817: PUSH
98818: LD_INT 4
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 3
98827: PUSH
98828: LD_INT 3
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 5
98837: PUSH
98838: LD_INT 3
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: LD_INT 3
98847: PUSH
98848: LD_INT 5
98850: PUSH
98851: EMPTY
98852: LIST
98853: LIST
98854: PUSH
98855: LD_INT 0
98857: PUSH
98858: LD_INT 3
98860: PUSH
98861: EMPTY
98862: LIST
98863: LIST
98864: PUSH
98865: LD_INT 0
98867: PUSH
98868: LD_INT 2
98870: PUSH
98871: EMPTY
98872: LIST
98873: LIST
98874: PUSH
98875: LD_INT 1
98877: PUSH
98878: LD_INT 3
98880: PUSH
98881: EMPTY
98882: LIST
98883: LIST
98884: PUSH
98885: LD_INT 1
98887: PUSH
98888: LD_INT 4
98890: PUSH
98891: EMPTY
98892: LIST
98893: LIST
98894: PUSH
98895: LD_INT 0
98897: PUSH
98898: LD_INT 4
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: LD_INT 1
98907: NEG
98908: PUSH
98909: LD_INT 3
98911: PUSH
98912: EMPTY
98913: LIST
98914: LIST
98915: PUSH
98916: LD_INT 1
98918: NEG
98919: PUSH
98920: LD_INT 2
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: PUSH
98927: LD_INT 2
98929: PUSH
98930: LD_INT 4
98932: PUSH
98933: EMPTY
98934: LIST
98935: LIST
98936: PUSH
98937: LD_INT 2
98939: NEG
98940: PUSH
98941: LD_INT 2
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: PUSH
98948: LD_INT 4
98950: NEG
98951: PUSH
98952: LD_INT 0
98954: PUSH
98955: EMPTY
98956: LIST
98957: LIST
98958: PUSH
98959: LD_INT 4
98961: NEG
98962: PUSH
98963: LD_INT 1
98965: NEG
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: LD_INT 3
98973: NEG
98974: PUSH
98975: LD_INT 0
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: LD_INT 3
98984: NEG
98985: PUSH
98986: LD_INT 1
98988: PUSH
98989: EMPTY
98990: LIST
98991: LIST
98992: PUSH
98993: LD_INT 4
98995: NEG
98996: PUSH
98997: LD_INT 1
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: PUSH
99004: LD_INT 5
99006: NEG
99007: PUSH
99008: LD_INT 0
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: LD_INT 5
99017: NEG
99018: PUSH
99019: LD_INT 1
99021: NEG
99022: PUSH
99023: EMPTY
99024: LIST
99025: LIST
99026: PUSH
99027: LD_INT 5
99029: NEG
99030: PUSH
99031: LD_INT 2
99033: NEG
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: PUSH
99039: LD_INT 3
99041: NEG
99042: PUSH
99043: LD_INT 2
99045: PUSH
99046: EMPTY
99047: LIST
99048: LIST
99049: PUSH
99050: EMPTY
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: ST_TO_ADDR
// end ; end ;
99097: GO 99100
99099: POP
// case btype of b_depot , b_warehouse :
99100: LD_VAR 0 1
99104: PUSH
99105: LD_INT 0
99107: DOUBLE
99108: EQUAL
99109: IFTRUE 99119
99111: LD_INT 1
99113: DOUBLE
99114: EQUAL
99115: IFTRUE 99119
99117: GO 99320
99119: POP
// case nation of nation_american :
99120: LD_VAR 0 5
99124: PUSH
99125: LD_INT 1
99127: DOUBLE
99128: EQUAL
99129: IFTRUE 99133
99131: GO 99189
99133: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99134: LD_ADDR_VAR 0 9
99138: PUSH
99139: LD_VAR 0 11
99143: PUSH
99144: LD_VAR 0 12
99148: PUSH
99149: LD_VAR 0 13
99153: PUSH
99154: LD_VAR 0 14
99158: PUSH
99159: LD_VAR 0 15
99163: PUSH
99164: LD_VAR 0 16
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: PUSH
99177: LD_VAR 0 4
99181: PUSH
99182: LD_INT 1
99184: PLUS
99185: ARRAY
99186: ST_TO_ADDR
99187: GO 99318
99189: LD_INT 2
99191: DOUBLE
99192: EQUAL
99193: IFTRUE 99197
99195: GO 99253
99197: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99198: LD_ADDR_VAR 0 9
99202: PUSH
99203: LD_VAR 0 17
99207: PUSH
99208: LD_VAR 0 18
99212: PUSH
99213: LD_VAR 0 19
99217: PUSH
99218: LD_VAR 0 20
99222: PUSH
99223: LD_VAR 0 21
99227: PUSH
99228: LD_VAR 0 22
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: PUSH
99241: LD_VAR 0 4
99245: PUSH
99246: LD_INT 1
99248: PLUS
99249: ARRAY
99250: ST_TO_ADDR
99251: GO 99318
99253: LD_INT 3
99255: DOUBLE
99256: EQUAL
99257: IFTRUE 99261
99259: GO 99317
99261: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99262: LD_ADDR_VAR 0 9
99266: PUSH
99267: LD_VAR 0 23
99271: PUSH
99272: LD_VAR 0 24
99276: PUSH
99277: LD_VAR 0 25
99281: PUSH
99282: LD_VAR 0 26
99286: PUSH
99287: LD_VAR 0 27
99291: PUSH
99292: LD_VAR 0 28
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: LIST
99304: PUSH
99305: LD_VAR 0 4
99309: PUSH
99310: LD_INT 1
99312: PLUS
99313: ARRAY
99314: ST_TO_ADDR
99315: GO 99318
99317: POP
99318: GO 99873
99320: LD_INT 2
99322: DOUBLE
99323: EQUAL
99324: IFTRUE 99334
99326: LD_INT 3
99328: DOUBLE
99329: EQUAL
99330: IFTRUE 99334
99332: GO 99390
99334: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99335: LD_ADDR_VAR 0 9
99339: PUSH
99340: LD_VAR 0 29
99344: PUSH
99345: LD_VAR 0 30
99349: PUSH
99350: LD_VAR 0 31
99354: PUSH
99355: LD_VAR 0 32
99359: PUSH
99360: LD_VAR 0 33
99364: PUSH
99365: LD_VAR 0 34
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: PUSH
99378: LD_VAR 0 4
99382: PUSH
99383: LD_INT 1
99385: PLUS
99386: ARRAY
99387: ST_TO_ADDR
99388: GO 99873
99390: LD_INT 16
99392: DOUBLE
99393: EQUAL
99394: IFTRUE 99452
99396: LD_INT 17
99398: DOUBLE
99399: EQUAL
99400: IFTRUE 99452
99402: LD_INT 18
99404: DOUBLE
99405: EQUAL
99406: IFTRUE 99452
99408: LD_INT 19
99410: DOUBLE
99411: EQUAL
99412: IFTRUE 99452
99414: LD_INT 22
99416: DOUBLE
99417: EQUAL
99418: IFTRUE 99452
99420: LD_INT 20
99422: DOUBLE
99423: EQUAL
99424: IFTRUE 99452
99426: LD_INT 21
99428: DOUBLE
99429: EQUAL
99430: IFTRUE 99452
99432: LD_INT 23
99434: DOUBLE
99435: EQUAL
99436: IFTRUE 99452
99438: LD_INT 24
99440: DOUBLE
99441: EQUAL
99442: IFTRUE 99452
99444: LD_INT 25
99446: DOUBLE
99447: EQUAL
99448: IFTRUE 99452
99450: GO 99508
99452: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99453: LD_ADDR_VAR 0 9
99457: PUSH
99458: LD_VAR 0 35
99462: PUSH
99463: LD_VAR 0 36
99467: PUSH
99468: LD_VAR 0 37
99472: PUSH
99473: LD_VAR 0 38
99477: PUSH
99478: LD_VAR 0 39
99482: PUSH
99483: LD_VAR 0 40
99487: PUSH
99488: EMPTY
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: LIST
99494: LIST
99495: PUSH
99496: LD_VAR 0 4
99500: PUSH
99501: LD_INT 1
99503: PLUS
99504: ARRAY
99505: ST_TO_ADDR
99506: GO 99873
99508: LD_INT 6
99510: DOUBLE
99511: EQUAL
99512: IFTRUE 99564
99514: LD_INT 7
99516: DOUBLE
99517: EQUAL
99518: IFTRUE 99564
99520: LD_INT 8
99522: DOUBLE
99523: EQUAL
99524: IFTRUE 99564
99526: LD_INT 13
99528: DOUBLE
99529: EQUAL
99530: IFTRUE 99564
99532: LD_INT 12
99534: DOUBLE
99535: EQUAL
99536: IFTRUE 99564
99538: LD_INT 15
99540: DOUBLE
99541: EQUAL
99542: IFTRUE 99564
99544: LD_INT 11
99546: DOUBLE
99547: EQUAL
99548: IFTRUE 99564
99550: LD_INT 14
99552: DOUBLE
99553: EQUAL
99554: IFTRUE 99564
99556: LD_INT 10
99558: DOUBLE
99559: EQUAL
99560: IFTRUE 99564
99562: GO 99620
99564: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99565: LD_ADDR_VAR 0 9
99569: PUSH
99570: LD_VAR 0 41
99574: PUSH
99575: LD_VAR 0 42
99579: PUSH
99580: LD_VAR 0 43
99584: PUSH
99585: LD_VAR 0 44
99589: PUSH
99590: LD_VAR 0 45
99594: PUSH
99595: LD_VAR 0 46
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: PUSH
99608: LD_VAR 0 4
99612: PUSH
99613: LD_INT 1
99615: PLUS
99616: ARRAY
99617: ST_TO_ADDR
99618: GO 99873
99620: LD_INT 36
99622: DOUBLE
99623: EQUAL
99624: IFTRUE 99628
99626: GO 99684
99628: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99629: LD_ADDR_VAR 0 9
99633: PUSH
99634: LD_VAR 0 47
99638: PUSH
99639: LD_VAR 0 48
99643: PUSH
99644: LD_VAR 0 49
99648: PUSH
99649: LD_VAR 0 50
99653: PUSH
99654: LD_VAR 0 51
99658: PUSH
99659: LD_VAR 0 52
99663: PUSH
99664: EMPTY
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: PUSH
99672: LD_VAR 0 4
99676: PUSH
99677: LD_INT 1
99679: PLUS
99680: ARRAY
99681: ST_TO_ADDR
99682: GO 99873
99684: LD_INT 4
99686: DOUBLE
99687: EQUAL
99688: IFTRUE 99710
99690: LD_INT 5
99692: DOUBLE
99693: EQUAL
99694: IFTRUE 99710
99696: LD_INT 34
99698: DOUBLE
99699: EQUAL
99700: IFTRUE 99710
99702: LD_INT 37
99704: DOUBLE
99705: EQUAL
99706: IFTRUE 99710
99708: GO 99766
99710: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99711: LD_ADDR_VAR 0 9
99715: PUSH
99716: LD_VAR 0 53
99720: PUSH
99721: LD_VAR 0 54
99725: PUSH
99726: LD_VAR 0 55
99730: PUSH
99731: LD_VAR 0 56
99735: PUSH
99736: LD_VAR 0 57
99740: PUSH
99741: LD_VAR 0 58
99745: PUSH
99746: EMPTY
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: PUSH
99754: LD_VAR 0 4
99758: PUSH
99759: LD_INT 1
99761: PLUS
99762: ARRAY
99763: ST_TO_ADDR
99764: GO 99873
99766: LD_INT 31
99768: DOUBLE
99769: EQUAL
99770: IFTRUE 99816
99772: LD_INT 32
99774: DOUBLE
99775: EQUAL
99776: IFTRUE 99816
99778: LD_INT 33
99780: DOUBLE
99781: EQUAL
99782: IFTRUE 99816
99784: LD_INT 27
99786: DOUBLE
99787: EQUAL
99788: IFTRUE 99816
99790: LD_INT 26
99792: DOUBLE
99793: EQUAL
99794: IFTRUE 99816
99796: LD_INT 28
99798: DOUBLE
99799: EQUAL
99800: IFTRUE 99816
99802: LD_INT 29
99804: DOUBLE
99805: EQUAL
99806: IFTRUE 99816
99808: LD_INT 30
99810: DOUBLE
99811: EQUAL
99812: IFTRUE 99816
99814: GO 99872
99816: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99817: LD_ADDR_VAR 0 9
99821: PUSH
99822: LD_VAR 0 59
99826: PUSH
99827: LD_VAR 0 60
99831: PUSH
99832: LD_VAR 0 61
99836: PUSH
99837: LD_VAR 0 62
99841: PUSH
99842: LD_VAR 0 63
99846: PUSH
99847: LD_VAR 0 64
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: LIST
99856: LIST
99857: LIST
99858: LIST
99859: PUSH
99860: LD_VAR 0 4
99864: PUSH
99865: LD_INT 1
99867: PLUS
99868: ARRAY
99869: ST_TO_ADDR
99870: GO 99873
99872: POP
// temp_list2 = [ ] ;
99873: LD_ADDR_VAR 0 10
99877: PUSH
99878: EMPTY
99879: ST_TO_ADDR
// for i in temp_list do
99880: LD_ADDR_VAR 0 8
99884: PUSH
99885: LD_VAR 0 9
99889: PUSH
99890: FOR_IN
99891: IFFALSE 99943
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99893: LD_ADDR_VAR 0 10
99897: PUSH
99898: LD_VAR 0 10
99902: PUSH
99903: LD_VAR 0 8
99907: PUSH
99908: LD_INT 1
99910: ARRAY
99911: PUSH
99912: LD_VAR 0 2
99916: PLUS
99917: PUSH
99918: LD_VAR 0 8
99922: PUSH
99923: LD_INT 2
99925: ARRAY
99926: PUSH
99927: LD_VAR 0 3
99931: PLUS
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PUSH
99937: EMPTY
99938: LIST
99939: ADD
99940: ST_TO_ADDR
99941: GO 99890
99943: POP
99944: POP
// result = temp_list2 ;
99945: LD_ADDR_VAR 0 7
99949: PUSH
99950: LD_VAR 0 10
99954: ST_TO_ADDR
// end ;
99955: LD_VAR 0 7
99959: RET
// export function EnemyInRange ( unit , dist ) ; begin
99960: LD_INT 0
99962: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99963: LD_ADDR_VAR 0 3
99967: PUSH
99968: LD_VAR 0 1
99972: PPUSH
99973: CALL_OW 255
99977: PPUSH
99978: LD_VAR 0 1
99982: PPUSH
99983: CALL_OW 250
99987: PPUSH
99988: LD_VAR 0 1
99992: PPUSH
99993: CALL_OW 251
99997: PPUSH
99998: LD_VAR 0 2
100002: PPUSH
100003: CALL 73362 0 4
100007: PUSH
100008: LD_INT 4
100010: ARRAY
100011: ST_TO_ADDR
// end ;
100012: LD_VAR 0 3
100016: RET
// export function PlayerSeeMe ( unit ) ; begin
100017: LD_INT 0
100019: PPUSH
// result := See ( your_side , unit ) ;
100020: LD_ADDR_VAR 0 2
100024: PUSH
100025: LD_OWVAR 2
100029: PPUSH
100030: LD_VAR 0 1
100034: PPUSH
100035: CALL_OW 292
100039: ST_TO_ADDR
// end ;
100040: LD_VAR 0 2
100044: RET
// export function ReverseDir ( unit ) ; begin
100045: LD_INT 0
100047: PPUSH
// if not unit then
100048: LD_VAR 0 1
100052: NOT
100053: IFFALSE 100057
// exit ;
100055: GO 100080
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100057: LD_ADDR_VAR 0 2
100061: PUSH
100062: LD_VAR 0 1
100066: PPUSH
100067: CALL_OW 254
100071: PUSH
100072: LD_INT 3
100074: PLUS
100075: PUSH
100076: LD_INT 6
100078: MOD
100079: ST_TO_ADDR
// end ;
100080: LD_VAR 0 2
100084: RET
// export function ReverseArray ( array ) ; var i ; begin
100085: LD_INT 0
100087: PPUSH
100088: PPUSH
// if not array then
100089: LD_VAR 0 1
100093: NOT
100094: IFFALSE 100098
// exit ;
100096: GO 100153
// result := [ ] ;
100098: LD_ADDR_VAR 0 2
100102: PUSH
100103: EMPTY
100104: ST_TO_ADDR
// for i := array downto 1 do
100105: LD_ADDR_VAR 0 3
100109: PUSH
100110: DOUBLE
100111: LD_VAR 0 1
100115: INC
100116: ST_TO_ADDR
100117: LD_INT 1
100119: PUSH
100120: FOR_DOWNTO
100121: IFFALSE 100151
// result := Join ( result , array [ i ] ) ;
100123: LD_ADDR_VAR 0 2
100127: PUSH
100128: LD_VAR 0 2
100132: PPUSH
100133: LD_VAR 0 1
100137: PUSH
100138: LD_VAR 0 3
100142: ARRAY
100143: PPUSH
100144: CALL 104778 0 2
100148: ST_TO_ADDR
100149: GO 100120
100151: POP
100152: POP
// end ;
100153: LD_VAR 0 2
100157: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100158: LD_INT 0
100160: PPUSH
100161: PPUSH
100162: PPUSH
100163: PPUSH
100164: PPUSH
100165: PPUSH
// if not unit or not hexes then
100166: LD_VAR 0 1
100170: NOT
100171: PUSH
100172: LD_VAR 0 2
100176: NOT
100177: OR
100178: IFFALSE 100182
// exit ;
100180: GO 100305
// dist := 9999 ;
100182: LD_ADDR_VAR 0 5
100186: PUSH
100187: LD_INT 9999
100189: ST_TO_ADDR
// for i = 1 to hexes do
100190: LD_ADDR_VAR 0 4
100194: PUSH
100195: DOUBLE
100196: LD_INT 1
100198: DEC
100199: ST_TO_ADDR
100200: LD_VAR 0 2
100204: PUSH
100205: FOR_TO
100206: IFFALSE 100293
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100208: LD_ADDR_VAR 0 6
100212: PUSH
100213: LD_VAR 0 1
100217: PPUSH
100218: LD_VAR 0 2
100222: PUSH
100223: LD_VAR 0 4
100227: ARRAY
100228: PUSH
100229: LD_INT 1
100231: ARRAY
100232: PPUSH
100233: LD_VAR 0 2
100237: PUSH
100238: LD_VAR 0 4
100242: ARRAY
100243: PUSH
100244: LD_INT 2
100246: ARRAY
100247: PPUSH
100248: CALL_OW 297
100252: ST_TO_ADDR
// if tdist < dist then
100253: LD_VAR 0 6
100257: PUSH
100258: LD_VAR 0 5
100262: LESS
100263: IFFALSE 100291
// begin hex := hexes [ i ] ;
100265: LD_ADDR_VAR 0 8
100269: PUSH
100270: LD_VAR 0 2
100274: PUSH
100275: LD_VAR 0 4
100279: ARRAY
100280: ST_TO_ADDR
// dist := tdist ;
100281: LD_ADDR_VAR 0 5
100285: PUSH
100286: LD_VAR 0 6
100290: ST_TO_ADDR
// end ; end ;
100291: GO 100205
100293: POP
100294: POP
// result := hex ;
100295: LD_ADDR_VAR 0 3
100299: PUSH
100300: LD_VAR 0 8
100304: ST_TO_ADDR
// end ;
100305: LD_VAR 0 3
100309: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100310: LD_INT 0
100312: PPUSH
100313: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100314: LD_VAR 0 1
100318: NOT
100319: PUSH
100320: LD_VAR 0 1
100324: PUSH
100325: LD_INT 21
100327: PUSH
100328: LD_INT 2
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: PUSH
100335: LD_INT 23
100337: PUSH
100338: LD_INT 2
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: PUSH
100345: EMPTY
100346: LIST
100347: LIST
100348: PPUSH
100349: CALL_OW 69
100353: IN
100354: NOT
100355: OR
100356: IFFALSE 100360
// exit ;
100358: GO 100407
// for i = 1 to 3 do
100360: LD_ADDR_VAR 0 3
100364: PUSH
100365: DOUBLE
100366: LD_INT 1
100368: DEC
100369: ST_TO_ADDR
100370: LD_INT 3
100372: PUSH
100373: FOR_TO
100374: IFFALSE 100405
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100376: LD_VAR 0 1
100380: PPUSH
100381: CALL_OW 250
100385: PPUSH
100386: LD_VAR 0 1
100390: PPUSH
100391: CALL_OW 251
100395: PPUSH
100396: LD_INT 1
100398: PPUSH
100399: CALL_OW 453
100403: GO 100373
100405: POP
100406: POP
// end ;
100407: LD_VAR 0 2
100411: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100412: LD_INT 0
100414: PPUSH
100415: PPUSH
100416: PPUSH
100417: PPUSH
100418: PPUSH
100419: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100420: LD_VAR 0 1
100424: NOT
100425: PUSH
100426: LD_VAR 0 2
100430: NOT
100431: OR
100432: PUSH
100433: LD_VAR 0 1
100437: PPUSH
100438: CALL_OW 314
100442: OR
100443: IFFALSE 100447
// exit ;
100445: GO 100888
// x := GetX ( enemy_unit ) ;
100447: LD_ADDR_VAR 0 7
100451: PUSH
100452: LD_VAR 0 2
100456: PPUSH
100457: CALL_OW 250
100461: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100462: LD_ADDR_VAR 0 8
100466: PUSH
100467: LD_VAR 0 2
100471: PPUSH
100472: CALL_OW 251
100476: ST_TO_ADDR
// if not x or not y then
100477: LD_VAR 0 7
100481: NOT
100482: PUSH
100483: LD_VAR 0 8
100487: NOT
100488: OR
100489: IFFALSE 100493
// exit ;
100491: GO 100888
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100493: LD_ADDR_VAR 0 6
100497: PUSH
100498: LD_VAR 0 7
100502: PPUSH
100503: LD_INT 0
100505: PPUSH
100506: LD_INT 4
100508: PPUSH
100509: CALL_OW 272
100513: PUSH
100514: LD_VAR 0 8
100518: PPUSH
100519: LD_INT 0
100521: PPUSH
100522: LD_INT 4
100524: PPUSH
100525: CALL_OW 273
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PUSH
100534: LD_VAR 0 7
100538: PPUSH
100539: LD_INT 1
100541: PPUSH
100542: LD_INT 4
100544: PPUSH
100545: CALL_OW 272
100549: PUSH
100550: LD_VAR 0 8
100554: PPUSH
100555: LD_INT 1
100557: PPUSH
100558: LD_INT 4
100560: PPUSH
100561: CALL_OW 273
100565: PUSH
100566: EMPTY
100567: LIST
100568: LIST
100569: PUSH
100570: LD_VAR 0 7
100574: PPUSH
100575: LD_INT 2
100577: PPUSH
100578: LD_INT 4
100580: PPUSH
100581: CALL_OW 272
100585: PUSH
100586: LD_VAR 0 8
100590: PPUSH
100591: LD_INT 2
100593: PPUSH
100594: LD_INT 4
100596: PPUSH
100597: CALL_OW 273
100601: PUSH
100602: EMPTY
100603: LIST
100604: LIST
100605: PUSH
100606: LD_VAR 0 7
100610: PPUSH
100611: LD_INT 3
100613: PPUSH
100614: LD_INT 4
100616: PPUSH
100617: CALL_OW 272
100621: PUSH
100622: LD_VAR 0 8
100626: PPUSH
100627: LD_INT 3
100629: PPUSH
100630: LD_INT 4
100632: PPUSH
100633: CALL_OW 273
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PUSH
100642: LD_VAR 0 7
100646: PPUSH
100647: LD_INT 4
100649: PPUSH
100650: LD_INT 4
100652: PPUSH
100653: CALL_OW 272
100657: PUSH
100658: LD_VAR 0 8
100662: PPUSH
100663: LD_INT 4
100665: PPUSH
100666: LD_INT 4
100668: PPUSH
100669: CALL_OW 273
100673: PUSH
100674: EMPTY
100675: LIST
100676: LIST
100677: PUSH
100678: LD_VAR 0 7
100682: PPUSH
100683: LD_INT 5
100685: PPUSH
100686: LD_INT 4
100688: PPUSH
100689: CALL_OW 272
100693: PUSH
100694: LD_VAR 0 8
100698: PPUSH
100699: LD_INT 5
100701: PPUSH
100702: LD_INT 4
100704: PPUSH
100705: CALL_OW 273
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PUSH
100714: EMPTY
100715: LIST
100716: LIST
100717: LIST
100718: LIST
100719: LIST
100720: LIST
100721: ST_TO_ADDR
// for i = tmp downto 1 do
100722: LD_ADDR_VAR 0 4
100726: PUSH
100727: DOUBLE
100728: LD_VAR 0 6
100732: INC
100733: ST_TO_ADDR
100734: LD_INT 1
100736: PUSH
100737: FOR_DOWNTO
100738: IFFALSE 100839
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100740: LD_VAR 0 6
100744: PUSH
100745: LD_VAR 0 4
100749: ARRAY
100750: PUSH
100751: LD_INT 1
100753: ARRAY
100754: PPUSH
100755: LD_VAR 0 6
100759: PUSH
100760: LD_VAR 0 4
100764: ARRAY
100765: PUSH
100766: LD_INT 2
100768: ARRAY
100769: PPUSH
100770: CALL_OW 488
100774: NOT
100775: PUSH
100776: LD_VAR 0 6
100780: PUSH
100781: LD_VAR 0 4
100785: ARRAY
100786: PUSH
100787: LD_INT 1
100789: ARRAY
100790: PPUSH
100791: LD_VAR 0 6
100795: PUSH
100796: LD_VAR 0 4
100800: ARRAY
100801: PUSH
100802: LD_INT 2
100804: ARRAY
100805: PPUSH
100806: CALL_OW 428
100810: PUSH
100811: LD_INT 0
100813: NONEQUAL
100814: OR
100815: IFFALSE 100837
// tmp := Delete ( tmp , i ) ;
100817: LD_ADDR_VAR 0 6
100821: PUSH
100822: LD_VAR 0 6
100826: PPUSH
100827: LD_VAR 0 4
100831: PPUSH
100832: CALL_OW 3
100836: ST_TO_ADDR
100837: GO 100737
100839: POP
100840: POP
// j := GetClosestHex ( unit , tmp ) ;
100841: LD_ADDR_VAR 0 5
100845: PUSH
100846: LD_VAR 0 1
100850: PPUSH
100851: LD_VAR 0 6
100855: PPUSH
100856: CALL 100158 0 2
100860: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
100861: LD_VAR 0 1
100865: PPUSH
100866: LD_VAR 0 5
100870: PUSH
100871: LD_INT 1
100873: ARRAY
100874: PPUSH
100875: LD_VAR 0 5
100879: PUSH
100880: LD_INT 2
100882: ARRAY
100883: PPUSH
100884: CALL_OW 111
// end ;
100888: LD_VAR 0 3
100892: RET
// export function PrepareApemanSoldier ( ) ; begin
100893: LD_INT 0
100895: PPUSH
// uc_nation := 0 ;
100896: LD_ADDR_OWVAR 21
100900: PUSH
100901: LD_INT 0
100903: ST_TO_ADDR
// hc_sex := sex_male ;
100904: LD_ADDR_OWVAR 27
100908: PUSH
100909: LD_INT 1
100911: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
100912: LD_ADDR_OWVAR 28
100916: PUSH
100917: LD_INT 15
100919: ST_TO_ADDR
// hc_gallery :=  ;
100920: LD_ADDR_OWVAR 33
100924: PUSH
100925: LD_STRING 
100927: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100928: LD_ADDR_OWVAR 31
100932: PUSH
100933: LD_INT 0
100935: PPUSH
100936: LD_INT 3
100938: PPUSH
100939: CALL_OW 12
100943: PUSH
100944: LD_INT 0
100946: PPUSH
100947: LD_INT 3
100949: PPUSH
100950: CALL_OW 12
100954: PUSH
100955: LD_INT 0
100957: PUSH
100958: LD_INT 0
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: ST_TO_ADDR
// end ;
100967: LD_VAR 0 1
100971: RET
// export function PrepareApemanEngineer ( ) ; begin
100972: LD_INT 0
100974: PPUSH
// uc_nation := 0 ;
100975: LD_ADDR_OWVAR 21
100979: PUSH
100980: LD_INT 0
100982: ST_TO_ADDR
// hc_sex := sex_male ;
100983: LD_ADDR_OWVAR 27
100987: PUSH
100988: LD_INT 1
100990: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
100991: LD_ADDR_OWVAR 28
100995: PUSH
100996: LD_INT 16
100998: ST_TO_ADDR
// hc_gallery :=  ;
100999: LD_ADDR_OWVAR 33
101003: PUSH
101004: LD_STRING 
101006: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101007: LD_ADDR_OWVAR 31
101011: PUSH
101012: LD_INT 0
101014: PPUSH
101015: LD_INT 3
101017: PPUSH
101018: CALL_OW 12
101022: PUSH
101023: LD_INT 0
101025: PPUSH
101026: LD_INT 3
101028: PPUSH
101029: CALL_OW 12
101033: PUSH
101034: LD_INT 0
101036: PUSH
101037: LD_INT 0
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: ST_TO_ADDR
// end ;
101046: LD_VAR 0 1
101050: RET
// export function PrepareApeman ( agressivity ) ; begin
101051: LD_INT 0
101053: PPUSH
// uc_side := 0 ;
101054: LD_ADDR_OWVAR 20
101058: PUSH
101059: LD_INT 0
101061: ST_TO_ADDR
// uc_nation := 0 ;
101062: LD_ADDR_OWVAR 21
101066: PUSH
101067: LD_INT 0
101069: ST_TO_ADDR
// hc_sex := sex_male ;
101070: LD_ADDR_OWVAR 27
101074: PUSH
101075: LD_INT 1
101077: ST_TO_ADDR
// hc_class := class_apeman ;
101078: LD_ADDR_OWVAR 28
101082: PUSH
101083: LD_INT 12
101085: ST_TO_ADDR
// hc_gallery :=  ;
101086: LD_ADDR_OWVAR 33
101090: PUSH
101091: LD_STRING 
101093: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101094: LD_ADDR_OWVAR 35
101098: PUSH
101099: LD_VAR 0 1
101103: NEG
101104: PPUSH
101105: LD_VAR 0 1
101109: PPUSH
101110: CALL_OW 12
101114: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101115: LD_ADDR_OWVAR 31
101119: PUSH
101120: LD_INT 0
101122: PPUSH
101123: LD_INT 3
101125: PPUSH
101126: CALL_OW 12
101130: PUSH
101131: LD_INT 0
101133: PPUSH
101134: LD_INT 3
101136: PPUSH
101137: CALL_OW 12
101141: PUSH
101142: LD_INT 0
101144: PUSH
101145: LD_INT 0
101147: PUSH
101148: EMPTY
101149: LIST
101150: LIST
101151: LIST
101152: LIST
101153: ST_TO_ADDR
// end ;
101154: LD_VAR 0 2
101158: RET
// export function PrepareTiger ( agressivity ) ; begin
101159: LD_INT 0
101161: PPUSH
// uc_side := 0 ;
101162: LD_ADDR_OWVAR 20
101166: PUSH
101167: LD_INT 0
101169: ST_TO_ADDR
// uc_nation := 0 ;
101170: LD_ADDR_OWVAR 21
101174: PUSH
101175: LD_INT 0
101177: ST_TO_ADDR
// hc_class := class_tiger ;
101178: LD_ADDR_OWVAR 28
101182: PUSH
101183: LD_INT 14
101185: ST_TO_ADDR
// hc_gallery :=  ;
101186: LD_ADDR_OWVAR 33
101190: PUSH
101191: LD_STRING 
101193: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101194: LD_ADDR_OWVAR 35
101198: PUSH
101199: LD_VAR 0 1
101203: NEG
101204: PPUSH
101205: LD_VAR 0 1
101209: PPUSH
101210: CALL_OW 12
101214: ST_TO_ADDR
// end ;
101215: LD_VAR 0 2
101219: RET
// export function PrepareEnchidna ( ) ; begin
101220: LD_INT 0
101222: PPUSH
// uc_side := 0 ;
101223: LD_ADDR_OWVAR 20
101227: PUSH
101228: LD_INT 0
101230: ST_TO_ADDR
// uc_nation := 0 ;
101231: LD_ADDR_OWVAR 21
101235: PUSH
101236: LD_INT 0
101238: ST_TO_ADDR
// hc_class := class_baggie ;
101239: LD_ADDR_OWVAR 28
101243: PUSH
101244: LD_INT 13
101246: ST_TO_ADDR
// hc_gallery :=  ;
101247: LD_ADDR_OWVAR 33
101251: PUSH
101252: LD_STRING 
101254: ST_TO_ADDR
// end ;
101255: LD_VAR 0 1
101259: RET
// export function PrepareFrog ( ) ; begin
101260: LD_INT 0
101262: PPUSH
// uc_side := 0 ;
101263: LD_ADDR_OWVAR 20
101267: PUSH
101268: LD_INT 0
101270: ST_TO_ADDR
// uc_nation := 0 ;
101271: LD_ADDR_OWVAR 21
101275: PUSH
101276: LD_INT 0
101278: ST_TO_ADDR
// hc_class := class_frog ;
101279: LD_ADDR_OWVAR 28
101283: PUSH
101284: LD_INT 19
101286: ST_TO_ADDR
// hc_gallery :=  ;
101287: LD_ADDR_OWVAR 33
101291: PUSH
101292: LD_STRING 
101294: ST_TO_ADDR
// end ;
101295: LD_VAR 0 1
101299: RET
// export function PrepareFish ( ) ; begin
101300: LD_INT 0
101302: PPUSH
// uc_side := 0 ;
101303: LD_ADDR_OWVAR 20
101307: PUSH
101308: LD_INT 0
101310: ST_TO_ADDR
// uc_nation := 0 ;
101311: LD_ADDR_OWVAR 21
101315: PUSH
101316: LD_INT 0
101318: ST_TO_ADDR
// hc_class := class_fish ;
101319: LD_ADDR_OWVAR 28
101323: PUSH
101324: LD_INT 20
101326: ST_TO_ADDR
// hc_gallery :=  ;
101327: LD_ADDR_OWVAR 33
101331: PUSH
101332: LD_STRING 
101334: ST_TO_ADDR
// end ;
101335: LD_VAR 0 1
101339: RET
// export function PrepareBird ( ) ; begin
101340: LD_INT 0
101342: PPUSH
// uc_side := 0 ;
101343: LD_ADDR_OWVAR 20
101347: PUSH
101348: LD_INT 0
101350: ST_TO_ADDR
// uc_nation := 0 ;
101351: LD_ADDR_OWVAR 21
101355: PUSH
101356: LD_INT 0
101358: ST_TO_ADDR
// hc_class := class_phororhacos ;
101359: LD_ADDR_OWVAR 28
101363: PUSH
101364: LD_INT 18
101366: ST_TO_ADDR
// hc_gallery :=  ;
101367: LD_ADDR_OWVAR 33
101371: PUSH
101372: LD_STRING 
101374: ST_TO_ADDR
// end ;
101375: LD_VAR 0 1
101379: RET
// export function PrepareHorse ( ) ; begin
101380: LD_INT 0
101382: PPUSH
// uc_side := 0 ;
101383: LD_ADDR_OWVAR 20
101387: PUSH
101388: LD_INT 0
101390: ST_TO_ADDR
// uc_nation := 0 ;
101391: LD_ADDR_OWVAR 21
101395: PUSH
101396: LD_INT 0
101398: ST_TO_ADDR
// hc_class := class_horse ;
101399: LD_ADDR_OWVAR 28
101403: PUSH
101404: LD_INT 21
101406: ST_TO_ADDR
// hc_gallery :=  ;
101407: LD_ADDR_OWVAR 33
101411: PUSH
101412: LD_STRING 
101414: ST_TO_ADDR
// end ;
101415: LD_VAR 0 1
101419: RET
// export function PrepareMastodont ( ) ; begin
101420: LD_INT 0
101422: PPUSH
// uc_side := 0 ;
101423: LD_ADDR_OWVAR 20
101427: PUSH
101428: LD_INT 0
101430: ST_TO_ADDR
// uc_nation := 0 ;
101431: LD_ADDR_OWVAR 21
101435: PUSH
101436: LD_INT 0
101438: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101439: LD_ADDR_OWVAR 37
101443: PUSH
101444: LD_INT 31
101446: ST_TO_ADDR
// vc_control := control_rider ;
101447: LD_ADDR_OWVAR 38
101451: PUSH
101452: LD_INT 4
101454: ST_TO_ADDR
// end ;
101455: LD_VAR 0 1
101459: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101460: LD_INT 0
101462: PPUSH
101463: PPUSH
101464: PPUSH
// uc_side = 0 ;
101465: LD_ADDR_OWVAR 20
101469: PUSH
101470: LD_INT 0
101472: ST_TO_ADDR
// uc_nation = 0 ;
101473: LD_ADDR_OWVAR 21
101477: PUSH
101478: LD_INT 0
101480: ST_TO_ADDR
// InitHc_All ( ) ;
101481: CALL_OW 584
// InitVc ;
101485: CALL_OW 20
// if mastodonts then
101489: LD_VAR 0 6
101493: IFFALSE 101560
// for i = 1 to mastodonts do
101495: LD_ADDR_VAR 0 11
101499: PUSH
101500: DOUBLE
101501: LD_INT 1
101503: DEC
101504: ST_TO_ADDR
101505: LD_VAR 0 6
101509: PUSH
101510: FOR_TO
101511: IFFALSE 101558
// begin vc_chassis := 31 ;
101513: LD_ADDR_OWVAR 37
101517: PUSH
101518: LD_INT 31
101520: ST_TO_ADDR
// vc_control := control_rider ;
101521: LD_ADDR_OWVAR 38
101525: PUSH
101526: LD_INT 4
101528: ST_TO_ADDR
// animal := CreateVehicle ;
101529: LD_ADDR_VAR 0 12
101533: PUSH
101534: CALL_OW 45
101538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101539: LD_VAR 0 12
101543: PPUSH
101544: LD_VAR 0 8
101548: PPUSH
101549: LD_INT 0
101551: PPUSH
101552: CALL 103695 0 3
// end ;
101556: GO 101510
101558: POP
101559: POP
// if horses then
101560: LD_VAR 0 5
101564: IFFALSE 101631
// for i = 1 to horses do
101566: LD_ADDR_VAR 0 11
101570: PUSH
101571: DOUBLE
101572: LD_INT 1
101574: DEC
101575: ST_TO_ADDR
101576: LD_VAR 0 5
101580: PUSH
101581: FOR_TO
101582: IFFALSE 101629
// begin hc_class := 21 ;
101584: LD_ADDR_OWVAR 28
101588: PUSH
101589: LD_INT 21
101591: ST_TO_ADDR
// hc_gallery :=  ;
101592: LD_ADDR_OWVAR 33
101596: PUSH
101597: LD_STRING 
101599: ST_TO_ADDR
// animal := CreateHuman ;
101600: LD_ADDR_VAR 0 12
101604: PUSH
101605: CALL_OW 44
101609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101610: LD_VAR 0 12
101614: PPUSH
101615: LD_VAR 0 8
101619: PPUSH
101620: LD_INT 0
101622: PPUSH
101623: CALL 103695 0 3
// end ;
101627: GO 101581
101629: POP
101630: POP
// if birds then
101631: LD_VAR 0 1
101635: IFFALSE 101702
// for i = 1 to birds do
101637: LD_ADDR_VAR 0 11
101641: PUSH
101642: DOUBLE
101643: LD_INT 1
101645: DEC
101646: ST_TO_ADDR
101647: LD_VAR 0 1
101651: PUSH
101652: FOR_TO
101653: IFFALSE 101700
// begin hc_class = 18 ;
101655: LD_ADDR_OWVAR 28
101659: PUSH
101660: LD_INT 18
101662: ST_TO_ADDR
// hc_gallery =  ;
101663: LD_ADDR_OWVAR 33
101667: PUSH
101668: LD_STRING 
101670: ST_TO_ADDR
// animal := CreateHuman ;
101671: LD_ADDR_VAR 0 12
101675: PUSH
101676: CALL_OW 44
101680: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101681: LD_VAR 0 12
101685: PPUSH
101686: LD_VAR 0 8
101690: PPUSH
101691: LD_INT 0
101693: PPUSH
101694: CALL 103695 0 3
// end ;
101698: GO 101652
101700: POP
101701: POP
// if tigers then
101702: LD_VAR 0 2
101706: IFFALSE 101790
// for i = 1 to tigers do
101708: LD_ADDR_VAR 0 11
101712: PUSH
101713: DOUBLE
101714: LD_INT 1
101716: DEC
101717: ST_TO_ADDR
101718: LD_VAR 0 2
101722: PUSH
101723: FOR_TO
101724: IFFALSE 101788
// begin hc_class = class_tiger ;
101726: LD_ADDR_OWVAR 28
101730: PUSH
101731: LD_INT 14
101733: ST_TO_ADDR
// hc_gallery =  ;
101734: LD_ADDR_OWVAR 33
101738: PUSH
101739: LD_STRING 
101741: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101742: LD_ADDR_OWVAR 35
101746: PUSH
101747: LD_INT 7
101749: NEG
101750: PPUSH
101751: LD_INT 7
101753: PPUSH
101754: CALL_OW 12
101758: ST_TO_ADDR
// animal := CreateHuman ;
101759: LD_ADDR_VAR 0 12
101763: PUSH
101764: CALL_OW 44
101768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101769: LD_VAR 0 12
101773: PPUSH
101774: LD_VAR 0 8
101778: PPUSH
101779: LD_INT 0
101781: PPUSH
101782: CALL 103695 0 3
// end ;
101786: GO 101723
101788: POP
101789: POP
// if apemans then
101790: LD_VAR 0 3
101794: IFFALSE 101917
// for i = 1 to apemans do
101796: LD_ADDR_VAR 0 11
101800: PUSH
101801: DOUBLE
101802: LD_INT 1
101804: DEC
101805: ST_TO_ADDR
101806: LD_VAR 0 3
101810: PUSH
101811: FOR_TO
101812: IFFALSE 101915
// begin hc_class = class_apeman ;
101814: LD_ADDR_OWVAR 28
101818: PUSH
101819: LD_INT 12
101821: ST_TO_ADDR
// hc_gallery =  ;
101822: LD_ADDR_OWVAR 33
101826: PUSH
101827: LD_STRING 
101829: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
101830: LD_ADDR_OWVAR 35
101834: PUSH
101835: LD_INT 2
101837: NEG
101838: PPUSH
101839: LD_INT 2
101841: PPUSH
101842: CALL_OW 12
101846: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
101847: LD_ADDR_OWVAR 31
101851: PUSH
101852: LD_INT 1
101854: PPUSH
101855: LD_INT 3
101857: PPUSH
101858: CALL_OW 12
101862: PUSH
101863: LD_INT 1
101865: PPUSH
101866: LD_INT 3
101868: PPUSH
101869: CALL_OW 12
101873: PUSH
101874: LD_INT 0
101876: PUSH
101877: LD_INT 0
101879: PUSH
101880: EMPTY
101881: LIST
101882: LIST
101883: LIST
101884: LIST
101885: ST_TO_ADDR
// animal := CreateHuman ;
101886: LD_ADDR_VAR 0 12
101890: PUSH
101891: CALL_OW 44
101895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101896: LD_VAR 0 12
101900: PPUSH
101901: LD_VAR 0 8
101905: PPUSH
101906: LD_INT 0
101908: PPUSH
101909: CALL 103695 0 3
// end ;
101913: GO 101811
101915: POP
101916: POP
// if enchidnas then
101917: LD_VAR 0 4
101921: IFFALSE 101988
// for i = 1 to enchidnas do
101923: LD_ADDR_VAR 0 11
101927: PUSH
101928: DOUBLE
101929: LD_INT 1
101931: DEC
101932: ST_TO_ADDR
101933: LD_VAR 0 4
101937: PUSH
101938: FOR_TO
101939: IFFALSE 101986
// begin hc_class = 13 ;
101941: LD_ADDR_OWVAR 28
101945: PUSH
101946: LD_INT 13
101948: ST_TO_ADDR
// hc_gallery =  ;
101949: LD_ADDR_OWVAR 33
101953: PUSH
101954: LD_STRING 
101956: ST_TO_ADDR
// animal := CreateHuman ;
101957: LD_ADDR_VAR 0 12
101961: PUSH
101962: CALL_OW 44
101966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101967: LD_VAR 0 12
101971: PPUSH
101972: LD_VAR 0 8
101976: PPUSH
101977: LD_INT 0
101979: PPUSH
101980: CALL 103695 0 3
// end ;
101984: GO 101938
101986: POP
101987: POP
// if fishes then
101988: LD_VAR 0 7
101992: IFFALSE 102059
// for i = 1 to fishes do
101994: LD_ADDR_VAR 0 11
101998: PUSH
101999: DOUBLE
102000: LD_INT 1
102002: DEC
102003: ST_TO_ADDR
102004: LD_VAR 0 7
102008: PUSH
102009: FOR_TO
102010: IFFALSE 102057
// begin hc_class = 20 ;
102012: LD_ADDR_OWVAR 28
102016: PUSH
102017: LD_INT 20
102019: ST_TO_ADDR
// hc_gallery =  ;
102020: LD_ADDR_OWVAR 33
102024: PUSH
102025: LD_STRING 
102027: ST_TO_ADDR
// animal := CreateHuman ;
102028: LD_ADDR_VAR 0 12
102032: PUSH
102033: CALL_OW 44
102037: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102038: LD_VAR 0 12
102042: PPUSH
102043: LD_VAR 0 9
102047: PPUSH
102048: LD_INT 0
102050: PPUSH
102051: CALL 103695 0 3
// end ;
102055: GO 102009
102057: POP
102058: POP
// end ;
102059: LD_VAR 0 10
102063: RET
// export function WantHeal ( sci , unit ) ; begin
102064: LD_INT 0
102066: PPUSH
// if GetTaskList ( sci ) > 0 then
102067: LD_VAR 0 1
102071: PPUSH
102072: CALL_OW 437
102076: PUSH
102077: LD_INT 0
102079: GREATER
102080: IFFALSE 102150
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102082: LD_VAR 0 1
102086: PPUSH
102087: CALL_OW 437
102091: PUSH
102092: LD_INT 1
102094: ARRAY
102095: PUSH
102096: LD_INT 1
102098: ARRAY
102099: PUSH
102100: LD_STRING l
102102: EQUAL
102103: PUSH
102104: LD_VAR 0 1
102108: PPUSH
102109: CALL_OW 437
102113: PUSH
102114: LD_INT 1
102116: ARRAY
102117: PUSH
102118: LD_INT 4
102120: ARRAY
102121: PUSH
102122: LD_VAR 0 2
102126: EQUAL
102127: AND
102128: IFFALSE 102140
// result := true else
102130: LD_ADDR_VAR 0 3
102134: PUSH
102135: LD_INT 1
102137: ST_TO_ADDR
102138: GO 102148
// result := false ;
102140: LD_ADDR_VAR 0 3
102144: PUSH
102145: LD_INT 0
102147: ST_TO_ADDR
// end else
102148: GO 102158
// result := false ;
102150: LD_ADDR_VAR 0 3
102154: PUSH
102155: LD_INT 0
102157: ST_TO_ADDR
// end ;
102158: LD_VAR 0 3
102162: RET
// export function HealTarget ( sci ) ; begin
102163: LD_INT 0
102165: PPUSH
// if not sci then
102166: LD_VAR 0 1
102170: NOT
102171: IFFALSE 102175
// exit ;
102173: GO 102240
// result := 0 ;
102175: LD_ADDR_VAR 0 2
102179: PUSH
102180: LD_INT 0
102182: ST_TO_ADDR
// if GetTaskList ( sci ) then
102183: LD_VAR 0 1
102187: PPUSH
102188: CALL_OW 437
102192: IFFALSE 102240
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102194: LD_VAR 0 1
102198: PPUSH
102199: CALL_OW 437
102203: PUSH
102204: LD_INT 1
102206: ARRAY
102207: PUSH
102208: LD_INT 1
102210: ARRAY
102211: PUSH
102212: LD_STRING l
102214: EQUAL
102215: IFFALSE 102240
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102217: LD_ADDR_VAR 0 2
102221: PUSH
102222: LD_VAR 0 1
102226: PPUSH
102227: CALL_OW 437
102231: PUSH
102232: LD_INT 1
102234: ARRAY
102235: PUSH
102236: LD_INT 4
102238: ARRAY
102239: ST_TO_ADDR
// end ;
102240: LD_VAR 0 2
102244: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102245: LD_INT 0
102247: PPUSH
102248: PPUSH
102249: PPUSH
102250: PPUSH
// if not base_units then
102251: LD_VAR 0 1
102255: NOT
102256: IFFALSE 102260
// exit ;
102258: GO 102347
// result := false ;
102260: LD_ADDR_VAR 0 2
102264: PUSH
102265: LD_INT 0
102267: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102268: LD_ADDR_VAR 0 5
102272: PUSH
102273: LD_VAR 0 1
102277: PPUSH
102278: LD_INT 21
102280: PUSH
102281: LD_INT 3
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: PPUSH
102288: CALL_OW 72
102292: ST_TO_ADDR
// if not tmp then
102293: LD_VAR 0 5
102297: NOT
102298: IFFALSE 102302
// exit ;
102300: GO 102347
// for i in tmp do
102302: LD_ADDR_VAR 0 3
102306: PUSH
102307: LD_VAR 0 5
102311: PUSH
102312: FOR_IN
102313: IFFALSE 102345
// begin result := EnemyInRange ( i , 22 ) ;
102315: LD_ADDR_VAR 0 2
102319: PUSH
102320: LD_VAR 0 3
102324: PPUSH
102325: LD_INT 22
102327: PPUSH
102328: CALL 99960 0 2
102332: ST_TO_ADDR
// if result then
102333: LD_VAR 0 2
102337: IFFALSE 102343
// exit ;
102339: POP
102340: POP
102341: GO 102347
// end ;
102343: GO 102312
102345: POP
102346: POP
// end ;
102347: LD_VAR 0 2
102351: RET
// export function FilterByTag ( units , tag ) ; begin
102352: LD_INT 0
102354: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102355: LD_ADDR_VAR 0 3
102359: PUSH
102360: LD_VAR 0 1
102364: PPUSH
102365: LD_INT 120
102367: PUSH
102368: LD_VAR 0 2
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: PPUSH
102377: CALL_OW 72
102381: ST_TO_ADDR
// end ;
102382: LD_VAR 0 3
102386: RET
// export function IsDriver ( un ) ; begin
102387: LD_INT 0
102389: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102390: LD_ADDR_VAR 0 2
102394: PUSH
102395: LD_VAR 0 1
102399: PUSH
102400: LD_INT 55
102402: PUSH
102403: EMPTY
102404: LIST
102405: PPUSH
102406: CALL_OW 69
102410: IN
102411: ST_TO_ADDR
// end ;
102412: LD_VAR 0 2
102416: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102417: LD_INT 0
102419: PPUSH
102420: PPUSH
// list := [ ] ;
102421: LD_ADDR_VAR 0 5
102425: PUSH
102426: EMPTY
102427: ST_TO_ADDR
// case d of 0 :
102428: LD_VAR 0 3
102432: PUSH
102433: LD_INT 0
102435: DOUBLE
102436: EQUAL
102437: IFTRUE 102441
102439: GO 102574
102441: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102442: LD_ADDR_VAR 0 5
102446: PUSH
102447: LD_VAR 0 1
102451: PUSH
102452: LD_INT 4
102454: MINUS
102455: PUSH
102456: LD_VAR 0 2
102460: PUSH
102461: LD_INT 4
102463: MINUS
102464: PUSH
102465: LD_INT 2
102467: PUSH
102468: EMPTY
102469: LIST
102470: LIST
102471: LIST
102472: PUSH
102473: LD_VAR 0 1
102477: PUSH
102478: LD_INT 3
102480: MINUS
102481: PUSH
102482: LD_VAR 0 2
102486: PUSH
102487: LD_INT 1
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: LIST
102494: PUSH
102495: LD_VAR 0 1
102499: PUSH
102500: LD_INT 4
102502: PLUS
102503: PUSH
102504: LD_VAR 0 2
102508: PUSH
102509: LD_INT 4
102511: PUSH
102512: EMPTY
102513: LIST
102514: LIST
102515: LIST
102516: PUSH
102517: LD_VAR 0 1
102521: PUSH
102522: LD_INT 3
102524: PLUS
102525: PUSH
102526: LD_VAR 0 2
102530: PUSH
102531: LD_INT 3
102533: PLUS
102534: PUSH
102535: LD_INT 5
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: LIST
102542: PUSH
102543: LD_VAR 0 1
102547: PUSH
102548: LD_VAR 0 2
102552: PUSH
102553: LD_INT 4
102555: PLUS
102556: PUSH
102557: LD_INT 0
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: LIST
102564: PUSH
102565: EMPTY
102566: LIST
102567: LIST
102568: LIST
102569: LIST
102570: LIST
102571: ST_TO_ADDR
// end ; 1 :
102572: GO 103272
102574: LD_INT 1
102576: DOUBLE
102577: EQUAL
102578: IFTRUE 102582
102580: GO 102715
102582: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102583: LD_ADDR_VAR 0 5
102587: PUSH
102588: LD_VAR 0 1
102592: PUSH
102593: LD_VAR 0 2
102597: PUSH
102598: LD_INT 4
102600: MINUS
102601: PUSH
102602: LD_INT 3
102604: PUSH
102605: EMPTY
102606: LIST
102607: LIST
102608: LIST
102609: PUSH
102610: LD_VAR 0 1
102614: PUSH
102615: LD_INT 3
102617: MINUS
102618: PUSH
102619: LD_VAR 0 2
102623: PUSH
102624: LD_INT 3
102626: MINUS
102627: PUSH
102628: LD_INT 2
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: LIST
102635: PUSH
102636: LD_VAR 0 1
102640: PUSH
102641: LD_INT 4
102643: MINUS
102644: PUSH
102645: LD_VAR 0 2
102649: PUSH
102650: LD_INT 1
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: LIST
102657: PUSH
102658: LD_VAR 0 1
102662: PUSH
102663: LD_VAR 0 2
102667: PUSH
102668: LD_INT 3
102670: PLUS
102671: PUSH
102672: LD_INT 0
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: LIST
102679: PUSH
102680: LD_VAR 0 1
102684: PUSH
102685: LD_INT 4
102687: PLUS
102688: PUSH
102689: LD_VAR 0 2
102693: PUSH
102694: LD_INT 4
102696: PLUS
102697: PUSH
102698: LD_INT 5
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: ST_TO_ADDR
// end ; 2 :
102713: GO 103272
102715: LD_INT 2
102717: DOUBLE
102718: EQUAL
102719: IFTRUE 102723
102721: GO 102852
102723: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102724: LD_ADDR_VAR 0 5
102728: PUSH
102729: LD_VAR 0 1
102733: PUSH
102734: LD_VAR 0 2
102738: PUSH
102739: LD_INT 3
102741: MINUS
102742: PUSH
102743: LD_INT 3
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: LIST
102750: PUSH
102751: LD_VAR 0 1
102755: PUSH
102756: LD_INT 4
102758: PLUS
102759: PUSH
102760: LD_VAR 0 2
102764: PUSH
102765: LD_INT 4
102767: PUSH
102768: EMPTY
102769: LIST
102770: LIST
102771: LIST
102772: PUSH
102773: LD_VAR 0 1
102777: PUSH
102778: LD_VAR 0 2
102782: PUSH
102783: LD_INT 4
102785: PLUS
102786: PUSH
102787: LD_INT 0
102789: PUSH
102790: EMPTY
102791: LIST
102792: LIST
102793: LIST
102794: PUSH
102795: LD_VAR 0 1
102799: PUSH
102800: LD_INT 3
102802: MINUS
102803: PUSH
102804: LD_VAR 0 2
102808: PUSH
102809: LD_INT 1
102811: PUSH
102812: EMPTY
102813: LIST
102814: LIST
102815: LIST
102816: PUSH
102817: LD_VAR 0 1
102821: PUSH
102822: LD_INT 4
102824: MINUS
102825: PUSH
102826: LD_VAR 0 2
102830: PUSH
102831: LD_INT 4
102833: MINUS
102834: PUSH
102835: LD_INT 2
102837: PUSH
102838: EMPTY
102839: LIST
102840: LIST
102841: LIST
102842: PUSH
102843: EMPTY
102844: LIST
102845: LIST
102846: LIST
102847: LIST
102848: LIST
102849: ST_TO_ADDR
// end ; 3 :
102850: GO 103272
102852: LD_INT 3
102854: DOUBLE
102855: EQUAL
102856: IFTRUE 102860
102858: GO 102993
102860: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102861: LD_ADDR_VAR 0 5
102865: PUSH
102866: LD_VAR 0 1
102870: PUSH
102871: LD_INT 3
102873: PLUS
102874: PUSH
102875: LD_VAR 0 2
102879: PUSH
102880: LD_INT 4
102882: PUSH
102883: EMPTY
102884: LIST
102885: LIST
102886: LIST
102887: PUSH
102888: LD_VAR 0 1
102892: PUSH
102893: LD_INT 4
102895: PLUS
102896: PUSH
102897: LD_VAR 0 2
102901: PUSH
102902: LD_INT 4
102904: PLUS
102905: PUSH
102906: LD_INT 5
102908: PUSH
102909: EMPTY
102910: LIST
102911: LIST
102912: LIST
102913: PUSH
102914: LD_VAR 0 1
102918: PUSH
102919: LD_INT 4
102921: MINUS
102922: PUSH
102923: LD_VAR 0 2
102927: PUSH
102928: LD_INT 1
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: LIST
102935: PUSH
102936: LD_VAR 0 1
102940: PUSH
102941: LD_VAR 0 2
102945: PUSH
102946: LD_INT 4
102948: MINUS
102949: PUSH
102950: LD_INT 3
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: LIST
102957: PUSH
102958: LD_VAR 0 1
102962: PUSH
102963: LD_INT 3
102965: MINUS
102966: PUSH
102967: LD_VAR 0 2
102971: PUSH
102972: LD_INT 3
102974: MINUS
102975: PUSH
102976: LD_INT 2
102978: PUSH
102979: EMPTY
102980: LIST
102981: LIST
102982: LIST
102983: PUSH
102984: EMPTY
102985: LIST
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: ST_TO_ADDR
// end ; 4 :
102991: GO 103272
102993: LD_INT 4
102995: DOUBLE
102996: EQUAL
102997: IFTRUE 103001
102999: GO 103134
103001: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103002: LD_ADDR_VAR 0 5
103006: PUSH
103007: LD_VAR 0 1
103011: PUSH
103012: LD_VAR 0 2
103016: PUSH
103017: LD_INT 4
103019: PLUS
103020: PUSH
103021: LD_INT 0
103023: PUSH
103024: EMPTY
103025: LIST
103026: LIST
103027: LIST
103028: PUSH
103029: LD_VAR 0 1
103033: PUSH
103034: LD_INT 3
103036: PLUS
103037: PUSH
103038: LD_VAR 0 2
103042: PUSH
103043: LD_INT 3
103045: PLUS
103046: PUSH
103047: LD_INT 5
103049: PUSH
103050: EMPTY
103051: LIST
103052: LIST
103053: LIST
103054: PUSH
103055: LD_VAR 0 1
103059: PUSH
103060: LD_INT 4
103062: PLUS
103063: PUSH
103064: LD_VAR 0 2
103068: PUSH
103069: LD_INT 4
103071: PUSH
103072: EMPTY
103073: LIST
103074: LIST
103075: LIST
103076: PUSH
103077: LD_VAR 0 1
103081: PUSH
103082: LD_VAR 0 2
103086: PUSH
103087: LD_INT 3
103089: MINUS
103090: PUSH
103091: LD_INT 3
103093: PUSH
103094: EMPTY
103095: LIST
103096: LIST
103097: LIST
103098: PUSH
103099: LD_VAR 0 1
103103: PUSH
103104: LD_INT 4
103106: MINUS
103107: PUSH
103108: LD_VAR 0 2
103112: PUSH
103113: LD_INT 4
103115: MINUS
103116: PUSH
103117: LD_INT 2
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: LIST
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: ST_TO_ADDR
// end ; 5 :
103132: GO 103272
103134: LD_INT 5
103136: DOUBLE
103137: EQUAL
103138: IFTRUE 103142
103140: GO 103271
103142: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103143: LD_ADDR_VAR 0 5
103147: PUSH
103148: LD_VAR 0 1
103152: PUSH
103153: LD_INT 4
103155: MINUS
103156: PUSH
103157: LD_VAR 0 2
103161: PUSH
103162: LD_INT 1
103164: PUSH
103165: EMPTY
103166: LIST
103167: LIST
103168: LIST
103169: PUSH
103170: LD_VAR 0 1
103174: PUSH
103175: LD_VAR 0 2
103179: PUSH
103180: LD_INT 4
103182: MINUS
103183: PUSH
103184: LD_INT 3
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: LIST
103191: PUSH
103192: LD_VAR 0 1
103196: PUSH
103197: LD_INT 4
103199: PLUS
103200: PUSH
103201: LD_VAR 0 2
103205: PUSH
103206: LD_INT 4
103208: PLUS
103209: PUSH
103210: LD_INT 5
103212: PUSH
103213: EMPTY
103214: LIST
103215: LIST
103216: LIST
103217: PUSH
103218: LD_VAR 0 1
103222: PUSH
103223: LD_INT 3
103225: PLUS
103226: PUSH
103227: LD_VAR 0 2
103231: PUSH
103232: LD_INT 4
103234: PUSH
103235: EMPTY
103236: LIST
103237: LIST
103238: LIST
103239: PUSH
103240: LD_VAR 0 1
103244: PUSH
103245: LD_VAR 0 2
103249: PUSH
103250: LD_INT 3
103252: PLUS
103253: PUSH
103254: LD_INT 0
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: LIST
103261: PUSH
103262: EMPTY
103263: LIST
103264: LIST
103265: LIST
103266: LIST
103267: LIST
103268: ST_TO_ADDR
// end ; end ;
103269: GO 103272
103271: POP
// result := list ;
103272: LD_ADDR_VAR 0 4
103276: PUSH
103277: LD_VAR 0 5
103281: ST_TO_ADDR
// end ;
103282: LD_VAR 0 4
103286: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103287: LD_INT 0
103289: PPUSH
103290: PPUSH
103291: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103292: LD_VAR 0 1
103296: NOT
103297: PUSH
103298: LD_VAR 0 2
103302: PUSH
103303: LD_INT 1
103305: PUSH
103306: LD_INT 2
103308: PUSH
103309: LD_INT 3
103311: PUSH
103312: LD_INT 4
103314: PUSH
103315: EMPTY
103316: LIST
103317: LIST
103318: LIST
103319: LIST
103320: IN
103321: NOT
103322: OR
103323: IFFALSE 103327
// exit ;
103325: GO 103419
// tmp := [ ] ;
103327: LD_ADDR_VAR 0 5
103331: PUSH
103332: EMPTY
103333: ST_TO_ADDR
// for i in units do
103334: LD_ADDR_VAR 0 4
103338: PUSH
103339: LD_VAR 0 1
103343: PUSH
103344: FOR_IN
103345: IFFALSE 103388
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103347: LD_ADDR_VAR 0 5
103351: PUSH
103352: LD_VAR 0 5
103356: PPUSH
103357: LD_VAR 0 5
103361: PUSH
103362: LD_INT 1
103364: PLUS
103365: PPUSH
103366: LD_VAR 0 4
103370: PPUSH
103371: LD_VAR 0 2
103375: PPUSH
103376: CALL_OW 259
103380: PPUSH
103381: CALL_OW 2
103385: ST_TO_ADDR
103386: GO 103344
103388: POP
103389: POP
// if not tmp then
103390: LD_VAR 0 5
103394: NOT
103395: IFFALSE 103399
// exit ;
103397: GO 103419
// result := SortListByListDesc ( units , tmp ) ;
103399: LD_ADDR_VAR 0 3
103403: PUSH
103404: LD_VAR 0 1
103408: PPUSH
103409: LD_VAR 0 5
103413: PPUSH
103414: CALL_OW 77
103418: ST_TO_ADDR
// end ;
103419: LD_VAR 0 3
103423: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103424: LD_INT 0
103426: PPUSH
103427: PPUSH
103428: PPUSH
// result := false ;
103429: LD_ADDR_VAR 0 3
103433: PUSH
103434: LD_INT 0
103436: ST_TO_ADDR
// x := GetX ( building ) ;
103437: LD_ADDR_VAR 0 4
103441: PUSH
103442: LD_VAR 0 2
103446: PPUSH
103447: CALL_OW 250
103451: ST_TO_ADDR
// y := GetY ( building ) ;
103452: LD_ADDR_VAR 0 5
103456: PUSH
103457: LD_VAR 0 2
103461: PPUSH
103462: CALL_OW 251
103466: ST_TO_ADDR
// if not building or not x or not y then
103467: LD_VAR 0 2
103471: NOT
103472: PUSH
103473: LD_VAR 0 4
103477: NOT
103478: OR
103479: PUSH
103480: LD_VAR 0 5
103484: NOT
103485: OR
103486: IFFALSE 103490
// exit ;
103488: GO 103582
// if GetTaskList ( unit ) then
103490: LD_VAR 0 1
103494: PPUSH
103495: CALL_OW 437
103499: IFFALSE 103582
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103501: LD_STRING e
103503: PUSH
103504: LD_VAR 0 1
103508: PPUSH
103509: CALL_OW 437
103513: PUSH
103514: LD_INT 1
103516: ARRAY
103517: PUSH
103518: LD_INT 1
103520: ARRAY
103521: EQUAL
103522: PUSH
103523: LD_VAR 0 4
103527: PUSH
103528: LD_VAR 0 1
103532: PPUSH
103533: CALL_OW 437
103537: PUSH
103538: LD_INT 1
103540: ARRAY
103541: PUSH
103542: LD_INT 2
103544: ARRAY
103545: EQUAL
103546: AND
103547: PUSH
103548: LD_VAR 0 5
103552: PUSH
103553: LD_VAR 0 1
103557: PPUSH
103558: CALL_OW 437
103562: PUSH
103563: LD_INT 1
103565: ARRAY
103566: PUSH
103567: LD_INT 3
103569: ARRAY
103570: EQUAL
103571: AND
103572: IFFALSE 103582
// result := true end ;
103574: LD_ADDR_VAR 0 3
103578: PUSH
103579: LD_INT 1
103581: ST_TO_ADDR
// end ;
103582: LD_VAR 0 3
103586: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103587: LD_INT 0
103589: PPUSH
// result := false ;
103590: LD_ADDR_VAR 0 4
103594: PUSH
103595: LD_INT 0
103597: ST_TO_ADDR
// if GetTaskList ( unit ) then
103598: LD_VAR 0 1
103602: PPUSH
103603: CALL_OW 437
103607: IFFALSE 103690
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103609: LD_STRING M
103611: PUSH
103612: LD_VAR 0 1
103616: PPUSH
103617: CALL_OW 437
103621: PUSH
103622: LD_INT 1
103624: ARRAY
103625: PUSH
103626: LD_INT 1
103628: ARRAY
103629: EQUAL
103630: PUSH
103631: LD_VAR 0 2
103635: PUSH
103636: LD_VAR 0 1
103640: PPUSH
103641: CALL_OW 437
103645: PUSH
103646: LD_INT 1
103648: ARRAY
103649: PUSH
103650: LD_INT 2
103652: ARRAY
103653: EQUAL
103654: AND
103655: PUSH
103656: LD_VAR 0 3
103660: PUSH
103661: LD_VAR 0 1
103665: PPUSH
103666: CALL_OW 437
103670: PUSH
103671: LD_INT 1
103673: ARRAY
103674: PUSH
103675: LD_INT 3
103677: ARRAY
103678: EQUAL
103679: AND
103680: IFFALSE 103690
// result := true ;
103682: LD_ADDR_VAR 0 4
103686: PUSH
103687: LD_INT 1
103689: ST_TO_ADDR
// end ; end ;
103690: LD_VAR 0 4
103694: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103695: LD_INT 0
103697: PPUSH
103698: PPUSH
103699: PPUSH
103700: PPUSH
// if not unit or not area then
103701: LD_VAR 0 1
103705: NOT
103706: PUSH
103707: LD_VAR 0 2
103711: NOT
103712: OR
103713: IFFALSE 103717
// exit ;
103715: GO 103881
// tmp := AreaToList ( area , i ) ;
103717: LD_ADDR_VAR 0 6
103721: PUSH
103722: LD_VAR 0 2
103726: PPUSH
103727: LD_VAR 0 5
103731: PPUSH
103732: CALL_OW 517
103736: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103737: LD_ADDR_VAR 0 5
103741: PUSH
103742: DOUBLE
103743: LD_INT 1
103745: DEC
103746: ST_TO_ADDR
103747: LD_VAR 0 6
103751: PUSH
103752: LD_INT 1
103754: ARRAY
103755: PUSH
103756: FOR_TO
103757: IFFALSE 103879
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103759: LD_ADDR_VAR 0 7
103763: PUSH
103764: LD_VAR 0 6
103768: PUSH
103769: LD_INT 1
103771: ARRAY
103772: PUSH
103773: LD_VAR 0 5
103777: ARRAY
103778: PUSH
103779: LD_VAR 0 6
103783: PUSH
103784: LD_INT 2
103786: ARRAY
103787: PUSH
103788: LD_VAR 0 5
103792: ARRAY
103793: PUSH
103794: EMPTY
103795: LIST
103796: LIST
103797: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103798: LD_VAR 0 7
103802: PUSH
103803: LD_INT 1
103805: ARRAY
103806: PPUSH
103807: LD_VAR 0 7
103811: PUSH
103812: LD_INT 2
103814: ARRAY
103815: PPUSH
103816: CALL_OW 428
103820: PUSH
103821: LD_INT 0
103823: EQUAL
103824: IFFALSE 103877
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103826: LD_VAR 0 1
103830: PPUSH
103831: LD_VAR 0 7
103835: PUSH
103836: LD_INT 1
103838: ARRAY
103839: PPUSH
103840: LD_VAR 0 7
103844: PUSH
103845: LD_INT 2
103847: ARRAY
103848: PPUSH
103849: LD_VAR 0 3
103853: PPUSH
103854: CALL_OW 48
// result := IsPlaced ( unit ) ;
103858: LD_ADDR_VAR 0 4
103862: PUSH
103863: LD_VAR 0 1
103867: PPUSH
103868: CALL_OW 305
103872: ST_TO_ADDR
// exit ;
103873: POP
103874: POP
103875: GO 103881
// end ; end ;
103877: GO 103756
103879: POP
103880: POP
// end ;
103881: LD_VAR 0 4
103885: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103886: LD_INT 0
103888: PPUSH
103889: PPUSH
103890: PPUSH
// if not side or side > 8 then
103891: LD_VAR 0 1
103895: NOT
103896: PUSH
103897: LD_VAR 0 1
103901: PUSH
103902: LD_INT 8
103904: GREATER
103905: OR
103906: IFFALSE 103910
// exit ;
103908: GO 104097
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103910: LD_ADDR_VAR 0 4
103914: PUSH
103915: LD_INT 22
103917: PUSH
103918: LD_VAR 0 1
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 21
103929: PUSH
103930: LD_INT 3
103932: PUSH
103933: EMPTY
103934: LIST
103935: LIST
103936: PUSH
103937: EMPTY
103938: LIST
103939: LIST
103940: PPUSH
103941: CALL_OW 69
103945: ST_TO_ADDR
// if not tmp then
103946: LD_VAR 0 4
103950: NOT
103951: IFFALSE 103955
// exit ;
103953: GO 104097
// enable_addtolog := true ;
103955: LD_ADDR_OWVAR 81
103959: PUSH
103960: LD_INT 1
103962: ST_TO_ADDR
// AddToLog ( [ ) ;
103963: LD_STRING [
103965: PPUSH
103966: CALL_OW 561
// for i in tmp do
103970: LD_ADDR_VAR 0 3
103974: PUSH
103975: LD_VAR 0 4
103979: PUSH
103980: FOR_IN
103981: IFFALSE 104088
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103983: LD_STRING [
103985: PUSH
103986: LD_VAR 0 3
103990: PPUSH
103991: CALL_OW 266
103995: STR
103996: PUSH
103997: LD_STRING , 
103999: STR
104000: PUSH
104001: LD_VAR 0 3
104005: PPUSH
104006: CALL_OW 250
104010: STR
104011: PUSH
104012: LD_STRING , 
104014: STR
104015: PUSH
104016: LD_VAR 0 3
104020: PPUSH
104021: CALL_OW 251
104025: STR
104026: PUSH
104027: LD_STRING , 
104029: STR
104030: PUSH
104031: LD_VAR 0 3
104035: PPUSH
104036: CALL_OW 254
104040: STR
104041: PUSH
104042: LD_STRING , 
104044: STR
104045: PUSH
104046: LD_VAR 0 3
104050: PPUSH
104051: LD_INT 1
104053: PPUSH
104054: CALL_OW 268
104058: STR
104059: PUSH
104060: LD_STRING , 
104062: STR
104063: PUSH
104064: LD_VAR 0 3
104068: PPUSH
104069: LD_INT 2
104071: PPUSH
104072: CALL_OW 268
104076: STR
104077: PUSH
104078: LD_STRING ],
104080: STR
104081: PPUSH
104082: CALL_OW 561
// end ;
104086: GO 103980
104088: POP
104089: POP
// AddToLog ( ]; ) ;
104090: LD_STRING ];
104092: PPUSH
104093: CALL_OW 561
// end ;
104097: LD_VAR 0 2
104101: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104102: LD_INT 0
104104: PPUSH
104105: PPUSH
104106: PPUSH
104107: PPUSH
104108: PPUSH
// if not area or not rate or not max then
104109: LD_VAR 0 1
104113: NOT
104114: PUSH
104115: LD_VAR 0 2
104119: NOT
104120: OR
104121: PUSH
104122: LD_VAR 0 4
104126: NOT
104127: OR
104128: IFFALSE 104132
// exit ;
104130: GO 104321
// while 1 do
104132: LD_INT 1
104134: IFFALSE 104321
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104136: LD_ADDR_VAR 0 9
104140: PUSH
104141: LD_VAR 0 1
104145: PPUSH
104146: LD_INT 1
104148: PPUSH
104149: CALL_OW 287
104153: PUSH
104154: LD_INT 10
104156: MUL
104157: ST_TO_ADDR
// r := rate / 10 ;
104158: LD_ADDR_VAR 0 7
104162: PUSH
104163: LD_VAR 0 2
104167: PUSH
104168: LD_INT 10
104170: DIVREAL
104171: ST_TO_ADDR
// time := 1 1$00 ;
104172: LD_ADDR_VAR 0 8
104176: PUSH
104177: LD_INT 2100
104179: ST_TO_ADDR
// if amount < min then
104180: LD_VAR 0 9
104184: PUSH
104185: LD_VAR 0 3
104189: LESS
104190: IFFALSE 104208
// r := r * 2 else
104192: LD_ADDR_VAR 0 7
104196: PUSH
104197: LD_VAR 0 7
104201: PUSH
104202: LD_INT 2
104204: MUL
104205: ST_TO_ADDR
104206: GO 104234
// if amount > max then
104208: LD_VAR 0 9
104212: PUSH
104213: LD_VAR 0 4
104217: GREATER
104218: IFFALSE 104234
// r := r / 2 ;
104220: LD_ADDR_VAR 0 7
104224: PUSH
104225: LD_VAR 0 7
104229: PUSH
104230: LD_INT 2
104232: DIVREAL
104233: ST_TO_ADDR
// time := time / r ;
104234: LD_ADDR_VAR 0 8
104238: PUSH
104239: LD_VAR 0 8
104243: PUSH
104244: LD_VAR 0 7
104248: DIVREAL
104249: ST_TO_ADDR
// if time < 0 then
104250: LD_VAR 0 8
104254: PUSH
104255: LD_INT 0
104257: LESS
104258: IFFALSE 104275
// time := time * - 1 ;
104260: LD_ADDR_VAR 0 8
104264: PUSH
104265: LD_VAR 0 8
104269: PUSH
104270: LD_INT 1
104272: NEG
104273: MUL
104274: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104275: LD_VAR 0 8
104279: PUSH
104280: LD_INT 35
104282: PPUSH
104283: LD_INT 875
104285: PPUSH
104286: CALL_OW 12
104290: PLUS
104291: PPUSH
104292: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104296: LD_INT 1
104298: PPUSH
104299: LD_INT 5
104301: PPUSH
104302: CALL_OW 12
104306: PPUSH
104307: LD_VAR 0 1
104311: PPUSH
104312: LD_INT 1
104314: PPUSH
104315: CALL_OW 55
// end ;
104319: GO 104132
// end ;
104321: LD_VAR 0 5
104325: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104326: LD_INT 0
104328: PPUSH
104329: PPUSH
104330: PPUSH
104331: PPUSH
104332: PPUSH
104333: PPUSH
104334: PPUSH
104335: PPUSH
// if not turrets or not factories then
104336: LD_VAR 0 1
104340: NOT
104341: PUSH
104342: LD_VAR 0 2
104346: NOT
104347: OR
104348: IFFALSE 104352
// exit ;
104350: GO 104659
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104352: LD_ADDR_VAR 0 10
104356: PUSH
104357: LD_INT 5
104359: PUSH
104360: LD_INT 6
104362: PUSH
104363: EMPTY
104364: LIST
104365: LIST
104366: PUSH
104367: LD_INT 2
104369: PUSH
104370: LD_INT 4
104372: PUSH
104373: EMPTY
104374: LIST
104375: LIST
104376: PUSH
104377: LD_INT 3
104379: PUSH
104380: LD_INT 5
104382: PUSH
104383: EMPTY
104384: LIST
104385: LIST
104386: PUSH
104387: EMPTY
104388: LIST
104389: LIST
104390: LIST
104391: PUSH
104392: LD_INT 24
104394: PUSH
104395: LD_INT 25
104397: PUSH
104398: EMPTY
104399: LIST
104400: LIST
104401: PUSH
104402: LD_INT 23
104404: PUSH
104405: LD_INT 27
104407: PUSH
104408: EMPTY
104409: LIST
104410: LIST
104411: PUSH
104412: EMPTY
104413: LIST
104414: LIST
104415: PUSH
104416: LD_INT 42
104418: PUSH
104419: LD_INT 43
104421: PUSH
104422: EMPTY
104423: LIST
104424: LIST
104425: PUSH
104426: LD_INT 44
104428: PUSH
104429: LD_INT 46
104431: PUSH
104432: EMPTY
104433: LIST
104434: LIST
104435: PUSH
104436: LD_INT 45
104438: PUSH
104439: LD_INT 47
104441: PUSH
104442: EMPTY
104443: LIST
104444: LIST
104445: PUSH
104446: EMPTY
104447: LIST
104448: LIST
104449: LIST
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: LIST
104455: ST_TO_ADDR
// result := [ ] ;
104456: LD_ADDR_VAR 0 3
104460: PUSH
104461: EMPTY
104462: ST_TO_ADDR
// for i in turrets do
104463: LD_ADDR_VAR 0 4
104467: PUSH
104468: LD_VAR 0 1
104472: PUSH
104473: FOR_IN
104474: IFFALSE 104657
// begin nat := GetNation ( i ) ;
104476: LD_ADDR_VAR 0 7
104480: PUSH
104481: LD_VAR 0 4
104485: PPUSH
104486: CALL_OW 248
104490: ST_TO_ADDR
// weapon := 0 ;
104491: LD_ADDR_VAR 0 8
104495: PUSH
104496: LD_INT 0
104498: ST_TO_ADDR
// if not nat then
104499: LD_VAR 0 7
104503: NOT
104504: IFFALSE 104508
// continue ;
104506: GO 104473
// for j in list [ nat ] do
104508: LD_ADDR_VAR 0 5
104512: PUSH
104513: LD_VAR 0 10
104517: PUSH
104518: LD_VAR 0 7
104522: ARRAY
104523: PUSH
104524: FOR_IN
104525: IFFALSE 104566
// if GetBWeapon ( i ) = j [ 1 ] then
104527: LD_VAR 0 4
104531: PPUSH
104532: CALL_OW 269
104536: PUSH
104537: LD_VAR 0 5
104541: PUSH
104542: LD_INT 1
104544: ARRAY
104545: EQUAL
104546: IFFALSE 104564
// begin weapon := j [ 2 ] ;
104548: LD_ADDR_VAR 0 8
104552: PUSH
104553: LD_VAR 0 5
104557: PUSH
104558: LD_INT 2
104560: ARRAY
104561: ST_TO_ADDR
// break ;
104562: GO 104566
// end ;
104564: GO 104524
104566: POP
104567: POP
// if not weapon then
104568: LD_VAR 0 8
104572: NOT
104573: IFFALSE 104577
// continue ;
104575: GO 104473
// for k in factories do
104577: LD_ADDR_VAR 0 6
104581: PUSH
104582: LD_VAR 0 2
104586: PUSH
104587: FOR_IN
104588: IFFALSE 104653
// begin weapons := AvailableWeaponList ( k ) ;
104590: LD_ADDR_VAR 0 9
104594: PUSH
104595: LD_VAR 0 6
104599: PPUSH
104600: CALL_OW 478
104604: ST_TO_ADDR
// if not weapons then
104605: LD_VAR 0 9
104609: NOT
104610: IFFALSE 104614
// continue ;
104612: GO 104587
// if weapon in weapons then
104614: LD_VAR 0 8
104618: PUSH
104619: LD_VAR 0 9
104623: IN
104624: IFFALSE 104651
// begin result := [ i , weapon ] ;
104626: LD_ADDR_VAR 0 3
104630: PUSH
104631: LD_VAR 0 4
104635: PUSH
104636: LD_VAR 0 8
104640: PUSH
104641: EMPTY
104642: LIST
104643: LIST
104644: ST_TO_ADDR
// exit ;
104645: POP
104646: POP
104647: POP
104648: POP
104649: GO 104659
// end ; end ;
104651: GO 104587
104653: POP
104654: POP
// end ;
104655: GO 104473
104657: POP
104658: POP
// end ;
104659: LD_VAR 0 3
104663: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104664: LD_INT 0
104666: PPUSH
// if not side or side > 8 then
104667: LD_VAR 0 3
104671: NOT
104672: PUSH
104673: LD_VAR 0 3
104677: PUSH
104678: LD_INT 8
104680: GREATER
104681: OR
104682: IFFALSE 104686
// exit ;
104684: GO 104745
// if not range then
104686: LD_VAR 0 4
104690: NOT
104691: IFFALSE 104702
// range := - 12 ;
104693: LD_ADDR_VAR 0 4
104697: PUSH
104698: LD_INT 12
104700: NEG
104701: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104702: LD_VAR 0 1
104706: PPUSH
104707: LD_VAR 0 2
104711: PPUSH
104712: LD_VAR 0 3
104716: PPUSH
104717: LD_VAR 0 4
104721: PPUSH
104722: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104726: LD_VAR 0 1
104730: PPUSH
104731: LD_VAR 0 2
104735: PPUSH
104736: LD_VAR 0 3
104740: PPUSH
104741: CALL_OW 331
// end ;
104745: LD_VAR 0 5
104749: RET
// export function Video ( mode ) ; begin
104750: LD_INT 0
104752: PPUSH
// ingame_video = mode ;
104753: LD_ADDR_OWVAR 52
104757: PUSH
104758: LD_VAR 0 1
104762: ST_TO_ADDR
// interface_hidden = mode ;
104763: LD_ADDR_OWVAR 54
104767: PUSH
104768: LD_VAR 0 1
104772: ST_TO_ADDR
// end ;
104773: LD_VAR 0 2
104777: RET
// export function Join ( array , element ) ; begin
104778: LD_INT 0
104780: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104781: LD_ADDR_VAR 0 3
104785: PUSH
104786: LD_VAR 0 1
104790: PPUSH
104791: LD_VAR 0 1
104795: PUSH
104796: LD_INT 1
104798: PLUS
104799: PPUSH
104800: LD_VAR 0 2
104804: PPUSH
104805: CALL_OW 1
104809: ST_TO_ADDR
// end ;
104810: LD_VAR 0 3
104814: RET
// export function JoinUnion ( array , element ) ; begin
104815: LD_INT 0
104817: PPUSH
// result := array union element ;
104818: LD_ADDR_VAR 0 3
104822: PUSH
104823: LD_VAR 0 1
104827: PUSH
104828: LD_VAR 0 2
104832: UNION
104833: ST_TO_ADDR
// end ;
104834: LD_VAR 0 3
104838: RET
// export function GetBehemoths ( side ) ; begin
104839: LD_INT 0
104841: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
104842: LD_ADDR_VAR 0 2
104846: PUSH
104847: LD_INT 22
104849: PUSH
104850: LD_VAR 0 1
104854: PUSH
104855: EMPTY
104856: LIST
104857: LIST
104858: PUSH
104859: LD_INT 31
104861: PUSH
104862: LD_INT 25
104864: PUSH
104865: EMPTY
104866: LIST
104867: LIST
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: PPUSH
104873: CALL_OW 69
104877: ST_TO_ADDR
// end ;
104878: LD_VAR 0 2
104882: RET
// export function Shuffle ( array ) ; var i , index ; begin
104883: LD_INT 0
104885: PPUSH
104886: PPUSH
104887: PPUSH
// result := [ ] ;
104888: LD_ADDR_VAR 0 2
104892: PUSH
104893: EMPTY
104894: ST_TO_ADDR
// if not array then
104895: LD_VAR 0 1
104899: NOT
104900: IFFALSE 104904
// exit ;
104902: GO 105003
// Randomize ;
104904: CALL_OW 10
// for i = array downto 1 do
104908: LD_ADDR_VAR 0 3
104912: PUSH
104913: DOUBLE
104914: LD_VAR 0 1
104918: INC
104919: ST_TO_ADDR
104920: LD_INT 1
104922: PUSH
104923: FOR_DOWNTO
104924: IFFALSE 105001
// begin index := rand ( 1 , array ) ;
104926: LD_ADDR_VAR 0 4
104930: PUSH
104931: LD_INT 1
104933: PPUSH
104934: LD_VAR 0 1
104938: PPUSH
104939: CALL_OW 12
104943: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104944: LD_ADDR_VAR 0 2
104948: PUSH
104949: LD_VAR 0 2
104953: PPUSH
104954: LD_VAR 0 2
104958: PUSH
104959: LD_INT 1
104961: PLUS
104962: PPUSH
104963: LD_VAR 0 1
104967: PUSH
104968: LD_VAR 0 4
104972: ARRAY
104973: PPUSH
104974: CALL_OW 2
104978: ST_TO_ADDR
// array := Delete ( array , index ) ;
104979: LD_ADDR_VAR 0 1
104983: PUSH
104984: LD_VAR 0 1
104988: PPUSH
104989: LD_VAR 0 4
104993: PPUSH
104994: CALL_OW 3
104998: ST_TO_ADDR
// end ;
104999: GO 104923
105001: POP
105002: POP
// end ;
105003: LD_VAR 0 2
105007: RET
// export function GetBaseMaterials ( base ) ; begin
105008: LD_INT 0
105010: PPUSH
// result := [ 0 , 0 , 0 ] ;
105011: LD_ADDR_VAR 0 2
105015: PUSH
105016: LD_INT 0
105018: PUSH
105019: LD_INT 0
105021: PUSH
105022: LD_INT 0
105024: PUSH
105025: EMPTY
105026: LIST
105027: LIST
105028: LIST
105029: ST_TO_ADDR
// if not base then
105030: LD_VAR 0 1
105034: NOT
105035: IFFALSE 105039
// exit ;
105037: GO 105088
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105039: LD_ADDR_VAR 0 2
105043: PUSH
105044: LD_VAR 0 1
105048: PPUSH
105049: LD_INT 1
105051: PPUSH
105052: CALL_OW 275
105056: PUSH
105057: LD_VAR 0 1
105061: PPUSH
105062: LD_INT 2
105064: PPUSH
105065: CALL_OW 275
105069: PUSH
105070: LD_VAR 0 1
105074: PPUSH
105075: LD_INT 3
105077: PPUSH
105078: CALL_OW 275
105082: PUSH
105083: EMPTY
105084: LIST
105085: LIST
105086: LIST
105087: ST_TO_ADDR
// end ;
105088: LD_VAR 0 2
105092: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105093: LD_INT 0
105095: PPUSH
105096: PPUSH
// result := array ;
105097: LD_ADDR_VAR 0 3
105101: PUSH
105102: LD_VAR 0 1
105106: ST_TO_ADDR
// if size >= result then
105107: LD_VAR 0 2
105111: PUSH
105112: LD_VAR 0 3
105116: GREATEREQUAL
105117: IFFALSE 105121
// exit ;
105119: GO 105171
// if size then
105121: LD_VAR 0 2
105125: IFFALSE 105171
// for i := array downto size do
105127: LD_ADDR_VAR 0 4
105131: PUSH
105132: DOUBLE
105133: LD_VAR 0 1
105137: INC
105138: ST_TO_ADDR
105139: LD_VAR 0 2
105143: PUSH
105144: FOR_DOWNTO
105145: IFFALSE 105169
// result := Delete ( result , result ) ;
105147: LD_ADDR_VAR 0 3
105151: PUSH
105152: LD_VAR 0 3
105156: PPUSH
105157: LD_VAR 0 3
105161: PPUSH
105162: CALL_OW 3
105166: ST_TO_ADDR
105167: GO 105144
105169: POP
105170: POP
// end ;
105171: LD_VAR 0 3
105175: RET
// export function ComExit ( unit ) ; var tmp ; begin
105176: LD_INT 0
105178: PPUSH
105179: PPUSH
// if not IsInUnit ( unit ) then
105180: LD_VAR 0 1
105184: PPUSH
105185: CALL_OW 310
105189: NOT
105190: IFFALSE 105194
// exit ;
105192: GO 105254
// tmp := IsInUnit ( unit ) ;
105194: LD_ADDR_VAR 0 3
105198: PUSH
105199: LD_VAR 0 1
105203: PPUSH
105204: CALL_OW 310
105208: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105209: LD_VAR 0 3
105213: PPUSH
105214: CALL_OW 247
105218: PUSH
105219: LD_INT 2
105221: EQUAL
105222: IFFALSE 105235
// ComExitVehicle ( unit ) else
105224: LD_VAR 0 1
105228: PPUSH
105229: CALL_OW 121
105233: GO 105244
// ComExitBuilding ( unit ) ;
105235: LD_VAR 0 1
105239: PPUSH
105240: CALL_OW 122
// result := tmp ;
105244: LD_ADDR_VAR 0 2
105248: PUSH
105249: LD_VAR 0 3
105253: ST_TO_ADDR
// end ;
105254: LD_VAR 0 2
105258: RET
// export function ComExitAll ( units ) ; var i ; begin
105259: LD_INT 0
105261: PPUSH
105262: PPUSH
// if not units then
105263: LD_VAR 0 1
105267: NOT
105268: IFFALSE 105272
// exit ;
105270: GO 105298
// for i in units do
105272: LD_ADDR_VAR 0 3
105276: PUSH
105277: LD_VAR 0 1
105281: PUSH
105282: FOR_IN
105283: IFFALSE 105296
// ComExit ( i ) ;
105285: LD_VAR 0 3
105289: PPUSH
105290: CALL 105176 0 1
105294: GO 105282
105296: POP
105297: POP
// end ;
105298: LD_VAR 0 2
105302: RET
// export function ResetHc ; begin
105303: LD_INT 0
105305: PPUSH
// InitHc ;
105306: CALL_OW 19
// hc_importance := 0 ;
105310: LD_ADDR_OWVAR 32
105314: PUSH
105315: LD_INT 0
105317: ST_TO_ADDR
// end ;
105318: LD_VAR 0 1
105322: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105323: LD_INT 0
105325: PPUSH
105326: PPUSH
105327: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105328: LD_ADDR_VAR 0 6
105332: PUSH
105333: LD_VAR 0 1
105337: PUSH
105338: LD_VAR 0 3
105342: PLUS
105343: PUSH
105344: LD_INT 2
105346: DIV
105347: ST_TO_ADDR
// if _x < 0 then
105348: LD_VAR 0 6
105352: PUSH
105353: LD_INT 0
105355: LESS
105356: IFFALSE 105373
// _x := _x * - 1 ;
105358: LD_ADDR_VAR 0 6
105362: PUSH
105363: LD_VAR 0 6
105367: PUSH
105368: LD_INT 1
105370: NEG
105371: MUL
105372: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105373: LD_ADDR_VAR 0 7
105377: PUSH
105378: LD_VAR 0 2
105382: PUSH
105383: LD_VAR 0 4
105387: PLUS
105388: PUSH
105389: LD_INT 2
105391: DIV
105392: ST_TO_ADDR
// if _y < 0 then
105393: LD_VAR 0 7
105397: PUSH
105398: LD_INT 0
105400: LESS
105401: IFFALSE 105418
// _y := _y * - 1 ;
105403: LD_ADDR_VAR 0 7
105407: PUSH
105408: LD_VAR 0 7
105412: PUSH
105413: LD_INT 1
105415: NEG
105416: MUL
105417: ST_TO_ADDR
// result := [ _x , _y ] ;
105418: LD_ADDR_VAR 0 5
105422: PUSH
105423: LD_VAR 0 6
105427: PUSH
105428: LD_VAR 0 7
105432: PUSH
105433: EMPTY
105434: LIST
105435: LIST
105436: ST_TO_ADDR
// end ;
105437: LD_VAR 0 5
105441: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105442: LD_INT 0
105444: PPUSH
105445: PPUSH
105446: PPUSH
105447: PPUSH
// task := GetTaskList ( unit ) ;
105448: LD_ADDR_VAR 0 7
105452: PUSH
105453: LD_VAR 0 1
105457: PPUSH
105458: CALL_OW 437
105462: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105463: LD_VAR 0 7
105467: NOT
105468: PUSH
105469: LD_VAR 0 1
105473: PPUSH
105474: LD_VAR 0 2
105478: PPUSH
105479: CALL_OW 308
105483: NOT
105484: AND
105485: IFFALSE 105489
// exit ;
105487: GO 105607
// if IsInArea ( unit , area ) then
105489: LD_VAR 0 1
105493: PPUSH
105494: LD_VAR 0 2
105498: PPUSH
105499: CALL_OW 308
105503: IFFALSE 105521
// begin ComMoveToArea ( unit , goAway ) ;
105505: LD_VAR 0 1
105509: PPUSH
105510: LD_VAR 0 3
105514: PPUSH
105515: CALL_OW 113
// exit ;
105519: GO 105607
// end ; if task [ 1 ] [ 1 ] <> M then
105521: LD_VAR 0 7
105525: PUSH
105526: LD_INT 1
105528: ARRAY
105529: PUSH
105530: LD_INT 1
105532: ARRAY
105533: PUSH
105534: LD_STRING M
105536: NONEQUAL
105537: IFFALSE 105541
// exit ;
105539: GO 105607
// x := task [ 1 ] [ 2 ] ;
105541: LD_ADDR_VAR 0 5
105545: PUSH
105546: LD_VAR 0 7
105550: PUSH
105551: LD_INT 1
105553: ARRAY
105554: PUSH
105555: LD_INT 2
105557: ARRAY
105558: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105559: LD_ADDR_VAR 0 6
105563: PUSH
105564: LD_VAR 0 7
105568: PUSH
105569: LD_INT 1
105571: ARRAY
105572: PUSH
105573: LD_INT 3
105575: ARRAY
105576: ST_TO_ADDR
// if InArea ( x , y , area ) then
105577: LD_VAR 0 5
105581: PPUSH
105582: LD_VAR 0 6
105586: PPUSH
105587: LD_VAR 0 2
105591: PPUSH
105592: CALL_OW 309
105596: IFFALSE 105607
// ComStop ( unit ) ;
105598: LD_VAR 0 1
105602: PPUSH
105603: CALL_OW 141
// end ;
105607: LD_VAR 0 4
105611: RET
// export function Abs ( value ) ; begin
105612: LD_INT 0
105614: PPUSH
// result := value ;
105615: LD_ADDR_VAR 0 2
105619: PUSH
105620: LD_VAR 0 1
105624: ST_TO_ADDR
// if value < 0 then
105625: LD_VAR 0 1
105629: PUSH
105630: LD_INT 0
105632: LESS
105633: IFFALSE 105650
// result := value * - 1 ;
105635: LD_ADDR_VAR 0 2
105639: PUSH
105640: LD_VAR 0 1
105644: PUSH
105645: LD_INT 1
105647: NEG
105648: MUL
105649: ST_TO_ADDR
// end ;
105650: LD_VAR 0 2
105654: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105655: LD_INT 0
105657: PPUSH
105658: PPUSH
105659: PPUSH
105660: PPUSH
105661: PPUSH
105662: PPUSH
105663: PPUSH
105664: PPUSH
// if not unit or not building then
105665: LD_VAR 0 1
105669: NOT
105670: PUSH
105671: LD_VAR 0 2
105675: NOT
105676: OR
105677: IFFALSE 105681
// exit ;
105679: GO 105907
// x := GetX ( building ) ;
105681: LD_ADDR_VAR 0 4
105685: PUSH
105686: LD_VAR 0 2
105690: PPUSH
105691: CALL_OW 250
105695: ST_TO_ADDR
// y := GetY ( building ) ;
105696: LD_ADDR_VAR 0 6
105700: PUSH
105701: LD_VAR 0 2
105705: PPUSH
105706: CALL_OW 251
105710: ST_TO_ADDR
// d := GetDir ( building ) ;
105711: LD_ADDR_VAR 0 8
105715: PUSH
105716: LD_VAR 0 2
105720: PPUSH
105721: CALL_OW 254
105725: ST_TO_ADDR
// r := 4 ;
105726: LD_ADDR_VAR 0 9
105730: PUSH
105731: LD_INT 4
105733: ST_TO_ADDR
// for i := 1 to 5 do
105734: LD_ADDR_VAR 0 10
105738: PUSH
105739: DOUBLE
105740: LD_INT 1
105742: DEC
105743: ST_TO_ADDR
105744: LD_INT 5
105746: PUSH
105747: FOR_TO
105748: IFFALSE 105905
// begin _x := ShiftX ( x , d , r + i ) ;
105750: LD_ADDR_VAR 0 5
105754: PUSH
105755: LD_VAR 0 4
105759: PPUSH
105760: LD_VAR 0 8
105764: PPUSH
105765: LD_VAR 0 9
105769: PUSH
105770: LD_VAR 0 10
105774: PLUS
105775: PPUSH
105776: CALL_OW 272
105780: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105781: LD_ADDR_VAR 0 7
105785: PUSH
105786: LD_VAR 0 6
105790: PPUSH
105791: LD_VAR 0 8
105795: PPUSH
105796: LD_VAR 0 9
105800: PUSH
105801: LD_VAR 0 10
105805: PLUS
105806: PPUSH
105807: CALL_OW 273
105811: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105812: LD_VAR 0 5
105816: PPUSH
105817: LD_VAR 0 7
105821: PPUSH
105822: CALL_OW 488
105826: PUSH
105827: LD_VAR 0 5
105831: PPUSH
105832: LD_VAR 0 7
105836: PPUSH
105837: CALL_OW 428
105841: PPUSH
105842: CALL_OW 247
105846: PUSH
105847: LD_INT 3
105849: PUSH
105850: LD_INT 2
105852: PUSH
105853: EMPTY
105854: LIST
105855: LIST
105856: IN
105857: NOT
105858: AND
105859: IFFALSE 105903
// begin ComMoveXY ( unit , _x , _y ) ;
105861: LD_VAR 0 1
105865: PPUSH
105866: LD_VAR 0 5
105870: PPUSH
105871: LD_VAR 0 7
105875: PPUSH
105876: CALL_OW 111
// result := [ _x , _y ] ;
105880: LD_ADDR_VAR 0 3
105884: PUSH
105885: LD_VAR 0 5
105889: PUSH
105890: LD_VAR 0 7
105894: PUSH
105895: EMPTY
105896: LIST
105897: LIST
105898: ST_TO_ADDR
// exit ;
105899: POP
105900: POP
105901: GO 105907
// end ; end ;
105903: GO 105747
105905: POP
105906: POP
// end ;
105907: LD_VAR 0 3
105911: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
105912: LD_INT 0
105914: PPUSH
105915: PPUSH
105916: PPUSH
// result := 0 ;
105917: LD_ADDR_VAR 0 3
105921: PUSH
105922: LD_INT 0
105924: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
105925: LD_VAR 0 1
105929: PUSH
105930: LD_INT 0
105932: LESS
105933: PUSH
105934: LD_VAR 0 1
105938: PUSH
105939: LD_INT 8
105941: GREATER
105942: OR
105943: PUSH
105944: LD_VAR 0 2
105948: PUSH
105949: LD_INT 0
105951: LESS
105952: OR
105953: PUSH
105954: LD_VAR 0 2
105958: PUSH
105959: LD_INT 8
105961: GREATER
105962: OR
105963: IFFALSE 105967
// exit ;
105965: GO 106042
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
105967: LD_ADDR_VAR 0 4
105971: PUSH
105972: LD_INT 22
105974: PUSH
105975: LD_VAR 0 2
105979: PUSH
105980: EMPTY
105981: LIST
105982: LIST
105983: PPUSH
105984: CALL_OW 69
105988: PUSH
105989: FOR_IN
105990: IFFALSE 106040
// begin un := UnitShoot ( i ) ;
105992: LD_ADDR_VAR 0 5
105996: PUSH
105997: LD_VAR 0 4
106001: PPUSH
106002: CALL_OW 504
106006: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106007: LD_VAR 0 5
106011: PPUSH
106012: CALL_OW 255
106016: PUSH
106017: LD_VAR 0 1
106021: EQUAL
106022: IFFALSE 106038
// begin result := un ;
106024: LD_ADDR_VAR 0 3
106028: PUSH
106029: LD_VAR 0 5
106033: ST_TO_ADDR
// exit ;
106034: POP
106035: POP
106036: GO 106042
// end ; end ;
106038: GO 105989
106040: POP
106041: POP
// end ;
106042: LD_VAR 0 3
106046: RET
// export function GetCargoBay ( units ) ; begin
106047: LD_INT 0
106049: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106050: LD_ADDR_VAR 0 2
106054: PUSH
106055: LD_VAR 0 1
106059: PPUSH
106060: LD_INT 2
106062: PUSH
106063: LD_INT 34
106065: PUSH
106066: LD_INT 12
106068: PUSH
106069: EMPTY
106070: LIST
106071: LIST
106072: PUSH
106073: LD_INT 34
106075: PUSH
106076: LD_INT 51
106078: PUSH
106079: EMPTY
106080: LIST
106081: LIST
106082: PUSH
106083: LD_INT 34
106085: PUSH
106086: LD_INT 32
106088: PUSH
106089: EMPTY
106090: LIST
106091: LIST
106092: PUSH
106093: LD_INT 34
106095: PUSH
106096: LD_INT 89
106098: PUSH
106099: EMPTY
106100: LIST
106101: LIST
106102: PUSH
106103: EMPTY
106104: LIST
106105: LIST
106106: LIST
106107: LIST
106108: LIST
106109: PPUSH
106110: CALL_OW 72
106114: ST_TO_ADDR
// end ;
106115: LD_VAR 0 2
106119: RET
// export function Negate ( value ) ; begin
106120: LD_INT 0
106122: PPUSH
// result := not value ;
106123: LD_ADDR_VAR 0 2
106127: PUSH
106128: LD_VAR 0 1
106132: NOT
106133: ST_TO_ADDR
// end ;
106134: LD_VAR 0 2
106138: RET
// export function Inc ( value ) ; begin
106139: LD_INT 0
106141: PPUSH
// result := value + 1 ;
106142: LD_ADDR_VAR 0 2
106146: PUSH
106147: LD_VAR 0 1
106151: PUSH
106152: LD_INT 1
106154: PLUS
106155: ST_TO_ADDR
// end ;
106156: LD_VAR 0 2
106160: RET
// export function Dec ( value ) ; begin
106161: LD_INT 0
106163: PPUSH
// result := value - 1 ;
106164: LD_ADDR_VAR 0 2
106168: PUSH
106169: LD_VAR 0 1
106173: PUSH
106174: LD_INT 1
106176: MINUS
106177: ST_TO_ADDR
// end ;
106178: LD_VAR 0 2
106182: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106183: LD_INT 0
106185: PPUSH
106186: PPUSH
106187: PPUSH
106188: PPUSH
106189: PPUSH
106190: PPUSH
106191: PPUSH
106192: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106193: LD_VAR 0 1
106197: PPUSH
106198: LD_VAR 0 2
106202: PPUSH
106203: CALL_OW 488
106207: NOT
106208: PUSH
106209: LD_VAR 0 3
106213: PPUSH
106214: LD_VAR 0 4
106218: PPUSH
106219: CALL_OW 488
106223: NOT
106224: OR
106225: IFFALSE 106238
// begin result := - 1 ;
106227: LD_ADDR_VAR 0 5
106231: PUSH
106232: LD_INT 1
106234: NEG
106235: ST_TO_ADDR
// exit ;
106236: GO 106473
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106238: LD_ADDR_VAR 0 12
106242: PUSH
106243: LD_VAR 0 1
106247: PPUSH
106248: LD_VAR 0 2
106252: PPUSH
106253: LD_VAR 0 3
106257: PPUSH
106258: LD_VAR 0 4
106262: PPUSH
106263: CALL 105323 0 4
106267: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106268: LD_ADDR_VAR 0 11
106272: PUSH
106273: LD_VAR 0 1
106277: PPUSH
106278: LD_VAR 0 2
106282: PPUSH
106283: LD_VAR 0 12
106287: PUSH
106288: LD_INT 1
106290: ARRAY
106291: PPUSH
106292: LD_VAR 0 12
106296: PUSH
106297: LD_INT 2
106299: ARRAY
106300: PPUSH
106301: CALL_OW 298
106305: ST_TO_ADDR
// distance := 9999 ;
106306: LD_ADDR_VAR 0 10
106310: PUSH
106311: LD_INT 9999
106313: ST_TO_ADDR
// for i := 0 to 5 do
106314: LD_ADDR_VAR 0 6
106318: PUSH
106319: DOUBLE
106320: LD_INT 0
106322: DEC
106323: ST_TO_ADDR
106324: LD_INT 5
106326: PUSH
106327: FOR_TO
106328: IFFALSE 106471
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106330: LD_ADDR_VAR 0 7
106334: PUSH
106335: LD_VAR 0 1
106339: PPUSH
106340: LD_VAR 0 6
106344: PPUSH
106345: LD_VAR 0 11
106349: PPUSH
106350: CALL_OW 272
106354: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106355: LD_ADDR_VAR 0 8
106359: PUSH
106360: LD_VAR 0 2
106364: PPUSH
106365: LD_VAR 0 6
106369: PPUSH
106370: LD_VAR 0 11
106374: PPUSH
106375: CALL_OW 273
106379: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106380: LD_VAR 0 7
106384: PPUSH
106385: LD_VAR 0 8
106389: PPUSH
106390: CALL_OW 488
106394: NOT
106395: IFFALSE 106399
// continue ;
106397: GO 106327
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106399: LD_ADDR_VAR 0 9
106403: PUSH
106404: LD_VAR 0 12
106408: PUSH
106409: LD_INT 1
106411: ARRAY
106412: PPUSH
106413: LD_VAR 0 12
106417: PUSH
106418: LD_INT 2
106420: ARRAY
106421: PPUSH
106422: LD_VAR 0 7
106426: PPUSH
106427: LD_VAR 0 8
106431: PPUSH
106432: CALL_OW 298
106436: ST_TO_ADDR
// if tmp < distance then
106437: LD_VAR 0 9
106441: PUSH
106442: LD_VAR 0 10
106446: LESS
106447: IFFALSE 106469
// begin result := i ;
106449: LD_ADDR_VAR 0 5
106453: PUSH
106454: LD_VAR 0 6
106458: ST_TO_ADDR
// distance := tmp ;
106459: LD_ADDR_VAR 0 10
106463: PUSH
106464: LD_VAR 0 9
106468: ST_TO_ADDR
// end ; end ;
106469: GO 106327
106471: POP
106472: POP
// end ;
106473: LD_VAR 0 5
106477: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106478: LD_INT 0
106480: PPUSH
106481: PPUSH
// if not driver or not IsInUnit ( driver ) then
106482: LD_VAR 0 1
106486: NOT
106487: PUSH
106488: LD_VAR 0 1
106492: PPUSH
106493: CALL_OW 310
106497: NOT
106498: OR
106499: IFFALSE 106503
// exit ;
106501: GO 106593
// vehicle := IsInUnit ( driver ) ;
106503: LD_ADDR_VAR 0 3
106507: PUSH
106508: LD_VAR 0 1
106512: PPUSH
106513: CALL_OW 310
106517: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106518: LD_VAR 0 1
106522: PPUSH
106523: LD_STRING \
106525: PUSH
106526: LD_INT 0
106528: PUSH
106529: LD_INT 0
106531: PUSH
106532: LD_INT 0
106534: PUSH
106535: LD_INT 0
106537: PUSH
106538: LD_INT 0
106540: PUSH
106541: LD_INT 0
106543: PUSH
106544: EMPTY
106545: LIST
106546: LIST
106547: LIST
106548: LIST
106549: LIST
106550: LIST
106551: LIST
106552: PUSH
106553: LD_STRING E
106555: PUSH
106556: LD_INT 0
106558: PUSH
106559: LD_INT 0
106561: PUSH
106562: LD_VAR 0 3
106566: PUSH
106567: LD_INT 0
106569: PUSH
106570: LD_INT 0
106572: PUSH
106573: LD_INT 0
106575: PUSH
106576: EMPTY
106577: LIST
106578: LIST
106579: LIST
106580: LIST
106581: LIST
106582: LIST
106583: LIST
106584: PUSH
106585: EMPTY
106586: LIST
106587: LIST
106588: PPUSH
106589: CALL_OW 446
// end ;
106593: LD_VAR 0 2
106597: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106598: LD_INT 0
106600: PPUSH
106601: PPUSH
// if not driver or not IsInUnit ( driver ) then
106602: LD_VAR 0 1
106606: NOT
106607: PUSH
106608: LD_VAR 0 1
106612: PPUSH
106613: CALL_OW 310
106617: NOT
106618: OR
106619: IFFALSE 106623
// exit ;
106621: GO 106713
// vehicle := IsInUnit ( driver ) ;
106623: LD_ADDR_VAR 0 3
106627: PUSH
106628: LD_VAR 0 1
106632: PPUSH
106633: CALL_OW 310
106637: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106638: LD_VAR 0 1
106642: PPUSH
106643: LD_STRING \
106645: PUSH
106646: LD_INT 0
106648: PUSH
106649: LD_INT 0
106651: PUSH
106652: LD_INT 0
106654: PUSH
106655: LD_INT 0
106657: PUSH
106658: LD_INT 0
106660: PUSH
106661: LD_INT 0
106663: PUSH
106664: EMPTY
106665: LIST
106666: LIST
106667: LIST
106668: LIST
106669: LIST
106670: LIST
106671: LIST
106672: PUSH
106673: LD_STRING E
106675: PUSH
106676: LD_INT 0
106678: PUSH
106679: LD_INT 0
106681: PUSH
106682: LD_VAR 0 3
106686: PUSH
106687: LD_INT 0
106689: PUSH
106690: LD_INT 0
106692: PUSH
106693: LD_INT 0
106695: PUSH
106696: EMPTY
106697: LIST
106698: LIST
106699: LIST
106700: LIST
106701: LIST
106702: LIST
106703: LIST
106704: PUSH
106705: EMPTY
106706: LIST
106707: LIST
106708: PPUSH
106709: CALL_OW 447
// end ;
106713: LD_VAR 0 2
106717: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106718: LD_INT 0
106720: PPUSH
106721: PPUSH
106722: PPUSH
// tmp := [ ] ;
106723: LD_ADDR_VAR 0 5
106727: PUSH
106728: EMPTY
106729: ST_TO_ADDR
// for i in units do
106730: LD_ADDR_VAR 0 4
106734: PUSH
106735: LD_VAR 0 1
106739: PUSH
106740: FOR_IN
106741: IFFALSE 106779
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106743: LD_ADDR_VAR 0 5
106747: PUSH
106748: LD_VAR 0 5
106752: PPUSH
106753: LD_VAR 0 5
106757: PUSH
106758: LD_INT 1
106760: PLUS
106761: PPUSH
106762: LD_VAR 0 4
106766: PPUSH
106767: CALL_OW 256
106771: PPUSH
106772: CALL_OW 2
106776: ST_TO_ADDR
106777: GO 106740
106779: POP
106780: POP
// if not tmp then
106781: LD_VAR 0 5
106785: NOT
106786: IFFALSE 106790
// exit ;
106788: GO 106838
// if asc then
106790: LD_VAR 0 2
106794: IFFALSE 106818
// result := SortListByListAsc ( units , tmp ) else
106796: LD_ADDR_VAR 0 3
106800: PUSH
106801: LD_VAR 0 1
106805: PPUSH
106806: LD_VAR 0 5
106810: PPUSH
106811: CALL_OW 76
106815: ST_TO_ADDR
106816: GO 106838
// result := SortListByListDesc ( units , tmp ) ;
106818: LD_ADDR_VAR 0 3
106822: PUSH
106823: LD_VAR 0 1
106827: PPUSH
106828: LD_VAR 0 5
106832: PPUSH
106833: CALL_OW 77
106837: ST_TO_ADDR
// end ;
106838: LD_VAR 0 3
106842: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
106843: LD_INT 0
106845: PPUSH
106846: PPUSH
// task := GetTaskList ( mech ) ;
106847: LD_ADDR_VAR 0 4
106851: PUSH
106852: LD_VAR 0 1
106856: PPUSH
106857: CALL_OW 437
106861: ST_TO_ADDR
// if not task then
106862: LD_VAR 0 4
106866: NOT
106867: IFFALSE 106871
// exit ;
106869: GO 106913
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
106871: LD_ADDR_VAR 0 3
106875: PUSH
106876: LD_VAR 0 4
106880: PUSH
106881: LD_INT 1
106883: ARRAY
106884: PUSH
106885: LD_INT 1
106887: ARRAY
106888: PUSH
106889: LD_STRING r
106891: EQUAL
106892: PUSH
106893: LD_VAR 0 4
106897: PUSH
106898: LD_INT 1
106900: ARRAY
106901: PUSH
106902: LD_INT 4
106904: ARRAY
106905: PUSH
106906: LD_VAR 0 2
106910: EQUAL
106911: AND
106912: ST_TO_ADDR
// end ;
106913: LD_VAR 0 3
106917: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
106918: LD_INT 0
106920: PPUSH
// SetDir ( unit , d ) ;
106921: LD_VAR 0 1
106925: PPUSH
106926: LD_VAR 0 4
106930: PPUSH
106931: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
106935: LD_VAR 0 1
106939: PPUSH
106940: LD_VAR 0 2
106944: PPUSH
106945: LD_VAR 0 3
106949: PPUSH
106950: LD_VAR 0 5
106954: PPUSH
106955: CALL_OW 48
// end ;
106959: LD_VAR 0 6
106963: RET
// export function ToNaturalNumber ( number ) ; begin
106964: LD_INT 0
106966: PPUSH
// result := number div 1 ;
106967: LD_ADDR_VAR 0 2
106971: PUSH
106972: LD_VAR 0 1
106976: PUSH
106977: LD_INT 1
106979: DIV
106980: ST_TO_ADDR
// if number < 0 then
106981: LD_VAR 0 1
106985: PUSH
106986: LD_INT 0
106988: LESS
106989: IFFALSE 106999
// result := 0 ;
106991: LD_ADDR_VAR 0 2
106995: PUSH
106996: LD_INT 0
106998: ST_TO_ADDR
// end ;
106999: LD_VAR 0 2
107003: RET
// export function SortByClass ( units , class ) ; var un ; begin
107004: LD_INT 0
107006: PPUSH
107007: PPUSH
// if not units or not class then
107008: LD_VAR 0 1
107012: NOT
107013: PUSH
107014: LD_VAR 0 2
107018: NOT
107019: OR
107020: IFFALSE 107024
// exit ;
107022: GO 107119
// result := [ ] ;
107024: LD_ADDR_VAR 0 3
107028: PUSH
107029: EMPTY
107030: ST_TO_ADDR
// for un in units do
107031: LD_ADDR_VAR 0 4
107035: PUSH
107036: LD_VAR 0 1
107040: PUSH
107041: FOR_IN
107042: IFFALSE 107117
// if GetClass ( un ) = class then
107044: LD_VAR 0 4
107048: PPUSH
107049: CALL_OW 257
107053: PUSH
107054: LD_VAR 0 2
107058: EQUAL
107059: IFFALSE 107086
// result := Insert ( result , 1 , un ) else
107061: LD_ADDR_VAR 0 3
107065: PUSH
107066: LD_VAR 0 3
107070: PPUSH
107071: LD_INT 1
107073: PPUSH
107074: LD_VAR 0 4
107078: PPUSH
107079: CALL_OW 2
107083: ST_TO_ADDR
107084: GO 107115
// result := Replace ( result , result + 1 , un ) ;
107086: LD_ADDR_VAR 0 3
107090: PUSH
107091: LD_VAR 0 3
107095: PPUSH
107096: LD_VAR 0 3
107100: PUSH
107101: LD_INT 1
107103: PLUS
107104: PPUSH
107105: LD_VAR 0 4
107109: PPUSH
107110: CALL_OW 1
107114: ST_TO_ADDR
107115: GO 107041
107117: POP
107118: POP
// end ;
107119: LD_VAR 0 3
107123: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107124: LD_INT 0
107126: PPUSH
107127: PPUSH
107128: PPUSH
107129: PPUSH
107130: PPUSH
107131: PPUSH
107132: PPUSH
// result := [ ] ;
107133: LD_ADDR_VAR 0 4
107137: PUSH
107138: EMPTY
107139: ST_TO_ADDR
// if x - r < 0 then
107140: LD_VAR 0 1
107144: PUSH
107145: LD_VAR 0 3
107149: MINUS
107150: PUSH
107151: LD_INT 0
107153: LESS
107154: IFFALSE 107166
// min_x := 0 else
107156: LD_ADDR_VAR 0 8
107160: PUSH
107161: LD_INT 0
107163: ST_TO_ADDR
107164: GO 107182
// min_x := x - r ;
107166: LD_ADDR_VAR 0 8
107170: PUSH
107171: LD_VAR 0 1
107175: PUSH
107176: LD_VAR 0 3
107180: MINUS
107181: ST_TO_ADDR
// if y - r < 0 then
107182: LD_VAR 0 2
107186: PUSH
107187: LD_VAR 0 3
107191: MINUS
107192: PUSH
107193: LD_INT 0
107195: LESS
107196: IFFALSE 107208
// min_y := 0 else
107198: LD_ADDR_VAR 0 7
107202: PUSH
107203: LD_INT 0
107205: ST_TO_ADDR
107206: GO 107224
// min_y := y - r ;
107208: LD_ADDR_VAR 0 7
107212: PUSH
107213: LD_VAR 0 2
107217: PUSH
107218: LD_VAR 0 3
107222: MINUS
107223: ST_TO_ADDR
// max_x := x + r ;
107224: LD_ADDR_VAR 0 9
107228: PUSH
107229: LD_VAR 0 1
107233: PUSH
107234: LD_VAR 0 3
107238: PLUS
107239: ST_TO_ADDR
// max_y := y + r ;
107240: LD_ADDR_VAR 0 10
107244: PUSH
107245: LD_VAR 0 2
107249: PUSH
107250: LD_VAR 0 3
107254: PLUS
107255: ST_TO_ADDR
// for _x = min_x to max_x do
107256: LD_ADDR_VAR 0 5
107260: PUSH
107261: DOUBLE
107262: LD_VAR 0 8
107266: DEC
107267: ST_TO_ADDR
107268: LD_VAR 0 9
107272: PUSH
107273: FOR_TO
107274: IFFALSE 107375
// for _y = min_y to max_y do
107276: LD_ADDR_VAR 0 6
107280: PUSH
107281: DOUBLE
107282: LD_VAR 0 7
107286: DEC
107287: ST_TO_ADDR
107288: LD_VAR 0 10
107292: PUSH
107293: FOR_TO
107294: IFFALSE 107371
// begin if not ValidHex ( _x , _y ) then
107296: LD_VAR 0 5
107300: PPUSH
107301: LD_VAR 0 6
107305: PPUSH
107306: CALL_OW 488
107310: NOT
107311: IFFALSE 107315
// continue ;
107313: GO 107293
// if GetResourceTypeXY ( _x , _y ) then
107315: LD_VAR 0 5
107319: PPUSH
107320: LD_VAR 0 6
107324: PPUSH
107325: CALL_OW 283
107329: IFFALSE 107369
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107331: LD_ADDR_VAR 0 4
107335: PUSH
107336: LD_VAR 0 4
107340: PPUSH
107341: LD_VAR 0 4
107345: PUSH
107346: LD_INT 1
107348: PLUS
107349: PPUSH
107350: LD_VAR 0 5
107354: PUSH
107355: LD_VAR 0 6
107359: PUSH
107360: EMPTY
107361: LIST
107362: LIST
107363: PPUSH
107364: CALL_OW 1
107368: ST_TO_ADDR
// end ;
107369: GO 107293
107371: POP
107372: POP
107373: GO 107273
107375: POP
107376: POP
// end ;
107377: LD_VAR 0 4
107381: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107382: LD_INT 0
107384: PPUSH
107385: PPUSH
107386: PPUSH
107387: PPUSH
107388: PPUSH
107389: PPUSH
107390: PPUSH
107391: PPUSH
// if not units then
107392: LD_VAR 0 1
107396: NOT
107397: IFFALSE 107401
// exit ;
107399: GO 107925
// result := UnitFilter ( units , [ f_ok ] ) ;
107401: LD_ADDR_VAR 0 3
107405: PUSH
107406: LD_VAR 0 1
107410: PPUSH
107411: LD_INT 50
107413: PUSH
107414: EMPTY
107415: LIST
107416: PPUSH
107417: CALL_OW 72
107421: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107422: LD_ADDR_VAR 0 8
107426: PUSH
107427: LD_VAR 0 1
107431: PUSH
107432: LD_INT 1
107434: ARRAY
107435: PPUSH
107436: CALL_OW 255
107440: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107441: LD_ADDR_VAR 0 10
107445: PUSH
107446: LD_INT 29
107448: PUSH
107449: LD_INT 91
107451: PUSH
107452: LD_INT 49
107454: PUSH
107455: EMPTY
107456: LIST
107457: LIST
107458: LIST
107459: ST_TO_ADDR
// if not result then
107460: LD_VAR 0 3
107464: NOT
107465: IFFALSE 107469
// exit ;
107467: GO 107925
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107469: LD_ADDR_VAR 0 5
107473: PUSH
107474: LD_INT 81
107476: PUSH
107477: LD_VAR 0 8
107481: PUSH
107482: EMPTY
107483: LIST
107484: LIST
107485: PPUSH
107486: CALL_OW 69
107490: ST_TO_ADDR
// for i in result do
107491: LD_ADDR_VAR 0 4
107495: PUSH
107496: LD_VAR 0 3
107500: PUSH
107501: FOR_IN
107502: IFFALSE 107923
// begin tag := GetTag ( i ) + 1 ;
107504: LD_ADDR_VAR 0 9
107508: PUSH
107509: LD_VAR 0 4
107513: PPUSH
107514: CALL_OW 110
107518: PUSH
107519: LD_INT 1
107521: PLUS
107522: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107523: LD_ADDR_VAR 0 7
107527: PUSH
107528: LD_VAR 0 4
107532: PPUSH
107533: CALL_OW 250
107537: PPUSH
107538: LD_VAR 0 4
107542: PPUSH
107543: CALL_OW 251
107547: PPUSH
107548: LD_INT 6
107550: PPUSH
107551: CALL 107124 0 3
107555: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107556: LD_VAR 0 4
107560: PPUSH
107561: CALL_OW 247
107565: PUSH
107566: LD_INT 2
107568: EQUAL
107569: PUSH
107570: LD_VAR 0 7
107574: AND
107575: PUSH
107576: LD_VAR 0 4
107580: PPUSH
107581: CALL_OW 264
107585: PUSH
107586: LD_VAR 0 10
107590: IN
107591: NOT
107592: AND
107593: IFFALSE 107632
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107595: LD_VAR 0 4
107599: PPUSH
107600: LD_VAR 0 7
107604: PUSH
107605: LD_INT 1
107607: ARRAY
107608: PUSH
107609: LD_INT 1
107611: ARRAY
107612: PPUSH
107613: LD_VAR 0 7
107617: PUSH
107618: LD_INT 1
107620: ARRAY
107621: PUSH
107622: LD_INT 2
107624: ARRAY
107625: PPUSH
107626: CALL_OW 116
107630: GO 107921
// if path > tag then
107632: LD_VAR 0 2
107636: PUSH
107637: LD_VAR 0 9
107641: GREATER
107642: IFFALSE 107850
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107644: LD_ADDR_VAR 0 6
107648: PUSH
107649: LD_VAR 0 5
107653: PPUSH
107654: LD_INT 91
107656: PUSH
107657: LD_VAR 0 4
107661: PUSH
107662: LD_INT 8
107664: PUSH
107665: EMPTY
107666: LIST
107667: LIST
107668: LIST
107669: PPUSH
107670: CALL_OW 72
107674: ST_TO_ADDR
// if nearEnemy then
107675: LD_VAR 0 6
107679: IFFALSE 107748
// begin if GetWeapon ( i ) = ru_time_lapser then
107681: LD_VAR 0 4
107685: PPUSH
107686: CALL_OW 264
107690: PUSH
107691: LD_INT 49
107693: EQUAL
107694: IFFALSE 107722
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107696: LD_VAR 0 4
107700: PPUSH
107701: LD_VAR 0 6
107705: PPUSH
107706: LD_VAR 0 4
107710: PPUSH
107711: CALL_OW 74
107715: PPUSH
107716: CALL_OW 112
107720: GO 107746
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107722: LD_VAR 0 4
107726: PPUSH
107727: LD_VAR 0 6
107731: PPUSH
107732: LD_VAR 0 4
107736: PPUSH
107737: CALL_OW 74
107741: PPUSH
107742: CALL_OW 115
// end else
107746: GO 107848
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107748: LD_VAR 0 4
107752: PPUSH
107753: LD_VAR 0 2
107757: PUSH
107758: LD_VAR 0 9
107762: ARRAY
107763: PUSH
107764: LD_INT 1
107766: ARRAY
107767: PPUSH
107768: LD_VAR 0 2
107772: PUSH
107773: LD_VAR 0 9
107777: ARRAY
107778: PUSH
107779: LD_INT 2
107781: ARRAY
107782: PPUSH
107783: CALL_OW 297
107787: PUSH
107788: LD_INT 6
107790: GREATER
107791: IFFALSE 107834
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107793: LD_VAR 0 4
107797: PPUSH
107798: LD_VAR 0 2
107802: PUSH
107803: LD_VAR 0 9
107807: ARRAY
107808: PUSH
107809: LD_INT 1
107811: ARRAY
107812: PPUSH
107813: LD_VAR 0 2
107817: PUSH
107818: LD_VAR 0 9
107822: ARRAY
107823: PUSH
107824: LD_INT 2
107826: ARRAY
107827: PPUSH
107828: CALL_OW 114
107832: GO 107848
// SetTag ( i , tag ) ;
107834: LD_VAR 0 4
107838: PPUSH
107839: LD_VAR 0 9
107843: PPUSH
107844: CALL_OW 109
// end else
107848: GO 107921
// if enemy then
107850: LD_VAR 0 5
107854: IFFALSE 107921
// begin if GetWeapon ( i ) = ru_time_lapser then
107856: LD_VAR 0 4
107860: PPUSH
107861: CALL_OW 264
107865: PUSH
107866: LD_INT 49
107868: EQUAL
107869: IFFALSE 107897
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107871: LD_VAR 0 4
107875: PPUSH
107876: LD_VAR 0 5
107880: PPUSH
107881: LD_VAR 0 4
107885: PPUSH
107886: CALL_OW 74
107890: PPUSH
107891: CALL_OW 112
107895: GO 107921
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
107897: LD_VAR 0 4
107901: PPUSH
107902: LD_VAR 0 5
107906: PPUSH
107907: LD_VAR 0 4
107911: PPUSH
107912: CALL_OW 74
107916: PPUSH
107917: CALL_OW 115
// end ; end ;
107921: GO 107501
107923: POP
107924: POP
// end ;
107925: LD_VAR 0 3
107929: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
107930: LD_INT 0
107932: PPUSH
107933: PPUSH
107934: PPUSH
// if not unit or IsInUnit ( unit ) then
107935: LD_VAR 0 1
107939: NOT
107940: PUSH
107941: LD_VAR 0 1
107945: PPUSH
107946: CALL_OW 310
107950: OR
107951: IFFALSE 107955
// exit ;
107953: GO 108046
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
107955: LD_ADDR_VAR 0 4
107959: PUSH
107960: LD_VAR 0 1
107964: PPUSH
107965: CALL_OW 250
107969: PPUSH
107970: LD_VAR 0 2
107974: PPUSH
107975: LD_INT 1
107977: PPUSH
107978: CALL_OW 272
107982: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
107983: LD_ADDR_VAR 0 5
107987: PUSH
107988: LD_VAR 0 1
107992: PPUSH
107993: CALL_OW 251
107997: PPUSH
107998: LD_VAR 0 2
108002: PPUSH
108003: LD_INT 1
108005: PPUSH
108006: CALL_OW 273
108010: ST_TO_ADDR
// if ValidHex ( x , y ) then
108011: LD_VAR 0 4
108015: PPUSH
108016: LD_VAR 0 5
108020: PPUSH
108021: CALL_OW 488
108025: IFFALSE 108046
// ComTurnXY ( unit , x , y ) ;
108027: LD_VAR 0 1
108031: PPUSH
108032: LD_VAR 0 4
108036: PPUSH
108037: LD_VAR 0 5
108041: PPUSH
108042: CALL_OW 118
// end ;
108046: LD_VAR 0 3
108050: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108051: LD_INT 0
108053: PPUSH
108054: PPUSH
// result := false ;
108055: LD_ADDR_VAR 0 3
108059: PUSH
108060: LD_INT 0
108062: ST_TO_ADDR
// if not units then
108063: LD_VAR 0 2
108067: NOT
108068: IFFALSE 108072
// exit ;
108070: GO 108117
// for i in units do
108072: LD_ADDR_VAR 0 4
108076: PUSH
108077: LD_VAR 0 2
108081: PUSH
108082: FOR_IN
108083: IFFALSE 108115
// if See ( side , i ) then
108085: LD_VAR 0 1
108089: PPUSH
108090: LD_VAR 0 4
108094: PPUSH
108095: CALL_OW 292
108099: IFFALSE 108113
// begin result := true ;
108101: LD_ADDR_VAR 0 3
108105: PUSH
108106: LD_INT 1
108108: ST_TO_ADDR
// exit ;
108109: POP
108110: POP
108111: GO 108117
// end ;
108113: GO 108082
108115: POP
108116: POP
// end ;
108117: LD_VAR 0 3
108121: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108122: LD_INT 0
108124: PPUSH
108125: PPUSH
108126: PPUSH
108127: PPUSH
// if not unit or not points then
108128: LD_VAR 0 1
108132: NOT
108133: PUSH
108134: LD_VAR 0 2
108138: NOT
108139: OR
108140: IFFALSE 108144
// exit ;
108142: GO 108234
// dist := 99999 ;
108144: LD_ADDR_VAR 0 5
108148: PUSH
108149: LD_INT 99999
108151: ST_TO_ADDR
// for i in points do
108152: LD_ADDR_VAR 0 4
108156: PUSH
108157: LD_VAR 0 2
108161: PUSH
108162: FOR_IN
108163: IFFALSE 108232
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108165: LD_ADDR_VAR 0 6
108169: PUSH
108170: LD_VAR 0 1
108174: PPUSH
108175: LD_VAR 0 4
108179: PUSH
108180: LD_INT 1
108182: ARRAY
108183: PPUSH
108184: LD_VAR 0 4
108188: PUSH
108189: LD_INT 2
108191: ARRAY
108192: PPUSH
108193: CALL_OW 297
108197: ST_TO_ADDR
// if tmpDist < dist then
108198: LD_VAR 0 6
108202: PUSH
108203: LD_VAR 0 5
108207: LESS
108208: IFFALSE 108230
// begin result := i ;
108210: LD_ADDR_VAR 0 3
108214: PUSH
108215: LD_VAR 0 4
108219: ST_TO_ADDR
// dist := tmpDist ;
108220: LD_ADDR_VAR 0 5
108224: PUSH
108225: LD_VAR 0 6
108229: ST_TO_ADDR
// end ; end ;
108230: GO 108162
108232: POP
108233: POP
// end ;
108234: LD_VAR 0 3
108238: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108239: LD_INT 0
108241: PPUSH
// uc_side := side ;
108242: LD_ADDR_OWVAR 20
108246: PUSH
108247: LD_VAR 0 1
108251: ST_TO_ADDR
// uc_nation := 3 ;
108252: LD_ADDR_OWVAR 21
108256: PUSH
108257: LD_INT 3
108259: ST_TO_ADDR
// vc_chassis := 25 ;
108260: LD_ADDR_OWVAR 37
108264: PUSH
108265: LD_INT 25
108267: ST_TO_ADDR
// vc_engine := engine_siberite ;
108268: LD_ADDR_OWVAR 39
108272: PUSH
108273: LD_INT 3
108275: ST_TO_ADDR
// vc_control := control_computer ;
108276: LD_ADDR_OWVAR 38
108280: PUSH
108281: LD_INT 3
108283: ST_TO_ADDR
// vc_weapon := 59 ;
108284: LD_ADDR_OWVAR 40
108288: PUSH
108289: LD_INT 59
108291: ST_TO_ADDR
// result := CreateVehicle ;
108292: LD_ADDR_VAR 0 5
108296: PUSH
108297: CALL_OW 45
108301: ST_TO_ADDR
// SetDir ( result , d ) ;
108302: LD_VAR 0 5
108306: PPUSH
108307: LD_VAR 0 4
108311: PPUSH
108312: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108316: LD_VAR 0 5
108320: PPUSH
108321: LD_VAR 0 2
108325: PPUSH
108326: LD_VAR 0 3
108330: PPUSH
108331: LD_INT 0
108333: PPUSH
108334: CALL_OW 48
// end ;
108338: LD_VAR 0 5
108342: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108343: LD_INT 0
108345: PPUSH
108346: PPUSH
108347: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108348: LD_ADDR_VAR 0 2
108352: PUSH
108353: LD_INT 0
108355: PUSH
108356: LD_INT 0
108358: PUSH
108359: LD_INT 0
108361: PUSH
108362: LD_INT 0
108364: PUSH
108365: EMPTY
108366: LIST
108367: LIST
108368: LIST
108369: LIST
108370: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108371: LD_VAR 0 1
108375: NOT
108376: PUSH
108377: LD_VAR 0 1
108381: PPUSH
108382: CALL_OW 264
108386: PUSH
108387: LD_INT 12
108389: PUSH
108390: LD_INT 51
108392: PUSH
108393: LD_INT 32
108395: PUSH
108396: LD_INT 89
108398: PUSH
108399: EMPTY
108400: LIST
108401: LIST
108402: LIST
108403: LIST
108404: IN
108405: NOT
108406: OR
108407: IFFALSE 108411
// exit ;
108409: GO 108509
// for i := 1 to 3 do
108411: LD_ADDR_VAR 0 3
108415: PUSH
108416: DOUBLE
108417: LD_INT 1
108419: DEC
108420: ST_TO_ADDR
108421: LD_INT 3
108423: PUSH
108424: FOR_TO
108425: IFFALSE 108507
// begin tmp := GetCargo ( cargo , i ) ;
108427: LD_ADDR_VAR 0 4
108431: PUSH
108432: LD_VAR 0 1
108436: PPUSH
108437: LD_VAR 0 3
108441: PPUSH
108442: CALL_OW 289
108446: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108447: LD_ADDR_VAR 0 2
108451: PUSH
108452: LD_VAR 0 2
108456: PPUSH
108457: LD_VAR 0 3
108461: PPUSH
108462: LD_VAR 0 4
108466: PPUSH
108467: CALL_OW 1
108471: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108472: LD_ADDR_VAR 0 2
108476: PUSH
108477: LD_VAR 0 2
108481: PPUSH
108482: LD_INT 4
108484: PPUSH
108485: LD_VAR 0 2
108489: PUSH
108490: LD_INT 4
108492: ARRAY
108493: PUSH
108494: LD_VAR 0 4
108498: PLUS
108499: PPUSH
108500: CALL_OW 1
108504: ST_TO_ADDR
// end ;
108505: GO 108424
108507: POP
108508: POP
// end ;
108509: LD_VAR 0 2
108513: RET
// export function Length ( array ) ; begin
108514: LD_INT 0
108516: PPUSH
// result := array + 0 ;
108517: LD_ADDR_VAR 0 2
108521: PUSH
108522: LD_VAR 0 1
108526: PUSH
108527: LD_INT 0
108529: PLUS
108530: ST_TO_ADDR
// end ;
108531: LD_VAR 0 2
108535: RET
// export function PrepareArray ( array ) ; begin
108536: LD_INT 0
108538: PPUSH
// result := array diff 0 ;
108539: LD_ADDR_VAR 0 2
108543: PUSH
108544: LD_VAR 0 1
108548: PUSH
108549: LD_INT 0
108551: DIFF
108552: ST_TO_ADDR
// if not result [ 1 ] then
108553: LD_VAR 0 2
108557: PUSH
108558: LD_INT 1
108560: ARRAY
108561: NOT
108562: IFFALSE 108582
// result := Delete ( result , 1 ) ;
108564: LD_ADDR_VAR 0 2
108568: PUSH
108569: LD_VAR 0 2
108573: PPUSH
108574: LD_INT 1
108576: PPUSH
108577: CALL_OW 3
108581: ST_TO_ADDR
// end ;
108582: LD_VAR 0 2
108586: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108587: LD_INT 0
108589: PPUSH
108590: PPUSH
108591: PPUSH
108592: PPUSH
// sibRocketRange := 25 ;
108593: LD_ADDR_VAR 0 6
108597: PUSH
108598: LD_INT 25
108600: ST_TO_ADDR
// result := false ;
108601: LD_ADDR_VAR 0 4
108605: PUSH
108606: LD_INT 0
108608: ST_TO_ADDR
// for i := 0 to 5 do
108609: LD_ADDR_VAR 0 5
108613: PUSH
108614: DOUBLE
108615: LD_INT 0
108617: DEC
108618: ST_TO_ADDR
108619: LD_INT 5
108621: PUSH
108622: FOR_TO
108623: IFFALSE 108690
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108625: LD_VAR 0 1
108629: PPUSH
108630: LD_VAR 0 5
108634: PPUSH
108635: LD_VAR 0 6
108639: PPUSH
108640: CALL_OW 272
108644: PPUSH
108645: LD_VAR 0 2
108649: PPUSH
108650: LD_VAR 0 5
108654: PPUSH
108655: LD_VAR 0 6
108659: PPUSH
108660: CALL_OW 273
108664: PPUSH
108665: LD_VAR 0 3
108669: PPUSH
108670: CALL_OW 309
108674: IFFALSE 108688
// begin result := true ;
108676: LD_ADDR_VAR 0 4
108680: PUSH
108681: LD_INT 1
108683: ST_TO_ADDR
// exit ;
108684: POP
108685: POP
108686: GO 108692
// end ;
108688: GO 108622
108690: POP
108691: POP
// end ; end_of_file end_of_file
108692: LD_VAR 0 4
108696: RET
// every 0 0$1 do
108697: GO 108699
108699: DISABLE
// begin enable ;
108700: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108701: LD_STRING updateTimer(
108703: PUSH
108704: LD_OWVAR 1
108708: STR
108709: PUSH
108710: LD_STRING );
108712: STR
108713: PPUSH
108714: CALL_OW 559
// end ;
108718: END
// export function SOS_MapStart ( ) ; begin
108719: LD_INT 0
108721: PPUSH
// if streamModeActive then
108722: LD_EXP 143
108726: IFFALSE 108735
// DefineStreamItems ( true ) ;
108728: LD_INT 1
108730: PPUSH
108731: CALL 110389 0 1
// UpdateFactoryWaypoints ( ) ;
108735: CALL 123250 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108739: CALL 123507 0 0
// end ;
108743: LD_VAR 0 1
108747: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108748: LD_INT 0
108750: PPUSH
// if p2 = hack_mode then
108751: LD_VAR 0 2
108755: PUSH
108756: LD_INT 100
108758: EQUAL
108759: IFFALSE 109762
// begin if not StreamModeActive then
108761: LD_EXP 143
108765: NOT
108766: IFFALSE 108776
// StreamModeActive := true ;
108768: LD_ADDR_EXP 143
108772: PUSH
108773: LD_INT 1
108775: ST_TO_ADDR
// if p3 = 0 then
108776: LD_VAR 0 3
108780: PUSH
108781: LD_INT 0
108783: EQUAL
108784: IFFALSE 108790
// InitStreamMode ;
108786: CALL 109925 0 0
// if p3 = 1 then
108790: LD_VAR 0 3
108794: PUSH
108795: LD_INT 1
108797: EQUAL
108798: IFFALSE 108808
// sRocket := true ;
108800: LD_ADDR_EXP 148
108804: PUSH
108805: LD_INT 1
108807: ST_TO_ADDR
// if p3 = 2 then
108808: LD_VAR 0 3
108812: PUSH
108813: LD_INT 2
108815: EQUAL
108816: IFFALSE 108826
// sSpeed := true ;
108818: LD_ADDR_EXP 147
108822: PUSH
108823: LD_INT 1
108825: ST_TO_ADDR
// if p3 = 3 then
108826: LD_VAR 0 3
108830: PUSH
108831: LD_INT 3
108833: EQUAL
108834: IFFALSE 108844
// sEngine := true ;
108836: LD_ADDR_EXP 149
108840: PUSH
108841: LD_INT 1
108843: ST_TO_ADDR
// if p3 = 4 then
108844: LD_VAR 0 3
108848: PUSH
108849: LD_INT 4
108851: EQUAL
108852: IFFALSE 108862
// sSpec := true ;
108854: LD_ADDR_EXP 146
108858: PUSH
108859: LD_INT 1
108861: ST_TO_ADDR
// if p3 = 5 then
108862: LD_VAR 0 3
108866: PUSH
108867: LD_INT 5
108869: EQUAL
108870: IFFALSE 108880
// sLevel := true ;
108872: LD_ADDR_EXP 150
108876: PUSH
108877: LD_INT 1
108879: ST_TO_ADDR
// if p3 = 6 then
108880: LD_VAR 0 3
108884: PUSH
108885: LD_INT 6
108887: EQUAL
108888: IFFALSE 108898
// sArmoury := true ;
108890: LD_ADDR_EXP 151
108894: PUSH
108895: LD_INT 1
108897: ST_TO_ADDR
// if p3 = 7 then
108898: LD_VAR 0 3
108902: PUSH
108903: LD_INT 7
108905: EQUAL
108906: IFFALSE 108916
// sRadar := true ;
108908: LD_ADDR_EXP 152
108912: PUSH
108913: LD_INT 1
108915: ST_TO_ADDR
// if p3 = 8 then
108916: LD_VAR 0 3
108920: PUSH
108921: LD_INT 8
108923: EQUAL
108924: IFFALSE 108934
// sBunker := true ;
108926: LD_ADDR_EXP 153
108930: PUSH
108931: LD_INT 1
108933: ST_TO_ADDR
// if p3 = 9 then
108934: LD_VAR 0 3
108938: PUSH
108939: LD_INT 9
108941: EQUAL
108942: IFFALSE 108952
// sHack := true ;
108944: LD_ADDR_EXP 154
108948: PUSH
108949: LD_INT 1
108951: ST_TO_ADDR
// if p3 = 10 then
108952: LD_VAR 0 3
108956: PUSH
108957: LD_INT 10
108959: EQUAL
108960: IFFALSE 108970
// sFire := true ;
108962: LD_ADDR_EXP 155
108966: PUSH
108967: LD_INT 1
108969: ST_TO_ADDR
// if p3 = 11 then
108970: LD_VAR 0 3
108974: PUSH
108975: LD_INT 11
108977: EQUAL
108978: IFFALSE 108988
// sRefresh := true ;
108980: LD_ADDR_EXP 156
108984: PUSH
108985: LD_INT 1
108987: ST_TO_ADDR
// if p3 = 12 then
108988: LD_VAR 0 3
108992: PUSH
108993: LD_INT 12
108995: EQUAL
108996: IFFALSE 109006
// sExp := true ;
108998: LD_ADDR_EXP 157
109002: PUSH
109003: LD_INT 1
109005: ST_TO_ADDR
// if p3 = 13 then
109006: LD_VAR 0 3
109010: PUSH
109011: LD_INT 13
109013: EQUAL
109014: IFFALSE 109024
// sDepot := true ;
109016: LD_ADDR_EXP 158
109020: PUSH
109021: LD_INT 1
109023: ST_TO_ADDR
// if p3 = 14 then
109024: LD_VAR 0 3
109028: PUSH
109029: LD_INT 14
109031: EQUAL
109032: IFFALSE 109042
// sFlag := true ;
109034: LD_ADDR_EXP 159
109038: PUSH
109039: LD_INT 1
109041: ST_TO_ADDR
// if p3 = 15 then
109042: LD_VAR 0 3
109046: PUSH
109047: LD_INT 15
109049: EQUAL
109050: IFFALSE 109060
// sKamikadze := true ;
109052: LD_ADDR_EXP 167
109056: PUSH
109057: LD_INT 1
109059: ST_TO_ADDR
// if p3 = 16 then
109060: LD_VAR 0 3
109064: PUSH
109065: LD_INT 16
109067: EQUAL
109068: IFFALSE 109078
// sTroll := true ;
109070: LD_ADDR_EXP 168
109074: PUSH
109075: LD_INT 1
109077: ST_TO_ADDR
// if p3 = 17 then
109078: LD_VAR 0 3
109082: PUSH
109083: LD_INT 17
109085: EQUAL
109086: IFFALSE 109096
// sSlow := true ;
109088: LD_ADDR_EXP 169
109092: PUSH
109093: LD_INT 1
109095: ST_TO_ADDR
// if p3 = 18 then
109096: LD_VAR 0 3
109100: PUSH
109101: LD_INT 18
109103: EQUAL
109104: IFFALSE 109114
// sLack := true ;
109106: LD_ADDR_EXP 170
109110: PUSH
109111: LD_INT 1
109113: ST_TO_ADDR
// if p3 = 19 then
109114: LD_VAR 0 3
109118: PUSH
109119: LD_INT 19
109121: EQUAL
109122: IFFALSE 109132
// sTank := true ;
109124: LD_ADDR_EXP 172
109128: PUSH
109129: LD_INT 1
109131: ST_TO_ADDR
// if p3 = 20 then
109132: LD_VAR 0 3
109136: PUSH
109137: LD_INT 20
109139: EQUAL
109140: IFFALSE 109150
// sRemote := true ;
109142: LD_ADDR_EXP 173
109146: PUSH
109147: LD_INT 1
109149: ST_TO_ADDR
// if p3 = 21 then
109150: LD_VAR 0 3
109154: PUSH
109155: LD_INT 21
109157: EQUAL
109158: IFFALSE 109168
// sPowell := true ;
109160: LD_ADDR_EXP 174
109164: PUSH
109165: LD_INT 1
109167: ST_TO_ADDR
// if p3 = 22 then
109168: LD_VAR 0 3
109172: PUSH
109173: LD_INT 22
109175: EQUAL
109176: IFFALSE 109186
// sTeleport := true ;
109178: LD_ADDR_EXP 177
109182: PUSH
109183: LD_INT 1
109185: ST_TO_ADDR
// if p3 = 23 then
109186: LD_VAR 0 3
109190: PUSH
109191: LD_INT 23
109193: EQUAL
109194: IFFALSE 109204
// sOilTower := true ;
109196: LD_ADDR_EXP 179
109200: PUSH
109201: LD_INT 1
109203: ST_TO_ADDR
// if p3 = 24 then
109204: LD_VAR 0 3
109208: PUSH
109209: LD_INT 24
109211: EQUAL
109212: IFFALSE 109222
// sShovel := true ;
109214: LD_ADDR_EXP 180
109218: PUSH
109219: LD_INT 1
109221: ST_TO_ADDR
// if p3 = 25 then
109222: LD_VAR 0 3
109226: PUSH
109227: LD_INT 25
109229: EQUAL
109230: IFFALSE 109240
// sSheik := true ;
109232: LD_ADDR_EXP 181
109236: PUSH
109237: LD_INT 1
109239: ST_TO_ADDR
// if p3 = 26 then
109240: LD_VAR 0 3
109244: PUSH
109245: LD_INT 26
109247: EQUAL
109248: IFFALSE 109258
// sEarthquake := true ;
109250: LD_ADDR_EXP 183
109254: PUSH
109255: LD_INT 1
109257: ST_TO_ADDR
// if p3 = 27 then
109258: LD_VAR 0 3
109262: PUSH
109263: LD_INT 27
109265: EQUAL
109266: IFFALSE 109276
// sAI := true ;
109268: LD_ADDR_EXP 184
109272: PUSH
109273: LD_INT 1
109275: ST_TO_ADDR
// if p3 = 28 then
109276: LD_VAR 0 3
109280: PUSH
109281: LD_INT 28
109283: EQUAL
109284: IFFALSE 109294
// sCargo := true ;
109286: LD_ADDR_EXP 187
109290: PUSH
109291: LD_INT 1
109293: ST_TO_ADDR
// if p3 = 29 then
109294: LD_VAR 0 3
109298: PUSH
109299: LD_INT 29
109301: EQUAL
109302: IFFALSE 109312
// sDLaser := true ;
109304: LD_ADDR_EXP 188
109308: PUSH
109309: LD_INT 1
109311: ST_TO_ADDR
// if p3 = 30 then
109312: LD_VAR 0 3
109316: PUSH
109317: LD_INT 30
109319: EQUAL
109320: IFFALSE 109330
// sExchange := true ;
109322: LD_ADDR_EXP 189
109326: PUSH
109327: LD_INT 1
109329: ST_TO_ADDR
// if p3 = 31 then
109330: LD_VAR 0 3
109334: PUSH
109335: LD_INT 31
109337: EQUAL
109338: IFFALSE 109348
// sFac := true ;
109340: LD_ADDR_EXP 190
109344: PUSH
109345: LD_INT 1
109347: ST_TO_ADDR
// if p3 = 32 then
109348: LD_VAR 0 3
109352: PUSH
109353: LD_INT 32
109355: EQUAL
109356: IFFALSE 109366
// sPower := true ;
109358: LD_ADDR_EXP 191
109362: PUSH
109363: LD_INT 1
109365: ST_TO_ADDR
// if p3 = 33 then
109366: LD_VAR 0 3
109370: PUSH
109371: LD_INT 33
109373: EQUAL
109374: IFFALSE 109384
// sRandom := true ;
109376: LD_ADDR_EXP 192
109380: PUSH
109381: LD_INT 1
109383: ST_TO_ADDR
// if p3 = 34 then
109384: LD_VAR 0 3
109388: PUSH
109389: LD_INT 34
109391: EQUAL
109392: IFFALSE 109402
// sShield := true ;
109394: LD_ADDR_EXP 193
109398: PUSH
109399: LD_INT 1
109401: ST_TO_ADDR
// if p3 = 35 then
109402: LD_VAR 0 3
109406: PUSH
109407: LD_INT 35
109409: EQUAL
109410: IFFALSE 109420
// sTime := true ;
109412: LD_ADDR_EXP 194
109416: PUSH
109417: LD_INT 1
109419: ST_TO_ADDR
// if p3 = 36 then
109420: LD_VAR 0 3
109424: PUSH
109425: LD_INT 36
109427: EQUAL
109428: IFFALSE 109438
// sTools := true ;
109430: LD_ADDR_EXP 195
109434: PUSH
109435: LD_INT 1
109437: ST_TO_ADDR
// if p3 = 101 then
109438: LD_VAR 0 3
109442: PUSH
109443: LD_INT 101
109445: EQUAL
109446: IFFALSE 109456
// sSold := true ;
109448: LD_ADDR_EXP 160
109452: PUSH
109453: LD_INT 1
109455: ST_TO_ADDR
// if p3 = 102 then
109456: LD_VAR 0 3
109460: PUSH
109461: LD_INT 102
109463: EQUAL
109464: IFFALSE 109474
// sDiff := true ;
109466: LD_ADDR_EXP 161
109470: PUSH
109471: LD_INT 1
109473: ST_TO_ADDR
// if p3 = 103 then
109474: LD_VAR 0 3
109478: PUSH
109479: LD_INT 103
109481: EQUAL
109482: IFFALSE 109492
// sFog := true ;
109484: LD_ADDR_EXP 164
109488: PUSH
109489: LD_INT 1
109491: ST_TO_ADDR
// if p3 = 104 then
109492: LD_VAR 0 3
109496: PUSH
109497: LD_INT 104
109499: EQUAL
109500: IFFALSE 109510
// sReset := true ;
109502: LD_ADDR_EXP 165
109506: PUSH
109507: LD_INT 1
109509: ST_TO_ADDR
// if p3 = 105 then
109510: LD_VAR 0 3
109514: PUSH
109515: LD_INT 105
109517: EQUAL
109518: IFFALSE 109528
// sSun := true ;
109520: LD_ADDR_EXP 166
109524: PUSH
109525: LD_INT 1
109527: ST_TO_ADDR
// if p3 = 106 then
109528: LD_VAR 0 3
109532: PUSH
109533: LD_INT 106
109535: EQUAL
109536: IFFALSE 109546
// sTiger := true ;
109538: LD_ADDR_EXP 162
109542: PUSH
109543: LD_INT 1
109545: ST_TO_ADDR
// if p3 = 107 then
109546: LD_VAR 0 3
109550: PUSH
109551: LD_INT 107
109553: EQUAL
109554: IFFALSE 109564
// sBomb := true ;
109556: LD_ADDR_EXP 163
109560: PUSH
109561: LD_INT 1
109563: ST_TO_ADDR
// if p3 = 108 then
109564: LD_VAR 0 3
109568: PUSH
109569: LD_INT 108
109571: EQUAL
109572: IFFALSE 109582
// sWound := true ;
109574: LD_ADDR_EXP 171
109578: PUSH
109579: LD_INT 1
109581: ST_TO_ADDR
// if p3 = 109 then
109582: LD_VAR 0 3
109586: PUSH
109587: LD_INT 109
109589: EQUAL
109590: IFFALSE 109600
// sBetray := true ;
109592: LD_ADDR_EXP 175
109596: PUSH
109597: LD_INT 1
109599: ST_TO_ADDR
// if p3 = 110 then
109600: LD_VAR 0 3
109604: PUSH
109605: LD_INT 110
109607: EQUAL
109608: IFFALSE 109618
// sContamin := true ;
109610: LD_ADDR_EXP 176
109614: PUSH
109615: LD_INT 1
109617: ST_TO_ADDR
// if p3 = 111 then
109618: LD_VAR 0 3
109622: PUSH
109623: LD_INT 111
109625: EQUAL
109626: IFFALSE 109636
// sOil := true ;
109628: LD_ADDR_EXP 178
109632: PUSH
109633: LD_INT 1
109635: ST_TO_ADDR
// if p3 = 112 then
109636: LD_VAR 0 3
109640: PUSH
109641: LD_INT 112
109643: EQUAL
109644: IFFALSE 109654
// sStu := true ;
109646: LD_ADDR_EXP 182
109650: PUSH
109651: LD_INT 1
109653: ST_TO_ADDR
// if p3 = 113 then
109654: LD_VAR 0 3
109658: PUSH
109659: LD_INT 113
109661: EQUAL
109662: IFFALSE 109672
// sBazooka := true ;
109664: LD_ADDR_EXP 185
109668: PUSH
109669: LD_INT 1
109671: ST_TO_ADDR
// if p3 = 114 then
109672: LD_VAR 0 3
109676: PUSH
109677: LD_INT 114
109679: EQUAL
109680: IFFALSE 109690
// sMortar := true ;
109682: LD_ADDR_EXP 186
109686: PUSH
109687: LD_INT 1
109689: ST_TO_ADDR
// if p3 = 115 then
109690: LD_VAR 0 3
109694: PUSH
109695: LD_INT 115
109697: EQUAL
109698: IFFALSE 109708
// sRanger := true ;
109700: LD_ADDR_EXP 196
109704: PUSH
109705: LD_INT 1
109707: ST_TO_ADDR
// if p3 = 116 then
109708: LD_VAR 0 3
109712: PUSH
109713: LD_INT 116
109715: EQUAL
109716: IFFALSE 109726
// sComputer := true ;
109718: LD_ADDR_EXP 197
109722: PUSH
109723: LD_INT 1
109725: ST_TO_ADDR
// if p3 = 117 then
109726: LD_VAR 0 3
109730: PUSH
109731: LD_INT 117
109733: EQUAL
109734: IFFALSE 109744
// s30 := true ;
109736: LD_ADDR_EXP 198
109740: PUSH
109741: LD_INT 1
109743: ST_TO_ADDR
// if p3 = 118 then
109744: LD_VAR 0 3
109748: PUSH
109749: LD_INT 118
109751: EQUAL
109752: IFFALSE 109762
// s60 := true ;
109754: LD_ADDR_EXP 199
109758: PUSH
109759: LD_INT 1
109761: ST_TO_ADDR
// end ; if p2 = stream_mode then
109762: LD_VAR 0 2
109766: PUSH
109767: LD_INT 101
109769: EQUAL
109770: IFFALSE 109898
// begin case p3 of 1 :
109772: LD_VAR 0 3
109776: PUSH
109777: LD_INT 1
109779: DOUBLE
109780: EQUAL
109781: IFTRUE 109785
109783: GO 109792
109785: POP
// hHackUnlimitedResources ; 2 :
109786: CALL 121996 0 0
109790: GO 109898
109792: LD_INT 2
109794: DOUBLE
109795: EQUAL
109796: IFTRUE 109800
109798: GO 109807
109800: POP
// hHackSetLevel10 ; 3 :
109801: CALL 122129 0 0
109805: GO 109898
109807: LD_INT 3
109809: DOUBLE
109810: EQUAL
109811: IFTRUE 109815
109813: GO 109822
109815: POP
// hHackSetLevel10YourUnits ; 4 :
109816: CALL 122214 0 0
109820: GO 109898
109822: LD_INT 4
109824: DOUBLE
109825: EQUAL
109826: IFTRUE 109830
109828: GO 109837
109830: POP
// hHackInvincible ; 5 :
109831: CALL 122662 0 0
109835: GO 109898
109837: LD_INT 5
109839: DOUBLE
109840: EQUAL
109841: IFTRUE 109845
109843: GO 109852
109845: POP
// hHackInvisible ; 6 :
109846: CALL 122773 0 0
109850: GO 109898
109852: LD_INT 6
109854: DOUBLE
109855: EQUAL
109856: IFTRUE 109860
109858: GO 109867
109860: POP
// hHackChangeYourSide ; 7 :
109861: CALL 122830 0 0
109865: GO 109898
109867: LD_INT 7
109869: DOUBLE
109870: EQUAL
109871: IFTRUE 109875
109873: GO 109882
109875: POP
// hHackChangeUnitSide ; 8 :
109876: CALL 122872 0 0
109880: GO 109898
109882: LD_INT 8
109884: DOUBLE
109885: EQUAL
109886: IFTRUE 109890
109888: GO 109897
109890: POP
// hHackFog ; end ;
109891: CALL 122973 0 0
109895: GO 109898
109897: POP
// end ; end ;
109898: LD_VAR 0 7
109902: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
109903: GO 109905
109905: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
109906: LD_STRING initStreamRollete();
109908: PPUSH
109909: CALL_OW 559
// InitStreamMode ;
109913: CALL 109925 0 0
// DefineStreamItems ( false ) ;
109917: LD_INT 0
109919: PPUSH
109920: CALL 110389 0 1
// end ;
109924: END
// function InitStreamMode ; begin
109925: LD_INT 0
109927: PPUSH
// streamModeActive := false ;
109928: LD_ADDR_EXP 143
109932: PUSH
109933: LD_INT 0
109935: ST_TO_ADDR
// normalCounter := 36 ;
109936: LD_ADDR_EXP 144
109940: PUSH
109941: LD_INT 36
109943: ST_TO_ADDR
// hardcoreCounter := 18 ;
109944: LD_ADDR_EXP 145
109948: PUSH
109949: LD_INT 18
109951: ST_TO_ADDR
// sRocket := false ;
109952: LD_ADDR_EXP 148
109956: PUSH
109957: LD_INT 0
109959: ST_TO_ADDR
// sSpeed := false ;
109960: LD_ADDR_EXP 147
109964: PUSH
109965: LD_INT 0
109967: ST_TO_ADDR
// sEngine := false ;
109968: LD_ADDR_EXP 149
109972: PUSH
109973: LD_INT 0
109975: ST_TO_ADDR
// sSpec := false ;
109976: LD_ADDR_EXP 146
109980: PUSH
109981: LD_INT 0
109983: ST_TO_ADDR
// sLevel := false ;
109984: LD_ADDR_EXP 150
109988: PUSH
109989: LD_INT 0
109991: ST_TO_ADDR
// sArmoury := false ;
109992: LD_ADDR_EXP 151
109996: PUSH
109997: LD_INT 0
109999: ST_TO_ADDR
// sRadar := false ;
110000: LD_ADDR_EXP 152
110004: PUSH
110005: LD_INT 0
110007: ST_TO_ADDR
// sBunker := false ;
110008: LD_ADDR_EXP 153
110012: PUSH
110013: LD_INT 0
110015: ST_TO_ADDR
// sHack := false ;
110016: LD_ADDR_EXP 154
110020: PUSH
110021: LD_INT 0
110023: ST_TO_ADDR
// sFire := false ;
110024: LD_ADDR_EXP 155
110028: PUSH
110029: LD_INT 0
110031: ST_TO_ADDR
// sRefresh := false ;
110032: LD_ADDR_EXP 156
110036: PUSH
110037: LD_INT 0
110039: ST_TO_ADDR
// sExp := false ;
110040: LD_ADDR_EXP 157
110044: PUSH
110045: LD_INT 0
110047: ST_TO_ADDR
// sDepot := false ;
110048: LD_ADDR_EXP 158
110052: PUSH
110053: LD_INT 0
110055: ST_TO_ADDR
// sFlag := false ;
110056: LD_ADDR_EXP 159
110060: PUSH
110061: LD_INT 0
110063: ST_TO_ADDR
// sKamikadze := false ;
110064: LD_ADDR_EXP 167
110068: PUSH
110069: LD_INT 0
110071: ST_TO_ADDR
// sTroll := false ;
110072: LD_ADDR_EXP 168
110076: PUSH
110077: LD_INT 0
110079: ST_TO_ADDR
// sSlow := false ;
110080: LD_ADDR_EXP 169
110084: PUSH
110085: LD_INT 0
110087: ST_TO_ADDR
// sLack := false ;
110088: LD_ADDR_EXP 170
110092: PUSH
110093: LD_INT 0
110095: ST_TO_ADDR
// sTank := false ;
110096: LD_ADDR_EXP 172
110100: PUSH
110101: LD_INT 0
110103: ST_TO_ADDR
// sRemote := false ;
110104: LD_ADDR_EXP 173
110108: PUSH
110109: LD_INT 0
110111: ST_TO_ADDR
// sPowell := false ;
110112: LD_ADDR_EXP 174
110116: PUSH
110117: LD_INT 0
110119: ST_TO_ADDR
// sTeleport := false ;
110120: LD_ADDR_EXP 177
110124: PUSH
110125: LD_INT 0
110127: ST_TO_ADDR
// sOilTower := false ;
110128: LD_ADDR_EXP 179
110132: PUSH
110133: LD_INT 0
110135: ST_TO_ADDR
// sShovel := false ;
110136: LD_ADDR_EXP 180
110140: PUSH
110141: LD_INT 0
110143: ST_TO_ADDR
// sSheik := false ;
110144: LD_ADDR_EXP 181
110148: PUSH
110149: LD_INT 0
110151: ST_TO_ADDR
// sEarthquake := false ;
110152: LD_ADDR_EXP 183
110156: PUSH
110157: LD_INT 0
110159: ST_TO_ADDR
// sAI := false ;
110160: LD_ADDR_EXP 184
110164: PUSH
110165: LD_INT 0
110167: ST_TO_ADDR
// sCargo := false ;
110168: LD_ADDR_EXP 187
110172: PUSH
110173: LD_INT 0
110175: ST_TO_ADDR
// sDLaser := false ;
110176: LD_ADDR_EXP 188
110180: PUSH
110181: LD_INT 0
110183: ST_TO_ADDR
// sExchange := false ;
110184: LD_ADDR_EXP 189
110188: PUSH
110189: LD_INT 0
110191: ST_TO_ADDR
// sFac := false ;
110192: LD_ADDR_EXP 190
110196: PUSH
110197: LD_INT 0
110199: ST_TO_ADDR
// sPower := false ;
110200: LD_ADDR_EXP 191
110204: PUSH
110205: LD_INT 0
110207: ST_TO_ADDR
// sRandom := false ;
110208: LD_ADDR_EXP 192
110212: PUSH
110213: LD_INT 0
110215: ST_TO_ADDR
// sShield := false ;
110216: LD_ADDR_EXP 193
110220: PUSH
110221: LD_INT 0
110223: ST_TO_ADDR
// sTime := false ;
110224: LD_ADDR_EXP 194
110228: PUSH
110229: LD_INT 0
110231: ST_TO_ADDR
// sTools := false ;
110232: LD_ADDR_EXP 195
110236: PUSH
110237: LD_INT 0
110239: ST_TO_ADDR
// sSold := false ;
110240: LD_ADDR_EXP 160
110244: PUSH
110245: LD_INT 0
110247: ST_TO_ADDR
// sDiff := false ;
110248: LD_ADDR_EXP 161
110252: PUSH
110253: LD_INT 0
110255: ST_TO_ADDR
// sFog := false ;
110256: LD_ADDR_EXP 164
110260: PUSH
110261: LD_INT 0
110263: ST_TO_ADDR
// sReset := false ;
110264: LD_ADDR_EXP 165
110268: PUSH
110269: LD_INT 0
110271: ST_TO_ADDR
// sSun := false ;
110272: LD_ADDR_EXP 166
110276: PUSH
110277: LD_INT 0
110279: ST_TO_ADDR
// sTiger := false ;
110280: LD_ADDR_EXP 162
110284: PUSH
110285: LD_INT 0
110287: ST_TO_ADDR
// sBomb := false ;
110288: LD_ADDR_EXP 163
110292: PUSH
110293: LD_INT 0
110295: ST_TO_ADDR
// sWound := false ;
110296: LD_ADDR_EXP 171
110300: PUSH
110301: LD_INT 0
110303: ST_TO_ADDR
// sBetray := false ;
110304: LD_ADDR_EXP 175
110308: PUSH
110309: LD_INT 0
110311: ST_TO_ADDR
// sContamin := false ;
110312: LD_ADDR_EXP 176
110316: PUSH
110317: LD_INT 0
110319: ST_TO_ADDR
// sOil := false ;
110320: LD_ADDR_EXP 178
110324: PUSH
110325: LD_INT 0
110327: ST_TO_ADDR
// sStu := false ;
110328: LD_ADDR_EXP 182
110332: PUSH
110333: LD_INT 0
110335: ST_TO_ADDR
// sBazooka := false ;
110336: LD_ADDR_EXP 185
110340: PUSH
110341: LD_INT 0
110343: ST_TO_ADDR
// sMortar := false ;
110344: LD_ADDR_EXP 186
110348: PUSH
110349: LD_INT 0
110351: ST_TO_ADDR
// sRanger := false ;
110352: LD_ADDR_EXP 196
110356: PUSH
110357: LD_INT 0
110359: ST_TO_ADDR
// sComputer := false ;
110360: LD_ADDR_EXP 197
110364: PUSH
110365: LD_INT 0
110367: ST_TO_ADDR
// s30 := false ;
110368: LD_ADDR_EXP 198
110372: PUSH
110373: LD_INT 0
110375: ST_TO_ADDR
// s60 := false ;
110376: LD_ADDR_EXP 199
110380: PUSH
110381: LD_INT 0
110383: ST_TO_ADDR
// end ;
110384: LD_VAR 0 1
110388: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110389: LD_INT 0
110391: PPUSH
110392: PPUSH
110393: PPUSH
110394: PPUSH
110395: PPUSH
110396: PPUSH
110397: PPUSH
// result := [ ] ;
110398: LD_ADDR_VAR 0 2
110402: PUSH
110403: EMPTY
110404: ST_TO_ADDR
// if campaign_id = 1 then
110405: LD_OWVAR 69
110409: PUSH
110410: LD_INT 1
110412: EQUAL
110413: IFFALSE 113579
// begin case mission_number of 1 :
110415: LD_OWVAR 70
110419: PUSH
110420: LD_INT 1
110422: DOUBLE
110423: EQUAL
110424: IFTRUE 110428
110426: GO 110504
110428: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110429: LD_ADDR_VAR 0 2
110433: PUSH
110434: LD_INT 2
110436: PUSH
110437: LD_INT 4
110439: PUSH
110440: LD_INT 11
110442: PUSH
110443: LD_INT 12
110445: PUSH
110446: LD_INT 15
110448: PUSH
110449: LD_INT 16
110451: PUSH
110452: LD_INT 22
110454: PUSH
110455: LD_INT 23
110457: PUSH
110458: LD_INT 26
110460: PUSH
110461: EMPTY
110462: LIST
110463: LIST
110464: LIST
110465: LIST
110466: LIST
110467: LIST
110468: LIST
110469: LIST
110470: LIST
110471: PUSH
110472: LD_INT 101
110474: PUSH
110475: LD_INT 102
110477: PUSH
110478: LD_INT 106
110480: PUSH
110481: LD_INT 116
110483: PUSH
110484: LD_INT 117
110486: PUSH
110487: LD_INT 118
110489: PUSH
110490: EMPTY
110491: LIST
110492: LIST
110493: LIST
110494: LIST
110495: LIST
110496: LIST
110497: PUSH
110498: EMPTY
110499: LIST
110500: LIST
110501: ST_TO_ADDR
110502: GO 113577
110504: LD_INT 2
110506: DOUBLE
110507: EQUAL
110508: IFTRUE 110512
110510: GO 110596
110512: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110513: LD_ADDR_VAR 0 2
110517: PUSH
110518: LD_INT 2
110520: PUSH
110521: LD_INT 4
110523: PUSH
110524: LD_INT 11
110526: PUSH
110527: LD_INT 12
110529: PUSH
110530: LD_INT 15
110532: PUSH
110533: LD_INT 16
110535: PUSH
110536: LD_INT 22
110538: PUSH
110539: LD_INT 23
110541: PUSH
110542: LD_INT 26
110544: PUSH
110545: EMPTY
110546: LIST
110547: LIST
110548: LIST
110549: LIST
110550: LIST
110551: LIST
110552: LIST
110553: LIST
110554: LIST
110555: PUSH
110556: LD_INT 101
110558: PUSH
110559: LD_INT 102
110561: PUSH
110562: LD_INT 105
110564: PUSH
110565: LD_INT 106
110567: PUSH
110568: LD_INT 108
110570: PUSH
110571: LD_INT 116
110573: PUSH
110574: LD_INT 117
110576: PUSH
110577: LD_INT 118
110579: PUSH
110580: EMPTY
110581: LIST
110582: LIST
110583: LIST
110584: LIST
110585: LIST
110586: LIST
110587: LIST
110588: LIST
110589: PUSH
110590: EMPTY
110591: LIST
110592: LIST
110593: ST_TO_ADDR
110594: GO 113577
110596: LD_INT 3
110598: DOUBLE
110599: EQUAL
110600: IFTRUE 110604
110602: GO 110692
110604: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110605: LD_ADDR_VAR 0 2
110609: PUSH
110610: LD_INT 2
110612: PUSH
110613: LD_INT 4
110615: PUSH
110616: LD_INT 5
110618: PUSH
110619: LD_INT 11
110621: PUSH
110622: LD_INT 12
110624: PUSH
110625: LD_INT 15
110627: PUSH
110628: LD_INT 16
110630: PUSH
110631: LD_INT 22
110633: PUSH
110634: LD_INT 26
110636: PUSH
110637: LD_INT 36
110639: PUSH
110640: EMPTY
110641: LIST
110642: LIST
110643: LIST
110644: LIST
110645: LIST
110646: LIST
110647: LIST
110648: LIST
110649: LIST
110650: LIST
110651: PUSH
110652: LD_INT 101
110654: PUSH
110655: LD_INT 102
110657: PUSH
110658: LD_INT 105
110660: PUSH
110661: LD_INT 106
110663: PUSH
110664: LD_INT 108
110666: PUSH
110667: LD_INT 116
110669: PUSH
110670: LD_INT 117
110672: PUSH
110673: LD_INT 118
110675: PUSH
110676: EMPTY
110677: LIST
110678: LIST
110679: LIST
110680: LIST
110681: LIST
110682: LIST
110683: LIST
110684: LIST
110685: PUSH
110686: EMPTY
110687: LIST
110688: LIST
110689: ST_TO_ADDR
110690: GO 113577
110692: LD_INT 4
110694: DOUBLE
110695: EQUAL
110696: IFTRUE 110700
110698: GO 110796
110700: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110701: LD_ADDR_VAR 0 2
110705: PUSH
110706: LD_INT 2
110708: PUSH
110709: LD_INT 4
110711: PUSH
110712: LD_INT 5
110714: PUSH
110715: LD_INT 8
110717: PUSH
110718: LD_INT 11
110720: PUSH
110721: LD_INT 12
110723: PUSH
110724: LD_INT 15
110726: PUSH
110727: LD_INT 16
110729: PUSH
110730: LD_INT 22
110732: PUSH
110733: LD_INT 23
110735: PUSH
110736: LD_INT 26
110738: PUSH
110739: LD_INT 36
110741: PUSH
110742: EMPTY
110743: LIST
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: LIST
110749: LIST
110750: LIST
110751: LIST
110752: LIST
110753: LIST
110754: LIST
110755: PUSH
110756: LD_INT 101
110758: PUSH
110759: LD_INT 102
110761: PUSH
110762: LD_INT 105
110764: PUSH
110765: LD_INT 106
110767: PUSH
110768: LD_INT 108
110770: PUSH
110771: LD_INT 116
110773: PUSH
110774: LD_INT 117
110776: PUSH
110777: LD_INT 118
110779: PUSH
110780: EMPTY
110781: LIST
110782: LIST
110783: LIST
110784: LIST
110785: LIST
110786: LIST
110787: LIST
110788: LIST
110789: PUSH
110790: EMPTY
110791: LIST
110792: LIST
110793: ST_TO_ADDR
110794: GO 113577
110796: LD_INT 5
110798: DOUBLE
110799: EQUAL
110800: IFTRUE 110804
110802: GO 110916
110804: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
110805: LD_ADDR_VAR 0 2
110809: PUSH
110810: LD_INT 2
110812: PUSH
110813: LD_INT 4
110815: PUSH
110816: LD_INT 5
110818: PUSH
110819: LD_INT 6
110821: PUSH
110822: LD_INT 8
110824: PUSH
110825: LD_INT 11
110827: PUSH
110828: LD_INT 12
110830: PUSH
110831: LD_INT 15
110833: PUSH
110834: LD_INT 16
110836: PUSH
110837: LD_INT 22
110839: PUSH
110840: LD_INT 23
110842: PUSH
110843: LD_INT 25
110845: PUSH
110846: LD_INT 26
110848: PUSH
110849: LD_INT 36
110851: PUSH
110852: EMPTY
110853: LIST
110854: LIST
110855: LIST
110856: LIST
110857: LIST
110858: LIST
110859: LIST
110860: LIST
110861: LIST
110862: LIST
110863: LIST
110864: LIST
110865: LIST
110866: LIST
110867: PUSH
110868: LD_INT 101
110870: PUSH
110871: LD_INT 102
110873: PUSH
110874: LD_INT 105
110876: PUSH
110877: LD_INT 106
110879: PUSH
110880: LD_INT 108
110882: PUSH
110883: LD_INT 109
110885: PUSH
110886: LD_INT 112
110888: PUSH
110889: LD_INT 116
110891: PUSH
110892: LD_INT 117
110894: PUSH
110895: LD_INT 118
110897: PUSH
110898: EMPTY
110899: LIST
110900: LIST
110901: LIST
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: PUSH
110910: EMPTY
110911: LIST
110912: LIST
110913: ST_TO_ADDR
110914: GO 113577
110916: LD_INT 6
110918: DOUBLE
110919: EQUAL
110920: IFTRUE 110924
110922: GO 111056
110924: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
110925: LD_ADDR_VAR 0 2
110929: PUSH
110930: LD_INT 2
110932: PUSH
110933: LD_INT 4
110935: PUSH
110936: LD_INT 5
110938: PUSH
110939: LD_INT 6
110941: PUSH
110942: LD_INT 8
110944: PUSH
110945: LD_INT 11
110947: PUSH
110948: LD_INT 12
110950: PUSH
110951: LD_INT 15
110953: PUSH
110954: LD_INT 16
110956: PUSH
110957: LD_INT 20
110959: PUSH
110960: LD_INT 21
110962: PUSH
110963: LD_INT 22
110965: PUSH
110966: LD_INT 23
110968: PUSH
110969: LD_INT 25
110971: PUSH
110972: LD_INT 26
110974: PUSH
110975: LD_INT 30
110977: PUSH
110978: LD_INT 31
110980: PUSH
110981: LD_INT 32
110983: PUSH
110984: LD_INT 36
110986: PUSH
110987: EMPTY
110988: LIST
110989: LIST
110990: LIST
110991: LIST
110992: LIST
110993: LIST
110994: LIST
110995: LIST
110996: LIST
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: LIST
111005: LIST
111006: LIST
111007: PUSH
111008: LD_INT 101
111010: PUSH
111011: LD_INT 102
111013: PUSH
111014: LD_INT 105
111016: PUSH
111017: LD_INT 106
111019: PUSH
111020: LD_INT 108
111022: PUSH
111023: LD_INT 109
111025: PUSH
111026: LD_INT 112
111028: PUSH
111029: LD_INT 116
111031: PUSH
111032: LD_INT 117
111034: PUSH
111035: LD_INT 118
111037: PUSH
111038: EMPTY
111039: LIST
111040: LIST
111041: LIST
111042: LIST
111043: LIST
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: PUSH
111050: EMPTY
111051: LIST
111052: LIST
111053: ST_TO_ADDR
111054: GO 113577
111056: LD_INT 7
111058: DOUBLE
111059: EQUAL
111060: IFTRUE 111064
111062: GO 111176
111064: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111065: LD_ADDR_VAR 0 2
111069: PUSH
111070: LD_INT 2
111072: PUSH
111073: LD_INT 4
111075: PUSH
111076: LD_INT 5
111078: PUSH
111079: LD_INT 7
111081: PUSH
111082: LD_INT 11
111084: PUSH
111085: LD_INT 12
111087: PUSH
111088: LD_INT 15
111090: PUSH
111091: LD_INT 16
111093: PUSH
111094: LD_INT 20
111096: PUSH
111097: LD_INT 21
111099: PUSH
111100: LD_INT 22
111102: PUSH
111103: LD_INT 23
111105: PUSH
111106: LD_INT 25
111108: PUSH
111109: LD_INT 26
111111: PUSH
111112: EMPTY
111113: LIST
111114: LIST
111115: LIST
111116: LIST
111117: LIST
111118: LIST
111119: LIST
111120: LIST
111121: LIST
111122: LIST
111123: LIST
111124: LIST
111125: LIST
111126: LIST
111127: PUSH
111128: LD_INT 101
111130: PUSH
111131: LD_INT 102
111133: PUSH
111134: LD_INT 103
111136: PUSH
111137: LD_INT 105
111139: PUSH
111140: LD_INT 106
111142: PUSH
111143: LD_INT 108
111145: PUSH
111146: LD_INT 112
111148: PUSH
111149: LD_INT 116
111151: PUSH
111152: LD_INT 117
111154: PUSH
111155: LD_INT 118
111157: PUSH
111158: EMPTY
111159: LIST
111160: LIST
111161: LIST
111162: LIST
111163: LIST
111164: LIST
111165: LIST
111166: LIST
111167: LIST
111168: LIST
111169: PUSH
111170: EMPTY
111171: LIST
111172: LIST
111173: ST_TO_ADDR
111174: GO 113577
111176: LD_INT 8
111178: DOUBLE
111179: EQUAL
111180: IFTRUE 111184
111182: GO 111324
111184: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111185: LD_ADDR_VAR 0 2
111189: PUSH
111190: LD_INT 2
111192: PUSH
111193: LD_INT 4
111195: PUSH
111196: LD_INT 5
111198: PUSH
111199: LD_INT 6
111201: PUSH
111202: LD_INT 7
111204: PUSH
111205: LD_INT 8
111207: PUSH
111208: LD_INT 11
111210: PUSH
111211: LD_INT 12
111213: PUSH
111214: LD_INT 15
111216: PUSH
111217: LD_INT 16
111219: PUSH
111220: LD_INT 20
111222: PUSH
111223: LD_INT 21
111225: PUSH
111226: LD_INT 22
111228: PUSH
111229: LD_INT 23
111231: PUSH
111232: LD_INT 25
111234: PUSH
111235: LD_INT 26
111237: PUSH
111238: LD_INT 30
111240: PUSH
111241: LD_INT 31
111243: PUSH
111244: LD_INT 32
111246: PUSH
111247: LD_INT 36
111249: PUSH
111250: EMPTY
111251: LIST
111252: LIST
111253: LIST
111254: LIST
111255: LIST
111256: LIST
111257: LIST
111258: LIST
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: LIST
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: LIST
111269: LIST
111270: LIST
111271: PUSH
111272: LD_INT 101
111274: PUSH
111275: LD_INT 102
111277: PUSH
111278: LD_INT 103
111280: PUSH
111281: LD_INT 105
111283: PUSH
111284: LD_INT 106
111286: PUSH
111287: LD_INT 108
111289: PUSH
111290: LD_INT 109
111292: PUSH
111293: LD_INT 112
111295: PUSH
111296: LD_INT 116
111298: PUSH
111299: LD_INT 117
111301: PUSH
111302: LD_INT 118
111304: PUSH
111305: EMPTY
111306: LIST
111307: LIST
111308: LIST
111309: LIST
111310: LIST
111311: LIST
111312: LIST
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: PUSH
111318: EMPTY
111319: LIST
111320: LIST
111321: ST_TO_ADDR
111322: GO 113577
111324: LD_INT 9
111326: DOUBLE
111327: EQUAL
111328: IFTRUE 111332
111330: GO 111480
111332: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111333: LD_ADDR_VAR 0 2
111337: PUSH
111338: LD_INT 2
111340: PUSH
111341: LD_INT 4
111343: PUSH
111344: LD_INT 5
111346: PUSH
111347: LD_INT 6
111349: PUSH
111350: LD_INT 7
111352: PUSH
111353: LD_INT 8
111355: PUSH
111356: LD_INT 11
111358: PUSH
111359: LD_INT 12
111361: PUSH
111362: LD_INT 15
111364: PUSH
111365: LD_INT 16
111367: PUSH
111368: LD_INT 20
111370: PUSH
111371: LD_INT 21
111373: PUSH
111374: LD_INT 22
111376: PUSH
111377: LD_INT 23
111379: PUSH
111380: LD_INT 25
111382: PUSH
111383: LD_INT 26
111385: PUSH
111386: LD_INT 28
111388: PUSH
111389: LD_INT 30
111391: PUSH
111392: LD_INT 31
111394: PUSH
111395: LD_INT 32
111397: PUSH
111398: LD_INT 36
111400: PUSH
111401: EMPTY
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: LIST
111407: LIST
111408: LIST
111409: LIST
111410: LIST
111411: LIST
111412: LIST
111413: LIST
111414: LIST
111415: LIST
111416: LIST
111417: LIST
111418: LIST
111419: LIST
111420: LIST
111421: LIST
111422: LIST
111423: PUSH
111424: LD_INT 101
111426: PUSH
111427: LD_INT 102
111429: PUSH
111430: LD_INT 103
111432: PUSH
111433: LD_INT 105
111435: PUSH
111436: LD_INT 106
111438: PUSH
111439: LD_INT 108
111441: PUSH
111442: LD_INT 109
111444: PUSH
111445: LD_INT 112
111447: PUSH
111448: LD_INT 114
111450: PUSH
111451: LD_INT 116
111453: PUSH
111454: LD_INT 117
111456: PUSH
111457: LD_INT 118
111459: PUSH
111460: EMPTY
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: PUSH
111474: EMPTY
111475: LIST
111476: LIST
111477: ST_TO_ADDR
111478: GO 113577
111480: LD_INT 10
111482: DOUBLE
111483: EQUAL
111484: IFTRUE 111488
111486: GO 111684
111488: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111489: LD_ADDR_VAR 0 2
111493: PUSH
111494: LD_INT 2
111496: PUSH
111497: LD_INT 4
111499: PUSH
111500: LD_INT 5
111502: PUSH
111503: LD_INT 6
111505: PUSH
111506: LD_INT 7
111508: PUSH
111509: LD_INT 8
111511: PUSH
111512: LD_INT 9
111514: PUSH
111515: LD_INT 10
111517: PUSH
111518: LD_INT 11
111520: PUSH
111521: LD_INT 12
111523: PUSH
111524: LD_INT 13
111526: PUSH
111527: LD_INT 14
111529: PUSH
111530: LD_INT 15
111532: PUSH
111533: LD_INT 16
111535: PUSH
111536: LD_INT 17
111538: PUSH
111539: LD_INT 18
111541: PUSH
111542: LD_INT 19
111544: PUSH
111545: LD_INT 20
111547: PUSH
111548: LD_INT 21
111550: PUSH
111551: LD_INT 22
111553: PUSH
111554: LD_INT 23
111556: PUSH
111557: LD_INT 24
111559: PUSH
111560: LD_INT 25
111562: PUSH
111563: LD_INT 26
111565: PUSH
111566: LD_INT 28
111568: PUSH
111569: LD_INT 30
111571: PUSH
111572: LD_INT 31
111574: PUSH
111575: LD_INT 32
111577: PUSH
111578: LD_INT 36
111580: PUSH
111581: EMPTY
111582: LIST
111583: LIST
111584: LIST
111585: LIST
111586: LIST
111587: LIST
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: LIST
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: LIST
111604: LIST
111605: LIST
111606: LIST
111607: LIST
111608: LIST
111609: LIST
111610: LIST
111611: PUSH
111612: LD_INT 101
111614: PUSH
111615: LD_INT 102
111617: PUSH
111618: LD_INT 103
111620: PUSH
111621: LD_INT 104
111623: PUSH
111624: LD_INT 105
111626: PUSH
111627: LD_INT 106
111629: PUSH
111630: LD_INT 107
111632: PUSH
111633: LD_INT 108
111635: PUSH
111636: LD_INT 109
111638: PUSH
111639: LD_INT 110
111641: PUSH
111642: LD_INT 111
111644: PUSH
111645: LD_INT 112
111647: PUSH
111648: LD_INT 114
111650: PUSH
111651: LD_INT 116
111653: PUSH
111654: LD_INT 117
111656: PUSH
111657: LD_INT 118
111659: PUSH
111660: EMPTY
111661: LIST
111662: LIST
111663: LIST
111664: LIST
111665: LIST
111666: LIST
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: PUSH
111678: EMPTY
111679: LIST
111680: LIST
111681: ST_TO_ADDR
111682: GO 113577
111684: LD_INT 11
111686: DOUBLE
111687: EQUAL
111688: IFTRUE 111692
111690: GO 111896
111692: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111693: LD_ADDR_VAR 0 2
111697: PUSH
111698: LD_INT 2
111700: PUSH
111701: LD_INT 3
111703: PUSH
111704: LD_INT 4
111706: PUSH
111707: LD_INT 5
111709: PUSH
111710: LD_INT 6
111712: PUSH
111713: LD_INT 7
111715: PUSH
111716: LD_INT 8
111718: PUSH
111719: LD_INT 9
111721: PUSH
111722: LD_INT 10
111724: PUSH
111725: LD_INT 11
111727: PUSH
111728: LD_INT 12
111730: PUSH
111731: LD_INT 13
111733: PUSH
111734: LD_INT 14
111736: PUSH
111737: LD_INT 15
111739: PUSH
111740: LD_INT 16
111742: PUSH
111743: LD_INT 17
111745: PUSH
111746: LD_INT 18
111748: PUSH
111749: LD_INT 19
111751: PUSH
111752: LD_INT 20
111754: PUSH
111755: LD_INT 21
111757: PUSH
111758: LD_INT 22
111760: PUSH
111761: LD_INT 23
111763: PUSH
111764: LD_INT 24
111766: PUSH
111767: LD_INT 25
111769: PUSH
111770: LD_INT 26
111772: PUSH
111773: LD_INT 28
111775: PUSH
111776: LD_INT 30
111778: PUSH
111779: LD_INT 31
111781: PUSH
111782: LD_INT 32
111784: PUSH
111785: LD_INT 34
111787: PUSH
111788: LD_INT 36
111790: PUSH
111791: EMPTY
111792: LIST
111793: LIST
111794: LIST
111795: LIST
111796: LIST
111797: LIST
111798: LIST
111799: LIST
111800: LIST
111801: LIST
111802: LIST
111803: LIST
111804: LIST
111805: LIST
111806: LIST
111807: LIST
111808: LIST
111809: LIST
111810: LIST
111811: LIST
111812: LIST
111813: LIST
111814: LIST
111815: LIST
111816: LIST
111817: LIST
111818: LIST
111819: LIST
111820: LIST
111821: LIST
111822: LIST
111823: PUSH
111824: LD_INT 101
111826: PUSH
111827: LD_INT 102
111829: PUSH
111830: LD_INT 103
111832: PUSH
111833: LD_INT 104
111835: PUSH
111836: LD_INT 105
111838: PUSH
111839: LD_INT 106
111841: PUSH
111842: LD_INT 107
111844: PUSH
111845: LD_INT 108
111847: PUSH
111848: LD_INT 109
111850: PUSH
111851: LD_INT 110
111853: PUSH
111854: LD_INT 111
111856: PUSH
111857: LD_INT 112
111859: PUSH
111860: LD_INT 114
111862: PUSH
111863: LD_INT 116
111865: PUSH
111866: LD_INT 117
111868: PUSH
111869: LD_INT 118
111871: PUSH
111872: EMPTY
111873: LIST
111874: LIST
111875: LIST
111876: LIST
111877: LIST
111878: LIST
111879: LIST
111880: LIST
111881: LIST
111882: LIST
111883: LIST
111884: LIST
111885: LIST
111886: LIST
111887: LIST
111888: LIST
111889: PUSH
111890: EMPTY
111891: LIST
111892: LIST
111893: ST_TO_ADDR
111894: GO 113577
111896: LD_INT 12
111898: DOUBLE
111899: EQUAL
111900: IFTRUE 111904
111902: GO 112124
111904: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
111905: LD_ADDR_VAR 0 2
111909: PUSH
111910: LD_INT 1
111912: PUSH
111913: LD_INT 2
111915: PUSH
111916: LD_INT 3
111918: PUSH
111919: LD_INT 4
111921: PUSH
111922: LD_INT 5
111924: PUSH
111925: LD_INT 6
111927: PUSH
111928: LD_INT 7
111930: PUSH
111931: LD_INT 8
111933: PUSH
111934: LD_INT 9
111936: PUSH
111937: LD_INT 10
111939: PUSH
111940: LD_INT 11
111942: PUSH
111943: LD_INT 12
111945: PUSH
111946: LD_INT 13
111948: PUSH
111949: LD_INT 14
111951: PUSH
111952: LD_INT 15
111954: PUSH
111955: LD_INT 16
111957: PUSH
111958: LD_INT 17
111960: PUSH
111961: LD_INT 18
111963: PUSH
111964: LD_INT 19
111966: PUSH
111967: LD_INT 20
111969: PUSH
111970: LD_INT 21
111972: PUSH
111973: LD_INT 22
111975: PUSH
111976: LD_INT 23
111978: PUSH
111979: LD_INT 24
111981: PUSH
111982: LD_INT 25
111984: PUSH
111985: LD_INT 26
111987: PUSH
111988: LD_INT 27
111990: PUSH
111991: LD_INT 28
111993: PUSH
111994: LD_INT 30
111996: PUSH
111997: LD_INT 31
111999: PUSH
112000: LD_INT 32
112002: PUSH
112003: LD_INT 33
112005: PUSH
112006: LD_INT 34
112008: PUSH
112009: LD_INT 36
112011: PUSH
112012: EMPTY
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: LIST
112021: LIST
112022: LIST
112023: LIST
112024: LIST
112025: LIST
112026: LIST
112027: LIST
112028: LIST
112029: LIST
112030: LIST
112031: LIST
112032: LIST
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: PUSH
112048: LD_INT 101
112050: PUSH
112051: LD_INT 102
112053: PUSH
112054: LD_INT 103
112056: PUSH
112057: LD_INT 104
112059: PUSH
112060: LD_INT 105
112062: PUSH
112063: LD_INT 106
112065: PUSH
112066: LD_INT 107
112068: PUSH
112069: LD_INT 108
112071: PUSH
112072: LD_INT 109
112074: PUSH
112075: LD_INT 110
112077: PUSH
112078: LD_INT 111
112080: PUSH
112081: LD_INT 112
112083: PUSH
112084: LD_INT 113
112086: PUSH
112087: LD_INT 114
112089: PUSH
112090: LD_INT 116
112092: PUSH
112093: LD_INT 117
112095: PUSH
112096: LD_INT 118
112098: PUSH
112099: EMPTY
112100: LIST
112101: LIST
112102: LIST
112103: LIST
112104: LIST
112105: LIST
112106: LIST
112107: LIST
112108: LIST
112109: LIST
112110: LIST
112111: LIST
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: LIST
112117: PUSH
112118: EMPTY
112119: LIST
112120: LIST
112121: ST_TO_ADDR
112122: GO 113577
112124: LD_INT 13
112126: DOUBLE
112127: EQUAL
112128: IFTRUE 112132
112130: GO 112340
112132: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112133: LD_ADDR_VAR 0 2
112137: PUSH
112138: LD_INT 1
112140: PUSH
112141: LD_INT 2
112143: PUSH
112144: LD_INT 3
112146: PUSH
112147: LD_INT 4
112149: PUSH
112150: LD_INT 5
112152: PUSH
112153: LD_INT 8
112155: PUSH
112156: LD_INT 9
112158: PUSH
112159: LD_INT 10
112161: PUSH
112162: LD_INT 11
112164: PUSH
112165: LD_INT 12
112167: PUSH
112168: LD_INT 14
112170: PUSH
112171: LD_INT 15
112173: PUSH
112174: LD_INT 16
112176: PUSH
112177: LD_INT 17
112179: PUSH
112180: LD_INT 18
112182: PUSH
112183: LD_INT 19
112185: PUSH
112186: LD_INT 20
112188: PUSH
112189: LD_INT 21
112191: PUSH
112192: LD_INT 22
112194: PUSH
112195: LD_INT 23
112197: PUSH
112198: LD_INT 24
112200: PUSH
112201: LD_INT 25
112203: PUSH
112204: LD_INT 26
112206: PUSH
112207: LD_INT 27
112209: PUSH
112210: LD_INT 28
112212: PUSH
112213: LD_INT 30
112215: PUSH
112216: LD_INT 31
112218: PUSH
112219: LD_INT 32
112221: PUSH
112222: LD_INT 33
112224: PUSH
112225: LD_INT 34
112227: PUSH
112228: LD_INT 36
112230: PUSH
112231: EMPTY
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: LIST
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: PUSH
112264: LD_INT 101
112266: PUSH
112267: LD_INT 102
112269: PUSH
112270: LD_INT 103
112272: PUSH
112273: LD_INT 104
112275: PUSH
112276: LD_INT 105
112278: PUSH
112279: LD_INT 106
112281: PUSH
112282: LD_INT 107
112284: PUSH
112285: LD_INT 108
112287: PUSH
112288: LD_INT 109
112290: PUSH
112291: LD_INT 110
112293: PUSH
112294: LD_INT 111
112296: PUSH
112297: LD_INT 112
112299: PUSH
112300: LD_INT 113
112302: PUSH
112303: LD_INT 114
112305: PUSH
112306: LD_INT 116
112308: PUSH
112309: LD_INT 117
112311: PUSH
112312: LD_INT 118
112314: PUSH
112315: EMPTY
112316: LIST
112317: LIST
112318: LIST
112319: LIST
112320: LIST
112321: LIST
112322: LIST
112323: LIST
112324: LIST
112325: LIST
112326: LIST
112327: LIST
112328: LIST
112329: LIST
112330: LIST
112331: LIST
112332: LIST
112333: PUSH
112334: EMPTY
112335: LIST
112336: LIST
112337: ST_TO_ADDR
112338: GO 113577
112340: LD_INT 14
112342: DOUBLE
112343: EQUAL
112344: IFTRUE 112348
112346: GO 112572
112348: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112349: LD_ADDR_VAR 0 2
112353: PUSH
112354: LD_INT 1
112356: PUSH
112357: LD_INT 2
112359: PUSH
112360: LD_INT 3
112362: PUSH
112363: LD_INT 4
112365: PUSH
112366: LD_INT 5
112368: PUSH
112369: LD_INT 6
112371: PUSH
112372: LD_INT 7
112374: PUSH
112375: LD_INT 8
112377: PUSH
112378: LD_INT 9
112380: PUSH
112381: LD_INT 10
112383: PUSH
112384: LD_INT 11
112386: PUSH
112387: LD_INT 12
112389: PUSH
112390: LD_INT 13
112392: PUSH
112393: LD_INT 14
112395: PUSH
112396: LD_INT 15
112398: PUSH
112399: LD_INT 16
112401: PUSH
112402: LD_INT 17
112404: PUSH
112405: LD_INT 18
112407: PUSH
112408: LD_INT 19
112410: PUSH
112411: LD_INT 20
112413: PUSH
112414: LD_INT 21
112416: PUSH
112417: LD_INT 22
112419: PUSH
112420: LD_INT 23
112422: PUSH
112423: LD_INT 24
112425: PUSH
112426: LD_INT 25
112428: PUSH
112429: LD_INT 26
112431: PUSH
112432: LD_INT 27
112434: PUSH
112435: LD_INT 28
112437: PUSH
112438: LD_INT 29
112440: PUSH
112441: LD_INT 30
112443: PUSH
112444: LD_INT 31
112446: PUSH
112447: LD_INT 32
112449: PUSH
112450: LD_INT 33
112452: PUSH
112453: LD_INT 34
112455: PUSH
112456: LD_INT 36
112458: PUSH
112459: EMPTY
112460: LIST
112461: LIST
112462: LIST
112463: LIST
112464: LIST
112465: LIST
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: PUSH
112496: LD_INT 101
112498: PUSH
112499: LD_INT 102
112501: PUSH
112502: LD_INT 103
112504: PUSH
112505: LD_INT 104
112507: PUSH
112508: LD_INT 105
112510: PUSH
112511: LD_INT 106
112513: PUSH
112514: LD_INT 107
112516: PUSH
112517: LD_INT 108
112519: PUSH
112520: LD_INT 109
112522: PUSH
112523: LD_INT 110
112525: PUSH
112526: LD_INT 111
112528: PUSH
112529: LD_INT 112
112531: PUSH
112532: LD_INT 113
112534: PUSH
112535: LD_INT 114
112537: PUSH
112538: LD_INT 116
112540: PUSH
112541: LD_INT 117
112543: PUSH
112544: LD_INT 118
112546: PUSH
112547: EMPTY
112548: LIST
112549: LIST
112550: LIST
112551: LIST
112552: LIST
112553: LIST
112554: LIST
112555: LIST
112556: LIST
112557: LIST
112558: LIST
112559: LIST
112560: LIST
112561: LIST
112562: LIST
112563: LIST
112564: LIST
112565: PUSH
112566: EMPTY
112567: LIST
112568: LIST
112569: ST_TO_ADDR
112570: GO 113577
112572: LD_INT 15
112574: DOUBLE
112575: EQUAL
112576: IFTRUE 112580
112578: GO 112804
112580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112581: LD_ADDR_VAR 0 2
112585: PUSH
112586: LD_INT 1
112588: PUSH
112589: LD_INT 2
112591: PUSH
112592: LD_INT 3
112594: PUSH
112595: LD_INT 4
112597: PUSH
112598: LD_INT 5
112600: PUSH
112601: LD_INT 6
112603: PUSH
112604: LD_INT 7
112606: PUSH
112607: LD_INT 8
112609: PUSH
112610: LD_INT 9
112612: PUSH
112613: LD_INT 10
112615: PUSH
112616: LD_INT 11
112618: PUSH
112619: LD_INT 12
112621: PUSH
112622: LD_INT 13
112624: PUSH
112625: LD_INT 14
112627: PUSH
112628: LD_INT 15
112630: PUSH
112631: LD_INT 16
112633: PUSH
112634: LD_INT 17
112636: PUSH
112637: LD_INT 18
112639: PUSH
112640: LD_INT 19
112642: PUSH
112643: LD_INT 20
112645: PUSH
112646: LD_INT 21
112648: PUSH
112649: LD_INT 22
112651: PUSH
112652: LD_INT 23
112654: PUSH
112655: LD_INT 24
112657: PUSH
112658: LD_INT 25
112660: PUSH
112661: LD_INT 26
112663: PUSH
112664: LD_INT 27
112666: PUSH
112667: LD_INT 28
112669: PUSH
112670: LD_INT 29
112672: PUSH
112673: LD_INT 30
112675: PUSH
112676: LD_INT 31
112678: PUSH
112679: LD_INT 32
112681: PUSH
112682: LD_INT 33
112684: PUSH
112685: LD_INT 34
112687: PUSH
112688: LD_INT 36
112690: PUSH
112691: EMPTY
112692: LIST
112693: LIST
112694: LIST
112695: LIST
112696: LIST
112697: LIST
112698: LIST
112699: LIST
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: LIST
112715: LIST
112716: LIST
112717: LIST
112718: LIST
112719: LIST
112720: LIST
112721: LIST
112722: LIST
112723: LIST
112724: LIST
112725: LIST
112726: LIST
112727: PUSH
112728: LD_INT 101
112730: PUSH
112731: LD_INT 102
112733: PUSH
112734: LD_INT 103
112736: PUSH
112737: LD_INT 104
112739: PUSH
112740: LD_INT 105
112742: PUSH
112743: LD_INT 106
112745: PUSH
112746: LD_INT 107
112748: PUSH
112749: LD_INT 108
112751: PUSH
112752: LD_INT 109
112754: PUSH
112755: LD_INT 110
112757: PUSH
112758: LD_INT 111
112760: PUSH
112761: LD_INT 112
112763: PUSH
112764: LD_INT 113
112766: PUSH
112767: LD_INT 114
112769: PUSH
112770: LD_INT 116
112772: PUSH
112773: LD_INT 117
112775: PUSH
112776: LD_INT 118
112778: PUSH
112779: EMPTY
112780: LIST
112781: LIST
112782: LIST
112783: LIST
112784: LIST
112785: LIST
112786: LIST
112787: LIST
112788: LIST
112789: LIST
112790: LIST
112791: LIST
112792: LIST
112793: LIST
112794: LIST
112795: LIST
112796: LIST
112797: PUSH
112798: EMPTY
112799: LIST
112800: LIST
112801: ST_TO_ADDR
112802: GO 113577
112804: LD_INT 16
112806: DOUBLE
112807: EQUAL
112808: IFTRUE 112812
112810: GO 112948
112812: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
112813: LD_ADDR_VAR 0 2
112817: PUSH
112818: LD_INT 2
112820: PUSH
112821: LD_INT 4
112823: PUSH
112824: LD_INT 5
112826: PUSH
112827: LD_INT 7
112829: PUSH
112830: LD_INT 11
112832: PUSH
112833: LD_INT 12
112835: PUSH
112836: LD_INT 15
112838: PUSH
112839: LD_INT 16
112841: PUSH
112842: LD_INT 20
112844: PUSH
112845: LD_INT 21
112847: PUSH
112848: LD_INT 22
112850: PUSH
112851: LD_INT 23
112853: PUSH
112854: LD_INT 25
112856: PUSH
112857: LD_INT 26
112859: PUSH
112860: LD_INT 30
112862: PUSH
112863: LD_INT 31
112865: PUSH
112866: LD_INT 32
112868: PUSH
112869: LD_INT 33
112871: PUSH
112872: LD_INT 34
112874: PUSH
112875: EMPTY
112876: LIST
112877: LIST
112878: LIST
112879: LIST
112880: LIST
112881: LIST
112882: LIST
112883: LIST
112884: LIST
112885: LIST
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: LIST
112892: LIST
112893: LIST
112894: LIST
112895: PUSH
112896: LD_INT 101
112898: PUSH
112899: LD_INT 102
112901: PUSH
112902: LD_INT 103
112904: PUSH
112905: LD_INT 106
112907: PUSH
112908: LD_INT 108
112910: PUSH
112911: LD_INT 112
112913: PUSH
112914: LD_INT 113
112916: PUSH
112917: LD_INT 114
112919: PUSH
112920: LD_INT 116
112922: PUSH
112923: LD_INT 117
112925: PUSH
112926: LD_INT 118
112928: PUSH
112929: EMPTY
112930: LIST
112931: LIST
112932: LIST
112933: LIST
112934: LIST
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: PUSH
112942: EMPTY
112943: LIST
112944: LIST
112945: ST_TO_ADDR
112946: GO 113577
112948: LD_INT 17
112950: DOUBLE
112951: EQUAL
112952: IFTRUE 112956
112954: GO 113180
112956: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
112957: LD_ADDR_VAR 0 2
112961: PUSH
112962: LD_INT 1
112964: PUSH
112965: LD_INT 2
112967: PUSH
112968: LD_INT 3
112970: PUSH
112971: LD_INT 4
112973: PUSH
112974: LD_INT 5
112976: PUSH
112977: LD_INT 6
112979: PUSH
112980: LD_INT 7
112982: PUSH
112983: LD_INT 8
112985: PUSH
112986: LD_INT 9
112988: PUSH
112989: LD_INT 10
112991: PUSH
112992: LD_INT 11
112994: PUSH
112995: LD_INT 12
112997: PUSH
112998: LD_INT 13
113000: PUSH
113001: LD_INT 14
113003: PUSH
113004: LD_INT 15
113006: PUSH
113007: LD_INT 16
113009: PUSH
113010: LD_INT 17
113012: PUSH
113013: LD_INT 18
113015: PUSH
113016: LD_INT 19
113018: PUSH
113019: LD_INT 20
113021: PUSH
113022: LD_INT 21
113024: PUSH
113025: LD_INT 22
113027: PUSH
113028: LD_INT 23
113030: PUSH
113031: LD_INT 24
113033: PUSH
113034: LD_INT 25
113036: PUSH
113037: LD_INT 26
113039: PUSH
113040: LD_INT 27
113042: PUSH
113043: LD_INT 28
113045: PUSH
113046: LD_INT 29
113048: PUSH
113049: LD_INT 30
113051: PUSH
113052: LD_INT 31
113054: PUSH
113055: LD_INT 32
113057: PUSH
113058: LD_INT 33
113060: PUSH
113061: LD_INT 34
113063: PUSH
113064: LD_INT 36
113066: PUSH
113067: EMPTY
113068: LIST
113069: LIST
113070: LIST
113071: LIST
113072: LIST
113073: LIST
113074: LIST
113075: LIST
113076: LIST
113077: LIST
113078: LIST
113079: LIST
113080: LIST
113081: LIST
113082: LIST
113083: LIST
113084: LIST
113085: LIST
113086: LIST
113087: LIST
113088: LIST
113089: LIST
113090: LIST
113091: LIST
113092: LIST
113093: LIST
113094: LIST
113095: LIST
113096: LIST
113097: LIST
113098: LIST
113099: LIST
113100: LIST
113101: LIST
113102: LIST
113103: PUSH
113104: LD_INT 101
113106: PUSH
113107: LD_INT 102
113109: PUSH
113110: LD_INT 103
113112: PUSH
113113: LD_INT 104
113115: PUSH
113116: LD_INT 105
113118: PUSH
113119: LD_INT 106
113121: PUSH
113122: LD_INT 107
113124: PUSH
113125: LD_INT 108
113127: PUSH
113128: LD_INT 109
113130: PUSH
113131: LD_INT 110
113133: PUSH
113134: LD_INT 111
113136: PUSH
113137: LD_INT 112
113139: PUSH
113140: LD_INT 113
113142: PUSH
113143: LD_INT 114
113145: PUSH
113146: LD_INT 116
113148: PUSH
113149: LD_INT 117
113151: PUSH
113152: LD_INT 118
113154: PUSH
113155: EMPTY
113156: LIST
113157: LIST
113158: LIST
113159: LIST
113160: LIST
113161: LIST
113162: LIST
113163: LIST
113164: LIST
113165: LIST
113166: LIST
113167: LIST
113168: LIST
113169: LIST
113170: LIST
113171: LIST
113172: LIST
113173: PUSH
113174: EMPTY
113175: LIST
113176: LIST
113177: ST_TO_ADDR
113178: GO 113577
113180: LD_INT 18
113182: DOUBLE
113183: EQUAL
113184: IFTRUE 113188
113186: GO 113336
113188: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113189: LD_ADDR_VAR 0 2
113193: PUSH
113194: LD_INT 2
113196: PUSH
113197: LD_INT 4
113199: PUSH
113200: LD_INT 5
113202: PUSH
113203: LD_INT 7
113205: PUSH
113206: LD_INT 11
113208: PUSH
113209: LD_INT 12
113211: PUSH
113212: LD_INT 15
113214: PUSH
113215: LD_INT 16
113217: PUSH
113218: LD_INT 20
113220: PUSH
113221: LD_INT 21
113223: PUSH
113224: LD_INT 22
113226: PUSH
113227: LD_INT 23
113229: PUSH
113230: LD_INT 25
113232: PUSH
113233: LD_INT 26
113235: PUSH
113236: LD_INT 30
113238: PUSH
113239: LD_INT 31
113241: PUSH
113242: LD_INT 32
113244: PUSH
113245: LD_INT 33
113247: PUSH
113248: LD_INT 34
113250: PUSH
113251: LD_INT 35
113253: PUSH
113254: LD_INT 36
113256: PUSH
113257: EMPTY
113258: LIST
113259: LIST
113260: LIST
113261: LIST
113262: LIST
113263: LIST
113264: LIST
113265: LIST
113266: LIST
113267: LIST
113268: LIST
113269: LIST
113270: LIST
113271: LIST
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: PUSH
113280: LD_INT 101
113282: PUSH
113283: LD_INT 102
113285: PUSH
113286: LD_INT 103
113288: PUSH
113289: LD_INT 106
113291: PUSH
113292: LD_INT 108
113294: PUSH
113295: LD_INT 112
113297: PUSH
113298: LD_INT 113
113300: PUSH
113301: LD_INT 114
113303: PUSH
113304: LD_INT 115
113306: PUSH
113307: LD_INT 116
113309: PUSH
113310: LD_INT 117
113312: PUSH
113313: LD_INT 118
113315: PUSH
113316: EMPTY
113317: LIST
113318: LIST
113319: LIST
113320: LIST
113321: LIST
113322: LIST
113323: LIST
113324: LIST
113325: LIST
113326: LIST
113327: LIST
113328: LIST
113329: PUSH
113330: EMPTY
113331: LIST
113332: LIST
113333: ST_TO_ADDR
113334: GO 113577
113336: LD_INT 19
113338: DOUBLE
113339: EQUAL
113340: IFTRUE 113344
113342: GO 113576
113344: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113345: LD_ADDR_VAR 0 2
113349: PUSH
113350: LD_INT 1
113352: PUSH
113353: LD_INT 2
113355: PUSH
113356: LD_INT 3
113358: PUSH
113359: LD_INT 4
113361: PUSH
113362: LD_INT 5
113364: PUSH
113365: LD_INT 6
113367: PUSH
113368: LD_INT 7
113370: PUSH
113371: LD_INT 8
113373: PUSH
113374: LD_INT 9
113376: PUSH
113377: LD_INT 10
113379: PUSH
113380: LD_INT 11
113382: PUSH
113383: LD_INT 12
113385: PUSH
113386: LD_INT 13
113388: PUSH
113389: LD_INT 14
113391: PUSH
113392: LD_INT 15
113394: PUSH
113395: LD_INT 16
113397: PUSH
113398: LD_INT 17
113400: PUSH
113401: LD_INT 18
113403: PUSH
113404: LD_INT 19
113406: PUSH
113407: LD_INT 20
113409: PUSH
113410: LD_INT 21
113412: PUSH
113413: LD_INT 22
113415: PUSH
113416: LD_INT 23
113418: PUSH
113419: LD_INT 24
113421: PUSH
113422: LD_INT 25
113424: PUSH
113425: LD_INT 26
113427: PUSH
113428: LD_INT 27
113430: PUSH
113431: LD_INT 28
113433: PUSH
113434: LD_INT 29
113436: PUSH
113437: LD_INT 30
113439: PUSH
113440: LD_INT 31
113442: PUSH
113443: LD_INT 32
113445: PUSH
113446: LD_INT 33
113448: PUSH
113449: LD_INT 34
113451: PUSH
113452: LD_INT 35
113454: PUSH
113455: LD_INT 36
113457: PUSH
113458: EMPTY
113459: LIST
113460: LIST
113461: LIST
113462: LIST
113463: LIST
113464: LIST
113465: LIST
113466: LIST
113467: LIST
113468: LIST
113469: LIST
113470: LIST
113471: LIST
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: LIST
113488: LIST
113489: LIST
113490: LIST
113491: LIST
113492: LIST
113493: LIST
113494: LIST
113495: PUSH
113496: LD_INT 101
113498: PUSH
113499: LD_INT 102
113501: PUSH
113502: LD_INT 103
113504: PUSH
113505: LD_INT 104
113507: PUSH
113508: LD_INT 105
113510: PUSH
113511: LD_INT 106
113513: PUSH
113514: LD_INT 107
113516: PUSH
113517: LD_INT 108
113519: PUSH
113520: LD_INT 109
113522: PUSH
113523: LD_INT 110
113525: PUSH
113526: LD_INT 111
113528: PUSH
113529: LD_INT 112
113531: PUSH
113532: LD_INT 113
113534: PUSH
113535: LD_INT 114
113537: PUSH
113538: LD_INT 115
113540: PUSH
113541: LD_INT 116
113543: PUSH
113544: LD_INT 117
113546: PUSH
113547: LD_INT 118
113549: PUSH
113550: EMPTY
113551: LIST
113552: LIST
113553: LIST
113554: LIST
113555: LIST
113556: LIST
113557: LIST
113558: LIST
113559: LIST
113560: LIST
113561: LIST
113562: LIST
113563: LIST
113564: LIST
113565: LIST
113566: LIST
113567: LIST
113568: LIST
113569: PUSH
113570: EMPTY
113571: LIST
113572: LIST
113573: ST_TO_ADDR
113574: GO 113577
113576: POP
// end else
113577: GO 113808
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113579: LD_ADDR_VAR 0 2
113583: PUSH
113584: LD_INT 1
113586: PUSH
113587: LD_INT 2
113589: PUSH
113590: LD_INT 3
113592: PUSH
113593: LD_INT 4
113595: PUSH
113596: LD_INT 5
113598: PUSH
113599: LD_INT 6
113601: PUSH
113602: LD_INT 7
113604: PUSH
113605: LD_INT 8
113607: PUSH
113608: LD_INT 9
113610: PUSH
113611: LD_INT 10
113613: PUSH
113614: LD_INT 11
113616: PUSH
113617: LD_INT 12
113619: PUSH
113620: LD_INT 13
113622: PUSH
113623: LD_INT 14
113625: PUSH
113626: LD_INT 15
113628: PUSH
113629: LD_INT 16
113631: PUSH
113632: LD_INT 17
113634: PUSH
113635: LD_INT 18
113637: PUSH
113638: LD_INT 19
113640: PUSH
113641: LD_INT 20
113643: PUSH
113644: LD_INT 21
113646: PUSH
113647: LD_INT 22
113649: PUSH
113650: LD_INT 23
113652: PUSH
113653: LD_INT 24
113655: PUSH
113656: LD_INT 25
113658: PUSH
113659: LD_INT 26
113661: PUSH
113662: LD_INT 27
113664: PUSH
113665: LD_INT 28
113667: PUSH
113668: LD_INT 29
113670: PUSH
113671: LD_INT 30
113673: PUSH
113674: LD_INT 31
113676: PUSH
113677: LD_INT 32
113679: PUSH
113680: LD_INT 33
113682: PUSH
113683: LD_INT 34
113685: PUSH
113686: LD_INT 35
113688: PUSH
113689: LD_INT 36
113691: PUSH
113692: EMPTY
113693: LIST
113694: LIST
113695: LIST
113696: LIST
113697: LIST
113698: LIST
113699: LIST
113700: LIST
113701: LIST
113702: LIST
113703: LIST
113704: LIST
113705: LIST
113706: LIST
113707: LIST
113708: LIST
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: LIST
113728: LIST
113729: PUSH
113730: LD_INT 101
113732: PUSH
113733: LD_INT 102
113735: PUSH
113736: LD_INT 103
113738: PUSH
113739: LD_INT 104
113741: PUSH
113742: LD_INT 105
113744: PUSH
113745: LD_INT 106
113747: PUSH
113748: LD_INT 107
113750: PUSH
113751: LD_INT 108
113753: PUSH
113754: LD_INT 109
113756: PUSH
113757: LD_INT 110
113759: PUSH
113760: LD_INT 111
113762: PUSH
113763: LD_INT 112
113765: PUSH
113766: LD_INT 113
113768: PUSH
113769: LD_INT 114
113771: PUSH
113772: LD_INT 115
113774: PUSH
113775: LD_INT 116
113777: PUSH
113778: LD_INT 117
113780: PUSH
113781: LD_INT 118
113783: PUSH
113784: EMPTY
113785: LIST
113786: LIST
113787: LIST
113788: LIST
113789: LIST
113790: LIST
113791: LIST
113792: LIST
113793: LIST
113794: LIST
113795: LIST
113796: LIST
113797: LIST
113798: LIST
113799: LIST
113800: LIST
113801: LIST
113802: LIST
113803: PUSH
113804: EMPTY
113805: LIST
113806: LIST
113807: ST_TO_ADDR
// if result then
113808: LD_VAR 0 2
113812: IFFALSE 114598
// begin normal :=  ;
113814: LD_ADDR_VAR 0 5
113818: PUSH
113819: LD_STRING 
113821: ST_TO_ADDR
// hardcore :=  ;
113822: LD_ADDR_VAR 0 6
113826: PUSH
113827: LD_STRING 
113829: ST_TO_ADDR
// active :=  ;
113830: LD_ADDR_VAR 0 7
113834: PUSH
113835: LD_STRING 
113837: ST_TO_ADDR
// for i = 1 to normalCounter do
113838: LD_ADDR_VAR 0 8
113842: PUSH
113843: DOUBLE
113844: LD_INT 1
113846: DEC
113847: ST_TO_ADDR
113848: LD_EXP 144
113852: PUSH
113853: FOR_TO
113854: IFFALSE 113955
// begin tmp := 0 ;
113856: LD_ADDR_VAR 0 3
113860: PUSH
113861: LD_STRING 0
113863: ST_TO_ADDR
// if result [ 1 ] then
113864: LD_VAR 0 2
113868: PUSH
113869: LD_INT 1
113871: ARRAY
113872: IFFALSE 113937
// if result [ 1 ] [ 1 ] = i then
113874: LD_VAR 0 2
113878: PUSH
113879: LD_INT 1
113881: ARRAY
113882: PUSH
113883: LD_INT 1
113885: ARRAY
113886: PUSH
113887: LD_VAR 0 8
113891: EQUAL
113892: IFFALSE 113937
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
113894: LD_ADDR_VAR 0 2
113898: PUSH
113899: LD_VAR 0 2
113903: PPUSH
113904: LD_INT 1
113906: PPUSH
113907: LD_VAR 0 2
113911: PUSH
113912: LD_INT 1
113914: ARRAY
113915: PPUSH
113916: LD_INT 1
113918: PPUSH
113919: CALL_OW 3
113923: PPUSH
113924: CALL_OW 1
113928: ST_TO_ADDR
// tmp := 1 ;
113929: LD_ADDR_VAR 0 3
113933: PUSH
113934: LD_STRING 1
113936: ST_TO_ADDR
// end ; normal := normal & tmp ;
113937: LD_ADDR_VAR 0 5
113941: PUSH
113942: LD_VAR 0 5
113946: PUSH
113947: LD_VAR 0 3
113951: STR
113952: ST_TO_ADDR
// end ;
113953: GO 113853
113955: POP
113956: POP
// for i = 1 to hardcoreCounter do
113957: LD_ADDR_VAR 0 8
113961: PUSH
113962: DOUBLE
113963: LD_INT 1
113965: DEC
113966: ST_TO_ADDR
113967: LD_EXP 145
113971: PUSH
113972: FOR_TO
113973: IFFALSE 114078
// begin tmp := 0 ;
113975: LD_ADDR_VAR 0 3
113979: PUSH
113980: LD_STRING 0
113982: ST_TO_ADDR
// if result [ 2 ] then
113983: LD_VAR 0 2
113987: PUSH
113988: LD_INT 2
113990: ARRAY
113991: IFFALSE 114060
// if result [ 2 ] [ 1 ] = 100 + i then
113993: LD_VAR 0 2
113997: PUSH
113998: LD_INT 2
114000: ARRAY
114001: PUSH
114002: LD_INT 1
114004: ARRAY
114005: PUSH
114006: LD_INT 100
114008: PUSH
114009: LD_VAR 0 8
114013: PLUS
114014: EQUAL
114015: IFFALSE 114060
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114017: LD_ADDR_VAR 0 2
114021: PUSH
114022: LD_VAR 0 2
114026: PPUSH
114027: LD_INT 2
114029: PPUSH
114030: LD_VAR 0 2
114034: PUSH
114035: LD_INT 2
114037: ARRAY
114038: PPUSH
114039: LD_INT 1
114041: PPUSH
114042: CALL_OW 3
114046: PPUSH
114047: CALL_OW 1
114051: ST_TO_ADDR
// tmp := 1 ;
114052: LD_ADDR_VAR 0 3
114056: PUSH
114057: LD_STRING 1
114059: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114060: LD_ADDR_VAR 0 6
114064: PUSH
114065: LD_VAR 0 6
114069: PUSH
114070: LD_VAR 0 3
114074: STR
114075: ST_TO_ADDR
// end ;
114076: GO 113972
114078: POP
114079: POP
// if isGameLoad then
114080: LD_VAR 0 1
114084: IFFALSE 114559
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114086: LD_ADDR_VAR 0 4
114090: PUSH
114091: LD_EXP 148
114095: PUSH
114096: LD_EXP 147
114100: PUSH
114101: LD_EXP 149
114105: PUSH
114106: LD_EXP 146
114110: PUSH
114111: LD_EXP 150
114115: PUSH
114116: LD_EXP 151
114120: PUSH
114121: LD_EXP 152
114125: PUSH
114126: LD_EXP 153
114130: PUSH
114131: LD_EXP 154
114135: PUSH
114136: LD_EXP 155
114140: PUSH
114141: LD_EXP 156
114145: PUSH
114146: LD_EXP 157
114150: PUSH
114151: LD_EXP 158
114155: PUSH
114156: LD_EXP 159
114160: PUSH
114161: LD_EXP 167
114165: PUSH
114166: LD_EXP 168
114170: PUSH
114171: LD_EXP 169
114175: PUSH
114176: LD_EXP 170
114180: PUSH
114181: LD_EXP 172
114185: PUSH
114186: LD_EXP 173
114190: PUSH
114191: LD_EXP 174
114195: PUSH
114196: LD_EXP 177
114200: PUSH
114201: LD_EXP 179
114205: PUSH
114206: LD_EXP 180
114210: PUSH
114211: LD_EXP 181
114215: PUSH
114216: LD_EXP 183
114220: PUSH
114221: LD_EXP 184
114225: PUSH
114226: LD_EXP 187
114230: PUSH
114231: LD_EXP 188
114235: PUSH
114236: LD_EXP 189
114240: PUSH
114241: LD_EXP 190
114245: PUSH
114246: LD_EXP 191
114250: PUSH
114251: LD_EXP 192
114255: PUSH
114256: LD_EXP 193
114260: PUSH
114261: LD_EXP 194
114265: PUSH
114266: LD_EXP 195
114270: PUSH
114271: LD_EXP 160
114275: PUSH
114276: LD_EXP 161
114280: PUSH
114281: LD_EXP 164
114285: PUSH
114286: LD_EXP 165
114290: PUSH
114291: LD_EXP 166
114295: PUSH
114296: LD_EXP 162
114300: PUSH
114301: LD_EXP 163
114305: PUSH
114306: LD_EXP 171
114310: PUSH
114311: LD_EXP 175
114315: PUSH
114316: LD_EXP 176
114320: PUSH
114321: LD_EXP 178
114325: PUSH
114326: LD_EXP 182
114330: PUSH
114331: LD_EXP 185
114335: PUSH
114336: LD_EXP 186
114340: PUSH
114341: LD_EXP 196
114345: PUSH
114346: LD_EXP 197
114350: PUSH
114351: LD_EXP 198
114355: PUSH
114356: LD_EXP 199
114360: PUSH
114361: EMPTY
114362: LIST
114363: LIST
114364: LIST
114365: LIST
114366: LIST
114367: LIST
114368: LIST
114369: LIST
114370: LIST
114371: LIST
114372: LIST
114373: LIST
114374: LIST
114375: LIST
114376: LIST
114377: LIST
114378: LIST
114379: LIST
114380: LIST
114381: LIST
114382: LIST
114383: LIST
114384: LIST
114385: LIST
114386: LIST
114387: LIST
114388: LIST
114389: LIST
114390: LIST
114391: LIST
114392: LIST
114393: LIST
114394: LIST
114395: LIST
114396: LIST
114397: LIST
114398: LIST
114399: LIST
114400: LIST
114401: LIST
114402: LIST
114403: LIST
114404: LIST
114405: LIST
114406: LIST
114407: LIST
114408: LIST
114409: LIST
114410: LIST
114411: LIST
114412: LIST
114413: LIST
114414: LIST
114415: LIST
114416: ST_TO_ADDR
// tmp :=  ;
114417: LD_ADDR_VAR 0 3
114421: PUSH
114422: LD_STRING 
114424: ST_TO_ADDR
// for i = 1 to normalCounter do
114425: LD_ADDR_VAR 0 8
114429: PUSH
114430: DOUBLE
114431: LD_INT 1
114433: DEC
114434: ST_TO_ADDR
114435: LD_EXP 144
114439: PUSH
114440: FOR_TO
114441: IFFALSE 114477
// begin if flags [ i ] then
114443: LD_VAR 0 4
114447: PUSH
114448: LD_VAR 0 8
114452: ARRAY
114453: IFFALSE 114475
// tmp := tmp & i & ; ;
114455: LD_ADDR_VAR 0 3
114459: PUSH
114460: LD_VAR 0 3
114464: PUSH
114465: LD_VAR 0 8
114469: STR
114470: PUSH
114471: LD_STRING ;
114473: STR
114474: ST_TO_ADDR
// end ;
114475: GO 114440
114477: POP
114478: POP
// for i = 1 to hardcoreCounter do
114479: LD_ADDR_VAR 0 8
114483: PUSH
114484: DOUBLE
114485: LD_INT 1
114487: DEC
114488: ST_TO_ADDR
114489: LD_EXP 145
114493: PUSH
114494: FOR_TO
114495: IFFALSE 114541
// begin if flags [ normalCounter + i ] then
114497: LD_VAR 0 4
114501: PUSH
114502: LD_EXP 144
114506: PUSH
114507: LD_VAR 0 8
114511: PLUS
114512: ARRAY
114513: IFFALSE 114539
// tmp := tmp & ( 100 + i ) & ; ;
114515: LD_ADDR_VAR 0 3
114519: PUSH
114520: LD_VAR 0 3
114524: PUSH
114525: LD_INT 100
114527: PUSH
114528: LD_VAR 0 8
114532: PLUS
114533: STR
114534: PUSH
114535: LD_STRING ;
114537: STR
114538: ST_TO_ADDR
// end ;
114539: GO 114494
114541: POP
114542: POP
// if tmp then
114543: LD_VAR 0 3
114547: IFFALSE 114559
// active := tmp ;
114549: LD_ADDR_VAR 0 7
114553: PUSH
114554: LD_VAR 0 3
114558: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114559: LD_STRING getStreamItemsFromMission("
114561: PUSH
114562: LD_VAR 0 5
114566: STR
114567: PUSH
114568: LD_STRING ","
114570: STR
114571: PUSH
114572: LD_VAR 0 6
114576: STR
114577: PUSH
114578: LD_STRING ","
114580: STR
114581: PUSH
114582: LD_VAR 0 7
114586: STR
114587: PUSH
114588: LD_STRING ")
114590: STR
114591: PPUSH
114592: CALL_OW 559
// end else
114596: GO 114605
// ToLua ( getStreamItemsFromMission("","","") ) ;
114598: LD_STRING getStreamItemsFromMission("","","")
114600: PPUSH
114601: CALL_OW 559
// end ;
114605: LD_VAR 0 2
114609: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114610: LD_EXP 143
114614: PUSH
114615: LD_EXP 148
114619: AND
114620: IFFALSE 114744
114622: GO 114624
114624: DISABLE
114625: LD_INT 0
114627: PPUSH
114628: PPUSH
// begin enable ;
114629: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114630: LD_ADDR_VAR 0 2
114634: PUSH
114635: LD_INT 22
114637: PUSH
114638: LD_OWVAR 2
114642: PUSH
114643: EMPTY
114644: LIST
114645: LIST
114646: PUSH
114647: LD_INT 2
114649: PUSH
114650: LD_INT 34
114652: PUSH
114653: LD_INT 7
114655: PUSH
114656: EMPTY
114657: LIST
114658: LIST
114659: PUSH
114660: LD_INT 34
114662: PUSH
114663: LD_INT 45
114665: PUSH
114666: EMPTY
114667: LIST
114668: LIST
114669: PUSH
114670: LD_INT 34
114672: PUSH
114673: LD_INT 28
114675: PUSH
114676: EMPTY
114677: LIST
114678: LIST
114679: PUSH
114680: LD_INT 34
114682: PUSH
114683: LD_INT 47
114685: PUSH
114686: EMPTY
114687: LIST
114688: LIST
114689: PUSH
114690: EMPTY
114691: LIST
114692: LIST
114693: LIST
114694: LIST
114695: LIST
114696: PUSH
114697: EMPTY
114698: LIST
114699: LIST
114700: PPUSH
114701: CALL_OW 69
114705: ST_TO_ADDR
// if not tmp then
114706: LD_VAR 0 2
114710: NOT
114711: IFFALSE 114715
// exit ;
114713: GO 114744
// for i in tmp do
114715: LD_ADDR_VAR 0 1
114719: PUSH
114720: LD_VAR 0 2
114724: PUSH
114725: FOR_IN
114726: IFFALSE 114742
// begin SetLives ( i , 0 ) ;
114728: LD_VAR 0 1
114732: PPUSH
114733: LD_INT 0
114735: PPUSH
114736: CALL_OW 234
// end ;
114740: GO 114725
114742: POP
114743: POP
// end ;
114744: PPOPN 2
114746: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114747: LD_EXP 143
114751: PUSH
114752: LD_EXP 149
114756: AND
114757: IFFALSE 114841
114759: GO 114761
114761: DISABLE
114762: LD_INT 0
114764: PPUSH
114765: PPUSH
// begin enable ;
114766: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114767: LD_ADDR_VAR 0 2
114771: PUSH
114772: LD_INT 22
114774: PUSH
114775: LD_OWVAR 2
114779: PUSH
114780: EMPTY
114781: LIST
114782: LIST
114783: PUSH
114784: LD_INT 32
114786: PUSH
114787: LD_INT 3
114789: PUSH
114790: EMPTY
114791: LIST
114792: LIST
114793: PUSH
114794: EMPTY
114795: LIST
114796: LIST
114797: PPUSH
114798: CALL_OW 69
114802: ST_TO_ADDR
// if not tmp then
114803: LD_VAR 0 2
114807: NOT
114808: IFFALSE 114812
// exit ;
114810: GO 114841
// for i in tmp do
114812: LD_ADDR_VAR 0 1
114816: PUSH
114817: LD_VAR 0 2
114821: PUSH
114822: FOR_IN
114823: IFFALSE 114839
// begin SetLives ( i , 0 ) ;
114825: LD_VAR 0 1
114829: PPUSH
114830: LD_INT 0
114832: PPUSH
114833: CALL_OW 234
// end ;
114837: GO 114822
114839: POP
114840: POP
// end ;
114841: PPOPN 2
114843: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
114844: LD_EXP 143
114848: PUSH
114849: LD_EXP 146
114853: AND
114854: IFFALSE 114947
114856: GO 114858
114858: DISABLE
114859: LD_INT 0
114861: PPUSH
// begin enable ;
114862: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
114863: LD_ADDR_VAR 0 1
114867: PUSH
114868: LD_INT 22
114870: PUSH
114871: LD_OWVAR 2
114875: PUSH
114876: EMPTY
114877: LIST
114878: LIST
114879: PUSH
114880: LD_INT 2
114882: PUSH
114883: LD_INT 25
114885: PUSH
114886: LD_INT 5
114888: PUSH
114889: EMPTY
114890: LIST
114891: LIST
114892: PUSH
114893: LD_INT 25
114895: PUSH
114896: LD_INT 9
114898: PUSH
114899: EMPTY
114900: LIST
114901: LIST
114902: PUSH
114903: LD_INT 25
114905: PUSH
114906: LD_INT 8
114908: PUSH
114909: EMPTY
114910: LIST
114911: LIST
114912: PUSH
114913: EMPTY
114914: LIST
114915: LIST
114916: LIST
114917: LIST
114918: PUSH
114919: EMPTY
114920: LIST
114921: LIST
114922: PPUSH
114923: CALL_OW 69
114927: PUSH
114928: FOR_IN
114929: IFFALSE 114945
// begin SetClass ( i , 1 ) ;
114931: LD_VAR 0 1
114935: PPUSH
114936: LD_INT 1
114938: PPUSH
114939: CALL_OW 336
// end ;
114943: GO 114928
114945: POP
114946: POP
// end ;
114947: PPOPN 1
114949: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
114950: LD_EXP 143
114954: PUSH
114955: LD_EXP 147
114959: AND
114960: PUSH
114961: LD_OWVAR 65
114965: PUSH
114966: LD_INT 7
114968: LESS
114969: AND
114970: IFFALSE 114984
114972: GO 114974
114974: DISABLE
// begin enable ;
114975: ENABLE
// game_speed := 7 ;
114976: LD_ADDR_OWVAR 65
114980: PUSH
114981: LD_INT 7
114983: ST_TO_ADDR
// end ;
114984: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
114985: LD_EXP 143
114989: PUSH
114990: LD_EXP 150
114994: AND
114995: IFFALSE 115197
114997: GO 114999
114999: DISABLE
115000: LD_INT 0
115002: PPUSH
115003: PPUSH
115004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115005: LD_ADDR_VAR 0 3
115009: PUSH
115010: LD_INT 81
115012: PUSH
115013: LD_OWVAR 2
115017: PUSH
115018: EMPTY
115019: LIST
115020: LIST
115021: PUSH
115022: LD_INT 21
115024: PUSH
115025: LD_INT 1
115027: PUSH
115028: EMPTY
115029: LIST
115030: LIST
115031: PUSH
115032: EMPTY
115033: LIST
115034: LIST
115035: PPUSH
115036: CALL_OW 69
115040: ST_TO_ADDR
// if not tmp then
115041: LD_VAR 0 3
115045: NOT
115046: IFFALSE 115050
// exit ;
115048: GO 115197
// if tmp > 5 then
115050: LD_VAR 0 3
115054: PUSH
115055: LD_INT 5
115057: GREATER
115058: IFFALSE 115070
// k := 5 else
115060: LD_ADDR_VAR 0 2
115064: PUSH
115065: LD_INT 5
115067: ST_TO_ADDR
115068: GO 115080
// k := tmp ;
115070: LD_ADDR_VAR 0 2
115074: PUSH
115075: LD_VAR 0 3
115079: ST_TO_ADDR
// for i := 1 to k do
115080: LD_ADDR_VAR 0 1
115084: PUSH
115085: DOUBLE
115086: LD_INT 1
115088: DEC
115089: ST_TO_ADDR
115090: LD_VAR 0 2
115094: PUSH
115095: FOR_TO
115096: IFFALSE 115195
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115098: LD_VAR 0 3
115102: PUSH
115103: LD_VAR 0 1
115107: ARRAY
115108: PPUSH
115109: LD_VAR 0 1
115113: PUSH
115114: LD_INT 4
115116: MOD
115117: PUSH
115118: LD_INT 1
115120: PLUS
115121: PPUSH
115122: CALL_OW 259
115126: PUSH
115127: LD_INT 10
115129: LESS
115130: IFFALSE 115193
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115132: LD_VAR 0 3
115136: PUSH
115137: LD_VAR 0 1
115141: ARRAY
115142: PPUSH
115143: LD_VAR 0 1
115147: PUSH
115148: LD_INT 4
115150: MOD
115151: PUSH
115152: LD_INT 1
115154: PLUS
115155: PPUSH
115156: LD_VAR 0 3
115160: PUSH
115161: LD_VAR 0 1
115165: ARRAY
115166: PPUSH
115167: LD_VAR 0 1
115171: PUSH
115172: LD_INT 4
115174: MOD
115175: PUSH
115176: LD_INT 1
115178: PLUS
115179: PPUSH
115180: CALL_OW 259
115184: PUSH
115185: LD_INT 1
115187: PLUS
115188: PPUSH
115189: CALL_OW 237
115193: GO 115095
115195: POP
115196: POP
// end ;
115197: PPOPN 3
115199: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115200: LD_EXP 143
115204: PUSH
115205: LD_EXP 151
115209: AND
115210: IFFALSE 115230
115212: GO 115214
115214: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115215: LD_INT 4
115217: PPUSH
115218: LD_OWVAR 2
115222: PPUSH
115223: LD_INT 0
115225: PPUSH
115226: CALL_OW 324
115230: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115231: LD_EXP 143
115235: PUSH
115236: LD_EXP 180
115240: AND
115241: IFFALSE 115261
115243: GO 115245
115245: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115246: LD_INT 19
115248: PPUSH
115249: LD_OWVAR 2
115253: PPUSH
115254: LD_INT 0
115256: PPUSH
115257: CALL_OW 324
115261: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115262: LD_EXP 143
115266: PUSH
115267: LD_EXP 152
115271: AND
115272: IFFALSE 115374
115274: GO 115276
115276: DISABLE
115277: LD_INT 0
115279: PPUSH
115280: PPUSH
// begin enable ;
115281: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115282: LD_ADDR_VAR 0 2
115286: PUSH
115287: LD_INT 22
115289: PUSH
115290: LD_OWVAR 2
115294: PUSH
115295: EMPTY
115296: LIST
115297: LIST
115298: PUSH
115299: LD_INT 2
115301: PUSH
115302: LD_INT 34
115304: PUSH
115305: LD_INT 11
115307: PUSH
115308: EMPTY
115309: LIST
115310: LIST
115311: PUSH
115312: LD_INT 34
115314: PUSH
115315: LD_INT 30
115317: PUSH
115318: EMPTY
115319: LIST
115320: LIST
115321: PUSH
115322: EMPTY
115323: LIST
115324: LIST
115325: LIST
115326: PUSH
115327: EMPTY
115328: LIST
115329: LIST
115330: PPUSH
115331: CALL_OW 69
115335: ST_TO_ADDR
// if not tmp then
115336: LD_VAR 0 2
115340: NOT
115341: IFFALSE 115345
// exit ;
115343: GO 115374
// for i in tmp do
115345: LD_ADDR_VAR 0 1
115349: PUSH
115350: LD_VAR 0 2
115354: PUSH
115355: FOR_IN
115356: IFFALSE 115372
// begin SetLives ( i , 0 ) ;
115358: LD_VAR 0 1
115362: PPUSH
115363: LD_INT 0
115365: PPUSH
115366: CALL_OW 234
// end ;
115370: GO 115355
115372: POP
115373: POP
// end ;
115374: PPOPN 2
115376: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115377: LD_EXP 143
115381: PUSH
115382: LD_EXP 153
115386: AND
115387: IFFALSE 115407
115389: GO 115391
115391: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115392: LD_INT 32
115394: PPUSH
115395: LD_OWVAR 2
115399: PPUSH
115400: LD_INT 0
115402: PPUSH
115403: CALL_OW 324
115407: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115408: LD_EXP 143
115412: PUSH
115413: LD_EXP 154
115417: AND
115418: IFFALSE 115599
115420: GO 115422
115422: DISABLE
115423: LD_INT 0
115425: PPUSH
115426: PPUSH
115427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115428: LD_ADDR_VAR 0 2
115432: PUSH
115433: LD_INT 22
115435: PUSH
115436: LD_OWVAR 2
115440: PUSH
115441: EMPTY
115442: LIST
115443: LIST
115444: PUSH
115445: LD_INT 33
115447: PUSH
115448: LD_INT 3
115450: PUSH
115451: EMPTY
115452: LIST
115453: LIST
115454: PUSH
115455: EMPTY
115456: LIST
115457: LIST
115458: PPUSH
115459: CALL_OW 69
115463: ST_TO_ADDR
// if not tmp then
115464: LD_VAR 0 2
115468: NOT
115469: IFFALSE 115473
// exit ;
115471: GO 115599
// side := 0 ;
115473: LD_ADDR_VAR 0 3
115477: PUSH
115478: LD_INT 0
115480: ST_TO_ADDR
// for i := 1 to 8 do
115481: LD_ADDR_VAR 0 1
115485: PUSH
115486: DOUBLE
115487: LD_INT 1
115489: DEC
115490: ST_TO_ADDR
115491: LD_INT 8
115493: PUSH
115494: FOR_TO
115495: IFFALSE 115543
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115497: LD_OWVAR 2
115501: PUSH
115502: LD_VAR 0 1
115506: NONEQUAL
115507: PUSH
115508: LD_OWVAR 2
115512: PPUSH
115513: LD_VAR 0 1
115517: PPUSH
115518: CALL_OW 81
115522: PUSH
115523: LD_INT 2
115525: EQUAL
115526: AND
115527: IFFALSE 115541
// begin side := i ;
115529: LD_ADDR_VAR 0 3
115533: PUSH
115534: LD_VAR 0 1
115538: ST_TO_ADDR
// break ;
115539: GO 115543
// end ;
115541: GO 115494
115543: POP
115544: POP
// if not side then
115545: LD_VAR 0 3
115549: NOT
115550: IFFALSE 115554
// exit ;
115552: GO 115599
// for i := 1 to tmp do
115554: LD_ADDR_VAR 0 1
115558: PUSH
115559: DOUBLE
115560: LD_INT 1
115562: DEC
115563: ST_TO_ADDR
115564: LD_VAR 0 2
115568: PUSH
115569: FOR_TO
115570: IFFALSE 115597
// if Prob ( 60 ) then
115572: LD_INT 60
115574: PPUSH
115575: CALL_OW 13
115579: IFFALSE 115595
// SetSide ( i , side ) ;
115581: LD_VAR 0 1
115585: PPUSH
115586: LD_VAR 0 3
115590: PPUSH
115591: CALL_OW 235
115595: GO 115569
115597: POP
115598: POP
// end ;
115599: PPOPN 3
115601: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115602: LD_EXP 143
115606: PUSH
115607: LD_EXP 156
115611: AND
115612: IFFALSE 115731
115614: GO 115616
115616: DISABLE
115617: LD_INT 0
115619: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115620: LD_ADDR_VAR 0 1
115624: PUSH
115625: LD_INT 22
115627: PUSH
115628: LD_OWVAR 2
115632: PUSH
115633: EMPTY
115634: LIST
115635: LIST
115636: PUSH
115637: LD_INT 21
115639: PUSH
115640: LD_INT 1
115642: PUSH
115643: EMPTY
115644: LIST
115645: LIST
115646: PUSH
115647: LD_INT 3
115649: PUSH
115650: LD_INT 23
115652: PUSH
115653: LD_INT 0
115655: PUSH
115656: EMPTY
115657: LIST
115658: LIST
115659: PUSH
115660: EMPTY
115661: LIST
115662: LIST
115663: PUSH
115664: EMPTY
115665: LIST
115666: LIST
115667: LIST
115668: PPUSH
115669: CALL_OW 69
115673: PUSH
115674: FOR_IN
115675: IFFALSE 115729
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115677: LD_VAR 0 1
115681: PPUSH
115682: CALL_OW 257
115686: PUSH
115687: LD_INT 1
115689: PUSH
115690: LD_INT 2
115692: PUSH
115693: LD_INT 3
115695: PUSH
115696: LD_INT 4
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: IN
115705: IFFALSE 115727
// SetClass ( un , rand ( 1 , 4 ) ) ;
115707: LD_VAR 0 1
115711: PPUSH
115712: LD_INT 1
115714: PPUSH
115715: LD_INT 4
115717: PPUSH
115718: CALL_OW 12
115722: PPUSH
115723: CALL_OW 336
115727: GO 115674
115729: POP
115730: POP
// end ;
115731: PPOPN 1
115733: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115734: LD_EXP 143
115738: PUSH
115739: LD_EXP 155
115743: AND
115744: IFFALSE 115823
115746: GO 115748
115748: DISABLE
115749: LD_INT 0
115751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115752: LD_ADDR_VAR 0 1
115756: PUSH
115757: LD_INT 22
115759: PUSH
115760: LD_OWVAR 2
115764: PUSH
115765: EMPTY
115766: LIST
115767: LIST
115768: PUSH
115769: LD_INT 21
115771: PUSH
115772: LD_INT 3
115774: PUSH
115775: EMPTY
115776: LIST
115777: LIST
115778: PUSH
115779: EMPTY
115780: LIST
115781: LIST
115782: PPUSH
115783: CALL_OW 69
115787: ST_TO_ADDR
// if not tmp then
115788: LD_VAR 0 1
115792: NOT
115793: IFFALSE 115797
// exit ;
115795: GO 115823
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
115797: LD_VAR 0 1
115801: PUSH
115802: LD_INT 1
115804: PPUSH
115805: LD_VAR 0 1
115809: PPUSH
115810: CALL_OW 12
115814: ARRAY
115815: PPUSH
115816: LD_INT 100
115818: PPUSH
115819: CALL_OW 234
// end ;
115823: PPOPN 1
115825: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
115826: LD_EXP 143
115830: PUSH
115831: LD_EXP 157
115835: AND
115836: IFFALSE 115934
115838: GO 115840
115840: DISABLE
115841: LD_INT 0
115843: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115844: LD_ADDR_VAR 0 1
115848: PUSH
115849: LD_INT 22
115851: PUSH
115852: LD_OWVAR 2
115856: PUSH
115857: EMPTY
115858: LIST
115859: LIST
115860: PUSH
115861: LD_INT 21
115863: PUSH
115864: LD_INT 1
115866: PUSH
115867: EMPTY
115868: LIST
115869: LIST
115870: PUSH
115871: EMPTY
115872: LIST
115873: LIST
115874: PPUSH
115875: CALL_OW 69
115879: ST_TO_ADDR
// if not tmp then
115880: LD_VAR 0 1
115884: NOT
115885: IFFALSE 115889
// exit ;
115887: GO 115934
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
115889: LD_VAR 0 1
115893: PUSH
115894: LD_INT 1
115896: PPUSH
115897: LD_VAR 0 1
115901: PPUSH
115902: CALL_OW 12
115906: ARRAY
115907: PPUSH
115908: LD_INT 1
115910: PPUSH
115911: LD_INT 4
115913: PPUSH
115914: CALL_OW 12
115918: PPUSH
115919: LD_INT 3000
115921: PPUSH
115922: LD_INT 9000
115924: PPUSH
115925: CALL_OW 12
115929: PPUSH
115930: CALL_OW 492
// end ;
115934: PPOPN 1
115936: END
// every 0 0$1 trigger StreamModeActive and sDepot do
115937: LD_EXP 143
115941: PUSH
115942: LD_EXP 158
115946: AND
115947: IFFALSE 115967
115949: GO 115951
115951: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
115952: LD_INT 1
115954: PPUSH
115955: LD_OWVAR 2
115959: PPUSH
115960: LD_INT 0
115962: PPUSH
115963: CALL_OW 324
115967: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
115968: LD_EXP 143
115972: PUSH
115973: LD_EXP 159
115977: AND
115978: IFFALSE 116061
115980: GO 115982
115982: DISABLE
115983: LD_INT 0
115985: PPUSH
115986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115987: LD_ADDR_VAR 0 2
115991: PUSH
115992: LD_INT 22
115994: PUSH
115995: LD_OWVAR 2
115999: PUSH
116000: EMPTY
116001: LIST
116002: LIST
116003: PUSH
116004: LD_INT 21
116006: PUSH
116007: LD_INT 3
116009: PUSH
116010: EMPTY
116011: LIST
116012: LIST
116013: PUSH
116014: EMPTY
116015: LIST
116016: LIST
116017: PPUSH
116018: CALL_OW 69
116022: ST_TO_ADDR
// if not tmp then
116023: LD_VAR 0 2
116027: NOT
116028: IFFALSE 116032
// exit ;
116030: GO 116061
// for i in tmp do
116032: LD_ADDR_VAR 0 1
116036: PUSH
116037: LD_VAR 0 2
116041: PUSH
116042: FOR_IN
116043: IFFALSE 116059
// SetBLevel ( i , 10 ) ;
116045: LD_VAR 0 1
116049: PPUSH
116050: LD_INT 10
116052: PPUSH
116053: CALL_OW 241
116057: GO 116042
116059: POP
116060: POP
// end ;
116061: PPOPN 2
116063: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116064: LD_EXP 143
116068: PUSH
116069: LD_EXP 160
116073: AND
116074: IFFALSE 116185
116076: GO 116078
116078: DISABLE
116079: LD_INT 0
116081: PPUSH
116082: PPUSH
116083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116084: LD_ADDR_VAR 0 3
116088: PUSH
116089: LD_INT 22
116091: PUSH
116092: LD_OWVAR 2
116096: PUSH
116097: EMPTY
116098: LIST
116099: LIST
116100: PUSH
116101: LD_INT 25
116103: PUSH
116104: LD_INT 1
116106: PUSH
116107: EMPTY
116108: LIST
116109: LIST
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PPUSH
116115: CALL_OW 69
116119: ST_TO_ADDR
// if not tmp then
116120: LD_VAR 0 3
116124: NOT
116125: IFFALSE 116129
// exit ;
116127: GO 116185
// un := tmp [ rand ( 1 , tmp ) ] ;
116129: LD_ADDR_VAR 0 2
116133: PUSH
116134: LD_VAR 0 3
116138: PUSH
116139: LD_INT 1
116141: PPUSH
116142: LD_VAR 0 3
116146: PPUSH
116147: CALL_OW 12
116151: ARRAY
116152: ST_TO_ADDR
// if Crawls ( un ) then
116153: LD_VAR 0 2
116157: PPUSH
116158: CALL_OW 318
116162: IFFALSE 116173
// ComWalk ( un ) ;
116164: LD_VAR 0 2
116168: PPUSH
116169: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116173: LD_VAR 0 2
116177: PPUSH
116178: LD_INT 5
116180: PPUSH
116181: CALL_OW 336
// end ;
116185: PPOPN 3
116187: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116188: LD_EXP 143
116192: PUSH
116193: LD_EXP 161
116197: AND
116198: PUSH
116199: LD_OWVAR 67
116203: PUSH
116204: LD_INT 4
116206: LESS
116207: AND
116208: IFFALSE 116227
116210: GO 116212
116212: DISABLE
// begin Difficulty := Difficulty + 1 ;
116213: LD_ADDR_OWVAR 67
116217: PUSH
116218: LD_OWVAR 67
116222: PUSH
116223: LD_INT 1
116225: PLUS
116226: ST_TO_ADDR
// end ;
116227: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116228: LD_EXP 143
116232: PUSH
116233: LD_EXP 162
116237: AND
116238: IFFALSE 116341
116240: GO 116242
116242: DISABLE
116243: LD_INT 0
116245: PPUSH
// begin for i := 1 to 5 do
116246: LD_ADDR_VAR 0 1
116250: PUSH
116251: DOUBLE
116252: LD_INT 1
116254: DEC
116255: ST_TO_ADDR
116256: LD_INT 5
116258: PUSH
116259: FOR_TO
116260: IFFALSE 116339
// begin uc_nation := nation_nature ;
116262: LD_ADDR_OWVAR 21
116266: PUSH
116267: LD_INT 0
116269: ST_TO_ADDR
// uc_side := 0 ;
116270: LD_ADDR_OWVAR 20
116274: PUSH
116275: LD_INT 0
116277: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116278: LD_ADDR_OWVAR 29
116282: PUSH
116283: LD_INT 12
116285: PUSH
116286: LD_INT 12
116288: PUSH
116289: EMPTY
116290: LIST
116291: LIST
116292: ST_TO_ADDR
// hc_agressivity := 20 ;
116293: LD_ADDR_OWVAR 35
116297: PUSH
116298: LD_INT 20
116300: ST_TO_ADDR
// hc_class := class_tiger ;
116301: LD_ADDR_OWVAR 28
116305: PUSH
116306: LD_INT 14
116308: ST_TO_ADDR
// hc_gallery :=  ;
116309: LD_ADDR_OWVAR 33
116313: PUSH
116314: LD_STRING 
116316: ST_TO_ADDR
// hc_name :=  ;
116317: LD_ADDR_OWVAR 26
116321: PUSH
116322: LD_STRING 
116324: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116325: CALL_OW 44
116329: PPUSH
116330: LD_INT 0
116332: PPUSH
116333: CALL_OW 51
// end ;
116337: GO 116259
116339: POP
116340: POP
// end ;
116341: PPOPN 1
116343: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116344: LD_EXP 143
116348: PUSH
116349: LD_EXP 163
116353: AND
116354: IFFALSE 116363
116356: GO 116358
116358: DISABLE
// StreamSibBomb ;
116359: CALL 116364 0 0
116363: END
// export function StreamSibBomb ; var i , x , y ; begin
116364: LD_INT 0
116366: PPUSH
116367: PPUSH
116368: PPUSH
116369: PPUSH
// result := false ;
116370: LD_ADDR_VAR 0 1
116374: PUSH
116375: LD_INT 0
116377: ST_TO_ADDR
// for i := 1 to 16 do
116378: LD_ADDR_VAR 0 2
116382: PUSH
116383: DOUBLE
116384: LD_INT 1
116386: DEC
116387: ST_TO_ADDR
116388: LD_INT 16
116390: PUSH
116391: FOR_TO
116392: IFFALSE 116591
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116394: LD_ADDR_VAR 0 3
116398: PUSH
116399: LD_INT 10
116401: PUSH
116402: LD_INT 20
116404: PUSH
116405: LD_INT 30
116407: PUSH
116408: LD_INT 40
116410: PUSH
116411: LD_INT 50
116413: PUSH
116414: LD_INT 60
116416: PUSH
116417: LD_INT 70
116419: PUSH
116420: LD_INT 80
116422: PUSH
116423: LD_INT 90
116425: PUSH
116426: LD_INT 100
116428: PUSH
116429: LD_INT 110
116431: PUSH
116432: LD_INT 120
116434: PUSH
116435: LD_INT 130
116437: PUSH
116438: LD_INT 140
116440: PUSH
116441: LD_INT 150
116443: PUSH
116444: EMPTY
116445: LIST
116446: LIST
116447: LIST
116448: LIST
116449: LIST
116450: LIST
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: PUSH
116461: LD_INT 1
116463: PPUSH
116464: LD_INT 15
116466: PPUSH
116467: CALL_OW 12
116471: ARRAY
116472: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116473: LD_ADDR_VAR 0 4
116477: PUSH
116478: LD_INT 10
116480: PUSH
116481: LD_INT 20
116483: PUSH
116484: LD_INT 30
116486: PUSH
116487: LD_INT 40
116489: PUSH
116490: LD_INT 50
116492: PUSH
116493: LD_INT 60
116495: PUSH
116496: LD_INT 70
116498: PUSH
116499: LD_INT 80
116501: PUSH
116502: LD_INT 90
116504: PUSH
116505: LD_INT 100
116507: PUSH
116508: LD_INT 110
116510: PUSH
116511: LD_INT 120
116513: PUSH
116514: LD_INT 130
116516: PUSH
116517: LD_INT 140
116519: PUSH
116520: LD_INT 150
116522: PUSH
116523: EMPTY
116524: LIST
116525: LIST
116526: LIST
116527: LIST
116528: LIST
116529: LIST
116530: LIST
116531: LIST
116532: LIST
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: PUSH
116540: LD_INT 1
116542: PPUSH
116543: LD_INT 15
116545: PPUSH
116546: CALL_OW 12
116550: ARRAY
116551: ST_TO_ADDR
// if ValidHex ( x , y ) then
116552: LD_VAR 0 3
116556: PPUSH
116557: LD_VAR 0 4
116561: PPUSH
116562: CALL_OW 488
116566: IFFALSE 116589
// begin result := [ x , y ] ;
116568: LD_ADDR_VAR 0 1
116572: PUSH
116573: LD_VAR 0 3
116577: PUSH
116578: LD_VAR 0 4
116582: PUSH
116583: EMPTY
116584: LIST
116585: LIST
116586: ST_TO_ADDR
// break ;
116587: GO 116591
// end ; end ;
116589: GO 116391
116591: POP
116592: POP
// if result then
116593: LD_VAR 0 1
116597: IFFALSE 116657
// begin ToLua ( playSibBomb() ) ;
116599: LD_STRING playSibBomb()
116601: PPUSH
116602: CALL_OW 559
// wait ( 0 0$14 ) ;
116606: LD_INT 490
116608: PPUSH
116609: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116613: LD_VAR 0 1
116617: PUSH
116618: LD_INT 1
116620: ARRAY
116621: PPUSH
116622: LD_VAR 0 1
116626: PUSH
116627: LD_INT 2
116629: ARRAY
116630: PPUSH
116631: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116635: LD_VAR 0 1
116639: PUSH
116640: LD_INT 1
116642: ARRAY
116643: PPUSH
116644: LD_VAR 0 1
116648: PUSH
116649: LD_INT 2
116651: ARRAY
116652: PPUSH
116653: CALL_OW 429
// end ; end ;
116657: LD_VAR 0 1
116661: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116662: LD_EXP 143
116666: PUSH
116667: LD_EXP 165
116671: AND
116672: IFFALSE 116684
116674: GO 116676
116676: DISABLE
// YouLost (  ) ;
116677: LD_STRING 
116679: PPUSH
116680: CALL_OW 104
116684: END
// every 0 0$1 trigger StreamModeActive and sFog do
116685: LD_EXP 143
116689: PUSH
116690: LD_EXP 164
116694: AND
116695: IFFALSE 116709
116697: GO 116699
116699: DISABLE
// FogOff ( your_side ) ;
116700: LD_OWVAR 2
116704: PPUSH
116705: CALL_OW 344
116709: END
// every 0 0$1 trigger StreamModeActive and sSun do
116710: LD_EXP 143
116714: PUSH
116715: LD_EXP 166
116719: AND
116720: IFFALSE 116748
116722: GO 116724
116724: DISABLE
// begin solar_recharge_percent := 0 ;
116725: LD_ADDR_OWVAR 79
116729: PUSH
116730: LD_INT 0
116732: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116733: LD_INT 10500
116735: PPUSH
116736: CALL_OW 67
// solar_recharge_percent := 100 ;
116740: LD_ADDR_OWVAR 79
116744: PUSH
116745: LD_INT 100
116747: ST_TO_ADDR
// end ;
116748: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116749: LD_EXP 143
116753: PUSH
116754: LD_EXP 167
116758: AND
116759: IFFALSE 116998
116761: GO 116763
116763: DISABLE
116764: LD_INT 0
116766: PPUSH
116767: PPUSH
116768: PPUSH
// begin tmp := [ ] ;
116769: LD_ADDR_VAR 0 3
116773: PUSH
116774: EMPTY
116775: ST_TO_ADDR
// for i := 1 to 6 do
116776: LD_ADDR_VAR 0 1
116780: PUSH
116781: DOUBLE
116782: LD_INT 1
116784: DEC
116785: ST_TO_ADDR
116786: LD_INT 6
116788: PUSH
116789: FOR_TO
116790: IFFALSE 116895
// begin uc_nation := nation_nature ;
116792: LD_ADDR_OWVAR 21
116796: PUSH
116797: LD_INT 0
116799: ST_TO_ADDR
// uc_side := 0 ;
116800: LD_ADDR_OWVAR 20
116804: PUSH
116805: LD_INT 0
116807: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116808: LD_ADDR_OWVAR 29
116812: PUSH
116813: LD_INT 12
116815: PUSH
116816: LD_INT 12
116818: PUSH
116819: EMPTY
116820: LIST
116821: LIST
116822: ST_TO_ADDR
// hc_agressivity := 20 ;
116823: LD_ADDR_OWVAR 35
116827: PUSH
116828: LD_INT 20
116830: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
116831: LD_ADDR_OWVAR 28
116835: PUSH
116836: LD_INT 17
116838: ST_TO_ADDR
// hc_gallery :=  ;
116839: LD_ADDR_OWVAR 33
116843: PUSH
116844: LD_STRING 
116846: ST_TO_ADDR
// hc_name :=  ;
116847: LD_ADDR_OWVAR 26
116851: PUSH
116852: LD_STRING 
116854: ST_TO_ADDR
// un := CreateHuman ;
116855: LD_ADDR_VAR 0 2
116859: PUSH
116860: CALL_OW 44
116864: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
116865: LD_VAR 0 2
116869: PPUSH
116870: LD_INT 1
116872: PPUSH
116873: CALL_OW 51
// tmp := tmp ^ un ;
116877: LD_ADDR_VAR 0 3
116881: PUSH
116882: LD_VAR 0 3
116886: PUSH
116887: LD_VAR 0 2
116891: ADD
116892: ST_TO_ADDR
// end ;
116893: GO 116789
116895: POP
116896: POP
// repeat wait ( 0 0$1 ) ;
116897: LD_INT 35
116899: PPUSH
116900: CALL_OW 67
// for un in tmp do
116904: LD_ADDR_VAR 0 2
116908: PUSH
116909: LD_VAR 0 3
116913: PUSH
116914: FOR_IN
116915: IFFALSE 116989
// begin if IsDead ( un ) then
116917: LD_VAR 0 2
116921: PPUSH
116922: CALL_OW 301
116926: IFFALSE 116946
// begin tmp := tmp diff un ;
116928: LD_ADDR_VAR 0 3
116932: PUSH
116933: LD_VAR 0 3
116937: PUSH
116938: LD_VAR 0 2
116942: DIFF
116943: ST_TO_ADDR
// continue ;
116944: GO 116914
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
116946: LD_VAR 0 2
116950: PPUSH
116951: LD_INT 3
116953: PUSH
116954: LD_INT 22
116956: PUSH
116957: LD_INT 0
116959: PUSH
116960: EMPTY
116961: LIST
116962: LIST
116963: PUSH
116964: EMPTY
116965: LIST
116966: LIST
116967: PPUSH
116968: CALL_OW 69
116972: PPUSH
116973: LD_VAR 0 2
116977: PPUSH
116978: CALL_OW 74
116982: PPUSH
116983: CALL_OW 115
// end ;
116987: GO 116914
116989: POP
116990: POP
// until not tmp ;
116991: LD_VAR 0 3
116995: NOT
116996: IFFALSE 116897
// end ;
116998: PPOPN 3
117000: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117001: LD_EXP 143
117005: PUSH
117006: LD_EXP 168
117010: AND
117011: IFFALSE 117065
117013: GO 117015
117015: DISABLE
// begin ToLua ( displayTroll(); ) ;
117016: LD_STRING displayTroll();
117018: PPUSH
117019: CALL_OW 559
// wait ( 3 3$00 ) ;
117023: LD_INT 6300
117025: PPUSH
117026: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117030: LD_STRING hideTroll();
117032: PPUSH
117033: CALL_OW 559
// wait ( 1 1$00 ) ;
117037: LD_INT 2100
117039: PPUSH
117040: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117044: LD_STRING displayTroll();
117046: PPUSH
117047: CALL_OW 559
// wait ( 1 1$00 ) ;
117051: LD_INT 2100
117053: PPUSH
117054: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117058: LD_STRING hideTroll();
117060: PPUSH
117061: CALL_OW 559
// end ;
117065: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117066: LD_EXP 143
117070: PUSH
117071: LD_EXP 169
117075: AND
117076: IFFALSE 117139
117078: GO 117080
117080: DISABLE
117081: LD_INT 0
117083: PPUSH
// begin p := 0 ;
117084: LD_ADDR_VAR 0 1
117088: PUSH
117089: LD_INT 0
117091: ST_TO_ADDR
// repeat game_speed := 1 ;
117092: LD_ADDR_OWVAR 65
117096: PUSH
117097: LD_INT 1
117099: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117100: LD_INT 35
117102: PPUSH
117103: CALL_OW 67
// p := p + 1 ;
117107: LD_ADDR_VAR 0 1
117111: PUSH
117112: LD_VAR 0 1
117116: PUSH
117117: LD_INT 1
117119: PLUS
117120: ST_TO_ADDR
// until p >= 60 ;
117121: LD_VAR 0 1
117125: PUSH
117126: LD_INT 60
117128: GREATEREQUAL
117129: IFFALSE 117092
// game_speed := 4 ;
117131: LD_ADDR_OWVAR 65
117135: PUSH
117136: LD_INT 4
117138: ST_TO_ADDR
// end ;
117139: PPOPN 1
117141: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117142: LD_EXP 143
117146: PUSH
117147: LD_EXP 170
117151: AND
117152: IFFALSE 117298
117154: GO 117156
117156: DISABLE
117157: LD_INT 0
117159: PPUSH
117160: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117161: LD_ADDR_VAR 0 1
117165: PUSH
117166: LD_INT 22
117168: PUSH
117169: LD_OWVAR 2
117173: PUSH
117174: EMPTY
117175: LIST
117176: LIST
117177: PUSH
117178: LD_INT 2
117180: PUSH
117181: LD_INT 30
117183: PUSH
117184: LD_INT 0
117186: PUSH
117187: EMPTY
117188: LIST
117189: LIST
117190: PUSH
117191: LD_INT 30
117193: PUSH
117194: LD_INT 1
117196: PUSH
117197: EMPTY
117198: LIST
117199: LIST
117200: PUSH
117201: EMPTY
117202: LIST
117203: LIST
117204: LIST
117205: PUSH
117206: EMPTY
117207: LIST
117208: LIST
117209: PPUSH
117210: CALL_OW 69
117214: ST_TO_ADDR
// if not depot then
117215: LD_VAR 0 1
117219: NOT
117220: IFFALSE 117224
// exit ;
117222: GO 117298
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117224: LD_ADDR_VAR 0 2
117228: PUSH
117229: LD_VAR 0 1
117233: PUSH
117234: LD_INT 1
117236: PPUSH
117237: LD_VAR 0 1
117241: PPUSH
117242: CALL_OW 12
117246: ARRAY
117247: PPUSH
117248: CALL_OW 274
117252: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117253: LD_VAR 0 2
117257: PPUSH
117258: LD_INT 1
117260: PPUSH
117261: LD_INT 0
117263: PPUSH
117264: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117268: LD_VAR 0 2
117272: PPUSH
117273: LD_INT 2
117275: PPUSH
117276: LD_INT 0
117278: PPUSH
117279: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117283: LD_VAR 0 2
117287: PPUSH
117288: LD_INT 3
117290: PPUSH
117291: LD_INT 0
117293: PPUSH
117294: CALL_OW 277
// end ;
117298: PPOPN 2
117300: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117301: LD_EXP 143
117305: PUSH
117306: LD_EXP 171
117310: AND
117311: IFFALSE 117408
117313: GO 117315
117315: DISABLE
117316: LD_INT 0
117318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117319: LD_ADDR_VAR 0 1
117323: PUSH
117324: LD_INT 22
117326: PUSH
117327: LD_OWVAR 2
117331: PUSH
117332: EMPTY
117333: LIST
117334: LIST
117335: PUSH
117336: LD_INT 21
117338: PUSH
117339: LD_INT 1
117341: PUSH
117342: EMPTY
117343: LIST
117344: LIST
117345: PUSH
117346: LD_INT 3
117348: PUSH
117349: LD_INT 23
117351: PUSH
117352: LD_INT 0
117354: PUSH
117355: EMPTY
117356: LIST
117357: LIST
117358: PUSH
117359: EMPTY
117360: LIST
117361: LIST
117362: PUSH
117363: EMPTY
117364: LIST
117365: LIST
117366: LIST
117367: PPUSH
117368: CALL_OW 69
117372: ST_TO_ADDR
// if not tmp then
117373: LD_VAR 0 1
117377: NOT
117378: IFFALSE 117382
// exit ;
117380: GO 117408
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117382: LD_VAR 0 1
117386: PUSH
117387: LD_INT 1
117389: PPUSH
117390: LD_VAR 0 1
117394: PPUSH
117395: CALL_OW 12
117399: ARRAY
117400: PPUSH
117401: LD_INT 200
117403: PPUSH
117404: CALL_OW 234
// end ;
117408: PPOPN 1
117410: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117411: LD_EXP 143
117415: PUSH
117416: LD_EXP 172
117420: AND
117421: IFFALSE 117500
117423: GO 117425
117425: DISABLE
117426: LD_INT 0
117428: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117429: LD_ADDR_VAR 0 1
117433: PUSH
117434: LD_INT 22
117436: PUSH
117437: LD_OWVAR 2
117441: PUSH
117442: EMPTY
117443: LIST
117444: LIST
117445: PUSH
117446: LD_INT 21
117448: PUSH
117449: LD_INT 2
117451: PUSH
117452: EMPTY
117453: LIST
117454: LIST
117455: PUSH
117456: EMPTY
117457: LIST
117458: LIST
117459: PPUSH
117460: CALL_OW 69
117464: ST_TO_ADDR
// if not tmp then
117465: LD_VAR 0 1
117469: NOT
117470: IFFALSE 117474
// exit ;
117472: GO 117500
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117474: LD_VAR 0 1
117478: PUSH
117479: LD_INT 1
117481: PPUSH
117482: LD_VAR 0 1
117486: PPUSH
117487: CALL_OW 12
117491: ARRAY
117492: PPUSH
117493: LD_INT 60
117495: PPUSH
117496: CALL_OW 234
// end ;
117500: PPOPN 1
117502: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117503: LD_EXP 143
117507: PUSH
117508: LD_EXP 173
117512: AND
117513: IFFALSE 117612
117515: GO 117517
117517: DISABLE
117518: LD_INT 0
117520: PPUSH
117521: PPUSH
// begin enable ;
117522: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117523: LD_ADDR_VAR 0 1
117527: PUSH
117528: LD_INT 22
117530: PUSH
117531: LD_OWVAR 2
117535: PUSH
117536: EMPTY
117537: LIST
117538: LIST
117539: PUSH
117540: LD_INT 61
117542: PUSH
117543: EMPTY
117544: LIST
117545: PUSH
117546: LD_INT 33
117548: PUSH
117549: LD_INT 2
117551: PUSH
117552: EMPTY
117553: LIST
117554: LIST
117555: PUSH
117556: EMPTY
117557: LIST
117558: LIST
117559: LIST
117560: PPUSH
117561: CALL_OW 69
117565: ST_TO_ADDR
// if not tmp then
117566: LD_VAR 0 1
117570: NOT
117571: IFFALSE 117575
// exit ;
117573: GO 117612
// for i in tmp do
117575: LD_ADDR_VAR 0 2
117579: PUSH
117580: LD_VAR 0 1
117584: PUSH
117585: FOR_IN
117586: IFFALSE 117610
// if IsControledBy ( i ) then
117588: LD_VAR 0 2
117592: PPUSH
117593: CALL_OW 312
117597: IFFALSE 117608
// ComUnlink ( i ) ;
117599: LD_VAR 0 2
117603: PPUSH
117604: CALL_OW 136
117608: GO 117585
117610: POP
117611: POP
// end ;
117612: PPOPN 2
117614: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117615: LD_EXP 143
117619: PUSH
117620: LD_EXP 174
117624: AND
117625: IFFALSE 117765
117627: GO 117629
117629: DISABLE
117630: LD_INT 0
117632: PPUSH
117633: PPUSH
// begin ToLua ( displayPowell(); ) ;
117634: LD_STRING displayPowell();
117636: PPUSH
117637: CALL_OW 559
// uc_side := 0 ;
117641: LD_ADDR_OWVAR 20
117645: PUSH
117646: LD_INT 0
117648: ST_TO_ADDR
// uc_nation := 2 ;
117649: LD_ADDR_OWVAR 21
117653: PUSH
117654: LD_INT 2
117656: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117657: LD_ADDR_OWVAR 37
117661: PUSH
117662: LD_INT 14
117664: ST_TO_ADDR
// vc_engine := engine_siberite ;
117665: LD_ADDR_OWVAR 39
117669: PUSH
117670: LD_INT 3
117672: ST_TO_ADDR
// vc_control := control_apeman ;
117673: LD_ADDR_OWVAR 38
117677: PUSH
117678: LD_INT 5
117680: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117681: LD_ADDR_OWVAR 40
117685: PUSH
117686: LD_INT 29
117688: ST_TO_ADDR
// un := CreateVehicle ;
117689: LD_ADDR_VAR 0 2
117693: PUSH
117694: CALL_OW 45
117698: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117699: LD_VAR 0 2
117703: PPUSH
117704: LD_INT 1
117706: PPUSH
117707: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117711: LD_INT 35
117713: PPUSH
117714: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117718: LD_VAR 0 2
117722: PPUSH
117723: LD_INT 22
117725: PUSH
117726: LD_OWVAR 2
117730: PUSH
117731: EMPTY
117732: LIST
117733: LIST
117734: PPUSH
117735: CALL_OW 69
117739: PPUSH
117740: LD_VAR 0 2
117744: PPUSH
117745: CALL_OW 74
117749: PPUSH
117750: CALL_OW 115
// until IsDead ( un ) ;
117754: LD_VAR 0 2
117758: PPUSH
117759: CALL_OW 301
117763: IFFALSE 117711
// end ;
117765: PPOPN 2
117767: END
// every 0 0$1 trigger StreamModeActive and sStu do
117768: LD_EXP 143
117772: PUSH
117773: LD_EXP 182
117777: AND
117778: IFFALSE 117794
117780: GO 117782
117782: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117783: LD_STRING displayStucuk();
117785: PPUSH
117786: CALL_OW 559
// ResetFog ;
117790: CALL_OW 335
// end ;
117794: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
117795: LD_EXP 143
117799: PUSH
117800: LD_EXP 175
117804: AND
117805: IFFALSE 117946
117807: GO 117809
117809: DISABLE
117810: LD_INT 0
117812: PPUSH
117813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117814: LD_ADDR_VAR 0 2
117818: PUSH
117819: LD_INT 22
117821: PUSH
117822: LD_OWVAR 2
117826: PUSH
117827: EMPTY
117828: LIST
117829: LIST
117830: PUSH
117831: LD_INT 21
117833: PUSH
117834: LD_INT 1
117836: PUSH
117837: EMPTY
117838: LIST
117839: LIST
117840: PUSH
117841: EMPTY
117842: LIST
117843: LIST
117844: PPUSH
117845: CALL_OW 69
117849: ST_TO_ADDR
// if not tmp then
117850: LD_VAR 0 2
117854: NOT
117855: IFFALSE 117859
// exit ;
117857: GO 117946
// un := tmp [ rand ( 1 , tmp ) ] ;
117859: LD_ADDR_VAR 0 1
117863: PUSH
117864: LD_VAR 0 2
117868: PUSH
117869: LD_INT 1
117871: PPUSH
117872: LD_VAR 0 2
117876: PPUSH
117877: CALL_OW 12
117881: ARRAY
117882: ST_TO_ADDR
// SetSide ( un , 0 ) ;
117883: LD_VAR 0 1
117887: PPUSH
117888: LD_INT 0
117890: PPUSH
117891: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
117895: LD_VAR 0 1
117899: PPUSH
117900: LD_OWVAR 3
117904: PUSH
117905: LD_VAR 0 1
117909: DIFF
117910: PPUSH
117911: LD_VAR 0 1
117915: PPUSH
117916: CALL_OW 74
117920: PPUSH
117921: CALL_OW 115
// wait ( 0 0$20 ) ;
117925: LD_INT 700
117927: PPUSH
117928: CALL_OW 67
// SetSide ( un , your_side ) ;
117932: LD_VAR 0 1
117936: PPUSH
117937: LD_OWVAR 2
117941: PPUSH
117942: CALL_OW 235
// end ;
117946: PPOPN 2
117948: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
117949: LD_EXP 143
117953: PUSH
117954: LD_EXP 176
117958: AND
117959: IFFALSE 118065
117961: GO 117963
117963: DISABLE
117964: LD_INT 0
117966: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117967: LD_ADDR_VAR 0 1
117971: PUSH
117972: LD_INT 22
117974: PUSH
117975: LD_OWVAR 2
117979: PUSH
117980: EMPTY
117981: LIST
117982: LIST
117983: PUSH
117984: LD_INT 2
117986: PUSH
117987: LD_INT 30
117989: PUSH
117990: LD_INT 0
117992: PUSH
117993: EMPTY
117994: LIST
117995: LIST
117996: PUSH
117997: LD_INT 30
117999: PUSH
118000: LD_INT 1
118002: PUSH
118003: EMPTY
118004: LIST
118005: LIST
118006: PUSH
118007: EMPTY
118008: LIST
118009: LIST
118010: LIST
118011: PUSH
118012: EMPTY
118013: LIST
118014: LIST
118015: PPUSH
118016: CALL_OW 69
118020: ST_TO_ADDR
// if not depot then
118021: LD_VAR 0 1
118025: NOT
118026: IFFALSE 118030
// exit ;
118028: GO 118065
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118030: LD_VAR 0 1
118034: PUSH
118035: LD_INT 1
118037: ARRAY
118038: PPUSH
118039: CALL_OW 250
118043: PPUSH
118044: LD_VAR 0 1
118048: PUSH
118049: LD_INT 1
118051: ARRAY
118052: PPUSH
118053: CALL_OW 251
118057: PPUSH
118058: LD_INT 70
118060: PPUSH
118061: CALL_OW 495
// end ;
118065: PPOPN 1
118067: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118068: LD_EXP 143
118072: PUSH
118073: LD_EXP 177
118077: AND
118078: IFFALSE 118289
118080: GO 118082
118082: DISABLE
118083: LD_INT 0
118085: PPUSH
118086: PPUSH
118087: PPUSH
118088: PPUSH
118089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118090: LD_ADDR_VAR 0 5
118094: PUSH
118095: LD_INT 22
118097: PUSH
118098: LD_OWVAR 2
118102: PUSH
118103: EMPTY
118104: LIST
118105: LIST
118106: PUSH
118107: LD_INT 21
118109: PUSH
118110: LD_INT 1
118112: PUSH
118113: EMPTY
118114: LIST
118115: LIST
118116: PUSH
118117: EMPTY
118118: LIST
118119: LIST
118120: PPUSH
118121: CALL_OW 69
118125: ST_TO_ADDR
// if not tmp then
118126: LD_VAR 0 5
118130: NOT
118131: IFFALSE 118135
// exit ;
118133: GO 118289
// for i in tmp do
118135: LD_ADDR_VAR 0 1
118139: PUSH
118140: LD_VAR 0 5
118144: PUSH
118145: FOR_IN
118146: IFFALSE 118287
// begin d := rand ( 0 , 5 ) ;
118148: LD_ADDR_VAR 0 4
118152: PUSH
118153: LD_INT 0
118155: PPUSH
118156: LD_INT 5
118158: PPUSH
118159: CALL_OW 12
118163: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118164: LD_ADDR_VAR 0 2
118168: PUSH
118169: LD_VAR 0 1
118173: PPUSH
118174: CALL_OW 250
118178: PPUSH
118179: LD_VAR 0 4
118183: PPUSH
118184: LD_INT 3
118186: PPUSH
118187: LD_INT 12
118189: PPUSH
118190: CALL_OW 12
118194: PPUSH
118195: CALL_OW 272
118199: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118200: LD_ADDR_VAR 0 3
118204: PUSH
118205: LD_VAR 0 1
118209: PPUSH
118210: CALL_OW 251
118214: PPUSH
118215: LD_VAR 0 4
118219: PPUSH
118220: LD_INT 3
118222: PPUSH
118223: LD_INT 12
118225: PPUSH
118226: CALL_OW 12
118230: PPUSH
118231: CALL_OW 273
118235: ST_TO_ADDR
// if ValidHex ( x , y ) then
118236: LD_VAR 0 2
118240: PPUSH
118241: LD_VAR 0 3
118245: PPUSH
118246: CALL_OW 488
118250: IFFALSE 118285
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118252: LD_VAR 0 1
118256: PPUSH
118257: LD_VAR 0 2
118261: PPUSH
118262: LD_VAR 0 3
118266: PPUSH
118267: LD_INT 3
118269: PPUSH
118270: LD_INT 6
118272: PPUSH
118273: CALL_OW 12
118277: PPUSH
118278: LD_INT 1
118280: PPUSH
118281: CALL_OW 483
// end ;
118285: GO 118145
118287: POP
118288: POP
// end ;
118289: PPOPN 5
118291: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118292: LD_EXP 143
118296: PUSH
118297: LD_EXP 178
118301: AND
118302: IFFALSE 118396
118304: GO 118306
118306: DISABLE
118307: LD_INT 0
118309: PPUSH
118310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118311: LD_ADDR_VAR 0 2
118315: PUSH
118316: LD_INT 22
118318: PUSH
118319: LD_OWVAR 2
118323: PUSH
118324: EMPTY
118325: LIST
118326: LIST
118327: PUSH
118328: LD_INT 32
118330: PUSH
118331: LD_INT 1
118333: PUSH
118334: EMPTY
118335: LIST
118336: LIST
118337: PUSH
118338: LD_INT 21
118340: PUSH
118341: LD_INT 2
118343: PUSH
118344: EMPTY
118345: LIST
118346: LIST
118347: PUSH
118348: EMPTY
118349: LIST
118350: LIST
118351: LIST
118352: PPUSH
118353: CALL_OW 69
118357: ST_TO_ADDR
// if not tmp then
118358: LD_VAR 0 2
118362: NOT
118363: IFFALSE 118367
// exit ;
118365: GO 118396
// for i in tmp do
118367: LD_ADDR_VAR 0 1
118371: PUSH
118372: LD_VAR 0 2
118376: PUSH
118377: FOR_IN
118378: IFFALSE 118394
// SetFuel ( i , 0 ) ;
118380: LD_VAR 0 1
118384: PPUSH
118385: LD_INT 0
118387: PPUSH
118388: CALL_OW 240
118392: GO 118377
118394: POP
118395: POP
// end ;
118396: PPOPN 2
118398: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118399: LD_EXP 143
118403: PUSH
118404: LD_EXP 179
118408: AND
118409: IFFALSE 118475
118411: GO 118413
118413: DISABLE
118414: LD_INT 0
118416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118417: LD_ADDR_VAR 0 1
118421: PUSH
118422: LD_INT 22
118424: PUSH
118425: LD_OWVAR 2
118429: PUSH
118430: EMPTY
118431: LIST
118432: LIST
118433: PUSH
118434: LD_INT 30
118436: PUSH
118437: LD_INT 29
118439: PUSH
118440: EMPTY
118441: LIST
118442: LIST
118443: PUSH
118444: EMPTY
118445: LIST
118446: LIST
118447: PPUSH
118448: CALL_OW 69
118452: ST_TO_ADDR
// if not tmp then
118453: LD_VAR 0 1
118457: NOT
118458: IFFALSE 118462
// exit ;
118460: GO 118475
// DestroyUnit ( tmp [ 1 ] ) ;
118462: LD_VAR 0 1
118466: PUSH
118467: LD_INT 1
118469: ARRAY
118470: PPUSH
118471: CALL_OW 65
// end ;
118475: PPOPN 1
118477: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118478: LD_EXP 143
118482: PUSH
118483: LD_EXP 181
118487: AND
118488: IFFALSE 118617
118490: GO 118492
118492: DISABLE
118493: LD_INT 0
118495: PPUSH
// begin uc_side := 0 ;
118496: LD_ADDR_OWVAR 20
118500: PUSH
118501: LD_INT 0
118503: ST_TO_ADDR
// uc_nation := nation_arabian ;
118504: LD_ADDR_OWVAR 21
118508: PUSH
118509: LD_INT 2
118511: ST_TO_ADDR
// hc_gallery :=  ;
118512: LD_ADDR_OWVAR 33
118516: PUSH
118517: LD_STRING 
118519: ST_TO_ADDR
// hc_name :=  ;
118520: LD_ADDR_OWVAR 26
118524: PUSH
118525: LD_STRING 
118527: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118528: LD_INT 1
118530: PPUSH
118531: LD_INT 11
118533: PPUSH
118534: LD_INT 10
118536: PPUSH
118537: CALL_OW 380
// un := CreateHuman ;
118541: LD_ADDR_VAR 0 1
118545: PUSH
118546: CALL_OW 44
118550: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118551: LD_VAR 0 1
118555: PPUSH
118556: LD_INT 1
118558: PPUSH
118559: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118563: LD_INT 35
118565: PPUSH
118566: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118570: LD_VAR 0 1
118574: PPUSH
118575: LD_INT 22
118577: PUSH
118578: LD_OWVAR 2
118582: PUSH
118583: EMPTY
118584: LIST
118585: LIST
118586: PPUSH
118587: CALL_OW 69
118591: PPUSH
118592: LD_VAR 0 1
118596: PPUSH
118597: CALL_OW 74
118601: PPUSH
118602: CALL_OW 115
// until IsDead ( un ) ;
118606: LD_VAR 0 1
118610: PPUSH
118611: CALL_OW 301
118615: IFFALSE 118563
// end ;
118617: PPOPN 1
118619: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118620: LD_EXP 143
118624: PUSH
118625: LD_EXP 183
118629: AND
118630: IFFALSE 118642
118632: GO 118634
118634: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118635: LD_STRING earthquake(getX(game), 0, 32)
118637: PPUSH
118638: CALL_OW 559
118642: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118643: LD_EXP 143
118647: PUSH
118648: LD_EXP 184
118652: AND
118653: IFFALSE 118744
118655: GO 118657
118657: DISABLE
118658: LD_INT 0
118660: PPUSH
// begin enable ;
118661: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118662: LD_ADDR_VAR 0 1
118666: PUSH
118667: LD_INT 22
118669: PUSH
118670: LD_OWVAR 2
118674: PUSH
118675: EMPTY
118676: LIST
118677: LIST
118678: PUSH
118679: LD_INT 21
118681: PUSH
118682: LD_INT 2
118684: PUSH
118685: EMPTY
118686: LIST
118687: LIST
118688: PUSH
118689: LD_INT 33
118691: PUSH
118692: LD_INT 3
118694: PUSH
118695: EMPTY
118696: LIST
118697: LIST
118698: PUSH
118699: EMPTY
118700: LIST
118701: LIST
118702: LIST
118703: PPUSH
118704: CALL_OW 69
118708: ST_TO_ADDR
// if not tmp then
118709: LD_VAR 0 1
118713: NOT
118714: IFFALSE 118718
// exit ;
118716: GO 118744
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118718: LD_VAR 0 1
118722: PUSH
118723: LD_INT 1
118725: PPUSH
118726: LD_VAR 0 1
118730: PPUSH
118731: CALL_OW 12
118735: ARRAY
118736: PPUSH
118737: LD_INT 1
118739: PPUSH
118740: CALL_OW 234
// end ;
118744: PPOPN 1
118746: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118747: LD_EXP 143
118751: PUSH
118752: LD_EXP 185
118756: AND
118757: IFFALSE 118898
118759: GO 118761
118761: DISABLE
118762: LD_INT 0
118764: PPUSH
118765: PPUSH
118766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118767: LD_ADDR_VAR 0 3
118771: PUSH
118772: LD_INT 22
118774: PUSH
118775: LD_OWVAR 2
118779: PUSH
118780: EMPTY
118781: LIST
118782: LIST
118783: PUSH
118784: LD_INT 25
118786: PUSH
118787: LD_INT 1
118789: PUSH
118790: EMPTY
118791: LIST
118792: LIST
118793: PUSH
118794: EMPTY
118795: LIST
118796: LIST
118797: PPUSH
118798: CALL_OW 69
118802: ST_TO_ADDR
// if not tmp then
118803: LD_VAR 0 3
118807: NOT
118808: IFFALSE 118812
// exit ;
118810: GO 118898
// un := tmp [ rand ( 1 , tmp ) ] ;
118812: LD_ADDR_VAR 0 2
118816: PUSH
118817: LD_VAR 0 3
118821: PUSH
118822: LD_INT 1
118824: PPUSH
118825: LD_VAR 0 3
118829: PPUSH
118830: CALL_OW 12
118834: ARRAY
118835: ST_TO_ADDR
// if Crawls ( un ) then
118836: LD_VAR 0 2
118840: PPUSH
118841: CALL_OW 318
118845: IFFALSE 118856
// ComWalk ( un ) ;
118847: LD_VAR 0 2
118851: PPUSH
118852: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
118856: LD_VAR 0 2
118860: PPUSH
118861: LD_INT 9
118863: PPUSH
118864: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
118868: LD_INT 28
118870: PPUSH
118871: LD_OWVAR 2
118875: PPUSH
118876: LD_INT 2
118878: PPUSH
118879: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
118883: LD_INT 29
118885: PPUSH
118886: LD_OWVAR 2
118890: PPUSH
118891: LD_INT 2
118893: PPUSH
118894: CALL_OW 322
// end ;
118898: PPOPN 3
118900: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
118901: LD_EXP 143
118905: PUSH
118906: LD_EXP 186
118910: AND
118911: IFFALSE 119022
118913: GO 118915
118915: DISABLE
118916: LD_INT 0
118918: PPUSH
118919: PPUSH
118920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118921: LD_ADDR_VAR 0 3
118925: PUSH
118926: LD_INT 22
118928: PUSH
118929: LD_OWVAR 2
118933: PUSH
118934: EMPTY
118935: LIST
118936: LIST
118937: PUSH
118938: LD_INT 25
118940: PUSH
118941: LD_INT 1
118943: PUSH
118944: EMPTY
118945: LIST
118946: LIST
118947: PUSH
118948: EMPTY
118949: LIST
118950: LIST
118951: PPUSH
118952: CALL_OW 69
118956: ST_TO_ADDR
// if not tmp then
118957: LD_VAR 0 3
118961: NOT
118962: IFFALSE 118966
// exit ;
118964: GO 119022
// un := tmp [ rand ( 1 , tmp ) ] ;
118966: LD_ADDR_VAR 0 2
118970: PUSH
118971: LD_VAR 0 3
118975: PUSH
118976: LD_INT 1
118978: PPUSH
118979: LD_VAR 0 3
118983: PPUSH
118984: CALL_OW 12
118988: ARRAY
118989: ST_TO_ADDR
// if Crawls ( un ) then
118990: LD_VAR 0 2
118994: PPUSH
118995: CALL_OW 318
118999: IFFALSE 119010
// ComWalk ( un ) ;
119001: LD_VAR 0 2
119005: PPUSH
119006: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119010: LD_VAR 0 2
119014: PPUSH
119015: LD_INT 8
119017: PPUSH
119018: CALL_OW 336
// end ;
119022: PPOPN 3
119024: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119025: LD_EXP 143
119029: PUSH
119030: LD_EXP 187
119034: AND
119035: IFFALSE 119179
119037: GO 119039
119039: DISABLE
119040: LD_INT 0
119042: PPUSH
119043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119044: LD_ADDR_VAR 0 2
119048: PUSH
119049: LD_INT 22
119051: PUSH
119052: LD_OWVAR 2
119056: PUSH
119057: EMPTY
119058: LIST
119059: LIST
119060: PUSH
119061: LD_INT 21
119063: PUSH
119064: LD_INT 2
119066: PUSH
119067: EMPTY
119068: LIST
119069: LIST
119070: PUSH
119071: LD_INT 2
119073: PUSH
119074: LD_INT 34
119076: PUSH
119077: LD_INT 12
119079: PUSH
119080: EMPTY
119081: LIST
119082: LIST
119083: PUSH
119084: LD_INT 34
119086: PUSH
119087: LD_INT 51
119089: PUSH
119090: EMPTY
119091: LIST
119092: LIST
119093: PUSH
119094: LD_INT 34
119096: PUSH
119097: LD_INT 32
119099: PUSH
119100: EMPTY
119101: LIST
119102: LIST
119103: PUSH
119104: EMPTY
119105: LIST
119106: LIST
119107: LIST
119108: LIST
119109: PUSH
119110: EMPTY
119111: LIST
119112: LIST
119113: LIST
119114: PPUSH
119115: CALL_OW 69
119119: ST_TO_ADDR
// if not tmp then
119120: LD_VAR 0 2
119124: NOT
119125: IFFALSE 119129
// exit ;
119127: GO 119179
// for i in tmp do
119129: LD_ADDR_VAR 0 1
119133: PUSH
119134: LD_VAR 0 2
119138: PUSH
119139: FOR_IN
119140: IFFALSE 119177
// if GetCargo ( i , mat_artifact ) = 0 then
119142: LD_VAR 0 1
119146: PPUSH
119147: LD_INT 4
119149: PPUSH
119150: CALL_OW 289
119154: PUSH
119155: LD_INT 0
119157: EQUAL
119158: IFFALSE 119175
// SetCargo ( i , mat_siberit , 100 ) ;
119160: LD_VAR 0 1
119164: PPUSH
119165: LD_INT 3
119167: PPUSH
119168: LD_INT 100
119170: PPUSH
119171: CALL_OW 290
119175: GO 119139
119177: POP
119178: POP
// end ;
119179: PPOPN 2
119181: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119182: LD_EXP 143
119186: PUSH
119187: LD_EXP 188
119191: AND
119192: IFFALSE 119375
119194: GO 119196
119196: DISABLE
119197: LD_INT 0
119199: PPUSH
119200: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119201: LD_ADDR_VAR 0 2
119205: PUSH
119206: LD_INT 22
119208: PUSH
119209: LD_OWVAR 2
119213: PUSH
119214: EMPTY
119215: LIST
119216: LIST
119217: PPUSH
119218: CALL_OW 69
119222: ST_TO_ADDR
// if not tmp then
119223: LD_VAR 0 2
119227: NOT
119228: IFFALSE 119232
// exit ;
119230: GO 119375
// for i := 1 to 2 do
119232: LD_ADDR_VAR 0 1
119236: PUSH
119237: DOUBLE
119238: LD_INT 1
119240: DEC
119241: ST_TO_ADDR
119242: LD_INT 2
119244: PUSH
119245: FOR_TO
119246: IFFALSE 119373
// begin uc_side := your_side ;
119248: LD_ADDR_OWVAR 20
119252: PUSH
119253: LD_OWVAR 2
119257: ST_TO_ADDR
// uc_nation := nation_american ;
119258: LD_ADDR_OWVAR 21
119262: PUSH
119263: LD_INT 1
119265: ST_TO_ADDR
// vc_chassis := us_morphling ;
119266: LD_ADDR_OWVAR 37
119270: PUSH
119271: LD_INT 5
119273: ST_TO_ADDR
// vc_engine := engine_siberite ;
119274: LD_ADDR_OWVAR 39
119278: PUSH
119279: LD_INT 3
119281: ST_TO_ADDR
// vc_control := control_computer ;
119282: LD_ADDR_OWVAR 38
119286: PUSH
119287: LD_INT 3
119289: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119290: LD_ADDR_OWVAR 40
119294: PUSH
119295: LD_INT 10
119297: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119298: LD_VAR 0 2
119302: PUSH
119303: LD_INT 1
119305: ARRAY
119306: PPUSH
119307: CALL_OW 310
119311: NOT
119312: IFFALSE 119359
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119314: CALL_OW 45
119318: PPUSH
119319: LD_VAR 0 2
119323: PUSH
119324: LD_INT 1
119326: ARRAY
119327: PPUSH
119328: CALL_OW 250
119332: PPUSH
119333: LD_VAR 0 2
119337: PUSH
119338: LD_INT 1
119340: ARRAY
119341: PPUSH
119342: CALL_OW 251
119346: PPUSH
119347: LD_INT 12
119349: PPUSH
119350: LD_INT 1
119352: PPUSH
119353: CALL_OW 50
119357: GO 119371
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119359: CALL_OW 45
119363: PPUSH
119364: LD_INT 1
119366: PPUSH
119367: CALL_OW 51
// end ;
119371: GO 119245
119373: POP
119374: POP
// end ;
119375: PPOPN 2
119377: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119378: LD_EXP 143
119382: PUSH
119383: LD_EXP 189
119387: AND
119388: IFFALSE 119610
119390: GO 119392
119392: DISABLE
119393: LD_INT 0
119395: PPUSH
119396: PPUSH
119397: PPUSH
119398: PPUSH
119399: PPUSH
119400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119401: LD_ADDR_VAR 0 6
119405: PUSH
119406: LD_INT 22
119408: PUSH
119409: LD_OWVAR 2
119413: PUSH
119414: EMPTY
119415: LIST
119416: LIST
119417: PUSH
119418: LD_INT 21
119420: PUSH
119421: LD_INT 1
119423: PUSH
119424: EMPTY
119425: LIST
119426: LIST
119427: PUSH
119428: LD_INT 3
119430: PUSH
119431: LD_INT 23
119433: PUSH
119434: LD_INT 0
119436: PUSH
119437: EMPTY
119438: LIST
119439: LIST
119440: PUSH
119441: EMPTY
119442: LIST
119443: LIST
119444: PUSH
119445: EMPTY
119446: LIST
119447: LIST
119448: LIST
119449: PPUSH
119450: CALL_OW 69
119454: ST_TO_ADDR
// if not tmp then
119455: LD_VAR 0 6
119459: NOT
119460: IFFALSE 119464
// exit ;
119462: GO 119610
// s1 := rand ( 1 , 4 ) ;
119464: LD_ADDR_VAR 0 2
119468: PUSH
119469: LD_INT 1
119471: PPUSH
119472: LD_INT 4
119474: PPUSH
119475: CALL_OW 12
119479: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119480: LD_ADDR_VAR 0 4
119484: PUSH
119485: LD_VAR 0 6
119489: PUSH
119490: LD_INT 1
119492: ARRAY
119493: PPUSH
119494: LD_VAR 0 2
119498: PPUSH
119499: CALL_OW 259
119503: ST_TO_ADDR
// if s1 = 1 then
119504: LD_VAR 0 2
119508: PUSH
119509: LD_INT 1
119511: EQUAL
119512: IFFALSE 119532
// s2 := rand ( 2 , 4 ) else
119514: LD_ADDR_VAR 0 3
119518: PUSH
119519: LD_INT 2
119521: PPUSH
119522: LD_INT 4
119524: PPUSH
119525: CALL_OW 12
119529: ST_TO_ADDR
119530: GO 119540
// s2 := 1 ;
119532: LD_ADDR_VAR 0 3
119536: PUSH
119537: LD_INT 1
119539: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119540: LD_ADDR_VAR 0 5
119544: PUSH
119545: LD_VAR 0 6
119549: PUSH
119550: LD_INT 1
119552: ARRAY
119553: PPUSH
119554: LD_VAR 0 3
119558: PPUSH
119559: CALL_OW 259
119563: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119564: LD_VAR 0 6
119568: PUSH
119569: LD_INT 1
119571: ARRAY
119572: PPUSH
119573: LD_VAR 0 2
119577: PPUSH
119578: LD_VAR 0 5
119582: PPUSH
119583: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119587: LD_VAR 0 6
119591: PUSH
119592: LD_INT 1
119594: ARRAY
119595: PPUSH
119596: LD_VAR 0 3
119600: PPUSH
119601: LD_VAR 0 4
119605: PPUSH
119606: CALL_OW 237
// end ;
119610: PPOPN 6
119612: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119613: LD_EXP 143
119617: PUSH
119618: LD_EXP 190
119622: AND
119623: IFFALSE 119702
119625: GO 119627
119627: DISABLE
119628: LD_INT 0
119630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119631: LD_ADDR_VAR 0 1
119635: PUSH
119636: LD_INT 22
119638: PUSH
119639: LD_OWVAR 2
119643: PUSH
119644: EMPTY
119645: LIST
119646: LIST
119647: PUSH
119648: LD_INT 30
119650: PUSH
119651: LD_INT 3
119653: PUSH
119654: EMPTY
119655: LIST
119656: LIST
119657: PUSH
119658: EMPTY
119659: LIST
119660: LIST
119661: PPUSH
119662: CALL_OW 69
119666: ST_TO_ADDR
// if not tmp then
119667: LD_VAR 0 1
119671: NOT
119672: IFFALSE 119676
// exit ;
119674: GO 119702
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119676: LD_VAR 0 1
119680: PUSH
119681: LD_INT 1
119683: PPUSH
119684: LD_VAR 0 1
119688: PPUSH
119689: CALL_OW 12
119693: ARRAY
119694: PPUSH
119695: LD_INT 1
119697: PPUSH
119698: CALL_OW 234
// end ;
119702: PPOPN 1
119704: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119705: LD_EXP 143
119709: PUSH
119710: LD_EXP 191
119714: AND
119715: IFFALSE 119827
119717: GO 119719
119719: DISABLE
119720: LD_INT 0
119722: PPUSH
119723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119724: LD_ADDR_VAR 0 2
119728: PUSH
119729: LD_INT 22
119731: PUSH
119732: LD_OWVAR 2
119736: PUSH
119737: EMPTY
119738: LIST
119739: LIST
119740: PUSH
119741: LD_INT 2
119743: PUSH
119744: LD_INT 30
119746: PUSH
119747: LD_INT 27
119749: PUSH
119750: EMPTY
119751: LIST
119752: LIST
119753: PUSH
119754: LD_INT 30
119756: PUSH
119757: LD_INT 26
119759: PUSH
119760: EMPTY
119761: LIST
119762: LIST
119763: PUSH
119764: LD_INT 30
119766: PUSH
119767: LD_INT 28
119769: PUSH
119770: EMPTY
119771: LIST
119772: LIST
119773: PUSH
119774: EMPTY
119775: LIST
119776: LIST
119777: LIST
119778: LIST
119779: PUSH
119780: EMPTY
119781: LIST
119782: LIST
119783: PPUSH
119784: CALL_OW 69
119788: ST_TO_ADDR
// if not tmp then
119789: LD_VAR 0 2
119793: NOT
119794: IFFALSE 119798
// exit ;
119796: GO 119827
// for i in tmp do
119798: LD_ADDR_VAR 0 1
119802: PUSH
119803: LD_VAR 0 2
119807: PUSH
119808: FOR_IN
119809: IFFALSE 119825
// SetLives ( i , 1 ) ;
119811: LD_VAR 0 1
119815: PPUSH
119816: LD_INT 1
119818: PPUSH
119819: CALL_OW 234
119823: GO 119808
119825: POP
119826: POP
// end ;
119827: PPOPN 2
119829: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
119830: LD_EXP 143
119834: PUSH
119835: LD_EXP 192
119839: AND
119840: IFFALSE 120127
119842: GO 119844
119844: DISABLE
119845: LD_INT 0
119847: PPUSH
119848: PPUSH
119849: PPUSH
// begin i := rand ( 1 , 7 ) ;
119850: LD_ADDR_VAR 0 1
119854: PUSH
119855: LD_INT 1
119857: PPUSH
119858: LD_INT 7
119860: PPUSH
119861: CALL_OW 12
119865: ST_TO_ADDR
// case i of 1 :
119866: LD_VAR 0 1
119870: PUSH
119871: LD_INT 1
119873: DOUBLE
119874: EQUAL
119875: IFTRUE 119879
119877: GO 119889
119879: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
119880: LD_STRING earthquake(getX(game), 0, 32)
119882: PPUSH
119883: CALL_OW 559
119887: GO 120127
119889: LD_INT 2
119891: DOUBLE
119892: EQUAL
119893: IFTRUE 119897
119895: GO 119911
119897: POP
// begin ToLua ( displayStucuk(); ) ;
119898: LD_STRING displayStucuk();
119900: PPUSH
119901: CALL_OW 559
// ResetFog ;
119905: CALL_OW 335
// end ; 3 :
119909: GO 120127
119911: LD_INT 3
119913: DOUBLE
119914: EQUAL
119915: IFTRUE 119919
119917: GO 120023
119919: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119920: LD_ADDR_VAR 0 2
119924: PUSH
119925: LD_INT 22
119927: PUSH
119928: LD_OWVAR 2
119932: PUSH
119933: EMPTY
119934: LIST
119935: LIST
119936: PUSH
119937: LD_INT 25
119939: PUSH
119940: LD_INT 1
119942: PUSH
119943: EMPTY
119944: LIST
119945: LIST
119946: PUSH
119947: EMPTY
119948: LIST
119949: LIST
119950: PPUSH
119951: CALL_OW 69
119955: ST_TO_ADDR
// if not tmp then
119956: LD_VAR 0 2
119960: NOT
119961: IFFALSE 119965
// exit ;
119963: GO 120127
// un := tmp [ rand ( 1 , tmp ) ] ;
119965: LD_ADDR_VAR 0 3
119969: PUSH
119970: LD_VAR 0 2
119974: PUSH
119975: LD_INT 1
119977: PPUSH
119978: LD_VAR 0 2
119982: PPUSH
119983: CALL_OW 12
119987: ARRAY
119988: ST_TO_ADDR
// if Crawls ( un ) then
119989: LD_VAR 0 3
119993: PPUSH
119994: CALL_OW 318
119998: IFFALSE 120009
// ComWalk ( un ) ;
120000: LD_VAR 0 3
120004: PPUSH
120005: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120009: LD_VAR 0 3
120013: PPUSH
120014: LD_INT 8
120016: PPUSH
120017: CALL_OW 336
// end ; 4 :
120021: GO 120127
120023: LD_INT 4
120025: DOUBLE
120026: EQUAL
120027: IFTRUE 120031
120029: GO 120105
120031: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120032: LD_ADDR_VAR 0 2
120036: PUSH
120037: LD_INT 22
120039: PUSH
120040: LD_OWVAR 2
120044: PUSH
120045: EMPTY
120046: LIST
120047: LIST
120048: PUSH
120049: LD_INT 30
120051: PUSH
120052: LD_INT 29
120054: PUSH
120055: EMPTY
120056: LIST
120057: LIST
120058: PUSH
120059: EMPTY
120060: LIST
120061: LIST
120062: PPUSH
120063: CALL_OW 69
120067: ST_TO_ADDR
// if not tmp then
120068: LD_VAR 0 2
120072: NOT
120073: IFFALSE 120077
// exit ;
120075: GO 120127
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120077: LD_VAR 0 2
120081: PUSH
120082: LD_INT 1
120084: ARRAY
120085: PPUSH
120086: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120090: LD_VAR 0 2
120094: PUSH
120095: LD_INT 1
120097: ARRAY
120098: PPUSH
120099: CALL_OW 65
// end ; 5 .. 7 :
120103: GO 120127
120105: LD_INT 5
120107: DOUBLE
120108: GREATEREQUAL
120109: IFFALSE 120117
120111: LD_INT 7
120113: DOUBLE
120114: LESSEQUAL
120115: IFTRUE 120119
120117: GO 120126
120119: POP
// StreamSibBomb ; end ;
120120: CALL 116364 0 0
120124: GO 120127
120126: POP
// end ;
120127: PPOPN 3
120129: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120130: LD_EXP 143
120134: PUSH
120135: LD_EXP 193
120139: AND
120140: IFFALSE 120296
120142: GO 120144
120144: DISABLE
120145: LD_INT 0
120147: PPUSH
120148: PPUSH
120149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120150: LD_ADDR_VAR 0 2
120154: PUSH
120155: LD_INT 81
120157: PUSH
120158: LD_OWVAR 2
120162: PUSH
120163: EMPTY
120164: LIST
120165: LIST
120166: PUSH
120167: LD_INT 2
120169: PUSH
120170: LD_INT 21
120172: PUSH
120173: LD_INT 1
120175: PUSH
120176: EMPTY
120177: LIST
120178: LIST
120179: PUSH
120180: LD_INT 21
120182: PUSH
120183: LD_INT 2
120185: PUSH
120186: EMPTY
120187: LIST
120188: LIST
120189: PUSH
120190: EMPTY
120191: LIST
120192: LIST
120193: LIST
120194: PUSH
120195: EMPTY
120196: LIST
120197: LIST
120198: PPUSH
120199: CALL_OW 69
120203: ST_TO_ADDR
// if not tmp then
120204: LD_VAR 0 2
120208: NOT
120209: IFFALSE 120213
// exit ;
120211: GO 120296
// p := 0 ;
120213: LD_ADDR_VAR 0 3
120217: PUSH
120218: LD_INT 0
120220: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120221: LD_INT 35
120223: PPUSH
120224: CALL_OW 67
// p := p + 1 ;
120228: LD_ADDR_VAR 0 3
120232: PUSH
120233: LD_VAR 0 3
120237: PUSH
120238: LD_INT 1
120240: PLUS
120241: ST_TO_ADDR
// for i in tmp do
120242: LD_ADDR_VAR 0 1
120246: PUSH
120247: LD_VAR 0 2
120251: PUSH
120252: FOR_IN
120253: IFFALSE 120284
// if GetLives ( i ) < 1000 then
120255: LD_VAR 0 1
120259: PPUSH
120260: CALL_OW 256
120264: PUSH
120265: LD_INT 1000
120267: LESS
120268: IFFALSE 120282
// SetLives ( i , 1000 ) ;
120270: LD_VAR 0 1
120274: PPUSH
120275: LD_INT 1000
120277: PPUSH
120278: CALL_OW 234
120282: GO 120252
120284: POP
120285: POP
// until p > 20 ;
120286: LD_VAR 0 3
120290: PUSH
120291: LD_INT 20
120293: GREATER
120294: IFFALSE 120221
// end ;
120296: PPOPN 3
120298: END
// every 0 0$1 trigger StreamModeActive and sTime do
120299: LD_EXP 143
120303: PUSH
120304: LD_EXP 194
120308: AND
120309: IFFALSE 120344
120311: GO 120313
120313: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120314: LD_INT 28
120316: PPUSH
120317: LD_OWVAR 2
120321: PPUSH
120322: LD_INT 2
120324: PPUSH
120325: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120329: LD_INT 30
120331: PPUSH
120332: LD_OWVAR 2
120336: PPUSH
120337: LD_INT 2
120339: PPUSH
120340: CALL_OW 322
// end ;
120344: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120345: LD_EXP 143
120349: PUSH
120350: LD_EXP 195
120354: AND
120355: IFFALSE 120476
120357: GO 120359
120359: DISABLE
120360: LD_INT 0
120362: PPUSH
120363: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120364: LD_ADDR_VAR 0 2
120368: PUSH
120369: LD_INT 22
120371: PUSH
120372: LD_OWVAR 2
120376: PUSH
120377: EMPTY
120378: LIST
120379: LIST
120380: PUSH
120381: LD_INT 21
120383: PUSH
120384: LD_INT 1
120386: PUSH
120387: EMPTY
120388: LIST
120389: LIST
120390: PUSH
120391: LD_INT 3
120393: PUSH
120394: LD_INT 23
120396: PUSH
120397: LD_INT 0
120399: PUSH
120400: EMPTY
120401: LIST
120402: LIST
120403: PUSH
120404: EMPTY
120405: LIST
120406: LIST
120407: PUSH
120408: EMPTY
120409: LIST
120410: LIST
120411: LIST
120412: PPUSH
120413: CALL_OW 69
120417: ST_TO_ADDR
// if not tmp then
120418: LD_VAR 0 2
120422: NOT
120423: IFFALSE 120427
// exit ;
120425: GO 120476
// for i in tmp do
120427: LD_ADDR_VAR 0 1
120431: PUSH
120432: LD_VAR 0 2
120436: PUSH
120437: FOR_IN
120438: IFFALSE 120474
// begin if Crawls ( i ) then
120440: LD_VAR 0 1
120444: PPUSH
120445: CALL_OW 318
120449: IFFALSE 120460
// ComWalk ( i ) ;
120451: LD_VAR 0 1
120455: PPUSH
120456: CALL_OW 138
// SetClass ( i , 2 ) ;
120460: LD_VAR 0 1
120464: PPUSH
120465: LD_INT 2
120467: PPUSH
120468: CALL_OW 336
// end ;
120472: GO 120437
120474: POP
120475: POP
// end ;
120476: PPOPN 2
120478: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120479: LD_EXP 143
120483: PUSH
120484: LD_EXP 196
120488: AND
120489: IFFALSE 120777
120491: GO 120493
120493: DISABLE
120494: LD_INT 0
120496: PPUSH
120497: PPUSH
120498: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120499: LD_OWVAR 2
120503: PPUSH
120504: LD_INT 9
120506: PPUSH
120507: LD_INT 1
120509: PPUSH
120510: LD_INT 1
120512: PPUSH
120513: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120517: LD_INT 9
120519: PPUSH
120520: LD_OWVAR 2
120524: PPUSH
120525: CALL_OW 343
// uc_side := 9 ;
120529: LD_ADDR_OWVAR 20
120533: PUSH
120534: LD_INT 9
120536: ST_TO_ADDR
// uc_nation := 2 ;
120537: LD_ADDR_OWVAR 21
120541: PUSH
120542: LD_INT 2
120544: ST_TO_ADDR
// hc_name := Dark Warrior ;
120545: LD_ADDR_OWVAR 26
120549: PUSH
120550: LD_STRING Dark Warrior
120552: ST_TO_ADDR
// hc_gallery :=  ;
120553: LD_ADDR_OWVAR 33
120557: PUSH
120558: LD_STRING 
120560: ST_TO_ADDR
// hc_noskilllimit := true ;
120561: LD_ADDR_OWVAR 76
120565: PUSH
120566: LD_INT 1
120568: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120569: LD_ADDR_OWVAR 31
120573: PUSH
120574: LD_INT 30
120576: PUSH
120577: LD_INT 30
120579: PUSH
120580: LD_INT 30
120582: PUSH
120583: LD_INT 30
120585: PUSH
120586: EMPTY
120587: LIST
120588: LIST
120589: LIST
120590: LIST
120591: ST_TO_ADDR
// un := CreateHuman ;
120592: LD_ADDR_VAR 0 3
120596: PUSH
120597: CALL_OW 44
120601: ST_TO_ADDR
// hc_noskilllimit := false ;
120602: LD_ADDR_OWVAR 76
120606: PUSH
120607: LD_INT 0
120609: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120610: LD_VAR 0 3
120614: PPUSH
120615: LD_INT 1
120617: PPUSH
120618: CALL_OW 51
// ToLua ( playRanger() ) ;
120622: LD_STRING playRanger()
120624: PPUSH
120625: CALL_OW 559
// p := 0 ;
120629: LD_ADDR_VAR 0 2
120633: PUSH
120634: LD_INT 0
120636: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120637: LD_INT 35
120639: PPUSH
120640: CALL_OW 67
// p := p + 1 ;
120644: LD_ADDR_VAR 0 2
120648: PUSH
120649: LD_VAR 0 2
120653: PUSH
120654: LD_INT 1
120656: PLUS
120657: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120658: LD_VAR 0 3
120662: PPUSH
120663: CALL_OW 256
120667: PUSH
120668: LD_INT 1000
120670: LESS
120671: IFFALSE 120685
// SetLives ( un , 1000 ) ;
120673: LD_VAR 0 3
120677: PPUSH
120678: LD_INT 1000
120680: PPUSH
120681: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120685: LD_VAR 0 3
120689: PPUSH
120690: LD_INT 81
120692: PUSH
120693: LD_OWVAR 2
120697: PUSH
120698: EMPTY
120699: LIST
120700: LIST
120701: PUSH
120702: LD_INT 91
120704: PUSH
120705: LD_VAR 0 3
120709: PUSH
120710: LD_INT 30
120712: PUSH
120713: EMPTY
120714: LIST
120715: LIST
120716: LIST
120717: PUSH
120718: EMPTY
120719: LIST
120720: LIST
120721: PPUSH
120722: CALL_OW 69
120726: PPUSH
120727: LD_VAR 0 3
120731: PPUSH
120732: CALL_OW 74
120736: PPUSH
120737: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120741: LD_VAR 0 2
120745: PUSH
120746: LD_INT 80
120748: GREATER
120749: PUSH
120750: LD_VAR 0 3
120754: PPUSH
120755: CALL_OW 301
120759: OR
120760: IFFALSE 120637
// if un then
120762: LD_VAR 0 3
120766: IFFALSE 120777
// RemoveUnit ( un ) ;
120768: LD_VAR 0 3
120772: PPUSH
120773: CALL_OW 64
// end ;
120777: PPOPN 3
120779: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120780: LD_EXP 197
120784: IFFALSE 120900
120786: GO 120788
120788: DISABLE
120789: LD_INT 0
120791: PPUSH
120792: PPUSH
120793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120794: LD_ADDR_VAR 0 2
120798: PUSH
120799: LD_INT 81
120801: PUSH
120802: LD_OWVAR 2
120806: PUSH
120807: EMPTY
120808: LIST
120809: LIST
120810: PUSH
120811: LD_INT 21
120813: PUSH
120814: LD_INT 1
120816: PUSH
120817: EMPTY
120818: LIST
120819: LIST
120820: PUSH
120821: EMPTY
120822: LIST
120823: LIST
120824: PPUSH
120825: CALL_OW 69
120829: ST_TO_ADDR
// ToLua ( playComputer() ) ;
120830: LD_STRING playComputer()
120832: PPUSH
120833: CALL_OW 559
// if not tmp then
120837: LD_VAR 0 2
120841: NOT
120842: IFFALSE 120846
// exit ;
120844: GO 120900
// for i in tmp do
120846: LD_ADDR_VAR 0 1
120850: PUSH
120851: LD_VAR 0 2
120855: PUSH
120856: FOR_IN
120857: IFFALSE 120898
// for j := 1 to 4 do
120859: LD_ADDR_VAR 0 3
120863: PUSH
120864: DOUBLE
120865: LD_INT 1
120867: DEC
120868: ST_TO_ADDR
120869: LD_INT 4
120871: PUSH
120872: FOR_TO
120873: IFFALSE 120894
// SetSkill ( i , j , 10 ) ;
120875: LD_VAR 0 1
120879: PPUSH
120880: LD_VAR 0 3
120884: PPUSH
120885: LD_INT 10
120887: PPUSH
120888: CALL_OW 237
120892: GO 120872
120894: POP
120895: POP
120896: GO 120856
120898: POP
120899: POP
// end ;
120900: PPOPN 3
120902: END
// every 0 0$1 trigger s30 do var i , tmp ;
120903: LD_EXP 198
120907: IFFALSE 120976
120909: GO 120911
120911: DISABLE
120912: LD_INT 0
120914: PPUSH
120915: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120916: LD_ADDR_VAR 0 2
120920: PUSH
120921: LD_INT 22
120923: PUSH
120924: LD_OWVAR 2
120928: PUSH
120929: EMPTY
120930: LIST
120931: LIST
120932: PPUSH
120933: CALL_OW 69
120937: ST_TO_ADDR
// if not tmp then
120938: LD_VAR 0 2
120942: NOT
120943: IFFALSE 120947
// exit ;
120945: GO 120976
// for i in tmp do
120947: LD_ADDR_VAR 0 1
120951: PUSH
120952: LD_VAR 0 2
120956: PUSH
120957: FOR_IN
120958: IFFALSE 120974
// SetLives ( i , 300 ) ;
120960: LD_VAR 0 1
120964: PPUSH
120965: LD_INT 300
120967: PPUSH
120968: CALL_OW 234
120972: GO 120957
120974: POP
120975: POP
// end ;
120976: PPOPN 2
120978: END
// every 0 0$1 trigger s60 do var i , tmp ;
120979: LD_EXP 199
120983: IFFALSE 121052
120985: GO 120987
120987: DISABLE
120988: LD_INT 0
120990: PPUSH
120991: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120992: LD_ADDR_VAR 0 2
120996: PUSH
120997: LD_INT 22
120999: PUSH
121000: LD_OWVAR 2
121004: PUSH
121005: EMPTY
121006: LIST
121007: LIST
121008: PPUSH
121009: CALL_OW 69
121013: ST_TO_ADDR
// if not tmp then
121014: LD_VAR 0 2
121018: NOT
121019: IFFALSE 121023
// exit ;
121021: GO 121052
// for i in tmp do
121023: LD_ADDR_VAR 0 1
121027: PUSH
121028: LD_VAR 0 2
121032: PUSH
121033: FOR_IN
121034: IFFALSE 121050
// SetLives ( i , 600 ) ;
121036: LD_VAR 0 1
121040: PPUSH
121041: LD_INT 600
121043: PPUSH
121044: CALL_OW 234
121048: GO 121033
121050: POP
121051: POP
// end ;
121052: PPOPN 2
121054: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121055: LD_INT 0
121057: PPUSH
// case cmd of 301 :
121058: LD_VAR 0 1
121062: PUSH
121063: LD_INT 301
121065: DOUBLE
121066: EQUAL
121067: IFTRUE 121071
121069: GO 121103
121071: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121072: LD_VAR 0 6
121076: PPUSH
121077: LD_VAR 0 7
121081: PPUSH
121082: LD_VAR 0 8
121086: PPUSH
121087: LD_VAR 0 4
121091: PPUSH
121092: LD_VAR 0 5
121096: PPUSH
121097: CALL 122304 0 5
121101: GO 121224
121103: LD_INT 302
121105: DOUBLE
121106: EQUAL
121107: IFTRUE 121111
121109: GO 121148
121111: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121112: LD_VAR 0 6
121116: PPUSH
121117: LD_VAR 0 7
121121: PPUSH
121122: LD_VAR 0 8
121126: PPUSH
121127: LD_VAR 0 9
121131: PPUSH
121132: LD_VAR 0 4
121136: PPUSH
121137: LD_VAR 0 5
121141: PPUSH
121142: CALL 122395 0 6
121146: GO 121224
121148: LD_INT 303
121150: DOUBLE
121151: EQUAL
121152: IFTRUE 121156
121154: GO 121193
121156: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121157: LD_VAR 0 6
121161: PPUSH
121162: LD_VAR 0 7
121166: PPUSH
121167: LD_VAR 0 8
121171: PPUSH
121172: LD_VAR 0 9
121176: PPUSH
121177: LD_VAR 0 4
121181: PPUSH
121182: LD_VAR 0 5
121186: PPUSH
121187: CALL 121229 0 6
121191: GO 121224
121193: LD_INT 304
121195: DOUBLE
121196: EQUAL
121197: IFTRUE 121201
121199: GO 121223
121201: POP
// hHackTeleport ( unit , x , y ) ; end ;
121202: LD_VAR 0 2
121206: PPUSH
121207: LD_VAR 0 4
121211: PPUSH
121212: LD_VAR 0 5
121216: PPUSH
121217: CALL 122988 0 3
121221: GO 121224
121223: POP
// end ;
121224: LD_VAR 0 12
121228: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121229: LD_INT 0
121231: PPUSH
121232: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121233: LD_VAR 0 1
121237: PUSH
121238: LD_INT 1
121240: LESS
121241: PUSH
121242: LD_VAR 0 1
121246: PUSH
121247: LD_INT 3
121249: GREATER
121250: OR
121251: PUSH
121252: LD_VAR 0 5
121256: PPUSH
121257: LD_VAR 0 6
121261: PPUSH
121262: CALL_OW 428
121266: OR
121267: IFFALSE 121271
// exit ;
121269: GO 121991
// uc_side := your_side ;
121271: LD_ADDR_OWVAR 20
121275: PUSH
121276: LD_OWVAR 2
121280: ST_TO_ADDR
// uc_nation := nation ;
121281: LD_ADDR_OWVAR 21
121285: PUSH
121286: LD_VAR 0 1
121290: ST_TO_ADDR
// bc_level = 1 ;
121291: LD_ADDR_OWVAR 43
121295: PUSH
121296: LD_INT 1
121298: ST_TO_ADDR
// case btype of 1 :
121299: LD_VAR 0 2
121303: PUSH
121304: LD_INT 1
121306: DOUBLE
121307: EQUAL
121308: IFTRUE 121312
121310: GO 121323
121312: POP
// bc_type := b_depot ; 2 :
121313: LD_ADDR_OWVAR 42
121317: PUSH
121318: LD_INT 0
121320: ST_TO_ADDR
121321: GO 121935
121323: LD_INT 2
121325: DOUBLE
121326: EQUAL
121327: IFTRUE 121331
121329: GO 121342
121331: POP
// bc_type := b_warehouse ; 3 :
121332: LD_ADDR_OWVAR 42
121336: PUSH
121337: LD_INT 1
121339: ST_TO_ADDR
121340: GO 121935
121342: LD_INT 3
121344: DOUBLE
121345: EQUAL
121346: IFTRUE 121350
121348: GO 121361
121350: POP
// bc_type := b_lab ; 4 .. 9 :
121351: LD_ADDR_OWVAR 42
121355: PUSH
121356: LD_INT 6
121358: ST_TO_ADDR
121359: GO 121935
121361: LD_INT 4
121363: DOUBLE
121364: GREATEREQUAL
121365: IFFALSE 121373
121367: LD_INT 9
121369: DOUBLE
121370: LESSEQUAL
121371: IFTRUE 121375
121373: GO 121427
121375: POP
// begin bc_type := b_lab_half ;
121376: LD_ADDR_OWVAR 42
121380: PUSH
121381: LD_INT 7
121383: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121384: LD_ADDR_OWVAR 44
121388: PUSH
121389: LD_INT 10
121391: PUSH
121392: LD_INT 11
121394: PUSH
121395: LD_INT 12
121397: PUSH
121398: LD_INT 15
121400: PUSH
121401: LD_INT 14
121403: PUSH
121404: LD_INT 13
121406: PUSH
121407: EMPTY
121408: LIST
121409: LIST
121410: LIST
121411: LIST
121412: LIST
121413: LIST
121414: PUSH
121415: LD_VAR 0 2
121419: PUSH
121420: LD_INT 3
121422: MINUS
121423: ARRAY
121424: ST_TO_ADDR
// end ; 10 .. 13 :
121425: GO 121935
121427: LD_INT 10
121429: DOUBLE
121430: GREATEREQUAL
121431: IFFALSE 121439
121433: LD_INT 13
121435: DOUBLE
121436: LESSEQUAL
121437: IFTRUE 121441
121439: GO 121518
121441: POP
// begin bc_type := b_lab_full ;
121442: LD_ADDR_OWVAR 42
121446: PUSH
121447: LD_INT 8
121449: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121450: LD_ADDR_OWVAR 44
121454: PUSH
121455: LD_INT 10
121457: PUSH
121458: LD_INT 12
121460: PUSH
121461: LD_INT 14
121463: PUSH
121464: LD_INT 13
121466: PUSH
121467: EMPTY
121468: LIST
121469: LIST
121470: LIST
121471: LIST
121472: PUSH
121473: LD_VAR 0 2
121477: PUSH
121478: LD_INT 9
121480: MINUS
121481: ARRAY
121482: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121483: LD_ADDR_OWVAR 45
121487: PUSH
121488: LD_INT 11
121490: PUSH
121491: LD_INT 15
121493: PUSH
121494: LD_INT 12
121496: PUSH
121497: LD_INT 15
121499: PUSH
121500: EMPTY
121501: LIST
121502: LIST
121503: LIST
121504: LIST
121505: PUSH
121506: LD_VAR 0 2
121510: PUSH
121511: LD_INT 9
121513: MINUS
121514: ARRAY
121515: ST_TO_ADDR
// end ; 14 :
121516: GO 121935
121518: LD_INT 14
121520: DOUBLE
121521: EQUAL
121522: IFTRUE 121526
121524: GO 121537
121526: POP
// bc_type := b_workshop ; 15 :
121527: LD_ADDR_OWVAR 42
121531: PUSH
121532: LD_INT 2
121534: ST_TO_ADDR
121535: GO 121935
121537: LD_INT 15
121539: DOUBLE
121540: EQUAL
121541: IFTRUE 121545
121543: GO 121556
121545: POP
// bc_type := b_factory ; 16 :
121546: LD_ADDR_OWVAR 42
121550: PUSH
121551: LD_INT 3
121553: ST_TO_ADDR
121554: GO 121935
121556: LD_INT 16
121558: DOUBLE
121559: EQUAL
121560: IFTRUE 121564
121562: GO 121575
121564: POP
// bc_type := b_ext_gun ; 17 :
121565: LD_ADDR_OWVAR 42
121569: PUSH
121570: LD_INT 17
121572: ST_TO_ADDR
121573: GO 121935
121575: LD_INT 17
121577: DOUBLE
121578: EQUAL
121579: IFTRUE 121583
121581: GO 121611
121583: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121584: LD_ADDR_OWVAR 42
121588: PUSH
121589: LD_INT 19
121591: PUSH
121592: LD_INT 23
121594: PUSH
121595: LD_INT 19
121597: PUSH
121598: EMPTY
121599: LIST
121600: LIST
121601: LIST
121602: PUSH
121603: LD_VAR 0 1
121607: ARRAY
121608: ST_TO_ADDR
121609: GO 121935
121611: LD_INT 18
121613: DOUBLE
121614: EQUAL
121615: IFTRUE 121619
121617: GO 121630
121619: POP
// bc_type := b_ext_radar ; 19 :
121620: LD_ADDR_OWVAR 42
121624: PUSH
121625: LD_INT 20
121627: ST_TO_ADDR
121628: GO 121935
121630: LD_INT 19
121632: DOUBLE
121633: EQUAL
121634: IFTRUE 121638
121636: GO 121649
121638: POP
// bc_type := b_ext_radio ; 20 :
121639: LD_ADDR_OWVAR 42
121643: PUSH
121644: LD_INT 22
121646: ST_TO_ADDR
121647: GO 121935
121649: LD_INT 20
121651: DOUBLE
121652: EQUAL
121653: IFTRUE 121657
121655: GO 121668
121657: POP
// bc_type := b_ext_siberium ; 21 :
121658: LD_ADDR_OWVAR 42
121662: PUSH
121663: LD_INT 21
121665: ST_TO_ADDR
121666: GO 121935
121668: LD_INT 21
121670: DOUBLE
121671: EQUAL
121672: IFTRUE 121676
121674: GO 121687
121676: POP
// bc_type := b_ext_computer ; 22 :
121677: LD_ADDR_OWVAR 42
121681: PUSH
121682: LD_INT 24
121684: ST_TO_ADDR
121685: GO 121935
121687: LD_INT 22
121689: DOUBLE
121690: EQUAL
121691: IFTRUE 121695
121693: GO 121706
121695: POP
// bc_type := b_ext_track ; 23 :
121696: LD_ADDR_OWVAR 42
121700: PUSH
121701: LD_INT 16
121703: ST_TO_ADDR
121704: GO 121935
121706: LD_INT 23
121708: DOUBLE
121709: EQUAL
121710: IFTRUE 121714
121712: GO 121725
121714: POP
// bc_type := b_ext_laser ; 24 :
121715: LD_ADDR_OWVAR 42
121719: PUSH
121720: LD_INT 25
121722: ST_TO_ADDR
121723: GO 121935
121725: LD_INT 24
121727: DOUBLE
121728: EQUAL
121729: IFTRUE 121733
121731: GO 121744
121733: POP
// bc_type := b_control_tower ; 25 :
121734: LD_ADDR_OWVAR 42
121738: PUSH
121739: LD_INT 36
121741: ST_TO_ADDR
121742: GO 121935
121744: LD_INT 25
121746: DOUBLE
121747: EQUAL
121748: IFTRUE 121752
121750: GO 121763
121752: POP
// bc_type := b_breastwork ; 26 :
121753: LD_ADDR_OWVAR 42
121757: PUSH
121758: LD_INT 31
121760: ST_TO_ADDR
121761: GO 121935
121763: LD_INT 26
121765: DOUBLE
121766: EQUAL
121767: IFTRUE 121771
121769: GO 121782
121771: POP
// bc_type := b_bunker ; 27 :
121772: LD_ADDR_OWVAR 42
121776: PUSH
121777: LD_INT 32
121779: ST_TO_ADDR
121780: GO 121935
121782: LD_INT 27
121784: DOUBLE
121785: EQUAL
121786: IFTRUE 121790
121788: GO 121801
121790: POP
// bc_type := b_turret ; 28 :
121791: LD_ADDR_OWVAR 42
121795: PUSH
121796: LD_INT 33
121798: ST_TO_ADDR
121799: GO 121935
121801: LD_INT 28
121803: DOUBLE
121804: EQUAL
121805: IFTRUE 121809
121807: GO 121820
121809: POP
// bc_type := b_armoury ; 29 :
121810: LD_ADDR_OWVAR 42
121814: PUSH
121815: LD_INT 4
121817: ST_TO_ADDR
121818: GO 121935
121820: LD_INT 29
121822: DOUBLE
121823: EQUAL
121824: IFTRUE 121828
121826: GO 121839
121828: POP
// bc_type := b_barracks ; 30 :
121829: LD_ADDR_OWVAR 42
121833: PUSH
121834: LD_INT 5
121836: ST_TO_ADDR
121837: GO 121935
121839: LD_INT 30
121841: DOUBLE
121842: EQUAL
121843: IFTRUE 121847
121845: GO 121858
121847: POP
// bc_type := b_solar_power ; 31 :
121848: LD_ADDR_OWVAR 42
121852: PUSH
121853: LD_INT 27
121855: ST_TO_ADDR
121856: GO 121935
121858: LD_INT 31
121860: DOUBLE
121861: EQUAL
121862: IFTRUE 121866
121864: GO 121877
121866: POP
// bc_type := b_oil_power ; 32 :
121867: LD_ADDR_OWVAR 42
121871: PUSH
121872: LD_INT 26
121874: ST_TO_ADDR
121875: GO 121935
121877: LD_INT 32
121879: DOUBLE
121880: EQUAL
121881: IFTRUE 121885
121883: GO 121896
121885: POP
// bc_type := b_siberite_power ; 33 :
121886: LD_ADDR_OWVAR 42
121890: PUSH
121891: LD_INT 28
121893: ST_TO_ADDR
121894: GO 121935
121896: LD_INT 33
121898: DOUBLE
121899: EQUAL
121900: IFTRUE 121904
121902: GO 121915
121904: POP
// bc_type := b_oil_mine ; 34 :
121905: LD_ADDR_OWVAR 42
121909: PUSH
121910: LD_INT 29
121912: ST_TO_ADDR
121913: GO 121935
121915: LD_INT 34
121917: DOUBLE
121918: EQUAL
121919: IFTRUE 121923
121921: GO 121934
121923: POP
// bc_type := b_siberite_mine ; end ;
121924: LD_ADDR_OWVAR 42
121928: PUSH
121929: LD_INT 30
121931: ST_TO_ADDR
121932: GO 121935
121934: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
121935: LD_ADDR_VAR 0 8
121939: PUSH
121940: LD_VAR 0 5
121944: PPUSH
121945: LD_VAR 0 6
121949: PPUSH
121950: LD_VAR 0 3
121954: PPUSH
121955: CALL_OW 47
121959: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
121960: LD_OWVAR 42
121964: PUSH
121965: LD_INT 32
121967: PUSH
121968: LD_INT 33
121970: PUSH
121971: EMPTY
121972: LIST
121973: LIST
121974: IN
121975: IFFALSE 121991
// PlaceWeaponTurret ( b , weapon ) ;
121977: LD_VAR 0 8
121981: PPUSH
121982: LD_VAR 0 4
121986: PPUSH
121987: CALL_OW 431
// end ;
121991: LD_VAR 0 7
121995: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
121996: LD_INT 0
121998: PPUSH
121999: PPUSH
122000: PPUSH
122001: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122002: LD_ADDR_VAR 0 4
122006: PUSH
122007: LD_INT 22
122009: PUSH
122010: LD_OWVAR 2
122014: PUSH
122015: EMPTY
122016: LIST
122017: LIST
122018: PUSH
122019: LD_INT 2
122021: PUSH
122022: LD_INT 30
122024: PUSH
122025: LD_INT 0
122027: PUSH
122028: EMPTY
122029: LIST
122030: LIST
122031: PUSH
122032: LD_INT 30
122034: PUSH
122035: LD_INT 1
122037: PUSH
122038: EMPTY
122039: LIST
122040: LIST
122041: PUSH
122042: EMPTY
122043: LIST
122044: LIST
122045: LIST
122046: PUSH
122047: EMPTY
122048: LIST
122049: LIST
122050: PPUSH
122051: CALL_OW 69
122055: ST_TO_ADDR
// if not tmp then
122056: LD_VAR 0 4
122060: NOT
122061: IFFALSE 122065
// exit ;
122063: GO 122124
// for i in tmp do
122065: LD_ADDR_VAR 0 2
122069: PUSH
122070: LD_VAR 0 4
122074: PUSH
122075: FOR_IN
122076: IFFALSE 122122
// for j = 1 to 3 do
122078: LD_ADDR_VAR 0 3
122082: PUSH
122083: DOUBLE
122084: LD_INT 1
122086: DEC
122087: ST_TO_ADDR
122088: LD_INT 3
122090: PUSH
122091: FOR_TO
122092: IFFALSE 122118
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122094: LD_VAR 0 2
122098: PPUSH
122099: CALL_OW 274
122103: PPUSH
122104: LD_VAR 0 3
122108: PPUSH
122109: LD_INT 99999
122111: PPUSH
122112: CALL_OW 277
122116: GO 122091
122118: POP
122119: POP
122120: GO 122075
122122: POP
122123: POP
// end ;
122124: LD_VAR 0 1
122128: RET
// export function hHackSetLevel10 ; var i , j ; begin
122129: LD_INT 0
122131: PPUSH
122132: PPUSH
122133: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122134: LD_ADDR_VAR 0 2
122138: PUSH
122139: LD_INT 21
122141: PUSH
122142: LD_INT 1
122144: PUSH
122145: EMPTY
122146: LIST
122147: LIST
122148: PPUSH
122149: CALL_OW 69
122153: PUSH
122154: FOR_IN
122155: IFFALSE 122207
// if IsSelected ( i ) then
122157: LD_VAR 0 2
122161: PPUSH
122162: CALL_OW 306
122166: IFFALSE 122205
// begin for j := 1 to 4 do
122168: LD_ADDR_VAR 0 3
122172: PUSH
122173: DOUBLE
122174: LD_INT 1
122176: DEC
122177: ST_TO_ADDR
122178: LD_INT 4
122180: PUSH
122181: FOR_TO
122182: IFFALSE 122203
// SetSkill ( i , j , 10 ) ;
122184: LD_VAR 0 2
122188: PPUSH
122189: LD_VAR 0 3
122193: PPUSH
122194: LD_INT 10
122196: PPUSH
122197: CALL_OW 237
122201: GO 122181
122203: POP
122204: POP
// end ;
122205: GO 122154
122207: POP
122208: POP
// end ;
122209: LD_VAR 0 1
122213: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122214: LD_INT 0
122216: PPUSH
122217: PPUSH
122218: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122219: LD_ADDR_VAR 0 2
122223: PUSH
122224: LD_INT 22
122226: PUSH
122227: LD_OWVAR 2
122231: PUSH
122232: EMPTY
122233: LIST
122234: LIST
122235: PUSH
122236: LD_INT 21
122238: PUSH
122239: LD_INT 1
122241: PUSH
122242: EMPTY
122243: LIST
122244: LIST
122245: PUSH
122246: EMPTY
122247: LIST
122248: LIST
122249: PPUSH
122250: CALL_OW 69
122254: PUSH
122255: FOR_IN
122256: IFFALSE 122297
// begin for j := 1 to 4 do
122258: LD_ADDR_VAR 0 3
122262: PUSH
122263: DOUBLE
122264: LD_INT 1
122266: DEC
122267: ST_TO_ADDR
122268: LD_INT 4
122270: PUSH
122271: FOR_TO
122272: IFFALSE 122293
// SetSkill ( i , j , 10 ) ;
122274: LD_VAR 0 2
122278: PPUSH
122279: LD_VAR 0 3
122283: PPUSH
122284: LD_INT 10
122286: PPUSH
122287: CALL_OW 237
122291: GO 122271
122293: POP
122294: POP
// end ;
122295: GO 122255
122297: POP
122298: POP
// end ;
122299: LD_VAR 0 1
122303: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122304: LD_INT 0
122306: PPUSH
// uc_side := your_side ;
122307: LD_ADDR_OWVAR 20
122311: PUSH
122312: LD_OWVAR 2
122316: ST_TO_ADDR
// uc_nation := nation ;
122317: LD_ADDR_OWVAR 21
122321: PUSH
122322: LD_VAR 0 1
122326: ST_TO_ADDR
// InitHc ;
122327: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122331: LD_INT 0
122333: PPUSH
122334: LD_VAR 0 2
122338: PPUSH
122339: LD_VAR 0 3
122343: PPUSH
122344: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122348: LD_VAR 0 4
122352: PPUSH
122353: LD_VAR 0 5
122357: PPUSH
122358: CALL_OW 428
122362: PUSH
122363: LD_INT 0
122365: EQUAL
122366: IFFALSE 122390
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122368: CALL_OW 44
122372: PPUSH
122373: LD_VAR 0 4
122377: PPUSH
122378: LD_VAR 0 5
122382: PPUSH
122383: LD_INT 1
122385: PPUSH
122386: CALL_OW 48
// end ;
122390: LD_VAR 0 6
122394: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122395: LD_INT 0
122397: PPUSH
122398: PPUSH
// uc_side := your_side ;
122399: LD_ADDR_OWVAR 20
122403: PUSH
122404: LD_OWVAR 2
122408: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122409: LD_VAR 0 1
122413: PUSH
122414: LD_INT 1
122416: PUSH
122417: LD_INT 2
122419: PUSH
122420: LD_INT 3
122422: PUSH
122423: LD_INT 4
122425: PUSH
122426: LD_INT 5
122428: PUSH
122429: EMPTY
122430: LIST
122431: LIST
122432: LIST
122433: LIST
122434: LIST
122435: IN
122436: IFFALSE 122448
// uc_nation := nation_american else
122438: LD_ADDR_OWVAR 21
122442: PUSH
122443: LD_INT 1
122445: ST_TO_ADDR
122446: GO 122491
// if chassis in [ 11 , 12 , 13 , 14 ] then
122448: LD_VAR 0 1
122452: PUSH
122453: LD_INT 11
122455: PUSH
122456: LD_INT 12
122458: PUSH
122459: LD_INT 13
122461: PUSH
122462: LD_INT 14
122464: PUSH
122465: EMPTY
122466: LIST
122467: LIST
122468: LIST
122469: LIST
122470: IN
122471: IFFALSE 122483
// uc_nation := nation_arabian else
122473: LD_ADDR_OWVAR 21
122477: PUSH
122478: LD_INT 2
122480: ST_TO_ADDR
122481: GO 122491
// uc_nation := nation_russian ;
122483: LD_ADDR_OWVAR 21
122487: PUSH
122488: LD_INT 3
122490: ST_TO_ADDR
// vc_chassis := chassis ;
122491: LD_ADDR_OWVAR 37
122495: PUSH
122496: LD_VAR 0 1
122500: ST_TO_ADDR
// vc_engine := engine ;
122501: LD_ADDR_OWVAR 39
122505: PUSH
122506: LD_VAR 0 2
122510: ST_TO_ADDR
// vc_control := control ;
122511: LD_ADDR_OWVAR 38
122515: PUSH
122516: LD_VAR 0 3
122520: ST_TO_ADDR
// vc_weapon := weapon ;
122521: LD_ADDR_OWVAR 40
122525: PUSH
122526: LD_VAR 0 4
122530: ST_TO_ADDR
// un := CreateVehicle ;
122531: LD_ADDR_VAR 0 8
122535: PUSH
122536: CALL_OW 45
122540: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122541: LD_VAR 0 8
122545: PPUSH
122546: LD_INT 0
122548: PPUSH
122549: LD_INT 5
122551: PPUSH
122552: CALL_OW 12
122556: PPUSH
122557: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122561: LD_VAR 0 8
122565: PPUSH
122566: LD_VAR 0 5
122570: PPUSH
122571: LD_VAR 0 6
122575: PPUSH
122576: LD_INT 1
122578: PPUSH
122579: CALL_OW 48
// end ;
122583: LD_VAR 0 7
122587: RET
// export hInvincible ; every 1 do
122588: GO 122590
122590: DISABLE
// hInvincible := [ ] ;
122591: LD_ADDR_EXP 200
122595: PUSH
122596: EMPTY
122597: ST_TO_ADDR
122598: END
// every 10 do var i ;
122599: GO 122601
122601: DISABLE
122602: LD_INT 0
122604: PPUSH
// begin enable ;
122605: ENABLE
// if not hInvincible then
122606: LD_EXP 200
122610: NOT
122611: IFFALSE 122615
// exit ;
122613: GO 122659
// for i in hInvincible do
122615: LD_ADDR_VAR 0 1
122619: PUSH
122620: LD_EXP 200
122624: PUSH
122625: FOR_IN
122626: IFFALSE 122657
// if GetLives ( i ) < 1000 then
122628: LD_VAR 0 1
122632: PPUSH
122633: CALL_OW 256
122637: PUSH
122638: LD_INT 1000
122640: LESS
122641: IFFALSE 122655
// SetLives ( i , 1000 ) ;
122643: LD_VAR 0 1
122647: PPUSH
122648: LD_INT 1000
122650: PPUSH
122651: CALL_OW 234
122655: GO 122625
122657: POP
122658: POP
// end ;
122659: PPOPN 1
122661: END
// export function hHackInvincible ; var i ; begin
122662: LD_INT 0
122664: PPUSH
122665: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122666: LD_ADDR_VAR 0 2
122670: PUSH
122671: LD_INT 2
122673: PUSH
122674: LD_INT 21
122676: PUSH
122677: LD_INT 1
122679: PUSH
122680: EMPTY
122681: LIST
122682: LIST
122683: PUSH
122684: LD_INT 21
122686: PUSH
122687: LD_INT 2
122689: PUSH
122690: EMPTY
122691: LIST
122692: LIST
122693: PUSH
122694: EMPTY
122695: LIST
122696: LIST
122697: LIST
122698: PPUSH
122699: CALL_OW 69
122703: PUSH
122704: FOR_IN
122705: IFFALSE 122766
// if IsSelected ( i ) then
122707: LD_VAR 0 2
122711: PPUSH
122712: CALL_OW 306
122716: IFFALSE 122764
// begin if i in hInvincible then
122718: LD_VAR 0 2
122722: PUSH
122723: LD_EXP 200
122727: IN
122728: IFFALSE 122748
// hInvincible := hInvincible diff i else
122730: LD_ADDR_EXP 200
122734: PUSH
122735: LD_EXP 200
122739: PUSH
122740: LD_VAR 0 2
122744: DIFF
122745: ST_TO_ADDR
122746: GO 122764
// hInvincible := hInvincible union i ;
122748: LD_ADDR_EXP 200
122752: PUSH
122753: LD_EXP 200
122757: PUSH
122758: LD_VAR 0 2
122762: UNION
122763: ST_TO_ADDR
// end ;
122764: GO 122704
122766: POP
122767: POP
// end ;
122768: LD_VAR 0 1
122772: RET
// export function hHackInvisible ; var i , j ; begin
122773: LD_INT 0
122775: PPUSH
122776: PPUSH
122777: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122778: LD_ADDR_VAR 0 2
122782: PUSH
122783: LD_INT 21
122785: PUSH
122786: LD_INT 1
122788: PUSH
122789: EMPTY
122790: LIST
122791: LIST
122792: PPUSH
122793: CALL_OW 69
122797: PUSH
122798: FOR_IN
122799: IFFALSE 122823
// if IsSelected ( i ) then
122801: LD_VAR 0 2
122805: PPUSH
122806: CALL_OW 306
122810: IFFALSE 122821
// ComForceInvisible ( i ) ;
122812: LD_VAR 0 2
122816: PPUSH
122817: CALL_OW 496
122821: GO 122798
122823: POP
122824: POP
// end ;
122825: LD_VAR 0 1
122829: RET
// export function hHackChangeYourSide ; begin
122830: LD_INT 0
122832: PPUSH
// if your_side = 8 then
122833: LD_OWVAR 2
122837: PUSH
122838: LD_INT 8
122840: EQUAL
122841: IFFALSE 122853
// your_side := 0 else
122843: LD_ADDR_OWVAR 2
122847: PUSH
122848: LD_INT 0
122850: ST_TO_ADDR
122851: GO 122867
// your_side := your_side + 1 ;
122853: LD_ADDR_OWVAR 2
122857: PUSH
122858: LD_OWVAR 2
122862: PUSH
122863: LD_INT 1
122865: PLUS
122866: ST_TO_ADDR
// end ;
122867: LD_VAR 0 1
122871: RET
// export function hHackChangeUnitSide ; var i , j ; begin
122872: LD_INT 0
122874: PPUSH
122875: PPUSH
122876: PPUSH
// for i in all_units do
122877: LD_ADDR_VAR 0 2
122881: PUSH
122882: LD_OWVAR 3
122886: PUSH
122887: FOR_IN
122888: IFFALSE 122966
// if IsSelected ( i ) then
122890: LD_VAR 0 2
122894: PPUSH
122895: CALL_OW 306
122899: IFFALSE 122964
// begin j := GetSide ( i ) ;
122901: LD_ADDR_VAR 0 3
122905: PUSH
122906: LD_VAR 0 2
122910: PPUSH
122911: CALL_OW 255
122915: ST_TO_ADDR
// if j = 8 then
122916: LD_VAR 0 3
122920: PUSH
122921: LD_INT 8
122923: EQUAL
122924: IFFALSE 122936
// j := 0 else
122926: LD_ADDR_VAR 0 3
122930: PUSH
122931: LD_INT 0
122933: ST_TO_ADDR
122934: GO 122950
// j := j + 1 ;
122936: LD_ADDR_VAR 0 3
122940: PUSH
122941: LD_VAR 0 3
122945: PUSH
122946: LD_INT 1
122948: PLUS
122949: ST_TO_ADDR
// SetSide ( i , j ) ;
122950: LD_VAR 0 2
122954: PPUSH
122955: LD_VAR 0 3
122959: PPUSH
122960: CALL_OW 235
// end ;
122964: GO 122887
122966: POP
122967: POP
// end ;
122968: LD_VAR 0 1
122972: RET
// export function hHackFog ; begin
122973: LD_INT 0
122975: PPUSH
// FogOff ( true ) ;
122976: LD_INT 1
122978: PPUSH
122979: CALL_OW 344
// end ;
122983: LD_VAR 0 1
122987: RET
// export function hHackTeleport ( unit , x , y ) ; begin
122988: LD_INT 0
122990: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
122991: LD_VAR 0 1
122995: PPUSH
122996: LD_VAR 0 2
123000: PPUSH
123001: LD_VAR 0 3
123005: PPUSH
123006: LD_INT 1
123008: PPUSH
123009: LD_INT 1
123011: PPUSH
123012: CALL_OW 483
// CenterOnXY ( x , y ) ;
123016: LD_VAR 0 2
123020: PPUSH
123021: LD_VAR 0 3
123025: PPUSH
123026: CALL_OW 84
// end ;
123030: LD_VAR 0 4
123034: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123035: LD_INT 0
123037: PPUSH
123038: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123039: LD_VAR 0 1
123043: NOT
123044: PUSH
123045: LD_VAR 0 2
123049: PPUSH
123050: LD_VAR 0 3
123054: PPUSH
123055: CALL_OW 488
123059: NOT
123060: OR
123061: PUSH
123062: LD_VAR 0 1
123066: PPUSH
123067: CALL_OW 266
123071: PUSH
123072: LD_INT 3
123074: NONEQUAL
123075: PUSH
123076: LD_VAR 0 1
123080: PPUSH
123081: CALL_OW 247
123085: PUSH
123086: LD_INT 1
123088: EQUAL
123089: NOT
123090: AND
123091: OR
123092: IFFALSE 123096
// exit ;
123094: GO 123245
// if GetType ( factory ) = unit_human then
123096: LD_VAR 0 1
123100: PPUSH
123101: CALL_OW 247
123105: PUSH
123106: LD_INT 1
123108: EQUAL
123109: IFFALSE 123126
// factory := IsInUnit ( factory ) ;
123111: LD_ADDR_VAR 0 1
123115: PUSH
123116: LD_VAR 0 1
123120: PPUSH
123121: CALL_OW 310
123125: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123126: LD_VAR 0 1
123130: PPUSH
123131: CALL_OW 266
123135: PUSH
123136: LD_INT 3
123138: NONEQUAL
123139: IFFALSE 123143
// exit ;
123141: GO 123245
// if HexInfo ( x , y ) = factory then
123143: LD_VAR 0 2
123147: PPUSH
123148: LD_VAR 0 3
123152: PPUSH
123153: CALL_OW 428
123157: PUSH
123158: LD_VAR 0 1
123162: EQUAL
123163: IFFALSE 123190
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123165: LD_ADDR_EXP 201
123169: PUSH
123170: LD_EXP 201
123174: PPUSH
123175: LD_VAR 0 1
123179: PPUSH
123180: LD_INT 0
123182: PPUSH
123183: CALL_OW 1
123187: ST_TO_ADDR
123188: GO 123241
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123190: LD_ADDR_EXP 201
123194: PUSH
123195: LD_EXP 201
123199: PPUSH
123200: LD_VAR 0 1
123204: PPUSH
123205: LD_VAR 0 1
123209: PPUSH
123210: CALL_OW 255
123214: PUSH
123215: LD_VAR 0 1
123219: PUSH
123220: LD_VAR 0 2
123224: PUSH
123225: LD_VAR 0 3
123229: PUSH
123230: EMPTY
123231: LIST
123232: LIST
123233: LIST
123234: LIST
123235: PPUSH
123236: CALL_OW 1
123240: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123241: CALL 123250 0 0
// end ;
123245: LD_VAR 0 4
123249: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123250: LD_INT 0
123252: PPUSH
123253: PPUSH
123254: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123255: LD_STRING resetFactoryWaypoint();
123257: PPUSH
123258: CALL_OW 559
// if factoryWaypoints then
123262: LD_EXP 201
123266: IFFALSE 123392
// begin list := PrepareArray ( factoryWaypoints ) ;
123268: LD_ADDR_VAR 0 3
123272: PUSH
123273: LD_EXP 201
123277: PPUSH
123278: CALL 108536 0 1
123282: ST_TO_ADDR
// for i := 1 to list do
123283: LD_ADDR_VAR 0 2
123287: PUSH
123288: DOUBLE
123289: LD_INT 1
123291: DEC
123292: ST_TO_ADDR
123293: LD_VAR 0 3
123297: PUSH
123298: FOR_TO
123299: IFFALSE 123390
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123301: LD_STRING setFactoryWaypointXY(
123303: PUSH
123304: LD_VAR 0 3
123308: PUSH
123309: LD_VAR 0 2
123313: ARRAY
123314: PUSH
123315: LD_INT 1
123317: ARRAY
123318: STR
123319: PUSH
123320: LD_STRING ,
123322: STR
123323: PUSH
123324: LD_VAR 0 3
123328: PUSH
123329: LD_VAR 0 2
123333: ARRAY
123334: PUSH
123335: LD_INT 2
123337: ARRAY
123338: STR
123339: PUSH
123340: LD_STRING ,
123342: STR
123343: PUSH
123344: LD_VAR 0 3
123348: PUSH
123349: LD_VAR 0 2
123353: ARRAY
123354: PUSH
123355: LD_INT 3
123357: ARRAY
123358: STR
123359: PUSH
123360: LD_STRING ,
123362: STR
123363: PUSH
123364: LD_VAR 0 3
123368: PUSH
123369: LD_VAR 0 2
123373: ARRAY
123374: PUSH
123375: LD_INT 4
123377: ARRAY
123378: STR
123379: PUSH
123380: LD_STRING )
123382: STR
123383: PPUSH
123384: CALL_OW 559
123388: GO 123298
123390: POP
123391: POP
// end ; end ;
123392: LD_VAR 0 1
123396: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123397: LD_INT 0
123399: PPUSH
// if HexInfo ( x , y ) = warehouse then
123400: LD_VAR 0 2
123404: PPUSH
123405: LD_VAR 0 3
123409: PPUSH
123410: CALL_OW 428
123414: PUSH
123415: LD_VAR 0 1
123419: EQUAL
123420: IFFALSE 123447
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123422: LD_ADDR_EXP 202
123426: PUSH
123427: LD_EXP 202
123431: PPUSH
123432: LD_VAR 0 1
123436: PPUSH
123437: LD_INT 0
123439: PPUSH
123440: CALL_OW 1
123444: ST_TO_ADDR
123445: GO 123498
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123447: LD_ADDR_EXP 202
123451: PUSH
123452: LD_EXP 202
123456: PPUSH
123457: LD_VAR 0 1
123461: PPUSH
123462: LD_VAR 0 1
123466: PPUSH
123467: CALL_OW 255
123471: PUSH
123472: LD_VAR 0 1
123476: PUSH
123477: LD_VAR 0 2
123481: PUSH
123482: LD_VAR 0 3
123486: PUSH
123487: EMPTY
123488: LIST
123489: LIST
123490: LIST
123491: LIST
123492: PPUSH
123493: CALL_OW 1
123497: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123498: CALL 123507 0 0
// end ;
123502: LD_VAR 0 4
123506: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123507: LD_INT 0
123509: PPUSH
123510: PPUSH
123511: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123512: LD_STRING resetWarehouseGatheringPoints();
123514: PPUSH
123515: CALL_OW 559
// if warehouseGatheringPoints then
123519: LD_EXP 202
123523: IFFALSE 123649
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123525: LD_ADDR_VAR 0 3
123529: PUSH
123530: LD_EXP 202
123534: PPUSH
123535: CALL 108536 0 1
123539: ST_TO_ADDR
// for i := 1 to list do
123540: LD_ADDR_VAR 0 2
123544: PUSH
123545: DOUBLE
123546: LD_INT 1
123548: DEC
123549: ST_TO_ADDR
123550: LD_VAR 0 3
123554: PUSH
123555: FOR_TO
123556: IFFALSE 123647
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123558: LD_STRING setWarehouseGatheringPointXY(
123560: PUSH
123561: LD_VAR 0 3
123565: PUSH
123566: LD_VAR 0 2
123570: ARRAY
123571: PUSH
123572: LD_INT 1
123574: ARRAY
123575: STR
123576: PUSH
123577: LD_STRING ,
123579: STR
123580: PUSH
123581: LD_VAR 0 3
123585: PUSH
123586: LD_VAR 0 2
123590: ARRAY
123591: PUSH
123592: LD_INT 2
123594: ARRAY
123595: STR
123596: PUSH
123597: LD_STRING ,
123599: STR
123600: PUSH
123601: LD_VAR 0 3
123605: PUSH
123606: LD_VAR 0 2
123610: ARRAY
123611: PUSH
123612: LD_INT 3
123614: ARRAY
123615: STR
123616: PUSH
123617: LD_STRING ,
123619: STR
123620: PUSH
123621: LD_VAR 0 3
123625: PUSH
123626: LD_VAR 0 2
123630: ARRAY
123631: PUSH
123632: LD_INT 4
123634: ARRAY
123635: STR
123636: PUSH
123637: LD_STRING )
123639: STR
123640: PPUSH
123641: CALL_OW 559
123645: GO 123555
123647: POP
123648: POP
// end ; end ;
123649: LD_VAR 0 1
123653: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123654: LD_EXP 202
123658: IFFALSE 124343
123660: GO 123662
123662: DISABLE
123663: LD_INT 0
123665: PPUSH
123666: PPUSH
123667: PPUSH
123668: PPUSH
123669: PPUSH
123670: PPUSH
123671: PPUSH
123672: PPUSH
123673: PPUSH
// begin enable ;
123674: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123675: LD_ADDR_VAR 0 3
123679: PUSH
123680: LD_EXP 202
123684: PPUSH
123685: CALL 108536 0 1
123689: ST_TO_ADDR
// if not list then
123690: LD_VAR 0 3
123694: NOT
123695: IFFALSE 123699
// exit ;
123697: GO 124343
// for i := 1 to list do
123699: LD_ADDR_VAR 0 1
123703: PUSH
123704: DOUBLE
123705: LD_INT 1
123707: DEC
123708: ST_TO_ADDR
123709: LD_VAR 0 3
123713: PUSH
123714: FOR_TO
123715: IFFALSE 124341
// begin depot := list [ i ] [ 2 ] ;
123717: LD_ADDR_VAR 0 8
123721: PUSH
123722: LD_VAR 0 3
123726: PUSH
123727: LD_VAR 0 1
123731: ARRAY
123732: PUSH
123733: LD_INT 2
123735: ARRAY
123736: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123737: LD_ADDR_VAR 0 5
123741: PUSH
123742: LD_VAR 0 3
123746: PUSH
123747: LD_VAR 0 1
123751: ARRAY
123752: PUSH
123753: LD_INT 1
123755: ARRAY
123756: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123757: LD_VAR 0 8
123761: PPUSH
123762: CALL_OW 301
123766: PUSH
123767: LD_VAR 0 5
123771: PUSH
123772: LD_VAR 0 8
123776: PPUSH
123777: CALL_OW 255
123781: NONEQUAL
123782: OR
123783: IFFALSE 123812
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
123785: LD_ADDR_EXP 202
123789: PUSH
123790: LD_EXP 202
123794: PPUSH
123795: LD_VAR 0 8
123799: PPUSH
123800: LD_INT 0
123802: PPUSH
123803: CALL_OW 1
123807: ST_TO_ADDR
// exit ;
123808: POP
123809: POP
123810: GO 124343
// end ; x := list [ i ] [ 3 ] ;
123812: LD_ADDR_VAR 0 6
123816: PUSH
123817: LD_VAR 0 3
123821: PUSH
123822: LD_VAR 0 1
123826: ARRAY
123827: PUSH
123828: LD_INT 3
123830: ARRAY
123831: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
123832: LD_ADDR_VAR 0 7
123836: PUSH
123837: LD_VAR 0 3
123841: PUSH
123842: LD_VAR 0 1
123846: ARRAY
123847: PUSH
123848: LD_INT 4
123850: ARRAY
123851: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
123852: LD_ADDR_VAR 0 9
123856: PUSH
123857: LD_VAR 0 6
123861: PPUSH
123862: LD_VAR 0 7
123866: PPUSH
123867: LD_INT 16
123869: PPUSH
123870: CALL 107124 0 3
123874: ST_TO_ADDR
// if not cratesNearbyPoint then
123875: LD_VAR 0 9
123879: NOT
123880: IFFALSE 123886
// exit ;
123882: POP
123883: POP
123884: GO 124343
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
123886: LD_ADDR_VAR 0 4
123890: PUSH
123891: LD_INT 22
123893: PUSH
123894: LD_VAR 0 5
123898: PUSH
123899: EMPTY
123900: LIST
123901: LIST
123902: PUSH
123903: LD_INT 3
123905: PUSH
123906: LD_INT 60
123908: PUSH
123909: EMPTY
123910: LIST
123911: PUSH
123912: EMPTY
123913: LIST
123914: LIST
123915: PUSH
123916: LD_INT 91
123918: PUSH
123919: LD_VAR 0 8
123923: PUSH
123924: LD_INT 6
123926: PUSH
123927: EMPTY
123928: LIST
123929: LIST
123930: LIST
123931: PUSH
123932: LD_INT 2
123934: PUSH
123935: LD_INT 25
123937: PUSH
123938: LD_INT 2
123940: PUSH
123941: EMPTY
123942: LIST
123943: LIST
123944: PUSH
123945: LD_INT 25
123947: PUSH
123948: LD_INT 16
123950: PUSH
123951: EMPTY
123952: LIST
123953: LIST
123954: PUSH
123955: EMPTY
123956: LIST
123957: LIST
123958: LIST
123959: PUSH
123960: EMPTY
123961: LIST
123962: LIST
123963: LIST
123964: LIST
123965: PPUSH
123966: CALL_OW 69
123970: PUSH
123971: LD_VAR 0 8
123975: PPUSH
123976: CALL_OW 313
123980: PPUSH
123981: LD_INT 3
123983: PUSH
123984: LD_INT 60
123986: PUSH
123987: EMPTY
123988: LIST
123989: PUSH
123990: EMPTY
123991: LIST
123992: LIST
123993: PUSH
123994: LD_INT 2
123996: PUSH
123997: LD_INT 25
123999: PUSH
124000: LD_INT 2
124002: PUSH
124003: EMPTY
124004: LIST
124005: LIST
124006: PUSH
124007: LD_INT 25
124009: PUSH
124010: LD_INT 16
124012: PUSH
124013: EMPTY
124014: LIST
124015: LIST
124016: PUSH
124017: EMPTY
124018: LIST
124019: LIST
124020: LIST
124021: PUSH
124022: EMPTY
124023: LIST
124024: LIST
124025: PPUSH
124026: CALL_OW 72
124030: UNION
124031: ST_TO_ADDR
// if tmp then
124032: LD_VAR 0 4
124036: IFFALSE 124116
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124038: LD_ADDR_VAR 0 4
124042: PUSH
124043: LD_VAR 0 4
124047: PPUSH
124048: LD_INT 3
124050: PPUSH
124051: CALL 105093 0 2
124055: ST_TO_ADDR
// for j in tmp do
124056: LD_ADDR_VAR 0 2
124060: PUSH
124061: LD_VAR 0 4
124065: PUSH
124066: FOR_IN
124067: IFFALSE 124110
// begin if IsInUnit ( j ) then
124069: LD_VAR 0 2
124073: PPUSH
124074: CALL_OW 310
124078: IFFALSE 124089
// ComExit ( j ) ;
124080: LD_VAR 0 2
124084: PPUSH
124085: CALL 105176 0 1
// AddComCollect ( j , x , y ) ;
124089: LD_VAR 0 2
124093: PPUSH
124094: LD_VAR 0 6
124098: PPUSH
124099: LD_VAR 0 7
124103: PPUSH
124104: CALL_OW 177
// end ;
124108: GO 124066
124110: POP
124111: POP
// exit ;
124112: POP
124113: POP
124114: GO 124343
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124116: LD_ADDR_VAR 0 4
124120: PUSH
124121: LD_INT 22
124123: PUSH
124124: LD_VAR 0 5
124128: PUSH
124129: EMPTY
124130: LIST
124131: LIST
124132: PUSH
124133: LD_INT 91
124135: PUSH
124136: LD_VAR 0 8
124140: PUSH
124141: LD_INT 8
124143: PUSH
124144: EMPTY
124145: LIST
124146: LIST
124147: LIST
124148: PUSH
124149: LD_INT 2
124151: PUSH
124152: LD_INT 34
124154: PUSH
124155: LD_INT 12
124157: PUSH
124158: EMPTY
124159: LIST
124160: LIST
124161: PUSH
124162: LD_INT 34
124164: PUSH
124165: LD_INT 51
124167: PUSH
124168: EMPTY
124169: LIST
124170: LIST
124171: PUSH
124172: LD_INT 34
124174: PUSH
124175: LD_INT 32
124177: PUSH
124178: EMPTY
124179: LIST
124180: LIST
124181: PUSH
124182: LD_INT 34
124184: PUSH
124185: LD_INT 89
124187: PUSH
124188: EMPTY
124189: LIST
124190: LIST
124191: PUSH
124192: EMPTY
124193: LIST
124194: LIST
124195: LIST
124196: LIST
124197: LIST
124198: PUSH
124199: EMPTY
124200: LIST
124201: LIST
124202: LIST
124203: PPUSH
124204: CALL_OW 69
124208: ST_TO_ADDR
// if tmp then
124209: LD_VAR 0 4
124213: IFFALSE 124339
// begin for j in tmp do
124215: LD_ADDR_VAR 0 2
124219: PUSH
124220: LD_VAR 0 4
124224: PUSH
124225: FOR_IN
124226: IFFALSE 124337
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124228: LD_VAR 0 2
124232: PPUSH
124233: CALL_OW 262
124237: PUSH
124238: LD_INT 3
124240: EQUAL
124241: PUSH
124242: LD_VAR 0 2
124246: PPUSH
124247: CALL_OW 261
124251: PUSH
124252: LD_INT 20
124254: GREATER
124255: OR
124256: PUSH
124257: LD_VAR 0 2
124261: PPUSH
124262: CALL_OW 314
124266: NOT
124267: AND
124268: PUSH
124269: LD_VAR 0 2
124273: PPUSH
124274: CALL_OW 263
124278: PUSH
124279: LD_INT 1
124281: NONEQUAL
124282: PUSH
124283: LD_VAR 0 2
124287: PPUSH
124288: CALL_OW 311
124292: OR
124293: AND
124294: IFFALSE 124335
// begin ComCollect ( j , x , y ) ;
124296: LD_VAR 0 2
124300: PPUSH
124301: LD_VAR 0 6
124305: PPUSH
124306: LD_VAR 0 7
124310: PPUSH
124311: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124315: LD_VAR 0 2
124319: PPUSH
124320: LD_VAR 0 8
124324: PPUSH
124325: CALL_OW 172
// exit ;
124329: POP
124330: POP
124331: POP
124332: POP
124333: GO 124343
// end ;
124335: GO 124225
124337: POP
124338: POP
// end ; end ;
124339: GO 123714
124341: POP
124342: POP
// end ; end_of_file
124343: PPOPN 9
124345: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124346: LD_INT 0
124348: PPUSH
124349: PPUSH
124350: PPUSH
124351: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124352: LD_VAR 0 1
124356: PPUSH
124357: CALL_OW 264
124361: PUSH
124362: LD_INT 91
124364: EQUAL
124365: IFFALSE 124437
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124367: LD_INT 68
124369: PPUSH
124370: LD_VAR 0 1
124374: PPUSH
124375: CALL_OW 255
124379: PPUSH
124380: CALL_OW 321
124384: PUSH
124385: LD_INT 2
124387: EQUAL
124388: IFFALSE 124400
// eff := 70 else
124390: LD_ADDR_VAR 0 4
124394: PUSH
124395: LD_INT 70
124397: ST_TO_ADDR
124398: GO 124408
// eff := 30 ;
124400: LD_ADDR_VAR 0 4
124404: PUSH
124405: LD_INT 30
124407: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124408: LD_VAR 0 1
124412: PPUSH
124413: CALL_OW 250
124417: PPUSH
124418: LD_VAR 0 1
124422: PPUSH
124423: CALL_OW 251
124427: PPUSH
124428: LD_VAR 0 4
124432: PPUSH
124433: CALL_OW 495
// end ; end ;
124437: LD_VAR 0 2
124441: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124442: LD_INT 0
124444: PPUSH
// end ;
124445: LD_VAR 0 4
124449: RET
// export function SOS_Command ( cmd ) ; begin
124450: LD_INT 0
124452: PPUSH
// end ;
124453: LD_VAR 0 2
124457: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124458: LD_INT 0
124460: PPUSH
// end ;
124461: LD_VAR 0 6
124465: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124466: LD_INT 0
124468: PPUSH
124469: PPUSH
// if not vehicle or not factory then
124470: LD_VAR 0 1
124474: NOT
124475: PUSH
124476: LD_VAR 0 2
124480: NOT
124481: OR
124482: IFFALSE 124486
// exit ;
124484: GO 124717
// if factoryWaypoints >= factory then
124486: LD_EXP 201
124490: PUSH
124491: LD_VAR 0 2
124495: GREATEREQUAL
124496: IFFALSE 124717
// if factoryWaypoints [ factory ] then
124498: LD_EXP 201
124502: PUSH
124503: LD_VAR 0 2
124507: ARRAY
124508: IFFALSE 124717
// begin if GetControl ( vehicle ) = control_manual then
124510: LD_VAR 0 1
124514: PPUSH
124515: CALL_OW 263
124519: PUSH
124520: LD_INT 1
124522: EQUAL
124523: IFFALSE 124604
// begin driver := IsDrivenBy ( vehicle ) ;
124525: LD_ADDR_VAR 0 4
124529: PUSH
124530: LD_VAR 0 1
124534: PPUSH
124535: CALL_OW 311
124539: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124540: LD_VAR 0 4
124544: PPUSH
124545: LD_EXP 201
124549: PUSH
124550: LD_VAR 0 2
124554: ARRAY
124555: PUSH
124556: LD_INT 3
124558: ARRAY
124559: PPUSH
124560: LD_EXP 201
124564: PUSH
124565: LD_VAR 0 2
124569: ARRAY
124570: PUSH
124571: LD_INT 4
124573: ARRAY
124574: PPUSH
124575: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124579: LD_VAR 0 4
124583: PPUSH
124584: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124588: LD_VAR 0 4
124592: PPUSH
124593: LD_VAR 0 2
124597: PPUSH
124598: CALL_OW 180
// end else
124602: GO 124717
// if GetControl ( vehicle ) = control_remote then
124604: LD_VAR 0 1
124608: PPUSH
124609: CALL_OW 263
124613: PUSH
124614: LD_INT 2
124616: EQUAL
124617: IFFALSE 124678
// begin wait ( 0 0$2 ) ;
124619: LD_INT 70
124621: PPUSH
124622: CALL_OW 67
// if Connect ( vehicle ) then
124626: LD_VAR 0 1
124630: PPUSH
124631: CALL 75435 0 1
124635: IFFALSE 124676
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124637: LD_VAR 0 1
124641: PPUSH
124642: LD_EXP 201
124646: PUSH
124647: LD_VAR 0 2
124651: ARRAY
124652: PUSH
124653: LD_INT 3
124655: ARRAY
124656: PPUSH
124657: LD_EXP 201
124661: PUSH
124662: LD_VAR 0 2
124666: ARRAY
124667: PUSH
124668: LD_INT 4
124670: ARRAY
124671: PPUSH
124672: CALL_OW 171
// end else
124676: GO 124717
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124678: LD_VAR 0 1
124682: PPUSH
124683: LD_EXP 201
124687: PUSH
124688: LD_VAR 0 2
124692: ARRAY
124693: PUSH
124694: LD_INT 3
124696: ARRAY
124697: PPUSH
124698: LD_EXP 201
124702: PUSH
124703: LD_VAR 0 2
124707: ARRAY
124708: PUSH
124709: LD_INT 4
124711: ARRAY
124712: PPUSH
124713: CALL_OW 171
// end ; end ;
124717: LD_VAR 0 3
124721: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124722: LD_INT 0
124724: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124725: LD_VAR 0 1
124729: PUSH
124730: LD_INT 250
124732: EQUAL
124733: PUSH
124734: LD_VAR 0 2
124738: PPUSH
124739: CALL_OW 264
124743: PUSH
124744: LD_INT 81
124746: EQUAL
124747: AND
124748: IFFALSE 124769
// MinerPlaceMine ( unit , x , y ) ;
124750: LD_VAR 0 2
124754: PPUSH
124755: LD_VAR 0 4
124759: PPUSH
124760: LD_VAR 0 5
124764: PPUSH
124765: CALL 127154 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124769: LD_VAR 0 1
124773: PUSH
124774: LD_INT 251
124776: EQUAL
124777: PUSH
124778: LD_VAR 0 2
124782: PPUSH
124783: CALL_OW 264
124787: PUSH
124788: LD_INT 81
124790: EQUAL
124791: AND
124792: IFFALSE 124813
// MinerDetonateMine ( unit , x , y ) ;
124794: LD_VAR 0 2
124798: PPUSH
124799: LD_VAR 0 4
124803: PPUSH
124804: LD_VAR 0 5
124808: PPUSH
124809: CALL 127429 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
124813: LD_VAR 0 1
124817: PUSH
124818: LD_INT 252
124820: EQUAL
124821: PUSH
124822: LD_VAR 0 2
124826: PPUSH
124827: CALL_OW 264
124831: PUSH
124832: LD_INT 81
124834: EQUAL
124835: AND
124836: IFFALSE 124857
// MinerCreateMinefield ( unit , x , y ) ;
124838: LD_VAR 0 2
124842: PPUSH
124843: LD_VAR 0 4
124847: PPUSH
124848: LD_VAR 0 5
124852: PPUSH
124853: CALL 127846 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
124857: LD_VAR 0 1
124861: PUSH
124862: LD_INT 253
124864: EQUAL
124865: PUSH
124866: LD_VAR 0 2
124870: PPUSH
124871: CALL_OW 257
124875: PUSH
124876: LD_INT 5
124878: EQUAL
124879: AND
124880: IFFALSE 124901
// ComBinocular ( unit , x , y ) ;
124882: LD_VAR 0 2
124886: PPUSH
124887: LD_VAR 0 4
124891: PPUSH
124892: LD_VAR 0 5
124896: PPUSH
124897: CALL 128215 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
124901: LD_VAR 0 1
124905: PUSH
124906: LD_INT 254
124908: EQUAL
124909: PUSH
124910: LD_VAR 0 2
124914: PPUSH
124915: CALL_OW 264
124919: PUSH
124920: LD_INT 99
124922: EQUAL
124923: AND
124924: PUSH
124925: LD_VAR 0 3
124929: PPUSH
124930: CALL_OW 263
124934: PUSH
124935: LD_INT 3
124937: EQUAL
124938: AND
124939: IFFALSE 124955
// HackDestroyVehicle ( unit , selectedUnit ) ;
124941: LD_VAR 0 2
124945: PPUSH
124946: LD_VAR 0 3
124950: PPUSH
124951: CALL 126518 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
124955: LD_VAR 0 1
124959: PUSH
124960: LD_INT 255
124962: EQUAL
124963: PUSH
124964: LD_VAR 0 2
124968: PPUSH
124969: CALL_OW 264
124973: PUSH
124974: LD_INT 14
124976: PUSH
124977: LD_INT 53
124979: PUSH
124980: EMPTY
124981: LIST
124982: LIST
124983: IN
124984: AND
124985: PUSH
124986: LD_VAR 0 4
124990: PPUSH
124991: LD_VAR 0 5
124995: PPUSH
124996: CALL_OW 488
125000: AND
125001: IFFALSE 125025
// CutTreeXYR ( unit , x , y , 12 ) ;
125003: LD_VAR 0 2
125007: PPUSH
125008: LD_VAR 0 4
125012: PPUSH
125013: LD_VAR 0 5
125017: PPUSH
125018: LD_INT 12
125020: PPUSH
125021: CALL 125088 0 4
// if cmd = 256 then
125025: LD_VAR 0 1
125029: PUSH
125030: LD_INT 256
125032: EQUAL
125033: IFFALSE 125054
// SetFactoryWaypoint ( unit , x , y ) ;
125035: LD_VAR 0 2
125039: PPUSH
125040: LD_VAR 0 4
125044: PPUSH
125045: LD_VAR 0 5
125049: PPUSH
125050: CALL 123035 0 3
// if cmd = 257 then
125054: LD_VAR 0 1
125058: PUSH
125059: LD_INT 257
125061: EQUAL
125062: IFFALSE 125083
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125064: LD_VAR 0 2
125068: PPUSH
125069: LD_VAR 0 4
125073: PPUSH
125074: LD_VAR 0 5
125078: PPUSH
125079: CALL 123397 0 3
// end ;
125083: LD_VAR 0 6
125087: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125088: LD_INT 0
125090: PPUSH
125091: PPUSH
125092: PPUSH
125093: PPUSH
125094: PPUSH
125095: PPUSH
125096: PPUSH
125097: PPUSH
125098: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125099: LD_VAR 0 1
125103: NOT
125104: PUSH
125105: LD_VAR 0 2
125109: PPUSH
125110: LD_VAR 0 3
125114: PPUSH
125115: CALL_OW 488
125119: NOT
125120: OR
125121: PUSH
125122: LD_VAR 0 4
125126: NOT
125127: OR
125128: IFFALSE 125132
// exit ;
125130: GO 125472
// list := [ ] ;
125132: LD_ADDR_VAR 0 13
125136: PUSH
125137: EMPTY
125138: ST_TO_ADDR
// if x - r < 0 then
125139: LD_VAR 0 2
125143: PUSH
125144: LD_VAR 0 4
125148: MINUS
125149: PUSH
125150: LD_INT 0
125152: LESS
125153: IFFALSE 125165
// min_x := 0 else
125155: LD_ADDR_VAR 0 7
125159: PUSH
125160: LD_INT 0
125162: ST_TO_ADDR
125163: GO 125181
// min_x := x - r ;
125165: LD_ADDR_VAR 0 7
125169: PUSH
125170: LD_VAR 0 2
125174: PUSH
125175: LD_VAR 0 4
125179: MINUS
125180: ST_TO_ADDR
// if y - r < 0 then
125181: LD_VAR 0 3
125185: PUSH
125186: LD_VAR 0 4
125190: MINUS
125191: PUSH
125192: LD_INT 0
125194: LESS
125195: IFFALSE 125207
// min_y := 0 else
125197: LD_ADDR_VAR 0 8
125201: PUSH
125202: LD_INT 0
125204: ST_TO_ADDR
125205: GO 125223
// min_y := y - r ;
125207: LD_ADDR_VAR 0 8
125211: PUSH
125212: LD_VAR 0 3
125216: PUSH
125217: LD_VAR 0 4
125221: MINUS
125222: ST_TO_ADDR
// max_x := x + r ;
125223: LD_ADDR_VAR 0 9
125227: PUSH
125228: LD_VAR 0 2
125232: PUSH
125233: LD_VAR 0 4
125237: PLUS
125238: ST_TO_ADDR
// max_y := y + r ;
125239: LD_ADDR_VAR 0 10
125243: PUSH
125244: LD_VAR 0 3
125248: PUSH
125249: LD_VAR 0 4
125253: PLUS
125254: ST_TO_ADDR
// for _x = min_x to max_x do
125255: LD_ADDR_VAR 0 11
125259: PUSH
125260: DOUBLE
125261: LD_VAR 0 7
125265: DEC
125266: ST_TO_ADDR
125267: LD_VAR 0 9
125271: PUSH
125272: FOR_TO
125273: IFFALSE 125390
// for _y = min_y to max_y do
125275: LD_ADDR_VAR 0 12
125279: PUSH
125280: DOUBLE
125281: LD_VAR 0 8
125285: DEC
125286: ST_TO_ADDR
125287: LD_VAR 0 10
125291: PUSH
125292: FOR_TO
125293: IFFALSE 125386
// begin if not ValidHex ( _x , _y ) then
125295: LD_VAR 0 11
125299: PPUSH
125300: LD_VAR 0 12
125304: PPUSH
125305: CALL_OW 488
125309: NOT
125310: IFFALSE 125314
// continue ;
125312: GO 125292
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125314: LD_VAR 0 11
125318: PPUSH
125319: LD_VAR 0 12
125323: PPUSH
125324: CALL_OW 351
125328: PUSH
125329: LD_VAR 0 11
125333: PPUSH
125334: LD_VAR 0 12
125338: PPUSH
125339: CALL_OW 554
125343: AND
125344: IFFALSE 125384
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125346: LD_ADDR_VAR 0 13
125350: PUSH
125351: LD_VAR 0 13
125355: PPUSH
125356: LD_VAR 0 13
125360: PUSH
125361: LD_INT 1
125363: PLUS
125364: PPUSH
125365: LD_VAR 0 11
125369: PUSH
125370: LD_VAR 0 12
125374: PUSH
125375: EMPTY
125376: LIST
125377: LIST
125378: PPUSH
125379: CALL_OW 2
125383: ST_TO_ADDR
// end ;
125384: GO 125292
125386: POP
125387: POP
125388: GO 125272
125390: POP
125391: POP
// if not list then
125392: LD_VAR 0 13
125396: NOT
125397: IFFALSE 125401
// exit ;
125399: GO 125472
// for i in list do
125401: LD_ADDR_VAR 0 6
125405: PUSH
125406: LD_VAR 0 13
125410: PUSH
125411: FOR_IN
125412: IFFALSE 125470
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125414: LD_VAR 0 1
125418: PPUSH
125419: LD_STRING M
125421: PUSH
125422: LD_VAR 0 6
125426: PUSH
125427: LD_INT 1
125429: ARRAY
125430: PUSH
125431: LD_VAR 0 6
125435: PUSH
125436: LD_INT 2
125438: ARRAY
125439: PUSH
125440: LD_INT 0
125442: PUSH
125443: LD_INT 0
125445: PUSH
125446: LD_INT 0
125448: PUSH
125449: LD_INT 0
125451: PUSH
125452: EMPTY
125453: LIST
125454: LIST
125455: LIST
125456: LIST
125457: LIST
125458: LIST
125459: LIST
125460: PUSH
125461: EMPTY
125462: LIST
125463: PPUSH
125464: CALL_OW 447
125468: GO 125411
125470: POP
125471: POP
// end ;
125472: LD_VAR 0 5
125476: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125477: LD_EXP 204
125481: NOT
125482: IFFALSE 125532
125484: GO 125486
125486: DISABLE
// begin initHack := true ;
125487: LD_ADDR_EXP 204
125491: PUSH
125492: LD_INT 1
125494: ST_TO_ADDR
// hackTanks := [ ] ;
125495: LD_ADDR_EXP 205
125499: PUSH
125500: EMPTY
125501: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125502: LD_ADDR_EXP 206
125506: PUSH
125507: EMPTY
125508: ST_TO_ADDR
// hackLimit := 3 ;
125509: LD_ADDR_EXP 207
125513: PUSH
125514: LD_INT 3
125516: ST_TO_ADDR
// hackDist := 12 ;
125517: LD_ADDR_EXP 208
125521: PUSH
125522: LD_INT 12
125524: ST_TO_ADDR
// hackCounter := [ ] ;
125525: LD_ADDR_EXP 209
125529: PUSH
125530: EMPTY
125531: ST_TO_ADDR
// end ;
125532: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125533: LD_EXP 204
125537: PUSH
125538: LD_INT 34
125540: PUSH
125541: LD_INT 99
125543: PUSH
125544: EMPTY
125545: LIST
125546: LIST
125547: PPUSH
125548: CALL_OW 69
125552: AND
125553: IFFALSE 125806
125555: GO 125557
125557: DISABLE
125558: LD_INT 0
125560: PPUSH
125561: PPUSH
// begin enable ;
125562: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125563: LD_ADDR_VAR 0 1
125567: PUSH
125568: LD_INT 34
125570: PUSH
125571: LD_INT 99
125573: PUSH
125574: EMPTY
125575: LIST
125576: LIST
125577: PPUSH
125578: CALL_OW 69
125582: PUSH
125583: FOR_IN
125584: IFFALSE 125804
// begin if not i in hackTanks then
125586: LD_VAR 0 1
125590: PUSH
125591: LD_EXP 205
125595: IN
125596: NOT
125597: IFFALSE 125680
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125599: LD_ADDR_EXP 205
125603: PUSH
125604: LD_EXP 205
125608: PPUSH
125609: LD_EXP 205
125613: PUSH
125614: LD_INT 1
125616: PLUS
125617: PPUSH
125618: LD_VAR 0 1
125622: PPUSH
125623: CALL_OW 1
125627: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125628: LD_ADDR_EXP 206
125632: PUSH
125633: LD_EXP 206
125637: PPUSH
125638: LD_EXP 206
125642: PUSH
125643: LD_INT 1
125645: PLUS
125646: PPUSH
125647: EMPTY
125648: PPUSH
125649: CALL_OW 1
125653: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125654: LD_ADDR_EXP 209
125658: PUSH
125659: LD_EXP 209
125663: PPUSH
125664: LD_EXP 209
125668: PUSH
125669: LD_INT 1
125671: PLUS
125672: PPUSH
125673: EMPTY
125674: PPUSH
125675: CALL_OW 1
125679: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125680: LD_VAR 0 1
125684: PPUSH
125685: CALL_OW 302
125689: NOT
125690: IFFALSE 125703
// begin HackUnlinkAll ( i ) ;
125692: LD_VAR 0 1
125696: PPUSH
125697: CALL 125809 0 1
// continue ;
125701: GO 125583
// end ; HackCheckCapturedStatus ( i ) ;
125703: LD_VAR 0 1
125707: PPUSH
125708: CALL 126252 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125712: LD_ADDR_VAR 0 2
125716: PUSH
125717: LD_INT 81
125719: PUSH
125720: LD_VAR 0 1
125724: PPUSH
125725: CALL_OW 255
125729: PUSH
125730: EMPTY
125731: LIST
125732: LIST
125733: PUSH
125734: LD_INT 33
125736: PUSH
125737: LD_INT 3
125739: PUSH
125740: EMPTY
125741: LIST
125742: LIST
125743: PUSH
125744: LD_INT 91
125746: PUSH
125747: LD_VAR 0 1
125751: PUSH
125752: LD_EXP 208
125756: PUSH
125757: EMPTY
125758: LIST
125759: LIST
125760: LIST
125761: PUSH
125762: LD_INT 50
125764: PUSH
125765: EMPTY
125766: LIST
125767: PUSH
125768: EMPTY
125769: LIST
125770: LIST
125771: LIST
125772: LIST
125773: PPUSH
125774: CALL_OW 69
125778: ST_TO_ADDR
// if not tmp then
125779: LD_VAR 0 2
125783: NOT
125784: IFFALSE 125788
// continue ;
125786: GO 125583
// HackLink ( i , tmp ) ;
125788: LD_VAR 0 1
125792: PPUSH
125793: LD_VAR 0 2
125797: PPUSH
125798: CALL 125945 0 2
// end ;
125802: GO 125583
125804: POP
125805: POP
// end ;
125806: PPOPN 2
125808: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
125809: LD_INT 0
125811: PPUSH
125812: PPUSH
125813: PPUSH
// if not hack in hackTanks then
125814: LD_VAR 0 1
125818: PUSH
125819: LD_EXP 205
125823: IN
125824: NOT
125825: IFFALSE 125829
// exit ;
125827: GO 125940
// index := GetElementIndex ( hackTanks , hack ) ;
125829: LD_ADDR_VAR 0 4
125833: PUSH
125834: LD_EXP 205
125838: PPUSH
125839: LD_VAR 0 1
125843: PPUSH
125844: CALL 72251 0 2
125848: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
125849: LD_EXP 206
125853: PUSH
125854: LD_VAR 0 4
125858: ARRAY
125859: IFFALSE 125940
// begin for i in hackTanksCaptured [ index ] do
125861: LD_ADDR_VAR 0 3
125865: PUSH
125866: LD_EXP 206
125870: PUSH
125871: LD_VAR 0 4
125875: ARRAY
125876: PUSH
125877: FOR_IN
125878: IFFALSE 125904
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
125880: LD_VAR 0 3
125884: PUSH
125885: LD_INT 1
125887: ARRAY
125888: PPUSH
125889: LD_VAR 0 3
125893: PUSH
125894: LD_INT 2
125896: ARRAY
125897: PPUSH
125898: CALL_OW 235
125902: GO 125877
125904: POP
125905: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
125906: LD_ADDR_EXP 206
125910: PUSH
125911: LD_EXP 206
125915: PPUSH
125916: LD_VAR 0 4
125920: PPUSH
125921: EMPTY
125922: PPUSH
125923: CALL_OW 1
125927: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
125928: LD_VAR 0 1
125932: PPUSH
125933: LD_INT 0
125935: PPUSH
125936: CALL_OW 505
// end ; end ;
125940: LD_VAR 0 2
125944: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
125945: LD_INT 0
125947: PPUSH
125948: PPUSH
125949: PPUSH
// if not hack in hackTanks or not vehicles then
125950: LD_VAR 0 1
125954: PUSH
125955: LD_EXP 205
125959: IN
125960: NOT
125961: PUSH
125962: LD_VAR 0 2
125966: NOT
125967: OR
125968: IFFALSE 125972
// exit ;
125970: GO 126247
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
125972: LD_ADDR_VAR 0 2
125976: PUSH
125977: LD_VAR 0 1
125981: PPUSH
125982: LD_VAR 0 2
125986: PPUSH
125987: LD_INT 1
125989: PPUSH
125990: LD_INT 1
125992: PPUSH
125993: CALL 72901 0 4
125997: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
125998: LD_ADDR_VAR 0 5
126002: PUSH
126003: LD_EXP 205
126007: PPUSH
126008: LD_VAR 0 1
126012: PPUSH
126013: CALL 72251 0 2
126017: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126018: LD_EXP 206
126022: PUSH
126023: LD_VAR 0 5
126027: ARRAY
126028: PUSH
126029: LD_EXP 207
126033: LESS
126034: IFFALSE 126223
// begin for i := 1 to vehicles do
126036: LD_ADDR_VAR 0 4
126040: PUSH
126041: DOUBLE
126042: LD_INT 1
126044: DEC
126045: ST_TO_ADDR
126046: LD_VAR 0 2
126050: PUSH
126051: FOR_TO
126052: IFFALSE 126221
// begin if hackTanksCaptured [ index ] = hackLimit then
126054: LD_EXP 206
126058: PUSH
126059: LD_VAR 0 5
126063: ARRAY
126064: PUSH
126065: LD_EXP 207
126069: EQUAL
126070: IFFALSE 126074
// break ;
126072: GO 126221
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126074: LD_ADDR_EXP 209
126078: PUSH
126079: LD_EXP 209
126083: PPUSH
126084: LD_VAR 0 5
126088: PPUSH
126089: LD_EXP 209
126093: PUSH
126094: LD_VAR 0 5
126098: ARRAY
126099: PUSH
126100: LD_INT 1
126102: PLUS
126103: PPUSH
126104: CALL_OW 1
126108: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126109: LD_ADDR_EXP 206
126113: PUSH
126114: LD_EXP 206
126118: PPUSH
126119: LD_VAR 0 5
126123: PUSH
126124: LD_EXP 206
126128: PUSH
126129: LD_VAR 0 5
126133: ARRAY
126134: PUSH
126135: LD_INT 1
126137: PLUS
126138: PUSH
126139: EMPTY
126140: LIST
126141: LIST
126142: PPUSH
126143: LD_VAR 0 2
126147: PUSH
126148: LD_VAR 0 4
126152: ARRAY
126153: PUSH
126154: LD_VAR 0 2
126158: PUSH
126159: LD_VAR 0 4
126163: ARRAY
126164: PPUSH
126165: CALL_OW 255
126169: PUSH
126170: EMPTY
126171: LIST
126172: LIST
126173: PPUSH
126174: CALL 72466 0 3
126178: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126179: LD_VAR 0 2
126183: PUSH
126184: LD_VAR 0 4
126188: ARRAY
126189: PPUSH
126190: LD_VAR 0 1
126194: PPUSH
126195: CALL_OW 255
126199: PPUSH
126200: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126204: LD_VAR 0 2
126208: PUSH
126209: LD_VAR 0 4
126213: ARRAY
126214: PPUSH
126215: CALL_OW 141
// end ;
126219: GO 126051
126221: POP
126222: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126223: LD_VAR 0 1
126227: PPUSH
126228: LD_EXP 206
126232: PUSH
126233: LD_VAR 0 5
126237: ARRAY
126238: PUSH
126239: LD_INT 0
126241: PLUS
126242: PPUSH
126243: CALL_OW 505
// end ;
126247: LD_VAR 0 3
126251: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126252: LD_INT 0
126254: PPUSH
126255: PPUSH
126256: PPUSH
126257: PPUSH
// if not hack in hackTanks then
126258: LD_VAR 0 1
126262: PUSH
126263: LD_EXP 205
126267: IN
126268: NOT
126269: IFFALSE 126273
// exit ;
126271: GO 126513
// index := GetElementIndex ( hackTanks , hack ) ;
126273: LD_ADDR_VAR 0 4
126277: PUSH
126278: LD_EXP 205
126282: PPUSH
126283: LD_VAR 0 1
126287: PPUSH
126288: CALL 72251 0 2
126292: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126293: LD_ADDR_VAR 0 3
126297: PUSH
126298: DOUBLE
126299: LD_EXP 206
126303: PUSH
126304: LD_VAR 0 4
126308: ARRAY
126309: INC
126310: ST_TO_ADDR
126311: LD_INT 1
126313: PUSH
126314: FOR_DOWNTO
126315: IFFALSE 126487
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126317: LD_ADDR_VAR 0 5
126321: PUSH
126322: LD_EXP 206
126326: PUSH
126327: LD_VAR 0 4
126331: ARRAY
126332: PUSH
126333: LD_VAR 0 3
126337: ARRAY
126338: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126339: LD_VAR 0 5
126343: PUSH
126344: LD_INT 1
126346: ARRAY
126347: PPUSH
126348: CALL_OW 302
126352: NOT
126353: PUSH
126354: LD_VAR 0 5
126358: PUSH
126359: LD_INT 1
126361: ARRAY
126362: PPUSH
126363: CALL_OW 255
126367: PUSH
126368: LD_VAR 0 1
126372: PPUSH
126373: CALL_OW 255
126377: NONEQUAL
126378: OR
126379: IFFALSE 126485
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126381: LD_VAR 0 5
126385: PUSH
126386: LD_INT 1
126388: ARRAY
126389: PPUSH
126390: CALL_OW 305
126394: PUSH
126395: LD_VAR 0 5
126399: PUSH
126400: LD_INT 1
126402: ARRAY
126403: PPUSH
126404: CALL_OW 255
126408: PUSH
126409: LD_VAR 0 1
126413: PPUSH
126414: CALL_OW 255
126418: EQUAL
126419: AND
126420: IFFALSE 126444
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126422: LD_VAR 0 5
126426: PUSH
126427: LD_INT 1
126429: ARRAY
126430: PPUSH
126431: LD_VAR 0 5
126435: PUSH
126436: LD_INT 2
126438: ARRAY
126439: PPUSH
126440: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126444: LD_ADDR_EXP 206
126448: PUSH
126449: LD_EXP 206
126453: PPUSH
126454: LD_VAR 0 4
126458: PPUSH
126459: LD_EXP 206
126463: PUSH
126464: LD_VAR 0 4
126468: ARRAY
126469: PPUSH
126470: LD_VAR 0 3
126474: PPUSH
126475: CALL_OW 3
126479: PPUSH
126480: CALL_OW 1
126484: ST_TO_ADDR
// end ; end ;
126485: GO 126314
126487: POP
126488: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126489: LD_VAR 0 1
126493: PPUSH
126494: LD_EXP 206
126498: PUSH
126499: LD_VAR 0 4
126503: ARRAY
126504: PUSH
126505: LD_INT 0
126507: PLUS
126508: PPUSH
126509: CALL_OW 505
// end ;
126513: LD_VAR 0 2
126517: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126518: LD_INT 0
126520: PPUSH
126521: PPUSH
126522: PPUSH
126523: PPUSH
// if not hack in hackTanks then
126524: LD_VAR 0 1
126528: PUSH
126529: LD_EXP 205
126533: IN
126534: NOT
126535: IFFALSE 126539
// exit ;
126537: GO 126624
// index := GetElementIndex ( hackTanks , hack ) ;
126539: LD_ADDR_VAR 0 5
126543: PUSH
126544: LD_EXP 205
126548: PPUSH
126549: LD_VAR 0 1
126553: PPUSH
126554: CALL 72251 0 2
126558: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126559: LD_ADDR_VAR 0 4
126563: PUSH
126564: DOUBLE
126565: LD_INT 1
126567: DEC
126568: ST_TO_ADDR
126569: LD_EXP 206
126573: PUSH
126574: LD_VAR 0 5
126578: ARRAY
126579: PUSH
126580: FOR_TO
126581: IFFALSE 126622
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126583: LD_EXP 206
126587: PUSH
126588: LD_VAR 0 5
126592: ARRAY
126593: PUSH
126594: LD_VAR 0 4
126598: ARRAY
126599: PUSH
126600: LD_INT 1
126602: ARRAY
126603: PUSH
126604: LD_VAR 0 2
126608: EQUAL
126609: IFFALSE 126620
// KillUnit ( vehicle ) ;
126611: LD_VAR 0 2
126615: PPUSH
126616: CALL_OW 66
126620: GO 126580
126622: POP
126623: POP
// end ;
126624: LD_VAR 0 3
126628: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126629: LD_EXP 210
126633: NOT
126634: IFFALSE 126669
126636: GO 126638
126638: DISABLE
// begin initMiner := true ;
126639: LD_ADDR_EXP 210
126643: PUSH
126644: LD_INT 1
126646: ST_TO_ADDR
// minersList := [ ] ;
126647: LD_ADDR_EXP 211
126651: PUSH
126652: EMPTY
126653: ST_TO_ADDR
// minerMinesList := [ ] ;
126654: LD_ADDR_EXP 212
126658: PUSH
126659: EMPTY
126660: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126661: LD_ADDR_EXP 213
126665: PUSH
126666: LD_INT 5
126668: ST_TO_ADDR
// end ;
126669: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126670: LD_EXP 210
126674: PUSH
126675: LD_INT 34
126677: PUSH
126678: LD_INT 81
126680: PUSH
126681: EMPTY
126682: LIST
126683: LIST
126684: PPUSH
126685: CALL_OW 69
126689: AND
126690: IFFALSE 127151
126692: GO 126694
126694: DISABLE
126695: LD_INT 0
126697: PPUSH
126698: PPUSH
126699: PPUSH
126700: PPUSH
// begin enable ;
126701: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126702: LD_ADDR_VAR 0 1
126706: PUSH
126707: LD_INT 34
126709: PUSH
126710: LD_INT 81
126712: PUSH
126713: EMPTY
126714: LIST
126715: LIST
126716: PPUSH
126717: CALL_OW 69
126721: PUSH
126722: FOR_IN
126723: IFFALSE 126795
// begin if not i in minersList then
126725: LD_VAR 0 1
126729: PUSH
126730: LD_EXP 211
126734: IN
126735: NOT
126736: IFFALSE 126793
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126738: LD_ADDR_EXP 211
126742: PUSH
126743: LD_EXP 211
126747: PPUSH
126748: LD_EXP 211
126752: PUSH
126753: LD_INT 1
126755: PLUS
126756: PPUSH
126757: LD_VAR 0 1
126761: PPUSH
126762: CALL_OW 1
126766: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126767: LD_ADDR_EXP 212
126771: PUSH
126772: LD_EXP 212
126776: PPUSH
126777: LD_EXP 212
126781: PUSH
126782: LD_INT 1
126784: PLUS
126785: PPUSH
126786: EMPTY
126787: PPUSH
126788: CALL_OW 1
126792: ST_TO_ADDR
// end end ;
126793: GO 126722
126795: POP
126796: POP
// for i := minerMinesList downto 1 do
126797: LD_ADDR_VAR 0 1
126801: PUSH
126802: DOUBLE
126803: LD_EXP 212
126807: INC
126808: ST_TO_ADDR
126809: LD_INT 1
126811: PUSH
126812: FOR_DOWNTO
126813: IFFALSE 127149
// begin if IsLive ( minersList [ i ] ) then
126815: LD_EXP 211
126819: PUSH
126820: LD_VAR 0 1
126824: ARRAY
126825: PPUSH
126826: CALL_OW 300
126830: IFFALSE 126858
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
126832: LD_EXP 211
126836: PUSH
126837: LD_VAR 0 1
126841: ARRAY
126842: PPUSH
126843: LD_EXP 212
126847: PUSH
126848: LD_VAR 0 1
126852: ARRAY
126853: PPUSH
126854: CALL_OW 505
// if not minerMinesList [ i ] then
126858: LD_EXP 212
126862: PUSH
126863: LD_VAR 0 1
126867: ARRAY
126868: NOT
126869: IFFALSE 126873
// continue ;
126871: GO 126812
// for j := minerMinesList [ i ] downto 1 do
126873: LD_ADDR_VAR 0 2
126877: PUSH
126878: DOUBLE
126879: LD_EXP 212
126883: PUSH
126884: LD_VAR 0 1
126888: ARRAY
126889: INC
126890: ST_TO_ADDR
126891: LD_INT 1
126893: PUSH
126894: FOR_DOWNTO
126895: IFFALSE 127145
// begin side := GetSide ( minersList [ i ] ) ;
126897: LD_ADDR_VAR 0 3
126901: PUSH
126902: LD_EXP 211
126906: PUSH
126907: LD_VAR 0 1
126911: ARRAY
126912: PPUSH
126913: CALL_OW 255
126917: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
126918: LD_ADDR_VAR 0 4
126922: PUSH
126923: LD_EXP 212
126927: PUSH
126928: LD_VAR 0 1
126932: ARRAY
126933: PUSH
126934: LD_VAR 0 2
126938: ARRAY
126939: PUSH
126940: LD_INT 1
126942: ARRAY
126943: PPUSH
126944: LD_EXP 212
126948: PUSH
126949: LD_VAR 0 1
126953: ARRAY
126954: PUSH
126955: LD_VAR 0 2
126959: ARRAY
126960: PUSH
126961: LD_INT 2
126963: ARRAY
126964: PPUSH
126965: CALL_OW 428
126969: ST_TO_ADDR
// if not tmp then
126970: LD_VAR 0 4
126974: NOT
126975: IFFALSE 126979
// continue ;
126977: GO 126894
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
126979: LD_VAR 0 4
126983: PUSH
126984: LD_INT 81
126986: PUSH
126987: LD_VAR 0 3
126991: PUSH
126992: EMPTY
126993: LIST
126994: LIST
126995: PPUSH
126996: CALL_OW 69
127000: IN
127001: PUSH
127002: LD_EXP 212
127006: PUSH
127007: LD_VAR 0 1
127011: ARRAY
127012: PUSH
127013: LD_VAR 0 2
127017: ARRAY
127018: PUSH
127019: LD_INT 1
127021: ARRAY
127022: PPUSH
127023: LD_EXP 212
127027: PUSH
127028: LD_VAR 0 1
127032: ARRAY
127033: PUSH
127034: LD_VAR 0 2
127038: ARRAY
127039: PUSH
127040: LD_INT 2
127042: ARRAY
127043: PPUSH
127044: CALL_OW 458
127048: AND
127049: IFFALSE 127143
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127051: LD_EXP 212
127055: PUSH
127056: LD_VAR 0 1
127060: ARRAY
127061: PUSH
127062: LD_VAR 0 2
127066: ARRAY
127067: PUSH
127068: LD_INT 1
127070: ARRAY
127071: PPUSH
127072: LD_EXP 212
127076: PUSH
127077: LD_VAR 0 1
127081: ARRAY
127082: PUSH
127083: LD_VAR 0 2
127087: ARRAY
127088: PUSH
127089: LD_INT 2
127091: ARRAY
127092: PPUSH
127093: LD_VAR 0 3
127097: PPUSH
127098: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127102: LD_ADDR_EXP 212
127106: PUSH
127107: LD_EXP 212
127111: PPUSH
127112: LD_VAR 0 1
127116: PPUSH
127117: LD_EXP 212
127121: PUSH
127122: LD_VAR 0 1
127126: ARRAY
127127: PPUSH
127128: LD_VAR 0 2
127132: PPUSH
127133: CALL_OW 3
127137: PPUSH
127138: CALL_OW 1
127142: ST_TO_ADDR
// end ; end ;
127143: GO 126894
127145: POP
127146: POP
// end ;
127147: GO 126812
127149: POP
127150: POP
// end ;
127151: PPOPN 4
127153: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127154: LD_INT 0
127156: PPUSH
127157: PPUSH
// result := false ;
127158: LD_ADDR_VAR 0 4
127162: PUSH
127163: LD_INT 0
127165: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127166: LD_VAR 0 1
127170: PPUSH
127171: CALL_OW 264
127175: PUSH
127176: LD_INT 81
127178: EQUAL
127179: NOT
127180: IFFALSE 127184
// exit ;
127182: GO 127424
// index := GetElementIndex ( minersList , unit ) ;
127184: LD_ADDR_VAR 0 5
127188: PUSH
127189: LD_EXP 211
127193: PPUSH
127194: LD_VAR 0 1
127198: PPUSH
127199: CALL 72251 0 2
127203: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127204: LD_EXP 212
127208: PUSH
127209: LD_VAR 0 5
127213: ARRAY
127214: PUSH
127215: LD_EXP 213
127219: GREATEREQUAL
127220: IFFALSE 127224
// exit ;
127222: GO 127424
// ComMoveXY ( unit , x , y ) ;
127224: LD_VAR 0 1
127228: PPUSH
127229: LD_VAR 0 2
127233: PPUSH
127234: LD_VAR 0 3
127238: PPUSH
127239: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127243: LD_INT 35
127245: PPUSH
127246: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127250: LD_VAR 0 1
127254: PPUSH
127255: LD_VAR 0 2
127259: PPUSH
127260: LD_VAR 0 3
127264: PPUSH
127265: CALL 103587 0 3
127269: NOT
127270: PUSH
127271: LD_VAR 0 1
127275: PPUSH
127276: CALL_OW 314
127280: AND
127281: IFFALSE 127285
// exit ;
127283: GO 127424
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127285: LD_VAR 0 2
127289: PPUSH
127290: LD_VAR 0 3
127294: PPUSH
127295: CALL_OW 428
127299: PUSH
127300: LD_VAR 0 1
127304: EQUAL
127305: PUSH
127306: LD_VAR 0 1
127310: PPUSH
127311: CALL_OW 314
127315: NOT
127316: AND
127317: IFFALSE 127243
// PlaySoundXY ( x , y , PlantMine ) ;
127319: LD_VAR 0 2
127323: PPUSH
127324: LD_VAR 0 3
127328: PPUSH
127329: LD_STRING PlantMine
127331: PPUSH
127332: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127336: LD_VAR 0 2
127340: PPUSH
127341: LD_VAR 0 3
127345: PPUSH
127346: LD_VAR 0 1
127350: PPUSH
127351: CALL_OW 255
127355: PPUSH
127356: LD_INT 0
127358: PPUSH
127359: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127363: LD_ADDR_EXP 212
127367: PUSH
127368: LD_EXP 212
127372: PPUSH
127373: LD_VAR 0 5
127377: PUSH
127378: LD_EXP 212
127382: PUSH
127383: LD_VAR 0 5
127387: ARRAY
127388: PUSH
127389: LD_INT 1
127391: PLUS
127392: PUSH
127393: EMPTY
127394: LIST
127395: LIST
127396: PPUSH
127397: LD_VAR 0 2
127401: PUSH
127402: LD_VAR 0 3
127406: PUSH
127407: EMPTY
127408: LIST
127409: LIST
127410: PPUSH
127411: CALL 72466 0 3
127415: ST_TO_ADDR
// result := true ;
127416: LD_ADDR_VAR 0 4
127420: PUSH
127421: LD_INT 1
127423: ST_TO_ADDR
// end ;
127424: LD_VAR 0 4
127428: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127429: LD_INT 0
127431: PPUSH
127432: PPUSH
127433: PPUSH
// if not unit in minersList then
127434: LD_VAR 0 1
127438: PUSH
127439: LD_EXP 211
127443: IN
127444: NOT
127445: IFFALSE 127449
// exit ;
127447: GO 127841
// index := GetElementIndex ( minersList , unit ) ;
127449: LD_ADDR_VAR 0 6
127453: PUSH
127454: LD_EXP 211
127458: PPUSH
127459: LD_VAR 0 1
127463: PPUSH
127464: CALL 72251 0 2
127468: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127469: LD_ADDR_VAR 0 5
127473: PUSH
127474: DOUBLE
127475: LD_EXP 212
127479: PUSH
127480: LD_VAR 0 6
127484: ARRAY
127485: INC
127486: ST_TO_ADDR
127487: LD_INT 1
127489: PUSH
127490: FOR_DOWNTO
127491: IFFALSE 127652
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127493: LD_EXP 212
127497: PUSH
127498: LD_VAR 0 6
127502: ARRAY
127503: PUSH
127504: LD_VAR 0 5
127508: ARRAY
127509: PUSH
127510: LD_INT 1
127512: ARRAY
127513: PUSH
127514: LD_VAR 0 2
127518: EQUAL
127519: PUSH
127520: LD_EXP 212
127524: PUSH
127525: LD_VAR 0 6
127529: ARRAY
127530: PUSH
127531: LD_VAR 0 5
127535: ARRAY
127536: PUSH
127537: LD_INT 2
127539: ARRAY
127540: PUSH
127541: LD_VAR 0 3
127545: EQUAL
127546: AND
127547: IFFALSE 127650
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127549: LD_EXP 212
127553: PUSH
127554: LD_VAR 0 6
127558: ARRAY
127559: PUSH
127560: LD_VAR 0 5
127564: ARRAY
127565: PUSH
127566: LD_INT 1
127568: ARRAY
127569: PPUSH
127570: LD_EXP 212
127574: PUSH
127575: LD_VAR 0 6
127579: ARRAY
127580: PUSH
127581: LD_VAR 0 5
127585: ARRAY
127586: PUSH
127587: LD_INT 2
127589: ARRAY
127590: PPUSH
127591: LD_VAR 0 1
127595: PPUSH
127596: CALL_OW 255
127600: PPUSH
127601: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127605: LD_ADDR_EXP 212
127609: PUSH
127610: LD_EXP 212
127614: PPUSH
127615: LD_VAR 0 6
127619: PPUSH
127620: LD_EXP 212
127624: PUSH
127625: LD_VAR 0 6
127629: ARRAY
127630: PPUSH
127631: LD_VAR 0 5
127635: PPUSH
127636: CALL_OW 3
127640: PPUSH
127641: CALL_OW 1
127645: ST_TO_ADDR
// exit ;
127646: POP
127647: POP
127648: GO 127841
// end ; end ;
127650: GO 127490
127652: POP
127653: POP
// for i := minerMinesList [ index ] downto 1 do
127654: LD_ADDR_VAR 0 5
127658: PUSH
127659: DOUBLE
127660: LD_EXP 212
127664: PUSH
127665: LD_VAR 0 6
127669: ARRAY
127670: INC
127671: ST_TO_ADDR
127672: LD_INT 1
127674: PUSH
127675: FOR_DOWNTO
127676: IFFALSE 127839
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127678: LD_EXP 212
127682: PUSH
127683: LD_VAR 0 6
127687: ARRAY
127688: PUSH
127689: LD_VAR 0 5
127693: ARRAY
127694: PUSH
127695: LD_INT 1
127697: ARRAY
127698: PPUSH
127699: LD_EXP 212
127703: PUSH
127704: LD_VAR 0 6
127708: ARRAY
127709: PUSH
127710: LD_VAR 0 5
127714: ARRAY
127715: PUSH
127716: LD_INT 2
127718: ARRAY
127719: PPUSH
127720: LD_VAR 0 2
127724: PPUSH
127725: LD_VAR 0 3
127729: PPUSH
127730: CALL_OW 298
127734: PUSH
127735: LD_INT 6
127737: LESS
127738: IFFALSE 127837
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127740: LD_EXP 212
127744: PUSH
127745: LD_VAR 0 6
127749: ARRAY
127750: PUSH
127751: LD_VAR 0 5
127755: ARRAY
127756: PUSH
127757: LD_INT 1
127759: ARRAY
127760: PPUSH
127761: LD_EXP 212
127765: PUSH
127766: LD_VAR 0 6
127770: ARRAY
127771: PUSH
127772: LD_VAR 0 5
127776: ARRAY
127777: PUSH
127778: LD_INT 2
127780: ARRAY
127781: PPUSH
127782: LD_VAR 0 1
127786: PPUSH
127787: CALL_OW 255
127791: PPUSH
127792: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127796: LD_ADDR_EXP 212
127800: PUSH
127801: LD_EXP 212
127805: PPUSH
127806: LD_VAR 0 6
127810: PPUSH
127811: LD_EXP 212
127815: PUSH
127816: LD_VAR 0 6
127820: ARRAY
127821: PPUSH
127822: LD_VAR 0 5
127826: PPUSH
127827: CALL_OW 3
127831: PPUSH
127832: CALL_OW 1
127836: ST_TO_ADDR
// end ; end ;
127837: GO 127675
127839: POP
127840: POP
// end ;
127841: LD_VAR 0 4
127845: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
127846: LD_INT 0
127848: PPUSH
127849: PPUSH
127850: PPUSH
127851: PPUSH
127852: PPUSH
127853: PPUSH
127854: PPUSH
127855: PPUSH
127856: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
127857: LD_VAR 0 1
127861: PPUSH
127862: CALL_OW 264
127866: PUSH
127867: LD_INT 81
127869: EQUAL
127870: NOT
127871: PUSH
127872: LD_VAR 0 1
127876: PUSH
127877: LD_EXP 211
127881: IN
127882: NOT
127883: OR
127884: IFFALSE 127888
// exit ;
127886: GO 128210
// index := GetElementIndex ( minersList , unit ) ;
127888: LD_ADDR_VAR 0 6
127892: PUSH
127893: LD_EXP 211
127897: PPUSH
127898: LD_VAR 0 1
127902: PPUSH
127903: CALL 72251 0 2
127907: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
127908: LD_ADDR_VAR 0 8
127912: PUSH
127913: LD_EXP 213
127917: PUSH
127918: LD_EXP 212
127922: PUSH
127923: LD_VAR 0 6
127927: ARRAY
127928: MINUS
127929: ST_TO_ADDR
// if not minesFreeAmount then
127930: LD_VAR 0 8
127934: NOT
127935: IFFALSE 127939
// exit ;
127937: GO 128210
// tmp := [ ] ;
127939: LD_ADDR_VAR 0 7
127943: PUSH
127944: EMPTY
127945: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
127946: LD_ADDR_VAR 0 5
127950: PUSH
127951: DOUBLE
127952: LD_INT 1
127954: DEC
127955: ST_TO_ADDR
127956: LD_VAR 0 8
127960: PUSH
127961: FOR_TO
127962: IFFALSE 128157
// begin _d := rand ( 0 , 5 ) ;
127964: LD_ADDR_VAR 0 11
127968: PUSH
127969: LD_INT 0
127971: PPUSH
127972: LD_INT 5
127974: PPUSH
127975: CALL_OW 12
127979: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
127980: LD_ADDR_VAR 0 12
127984: PUSH
127985: LD_INT 2
127987: PPUSH
127988: LD_INT 6
127990: PPUSH
127991: CALL_OW 12
127995: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
127996: LD_ADDR_VAR 0 9
128000: PUSH
128001: LD_VAR 0 2
128005: PPUSH
128006: LD_VAR 0 11
128010: PPUSH
128011: LD_VAR 0 12
128015: PPUSH
128016: CALL_OW 272
128020: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128021: LD_ADDR_VAR 0 10
128025: PUSH
128026: LD_VAR 0 3
128030: PPUSH
128031: LD_VAR 0 11
128035: PPUSH
128036: LD_VAR 0 12
128040: PPUSH
128041: CALL_OW 273
128045: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128046: LD_VAR 0 9
128050: PPUSH
128051: LD_VAR 0 10
128055: PPUSH
128056: CALL_OW 488
128060: PUSH
128061: LD_VAR 0 9
128065: PUSH
128066: LD_VAR 0 10
128070: PUSH
128071: EMPTY
128072: LIST
128073: LIST
128074: PUSH
128075: LD_VAR 0 7
128079: IN
128080: NOT
128081: AND
128082: PUSH
128083: LD_VAR 0 9
128087: PPUSH
128088: LD_VAR 0 10
128092: PPUSH
128093: CALL_OW 458
128097: NOT
128098: AND
128099: IFFALSE 128141
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128101: LD_ADDR_VAR 0 7
128105: PUSH
128106: LD_VAR 0 7
128110: PPUSH
128111: LD_VAR 0 7
128115: PUSH
128116: LD_INT 1
128118: PLUS
128119: PPUSH
128120: LD_VAR 0 9
128124: PUSH
128125: LD_VAR 0 10
128129: PUSH
128130: EMPTY
128131: LIST
128132: LIST
128133: PPUSH
128134: CALL_OW 1
128138: ST_TO_ADDR
128139: GO 128155
// i := i - 1 ;
128141: LD_ADDR_VAR 0 5
128145: PUSH
128146: LD_VAR 0 5
128150: PUSH
128151: LD_INT 1
128153: MINUS
128154: ST_TO_ADDR
// end ;
128155: GO 127961
128157: POP
128158: POP
// for i in tmp do
128159: LD_ADDR_VAR 0 5
128163: PUSH
128164: LD_VAR 0 7
128168: PUSH
128169: FOR_IN
128170: IFFALSE 128208
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128172: LD_VAR 0 1
128176: PPUSH
128177: LD_VAR 0 5
128181: PUSH
128182: LD_INT 1
128184: ARRAY
128185: PPUSH
128186: LD_VAR 0 5
128190: PUSH
128191: LD_INT 2
128193: ARRAY
128194: PPUSH
128195: CALL 127154 0 3
128199: NOT
128200: IFFALSE 128206
// exit ;
128202: POP
128203: POP
128204: GO 128210
128206: GO 128169
128208: POP
128209: POP
// end ;
128210: LD_VAR 0 4
128214: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128215: LD_INT 0
128217: PPUSH
128218: PPUSH
128219: PPUSH
128220: PPUSH
128221: PPUSH
128222: PPUSH
128223: PPUSH
// if not GetClass ( unit ) = class_sniper then
128224: LD_VAR 0 1
128228: PPUSH
128229: CALL_OW 257
128233: PUSH
128234: LD_INT 5
128236: EQUAL
128237: NOT
128238: IFFALSE 128242
// exit ;
128240: GO 128630
// dist := 8 ;
128242: LD_ADDR_VAR 0 5
128246: PUSH
128247: LD_INT 8
128249: ST_TO_ADDR
// viewRange := 12 ;
128250: LD_ADDR_VAR 0 7
128254: PUSH
128255: LD_INT 12
128257: ST_TO_ADDR
// side := GetSide ( unit ) ;
128258: LD_ADDR_VAR 0 6
128262: PUSH
128263: LD_VAR 0 1
128267: PPUSH
128268: CALL_OW 255
128272: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128273: LD_INT 61
128275: PPUSH
128276: LD_VAR 0 6
128280: PPUSH
128281: CALL_OW 321
128285: PUSH
128286: LD_INT 2
128288: EQUAL
128289: IFFALSE 128299
// viewRange := 16 ;
128291: LD_ADDR_VAR 0 7
128295: PUSH
128296: LD_INT 16
128298: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128299: LD_VAR 0 1
128303: PPUSH
128304: LD_VAR 0 2
128308: PPUSH
128309: LD_VAR 0 3
128313: PPUSH
128314: CALL_OW 297
128318: PUSH
128319: LD_VAR 0 5
128323: GREATER
128324: IFFALSE 128403
// begin ComMoveXY ( unit , x , y ) ;
128326: LD_VAR 0 1
128330: PPUSH
128331: LD_VAR 0 2
128335: PPUSH
128336: LD_VAR 0 3
128340: PPUSH
128341: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128345: LD_INT 35
128347: PPUSH
128348: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128352: LD_VAR 0 1
128356: PPUSH
128357: LD_VAR 0 2
128361: PPUSH
128362: LD_VAR 0 3
128366: PPUSH
128367: CALL 103587 0 3
128371: NOT
128372: IFFALSE 128376
// exit ;
128374: GO 128630
// until GetDistUnitXY ( unit , x , y ) < dist ;
128376: LD_VAR 0 1
128380: PPUSH
128381: LD_VAR 0 2
128385: PPUSH
128386: LD_VAR 0 3
128390: PPUSH
128391: CALL_OW 297
128395: PUSH
128396: LD_VAR 0 5
128400: LESS
128401: IFFALSE 128345
// end ; ComTurnXY ( unit , x , y ) ;
128403: LD_VAR 0 1
128407: PPUSH
128408: LD_VAR 0 2
128412: PPUSH
128413: LD_VAR 0 3
128417: PPUSH
128418: CALL_OW 118
// wait ( 5 ) ;
128422: LD_INT 5
128424: PPUSH
128425: CALL_OW 67
// _d := GetDir ( unit ) ;
128429: LD_ADDR_VAR 0 10
128433: PUSH
128434: LD_VAR 0 1
128438: PPUSH
128439: CALL_OW 254
128443: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128444: LD_ADDR_VAR 0 8
128448: PUSH
128449: LD_VAR 0 1
128453: PPUSH
128454: CALL_OW 250
128458: PPUSH
128459: LD_VAR 0 10
128463: PPUSH
128464: LD_VAR 0 5
128468: PPUSH
128469: CALL_OW 272
128473: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128474: LD_ADDR_VAR 0 9
128478: PUSH
128479: LD_VAR 0 1
128483: PPUSH
128484: CALL_OW 251
128488: PPUSH
128489: LD_VAR 0 10
128493: PPUSH
128494: LD_VAR 0 5
128498: PPUSH
128499: CALL_OW 273
128503: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128504: LD_VAR 0 8
128508: PPUSH
128509: LD_VAR 0 9
128513: PPUSH
128514: CALL_OW 488
128518: NOT
128519: IFFALSE 128523
// exit ;
128521: GO 128630
// ComAnimCustom ( unit , 1 ) ;
128523: LD_VAR 0 1
128527: PPUSH
128528: LD_INT 1
128530: PPUSH
128531: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128535: LD_VAR 0 8
128539: PPUSH
128540: LD_VAR 0 9
128544: PPUSH
128545: LD_VAR 0 6
128549: PPUSH
128550: LD_VAR 0 7
128554: PPUSH
128555: CALL_OW 330
// repeat wait ( 1 ) ;
128559: LD_INT 1
128561: PPUSH
128562: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128566: LD_VAR 0 1
128570: PPUSH
128571: CALL_OW 316
128575: PUSH
128576: LD_VAR 0 1
128580: PPUSH
128581: CALL_OW 314
128585: OR
128586: PUSH
128587: LD_VAR 0 1
128591: PPUSH
128592: CALL_OW 302
128596: NOT
128597: OR
128598: PUSH
128599: LD_VAR 0 1
128603: PPUSH
128604: CALL_OW 301
128608: OR
128609: IFFALSE 128559
// RemoveSeeing ( _x , _y , side ) ;
128611: LD_VAR 0 8
128615: PPUSH
128616: LD_VAR 0 9
128620: PPUSH
128621: LD_VAR 0 6
128625: PPUSH
128626: CALL_OW 331
// end ; end_of_file
128630: LD_VAR 0 4
128634: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128635: LD_INT 0
128637: PPUSH
128638: PPUSH
128639: PPUSH
128640: PPUSH
128641: PPUSH
128642: PPUSH
128643: PPUSH
128644: PPUSH
128645: PPUSH
128646: PPUSH
128647: PPUSH
128648: PPUSH
128649: PPUSH
128650: PPUSH
128651: PPUSH
128652: PPUSH
128653: PPUSH
128654: PPUSH
128655: PPUSH
128656: PPUSH
128657: PPUSH
128658: PPUSH
128659: PPUSH
128660: PPUSH
128661: PPUSH
128662: PPUSH
128663: PPUSH
128664: PPUSH
128665: PPUSH
128666: PPUSH
128667: PPUSH
128668: PPUSH
128669: PPUSH
128670: PPUSH
// if not list then
128671: LD_VAR 0 1
128675: NOT
128676: IFFALSE 128680
// exit ;
128678: GO 133339
// base := list [ 1 ] ;
128680: LD_ADDR_VAR 0 3
128684: PUSH
128685: LD_VAR 0 1
128689: PUSH
128690: LD_INT 1
128692: ARRAY
128693: ST_TO_ADDR
// group := list [ 2 ] ;
128694: LD_ADDR_VAR 0 4
128698: PUSH
128699: LD_VAR 0 1
128703: PUSH
128704: LD_INT 2
128706: ARRAY
128707: ST_TO_ADDR
// path := list [ 3 ] ;
128708: LD_ADDR_VAR 0 5
128712: PUSH
128713: LD_VAR 0 1
128717: PUSH
128718: LD_INT 3
128720: ARRAY
128721: ST_TO_ADDR
// flags := list [ 4 ] ;
128722: LD_ADDR_VAR 0 6
128726: PUSH
128727: LD_VAR 0 1
128731: PUSH
128732: LD_INT 4
128734: ARRAY
128735: ST_TO_ADDR
// mined := [ ] ;
128736: LD_ADDR_VAR 0 27
128740: PUSH
128741: EMPTY
128742: ST_TO_ADDR
// bombed := [ ] ;
128743: LD_ADDR_VAR 0 28
128747: PUSH
128748: EMPTY
128749: ST_TO_ADDR
// healers := [ ] ;
128750: LD_ADDR_VAR 0 31
128754: PUSH
128755: EMPTY
128756: ST_TO_ADDR
// to_heal := [ ] ;
128757: LD_ADDR_VAR 0 30
128761: PUSH
128762: EMPTY
128763: ST_TO_ADDR
// repairs := [ ] ;
128764: LD_ADDR_VAR 0 33
128768: PUSH
128769: EMPTY
128770: ST_TO_ADDR
// to_repair := [ ] ;
128771: LD_ADDR_VAR 0 32
128775: PUSH
128776: EMPTY
128777: ST_TO_ADDR
// if not group or not path then
128778: LD_VAR 0 4
128782: NOT
128783: PUSH
128784: LD_VAR 0 5
128788: NOT
128789: OR
128790: IFFALSE 128794
// exit ;
128792: GO 133339
// side := GetSide ( group [ 1 ] ) ;
128794: LD_ADDR_VAR 0 35
128798: PUSH
128799: LD_VAR 0 4
128803: PUSH
128804: LD_INT 1
128806: ARRAY
128807: PPUSH
128808: CALL_OW 255
128812: ST_TO_ADDR
// if flags then
128813: LD_VAR 0 6
128817: IFFALSE 128961
// begin f_ignore_area := flags [ 1 ] ;
128819: LD_ADDR_VAR 0 17
128823: PUSH
128824: LD_VAR 0 6
128828: PUSH
128829: LD_INT 1
128831: ARRAY
128832: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
128833: LD_ADDR_VAR 0 18
128837: PUSH
128838: LD_VAR 0 6
128842: PUSH
128843: LD_INT 2
128845: ARRAY
128846: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
128847: LD_ADDR_VAR 0 19
128851: PUSH
128852: LD_VAR 0 6
128856: PUSH
128857: LD_INT 3
128859: ARRAY
128860: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
128861: LD_ADDR_VAR 0 20
128865: PUSH
128866: LD_VAR 0 6
128870: PUSH
128871: LD_INT 4
128873: ARRAY
128874: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
128875: LD_ADDR_VAR 0 21
128879: PUSH
128880: LD_VAR 0 6
128884: PUSH
128885: LD_INT 5
128887: ARRAY
128888: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
128889: LD_ADDR_VAR 0 22
128893: PUSH
128894: LD_VAR 0 6
128898: PUSH
128899: LD_INT 6
128901: ARRAY
128902: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
128903: LD_ADDR_VAR 0 23
128907: PUSH
128908: LD_VAR 0 6
128912: PUSH
128913: LD_INT 7
128915: ARRAY
128916: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
128917: LD_ADDR_VAR 0 24
128921: PUSH
128922: LD_VAR 0 6
128926: PUSH
128927: LD_INT 8
128929: ARRAY
128930: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
128931: LD_ADDR_VAR 0 25
128935: PUSH
128936: LD_VAR 0 6
128940: PUSH
128941: LD_INT 9
128943: ARRAY
128944: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
128945: LD_ADDR_VAR 0 26
128949: PUSH
128950: LD_VAR 0 6
128954: PUSH
128955: LD_INT 10
128957: ARRAY
128958: ST_TO_ADDR
// end else
128959: GO 129041
// begin f_ignore_area := false ;
128961: LD_ADDR_VAR 0 17
128965: PUSH
128966: LD_INT 0
128968: ST_TO_ADDR
// f_capture := false ;
128969: LD_ADDR_VAR 0 18
128973: PUSH
128974: LD_INT 0
128976: ST_TO_ADDR
// f_ignore_civ := false ;
128977: LD_ADDR_VAR 0 19
128981: PUSH
128982: LD_INT 0
128984: ST_TO_ADDR
// f_murder := false ;
128985: LD_ADDR_VAR 0 20
128989: PUSH
128990: LD_INT 0
128992: ST_TO_ADDR
// f_mines := false ;
128993: LD_ADDR_VAR 0 21
128997: PUSH
128998: LD_INT 0
129000: ST_TO_ADDR
// f_repair := false ;
129001: LD_ADDR_VAR 0 22
129005: PUSH
129006: LD_INT 0
129008: ST_TO_ADDR
// f_heal := false ;
129009: LD_ADDR_VAR 0 23
129013: PUSH
129014: LD_INT 0
129016: ST_TO_ADDR
// f_spacetime := false ;
129017: LD_ADDR_VAR 0 24
129021: PUSH
129022: LD_INT 0
129024: ST_TO_ADDR
// f_attack_depot := false ;
129025: LD_ADDR_VAR 0 25
129029: PUSH
129030: LD_INT 0
129032: ST_TO_ADDR
// f_crawl := false ;
129033: LD_ADDR_VAR 0 26
129037: PUSH
129038: LD_INT 0
129040: ST_TO_ADDR
// end ; if f_heal then
129041: LD_VAR 0 23
129045: IFFALSE 129072
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129047: LD_ADDR_VAR 0 31
129051: PUSH
129052: LD_VAR 0 4
129056: PPUSH
129057: LD_INT 25
129059: PUSH
129060: LD_INT 4
129062: PUSH
129063: EMPTY
129064: LIST
129065: LIST
129066: PPUSH
129067: CALL_OW 72
129071: ST_TO_ADDR
// if f_repair then
129072: LD_VAR 0 22
129076: IFFALSE 129103
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129078: LD_ADDR_VAR 0 33
129082: PUSH
129083: LD_VAR 0 4
129087: PPUSH
129088: LD_INT 25
129090: PUSH
129091: LD_INT 3
129093: PUSH
129094: EMPTY
129095: LIST
129096: LIST
129097: PPUSH
129098: CALL_OW 72
129102: ST_TO_ADDR
// units_path := [ ] ;
129103: LD_ADDR_VAR 0 16
129107: PUSH
129108: EMPTY
129109: ST_TO_ADDR
// for i = 1 to group do
129110: LD_ADDR_VAR 0 7
129114: PUSH
129115: DOUBLE
129116: LD_INT 1
129118: DEC
129119: ST_TO_ADDR
129120: LD_VAR 0 4
129124: PUSH
129125: FOR_TO
129126: IFFALSE 129155
// units_path := Replace ( units_path , i , path ) ;
129128: LD_ADDR_VAR 0 16
129132: PUSH
129133: LD_VAR 0 16
129137: PPUSH
129138: LD_VAR 0 7
129142: PPUSH
129143: LD_VAR 0 5
129147: PPUSH
129148: CALL_OW 1
129152: ST_TO_ADDR
129153: GO 129125
129155: POP
129156: POP
// repeat for i = group downto 1 do
129157: LD_ADDR_VAR 0 7
129161: PUSH
129162: DOUBLE
129163: LD_VAR 0 4
129167: INC
129168: ST_TO_ADDR
129169: LD_INT 1
129171: PUSH
129172: FOR_DOWNTO
129173: IFFALSE 133295
// begin wait ( 5 ) ;
129175: LD_INT 5
129177: PPUSH
129178: CALL_OW 67
// tmp := [ ] ;
129182: LD_ADDR_VAR 0 14
129186: PUSH
129187: EMPTY
129188: ST_TO_ADDR
// attacking := false ;
129189: LD_ADDR_VAR 0 29
129193: PUSH
129194: LD_INT 0
129196: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129197: LD_VAR 0 4
129201: PUSH
129202: LD_VAR 0 7
129206: ARRAY
129207: PPUSH
129208: CALL_OW 301
129212: PUSH
129213: LD_VAR 0 4
129217: PUSH
129218: LD_VAR 0 7
129222: ARRAY
129223: NOT
129224: OR
129225: IFFALSE 129334
// begin if GetType ( group [ i ] ) = unit_human then
129227: LD_VAR 0 4
129231: PUSH
129232: LD_VAR 0 7
129236: ARRAY
129237: PPUSH
129238: CALL_OW 247
129242: PUSH
129243: LD_INT 1
129245: EQUAL
129246: IFFALSE 129292
// begin to_heal := to_heal diff group [ i ] ;
129248: LD_ADDR_VAR 0 30
129252: PUSH
129253: LD_VAR 0 30
129257: PUSH
129258: LD_VAR 0 4
129262: PUSH
129263: LD_VAR 0 7
129267: ARRAY
129268: DIFF
129269: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129270: LD_ADDR_VAR 0 31
129274: PUSH
129275: LD_VAR 0 31
129279: PUSH
129280: LD_VAR 0 4
129284: PUSH
129285: LD_VAR 0 7
129289: ARRAY
129290: DIFF
129291: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129292: LD_ADDR_VAR 0 4
129296: PUSH
129297: LD_VAR 0 4
129301: PPUSH
129302: LD_VAR 0 7
129306: PPUSH
129307: CALL_OW 3
129311: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129312: LD_ADDR_VAR 0 16
129316: PUSH
129317: LD_VAR 0 16
129321: PPUSH
129322: LD_VAR 0 7
129326: PPUSH
129327: CALL_OW 3
129331: ST_TO_ADDR
// continue ;
129332: GO 129172
// end ; if f_repair then
129334: LD_VAR 0 22
129338: IFFALSE 129827
// begin if GetType ( group [ i ] ) = unit_vehicle then
129340: LD_VAR 0 4
129344: PUSH
129345: LD_VAR 0 7
129349: ARRAY
129350: PPUSH
129351: CALL_OW 247
129355: PUSH
129356: LD_INT 2
129358: EQUAL
129359: IFFALSE 129549
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129361: LD_VAR 0 4
129365: PUSH
129366: LD_VAR 0 7
129370: ARRAY
129371: PPUSH
129372: CALL_OW 256
129376: PUSH
129377: LD_INT 700
129379: LESS
129380: PUSH
129381: LD_VAR 0 4
129385: PUSH
129386: LD_VAR 0 7
129390: ARRAY
129391: PUSH
129392: LD_VAR 0 32
129396: IN
129397: NOT
129398: AND
129399: IFFALSE 129423
// to_repair := to_repair union group [ i ] ;
129401: LD_ADDR_VAR 0 32
129405: PUSH
129406: LD_VAR 0 32
129410: PUSH
129411: LD_VAR 0 4
129415: PUSH
129416: LD_VAR 0 7
129420: ARRAY
129421: UNION
129422: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129423: LD_VAR 0 4
129427: PUSH
129428: LD_VAR 0 7
129432: ARRAY
129433: PPUSH
129434: CALL_OW 256
129438: PUSH
129439: LD_INT 1000
129441: EQUAL
129442: PUSH
129443: LD_VAR 0 4
129447: PUSH
129448: LD_VAR 0 7
129452: ARRAY
129453: PUSH
129454: LD_VAR 0 32
129458: IN
129459: AND
129460: IFFALSE 129484
// to_repair := to_repair diff group [ i ] ;
129462: LD_ADDR_VAR 0 32
129466: PUSH
129467: LD_VAR 0 32
129471: PUSH
129472: LD_VAR 0 4
129476: PUSH
129477: LD_VAR 0 7
129481: ARRAY
129482: DIFF
129483: ST_TO_ADDR
// if group [ i ] in to_repair then
129484: LD_VAR 0 4
129488: PUSH
129489: LD_VAR 0 7
129493: ARRAY
129494: PUSH
129495: LD_VAR 0 32
129499: IN
129500: IFFALSE 129547
// begin if not IsInArea ( group [ i ] , f_repair ) then
129502: LD_VAR 0 4
129506: PUSH
129507: LD_VAR 0 7
129511: ARRAY
129512: PPUSH
129513: LD_VAR 0 22
129517: PPUSH
129518: CALL_OW 308
129522: NOT
129523: IFFALSE 129545
// ComMoveToArea ( group [ i ] , f_repair ) ;
129525: LD_VAR 0 4
129529: PUSH
129530: LD_VAR 0 7
129534: ARRAY
129535: PPUSH
129536: LD_VAR 0 22
129540: PPUSH
129541: CALL_OW 113
// continue ;
129545: GO 129172
// end ; end else
129547: GO 129827
// if group [ i ] in repairs then
129549: LD_VAR 0 4
129553: PUSH
129554: LD_VAR 0 7
129558: ARRAY
129559: PUSH
129560: LD_VAR 0 33
129564: IN
129565: IFFALSE 129827
// begin if IsInUnit ( group [ i ] ) then
129567: LD_VAR 0 4
129571: PUSH
129572: LD_VAR 0 7
129576: ARRAY
129577: PPUSH
129578: CALL_OW 310
129582: IFFALSE 129650
// begin z := IsInUnit ( group [ i ] ) ;
129584: LD_ADDR_VAR 0 13
129588: PUSH
129589: LD_VAR 0 4
129593: PUSH
129594: LD_VAR 0 7
129598: ARRAY
129599: PPUSH
129600: CALL_OW 310
129604: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129605: LD_VAR 0 13
129609: PUSH
129610: LD_VAR 0 32
129614: IN
129615: PUSH
129616: LD_VAR 0 13
129620: PPUSH
129621: LD_VAR 0 22
129625: PPUSH
129626: CALL_OW 308
129630: AND
129631: IFFALSE 129648
// ComExitVehicle ( group [ i ] ) ;
129633: LD_VAR 0 4
129637: PUSH
129638: LD_VAR 0 7
129642: ARRAY
129643: PPUSH
129644: CALL_OW 121
// end else
129648: GO 129827
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129650: LD_ADDR_VAR 0 13
129654: PUSH
129655: LD_VAR 0 4
129659: PPUSH
129660: LD_INT 95
129662: PUSH
129663: LD_VAR 0 22
129667: PUSH
129668: EMPTY
129669: LIST
129670: LIST
129671: PUSH
129672: LD_INT 58
129674: PUSH
129675: EMPTY
129676: LIST
129677: PUSH
129678: EMPTY
129679: LIST
129680: LIST
129681: PPUSH
129682: CALL_OW 72
129686: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129687: LD_VAR 0 4
129691: PUSH
129692: LD_VAR 0 7
129696: ARRAY
129697: PPUSH
129698: CALL_OW 314
129702: NOT
129703: IFFALSE 129825
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129705: LD_ADDR_VAR 0 10
129709: PUSH
129710: LD_VAR 0 13
129714: PPUSH
129715: LD_VAR 0 4
129719: PUSH
129720: LD_VAR 0 7
129724: ARRAY
129725: PPUSH
129726: CALL_OW 74
129730: ST_TO_ADDR
// if not x then
129731: LD_VAR 0 10
129735: NOT
129736: IFFALSE 129740
// continue ;
129738: GO 129172
// if GetLives ( x ) < 1000 then
129740: LD_VAR 0 10
129744: PPUSH
129745: CALL_OW 256
129749: PUSH
129750: LD_INT 1000
129752: LESS
129753: IFFALSE 129777
// ComRepairVehicle ( group [ i ] , x ) else
129755: LD_VAR 0 4
129759: PUSH
129760: LD_VAR 0 7
129764: ARRAY
129765: PPUSH
129766: LD_VAR 0 10
129770: PPUSH
129771: CALL_OW 129
129775: GO 129825
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129777: LD_VAR 0 23
129781: PUSH
129782: LD_VAR 0 4
129786: PUSH
129787: LD_VAR 0 7
129791: ARRAY
129792: PPUSH
129793: CALL_OW 256
129797: PUSH
129798: LD_INT 1000
129800: LESS
129801: AND
129802: NOT
129803: IFFALSE 129825
// ComEnterUnit ( group [ i ] , x ) ;
129805: LD_VAR 0 4
129809: PUSH
129810: LD_VAR 0 7
129814: ARRAY
129815: PPUSH
129816: LD_VAR 0 10
129820: PPUSH
129821: CALL_OW 120
// end ; continue ;
129825: GO 129172
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
129827: LD_VAR 0 23
129831: PUSH
129832: LD_VAR 0 4
129836: PUSH
129837: LD_VAR 0 7
129841: ARRAY
129842: PPUSH
129843: CALL_OW 247
129847: PUSH
129848: LD_INT 1
129850: EQUAL
129851: AND
129852: IFFALSE 130330
// begin if group [ i ] in healers then
129854: LD_VAR 0 4
129858: PUSH
129859: LD_VAR 0 7
129863: ARRAY
129864: PUSH
129865: LD_VAR 0 31
129869: IN
129870: IFFALSE 130143
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
129872: LD_VAR 0 4
129876: PUSH
129877: LD_VAR 0 7
129881: ARRAY
129882: PPUSH
129883: LD_VAR 0 23
129887: PPUSH
129888: CALL_OW 308
129892: NOT
129893: PUSH
129894: LD_VAR 0 4
129898: PUSH
129899: LD_VAR 0 7
129903: ARRAY
129904: PPUSH
129905: CALL_OW 314
129909: NOT
129910: AND
129911: IFFALSE 129935
// ComMoveToArea ( group [ i ] , f_heal ) else
129913: LD_VAR 0 4
129917: PUSH
129918: LD_VAR 0 7
129922: ARRAY
129923: PPUSH
129924: LD_VAR 0 23
129928: PPUSH
129929: CALL_OW 113
129933: GO 130141
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
129935: LD_VAR 0 4
129939: PUSH
129940: LD_VAR 0 7
129944: ARRAY
129945: PPUSH
129946: CALL 102163 0 1
129950: PPUSH
129951: CALL_OW 256
129955: PUSH
129956: LD_INT 1000
129958: EQUAL
129959: IFFALSE 129978
// ComStop ( group [ i ] ) else
129961: LD_VAR 0 4
129965: PUSH
129966: LD_VAR 0 7
129970: ARRAY
129971: PPUSH
129972: CALL_OW 141
129976: GO 130141
// if not HasTask ( group [ i ] ) and to_heal then
129978: LD_VAR 0 4
129982: PUSH
129983: LD_VAR 0 7
129987: ARRAY
129988: PPUSH
129989: CALL_OW 314
129993: NOT
129994: PUSH
129995: LD_VAR 0 30
129999: AND
130000: IFFALSE 130141
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130002: LD_ADDR_VAR 0 13
130006: PUSH
130007: LD_VAR 0 30
130011: PPUSH
130012: LD_INT 3
130014: PUSH
130015: LD_INT 54
130017: PUSH
130018: EMPTY
130019: LIST
130020: PUSH
130021: EMPTY
130022: LIST
130023: LIST
130024: PPUSH
130025: CALL_OW 72
130029: PPUSH
130030: LD_VAR 0 4
130034: PUSH
130035: LD_VAR 0 7
130039: ARRAY
130040: PPUSH
130041: CALL_OW 74
130045: ST_TO_ADDR
// if z then
130046: LD_VAR 0 13
130050: IFFALSE 130141
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130052: LD_INT 91
130054: PUSH
130055: LD_VAR 0 13
130059: PUSH
130060: LD_INT 10
130062: PUSH
130063: EMPTY
130064: LIST
130065: LIST
130066: LIST
130067: PUSH
130068: LD_INT 81
130070: PUSH
130071: LD_VAR 0 13
130075: PPUSH
130076: CALL_OW 255
130080: PUSH
130081: EMPTY
130082: LIST
130083: LIST
130084: PUSH
130085: EMPTY
130086: LIST
130087: LIST
130088: PPUSH
130089: CALL_OW 69
130093: PUSH
130094: LD_INT 0
130096: EQUAL
130097: IFFALSE 130121
// ComHeal ( group [ i ] , z ) else
130099: LD_VAR 0 4
130103: PUSH
130104: LD_VAR 0 7
130108: ARRAY
130109: PPUSH
130110: LD_VAR 0 13
130114: PPUSH
130115: CALL_OW 128
130119: GO 130141
// ComMoveToArea ( group [ i ] , f_heal ) ;
130121: LD_VAR 0 4
130125: PUSH
130126: LD_VAR 0 7
130130: ARRAY
130131: PPUSH
130132: LD_VAR 0 23
130136: PPUSH
130137: CALL_OW 113
// end ; continue ;
130141: GO 129172
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130143: LD_VAR 0 4
130147: PUSH
130148: LD_VAR 0 7
130152: ARRAY
130153: PPUSH
130154: CALL_OW 256
130158: PUSH
130159: LD_INT 700
130161: LESS
130162: PUSH
130163: LD_VAR 0 4
130167: PUSH
130168: LD_VAR 0 7
130172: ARRAY
130173: PUSH
130174: LD_VAR 0 30
130178: IN
130179: NOT
130180: AND
130181: IFFALSE 130205
// to_heal := to_heal union group [ i ] ;
130183: LD_ADDR_VAR 0 30
130187: PUSH
130188: LD_VAR 0 30
130192: PUSH
130193: LD_VAR 0 4
130197: PUSH
130198: LD_VAR 0 7
130202: ARRAY
130203: UNION
130204: ST_TO_ADDR
// if group [ i ] in to_heal then
130205: LD_VAR 0 4
130209: PUSH
130210: LD_VAR 0 7
130214: ARRAY
130215: PUSH
130216: LD_VAR 0 30
130220: IN
130221: IFFALSE 130330
// begin if GetLives ( group [ i ] ) = 1000 then
130223: LD_VAR 0 4
130227: PUSH
130228: LD_VAR 0 7
130232: ARRAY
130233: PPUSH
130234: CALL_OW 256
130238: PUSH
130239: LD_INT 1000
130241: EQUAL
130242: IFFALSE 130268
// to_heal := to_heal diff group [ i ] else
130244: LD_ADDR_VAR 0 30
130248: PUSH
130249: LD_VAR 0 30
130253: PUSH
130254: LD_VAR 0 4
130258: PUSH
130259: LD_VAR 0 7
130263: ARRAY
130264: DIFF
130265: ST_TO_ADDR
130266: GO 130330
// begin if not IsInArea ( group [ i ] , to_heal ) then
130268: LD_VAR 0 4
130272: PUSH
130273: LD_VAR 0 7
130277: ARRAY
130278: PPUSH
130279: LD_VAR 0 30
130283: PPUSH
130284: CALL_OW 308
130288: NOT
130289: IFFALSE 130313
// ComMoveToArea ( group [ i ] , f_heal ) else
130291: LD_VAR 0 4
130295: PUSH
130296: LD_VAR 0 7
130300: ARRAY
130301: PPUSH
130302: LD_VAR 0 23
130306: PPUSH
130307: CALL_OW 113
130311: GO 130328
// ComHold ( group [ i ] ) ;
130313: LD_VAR 0 4
130317: PUSH
130318: LD_VAR 0 7
130322: ARRAY
130323: PPUSH
130324: CALL_OW 140
// continue ;
130328: GO 129172
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130330: LD_VAR 0 4
130334: PUSH
130335: LD_VAR 0 7
130339: ARRAY
130340: PPUSH
130341: LD_INT 10
130343: PPUSH
130344: CALL 99960 0 2
130348: NOT
130349: PUSH
130350: LD_VAR 0 16
130354: PUSH
130355: LD_VAR 0 7
130359: ARRAY
130360: PUSH
130361: EMPTY
130362: EQUAL
130363: NOT
130364: AND
130365: IFFALSE 130631
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130367: LD_VAR 0 4
130371: PUSH
130372: LD_VAR 0 7
130376: ARRAY
130377: PPUSH
130378: CALL_OW 262
130382: PUSH
130383: LD_INT 1
130385: PUSH
130386: LD_INT 2
130388: PUSH
130389: EMPTY
130390: LIST
130391: LIST
130392: IN
130393: IFFALSE 130434
// if GetFuel ( group [ i ] ) < 10 then
130395: LD_VAR 0 4
130399: PUSH
130400: LD_VAR 0 7
130404: ARRAY
130405: PPUSH
130406: CALL_OW 261
130410: PUSH
130411: LD_INT 10
130413: LESS
130414: IFFALSE 130434
// SetFuel ( group [ i ] , 12 ) ;
130416: LD_VAR 0 4
130420: PUSH
130421: LD_VAR 0 7
130425: ARRAY
130426: PPUSH
130427: LD_INT 12
130429: PPUSH
130430: CALL_OW 240
// if units_path [ i ] then
130434: LD_VAR 0 16
130438: PUSH
130439: LD_VAR 0 7
130443: ARRAY
130444: IFFALSE 130629
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130446: LD_VAR 0 4
130450: PUSH
130451: LD_VAR 0 7
130455: ARRAY
130456: PPUSH
130457: LD_VAR 0 16
130461: PUSH
130462: LD_VAR 0 7
130466: ARRAY
130467: PUSH
130468: LD_INT 1
130470: ARRAY
130471: PUSH
130472: LD_INT 1
130474: ARRAY
130475: PPUSH
130476: LD_VAR 0 16
130480: PUSH
130481: LD_VAR 0 7
130485: ARRAY
130486: PUSH
130487: LD_INT 1
130489: ARRAY
130490: PUSH
130491: LD_INT 2
130493: ARRAY
130494: PPUSH
130495: CALL_OW 297
130499: PUSH
130500: LD_INT 6
130502: GREATER
130503: IFFALSE 130578
// begin if not HasTask ( group [ i ] ) then
130505: LD_VAR 0 4
130509: PUSH
130510: LD_VAR 0 7
130514: ARRAY
130515: PPUSH
130516: CALL_OW 314
130520: NOT
130521: IFFALSE 130576
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130523: LD_VAR 0 4
130527: PUSH
130528: LD_VAR 0 7
130532: ARRAY
130533: PPUSH
130534: LD_VAR 0 16
130538: PUSH
130539: LD_VAR 0 7
130543: ARRAY
130544: PUSH
130545: LD_INT 1
130547: ARRAY
130548: PUSH
130549: LD_INT 1
130551: ARRAY
130552: PPUSH
130553: LD_VAR 0 16
130557: PUSH
130558: LD_VAR 0 7
130562: ARRAY
130563: PUSH
130564: LD_INT 1
130566: ARRAY
130567: PUSH
130568: LD_INT 2
130570: ARRAY
130571: PPUSH
130572: CALL_OW 114
// end else
130576: GO 130629
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130578: LD_ADDR_VAR 0 15
130582: PUSH
130583: LD_VAR 0 16
130587: PUSH
130588: LD_VAR 0 7
130592: ARRAY
130593: PPUSH
130594: LD_INT 1
130596: PPUSH
130597: CALL_OW 3
130601: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130602: LD_ADDR_VAR 0 16
130606: PUSH
130607: LD_VAR 0 16
130611: PPUSH
130612: LD_VAR 0 7
130616: PPUSH
130617: LD_VAR 0 15
130621: PPUSH
130622: CALL_OW 1
130626: ST_TO_ADDR
// continue ;
130627: GO 129172
// end ; end ; end else
130629: GO 133293
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130631: LD_ADDR_VAR 0 14
130635: PUSH
130636: LD_INT 81
130638: PUSH
130639: LD_VAR 0 4
130643: PUSH
130644: LD_VAR 0 7
130648: ARRAY
130649: PPUSH
130650: CALL_OW 255
130654: PUSH
130655: EMPTY
130656: LIST
130657: LIST
130658: PPUSH
130659: CALL_OW 69
130663: ST_TO_ADDR
// if not tmp then
130664: LD_VAR 0 14
130668: NOT
130669: IFFALSE 130673
// continue ;
130671: GO 129172
// if f_ignore_area then
130673: LD_VAR 0 17
130677: IFFALSE 130765
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130679: LD_ADDR_VAR 0 15
130683: PUSH
130684: LD_VAR 0 14
130688: PPUSH
130689: LD_INT 3
130691: PUSH
130692: LD_INT 92
130694: PUSH
130695: LD_VAR 0 17
130699: PUSH
130700: LD_INT 1
130702: ARRAY
130703: PUSH
130704: LD_VAR 0 17
130708: PUSH
130709: LD_INT 2
130711: ARRAY
130712: PUSH
130713: LD_VAR 0 17
130717: PUSH
130718: LD_INT 3
130720: ARRAY
130721: PUSH
130722: EMPTY
130723: LIST
130724: LIST
130725: LIST
130726: LIST
130727: PUSH
130728: EMPTY
130729: LIST
130730: LIST
130731: PPUSH
130732: CALL_OW 72
130736: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130737: LD_VAR 0 14
130741: PUSH
130742: LD_VAR 0 15
130746: DIFF
130747: IFFALSE 130765
// tmp := tmp diff tmp2 ;
130749: LD_ADDR_VAR 0 14
130753: PUSH
130754: LD_VAR 0 14
130758: PUSH
130759: LD_VAR 0 15
130763: DIFF
130764: ST_TO_ADDR
// end ; if not f_murder then
130765: LD_VAR 0 20
130769: NOT
130770: IFFALSE 130828
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130772: LD_ADDR_VAR 0 15
130776: PUSH
130777: LD_VAR 0 14
130781: PPUSH
130782: LD_INT 3
130784: PUSH
130785: LD_INT 50
130787: PUSH
130788: EMPTY
130789: LIST
130790: PUSH
130791: EMPTY
130792: LIST
130793: LIST
130794: PPUSH
130795: CALL_OW 72
130799: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130800: LD_VAR 0 14
130804: PUSH
130805: LD_VAR 0 15
130809: DIFF
130810: IFFALSE 130828
// tmp := tmp diff tmp2 ;
130812: LD_ADDR_VAR 0 14
130816: PUSH
130817: LD_VAR 0 14
130821: PUSH
130822: LD_VAR 0 15
130826: DIFF
130827: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
130828: LD_ADDR_VAR 0 14
130832: PUSH
130833: LD_VAR 0 4
130837: PUSH
130838: LD_VAR 0 7
130842: ARRAY
130843: PPUSH
130844: LD_VAR 0 14
130848: PPUSH
130849: LD_INT 1
130851: PPUSH
130852: LD_INT 1
130854: PPUSH
130855: CALL 72901 0 4
130859: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
130860: LD_VAR 0 4
130864: PUSH
130865: LD_VAR 0 7
130869: ARRAY
130870: PPUSH
130871: CALL_OW 257
130875: PUSH
130876: LD_INT 1
130878: EQUAL
130879: IFFALSE 131327
// begin if WantPlant ( group [ i ] ) then
130881: LD_VAR 0 4
130885: PUSH
130886: LD_VAR 0 7
130890: ARRAY
130891: PPUSH
130892: CALL 72402 0 1
130896: IFFALSE 130900
// continue ;
130898: GO 129172
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
130900: LD_VAR 0 18
130904: PUSH
130905: LD_VAR 0 4
130909: PUSH
130910: LD_VAR 0 7
130914: ARRAY
130915: PPUSH
130916: CALL_OW 310
130920: NOT
130921: AND
130922: PUSH
130923: LD_VAR 0 14
130927: PUSH
130928: LD_INT 1
130930: ARRAY
130931: PUSH
130932: LD_VAR 0 14
130936: PPUSH
130937: LD_INT 21
130939: PUSH
130940: LD_INT 2
130942: PUSH
130943: EMPTY
130944: LIST
130945: LIST
130946: PUSH
130947: LD_INT 58
130949: PUSH
130950: EMPTY
130951: LIST
130952: PUSH
130953: EMPTY
130954: LIST
130955: LIST
130956: PPUSH
130957: CALL_OW 72
130961: IN
130962: AND
130963: IFFALSE 130999
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
130965: LD_VAR 0 4
130969: PUSH
130970: LD_VAR 0 7
130974: ARRAY
130975: PPUSH
130976: LD_VAR 0 14
130980: PUSH
130981: LD_INT 1
130983: ARRAY
130984: PPUSH
130985: CALL_OW 120
// attacking := true ;
130989: LD_ADDR_VAR 0 29
130993: PUSH
130994: LD_INT 1
130996: ST_TO_ADDR
// continue ;
130997: GO 129172
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
130999: LD_VAR 0 26
131003: PUSH
131004: LD_VAR 0 4
131008: PUSH
131009: LD_VAR 0 7
131013: ARRAY
131014: PPUSH
131015: CALL_OW 257
131019: PUSH
131020: LD_INT 1
131022: EQUAL
131023: AND
131024: PUSH
131025: LD_VAR 0 4
131029: PUSH
131030: LD_VAR 0 7
131034: ARRAY
131035: PPUSH
131036: CALL_OW 256
131040: PUSH
131041: LD_INT 800
131043: LESS
131044: AND
131045: PUSH
131046: LD_VAR 0 4
131050: PUSH
131051: LD_VAR 0 7
131055: ARRAY
131056: PPUSH
131057: CALL_OW 318
131061: NOT
131062: AND
131063: IFFALSE 131080
// ComCrawl ( group [ i ] ) ;
131065: LD_VAR 0 4
131069: PUSH
131070: LD_VAR 0 7
131074: ARRAY
131075: PPUSH
131076: CALL_OW 137
// if f_mines then
131080: LD_VAR 0 21
131084: IFFALSE 131327
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131086: LD_VAR 0 14
131090: PUSH
131091: LD_INT 1
131093: ARRAY
131094: PPUSH
131095: CALL_OW 247
131099: PUSH
131100: LD_INT 3
131102: EQUAL
131103: PUSH
131104: LD_VAR 0 14
131108: PUSH
131109: LD_INT 1
131111: ARRAY
131112: PUSH
131113: LD_VAR 0 27
131117: IN
131118: NOT
131119: AND
131120: IFFALSE 131327
// begin x := GetX ( tmp [ 1 ] ) ;
131122: LD_ADDR_VAR 0 10
131126: PUSH
131127: LD_VAR 0 14
131131: PUSH
131132: LD_INT 1
131134: ARRAY
131135: PPUSH
131136: CALL_OW 250
131140: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131141: LD_ADDR_VAR 0 11
131145: PUSH
131146: LD_VAR 0 14
131150: PUSH
131151: LD_INT 1
131153: ARRAY
131154: PPUSH
131155: CALL_OW 251
131159: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131160: LD_ADDR_VAR 0 12
131164: PUSH
131165: LD_VAR 0 4
131169: PUSH
131170: LD_VAR 0 7
131174: ARRAY
131175: PPUSH
131176: CALL 100045 0 1
131180: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131181: LD_VAR 0 4
131185: PUSH
131186: LD_VAR 0 7
131190: ARRAY
131191: PPUSH
131192: LD_VAR 0 10
131196: PPUSH
131197: LD_VAR 0 11
131201: PPUSH
131202: LD_VAR 0 14
131206: PUSH
131207: LD_INT 1
131209: ARRAY
131210: PPUSH
131211: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131215: LD_VAR 0 4
131219: PUSH
131220: LD_VAR 0 7
131224: ARRAY
131225: PPUSH
131226: LD_VAR 0 10
131230: PPUSH
131231: LD_VAR 0 12
131235: PPUSH
131236: LD_INT 7
131238: PPUSH
131239: CALL_OW 272
131243: PPUSH
131244: LD_VAR 0 11
131248: PPUSH
131249: LD_VAR 0 12
131253: PPUSH
131254: LD_INT 7
131256: PPUSH
131257: CALL_OW 273
131261: PPUSH
131262: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131266: LD_VAR 0 4
131270: PUSH
131271: LD_VAR 0 7
131275: ARRAY
131276: PPUSH
131277: LD_INT 71
131279: PPUSH
131280: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131284: LD_ADDR_VAR 0 27
131288: PUSH
131289: LD_VAR 0 27
131293: PPUSH
131294: LD_VAR 0 27
131298: PUSH
131299: LD_INT 1
131301: PLUS
131302: PPUSH
131303: LD_VAR 0 14
131307: PUSH
131308: LD_INT 1
131310: ARRAY
131311: PPUSH
131312: CALL_OW 1
131316: ST_TO_ADDR
// attacking := true ;
131317: LD_ADDR_VAR 0 29
131321: PUSH
131322: LD_INT 1
131324: ST_TO_ADDR
// continue ;
131325: GO 129172
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131327: LD_VAR 0 4
131331: PUSH
131332: LD_VAR 0 7
131336: ARRAY
131337: PPUSH
131338: CALL_OW 257
131342: PUSH
131343: LD_INT 17
131345: EQUAL
131346: PUSH
131347: LD_VAR 0 4
131351: PUSH
131352: LD_VAR 0 7
131356: ARRAY
131357: PPUSH
131358: CALL_OW 110
131362: PUSH
131363: LD_INT 71
131365: EQUAL
131366: NOT
131367: AND
131368: IFFALSE 131514
// begin attacking := false ;
131370: LD_ADDR_VAR 0 29
131374: PUSH
131375: LD_INT 0
131377: ST_TO_ADDR
// k := 5 ;
131378: LD_ADDR_VAR 0 9
131382: PUSH
131383: LD_INT 5
131385: ST_TO_ADDR
// if tmp < k then
131386: LD_VAR 0 14
131390: PUSH
131391: LD_VAR 0 9
131395: LESS
131396: IFFALSE 131408
// k := tmp ;
131398: LD_ADDR_VAR 0 9
131402: PUSH
131403: LD_VAR 0 14
131407: ST_TO_ADDR
// for j = 1 to k do
131408: LD_ADDR_VAR 0 8
131412: PUSH
131413: DOUBLE
131414: LD_INT 1
131416: DEC
131417: ST_TO_ADDR
131418: LD_VAR 0 9
131422: PUSH
131423: FOR_TO
131424: IFFALSE 131512
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131426: LD_VAR 0 14
131430: PUSH
131431: LD_VAR 0 8
131435: ARRAY
131436: PUSH
131437: LD_VAR 0 14
131441: PPUSH
131442: LD_INT 58
131444: PUSH
131445: EMPTY
131446: LIST
131447: PPUSH
131448: CALL_OW 72
131452: IN
131453: NOT
131454: IFFALSE 131510
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131456: LD_VAR 0 4
131460: PUSH
131461: LD_VAR 0 7
131465: ARRAY
131466: PPUSH
131467: LD_VAR 0 14
131471: PUSH
131472: LD_VAR 0 8
131476: ARRAY
131477: PPUSH
131478: CALL_OW 115
// attacking := true ;
131482: LD_ADDR_VAR 0 29
131486: PUSH
131487: LD_INT 1
131489: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131490: LD_VAR 0 4
131494: PUSH
131495: LD_VAR 0 7
131499: ARRAY
131500: PPUSH
131501: LD_INT 71
131503: PPUSH
131504: CALL_OW 109
// continue ;
131508: GO 131423
// end ; end ;
131510: GO 131423
131512: POP
131513: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131514: LD_VAR 0 4
131518: PUSH
131519: LD_VAR 0 7
131523: ARRAY
131524: PPUSH
131525: CALL_OW 257
131529: PUSH
131530: LD_INT 8
131532: EQUAL
131533: PUSH
131534: LD_VAR 0 4
131538: PUSH
131539: LD_VAR 0 7
131543: ARRAY
131544: PPUSH
131545: CALL_OW 264
131549: PUSH
131550: LD_INT 28
131552: PUSH
131553: LD_INT 45
131555: PUSH
131556: LD_INT 7
131558: PUSH
131559: LD_INT 47
131561: PUSH
131562: EMPTY
131563: LIST
131564: LIST
131565: LIST
131566: LIST
131567: IN
131568: OR
131569: IFFALSE 131825
// begin attacking := false ;
131571: LD_ADDR_VAR 0 29
131575: PUSH
131576: LD_INT 0
131578: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131579: LD_VAR 0 14
131583: PUSH
131584: LD_INT 1
131586: ARRAY
131587: PPUSH
131588: CALL_OW 266
131592: PUSH
131593: LD_INT 32
131595: PUSH
131596: LD_INT 31
131598: PUSH
131599: LD_INT 33
131601: PUSH
131602: LD_INT 4
131604: PUSH
131605: LD_INT 5
131607: PUSH
131608: EMPTY
131609: LIST
131610: LIST
131611: LIST
131612: LIST
131613: LIST
131614: IN
131615: IFFALSE 131801
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131617: LD_ADDR_VAR 0 9
131621: PUSH
131622: LD_VAR 0 14
131626: PUSH
131627: LD_INT 1
131629: ARRAY
131630: PPUSH
131631: CALL_OW 266
131635: PPUSH
131636: LD_VAR 0 14
131640: PUSH
131641: LD_INT 1
131643: ARRAY
131644: PPUSH
131645: CALL_OW 250
131649: PPUSH
131650: LD_VAR 0 14
131654: PUSH
131655: LD_INT 1
131657: ARRAY
131658: PPUSH
131659: CALL_OW 251
131663: PPUSH
131664: LD_VAR 0 14
131668: PUSH
131669: LD_INT 1
131671: ARRAY
131672: PPUSH
131673: CALL_OW 254
131677: PPUSH
131678: LD_VAR 0 14
131682: PUSH
131683: LD_INT 1
131685: ARRAY
131686: PPUSH
131687: CALL_OW 248
131691: PPUSH
131692: LD_INT 0
131694: PPUSH
131695: CALL 81415 0 6
131699: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131700: LD_ADDR_VAR 0 8
131704: PUSH
131705: LD_VAR 0 4
131709: PUSH
131710: LD_VAR 0 7
131714: ARRAY
131715: PPUSH
131716: LD_VAR 0 9
131720: PPUSH
131721: CALL 100158 0 2
131725: ST_TO_ADDR
// if j then
131726: LD_VAR 0 8
131730: IFFALSE 131799
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131732: LD_VAR 0 8
131736: PUSH
131737: LD_INT 1
131739: ARRAY
131740: PPUSH
131741: LD_VAR 0 8
131745: PUSH
131746: LD_INT 2
131748: ARRAY
131749: PPUSH
131750: CALL_OW 488
131754: IFFALSE 131799
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131756: LD_VAR 0 4
131760: PUSH
131761: LD_VAR 0 7
131765: ARRAY
131766: PPUSH
131767: LD_VAR 0 8
131771: PUSH
131772: LD_INT 1
131774: ARRAY
131775: PPUSH
131776: LD_VAR 0 8
131780: PUSH
131781: LD_INT 2
131783: ARRAY
131784: PPUSH
131785: CALL_OW 116
// attacking := true ;
131789: LD_ADDR_VAR 0 29
131793: PUSH
131794: LD_INT 1
131796: ST_TO_ADDR
// continue ;
131797: GO 129172
// end ; end else
131799: GO 131825
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131801: LD_VAR 0 4
131805: PUSH
131806: LD_VAR 0 7
131810: ARRAY
131811: PPUSH
131812: LD_VAR 0 14
131816: PUSH
131817: LD_INT 1
131819: ARRAY
131820: PPUSH
131821: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
131825: LD_VAR 0 4
131829: PUSH
131830: LD_VAR 0 7
131834: ARRAY
131835: PPUSH
131836: CALL_OW 265
131840: PUSH
131841: LD_INT 11
131843: EQUAL
131844: IFFALSE 132122
// begin k := 10 ;
131846: LD_ADDR_VAR 0 9
131850: PUSH
131851: LD_INT 10
131853: ST_TO_ADDR
// x := 0 ;
131854: LD_ADDR_VAR 0 10
131858: PUSH
131859: LD_INT 0
131861: ST_TO_ADDR
// if tmp < k then
131862: LD_VAR 0 14
131866: PUSH
131867: LD_VAR 0 9
131871: LESS
131872: IFFALSE 131884
// k := tmp ;
131874: LD_ADDR_VAR 0 9
131878: PUSH
131879: LD_VAR 0 14
131883: ST_TO_ADDR
// for j = k downto 1 do
131884: LD_ADDR_VAR 0 8
131888: PUSH
131889: DOUBLE
131890: LD_VAR 0 9
131894: INC
131895: ST_TO_ADDR
131896: LD_INT 1
131898: PUSH
131899: FOR_DOWNTO
131900: IFFALSE 131975
// begin if GetType ( tmp [ j ] ) = unit_human then
131902: LD_VAR 0 14
131906: PUSH
131907: LD_VAR 0 8
131911: ARRAY
131912: PPUSH
131913: CALL_OW 247
131917: PUSH
131918: LD_INT 1
131920: EQUAL
131921: IFFALSE 131973
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
131923: LD_VAR 0 4
131927: PUSH
131928: LD_VAR 0 7
131932: ARRAY
131933: PPUSH
131934: LD_VAR 0 14
131938: PUSH
131939: LD_VAR 0 8
131943: ARRAY
131944: PPUSH
131945: CALL 100412 0 2
// x := tmp [ j ] ;
131949: LD_ADDR_VAR 0 10
131953: PUSH
131954: LD_VAR 0 14
131958: PUSH
131959: LD_VAR 0 8
131963: ARRAY
131964: ST_TO_ADDR
// attacking := true ;
131965: LD_ADDR_VAR 0 29
131969: PUSH
131970: LD_INT 1
131972: ST_TO_ADDR
// end ; end ;
131973: GO 131899
131975: POP
131976: POP
// if not x then
131977: LD_VAR 0 10
131981: NOT
131982: IFFALSE 132122
// begin attacking := true ;
131984: LD_ADDR_VAR 0 29
131988: PUSH
131989: LD_INT 1
131991: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
131992: LD_VAR 0 4
131996: PUSH
131997: LD_VAR 0 7
132001: ARRAY
132002: PPUSH
132003: CALL_OW 250
132007: PPUSH
132008: LD_VAR 0 4
132012: PUSH
132013: LD_VAR 0 7
132017: ARRAY
132018: PPUSH
132019: CALL_OW 251
132023: PPUSH
132024: CALL_OW 546
132028: PUSH
132029: LD_INT 2
132031: ARRAY
132032: PUSH
132033: LD_VAR 0 14
132037: PUSH
132038: LD_INT 1
132040: ARRAY
132041: PPUSH
132042: CALL_OW 250
132046: PPUSH
132047: LD_VAR 0 14
132051: PUSH
132052: LD_INT 1
132054: ARRAY
132055: PPUSH
132056: CALL_OW 251
132060: PPUSH
132061: CALL_OW 546
132065: PUSH
132066: LD_INT 2
132068: ARRAY
132069: EQUAL
132070: IFFALSE 132098
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132072: LD_VAR 0 4
132076: PUSH
132077: LD_VAR 0 7
132081: ARRAY
132082: PPUSH
132083: LD_VAR 0 14
132087: PUSH
132088: LD_INT 1
132090: ARRAY
132091: PPUSH
132092: CALL 100412 0 2
132096: GO 132122
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132098: LD_VAR 0 4
132102: PUSH
132103: LD_VAR 0 7
132107: ARRAY
132108: PPUSH
132109: LD_VAR 0 14
132113: PUSH
132114: LD_INT 1
132116: ARRAY
132117: PPUSH
132118: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132122: LD_VAR 0 4
132126: PUSH
132127: LD_VAR 0 7
132131: ARRAY
132132: PPUSH
132133: CALL_OW 264
132137: PUSH
132138: LD_INT 29
132140: EQUAL
132141: IFFALSE 132507
// begin if WantsToAttack ( group [ i ] ) in bombed then
132143: LD_VAR 0 4
132147: PUSH
132148: LD_VAR 0 7
132152: ARRAY
132153: PPUSH
132154: CALL_OW 319
132158: PUSH
132159: LD_VAR 0 28
132163: IN
132164: IFFALSE 132168
// continue ;
132166: GO 129172
// k := 8 ;
132168: LD_ADDR_VAR 0 9
132172: PUSH
132173: LD_INT 8
132175: ST_TO_ADDR
// x := 0 ;
132176: LD_ADDR_VAR 0 10
132180: PUSH
132181: LD_INT 0
132183: ST_TO_ADDR
// if tmp < k then
132184: LD_VAR 0 14
132188: PUSH
132189: LD_VAR 0 9
132193: LESS
132194: IFFALSE 132206
// k := tmp ;
132196: LD_ADDR_VAR 0 9
132200: PUSH
132201: LD_VAR 0 14
132205: ST_TO_ADDR
// for j = 1 to k do
132206: LD_ADDR_VAR 0 8
132210: PUSH
132211: DOUBLE
132212: LD_INT 1
132214: DEC
132215: ST_TO_ADDR
132216: LD_VAR 0 9
132220: PUSH
132221: FOR_TO
132222: IFFALSE 132354
// begin if GetType ( tmp [ j ] ) = unit_building then
132224: LD_VAR 0 14
132228: PUSH
132229: LD_VAR 0 8
132233: ARRAY
132234: PPUSH
132235: CALL_OW 247
132239: PUSH
132240: LD_INT 3
132242: EQUAL
132243: IFFALSE 132352
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132245: LD_VAR 0 14
132249: PUSH
132250: LD_VAR 0 8
132254: ARRAY
132255: PUSH
132256: LD_VAR 0 28
132260: IN
132261: NOT
132262: PUSH
132263: LD_VAR 0 14
132267: PUSH
132268: LD_VAR 0 8
132272: ARRAY
132273: PPUSH
132274: CALL_OW 313
132278: AND
132279: IFFALSE 132352
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132281: LD_VAR 0 4
132285: PUSH
132286: LD_VAR 0 7
132290: ARRAY
132291: PPUSH
132292: LD_VAR 0 14
132296: PUSH
132297: LD_VAR 0 8
132301: ARRAY
132302: PPUSH
132303: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132307: LD_ADDR_VAR 0 28
132311: PUSH
132312: LD_VAR 0 28
132316: PPUSH
132317: LD_VAR 0 28
132321: PUSH
132322: LD_INT 1
132324: PLUS
132325: PPUSH
132326: LD_VAR 0 14
132330: PUSH
132331: LD_VAR 0 8
132335: ARRAY
132336: PPUSH
132337: CALL_OW 1
132341: ST_TO_ADDR
// attacking := true ;
132342: LD_ADDR_VAR 0 29
132346: PUSH
132347: LD_INT 1
132349: ST_TO_ADDR
// break ;
132350: GO 132354
// end ; end ;
132352: GO 132221
132354: POP
132355: POP
// if not attacking and f_attack_depot then
132356: LD_VAR 0 29
132360: NOT
132361: PUSH
132362: LD_VAR 0 25
132366: AND
132367: IFFALSE 132462
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132369: LD_ADDR_VAR 0 13
132373: PUSH
132374: LD_VAR 0 14
132378: PPUSH
132379: LD_INT 2
132381: PUSH
132382: LD_INT 30
132384: PUSH
132385: LD_INT 0
132387: PUSH
132388: EMPTY
132389: LIST
132390: LIST
132391: PUSH
132392: LD_INT 30
132394: PUSH
132395: LD_INT 1
132397: PUSH
132398: EMPTY
132399: LIST
132400: LIST
132401: PUSH
132402: EMPTY
132403: LIST
132404: LIST
132405: LIST
132406: PPUSH
132407: CALL_OW 72
132411: ST_TO_ADDR
// if z then
132412: LD_VAR 0 13
132416: IFFALSE 132462
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132418: LD_VAR 0 4
132422: PUSH
132423: LD_VAR 0 7
132427: ARRAY
132428: PPUSH
132429: LD_VAR 0 13
132433: PPUSH
132434: LD_VAR 0 4
132438: PUSH
132439: LD_VAR 0 7
132443: ARRAY
132444: PPUSH
132445: CALL_OW 74
132449: PPUSH
132450: CALL_OW 115
// attacking := true ;
132454: LD_ADDR_VAR 0 29
132458: PUSH
132459: LD_INT 1
132461: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132462: LD_VAR 0 4
132466: PUSH
132467: LD_VAR 0 7
132471: ARRAY
132472: PPUSH
132473: CALL_OW 256
132477: PUSH
132478: LD_INT 500
132480: LESS
132481: IFFALSE 132507
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132483: LD_VAR 0 4
132487: PUSH
132488: LD_VAR 0 7
132492: ARRAY
132493: PPUSH
132494: LD_VAR 0 14
132498: PUSH
132499: LD_INT 1
132501: ARRAY
132502: PPUSH
132503: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132507: LD_VAR 0 4
132511: PUSH
132512: LD_VAR 0 7
132516: ARRAY
132517: PPUSH
132518: CALL_OW 264
132522: PUSH
132523: LD_INT 49
132525: EQUAL
132526: IFFALSE 132647
// begin if not HasTask ( group [ i ] ) then
132528: LD_VAR 0 4
132532: PUSH
132533: LD_VAR 0 7
132537: ARRAY
132538: PPUSH
132539: CALL_OW 314
132543: NOT
132544: IFFALSE 132647
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132546: LD_ADDR_VAR 0 9
132550: PUSH
132551: LD_INT 81
132553: PUSH
132554: LD_VAR 0 4
132558: PUSH
132559: LD_VAR 0 7
132563: ARRAY
132564: PPUSH
132565: CALL_OW 255
132569: PUSH
132570: EMPTY
132571: LIST
132572: LIST
132573: PPUSH
132574: CALL_OW 69
132578: PPUSH
132579: LD_VAR 0 4
132583: PUSH
132584: LD_VAR 0 7
132588: ARRAY
132589: PPUSH
132590: CALL_OW 74
132594: ST_TO_ADDR
// if k then
132595: LD_VAR 0 9
132599: IFFALSE 132647
// if GetDistUnits ( group [ i ] , k ) > 10 then
132601: LD_VAR 0 4
132605: PUSH
132606: LD_VAR 0 7
132610: ARRAY
132611: PPUSH
132612: LD_VAR 0 9
132616: PPUSH
132617: CALL_OW 296
132621: PUSH
132622: LD_INT 10
132624: GREATER
132625: IFFALSE 132647
// ComMoveUnit ( group [ i ] , k ) ;
132627: LD_VAR 0 4
132631: PUSH
132632: LD_VAR 0 7
132636: ARRAY
132637: PPUSH
132638: LD_VAR 0 9
132642: PPUSH
132643: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132647: LD_VAR 0 4
132651: PUSH
132652: LD_VAR 0 7
132656: ARRAY
132657: PPUSH
132658: CALL_OW 256
132662: PUSH
132663: LD_INT 250
132665: LESS
132666: PUSH
132667: LD_VAR 0 4
132671: PUSH
132672: LD_VAR 0 7
132676: ARRAY
132677: PUSH
132678: LD_INT 21
132680: PUSH
132681: LD_INT 2
132683: PUSH
132684: EMPTY
132685: LIST
132686: LIST
132687: PUSH
132688: LD_INT 23
132690: PUSH
132691: LD_INT 2
132693: PUSH
132694: EMPTY
132695: LIST
132696: LIST
132697: PUSH
132698: EMPTY
132699: LIST
132700: LIST
132701: PPUSH
132702: CALL_OW 69
132706: IN
132707: AND
132708: IFFALSE 132833
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132710: LD_ADDR_VAR 0 9
132714: PUSH
132715: LD_OWVAR 3
132719: PUSH
132720: LD_VAR 0 4
132724: PUSH
132725: LD_VAR 0 7
132729: ARRAY
132730: DIFF
132731: PPUSH
132732: LD_VAR 0 4
132736: PUSH
132737: LD_VAR 0 7
132741: ARRAY
132742: PPUSH
132743: CALL_OW 74
132747: ST_TO_ADDR
// if not k then
132748: LD_VAR 0 9
132752: NOT
132753: IFFALSE 132757
// continue ;
132755: GO 129172
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132757: LD_VAR 0 9
132761: PUSH
132762: LD_INT 81
132764: PUSH
132765: LD_VAR 0 4
132769: PUSH
132770: LD_VAR 0 7
132774: ARRAY
132775: PPUSH
132776: CALL_OW 255
132780: PUSH
132781: EMPTY
132782: LIST
132783: LIST
132784: PPUSH
132785: CALL_OW 69
132789: IN
132790: PUSH
132791: LD_VAR 0 9
132795: PPUSH
132796: LD_VAR 0 4
132800: PUSH
132801: LD_VAR 0 7
132805: ARRAY
132806: PPUSH
132807: CALL_OW 296
132811: PUSH
132812: LD_INT 5
132814: LESS
132815: AND
132816: IFFALSE 132833
// ComAutodestruct ( group [ i ] ) ;
132818: LD_VAR 0 4
132822: PUSH
132823: LD_VAR 0 7
132827: ARRAY
132828: PPUSH
132829: CALL 100310 0 1
// end ; if f_attack_depot then
132833: LD_VAR 0 25
132837: IFFALSE 132949
// begin k := 6 ;
132839: LD_ADDR_VAR 0 9
132843: PUSH
132844: LD_INT 6
132846: ST_TO_ADDR
// if tmp < k then
132847: LD_VAR 0 14
132851: PUSH
132852: LD_VAR 0 9
132856: LESS
132857: IFFALSE 132869
// k := tmp ;
132859: LD_ADDR_VAR 0 9
132863: PUSH
132864: LD_VAR 0 14
132868: ST_TO_ADDR
// for j = 1 to k do
132869: LD_ADDR_VAR 0 8
132873: PUSH
132874: DOUBLE
132875: LD_INT 1
132877: DEC
132878: ST_TO_ADDR
132879: LD_VAR 0 9
132883: PUSH
132884: FOR_TO
132885: IFFALSE 132947
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
132887: LD_VAR 0 8
132891: PPUSH
132892: CALL_OW 266
132896: PUSH
132897: LD_INT 0
132899: PUSH
132900: LD_INT 1
132902: PUSH
132903: EMPTY
132904: LIST
132905: LIST
132906: IN
132907: IFFALSE 132945
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132909: LD_VAR 0 4
132913: PUSH
132914: LD_VAR 0 7
132918: ARRAY
132919: PPUSH
132920: LD_VAR 0 14
132924: PUSH
132925: LD_VAR 0 8
132929: ARRAY
132930: PPUSH
132931: CALL_OW 115
// attacking := true ;
132935: LD_ADDR_VAR 0 29
132939: PUSH
132940: LD_INT 1
132942: ST_TO_ADDR
// break ;
132943: GO 132947
// end ;
132945: GO 132884
132947: POP
132948: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
132949: LD_VAR 0 4
132953: PUSH
132954: LD_VAR 0 7
132958: ARRAY
132959: PPUSH
132960: CALL_OW 302
132964: PUSH
132965: LD_VAR 0 29
132969: NOT
132970: AND
132971: IFFALSE 133293
// begin if GetTag ( group [ i ] ) = 71 then
132973: LD_VAR 0 4
132977: PUSH
132978: LD_VAR 0 7
132982: ARRAY
132983: PPUSH
132984: CALL_OW 110
132988: PUSH
132989: LD_INT 71
132991: EQUAL
132992: IFFALSE 133033
// begin if HasTask ( group [ i ] ) then
132994: LD_VAR 0 4
132998: PUSH
132999: LD_VAR 0 7
133003: ARRAY
133004: PPUSH
133005: CALL_OW 314
133009: IFFALSE 133015
// continue else
133011: GO 129172
133013: GO 133033
// SetTag ( group [ i ] , 0 ) ;
133015: LD_VAR 0 4
133019: PUSH
133020: LD_VAR 0 7
133024: ARRAY
133025: PPUSH
133026: LD_INT 0
133028: PPUSH
133029: CALL_OW 109
// end ; k := 8 ;
133033: LD_ADDR_VAR 0 9
133037: PUSH
133038: LD_INT 8
133040: ST_TO_ADDR
// x := 0 ;
133041: LD_ADDR_VAR 0 10
133045: PUSH
133046: LD_INT 0
133048: ST_TO_ADDR
// if tmp < k then
133049: LD_VAR 0 14
133053: PUSH
133054: LD_VAR 0 9
133058: LESS
133059: IFFALSE 133071
// k := tmp ;
133061: LD_ADDR_VAR 0 9
133065: PUSH
133066: LD_VAR 0 14
133070: ST_TO_ADDR
// for j = 1 to k do
133071: LD_ADDR_VAR 0 8
133075: PUSH
133076: DOUBLE
133077: LD_INT 1
133079: DEC
133080: ST_TO_ADDR
133081: LD_VAR 0 9
133085: PUSH
133086: FOR_TO
133087: IFFALSE 133185
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133089: LD_VAR 0 14
133093: PUSH
133094: LD_VAR 0 8
133098: ARRAY
133099: PPUSH
133100: CALL_OW 247
133104: PUSH
133105: LD_INT 1
133107: EQUAL
133108: PUSH
133109: LD_VAR 0 14
133113: PUSH
133114: LD_VAR 0 8
133118: ARRAY
133119: PPUSH
133120: CALL_OW 256
133124: PUSH
133125: LD_INT 250
133127: LESS
133128: PUSH
133129: LD_VAR 0 20
133133: AND
133134: PUSH
133135: LD_VAR 0 20
133139: NOT
133140: PUSH
133141: LD_VAR 0 14
133145: PUSH
133146: LD_VAR 0 8
133150: ARRAY
133151: PPUSH
133152: CALL_OW 256
133156: PUSH
133157: LD_INT 250
133159: GREATEREQUAL
133160: AND
133161: OR
133162: AND
133163: IFFALSE 133183
// begin x := tmp [ j ] ;
133165: LD_ADDR_VAR 0 10
133169: PUSH
133170: LD_VAR 0 14
133174: PUSH
133175: LD_VAR 0 8
133179: ARRAY
133180: ST_TO_ADDR
// break ;
133181: GO 133185
// end ;
133183: GO 133086
133185: POP
133186: POP
// if x then
133187: LD_VAR 0 10
133191: IFFALSE 133215
// ComAttackUnit ( group [ i ] , x ) else
133193: LD_VAR 0 4
133197: PUSH
133198: LD_VAR 0 7
133202: ARRAY
133203: PPUSH
133204: LD_VAR 0 10
133208: PPUSH
133209: CALL_OW 115
133213: GO 133239
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133215: LD_VAR 0 4
133219: PUSH
133220: LD_VAR 0 7
133224: ARRAY
133225: PPUSH
133226: LD_VAR 0 14
133230: PUSH
133231: LD_INT 1
133233: ARRAY
133234: PPUSH
133235: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133239: LD_VAR 0 4
133243: PUSH
133244: LD_VAR 0 7
133248: ARRAY
133249: PPUSH
133250: CALL_OW 314
133254: NOT
133255: IFFALSE 133293
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133257: LD_VAR 0 4
133261: PUSH
133262: LD_VAR 0 7
133266: ARRAY
133267: PPUSH
133268: LD_VAR 0 14
133272: PPUSH
133273: LD_VAR 0 4
133277: PUSH
133278: LD_VAR 0 7
133282: ARRAY
133283: PPUSH
133284: CALL_OW 74
133288: PPUSH
133289: CALL_OW 115
// end ; end ; end ;
133293: GO 129172
133295: POP
133296: POP
// wait ( 0 0$2 ) ;
133297: LD_INT 70
133299: PPUSH
133300: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133304: LD_VAR 0 4
133308: NOT
133309: PUSH
133310: LD_VAR 0 4
133314: PUSH
133315: EMPTY
133316: EQUAL
133317: OR
133318: PUSH
133319: LD_INT 81
133321: PUSH
133322: LD_VAR 0 35
133326: PUSH
133327: EMPTY
133328: LIST
133329: LIST
133330: PPUSH
133331: CALL_OW 69
133335: NOT
133336: OR
133337: IFFALSE 129157
// end ;
133339: LD_VAR 0 2
133343: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133344: LD_INT 0
133346: PPUSH
133347: PPUSH
133348: PPUSH
133349: PPUSH
133350: PPUSH
133351: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133352: LD_VAR 0 1
133356: NOT
133357: PUSH
133358: LD_EXP 99
133362: PUSH
133363: LD_VAR 0 1
133367: ARRAY
133368: NOT
133369: OR
133370: PUSH
133371: LD_VAR 0 2
133375: NOT
133376: OR
133377: IFFALSE 133381
// exit ;
133379: GO 133935
// side := mc_sides [ base ] ;
133381: LD_ADDR_VAR 0 6
133385: PUSH
133386: LD_EXP 125
133390: PUSH
133391: LD_VAR 0 1
133395: ARRAY
133396: ST_TO_ADDR
// if not side then
133397: LD_VAR 0 6
133401: NOT
133402: IFFALSE 133406
// exit ;
133404: GO 133935
// for i in solds do
133406: LD_ADDR_VAR 0 7
133410: PUSH
133411: LD_VAR 0 2
133415: PUSH
133416: FOR_IN
133417: IFFALSE 133478
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133419: LD_VAR 0 7
133423: PPUSH
133424: CALL_OW 310
133428: PPUSH
133429: CALL_OW 266
133433: PUSH
133434: LD_INT 32
133436: PUSH
133437: LD_INT 31
133439: PUSH
133440: EMPTY
133441: LIST
133442: LIST
133443: IN
133444: IFFALSE 133464
// solds := solds diff i else
133446: LD_ADDR_VAR 0 2
133450: PUSH
133451: LD_VAR 0 2
133455: PUSH
133456: LD_VAR 0 7
133460: DIFF
133461: ST_TO_ADDR
133462: GO 133476
// SetTag ( i , 18 ) ;
133464: LD_VAR 0 7
133468: PPUSH
133469: LD_INT 18
133471: PPUSH
133472: CALL_OW 109
133476: GO 133416
133478: POP
133479: POP
// if not solds then
133480: LD_VAR 0 2
133484: NOT
133485: IFFALSE 133489
// exit ;
133487: GO 133935
// repeat wait ( 0 0$2 ) ;
133489: LD_INT 70
133491: PPUSH
133492: CALL_OW 67
// enemy := mc_scan [ base ] ;
133496: LD_ADDR_VAR 0 4
133500: PUSH
133501: LD_EXP 122
133505: PUSH
133506: LD_VAR 0 1
133510: ARRAY
133511: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133512: LD_EXP 99
133516: PUSH
133517: LD_VAR 0 1
133521: ARRAY
133522: NOT
133523: PUSH
133524: LD_EXP 99
133528: PUSH
133529: LD_VAR 0 1
133533: ARRAY
133534: PUSH
133535: EMPTY
133536: EQUAL
133537: OR
133538: IFFALSE 133575
// begin for i in solds do
133540: LD_ADDR_VAR 0 7
133544: PUSH
133545: LD_VAR 0 2
133549: PUSH
133550: FOR_IN
133551: IFFALSE 133564
// ComStop ( i ) ;
133553: LD_VAR 0 7
133557: PPUSH
133558: CALL_OW 141
133562: GO 133550
133564: POP
133565: POP
// solds := [ ] ;
133566: LD_ADDR_VAR 0 2
133570: PUSH
133571: EMPTY
133572: ST_TO_ADDR
// exit ;
133573: GO 133935
// end ; for i in solds do
133575: LD_ADDR_VAR 0 7
133579: PUSH
133580: LD_VAR 0 2
133584: PUSH
133585: FOR_IN
133586: IFFALSE 133907
// begin if IsInUnit ( i ) then
133588: LD_VAR 0 7
133592: PPUSH
133593: CALL_OW 310
133597: IFFALSE 133608
// ComExitBuilding ( i ) ;
133599: LD_VAR 0 7
133603: PPUSH
133604: CALL_OW 122
// if GetLives ( i ) > 500 then
133608: LD_VAR 0 7
133612: PPUSH
133613: CALL_OW 256
133617: PUSH
133618: LD_INT 500
133620: GREATER
133621: IFFALSE 133674
// begin e := NearestUnitToUnit ( enemy , i ) ;
133623: LD_ADDR_VAR 0 5
133627: PUSH
133628: LD_VAR 0 4
133632: PPUSH
133633: LD_VAR 0 7
133637: PPUSH
133638: CALL_OW 74
133642: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133643: LD_VAR 0 7
133647: PPUSH
133648: LD_VAR 0 5
133652: PPUSH
133653: CALL_OW 250
133657: PPUSH
133658: LD_VAR 0 5
133662: PPUSH
133663: CALL_OW 251
133667: PPUSH
133668: CALL_OW 114
// end else
133672: GO 133905
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133674: LD_VAR 0 7
133678: PPUSH
133679: LD_EXP 99
133683: PUSH
133684: LD_VAR 0 1
133688: ARRAY
133689: PPUSH
133690: LD_INT 2
133692: PUSH
133693: LD_INT 30
133695: PUSH
133696: LD_INT 0
133698: PUSH
133699: EMPTY
133700: LIST
133701: LIST
133702: PUSH
133703: LD_INT 30
133705: PUSH
133706: LD_INT 1
133708: PUSH
133709: EMPTY
133710: LIST
133711: LIST
133712: PUSH
133713: LD_INT 30
133715: PUSH
133716: LD_INT 6
133718: PUSH
133719: EMPTY
133720: LIST
133721: LIST
133722: PUSH
133723: EMPTY
133724: LIST
133725: LIST
133726: LIST
133727: LIST
133728: PPUSH
133729: CALL_OW 72
133733: PPUSH
133734: LD_VAR 0 7
133738: PPUSH
133739: CALL_OW 74
133743: PPUSH
133744: CALL_OW 296
133748: PUSH
133749: LD_INT 10
133751: GREATER
133752: IFFALSE 133905
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133754: LD_ADDR_VAR 0 8
133758: PUSH
133759: LD_EXP 99
133763: PUSH
133764: LD_VAR 0 1
133768: ARRAY
133769: PPUSH
133770: LD_INT 2
133772: PUSH
133773: LD_INT 30
133775: PUSH
133776: LD_INT 0
133778: PUSH
133779: EMPTY
133780: LIST
133781: LIST
133782: PUSH
133783: LD_INT 30
133785: PUSH
133786: LD_INT 1
133788: PUSH
133789: EMPTY
133790: LIST
133791: LIST
133792: PUSH
133793: LD_INT 30
133795: PUSH
133796: LD_INT 6
133798: PUSH
133799: EMPTY
133800: LIST
133801: LIST
133802: PUSH
133803: EMPTY
133804: LIST
133805: LIST
133806: LIST
133807: LIST
133808: PPUSH
133809: CALL_OW 72
133813: PPUSH
133814: LD_VAR 0 7
133818: PPUSH
133819: CALL_OW 74
133823: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
133824: LD_VAR 0 7
133828: PPUSH
133829: LD_VAR 0 8
133833: PPUSH
133834: CALL_OW 250
133838: PPUSH
133839: LD_INT 3
133841: PPUSH
133842: LD_INT 5
133844: PPUSH
133845: CALL_OW 272
133849: PPUSH
133850: LD_VAR 0 8
133854: PPUSH
133855: CALL_OW 251
133859: PPUSH
133860: LD_INT 3
133862: PPUSH
133863: LD_INT 5
133865: PPUSH
133866: CALL_OW 273
133870: PPUSH
133871: CALL_OW 111
// SetTag ( i , 0 ) ;
133875: LD_VAR 0 7
133879: PPUSH
133880: LD_INT 0
133882: PPUSH
133883: CALL_OW 109
// solds := solds diff i ;
133887: LD_ADDR_VAR 0 2
133891: PUSH
133892: LD_VAR 0 2
133896: PUSH
133897: LD_VAR 0 7
133901: DIFF
133902: ST_TO_ADDR
// continue ;
133903: GO 133585
// end ; end ;
133905: GO 133585
133907: POP
133908: POP
// until not solds or not enemy ;
133909: LD_VAR 0 2
133913: NOT
133914: PUSH
133915: LD_VAR 0 4
133919: NOT
133920: OR
133921: IFFALSE 133489
// MC_Reset ( base , 18 ) ;
133923: LD_VAR 0 1
133927: PPUSH
133928: LD_INT 18
133930: PPUSH
133931: CALL 40826 0 2
// end ;
133935: LD_VAR 0 3
133939: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
133940: LD_INT 0
133942: PPUSH
133943: PPUSH
133944: PPUSH
133945: PPUSH
133946: PPUSH
133947: PPUSH
133948: PPUSH
133949: PPUSH
133950: PPUSH
133951: PPUSH
133952: PPUSH
133953: PPUSH
133954: PPUSH
133955: PPUSH
133956: PPUSH
133957: PPUSH
133958: PPUSH
133959: PPUSH
133960: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
133961: LD_ADDR_VAR 0 12
133965: PUSH
133966: LD_EXP 99
133970: PUSH
133971: LD_VAR 0 1
133975: ARRAY
133976: PPUSH
133977: LD_INT 25
133979: PUSH
133980: LD_INT 3
133982: PUSH
133983: EMPTY
133984: LIST
133985: LIST
133986: PPUSH
133987: CALL_OW 72
133991: ST_TO_ADDR
// if mc_remote_driver [ base ] then
133992: LD_EXP 139
133996: PUSH
133997: LD_VAR 0 1
134001: ARRAY
134002: IFFALSE 134026
// mechs := mechs diff mc_remote_driver [ base ] ;
134004: LD_ADDR_VAR 0 12
134008: PUSH
134009: LD_VAR 0 12
134013: PUSH
134014: LD_EXP 139
134018: PUSH
134019: LD_VAR 0 1
134023: ARRAY
134024: DIFF
134025: ST_TO_ADDR
// for i in mechs do
134026: LD_ADDR_VAR 0 4
134030: PUSH
134031: LD_VAR 0 12
134035: PUSH
134036: FOR_IN
134037: IFFALSE 134072
// if GetTag ( i ) > 0 then
134039: LD_VAR 0 4
134043: PPUSH
134044: CALL_OW 110
134048: PUSH
134049: LD_INT 0
134051: GREATER
134052: IFFALSE 134070
// mechs := mechs diff i ;
134054: LD_ADDR_VAR 0 12
134058: PUSH
134059: LD_VAR 0 12
134063: PUSH
134064: LD_VAR 0 4
134068: DIFF
134069: ST_TO_ADDR
134070: GO 134036
134072: POP
134073: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134074: LD_ADDR_VAR 0 8
134078: PUSH
134079: LD_EXP 99
134083: PUSH
134084: LD_VAR 0 1
134088: ARRAY
134089: PPUSH
134090: LD_INT 2
134092: PUSH
134093: LD_INT 25
134095: PUSH
134096: LD_INT 1
134098: PUSH
134099: EMPTY
134100: LIST
134101: LIST
134102: PUSH
134103: LD_INT 25
134105: PUSH
134106: LD_INT 5
134108: PUSH
134109: EMPTY
134110: LIST
134111: LIST
134112: PUSH
134113: LD_INT 25
134115: PUSH
134116: LD_INT 8
134118: PUSH
134119: EMPTY
134120: LIST
134121: LIST
134122: PUSH
134123: LD_INT 25
134125: PUSH
134126: LD_INT 9
134128: PUSH
134129: EMPTY
134130: LIST
134131: LIST
134132: PUSH
134133: EMPTY
134134: LIST
134135: LIST
134136: LIST
134137: LIST
134138: LIST
134139: PPUSH
134140: CALL_OW 72
134144: ST_TO_ADDR
// if not defenders and not solds then
134145: LD_VAR 0 2
134149: NOT
134150: PUSH
134151: LD_VAR 0 8
134155: NOT
134156: AND
134157: IFFALSE 134161
// exit ;
134159: GO 135931
// depot_under_attack := false ;
134161: LD_ADDR_VAR 0 16
134165: PUSH
134166: LD_INT 0
134168: ST_TO_ADDR
// sold_defenders := [ ] ;
134169: LD_ADDR_VAR 0 17
134173: PUSH
134174: EMPTY
134175: ST_TO_ADDR
// if mechs then
134176: LD_VAR 0 12
134180: IFFALSE 134333
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134182: LD_ADDR_VAR 0 4
134186: PUSH
134187: LD_VAR 0 2
134191: PPUSH
134192: LD_INT 21
134194: PUSH
134195: LD_INT 2
134197: PUSH
134198: EMPTY
134199: LIST
134200: LIST
134201: PPUSH
134202: CALL_OW 72
134206: PUSH
134207: FOR_IN
134208: IFFALSE 134331
// begin if GetTag ( i ) <> 20 then
134210: LD_VAR 0 4
134214: PPUSH
134215: CALL_OW 110
134219: PUSH
134220: LD_INT 20
134222: NONEQUAL
134223: IFFALSE 134237
// SetTag ( i , 20 ) ;
134225: LD_VAR 0 4
134229: PPUSH
134230: LD_INT 20
134232: PPUSH
134233: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134237: LD_VAR 0 4
134241: PPUSH
134242: CALL_OW 263
134246: PUSH
134247: LD_INT 1
134249: EQUAL
134250: PUSH
134251: LD_VAR 0 4
134255: PPUSH
134256: CALL_OW 311
134260: NOT
134261: AND
134262: IFFALSE 134329
// begin un := mechs [ 1 ] ;
134264: LD_ADDR_VAR 0 10
134268: PUSH
134269: LD_VAR 0 12
134273: PUSH
134274: LD_INT 1
134276: ARRAY
134277: ST_TO_ADDR
// ComExit ( un ) ;
134278: LD_VAR 0 10
134282: PPUSH
134283: CALL 105176 0 1
// AddComEnterUnit ( un , i ) ;
134287: LD_VAR 0 10
134291: PPUSH
134292: LD_VAR 0 4
134296: PPUSH
134297: CALL_OW 180
// SetTag ( un , 19 ) ;
134301: LD_VAR 0 10
134305: PPUSH
134306: LD_INT 19
134308: PPUSH
134309: CALL_OW 109
// mechs := mechs diff un ;
134313: LD_ADDR_VAR 0 12
134317: PUSH
134318: LD_VAR 0 12
134322: PUSH
134323: LD_VAR 0 10
134327: DIFF
134328: ST_TO_ADDR
// end ; end ;
134329: GO 134207
134331: POP
134332: POP
// if solds then
134333: LD_VAR 0 8
134337: IFFALSE 134396
// for i in solds do
134339: LD_ADDR_VAR 0 4
134343: PUSH
134344: LD_VAR 0 8
134348: PUSH
134349: FOR_IN
134350: IFFALSE 134394
// if not GetTag ( i ) then
134352: LD_VAR 0 4
134356: PPUSH
134357: CALL_OW 110
134361: NOT
134362: IFFALSE 134392
// begin defenders := defenders union i ;
134364: LD_ADDR_VAR 0 2
134368: PUSH
134369: LD_VAR 0 2
134373: PUSH
134374: LD_VAR 0 4
134378: UNION
134379: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134380: LD_VAR 0 4
134384: PPUSH
134385: LD_INT 18
134387: PPUSH
134388: CALL_OW 109
// end ;
134392: GO 134349
134394: POP
134395: POP
// repeat wait ( 0 0$2 ) ;
134396: LD_INT 70
134398: PPUSH
134399: CALL_OW 67
// enemy := mc_scan [ base ] ;
134403: LD_ADDR_VAR 0 21
134407: PUSH
134408: LD_EXP 122
134412: PUSH
134413: LD_VAR 0 1
134417: ARRAY
134418: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134419: LD_EXP 99
134423: PUSH
134424: LD_VAR 0 1
134428: ARRAY
134429: NOT
134430: PUSH
134431: LD_EXP 99
134435: PUSH
134436: LD_VAR 0 1
134440: ARRAY
134441: PUSH
134442: EMPTY
134443: EQUAL
134444: OR
134445: IFFALSE 134482
// begin for i in defenders do
134447: LD_ADDR_VAR 0 4
134451: PUSH
134452: LD_VAR 0 2
134456: PUSH
134457: FOR_IN
134458: IFFALSE 134471
// ComStop ( i ) ;
134460: LD_VAR 0 4
134464: PPUSH
134465: CALL_OW 141
134469: GO 134457
134471: POP
134472: POP
// defenders := [ ] ;
134473: LD_ADDR_VAR 0 2
134477: PUSH
134478: EMPTY
134479: ST_TO_ADDR
// exit ;
134480: GO 135931
// end ; for i in defenders do
134482: LD_ADDR_VAR 0 4
134486: PUSH
134487: LD_VAR 0 2
134491: PUSH
134492: FOR_IN
134493: IFFALSE 135391
// begin e := NearestUnitToUnit ( enemy , i ) ;
134495: LD_ADDR_VAR 0 13
134499: PUSH
134500: LD_VAR 0 21
134504: PPUSH
134505: LD_VAR 0 4
134509: PPUSH
134510: CALL_OW 74
134514: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134515: LD_ADDR_VAR 0 7
134519: PUSH
134520: LD_EXP 99
134524: PUSH
134525: LD_VAR 0 1
134529: ARRAY
134530: PPUSH
134531: LD_INT 2
134533: PUSH
134534: LD_INT 30
134536: PUSH
134537: LD_INT 0
134539: PUSH
134540: EMPTY
134541: LIST
134542: LIST
134543: PUSH
134544: LD_INT 30
134546: PUSH
134547: LD_INT 1
134549: PUSH
134550: EMPTY
134551: LIST
134552: LIST
134553: PUSH
134554: EMPTY
134555: LIST
134556: LIST
134557: LIST
134558: PPUSH
134559: CALL_OW 72
134563: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134564: LD_ADDR_VAR 0 16
134568: PUSH
134569: LD_VAR 0 7
134573: NOT
134574: PUSH
134575: LD_VAR 0 7
134579: PPUSH
134580: LD_INT 3
134582: PUSH
134583: LD_INT 24
134585: PUSH
134586: LD_INT 600
134588: PUSH
134589: EMPTY
134590: LIST
134591: LIST
134592: PUSH
134593: EMPTY
134594: LIST
134595: LIST
134596: PPUSH
134597: CALL_OW 72
134601: OR
134602: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134603: LD_VAR 0 4
134607: PPUSH
134608: CALL_OW 247
134612: PUSH
134613: LD_INT 2
134615: DOUBLE
134616: EQUAL
134617: IFTRUE 134621
134619: GO 135017
134621: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134622: LD_VAR 0 4
134626: PPUSH
134627: CALL_OW 256
134631: PUSH
134632: LD_INT 1000
134634: EQUAL
134635: PUSH
134636: LD_VAR 0 4
134640: PPUSH
134641: LD_VAR 0 13
134645: PPUSH
134646: CALL_OW 296
134650: PUSH
134651: LD_INT 40
134653: LESS
134654: PUSH
134655: LD_VAR 0 13
134659: PPUSH
134660: LD_EXP 124
134664: PUSH
134665: LD_VAR 0 1
134669: ARRAY
134670: PPUSH
134671: CALL_OW 308
134675: OR
134676: AND
134677: IFFALSE 134799
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134679: LD_VAR 0 4
134683: PPUSH
134684: CALL_OW 262
134688: PUSH
134689: LD_INT 1
134691: EQUAL
134692: PUSH
134693: LD_VAR 0 4
134697: PPUSH
134698: CALL_OW 261
134702: PUSH
134703: LD_INT 30
134705: LESS
134706: AND
134707: PUSH
134708: LD_VAR 0 7
134712: AND
134713: IFFALSE 134783
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134715: LD_VAR 0 4
134719: PPUSH
134720: LD_VAR 0 7
134724: PPUSH
134725: LD_VAR 0 4
134729: PPUSH
134730: CALL_OW 74
134734: PPUSH
134735: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134739: LD_VAR 0 4
134743: PPUSH
134744: LD_VAR 0 7
134748: PPUSH
134749: LD_VAR 0 4
134753: PPUSH
134754: CALL_OW 74
134758: PPUSH
134759: CALL_OW 296
134763: PUSH
134764: LD_INT 6
134766: LESS
134767: IFFALSE 134781
// SetFuel ( i , 100 ) ;
134769: LD_VAR 0 4
134773: PPUSH
134774: LD_INT 100
134776: PPUSH
134777: CALL_OW 240
// end else
134781: GO 134797
// ComAttackUnit ( i , e ) ;
134783: LD_VAR 0 4
134787: PPUSH
134788: LD_VAR 0 13
134792: PPUSH
134793: CALL_OW 115
// end else
134797: GO 134900
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
134799: LD_VAR 0 13
134803: PPUSH
134804: LD_EXP 124
134808: PUSH
134809: LD_VAR 0 1
134813: ARRAY
134814: PPUSH
134815: CALL_OW 308
134819: NOT
134820: PUSH
134821: LD_VAR 0 4
134825: PPUSH
134826: LD_VAR 0 13
134830: PPUSH
134831: CALL_OW 296
134835: PUSH
134836: LD_INT 40
134838: GREATEREQUAL
134839: AND
134840: PUSH
134841: LD_VAR 0 4
134845: PPUSH
134846: CALL_OW 256
134850: PUSH
134851: LD_INT 650
134853: LESSEQUAL
134854: OR
134855: PUSH
134856: LD_VAR 0 4
134860: PPUSH
134861: LD_EXP 123
134865: PUSH
134866: LD_VAR 0 1
134870: ARRAY
134871: PPUSH
134872: CALL_OW 308
134876: NOT
134877: AND
134878: IFFALSE 134900
// ComMoveToArea ( i , mc_parking [ base ] ) ;
134880: LD_VAR 0 4
134884: PPUSH
134885: LD_EXP 123
134889: PUSH
134890: LD_VAR 0 1
134894: ARRAY
134895: PPUSH
134896: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
134900: LD_VAR 0 4
134904: PPUSH
134905: CALL_OW 256
134909: PUSH
134910: LD_INT 1000
134912: LESS
134913: PUSH
134914: LD_VAR 0 4
134918: PPUSH
134919: CALL_OW 263
134923: PUSH
134924: LD_INT 1
134926: EQUAL
134927: AND
134928: PUSH
134929: LD_VAR 0 4
134933: PPUSH
134934: CALL_OW 311
134938: AND
134939: PUSH
134940: LD_VAR 0 4
134944: PPUSH
134945: LD_EXP 123
134949: PUSH
134950: LD_VAR 0 1
134954: ARRAY
134955: PPUSH
134956: CALL_OW 308
134960: AND
134961: IFFALSE 135015
// begin mech := IsDrivenBy ( i ) ;
134963: LD_ADDR_VAR 0 9
134967: PUSH
134968: LD_VAR 0 4
134972: PPUSH
134973: CALL_OW 311
134977: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
134978: LD_VAR 0 9
134982: PPUSH
134983: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
134987: LD_VAR 0 9
134991: PPUSH
134992: LD_VAR 0 4
134996: PPUSH
134997: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135001: LD_VAR 0 9
135005: PPUSH
135006: LD_VAR 0 4
135010: PPUSH
135011: CALL_OW 180
// end ; end ; unit_human :
135015: GO 135362
135017: LD_INT 1
135019: DOUBLE
135020: EQUAL
135021: IFTRUE 135025
135023: GO 135361
135025: POP
// begin b := IsInUnit ( i ) ;
135026: LD_ADDR_VAR 0 18
135030: PUSH
135031: LD_VAR 0 4
135035: PPUSH
135036: CALL_OW 310
135040: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135041: LD_ADDR_VAR 0 19
135045: PUSH
135046: LD_VAR 0 18
135050: NOT
135051: PUSH
135052: LD_VAR 0 18
135056: PPUSH
135057: CALL_OW 266
135061: PUSH
135062: LD_INT 32
135064: PUSH
135065: LD_INT 31
135067: PUSH
135068: EMPTY
135069: LIST
135070: LIST
135071: IN
135072: OR
135073: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135074: LD_VAR 0 18
135078: PPUSH
135079: CALL_OW 266
135083: PUSH
135084: LD_INT 5
135086: EQUAL
135087: PUSH
135088: LD_VAR 0 4
135092: PPUSH
135093: CALL_OW 257
135097: PUSH
135098: LD_INT 1
135100: PUSH
135101: LD_INT 2
135103: PUSH
135104: LD_INT 3
135106: PUSH
135107: LD_INT 4
135109: PUSH
135110: EMPTY
135111: LIST
135112: LIST
135113: LIST
135114: LIST
135115: IN
135116: AND
135117: IFFALSE 135154
// begin class := AllowSpecClass ( i ) ;
135119: LD_ADDR_VAR 0 20
135123: PUSH
135124: LD_VAR 0 4
135128: PPUSH
135129: CALL 69115 0 1
135133: ST_TO_ADDR
// if class then
135134: LD_VAR 0 20
135138: IFFALSE 135154
// ComChangeProfession ( i , class ) ;
135140: LD_VAR 0 4
135144: PPUSH
135145: LD_VAR 0 20
135149: PPUSH
135150: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135154: LD_VAR 0 16
135158: PUSH
135159: LD_VAR 0 2
135163: PPUSH
135164: LD_INT 21
135166: PUSH
135167: LD_INT 2
135169: PUSH
135170: EMPTY
135171: LIST
135172: LIST
135173: PPUSH
135174: CALL_OW 72
135178: PUSH
135179: LD_INT 1
135181: LESSEQUAL
135182: OR
135183: PUSH
135184: LD_VAR 0 19
135188: AND
135189: PUSH
135190: LD_VAR 0 4
135194: PUSH
135195: LD_VAR 0 17
135199: IN
135200: NOT
135201: AND
135202: IFFALSE 135295
// begin if b then
135204: LD_VAR 0 18
135208: IFFALSE 135257
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135210: LD_VAR 0 18
135214: PPUSH
135215: LD_VAR 0 21
135219: PPUSH
135220: LD_VAR 0 18
135224: PPUSH
135225: CALL_OW 74
135229: PPUSH
135230: CALL_OW 296
135234: PUSH
135235: LD_INT 10
135237: LESS
135238: PUSH
135239: LD_VAR 0 18
135243: PPUSH
135244: CALL_OW 461
135248: PUSH
135249: LD_INT 7
135251: NONEQUAL
135252: AND
135253: IFFALSE 135257
// continue ;
135255: GO 134492
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135257: LD_ADDR_VAR 0 17
135261: PUSH
135262: LD_VAR 0 17
135266: PPUSH
135267: LD_VAR 0 17
135271: PUSH
135272: LD_INT 1
135274: PLUS
135275: PPUSH
135276: LD_VAR 0 4
135280: PPUSH
135281: CALL_OW 1
135285: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135286: LD_VAR 0 4
135290: PPUSH
135291: CALL_OW 122
// end ; if sold_defenders then
135295: LD_VAR 0 17
135299: IFFALSE 135359
// if i in sold_defenders then
135301: LD_VAR 0 4
135305: PUSH
135306: LD_VAR 0 17
135310: IN
135311: IFFALSE 135359
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135313: LD_VAR 0 4
135317: PPUSH
135318: CALL_OW 314
135322: NOT
135323: PUSH
135324: LD_VAR 0 4
135328: PPUSH
135329: LD_VAR 0 13
135333: PPUSH
135334: CALL_OW 296
135338: PUSH
135339: LD_INT 30
135341: LESS
135342: AND
135343: IFFALSE 135359
// ComAttackUnit ( i , e ) ;
135345: LD_VAR 0 4
135349: PPUSH
135350: LD_VAR 0 13
135354: PPUSH
135355: CALL_OW 115
// end ; end ; end ;
135359: GO 135362
135361: POP
// if IsDead ( i ) then
135362: LD_VAR 0 4
135366: PPUSH
135367: CALL_OW 301
135371: IFFALSE 135389
// defenders := defenders diff i ;
135373: LD_ADDR_VAR 0 2
135377: PUSH
135378: LD_VAR 0 2
135382: PUSH
135383: LD_VAR 0 4
135387: DIFF
135388: ST_TO_ADDR
// end ;
135389: GO 134492
135391: POP
135392: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135393: LD_VAR 0 21
135397: NOT
135398: PUSH
135399: LD_VAR 0 2
135403: NOT
135404: OR
135405: PUSH
135406: LD_EXP 99
135410: PUSH
135411: LD_VAR 0 1
135415: ARRAY
135416: NOT
135417: OR
135418: IFFALSE 134396
// MC_Reset ( base , 18 ) ;
135420: LD_VAR 0 1
135424: PPUSH
135425: LD_INT 18
135427: PPUSH
135428: CALL 40826 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135432: LD_ADDR_VAR 0 2
135436: PUSH
135437: LD_VAR 0 2
135441: PUSH
135442: LD_VAR 0 2
135446: PPUSH
135447: LD_INT 2
135449: PUSH
135450: LD_INT 25
135452: PUSH
135453: LD_INT 1
135455: PUSH
135456: EMPTY
135457: LIST
135458: LIST
135459: PUSH
135460: LD_INT 25
135462: PUSH
135463: LD_INT 5
135465: PUSH
135466: EMPTY
135467: LIST
135468: LIST
135469: PUSH
135470: LD_INT 25
135472: PUSH
135473: LD_INT 8
135475: PUSH
135476: EMPTY
135477: LIST
135478: LIST
135479: PUSH
135480: LD_INT 25
135482: PUSH
135483: LD_INT 9
135485: PUSH
135486: EMPTY
135487: LIST
135488: LIST
135489: PUSH
135490: EMPTY
135491: LIST
135492: LIST
135493: LIST
135494: LIST
135495: LIST
135496: PPUSH
135497: CALL_OW 72
135501: DIFF
135502: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135503: LD_VAR 0 21
135507: NOT
135508: PUSH
135509: LD_VAR 0 2
135513: PPUSH
135514: LD_INT 21
135516: PUSH
135517: LD_INT 2
135519: PUSH
135520: EMPTY
135521: LIST
135522: LIST
135523: PPUSH
135524: CALL_OW 72
135528: AND
135529: IFFALSE 135867
// begin tmp := FilterByTag ( defenders , 19 ) ;
135531: LD_ADDR_VAR 0 11
135535: PUSH
135536: LD_VAR 0 2
135540: PPUSH
135541: LD_INT 19
135543: PPUSH
135544: CALL 102352 0 2
135548: ST_TO_ADDR
// if tmp then
135549: LD_VAR 0 11
135553: IFFALSE 135623
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135555: LD_ADDR_VAR 0 11
135559: PUSH
135560: LD_VAR 0 11
135564: PPUSH
135565: LD_INT 25
135567: PUSH
135568: LD_INT 3
135570: PUSH
135571: EMPTY
135572: LIST
135573: LIST
135574: PPUSH
135575: CALL_OW 72
135579: ST_TO_ADDR
// if tmp then
135580: LD_VAR 0 11
135584: IFFALSE 135623
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135586: LD_ADDR_EXP 111
135590: PUSH
135591: LD_EXP 111
135595: PPUSH
135596: LD_VAR 0 1
135600: PPUSH
135601: LD_EXP 111
135605: PUSH
135606: LD_VAR 0 1
135610: ARRAY
135611: PUSH
135612: LD_VAR 0 11
135616: UNION
135617: PPUSH
135618: CALL_OW 1
135622: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135623: LD_VAR 0 1
135627: PPUSH
135628: LD_INT 19
135630: PPUSH
135631: CALL 40826 0 2
// repeat wait ( 0 0$1 ) ;
135635: LD_INT 35
135637: PPUSH
135638: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135642: LD_EXP 99
135646: PUSH
135647: LD_VAR 0 1
135651: ARRAY
135652: NOT
135653: PUSH
135654: LD_EXP 99
135658: PUSH
135659: LD_VAR 0 1
135663: ARRAY
135664: PUSH
135665: EMPTY
135666: EQUAL
135667: OR
135668: IFFALSE 135705
// begin for i in defenders do
135670: LD_ADDR_VAR 0 4
135674: PUSH
135675: LD_VAR 0 2
135679: PUSH
135680: FOR_IN
135681: IFFALSE 135694
// ComStop ( i ) ;
135683: LD_VAR 0 4
135687: PPUSH
135688: CALL_OW 141
135692: GO 135680
135694: POP
135695: POP
// defenders := [ ] ;
135696: LD_ADDR_VAR 0 2
135700: PUSH
135701: EMPTY
135702: ST_TO_ADDR
// exit ;
135703: GO 135931
// end ; for i in defenders do
135705: LD_ADDR_VAR 0 4
135709: PUSH
135710: LD_VAR 0 2
135714: PUSH
135715: FOR_IN
135716: IFFALSE 135805
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135718: LD_VAR 0 4
135722: PPUSH
135723: LD_EXP 123
135727: PUSH
135728: LD_VAR 0 1
135732: ARRAY
135733: PPUSH
135734: CALL_OW 308
135738: NOT
135739: IFFALSE 135763
// ComMoveToArea ( i , mc_parking [ base ] ) else
135741: LD_VAR 0 4
135745: PPUSH
135746: LD_EXP 123
135750: PUSH
135751: LD_VAR 0 1
135755: ARRAY
135756: PPUSH
135757: CALL_OW 113
135761: GO 135803
// if GetControl ( i ) = control_manual then
135763: LD_VAR 0 4
135767: PPUSH
135768: CALL_OW 263
135772: PUSH
135773: LD_INT 1
135775: EQUAL
135776: IFFALSE 135803
// if IsDrivenBy ( i ) then
135778: LD_VAR 0 4
135782: PPUSH
135783: CALL_OW 311
135787: IFFALSE 135803
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
135789: LD_VAR 0 4
135793: PPUSH
135794: CALL_OW 311
135798: PPUSH
135799: CALL_OW 121
// end ;
135803: GO 135715
135805: POP
135806: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
135807: LD_VAR 0 2
135811: PPUSH
135812: LD_INT 95
135814: PUSH
135815: LD_EXP 123
135819: PUSH
135820: LD_VAR 0 1
135824: ARRAY
135825: PUSH
135826: EMPTY
135827: LIST
135828: LIST
135829: PPUSH
135830: CALL_OW 72
135834: PUSH
135835: LD_VAR 0 2
135839: EQUAL
135840: PUSH
135841: LD_EXP 122
135845: PUSH
135846: LD_VAR 0 1
135850: ARRAY
135851: OR
135852: PUSH
135853: LD_EXP 99
135857: PUSH
135858: LD_VAR 0 1
135862: ARRAY
135863: NOT
135864: OR
135865: IFFALSE 135635
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
135867: LD_ADDR_EXP 121
135871: PUSH
135872: LD_EXP 121
135876: PPUSH
135877: LD_VAR 0 1
135881: PPUSH
135882: LD_VAR 0 2
135886: PPUSH
135887: LD_INT 21
135889: PUSH
135890: LD_INT 2
135892: PUSH
135893: EMPTY
135894: LIST
135895: LIST
135896: PPUSH
135897: CALL_OW 72
135901: PPUSH
135902: CALL_OW 1
135906: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
135907: LD_VAR 0 1
135911: PPUSH
135912: LD_INT 19
135914: PPUSH
135915: CALL 40826 0 2
// MC_Reset ( base , 20 ) ;
135919: LD_VAR 0 1
135923: PPUSH
135924: LD_INT 20
135926: PPUSH
135927: CALL 40826 0 2
// end ; end_of_file
135931: LD_VAR 0 3
135935: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
135936: LD_VAR 0 1
135940: PUSH
135941: LD_INT 200
135943: DOUBLE
135944: GREATEREQUAL
135945: IFFALSE 135953
135947: LD_INT 299
135949: DOUBLE
135950: LESSEQUAL
135951: IFTRUE 135955
135953: GO 135987
135955: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
135956: LD_VAR 0 1
135960: PPUSH
135961: LD_VAR 0 2
135965: PPUSH
135966: LD_VAR 0 3
135970: PPUSH
135971: LD_VAR 0 4
135975: PPUSH
135976: LD_VAR 0 5
135980: PPUSH
135981: CALL 124722 0 5
135985: GO 136064
135987: LD_INT 300
135989: DOUBLE
135990: GREATEREQUAL
135991: IFFALSE 135999
135993: LD_INT 399
135995: DOUBLE
135996: LESSEQUAL
135997: IFTRUE 136001
135999: GO 136063
136001: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136002: LD_VAR 0 1
136006: PPUSH
136007: LD_VAR 0 2
136011: PPUSH
136012: LD_VAR 0 3
136016: PPUSH
136017: LD_VAR 0 4
136021: PPUSH
136022: LD_VAR 0 5
136026: PPUSH
136027: LD_VAR 0 6
136031: PPUSH
136032: LD_VAR 0 7
136036: PPUSH
136037: LD_VAR 0 8
136041: PPUSH
136042: LD_VAR 0 9
136046: PPUSH
136047: LD_VAR 0 10
136051: PPUSH
136052: LD_VAR 0 11
136056: PPUSH
136057: CALL 121055 0 11
136061: GO 136064
136063: POP
// end ;
136064: PPOPN 11
136066: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136067: LD_VAR 0 1
136071: PPUSH
136072: LD_VAR 0 2
136076: PPUSH
136077: LD_VAR 0 3
136081: PPUSH
136082: LD_VAR 0 4
136086: PPUSH
136087: LD_VAR 0 5
136091: PPUSH
136092: CALL 124458 0 5
// end ; end_of_file
136096: PPOPN 5
136098: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136099: LD_VAR 0 1
136103: PPUSH
136104: LD_VAR 0 2
136108: PPUSH
136109: LD_VAR 0 3
136113: PPUSH
136114: LD_VAR 0 4
136118: PPUSH
136119: LD_VAR 0 5
136123: PPUSH
136124: LD_VAR 0 6
136128: PPUSH
136129: CALL 108748 0 6
// end ;
136133: PPOPN 6
136135: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136136: LD_INT 0
136138: PPUSH
// begin if not units then
136139: LD_VAR 0 1
136143: NOT
136144: IFFALSE 136148
// exit ;
136146: GO 136148
// end ;
136148: PPOPN 7
136150: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136151: CALL 108719 0 0
// end ;
136155: PPOPN 1
136157: END
