// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34941 0 0
// InitNature ;
  19: CALL 34701 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11057 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14951 0 0
// MC_Start ( ) ;
  60: CALL 37053 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 134
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 135
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59330 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59423 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58773 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58588 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59330 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59423 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58588 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58773 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59203 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58270 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59330 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59423 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 139
 955: PUSH
 956: LD_EXP 139
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58588 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59330 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59423 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58480 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59741 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58912 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59203 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59203 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59535 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58588 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59154 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64980 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 72215 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 72215 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 72215 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 72215 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 72215 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64980 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64980 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64980 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64980 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64980 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64980 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64980 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64980 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64980 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64980 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64980 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64980 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64980 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64980 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64980 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64980 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64980 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64980 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64980 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64980 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64980 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64980 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64980 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64980 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64980 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64980 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64980 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64980 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 72215 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64980 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64980 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64980 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 75624 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 110
4699: PUSH
4700: LD_EXP 110
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 60
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 62
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 72215 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 63
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 63
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 61
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 61
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 61
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 61
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 61
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 61
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 61
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 61
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 61
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 61
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 61
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 61
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58773 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58636 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 60054 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58636 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58636 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 60054 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 60054 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 129
5983: PUSH
5984: LD_EXP 129
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 129
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 72215 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 64
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 65
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7120: LD_ADDR_EXP 67
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: LD_EXP 1
7132: NOT
7133: PPUSH
7134: LD_STRING 09_
7136: PPUSH
7137: CALL 64980 0 3
7141: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7142: LD_ADDR_EXP 66
7146: PUSH
7147: LD_STRING Bystrov
7149: PPUSH
7150: CALL_OW 25
7154: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7155: LD_ADDR_EXP 68
7159: PUSH
7160: LD_STRING Gleb
7162: PPUSH
7163: CALL_OW 25
7167: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7168: LD_STRING 03_Cornel
7170: PPUSH
7171: CALL_OW 28
7175: IFFALSE 7223
// begin Bierezov := NewCharacter ( Mikhail ) ;
7177: LD_ADDR_EXP 69
7181: PUSH
7182: LD_STRING Mikhail
7184: PPUSH
7185: CALL_OW 25
7189: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 197
7197: PPUSH
7198: LD_INT 111
7200: PPUSH
7201: LD_INT 9
7203: PPUSH
7204: LD_INT 0
7206: PPUSH
7207: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7211: LD_EXP 69
7215: PPUSH
7216: LD_INT 3
7218: PPUSH
7219: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7223: LD_EXP 64
7227: PPUSH
7228: LD_INT 126
7230: PPUSH
7231: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 134
7242: PPUSH
7243: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7247: LD_EXP 67
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 66
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7289: LD_EXP 68
7293: PPUSH
7294: LD_INT 197
7296: PPUSH
7297: LD_INT 111
7299: PPUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: LD_INT 126
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_STRING zhukov
7323: PPUSH
7324: LD_INT 9
7326: PUSH
7327: LD_INT 10
7329: PUSH
7330: LD_INT 10
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: PUSH
7338: LD_OWVAR 67
7342: ARRAY
7343: PPUSH
7344: LD_INT 90000
7346: PUSH
7347: LD_INT 1000
7349: PUSH
7350: LD_INT 300
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: LD_INT 18
7360: PUSH
7361: LD_INT 8
7363: PUSH
7364: LD_INT 13
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL 75624 0 6
7380: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7381: LD_ADDR_VAR 0 4
7385: PUSH
7386: LD_INT 267
7388: PPUSH
7389: CALL_OW 274
7393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 5000
7404: PPUSH
7405: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 200
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 3
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7439: LD_ADDR_EXP 110
7443: PUSH
7444: LD_EXP 110
7448: PPUSH
7449: LD_INT 2
7451: PPUSH
7452: LD_VAR 0 5
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_VAR 0 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: LD_INT 3
7471: PUSH
7472: LD_INT 21
7474: PUSH
7475: LD_INT 2
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: UNION
7495: PUSH
7496: LD_EXP 64
7500: DIFF
7501: PPUSH
7502: CALL_OW 1
7506: ST_TO_ADDR
// behemoths := [ ] ;
7507: LD_ADDR_EXP 72
7511: PUSH
7512: EMPTY
7513: ST_TO_ADDR
// behemothBuilders := [ ] ;
7514: LD_ADDR_EXP 73
7518: PUSH
7519: EMPTY
7520: ST_TO_ADDR
// if Kovalyuk then
7521: LD_EXP 65
7525: IFFALSE 7547
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7527: LD_ADDR_EXP 73
7531: PUSH
7532: LD_EXP 73
7536: PPUSH
7537: LD_EXP 65
7541: PPUSH
7542: CALL 107970 0 2
7546: ST_TO_ADDR
// j := 3 ;
7547: LD_ADDR_VAR 0 3
7551: PUSH
7552: LD_INT 3
7554: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_INT 22
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 25
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: PUSH
7589: LD_EXP 65
7593: DIFF
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7646
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7598: LD_ADDR_EXP 73
7602: PUSH
7603: LD_EXP 73
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: CALL 107970 0 2
7617: ST_TO_ADDR
// j := j - 1 ;
7618: LD_ADDR_VAR 0 3
7622: PUSH
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 1
7630: MINUS
7631: ST_TO_ADDR
// if j = 0 then
7632: LD_VAR 0 3
7636: PUSH
7637: LD_INT 0
7639: EQUAL
7640: IFFALSE 7644
// break ;
7642: GO 7646
// end ;
7644: GO 7595
7646: POP
7647: POP
// end ;
7648: LD_VAR 0 1
7652: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
7657: PPUSH
7658: PPUSH
7659: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7660: LD_ADDR_VAR 0 4
7664: PUSH
7665: LD_INT 209
7667: PUSH
7668: LD_INT 149
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 219
7677: PUSH
7678: LD_INT 154
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 223
7687: PUSH
7688: LD_INT 149
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 232
7697: PUSH
7698: LD_INT 155
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: ST_TO_ADDR
// if not behemothBuilders then
7711: LD_EXP 73
7715: NOT
7716: IFFALSE 7720
// exit ;
7718: GO 7824
// j := 1 ;
7720: LD_ADDR_VAR 0 3
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// for i in behemothBuilders do
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_EXP 73
7737: PUSH
7738: FOR_IN
7739: IFFALSE 7822
// begin if IsInUnit ( i ) then
7741: LD_VAR 0 2
7745: PPUSH
7746: CALL_OW 310
7750: IFFALSE 7761
// ComExitBuilding ( i ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7761: LD_VAR 0 2
7765: PPUSH
7766: LD_INT 37
7768: PPUSH
7769: LD_VAR 0 4
7773: PUSH
7774: LD_VAR 0 3
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 2
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 230
// j := j + 1 ;
7806: LD_ADDR_VAR 0 3
7810: PUSH
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 1
7818: PLUS
7819: ST_TO_ADDR
// end ;
7820: GO 7738
7822: POP
7823: POP
// end ;
7824: LD_VAR 0 1
7828: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7829: LD_INT 24
7831: PPUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 37
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 70
7846: IFFALSE 7859
7848: GO 7850
7850: DISABLE
// behemothUnderConstruct := true ;
7851: LD_ADDR_EXP 26
7855: PUSH
7856: LD_INT 1
7858: ST_TO_ADDR
7859: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7860: LD_INT 3
7862: PPUSH
7863: CALL 108018 0 1
7867: PUSH
7868: LD_INT 22
7870: PUSH
7871: LD_INT 3
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 30
7880: PUSH
7881: LD_INT 37
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: AND
7898: IFFALSE 8084
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: PPUSH
7916: CALL 108018 0 1
7920: ST_TO_ADDR
// for i in tmp do
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_IN
7932: IFFALSE 8082
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_INT 9
7941: PPUSH
7942: CALL_OW 308
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 110
7956: PUSH
7957: LD_INT 2
7959: EQUAL
7960: NOT
7961: AND
7962: IFFALSE 7976
// SetTag ( i , 2 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7976: LD_INT 81
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 91
7988: PUSH
7989: LD_VAR 0 1
7993: PUSH
7994: LD_INT 12
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PPUSH
8006: CALL_OW 69
8010: NOT
8011: PUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 110
8021: PUSH
8022: LD_INT 2
8024: EQUAL
8025: NOT
8026: AND
8027: IFFALSE 8046
// ComAgressiveMove ( i , 64 , 93 ) else
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 64
8036: PPUSH
8037: LD_INT 93
8039: PPUSH
8040: CALL_OW 114
8044: GO 8080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 81
8053: PUSH
8054: LD_INT 3
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL_OW 69
8065: PPUSH
8066: LD_VAR 0 1
8070: PPUSH
8071: CALL_OW 74
8075: PPUSH
8076: CALL_OW 115
// end ;
8080: GO 7931
8082: POP
8083: POP
// end ;
8084: PPOPN 2
8086: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8087: LD_INT 0
8089: PPUSH
8090: PPUSH
8091: PPUSH
// result := [ ] ;
8092: LD_ADDR_VAR 0 2
8096: PUSH
8097: EMPTY
8098: ST_TO_ADDR
// uc_side := 6 ;
8099: LD_ADDR_OWVAR 20
8103: PUSH
8104: LD_INT 6
8106: ST_TO_ADDR
// uc_nation := 3 ;
8107: LD_ADDR_OWVAR 21
8111: PUSH
8112: LD_INT 3
8114: ST_TO_ADDR
// case strength of 1 :
8115: LD_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: DOUBLE
8123: EQUAL
8124: IFTRUE 8128
8126: GO 8266
8128: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8129: LD_ADDR_VAR 0 3
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_INT 4
8141: PUSH
8142: LD_INT 5
8144: PUSH
8145: LD_INT 6
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: PUSH
8159: FOR_TO
8160: IFFALSE 8262
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8162: LD_INT 22
8164: PUSH
8165: LD_INT 24
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_VAR 0 3
8176: PUSH
8177: LD_INT 2
8179: MOD
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: ARRAY
8185: PPUSH
8186: LD_INT 1
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: CALL_OW 12
8206: ARRAY
8207: PPUSH
8208: LD_INT 3
8210: PPUSH
8211: LD_INT 43
8213: PUSH
8214: LD_INT 44
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 1
8227: PPUSH
8228: LD_INT 3
8230: PPUSH
8231: CALL_OW 12
8235: ARRAY
8236: PPUSH
8237: LD_INT 80
8239: PPUSH
8240: CALL 72215 0 5
// result := result union CreateVehicle ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_VAR 0 2
8253: PUSH
8254: CALL_OW 45
8258: UNION
8259: ST_TO_ADDR
// end ;
8260: GO 8159
8262: POP
8263: POP
// end ; 2 :
8264: GO 9217
8266: LD_INT 2
8268: DOUBLE
8269: EQUAL
8270: IFTRUE 8274
8272: GO 8430
8274: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8275: LD_ADDR_VAR 0 3
8279: PUSH
8280: DOUBLE
8281: LD_INT 1
8283: DEC
8284: ST_TO_ADDR
8285: LD_INT 5
8287: PUSH
8288: LD_INT 6
8290: PUSH
8291: LD_INT 7
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PUSH
8299: LD_OWVAR 67
8303: ARRAY
8304: PUSH
8305: FOR_TO
8306: IFFALSE 8426
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8308: LD_INT 22
8310: PUSH
8311: LD_INT 24
8313: PUSH
8314: LD_INT 24
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_VAR 0 3
8326: PUSH
8327: LD_INT 3
8329: MOD
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ARRAY
8335: PPUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 3
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 1
8348: PPUSH
8349: LD_INT 2
8351: PPUSH
8352: CALL_OW 12
8356: ARRAY
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 43
8363: PUSH
8364: LD_INT 44
8366: PUSH
8367: LD_INT 45
8369: PUSH
8370: LD_INT 44
8372: PUSH
8373: LD_INT 46
8375: PUSH
8376: LD_INT 46
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_VAR 0 3
8391: PUSH
8392: LD_INT 6
8394: MOD
8395: PUSH
8396: LD_INT 1
8398: PLUS
8399: ARRAY
8400: PPUSH
8401: LD_INT 80
8403: PPUSH
8404: CALL 72215 0 5
// result := result union CreateVehicle ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: CALL_OW 45
8422: UNION
8423: ST_TO_ADDR
// end ;
8424: GO 8305
8426: POP
8427: POP
// end ; 3 :
8428: GO 9217
8430: LD_INT 3
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8594
8438: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 5
8451: PUSH
8452: LD_INT 7
8454: PUSH
8455: LD_INT 8
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 43
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 72215 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// end ; 4 :
8592: GO 9217
8594: LD_INT 4
8596: DOUBLE
8597: EQUAL
8598: IFTRUE 8602
8600: GO 9216
8602: POP
// begin uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8611: LD_ADDR_VAR 0 3
8615: PUSH
8616: DOUBLE
8617: LD_INT 1
8619: DEC
8620: ST_TO_ADDR
8621: LD_INT 6
8623: PUSH
8624: LD_INT 8
8626: PUSH
8627: LD_INT 9
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: FOR_TO
8642: IFFALSE 8762
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8644: LD_INT 22
8646: PUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 3
8665: MOD
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_INT 1
8674: PUSH
8675: LD_INT 3
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ARRAY
8693: PPUSH
8694: LD_INT 3
8696: PPUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 47
8702: PUSH
8703: LD_INT 47
8705: PUSH
8706: LD_INT 45
8708: PUSH
8709: LD_INT 46
8711: PUSH
8712: LD_INT 46
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: PUSH
8723: LD_VAR 0 3
8727: PUSH
8728: LD_INT 6
8730: MOD
8731: PUSH
8732: LD_INT 1
8734: PLUS
8735: ARRAY
8736: PPUSH
8737: LD_INT 80
8739: PPUSH
8740: CALL 72215 0 5
// result := result union CreateVehicle ;
8744: LD_ADDR_VAR 0 2
8748: PUSH
8749: LD_VAR 0 2
8753: PUSH
8754: CALL_OW 45
8758: UNION
8759: ST_TO_ADDR
// end ;
8760: GO 8641
8762: POP
8763: POP
// if not KappaStatus then
8764: LD_EXP 2
8768: NOT
8769: IFFALSE 9004
// begin uc_nation := 1 ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// for i = 1 to 3 do
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: DOUBLE
8785: LD_INT 1
8787: DEC
8788: ST_TO_ADDR
8789: LD_INT 3
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8929
// begin j := rand ( 0 , 1 ) ;
8795: LD_ADDR_VAR 0 4
8799: PUSH
8800: LD_INT 0
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL_OW 12
8810: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8811: LD_INT 3
8813: PUSH
8814: LD_INT 5
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 4
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 1
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 2
8862: PPUSH
8863: CALL_OW 12
8867: ARRAY
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 9
8874: PUSH
8875: LD_INT 7
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: PPUSH
8894: LD_INT 2
8896: PPUSH
8897: CALL_OW 12
8901: PLUS
8902: ARRAY
8903: PPUSH
8904: LD_INT 85
8906: PPUSH
8907: CALL 72215 0 5
// result := result union CreateVehicle ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_VAR 0 2
8920: PUSH
8921: CALL_OW 45
8925: UNION
8926: ST_TO_ADDR
// end ;
8927: GO 8792
8929: POP
8930: POP
// if vsevolodFirstAttack then
8931: LD_EXP 24
8935: IFFALSE 9002
// begin vsevolodFirstAttack := false ;
8937: LD_ADDR_EXP 24
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8945: LD_INT 5
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 6
8956: PPUSH
8957: LD_INT 100
8959: PPUSH
8960: CALL 72215 0 5
// sewiVeh := CreateVehicle ;
8964: LD_ADDR_EXP 71
8968: PUSH
8969: CALL_OW 45
8973: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8974: LD_EXP 71
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 242
// result := result union sewiVeh ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 2
8995: PUSH
8996: LD_EXP 71
9000: UNION
9001: ST_TO_ADDR
// end ; end else
9002: GO 9214
// if vsevolodFirstAttack then
9004: LD_EXP 24
9008: IFFALSE 9214
// begin vsevolodFirstAttack := false ;
9010: LD_ADDR_EXP 24
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9026: LD_ADDR_VAR 0 3
9030: PUSH
9031: DOUBLE
9032: LD_INT 1
9034: DEC
9035: ST_TO_ADDR
9036: LD_INT 2
9038: PUSH
9039: LD_OWVAR 67
9043: PLUS
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9154
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 45
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 47
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_INT 3
9122: MOD
9123: PUSH
9124: LD_INT 1
9126: PLUS
9127: ARRAY
9128: PPUSH
9129: LD_INT 80
9131: PPUSH
9132: CALL 72215 0 5
// result := result union CreateVehicle ;
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: LD_VAR 0 2
9145: PUSH
9146: CALL_OW 45
9150: UNION
9151: ST_TO_ADDR
// end ;
9152: GO 9045
9154: POP
9155: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9156: LD_INT 24
9158: PPUSH
9159: LD_INT 3
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 47
9167: PPUSH
9168: LD_INT 100
9170: PPUSH
9171: CALL 72215 0 5
// sewiVeh := CreateVehicle ;
9175: LD_ADDR_EXP 71
9179: PUSH
9180: CALL_OW 45
9184: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9185: LD_EXP 71
9189: PPUSH
9190: LD_INT 6
9192: NEG
9193: PPUSH
9194: CALL_OW 242
// result := result union sewiVeh ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: LD_EXP 71
9212: UNION
9213: ST_TO_ADDR
// end ; end ; end ;
9214: GO 9217
9216: POP
// end ;
9217: LD_VAR 0 2
9221: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9222: LD_EXP 16
9226: IFFALSE 10067
9228: GO 9230
9230: DISABLE
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9239: LD_ADDR_VAR 0 4
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 12
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9254: LD_ADDR_VAR 0 3
9258: PUSH
9259: LD_INT 11550
9261: PUSH
9262: LD_INT 10150
9264: PUSH
9265: LD_INT 9800
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_OWVAR 67
9277: ARRAY
9278: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9279: LD_ADDR_VAR 0 6
9283: PUSH
9284: LD_INT 70
9286: PUSH
9287: LD_INT 118
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 78
9296: PUSH
9297: LD_INT 31
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: ST_TO_ADDR
// repeat if missionStage = 2 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: IFFALSE 9327
// wait ( 1 1$30 ) else
9318: LD_INT 3150
9320: PPUSH
9321: CALL_OW 67
9325: GO 9336
// wait ( time ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: CALL_OW 67
// if missionStage = 6 then
9336: LD_EXP 15
9340: PUSH
9341: LD_INT 6
9343: EQUAL
9344: IFFALSE 9372
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9346: LD_INT 51
9348: PPUSH
9349: LD_INT 6
9351: PPUSH
9352: LD_INT 2
9354: PPUSH
9355: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9359: LD_INT 57
9361: PPUSH
9362: LD_INT 6
9364: PPUSH
9365: LD_INT 2
9367: PPUSH
9368: CALL_OW 322
// end ; if missionStage = 8 then
9372: LD_EXP 15
9376: PUSH
9377: LD_INT 8
9379: EQUAL
9380: IFFALSE 9408
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9382: LD_INT 52
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9395: LD_INT 58
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 10
9415: EQUAL
9416: PUSH
9417: LD_OWVAR 67
9421: PUSH
9422: LD_INT 1
9424: GREATER
9425: AND
9426: IFFALSE 9454
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9428: LD_INT 53
9430: PPUSH
9431: LD_INT 6
9433: PPUSH
9434: LD_INT 2
9436: PPUSH
9437: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9441: LD_INT 59
9443: PPUSH
9444: LD_INT 6
9446: PPUSH
9447: LD_INT 2
9449: PPUSH
9450: CALL_OW 322
// end ; if activeAttacks then
9454: LD_EXP 16
9458: IFFALSE 10061
// begin if missionStage = 2 then
9460: LD_EXP 15
9464: PUSH
9465: LD_INT 2
9467: EQUAL
9468: IFFALSE 9478
// strength := 1 ;
9470: LD_ADDR_VAR 0 5
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// if missionStage > 2 then
9478: LD_EXP 15
9482: PUSH
9483: LD_INT 2
9485: GREATER
9486: IFFALSE 9496
// strength := 2 ;
9488: LD_ADDR_VAR 0 5
9492: PUSH
9493: LD_INT 2
9495: ST_TO_ADDR
// if missionStage > 6 then
9496: LD_EXP 15
9500: PUSH
9501: LD_INT 6
9503: GREATER
9504: IFFALSE 9514
// strength := 3 ;
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: LD_INT 3
9513: ST_TO_ADDR
// if missionStage > 10 then
9514: LD_EXP 15
9518: PUSH
9519: LD_INT 10
9521: GREATER
9522: IFFALSE 9532
// strength := 4 ;
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_INT 4
9531: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9532: LD_ADDR_VAR 0 2
9536: PUSH
9537: LD_VAR 0 5
9541: PPUSH
9542: CALL 8087 0 1
9546: ST_TO_ADDR
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9741
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9560: LD_VAR 0 1
9564: PPUSH
9565: LD_VAR 0 4
9569: PUSH
9570: LD_INT 1
9572: PPUSH
9573: LD_INT 2
9575: PPUSH
9576: CALL_OW 12
9580: ARRAY
9581: PPUSH
9582: LD_INT 0
9584: PPUSH
9585: CALL_OW 49
// if i = sewiVeh then
9589: LD_VAR 0 1
9593: PUSH
9594: LD_EXP 71
9598: EQUAL
9599: IFFALSE 9636
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9601: LD_ADDR_EXP 70
9605: PUSH
9606: LD_STRING Vsevolod
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: LD_STRING 
9614: PPUSH
9615: CALL 64980 0 3
9619: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9620: LD_EXP 70
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 52
// end else
9634: GO 9717
// if GetControl ( i ) = control_manual then
9636: LD_VAR 0 1
9640: PPUSH
9641: CALL_OW 263
9645: PUSH
9646: LD_INT 1
9648: EQUAL
9649: IFFALSE 9717
// begin uc_side := 6 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 6
9658: ST_TO_ADDR
// uc_nation := 3 ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// hc_gallery :=  ;
9667: LD_ADDR_OWVAR 33
9671: PUSH
9672: LD_STRING 
9674: ST_TO_ADDR
// hc_name :=  ;
9675: LD_ADDR_OWVAR 26
9679: PUSH
9680: LD_STRING 
9682: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9683: LD_INT 0
9685: PPUSH
9686: LD_INT 3
9688: PPUSH
9689: LD_INT 10
9691: PPUSH
9692: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9696: CALL_OW 44
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9710: LD_INT 10
9712: PPUSH
9713: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: LD_INT 111
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: CALL_OW 111
// wait ( 0 0$2 ) ;
9732: LD_INT 70
9734: PPUSH
9735: CALL_OW 67
// end ;
9739: GO 9557
9741: POP
9742: POP
// repeat wait ( 0 0$1 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 10042
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9763: LD_INT 81
9765: PUSH
9766: LD_INT 6
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 91
9775: PUSH
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 12
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: IFFALSE 9855
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 81
9806: PUSH
9807: LD_INT 6
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: LD_INT 91
9816: PUSH
9817: LD_VAR 0 1
9821: PUSH
9822: LD_INT 12
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 74
9848: PPUSH
9849: CALL_OW 115
9853: GO 10040
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9855: LD_INT 9
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 6
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 70
9872: IFFALSE 10006
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_VAR 0 6
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: PPUSH
9892: LD_VAR 0 6
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PUSH
9901: LD_INT 2
9903: ARRAY
9904: PPUSH
9905: CALL_OW 297
9909: PUSH
9910: LD_INT 10
9912: GREATER
9913: PUSH
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 9
9921: PPUSH
9922: CALL_OW 308
9926: NOT
9927: AND
9928: IFFALSE 9967
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 6
9939: PUSH
9940: LD_INT 1
9942: ARRAY
9943: PUSH
9944: LD_INT 1
9946: ARRAY
9947: PPUSH
9948: LD_VAR 0 6
9952: PUSH
9953: LD_INT 1
9955: ARRAY
9956: PUSH
9957: LD_INT 2
9959: ARRAY
9960: PPUSH
9961: CALL_OW 114
9965: GO 10004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9967: LD_VAR 0 1
9971: PPUSH
9972: LD_INT 9
9974: PPUSH
9975: LD_INT 81
9977: PUSH
9978: LD_INT 6
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PPUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: CALL_OW 74
9999: PPUSH
10000: CALL_OW 115
// end else
10004: GO 10040
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: LD_INT 81
10013: PUSH
10014: LD_INT 6
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: PPUSH
10036: CALL_OW 115
// end ;
10040: GO 9760
10042: POP
10043: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10044: LD_INT 22
10046: PUSH
10047: LD_INT 6
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: NOT
10059: IFFALSE 9743
// end ; until russianDestroyed ;
10061: LD_EXP 21
10065: IFFALSE 9308
// end ;
10067: PPOPN 6
10069: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10070: LD_EXP 21
10074: NOT
10075: PUSH
10076: LD_EXP 15
10080: PUSH
10081: LD_INT 6
10083: GREATEREQUAL
10084: AND
10085: PUSH
10086: LD_INT 2
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL 60054 0 2
10096: NOT
10097: AND
10098: IFFALSE 11054
10100: GO 10102
10102: DISABLE
10103: LD_INT 0
10105: PPUSH
10106: PPUSH
10107: PPUSH
10108: PPUSH
// begin enable ;
10109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10110: LD_INT 22
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 30
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PPUSH
10134: CALL_OW 69
10138: NOT
10139: IFFALSE 10143
// exit ;
10141: GO 11054
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10143: LD_ADDR_VAR 0 4
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 30
10160: PUSH
10161: LD_INT 34
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PPUSH
10172: CALL_OW 69
10176: ST_TO_ADDR
// if Prob ( 40 ) then
10177: LD_INT 40
10179: PPUSH
10180: CALL_OW 13
10184: IFFALSE 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 49
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 22
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 49
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL 58636 0 2
// end else
10309: GO 10434
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10311: LD_INT 2
10313: PPUSH
10314: LD_INT 24
10316: PUSH
10317: LD_INT 3
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: LD_INT 47
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 24
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 3
10340: PUSH
10341: LD_INT 47
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 24
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 3
10358: PUSH
10359: LD_INT 47
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: PUSH
10368: LD_INT 24
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 3
10376: PUSH
10377: LD_INT 46
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 24
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 3
10412: PUSH
10413: LD_INT 46
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL 58636 0 2
// end ; if Difficulty > 1 then
10434: LD_OWVAR 67
10438: PUSH
10439: LD_INT 1
10441: GREATER
10442: IFFALSE 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 47
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10479: LD_INT 2
10481: PPUSH
10482: LD_INT 1
10484: PPUSH
10485: CALL 60054 0 2
10489: PUSH
10490: LD_INT 6
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: LD_INT 7
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_OWVAR 67
10508: ARRAY
10509: GREATEREQUAL
10510: IFFALSE 10472
// wait ( 0 0$30 ) ;
10512: LD_INT 1050
10514: PPUSH
10515: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_INT 2
10526: PPUSH
10527: LD_INT 1
10529: PPUSH
10530: CALL 60054 0 2
10534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10535: LD_ADDR_EXP 129
10539: PUSH
10540: LD_EXP 129
10544: PPUSH
10545: LD_INT 2
10547: PPUSH
10548: LD_EXP 129
10552: PUSH
10553: LD_INT 2
10555: ARRAY
10556: PUSH
10557: LD_VAR 0 2
10561: DIFF
10562: PPUSH
10563: CALL_OW 1
10567: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10568: LD_ADDR_VAR 0 3
10572: PUSH
10573: LD_INT 0
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 12
10583: ST_TO_ADDR
// if target then
10584: LD_VAR 0 3
10588: IFFALSE 10716
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10590: LD_ADDR_VAR 0 2
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_INT 24
10602: PUSH
10603: LD_INT 250
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 72
10614: ST_TO_ADDR
// for i in tmp do
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 2
10624: PUSH
10625: FOR_IN
10626: IFFALSE 10666
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: LD_INT 89
10638: PPUSH
10639: CALL_OW 297
10643: PUSH
10644: LD_INT 9
10646: GREATER
10647: IFFALSE 10664
// ComMoveXY ( i , 139 , 89 ) ;
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: LD_INT 89
10659: PPUSH
10660: CALL_OW 111
10664: GO 10625
10666: POP
10667: POP
// wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_INT 92
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 89
10688: PUSH
10689: LD_INT 9
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 72
10702: PUSH
10703: LD_VAR 0 2
10707: PUSH
10708: LD_INT 1
10710: MINUS
10711: GREATEREQUAL
10712: IFFALSE 10590
// end else
10714: GO 10858
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10716: LD_VAR 0 2
10720: PPUSH
10721: LD_VAR 0 4
10725: PUSH
10726: LD_INT 1
10728: ARRAY
10729: PPUSH
10730: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: LD_INT 24
10746: PUSH
10747: LD_INT 250
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 72
10758: ST_TO_ADDR
// for i in tmp do
10759: LD_ADDR_VAR 0 1
10763: PUSH
10764: LD_VAR 0 2
10768: PUSH
10769: FOR_IN
10770: IFFALSE 10810
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 124
10779: PPUSH
10780: LD_INT 139
10782: PPUSH
10783: CALL_OW 297
10787: PUSH
10788: LD_INT 9
10790: GREATER
10791: IFFALSE 10808
// ComMoveXY ( i , 124 , 139 ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_INT 124
10800: PPUSH
10801: LD_INT 139
10803: PPUSH
10804: CALL_OW 111
10808: GO 10769
10810: POP
10811: POP
// wait ( 0 0$1 ) ;
10812: LD_INT 35
10814: PPUSH
10815: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_INT 92
10826: PUSH
10827: LD_INT 124
10829: PUSH
10830: LD_INT 139
10832: PUSH
10833: LD_INT 9
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 72
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 1
10854: MINUS
10855: GREATEREQUAL
10856: IFFALSE 10734
// end ; repeat wait ( 0 0$1 ) ;
10858: LD_INT 35
10860: PPUSH
10861: CALL_OW 67
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 11045
// begin if GetLives ( i ) > 251 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 256
10887: PUSH
10888: LD_INT 251
10890: GREATER
10891: IFFALSE 11016
// begin if GetWeapon ( i ) = ru_time_lapser then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 264
10902: PUSH
10903: LD_INT 49
10905: EQUAL
10906: IFFALSE 10962
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 2
10915: PUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 8
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: PPUSH
10946: LD_VAR 0 1
10950: PPUSH
10951: CALL_OW 74
10955: PPUSH
10956: CALL_OW 112
10960: GO 11014
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10962: LD_VAR 0 1
10966: PPUSH
10967: LD_INT 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 8
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 69
10999: PPUSH
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 74
11009: PPUSH
11010: CALL_OW 115
// end else
11014: GO 11043
// if IsDead ( i ) then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 301
11025: IFFALSE 11043
// tmp := tmp diff i ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 1
11041: DIFF
11042: ST_TO_ADDR
// end ;
11043: GO 10875
11045: POP
11046: POP
// until not tmp ;
11047: LD_VAR 0 2
11051: NOT
11052: IFFALSE 10858
// end ; end_of_file
11054: PPOPN 4
11056: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11057: LD_INT 0
11059: PPUSH
11060: PPUSH
11061: PPUSH
11062: PPUSH
11063: PPUSH
11064: PPUSH
// side := 7 ;
11065: LD_ADDR_VAR 0 5
11069: PUSH
11070: LD_INT 7
11072: ST_TO_ADDR
// uc_side := side ;
11073: LD_ADDR_OWVAR 20
11077: PUSH
11078: LD_VAR 0 5
11082: ST_TO_ADDR
// uc_nation := 1 ;
11083: LD_ADDR_OWVAR 21
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11091: LD_ADDR_VAR 0 2
11095: PUSH
11096: LD_INT 22
11098: PUSH
11099: LD_VAR 0 5
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 3
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PPUSH
11122: CALL_OW 69
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11144
// SetBLevel ( i , 10 ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: LD_INT 10
11137: PPUSH
11138: CALL_OW 241
11142: GO 11127
11144: POP
11145: POP
// base := GetBase ( al_depot ) ;
11146: LD_ADDR_VAR 0 4
11150: PUSH
11151: LD_INT 2
11153: PPUSH
11154: CALL_OW 274
11158: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11159: LD_ADDR_VAR 0 6
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_VAR 0 5
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: LD_INT 30
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 69
11194: ST_TO_ADDR
// if teleport then
11195: LD_VAR 0 6
11199: IFFALSE 11220
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11201: LD_VAR 0 6
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_INT 262
11212: PPUSH
11213: LD_INT 119
11215: PPUSH
11216: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11220: LD_VAR 0 4
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 19500
11230: PPUSH
11231: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 2
11242: PPUSH
11243: LD_INT 200
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 3
11257: PPUSH
11258: LD_INT 650
11260: PPUSH
11261: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11265: LD_ADDR_EXP 74
11269: PUSH
11270: LD_STRING Roth
11272: PPUSH
11273: CALL_OW 25
11277: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_STRING Simms
11285: PPUSH
11286: LD_EXP 1
11290: NOT
11291: PPUSH
11292: LD_STRING 10c_
11294: PPUSH
11295: CALL 64980 0 3
11299: ST_TO_ADDR
// if not Simms then
11300: LD_EXP 75
11304: NOT
11305: IFFALSE 11335
// begin uc_nation := 1 ;
11307: LD_ADDR_OWVAR 21
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11315: LD_INT 2
11317: PPUSH
11318: LD_INT 10
11320: PPUSH
11321: CALL_OW 384
// Simms := CreateHuman ;
11325: LD_ADDR_EXP 75
11329: PUSH
11330: CALL_OW 44
11334: ST_TO_ADDR
// end ; uc_nation := 3 ;
11335: LD_ADDR_OWVAR 21
11339: PUSH
11340: LD_INT 3
11342: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11343: LD_ADDR_EXP 76
11347: PUSH
11348: LD_STRING Kirilenkova
11350: PPUSH
11351: CALL_OW 25
11355: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11356: LD_ADDR_EXP 90
11360: PUSH
11361: LD_STRING Oblukov
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11369: LD_ADDR_EXP 77
11373: PUSH
11374: LD_STRING Dolgov
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11382: LD_ADDR_EXP 78
11386: PUSH
11387: LD_STRING Petrosyan
11389: PPUSH
11390: CALL_OW 25
11394: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11395: LD_ADDR_EXP 89
11399: PUSH
11400: LD_STRING Scholtze
11402: PPUSH
11403: CALL_OW 25
11407: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11408: LD_ADDR_EXP 88
11412: PUSH
11413: LD_STRING Kapitsova
11415: PPUSH
11416: CALL_OW 25
11420: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11421: LD_ADDR_EXP 79
11425: PUSH
11426: LD_STRING Petrovova
11428: PPUSH
11429: CALL_OW 25
11433: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11434: LD_ADDR_EXP 80
11438: PUSH
11439: LD_STRING Kuzmov
11441: PPUSH
11442: CALL_OW 25
11446: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11447: LD_ADDR_EXP 87
11451: PUSH
11452: LD_STRING Karamazov
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11460: LD_STRING 13_Lipshchin_1
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 30
11470: IFFALSE 11485
// Lipshchin := NewCharacter ( Lipshchin ) ;
11472: LD_ADDR_EXP 81
11476: PUSH
11477: LD_STRING Lipshchin
11479: PPUSH
11480: CALL_OW 25
11484: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11485: LD_STRING 13_Titov_1
11487: PPUSH
11488: LD_INT 0
11490: PPUSH
11491: CALL_OW 30
11495: IFFALSE 11510
// Titov := NewCharacter ( Titov ) ;
11497: LD_ADDR_EXP 83
11501: PUSH
11502: LD_STRING Titov
11504: PPUSH
11505: CALL_OW 25
11509: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11510: LD_STRING 13_Gnyevko_1
11512: PPUSH
11513: LD_INT 0
11515: PPUSH
11516: CALL_OW 30
11520: IFFALSE 11535
// Gnyevko := NewCharacter ( Gnyevko ) ;
11522: LD_ADDR_EXP 82
11526: PUSH
11527: LD_STRING Gnyevko
11529: PPUSH
11530: CALL_OW 25
11534: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11535: LD_STRING 13_Xavier_1
11537: PPUSH
11538: LD_INT 0
11540: PPUSH
11541: CALL_OW 30
11545: IFFALSE 11560
// Xavier := NewCharacter ( Xavier2 ) ;
11547: LD_ADDR_EXP 84
11551: PUSH
11552: LD_STRING Xavier2
11554: PPUSH
11555: CALL_OW 25
11559: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11560: LD_STRING 13_Belkov_1
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 30
11570: IFFALSE 11585
// Belkov := NewCharacter ( Belkov ) ;
11572: LD_ADDR_EXP 85
11576: PUSH
11577: LD_STRING Belkov
11579: PPUSH
11580: CALL_OW 25
11584: ST_TO_ADDR
// if not BurlakStatus then
11585: LD_EXP 9
11589: NOT
11590: IFFALSE 11605
// Burlak = NewCharacter ( Burlak ) ;
11592: LD_ADDR_EXP 86
11596: PUSH
11597: LD_STRING Burlak
11599: PPUSH
11600: CALL_OW 25
11604: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_EXP 74
11614: PUSH
11615: LD_EXP 76
11619: PUSH
11620: LD_EXP 90
11624: PUSH
11625: LD_EXP 77
11629: PUSH
11630: LD_EXP 78
11634: PUSH
11635: LD_EXP 89
11639: PUSH
11640: LD_EXP 88
11644: PUSH
11645: LD_EXP 79
11649: PUSH
11650: LD_EXP 80
11654: PUSH
11655: LD_EXP 87
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: ST_TO_ADDR
// if Simms then
11672: LD_EXP 75
11676: IFFALSE 11694
// tmp := tmp ^ Simms ;
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_EXP 75
11692: ADD
11693: ST_TO_ADDR
// if Titov then
11694: LD_EXP 83
11698: IFFALSE 11716
// tmp := tmp ^ Titov ;
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_EXP 83
11714: ADD
11715: ST_TO_ADDR
// if Lipshchin then
11716: LD_EXP 81
11720: IFFALSE 11738
// tmp := tmp ^ Lipshchin ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_EXP 81
11736: ADD
11737: ST_TO_ADDR
// if Gnyevko then
11738: LD_EXP 82
11742: IFFALSE 11760
// tmp := tmp ^ Gnyevko ;
11744: LD_ADDR_VAR 0 3
11748: PUSH
11749: LD_VAR 0 3
11753: PUSH
11754: LD_EXP 82
11758: ADD
11759: ST_TO_ADDR
// if Xavier then
11760: LD_EXP 84
11764: IFFALSE 11782
// tmp := tmp ^ Xavier ;
11766: LD_ADDR_VAR 0 3
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_EXP 84
11780: ADD
11781: ST_TO_ADDR
// if Belkov then
11782: LD_EXP 85
11786: IFFALSE 11804
// tmp := tmp ^ Belkov ;
11788: LD_ADDR_VAR 0 3
11792: PUSH
11793: LD_VAR 0 3
11797: PUSH
11798: LD_EXP 85
11802: ADD
11803: ST_TO_ADDR
// if Burlak then
11804: LD_EXP 86
11808: IFFALSE 11826
// tmp := tmp ^ Burlak ;
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_VAR 0 3
11819: PUSH
11820: LD_EXP 86
11824: ADD
11825: ST_TO_ADDR
// for i = 1 to 11 do
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: DOUBLE
11832: LD_INT 1
11834: DEC
11835: ST_TO_ADDR
11836: LD_INT 11
11838: PUSH
11839: FOR_TO
11840: IFFALSE 11906
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11842: LD_ADDR_OWVAR 21
11846: PUSH
11847: LD_INT 1
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: CALL_OW 12
11867: ARRAY
11868: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11869: LD_INT 0
11871: PPUSH
11872: LD_VAR 0 2
11876: PUSH
11877: LD_INT 2
11879: DIV
11880: PPUSH
11881: LD_INT 10
11883: PPUSH
11884: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: CALL_OW 44
11902: ADD
11903: ST_TO_ADDR
// end ;
11904: GO 11839
11906: POP
11907: POP
// for i in tmp do
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: LD_VAR 0 3
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11944
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11921: LD_VAR 0 2
11925: PPUSH
11926: LD_INT 260
11928: PPUSH
11929: LD_INT 235
11931: PPUSH
11932: LD_INT 8
11934: PPUSH
11935: LD_INT 0
11937: PPUSH
11938: CALL_OW 50
11942: GO 11918
11944: POP
11945: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11946: LD_ADDR_EXP 110
11950: PUSH
11951: LD_EXP 110
11955: PPUSH
11956: LD_INT 1
11958: PPUSH
11959: LD_INT 22
11961: PUSH
11962: LD_VAR 0 5
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 21
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: PUSH
11997: LD_EXP 74
12001: PUSH
12002: LD_EXP 75
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: DIFF
12011: PPUSH
12012: CALL_OW 1
12016: ST_TO_ADDR
// uc_side := 0 ;
12017: LD_ADDR_OWVAR 20
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// uc_nation := 0 ;
12025: LD_ADDR_OWVAR 21
12029: PUSH
12030: LD_INT 0
12032: ST_TO_ADDR
// for i = 1 to 5 do
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: DOUBLE
12039: LD_INT 1
12041: DEC
12042: ST_TO_ADDR
12043: LD_INT 5
12045: PUSH
12046: FOR_TO
12047: IFFALSE 12084
// begin InitHc ;
12049: CALL_OW 19
// hc_class := class_apeman ;
12053: LD_ADDR_OWVAR 28
12057: PUSH
12058: LD_INT 12
12060: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12061: CALL_OW 44
12065: PPUSH
12066: LD_INT 299
12068: PPUSH
12069: LD_INT 229
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 50
// end ;
12082: GO 12046
12084: POP
12085: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12086: LD_EXP 74
12090: PPUSH
12091: LD_INT 259
12093: PPUSH
12094: LD_INT 235
12096: PPUSH
12097: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 262
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 178
// if Simms then
12116: LD_EXP 75
12120: IFFALSE 12151
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12122: LD_EXP 75
12126: PPUSH
12127: LD_INT 262
12129: PPUSH
12130: LD_INT 235
12132: PPUSH
12133: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_EXP 74
12146: PPUSH
12147: CALL_OW 179
// end ; end ;
12151: LD_VAR 0 1
12155: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12156: LD_EXP 31
12160: PUSH
12161: LD_EXP 23
12165: NOT
12166: AND
12167: IFFALSE 12343
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
12175: PPUSH
12176: PPUSH
// begin enable ;
12177: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12178: LD_ADDR_VAR 0 2
12182: PUSH
12183: LD_INT 81
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 3
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 30
12208: PUSH
12209: LD_INT 30
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PUSH
12216: LD_INT 30
12218: PUSH
12219: LD_INT 28
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: PUSH
12226: LD_INT 34
12228: PUSH
12229: LD_INT 49
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 34
12238: PUSH
12239: LD_INT 10
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 34
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PPUSH
12269: CALL_OW 69
12273: ST_TO_ADDR
// if not tmp then
12274: LD_VAR 0 2
12278: NOT
12279: IFFALSE 12283
// exit ;
12281: GO 12343
// target := tmp [ rand ( 1 , tmp ) ] ;
12283: LD_ADDR_VAR 0 3
12287: PUSH
12288: LD_VAR 0 2
12292: PUSH
12293: LD_INT 1
12295: PPUSH
12296: LD_VAR 0 2
12300: PPUSH
12301: CALL_OW 12
12305: ARRAY
12306: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 255
12316: PUSH
12317: LD_INT 1
12319: EQUAL
12320: IFFALSE 12331
// CenterNowOnUnits ( target ) ;
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 87
// SetLives ( target , 0 ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 234
// end ;
12343: PPOPN 3
12345: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12346: LD_EXP 23
12350: NOT
12351: PUSH
12352: LD_EXP 31
12356: AND
12357: IFFALSE 12879
12359: GO 12361
12361: DISABLE
12362: LD_INT 0
12364: PPUSH
12365: PPUSH
12366: PPUSH
// begin uc_side := 7 ;
12367: LD_ADDR_OWVAR 20
12371: PUSH
12372: LD_INT 7
12374: ST_TO_ADDR
// uc_nation := 1 ;
12375: LD_ADDR_OWVAR 21
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12383: LD_ADDR_VAR 0 3
12387: PUSH
12388: LD_INT 125
12390: PUSH
12391: LD_INT 163
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 185
12400: PUSH
12401: LD_INT 168
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 111
12410: PUSH
12411: LD_INT 97
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL 108062 0 1
12427: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12428: LD_ADDR_EXP 91
12432: PUSH
12433: EMPTY
12434: ST_TO_ADDR
// for i = 1 to Difficulty do
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: DOUBLE
12441: LD_INT 1
12443: DEC
12444: ST_TO_ADDR
12445: LD_OWVAR 67
12449: PUSH
12450: FOR_TO
12451: IFFALSE 12609
// begin InitHc ;
12453: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12457: LD_INT 0
12459: PPUSH
12460: LD_INT 8
12462: PPUSH
12463: CALL_OW 381
// un := CreateHuman ;
12467: LD_ADDR_VAR 0 2
12471: PUSH
12472: CALL_OW 44
12476: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 258
12484: PPUSH
12485: LD_INT 267
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: LD_INT 0
12493: PPUSH
12494: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12498: LD_ADDR_EXP 91
12502: PUSH
12503: LD_EXP 91
12507: PUSH
12508: LD_VAR 0 2
12512: UNION
12513: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12514: LD_VAR 0 2
12518: PPUSH
12519: LD_VAR 0 3
12523: PUSH
12524: LD_VAR 0 1
12528: ARRAY
12529: PUSH
12530: LD_INT 1
12532: ARRAY
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 2
12547: ARRAY
12548: PPUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 1
12554: PPUSH
12555: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_VAR 0 1
12573: ARRAY
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 2
12592: ARRAY
12593: PPUSH
12594: CALL_OW 171
// AddComInvisible ( un ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 212
// end ;
12607: GO 12450
12609: POP
12610: POP
// repeat wait ( 0 0$20 ) ;
12611: LD_INT 700
12613: PPUSH
12614: CALL_OW 67
// for i in allianceSpecialForce do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_EXP 91
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12864
// begin if IsInvisible ( i ) then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 571
12640: IFFALSE 12833
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 50
12659: PUSH
12660: EMPTY
12661: LIST
12662: PUSH
12663: LD_INT 56
12665: PUSH
12666: EMPTY
12667: LIST
12668: PUSH
12669: LD_INT 91
12671: PUSH
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 25
12679: PUSH
12680: LD_INT 30
12682: PUSH
12683: LD_INT 35
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: PUSH
12691: LD_OWVAR 67
12695: ARRAY
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: LIST
12701: PUSH
12702: LD_INT 2
12704: PUSH
12705: LD_INT 25
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 25
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 5
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 8
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PPUSH
12781: CALL_OW 69
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 3
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12628
// if Prob ( 30 * Difficulty ) then
12795: LD_INT 30
12797: PUSH
12798: LD_OWVAR 67
12802: MUL
12803: PPUSH
12804: CALL_OW 13
12808: IFFALSE 12833
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12810: LD_VAR 0 3
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_VAR 0 3
12822: PPUSH
12823: CALL_OW 12
12827: ARRAY
12828: PPUSH
12829: CALL 31022 0 1
// end ; if IsDead ( i ) then
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 301
12842: IFFALSE 12862
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12844: LD_ADDR_EXP 91
12848: PUSH
12849: LD_EXP 91
12853: PUSH
12854: LD_VAR 0 1
12858: DIFF
12859: ST_TO_ADDR
// continue ;
12860: GO 12628
// end ; end ;
12862: GO 12628
12864: POP
12865: POP
// until allianceDestroyed or not allianceSpecialForce ;
12866: LD_EXP 23
12870: PUSH
12871: LD_EXP 91
12875: NOT
12876: OR
12877: IFFALSE 12611
// end ;
12879: PPOPN 3
12881: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12882: LD_EXP 23
12886: NOT
12887: PUSH
12888: LD_EXP 31
12892: AND
12893: IFFALSE 13860
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
12901: PPUSH
12902: PPUSH
12903: PPUSH
// begin enable ;
12904: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12905: LD_INT 22
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 30
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: NOT
12934: IFFALSE 12938
// exit ;
12936: GO 13860
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12938: LD_ADDR_VAR 0 4
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 30
12955: PUSH
12956: LD_INT 34
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// if Prob ( 40 ) then
12972: LD_INT 40
12974: PPUSH
12975: CALL_OW 13
12979: IFFALSE 13106
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12981: LD_INT 1
12983: PPUSH
12984: LD_INT 5
12986: PUSH
12987: LD_INT 3
12989: PUSH
12990: LD_INT 2
12992: PUSH
12993: LD_INT 6
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 5
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: LD_INT 6
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 5
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 2
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 24
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 45
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 24
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 47
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL 58636 0 2
// end else
13104: GO 13229
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13106: LD_INT 1
13108: PPUSH
13109: LD_INT 24
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 47
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 47
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 5
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 2
13153: PUSH
13154: LD_INT 9
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 5
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: LD_INT 2
13171: PUSH
13172: LD_INT 9
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: PUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 45
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 24
13201: PUSH
13202: LD_INT 1
13204: PUSH
13205: LD_INT 3
13207: PUSH
13208: LD_INT 45
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL 58636 0 2
// end ; if Difficulty > 1 then
13229: LD_OWVAR 67
13233: PUSH
13234: LD_INT 1
13236: GREATER
13237: IFFALSE 13267
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 24
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 3
13250: PUSH
13251: LD_INT 47
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: PPUSH
13263: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL 60054 0 2
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 7
13290: PUSH
13291: LD_INT 7
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: GREATEREQUAL
13305: IFFALSE 13267
// wait ( 0 0$40 ) ;
13307: LD_INT 1400
13309: PPUSH
13310: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13314: LD_ADDR_VAR 0 2
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 1
13324: PPUSH
13325: CALL 60054 0 2
13329: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13330: LD_ADDR_EXP 129
13334: PUSH
13335: LD_EXP 129
13339: PPUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_EXP 129
13347: PUSH
13348: LD_INT 1
13350: ARRAY
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: PPUSH
13358: CALL_OW 1
13362: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: CALL_OW 12
13378: ST_TO_ADDR
// if target then
13379: LD_VAR 0 3
13383: IFFALSE 13549
// begin for i in tmp do
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: FOR_IN
13396: IFFALSE 13421
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_INT 179
13405: PPUSH
13406: LD_INT 209
13408: PPUSH
13409: LD_INT 8
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 483
13419: GO 13395
13421: POP
13422: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_VAR 0 2
13432: PPUSH
13433: LD_INT 24
13435: PUSH
13436: LD_INT 250
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: ST_TO_ADDR
// for i in tmp do
13448: LD_ADDR_VAR 0 1
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: FOR_IN
13459: IFFALSE 13499
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13461: LD_VAR 0 1
13465: PPUSH
13466: LD_INT 179
13468: PPUSH
13469: LD_INT 209
13471: PPUSH
13472: CALL_OW 297
13476: PUSH
13477: LD_INT 9
13479: GREATER
13480: IFFALSE 13497
// ComMoveXY ( i , 179 , 209 ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_INT 179
13489: PPUSH
13490: LD_INT 209
13492: PPUSH
13493: CALL_OW 111
13497: GO 13458
13499: POP
13500: POP
// wait ( 0 0$1 ) ;
13501: LD_INT 35
13503: PPUSH
13504: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_INT 92
13515: PUSH
13516: LD_INT 179
13518: PUSH
13519: LD_INT 209
13521: PUSH
13522: LD_INT 9
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 1
13543: MINUS
13544: GREATEREQUAL
13545: IFFALSE 13423
// end else
13547: GO 13711
// begin for i in tmp do
13549: LD_ADDR_VAR 0 1
13553: PUSH
13554: LD_VAR 0 2
13558: PUSH
13559: FOR_IN
13560: IFFALSE 13585
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13562: LD_VAR 0 1
13566: PPUSH
13567: LD_INT 285
13569: PPUSH
13570: LD_INT 163
13572: PPUSH
13573: LD_INT 8
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 483
13583: GO 13559
13585: POP
13586: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_INT 24
13599: PUSH
13600: LD_INT 250
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 72
13611: ST_TO_ADDR
// for i in tmp do
13612: LD_ADDR_VAR 0 1
13616: PUSH
13617: LD_VAR 0 2
13621: PUSH
13622: FOR_IN
13623: IFFALSE 13663
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13625: LD_VAR 0 1
13629: PPUSH
13630: LD_INT 285
13632: PPUSH
13633: LD_INT 163
13635: PPUSH
13636: CALL_OW 297
13640: PUSH
13641: LD_INT 9
13643: GREATER
13644: IFFALSE 13661
// ComMoveXY ( i , 285 , 163 ) ;
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 285
13653: PPUSH
13654: LD_INT 163
13656: PPUSH
13657: CALL_OW 111
13661: GO 13622
13663: POP
13664: POP
// wait ( 0 0$1 ) ;
13665: LD_INT 35
13667: PPUSH
13668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13672: LD_VAR 0 2
13676: PPUSH
13677: LD_INT 92
13679: PUSH
13680: LD_INT 285
13682: PUSH
13683: LD_INT 163
13685: PUSH
13686: LD_INT 9
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 72
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: MINUS
13708: GREATEREQUAL
13709: IFFALSE 13587
// end ; repeat wait ( 0 0$1 ) ;
13711: LD_INT 35
13713: PPUSH
13714: CALL_OW 67
// for i in tmp do
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: FOR_IN
13729: IFFALSE 13851
// if GetLives ( i ) > 251 then
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 256
13740: PUSH
13741: LD_INT 251
13743: GREATER
13744: IFFALSE 13833
// begin if GetWeapon ( i ) = ru_time_lapser then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 264
13755: PUSH
13756: LD_INT 49
13758: EQUAL
13759: IFFALSE 13797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13761: LD_VAR 0 1
13765: PPUSH
13766: LD_INT 81
13768: PUSH
13769: LD_INT 7
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: CALL_OW 74
13790: PPUSH
13791: CALL_OW 112
13795: GO 13831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 81
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PPUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: CALL_OW 74
13826: PPUSH
13827: CALL_OW 115
// end else
13831: GO 13849
// tmp := tmp diff i ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: DIFF
13848: ST_TO_ADDR
13849: GO 13728
13851: POP
13852: POP
// until not tmp ;
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13711
// end ; end_of_file
13860: PPOPN 4
13862: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// missionStage := 13 ;
13869: LD_ADDR_EXP 15
13873: PUSH
13874: LD_INT 13
13876: ST_TO_ADDR
// uc_side := 2 ;
13877: LD_ADDR_OWVAR 20
13881: PUSH
13882: LD_INT 2
13884: ST_TO_ADDR
// uc_nation := 2 ;
13885: LD_ADDR_OWVAR 21
13889: PUSH
13890: LD_INT 2
13892: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13893: LD_ADDR_EXP 92
13897: PUSH
13898: LD_STRING Omar
13900: PPUSH
13901: CALL_OW 25
13905: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13906: LD_EXP 92
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13918: LD_EXP 92
13922: PPUSH
13923: LD_INT 242
13925: PPUSH
13926: LD_INT 75
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13936: LD_ADDR_EXP 93
13940: PUSH
13941: LD_STRING Heike
13943: PPUSH
13944: CALL_OW 25
13948: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13949: LD_INT 14
13951: PPUSH
13952: LD_INT 3
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: LD_INT 27
13960: PPUSH
13961: LD_INT 100
13963: PPUSH
13964: CALL 72215 0 5
// veh := CreateVehicle ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: CALL_OW 45
13977: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13978: LD_VAR 0 3
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 242
// SetDir ( veh , 4 ) ;
13990: LD_VAR 0 3
13994: PPUSH
13995: LD_INT 4
13997: PPUSH
13998: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 241
14009: PPUSH
14010: LD_INT 72
14012: PPUSH
14013: LD_INT 0
14015: PPUSH
14016: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14020: LD_EXP 93
14024: PPUSH
14025: LD_VAR 0 3
14029: PPUSH
14030: CALL_OW 52
// if KhatamStatus then
14034: LD_EXP 8
14038: IFFALSE 14089
// begin Khatam := NewCharacter ( Khatam ) ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_STRING Khatam
14047: PPUSH
14048: CALL_OW 25
14052: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14053: LD_EXP 94
14057: PPUSH
14058: LD_INT 245
14060: PPUSH
14061: LD_INT 78
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 0
14069: PPUSH
14070: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14074: LD_EXP 94
14078: PPUSH
14079: LD_INT 4
14081: PPUSH
14082: LD_INT 10
14084: PPUSH
14085: CALL_OW 237
// end ; for i = 1 to Difficulty do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_OWVAR 67
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14171
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14107: LD_INT 0
14109: PPUSH
14110: LD_INT 7
14112: PUSH
14113: LD_OWVAR 67
14117: PLUS
14118: PPUSH
14119: CALL_OW 384
// un := CreateHuman ;
14123: LD_ADDR_VAR 0 4
14127: PUSH
14128: CALL_OW 44
14132: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14133: LD_VAR 0 4
14137: PPUSH
14138: LD_INT 28
14140: PUSH
14141: LD_INT 29
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: MOD
14156: PUSH
14157: LD_INT 1
14159: PLUS
14160: ARRAY
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// end ;
14169: GO 14104
14171: POP
14172: POP
// for i = 1 to 6 do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_INT 6
14185: PUSH
14186: FOR_TO
14187: IFFALSE 14232
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14189: LD_INT 0
14191: PPUSH
14192: LD_INT 7
14194: PUSH
14195: LD_OWVAR 67
14199: PLUS
14200: PPUSH
14201: CALL_OW 381
// un := CreateHuman ;
14205: LD_ADDR_VAR 0 4
14209: PUSH
14210: CALL_OW 44
14214: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14215: LD_VAR 0 4
14219: PPUSH
14220: LD_INT 28
14222: PPUSH
14223: LD_INT 0
14225: PPUSH
14226: CALL_OW 49
// end ;
14230: GO 14186
14232: POP
14233: POP
// for i = 1 to 3 do
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: DOUBLE
14240: LD_INT 1
14242: DEC
14243: ST_TO_ADDR
14244: LD_INT 3
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14296
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14250: LD_INT 0
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: LD_INT 7
14258: PUSH
14259: LD_OWVAR 67
14263: PLUS
14264: PPUSH
14265: CALL_OW 380
// un := CreateHuman ;
14269: LD_ADDR_VAR 0 4
14273: PUSH
14274: CALL_OW 44
14278: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14279: LD_VAR 0 4
14283: PPUSH
14284: LD_INT 28
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 49
// end ;
14294: GO 14247
14296: POP
14297: POP
// for i = 1 to 3 do
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: DOUBLE
14304: LD_INT 1
14306: DEC
14307: ST_TO_ADDR
14308: LD_INT 3
14310: PUSH
14311: FOR_TO
14312: IFFALSE 14402
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14314: LD_INT 14
14316: PPUSH
14317: LD_INT 2
14319: PPUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 28
14325: PPUSH
14326: LD_INT 80
14328: PPUSH
14329: CALL 72215 0 5
// veh := CreateVehicle ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: CALL_OW 45
14342: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14343: LD_VAR 0 3
14347: PPUSH
14348: LD_INT 3
14350: PPUSH
14351: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14355: LD_VAR 0 3
14359: PPUSH
14360: LD_INT 29
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 7
14375: PUSH
14376: LD_OWVAR 67
14380: PLUS
14381: PPUSH
14382: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14386: CALL_OW 44
14390: PPUSH
14391: LD_VAR 0 3
14395: PPUSH
14396: CALL_OW 52
// end ;
14400: GO 14311
14402: POP
14403: POP
// for i = 1 to 5 + Difficulty do
14404: LD_ADDR_VAR 0 2
14408: PUSH
14409: DOUBLE
14410: LD_INT 1
14412: DEC
14413: ST_TO_ADDR
14414: LD_INT 5
14416: PUSH
14417: LD_OWVAR 67
14421: PLUS
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14551
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: CALL_OW 12
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PUSH
14446: LD_INT 26
14448: PUSH
14449: LD_INT 27
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_VAR 0 2
14465: PUSH
14466: LD_INT 4
14468: MOD
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ARRAY
14474: PPUSH
14475: LD_INT 80
14477: PPUSH
14478: CALL 72215 0 5
// veh := CreateVehicle ;
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: CALL_OW 45
14491: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_INT 4
14499: PPUSH
14500: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14504: LD_VAR 0 3
14508: PPUSH
14509: LD_INT 28
14511: PPUSH
14512: LD_INT 0
14514: PPUSH
14515: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14519: LD_INT 0
14521: PPUSH
14522: LD_INT 7
14524: PUSH
14525: LD_OWVAR 67
14529: PLUS
14530: PPUSH
14531: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14535: CALL_OW 44
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: CALL_OW 52
// end ;
14549: GO 14423
14551: POP
14552: POP
// for i = 1 to 3 do
14553: LD_ADDR_VAR 0 2
14557: PUSH
14558: DOUBLE
14559: LD_INT 1
14561: DEC
14562: ST_TO_ADDR
14563: LD_INT 3
14565: PUSH
14566: FOR_TO
14567: IFFALSE 14627
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14569: LD_INT 14
14571: PPUSH
14572: LD_INT 3
14574: PPUSH
14575: LD_INT 5
14577: PPUSH
14578: LD_INT 29
14580: PPUSH
14581: LD_INT 80
14583: PPUSH
14584: CALL 72215 0 5
// veh := CreateVehicle ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: CALL_OW 45
14597: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 4
14605: PPUSH
14606: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 28
14617: PPUSH
14618: LD_INT 0
14620: PPUSH
14621: CALL_OW 49
// end ;
14625: GO 14566
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 1
14633: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14634: LD_INT 22
14636: PUSH
14637: LD_INT 2
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: IFFALSE 14948
14650: GO 14652
14652: DISABLE
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 22
14665: PUSH
14666: LD_INT 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 4
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_EXP 94
14696: DIFF
14697: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PPUSH
14713: CALL_OW 69
14717: PUSH
14718: LD_EXP 94
14722: PUSH
14723: LD_VAR 0 3
14727: UNION
14728: DIFF
14729: ST_TO_ADDR
// if Khatam then
14730: LD_EXP 94
14734: IFFALSE 14751
// ComMoveXY ( Khatam , 211 , 92 ) ;
14736: LD_EXP 94
14740: PPUSH
14741: LD_INT 211
14743: PPUSH
14744: LD_INT 92
14746: PPUSH
14747: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14751: LD_INT 197
14753: PPUSH
14754: LD_INT 80
14756: PPUSH
14757: LD_INT 2
14759: PPUSH
14760: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14764: LD_INT 213
14766: PPUSH
14767: LD_INT 90
14769: PPUSH
14770: LD_INT 2
14772: PPUSH
14773: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 441
// if sci then
14790: LD_VAR 0 3
14794: IFFALSE 14815
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 1
14803: ARRAY
14804: PPUSH
14805: LD_INT 197
14807: PPUSH
14808: LD_INT 80
14810: PPUSH
14811: CALL_OW 158
// if sci > 1 then
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: GREATER
14823: IFFALSE 14844
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 2
14832: ARRAY
14833: PPUSH
14834: LD_INT 213
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 158
// if sci > 2 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: GREATER
14852: IFFALSE 14873
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14854: LD_VAR 0 3
14858: PUSH
14859: LD_INT 3
14861: ARRAY
14862: PPUSH
14863: LD_INT 215
14865: PPUSH
14866: LD_INT 129
14868: PPUSH
14869: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14873: LD_INT 35
14875: PPUSH
14876: CALL_OW 67
// for i in tmp do
14880: LD_ADDR_VAR 0 1
14884: PUSH
14885: LD_VAR 0 2
14889: PUSH
14890: FOR_IN
14891: IFFALSE 14929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: LD_INT 81
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PPUSH
14908: CALL_OW 69
14912: PPUSH
14913: LD_VAR 0 1
14917: PPUSH
14918: CALL_OW 74
14922: PPUSH
14923: CALL_OW 115
14927: GO 14890
14929: POP
14930: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14931: LD_INT 22
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: NOT
14946: IFFALSE 14873
// end ; end_of_file
14948: PPOPN 3
14950: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14951: LD_INT 0
14953: PPUSH
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
// Video ( true ) ;
14962: LD_INT 1
14964: PPUSH
14965: CALL 107942 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_INT 7
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 517
14984: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: DOUBLE
14991: LD_INT 1
14993: DEC
14994: ST_TO_ADDR
14995: LD_VAR 0 5
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PUSH
15004: FOR_TO
15005: IFFALSE 15050
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: ARRAY
15021: PPUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 2
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_INT 1
15039: PPUSH
15040: LD_INT 15
15042: NEG
15043: PPUSH
15044: CALL 107856 0 4
15048: GO 15004
15050: POP
15051: POP
// CenterNowOnUnits ( Powell ) ;
15052: LD_EXP 58
15056: PPUSH
15057: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15061: LD_ADDR_VAR 0 5
15065: PUSH
15066: LD_EXP 56
15070: PUSH
15071: EMPTY
15072: LIST
15073: ST_TO_ADDR
// if GirlNewVeh then
15074: LD_EXP 57
15078: IFFALSE 15096
// tmp := tmp ^ GirlNewVeh ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_VAR 0 5
15089: PUSH
15090: LD_EXP 57
15094: ADD
15095: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15096: LD_VAR 0 5
15100: PPUSH
15101: LD_INT 60
15103: PPUSH
15104: LD_INT 109
15106: PPUSH
15107: CALL_OW 111
// if KappaStatus then
15111: LD_EXP 2
15115: IFFALSE 15167
// begin Say ( JMM , D1nT-JMM-1 ) ;
15117: LD_EXP 39
15121: PPUSH
15122: LD_STRING D1nT-JMM-1
15124: PPUSH
15125: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15129: LD_EXP 58
15133: PPUSH
15134: LD_STRING D1T-Pow-1
15136: PPUSH
15137: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15141: LD_EXP 39
15145: PPUSH
15146: LD_STRING D1T-JMM-2
15148: PPUSH
15149: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15153: LD_EXP 58
15157: PPUSH
15158: LD_STRING D1T-Pow-2
15160: PPUSH
15161: CALL_OW 88
// end else
15165: GO 15373
// if JMMGirlStatus then
15167: LD_EXP 6
15171: IFFALSE 15316
// begin Say ( JMM , D1T-JMM-1 ) ;
15173: LD_EXP 39
15177: PPUSH
15178: LD_STRING D1T-JMM-1
15180: PPUSH
15181: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15185: LD_EXP 58
15189: PPUSH
15190: LD_STRING D1T-Pow-1
15192: PPUSH
15193: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15197: LD_EXP 39
15201: PPUSH
15202: LD_STRING D1T-JMM-3
15204: PPUSH
15205: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15209: LD_EXP 58
15213: PPUSH
15214: LD_STRING D1T-Pow-3
15216: PPUSH
15217: CALL_OW 88
// if JMMGirl then
15221: LD_EXP 7
15225: IFFALSE 15314
// begin case JMMGirl of 1 :
15227: LD_EXP 7
15231: PUSH
15232: LD_INT 1
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15255
15240: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15241: LD_EXP 40
15245: PPUSH
15246: LD_STRING D1T-Joan-3
15248: PPUSH
15249: CALL_OW 88
15253: GO 15302
15255: LD_INT 2
15257: DOUBLE
15258: EQUAL
15259: IFTRUE 15263
15261: GO 15278
15263: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15264: LD_EXP 42
15268: PPUSH
15269: LD_STRING D1T-Lisa-3
15271: PPUSH
15272: CALL_OW 88
15276: GO 15302
15278: LD_INT 3
15280: DOUBLE
15281: EQUAL
15282: IFTRUE 15286
15284: GO 15301
15286: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15287: LD_EXP 54
15291: PPUSH
15292: LD_STRING D1T-Con-3
15294: PPUSH
15295: CALL_OW 88
15299: GO 15302
15301: POP
// Say ( Powell , D1T-Pow-4 ) ;
15302: LD_EXP 58
15306: PPUSH
15307: LD_STRING D1T-Pow-4
15309: PPUSH
15310: CALL_OW 88
// end ; end else
15314: GO 15373
// if not FastEnd then
15316: LD_EXP 11
15320: NOT
15321: IFFALSE 15349
// begin Say ( JMM , D1T-JMM-4 ) ;
15323: LD_EXP 39
15327: PPUSH
15328: LD_STRING D1T-JMM-4
15330: PPUSH
15331: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15335: LD_EXP 58
15339: PPUSH
15340: LD_STRING D1T-Pow-5
15342: PPUSH
15343: CALL_OW 88
// end else
15347: GO 15373
// begin Say ( JMM , D1nT-JMM-1 ) ;
15349: LD_EXP 39
15353: PPUSH
15354: LD_STRING D1nT-JMM-1
15356: PPUSH
15357: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15361: LD_EXP 58
15365: PPUSH
15366: LD_STRING D1nT-Pow-1
15368: PPUSH
15369: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15373: LD_INT 35
15375: PPUSH
15376: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15380: LD_EXP 56
15384: PPUSH
15385: CALL_OW 314
15389: NOT
15390: IFFALSE 15373
// ComExitVehicle ( JMM ) ;
15392: LD_EXP 39
15396: PPUSH
15397: CALL_OW 121
// wait ( 3 ) ;
15401: LD_INT 3
15403: PPUSH
15404: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15408: LD_EXP 39
15412: PPUSH
15413: LD_INT 60
15415: PPUSH
15416: LD_INT 94
15418: PPUSH
15419: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_EXP 58
15432: PPUSH
15433: CALL_OW 179
// if Joan then
15437: LD_EXP 40
15441: IFFALSE 15495
// begin ComExitVehicle ( Joan ) ;
15443: LD_EXP 40
15447: PPUSH
15448: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15452: LD_EXP 40
15456: PPUSH
15457: LD_INT 35
15459: PPUSH
15460: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15464: LD_EXP 40
15468: PPUSH
15469: LD_INT 65
15471: PPUSH
15472: LD_INT 104
15474: PPUSH
15475: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_EXP 39
15488: PPUSH
15489: CALL_OW 179
// end else
15493: GO 15629
// if Lisa and JMMGirl = 2 then
15495: LD_EXP 42
15499: PUSH
15500: LD_EXP 7
15504: PUSH
15505: LD_INT 2
15507: EQUAL
15508: AND
15509: IFFALSE 15563
// begin ComExitVehicle ( Lisa ) ;
15511: LD_EXP 42
15515: PPUSH
15516: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15520: LD_EXP 42
15524: PPUSH
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15532: LD_EXP 42
15536: PPUSH
15537: LD_INT 65
15539: PPUSH
15540: LD_INT 104
15542: PPUSH
15543: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_EXP 39
15556: PPUSH
15557: CALL_OW 179
// end else
15561: GO 15629
// if Connie and JMMGirl = 3 then
15563: LD_EXP 54
15567: PUSH
15568: LD_EXP 7
15572: PUSH
15573: LD_INT 3
15575: EQUAL
15576: AND
15577: IFFALSE 15629
// begin ComExitVehicle ( Connie ) ;
15579: LD_EXP 54
15583: PPUSH
15584: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15588: LD_EXP 54
15592: PPUSH
15593: LD_INT 35
15595: PPUSH
15596: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15600: LD_EXP 54
15604: PPUSH
15605: LD_INT 65
15607: PPUSH
15608: LD_INT 104
15610: PPUSH
15611: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_EXP 39
15624: PPUSH
15625: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15636: LD_EXP 39
15640: PPUSH
15641: LD_EXP 58
15645: PPUSH
15646: CALL_OW 296
15650: PUSH
15651: LD_INT 6
15653: LESS
15654: IFFALSE 15629
// wait ( 0 0$0.5 ) ;
15656: LD_INT 18
15658: PPUSH
15659: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15663: LD_EXP 39
15667: PPUSH
15668: LD_STRING D1-JMM-1
15670: PPUSH
15671: CALL_OW 88
// async ;
15675: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15676: LD_EXP 58
15680: PPUSH
15681: LD_STRING D1-Pow-1
15683: PPUSH
15684: CALL_OW 88
// if not dialogue_skipped then
15688: LD_OWVAR 59
15692: NOT
15693: IFFALSE 15702
// wait ( 0 0$2 ) ;
15695: LD_INT 70
15697: PPUSH
15698: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15702: LD_INT 170
15704: PPUSH
15705: LD_INT 99
15707: PPUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_INT 6
15713: NEG
15714: PPUSH
15715: CALL 107856 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15719: LD_INT 174
15721: PPUSH
15722: LD_INT 115
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_INT 6
15730: NEG
15731: PPUSH
15732: CALL 107856 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15736: LD_INT 169
15738: PPUSH
15739: LD_INT 71
15741: PPUSH
15742: LD_INT 1
15744: PPUSH
15745: LD_INT 6
15747: NEG
15748: PPUSH
15749: CALL 107856 0 4
// if not dialogue_skipped then
15753: LD_OWVAR 59
15757: NOT
15758: IFFALSE 15777
// begin CenterOnXY ( 170 , 99 ) ;
15760: LD_INT 170
15762: PPUSH
15763: LD_INT 99
15765: PPUSH
15766: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15770: LD_INT 80
15772: PPUSH
15773: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15777: LD_INT 75
15779: PPUSH
15780: LD_INT 53
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: LD_INT 9
15788: NEG
15789: PPUSH
15790: CALL 107856 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15794: LD_INT 54
15796: PPUSH
15797: LD_INT 42
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: LD_INT 9
15805: NEG
15806: PPUSH
15807: CALL 107856 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15811: LD_INT 62
15813: PPUSH
15814: LD_INT 51
15816: PPUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 9
15822: NEG
15823: PPUSH
15824: CALL 107856 0 4
// if not dialogue_skipped then
15828: LD_OWVAR 59
15832: NOT
15833: IFFALSE 15852
// begin CenterOnXY ( 75 , 53 ) ;
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 53
15840: PPUSH
15841: CALL_OW 84
// wait ( 0 0$4 ) ;
15845: LD_INT 140
15847: PPUSH
15848: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15852: LD_EXP 58
15856: PPUSH
15857: CALL_OW 87
// if not dialogue_skipped then
15861: LD_OWVAR 59
15865: NOT
15866: IFFALSE 15875
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// sync ;
15875: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15876: LD_EXP 39
15880: PPUSH
15881: LD_STRING D1-JMM-2
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15888: LD_EXP 58
15892: PPUSH
15893: LD_STRING D1-Pow-2
15895: PPUSH
15896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15900: LD_EXP 39
15904: PPUSH
15905: LD_STRING D1-JMM-3
15907: PPUSH
15908: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15912: LD_EXP 58
15916: PPUSH
15917: LD_STRING D1-Pow-3
15919: PPUSH
15920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15924: LD_EXP 39
15928: PPUSH
15929: LD_STRING D1-JMM-4
15931: PPUSH
15932: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15936: LD_EXP 58
15940: PPUSH
15941: LD_STRING D1-Pow-4
15943: PPUSH
15944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15948: LD_EXP 39
15952: PPUSH
15953: LD_STRING D1-JMM-5
15955: PPUSH
15956: CALL_OW 88
// async ;
15960: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15961: LD_EXP 58
15965: PPUSH
15966: LD_STRING D1-Pow-5
15968: PPUSH
15969: CALL_OW 88
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$3.6 ) ;
15980: LD_INT 126
15982: PPUSH
15983: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15987: LD_INT 134
15989: PPUSH
15990: LD_INT 210
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_INT 11
15998: NEG
15999: PPUSH
16000: CALL 107856 0 4
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16028
// begin CenterOnXY ( 134 , 210 ) ;
16011: LD_INT 134
16013: PPUSH
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 84
// wait ( 0 0$2 ) ;
16021: LD_INT 70
16023: PPUSH
16024: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16028: LD_INT 101
16030: PPUSH
16031: LD_INT 159
16033: PPUSH
16034: LD_INT 1
16036: PPUSH
16037: LD_INT 10
16039: NEG
16040: PPUSH
16041: CALL 107856 0 4
// if not dialogue_skipped then
16045: LD_OWVAR 59
16049: NOT
16050: IFFALSE 16069
// begin CenterOnXY ( 101 , 159 ) ;
16052: LD_INT 101
16054: PPUSH
16055: LD_INT 159
16057: PPUSH
16058: CALL_OW 84
// wait ( 0 0$2 ) ;
16062: LD_INT 70
16064: PPUSH
16065: CALL_OW 67
// end ; sync ;
16069: SYNC
// CenterNowOnUnits ( Powell ) ;
16070: LD_EXP 58
16074: PPUSH
16075: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: LD_INT 2
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: LD_INT 4
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if not dialogue_skipped then
16110: LD_OWVAR 59
16114: NOT
16115: IFFALSE 16284
// begin game_speed := 4 ;
16117: LD_ADDR_OWVAR 65
16121: PUSH
16122: LD_INT 4
16124: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16125: LD_INT 210
16127: PPUSH
16128: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1
16139: PPUSH
16140: LD_VAR 0 6
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_STRING Q1
16157: PPUSH
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 98
16167: ST_TO_ADDR
// options = options diff dec ;
16168: LD_ADDR_VAR 0 6
16172: PUSH
16173: LD_VAR 0 6
16177: PUSH
16178: LD_VAR 0 7
16182: DIFF
16183: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16184: LD_VAR 0 7
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17756 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16198: LD_VAR 0 7
16202: PUSH
16203: LD_INT 5
16205: PUSH
16206: LD_INT 6
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: IN
16213: PUSH
16214: LD_VAR 0 6
16218: PUSH
16219: LD_INT 2
16221: EQUAL
16222: OR
16223: IFFALSE 16150
// if not ( dec in [ 5 , 6 ] ) then
16225: LD_VAR 0 7
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 6
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: IN
16240: NOT
16241: IFFALSE 16284
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_STRING Q1a
16250: PPUSH
16251: LD_INT 1
16253: PUSH
16254: LD_INT 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PPUSH
16261: CALL_OW 98
16265: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16266: LD_VAR 0 7
16270: PUSH
16271: LD_INT 4
16273: PLUS
16274: PPUSH
16275: LD_VAR 0 6
16279: PPUSH
16280: CALL 17756 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16284: LD_INT 81
16286: PPUSH
16287: LD_INT 127
16289: PPUSH
16290: CALL_OW 84
// amount := 5 ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_INT 5
16301: ST_TO_ADDR
// macmilan_squad := [ ] ;
16302: LD_ADDR_VAR 0 9
16306: PUSH
16307: EMPTY
16308: ST_TO_ADDR
// if vip < amount then
16309: LD_EXP 59
16313: PUSH
16314: LD_VAR 0 8
16318: LESS
16319: IFFALSE 16363
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16321: LD_ADDR_VAR 0 5
16325: PUSH
16326: LD_EXP 59
16330: PUSH
16331: LD_INT 22
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: LD_INT 21
16343: PUSH
16344: LD_INT 1
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 69
16359: UNION
16360: ST_TO_ADDR
16361: GO 16373
// tmp := vip ;
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: LD_EXP 59
16372: ST_TO_ADDR
// tmp := tmp diff Powell ;
16373: LD_ADDR_VAR 0 5
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: LD_EXP 58
16387: DIFF
16388: ST_TO_ADDR
// if tmp < amount then
16389: LD_VAR 0 5
16393: PUSH
16394: LD_VAR 0 8
16398: LESS
16399: IFFALSE 16411
// amount := tmp ;
16401: LD_ADDR_VAR 0 8
16405: PUSH
16406: LD_VAR 0 5
16410: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16411: LD_VAR 0 5
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: PPUSH
16420: CALL_OW 257
16424: PUSH
16425: LD_INT 2
16427: NONEQUAL
16428: IFFALSE 16490
// begin if IsInUnit ( tmp [ 1 ] ) then
16430: LD_VAR 0 5
16434: PUSH
16435: LD_INT 1
16437: ARRAY
16438: PPUSH
16439: CALL_OW 310
16443: IFFALSE 16458
// ComExitBuilding ( tmp [ 1 ] ) ;
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: PPUSH
16467: LD_INT 387
16469: PPUSH
16470: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_INT 1
16481: ARRAY
16482: PPUSH
16483: LD_INT 2
16485: PPUSH
16486: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16490: LD_EXP 39
16494: PPUSH
16495: LD_INT 82
16497: PPUSH
16498: LD_INT 129
16500: PPUSH
16501: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_EXP 58
16514: PPUSH
16515: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16519: LD_INT 22
16521: PUSH
16522: LD_INT 1
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 39
16538: DIFF
16539: PPUSH
16540: LD_INT 84
16542: PPUSH
16543: LD_INT 128
16545: PPUSH
16546: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16550: LD_INT 22
16552: PUSH
16553: LD_INT 1
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_EXP 39
16569: DIFF
16570: PPUSH
16571: LD_EXP 39
16575: PPUSH
16576: CALL_OW 179
// for i = 1 to amount do
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: DOUBLE
16586: LD_INT 1
16588: DEC
16589: ST_TO_ADDR
16590: LD_VAR 0 8
16594: PUSH
16595: FOR_TO
16596: IFFALSE 16764
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16598: LD_ADDR_VAR 0 9
16602: PUSH
16603: LD_VAR 0 9
16607: PUSH
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: ADD
16619: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16620: LD_VAR 0 5
16624: PUSH
16625: LD_VAR 0 2
16629: ARRAY
16630: PPUSH
16631: CALL_OW 310
16635: IFFALSE 16652
// AddComExitBuilding ( tmp [ i ] ) ;
16637: LD_VAR 0 5
16641: PUSH
16642: LD_VAR 0 2
16646: ARRAY
16647: PPUSH
16648: CALL_OW 182
// if i = 2 and JMMNewVeh then
16652: LD_VAR 0 2
16656: PUSH
16657: LD_INT 2
16659: EQUAL
16660: PUSH
16661: LD_EXP 56
16665: AND
16666: IFFALSE 16724
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16668: LD_VAR 0 5
16672: PUSH
16673: LD_VAR 0 2
16677: ARRAY
16678: PPUSH
16679: LD_EXP 56
16683: PPUSH
16684: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16688: LD_VAR 0 5
16692: PUSH
16693: LD_VAR 0 2
16697: ARRAY
16698: PPUSH
16699: LD_INT 86
16701: PPUSH
16702: LD_INT 133
16704: PPUSH
16705: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16709: LD_VAR 0 5
16713: PUSH
16714: LD_VAR 0 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: LD_INT 8
16737: PPUSH
16738: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16742: LD_VAR 0 5
16746: PUSH
16747: LD_VAR 0 2
16751: ARRAY
16752: PPUSH
16753: LD_EXP 39
16757: PPUSH
16758: CALL_OW 179
// end ;
16762: GO 16595
16764: POP
16765: POP
// if GirlNewVeh then
16766: LD_EXP 57
16770: IFFALSE 16784
// SetSide ( GirlNewVeh , 4 ) ;
16772: LD_EXP 57
16776: PPUSH
16777: LD_INT 4
16779: PPUSH
16780: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16784: LD_INT 35
16786: PPUSH
16787: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16791: LD_VAR 0 9
16795: PPUSH
16796: LD_INT 95
16798: PUSH
16799: LD_INT 9
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: PUSH
16811: LD_INT 0
16813: EQUAL
16814: PUSH
16815: LD_EXP 39
16819: PPUSH
16820: LD_INT 9
16822: PPUSH
16823: CALL_OW 308
16827: NOT
16828: AND
16829: IFFALSE 16784
// wait ( 0 0$2 ) ;
16831: LD_INT 70
16833: PPUSH
16834: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16838: LD_VAR 0 9
16842: PPUSH
16843: LD_INT 1
16845: PPUSH
16846: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16850: LD_INT 21
16852: PUSH
16853: LD_INT 2
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 92
16862: PUSH
16863: LD_INT 83
16865: PUSH
16866: LD_INT 130
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PPUSH
16882: CALL_OW 69
16886: PPUSH
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 235
// Video ( false ) ;
16894: LD_INT 0
16896: PPUSH
16897: CALL 107942 0 1
// ChangeMissionObjectives ( M1 ) ;
16901: LD_STRING M1
16903: PPUSH
16904: CALL_OW 337
// SaveForQuickRestart ;
16908: CALL_OW 22
// missionStart := true ;
16912: LD_ADDR_EXP 13
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// missionStage := 2 ;
16920: LD_ADDR_EXP 15
16924: PUSH
16925: LD_INT 2
16927: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16928: LD_INT 105
16930: PPUSH
16931: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16935: LD_ADDR_VAR 0 5
16939: PUSH
16940: LD_INT 22
16942: PUSH
16943: LD_INT 4
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: LD_INT 21
16952: PUSH
16953: LD_INT 1
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 58
16973: DIFF
16974: ST_TO_ADDR
// if not tmp then
16975: LD_VAR 0 5
16979: NOT
16980: IFFALSE 16995
// tmp := [ Powell ] ;
16982: LD_ADDR_VAR 0 5
16986: PUSH
16987: LD_EXP 58
16991: PUSH
16992: EMPTY
16993: LIST
16994: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16995: LD_ADDR_EXP 110
16999: PUSH
17000: LD_EXP 110
17004: PPUSH
17005: LD_INT 4
17007: PPUSH
17008: LD_INT 22
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: LD_INT 21
17033: PUSH
17034: LD_INT 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PPUSH
17050: CALL_OW 69
17054: PUSH
17055: LD_EXP 58
17059: DIFF
17060: PPUSH
17061: CALL_OW 1
17065: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17066: LD_ADDR_VAR 0 4
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 34
17083: PUSH
17084: LD_INT 12
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17104: LD_VAR 0 5
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PPUSH
17113: CALL_OW 310
17117: IFFALSE 17132
// ComExitBuilding ( tmp [ 1 ] ) ;
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17132: LD_VAR 0 5
17136: PUSH
17137: LD_INT 1
17139: ARRAY
17140: PPUSH
17141: LD_VAR 0 4
17145: PPUSH
17146: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17150: LD_VAR 0 5
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_INT 80
17161: PPUSH
17162: LD_INT 136
17164: PPUSH
17165: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17169: LD_VAR 0 5
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PPUSH
17178: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17182: LD_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_INT 59
17193: PPUSH
17194: LD_INT 112
17196: PPUSH
17197: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17201: LD_VAR 0 5
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17214: LD_EXP 40
17218: PUSH
17219: LD_EXP 40
17223: PPUSH
17224: CALL_OW 255
17228: PUSH
17229: LD_INT 1
17231: EQUAL
17232: AND
17233: IFFALSE 17259
// begin Say ( Joan , D3W-Joan-1 ) ;
17235: LD_EXP 40
17239: PPUSH
17240: LD_STRING D3W-Joan-1
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17247: LD_EXP 39
17251: PPUSH
17252: LD_STRING D3W-JMM-1
17254: PPUSH
17255: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17259: LD_EXP 42
17263: PUSH
17264: LD_EXP 42
17268: PPUSH
17269: CALL_OW 255
17273: PUSH
17274: LD_INT 1
17276: EQUAL
17277: AND
17278: PUSH
17279: LD_EXP 42
17283: PUSH
17284: LD_EXP 59
17288: IN
17289: NOT
17290: AND
17291: IFFALSE 17317
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17293: LD_EXP 42
17297: PPUSH
17298: LD_STRING D3W-Lisa-1
17300: PPUSH
17301: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17305: LD_EXP 39
17309: PPUSH
17310: LD_STRING D3W-JMM-1
17312: PPUSH
17313: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17317: LD_EXP 54
17321: PUSH
17322: LD_EXP 54
17326: PPUSH
17327: CALL_OW 255
17331: PUSH
17332: LD_INT 1
17334: EQUAL
17335: AND
17336: IFFALSE 17362
// begin Say ( Connie , D3W-Con-1 ) ;
17338: LD_EXP 54
17342: PPUSH
17343: LD_STRING D3W-Con-1
17345: PPUSH
17346: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING D3W-JMM-1
17357: PPUSH
17358: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17362: LD_EXP 42
17366: PUSH
17367: LD_EXP 59
17371: IN
17372: PUSH
17373: LD_EXP 42
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Lisa , D3nW-Lisa-1 ) else
17389: LD_EXP 42
17393: PPUSH
17394: LD_STRING D3nW-Lisa-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17647
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17403: LD_EXP 45
17407: PUSH
17408: LD_EXP 59
17412: IN
17413: PUSH
17414: LD_EXP 45
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17430: LD_EXP 45
17434: PPUSH
17435: LD_STRING D3nW-Cyrus-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17647
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17444: LD_EXP 44
17448: PUSH
17449: LD_EXP 59
17453: IN
17454: PUSH
17455: LD_EXP 44
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Bobby , D3nW-Bobby-1 ) else
17471: LD_EXP 44
17475: PPUSH
17476: LD_STRING D3nW-Bobby-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17647
// if Gary in vip and GetSide ( Gary ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 59
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17526
// Say ( Gary , D3nW-Gary-1 ) else
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Gary-1
17519: PPUSH
17520: CALL_OW 88
17524: GO 17647
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17526: LD_EXP 43
17530: PUSH
17531: LD_EXP 59
17535: IN
17536: PUSH
17537: LD_EXP 43
17541: PPUSH
17542: CALL_OW 255
17546: PUSH
17547: LD_INT 1
17549: EQUAL
17550: AND
17551: IFFALSE 17567
// Say ( Donaldson , D3nW-Don-1 ) else
17553: LD_EXP 43
17557: PPUSH
17558: LD_STRING D3nW-Don-1
17560: PPUSH
17561: CALL_OW 88
17565: GO 17647
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17567: LD_EXP 50
17571: PUSH
17572: LD_EXP 59
17576: IN
17577: PUSH
17578: LD_EXP 50
17582: PPUSH
17583: CALL_OW 255
17587: PUSH
17588: LD_INT 1
17590: EQUAL
17591: AND
17592: IFFALSE 17608
// Say ( Cornel , D3nW-Corn-1 ) else
17594: LD_EXP 50
17598: PPUSH
17599: LD_STRING D3nW-Corn-1
17601: PPUSH
17602: CALL_OW 88
17606: GO 17647
// if Frank in vip and GetSide ( Frank ) = 1 then
17608: LD_EXP 52
17612: PUSH
17613: LD_EXP 59
17617: IN
17618: PUSH
17619: LD_EXP 52
17623: PPUSH
17624: CALL_OW 255
17628: PUSH
17629: LD_INT 1
17631: EQUAL
17632: AND
17633: IFFALSE 17647
// Say ( Frank , D3nW-Frank-1 ) ;
17635: LD_EXP 52
17639: PPUSH
17640: LD_STRING D3nW-Frank-1
17642: PPUSH
17643: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17647: LD_EXP 59
17651: PPUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 72
17666: IFFALSE 17692
// begin Say ( JMM , D3nW-JMM-1 ) ;
17668: LD_EXP 39
17672: PPUSH
17673: LD_STRING D3nW-JMM-1
17675: PPUSH
17676: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17680: LD_EXP 39
17684: PPUSH
17685: LD_STRING D3nW-JMM-1a
17687: PPUSH
17688: CALL_OW 88
// end ; t := 0 0$00 ;
17692: LD_ADDR_VAR 0 3
17696: PUSH
17697: LD_INT 0
17699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17700: LD_INT 35
17702: PPUSH
17703: CALL_OW 67
// t := t + 0 0$1 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 3
17716: PUSH
17717: LD_INT 35
17719: PLUS
17720: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17721: LD_INT 59
17723: PPUSH
17724: LD_INT 112
17726: PPUSH
17727: CALL_OW 428
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_INT 2100
17739: GREATER
17740: OR
17741: IFFALSE 17700
// activeAttacks := true ;
17743: LD_ADDR_EXP 16
17747: PUSH
17748: LD_INT 1
17750: ST_TO_ADDR
// end ;
17751: LD_VAR 0 1
17755: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17756: LD_INT 0
17758: PPUSH
// case question of 1 :
17759: LD_VAR 0 1
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17823
17772: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17773: LD_EXP 39
17777: PPUSH
17778: LD_STRING D2Mot-JMM-1
17780: PPUSH
17781: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17785: LD_EXP 58
17789: PPUSH
17790: LD_STRING D2Mot-Pow-1
17792: PPUSH
17793: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17797: LD_EXP 39
17801: PPUSH
17802: LD_STRING D2Mot-JMM-2
17804: PPUSH
17805: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17809: LD_EXP 58
17813: PPUSH
17814: LD_STRING D2Mot-Pow-2
17816: PPUSH
17817: CALL_OW 88
// end ; 2 :
17821: GO 18174
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17907
17831: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17832: LD_EXP 39
17836: PPUSH
17837: LD_STRING D2Rus-JMM-1
17839: PPUSH
17840: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17844: LD_EXP 58
17848: PPUSH
17849: LD_STRING D2Rus-Pow-1
17851: PPUSH
17852: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17856: LD_EXP 39
17860: PPUSH
17861: LD_STRING D2Rus-JMM-2
17863: PPUSH
17864: CALL_OW 88
// if not ( 3 in list_of_q ) then
17868: LD_INT 3
17870: PUSH
17871: LD_VAR 0 2
17875: IN
17876: NOT
17877: IFFALSE 17893
// Say ( Powell , D2Rus-Pow-2 ) else
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Rus-Pow-2
17886: PPUSH
17887: CALL_OW 88
17891: GO 17905
// Say ( Powell , D2Rus-Pow-2a ) ;
17893: LD_EXP 58
17897: PPUSH
17898: LD_STRING D2Rus-Pow-2a
17900: PPUSH
17901: CALL_OW 88
// end ; 3 :
17905: GO 18174
17907: LD_INT 3
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 18000
17915: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17916: LD_EXP 39
17920: PPUSH
17921: LD_STRING D2Leg-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17928: LD_EXP 58
17932: PPUSH
17933: LD_STRING D2Leg-Pow-1
17935: PPUSH
17936: CALL_OW 88
// if 2 in list_of_q then
17940: LD_INT 2
17942: PUSH
17943: LD_VAR 0 2
17947: IN
17948: IFFALSE 17974
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Leg-JMM-2
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Leg-Pow-2
17969: PPUSH
17970: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17974: LD_EXP 39
17978: PPUSH
17979: LD_STRING D2Leg-JMM-3
17981: PPUSH
17982: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17986: LD_EXP 58
17990: PPUSH
17991: LD_STRING D2Leg-Pow-3
17993: PPUSH
17994: CALL_OW 88
// end ; 4 :
17998: GO 18174
18000: LD_INT 4
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18083
18008: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18009: LD_EXP 39
18013: PPUSH
18014: LD_STRING D2Ar-JMM-1
18016: PPUSH
18017: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18021: LD_EXP 58
18025: PPUSH
18026: LD_STRING D2Ar-Pow-1
18028: PPUSH
18029: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18033: LD_EXP 39
18037: PPUSH
18038: LD_STRING D2Ar-JMM-2
18040: PPUSH
18041: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18045: LD_EXP 58
18049: PPUSH
18050: LD_STRING D2Ar-Pow-2
18052: PPUSH
18053: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18057: LD_EXP 39
18061: PPUSH
18062: LD_STRING D2Ar-JMM-3
18064: PPUSH
18065: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18069: LD_EXP 58
18073: PPUSH
18074: LD_STRING D2Ar-Pow-3
18076: PPUSH
18077: CALL_OW 88
// end ; 5 :
18081: GO 18174
18083: LD_INT 5
18085: DOUBLE
18086: EQUAL
18087: IFTRUE 18091
18089: GO 18106
18091: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18092: LD_EXP 39
18096: PPUSH
18097: LD_STRING D2Conf-JMM-1
18099: PPUSH
18100: CALL_OW 88
18104: GO 18174
18106: LD_INT 6
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18173
18114: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18115: LD_EXP 39
18119: PPUSH
18120: LD_STRING D2Com-JMM-1
18122: PPUSH
18123: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18127: LD_EXP 58
18131: PPUSH
18132: LD_STRING D2Com-Pow-1
18134: PPUSH
18135: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18139: LD_EXP 39
18143: PPUSH
18144: LD_STRING D2Com-JMM-2
18146: PPUSH
18147: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18151: LD_EXP 58
18155: PPUSH
18156: LD_STRING D2Com-Pow-2
18158: PPUSH
18159: CALL_OW 88
// powellAngerQuery := true ;
18163: LD_ADDR_EXP 36
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// end ;
18174: LD_VAR 0 3
18178: RET
// every 0 0$5 trigger missionStart do var tmp ;
18179: LD_EXP 13
18183: IFFALSE 18466
18185: GO 18187
18187: DISABLE
18188: LD_INT 0
18190: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18191: LD_INT 35
18193: PPUSH
18194: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18198: LD_INT 14
18200: PPUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: PUSH
18216: LD_EXP 15
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 4
18229: PUSH
18230: LD_INT 5
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: IN
18239: AND
18240: IFFALSE 18456
// begin powellAnger := powellAnger + 1 ;
18242: LD_ADDR_EXP 17
18246: PUSH
18247: LD_EXP 17
18251: PUSH
18252: LD_INT 1
18254: PLUS
18255: ST_TO_ADDR
// Video ( true ) ;
18256: LD_INT 1
18258: PPUSH
18259: CALL 107942 0 1
// CenterNowOnUnits ( tmp ) ;
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18272: LD_INT 14
18274: PPUSH
18275: LD_INT 22
18277: PUSH
18278: LD_INT 1
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 70
18289: PPUSH
18290: LD_INT 86
18292: PPUSH
18293: LD_INT 133
18295: PPUSH
18296: CALL_OW 111
// async ;
18300: ASYNC
// case powellAnger of 1 :
18301: LD_EXP 17
18305: PUSH
18306: LD_INT 1
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18329
18314: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18315: LD_EXP 58
18319: PPUSH
18320: LD_STRING DBack1-Pow-1
18322: PPUSH
18323: CALL_OW 88
18327: GO 18376
18329: LD_INT 2
18331: DOUBLE
18332: EQUAL
18333: IFTRUE 18337
18335: GO 18352
18337: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18338: LD_EXP 58
18342: PPUSH
18343: LD_STRING DBack2-Pow-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18376
18352: LD_INT 3
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18375
18360: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18361: LD_EXP 58
18365: PPUSH
18366: LD_STRING DBack3-Pow-1
18368: PPUSH
18369: CALL_OW 88
18373: GO 18376
18375: POP
// sync ;
18376: SYNC
// repeat wait ( 0 0$1 ) ;
18377: LD_INT 35
18379: PPUSH
18380: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18412: LD_INT 14
18414: PPUSH
18415: LD_INT 22
18417: PUSH
18418: LD_INT 1
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PPUSH
18425: CALL_OW 70
18429: NOT
18430: IFFALSE 18377
// if powellAnger >= 3 then
18432: LD_EXP 17
18436: PUSH
18437: LD_INT 3
18439: GREATEREQUAL
18440: IFFALSE 18449
// YouLost ( Dismissed ) ;
18442: LD_STRING Dismissed
18444: PPUSH
18445: CALL_OW 104
// Video ( false ) ;
18449: LD_INT 0
18451: PPUSH
18452: CALL 107942 0 1
// end ; until missionStage > 5 ;
18456: LD_EXP 15
18460: PUSH
18461: LD_INT 5
18463: GREATER
18464: IFFALSE 18191
// end ;
18466: PPOPN 1
18468: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18469: LD_EXP 13
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: LD_INT 4
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 21
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 69
18502: PUSH
18503: LD_INT 4
18505: GREATEREQUAL
18506: AND
18507: PUSH
18508: LD_EXP 15
18512: PUSH
18513: LD_INT 2
18515: EQUAL
18516: AND
18517: IFFALSE 20340
18519: GO 18521
18521: DISABLE
18522: LD_INT 0
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin missionStage := 3 ;
18532: LD_ADDR_EXP 15
18536: PUSH
18537: LD_INT 3
18539: ST_TO_ADDR
// retreat := false ;
18540: LD_ADDR_VAR 0 4
18544: PUSH
18545: LD_INT 0
18547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18548: LD_ADDR_VAR 0 5
18552: PUSH
18553: LD_INT 22
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_INT 22
18589: PUSH
18590: LD_INT 4
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: LD_INT 30
18599: PUSH
18600: LD_INT 5
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PPUSH
18611: CALL_OW 69
18615: ST_TO_ADDR
// if not bar then
18616: LD_VAR 0 6
18620: NOT
18621: IFFALSE 18674
// begin repeat wait ( 0 0$1 ) ;
18623: LD_INT 35
18625: PPUSH
18626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 3
18642: PUSH
18643: LD_INT 57
18645: PUSH
18646: EMPTY
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 30
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: LIST
18667: PPUSH
18668: CALL_OW 69
18672: IFFALSE 18623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18674: LD_ADDR_VAR 0 6
18678: PUSH
18679: LD_INT 22
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: LD_INT 30
18691: PUSH
18692: LD_INT 5
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PPUSH
18703: CALL_OW 69
18707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18708: LD_INT 35
18710: PPUSH
18711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18715: LD_EXP 129
18719: PUSH
18720: LD_INT 4
18722: ARRAY
18723: PUSH
18724: LD_INT 4
18726: GREATEREQUAL
18727: IFFALSE 18708
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18729: LD_ADDR_VAR 0 2
18733: PUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 25
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 25
18779: PUSH
18780: LD_INT 4
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 5
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PUSH
18814: LD_EXP 58
18818: PUSH
18819: LD_EXP 59
18823: ADD
18824: DIFF
18825: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_VAR 0 2
18835: PPUSH
18836: LD_INT 26
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 72
18850: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18851: LD_ADDR_VAR 0 2
18855: PUSH
18856: LD_VAR 0 2
18860: PUSH
18861: LD_VAR 0 3
18865: DIFF
18866: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 2
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL 106595 0 2
18884: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18885: LD_ADDR_VAR 0 3
18889: PUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_INT 1
18897: PPUSH
18898: CALL 106595 0 2
18902: ST_TO_ADDR
// for i = 1 to 4 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 4
18915: PUSH
18916: FOR_TO
18917: IFFALSE 19083
// begin if tmp2 then
18919: LD_VAR 0 3
18923: IFFALSE 19004
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18925: LD_ADDR_EXP 18
18929: PUSH
18930: LD_EXP 18
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: LD_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ARRAY
18946: PUSH
18947: LD_VAR 0 3
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: ADD
18958: PPUSH
18959: CALL_OW 1
18963: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 3
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_VAR 0 3
18991: PPUSH
18992: LD_VAR 0 3
18996: PPUSH
18997: CALL_OW 3
19001: ST_TO_ADDR
// end else
19002: GO 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19004: LD_ADDR_EXP 18
19008: PUSH
19009: LD_EXP 18
19013: PPUSH
19014: LD_INT 1
19016: PPUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PUSH
19026: LD_VAR 0 2
19030: PUSH
19031: LD_VAR 0 2
19035: ARRAY
19036: ADD
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 2
19052: ARRAY
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: LD_VAR 0 2
19075: PPUSH
19076: CALL_OW 3
19080: ST_TO_ADDR
// end ; end ;
19081: GO 18916
19083: POP
19084: POP
// if tmp2 then
19085: LD_VAR 0 3
19089: IFFALSE 19107
// tmp := tmp union tmp2 ;
19091: LD_ADDR_VAR 0 2
19095: PUSH
19096: LD_VAR 0 2
19100: PUSH
19101: LD_VAR 0 3
19105: UNION
19106: ST_TO_ADDR
// for i = 1 to 4 do
19107: LD_ADDR_VAR 0 1
19111: PUSH
19112: DOUBLE
19113: LD_INT 1
19115: DEC
19116: ST_TO_ADDR
19117: LD_INT 4
19119: PUSH
19120: FOR_TO
19121: IFFALSE 19170
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19123: LD_ADDR_EXP 18
19127: PUSH
19128: LD_EXP 18
19132: PPUSH
19133: LD_INT 2
19135: PPUSH
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PUSH
19145: LD_VAR 0 2
19149: PUSH
19150: LD_VAR 0 2
19154: PUSH
19155: LD_VAR 0 1
19159: MINUS
19160: ARRAY
19161: ADD
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
19168: GO 19120
19170: POP
19171: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19172: LD_ADDR_EXP 110
19176: PUSH
19177: LD_EXP 110
19181: PPUSH
19182: LD_INT 4
19184: PPUSH
19185: LD_EXP 110
19189: PUSH
19190: LD_INT 4
19192: ARRAY
19193: PUSH
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: DIFF
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 313
19222: IFFALSE 19277
// begin for i in UnitsInside ( arm [ 1 ] ) do
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_VAR 0 5
19233: PUSH
19234: LD_INT 1
19236: ARRAY
19237: PPUSH
19238: CALL_OW 313
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19275
// begin ComExitBuilding ( i ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_VAR 0 6
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: CALL_OW 180
// end ;
19273: GO 19243
19275: POP
19276: POP
// end ; wait ( 0 0$3 ) ;
19277: LD_INT 105
19279: PPUSH
19280: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19284: LD_ADDR_VAR 0 1
19288: PUSH
19289: LD_EXP 18
19293: PUSH
19294: LD_INT 1
19296: ARRAY
19297: PUSH
19298: FOR_IN
19299: IFFALSE 19406
// begin if IsInUnit ( i ) then
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 310
19310: IFFALSE 19321
// ComExitBuilding ( i ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 122
// if GetClass ( i ) <> 1 then
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 257
19330: PUSH
19331: LD_INT 1
19333: NONEQUAL
19334: IFFALSE 19375
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 1
19361: PPUSH
19362: CALL_OW 183
// AddComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 60
19382: PPUSH
19383: LD_INT 94
19385: PPUSH
19386: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_EXP 58
19399: PPUSH
19400: CALL_OW 179
// end ;
19404: GO 19298
19406: POP
19407: POP
// wait ( 0 0$15 ) ;
19408: LD_INT 525
19410: PPUSH
19411: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19415: LD_EXP 58
19419: PPUSH
19420: LD_STRING D4-Pow-1
19422: PPUSH
19423: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19427: LD_ADDR_VAR 0 2
19431: PUSH
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 26
19443: PUSH
19444: LD_INT 1
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: ST_TO_ADDR
// if tmp then
19456: LD_VAR 0 2
19460: IFFALSE 19478
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19462: LD_VAR 0 2
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: LD_STRING D4-Sol1-1
19473: PPUSH
19474: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19478: LD_EXP 58
19482: PPUSH
19483: LD_STRING D4-Pow-2
19485: PPUSH
19486: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: DOUBLE
19496: LD_INT 1
19498: DEC
19499: ST_TO_ADDR
19500: LD_EXP 18
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19603
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19512: LD_EXP 18
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PPUSH
19527: LD_EXP 129
19531: PUSH
19532: LD_INT 4
19534: ARRAY
19535: PUSH
19536: LD_INT 1
19538: ARRAY
19539: PPUSH
19540: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19544: LD_ADDR_EXP 129
19548: PUSH
19549: LD_EXP 129
19553: PPUSH
19554: LD_INT 4
19556: PPUSH
19557: LD_EXP 129
19561: PUSH
19562: LD_INT 4
19564: ARRAY
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19579: LD_INT 8
19581: PPUSH
19582: LD_EXP 18
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 471
// end ;
19601: GO 19509
19603: POP
19604: POP
// repeat wait ( 0 0$1 ) ;
19605: LD_INT 35
19607: PPUSH
19608: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PPUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PPUSH
19627: CALL_OW 72
19631: PUSH
19632: LD_INT 4
19634: GREATEREQUAL
19635: IFFALSE 19605
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19637: LD_EXP 18
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 69
19648: PPUSH
19649: LD_INT 94
19651: PPUSH
19652: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19656: LD_EXP 18
19660: PUSH
19661: LD_INT 1
19663: ARRAY
19664: PPUSH
19665: LD_INT 82
19667: PPUSH
19668: LD_INT 83
19670: PPUSH
19671: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19675: LD_EXP 18
19679: PUSH
19680: LD_INT 1
19682: ARRAY
19683: PPUSH
19684: LD_INT 77
19686: PPUSH
19687: LD_INT 69
19689: PPUSH
19690: CALL_OW 174
// repeat wait ( 3 ) ;
19694: LD_INT 3
19696: PPUSH
19697: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19701: LD_ADDR_VAR 0 1
19705: PUSH
19706: LD_EXP 18
19710: PUSH
19711: LD_INT 1
19713: ARRAY
19714: PUSH
19715: FOR_IN
19716: IFFALSE 19852
// begin if GetLives ( i ) < 990 then
19718: LD_VAR 0 1
19722: PPUSH
19723: CALL_OW 256
19727: PUSH
19728: LD_INT 990
19730: LESS
19731: IFFALSE 19745
// SetLives ( i , 1000 ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_INT 1000
19740: PPUSH
19741: CALL_OW 234
// if not IsInUnit ( i ) then
19745: LD_VAR 0 1
19749: PPUSH
19750: CALL_OW 310
19754: NOT
19755: IFFALSE 19850
// begin if not HasTask ( i ) then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 314
19766: NOT
19767: IFFALSE 19784
// ComMoveXY ( i , 64 , 93 ) ;
19769: LD_VAR 0 1
19773: PPUSH
19774: LD_INT 64
19776: PPUSH
19777: LD_INT 93
19779: PPUSH
19780: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19784: LD_VAR 0 4
19788: NOT
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 258
19799: PUSH
19800: LD_INT 1
19802: EQUAL
19803: AND
19804: IFFALSE 19850
// begin retreat := true ;
19806: LD_ADDR_VAR 0 4
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19814: LD_VAR 0 1
19818: PPUSH
19819: LD_INT 2
19821: PPUSH
19822: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_STRING D4a-Sol1-1
19833: PPUSH
19834: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19838: LD_EXP 58
19842: PPUSH
19843: LD_STRING D4a-Pow-1
19845: PPUSH
19846: CALL_OW 88
// end ; end ; end ;
19850: GO 19715
19852: POP
19853: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19854: LD_EXP 18
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 95
19865: PUSH
19866: LD_INT 9
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: PUSH
19873: LD_INT 3
19875: PUSH
19876: LD_INT 55
19878: PUSH
19879: EMPTY
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PPUSH
19890: CALL_OW 72
19894: PUSH
19895: LD_INT 4
19897: GREATEREQUAL
19898: IFFALSE 19694
// for i in powellSquadAttack [ 1 ] do
19900: LD_ADDR_VAR 0 1
19904: PUSH
19905: LD_EXP 18
19909: PUSH
19910: LD_INT 1
19912: ARRAY
19913: PUSH
19914: FOR_IN
19915: IFFALSE 20051
// begin if GetTag ( i ) = 2 then
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 110
19926: PUSH
19927: LD_INT 2
19929: EQUAL
19930: IFFALSE 19992
// begin ComMoveXY ( i , 60 , 94 ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 60
19939: PPUSH
19940: LD_INT 94
19942: PPUSH
19943: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_EXP 58
19956: PPUSH
19957: CALL_OW 179
// wait ( 0 0$3 ) ;
19961: LD_INT 105
19963: PPUSH
19964: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19968: LD_VAR 0 1
19972: PPUSH
19973: LD_STRING D4a-Sol1-2
19975: PPUSH
19976: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19980: LD_EXP 58
19984: PPUSH
19985: LD_STRING D4a-Pow-2
19987: PPUSH
19988: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 0
19999: PPUSH
20000: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20004: LD_ADDR_EXP 110
20008: PUSH
20009: LD_EXP 110
20013: PPUSH
20014: LD_INT 4
20016: PPUSH
20017: LD_EXP 110
20021: PUSH
20022: LD_INT 4
20024: ARRAY
20025: PUSH
20026: LD_VAR 0 1
20030: UNION
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20037: LD_INT 8
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 472
// end ;
20049: GO 19914
20051: POP
20052: POP
// wait ( 4 4$00 ) ;
20053: LD_INT 8400
20055: PPUSH
20056: CALL_OW 67
// uc_side := 6 ;
20060: LD_ADDR_OWVAR 20
20064: PUSH
20065: LD_INT 6
20067: ST_TO_ADDR
// uc_nation := 3 ;
20068: LD_ADDR_OWVAR 21
20072: PUSH
20073: LD_INT 3
20075: ST_TO_ADDR
// ru := [ ] ;
20076: LD_ADDR_VAR 0 7
20080: PUSH
20081: EMPTY
20082: ST_TO_ADDR
// for i = 1 to 4 do
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_INT 4
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20198
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20099: LD_INT 22
20101: PPUSH
20102: LD_INT 1
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 43
20110: PUSH
20111: LD_INT 44
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: CALL_OW 12
20128: ARRAY
20129: PPUSH
20130: LD_INT 89
20132: PPUSH
20133: CALL 72215 0 5
// un := CreateVehicle ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: CALL_OW 45
20146: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20147: LD_VAR 0 8
20151: PPUSH
20152: LD_INT 4
20154: PPUSH
20155: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20159: LD_VAR 0 8
20163: PPUSH
20164: LD_INT 136
20166: PPUSH
20167: LD_INT 90
20169: PPUSH
20170: LD_INT 8
20172: PPUSH
20173: LD_INT 0
20175: PPUSH
20176: CALL_OW 50
// ru := ru ^ un ;
20180: LD_ADDR_VAR 0 7
20184: PUSH
20185: LD_VAR 0 7
20189: PUSH
20190: LD_VAR 0 8
20194: ADD
20195: ST_TO_ADDR
// end ;
20196: GO 20096
20198: POP
20199: POP
// if ru then
20200: LD_VAR 0 7
20204: IFFALSE 20221
// ComAgressiveMove ( ru , 80 , 92 ) ;
20206: LD_VAR 0 7
20210: PPUSH
20211: LD_INT 80
20213: PPUSH
20214: LD_INT 92
20216: PPUSH
20217: CALL_OW 114
// wait ( 8 8$00 ) ;
20221: LD_INT 16800
20223: PPUSH
20224: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20228: LD_INT 4
20230: PPUSH
20231: LD_INT 3
20233: PUSH
20234: LD_INT 1
20236: PUSH
20237: LD_INT 1
20239: PUSH
20240: LD_INT 5
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 6
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: PUSH
20267: LD_INT 4
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 1
20275: PUSH
20276: LD_INT 7
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: PUSH
20285: LD_INT 3
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 1
20293: PUSH
20294: LD_INT 7
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 3
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 1
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL 58588 0 2
// missionStage := 4 ;
20332: LD_ADDR_EXP 15
20336: PUSH
20337: LD_INT 4
20339: ST_TO_ADDR
// end ;
20340: PPOPN 8
20342: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20343: LD_EXP 15
20347: PUSH
20348: LD_INT 4
20350: EQUAL
20351: PUSH
20352: LD_INT 22
20354: PUSH
20355: LD_INT 4
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: PUSH
20362: LD_INT 21
20364: PUSH
20365: LD_INT 2
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: PUSH
20381: LD_INT 5
20383: GREATEREQUAL
20384: AND
20385: IFFALSE 24490
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
20394: PPUSH
20395: PPUSH
20396: PPUSH
20397: PPUSH
20398: PPUSH
20399: PPUSH
20400: PPUSH
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
// begin missionStage := 5 ;
20405: LD_ADDR_EXP 15
20409: PUSH
20410: LD_INT 5
20412: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20413: LD_ADDR_VAR 0 10
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 4
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 4
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 5
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20465: LD_ADDR_VAR 0 6
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 4
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 21
20482: PUSH
20483: LD_INT 1
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: LD_INT 25
20495: PUSH
20496: LD_INT 16
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 3
20509: PUSH
20510: LD_INT 25
20512: PUSH
20513: LD_INT 12
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 69
20534: PUSH
20535: LD_EXP 58
20539: DIFF
20540: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 22
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 3
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20579: LD_INT 35
20581: PPUSH
20582: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20586: LD_EXP 129
20590: PUSH
20591: LD_INT 4
20593: ARRAY
20594: PUSH
20595: LD_INT 5
20597: GREATEREQUAL
20598: PUSH
20599: LD_EXP 129
20603: PUSH
20604: LD_INT 4
20606: ARRAY
20607: PPUSH
20608: LD_INT 58
20610: PUSH
20611: EMPTY
20612: LIST
20613: PPUSH
20614: CALL_OW 72
20618: PUSH
20619: LD_INT 5
20621: GREATEREQUAL
20622: AND
20623: IFFALSE 20579
// powellAllowRetreat := false ;
20625: LD_ADDR_EXP 19
20629: PUSH
20630: LD_INT 0
20632: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20633: LD_INT 700
20635: PPUSH
20636: CALL_OW 67
// activeAttacks := false ;
20640: LD_ADDR_EXP 16
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20648: LD_INT 35
20650: PPUSH
20651: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20655: LD_INT 22
20657: PUSH
20658: LD_INT 6
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 0
20672: EQUAL
20673: IFFALSE 20648
// tmp := mc_vehicles [ 4 ] ;
20675: LD_ADDR_VAR 0 3
20679: PUSH
20680: LD_EXP 129
20684: PUSH
20685: LD_INT 4
20687: ARRAY
20688: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20689: LD_ADDR_VAR 0 1
20693: PUSH
20694: DOUBLE
20695: LD_INT 1
20697: DEC
20698: ST_TO_ADDR
20699: LD_EXP 18
20703: PUSH
20704: FOR_TO
20705: IFFALSE 20966
// begin for j in powellSquadAttack [ i ] do
20707: LD_ADDR_VAR 0 2
20711: PUSH
20712: LD_EXP 18
20716: PUSH
20717: LD_VAR 0 1
20721: ARRAY
20722: PUSH
20723: FOR_IN
20724: IFFALSE 20962
// begin forces := forces diff j ;
20726: LD_ADDR_VAR 0 6
20730: PUSH
20731: LD_VAR 0 6
20735: PUSH
20736: LD_VAR 0 2
20740: DIFF
20741: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 109
// wait ( 0 0$2 ) ;
20754: LD_INT 70
20756: PPUSH
20757: CALL_OW 67
// if IsInUnit ( j ) then
20761: LD_VAR 0 2
20765: PPUSH
20766: CALL_OW 310
20770: IFFALSE 20781
// ComExitBuilding ( j ) ;
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL_OW 122
// if GetClass ( j ) <> 1 then
20781: LD_VAR 0 2
20785: PPUSH
20786: CALL_OW 257
20790: PUSH
20791: LD_INT 1
20793: NONEQUAL
20794: IFFALSE 20874
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20796: LD_VAR 0 10
20800: PUSH
20801: LD_INT 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 313
20809: PUSH
20810: LD_INT 5
20812: GREATEREQUAL
20813: IFFALSE 20835
// AddComEnterUnit ( j , arm [ 2 ] ) else
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: CALL_OW 180
20833: GO 20853
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 10
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: CALL_OW 183
// AddComExitBuilding ( j ) ;
20865: LD_VAR 0 2
20869: PPUSH
20870: CALL_OW 182
// end ; if i = 2 then
20874: LD_VAR 0 1
20878: PUSH
20879: LD_INT 2
20881: EQUAL
20882: IFFALSE 20899
// AddComMoveXY ( j , 61 , 93 ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: LD_INT 61
20891: PPUSH
20892: LD_INT 93
20894: PPUSH
20895: CALL_OW 171
// if i = 1 then
20899: LD_VAR 0 1
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20960
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 3
20918: PUSH
20919: LD_INT 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20927: LD_ADDR_VAR 0 3
20931: PUSH
20932: LD_VAR 0 3
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 3
20944: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 69
20952: PPUSH
20953: LD_INT 94
20955: PPUSH
20956: CALL_OW 171
// end ; end ;
20960: GO 20723
20962: POP
20963: POP
// end ;
20964: GO 20704
20966: POP
20967: POP
// wait ( 0 0$55 ) ;
20968: LD_INT 1925
20970: PPUSH
20971: CALL_OW 67
// MC_Kill ( 4 ) ;
20975: LD_INT 4
20977: PPUSH
20978: CALL 35176 0 1
// tmp := UnitsInside ( fac ) ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_VAR 0 9
20991: PPUSH
20992: CALL_OW 313
20996: ST_TO_ADDR
// if tmp then
20997: LD_VAR 0 3
21001: IFFALSE 21122
// for i in tmp do
21003: LD_ADDR_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: PUSH
21013: FOR_IN
21014: IFFALSE 21120
// begin ComExitBuilding ( i ) ;
21016: LD_VAR 0 1
21020: PPUSH
21021: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21025: LD_VAR 0 10
21029: PUSH
21030: LD_INT 2
21032: ARRAY
21033: PPUSH
21034: CALL_OW 313
21038: PUSH
21039: LD_INT 6
21041: LESS
21042: IFFALSE 21064
// AddComEnterUnit ( i , arm [ 2 ] ) else
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_VAR 0 10
21053: PUSH
21054: LD_INT 2
21056: ARRAY
21057: PPUSH
21058: CALL_OW 180
21062: GO 21118
// if UnitsInside ( arm [ 1 ] ) < 6 then
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: CALL_OW 313
21077: PUSH
21078: LD_INT 6
21080: LESS
21081: IFFALSE 21103
// AddComEnterUnit ( i , arm [ 1 ] ) else
21083: LD_VAR 0 1
21087: PPUSH
21088: LD_VAR 0 10
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PPUSH
21097: CALL_OW 180
21101: GO 21118
// AddComMoveXY ( i , 37 , 68 ) ;
21103: LD_VAR 0 1
21107: PPUSH
21108: LD_INT 37
21110: PPUSH
21111: LD_INT 68
21113: PPUSH
21114: CALL_OW 171
// end ;
21118: GO 21013
21120: POP
21121: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21122: LD_ADDR_VAR 0 11
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_INT 26
21134: PUSH
21135: LD_INT 1
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 72
21146: PUSH
21147: LD_EXP 59
21151: DIFF
21152: ST_TO_ADDR
// if not speaker then
21153: LD_VAR 0 11
21157: NOT
21158: IFFALSE 21185
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21160: LD_ADDR_VAR 0 11
21164: PUSH
21165: LD_VAR 0 6
21169: PPUSH
21170: LD_INT 26
21172: PUSH
21173: LD_INT 1
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// if speaker then
21185: LD_VAR 0 11
21189: IFFALSE 21205
// speaker := speaker [ 1 ] ;
21191: LD_ADDR_VAR 0 11
21195: PUSH
21196: LD_VAR 0 11
21200: PUSH
21201: LD_INT 1
21203: ARRAY
21204: ST_TO_ADDR
// Video ( true ) ;
21205: LD_INT 1
21207: PPUSH
21208: CALL 107942 0 1
// CenterNowOnUnits ( Powell ) ;
21212: LD_EXP 58
21216: PPUSH
21217: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 6
21230: PPUSH
21231: LD_INT 3
21233: PUSH
21234: LD_INT 25
21236: PUSH
21237: LD_INT 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PPUSH
21248: CALL_OW 72
21252: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21253: LD_ADDR_VAR 0 12
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 32
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 58
21280: PUSH
21281: EMPTY
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// for i = 1 to 6 do
21294: LD_ADDR_VAR 0 1
21298: PUSH
21299: DOUBLE
21300: LD_INT 1
21302: DEC
21303: ST_TO_ADDR
21304: LD_INT 6
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21449
// begin if IsInUnit ( tmp [ i ] ) then
21310: LD_VAR 0 3
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: CALL_OW 310
21325: IFFALSE 21342
// ComExitBuilding ( tmp [ i ] ) ;
21327: LD_VAR 0 3
21331: PUSH
21332: LD_VAR 0 1
21336: ARRAY
21337: PPUSH
21338: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: LD_VAR 0 10
21357: PUSH
21358: LD_INT 1
21360: ARRAY
21361: PPUSH
21362: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 1
21375: ARRAY
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL_OW 183
// if emp_towers then
21384: LD_VAR 0 12
21388: IFFALSE 21447
// begin AddComExitBuilding ( tmp [ i ] ) ;
21390: LD_VAR 0 3
21394: PUSH
21395: LD_VAR 0 1
21399: ARRAY
21400: PPUSH
21401: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 12
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21429: LD_ADDR_VAR 0 12
21433: PUSH
21434: LD_VAR 0 12
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 3
21446: ST_TO_ADDR
// end ; end ;
21447: GO 21307
21449: POP
21450: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21451: LD_ADDR_VAR 0 3
21455: PUSH
21456: LD_EXP 18
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PUSH
21465: LD_EXP 18
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: ADD
21474: PPUSH
21475: LD_INT 26
21477: PUSH
21478: LD_INT 1
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: PPUSH
21485: CALL_OW 72
21489: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_EXP 18
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21523
// ComTurnUnit ( i , Powell ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_EXP 58
21516: PPUSH
21517: CALL_OW 119
21521: GO 21504
21523: POP
21524: POP
// Say ( Powell , D5-Pow-1 ) ;
21525: LD_EXP 58
21529: PPUSH
21530: LD_STRING D5-Pow-1
21532: PPUSH
21533: CALL_OW 88
// if tmp then
21537: LD_VAR 0 3
21541: IFFALSE 21559
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: ARRAY
21551: PPUSH
21552: LD_STRING D5-Sol2-1
21554: PPUSH
21555: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21559: LD_EXP 58
21563: PPUSH
21564: LD_STRING D5-Pow-2
21566: PPUSH
21567: CALL_OW 88
// if tmp > 1 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 1
21578: GREATER
21579: IFFALSE 21597
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21581: LD_VAR 0 3
21585: PUSH
21586: LD_INT 2
21588: ARRAY
21589: PPUSH
21590: LD_STRING D5-Sol2-2
21592: PPUSH
21593: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21597: LD_EXP 58
21601: PPUSH
21602: LD_STRING D5-Pow-3
21604: PPUSH
21605: CALL_OW 88
// wait ( 0 0$1 ) ;
21609: LD_INT 35
21611: PPUSH
21612: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21616: LD_ADDR_VAR 0 3
21620: PUSH
21621: LD_EXP 18
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PUSH
21630: LD_EXP 18
21634: PUSH
21635: LD_INT 2
21637: ARRAY
21638: UNION
21639: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21640: LD_VAR 0 3
21644: PPUSH
21645: LD_INT 80
21647: PPUSH
21648: LD_INT 67
21650: PPUSH
21651: CALL_OW 114
// wait ( 0 0$2 ) ;
21655: LD_INT 70
21657: PPUSH
21658: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21662: LD_INT 79
21664: PPUSH
21665: LD_INT 72
21667: PPUSH
21668: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21672: LD_INT 35
21674: PPUSH
21675: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_INT 3
21686: PUSH
21687: LD_INT 24
21689: PUSH
21690: LD_INT 1000
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PPUSH
21701: CALL_OW 72
21705: IFFALSE 21672
// Say ( Powell , D5a-Pow-1 ) ;
21707: LD_EXP 58
21711: PPUSH
21712: LD_STRING D5a-Pow-1
21714: PPUSH
21715: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21719: LD_EXP 58
21723: PPUSH
21724: LD_STRING D5a-Pow-1a
21726: PPUSH
21727: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21731: LD_INT 10
21733: PPUSH
21734: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21738: LD_EXP 58
21742: PPUSH
21743: LD_STRING D5a-Pow-1b
21745: PPUSH
21746: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21750: LD_EXP 58
21754: PPUSH
21755: LD_STRING D5a-Pow-1c
21757: PPUSH
21758: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21762: LD_EXP 58
21766: PPUSH
21767: LD_STRING D5a-Pow-1d
21769: PPUSH
21770: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21774: LD_INT 35
21776: PPUSH
21777: CALL_OW 67
// if not HasTask ( tmp ) then
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 314
21790: NOT
21791: IFFALSE 21808
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_INT 80
21800: PPUSH
21801: LD_INT 67
21803: PPUSH
21804: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 24
21815: PUSH
21816: LD_INT 1
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: IFFALSE 21774
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 22
21837: PUSH
21838: LD_INT 4
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PUSH
21845: LD_INT 92
21847: PUSH
21848: LD_INT 60
21850: PUSH
21851: LD_INT 93
21853: PUSH
21854: LD_INT 10
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: LIST
21862: PUSH
21863: LD_INT 3
21865: PUSH
21866: LD_INT 54
21868: PUSH
21869: EMPTY
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 69
21885: PUSH
21886: LD_EXP 58
21890: DIFF
21891: ST_TO_ADDR
// if tmp then
21892: LD_VAR 0 3
21896: IFFALSE 21930
// for i in tmp do
21898: LD_ADDR_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: PUSH
21908: FOR_IN
21909: IFFALSE 21928
// ComMoveXY ( i , 36 , 67 ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: LD_INT 36
21918: PPUSH
21919: LD_INT 67
21921: PPUSH
21922: CALL_OW 111
21926: GO 21908
21928: POP
21929: POP
// wait ( 0 0$3 ) ;
21930: LD_INT 105
21932: PPUSH
21933: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21937: LD_VAR 0 11
21941: PPUSH
21942: LD_STRING D6-Sol3-1
21944: PPUSH
21945: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21949: LD_EXP 58
21953: PPUSH
21954: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21958: LD_EXP 58
21962: PPUSH
21963: LD_STRING D6-Pow-1
21965: PPUSH
21966: CALL_OW 88
// tmp := [ ] ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: EMPTY
21976: ST_TO_ADDR
// for i = 1 to 2 do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: DOUBLE
21983: LD_INT 1
21985: DEC
21986: ST_TO_ADDR
21987: LD_INT 2
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22105
// begin uc_side := 8 ;
21993: LD_ADDR_OWVAR 20
21997: PUSH
21998: LD_INT 8
22000: ST_TO_ADDR
// uc_nation := 2 ;
22001: LD_ADDR_OWVAR 21
22005: PUSH
22006: LD_INT 2
22008: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22009: LD_INT 14
22011: PPUSH
22012: LD_INT 3
22014: PPUSH
22015: LD_INT 2
22017: PPUSH
22018: LD_INT 29
22020: PPUSH
22021: LD_INT 100
22023: PPUSH
22024: CALL 72215 0 5
// veh := CreateVehicle ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: CALL_OW 45
22037: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22038: LD_VAR 0 13
22042: PPUSH
22043: LD_INT 4
22045: PPUSH
22046: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22050: LD_VAR 0 13
22054: PPUSH
22055: LD_INT 99
22057: PPUSH
22058: LD_INT 83
22060: PPUSH
22061: LD_INT 6
22063: PPUSH
22064: LD_INT 0
22066: PPUSH
22067: CALL_OW 50
// wait ( 3 ) ;
22071: LD_INT 3
22073: PPUSH
22074: CALL_OW 67
// Connect ( veh ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: CALL 75270 0 1
// tmp := tmp ^ veh ;
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: PUSH
22097: LD_VAR 0 13
22101: ADD
22102: ST_TO_ADDR
// end ;
22103: GO 21990
22105: POP
22106: POP
// wait ( 0 0$1 ) ;
22107: LD_INT 35
22109: PPUSH
22110: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22114: LD_INT 99
22116: PPUSH
22117: LD_INT 83
22119: PPUSH
22120: LD_INT 1
22122: PPUSH
22123: LD_INT 10
22125: PPUSH
22126: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22130: LD_INT 99
22132: PPUSH
22133: LD_INT 83
22135: PPUSH
22136: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_STRING D6-Sol3-2
22147: PPUSH
22148: CALL_OW 88
// async ;
22152: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22153: LD_EXP 58
22157: PPUSH
22158: LD_STRING D6-Pow-2
22160: PPUSH
22161: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: PPUSH
22174: LD_VAR 0 9
22178: PPUSH
22179: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: ARRAY
22191: PPUSH
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 21
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PPUSH
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 2
22228: ARRAY
22229: PPUSH
22230: CALL_OW 74
22234: PPUSH
22235: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22239: LD_EXP 58
22243: PPUSH
22244: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 331
// repeat wait ( 4 ) ;
22261: LD_INT 4
22263: PPUSH
22264: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22268: LD_VAR 0 3
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22303
// SetLives ( tmp [ 1 ] , 1000 ) ;
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_INT 1000
22298: PPUSH
22299: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22303: LD_INT 22
22305: PUSH
22306: LD_INT 4
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 3
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PPUSH
22327: CALL_OW 69
22331: PUSH
22332: LD_INT 0
22334: EQUAL
22335: IFFALSE 22261
// sync ;
22337: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22338: LD_EXP 58
22342: PPUSH
22343: LD_STRING D6a-Pow-1
22345: PPUSH
22346: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22350: LD_VAR 0 11
22354: PPUSH
22355: LD_STRING D6a-Sol3-1
22357: PPUSH
22358: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22362: LD_EXP 58
22366: PPUSH
22367: LD_STRING D6a-Pow-2
22369: PPUSH
22370: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22374: LD_VAR 0 11
22378: PPUSH
22379: LD_STRING D6a-Sol3-2
22381: PPUSH
22382: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22386: LD_EXP 58
22390: PPUSH
22391: LD_STRING D6a-Pow-3
22393: PPUSH
22394: CALL_OW 88
// powellCenterCameraMode := true ;
22398: LD_ADDR_EXP 20
22402: PUSH
22403: LD_INT 1
22405: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22406: LD_ADDR_VAR 0 1
22410: PUSH
22411: LD_INT 22
22413: PUSH
22414: LD_INT 8
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 25
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: PUSH
22440: FOR_IN
22441: IFFALSE 22496
// begin SetTag ( i , 1 ) ;
22443: LD_VAR 0 1
22447: PPUSH
22448: LD_INT 1
22450: PPUSH
22451: CALL_OW 109
// ComExitBuilding ( i ) ;
22455: LD_VAR 0 1
22459: PPUSH
22460: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 35
22471: PPUSH
22472: LD_INT 6
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 53
22486: PPUSH
22487: LD_INT 4
22489: PPUSH
22490: CALL_OW 171
// end ;
22494: GO 22440
22496: POP
22497: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_INT 4
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: PUSH
22513: LD_INT 21
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 34
22528: PUSH
22529: LD_INT 12
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22550: LD_EXP 58
22554: PPUSH
22555: LD_VAR 0 3
22559: PPUSH
22560: LD_EXP 58
22564: PPUSH
22565: CALL_OW 74
22569: PPUSH
22570: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22574: LD_EXP 58
22578: PPUSH
22579: LD_INT 100
22581: PPUSH
22582: LD_INT 88
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 75
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 88
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22619: LD_INT 8
22621: PPUSH
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 471
// repeat wait ( 3 ) ;
22631: LD_INT 3
22633: PPUSH
22634: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22638: LD_INT 22
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: LD_INT 92
22650: PUSH
22651: LD_INT 100
22653: PUSH
22654: LD_INT 75
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PPUSH
22670: CALL_OW 69
22674: IFFALSE 22631
// async ;
22676: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22677: LD_EXP 58
22681: PPUSH
22682: LD_STRING D6b-Pow-1
22684: PPUSH
22685: CALL_OW 88
// repeat wait ( 3 ) ;
22689: LD_INT 3
22691: PPUSH
22692: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22696: LD_EXP 58
22700: PPUSH
22701: CALL_OW 310
22705: PPUSH
22706: CALL_OW 256
22710: PUSH
22711: LD_INT 1000
22713: LESS
22714: IFFALSE 22733
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: CALL_OW 310
22725: PPUSH
22726: LD_INT 1000
22728: PPUSH
22729: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22733: LD_EXP 58
22737: PPUSH
22738: CALL_OW 256
22742: PUSH
22743: LD_INT 1000
22745: LESS
22746: IFFALSE 22760
// SetLives ( Powell , 1000 ) ;
22748: LD_EXP 58
22752: PPUSH
22753: LD_INT 1000
22755: PPUSH
22756: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22760: LD_EXP 58
22764: PPUSH
22765: LD_EXP 63
22769: PPUSH
22770: CALL_OW 296
22774: PUSH
22775: LD_INT 5
22777: LESS
22778: PUSH
22779: LD_EXP 58
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: LD_EXP 63
22793: PPUSH
22794: CALL_OW 296
22798: PUSH
22799: LD_INT 5
22801: LESS
22802: OR
22803: IFFALSE 22822
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: CALL_OW 310
22814: PPUSH
22815: LD_INT 100
22817: PPUSH
22818: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22822: LD_EXP 58
22826: PPUSH
22827: CALL_OW 310
22831: NOT
22832: IFFALSE 22689
// DoNotAttack ( 8 , powellBomb ) ;
22834: LD_INT 8
22836: PPUSH
22837: LD_EXP 63
22841: PPUSH
22842: CALL_OW 471
// game_speed := 4 ;
22846: LD_ADDR_OWVAR 65
22850: PUSH
22851: LD_INT 4
22853: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_STRING D6b-Pow-1a
22861: PPUSH
22862: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22866: LD_EXP 58
22870: PPUSH
22871: LD_EXP 63
22875: PPUSH
22876: CALL_OW 180
// sync ;
22880: SYNC
// repeat wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// until IsInUnit ( Powell ) ;
22888: LD_EXP 58
22892: PPUSH
22893: CALL_OW 310
22897: IFFALSE 22881
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22899: LD_INT 8
22901: PPUSH
22902: LD_EXP 58
22906: PPUSH
22907: CALL_OW 310
22911: PPUSH
22912: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22916: LD_EXP 58
22920: PPUSH
22921: LD_INT 91
22923: PPUSH
22924: LD_INT 44
22926: PPUSH
22927: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 96
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 41
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 92
22968: PPUSH
22969: LD_INT 39
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 88
22983: PPUSH
22984: LD_INT 41
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 91
22998: PPUSH
22999: LD_INT 44
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 96
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 41
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 92
23043: PPUSH
23044: LD_INT 39
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 88
23058: PPUSH
23059: LD_INT 41
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 91
23073: PPUSH
23074: LD_INT 44
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 93
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 36
23106: PPUSH
23107: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23111: LD_INT 122
23113: PPUSH
23114: CALL_OW 67
// game_speed := 4 ;
23118: LD_ADDR_OWVAR 65
23122: PUSH
23123: LD_INT 4
23125: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_STRING D6b-Pow-1b
23133: PPUSH
23134: CALL_OW 88
// tmp := [ ] ;
23138: LD_ADDR_VAR 0 3
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23145: LD_ADDR_VAR 0 5
23149: PUSH
23150: LD_INT 78
23152: PUSH
23153: LD_INT 47
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: LD_INT 106
23162: PUSH
23163: LD_INT 53
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23174: LD_ADDR_VAR 0 1
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 8
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 3
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 92
23201: PUSH
23202: LD_INT 90
23204: PUSH
23205: LD_INT 52
23207: PUSH
23208: LD_INT 12
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: LIST
23221: PPUSH
23222: CALL_OW 69
23226: PUSH
23227: FOR_IN
23228: IFFALSE 23253
// tmp := tmp ^ UnitsInside ( i ) ;
23230: LD_ADDR_VAR 0 3
23234: PUSH
23235: LD_VAR 0 3
23239: PUSH
23240: LD_VAR 0 1
23244: PPUSH
23245: CALL_OW 313
23249: ADD
23250: ST_TO_ADDR
23251: GO 23227
23253: POP
23254: POP
// for i in tmp do
23255: LD_ADDR_VAR 0 1
23259: PUSH
23260: LD_VAR 0 3
23264: PUSH
23265: FOR_IN
23266: IFFALSE 23428
// begin dist := 9999 ;
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: LD_INT 9999
23275: ST_TO_ADDR
// _xy := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_INT 1
23290: PPUSH
23291: CALL_OW 109
// ComExitBuilding ( i ) ;
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 122
// for j in xy do
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_IN
23315: IFFALSE 23397
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23317: LD_VAR 0 1
23321: PPUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_INT 1
23329: ARRAY
23330: PPUSH
23331: LD_VAR 0 2
23335: PUSH
23336: LD_INT 2
23338: ARRAY
23339: PPUSH
23340: CALL_OW 297
23344: PUSH
23345: LD_VAR 0 8
23349: LESS
23350: IFFALSE 23395
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: ST_TO_ADDR
// _xy := j ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 2
23394: ST_TO_ADDR
// end ;
23395: GO 23314
23397: POP
23398: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PPUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 2
23420: ARRAY
23421: PPUSH
23422: CALL_OW 171
// end ;
23426: GO 23265
23428: POP
23429: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23430: LD_ADDR_VAR 0 4
23434: PUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 25
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PPUSH
23464: CALL_OW 72
23468: ST_TO_ADDR
// if tmp2 < 2 then
23469: LD_VAR 0 4
23473: PUSH
23474: LD_INT 2
23476: LESS
23477: IFFALSE 23546
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_INT 22
23486: PUSH
23487: LD_INT 8
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 26
23496: PUSH
23497: LD_INT 1
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 25
23509: PUSH
23510: LD_INT 15
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 69
23530: PUSH
23531: LD_EXP 60
23535: PUSH
23536: LD_EXP 61
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: DIFF
23545: ST_TO_ADDR
// if tmp2 then
23546: LD_VAR 0 4
23550: IFFALSE 23568
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23552: LD_VAR 0 4
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_STRING D6b-ArSol1-1
23563: PPUSH
23564: CALL_OW 88
// async ;
23568: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23569: LD_EXP 58
23573: PPUSH
23574: LD_STRING D6b-Pow-2
23576: PPUSH
23577: CALL_OW 88
// wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if tmp2 > 1 then
23588: LD_VAR 0 4
23592: PUSH
23593: LD_INT 1
23595: GREATER
23596: IFFALSE 23614
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23598: LD_VAR 0 4
23602: PUSH
23603: LD_INT 2
23605: ARRAY
23606: PPUSH
23607: LD_STRING D6b-ArSol2-1
23609: PPUSH
23610: CALL_OW 88
// sync ;
23614: SYNC
// repeat wait ( 5 ) ;
23615: LD_INT 5
23617: PPUSH
23618: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23622: LD_INT 93
23624: PPUSH
23625: LD_INT 36
23627: PPUSH
23628: CALL_OW 428
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: LD_INT 4
23640: EQUAL
23641: IFFALSE 23615
// DialogueOn ;
23643: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23647: LD_INT 10
23649: PPUSH
23650: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23654: LD_EXP 58
23658: PPUSH
23659: LD_STRING D6b-Pow-2a
23661: PPUSH
23662: CALL_OW 88
// DialogueOff ;
23666: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23670: LD_EXP 58
23674: PPUSH
23675: CALL_OW 310
23679: PPUSH
23680: LD_INT 332
23682: PPUSH
23683: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23687: LD_INT 93
23689: PPUSH
23690: LD_INT 35
23692: PPUSH
23693: LD_INT 1
23695: PPUSH
23696: LD_INT 6
23698: NEG
23699: PPUSH
23700: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23711: LD_INT 332
23713: PPUSH
23714: CALL_OW 256
23718: PUSH
23719: LD_INT 1000
23721: LESS
23722: PUSH
23723: LD_INT 332
23725: PPUSH
23726: CALL_OW 300
23730: AND
23731: IFFALSE 23743
// SetLives ( kozlov_fac , 0 ) ;
23733: LD_INT 332
23735: PPUSH
23736: LD_INT 0
23738: PPUSH
23739: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23743: LD_INT 332
23745: PPUSH
23746: CALL_OW 301
23750: PUSH
23751: LD_EXP 58
23755: PPUSH
23756: CALL_OW 301
23760: OR
23761: IFFALSE 23704
// game_speed := 4 ;
23763: LD_ADDR_OWVAR 65
23767: PUSH
23768: LD_INT 4
23770: ST_TO_ADDR
// powellCenterCameraMode := false ;
23771: LD_ADDR_EXP 20
23775: PUSH
23776: LD_INT 0
23778: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23779: LD_ADDR_VAR 0 1
23783: PUSH
23784: LD_VAR 0 3
23788: PUSH
23789: LD_INT 22
23791: PUSH
23792: LD_INT 8
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 25
23801: PUSH
23802: LD_INT 2
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: PPUSH
23813: CALL_OW 69
23817: UNION
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23836
// SetTag ( i , 0 ) ;
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 0
23829: PPUSH
23830: CALL_OW 109
23834: GO 23819
23836: POP
23837: POP
// wait ( 0 0$3 ) ;
23838: LD_INT 105
23840: PPUSH
23841: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23845: LD_INT 93
23847: PPUSH
23848: LD_INT 35
23850: PPUSH
23851: LD_INT 1
23853: PPUSH
23854: CALL_OW 331
// DialogueOn ;
23858: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23862: LD_VAR 0 11
23866: PPUSH
23867: LD_STRING D6c-Sol3-1
23869: PPUSH
23870: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23874: LD_INT 10
23876: PPUSH
23877: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23881: LD_EXP 39
23885: PPUSH
23886: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23890: LD_EXP 39
23894: PPUSH
23895: LD_STRING D6c-JMM-1
23897: PPUSH
23898: CALL_OW 88
// if Cyrus then
23902: LD_EXP 45
23906: IFFALSE 23920
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23908: LD_EXP 45
23912: PPUSH
23913: LD_STRING D6c-Cyrus-1
23915: PPUSH
23916: CALL_OW 88
// if Bobby then
23920: LD_EXP 44
23924: IFFALSE 23938
// Say ( Bobby , D6c-Bobby-1 ) ;
23926: LD_EXP 44
23930: PPUSH
23931: LD_STRING D6c-Bobby-1
23933: PPUSH
23934: CALL_OW 88
// if Cornel then
23938: LD_EXP 50
23942: IFFALSE 23956
// Say ( Cornel , D6c-Corn-1 ) ;
23944: LD_EXP 50
23948: PPUSH
23949: LD_STRING D6c-Corn-1
23951: PPUSH
23952: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 22
23966: PUSH
23967: LD_INT 1
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 22
23976: PUSH
23977: LD_INT 4
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 26
23991: PUSH
23992: LD_INT 1
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 25
24004: PUSH
24005: LD_INT 16
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 25
24014: PUSH
24015: LD_INT 12
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PPUSH
24032: CALL_OW 69
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: LD_EXP 39
24046: UNION
24047: PUSH
24048: LD_EXP 59
24052: UNION
24053: PUSH
24054: EMPTY
24055: LIST
24056: DIFF
24057: ST_TO_ADDR
// if tmp2 then
24058: LD_VAR 0 4
24062: IFFALSE 24080
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24064: LD_VAR 0 4
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_STRING D6c-Sol1-1
24075: PPUSH
24076: CALL_OW 88
// if Lisa then
24080: LD_EXP 42
24084: IFFALSE 24098
// Say ( Lisa , D6c-Lisa-1 ) ;
24086: LD_EXP 42
24090: PPUSH
24091: LD_STRING D6c-Lisa-1
24093: PPUSH
24094: CALL_OW 88
// if Gary then
24098: LD_EXP 51
24102: IFFALSE 24116
// Say ( Gary , D6c-Gary-1 ) ;
24104: LD_EXP 51
24108: PPUSH
24109: LD_STRING D6c-Gary-1
24111: PPUSH
24112: CALL_OW 88
// if Donaldson then
24116: LD_EXP 43
24120: IFFALSE 24134
// Say ( Donaldson , D6c-Don-1 ) ;
24122: LD_EXP 43
24126: PPUSH
24127: LD_STRING D6c-Don-1
24129: PPUSH
24130: CALL_OW 88
// if tmp2 > 1 then
24134: LD_VAR 0 4
24138: PUSH
24139: LD_INT 1
24141: GREATER
24142: IFFALSE 24160
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24144: LD_VAR 0 4
24148: PUSH
24149: LD_INT 2
24151: ARRAY
24152: PPUSH
24153: LD_STRING D6c-Sol2-1
24155: PPUSH
24156: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24160: LD_VAR 0 11
24164: PPUSH
24165: LD_STRING D6c-Sol3-2
24167: PPUSH
24168: CALL_OW 88
// dwait ( 0 0$1 ) ;
24172: LD_INT 35
24174: PPUSH
24175: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24179: LD_EXP 39
24183: PPUSH
24184: LD_STRING D6c-JMM-2
24186: PPUSH
24187: CALL_OW 88
// DialogueOff ;
24191: CALL_OW 7
// Video ( false ) ;
24195: LD_INT 0
24197: PPUSH
24198: CALL 107942 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24202: LD_INT 22
24204: PUSH
24205: LD_INT 4
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PPUSH
24212: CALL_OW 69
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24224: LD_INT 4
24226: PPUSH
24227: LD_INT 4
24229: PPUSH
24230: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24234: LD_ADDR_VAR 0 1
24238: PUSH
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 1
24244: PPUSH
24245: LD_INT 2
24247: PPUSH
24248: CALL 65043 0 3
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24291
// if GetTech ( i , 1 ) <> state_researched then
24256: LD_VAR 0 1
24260: PPUSH
24261: LD_INT 1
24263: PPUSH
24264: CALL_OW 321
24268: PUSH
24269: LD_INT 2
24271: NONEQUAL
24272: IFFALSE 24289
// SetTech ( i , 1 , state_researched ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_INT 1
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: CALL_OW 322
24289: GO 24253
24291: POP
24292: POP
// missionStage := 6 ;
24293: LD_ADDR_EXP 15
24297: PUSH
24298: LD_INT 6
24300: ST_TO_ADDR
// activeAttacks := true ;
24301: LD_ADDR_EXP 16
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24309: LD_STRING M2
24311: PPUSH
24312: CALL_OW 337
// SaveForQuickRestart ;
24316: CALL_OW 22
// wait ( 0 0$40 ) ;
24320: LD_INT 1400
24322: PPUSH
24323: CALL_OW 67
// DialogueOn ;
24327: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24331: LD_EXP 62
24335: PPUSH
24336: LD_STRING D7-Friend-1
24338: PPUSH
24339: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24343: LD_EXP 39
24347: PPUSH
24348: LD_STRING D7-JMM-1
24350: PPUSH
24351: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24355: LD_EXP 62
24359: PPUSH
24360: LD_STRING D7-Friend-2
24362: PPUSH
24363: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24367: LD_EXP 39
24371: PPUSH
24372: LD_STRING D7-JMM-2
24374: PPUSH
24375: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24379: LD_EXP 62
24383: PPUSH
24384: LD_STRING D7-Friend-3
24386: PPUSH
24387: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24391: LD_EXP 39
24395: PPUSH
24396: LD_STRING D7-JMM-3
24398: PPUSH
24399: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24403: LD_EXP 62
24407: PPUSH
24408: LD_STRING D7-Friend-4
24410: PPUSH
24411: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24415: LD_EXP 39
24419: PPUSH
24420: LD_STRING D7-JMM-4
24422: PPUSH
24423: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24427: LD_EXP 62
24431: PPUSH
24432: LD_STRING D7-Friend-5
24434: PPUSH
24435: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24439: LD_EXP 39
24443: PPUSH
24444: LD_STRING D7-JMM-5
24446: PPUSH
24447: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-6
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-6
24470: PPUSH
24471: CALL_OW 88
// DialogueOff ;
24475: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24479: LD_STRING Mlegion
24481: PPUSH
24482: CALL_OW 337
// RebuildKozlovFactory ;
24486: CALL 4840 0 0
// end ;
24490: PPOPN 13
24492: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24493: LD_EXP 20
24497: PUSH
24498: LD_EXP 58
24502: PPUSH
24503: CALL_OW 300
24507: AND
24508: IFFALSE 24550
24510: GO 24512
24512: DISABLE
// begin enable ;
24513: ENABLE
// if IsInUnit ( Powell ) then
24514: LD_EXP 58
24518: PPUSH
24519: CALL_OW 310
24523: IFFALSE 24541
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24525: LD_EXP 58
24529: PPUSH
24530: CALL_OW 310
24534: PPUSH
24535: CALL_OW 85
24539: GO 24550
// CenterOnUnits ( Powell ) ;
24541: LD_EXP 58
24545: PPUSH
24546: CALL_OW 85
// end ;
24550: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24551: LD_INT 22
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 34
24563: PUSH
24564: LD_INT 48
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 69
24579: IFFALSE 24853
24581: GO 24583
24583: DISABLE
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
// begin if missionStage < 9 then
24588: LD_EXP 15
24592: PUSH
24593: LD_INT 9
24595: LESS
24596: IFFALSE 24606
// missionStage := 9 ;
24598: LD_ADDR_EXP 15
24602: PUSH
24603: LD_INT 9
24605: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 34
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PPUSH
24635: CALL_OW 69
24639: PUSH
24640: LD_INT 1
24642: ARRAY
24643: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24644: LD_INT 175
24646: PPUSH
24647: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24651: LD_EXP 12
24655: PUSH
24656: LD_EXP 3
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: LD_INT 2
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: IN
24671: OR
24672: IFFALSE 24695
// target := [ 68 , 108 , 1 ] else
24674: LD_ADDR_VAR 0 2
24678: PUSH
24679: LD_INT 68
24681: PUSH
24682: LD_INT 108
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: ST_TO_ADDR
24693: GO 24714
// target := [ 181 , 88 , 2 ] ;
24695: LD_ADDR_VAR 0 2
24699: PUSH
24700: LD_INT 181
24702: PUSH
24703: LD_INT 88
24705: PUSH
24706: LD_INT 2
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: LIST
24713: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_VAR 0 2
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 176
// if target [ 3 ] = 1 then
24741: LD_VAR 0 2
24745: PUSH
24746: LD_INT 3
24748: ARRAY
24749: PUSH
24750: LD_INT 1
24752: EQUAL
24753: IFFALSE 24769
// SayRadio ( Kurt , D12-Kurt-1 ) else
24755: LD_EXP 60
24759: PPUSH
24760: LD_STRING D12-Kurt-1
24762: PPUSH
24763: CALL_OW 94
24767: GO 24793
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24769: LD_EXP 60
24773: PPUSH
24774: LD_STRING D12a-Kurt-1
24776: PPUSH
24777: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24781: LD_EXP 74
24785: PPUSH
24786: LD_STRING D12a-Roth-1
24788: PPUSH
24789: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24793: LD_INT 350
24795: PPUSH
24796: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24800: LD_VAR 0 1
24804: PPUSH
24805: LD_INT 22
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 23
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 30
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: PUSH
24845: LD_INT 1
24847: ARRAY
24848: PPUSH
24849: CALL_OW 228
// end ;
24853: PPOPN 2
24855: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 999
24868: LESS
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 8
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 23
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 9
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: LD_INT 7
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: LD_OWVAR 67
24928: ARRAY
24929: LESSEQUAL
24930: OR
24931: PUSH
24932: LD_INT 22
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 34
24944: PUSH
24945: LD_INT 48
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: NOT
24961: AND
24962: PUSH
24963: LD_EXP 60
24967: PPUSH
24968: CALL_OW 302
24972: AND
24973: PUSH
24974: LD_INT 5
24976: PPUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 1
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 70
24991: AND
24992: IFFALSE 25697
24994: GO 24996
24996: DISABLE
24997: LD_INT 0
24999: PPUSH
25000: PPUSH
25001: PPUSH
// begin DialogueOn ;
25002: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25006: LD_EXP 39
25010: PPUSH
25011: LD_STRING D13-JMM-1
25013: PPUSH
25014: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25018: LD_EXP 60
25022: PPUSH
25023: LD_STRING D13-Kurt-1
25025: PPUSH
25026: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25030: LD_EXP 39
25034: PPUSH
25035: LD_STRING D13-JMM-2
25037: PPUSH
25038: CALL_OW 88
// if FakeInfo then
25042: LD_EXP 12
25046: IFFALSE 25066
// begin Say ( Kurt , D13-Kurt-2 ) ;
25048: LD_EXP 60
25052: PPUSH
25053: LD_STRING D13-Kurt-2
25055: PPUSH
25056: CALL_OW 88
// DialogueOff ;
25060: CALL_OW 7
// exit ;
25064: GO 25697
// end ; if not KurtStatus then
25066: LD_EXP 3
25070: NOT
25071: IFFALSE 25087
// Say ( Kurt , D13-Kurt-2b ) else
25073: LD_EXP 60
25077: PPUSH
25078: LD_STRING D13-Kurt-2b
25080: PPUSH
25081: CALL_OW 88
25085: GO 25099
// Say ( Kurt , D13-Kurt-2a ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_STRING D13-Kurt-2a
25094: PPUSH
25095: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25099: LD_EXP 39
25103: PPUSH
25104: LD_STRING D13-JMM-3
25106: PPUSH
25107: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25111: LD_EXP 60
25115: PPUSH
25116: LD_STRING D13-Kurt-3
25118: PPUSH
25119: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25123: LD_EXP 39
25127: PPUSH
25128: LD_STRING D13-JMM-4
25130: PPUSH
25131: CALL_OW 88
// DialogueOff ;
25135: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25139: LD_STRING MlegionOut
25141: PPUSH
25142: CALL_OW 337
// legionDestroyed := true ;
25146: LD_ADDR_EXP 22
25150: PUSH
25151: LD_INT 1
25153: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25154: LD_INT 3
25156: PPUSH
25157: CALL 35176 0 1
// KillUnit ( Kozlov ) ;
25161: LD_EXP 61
25165: PPUSH
25166: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25170: LD_ADDR_VAR 0 1
25174: PUSH
25175: LD_INT 22
25177: PUSH
25178: LD_INT 8
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: LD_INT 23
25187: PUSH
25188: LD_INT 3
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: LD_INT 3
25197: PUSH
25198: LD_INT 21
25200: PUSH
25201: LD_INT 33
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: LIST
25216: PPUSH
25217: CALL_OW 69
25221: PUSH
25222: FOR_IN
25223: IFFALSE 25236
// KillUnit ( i ) ;
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 66
25234: GO 25222
25236: POP
25237: POP
// ChangeSideFog ( 8 , 1 ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25248: LD_ADDR_VAR 0 2
25252: PUSH
25253: LD_INT 22
25255: PUSH
25256: LD_INT 8
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 21
25265: PUSH
25266: LD_INT 1
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PPUSH
25277: CALL_OW 69
25281: PUSH
25282: LD_EXP 61
25286: PUSH
25287: LD_EXP 60
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: DIFF
25296: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25297: LD_VAR 0 2
25301: PUSH
25302: LD_INT 6
25304: PUSH
25305: LD_INT 5
25307: PUSH
25308: LD_INT 4
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: PUSH
25316: LD_OWVAR 67
25320: ARRAY
25321: GREATEREQUAL
25322: IFFALSE 25496
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25324: LD_ADDR_VAR 0 3
25328: PUSH
25329: LD_INT 6
25331: PUSH
25332: LD_INT 5
25334: PUSH
25335: LD_INT 4
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: LIST
25342: PUSH
25343: LD_OWVAR 67
25347: ARRAY
25348: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25349: LD_ADDR_VAR 0 1
25353: PUSH
25354: DOUBLE
25355: LD_VAR 0 2
25359: PUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 1
25367: PLUS
25368: MINUS
25369: INC
25370: ST_TO_ADDR
25371: LD_INT 1
25373: PUSH
25374: FOR_DOWNTO
25375: IFFALSE 25492
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25377: LD_ADDR_EXP 38
25381: PUSH
25382: LD_EXP 38
25386: PUSH
25387: LD_VAR 0 2
25391: PUSH
25392: LD_VAR 0 1
25396: ARRAY
25397: ADD
25398: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25399: LD_VAR 0 2
25403: PUSH
25404: LD_VAR 0 1
25408: ARRAY
25409: PPUSH
25410: CALL_OW 310
25414: IFFALSE 25431
// ComExitBuilding ( tmp [ i ] ) ;
25416: LD_VAR 0 2
25420: PUSH
25421: LD_VAR 0 1
25425: ARRAY
25426: PPUSH
25427: CALL_OW 122
// if IsInUnit ( i ) then
25431: LD_VAR 0 1
25435: PPUSH
25436: CALL_OW 310
25440: IFFALSE 25457
// ComExitVehicle ( tmp [ i ] ) ;
25442: LD_VAR 0 2
25446: PUSH
25447: LD_VAR 0 1
25451: ARRAY
25452: PPUSH
25453: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: LD_INT 34
25470: PUSH
25471: LD_INT 0
25473: PPUSH
25474: LD_INT 6
25476: PPUSH
25477: CALL_OW 12
25481: PLUS
25482: PPUSH
25483: LD_INT 1
25485: PPUSH
25486: CALL_OW 171
// end ;
25490: GO 25374
25492: POP
25493: POP
// end else
25494: GO 25506
// x := tmp ;
25496: LD_ADDR_VAR 0 3
25500: PUSH
25501: LD_VAR 0 2
25505: ST_TO_ADDR
// for i := tmp downto tmp - x do
25506: LD_ADDR_VAR 0 1
25510: PUSH
25511: DOUBLE
25512: LD_VAR 0 2
25516: INC
25517: ST_TO_ADDR
25518: LD_VAR 0 2
25522: PUSH
25523: LD_VAR 0 3
25527: MINUS
25528: PUSH
25529: FOR_DOWNTO
25530: IFFALSE 25584
// begin if IsInUnit ( tmp [ i ] ) then
25532: LD_VAR 0 2
25536: PUSH
25537: LD_VAR 0 1
25541: ARRAY
25542: PPUSH
25543: CALL_OW 310
25547: IFFALSE 25564
// ComExitVehicle ( tmp [ i ] ) ;
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: LD_INT 1
25577: PPUSH
25578: CALL_OW 235
// end ;
25582: GO 25529
25584: POP
25585: POP
// SetSide ( Kurt , 1 ) ;
25586: LD_EXP 60
25590: PPUSH
25591: LD_INT 1
25593: PPUSH
25594: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25598: LD_INT 22
25600: PUSH
25601: LD_INT 8
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 21
25610: PUSH
25611: LD_INT 3
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PPUSH
25622: CALL_OW 69
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25634: LD_INT 8
25636: PPUSH
25637: LD_INT 1
25639: PPUSH
25640: LD_INT 1
25642: PPUSH
25643: LD_INT 1
25645: PPUSH
25646: CALL_OW 80
// wait ( 1 1$20 ) ;
25650: LD_INT 2800
25652: PPUSH
25653: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25657: LD_EXP 62
25661: PPUSH
25662: LD_INT 37
25664: PPUSH
25665: LD_INT 1
25667: PPUSH
25668: LD_INT 0
25670: PPUSH
25671: CALL_OW 48
// wait ( 0 0$1 ) ;
25675: LD_INT 35
25677: PPUSH
25678: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25682: LD_EXP 62
25686: PPUSH
25687: LD_INT 60
25689: PPUSH
25690: LD_INT 95
25692: PPUSH
25693: CALL_OW 111
// end ;
25697: PPOPN 3
25699: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25700: LD_EXP 22
25704: NOT
25705: PUSH
25706: LD_INT 22
25708: PUSH
25709: LD_INT 8
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 21
25718: PUSH
25719: LD_INT 1
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PPUSH
25730: CALL_OW 69
25734: PUSH
25735: LD_INT 0
25737: EQUAL
25738: AND
25739: IFFALSE 25759
25741: GO 25743
25743: DISABLE
// begin legionDestroyed := true ;
25744: LD_ADDR_EXP 22
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25752: LD_STRING MlegionOut
25754: PPUSH
25755: CALL_OW 337
// end ;
25759: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25760: LD_EXP 38
25764: IFFALSE 25839
25766: GO 25768
25768: DISABLE
25769: LD_INT 0
25771: PPUSH
// begin enable ;
25772: ENABLE
// for i in legionEscapeUnits do
25773: LD_ADDR_VAR 0 1
25777: PUSH
25778: LD_EXP 38
25782: PUSH
25783: FOR_IN
25784: IFFALSE 25837
// begin if IsInArea ( i , legionEscapeArea ) then
25786: LD_VAR 0 1
25790: PPUSH
25791: LD_INT 31
25793: PPUSH
25794: CALL_OW 308
25798: IFFALSE 25811
// RemoveUnit ( i ) else
25800: LD_VAR 0 1
25804: PPUSH
25805: CALL_OW 64
25809: GO 25835
// if not HasTask ( i ) then
25811: LD_VAR 0 1
25815: PPUSH
25816: CALL_OW 314
25820: NOT
25821: IFFALSE 25835
// ComMoveToArea ( i , legionEscapeArea ) ;
25823: LD_VAR 0 1
25827: PPUSH
25828: LD_INT 31
25830: PPUSH
25831: CALL_OW 113
// end ;
25835: GO 25783
25837: POP
25838: POP
// end ;
25839: PPOPN 1
25841: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25842: LD_INT 1
25844: PPUSH
25845: LD_EXP 62
25849: PPUSH
25850: CALL_OW 292
25854: IFFALSE 26152
25856: GO 25858
25858: DISABLE
25859: LD_INT 0
25861: PPUSH
// begin wait ( 0 0$2 ) ;
25862: LD_INT 70
25864: PPUSH
25865: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25869: LD_EXP 62
25873: PPUSH
25874: CALL_OW 87
// DialogueOn ;
25878: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25882: LD_EXP 39
25886: PPUSH
25887: LD_STRING D14-JMM-1
25889: PPUSH
25890: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25894: LD_EXP 62
25898: PPUSH
25899: LD_STRING D14-Friend-1
25901: PPUSH
25902: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25906: LD_EXP 39
25910: PPUSH
25911: LD_STRING D14-JMM-2
25913: PPUSH
25914: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25918: LD_EXP 62
25922: PPUSH
25923: LD_STRING D14-Friend-2
25925: PPUSH
25926: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25930: LD_EXP 39
25934: PPUSH
25935: LD_STRING D14-JMM-3
25937: PPUSH
25938: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25942: LD_EXP 62
25946: PPUSH
25947: LD_STRING D14-Friend-3
25949: PPUSH
25950: CALL_OW 88
// DialogueOff ;
25954: CALL_OW 7
// dec = Query ( Q14 ) ;
25958: LD_ADDR_VAR 0 1
25962: PUSH
25963: LD_STRING Q14
25965: PPUSH
25966: CALL_OW 97
25970: ST_TO_ADDR
// if dec = 1 then
25971: LD_VAR 0 1
25975: PUSH
25976: LD_INT 1
25978: EQUAL
25979: IFFALSE 26013
// begin DialogueOn ;
25981: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25985: LD_EXP 39
25989: PPUSH
25990: LD_STRING D14a-JMM-1
25992: PPUSH
25993: CALL_OW 88
// DialogueOff ;
25997: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26001: LD_EXP 62
26005: PPUSH
26006: LD_INT 1
26008: PPUSH
26009: CALL_OW 235
// end ; if dec = 2 then
26013: LD_VAR 0 1
26017: PUSH
26018: LD_INT 2
26020: EQUAL
26021: IFFALSE 26074
// begin DialogueOn ;
26023: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26027: LD_EXP 39
26031: PPUSH
26032: LD_STRING D14b-JMM-1
26034: PPUSH
26035: CALL_OW 88
// DialogueOff ;
26039: CALL_OW 7
// wait ( 0 0$1 ) ;
26043: LD_INT 35
26045: PPUSH
26046: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26050: LD_EXP 62
26054: PPUSH
26055: LD_INT 9
26057: PPUSH
26058: LD_INT 2
26060: PPUSH
26061: CALL_OW 111
// AddComHold ( Friend ) ;
26065: LD_EXP 62
26069: PPUSH
26070: CALL_OW 200
// end ; if dec = 3 then
26074: LD_VAR 0 1
26078: PUSH
26079: LD_INT 3
26081: EQUAL
26082: IFFALSE 26152
// begin DialogueOn ;
26084: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26088: LD_EXP 39
26092: PPUSH
26093: LD_STRING D14c-JMM-1
26095: PPUSH
26096: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26100: LD_EXP 62
26104: PPUSH
26105: LD_STRING D14c-Friend-1
26107: PPUSH
26108: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26112: LD_EXP 39
26116: PPUSH
26117: LD_STRING D14c-JMM-2
26119: PPUSH
26120: CALL_OW 88
// DialogueOff ;
26124: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26128: LD_EXP 62
26132: PPUSH
26133: LD_INT 9
26135: PPUSH
26136: LD_INT 2
26138: PPUSH
26139: CALL_OW 111
// AddComHold ( Friend ) ;
26143: LD_EXP 62
26147: PPUSH
26148: CALL_OW 200
// end ; end ;
26152: PPOPN 1
26154: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26155: LD_INT 9
26157: PPUSH
26158: LD_INT 2
26160: PPUSH
26161: CALL_OW 428
26165: PUSH
26166: LD_EXP 62
26170: EQUAL
26171: PUSH
26172: LD_EXP 62
26176: PPUSH
26177: CALL_OW 255
26181: PUSH
26182: LD_INT 8
26184: EQUAL
26185: AND
26186: IFFALSE 26200
26188: GO 26190
26190: DISABLE
// RemoveUnit ( Friend ) ;
26191: LD_EXP 62
26195: PPUSH
26196: CALL_OW 64
26200: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26201: LD_EXP 14
26205: PUSH
26206: LD_INT 31500
26208: GREATEREQUAL
26209: PUSH
26210: LD_EXP 7
26214: AND
26215: PUSH
26216: LD_EXP 2
26220: AND
26221: IFFALSE 26651
26223: GO 26225
26225: DISABLE
26226: LD_INT 0
26228: PPUSH
26229: PPUSH
26230: PPUSH
// begin missionStage := 7 ;
26231: LD_ADDR_EXP 15
26235: PUSH
26236: LD_INT 7
26238: ST_TO_ADDR
// uc_side = 1 ;
26239: LD_ADDR_OWVAR 20
26243: PUSH
26244: LD_INT 1
26246: ST_TO_ADDR
// uc_nation = 1 ;
26247: LD_ADDR_OWVAR 21
26251: PUSH
26252: LD_INT 1
26254: ST_TO_ADDR
// for i = 1 to 5 do
26255: LD_ADDR_VAR 0 1
26259: PUSH
26260: DOUBLE
26261: LD_INT 1
26263: DEC
26264: ST_TO_ADDR
26265: LD_INT 5
26267: PUSH
26268: FOR_TO
26269: IFFALSE 26365
// begin vc_engine = 3 ;
26271: LD_ADDR_OWVAR 39
26275: PUSH
26276: LD_INT 3
26278: ST_TO_ADDR
// vc_control = 3 ;
26279: LD_ADDR_OWVAR 38
26283: PUSH
26284: LD_INT 3
26286: ST_TO_ADDR
// vc_chassis = 3 ;
26287: LD_ADDR_OWVAR 37
26291: PUSH
26292: LD_INT 3
26294: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26295: LD_ADDR_OWVAR 40
26299: PUSH
26300: LD_INT 5
26302: PUSH
26303: LD_INT 9
26305: PUSH
26306: LD_INT 7
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 1
26316: PPUSH
26317: LD_INT 3
26319: PPUSH
26320: CALL_OW 12
26324: ARRAY
26325: ST_TO_ADDR
// veh = CreateVehicle ;
26326: LD_ADDR_VAR 0 2
26330: PUSH
26331: CALL_OW 45
26335: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26336: LD_VAR 0 2
26340: PPUSH
26341: LD_INT 1
26343: PPUSH
26344: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26348: LD_VAR 0 2
26352: PPUSH
26353: LD_INT 19
26355: PPUSH
26356: LD_INT 0
26358: PPUSH
26359: CALL_OW 49
// end ;
26363: GO 26268
26365: POP
26366: POP
// vc_engine = 3 ;
26367: LD_ADDR_OWVAR 39
26371: PUSH
26372: LD_INT 3
26374: ST_TO_ADDR
// vc_control = 1 ;
26375: LD_ADDR_OWVAR 38
26379: PUSH
26380: LD_INT 1
26382: ST_TO_ADDR
// vc_chassis = 3 ;
26383: LD_ADDR_OWVAR 37
26387: PUSH
26388: LD_INT 3
26390: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26391: LD_ADDR_OWVAR 40
26395: PUSH
26396: LD_INT 5
26398: PUSH
26399: LD_INT 9
26401: PUSH
26402: LD_INT 7
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 1
26412: PPUSH
26413: LD_INT 3
26415: PPUSH
26416: CALL_OW 12
26420: ARRAY
26421: ST_TO_ADDR
// vehG = CreateVehicle ;
26422: LD_ADDR_VAR 0 3
26426: PUSH
26427: CALL_OW 45
26431: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26432: LD_VAR 0 3
26436: PPUSH
26437: LD_INT 1
26439: PPUSH
26440: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26444: LD_VAR 0 3
26448: PPUSH
26449: LD_INT 19
26451: PPUSH
26452: LD_INT 0
26454: PPUSH
26455: CALL_OW 49
// if JMMGirl = 1 then
26459: LD_EXP 7
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26523
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26469: LD_ADDR_EXP 40
26473: PUSH
26474: LD_STRING Joan
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: LD_STRING 14_
26482: PPUSH
26483: CALL 64980 0 3
26487: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26488: LD_EXP 40
26492: PPUSH
26493: LD_VAR 0 3
26497: PPUSH
26498: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26502: LD_VAR 0 3
26506: PPUSH
26507: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26511: LD_EXP 40
26515: PPUSH
26516: LD_STRING D10BW-Joan-1
26518: PPUSH
26519: CALL_OW 94
// end ; if JMMGirl = 2 then
26523: LD_EXP 7
26527: PUSH
26528: LD_INT 2
26530: EQUAL
26531: IFFALSE 26587
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26533: LD_ADDR_EXP 42
26537: PUSH
26538: LD_STRING Lisa
26540: PPUSH
26541: LD_INT 1
26543: PPUSH
26544: LD_STRING 14_
26546: PPUSH
26547: CALL 64980 0 3
26551: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26552: LD_EXP 42
26556: PPUSH
26557: LD_VAR 0 3
26561: PPUSH
26562: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26566: LD_VAR 0 3
26570: PPUSH
26571: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26575: LD_EXP 42
26579: PPUSH
26580: LD_STRING D10BW-Lisa-1
26582: PPUSH
26583: CALL_OW 94
// end ; if JMMGirl = 3 then
26587: LD_EXP 7
26591: PUSH
26592: LD_INT 3
26594: EQUAL
26595: IFFALSE 26651
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26597: LD_ADDR_EXP 54
26601: PUSH
26602: LD_STRING Connie
26604: PPUSH
26605: LD_INT 1
26607: PPUSH
26608: LD_STRING 14_
26610: PPUSH
26611: CALL 64980 0 3
26615: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26616: LD_EXP 54
26620: PPUSH
26621: LD_VAR 0 3
26625: PPUSH
26626: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26630: LD_VAR 0 3
26634: PPUSH
26635: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26639: LD_EXP 54
26643: PPUSH
26644: LD_STRING D10BW-Con-1
26646: PPUSH
26647: CALL_OW 94
// end ; end ;
26651: PPOPN 3
26653: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26654: LD_EXP 14
26658: PUSH
26659: LD_INT 94500
26661: GREATEREQUAL
26662: IFFALSE 27074
26664: GO 26666
26666: DISABLE
26667: LD_INT 0
26669: PPUSH
26670: PPUSH
26671: PPUSH
// begin tmp := PrepareStevensSquad ;
26672: LD_ADDR_VAR 0 3
26676: PUSH
26677: CALL 2197 0 0
26681: ST_TO_ADDR
// if not tmp then
26682: LD_VAR 0 3
26686: NOT
26687: IFFALSE 26691
// exit ;
26689: GO 27074
// uc_side := 1 ;
26691: LD_ADDR_OWVAR 20
26695: PUSH
26696: LD_INT 1
26698: ST_TO_ADDR
// uc_nation := 1 ;
26699: LD_ADDR_OWVAR 21
26703: PUSH
26704: LD_INT 1
26706: ST_TO_ADDR
// for i in tmp do
26707: LD_ADDR_VAR 0 1
26711: PUSH
26712: LD_VAR 0 3
26716: PUSH
26717: FOR_IN
26718: IFFALSE 26815
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26720: LD_INT 3
26722: PPUSH
26723: LD_INT 3
26725: PPUSH
26726: LD_INT 1
26728: PPUSH
26729: LD_INT 5
26731: PUSH
26732: LD_INT 9
26734: PUSH
26735: LD_INT 7
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: LIST
26742: PUSH
26743: LD_INT 1
26745: PPUSH
26746: LD_INT 3
26748: PPUSH
26749: CALL_OW 12
26753: ARRAY
26754: PPUSH
26755: LD_INT 40
26757: PPUSH
26758: CALL 72215 0 5
// veh := CreateVehicle ;
26762: LD_ADDR_VAR 0 2
26766: PUSH
26767: CALL_OW 45
26771: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26772: LD_VAR 0 2
26776: PPUSH
26777: LD_INT 1
26779: PPUSH
26780: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26784: LD_VAR 0 2
26788: PPUSH
26789: LD_INT 19
26791: PPUSH
26792: LD_INT 0
26794: PPUSH
26795: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26799: LD_VAR 0 1
26803: PPUSH
26804: LD_VAR 0 2
26808: PPUSH
26809: CALL_OW 52
// end ;
26813: GO 26717
26815: POP
26816: POP
// missionStage := 8 ;
26817: LD_ADDR_EXP 15
26821: PUSH
26822: LD_INT 8
26824: ST_TO_ADDR
// DialogueOn ;
26825: CALL_OW 6
// if Stevens then
26829: LD_EXP 41
26833: IFFALSE 26947
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26835: LD_EXP 41
26839: PPUSH
26840: CALL_OW 310
26844: PPUSH
26845: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26849: LD_EXP 41
26853: PPUSH
26854: LD_STRING D8-Huck-1
26856: PPUSH
26857: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26861: LD_EXP 39
26865: PPUSH
26866: LD_STRING D8-JMM-1
26868: PPUSH
26869: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26873: LD_EXP 41
26877: PPUSH
26878: LD_STRING D8-Huck-2
26880: PPUSH
26881: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26885: LD_EXP 39
26889: PPUSH
26890: LD_STRING D8-JMM-2
26892: PPUSH
26893: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26897: LD_EXP 41
26901: PPUSH
26902: LD_STRING D8-Huck-3
26904: PPUSH
26905: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26909: LD_EXP 39
26913: PPUSH
26914: LD_STRING D8-JMM-3
26916: PPUSH
26917: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26921: LD_EXP 41
26925: PPUSH
26926: LD_STRING D8-Huck-4
26928: PPUSH
26929: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26933: LD_EXP 39
26937: PPUSH
26938: LD_STRING D8-JMM-4
26940: PPUSH
26941: CALL_OW 88
// end else
26945: GO 27057
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26947: LD_EXP 55
26951: PPUSH
26952: CALL_OW 310
26956: PPUSH
26957: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26961: LD_EXP 55
26965: PPUSH
26966: LD_STRING D8-Huck-1
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-1a
26980: PPUSH
26981: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26985: LD_EXP 55
26989: PPUSH
26990: LD_STRING D8-Huck-2
26992: PPUSH
26993: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26997: LD_EXP 39
27001: PPUSH
27002: LD_STRING D8-JMM-2
27004: PPUSH
27005: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27009: LD_EXP 55
27013: PPUSH
27014: LD_STRING D8-Huck-3
27016: PPUSH
27017: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27021: LD_EXP 39
27025: PPUSH
27026: LD_STRING D8-JMM-3
27028: PPUSH
27029: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27033: LD_EXP 55
27037: PPUSH
27038: LD_STRING D8-Huck-4
27040: PPUSH
27041: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27045: LD_EXP 39
27049: PPUSH
27050: LD_STRING D8-JMM-4
27052: PPUSH
27053: CALL_OW 88
// end ; DialogueOff ;
27057: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27061: LD_INT 25
27063: PPUSH
27064: LD_INT 1
27066: PPUSH
27067: LD_INT 1
27069: PPUSH
27070: CALL_OW 322
// end ;
27074: PPOPN 3
27076: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27077: LD_INT 1
27079: PPUSH
27080: LD_EXP 71
27084: PPUSH
27085: CALL_OW 292
27089: IFFALSE 27340
27091: GO 27093
27093: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27094: LD_EXP 71
27098: PPUSH
27099: CALL_OW 87
// DialogueOn ;
27103: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27107: LD_EXP 39
27111: PPUSH
27112: LD_STRING D10nB-JMM-1
27114: PPUSH
27115: CALL_OW 88
// if BurlakStatus = 1 then
27119: LD_EXP 9
27123: PUSH
27124: LD_INT 1
27126: EQUAL
27127: IFFALSE 27141
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27129: LD_EXP 70
27133: PPUSH
27134: LD_STRING D10nB-Vse-1a
27136: PPUSH
27137: CALL_OW 94
// end ; if BurlakStatus = 0 then
27141: LD_EXP 9
27145: PUSH
27146: LD_INT 0
27148: EQUAL
27149: IFFALSE 27163
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27151: LD_EXP 70
27155: PPUSH
27156: LD_STRING D10nB-Vse-1
27158: PPUSH
27159: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27163: LD_EXP 39
27167: PPUSH
27168: LD_STRING D10nB-JMM-2
27170: PPUSH
27171: CALL_OW 88
// if KappaStatus then
27175: LD_EXP 2
27179: IFFALSE 27193
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27181: LD_EXP 70
27185: PPUSH
27186: LD_STRING D10nB-Vse-5a
27188: PPUSH
27189: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27193: LD_EXP 2
27197: NOT
27198: PUSH
27199: LD_EXP 6
27203: PUSH
27204: LD_INT 0
27206: EQUAL
27207: AND
27208: IFFALSE 27336
// begin if JMMGirl = 1 then
27210: LD_EXP 7
27214: PUSH
27215: LD_INT 1
27217: EQUAL
27218: IFFALSE 27268
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27220: LD_EXP 70
27224: PPUSH
27225: LD_STRING D10nB-Vse-2
27227: PPUSH
27228: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27232: LD_EXP 39
27236: PPUSH
27237: LD_STRING D10nB-JMM-3
27239: PPUSH
27240: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27244: LD_EXP 70
27248: PPUSH
27249: LD_STRING D10nB-Vse-3
27251: PPUSH
27252: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27256: LD_EXP 39
27260: PPUSH
27261: LD_STRING D10nB-JMM-4
27263: PPUSH
27264: CALL_OW 88
// end ; if JMMGirl = 2 then
27268: LD_EXP 7
27272: PUSH
27273: LD_INT 2
27275: EQUAL
27276: IFFALSE 27302
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27278: LD_EXP 70
27282: PPUSH
27283: LD_STRING D10nB-Vse-4
27285: PPUSH
27286: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27290: LD_EXP 39
27294: PPUSH
27295: LD_STRING D10nB-JMM-5
27297: PPUSH
27298: CALL_OW 88
// end ; if JMMGirl = 3 then
27302: LD_EXP 7
27306: PUSH
27307: LD_INT 3
27309: EQUAL
27310: IFFALSE 27336
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27312: LD_EXP 70
27316: PPUSH
27317: LD_STRING D10nB-Vse-5
27319: PPUSH
27320: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27324: LD_EXP 39
27328: PPUSH
27329: LD_STRING D10nB-JMM-6
27331: PPUSH
27332: CALL_OW 88
// end ; end ; DialogueOff ;
27336: CALL_OW 7
// end ;
27340: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27341: LD_EXP 14
27345: PUSH
27346: LD_INT 115500
27348: GREATEREQUAL
27349: IFFALSE 27725
27351: GO 27353
27353: DISABLE
27354: LD_INT 0
27356: PPUSH
// begin missionStage := 10 ;
27357: LD_ADDR_EXP 15
27361: PUSH
27362: LD_INT 10
27364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27365: LD_ADDR_VAR 0 1
27369: PUSH
27370: LD_INT 22
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 23
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 26
27392: PUSH
27393: LD_INT 1
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: LD_INT 3
27402: PUSH
27403: LD_INT 25
27405: PUSH
27406: LD_INT 12
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 3
27419: PUSH
27420: LD_INT 25
27422: PUSH
27423: LD_INT 16
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: LIST
27440: PPUSH
27441: CALL_OW 69
27445: PUSH
27446: LD_EXP 39
27450: PUSH
27451: LD_EXP 60
27455: PUSH
27456: LD_EXP 41
27460: PUSH
27461: LD_EXP 55
27465: PUSH
27466: LD_EXP 42
27470: PUSH
27471: LD_EXP 43
27475: PUSH
27476: LD_EXP 44
27480: PUSH
27481: LD_EXP 45
27485: PUSH
27486: LD_EXP 46
27490: PUSH
27491: LD_EXP 47
27495: PUSH
27496: LD_EXP 48
27500: PUSH
27501: LD_EXP 49
27505: PUSH
27506: LD_EXP 50
27510: PUSH
27511: LD_EXP 51
27515: PUSH
27516: LD_EXP 52
27520: PUSH
27521: LD_EXP 53
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: DIFF
27544: ST_TO_ADDR
// if not tmp and Brown then
27545: LD_VAR 0 1
27549: NOT
27550: PUSH
27551: LD_EXP 47
27555: AND
27556: IFFALSE 27571
// tmp := [ Brown ] ;
27558: LD_ADDR_VAR 0 1
27562: PUSH
27563: LD_EXP 47
27567: PUSH
27568: EMPTY
27569: LIST
27570: ST_TO_ADDR
// DialogueOn ;
27571: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27575: LD_VAR 0 1
27579: PUSH
27580: LD_INT 1
27582: ARRAY
27583: PPUSH
27584: LD_STRING D11-Sol1-1
27586: PPUSH
27587: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27591: LD_EXP 64
27595: PPUSH
27596: LD_STRING D11-Pla-1
27598: PPUSH
27599: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27603: LD_EXP 65
27607: PPUSH
27608: LD_STRING D11-Kov-1
27610: PPUSH
27611: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27615: LD_EXP 64
27619: PPUSH
27620: LD_STRING D11-Pla-2
27622: PPUSH
27623: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27627: LD_VAR 0 1
27631: PUSH
27632: LD_INT 1
27634: ARRAY
27635: PPUSH
27636: LD_STRING D11-Sol1-2
27638: PPUSH
27639: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27643: LD_EXP 39
27647: PPUSH
27648: LD_STRING D11-JMM-2
27650: PPUSH
27651: CALL_OW 88
// DialogueOff ;
27655: CALL_OW 7
// allowBehemothConstruct := true ;
27659: LD_ADDR_EXP 25
27663: PUSH
27664: LD_INT 1
27666: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27667: LD_STRING M4
27669: PPUSH
27670: CALL_OW 337
// BuildBehemoths ;
27674: CALL 7653 0 0
// repeat wait ( 15 15$00 ) ;
27678: LD_INT 31500
27680: PPUSH
27681: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27685: LD_EXP 27
27689: IFFALSE 27693
// break ;
27691: GO 27725
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27693: LD_INT 267
27695: PPUSH
27696: CALL_OW 274
27700: PPUSH
27701: LD_INT 1
27703: PPUSH
27704: CALL_OW 275
27708: PUSH
27709: LD_INT 1000
27711: GREATEREQUAL
27712: IFFALSE 27718
// BuildBehemoths ;
27714: CALL 7653 0 0
// until not behemothBuilders ;
27718: LD_EXP 73
27722: NOT
27723: IFFALSE 27678
// end ;
27725: PPOPN 1
27727: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27728: LD_EXP 73
27732: NOT
27733: PUSH
27734: LD_EXP 28
27738: NOT
27739: AND
27740: PUSH
27741: LD_EXP 25
27745: AND
27746: IFFALSE 27766
27748: GO 27750
27750: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27751: LD_STRING M4a
27753: PPUSH
27754: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27758: LD_ADDR_EXP 27
27762: PUSH
27763: LD_INT 1
27765: ST_TO_ADDR
// end ;
27766: END
// every 0 0$1 trigger behemothDone do
27767: LD_EXP 28
27771: IFFALSE 27783
27773: GO 27775
27775: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27776: LD_STRING M4b
27778: PPUSH
27779: CALL_OW 337
27783: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27784: LD_EXP 29
27788: NOT
27789: IFFALSE 27985
27791: GO 27793
27793: DISABLE
27794: LD_INT 0
27796: PPUSH
27797: PPUSH
// begin enable ;
27798: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27799: LD_ADDR_VAR 0 1
27803: PUSH
27804: LD_INT 3
27806: PPUSH
27807: CALL 108018 0 1
27811: ST_TO_ADDR
// if not tmp and not behemothDone then
27812: LD_VAR 0 1
27816: NOT
27817: PUSH
27818: LD_EXP 28
27822: NOT
27823: AND
27824: IFFALSE 27860
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27826: LD_ADDR_VAR 0 1
27830: PUSH
27831: LD_INT 22
27833: PUSH
27834: LD_INT 3
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 30
27843: PUSH
27844: LD_INT 37
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PPUSH
27855: CALL_OW 69
27859: ST_TO_ADDR
// if not tmp then
27860: LD_VAR 0 1
27864: NOT
27865: IFFALSE 27869
// exit ;
27867: GO 27985
// for i in tmp do
27869: LD_ADDR_VAR 0 2
27873: PUSH
27874: LD_VAR 0 1
27878: PUSH
27879: FOR_IN
27880: IFFALSE 27983
// if See ( 1 , i ) then
27882: LD_INT 1
27884: PPUSH
27885: LD_VAR 0 2
27889: PPUSH
27890: CALL_OW 292
27894: IFFALSE 27981
// begin if GetType ( i ) = unit_building then
27896: LD_VAR 0 2
27900: PPUSH
27901: CALL_OW 247
27905: PUSH
27906: LD_INT 3
27908: EQUAL
27909: IFFALSE 27947
// begin CenterNowOnUnits ( i ) ;
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27920: LD_EXP 39
27924: PPUSH
27925: LD_STRING D17a-JMM-1
27927: PPUSH
27928: CALL_OW 88
// seeBehemoth := true ;
27932: LD_ADDR_EXP 29
27936: PUSH
27937: LD_INT 1
27939: ST_TO_ADDR
// disable ;
27940: DISABLE
// exit ;
27941: POP
27942: POP
27943: GO 27985
// end else
27945: GO 27981
// begin CenterNowOnUnits ( i ) ;
27947: LD_VAR 0 2
27951: PPUSH
27952: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27956: LD_EXP 39
27960: PPUSH
27961: LD_STRING D17b-JMM-1
27963: PPUSH
27964: CALL_OW 88
// seeBehemoth := true ;
27968: LD_ADDR_EXP 29
27972: PUSH
27973: LD_INT 1
27975: ST_TO_ADDR
// disable ;
27976: DISABLE
// exit ;
27977: POP
27978: POP
27979: GO 27985
// end ; end ;
27981: GO 27879
27983: POP
27984: POP
// end ;
27985: PPOPN 2
27987: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27988: LD_EXP 14
27992: PUSH
27993: LD_INT 116550
27995: GREATEREQUAL
27996: IFFALSE 29172
27998: GO 28000
28000: DISABLE
28001: LD_INT 0
28003: PPUSH
28004: PPUSH
28005: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28006: LD_INT 2
28008: PPUSH
28009: LD_INT 23
28011: PUSH
28012: LD_INT 3
28014: PUSH
28015: LD_INT 3
28017: PUSH
28018: LD_INT 48
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: LIST
28026: PUSH
28027: EMPTY
28028: LIST
28029: PPUSH
28030: CALL 58636 0 2
// repeat wait ( 0 0$1 ) ;
28034: LD_INT 35
28036: PPUSH
28037: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28041: LD_INT 22
28043: PUSH
28044: LD_INT 3
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 34
28053: PUSH
28054: LD_INT 48
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PPUSH
28065: CALL_OW 69
28069: IFFALSE 28034
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28071: LD_ADDR_VAR 0 1
28075: PUSH
28076: LD_INT 22
28078: PUSH
28079: LD_INT 3
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 34
28088: PUSH
28089: LD_INT 48
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PPUSH
28100: CALL_OW 69
28104: PUSH
28105: LD_INT 1
28107: ARRAY
28108: ST_TO_ADDR
// missionStage := 12 ;
28109: LD_ADDR_EXP 15
28113: PUSH
28114: LD_INT 12
28116: ST_TO_ADDR
// platonovHasBomb := true ;
28117: LD_ADDR_EXP 30
28121: PUSH
28122: LD_INT 1
28124: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28125: LD_VAR 0 1
28129: PPUSH
28130: LD_INT 181
28132: PPUSH
28133: LD_INT 86
28135: PPUSH
28136: CALL_OW 171
// AddComHold ( bomb ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: CALL_OW 200
// wait ( 0 0$10 ) ;
28149: LD_INT 350
28151: PPUSH
28152: CALL_OW 67
// DialogueOn ;
28156: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28160: LD_EXP 64
28164: PPUSH
28165: LD_STRING D15-Pla-1
28167: PPUSH
28168: CALL_OW 94
// dec = Query ( Q15a ) ;
28172: LD_ADDR_VAR 0 2
28176: PUSH
28177: LD_STRING Q15a
28179: PPUSH
28180: CALL_OW 97
28184: ST_TO_ADDR
// if dec = 1 then
28185: LD_VAR 0 2
28189: PUSH
28190: LD_INT 1
28192: EQUAL
28193: IFFALSE 28216
// begin Say ( JMM , D15a-JMM-1 ) ;
28195: LD_EXP 39
28199: PPUSH
28200: LD_STRING D15a-JMM-1
28202: PPUSH
28203: CALL_OW 88
// YouLost ( Surrender ) ;
28207: LD_STRING Surrender
28209: PPUSH
28210: CALL_OW 104
// exit ;
28214: GO 29172
// end ; if dec = 2 then
28216: LD_VAR 0 2
28220: PUSH
28221: LD_INT 2
28223: EQUAL
28224: IFFALSE 28293
// begin Say ( JMM , D15b-JMM-1 ) ;
28226: LD_EXP 39
28230: PPUSH
28231: LD_STRING D15b-JMM-1
28233: PPUSH
28234: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28238: LD_EXP 64
28242: PPUSH
28243: LD_STRING D15b-Pla-1
28245: PPUSH
28246: CALL_OW 94
// DialogueOff ;
28250: CALL_OW 7
// wait ( 3 3$00 ) ;
28254: LD_INT 6300
28256: PPUSH
28257: CALL_OW 67
// DialogueOn ;
28261: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28265: LD_EXP 39
28269: PPUSH
28270: LD_STRING D15d-JMM-1a
28272: PPUSH
28273: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28277: LD_EXP 64
28281: PPUSH
28282: LD_STRING D15d-Pla-1
28284: PPUSH
28285: CALL_OW 94
// DialogueOff ;
28289: CALL_OW 7
// end ; if dec = 3 then
28293: LD_VAR 0 2
28297: PUSH
28298: LD_INT 3
28300: EQUAL
28301: IFFALSE 28355
// begin Say ( JMM , D15c-JMM-1 ) ;
28303: LD_EXP 39
28307: PPUSH
28308: LD_STRING D15c-JMM-1
28310: PPUSH
28311: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28315: LD_EXP 64
28319: PPUSH
28320: LD_STRING D15c-Pla-1
28322: PPUSH
28323: CALL_OW 94
// DialogueOff ;
28327: CALL_OW 7
// wait ( 0 0$15 ) ;
28331: LD_INT 525
28333: PPUSH
28334: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28338: LD_VAR 0 1
28342: PPUSH
28343: LD_INT 60
28345: PPUSH
28346: LD_INT 95
28348: PPUSH
28349: CALL_OW 116
// exit ;
28353: GO 29172
// end ; if dec = 4 then
28355: LD_VAR 0 2
28359: PUSH
28360: LD_INT 4
28362: EQUAL
28363: IFFALSE 28393
// begin Say ( JMM , D15d-JMM-1 ) ;
28365: LD_EXP 39
28369: PPUSH
28370: LD_STRING D15d-JMM-1
28372: PPUSH
28373: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28377: LD_EXP 64
28381: PPUSH
28382: LD_STRING D15d-Pla-1
28384: PPUSH
28385: CALL_OW 94
// DialogueOff ;
28389: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28393: LD_EXP 62
28397: PPUSH
28398: CALL_OW 302
28402: PUSH
28403: LD_EXP 62
28407: PPUSH
28408: CALL_OW 255
28412: PUSH
28413: LD_INT 1
28415: EQUAL
28416: AND
28417: PUSH
28418: LD_INT 22
28420: PUSH
28421: LD_INT 1
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 34
28430: PUSH
28431: LD_INT 8
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PPUSH
28442: CALL_OW 69
28446: NOT
28447: AND
28448: IFFALSE 29073
// begin SetSide ( Friend , 8 ) ;
28450: LD_EXP 62
28454: PPUSH
28455: LD_INT 8
28457: PPUSH
28458: CALL_OW 235
// if IsInUnit ( Friend ) then
28462: LD_EXP 62
28466: PPUSH
28467: CALL_OW 310
28471: IFFALSE 28482
// ComExitBuilding ( Friend ) ;
28473: LD_EXP 62
28477: PPUSH
28478: CALL_OW 122
// if IsDriver ( Friend ) then
28482: LD_EXP 62
28486: PPUSH
28487: CALL 105695 0 1
28491: IFFALSE 28502
// ComExitVehicle ( Friend ) ;
28493: LD_EXP 62
28497: PPUSH
28498: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28502: LD_EXP 62
28506: PPUSH
28507: LD_INT 9
28509: PPUSH
28510: LD_INT 2
28512: PPUSH
28513: CALL_OW 171
// wait ( 0 0$05 ) ;
28517: LD_INT 175
28519: PPUSH
28520: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28524: LD_EXP 62
28528: PPUSH
28529: CALL_OW 87
// DialogueOn ;
28533: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28537: LD_EXP 39
28541: PPUSH
28542: LD_STRING D16-JMM-1
28544: PPUSH
28545: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28549: LD_EXP 62
28553: PPUSH
28554: LD_STRING D16-Friend-1
28556: PPUSH
28557: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28561: LD_EXP 39
28565: PPUSH
28566: LD_STRING D16-JMM-2
28568: PPUSH
28569: CALL_OW 88
// DialogueOff ;
28573: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28577: LD_EXP 62
28581: PPUSH
28582: LD_INT 1
28584: PPUSH
28585: CALL_OW 235
// ComHold ( Friend ) ;
28589: LD_EXP 62
28593: PPUSH
28594: CALL_OW 140
// wait ( 0 0$20 ) ;
28598: LD_INT 700
28600: PPUSH
28601: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28605: LD_EXP 62
28609: PPUSH
28610: LD_INT 9
28612: PPUSH
28613: LD_INT 2
28615: PPUSH
28616: CALL_OW 297
28620: PUSH
28621: LD_INT 30
28623: LESS
28624: IFFALSE 28693
// begin SetSide ( Friend , 8 ) ;
28626: LD_EXP 62
28630: PPUSH
28631: LD_INT 8
28633: PPUSH
28634: CALL_OW 235
// if IsInUnit ( Friend ) then
28638: LD_EXP 62
28642: PPUSH
28643: CALL_OW 310
28647: IFFALSE 28658
// ComExitBuilding ( Friend ) ;
28649: LD_EXP 62
28653: PPUSH
28654: CALL_OW 122
// if IsDriver ( Friend ) then
28658: LD_EXP 62
28662: PPUSH
28663: CALL 105695 0 1
28667: IFFALSE 28678
// ComExitVehicle ( Friend ) ;
28669: LD_EXP 62
28673: PPUSH
28674: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28678: LD_EXP 62
28682: PPUSH
28683: LD_INT 9
28685: PPUSH
28686: LD_INT 2
28688: PPUSH
28689: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28693: LD_INT 1050
28695: PPUSH
28696: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28700: LD_INT 22
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 34
28712: PUSH
28713: LD_INT 8
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PPUSH
28724: CALL_OW 69
28728: NOT
28729: IFFALSE 29051
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28731: LD_ADDR_VAR 0 3
28735: PUSH
28736: LD_INT 22
28738: PUSH
28739: LD_INT 1
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 26
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 3
28758: PUSH
28759: LD_INT 25
28761: PUSH
28762: LD_INT 12
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 25
28771: PUSH
28772: LD_INT 16
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: LIST
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: LIST
28788: PPUSH
28789: CALL_OW 69
28793: PUSH
28794: LD_EXP 39
28798: PUSH
28799: LD_EXP 41
28803: PUSH
28804: LD_EXP 55
28808: PUSH
28809: LD_EXP 42
28813: PUSH
28814: LD_EXP 43
28818: PUSH
28819: LD_EXP 44
28823: PUSH
28824: LD_EXP 45
28828: PUSH
28829: LD_EXP 46
28833: PUSH
28834: LD_EXP 47
28838: PUSH
28839: LD_EXP 48
28843: PUSH
28844: LD_EXP 49
28848: PUSH
28849: LD_EXP 50
28853: PUSH
28854: LD_EXP 51
28858: PUSH
28859: LD_EXP 52
28863: PUSH
28864: LD_EXP 53
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: LIST
28873: LIST
28874: LIST
28875: LIST
28876: LIST
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: DIFF
28886: ST_TO_ADDR
// DialogueOn ;
28887: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28891: LD_EXP 64
28895: PPUSH
28896: LD_STRING D16a-Pla-1
28898: PPUSH
28899: CALL_OW 94
// if Stevens then
28903: LD_EXP 41
28907: IFFALSE 28923
// Say ( Stevens , D16a-Huck-1 ) else
28909: LD_EXP 41
28913: PPUSH
28914: LD_STRING D16a-Huck-1
28916: PPUSH
28917: CALL_OW 88
28921: GO 28965
// if Baker then
28923: LD_EXP 55
28927: IFFALSE 28943
// Say ( Baker , D16a-Huck-1 ) else
28929: LD_EXP 55
28933: PPUSH
28934: LD_STRING D16a-Huck-1
28936: PPUSH
28937: CALL_OW 88
28941: GO 28965
// if tmp then
28943: LD_VAR 0 3
28947: IFFALSE 28965
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28949: LD_VAR 0 3
28953: PUSH
28954: LD_INT 1
28956: ARRAY
28957: PPUSH
28958: LD_STRING D16a-Sol1-1
28960: PPUSH
28961: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28965: LD_EXP 62
28969: PPUSH
28970: CALL_OW 255
28974: PUSH
28975: LD_INT 8
28977: EQUAL
28978: IFFALSE 28994
// Say ( JMM , D16a-JMM-1 ) else
28980: LD_EXP 39
28984: PPUSH
28985: LD_STRING D16a-JMM-1
28987: PPUSH
28988: CALL_OW 88
28992: GO 29030
// begin Say ( JMM , D16a-JMM-1a ) ;
28994: LD_EXP 39
28998: PPUSH
28999: LD_STRING D16a-JMM-1a
29001: PPUSH
29002: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29006: LD_EXP 62
29010: PPUSH
29011: LD_STRING D16a-Friend-1
29013: PPUSH
29014: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29018: LD_EXP 62
29022: PPUSH
29023: LD_INT 3
29025: PPUSH
29026: CALL_OW 235
// end ; DialogueOff ;
29030: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29034: LD_VAR 0 1
29038: PPUSH
29039: LD_INT 60
29041: PPUSH
29042: LD_INT 95
29044: PPUSH
29045: CALL_OW 116
// end else
29049: GO 29071
// begin DialogueOn ;
29051: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29055: LD_EXP 64
29059: PPUSH
29060: LD_STRING D16c-Pla-
29062: PPUSH
29063: CALL_OW 94
// DialogueOff ;
29067: CALL_OW 7
// end ; end else
29071: GO 29172
// begin wait ( 3 3$00 ) ;
29073: LD_INT 6300
29075: PPUSH
29076: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29080: LD_INT 22
29082: PUSH
29083: LD_INT 1
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 34
29092: PUSH
29093: LD_INT 8
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PPUSH
29104: CALL_OW 69
29108: NOT
29109: IFFALSE 29152
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29111: LD_EXP 64
29115: PPUSH
29116: LD_STRING D16b-Pla-1
29118: PPUSH
29119: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29123: LD_EXP 39
29127: PPUSH
29128: LD_STRING D16b-JMM-
29130: PPUSH
29131: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29135: LD_VAR 0 1
29139: PPUSH
29140: LD_INT 60
29142: PPUSH
29143: LD_INT 95
29145: PPUSH
29146: CALL_OW 116
// end else
29150: GO 29172
// begin DialogueOn ;
29152: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29156: LD_EXP 64
29160: PPUSH
29161: LD_STRING D16c-Pla-
29163: PPUSH
29164: CALL_OW 94
// DialogueOff ;
29168: CALL_OW 7
// end ; end ; end ;
29172: PPOPN 3
29174: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29175: LD_EXP 14
29179: PUSH
29180: LD_INT 126000
29182: GREATEREQUAL
29183: PUSH
29184: LD_EXP 23
29188: NOT
29189: AND
29190: PUSH
29191: LD_EXP 74
29195: PPUSH
29196: CALL_OW 302
29200: AND
29201: IFFALSE 29559
29203: GO 29205
29205: DISABLE
29206: LD_INT 0
29208: PPUSH
// begin missionStage = 11 ;
29209: LD_ADDR_EXP 15
29213: PUSH
29214: LD_INT 11
29216: ST_TO_ADDR
// DialogueOn ;
29217: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29221: LD_EXP 74
29225: PPUSH
29226: LD_STRING D9-Roth-1
29228: PPUSH
29229: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29233: LD_EXP 39
29237: PPUSH
29238: LD_STRING D9-JMM-1
29240: PPUSH
29241: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29245: LD_EXP 74
29249: PPUSH
29250: LD_STRING D9-Roth-2
29252: PPUSH
29253: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29257: LD_EXP 74
29261: PPUSH
29262: LD_STRING D9-Roth-2a
29264: PPUSH
29265: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29269: LD_EXP 64
29273: PPUSH
29274: LD_STRING D9-Pla-2
29276: PPUSH
29277: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29281: LD_EXP 74
29285: PPUSH
29286: LD_STRING D9-Roth-3
29288: PPUSH
29289: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29293: LD_EXP 64
29297: PPUSH
29298: LD_STRING D9-Pla-3
29300: PPUSH
29301: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29305: LD_EXP 74
29309: PPUSH
29310: LD_STRING D9-Roth-4
29312: PPUSH
29313: CALL_OW 94
// dec = Query ( Q9 ) ;
29317: LD_ADDR_VAR 0 1
29321: PUSH
29322: LD_STRING Q9
29324: PPUSH
29325: CALL_OW 97
29329: ST_TO_ADDR
// if dec = 1 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 1
29337: EQUAL
29338: IFFALSE 29352
// SayRadio ( Roth , D9a-Roth-1 ) ;
29340: LD_EXP 74
29344: PPUSH
29345: LD_STRING D9a-Roth-1
29347: PPUSH
29348: CALL_OW 94
// if dec = 2 then
29352: LD_VAR 0 1
29356: PUSH
29357: LD_INT 2
29359: EQUAL
29360: IFFALSE 29386
// begin Say ( JMM , D9b-JMM-1 ) ;
29362: LD_EXP 39
29366: PPUSH
29367: LD_STRING D9b-JMM-1
29369: PPUSH
29370: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29374: LD_EXP 74
29378: PPUSH
29379: LD_STRING D9b-Roth-1
29381: PPUSH
29382: CALL_OW 94
// end ; if dec = 3 then
29386: LD_VAR 0 1
29390: PUSH
29391: LD_INT 3
29393: EQUAL
29394: IFFALSE 29456
// begin Say ( JMM , D9c-JMM-1 ) ;
29396: LD_EXP 39
29400: PPUSH
29401: LD_STRING D9c-JMM-1
29403: PPUSH
29404: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29408: LD_EXP 74
29412: PPUSH
29413: LD_STRING D9c-Roth-1
29415: PPUSH
29416: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29420: LD_EXP 39
29424: PPUSH
29425: LD_STRING D9c-JMM-2
29427: PPUSH
29428: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29432: LD_EXP 74
29436: PPUSH
29437: LD_STRING D9c-Roth-2
29439: PPUSH
29440: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29444: LD_EXP 39
29448: PPUSH
29449: LD_STRING D9c-JMM-3
29451: PPUSH
29452: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29456: LD_EXP 74
29460: PPUSH
29461: LD_STRING D9c-Roth-3
29463: PPUSH
29464: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29468: LD_EXP 74
29472: PPUSH
29473: LD_STRING D9cont-Roth-1
29475: PPUSH
29476: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29480: LD_EXP 39
29484: PPUSH
29485: LD_STRING D9cont-JMM-1
29487: PPUSH
29488: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29492: LD_EXP 74
29496: PPUSH
29497: LD_STRING D9cont-Roth-2
29499: PPUSH
29500: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29504: LD_EXP 39
29508: PPUSH
29509: LD_STRING D9cont-JMM-2
29511: PPUSH
29512: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29516: LD_EXP 74
29520: PPUSH
29521: LD_STRING D9cont-Roth-3
29523: PPUSH
29524: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29528: LD_EXP 39
29532: PPUSH
29533: LD_STRING D9cont-JMM-3
29535: PPUSH
29536: CALL_OW 88
// DialogueOff ;
29540: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29544: LD_STRING M3
29546: PPUSH
29547: CALL_OW 337
// allianceActive := true ;
29551: LD_ADDR_EXP 31
29555: PUSH
29556: LD_INT 1
29558: ST_TO_ADDR
// end ;
29559: PPOPN 1
29561: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29562: LD_EXP 64
29566: PPUSH
29567: CALL_OW 301
29571: PUSH
29572: LD_EXP 67
29576: PPUSH
29577: CALL_OW 301
29581: AND
29582: PUSH
29583: LD_INT 22
29585: PUSH
29586: LD_INT 3
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 21
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 50
29605: PUSH
29606: EMPTY
29607: LIST
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL_OW 69
29618: PUSH
29619: LD_INT 7
29621: PUSH
29622: LD_INT 8
29624: PUSH
29625: LD_INT 9
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: LIST
29632: PUSH
29633: LD_OWVAR 67
29637: ARRAY
29638: LESS
29639: AND
29640: IFFALSE 30411
29642: GO 29644
29644: DISABLE
29645: LD_INT 0
29647: PPUSH
29648: PPUSH
29649: PPUSH
29650: PPUSH
// begin MC_Kill ( 1 ) ;
29651: LD_INT 1
29653: PPUSH
29654: CALL 35176 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29658: LD_INT 1
29660: PPUSH
29661: LD_INT 3
29663: PPUSH
29664: LD_INT 1
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29674: LD_ADDR_VAR 0 1
29678: PUSH
29679: LD_INT 22
29681: PUSH
29682: LD_INT 3
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 21
29691: PUSH
29692: LD_INT 1
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 24
29701: PUSH
29702: LD_INT 900
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: PPUSH
29714: CALL_OW 69
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29751
// if GetSex ( i ) = sex_male then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 258
29731: PUSH
29732: LD_INT 1
29734: EQUAL
29735: IFFALSE 29749
// begin tmp = i ;
29737: LD_ADDR_VAR 0 2
29741: PUSH
29742: LD_VAR 0 1
29746: ST_TO_ADDR
// break ;
29747: GO 29751
// end ;
29749: GO 29719
29751: POP
29752: POP
// if tmp = 0 then
29753: LD_VAR 0 2
29757: PUSH
29758: LD_INT 0
29760: EQUAL
29761: IFFALSE 29815
// begin uc_side = 3 ;
29763: LD_ADDR_OWVAR 20
29767: PUSH
29768: LD_INT 3
29770: ST_TO_ADDR
// uc_nation = 3 ;
29771: LD_ADDR_OWVAR 21
29775: PUSH
29776: LD_INT 3
29778: ST_TO_ADDR
// hc_name =  ;
29779: LD_ADDR_OWVAR 26
29783: PUSH
29784: LD_STRING 
29786: ST_TO_ADDR
// hc_gallery =  ;
29787: LD_ADDR_OWVAR 33
29791: PUSH
29792: LD_STRING 
29794: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29795: LD_INT 1
29797: PPUSH
29798: LD_INT 10
29800: PPUSH
29801: CALL_OW 381
// tmp = CreateHuman ;
29805: LD_ADDR_VAR 0 2
29809: PUSH
29810: CALL_OW 44
29814: ST_TO_ADDR
// end ; DialogueOn ;
29815: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29819: LD_VAR 0 2
29823: PPUSH
29824: LD_STRING DSurrenderRussians-RSol1-1a
29826: PPUSH
29827: CALL_OW 94
// DialogueOff ;
29831: CALL_OW 7
// russianDestroyed := true ;
29835: LD_ADDR_EXP 21
29839: PUSH
29840: LD_INT 1
29842: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29843: LD_INT 22
29845: PUSH
29846: LD_INT 3
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 21
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 69
29871: PPUSH
29872: CALL_OW 122
// wait ( 0 0$1 ) ;
29876: LD_INT 35
29878: PPUSH
29879: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29883: LD_INT 22
29885: PUSH
29886: LD_INT 3
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 21
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: PPUSH
29907: CALL_OW 69
29911: PPUSH
29912: LD_INT 25
29914: PPUSH
29915: CALL_OW 173
// wait ( 0 0$10 ) ;
29919: LD_INT 350
29921: PPUSH
29922: CALL_OW 67
// PrepareOmarInvasion ;
29926: CALL 13863 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29930: LD_ADDR_VAR 0 2
29934: PUSH
29935: LD_EXP 92
29939: PPUSH
29940: CALL_OW 250
29944: PUSH
29945: LD_EXP 92
29949: PPUSH
29950: CALL_OW 251
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29959: LD_VAR 0 2
29963: PUSH
29964: LD_INT 1
29966: ARRAY
29967: PPUSH
29968: LD_VAR 0 2
29972: PUSH
29973: LD_INT 2
29975: ARRAY
29976: PPUSH
29977: LD_INT 1
29979: PPUSH
29980: LD_INT 8
29982: NEG
29983: PPUSH
29984: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29988: LD_EXP 92
29992: PPUSH
29993: CALL_OW 87
// DialogueOn ;
29997: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30001: LD_EXP 39
30005: PPUSH
30006: LD_STRING D19-JMM-1
30008: PPUSH
30009: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30013: LD_ADDR_VAR 0 3
30017: PUSH
30018: LD_INT 22
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 26
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 2
30040: PUSH
30041: LD_INT 25
30043: PUSH
30044: LD_INT 1
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 25
30053: PUSH
30054: LD_INT 2
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 25
30063: PUSH
30064: LD_INT 3
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 25
30073: PUSH
30074: LD_INT 4
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 25
30083: PUSH
30084: LD_INT 5
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 25
30093: PUSH
30094: LD_INT 8
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: LIST
30114: PPUSH
30115: CALL_OW 69
30119: PUSH
30120: LD_EXP 39
30124: PUSH
30125: LD_EXP 40
30129: PUSH
30130: LD_EXP 41
30134: PUSH
30135: LD_EXP 42
30139: PUSH
30140: LD_EXP 43
30144: PUSH
30145: LD_EXP 44
30149: PUSH
30150: LD_EXP 45
30154: PUSH
30155: LD_EXP 46
30159: PUSH
30160: LD_EXP 47
30164: PUSH
30165: LD_EXP 48
30169: PUSH
30170: LD_EXP 49
30174: PUSH
30175: LD_EXP 50
30179: PUSH
30180: LD_EXP 51
30184: PUSH
30185: LD_EXP 52
30189: PUSH
30190: LD_EXP 53
30194: PUSH
30195: LD_EXP 54
30199: PUSH
30200: LD_EXP 55
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: DIFF
30224: ST_TO_ADDR
// if tmp2 then
30225: LD_VAR 0 3
30229: IFFALSE 30247
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30231: LD_VAR 0 3
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: PPUSH
30240: LD_STRING D19-Sol1-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30247: LD_EXP 39
30251: PPUSH
30252: LD_STRING D19-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30263: LD_VAR 0 2
30267: PUSH
30268: LD_INT 1
30270: ARRAY
30271: PPUSH
30272: LD_VAR 0 2
30276: PUSH
30277: LD_INT 2
30279: ARRAY
30280: PPUSH
30281: LD_INT 1
30283: PPUSH
30284: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30288: LD_STRING M5
30290: PPUSH
30291: CALL_OW 337
// omarOnMotherLode := false ;
30295: LD_ADDR_VAR 0 4
30299: PUSH
30300: LD_INT 0
30302: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30303: LD_INT 35
30305: PPUSH
30306: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30310: LD_EXP 92
30314: PPUSH
30315: LD_INT 215
30317: PPUSH
30318: LD_INT 100
30320: PPUSH
30321: CALL_OW 297
30325: PUSH
30326: LD_INT 10
30328: LESS
30329: PUSH
30330: LD_VAR 0 4
30334: NOT
30335: AND
30336: IFFALSE 30370
// begin omarOnMotherLode := true ;
30338: LD_ADDR_VAR 0 4
30342: PUSH
30343: LD_INT 1
30345: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30346: LD_EXP 39
30350: PPUSH
30351: LD_STRING D19b-JMM-1
30353: PPUSH
30354: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30358: LD_EXP 92
30362: PPUSH
30363: LD_STRING DOmarContam-Omar-1
30365: PPUSH
30366: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30370: LD_EXP 92
30374: PPUSH
30375: CALL_OW 301
30379: IFFALSE 30303
// Say ( JMM , D19a-JMM-1 ) ;
30381: LD_EXP 39
30385: PPUSH
30386: LD_STRING D19a-JMM-1
30388: PPUSH
30389: CALL_OW 88
// if Heike then
30393: LD_EXP 93
30397: IFFALSE 30411
// Say ( Heike , D19a-Hke-1 ) ;
30399: LD_EXP 93
30403: PPUSH
30404: LD_STRING D19a-Hke-1
30406: PPUSH
30407: CALL_OW 88
// end ;
30411: PPOPN 4
30413: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30414: LD_INT 22
30416: PUSH
30417: LD_INT 3
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 21
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PPUSH
30438: CALL_OW 69
30442: PUSH
30443: LD_EXP 21
30447: AND
30448: IFFALSE 30516
30450: GO 30452
30452: DISABLE
30453: LD_INT 0
30455: PPUSH
30456: PPUSH
// begin enable ;
30457: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30458: LD_ADDR_VAR 0 2
30462: PUSH
30463: LD_INT 25
30465: PPUSH
30466: LD_INT 22
30468: PUSH
30469: LD_INT 3
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PPUSH
30476: CALL_OW 70
30480: ST_TO_ADDR
// if not tmp then
30481: LD_VAR 0 2
30485: NOT
30486: IFFALSE 30490
// exit ;
30488: GO 30516
// for i in tmp do
30490: LD_ADDR_VAR 0 1
30494: PUSH
30495: LD_VAR 0 2
30499: PUSH
30500: FOR_IN
30501: IFFALSE 30514
// RemoveUnit ( i ) ;
30503: LD_VAR 0 1
30507: PPUSH
30508: CALL_OW 64
30512: GO 30500
30514: POP
30515: POP
// end ;
30516: PPOPN 2
30518: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30519: LD_INT 22
30521: PUSH
30522: LD_INT 7
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 21
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PPUSH
30543: CALL_OW 69
30547: PUSH
30548: LD_INT 6
30550: LESS
30551: IFFALSE 31019
30553: GO 30555
30555: DISABLE
30556: LD_INT 0
30558: PPUSH
30559: PPUSH
// begin MC_Kill ( 1 ) ;
30560: LD_INT 1
30562: PPUSH
30563: CALL 35176 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30567: LD_INT 7
30569: PPUSH
30570: LD_INT 1
30572: PPUSH
30573: LD_INT 1
30575: PPUSH
30576: LD_INT 1
30578: PPUSH
30579: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30583: LD_ADDR_VAR 0 1
30587: PUSH
30588: LD_INT 22
30590: PUSH
30591: LD_INT 7
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 26
30600: PUSH
30601: LD_INT 1
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PPUSH
30612: CALL_OW 69
30616: PUSH
30617: LD_EXP 74
30621: DIFF
30622: ST_TO_ADDR
// if tmp then
30623: LD_VAR 0 1
30627: IFFALSE 30645
// tmp := tmp [ 1 ] else
30629: LD_ADDR_VAR 0 1
30633: PUSH
30634: LD_VAR 0 1
30638: PUSH
30639: LD_INT 1
30641: ARRAY
30642: ST_TO_ADDR
30643: GO 30681
// begin uc_side := 7 ;
30645: LD_ADDR_OWVAR 20
30649: PUSH
30650: LD_INT 7
30652: ST_TO_ADDR
// uc_nation := 1 ;
30653: LD_ADDR_OWVAR 21
30657: PUSH
30658: LD_INT 1
30660: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30661: LD_INT 1
30663: PPUSH
30664: LD_INT 8
30666: PPUSH
30667: CALL_OW 384
// tmp := CreateHuman ;
30671: LD_ADDR_VAR 0 1
30675: PUSH
30676: CALL_OW 44
30680: ST_TO_ADDR
// end ; DialogueOn ;
30681: CALL_OW 6
// if IsOK ( Roth ) then
30685: LD_EXP 74
30689: PPUSH
30690: CALL_OW 302
30694: IFFALSE 30708
// Say ( JMM , DAb-JMM-1 ) ;
30696: LD_EXP 39
30700: PPUSH
30701: LD_STRING DAb-JMM-1
30703: PPUSH
30704: CALL_OW 88
// if IsOK ( Roth ) then
30708: LD_EXP 74
30712: PPUSH
30713: CALL_OW 302
30717: IFFALSE 30741
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30719: LD_EXP 74
30723: PPUSH
30724: LD_STRING DSurrenderAlliance-Roth-1
30726: PPUSH
30727: CALL_OW 88
// RothCaptured := true ;
30731: LD_ADDR_EXP 33
30735: PUSH
30736: LD_INT 1
30738: ST_TO_ADDR
// end else
30739: GO 30753
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30741: LD_VAR 0 1
30745: PPUSH
30746: LD_STRING DSurrenderAlliance-Sci1-1
30748: PPUSH
30749: CALL_OW 88
// DialogueOff ;
30753: CALL_OW 7
// allianceDestroyed := true ;
30757: LD_ADDR_EXP 23
30761: PUSH
30762: LD_INT 1
30764: ST_TO_ADDR
// if capturedUnit = 0 then
30765: LD_EXP 34
30769: PUSH
30770: LD_INT 0
30772: EQUAL
30773: IFFALSE 30782
// SetAchievement ( ACH_ALLIANCE ) ;
30775: LD_STRING ACH_ALLIANCE
30777: PPUSH
30778: CALL_OW 543
// if trueAmericans then
30782: LD_EXP 35
30786: IFFALSE 30862
// begin if trueAmericans = 1 then
30788: LD_EXP 35
30792: PUSH
30793: LD_INT 1
30795: EQUAL
30796: IFFALSE 30812
// Say ( JMM , DAb-JMM-1a ) else
30798: LD_EXP 39
30802: PPUSH
30803: LD_STRING DAb-JMM-1a
30805: PPUSH
30806: CALL_OW 88
30810: GO 30824
// Say ( JMM , DAb-JMM-1b ) ;
30812: LD_EXP 39
30816: PPUSH
30817: LD_STRING DAb-JMM-1b
30819: PPUSH
30820: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30824: LD_EXP 35
30828: PPUSH
30829: CALL_OW 87
// for i in trueAmericans do
30833: LD_ADDR_VAR 0 2
30837: PUSH
30838: LD_EXP 35
30842: PUSH
30843: FOR_IN
30844: IFFALSE 30860
// SetSide ( i , 1 ) ;
30846: LD_VAR 0 2
30850: PPUSH
30851: LD_INT 1
30853: PPUSH
30854: CALL_OW 235
30858: GO 30843
30860: POP
30861: POP
// end ; repeat wait ( 0 0$1 ) ;
30862: LD_INT 35
30864: PPUSH
30865: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30869: LD_ADDR_VAR 0 2
30873: PUSH
30874: LD_INT 22
30876: PUSH
30877: LD_INT 7
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 21
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PPUSH
30898: CALL_OW 69
30902: PUSH
30903: FOR_IN
30904: IFFALSE 30986
// begin if IsInUnit ( i ) then
30906: LD_VAR 0 2
30910: PPUSH
30911: CALL_OW 310
30915: IFFALSE 30926
// ComExitBuilding ( i ) ;
30917: LD_VAR 0 2
30921: PPUSH
30922: CALL_OW 122
// if IsDriver ( i ) then
30926: LD_VAR 0 2
30930: PPUSH
30931: CALL 105695 0 1
30935: IFFALSE 30946
// ComExitVehicle ( i ) ;
30937: LD_VAR 0 2
30941: PPUSH
30942: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30946: LD_VAR 0 2
30950: PPUSH
30951: LD_INT 26
30953: PPUSH
30954: CALL_OW 308
30958: NOT
30959: IFFALSE 30975
// AddComMoveToArea ( i , allianceEscapeArea ) else
30961: LD_VAR 0 2
30965: PPUSH
30966: LD_INT 26
30968: PPUSH
30969: CALL_OW 173
30973: GO 30984
// RemoveUnit ( i ) ;
30975: LD_VAR 0 2
30979: PPUSH
30980: CALL_OW 64
// end ;
30984: GO 30903
30986: POP
30987: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30988: LD_INT 22
30990: PUSH
30991: LD_INT 7
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 21
31000: PUSH
31001: LD_INT 1
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PPUSH
31012: CALL_OW 69
31016: NOT
31017: IFFALSE 30862
// end ;
31019: PPOPN 2
31021: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31022: LD_INT 0
31024: PPUSH
31025: PPUSH
// if not unit then
31026: LD_VAR 0 1
31030: NOT
31031: IFFALSE 31035
// exit ;
31033: GO 32533
// DoNotAttack ( 7 , unit ) ;
31035: LD_INT 7
31037: PPUSH
31038: LD_VAR 0 1
31042: PPUSH
31043: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31047: LD_VAR 0 1
31051: PPUSH
31052: LD_INT 260
31054: PPUSH
31055: LD_INT 235
31057: PPUSH
31058: LD_INT 3
31060: PPUSH
31061: LD_INT 1
31063: PPUSH
31064: CALL_OW 483
// SetSide ( unit , 4 ) ;
31068: LD_VAR 0 1
31072: PPUSH
31073: LD_INT 4
31075: PPUSH
31076: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31080: LD_ADDR_EXP 34
31084: PUSH
31085: LD_EXP 34
31089: PUSH
31090: LD_INT 1
31092: PLUS
31093: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31094: LD_INT 70
31096: PPUSH
31097: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31101: LD_INT 260
31103: PPUSH
31104: LD_INT 235
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: LD_INT 8
31112: NEG
31113: PPUSH
31114: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31127: LD_VAR 0 1
31131: PPUSH
31132: LD_EXP 74
31136: PPUSH
31137: CALL_OW 119
// DialogueOn ;
31141: CALL_OW 6
// case unit of JMM :
31145: LD_VAR 0 1
31149: PUSH
31150: LD_EXP 39
31154: DOUBLE
31155: EQUAL
31156: IFTRUE 31160
31158: GO 31175
31160: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31161: LD_EXP 39
31165: PPUSH
31166: LD_STRING DA1-JMM-1
31168: PPUSH
31169: CALL_OW 91
31173: GO 31617
31175: LD_EXP 40
31179: DOUBLE
31180: EQUAL
31181: IFTRUE 31185
31183: GO 31200
31185: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31186: LD_EXP 40
31190: PPUSH
31191: LD_STRING DA1-Joan-1
31193: PPUSH
31194: CALL_OW 91
31198: GO 31617
31200: LD_EXP 42
31204: DOUBLE
31205: EQUAL
31206: IFTRUE 31210
31208: GO 31225
31210: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31211: LD_EXP 42
31215: PPUSH
31216: LD_STRING DA1-Lisa-1
31218: PPUSH
31219: CALL_OW 91
31223: GO 31617
31225: LD_EXP 43
31229: DOUBLE
31230: EQUAL
31231: IFTRUE 31235
31233: GO 31250
31235: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31236: LD_EXP 43
31240: PPUSH
31241: LD_STRING DA1-Don-1
31243: PPUSH
31244: CALL_OW 91
31248: GO 31617
31250: LD_EXP 50
31254: DOUBLE
31255: EQUAL
31256: IFTRUE 31260
31258: GO 31275
31260: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31261: LD_EXP 50
31265: PPUSH
31266: LD_STRING DA1-Corn-1
31268: PPUSH
31269: CALL_OW 91
31273: GO 31617
31275: LD_EXP 46
31279: DOUBLE
31280: EQUAL
31281: IFTRUE 31285
31283: GO 31300
31285: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31286: LD_EXP 46
31290: PPUSH
31291: LD_STRING DA1-Den-1
31293: PPUSH
31294: CALL_OW 91
31298: GO 31617
31300: LD_EXP 44
31304: DOUBLE
31305: EQUAL
31306: IFTRUE 31310
31308: GO 31325
31310: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31311: LD_EXP 44
31315: PPUSH
31316: LD_STRING DA1-Bobby-1
31318: PPUSH
31319: CALL_OW 91
31323: GO 31617
31325: LD_EXP 48
31329: DOUBLE
31330: EQUAL
31331: IFTRUE 31335
31333: GO 31350
31335: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31336: LD_EXP 48
31340: PPUSH
31341: LD_STRING DA1-Glad-1
31343: PPUSH
31344: CALL_OW 91
31348: GO 31617
31350: LD_EXP 45
31354: DOUBLE
31355: EQUAL
31356: IFTRUE 31360
31358: GO 31375
31360: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31361: LD_EXP 45
31365: PPUSH
31366: LD_STRING DA1-Cyrus-1
31368: PPUSH
31369: CALL_OW 91
31373: GO 31617
31375: LD_EXP 41
31379: DOUBLE
31380: EQUAL
31381: IFTRUE 31385
31383: GO 31400
31385: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31386: LD_EXP 41
31390: PPUSH
31391: LD_STRING DA1-Huck-1
31393: PPUSH
31394: CALL_OW 91
31398: GO 31617
31400: LD_EXP 55
31404: DOUBLE
31405: EQUAL
31406: IFTRUE 31410
31408: GO 31425
31410: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31411: LD_EXP 55
31415: PPUSH
31416: LD_STRING DA1-Huck-1
31418: PPUSH
31419: CALL_OW 91
31423: GO 31617
31425: LD_EXP 47
31429: DOUBLE
31430: EQUAL
31431: IFTRUE 31435
31433: GO 31450
31435: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31436: LD_EXP 47
31440: PPUSH
31441: LD_STRING DA1-Brown-1
31443: PPUSH
31444: CALL_OW 91
31448: GO 31617
31450: LD_EXP 51
31454: DOUBLE
31455: EQUAL
31456: IFTRUE 31460
31458: GO 31475
31460: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31461: LD_EXP 51
31465: PPUSH
31466: LD_STRING DA1-Gary-1
31468: PPUSH
31469: CALL_OW 91
31473: GO 31617
31475: LD_EXP 54
31479: DOUBLE
31480: EQUAL
31481: IFTRUE 31485
31483: GO 31500
31485: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31486: LD_EXP 54
31490: PPUSH
31491: LD_STRING DA1-Con-1
31493: PPUSH
31494: CALL_OW 91
31498: GO 31617
31500: LD_EXP 60
31504: DOUBLE
31505: EQUAL
31506: IFTRUE 31510
31508: GO 31525
31510: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31511: LD_EXP 60
31515: PPUSH
31516: LD_STRING DA1-Kurt-1
31518: PPUSH
31519: CALL_OW 91
31523: GO 31617
31525: LD_EXP 53
31529: DOUBLE
31530: EQUAL
31531: IFTRUE 31535
31533: GO 31550
31535: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31536: LD_EXP 53
31540: PPUSH
31541: LD_STRING DA1-Yam-1
31543: PPUSH
31544: CALL_OW 91
31548: GO 31617
31550: LD_EXP 52
31554: DOUBLE
31555: EQUAL
31556: IFTRUE 31560
31558: GO 31575
31560: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31561: LD_EXP 52
31565: PPUSH
31566: LD_STRING DA1-Frank-1
31568: PPUSH
31569: CALL_OW 91
31573: GO 31617
31575: POP
// begin if GetSex ( unit ) = sex_male then
31576: LD_VAR 0 1
31580: PPUSH
31581: CALL_OW 258
31585: PUSH
31586: LD_INT 1
31588: EQUAL
31589: IFFALSE 31605
// ForceSay ( unit , DA1-Sol1-1 ) else
31591: LD_VAR 0 1
31595: PPUSH
31596: LD_STRING DA1-Sol1-1
31598: PPUSH
31599: CALL_OW 91
31603: GO 31617
// ForceSay ( unit , DA1-FSol1-1 ) ;
31605: LD_VAR 0 1
31609: PPUSH
31610: LD_STRING DA1-FSol1-1
31612: PPUSH
31613: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31617: LD_EXP 74
31621: PPUSH
31622: LD_STRING DA-Roth-1
31624: PPUSH
31625: CALL_OW 88
// if capturedUnit = 1 then
31629: LD_EXP 34
31633: PUSH
31634: LD_INT 1
31636: EQUAL
31637: IFFALSE 31665
// begin Say ( Simms , DA-Sim-1 ) ;
31639: LD_EXP 75
31643: PPUSH
31644: LD_STRING DA-Sim-1
31646: PPUSH
31647: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31651: LD_EXP 74
31655: PPUSH
31656: LD_STRING DA-Roth-2
31658: PPUSH
31659: CALL_OW 88
// end else
31663: GO 31677
// Say ( Simms , DA-Sim-2 ) ;
31665: LD_EXP 75
31669: PPUSH
31670: LD_STRING DA-Sim-2
31672: PPUSH
31673: CALL_OW 88
// case unit of JMM :
31677: LD_VAR 0 1
31681: PUSH
31682: LD_EXP 39
31686: DOUBLE
31687: EQUAL
31688: IFTRUE 31692
31690: GO 31707
31692: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31693: LD_EXP 39
31697: PPUSH
31698: LD_STRING DA1-JMM-1a
31700: PPUSH
31701: CALL_OW 91
31705: GO 32214
31707: LD_EXP 40
31711: DOUBLE
31712: EQUAL
31713: IFTRUE 31717
31715: GO 31732
31717: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31718: LD_EXP 40
31722: PPUSH
31723: LD_STRING DA1-Joan-1a
31725: PPUSH
31726: CALL_OW 91
31730: GO 32214
31732: LD_EXP 42
31736: DOUBLE
31737: EQUAL
31738: IFTRUE 31742
31740: GO 31757
31742: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31743: LD_EXP 42
31747: PPUSH
31748: LD_STRING DA1-Lisa-1a
31750: PPUSH
31751: CALL_OW 91
31755: GO 32214
31757: LD_EXP 43
31761: DOUBLE
31762: EQUAL
31763: IFTRUE 31767
31765: GO 31782
31767: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31768: LD_EXP 43
31772: PPUSH
31773: LD_STRING DA1-Don-1a
31775: PPUSH
31776: CALL_OW 91
31780: GO 32214
31782: LD_EXP 50
31786: DOUBLE
31787: EQUAL
31788: IFTRUE 31792
31790: GO 31807
31792: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31793: LD_EXP 50
31797: PPUSH
31798: LD_STRING DA1-Corn-1a
31800: PPUSH
31801: CALL_OW 91
31805: GO 32214
31807: LD_EXP 46
31811: DOUBLE
31812: EQUAL
31813: IFTRUE 31817
31815: GO 31832
31817: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31818: LD_EXP 46
31822: PPUSH
31823: LD_STRING DA1-Den-1a
31825: PPUSH
31826: CALL_OW 91
31830: GO 32214
31832: LD_EXP 44
31836: DOUBLE
31837: EQUAL
31838: IFTRUE 31842
31840: GO 31857
31842: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31843: LD_EXP 44
31847: PPUSH
31848: LD_STRING DA1-Bobby-1a
31850: PPUSH
31851: CALL_OW 91
31855: GO 32214
31857: LD_EXP 48
31861: DOUBLE
31862: EQUAL
31863: IFTRUE 31867
31865: GO 31882
31867: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31868: LD_EXP 48
31872: PPUSH
31873: LD_STRING DA1-Glad-1a
31875: PPUSH
31876: CALL_OW 91
31880: GO 32214
31882: LD_EXP 45
31886: DOUBLE
31887: EQUAL
31888: IFTRUE 31892
31890: GO 31907
31892: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31893: LD_EXP 45
31897: PPUSH
31898: LD_STRING DA1-Cyrus-1a
31900: PPUSH
31901: CALL_OW 91
31905: GO 32214
31907: LD_EXP 41
31911: DOUBLE
31912: EQUAL
31913: IFTRUE 31917
31915: GO 31932
31917: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31918: LD_EXP 41
31922: PPUSH
31923: LD_STRING DA1-Huck-1a
31925: PPUSH
31926: CALL_OW 91
31930: GO 32214
31932: LD_EXP 55
31936: DOUBLE
31937: EQUAL
31938: IFTRUE 31942
31940: GO 31957
31942: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31943: LD_EXP 55
31947: PPUSH
31948: LD_STRING DA1-Huck-1a
31950: PPUSH
31951: CALL_OW 91
31955: GO 32214
31957: LD_EXP 47
31961: DOUBLE
31962: EQUAL
31963: IFTRUE 31967
31965: GO 31982
31967: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31968: LD_EXP 47
31972: PPUSH
31973: LD_STRING DA1-Brown-1a
31975: PPUSH
31976: CALL_OW 91
31980: GO 32214
31982: LD_EXP 51
31986: DOUBLE
31987: EQUAL
31988: IFTRUE 31992
31990: GO 32007
31992: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31993: LD_EXP 51
31997: PPUSH
31998: LD_STRING DA1-Gary-1a
32000: PPUSH
32001: CALL_OW 91
32005: GO 32214
32007: LD_EXP 54
32011: DOUBLE
32012: EQUAL
32013: IFTRUE 32017
32015: GO 32032
32017: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32018: LD_EXP 54
32022: PPUSH
32023: LD_STRING DA1-Con-1a
32025: PPUSH
32026: CALL_OW 91
32030: GO 32214
32032: LD_EXP 60
32036: DOUBLE
32037: EQUAL
32038: IFTRUE 32042
32040: GO 32057
32042: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32043: LD_EXP 60
32047: PPUSH
32048: LD_STRING DA1-Kurt-1a
32050: PPUSH
32051: CALL_OW 91
32055: GO 32214
32057: LD_EXP 53
32061: DOUBLE
32062: EQUAL
32063: IFTRUE 32067
32065: GO 32082
32067: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32068: LD_EXP 53
32072: PPUSH
32073: LD_STRING DA1-Yam-1a
32075: PPUSH
32076: CALL_OW 91
32080: GO 32214
32082: LD_EXP 52
32086: DOUBLE
32087: EQUAL
32088: IFTRUE 32092
32090: GO 32107
32092: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32093: LD_EXP 52
32097: PPUSH
32098: LD_STRING DA1-Frank-1a
32100: PPUSH
32101: CALL_OW 91
32105: GO 32214
32107: POP
// begin join := rand ( 0 , 1 ) ;
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 0
32115: PPUSH
32116: LD_INT 1
32118: PPUSH
32119: CALL_OW 12
32123: ST_TO_ADDR
// if join then
32124: LD_VAR 0 3
32128: IFFALSE 32173
// begin if GetSex ( unit ) = sex_male then
32130: LD_VAR 0 1
32134: PPUSH
32135: CALL_OW 258
32139: PUSH
32140: LD_INT 1
32142: EQUAL
32143: IFFALSE 32159
// ForceSay ( unit , DA1-Sol1-1b ) else
32145: LD_VAR 0 1
32149: PPUSH
32150: LD_STRING DA1-Sol1-1b
32152: PPUSH
32153: CALL_OW 91
32157: GO 32171
// ForceSay ( unit , DA1-FSol1-1b ) ;
32159: LD_VAR 0 1
32163: PPUSH
32164: LD_STRING DA1-FSol1-1b
32166: PPUSH
32167: CALL_OW 91
// end else
32171: GO 32214
// begin if GetSex ( unit ) = sex_male then
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 258
32182: PUSH
32183: LD_INT 1
32185: EQUAL
32186: IFFALSE 32202
// ForceSay ( unit , DA1-Sol1-1a ) else
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_STRING DA1-Sol1-1a
32195: PPUSH
32196: CALL_OW 91
32200: GO 32214
// ForceSay ( unit , DA1-FSol1-1a ) ;
32202: LD_VAR 0 1
32206: PPUSH
32207: LD_STRING DA1-FSol1-1a
32209: PPUSH
32210: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32214: LD_VAR 0 1
32218: PUSH
32219: LD_EXP 39
32223: EQUAL
32224: IFFALSE 32235
// begin YouLost ( JMMCaptured ) ;
32226: LD_STRING JMMCaptured
32228: PPUSH
32229: CALL_OW 104
// exit ;
32233: GO 32533
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32235: LD_VAR 0 1
32239: PUSH
32240: LD_EXP 43
32244: PUSH
32245: LD_EXP 46
32249: PUSH
32250: LD_EXP 44
32254: PUSH
32255: LD_EXP 41
32259: PUSH
32260: LD_EXP 55
32264: PUSH
32265: LD_EXP 47
32269: PUSH
32270: LD_EXP 53
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: IN
32284: PUSH
32285: LD_VAR 0 3
32289: OR
32290: IFFALSE 32389
// begin Say ( Roth , DA-Roth-3 ) ;
32292: LD_EXP 74
32296: PPUSH
32297: LD_STRING DA-Roth-3
32299: PPUSH
32300: CALL_OW 88
// SetSide ( unit , 7 ) ;
32304: LD_VAR 0 1
32308: PPUSH
32309: LD_INT 7
32311: PPUSH
32312: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32316: LD_ADDR_EXP 110
32320: PUSH
32321: LD_EXP 110
32325: PPUSH
32326: LD_INT 1
32328: PPUSH
32329: LD_EXP 110
32333: PUSH
32334: LD_INT 1
32336: ARRAY
32337: PUSH
32338: LD_VAR 0 1
32342: ADD
32343: PPUSH
32344: CALL_OW 1
32348: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32349: LD_INT 260
32351: PPUSH
32352: LD_INT 235
32354: PPUSH
32355: LD_INT 1
32357: PPUSH
32358: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32362: LD_VAR 0 1
32366: PPUSH
32367: LD_INT 1000
32369: PPUSH
32370: CALL_OW 234
// DialogueOff ;
32374: CALL_OW 7
// ComFree ( unit ) ;
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 139
// end else
32387: GO 32470
// begin Say ( Roth , DA-Roth-3a ) ;
32389: LD_EXP 74
32393: PPUSH
32394: LD_STRING DA-Roth-3a
32396: PPUSH
32397: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32401: LD_ADDR_EXP 35
32405: PUSH
32406: LD_EXP 35
32410: PUSH
32411: LD_VAR 0 1
32415: ADD
32416: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32417: LD_INT 260
32419: PPUSH
32420: LD_INT 235
32422: PPUSH
32423: LD_INT 1
32425: PPUSH
32426: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32430: LD_VAR 0 1
32434: PPUSH
32435: LD_INT 1000
32437: PPUSH
32438: CALL_OW 234
// DialogueOff ;
32442: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32446: LD_VAR 0 1
32450: PPUSH
32451: LD_INT 272
32453: PPUSH
32454: LD_INT 254
32456: PPUSH
32457: CALL_OW 111
// AddComHold ( unit ) ;
32461: LD_VAR 0 1
32465: PPUSH
32466: CALL_OW 200
// end ; if capturedUnit = 1 then
32470: LD_EXP 34
32474: PUSH
32475: LD_INT 1
32477: EQUAL
32478: IFFALSE 32533
// begin DialogueOn ;
32480: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32484: LD_EXP 39
32488: PPUSH
32489: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32493: LD_EXP 39
32497: PPUSH
32498: LD_STRING DAa-JMM-1
32500: PPUSH
32501: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32505: LD_EXP 39
32509: PPUSH
32510: LD_STRING DAa-JMM-1a
32512: PPUSH
32513: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32517: LD_EXP 39
32521: PPUSH
32522: LD_STRING DAa-JMM-1b
32524: PPUSH
32525: CALL_OW 88
// DialogueOff ;
32529: CALL_OW 7
// end ; end ;
32533: LD_VAR 0 2
32537: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32538: LD_EXP 15
32542: PUSH
32543: LD_INT 13
32545: GREATEREQUAL
32546: PUSH
32547: LD_INT 22
32549: PUSH
32550: LD_INT 2
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 21
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PPUSH
32571: CALL_OW 69
32575: PUSH
32576: LD_INT 0
32578: EQUAL
32579: AND
32580: PUSH
32581: LD_INT 22
32583: PUSH
32584: LD_INT 2
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 21
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 50
32603: PUSH
32604: EMPTY
32605: LIST
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: LIST
32611: PPUSH
32612: CALL_OW 69
32616: PUSH
32617: LD_INT 0
32619: EQUAL
32620: AND
32621: PUSH
32622: LD_EXP 21
32626: AND
32627: PUSH
32628: LD_EXP 22
32632: AND
32633: PUSH
32634: LD_EXP 23
32638: AND
32639: IFFALSE 33281
32641: GO 32643
32643: DISABLE
32644: LD_INT 0
32646: PPUSH
32647: PPUSH
32648: PPUSH
// begin m1 := false ;
32649: LD_ADDR_VAR 0 1
32653: PUSH
32654: LD_INT 0
32656: ST_TO_ADDR
// m2 := false ;
32657: LD_ADDR_VAR 0 2
32661: PUSH
32662: LD_INT 0
32664: ST_TO_ADDR
// m3 := false ;
32665: LD_ADDR_VAR 0 3
32669: PUSH
32670: LD_INT 0
32672: ST_TO_ADDR
// if not bombExploded then
32673: LD_EXP 37
32677: NOT
32678: IFFALSE 32687
// SetAchievement ( ACH_SIBROCKET ) ;
32680: LD_STRING ACH_SIBROCKET
32682: PPUSH
32683: CALL_OW 543
// if tick <= 120 120$00 then
32687: LD_OWVAR 1
32691: PUSH
32692: LD_INT 252000
32694: LESSEQUAL
32695: IFFALSE 32711
// begin wait ( 3 ) ;
32697: LD_INT 3
32699: PPUSH
32700: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32704: LD_STRING ACH_ASPEED_15
32706: PPUSH
32707: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32711: LD_EXP 39
32715: PPUSH
32716: CALL_OW 87
// music_class := 5 ;
32720: LD_ADDR_OWVAR 72
32724: PUSH
32725: LD_INT 5
32727: ST_TO_ADDR
// music_nat := 5 ;
32728: LD_ADDR_OWVAR 71
32732: PUSH
32733: LD_INT 5
32735: ST_TO_ADDR
// DialogueOn ;
32736: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32740: LD_EXP 39
32744: PPUSH
32745: LD_STRING D20-JMM-1
32747: PPUSH
32748: CALL_OW 88
// if IsOK ( Joan ) then
32752: LD_EXP 40
32756: PPUSH
32757: CALL_OW 302
32761: IFFALSE 32775
// Say ( Joan , D20-Joan-1 ) ;
32763: LD_EXP 40
32767: PPUSH
32768: LD_STRING D20-Joan-1
32770: PPUSH
32771: CALL_OW 88
// if IsOk ( Lisa ) then
32775: LD_EXP 42
32779: PPUSH
32780: CALL_OW 302
32784: IFFALSE 32798
// Say ( Lisa , D20-Lisa-1 ) ;
32786: LD_EXP 42
32790: PPUSH
32791: LD_STRING D20-Lisa-1
32793: PPUSH
32794: CALL_OW 88
// if IsOk ( Donaldson ) then
32798: LD_EXP 43
32802: PPUSH
32803: CALL_OW 302
32807: IFFALSE 32821
// Say ( Donaldson , D20-Don-1 ) ;
32809: LD_EXP 43
32813: PPUSH
32814: LD_STRING D20-Don-1
32816: PPUSH
32817: CALL_OW 88
// if IsOK ( Cornel ) then
32821: LD_EXP 50
32825: PPUSH
32826: CALL_OW 302
32830: IFFALSE 32844
// Say ( Cornel , D20-Corn-1 ) ;
32832: LD_EXP 50
32836: PPUSH
32837: LD_STRING D20-Corn-1
32839: PPUSH
32840: CALL_OW 88
// if IsOk ( Denis ) then
32844: LD_EXP 46
32848: PPUSH
32849: CALL_OW 302
32853: IFFALSE 32867
// Say ( Denis , D20-Den-1 ) ;
32855: LD_EXP 46
32859: PPUSH
32860: LD_STRING D20-Den-1
32862: PPUSH
32863: CALL_OW 88
// if IsOk ( Bobby ) then
32867: LD_EXP 44
32871: PPUSH
32872: CALL_OW 302
32876: IFFALSE 32890
// Say ( Bobby , D20-Bobby-1 ) ;
32878: LD_EXP 44
32882: PPUSH
32883: LD_STRING D20-Bobby-1
32885: PPUSH
32886: CALL_OW 88
// if IsOk ( Gladstone ) then
32890: LD_EXP 48
32894: PPUSH
32895: CALL_OW 302
32899: IFFALSE 32913
// Say ( Gladstone , D20-Glad-1 ) ;
32901: LD_EXP 48
32905: PPUSH
32906: LD_STRING D20-Glad-1
32908: PPUSH
32909: CALL_OW 88
// if IsOk ( Cyrus ) then
32913: LD_EXP 45
32917: PPUSH
32918: CALL_OW 302
32922: IFFALSE 32936
// Say ( Cyrus , D20-Cyrus-1 ) ;
32924: LD_EXP 45
32928: PPUSH
32929: LD_STRING D20-Cyrus-1
32931: PPUSH
32932: CALL_OW 88
// if IsOk ( Stevens ) then
32936: LD_EXP 41
32940: PPUSH
32941: CALL_OW 302
32945: IFFALSE 32959
// Say ( Stevens , D20-Huck-1 ) ;
32947: LD_EXP 41
32951: PPUSH
32952: LD_STRING D20-Huck-1
32954: PPUSH
32955: CALL_OW 88
// if IsOk ( Brown ) then
32959: LD_EXP 47
32963: PPUSH
32964: CALL_OW 302
32968: IFFALSE 32982
// Say ( Brown , D20-Brown-1 ) ;
32970: LD_EXP 47
32974: PPUSH
32975: LD_STRING D20-Brown-1
32977: PPUSH
32978: CALL_OW 88
// if IsOk ( Gary ) then
32982: LD_EXP 51
32986: PPUSH
32987: CALL_OW 302
32991: IFFALSE 33005
// Say ( Gary , D20-Gary-1 ) ;
32993: LD_EXP 51
32997: PPUSH
32998: LD_STRING D20-Gary-1
33000: PPUSH
33001: CALL_OW 88
// if IsOk ( Connie ) then
33005: LD_EXP 54
33009: PPUSH
33010: CALL_OW 302
33014: IFFALSE 33028
// Say ( Connie , D20-Con-1 ) ;
33016: LD_EXP 54
33020: PPUSH
33021: LD_STRING D20-Con-1
33023: PPUSH
33024: CALL_OW 88
// if IsOk ( Kurt ) then
33028: LD_EXP 60
33032: PPUSH
33033: CALL_OW 302
33037: IFFALSE 33051
// Say ( Kurt , D20-Kurt-1 ) ;
33039: LD_EXP 60
33043: PPUSH
33044: LD_STRING D20-Kurt-1
33046: PPUSH
33047: CALL_OW 88
// if IsOk ( Kikuchi ) then
33051: LD_EXP 53
33055: PPUSH
33056: CALL_OW 302
33060: IFFALSE 33074
// Say ( Kikuchi , D20-Yam-1 ) ;
33062: LD_EXP 53
33066: PPUSH
33067: LD_STRING D20-Yam-1
33069: PPUSH
33070: CALL_OW 88
// if IsOk ( Frank ) then
33074: LD_EXP 52
33078: PPUSH
33079: CALL_OW 302
33083: IFFALSE 33097
// Say ( Frank , D20-Frank-1 ) ;
33085: LD_EXP 52
33089: PPUSH
33090: LD_STRING D20-Frank-1
33092: PPUSH
33093: CALL_OW 88
// DialogueOff ;
33097: CALL_OW 7
// if RothCaptured then
33101: LD_EXP 33
33105: IFFALSE 33127
// begin m1 := true ;
33107: LD_ADDR_VAR 0 1
33111: PUSH
33112: LD_INT 1
33114: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33115: LD_STRING Roth
33117: PPUSH
33118: LD_INT 1
33120: PPUSH
33121: CALL_OW 101
// end else
33125: GO 33138
// AddMedal ( Roth , - 1 ) ;
33127: LD_STRING Roth
33129: PPUSH
33130: LD_INT 1
33132: NEG
33133: PPUSH
33134: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33138: LD_EXP 27
33142: IFFALSE 33164
// begin m2 := true ;
33144: LD_ADDR_VAR 0 2
33148: PUSH
33149: LD_INT 1
33151: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33152: LD_STRING Project
33154: PPUSH
33155: LD_INT 1
33157: PPUSH
33158: CALL_OW 101
// end else
33162: GO 33175
// AddMedal ( Project , - 1 ) ;
33164: LD_STRING Project
33166: PPUSH
33167: LD_INT 1
33169: NEG
33170: PPUSH
33171: CALL_OW 101
// if lostCounter = 0 then
33175: LD_EXP 32
33179: PUSH
33180: LD_INT 0
33182: EQUAL
33183: IFFALSE 33205
// begin m3 := true ;
33185: LD_ADDR_VAR 0 3
33189: PUSH
33190: LD_INT 1
33192: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33193: LD_STRING NoLosses
33195: PPUSH
33196: LD_INT 1
33198: PPUSH
33199: CALL_OW 101
// end else
33203: GO 33216
// AddMedal ( NoLosses , - 1 ) ;
33205: LD_STRING NoLosses
33207: PPUSH
33208: LD_INT 1
33210: NEG
33211: PPUSH
33212: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33216: LD_VAR 0 1
33220: PUSH
33221: LD_VAR 0 2
33225: AND
33226: PUSH
33227: LD_VAR 0 3
33231: AND
33232: PUSH
33233: LD_OWVAR 67
33237: PUSH
33238: LD_INT 3
33240: EQUAL
33241: AND
33242: IFFALSE 33254
// SetAchievementEX ( ACH_AMER , 15 ) ;
33244: LD_STRING ACH_AMER
33246: PPUSH
33247: LD_INT 15
33249: PPUSH
33250: CALL_OW 564
// GiveMedals ( MAIN ) ;
33254: LD_STRING MAIN
33256: PPUSH
33257: CALL_OW 102
// music_class := 4 ;
33261: LD_ADDR_OWVAR 72
33265: PUSH
33266: LD_INT 4
33268: ST_TO_ADDR
// music_nat := 1 ;
33269: LD_ADDR_OWVAR 71
33273: PUSH
33274: LD_INT 1
33276: ST_TO_ADDR
// YouWin ;
33277: CALL_OW 103
// end ; end_of_file
33281: PPOPN 3
33283: END
// export function CustomEvent ( event ) ; begin
33284: LD_INT 0
33286: PPUSH
// end ;
33287: LD_VAR 0 2
33291: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33292: LD_VAR 0 1
33296: PUSH
33297: LD_INT 1
33299: EQUAL
33300: PUSH
33301: LD_VAR 0 2
33305: PUSH
33306: LD_INT 4
33308: EQUAL
33309: AND
33310: PUSH
33311: LD_EXP 58
33315: PPUSH
33316: CALL_OW 300
33320: AND
33321: IFFALSE 33337
// begin wait ( 0 0$2 ) ;
33323: LD_INT 70
33325: PPUSH
33326: CALL_OW 67
// YouLost ( Dismissed ) ;
33330: LD_STRING Dismissed
33332: PPUSH
33333: CALL_OW 104
// end ; end ;
33337: PPOPN 2
33339: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33340: LD_VAR 0 2
33344: PPUSH
33345: LD_VAR 0 3
33349: PPUSH
33350: LD_INT 18
33352: PPUSH
33353: CALL_OW 309
33357: IFFALSE 33366
// YouLost ( Motherlode3 ) ;
33359: LD_STRING Motherlode3
33361: PPUSH
33362: CALL_OW 104
// end ;
33366: PPOPN 3
33368: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33369: LD_EXP 27
33373: NOT
33374: IFFALSE 33384
// behemothDone := true ;
33376: LD_ADDR_EXP 28
33380: PUSH
33381: LD_INT 1
33383: ST_TO_ADDR
// end ;
33384: PPOPN 1
33386: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33387: LD_VAR 0 1
33391: PPUSH
33392: CALL_OW 255
33396: PUSH
33397: LD_INT 1
33399: EQUAL
33400: IFFALSE 33410
// bombExploded := true ;
33402: LD_ADDR_EXP 37
33406: PUSH
33407: LD_INT 1
33409: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33410: LD_VAR 0 1
33414: PPUSH
33415: CALL_OW 255
33419: PUSH
33420: LD_INT 1
33422: EQUAL
33423: PUSH
33424: LD_EXP 30
33428: AND
33429: PUSH
33430: LD_INT 22
33432: PUSH
33433: LD_INT 3
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 34
33442: PUSH
33443: LD_INT 48
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PPUSH
33454: CALL_OW 69
33458: AND
33459: PUSH
33460: LD_INT 22
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 34
33472: PUSH
33473: LD_INT 8
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PPUSH
33484: CALL_OW 69
33488: NOT
33489: AND
33490: IFFALSE 33542
// begin wait ( 0 0$5 ) ;
33492: LD_INT 175
33494: PPUSH
33495: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33499: LD_INT 22
33501: PUSH
33502: LD_INT 3
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 34
33511: PUSH
33512: LD_INT 48
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PPUSH
33523: CALL_OW 69
33527: PUSH
33528: LD_INT 1
33530: ARRAY
33531: PPUSH
33532: LD_INT 60
33534: PPUSH
33535: LD_INT 95
33537: PPUSH
33538: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33542: LD_VAR 0 2
33546: PPUSH
33547: LD_VAR 0 3
33551: PPUSH
33552: LD_INT 18
33554: PPUSH
33555: CALL_OW 309
33559: IFFALSE 33619
// begin if GetSide ( unit ) = 1 then
33561: LD_VAR 0 1
33565: PPUSH
33566: CALL_OW 255
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: IFFALSE 33590
// begin wait ( 0 0$6 ) ;
33576: LD_INT 210
33578: PPUSH
33579: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33583: LD_STRING Motherlode2
33585: PPUSH
33586: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33590: LD_VAR 0 1
33594: PPUSH
33595: CALL_OW 255
33599: PUSH
33600: LD_INT 8
33602: EQUAL
33603: IFFALSE 33619
// begin wait ( 0 0$6 ) ;
33605: LD_INT 210
33607: PPUSH
33608: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33612: LD_STRING Motherlode1
33614: PPUSH
33615: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33619: LD_VAR 0 1
33623: PPUSH
33624: CALL_OW 255
33628: PUSH
33629: LD_INT 3
33631: EQUAL
33632: IFFALSE 33653
// begin wait ( 0 0$5 ) ;
33634: LD_INT 175
33636: PPUSH
33637: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33641: LD_EXP 64
33645: PPUSH
33646: LD_STRING D18-Pla-1
33648: PPUSH
33649: CALL_OW 94
// end ; end ;
33653: PPOPN 3
33655: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33656: LD_VAR 0 1
33660: PUSH
33661: LD_EXP 73
33665: IN
33666: IFFALSE 33686
// begin behemothBuilders := behemothBuilders diff un ;
33668: LD_ADDR_EXP 73
33672: PUSH
33673: LD_EXP 73
33677: PUSH
33678: LD_VAR 0 1
33682: DIFF
33683: ST_TO_ADDR
// exit ;
33684: GO 33784
// end ; if un = JMM then
33686: LD_VAR 0 1
33690: PUSH
33691: LD_EXP 39
33695: EQUAL
33696: IFFALSE 33707
// begin YouLost ( JMM ) ;
33698: LD_STRING JMM
33700: PPUSH
33701: CALL_OW 104
// exit ;
33705: GO 33784
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33707: LD_VAR 0 1
33711: PUSH
33712: LD_INT 22
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 3
33724: PUSH
33725: LD_INT 25
33727: PUSH
33728: LD_INT 16
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 25
33737: PUSH
33738: LD_INT 12
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PPUSH
33754: CALL_OW 69
33758: IN
33759: IFFALSE 33775
// lostCounter := lostCounter + 1 ;
33761: LD_ADDR_EXP 32
33765: PUSH
33766: LD_EXP 32
33770: PUSH
33771: LD_INT 1
33773: PLUS
33774: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33775: LD_VAR 0 1
33779: PPUSH
33780: CALL 62028 0 1
// end ;
33784: PPOPN 1
33786: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33787: LD_VAR 0 1
33791: PPUSH
33792: LD_VAR 0 2
33796: PPUSH
33797: CALL 64362 0 2
// end ;
33801: PPOPN 2
33803: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33804: LD_VAR 0 1
33808: PPUSH
33809: CALL 63430 0 1
// end ;
33813: PPOPN 1
33815: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33816: LD_VAR 0 1
33820: PUSH
33821: LD_INT 22
33823: PUSH
33824: LD_INT 8
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 30
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 23
33843: PUSH
33844: LD_INT 3
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: LIST
33855: PPUSH
33856: CALL_OW 69
33860: IN
33861: IFFALSE 33888
// begin ComUpgrade ( building ) ;
33863: LD_VAR 0 1
33867: PPUSH
33868: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33872: LD_EXP 61
33876: PPUSH
33877: LD_VAR 0 1
33881: PPUSH
33882: CALL 75188 0 2
// exit ;
33886: GO 33897
// end ; MCE_BuildingComplete ( building ) ;
33888: LD_VAR 0 1
33892: PPUSH
33893: CALL 63671 0 1
// end ;
33897: PPOPN 1
33899: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33900: LD_VAR 0 1
33904: PPUSH
33905: LD_VAR 0 2
33909: PPUSH
33910: CALL 61724 0 2
// end ;
33914: PPOPN 2
33916: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: LD_VAR 0 2
33926: PPUSH
33927: LD_VAR 0 3
33931: PPUSH
33932: LD_VAR 0 4
33936: PPUSH
33937: LD_VAR 0 5
33941: PPUSH
33942: CALL 61344 0 5
// end ;
33946: PPOPN 5
33948: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33949: LD_VAR 0 1
33953: PPUSH
33954: LD_VAR 0 2
33958: PPUSH
33959: CALL 60940 0 2
// end ;
33963: PPOPN 2
33965: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33966: LD_VAR 0 1
33970: PPUSH
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_VAR 0 3
33980: PPUSH
33981: LD_VAR 0 4
33985: PPUSH
33986: CALL 60778 0 4
// end ;
33990: PPOPN 4
33992: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: LD_VAR 0 3
34007: PPUSH
34008: CALL 60553 0 3
// end ;
34012: PPOPN 3
34014: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34015: LD_VAR 0 1
34019: PPUSH
34020: LD_VAR 0 2
34024: PPUSH
34025: CALL 60438 0 2
// end ;
34029: PPOPN 2
34031: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34032: LD_VAR 0 1
34036: PPUSH
34037: LD_VAR 0 2
34041: PPUSH
34042: CALL 64623 0 2
// end ;
34046: PPOPN 2
34048: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34049: LD_VAR 0 1
34053: PPUSH
34054: CALL_OW 255
34058: PUSH
34059: LD_INT 4
34061: EQUAL
34062: PUSH
34063: LD_VAR 0 1
34067: PUSH
34068: LD_EXP 18
34072: PUSH
34073: LD_INT 1
34075: ARRAY
34076: IN
34077: AND
34078: PUSH
34079: LD_EXP 19
34083: AND
34084: IFFALSE 34103
// begin ComMoveXY ( driver , 61 , 93 ) ;
34086: LD_VAR 0 1
34090: PPUSH
34091: LD_INT 61
34093: PPUSH
34094: LD_INT 93
34096: PPUSH
34097: CALL_OW 111
// exit ;
34101: GO 34127
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL 64839 0 4
// end ;
34127: PPOPN 4
34129: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: CALL 60247 0 2
// end ;
34144: PPOPN 2
34146: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34147: LD_VAR 0 1
34151: PPUSH
34152: CALL 119217 0 1
// end ; end_of_file
34156: PPOPN 1
34158: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34159: LD_EXP 15
34163: PUSH
34164: LD_INT 2
34166: EQUAL
34167: IFFALSE 34646
34169: GO 34171
34171: DISABLE
34172: LD_INT 0
34174: PPUSH
// begin time := 0 0$40 ;
34175: LD_ADDR_VAR 0 1
34179: PUSH
34180: LD_INT 1400
34182: ST_TO_ADDR
// repeat wait ( time ) ;
34183: LD_VAR 0 1
34187: PPUSH
34188: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34192: LD_INT 1
34194: PPUSH
34195: LD_INT 5
34197: PPUSH
34198: CALL_OW 12
34202: PPUSH
34203: LD_INT 106
34205: PPUSH
34206: LD_INT 150
34208: PPUSH
34209: LD_INT 19
34211: PPUSH
34212: LD_INT 1
34214: PPUSH
34215: CALL_OW 56
// time := time + 0 0$9 ;
34219: LD_ADDR_VAR 0 1
34223: PUSH
34224: LD_VAR 0 1
34228: PUSH
34229: LD_INT 315
34231: PLUS
34232: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34233: LD_INT 455
34235: PPUSH
34236: LD_INT 840
34238: PPUSH
34239: CALL_OW 12
34243: PPUSH
34244: CALL_OW 67
// if Prob ( 50 ) then
34248: LD_INT 50
34250: PPUSH
34251: CALL_OW 13
34255: IFFALSE 34284
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34257: LD_INT 1
34259: PPUSH
34260: LD_INT 5
34262: PPUSH
34263: CALL_OW 12
34267: PPUSH
34268: LD_INT 62
34270: PPUSH
34271: LD_INT 108
34273: PPUSH
34274: LD_INT 10
34276: PPUSH
34277: LD_INT 1
34279: PPUSH
34280: CALL_OW 56
// until missionStage > 4 ;
34284: LD_EXP 15
34288: PUSH
34289: LD_INT 4
34291: GREATER
34292: IFFALSE 34183
// repeat wait ( 0 0$1 ) ;
34294: LD_INT 35
34296: PPUSH
34297: CALL_OW 67
// until missionStage = 6 ;
34301: LD_EXP 15
34305: PUSH
34306: LD_INT 6
34308: EQUAL
34309: IFFALSE 34294
// time := 0 0$50 ;
34311: LD_ADDR_VAR 0 1
34315: PUSH
34316: LD_INT 1750
34318: ST_TO_ADDR
// repeat wait ( time ) ;
34319: LD_VAR 0 1
34323: PPUSH
34324: CALL_OW 67
// if Prob ( 50 ) then
34328: LD_INT 50
34330: PPUSH
34331: CALL_OW 13
34335: IFFALSE 34364
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34337: LD_INT 1
34339: PPUSH
34340: LD_INT 5
34342: PPUSH
34343: CALL_OW 12
34347: PPUSH
34348: LD_INT 106
34350: PPUSH
34351: LD_INT 89
34353: PPUSH
34354: LD_INT 45
34356: PPUSH
34357: LD_INT 1
34359: PPUSH
34360: CALL_OW 56
// time := time + 0 0$2 ;
34364: LD_ADDR_VAR 0 1
34368: PUSH
34369: LD_VAR 0 1
34373: PUSH
34374: LD_INT 70
34376: PLUS
34377: ST_TO_ADDR
// if Prob ( 30 ) then
34378: LD_INT 30
34380: PPUSH
34381: CALL_OW 13
34385: IFFALSE 34431
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34387: LD_INT 385
34389: PPUSH
34390: LD_INT 945
34392: PPUSH
34393: CALL_OW 12
34397: PPUSH
34398: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34402: LD_INT 1
34404: PPUSH
34405: LD_INT 5
34407: PPUSH
34408: CALL_OW 12
34412: PPUSH
34413: LD_INT 21
34415: PPUSH
34416: LD_INT 26
34418: PPUSH
34419: LD_INT 12
34421: PPUSH
34422: LD_INT 1
34424: PPUSH
34425: CALL_OW 56
// end else
34429: GO 34467
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34431: LD_INT 700
34433: PPUSH
34434: LD_INT 1225
34436: PPUSH
34437: CALL_OW 12
34441: PPUSH
34442: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34446: LD_INT 1
34448: PPUSH
34449: LD_INT 5
34451: PPUSH
34452: CALL_OW 12
34456: PPUSH
34457: LD_INT 16
34459: PPUSH
34460: LD_INT 1
34462: PPUSH
34463: CALL_OW 55
// end ; if Prob ( 50 ) then
34467: LD_INT 50
34469: PPUSH
34470: CALL_OW 13
34474: IFFALSE 34520
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34476: LD_INT 700
34478: PPUSH
34479: LD_INT 1050
34481: PPUSH
34482: CALL_OW 12
34486: PPUSH
34487: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34491: LD_INT 1
34493: PPUSH
34494: LD_INT 5
34496: PPUSH
34497: CALL_OW 12
34501: PPUSH
34502: LD_INT 181
34504: PPUSH
34505: LD_INT 218
34507: PPUSH
34508: LD_INT 16
34510: PPUSH
34511: LD_INT 1
34513: PPUSH
34514: CALL_OW 56
// end else
34518: GO 34556
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34520: LD_INT 350
34522: PPUSH
34523: LD_INT 525
34525: PPUSH
34526: CALL_OW 12
34530: PPUSH
34531: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34535: LD_INT 1
34537: PPUSH
34538: LD_INT 5
34540: PPUSH
34541: CALL_OW 12
34545: PPUSH
34546: LD_INT 15
34548: PPUSH
34549: LD_INT 1
34551: PPUSH
34552: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34556: LD_INT 45
34558: PUSH
34559: LD_INT 32
34561: PUSH
34562: LD_INT 25
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: LIST
34569: PUSH
34570: LD_OWVAR 67
34574: ARRAY
34575: PPUSH
34576: CALL_OW 13
34580: IFFALSE 34624
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34582: LD_INT 175
34584: PPUSH
34585: LD_INT 315
34587: PPUSH
34588: CALL_OW 12
34592: PPUSH
34593: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34597: LD_INT 1
34599: PPUSH
34600: LD_INT 5
34602: PPUSH
34603: CALL_OW 12
34607: PPUSH
34608: LD_INT 103
34610: PPUSH
34611: LD_INT 140
34613: PPUSH
34614: LD_INT 20
34616: PPUSH
34617: LD_INT 1
34619: PPUSH
34620: CALL_OW 56
// end ; if time > 1 1$20 then
34624: LD_VAR 0 1
34628: PUSH
34629: LD_INT 2800
34631: GREATER
34632: IFFALSE 34642
// time := 0 0$30 ;
34634: LD_ADDR_VAR 0 1
34638: PUSH
34639: LD_INT 1050
34641: ST_TO_ADDR
// until false ;
34642: LD_INT 0
34644: IFFALSE 34319
// end ; end_of_file
34646: PPOPN 1
34648: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34649: LD_EXP 13
34653: PUSH
34654: LD_EXP 15
34658: PUSH
34659: LD_INT 6
34661: GREATEREQUAL
34662: AND
34663: IFFALSE 34700
34665: GO 34667
34667: DISABLE
// begin enable ;
34668: ENABLE
// missionTime := missionTime + 0 0$1 ;
34669: LD_ADDR_EXP 14
34673: PUSH
34674: LD_EXP 14
34678: PUSH
34679: LD_INT 35
34681: PLUS
34682: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34683: LD_ADDR_OWVAR 47
34687: PUSH
34688: LD_STRING #Am15-1
34690: PUSH
34691: LD_EXP 14
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: ST_TO_ADDR
// end ; end_of_file
34700: END
// export function InitNature ; begin
34701: LD_INT 0
34703: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34704: LD_INT 3
34706: PPUSH
34707: LD_INT 3
34709: PPUSH
34710: LD_INT 2
34712: PPUSH
34713: LD_INT 1
34715: PPUSH
34716: LD_INT 1
34718: PPUSH
34719: LD_INT 0
34721: PPUSH
34722: LD_INT 0
34724: PPUSH
34725: LD_INT 20
34727: PPUSH
34728: LD_INT 0
34730: PPUSH
34731: CALL 100006 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34735: LD_INT 2
34737: PPUSH
34738: LD_INT 1
34740: PPUSH
34741: LD_INT 1
34743: PPUSH
34744: LD_INT 1
34746: PPUSH
34747: LD_INT 1
34749: PPUSH
34750: LD_INT 0
34752: PPUSH
34753: LD_INT 0
34755: PPUSH
34756: LD_INT 21
34758: PPUSH
34759: LD_INT 0
34761: PPUSH
34762: CALL 100006 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34766: LD_INT 4
34768: PPUSH
34769: LD_INT 1
34771: PPUSH
34772: LD_INT 2
34774: PPUSH
34775: LD_INT 4
34777: PPUSH
34778: LD_INT 2
34780: PPUSH
34781: LD_INT 1
34783: PPUSH
34784: LD_INT 0
34786: PPUSH
34787: LD_INT 22
34789: PPUSH
34790: LD_INT 0
34792: PPUSH
34793: CALL 100006 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34797: LD_INT 0
34799: PPUSH
34800: LD_INT 0
34802: PPUSH
34803: LD_INT 0
34805: PPUSH
34806: LD_INT 0
34808: PPUSH
34809: LD_INT 0
34811: PPUSH
34812: LD_INT 0
34814: PPUSH
34815: LD_INT 9
34817: PPUSH
34818: LD_INT 0
34820: PPUSH
34821: LD_INT 23
34823: PPUSH
34824: CALL 100006 0 9
// end ; end_of_file
34828: LD_VAR 0 1
34832: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
34833: GO 34835
34835: DISABLE
// begin ru_radar := 98 ;
34836: LD_ADDR_EXP 95
34840: PUSH
34841: LD_INT 98
34843: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34844: LD_ADDR_EXP 96
34848: PUSH
34849: LD_INT 89
34851: ST_TO_ADDR
// us_hack := 99 ;
34852: LD_ADDR_EXP 97
34856: PUSH
34857: LD_INT 99
34859: ST_TO_ADDR
// us_artillery := 97 ;
34860: LD_ADDR_EXP 98
34864: PUSH
34865: LD_INT 97
34867: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34868: LD_ADDR_EXP 99
34872: PUSH
34873: LD_INT 91
34875: ST_TO_ADDR
// tech_Artillery := 80 ;
34876: LD_ADDR_EXP 100
34880: PUSH
34881: LD_INT 80
34883: ST_TO_ADDR
// tech_RadMat := 81 ;
34884: LD_ADDR_EXP 101
34888: PUSH
34889: LD_INT 81
34891: ST_TO_ADDR
// tech_BasicTools := 82 ;
34892: LD_ADDR_EXP 102
34896: PUSH
34897: LD_INT 82
34899: ST_TO_ADDR
// tech_Cargo := 83 ;
34900: LD_ADDR_EXP 103
34904: PUSH
34905: LD_INT 83
34907: ST_TO_ADDR
// tech_Track := 84 ;
34908: LD_ADDR_EXP 104
34912: PUSH
34913: LD_INT 84
34915: ST_TO_ADDR
// tech_Crane := 85 ;
34916: LD_ADDR_EXP 105
34920: PUSH
34921: LD_INT 85
34923: ST_TO_ADDR
// tech_Bulldozer := 86 ;
34924: LD_ADDR_EXP 106
34928: PUSH
34929: LD_INT 86
34931: ST_TO_ADDR
// tech_Hovercraft := 87 ;
34932: LD_ADDR_EXP 107
34936: PUSH
34937: LD_INT 87
34939: ST_TO_ADDR
// end ; end_of_file
34940: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34941: LD_INT 0
34943: PPUSH
34944: PPUSH
// skirmish := false ;
34945: LD_ADDR_EXP 108
34949: PUSH
34950: LD_INT 0
34952: ST_TO_ADDR
// debug_mc := false ;
34953: LD_ADDR_EXP 109
34957: PUSH
34958: LD_INT 0
34960: ST_TO_ADDR
// mc_bases := [ ] ;
34961: LD_ADDR_EXP 110
34965: PUSH
34966: EMPTY
34967: ST_TO_ADDR
// mc_sides := [ ] ;
34968: LD_ADDR_EXP 136
34972: PUSH
34973: EMPTY
34974: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34975: LD_ADDR_EXP 111
34979: PUSH
34980: EMPTY
34981: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34982: LD_ADDR_EXP 112
34986: PUSH
34987: EMPTY
34988: ST_TO_ADDR
// mc_need_heal := [ ] ;
34989: LD_ADDR_EXP 113
34993: PUSH
34994: EMPTY
34995: ST_TO_ADDR
// mc_healers := [ ] ;
34996: LD_ADDR_EXP 114
35000: PUSH
35001: EMPTY
35002: ST_TO_ADDR
// mc_build_list := [ ] ;
35003: LD_ADDR_EXP 115
35007: PUSH
35008: EMPTY
35009: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35010: LD_ADDR_EXP 142
35014: PUSH
35015: EMPTY
35016: ST_TO_ADDR
// mc_builders := [ ] ;
35017: LD_ADDR_EXP 116
35021: PUSH
35022: EMPTY
35023: ST_TO_ADDR
// mc_construct_list := [ ] ;
35024: LD_ADDR_EXP 117
35028: PUSH
35029: EMPTY
35030: ST_TO_ADDR
// mc_turret_list := [ ] ;
35031: LD_ADDR_EXP 118
35035: PUSH
35036: EMPTY
35037: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35038: LD_ADDR_EXP 119
35042: PUSH
35043: EMPTY
35044: ST_TO_ADDR
// mc_miners := [ ] ;
35045: LD_ADDR_EXP 124
35049: PUSH
35050: EMPTY
35051: ST_TO_ADDR
// mc_mines := [ ] ;
35052: LD_ADDR_EXP 123
35056: PUSH
35057: EMPTY
35058: ST_TO_ADDR
// mc_minefields := [ ] ;
35059: LD_ADDR_EXP 125
35063: PUSH
35064: EMPTY
35065: ST_TO_ADDR
// mc_crates := [ ] ;
35066: LD_ADDR_EXP 126
35070: PUSH
35071: EMPTY
35072: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35073: LD_ADDR_EXP 127
35077: PUSH
35078: EMPTY
35079: ST_TO_ADDR
// mc_crates_area := [ ] ;
35080: LD_ADDR_EXP 128
35084: PUSH
35085: EMPTY
35086: ST_TO_ADDR
// mc_vehicles := [ ] ;
35087: LD_ADDR_EXP 129
35091: PUSH
35092: EMPTY
35093: ST_TO_ADDR
// mc_attack := [ ] ;
35094: LD_ADDR_EXP 130
35098: PUSH
35099: EMPTY
35100: ST_TO_ADDR
// mc_produce := [ ] ;
35101: LD_ADDR_EXP 131
35105: PUSH
35106: EMPTY
35107: ST_TO_ADDR
// mc_defender := [ ] ;
35108: LD_ADDR_EXP 132
35112: PUSH
35113: EMPTY
35114: ST_TO_ADDR
// mc_parking := [ ] ;
35115: LD_ADDR_EXP 134
35119: PUSH
35120: EMPTY
35121: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35122: LD_ADDR_EXP 120
35126: PUSH
35127: EMPTY
35128: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35129: LD_ADDR_EXP 122
35133: PUSH
35134: EMPTY
35135: ST_TO_ADDR
// mc_scan := [ ] ;
35136: LD_ADDR_EXP 133
35140: PUSH
35141: EMPTY
35142: ST_TO_ADDR
// mc_scan_area := [ ] ;
35143: LD_ADDR_EXP 135
35147: PUSH
35148: EMPTY
35149: ST_TO_ADDR
// mc_tech := [ ] ;
35150: LD_ADDR_EXP 137
35154: PUSH
35155: EMPTY
35156: ST_TO_ADDR
// mc_class := [ ] ;
35157: LD_ADDR_EXP 151
35161: PUSH
35162: EMPTY
35163: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35164: LD_ADDR_EXP 152
35168: PUSH
35169: EMPTY
35170: ST_TO_ADDR
// end ;
35171: LD_VAR 0 1
35175: RET
// export function MC_Kill ( base ) ; begin
35176: LD_INT 0
35178: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35179: LD_ADDR_EXP 110
35183: PUSH
35184: LD_EXP 110
35188: PPUSH
35189: LD_VAR 0 1
35193: PPUSH
35194: EMPTY
35195: PPUSH
35196: CALL_OW 1
35200: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35201: LD_ADDR_EXP 111
35205: PUSH
35206: LD_EXP 111
35210: PPUSH
35211: LD_VAR 0 1
35215: PPUSH
35216: EMPTY
35217: PPUSH
35218: CALL_OW 1
35222: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35223: LD_ADDR_EXP 112
35227: PUSH
35228: LD_EXP 112
35232: PPUSH
35233: LD_VAR 0 1
35237: PPUSH
35238: EMPTY
35239: PPUSH
35240: CALL_OW 1
35244: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35245: LD_ADDR_EXP 113
35249: PUSH
35250: LD_EXP 113
35254: PPUSH
35255: LD_VAR 0 1
35259: PPUSH
35260: EMPTY
35261: PPUSH
35262: CALL_OW 1
35266: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35267: LD_ADDR_EXP 114
35271: PUSH
35272: LD_EXP 114
35276: PPUSH
35277: LD_VAR 0 1
35281: PPUSH
35282: EMPTY
35283: PPUSH
35284: CALL_OW 1
35288: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35289: LD_ADDR_EXP 115
35293: PUSH
35294: LD_EXP 115
35298: PPUSH
35299: LD_VAR 0 1
35303: PPUSH
35304: EMPTY
35305: PPUSH
35306: CALL_OW 1
35310: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35311: LD_ADDR_EXP 116
35315: PUSH
35316: LD_EXP 116
35320: PPUSH
35321: LD_VAR 0 1
35325: PPUSH
35326: EMPTY
35327: PPUSH
35328: CALL_OW 1
35332: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35333: LD_ADDR_EXP 117
35337: PUSH
35338: LD_EXP 117
35342: PPUSH
35343: LD_VAR 0 1
35347: PPUSH
35348: EMPTY
35349: PPUSH
35350: CALL_OW 1
35354: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35355: LD_ADDR_EXP 118
35359: PUSH
35360: LD_EXP 118
35364: PPUSH
35365: LD_VAR 0 1
35369: PPUSH
35370: EMPTY
35371: PPUSH
35372: CALL_OW 1
35376: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35377: LD_ADDR_EXP 119
35381: PUSH
35382: LD_EXP 119
35386: PPUSH
35387: LD_VAR 0 1
35391: PPUSH
35392: EMPTY
35393: PPUSH
35394: CALL_OW 1
35398: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35399: LD_ADDR_EXP 120
35403: PUSH
35404: LD_EXP 120
35408: PPUSH
35409: LD_VAR 0 1
35413: PPUSH
35414: EMPTY
35415: PPUSH
35416: CALL_OW 1
35420: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35421: LD_ADDR_EXP 121
35425: PUSH
35426: LD_EXP 121
35430: PPUSH
35431: LD_VAR 0 1
35435: PPUSH
35436: LD_INT 0
35438: PPUSH
35439: CALL_OW 1
35443: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35444: LD_ADDR_EXP 122
35448: PUSH
35449: LD_EXP 122
35453: PPUSH
35454: LD_VAR 0 1
35458: PPUSH
35459: EMPTY
35460: PPUSH
35461: CALL_OW 1
35465: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35466: LD_ADDR_EXP 123
35470: PUSH
35471: LD_EXP 123
35475: PPUSH
35476: LD_VAR 0 1
35480: PPUSH
35481: EMPTY
35482: PPUSH
35483: CALL_OW 1
35487: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35488: LD_ADDR_EXP 124
35492: PUSH
35493: LD_EXP 124
35497: PPUSH
35498: LD_VAR 0 1
35502: PPUSH
35503: EMPTY
35504: PPUSH
35505: CALL_OW 1
35509: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35510: LD_ADDR_EXP 125
35514: PUSH
35515: LD_EXP 125
35519: PPUSH
35520: LD_VAR 0 1
35524: PPUSH
35525: EMPTY
35526: PPUSH
35527: CALL_OW 1
35531: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35532: LD_ADDR_EXP 126
35536: PUSH
35537: LD_EXP 126
35541: PPUSH
35542: LD_VAR 0 1
35546: PPUSH
35547: EMPTY
35548: PPUSH
35549: CALL_OW 1
35553: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35554: LD_ADDR_EXP 127
35558: PUSH
35559: LD_EXP 127
35563: PPUSH
35564: LD_VAR 0 1
35568: PPUSH
35569: EMPTY
35570: PPUSH
35571: CALL_OW 1
35575: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35576: LD_ADDR_EXP 128
35580: PUSH
35581: LD_EXP 128
35585: PPUSH
35586: LD_VAR 0 1
35590: PPUSH
35591: EMPTY
35592: PPUSH
35593: CALL_OW 1
35597: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35598: LD_ADDR_EXP 129
35602: PUSH
35603: LD_EXP 129
35607: PPUSH
35608: LD_VAR 0 1
35612: PPUSH
35613: EMPTY
35614: PPUSH
35615: CALL_OW 1
35619: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35620: LD_ADDR_EXP 130
35624: PUSH
35625: LD_EXP 130
35629: PPUSH
35630: LD_VAR 0 1
35634: PPUSH
35635: EMPTY
35636: PPUSH
35637: CALL_OW 1
35641: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35642: LD_ADDR_EXP 131
35646: PUSH
35647: LD_EXP 131
35651: PPUSH
35652: LD_VAR 0 1
35656: PPUSH
35657: EMPTY
35658: PPUSH
35659: CALL_OW 1
35663: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35664: LD_ADDR_EXP 132
35668: PUSH
35669: LD_EXP 132
35673: PPUSH
35674: LD_VAR 0 1
35678: PPUSH
35679: EMPTY
35680: PPUSH
35681: CALL_OW 1
35685: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35686: LD_ADDR_EXP 133
35690: PUSH
35691: LD_EXP 133
35695: PPUSH
35696: LD_VAR 0 1
35700: PPUSH
35701: EMPTY
35702: PPUSH
35703: CALL_OW 1
35707: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35708: LD_ADDR_EXP 134
35712: PUSH
35713: LD_EXP 134
35717: PPUSH
35718: LD_VAR 0 1
35722: PPUSH
35723: EMPTY
35724: PPUSH
35725: CALL_OW 1
35729: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35730: LD_ADDR_EXP 135
35734: PUSH
35735: LD_EXP 135
35739: PPUSH
35740: LD_VAR 0 1
35744: PPUSH
35745: EMPTY
35746: PPUSH
35747: CALL_OW 1
35751: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35752: LD_ADDR_EXP 137
35756: PUSH
35757: LD_EXP 137
35761: PPUSH
35762: LD_VAR 0 1
35766: PPUSH
35767: EMPTY
35768: PPUSH
35769: CALL_OW 1
35773: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35774: LD_ADDR_EXP 139
35778: PUSH
35779: LD_EXP 139
35783: PPUSH
35784: LD_VAR 0 1
35788: PPUSH
35789: EMPTY
35790: PPUSH
35791: CALL_OW 1
35795: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35796: LD_ADDR_EXP 140
35800: PUSH
35801: LD_EXP 140
35805: PPUSH
35806: LD_VAR 0 1
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35818: LD_ADDR_EXP 141
35822: PUSH
35823: LD_EXP 141
35827: PPUSH
35828: LD_VAR 0 1
35832: PPUSH
35833: EMPTY
35834: PPUSH
35835: CALL_OW 1
35839: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35840: LD_ADDR_EXP 142
35844: PUSH
35845: LD_EXP 142
35849: PPUSH
35850: LD_VAR 0 1
35854: PPUSH
35855: EMPTY
35856: PPUSH
35857: CALL_OW 1
35861: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35862: LD_ADDR_EXP 143
35866: PUSH
35867: LD_EXP 143
35871: PPUSH
35872: LD_VAR 0 1
35876: PPUSH
35877: EMPTY
35878: PPUSH
35879: CALL_OW 1
35883: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35884: LD_ADDR_EXP 144
35888: PUSH
35889: LD_EXP 144
35893: PPUSH
35894: LD_VAR 0 1
35898: PPUSH
35899: EMPTY
35900: PPUSH
35901: CALL_OW 1
35905: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35906: LD_ADDR_EXP 145
35910: PUSH
35911: LD_EXP 145
35915: PPUSH
35916: LD_VAR 0 1
35920: PPUSH
35921: EMPTY
35922: PPUSH
35923: CALL_OW 1
35927: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35928: LD_ADDR_EXP 146
35932: PUSH
35933: LD_EXP 146
35937: PPUSH
35938: LD_VAR 0 1
35942: PPUSH
35943: EMPTY
35944: PPUSH
35945: CALL_OW 1
35949: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35950: LD_ADDR_EXP 147
35954: PUSH
35955: LD_EXP 147
35959: PPUSH
35960: LD_VAR 0 1
35964: PPUSH
35965: EMPTY
35966: PPUSH
35967: CALL_OW 1
35971: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35972: LD_ADDR_EXP 148
35976: PUSH
35977: LD_EXP 148
35981: PPUSH
35982: LD_VAR 0 1
35986: PPUSH
35987: EMPTY
35988: PPUSH
35989: CALL_OW 1
35993: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35994: LD_ADDR_EXP 149
35998: PUSH
35999: LD_EXP 149
36003: PPUSH
36004: LD_VAR 0 1
36008: PPUSH
36009: EMPTY
36010: PPUSH
36011: CALL_OW 1
36015: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36016: LD_ADDR_EXP 150
36020: PUSH
36021: LD_EXP 150
36025: PPUSH
36026: LD_VAR 0 1
36030: PPUSH
36031: EMPTY
36032: PPUSH
36033: CALL_OW 1
36037: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36038: LD_ADDR_EXP 151
36042: PUSH
36043: LD_EXP 151
36047: PPUSH
36048: LD_VAR 0 1
36052: PPUSH
36053: EMPTY
36054: PPUSH
36055: CALL_OW 1
36059: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36060: LD_ADDR_EXP 152
36064: PUSH
36065: LD_EXP 152
36069: PPUSH
36070: LD_VAR 0 1
36074: PPUSH
36075: LD_INT 0
36077: PPUSH
36078: CALL_OW 1
36082: ST_TO_ADDR
// end ;
36083: LD_VAR 0 2
36087: RET
// export function MC_Add ( side , units ) ; var base ; begin
36088: LD_INT 0
36090: PPUSH
36091: PPUSH
// base := mc_bases + 1 ;
36092: LD_ADDR_VAR 0 4
36096: PUSH
36097: LD_EXP 110
36101: PUSH
36102: LD_INT 1
36104: PLUS
36105: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36106: LD_ADDR_EXP 136
36110: PUSH
36111: LD_EXP 136
36115: PPUSH
36116: LD_VAR 0 4
36120: PPUSH
36121: LD_VAR 0 1
36125: PPUSH
36126: CALL_OW 1
36130: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36131: LD_ADDR_EXP 110
36135: PUSH
36136: LD_EXP 110
36140: PPUSH
36141: LD_VAR 0 4
36145: PPUSH
36146: LD_VAR 0 2
36150: PPUSH
36151: CALL_OW 1
36155: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36156: LD_ADDR_EXP 111
36160: PUSH
36161: LD_EXP 111
36165: PPUSH
36166: LD_VAR 0 4
36170: PPUSH
36171: EMPTY
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36178: LD_ADDR_EXP 112
36182: PUSH
36183: LD_EXP 112
36187: PPUSH
36188: LD_VAR 0 4
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36200: LD_ADDR_EXP 113
36204: PUSH
36205: LD_EXP 113
36209: PPUSH
36210: LD_VAR 0 4
36214: PPUSH
36215: EMPTY
36216: PPUSH
36217: CALL_OW 1
36221: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36222: LD_ADDR_EXP 114
36226: PUSH
36227: LD_EXP 114
36231: PPUSH
36232: LD_VAR 0 4
36236: PPUSH
36237: EMPTY
36238: PPUSH
36239: CALL_OW 1
36243: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36244: LD_ADDR_EXP 115
36248: PUSH
36249: LD_EXP 115
36253: PPUSH
36254: LD_VAR 0 4
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36266: LD_ADDR_EXP 116
36270: PUSH
36271: LD_EXP 116
36275: PPUSH
36276: LD_VAR 0 4
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL_OW 1
36287: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36288: LD_ADDR_EXP 117
36292: PUSH
36293: LD_EXP 117
36297: PPUSH
36298: LD_VAR 0 4
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36310: LD_ADDR_EXP 118
36314: PUSH
36315: LD_EXP 118
36319: PPUSH
36320: LD_VAR 0 4
36324: PPUSH
36325: EMPTY
36326: PPUSH
36327: CALL_OW 1
36331: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36332: LD_ADDR_EXP 119
36336: PUSH
36337: LD_EXP 119
36341: PPUSH
36342: LD_VAR 0 4
36346: PPUSH
36347: EMPTY
36348: PPUSH
36349: CALL_OW 1
36353: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36354: LD_ADDR_EXP 120
36358: PUSH
36359: LD_EXP 120
36363: PPUSH
36364: LD_VAR 0 4
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36376: LD_ADDR_EXP 121
36380: PUSH
36381: LD_EXP 121
36385: PPUSH
36386: LD_VAR 0 4
36390: PPUSH
36391: LD_INT 0
36393: PPUSH
36394: CALL_OW 1
36398: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36399: LD_ADDR_EXP 122
36403: PUSH
36404: LD_EXP 122
36408: PPUSH
36409: LD_VAR 0 4
36413: PPUSH
36414: EMPTY
36415: PPUSH
36416: CALL_OW 1
36420: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36421: LD_ADDR_EXP 123
36425: PUSH
36426: LD_EXP 123
36430: PPUSH
36431: LD_VAR 0 4
36435: PPUSH
36436: EMPTY
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36443: LD_ADDR_EXP 124
36447: PUSH
36448: LD_EXP 124
36452: PPUSH
36453: LD_VAR 0 4
36457: PPUSH
36458: EMPTY
36459: PPUSH
36460: CALL_OW 1
36464: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36465: LD_ADDR_EXP 125
36469: PUSH
36470: LD_EXP 125
36474: PPUSH
36475: LD_VAR 0 4
36479: PPUSH
36480: EMPTY
36481: PPUSH
36482: CALL_OW 1
36486: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36487: LD_ADDR_EXP 126
36491: PUSH
36492: LD_EXP 126
36496: PPUSH
36497: LD_VAR 0 4
36501: PPUSH
36502: EMPTY
36503: PPUSH
36504: CALL_OW 1
36508: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36509: LD_ADDR_EXP 127
36513: PUSH
36514: LD_EXP 127
36518: PPUSH
36519: LD_VAR 0 4
36523: PPUSH
36524: EMPTY
36525: PPUSH
36526: CALL_OW 1
36530: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36531: LD_ADDR_EXP 128
36535: PUSH
36536: LD_EXP 128
36540: PPUSH
36541: LD_VAR 0 4
36545: PPUSH
36546: EMPTY
36547: PPUSH
36548: CALL_OW 1
36552: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36553: LD_ADDR_EXP 129
36557: PUSH
36558: LD_EXP 129
36562: PPUSH
36563: LD_VAR 0 4
36567: PPUSH
36568: EMPTY
36569: PPUSH
36570: CALL_OW 1
36574: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36575: LD_ADDR_EXP 130
36579: PUSH
36580: LD_EXP 130
36584: PPUSH
36585: LD_VAR 0 4
36589: PPUSH
36590: EMPTY
36591: PPUSH
36592: CALL_OW 1
36596: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36597: LD_ADDR_EXP 131
36601: PUSH
36602: LD_EXP 131
36606: PPUSH
36607: LD_VAR 0 4
36611: PPUSH
36612: EMPTY
36613: PPUSH
36614: CALL_OW 1
36618: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36619: LD_ADDR_EXP 132
36623: PUSH
36624: LD_EXP 132
36628: PPUSH
36629: LD_VAR 0 4
36633: PPUSH
36634: EMPTY
36635: PPUSH
36636: CALL_OW 1
36640: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36641: LD_ADDR_EXP 133
36645: PUSH
36646: LD_EXP 133
36650: PPUSH
36651: LD_VAR 0 4
36655: PPUSH
36656: EMPTY
36657: PPUSH
36658: CALL_OW 1
36662: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36663: LD_ADDR_EXP 134
36667: PUSH
36668: LD_EXP 134
36672: PPUSH
36673: LD_VAR 0 4
36677: PPUSH
36678: EMPTY
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36685: LD_ADDR_EXP 135
36689: PUSH
36690: LD_EXP 135
36694: PPUSH
36695: LD_VAR 0 4
36699: PPUSH
36700: EMPTY
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36707: LD_ADDR_EXP 137
36711: PUSH
36712: LD_EXP 137
36716: PPUSH
36717: LD_VAR 0 4
36721: PPUSH
36722: EMPTY
36723: PPUSH
36724: CALL_OW 1
36728: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36729: LD_ADDR_EXP 139
36733: PUSH
36734: LD_EXP 139
36738: PPUSH
36739: LD_VAR 0 4
36743: PPUSH
36744: EMPTY
36745: PPUSH
36746: CALL_OW 1
36750: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36751: LD_ADDR_EXP 140
36755: PUSH
36756: LD_EXP 140
36760: PPUSH
36761: LD_VAR 0 4
36765: PPUSH
36766: EMPTY
36767: PPUSH
36768: CALL_OW 1
36772: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36773: LD_ADDR_EXP 141
36777: PUSH
36778: LD_EXP 141
36782: PPUSH
36783: LD_VAR 0 4
36787: PPUSH
36788: EMPTY
36789: PPUSH
36790: CALL_OW 1
36794: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36795: LD_ADDR_EXP 142
36799: PUSH
36800: LD_EXP 142
36804: PPUSH
36805: LD_VAR 0 4
36809: PPUSH
36810: EMPTY
36811: PPUSH
36812: CALL_OW 1
36816: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36817: LD_ADDR_EXP 143
36821: PUSH
36822: LD_EXP 143
36826: PPUSH
36827: LD_VAR 0 4
36831: PPUSH
36832: EMPTY
36833: PPUSH
36834: CALL_OW 1
36838: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36839: LD_ADDR_EXP 144
36843: PUSH
36844: LD_EXP 144
36848: PPUSH
36849: LD_VAR 0 4
36853: PPUSH
36854: EMPTY
36855: PPUSH
36856: CALL_OW 1
36860: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36861: LD_ADDR_EXP 145
36865: PUSH
36866: LD_EXP 145
36870: PPUSH
36871: LD_VAR 0 4
36875: PPUSH
36876: EMPTY
36877: PPUSH
36878: CALL_OW 1
36882: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36883: LD_ADDR_EXP 146
36887: PUSH
36888: LD_EXP 146
36892: PPUSH
36893: LD_VAR 0 4
36897: PPUSH
36898: EMPTY
36899: PPUSH
36900: CALL_OW 1
36904: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36905: LD_ADDR_EXP 147
36909: PUSH
36910: LD_EXP 147
36914: PPUSH
36915: LD_VAR 0 4
36919: PPUSH
36920: EMPTY
36921: PPUSH
36922: CALL_OW 1
36926: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36927: LD_ADDR_EXP 148
36931: PUSH
36932: LD_EXP 148
36936: PPUSH
36937: LD_VAR 0 4
36941: PPUSH
36942: EMPTY
36943: PPUSH
36944: CALL_OW 1
36948: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36949: LD_ADDR_EXP 149
36953: PUSH
36954: LD_EXP 149
36958: PPUSH
36959: LD_VAR 0 4
36963: PPUSH
36964: EMPTY
36965: PPUSH
36966: CALL_OW 1
36970: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36971: LD_ADDR_EXP 150
36975: PUSH
36976: LD_EXP 150
36980: PPUSH
36981: LD_VAR 0 4
36985: PPUSH
36986: EMPTY
36987: PPUSH
36988: CALL_OW 1
36992: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36993: LD_ADDR_EXP 151
36997: PUSH
36998: LD_EXP 151
37002: PPUSH
37003: LD_VAR 0 4
37007: PPUSH
37008: EMPTY
37009: PPUSH
37010: CALL_OW 1
37014: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37015: LD_ADDR_EXP 152
37019: PUSH
37020: LD_EXP 152
37024: PPUSH
37025: LD_VAR 0 4
37029: PPUSH
37030: LD_INT 0
37032: PPUSH
37033: CALL_OW 1
37037: ST_TO_ADDR
// result := base ;
37038: LD_ADDR_VAR 0 3
37042: PUSH
37043: LD_VAR 0 4
37047: ST_TO_ADDR
// end ;
37048: LD_VAR 0 3
37052: RET
// export function MC_Start ( ) ; var i ; begin
37053: LD_INT 0
37055: PPUSH
37056: PPUSH
// for i = 1 to mc_bases do
37057: LD_ADDR_VAR 0 2
37061: PUSH
37062: DOUBLE
37063: LD_INT 1
37065: DEC
37066: ST_TO_ADDR
37067: LD_EXP 110
37071: PUSH
37072: FOR_TO
37073: IFFALSE 38150
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37075: LD_ADDR_EXP 110
37079: PUSH
37080: LD_EXP 110
37084: PPUSH
37085: LD_VAR 0 2
37089: PPUSH
37090: LD_EXP 110
37094: PUSH
37095: LD_VAR 0 2
37099: ARRAY
37100: PUSH
37101: LD_INT 0
37103: DIFF
37104: PPUSH
37105: CALL_OW 1
37109: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37110: LD_ADDR_EXP 111
37114: PUSH
37115: LD_EXP 111
37119: PPUSH
37120: LD_VAR 0 2
37124: PPUSH
37125: EMPTY
37126: PPUSH
37127: CALL_OW 1
37131: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37132: LD_ADDR_EXP 112
37136: PUSH
37137: LD_EXP 112
37141: PPUSH
37142: LD_VAR 0 2
37146: PPUSH
37147: EMPTY
37148: PPUSH
37149: CALL_OW 1
37153: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37154: LD_ADDR_EXP 113
37158: PUSH
37159: LD_EXP 113
37163: PPUSH
37164: LD_VAR 0 2
37168: PPUSH
37169: EMPTY
37170: PPUSH
37171: CALL_OW 1
37175: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37176: LD_ADDR_EXP 114
37180: PUSH
37181: LD_EXP 114
37185: PPUSH
37186: LD_VAR 0 2
37190: PPUSH
37191: EMPTY
37192: PUSH
37193: EMPTY
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PPUSH
37199: CALL_OW 1
37203: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37204: LD_ADDR_EXP 115
37208: PUSH
37209: LD_EXP 115
37213: PPUSH
37214: LD_VAR 0 2
37218: PPUSH
37219: EMPTY
37220: PPUSH
37221: CALL_OW 1
37225: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37226: LD_ADDR_EXP 142
37230: PUSH
37231: LD_EXP 142
37235: PPUSH
37236: LD_VAR 0 2
37240: PPUSH
37241: EMPTY
37242: PPUSH
37243: CALL_OW 1
37247: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37248: LD_ADDR_EXP 116
37252: PUSH
37253: LD_EXP 116
37257: PPUSH
37258: LD_VAR 0 2
37262: PPUSH
37263: EMPTY
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37270: LD_ADDR_EXP 117
37274: PUSH
37275: LD_EXP 117
37279: PPUSH
37280: LD_VAR 0 2
37284: PPUSH
37285: EMPTY
37286: PPUSH
37287: CALL_OW 1
37291: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37292: LD_ADDR_EXP 118
37296: PUSH
37297: LD_EXP 118
37301: PPUSH
37302: LD_VAR 0 2
37306: PPUSH
37307: LD_EXP 110
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PPUSH
37318: LD_INT 2
37320: PUSH
37321: LD_INT 30
37323: PUSH
37324: LD_INT 32
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 30
37333: PUSH
37334: LD_INT 33
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: LIST
37345: PPUSH
37346: CALL_OW 72
37350: PPUSH
37351: CALL_OW 1
37355: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37356: LD_ADDR_EXP 119
37360: PUSH
37361: LD_EXP 119
37365: PPUSH
37366: LD_VAR 0 2
37370: PPUSH
37371: LD_EXP 110
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 32
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 31
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 58
37412: PUSH
37413: EMPTY
37414: LIST
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PPUSH
37420: CALL_OW 72
37424: PPUSH
37425: CALL_OW 1
37429: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37430: LD_ADDR_EXP 120
37434: PUSH
37435: LD_EXP 120
37439: PPUSH
37440: LD_VAR 0 2
37444: PPUSH
37445: EMPTY
37446: PPUSH
37447: CALL_OW 1
37451: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37452: LD_ADDR_EXP 124
37456: PUSH
37457: LD_EXP 124
37461: PPUSH
37462: LD_VAR 0 2
37466: PPUSH
37467: EMPTY
37468: PPUSH
37469: CALL_OW 1
37473: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37474: LD_ADDR_EXP 123
37478: PUSH
37479: LD_EXP 123
37483: PPUSH
37484: LD_VAR 0 2
37488: PPUSH
37489: EMPTY
37490: PPUSH
37491: CALL_OW 1
37495: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37496: LD_ADDR_EXP 125
37500: PUSH
37501: LD_EXP 125
37505: PPUSH
37506: LD_VAR 0 2
37510: PPUSH
37511: EMPTY
37512: PPUSH
37513: CALL_OW 1
37517: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37518: LD_ADDR_EXP 126
37522: PUSH
37523: LD_EXP 126
37527: PPUSH
37528: LD_VAR 0 2
37532: PPUSH
37533: EMPTY
37534: PPUSH
37535: CALL_OW 1
37539: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37540: LD_ADDR_EXP 127
37544: PUSH
37545: LD_EXP 127
37549: PPUSH
37550: LD_VAR 0 2
37554: PPUSH
37555: EMPTY
37556: PPUSH
37557: CALL_OW 1
37561: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37562: LD_ADDR_EXP 128
37566: PUSH
37567: LD_EXP 128
37571: PPUSH
37572: LD_VAR 0 2
37576: PPUSH
37577: EMPTY
37578: PPUSH
37579: CALL_OW 1
37583: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37584: LD_ADDR_EXP 129
37588: PUSH
37589: LD_EXP 129
37593: PPUSH
37594: LD_VAR 0 2
37598: PPUSH
37599: EMPTY
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37606: LD_ADDR_EXP 130
37610: PUSH
37611: LD_EXP 130
37615: PPUSH
37616: LD_VAR 0 2
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37628: LD_ADDR_EXP 131
37632: PUSH
37633: LD_EXP 131
37637: PPUSH
37638: LD_VAR 0 2
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37650: LD_ADDR_EXP 132
37654: PUSH
37655: LD_EXP 132
37659: PPUSH
37660: LD_VAR 0 2
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37672: LD_ADDR_EXP 121
37676: PUSH
37677: LD_EXP 121
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: LD_INT 0
37689: PPUSH
37690: CALL_OW 1
37694: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37695: LD_ADDR_EXP 134
37699: PUSH
37700: LD_EXP 134
37704: PPUSH
37705: LD_VAR 0 2
37709: PPUSH
37710: LD_INT 0
37712: PPUSH
37713: CALL_OW 1
37717: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37718: LD_ADDR_EXP 122
37722: PUSH
37723: LD_EXP 122
37727: PPUSH
37728: LD_VAR 0 2
37732: PPUSH
37733: EMPTY
37734: PPUSH
37735: CALL_OW 1
37739: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37740: LD_ADDR_EXP 133
37744: PUSH
37745: LD_EXP 133
37749: PPUSH
37750: LD_VAR 0 2
37754: PPUSH
37755: LD_INT 0
37757: PPUSH
37758: CALL_OW 1
37762: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37763: LD_ADDR_EXP 135
37767: PUSH
37768: LD_EXP 135
37772: PPUSH
37773: LD_VAR 0 2
37777: PPUSH
37778: EMPTY
37779: PPUSH
37780: CALL_OW 1
37784: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37785: LD_ADDR_EXP 138
37789: PUSH
37790: LD_EXP 138
37794: PPUSH
37795: LD_VAR 0 2
37799: PPUSH
37800: LD_INT 0
37802: PPUSH
37803: CALL_OW 1
37807: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37808: LD_ADDR_EXP 139
37812: PUSH
37813: LD_EXP 139
37817: PPUSH
37818: LD_VAR 0 2
37822: PPUSH
37823: EMPTY
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37830: LD_ADDR_EXP 140
37834: PUSH
37835: LD_EXP 140
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37852: LD_ADDR_EXP 141
37856: PUSH
37857: LD_EXP 141
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: EMPTY
37868: PPUSH
37869: CALL_OW 1
37873: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37874: LD_ADDR_EXP 143
37878: PUSH
37879: LD_EXP 143
37883: PPUSH
37884: LD_VAR 0 2
37888: PPUSH
37889: LD_EXP 110
37893: PUSH
37894: LD_VAR 0 2
37898: ARRAY
37899: PPUSH
37900: LD_INT 2
37902: PUSH
37903: LD_INT 30
37905: PUSH
37906: LD_INT 6
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 30
37915: PUSH
37916: LD_INT 7
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 30
37925: PUSH
37926: LD_INT 8
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: PPUSH
37939: CALL_OW 72
37943: PPUSH
37944: CALL_OW 1
37948: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37949: LD_ADDR_EXP 144
37953: PUSH
37954: LD_EXP 144
37958: PPUSH
37959: LD_VAR 0 2
37963: PPUSH
37964: EMPTY
37965: PPUSH
37966: CALL_OW 1
37970: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37971: LD_ADDR_EXP 145
37975: PUSH
37976: LD_EXP 145
37980: PPUSH
37981: LD_VAR 0 2
37985: PPUSH
37986: EMPTY
37987: PPUSH
37988: CALL_OW 1
37992: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37993: LD_ADDR_EXP 146
37997: PUSH
37998: LD_EXP 146
38002: PPUSH
38003: LD_VAR 0 2
38007: PPUSH
38008: EMPTY
38009: PPUSH
38010: CALL_OW 1
38014: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38015: LD_ADDR_EXP 147
38019: PUSH
38020: LD_EXP 147
38024: PPUSH
38025: LD_VAR 0 2
38029: PPUSH
38030: EMPTY
38031: PPUSH
38032: CALL_OW 1
38036: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38037: LD_ADDR_EXP 148
38041: PUSH
38042: LD_EXP 148
38046: PPUSH
38047: LD_VAR 0 2
38051: PPUSH
38052: EMPTY
38053: PPUSH
38054: CALL_OW 1
38058: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38059: LD_ADDR_EXP 149
38063: PUSH
38064: LD_EXP 149
38068: PPUSH
38069: LD_VAR 0 2
38073: PPUSH
38074: EMPTY
38075: PPUSH
38076: CALL_OW 1
38080: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38081: LD_ADDR_EXP 150
38085: PUSH
38086: LD_EXP 150
38090: PPUSH
38091: LD_VAR 0 2
38095: PPUSH
38096: EMPTY
38097: PPUSH
38098: CALL_OW 1
38102: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38103: LD_ADDR_EXP 151
38107: PUSH
38108: LD_EXP 151
38112: PPUSH
38113: LD_VAR 0 2
38117: PPUSH
38118: EMPTY
38119: PPUSH
38120: CALL_OW 1
38124: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38125: LD_ADDR_EXP 152
38129: PUSH
38130: LD_EXP 152
38134: PPUSH
38135: LD_VAR 0 2
38139: PPUSH
38140: LD_INT 0
38142: PPUSH
38143: CALL_OW 1
38147: ST_TO_ADDR
// end ;
38148: GO 37072
38150: POP
38151: POP
// MC_InitSides ( ) ;
38152: CALL 38438 0 0
// MC_InitResearch ( ) ;
38156: CALL 38177 0 0
// CustomInitMacro ( ) ;
38160: CALL 467 0 0
// skirmish := true ;
38164: LD_ADDR_EXP 108
38168: PUSH
38169: LD_INT 1
38171: ST_TO_ADDR
// end ;
38172: LD_VAR 0 1
38176: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38177: LD_INT 0
38179: PPUSH
38180: PPUSH
38181: PPUSH
38182: PPUSH
38183: PPUSH
38184: PPUSH
// if not mc_bases then
38185: LD_EXP 110
38189: NOT
38190: IFFALSE 38194
// exit ;
38192: GO 38433
// for i = 1 to 8 do
38194: LD_ADDR_VAR 0 2
38198: PUSH
38199: DOUBLE
38200: LD_INT 1
38202: DEC
38203: ST_TO_ADDR
38204: LD_INT 8
38206: PUSH
38207: FOR_TO
38208: IFFALSE 38234
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38210: LD_ADDR_EXP 137
38214: PUSH
38215: LD_EXP 137
38219: PPUSH
38220: LD_VAR 0 2
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
38232: GO 38207
38234: POP
38235: POP
// tmp := [ ] ;
38236: LD_ADDR_VAR 0 5
38240: PUSH
38241: EMPTY
38242: ST_TO_ADDR
// for i = 1 to mc_sides do
38243: LD_ADDR_VAR 0 2
38247: PUSH
38248: DOUBLE
38249: LD_INT 1
38251: DEC
38252: ST_TO_ADDR
38253: LD_EXP 136
38257: PUSH
38258: FOR_TO
38259: IFFALSE 38317
// if not mc_sides [ i ] in tmp then
38261: LD_EXP 136
38265: PUSH
38266: LD_VAR 0 2
38270: ARRAY
38271: PUSH
38272: LD_VAR 0 5
38276: IN
38277: NOT
38278: IFFALSE 38315
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38280: LD_ADDR_VAR 0 5
38284: PUSH
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_VAR 0 5
38294: PUSH
38295: LD_INT 1
38297: PLUS
38298: PPUSH
38299: LD_EXP 136
38303: PUSH
38304: LD_VAR 0 2
38308: ARRAY
38309: PPUSH
38310: CALL_OW 2
38314: ST_TO_ADDR
38315: GO 38258
38317: POP
38318: POP
// if not tmp then
38319: LD_VAR 0 5
38323: NOT
38324: IFFALSE 38328
// exit ;
38326: GO 38433
// for j in tmp do
38328: LD_ADDR_VAR 0 3
38332: PUSH
38333: LD_VAR 0 5
38337: PUSH
38338: FOR_IN
38339: IFFALSE 38431
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38341: LD_ADDR_VAR 0 6
38345: PUSH
38346: LD_INT 22
38348: PUSH
38349: LD_VAR 0 3
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PPUSH
38358: CALL_OW 69
38362: ST_TO_ADDR
// if not un then
38363: LD_VAR 0 6
38367: NOT
38368: IFFALSE 38372
// continue ;
38370: GO 38338
// nation := GetNation ( un [ 1 ] ) ;
38372: LD_ADDR_VAR 0 4
38376: PUSH
38377: LD_VAR 0 6
38381: PUSH
38382: LD_INT 1
38384: ARRAY
38385: PPUSH
38386: CALL_OW 248
38390: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38391: LD_ADDR_EXP 137
38395: PUSH
38396: LD_EXP 137
38400: PPUSH
38401: LD_VAR 0 3
38405: PPUSH
38406: LD_VAR 0 3
38410: PPUSH
38411: LD_VAR 0 4
38415: PPUSH
38416: LD_INT 1
38418: PPUSH
38419: CALL 65043 0 3
38423: PPUSH
38424: CALL_OW 1
38428: ST_TO_ADDR
// end ;
38429: GO 38338
38431: POP
38432: POP
// end ;
38433: LD_VAR 0 1
38437: RET
// export function MC_InitSides ( ) ; var i ; begin
38438: LD_INT 0
38440: PPUSH
38441: PPUSH
// if not mc_bases then
38442: LD_EXP 110
38446: NOT
38447: IFFALSE 38451
// exit ;
38449: GO 38525
// for i = 1 to mc_bases do
38451: LD_ADDR_VAR 0 2
38455: PUSH
38456: DOUBLE
38457: LD_INT 1
38459: DEC
38460: ST_TO_ADDR
38461: LD_EXP 110
38465: PUSH
38466: FOR_TO
38467: IFFALSE 38523
// if mc_bases [ i ] then
38469: LD_EXP 110
38473: PUSH
38474: LD_VAR 0 2
38478: ARRAY
38479: IFFALSE 38521
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38481: LD_ADDR_EXP 136
38485: PUSH
38486: LD_EXP 136
38490: PPUSH
38491: LD_VAR 0 2
38495: PPUSH
38496: LD_EXP 110
38500: PUSH
38501: LD_VAR 0 2
38505: ARRAY
38506: PUSH
38507: LD_INT 1
38509: ARRAY
38510: PPUSH
38511: CALL_OW 255
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
38521: GO 38466
38523: POP
38524: POP
// end ;
38525: LD_VAR 0 1
38529: RET
// every 0 0$01 trigger skirmish do
38530: LD_EXP 108
38534: IFFALSE 38688
38536: GO 38538
38538: DISABLE
// begin enable ;
38539: ENABLE
// MC_CheckBuildings ( ) ;
38540: CALL 43186 0 0
// MC_CheckPeopleLife ( ) ;
38544: CALL 43311 0 0
// RaiseSailEvent ( 100 ) ;
38548: LD_INT 100
38550: PPUSH
38551: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38555: LD_INT 103
38557: PPUSH
38558: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38562: LD_INT 104
38564: PPUSH
38565: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38569: LD_INT 105
38571: PPUSH
38572: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38576: LD_INT 106
38578: PPUSH
38579: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38583: LD_INT 107
38585: PPUSH
38586: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38590: LD_INT 108
38592: PPUSH
38593: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38597: LD_INT 109
38599: PPUSH
38600: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38604: LD_INT 110
38606: PPUSH
38607: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38611: LD_INT 111
38613: PPUSH
38614: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38618: LD_INT 112
38620: PPUSH
38621: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38625: LD_INT 113
38627: PPUSH
38628: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38632: LD_INT 120
38634: PPUSH
38635: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38639: LD_INT 121
38641: PPUSH
38642: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38646: LD_INT 122
38648: PPUSH
38649: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38653: LD_INT 123
38655: PPUSH
38656: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38660: LD_INT 124
38662: PPUSH
38663: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38667: LD_INT 125
38669: PPUSH
38670: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38674: LD_INT 126
38676: PPUSH
38677: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38681: LD_INT 200
38683: PPUSH
38684: CALL_OW 427
// end ;
38688: END
// on SailEvent ( event ) do begin if event < 100 then
38689: LD_VAR 0 1
38693: PUSH
38694: LD_INT 100
38696: LESS
38697: IFFALSE 38708
// CustomEvent ( event ) ;
38699: LD_VAR 0 1
38703: PPUSH
38704: CALL 33284 0 1
// if event = 100 then
38708: LD_VAR 0 1
38712: PUSH
38713: LD_INT 100
38715: EQUAL
38716: IFFALSE 38722
// MC_ClassManager ( ) ;
38718: CALL 39114 0 0
// if event = 101 then
38722: LD_VAR 0 1
38726: PUSH
38727: LD_INT 101
38729: EQUAL
38730: IFFALSE 38736
// MC_RepairBuildings ( ) ;
38732: CALL 43907 0 0
// if event = 102 then
38736: LD_VAR 0 1
38740: PUSH
38741: LD_INT 102
38743: EQUAL
38744: IFFALSE 38750
// MC_Heal ( ) ;
38746: CALL 44771 0 0
// if event = 103 then
38750: LD_VAR 0 1
38754: PUSH
38755: LD_INT 103
38757: EQUAL
38758: IFFALSE 38764
// MC_Build ( ) ;
38760: CALL 45193 0 0
// if event = 104 then
38764: LD_VAR 0 1
38768: PUSH
38769: LD_INT 104
38771: EQUAL
38772: IFFALSE 38778
// MC_TurretWeapon ( ) ;
38774: CALL 46806 0 0
// if event = 105 then
38778: LD_VAR 0 1
38782: PUSH
38783: LD_INT 105
38785: EQUAL
38786: IFFALSE 38792
// MC_BuildUpgrade ( ) ;
38788: CALL 46357 0 0
// if event = 106 then
38792: LD_VAR 0 1
38796: PUSH
38797: LD_INT 106
38799: EQUAL
38800: IFFALSE 38806
// MC_PlantMines ( ) ;
38802: CALL 47236 0 0
// if event = 107 then
38806: LD_VAR 0 1
38810: PUSH
38811: LD_INT 107
38813: EQUAL
38814: IFFALSE 38820
// MC_CollectCrates ( ) ;
38816: CALL 48034 0 0
// if event = 108 then
38820: LD_VAR 0 1
38824: PUSH
38825: LD_INT 108
38827: EQUAL
38828: IFFALSE 38834
// MC_LinkRemoteControl ( ) ;
38830: CALL 49810 0 0
// if event = 109 then
38834: LD_VAR 0 1
38838: PUSH
38839: LD_INT 109
38841: EQUAL
38842: IFFALSE 38848
// MC_ProduceVehicle ( ) ;
38844: CALL 49991 0 0
// if event = 110 then
38848: LD_VAR 0 1
38852: PUSH
38853: LD_INT 110
38855: EQUAL
38856: IFFALSE 38862
// MC_SendAttack ( ) ;
38858: CALL 50457 0 0
// if event = 111 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 111
38869: EQUAL
38870: IFFALSE 38876
// MC_Defend ( ) ;
38872: CALL 50565 0 0
// if event = 112 then
38876: LD_VAR 0 1
38880: PUSH
38881: LD_INT 112
38883: EQUAL
38884: IFFALSE 38890
// MC_Research ( ) ;
38886: CALL 51170 0 0
// if event = 113 then
38890: LD_VAR 0 1
38894: PUSH
38895: LD_INT 113
38897: EQUAL
38898: IFFALSE 38904
// MC_MinesTrigger ( ) ;
38900: CALL 52284 0 0
// if event = 120 then
38904: LD_VAR 0 1
38908: PUSH
38909: LD_INT 120
38911: EQUAL
38912: IFFALSE 38918
// MC_RepairVehicle ( ) ;
38914: CALL 52383 0 0
// if event = 121 then
38918: LD_VAR 0 1
38922: PUSH
38923: LD_INT 121
38925: EQUAL
38926: IFFALSE 38932
// MC_TameApe ( ) ;
38928: CALL 53113 0 0
// if event = 122 then
38932: LD_VAR 0 1
38936: PUSH
38937: LD_INT 122
38939: EQUAL
38940: IFFALSE 38946
// MC_ChangeApeClass ( ) ;
38942: CALL 53942 0 0
// if event = 123 then
38946: LD_VAR 0 1
38950: PUSH
38951: LD_INT 123
38953: EQUAL
38954: IFFALSE 38960
// MC_Bazooka ( ) ;
38956: CALL 54592 0 0
// if event = 124 then
38960: LD_VAR 0 1
38964: PUSH
38965: LD_INT 124
38967: EQUAL
38968: IFFALSE 38974
// MC_TeleportExit ( ) ;
38970: CALL 54790 0 0
// if event = 125 then
38974: LD_VAR 0 1
38978: PUSH
38979: LD_INT 125
38981: EQUAL
38982: IFFALSE 38988
// MC_Deposits ( ) ;
38984: CALL 55437 0 0
// if event = 126 then
38988: LD_VAR 0 1
38992: PUSH
38993: LD_INT 126
38995: EQUAL
38996: IFFALSE 39002
// MC_RemoteDriver ( ) ;
38998: CALL 56062 0 0
// if event = 200 then
39002: LD_VAR 0 1
39006: PUSH
39007: LD_INT 200
39009: EQUAL
39010: IFFALSE 39016
// MC_Idle ( ) ;
39012: CALL 58011 0 0
// end ;
39016: PPOPN 1
39018: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39019: LD_INT 0
39021: PPUSH
39022: PPUSH
// if not mc_bases [ base ] or not tag then
39023: LD_EXP 110
39027: PUSH
39028: LD_VAR 0 1
39032: ARRAY
39033: NOT
39034: PUSH
39035: LD_VAR 0 2
39039: NOT
39040: OR
39041: IFFALSE 39045
// exit ;
39043: GO 39109
// for i in mc_bases [ base ] union mc_ape [ base ] do
39045: LD_ADDR_VAR 0 4
39049: PUSH
39050: LD_EXP 110
39054: PUSH
39055: LD_VAR 0 1
39059: ARRAY
39060: PUSH
39061: LD_EXP 139
39065: PUSH
39066: LD_VAR 0 1
39070: ARRAY
39071: UNION
39072: PUSH
39073: FOR_IN
39074: IFFALSE 39107
// if GetTag ( i ) = tag then
39076: LD_VAR 0 4
39080: PPUSH
39081: CALL_OW 110
39085: PUSH
39086: LD_VAR 0 2
39090: EQUAL
39091: IFFALSE 39105
// SetTag ( i , 0 ) ;
39093: LD_VAR 0 4
39097: PPUSH
39098: LD_INT 0
39100: PPUSH
39101: CALL_OW 109
39105: GO 39073
39107: POP
39108: POP
// end ;
39109: LD_VAR 0 3
39113: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39114: LD_INT 0
39116: PPUSH
39117: PPUSH
39118: PPUSH
39119: PPUSH
39120: PPUSH
39121: PPUSH
39122: PPUSH
39123: PPUSH
// if not mc_bases then
39124: LD_EXP 110
39128: NOT
39129: IFFALSE 39133
// exit ;
39131: GO 39591
// for i = 1 to mc_bases do
39133: LD_ADDR_VAR 0 2
39137: PUSH
39138: DOUBLE
39139: LD_INT 1
39141: DEC
39142: ST_TO_ADDR
39143: LD_EXP 110
39147: PUSH
39148: FOR_TO
39149: IFFALSE 39589
// begin tmp := MC_ClassCheckReq ( i ) ;
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_VAR 0 2
39160: PPUSH
39161: CALL 39596 0 1
39165: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39166: LD_ADDR_EXP 151
39170: PUSH
39171: LD_EXP 151
39175: PPUSH
39176: LD_VAR 0 2
39180: PPUSH
39181: LD_VAR 0 4
39185: PPUSH
39186: CALL_OW 1
39190: ST_TO_ADDR
// if not tmp then
39191: LD_VAR 0 4
39195: NOT
39196: IFFALSE 39200
// continue ;
39198: GO 39148
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39200: LD_ADDR_VAR 0 6
39204: PUSH
39205: LD_EXP 110
39209: PUSH
39210: LD_VAR 0 2
39214: ARRAY
39215: PPUSH
39216: LD_INT 2
39218: PUSH
39219: LD_INT 30
39221: PUSH
39222: LD_INT 4
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 30
39231: PUSH
39232: LD_INT 5
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: LIST
39243: PPUSH
39244: CALL_OW 72
39248: PUSH
39249: LD_EXP 110
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: PPUSH
39260: LD_INT 2
39262: PUSH
39263: LD_INT 30
39265: PUSH
39266: LD_INT 0
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: PUSH
39273: LD_INT 30
39275: PUSH
39276: LD_INT 1
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: LIST
39287: PPUSH
39288: CALL_OW 72
39292: PUSH
39293: LD_EXP 110
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PPUSH
39304: LD_INT 30
39306: PUSH
39307: LD_INT 3
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PPUSH
39314: CALL_OW 72
39318: PUSH
39319: LD_EXP 110
39323: PUSH
39324: LD_VAR 0 2
39328: ARRAY
39329: PPUSH
39330: LD_INT 2
39332: PUSH
39333: LD_INT 30
39335: PUSH
39336: LD_INT 6
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 30
39345: PUSH
39346: LD_INT 7
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 30
39355: PUSH
39356: LD_INT 8
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: LIST
39367: LIST
39368: PPUSH
39369: CALL_OW 72
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: LIST
39378: LIST
39379: ST_TO_ADDR
// for j = 1 to 4 do
39380: LD_ADDR_VAR 0 3
39384: PUSH
39385: DOUBLE
39386: LD_INT 1
39388: DEC
39389: ST_TO_ADDR
39390: LD_INT 4
39392: PUSH
39393: FOR_TO
39394: IFFALSE 39585
// begin if not tmp [ j ] then
39396: LD_VAR 0 4
39400: PUSH
39401: LD_VAR 0 3
39405: ARRAY
39406: NOT
39407: IFFALSE 39411
// continue ;
39409: GO 39393
// for p in tmp [ j ] do
39411: LD_ADDR_VAR 0 5
39415: PUSH
39416: LD_VAR 0 4
39420: PUSH
39421: LD_VAR 0 3
39425: ARRAY
39426: PUSH
39427: FOR_IN
39428: IFFALSE 39581
// begin if not b [ j ] then
39430: LD_VAR 0 6
39434: PUSH
39435: LD_VAR 0 3
39439: ARRAY
39440: NOT
39441: IFFALSE 39445
// break ;
39443: GO 39581
// e := 0 ;
39445: LD_ADDR_VAR 0 7
39449: PUSH
39450: LD_INT 0
39452: ST_TO_ADDR
// for k in b [ j ] do
39453: LD_ADDR_VAR 0 8
39457: PUSH
39458: LD_VAR 0 6
39462: PUSH
39463: LD_VAR 0 3
39467: ARRAY
39468: PUSH
39469: FOR_IN
39470: IFFALSE 39497
// if IsNotFull ( k ) then
39472: LD_VAR 0 8
39476: PPUSH
39477: CALL 69603 0 1
39481: IFFALSE 39495
// begin e := k ;
39483: LD_ADDR_VAR 0 7
39487: PUSH
39488: LD_VAR 0 8
39492: ST_TO_ADDR
// break ;
39493: GO 39497
// end ;
39495: GO 39469
39497: POP
39498: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39499: LD_VAR 0 7
39503: PUSH
39504: LD_VAR 0 5
39508: PPUSH
39509: LD_VAR 0 7
39513: PPUSH
39514: CALL 106732 0 2
39518: NOT
39519: AND
39520: IFFALSE 39579
// begin if IsInUnit ( p ) then
39522: LD_VAR 0 5
39526: PPUSH
39527: CALL_OW 310
39531: IFFALSE 39542
// ComExitBuilding ( p ) ;
39533: LD_VAR 0 5
39537: PPUSH
39538: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39542: LD_VAR 0 5
39546: PPUSH
39547: LD_VAR 0 7
39551: PPUSH
39552: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39556: LD_VAR 0 5
39560: PPUSH
39561: LD_VAR 0 3
39565: PPUSH
39566: CALL_OW 183
// AddComExitBuilding ( p ) ;
39570: LD_VAR 0 5
39574: PPUSH
39575: CALL_OW 182
// end ; end ;
39579: GO 39427
39581: POP
39582: POP
// end ;
39583: GO 39393
39585: POP
39586: POP
// end ;
39587: GO 39148
39589: POP
39590: POP
// end ;
39591: LD_VAR 0 1
39595: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39596: LD_INT 0
39598: PPUSH
39599: PPUSH
39600: PPUSH
39601: PPUSH
39602: PPUSH
39603: PPUSH
39604: PPUSH
39605: PPUSH
39606: PPUSH
39607: PPUSH
39608: PPUSH
39609: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39610: LD_VAR 0 1
39614: NOT
39615: PUSH
39616: LD_EXP 110
39620: PUSH
39621: LD_VAR 0 1
39625: ARRAY
39626: NOT
39627: OR
39628: PUSH
39629: LD_EXP 110
39633: PUSH
39634: LD_VAR 0 1
39638: ARRAY
39639: PPUSH
39640: LD_INT 2
39642: PUSH
39643: LD_INT 30
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 30
39655: PUSH
39656: LD_INT 1
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: LIST
39667: PPUSH
39668: CALL_OW 72
39672: NOT
39673: OR
39674: IFFALSE 39678
// exit ;
39676: GO 43181
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39678: LD_ADDR_VAR 0 4
39682: PUSH
39683: LD_EXP 110
39687: PUSH
39688: LD_VAR 0 1
39692: ARRAY
39693: PPUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 25
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 25
39709: PUSH
39710: LD_INT 2
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 25
39719: PUSH
39720: LD_INT 3
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 25
39729: PUSH
39730: LD_INT 4
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 25
39739: PUSH
39740: LD_INT 5
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 25
39749: PUSH
39750: LD_INT 8
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 25
39759: PUSH
39760: LD_INT 9
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: PPUSH
39777: CALL_OW 72
39781: ST_TO_ADDR
// if not tmp then
39782: LD_VAR 0 4
39786: NOT
39787: IFFALSE 39791
// exit ;
39789: GO 43181
// for i in tmp do
39791: LD_ADDR_VAR 0 3
39795: PUSH
39796: LD_VAR 0 4
39800: PUSH
39801: FOR_IN
39802: IFFALSE 39833
// if GetTag ( i ) then
39804: LD_VAR 0 3
39808: PPUSH
39809: CALL_OW 110
39813: IFFALSE 39831
// tmp := tmp diff i ;
39815: LD_ADDR_VAR 0 4
39819: PUSH
39820: LD_VAR 0 4
39824: PUSH
39825: LD_VAR 0 3
39829: DIFF
39830: ST_TO_ADDR
39831: GO 39801
39833: POP
39834: POP
// if not tmp then
39835: LD_VAR 0 4
39839: NOT
39840: IFFALSE 39844
// exit ;
39842: GO 43181
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39844: LD_ADDR_VAR 0 5
39848: PUSH
39849: LD_EXP 110
39853: PUSH
39854: LD_VAR 0 1
39858: ARRAY
39859: PPUSH
39860: LD_INT 2
39862: PUSH
39863: LD_INT 25
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 25
39875: PUSH
39876: LD_INT 5
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 25
39885: PUSH
39886: LD_INT 8
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 25
39895: PUSH
39896: LD_INT 9
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: PPUSH
39910: CALL_OW 72
39914: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39915: LD_ADDR_VAR 0 6
39919: PUSH
39920: LD_EXP 110
39924: PUSH
39925: LD_VAR 0 1
39929: ARRAY
39930: PPUSH
39931: LD_INT 25
39933: PUSH
39934: LD_INT 2
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PPUSH
39941: CALL_OW 72
39945: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39946: LD_ADDR_VAR 0 7
39950: PUSH
39951: LD_EXP 110
39955: PUSH
39956: LD_VAR 0 1
39960: ARRAY
39961: PPUSH
39962: LD_INT 25
39964: PUSH
39965: LD_INT 3
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PPUSH
39972: CALL_OW 72
39976: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39977: LD_ADDR_VAR 0 8
39981: PUSH
39982: LD_EXP 110
39986: PUSH
39987: LD_VAR 0 1
39991: ARRAY
39992: PPUSH
39993: LD_INT 25
39995: PUSH
39996: LD_INT 4
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 24
40005: PUSH
40006: LD_INT 251
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PPUSH
40017: CALL_OW 72
40021: ST_TO_ADDR
// if mc_scan [ base ] then
40022: LD_EXP 133
40026: PUSH
40027: LD_VAR 0 1
40031: ARRAY
40032: IFFALSE 40493
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40034: LD_ADDR_EXP 152
40038: PUSH
40039: LD_EXP 152
40043: PPUSH
40044: LD_VAR 0 1
40048: PPUSH
40049: LD_INT 4
40051: PPUSH
40052: CALL_OW 1
40056: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40057: LD_ADDR_VAR 0 12
40061: PUSH
40062: LD_EXP 110
40066: PUSH
40067: LD_VAR 0 1
40071: ARRAY
40072: PPUSH
40073: LD_INT 2
40075: PUSH
40076: LD_INT 30
40078: PUSH
40079: LD_INT 4
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 30
40088: PUSH
40089: LD_INT 5
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: LIST
40100: PPUSH
40101: CALL_OW 72
40105: ST_TO_ADDR
// if not b then
40106: LD_VAR 0 12
40110: NOT
40111: IFFALSE 40115
// exit ;
40113: GO 43181
// p := [ ] ;
40115: LD_ADDR_VAR 0 11
40119: PUSH
40120: EMPTY
40121: ST_TO_ADDR
// if sci >= 2 then
40122: LD_VAR 0 8
40126: PUSH
40127: LD_INT 2
40129: GREATEREQUAL
40130: IFFALSE 40161
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40132: LD_ADDR_VAR 0 8
40136: PUSH
40137: LD_VAR 0 8
40141: PUSH
40142: LD_INT 1
40144: ARRAY
40145: PUSH
40146: LD_VAR 0 8
40150: PUSH
40151: LD_INT 2
40153: ARRAY
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: ST_TO_ADDR
40159: GO 40222
// if sci = 1 then
40161: LD_VAR 0 8
40165: PUSH
40166: LD_INT 1
40168: EQUAL
40169: IFFALSE 40190
// sci := [ sci [ 1 ] ] else
40171: LD_ADDR_VAR 0 8
40175: PUSH
40176: LD_VAR 0 8
40180: PUSH
40181: LD_INT 1
40183: ARRAY
40184: PUSH
40185: EMPTY
40186: LIST
40187: ST_TO_ADDR
40188: GO 40222
// if sci = 0 then
40190: LD_VAR 0 8
40194: PUSH
40195: LD_INT 0
40197: EQUAL
40198: IFFALSE 40222
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40200: LD_ADDR_VAR 0 11
40204: PUSH
40205: LD_VAR 0 4
40209: PPUSH
40210: LD_INT 4
40212: PPUSH
40213: CALL 106595 0 2
40217: PUSH
40218: LD_INT 1
40220: ARRAY
40221: ST_TO_ADDR
// if eng > 4 then
40222: LD_VAR 0 6
40226: PUSH
40227: LD_INT 4
40229: GREATER
40230: IFFALSE 40276
// for i = eng downto 4 do
40232: LD_ADDR_VAR 0 3
40236: PUSH
40237: DOUBLE
40238: LD_VAR 0 6
40242: INC
40243: ST_TO_ADDR
40244: LD_INT 4
40246: PUSH
40247: FOR_DOWNTO
40248: IFFALSE 40274
// eng := eng diff eng [ i ] ;
40250: LD_ADDR_VAR 0 6
40254: PUSH
40255: LD_VAR 0 6
40259: PUSH
40260: LD_VAR 0 6
40264: PUSH
40265: LD_VAR 0 3
40269: ARRAY
40270: DIFF
40271: ST_TO_ADDR
40272: GO 40247
40274: POP
40275: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40276: LD_ADDR_VAR 0 4
40280: PUSH
40281: LD_VAR 0 4
40285: PUSH
40286: LD_VAR 0 5
40290: PUSH
40291: LD_VAR 0 6
40295: UNION
40296: PUSH
40297: LD_VAR 0 7
40301: UNION
40302: PUSH
40303: LD_VAR 0 8
40307: UNION
40308: DIFF
40309: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40310: LD_ADDR_VAR 0 13
40314: PUSH
40315: LD_EXP 110
40319: PUSH
40320: LD_VAR 0 1
40324: ARRAY
40325: PPUSH
40326: LD_INT 2
40328: PUSH
40329: LD_INT 30
40331: PUSH
40332: LD_INT 32
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 30
40341: PUSH
40342: LD_INT 31
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: LIST
40353: PPUSH
40354: CALL_OW 72
40358: PUSH
40359: LD_EXP 110
40363: PUSH
40364: LD_VAR 0 1
40368: ARRAY
40369: PPUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 30
40375: PUSH
40376: LD_INT 4
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 30
40385: PUSH
40386: LD_INT 5
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: LIST
40397: PPUSH
40398: CALL_OW 72
40402: PUSH
40403: LD_INT 6
40405: MUL
40406: PLUS
40407: ST_TO_ADDR
// if bcount < tmp then
40408: LD_VAR 0 13
40412: PUSH
40413: LD_VAR 0 4
40417: LESS
40418: IFFALSE 40464
// for i = tmp downto bcount do
40420: LD_ADDR_VAR 0 3
40424: PUSH
40425: DOUBLE
40426: LD_VAR 0 4
40430: INC
40431: ST_TO_ADDR
40432: LD_VAR 0 13
40436: PUSH
40437: FOR_DOWNTO
40438: IFFALSE 40462
// tmp := Delete ( tmp , tmp ) ;
40440: LD_ADDR_VAR 0 4
40444: PUSH
40445: LD_VAR 0 4
40449: PPUSH
40450: LD_VAR 0 4
40454: PPUSH
40455: CALL_OW 3
40459: ST_TO_ADDR
40460: GO 40437
40462: POP
40463: POP
// result := [ tmp , 0 , 0 , p ] ;
40464: LD_ADDR_VAR 0 2
40468: PUSH
40469: LD_VAR 0 4
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_VAR 0 11
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: ST_TO_ADDR
// exit ;
40491: GO 43181
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40493: LD_EXP 110
40497: PUSH
40498: LD_VAR 0 1
40502: ARRAY
40503: PPUSH
40504: LD_INT 2
40506: PUSH
40507: LD_INT 30
40509: PUSH
40510: LD_INT 6
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 30
40519: PUSH
40520: LD_INT 7
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 30
40529: PUSH
40530: LD_INT 8
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: PPUSH
40543: CALL_OW 72
40547: NOT
40548: PUSH
40549: LD_EXP 110
40553: PUSH
40554: LD_VAR 0 1
40558: ARRAY
40559: PPUSH
40560: LD_INT 30
40562: PUSH
40563: LD_INT 3
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PPUSH
40570: CALL_OW 72
40574: NOT
40575: AND
40576: IFFALSE 40648
// begin if eng = tmp then
40578: LD_VAR 0 6
40582: PUSH
40583: LD_VAR 0 4
40587: EQUAL
40588: IFFALSE 40592
// exit ;
40590: GO 43181
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40592: LD_ADDR_EXP 152
40596: PUSH
40597: LD_EXP 152
40601: PPUSH
40602: LD_VAR 0 1
40606: PPUSH
40607: LD_INT 1
40609: PPUSH
40610: CALL_OW 1
40614: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40615: LD_ADDR_VAR 0 2
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: LD_VAR 0 4
40627: PUSH
40628: LD_VAR 0 6
40632: DIFF
40633: PUSH
40634: LD_INT 0
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: ST_TO_ADDR
// exit ;
40646: GO 43181
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40648: LD_EXP 137
40652: PUSH
40653: LD_EXP 136
40657: PUSH
40658: LD_VAR 0 1
40662: ARRAY
40663: ARRAY
40664: PUSH
40665: LD_EXP 110
40669: PUSH
40670: LD_VAR 0 1
40674: ARRAY
40675: PPUSH
40676: LD_INT 2
40678: PUSH
40679: LD_INT 30
40681: PUSH
40682: LD_INT 6
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 30
40691: PUSH
40692: LD_INT 7
40694: PUSH
40695: EMPTY
40696: LIST
40697: LIST
40698: PUSH
40699: LD_INT 30
40701: PUSH
40702: LD_INT 8
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: PPUSH
40715: CALL_OW 72
40719: AND
40720: PUSH
40721: LD_EXP 110
40725: PUSH
40726: LD_VAR 0 1
40730: ARRAY
40731: PPUSH
40732: LD_INT 30
40734: PUSH
40735: LD_INT 3
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PPUSH
40742: CALL_OW 72
40746: NOT
40747: AND
40748: IFFALSE 40962
// begin if sci >= 6 then
40750: LD_VAR 0 8
40754: PUSH
40755: LD_INT 6
40757: GREATEREQUAL
40758: IFFALSE 40762
// exit ;
40760: GO 43181
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40762: LD_ADDR_EXP 152
40766: PUSH
40767: LD_EXP 152
40771: PPUSH
40772: LD_VAR 0 1
40776: PPUSH
40777: LD_INT 2
40779: PPUSH
40780: CALL_OW 1
40784: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40785: LD_ADDR_VAR 0 9
40789: PUSH
40790: LD_VAR 0 4
40794: PUSH
40795: LD_VAR 0 8
40799: DIFF
40800: PPUSH
40801: LD_INT 4
40803: PPUSH
40804: CALL 106595 0 2
40808: ST_TO_ADDR
// p := [ ] ;
40809: LD_ADDR_VAR 0 11
40813: PUSH
40814: EMPTY
40815: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40816: LD_VAR 0 8
40820: PUSH
40821: LD_INT 6
40823: LESS
40824: PUSH
40825: LD_VAR 0 9
40829: PUSH
40830: LD_INT 6
40832: GREATER
40833: AND
40834: IFFALSE 40915
// begin for i = 1 to 6 - sci do
40836: LD_ADDR_VAR 0 3
40840: PUSH
40841: DOUBLE
40842: LD_INT 1
40844: DEC
40845: ST_TO_ADDR
40846: LD_INT 6
40848: PUSH
40849: LD_VAR 0 8
40853: MINUS
40854: PUSH
40855: FOR_TO
40856: IFFALSE 40911
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40858: LD_ADDR_VAR 0 11
40862: PUSH
40863: LD_VAR 0 11
40867: PPUSH
40868: LD_VAR 0 11
40872: PUSH
40873: LD_INT 1
40875: PLUS
40876: PPUSH
40877: LD_VAR 0 9
40881: PUSH
40882: LD_INT 1
40884: ARRAY
40885: PPUSH
40886: CALL_OW 2
40890: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40891: LD_ADDR_VAR 0 9
40895: PUSH
40896: LD_VAR 0 9
40900: PPUSH
40901: LD_INT 1
40903: PPUSH
40904: CALL_OW 3
40908: ST_TO_ADDR
// end ;
40909: GO 40855
40911: POP
40912: POP
// end else
40913: GO 40935
// if sort then
40915: LD_VAR 0 9
40919: IFFALSE 40935
// p := sort [ 1 ] ;
40921: LD_ADDR_VAR 0 11
40925: PUSH
40926: LD_VAR 0 9
40930: PUSH
40931: LD_INT 1
40933: ARRAY
40934: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40935: LD_ADDR_VAR 0 2
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: LD_INT 0
40948: PUSH
40949: LD_VAR 0 11
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: ST_TO_ADDR
// exit ;
40960: GO 43181
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40962: LD_EXP 137
40966: PUSH
40967: LD_EXP 136
40971: PUSH
40972: LD_VAR 0 1
40976: ARRAY
40977: ARRAY
40978: PUSH
40979: LD_EXP 110
40983: PUSH
40984: LD_VAR 0 1
40988: ARRAY
40989: PPUSH
40990: LD_INT 2
40992: PUSH
40993: LD_INT 30
40995: PUSH
40996: LD_INT 6
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 30
41005: PUSH
41006: LD_INT 7
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PUSH
41013: LD_INT 30
41015: PUSH
41016: LD_INT 8
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: PPUSH
41029: CALL_OW 72
41033: AND
41034: PUSH
41035: LD_EXP 110
41039: PUSH
41040: LD_VAR 0 1
41044: ARRAY
41045: PPUSH
41046: LD_INT 30
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PPUSH
41056: CALL_OW 72
41060: AND
41061: IFFALSE 41795
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41063: LD_ADDR_EXP 152
41067: PUSH
41068: LD_EXP 152
41072: PPUSH
41073: LD_VAR 0 1
41077: PPUSH
41078: LD_INT 3
41080: PPUSH
41081: CALL_OW 1
41085: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41086: LD_ADDR_VAR 0 2
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: LD_INT 0
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: ST_TO_ADDR
// if not eng then
41109: LD_VAR 0 6
41113: NOT
41114: IFFALSE 41177
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41116: LD_ADDR_VAR 0 11
41120: PUSH
41121: LD_VAR 0 4
41125: PPUSH
41126: LD_INT 2
41128: PPUSH
41129: CALL 106595 0 2
41133: PUSH
41134: LD_INT 1
41136: ARRAY
41137: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41138: LD_ADDR_VAR 0 2
41142: PUSH
41143: LD_VAR 0 2
41147: PPUSH
41148: LD_INT 2
41150: PPUSH
41151: LD_VAR 0 11
41155: PPUSH
41156: CALL_OW 1
41160: ST_TO_ADDR
// tmp := tmp diff p ;
41161: LD_ADDR_VAR 0 4
41165: PUSH
41166: LD_VAR 0 4
41170: PUSH
41171: LD_VAR 0 11
41175: DIFF
41176: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41177: LD_VAR 0 4
41181: PUSH
41182: LD_VAR 0 8
41186: PUSH
41187: LD_INT 6
41189: LESS
41190: AND
41191: IFFALSE 41379
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41193: LD_ADDR_VAR 0 9
41197: PUSH
41198: LD_VAR 0 4
41202: PUSH
41203: LD_VAR 0 8
41207: PUSH
41208: LD_VAR 0 7
41212: UNION
41213: DIFF
41214: PPUSH
41215: LD_INT 4
41217: PPUSH
41218: CALL 106595 0 2
41222: ST_TO_ADDR
// p := [ ] ;
41223: LD_ADDR_VAR 0 11
41227: PUSH
41228: EMPTY
41229: ST_TO_ADDR
// if sort then
41230: LD_VAR 0 9
41234: IFFALSE 41350
// for i = 1 to 6 - sci do
41236: LD_ADDR_VAR 0 3
41240: PUSH
41241: DOUBLE
41242: LD_INT 1
41244: DEC
41245: ST_TO_ADDR
41246: LD_INT 6
41248: PUSH
41249: LD_VAR 0 8
41253: MINUS
41254: PUSH
41255: FOR_TO
41256: IFFALSE 41348
// begin if i = sort then
41258: LD_VAR 0 3
41262: PUSH
41263: LD_VAR 0 9
41267: EQUAL
41268: IFFALSE 41272
// break ;
41270: GO 41348
// if GetClass ( i ) = 4 then
41272: LD_VAR 0 3
41276: PPUSH
41277: CALL_OW 257
41281: PUSH
41282: LD_INT 4
41284: EQUAL
41285: IFFALSE 41289
// continue ;
41287: GO 41255
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41289: LD_ADDR_VAR 0 11
41293: PUSH
41294: LD_VAR 0 11
41298: PPUSH
41299: LD_VAR 0 11
41303: PUSH
41304: LD_INT 1
41306: PLUS
41307: PPUSH
41308: LD_VAR 0 9
41312: PUSH
41313: LD_VAR 0 3
41317: ARRAY
41318: PPUSH
41319: CALL_OW 2
41323: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41324: LD_ADDR_VAR 0 4
41328: PUSH
41329: LD_VAR 0 4
41333: PUSH
41334: LD_VAR 0 9
41338: PUSH
41339: LD_VAR 0 3
41343: ARRAY
41344: DIFF
41345: ST_TO_ADDR
// end ;
41346: GO 41255
41348: POP
41349: POP
// if p then
41350: LD_VAR 0 11
41354: IFFALSE 41379
// result := Replace ( result , 4 , p ) ;
41356: LD_ADDR_VAR 0 2
41360: PUSH
41361: LD_VAR 0 2
41365: PPUSH
41366: LD_INT 4
41368: PPUSH
41369: LD_VAR 0 11
41373: PPUSH
41374: CALL_OW 1
41378: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41379: LD_VAR 0 4
41383: PUSH
41384: LD_VAR 0 7
41388: PUSH
41389: LD_INT 6
41391: LESS
41392: AND
41393: IFFALSE 41581
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41395: LD_ADDR_VAR 0 9
41399: PUSH
41400: LD_VAR 0 4
41404: PUSH
41405: LD_VAR 0 8
41409: PUSH
41410: LD_VAR 0 7
41414: UNION
41415: DIFF
41416: PPUSH
41417: LD_INT 3
41419: PPUSH
41420: CALL 106595 0 2
41424: ST_TO_ADDR
// p := [ ] ;
41425: LD_ADDR_VAR 0 11
41429: PUSH
41430: EMPTY
41431: ST_TO_ADDR
// if sort then
41432: LD_VAR 0 9
41436: IFFALSE 41552
// for i = 1 to 6 - mech do
41438: LD_ADDR_VAR 0 3
41442: PUSH
41443: DOUBLE
41444: LD_INT 1
41446: DEC
41447: ST_TO_ADDR
41448: LD_INT 6
41450: PUSH
41451: LD_VAR 0 7
41455: MINUS
41456: PUSH
41457: FOR_TO
41458: IFFALSE 41550
// begin if i = sort then
41460: LD_VAR 0 3
41464: PUSH
41465: LD_VAR 0 9
41469: EQUAL
41470: IFFALSE 41474
// break ;
41472: GO 41550
// if GetClass ( i ) = 3 then
41474: LD_VAR 0 3
41478: PPUSH
41479: CALL_OW 257
41483: PUSH
41484: LD_INT 3
41486: EQUAL
41487: IFFALSE 41491
// continue ;
41489: GO 41457
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41491: LD_ADDR_VAR 0 11
41495: PUSH
41496: LD_VAR 0 11
41500: PPUSH
41501: LD_VAR 0 11
41505: PUSH
41506: LD_INT 1
41508: PLUS
41509: PPUSH
41510: LD_VAR 0 9
41514: PUSH
41515: LD_VAR 0 3
41519: ARRAY
41520: PPUSH
41521: CALL_OW 2
41525: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41526: LD_ADDR_VAR 0 4
41530: PUSH
41531: LD_VAR 0 4
41535: PUSH
41536: LD_VAR 0 9
41540: PUSH
41541: LD_VAR 0 3
41545: ARRAY
41546: DIFF
41547: ST_TO_ADDR
// end ;
41548: GO 41457
41550: POP
41551: POP
// if p then
41552: LD_VAR 0 11
41556: IFFALSE 41581
// result := Replace ( result , 3 , p ) ;
41558: LD_ADDR_VAR 0 2
41562: PUSH
41563: LD_VAR 0 2
41567: PPUSH
41568: LD_INT 3
41570: PPUSH
41571: LD_VAR 0 11
41575: PPUSH
41576: CALL_OW 1
41580: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41581: LD_VAR 0 4
41585: PUSH
41586: LD_INT 6
41588: GREATER
41589: PUSH
41590: LD_VAR 0 6
41594: PUSH
41595: LD_INT 6
41597: LESS
41598: AND
41599: IFFALSE 41793
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41601: LD_ADDR_VAR 0 9
41605: PUSH
41606: LD_VAR 0 4
41610: PUSH
41611: LD_VAR 0 8
41615: PUSH
41616: LD_VAR 0 7
41620: UNION
41621: PUSH
41622: LD_VAR 0 6
41626: UNION
41627: DIFF
41628: PPUSH
41629: LD_INT 2
41631: PPUSH
41632: CALL 106595 0 2
41636: ST_TO_ADDR
// p := [ ] ;
41637: LD_ADDR_VAR 0 11
41641: PUSH
41642: EMPTY
41643: ST_TO_ADDR
// if sort then
41644: LD_VAR 0 9
41648: IFFALSE 41764
// for i = 1 to 6 - eng do
41650: LD_ADDR_VAR 0 3
41654: PUSH
41655: DOUBLE
41656: LD_INT 1
41658: DEC
41659: ST_TO_ADDR
41660: LD_INT 6
41662: PUSH
41663: LD_VAR 0 6
41667: MINUS
41668: PUSH
41669: FOR_TO
41670: IFFALSE 41762
// begin if i = sort then
41672: LD_VAR 0 3
41676: PUSH
41677: LD_VAR 0 9
41681: EQUAL
41682: IFFALSE 41686
// break ;
41684: GO 41762
// if GetClass ( i ) = 2 then
41686: LD_VAR 0 3
41690: PPUSH
41691: CALL_OW 257
41695: PUSH
41696: LD_INT 2
41698: EQUAL
41699: IFFALSE 41703
// continue ;
41701: GO 41669
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41703: LD_ADDR_VAR 0 11
41707: PUSH
41708: LD_VAR 0 11
41712: PPUSH
41713: LD_VAR 0 11
41717: PUSH
41718: LD_INT 1
41720: PLUS
41721: PPUSH
41722: LD_VAR 0 9
41726: PUSH
41727: LD_VAR 0 3
41731: ARRAY
41732: PPUSH
41733: CALL_OW 2
41737: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41738: LD_ADDR_VAR 0 4
41742: PUSH
41743: LD_VAR 0 4
41747: PUSH
41748: LD_VAR 0 9
41752: PUSH
41753: LD_VAR 0 3
41757: ARRAY
41758: DIFF
41759: ST_TO_ADDR
// end ;
41760: GO 41669
41762: POP
41763: POP
// if p then
41764: LD_VAR 0 11
41768: IFFALSE 41793
// result := Replace ( result , 2 , p ) ;
41770: LD_ADDR_VAR 0 2
41774: PUSH
41775: LD_VAR 0 2
41779: PPUSH
41780: LD_INT 2
41782: PPUSH
41783: LD_VAR 0 11
41787: PPUSH
41788: CALL_OW 1
41792: ST_TO_ADDR
// end ; exit ;
41793: GO 43181
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41795: LD_EXP 137
41799: PUSH
41800: LD_EXP 136
41804: PUSH
41805: LD_VAR 0 1
41809: ARRAY
41810: ARRAY
41811: NOT
41812: PUSH
41813: LD_EXP 110
41817: PUSH
41818: LD_VAR 0 1
41822: ARRAY
41823: PPUSH
41824: LD_INT 30
41826: PUSH
41827: LD_INT 3
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PPUSH
41834: CALL_OW 72
41838: AND
41839: PUSH
41840: LD_EXP 115
41844: PUSH
41845: LD_VAR 0 1
41849: ARRAY
41850: AND
41851: IFFALSE 42459
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41853: LD_ADDR_EXP 152
41857: PUSH
41858: LD_EXP 152
41862: PPUSH
41863: LD_VAR 0 1
41867: PPUSH
41868: LD_INT 5
41870: PPUSH
41871: CALL_OW 1
41875: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41876: LD_ADDR_VAR 0 2
41880: PUSH
41881: LD_INT 0
41883: PUSH
41884: LD_INT 0
41886: PUSH
41887: LD_INT 0
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: ST_TO_ADDR
// if sci > 1 then
41899: LD_VAR 0 8
41903: PUSH
41904: LD_INT 1
41906: GREATER
41907: IFFALSE 41935
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41909: LD_ADDR_VAR 0 4
41913: PUSH
41914: LD_VAR 0 4
41918: PUSH
41919: LD_VAR 0 8
41923: PUSH
41924: LD_VAR 0 8
41928: PUSH
41929: LD_INT 1
41931: ARRAY
41932: DIFF
41933: DIFF
41934: ST_TO_ADDR
// if tmp and not sci then
41935: LD_VAR 0 4
41939: PUSH
41940: LD_VAR 0 8
41944: NOT
41945: AND
41946: IFFALSE 42015
// begin sort := SortBySkill ( tmp , 4 ) ;
41948: LD_ADDR_VAR 0 9
41952: PUSH
41953: LD_VAR 0 4
41957: PPUSH
41958: LD_INT 4
41960: PPUSH
41961: CALL 106595 0 2
41965: ST_TO_ADDR
// if sort then
41966: LD_VAR 0 9
41970: IFFALSE 41986
// p := sort [ 1 ] ;
41972: LD_ADDR_VAR 0 11
41976: PUSH
41977: LD_VAR 0 9
41981: PUSH
41982: LD_INT 1
41984: ARRAY
41985: ST_TO_ADDR
// if p then
41986: LD_VAR 0 11
41990: IFFALSE 42015
// result := Replace ( result , 4 , p ) ;
41992: LD_ADDR_VAR 0 2
41996: PUSH
41997: LD_VAR 0 2
42001: PPUSH
42002: LD_INT 4
42004: PPUSH
42005: LD_VAR 0 11
42009: PPUSH
42010: CALL_OW 1
42014: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42015: LD_ADDR_VAR 0 4
42019: PUSH
42020: LD_VAR 0 4
42024: PUSH
42025: LD_VAR 0 7
42029: DIFF
42030: ST_TO_ADDR
// if tmp and mech < 6 then
42031: LD_VAR 0 4
42035: PUSH
42036: LD_VAR 0 7
42040: PUSH
42041: LD_INT 6
42043: LESS
42044: AND
42045: IFFALSE 42233
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42047: LD_ADDR_VAR 0 9
42051: PUSH
42052: LD_VAR 0 4
42056: PUSH
42057: LD_VAR 0 8
42061: PUSH
42062: LD_VAR 0 7
42066: UNION
42067: DIFF
42068: PPUSH
42069: LD_INT 3
42071: PPUSH
42072: CALL 106595 0 2
42076: ST_TO_ADDR
// p := [ ] ;
42077: LD_ADDR_VAR 0 11
42081: PUSH
42082: EMPTY
42083: ST_TO_ADDR
// if sort then
42084: LD_VAR 0 9
42088: IFFALSE 42204
// for i = 1 to 6 - mech do
42090: LD_ADDR_VAR 0 3
42094: PUSH
42095: DOUBLE
42096: LD_INT 1
42098: DEC
42099: ST_TO_ADDR
42100: LD_INT 6
42102: PUSH
42103: LD_VAR 0 7
42107: MINUS
42108: PUSH
42109: FOR_TO
42110: IFFALSE 42202
// begin if i = sort then
42112: LD_VAR 0 3
42116: PUSH
42117: LD_VAR 0 9
42121: EQUAL
42122: IFFALSE 42126
// break ;
42124: GO 42202
// if GetClass ( i ) = 3 then
42126: LD_VAR 0 3
42130: PPUSH
42131: CALL_OW 257
42135: PUSH
42136: LD_INT 3
42138: EQUAL
42139: IFFALSE 42143
// continue ;
42141: GO 42109
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42143: LD_ADDR_VAR 0 11
42147: PUSH
42148: LD_VAR 0 11
42152: PPUSH
42153: LD_VAR 0 11
42157: PUSH
42158: LD_INT 1
42160: PLUS
42161: PPUSH
42162: LD_VAR 0 9
42166: PUSH
42167: LD_VAR 0 3
42171: ARRAY
42172: PPUSH
42173: CALL_OW 2
42177: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42178: LD_ADDR_VAR 0 4
42182: PUSH
42183: LD_VAR 0 4
42187: PUSH
42188: LD_VAR 0 9
42192: PUSH
42193: LD_VAR 0 3
42197: ARRAY
42198: DIFF
42199: ST_TO_ADDR
// end ;
42200: GO 42109
42202: POP
42203: POP
// if p then
42204: LD_VAR 0 11
42208: IFFALSE 42233
// result := Replace ( result , 3 , p ) ;
42210: LD_ADDR_VAR 0 2
42214: PUSH
42215: LD_VAR 0 2
42219: PPUSH
42220: LD_INT 3
42222: PPUSH
42223: LD_VAR 0 11
42227: PPUSH
42228: CALL_OW 1
42232: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42233: LD_ADDR_VAR 0 4
42237: PUSH
42238: LD_VAR 0 4
42242: PUSH
42243: LD_VAR 0 6
42247: DIFF
42248: ST_TO_ADDR
// if tmp and eng < 6 then
42249: LD_VAR 0 4
42253: PUSH
42254: LD_VAR 0 6
42258: PUSH
42259: LD_INT 6
42261: LESS
42262: AND
42263: IFFALSE 42457
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42265: LD_ADDR_VAR 0 9
42269: PUSH
42270: LD_VAR 0 4
42274: PUSH
42275: LD_VAR 0 8
42279: PUSH
42280: LD_VAR 0 7
42284: UNION
42285: PUSH
42286: LD_VAR 0 6
42290: UNION
42291: DIFF
42292: PPUSH
42293: LD_INT 2
42295: PPUSH
42296: CALL 106595 0 2
42300: ST_TO_ADDR
// p := [ ] ;
42301: LD_ADDR_VAR 0 11
42305: PUSH
42306: EMPTY
42307: ST_TO_ADDR
// if sort then
42308: LD_VAR 0 9
42312: IFFALSE 42428
// for i = 1 to 6 - eng do
42314: LD_ADDR_VAR 0 3
42318: PUSH
42319: DOUBLE
42320: LD_INT 1
42322: DEC
42323: ST_TO_ADDR
42324: LD_INT 6
42326: PUSH
42327: LD_VAR 0 6
42331: MINUS
42332: PUSH
42333: FOR_TO
42334: IFFALSE 42426
// begin if i = sort then
42336: LD_VAR 0 3
42340: PUSH
42341: LD_VAR 0 9
42345: EQUAL
42346: IFFALSE 42350
// break ;
42348: GO 42426
// if GetClass ( i ) = 2 then
42350: LD_VAR 0 3
42354: PPUSH
42355: CALL_OW 257
42359: PUSH
42360: LD_INT 2
42362: EQUAL
42363: IFFALSE 42367
// continue ;
42365: GO 42333
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42367: LD_ADDR_VAR 0 11
42371: PUSH
42372: LD_VAR 0 11
42376: PPUSH
42377: LD_VAR 0 11
42381: PUSH
42382: LD_INT 1
42384: PLUS
42385: PPUSH
42386: LD_VAR 0 9
42390: PUSH
42391: LD_VAR 0 3
42395: ARRAY
42396: PPUSH
42397: CALL_OW 2
42401: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42402: LD_ADDR_VAR 0 4
42406: PUSH
42407: LD_VAR 0 4
42411: PUSH
42412: LD_VAR 0 9
42416: PUSH
42417: LD_VAR 0 3
42421: ARRAY
42422: DIFF
42423: ST_TO_ADDR
// end ;
42424: GO 42333
42426: POP
42427: POP
// if p then
42428: LD_VAR 0 11
42432: IFFALSE 42457
// result := Replace ( result , 2 , p ) ;
42434: LD_ADDR_VAR 0 2
42438: PUSH
42439: LD_VAR 0 2
42443: PPUSH
42444: LD_INT 2
42446: PPUSH
42447: LD_VAR 0 11
42451: PPUSH
42452: CALL_OW 1
42456: ST_TO_ADDR
// end ; exit ;
42457: GO 43181
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42459: LD_EXP 137
42463: PUSH
42464: LD_EXP 136
42468: PUSH
42469: LD_VAR 0 1
42473: ARRAY
42474: ARRAY
42475: NOT
42476: PUSH
42477: LD_EXP 110
42481: PUSH
42482: LD_VAR 0 1
42486: ARRAY
42487: PPUSH
42488: LD_INT 30
42490: PUSH
42491: LD_INT 3
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PPUSH
42498: CALL_OW 72
42502: AND
42503: PUSH
42504: LD_EXP 115
42508: PUSH
42509: LD_VAR 0 1
42513: ARRAY
42514: NOT
42515: AND
42516: IFFALSE 43181
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42518: LD_ADDR_EXP 152
42522: PUSH
42523: LD_EXP 152
42527: PPUSH
42528: LD_VAR 0 1
42532: PPUSH
42533: LD_INT 6
42535: PPUSH
42536: CALL_OW 1
42540: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42541: LD_ADDR_VAR 0 2
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: LD_INT 0
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: LD_INT 0
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: ST_TO_ADDR
// if sci >= 1 then
42564: LD_VAR 0 8
42568: PUSH
42569: LD_INT 1
42571: GREATEREQUAL
42572: IFFALSE 42594
// tmp := tmp diff sci [ 1 ] ;
42574: LD_ADDR_VAR 0 4
42578: PUSH
42579: LD_VAR 0 4
42583: PUSH
42584: LD_VAR 0 8
42588: PUSH
42589: LD_INT 1
42591: ARRAY
42592: DIFF
42593: ST_TO_ADDR
// if tmp and not sci then
42594: LD_VAR 0 4
42598: PUSH
42599: LD_VAR 0 8
42603: NOT
42604: AND
42605: IFFALSE 42674
// begin sort := SortBySkill ( tmp , 4 ) ;
42607: LD_ADDR_VAR 0 9
42611: PUSH
42612: LD_VAR 0 4
42616: PPUSH
42617: LD_INT 4
42619: PPUSH
42620: CALL 106595 0 2
42624: ST_TO_ADDR
// if sort then
42625: LD_VAR 0 9
42629: IFFALSE 42645
// p := sort [ 1 ] ;
42631: LD_ADDR_VAR 0 11
42635: PUSH
42636: LD_VAR 0 9
42640: PUSH
42641: LD_INT 1
42643: ARRAY
42644: ST_TO_ADDR
// if p then
42645: LD_VAR 0 11
42649: IFFALSE 42674
// result := Replace ( result , 4 , p ) ;
42651: LD_ADDR_VAR 0 2
42655: PUSH
42656: LD_VAR 0 2
42660: PPUSH
42661: LD_INT 4
42663: PPUSH
42664: LD_VAR 0 11
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42674: LD_ADDR_VAR 0 4
42678: PUSH
42679: LD_VAR 0 4
42683: PUSH
42684: LD_VAR 0 7
42688: DIFF
42689: ST_TO_ADDR
// if tmp and mech < 6 then
42690: LD_VAR 0 4
42694: PUSH
42695: LD_VAR 0 7
42699: PUSH
42700: LD_INT 6
42702: LESS
42703: AND
42704: IFFALSE 42886
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42706: LD_ADDR_VAR 0 9
42710: PUSH
42711: LD_VAR 0 4
42715: PUSH
42716: LD_VAR 0 7
42720: DIFF
42721: PPUSH
42722: LD_INT 3
42724: PPUSH
42725: CALL 106595 0 2
42729: ST_TO_ADDR
// p := [ ] ;
42730: LD_ADDR_VAR 0 11
42734: PUSH
42735: EMPTY
42736: ST_TO_ADDR
// if sort then
42737: LD_VAR 0 9
42741: IFFALSE 42857
// for i = 1 to 6 - mech do
42743: LD_ADDR_VAR 0 3
42747: PUSH
42748: DOUBLE
42749: LD_INT 1
42751: DEC
42752: ST_TO_ADDR
42753: LD_INT 6
42755: PUSH
42756: LD_VAR 0 7
42760: MINUS
42761: PUSH
42762: FOR_TO
42763: IFFALSE 42855
// begin if i = sort then
42765: LD_VAR 0 3
42769: PUSH
42770: LD_VAR 0 9
42774: EQUAL
42775: IFFALSE 42779
// break ;
42777: GO 42855
// if GetClass ( i ) = 3 then
42779: LD_VAR 0 3
42783: PPUSH
42784: CALL_OW 257
42788: PUSH
42789: LD_INT 3
42791: EQUAL
42792: IFFALSE 42796
// continue ;
42794: GO 42762
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42796: LD_ADDR_VAR 0 11
42800: PUSH
42801: LD_VAR 0 11
42805: PPUSH
42806: LD_VAR 0 11
42810: PUSH
42811: LD_INT 1
42813: PLUS
42814: PPUSH
42815: LD_VAR 0 9
42819: PUSH
42820: LD_VAR 0 3
42824: ARRAY
42825: PPUSH
42826: CALL_OW 2
42830: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42831: LD_ADDR_VAR 0 4
42835: PUSH
42836: LD_VAR 0 4
42840: PUSH
42841: LD_VAR 0 9
42845: PUSH
42846: LD_VAR 0 3
42850: ARRAY
42851: DIFF
42852: ST_TO_ADDR
// end ;
42853: GO 42762
42855: POP
42856: POP
// if p then
42857: LD_VAR 0 11
42861: IFFALSE 42886
// result := Replace ( result , 3 , p ) ;
42863: LD_ADDR_VAR 0 2
42867: PUSH
42868: LD_VAR 0 2
42872: PPUSH
42873: LD_INT 3
42875: PPUSH
42876: LD_VAR 0 11
42880: PPUSH
42881: CALL_OW 1
42885: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42886: LD_ADDR_VAR 0 4
42890: PUSH
42891: LD_VAR 0 4
42895: PUSH
42896: LD_VAR 0 6
42900: DIFF
42901: ST_TO_ADDR
// if tmp and eng < 4 then
42902: LD_VAR 0 4
42906: PUSH
42907: LD_VAR 0 6
42911: PUSH
42912: LD_INT 4
42914: LESS
42915: AND
42916: IFFALSE 43106
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42918: LD_ADDR_VAR 0 9
42922: PUSH
42923: LD_VAR 0 4
42927: PUSH
42928: LD_VAR 0 7
42932: PUSH
42933: LD_VAR 0 6
42937: UNION
42938: DIFF
42939: PPUSH
42940: LD_INT 2
42942: PPUSH
42943: CALL 106595 0 2
42947: ST_TO_ADDR
// p := [ ] ;
42948: LD_ADDR_VAR 0 11
42952: PUSH
42953: EMPTY
42954: ST_TO_ADDR
// if sort then
42955: LD_VAR 0 9
42959: IFFALSE 43075
// for i = 1 to 4 - eng do
42961: LD_ADDR_VAR 0 3
42965: PUSH
42966: DOUBLE
42967: LD_INT 1
42969: DEC
42970: ST_TO_ADDR
42971: LD_INT 4
42973: PUSH
42974: LD_VAR 0 6
42978: MINUS
42979: PUSH
42980: FOR_TO
42981: IFFALSE 43073
// begin if i = sort then
42983: LD_VAR 0 3
42987: PUSH
42988: LD_VAR 0 9
42992: EQUAL
42993: IFFALSE 42997
// break ;
42995: GO 43073
// if GetClass ( i ) = 2 then
42997: LD_VAR 0 3
43001: PPUSH
43002: CALL_OW 257
43006: PUSH
43007: LD_INT 2
43009: EQUAL
43010: IFFALSE 43014
// continue ;
43012: GO 42980
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43014: LD_ADDR_VAR 0 11
43018: PUSH
43019: LD_VAR 0 11
43023: PPUSH
43024: LD_VAR 0 11
43028: PUSH
43029: LD_INT 1
43031: PLUS
43032: PPUSH
43033: LD_VAR 0 9
43037: PUSH
43038: LD_VAR 0 3
43042: ARRAY
43043: PPUSH
43044: CALL_OW 2
43048: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43049: LD_ADDR_VAR 0 4
43053: PUSH
43054: LD_VAR 0 4
43058: PUSH
43059: LD_VAR 0 9
43063: PUSH
43064: LD_VAR 0 3
43068: ARRAY
43069: DIFF
43070: ST_TO_ADDR
// end ;
43071: GO 42980
43073: POP
43074: POP
// if p then
43075: LD_VAR 0 11
43079: IFFALSE 43104
// result := Replace ( result , 2 , p ) ;
43081: LD_ADDR_VAR 0 2
43085: PUSH
43086: LD_VAR 0 2
43090: PPUSH
43091: LD_INT 2
43093: PPUSH
43094: LD_VAR 0 11
43098: PPUSH
43099: CALL_OW 1
43103: ST_TO_ADDR
// end else
43104: GO 43150
// for i = eng downto 5 do
43106: LD_ADDR_VAR 0 3
43110: PUSH
43111: DOUBLE
43112: LD_VAR 0 6
43116: INC
43117: ST_TO_ADDR
43118: LD_INT 5
43120: PUSH
43121: FOR_DOWNTO
43122: IFFALSE 43148
// tmp := tmp union eng [ i ] ;
43124: LD_ADDR_VAR 0 4
43128: PUSH
43129: LD_VAR 0 4
43133: PUSH
43134: LD_VAR 0 6
43138: PUSH
43139: LD_VAR 0 3
43143: ARRAY
43144: UNION
43145: ST_TO_ADDR
43146: GO 43121
43148: POP
43149: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43150: LD_ADDR_VAR 0 2
43154: PUSH
43155: LD_VAR 0 2
43159: PPUSH
43160: LD_INT 1
43162: PPUSH
43163: LD_VAR 0 4
43167: PUSH
43168: LD_VAR 0 5
43172: DIFF
43173: PPUSH
43174: CALL_OW 1
43178: ST_TO_ADDR
// exit ;
43179: GO 43181
// end ; end ;
43181: LD_VAR 0 2
43185: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43186: LD_INT 0
43188: PPUSH
43189: PPUSH
43190: PPUSH
// if not mc_bases then
43191: LD_EXP 110
43195: NOT
43196: IFFALSE 43200
// exit ;
43198: GO 43306
// for i = 1 to mc_bases do
43200: LD_ADDR_VAR 0 2
43204: PUSH
43205: DOUBLE
43206: LD_INT 1
43208: DEC
43209: ST_TO_ADDR
43210: LD_EXP 110
43214: PUSH
43215: FOR_TO
43216: IFFALSE 43297
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43218: LD_ADDR_VAR 0 3
43222: PUSH
43223: LD_EXP 110
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: PPUSH
43234: LD_INT 21
43236: PUSH
43237: LD_INT 3
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 3
43246: PUSH
43247: LD_INT 24
43249: PUSH
43250: LD_INT 1000
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PPUSH
43265: CALL_OW 72
43269: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43270: LD_ADDR_EXP 111
43274: PUSH
43275: LD_EXP 111
43279: PPUSH
43280: LD_VAR 0 2
43284: PPUSH
43285: LD_VAR 0 3
43289: PPUSH
43290: CALL_OW 1
43294: ST_TO_ADDR
// end ;
43295: GO 43215
43297: POP
43298: POP
// RaiseSailEvent ( 101 ) ;
43299: LD_INT 101
43301: PPUSH
43302: CALL_OW 427
// end ;
43306: LD_VAR 0 1
43310: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43311: LD_INT 0
43313: PPUSH
43314: PPUSH
43315: PPUSH
43316: PPUSH
43317: PPUSH
43318: PPUSH
43319: PPUSH
// if not mc_bases then
43320: LD_EXP 110
43324: NOT
43325: IFFALSE 43329
// exit ;
43327: GO 43902
// for i = 1 to mc_bases do
43329: LD_ADDR_VAR 0 2
43333: PUSH
43334: DOUBLE
43335: LD_INT 1
43337: DEC
43338: ST_TO_ADDR
43339: LD_EXP 110
43343: PUSH
43344: FOR_TO
43345: IFFALSE 43893
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43347: LD_ADDR_VAR 0 5
43351: PUSH
43352: LD_EXP 110
43356: PUSH
43357: LD_VAR 0 2
43361: ARRAY
43362: PUSH
43363: LD_EXP 139
43367: PUSH
43368: LD_VAR 0 2
43372: ARRAY
43373: UNION
43374: PPUSH
43375: LD_INT 21
43377: PUSH
43378: LD_INT 1
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 1
43387: PUSH
43388: LD_INT 3
43390: PUSH
43391: LD_INT 54
43393: PUSH
43394: EMPTY
43395: LIST
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 24
43406: PUSH
43407: LD_INT 800
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: LIST
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PPUSH
43427: CALL_OW 72
43431: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43432: LD_ADDR_VAR 0 6
43436: PUSH
43437: LD_EXP 110
43441: PUSH
43442: LD_VAR 0 2
43446: ARRAY
43447: PPUSH
43448: LD_INT 21
43450: PUSH
43451: LD_INT 1
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 1
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 54
43466: PUSH
43467: EMPTY
43468: LIST
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: PUSH
43474: LD_INT 3
43476: PUSH
43477: LD_INT 24
43479: PUSH
43480: LD_INT 250
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: LIST
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PPUSH
43500: CALL_OW 72
43504: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43505: LD_ADDR_VAR 0 7
43509: PUSH
43510: LD_VAR 0 5
43514: PUSH
43515: LD_VAR 0 6
43519: DIFF
43520: ST_TO_ADDR
// if not need_heal_1 then
43521: LD_VAR 0 6
43525: NOT
43526: IFFALSE 43559
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43528: LD_ADDR_EXP 113
43532: PUSH
43533: LD_EXP 113
43537: PPUSH
43538: LD_VAR 0 2
43542: PUSH
43543: LD_INT 1
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PPUSH
43550: EMPTY
43551: PPUSH
43552: CALL 72337 0 3
43556: ST_TO_ADDR
43557: GO 43629
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43559: LD_ADDR_EXP 113
43563: PUSH
43564: LD_EXP 113
43568: PPUSH
43569: LD_VAR 0 2
43573: PUSH
43574: LD_INT 1
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PPUSH
43581: LD_EXP 113
43585: PUSH
43586: LD_VAR 0 2
43590: ARRAY
43591: PUSH
43592: LD_INT 1
43594: ARRAY
43595: PPUSH
43596: LD_INT 3
43598: PUSH
43599: LD_INT 24
43601: PUSH
43602: LD_INT 1000
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PPUSH
43613: CALL_OW 72
43617: PUSH
43618: LD_VAR 0 6
43622: UNION
43623: PPUSH
43624: CALL 72337 0 3
43628: ST_TO_ADDR
// if not need_heal_2 then
43629: LD_VAR 0 7
43633: NOT
43634: IFFALSE 43667
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43636: LD_ADDR_EXP 113
43640: PUSH
43641: LD_EXP 113
43645: PPUSH
43646: LD_VAR 0 2
43650: PUSH
43651: LD_INT 2
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PPUSH
43658: EMPTY
43659: PPUSH
43660: CALL 72337 0 3
43664: ST_TO_ADDR
43665: GO 43699
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43667: LD_ADDR_EXP 113
43671: PUSH
43672: LD_EXP 113
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_INT 2
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PPUSH
43689: LD_VAR 0 7
43693: PPUSH
43694: CALL 72337 0 3
43698: ST_TO_ADDR
// if need_heal_2 then
43699: LD_VAR 0 7
43703: IFFALSE 43875
// for j in need_heal_2 do
43705: LD_ADDR_VAR 0 3
43709: PUSH
43710: LD_VAR 0 7
43714: PUSH
43715: FOR_IN
43716: IFFALSE 43873
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43718: LD_ADDR_VAR 0 5
43722: PUSH
43723: LD_EXP 110
43727: PUSH
43728: LD_VAR 0 2
43732: ARRAY
43733: PPUSH
43734: LD_INT 2
43736: PUSH
43737: LD_INT 30
43739: PUSH
43740: LD_INT 6
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 30
43749: PUSH
43750: LD_INT 7
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 30
43759: PUSH
43760: LD_INT 8
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 30
43769: PUSH
43770: LD_INT 0
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 30
43779: PUSH
43780: LD_INT 1
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 25
43789: PUSH
43790: LD_INT 4
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: PPUSH
43806: CALL_OW 72
43810: ST_TO_ADDR
// if tmp then
43811: LD_VAR 0 5
43815: IFFALSE 43871
// begin k := NearestUnitToUnit ( tmp , j ) ;
43817: LD_ADDR_VAR 0 4
43821: PUSH
43822: LD_VAR 0 5
43826: PPUSH
43827: LD_VAR 0 3
43831: PPUSH
43832: CALL_OW 74
43836: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43837: LD_VAR 0 3
43841: PPUSH
43842: LD_VAR 0 4
43846: PPUSH
43847: CALL_OW 296
43851: PUSH
43852: LD_INT 7
43854: GREATER
43855: IFFALSE 43871
// ComMoveUnit ( j , k ) ;
43857: LD_VAR 0 3
43861: PPUSH
43862: LD_VAR 0 4
43866: PPUSH
43867: CALL_OW 112
// end ; end ;
43871: GO 43715
43873: POP
43874: POP
// if not need_heal_1 and not need_heal_2 then
43875: LD_VAR 0 6
43879: NOT
43880: PUSH
43881: LD_VAR 0 7
43885: NOT
43886: AND
43887: IFFALSE 43891
// continue ;
43889: GO 43344
// end ;
43891: GO 43344
43893: POP
43894: POP
// RaiseSailEvent ( 102 ) ;
43895: LD_INT 102
43897: PPUSH
43898: CALL_OW 427
// end ;
43902: LD_VAR 0 1
43906: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43907: LD_INT 0
43909: PPUSH
43910: PPUSH
43911: PPUSH
43912: PPUSH
43913: PPUSH
43914: PPUSH
43915: PPUSH
43916: PPUSH
// if not mc_bases then
43917: LD_EXP 110
43921: NOT
43922: IFFALSE 43926
// exit ;
43924: GO 44766
// for i = 1 to mc_bases do
43926: LD_ADDR_VAR 0 2
43930: PUSH
43931: DOUBLE
43932: LD_INT 1
43934: DEC
43935: ST_TO_ADDR
43936: LD_EXP 110
43940: PUSH
43941: FOR_TO
43942: IFFALSE 44764
// begin if not mc_building_need_repair [ i ] then
43944: LD_EXP 111
43948: PUSH
43949: LD_VAR 0 2
43953: ARRAY
43954: NOT
43955: IFFALSE 44129
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43957: LD_ADDR_VAR 0 6
43961: PUSH
43962: LD_EXP 129
43966: PUSH
43967: LD_VAR 0 2
43971: ARRAY
43972: PPUSH
43973: LD_INT 3
43975: PUSH
43976: LD_INT 24
43978: PUSH
43979: LD_INT 1000
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 2
43992: PUSH
43993: LD_INT 34
43995: PUSH
43996: LD_INT 13
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 34
44005: PUSH
44006: LD_INT 52
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: LIST
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PPUSH
44022: CALL_OW 72
44026: ST_TO_ADDR
// if cranes then
44027: LD_VAR 0 6
44031: IFFALSE 44093
// for j in cranes do
44033: LD_ADDR_VAR 0 3
44037: PUSH
44038: LD_VAR 0 6
44042: PUSH
44043: FOR_IN
44044: IFFALSE 44091
// if not IsInArea ( j , mc_parking [ i ] ) then
44046: LD_VAR 0 3
44050: PPUSH
44051: LD_EXP 134
44055: PUSH
44056: LD_VAR 0 2
44060: ARRAY
44061: PPUSH
44062: CALL_OW 308
44066: NOT
44067: IFFALSE 44089
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44069: LD_VAR 0 3
44073: PPUSH
44074: LD_EXP 134
44078: PUSH
44079: LD_VAR 0 2
44083: ARRAY
44084: PPUSH
44085: CALL_OW 113
44089: GO 44043
44091: POP
44092: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44093: LD_ADDR_EXP 112
44097: PUSH
44098: LD_EXP 112
44102: PPUSH
44103: LD_VAR 0 2
44107: PPUSH
44108: EMPTY
44109: PPUSH
44110: CALL_OW 1
44114: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44115: LD_VAR 0 2
44119: PPUSH
44120: LD_INT 101
44122: PPUSH
44123: CALL 39019 0 2
// continue ;
44127: GO 43941
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44129: LD_ADDR_EXP 116
44133: PUSH
44134: LD_EXP 116
44138: PPUSH
44139: LD_VAR 0 2
44143: PPUSH
44144: EMPTY
44145: PPUSH
44146: CALL_OW 1
44150: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44151: LD_VAR 0 2
44155: PPUSH
44156: LD_INT 103
44158: PPUSH
44159: CALL 39019 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44163: LD_ADDR_VAR 0 5
44167: PUSH
44168: LD_EXP 110
44172: PUSH
44173: LD_VAR 0 2
44177: ARRAY
44178: PUSH
44179: LD_EXP 139
44183: PUSH
44184: LD_VAR 0 2
44188: ARRAY
44189: UNION
44190: PPUSH
44191: LD_INT 2
44193: PUSH
44194: LD_INT 25
44196: PUSH
44197: LD_INT 2
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_INT 25
44206: PUSH
44207: LD_INT 16
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: EMPTY
44215: LIST
44216: LIST
44217: LIST
44218: PUSH
44219: EMPTY
44220: LIST
44221: PPUSH
44222: CALL_OW 72
44226: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44227: LD_ADDR_VAR 0 6
44231: PUSH
44232: LD_EXP 129
44236: PUSH
44237: LD_VAR 0 2
44241: ARRAY
44242: PPUSH
44243: LD_INT 2
44245: PUSH
44246: LD_INT 34
44248: PUSH
44249: LD_INT 13
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 34
44258: PUSH
44259: LD_INT 52
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: LIST
44270: PPUSH
44271: CALL_OW 72
44275: ST_TO_ADDR
// if cranes then
44276: LD_VAR 0 6
44280: IFFALSE 44416
// begin for j in cranes do
44282: LD_ADDR_VAR 0 3
44286: PUSH
44287: LD_VAR 0 6
44291: PUSH
44292: FOR_IN
44293: IFFALSE 44414
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44295: LD_VAR 0 3
44299: PPUSH
44300: CALL_OW 256
44304: PUSH
44305: LD_INT 500
44307: GREATEREQUAL
44308: PUSH
44309: LD_VAR 0 3
44313: PPUSH
44314: CALL_OW 314
44318: NOT
44319: AND
44320: IFFALSE 44354
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44322: LD_VAR 0 3
44326: PPUSH
44327: LD_EXP 111
44331: PUSH
44332: LD_VAR 0 2
44336: ARRAY
44337: PPUSH
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 74
44347: PPUSH
44348: CALL_OW 130
44352: GO 44412
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44354: LD_VAR 0 3
44358: PPUSH
44359: CALL_OW 256
44363: PUSH
44364: LD_INT 500
44366: LESS
44367: PUSH
44368: LD_VAR 0 3
44372: PPUSH
44373: LD_EXP 134
44377: PUSH
44378: LD_VAR 0 2
44382: ARRAY
44383: PPUSH
44384: CALL_OW 308
44388: NOT
44389: AND
44390: IFFALSE 44412
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44392: LD_VAR 0 3
44396: PPUSH
44397: LD_EXP 134
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: CALL_OW 113
44412: GO 44292
44414: POP
44415: POP
// end ; if not tmp then
44416: LD_VAR 0 5
44420: NOT
44421: IFFALSE 44425
// continue ;
44423: GO 43941
// for j in tmp do
44425: LD_ADDR_VAR 0 3
44429: PUSH
44430: LD_VAR 0 5
44434: PUSH
44435: FOR_IN
44436: IFFALSE 44760
// begin if mc_need_heal [ i ] then
44438: LD_EXP 113
44442: PUSH
44443: LD_VAR 0 2
44447: ARRAY
44448: IFFALSE 44496
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44450: LD_VAR 0 3
44454: PUSH
44455: LD_EXP 113
44459: PUSH
44460: LD_VAR 0 2
44464: ARRAY
44465: PUSH
44466: LD_INT 1
44468: ARRAY
44469: IN
44470: PUSH
44471: LD_VAR 0 3
44475: PUSH
44476: LD_EXP 113
44480: PUSH
44481: LD_VAR 0 2
44485: ARRAY
44486: PUSH
44487: LD_INT 2
44489: ARRAY
44490: IN
44491: OR
44492: IFFALSE 44496
// continue ;
44494: GO 44435
// if IsInUnit ( j ) then
44496: LD_VAR 0 3
44500: PPUSH
44501: CALL_OW 310
44505: IFFALSE 44516
// ComExitBuilding ( j ) ;
44507: LD_VAR 0 3
44511: PPUSH
44512: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44516: LD_VAR 0 3
44520: PUSH
44521: LD_EXP 112
44525: PUSH
44526: LD_VAR 0 2
44530: ARRAY
44531: IN
44532: NOT
44533: IFFALSE 44591
// begin SetTag ( j , 101 ) ;
44535: LD_VAR 0 3
44539: PPUSH
44540: LD_INT 101
44542: PPUSH
44543: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44547: LD_ADDR_EXP 112
44551: PUSH
44552: LD_EXP 112
44556: PPUSH
44557: LD_VAR 0 2
44561: PUSH
44562: LD_EXP 112
44566: PUSH
44567: LD_VAR 0 2
44571: ARRAY
44572: PUSH
44573: LD_INT 1
44575: PLUS
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PPUSH
44581: LD_VAR 0 3
44585: PPUSH
44586: CALL 72337 0 3
44590: ST_TO_ADDR
// end ; wait ( 1 ) ;
44591: LD_INT 1
44593: PPUSH
44594: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44598: LD_ADDR_VAR 0 7
44602: PUSH
44603: LD_EXP 111
44607: PUSH
44608: LD_VAR 0 2
44612: ARRAY
44613: ST_TO_ADDR
// if mc_scan [ i ] then
44614: LD_EXP 133
44618: PUSH
44619: LD_VAR 0 2
44623: ARRAY
44624: IFFALSE 44693
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44626: LD_ADDR_VAR 0 7
44630: PUSH
44631: LD_EXP 111
44635: PUSH
44636: LD_VAR 0 2
44640: ARRAY
44641: PPUSH
44642: LD_INT 3
44644: PUSH
44645: LD_INT 2
44647: PUSH
44648: LD_INT 30
44650: PUSH
44651: LD_INT 32
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 30
44660: PUSH
44661: LD_INT 33
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 30
44670: PUSH
44671: LD_INT 31
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: LIST
44682: LIST
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PPUSH
44688: CALL_OW 72
44692: ST_TO_ADDR
// if not to_repair_tmp then
44693: LD_VAR 0 7
44697: NOT
44698: IFFALSE 44702
// continue ;
44700: GO 44435
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44702: LD_ADDR_VAR 0 8
44706: PUSH
44707: LD_VAR 0 7
44711: PPUSH
44712: LD_VAR 0 3
44716: PPUSH
44717: CALL_OW 74
44721: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44722: LD_VAR 0 8
44726: PPUSH
44727: LD_INT 14
44729: PPUSH
44730: CALL 74930 0 2
44734: PUSH
44735: LD_INT 4
44737: ARRAY
44738: PUSH
44739: LD_INT 5
44741: LESS
44742: IFFALSE 44758
// ComRepairBuilding ( j , to_repair ) ;
44744: LD_VAR 0 3
44748: PPUSH
44749: LD_VAR 0 8
44753: PPUSH
44754: CALL_OW 130
// end ;
44758: GO 44435
44760: POP
44761: POP
// end ;
44762: GO 43941
44764: POP
44765: POP
// end ;
44766: LD_VAR 0 1
44770: RET
// export function MC_Heal ; var i , j , tmp ; begin
44771: LD_INT 0
44773: PPUSH
44774: PPUSH
44775: PPUSH
44776: PPUSH
// if not mc_bases then
44777: LD_EXP 110
44781: NOT
44782: IFFALSE 44786
// exit ;
44784: GO 45188
// for i = 1 to mc_bases do
44786: LD_ADDR_VAR 0 2
44790: PUSH
44791: DOUBLE
44792: LD_INT 1
44794: DEC
44795: ST_TO_ADDR
44796: LD_EXP 110
44800: PUSH
44801: FOR_TO
44802: IFFALSE 45186
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44804: LD_EXP 113
44808: PUSH
44809: LD_VAR 0 2
44813: ARRAY
44814: PUSH
44815: LD_INT 1
44817: ARRAY
44818: NOT
44819: PUSH
44820: LD_EXP 113
44824: PUSH
44825: LD_VAR 0 2
44829: ARRAY
44830: PUSH
44831: LD_INT 2
44833: ARRAY
44834: NOT
44835: AND
44836: IFFALSE 44874
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44838: LD_ADDR_EXP 114
44842: PUSH
44843: LD_EXP 114
44847: PPUSH
44848: LD_VAR 0 2
44852: PPUSH
44853: EMPTY
44854: PPUSH
44855: CALL_OW 1
44859: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44860: LD_VAR 0 2
44864: PPUSH
44865: LD_INT 102
44867: PPUSH
44868: CALL 39019 0 2
// continue ;
44872: GO 44801
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44874: LD_ADDR_VAR 0 4
44878: PUSH
44879: LD_EXP 110
44883: PUSH
44884: LD_VAR 0 2
44888: ARRAY
44889: PPUSH
44890: LD_INT 25
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PPUSH
44900: CALL_OW 72
44904: ST_TO_ADDR
// if not tmp then
44905: LD_VAR 0 4
44909: NOT
44910: IFFALSE 44914
// continue ;
44912: GO 44801
// if mc_taming [ i ] then
44914: LD_EXP 141
44918: PUSH
44919: LD_VAR 0 2
44923: ARRAY
44924: IFFALSE 44948
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44926: LD_ADDR_EXP 141
44930: PUSH
44931: LD_EXP 141
44935: PPUSH
44936: LD_VAR 0 2
44940: PPUSH
44941: EMPTY
44942: PPUSH
44943: CALL_OW 1
44947: ST_TO_ADDR
// for j in tmp do
44948: LD_ADDR_VAR 0 3
44952: PUSH
44953: LD_VAR 0 4
44957: PUSH
44958: FOR_IN
44959: IFFALSE 45182
// begin if IsInUnit ( j ) then
44961: LD_VAR 0 3
44965: PPUSH
44966: CALL_OW 310
44970: IFFALSE 44981
// ComExitBuilding ( j ) ;
44972: LD_VAR 0 3
44976: PPUSH
44977: CALL_OW 122
// if not j in mc_healers [ i ] then
44981: LD_VAR 0 3
44985: PUSH
44986: LD_EXP 114
44990: PUSH
44991: LD_VAR 0 2
44995: ARRAY
44996: IN
44997: NOT
44998: IFFALSE 45044
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45000: LD_ADDR_EXP 114
45004: PUSH
45005: LD_EXP 114
45009: PPUSH
45010: LD_VAR 0 2
45014: PUSH
45015: LD_EXP 114
45019: PUSH
45020: LD_VAR 0 2
45024: ARRAY
45025: PUSH
45026: LD_INT 1
45028: PLUS
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PPUSH
45034: LD_VAR 0 3
45038: PPUSH
45039: CALL 72337 0 3
45043: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45044: LD_VAR 0 3
45048: PPUSH
45049: CALL_OW 110
45053: PUSH
45054: LD_INT 102
45056: NONEQUAL
45057: IFFALSE 45071
// SetTag ( j , 102 ) ;
45059: LD_VAR 0 3
45063: PPUSH
45064: LD_INT 102
45066: PPUSH
45067: CALL_OW 109
// Wait ( 3 ) ;
45071: LD_INT 3
45073: PPUSH
45074: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45078: LD_EXP 113
45082: PUSH
45083: LD_VAR 0 2
45087: ARRAY
45088: PUSH
45089: LD_INT 1
45091: ARRAY
45092: IFFALSE 45124
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45094: LD_VAR 0 3
45098: PPUSH
45099: LD_EXP 113
45103: PUSH
45104: LD_VAR 0 2
45108: ARRAY
45109: PUSH
45110: LD_INT 1
45112: ARRAY
45113: PUSH
45114: LD_INT 1
45116: ARRAY
45117: PPUSH
45118: CALL_OW 128
45122: GO 45180
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45124: LD_VAR 0 3
45128: PPUSH
45129: CALL_OW 314
45133: NOT
45134: PUSH
45135: LD_EXP 113
45139: PUSH
45140: LD_VAR 0 2
45144: ARRAY
45145: PUSH
45146: LD_INT 2
45148: ARRAY
45149: AND
45150: IFFALSE 45180
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45152: LD_VAR 0 3
45156: PPUSH
45157: LD_EXP 113
45161: PUSH
45162: LD_VAR 0 2
45166: ARRAY
45167: PUSH
45168: LD_INT 2
45170: ARRAY
45171: PUSH
45172: LD_INT 1
45174: ARRAY
45175: PPUSH
45176: CALL_OW 128
// end ;
45180: GO 44958
45182: POP
45183: POP
// end ;
45184: GO 44801
45186: POP
45187: POP
// end ;
45188: LD_VAR 0 1
45192: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45193: LD_INT 0
45195: PPUSH
45196: PPUSH
45197: PPUSH
45198: PPUSH
45199: PPUSH
// if not mc_bases then
45200: LD_EXP 110
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 46352
// for i = 1 to mc_bases do
45209: LD_ADDR_VAR 0 2
45213: PUSH
45214: DOUBLE
45215: LD_INT 1
45217: DEC
45218: ST_TO_ADDR
45219: LD_EXP 110
45223: PUSH
45224: FOR_TO
45225: IFFALSE 46350
// begin if mc_scan [ i ] then
45227: LD_EXP 133
45231: PUSH
45232: LD_VAR 0 2
45236: ARRAY
45237: IFFALSE 45241
// continue ;
45239: GO 45224
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45241: LD_EXP 115
45245: PUSH
45246: LD_VAR 0 2
45250: ARRAY
45251: NOT
45252: PUSH
45253: LD_EXP 117
45257: PUSH
45258: LD_VAR 0 2
45262: ARRAY
45263: NOT
45264: AND
45265: PUSH
45266: LD_EXP 116
45270: PUSH
45271: LD_VAR 0 2
45275: ARRAY
45276: AND
45277: IFFALSE 45315
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45279: LD_ADDR_EXP 116
45283: PUSH
45284: LD_EXP 116
45288: PPUSH
45289: LD_VAR 0 2
45293: PPUSH
45294: EMPTY
45295: PPUSH
45296: CALL_OW 1
45300: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45301: LD_VAR 0 2
45305: PPUSH
45306: LD_INT 103
45308: PPUSH
45309: CALL 39019 0 2
// continue ;
45313: GO 45224
// end ; if mc_construct_list [ i ] then
45315: LD_EXP 117
45319: PUSH
45320: LD_VAR 0 2
45324: ARRAY
45325: IFFALSE 45545
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45327: LD_ADDR_VAR 0 4
45331: PUSH
45332: LD_EXP 110
45336: PUSH
45337: LD_VAR 0 2
45341: ARRAY
45342: PPUSH
45343: LD_INT 25
45345: PUSH
45346: LD_INT 2
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PPUSH
45353: CALL_OW 72
45357: PUSH
45358: LD_EXP 112
45362: PUSH
45363: LD_VAR 0 2
45367: ARRAY
45368: DIFF
45369: ST_TO_ADDR
// if not tmp then
45370: LD_VAR 0 4
45374: NOT
45375: IFFALSE 45379
// continue ;
45377: GO 45224
// for j in tmp do
45379: LD_ADDR_VAR 0 3
45383: PUSH
45384: LD_VAR 0 4
45388: PUSH
45389: FOR_IN
45390: IFFALSE 45541
// begin if not mc_builders [ i ] then
45392: LD_EXP 116
45396: PUSH
45397: LD_VAR 0 2
45401: ARRAY
45402: NOT
45403: IFFALSE 45461
// begin SetTag ( j , 103 ) ;
45405: LD_VAR 0 3
45409: PPUSH
45410: LD_INT 103
45412: PPUSH
45413: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45417: LD_ADDR_EXP 116
45421: PUSH
45422: LD_EXP 116
45426: PPUSH
45427: LD_VAR 0 2
45431: PUSH
45432: LD_EXP 116
45436: PUSH
45437: LD_VAR 0 2
45441: ARRAY
45442: PUSH
45443: LD_INT 1
45445: PLUS
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PPUSH
45451: LD_VAR 0 3
45455: PPUSH
45456: CALL 72337 0 3
45460: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45461: LD_VAR 0 3
45465: PPUSH
45466: CALL_OW 310
45470: IFFALSE 45481
// ComExitBuilding ( j ) ;
45472: LD_VAR 0 3
45476: PPUSH
45477: CALL_OW 122
// wait ( 3 ) ;
45481: LD_INT 3
45483: PPUSH
45484: CALL_OW 67
// if not mc_construct_list [ i ] then
45488: LD_EXP 117
45492: PUSH
45493: LD_VAR 0 2
45497: ARRAY
45498: NOT
45499: IFFALSE 45503
// break ;
45501: GO 45541
// if not HasTask ( j ) then
45503: LD_VAR 0 3
45507: PPUSH
45508: CALL_OW 314
45512: NOT
45513: IFFALSE 45539
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45515: LD_VAR 0 3
45519: PPUSH
45520: LD_EXP 117
45524: PUSH
45525: LD_VAR 0 2
45529: ARRAY
45530: PUSH
45531: LD_INT 1
45533: ARRAY
45534: PPUSH
45535: CALL 75188 0 2
// end ;
45539: GO 45389
45541: POP
45542: POP
// end else
45543: GO 46348
// if mc_build_list [ i ] then
45545: LD_EXP 115
45549: PUSH
45550: LD_VAR 0 2
45554: ARRAY
45555: IFFALSE 46348
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45557: LD_ADDR_VAR 0 5
45561: PUSH
45562: LD_EXP 110
45566: PUSH
45567: LD_VAR 0 2
45571: ARRAY
45572: PPUSH
45573: LD_INT 2
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 0
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 30
45588: PUSH
45589: LD_INT 1
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: PPUSH
45601: CALL_OW 72
45605: ST_TO_ADDR
// if depot then
45606: LD_VAR 0 5
45610: IFFALSE 45628
// depot := depot [ 1 ] else
45612: LD_ADDR_VAR 0 5
45616: PUSH
45617: LD_VAR 0 5
45621: PUSH
45622: LD_INT 1
45624: ARRAY
45625: ST_TO_ADDR
45626: GO 45636
// depot := 0 ;
45628: LD_ADDR_VAR 0 5
45632: PUSH
45633: LD_INT 0
45635: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45636: LD_EXP 115
45640: PUSH
45641: LD_VAR 0 2
45645: ARRAY
45646: PUSH
45647: LD_INT 1
45649: ARRAY
45650: PUSH
45651: LD_INT 1
45653: ARRAY
45654: PPUSH
45655: CALL 75018 0 1
45659: PUSH
45660: LD_EXP 110
45664: PUSH
45665: LD_VAR 0 2
45669: ARRAY
45670: PPUSH
45671: LD_INT 2
45673: PUSH
45674: LD_INT 30
45676: PUSH
45677: LD_INT 2
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 30
45686: PUSH
45687: LD_INT 3
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: LIST
45698: PPUSH
45699: CALL_OW 72
45703: NOT
45704: AND
45705: IFFALSE 45810
// begin for j = 1 to mc_build_list [ i ] do
45707: LD_ADDR_VAR 0 3
45711: PUSH
45712: DOUBLE
45713: LD_INT 1
45715: DEC
45716: ST_TO_ADDR
45717: LD_EXP 115
45721: PUSH
45722: LD_VAR 0 2
45726: ARRAY
45727: PUSH
45728: FOR_TO
45729: IFFALSE 45808
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45731: LD_EXP 115
45735: PUSH
45736: LD_VAR 0 2
45740: ARRAY
45741: PUSH
45742: LD_VAR 0 3
45746: ARRAY
45747: PUSH
45748: LD_INT 1
45750: ARRAY
45751: PUSH
45752: LD_INT 2
45754: EQUAL
45755: IFFALSE 45806
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45757: LD_ADDR_EXP 115
45761: PUSH
45762: LD_EXP 115
45766: PPUSH
45767: LD_VAR 0 2
45771: PPUSH
45772: LD_EXP 115
45776: PUSH
45777: LD_VAR 0 2
45781: ARRAY
45782: PPUSH
45783: LD_VAR 0 3
45787: PPUSH
45788: LD_INT 1
45790: PPUSH
45791: LD_INT 0
45793: PPUSH
45794: CALL 71755 0 4
45798: PPUSH
45799: CALL_OW 1
45803: ST_TO_ADDR
// break ;
45804: GO 45808
// end ;
45806: GO 45728
45808: POP
45809: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45810: LD_EXP 115
45814: PUSH
45815: LD_VAR 0 2
45819: ARRAY
45820: PUSH
45821: LD_INT 1
45823: ARRAY
45824: PUSH
45825: LD_INT 1
45827: ARRAY
45828: PUSH
45829: LD_INT 0
45831: EQUAL
45832: PUSH
45833: LD_VAR 0 5
45837: PUSH
45838: LD_VAR 0 5
45842: PPUSH
45843: LD_EXP 115
45847: PUSH
45848: LD_VAR 0 2
45852: ARRAY
45853: PUSH
45854: LD_INT 1
45856: ARRAY
45857: PUSH
45858: LD_INT 1
45860: ARRAY
45861: PPUSH
45862: LD_EXP 115
45866: PUSH
45867: LD_VAR 0 2
45871: ARRAY
45872: PUSH
45873: LD_INT 1
45875: ARRAY
45876: PUSH
45877: LD_INT 2
45879: ARRAY
45880: PPUSH
45881: LD_EXP 115
45885: PUSH
45886: LD_VAR 0 2
45890: ARRAY
45891: PUSH
45892: LD_INT 1
45894: ARRAY
45895: PUSH
45896: LD_INT 3
45898: ARRAY
45899: PPUSH
45900: LD_EXP 115
45904: PUSH
45905: LD_VAR 0 2
45909: ARRAY
45910: PUSH
45911: LD_INT 1
45913: ARRAY
45914: PUSH
45915: LD_INT 4
45917: ARRAY
45918: PPUSH
45919: CALL 79752 0 5
45923: AND
45924: OR
45925: IFFALSE 46206
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45927: LD_ADDR_VAR 0 4
45931: PUSH
45932: LD_EXP 110
45936: PUSH
45937: LD_VAR 0 2
45941: ARRAY
45942: PPUSH
45943: LD_INT 25
45945: PUSH
45946: LD_INT 2
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PPUSH
45953: CALL_OW 72
45957: PUSH
45958: LD_EXP 112
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: DIFF
45969: ST_TO_ADDR
// if not tmp then
45970: LD_VAR 0 4
45974: NOT
45975: IFFALSE 45979
// continue ;
45977: GO 45224
// for j in tmp do
45979: LD_ADDR_VAR 0 3
45983: PUSH
45984: LD_VAR 0 4
45988: PUSH
45989: FOR_IN
45990: IFFALSE 46202
// begin if not mc_builders [ i ] then
45992: LD_EXP 116
45996: PUSH
45997: LD_VAR 0 2
46001: ARRAY
46002: NOT
46003: IFFALSE 46061
// begin SetTag ( j , 103 ) ;
46005: LD_VAR 0 3
46009: PPUSH
46010: LD_INT 103
46012: PPUSH
46013: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46017: LD_ADDR_EXP 116
46021: PUSH
46022: LD_EXP 116
46026: PPUSH
46027: LD_VAR 0 2
46031: PUSH
46032: LD_EXP 116
46036: PUSH
46037: LD_VAR 0 2
46041: ARRAY
46042: PUSH
46043: LD_INT 1
46045: PLUS
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: PPUSH
46051: LD_VAR 0 3
46055: PPUSH
46056: CALL 72337 0 3
46060: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46061: LD_VAR 0 3
46065: PPUSH
46066: CALL_OW 310
46070: IFFALSE 46081
// ComExitBuilding ( j ) ;
46072: LD_VAR 0 3
46076: PPUSH
46077: CALL_OW 122
// wait ( 3 ) ;
46081: LD_INT 3
46083: PPUSH
46084: CALL_OW 67
// if not mc_build_list [ i ] then
46088: LD_EXP 115
46092: PUSH
46093: LD_VAR 0 2
46097: ARRAY
46098: NOT
46099: IFFALSE 46103
// break ;
46101: GO 46202
// if not HasTask ( j ) then
46103: LD_VAR 0 3
46107: PPUSH
46108: CALL_OW 314
46112: NOT
46113: IFFALSE 46200
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46115: LD_VAR 0 3
46119: PPUSH
46120: LD_EXP 115
46124: PUSH
46125: LD_VAR 0 2
46129: ARRAY
46130: PUSH
46131: LD_INT 1
46133: ARRAY
46134: PUSH
46135: LD_INT 1
46137: ARRAY
46138: PPUSH
46139: LD_EXP 115
46143: PUSH
46144: LD_VAR 0 2
46148: ARRAY
46149: PUSH
46150: LD_INT 1
46152: ARRAY
46153: PUSH
46154: LD_INT 2
46156: ARRAY
46157: PPUSH
46158: LD_EXP 115
46162: PUSH
46163: LD_VAR 0 2
46167: ARRAY
46168: PUSH
46169: LD_INT 1
46171: ARRAY
46172: PUSH
46173: LD_INT 3
46175: ARRAY
46176: PPUSH
46177: LD_EXP 115
46181: PUSH
46182: LD_VAR 0 2
46186: ARRAY
46187: PUSH
46188: LD_INT 1
46190: ARRAY
46191: PUSH
46192: LD_INT 4
46194: ARRAY
46195: PPUSH
46196: CALL_OW 145
// end ;
46200: GO 45989
46202: POP
46203: POP
// end else
46204: GO 46348
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46206: LD_EXP 110
46210: PUSH
46211: LD_VAR 0 2
46215: ARRAY
46216: PPUSH
46217: LD_EXP 115
46221: PUSH
46222: LD_VAR 0 2
46226: ARRAY
46227: PUSH
46228: LD_INT 1
46230: ARRAY
46231: PUSH
46232: LD_INT 1
46234: ARRAY
46235: PPUSH
46236: LD_EXP 115
46240: PUSH
46241: LD_VAR 0 2
46245: ARRAY
46246: PUSH
46247: LD_INT 1
46249: ARRAY
46250: PUSH
46251: LD_INT 2
46253: ARRAY
46254: PPUSH
46255: LD_EXP 115
46259: PUSH
46260: LD_VAR 0 2
46264: ARRAY
46265: PUSH
46266: LD_INT 1
46268: ARRAY
46269: PUSH
46270: LD_INT 3
46272: ARRAY
46273: PPUSH
46274: LD_EXP 115
46278: PUSH
46279: LD_VAR 0 2
46283: ARRAY
46284: PUSH
46285: LD_INT 1
46287: ARRAY
46288: PUSH
46289: LD_INT 4
46291: ARRAY
46292: PPUSH
46293: CALL 79088 0 5
46297: NOT
46298: IFFALSE 46348
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46300: LD_ADDR_EXP 115
46304: PUSH
46305: LD_EXP 115
46309: PPUSH
46310: LD_VAR 0 2
46314: PPUSH
46315: LD_EXP 115
46319: PUSH
46320: LD_VAR 0 2
46324: ARRAY
46325: PPUSH
46326: LD_INT 1
46328: PPUSH
46329: LD_INT 1
46331: NEG
46332: PPUSH
46333: LD_INT 0
46335: PPUSH
46336: CALL 71755 0 4
46340: PPUSH
46341: CALL_OW 1
46345: ST_TO_ADDR
// continue ;
46346: GO 45224
// end ; end ; end ;
46348: GO 45224
46350: POP
46351: POP
// end ;
46352: LD_VAR 0 1
46356: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46357: LD_INT 0
46359: PPUSH
46360: PPUSH
46361: PPUSH
46362: PPUSH
46363: PPUSH
46364: PPUSH
// if not mc_bases then
46365: LD_EXP 110
46369: NOT
46370: IFFALSE 46374
// exit ;
46372: GO 46801
// for i = 1 to mc_bases do
46374: LD_ADDR_VAR 0 2
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_EXP 110
46388: PUSH
46389: FOR_TO
46390: IFFALSE 46799
// begin tmp := mc_build_upgrade [ i ] ;
46392: LD_ADDR_VAR 0 4
46396: PUSH
46397: LD_EXP 142
46401: PUSH
46402: LD_VAR 0 2
46406: ARRAY
46407: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46408: LD_ADDR_VAR 0 6
46412: PUSH
46413: LD_EXP 143
46417: PUSH
46418: LD_VAR 0 2
46422: ARRAY
46423: PPUSH
46424: LD_INT 2
46426: PUSH
46427: LD_INT 30
46429: PUSH
46430: LD_INT 6
46432: PUSH
46433: EMPTY
46434: LIST
46435: LIST
46436: PUSH
46437: LD_INT 30
46439: PUSH
46440: LD_INT 7
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: LIST
46451: PPUSH
46452: CALL_OW 72
46456: ST_TO_ADDR
// if not tmp and not lab then
46457: LD_VAR 0 4
46461: NOT
46462: PUSH
46463: LD_VAR 0 6
46467: NOT
46468: AND
46469: IFFALSE 46473
// continue ;
46471: GO 46389
// if tmp then
46473: LD_VAR 0 4
46477: IFFALSE 46597
// for j in tmp do
46479: LD_ADDR_VAR 0 3
46483: PUSH
46484: LD_VAR 0 4
46488: PUSH
46489: FOR_IN
46490: IFFALSE 46595
// begin if UpgradeCost ( j ) then
46492: LD_VAR 0 3
46496: PPUSH
46497: CALL 78748 0 1
46501: IFFALSE 46593
// begin ComUpgrade ( j ) ;
46503: LD_VAR 0 3
46507: PPUSH
46508: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46512: LD_ADDR_EXP 142
46516: PUSH
46517: LD_EXP 142
46521: PPUSH
46522: LD_VAR 0 2
46526: PPUSH
46527: LD_EXP 142
46531: PUSH
46532: LD_VAR 0 2
46536: ARRAY
46537: PUSH
46538: LD_VAR 0 3
46542: DIFF
46543: PPUSH
46544: CALL_OW 1
46548: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46549: LD_ADDR_EXP 117
46553: PUSH
46554: LD_EXP 117
46558: PPUSH
46559: LD_VAR 0 2
46563: PUSH
46564: LD_EXP 117
46568: PUSH
46569: LD_VAR 0 2
46573: ARRAY
46574: PUSH
46575: LD_INT 1
46577: PLUS
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PPUSH
46583: LD_VAR 0 3
46587: PPUSH
46588: CALL 72337 0 3
46592: ST_TO_ADDR
// end ; end ;
46593: GO 46489
46595: POP
46596: POP
// if not lab or not mc_lab_upgrade [ i ] then
46597: LD_VAR 0 6
46601: NOT
46602: PUSH
46603: LD_EXP 144
46607: PUSH
46608: LD_VAR 0 2
46612: ARRAY
46613: NOT
46614: OR
46615: IFFALSE 46619
// continue ;
46617: GO 46389
// for j in lab do
46619: LD_ADDR_VAR 0 3
46623: PUSH
46624: LD_VAR 0 6
46628: PUSH
46629: FOR_IN
46630: IFFALSE 46795
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46632: LD_VAR 0 3
46636: PPUSH
46637: CALL_OW 266
46641: PUSH
46642: LD_INT 6
46644: PUSH
46645: LD_INT 7
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: IN
46652: PUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: CALL_OW 461
46662: PUSH
46663: LD_INT 1
46665: NONEQUAL
46666: AND
46667: IFFALSE 46793
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46669: LD_VAR 0 3
46673: PPUSH
46674: LD_EXP 144
46678: PUSH
46679: LD_VAR 0 2
46683: ARRAY
46684: PUSH
46685: LD_INT 1
46687: ARRAY
46688: PPUSH
46689: CALL 78953 0 2
46693: IFFALSE 46793
// begin ComCancel ( j ) ;
46695: LD_VAR 0 3
46699: PPUSH
46700: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46704: LD_VAR 0 3
46708: PPUSH
46709: LD_EXP 144
46713: PUSH
46714: LD_VAR 0 2
46718: ARRAY
46719: PUSH
46720: LD_INT 1
46722: ARRAY
46723: PPUSH
46724: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46728: LD_VAR 0 3
46732: PUSH
46733: LD_EXP 117
46737: PUSH
46738: LD_VAR 0 2
46742: ARRAY
46743: IN
46744: NOT
46745: IFFALSE 46791
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46747: LD_ADDR_EXP 117
46751: PUSH
46752: LD_EXP 117
46756: PPUSH
46757: LD_VAR 0 2
46761: PUSH
46762: LD_EXP 117
46766: PUSH
46767: LD_VAR 0 2
46771: ARRAY
46772: PUSH
46773: LD_INT 1
46775: PLUS
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PPUSH
46781: LD_VAR 0 3
46785: PPUSH
46786: CALL 72337 0 3
46790: ST_TO_ADDR
// break ;
46791: GO 46795
// end ; end ; end ;
46793: GO 46629
46795: POP
46796: POP
// end ;
46797: GO 46389
46799: POP
46800: POP
// end ;
46801: LD_VAR 0 1
46805: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46806: LD_INT 0
46808: PPUSH
46809: PPUSH
46810: PPUSH
46811: PPUSH
46812: PPUSH
46813: PPUSH
46814: PPUSH
46815: PPUSH
46816: PPUSH
// if not mc_bases then
46817: LD_EXP 110
46821: NOT
46822: IFFALSE 46826
// exit ;
46824: GO 47231
// for i = 1 to mc_bases do
46826: LD_ADDR_VAR 0 2
46830: PUSH
46831: DOUBLE
46832: LD_INT 1
46834: DEC
46835: ST_TO_ADDR
46836: LD_EXP 110
46840: PUSH
46841: FOR_TO
46842: IFFALSE 47229
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46844: LD_EXP 118
46848: PUSH
46849: LD_VAR 0 2
46853: ARRAY
46854: NOT
46855: PUSH
46856: LD_EXP 110
46860: PUSH
46861: LD_VAR 0 2
46865: ARRAY
46866: PPUSH
46867: LD_INT 30
46869: PUSH
46870: LD_INT 3
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: PPUSH
46877: CALL_OW 72
46881: NOT
46882: OR
46883: IFFALSE 46887
// continue ;
46885: GO 46841
// busy := false ;
46887: LD_ADDR_VAR 0 8
46891: PUSH
46892: LD_INT 0
46894: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46895: LD_ADDR_VAR 0 4
46899: PUSH
46900: LD_EXP 110
46904: PUSH
46905: LD_VAR 0 2
46909: ARRAY
46910: PPUSH
46911: LD_INT 30
46913: PUSH
46914: LD_INT 3
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PPUSH
46921: CALL_OW 72
46925: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_EXP 118
46935: PUSH
46936: LD_VAR 0 2
46940: ARRAY
46941: PPUSH
46942: LD_INT 2
46944: PUSH
46945: LD_INT 30
46947: PUSH
46948: LD_INT 32
46950: PUSH
46951: EMPTY
46952: LIST
46953: LIST
46954: PUSH
46955: LD_INT 30
46957: PUSH
46958: LD_INT 33
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: PPUSH
46970: CALL_OW 72
46974: ST_TO_ADDR
// if not t then
46975: LD_VAR 0 6
46979: NOT
46980: IFFALSE 46984
// continue ;
46982: GO 46841
// for j in tmp do
46984: LD_ADDR_VAR 0 3
46988: PUSH
46989: LD_VAR 0 4
46993: PUSH
46994: FOR_IN
46995: IFFALSE 47025
// if not BuildingStatus ( j ) = bs_idle then
46997: LD_VAR 0 3
47001: PPUSH
47002: CALL_OW 461
47006: PUSH
47007: LD_INT 2
47009: EQUAL
47010: NOT
47011: IFFALSE 47023
// begin busy := true ;
47013: LD_ADDR_VAR 0 8
47017: PUSH
47018: LD_INT 1
47020: ST_TO_ADDR
// break ;
47021: GO 47025
// end ;
47023: GO 46994
47025: POP
47026: POP
// if busy then
47027: LD_VAR 0 8
47031: IFFALSE 47035
// continue ;
47033: GO 46841
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47035: LD_ADDR_VAR 0 7
47039: PUSH
47040: LD_VAR 0 6
47044: PPUSH
47045: LD_INT 35
47047: PUSH
47048: LD_INT 0
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PPUSH
47055: CALL_OW 72
47059: ST_TO_ADDR
// if tw then
47060: LD_VAR 0 7
47064: IFFALSE 47141
// begin tw := tw [ 1 ] ;
47066: LD_ADDR_VAR 0 7
47070: PUSH
47071: LD_VAR 0 7
47075: PUSH
47076: LD_INT 1
47078: ARRAY
47079: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47080: LD_ADDR_VAR 0 9
47084: PUSH
47085: LD_VAR 0 7
47089: PPUSH
47090: LD_EXP 135
47094: PUSH
47095: LD_VAR 0 2
47099: ARRAY
47100: PPUSH
47101: CALL 77307 0 2
47105: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47106: LD_EXP 149
47110: PUSH
47111: LD_VAR 0 2
47115: ARRAY
47116: IFFALSE 47139
// if not weapon in mc_allowed_tower_weapons [ i ] then
47118: LD_VAR 0 9
47122: PUSH
47123: LD_EXP 149
47127: PUSH
47128: LD_VAR 0 2
47132: ARRAY
47133: IN
47134: NOT
47135: IFFALSE 47139
// continue ;
47137: GO 46841
// end else
47139: GO 47204
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47141: LD_ADDR_VAR 0 5
47145: PUSH
47146: LD_EXP 118
47150: PUSH
47151: LD_VAR 0 2
47155: ARRAY
47156: PPUSH
47157: LD_VAR 0 4
47161: PPUSH
47162: CALL 107518 0 2
47166: ST_TO_ADDR
// if not tmp2 then
47167: LD_VAR 0 5
47171: NOT
47172: IFFALSE 47176
// continue ;
47174: GO 46841
// tw := tmp2 [ 1 ] ;
47176: LD_ADDR_VAR 0 7
47180: PUSH
47181: LD_VAR 0 5
47185: PUSH
47186: LD_INT 1
47188: ARRAY
47189: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47190: LD_ADDR_VAR 0 9
47194: PUSH
47195: LD_VAR 0 5
47199: PUSH
47200: LD_INT 2
47202: ARRAY
47203: ST_TO_ADDR
// end ; if not weapon then
47204: LD_VAR 0 9
47208: NOT
47209: IFFALSE 47213
// continue ;
47211: GO 46841
// ComPlaceWeapon ( tw , weapon ) ;
47213: LD_VAR 0 7
47217: PPUSH
47218: LD_VAR 0 9
47222: PPUSH
47223: CALL_OW 148
// end ;
47227: GO 46841
47229: POP
47230: POP
// end ;
47231: LD_VAR 0 1
47235: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47236: LD_INT 0
47238: PPUSH
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
47243: PPUSH
// if not mc_bases then
47244: LD_EXP 110
47248: NOT
47249: IFFALSE 47253
// exit ;
47251: GO 48029
// for i = 1 to mc_bases do
47253: LD_ADDR_VAR 0 2
47257: PUSH
47258: DOUBLE
47259: LD_INT 1
47261: DEC
47262: ST_TO_ADDR
47263: LD_EXP 110
47267: PUSH
47268: FOR_TO
47269: IFFALSE 48027
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47271: LD_EXP 123
47275: PUSH
47276: LD_VAR 0 2
47280: ARRAY
47281: NOT
47282: PUSH
47283: LD_EXP 123
47287: PUSH
47288: LD_VAR 0 2
47292: ARRAY
47293: PUSH
47294: LD_EXP 124
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: EQUAL
47305: OR
47306: PUSH
47307: LD_EXP 133
47311: PUSH
47312: LD_VAR 0 2
47316: ARRAY
47317: OR
47318: IFFALSE 47322
// continue ;
47320: GO 47268
// if mc_miners [ i ] then
47322: LD_EXP 124
47326: PUSH
47327: LD_VAR 0 2
47331: ARRAY
47332: IFFALSE 47714
// begin for j = mc_miners [ i ] downto 1 do
47334: LD_ADDR_VAR 0 3
47338: PUSH
47339: DOUBLE
47340: LD_EXP 124
47344: PUSH
47345: LD_VAR 0 2
47349: ARRAY
47350: INC
47351: ST_TO_ADDR
47352: LD_INT 1
47354: PUSH
47355: FOR_DOWNTO
47356: IFFALSE 47712
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47358: LD_EXP 124
47362: PUSH
47363: LD_VAR 0 2
47367: ARRAY
47368: PUSH
47369: LD_VAR 0 3
47373: ARRAY
47374: PPUSH
47375: CALL_OW 301
47379: PUSH
47380: LD_EXP 124
47384: PUSH
47385: LD_VAR 0 2
47389: ARRAY
47390: PUSH
47391: LD_VAR 0 3
47395: ARRAY
47396: PPUSH
47397: CALL_OW 257
47401: PUSH
47402: LD_INT 1
47404: NONEQUAL
47405: OR
47406: IFFALSE 47469
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47408: LD_ADDR_VAR 0 5
47412: PUSH
47413: LD_EXP 124
47417: PUSH
47418: LD_VAR 0 2
47422: ARRAY
47423: PUSH
47424: LD_EXP 124
47428: PUSH
47429: LD_VAR 0 2
47433: ARRAY
47434: PUSH
47435: LD_VAR 0 3
47439: ARRAY
47440: DIFF
47441: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47442: LD_ADDR_EXP 124
47446: PUSH
47447: LD_EXP 124
47451: PPUSH
47452: LD_VAR 0 2
47456: PPUSH
47457: LD_VAR 0 5
47461: PPUSH
47462: CALL_OW 1
47466: ST_TO_ADDR
// continue ;
47467: GO 47355
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47469: LD_EXP 124
47473: PUSH
47474: LD_VAR 0 2
47478: ARRAY
47479: PUSH
47480: LD_VAR 0 3
47484: ARRAY
47485: PPUSH
47486: CALL_OW 257
47490: PUSH
47491: LD_INT 1
47493: EQUAL
47494: PUSH
47495: LD_EXP 124
47499: PUSH
47500: LD_VAR 0 2
47504: ARRAY
47505: PUSH
47506: LD_VAR 0 3
47510: ARRAY
47511: PPUSH
47512: CALL_OW 459
47516: NOT
47517: AND
47518: PUSH
47519: LD_EXP 124
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: PUSH
47530: LD_VAR 0 3
47534: ARRAY
47535: PPUSH
47536: CALL_OW 314
47540: NOT
47541: AND
47542: IFFALSE 47710
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47544: LD_EXP 124
47548: PUSH
47549: LD_VAR 0 2
47553: ARRAY
47554: PUSH
47555: LD_VAR 0 3
47559: ARRAY
47560: PPUSH
47561: CALL_OW 310
47565: IFFALSE 47588
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47567: LD_EXP 124
47571: PUSH
47572: LD_VAR 0 2
47576: ARRAY
47577: PUSH
47578: LD_VAR 0 3
47582: ARRAY
47583: PPUSH
47584: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47588: LD_EXP 124
47592: PUSH
47593: LD_VAR 0 2
47597: ARRAY
47598: PUSH
47599: LD_VAR 0 3
47603: ARRAY
47604: PPUSH
47605: CALL_OW 314
47609: NOT
47610: IFFALSE 47710
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47612: LD_EXP 124
47616: PUSH
47617: LD_VAR 0 2
47621: ARRAY
47622: PUSH
47623: LD_VAR 0 3
47627: ARRAY
47628: PPUSH
47629: LD_EXP 123
47633: PUSH
47634: LD_VAR 0 2
47638: ARRAY
47639: PUSH
47640: LD_VAR 0 3
47644: PUSH
47645: LD_EXP 123
47649: PUSH
47650: LD_VAR 0 2
47654: ARRAY
47655: MOD
47656: PUSH
47657: LD_INT 1
47659: PLUS
47660: ARRAY
47661: PUSH
47662: LD_INT 1
47664: ARRAY
47665: PPUSH
47666: LD_EXP 123
47670: PUSH
47671: LD_VAR 0 2
47675: ARRAY
47676: PUSH
47677: LD_VAR 0 3
47681: PUSH
47682: LD_EXP 123
47686: PUSH
47687: LD_VAR 0 2
47691: ARRAY
47692: MOD
47693: PUSH
47694: LD_INT 1
47696: PLUS
47697: ARRAY
47698: PUSH
47699: LD_INT 2
47701: ARRAY
47702: PPUSH
47703: LD_INT 0
47705: PPUSH
47706: CALL_OW 193
// end ; end ;
47710: GO 47355
47712: POP
47713: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47714: LD_ADDR_VAR 0 5
47718: PUSH
47719: LD_EXP 110
47723: PUSH
47724: LD_VAR 0 2
47728: ARRAY
47729: PPUSH
47730: LD_INT 2
47732: PUSH
47733: LD_INT 30
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: EMPTY
47740: LIST
47741: LIST
47742: PUSH
47743: LD_INT 30
47745: PUSH
47746: LD_INT 5
47748: PUSH
47749: EMPTY
47750: LIST
47751: LIST
47752: PUSH
47753: LD_INT 30
47755: PUSH
47756: LD_INT 32
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: PPUSH
47769: CALL_OW 72
47773: ST_TO_ADDR
// if not tmp then
47774: LD_VAR 0 5
47778: NOT
47779: IFFALSE 47783
// continue ;
47781: GO 47268
// list := [ ] ;
47783: LD_ADDR_VAR 0 6
47787: PUSH
47788: EMPTY
47789: ST_TO_ADDR
// for j in tmp do
47790: LD_ADDR_VAR 0 3
47794: PUSH
47795: LD_VAR 0 5
47799: PUSH
47800: FOR_IN
47801: IFFALSE 47870
// begin for k in UnitsInside ( j ) do
47803: LD_ADDR_VAR 0 4
47807: PUSH
47808: LD_VAR 0 3
47812: PPUSH
47813: CALL_OW 313
47817: PUSH
47818: FOR_IN
47819: IFFALSE 47866
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47821: LD_VAR 0 4
47825: PPUSH
47826: CALL_OW 257
47830: PUSH
47831: LD_INT 1
47833: EQUAL
47834: PUSH
47835: LD_VAR 0 4
47839: PPUSH
47840: CALL_OW 459
47844: NOT
47845: AND
47846: IFFALSE 47864
// list := list ^ k ;
47848: LD_ADDR_VAR 0 6
47852: PUSH
47853: LD_VAR 0 6
47857: PUSH
47858: LD_VAR 0 4
47862: ADD
47863: ST_TO_ADDR
47864: GO 47818
47866: POP
47867: POP
// end ;
47868: GO 47800
47870: POP
47871: POP
// list := list diff mc_miners [ i ] ;
47872: LD_ADDR_VAR 0 6
47876: PUSH
47877: LD_VAR 0 6
47881: PUSH
47882: LD_EXP 124
47886: PUSH
47887: LD_VAR 0 2
47891: ARRAY
47892: DIFF
47893: ST_TO_ADDR
// if not list then
47894: LD_VAR 0 6
47898: NOT
47899: IFFALSE 47903
// continue ;
47901: GO 47268
// k := mc_mines [ i ] - mc_miners [ i ] ;
47903: LD_ADDR_VAR 0 4
47907: PUSH
47908: LD_EXP 123
47912: PUSH
47913: LD_VAR 0 2
47917: ARRAY
47918: PUSH
47919: LD_EXP 124
47923: PUSH
47924: LD_VAR 0 2
47928: ARRAY
47929: MINUS
47930: ST_TO_ADDR
// if k > list then
47931: LD_VAR 0 4
47935: PUSH
47936: LD_VAR 0 6
47940: GREATER
47941: IFFALSE 47953
// k := list ;
47943: LD_ADDR_VAR 0 4
47947: PUSH
47948: LD_VAR 0 6
47952: ST_TO_ADDR
// for j = 1 to k do
47953: LD_ADDR_VAR 0 3
47957: PUSH
47958: DOUBLE
47959: LD_INT 1
47961: DEC
47962: ST_TO_ADDR
47963: LD_VAR 0 4
47967: PUSH
47968: FOR_TO
47969: IFFALSE 48023
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47971: LD_ADDR_EXP 124
47975: PUSH
47976: LD_EXP 124
47980: PPUSH
47981: LD_VAR 0 2
47985: PUSH
47986: LD_EXP 124
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: PUSH
47997: LD_INT 1
47999: PLUS
48000: PUSH
48001: EMPTY
48002: LIST
48003: LIST
48004: PPUSH
48005: LD_VAR 0 6
48009: PUSH
48010: LD_VAR 0 3
48014: ARRAY
48015: PPUSH
48016: CALL 72337 0 3
48020: ST_TO_ADDR
48021: GO 47968
48023: POP
48024: POP
// end ;
48025: GO 47268
48027: POP
48028: POP
// end ;
48029: LD_VAR 0 1
48033: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48034: LD_INT 0
48036: PPUSH
48037: PPUSH
48038: PPUSH
48039: PPUSH
48040: PPUSH
48041: PPUSH
48042: PPUSH
48043: PPUSH
48044: PPUSH
48045: PPUSH
// if not mc_bases then
48046: LD_EXP 110
48050: NOT
48051: IFFALSE 48055
// exit ;
48053: GO 49805
// for i = 1 to mc_bases do
48055: LD_ADDR_VAR 0 2
48059: PUSH
48060: DOUBLE
48061: LD_INT 1
48063: DEC
48064: ST_TO_ADDR
48065: LD_EXP 110
48069: PUSH
48070: FOR_TO
48071: IFFALSE 49803
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48073: LD_EXP 110
48077: PUSH
48078: LD_VAR 0 2
48082: ARRAY
48083: NOT
48084: PUSH
48085: LD_EXP 117
48089: PUSH
48090: LD_VAR 0 2
48094: ARRAY
48095: OR
48096: IFFALSE 48100
// continue ;
48098: GO 48070
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48100: LD_EXP 126
48104: PUSH
48105: LD_VAR 0 2
48109: ARRAY
48110: NOT
48111: PUSH
48112: LD_EXP 127
48116: PUSH
48117: LD_VAR 0 2
48121: ARRAY
48122: AND
48123: IFFALSE 48161
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48125: LD_ADDR_EXP 127
48129: PUSH
48130: LD_EXP 127
48134: PPUSH
48135: LD_VAR 0 2
48139: PPUSH
48140: EMPTY
48141: PPUSH
48142: CALL_OW 1
48146: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48147: LD_VAR 0 2
48151: PPUSH
48152: LD_INT 107
48154: PPUSH
48155: CALL 39019 0 2
// continue ;
48159: GO 48070
// end ; target := [ ] ;
48161: LD_ADDR_VAR 0 6
48165: PUSH
48166: EMPTY
48167: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48168: LD_ADDR_VAR 0 3
48172: PUSH
48173: DOUBLE
48174: LD_EXP 126
48178: PUSH
48179: LD_VAR 0 2
48183: ARRAY
48184: INC
48185: ST_TO_ADDR
48186: LD_INT 1
48188: PUSH
48189: FOR_DOWNTO
48190: IFFALSE 48450
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48192: LD_EXP 126
48196: PUSH
48197: LD_VAR 0 2
48201: ARRAY
48202: PUSH
48203: LD_VAR 0 3
48207: ARRAY
48208: PUSH
48209: LD_INT 2
48211: ARRAY
48212: PPUSH
48213: LD_EXP 126
48217: PUSH
48218: LD_VAR 0 2
48222: ARRAY
48223: PUSH
48224: LD_VAR 0 3
48228: ARRAY
48229: PUSH
48230: LD_INT 3
48232: ARRAY
48233: PPUSH
48234: CALL_OW 488
48238: PUSH
48239: LD_EXP 126
48243: PUSH
48244: LD_VAR 0 2
48248: ARRAY
48249: PUSH
48250: LD_VAR 0 3
48254: ARRAY
48255: PUSH
48256: LD_INT 2
48258: ARRAY
48259: PPUSH
48260: LD_EXP 126
48264: PUSH
48265: LD_VAR 0 2
48269: ARRAY
48270: PUSH
48271: LD_VAR 0 3
48275: ARRAY
48276: PUSH
48277: LD_INT 3
48279: ARRAY
48280: PPUSH
48281: CALL_OW 284
48285: PUSH
48286: LD_INT 0
48288: EQUAL
48289: AND
48290: IFFALSE 48345
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48292: LD_ADDR_VAR 0 5
48296: PUSH
48297: LD_EXP 126
48301: PUSH
48302: LD_VAR 0 2
48306: ARRAY
48307: PPUSH
48308: LD_VAR 0 3
48312: PPUSH
48313: CALL_OW 3
48317: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48318: LD_ADDR_EXP 126
48322: PUSH
48323: LD_EXP 126
48327: PPUSH
48328: LD_VAR 0 2
48332: PPUSH
48333: LD_VAR 0 5
48337: PPUSH
48338: CALL_OW 1
48342: ST_TO_ADDR
// continue ;
48343: GO 48189
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48345: LD_EXP 110
48349: PUSH
48350: LD_VAR 0 2
48354: ARRAY
48355: PUSH
48356: LD_INT 1
48358: ARRAY
48359: PPUSH
48360: CALL_OW 255
48364: PPUSH
48365: LD_EXP 126
48369: PUSH
48370: LD_VAR 0 2
48374: ARRAY
48375: PUSH
48376: LD_VAR 0 3
48380: ARRAY
48381: PUSH
48382: LD_INT 2
48384: ARRAY
48385: PPUSH
48386: LD_EXP 126
48390: PUSH
48391: LD_VAR 0 2
48395: ARRAY
48396: PUSH
48397: LD_VAR 0 3
48401: ARRAY
48402: PUSH
48403: LD_INT 3
48405: ARRAY
48406: PPUSH
48407: LD_INT 30
48409: PPUSH
48410: CALL 73233 0 4
48414: PUSH
48415: LD_INT 4
48417: ARRAY
48418: PUSH
48419: LD_INT 0
48421: EQUAL
48422: IFFALSE 48448
// begin target := mc_crates [ i ] [ j ] ;
48424: LD_ADDR_VAR 0 6
48428: PUSH
48429: LD_EXP 126
48433: PUSH
48434: LD_VAR 0 2
48438: ARRAY
48439: PUSH
48440: LD_VAR 0 3
48444: ARRAY
48445: ST_TO_ADDR
// break ;
48446: GO 48450
// end ; end ;
48448: GO 48189
48450: POP
48451: POP
// if not target then
48452: LD_VAR 0 6
48456: NOT
48457: IFFALSE 48461
// continue ;
48459: GO 48070
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48461: LD_ADDR_VAR 0 7
48465: PUSH
48466: LD_EXP 129
48470: PUSH
48471: LD_VAR 0 2
48475: ARRAY
48476: PPUSH
48477: LD_INT 2
48479: PUSH
48480: LD_INT 3
48482: PUSH
48483: LD_INT 58
48485: PUSH
48486: EMPTY
48487: LIST
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: PUSH
48493: LD_INT 61
48495: PUSH
48496: EMPTY
48497: LIST
48498: PUSH
48499: LD_INT 33
48501: PUSH
48502: LD_INT 5
48504: PUSH
48505: EMPTY
48506: LIST
48507: LIST
48508: PUSH
48509: LD_INT 33
48511: PUSH
48512: LD_INT 3
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: EMPTY
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: PUSH
48526: LD_INT 2
48528: PUSH
48529: LD_INT 34
48531: PUSH
48532: LD_INT 32
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: LD_INT 34
48541: PUSH
48542: LD_INT 51
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: LD_INT 34
48551: PUSH
48552: LD_INT 12
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: LIST
48563: LIST
48564: PUSH
48565: EMPTY
48566: LIST
48567: LIST
48568: PPUSH
48569: CALL_OW 72
48573: ST_TO_ADDR
// if not cargo then
48574: LD_VAR 0 7
48578: NOT
48579: IFFALSE 49222
// begin if mc_crates_collector [ i ] < 5 then
48581: LD_EXP 127
48585: PUSH
48586: LD_VAR 0 2
48590: ARRAY
48591: PUSH
48592: LD_INT 5
48594: LESS
48595: IFFALSE 48961
// begin if mc_ape [ i ] then
48597: LD_EXP 139
48601: PUSH
48602: LD_VAR 0 2
48606: ARRAY
48607: IFFALSE 48654
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48609: LD_ADDR_VAR 0 5
48613: PUSH
48614: LD_EXP 139
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: PPUSH
48625: LD_INT 25
48627: PUSH
48628: LD_INT 16
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: PUSH
48635: LD_INT 24
48637: PUSH
48638: LD_INT 750
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PPUSH
48649: CALL_OW 72
48653: ST_TO_ADDR
// if not tmp then
48654: LD_VAR 0 5
48658: NOT
48659: IFFALSE 48706
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48661: LD_ADDR_VAR 0 5
48665: PUSH
48666: LD_EXP 110
48670: PUSH
48671: LD_VAR 0 2
48675: ARRAY
48676: PPUSH
48677: LD_INT 25
48679: PUSH
48680: LD_INT 2
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 24
48689: PUSH
48690: LD_INT 750
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PUSH
48697: EMPTY
48698: LIST
48699: LIST
48700: PPUSH
48701: CALL_OW 72
48705: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48706: LD_EXP 139
48710: PUSH
48711: LD_VAR 0 2
48715: ARRAY
48716: PUSH
48717: LD_EXP 110
48721: PUSH
48722: LD_VAR 0 2
48726: ARRAY
48727: PPUSH
48728: LD_INT 25
48730: PUSH
48731: LD_INT 2
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: PUSH
48738: LD_INT 24
48740: PUSH
48741: LD_INT 750
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: EMPTY
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: AND
48757: PUSH
48758: LD_VAR 0 5
48762: PUSH
48763: LD_INT 5
48765: LESS
48766: AND
48767: IFFALSE 48849
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48769: LD_ADDR_VAR 0 3
48773: PUSH
48774: LD_EXP 110
48778: PUSH
48779: LD_VAR 0 2
48783: ARRAY
48784: PPUSH
48785: LD_INT 25
48787: PUSH
48788: LD_INT 2
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PUSH
48795: LD_INT 24
48797: PUSH
48798: LD_INT 750
48800: PUSH
48801: EMPTY
48802: LIST
48803: LIST
48804: PUSH
48805: EMPTY
48806: LIST
48807: LIST
48808: PPUSH
48809: CALL_OW 72
48813: PUSH
48814: FOR_IN
48815: IFFALSE 48847
// begin tmp := tmp union j ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_VAR 0 5
48826: PUSH
48827: LD_VAR 0 3
48831: UNION
48832: ST_TO_ADDR
// if tmp >= 5 then
48833: LD_VAR 0 5
48837: PUSH
48838: LD_INT 5
48840: GREATEREQUAL
48841: IFFALSE 48845
// break ;
48843: GO 48847
// end ;
48845: GO 48814
48847: POP
48848: POP
// end ; if not tmp then
48849: LD_VAR 0 5
48853: NOT
48854: IFFALSE 48858
// continue ;
48856: GO 48070
// for j in tmp do
48858: LD_ADDR_VAR 0 3
48862: PUSH
48863: LD_VAR 0 5
48867: PUSH
48868: FOR_IN
48869: IFFALSE 48959
// if not GetTag ( j ) then
48871: LD_VAR 0 3
48875: PPUSH
48876: CALL_OW 110
48880: NOT
48881: IFFALSE 48957
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48883: LD_ADDR_EXP 127
48887: PUSH
48888: LD_EXP 127
48892: PPUSH
48893: LD_VAR 0 2
48897: PUSH
48898: LD_EXP 127
48902: PUSH
48903: LD_VAR 0 2
48907: ARRAY
48908: PUSH
48909: LD_INT 1
48911: PLUS
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: PPUSH
48917: LD_VAR 0 3
48921: PPUSH
48922: CALL 72337 0 3
48926: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48927: LD_VAR 0 3
48931: PPUSH
48932: LD_INT 107
48934: PPUSH
48935: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48939: LD_EXP 127
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: PUSH
48950: LD_INT 5
48952: GREATEREQUAL
48953: IFFALSE 48957
// break ;
48955: GO 48959
// end ;
48957: GO 48868
48959: POP
48960: POP
// end ; if mc_crates_collector [ i ] and target then
48961: LD_EXP 127
48965: PUSH
48966: LD_VAR 0 2
48970: ARRAY
48971: PUSH
48972: LD_VAR 0 6
48976: AND
48977: IFFALSE 49220
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48979: LD_EXP 127
48983: PUSH
48984: LD_VAR 0 2
48988: ARRAY
48989: PUSH
48990: LD_VAR 0 6
48994: PUSH
48995: LD_INT 1
48997: ARRAY
48998: LESS
48999: IFFALSE 49019
// tmp := mc_crates_collector [ i ] else
49001: LD_ADDR_VAR 0 5
49005: PUSH
49006: LD_EXP 127
49010: PUSH
49011: LD_VAR 0 2
49015: ARRAY
49016: ST_TO_ADDR
49017: GO 49033
// tmp := target [ 1 ] ;
49019: LD_ADDR_VAR 0 5
49023: PUSH
49024: LD_VAR 0 6
49028: PUSH
49029: LD_INT 1
49031: ARRAY
49032: ST_TO_ADDR
// k := 0 ;
49033: LD_ADDR_VAR 0 4
49037: PUSH
49038: LD_INT 0
49040: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49041: LD_ADDR_VAR 0 3
49045: PUSH
49046: LD_EXP 127
49050: PUSH
49051: LD_VAR 0 2
49055: ARRAY
49056: PUSH
49057: FOR_IN
49058: IFFALSE 49218
// begin k := k + 1 ;
49060: LD_ADDR_VAR 0 4
49064: PUSH
49065: LD_VAR 0 4
49069: PUSH
49070: LD_INT 1
49072: PLUS
49073: ST_TO_ADDR
// if k > tmp then
49074: LD_VAR 0 4
49078: PUSH
49079: LD_VAR 0 5
49083: GREATER
49084: IFFALSE 49088
// break ;
49086: GO 49218
// if not GetClass ( j ) in [ 2 , 16 ] then
49088: LD_VAR 0 3
49092: PPUSH
49093: CALL_OW 257
49097: PUSH
49098: LD_INT 2
49100: PUSH
49101: LD_INT 16
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: IN
49108: NOT
49109: IFFALSE 49162
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49111: LD_ADDR_EXP 127
49115: PUSH
49116: LD_EXP 127
49120: PPUSH
49121: LD_VAR 0 2
49125: PPUSH
49126: LD_EXP 127
49130: PUSH
49131: LD_VAR 0 2
49135: ARRAY
49136: PUSH
49137: LD_VAR 0 3
49141: DIFF
49142: PPUSH
49143: CALL_OW 1
49147: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49148: LD_VAR 0 3
49152: PPUSH
49153: LD_INT 0
49155: PPUSH
49156: CALL_OW 109
// continue ;
49160: GO 49057
// end ; if IsInUnit ( j ) then
49162: LD_VAR 0 3
49166: PPUSH
49167: CALL_OW 310
49171: IFFALSE 49182
// ComExitBuilding ( j ) ;
49173: LD_VAR 0 3
49177: PPUSH
49178: CALL_OW 122
// wait ( 3 ) ;
49182: LD_INT 3
49184: PPUSH
49185: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49189: LD_VAR 0 3
49193: PPUSH
49194: LD_VAR 0 6
49198: PUSH
49199: LD_INT 2
49201: ARRAY
49202: PPUSH
49203: LD_VAR 0 6
49207: PUSH
49208: LD_INT 3
49210: ARRAY
49211: PPUSH
49212: CALL_OW 117
// end ;
49216: GO 49057
49218: POP
49219: POP
// end ; end else
49220: GO 49801
// begin for j in cargo do
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: LD_VAR 0 7
49231: PUSH
49232: FOR_IN
49233: IFFALSE 49799
// begin if GetTag ( j ) <> 0 then
49235: LD_VAR 0 3
49239: PPUSH
49240: CALL_OW 110
49244: PUSH
49245: LD_INT 0
49247: NONEQUAL
49248: IFFALSE 49252
// continue ;
49250: GO 49232
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49252: LD_VAR 0 3
49256: PPUSH
49257: CALL_OW 256
49261: PUSH
49262: LD_INT 1000
49264: LESS
49265: PUSH
49266: LD_VAR 0 3
49270: PPUSH
49271: LD_EXP 134
49275: PUSH
49276: LD_VAR 0 2
49280: ARRAY
49281: PPUSH
49282: CALL_OW 308
49286: NOT
49287: AND
49288: IFFALSE 49310
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49290: LD_VAR 0 3
49294: PPUSH
49295: LD_EXP 134
49299: PUSH
49300: LD_VAR 0 2
49304: ARRAY
49305: PPUSH
49306: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49310: LD_VAR 0 3
49314: PPUSH
49315: CALL_OW 256
49319: PUSH
49320: LD_INT 1000
49322: LESS
49323: PUSH
49324: LD_VAR 0 3
49328: PPUSH
49329: LD_EXP 134
49333: PUSH
49334: LD_VAR 0 2
49338: ARRAY
49339: PPUSH
49340: CALL_OW 308
49344: AND
49345: IFFALSE 49349
// continue ;
49347: GO 49232
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49349: LD_VAR 0 3
49353: PPUSH
49354: CALL_OW 262
49358: PUSH
49359: LD_INT 2
49361: EQUAL
49362: PUSH
49363: LD_VAR 0 3
49367: PPUSH
49368: CALL_OW 261
49372: PUSH
49373: LD_INT 15
49375: LESS
49376: AND
49377: IFFALSE 49381
// continue ;
49379: GO 49232
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49381: LD_VAR 0 3
49385: PPUSH
49386: CALL_OW 262
49390: PUSH
49391: LD_INT 1
49393: EQUAL
49394: PUSH
49395: LD_VAR 0 3
49399: PPUSH
49400: CALL_OW 261
49404: PUSH
49405: LD_INT 10
49407: LESS
49408: AND
49409: IFFALSE 49738
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49411: LD_ADDR_VAR 0 8
49415: PUSH
49416: LD_EXP 110
49420: PUSH
49421: LD_VAR 0 2
49425: ARRAY
49426: PPUSH
49427: LD_INT 2
49429: PUSH
49430: LD_INT 30
49432: PUSH
49433: LD_INT 0
49435: PUSH
49436: EMPTY
49437: LIST
49438: LIST
49439: PUSH
49440: LD_INT 30
49442: PUSH
49443: LD_INT 1
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: LIST
49454: PPUSH
49455: CALL_OW 72
49459: ST_TO_ADDR
// if not depot then
49460: LD_VAR 0 8
49464: NOT
49465: IFFALSE 49469
// continue ;
49467: GO 49232
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49469: LD_VAR 0 3
49473: PPUSH
49474: LD_VAR 0 8
49478: PPUSH
49479: LD_VAR 0 3
49483: PPUSH
49484: CALL_OW 74
49488: PPUSH
49489: CALL_OW 296
49493: PUSH
49494: LD_INT 6
49496: LESS
49497: IFFALSE 49513
// SetFuel ( j , 100 ) else
49499: LD_VAR 0 3
49503: PPUSH
49504: LD_INT 100
49506: PPUSH
49507: CALL_OW 240
49511: GO 49738
// if GetFuel ( j ) = 0 then
49513: LD_VAR 0 3
49517: PPUSH
49518: CALL_OW 261
49522: PUSH
49523: LD_INT 0
49525: EQUAL
49526: IFFALSE 49738
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49528: LD_ADDR_EXP 129
49532: PUSH
49533: LD_EXP 129
49537: PPUSH
49538: LD_VAR 0 2
49542: PPUSH
49543: LD_EXP 129
49547: PUSH
49548: LD_VAR 0 2
49552: ARRAY
49553: PUSH
49554: LD_VAR 0 3
49558: DIFF
49559: PPUSH
49560: CALL_OW 1
49564: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49565: LD_VAR 0 3
49569: PPUSH
49570: CALL_OW 263
49574: PUSH
49575: LD_INT 1
49577: EQUAL
49578: IFFALSE 49594
// ComExitVehicle ( IsInUnit ( j ) ) ;
49580: LD_VAR 0 3
49584: PPUSH
49585: CALL_OW 310
49589: PPUSH
49590: CALL_OW 121
// if GetControl ( j ) = control_remote then
49594: LD_VAR 0 3
49598: PPUSH
49599: CALL_OW 263
49603: PUSH
49604: LD_INT 2
49606: EQUAL
49607: IFFALSE 49618
// ComUnlink ( j ) ;
49609: LD_VAR 0 3
49613: PPUSH
49614: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49618: LD_ADDR_VAR 0 9
49622: PUSH
49623: LD_VAR 0 2
49627: PPUSH
49628: LD_INT 3
49630: PPUSH
49631: CALL 59091 0 2
49635: ST_TO_ADDR
// if fac then
49636: LD_VAR 0 9
49640: IFFALSE 49736
// begin for k in fac do
49642: LD_ADDR_VAR 0 4
49646: PUSH
49647: LD_VAR 0 9
49651: PUSH
49652: FOR_IN
49653: IFFALSE 49734
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49655: LD_ADDR_VAR 0 10
49659: PUSH
49660: LD_VAR 0 9
49664: PPUSH
49665: LD_VAR 0 3
49669: PPUSH
49670: CALL_OW 265
49674: PPUSH
49675: LD_VAR 0 3
49679: PPUSH
49680: CALL_OW 262
49684: PPUSH
49685: LD_VAR 0 3
49689: PPUSH
49690: CALL_OW 263
49694: PPUSH
49695: LD_VAR 0 3
49699: PPUSH
49700: CALL_OW 264
49704: PPUSH
49705: CALL 69869 0 5
49709: ST_TO_ADDR
// if components then
49710: LD_VAR 0 10
49714: IFFALSE 49732
// begin MC_InsertProduceList ( i , components ) ;
49716: LD_VAR 0 2
49720: PPUSH
49721: LD_VAR 0 10
49725: PPUSH
49726: CALL 58636 0 2
// break ;
49730: GO 49734
// end ; end ;
49732: GO 49652
49734: POP
49735: POP
// end ; continue ;
49736: GO 49232
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49738: LD_VAR 0 3
49742: PPUSH
49743: LD_INT 1
49745: PPUSH
49746: CALL_OW 289
49750: PUSH
49751: LD_INT 100
49753: LESS
49754: PUSH
49755: LD_VAR 0 3
49759: PPUSH
49760: CALL_OW 314
49764: NOT
49765: AND
49766: IFFALSE 49795
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49768: LD_VAR 0 3
49772: PPUSH
49773: LD_VAR 0 6
49777: PUSH
49778: LD_INT 2
49780: ARRAY
49781: PPUSH
49782: LD_VAR 0 6
49786: PUSH
49787: LD_INT 3
49789: ARRAY
49790: PPUSH
49791: CALL_OW 117
// break ;
49795: GO 49799
// end ;
49797: GO 49232
49799: POP
49800: POP
// end ; end ;
49801: GO 48070
49803: POP
49804: POP
// end ;
49805: LD_VAR 0 1
49809: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49810: LD_INT 0
49812: PPUSH
49813: PPUSH
49814: PPUSH
49815: PPUSH
// if not mc_bases then
49816: LD_EXP 110
49820: NOT
49821: IFFALSE 49825
// exit ;
49823: GO 49986
// for i = 1 to mc_bases do
49825: LD_ADDR_VAR 0 2
49829: PUSH
49830: DOUBLE
49831: LD_INT 1
49833: DEC
49834: ST_TO_ADDR
49835: LD_EXP 110
49839: PUSH
49840: FOR_TO
49841: IFFALSE 49984
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49843: LD_ADDR_VAR 0 4
49847: PUSH
49848: LD_EXP 129
49852: PUSH
49853: LD_VAR 0 2
49857: ARRAY
49858: PUSH
49859: LD_EXP 132
49863: PUSH
49864: LD_VAR 0 2
49868: ARRAY
49869: UNION
49870: PPUSH
49871: LD_INT 33
49873: PUSH
49874: LD_INT 2
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: PPUSH
49881: CALL_OW 72
49885: ST_TO_ADDR
// if tmp then
49886: LD_VAR 0 4
49890: IFFALSE 49982
// for j in tmp do
49892: LD_ADDR_VAR 0 3
49896: PUSH
49897: LD_VAR 0 4
49901: PUSH
49902: FOR_IN
49903: IFFALSE 49980
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49905: LD_VAR 0 3
49909: PPUSH
49910: CALL_OW 312
49914: NOT
49915: PUSH
49916: LD_VAR 0 3
49920: PPUSH
49921: CALL_OW 256
49925: PUSH
49926: LD_INT 250
49928: GREATEREQUAL
49929: AND
49930: IFFALSE 49943
// Connect ( j ) else
49932: LD_VAR 0 3
49936: PPUSH
49937: CALL 75270 0 1
49941: GO 49978
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49943: LD_VAR 0 3
49947: PPUSH
49948: CALL_OW 256
49952: PUSH
49953: LD_INT 250
49955: LESS
49956: PUSH
49957: LD_VAR 0 3
49961: PPUSH
49962: CALL_OW 312
49966: AND
49967: IFFALSE 49978
// ComUnlink ( j ) ;
49969: LD_VAR 0 3
49973: PPUSH
49974: CALL_OW 136
49978: GO 49902
49980: POP
49981: POP
// end ;
49982: GO 49840
49984: POP
49985: POP
// end ;
49986: LD_VAR 0 1
49990: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49991: LD_INT 0
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
// if not mc_bases then
49998: LD_EXP 110
50002: NOT
50003: IFFALSE 50007
// exit ;
50005: GO 50452
// for i = 1 to mc_bases do
50007: LD_ADDR_VAR 0 2
50011: PUSH
50012: DOUBLE
50013: LD_INT 1
50015: DEC
50016: ST_TO_ADDR
50017: LD_EXP 110
50021: PUSH
50022: FOR_TO
50023: IFFALSE 50450
// begin if not mc_produce [ i ] then
50025: LD_EXP 131
50029: PUSH
50030: LD_VAR 0 2
50034: ARRAY
50035: NOT
50036: IFFALSE 50040
// continue ;
50038: GO 50022
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50040: LD_ADDR_VAR 0 5
50044: PUSH
50045: LD_EXP 110
50049: PUSH
50050: LD_VAR 0 2
50054: ARRAY
50055: PPUSH
50056: LD_INT 30
50058: PUSH
50059: LD_INT 3
50061: PUSH
50062: EMPTY
50063: LIST
50064: LIST
50065: PPUSH
50066: CALL_OW 72
50070: ST_TO_ADDR
// if not fac then
50071: LD_VAR 0 5
50075: NOT
50076: IFFALSE 50080
// continue ;
50078: GO 50022
// for j in fac do
50080: LD_ADDR_VAR 0 3
50084: PUSH
50085: LD_VAR 0 5
50089: PUSH
50090: FOR_IN
50091: IFFALSE 50446
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50093: LD_VAR 0 3
50097: PPUSH
50098: CALL_OW 461
50102: PUSH
50103: LD_INT 2
50105: NONEQUAL
50106: PUSH
50107: LD_VAR 0 3
50111: PPUSH
50112: LD_INT 15
50114: PPUSH
50115: CALL 74930 0 2
50119: PUSH
50120: LD_INT 4
50122: ARRAY
50123: OR
50124: IFFALSE 50128
// continue ;
50126: GO 50090
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50128: LD_VAR 0 3
50132: PPUSH
50133: LD_EXP 131
50137: PUSH
50138: LD_VAR 0 2
50142: ARRAY
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PUSH
50148: LD_INT 1
50150: ARRAY
50151: PPUSH
50152: LD_EXP 131
50156: PUSH
50157: LD_VAR 0 2
50161: ARRAY
50162: PUSH
50163: LD_INT 1
50165: ARRAY
50166: PUSH
50167: LD_INT 2
50169: ARRAY
50170: PPUSH
50171: LD_EXP 131
50175: PUSH
50176: LD_VAR 0 2
50180: ARRAY
50181: PUSH
50182: LD_INT 1
50184: ARRAY
50185: PUSH
50186: LD_INT 3
50188: ARRAY
50189: PPUSH
50190: LD_EXP 131
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PUSH
50205: LD_INT 4
50207: ARRAY
50208: PPUSH
50209: CALL_OW 448
50213: PUSH
50214: LD_VAR 0 3
50218: PPUSH
50219: LD_EXP 131
50223: PUSH
50224: LD_VAR 0 2
50228: ARRAY
50229: PUSH
50230: LD_INT 1
50232: ARRAY
50233: PUSH
50234: LD_INT 1
50236: ARRAY
50237: PUSH
50238: LD_EXP 131
50242: PUSH
50243: LD_VAR 0 2
50247: ARRAY
50248: PUSH
50249: LD_INT 1
50251: ARRAY
50252: PUSH
50253: LD_INT 2
50255: ARRAY
50256: PUSH
50257: LD_EXP 131
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: ARRAY
50271: PUSH
50272: LD_INT 3
50274: ARRAY
50275: PUSH
50276: LD_EXP 131
50280: PUSH
50281: LD_VAR 0 2
50285: ARRAY
50286: PUSH
50287: LD_INT 1
50289: ARRAY
50290: PUSH
50291: LD_INT 4
50293: ARRAY
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: PPUSH
50301: CALL 78601 0 2
50305: AND
50306: IFFALSE 50444
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50308: LD_VAR 0 3
50312: PPUSH
50313: LD_EXP 131
50317: PUSH
50318: LD_VAR 0 2
50322: ARRAY
50323: PUSH
50324: LD_INT 1
50326: ARRAY
50327: PUSH
50328: LD_INT 1
50330: ARRAY
50331: PPUSH
50332: LD_EXP 131
50336: PUSH
50337: LD_VAR 0 2
50341: ARRAY
50342: PUSH
50343: LD_INT 1
50345: ARRAY
50346: PUSH
50347: LD_INT 2
50349: ARRAY
50350: PPUSH
50351: LD_EXP 131
50355: PUSH
50356: LD_VAR 0 2
50360: ARRAY
50361: PUSH
50362: LD_INT 1
50364: ARRAY
50365: PUSH
50366: LD_INT 3
50368: ARRAY
50369: PPUSH
50370: LD_EXP 131
50374: PUSH
50375: LD_VAR 0 2
50379: ARRAY
50380: PUSH
50381: LD_INT 1
50383: ARRAY
50384: PUSH
50385: LD_INT 4
50387: ARRAY
50388: PPUSH
50389: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50393: LD_ADDR_VAR 0 4
50397: PUSH
50398: LD_EXP 131
50402: PUSH
50403: LD_VAR 0 2
50407: ARRAY
50408: PPUSH
50409: LD_INT 1
50411: PPUSH
50412: CALL_OW 3
50416: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50417: LD_ADDR_EXP 131
50421: PUSH
50422: LD_EXP 131
50426: PPUSH
50427: LD_VAR 0 2
50431: PPUSH
50432: LD_VAR 0 4
50436: PPUSH
50437: CALL_OW 1
50441: ST_TO_ADDR
// break ;
50442: GO 50446
// end ; end ;
50444: GO 50090
50446: POP
50447: POP
// end ;
50448: GO 50022
50450: POP
50451: POP
// end ;
50452: LD_VAR 0 1
50456: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50457: LD_INT 0
50459: PPUSH
50460: PPUSH
50461: PPUSH
// if not mc_bases then
50462: LD_EXP 110
50466: NOT
50467: IFFALSE 50471
// exit ;
50469: GO 50560
// for i = 1 to mc_bases do
50471: LD_ADDR_VAR 0 2
50475: PUSH
50476: DOUBLE
50477: LD_INT 1
50479: DEC
50480: ST_TO_ADDR
50481: LD_EXP 110
50485: PUSH
50486: FOR_TO
50487: IFFALSE 50558
// begin if mc_attack [ i ] then
50489: LD_EXP 130
50493: PUSH
50494: LD_VAR 0 2
50498: ARRAY
50499: IFFALSE 50556
// begin tmp := mc_attack [ i ] [ 1 ] ;
50501: LD_ADDR_VAR 0 3
50505: PUSH
50506: LD_EXP 130
50510: PUSH
50511: LD_VAR 0 2
50515: ARRAY
50516: PUSH
50517: LD_INT 1
50519: ARRAY
50520: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50521: LD_ADDR_EXP 130
50525: PUSH
50526: LD_EXP 130
50530: PPUSH
50531: LD_VAR 0 2
50535: PPUSH
50536: EMPTY
50537: PPUSH
50538: CALL_OW 1
50542: ST_TO_ADDR
// Attack ( tmp ) ;
50543: LD_VAR 0 3
50547: PPUSH
50548: CALL 100791 0 1
// exit ;
50552: POP
50553: POP
50554: GO 50560
// end ; end ;
50556: GO 50486
50558: POP
50559: POP
// end ;
50560: LD_VAR 0 1
50564: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50565: LD_INT 0
50567: PPUSH
50568: PPUSH
50569: PPUSH
50570: PPUSH
50571: PPUSH
50572: PPUSH
50573: PPUSH
// if not mc_bases then
50574: LD_EXP 110
50578: NOT
50579: IFFALSE 50583
// exit ;
50581: GO 51165
// for i = 1 to mc_bases do
50583: LD_ADDR_VAR 0 2
50587: PUSH
50588: DOUBLE
50589: LD_INT 1
50591: DEC
50592: ST_TO_ADDR
50593: LD_EXP 110
50597: PUSH
50598: FOR_TO
50599: IFFALSE 51163
// begin if not mc_bases [ i ] then
50601: LD_EXP 110
50605: PUSH
50606: LD_VAR 0 2
50610: ARRAY
50611: NOT
50612: IFFALSE 50616
// continue ;
50614: GO 50598
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50616: LD_ADDR_VAR 0 7
50620: PUSH
50621: LD_EXP 110
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PPUSH
50636: CALL 69173 0 1
50640: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50641: LD_ADDR_EXP 133
50645: PUSH
50646: LD_EXP 133
50650: PPUSH
50651: LD_VAR 0 2
50655: PPUSH
50656: LD_EXP 110
50660: PUSH
50661: LD_VAR 0 2
50665: ARRAY
50666: PUSH
50667: LD_INT 1
50669: ARRAY
50670: PPUSH
50671: CALL_OW 255
50675: PPUSH
50676: LD_EXP 135
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: PPUSH
50687: CALL 66727 0 2
50691: PPUSH
50692: CALL_OW 1
50696: ST_TO_ADDR
// if not mc_scan [ i ] then
50697: LD_EXP 133
50701: PUSH
50702: LD_VAR 0 2
50706: ARRAY
50707: NOT
50708: IFFALSE 50863
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50710: LD_ADDR_VAR 0 4
50714: PUSH
50715: LD_EXP 110
50719: PUSH
50720: LD_VAR 0 2
50724: ARRAY
50725: PPUSH
50726: LD_INT 2
50728: PUSH
50729: LD_INT 25
50731: PUSH
50732: LD_INT 5
50734: PUSH
50735: EMPTY
50736: LIST
50737: LIST
50738: PUSH
50739: LD_INT 25
50741: PUSH
50742: LD_INT 8
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PUSH
50749: LD_INT 25
50751: PUSH
50752: LD_INT 9
50754: PUSH
50755: EMPTY
50756: LIST
50757: LIST
50758: PUSH
50759: EMPTY
50760: LIST
50761: LIST
50762: LIST
50763: LIST
50764: PPUSH
50765: CALL_OW 72
50769: ST_TO_ADDR
// if not tmp then
50770: LD_VAR 0 4
50774: NOT
50775: IFFALSE 50779
// continue ;
50777: GO 50598
// for j in tmp do
50779: LD_ADDR_VAR 0 3
50783: PUSH
50784: LD_VAR 0 4
50788: PUSH
50789: FOR_IN
50790: IFFALSE 50861
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50792: LD_VAR 0 3
50796: PPUSH
50797: CALL_OW 310
50801: PPUSH
50802: CALL_OW 266
50806: PUSH
50807: LD_INT 5
50809: EQUAL
50810: PUSH
50811: LD_VAR 0 3
50815: PPUSH
50816: CALL_OW 257
50820: PUSH
50821: LD_INT 1
50823: EQUAL
50824: AND
50825: PUSH
50826: LD_VAR 0 3
50830: PPUSH
50831: CALL_OW 459
50835: NOT
50836: AND
50837: PUSH
50838: LD_VAR 0 7
50842: AND
50843: IFFALSE 50859
// ComChangeProfession ( j , class ) ;
50845: LD_VAR 0 3
50849: PPUSH
50850: LD_VAR 0 7
50854: PPUSH
50855: CALL_OW 123
50859: GO 50789
50861: POP
50862: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50863: LD_EXP 133
50867: PUSH
50868: LD_VAR 0 2
50872: ARRAY
50873: PUSH
50874: LD_EXP 132
50878: PUSH
50879: LD_VAR 0 2
50883: ARRAY
50884: NOT
50885: AND
50886: PUSH
50887: LD_EXP 110
50891: PUSH
50892: LD_VAR 0 2
50896: ARRAY
50897: PPUSH
50898: LD_INT 30
50900: PUSH
50901: LD_INT 32
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PPUSH
50908: CALL_OW 72
50912: NOT
50913: AND
50914: PUSH
50915: LD_EXP 110
50919: PUSH
50920: LD_VAR 0 2
50924: ARRAY
50925: PPUSH
50926: LD_INT 2
50928: PUSH
50929: LD_INT 30
50931: PUSH
50932: LD_INT 4
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 30
50941: PUSH
50942: LD_INT 5
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: LIST
50953: PPUSH
50954: CALL_OW 72
50958: NOT
50959: AND
50960: IFFALSE 51092
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50962: LD_ADDR_VAR 0 4
50966: PUSH
50967: LD_EXP 110
50971: PUSH
50972: LD_VAR 0 2
50976: ARRAY
50977: PPUSH
50978: LD_INT 2
50980: PUSH
50981: LD_INT 25
50983: PUSH
50984: LD_INT 1
50986: PUSH
50987: EMPTY
50988: LIST
50989: LIST
50990: PUSH
50991: LD_INT 25
50993: PUSH
50994: LD_INT 5
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PUSH
51001: LD_INT 25
51003: PUSH
51004: LD_INT 8
51006: PUSH
51007: EMPTY
51008: LIST
51009: LIST
51010: PUSH
51011: LD_INT 25
51013: PUSH
51014: LD_INT 9
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: PPUSH
51028: CALL_OW 72
51032: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51033: LD_ADDR_VAR 0 4
51037: PUSH
51038: LD_VAR 0 4
51042: PUSH
51043: LD_VAR 0 4
51047: PPUSH
51048: LD_INT 18
51050: PPUSH
51051: CALL 105607 0 2
51055: DIFF
51056: ST_TO_ADDR
// if tmp then
51057: LD_VAR 0 4
51061: IFFALSE 51092
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51063: LD_VAR 0 2
51067: PPUSH
51068: LD_VAR 0 4
51072: PPUSH
51073: LD_EXP 135
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PPUSH
51084: CALL 66762 0 3
// exit ;
51088: POP
51089: POP
51090: GO 51165
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51092: LD_EXP 133
51096: PUSH
51097: LD_VAR 0 2
51101: ARRAY
51102: PUSH
51103: LD_EXP 132
51107: PUSH
51108: LD_VAR 0 2
51112: ARRAY
51113: AND
51114: IFFALSE 51161
// begin tmp := mc_defender [ i ] ;
51116: LD_ADDR_VAR 0 4
51120: PUSH
51121: LD_EXP 132
51125: PUSH
51126: LD_VAR 0 2
51130: ARRAY
51131: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51132: LD_VAR 0 2
51136: PPUSH
51137: LD_VAR 0 4
51141: PPUSH
51142: LD_EXP 133
51146: PUSH
51147: LD_VAR 0 2
51151: ARRAY
51152: PPUSH
51153: CALL 67323 0 3
// exit ;
51157: POP
51158: POP
51159: GO 51165
// end ; end ;
51161: GO 50598
51163: POP
51164: POP
// end ;
51165: LD_VAR 0 1
51169: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51170: LD_INT 0
51172: PPUSH
51173: PPUSH
51174: PPUSH
51175: PPUSH
51176: PPUSH
51177: PPUSH
51178: PPUSH
51179: PPUSH
51180: PPUSH
51181: PPUSH
51182: PPUSH
// if not mc_bases then
51183: LD_EXP 110
51187: NOT
51188: IFFALSE 51192
// exit ;
51190: GO 52279
// for i = 1 to mc_bases do
51192: LD_ADDR_VAR 0 2
51196: PUSH
51197: DOUBLE
51198: LD_INT 1
51200: DEC
51201: ST_TO_ADDR
51202: LD_EXP 110
51206: PUSH
51207: FOR_TO
51208: IFFALSE 52277
// begin tmp := mc_lab [ i ] ;
51210: LD_ADDR_VAR 0 6
51214: PUSH
51215: LD_EXP 143
51219: PUSH
51220: LD_VAR 0 2
51224: ARRAY
51225: ST_TO_ADDR
// if not tmp then
51226: LD_VAR 0 6
51230: NOT
51231: IFFALSE 51235
// continue ;
51233: GO 51207
// idle_lab := 0 ;
51235: LD_ADDR_VAR 0 11
51239: PUSH
51240: LD_INT 0
51242: ST_TO_ADDR
// for j in tmp do
51243: LD_ADDR_VAR 0 3
51247: PUSH
51248: LD_VAR 0 6
51252: PUSH
51253: FOR_IN
51254: IFFALSE 52273
// begin researching := false ;
51256: LD_ADDR_VAR 0 10
51260: PUSH
51261: LD_INT 0
51263: ST_TO_ADDR
// side := GetSide ( j ) ;
51264: LD_ADDR_VAR 0 4
51268: PUSH
51269: LD_VAR 0 3
51273: PPUSH
51274: CALL_OW 255
51278: ST_TO_ADDR
// if not mc_tech [ side ] then
51279: LD_EXP 137
51283: PUSH
51284: LD_VAR 0 4
51288: ARRAY
51289: NOT
51290: IFFALSE 51294
// continue ;
51292: GO 51253
// if BuildingStatus ( j ) = bs_idle then
51294: LD_VAR 0 3
51298: PPUSH
51299: CALL_OW 461
51303: PUSH
51304: LD_INT 2
51306: EQUAL
51307: IFFALSE 51495
// begin if idle_lab and UnitsInside ( j ) < 6 then
51309: LD_VAR 0 11
51313: PUSH
51314: LD_VAR 0 3
51318: PPUSH
51319: CALL_OW 313
51323: PUSH
51324: LD_INT 6
51326: LESS
51327: AND
51328: IFFALSE 51399
// begin tmp2 := UnitsInside ( idle_lab ) ;
51330: LD_ADDR_VAR 0 9
51334: PUSH
51335: LD_VAR 0 11
51339: PPUSH
51340: CALL_OW 313
51344: ST_TO_ADDR
// if tmp2 then
51345: LD_VAR 0 9
51349: IFFALSE 51391
// for x in tmp2 do
51351: LD_ADDR_VAR 0 7
51355: PUSH
51356: LD_VAR 0 9
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51389
// begin ComExitBuilding ( x ) ;
51364: LD_VAR 0 7
51368: PPUSH
51369: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51373: LD_VAR 0 7
51377: PPUSH
51378: LD_VAR 0 3
51382: PPUSH
51383: CALL_OW 180
// end ;
51387: GO 51361
51389: POP
51390: POP
// idle_lab := 0 ;
51391: LD_ADDR_VAR 0 11
51395: PUSH
51396: LD_INT 0
51398: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51399: LD_ADDR_VAR 0 5
51403: PUSH
51404: LD_EXP 137
51408: PUSH
51409: LD_VAR 0 4
51413: ARRAY
51414: PUSH
51415: FOR_IN
51416: IFFALSE 51476
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51418: LD_VAR 0 3
51422: PPUSH
51423: LD_VAR 0 5
51427: PPUSH
51428: CALL_OW 430
51432: PUSH
51433: LD_VAR 0 4
51437: PPUSH
51438: LD_VAR 0 5
51442: PPUSH
51443: CALL 65832 0 2
51447: AND
51448: IFFALSE 51474
// begin researching := true ;
51450: LD_ADDR_VAR 0 10
51454: PUSH
51455: LD_INT 1
51457: ST_TO_ADDR
// ComResearch ( j , t ) ;
51458: LD_VAR 0 3
51462: PPUSH
51463: LD_VAR 0 5
51467: PPUSH
51468: CALL_OW 124
// break ;
51472: GO 51476
// end ;
51474: GO 51415
51476: POP
51477: POP
// if not researching then
51478: LD_VAR 0 10
51482: NOT
51483: IFFALSE 51495
// idle_lab := j ;
51485: LD_ADDR_VAR 0 11
51489: PUSH
51490: LD_VAR 0 3
51494: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51495: LD_VAR 0 3
51499: PPUSH
51500: CALL_OW 461
51504: PUSH
51505: LD_INT 10
51507: EQUAL
51508: IFFALSE 52096
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51510: LD_EXP 139
51514: PUSH
51515: LD_VAR 0 2
51519: ARRAY
51520: NOT
51521: PUSH
51522: LD_EXP 140
51526: PUSH
51527: LD_VAR 0 2
51531: ARRAY
51532: NOT
51533: AND
51534: PUSH
51535: LD_EXP 137
51539: PUSH
51540: LD_VAR 0 4
51544: ARRAY
51545: PUSH
51546: LD_INT 1
51548: GREATER
51549: AND
51550: IFFALSE 51681
// begin ComCancel ( j ) ;
51552: LD_VAR 0 3
51556: PPUSH
51557: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51561: LD_ADDR_EXP 137
51565: PUSH
51566: LD_EXP 137
51570: PPUSH
51571: LD_VAR 0 4
51575: PPUSH
51576: LD_EXP 137
51580: PUSH
51581: LD_VAR 0 4
51585: ARRAY
51586: PPUSH
51587: LD_EXP 137
51591: PUSH
51592: LD_VAR 0 4
51596: ARRAY
51597: PUSH
51598: LD_INT 1
51600: MINUS
51601: PPUSH
51602: LD_EXP 137
51606: PUSH
51607: LD_VAR 0 4
51611: ARRAY
51612: PPUSH
51613: LD_INT 0
51615: PPUSH
51616: CALL 71755 0 4
51620: PPUSH
51621: CALL_OW 1
51625: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51626: LD_ADDR_EXP 137
51630: PUSH
51631: LD_EXP 137
51635: PPUSH
51636: LD_VAR 0 4
51640: PPUSH
51641: LD_EXP 137
51645: PUSH
51646: LD_VAR 0 4
51650: ARRAY
51651: PPUSH
51652: LD_EXP 137
51656: PUSH
51657: LD_VAR 0 4
51661: ARRAY
51662: PPUSH
51663: LD_INT 1
51665: PPUSH
51666: LD_INT 0
51668: PPUSH
51669: CALL 71755 0 4
51673: PPUSH
51674: CALL_OW 1
51678: ST_TO_ADDR
// continue ;
51679: GO 51253
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51681: LD_EXP 139
51685: PUSH
51686: LD_VAR 0 2
51690: ARRAY
51691: PUSH
51692: LD_EXP 140
51696: PUSH
51697: LD_VAR 0 2
51701: ARRAY
51702: NOT
51703: AND
51704: IFFALSE 51831
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51706: LD_ADDR_EXP 140
51710: PUSH
51711: LD_EXP 140
51715: PPUSH
51716: LD_VAR 0 2
51720: PUSH
51721: LD_EXP 140
51725: PUSH
51726: LD_VAR 0 2
51730: ARRAY
51731: PUSH
51732: LD_INT 1
51734: PLUS
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: PPUSH
51740: LD_EXP 139
51744: PUSH
51745: LD_VAR 0 2
51749: ARRAY
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL 72337 0 3
51759: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51760: LD_EXP 139
51764: PUSH
51765: LD_VAR 0 2
51769: ARRAY
51770: PUSH
51771: LD_INT 1
51773: ARRAY
51774: PPUSH
51775: LD_INT 112
51777: PPUSH
51778: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51782: LD_ADDR_VAR 0 9
51786: PUSH
51787: LD_EXP 139
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: PPUSH
51798: LD_INT 1
51800: PPUSH
51801: CALL_OW 3
51805: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51806: LD_ADDR_EXP 139
51810: PUSH
51811: LD_EXP 139
51815: PPUSH
51816: LD_VAR 0 2
51820: PPUSH
51821: LD_VAR 0 9
51825: PPUSH
51826: CALL_OW 1
51830: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51831: LD_EXP 139
51835: PUSH
51836: LD_VAR 0 2
51840: ARRAY
51841: PUSH
51842: LD_EXP 140
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: AND
51853: PUSH
51854: LD_EXP 140
51858: PUSH
51859: LD_VAR 0 2
51863: ARRAY
51864: PUSH
51865: LD_INT 1
51867: ARRAY
51868: PPUSH
51869: CALL_OW 310
51873: NOT
51874: AND
51875: PUSH
51876: LD_VAR 0 3
51880: PPUSH
51881: CALL_OW 313
51885: PUSH
51886: LD_INT 6
51888: EQUAL
51889: AND
51890: IFFALSE 51946
// begin tmp2 := UnitsInside ( j ) ;
51892: LD_ADDR_VAR 0 9
51896: PUSH
51897: LD_VAR 0 3
51901: PPUSH
51902: CALL_OW 313
51906: ST_TO_ADDR
// if tmp2 = 6 then
51907: LD_VAR 0 9
51911: PUSH
51912: LD_INT 6
51914: EQUAL
51915: IFFALSE 51946
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51917: LD_VAR 0 9
51921: PUSH
51922: LD_INT 1
51924: ARRAY
51925: PPUSH
51926: LD_INT 112
51928: PPUSH
51929: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51933: LD_VAR 0 9
51937: PUSH
51938: LD_INT 1
51940: ARRAY
51941: PPUSH
51942: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51946: LD_EXP 140
51950: PUSH
51951: LD_VAR 0 2
51955: ARRAY
51956: PUSH
51957: LD_EXP 140
51961: PUSH
51962: LD_VAR 0 2
51966: ARRAY
51967: PUSH
51968: LD_INT 1
51970: ARRAY
51971: PPUSH
51972: CALL_OW 314
51976: NOT
51977: AND
51978: PUSH
51979: LD_EXP 140
51983: PUSH
51984: LD_VAR 0 2
51988: ARRAY
51989: PUSH
51990: LD_INT 1
51992: ARRAY
51993: PPUSH
51994: CALL_OW 310
51998: NOT
51999: AND
52000: IFFALSE 52026
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52002: LD_EXP 140
52006: PUSH
52007: LD_VAR 0 2
52011: ARRAY
52012: PUSH
52013: LD_INT 1
52015: ARRAY
52016: PPUSH
52017: LD_VAR 0 3
52021: PPUSH
52022: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52026: LD_EXP 140
52030: PUSH
52031: LD_VAR 0 2
52035: ARRAY
52036: PUSH
52037: LD_INT 1
52039: ARRAY
52040: PPUSH
52041: CALL_OW 310
52045: PUSH
52046: LD_EXP 140
52050: PUSH
52051: LD_VAR 0 2
52055: ARRAY
52056: PUSH
52057: LD_INT 1
52059: ARRAY
52060: PPUSH
52061: CALL_OW 310
52065: PPUSH
52066: CALL_OW 461
52070: PUSH
52071: LD_INT 3
52073: NONEQUAL
52074: AND
52075: IFFALSE 52096
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52077: LD_EXP 140
52081: PUSH
52082: LD_VAR 0 2
52086: ARRAY
52087: PUSH
52088: LD_INT 1
52090: ARRAY
52091: PPUSH
52092: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52096: LD_VAR 0 3
52100: PPUSH
52101: CALL_OW 461
52105: PUSH
52106: LD_INT 6
52108: EQUAL
52109: PUSH
52110: LD_VAR 0 6
52114: PUSH
52115: LD_INT 1
52117: GREATER
52118: AND
52119: IFFALSE 52271
// begin sci := [ ] ;
52121: LD_ADDR_VAR 0 8
52125: PUSH
52126: EMPTY
52127: ST_TO_ADDR
// for x in ( tmp diff j ) do
52128: LD_ADDR_VAR 0 7
52132: PUSH
52133: LD_VAR 0 6
52137: PUSH
52138: LD_VAR 0 3
52142: DIFF
52143: PUSH
52144: FOR_IN
52145: IFFALSE 52197
// begin if sci = 6 then
52147: LD_VAR 0 8
52151: PUSH
52152: LD_INT 6
52154: EQUAL
52155: IFFALSE 52159
// break ;
52157: GO 52197
// if BuildingStatus ( x ) = bs_idle then
52159: LD_VAR 0 7
52163: PPUSH
52164: CALL_OW 461
52168: PUSH
52169: LD_INT 2
52171: EQUAL
52172: IFFALSE 52195
// sci := sci ^ UnitsInside ( x ) ;
52174: LD_ADDR_VAR 0 8
52178: PUSH
52179: LD_VAR 0 8
52183: PUSH
52184: LD_VAR 0 7
52188: PPUSH
52189: CALL_OW 313
52193: ADD
52194: ST_TO_ADDR
// end ;
52195: GO 52144
52197: POP
52198: POP
// if not sci then
52199: LD_VAR 0 8
52203: NOT
52204: IFFALSE 52208
// continue ;
52206: GO 51253
// for x in sci do
52208: LD_ADDR_VAR 0 7
52212: PUSH
52213: LD_VAR 0 8
52217: PUSH
52218: FOR_IN
52219: IFFALSE 52269
// if IsInUnit ( x ) and not HasTask ( x ) then
52221: LD_VAR 0 7
52225: PPUSH
52226: CALL_OW 310
52230: PUSH
52231: LD_VAR 0 7
52235: PPUSH
52236: CALL_OW 314
52240: NOT
52241: AND
52242: IFFALSE 52267
// begin ComExitBuilding ( x ) ;
52244: LD_VAR 0 7
52248: PPUSH
52249: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52253: LD_VAR 0 7
52257: PPUSH
52258: LD_VAR 0 3
52262: PPUSH
52263: CALL_OW 180
// end ;
52267: GO 52218
52269: POP
52270: POP
// end ; end ;
52271: GO 51253
52273: POP
52274: POP
// end ;
52275: GO 51207
52277: POP
52278: POP
// end ;
52279: LD_VAR 0 1
52283: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52284: LD_INT 0
52286: PPUSH
52287: PPUSH
// if not mc_bases then
52288: LD_EXP 110
52292: NOT
52293: IFFALSE 52297
// exit ;
52295: GO 52378
// for i = 1 to mc_bases do
52297: LD_ADDR_VAR 0 2
52301: PUSH
52302: DOUBLE
52303: LD_INT 1
52305: DEC
52306: ST_TO_ADDR
52307: LD_EXP 110
52311: PUSH
52312: FOR_TO
52313: IFFALSE 52376
// if mc_mines [ i ] and mc_miners [ i ] then
52315: LD_EXP 123
52319: PUSH
52320: LD_VAR 0 2
52324: ARRAY
52325: PUSH
52326: LD_EXP 124
52330: PUSH
52331: LD_VAR 0 2
52335: ARRAY
52336: AND
52337: IFFALSE 52374
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52339: LD_EXP 124
52343: PUSH
52344: LD_VAR 0 2
52348: ARRAY
52349: PUSH
52350: LD_INT 1
52352: ARRAY
52353: PPUSH
52354: CALL_OW 255
52358: PPUSH
52359: LD_EXP 123
52363: PUSH
52364: LD_VAR 0 2
52368: ARRAY
52369: PPUSH
52370: CALL 69326 0 2
52374: GO 52312
52376: POP
52377: POP
// end ;
52378: LD_VAR 0 1
52382: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52383: LD_INT 0
52385: PPUSH
52386: PPUSH
52387: PPUSH
52388: PPUSH
52389: PPUSH
52390: PPUSH
52391: PPUSH
52392: PPUSH
// if not mc_bases or not mc_parking then
52393: LD_EXP 110
52397: NOT
52398: PUSH
52399: LD_EXP 134
52403: NOT
52404: OR
52405: IFFALSE 52409
// exit ;
52407: GO 53108
// for i = 1 to mc_bases do
52409: LD_ADDR_VAR 0 2
52413: PUSH
52414: DOUBLE
52415: LD_INT 1
52417: DEC
52418: ST_TO_ADDR
52419: LD_EXP 110
52423: PUSH
52424: FOR_TO
52425: IFFALSE 53106
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52427: LD_EXP 110
52431: PUSH
52432: LD_VAR 0 2
52436: ARRAY
52437: NOT
52438: PUSH
52439: LD_EXP 134
52443: PUSH
52444: LD_VAR 0 2
52448: ARRAY
52449: NOT
52450: OR
52451: IFFALSE 52455
// continue ;
52453: GO 52424
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52455: LD_ADDR_VAR 0 5
52459: PUSH
52460: LD_EXP 110
52464: PUSH
52465: LD_VAR 0 2
52469: ARRAY
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: PPUSH
52475: CALL_OW 255
52479: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52480: LD_ADDR_VAR 0 6
52484: PUSH
52485: LD_EXP 110
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PPUSH
52496: LD_INT 30
52498: PUSH
52499: LD_INT 3
52501: PUSH
52502: EMPTY
52503: LIST
52504: LIST
52505: PPUSH
52506: CALL_OW 72
52510: ST_TO_ADDR
// if not fac then
52511: LD_VAR 0 6
52515: NOT
52516: IFFALSE 52567
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52518: LD_ADDR_VAR 0 6
52522: PUSH
52523: LD_EXP 110
52527: PUSH
52528: LD_VAR 0 2
52532: ARRAY
52533: PPUSH
52534: LD_INT 2
52536: PUSH
52537: LD_INT 30
52539: PUSH
52540: LD_INT 0
52542: PUSH
52543: EMPTY
52544: LIST
52545: LIST
52546: PUSH
52547: LD_INT 30
52549: PUSH
52550: LD_INT 1
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: PUSH
52557: EMPTY
52558: LIST
52559: LIST
52560: LIST
52561: PPUSH
52562: CALL_OW 72
52566: ST_TO_ADDR
// if not fac then
52567: LD_VAR 0 6
52571: NOT
52572: IFFALSE 52576
// continue ;
52574: GO 52424
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52576: LD_ADDR_VAR 0 7
52580: PUSH
52581: LD_EXP 134
52585: PUSH
52586: LD_VAR 0 2
52590: ARRAY
52591: PPUSH
52592: LD_INT 22
52594: PUSH
52595: LD_VAR 0 5
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: PUSH
52604: LD_INT 21
52606: PUSH
52607: LD_INT 2
52609: PUSH
52610: EMPTY
52611: LIST
52612: LIST
52613: PUSH
52614: LD_INT 3
52616: PUSH
52617: LD_INT 24
52619: PUSH
52620: LD_INT 1000
52622: PUSH
52623: EMPTY
52624: LIST
52625: LIST
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: LIST
52635: PPUSH
52636: CALL_OW 70
52640: ST_TO_ADDR
// for j in fac do
52641: LD_ADDR_VAR 0 3
52645: PUSH
52646: LD_VAR 0 6
52650: PUSH
52651: FOR_IN
52652: IFFALSE 52733
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52654: LD_ADDR_VAR 0 7
52658: PUSH
52659: LD_VAR 0 7
52663: PUSH
52664: LD_INT 22
52666: PUSH
52667: LD_VAR 0 5
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: PUSH
52676: LD_INT 91
52678: PUSH
52679: LD_VAR 0 3
52683: PUSH
52684: LD_INT 15
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: LIST
52691: PUSH
52692: LD_INT 21
52694: PUSH
52695: LD_INT 2
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: PUSH
52702: LD_INT 3
52704: PUSH
52705: LD_INT 24
52707: PUSH
52708: LD_INT 1000
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: PPUSH
52725: CALL_OW 69
52729: UNION
52730: ST_TO_ADDR
52731: GO 52651
52733: POP
52734: POP
// if not vehs then
52735: LD_VAR 0 7
52739: NOT
52740: IFFALSE 52766
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52742: LD_ADDR_EXP 122
52746: PUSH
52747: LD_EXP 122
52751: PPUSH
52752: LD_VAR 0 2
52756: PPUSH
52757: EMPTY
52758: PPUSH
52759: CALL_OW 1
52763: ST_TO_ADDR
// continue ;
52764: GO 52424
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52766: LD_ADDR_VAR 0 8
52770: PUSH
52771: LD_EXP 110
52775: PUSH
52776: LD_VAR 0 2
52780: ARRAY
52781: PPUSH
52782: LD_INT 30
52784: PUSH
52785: LD_INT 3
52787: PUSH
52788: EMPTY
52789: LIST
52790: LIST
52791: PPUSH
52792: CALL_OW 72
52796: ST_TO_ADDR
// if tmp then
52797: LD_VAR 0 8
52801: IFFALSE 52904
// begin for j in tmp do
52803: LD_ADDR_VAR 0 3
52807: PUSH
52808: LD_VAR 0 8
52812: PUSH
52813: FOR_IN
52814: IFFALSE 52902
// for k in UnitsInside ( j ) do
52816: LD_ADDR_VAR 0 4
52820: PUSH
52821: LD_VAR 0 3
52825: PPUSH
52826: CALL_OW 313
52830: PUSH
52831: FOR_IN
52832: IFFALSE 52898
// if k then
52834: LD_VAR 0 4
52838: IFFALSE 52896
// if not k in mc_repair_vehicle [ i ] then
52840: LD_VAR 0 4
52844: PUSH
52845: LD_EXP 122
52849: PUSH
52850: LD_VAR 0 2
52854: ARRAY
52855: IN
52856: NOT
52857: IFFALSE 52896
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52859: LD_ADDR_EXP 122
52863: PUSH
52864: LD_EXP 122
52868: PPUSH
52869: LD_VAR 0 2
52873: PPUSH
52874: LD_EXP 122
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: PUSH
52885: LD_VAR 0 4
52889: UNION
52890: PPUSH
52891: CALL_OW 1
52895: ST_TO_ADDR
52896: GO 52831
52898: POP
52899: POP
52900: GO 52813
52902: POP
52903: POP
// end ; if not mc_repair_vehicle [ i ] then
52904: LD_EXP 122
52908: PUSH
52909: LD_VAR 0 2
52913: ARRAY
52914: NOT
52915: IFFALSE 52919
// continue ;
52917: GO 52424
// for j in mc_repair_vehicle [ i ] do
52919: LD_ADDR_VAR 0 3
52923: PUSH
52924: LD_EXP 122
52928: PUSH
52929: LD_VAR 0 2
52933: ARRAY
52934: PUSH
52935: FOR_IN
52936: IFFALSE 53102
// begin if GetClass ( j ) <> 3 then
52938: LD_VAR 0 3
52942: PPUSH
52943: CALL_OW 257
52947: PUSH
52948: LD_INT 3
52950: NONEQUAL
52951: IFFALSE 52992
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52953: LD_ADDR_EXP 122
52957: PUSH
52958: LD_EXP 122
52962: PPUSH
52963: LD_VAR 0 2
52967: PPUSH
52968: LD_EXP 122
52972: PUSH
52973: LD_VAR 0 2
52977: ARRAY
52978: PUSH
52979: LD_VAR 0 3
52983: DIFF
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// continue ;
52990: GO 52935
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52992: LD_VAR 0 3
52996: PPUSH
52997: CALL_OW 311
53001: NOT
53002: PUSH
53003: LD_VAR 0 3
53007: PUSH
53008: LD_EXP 113
53012: PUSH
53013: LD_VAR 0 2
53017: ARRAY
53018: PUSH
53019: LD_INT 1
53021: ARRAY
53022: IN
53023: NOT
53024: AND
53025: PUSH
53026: LD_VAR 0 3
53030: PUSH
53031: LD_EXP 113
53035: PUSH
53036: LD_VAR 0 2
53040: ARRAY
53041: PUSH
53042: LD_INT 2
53044: ARRAY
53045: IN
53046: NOT
53047: AND
53048: IFFALSE 53100
// begin if IsInUnit ( j ) then
53050: LD_VAR 0 3
53054: PPUSH
53055: CALL_OW 310
53059: IFFALSE 53070
// ComExitBuilding ( j ) ;
53061: LD_VAR 0 3
53065: PPUSH
53066: CALL_OW 122
// if not HasTask ( j ) then
53070: LD_VAR 0 3
53074: PPUSH
53075: CALL_OW 314
53079: NOT
53080: IFFALSE 53100
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53082: LD_VAR 0 3
53086: PPUSH
53087: LD_VAR 0 7
53091: PUSH
53092: LD_INT 1
53094: ARRAY
53095: PPUSH
53096: CALL_OW 189
// end ; end ;
53100: GO 52935
53102: POP
53103: POP
// end ;
53104: GO 52424
53106: POP
53107: POP
// end ;
53108: LD_VAR 0 1
53112: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53113: LD_INT 0
53115: PPUSH
53116: PPUSH
53117: PPUSH
53118: PPUSH
53119: PPUSH
53120: PPUSH
53121: PPUSH
53122: PPUSH
53123: PPUSH
53124: PPUSH
53125: PPUSH
// if not mc_bases then
53126: LD_EXP 110
53130: NOT
53131: IFFALSE 53135
// exit ;
53133: GO 53937
// for i = 1 to mc_bases do
53135: LD_ADDR_VAR 0 2
53139: PUSH
53140: DOUBLE
53141: LD_INT 1
53143: DEC
53144: ST_TO_ADDR
53145: LD_EXP 110
53149: PUSH
53150: FOR_TO
53151: IFFALSE 53935
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53153: LD_EXP 138
53157: PUSH
53158: LD_VAR 0 2
53162: ARRAY
53163: NOT
53164: PUSH
53165: LD_EXP 113
53169: PUSH
53170: LD_VAR 0 2
53174: ARRAY
53175: PUSH
53176: LD_INT 1
53178: ARRAY
53179: OR
53180: PUSH
53181: LD_EXP 113
53185: PUSH
53186: LD_VAR 0 2
53190: ARRAY
53191: PUSH
53192: LD_INT 2
53194: ARRAY
53195: OR
53196: PUSH
53197: LD_EXP 136
53201: PUSH
53202: LD_VAR 0 2
53206: ARRAY
53207: PPUSH
53208: LD_INT 1
53210: PPUSH
53211: CALL_OW 325
53215: NOT
53216: OR
53217: PUSH
53218: LD_EXP 133
53222: PUSH
53223: LD_VAR 0 2
53227: ARRAY
53228: OR
53229: IFFALSE 53233
// continue ;
53231: GO 53150
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53233: LD_ADDR_VAR 0 8
53237: PUSH
53238: LD_EXP 110
53242: PUSH
53243: LD_VAR 0 2
53247: ARRAY
53248: PPUSH
53249: LD_INT 25
53251: PUSH
53252: LD_INT 4
53254: PUSH
53255: EMPTY
53256: LIST
53257: LIST
53258: PUSH
53259: LD_INT 50
53261: PUSH
53262: EMPTY
53263: LIST
53264: PUSH
53265: LD_INT 3
53267: PUSH
53268: LD_INT 60
53270: PUSH
53271: EMPTY
53272: LIST
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: LIST
53282: PPUSH
53283: CALL_OW 72
53287: PUSH
53288: LD_EXP 114
53292: PUSH
53293: LD_VAR 0 2
53297: ARRAY
53298: DIFF
53299: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53300: LD_ADDR_VAR 0 9
53304: PUSH
53305: LD_EXP 110
53309: PUSH
53310: LD_VAR 0 2
53314: ARRAY
53315: PPUSH
53316: LD_INT 2
53318: PUSH
53319: LD_INT 30
53321: PUSH
53322: LD_INT 0
53324: PUSH
53325: EMPTY
53326: LIST
53327: LIST
53328: PUSH
53329: LD_INT 30
53331: PUSH
53332: LD_INT 1
53334: PUSH
53335: EMPTY
53336: LIST
53337: LIST
53338: PUSH
53339: EMPTY
53340: LIST
53341: LIST
53342: LIST
53343: PPUSH
53344: CALL_OW 72
53348: ST_TO_ADDR
// if not tmp or not dep then
53349: LD_VAR 0 8
53353: NOT
53354: PUSH
53355: LD_VAR 0 9
53359: NOT
53360: OR
53361: IFFALSE 53365
// continue ;
53363: GO 53150
// side := GetSide ( tmp [ 1 ] ) ;
53365: LD_ADDR_VAR 0 11
53369: PUSH
53370: LD_VAR 0 8
53374: PUSH
53375: LD_INT 1
53377: ARRAY
53378: PPUSH
53379: CALL_OW 255
53383: ST_TO_ADDR
// dep := dep [ 1 ] ;
53384: LD_ADDR_VAR 0 9
53388: PUSH
53389: LD_VAR 0 9
53393: PUSH
53394: LD_INT 1
53396: ARRAY
53397: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53398: LD_ADDR_VAR 0 7
53402: PUSH
53403: LD_EXP 138
53407: PUSH
53408: LD_VAR 0 2
53412: ARRAY
53413: PPUSH
53414: LD_INT 22
53416: PUSH
53417: LD_INT 0
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: PUSH
53424: LD_INT 25
53426: PUSH
53427: LD_INT 12
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: PPUSH
53438: CALL_OW 70
53442: PUSH
53443: LD_INT 22
53445: PUSH
53446: LD_INT 0
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: LD_INT 25
53455: PUSH
53456: LD_INT 12
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: LD_INT 91
53465: PUSH
53466: LD_VAR 0 9
53470: PUSH
53471: LD_INT 20
53473: PUSH
53474: EMPTY
53475: LIST
53476: LIST
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 69
53488: UNION
53489: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53490: LD_ADDR_VAR 0 10
53494: PUSH
53495: LD_EXP 138
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: PPUSH
53506: LD_INT 81
53508: PUSH
53509: LD_VAR 0 11
53513: PUSH
53514: EMPTY
53515: LIST
53516: LIST
53517: PPUSH
53518: CALL_OW 70
53522: ST_TO_ADDR
// if not apes or danger_at_area then
53523: LD_VAR 0 7
53527: NOT
53528: PUSH
53529: LD_VAR 0 10
53533: OR
53534: IFFALSE 53584
// begin if mc_taming [ i ] then
53536: LD_EXP 141
53540: PUSH
53541: LD_VAR 0 2
53545: ARRAY
53546: IFFALSE 53582
// begin MC_Reset ( i , 121 ) ;
53548: LD_VAR 0 2
53552: PPUSH
53553: LD_INT 121
53555: PPUSH
53556: CALL 39019 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53560: LD_ADDR_EXP 141
53564: PUSH
53565: LD_EXP 141
53569: PPUSH
53570: LD_VAR 0 2
53574: PPUSH
53575: EMPTY
53576: PPUSH
53577: CALL_OW 1
53581: ST_TO_ADDR
// end ; continue ;
53582: GO 53150
// end ; for j in tmp do
53584: LD_ADDR_VAR 0 3
53588: PUSH
53589: LD_VAR 0 8
53593: PUSH
53594: FOR_IN
53595: IFFALSE 53931
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53597: LD_VAR 0 3
53601: PUSH
53602: LD_EXP 141
53606: PUSH
53607: LD_VAR 0 2
53611: ARRAY
53612: IN
53613: NOT
53614: PUSH
53615: LD_EXP 141
53619: PUSH
53620: LD_VAR 0 2
53624: ARRAY
53625: PUSH
53626: LD_INT 3
53628: LESS
53629: AND
53630: IFFALSE 53688
// begin SetTag ( j , 121 ) ;
53632: LD_VAR 0 3
53636: PPUSH
53637: LD_INT 121
53639: PPUSH
53640: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53644: LD_ADDR_EXP 141
53648: PUSH
53649: LD_EXP 141
53653: PPUSH
53654: LD_VAR 0 2
53658: PUSH
53659: LD_EXP 141
53663: PUSH
53664: LD_VAR 0 2
53668: ARRAY
53669: PUSH
53670: LD_INT 1
53672: PLUS
53673: PUSH
53674: EMPTY
53675: LIST
53676: LIST
53677: PPUSH
53678: LD_VAR 0 3
53682: PPUSH
53683: CALL 72337 0 3
53687: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53688: LD_VAR 0 3
53692: PUSH
53693: LD_EXP 141
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: IN
53704: IFFALSE 53929
// begin if GetClass ( j ) <> 4 then
53706: LD_VAR 0 3
53710: PPUSH
53711: CALL_OW 257
53715: PUSH
53716: LD_INT 4
53718: NONEQUAL
53719: IFFALSE 53772
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53721: LD_ADDR_EXP 141
53725: PUSH
53726: LD_EXP 141
53730: PPUSH
53731: LD_VAR 0 2
53735: PPUSH
53736: LD_EXP 141
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: PUSH
53747: LD_VAR 0 3
53751: DIFF
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53758: LD_VAR 0 3
53762: PPUSH
53763: LD_INT 0
53765: PPUSH
53766: CALL_OW 109
// continue ;
53770: GO 53594
// end ; if IsInUnit ( j ) then
53772: LD_VAR 0 3
53776: PPUSH
53777: CALL_OW 310
53781: IFFALSE 53792
// ComExitBuilding ( j ) ;
53783: LD_VAR 0 3
53787: PPUSH
53788: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53792: LD_ADDR_VAR 0 6
53796: PUSH
53797: LD_VAR 0 7
53801: PPUSH
53802: LD_VAR 0 3
53806: PPUSH
53807: CALL_OW 74
53811: ST_TO_ADDR
// if not ape then
53812: LD_VAR 0 6
53816: NOT
53817: IFFALSE 53821
// break ;
53819: GO 53931
// x := GetX ( ape ) ;
53821: LD_ADDR_VAR 0 4
53825: PUSH
53826: LD_VAR 0 6
53830: PPUSH
53831: CALL_OW 250
53835: ST_TO_ADDR
// y := GetY ( ape ) ;
53836: LD_ADDR_VAR 0 5
53840: PUSH
53841: LD_VAR 0 6
53845: PPUSH
53846: CALL_OW 251
53850: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53851: LD_VAR 0 4
53855: PPUSH
53856: LD_VAR 0 5
53860: PPUSH
53861: CALL_OW 488
53865: NOT
53866: PUSH
53867: LD_VAR 0 11
53871: PPUSH
53872: LD_VAR 0 4
53876: PPUSH
53877: LD_VAR 0 5
53881: PPUSH
53882: LD_INT 20
53884: PPUSH
53885: CALL 73233 0 4
53889: PUSH
53890: LD_INT 4
53892: ARRAY
53893: OR
53894: IFFALSE 53898
// break ;
53896: GO 53931
// if not HasTask ( j ) then
53898: LD_VAR 0 3
53902: PPUSH
53903: CALL_OW 314
53907: NOT
53908: IFFALSE 53929
// ComTameXY ( j , x , y ) ;
53910: LD_VAR 0 3
53914: PPUSH
53915: LD_VAR 0 4
53919: PPUSH
53920: LD_VAR 0 5
53924: PPUSH
53925: CALL_OW 131
// end ; end ;
53929: GO 53594
53931: POP
53932: POP
// end ;
53933: GO 53150
53935: POP
53936: POP
// end ;
53937: LD_VAR 0 1
53941: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53942: LD_INT 0
53944: PPUSH
53945: PPUSH
53946: PPUSH
53947: PPUSH
53948: PPUSH
53949: PPUSH
53950: PPUSH
53951: PPUSH
// if not mc_bases then
53952: LD_EXP 110
53956: NOT
53957: IFFALSE 53961
// exit ;
53959: GO 54587
// for i = 1 to mc_bases do
53961: LD_ADDR_VAR 0 2
53965: PUSH
53966: DOUBLE
53967: LD_INT 1
53969: DEC
53970: ST_TO_ADDR
53971: LD_EXP 110
53975: PUSH
53976: FOR_TO
53977: IFFALSE 54585
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53979: LD_EXP 139
53983: PUSH
53984: LD_VAR 0 2
53988: ARRAY
53989: NOT
53990: PUSH
53991: LD_EXP 139
53995: PUSH
53996: LD_VAR 0 2
54000: ARRAY
54001: PPUSH
54002: LD_INT 25
54004: PUSH
54005: LD_INT 12
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: PPUSH
54012: CALL_OW 72
54016: NOT
54017: OR
54018: IFFALSE 54022
// continue ;
54020: GO 53976
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54022: LD_ADDR_VAR 0 5
54026: PUSH
54027: LD_EXP 139
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PUSH
54038: LD_INT 1
54040: ARRAY
54041: PPUSH
54042: CALL_OW 255
54046: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54047: LD_VAR 0 5
54051: PPUSH
54052: LD_INT 2
54054: PPUSH
54055: CALL_OW 325
54059: IFFALSE 54312
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54061: LD_ADDR_VAR 0 4
54065: PUSH
54066: LD_EXP 139
54070: PUSH
54071: LD_VAR 0 2
54075: ARRAY
54076: PPUSH
54077: LD_INT 25
54079: PUSH
54080: LD_INT 16
54082: PUSH
54083: EMPTY
54084: LIST
54085: LIST
54086: PPUSH
54087: CALL_OW 72
54091: ST_TO_ADDR
// if tmp < 6 then
54092: LD_VAR 0 4
54096: PUSH
54097: LD_INT 6
54099: LESS
54100: IFFALSE 54312
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54102: LD_ADDR_VAR 0 6
54106: PUSH
54107: LD_EXP 110
54111: PUSH
54112: LD_VAR 0 2
54116: ARRAY
54117: PPUSH
54118: LD_INT 2
54120: PUSH
54121: LD_INT 30
54123: PUSH
54124: LD_INT 0
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: PUSH
54131: LD_INT 30
54133: PUSH
54134: LD_INT 1
54136: PUSH
54137: EMPTY
54138: LIST
54139: LIST
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: PPUSH
54146: CALL_OW 72
54150: ST_TO_ADDR
// if depot then
54151: LD_VAR 0 6
54155: IFFALSE 54312
// begin selected := 0 ;
54157: LD_ADDR_VAR 0 7
54161: PUSH
54162: LD_INT 0
54164: ST_TO_ADDR
// for j in depot do
54165: LD_ADDR_VAR 0 3
54169: PUSH
54170: LD_VAR 0 6
54174: PUSH
54175: FOR_IN
54176: IFFALSE 54207
// begin if UnitsInside ( j ) < 6 then
54178: LD_VAR 0 3
54182: PPUSH
54183: CALL_OW 313
54187: PUSH
54188: LD_INT 6
54190: LESS
54191: IFFALSE 54205
// begin selected := j ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 3
54202: ST_TO_ADDR
// break ;
54203: GO 54207
// end ; end ;
54205: GO 54175
54207: POP
54208: POP
// if selected then
54209: LD_VAR 0 7
54213: IFFALSE 54312
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54215: LD_ADDR_VAR 0 3
54219: PUSH
54220: LD_EXP 139
54224: PUSH
54225: LD_VAR 0 2
54229: ARRAY
54230: PPUSH
54231: LD_INT 25
54233: PUSH
54234: LD_INT 12
54236: PUSH
54237: EMPTY
54238: LIST
54239: LIST
54240: PPUSH
54241: CALL_OW 72
54245: PUSH
54246: FOR_IN
54247: IFFALSE 54310
// if not HasTask ( j ) then
54249: LD_VAR 0 3
54253: PPUSH
54254: CALL_OW 314
54258: NOT
54259: IFFALSE 54308
// begin if not IsInUnit ( j ) then
54261: LD_VAR 0 3
54265: PPUSH
54266: CALL_OW 310
54270: NOT
54271: IFFALSE 54287
// ComEnterUnit ( j , selected ) ;
54273: LD_VAR 0 3
54277: PPUSH
54278: LD_VAR 0 7
54282: PPUSH
54283: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54287: LD_VAR 0 3
54291: PPUSH
54292: LD_INT 16
54294: PPUSH
54295: CALL_OW 183
// AddComExitBuilding ( j ) ;
54299: LD_VAR 0 3
54303: PPUSH
54304: CALL_OW 182
// end ;
54308: GO 54246
54310: POP
54311: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54312: LD_VAR 0 5
54316: PPUSH
54317: LD_INT 11
54319: PPUSH
54320: CALL_OW 325
54324: IFFALSE 54583
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54326: LD_ADDR_VAR 0 4
54330: PUSH
54331: LD_EXP 139
54335: PUSH
54336: LD_VAR 0 2
54340: ARRAY
54341: PPUSH
54342: LD_INT 25
54344: PUSH
54345: LD_INT 16
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: PPUSH
54352: CALL_OW 72
54356: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54357: LD_VAR 0 4
54361: PUSH
54362: LD_INT 6
54364: GREATEREQUAL
54365: PUSH
54366: LD_VAR 0 5
54370: PPUSH
54371: LD_INT 2
54373: PPUSH
54374: CALL_OW 325
54378: NOT
54379: OR
54380: IFFALSE 54583
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54382: LD_ADDR_VAR 0 8
54386: PUSH
54387: LD_EXP 110
54391: PUSH
54392: LD_VAR 0 2
54396: ARRAY
54397: PPUSH
54398: LD_INT 2
54400: PUSH
54401: LD_INT 30
54403: PUSH
54404: LD_INT 4
54406: PUSH
54407: EMPTY
54408: LIST
54409: LIST
54410: PUSH
54411: LD_INT 30
54413: PUSH
54414: LD_INT 5
54416: PUSH
54417: EMPTY
54418: LIST
54419: LIST
54420: PUSH
54421: EMPTY
54422: LIST
54423: LIST
54424: LIST
54425: PPUSH
54426: CALL_OW 72
54430: ST_TO_ADDR
// if barracks then
54431: LD_VAR 0 8
54435: IFFALSE 54583
// begin selected := 0 ;
54437: LD_ADDR_VAR 0 7
54441: PUSH
54442: LD_INT 0
54444: ST_TO_ADDR
// for j in barracks do
54445: LD_ADDR_VAR 0 3
54449: PUSH
54450: LD_VAR 0 8
54454: PUSH
54455: FOR_IN
54456: IFFALSE 54487
// begin if UnitsInside ( j ) < 6 then
54458: LD_VAR 0 3
54462: PPUSH
54463: CALL_OW 313
54467: PUSH
54468: LD_INT 6
54470: LESS
54471: IFFALSE 54485
// begin selected := j ;
54473: LD_ADDR_VAR 0 7
54477: PUSH
54478: LD_VAR 0 3
54482: ST_TO_ADDR
// break ;
54483: GO 54487
// end ; end ;
54485: GO 54455
54487: POP
54488: POP
// if selected then
54489: LD_VAR 0 7
54493: IFFALSE 54583
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54495: LD_ADDR_VAR 0 3
54499: PUSH
54500: LD_EXP 139
54504: PUSH
54505: LD_VAR 0 2
54509: ARRAY
54510: PPUSH
54511: LD_INT 25
54513: PUSH
54514: LD_INT 12
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PPUSH
54521: CALL_OW 72
54525: PUSH
54526: FOR_IN
54527: IFFALSE 54581
// if not IsInUnit ( j ) and not HasTask ( j ) then
54529: LD_VAR 0 3
54533: PPUSH
54534: CALL_OW 310
54538: NOT
54539: PUSH
54540: LD_VAR 0 3
54544: PPUSH
54545: CALL_OW 314
54549: NOT
54550: AND
54551: IFFALSE 54579
// begin ComEnterUnit ( j , selected ) ;
54553: LD_VAR 0 3
54557: PPUSH
54558: LD_VAR 0 7
54562: PPUSH
54563: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54567: LD_VAR 0 3
54571: PPUSH
54572: LD_INT 15
54574: PPUSH
54575: CALL_OW 183
// end ;
54579: GO 54526
54581: POP
54582: POP
// end ; end ; end ; end ; end ;
54583: GO 53976
54585: POP
54586: POP
// end ;
54587: LD_VAR 0 1
54591: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
// if not mc_bases then
54598: LD_EXP 110
54602: NOT
54603: IFFALSE 54607
// exit ;
54605: GO 54785
// for i = 1 to mc_bases do
54607: LD_ADDR_VAR 0 2
54611: PUSH
54612: DOUBLE
54613: LD_INT 1
54615: DEC
54616: ST_TO_ADDR
54617: LD_EXP 110
54621: PUSH
54622: FOR_TO
54623: IFFALSE 54783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54625: LD_ADDR_VAR 0 4
54629: PUSH
54630: LD_EXP 110
54634: PUSH
54635: LD_VAR 0 2
54639: ARRAY
54640: PPUSH
54641: LD_INT 25
54643: PUSH
54644: LD_INT 9
54646: PUSH
54647: EMPTY
54648: LIST
54649: LIST
54650: PPUSH
54651: CALL_OW 72
54655: ST_TO_ADDR
// if not tmp then
54656: LD_VAR 0 4
54660: NOT
54661: IFFALSE 54665
// continue ;
54663: GO 54622
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54665: LD_EXP 136
54669: PUSH
54670: LD_VAR 0 2
54674: ARRAY
54675: PPUSH
54676: LD_INT 29
54678: PPUSH
54679: CALL_OW 325
54683: NOT
54684: PUSH
54685: LD_EXP 136
54689: PUSH
54690: LD_VAR 0 2
54694: ARRAY
54695: PPUSH
54696: LD_INT 28
54698: PPUSH
54699: CALL_OW 325
54703: NOT
54704: AND
54705: IFFALSE 54709
// continue ;
54707: GO 54622
// for j in tmp do
54709: LD_ADDR_VAR 0 3
54713: PUSH
54714: LD_VAR 0 4
54718: PUSH
54719: FOR_IN
54720: IFFALSE 54779
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54722: LD_VAR 0 3
54726: PUSH
54727: LD_EXP 113
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: PUSH
54738: LD_INT 1
54740: ARRAY
54741: IN
54742: NOT
54743: PUSH
54744: LD_VAR 0 3
54748: PUSH
54749: LD_EXP 113
54753: PUSH
54754: LD_VAR 0 2
54758: ARRAY
54759: PUSH
54760: LD_INT 2
54762: ARRAY
54763: IN
54764: NOT
54765: AND
54766: IFFALSE 54777
// ComSpaceTimeShoot ( j ) ;
54768: LD_VAR 0 3
54772: PPUSH
54773: CALL 65923 0 1
54777: GO 54719
54779: POP
54780: POP
// end ;
54781: GO 54622
54783: POP
54784: POP
// end ;
54785: LD_VAR 0 1
54789: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54790: LD_INT 0
54792: PPUSH
54793: PPUSH
54794: PPUSH
54795: PPUSH
54796: PPUSH
54797: PPUSH
54798: PPUSH
54799: PPUSH
54800: PPUSH
// if not mc_bases then
54801: LD_EXP 110
54805: NOT
54806: IFFALSE 54810
// exit ;
54808: GO 55432
// for i = 1 to mc_bases do
54810: LD_ADDR_VAR 0 2
54814: PUSH
54815: DOUBLE
54816: LD_INT 1
54818: DEC
54819: ST_TO_ADDR
54820: LD_EXP 110
54824: PUSH
54825: FOR_TO
54826: IFFALSE 55430
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54828: LD_EXP 145
54832: PUSH
54833: LD_VAR 0 2
54837: ARRAY
54838: NOT
54839: PUSH
54840: LD_INT 38
54842: PPUSH
54843: LD_EXP 136
54847: PUSH
54848: LD_VAR 0 2
54852: ARRAY
54853: PPUSH
54854: CALL_OW 321
54858: PUSH
54859: LD_INT 2
54861: NONEQUAL
54862: OR
54863: IFFALSE 54867
// continue ;
54865: GO 54825
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54867: LD_ADDR_VAR 0 8
54871: PUSH
54872: LD_EXP 110
54876: PUSH
54877: LD_VAR 0 2
54881: ARRAY
54882: PPUSH
54883: LD_INT 30
54885: PUSH
54886: LD_INT 34
54888: PUSH
54889: EMPTY
54890: LIST
54891: LIST
54892: PPUSH
54893: CALL_OW 72
54897: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54898: LD_ADDR_VAR 0 9
54902: PUSH
54903: LD_EXP 110
54907: PUSH
54908: LD_VAR 0 2
54912: ARRAY
54913: PPUSH
54914: LD_INT 25
54916: PUSH
54917: LD_INT 4
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: PPUSH
54924: CALL_OW 72
54928: PPUSH
54929: LD_INT 0
54931: PPUSH
54932: CALL 105607 0 2
54936: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54937: LD_VAR 0 9
54941: NOT
54942: PUSH
54943: LD_VAR 0 8
54947: NOT
54948: OR
54949: PUSH
54950: LD_EXP 110
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PPUSH
54961: LD_INT 124
54963: PPUSH
54964: CALL 105607 0 2
54968: OR
54969: IFFALSE 54973
// continue ;
54971: GO 54825
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54973: LD_EXP 146
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: LD_EXP 145
54988: PUSH
54989: LD_VAR 0 2
54993: ARRAY
54994: LESS
54995: PUSH
54996: LD_EXP 146
55000: PUSH
55001: LD_VAR 0 2
55005: ARRAY
55006: PUSH
55007: LD_VAR 0 8
55011: LESS
55012: AND
55013: IFFALSE 55428
// begin tmp := sci [ 1 ] ;
55015: LD_ADDR_VAR 0 7
55019: PUSH
55020: LD_VAR 0 9
55024: PUSH
55025: LD_INT 1
55027: ARRAY
55028: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55029: LD_VAR 0 7
55033: PPUSH
55034: LD_INT 124
55036: PPUSH
55037: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55041: LD_ADDR_VAR 0 3
55045: PUSH
55046: DOUBLE
55047: LD_EXP 145
55051: PUSH
55052: LD_VAR 0 2
55056: ARRAY
55057: INC
55058: ST_TO_ADDR
55059: LD_EXP 145
55063: PUSH
55064: LD_VAR 0 2
55068: ARRAY
55069: PUSH
55070: FOR_DOWNTO
55071: IFFALSE 55414
// begin if IsInUnit ( tmp ) then
55073: LD_VAR 0 7
55077: PPUSH
55078: CALL_OW 310
55082: IFFALSE 55093
// ComExitBuilding ( tmp ) ;
55084: LD_VAR 0 7
55088: PPUSH
55089: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55093: LD_INT 35
55095: PPUSH
55096: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55100: LD_VAR 0 7
55104: PPUSH
55105: CALL_OW 310
55109: NOT
55110: PUSH
55111: LD_VAR 0 7
55115: PPUSH
55116: CALL_OW 314
55120: NOT
55121: AND
55122: IFFALSE 55093
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55124: LD_ADDR_VAR 0 6
55128: PUSH
55129: LD_VAR 0 7
55133: PPUSH
55134: CALL_OW 250
55138: PUSH
55139: LD_VAR 0 7
55143: PPUSH
55144: CALL_OW 251
55148: PUSH
55149: EMPTY
55150: LIST
55151: LIST
55152: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55153: LD_INT 35
55155: PPUSH
55156: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55160: LD_ADDR_VAR 0 4
55164: PUSH
55165: LD_EXP 145
55169: PUSH
55170: LD_VAR 0 2
55174: ARRAY
55175: PUSH
55176: LD_VAR 0 3
55180: ARRAY
55181: PUSH
55182: LD_INT 1
55184: ARRAY
55185: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55186: LD_ADDR_VAR 0 5
55190: PUSH
55191: LD_EXP 145
55195: PUSH
55196: LD_VAR 0 2
55200: ARRAY
55201: PUSH
55202: LD_VAR 0 3
55206: ARRAY
55207: PUSH
55208: LD_INT 2
55210: ARRAY
55211: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55212: LD_VAR 0 7
55216: PPUSH
55217: LD_INT 10
55219: PPUSH
55220: CALL 74930 0 2
55224: PUSH
55225: LD_INT 4
55227: ARRAY
55228: IFFALSE 55266
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55230: LD_VAR 0 7
55234: PPUSH
55235: LD_VAR 0 6
55239: PUSH
55240: LD_INT 1
55242: ARRAY
55243: PPUSH
55244: LD_VAR 0 6
55248: PUSH
55249: LD_INT 2
55251: ARRAY
55252: PPUSH
55253: CALL_OW 111
// wait ( 0 0$10 ) ;
55257: LD_INT 350
55259: PPUSH
55260: CALL_OW 67
// end else
55264: GO 55292
// begin ComMoveXY ( tmp , x , y ) ;
55266: LD_VAR 0 7
55270: PPUSH
55271: LD_VAR 0 4
55275: PPUSH
55276: LD_VAR 0 5
55280: PPUSH
55281: CALL_OW 111
// wait ( 0 0$3 ) ;
55285: LD_INT 105
55287: PPUSH
55288: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55292: LD_VAR 0 7
55296: PPUSH
55297: LD_VAR 0 4
55301: PPUSH
55302: LD_VAR 0 5
55306: PPUSH
55307: CALL_OW 307
55311: IFFALSE 55153
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55313: LD_VAR 0 7
55317: PPUSH
55318: LD_VAR 0 4
55322: PPUSH
55323: LD_VAR 0 5
55327: PPUSH
55328: LD_VAR 0 8
55332: PUSH
55333: LD_VAR 0 3
55337: ARRAY
55338: PPUSH
55339: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55343: LD_INT 35
55345: PPUSH
55346: CALL_OW 67
// until not HasTask ( tmp ) ;
55350: LD_VAR 0 7
55354: PPUSH
55355: CALL_OW 314
55359: NOT
55360: IFFALSE 55343
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55362: LD_ADDR_EXP 146
55366: PUSH
55367: LD_EXP 146
55371: PPUSH
55372: LD_VAR 0 2
55376: PUSH
55377: LD_EXP 146
55381: PUSH
55382: LD_VAR 0 2
55386: ARRAY
55387: PUSH
55388: LD_INT 1
55390: PLUS
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PPUSH
55396: LD_VAR 0 8
55400: PUSH
55401: LD_VAR 0 3
55405: ARRAY
55406: PPUSH
55407: CALL 72337 0 3
55411: ST_TO_ADDR
// end ;
55412: GO 55070
55414: POP
55415: POP
// MC_Reset ( i , 124 ) ;
55416: LD_VAR 0 2
55420: PPUSH
55421: LD_INT 124
55423: PPUSH
55424: CALL 39019 0 2
// end ; end ;
55428: GO 54825
55430: POP
55431: POP
// end ;
55432: LD_VAR 0 1
55436: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55437: LD_INT 0
55439: PPUSH
55440: PPUSH
55441: PPUSH
// if not mc_bases then
55442: LD_EXP 110
55446: NOT
55447: IFFALSE 55451
// exit ;
55449: GO 56057
// for i = 1 to mc_bases do
55451: LD_ADDR_VAR 0 2
55455: PUSH
55456: DOUBLE
55457: LD_INT 1
55459: DEC
55460: ST_TO_ADDR
55461: LD_EXP 110
55465: PUSH
55466: FOR_TO
55467: IFFALSE 56055
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55469: LD_ADDR_VAR 0 3
55473: PUSH
55474: LD_EXP 110
55478: PUSH
55479: LD_VAR 0 2
55483: ARRAY
55484: PPUSH
55485: LD_INT 25
55487: PUSH
55488: LD_INT 4
55490: PUSH
55491: EMPTY
55492: LIST
55493: LIST
55494: PPUSH
55495: CALL_OW 72
55499: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55500: LD_VAR 0 3
55504: NOT
55505: PUSH
55506: LD_EXP 147
55510: PUSH
55511: LD_VAR 0 2
55515: ARRAY
55516: NOT
55517: OR
55518: PUSH
55519: LD_EXP 110
55523: PUSH
55524: LD_VAR 0 2
55528: ARRAY
55529: PPUSH
55530: LD_INT 2
55532: PUSH
55533: LD_INT 30
55535: PUSH
55536: LD_INT 0
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: PUSH
55543: LD_INT 30
55545: PUSH
55546: LD_INT 1
55548: PUSH
55549: EMPTY
55550: LIST
55551: LIST
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: PPUSH
55558: CALL_OW 72
55562: NOT
55563: OR
55564: IFFALSE 55614
// begin if mc_deposits_finder [ i ] then
55566: LD_EXP 148
55570: PUSH
55571: LD_VAR 0 2
55575: ARRAY
55576: IFFALSE 55612
// begin MC_Reset ( i , 125 ) ;
55578: LD_VAR 0 2
55582: PPUSH
55583: LD_INT 125
55585: PPUSH
55586: CALL 39019 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55590: LD_ADDR_EXP 148
55594: PUSH
55595: LD_EXP 148
55599: PPUSH
55600: LD_VAR 0 2
55604: PPUSH
55605: EMPTY
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// end ; continue ;
55612: GO 55466
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55614: LD_EXP 147
55618: PUSH
55619: LD_VAR 0 2
55623: ARRAY
55624: PUSH
55625: LD_INT 1
55627: ARRAY
55628: PUSH
55629: LD_INT 3
55631: ARRAY
55632: PUSH
55633: LD_INT 1
55635: EQUAL
55636: PUSH
55637: LD_INT 20
55639: PPUSH
55640: LD_EXP 136
55644: PUSH
55645: LD_VAR 0 2
55649: ARRAY
55650: PPUSH
55651: CALL_OW 321
55655: PUSH
55656: LD_INT 2
55658: NONEQUAL
55659: AND
55660: IFFALSE 55710
// begin if mc_deposits_finder [ i ] then
55662: LD_EXP 148
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: IFFALSE 55708
// begin MC_Reset ( i , 125 ) ;
55674: LD_VAR 0 2
55678: PPUSH
55679: LD_INT 125
55681: PPUSH
55682: CALL 39019 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55686: LD_ADDR_EXP 148
55690: PUSH
55691: LD_EXP 148
55695: PPUSH
55696: LD_VAR 0 2
55700: PPUSH
55701: EMPTY
55702: PPUSH
55703: CALL_OW 1
55707: ST_TO_ADDR
// end ; continue ;
55708: GO 55466
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55710: LD_EXP 147
55714: PUSH
55715: LD_VAR 0 2
55719: ARRAY
55720: PUSH
55721: LD_INT 1
55723: ARRAY
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: PPUSH
55729: LD_EXP 147
55733: PUSH
55734: LD_VAR 0 2
55738: ARRAY
55739: PUSH
55740: LD_INT 1
55742: ARRAY
55743: PUSH
55744: LD_INT 2
55746: ARRAY
55747: PPUSH
55748: LD_EXP 136
55752: PUSH
55753: LD_VAR 0 2
55757: ARRAY
55758: PPUSH
55759: CALL_OW 440
55763: IFFALSE 55806
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55765: LD_ADDR_EXP 147
55769: PUSH
55770: LD_EXP 147
55774: PPUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_EXP 147
55784: PUSH
55785: LD_VAR 0 2
55789: ARRAY
55790: PPUSH
55791: LD_INT 1
55793: PPUSH
55794: CALL_OW 3
55798: PPUSH
55799: CALL_OW 1
55803: ST_TO_ADDR
55804: GO 56053
// begin if not mc_deposits_finder [ i ] then
55806: LD_EXP 148
55810: PUSH
55811: LD_VAR 0 2
55815: ARRAY
55816: NOT
55817: IFFALSE 55869
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55819: LD_ADDR_EXP 148
55823: PUSH
55824: LD_EXP 148
55828: PPUSH
55829: LD_VAR 0 2
55833: PPUSH
55834: LD_VAR 0 3
55838: PUSH
55839: LD_INT 1
55841: ARRAY
55842: PUSH
55843: EMPTY
55844: LIST
55845: PPUSH
55846: CALL_OW 1
55850: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55851: LD_VAR 0 3
55855: PUSH
55856: LD_INT 1
55858: ARRAY
55859: PPUSH
55860: LD_INT 125
55862: PPUSH
55863: CALL_OW 109
// end else
55867: GO 56053
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55869: LD_EXP 148
55873: PUSH
55874: LD_VAR 0 2
55878: ARRAY
55879: PUSH
55880: LD_INT 1
55882: ARRAY
55883: PPUSH
55884: CALL_OW 310
55888: IFFALSE 55911
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55890: LD_EXP 148
55894: PUSH
55895: LD_VAR 0 2
55899: ARRAY
55900: PUSH
55901: LD_INT 1
55903: ARRAY
55904: PPUSH
55905: CALL_OW 122
55909: GO 56053
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55911: LD_EXP 148
55915: PUSH
55916: LD_VAR 0 2
55920: ARRAY
55921: PUSH
55922: LD_INT 1
55924: ARRAY
55925: PPUSH
55926: CALL_OW 314
55930: NOT
55931: PUSH
55932: LD_EXP 148
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: PPUSH
55947: LD_EXP 147
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: PUSH
55958: LD_INT 1
55960: ARRAY
55961: PUSH
55962: LD_INT 1
55964: ARRAY
55965: PPUSH
55966: LD_EXP 147
55970: PUSH
55971: LD_VAR 0 2
55975: ARRAY
55976: PUSH
55977: LD_INT 1
55979: ARRAY
55980: PUSH
55981: LD_INT 2
55983: ARRAY
55984: PPUSH
55985: CALL_OW 297
55989: PUSH
55990: LD_INT 6
55992: GREATER
55993: AND
55994: IFFALSE 56053
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55996: LD_EXP 148
56000: PUSH
56001: LD_VAR 0 2
56005: ARRAY
56006: PUSH
56007: LD_INT 1
56009: ARRAY
56010: PPUSH
56011: LD_EXP 147
56015: PUSH
56016: LD_VAR 0 2
56020: ARRAY
56021: PUSH
56022: LD_INT 1
56024: ARRAY
56025: PUSH
56026: LD_INT 1
56028: ARRAY
56029: PPUSH
56030: LD_EXP 147
56034: PUSH
56035: LD_VAR 0 2
56039: ARRAY
56040: PUSH
56041: LD_INT 1
56043: ARRAY
56044: PUSH
56045: LD_INT 2
56047: ARRAY
56048: PPUSH
56049: CALL_OW 111
// end ; end ; end ;
56053: GO 55466
56055: POP
56056: POP
// end ;
56057: LD_VAR 0 1
56061: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56062: LD_INT 0
56064: PPUSH
56065: PPUSH
56066: PPUSH
56067: PPUSH
56068: PPUSH
56069: PPUSH
56070: PPUSH
56071: PPUSH
56072: PPUSH
56073: PPUSH
56074: PPUSH
// if not mc_bases then
56075: LD_EXP 110
56079: NOT
56080: IFFALSE 56084
// exit ;
56082: GO 57024
// for i = 1 to mc_bases do
56084: LD_ADDR_VAR 0 2
56088: PUSH
56089: DOUBLE
56090: LD_INT 1
56092: DEC
56093: ST_TO_ADDR
56094: LD_EXP 110
56098: PUSH
56099: FOR_TO
56100: IFFALSE 57022
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56102: LD_EXP 110
56106: PUSH
56107: LD_VAR 0 2
56111: ARRAY
56112: NOT
56113: PUSH
56114: LD_EXP 133
56118: PUSH
56119: LD_VAR 0 2
56123: ARRAY
56124: OR
56125: IFFALSE 56129
// continue ;
56127: GO 56099
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56129: LD_ADDR_VAR 0 7
56133: PUSH
56134: LD_EXP 110
56138: PUSH
56139: LD_VAR 0 2
56143: ARRAY
56144: PUSH
56145: LD_INT 1
56147: ARRAY
56148: PPUSH
56149: CALL_OW 248
56153: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56154: LD_VAR 0 7
56158: PUSH
56159: LD_INT 3
56161: EQUAL
56162: PUSH
56163: LD_EXP 129
56167: PUSH
56168: LD_VAR 0 2
56172: ARRAY
56173: PUSH
56174: LD_EXP 132
56178: PUSH
56179: LD_VAR 0 2
56183: ARRAY
56184: UNION
56185: PPUSH
56186: LD_INT 33
56188: PUSH
56189: LD_INT 2
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: PPUSH
56196: CALL_OW 72
56200: NOT
56201: OR
56202: IFFALSE 56206
// continue ;
56204: GO 56099
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56206: LD_ADDR_VAR 0 9
56210: PUSH
56211: LD_EXP 110
56215: PUSH
56216: LD_VAR 0 2
56220: ARRAY
56221: PPUSH
56222: LD_INT 30
56224: PUSH
56225: LD_INT 36
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PPUSH
56232: CALL_OW 72
56236: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56237: LD_ADDR_VAR 0 10
56241: PUSH
56242: LD_EXP 129
56246: PUSH
56247: LD_VAR 0 2
56251: ARRAY
56252: PPUSH
56253: LD_INT 34
56255: PUSH
56256: LD_INT 31
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PPUSH
56263: CALL_OW 72
56267: ST_TO_ADDR
// if not cts and not mcts then
56268: LD_VAR 0 9
56272: NOT
56273: PUSH
56274: LD_VAR 0 10
56278: NOT
56279: AND
56280: IFFALSE 56284
// continue ;
56282: GO 56099
// x := cts ;
56284: LD_ADDR_VAR 0 11
56288: PUSH
56289: LD_VAR 0 9
56293: ST_TO_ADDR
// if not x then
56294: LD_VAR 0 11
56298: NOT
56299: IFFALSE 56311
// x := mcts ;
56301: LD_ADDR_VAR 0 11
56305: PUSH
56306: LD_VAR 0 10
56310: ST_TO_ADDR
// if not x then
56311: LD_VAR 0 11
56315: NOT
56316: IFFALSE 56320
// continue ;
56318: GO 56099
// if mc_remote_driver [ i ] then
56320: LD_EXP 150
56324: PUSH
56325: LD_VAR 0 2
56329: ARRAY
56330: IFFALSE 56717
// for j in mc_remote_driver [ i ] do
56332: LD_ADDR_VAR 0 3
56336: PUSH
56337: LD_EXP 150
56341: PUSH
56342: LD_VAR 0 2
56346: ARRAY
56347: PUSH
56348: FOR_IN
56349: IFFALSE 56715
// begin if GetClass ( j ) <> 3 then
56351: LD_VAR 0 3
56355: PPUSH
56356: CALL_OW 257
56360: PUSH
56361: LD_INT 3
56363: NONEQUAL
56364: IFFALSE 56417
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56366: LD_ADDR_EXP 150
56370: PUSH
56371: LD_EXP 150
56375: PPUSH
56376: LD_VAR 0 2
56380: PPUSH
56381: LD_EXP 150
56385: PUSH
56386: LD_VAR 0 2
56390: ARRAY
56391: PUSH
56392: LD_VAR 0 3
56396: DIFF
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56403: LD_VAR 0 3
56407: PPUSH
56408: LD_INT 0
56410: PPUSH
56411: CALL_OW 109
// continue ;
56415: GO 56348
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56417: LD_EXP 129
56421: PUSH
56422: LD_VAR 0 2
56426: ARRAY
56427: PPUSH
56428: LD_INT 34
56430: PUSH
56431: LD_INT 31
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PUSH
56438: LD_INT 58
56440: PUSH
56441: EMPTY
56442: LIST
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PPUSH
56448: CALL_OW 72
56452: PUSH
56453: LD_VAR 0 3
56457: PPUSH
56458: CALL 105695 0 1
56462: NOT
56463: AND
56464: IFFALSE 56535
// begin if IsInUnit ( j ) then
56466: LD_VAR 0 3
56470: PPUSH
56471: CALL_OW 310
56475: IFFALSE 56486
// ComExitBuilding ( j ) ;
56477: LD_VAR 0 3
56481: PPUSH
56482: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56486: LD_VAR 0 3
56490: PPUSH
56491: LD_EXP 129
56495: PUSH
56496: LD_VAR 0 2
56500: ARRAY
56501: PPUSH
56502: LD_INT 34
56504: PUSH
56505: LD_INT 31
56507: PUSH
56508: EMPTY
56509: LIST
56510: LIST
56511: PUSH
56512: LD_INT 58
56514: PUSH
56515: EMPTY
56516: LIST
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: PUSH
56527: LD_INT 1
56529: ARRAY
56530: PPUSH
56531: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56535: LD_VAR 0 3
56539: PPUSH
56540: CALL_OW 310
56544: NOT
56545: PUSH
56546: LD_VAR 0 3
56550: PPUSH
56551: CALL_OW 310
56555: PPUSH
56556: CALL_OW 266
56560: PUSH
56561: LD_INT 36
56563: NONEQUAL
56564: PUSH
56565: LD_VAR 0 3
56569: PPUSH
56570: CALL 105695 0 1
56574: NOT
56575: AND
56576: OR
56577: IFFALSE 56713
// begin if IsInUnit ( j ) then
56579: LD_VAR 0 3
56583: PPUSH
56584: CALL_OW 310
56588: IFFALSE 56599
// ComExitBuilding ( j ) ;
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 122
// ct := 0 ;
56599: LD_ADDR_VAR 0 8
56603: PUSH
56604: LD_INT 0
56606: ST_TO_ADDR
// for k in x do
56607: LD_ADDR_VAR 0 4
56611: PUSH
56612: LD_VAR 0 11
56616: PUSH
56617: FOR_IN
56618: IFFALSE 56691
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56620: LD_VAR 0 4
56624: PPUSH
56625: CALL_OW 264
56629: PUSH
56630: LD_INT 31
56632: EQUAL
56633: PUSH
56634: LD_VAR 0 4
56638: PPUSH
56639: CALL_OW 311
56643: NOT
56644: AND
56645: PUSH
56646: LD_VAR 0 4
56650: PPUSH
56651: CALL_OW 266
56655: PUSH
56656: LD_INT 36
56658: EQUAL
56659: PUSH
56660: LD_VAR 0 4
56664: PPUSH
56665: CALL_OW 313
56669: PUSH
56670: LD_INT 3
56672: LESS
56673: AND
56674: OR
56675: IFFALSE 56689
// begin ct := k ;
56677: LD_ADDR_VAR 0 8
56681: PUSH
56682: LD_VAR 0 4
56686: ST_TO_ADDR
// break ;
56687: GO 56691
// end ;
56689: GO 56617
56691: POP
56692: POP
// if ct then
56693: LD_VAR 0 8
56697: IFFALSE 56713
// ComEnterUnit ( j , ct ) ;
56699: LD_VAR 0 3
56703: PPUSH
56704: LD_VAR 0 8
56708: PPUSH
56709: CALL_OW 120
// end ; end ;
56713: GO 56348
56715: POP
56716: POP
// places := 0 ;
56717: LD_ADDR_VAR 0 5
56721: PUSH
56722: LD_INT 0
56724: ST_TO_ADDR
// for j = 1 to x do
56725: LD_ADDR_VAR 0 3
56729: PUSH
56730: DOUBLE
56731: LD_INT 1
56733: DEC
56734: ST_TO_ADDR
56735: LD_VAR 0 11
56739: PUSH
56740: FOR_TO
56741: IFFALSE 56817
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56743: LD_VAR 0 11
56747: PUSH
56748: LD_VAR 0 3
56752: ARRAY
56753: PPUSH
56754: CALL_OW 264
56758: PUSH
56759: LD_INT 31
56761: EQUAL
56762: IFFALSE 56780
// places := places + 1 else
56764: LD_ADDR_VAR 0 5
56768: PUSH
56769: LD_VAR 0 5
56773: PUSH
56774: LD_INT 1
56776: PLUS
56777: ST_TO_ADDR
56778: GO 56815
// if GetBType ( x [ j ] ) = b_control_tower then
56780: LD_VAR 0 11
56784: PUSH
56785: LD_VAR 0 3
56789: ARRAY
56790: PPUSH
56791: CALL_OW 266
56795: PUSH
56796: LD_INT 36
56798: EQUAL
56799: IFFALSE 56815
// places := places + 3 ;
56801: LD_ADDR_VAR 0 5
56805: PUSH
56806: LD_VAR 0 5
56810: PUSH
56811: LD_INT 3
56813: PLUS
56814: ST_TO_ADDR
56815: GO 56740
56817: POP
56818: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56819: LD_VAR 0 5
56823: PUSH
56824: LD_INT 0
56826: EQUAL
56827: PUSH
56828: LD_VAR 0 5
56832: PUSH
56833: LD_EXP 150
56837: PUSH
56838: LD_VAR 0 2
56842: ARRAY
56843: LESSEQUAL
56844: OR
56845: IFFALSE 56849
// continue ;
56847: GO 56099
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56849: LD_ADDR_VAR 0 6
56853: PUSH
56854: LD_EXP 110
56858: PUSH
56859: LD_VAR 0 2
56863: ARRAY
56864: PPUSH
56865: LD_INT 25
56867: PUSH
56868: LD_INT 3
56870: PUSH
56871: EMPTY
56872: LIST
56873: LIST
56874: PPUSH
56875: CALL_OW 72
56879: PUSH
56880: LD_EXP 150
56884: PUSH
56885: LD_VAR 0 2
56889: ARRAY
56890: DIFF
56891: PPUSH
56892: LD_INT 3
56894: PPUSH
56895: CALL 106595 0 2
56899: ST_TO_ADDR
// for j in tmp do
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: LD_VAR 0 6
56909: PUSH
56910: FOR_IN
56911: IFFALSE 56946
// if GetTag ( j ) > 0 then
56913: LD_VAR 0 3
56917: PPUSH
56918: CALL_OW 110
56922: PUSH
56923: LD_INT 0
56925: GREATER
56926: IFFALSE 56944
// tmp := tmp diff j ;
56928: LD_ADDR_VAR 0 6
56932: PUSH
56933: LD_VAR 0 6
56937: PUSH
56938: LD_VAR 0 3
56942: DIFF
56943: ST_TO_ADDR
56944: GO 56910
56946: POP
56947: POP
// if not tmp then
56948: LD_VAR 0 6
56952: NOT
56953: IFFALSE 56957
// continue ;
56955: GO 56099
// if places then
56957: LD_VAR 0 5
56961: IFFALSE 57020
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56963: LD_ADDR_EXP 150
56967: PUSH
56968: LD_EXP 150
56972: PPUSH
56973: LD_VAR 0 2
56977: PPUSH
56978: LD_EXP 150
56982: PUSH
56983: LD_VAR 0 2
56987: ARRAY
56988: PUSH
56989: LD_VAR 0 6
56993: PUSH
56994: LD_INT 1
56996: ARRAY
56997: UNION
56998: PPUSH
56999: CALL_OW 1
57003: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57004: LD_VAR 0 6
57008: PUSH
57009: LD_INT 1
57011: ARRAY
57012: PPUSH
57013: LD_INT 126
57015: PPUSH
57016: CALL_OW 109
// end ; end ;
57020: GO 56099
57022: POP
57023: POP
// end ;
57024: LD_VAR 0 1
57028: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57029: LD_INT 0
57031: PPUSH
57032: PPUSH
57033: PPUSH
57034: PPUSH
57035: PPUSH
57036: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57037: LD_VAR 0 1
57041: NOT
57042: PUSH
57043: LD_VAR 0 2
57047: NOT
57048: OR
57049: PUSH
57050: LD_VAR 0 3
57054: NOT
57055: OR
57056: PUSH
57057: LD_VAR 0 4
57061: PUSH
57062: LD_INT 1
57064: PUSH
57065: LD_INT 2
57067: PUSH
57068: LD_INT 3
57070: PUSH
57071: LD_INT 4
57073: PUSH
57074: LD_INT 5
57076: PUSH
57077: LD_INT 8
57079: PUSH
57080: LD_INT 9
57082: PUSH
57083: LD_INT 15
57085: PUSH
57086: LD_INT 16
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: LIST
57093: LIST
57094: LIST
57095: LIST
57096: LIST
57097: LIST
57098: LIST
57099: IN
57100: NOT
57101: OR
57102: IFFALSE 57106
// exit ;
57104: GO 58006
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57106: LD_ADDR_VAR 0 2
57110: PUSH
57111: LD_VAR 0 2
57115: PPUSH
57116: LD_INT 21
57118: PUSH
57119: LD_INT 3
57121: PUSH
57122: EMPTY
57123: LIST
57124: LIST
57125: PUSH
57126: LD_INT 24
57128: PUSH
57129: LD_INT 250
57131: PUSH
57132: EMPTY
57133: LIST
57134: LIST
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PPUSH
57140: CALL_OW 72
57144: ST_TO_ADDR
// case class of 1 , 15 :
57145: LD_VAR 0 4
57149: PUSH
57150: LD_INT 1
57152: DOUBLE
57153: EQUAL
57154: IFTRUE 57164
57156: LD_INT 15
57158: DOUBLE
57159: EQUAL
57160: IFTRUE 57164
57162: GO 57249
57164: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57165: LD_ADDR_VAR 0 8
57169: PUSH
57170: LD_VAR 0 2
57174: PPUSH
57175: LD_INT 2
57177: PUSH
57178: LD_INT 30
57180: PUSH
57181: LD_INT 32
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 31
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: EMPTY
57199: LIST
57200: LIST
57201: LIST
57202: PPUSH
57203: CALL_OW 72
57207: PUSH
57208: LD_VAR 0 2
57212: PPUSH
57213: LD_INT 2
57215: PUSH
57216: LD_INT 30
57218: PUSH
57219: LD_INT 4
57221: PUSH
57222: EMPTY
57223: LIST
57224: LIST
57225: PUSH
57226: LD_INT 30
57228: PUSH
57229: LD_INT 5
57231: PUSH
57232: EMPTY
57233: LIST
57234: LIST
57235: PUSH
57236: EMPTY
57237: LIST
57238: LIST
57239: LIST
57240: PPUSH
57241: CALL_OW 72
57245: ADD
57246: ST_TO_ADDR
57247: GO 57495
57249: LD_INT 2
57251: DOUBLE
57252: EQUAL
57253: IFTRUE 57263
57255: LD_INT 16
57257: DOUBLE
57258: EQUAL
57259: IFTRUE 57263
57261: GO 57309
57263: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57264: LD_ADDR_VAR 0 8
57268: PUSH
57269: LD_VAR 0 2
57273: PPUSH
57274: LD_INT 2
57276: PUSH
57277: LD_INT 30
57279: PUSH
57280: LD_INT 0
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: PUSH
57287: LD_INT 30
57289: PUSH
57290: LD_INT 1
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: LIST
57301: PPUSH
57302: CALL_OW 72
57306: ST_TO_ADDR
57307: GO 57495
57309: LD_INT 3
57311: DOUBLE
57312: EQUAL
57313: IFTRUE 57317
57315: GO 57363
57317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57318: LD_ADDR_VAR 0 8
57322: PUSH
57323: LD_VAR 0 2
57327: PPUSH
57328: LD_INT 2
57330: PUSH
57331: LD_INT 30
57333: PUSH
57334: LD_INT 2
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: LD_INT 30
57343: PUSH
57344: LD_INT 3
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: LIST
57355: PPUSH
57356: CALL_OW 72
57360: ST_TO_ADDR
57361: GO 57495
57363: LD_INT 4
57365: DOUBLE
57366: EQUAL
57367: IFTRUE 57371
57369: GO 57428
57371: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57372: LD_ADDR_VAR 0 8
57376: PUSH
57377: LD_VAR 0 2
57381: PPUSH
57382: LD_INT 2
57384: PUSH
57385: LD_INT 30
57387: PUSH
57388: LD_INT 6
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 7
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PUSH
57405: LD_INT 30
57407: PUSH
57408: LD_INT 8
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 72
57425: ST_TO_ADDR
57426: GO 57495
57428: LD_INT 5
57430: DOUBLE
57431: EQUAL
57432: IFTRUE 57448
57434: LD_INT 8
57436: DOUBLE
57437: EQUAL
57438: IFTRUE 57448
57440: LD_INT 9
57442: DOUBLE
57443: EQUAL
57444: IFTRUE 57448
57446: GO 57494
57448: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57449: LD_ADDR_VAR 0 8
57453: PUSH
57454: LD_VAR 0 2
57458: PPUSH
57459: LD_INT 2
57461: PUSH
57462: LD_INT 30
57464: PUSH
57465: LD_INT 4
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: PUSH
57472: LD_INT 30
57474: PUSH
57475: LD_INT 5
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: LIST
57486: PPUSH
57487: CALL_OW 72
57491: ST_TO_ADDR
57492: GO 57495
57494: POP
// if not tmp then
57495: LD_VAR 0 8
57499: NOT
57500: IFFALSE 57504
// exit ;
57502: GO 58006
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57504: LD_VAR 0 4
57508: PUSH
57509: LD_INT 1
57511: PUSH
57512: LD_INT 15
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: IN
57519: PUSH
57520: LD_EXP 119
57524: PUSH
57525: LD_VAR 0 1
57529: ARRAY
57530: AND
57531: IFFALSE 57687
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57533: LD_ADDR_VAR 0 9
57537: PUSH
57538: LD_EXP 119
57542: PUSH
57543: LD_VAR 0 1
57547: ARRAY
57548: PUSH
57549: LD_INT 1
57551: ARRAY
57552: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57553: LD_VAR 0 9
57557: PUSH
57558: LD_EXP 120
57562: PUSH
57563: LD_VAR 0 1
57567: ARRAY
57568: IN
57569: NOT
57570: IFFALSE 57685
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57572: LD_ADDR_EXP 120
57576: PUSH
57577: LD_EXP 120
57581: PPUSH
57582: LD_VAR 0 1
57586: PUSH
57587: LD_EXP 120
57591: PUSH
57592: LD_VAR 0 1
57596: ARRAY
57597: PUSH
57598: LD_INT 1
57600: PLUS
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PPUSH
57606: LD_VAR 0 9
57610: PPUSH
57611: CALL 72337 0 3
57615: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57616: LD_ADDR_EXP 119
57620: PUSH
57621: LD_EXP 119
57625: PPUSH
57626: LD_VAR 0 1
57630: PPUSH
57631: LD_EXP 119
57635: PUSH
57636: LD_VAR 0 1
57640: ARRAY
57641: PUSH
57642: LD_VAR 0 9
57646: DIFF
57647: PPUSH
57648: CALL_OW 1
57652: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57653: LD_VAR 0 3
57657: PPUSH
57658: LD_EXP 120
57662: PUSH
57663: LD_VAR 0 1
57667: ARRAY
57668: PUSH
57669: LD_EXP 120
57673: PUSH
57674: LD_VAR 0 1
57678: ARRAY
57679: ARRAY
57680: PPUSH
57681: CALL_OW 120
// end ; exit ;
57685: GO 58006
// end ; if tmp > 1 then
57687: LD_VAR 0 8
57691: PUSH
57692: LD_INT 1
57694: GREATER
57695: IFFALSE 57799
// for i = 2 to tmp do
57697: LD_ADDR_VAR 0 6
57701: PUSH
57702: DOUBLE
57703: LD_INT 2
57705: DEC
57706: ST_TO_ADDR
57707: LD_VAR 0 8
57711: PUSH
57712: FOR_TO
57713: IFFALSE 57797
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57715: LD_VAR 0 8
57719: PUSH
57720: LD_VAR 0 6
57724: ARRAY
57725: PPUSH
57726: CALL_OW 461
57730: PUSH
57731: LD_INT 6
57733: EQUAL
57734: IFFALSE 57795
// begin x := tmp [ i ] ;
57736: LD_ADDR_VAR 0 9
57740: PUSH
57741: LD_VAR 0 8
57745: PUSH
57746: LD_VAR 0 6
57750: ARRAY
57751: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57752: LD_ADDR_VAR 0 8
57756: PUSH
57757: LD_VAR 0 8
57761: PPUSH
57762: LD_VAR 0 6
57766: PPUSH
57767: CALL_OW 3
57771: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57772: LD_ADDR_VAR 0 8
57776: PUSH
57777: LD_VAR 0 8
57781: PPUSH
57782: LD_INT 1
57784: PPUSH
57785: LD_VAR 0 9
57789: PPUSH
57790: CALL_OW 2
57794: ST_TO_ADDR
// end ;
57795: GO 57712
57797: POP
57798: POP
// for i in tmp do
57799: LD_ADDR_VAR 0 6
57803: PUSH
57804: LD_VAR 0 8
57808: PUSH
57809: FOR_IN
57810: IFFALSE 57879
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57812: LD_VAR 0 6
57816: PPUSH
57817: CALL_OW 313
57821: PUSH
57822: LD_INT 6
57824: LESS
57825: PUSH
57826: LD_VAR 0 6
57830: PPUSH
57831: CALL_OW 266
57835: PUSH
57836: LD_INT 31
57838: PUSH
57839: LD_INT 32
57841: PUSH
57842: EMPTY
57843: LIST
57844: LIST
57845: IN
57846: NOT
57847: AND
57848: PUSH
57849: LD_VAR 0 6
57853: PPUSH
57854: CALL_OW 313
57858: PUSH
57859: LD_INT 0
57861: EQUAL
57862: OR
57863: IFFALSE 57877
// begin j := i ;
57865: LD_ADDR_VAR 0 7
57869: PUSH
57870: LD_VAR 0 6
57874: ST_TO_ADDR
// break ;
57875: GO 57879
// end ; end ;
57877: GO 57809
57879: POP
57880: POP
// if j then
57881: LD_VAR 0 7
57885: IFFALSE 57903
// ComEnterUnit ( unit , j ) else
57887: LD_VAR 0 3
57891: PPUSH
57892: LD_VAR 0 7
57896: PPUSH
57897: CALL_OW 120
57901: GO 58006
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57903: LD_ADDR_VAR 0 10
57907: PUSH
57908: LD_VAR 0 2
57912: PPUSH
57913: LD_INT 2
57915: PUSH
57916: LD_INT 30
57918: PUSH
57919: LD_INT 0
57921: PUSH
57922: EMPTY
57923: LIST
57924: LIST
57925: PUSH
57926: LD_INT 30
57928: PUSH
57929: LD_INT 1
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: LIST
57940: PPUSH
57941: CALL_OW 72
57945: ST_TO_ADDR
// if depot then
57946: LD_VAR 0 10
57950: IFFALSE 58006
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57952: LD_ADDR_VAR 0 10
57956: PUSH
57957: LD_VAR 0 10
57961: PPUSH
57962: LD_VAR 0 3
57966: PPUSH
57967: CALL_OW 74
57971: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57972: LD_VAR 0 3
57976: PPUSH
57977: LD_VAR 0 10
57981: PPUSH
57982: CALL_OW 296
57986: PUSH
57987: LD_INT 10
57989: GREATER
57990: IFFALSE 58006
// ComStandNearbyBuilding ( unit , depot ) ;
57992: LD_VAR 0 3
57996: PPUSH
57997: LD_VAR 0 10
58001: PPUSH
58002: CALL 66540 0 2
// end ; end ; end ;
58006: LD_VAR 0 5
58010: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58011: LD_INT 0
58013: PPUSH
58014: PPUSH
58015: PPUSH
58016: PPUSH
// if not mc_bases then
58017: LD_EXP 110
58021: NOT
58022: IFFALSE 58026
// exit ;
58024: GO 58265
// for i = 1 to mc_bases do
58026: LD_ADDR_VAR 0 2
58030: PUSH
58031: DOUBLE
58032: LD_INT 1
58034: DEC
58035: ST_TO_ADDR
58036: LD_EXP 110
58040: PUSH
58041: FOR_TO
58042: IFFALSE 58263
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58044: LD_ADDR_VAR 0 4
58048: PUSH
58049: LD_EXP 110
58053: PUSH
58054: LD_VAR 0 2
58058: ARRAY
58059: PPUSH
58060: LD_INT 21
58062: PUSH
58063: LD_INT 1
58065: PUSH
58066: EMPTY
58067: LIST
58068: LIST
58069: PPUSH
58070: CALL_OW 72
58074: PUSH
58075: LD_EXP 139
58079: PUSH
58080: LD_VAR 0 2
58084: ARRAY
58085: UNION
58086: ST_TO_ADDR
// if not tmp then
58087: LD_VAR 0 4
58091: NOT
58092: IFFALSE 58096
// continue ;
58094: GO 58041
// for j in tmp do
58096: LD_ADDR_VAR 0 3
58100: PUSH
58101: LD_VAR 0 4
58105: PUSH
58106: FOR_IN
58107: IFFALSE 58259
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58109: LD_VAR 0 3
58113: PPUSH
58114: CALL_OW 110
58118: NOT
58119: PUSH
58120: LD_VAR 0 3
58124: PPUSH
58125: CALL_OW 314
58129: NOT
58130: AND
58131: PUSH
58132: LD_VAR 0 3
58136: PPUSH
58137: CALL_OW 311
58141: NOT
58142: AND
58143: PUSH
58144: LD_VAR 0 3
58148: PPUSH
58149: CALL_OW 310
58153: NOT
58154: AND
58155: PUSH
58156: LD_VAR 0 3
58160: PUSH
58161: LD_EXP 113
58165: PUSH
58166: LD_VAR 0 2
58170: ARRAY
58171: PUSH
58172: LD_INT 1
58174: ARRAY
58175: IN
58176: NOT
58177: AND
58178: PUSH
58179: LD_VAR 0 3
58183: PUSH
58184: LD_EXP 113
58188: PUSH
58189: LD_VAR 0 2
58193: ARRAY
58194: PUSH
58195: LD_INT 2
58197: ARRAY
58198: IN
58199: NOT
58200: AND
58201: PUSH
58202: LD_VAR 0 3
58206: PUSH
58207: LD_EXP 122
58211: PUSH
58212: LD_VAR 0 2
58216: ARRAY
58217: IN
58218: NOT
58219: AND
58220: IFFALSE 58257
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58222: LD_VAR 0 2
58226: PPUSH
58227: LD_EXP 110
58231: PUSH
58232: LD_VAR 0 2
58236: ARRAY
58237: PPUSH
58238: LD_VAR 0 3
58242: PPUSH
58243: LD_VAR 0 3
58247: PPUSH
58248: CALL_OW 257
58252: PPUSH
58253: CALL 57029 0 4
// end ;
58257: GO 58106
58259: POP
58260: POP
// end ;
58261: GO 58041
58263: POP
58264: POP
// end ;
58265: LD_VAR 0 1
58269: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58270: LD_INT 0
58272: PPUSH
58273: PPUSH
58274: PPUSH
58275: PPUSH
58276: PPUSH
58277: PPUSH
// if not mc_bases [ base ] then
58278: LD_EXP 110
58282: PUSH
58283: LD_VAR 0 1
58287: ARRAY
58288: NOT
58289: IFFALSE 58293
// exit ;
58291: GO 58475
// tmp := [ ] ;
58293: LD_ADDR_VAR 0 6
58297: PUSH
58298: EMPTY
58299: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58300: LD_ADDR_VAR 0 7
58304: PUSH
58305: LD_VAR 0 3
58309: PPUSH
58310: LD_INT 0
58312: PPUSH
58313: CALL_OW 517
58317: ST_TO_ADDR
// if not list then
58318: LD_VAR 0 7
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58475
// for i = 1 to amount do
58327: LD_ADDR_VAR 0 5
58331: PUSH
58332: DOUBLE
58333: LD_INT 1
58335: DEC
58336: ST_TO_ADDR
58337: LD_VAR 0 2
58341: PUSH
58342: FOR_TO
58343: IFFALSE 58423
// begin x := rand ( 1 , list [ 1 ] ) ;
58345: LD_ADDR_VAR 0 8
58349: PUSH
58350: LD_INT 1
58352: PPUSH
58353: LD_VAR 0 7
58357: PUSH
58358: LD_INT 1
58360: ARRAY
58361: PPUSH
58362: CALL_OW 12
58366: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58367: LD_ADDR_VAR 0 6
58371: PUSH
58372: LD_VAR 0 6
58376: PPUSH
58377: LD_VAR 0 5
58381: PPUSH
58382: LD_VAR 0 7
58386: PUSH
58387: LD_INT 1
58389: ARRAY
58390: PUSH
58391: LD_VAR 0 8
58395: ARRAY
58396: PUSH
58397: LD_VAR 0 7
58401: PUSH
58402: LD_INT 2
58404: ARRAY
58405: PUSH
58406: LD_VAR 0 8
58410: ARRAY
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: PPUSH
58416: CALL_OW 1
58420: ST_TO_ADDR
// end ;
58421: GO 58342
58423: POP
58424: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58425: LD_ADDR_EXP 123
58429: PUSH
58430: LD_EXP 123
58434: PPUSH
58435: LD_VAR 0 1
58439: PPUSH
58440: LD_VAR 0 6
58444: PPUSH
58445: CALL_OW 1
58449: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58450: LD_ADDR_EXP 125
58454: PUSH
58455: LD_EXP 125
58459: PPUSH
58460: LD_VAR 0 1
58464: PPUSH
58465: LD_VAR 0 3
58469: PPUSH
58470: CALL_OW 1
58474: ST_TO_ADDR
// end ;
58475: LD_VAR 0 4
58479: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58480: LD_INT 0
58482: PPUSH
// if not mc_bases [ base ] then
58483: LD_EXP 110
58487: PUSH
58488: LD_VAR 0 1
58492: ARRAY
58493: NOT
58494: IFFALSE 58498
// exit ;
58496: GO 58523
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58498: LD_ADDR_EXP 115
58502: PUSH
58503: LD_EXP 115
58507: PPUSH
58508: LD_VAR 0 1
58512: PPUSH
58513: LD_VAR 0 2
58517: PPUSH
58518: CALL_OW 1
58522: ST_TO_ADDR
// end ;
58523: LD_VAR 0 3
58527: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58528: LD_INT 0
58530: PPUSH
// if not mc_bases [ base ] then
58531: LD_EXP 110
58535: PUSH
58536: LD_VAR 0 1
58540: ARRAY
58541: NOT
58542: IFFALSE 58546
// exit ;
58544: GO 58583
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58546: LD_ADDR_EXP 115
58550: PUSH
58551: LD_EXP 115
58555: PPUSH
58556: LD_VAR 0 1
58560: PPUSH
58561: LD_EXP 115
58565: PUSH
58566: LD_VAR 0 1
58570: ARRAY
58571: PUSH
58572: LD_VAR 0 2
58576: UNION
58577: PPUSH
58578: CALL_OW 1
58582: ST_TO_ADDR
// end ;
58583: LD_VAR 0 3
58587: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58588: LD_INT 0
58590: PPUSH
// if not mc_bases [ base ] then
58591: LD_EXP 110
58595: PUSH
58596: LD_VAR 0 1
58600: ARRAY
58601: NOT
58602: IFFALSE 58606
// exit ;
58604: GO 58631
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58606: LD_ADDR_EXP 131
58610: PUSH
58611: LD_EXP 131
58615: PPUSH
58616: LD_VAR 0 1
58620: PPUSH
58621: LD_VAR 0 2
58625: PPUSH
58626: CALL_OW 1
58630: ST_TO_ADDR
// end ;
58631: LD_VAR 0 3
58635: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58636: LD_INT 0
58638: PPUSH
// if not mc_bases [ base ] then
58639: LD_EXP 110
58643: PUSH
58644: LD_VAR 0 1
58648: ARRAY
58649: NOT
58650: IFFALSE 58654
// exit ;
58652: GO 58691
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58654: LD_ADDR_EXP 131
58658: PUSH
58659: LD_EXP 131
58663: PPUSH
58664: LD_VAR 0 1
58668: PPUSH
58669: LD_EXP 131
58673: PUSH
58674: LD_VAR 0 1
58678: ARRAY
58679: PUSH
58680: LD_VAR 0 2
58684: ADD
58685: PPUSH
58686: CALL_OW 1
58690: ST_TO_ADDR
// end ;
58691: LD_VAR 0 3
58695: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58696: LD_INT 0
58698: PPUSH
// if not mc_bases [ base ] then
58699: LD_EXP 110
58703: PUSH
58704: LD_VAR 0 1
58708: ARRAY
58709: NOT
58710: IFFALSE 58714
// exit ;
58712: GO 58768
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58714: LD_ADDR_EXP 132
58718: PUSH
58719: LD_EXP 132
58723: PPUSH
58724: LD_VAR 0 1
58728: PPUSH
58729: LD_VAR 0 2
58733: PPUSH
58734: CALL_OW 1
58738: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58739: LD_ADDR_EXP 121
58743: PUSH
58744: LD_EXP 121
58748: PPUSH
58749: LD_VAR 0 1
58753: PPUSH
58754: LD_VAR 0 2
58758: PUSH
58759: LD_INT 0
58761: PLUS
58762: PPUSH
58763: CALL_OW 1
58767: ST_TO_ADDR
// end ;
58768: LD_VAR 0 3
58772: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58773: LD_INT 0
58775: PPUSH
// if not mc_bases [ base ] then
58776: LD_EXP 110
58780: PUSH
58781: LD_VAR 0 1
58785: ARRAY
58786: NOT
58787: IFFALSE 58791
// exit ;
58789: GO 58816
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58791: LD_ADDR_EXP 121
58795: PUSH
58796: LD_EXP 121
58800: PPUSH
58801: LD_VAR 0 1
58805: PPUSH
58806: LD_VAR 0 2
58810: PPUSH
58811: CALL_OW 1
58815: ST_TO_ADDR
// end ;
58816: LD_VAR 0 3
58820: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58821: LD_INT 0
58823: PPUSH
58824: PPUSH
58825: PPUSH
58826: PPUSH
// if not mc_bases [ base ] then
58827: LD_EXP 110
58831: PUSH
58832: LD_VAR 0 1
58836: ARRAY
58837: NOT
58838: IFFALSE 58842
// exit ;
58840: GO 58907
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58842: LD_ADDR_EXP 130
58846: PUSH
58847: LD_EXP 130
58851: PPUSH
58852: LD_VAR 0 1
58856: PUSH
58857: LD_EXP 130
58861: PUSH
58862: LD_VAR 0 1
58866: ARRAY
58867: PUSH
58868: LD_INT 1
58870: PLUS
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: PPUSH
58876: LD_VAR 0 1
58880: PUSH
58881: LD_VAR 0 2
58885: PUSH
58886: LD_VAR 0 3
58890: PUSH
58891: LD_VAR 0 4
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: LIST
58900: LIST
58901: PPUSH
58902: CALL 72337 0 3
58906: ST_TO_ADDR
// end ;
58907: LD_VAR 0 5
58911: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58912: LD_INT 0
58914: PPUSH
// if not mc_bases [ base ] then
58915: LD_EXP 110
58919: PUSH
58920: LD_VAR 0 1
58924: ARRAY
58925: NOT
58926: IFFALSE 58930
// exit ;
58928: GO 58955
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58930: LD_ADDR_EXP 147
58934: PUSH
58935: LD_EXP 147
58939: PPUSH
58940: LD_VAR 0 1
58944: PPUSH
58945: LD_VAR 0 2
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// end ;
58955: LD_VAR 0 3
58959: RET
// export function MC_GetMinesField ( base ) ; begin
58960: LD_INT 0
58962: PPUSH
// result := mc_mines [ base ] ;
58963: LD_ADDR_VAR 0 2
58967: PUSH
58968: LD_EXP 123
58972: PUSH
58973: LD_VAR 0 1
58977: ARRAY
58978: ST_TO_ADDR
// end ;
58979: LD_VAR 0 2
58983: RET
// export function MC_GetProduceList ( base ) ; begin
58984: LD_INT 0
58986: PPUSH
// result := mc_produce [ base ] ;
58987: LD_ADDR_VAR 0 2
58991: PUSH
58992: LD_EXP 131
58996: PUSH
58997: LD_VAR 0 1
59001: ARRAY
59002: ST_TO_ADDR
// end ;
59003: LD_VAR 0 2
59007: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59008: LD_INT 0
59010: PPUSH
59011: PPUSH
// if not mc_bases then
59012: LD_EXP 110
59016: NOT
59017: IFFALSE 59021
// exit ;
59019: GO 59086
// if mc_bases [ base ] then
59021: LD_EXP 110
59025: PUSH
59026: LD_VAR 0 1
59030: ARRAY
59031: IFFALSE 59086
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59033: LD_ADDR_VAR 0 3
59037: PUSH
59038: LD_EXP 110
59042: PUSH
59043: LD_VAR 0 1
59047: ARRAY
59048: PPUSH
59049: LD_INT 30
59051: PUSH
59052: LD_VAR 0 2
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PPUSH
59061: CALL_OW 72
59065: ST_TO_ADDR
// if result then
59066: LD_VAR 0 3
59070: IFFALSE 59086
// result := result [ 1 ] ;
59072: LD_ADDR_VAR 0 3
59076: PUSH
59077: LD_VAR 0 3
59081: PUSH
59082: LD_INT 1
59084: ARRAY
59085: ST_TO_ADDR
// end ; end ;
59086: LD_VAR 0 3
59090: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59091: LD_INT 0
59093: PPUSH
59094: PPUSH
// if not mc_bases then
59095: LD_EXP 110
59099: NOT
59100: IFFALSE 59104
// exit ;
59102: GO 59149
// if mc_bases [ base ] then
59104: LD_EXP 110
59108: PUSH
59109: LD_VAR 0 1
59113: ARRAY
59114: IFFALSE 59149
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59116: LD_ADDR_VAR 0 3
59120: PUSH
59121: LD_EXP 110
59125: PUSH
59126: LD_VAR 0 1
59130: ARRAY
59131: PPUSH
59132: LD_INT 30
59134: PUSH
59135: LD_VAR 0 2
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PPUSH
59144: CALL_OW 72
59148: ST_TO_ADDR
// end ;
59149: LD_VAR 0 3
59153: RET
// export function MC_SetTame ( base , area ) ; begin
59154: LD_INT 0
59156: PPUSH
// if not mc_bases or not base then
59157: LD_EXP 110
59161: NOT
59162: PUSH
59163: LD_VAR 0 1
59167: NOT
59168: OR
59169: IFFALSE 59173
// exit ;
59171: GO 59198
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59173: LD_ADDR_EXP 138
59177: PUSH
59178: LD_EXP 138
59182: PPUSH
59183: LD_VAR 0 1
59187: PPUSH
59188: LD_VAR 0 2
59192: PPUSH
59193: CALL_OW 1
59197: ST_TO_ADDR
// end ;
59198: LD_VAR 0 3
59202: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59203: LD_INT 0
59205: PPUSH
59206: PPUSH
// if not mc_bases or not base then
59207: LD_EXP 110
59211: NOT
59212: PUSH
59213: LD_VAR 0 1
59217: NOT
59218: OR
59219: IFFALSE 59223
// exit ;
59221: GO 59325
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59223: LD_ADDR_VAR 0 4
59227: PUSH
59228: LD_EXP 110
59232: PUSH
59233: LD_VAR 0 1
59237: ARRAY
59238: PPUSH
59239: LD_INT 30
59241: PUSH
59242: LD_VAR 0 2
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PPUSH
59251: CALL_OW 72
59255: ST_TO_ADDR
// if not tmp then
59256: LD_VAR 0 4
59260: NOT
59261: IFFALSE 59265
// exit ;
59263: GO 59325
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59265: LD_ADDR_EXP 142
59269: PUSH
59270: LD_EXP 142
59274: PPUSH
59275: LD_VAR 0 1
59279: PPUSH
59280: LD_EXP 142
59284: PUSH
59285: LD_VAR 0 1
59289: ARRAY
59290: PPUSH
59291: LD_EXP 142
59295: PUSH
59296: LD_VAR 0 1
59300: ARRAY
59301: PUSH
59302: LD_INT 1
59304: PLUS
59305: PPUSH
59306: LD_VAR 0 4
59310: PUSH
59311: LD_INT 1
59313: ARRAY
59314: PPUSH
59315: CALL_OW 2
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// end ;
59325: LD_VAR 0 3
59329: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59330: LD_INT 0
59332: PPUSH
59333: PPUSH
// if not mc_bases or not base or not kinds then
59334: LD_EXP 110
59338: NOT
59339: PUSH
59340: LD_VAR 0 1
59344: NOT
59345: OR
59346: PUSH
59347: LD_VAR 0 2
59351: NOT
59352: OR
59353: IFFALSE 59357
// exit ;
59355: GO 59418
// for i in kinds do
59357: LD_ADDR_VAR 0 4
59361: PUSH
59362: LD_VAR 0 2
59366: PUSH
59367: FOR_IN
59368: IFFALSE 59416
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59370: LD_ADDR_EXP 144
59374: PUSH
59375: LD_EXP 144
59379: PPUSH
59380: LD_VAR 0 1
59384: PUSH
59385: LD_EXP 144
59389: PUSH
59390: LD_VAR 0 1
59394: ARRAY
59395: PUSH
59396: LD_INT 1
59398: PLUS
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: PPUSH
59404: LD_VAR 0 4
59408: PPUSH
59409: CALL 72337 0 3
59413: ST_TO_ADDR
59414: GO 59367
59416: POP
59417: POP
// end ;
59418: LD_VAR 0 3
59422: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59423: LD_INT 0
59425: PPUSH
// if not mc_bases or not base or not areas then
59426: LD_EXP 110
59430: NOT
59431: PUSH
59432: LD_VAR 0 1
59436: NOT
59437: OR
59438: PUSH
59439: LD_VAR 0 2
59443: NOT
59444: OR
59445: IFFALSE 59449
// exit ;
59447: GO 59474
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59449: LD_ADDR_EXP 128
59453: PUSH
59454: LD_EXP 128
59458: PPUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_VAR 0 2
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// end ;
59474: LD_VAR 0 3
59478: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59479: LD_INT 0
59481: PPUSH
// if not mc_bases or not base or not teleports_exit then
59482: LD_EXP 110
59486: NOT
59487: PUSH
59488: LD_VAR 0 1
59492: NOT
59493: OR
59494: PUSH
59495: LD_VAR 0 2
59499: NOT
59500: OR
59501: IFFALSE 59505
// exit ;
59503: GO 59530
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59505: LD_ADDR_EXP 145
59509: PUSH
59510: LD_EXP 145
59514: PPUSH
59515: LD_VAR 0 1
59519: PPUSH
59520: LD_VAR 0 2
59524: PPUSH
59525: CALL_OW 1
59529: ST_TO_ADDR
// end ;
59530: LD_VAR 0 3
59534: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59535: LD_INT 0
59537: PPUSH
59538: PPUSH
59539: PPUSH
// if not mc_bases or not base or not ext_list then
59540: LD_EXP 110
59544: NOT
59545: PUSH
59546: LD_VAR 0 1
59550: NOT
59551: OR
59552: PUSH
59553: LD_VAR 0 5
59557: NOT
59558: OR
59559: IFFALSE 59563
// exit ;
59561: GO 59736
// tmp := GetFacExtXYD ( x , y , d ) ;
59563: LD_ADDR_VAR 0 8
59567: PUSH
59568: LD_VAR 0 2
59572: PPUSH
59573: LD_VAR 0 3
59577: PPUSH
59578: LD_VAR 0 4
59582: PPUSH
59583: CALL 105725 0 3
59587: ST_TO_ADDR
// if not tmp then
59588: LD_VAR 0 8
59592: NOT
59593: IFFALSE 59597
// exit ;
59595: GO 59736
// for i in tmp do
59597: LD_ADDR_VAR 0 7
59601: PUSH
59602: LD_VAR 0 8
59606: PUSH
59607: FOR_IN
59608: IFFALSE 59734
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59610: LD_ADDR_EXP 115
59614: PUSH
59615: LD_EXP 115
59619: PPUSH
59620: LD_VAR 0 1
59624: PPUSH
59625: LD_EXP 115
59629: PUSH
59630: LD_VAR 0 1
59634: ARRAY
59635: PPUSH
59636: LD_EXP 115
59640: PUSH
59641: LD_VAR 0 1
59645: ARRAY
59646: PUSH
59647: LD_INT 1
59649: PLUS
59650: PPUSH
59651: LD_VAR 0 5
59655: PUSH
59656: LD_INT 1
59658: ARRAY
59659: PUSH
59660: LD_VAR 0 7
59664: PUSH
59665: LD_INT 1
59667: ARRAY
59668: PUSH
59669: LD_VAR 0 7
59673: PUSH
59674: LD_INT 2
59676: ARRAY
59677: PUSH
59678: LD_VAR 0 7
59682: PUSH
59683: LD_INT 3
59685: ARRAY
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: LIST
59691: LIST
59692: PPUSH
59693: CALL_OW 2
59697: PPUSH
59698: CALL_OW 1
59702: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59703: LD_ADDR_VAR 0 5
59707: PUSH
59708: LD_VAR 0 5
59712: PPUSH
59713: LD_INT 1
59715: PPUSH
59716: CALL_OW 3
59720: ST_TO_ADDR
// if not ext_list then
59721: LD_VAR 0 5
59725: NOT
59726: IFFALSE 59732
// exit ;
59728: POP
59729: POP
59730: GO 59736
// end ;
59732: GO 59607
59734: POP
59735: POP
// end ;
59736: LD_VAR 0 6
59740: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59741: LD_INT 0
59743: PPUSH
// if not mc_bases or not base or not weapon_list then
59744: LD_EXP 110
59748: NOT
59749: PUSH
59750: LD_VAR 0 1
59754: NOT
59755: OR
59756: PUSH
59757: LD_VAR 0 2
59761: NOT
59762: OR
59763: IFFALSE 59767
// exit ;
59765: GO 59792
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59767: LD_ADDR_EXP 149
59771: PUSH
59772: LD_EXP 149
59776: PPUSH
59777: LD_VAR 0 1
59781: PPUSH
59782: LD_VAR 0 2
59786: PPUSH
59787: CALL_OW 1
59791: ST_TO_ADDR
// end ;
59792: LD_VAR 0 3
59796: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59797: LD_INT 0
59799: PPUSH
// if not mc_bases or not base or not tech_list then
59800: LD_EXP 110
59804: NOT
59805: PUSH
59806: LD_VAR 0 1
59810: NOT
59811: OR
59812: PUSH
59813: LD_VAR 0 2
59817: NOT
59818: OR
59819: IFFALSE 59823
// exit ;
59821: GO 59848
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59823: LD_ADDR_EXP 137
59827: PUSH
59828: LD_EXP 137
59832: PPUSH
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_VAR 0 2
59842: PPUSH
59843: CALL_OW 1
59847: ST_TO_ADDR
// end ;
59848: LD_VAR 0 3
59852: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59853: LD_INT 0
59855: PPUSH
// if not mc_bases or not parking_area or not base then
59856: LD_EXP 110
59860: NOT
59861: PUSH
59862: LD_VAR 0 2
59866: NOT
59867: OR
59868: PUSH
59869: LD_VAR 0 1
59873: NOT
59874: OR
59875: IFFALSE 59879
// exit ;
59877: GO 59904
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59879: LD_ADDR_EXP 134
59883: PUSH
59884: LD_EXP 134
59888: PPUSH
59889: LD_VAR 0 1
59893: PPUSH
59894: LD_VAR 0 2
59898: PPUSH
59899: CALL_OW 1
59903: ST_TO_ADDR
// end ;
59904: LD_VAR 0 3
59908: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59909: LD_INT 0
59911: PPUSH
// if not mc_bases or not base or not scan_area then
59912: LD_EXP 110
59916: NOT
59917: PUSH
59918: LD_VAR 0 1
59922: NOT
59923: OR
59924: PUSH
59925: LD_VAR 0 2
59929: NOT
59930: OR
59931: IFFALSE 59935
// exit ;
59933: GO 59960
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59935: LD_ADDR_EXP 135
59939: PUSH
59940: LD_EXP 135
59944: PPUSH
59945: LD_VAR 0 1
59949: PPUSH
59950: LD_VAR 0 2
59954: PPUSH
59955: CALL_OW 1
59959: ST_TO_ADDR
// end ;
59960: LD_VAR 0 3
59964: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// if not mc_bases or not base then
59969: LD_EXP 110
59973: NOT
59974: PUSH
59975: LD_VAR 0 1
59979: NOT
59980: OR
59981: IFFALSE 59985
// exit ;
59983: GO 60049
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59985: LD_ADDR_VAR 0 3
59989: PUSH
59990: LD_INT 1
59992: PUSH
59993: LD_INT 2
59995: PUSH
59996: LD_INT 3
59998: PUSH
59999: LD_INT 4
60001: PUSH
60002: LD_INT 11
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: LIST
60009: LIST
60010: LIST
60011: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60012: LD_ADDR_EXP 137
60016: PUSH
60017: LD_EXP 137
60021: PPUSH
60022: LD_VAR 0 1
60026: PPUSH
60027: LD_EXP 137
60031: PUSH
60032: LD_VAR 0 1
60036: ARRAY
60037: PUSH
60038: LD_VAR 0 3
60042: DIFF
60043: PPUSH
60044: CALL_OW 1
60048: ST_TO_ADDR
// end ;
60049: LD_VAR 0 2
60053: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60054: LD_INT 0
60056: PPUSH
// result := mc_vehicles [ base ] ;
60057: LD_ADDR_VAR 0 3
60061: PUSH
60062: LD_EXP 129
60066: PUSH
60067: LD_VAR 0 1
60071: ARRAY
60072: ST_TO_ADDR
// if onlyCombat then
60073: LD_VAR 0 2
60077: IFFALSE 60242
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60079: LD_ADDR_VAR 0 3
60083: PUSH
60084: LD_VAR 0 3
60088: PUSH
60089: LD_VAR 0 3
60093: PPUSH
60094: LD_INT 2
60096: PUSH
60097: LD_INT 34
60099: PUSH
60100: LD_INT 12
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: PUSH
60107: LD_INT 34
60109: PUSH
60110: LD_INT 51
60112: PUSH
60113: EMPTY
60114: LIST
60115: LIST
60116: PUSH
60117: LD_INT 34
60119: PUSH
60120: LD_EXP 96
60124: PUSH
60125: EMPTY
60126: LIST
60127: LIST
60128: PUSH
60129: LD_INT 34
60131: PUSH
60132: LD_INT 32
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PUSH
60139: LD_INT 34
60141: PUSH
60142: LD_INT 13
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 34
60151: PUSH
60152: LD_INT 52
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: LD_INT 34
60161: PUSH
60162: LD_INT 14
60164: PUSH
60165: EMPTY
60166: LIST
60167: LIST
60168: PUSH
60169: LD_INT 34
60171: PUSH
60172: LD_INT 53
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PUSH
60179: LD_INT 34
60181: PUSH
60182: LD_EXP 95
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PUSH
60191: LD_INT 34
60193: PUSH
60194: LD_INT 31
60196: PUSH
60197: EMPTY
60198: LIST
60199: LIST
60200: PUSH
60201: LD_INT 34
60203: PUSH
60204: LD_INT 48
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: PUSH
60211: LD_INT 34
60213: PUSH
60214: LD_INT 8
60216: PUSH
60217: EMPTY
60218: LIST
60219: LIST
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: LIST
60225: LIST
60226: LIST
60227: LIST
60228: LIST
60229: LIST
60230: LIST
60231: LIST
60232: LIST
60233: LIST
60234: LIST
60235: PPUSH
60236: CALL_OW 72
60240: DIFF
60241: ST_TO_ADDR
// end ; end_of_file
60242: LD_VAR 0 3
60246: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60247: LD_INT 0
60249: PPUSH
60250: PPUSH
60251: PPUSH
// if not mc_bases or not skirmish then
60252: LD_EXP 110
60256: NOT
60257: PUSH
60258: LD_EXP 108
60262: NOT
60263: OR
60264: IFFALSE 60268
// exit ;
60266: GO 60433
// for i = 1 to mc_bases do
60268: LD_ADDR_VAR 0 4
60272: PUSH
60273: DOUBLE
60274: LD_INT 1
60276: DEC
60277: ST_TO_ADDR
60278: LD_EXP 110
60282: PUSH
60283: FOR_TO
60284: IFFALSE 60431
// begin if sci in mc_bases [ i ] then
60286: LD_VAR 0 2
60290: PUSH
60291: LD_EXP 110
60295: PUSH
60296: LD_VAR 0 4
60300: ARRAY
60301: IN
60302: IFFALSE 60429
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60304: LD_ADDR_EXP 139
60308: PUSH
60309: LD_EXP 139
60313: PPUSH
60314: LD_VAR 0 4
60318: PUSH
60319: LD_EXP 139
60323: PUSH
60324: LD_VAR 0 4
60328: ARRAY
60329: PUSH
60330: LD_INT 1
60332: PLUS
60333: PUSH
60334: EMPTY
60335: LIST
60336: LIST
60337: PPUSH
60338: LD_VAR 0 1
60342: PPUSH
60343: CALL 72337 0 3
60347: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60348: LD_ADDR_VAR 0 5
60352: PUSH
60353: LD_EXP 110
60357: PUSH
60358: LD_VAR 0 4
60362: ARRAY
60363: PPUSH
60364: LD_INT 2
60366: PUSH
60367: LD_INT 30
60369: PUSH
60370: LD_INT 0
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PUSH
60377: LD_INT 30
60379: PUSH
60380: LD_INT 1
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: LIST
60391: PPUSH
60392: CALL_OW 72
60396: PPUSH
60397: LD_VAR 0 1
60401: PPUSH
60402: CALL_OW 74
60406: ST_TO_ADDR
// if tmp then
60407: LD_VAR 0 5
60411: IFFALSE 60427
// ComStandNearbyBuilding ( ape , tmp ) ;
60413: LD_VAR 0 1
60417: PPUSH
60418: LD_VAR 0 5
60422: PPUSH
60423: CALL 66540 0 2
// break ;
60427: GO 60431
// end ; end ;
60429: GO 60283
60431: POP
60432: POP
// end ;
60433: LD_VAR 0 3
60437: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60438: LD_INT 0
60440: PPUSH
60441: PPUSH
60442: PPUSH
// if not mc_bases or not skirmish then
60443: LD_EXP 110
60447: NOT
60448: PUSH
60449: LD_EXP 108
60453: NOT
60454: OR
60455: IFFALSE 60459
// exit ;
60457: GO 60548
// for i = 1 to mc_bases do
60459: LD_ADDR_VAR 0 4
60463: PUSH
60464: DOUBLE
60465: LD_INT 1
60467: DEC
60468: ST_TO_ADDR
60469: LD_EXP 110
60473: PUSH
60474: FOR_TO
60475: IFFALSE 60546
// begin if building in mc_busy_turret_list [ i ] then
60477: LD_VAR 0 1
60481: PUSH
60482: LD_EXP 120
60486: PUSH
60487: LD_VAR 0 4
60491: ARRAY
60492: IN
60493: IFFALSE 60544
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60495: LD_ADDR_VAR 0 5
60499: PUSH
60500: LD_EXP 120
60504: PUSH
60505: LD_VAR 0 4
60509: ARRAY
60510: PUSH
60511: LD_VAR 0 1
60515: DIFF
60516: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60517: LD_ADDR_EXP 120
60521: PUSH
60522: LD_EXP 120
60526: PPUSH
60527: LD_VAR 0 4
60531: PPUSH
60532: LD_VAR 0 5
60536: PPUSH
60537: CALL_OW 1
60541: ST_TO_ADDR
// break ;
60542: GO 60546
// end ; end ;
60544: GO 60474
60546: POP
60547: POP
// end ;
60548: LD_VAR 0 3
60552: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60553: LD_INT 0
60555: PPUSH
60556: PPUSH
60557: PPUSH
// if not mc_bases or not skirmish then
60558: LD_EXP 110
60562: NOT
60563: PUSH
60564: LD_EXP 108
60568: NOT
60569: OR
60570: IFFALSE 60574
// exit ;
60572: GO 60773
// for i = 1 to mc_bases do
60574: LD_ADDR_VAR 0 5
60578: PUSH
60579: DOUBLE
60580: LD_INT 1
60582: DEC
60583: ST_TO_ADDR
60584: LD_EXP 110
60588: PUSH
60589: FOR_TO
60590: IFFALSE 60771
// if building in mc_bases [ i ] then
60592: LD_VAR 0 1
60596: PUSH
60597: LD_EXP 110
60601: PUSH
60602: LD_VAR 0 5
60606: ARRAY
60607: IN
60608: IFFALSE 60769
// begin tmp := mc_bases [ i ] diff building ;
60610: LD_ADDR_VAR 0 6
60614: PUSH
60615: LD_EXP 110
60619: PUSH
60620: LD_VAR 0 5
60624: ARRAY
60625: PUSH
60626: LD_VAR 0 1
60630: DIFF
60631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60632: LD_ADDR_EXP 110
60636: PUSH
60637: LD_EXP 110
60641: PPUSH
60642: LD_VAR 0 5
60646: PPUSH
60647: LD_VAR 0 6
60651: PPUSH
60652: CALL_OW 1
60656: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60657: LD_VAR 0 1
60661: PUSH
60662: LD_EXP 118
60666: PUSH
60667: LD_VAR 0 5
60671: ARRAY
60672: IN
60673: IFFALSE 60712
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60675: LD_ADDR_EXP 118
60679: PUSH
60680: LD_EXP 118
60684: PPUSH
60685: LD_VAR 0 5
60689: PPUSH
60690: LD_EXP 118
60694: PUSH
60695: LD_VAR 0 5
60699: ARRAY
60700: PUSH
60701: LD_VAR 0 1
60705: DIFF
60706: PPUSH
60707: CALL_OW 1
60711: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60712: LD_VAR 0 1
60716: PUSH
60717: LD_EXP 119
60721: PUSH
60722: LD_VAR 0 5
60726: ARRAY
60727: IN
60728: IFFALSE 60767
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60730: LD_ADDR_EXP 119
60734: PUSH
60735: LD_EXP 119
60739: PPUSH
60740: LD_VAR 0 5
60744: PPUSH
60745: LD_EXP 119
60749: PUSH
60750: LD_VAR 0 5
60754: ARRAY
60755: PUSH
60756: LD_VAR 0 1
60760: DIFF
60761: PPUSH
60762: CALL_OW 1
60766: ST_TO_ADDR
// break ;
60767: GO 60771
// end ;
60769: GO 60589
60771: POP
60772: POP
// end ;
60773: LD_VAR 0 4
60777: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60778: LD_INT 0
60780: PPUSH
60781: PPUSH
60782: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60783: LD_EXP 110
60787: NOT
60788: PUSH
60789: LD_EXP 108
60793: NOT
60794: OR
60795: PUSH
60796: LD_VAR 0 3
60800: PUSH
60801: LD_EXP 136
60805: IN
60806: NOT
60807: OR
60808: IFFALSE 60812
// exit ;
60810: GO 60935
// for i = 1 to mc_vehicles do
60812: LD_ADDR_VAR 0 6
60816: PUSH
60817: DOUBLE
60818: LD_INT 1
60820: DEC
60821: ST_TO_ADDR
60822: LD_EXP 129
60826: PUSH
60827: FOR_TO
60828: IFFALSE 60933
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60830: LD_VAR 0 2
60834: PUSH
60835: LD_EXP 129
60839: PUSH
60840: LD_VAR 0 6
60844: ARRAY
60845: IN
60846: PUSH
60847: LD_VAR 0 1
60851: PUSH
60852: LD_EXP 129
60856: PUSH
60857: LD_VAR 0 6
60861: ARRAY
60862: IN
60863: OR
60864: IFFALSE 60931
// begin tmp := mc_vehicles [ i ] diff old ;
60866: LD_ADDR_VAR 0 7
60870: PUSH
60871: LD_EXP 129
60875: PUSH
60876: LD_VAR 0 6
60880: ARRAY
60881: PUSH
60882: LD_VAR 0 2
60886: DIFF
60887: ST_TO_ADDR
// tmp := tmp diff new ;
60888: LD_ADDR_VAR 0 7
60892: PUSH
60893: LD_VAR 0 7
60897: PUSH
60898: LD_VAR 0 1
60902: DIFF
60903: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60904: LD_ADDR_EXP 129
60908: PUSH
60909: LD_EXP 129
60913: PPUSH
60914: LD_VAR 0 6
60918: PPUSH
60919: LD_VAR 0 7
60923: PPUSH
60924: CALL_OW 1
60928: ST_TO_ADDR
// break ;
60929: GO 60933
// end ;
60931: GO 60827
60933: POP
60934: POP
// end ;
60935: LD_VAR 0 5
60939: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60940: LD_INT 0
60942: PPUSH
60943: PPUSH
60944: PPUSH
60945: PPUSH
// if not mc_bases or not skirmish then
60946: LD_EXP 110
60950: NOT
60951: PUSH
60952: LD_EXP 108
60956: NOT
60957: OR
60958: IFFALSE 60962
// exit ;
60960: GO 61339
// side := GetSide ( vehicle ) ;
60962: LD_ADDR_VAR 0 5
60966: PUSH
60967: LD_VAR 0 1
60971: PPUSH
60972: CALL_OW 255
60976: ST_TO_ADDR
// for i = 1 to mc_bases do
60977: LD_ADDR_VAR 0 4
60981: PUSH
60982: DOUBLE
60983: LD_INT 1
60985: DEC
60986: ST_TO_ADDR
60987: LD_EXP 110
60991: PUSH
60992: FOR_TO
60993: IFFALSE 61337
// begin if factory in mc_bases [ i ] then
60995: LD_VAR 0 2
60999: PUSH
61000: LD_EXP 110
61004: PUSH
61005: LD_VAR 0 4
61009: ARRAY
61010: IN
61011: IFFALSE 61335
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61013: LD_EXP 132
61017: PUSH
61018: LD_VAR 0 4
61022: ARRAY
61023: PUSH
61024: LD_EXP 121
61028: PUSH
61029: LD_VAR 0 4
61033: ARRAY
61034: LESS
61035: PUSH
61036: LD_VAR 0 1
61040: PPUSH
61041: CALL_OW 264
61045: PUSH
61046: LD_INT 31
61048: PUSH
61049: LD_INT 32
61051: PUSH
61052: LD_INT 51
61054: PUSH
61055: LD_EXP 96
61059: PUSH
61060: LD_INT 12
61062: PUSH
61063: LD_INT 30
61065: PUSH
61066: LD_EXP 95
61070: PUSH
61071: LD_INT 11
61073: PUSH
61074: LD_INT 53
61076: PUSH
61077: LD_INT 14
61079: PUSH
61080: LD_EXP 99
61084: PUSH
61085: LD_INT 29
61087: PUSH
61088: LD_EXP 97
61092: PUSH
61093: LD_INT 13
61095: PUSH
61096: LD_INT 52
61098: PUSH
61099: LD_INT 48
61101: PUSH
61102: LD_INT 8
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: LIST
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: IN
61124: NOT
61125: AND
61126: IFFALSE 61174
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61128: LD_ADDR_EXP 132
61132: PUSH
61133: LD_EXP 132
61137: PPUSH
61138: LD_VAR 0 4
61142: PUSH
61143: LD_EXP 132
61147: PUSH
61148: LD_VAR 0 4
61152: ARRAY
61153: PUSH
61154: LD_INT 1
61156: PLUS
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: PPUSH
61162: LD_VAR 0 1
61166: PPUSH
61167: CALL 72337 0 3
61171: ST_TO_ADDR
61172: GO 61218
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61174: LD_ADDR_EXP 129
61178: PUSH
61179: LD_EXP 129
61183: PPUSH
61184: LD_VAR 0 4
61188: PUSH
61189: LD_EXP 129
61193: PUSH
61194: LD_VAR 0 4
61198: ARRAY
61199: PUSH
61200: LD_INT 1
61202: PLUS
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PPUSH
61208: LD_VAR 0 1
61212: PPUSH
61213: CALL 72337 0 3
61217: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61218: LD_VAR 0 1
61222: PPUSH
61223: CALL_OW 263
61227: PUSH
61228: LD_INT 2
61230: EQUAL
61231: IFFALSE 61251
// begin repeat wait ( 0 0$1 ) ;
61233: LD_INT 35
61235: PPUSH
61236: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61240: LD_VAR 0 1
61244: PPUSH
61245: CALL_OW 312
61249: IFFALSE 61233
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61251: LD_VAR 0 1
61255: PPUSH
61256: LD_EXP 134
61260: PUSH
61261: LD_VAR 0 4
61265: ARRAY
61266: PPUSH
61267: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61271: LD_VAR 0 1
61275: PPUSH
61276: CALL_OW 263
61280: PUSH
61281: LD_INT 1
61283: NONEQUAL
61284: IFFALSE 61288
// break ;
61286: GO 61337
// repeat wait ( 0 0$1 ) ;
61288: LD_INT 35
61290: PPUSH
61291: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61295: LD_VAR 0 1
61299: PPUSH
61300: LD_EXP 134
61304: PUSH
61305: LD_VAR 0 4
61309: ARRAY
61310: PPUSH
61311: CALL_OW 308
61315: IFFALSE 61288
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61317: LD_VAR 0 1
61321: PPUSH
61322: CALL_OW 311
61326: PPUSH
61327: CALL_OW 121
// exit ;
61331: POP
61332: POP
61333: GO 61339
// end ; end ;
61335: GO 60992
61337: POP
61338: POP
// end ;
61339: LD_VAR 0 3
61343: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61344: LD_INT 0
61346: PPUSH
61347: PPUSH
61348: PPUSH
61349: PPUSH
// if not mc_bases or not skirmish then
61350: LD_EXP 110
61354: NOT
61355: PUSH
61356: LD_EXP 108
61360: NOT
61361: OR
61362: IFFALSE 61366
// exit ;
61364: GO 61719
// repeat wait ( 0 0$1 ) ;
61366: LD_INT 35
61368: PPUSH
61369: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61373: LD_VAR 0 2
61377: PPUSH
61378: LD_VAR 0 3
61382: PPUSH
61383: CALL_OW 284
61387: IFFALSE 61366
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61389: LD_VAR 0 2
61393: PPUSH
61394: LD_VAR 0 3
61398: PPUSH
61399: CALL_OW 283
61403: PUSH
61404: LD_INT 4
61406: EQUAL
61407: IFFALSE 61411
// exit ;
61409: GO 61719
// for i = 1 to mc_bases do
61411: LD_ADDR_VAR 0 7
61415: PUSH
61416: DOUBLE
61417: LD_INT 1
61419: DEC
61420: ST_TO_ADDR
61421: LD_EXP 110
61425: PUSH
61426: FOR_TO
61427: IFFALSE 61717
// begin if mc_crates_area [ i ] then
61429: LD_EXP 128
61433: PUSH
61434: LD_VAR 0 7
61438: ARRAY
61439: IFFALSE 61550
// for j in mc_crates_area [ i ] do
61441: LD_ADDR_VAR 0 8
61445: PUSH
61446: LD_EXP 128
61450: PUSH
61451: LD_VAR 0 7
61455: ARRAY
61456: PUSH
61457: FOR_IN
61458: IFFALSE 61548
// if InArea ( x , y , j ) then
61460: LD_VAR 0 2
61464: PPUSH
61465: LD_VAR 0 3
61469: PPUSH
61470: LD_VAR 0 8
61474: PPUSH
61475: CALL_OW 309
61479: IFFALSE 61546
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61481: LD_ADDR_EXP 126
61485: PUSH
61486: LD_EXP 126
61490: PPUSH
61491: LD_VAR 0 7
61495: PUSH
61496: LD_EXP 126
61500: PUSH
61501: LD_VAR 0 7
61505: ARRAY
61506: PUSH
61507: LD_INT 1
61509: PLUS
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: PPUSH
61515: LD_VAR 0 4
61519: PUSH
61520: LD_VAR 0 2
61524: PUSH
61525: LD_VAR 0 3
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: LIST
61534: PPUSH
61535: CALL 72337 0 3
61539: ST_TO_ADDR
// exit ;
61540: POP
61541: POP
61542: POP
61543: POP
61544: GO 61719
// end ;
61546: GO 61457
61548: POP
61549: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61550: LD_ADDR_VAR 0 9
61554: PUSH
61555: LD_EXP 110
61559: PUSH
61560: LD_VAR 0 7
61564: ARRAY
61565: PPUSH
61566: LD_INT 2
61568: PUSH
61569: LD_INT 30
61571: PUSH
61572: LD_INT 0
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PUSH
61579: LD_INT 30
61581: PUSH
61582: LD_INT 1
61584: PUSH
61585: EMPTY
61586: LIST
61587: LIST
61588: PUSH
61589: EMPTY
61590: LIST
61591: LIST
61592: LIST
61593: PPUSH
61594: CALL_OW 72
61598: ST_TO_ADDR
// if not depot then
61599: LD_VAR 0 9
61603: NOT
61604: IFFALSE 61608
// continue ;
61606: GO 61426
// for j in depot do
61608: LD_ADDR_VAR 0 8
61612: PUSH
61613: LD_VAR 0 9
61617: PUSH
61618: FOR_IN
61619: IFFALSE 61713
// if GetDistUnitXY ( j , x , y ) < 30 then
61621: LD_VAR 0 8
61625: PPUSH
61626: LD_VAR 0 2
61630: PPUSH
61631: LD_VAR 0 3
61635: PPUSH
61636: CALL_OW 297
61640: PUSH
61641: LD_INT 30
61643: LESS
61644: IFFALSE 61711
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61646: LD_ADDR_EXP 126
61650: PUSH
61651: LD_EXP 126
61655: PPUSH
61656: LD_VAR 0 7
61660: PUSH
61661: LD_EXP 126
61665: PUSH
61666: LD_VAR 0 7
61670: ARRAY
61671: PUSH
61672: LD_INT 1
61674: PLUS
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: PPUSH
61680: LD_VAR 0 4
61684: PUSH
61685: LD_VAR 0 2
61689: PUSH
61690: LD_VAR 0 3
61694: PUSH
61695: EMPTY
61696: LIST
61697: LIST
61698: LIST
61699: PPUSH
61700: CALL 72337 0 3
61704: ST_TO_ADDR
// exit ;
61705: POP
61706: POP
61707: POP
61708: POP
61709: GO 61719
// end ;
61711: GO 61618
61713: POP
61714: POP
// end ;
61715: GO 61426
61717: POP
61718: POP
// end ;
61719: LD_VAR 0 6
61723: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61724: LD_INT 0
61726: PPUSH
61727: PPUSH
61728: PPUSH
61729: PPUSH
// if not mc_bases or not skirmish then
61730: LD_EXP 110
61734: NOT
61735: PUSH
61736: LD_EXP 108
61740: NOT
61741: OR
61742: IFFALSE 61746
// exit ;
61744: GO 62023
// side := GetSide ( lab ) ;
61746: LD_ADDR_VAR 0 4
61750: PUSH
61751: LD_VAR 0 2
61755: PPUSH
61756: CALL_OW 255
61760: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61761: LD_VAR 0 4
61765: PUSH
61766: LD_EXP 136
61770: IN
61771: NOT
61772: PUSH
61773: LD_EXP 137
61777: NOT
61778: OR
61779: PUSH
61780: LD_EXP 110
61784: NOT
61785: OR
61786: IFFALSE 61790
// exit ;
61788: GO 62023
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61790: LD_ADDR_EXP 137
61794: PUSH
61795: LD_EXP 137
61799: PPUSH
61800: LD_VAR 0 4
61804: PPUSH
61805: LD_EXP 137
61809: PUSH
61810: LD_VAR 0 4
61814: ARRAY
61815: PUSH
61816: LD_VAR 0 1
61820: DIFF
61821: PPUSH
61822: CALL_OW 1
61826: ST_TO_ADDR
// for i = 1 to mc_bases do
61827: LD_ADDR_VAR 0 5
61831: PUSH
61832: DOUBLE
61833: LD_INT 1
61835: DEC
61836: ST_TO_ADDR
61837: LD_EXP 110
61841: PUSH
61842: FOR_TO
61843: IFFALSE 62021
// begin if lab in mc_bases [ i ] then
61845: LD_VAR 0 2
61849: PUSH
61850: LD_EXP 110
61854: PUSH
61855: LD_VAR 0 5
61859: ARRAY
61860: IN
61861: IFFALSE 62019
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61863: LD_VAR 0 1
61867: PUSH
61868: LD_INT 11
61870: PUSH
61871: LD_INT 4
61873: PUSH
61874: LD_INT 3
61876: PUSH
61877: LD_INT 2
61879: PUSH
61880: EMPTY
61881: LIST
61882: LIST
61883: LIST
61884: LIST
61885: IN
61886: PUSH
61887: LD_EXP 140
61891: PUSH
61892: LD_VAR 0 5
61896: ARRAY
61897: AND
61898: IFFALSE 62019
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61900: LD_ADDR_VAR 0 6
61904: PUSH
61905: LD_EXP 140
61909: PUSH
61910: LD_VAR 0 5
61914: ARRAY
61915: PUSH
61916: LD_INT 1
61918: ARRAY
61919: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61920: LD_ADDR_EXP 140
61924: PUSH
61925: LD_EXP 140
61929: PPUSH
61930: LD_VAR 0 5
61934: PPUSH
61935: EMPTY
61936: PPUSH
61937: CALL_OW 1
61941: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61942: LD_VAR 0 6
61946: PPUSH
61947: LD_INT 0
61949: PPUSH
61950: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61954: LD_VAR 0 6
61958: PPUSH
61959: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61963: LD_ADDR_EXP 139
61967: PUSH
61968: LD_EXP 139
61972: PPUSH
61973: LD_VAR 0 5
61977: PPUSH
61978: LD_EXP 139
61982: PUSH
61983: LD_VAR 0 5
61987: ARRAY
61988: PPUSH
61989: LD_INT 1
61991: PPUSH
61992: LD_VAR 0 6
61996: PPUSH
61997: CALL_OW 2
62001: PPUSH
62002: CALL_OW 1
62006: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62007: LD_VAR 0 5
62011: PPUSH
62012: LD_INT 112
62014: PPUSH
62015: CALL 39019 0 2
// end ; end ; end ;
62019: GO 61842
62021: POP
62022: POP
// end ;
62023: LD_VAR 0 3
62027: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62028: LD_INT 0
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
// if not mc_bases or not skirmish then
62038: LD_EXP 110
62042: NOT
62043: PUSH
62044: LD_EXP 108
62048: NOT
62049: OR
62050: IFFALSE 62054
// exit ;
62052: GO 63425
// for i = 1 to mc_bases do
62054: LD_ADDR_VAR 0 3
62058: PUSH
62059: DOUBLE
62060: LD_INT 1
62062: DEC
62063: ST_TO_ADDR
62064: LD_EXP 110
62068: PUSH
62069: FOR_TO
62070: IFFALSE 63423
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62072: LD_VAR 0 1
62076: PUSH
62077: LD_EXP 110
62081: PUSH
62082: LD_VAR 0 3
62086: ARRAY
62087: IN
62088: PUSH
62089: LD_VAR 0 1
62093: PUSH
62094: LD_EXP 117
62098: PUSH
62099: LD_VAR 0 3
62103: ARRAY
62104: IN
62105: OR
62106: PUSH
62107: LD_VAR 0 1
62111: PUSH
62112: LD_EXP 132
62116: PUSH
62117: LD_VAR 0 3
62121: ARRAY
62122: IN
62123: OR
62124: PUSH
62125: LD_VAR 0 1
62129: PUSH
62130: LD_EXP 129
62134: PUSH
62135: LD_VAR 0 3
62139: ARRAY
62140: IN
62141: OR
62142: PUSH
62143: LD_VAR 0 1
62147: PUSH
62148: LD_EXP 139
62152: PUSH
62153: LD_VAR 0 3
62157: ARRAY
62158: IN
62159: OR
62160: PUSH
62161: LD_VAR 0 1
62165: PUSH
62166: LD_EXP 140
62170: PUSH
62171: LD_VAR 0 3
62175: ARRAY
62176: IN
62177: OR
62178: IFFALSE 63421
// begin if un in mc_ape [ i ] then
62180: LD_VAR 0 1
62184: PUSH
62185: LD_EXP 139
62189: PUSH
62190: LD_VAR 0 3
62194: ARRAY
62195: IN
62196: IFFALSE 62235
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62198: LD_ADDR_EXP 139
62202: PUSH
62203: LD_EXP 139
62207: PPUSH
62208: LD_VAR 0 3
62212: PPUSH
62213: LD_EXP 139
62217: PUSH
62218: LD_VAR 0 3
62222: ARRAY
62223: PUSH
62224: LD_VAR 0 1
62228: DIFF
62229: PPUSH
62230: CALL_OW 1
62234: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62235: LD_VAR 0 1
62239: PUSH
62240: LD_EXP 140
62244: PUSH
62245: LD_VAR 0 3
62249: ARRAY
62250: IN
62251: IFFALSE 62275
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62253: LD_ADDR_EXP 140
62257: PUSH
62258: LD_EXP 140
62262: PPUSH
62263: LD_VAR 0 3
62267: PPUSH
62268: EMPTY
62269: PPUSH
62270: CALL_OW 1
62274: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62275: LD_VAR 0 1
62279: PPUSH
62280: CALL_OW 247
62284: PUSH
62285: LD_INT 2
62287: EQUAL
62288: PUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: CALL_OW 110
62298: PUSH
62299: LD_INT 20
62301: EQUAL
62302: PUSH
62303: LD_VAR 0 1
62307: PUSH
62308: LD_EXP 132
62312: PUSH
62313: LD_VAR 0 3
62317: ARRAY
62318: IN
62319: OR
62320: PUSH
62321: LD_VAR 0 1
62325: PPUSH
62326: CALL_OW 264
62330: PUSH
62331: LD_INT 12
62333: PUSH
62334: LD_INT 51
62336: PUSH
62337: LD_EXP 96
62341: PUSH
62342: LD_INT 32
62344: PUSH
62345: LD_INT 13
62347: PUSH
62348: LD_INT 52
62350: PUSH
62351: LD_INT 31
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: LIST
62360: LIST
62361: LIST
62362: IN
62363: OR
62364: AND
62365: IFFALSE 62673
// begin if un in mc_defender [ i ] then
62367: LD_VAR 0 1
62371: PUSH
62372: LD_EXP 132
62376: PUSH
62377: LD_VAR 0 3
62381: ARRAY
62382: IN
62383: IFFALSE 62422
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62385: LD_ADDR_EXP 132
62389: PUSH
62390: LD_EXP 132
62394: PPUSH
62395: LD_VAR 0 3
62399: PPUSH
62400: LD_EXP 132
62404: PUSH
62405: LD_VAR 0 3
62409: ARRAY
62410: PUSH
62411: LD_VAR 0 1
62415: DIFF
62416: PPUSH
62417: CALL_OW 1
62421: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62422: LD_ADDR_VAR 0 8
62426: PUSH
62427: LD_VAR 0 3
62431: PPUSH
62432: LD_INT 3
62434: PPUSH
62435: CALL 59091 0 2
62439: ST_TO_ADDR
// if fac then
62440: LD_VAR 0 8
62444: IFFALSE 62673
// begin for j in fac do
62446: LD_ADDR_VAR 0 4
62450: PUSH
62451: LD_VAR 0 8
62455: PUSH
62456: FOR_IN
62457: IFFALSE 62671
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62459: LD_ADDR_VAR 0 9
62463: PUSH
62464: LD_VAR 0 8
62468: PPUSH
62469: LD_VAR 0 1
62473: PPUSH
62474: CALL_OW 265
62478: PPUSH
62479: LD_VAR 0 1
62483: PPUSH
62484: CALL_OW 262
62488: PPUSH
62489: LD_VAR 0 1
62493: PPUSH
62494: CALL_OW 263
62498: PPUSH
62499: LD_VAR 0 1
62503: PPUSH
62504: CALL_OW 264
62508: PPUSH
62509: CALL 69869 0 5
62513: ST_TO_ADDR
// if components then
62514: LD_VAR 0 9
62518: IFFALSE 62669
// begin if GetWeapon ( un ) = ar_control_tower then
62520: LD_VAR 0 1
62524: PPUSH
62525: CALL_OW 264
62529: PUSH
62530: LD_INT 31
62532: EQUAL
62533: IFFALSE 62650
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62535: LD_VAR 0 1
62539: PPUSH
62540: CALL_OW 311
62544: PPUSH
62545: LD_INT 0
62547: PPUSH
62548: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62552: LD_ADDR_EXP 150
62556: PUSH
62557: LD_EXP 150
62561: PPUSH
62562: LD_VAR 0 3
62566: PPUSH
62567: LD_EXP 150
62571: PUSH
62572: LD_VAR 0 3
62576: ARRAY
62577: PUSH
62578: LD_VAR 0 1
62582: PPUSH
62583: CALL_OW 311
62587: DIFF
62588: PPUSH
62589: CALL_OW 1
62593: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62594: LD_ADDR_VAR 0 7
62598: PUSH
62599: LD_EXP 131
62603: PUSH
62604: LD_VAR 0 3
62608: ARRAY
62609: PPUSH
62610: LD_INT 1
62612: PPUSH
62613: LD_VAR 0 9
62617: PPUSH
62618: CALL_OW 2
62622: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62623: LD_ADDR_EXP 131
62627: PUSH
62628: LD_EXP 131
62632: PPUSH
62633: LD_VAR 0 3
62637: PPUSH
62638: LD_VAR 0 7
62642: PPUSH
62643: CALL_OW 1
62647: ST_TO_ADDR
// end else
62648: GO 62667
// MC_InsertProduceList ( i , [ components ] ) ;
62650: LD_VAR 0 3
62654: PPUSH
62655: LD_VAR 0 9
62659: PUSH
62660: EMPTY
62661: LIST
62662: PPUSH
62663: CALL 58636 0 2
// break ;
62667: GO 62671
// end ; end ;
62669: GO 62456
62671: POP
62672: POP
// end ; end ; if GetType ( un ) = unit_building then
62673: LD_VAR 0 1
62677: PPUSH
62678: CALL_OW 247
62682: PUSH
62683: LD_INT 3
62685: EQUAL
62686: IFFALSE 63089
// begin btype := GetBType ( un ) ;
62688: LD_ADDR_VAR 0 5
62692: PUSH
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 266
62702: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62703: LD_VAR 0 5
62707: PUSH
62708: LD_INT 29
62710: PUSH
62711: LD_INT 30
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: IN
62718: IFFALSE 62791
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62720: LD_VAR 0 1
62724: PPUSH
62725: CALL_OW 250
62729: PPUSH
62730: LD_VAR 0 1
62734: PPUSH
62735: CALL_OW 251
62739: PPUSH
62740: LD_VAR 0 1
62744: PPUSH
62745: CALL_OW 255
62749: PPUSH
62750: CALL_OW 440
62754: NOT
62755: IFFALSE 62791
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62757: LD_VAR 0 1
62761: PPUSH
62762: CALL_OW 250
62766: PPUSH
62767: LD_VAR 0 1
62771: PPUSH
62772: CALL_OW 251
62776: PPUSH
62777: LD_VAR 0 1
62781: PPUSH
62782: CALL_OW 255
62786: PPUSH
62787: CALL_OW 441
// end ; if btype = b_warehouse then
62791: LD_VAR 0 5
62795: PUSH
62796: LD_INT 1
62798: EQUAL
62799: IFFALSE 62817
// begin btype := b_depot ;
62801: LD_ADDR_VAR 0 5
62805: PUSH
62806: LD_INT 0
62808: ST_TO_ADDR
// pos := 1 ;
62809: LD_ADDR_VAR 0 6
62813: PUSH
62814: LD_INT 1
62816: ST_TO_ADDR
// end ; if btype = b_factory then
62817: LD_VAR 0 5
62821: PUSH
62822: LD_INT 3
62824: EQUAL
62825: IFFALSE 62843
// begin btype := b_workshop ;
62827: LD_ADDR_VAR 0 5
62831: PUSH
62832: LD_INT 2
62834: ST_TO_ADDR
// pos := 1 ;
62835: LD_ADDR_VAR 0 6
62839: PUSH
62840: LD_INT 1
62842: ST_TO_ADDR
// end ; if btype = b_barracks then
62843: LD_VAR 0 5
62847: PUSH
62848: LD_INT 5
62850: EQUAL
62851: IFFALSE 62861
// btype := b_armoury ;
62853: LD_ADDR_VAR 0 5
62857: PUSH
62858: LD_INT 4
62860: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 7
62868: PUSH
62869: LD_INT 8
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: IN
62876: IFFALSE 62886
// btype := b_lab ;
62878: LD_ADDR_VAR 0 5
62882: PUSH
62883: LD_INT 6
62885: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62886: LD_ADDR_EXP 115
62890: PUSH
62891: LD_EXP 115
62895: PPUSH
62896: LD_VAR 0 3
62900: PUSH
62901: LD_EXP 115
62905: PUSH
62906: LD_VAR 0 3
62910: ARRAY
62911: PUSH
62912: LD_INT 1
62914: PLUS
62915: PUSH
62916: EMPTY
62917: LIST
62918: LIST
62919: PPUSH
62920: LD_VAR 0 5
62924: PUSH
62925: LD_VAR 0 1
62929: PPUSH
62930: CALL_OW 250
62934: PUSH
62935: LD_VAR 0 1
62939: PPUSH
62940: CALL_OW 251
62944: PUSH
62945: LD_VAR 0 1
62949: PPUSH
62950: CALL_OW 254
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: PPUSH
62961: CALL 72337 0 3
62965: ST_TO_ADDR
// if pos = 1 then
62966: LD_VAR 0 6
62970: PUSH
62971: LD_INT 1
62973: EQUAL
62974: IFFALSE 63089
// begin tmp := mc_build_list [ i ] ;
62976: LD_ADDR_VAR 0 7
62980: PUSH
62981: LD_EXP 115
62985: PUSH
62986: LD_VAR 0 3
62990: ARRAY
62991: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62992: LD_VAR 0 7
62996: PPUSH
62997: LD_INT 2
62999: PUSH
63000: LD_INT 30
63002: PUSH
63003: LD_INT 0
63005: PUSH
63006: EMPTY
63007: LIST
63008: LIST
63009: PUSH
63010: LD_INT 30
63012: PUSH
63013: LD_INT 1
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: LIST
63024: PPUSH
63025: CALL_OW 72
63029: IFFALSE 63039
// pos := 2 ;
63031: LD_ADDR_VAR 0 6
63035: PUSH
63036: LD_INT 2
63038: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63039: LD_ADDR_VAR 0 7
63043: PUSH
63044: LD_VAR 0 7
63048: PPUSH
63049: LD_VAR 0 6
63053: PPUSH
63054: LD_VAR 0 7
63058: PPUSH
63059: CALL 72663 0 3
63063: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63064: LD_ADDR_EXP 115
63068: PUSH
63069: LD_EXP 115
63073: PPUSH
63074: LD_VAR 0 3
63078: PPUSH
63079: LD_VAR 0 7
63083: PPUSH
63084: CALL_OW 1
63088: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63089: LD_VAR 0 1
63093: PUSH
63094: LD_EXP 110
63098: PUSH
63099: LD_VAR 0 3
63103: ARRAY
63104: IN
63105: IFFALSE 63144
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63107: LD_ADDR_EXP 110
63111: PUSH
63112: LD_EXP 110
63116: PPUSH
63117: LD_VAR 0 3
63121: PPUSH
63122: LD_EXP 110
63126: PUSH
63127: LD_VAR 0 3
63131: ARRAY
63132: PUSH
63133: LD_VAR 0 1
63137: DIFF
63138: PPUSH
63139: CALL_OW 1
63143: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63144: LD_VAR 0 1
63148: PUSH
63149: LD_EXP 117
63153: PUSH
63154: LD_VAR 0 3
63158: ARRAY
63159: IN
63160: IFFALSE 63199
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63162: LD_ADDR_EXP 117
63166: PUSH
63167: LD_EXP 117
63171: PPUSH
63172: LD_VAR 0 3
63176: PPUSH
63177: LD_EXP 117
63181: PUSH
63182: LD_VAR 0 3
63186: ARRAY
63187: PUSH
63188: LD_VAR 0 1
63192: DIFF
63193: PPUSH
63194: CALL_OW 1
63198: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63199: LD_VAR 0 1
63203: PUSH
63204: LD_EXP 129
63208: PUSH
63209: LD_VAR 0 3
63213: ARRAY
63214: IN
63215: IFFALSE 63254
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63217: LD_ADDR_EXP 129
63221: PUSH
63222: LD_EXP 129
63226: PPUSH
63227: LD_VAR 0 3
63231: PPUSH
63232: LD_EXP 129
63236: PUSH
63237: LD_VAR 0 3
63241: ARRAY
63242: PUSH
63243: LD_VAR 0 1
63247: DIFF
63248: PPUSH
63249: CALL_OW 1
63253: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63254: LD_VAR 0 1
63258: PUSH
63259: LD_EXP 132
63263: PUSH
63264: LD_VAR 0 3
63268: ARRAY
63269: IN
63270: IFFALSE 63309
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63272: LD_ADDR_EXP 132
63276: PUSH
63277: LD_EXP 132
63281: PPUSH
63282: LD_VAR 0 3
63286: PPUSH
63287: LD_EXP 132
63291: PUSH
63292: LD_VAR 0 3
63296: ARRAY
63297: PUSH
63298: LD_VAR 0 1
63302: DIFF
63303: PPUSH
63304: CALL_OW 1
63308: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63309: LD_VAR 0 1
63313: PUSH
63314: LD_EXP 119
63318: PUSH
63319: LD_VAR 0 3
63323: ARRAY
63324: IN
63325: IFFALSE 63364
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63327: LD_ADDR_EXP 119
63331: PUSH
63332: LD_EXP 119
63336: PPUSH
63337: LD_VAR 0 3
63341: PPUSH
63342: LD_EXP 119
63346: PUSH
63347: LD_VAR 0 3
63351: ARRAY
63352: PUSH
63353: LD_VAR 0 1
63357: DIFF
63358: PPUSH
63359: CALL_OW 1
63363: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63364: LD_VAR 0 1
63368: PUSH
63369: LD_EXP 118
63373: PUSH
63374: LD_VAR 0 3
63378: ARRAY
63379: IN
63380: IFFALSE 63419
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63382: LD_ADDR_EXP 118
63386: PUSH
63387: LD_EXP 118
63391: PPUSH
63392: LD_VAR 0 3
63396: PPUSH
63397: LD_EXP 118
63401: PUSH
63402: LD_VAR 0 3
63406: ARRAY
63407: PUSH
63408: LD_VAR 0 1
63412: DIFF
63413: PPUSH
63414: CALL_OW 1
63418: ST_TO_ADDR
// end ; break ;
63419: GO 63423
// end ;
63421: GO 62069
63423: POP
63424: POP
// end ;
63425: LD_VAR 0 2
63429: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63430: LD_INT 0
63432: PPUSH
63433: PPUSH
63434: PPUSH
// if not mc_bases or not skirmish then
63435: LD_EXP 110
63439: NOT
63440: PUSH
63441: LD_EXP 108
63445: NOT
63446: OR
63447: IFFALSE 63451
// exit ;
63449: GO 63666
// for i = 1 to mc_bases do
63451: LD_ADDR_VAR 0 3
63455: PUSH
63456: DOUBLE
63457: LD_INT 1
63459: DEC
63460: ST_TO_ADDR
63461: LD_EXP 110
63465: PUSH
63466: FOR_TO
63467: IFFALSE 63664
// begin if building in mc_construct_list [ i ] then
63469: LD_VAR 0 1
63473: PUSH
63474: LD_EXP 117
63478: PUSH
63479: LD_VAR 0 3
63483: ARRAY
63484: IN
63485: IFFALSE 63662
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63487: LD_ADDR_EXP 117
63491: PUSH
63492: LD_EXP 117
63496: PPUSH
63497: LD_VAR 0 3
63501: PPUSH
63502: LD_EXP 117
63506: PUSH
63507: LD_VAR 0 3
63511: ARRAY
63512: PUSH
63513: LD_VAR 0 1
63517: DIFF
63518: PPUSH
63519: CALL_OW 1
63523: ST_TO_ADDR
// if building in mc_lab [ i ] then
63524: LD_VAR 0 1
63528: PUSH
63529: LD_EXP 143
63533: PUSH
63534: LD_VAR 0 3
63538: ARRAY
63539: IN
63540: IFFALSE 63595
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63542: LD_ADDR_EXP 144
63546: PUSH
63547: LD_EXP 144
63551: PPUSH
63552: LD_VAR 0 3
63556: PPUSH
63557: LD_EXP 144
63561: PUSH
63562: LD_VAR 0 3
63566: ARRAY
63567: PPUSH
63568: LD_INT 1
63570: PPUSH
63571: LD_EXP 144
63575: PUSH
63576: LD_VAR 0 3
63580: ARRAY
63581: PPUSH
63582: LD_INT 0
63584: PPUSH
63585: CALL 71755 0 4
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63595: LD_VAR 0 1
63599: PUSH
63600: LD_EXP 110
63604: PUSH
63605: LD_VAR 0 3
63609: ARRAY
63610: IN
63611: NOT
63612: IFFALSE 63658
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63614: LD_ADDR_EXP 110
63618: PUSH
63619: LD_EXP 110
63623: PPUSH
63624: LD_VAR 0 3
63628: PUSH
63629: LD_EXP 110
63633: PUSH
63634: LD_VAR 0 3
63638: ARRAY
63639: PUSH
63640: LD_INT 1
63642: PLUS
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL 72337 0 3
63657: ST_TO_ADDR
// exit ;
63658: POP
63659: POP
63660: GO 63666
// end ; end ;
63662: GO 63466
63664: POP
63665: POP
// end ;
63666: LD_VAR 0 2
63670: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63671: LD_INT 0
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
63677: PPUSH
63678: PPUSH
63679: PPUSH
// if not mc_bases or not skirmish then
63680: LD_EXP 110
63684: NOT
63685: PUSH
63686: LD_EXP 108
63690: NOT
63691: OR
63692: IFFALSE 63696
// exit ;
63694: GO 64357
// for i = 1 to mc_bases do
63696: LD_ADDR_VAR 0 3
63700: PUSH
63701: DOUBLE
63702: LD_INT 1
63704: DEC
63705: ST_TO_ADDR
63706: LD_EXP 110
63710: PUSH
63711: FOR_TO
63712: IFFALSE 64355
// begin if building in mc_construct_list [ i ] then
63714: LD_VAR 0 1
63718: PUSH
63719: LD_EXP 117
63723: PUSH
63724: LD_VAR 0 3
63728: ARRAY
63729: IN
63730: IFFALSE 64353
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63732: LD_ADDR_EXP 117
63736: PUSH
63737: LD_EXP 117
63741: PPUSH
63742: LD_VAR 0 3
63746: PPUSH
63747: LD_EXP 117
63751: PUSH
63752: LD_VAR 0 3
63756: ARRAY
63757: PUSH
63758: LD_VAR 0 1
63762: DIFF
63763: PPUSH
63764: CALL_OW 1
63768: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63769: LD_ADDR_EXP 110
63773: PUSH
63774: LD_EXP 110
63778: PPUSH
63779: LD_VAR 0 3
63783: PUSH
63784: LD_EXP 110
63788: PUSH
63789: LD_VAR 0 3
63793: ARRAY
63794: PUSH
63795: LD_INT 1
63797: PLUS
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PPUSH
63803: LD_VAR 0 1
63807: PPUSH
63808: CALL 72337 0 3
63812: ST_TO_ADDR
// btype := GetBType ( building ) ;
63813: LD_ADDR_VAR 0 5
63817: PUSH
63818: LD_VAR 0 1
63822: PPUSH
63823: CALL_OW 266
63827: ST_TO_ADDR
// side := GetSide ( building ) ;
63828: LD_ADDR_VAR 0 8
63832: PUSH
63833: LD_VAR 0 1
63837: PPUSH
63838: CALL_OW 255
63842: ST_TO_ADDR
// if btype = b_lab then
63843: LD_VAR 0 5
63847: PUSH
63848: LD_INT 6
63850: EQUAL
63851: IFFALSE 63901
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63853: LD_ADDR_EXP 143
63857: PUSH
63858: LD_EXP 143
63862: PPUSH
63863: LD_VAR 0 3
63867: PUSH
63868: LD_EXP 143
63872: PUSH
63873: LD_VAR 0 3
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: PLUS
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: PPUSH
63887: LD_VAR 0 1
63891: PPUSH
63892: CALL 72337 0 3
63896: ST_TO_ADDR
// exit ;
63897: POP
63898: POP
63899: GO 64357
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63901: LD_VAR 0 5
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 2
63911: PUSH
63912: LD_INT 4
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: LIST
63919: IN
63920: IFFALSE 64044
// begin if btype = b_armoury then
63922: LD_VAR 0 5
63926: PUSH
63927: LD_INT 4
63929: EQUAL
63930: IFFALSE 63940
// btype := b_barracks ;
63932: LD_ADDR_VAR 0 5
63936: PUSH
63937: LD_INT 5
63939: ST_TO_ADDR
// if btype = b_depot then
63940: LD_VAR 0 5
63944: PUSH
63945: LD_INT 0
63947: EQUAL
63948: IFFALSE 63958
// btype := b_warehouse ;
63950: LD_ADDR_VAR 0 5
63954: PUSH
63955: LD_INT 1
63957: ST_TO_ADDR
// if btype = b_workshop then
63958: LD_VAR 0 5
63962: PUSH
63963: LD_INT 2
63965: EQUAL
63966: IFFALSE 63976
// btype := b_factory ;
63968: LD_ADDR_VAR 0 5
63972: PUSH
63973: LD_INT 3
63975: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63976: LD_VAR 0 5
63980: PPUSH
63981: LD_VAR 0 8
63985: PPUSH
63986: CALL_OW 323
63990: PUSH
63991: LD_INT 1
63993: EQUAL
63994: IFFALSE 64040
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63996: LD_ADDR_EXP 142
64000: PUSH
64001: LD_EXP 142
64005: PPUSH
64006: LD_VAR 0 3
64010: PUSH
64011: LD_EXP 142
64015: PUSH
64016: LD_VAR 0 3
64020: ARRAY
64021: PUSH
64022: LD_INT 1
64024: PLUS
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PPUSH
64030: LD_VAR 0 1
64034: PPUSH
64035: CALL 72337 0 3
64039: ST_TO_ADDR
// exit ;
64040: POP
64041: POP
64042: GO 64357
// end ; if btype in [ b_bunker , b_turret ] then
64044: LD_VAR 0 5
64048: PUSH
64049: LD_INT 32
64051: PUSH
64052: LD_INT 33
64054: PUSH
64055: EMPTY
64056: LIST
64057: LIST
64058: IN
64059: IFFALSE 64349
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64061: LD_ADDR_EXP 118
64065: PUSH
64066: LD_EXP 118
64070: PPUSH
64071: LD_VAR 0 3
64075: PUSH
64076: LD_EXP 118
64080: PUSH
64081: LD_VAR 0 3
64085: ARRAY
64086: PUSH
64087: LD_INT 1
64089: PLUS
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PPUSH
64095: LD_VAR 0 1
64099: PPUSH
64100: CALL 72337 0 3
64104: ST_TO_ADDR
// if btype = b_bunker then
64105: LD_VAR 0 5
64109: PUSH
64110: LD_INT 32
64112: EQUAL
64113: IFFALSE 64349
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64115: LD_ADDR_EXP 119
64119: PUSH
64120: LD_EXP 119
64124: PPUSH
64125: LD_VAR 0 3
64129: PUSH
64130: LD_EXP 119
64134: PUSH
64135: LD_VAR 0 3
64139: ARRAY
64140: PUSH
64141: LD_INT 1
64143: PLUS
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PPUSH
64149: LD_VAR 0 1
64153: PPUSH
64154: CALL 72337 0 3
64158: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64159: LD_ADDR_VAR 0 6
64163: PUSH
64164: LD_EXP 110
64168: PUSH
64169: LD_VAR 0 3
64173: ARRAY
64174: PPUSH
64175: LD_INT 25
64177: PUSH
64178: LD_INT 1
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PUSH
64185: LD_INT 3
64187: PUSH
64188: LD_INT 54
64190: PUSH
64191: EMPTY
64192: LIST
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PPUSH
64202: CALL_OW 72
64206: ST_TO_ADDR
// if tmp then
64207: LD_VAR 0 6
64211: IFFALSE 64217
// exit ;
64213: POP
64214: POP
64215: GO 64357
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64217: LD_ADDR_VAR 0 6
64221: PUSH
64222: LD_EXP 110
64226: PUSH
64227: LD_VAR 0 3
64231: ARRAY
64232: PPUSH
64233: LD_INT 2
64235: PUSH
64236: LD_INT 30
64238: PUSH
64239: LD_INT 4
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 30
64248: PUSH
64249: LD_INT 5
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: LIST
64260: PPUSH
64261: CALL_OW 72
64265: ST_TO_ADDR
// if not tmp then
64266: LD_VAR 0 6
64270: NOT
64271: IFFALSE 64277
// exit ;
64273: POP
64274: POP
64275: GO 64357
// for j in tmp do
64277: LD_ADDR_VAR 0 4
64281: PUSH
64282: LD_VAR 0 6
64286: PUSH
64287: FOR_IN
64288: IFFALSE 64347
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64290: LD_ADDR_VAR 0 7
64294: PUSH
64295: LD_VAR 0 4
64299: PPUSH
64300: CALL_OW 313
64304: PPUSH
64305: LD_INT 25
64307: PUSH
64308: LD_INT 1
64310: PUSH
64311: EMPTY
64312: LIST
64313: LIST
64314: PPUSH
64315: CALL_OW 72
64319: ST_TO_ADDR
// if units then
64320: LD_VAR 0 7
64324: IFFALSE 64345
// begin ComExitBuilding ( units [ 1 ] ) ;
64326: LD_VAR 0 7
64330: PUSH
64331: LD_INT 1
64333: ARRAY
64334: PPUSH
64335: CALL_OW 122
// exit ;
64339: POP
64340: POP
64341: POP
64342: POP
64343: GO 64357
// end ; end ;
64345: GO 64287
64347: POP
64348: POP
// end ; end ; exit ;
64349: POP
64350: POP
64351: GO 64357
// end ; end ;
64353: GO 63711
64355: POP
64356: POP
// end ;
64357: LD_VAR 0 2
64361: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64362: LD_INT 0
64364: PPUSH
64365: PPUSH
64366: PPUSH
64367: PPUSH
64368: PPUSH
64369: PPUSH
64370: PPUSH
// if not mc_bases or not skirmish then
64371: LD_EXP 110
64375: NOT
64376: PUSH
64377: LD_EXP 108
64381: NOT
64382: OR
64383: IFFALSE 64387
// exit ;
64385: GO 64618
// btype := GetBType ( building ) ;
64387: LD_ADDR_VAR 0 6
64391: PUSH
64392: LD_VAR 0 1
64396: PPUSH
64397: CALL_OW 266
64401: ST_TO_ADDR
// x := GetX ( building ) ;
64402: LD_ADDR_VAR 0 7
64406: PUSH
64407: LD_VAR 0 1
64411: PPUSH
64412: CALL_OW 250
64416: ST_TO_ADDR
// y := GetY ( building ) ;
64417: LD_ADDR_VAR 0 8
64421: PUSH
64422: LD_VAR 0 1
64426: PPUSH
64427: CALL_OW 251
64431: ST_TO_ADDR
// d := GetDir ( building ) ;
64432: LD_ADDR_VAR 0 9
64436: PUSH
64437: LD_VAR 0 1
64441: PPUSH
64442: CALL_OW 254
64446: ST_TO_ADDR
// for i = 1 to mc_bases do
64447: LD_ADDR_VAR 0 4
64451: PUSH
64452: DOUBLE
64453: LD_INT 1
64455: DEC
64456: ST_TO_ADDR
64457: LD_EXP 110
64461: PUSH
64462: FOR_TO
64463: IFFALSE 64616
// begin if not mc_build_list [ i ] then
64465: LD_EXP 115
64469: PUSH
64470: LD_VAR 0 4
64474: ARRAY
64475: NOT
64476: IFFALSE 64480
// continue ;
64478: GO 64462
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64480: LD_VAR 0 6
64484: PUSH
64485: LD_VAR 0 7
64489: PUSH
64490: LD_VAR 0 8
64494: PUSH
64495: LD_VAR 0 9
64499: PUSH
64500: EMPTY
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: PPUSH
64506: LD_EXP 115
64510: PUSH
64511: LD_VAR 0 4
64515: ARRAY
64516: PUSH
64517: LD_INT 1
64519: ARRAY
64520: PPUSH
64521: CALL 78506 0 2
64525: IFFALSE 64614
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64527: LD_ADDR_EXP 115
64531: PUSH
64532: LD_EXP 115
64536: PPUSH
64537: LD_VAR 0 4
64541: PPUSH
64542: LD_EXP 115
64546: PUSH
64547: LD_VAR 0 4
64551: ARRAY
64552: PPUSH
64553: LD_INT 1
64555: PPUSH
64556: CALL_OW 3
64560: PPUSH
64561: CALL_OW 1
64565: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64566: LD_ADDR_EXP 117
64570: PUSH
64571: LD_EXP 117
64575: PPUSH
64576: LD_VAR 0 4
64580: PUSH
64581: LD_EXP 117
64585: PUSH
64586: LD_VAR 0 4
64590: ARRAY
64591: PUSH
64592: LD_INT 1
64594: PLUS
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PPUSH
64600: LD_VAR 0 1
64604: PPUSH
64605: CALL 72337 0 3
64609: ST_TO_ADDR
// exit ;
64610: POP
64611: POP
64612: GO 64618
// end ; end ;
64614: GO 64462
64616: POP
64617: POP
// end ;
64618: LD_VAR 0 3
64622: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64623: LD_INT 0
64625: PPUSH
64626: PPUSH
64627: PPUSH
// if not mc_bases or not skirmish then
64628: LD_EXP 110
64632: NOT
64633: PUSH
64634: LD_EXP 108
64638: NOT
64639: OR
64640: IFFALSE 64644
// exit ;
64642: GO 64834
// for i = 1 to mc_bases do
64644: LD_ADDR_VAR 0 4
64648: PUSH
64649: DOUBLE
64650: LD_INT 1
64652: DEC
64653: ST_TO_ADDR
64654: LD_EXP 110
64658: PUSH
64659: FOR_TO
64660: IFFALSE 64747
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64662: LD_VAR 0 1
64666: PUSH
64667: LD_EXP 118
64671: PUSH
64672: LD_VAR 0 4
64676: ARRAY
64677: IN
64678: PUSH
64679: LD_VAR 0 1
64683: PUSH
64684: LD_EXP 119
64688: PUSH
64689: LD_VAR 0 4
64693: ARRAY
64694: IN
64695: NOT
64696: AND
64697: IFFALSE 64745
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64699: LD_ADDR_EXP 119
64703: PUSH
64704: LD_EXP 119
64708: PPUSH
64709: LD_VAR 0 4
64713: PUSH
64714: LD_EXP 119
64718: PUSH
64719: LD_VAR 0 4
64723: ARRAY
64724: PUSH
64725: LD_INT 1
64727: PLUS
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PPUSH
64733: LD_VAR 0 1
64737: PPUSH
64738: CALL 72337 0 3
64742: ST_TO_ADDR
// break ;
64743: GO 64747
// end ; end ;
64745: GO 64659
64747: POP
64748: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64749: LD_VAR 0 1
64753: PPUSH
64754: CALL_OW 257
64758: PUSH
64759: LD_EXP 136
64763: IN
64764: PUSH
64765: LD_VAR 0 1
64769: PPUSH
64770: CALL_OW 266
64774: PUSH
64775: LD_INT 5
64777: EQUAL
64778: AND
64779: PUSH
64780: LD_VAR 0 2
64784: PPUSH
64785: CALL_OW 110
64789: PUSH
64790: LD_INT 18
64792: NONEQUAL
64793: AND
64794: IFFALSE 64834
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64796: LD_VAR 0 2
64800: PPUSH
64801: CALL_OW 257
64805: PUSH
64806: LD_INT 5
64808: PUSH
64809: LD_INT 8
64811: PUSH
64812: LD_INT 9
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: LIST
64819: IN
64820: IFFALSE 64834
// SetClass ( unit , 1 ) ;
64822: LD_VAR 0 2
64826: PPUSH
64827: LD_INT 1
64829: PPUSH
64830: CALL_OW 336
// end ;
64834: LD_VAR 0 3
64838: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64839: LD_INT 0
64841: PPUSH
64842: PPUSH
// if not mc_bases or not skirmish then
64843: LD_EXP 110
64847: NOT
64848: PUSH
64849: LD_EXP 108
64853: NOT
64854: OR
64855: IFFALSE 64859
// exit ;
64857: GO 64975
// if GetLives ( abandoned_vehicle ) > 250 then
64859: LD_VAR 0 2
64863: PPUSH
64864: CALL_OW 256
64868: PUSH
64869: LD_INT 250
64871: GREATER
64872: IFFALSE 64876
// exit ;
64874: GO 64975
// for i = 1 to mc_bases do
64876: LD_ADDR_VAR 0 6
64880: PUSH
64881: DOUBLE
64882: LD_INT 1
64884: DEC
64885: ST_TO_ADDR
64886: LD_EXP 110
64890: PUSH
64891: FOR_TO
64892: IFFALSE 64973
// begin if driver in mc_bases [ i ] then
64894: LD_VAR 0 1
64898: PUSH
64899: LD_EXP 110
64903: PUSH
64904: LD_VAR 0 6
64908: ARRAY
64909: IN
64910: IFFALSE 64971
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64912: LD_VAR 0 1
64916: PPUSH
64917: LD_EXP 110
64921: PUSH
64922: LD_VAR 0 6
64926: ARRAY
64927: PPUSH
64928: LD_INT 2
64930: PUSH
64931: LD_INT 30
64933: PUSH
64934: LD_INT 0
64936: PUSH
64937: EMPTY
64938: LIST
64939: LIST
64940: PUSH
64941: LD_INT 30
64943: PUSH
64944: LD_INT 1
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: EMPTY
64952: LIST
64953: LIST
64954: LIST
64955: PPUSH
64956: CALL_OW 72
64960: PUSH
64961: LD_INT 1
64963: ARRAY
64964: PPUSH
64965: CALL_OW 112
// break ;
64969: GO 64973
// end ; end ;
64971: GO 64891
64973: POP
64974: POP
// end ; end_of_file
64975: LD_VAR 0 5
64979: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64980: LD_INT 0
64982: PPUSH
64983: PPUSH
// if exist_mode then
64984: LD_VAR 0 2
64988: IFFALSE 65013
// unit := CreateCharacter ( prefix & ident ) else
64990: LD_ADDR_VAR 0 5
64994: PUSH
64995: LD_VAR 0 3
64999: PUSH
65000: LD_VAR 0 1
65004: STR
65005: PPUSH
65006: CALL_OW 34
65010: ST_TO_ADDR
65011: GO 65028
// unit := NewCharacter ( ident ) ;
65013: LD_ADDR_VAR 0 5
65017: PUSH
65018: LD_VAR 0 1
65022: PPUSH
65023: CALL_OW 25
65027: ST_TO_ADDR
// result := unit ;
65028: LD_ADDR_VAR 0 4
65032: PUSH
65033: LD_VAR 0 5
65037: ST_TO_ADDR
// end ;
65038: LD_VAR 0 4
65042: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65043: LD_INT 0
65045: PPUSH
65046: PPUSH
// if not side or not nation then
65047: LD_VAR 0 1
65051: NOT
65052: PUSH
65053: LD_VAR 0 2
65057: NOT
65058: OR
65059: IFFALSE 65063
// exit ;
65061: GO 65827
// case nation of nation_american :
65063: LD_VAR 0 2
65067: PUSH
65068: LD_INT 1
65070: DOUBLE
65071: EQUAL
65072: IFTRUE 65076
65074: GO 65290
65076: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65077: LD_ADDR_VAR 0 4
65081: PUSH
65082: LD_INT 35
65084: PUSH
65085: LD_INT 45
65087: PUSH
65088: LD_INT 46
65090: PUSH
65091: LD_INT 47
65093: PUSH
65094: LD_INT 82
65096: PUSH
65097: LD_INT 83
65099: PUSH
65100: LD_INT 84
65102: PUSH
65103: LD_INT 85
65105: PUSH
65106: LD_INT 86
65108: PUSH
65109: LD_INT 1
65111: PUSH
65112: LD_INT 2
65114: PUSH
65115: LD_INT 6
65117: PUSH
65118: LD_INT 15
65120: PUSH
65121: LD_INT 16
65123: PUSH
65124: LD_INT 7
65126: PUSH
65127: LD_INT 12
65129: PUSH
65130: LD_INT 13
65132: PUSH
65133: LD_INT 10
65135: PUSH
65136: LD_INT 14
65138: PUSH
65139: LD_INT 20
65141: PUSH
65142: LD_INT 21
65144: PUSH
65145: LD_INT 22
65147: PUSH
65148: LD_INT 25
65150: PUSH
65151: LD_INT 32
65153: PUSH
65154: LD_INT 27
65156: PUSH
65157: LD_INT 36
65159: PUSH
65160: LD_INT 69
65162: PUSH
65163: LD_INT 39
65165: PUSH
65166: LD_INT 34
65168: PUSH
65169: LD_INT 40
65171: PUSH
65172: LD_INT 48
65174: PUSH
65175: LD_INT 49
65177: PUSH
65178: LD_INT 50
65180: PUSH
65181: LD_INT 51
65183: PUSH
65184: LD_INT 52
65186: PUSH
65187: LD_INT 53
65189: PUSH
65190: LD_INT 54
65192: PUSH
65193: LD_INT 55
65195: PUSH
65196: LD_INT 56
65198: PUSH
65199: LD_INT 57
65201: PUSH
65202: LD_INT 58
65204: PUSH
65205: LD_INT 59
65207: PUSH
65208: LD_INT 60
65210: PUSH
65211: LD_INT 61
65213: PUSH
65214: LD_INT 62
65216: PUSH
65217: LD_INT 80
65219: PUSH
65220: LD_INT 82
65222: PUSH
65223: LD_INT 83
65225: PUSH
65226: LD_INT 84
65228: PUSH
65229: LD_INT 85
65231: PUSH
65232: LD_INT 86
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: LIST
65247: LIST
65248: LIST
65249: LIST
65250: LIST
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: LIST
65263: LIST
65264: LIST
65265: LIST
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: LIST
65275: LIST
65276: LIST
65277: LIST
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: LIST
65285: LIST
65286: LIST
65287: ST_TO_ADDR
65288: GO 65751
65290: LD_INT 2
65292: DOUBLE
65293: EQUAL
65294: IFTRUE 65298
65296: GO 65520
65298: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65299: LD_ADDR_VAR 0 4
65303: PUSH
65304: LD_INT 35
65306: PUSH
65307: LD_INT 45
65309: PUSH
65310: LD_INT 46
65312: PUSH
65313: LD_INT 47
65315: PUSH
65316: LD_INT 82
65318: PUSH
65319: LD_INT 83
65321: PUSH
65322: LD_INT 84
65324: PUSH
65325: LD_INT 85
65327: PUSH
65328: LD_INT 87
65330: PUSH
65331: LD_INT 70
65333: PUSH
65334: LD_INT 1
65336: PUSH
65337: LD_INT 11
65339: PUSH
65340: LD_INT 3
65342: PUSH
65343: LD_INT 4
65345: PUSH
65346: LD_INT 5
65348: PUSH
65349: LD_INT 6
65351: PUSH
65352: LD_INT 15
65354: PUSH
65355: LD_INT 18
65357: PUSH
65358: LD_INT 7
65360: PUSH
65361: LD_INT 17
65363: PUSH
65364: LD_INT 8
65366: PUSH
65367: LD_INT 20
65369: PUSH
65370: LD_INT 21
65372: PUSH
65373: LD_INT 22
65375: PUSH
65376: LD_INT 72
65378: PUSH
65379: LD_INT 26
65381: PUSH
65382: LD_INT 69
65384: PUSH
65385: LD_INT 39
65387: PUSH
65388: LD_INT 40
65390: PUSH
65391: LD_INT 41
65393: PUSH
65394: LD_INT 42
65396: PUSH
65397: LD_INT 43
65399: PUSH
65400: LD_INT 48
65402: PUSH
65403: LD_INT 49
65405: PUSH
65406: LD_INT 50
65408: PUSH
65409: LD_INT 51
65411: PUSH
65412: LD_INT 52
65414: PUSH
65415: LD_INT 53
65417: PUSH
65418: LD_INT 54
65420: PUSH
65421: LD_INT 55
65423: PUSH
65424: LD_INT 56
65426: PUSH
65427: LD_INT 60
65429: PUSH
65430: LD_INT 61
65432: PUSH
65433: LD_INT 62
65435: PUSH
65436: LD_INT 66
65438: PUSH
65439: LD_INT 67
65441: PUSH
65442: LD_INT 68
65444: PUSH
65445: LD_INT 81
65447: PUSH
65448: LD_INT 82
65450: PUSH
65451: LD_INT 83
65453: PUSH
65454: LD_INT 84
65456: PUSH
65457: LD_INT 85
65459: PUSH
65460: LD_INT 87
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: LIST
65492: LIST
65493: LIST
65494: LIST
65495: LIST
65496: LIST
65497: LIST
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: LIST
65503: LIST
65504: LIST
65505: LIST
65506: LIST
65507: LIST
65508: LIST
65509: LIST
65510: LIST
65511: LIST
65512: LIST
65513: LIST
65514: LIST
65515: LIST
65516: LIST
65517: ST_TO_ADDR
65518: GO 65751
65520: LD_INT 3
65522: DOUBLE
65523: EQUAL
65524: IFTRUE 65528
65526: GO 65750
65528: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65529: LD_ADDR_VAR 0 4
65533: PUSH
65534: LD_INT 46
65536: PUSH
65537: LD_INT 47
65539: PUSH
65540: LD_INT 1
65542: PUSH
65543: LD_INT 2
65545: PUSH
65546: LD_INT 82
65548: PUSH
65549: LD_INT 83
65551: PUSH
65552: LD_INT 84
65554: PUSH
65555: LD_INT 85
65557: PUSH
65558: LD_INT 86
65560: PUSH
65561: LD_INT 11
65563: PUSH
65564: LD_INT 9
65566: PUSH
65567: LD_INT 20
65569: PUSH
65570: LD_INT 19
65572: PUSH
65573: LD_INT 21
65575: PUSH
65576: LD_INT 24
65578: PUSH
65579: LD_INT 22
65581: PUSH
65582: LD_INT 25
65584: PUSH
65585: LD_INT 28
65587: PUSH
65588: LD_INT 29
65590: PUSH
65591: LD_INT 30
65593: PUSH
65594: LD_INT 31
65596: PUSH
65597: LD_INT 37
65599: PUSH
65600: LD_INT 38
65602: PUSH
65603: LD_INT 32
65605: PUSH
65606: LD_INT 27
65608: PUSH
65609: LD_INT 33
65611: PUSH
65612: LD_INT 69
65614: PUSH
65615: LD_INT 39
65617: PUSH
65618: LD_INT 34
65620: PUSH
65621: LD_INT 40
65623: PUSH
65624: LD_INT 71
65626: PUSH
65627: LD_INT 23
65629: PUSH
65630: LD_INT 44
65632: PUSH
65633: LD_INT 48
65635: PUSH
65636: LD_INT 49
65638: PUSH
65639: LD_INT 50
65641: PUSH
65642: LD_INT 51
65644: PUSH
65645: LD_INT 52
65647: PUSH
65648: LD_INT 53
65650: PUSH
65651: LD_INT 54
65653: PUSH
65654: LD_INT 55
65656: PUSH
65657: LD_INT 56
65659: PUSH
65660: LD_INT 57
65662: PUSH
65663: LD_INT 58
65665: PUSH
65666: LD_INT 59
65668: PUSH
65669: LD_INT 63
65671: PUSH
65672: LD_INT 64
65674: PUSH
65675: LD_INT 65
65677: PUSH
65678: LD_INT 82
65680: PUSH
65681: LD_INT 83
65683: PUSH
65684: LD_INT 84
65686: PUSH
65687: LD_INT 85
65689: PUSH
65690: LD_INT 86
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: LIST
65713: LIST
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: ST_TO_ADDR
65748: GO 65751
65750: POP
// if state > - 1 and state < 3 then
65751: LD_VAR 0 3
65755: PUSH
65756: LD_INT 1
65758: NEG
65759: GREATER
65760: PUSH
65761: LD_VAR 0 3
65765: PUSH
65766: LD_INT 3
65768: LESS
65769: AND
65770: IFFALSE 65827
// for i in result do
65772: LD_ADDR_VAR 0 5
65776: PUSH
65777: LD_VAR 0 4
65781: PUSH
65782: FOR_IN
65783: IFFALSE 65825
// if GetTech ( i , side ) <> state then
65785: LD_VAR 0 5
65789: PPUSH
65790: LD_VAR 0 1
65794: PPUSH
65795: CALL_OW 321
65799: PUSH
65800: LD_VAR 0 3
65804: NONEQUAL
65805: IFFALSE 65823
// result := result diff i ;
65807: LD_ADDR_VAR 0 4
65811: PUSH
65812: LD_VAR 0 4
65816: PUSH
65817: LD_VAR 0 5
65821: DIFF
65822: ST_TO_ADDR
65823: GO 65782
65825: POP
65826: POP
// end ;
65827: LD_VAR 0 4
65831: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65832: LD_INT 0
65834: PPUSH
65835: PPUSH
65836: PPUSH
// result := true ;
65837: LD_ADDR_VAR 0 3
65841: PUSH
65842: LD_INT 1
65844: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65845: LD_ADDR_VAR 0 5
65849: PUSH
65850: LD_VAR 0 2
65854: PPUSH
65855: CALL_OW 480
65859: ST_TO_ADDR
// if not tmp then
65860: LD_VAR 0 5
65864: NOT
65865: IFFALSE 65869
// exit ;
65867: GO 65918
// for i in tmp do
65869: LD_ADDR_VAR 0 4
65873: PUSH
65874: LD_VAR 0 5
65878: PUSH
65879: FOR_IN
65880: IFFALSE 65916
// if GetTech ( i , side ) <> state_researched then
65882: LD_VAR 0 4
65886: PPUSH
65887: LD_VAR 0 1
65891: PPUSH
65892: CALL_OW 321
65896: PUSH
65897: LD_INT 2
65899: NONEQUAL
65900: IFFALSE 65914
// begin result := false ;
65902: LD_ADDR_VAR 0 3
65906: PUSH
65907: LD_INT 0
65909: ST_TO_ADDR
// exit ;
65910: POP
65911: POP
65912: GO 65918
// end ;
65914: GO 65879
65916: POP
65917: POP
// end ;
65918: LD_VAR 0 3
65922: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65923: LD_INT 0
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65938: LD_VAR 0 1
65942: NOT
65943: PUSH
65944: LD_VAR 0 1
65948: PPUSH
65949: CALL_OW 257
65953: PUSH
65954: LD_INT 9
65956: NONEQUAL
65957: OR
65958: IFFALSE 65962
// exit ;
65960: GO 66535
// side := GetSide ( unit ) ;
65962: LD_ADDR_VAR 0 9
65966: PUSH
65967: LD_VAR 0 1
65971: PPUSH
65972: CALL_OW 255
65976: ST_TO_ADDR
// tech_space := tech_spacanom ;
65977: LD_ADDR_VAR 0 12
65981: PUSH
65982: LD_INT 29
65984: ST_TO_ADDR
// tech_time := tech_taurad ;
65985: LD_ADDR_VAR 0 13
65989: PUSH
65990: LD_INT 28
65992: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65993: LD_ADDR_VAR 0 11
65997: PUSH
65998: LD_VAR 0 1
66002: PPUSH
66003: CALL_OW 310
66007: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66008: LD_VAR 0 11
66012: PPUSH
66013: CALL_OW 247
66017: PUSH
66018: LD_INT 2
66020: EQUAL
66021: IFFALSE 66025
// exit ;
66023: GO 66535
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66025: LD_ADDR_VAR 0 8
66029: PUSH
66030: LD_INT 81
66032: PUSH
66033: LD_VAR 0 9
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PUSH
66042: LD_INT 3
66044: PUSH
66045: LD_INT 21
66047: PUSH
66048: LD_INT 3
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: EMPTY
66060: LIST
66061: LIST
66062: PPUSH
66063: CALL_OW 69
66067: ST_TO_ADDR
// if not tmp then
66068: LD_VAR 0 8
66072: NOT
66073: IFFALSE 66077
// exit ;
66075: GO 66535
// if in_unit then
66077: LD_VAR 0 11
66081: IFFALSE 66105
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66083: LD_ADDR_VAR 0 10
66087: PUSH
66088: LD_VAR 0 8
66092: PPUSH
66093: LD_VAR 0 11
66097: PPUSH
66098: CALL_OW 74
66102: ST_TO_ADDR
66103: GO 66125
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66105: LD_ADDR_VAR 0 10
66109: PUSH
66110: LD_VAR 0 8
66114: PPUSH
66115: LD_VAR 0 1
66119: PPUSH
66120: CALL_OW 74
66124: ST_TO_ADDR
// if not enemy then
66125: LD_VAR 0 10
66129: NOT
66130: IFFALSE 66134
// exit ;
66132: GO 66535
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66134: LD_VAR 0 11
66138: PUSH
66139: LD_VAR 0 11
66143: PPUSH
66144: LD_VAR 0 10
66148: PPUSH
66149: CALL_OW 296
66153: PUSH
66154: LD_INT 13
66156: GREATER
66157: AND
66158: PUSH
66159: LD_VAR 0 1
66163: PPUSH
66164: LD_VAR 0 10
66168: PPUSH
66169: CALL_OW 296
66173: PUSH
66174: LD_INT 12
66176: GREATER
66177: OR
66178: IFFALSE 66182
// exit ;
66180: GO 66535
// missile := [ 1 ] ;
66182: LD_ADDR_VAR 0 14
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: EMPTY
66191: LIST
66192: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66193: LD_VAR 0 9
66197: PPUSH
66198: LD_VAR 0 12
66202: PPUSH
66203: CALL_OW 325
66207: IFFALSE 66236
// missile := Insert ( missile , missile + 1 , 2 ) ;
66209: LD_ADDR_VAR 0 14
66213: PUSH
66214: LD_VAR 0 14
66218: PPUSH
66219: LD_VAR 0 14
66223: PUSH
66224: LD_INT 1
66226: PLUS
66227: PPUSH
66228: LD_INT 2
66230: PPUSH
66231: CALL_OW 2
66235: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66236: LD_VAR 0 9
66240: PPUSH
66241: LD_VAR 0 13
66245: PPUSH
66246: CALL_OW 325
66250: PUSH
66251: LD_VAR 0 10
66255: PPUSH
66256: CALL_OW 255
66260: PPUSH
66261: LD_VAR 0 13
66265: PPUSH
66266: CALL_OW 325
66270: NOT
66271: AND
66272: IFFALSE 66301
// missile := Insert ( missile , missile + 1 , 3 ) ;
66274: LD_ADDR_VAR 0 14
66278: PUSH
66279: LD_VAR 0 14
66283: PPUSH
66284: LD_VAR 0 14
66288: PUSH
66289: LD_INT 1
66291: PLUS
66292: PPUSH
66293: LD_INT 3
66295: PPUSH
66296: CALL_OW 2
66300: ST_TO_ADDR
// if missile < 2 then
66301: LD_VAR 0 14
66305: PUSH
66306: LD_INT 2
66308: LESS
66309: IFFALSE 66313
// exit ;
66311: GO 66535
// x := GetX ( enemy ) ;
66313: LD_ADDR_VAR 0 4
66317: PUSH
66318: LD_VAR 0 10
66322: PPUSH
66323: CALL_OW 250
66327: ST_TO_ADDR
// y := GetY ( enemy ) ;
66328: LD_ADDR_VAR 0 5
66332: PUSH
66333: LD_VAR 0 10
66337: PPUSH
66338: CALL_OW 251
66342: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66343: LD_ADDR_VAR 0 6
66347: PUSH
66348: LD_VAR 0 4
66352: PUSH
66353: LD_INT 1
66355: NEG
66356: PPUSH
66357: LD_INT 1
66359: PPUSH
66360: CALL_OW 12
66364: PLUS
66365: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66366: LD_ADDR_VAR 0 7
66370: PUSH
66371: LD_VAR 0 5
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PPUSH
66380: LD_INT 1
66382: PPUSH
66383: CALL_OW 12
66387: PLUS
66388: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66389: LD_VAR 0 6
66393: PPUSH
66394: LD_VAR 0 7
66398: PPUSH
66399: CALL_OW 488
66403: NOT
66404: IFFALSE 66426
// begin _x := x ;
66406: LD_ADDR_VAR 0 6
66410: PUSH
66411: LD_VAR 0 4
66415: ST_TO_ADDR
// _y := y ;
66416: LD_ADDR_VAR 0 7
66420: PUSH
66421: LD_VAR 0 5
66425: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66426: LD_ADDR_VAR 0 3
66430: PUSH
66431: LD_INT 1
66433: PPUSH
66434: LD_VAR 0 14
66438: PPUSH
66439: CALL_OW 12
66443: ST_TO_ADDR
// case i of 1 :
66444: LD_VAR 0 3
66448: PUSH
66449: LD_INT 1
66451: DOUBLE
66452: EQUAL
66453: IFTRUE 66457
66455: GO 66474
66457: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66458: LD_VAR 0 1
66462: PPUSH
66463: LD_VAR 0 10
66467: PPUSH
66468: CALL_OW 115
66472: GO 66535
66474: LD_INT 2
66476: DOUBLE
66477: EQUAL
66478: IFTRUE 66482
66480: GO 66504
66482: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66483: LD_VAR 0 1
66487: PPUSH
66488: LD_VAR 0 6
66492: PPUSH
66493: LD_VAR 0 7
66497: PPUSH
66498: CALL_OW 153
66502: GO 66535
66504: LD_INT 3
66506: DOUBLE
66507: EQUAL
66508: IFTRUE 66512
66510: GO 66534
66512: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66513: LD_VAR 0 1
66517: PPUSH
66518: LD_VAR 0 6
66522: PPUSH
66523: LD_VAR 0 7
66527: PPUSH
66528: CALL_OW 154
66532: GO 66535
66534: POP
// end ;
66535: LD_VAR 0 2
66539: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66540: LD_INT 0
66542: PPUSH
66543: PPUSH
66544: PPUSH
66545: PPUSH
66546: PPUSH
66547: PPUSH
// if not unit or not building then
66548: LD_VAR 0 1
66552: NOT
66553: PUSH
66554: LD_VAR 0 2
66558: NOT
66559: OR
66560: IFFALSE 66564
// exit ;
66562: GO 66722
// x := GetX ( building ) ;
66564: LD_ADDR_VAR 0 5
66568: PUSH
66569: LD_VAR 0 2
66573: PPUSH
66574: CALL_OW 250
66578: ST_TO_ADDR
// y := GetY ( building ) ;
66579: LD_ADDR_VAR 0 6
66583: PUSH
66584: LD_VAR 0 2
66588: PPUSH
66589: CALL_OW 251
66593: ST_TO_ADDR
// for i = 0 to 5 do
66594: LD_ADDR_VAR 0 4
66598: PUSH
66599: DOUBLE
66600: LD_INT 0
66602: DEC
66603: ST_TO_ADDR
66604: LD_INT 5
66606: PUSH
66607: FOR_TO
66608: IFFALSE 66720
// begin _x := ShiftX ( x , i , 3 ) ;
66610: LD_ADDR_VAR 0 7
66614: PUSH
66615: LD_VAR 0 5
66619: PPUSH
66620: LD_VAR 0 4
66624: PPUSH
66625: LD_INT 3
66627: PPUSH
66628: CALL_OW 272
66632: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66633: LD_ADDR_VAR 0 8
66637: PUSH
66638: LD_VAR 0 6
66642: PPUSH
66643: LD_VAR 0 4
66647: PPUSH
66648: LD_INT 3
66650: PPUSH
66651: CALL_OW 273
66655: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66656: LD_VAR 0 7
66660: PPUSH
66661: LD_VAR 0 8
66665: PPUSH
66666: CALL_OW 488
66670: NOT
66671: IFFALSE 66675
// continue ;
66673: GO 66607
// if HexInfo ( _x , _y ) = 0 then
66675: LD_VAR 0 7
66679: PPUSH
66680: LD_VAR 0 8
66684: PPUSH
66685: CALL_OW 428
66689: PUSH
66690: LD_INT 0
66692: EQUAL
66693: IFFALSE 66718
// begin ComMoveXY ( unit , _x , _y ) ;
66695: LD_VAR 0 1
66699: PPUSH
66700: LD_VAR 0 7
66704: PPUSH
66705: LD_VAR 0 8
66709: PPUSH
66710: CALL_OW 111
// exit ;
66714: POP
66715: POP
66716: GO 66722
// end ; end ;
66718: GO 66607
66720: POP
66721: POP
// end ;
66722: LD_VAR 0 3
66726: RET
// export function ScanBase ( side , base_area ) ; begin
66727: LD_INT 0
66729: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66730: LD_ADDR_VAR 0 3
66734: PUSH
66735: LD_VAR 0 2
66739: PPUSH
66740: LD_INT 81
66742: PUSH
66743: LD_VAR 0 1
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PPUSH
66752: CALL_OW 70
66756: ST_TO_ADDR
// end ;
66757: LD_VAR 0 3
66761: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66762: LD_INT 0
66764: PPUSH
66765: PPUSH
66766: PPUSH
66767: PPUSH
66768: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66769: LD_VAR 0 1
66773: NOT
66774: PUSH
66775: LD_EXP 110
66779: PUSH
66780: LD_VAR 0 1
66784: ARRAY
66785: NOT
66786: OR
66787: PUSH
66788: LD_VAR 0 2
66792: NOT
66793: OR
66794: PUSH
66795: LD_VAR 0 3
66799: NOT
66800: OR
66801: IFFALSE 66805
// exit ;
66803: GO 67318
// side := mc_sides [ base ] ;
66805: LD_ADDR_VAR 0 6
66809: PUSH
66810: LD_EXP 136
66814: PUSH
66815: LD_VAR 0 1
66819: ARRAY
66820: ST_TO_ADDR
// if not side then
66821: LD_VAR 0 6
66825: NOT
66826: IFFALSE 66830
// exit ;
66828: GO 67318
// for i in solds do
66830: LD_ADDR_VAR 0 7
66834: PUSH
66835: LD_VAR 0 2
66839: PUSH
66840: FOR_IN
66841: IFFALSE 66902
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66843: LD_VAR 0 7
66847: PPUSH
66848: CALL_OW 310
66852: PPUSH
66853: CALL_OW 266
66857: PUSH
66858: LD_INT 32
66860: PUSH
66861: LD_INT 31
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: IN
66868: IFFALSE 66888
// solds := solds diff i else
66870: LD_ADDR_VAR 0 2
66874: PUSH
66875: LD_VAR 0 2
66879: PUSH
66880: LD_VAR 0 7
66884: DIFF
66885: ST_TO_ADDR
66886: GO 66900
// SetTag ( i , 18 ) ;
66888: LD_VAR 0 7
66892: PPUSH
66893: LD_INT 18
66895: PPUSH
66896: CALL_OW 109
66900: GO 66840
66902: POP
66903: POP
// if not solds then
66904: LD_VAR 0 2
66908: NOT
66909: IFFALSE 66913
// exit ;
66911: GO 67318
// repeat wait ( 0 0$1 ) ;
66913: LD_INT 35
66915: PPUSH
66916: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66920: LD_ADDR_VAR 0 5
66924: PUSH
66925: LD_VAR 0 6
66929: PPUSH
66930: LD_VAR 0 3
66934: PPUSH
66935: CALL 66727 0 2
66939: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66940: LD_EXP 110
66944: PUSH
66945: LD_VAR 0 1
66949: ARRAY
66950: NOT
66951: PUSH
66952: LD_EXP 110
66956: PUSH
66957: LD_VAR 0 1
66961: ARRAY
66962: PUSH
66963: EMPTY
66964: EQUAL
66965: OR
66966: IFFALSE 67003
// begin for i in solds do
66968: LD_ADDR_VAR 0 7
66972: PUSH
66973: LD_VAR 0 2
66977: PUSH
66978: FOR_IN
66979: IFFALSE 66992
// ComStop ( i ) ;
66981: LD_VAR 0 7
66985: PPUSH
66986: CALL_OW 141
66990: GO 66978
66992: POP
66993: POP
// solds := [ ] ;
66994: LD_ADDR_VAR 0 2
66998: PUSH
66999: EMPTY
67000: ST_TO_ADDR
// exit ;
67001: GO 67318
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
67003: LD_VAR 0 5
67007: NOT
67008: PUSH
67009: LD_VAR 0 5
67013: PUSH
67014: LD_INT 3
67016: GREATER
67017: OR
67018: PUSH
67019: LD_EXP 132
67023: PUSH
67024: LD_VAR 0 1
67028: ARRAY
67029: OR
67030: IFFALSE 67071
// begin for i in solds do
67032: LD_ADDR_VAR 0 7
67036: PUSH
67037: LD_VAR 0 2
67041: PUSH
67042: FOR_IN
67043: IFFALSE 67067
// if HasTask ( i ) then
67045: LD_VAR 0 7
67049: PPUSH
67050: CALL_OW 314
67054: IFFALSE 67065
// ComStop ( i ) ;
67056: LD_VAR 0 7
67060: PPUSH
67061: CALL_OW 141
67065: GO 67042
67067: POP
67068: POP
// break ;
67069: GO 67306
// end ; for i in solds do
67071: LD_ADDR_VAR 0 7
67075: PUSH
67076: LD_VAR 0 2
67080: PUSH
67081: FOR_IN
67082: IFFALSE 67298
// begin if IsInUnit ( i ) then
67084: LD_VAR 0 7
67088: PPUSH
67089: CALL_OW 310
67093: IFFALSE 67104
// ComExitBuilding ( i ) ;
67095: LD_VAR 0 7
67099: PPUSH
67100: CALL_OW 122
// if GetLives ( i ) > 333 then
67104: LD_VAR 0 7
67108: PPUSH
67109: CALL_OW 256
67113: PUSH
67114: LD_INT 333
67116: GREATER
67117: IFFALSE 67145
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
67119: LD_VAR 0 7
67123: PPUSH
67124: LD_VAR 0 5
67128: PPUSH
67129: LD_VAR 0 7
67133: PPUSH
67134: CALL_OW 74
67138: PPUSH
67139: CALL_OW 115
67143: GO 67296
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
67145: LD_ADDR_VAR 0 8
67149: PUSH
67150: LD_EXP 110
67154: PUSH
67155: LD_VAR 0 1
67159: ARRAY
67160: PPUSH
67161: LD_INT 2
67163: PUSH
67164: LD_INT 30
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 30
67176: PUSH
67177: LD_INT 1
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 30
67186: PUSH
67187: LD_INT 6
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: PPUSH
67200: CALL_OW 72
67204: PPUSH
67205: LD_VAR 0 7
67209: PPUSH
67210: CALL_OW 74
67214: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
67215: LD_VAR 0 7
67219: PPUSH
67220: LD_VAR 0 8
67224: PPUSH
67225: CALL_OW 250
67229: PPUSH
67230: LD_INT 3
67232: PPUSH
67233: LD_INT 5
67235: PPUSH
67236: CALL_OW 272
67240: PPUSH
67241: LD_VAR 0 8
67245: PPUSH
67246: CALL_OW 251
67250: PPUSH
67251: LD_INT 3
67253: PPUSH
67254: LD_INT 5
67256: PPUSH
67257: CALL_OW 273
67261: PPUSH
67262: CALL_OW 111
// SetTag ( i , 0 ) ;
67266: LD_VAR 0 7
67270: PPUSH
67271: LD_INT 0
67273: PPUSH
67274: CALL_OW 109
// solds := solds diff i ;
67278: LD_ADDR_VAR 0 2
67282: PUSH
67283: LD_VAR 0 2
67287: PUSH
67288: LD_VAR 0 7
67292: DIFF
67293: ST_TO_ADDR
// continue ;
67294: GO 67081
// end ; end ;
67296: GO 67081
67298: POP
67299: POP
// until solds ;
67300: LD_VAR 0 2
67304: IFFALSE 66913
// MC_Reset ( base , 18 ) ;
67306: LD_VAR 0 1
67310: PPUSH
67311: LD_INT 18
67313: PPUSH
67314: CALL 39019 0 2
// end ;
67318: LD_VAR 0 4
67322: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67323: LD_INT 0
67325: PPUSH
67326: PPUSH
67327: PPUSH
67328: PPUSH
67329: PPUSH
67330: PPUSH
67331: PPUSH
67332: PPUSH
67333: PPUSH
67334: PPUSH
67335: PPUSH
67336: PPUSH
67337: PPUSH
67338: PPUSH
67339: PPUSH
67340: PPUSH
67341: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67342: LD_ADDR_VAR 0 13
67346: PUSH
67347: LD_EXP 110
67351: PUSH
67352: LD_VAR 0 1
67356: ARRAY
67357: PPUSH
67358: LD_INT 25
67360: PUSH
67361: LD_INT 3
67363: PUSH
67364: EMPTY
67365: LIST
67366: LIST
67367: PPUSH
67368: CALL_OW 72
67372: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67373: LD_EXP 150
67377: PUSH
67378: LD_VAR 0 1
67382: ARRAY
67383: IFFALSE 67407
// mechs := mechs diff mc_remote_driver [ base ] ;
67385: LD_ADDR_VAR 0 13
67389: PUSH
67390: LD_VAR 0 13
67394: PUSH
67395: LD_EXP 150
67399: PUSH
67400: LD_VAR 0 1
67404: ARRAY
67405: DIFF
67406: ST_TO_ADDR
// for i in mechs do
67407: LD_ADDR_VAR 0 5
67411: PUSH
67412: LD_VAR 0 13
67416: PUSH
67417: FOR_IN
67418: IFFALSE 67453
// if GetTag ( i ) > 0 then
67420: LD_VAR 0 5
67424: PPUSH
67425: CALL_OW 110
67429: PUSH
67430: LD_INT 0
67432: GREATER
67433: IFFALSE 67451
// mechs := mechs diff i ;
67435: LD_ADDR_VAR 0 13
67439: PUSH
67440: LD_VAR 0 13
67444: PUSH
67445: LD_VAR 0 5
67449: DIFF
67450: ST_TO_ADDR
67451: GO 67417
67453: POP
67454: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67455: LD_ADDR_VAR 0 9
67459: PUSH
67460: LD_EXP 110
67464: PUSH
67465: LD_VAR 0 1
67469: ARRAY
67470: PPUSH
67471: LD_INT 2
67473: PUSH
67474: LD_INT 25
67476: PUSH
67477: LD_INT 1
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 25
67486: PUSH
67487: LD_INT 5
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 25
67496: PUSH
67497: LD_INT 8
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 25
67506: PUSH
67507: LD_INT 9
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: EMPTY
67515: LIST
67516: LIST
67517: LIST
67518: LIST
67519: LIST
67520: PPUSH
67521: CALL_OW 72
67525: ST_TO_ADDR
// if not defenders and not solds then
67526: LD_VAR 0 2
67530: NOT
67531: PUSH
67532: LD_VAR 0 9
67536: NOT
67537: AND
67538: IFFALSE 67542
// exit ;
67540: GO 69168
// depot_under_attack := false ;
67542: LD_ADDR_VAR 0 17
67546: PUSH
67547: LD_INT 0
67549: ST_TO_ADDR
// sold_defenders := [ ] ;
67550: LD_ADDR_VAR 0 18
67554: PUSH
67555: EMPTY
67556: ST_TO_ADDR
// if mechs then
67557: LD_VAR 0 13
67561: IFFALSE 67690
// for i in defenders do
67563: LD_ADDR_VAR 0 5
67567: PUSH
67568: LD_VAR 0 2
67572: PUSH
67573: FOR_IN
67574: IFFALSE 67688
// begin SetTag ( i , 20 ) ;
67576: LD_VAR 0 5
67580: PPUSH
67581: LD_INT 20
67583: PPUSH
67584: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67588: LD_VAR 0 5
67592: PPUSH
67593: CALL_OW 263
67597: PUSH
67598: LD_INT 1
67600: EQUAL
67601: PUSH
67602: LD_VAR 0 5
67606: PPUSH
67607: CALL_OW 311
67611: NOT
67612: AND
67613: PUSH
67614: LD_VAR 0 13
67618: AND
67619: IFFALSE 67686
// begin un := mechs [ 1 ] ;
67621: LD_ADDR_VAR 0 11
67625: PUSH
67626: LD_VAR 0 13
67630: PUSH
67631: LD_INT 1
67633: ARRAY
67634: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67635: LD_VAR 0 11
67639: PPUSH
67640: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67644: LD_VAR 0 11
67648: PPUSH
67649: LD_VAR 0 5
67653: PPUSH
67654: CALL_OW 180
// SetTag ( un , 19 ) ;
67658: LD_VAR 0 11
67662: PPUSH
67663: LD_INT 19
67665: PPUSH
67666: CALL_OW 109
// mechs := mechs diff un ;
67670: LD_ADDR_VAR 0 13
67674: PUSH
67675: LD_VAR 0 13
67679: PUSH
67680: LD_VAR 0 11
67684: DIFF
67685: ST_TO_ADDR
// end ; end ;
67686: GO 67573
67688: POP
67689: POP
// if solds then
67690: LD_VAR 0 9
67694: IFFALSE 67753
// for i in solds do
67696: LD_ADDR_VAR 0 5
67700: PUSH
67701: LD_VAR 0 9
67705: PUSH
67706: FOR_IN
67707: IFFALSE 67751
// if not GetTag ( i ) then
67709: LD_VAR 0 5
67713: PPUSH
67714: CALL_OW 110
67718: NOT
67719: IFFALSE 67749
// begin defenders := defenders union i ;
67721: LD_ADDR_VAR 0 2
67725: PUSH
67726: LD_VAR 0 2
67730: PUSH
67731: LD_VAR 0 5
67735: UNION
67736: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67737: LD_VAR 0 5
67741: PPUSH
67742: LD_INT 18
67744: PPUSH
67745: CALL_OW 109
// end ;
67749: GO 67706
67751: POP
67752: POP
// repeat wait ( 0 0$1 ) ;
67753: LD_INT 35
67755: PPUSH
67756: CALL_OW 67
// enemy := mc_scan [ base ] ;
67760: LD_ADDR_VAR 0 3
67764: PUSH
67765: LD_EXP 133
67769: PUSH
67770: LD_VAR 0 1
67774: ARRAY
67775: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67776: LD_EXP 110
67780: PUSH
67781: LD_VAR 0 1
67785: ARRAY
67786: NOT
67787: PUSH
67788: LD_EXP 110
67792: PUSH
67793: LD_VAR 0 1
67797: ARRAY
67798: PUSH
67799: EMPTY
67800: EQUAL
67801: OR
67802: IFFALSE 67839
// begin for i in defenders do
67804: LD_ADDR_VAR 0 5
67808: PUSH
67809: LD_VAR 0 2
67813: PUSH
67814: FOR_IN
67815: IFFALSE 67828
// ComStop ( i ) ;
67817: LD_VAR 0 5
67821: PPUSH
67822: CALL_OW 141
67826: GO 67814
67828: POP
67829: POP
// defenders := [ ] ;
67830: LD_ADDR_VAR 0 2
67834: PUSH
67835: EMPTY
67836: ST_TO_ADDR
// exit ;
67837: GO 69168
// end ; for i in defenders do
67839: LD_ADDR_VAR 0 5
67843: PUSH
67844: LD_VAR 0 2
67848: PUSH
67849: FOR_IN
67850: IFFALSE 68668
// begin e := NearestUnitToUnit ( enemy , i ) ;
67852: LD_ADDR_VAR 0 14
67856: PUSH
67857: LD_VAR 0 3
67861: PPUSH
67862: LD_VAR 0 5
67866: PPUSH
67867: CALL_OW 74
67871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67872: LD_ADDR_VAR 0 8
67876: PUSH
67877: LD_EXP 110
67881: PUSH
67882: LD_VAR 0 1
67886: ARRAY
67887: PPUSH
67888: LD_INT 2
67890: PUSH
67891: LD_INT 30
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 30
67903: PUSH
67904: LD_INT 1
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: LIST
67915: PPUSH
67916: CALL_OW 72
67920: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67921: LD_ADDR_VAR 0 17
67925: PUSH
67926: LD_VAR 0 8
67930: NOT
67931: PUSH
67932: LD_VAR 0 8
67936: PPUSH
67937: LD_INT 3
67939: PUSH
67940: LD_INT 24
67942: PUSH
67943: LD_INT 600
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: EMPTY
67951: LIST
67952: LIST
67953: PPUSH
67954: CALL_OW 72
67958: OR
67959: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67960: LD_VAR 0 5
67964: PPUSH
67965: CALL_OW 247
67969: PUSH
67970: LD_INT 2
67972: DOUBLE
67973: EQUAL
67974: IFTRUE 67978
67976: GO 68374
67978: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67979: LD_VAR 0 5
67983: PPUSH
67984: CALL_OW 256
67988: PUSH
67989: LD_INT 650
67991: GREATER
67992: PUSH
67993: LD_VAR 0 5
67997: PPUSH
67998: LD_VAR 0 14
68002: PPUSH
68003: CALL_OW 296
68007: PUSH
68008: LD_INT 40
68010: LESS
68011: PUSH
68012: LD_VAR 0 14
68016: PPUSH
68017: LD_EXP 135
68021: PUSH
68022: LD_VAR 0 1
68026: ARRAY
68027: PPUSH
68028: CALL_OW 308
68032: OR
68033: AND
68034: IFFALSE 68156
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
68036: LD_VAR 0 5
68040: PPUSH
68041: CALL_OW 262
68045: PUSH
68046: LD_INT 1
68048: EQUAL
68049: PUSH
68050: LD_VAR 0 5
68054: PPUSH
68055: CALL_OW 261
68059: PUSH
68060: LD_INT 30
68062: LESS
68063: AND
68064: PUSH
68065: LD_VAR 0 8
68069: AND
68070: IFFALSE 68140
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
68072: LD_VAR 0 5
68076: PPUSH
68077: LD_VAR 0 8
68081: PPUSH
68082: LD_VAR 0 5
68086: PPUSH
68087: CALL_OW 74
68091: PPUSH
68092: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
68096: LD_VAR 0 5
68100: PPUSH
68101: LD_VAR 0 8
68105: PPUSH
68106: LD_VAR 0 5
68110: PPUSH
68111: CALL_OW 74
68115: PPUSH
68116: CALL_OW 296
68120: PUSH
68121: LD_INT 6
68123: LESS
68124: IFFALSE 68138
// SetFuel ( i , 100 ) ;
68126: LD_VAR 0 5
68130: PPUSH
68131: LD_INT 100
68133: PPUSH
68134: CALL_OW 240
// end else
68138: GO 68154
// ComAttackUnit ( i , e ) ;
68140: LD_VAR 0 5
68144: PPUSH
68145: LD_VAR 0 14
68149: PPUSH
68150: CALL_OW 115
// end else
68154: GO 68257
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
68156: LD_VAR 0 14
68160: PPUSH
68161: LD_EXP 135
68165: PUSH
68166: LD_VAR 0 1
68170: ARRAY
68171: PPUSH
68172: CALL_OW 308
68176: NOT
68177: PUSH
68178: LD_VAR 0 5
68182: PPUSH
68183: LD_VAR 0 14
68187: PPUSH
68188: CALL_OW 296
68192: PUSH
68193: LD_INT 40
68195: GREATEREQUAL
68196: AND
68197: PUSH
68198: LD_VAR 0 5
68202: PPUSH
68203: CALL_OW 256
68207: PUSH
68208: LD_INT 650
68210: LESSEQUAL
68211: OR
68212: PUSH
68213: LD_VAR 0 5
68217: PPUSH
68218: LD_EXP 134
68222: PUSH
68223: LD_VAR 0 1
68227: ARRAY
68228: PPUSH
68229: CALL_OW 308
68233: NOT
68234: AND
68235: IFFALSE 68257
// ComMoveToArea ( i , mc_parking [ base ] ) ;
68237: LD_VAR 0 5
68241: PPUSH
68242: LD_EXP 134
68246: PUSH
68247: LD_VAR 0 1
68251: ARRAY
68252: PPUSH
68253: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
68257: LD_VAR 0 5
68261: PPUSH
68262: CALL_OW 256
68266: PUSH
68267: LD_INT 998
68269: LESS
68270: PUSH
68271: LD_VAR 0 5
68275: PPUSH
68276: CALL_OW 263
68280: PUSH
68281: LD_INT 1
68283: EQUAL
68284: AND
68285: PUSH
68286: LD_VAR 0 5
68290: PPUSH
68291: CALL_OW 311
68295: AND
68296: PUSH
68297: LD_VAR 0 5
68301: PPUSH
68302: LD_EXP 134
68306: PUSH
68307: LD_VAR 0 1
68311: ARRAY
68312: PPUSH
68313: CALL_OW 308
68317: AND
68318: IFFALSE 68372
// begin mech := IsDrivenBy ( i ) ;
68320: LD_ADDR_VAR 0 10
68324: PUSH
68325: LD_VAR 0 5
68329: PPUSH
68330: CALL_OW 311
68334: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68335: LD_VAR 0 10
68339: PPUSH
68340: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68344: LD_VAR 0 10
68348: PPUSH
68349: LD_VAR 0 5
68353: PPUSH
68354: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68358: LD_VAR 0 10
68362: PPUSH
68363: LD_VAR 0 5
68367: PPUSH
68368: CALL_OW 180
// end ; end ; unit_human :
68372: GO 68639
68374: LD_INT 1
68376: DOUBLE
68377: EQUAL
68378: IFTRUE 68382
68380: GO 68638
68382: POP
// begin b := IsInUnit ( i ) ;
68383: LD_ADDR_VAR 0 19
68387: PUSH
68388: LD_VAR 0 5
68392: PPUSH
68393: CALL_OW 310
68397: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68398: LD_ADDR_VAR 0 20
68402: PUSH
68403: LD_VAR 0 19
68407: NOT
68408: PUSH
68409: LD_VAR 0 19
68413: PPUSH
68414: CALL_OW 266
68418: PUSH
68419: LD_INT 32
68421: PUSH
68422: LD_INT 31
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: IN
68429: OR
68430: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68431: LD_VAR 0 17
68435: PUSH
68436: LD_VAR 0 2
68440: PPUSH
68441: LD_INT 21
68443: PUSH
68444: LD_INT 2
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PPUSH
68451: CALL_OW 72
68455: PUSH
68456: LD_INT 1
68458: LESSEQUAL
68459: OR
68460: PUSH
68461: LD_VAR 0 20
68465: AND
68466: PUSH
68467: LD_VAR 0 5
68471: PUSH
68472: LD_VAR 0 18
68476: IN
68477: NOT
68478: AND
68479: IFFALSE 68572
// begin if b then
68481: LD_VAR 0 19
68485: IFFALSE 68534
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68487: LD_VAR 0 19
68491: PPUSH
68492: LD_VAR 0 3
68496: PPUSH
68497: LD_VAR 0 19
68501: PPUSH
68502: CALL_OW 74
68506: PPUSH
68507: CALL_OW 296
68511: PUSH
68512: LD_INT 10
68514: LESS
68515: PUSH
68516: LD_VAR 0 19
68520: PPUSH
68521: CALL_OW 461
68525: PUSH
68526: LD_INT 7
68528: NONEQUAL
68529: AND
68530: IFFALSE 68534
// continue ;
68532: GO 67849
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68534: LD_ADDR_VAR 0 18
68538: PUSH
68539: LD_VAR 0 18
68543: PPUSH
68544: LD_VAR 0 18
68548: PUSH
68549: LD_INT 1
68551: PLUS
68552: PPUSH
68553: LD_VAR 0 5
68557: PPUSH
68558: CALL_OW 1
68562: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68563: LD_VAR 0 5
68567: PPUSH
68568: CALL_OW 122
// end ; if sold_defenders then
68572: LD_VAR 0 18
68576: IFFALSE 68636
// if i in sold_defenders then
68578: LD_VAR 0 5
68582: PUSH
68583: LD_VAR 0 18
68587: IN
68588: IFFALSE 68636
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68590: LD_VAR 0 5
68594: PPUSH
68595: CALL_OW 314
68599: NOT
68600: PUSH
68601: LD_VAR 0 5
68605: PPUSH
68606: LD_VAR 0 14
68610: PPUSH
68611: CALL_OW 296
68615: PUSH
68616: LD_INT 30
68618: LESS
68619: AND
68620: IFFALSE 68636
// ComAttackUnit ( i , e ) ;
68622: LD_VAR 0 5
68626: PPUSH
68627: LD_VAR 0 14
68631: PPUSH
68632: CALL_OW 115
// end ; end ; end ;
68636: GO 68639
68638: POP
// if IsDead ( i ) then
68639: LD_VAR 0 5
68643: PPUSH
68644: CALL_OW 301
68648: IFFALSE 68666
// defenders := defenders diff i ;
68650: LD_ADDR_VAR 0 2
68654: PUSH
68655: LD_VAR 0 2
68659: PUSH
68660: LD_VAR 0 5
68664: DIFF
68665: ST_TO_ADDR
// end ;
68666: GO 67849
68668: POP
68669: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68670: LD_VAR 0 3
68674: NOT
68675: PUSH
68676: LD_VAR 0 2
68680: NOT
68681: OR
68682: PUSH
68683: LD_EXP 110
68687: PUSH
68688: LD_VAR 0 1
68692: ARRAY
68693: NOT
68694: OR
68695: IFFALSE 67753
// MC_Reset ( base , 18 ) ;
68697: LD_VAR 0 1
68701: PPUSH
68702: LD_INT 18
68704: PPUSH
68705: CALL 39019 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68709: LD_ADDR_VAR 0 2
68713: PUSH
68714: LD_VAR 0 2
68718: PUSH
68719: LD_VAR 0 2
68723: PPUSH
68724: LD_INT 2
68726: PUSH
68727: LD_INT 25
68729: PUSH
68730: LD_INT 1
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PUSH
68737: LD_INT 25
68739: PUSH
68740: LD_INT 5
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 25
68749: PUSH
68750: LD_INT 8
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 25
68759: PUSH
68760: LD_INT 9
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: PPUSH
68774: CALL_OW 72
68778: DIFF
68779: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68780: LD_VAR 0 3
68784: NOT
68785: PUSH
68786: LD_VAR 0 2
68790: PPUSH
68791: LD_INT 21
68793: PUSH
68794: LD_INT 2
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PPUSH
68801: CALL_OW 72
68805: AND
68806: IFFALSE 69144
// begin tmp := FilterByTag ( defenders , 19 ) ;
68808: LD_ADDR_VAR 0 12
68812: PUSH
68813: LD_VAR 0 2
68817: PPUSH
68818: LD_INT 19
68820: PPUSH
68821: CALL 105607 0 2
68825: ST_TO_ADDR
// if tmp then
68826: LD_VAR 0 12
68830: IFFALSE 68900
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68832: LD_ADDR_VAR 0 12
68836: PUSH
68837: LD_VAR 0 12
68841: PPUSH
68842: LD_INT 25
68844: PUSH
68845: LD_INT 3
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PPUSH
68852: CALL_OW 72
68856: ST_TO_ADDR
// if tmp then
68857: LD_VAR 0 12
68861: IFFALSE 68900
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68863: LD_ADDR_EXP 122
68867: PUSH
68868: LD_EXP 122
68872: PPUSH
68873: LD_VAR 0 1
68877: PPUSH
68878: LD_EXP 122
68882: PUSH
68883: LD_VAR 0 1
68887: ARRAY
68888: PUSH
68889: LD_VAR 0 12
68893: UNION
68894: PPUSH
68895: CALL_OW 1
68899: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68900: LD_VAR 0 1
68904: PPUSH
68905: LD_INT 19
68907: PPUSH
68908: CALL 39019 0 2
// repeat wait ( 0 0$1 ) ;
68912: LD_INT 35
68914: PPUSH
68915: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68919: LD_EXP 110
68923: PUSH
68924: LD_VAR 0 1
68928: ARRAY
68929: NOT
68930: PUSH
68931: LD_EXP 110
68935: PUSH
68936: LD_VAR 0 1
68940: ARRAY
68941: PUSH
68942: EMPTY
68943: EQUAL
68944: OR
68945: IFFALSE 68982
// begin for i in defenders do
68947: LD_ADDR_VAR 0 5
68951: PUSH
68952: LD_VAR 0 2
68956: PUSH
68957: FOR_IN
68958: IFFALSE 68971
// ComStop ( i ) ;
68960: LD_VAR 0 5
68964: PPUSH
68965: CALL_OW 141
68969: GO 68957
68971: POP
68972: POP
// defenders := [ ] ;
68973: LD_ADDR_VAR 0 2
68977: PUSH
68978: EMPTY
68979: ST_TO_ADDR
// exit ;
68980: GO 69168
// end ; for i in defenders do
68982: LD_ADDR_VAR 0 5
68986: PUSH
68987: LD_VAR 0 2
68991: PUSH
68992: FOR_IN
68993: IFFALSE 69082
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68995: LD_VAR 0 5
68999: PPUSH
69000: LD_EXP 134
69004: PUSH
69005: LD_VAR 0 1
69009: ARRAY
69010: PPUSH
69011: CALL_OW 308
69015: NOT
69016: IFFALSE 69040
// ComMoveToArea ( i , mc_parking [ base ] ) else
69018: LD_VAR 0 5
69022: PPUSH
69023: LD_EXP 134
69027: PUSH
69028: LD_VAR 0 1
69032: ARRAY
69033: PPUSH
69034: CALL_OW 113
69038: GO 69080
// if GetControl ( i ) = control_manual then
69040: LD_VAR 0 5
69044: PPUSH
69045: CALL_OW 263
69049: PUSH
69050: LD_INT 1
69052: EQUAL
69053: IFFALSE 69080
// if IsDrivenBy ( i ) then
69055: LD_VAR 0 5
69059: PPUSH
69060: CALL_OW 311
69064: IFFALSE 69080
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
69066: LD_VAR 0 5
69070: PPUSH
69071: CALL_OW 311
69075: PPUSH
69076: CALL_OW 121
// end ;
69080: GO 68992
69082: POP
69083: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
69084: LD_VAR 0 2
69088: PPUSH
69089: LD_INT 95
69091: PUSH
69092: LD_EXP 134
69096: PUSH
69097: LD_VAR 0 1
69101: ARRAY
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PPUSH
69107: CALL_OW 72
69111: PUSH
69112: LD_VAR 0 2
69116: EQUAL
69117: PUSH
69118: LD_EXP 133
69122: PUSH
69123: LD_VAR 0 1
69127: ARRAY
69128: OR
69129: PUSH
69130: LD_EXP 110
69134: PUSH
69135: LD_VAR 0 1
69139: ARRAY
69140: NOT
69141: OR
69142: IFFALSE 68912
// end ; MC_Reset ( base , 19 ) ;
69144: LD_VAR 0 1
69148: PPUSH
69149: LD_INT 19
69151: PPUSH
69152: CALL 39019 0 2
// MC_Reset ( base , 20 ) ;
69156: LD_VAR 0 1
69160: PPUSH
69161: LD_INT 20
69163: PPUSH
69164: CALL 39019 0 2
// end ;
69168: LD_VAR 0 4
69172: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69173: LD_INT 0
69175: PPUSH
69176: PPUSH
69177: PPUSH
69178: PPUSH
// result := false ;
69179: LD_ADDR_VAR 0 2
69183: PUSH
69184: LD_INT 0
69186: ST_TO_ADDR
// side := GetSide ( unit ) ;
69187: LD_ADDR_VAR 0 3
69191: PUSH
69192: LD_VAR 0 1
69196: PPUSH
69197: CALL_OW 255
69201: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69202: LD_ADDR_VAR 0 4
69206: PUSH
69207: LD_VAR 0 1
69211: PPUSH
69212: CALL_OW 248
69216: ST_TO_ADDR
// case nat of 1 :
69217: LD_VAR 0 4
69221: PUSH
69222: LD_INT 1
69224: DOUBLE
69225: EQUAL
69226: IFTRUE 69230
69228: GO 69241
69230: POP
// tech := tech_lassight ; 2 :
69231: LD_ADDR_VAR 0 5
69235: PUSH
69236: LD_INT 12
69238: ST_TO_ADDR
69239: GO 69280
69241: LD_INT 2
69243: DOUBLE
69244: EQUAL
69245: IFTRUE 69249
69247: GO 69260
69249: POP
// tech := tech_mortar ; 3 :
69250: LD_ADDR_VAR 0 5
69254: PUSH
69255: LD_INT 41
69257: ST_TO_ADDR
69258: GO 69280
69260: LD_INT 3
69262: DOUBLE
69263: EQUAL
69264: IFTRUE 69268
69266: GO 69279
69268: POP
// tech := tech_bazooka ; end ;
69269: LD_ADDR_VAR 0 5
69273: PUSH
69274: LD_INT 44
69276: ST_TO_ADDR
69277: GO 69280
69279: POP
// if Researched ( side , tech ) then
69280: LD_VAR 0 3
69284: PPUSH
69285: LD_VAR 0 5
69289: PPUSH
69290: CALL_OW 325
69294: IFFALSE 69321
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69296: LD_ADDR_VAR 0 2
69300: PUSH
69301: LD_INT 5
69303: PUSH
69304: LD_INT 8
69306: PUSH
69307: LD_INT 9
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: LIST
69314: PUSH
69315: LD_VAR 0 4
69319: ARRAY
69320: ST_TO_ADDR
// end ;
69321: LD_VAR 0 2
69325: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69326: LD_INT 0
69328: PPUSH
69329: PPUSH
69330: PPUSH
// if not mines then
69331: LD_VAR 0 2
69335: NOT
69336: IFFALSE 69340
// exit ;
69338: GO 69484
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69340: LD_ADDR_VAR 0 5
69344: PUSH
69345: LD_INT 81
69347: PUSH
69348: LD_VAR 0 1
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 3
69359: PUSH
69360: LD_INT 21
69362: PUSH
69363: LD_INT 3
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PPUSH
69378: CALL_OW 69
69382: ST_TO_ADDR
// for i in mines do
69383: LD_ADDR_VAR 0 4
69387: PUSH
69388: LD_VAR 0 2
69392: PUSH
69393: FOR_IN
69394: IFFALSE 69482
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69396: LD_VAR 0 4
69400: PUSH
69401: LD_INT 1
69403: ARRAY
69404: PPUSH
69405: LD_VAR 0 4
69409: PUSH
69410: LD_INT 2
69412: ARRAY
69413: PPUSH
69414: CALL_OW 458
69418: NOT
69419: IFFALSE 69423
// continue ;
69421: GO 69393
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69423: LD_VAR 0 4
69427: PUSH
69428: LD_INT 1
69430: ARRAY
69431: PPUSH
69432: LD_VAR 0 4
69436: PUSH
69437: LD_INT 2
69439: ARRAY
69440: PPUSH
69441: CALL_OW 428
69445: PUSH
69446: LD_VAR 0 5
69450: IN
69451: IFFALSE 69480
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69453: LD_VAR 0 4
69457: PUSH
69458: LD_INT 1
69460: ARRAY
69461: PPUSH
69462: LD_VAR 0 4
69466: PUSH
69467: LD_INT 2
69469: ARRAY
69470: PPUSH
69471: LD_VAR 0 1
69475: PPUSH
69476: CALL_OW 456
// end ;
69480: GO 69393
69482: POP
69483: POP
// end ;
69484: LD_VAR 0 3
69488: RET
// export function Count ( array ) ; var i ; begin
69489: LD_INT 0
69491: PPUSH
69492: PPUSH
// result := 0 ;
69493: LD_ADDR_VAR 0 2
69497: PUSH
69498: LD_INT 0
69500: ST_TO_ADDR
// for i in array do
69501: LD_ADDR_VAR 0 3
69505: PUSH
69506: LD_VAR 0 1
69510: PUSH
69511: FOR_IN
69512: IFFALSE 69536
// if i then
69514: LD_VAR 0 3
69518: IFFALSE 69534
// result := result + 1 ;
69520: LD_ADDR_VAR 0 2
69524: PUSH
69525: LD_VAR 0 2
69529: PUSH
69530: LD_INT 1
69532: PLUS
69533: ST_TO_ADDR
69534: GO 69511
69536: POP
69537: POP
// end ;
69538: LD_VAR 0 2
69542: RET
// export function IsEmpty ( building ) ; begin
69543: LD_INT 0
69545: PPUSH
// if not building then
69546: LD_VAR 0 1
69550: NOT
69551: IFFALSE 69555
// exit ;
69553: GO 69598
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69555: LD_ADDR_VAR 0 2
69559: PUSH
69560: LD_VAR 0 1
69564: PUSH
69565: LD_INT 22
69567: PUSH
69568: LD_VAR 0 1
69572: PPUSH
69573: CALL_OW 255
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 58
69584: PUSH
69585: EMPTY
69586: LIST
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PPUSH
69592: CALL_OW 69
69596: IN
69597: ST_TO_ADDR
// end ;
69598: LD_VAR 0 2
69602: RET
// export function IsNotFull ( building ) ; begin
69603: LD_INT 0
69605: PPUSH
// if not building then
69606: LD_VAR 0 1
69610: NOT
69611: IFFALSE 69615
// exit ;
69613: GO 69634
// result := UnitsInside ( building ) < 6 ;
69615: LD_ADDR_VAR 0 2
69619: PUSH
69620: LD_VAR 0 1
69624: PPUSH
69625: CALL_OW 313
69629: PUSH
69630: LD_INT 6
69632: LESS
69633: ST_TO_ADDR
// end ;
69634: LD_VAR 0 2
69638: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69639: LD_INT 0
69641: PPUSH
69642: PPUSH
69643: PPUSH
69644: PPUSH
// tmp := [ ] ;
69645: LD_ADDR_VAR 0 3
69649: PUSH
69650: EMPTY
69651: ST_TO_ADDR
// list := [ ] ;
69652: LD_ADDR_VAR 0 5
69656: PUSH
69657: EMPTY
69658: ST_TO_ADDR
// for i = 16 to 25 do
69659: LD_ADDR_VAR 0 4
69663: PUSH
69664: DOUBLE
69665: LD_INT 16
69667: DEC
69668: ST_TO_ADDR
69669: LD_INT 25
69671: PUSH
69672: FOR_TO
69673: IFFALSE 69746
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69675: LD_ADDR_VAR 0 3
69679: PUSH
69680: LD_VAR 0 3
69684: PUSH
69685: LD_INT 22
69687: PUSH
69688: LD_VAR 0 1
69692: PPUSH
69693: CALL_OW 255
69697: PUSH
69698: EMPTY
69699: LIST
69700: LIST
69701: PUSH
69702: LD_INT 91
69704: PUSH
69705: LD_VAR 0 1
69709: PUSH
69710: LD_INT 6
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 30
69720: PUSH
69721: LD_VAR 0 4
69725: PUSH
69726: EMPTY
69727: LIST
69728: LIST
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: LIST
69734: PUSH
69735: EMPTY
69736: LIST
69737: PPUSH
69738: CALL_OW 69
69742: ADD
69743: ST_TO_ADDR
69744: GO 69672
69746: POP
69747: POP
// for i = 1 to tmp do
69748: LD_ADDR_VAR 0 4
69752: PUSH
69753: DOUBLE
69754: LD_INT 1
69756: DEC
69757: ST_TO_ADDR
69758: LD_VAR 0 3
69762: PUSH
69763: FOR_TO
69764: IFFALSE 69852
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69766: LD_ADDR_VAR 0 5
69770: PUSH
69771: LD_VAR 0 5
69775: PUSH
69776: LD_VAR 0 3
69780: PUSH
69781: LD_VAR 0 4
69785: ARRAY
69786: PPUSH
69787: CALL_OW 266
69791: PUSH
69792: LD_VAR 0 3
69796: PUSH
69797: LD_VAR 0 4
69801: ARRAY
69802: PPUSH
69803: CALL_OW 250
69807: PUSH
69808: LD_VAR 0 3
69812: PUSH
69813: LD_VAR 0 4
69817: ARRAY
69818: PPUSH
69819: CALL_OW 251
69823: PUSH
69824: LD_VAR 0 3
69828: PUSH
69829: LD_VAR 0 4
69833: ARRAY
69834: PPUSH
69835: CALL_OW 254
69839: PUSH
69840: EMPTY
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: PUSH
69846: EMPTY
69847: LIST
69848: ADD
69849: ST_TO_ADDR
69850: GO 69763
69852: POP
69853: POP
// result := list ;
69854: LD_ADDR_VAR 0 2
69858: PUSH
69859: LD_VAR 0 5
69863: ST_TO_ADDR
// end ;
69864: LD_VAR 0 2
69868: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69869: LD_INT 0
69871: PPUSH
69872: PPUSH
69873: PPUSH
69874: PPUSH
69875: PPUSH
69876: PPUSH
69877: PPUSH
// if not factory then
69878: LD_VAR 0 1
69882: NOT
69883: IFFALSE 69887
// exit ;
69885: GO 70480
// if control = control_apeman then
69887: LD_VAR 0 4
69891: PUSH
69892: LD_INT 5
69894: EQUAL
69895: IFFALSE 70004
// begin tmp := UnitsInside ( factory ) ;
69897: LD_ADDR_VAR 0 8
69901: PUSH
69902: LD_VAR 0 1
69906: PPUSH
69907: CALL_OW 313
69911: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69912: LD_VAR 0 8
69916: PPUSH
69917: LD_INT 25
69919: PUSH
69920: LD_INT 12
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PPUSH
69927: CALL_OW 72
69931: NOT
69932: IFFALSE 69942
// control := control_manual ;
69934: LD_ADDR_VAR 0 4
69938: PUSH
69939: LD_INT 1
69941: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69942: LD_ADDR_VAR 0 8
69946: PUSH
69947: LD_VAR 0 1
69951: PPUSH
69952: CALL 69639 0 1
69956: ST_TO_ADDR
// if tmp then
69957: LD_VAR 0 8
69961: IFFALSE 70004
// begin for i in tmp do
69963: LD_ADDR_VAR 0 7
69967: PUSH
69968: LD_VAR 0 8
69972: PUSH
69973: FOR_IN
69974: IFFALSE 70002
// if i [ 1 ] = b_ext_radio then
69976: LD_VAR 0 7
69980: PUSH
69981: LD_INT 1
69983: ARRAY
69984: PUSH
69985: LD_INT 22
69987: EQUAL
69988: IFFALSE 70000
// begin control := control_remote ;
69990: LD_ADDR_VAR 0 4
69994: PUSH
69995: LD_INT 2
69997: ST_TO_ADDR
// break ;
69998: GO 70002
// end ;
70000: GO 69973
70002: POP
70003: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70004: LD_VAR 0 1
70008: PPUSH
70009: LD_VAR 0 2
70013: PPUSH
70014: LD_VAR 0 3
70018: PPUSH
70019: LD_VAR 0 4
70023: PPUSH
70024: LD_VAR 0 5
70028: PPUSH
70029: CALL_OW 448
70033: IFFALSE 70068
// begin result := [ chassis , engine , control , weapon ] ;
70035: LD_ADDR_VAR 0 6
70039: PUSH
70040: LD_VAR 0 2
70044: PUSH
70045: LD_VAR 0 3
70049: PUSH
70050: LD_VAR 0 4
70054: PUSH
70055: LD_VAR 0 5
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: ST_TO_ADDR
// exit ;
70066: GO 70480
// end ; _chassis := AvailableChassisList ( factory ) ;
70068: LD_ADDR_VAR 0 9
70072: PUSH
70073: LD_VAR 0 1
70077: PPUSH
70078: CALL_OW 475
70082: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70083: LD_ADDR_VAR 0 11
70087: PUSH
70088: LD_VAR 0 1
70092: PPUSH
70093: CALL_OW 476
70097: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70098: LD_ADDR_VAR 0 12
70102: PUSH
70103: LD_VAR 0 1
70107: PPUSH
70108: CALL_OW 477
70112: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70113: LD_ADDR_VAR 0 10
70117: PUSH
70118: LD_VAR 0 1
70122: PPUSH
70123: CALL_OW 478
70127: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70128: LD_VAR 0 9
70132: NOT
70133: PUSH
70134: LD_VAR 0 11
70138: NOT
70139: OR
70140: PUSH
70141: LD_VAR 0 12
70145: NOT
70146: OR
70147: PUSH
70148: LD_VAR 0 10
70152: NOT
70153: OR
70154: IFFALSE 70189
// begin result := [ chassis , engine , control , weapon ] ;
70156: LD_ADDR_VAR 0 6
70160: PUSH
70161: LD_VAR 0 2
70165: PUSH
70166: LD_VAR 0 3
70170: PUSH
70171: LD_VAR 0 4
70175: PUSH
70176: LD_VAR 0 5
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: ST_TO_ADDR
// exit ;
70187: GO 70480
// end ; if not chassis in _chassis then
70189: LD_VAR 0 2
70193: PUSH
70194: LD_VAR 0 9
70198: IN
70199: NOT
70200: IFFALSE 70226
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70202: LD_ADDR_VAR 0 2
70206: PUSH
70207: LD_VAR 0 9
70211: PUSH
70212: LD_INT 1
70214: PPUSH
70215: LD_VAR 0 9
70219: PPUSH
70220: CALL_OW 12
70224: ARRAY
70225: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70226: LD_VAR 0 2
70230: PPUSH
70231: LD_VAR 0 3
70235: PPUSH
70236: CALL 70485 0 2
70240: NOT
70241: IFFALSE 70300
// repeat engine := _engine [ 1 ] ;
70243: LD_ADDR_VAR 0 3
70247: PUSH
70248: LD_VAR 0 11
70252: PUSH
70253: LD_INT 1
70255: ARRAY
70256: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70257: LD_ADDR_VAR 0 11
70261: PUSH
70262: LD_VAR 0 11
70266: PPUSH
70267: LD_INT 1
70269: PPUSH
70270: CALL_OW 3
70274: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70275: LD_VAR 0 2
70279: PPUSH
70280: LD_VAR 0 3
70284: PPUSH
70285: CALL 70485 0 2
70289: PUSH
70290: LD_VAR 0 11
70294: PUSH
70295: EMPTY
70296: EQUAL
70297: OR
70298: IFFALSE 70243
// if not control in _control then
70300: LD_VAR 0 4
70304: PUSH
70305: LD_VAR 0 12
70309: IN
70310: NOT
70311: IFFALSE 70337
// control := _control [ rand ( 1 , _control ) ] ;
70313: LD_ADDR_VAR 0 4
70317: PUSH
70318: LD_VAR 0 12
70322: PUSH
70323: LD_INT 1
70325: PPUSH
70326: LD_VAR 0 12
70330: PPUSH
70331: CALL_OW 12
70335: ARRAY
70336: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70337: LD_VAR 0 2
70341: PPUSH
70342: LD_VAR 0 5
70346: PPUSH
70347: CALL 70705 0 2
70351: NOT
70352: IFFALSE 70411
// repeat weapon := _weapon [ 1 ] ;
70354: LD_ADDR_VAR 0 5
70358: PUSH
70359: LD_VAR 0 10
70363: PUSH
70364: LD_INT 1
70366: ARRAY
70367: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70368: LD_ADDR_VAR 0 10
70372: PUSH
70373: LD_VAR 0 10
70377: PPUSH
70378: LD_INT 1
70380: PPUSH
70381: CALL_OW 3
70385: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70386: LD_VAR 0 2
70390: PPUSH
70391: LD_VAR 0 5
70395: PPUSH
70396: CALL 70705 0 2
70400: PUSH
70401: LD_VAR 0 10
70405: PUSH
70406: EMPTY
70407: EQUAL
70408: OR
70409: IFFALSE 70354
// result := [ ] ;
70411: LD_ADDR_VAR 0 6
70415: PUSH
70416: EMPTY
70417: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70418: LD_VAR 0 1
70422: PPUSH
70423: LD_VAR 0 2
70427: PPUSH
70428: LD_VAR 0 3
70432: PPUSH
70433: LD_VAR 0 4
70437: PPUSH
70438: LD_VAR 0 5
70442: PPUSH
70443: CALL_OW 448
70447: IFFALSE 70480
// result := [ chassis , engine , control , weapon ] ;
70449: LD_ADDR_VAR 0 6
70453: PUSH
70454: LD_VAR 0 2
70458: PUSH
70459: LD_VAR 0 3
70463: PUSH
70464: LD_VAR 0 4
70468: PUSH
70469: LD_VAR 0 5
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: ST_TO_ADDR
// end ;
70480: LD_VAR 0 6
70484: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70485: LD_INT 0
70487: PPUSH
// if not chassis or not engine then
70488: LD_VAR 0 1
70492: NOT
70493: PUSH
70494: LD_VAR 0 2
70498: NOT
70499: OR
70500: IFFALSE 70504
// exit ;
70502: GO 70700
// case engine of engine_solar :
70504: LD_VAR 0 2
70508: PUSH
70509: LD_INT 2
70511: DOUBLE
70512: EQUAL
70513: IFTRUE 70517
70515: GO 70555
70517: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70518: LD_ADDR_VAR 0 3
70522: PUSH
70523: LD_INT 11
70525: PUSH
70526: LD_INT 12
70528: PUSH
70529: LD_INT 13
70531: PUSH
70532: LD_INT 14
70534: PUSH
70535: LD_INT 1
70537: PUSH
70538: LD_INT 2
70540: PUSH
70541: LD_INT 3
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: ST_TO_ADDR
70553: GO 70684
70555: LD_INT 1
70557: DOUBLE
70558: EQUAL
70559: IFTRUE 70563
70561: GO 70625
70563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70564: LD_ADDR_VAR 0 3
70568: PUSH
70569: LD_INT 11
70571: PUSH
70572: LD_INT 12
70574: PUSH
70575: LD_INT 13
70577: PUSH
70578: LD_INT 14
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: LD_INT 2
70586: PUSH
70587: LD_INT 3
70589: PUSH
70590: LD_INT 4
70592: PUSH
70593: LD_INT 5
70595: PUSH
70596: LD_INT 21
70598: PUSH
70599: LD_INT 23
70601: PUSH
70602: LD_INT 22
70604: PUSH
70605: LD_INT 24
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: ST_TO_ADDR
70623: GO 70684
70625: LD_INT 3
70627: DOUBLE
70628: EQUAL
70629: IFTRUE 70633
70631: GO 70683
70633: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70634: LD_ADDR_VAR 0 3
70638: PUSH
70639: LD_INT 13
70641: PUSH
70642: LD_INT 14
70644: PUSH
70645: LD_INT 2
70647: PUSH
70648: LD_INT 3
70650: PUSH
70651: LD_INT 4
70653: PUSH
70654: LD_INT 5
70656: PUSH
70657: LD_INT 21
70659: PUSH
70660: LD_INT 22
70662: PUSH
70663: LD_INT 23
70665: PUSH
70666: LD_INT 24
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: ST_TO_ADDR
70681: GO 70684
70683: POP
// result := ( chassis in result ) ;
70684: LD_ADDR_VAR 0 3
70688: PUSH
70689: LD_VAR 0 1
70693: PUSH
70694: LD_VAR 0 3
70698: IN
70699: ST_TO_ADDR
// end ;
70700: LD_VAR 0 3
70704: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70705: LD_INT 0
70707: PPUSH
// if not chassis or not weapon then
70708: LD_VAR 0 1
70712: NOT
70713: PUSH
70714: LD_VAR 0 2
70718: NOT
70719: OR
70720: IFFALSE 70724
// exit ;
70722: GO 71750
// case weapon of us_machine_gun :
70724: LD_VAR 0 2
70728: PUSH
70729: LD_INT 2
70731: DOUBLE
70732: EQUAL
70733: IFTRUE 70737
70735: GO 70767
70737: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70738: LD_ADDR_VAR 0 3
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: LD_INT 3
70751: PUSH
70752: LD_INT 4
70754: PUSH
70755: LD_INT 5
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: LIST
70764: ST_TO_ADDR
70765: GO 71734
70767: LD_INT 3
70769: DOUBLE
70770: EQUAL
70771: IFTRUE 70775
70773: GO 70805
70775: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70776: LD_ADDR_VAR 0 3
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: LD_INT 2
70786: PUSH
70787: LD_INT 3
70789: PUSH
70790: LD_INT 4
70792: PUSH
70793: LD_INT 5
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: ST_TO_ADDR
70803: GO 71734
70805: LD_INT 11
70807: DOUBLE
70808: EQUAL
70809: IFTRUE 70813
70811: GO 70843
70813: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70814: LD_ADDR_VAR 0 3
70818: PUSH
70819: LD_INT 1
70821: PUSH
70822: LD_INT 2
70824: PUSH
70825: LD_INT 3
70827: PUSH
70828: LD_INT 4
70830: PUSH
70831: LD_INT 5
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: LIST
70838: LIST
70839: LIST
70840: ST_TO_ADDR
70841: GO 71734
70843: LD_INT 4
70845: DOUBLE
70846: EQUAL
70847: IFTRUE 70851
70849: GO 70877
70851: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70852: LD_ADDR_VAR 0 3
70856: PUSH
70857: LD_INT 2
70859: PUSH
70860: LD_INT 3
70862: PUSH
70863: LD_INT 4
70865: PUSH
70866: LD_INT 5
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: ST_TO_ADDR
70875: GO 71734
70877: LD_INT 5
70879: DOUBLE
70880: EQUAL
70881: IFTRUE 70885
70883: GO 70911
70885: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70886: LD_ADDR_VAR 0 3
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: LD_INT 3
70896: PUSH
70897: LD_INT 4
70899: PUSH
70900: LD_INT 5
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: ST_TO_ADDR
70909: GO 71734
70911: LD_INT 9
70913: DOUBLE
70914: EQUAL
70915: IFTRUE 70919
70917: GO 70945
70919: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70920: LD_ADDR_VAR 0 3
70924: PUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 3
70930: PUSH
70931: LD_INT 4
70933: PUSH
70934: LD_INT 5
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: ST_TO_ADDR
70943: GO 71734
70945: LD_INT 7
70947: DOUBLE
70948: EQUAL
70949: IFTRUE 70953
70951: GO 70979
70953: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70954: LD_ADDR_VAR 0 3
70958: PUSH
70959: LD_INT 2
70961: PUSH
70962: LD_INT 3
70964: PUSH
70965: LD_INT 4
70967: PUSH
70968: LD_INT 5
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: ST_TO_ADDR
70977: GO 71734
70979: LD_INT 12
70981: DOUBLE
70982: EQUAL
70983: IFTRUE 70987
70985: GO 71013
70987: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70988: LD_ADDR_VAR 0 3
70992: PUSH
70993: LD_INT 2
70995: PUSH
70996: LD_INT 3
70998: PUSH
70999: LD_INT 4
71001: PUSH
71002: LD_INT 5
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: ST_TO_ADDR
71011: GO 71734
71013: LD_INT 13
71015: DOUBLE
71016: EQUAL
71017: IFTRUE 71021
71019: GO 71047
71021: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71022: LD_ADDR_VAR 0 3
71026: PUSH
71027: LD_INT 2
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: LD_INT 4
71035: PUSH
71036: LD_INT 5
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: ST_TO_ADDR
71045: GO 71734
71047: LD_INT 14
71049: DOUBLE
71050: EQUAL
71051: IFTRUE 71055
71053: GO 71073
71055: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71056: LD_ADDR_VAR 0 3
71060: PUSH
71061: LD_INT 4
71063: PUSH
71064: LD_INT 5
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: ST_TO_ADDR
71071: GO 71734
71073: LD_INT 6
71075: DOUBLE
71076: EQUAL
71077: IFTRUE 71081
71079: GO 71099
71081: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71082: LD_ADDR_VAR 0 3
71086: PUSH
71087: LD_INT 4
71089: PUSH
71090: LD_INT 5
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: ST_TO_ADDR
71097: GO 71734
71099: LD_INT 10
71101: DOUBLE
71102: EQUAL
71103: IFTRUE 71107
71105: GO 71125
71107: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71108: LD_ADDR_VAR 0 3
71112: PUSH
71113: LD_INT 4
71115: PUSH
71116: LD_INT 5
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: ST_TO_ADDR
71123: GO 71734
71125: LD_INT 22
71127: DOUBLE
71128: EQUAL
71129: IFTRUE 71133
71131: GO 71159
71133: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71134: LD_ADDR_VAR 0 3
71138: PUSH
71139: LD_INT 11
71141: PUSH
71142: LD_INT 12
71144: PUSH
71145: LD_INT 13
71147: PUSH
71148: LD_INT 14
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: ST_TO_ADDR
71157: GO 71734
71159: LD_INT 23
71161: DOUBLE
71162: EQUAL
71163: IFTRUE 71167
71165: GO 71193
71167: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71168: LD_ADDR_VAR 0 3
71172: PUSH
71173: LD_INT 11
71175: PUSH
71176: LD_INT 12
71178: PUSH
71179: LD_INT 13
71181: PUSH
71182: LD_INT 14
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: LIST
71189: LIST
71190: ST_TO_ADDR
71191: GO 71734
71193: LD_INT 24
71195: DOUBLE
71196: EQUAL
71197: IFTRUE 71201
71199: GO 71227
71201: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71202: LD_ADDR_VAR 0 3
71206: PUSH
71207: LD_INT 11
71209: PUSH
71210: LD_INT 12
71212: PUSH
71213: LD_INT 13
71215: PUSH
71216: LD_INT 14
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: ST_TO_ADDR
71225: GO 71734
71227: LD_INT 30
71229: DOUBLE
71230: EQUAL
71231: IFTRUE 71235
71233: GO 71261
71235: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71236: LD_ADDR_VAR 0 3
71240: PUSH
71241: LD_INT 11
71243: PUSH
71244: LD_INT 12
71246: PUSH
71247: LD_INT 13
71249: PUSH
71250: LD_INT 14
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: ST_TO_ADDR
71259: GO 71734
71261: LD_INT 25
71263: DOUBLE
71264: EQUAL
71265: IFTRUE 71269
71267: GO 71287
71269: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71270: LD_ADDR_VAR 0 3
71274: PUSH
71275: LD_INT 13
71277: PUSH
71278: LD_INT 14
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: ST_TO_ADDR
71285: GO 71734
71287: LD_INT 27
71289: DOUBLE
71290: EQUAL
71291: IFTRUE 71295
71293: GO 71313
71295: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71296: LD_ADDR_VAR 0 3
71300: PUSH
71301: LD_INT 13
71303: PUSH
71304: LD_INT 14
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: ST_TO_ADDR
71311: GO 71734
71313: LD_INT 28
71315: DOUBLE
71316: EQUAL
71317: IFTRUE 71321
71319: GO 71339
71321: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71322: LD_ADDR_VAR 0 3
71326: PUSH
71327: LD_INT 13
71329: PUSH
71330: LD_INT 14
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: ST_TO_ADDR
71337: GO 71734
71339: LD_INT 29
71341: DOUBLE
71342: EQUAL
71343: IFTRUE 71347
71345: GO 71365
71347: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71348: LD_ADDR_VAR 0 3
71352: PUSH
71353: LD_INT 13
71355: PUSH
71356: LD_INT 14
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: ST_TO_ADDR
71363: GO 71734
71365: LD_INT 31
71367: DOUBLE
71368: EQUAL
71369: IFTRUE 71373
71371: GO 71391
71373: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71374: LD_ADDR_VAR 0 3
71378: PUSH
71379: LD_INT 13
71381: PUSH
71382: LD_INT 14
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: ST_TO_ADDR
71389: GO 71734
71391: LD_INT 26
71393: DOUBLE
71394: EQUAL
71395: IFTRUE 71399
71397: GO 71417
71399: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71400: LD_ADDR_VAR 0 3
71404: PUSH
71405: LD_INT 13
71407: PUSH
71408: LD_INT 14
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: ST_TO_ADDR
71415: GO 71734
71417: LD_INT 42
71419: DOUBLE
71420: EQUAL
71421: IFTRUE 71425
71423: GO 71451
71425: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71426: LD_ADDR_VAR 0 3
71430: PUSH
71431: LD_INT 21
71433: PUSH
71434: LD_INT 22
71436: PUSH
71437: LD_INT 23
71439: PUSH
71440: LD_INT 24
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: LIST
71447: LIST
71448: ST_TO_ADDR
71449: GO 71734
71451: LD_INT 43
71453: DOUBLE
71454: EQUAL
71455: IFTRUE 71459
71457: GO 71485
71459: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71460: LD_ADDR_VAR 0 3
71464: PUSH
71465: LD_INT 21
71467: PUSH
71468: LD_INT 22
71470: PUSH
71471: LD_INT 23
71473: PUSH
71474: LD_INT 24
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: LIST
71481: LIST
71482: ST_TO_ADDR
71483: GO 71734
71485: LD_INT 44
71487: DOUBLE
71488: EQUAL
71489: IFTRUE 71493
71491: GO 71519
71493: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71494: LD_ADDR_VAR 0 3
71498: PUSH
71499: LD_INT 21
71501: PUSH
71502: LD_INT 22
71504: PUSH
71505: LD_INT 23
71507: PUSH
71508: LD_INT 24
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: ST_TO_ADDR
71517: GO 71734
71519: LD_INT 45
71521: DOUBLE
71522: EQUAL
71523: IFTRUE 71527
71525: GO 71553
71527: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71528: LD_ADDR_VAR 0 3
71532: PUSH
71533: LD_INT 21
71535: PUSH
71536: LD_INT 22
71538: PUSH
71539: LD_INT 23
71541: PUSH
71542: LD_INT 24
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: ST_TO_ADDR
71551: GO 71734
71553: LD_INT 49
71555: DOUBLE
71556: EQUAL
71557: IFTRUE 71561
71559: GO 71587
71561: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71562: LD_ADDR_VAR 0 3
71566: PUSH
71567: LD_INT 21
71569: PUSH
71570: LD_INT 22
71572: PUSH
71573: LD_INT 23
71575: PUSH
71576: LD_INT 24
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: ST_TO_ADDR
71585: GO 71734
71587: LD_INT 51
71589: DOUBLE
71590: EQUAL
71591: IFTRUE 71595
71593: GO 71621
71595: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71596: LD_ADDR_VAR 0 3
71600: PUSH
71601: LD_INT 21
71603: PUSH
71604: LD_INT 22
71606: PUSH
71607: LD_INT 23
71609: PUSH
71610: LD_INT 24
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: ST_TO_ADDR
71619: GO 71734
71621: LD_INT 52
71623: DOUBLE
71624: EQUAL
71625: IFTRUE 71629
71627: GO 71655
71629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71630: LD_ADDR_VAR 0 3
71634: PUSH
71635: LD_INT 21
71637: PUSH
71638: LD_INT 22
71640: PUSH
71641: LD_INT 23
71643: PUSH
71644: LD_INT 24
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: ST_TO_ADDR
71653: GO 71734
71655: LD_INT 53
71657: DOUBLE
71658: EQUAL
71659: IFTRUE 71663
71661: GO 71681
71663: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71664: LD_ADDR_VAR 0 3
71668: PUSH
71669: LD_INT 23
71671: PUSH
71672: LD_INT 24
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: ST_TO_ADDR
71679: GO 71734
71681: LD_INT 46
71683: DOUBLE
71684: EQUAL
71685: IFTRUE 71689
71687: GO 71707
71689: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71690: LD_ADDR_VAR 0 3
71694: PUSH
71695: LD_INT 23
71697: PUSH
71698: LD_INT 24
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: ST_TO_ADDR
71705: GO 71734
71707: LD_INT 47
71709: DOUBLE
71710: EQUAL
71711: IFTRUE 71715
71713: GO 71733
71715: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71716: LD_ADDR_VAR 0 3
71720: PUSH
71721: LD_INT 23
71723: PUSH
71724: LD_INT 24
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: ST_TO_ADDR
71731: GO 71734
71733: POP
// result := ( chassis in result ) ;
71734: LD_ADDR_VAR 0 3
71738: PUSH
71739: LD_VAR 0 1
71743: PUSH
71744: LD_VAR 0 3
71748: IN
71749: ST_TO_ADDR
// end ;
71750: LD_VAR 0 3
71754: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71755: LD_INT 0
71757: PPUSH
71758: PPUSH
71759: PPUSH
71760: PPUSH
71761: PPUSH
71762: PPUSH
71763: PPUSH
// result := array ;
71764: LD_ADDR_VAR 0 5
71768: PUSH
71769: LD_VAR 0 1
71773: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71774: LD_VAR 0 1
71778: NOT
71779: PUSH
71780: LD_VAR 0 2
71784: NOT
71785: OR
71786: PUSH
71787: LD_VAR 0 3
71791: NOT
71792: OR
71793: PUSH
71794: LD_VAR 0 2
71798: PUSH
71799: LD_VAR 0 1
71803: GREATER
71804: OR
71805: PUSH
71806: LD_VAR 0 3
71810: PUSH
71811: LD_VAR 0 1
71815: GREATER
71816: OR
71817: IFFALSE 71821
// exit ;
71819: GO 72117
// if direction then
71821: LD_VAR 0 4
71825: IFFALSE 71889
// begin d := 1 ;
71827: LD_ADDR_VAR 0 9
71831: PUSH
71832: LD_INT 1
71834: ST_TO_ADDR
// if i_from > i_to then
71835: LD_VAR 0 2
71839: PUSH
71840: LD_VAR 0 3
71844: GREATER
71845: IFFALSE 71871
// length := ( array - i_from ) + i_to else
71847: LD_ADDR_VAR 0 11
71851: PUSH
71852: LD_VAR 0 1
71856: PUSH
71857: LD_VAR 0 2
71861: MINUS
71862: PUSH
71863: LD_VAR 0 3
71867: PLUS
71868: ST_TO_ADDR
71869: GO 71887
// length := i_to - i_from ;
71871: LD_ADDR_VAR 0 11
71875: PUSH
71876: LD_VAR 0 3
71880: PUSH
71881: LD_VAR 0 2
71885: MINUS
71886: ST_TO_ADDR
// end else
71887: GO 71950
// begin d := - 1 ;
71889: LD_ADDR_VAR 0 9
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: ST_TO_ADDR
// if i_from > i_to then
71898: LD_VAR 0 2
71902: PUSH
71903: LD_VAR 0 3
71907: GREATER
71908: IFFALSE 71928
// length := i_from - i_to else
71910: LD_ADDR_VAR 0 11
71914: PUSH
71915: LD_VAR 0 2
71919: PUSH
71920: LD_VAR 0 3
71924: MINUS
71925: ST_TO_ADDR
71926: GO 71950
// length := ( array - i_to ) + i_from ;
71928: LD_ADDR_VAR 0 11
71932: PUSH
71933: LD_VAR 0 1
71937: PUSH
71938: LD_VAR 0 3
71942: MINUS
71943: PUSH
71944: LD_VAR 0 2
71948: PLUS
71949: ST_TO_ADDR
// end ; if not length then
71950: LD_VAR 0 11
71954: NOT
71955: IFFALSE 71959
// exit ;
71957: GO 72117
// tmp := array ;
71959: LD_ADDR_VAR 0 10
71963: PUSH
71964: LD_VAR 0 1
71968: ST_TO_ADDR
// for i = 1 to length do
71969: LD_ADDR_VAR 0 6
71973: PUSH
71974: DOUBLE
71975: LD_INT 1
71977: DEC
71978: ST_TO_ADDR
71979: LD_VAR 0 11
71983: PUSH
71984: FOR_TO
71985: IFFALSE 72105
// begin for j = 1 to array do
71987: LD_ADDR_VAR 0 7
71991: PUSH
71992: DOUBLE
71993: LD_INT 1
71995: DEC
71996: ST_TO_ADDR
71997: LD_VAR 0 1
72001: PUSH
72002: FOR_TO
72003: IFFALSE 72091
// begin k := j + d ;
72005: LD_ADDR_VAR 0 8
72009: PUSH
72010: LD_VAR 0 7
72014: PUSH
72015: LD_VAR 0 9
72019: PLUS
72020: ST_TO_ADDR
// if k > array then
72021: LD_VAR 0 8
72025: PUSH
72026: LD_VAR 0 1
72030: GREATER
72031: IFFALSE 72041
// k := 1 ;
72033: LD_ADDR_VAR 0 8
72037: PUSH
72038: LD_INT 1
72040: ST_TO_ADDR
// if not k then
72041: LD_VAR 0 8
72045: NOT
72046: IFFALSE 72058
// k := array ;
72048: LD_ADDR_VAR 0 8
72052: PUSH
72053: LD_VAR 0 1
72057: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72058: LD_ADDR_VAR 0 10
72062: PUSH
72063: LD_VAR 0 10
72067: PPUSH
72068: LD_VAR 0 8
72072: PPUSH
72073: LD_VAR 0 1
72077: PUSH
72078: LD_VAR 0 7
72082: ARRAY
72083: PPUSH
72084: CALL_OW 1
72088: ST_TO_ADDR
// end ;
72089: GO 72002
72091: POP
72092: POP
// array := tmp ;
72093: LD_ADDR_VAR 0 1
72097: PUSH
72098: LD_VAR 0 10
72102: ST_TO_ADDR
// end ;
72103: GO 71984
72105: POP
72106: POP
// result := array ;
72107: LD_ADDR_VAR 0 5
72111: PUSH
72112: LD_VAR 0 1
72116: ST_TO_ADDR
// end ;
72117: LD_VAR 0 5
72121: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72122: LD_INT 0
72124: PPUSH
72125: PPUSH
// result := 0 ;
72126: LD_ADDR_VAR 0 3
72130: PUSH
72131: LD_INT 0
72133: ST_TO_ADDR
// if not array or not value in array then
72134: LD_VAR 0 1
72138: NOT
72139: PUSH
72140: LD_VAR 0 2
72144: PUSH
72145: LD_VAR 0 1
72149: IN
72150: NOT
72151: OR
72152: IFFALSE 72156
// exit ;
72154: GO 72210
// for i = 1 to array do
72156: LD_ADDR_VAR 0 4
72160: PUSH
72161: DOUBLE
72162: LD_INT 1
72164: DEC
72165: ST_TO_ADDR
72166: LD_VAR 0 1
72170: PUSH
72171: FOR_TO
72172: IFFALSE 72208
// if value = array [ i ] then
72174: LD_VAR 0 2
72178: PUSH
72179: LD_VAR 0 1
72183: PUSH
72184: LD_VAR 0 4
72188: ARRAY
72189: EQUAL
72190: IFFALSE 72206
// begin result := i ;
72192: LD_ADDR_VAR 0 3
72196: PUSH
72197: LD_VAR 0 4
72201: ST_TO_ADDR
// exit ;
72202: POP
72203: POP
72204: GO 72210
// end ;
72206: GO 72171
72208: POP
72209: POP
// end ;
72210: LD_VAR 0 3
72214: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72215: LD_INT 0
72217: PPUSH
// vc_chassis := chassis ;
72218: LD_ADDR_OWVAR 37
72222: PUSH
72223: LD_VAR 0 1
72227: ST_TO_ADDR
// vc_engine := engine ;
72228: LD_ADDR_OWVAR 39
72232: PUSH
72233: LD_VAR 0 2
72237: ST_TO_ADDR
// vc_control := control ;
72238: LD_ADDR_OWVAR 38
72242: PUSH
72243: LD_VAR 0 3
72247: ST_TO_ADDR
// vc_weapon := weapon ;
72248: LD_ADDR_OWVAR 40
72252: PUSH
72253: LD_VAR 0 4
72257: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72258: LD_ADDR_OWVAR 41
72262: PUSH
72263: LD_VAR 0 5
72267: ST_TO_ADDR
// end ;
72268: LD_VAR 0 6
72272: RET
// export function WantPlant ( unit ) ; var task ; begin
72273: LD_INT 0
72275: PPUSH
72276: PPUSH
// result := false ;
72277: LD_ADDR_VAR 0 2
72281: PUSH
72282: LD_INT 0
72284: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72285: LD_ADDR_VAR 0 3
72289: PUSH
72290: LD_VAR 0 1
72294: PPUSH
72295: CALL_OW 437
72299: ST_TO_ADDR
// if task then
72300: LD_VAR 0 3
72304: IFFALSE 72332
// if task [ 1 ] [ 1 ] = p then
72306: LD_VAR 0 3
72310: PUSH
72311: LD_INT 1
72313: ARRAY
72314: PUSH
72315: LD_INT 1
72317: ARRAY
72318: PUSH
72319: LD_STRING p
72321: EQUAL
72322: IFFALSE 72332
// result := true ;
72324: LD_ADDR_VAR 0 2
72328: PUSH
72329: LD_INT 1
72331: ST_TO_ADDR
// end ;
72332: LD_VAR 0 2
72336: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72337: LD_INT 0
72339: PPUSH
72340: PPUSH
72341: PPUSH
72342: PPUSH
// if pos < 1 then
72343: LD_VAR 0 2
72347: PUSH
72348: LD_INT 1
72350: LESS
72351: IFFALSE 72355
// exit ;
72353: GO 72658
// if pos = 1 then
72355: LD_VAR 0 2
72359: PUSH
72360: LD_INT 1
72362: EQUAL
72363: IFFALSE 72396
// result := Replace ( arr , pos [ 1 ] , value ) else
72365: LD_ADDR_VAR 0 4
72369: PUSH
72370: LD_VAR 0 1
72374: PPUSH
72375: LD_VAR 0 2
72379: PUSH
72380: LD_INT 1
72382: ARRAY
72383: PPUSH
72384: LD_VAR 0 3
72388: PPUSH
72389: CALL_OW 1
72393: ST_TO_ADDR
72394: GO 72658
// begin tmp := arr ;
72396: LD_ADDR_VAR 0 6
72400: PUSH
72401: LD_VAR 0 1
72405: ST_TO_ADDR
// s_arr := [ tmp ] ;
72406: LD_ADDR_VAR 0 7
72410: PUSH
72411: LD_VAR 0 6
72415: PUSH
72416: EMPTY
72417: LIST
72418: ST_TO_ADDR
// for i = 1 to pos - 1 do
72419: LD_ADDR_VAR 0 5
72423: PUSH
72424: DOUBLE
72425: LD_INT 1
72427: DEC
72428: ST_TO_ADDR
72429: LD_VAR 0 2
72433: PUSH
72434: LD_INT 1
72436: MINUS
72437: PUSH
72438: FOR_TO
72439: IFFALSE 72484
// begin tmp := tmp [ pos [ i ] ] ;
72441: LD_ADDR_VAR 0 6
72445: PUSH
72446: LD_VAR 0 6
72450: PUSH
72451: LD_VAR 0 2
72455: PUSH
72456: LD_VAR 0 5
72460: ARRAY
72461: ARRAY
72462: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72463: LD_ADDR_VAR 0 7
72467: PUSH
72468: LD_VAR 0 7
72472: PUSH
72473: LD_VAR 0 6
72477: PUSH
72478: EMPTY
72479: LIST
72480: ADD
72481: ST_TO_ADDR
// end ;
72482: GO 72438
72484: POP
72485: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72486: LD_ADDR_VAR 0 6
72490: PUSH
72491: LD_VAR 0 6
72495: PPUSH
72496: LD_VAR 0 2
72500: PUSH
72501: LD_VAR 0 2
72505: ARRAY
72506: PPUSH
72507: LD_VAR 0 3
72511: PPUSH
72512: CALL_OW 1
72516: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72517: LD_ADDR_VAR 0 7
72521: PUSH
72522: LD_VAR 0 7
72526: PPUSH
72527: LD_VAR 0 7
72531: PPUSH
72532: LD_VAR 0 6
72536: PPUSH
72537: CALL_OW 1
72541: ST_TO_ADDR
// for i = s_arr downto 2 do
72542: LD_ADDR_VAR 0 5
72546: PUSH
72547: DOUBLE
72548: LD_VAR 0 7
72552: INC
72553: ST_TO_ADDR
72554: LD_INT 2
72556: PUSH
72557: FOR_DOWNTO
72558: IFFALSE 72642
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72560: LD_ADDR_VAR 0 6
72564: PUSH
72565: LD_VAR 0 7
72569: PUSH
72570: LD_VAR 0 5
72574: PUSH
72575: LD_INT 1
72577: MINUS
72578: ARRAY
72579: PPUSH
72580: LD_VAR 0 2
72584: PUSH
72585: LD_VAR 0 5
72589: PUSH
72590: LD_INT 1
72592: MINUS
72593: ARRAY
72594: PPUSH
72595: LD_VAR 0 7
72599: PUSH
72600: LD_VAR 0 5
72604: ARRAY
72605: PPUSH
72606: CALL_OW 1
72610: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72611: LD_ADDR_VAR 0 7
72615: PUSH
72616: LD_VAR 0 7
72620: PPUSH
72621: LD_VAR 0 5
72625: PUSH
72626: LD_INT 1
72628: MINUS
72629: PPUSH
72630: LD_VAR 0 6
72634: PPUSH
72635: CALL_OW 1
72639: ST_TO_ADDR
// end ;
72640: GO 72557
72642: POP
72643: POP
// result := s_arr [ 1 ] ;
72644: LD_ADDR_VAR 0 4
72648: PUSH
72649: LD_VAR 0 7
72653: PUSH
72654: LD_INT 1
72656: ARRAY
72657: ST_TO_ADDR
// end ; end ;
72658: LD_VAR 0 4
72662: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72663: LD_INT 0
72665: PPUSH
72666: PPUSH
// if not list then
72667: LD_VAR 0 1
72671: NOT
72672: IFFALSE 72676
// exit ;
72674: GO 72767
// i := list [ pos1 ] ;
72676: LD_ADDR_VAR 0 5
72680: PUSH
72681: LD_VAR 0 1
72685: PUSH
72686: LD_VAR 0 2
72690: ARRAY
72691: ST_TO_ADDR
// if not i then
72692: LD_VAR 0 5
72696: NOT
72697: IFFALSE 72701
// exit ;
72699: GO 72767
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72701: LD_ADDR_VAR 0 1
72705: PUSH
72706: LD_VAR 0 1
72710: PPUSH
72711: LD_VAR 0 2
72715: PPUSH
72716: LD_VAR 0 1
72720: PUSH
72721: LD_VAR 0 3
72725: ARRAY
72726: PPUSH
72727: CALL_OW 1
72731: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72732: LD_ADDR_VAR 0 1
72736: PUSH
72737: LD_VAR 0 1
72741: PPUSH
72742: LD_VAR 0 3
72746: PPUSH
72747: LD_VAR 0 5
72751: PPUSH
72752: CALL_OW 1
72756: ST_TO_ADDR
// result := list ;
72757: LD_ADDR_VAR 0 4
72761: PUSH
72762: LD_VAR 0 1
72766: ST_TO_ADDR
// end ;
72767: LD_VAR 0 4
72771: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72772: LD_INT 0
72774: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72775: LD_ADDR_VAR 0 5
72779: PUSH
72780: LD_VAR 0 1
72784: PPUSH
72785: CALL_OW 250
72789: PPUSH
72790: LD_VAR 0 1
72794: PPUSH
72795: CALL_OW 251
72799: PPUSH
72800: LD_VAR 0 2
72804: PPUSH
72805: LD_VAR 0 3
72809: PPUSH
72810: LD_VAR 0 4
72814: PPUSH
72815: CALL 72825 0 5
72819: ST_TO_ADDR
// end ;
72820: LD_VAR 0 5
72824: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72825: LD_INT 0
72827: PPUSH
72828: PPUSH
72829: PPUSH
72830: PPUSH
// if not list then
72831: LD_VAR 0 3
72835: NOT
72836: IFFALSE 72840
// exit ;
72838: GO 73228
// result := [ ] ;
72840: LD_ADDR_VAR 0 6
72844: PUSH
72845: EMPTY
72846: ST_TO_ADDR
// for i in list do
72847: LD_ADDR_VAR 0 7
72851: PUSH
72852: LD_VAR 0 3
72856: PUSH
72857: FOR_IN
72858: IFFALSE 73060
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72860: LD_ADDR_VAR 0 9
72864: PUSH
72865: LD_VAR 0 7
72869: PPUSH
72870: LD_VAR 0 1
72874: PPUSH
72875: LD_VAR 0 2
72879: PPUSH
72880: CALL_OW 297
72884: ST_TO_ADDR
// if not result then
72885: LD_VAR 0 6
72889: NOT
72890: IFFALSE 72916
// result := [ [ i , tmp ] ] else
72892: LD_ADDR_VAR 0 6
72896: PUSH
72897: LD_VAR 0 7
72901: PUSH
72902: LD_VAR 0 9
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: EMPTY
72912: LIST
72913: ST_TO_ADDR
72914: GO 73058
// begin if result [ result ] [ 2 ] < tmp then
72916: LD_VAR 0 6
72920: PUSH
72921: LD_VAR 0 6
72925: ARRAY
72926: PUSH
72927: LD_INT 2
72929: ARRAY
72930: PUSH
72931: LD_VAR 0 9
72935: LESS
72936: IFFALSE 72978
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72938: LD_ADDR_VAR 0 6
72942: PUSH
72943: LD_VAR 0 6
72947: PPUSH
72948: LD_VAR 0 6
72952: PUSH
72953: LD_INT 1
72955: PLUS
72956: PPUSH
72957: LD_VAR 0 7
72961: PUSH
72962: LD_VAR 0 9
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PPUSH
72971: CALL_OW 2
72975: ST_TO_ADDR
72976: GO 73058
// for j = 1 to result do
72978: LD_ADDR_VAR 0 8
72982: PUSH
72983: DOUBLE
72984: LD_INT 1
72986: DEC
72987: ST_TO_ADDR
72988: LD_VAR 0 6
72992: PUSH
72993: FOR_TO
72994: IFFALSE 73056
// begin if tmp < result [ j ] [ 2 ] then
72996: LD_VAR 0 9
73000: PUSH
73001: LD_VAR 0 6
73005: PUSH
73006: LD_VAR 0 8
73010: ARRAY
73011: PUSH
73012: LD_INT 2
73014: ARRAY
73015: LESS
73016: IFFALSE 73054
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73018: LD_ADDR_VAR 0 6
73022: PUSH
73023: LD_VAR 0 6
73027: PPUSH
73028: LD_VAR 0 8
73032: PPUSH
73033: LD_VAR 0 7
73037: PUSH
73038: LD_VAR 0 9
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PPUSH
73047: CALL_OW 2
73051: ST_TO_ADDR
// break ;
73052: GO 73056
// end ; end ;
73054: GO 72993
73056: POP
73057: POP
// end ; end ;
73058: GO 72857
73060: POP
73061: POP
// if result and not asc then
73062: LD_VAR 0 6
73066: PUSH
73067: LD_VAR 0 4
73071: NOT
73072: AND
73073: IFFALSE 73148
// begin tmp := result ;
73075: LD_ADDR_VAR 0 9
73079: PUSH
73080: LD_VAR 0 6
73084: ST_TO_ADDR
// for i = tmp downto 1 do
73085: LD_ADDR_VAR 0 7
73089: PUSH
73090: DOUBLE
73091: LD_VAR 0 9
73095: INC
73096: ST_TO_ADDR
73097: LD_INT 1
73099: PUSH
73100: FOR_DOWNTO
73101: IFFALSE 73146
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73103: LD_ADDR_VAR 0 6
73107: PUSH
73108: LD_VAR 0 6
73112: PPUSH
73113: LD_VAR 0 9
73117: PUSH
73118: LD_VAR 0 7
73122: MINUS
73123: PUSH
73124: LD_INT 1
73126: PLUS
73127: PPUSH
73128: LD_VAR 0 9
73132: PUSH
73133: LD_VAR 0 7
73137: ARRAY
73138: PPUSH
73139: CALL_OW 1
73143: ST_TO_ADDR
73144: GO 73100
73146: POP
73147: POP
// end ; tmp := [ ] ;
73148: LD_ADDR_VAR 0 9
73152: PUSH
73153: EMPTY
73154: ST_TO_ADDR
// if mode then
73155: LD_VAR 0 5
73159: IFFALSE 73228
// begin for i = 1 to result do
73161: LD_ADDR_VAR 0 7
73165: PUSH
73166: DOUBLE
73167: LD_INT 1
73169: DEC
73170: ST_TO_ADDR
73171: LD_VAR 0 6
73175: PUSH
73176: FOR_TO
73177: IFFALSE 73216
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73179: LD_ADDR_VAR 0 9
73183: PUSH
73184: LD_VAR 0 9
73188: PPUSH
73189: LD_VAR 0 7
73193: PPUSH
73194: LD_VAR 0 6
73198: PUSH
73199: LD_VAR 0 7
73203: ARRAY
73204: PUSH
73205: LD_INT 1
73207: ARRAY
73208: PPUSH
73209: CALL_OW 1
73213: ST_TO_ADDR
73214: GO 73176
73216: POP
73217: POP
// result := tmp ;
73218: LD_ADDR_VAR 0 6
73222: PUSH
73223: LD_VAR 0 9
73227: ST_TO_ADDR
// end ; end ;
73228: LD_VAR 0 6
73232: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73233: LD_INT 0
73235: PPUSH
73236: PPUSH
73237: PPUSH
73238: PPUSH
73239: PPUSH
73240: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73241: LD_ADDR_VAR 0 5
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: LD_INT 0
73254: PUSH
73255: EMPTY
73256: PUSH
73257: EMPTY
73258: LIST
73259: LIST
73260: LIST
73261: LIST
73262: ST_TO_ADDR
// if not x or not y then
73263: LD_VAR 0 2
73267: NOT
73268: PUSH
73269: LD_VAR 0 3
73273: NOT
73274: OR
73275: IFFALSE 73279
// exit ;
73277: GO 74925
// if not range then
73279: LD_VAR 0 4
73283: NOT
73284: IFFALSE 73294
// range := 10 ;
73286: LD_ADDR_VAR 0 4
73290: PUSH
73291: LD_INT 10
73293: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73294: LD_ADDR_VAR 0 8
73298: PUSH
73299: LD_INT 81
73301: PUSH
73302: LD_VAR 0 1
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 92
73313: PUSH
73314: LD_VAR 0 2
73318: PUSH
73319: LD_VAR 0 3
73323: PUSH
73324: LD_VAR 0 4
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 3
73337: PUSH
73338: LD_INT 21
73340: PUSH
73341: LD_INT 3
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: LIST
73356: PPUSH
73357: CALL_OW 69
73361: ST_TO_ADDR
// if not tmp then
73362: LD_VAR 0 8
73366: NOT
73367: IFFALSE 73371
// exit ;
73369: GO 74925
// for i in tmp do
73371: LD_ADDR_VAR 0 6
73375: PUSH
73376: LD_VAR 0 8
73380: PUSH
73381: FOR_IN
73382: IFFALSE 74900
// begin points := [ 0 , 0 , 0 ] ;
73384: LD_ADDR_VAR 0 9
73388: PUSH
73389: LD_INT 0
73391: PUSH
73392: LD_INT 0
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: LIST
73402: ST_TO_ADDR
// bpoints := 1 ;
73403: LD_ADDR_VAR 0 10
73407: PUSH
73408: LD_INT 1
73410: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73411: LD_VAR 0 6
73415: PPUSH
73416: CALL_OW 247
73420: PUSH
73421: LD_INT 1
73423: DOUBLE
73424: EQUAL
73425: IFTRUE 73429
73427: GO 74007
73429: POP
// begin if GetClass ( i ) = 1 then
73430: LD_VAR 0 6
73434: PPUSH
73435: CALL_OW 257
73439: PUSH
73440: LD_INT 1
73442: EQUAL
73443: IFFALSE 73464
// points := [ 10 , 5 , 3 ] ;
73445: LD_ADDR_VAR 0 9
73449: PUSH
73450: LD_INT 10
73452: PUSH
73453: LD_INT 5
73455: PUSH
73456: LD_INT 3
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73464: LD_VAR 0 6
73468: PPUSH
73469: CALL_OW 257
73473: PUSH
73474: LD_INT 2
73476: PUSH
73477: LD_INT 3
73479: PUSH
73480: LD_INT 4
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: LIST
73487: IN
73488: IFFALSE 73509
// points := [ 3 , 2 , 1 ] ;
73490: LD_ADDR_VAR 0 9
73494: PUSH
73495: LD_INT 3
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: LD_INT 1
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: LIST
73508: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73509: LD_VAR 0 6
73513: PPUSH
73514: CALL_OW 257
73518: PUSH
73519: LD_INT 5
73521: EQUAL
73522: IFFALSE 73543
// points := [ 130 , 5 , 2 ] ;
73524: LD_ADDR_VAR 0 9
73528: PUSH
73529: LD_INT 130
73531: PUSH
73532: LD_INT 5
73534: PUSH
73535: LD_INT 2
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: LIST
73542: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73543: LD_VAR 0 6
73547: PPUSH
73548: CALL_OW 257
73552: PUSH
73553: LD_INT 8
73555: EQUAL
73556: IFFALSE 73577
// points := [ 35 , 35 , 30 ] ;
73558: LD_ADDR_VAR 0 9
73562: PUSH
73563: LD_INT 35
73565: PUSH
73566: LD_INT 35
73568: PUSH
73569: LD_INT 30
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: LIST
73576: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73577: LD_VAR 0 6
73581: PPUSH
73582: CALL_OW 257
73586: PUSH
73587: LD_INT 9
73589: EQUAL
73590: IFFALSE 73611
// points := [ 20 , 55 , 40 ] ;
73592: LD_ADDR_VAR 0 9
73596: PUSH
73597: LD_INT 20
73599: PUSH
73600: LD_INT 55
73602: PUSH
73603: LD_INT 40
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: LIST
73610: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73611: LD_VAR 0 6
73615: PPUSH
73616: CALL_OW 257
73620: PUSH
73621: LD_INT 12
73623: PUSH
73624: LD_INT 16
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: IN
73631: IFFALSE 73652
// points := [ 5 , 3 , 2 ] ;
73633: LD_ADDR_VAR 0 9
73637: PUSH
73638: LD_INT 5
73640: PUSH
73641: LD_INT 3
73643: PUSH
73644: LD_INT 2
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: LIST
73651: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73652: LD_VAR 0 6
73656: PPUSH
73657: CALL_OW 257
73661: PUSH
73662: LD_INT 17
73664: EQUAL
73665: IFFALSE 73686
// points := [ 100 , 50 , 75 ] ;
73667: LD_ADDR_VAR 0 9
73671: PUSH
73672: LD_INT 100
73674: PUSH
73675: LD_INT 50
73677: PUSH
73678: LD_INT 75
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: LIST
73685: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73686: LD_VAR 0 6
73690: PPUSH
73691: CALL_OW 257
73695: PUSH
73696: LD_INT 15
73698: EQUAL
73699: IFFALSE 73720
// points := [ 10 , 5 , 3 ] ;
73701: LD_ADDR_VAR 0 9
73705: PUSH
73706: LD_INT 10
73708: PUSH
73709: LD_INT 5
73711: PUSH
73712: LD_INT 3
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: LIST
73719: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73720: LD_VAR 0 6
73724: PPUSH
73725: CALL_OW 257
73729: PUSH
73730: LD_INT 14
73732: EQUAL
73733: IFFALSE 73754
// points := [ 10 , 0 , 0 ] ;
73735: LD_ADDR_VAR 0 9
73739: PUSH
73740: LD_INT 10
73742: PUSH
73743: LD_INT 0
73745: PUSH
73746: LD_INT 0
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: LIST
73753: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73754: LD_VAR 0 6
73758: PPUSH
73759: CALL_OW 257
73763: PUSH
73764: LD_INT 11
73766: EQUAL
73767: IFFALSE 73788
// points := [ 30 , 10 , 5 ] ;
73769: LD_ADDR_VAR 0 9
73773: PUSH
73774: LD_INT 30
73776: PUSH
73777: LD_INT 10
73779: PUSH
73780: LD_INT 5
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73788: LD_VAR 0 1
73792: PPUSH
73793: LD_INT 5
73795: PPUSH
73796: CALL_OW 321
73800: PUSH
73801: LD_INT 2
73803: EQUAL
73804: IFFALSE 73821
// bpoints := bpoints * 1.8 ;
73806: LD_ADDR_VAR 0 10
73810: PUSH
73811: LD_VAR 0 10
73815: PUSH
73816: LD_REAL  1.80000000000000E+0000
73819: MUL
73820: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73821: LD_VAR 0 6
73825: PPUSH
73826: CALL_OW 257
73830: PUSH
73831: LD_INT 1
73833: PUSH
73834: LD_INT 2
73836: PUSH
73837: LD_INT 3
73839: PUSH
73840: LD_INT 4
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: LIST
73847: LIST
73848: IN
73849: PUSH
73850: LD_VAR 0 1
73854: PPUSH
73855: LD_INT 51
73857: PPUSH
73858: CALL_OW 321
73862: PUSH
73863: LD_INT 2
73865: EQUAL
73866: AND
73867: IFFALSE 73884
// bpoints := bpoints * 1.2 ;
73869: LD_ADDR_VAR 0 10
73873: PUSH
73874: LD_VAR 0 10
73878: PUSH
73879: LD_REAL  1.20000000000000E+0000
73882: MUL
73883: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73884: LD_VAR 0 6
73888: PPUSH
73889: CALL_OW 257
73893: PUSH
73894: LD_INT 5
73896: PUSH
73897: LD_INT 7
73899: PUSH
73900: LD_INT 9
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: LIST
73907: IN
73908: PUSH
73909: LD_VAR 0 1
73913: PPUSH
73914: LD_INT 52
73916: PPUSH
73917: CALL_OW 321
73921: PUSH
73922: LD_INT 2
73924: EQUAL
73925: AND
73926: IFFALSE 73943
// bpoints := bpoints * 1.5 ;
73928: LD_ADDR_VAR 0 10
73932: PUSH
73933: LD_VAR 0 10
73937: PUSH
73938: LD_REAL  1.50000000000000E+0000
73941: MUL
73942: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73943: LD_VAR 0 1
73947: PPUSH
73948: LD_INT 66
73950: PPUSH
73951: CALL_OW 321
73955: PUSH
73956: LD_INT 2
73958: EQUAL
73959: IFFALSE 73976
// bpoints := bpoints * 1.1 ;
73961: LD_ADDR_VAR 0 10
73965: PUSH
73966: LD_VAR 0 10
73970: PUSH
73971: LD_REAL  1.10000000000000E+0000
73974: MUL
73975: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73976: LD_ADDR_VAR 0 10
73980: PUSH
73981: LD_VAR 0 10
73985: PUSH
73986: LD_VAR 0 6
73990: PPUSH
73991: LD_INT 1
73993: PPUSH
73994: CALL_OW 259
73998: PUSH
73999: LD_REAL  1.15000000000000E+0000
74002: MUL
74003: MUL
74004: ST_TO_ADDR
// end ; unit_vehicle :
74005: GO 74829
74007: LD_INT 2
74009: DOUBLE
74010: EQUAL
74011: IFTRUE 74015
74013: GO 74817
74015: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74016: LD_VAR 0 6
74020: PPUSH
74021: CALL_OW 264
74025: PUSH
74026: LD_INT 2
74028: PUSH
74029: LD_INT 42
74031: PUSH
74032: LD_INT 24
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: LIST
74039: IN
74040: IFFALSE 74061
// points := [ 25 , 5 , 3 ] ;
74042: LD_ADDR_VAR 0 9
74046: PUSH
74047: LD_INT 25
74049: PUSH
74050: LD_INT 5
74052: PUSH
74053: LD_INT 3
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: LIST
74060: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74061: LD_VAR 0 6
74065: PPUSH
74066: CALL_OW 264
74070: PUSH
74071: LD_INT 4
74073: PUSH
74074: LD_INT 43
74076: PUSH
74077: LD_INT 25
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: LIST
74084: IN
74085: IFFALSE 74106
// points := [ 40 , 15 , 5 ] ;
74087: LD_ADDR_VAR 0 9
74091: PUSH
74092: LD_INT 40
74094: PUSH
74095: LD_INT 15
74097: PUSH
74098: LD_INT 5
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: LIST
74105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74106: LD_VAR 0 6
74110: PPUSH
74111: CALL_OW 264
74115: PUSH
74116: LD_INT 3
74118: PUSH
74119: LD_INT 23
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: IN
74126: IFFALSE 74147
// points := [ 7 , 25 , 8 ] ;
74128: LD_ADDR_VAR 0 9
74132: PUSH
74133: LD_INT 7
74135: PUSH
74136: LD_INT 25
74138: PUSH
74139: LD_INT 8
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: LIST
74146: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74147: LD_VAR 0 6
74151: PPUSH
74152: CALL_OW 264
74156: PUSH
74157: LD_INT 5
74159: PUSH
74160: LD_INT 27
74162: PUSH
74163: LD_INT 44
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: LIST
74170: IN
74171: IFFALSE 74192
// points := [ 14 , 50 , 16 ] ;
74173: LD_ADDR_VAR 0 9
74177: PUSH
74178: LD_INT 14
74180: PUSH
74181: LD_INT 50
74183: PUSH
74184: LD_INT 16
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: LIST
74191: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74192: LD_VAR 0 6
74196: PPUSH
74197: CALL_OW 264
74201: PUSH
74202: LD_INT 6
74204: PUSH
74205: LD_INT 46
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: IN
74212: IFFALSE 74233
// points := [ 32 , 120 , 70 ] ;
74214: LD_ADDR_VAR 0 9
74218: PUSH
74219: LD_INT 32
74221: PUSH
74222: LD_INT 120
74224: PUSH
74225: LD_INT 70
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: LIST
74232: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
74233: LD_VAR 0 6
74237: PPUSH
74238: CALL_OW 264
74242: PUSH
74243: LD_INT 7
74245: PUSH
74246: LD_INT 28
74248: PUSH
74249: LD_INT 45
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: LIST
74256: IN
74257: IFFALSE 74278
// points := [ 35 , 20 , 45 ] ;
74259: LD_ADDR_VAR 0 9
74263: PUSH
74264: LD_INT 35
74266: PUSH
74267: LD_INT 20
74269: PUSH
74270: LD_INT 45
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: LIST
74277: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74278: LD_VAR 0 6
74282: PPUSH
74283: CALL_OW 264
74287: PUSH
74288: LD_INT 47
74290: PUSH
74291: EMPTY
74292: LIST
74293: IN
74294: IFFALSE 74315
// points := [ 67 , 45 , 75 ] ;
74296: LD_ADDR_VAR 0 9
74300: PUSH
74301: LD_INT 67
74303: PUSH
74304: LD_INT 45
74306: PUSH
74307: LD_INT 75
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: LIST
74314: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74315: LD_VAR 0 6
74319: PPUSH
74320: CALL_OW 264
74324: PUSH
74325: LD_INT 26
74327: PUSH
74328: EMPTY
74329: LIST
74330: IN
74331: IFFALSE 74352
// points := [ 120 , 30 , 80 ] ;
74333: LD_ADDR_VAR 0 9
74337: PUSH
74338: LD_INT 120
74340: PUSH
74341: LD_INT 30
74343: PUSH
74344: LD_INT 80
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: LIST
74351: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74352: LD_VAR 0 6
74356: PPUSH
74357: CALL_OW 264
74361: PUSH
74362: LD_INT 22
74364: PUSH
74365: EMPTY
74366: LIST
74367: IN
74368: IFFALSE 74389
// points := [ 40 , 1 , 1 ] ;
74370: LD_ADDR_VAR 0 9
74374: PUSH
74375: LD_INT 40
74377: PUSH
74378: LD_INT 1
74380: PUSH
74381: LD_INT 1
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74389: LD_VAR 0 6
74393: PPUSH
74394: CALL_OW 264
74398: PUSH
74399: LD_INT 29
74401: PUSH
74402: EMPTY
74403: LIST
74404: IN
74405: IFFALSE 74426
// points := [ 70 , 200 , 400 ] ;
74407: LD_ADDR_VAR 0 9
74411: PUSH
74412: LD_INT 70
74414: PUSH
74415: LD_INT 200
74417: PUSH
74418: LD_INT 400
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: LIST
74425: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74426: LD_VAR 0 6
74430: PPUSH
74431: CALL_OW 264
74435: PUSH
74436: LD_INT 14
74438: PUSH
74439: LD_INT 53
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: IN
74446: IFFALSE 74467
// points := [ 40 , 10 , 20 ] ;
74448: LD_ADDR_VAR 0 9
74452: PUSH
74453: LD_INT 40
74455: PUSH
74456: LD_INT 10
74458: PUSH
74459: LD_INT 20
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: LIST
74466: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74467: LD_VAR 0 6
74471: PPUSH
74472: CALL_OW 264
74476: PUSH
74477: LD_INT 9
74479: PUSH
74480: EMPTY
74481: LIST
74482: IN
74483: IFFALSE 74504
// points := [ 5 , 70 , 20 ] ;
74485: LD_ADDR_VAR 0 9
74489: PUSH
74490: LD_INT 5
74492: PUSH
74493: LD_INT 70
74495: PUSH
74496: LD_INT 20
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: LIST
74503: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74504: LD_VAR 0 6
74508: PPUSH
74509: CALL_OW 264
74513: PUSH
74514: LD_INT 10
74516: PUSH
74517: EMPTY
74518: LIST
74519: IN
74520: IFFALSE 74541
// points := [ 35 , 110 , 70 ] ;
74522: LD_ADDR_VAR 0 9
74526: PUSH
74527: LD_INT 35
74529: PUSH
74530: LD_INT 110
74532: PUSH
74533: LD_INT 70
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: LIST
74540: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74541: LD_VAR 0 6
74545: PPUSH
74546: CALL_OW 265
74550: PUSH
74551: LD_INT 25
74553: EQUAL
74554: IFFALSE 74575
// points := [ 80 , 65 , 100 ] ;
74556: LD_ADDR_VAR 0 9
74560: PUSH
74561: LD_INT 80
74563: PUSH
74564: LD_INT 65
74566: PUSH
74567: LD_INT 100
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: LIST
74574: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74575: LD_VAR 0 6
74579: PPUSH
74580: CALL_OW 263
74584: PUSH
74585: LD_INT 1
74587: EQUAL
74588: IFFALSE 74623
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74590: LD_ADDR_VAR 0 10
74594: PUSH
74595: LD_VAR 0 10
74599: PUSH
74600: LD_VAR 0 6
74604: PPUSH
74605: CALL_OW 311
74609: PPUSH
74610: LD_INT 3
74612: PPUSH
74613: CALL_OW 259
74617: PUSH
74618: LD_INT 4
74620: MUL
74621: MUL
74622: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74623: LD_VAR 0 6
74627: PPUSH
74628: CALL_OW 263
74632: PUSH
74633: LD_INT 2
74635: EQUAL
74636: IFFALSE 74687
// begin j := IsControledBy ( i ) ;
74638: LD_ADDR_VAR 0 7
74642: PUSH
74643: LD_VAR 0 6
74647: PPUSH
74648: CALL_OW 312
74652: ST_TO_ADDR
// if j then
74653: LD_VAR 0 7
74657: IFFALSE 74687
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74659: LD_ADDR_VAR 0 10
74663: PUSH
74664: LD_VAR 0 10
74668: PUSH
74669: LD_VAR 0 7
74673: PPUSH
74674: LD_INT 3
74676: PPUSH
74677: CALL_OW 259
74681: PUSH
74682: LD_INT 3
74684: MUL
74685: MUL
74686: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74687: LD_VAR 0 6
74691: PPUSH
74692: CALL_OW 264
74696: PUSH
74697: LD_INT 5
74699: PUSH
74700: LD_INT 6
74702: PUSH
74703: LD_INT 46
74705: PUSH
74706: LD_INT 44
74708: PUSH
74709: LD_INT 47
74711: PUSH
74712: LD_INT 45
74714: PUSH
74715: LD_INT 28
74717: PUSH
74718: LD_INT 7
74720: PUSH
74721: LD_INT 27
74723: PUSH
74724: LD_INT 29
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: IN
74739: PUSH
74740: LD_VAR 0 1
74744: PPUSH
74745: LD_INT 52
74747: PPUSH
74748: CALL_OW 321
74752: PUSH
74753: LD_INT 2
74755: EQUAL
74756: AND
74757: IFFALSE 74774
// bpoints := bpoints * 1.2 ;
74759: LD_ADDR_VAR 0 10
74763: PUSH
74764: LD_VAR 0 10
74768: PUSH
74769: LD_REAL  1.20000000000000E+0000
74772: MUL
74773: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74774: LD_VAR 0 6
74778: PPUSH
74779: CALL_OW 264
74783: PUSH
74784: LD_INT 6
74786: PUSH
74787: LD_INT 46
74789: PUSH
74790: LD_INT 47
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: LIST
74797: IN
74798: IFFALSE 74815
// bpoints := bpoints * 1.2 ;
74800: LD_ADDR_VAR 0 10
74804: PUSH
74805: LD_VAR 0 10
74809: PUSH
74810: LD_REAL  1.20000000000000E+0000
74813: MUL
74814: ST_TO_ADDR
// end ; unit_building :
74815: GO 74829
74817: LD_INT 3
74819: DOUBLE
74820: EQUAL
74821: IFTRUE 74825
74823: GO 74828
74825: POP
// ; end ;
74826: GO 74829
74828: POP
// for j = 1 to 3 do
74829: LD_ADDR_VAR 0 7
74833: PUSH
74834: DOUBLE
74835: LD_INT 1
74837: DEC
74838: ST_TO_ADDR
74839: LD_INT 3
74841: PUSH
74842: FOR_TO
74843: IFFALSE 74896
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74845: LD_ADDR_VAR 0 5
74849: PUSH
74850: LD_VAR 0 5
74854: PPUSH
74855: LD_VAR 0 7
74859: PPUSH
74860: LD_VAR 0 5
74864: PUSH
74865: LD_VAR 0 7
74869: ARRAY
74870: PUSH
74871: LD_VAR 0 9
74875: PUSH
74876: LD_VAR 0 7
74880: ARRAY
74881: PUSH
74882: LD_VAR 0 10
74886: MUL
74887: PLUS
74888: PPUSH
74889: CALL_OW 1
74893: ST_TO_ADDR
74894: GO 74842
74896: POP
74897: POP
// end ;
74898: GO 73381
74900: POP
74901: POP
// result := Replace ( result , 4 , tmp ) ;
74902: LD_ADDR_VAR 0 5
74906: PUSH
74907: LD_VAR 0 5
74911: PPUSH
74912: LD_INT 4
74914: PPUSH
74915: LD_VAR 0 8
74919: PPUSH
74920: CALL_OW 1
74924: ST_TO_ADDR
// end ;
74925: LD_VAR 0 5
74929: RET
// export function DangerAtRange ( unit , range ) ; begin
74930: LD_INT 0
74932: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74933: LD_ADDR_VAR 0 3
74937: PUSH
74938: LD_VAR 0 1
74942: PPUSH
74943: CALL_OW 255
74947: PPUSH
74948: LD_VAR 0 1
74952: PPUSH
74953: CALL_OW 250
74957: PPUSH
74958: LD_VAR 0 1
74962: PPUSH
74963: CALL_OW 251
74967: PPUSH
74968: LD_VAR 0 2
74972: PPUSH
74973: CALL 73233 0 4
74977: ST_TO_ADDR
// end ;
74978: LD_VAR 0 3
74982: RET
// export function DangerInArea ( side , area ) ; begin
74983: LD_INT 0
74985: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74986: LD_ADDR_VAR 0 3
74990: PUSH
74991: LD_VAR 0 2
74995: PPUSH
74996: LD_INT 81
74998: PUSH
74999: LD_VAR 0 1
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PPUSH
75008: CALL_OW 70
75012: ST_TO_ADDR
// end ;
75013: LD_VAR 0 3
75017: RET
// export function IsExtension ( b ) ; begin
75018: LD_INT 0
75020: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75021: LD_ADDR_VAR 0 2
75025: PUSH
75026: LD_VAR 0 1
75030: PUSH
75031: LD_INT 23
75033: PUSH
75034: LD_INT 20
75036: PUSH
75037: LD_INT 22
75039: PUSH
75040: LD_INT 17
75042: PUSH
75043: LD_INT 24
75045: PUSH
75046: LD_INT 21
75048: PUSH
75049: LD_INT 19
75051: PUSH
75052: LD_INT 16
75054: PUSH
75055: LD_INT 25
75057: PUSH
75058: LD_INT 18
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: IN
75073: ST_TO_ADDR
// end ;
75074: LD_VAR 0 2
75078: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
75079: LD_INT 0
75081: PPUSH
75082: PPUSH
75083: PPUSH
// result := [ ] ;
75084: LD_ADDR_VAR 0 3
75088: PUSH
75089: EMPTY
75090: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75091: LD_ADDR_VAR 0 4
75095: PUSH
75096: LD_VAR 0 2
75100: PPUSH
75101: LD_INT 21
75103: PUSH
75104: LD_INT 3
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PPUSH
75111: CALL_OW 70
75115: ST_TO_ADDR
// if not tmp then
75116: LD_VAR 0 4
75120: NOT
75121: IFFALSE 75125
// exit ;
75123: GO 75183
// for i in tmp do
75125: LD_ADDR_VAR 0 5
75129: PUSH
75130: LD_VAR 0 4
75134: PUSH
75135: FOR_IN
75136: IFFALSE 75171
// if GetBase ( i ) <> base then
75138: LD_VAR 0 5
75142: PPUSH
75143: CALL_OW 274
75147: PUSH
75148: LD_VAR 0 1
75152: NONEQUAL
75153: IFFALSE 75169
// ComLinkToBase ( base , i ) ;
75155: LD_VAR 0 1
75159: PPUSH
75160: LD_VAR 0 5
75164: PPUSH
75165: CALL_OW 169
75169: GO 75135
75171: POP
75172: POP
// result := tmp ;
75173: LD_ADDR_VAR 0 3
75177: PUSH
75178: LD_VAR 0 4
75182: ST_TO_ADDR
// end ;
75183: LD_VAR 0 3
75187: RET
// export function ComComplete ( unit , b ) ; var i ; begin
75188: LD_INT 0
75190: PPUSH
75191: PPUSH
// if BuildingStatus ( b ) = bs_build then
75192: LD_VAR 0 2
75196: PPUSH
75197: CALL_OW 461
75201: PUSH
75202: LD_INT 1
75204: EQUAL
75205: IFFALSE 75265
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75207: LD_VAR 0 1
75211: PPUSH
75212: LD_STRING h
75214: PUSH
75215: LD_VAR 0 2
75219: PPUSH
75220: CALL_OW 250
75224: PUSH
75225: LD_VAR 0 2
75229: PPUSH
75230: CALL_OW 251
75234: PUSH
75235: LD_VAR 0 2
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: LD_INT 0
75245: PUSH
75246: LD_INT 0
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: PUSH
75258: EMPTY
75259: LIST
75260: PPUSH
75261: CALL_OW 446
// end ;
75265: LD_VAR 0 3
75269: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75270: LD_INT 0
75272: PPUSH
75273: PPUSH
75274: PPUSH
75275: PPUSH
75276: PPUSH
75277: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
75278: LD_VAR 0 1
75282: NOT
75283: PUSH
75284: LD_VAR 0 1
75288: PPUSH
75289: CALL_OW 263
75293: PUSH
75294: LD_INT 2
75296: EQUAL
75297: NOT
75298: OR
75299: IFFALSE 75303
// exit ;
75301: GO 75619
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75303: LD_ADDR_VAR 0 6
75307: PUSH
75308: LD_INT 22
75310: PUSH
75311: LD_VAR 0 1
75315: PPUSH
75316: CALL_OW 255
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 2
75327: PUSH
75328: LD_INT 30
75330: PUSH
75331: LD_INT 36
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 34
75340: PUSH
75341: LD_INT 31
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: LIST
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PPUSH
75357: CALL_OW 69
75361: ST_TO_ADDR
// if not tmp then
75362: LD_VAR 0 6
75366: NOT
75367: IFFALSE 75371
// exit ;
75369: GO 75619
// result := [ ] ;
75371: LD_ADDR_VAR 0 2
75375: PUSH
75376: EMPTY
75377: ST_TO_ADDR
// for i in tmp do
75378: LD_ADDR_VAR 0 3
75382: PUSH
75383: LD_VAR 0 6
75387: PUSH
75388: FOR_IN
75389: IFFALSE 75460
// begin t := UnitsInside ( i ) ;
75391: LD_ADDR_VAR 0 4
75395: PUSH
75396: LD_VAR 0 3
75400: PPUSH
75401: CALL_OW 313
75405: ST_TO_ADDR
// if t then
75406: LD_VAR 0 4
75410: IFFALSE 75458
// for j in t do
75412: LD_ADDR_VAR 0 7
75416: PUSH
75417: LD_VAR 0 4
75421: PUSH
75422: FOR_IN
75423: IFFALSE 75456
// result := Insert ( result , result + 1 , j ) ;
75425: LD_ADDR_VAR 0 2
75429: PUSH
75430: LD_VAR 0 2
75434: PPUSH
75435: LD_VAR 0 2
75439: PUSH
75440: LD_INT 1
75442: PLUS
75443: PPUSH
75444: LD_VAR 0 7
75448: PPUSH
75449: CALL_OW 2
75453: ST_TO_ADDR
75454: GO 75422
75456: POP
75457: POP
// end ;
75458: GO 75388
75460: POP
75461: POP
// if not result then
75462: LD_VAR 0 2
75466: NOT
75467: IFFALSE 75471
// exit ;
75469: GO 75619
// mech := result [ 1 ] ;
75471: LD_ADDR_VAR 0 5
75475: PUSH
75476: LD_VAR 0 2
75480: PUSH
75481: LD_INT 1
75483: ARRAY
75484: ST_TO_ADDR
// if result > 1 then
75485: LD_VAR 0 2
75489: PUSH
75490: LD_INT 1
75492: GREATER
75493: IFFALSE 75605
// for i = 2 to result do
75495: LD_ADDR_VAR 0 3
75499: PUSH
75500: DOUBLE
75501: LD_INT 2
75503: DEC
75504: ST_TO_ADDR
75505: LD_VAR 0 2
75509: PUSH
75510: FOR_TO
75511: IFFALSE 75603
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75513: LD_ADDR_VAR 0 4
75517: PUSH
75518: LD_VAR 0 2
75522: PUSH
75523: LD_VAR 0 3
75527: ARRAY
75528: PPUSH
75529: LD_INT 3
75531: PPUSH
75532: CALL_OW 259
75536: PUSH
75537: LD_VAR 0 2
75541: PUSH
75542: LD_VAR 0 3
75546: ARRAY
75547: PPUSH
75548: CALL_OW 432
75552: MINUS
75553: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75554: LD_VAR 0 4
75558: PUSH
75559: LD_VAR 0 5
75563: PPUSH
75564: LD_INT 3
75566: PPUSH
75567: CALL_OW 259
75571: PUSH
75572: LD_VAR 0 5
75576: PPUSH
75577: CALL_OW 432
75581: MINUS
75582: GREATEREQUAL
75583: IFFALSE 75601
// mech := result [ i ] ;
75585: LD_ADDR_VAR 0 5
75589: PUSH
75590: LD_VAR 0 2
75594: PUSH
75595: LD_VAR 0 3
75599: ARRAY
75600: ST_TO_ADDR
// end ;
75601: GO 75510
75603: POP
75604: POP
// ComLinkTo ( vehicle , mech ) ;
75605: LD_VAR 0 1
75609: PPUSH
75610: LD_VAR 0 5
75614: PPUSH
75615: CALL_OW 135
// end ;
75619: LD_VAR 0 2
75623: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75624: LD_INT 0
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
75630: PPUSH
75631: PPUSH
75632: PPUSH
75633: PPUSH
75634: PPUSH
75635: PPUSH
75636: PPUSH
75637: PPUSH
75638: PPUSH
// result := [ ] ;
75639: LD_ADDR_VAR 0 7
75643: PUSH
75644: EMPTY
75645: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75646: LD_VAR 0 1
75650: PPUSH
75651: CALL_OW 266
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: LD_INT 1
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: IN
75666: NOT
75667: IFFALSE 75671
// exit ;
75669: GO 77302
// if name then
75671: LD_VAR 0 3
75675: IFFALSE 75691
// SetBName ( base_dep , name ) ;
75677: LD_VAR 0 1
75681: PPUSH
75682: LD_VAR 0 3
75686: PPUSH
75687: CALL_OW 500
// base := GetBase ( base_dep ) ;
75691: LD_ADDR_VAR 0 15
75695: PUSH
75696: LD_VAR 0 1
75700: PPUSH
75701: CALL_OW 274
75705: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75706: LD_ADDR_VAR 0 16
75710: PUSH
75711: LD_VAR 0 1
75715: PPUSH
75716: CALL_OW 255
75720: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75721: LD_ADDR_VAR 0 17
75725: PUSH
75726: LD_VAR 0 1
75730: PPUSH
75731: CALL_OW 248
75735: ST_TO_ADDR
// if sources then
75736: LD_VAR 0 5
75740: IFFALSE 75787
// for i = 1 to 3 do
75742: LD_ADDR_VAR 0 8
75746: PUSH
75747: DOUBLE
75748: LD_INT 1
75750: DEC
75751: ST_TO_ADDR
75752: LD_INT 3
75754: PUSH
75755: FOR_TO
75756: IFFALSE 75785
// AddResourceType ( base , i , sources [ i ] ) ;
75758: LD_VAR 0 15
75762: PPUSH
75763: LD_VAR 0 8
75767: PPUSH
75768: LD_VAR 0 5
75772: PUSH
75773: LD_VAR 0 8
75777: ARRAY
75778: PPUSH
75779: CALL_OW 276
75783: GO 75755
75785: POP
75786: POP
// buildings := GetBaseBuildings ( base , area ) ;
75787: LD_ADDR_VAR 0 18
75791: PUSH
75792: LD_VAR 0 15
75796: PPUSH
75797: LD_VAR 0 2
75801: PPUSH
75802: CALL 75079 0 2
75806: ST_TO_ADDR
// InitHc ;
75807: CALL_OW 19
// InitUc ;
75811: CALL_OW 18
// uc_side := side ;
75815: LD_ADDR_OWVAR 20
75819: PUSH
75820: LD_VAR 0 16
75824: ST_TO_ADDR
// uc_nation := nation ;
75825: LD_ADDR_OWVAR 21
75829: PUSH
75830: LD_VAR 0 17
75834: ST_TO_ADDR
// if buildings then
75835: LD_VAR 0 18
75839: IFFALSE 77161
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75841: LD_ADDR_VAR 0 19
75845: PUSH
75846: LD_VAR 0 18
75850: PPUSH
75851: LD_INT 2
75853: PUSH
75854: LD_INT 30
75856: PUSH
75857: LD_INT 29
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 30
75866: PUSH
75867: LD_INT 30
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: LIST
75878: PPUSH
75879: CALL_OW 72
75883: ST_TO_ADDR
// if tmp then
75884: LD_VAR 0 19
75888: IFFALSE 75936
// for i in tmp do
75890: LD_ADDR_VAR 0 8
75894: PUSH
75895: LD_VAR 0 19
75899: PUSH
75900: FOR_IN
75901: IFFALSE 75934
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75903: LD_VAR 0 8
75907: PPUSH
75908: CALL_OW 250
75912: PPUSH
75913: LD_VAR 0 8
75917: PPUSH
75918: CALL_OW 251
75922: PPUSH
75923: LD_VAR 0 16
75927: PPUSH
75928: CALL_OW 441
75932: GO 75900
75934: POP
75935: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75936: LD_VAR 0 18
75940: PPUSH
75941: LD_INT 2
75943: PUSH
75944: LD_INT 30
75946: PUSH
75947: LD_INT 32
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 30
75956: PUSH
75957: LD_INT 33
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: LIST
75968: PPUSH
75969: CALL_OW 72
75973: IFFALSE 76061
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75975: LD_ADDR_VAR 0 8
75979: PUSH
75980: LD_VAR 0 18
75984: PPUSH
75985: LD_INT 2
75987: PUSH
75988: LD_INT 30
75990: PUSH
75991: LD_INT 32
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: LD_INT 30
76000: PUSH
76001: LD_INT 33
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: LIST
76012: PPUSH
76013: CALL_OW 72
76017: PUSH
76018: FOR_IN
76019: IFFALSE 76059
// begin if not GetBWeapon ( i ) then
76021: LD_VAR 0 8
76025: PPUSH
76026: CALL_OW 269
76030: NOT
76031: IFFALSE 76057
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76033: LD_VAR 0 8
76037: PPUSH
76038: LD_VAR 0 8
76042: PPUSH
76043: LD_VAR 0 2
76047: PPUSH
76048: CALL 77307 0 2
76052: PPUSH
76053: CALL_OW 431
// end ;
76057: GO 76018
76059: POP
76060: POP
// end ; for i = 1 to personel do
76061: LD_ADDR_VAR 0 8
76065: PUSH
76066: DOUBLE
76067: LD_INT 1
76069: DEC
76070: ST_TO_ADDR
76071: LD_VAR 0 6
76075: PUSH
76076: FOR_TO
76077: IFFALSE 77141
// begin if i > 4 then
76079: LD_VAR 0 8
76083: PUSH
76084: LD_INT 4
76086: GREATER
76087: IFFALSE 76091
// break ;
76089: GO 77141
// case i of 1 :
76091: LD_VAR 0 8
76095: PUSH
76096: LD_INT 1
76098: DOUBLE
76099: EQUAL
76100: IFTRUE 76104
76102: GO 76184
76104: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76105: LD_ADDR_VAR 0 12
76109: PUSH
76110: LD_VAR 0 18
76114: PPUSH
76115: LD_INT 22
76117: PUSH
76118: LD_VAR 0 16
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 58
76129: PUSH
76130: EMPTY
76131: LIST
76132: PUSH
76133: LD_INT 2
76135: PUSH
76136: LD_INT 30
76138: PUSH
76139: LD_INT 32
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 30
76148: PUSH
76149: LD_INT 4
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 30
76158: PUSH
76159: LD_INT 5
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: LIST
76170: LIST
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: LIST
76176: PPUSH
76177: CALL_OW 72
76181: ST_TO_ADDR
76182: GO 76406
76184: LD_INT 2
76186: DOUBLE
76187: EQUAL
76188: IFTRUE 76192
76190: GO 76254
76192: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76193: LD_ADDR_VAR 0 12
76197: PUSH
76198: LD_VAR 0 18
76202: PPUSH
76203: LD_INT 22
76205: PUSH
76206: LD_VAR 0 16
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 2
76217: PUSH
76218: LD_INT 30
76220: PUSH
76221: LD_INT 0
76223: PUSH
76224: EMPTY
76225: LIST
76226: LIST
76227: PUSH
76228: LD_INT 30
76230: PUSH
76231: LD_INT 1
76233: PUSH
76234: EMPTY
76235: LIST
76236: LIST
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: LIST
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PPUSH
76247: CALL_OW 72
76251: ST_TO_ADDR
76252: GO 76406
76254: LD_INT 3
76256: DOUBLE
76257: EQUAL
76258: IFTRUE 76262
76260: GO 76324
76262: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76263: LD_ADDR_VAR 0 12
76267: PUSH
76268: LD_VAR 0 18
76272: PPUSH
76273: LD_INT 22
76275: PUSH
76276: LD_VAR 0 16
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 2
76287: PUSH
76288: LD_INT 30
76290: PUSH
76291: LD_INT 2
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 30
76300: PUSH
76301: LD_INT 3
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: LIST
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PPUSH
76317: CALL_OW 72
76321: ST_TO_ADDR
76322: GO 76406
76324: LD_INT 4
76326: DOUBLE
76327: EQUAL
76328: IFTRUE 76332
76330: GO 76405
76332: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76333: LD_ADDR_VAR 0 12
76337: PUSH
76338: LD_VAR 0 18
76342: PPUSH
76343: LD_INT 22
76345: PUSH
76346: LD_VAR 0 16
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PUSH
76355: LD_INT 2
76357: PUSH
76358: LD_INT 30
76360: PUSH
76361: LD_INT 6
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 30
76370: PUSH
76371: LD_INT 7
76373: PUSH
76374: EMPTY
76375: LIST
76376: LIST
76377: PUSH
76378: LD_INT 30
76380: PUSH
76381: LD_INT 8
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: LIST
76392: LIST
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: PPUSH
76398: CALL_OW 72
76402: ST_TO_ADDR
76403: GO 76406
76405: POP
// if i = 1 then
76406: LD_VAR 0 8
76410: PUSH
76411: LD_INT 1
76413: EQUAL
76414: IFFALSE 76525
// begin tmp := [ ] ;
76416: LD_ADDR_VAR 0 19
76420: PUSH
76421: EMPTY
76422: ST_TO_ADDR
// for j in f do
76423: LD_ADDR_VAR 0 9
76427: PUSH
76428: LD_VAR 0 12
76432: PUSH
76433: FOR_IN
76434: IFFALSE 76507
// if GetBType ( j ) = b_bunker then
76436: LD_VAR 0 9
76440: PPUSH
76441: CALL_OW 266
76445: PUSH
76446: LD_INT 32
76448: EQUAL
76449: IFFALSE 76476
// tmp := Insert ( tmp , 1 , j ) else
76451: LD_ADDR_VAR 0 19
76455: PUSH
76456: LD_VAR 0 19
76460: PPUSH
76461: LD_INT 1
76463: PPUSH
76464: LD_VAR 0 9
76468: PPUSH
76469: CALL_OW 2
76473: ST_TO_ADDR
76474: GO 76505
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76476: LD_ADDR_VAR 0 19
76480: PUSH
76481: LD_VAR 0 19
76485: PPUSH
76486: LD_VAR 0 19
76490: PUSH
76491: LD_INT 1
76493: PLUS
76494: PPUSH
76495: LD_VAR 0 9
76499: PPUSH
76500: CALL_OW 2
76504: ST_TO_ADDR
76505: GO 76433
76507: POP
76508: POP
// if tmp then
76509: LD_VAR 0 19
76513: IFFALSE 76525
// f := tmp ;
76515: LD_ADDR_VAR 0 12
76519: PUSH
76520: LD_VAR 0 19
76524: ST_TO_ADDR
// end ; x := personel [ i ] ;
76525: LD_ADDR_VAR 0 13
76529: PUSH
76530: LD_VAR 0 6
76534: PUSH
76535: LD_VAR 0 8
76539: ARRAY
76540: ST_TO_ADDR
// if x = - 1 then
76541: LD_VAR 0 13
76545: PUSH
76546: LD_INT 1
76548: NEG
76549: EQUAL
76550: IFFALSE 76759
// begin for j in f do
76552: LD_ADDR_VAR 0 9
76556: PUSH
76557: LD_VAR 0 12
76561: PUSH
76562: FOR_IN
76563: IFFALSE 76755
// repeat InitHc ;
76565: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76569: LD_VAR 0 9
76573: PPUSH
76574: CALL_OW 266
76578: PUSH
76579: LD_INT 5
76581: EQUAL
76582: IFFALSE 76652
// begin if UnitsInside ( j ) < 3 then
76584: LD_VAR 0 9
76588: PPUSH
76589: CALL_OW 313
76593: PUSH
76594: LD_INT 3
76596: LESS
76597: IFFALSE 76633
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76599: LD_INT 0
76601: PPUSH
76602: LD_INT 5
76604: PUSH
76605: LD_INT 8
76607: PUSH
76608: LD_INT 9
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: LIST
76615: PUSH
76616: LD_VAR 0 17
76620: ARRAY
76621: PPUSH
76622: LD_VAR 0 4
76626: PPUSH
76627: CALL_OW 380
76631: GO 76650
// PrepareHuman ( false , i , skill ) ;
76633: LD_INT 0
76635: PPUSH
76636: LD_VAR 0 8
76640: PPUSH
76641: LD_VAR 0 4
76645: PPUSH
76646: CALL_OW 380
// end else
76650: GO 76669
// PrepareHuman ( false , i , skill ) ;
76652: LD_INT 0
76654: PPUSH
76655: LD_VAR 0 8
76659: PPUSH
76660: LD_VAR 0 4
76664: PPUSH
76665: CALL_OW 380
// un := CreateHuman ;
76669: LD_ADDR_VAR 0 14
76673: PUSH
76674: CALL_OW 44
76678: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76679: LD_ADDR_VAR 0 7
76683: PUSH
76684: LD_VAR 0 7
76688: PPUSH
76689: LD_INT 1
76691: PPUSH
76692: LD_VAR 0 14
76696: PPUSH
76697: CALL_OW 2
76701: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76702: LD_VAR 0 14
76706: PPUSH
76707: LD_VAR 0 9
76711: PPUSH
76712: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76716: LD_VAR 0 9
76720: PPUSH
76721: CALL_OW 313
76725: PUSH
76726: LD_INT 6
76728: EQUAL
76729: PUSH
76730: LD_VAR 0 9
76734: PPUSH
76735: CALL_OW 266
76739: PUSH
76740: LD_INT 32
76742: PUSH
76743: LD_INT 31
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: IN
76750: OR
76751: IFFALSE 76565
76753: GO 76562
76755: POP
76756: POP
// end else
76757: GO 77139
// for j = 1 to x do
76759: LD_ADDR_VAR 0 9
76763: PUSH
76764: DOUBLE
76765: LD_INT 1
76767: DEC
76768: ST_TO_ADDR
76769: LD_VAR 0 13
76773: PUSH
76774: FOR_TO
76775: IFFALSE 77137
// begin InitHc ;
76777: CALL_OW 19
// if not f then
76781: LD_VAR 0 12
76785: NOT
76786: IFFALSE 76875
// begin PrepareHuman ( false , i , skill ) ;
76788: LD_INT 0
76790: PPUSH
76791: LD_VAR 0 8
76795: PPUSH
76796: LD_VAR 0 4
76800: PPUSH
76801: CALL_OW 380
// un := CreateHuman ;
76805: LD_ADDR_VAR 0 14
76809: PUSH
76810: CALL_OW 44
76814: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76815: LD_ADDR_VAR 0 7
76819: PUSH
76820: LD_VAR 0 7
76824: PPUSH
76825: LD_INT 1
76827: PPUSH
76828: LD_VAR 0 14
76832: PPUSH
76833: CALL_OW 2
76837: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76838: LD_VAR 0 14
76842: PPUSH
76843: LD_VAR 0 1
76847: PPUSH
76848: CALL_OW 250
76852: PPUSH
76853: LD_VAR 0 1
76857: PPUSH
76858: CALL_OW 251
76862: PPUSH
76863: LD_INT 10
76865: PPUSH
76866: LD_INT 0
76868: PPUSH
76869: CALL_OW 50
// continue ;
76873: GO 76774
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76875: LD_VAR 0 12
76879: PUSH
76880: LD_INT 1
76882: ARRAY
76883: PPUSH
76884: CALL_OW 313
76888: PUSH
76889: LD_VAR 0 12
76893: PUSH
76894: LD_INT 1
76896: ARRAY
76897: PPUSH
76898: CALL_OW 266
76902: PUSH
76903: LD_INT 32
76905: PUSH
76906: LD_INT 31
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: IN
76913: AND
76914: PUSH
76915: LD_VAR 0 12
76919: PUSH
76920: LD_INT 1
76922: ARRAY
76923: PPUSH
76924: CALL_OW 313
76928: PUSH
76929: LD_INT 6
76931: EQUAL
76932: OR
76933: IFFALSE 76953
// f := Delete ( f , 1 ) ;
76935: LD_ADDR_VAR 0 12
76939: PUSH
76940: LD_VAR 0 12
76944: PPUSH
76945: LD_INT 1
76947: PPUSH
76948: CALL_OW 3
76952: ST_TO_ADDR
// if not f then
76953: LD_VAR 0 12
76957: NOT
76958: IFFALSE 76976
// begin x := x + 2 ;
76960: LD_ADDR_VAR 0 13
76964: PUSH
76965: LD_VAR 0 13
76969: PUSH
76970: LD_INT 2
76972: PLUS
76973: ST_TO_ADDR
// continue ;
76974: GO 76774
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76976: LD_VAR 0 12
76980: PUSH
76981: LD_INT 1
76983: ARRAY
76984: PPUSH
76985: CALL_OW 266
76989: PUSH
76990: LD_INT 5
76992: EQUAL
76993: IFFALSE 77067
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76995: LD_VAR 0 12
76999: PUSH
77000: LD_INT 1
77002: ARRAY
77003: PPUSH
77004: CALL_OW 313
77008: PUSH
77009: LD_INT 3
77011: LESS
77012: IFFALSE 77048
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77014: LD_INT 0
77016: PPUSH
77017: LD_INT 5
77019: PUSH
77020: LD_INT 8
77022: PUSH
77023: LD_INT 9
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: LIST
77030: PUSH
77031: LD_VAR 0 17
77035: ARRAY
77036: PPUSH
77037: LD_VAR 0 4
77041: PPUSH
77042: CALL_OW 380
77046: GO 77065
// PrepareHuman ( false , i , skill ) ;
77048: LD_INT 0
77050: PPUSH
77051: LD_VAR 0 8
77055: PPUSH
77056: LD_VAR 0 4
77060: PPUSH
77061: CALL_OW 380
// end else
77065: GO 77084
// PrepareHuman ( false , i , skill ) ;
77067: LD_INT 0
77069: PPUSH
77070: LD_VAR 0 8
77074: PPUSH
77075: LD_VAR 0 4
77079: PPUSH
77080: CALL_OW 380
// un := CreateHuman ;
77084: LD_ADDR_VAR 0 14
77088: PUSH
77089: CALL_OW 44
77093: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77094: LD_ADDR_VAR 0 7
77098: PUSH
77099: LD_VAR 0 7
77103: PPUSH
77104: LD_INT 1
77106: PPUSH
77107: LD_VAR 0 14
77111: PPUSH
77112: CALL_OW 2
77116: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77117: LD_VAR 0 14
77121: PPUSH
77122: LD_VAR 0 12
77126: PUSH
77127: LD_INT 1
77129: ARRAY
77130: PPUSH
77131: CALL_OW 52
// end ;
77135: GO 76774
77137: POP
77138: POP
// end ;
77139: GO 76076
77141: POP
77142: POP
// result := result ^ buildings ;
77143: LD_ADDR_VAR 0 7
77147: PUSH
77148: LD_VAR 0 7
77152: PUSH
77153: LD_VAR 0 18
77157: ADD
77158: ST_TO_ADDR
// end else
77159: GO 77302
// begin for i = 1 to personel do
77161: LD_ADDR_VAR 0 8
77165: PUSH
77166: DOUBLE
77167: LD_INT 1
77169: DEC
77170: ST_TO_ADDR
77171: LD_VAR 0 6
77175: PUSH
77176: FOR_TO
77177: IFFALSE 77300
// begin if i > 4 then
77179: LD_VAR 0 8
77183: PUSH
77184: LD_INT 4
77186: GREATER
77187: IFFALSE 77191
// break ;
77189: GO 77300
// x := personel [ i ] ;
77191: LD_ADDR_VAR 0 13
77195: PUSH
77196: LD_VAR 0 6
77200: PUSH
77201: LD_VAR 0 8
77205: ARRAY
77206: ST_TO_ADDR
// if x = - 1 then
77207: LD_VAR 0 13
77211: PUSH
77212: LD_INT 1
77214: NEG
77215: EQUAL
77216: IFFALSE 77220
// continue ;
77218: GO 77176
// PrepareHuman ( false , i , skill ) ;
77220: LD_INT 0
77222: PPUSH
77223: LD_VAR 0 8
77227: PPUSH
77228: LD_VAR 0 4
77232: PPUSH
77233: CALL_OW 380
// un := CreateHuman ;
77237: LD_ADDR_VAR 0 14
77241: PUSH
77242: CALL_OW 44
77246: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77247: LD_VAR 0 14
77251: PPUSH
77252: LD_VAR 0 1
77256: PPUSH
77257: CALL_OW 250
77261: PPUSH
77262: LD_VAR 0 1
77266: PPUSH
77267: CALL_OW 251
77271: PPUSH
77272: LD_INT 10
77274: PPUSH
77275: LD_INT 0
77277: PPUSH
77278: CALL_OW 50
// result := result ^ un ;
77282: LD_ADDR_VAR 0 7
77286: PUSH
77287: LD_VAR 0 7
77291: PUSH
77292: LD_VAR 0 14
77296: ADD
77297: ST_TO_ADDR
// end ;
77298: GO 77176
77300: POP
77301: POP
// end ; end ;
77302: LD_VAR 0 7
77306: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77307: LD_INT 0
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
// result := false ;
77325: LD_ADDR_VAR 0 3
77329: PUSH
77330: LD_INT 0
77332: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77333: LD_VAR 0 1
77337: NOT
77338: PUSH
77339: LD_VAR 0 1
77343: PPUSH
77344: CALL_OW 266
77348: PUSH
77349: LD_INT 32
77351: PUSH
77352: LD_INT 33
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: IN
77359: NOT
77360: OR
77361: IFFALSE 77365
// exit ;
77363: GO 78501
// nat := GetNation ( tower ) ;
77365: LD_ADDR_VAR 0 12
77369: PUSH
77370: LD_VAR 0 1
77374: PPUSH
77375: CALL_OW 248
77379: ST_TO_ADDR
// side := GetSide ( tower ) ;
77380: LD_ADDR_VAR 0 16
77384: PUSH
77385: LD_VAR 0 1
77389: PPUSH
77390: CALL_OW 255
77394: ST_TO_ADDR
// x := GetX ( tower ) ;
77395: LD_ADDR_VAR 0 10
77399: PUSH
77400: LD_VAR 0 1
77404: PPUSH
77405: CALL_OW 250
77409: ST_TO_ADDR
// y := GetY ( tower ) ;
77410: LD_ADDR_VAR 0 11
77414: PUSH
77415: LD_VAR 0 1
77419: PPUSH
77420: CALL_OW 251
77424: ST_TO_ADDR
// if not x or not y then
77425: LD_VAR 0 10
77429: NOT
77430: PUSH
77431: LD_VAR 0 11
77435: NOT
77436: OR
77437: IFFALSE 77441
// exit ;
77439: GO 78501
// weapon := 0 ;
77441: LD_ADDR_VAR 0 18
77445: PUSH
77446: LD_INT 0
77448: ST_TO_ADDR
// fac_list := [ ] ;
77449: LD_ADDR_VAR 0 17
77453: PUSH
77454: EMPTY
77455: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77456: LD_ADDR_VAR 0 6
77460: PUSH
77461: LD_VAR 0 1
77465: PPUSH
77466: CALL_OW 274
77470: PPUSH
77471: LD_VAR 0 2
77475: PPUSH
77476: CALL 75079 0 2
77480: PPUSH
77481: LD_INT 30
77483: PUSH
77484: LD_INT 3
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PPUSH
77491: CALL_OW 72
77495: ST_TO_ADDR
// if not factories then
77496: LD_VAR 0 6
77500: NOT
77501: IFFALSE 77505
// exit ;
77503: GO 78501
// for i in factories do
77505: LD_ADDR_VAR 0 8
77509: PUSH
77510: LD_VAR 0 6
77514: PUSH
77515: FOR_IN
77516: IFFALSE 77541
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77518: LD_ADDR_VAR 0 17
77522: PUSH
77523: LD_VAR 0 17
77527: PUSH
77528: LD_VAR 0 8
77532: PPUSH
77533: CALL_OW 478
77537: UNION
77538: ST_TO_ADDR
77539: GO 77515
77541: POP
77542: POP
// if not fac_list then
77543: LD_VAR 0 17
77547: NOT
77548: IFFALSE 77552
// exit ;
77550: GO 78501
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77552: LD_ADDR_VAR 0 5
77556: PUSH
77557: LD_INT 4
77559: PUSH
77560: LD_INT 5
77562: PUSH
77563: LD_INT 9
77565: PUSH
77566: LD_INT 10
77568: PUSH
77569: LD_INT 6
77571: PUSH
77572: LD_INT 7
77574: PUSH
77575: LD_INT 11
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 27
77589: PUSH
77590: LD_INT 28
77592: PUSH
77593: LD_INT 26
77595: PUSH
77596: LD_INT 30
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 43
77607: PUSH
77608: LD_INT 44
77610: PUSH
77611: LD_INT 46
77613: PUSH
77614: LD_INT 45
77616: PUSH
77617: LD_INT 47
77619: PUSH
77620: LD_INT 49
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: LIST
77635: PUSH
77636: LD_VAR 0 12
77640: ARRAY
77641: ST_TO_ADDR
// for i in list do
77642: LD_ADDR_VAR 0 8
77646: PUSH
77647: LD_VAR 0 5
77651: PUSH
77652: FOR_IN
77653: IFFALSE 77686
// if not i in fac_list then
77655: LD_VAR 0 8
77659: PUSH
77660: LD_VAR 0 17
77664: IN
77665: NOT
77666: IFFALSE 77684
// list := list diff i ;
77668: LD_ADDR_VAR 0 5
77672: PUSH
77673: LD_VAR 0 5
77677: PUSH
77678: LD_VAR 0 8
77682: DIFF
77683: ST_TO_ADDR
77684: GO 77652
77686: POP
77687: POP
// if not list then
77688: LD_VAR 0 5
77692: NOT
77693: IFFALSE 77697
// exit ;
77695: GO 78501
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77697: LD_VAR 0 12
77701: PUSH
77702: LD_INT 3
77704: EQUAL
77705: PUSH
77706: LD_INT 49
77708: PUSH
77709: LD_VAR 0 5
77713: IN
77714: AND
77715: PUSH
77716: LD_INT 31
77718: PPUSH
77719: LD_VAR 0 16
77723: PPUSH
77724: CALL_OW 321
77728: PUSH
77729: LD_INT 2
77731: EQUAL
77732: AND
77733: IFFALSE 77793
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77735: LD_INT 22
77737: PUSH
77738: LD_VAR 0 16
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 35
77749: PUSH
77750: LD_INT 49
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 91
77759: PUSH
77760: LD_VAR 0 1
77764: PUSH
77765: LD_INT 10
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: LIST
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: LIST
77777: PPUSH
77778: CALL_OW 69
77782: NOT
77783: IFFALSE 77793
// weapon := ru_time_lapser ;
77785: LD_ADDR_VAR 0 18
77789: PUSH
77790: LD_INT 49
77792: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77793: LD_VAR 0 12
77797: PUSH
77798: LD_INT 1
77800: PUSH
77801: LD_INT 2
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: IN
77808: PUSH
77809: LD_INT 11
77811: PUSH
77812: LD_VAR 0 5
77816: IN
77817: PUSH
77818: LD_INT 30
77820: PUSH
77821: LD_VAR 0 5
77825: IN
77826: OR
77827: AND
77828: PUSH
77829: LD_INT 6
77831: PPUSH
77832: LD_VAR 0 16
77836: PPUSH
77837: CALL_OW 321
77841: PUSH
77842: LD_INT 2
77844: EQUAL
77845: AND
77846: IFFALSE 78011
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77848: LD_INT 22
77850: PUSH
77851: LD_VAR 0 16
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 2
77862: PUSH
77863: LD_INT 35
77865: PUSH
77866: LD_INT 11
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 35
77875: PUSH
77876: LD_INT 30
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: LIST
77887: PUSH
77888: LD_INT 91
77890: PUSH
77891: LD_VAR 0 1
77895: PUSH
77896: LD_INT 18
77898: PUSH
77899: EMPTY
77900: LIST
77901: LIST
77902: LIST
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: LIST
77908: PPUSH
77909: CALL_OW 69
77913: NOT
77914: PUSH
77915: LD_INT 22
77917: PUSH
77918: LD_VAR 0 16
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 2
77929: PUSH
77930: LD_INT 30
77932: PUSH
77933: LD_INT 32
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 30
77942: PUSH
77943: LD_INT 33
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: LIST
77954: PUSH
77955: LD_INT 91
77957: PUSH
77958: LD_VAR 0 1
77962: PUSH
77963: LD_INT 12
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: LIST
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: LIST
77975: PUSH
77976: EMPTY
77977: LIST
77978: PPUSH
77979: CALL_OW 69
77983: PUSH
77984: LD_INT 2
77986: GREATER
77987: AND
77988: IFFALSE 78011
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77990: LD_ADDR_VAR 0 18
77994: PUSH
77995: LD_INT 11
77997: PUSH
77998: LD_INT 30
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_VAR 0 12
78009: ARRAY
78010: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78011: LD_VAR 0 18
78015: NOT
78016: PUSH
78017: LD_INT 40
78019: PPUSH
78020: LD_VAR 0 16
78024: PPUSH
78025: CALL_OW 321
78029: PUSH
78030: LD_INT 2
78032: EQUAL
78033: AND
78034: PUSH
78035: LD_INT 7
78037: PUSH
78038: LD_VAR 0 5
78042: IN
78043: PUSH
78044: LD_INT 28
78046: PUSH
78047: LD_VAR 0 5
78051: IN
78052: OR
78053: PUSH
78054: LD_INT 45
78056: PUSH
78057: LD_VAR 0 5
78061: IN
78062: OR
78063: AND
78064: IFFALSE 78318
// begin hex := GetHexInfo ( x , y ) ;
78066: LD_ADDR_VAR 0 4
78070: PUSH
78071: LD_VAR 0 10
78075: PPUSH
78076: LD_VAR 0 11
78080: PPUSH
78081: CALL_OW 546
78085: ST_TO_ADDR
// if hex [ 1 ] then
78086: LD_VAR 0 4
78090: PUSH
78091: LD_INT 1
78093: ARRAY
78094: IFFALSE 78098
// exit ;
78096: GO 78501
// height := hex [ 2 ] ;
78098: LD_ADDR_VAR 0 15
78102: PUSH
78103: LD_VAR 0 4
78107: PUSH
78108: LD_INT 2
78110: ARRAY
78111: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78112: LD_ADDR_VAR 0 14
78116: PUSH
78117: LD_INT 0
78119: PUSH
78120: LD_INT 2
78122: PUSH
78123: LD_INT 3
78125: PUSH
78126: LD_INT 5
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: ST_TO_ADDR
// for i in tmp do
78135: LD_ADDR_VAR 0 8
78139: PUSH
78140: LD_VAR 0 14
78144: PUSH
78145: FOR_IN
78146: IFFALSE 78316
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78148: LD_ADDR_VAR 0 9
78152: PUSH
78153: LD_VAR 0 10
78157: PPUSH
78158: LD_VAR 0 8
78162: PPUSH
78163: LD_INT 5
78165: PPUSH
78166: CALL_OW 272
78170: PUSH
78171: LD_VAR 0 11
78175: PPUSH
78176: LD_VAR 0 8
78180: PPUSH
78181: LD_INT 5
78183: PPUSH
78184: CALL_OW 273
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78193: LD_VAR 0 9
78197: PUSH
78198: LD_INT 1
78200: ARRAY
78201: PPUSH
78202: LD_VAR 0 9
78206: PUSH
78207: LD_INT 2
78209: ARRAY
78210: PPUSH
78211: CALL_OW 488
78215: IFFALSE 78314
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78217: LD_ADDR_VAR 0 4
78221: PUSH
78222: LD_VAR 0 9
78226: PUSH
78227: LD_INT 1
78229: ARRAY
78230: PPUSH
78231: LD_VAR 0 9
78235: PUSH
78236: LD_INT 2
78238: ARRAY
78239: PPUSH
78240: CALL_OW 546
78244: ST_TO_ADDR
// if hex [ 1 ] then
78245: LD_VAR 0 4
78249: PUSH
78250: LD_INT 1
78252: ARRAY
78253: IFFALSE 78257
// continue ;
78255: GO 78145
// h := hex [ 2 ] ;
78257: LD_ADDR_VAR 0 13
78261: PUSH
78262: LD_VAR 0 4
78266: PUSH
78267: LD_INT 2
78269: ARRAY
78270: ST_TO_ADDR
// if h + 7 < height then
78271: LD_VAR 0 13
78275: PUSH
78276: LD_INT 7
78278: PLUS
78279: PUSH
78280: LD_VAR 0 15
78284: LESS
78285: IFFALSE 78314
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78287: LD_ADDR_VAR 0 18
78291: PUSH
78292: LD_INT 7
78294: PUSH
78295: LD_INT 28
78297: PUSH
78298: LD_INT 45
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: LIST
78305: PUSH
78306: LD_VAR 0 12
78310: ARRAY
78311: ST_TO_ADDR
// break ;
78312: GO 78316
// end ; end ; end ;
78314: GO 78145
78316: POP
78317: POP
// end ; if not weapon then
78318: LD_VAR 0 18
78322: NOT
78323: IFFALSE 78383
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78325: LD_ADDR_VAR 0 5
78329: PUSH
78330: LD_VAR 0 5
78334: PUSH
78335: LD_INT 11
78337: PUSH
78338: LD_INT 30
78340: PUSH
78341: LD_INT 49
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: LIST
78348: DIFF
78349: ST_TO_ADDR
// if not list then
78350: LD_VAR 0 5
78354: NOT
78355: IFFALSE 78359
// exit ;
78357: GO 78501
// weapon := list [ rand ( 1 , list ) ] ;
78359: LD_ADDR_VAR 0 18
78363: PUSH
78364: LD_VAR 0 5
78368: PUSH
78369: LD_INT 1
78371: PPUSH
78372: LD_VAR 0 5
78376: PPUSH
78377: CALL_OW 12
78381: ARRAY
78382: ST_TO_ADDR
// end ; if weapon then
78383: LD_VAR 0 18
78387: IFFALSE 78501
// begin tmp := CostOfWeapon ( weapon ) ;
78389: LD_ADDR_VAR 0 14
78393: PUSH
78394: LD_VAR 0 18
78398: PPUSH
78399: CALL_OW 451
78403: ST_TO_ADDR
// j := GetBase ( tower ) ;
78404: LD_ADDR_VAR 0 9
78408: PUSH
78409: LD_VAR 0 1
78413: PPUSH
78414: CALL_OW 274
78418: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78419: LD_VAR 0 9
78423: PPUSH
78424: LD_INT 1
78426: PPUSH
78427: CALL_OW 275
78431: PUSH
78432: LD_VAR 0 14
78436: PUSH
78437: LD_INT 1
78439: ARRAY
78440: GREATEREQUAL
78441: PUSH
78442: LD_VAR 0 9
78446: PPUSH
78447: LD_INT 2
78449: PPUSH
78450: CALL_OW 275
78454: PUSH
78455: LD_VAR 0 14
78459: PUSH
78460: LD_INT 2
78462: ARRAY
78463: GREATEREQUAL
78464: AND
78465: PUSH
78466: LD_VAR 0 9
78470: PPUSH
78471: LD_INT 3
78473: PPUSH
78474: CALL_OW 275
78478: PUSH
78479: LD_VAR 0 14
78483: PUSH
78484: LD_INT 3
78486: ARRAY
78487: GREATEREQUAL
78488: AND
78489: IFFALSE 78501
// result := weapon ;
78491: LD_ADDR_VAR 0 3
78495: PUSH
78496: LD_VAR 0 18
78500: ST_TO_ADDR
// end ; end ;
78501: LD_VAR 0 3
78505: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78506: LD_INT 0
78508: PPUSH
78509: PPUSH
// result := true ;
78510: LD_ADDR_VAR 0 3
78514: PUSH
78515: LD_INT 1
78517: ST_TO_ADDR
// if array1 = array2 then
78518: LD_VAR 0 1
78522: PUSH
78523: LD_VAR 0 2
78527: EQUAL
78528: IFFALSE 78588
// begin for i = 1 to array1 do
78530: LD_ADDR_VAR 0 4
78534: PUSH
78535: DOUBLE
78536: LD_INT 1
78538: DEC
78539: ST_TO_ADDR
78540: LD_VAR 0 1
78544: PUSH
78545: FOR_TO
78546: IFFALSE 78584
// if array1 [ i ] <> array2 [ i ] then
78548: LD_VAR 0 1
78552: PUSH
78553: LD_VAR 0 4
78557: ARRAY
78558: PUSH
78559: LD_VAR 0 2
78563: PUSH
78564: LD_VAR 0 4
78568: ARRAY
78569: NONEQUAL
78570: IFFALSE 78582
// begin result := false ;
78572: LD_ADDR_VAR 0 3
78576: PUSH
78577: LD_INT 0
78579: ST_TO_ADDR
// break ;
78580: GO 78584
// end ;
78582: GO 78545
78584: POP
78585: POP
// end else
78586: GO 78596
// result := false ;
78588: LD_ADDR_VAR 0 3
78592: PUSH
78593: LD_INT 0
78595: ST_TO_ADDR
// end ;
78596: LD_VAR 0 3
78600: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
78605: PPUSH
// pom := GetBase ( fac ) ;
78606: LD_ADDR_VAR 0 5
78610: PUSH
78611: LD_VAR 0 1
78615: PPUSH
78616: CALL_OW 274
78620: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78621: LD_ADDR_VAR 0 4
78625: PUSH
78626: LD_VAR 0 2
78630: PUSH
78631: LD_INT 1
78633: ARRAY
78634: PPUSH
78635: LD_VAR 0 2
78639: PUSH
78640: LD_INT 2
78642: ARRAY
78643: PPUSH
78644: LD_VAR 0 2
78648: PUSH
78649: LD_INT 3
78651: ARRAY
78652: PPUSH
78653: LD_VAR 0 2
78657: PUSH
78658: LD_INT 4
78660: ARRAY
78661: PPUSH
78662: CALL_OW 449
78666: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78667: LD_ADDR_VAR 0 3
78671: PUSH
78672: LD_VAR 0 5
78676: PPUSH
78677: LD_INT 1
78679: PPUSH
78680: CALL_OW 275
78684: PUSH
78685: LD_VAR 0 4
78689: PUSH
78690: LD_INT 1
78692: ARRAY
78693: GREATEREQUAL
78694: PUSH
78695: LD_VAR 0 5
78699: PPUSH
78700: LD_INT 2
78702: PPUSH
78703: CALL_OW 275
78707: PUSH
78708: LD_VAR 0 4
78712: PUSH
78713: LD_INT 2
78715: ARRAY
78716: GREATEREQUAL
78717: AND
78718: PUSH
78719: LD_VAR 0 5
78723: PPUSH
78724: LD_INT 3
78726: PPUSH
78727: CALL_OW 275
78731: PUSH
78732: LD_VAR 0 4
78736: PUSH
78737: LD_INT 3
78739: ARRAY
78740: GREATEREQUAL
78741: AND
78742: ST_TO_ADDR
// end ;
78743: LD_VAR 0 3
78747: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78748: LD_INT 0
78750: PPUSH
78751: PPUSH
78752: PPUSH
78753: PPUSH
// pom := GetBase ( building ) ;
78754: LD_ADDR_VAR 0 3
78758: PUSH
78759: LD_VAR 0 1
78763: PPUSH
78764: CALL_OW 274
78768: ST_TO_ADDR
// if not pom then
78769: LD_VAR 0 3
78773: NOT
78774: IFFALSE 78778
// exit ;
78776: GO 78948
// btype := GetBType ( building ) ;
78778: LD_ADDR_VAR 0 5
78782: PUSH
78783: LD_VAR 0 1
78787: PPUSH
78788: CALL_OW 266
78792: ST_TO_ADDR
// if btype = b_armoury then
78793: LD_VAR 0 5
78797: PUSH
78798: LD_INT 4
78800: EQUAL
78801: IFFALSE 78811
// btype := b_barracks ;
78803: LD_ADDR_VAR 0 5
78807: PUSH
78808: LD_INT 5
78810: ST_TO_ADDR
// if btype = b_depot then
78811: LD_VAR 0 5
78815: PUSH
78816: LD_INT 0
78818: EQUAL
78819: IFFALSE 78829
// btype := b_warehouse ;
78821: LD_ADDR_VAR 0 5
78825: PUSH
78826: LD_INT 1
78828: ST_TO_ADDR
// if btype = b_workshop then
78829: LD_VAR 0 5
78833: PUSH
78834: LD_INT 2
78836: EQUAL
78837: IFFALSE 78847
// btype := b_factory ;
78839: LD_ADDR_VAR 0 5
78843: PUSH
78844: LD_INT 3
78846: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78847: LD_ADDR_VAR 0 4
78851: PUSH
78852: LD_VAR 0 5
78856: PPUSH
78857: LD_VAR 0 1
78861: PPUSH
78862: CALL_OW 248
78866: PPUSH
78867: CALL_OW 450
78871: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78872: LD_ADDR_VAR 0 2
78876: PUSH
78877: LD_VAR 0 3
78881: PPUSH
78882: LD_INT 1
78884: PPUSH
78885: CALL_OW 275
78889: PUSH
78890: LD_VAR 0 4
78894: PUSH
78895: LD_INT 1
78897: ARRAY
78898: GREATEREQUAL
78899: PUSH
78900: LD_VAR 0 3
78904: PPUSH
78905: LD_INT 2
78907: PPUSH
78908: CALL_OW 275
78912: PUSH
78913: LD_VAR 0 4
78917: PUSH
78918: LD_INT 2
78920: ARRAY
78921: GREATEREQUAL
78922: AND
78923: PUSH
78924: LD_VAR 0 3
78928: PPUSH
78929: LD_INT 3
78931: PPUSH
78932: CALL_OW 275
78936: PUSH
78937: LD_VAR 0 4
78941: PUSH
78942: LD_INT 3
78944: ARRAY
78945: GREATEREQUAL
78946: AND
78947: ST_TO_ADDR
// end ;
78948: LD_VAR 0 2
78952: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78953: LD_INT 0
78955: PPUSH
78956: PPUSH
78957: PPUSH
// pom := GetBase ( building ) ;
78958: LD_ADDR_VAR 0 4
78962: PUSH
78963: LD_VAR 0 1
78967: PPUSH
78968: CALL_OW 274
78972: ST_TO_ADDR
// if not pom then
78973: LD_VAR 0 4
78977: NOT
78978: IFFALSE 78982
// exit ;
78980: GO 79083
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78982: LD_ADDR_VAR 0 5
78986: PUSH
78987: LD_VAR 0 2
78991: PPUSH
78992: LD_VAR 0 1
78996: PPUSH
78997: CALL_OW 248
79001: PPUSH
79002: CALL_OW 450
79006: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79007: LD_ADDR_VAR 0 3
79011: PUSH
79012: LD_VAR 0 4
79016: PPUSH
79017: LD_INT 1
79019: PPUSH
79020: CALL_OW 275
79024: PUSH
79025: LD_VAR 0 5
79029: PUSH
79030: LD_INT 1
79032: ARRAY
79033: GREATEREQUAL
79034: PUSH
79035: LD_VAR 0 4
79039: PPUSH
79040: LD_INT 2
79042: PPUSH
79043: CALL_OW 275
79047: PUSH
79048: LD_VAR 0 5
79052: PUSH
79053: LD_INT 2
79055: ARRAY
79056: GREATEREQUAL
79057: AND
79058: PUSH
79059: LD_VAR 0 4
79063: PPUSH
79064: LD_INT 3
79066: PPUSH
79067: CALL_OW 275
79071: PUSH
79072: LD_VAR 0 5
79076: PUSH
79077: LD_INT 3
79079: ARRAY
79080: GREATEREQUAL
79081: AND
79082: ST_TO_ADDR
// end ;
79083: LD_VAR 0 3
79087: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
79088: LD_INT 0
79090: PPUSH
79091: PPUSH
79092: PPUSH
79093: PPUSH
79094: PPUSH
79095: PPUSH
79096: PPUSH
79097: PPUSH
79098: PPUSH
79099: PPUSH
// result := false ;
79100: LD_ADDR_VAR 0 6
79104: PUSH
79105: LD_INT 0
79107: ST_TO_ADDR
// if not base or not btype or not x or not y then
79108: LD_VAR 0 1
79112: NOT
79113: PUSH
79114: LD_VAR 0 2
79118: NOT
79119: OR
79120: PUSH
79121: LD_VAR 0 3
79125: NOT
79126: OR
79127: PUSH
79128: LD_VAR 0 4
79132: NOT
79133: OR
79134: IFFALSE 79138
// exit ;
79136: GO 79747
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
79138: LD_ADDR_VAR 0 12
79142: PUSH
79143: LD_VAR 0 2
79147: PPUSH
79148: LD_VAR 0 3
79152: PPUSH
79153: LD_VAR 0 4
79157: PPUSH
79158: LD_VAR 0 5
79162: PPUSH
79163: LD_VAR 0 1
79167: PUSH
79168: LD_INT 1
79170: ARRAY
79171: PPUSH
79172: CALL_OW 248
79176: PPUSH
79177: LD_INT 0
79179: PPUSH
79180: CALL 80584 0 6
79184: ST_TO_ADDR
// if not hexes then
79185: LD_VAR 0 12
79189: NOT
79190: IFFALSE 79194
// exit ;
79192: GO 79747
// for i = 1 to hexes do
79194: LD_ADDR_VAR 0 7
79198: PUSH
79199: DOUBLE
79200: LD_INT 1
79202: DEC
79203: ST_TO_ADDR
79204: LD_VAR 0 12
79208: PUSH
79209: FOR_TO
79210: IFFALSE 79745
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79212: LD_ADDR_VAR 0 11
79216: PUSH
79217: LD_VAR 0 12
79221: PUSH
79222: LD_VAR 0 7
79226: ARRAY
79227: PUSH
79228: LD_INT 1
79230: ARRAY
79231: PPUSH
79232: LD_VAR 0 12
79236: PUSH
79237: LD_VAR 0 7
79241: ARRAY
79242: PUSH
79243: LD_INT 2
79245: ARRAY
79246: PPUSH
79247: CALL_OW 428
79251: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79252: LD_VAR 0 12
79256: PUSH
79257: LD_VAR 0 7
79261: ARRAY
79262: PUSH
79263: LD_INT 1
79265: ARRAY
79266: PPUSH
79267: LD_VAR 0 12
79271: PUSH
79272: LD_VAR 0 7
79276: ARRAY
79277: PUSH
79278: LD_INT 2
79280: ARRAY
79281: PPUSH
79282: CALL_OW 351
79286: PUSH
79287: LD_VAR 0 12
79291: PUSH
79292: LD_VAR 0 7
79296: ARRAY
79297: PUSH
79298: LD_INT 1
79300: ARRAY
79301: PPUSH
79302: LD_VAR 0 12
79306: PUSH
79307: LD_VAR 0 7
79311: ARRAY
79312: PUSH
79313: LD_INT 2
79315: ARRAY
79316: PPUSH
79317: CALL_OW 488
79321: NOT
79322: OR
79323: PUSH
79324: LD_VAR 0 11
79328: PPUSH
79329: CALL_OW 247
79333: PUSH
79334: LD_INT 3
79336: EQUAL
79337: OR
79338: IFFALSE 79344
// exit ;
79340: POP
79341: POP
79342: GO 79747
// if not tmp or not tmp in base then
79344: LD_VAR 0 11
79348: NOT
79349: PUSH
79350: LD_VAR 0 11
79354: PUSH
79355: LD_VAR 0 1
79359: IN
79360: NOT
79361: OR
79362: IFFALSE 79366
// continue ;
79364: GO 79209
// result := true ;
79366: LD_ADDR_VAR 0 6
79370: PUSH
79371: LD_INT 1
79373: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79374: LD_ADDR_VAR 0 15
79378: PUSH
79379: LD_VAR 0 1
79383: PPUSH
79384: LD_INT 22
79386: PUSH
79387: LD_VAR 0 11
79391: PPUSH
79392: CALL_OW 255
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: PUSH
79401: LD_INT 2
79403: PUSH
79404: LD_INT 30
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 30
79416: PUSH
79417: LD_INT 1
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: LIST
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PPUSH
79433: CALL_OW 72
79437: ST_TO_ADDR
// if dep then
79438: LD_VAR 0 15
79442: IFFALSE 79578
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79444: LD_ADDR_VAR 0 14
79448: PUSH
79449: LD_VAR 0 15
79453: PUSH
79454: LD_INT 1
79456: ARRAY
79457: PPUSH
79458: CALL_OW 250
79462: PPUSH
79463: LD_VAR 0 15
79467: PUSH
79468: LD_INT 1
79470: ARRAY
79471: PPUSH
79472: CALL_OW 254
79476: PPUSH
79477: LD_INT 5
79479: PPUSH
79480: CALL_OW 272
79484: PUSH
79485: LD_VAR 0 15
79489: PUSH
79490: LD_INT 1
79492: ARRAY
79493: PPUSH
79494: CALL_OW 251
79498: PPUSH
79499: LD_VAR 0 15
79503: PUSH
79504: LD_INT 1
79506: ARRAY
79507: PPUSH
79508: CALL_OW 254
79512: PPUSH
79513: LD_INT 5
79515: PPUSH
79516: CALL_OW 273
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79525: LD_VAR 0 14
79529: PUSH
79530: LD_INT 1
79532: ARRAY
79533: PPUSH
79534: LD_VAR 0 14
79538: PUSH
79539: LD_INT 2
79541: ARRAY
79542: PPUSH
79543: CALL_OW 488
79547: IFFALSE 79578
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79549: LD_VAR 0 11
79553: PPUSH
79554: LD_VAR 0 14
79558: PUSH
79559: LD_INT 1
79561: ARRAY
79562: PPUSH
79563: LD_VAR 0 14
79567: PUSH
79568: LD_INT 2
79570: ARRAY
79571: PPUSH
79572: CALL_OW 111
// continue ;
79576: GO 79209
// end ; end ; r := GetDir ( tmp ) ;
79578: LD_ADDR_VAR 0 13
79582: PUSH
79583: LD_VAR 0 11
79587: PPUSH
79588: CALL_OW 254
79592: ST_TO_ADDR
// if r = 5 then
79593: LD_VAR 0 13
79597: PUSH
79598: LD_INT 5
79600: EQUAL
79601: IFFALSE 79611
// r := 0 ;
79603: LD_ADDR_VAR 0 13
79607: PUSH
79608: LD_INT 0
79610: ST_TO_ADDR
// for j = r to 5 do
79611: LD_ADDR_VAR 0 8
79615: PUSH
79616: DOUBLE
79617: LD_VAR 0 13
79621: DEC
79622: ST_TO_ADDR
79623: LD_INT 5
79625: PUSH
79626: FOR_TO
79627: IFFALSE 79741
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79629: LD_ADDR_VAR 0 9
79633: PUSH
79634: LD_VAR 0 11
79638: PPUSH
79639: CALL_OW 250
79643: PPUSH
79644: LD_VAR 0 8
79648: PPUSH
79649: LD_INT 2
79651: PPUSH
79652: CALL_OW 272
79656: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79657: LD_ADDR_VAR 0 10
79661: PUSH
79662: LD_VAR 0 11
79666: PPUSH
79667: CALL_OW 251
79671: PPUSH
79672: LD_VAR 0 8
79676: PPUSH
79677: LD_INT 2
79679: PPUSH
79680: CALL_OW 273
79684: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79685: LD_VAR 0 9
79689: PPUSH
79690: LD_VAR 0 10
79694: PPUSH
79695: CALL_OW 488
79699: PUSH
79700: LD_VAR 0 9
79704: PPUSH
79705: LD_VAR 0 10
79709: PPUSH
79710: CALL_OW 428
79714: NOT
79715: AND
79716: IFFALSE 79739
// begin ComMoveXY ( tmp , _x , _y ) ;
79718: LD_VAR 0 11
79722: PPUSH
79723: LD_VAR 0 9
79727: PPUSH
79728: LD_VAR 0 10
79732: PPUSH
79733: CALL_OW 111
// break ;
79737: GO 79741
// end ; end ;
79739: GO 79626
79741: POP
79742: POP
// end ;
79743: GO 79209
79745: POP
79746: POP
// end ;
79747: LD_VAR 0 6
79751: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79752: LD_INT 0
79754: PPUSH
79755: PPUSH
79756: PPUSH
79757: PPUSH
79758: PPUSH
79759: PPUSH
79760: PPUSH
79761: PPUSH
79762: PPUSH
79763: PPUSH
// result := false ;
79764: LD_ADDR_VAR 0 6
79768: PUSH
79769: LD_INT 0
79771: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79772: LD_VAR 0 1
79776: NOT
79777: PUSH
79778: LD_VAR 0 1
79782: PPUSH
79783: CALL_OW 266
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: LD_INT 1
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: IN
79798: NOT
79799: OR
79800: PUSH
79801: LD_VAR 0 2
79805: NOT
79806: OR
79807: PUSH
79808: LD_VAR 0 5
79812: PUSH
79813: LD_INT 0
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: LD_INT 3
79824: PUSH
79825: LD_INT 4
79827: PUSH
79828: LD_INT 5
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: IN
79839: NOT
79840: OR
79841: PUSH
79842: LD_VAR 0 3
79846: PPUSH
79847: LD_VAR 0 4
79851: PPUSH
79852: CALL_OW 488
79856: NOT
79857: OR
79858: IFFALSE 79862
// exit ;
79860: GO 80579
// pom := GetBase ( depot ) ;
79862: LD_ADDR_VAR 0 10
79866: PUSH
79867: LD_VAR 0 1
79871: PPUSH
79872: CALL_OW 274
79876: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79877: LD_ADDR_VAR 0 11
79881: PUSH
79882: LD_VAR 0 2
79886: PPUSH
79887: LD_VAR 0 1
79891: PPUSH
79892: CALL_OW 248
79896: PPUSH
79897: CALL_OW 450
79901: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79902: LD_VAR 0 10
79906: PPUSH
79907: LD_INT 1
79909: PPUSH
79910: CALL_OW 275
79914: PUSH
79915: LD_VAR 0 11
79919: PUSH
79920: LD_INT 1
79922: ARRAY
79923: GREATEREQUAL
79924: PUSH
79925: LD_VAR 0 10
79929: PPUSH
79930: LD_INT 2
79932: PPUSH
79933: CALL_OW 275
79937: PUSH
79938: LD_VAR 0 11
79942: PUSH
79943: LD_INT 2
79945: ARRAY
79946: GREATEREQUAL
79947: AND
79948: PUSH
79949: LD_VAR 0 10
79953: PPUSH
79954: LD_INT 3
79956: PPUSH
79957: CALL_OW 275
79961: PUSH
79962: LD_VAR 0 11
79966: PUSH
79967: LD_INT 3
79969: ARRAY
79970: GREATEREQUAL
79971: AND
79972: NOT
79973: IFFALSE 79977
// exit ;
79975: GO 80579
// if GetBType ( depot ) = b_depot then
79977: LD_VAR 0 1
79981: PPUSH
79982: CALL_OW 266
79986: PUSH
79987: LD_INT 0
79989: EQUAL
79990: IFFALSE 80002
// dist := 28 else
79992: LD_ADDR_VAR 0 14
79996: PUSH
79997: LD_INT 28
79999: ST_TO_ADDR
80000: GO 80010
// dist := 36 ;
80002: LD_ADDR_VAR 0 14
80006: PUSH
80007: LD_INT 36
80009: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80010: LD_VAR 0 1
80014: PPUSH
80015: LD_VAR 0 3
80019: PPUSH
80020: LD_VAR 0 4
80024: PPUSH
80025: CALL_OW 297
80029: PUSH
80030: LD_VAR 0 14
80034: GREATER
80035: IFFALSE 80039
// exit ;
80037: GO 80579
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80039: LD_ADDR_VAR 0 12
80043: PUSH
80044: LD_VAR 0 2
80048: PPUSH
80049: LD_VAR 0 3
80053: PPUSH
80054: LD_VAR 0 4
80058: PPUSH
80059: LD_VAR 0 5
80063: PPUSH
80064: LD_VAR 0 1
80068: PPUSH
80069: CALL_OW 248
80073: PPUSH
80074: LD_INT 0
80076: PPUSH
80077: CALL 80584 0 6
80081: ST_TO_ADDR
// if not hexes then
80082: LD_VAR 0 12
80086: NOT
80087: IFFALSE 80091
// exit ;
80089: GO 80579
// hex := GetHexInfo ( x , y ) ;
80091: LD_ADDR_VAR 0 15
80095: PUSH
80096: LD_VAR 0 3
80100: PPUSH
80101: LD_VAR 0 4
80105: PPUSH
80106: CALL_OW 546
80110: ST_TO_ADDR
// if hex [ 1 ] then
80111: LD_VAR 0 15
80115: PUSH
80116: LD_INT 1
80118: ARRAY
80119: IFFALSE 80123
// exit ;
80121: GO 80579
// height := hex [ 2 ] ;
80123: LD_ADDR_VAR 0 13
80127: PUSH
80128: LD_VAR 0 15
80132: PUSH
80133: LD_INT 2
80135: ARRAY
80136: ST_TO_ADDR
// for i = 1 to hexes do
80137: LD_ADDR_VAR 0 7
80141: PUSH
80142: DOUBLE
80143: LD_INT 1
80145: DEC
80146: ST_TO_ADDR
80147: LD_VAR 0 12
80151: PUSH
80152: FOR_TO
80153: IFFALSE 80483
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80155: LD_VAR 0 12
80159: PUSH
80160: LD_VAR 0 7
80164: ARRAY
80165: PUSH
80166: LD_INT 1
80168: ARRAY
80169: PPUSH
80170: LD_VAR 0 12
80174: PUSH
80175: LD_VAR 0 7
80179: ARRAY
80180: PUSH
80181: LD_INT 2
80183: ARRAY
80184: PPUSH
80185: CALL_OW 488
80189: NOT
80190: PUSH
80191: LD_VAR 0 12
80195: PUSH
80196: LD_VAR 0 7
80200: ARRAY
80201: PUSH
80202: LD_INT 1
80204: ARRAY
80205: PPUSH
80206: LD_VAR 0 12
80210: PUSH
80211: LD_VAR 0 7
80215: ARRAY
80216: PUSH
80217: LD_INT 2
80219: ARRAY
80220: PPUSH
80221: CALL_OW 428
80225: PUSH
80226: LD_INT 0
80228: GREATER
80229: OR
80230: PUSH
80231: LD_VAR 0 12
80235: PUSH
80236: LD_VAR 0 7
80240: ARRAY
80241: PUSH
80242: LD_INT 1
80244: ARRAY
80245: PPUSH
80246: LD_VAR 0 12
80250: PUSH
80251: LD_VAR 0 7
80255: ARRAY
80256: PUSH
80257: LD_INT 2
80259: ARRAY
80260: PPUSH
80261: CALL_OW 351
80265: OR
80266: IFFALSE 80272
// exit ;
80268: POP
80269: POP
80270: GO 80579
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80272: LD_ADDR_VAR 0 8
80276: PUSH
80277: LD_VAR 0 12
80281: PUSH
80282: LD_VAR 0 7
80286: ARRAY
80287: PUSH
80288: LD_INT 1
80290: ARRAY
80291: PPUSH
80292: LD_VAR 0 12
80296: PUSH
80297: LD_VAR 0 7
80301: ARRAY
80302: PUSH
80303: LD_INT 2
80305: ARRAY
80306: PPUSH
80307: CALL_OW 546
80311: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
80312: LD_VAR 0 8
80316: PUSH
80317: LD_INT 1
80319: ARRAY
80320: PUSH
80321: LD_VAR 0 8
80325: PUSH
80326: LD_INT 2
80328: ARRAY
80329: PUSH
80330: LD_VAR 0 13
80334: PUSH
80335: LD_INT 2
80337: PLUS
80338: GREATER
80339: OR
80340: PUSH
80341: LD_VAR 0 8
80345: PUSH
80346: LD_INT 2
80348: ARRAY
80349: PUSH
80350: LD_VAR 0 13
80354: PUSH
80355: LD_INT 2
80357: MINUS
80358: LESS
80359: OR
80360: PUSH
80361: LD_VAR 0 8
80365: PUSH
80366: LD_INT 3
80368: ARRAY
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 8
80375: PUSH
80376: LD_INT 9
80378: PUSH
80379: LD_INT 10
80381: PUSH
80382: LD_INT 11
80384: PUSH
80385: LD_INT 12
80387: PUSH
80388: LD_INT 13
80390: PUSH
80391: LD_INT 16
80393: PUSH
80394: LD_INT 17
80396: PUSH
80397: LD_INT 18
80399: PUSH
80400: LD_INT 19
80402: PUSH
80403: LD_INT 20
80405: PUSH
80406: LD_INT 21
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: LIST
80420: LIST
80421: LIST
80422: LIST
80423: IN
80424: NOT
80425: OR
80426: PUSH
80427: LD_VAR 0 8
80431: PUSH
80432: LD_INT 5
80434: ARRAY
80435: NOT
80436: OR
80437: PUSH
80438: LD_VAR 0 8
80442: PUSH
80443: LD_INT 6
80445: ARRAY
80446: PUSH
80447: LD_INT 1
80449: PUSH
80450: LD_INT 2
80452: PUSH
80453: LD_INT 7
80455: PUSH
80456: LD_INT 9
80458: PUSH
80459: LD_INT 10
80461: PUSH
80462: LD_INT 11
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: IN
80473: NOT
80474: OR
80475: IFFALSE 80481
// exit ;
80477: POP
80478: POP
80479: GO 80579
// end ;
80481: GO 80152
80483: POP
80484: POP
// side := GetSide ( depot ) ;
80485: LD_ADDR_VAR 0 9
80489: PUSH
80490: LD_VAR 0 1
80494: PPUSH
80495: CALL_OW 255
80499: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80500: LD_VAR 0 9
80504: PPUSH
80505: LD_VAR 0 3
80509: PPUSH
80510: LD_VAR 0 4
80514: PPUSH
80515: LD_INT 20
80517: PPUSH
80518: CALL 73233 0 4
80522: PUSH
80523: LD_INT 4
80525: ARRAY
80526: IFFALSE 80530
// exit ;
80528: GO 80579
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80530: LD_VAR 0 2
80534: PUSH
80535: LD_INT 29
80537: PUSH
80538: LD_INT 30
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: IN
80545: PUSH
80546: LD_VAR 0 3
80550: PPUSH
80551: LD_VAR 0 4
80555: PPUSH
80556: LD_VAR 0 9
80560: PPUSH
80561: CALL_OW 440
80565: NOT
80566: AND
80567: IFFALSE 80571
// exit ;
80569: GO 80579
// result := true ;
80571: LD_ADDR_VAR 0 6
80575: PUSH
80576: LD_INT 1
80578: ST_TO_ADDR
// end ;
80579: LD_VAR 0 6
80583: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80584: LD_INT 0
80586: PPUSH
80587: PPUSH
80588: PPUSH
80589: PPUSH
80590: PPUSH
80591: PPUSH
80592: PPUSH
80593: PPUSH
80594: PPUSH
80595: PPUSH
80596: PPUSH
80597: PPUSH
80598: PPUSH
80599: PPUSH
80600: PPUSH
80601: PPUSH
80602: PPUSH
80603: PPUSH
80604: PPUSH
80605: PPUSH
80606: PPUSH
80607: PPUSH
80608: PPUSH
80609: PPUSH
80610: PPUSH
80611: PPUSH
80612: PPUSH
80613: PPUSH
80614: PPUSH
80615: PPUSH
80616: PPUSH
80617: PPUSH
80618: PPUSH
80619: PPUSH
80620: PPUSH
80621: PPUSH
80622: PPUSH
80623: PPUSH
80624: PPUSH
80625: PPUSH
80626: PPUSH
80627: PPUSH
80628: PPUSH
80629: PPUSH
80630: PPUSH
80631: PPUSH
80632: PPUSH
80633: PPUSH
80634: PPUSH
80635: PPUSH
80636: PPUSH
80637: PPUSH
80638: PPUSH
80639: PPUSH
80640: PPUSH
80641: PPUSH
80642: PPUSH
80643: PPUSH
// result = [ ] ;
80644: LD_ADDR_VAR 0 7
80648: PUSH
80649: EMPTY
80650: ST_TO_ADDR
// temp_list = [ ] ;
80651: LD_ADDR_VAR 0 9
80655: PUSH
80656: EMPTY
80657: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80658: LD_VAR 0 4
80662: PUSH
80663: LD_INT 0
80665: PUSH
80666: LD_INT 1
80668: PUSH
80669: LD_INT 2
80671: PUSH
80672: LD_INT 3
80674: PUSH
80675: LD_INT 4
80677: PUSH
80678: LD_INT 5
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: IN
80689: NOT
80690: PUSH
80691: LD_VAR 0 1
80695: PUSH
80696: LD_INT 0
80698: PUSH
80699: LD_INT 1
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: IN
80706: PUSH
80707: LD_VAR 0 5
80711: PUSH
80712: LD_INT 1
80714: PUSH
80715: LD_INT 2
80717: PUSH
80718: LD_INT 3
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: LIST
80725: IN
80726: NOT
80727: AND
80728: OR
80729: IFFALSE 80733
// exit ;
80731: GO 99124
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80733: LD_VAR 0 1
80737: PUSH
80738: LD_INT 6
80740: PUSH
80741: LD_INT 7
80743: PUSH
80744: LD_INT 8
80746: PUSH
80747: LD_INT 13
80749: PUSH
80750: LD_INT 12
80752: PUSH
80753: LD_INT 15
80755: PUSH
80756: LD_INT 11
80758: PUSH
80759: LD_INT 14
80761: PUSH
80762: LD_INT 10
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: IN
80776: IFFALSE 80786
// btype = b_lab ;
80778: LD_ADDR_VAR 0 1
80782: PUSH
80783: LD_INT 6
80785: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80786: LD_VAR 0 6
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: LD_INT 1
80796: PUSH
80797: LD_INT 2
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: LIST
80804: IN
80805: NOT
80806: PUSH
80807: LD_VAR 0 1
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: LD_INT 2
80820: PUSH
80821: LD_INT 3
80823: PUSH
80824: LD_INT 6
80826: PUSH
80827: LD_INT 36
80829: PUSH
80830: LD_INT 4
80832: PUSH
80833: LD_INT 5
80835: PUSH
80836: LD_INT 31
80838: PUSH
80839: LD_INT 32
80841: PUSH
80842: LD_INT 33
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: LIST
80849: LIST
80850: LIST
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: IN
80858: NOT
80859: PUSH
80860: LD_VAR 0 6
80864: PUSH
80865: LD_INT 1
80867: EQUAL
80868: AND
80869: OR
80870: PUSH
80871: LD_VAR 0 1
80875: PUSH
80876: LD_INT 2
80878: PUSH
80879: LD_INT 3
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: IN
80886: NOT
80887: PUSH
80888: LD_VAR 0 6
80892: PUSH
80893: LD_INT 2
80895: EQUAL
80896: AND
80897: OR
80898: IFFALSE 80908
// mode = 0 ;
80900: LD_ADDR_VAR 0 6
80904: PUSH
80905: LD_INT 0
80907: ST_TO_ADDR
// case mode of 0 :
80908: LD_VAR 0 6
80912: PUSH
80913: LD_INT 0
80915: DOUBLE
80916: EQUAL
80917: IFTRUE 80921
80919: GO 92374
80921: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80922: LD_ADDR_VAR 0 11
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: LD_INT 0
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: LD_INT 1
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 1
80950: PUSH
80951: LD_INT 0
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: LD_INT 1
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 0
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: NEG
80981: PUSH
80982: LD_INT 0
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: NEG
80992: PUSH
80993: LD_INT 1
80995: NEG
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PUSH
81001: LD_INT 1
81003: NEG
81004: PUSH
81005: LD_INT 2
81007: NEG
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 0
81015: PUSH
81016: LD_INT 2
81018: NEG
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 1
81026: PUSH
81027: LD_INT 1
81029: NEG
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 1
81037: PUSH
81038: LD_INT 2
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 1
81057: NEG
81058: PUSH
81059: LD_INT 1
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 1
81068: PUSH
81069: LD_INT 3
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 0
81078: PUSH
81079: LD_INT 3
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 1
81088: NEG
81089: PUSH
81090: LD_INT 2
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: LIST
81113: LIST
81114: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81115: LD_ADDR_VAR 0 12
81119: PUSH
81120: LD_INT 0
81122: PUSH
81123: LD_INT 0
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: PUSH
81130: LD_INT 0
81132: PUSH
81133: LD_INT 1
81135: NEG
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 1
81143: PUSH
81144: LD_INT 0
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 1
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 1
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: NEG
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 1
81184: NEG
81185: PUSH
81186: LD_INT 1
81188: NEG
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: PUSH
81194: LD_INT 1
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 2
81207: PUSH
81208: LD_INT 0
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 2
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: NEG
81228: PUSH
81229: LD_INT 1
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 2
81238: NEG
81239: PUSH
81240: LD_INT 0
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 2
81261: NEG
81262: PUSH
81263: LD_INT 1
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 3
81272: NEG
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 3
81283: NEG
81284: PUSH
81285: LD_INT 1
81287: NEG
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: LIST
81304: LIST
81305: LIST
81306: LIST
81307: LIST
81308: LIST
81309: LIST
81310: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81311: LD_ADDR_VAR 0 13
81315: PUSH
81316: LD_INT 0
81318: PUSH
81319: LD_INT 0
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 0
81328: PUSH
81329: LD_INT 1
81331: NEG
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: LD_INT 0
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 1
81349: PUSH
81350: LD_INT 1
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: LD_INT 0
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: NEG
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: NEG
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 1
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 2
81434: NEG
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 2
81446: NEG
81447: PUSH
81448: LD_INT 2
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 2
81458: NEG
81459: PUSH
81460: LD_INT 3
81462: NEG
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 3
81470: NEG
81471: PUSH
81472: LD_INT 2
81474: NEG
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 3
81482: NEG
81483: PUSH
81484: LD_INT 3
81486: NEG
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81510: LD_ADDR_VAR 0 14
81514: PUSH
81515: LD_INT 0
81517: PUSH
81518: LD_INT 0
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: LD_INT 1
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 1
81538: PUSH
81539: LD_INT 0
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 1
81548: PUSH
81549: LD_INT 1
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: LD_INT 1
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 1
81568: NEG
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 1
81579: NEG
81580: PUSH
81581: LD_INT 1
81583: NEG
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: LD_INT 1
81591: NEG
81592: PUSH
81593: LD_INT 2
81595: NEG
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 0
81603: PUSH
81604: LD_INT 2
81606: NEG
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 1
81614: PUSH
81615: LD_INT 1
81617: NEG
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: PUSH
81626: LD_INT 2
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 0
81635: PUSH
81636: LD_INT 2
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: LD_INT 1
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 1
81656: NEG
81657: PUSH
81658: LD_INT 3
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 0
81668: PUSH
81669: LD_INT 3
81671: NEG
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 1
81679: PUSH
81680: LD_INT 2
81682: NEG
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81706: LD_ADDR_VAR 0 15
81710: PUSH
81711: LD_INT 0
81713: PUSH
81714: LD_INT 0
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 0
81723: PUSH
81724: LD_INT 1
81726: NEG
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: LD_INT 0
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 1
81744: PUSH
81745: LD_INT 1
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 0
81754: PUSH
81755: LD_INT 1
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: PUSH
81762: LD_INT 1
81764: NEG
81765: PUSH
81766: LD_INT 0
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 1
81775: NEG
81776: PUSH
81777: LD_INT 1
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 2
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 2
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 1
81818: NEG
81819: PUSH
81820: LD_INT 1
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 2
81829: NEG
81830: PUSH
81831: LD_INT 0
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 2
81840: NEG
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 2
81852: PUSH
81853: LD_INT 1
81855: NEG
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 3
81863: PUSH
81864: LD_INT 0
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 3
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: LIST
81890: LIST
81891: LIST
81892: LIST
81893: LIST
81894: LIST
81895: LIST
81896: LIST
81897: LIST
81898: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81899: LD_ADDR_VAR 0 16
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 0
81916: PUSH
81917: LD_INT 1
81919: NEG
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 1
81927: PUSH
81928: LD_INT 0
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 1
81937: PUSH
81938: LD_INT 1
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 0
81947: PUSH
81948: LD_INT 1
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 1
81957: NEG
81958: PUSH
81959: LD_INT 0
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 1
81968: NEG
81969: PUSH
81970: LD_INT 1
81972: NEG
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: LD_INT 2
81984: NEG
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: LD_INT 2
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: LD_INT 2
82002: PUSH
82003: LD_INT 2
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 1
82012: PUSH
82013: LD_INT 2
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 2
82022: NEG
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 2
82034: NEG
82035: PUSH
82036: LD_INT 2
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 3
82046: PUSH
82047: LD_INT 2
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 3
82056: PUSH
82057: LD_INT 3
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 2
82066: PUSH
82067: LD_INT 3
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82092: LD_ADDR_VAR 0 17
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: LD_INT 0
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: LD_INT 1
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 1
82130: PUSH
82131: LD_INT 1
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 0
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 1
82150: NEG
82151: PUSH
82152: LD_INT 0
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 1
82161: NEG
82162: PUSH
82163: LD_INT 1
82165: NEG
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: LD_INT 2
82177: NEG
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: PUSH
82183: LD_INT 0
82185: PUSH
82186: LD_INT 2
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: PUSH
82197: LD_INT 1
82199: NEG
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 2
82207: PUSH
82208: LD_INT 0
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 2
82217: PUSH
82218: LD_INT 1
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 2
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 1
82237: PUSH
82238: LD_INT 2
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: LD_INT 1
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 2
82268: NEG
82269: PUSH
82270: LD_INT 0
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 2
82279: NEG
82280: PUSH
82281: LD_INT 1
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: NEG
82292: PUSH
82293: LD_INT 2
82295: NEG
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82322: LD_ADDR_VAR 0 18
82326: PUSH
82327: LD_INT 0
82329: PUSH
82330: LD_INT 0
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 1
82342: NEG
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 1
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 1
82360: PUSH
82361: LD_INT 1
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 0
82370: PUSH
82371: LD_INT 1
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 1
82380: NEG
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 1
82391: NEG
82392: PUSH
82393: LD_INT 1
82395: NEG
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 1
82403: NEG
82404: PUSH
82405: LD_INT 2
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 0
82415: PUSH
82416: LD_INT 2
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 1
82426: PUSH
82427: LD_INT 1
82429: NEG
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: LD_INT 0
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 2
82447: PUSH
82448: LD_INT 1
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 2
82457: PUSH
82458: LD_INT 2
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 1
82467: PUSH
82468: LD_INT 2
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: LD_INT 2
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: LD_INT 1
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 2
82498: NEG
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 2
82509: NEG
82510: PUSH
82511: LD_INT 1
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: NEG
82522: PUSH
82523: LD_INT 2
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82552: LD_ADDR_VAR 0 19
82556: PUSH
82557: LD_INT 0
82559: PUSH
82560: LD_INT 0
82562: PUSH
82563: EMPTY
82564: LIST
82565: LIST
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: LD_INT 1
82572: NEG
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: LD_INT 1
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 1
82590: PUSH
82591: LD_INT 1
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 0
82600: PUSH
82601: LD_INT 1
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: LD_INT 0
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: LD_INT 1
82625: NEG
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 1
82633: NEG
82634: PUSH
82635: LD_INT 2
82637: NEG
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 0
82645: PUSH
82646: LD_INT 2
82648: NEG
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 1
82656: PUSH
82657: LD_INT 1
82659: NEG
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 2
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 2
82677: PUSH
82678: LD_INT 1
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 2
82687: PUSH
82688: LD_INT 2
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 1
82697: PUSH
82698: LD_INT 2
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: LD_INT 2
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: NEG
82718: PUSH
82719: LD_INT 1
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 2
82728: NEG
82729: PUSH
82730: LD_INT 0
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: NEG
82740: PUSH
82741: LD_INT 1
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: NEG
82752: PUSH
82753: LD_INT 2
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82782: LD_ADDR_VAR 0 20
82786: PUSH
82787: LD_INT 0
82789: PUSH
82790: LD_INT 0
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 1
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 1
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 0
82830: PUSH
82831: LD_INT 1
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 1
82840: NEG
82841: PUSH
82842: LD_INT 0
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 1
82851: NEG
82852: PUSH
82853: LD_INT 1
82855: NEG
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: LD_INT 2
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 0
82875: PUSH
82876: LD_INT 2
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 1
82886: PUSH
82887: LD_INT 1
82889: NEG
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 2
82897: PUSH
82898: LD_INT 0
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 2
82907: PUSH
82908: LD_INT 1
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 2
82917: PUSH
82918: LD_INT 2
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 1
82927: PUSH
82928: LD_INT 2
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 0
82937: PUSH
82938: LD_INT 2
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 1
82947: NEG
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 2
82958: NEG
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: NEG
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 2
82981: NEG
82982: PUSH
82983: LD_INT 2
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: EMPTY
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83012: LD_ADDR_VAR 0 21
83016: PUSH
83017: LD_INT 0
83019: PUSH
83020: LD_INT 0
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 0
83029: PUSH
83030: LD_INT 1
83032: NEG
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 1
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: LD_INT 1
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PUSH
83058: LD_INT 0
83060: PUSH
83061: LD_INT 1
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 1
83070: NEG
83071: PUSH
83072: LD_INT 0
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 1
83081: NEG
83082: PUSH
83083: LD_INT 1
83085: NEG
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: LD_INT 2
83097: NEG
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 0
83105: PUSH
83106: LD_INT 2
83108: NEG
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PUSH
83114: LD_INT 1
83116: PUSH
83117: LD_INT 1
83119: NEG
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 2
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 2
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 2
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 1
83157: PUSH
83158: LD_INT 2
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: PUSH
83165: LD_INT 0
83167: PUSH
83168: LD_INT 2
83170: PUSH
83171: EMPTY
83172: LIST
83173: LIST
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: LD_INT 1
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 2
83188: NEG
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 2
83199: NEG
83200: PUSH
83201: LD_INT 1
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 2
83211: NEG
83212: PUSH
83213: LD_INT 2
83215: NEG
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83242: LD_ADDR_VAR 0 22
83246: PUSH
83247: LD_INT 0
83249: PUSH
83250: LD_INT 0
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: LD_INT 1
83262: NEG
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 1
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 0
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 1
83300: NEG
83301: PUSH
83302: LD_INT 0
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 1
83311: NEG
83312: PUSH
83313: LD_INT 1
83315: NEG
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 1
83323: NEG
83324: PUSH
83325: LD_INT 2
83327: NEG
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 0
83335: PUSH
83336: LD_INT 2
83338: NEG
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 1
83346: PUSH
83347: LD_INT 1
83349: NEG
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 2
83357: PUSH
83358: LD_INT 0
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: LD_INT 2
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 0
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: LD_INT 1
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 2
83418: NEG
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 2
83429: NEG
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: NEG
83442: PUSH
83443: LD_INT 2
83445: NEG
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: LIST
83462: LIST
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83472: LD_ADDR_VAR 0 23
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: LD_INT 1
83492: NEG
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 1
83500: PUSH
83501: LD_INT 0
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 1
83510: PUSH
83511: LD_INT 1
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: LD_INT 0
83520: PUSH
83521: LD_INT 1
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 1
83530: NEG
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 1
83541: NEG
83542: PUSH
83543: LD_INT 1
83545: NEG
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 1
83553: NEG
83554: PUSH
83555: LD_INT 2
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 0
83565: PUSH
83566: LD_INT 2
83568: NEG
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 1
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 2
83587: PUSH
83588: LD_INT 0
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 2
83597: PUSH
83598: LD_INT 1
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 2
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: PUSH
83618: LD_INT 2
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: LD_INT 0
83627: PUSH
83628: LD_INT 2
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 1
83637: NEG
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 2
83648: NEG
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: NEG
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 2
83671: NEG
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 2
83683: NEG
83684: PUSH
83685: LD_INT 3
83687: NEG
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 1
83695: NEG
83696: PUSH
83697: LD_INT 3
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 1
83707: PUSH
83708: LD_INT 2
83710: NEG
83711: PUSH
83712: EMPTY
83713: LIST
83714: LIST
83715: PUSH
83716: LD_INT 2
83718: PUSH
83719: LD_INT 1
83721: NEG
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: EMPTY
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83752: LD_ADDR_VAR 0 24
83756: PUSH
83757: LD_INT 0
83759: PUSH
83760: LD_INT 0
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 0
83769: PUSH
83770: LD_INT 1
83772: NEG
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: LD_INT 1
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 0
83800: PUSH
83801: LD_INT 1
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: PUSH
83808: LD_INT 1
83810: NEG
83811: PUSH
83812: LD_INT 0
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 1
83821: NEG
83822: PUSH
83823: LD_INT 1
83825: NEG
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 1
83833: NEG
83834: PUSH
83835: LD_INT 2
83837: NEG
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 0
83845: PUSH
83846: LD_INT 2
83848: NEG
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: PUSH
83854: LD_INT 1
83856: PUSH
83857: LD_INT 1
83859: NEG
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: PUSH
83865: LD_INT 2
83867: PUSH
83868: LD_INT 0
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 2
83877: PUSH
83878: LD_INT 1
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 2
83887: PUSH
83888: LD_INT 2
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 1
83897: PUSH
83898: LD_INT 2
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: LD_INT 2
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: LD_INT 1
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: LD_INT 0
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: LD_INT 2
83939: NEG
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: LD_INT 2
83955: NEG
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 1
83963: PUSH
83964: LD_INT 2
83966: NEG
83967: PUSH
83968: EMPTY
83969: LIST
83970: LIST
83971: PUSH
83972: LD_INT 2
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 3
83985: PUSH
83986: LD_INT 1
83988: PUSH
83989: EMPTY
83990: LIST
83991: LIST
83992: PUSH
83993: LD_INT 3
83995: PUSH
83996: LD_INT 2
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: LIST
84025: LIST
84026: LIST
84027: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84028: LD_ADDR_VAR 0 25
84032: PUSH
84033: LD_INT 0
84035: PUSH
84036: LD_INT 0
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 0
84045: PUSH
84046: LD_INT 1
84048: NEG
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 1
84056: PUSH
84057: LD_INT 0
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 1
84066: PUSH
84067: LD_INT 1
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 0
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: LD_INT 1
84086: NEG
84087: PUSH
84088: LD_INT 0
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: LD_INT 1
84101: NEG
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 1
84109: NEG
84110: PUSH
84111: LD_INT 2
84113: NEG
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 0
84121: PUSH
84122: LD_INT 2
84124: NEG
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: LD_INT 1
84132: PUSH
84133: LD_INT 1
84135: NEG
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PUSH
84141: LD_INT 2
84143: PUSH
84144: LD_INT 0
84146: PUSH
84147: EMPTY
84148: LIST
84149: LIST
84150: PUSH
84151: LD_INT 2
84153: PUSH
84154: LD_INT 1
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: LD_INT 2
84163: PUSH
84164: LD_INT 2
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: PUSH
84174: LD_INT 2
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 0
84183: PUSH
84184: LD_INT 2
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 1
84193: NEG
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 2
84204: NEG
84205: PUSH
84206: LD_INT 0
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 2
84215: NEG
84216: PUSH
84217: LD_INT 1
84219: NEG
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 2
84227: NEG
84228: PUSH
84229: LD_INT 2
84231: NEG
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: PUSH
84237: LD_INT 3
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 3
84249: PUSH
84250: LD_INT 2
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 2
84259: PUSH
84260: LD_INT 3
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 1
84269: PUSH
84270: LD_INT 3
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: LIST
84300: LIST
84301: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84302: LD_ADDR_VAR 0 26
84306: PUSH
84307: LD_INT 0
84309: PUSH
84310: LD_INT 0
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 0
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 1
84340: PUSH
84341: LD_INT 1
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 0
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: LD_INT 0
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: NEG
84372: PUSH
84373: LD_INT 1
84375: NEG
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PUSH
84381: LD_INT 1
84383: NEG
84384: PUSH
84385: LD_INT 2
84387: NEG
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 0
84395: PUSH
84396: LD_INT 2
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 1
84406: PUSH
84407: LD_INT 1
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 2
84417: PUSH
84418: LD_INT 0
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 2
84427: PUSH
84428: LD_INT 1
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 2
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 1
84447: PUSH
84448: LD_INT 2
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 0
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 2
84478: NEG
84479: PUSH
84480: LD_INT 0
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 2
84489: NEG
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: LD_INT 2
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 3
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 1
84523: PUSH
84524: LD_INT 3
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 1
84533: NEG
84534: PUSH
84535: LD_INT 2
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 2
84544: NEG
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: EMPTY
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84578: LD_ADDR_VAR 0 27
84582: PUSH
84583: LD_INT 0
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 0
84595: PUSH
84596: LD_INT 1
84598: NEG
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PUSH
84604: LD_INT 1
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 1
84616: PUSH
84617: LD_INT 1
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 0
84626: PUSH
84627: LD_INT 1
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 1
84636: NEG
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 1
84647: NEG
84648: PUSH
84649: LD_INT 1
84651: NEG
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 1
84659: NEG
84660: PUSH
84661: LD_INT 2
84663: NEG
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: LD_INT 2
84674: NEG
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 1
84682: PUSH
84683: LD_INT 1
84685: NEG
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 2
84693: PUSH
84694: LD_INT 0
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 2
84703: PUSH
84704: LD_INT 1
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 1
84723: PUSH
84724: LD_INT 2
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 0
84733: PUSH
84734: LD_INT 2
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 1
84743: NEG
84744: PUSH
84745: LD_INT 1
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 2
84754: NEG
84755: PUSH
84756: LD_INT 0
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 2
84765: NEG
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 2
84777: NEG
84778: PUSH
84779: LD_INT 2
84781: NEG
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: PUSH
84787: LD_INT 1
84789: NEG
84790: PUSH
84791: LD_INT 2
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 2
84800: NEG
84801: PUSH
84802: LD_INT 1
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 3
84811: NEG
84812: PUSH
84813: LD_INT 1
84815: NEG
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: PUSH
84821: LD_INT 3
84823: NEG
84824: PUSH
84825: LD_INT 2
84827: NEG
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: LIST
84849: LIST
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84858: LD_ADDR_VAR 0 28
84862: PUSH
84863: LD_INT 0
84865: PUSH
84866: LD_INT 0
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 0
84875: PUSH
84876: LD_INT 1
84878: NEG
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 1
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 0
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: LD_INT 0
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 1
84927: NEG
84928: PUSH
84929: LD_INT 1
84931: NEG
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 1
84939: NEG
84940: PUSH
84941: LD_INT 2
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 0
84951: PUSH
84952: LD_INT 2
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: PUSH
84963: LD_INT 1
84965: NEG
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 2
84973: PUSH
84974: LD_INT 0
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 2
84983: PUSH
84984: LD_INT 1
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: LD_INT 2
84993: PUSH
84994: LD_INT 2
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: LD_INT 2
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 0
85013: PUSH
85014: LD_INT 2
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: LD_INT 1
85027: PUSH
85028: EMPTY
85029: LIST
85030: LIST
85031: PUSH
85032: LD_INT 2
85034: NEG
85035: PUSH
85036: LD_INT 0
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 2
85045: NEG
85046: PUSH
85047: LD_INT 1
85049: NEG
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PUSH
85055: LD_INT 2
85057: NEG
85058: PUSH
85059: LD_INT 2
85061: NEG
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 2
85069: NEG
85070: PUSH
85071: LD_INT 3
85073: NEG
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 1
85081: NEG
85082: PUSH
85083: LD_INT 3
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 3
85093: NEG
85094: PUSH
85095: LD_INT 1
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 3
85105: NEG
85106: PUSH
85107: LD_INT 2
85109: NEG
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85140: LD_ADDR_VAR 0 29
85144: PUSH
85145: LD_INT 0
85147: PUSH
85148: LD_INT 0
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PUSH
85155: LD_INT 0
85157: PUSH
85158: LD_INT 1
85160: NEG
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 1
85168: PUSH
85169: LD_INT 0
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 0
85188: PUSH
85189: LD_INT 1
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: LD_INT 1
85198: NEG
85199: PUSH
85200: LD_INT 0
85202: PUSH
85203: EMPTY
85204: LIST
85205: LIST
85206: PUSH
85207: LD_INT 1
85209: NEG
85210: PUSH
85211: LD_INT 1
85213: NEG
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: LD_INT 2
85225: NEG
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: LD_INT 2
85236: NEG
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: LD_INT 1
85247: NEG
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: PUSH
85256: LD_INT 0
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 2
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: PUSH
85276: LD_INT 2
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: LD_INT 2
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 2
85306: NEG
85307: PUSH
85308: LD_INT 1
85310: NEG
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 2
85318: NEG
85319: PUSH
85320: LD_INT 2
85322: NEG
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 2
85330: NEG
85331: PUSH
85332: LD_INT 3
85334: NEG
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 2
85342: PUSH
85343: LD_INT 1
85345: NEG
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 3
85353: PUSH
85354: LD_INT 1
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 1
85363: PUSH
85364: LD_INT 3
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 1
85373: NEG
85374: PUSH
85375: LD_INT 2
85377: PUSH
85378: EMPTY
85379: LIST
85380: LIST
85381: PUSH
85382: LD_INT 3
85384: NEG
85385: PUSH
85386: LD_INT 2
85388: NEG
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: LIST
85404: LIST
85405: LIST
85406: LIST
85407: LIST
85408: LIST
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85419: LD_ADDR_VAR 0 30
85423: PUSH
85424: LD_INT 0
85426: PUSH
85427: LD_INT 0
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 0
85436: PUSH
85437: LD_INT 1
85439: NEG
85440: PUSH
85441: EMPTY
85442: LIST
85443: LIST
85444: PUSH
85445: LD_INT 1
85447: PUSH
85448: LD_INT 0
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 1
85457: PUSH
85458: LD_INT 1
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 0
85467: PUSH
85468: LD_INT 1
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 1
85477: NEG
85478: PUSH
85479: LD_INT 0
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: LD_INT 1
85492: NEG
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: LD_INT 1
85500: NEG
85501: PUSH
85502: LD_INT 2
85504: NEG
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 0
85512: PUSH
85513: LD_INT 2
85515: NEG
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: LD_INT 1
85526: NEG
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 2
85534: PUSH
85535: LD_INT 0
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 2
85554: PUSH
85555: LD_INT 2
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: LD_INT 2
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 1
85574: NEG
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 2
85585: NEG
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: NEG
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: LD_INT 3
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 1
85620: PUSH
85621: LD_INT 2
85623: NEG
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 3
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 2
85641: PUSH
85642: LD_INT 3
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 3
85662: NEG
85663: PUSH
85664: LD_INT 1
85666: NEG
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85697: LD_ADDR_VAR 0 31
85701: PUSH
85702: LD_INT 0
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 0
85714: PUSH
85715: LD_INT 1
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: LD_INT 1
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: LD_INT 0
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 1
85766: NEG
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 1
85778: NEG
85779: PUSH
85780: LD_INT 2
85782: NEG
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 1
85790: PUSH
85791: LD_INT 1
85793: NEG
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 2
85801: PUSH
85802: LD_INT 0
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 2
85811: PUSH
85812: LD_INT 1
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 2
85821: PUSH
85822: LD_INT 2
85824: PUSH
85825: EMPTY
85826: LIST
85827: LIST
85828: PUSH
85829: LD_INT 1
85831: PUSH
85832: LD_INT 2
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 0
85841: PUSH
85842: LD_INT 2
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 1
85851: NEG
85852: PUSH
85853: LD_INT 1
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 2
85862: NEG
85863: PUSH
85864: LD_INT 1
85866: NEG
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PUSH
85872: LD_INT 2
85874: NEG
85875: PUSH
85876: LD_INT 2
85878: NEG
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 2
85886: NEG
85887: PUSH
85888: LD_INT 3
85890: NEG
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 2
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 3
85909: PUSH
85910: LD_INT 1
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 1
85919: PUSH
85920: LD_INT 3
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 1
85929: NEG
85930: PUSH
85931: LD_INT 2
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 3
85940: NEG
85941: PUSH
85942: LD_INT 2
85944: NEG
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85975: LD_ADDR_VAR 0 32
85979: PUSH
85980: LD_INT 0
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 0
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 1
86003: PUSH
86004: LD_INT 0
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 0
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 1
86033: NEG
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 1
86044: NEG
86045: PUSH
86046: LD_INT 1
86048: NEG
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: NEG
86057: PUSH
86058: LD_INT 2
86060: NEG
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 0
86068: PUSH
86069: LD_INT 2
86071: NEG
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 1
86079: PUSH
86080: LD_INT 1
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: LD_INT 1
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: LD_INT 2
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: LD_INT 2
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 0
86120: PUSH
86121: LD_INT 2
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: LD_INT 1
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 2
86141: NEG
86142: PUSH
86143: LD_INT 0
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 2
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: LD_INT 3
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 1
86176: PUSH
86177: LD_INT 2
86179: NEG
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 3
86187: PUSH
86188: LD_INT 2
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 2
86197: PUSH
86198: LD_INT 3
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: PUSH
86205: LD_INT 2
86207: NEG
86208: PUSH
86209: LD_INT 1
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: LD_INT 3
86218: NEG
86219: PUSH
86220: LD_INT 1
86222: NEG
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86253: LD_ADDR_VAR 0 33
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 1
86273: NEG
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 1
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 1
86322: NEG
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: LD_INT 2
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 1
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 2
86357: PUSH
86358: LD_INT 0
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 2
86367: PUSH
86368: LD_INT 1
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: LD_INT 2
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 0
86387: PUSH
86388: LD_INT 2
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 1
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 2
86408: NEG
86409: PUSH
86410: LD_INT 0
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 2
86419: NEG
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 2
86431: NEG
86432: PUSH
86433: LD_INT 2
86435: NEG
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: LD_INT 2
86443: NEG
86444: PUSH
86445: LD_INT 3
86447: NEG
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 2
86455: PUSH
86456: LD_INT 1
86458: NEG
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 3
86466: PUSH
86467: LD_INT 1
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 1
86476: PUSH
86477: LD_INT 3
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: LD_INT 2
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 3
86497: NEG
86498: PUSH
86499: LD_INT 2
86501: NEG
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86532: LD_ADDR_VAR 0 34
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 0
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: LD_INT 1
86605: NEG
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 0
86625: PUSH
86626: LD_INT 2
86628: NEG
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: LD_INT 1
86639: NEG
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 2
86647: PUSH
86648: LD_INT 1
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: LD_INT 2
86657: PUSH
86658: LD_INT 2
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 1
86667: PUSH
86668: LD_INT 2
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: LD_INT 1
86677: NEG
86678: PUSH
86679: LD_INT 1
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 2
86688: NEG
86689: PUSH
86690: LD_INT 0
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 2
86699: NEG
86700: PUSH
86701: LD_INT 1
86703: NEG
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 2
86711: NEG
86712: PUSH
86713: LD_INT 2
86715: NEG
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 1
86723: NEG
86724: PUSH
86725: LD_INT 3
86727: NEG
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 1
86735: PUSH
86736: LD_INT 2
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 3
86746: PUSH
86747: LD_INT 2
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 2
86756: PUSH
86757: LD_INT 3
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 2
86766: NEG
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 3
86777: NEG
86778: PUSH
86779: LD_INT 1
86781: NEG
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: LIST
86810: LIST
86811: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86812: LD_ADDR_VAR 0 35
86816: PUSH
86817: LD_INT 0
86819: PUSH
86820: LD_INT 0
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 0
86829: PUSH
86830: LD_INT 1
86832: NEG
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 0
86860: PUSH
86861: LD_INT 1
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 1
86881: NEG
86882: PUSH
86883: LD_INT 1
86885: NEG
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 2
86893: PUSH
86894: LD_INT 1
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 2
86903: NEG
86904: PUSH
86905: LD_INT 1
86907: NEG
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86924: LD_ADDR_VAR 0 36
86928: PUSH
86929: LD_INT 0
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 0
86941: PUSH
86942: LD_INT 1
86944: NEG
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: LD_INT 0
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 1
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 0
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 1
86982: NEG
86983: PUSH
86984: LD_INT 0
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 1
86993: NEG
86994: PUSH
86995: LD_INT 1
86997: NEG
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 1
87005: NEG
87006: PUSH
87007: LD_INT 2
87009: NEG
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: LD_INT 1
87017: PUSH
87018: LD_INT 2
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87036: LD_ADDR_VAR 0 37
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: LD_INT 1
87056: NEG
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 1
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: LD_INT 1
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 0
87084: PUSH
87085: LD_INT 1
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: LD_INT 0
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: LD_INT 1
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: LD_INT 1
87120: NEG
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 1
87128: NEG
87129: PUSH
87130: LD_INT 1
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87148: LD_ADDR_VAR 0 38
87152: PUSH
87153: LD_INT 0
87155: PUSH
87156: LD_INT 0
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 0
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: PUSH
87177: LD_INT 0
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 1
87186: PUSH
87187: LD_INT 1
87189: PUSH
87190: EMPTY
87191: LIST
87192: LIST
87193: PUSH
87194: LD_INT 0
87196: PUSH
87197: LD_INT 1
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: NEG
87207: PUSH
87208: LD_INT 0
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 1
87217: NEG
87218: PUSH
87219: LD_INT 1
87221: NEG
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 2
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 2
87239: NEG
87240: PUSH
87241: LD_INT 1
87243: NEG
87244: PUSH
87245: EMPTY
87246: LIST
87247: LIST
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87260: LD_ADDR_VAR 0 39
87264: PUSH
87265: LD_INT 0
87267: PUSH
87268: LD_INT 0
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 0
87277: PUSH
87278: LD_INT 1
87280: NEG
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 1
87288: PUSH
87289: LD_INT 0
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: LD_INT 1
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 0
87308: PUSH
87309: LD_INT 1
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: NEG
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 1
87341: NEG
87342: PUSH
87343: LD_INT 2
87345: NEG
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 1
87353: PUSH
87354: LD_INT 2
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87372: LD_ADDR_VAR 0 40
87376: PUSH
87377: LD_INT 0
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 0
87389: PUSH
87390: LD_INT 1
87392: NEG
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_INT 1
87400: PUSH
87401: LD_INT 0
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: LD_INT 1
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: LD_INT 0
87420: PUSH
87421: LD_INT 1
87423: PUSH
87424: EMPTY
87425: LIST
87426: LIST
87427: PUSH
87428: LD_INT 1
87430: NEG
87431: PUSH
87432: LD_INT 0
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: PUSH
87443: LD_INT 1
87445: NEG
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 1
87453: PUSH
87454: LD_INT 1
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 1
87464: NEG
87465: PUSH
87466: LD_INT 1
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87484: LD_ADDR_VAR 0 41
87488: PUSH
87489: LD_INT 0
87491: PUSH
87492: LD_INT 0
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: LD_INT 1
87504: NEG
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: LD_INT 1
87512: PUSH
87513: LD_INT 0
87515: PUSH
87516: EMPTY
87517: LIST
87518: LIST
87519: PUSH
87520: LD_INT 1
87522: PUSH
87523: LD_INT 1
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: PUSH
87530: LD_INT 0
87532: PUSH
87533: LD_INT 1
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 1
87542: NEG
87543: PUSH
87544: LD_INT 0
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 1
87553: NEG
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: LD_INT 1
87565: NEG
87566: PUSH
87567: LD_INT 2
87569: NEG
87570: PUSH
87571: EMPTY
87572: LIST
87573: LIST
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: LD_INT 1
87580: NEG
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 2
87588: PUSH
87589: LD_INT 0
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: LD_INT 1
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: LD_INT 2
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 1
87618: PUSH
87619: LD_INT 2
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 1
87628: NEG
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 2
87639: NEG
87640: PUSH
87641: LD_INT 0
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PUSH
87648: LD_INT 2
87650: NEG
87651: PUSH
87652: LD_INT 1
87654: NEG
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 2
87662: NEG
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 2
87674: NEG
87675: PUSH
87676: LD_INT 3
87678: NEG
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 2
87686: PUSH
87687: LD_INT 1
87689: NEG
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 3
87697: PUSH
87698: LD_INT 0
87700: PUSH
87701: EMPTY
87702: LIST
87703: LIST
87704: PUSH
87705: LD_INT 3
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 3
87717: PUSH
87718: LD_INT 2
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 3
87727: PUSH
87728: LD_INT 3
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 2
87737: PUSH
87738: LD_INT 3
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 2
87747: NEG
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 3
87758: NEG
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 3
87769: NEG
87770: PUSH
87771: LD_INT 1
87773: NEG
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 3
87781: NEG
87782: PUSH
87783: LD_INT 2
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 3
87793: NEG
87794: PUSH
87795: LD_INT 3
87797: NEG
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87834: LD_ADDR_VAR 0 42
87838: PUSH
87839: LD_INT 0
87841: PUSH
87842: LD_INT 0
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: LD_INT 1
87854: NEG
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 1
87862: PUSH
87863: LD_INT 0
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: LD_INT 1
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: LD_INT 1
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: PUSH
87890: LD_INT 1
87892: NEG
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 1
87903: NEG
87904: PUSH
87905: LD_INT 1
87907: NEG
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 1
87915: NEG
87916: PUSH
87917: LD_INT 2
87919: NEG
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: LD_INT 2
87930: NEG
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: LD_INT 1
87941: NEG
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 2
87949: PUSH
87950: LD_INT 1
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 2
87959: PUSH
87960: LD_INT 2
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 1
87969: PUSH
87970: LD_INT 2
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 0
87979: PUSH
87980: LD_INT 2
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 1
87989: NEG
87990: PUSH
87991: LD_INT 1
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 2
88000: NEG
88001: PUSH
88002: LD_INT 1
88004: NEG
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 2
88012: NEG
88013: PUSH
88014: LD_INT 2
88016: NEG
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 2
88024: NEG
88025: PUSH
88026: LD_INT 3
88028: NEG
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: NEG
88037: PUSH
88038: LD_INT 3
88040: NEG
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 0
88048: PUSH
88049: LD_INT 3
88051: NEG
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 1
88059: PUSH
88060: LD_INT 2
88062: NEG
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 3
88070: PUSH
88071: LD_INT 2
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 3
88080: PUSH
88081: LD_INT 3
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: LD_INT 2
88090: PUSH
88091: LD_INT 3
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 1
88100: PUSH
88101: LD_INT 3
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 0
88110: PUSH
88111: LD_INT 3
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: LD_INT 1
88120: NEG
88121: PUSH
88122: LD_INT 2
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: PUSH
88129: LD_INT 3
88131: NEG
88132: PUSH
88133: LD_INT 2
88135: NEG
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 3
88143: NEG
88144: PUSH
88145: LD_INT 3
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88184: LD_ADDR_VAR 0 43
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: LD_INT 0
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 0
88201: PUSH
88202: LD_INT 1
88204: NEG
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 1
88212: PUSH
88213: LD_INT 0
88215: PUSH
88216: EMPTY
88217: LIST
88218: LIST
88219: PUSH
88220: LD_INT 1
88222: PUSH
88223: LD_INT 1
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: PUSH
88230: LD_INT 0
88232: PUSH
88233: LD_INT 1
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: NEG
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 1
88253: NEG
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 1
88265: NEG
88266: PUSH
88267: LD_INT 2
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 0
88277: PUSH
88278: LD_INT 2
88280: NEG
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 1
88288: PUSH
88289: LD_INT 1
88291: NEG
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: LD_INT 2
88299: PUSH
88300: LD_INT 0
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 2
88309: PUSH
88310: LD_INT 1
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 1
88319: PUSH
88320: LD_INT 2
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: LD_INT 2
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 1
88339: NEG
88340: PUSH
88341: LD_INT 1
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 2
88350: NEG
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 2
88361: NEG
88362: PUSH
88363: LD_INT 1
88365: NEG
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 1
88373: NEG
88374: PUSH
88375: LD_INT 3
88377: NEG
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 0
88385: PUSH
88386: LD_INT 3
88388: NEG
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 1
88396: PUSH
88397: LD_INT 2
88399: NEG
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 2
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 3
88418: PUSH
88419: LD_INT 0
88421: PUSH
88422: EMPTY
88423: LIST
88424: LIST
88425: PUSH
88426: LD_INT 3
88428: PUSH
88429: LD_INT 1
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 3
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: LD_INT 3
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 1
88458: NEG
88459: PUSH
88460: LD_INT 2
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 2
88469: NEG
88470: PUSH
88471: LD_INT 1
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 3
88480: NEG
88481: PUSH
88482: LD_INT 0
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 3
88491: NEG
88492: PUSH
88493: LD_INT 1
88495: NEG
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: LIST
88528: LIST
88529: LIST
88530: LIST
88531: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88532: LD_ADDR_VAR 0 44
88536: PUSH
88537: LD_INT 0
88539: PUSH
88540: LD_INT 0
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: LD_INT 0
88549: PUSH
88550: LD_INT 1
88552: NEG
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: PUSH
88561: LD_INT 0
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 1
88570: PUSH
88571: LD_INT 1
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: LD_INT 0
88580: PUSH
88581: LD_INT 1
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 1
88590: NEG
88591: PUSH
88592: LD_INT 0
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 1
88601: NEG
88602: PUSH
88603: LD_INT 1
88605: NEG
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 1
88613: NEG
88614: PUSH
88615: LD_INT 2
88617: NEG
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 2
88636: PUSH
88637: LD_INT 0
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: LD_INT 1
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 2
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 1
88666: PUSH
88667: LD_INT 2
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 1
88676: NEG
88677: PUSH
88678: LD_INT 1
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: LD_INT 2
88687: NEG
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 2
88698: NEG
88699: PUSH
88700: LD_INT 1
88702: NEG
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 2
88710: NEG
88711: PUSH
88712: LD_INT 2
88714: NEG
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 2
88722: NEG
88723: PUSH
88724: LD_INT 3
88726: NEG
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 2
88734: PUSH
88735: LD_INT 1
88737: NEG
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 3
88745: PUSH
88746: LD_INT 0
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 3
88755: PUSH
88756: LD_INT 1
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 3
88765: PUSH
88766: LD_INT 2
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 3
88775: PUSH
88776: LD_INT 3
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: PUSH
88786: LD_INT 3
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 2
88795: NEG
88796: PUSH
88797: LD_INT 1
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 3
88806: NEG
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 3
88817: NEG
88818: PUSH
88819: LD_INT 1
88821: NEG
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 3
88829: NEG
88830: PUSH
88831: LD_INT 2
88833: NEG
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 3
88841: NEG
88842: PUSH
88843: LD_INT 3
88845: NEG
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88882: LD_ADDR_VAR 0 45
88886: PUSH
88887: LD_INT 0
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: PUSH
88897: LD_INT 0
88899: PUSH
88900: LD_INT 1
88902: NEG
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 1
88910: PUSH
88911: LD_INT 0
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 1
88920: PUSH
88921: LD_INT 1
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: PUSH
88928: LD_INT 0
88930: PUSH
88931: LD_INT 1
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 1
88940: NEG
88941: PUSH
88942: LD_INT 0
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: PUSH
88949: LD_INT 1
88951: NEG
88952: PUSH
88953: LD_INT 1
88955: NEG
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 1
88963: NEG
88964: PUSH
88965: LD_INT 2
88967: NEG
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 0
88975: PUSH
88976: LD_INT 2
88978: NEG
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 1
88986: PUSH
88987: LD_INT 1
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 2
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: PUSH
89018: LD_INT 2
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: LD_INT 2
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: LD_INT 1
89037: NEG
89038: PUSH
89039: LD_INT 1
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 2
89048: NEG
89049: PUSH
89050: LD_INT 1
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 2
89060: NEG
89061: PUSH
89062: LD_INT 2
89064: NEG
89065: PUSH
89066: EMPTY
89067: LIST
89068: LIST
89069: PUSH
89070: LD_INT 2
89072: NEG
89073: PUSH
89074: LD_INT 3
89076: NEG
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 1
89084: NEG
89085: PUSH
89086: LD_INT 3
89088: NEG
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 0
89096: PUSH
89097: LD_INT 3
89099: NEG
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: PUSH
89108: LD_INT 2
89110: NEG
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 3
89118: PUSH
89119: LD_INT 2
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 3
89128: PUSH
89129: LD_INT 3
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 2
89138: PUSH
89139: LD_INT 3
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: LD_INT 3
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 0
89158: PUSH
89159: LD_INT 3
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 1
89168: NEG
89169: PUSH
89170: LD_INT 2
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 3
89179: NEG
89180: PUSH
89181: LD_INT 2
89183: NEG
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 3
89191: NEG
89192: PUSH
89193: LD_INT 3
89195: NEG
89196: PUSH
89197: EMPTY
89198: LIST
89199: LIST
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89232: LD_ADDR_VAR 0 46
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 0
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: LD_INT 1
89252: NEG
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 1
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: LD_INT 1
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: NEG
89302: PUSH
89303: LD_INT 1
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: NEG
89314: PUSH
89315: LD_INT 2
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 0
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 1
89336: PUSH
89337: LD_INT 1
89339: NEG
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: LD_INT 0
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 2
89357: PUSH
89358: LD_INT 1
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 1
89367: PUSH
89368: LD_INT 2
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 0
89377: PUSH
89378: LD_INT 2
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: PUSH
89385: LD_INT 1
89387: NEG
89388: PUSH
89389: LD_INT 1
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 2
89398: NEG
89399: PUSH
89400: LD_INT 0
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PUSH
89407: LD_INT 2
89409: NEG
89410: PUSH
89411: LD_INT 1
89413: NEG
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 1
89421: NEG
89422: PUSH
89423: LD_INT 3
89425: NEG
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 0
89433: PUSH
89434: LD_INT 3
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: LD_INT 1
89444: PUSH
89445: LD_INT 2
89447: NEG
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 2
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 3
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 3
89476: PUSH
89477: LD_INT 1
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: PUSH
89484: LD_INT 1
89486: PUSH
89487: LD_INT 3
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: LD_INT 3
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: LD_INT 1
89506: NEG
89507: PUSH
89508: LD_INT 2
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 2
89517: NEG
89518: PUSH
89519: LD_INT 1
89521: PUSH
89522: EMPTY
89523: LIST
89524: LIST
89525: PUSH
89526: LD_INT 3
89528: NEG
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: PUSH
89537: LD_INT 3
89539: NEG
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89580: LD_ADDR_VAR 0 47
89584: PUSH
89585: LD_INT 0
89587: PUSH
89588: LD_INT 0
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PUSH
89595: LD_INT 0
89597: PUSH
89598: LD_INT 1
89600: NEG
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: LD_INT 0
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 1
89618: PUSH
89619: LD_INT 1
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: LD_INT 1
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: LD_INT 1
89638: NEG
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 1
89649: NEG
89650: PUSH
89651: LD_INT 1
89653: NEG
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 1
89661: NEG
89662: PUSH
89663: LD_INT 2
89665: NEG
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 0
89673: PUSH
89674: LD_INT 2
89676: NEG
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 1
89684: PUSH
89685: LD_INT 1
89687: NEG
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 2
89695: NEG
89696: PUSH
89697: LD_INT 1
89699: NEG
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: LD_INT 2
89707: NEG
89708: PUSH
89709: LD_INT 2
89711: NEG
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89731: LD_ADDR_VAR 0 48
89735: PUSH
89736: LD_INT 0
89738: PUSH
89739: LD_INT 0
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: LD_INT 1
89751: NEG
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PUSH
89757: LD_INT 1
89759: PUSH
89760: LD_INT 0
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: LD_INT 1
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 0
89779: PUSH
89780: LD_INT 1
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: PUSH
89787: LD_INT 1
89789: NEG
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: LD_INT 1
89800: NEG
89801: PUSH
89802: LD_INT 1
89804: NEG
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 1
89812: NEG
89813: PUSH
89814: LD_INT 2
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: LD_INT 2
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 2
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89878: LD_ADDR_VAR 0 49
89882: PUSH
89883: LD_INT 0
89885: PUSH
89886: LD_INT 0
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 0
89895: PUSH
89896: LD_INT 1
89898: NEG
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 1
89906: PUSH
89907: LD_INT 0
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 1
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 0
89926: PUSH
89927: LD_INT 1
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: NEG
89937: PUSH
89938: LD_INT 0
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 1
89947: NEG
89948: PUSH
89949: LD_INT 1
89951: NEG
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: LD_INT 1
89962: NEG
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 2
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 2
89980: PUSH
89981: LD_INT 1
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 2
89990: PUSH
89991: LD_INT 2
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: LD_INT 1
90000: PUSH
90001: LD_INT 2
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90022: LD_ADDR_VAR 0 50
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 0
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: LD_INT 0
90039: PUSH
90040: LD_INT 1
90042: NEG
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 1
90050: PUSH
90051: LD_INT 0
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: LD_INT 1
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 0
90070: PUSH
90071: LD_INT 1
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 1
90080: NEG
90081: PUSH
90082: LD_INT 0
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: LD_INT 1
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 2
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 2
90113: PUSH
90114: LD_INT 2
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: PUSH
90124: LD_INT 2
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: LD_INT 2
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 1
90143: NEG
90144: PUSH
90145: LD_INT 1
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90166: LD_ADDR_VAR 0 51
90170: PUSH
90171: LD_INT 0
90173: PUSH
90174: LD_INT 0
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: LD_INT 0
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: LD_INT 1
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 1
90224: NEG
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 1
90235: NEG
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: PUSH
90248: LD_INT 2
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 0
90257: PUSH
90258: LD_INT 2
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 1
90267: NEG
90268: PUSH
90269: LD_INT 1
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: LD_INT 2
90278: NEG
90279: PUSH
90280: LD_INT 0
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 2
90289: NEG
90290: PUSH
90291: LD_INT 1
90293: NEG
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90313: LD_ADDR_VAR 0 52
90317: PUSH
90318: LD_INT 0
90320: PUSH
90321: LD_INT 0
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 0
90330: PUSH
90331: LD_INT 1
90333: NEG
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 1
90341: PUSH
90342: LD_INT 0
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: LD_INT 1
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 0
90361: PUSH
90362: LD_INT 1
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 1
90371: NEG
90372: PUSH
90373: LD_INT 0
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 1
90382: NEG
90383: PUSH
90384: LD_INT 1
90386: NEG
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 1
90394: NEG
90395: PUSH
90396: LD_INT 2
90398: NEG
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: PUSH
90404: LD_INT 1
90406: NEG
90407: PUSH
90408: LD_INT 1
90410: PUSH
90411: EMPTY
90412: LIST
90413: LIST
90414: PUSH
90415: LD_INT 2
90417: NEG
90418: PUSH
90419: LD_INT 0
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 2
90428: NEG
90429: PUSH
90430: LD_INT 1
90432: NEG
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: PUSH
90438: LD_INT 2
90440: NEG
90441: PUSH
90442: LD_INT 2
90444: NEG
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90464: LD_ADDR_VAR 0 53
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 1
90502: PUSH
90503: LD_INT 1
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: LD_INT 0
90512: PUSH
90513: LD_INT 1
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PUSH
90520: LD_INT 1
90522: NEG
90523: PUSH
90524: LD_INT 0
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 1
90533: NEG
90534: PUSH
90535: LD_INT 1
90537: NEG
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: LD_INT 2
90549: NEG
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 0
90557: PUSH
90558: LD_INT 2
90560: NEG
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 1
90568: PUSH
90569: LD_INT 1
90571: NEG
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 2
90579: PUSH
90580: LD_INT 0
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: LD_INT 2
90589: PUSH
90590: LD_INT 1
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 2
90599: PUSH
90600: LD_INT 2
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 1
90609: PUSH
90610: LD_INT 2
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 0
90619: PUSH
90620: LD_INT 2
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 1
90629: NEG
90630: PUSH
90631: LD_INT 1
90633: PUSH
90634: EMPTY
90635: LIST
90636: LIST
90637: PUSH
90638: LD_INT 2
90640: NEG
90641: PUSH
90642: LD_INT 0
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 2
90651: NEG
90652: PUSH
90653: LD_INT 1
90655: NEG
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: NEG
90664: PUSH
90665: LD_INT 2
90667: NEG
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90694: LD_ADDR_VAR 0 54
90698: PUSH
90699: LD_INT 0
90701: PUSH
90702: LD_INT 0
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: LD_INT 1
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 1
90732: PUSH
90733: LD_INT 1
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 0
90742: PUSH
90743: LD_INT 1
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 1
90752: NEG
90753: PUSH
90754: LD_INT 0
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 1
90763: NEG
90764: PUSH
90765: LD_INT 1
90767: NEG
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 1
90775: NEG
90776: PUSH
90777: LD_INT 2
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 0
90787: PUSH
90788: LD_INT 2
90790: NEG
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 1
90798: PUSH
90799: LD_INT 1
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 2
90809: PUSH
90810: LD_INT 0
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PUSH
90817: LD_INT 2
90819: PUSH
90820: LD_INT 1
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 2
90829: PUSH
90830: LD_INT 2
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 1
90839: PUSH
90840: LD_INT 2
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 0
90849: PUSH
90850: LD_INT 2
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 1
90859: NEG
90860: PUSH
90861: LD_INT 1
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 2
90870: NEG
90871: PUSH
90872: LD_INT 0
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 2
90881: NEG
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 2
90893: NEG
90894: PUSH
90895: LD_INT 2
90897: NEG
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90924: LD_ADDR_VAR 0 55
90928: PUSH
90929: LD_INT 0
90931: PUSH
90932: LD_INT 0
90934: PUSH
90935: EMPTY
90936: LIST
90937: LIST
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: LD_INT 1
90944: NEG
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PUSH
90950: LD_INT 1
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PUSH
90960: LD_INT 1
90962: PUSH
90963: LD_INT 1
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: PUSH
90970: LD_INT 0
90972: PUSH
90973: LD_INT 1
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 1
90982: NEG
90983: PUSH
90984: LD_INT 0
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: PUSH
90991: LD_INT 1
90993: NEG
90994: PUSH
90995: LD_INT 1
90997: NEG
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 1
91005: NEG
91006: PUSH
91007: LD_INT 2
91009: NEG
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 0
91017: PUSH
91018: LD_INT 2
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: LD_INT 1
91031: NEG
91032: PUSH
91033: EMPTY
91034: LIST
91035: LIST
91036: PUSH
91037: LD_INT 2
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 2
91049: PUSH
91050: LD_INT 1
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 2
91059: PUSH
91060: LD_INT 2
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 1
91069: PUSH
91070: LD_INT 2
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 0
91079: PUSH
91080: LD_INT 2
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PUSH
91087: LD_INT 1
91089: NEG
91090: PUSH
91091: LD_INT 1
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 2
91100: NEG
91101: PUSH
91102: LD_INT 0
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 2
91111: NEG
91112: PUSH
91113: LD_INT 1
91115: NEG
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 2
91123: NEG
91124: PUSH
91125: LD_INT 2
91127: NEG
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91154: LD_ADDR_VAR 0 56
91158: PUSH
91159: LD_INT 0
91161: PUSH
91162: LD_INT 0
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: PUSH
91180: LD_INT 1
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 1
91192: PUSH
91193: LD_INT 1
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 0
91202: PUSH
91203: LD_INT 1
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 1
91212: NEG
91213: PUSH
91214: LD_INT 0
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 1
91223: NEG
91224: PUSH
91225: LD_INT 1
91227: NEG
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: NEG
91236: PUSH
91237: LD_INT 2
91239: NEG
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 0
91247: PUSH
91248: LD_INT 2
91250: NEG
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 1
91258: PUSH
91259: LD_INT 1
91261: NEG
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 2
91269: PUSH
91270: LD_INT 0
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 2
91279: PUSH
91280: LD_INT 1
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 2
91289: PUSH
91290: LD_INT 2
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 1
91299: PUSH
91300: LD_INT 2
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: LD_INT 2
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: LD_INT 1
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: PUSH
91328: LD_INT 2
91330: NEG
91331: PUSH
91332: LD_INT 0
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 2
91341: NEG
91342: PUSH
91343: LD_INT 1
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 2
91353: NEG
91354: PUSH
91355: LD_INT 2
91357: NEG
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91384: LD_ADDR_VAR 0 57
91388: PUSH
91389: LD_INT 0
91391: PUSH
91392: LD_INT 0
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 0
91401: PUSH
91402: LD_INT 1
91404: NEG
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 1
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 1
91422: PUSH
91423: LD_INT 1
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: LD_INT 0
91432: PUSH
91433: LD_INT 1
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 1
91442: NEG
91443: PUSH
91444: LD_INT 0
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 1
91453: NEG
91454: PUSH
91455: LD_INT 1
91457: NEG
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: PUSH
91463: LD_INT 1
91465: NEG
91466: PUSH
91467: LD_INT 2
91469: NEG
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 0
91477: PUSH
91478: LD_INT 2
91480: NEG
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 1
91488: PUSH
91489: LD_INT 1
91491: NEG
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 2
91499: PUSH
91500: LD_INT 0
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: PUSH
91507: LD_INT 2
91509: PUSH
91510: LD_INT 1
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 2
91519: PUSH
91520: LD_INT 2
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 1
91529: PUSH
91530: LD_INT 2
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 0
91539: PUSH
91540: LD_INT 2
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: LD_INT 1
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 2
91560: NEG
91561: PUSH
91562: LD_INT 0
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 2
91571: NEG
91572: PUSH
91573: LD_INT 1
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 2
91583: NEG
91584: PUSH
91585: LD_INT 2
91587: NEG
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: EMPTY
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91614: LD_ADDR_VAR 0 58
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: LD_INT 0
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 0
91662: PUSH
91663: LD_INT 1
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 1
91672: NEG
91673: PUSH
91674: LD_INT 0
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 1
91683: NEG
91684: PUSH
91685: LD_INT 1
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 1
91695: NEG
91696: PUSH
91697: LD_INT 2
91699: NEG
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 0
91707: PUSH
91708: LD_INT 2
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 1
91718: PUSH
91719: LD_INT 1
91721: NEG
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: PUSH
91727: LD_INT 2
91729: PUSH
91730: LD_INT 0
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PUSH
91737: LD_INT 2
91739: PUSH
91740: LD_INT 1
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 2
91749: PUSH
91750: LD_INT 2
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 1
91759: PUSH
91760: LD_INT 2
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 2
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 1
91779: NEG
91780: PUSH
91781: LD_INT 1
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 2
91790: NEG
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 2
91801: NEG
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 2
91813: NEG
91814: PUSH
91815: LD_INT 2
91817: NEG
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: LIST
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91844: LD_ADDR_VAR 0 59
91848: PUSH
91849: LD_INT 0
91851: PUSH
91852: LD_INT 0
91854: PUSH
91855: EMPTY
91856: LIST
91857: LIST
91858: PUSH
91859: LD_INT 0
91861: PUSH
91862: LD_INT 1
91864: NEG
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 1
91872: PUSH
91873: LD_INT 0
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: LD_INT 1
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 0
91892: PUSH
91893: LD_INT 1
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 1
91902: NEG
91903: PUSH
91904: LD_INT 0
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 1
91913: NEG
91914: PUSH
91915: LD_INT 1
91917: NEG
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91932: LD_ADDR_VAR 0 60
91936: PUSH
91937: LD_INT 0
91939: PUSH
91940: LD_INT 0
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: PUSH
91947: LD_INT 0
91949: PUSH
91950: LD_INT 1
91952: NEG
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 1
91960: PUSH
91961: LD_INT 0
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: PUSH
91968: LD_INT 1
91970: PUSH
91971: LD_INT 1
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: PUSH
91978: LD_INT 0
91980: PUSH
91981: LD_INT 1
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 1
91990: NEG
91991: PUSH
91992: LD_INT 0
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 1
92001: NEG
92002: PUSH
92003: LD_INT 1
92005: NEG
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92020: LD_ADDR_VAR 0 61
92024: PUSH
92025: LD_INT 0
92027: PUSH
92028: LD_INT 0
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 0
92037: PUSH
92038: LD_INT 1
92040: NEG
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 1
92048: PUSH
92049: LD_INT 0
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: LD_INT 1
92058: PUSH
92059: LD_INT 1
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 0
92068: PUSH
92069: LD_INT 1
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: NEG
92079: PUSH
92080: LD_INT 0
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 1
92089: NEG
92090: PUSH
92091: LD_INT 1
92093: NEG
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: EMPTY
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92108: LD_ADDR_VAR 0 62
92112: PUSH
92113: LD_INT 0
92115: PUSH
92116: LD_INT 0
92118: PUSH
92119: EMPTY
92120: LIST
92121: LIST
92122: PUSH
92123: LD_INT 0
92125: PUSH
92126: LD_INT 1
92128: NEG
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: LD_INT 0
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 1
92146: PUSH
92147: LD_INT 1
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: LD_INT 0
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 1
92166: NEG
92167: PUSH
92168: LD_INT 0
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 1
92177: NEG
92178: PUSH
92179: LD_INT 1
92181: NEG
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92196: LD_ADDR_VAR 0 63
92200: PUSH
92201: LD_INT 0
92203: PUSH
92204: LD_INT 0
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: LD_INT 1
92216: NEG
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 1
92224: PUSH
92225: LD_INT 0
92227: PUSH
92228: EMPTY
92229: LIST
92230: LIST
92231: PUSH
92232: LD_INT 1
92234: PUSH
92235: LD_INT 1
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 0
92244: PUSH
92245: LD_INT 1
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 1
92254: NEG
92255: PUSH
92256: LD_INT 0
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 1
92265: NEG
92266: PUSH
92267: LD_INT 1
92269: NEG
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: EMPTY
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92284: LD_ADDR_VAR 0 64
92288: PUSH
92289: LD_INT 0
92291: PUSH
92292: LD_INT 0
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 0
92301: PUSH
92302: LD_INT 1
92304: NEG
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 1
92312: PUSH
92313: LD_INT 0
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 1
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 0
92332: PUSH
92333: LD_INT 1
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 1
92342: NEG
92343: PUSH
92344: LD_INT 0
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 1
92353: NEG
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: ST_TO_ADDR
// end ; 1 :
92372: GO 98269
92374: LD_INT 1
92376: DOUBLE
92377: EQUAL
92378: IFTRUE 92382
92380: GO 95005
92382: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92383: LD_ADDR_VAR 0 11
92387: PUSH
92388: LD_INT 1
92390: NEG
92391: PUSH
92392: LD_INT 3
92394: NEG
92395: PUSH
92396: EMPTY
92397: LIST
92398: LIST
92399: PUSH
92400: LD_INT 0
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: LD_INT 1
92413: PUSH
92414: LD_INT 2
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: LIST
92426: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92427: LD_ADDR_VAR 0 12
92431: PUSH
92432: LD_INT 2
92434: PUSH
92435: LD_INT 1
92437: NEG
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 3
92445: PUSH
92446: LD_INT 0
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 3
92455: PUSH
92456: LD_INT 1
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: LIST
92467: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92468: LD_ADDR_VAR 0 13
92472: PUSH
92473: LD_INT 3
92475: PUSH
92476: LD_INT 2
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 3
92485: PUSH
92486: LD_INT 3
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 2
92495: PUSH
92496: LD_INT 3
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: LIST
92507: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92508: LD_ADDR_VAR 0 14
92512: PUSH
92513: LD_INT 1
92515: PUSH
92516: LD_INT 3
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 0
92525: PUSH
92526: LD_INT 3
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 1
92535: NEG
92536: PUSH
92537: LD_INT 2
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: LIST
92548: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92549: LD_ADDR_VAR 0 15
92553: PUSH
92554: LD_INT 2
92556: NEG
92557: PUSH
92558: LD_INT 1
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 3
92567: NEG
92568: PUSH
92569: LD_INT 0
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 3
92578: NEG
92579: PUSH
92580: LD_INT 1
92582: NEG
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: LIST
92592: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92593: LD_ADDR_VAR 0 16
92597: PUSH
92598: LD_INT 2
92600: NEG
92601: PUSH
92602: LD_INT 3
92604: NEG
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: LD_INT 3
92612: NEG
92613: PUSH
92614: LD_INT 2
92616: NEG
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 3
92624: NEG
92625: PUSH
92626: LD_INT 3
92628: NEG
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: LIST
92638: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92639: LD_ADDR_VAR 0 17
92643: PUSH
92644: LD_INT 1
92646: NEG
92647: PUSH
92648: LD_INT 3
92650: NEG
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 0
92658: PUSH
92659: LD_INT 3
92661: NEG
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 1
92669: PUSH
92670: LD_INT 2
92672: NEG
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: LIST
92682: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92683: LD_ADDR_VAR 0 18
92687: PUSH
92688: LD_INT 2
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 3
92701: PUSH
92702: LD_INT 0
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 3
92711: PUSH
92712: LD_INT 1
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: EMPTY
92720: LIST
92721: LIST
92722: LIST
92723: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92724: LD_ADDR_VAR 0 19
92728: PUSH
92729: LD_INT 3
92731: PUSH
92732: LD_INT 2
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 3
92741: PUSH
92742: LD_INT 3
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 3
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: LIST
92763: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92764: LD_ADDR_VAR 0 20
92768: PUSH
92769: LD_INT 1
92771: PUSH
92772: LD_INT 3
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 0
92781: PUSH
92782: LD_INT 3
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 1
92791: NEG
92792: PUSH
92793: LD_INT 2
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: LIST
92804: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92805: LD_ADDR_VAR 0 21
92809: PUSH
92810: LD_INT 2
92812: NEG
92813: PUSH
92814: LD_INT 1
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 3
92823: NEG
92824: PUSH
92825: LD_INT 0
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 3
92834: NEG
92835: PUSH
92836: LD_INT 1
92838: NEG
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: LIST
92848: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92849: LD_ADDR_VAR 0 22
92853: PUSH
92854: LD_INT 2
92856: NEG
92857: PUSH
92858: LD_INT 3
92860: NEG
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 3
92868: NEG
92869: PUSH
92870: LD_INT 2
92872: NEG
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 3
92880: NEG
92881: PUSH
92882: LD_INT 3
92884: NEG
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: LIST
92894: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92895: LD_ADDR_VAR 0 23
92899: PUSH
92900: LD_INT 0
92902: PUSH
92903: LD_INT 3
92905: NEG
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 1
92913: NEG
92914: PUSH
92915: LD_INT 4
92917: NEG
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 1
92925: PUSH
92926: LD_INT 3
92928: NEG
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: LIST
92938: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92939: LD_ADDR_VAR 0 24
92943: PUSH
92944: LD_INT 3
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 3
92956: PUSH
92957: LD_INT 1
92959: NEG
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 4
92967: PUSH
92968: LD_INT 1
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: LIST
92979: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92980: LD_ADDR_VAR 0 25
92984: PUSH
92985: LD_INT 3
92987: PUSH
92988: LD_INT 3
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 4
92997: PUSH
92998: LD_INT 3
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 3
93007: PUSH
93008: LD_INT 4
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: LIST
93019: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93020: LD_ADDR_VAR 0 26
93024: PUSH
93025: LD_INT 0
93027: PUSH
93028: LD_INT 3
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: LD_INT 4
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 1
93047: NEG
93048: PUSH
93049: LD_INT 3
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: LIST
93060: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93061: LD_ADDR_VAR 0 27
93065: PUSH
93066: LD_INT 3
93068: NEG
93069: PUSH
93070: LD_INT 0
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 3
93079: NEG
93080: PUSH
93081: LD_INT 1
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 4
93090: NEG
93091: PUSH
93092: LD_INT 1
93094: NEG
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: LIST
93104: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93105: LD_ADDR_VAR 0 28
93109: PUSH
93110: LD_INT 3
93112: NEG
93113: PUSH
93114: LD_INT 3
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 3
93124: NEG
93125: PUSH
93126: LD_INT 4
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 4
93136: NEG
93137: PUSH
93138: LD_INT 3
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: LIST
93150: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93151: LD_ADDR_VAR 0 29
93155: PUSH
93156: LD_INT 1
93158: NEG
93159: PUSH
93160: LD_INT 3
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: LD_INT 0
93170: PUSH
93171: LD_INT 3
93173: NEG
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: PUSH
93179: LD_INT 1
93181: PUSH
93182: LD_INT 2
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 1
93192: NEG
93193: PUSH
93194: LD_INT 4
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 0
93204: PUSH
93205: LD_INT 4
93207: NEG
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 1
93215: PUSH
93216: LD_INT 3
93218: NEG
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 1
93226: NEG
93227: PUSH
93228: LD_INT 5
93230: NEG
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 5
93241: NEG
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 1
93249: PUSH
93250: LD_INT 4
93252: NEG
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 1
93260: NEG
93261: PUSH
93262: LD_INT 6
93264: NEG
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 0
93272: PUSH
93273: LD_INT 6
93275: NEG
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: LD_INT 1
93283: PUSH
93284: LD_INT 5
93286: NEG
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
93306: LD_ADDR_VAR 0 30
93310: PUSH
93311: LD_INT 2
93313: PUSH
93314: LD_INT 1
93316: NEG
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: LD_INT 3
93324: PUSH
93325: LD_INT 0
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: LD_INT 3
93334: PUSH
93335: LD_INT 1
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 3
93344: PUSH
93345: LD_INT 1
93347: NEG
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 4
93355: PUSH
93356: LD_INT 0
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 4
93365: PUSH
93366: LD_INT 1
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: LD_INT 1
93378: NEG
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 5
93386: PUSH
93387: LD_INT 0
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: LD_INT 5
93396: PUSH
93397: LD_INT 1
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 5
93406: PUSH
93407: LD_INT 1
93409: NEG
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 6
93417: PUSH
93418: LD_INT 0
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 6
93427: PUSH
93428: LD_INT 1
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93449: LD_ADDR_VAR 0 31
93453: PUSH
93454: LD_INT 3
93456: PUSH
93457: LD_INT 2
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 3
93466: PUSH
93467: LD_INT 3
93469: PUSH
93470: EMPTY
93471: LIST
93472: LIST
93473: PUSH
93474: LD_INT 2
93476: PUSH
93477: LD_INT 3
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 4
93486: PUSH
93487: LD_INT 3
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: LD_INT 4
93496: PUSH
93497: LD_INT 4
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 3
93506: PUSH
93507: LD_INT 4
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 5
93516: PUSH
93517: LD_INT 4
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 5
93526: PUSH
93527: LD_INT 5
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: LD_INT 4
93536: PUSH
93537: LD_INT 5
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 6
93546: PUSH
93547: LD_INT 5
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 6
93556: PUSH
93557: LD_INT 6
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 5
93566: PUSH
93567: LD_INT 6
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93588: LD_ADDR_VAR 0 32
93592: PUSH
93593: LD_INT 1
93595: PUSH
93596: LD_INT 3
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 0
93605: PUSH
93606: LD_INT 3
93608: PUSH
93609: EMPTY
93610: LIST
93611: LIST
93612: PUSH
93613: LD_INT 1
93615: NEG
93616: PUSH
93617: LD_INT 2
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 1
93626: PUSH
93627: LD_INT 4
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 0
93636: PUSH
93637: LD_INT 4
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 1
93646: NEG
93647: PUSH
93648: LD_INT 3
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 1
93657: PUSH
93658: LD_INT 5
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 0
93667: PUSH
93668: LD_INT 5
93670: PUSH
93671: EMPTY
93672: LIST
93673: LIST
93674: PUSH
93675: LD_INT 1
93677: NEG
93678: PUSH
93679: LD_INT 4
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 1
93688: PUSH
93689: LD_INT 6
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: LD_INT 0
93698: PUSH
93699: LD_INT 6
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 1
93708: NEG
93709: PUSH
93710: LD_INT 5
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93731: LD_ADDR_VAR 0 33
93735: PUSH
93736: LD_INT 2
93738: NEG
93739: PUSH
93740: LD_INT 1
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: NEG
93750: PUSH
93751: LD_INT 0
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 3
93760: NEG
93761: PUSH
93762: LD_INT 1
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 3
93772: NEG
93773: PUSH
93774: LD_INT 1
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 4
93783: NEG
93784: PUSH
93785: LD_INT 0
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 4
93794: NEG
93795: PUSH
93796: LD_INT 1
93798: NEG
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 4
93806: NEG
93807: PUSH
93808: LD_INT 1
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 5
93817: NEG
93818: PUSH
93819: LD_INT 0
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 5
93828: NEG
93829: PUSH
93830: LD_INT 1
93832: NEG
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: LD_INT 5
93840: NEG
93841: PUSH
93842: LD_INT 1
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 6
93851: NEG
93852: PUSH
93853: LD_INT 0
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 6
93862: NEG
93863: PUSH
93864: LD_INT 1
93866: NEG
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93886: LD_ADDR_VAR 0 34
93890: PUSH
93891: LD_INT 2
93893: NEG
93894: PUSH
93895: LD_INT 3
93897: NEG
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 3
93905: NEG
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 3
93917: NEG
93918: PUSH
93919: LD_INT 3
93921: NEG
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 3
93929: NEG
93930: PUSH
93931: LD_INT 4
93933: NEG
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PUSH
93939: LD_INT 4
93941: NEG
93942: PUSH
93943: LD_INT 3
93945: NEG
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: PUSH
93951: LD_INT 4
93953: NEG
93954: PUSH
93955: LD_INT 4
93957: NEG
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 4
93965: NEG
93966: PUSH
93967: LD_INT 5
93969: NEG
93970: PUSH
93971: EMPTY
93972: LIST
93973: LIST
93974: PUSH
93975: LD_INT 5
93977: NEG
93978: PUSH
93979: LD_INT 4
93981: NEG
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: PUSH
93987: LD_INT 5
93989: NEG
93990: PUSH
93991: LD_INT 5
93993: NEG
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 5
94001: NEG
94002: PUSH
94003: LD_INT 6
94005: NEG
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 6
94013: NEG
94014: PUSH
94015: LD_INT 5
94017: NEG
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 6
94025: NEG
94026: PUSH
94027: LD_INT 6
94029: NEG
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94049: LD_ADDR_VAR 0 41
94053: PUSH
94054: LD_INT 0
94056: PUSH
94057: LD_INT 2
94059: NEG
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 1
94067: NEG
94068: PUSH
94069: LD_INT 3
94071: NEG
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: PUSH
94077: LD_INT 1
94079: PUSH
94080: LD_INT 2
94082: NEG
94083: PUSH
94084: EMPTY
94085: LIST
94086: LIST
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: LIST
94092: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94093: LD_ADDR_VAR 0 42
94097: PUSH
94098: LD_INT 2
94100: PUSH
94101: LD_INT 0
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 2
94110: PUSH
94111: LD_INT 1
94113: NEG
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 3
94121: PUSH
94122: LD_INT 1
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: EMPTY
94130: LIST
94131: LIST
94132: LIST
94133: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94134: LD_ADDR_VAR 0 43
94138: PUSH
94139: LD_INT 2
94141: PUSH
94142: LD_INT 2
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 3
94151: PUSH
94152: LD_INT 2
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 2
94161: PUSH
94162: LD_INT 3
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: LIST
94173: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94174: LD_ADDR_VAR 0 44
94178: PUSH
94179: LD_INT 0
94181: PUSH
94182: LD_INT 2
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: LD_INT 3
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 1
94201: NEG
94202: PUSH
94203: LD_INT 2
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: LIST
94214: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94215: LD_ADDR_VAR 0 45
94219: PUSH
94220: LD_INT 2
94222: NEG
94223: PUSH
94224: LD_INT 0
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 2
94233: NEG
94234: PUSH
94235: LD_INT 1
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 3
94244: NEG
94245: PUSH
94246: LD_INT 1
94248: NEG
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: LIST
94258: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94259: LD_ADDR_VAR 0 46
94263: PUSH
94264: LD_INT 2
94266: NEG
94267: PUSH
94268: LD_INT 2
94270: NEG
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 2
94278: NEG
94279: PUSH
94280: LD_INT 3
94282: NEG
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 3
94290: NEG
94291: PUSH
94292: LD_INT 2
94294: NEG
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: LIST
94304: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
94305: LD_ADDR_VAR 0 47
94309: PUSH
94310: LD_INT 2
94312: NEG
94313: PUSH
94314: LD_INT 3
94316: NEG
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 1
94324: NEG
94325: PUSH
94326: LD_INT 3
94328: NEG
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94338: LD_ADDR_VAR 0 48
94342: PUSH
94343: LD_INT 1
94345: PUSH
94346: LD_INT 2
94348: NEG
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 2
94356: PUSH
94357: LD_INT 1
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94369: LD_ADDR_VAR 0 49
94373: PUSH
94374: LD_INT 3
94376: PUSH
94377: LD_INT 1
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: LD_INT 2
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94398: LD_ADDR_VAR 0 50
94402: PUSH
94403: LD_INT 2
94405: PUSH
94406: LD_INT 3
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 1
94415: PUSH
94416: LD_INT 3
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94427: LD_ADDR_VAR 0 51
94431: PUSH
94432: LD_INT 1
94434: NEG
94435: PUSH
94436: LD_INT 2
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 2
94445: NEG
94446: PUSH
94447: LD_INT 1
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94458: LD_ADDR_VAR 0 52
94462: PUSH
94463: LD_INT 3
94465: NEG
94466: PUSH
94467: LD_INT 1
94469: NEG
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 3
94477: NEG
94478: PUSH
94479: LD_INT 2
94481: NEG
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94491: LD_ADDR_VAR 0 53
94495: PUSH
94496: LD_INT 1
94498: NEG
94499: PUSH
94500: LD_INT 3
94502: NEG
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: PUSH
94508: LD_INT 0
94510: PUSH
94511: LD_INT 3
94513: NEG
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 1
94521: PUSH
94522: LD_INT 2
94524: NEG
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: LIST
94534: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94535: LD_ADDR_VAR 0 54
94539: PUSH
94540: LD_INT 2
94542: PUSH
94543: LD_INT 1
94545: NEG
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 3
94553: PUSH
94554: LD_INT 0
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: LD_INT 1
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: LIST
94575: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94576: LD_ADDR_VAR 0 55
94580: PUSH
94581: LD_INT 3
94583: PUSH
94584: LD_INT 2
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 3
94593: PUSH
94594: LD_INT 3
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 2
94603: PUSH
94604: LD_INT 3
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: LIST
94615: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94616: LD_ADDR_VAR 0 56
94620: PUSH
94621: LD_INT 1
94623: PUSH
94624: LD_INT 3
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 0
94633: PUSH
94634: LD_INT 3
94636: PUSH
94637: EMPTY
94638: LIST
94639: LIST
94640: PUSH
94641: LD_INT 1
94643: NEG
94644: PUSH
94645: LD_INT 2
94647: PUSH
94648: EMPTY
94649: LIST
94650: LIST
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: LIST
94656: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94657: LD_ADDR_VAR 0 57
94661: PUSH
94662: LD_INT 2
94664: NEG
94665: PUSH
94666: LD_INT 1
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: LD_INT 3
94675: NEG
94676: PUSH
94677: LD_INT 0
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 3
94686: NEG
94687: PUSH
94688: LD_INT 1
94690: NEG
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: LIST
94700: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94701: LD_ADDR_VAR 0 58
94705: PUSH
94706: LD_INT 2
94708: NEG
94709: PUSH
94710: LD_INT 3
94712: NEG
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 3
94720: NEG
94721: PUSH
94722: LD_INT 2
94724: NEG
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 3
94732: NEG
94733: PUSH
94734: LD_INT 3
94736: NEG
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: LIST
94746: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94747: LD_ADDR_VAR 0 59
94751: PUSH
94752: LD_INT 1
94754: NEG
94755: PUSH
94756: LD_INT 2
94758: NEG
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 0
94766: PUSH
94767: LD_INT 2
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 1
94777: PUSH
94778: LD_INT 1
94780: NEG
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: LIST
94790: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94791: LD_ADDR_VAR 0 60
94795: PUSH
94796: LD_INT 1
94798: PUSH
94799: LD_INT 1
94801: NEG
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: LD_INT 2
94809: PUSH
94810: LD_INT 0
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: PUSH
94817: LD_INT 2
94819: PUSH
94820: LD_INT 1
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: LIST
94831: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94832: LD_ADDR_VAR 0 61
94836: PUSH
94837: LD_INT 2
94839: PUSH
94840: LD_INT 1
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 2
94849: PUSH
94850: LD_INT 2
94852: PUSH
94853: EMPTY
94854: LIST
94855: LIST
94856: PUSH
94857: LD_INT 1
94859: PUSH
94860: LD_INT 2
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: LIST
94871: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94872: LD_ADDR_VAR 0 62
94876: PUSH
94877: LD_INT 1
94879: PUSH
94880: LD_INT 2
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: PUSH
94887: LD_INT 0
94889: PUSH
94890: LD_INT 2
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: PUSH
94897: LD_INT 1
94899: NEG
94900: PUSH
94901: LD_INT 1
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: LIST
94912: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94913: LD_ADDR_VAR 0 63
94917: PUSH
94918: LD_INT 1
94920: NEG
94921: PUSH
94922: LD_INT 1
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 2
94931: NEG
94932: PUSH
94933: LD_INT 0
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: LD_INT 2
94942: NEG
94943: PUSH
94944: LD_INT 1
94946: NEG
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: LIST
94956: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94957: LD_ADDR_VAR 0 64
94961: PUSH
94962: LD_INT 1
94964: NEG
94965: PUSH
94966: LD_INT 2
94968: NEG
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 2
94976: NEG
94977: PUSH
94978: LD_INT 1
94980: NEG
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 2
94988: NEG
94989: PUSH
94990: LD_INT 2
94992: NEG
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: LIST
95002: ST_TO_ADDR
// end ; 2 :
95003: GO 98269
95005: LD_INT 2
95007: DOUBLE
95008: EQUAL
95009: IFTRUE 95013
95011: GO 98268
95013: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95014: LD_ADDR_VAR 0 29
95018: PUSH
95019: LD_INT 4
95021: PUSH
95022: LD_INT 0
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 4
95031: PUSH
95032: LD_INT 1
95034: NEG
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 5
95042: PUSH
95043: LD_INT 0
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 5
95052: PUSH
95053: LD_INT 1
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: PUSH
95060: LD_INT 4
95062: PUSH
95063: LD_INT 1
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: LD_INT 3
95072: PUSH
95073: LD_INT 0
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: PUSH
95080: LD_INT 3
95082: PUSH
95083: LD_INT 1
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 3
95093: PUSH
95094: LD_INT 2
95096: NEG
95097: PUSH
95098: EMPTY
95099: LIST
95100: LIST
95101: PUSH
95102: LD_INT 5
95104: PUSH
95105: LD_INT 2
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 3
95114: PUSH
95115: LD_INT 3
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 3
95124: PUSH
95125: LD_INT 2
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 4
95134: PUSH
95135: LD_INT 3
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 4
95144: PUSH
95145: LD_INT 4
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: LD_INT 3
95154: PUSH
95155: LD_INT 4
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 2
95164: PUSH
95165: LD_INT 3
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 2
95174: PUSH
95175: LD_INT 2
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 4
95184: PUSH
95185: LD_INT 2
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 2
95194: PUSH
95195: LD_INT 4
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 0
95204: PUSH
95205: LD_INT 4
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: LD_INT 0
95214: PUSH
95215: LD_INT 3
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PUSH
95222: LD_INT 1
95224: PUSH
95225: LD_INT 4
95227: PUSH
95228: EMPTY
95229: LIST
95230: LIST
95231: PUSH
95232: LD_INT 1
95234: PUSH
95235: LD_INT 5
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: PUSH
95242: LD_INT 0
95244: PUSH
95245: LD_INT 5
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 1
95254: NEG
95255: PUSH
95256: LD_INT 4
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 1
95265: NEG
95266: PUSH
95267: LD_INT 3
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 2
95276: PUSH
95277: LD_INT 5
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 2
95286: NEG
95287: PUSH
95288: LD_INT 3
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 3
95297: NEG
95298: PUSH
95299: LD_INT 0
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: PUSH
95306: LD_INT 3
95308: NEG
95309: PUSH
95310: LD_INT 1
95312: NEG
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: PUSH
95318: LD_INT 2
95320: NEG
95321: PUSH
95322: LD_INT 0
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: PUSH
95329: LD_INT 2
95331: NEG
95332: PUSH
95333: LD_INT 1
95335: PUSH
95336: EMPTY
95337: LIST
95338: LIST
95339: PUSH
95340: LD_INT 3
95342: NEG
95343: PUSH
95344: LD_INT 1
95346: PUSH
95347: EMPTY
95348: LIST
95349: LIST
95350: PUSH
95351: LD_INT 4
95353: NEG
95354: PUSH
95355: LD_INT 0
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 4
95364: NEG
95365: PUSH
95366: LD_INT 1
95368: NEG
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 4
95376: NEG
95377: PUSH
95378: LD_INT 2
95380: NEG
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 2
95388: NEG
95389: PUSH
95390: LD_INT 2
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 4
95399: NEG
95400: PUSH
95401: LD_INT 4
95403: NEG
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 4
95411: NEG
95412: PUSH
95413: LD_INT 5
95415: NEG
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 3
95423: NEG
95424: PUSH
95425: LD_INT 4
95427: NEG
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: PUSH
95433: LD_INT 3
95435: NEG
95436: PUSH
95437: LD_INT 3
95439: NEG
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: PUSH
95445: LD_INT 4
95447: NEG
95448: PUSH
95449: LD_INT 3
95451: NEG
95452: PUSH
95453: EMPTY
95454: LIST
95455: LIST
95456: PUSH
95457: LD_INT 5
95459: NEG
95460: PUSH
95461: LD_INT 4
95463: NEG
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 5
95471: NEG
95472: PUSH
95473: LD_INT 5
95475: NEG
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 3
95483: NEG
95484: PUSH
95485: LD_INT 5
95487: NEG
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 5
95495: NEG
95496: PUSH
95497: LD_INT 3
95499: NEG
95500: PUSH
95501: EMPTY
95502: LIST
95503: LIST
95504: PUSH
95505: EMPTY
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95552: LD_ADDR_VAR 0 30
95556: PUSH
95557: LD_INT 4
95559: PUSH
95560: LD_INT 4
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 4
95569: PUSH
95570: LD_INT 3
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 5
95579: PUSH
95580: LD_INT 4
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: LD_INT 5
95589: PUSH
95590: LD_INT 5
95592: PUSH
95593: EMPTY
95594: LIST
95595: LIST
95596: PUSH
95597: LD_INT 4
95599: PUSH
95600: LD_INT 5
95602: PUSH
95603: EMPTY
95604: LIST
95605: LIST
95606: PUSH
95607: LD_INT 3
95609: PUSH
95610: LD_INT 4
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 3
95619: PUSH
95620: LD_INT 3
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: PUSH
95627: LD_INT 5
95629: PUSH
95630: LD_INT 3
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 3
95639: PUSH
95640: LD_INT 5
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 0
95649: PUSH
95650: LD_INT 3
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 0
95659: PUSH
95660: LD_INT 2
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 1
95669: PUSH
95670: LD_INT 3
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 1
95679: PUSH
95680: LD_INT 4
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 0
95689: PUSH
95690: LD_INT 4
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: PUSH
95697: LD_INT 1
95699: NEG
95700: PUSH
95701: LD_INT 3
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 1
95710: NEG
95711: PUSH
95712: LD_INT 2
95714: PUSH
95715: EMPTY
95716: LIST
95717: LIST
95718: PUSH
95719: LD_INT 2
95721: PUSH
95722: LD_INT 4
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_INT 2
95731: NEG
95732: PUSH
95733: LD_INT 2
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PUSH
95740: LD_INT 4
95742: NEG
95743: PUSH
95744: LD_INT 0
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: LD_INT 1
95757: NEG
95758: PUSH
95759: EMPTY
95760: LIST
95761: LIST
95762: PUSH
95763: LD_INT 3
95765: NEG
95766: PUSH
95767: LD_INT 0
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 3
95776: NEG
95777: PUSH
95778: LD_INT 1
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 4
95787: NEG
95788: PUSH
95789: LD_INT 1
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 5
95798: NEG
95799: PUSH
95800: LD_INT 0
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 5
95809: NEG
95810: PUSH
95811: LD_INT 1
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 5
95821: NEG
95822: PUSH
95823: LD_INT 2
95825: NEG
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: PUSH
95831: LD_INT 3
95833: NEG
95834: PUSH
95835: LD_INT 2
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 3
95844: NEG
95845: PUSH
95846: LD_INT 3
95848: NEG
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 3
95856: NEG
95857: PUSH
95858: LD_INT 4
95860: NEG
95861: PUSH
95862: EMPTY
95863: LIST
95864: LIST
95865: PUSH
95866: LD_INT 2
95868: NEG
95869: PUSH
95870: LD_INT 3
95872: NEG
95873: PUSH
95874: EMPTY
95875: LIST
95876: LIST
95877: PUSH
95878: LD_INT 2
95880: NEG
95881: PUSH
95882: LD_INT 2
95884: NEG
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: PUSH
95890: LD_INT 3
95892: NEG
95893: PUSH
95894: LD_INT 2
95896: NEG
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: PUSH
95902: LD_INT 4
95904: NEG
95905: PUSH
95906: LD_INT 3
95908: NEG
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: LD_INT 4
95916: NEG
95917: PUSH
95918: LD_INT 4
95920: NEG
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: PUSH
95926: LD_INT 2
95928: NEG
95929: PUSH
95930: LD_INT 4
95932: NEG
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 4
95940: NEG
95941: PUSH
95942: LD_INT 2
95944: NEG
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: PUSH
95950: LD_INT 0
95952: PUSH
95953: LD_INT 4
95955: NEG
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 0
95963: PUSH
95964: LD_INT 5
95966: NEG
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: PUSH
95972: LD_INT 1
95974: PUSH
95975: LD_INT 4
95977: NEG
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 1
95985: PUSH
95986: LD_INT 3
95988: NEG
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 0
95996: PUSH
95997: LD_INT 3
95999: NEG
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 1
96007: NEG
96008: PUSH
96009: LD_INT 4
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 1
96019: NEG
96020: PUSH
96021: LD_INT 5
96023: NEG
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 2
96031: PUSH
96032: LD_INT 3
96034: NEG
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 2
96042: NEG
96043: PUSH
96044: LD_INT 5
96046: NEG
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: EMPTY
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96099: LD_ADDR_VAR 0 31
96103: PUSH
96104: LD_INT 0
96106: PUSH
96107: LD_INT 4
96109: PUSH
96110: EMPTY
96111: LIST
96112: LIST
96113: PUSH
96114: LD_INT 0
96116: PUSH
96117: LD_INT 3
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 1
96126: PUSH
96127: LD_INT 4
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: LD_INT 1
96136: PUSH
96137: LD_INT 5
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: PUSH
96144: LD_INT 0
96146: PUSH
96147: LD_INT 5
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PUSH
96154: LD_INT 1
96156: NEG
96157: PUSH
96158: LD_INT 4
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 1
96167: NEG
96168: PUSH
96169: LD_INT 3
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 2
96178: PUSH
96179: LD_INT 5
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 2
96188: NEG
96189: PUSH
96190: LD_INT 3
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 3
96199: NEG
96200: PUSH
96201: LD_INT 0
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 3
96210: NEG
96211: PUSH
96212: LD_INT 1
96214: NEG
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 2
96222: NEG
96223: PUSH
96224: LD_INT 0
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 2
96233: NEG
96234: PUSH
96235: LD_INT 1
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 3
96244: NEG
96245: PUSH
96246: LD_INT 1
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: PUSH
96253: LD_INT 4
96255: NEG
96256: PUSH
96257: LD_INT 0
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 4
96266: NEG
96267: PUSH
96268: LD_INT 1
96270: NEG
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 4
96278: NEG
96279: PUSH
96280: LD_INT 2
96282: NEG
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PUSH
96288: LD_INT 2
96290: NEG
96291: PUSH
96292: LD_INT 2
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: LD_INT 4
96301: NEG
96302: PUSH
96303: LD_INT 4
96305: NEG
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 4
96313: NEG
96314: PUSH
96315: LD_INT 5
96317: NEG
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 3
96325: NEG
96326: PUSH
96327: LD_INT 4
96329: NEG
96330: PUSH
96331: EMPTY
96332: LIST
96333: LIST
96334: PUSH
96335: LD_INT 3
96337: NEG
96338: PUSH
96339: LD_INT 3
96341: NEG
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 4
96349: NEG
96350: PUSH
96351: LD_INT 3
96353: NEG
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 5
96361: NEG
96362: PUSH
96363: LD_INT 4
96365: NEG
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 5
96373: NEG
96374: PUSH
96375: LD_INT 5
96377: NEG
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PUSH
96383: LD_INT 3
96385: NEG
96386: PUSH
96387: LD_INT 5
96389: NEG
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 5
96397: NEG
96398: PUSH
96399: LD_INT 3
96401: NEG
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: PUSH
96407: LD_INT 0
96409: PUSH
96410: LD_INT 3
96412: NEG
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: LD_INT 0
96420: PUSH
96421: LD_INT 4
96423: NEG
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: PUSH
96429: LD_INT 1
96431: PUSH
96432: LD_INT 3
96434: NEG
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_INT 1
96442: PUSH
96443: LD_INT 2
96445: NEG
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: PUSH
96451: LD_INT 0
96453: PUSH
96454: LD_INT 2
96456: NEG
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 1
96464: NEG
96465: PUSH
96466: LD_INT 3
96468: NEG
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 1
96476: NEG
96477: PUSH
96478: LD_INT 4
96480: NEG
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 2
96488: PUSH
96489: LD_INT 2
96491: NEG
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: PUSH
96497: LD_INT 2
96499: NEG
96500: PUSH
96501: LD_INT 4
96503: NEG
96504: PUSH
96505: EMPTY
96506: LIST
96507: LIST
96508: PUSH
96509: LD_INT 4
96511: PUSH
96512: LD_INT 0
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 4
96521: PUSH
96522: LD_INT 1
96524: NEG
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: PUSH
96530: LD_INT 5
96532: PUSH
96533: LD_INT 0
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: PUSH
96540: LD_INT 5
96542: PUSH
96543: LD_INT 1
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 4
96552: PUSH
96553: LD_INT 1
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 3
96562: PUSH
96563: LD_INT 0
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 3
96572: PUSH
96573: LD_INT 1
96575: NEG
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 3
96583: PUSH
96584: LD_INT 2
96586: NEG
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PUSH
96592: LD_INT 5
96594: PUSH
96595: LD_INT 2
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96649: LD_ADDR_VAR 0 32
96653: PUSH
96654: LD_INT 4
96656: NEG
96657: PUSH
96658: LD_INT 0
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: PUSH
96665: LD_INT 4
96667: NEG
96668: PUSH
96669: LD_INT 1
96671: NEG
96672: PUSH
96673: EMPTY
96674: LIST
96675: LIST
96676: PUSH
96677: LD_INT 3
96679: NEG
96680: PUSH
96681: LD_INT 0
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 3
96690: NEG
96691: PUSH
96692: LD_INT 1
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: PUSH
96699: LD_INT 4
96701: NEG
96702: PUSH
96703: LD_INT 1
96705: PUSH
96706: EMPTY
96707: LIST
96708: LIST
96709: PUSH
96710: LD_INT 5
96712: NEG
96713: PUSH
96714: LD_INT 0
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 5
96723: NEG
96724: PUSH
96725: LD_INT 1
96727: NEG
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 5
96735: NEG
96736: PUSH
96737: LD_INT 2
96739: NEG
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 3
96747: NEG
96748: PUSH
96749: LD_INT 2
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 3
96758: NEG
96759: PUSH
96760: LD_INT 3
96762: NEG
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: PUSH
96768: LD_INT 3
96770: NEG
96771: PUSH
96772: LD_INT 4
96774: NEG
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: PUSH
96780: LD_INT 2
96782: NEG
96783: PUSH
96784: LD_INT 3
96786: NEG
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 2
96794: NEG
96795: PUSH
96796: LD_INT 2
96798: NEG
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: PUSH
96804: LD_INT 3
96806: NEG
96807: PUSH
96808: LD_INT 2
96810: NEG
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 4
96818: NEG
96819: PUSH
96820: LD_INT 3
96822: NEG
96823: PUSH
96824: EMPTY
96825: LIST
96826: LIST
96827: PUSH
96828: LD_INT 4
96830: NEG
96831: PUSH
96832: LD_INT 4
96834: NEG
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: PUSH
96840: LD_INT 2
96842: NEG
96843: PUSH
96844: LD_INT 4
96846: NEG
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 4
96854: NEG
96855: PUSH
96856: LD_INT 2
96858: NEG
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: LD_INT 0
96866: PUSH
96867: LD_INT 4
96869: NEG
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PUSH
96875: LD_INT 0
96877: PUSH
96878: LD_INT 5
96880: NEG
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 1
96888: PUSH
96889: LD_INT 4
96891: NEG
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: PUSH
96900: LD_INT 3
96902: NEG
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 0
96910: PUSH
96911: LD_INT 3
96913: NEG
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 1
96921: NEG
96922: PUSH
96923: LD_INT 4
96925: NEG
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 1
96933: NEG
96934: PUSH
96935: LD_INT 5
96937: NEG
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 2
96945: PUSH
96946: LD_INT 3
96948: NEG
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 2
96956: NEG
96957: PUSH
96958: LD_INT 5
96960: NEG
96961: PUSH
96962: EMPTY
96963: LIST
96964: LIST
96965: PUSH
96966: LD_INT 3
96968: PUSH
96969: LD_INT 0
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: LD_INT 3
96978: PUSH
96979: LD_INT 1
96981: NEG
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: PUSH
96987: LD_INT 4
96989: PUSH
96990: LD_INT 0
96992: PUSH
96993: EMPTY
96994: LIST
96995: LIST
96996: PUSH
96997: LD_INT 4
96999: PUSH
97000: LD_INT 1
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 3
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 2
97019: PUSH
97020: LD_INT 0
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 2
97029: PUSH
97030: LD_INT 1
97032: NEG
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: LD_INT 2
97040: PUSH
97041: LD_INT 2
97043: NEG
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: LD_INT 4
97051: PUSH
97052: LD_INT 2
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: LD_INT 4
97061: PUSH
97062: LD_INT 4
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: PUSH
97069: LD_INT 4
97071: PUSH
97072: LD_INT 3
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 5
97081: PUSH
97082: LD_INT 4
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: LD_INT 5
97091: PUSH
97092: LD_INT 5
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 4
97101: PUSH
97102: LD_INT 5
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PUSH
97109: LD_INT 3
97111: PUSH
97112: LD_INT 4
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 3
97121: PUSH
97122: LD_INT 3
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 5
97131: PUSH
97132: LD_INT 3
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 3
97141: PUSH
97142: LD_INT 5
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: LIST
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97196: LD_ADDR_VAR 0 33
97200: PUSH
97201: LD_INT 4
97203: NEG
97204: PUSH
97205: LD_INT 4
97207: NEG
97208: PUSH
97209: EMPTY
97210: LIST
97211: LIST
97212: PUSH
97213: LD_INT 4
97215: NEG
97216: PUSH
97217: LD_INT 5
97219: NEG
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: PUSH
97225: LD_INT 3
97227: NEG
97228: PUSH
97229: LD_INT 4
97231: NEG
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 3
97239: NEG
97240: PUSH
97241: LD_INT 3
97243: NEG
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: LD_INT 4
97251: NEG
97252: PUSH
97253: LD_INT 3
97255: NEG
97256: PUSH
97257: EMPTY
97258: LIST
97259: LIST
97260: PUSH
97261: LD_INT 5
97263: NEG
97264: PUSH
97265: LD_INT 4
97267: NEG
97268: PUSH
97269: EMPTY
97270: LIST
97271: LIST
97272: PUSH
97273: LD_INT 5
97275: NEG
97276: PUSH
97277: LD_INT 5
97279: NEG
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 3
97287: NEG
97288: PUSH
97289: LD_INT 5
97291: NEG
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 5
97299: NEG
97300: PUSH
97301: LD_INT 3
97303: NEG
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: LD_INT 0
97311: PUSH
97312: LD_INT 3
97314: NEG
97315: PUSH
97316: EMPTY
97317: LIST
97318: LIST
97319: PUSH
97320: LD_INT 0
97322: PUSH
97323: LD_INT 4
97325: NEG
97326: PUSH
97327: EMPTY
97328: LIST
97329: LIST
97330: PUSH
97331: LD_INT 1
97333: PUSH
97334: LD_INT 3
97336: NEG
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: PUSH
97342: LD_INT 1
97344: PUSH
97345: LD_INT 2
97347: NEG
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: LD_INT 0
97355: PUSH
97356: LD_INT 2
97358: NEG
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 1
97366: NEG
97367: PUSH
97368: LD_INT 3
97370: NEG
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: LD_INT 1
97378: NEG
97379: PUSH
97380: LD_INT 4
97382: NEG
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 2
97390: PUSH
97391: LD_INT 2
97393: NEG
97394: PUSH
97395: EMPTY
97396: LIST
97397: LIST
97398: PUSH
97399: LD_INT 2
97401: NEG
97402: PUSH
97403: LD_INT 4
97405: NEG
97406: PUSH
97407: EMPTY
97408: LIST
97409: LIST
97410: PUSH
97411: LD_INT 4
97413: PUSH
97414: LD_INT 0
97416: PUSH
97417: EMPTY
97418: LIST
97419: LIST
97420: PUSH
97421: LD_INT 4
97423: PUSH
97424: LD_INT 1
97426: NEG
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: PUSH
97432: LD_INT 5
97434: PUSH
97435: LD_INT 0
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 5
97444: PUSH
97445: LD_INT 1
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PUSH
97452: LD_INT 4
97454: PUSH
97455: LD_INT 1
97457: PUSH
97458: EMPTY
97459: LIST
97460: LIST
97461: PUSH
97462: LD_INT 3
97464: PUSH
97465: LD_INT 0
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PUSH
97472: LD_INT 3
97474: PUSH
97475: LD_INT 1
97477: NEG
97478: PUSH
97479: EMPTY
97480: LIST
97481: LIST
97482: PUSH
97483: LD_INT 3
97485: PUSH
97486: LD_INT 2
97488: NEG
97489: PUSH
97490: EMPTY
97491: LIST
97492: LIST
97493: PUSH
97494: LD_INT 5
97496: PUSH
97497: LD_INT 2
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PUSH
97504: LD_INT 3
97506: PUSH
97507: LD_INT 3
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PUSH
97514: LD_INT 3
97516: PUSH
97517: LD_INT 2
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 4
97526: PUSH
97527: LD_INT 3
97529: PUSH
97530: EMPTY
97531: LIST
97532: LIST
97533: PUSH
97534: LD_INT 4
97536: PUSH
97537: LD_INT 4
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: LD_INT 3
97546: PUSH
97547: LD_INT 4
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 2
97556: PUSH
97557: LD_INT 3
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 2
97566: PUSH
97567: LD_INT 2
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: PUSH
97574: LD_INT 4
97576: PUSH
97577: LD_INT 2
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: PUSH
97584: LD_INT 2
97586: PUSH
97587: LD_INT 4
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PUSH
97594: LD_INT 0
97596: PUSH
97597: LD_INT 4
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_INT 0
97606: PUSH
97607: LD_INT 3
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: PUSH
97614: LD_INT 1
97616: PUSH
97617: LD_INT 4
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PUSH
97624: LD_INT 1
97626: PUSH
97627: LD_INT 5
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: LD_INT 0
97636: PUSH
97637: LD_INT 5
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: PUSH
97644: LD_INT 1
97646: NEG
97647: PUSH
97648: LD_INT 4
97650: PUSH
97651: EMPTY
97652: LIST
97653: LIST
97654: PUSH
97655: LD_INT 1
97657: NEG
97658: PUSH
97659: LD_INT 3
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PUSH
97666: LD_INT 2
97668: PUSH
97669: LD_INT 5
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 2
97678: NEG
97679: PUSH
97680: LD_INT 3
97682: PUSH
97683: EMPTY
97684: LIST
97685: LIST
97686: PUSH
97687: EMPTY
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97734: LD_ADDR_VAR 0 34
97738: PUSH
97739: LD_INT 0
97741: PUSH
97742: LD_INT 4
97744: NEG
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: PUSH
97750: LD_INT 0
97752: PUSH
97753: LD_INT 5
97755: NEG
97756: PUSH
97757: EMPTY
97758: LIST
97759: LIST
97760: PUSH
97761: LD_INT 1
97763: PUSH
97764: LD_INT 4
97766: NEG
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: PUSH
97772: LD_INT 1
97774: PUSH
97775: LD_INT 3
97777: NEG
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PUSH
97783: LD_INT 0
97785: PUSH
97786: LD_INT 3
97788: NEG
97789: PUSH
97790: EMPTY
97791: LIST
97792: LIST
97793: PUSH
97794: LD_INT 1
97796: NEG
97797: PUSH
97798: LD_INT 4
97800: NEG
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 1
97808: NEG
97809: PUSH
97810: LD_INT 5
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 2
97820: PUSH
97821: LD_INT 3
97823: NEG
97824: PUSH
97825: EMPTY
97826: LIST
97827: LIST
97828: PUSH
97829: LD_INT 2
97831: NEG
97832: PUSH
97833: LD_INT 5
97835: NEG
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: LD_INT 3
97843: PUSH
97844: LD_INT 0
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 3
97853: PUSH
97854: LD_INT 1
97856: NEG
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 4
97864: PUSH
97865: LD_INT 0
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PUSH
97872: LD_INT 4
97874: PUSH
97875: LD_INT 1
97877: PUSH
97878: EMPTY
97879: LIST
97880: LIST
97881: PUSH
97882: LD_INT 3
97884: PUSH
97885: LD_INT 1
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: PUSH
97892: LD_INT 2
97894: PUSH
97895: LD_INT 0
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 2
97904: PUSH
97905: LD_INT 1
97907: NEG
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: PUSH
97913: LD_INT 2
97915: PUSH
97916: LD_INT 2
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 4
97926: PUSH
97927: LD_INT 2
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: LD_INT 4
97936: PUSH
97937: LD_INT 4
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: PUSH
97944: LD_INT 4
97946: PUSH
97947: LD_INT 3
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: PUSH
97954: LD_INT 5
97956: PUSH
97957: LD_INT 4
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PUSH
97964: LD_INT 5
97966: PUSH
97967: LD_INT 5
97969: PUSH
97970: EMPTY
97971: LIST
97972: LIST
97973: PUSH
97974: LD_INT 4
97976: PUSH
97977: LD_INT 5
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: LD_INT 3
97986: PUSH
97987: LD_INT 4
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: LD_INT 3
97996: PUSH
97997: LD_INT 3
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 5
98006: PUSH
98007: LD_INT 3
98009: PUSH
98010: EMPTY
98011: LIST
98012: LIST
98013: PUSH
98014: LD_INT 3
98016: PUSH
98017: LD_INT 5
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: PUSH
98024: LD_INT 0
98026: PUSH
98027: LD_INT 3
98029: PUSH
98030: EMPTY
98031: LIST
98032: LIST
98033: PUSH
98034: LD_INT 0
98036: PUSH
98037: LD_INT 2
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: LD_INT 1
98046: PUSH
98047: LD_INT 3
98049: PUSH
98050: EMPTY
98051: LIST
98052: LIST
98053: PUSH
98054: LD_INT 1
98056: PUSH
98057: LD_INT 4
98059: PUSH
98060: EMPTY
98061: LIST
98062: LIST
98063: PUSH
98064: LD_INT 0
98066: PUSH
98067: LD_INT 4
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: LD_INT 1
98076: NEG
98077: PUSH
98078: LD_INT 3
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: PUSH
98085: LD_INT 1
98087: NEG
98088: PUSH
98089: LD_INT 2
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PUSH
98096: LD_INT 2
98098: PUSH
98099: LD_INT 4
98101: PUSH
98102: EMPTY
98103: LIST
98104: LIST
98105: PUSH
98106: LD_INT 2
98108: NEG
98109: PUSH
98110: LD_INT 2
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PUSH
98117: LD_INT 4
98119: NEG
98120: PUSH
98121: LD_INT 0
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 4
98130: NEG
98131: PUSH
98132: LD_INT 1
98134: NEG
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 3
98142: NEG
98143: PUSH
98144: LD_INT 0
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 3
98153: NEG
98154: PUSH
98155: LD_INT 1
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: LD_INT 4
98164: NEG
98165: PUSH
98166: LD_INT 1
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: LD_INT 5
98175: NEG
98176: PUSH
98177: LD_INT 0
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: LD_INT 5
98186: NEG
98187: PUSH
98188: LD_INT 1
98190: NEG
98191: PUSH
98192: EMPTY
98193: LIST
98194: LIST
98195: PUSH
98196: LD_INT 5
98198: NEG
98199: PUSH
98200: LD_INT 2
98202: NEG
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: PUSH
98208: LD_INT 3
98210: NEG
98211: PUSH
98212: LD_INT 2
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: ST_TO_ADDR
// end ; end ;
98266: GO 98269
98268: POP
// case btype of b_depot , b_warehouse :
98269: LD_VAR 0 1
98273: PUSH
98274: LD_INT 0
98276: DOUBLE
98277: EQUAL
98278: IFTRUE 98288
98280: LD_INT 1
98282: DOUBLE
98283: EQUAL
98284: IFTRUE 98288
98286: GO 98489
98288: POP
// case nation of nation_american :
98289: LD_VAR 0 5
98293: PUSH
98294: LD_INT 1
98296: DOUBLE
98297: EQUAL
98298: IFTRUE 98302
98300: GO 98358
98302: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
98303: LD_ADDR_VAR 0 9
98307: PUSH
98308: LD_VAR 0 11
98312: PUSH
98313: LD_VAR 0 12
98317: PUSH
98318: LD_VAR 0 13
98322: PUSH
98323: LD_VAR 0 14
98327: PUSH
98328: LD_VAR 0 15
98332: PUSH
98333: LD_VAR 0 16
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: PUSH
98346: LD_VAR 0 4
98350: PUSH
98351: LD_INT 1
98353: PLUS
98354: ARRAY
98355: ST_TO_ADDR
98356: GO 98487
98358: LD_INT 2
98360: DOUBLE
98361: EQUAL
98362: IFTRUE 98366
98364: GO 98422
98366: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98367: LD_ADDR_VAR 0 9
98371: PUSH
98372: LD_VAR 0 17
98376: PUSH
98377: LD_VAR 0 18
98381: PUSH
98382: LD_VAR 0 19
98386: PUSH
98387: LD_VAR 0 20
98391: PUSH
98392: LD_VAR 0 21
98396: PUSH
98397: LD_VAR 0 22
98401: PUSH
98402: EMPTY
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: PUSH
98410: LD_VAR 0 4
98414: PUSH
98415: LD_INT 1
98417: PLUS
98418: ARRAY
98419: ST_TO_ADDR
98420: GO 98487
98422: LD_INT 3
98424: DOUBLE
98425: EQUAL
98426: IFTRUE 98430
98428: GO 98486
98430: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98431: LD_ADDR_VAR 0 9
98435: PUSH
98436: LD_VAR 0 23
98440: PUSH
98441: LD_VAR 0 24
98445: PUSH
98446: LD_VAR 0 25
98450: PUSH
98451: LD_VAR 0 26
98455: PUSH
98456: LD_VAR 0 27
98460: PUSH
98461: LD_VAR 0 28
98465: PUSH
98466: EMPTY
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: PUSH
98474: LD_VAR 0 4
98478: PUSH
98479: LD_INT 1
98481: PLUS
98482: ARRAY
98483: ST_TO_ADDR
98484: GO 98487
98486: POP
98487: GO 99042
98489: LD_INT 2
98491: DOUBLE
98492: EQUAL
98493: IFTRUE 98503
98495: LD_INT 3
98497: DOUBLE
98498: EQUAL
98499: IFTRUE 98503
98501: GO 98559
98503: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98504: LD_ADDR_VAR 0 9
98508: PUSH
98509: LD_VAR 0 29
98513: PUSH
98514: LD_VAR 0 30
98518: PUSH
98519: LD_VAR 0 31
98523: PUSH
98524: LD_VAR 0 32
98528: PUSH
98529: LD_VAR 0 33
98533: PUSH
98534: LD_VAR 0 34
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: PUSH
98547: LD_VAR 0 4
98551: PUSH
98552: LD_INT 1
98554: PLUS
98555: ARRAY
98556: ST_TO_ADDR
98557: GO 99042
98559: LD_INT 16
98561: DOUBLE
98562: EQUAL
98563: IFTRUE 98621
98565: LD_INT 17
98567: DOUBLE
98568: EQUAL
98569: IFTRUE 98621
98571: LD_INT 18
98573: DOUBLE
98574: EQUAL
98575: IFTRUE 98621
98577: LD_INT 19
98579: DOUBLE
98580: EQUAL
98581: IFTRUE 98621
98583: LD_INT 22
98585: DOUBLE
98586: EQUAL
98587: IFTRUE 98621
98589: LD_INT 20
98591: DOUBLE
98592: EQUAL
98593: IFTRUE 98621
98595: LD_INT 21
98597: DOUBLE
98598: EQUAL
98599: IFTRUE 98621
98601: LD_INT 23
98603: DOUBLE
98604: EQUAL
98605: IFTRUE 98621
98607: LD_INT 24
98609: DOUBLE
98610: EQUAL
98611: IFTRUE 98621
98613: LD_INT 25
98615: DOUBLE
98616: EQUAL
98617: IFTRUE 98621
98619: GO 98677
98621: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98622: LD_ADDR_VAR 0 9
98626: PUSH
98627: LD_VAR 0 35
98631: PUSH
98632: LD_VAR 0 36
98636: PUSH
98637: LD_VAR 0 37
98641: PUSH
98642: LD_VAR 0 38
98646: PUSH
98647: LD_VAR 0 39
98651: PUSH
98652: LD_VAR 0 40
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: PUSH
98665: LD_VAR 0 4
98669: PUSH
98670: LD_INT 1
98672: PLUS
98673: ARRAY
98674: ST_TO_ADDR
98675: GO 99042
98677: LD_INT 6
98679: DOUBLE
98680: EQUAL
98681: IFTRUE 98733
98683: LD_INT 7
98685: DOUBLE
98686: EQUAL
98687: IFTRUE 98733
98689: LD_INT 8
98691: DOUBLE
98692: EQUAL
98693: IFTRUE 98733
98695: LD_INT 13
98697: DOUBLE
98698: EQUAL
98699: IFTRUE 98733
98701: LD_INT 12
98703: DOUBLE
98704: EQUAL
98705: IFTRUE 98733
98707: LD_INT 15
98709: DOUBLE
98710: EQUAL
98711: IFTRUE 98733
98713: LD_INT 11
98715: DOUBLE
98716: EQUAL
98717: IFTRUE 98733
98719: LD_INT 14
98721: DOUBLE
98722: EQUAL
98723: IFTRUE 98733
98725: LD_INT 10
98727: DOUBLE
98728: EQUAL
98729: IFTRUE 98733
98731: GO 98789
98733: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98734: LD_ADDR_VAR 0 9
98738: PUSH
98739: LD_VAR 0 41
98743: PUSH
98744: LD_VAR 0 42
98748: PUSH
98749: LD_VAR 0 43
98753: PUSH
98754: LD_VAR 0 44
98758: PUSH
98759: LD_VAR 0 45
98763: PUSH
98764: LD_VAR 0 46
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: LIST
98773: LIST
98774: LIST
98775: LIST
98776: PUSH
98777: LD_VAR 0 4
98781: PUSH
98782: LD_INT 1
98784: PLUS
98785: ARRAY
98786: ST_TO_ADDR
98787: GO 99042
98789: LD_INT 36
98791: DOUBLE
98792: EQUAL
98793: IFTRUE 98797
98795: GO 98853
98797: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98798: LD_ADDR_VAR 0 9
98802: PUSH
98803: LD_VAR 0 47
98807: PUSH
98808: LD_VAR 0 48
98812: PUSH
98813: LD_VAR 0 49
98817: PUSH
98818: LD_VAR 0 50
98822: PUSH
98823: LD_VAR 0 51
98827: PUSH
98828: LD_VAR 0 52
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: PUSH
98841: LD_VAR 0 4
98845: PUSH
98846: LD_INT 1
98848: PLUS
98849: ARRAY
98850: ST_TO_ADDR
98851: GO 99042
98853: LD_INT 4
98855: DOUBLE
98856: EQUAL
98857: IFTRUE 98879
98859: LD_INT 5
98861: DOUBLE
98862: EQUAL
98863: IFTRUE 98879
98865: LD_INT 34
98867: DOUBLE
98868: EQUAL
98869: IFTRUE 98879
98871: LD_INT 37
98873: DOUBLE
98874: EQUAL
98875: IFTRUE 98879
98877: GO 98935
98879: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98880: LD_ADDR_VAR 0 9
98884: PUSH
98885: LD_VAR 0 53
98889: PUSH
98890: LD_VAR 0 54
98894: PUSH
98895: LD_VAR 0 55
98899: PUSH
98900: LD_VAR 0 56
98904: PUSH
98905: LD_VAR 0 57
98909: PUSH
98910: LD_VAR 0 58
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: PUSH
98923: LD_VAR 0 4
98927: PUSH
98928: LD_INT 1
98930: PLUS
98931: ARRAY
98932: ST_TO_ADDR
98933: GO 99042
98935: LD_INT 31
98937: DOUBLE
98938: EQUAL
98939: IFTRUE 98985
98941: LD_INT 32
98943: DOUBLE
98944: EQUAL
98945: IFTRUE 98985
98947: LD_INT 33
98949: DOUBLE
98950: EQUAL
98951: IFTRUE 98985
98953: LD_INT 27
98955: DOUBLE
98956: EQUAL
98957: IFTRUE 98985
98959: LD_INT 26
98961: DOUBLE
98962: EQUAL
98963: IFTRUE 98985
98965: LD_INT 28
98967: DOUBLE
98968: EQUAL
98969: IFTRUE 98985
98971: LD_INT 29
98973: DOUBLE
98974: EQUAL
98975: IFTRUE 98985
98977: LD_INT 30
98979: DOUBLE
98980: EQUAL
98981: IFTRUE 98985
98983: GO 99041
98985: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98986: LD_ADDR_VAR 0 9
98990: PUSH
98991: LD_VAR 0 59
98995: PUSH
98996: LD_VAR 0 60
99000: PUSH
99001: LD_VAR 0 61
99005: PUSH
99006: LD_VAR 0 62
99010: PUSH
99011: LD_VAR 0 63
99015: PUSH
99016: LD_VAR 0 64
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: PUSH
99029: LD_VAR 0 4
99033: PUSH
99034: LD_INT 1
99036: PLUS
99037: ARRAY
99038: ST_TO_ADDR
99039: GO 99042
99041: POP
// temp_list2 = [ ] ;
99042: LD_ADDR_VAR 0 10
99046: PUSH
99047: EMPTY
99048: ST_TO_ADDR
// for i in temp_list do
99049: LD_ADDR_VAR 0 8
99053: PUSH
99054: LD_VAR 0 9
99058: PUSH
99059: FOR_IN
99060: IFFALSE 99112
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99062: LD_ADDR_VAR 0 10
99066: PUSH
99067: LD_VAR 0 10
99071: PUSH
99072: LD_VAR 0 8
99076: PUSH
99077: LD_INT 1
99079: ARRAY
99080: PUSH
99081: LD_VAR 0 2
99085: PLUS
99086: PUSH
99087: LD_VAR 0 8
99091: PUSH
99092: LD_INT 2
99094: ARRAY
99095: PUSH
99096: LD_VAR 0 3
99100: PLUS
99101: PUSH
99102: EMPTY
99103: LIST
99104: LIST
99105: PUSH
99106: EMPTY
99107: LIST
99108: ADD
99109: ST_TO_ADDR
99110: GO 99059
99112: POP
99113: POP
// result = temp_list2 ;
99114: LD_ADDR_VAR 0 7
99118: PUSH
99119: LD_VAR 0 10
99123: ST_TO_ADDR
// end ;
99124: LD_VAR 0 7
99128: RET
// export function EnemyInRange ( unit , dist ) ; begin
99129: LD_INT 0
99131: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99132: LD_ADDR_VAR 0 3
99136: PUSH
99137: LD_VAR 0 1
99141: PPUSH
99142: CALL_OW 255
99146: PPUSH
99147: LD_VAR 0 1
99151: PPUSH
99152: CALL_OW 250
99156: PPUSH
99157: LD_VAR 0 1
99161: PPUSH
99162: CALL_OW 251
99166: PPUSH
99167: LD_VAR 0 2
99171: PPUSH
99172: CALL 73233 0 4
99176: PUSH
99177: LD_INT 4
99179: ARRAY
99180: ST_TO_ADDR
// end ;
99181: LD_VAR 0 3
99185: RET
// export function PlayerSeeMe ( unit ) ; begin
99186: LD_INT 0
99188: PPUSH
// result := See ( your_side , unit ) ;
99189: LD_ADDR_VAR 0 2
99193: PUSH
99194: LD_OWVAR 2
99198: PPUSH
99199: LD_VAR 0 1
99203: PPUSH
99204: CALL_OW 292
99208: ST_TO_ADDR
// end ;
99209: LD_VAR 0 2
99213: RET
// export function ReverseDir ( unit ) ; begin
99214: LD_INT 0
99216: PPUSH
// if not unit then
99217: LD_VAR 0 1
99221: NOT
99222: IFFALSE 99226
// exit ;
99224: GO 99249
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99226: LD_ADDR_VAR 0 2
99230: PUSH
99231: LD_VAR 0 1
99235: PPUSH
99236: CALL_OW 254
99240: PUSH
99241: LD_INT 3
99243: PLUS
99244: PUSH
99245: LD_INT 6
99247: MOD
99248: ST_TO_ADDR
// end ;
99249: LD_VAR 0 2
99253: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
99254: LD_INT 0
99256: PPUSH
99257: PPUSH
99258: PPUSH
99259: PPUSH
99260: PPUSH
// if not hexes then
99261: LD_VAR 0 2
99265: NOT
99266: IFFALSE 99270
// exit ;
99268: GO 99418
// dist := 9999 ;
99270: LD_ADDR_VAR 0 5
99274: PUSH
99275: LD_INT 9999
99277: ST_TO_ADDR
// for i = 1 to hexes do
99278: LD_ADDR_VAR 0 4
99282: PUSH
99283: DOUBLE
99284: LD_INT 1
99286: DEC
99287: ST_TO_ADDR
99288: LD_VAR 0 2
99292: PUSH
99293: FOR_TO
99294: IFFALSE 99406
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
99296: LD_VAR 0 1
99300: PPUSH
99301: LD_VAR 0 2
99305: PUSH
99306: LD_VAR 0 4
99310: ARRAY
99311: PUSH
99312: LD_INT 1
99314: ARRAY
99315: PPUSH
99316: LD_VAR 0 2
99320: PUSH
99321: LD_VAR 0 4
99325: ARRAY
99326: PUSH
99327: LD_INT 2
99329: ARRAY
99330: PPUSH
99331: CALL_OW 297
99335: PUSH
99336: LD_VAR 0 5
99340: LESS
99341: IFFALSE 99404
// begin hex := hexes [ i ] ;
99343: LD_ADDR_VAR 0 7
99347: PUSH
99348: LD_VAR 0 2
99352: PUSH
99353: LD_VAR 0 4
99357: ARRAY
99358: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99359: LD_ADDR_VAR 0 5
99363: PUSH
99364: LD_VAR 0 1
99368: PPUSH
99369: LD_VAR 0 2
99373: PUSH
99374: LD_VAR 0 4
99378: ARRAY
99379: PUSH
99380: LD_INT 1
99382: ARRAY
99383: PPUSH
99384: LD_VAR 0 2
99388: PUSH
99389: LD_VAR 0 4
99393: ARRAY
99394: PUSH
99395: LD_INT 2
99397: ARRAY
99398: PPUSH
99399: CALL_OW 297
99403: ST_TO_ADDR
// end ; end ;
99404: GO 99293
99406: POP
99407: POP
// result := hex ;
99408: LD_ADDR_VAR 0 3
99412: PUSH
99413: LD_VAR 0 7
99417: ST_TO_ADDR
// end ;
99418: LD_VAR 0 3
99422: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99423: LD_INT 0
99425: PPUSH
99426: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99427: LD_VAR 0 1
99431: NOT
99432: PUSH
99433: LD_VAR 0 1
99437: PUSH
99438: LD_INT 21
99440: PUSH
99441: LD_INT 2
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PUSH
99448: LD_INT 23
99450: PUSH
99451: LD_INT 2
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: PPUSH
99462: CALL_OW 69
99466: IN
99467: NOT
99468: OR
99469: IFFALSE 99473
// exit ;
99471: GO 99520
// for i = 1 to 3 do
99473: LD_ADDR_VAR 0 3
99477: PUSH
99478: DOUBLE
99479: LD_INT 1
99481: DEC
99482: ST_TO_ADDR
99483: LD_INT 3
99485: PUSH
99486: FOR_TO
99487: IFFALSE 99518
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99489: LD_VAR 0 1
99493: PPUSH
99494: CALL_OW 250
99498: PPUSH
99499: LD_VAR 0 1
99503: PPUSH
99504: CALL_OW 251
99508: PPUSH
99509: LD_INT 1
99511: PPUSH
99512: CALL_OW 453
99516: GO 99486
99518: POP
99519: POP
// end ;
99520: LD_VAR 0 2
99524: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99525: LD_INT 0
99527: PPUSH
99528: PPUSH
99529: PPUSH
99530: PPUSH
99531: PPUSH
99532: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99533: LD_VAR 0 1
99537: NOT
99538: PUSH
99539: LD_VAR 0 2
99543: NOT
99544: OR
99545: PUSH
99546: LD_VAR 0 1
99550: PPUSH
99551: CALL_OW 314
99555: OR
99556: IFFALSE 99560
// exit ;
99558: GO 100001
// x := GetX ( enemy_unit ) ;
99560: LD_ADDR_VAR 0 7
99564: PUSH
99565: LD_VAR 0 2
99569: PPUSH
99570: CALL_OW 250
99574: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99575: LD_ADDR_VAR 0 8
99579: PUSH
99580: LD_VAR 0 2
99584: PPUSH
99585: CALL_OW 251
99589: ST_TO_ADDR
// if not x or not y then
99590: LD_VAR 0 7
99594: NOT
99595: PUSH
99596: LD_VAR 0 8
99600: NOT
99601: OR
99602: IFFALSE 99606
// exit ;
99604: GO 100001
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99606: LD_ADDR_VAR 0 6
99610: PUSH
99611: LD_VAR 0 7
99615: PPUSH
99616: LD_INT 0
99618: PPUSH
99619: LD_INT 4
99621: PPUSH
99622: CALL_OW 272
99626: PUSH
99627: LD_VAR 0 8
99631: PPUSH
99632: LD_INT 0
99634: PPUSH
99635: LD_INT 4
99637: PPUSH
99638: CALL_OW 273
99642: PUSH
99643: EMPTY
99644: LIST
99645: LIST
99646: PUSH
99647: LD_VAR 0 7
99651: PPUSH
99652: LD_INT 1
99654: PPUSH
99655: LD_INT 4
99657: PPUSH
99658: CALL_OW 272
99662: PUSH
99663: LD_VAR 0 8
99667: PPUSH
99668: LD_INT 1
99670: PPUSH
99671: LD_INT 4
99673: PPUSH
99674: CALL_OW 273
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PUSH
99683: LD_VAR 0 7
99687: PPUSH
99688: LD_INT 2
99690: PPUSH
99691: LD_INT 4
99693: PPUSH
99694: CALL_OW 272
99698: PUSH
99699: LD_VAR 0 8
99703: PPUSH
99704: LD_INT 2
99706: PPUSH
99707: LD_INT 4
99709: PPUSH
99710: CALL_OW 273
99714: PUSH
99715: EMPTY
99716: LIST
99717: LIST
99718: PUSH
99719: LD_VAR 0 7
99723: PPUSH
99724: LD_INT 3
99726: PPUSH
99727: LD_INT 4
99729: PPUSH
99730: CALL_OW 272
99734: PUSH
99735: LD_VAR 0 8
99739: PPUSH
99740: LD_INT 3
99742: PPUSH
99743: LD_INT 4
99745: PPUSH
99746: CALL_OW 273
99750: PUSH
99751: EMPTY
99752: LIST
99753: LIST
99754: PUSH
99755: LD_VAR 0 7
99759: PPUSH
99760: LD_INT 4
99762: PPUSH
99763: LD_INT 4
99765: PPUSH
99766: CALL_OW 272
99770: PUSH
99771: LD_VAR 0 8
99775: PPUSH
99776: LD_INT 4
99778: PPUSH
99779: LD_INT 4
99781: PPUSH
99782: CALL_OW 273
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_VAR 0 7
99795: PPUSH
99796: LD_INT 5
99798: PPUSH
99799: LD_INT 4
99801: PPUSH
99802: CALL_OW 272
99806: PUSH
99807: LD_VAR 0 8
99811: PPUSH
99812: LD_INT 5
99814: PPUSH
99815: LD_INT 4
99817: PPUSH
99818: CALL_OW 273
99822: PUSH
99823: EMPTY
99824: LIST
99825: LIST
99826: PUSH
99827: EMPTY
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: ST_TO_ADDR
// for i = tmp downto 1 do
99835: LD_ADDR_VAR 0 4
99839: PUSH
99840: DOUBLE
99841: LD_VAR 0 6
99845: INC
99846: ST_TO_ADDR
99847: LD_INT 1
99849: PUSH
99850: FOR_DOWNTO
99851: IFFALSE 99952
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99853: LD_VAR 0 6
99857: PUSH
99858: LD_VAR 0 4
99862: ARRAY
99863: PUSH
99864: LD_INT 1
99866: ARRAY
99867: PPUSH
99868: LD_VAR 0 6
99872: PUSH
99873: LD_VAR 0 4
99877: ARRAY
99878: PUSH
99879: LD_INT 2
99881: ARRAY
99882: PPUSH
99883: CALL_OW 488
99887: NOT
99888: PUSH
99889: LD_VAR 0 6
99893: PUSH
99894: LD_VAR 0 4
99898: ARRAY
99899: PUSH
99900: LD_INT 1
99902: ARRAY
99903: PPUSH
99904: LD_VAR 0 6
99908: PUSH
99909: LD_VAR 0 4
99913: ARRAY
99914: PUSH
99915: LD_INT 2
99917: ARRAY
99918: PPUSH
99919: CALL_OW 428
99923: PUSH
99924: LD_INT 0
99926: NONEQUAL
99927: OR
99928: IFFALSE 99950
// tmp := Delete ( tmp , i ) ;
99930: LD_ADDR_VAR 0 6
99934: PUSH
99935: LD_VAR 0 6
99939: PPUSH
99940: LD_VAR 0 4
99944: PPUSH
99945: CALL_OW 3
99949: ST_TO_ADDR
99950: GO 99850
99952: POP
99953: POP
// j := GetClosestHex ( unit , tmp ) ;
99954: LD_ADDR_VAR 0 5
99958: PUSH
99959: LD_VAR 0 1
99963: PPUSH
99964: LD_VAR 0 6
99968: PPUSH
99969: CALL 99254 0 2
99973: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99974: LD_VAR 0 1
99978: PPUSH
99979: LD_VAR 0 5
99983: PUSH
99984: LD_INT 1
99986: ARRAY
99987: PPUSH
99988: LD_VAR 0 5
99992: PUSH
99993: LD_INT 2
99995: ARRAY
99996: PPUSH
99997: CALL_OW 111
// end ;
100001: LD_VAR 0 3
100005: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
100006: LD_INT 0
100008: PPUSH
100009: PPUSH
100010: PPUSH
// uc_side = 0 ;
100011: LD_ADDR_OWVAR 20
100015: PUSH
100016: LD_INT 0
100018: ST_TO_ADDR
// uc_nation = 0 ;
100019: LD_ADDR_OWVAR 21
100023: PUSH
100024: LD_INT 0
100026: ST_TO_ADDR
// InitHc ;
100027: CALL_OW 19
// InitVc ;
100031: CALL_OW 20
// if mastodonts then
100035: LD_VAR 0 6
100039: IFFALSE 100106
// for i = 1 to mastodonts do
100041: LD_ADDR_VAR 0 11
100045: PUSH
100046: DOUBLE
100047: LD_INT 1
100049: DEC
100050: ST_TO_ADDR
100051: LD_VAR 0 6
100055: PUSH
100056: FOR_TO
100057: IFFALSE 100104
// begin vc_chassis := 31 ;
100059: LD_ADDR_OWVAR 37
100063: PUSH
100064: LD_INT 31
100066: ST_TO_ADDR
// vc_control := control_rider ;
100067: LD_ADDR_OWVAR 38
100071: PUSH
100072: LD_INT 4
100074: ST_TO_ADDR
// animal := CreateVehicle ;
100075: LD_ADDR_VAR 0 12
100079: PUSH
100080: CALL_OW 45
100084: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100085: LD_VAR 0 12
100089: PPUSH
100090: LD_VAR 0 8
100094: PPUSH
100095: LD_INT 0
100097: PPUSH
100098: CALL 106884 0 3
// end ;
100102: GO 100056
100104: POP
100105: POP
// if horses then
100106: LD_VAR 0 5
100110: IFFALSE 100177
// for i = 1 to horses do
100112: LD_ADDR_VAR 0 11
100116: PUSH
100117: DOUBLE
100118: LD_INT 1
100120: DEC
100121: ST_TO_ADDR
100122: LD_VAR 0 5
100126: PUSH
100127: FOR_TO
100128: IFFALSE 100175
// begin hc_class := 21 ;
100130: LD_ADDR_OWVAR 28
100134: PUSH
100135: LD_INT 21
100137: ST_TO_ADDR
// hc_gallery :=  ;
100138: LD_ADDR_OWVAR 33
100142: PUSH
100143: LD_STRING 
100145: ST_TO_ADDR
// animal := CreateHuman ;
100146: LD_ADDR_VAR 0 12
100150: PUSH
100151: CALL_OW 44
100155: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100156: LD_VAR 0 12
100160: PPUSH
100161: LD_VAR 0 8
100165: PPUSH
100166: LD_INT 0
100168: PPUSH
100169: CALL 106884 0 3
// end ;
100173: GO 100127
100175: POP
100176: POP
// if birds then
100177: LD_VAR 0 1
100181: IFFALSE 100248
// for i = 1 to birds do
100183: LD_ADDR_VAR 0 11
100187: PUSH
100188: DOUBLE
100189: LD_INT 1
100191: DEC
100192: ST_TO_ADDR
100193: LD_VAR 0 1
100197: PUSH
100198: FOR_TO
100199: IFFALSE 100246
// begin hc_class = 18 ;
100201: LD_ADDR_OWVAR 28
100205: PUSH
100206: LD_INT 18
100208: ST_TO_ADDR
// hc_gallery =  ;
100209: LD_ADDR_OWVAR 33
100213: PUSH
100214: LD_STRING 
100216: ST_TO_ADDR
// animal := CreateHuman ;
100217: LD_ADDR_VAR 0 12
100221: PUSH
100222: CALL_OW 44
100226: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100227: LD_VAR 0 12
100231: PPUSH
100232: LD_VAR 0 8
100236: PPUSH
100237: LD_INT 0
100239: PPUSH
100240: CALL 106884 0 3
// end ;
100244: GO 100198
100246: POP
100247: POP
// if tigers then
100248: LD_VAR 0 2
100252: IFFALSE 100336
// for i = 1 to tigers do
100254: LD_ADDR_VAR 0 11
100258: PUSH
100259: DOUBLE
100260: LD_INT 1
100262: DEC
100263: ST_TO_ADDR
100264: LD_VAR 0 2
100268: PUSH
100269: FOR_TO
100270: IFFALSE 100334
// begin hc_class = class_tiger ;
100272: LD_ADDR_OWVAR 28
100276: PUSH
100277: LD_INT 14
100279: ST_TO_ADDR
// hc_gallery =  ;
100280: LD_ADDR_OWVAR 33
100284: PUSH
100285: LD_STRING 
100287: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100288: LD_ADDR_OWVAR 35
100292: PUSH
100293: LD_INT 7
100295: NEG
100296: PPUSH
100297: LD_INT 7
100299: PPUSH
100300: CALL_OW 12
100304: ST_TO_ADDR
// animal := CreateHuman ;
100305: LD_ADDR_VAR 0 12
100309: PUSH
100310: CALL_OW 44
100314: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100315: LD_VAR 0 12
100319: PPUSH
100320: LD_VAR 0 8
100324: PPUSH
100325: LD_INT 0
100327: PPUSH
100328: CALL 106884 0 3
// end ;
100332: GO 100269
100334: POP
100335: POP
// if apemans then
100336: LD_VAR 0 3
100340: IFFALSE 100463
// for i = 1 to apemans do
100342: LD_ADDR_VAR 0 11
100346: PUSH
100347: DOUBLE
100348: LD_INT 1
100350: DEC
100351: ST_TO_ADDR
100352: LD_VAR 0 3
100356: PUSH
100357: FOR_TO
100358: IFFALSE 100461
// begin hc_class = class_apeman ;
100360: LD_ADDR_OWVAR 28
100364: PUSH
100365: LD_INT 12
100367: ST_TO_ADDR
// hc_gallery =  ;
100368: LD_ADDR_OWVAR 33
100372: PUSH
100373: LD_STRING 
100375: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100376: LD_ADDR_OWVAR 35
100380: PUSH
100381: LD_INT 5
100383: NEG
100384: PPUSH
100385: LD_INT 5
100387: PPUSH
100388: CALL_OW 12
100392: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100393: LD_ADDR_OWVAR 31
100397: PUSH
100398: LD_INT 1
100400: PPUSH
100401: LD_INT 3
100403: PPUSH
100404: CALL_OW 12
100408: PUSH
100409: LD_INT 1
100411: PPUSH
100412: LD_INT 3
100414: PPUSH
100415: CALL_OW 12
100419: PUSH
100420: LD_INT 0
100422: PUSH
100423: LD_INT 0
100425: PUSH
100426: EMPTY
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: ST_TO_ADDR
// animal := CreateHuman ;
100432: LD_ADDR_VAR 0 12
100436: PUSH
100437: CALL_OW 44
100441: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100442: LD_VAR 0 12
100446: PPUSH
100447: LD_VAR 0 8
100451: PPUSH
100452: LD_INT 0
100454: PPUSH
100455: CALL 106884 0 3
// end ;
100459: GO 100357
100461: POP
100462: POP
// if enchidnas then
100463: LD_VAR 0 4
100467: IFFALSE 100534
// for i = 1 to enchidnas do
100469: LD_ADDR_VAR 0 11
100473: PUSH
100474: DOUBLE
100475: LD_INT 1
100477: DEC
100478: ST_TO_ADDR
100479: LD_VAR 0 4
100483: PUSH
100484: FOR_TO
100485: IFFALSE 100532
// begin hc_class = 13 ;
100487: LD_ADDR_OWVAR 28
100491: PUSH
100492: LD_INT 13
100494: ST_TO_ADDR
// hc_gallery =  ;
100495: LD_ADDR_OWVAR 33
100499: PUSH
100500: LD_STRING 
100502: ST_TO_ADDR
// animal := CreateHuman ;
100503: LD_ADDR_VAR 0 12
100507: PUSH
100508: CALL_OW 44
100512: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100513: LD_VAR 0 12
100517: PPUSH
100518: LD_VAR 0 8
100522: PPUSH
100523: LD_INT 0
100525: PPUSH
100526: CALL 106884 0 3
// end ;
100530: GO 100484
100532: POP
100533: POP
// if fishes then
100534: LD_VAR 0 7
100538: IFFALSE 100605
// for i = 1 to fishes do
100540: LD_ADDR_VAR 0 11
100544: PUSH
100545: DOUBLE
100546: LD_INT 1
100548: DEC
100549: ST_TO_ADDR
100550: LD_VAR 0 7
100554: PUSH
100555: FOR_TO
100556: IFFALSE 100603
// begin hc_class = 20 ;
100558: LD_ADDR_OWVAR 28
100562: PUSH
100563: LD_INT 20
100565: ST_TO_ADDR
// hc_gallery =  ;
100566: LD_ADDR_OWVAR 33
100570: PUSH
100571: LD_STRING 
100573: ST_TO_ADDR
// animal := CreateHuman ;
100574: LD_ADDR_VAR 0 12
100578: PUSH
100579: CALL_OW 44
100583: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100584: LD_VAR 0 12
100588: PPUSH
100589: LD_VAR 0 9
100593: PPUSH
100594: LD_INT 0
100596: PPUSH
100597: CALL 106884 0 3
// end ;
100601: GO 100555
100603: POP
100604: POP
// end ;
100605: LD_VAR 0 10
100609: RET
// export function WantHeal ( sci , unit ) ; begin
100610: LD_INT 0
100612: PPUSH
// if GetTaskList ( sci ) > 0 then
100613: LD_VAR 0 1
100617: PPUSH
100618: CALL_OW 437
100622: PUSH
100623: LD_INT 0
100625: GREATER
100626: IFFALSE 100696
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100628: LD_VAR 0 1
100632: PPUSH
100633: CALL_OW 437
100637: PUSH
100638: LD_INT 1
100640: ARRAY
100641: PUSH
100642: LD_INT 1
100644: ARRAY
100645: PUSH
100646: LD_STRING l
100648: EQUAL
100649: PUSH
100650: LD_VAR 0 1
100654: PPUSH
100655: CALL_OW 437
100659: PUSH
100660: LD_INT 1
100662: ARRAY
100663: PUSH
100664: LD_INT 4
100666: ARRAY
100667: PUSH
100668: LD_VAR 0 2
100672: EQUAL
100673: AND
100674: IFFALSE 100686
// result := true else
100676: LD_ADDR_VAR 0 3
100680: PUSH
100681: LD_INT 1
100683: ST_TO_ADDR
100684: GO 100694
// result := false ;
100686: LD_ADDR_VAR 0 3
100690: PUSH
100691: LD_INT 0
100693: ST_TO_ADDR
// end else
100694: GO 100704
// result := false ;
100696: LD_ADDR_VAR 0 3
100700: PUSH
100701: LD_INT 0
100703: ST_TO_ADDR
// end ;
100704: LD_VAR 0 3
100708: RET
// export function HealTarget ( sci ) ; begin
100709: LD_INT 0
100711: PPUSH
// if not sci then
100712: LD_VAR 0 1
100716: NOT
100717: IFFALSE 100721
// exit ;
100719: GO 100786
// result := 0 ;
100721: LD_ADDR_VAR 0 2
100725: PUSH
100726: LD_INT 0
100728: ST_TO_ADDR
// if GetTaskList ( sci ) then
100729: LD_VAR 0 1
100733: PPUSH
100734: CALL_OW 437
100738: IFFALSE 100786
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100740: LD_VAR 0 1
100744: PPUSH
100745: CALL_OW 437
100749: PUSH
100750: LD_INT 1
100752: ARRAY
100753: PUSH
100754: LD_INT 1
100756: ARRAY
100757: PUSH
100758: LD_STRING l
100760: EQUAL
100761: IFFALSE 100786
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100763: LD_ADDR_VAR 0 2
100767: PUSH
100768: LD_VAR 0 1
100772: PPUSH
100773: CALL_OW 437
100777: PUSH
100778: LD_INT 1
100780: ARRAY
100781: PUSH
100782: LD_INT 4
100784: ARRAY
100785: ST_TO_ADDR
// end ;
100786: LD_VAR 0 2
100790: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100791: LD_INT 0
100793: PPUSH
100794: PPUSH
100795: PPUSH
100796: PPUSH
100797: PPUSH
100798: PPUSH
100799: PPUSH
100800: PPUSH
100801: PPUSH
100802: PPUSH
100803: PPUSH
100804: PPUSH
100805: PPUSH
100806: PPUSH
100807: PPUSH
100808: PPUSH
100809: PPUSH
100810: PPUSH
100811: PPUSH
100812: PPUSH
100813: PPUSH
100814: PPUSH
100815: PPUSH
100816: PPUSH
100817: PPUSH
100818: PPUSH
100819: PPUSH
100820: PPUSH
100821: PPUSH
100822: PPUSH
100823: PPUSH
100824: PPUSH
100825: PPUSH
100826: PPUSH
// if not list then
100827: LD_VAR 0 1
100831: NOT
100832: IFFALSE 100836
// exit ;
100834: GO 105495
// base := list [ 1 ] ;
100836: LD_ADDR_VAR 0 3
100840: PUSH
100841: LD_VAR 0 1
100845: PUSH
100846: LD_INT 1
100848: ARRAY
100849: ST_TO_ADDR
// group := list [ 2 ] ;
100850: LD_ADDR_VAR 0 4
100854: PUSH
100855: LD_VAR 0 1
100859: PUSH
100860: LD_INT 2
100862: ARRAY
100863: ST_TO_ADDR
// path := list [ 3 ] ;
100864: LD_ADDR_VAR 0 5
100868: PUSH
100869: LD_VAR 0 1
100873: PUSH
100874: LD_INT 3
100876: ARRAY
100877: ST_TO_ADDR
// flags := list [ 4 ] ;
100878: LD_ADDR_VAR 0 6
100882: PUSH
100883: LD_VAR 0 1
100887: PUSH
100888: LD_INT 4
100890: ARRAY
100891: ST_TO_ADDR
// mined := [ ] ;
100892: LD_ADDR_VAR 0 27
100896: PUSH
100897: EMPTY
100898: ST_TO_ADDR
// bombed := [ ] ;
100899: LD_ADDR_VAR 0 28
100903: PUSH
100904: EMPTY
100905: ST_TO_ADDR
// healers := [ ] ;
100906: LD_ADDR_VAR 0 31
100910: PUSH
100911: EMPTY
100912: ST_TO_ADDR
// to_heal := [ ] ;
100913: LD_ADDR_VAR 0 30
100917: PUSH
100918: EMPTY
100919: ST_TO_ADDR
// repairs := [ ] ;
100920: LD_ADDR_VAR 0 33
100924: PUSH
100925: EMPTY
100926: ST_TO_ADDR
// to_repair := [ ] ;
100927: LD_ADDR_VAR 0 32
100931: PUSH
100932: EMPTY
100933: ST_TO_ADDR
// if not group or not path then
100934: LD_VAR 0 4
100938: NOT
100939: PUSH
100940: LD_VAR 0 5
100944: NOT
100945: OR
100946: IFFALSE 100950
// exit ;
100948: GO 105495
// side := GetSide ( group [ 1 ] ) ;
100950: LD_ADDR_VAR 0 35
100954: PUSH
100955: LD_VAR 0 4
100959: PUSH
100960: LD_INT 1
100962: ARRAY
100963: PPUSH
100964: CALL_OW 255
100968: ST_TO_ADDR
// if flags then
100969: LD_VAR 0 6
100973: IFFALSE 101117
// begin f_ignore_area := flags [ 1 ] ;
100975: LD_ADDR_VAR 0 17
100979: PUSH
100980: LD_VAR 0 6
100984: PUSH
100985: LD_INT 1
100987: ARRAY
100988: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100989: LD_ADDR_VAR 0 18
100993: PUSH
100994: LD_VAR 0 6
100998: PUSH
100999: LD_INT 2
101001: ARRAY
101002: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
101003: LD_ADDR_VAR 0 19
101007: PUSH
101008: LD_VAR 0 6
101012: PUSH
101013: LD_INT 3
101015: ARRAY
101016: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
101017: LD_ADDR_VAR 0 20
101021: PUSH
101022: LD_VAR 0 6
101026: PUSH
101027: LD_INT 4
101029: ARRAY
101030: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
101031: LD_ADDR_VAR 0 21
101035: PUSH
101036: LD_VAR 0 6
101040: PUSH
101041: LD_INT 5
101043: ARRAY
101044: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
101045: LD_ADDR_VAR 0 22
101049: PUSH
101050: LD_VAR 0 6
101054: PUSH
101055: LD_INT 6
101057: ARRAY
101058: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
101059: LD_ADDR_VAR 0 23
101063: PUSH
101064: LD_VAR 0 6
101068: PUSH
101069: LD_INT 7
101071: ARRAY
101072: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
101073: LD_ADDR_VAR 0 24
101077: PUSH
101078: LD_VAR 0 6
101082: PUSH
101083: LD_INT 8
101085: ARRAY
101086: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
101087: LD_ADDR_VAR 0 25
101091: PUSH
101092: LD_VAR 0 6
101096: PUSH
101097: LD_INT 9
101099: ARRAY
101100: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
101101: LD_ADDR_VAR 0 26
101105: PUSH
101106: LD_VAR 0 6
101110: PUSH
101111: LD_INT 10
101113: ARRAY
101114: ST_TO_ADDR
// end else
101115: GO 101197
// begin f_ignore_area := false ;
101117: LD_ADDR_VAR 0 17
101121: PUSH
101122: LD_INT 0
101124: ST_TO_ADDR
// f_capture := false ;
101125: LD_ADDR_VAR 0 18
101129: PUSH
101130: LD_INT 0
101132: ST_TO_ADDR
// f_ignore_civ := false ;
101133: LD_ADDR_VAR 0 19
101137: PUSH
101138: LD_INT 0
101140: ST_TO_ADDR
// f_murder := false ;
101141: LD_ADDR_VAR 0 20
101145: PUSH
101146: LD_INT 0
101148: ST_TO_ADDR
// f_mines := false ;
101149: LD_ADDR_VAR 0 21
101153: PUSH
101154: LD_INT 0
101156: ST_TO_ADDR
// f_repair := false ;
101157: LD_ADDR_VAR 0 22
101161: PUSH
101162: LD_INT 0
101164: ST_TO_ADDR
// f_heal := false ;
101165: LD_ADDR_VAR 0 23
101169: PUSH
101170: LD_INT 0
101172: ST_TO_ADDR
// f_spacetime := false ;
101173: LD_ADDR_VAR 0 24
101177: PUSH
101178: LD_INT 0
101180: ST_TO_ADDR
// f_attack_depot := false ;
101181: LD_ADDR_VAR 0 25
101185: PUSH
101186: LD_INT 0
101188: ST_TO_ADDR
// f_crawl := false ;
101189: LD_ADDR_VAR 0 26
101193: PUSH
101194: LD_INT 0
101196: ST_TO_ADDR
// end ; if f_heal then
101197: LD_VAR 0 23
101201: IFFALSE 101228
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101203: LD_ADDR_VAR 0 31
101207: PUSH
101208: LD_VAR 0 4
101212: PPUSH
101213: LD_INT 25
101215: PUSH
101216: LD_INT 4
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PPUSH
101223: CALL_OW 72
101227: ST_TO_ADDR
// if f_repair then
101228: LD_VAR 0 22
101232: IFFALSE 101259
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101234: LD_ADDR_VAR 0 33
101238: PUSH
101239: LD_VAR 0 4
101243: PPUSH
101244: LD_INT 25
101246: PUSH
101247: LD_INT 3
101249: PUSH
101250: EMPTY
101251: LIST
101252: LIST
101253: PPUSH
101254: CALL_OW 72
101258: ST_TO_ADDR
// units_path := [ ] ;
101259: LD_ADDR_VAR 0 16
101263: PUSH
101264: EMPTY
101265: ST_TO_ADDR
// for i = 1 to group do
101266: LD_ADDR_VAR 0 7
101270: PUSH
101271: DOUBLE
101272: LD_INT 1
101274: DEC
101275: ST_TO_ADDR
101276: LD_VAR 0 4
101280: PUSH
101281: FOR_TO
101282: IFFALSE 101311
// units_path := Replace ( units_path , i , path ) ;
101284: LD_ADDR_VAR 0 16
101288: PUSH
101289: LD_VAR 0 16
101293: PPUSH
101294: LD_VAR 0 7
101298: PPUSH
101299: LD_VAR 0 5
101303: PPUSH
101304: CALL_OW 1
101308: ST_TO_ADDR
101309: GO 101281
101311: POP
101312: POP
// repeat for i = group downto 1 do
101313: LD_ADDR_VAR 0 7
101317: PUSH
101318: DOUBLE
101319: LD_VAR 0 4
101323: INC
101324: ST_TO_ADDR
101325: LD_INT 1
101327: PUSH
101328: FOR_DOWNTO
101329: IFFALSE 105451
// begin wait ( 5 ) ;
101331: LD_INT 5
101333: PPUSH
101334: CALL_OW 67
// tmp := [ ] ;
101338: LD_ADDR_VAR 0 14
101342: PUSH
101343: EMPTY
101344: ST_TO_ADDR
// attacking := false ;
101345: LD_ADDR_VAR 0 29
101349: PUSH
101350: LD_INT 0
101352: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101353: LD_VAR 0 4
101357: PUSH
101358: LD_VAR 0 7
101362: ARRAY
101363: PPUSH
101364: CALL_OW 301
101368: PUSH
101369: LD_VAR 0 4
101373: PUSH
101374: LD_VAR 0 7
101378: ARRAY
101379: NOT
101380: OR
101381: IFFALSE 101490
// begin if GetType ( group [ i ] ) = unit_human then
101383: LD_VAR 0 4
101387: PUSH
101388: LD_VAR 0 7
101392: ARRAY
101393: PPUSH
101394: CALL_OW 247
101398: PUSH
101399: LD_INT 1
101401: EQUAL
101402: IFFALSE 101448
// begin to_heal := to_heal diff group [ i ] ;
101404: LD_ADDR_VAR 0 30
101408: PUSH
101409: LD_VAR 0 30
101413: PUSH
101414: LD_VAR 0 4
101418: PUSH
101419: LD_VAR 0 7
101423: ARRAY
101424: DIFF
101425: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101426: LD_ADDR_VAR 0 31
101430: PUSH
101431: LD_VAR 0 31
101435: PUSH
101436: LD_VAR 0 4
101440: PUSH
101441: LD_VAR 0 7
101445: ARRAY
101446: DIFF
101447: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101448: LD_ADDR_VAR 0 4
101452: PUSH
101453: LD_VAR 0 4
101457: PPUSH
101458: LD_VAR 0 7
101462: PPUSH
101463: CALL_OW 3
101467: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101468: LD_ADDR_VAR 0 16
101472: PUSH
101473: LD_VAR 0 16
101477: PPUSH
101478: LD_VAR 0 7
101482: PPUSH
101483: CALL_OW 3
101487: ST_TO_ADDR
// continue ;
101488: GO 101328
// end ; if f_repair then
101490: LD_VAR 0 22
101494: IFFALSE 101983
// begin if GetType ( group [ i ] ) = unit_vehicle then
101496: LD_VAR 0 4
101500: PUSH
101501: LD_VAR 0 7
101505: ARRAY
101506: PPUSH
101507: CALL_OW 247
101511: PUSH
101512: LD_INT 2
101514: EQUAL
101515: IFFALSE 101705
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101517: LD_VAR 0 4
101521: PUSH
101522: LD_VAR 0 7
101526: ARRAY
101527: PPUSH
101528: CALL_OW 256
101532: PUSH
101533: LD_INT 700
101535: LESS
101536: PUSH
101537: LD_VAR 0 4
101541: PUSH
101542: LD_VAR 0 7
101546: ARRAY
101547: PUSH
101548: LD_VAR 0 32
101552: IN
101553: NOT
101554: AND
101555: IFFALSE 101579
// to_repair := to_repair union group [ i ] ;
101557: LD_ADDR_VAR 0 32
101561: PUSH
101562: LD_VAR 0 32
101566: PUSH
101567: LD_VAR 0 4
101571: PUSH
101572: LD_VAR 0 7
101576: ARRAY
101577: UNION
101578: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101579: LD_VAR 0 4
101583: PUSH
101584: LD_VAR 0 7
101588: ARRAY
101589: PPUSH
101590: CALL_OW 256
101594: PUSH
101595: LD_INT 1000
101597: EQUAL
101598: PUSH
101599: LD_VAR 0 4
101603: PUSH
101604: LD_VAR 0 7
101608: ARRAY
101609: PUSH
101610: LD_VAR 0 32
101614: IN
101615: AND
101616: IFFALSE 101640
// to_repair := to_repair diff group [ i ] ;
101618: LD_ADDR_VAR 0 32
101622: PUSH
101623: LD_VAR 0 32
101627: PUSH
101628: LD_VAR 0 4
101632: PUSH
101633: LD_VAR 0 7
101637: ARRAY
101638: DIFF
101639: ST_TO_ADDR
// if group [ i ] in to_repair then
101640: LD_VAR 0 4
101644: PUSH
101645: LD_VAR 0 7
101649: ARRAY
101650: PUSH
101651: LD_VAR 0 32
101655: IN
101656: IFFALSE 101703
// begin if not IsInArea ( group [ i ] , f_repair ) then
101658: LD_VAR 0 4
101662: PUSH
101663: LD_VAR 0 7
101667: ARRAY
101668: PPUSH
101669: LD_VAR 0 22
101673: PPUSH
101674: CALL_OW 308
101678: NOT
101679: IFFALSE 101701
// ComMoveToArea ( group [ i ] , f_repair ) ;
101681: LD_VAR 0 4
101685: PUSH
101686: LD_VAR 0 7
101690: ARRAY
101691: PPUSH
101692: LD_VAR 0 22
101696: PPUSH
101697: CALL_OW 113
// continue ;
101701: GO 101328
// end ; end else
101703: GO 101983
// if group [ i ] in repairs then
101705: LD_VAR 0 4
101709: PUSH
101710: LD_VAR 0 7
101714: ARRAY
101715: PUSH
101716: LD_VAR 0 33
101720: IN
101721: IFFALSE 101983
// begin if IsInUnit ( group [ i ] ) then
101723: LD_VAR 0 4
101727: PUSH
101728: LD_VAR 0 7
101732: ARRAY
101733: PPUSH
101734: CALL_OW 310
101738: IFFALSE 101806
// begin z := IsInUnit ( group [ i ] ) ;
101740: LD_ADDR_VAR 0 13
101744: PUSH
101745: LD_VAR 0 4
101749: PUSH
101750: LD_VAR 0 7
101754: ARRAY
101755: PPUSH
101756: CALL_OW 310
101760: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101761: LD_VAR 0 13
101765: PUSH
101766: LD_VAR 0 32
101770: IN
101771: PUSH
101772: LD_VAR 0 13
101776: PPUSH
101777: LD_VAR 0 22
101781: PPUSH
101782: CALL_OW 308
101786: AND
101787: IFFALSE 101804
// ComExitVehicle ( group [ i ] ) ;
101789: LD_VAR 0 4
101793: PUSH
101794: LD_VAR 0 7
101798: ARRAY
101799: PPUSH
101800: CALL_OW 121
// end else
101804: GO 101983
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101806: LD_ADDR_VAR 0 13
101810: PUSH
101811: LD_VAR 0 4
101815: PPUSH
101816: LD_INT 95
101818: PUSH
101819: LD_VAR 0 22
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: LD_INT 58
101830: PUSH
101831: EMPTY
101832: LIST
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PPUSH
101838: CALL_OW 72
101842: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101843: LD_VAR 0 4
101847: PUSH
101848: LD_VAR 0 7
101852: ARRAY
101853: PPUSH
101854: CALL_OW 314
101858: NOT
101859: IFFALSE 101981
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101861: LD_ADDR_VAR 0 10
101865: PUSH
101866: LD_VAR 0 13
101870: PPUSH
101871: LD_VAR 0 4
101875: PUSH
101876: LD_VAR 0 7
101880: ARRAY
101881: PPUSH
101882: CALL_OW 74
101886: ST_TO_ADDR
// if not x then
101887: LD_VAR 0 10
101891: NOT
101892: IFFALSE 101896
// continue ;
101894: GO 101328
// if GetLives ( x ) < 1000 then
101896: LD_VAR 0 10
101900: PPUSH
101901: CALL_OW 256
101905: PUSH
101906: LD_INT 1000
101908: LESS
101909: IFFALSE 101933
// ComRepairVehicle ( group [ i ] , x ) else
101911: LD_VAR 0 4
101915: PUSH
101916: LD_VAR 0 7
101920: ARRAY
101921: PPUSH
101922: LD_VAR 0 10
101926: PPUSH
101927: CALL_OW 129
101931: GO 101981
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101933: LD_VAR 0 23
101937: PUSH
101938: LD_VAR 0 4
101942: PUSH
101943: LD_VAR 0 7
101947: ARRAY
101948: PPUSH
101949: CALL_OW 256
101953: PUSH
101954: LD_INT 1000
101956: LESS
101957: AND
101958: NOT
101959: IFFALSE 101981
// ComEnterUnit ( group [ i ] , x ) ;
101961: LD_VAR 0 4
101965: PUSH
101966: LD_VAR 0 7
101970: ARRAY
101971: PPUSH
101972: LD_VAR 0 10
101976: PPUSH
101977: CALL_OW 120
// end ; continue ;
101981: GO 101328
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101983: LD_VAR 0 23
101987: PUSH
101988: LD_VAR 0 4
101992: PUSH
101993: LD_VAR 0 7
101997: ARRAY
101998: PPUSH
101999: CALL_OW 247
102003: PUSH
102004: LD_INT 1
102006: EQUAL
102007: AND
102008: IFFALSE 102486
// begin if group [ i ] in healers then
102010: LD_VAR 0 4
102014: PUSH
102015: LD_VAR 0 7
102019: ARRAY
102020: PUSH
102021: LD_VAR 0 31
102025: IN
102026: IFFALSE 102299
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
102028: LD_VAR 0 4
102032: PUSH
102033: LD_VAR 0 7
102037: ARRAY
102038: PPUSH
102039: LD_VAR 0 23
102043: PPUSH
102044: CALL_OW 308
102048: NOT
102049: PUSH
102050: LD_VAR 0 4
102054: PUSH
102055: LD_VAR 0 7
102059: ARRAY
102060: PPUSH
102061: CALL_OW 314
102065: NOT
102066: AND
102067: IFFALSE 102091
// ComMoveToArea ( group [ i ] , f_heal ) else
102069: LD_VAR 0 4
102073: PUSH
102074: LD_VAR 0 7
102078: ARRAY
102079: PPUSH
102080: LD_VAR 0 23
102084: PPUSH
102085: CALL_OW 113
102089: GO 102297
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
102091: LD_VAR 0 4
102095: PUSH
102096: LD_VAR 0 7
102100: ARRAY
102101: PPUSH
102102: CALL 100709 0 1
102106: PPUSH
102107: CALL_OW 256
102111: PUSH
102112: LD_INT 1000
102114: EQUAL
102115: IFFALSE 102134
// ComStop ( group [ i ] ) else
102117: LD_VAR 0 4
102121: PUSH
102122: LD_VAR 0 7
102126: ARRAY
102127: PPUSH
102128: CALL_OW 141
102132: GO 102297
// if not HasTask ( group [ i ] ) and to_heal then
102134: LD_VAR 0 4
102138: PUSH
102139: LD_VAR 0 7
102143: ARRAY
102144: PPUSH
102145: CALL_OW 314
102149: NOT
102150: PUSH
102151: LD_VAR 0 30
102155: AND
102156: IFFALSE 102297
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102158: LD_ADDR_VAR 0 13
102162: PUSH
102163: LD_VAR 0 30
102167: PPUSH
102168: LD_INT 3
102170: PUSH
102171: LD_INT 54
102173: PUSH
102174: EMPTY
102175: LIST
102176: PUSH
102177: EMPTY
102178: LIST
102179: LIST
102180: PPUSH
102181: CALL_OW 72
102185: PPUSH
102186: LD_VAR 0 4
102190: PUSH
102191: LD_VAR 0 7
102195: ARRAY
102196: PPUSH
102197: CALL_OW 74
102201: ST_TO_ADDR
// if z then
102202: LD_VAR 0 13
102206: IFFALSE 102297
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102208: LD_INT 91
102210: PUSH
102211: LD_VAR 0 13
102215: PUSH
102216: LD_INT 10
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: LIST
102223: PUSH
102224: LD_INT 81
102226: PUSH
102227: LD_VAR 0 13
102231: PPUSH
102232: CALL_OW 255
102236: PUSH
102237: EMPTY
102238: LIST
102239: LIST
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: PPUSH
102245: CALL_OW 69
102249: PUSH
102250: LD_INT 0
102252: EQUAL
102253: IFFALSE 102277
// ComHeal ( group [ i ] , z ) else
102255: LD_VAR 0 4
102259: PUSH
102260: LD_VAR 0 7
102264: ARRAY
102265: PPUSH
102266: LD_VAR 0 13
102270: PPUSH
102271: CALL_OW 128
102275: GO 102297
// ComMoveToArea ( group [ i ] , f_heal ) ;
102277: LD_VAR 0 4
102281: PUSH
102282: LD_VAR 0 7
102286: ARRAY
102287: PPUSH
102288: LD_VAR 0 23
102292: PPUSH
102293: CALL_OW 113
// end ; continue ;
102297: GO 101328
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102299: LD_VAR 0 4
102303: PUSH
102304: LD_VAR 0 7
102308: ARRAY
102309: PPUSH
102310: CALL_OW 256
102314: PUSH
102315: LD_INT 700
102317: LESS
102318: PUSH
102319: LD_VAR 0 4
102323: PUSH
102324: LD_VAR 0 7
102328: ARRAY
102329: PUSH
102330: LD_VAR 0 30
102334: IN
102335: NOT
102336: AND
102337: IFFALSE 102361
// to_heal := to_heal union group [ i ] ;
102339: LD_ADDR_VAR 0 30
102343: PUSH
102344: LD_VAR 0 30
102348: PUSH
102349: LD_VAR 0 4
102353: PUSH
102354: LD_VAR 0 7
102358: ARRAY
102359: UNION
102360: ST_TO_ADDR
// if group [ i ] in to_heal then
102361: LD_VAR 0 4
102365: PUSH
102366: LD_VAR 0 7
102370: ARRAY
102371: PUSH
102372: LD_VAR 0 30
102376: IN
102377: IFFALSE 102486
// begin if GetLives ( group [ i ] ) = 1000 then
102379: LD_VAR 0 4
102383: PUSH
102384: LD_VAR 0 7
102388: ARRAY
102389: PPUSH
102390: CALL_OW 256
102394: PUSH
102395: LD_INT 1000
102397: EQUAL
102398: IFFALSE 102424
// to_heal := to_heal diff group [ i ] else
102400: LD_ADDR_VAR 0 30
102404: PUSH
102405: LD_VAR 0 30
102409: PUSH
102410: LD_VAR 0 4
102414: PUSH
102415: LD_VAR 0 7
102419: ARRAY
102420: DIFF
102421: ST_TO_ADDR
102422: GO 102486
// begin if not IsInArea ( group [ i ] , to_heal ) then
102424: LD_VAR 0 4
102428: PUSH
102429: LD_VAR 0 7
102433: ARRAY
102434: PPUSH
102435: LD_VAR 0 30
102439: PPUSH
102440: CALL_OW 308
102444: NOT
102445: IFFALSE 102469
// ComMoveToArea ( group [ i ] , f_heal ) else
102447: LD_VAR 0 4
102451: PUSH
102452: LD_VAR 0 7
102456: ARRAY
102457: PPUSH
102458: LD_VAR 0 23
102462: PPUSH
102463: CALL_OW 113
102467: GO 102484
// ComHold ( group [ i ] ) ;
102469: LD_VAR 0 4
102473: PUSH
102474: LD_VAR 0 7
102478: ARRAY
102479: PPUSH
102480: CALL_OW 140
// continue ;
102484: GO 101328
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102486: LD_VAR 0 4
102490: PUSH
102491: LD_VAR 0 7
102495: ARRAY
102496: PPUSH
102497: LD_INT 10
102499: PPUSH
102500: CALL 99129 0 2
102504: NOT
102505: PUSH
102506: LD_VAR 0 16
102510: PUSH
102511: LD_VAR 0 7
102515: ARRAY
102516: PUSH
102517: EMPTY
102518: EQUAL
102519: NOT
102520: AND
102521: IFFALSE 102787
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102523: LD_VAR 0 4
102527: PUSH
102528: LD_VAR 0 7
102532: ARRAY
102533: PPUSH
102534: CALL_OW 262
102538: PUSH
102539: LD_INT 1
102541: PUSH
102542: LD_INT 2
102544: PUSH
102545: EMPTY
102546: LIST
102547: LIST
102548: IN
102549: IFFALSE 102590
// if GetFuel ( group [ i ] ) < 10 then
102551: LD_VAR 0 4
102555: PUSH
102556: LD_VAR 0 7
102560: ARRAY
102561: PPUSH
102562: CALL_OW 261
102566: PUSH
102567: LD_INT 10
102569: LESS
102570: IFFALSE 102590
// SetFuel ( group [ i ] , 12 ) ;
102572: LD_VAR 0 4
102576: PUSH
102577: LD_VAR 0 7
102581: ARRAY
102582: PPUSH
102583: LD_INT 12
102585: PPUSH
102586: CALL_OW 240
// if units_path [ i ] then
102590: LD_VAR 0 16
102594: PUSH
102595: LD_VAR 0 7
102599: ARRAY
102600: IFFALSE 102785
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102602: LD_VAR 0 4
102606: PUSH
102607: LD_VAR 0 7
102611: ARRAY
102612: PPUSH
102613: LD_VAR 0 16
102617: PUSH
102618: LD_VAR 0 7
102622: ARRAY
102623: PUSH
102624: LD_INT 1
102626: ARRAY
102627: PUSH
102628: LD_INT 1
102630: ARRAY
102631: PPUSH
102632: LD_VAR 0 16
102636: PUSH
102637: LD_VAR 0 7
102641: ARRAY
102642: PUSH
102643: LD_INT 1
102645: ARRAY
102646: PUSH
102647: LD_INT 2
102649: ARRAY
102650: PPUSH
102651: CALL_OW 297
102655: PUSH
102656: LD_INT 6
102658: GREATER
102659: IFFALSE 102734
// begin if not HasTask ( group [ i ] ) then
102661: LD_VAR 0 4
102665: PUSH
102666: LD_VAR 0 7
102670: ARRAY
102671: PPUSH
102672: CALL_OW 314
102676: NOT
102677: IFFALSE 102732
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102679: LD_VAR 0 4
102683: PUSH
102684: LD_VAR 0 7
102688: ARRAY
102689: PPUSH
102690: LD_VAR 0 16
102694: PUSH
102695: LD_VAR 0 7
102699: ARRAY
102700: PUSH
102701: LD_INT 1
102703: ARRAY
102704: PUSH
102705: LD_INT 1
102707: ARRAY
102708: PPUSH
102709: LD_VAR 0 16
102713: PUSH
102714: LD_VAR 0 7
102718: ARRAY
102719: PUSH
102720: LD_INT 1
102722: ARRAY
102723: PUSH
102724: LD_INT 2
102726: ARRAY
102727: PPUSH
102728: CALL_OW 114
// end else
102732: GO 102785
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102734: LD_ADDR_VAR 0 15
102738: PUSH
102739: LD_VAR 0 16
102743: PUSH
102744: LD_VAR 0 7
102748: ARRAY
102749: PPUSH
102750: LD_INT 1
102752: PPUSH
102753: CALL_OW 3
102757: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102758: LD_ADDR_VAR 0 16
102762: PUSH
102763: LD_VAR 0 16
102767: PPUSH
102768: LD_VAR 0 7
102772: PPUSH
102773: LD_VAR 0 15
102777: PPUSH
102778: CALL_OW 1
102782: ST_TO_ADDR
// continue ;
102783: GO 101328
// end ; end ; end else
102785: GO 105449
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102787: LD_ADDR_VAR 0 14
102791: PUSH
102792: LD_INT 81
102794: PUSH
102795: LD_VAR 0 4
102799: PUSH
102800: LD_VAR 0 7
102804: ARRAY
102805: PPUSH
102806: CALL_OW 255
102810: PUSH
102811: EMPTY
102812: LIST
102813: LIST
102814: PPUSH
102815: CALL_OW 69
102819: ST_TO_ADDR
// if not tmp then
102820: LD_VAR 0 14
102824: NOT
102825: IFFALSE 102829
// continue ;
102827: GO 101328
// if f_ignore_area then
102829: LD_VAR 0 17
102833: IFFALSE 102921
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102835: LD_ADDR_VAR 0 15
102839: PUSH
102840: LD_VAR 0 14
102844: PPUSH
102845: LD_INT 3
102847: PUSH
102848: LD_INT 92
102850: PUSH
102851: LD_VAR 0 17
102855: PUSH
102856: LD_INT 1
102858: ARRAY
102859: PUSH
102860: LD_VAR 0 17
102864: PUSH
102865: LD_INT 2
102867: ARRAY
102868: PUSH
102869: LD_VAR 0 17
102873: PUSH
102874: LD_INT 3
102876: ARRAY
102877: PUSH
102878: EMPTY
102879: LIST
102880: LIST
102881: LIST
102882: LIST
102883: PUSH
102884: EMPTY
102885: LIST
102886: LIST
102887: PPUSH
102888: CALL_OW 72
102892: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102893: LD_VAR 0 14
102897: PUSH
102898: LD_VAR 0 15
102902: DIFF
102903: IFFALSE 102921
// tmp := tmp diff tmp2 ;
102905: LD_ADDR_VAR 0 14
102909: PUSH
102910: LD_VAR 0 14
102914: PUSH
102915: LD_VAR 0 15
102919: DIFF
102920: ST_TO_ADDR
// end ; if not f_murder then
102921: LD_VAR 0 20
102925: NOT
102926: IFFALSE 102984
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102928: LD_ADDR_VAR 0 15
102932: PUSH
102933: LD_VAR 0 14
102937: PPUSH
102938: LD_INT 3
102940: PUSH
102941: LD_INT 50
102943: PUSH
102944: EMPTY
102945: LIST
102946: PUSH
102947: EMPTY
102948: LIST
102949: LIST
102950: PPUSH
102951: CALL_OW 72
102955: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102956: LD_VAR 0 14
102960: PUSH
102961: LD_VAR 0 15
102965: DIFF
102966: IFFALSE 102984
// tmp := tmp diff tmp2 ;
102968: LD_ADDR_VAR 0 14
102972: PUSH
102973: LD_VAR 0 14
102977: PUSH
102978: LD_VAR 0 15
102982: DIFF
102983: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102984: LD_ADDR_VAR 0 14
102988: PUSH
102989: LD_VAR 0 4
102993: PUSH
102994: LD_VAR 0 7
102998: ARRAY
102999: PPUSH
103000: LD_VAR 0 14
103004: PPUSH
103005: LD_INT 1
103007: PPUSH
103008: LD_INT 1
103010: PPUSH
103011: CALL 72772 0 4
103015: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
103016: LD_VAR 0 4
103020: PUSH
103021: LD_VAR 0 7
103025: ARRAY
103026: PPUSH
103027: CALL_OW 257
103031: PUSH
103032: LD_INT 1
103034: EQUAL
103035: IFFALSE 103483
// begin if WantPlant ( group [ i ] ) then
103037: LD_VAR 0 4
103041: PUSH
103042: LD_VAR 0 7
103046: ARRAY
103047: PPUSH
103048: CALL 72273 0 1
103052: IFFALSE 103056
// continue ;
103054: GO 101328
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
103056: LD_VAR 0 18
103060: PUSH
103061: LD_VAR 0 4
103065: PUSH
103066: LD_VAR 0 7
103070: ARRAY
103071: PPUSH
103072: CALL_OW 310
103076: NOT
103077: AND
103078: PUSH
103079: LD_VAR 0 14
103083: PUSH
103084: LD_INT 1
103086: ARRAY
103087: PUSH
103088: LD_VAR 0 14
103092: PPUSH
103093: LD_INT 21
103095: PUSH
103096: LD_INT 2
103098: PUSH
103099: EMPTY
103100: LIST
103101: LIST
103102: PUSH
103103: LD_INT 58
103105: PUSH
103106: EMPTY
103107: LIST
103108: PUSH
103109: EMPTY
103110: LIST
103111: LIST
103112: PPUSH
103113: CALL_OW 72
103117: IN
103118: AND
103119: IFFALSE 103155
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
103121: LD_VAR 0 4
103125: PUSH
103126: LD_VAR 0 7
103130: ARRAY
103131: PPUSH
103132: LD_VAR 0 14
103136: PUSH
103137: LD_INT 1
103139: ARRAY
103140: PPUSH
103141: CALL_OW 120
// attacking := true ;
103145: LD_ADDR_VAR 0 29
103149: PUSH
103150: LD_INT 1
103152: ST_TO_ADDR
// continue ;
103153: GO 101328
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103155: LD_VAR 0 26
103159: PUSH
103160: LD_VAR 0 4
103164: PUSH
103165: LD_VAR 0 7
103169: ARRAY
103170: PPUSH
103171: CALL_OW 257
103175: PUSH
103176: LD_INT 1
103178: EQUAL
103179: AND
103180: PUSH
103181: LD_VAR 0 4
103185: PUSH
103186: LD_VAR 0 7
103190: ARRAY
103191: PPUSH
103192: CALL_OW 256
103196: PUSH
103197: LD_INT 800
103199: LESS
103200: AND
103201: PUSH
103202: LD_VAR 0 4
103206: PUSH
103207: LD_VAR 0 7
103211: ARRAY
103212: PPUSH
103213: CALL_OW 318
103217: NOT
103218: AND
103219: IFFALSE 103236
// ComCrawl ( group [ i ] ) ;
103221: LD_VAR 0 4
103225: PUSH
103226: LD_VAR 0 7
103230: ARRAY
103231: PPUSH
103232: CALL_OW 137
// if f_mines then
103236: LD_VAR 0 21
103240: IFFALSE 103483
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103242: LD_VAR 0 14
103246: PUSH
103247: LD_INT 1
103249: ARRAY
103250: PPUSH
103251: CALL_OW 247
103255: PUSH
103256: LD_INT 3
103258: EQUAL
103259: PUSH
103260: LD_VAR 0 14
103264: PUSH
103265: LD_INT 1
103267: ARRAY
103268: PUSH
103269: LD_VAR 0 27
103273: IN
103274: NOT
103275: AND
103276: IFFALSE 103483
// begin x := GetX ( tmp [ 1 ] ) ;
103278: LD_ADDR_VAR 0 10
103282: PUSH
103283: LD_VAR 0 14
103287: PUSH
103288: LD_INT 1
103290: ARRAY
103291: PPUSH
103292: CALL_OW 250
103296: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103297: LD_ADDR_VAR 0 11
103301: PUSH
103302: LD_VAR 0 14
103306: PUSH
103307: LD_INT 1
103309: ARRAY
103310: PPUSH
103311: CALL_OW 251
103315: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103316: LD_ADDR_VAR 0 12
103320: PUSH
103321: LD_VAR 0 4
103325: PUSH
103326: LD_VAR 0 7
103330: ARRAY
103331: PPUSH
103332: CALL 99214 0 1
103336: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103337: LD_VAR 0 4
103341: PUSH
103342: LD_VAR 0 7
103346: ARRAY
103347: PPUSH
103348: LD_VAR 0 10
103352: PPUSH
103353: LD_VAR 0 11
103357: PPUSH
103358: LD_VAR 0 14
103362: PUSH
103363: LD_INT 1
103365: ARRAY
103366: PPUSH
103367: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103371: LD_VAR 0 4
103375: PUSH
103376: LD_VAR 0 7
103380: ARRAY
103381: PPUSH
103382: LD_VAR 0 10
103386: PPUSH
103387: LD_VAR 0 12
103391: PPUSH
103392: LD_INT 7
103394: PPUSH
103395: CALL_OW 272
103399: PPUSH
103400: LD_VAR 0 11
103404: PPUSH
103405: LD_VAR 0 12
103409: PPUSH
103410: LD_INT 7
103412: PPUSH
103413: CALL_OW 273
103417: PPUSH
103418: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103422: LD_VAR 0 4
103426: PUSH
103427: LD_VAR 0 7
103431: ARRAY
103432: PPUSH
103433: LD_INT 71
103435: PPUSH
103436: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103440: LD_ADDR_VAR 0 27
103444: PUSH
103445: LD_VAR 0 27
103449: PPUSH
103450: LD_VAR 0 27
103454: PUSH
103455: LD_INT 1
103457: PLUS
103458: PPUSH
103459: LD_VAR 0 14
103463: PUSH
103464: LD_INT 1
103466: ARRAY
103467: PPUSH
103468: CALL_OW 1
103472: ST_TO_ADDR
// attacking := true ;
103473: LD_ADDR_VAR 0 29
103477: PUSH
103478: LD_INT 1
103480: ST_TO_ADDR
// continue ;
103481: GO 101328
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103483: LD_VAR 0 4
103487: PUSH
103488: LD_VAR 0 7
103492: ARRAY
103493: PPUSH
103494: CALL_OW 257
103498: PUSH
103499: LD_INT 17
103501: EQUAL
103502: PUSH
103503: LD_VAR 0 4
103507: PUSH
103508: LD_VAR 0 7
103512: ARRAY
103513: PPUSH
103514: CALL_OW 110
103518: PUSH
103519: LD_INT 71
103521: EQUAL
103522: NOT
103523: AND
103524: IFFALSE 103670
// begin attacking := false ;
103526: LD_ADDR_VAR 0 29
103530: PUSH
103531: LD_INT 0
103533: ST_TO_ADDR
// k := 5 ;
103534: LD_ADDR_VAR 0 9
103538: PUSH
103539: LD_INT 5
103541: ST_TO_ADDR
// if tmp < k then
103542: LD_VAR 0 14
103546: PUSH
103547: LD_VAR 0 9
103551: LESS
103552: IFFALSE 103564
// k := tmp ;
103554: LD_ADDR_VAR 0 9
103558: PUSH
103559: LD_VAR 0 14
103563: ST_TO_ADDR
// for j = 1 to k do
103564: LD_ADDR_VAR 0 8
103568: PUSH
103569: DOUBLE
103570: LD_INT 1
103572: DEC
103573: ST_TO_ADDR
103574: LD_VAR 0 9
103578: PUSH
103579: FOR_TO
103580: IFFALSE 103668
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103582: LD_VAR 0 14
103586: PUSH
103587: LD_VAR 0 8
103591: ARRAY
103592: PUSH
103593: LD_VAR 0 14
103597: PPUSH
103598: LD_INT 58
103600: PUSH
103601: EMPTY
103602: LIST
103603: PPUSH
103604: CALL_OW 72
103608: IN
103609: NOT
103610: IFFALSE 103666
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103612: LD_VAR 0 4
103616: PUSH
103617: LD_VAR 0 7
103621: ARRAY
103622: PPUSH
103623: LD_VAR 0 14
103627: PUSH
103628: LD_VAR 0 8
103632: ARRAY
103633: PPUSH
103634: CALL_OW 115
// attacking := true ;
103638: LD_ADDR_VAR 0 29
103642: PUSH
103643: LD_INT 1
103645: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103646: LD_VAR 0 4
103650: PUSH
103651: LD_VAR 0 7
103655: ARRAY
103656: PPUSH
103657: LD_INT 71
103659: PPUSH
103660: CALL_OW 109
// continue ;
103664: GO 103579
// end ; end ;
103666: GO 103579
103668: POP
103669: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103670: LD_VAR 0 4
103674: PUSH
103675: LD_VAR 0 7
103679: ARRAY
103680: PPUSH
103681: CALL_OW 257
103685: PUSH
103686: LD_INT 8
103688: EQUAL
103689: PUSH
103690: LD_VAR 0 4
103694: PUSH
103695: LD_VAR 0 7
103699: ARRAY
103700: PPUSH
103701: CALL_OW 264
103705: PUSH
103706: LD_INT 28
103708: PUSH
103709: LD_INT 45
103711: PUSH
103712: LD_INT 7
103714: PUSH
103715: LD_INT 47
103717: PUSH
103718: EMPTY
103719: LIST
103720: LIST
103721: LIST
103722: LIST
103723: IN
103724: OR
103725: IFFALSE 103981
// begin attacking := false ;
103727: LD_ADDR_VAR 0 29
103731: PUSH
103732: LD_INT 0
103734: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103735: LD_VAR 0 14
103739: PUSH
103740: LD_INT 1
103742: ARRAY
103743: PPUSH
103744: CALL_OW 266
103748: PUSH
103749: LD_INT 32
103751: PUSH
103752: LD_INT 31
103754: PUSH
103755: LD_INT 33
103757: PUSH
103758: LD_INT 4
103760: PUSH
103761: LD_INT 5
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: IN
103771: IFFALSE 103957
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103773: LD_ADDR_VAR 0 9
103777: PUSH
103778: LD_VAR 0 14
103782: PUSH
103783: LD_INT 1
103785: ARRAY
103786: PPUSH
103787: CALL_OW 266
103791: PPUSH
103792: LD_VAR 0 14
103796: PUSH
103797: LD_INT 1
103799: ARRAY
103800: PPUSH
103801: CALL_OW 250
103805: PPUSH
103806: LD_VAR 0 14
103810: PUSH
103811: LD_INT 1
103813: ARRAY
103814: PPUSH
103815: CALL_OW 251
103819: PPUSH
103820: LD_VAR 0 14
103824: PUSH
103825: LD_INT 1
103827: ARRAY
103828: PPUSH
103829: CALL_OW 254
103833: PPUSH
103834: LD_VAR 0 14
103838: PUSH
103839: LD_INT 1
103841: ARRAY
103842: PPUSH
103843: CALL_OW 248
103847: PPUSH
103848: LD_INT 0
103850: PPUSH
103851: CALL 80584 0 6
103855: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103856: LD_ADDR_VAR 0 8
103860: PUSH
103861: LD_VAR 0 4
103865: PUSH
103866: LD_VAR 0 7
103870: ARRAY
103871: PPUSH
103872: LD_VAR 0 9
103876: PPUSH
103877: CALL 99254 0 2
103881: ST_TO_ADDR
// if j then
103882: LD_VAR 0 8
103886: IFFALSE 103955
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103888: LD_VAR 0 8
103892: PUSH
103893: LD_INT 1
103895: ARRAY
103896: PPUSH
103897: LD_VAR 0 8
103901: PUSH
103902: LD_INT 2
103904: ARRAY
103905: PPUSH
103906: CALL_OW 488
103910: IFFALSE 103955
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103912: LD_VAR 0 4
103916: PUSH
103917: LD_VAR 0 7
103921: ARRAY
103922: PPUSH
103923: LD_VAR 0 8
103927: PUSH
103928: LD_INT 1
103930: ARRAY
103931: PPUSH
103932: LD_VAR 0 8
103936: PUSH
103937: LD_INT 2
103939: ARRAY
103940: PPUSH
103941: CALL_OW 116
// attacking := true ;
103945: LD_ADDR_VAR 0 29
103949: PUSH
103950: LD_INT 1
103952: ST_TO_ADDR
// continue ;
103953: GO 101328
// end ; end else
103955: GO 103981
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103957: LD_VAR 0 4
103961: PUSH
103962: LD_VAR 0 7
103966: ARRAY
103967: PPUSH
103968: LD_VAR 0 14
103972: PUSH
103973: LD_INT 1
103975: ARRAY
103976: PPUSH
103977: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103981: LD_VAR 0 4
103985: PUSH
103986: LD_VAR 0 7
103990: ARRAY
103991: PPUSH
103992: CALL_OW 265
103996: PUSH
103997: LD_INT 11
103999: EQUAL
104000: IFFALSE 104278
// begin k := 10 ;
104002: LD_ADDR_VAR 0 9
104006: PUSH
104007: LD_INT 10
104009: ST_TO_ADDR
// x := 0 ;
104010: LD_ADDR_VAR 0 10
104014: PUSH
104015: LD_INT 0
104017: ST_TO_ADDR
// if tmp < k then
104018: LD_VAR 0 14
104022: PUSH
104023: LD_VAR 0 9
104027: LESS
104028: IFFALSE 104040
// k := tmp ;
104030: LD_ADDR_VAR 0 9
104034: PUSH
104035: LD_VAR 0 14
104039: ST_TO_ADDR
// for j = k downto 1 do
104040: LD_ADDR_VAR 0 8
104044: PUSH
104045: DOUBLE
104046: LD_VAR 0 9
104050: INC
104051: ST_TO_ADDR
104052: LD_INT 1
104054: PUSH
104055: FOR_DOWNTO
104056: IFFALSE 104131
// begin if GetType ( tmp [ j ] ) = unit_human then
104058: LD_VAR 0 14
104062: PUSH
104063: LD_VAR 0 8
104067: ARRAY
104068: PPUSH
104069: CALL_OW 247
104073: PUSH
104074: LD_INT 1
104076: EQUAL
104077: IFFALSE 104129
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
104079: LD_VAR 0 4
104083: PUSH
104084: LD_VAR 0 7
104088: ARRAY
104089: PPUSH
104090: LD_VAR 0 14
104094: PUSH
104095: LD_VAR 0 8
104099: ARRAY
104100: PPUSH
104101: CALL 99525 0 2
// x := tmp [ j ] ;
104105: LD_ADDR_VAR 0 10
104109: PUSH
104110: LD_VAR 0 14
104114: PUSH
104115: LD_VAR 0 8
104119: ARRAY
104120: ST_TO_ADDR
// attacking := true ;
104121: LD_ADDR_VAR 0 29
104125: PUSH
104126: LD_INT 1
104128: ST_TO_ADDR
// end ; end ;
104129: GO 104055
104131: POP
104132: POP
// if not x then
104133: LD_VAR 0 10
104137: NOT
104138: IFFALSE 104278
// begin attacking := true ;
104140: LD_ADDR_VAR 0 29
104144: PUSH
104145: LD_INT 1
104147: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104148: LD_VAR 0 4
104152: PUSH
104153: LD_VAR 0 7
104157: ARRAY
104158: PPUSH
104159: CALL_OW 250
104163: PPUSH
104164: LD_VAR 0 4
104168: PUSH
104169: LD_VAR 0 7
104173: ARRAY
104174: PPUSH
104175: CALL_OW 251
104179: PPUSH
104180: CALL_OW 546
104184: PUSH
104185: LD_INT 2
104187: ARRAY
104188: PUSH
104189: LD_VAR 0 14
104193: PUSH
104194: LD_INT 1
104196: ARRAY
104197: PPUSH
104198: CALL_OW 250
104202: PPUSH
104203: LD_VAR 0 14
104207: PUSH
104208: LD_INT 1
104210: ARRAY
104211: PPUSH
104212: CALL_OW 251
104216: PPUSH
104217: CALL_OW 546
104221: PUSH
104222: LD_INT 2
104224: ARRAY
104225: EQUAL
104226: IFFALSE 104254
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104228: LD_VAR 0 4
104232: PUSH
104233: LD_VAR 0 7
104237: ARRAY
104238: PPUSH
104239: LD_VAR 0 14
104243: PUSH
104244: LD_INT 1
104246: ARRAY
104247: PPUSH
104248: CALL 99525 0 2
104252: GO 104278
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104254: LD_VAR 0 4
104258: PUSH
104259: LD_VAR 0 7
104263: ARRAY
104264: PPUSH
104265: LD_VAR 0 14
104269: PUSH
104270: LD_INT 1
104272: ARRAY
104273: PPUSH
104274: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104278: LD_VAR 0 4
104282: PUSH
104283: LD_VAR 0 7
104287: ARRAY
104288: PPUSH
104289: CALL_OW 264
104293: PUSH
104294: LD_INT 29
104296: EQUAL
104297: IFFALSE 104663
// begin if WantsToAttack ( group [ i ] ) in bombed then
104299: LD_VAR 0 4
104303: PUSH
104304: LD_VAR 0 7
104308: ARRAY
104309: PPUSH
104310: CALL_OW 319
104314: PUSH
104315: LD_VAR 0 28
104319: IN
104320: IFFALSE 104324
// continue ;
104322: GO 101328
// k := 8 ;
104324: LD_ADDR_VAR 0 9
104328: PUSH
104329: LD_INT 8
104331: ST_TO_ADDR
// x := 0 ;
104332: LD_ADDR_VAR 0 10
104336: PUSH
104337: LD_INT 0
104339: ST_TO_ADDR
// if tmp < k then
104340: LD_VAR 0 14
104344: PUSH
104345: LD_VAR 0 9
104349: LESS
104350: IFFALSE 104362
// k := tmp ;
104352: LD_ADDR_VAR 0 9
104356: PUSH
104357: LD_VAR 0 14
104361: ST_TO_ADDR
// for j = 1 to k do
104362: LD_ADDR_VAR 0 8
104366: PUSH
104367: DOUBLE
104368: LD_INT 1
104370: DEC
104371: ST_TO_ADDR
104372: LD_VAR 0 9
104376: PUSH
104377: FOR_TO
104378: IFFALSE 104510
// begin if GetType ( tmp [ j ] ) = unit_building then
104380: LD_VAR 0 14
104384: PUSH
104385: LD_VAR 0 8
104389: ARRAY
104390: PPUSH
104391: CALL_OW 247
104395: PUSH
104396: LD_INT 3
104398: EQUAL
104399: IFFALSE 104508
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104401: LD_VAR 0 14
104405: PUSH
104406: LD_VAR 0 8
104410: ARRAY
104411: PUSH
104412: LD_VAR 0 28
104416: IN
104417: NOT
104418: PUSH
104419: LD_VAR 0 14
104423: PUSH
104424: LD_VAR 0 8
104428: ARRAY
104429: PPUSH
104430: CALL_OW 313
104434: AND
104435: IFFALSE 104508
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104437: LD_VAR 0 4
104441: PUSH
104442: LD_VAR 0 7
104446: ARRAY
104447: PPUSH
104448: LD_VAR 0 14
104452: PUSH
104453: LD_VAR 0 8
104457: ARRAY
104458: PPUSH
104459: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104463: LD_ADDR_VAR 0 28
104467: PUSH
104468: LD_VAR 0 28
104472: PPUSH
104473: LD_VAR 0 28
104477: PUSH
104478: LD_INT 1
104480: PLUS
104481: PPUSH
104482: LD_VAR 0 14
104486: PUSH
104487: LD_VAR 0 8
104491: ARRAY
104492: PPUSH
104493: CALL_OW 1
104497: ST_TO_ADDR
// attacking := true ;
104498: LD_ADDR_VAR 0 29
104502: PUSH
104503: LD_INT 1
104505: ST_TO_ADDR
// break ;
104506: GO 104510
// end ; end ;
104508: GO 104377
104510: POP
104511: POP
// if not attacking and f_attack_depot then
104512: LD_VAR 0 29
104516: NOT
104517: PUSH
104518: LD_VAR 0 25
104522: AND
104523: IFFALSE 104618
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104525: LD_ADDR_VAR 0 13
104529: PUSH
104530: LD_VAR 0 14
104534: PPUSH
104535: LD_INT 2
104537: PUSH
104538: LD_INT 30
104540: PUSH
104541: LD_INT 0
104543: PUSH
104544: EMPTY
104545: LIST
104546: LIST
104547: PUSH
104548: LD_INT 30
104550: PUSH
104551: LD_INT 1
104553: PUSH
104554: EMPTY
104555: LIST
104556: LIST
104557: PUSH
104558: EMPTY
104559: LIST
104560: LIST
104561: LIST
104562: PPUSH
104563: CALL_OW 72
104567: ST_TO_ADDR
// if z then
104568: LD_VAR 0 13
104572: IFFALSE 104618
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104574: LD_VAR 0 4
104578: PUSH
104579: LD_VAR 0 7
104583: ARRAY
104584: PPUSH
104585: LD_VAR 0 13
104589: PPUSH
104590: LD_VAR 0 4
104594: PUSH
104595: LD_VAR 0 7
104599: ARRAY
104600: PPUSH
104601: CALL_OW 74
104605: PPUSH
104606: CALL_OW 115
// attacking := true ;
104610: LD_ADDR_VAR 0 29
104614: PUSH
104615: LD_INT 1
104617: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104618: LD_VAR 0 4
104622: PUSH
104623: LD_VAR 0 7
104627: ARRAY
104628: PPUSH
104629: CALL_OW 256
104633: PUSH
104634: LD_INT 500
104636: LESS
104637: IFFALSE 104663
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104639: LD_VAR 0 4
104643: PUSH
104644: LD_VAR 0 7
104648: ARRAY
104649: PPUSH
104650: LD_VAR 0 14
104654: PUSH
104655: LD_INT 1
104657: ARRAY
104658: PPUSH
104659: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104663: LD_VAR 0 4
104667: PUSH
104668: LD_VAR 0 7
104672: ARRAY
104673: PPUSH
104674: CALL_OW 264
104678: PUSH
104679: LD_INT 49
104681: EQUAL
104682: IFFALSE 104803
// begin if not HasTask ( group [ i ] ) then
104684: LD_VAR 0 4
104688: PUSH
104689: LD_VAR 0 7
104693: ARRAY
104694: PPUSH
104695: CALL_OW 314
104699: NOT
104700: IFFALSE 104803
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104702: LD_ADDR_VAR 0 9
104706: PUSH
104707: LD_INT 81
104709: PUSH
104710: LD_VAR 0 4
104714: PUSH
104715: LD_VAR 0 7
104719: ARRAY
104720: PPUSH
104721: CALL_OW 255
104725: PUSH
104726: EMPTY
104727: LIST
104728: LIST
104729: PPUSH
104730: CALL_OW 69
104734: PPUSH
104735: LD_VAR 0 4
104739: PUSH
104740: LD_VAR 0 7
104744: ARRAY
104745: PPUSH
104746: CALL_OW 74
104750: ST_TO_ADDR
// if k then
104751: LD_VAR 0 9
104755: IFFALSE 104803
// if GetDistUnits ( group [ i ] , k ) > 10 then
104757: LD_VAR 0 4
104761: PUSH
104762: LD_VAR 0 7
104766: ARRAY
104767: PPUSH
104768: LD_VAR 0 9
104772: PPUSH
104773: CALL_OW 296
104777: PUSH
104778: LD_INT 10
104780: GREATER
104781: IFFALSE 104803
// ComMoveUnit ( group [ i ] , k ) ;
104783: LD_VAR 0 4
104787: PUSH
104788: LD_VAR 0 7
104792: ARRAY
104793: PPUSH
104794: LD_VAR 0 9
104798: PPUSH
104799: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104803: LD_VAR 0 4
104807: PUSH
104808: LD_VAR 0 7
104812: ARRAY
104813: PPUSH
104814: CALL_OW 256
104818: PUSH
104819: LD_INT 250
104821: LESS
104822: PUSH
104823: LD_VAR 0 4
104827: PUSH
104828: LD_VAR 0 7
104832: ARRAY
104833: PUSH
104834: LD_INT 21
104836: PUSH
104837: LD_INT 2
104839: PUSH
104840: EMPTY
104841: LIST
104842: LIST
104843: PUSH
104844: LD_INT 23
104846: PUSH
104847: LD_INT 2
104849: PUSH
104850: EMPTY
104851: LIST
104852: LIST
104853: PUSH
104854: EMPTY
104855: LIST
104856: LIST
104857: PPUSH
104858: CALL_OW 69
104862: IN
104863: AND
104864: IFFALSE 104989
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104866: LD_ADDR_VAR 0 9
104870: PUSH
104871: LD_OWVAR 3
104875: PUSH
104876: LD_VAR 0 4
104880: PUSH
104881: LD_VAR 0 7
104885: ARRAY
104886: DIFF
104887: PPUSH
104888: LD_VAR 0 4
104892: PUSH
104893: LD_VAR 0 7
104897: ARRAY
104898: PPUSH
104899: CALL_OW 74
104903: ST_TO_ADDR
// if not k then
104904: LD_VAR 0 9
104908: NOT
104909: IFFALSE 104913
// continue ;
104911: GO 101328
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104913: LD_VAR 0 9
104917: PUSH
104918: LD_INT 81
104920: PUSH
104921: LD_VAR 0 4
104925: PUSH
104926: LD_VAR 0 7
104930: ARRAY
104931: PPUSH
104932: CALL_OW 255
104936: PUSH
104937: EMPTY
104938: LIST
104939: LIST
104940: PPUSH
104941: CALL_OW 69
104945: IN
104946: PUSH
104947: LD_VAR 0 9
104951: PPUSH
104952: LD_VAR 0 4
104956: PUSH
104957: LD_VAR 0 7
104961: ARRAY
104962: PPUSH
104963: CALL_OW 296
104967: PUSH
104968: LD_INT 5
104970: LESS
104971: AND
104972: IFFALSE 104989
// ComAutodestruct ( group [ i ] ) ;
104974: LD_VAR 0 4
104978: PUSH
104979: LD_VAR 0 7
104983: ARRAY
104984: PPUSH
104985: CALL 99423 0 1
// end ; if f_attack_depot then
104989: LD_VAR 0 25
104993: IFFALSE 105105
// begin k := 6 ;
104995: LD_ADDR_VAR 0 9
104999: PUSH
105000: LD_INT 6
105002: ST_TO_ADDR
// if tmp < k then
105003: LD_VAR 0 14
105007: PUSH
105008: LD_VAR 0 9
105012: LESS
105013: IFFALSE 105025
// k := tmp ;
105015: LD_ADDR_VAR 0 9
105019: PUSH
105020: LD_VAR 0 14
105024: ST_TO_ADDR
// for j = 1 to k do
105025: LD_ADDR_VAR 0 8
105029: PUSH
105030: DOUBLE
105031: LD_INT 1
105033: DEC
105034: ST_TO_ADDR
105035: LD_VAR 0 9
105039: PUSH
105040: FOR_TO
105041: IFFALSE 105103
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
105043: LD_VAR 0 8
105047: PPUSH
105048: CALL_OW 266
105052: PUSH
105053: LD_INT 0
105055: PUSH
105056: LD_INT 1
105058: PUSH
105059: EMPTY
105060: LIST
105061: LIST
105062: IN
105063: IFFALSE 105101
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105065: LD_VAR 0 4
105069: PUSH
105070: LD_VAR 0 7
105074: ARRAY
105075: PPUSH
105076: LD_VAR 0 14
105080: PUSH
105081: LD_VAR 0 8
105085: ARRAY
105086: PPUSH
105087: CALL_OW 115
// attacking := true ;
105091: LD_ADDR_VAR 0 29
105095: PUSH
105096: LD_INT 1
105098: ST_TO_ADDR
// break ;
105099: GO 105103
// end ;
105101: GO 105040
105103: POP
105104: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
105105: LD_VAR 0 4
105109: PUSH
105110: LD_VAR 0 7
105114: ARRAY
105115: PPUSH
105116: CALL_OW 302
105120: PUSH
105121: LD_VAR 0 29
105125: NOT
105126: AND
105127: IFFALSE 105449
// begin if GetTag ( group [ i ] ) = 71 then
105129: LD_VAR 0 4
105133: PUSH
105134: LD_VAR 0 7
105138: ARRAY
105139: PPUSH
105140: CALL_OW 110
105144: PUSH
105145: LD_INT 71
105147: EQUAL
105148: IFFALSE 105189
// begin if HasTask ( group [ i ] ) then
105150: LD_VAR 0 4
105154: PUSH
105155: LD_VAR 0 7
105159: ARRAY
105160: PPUSH
105161: CALL_OW 314
105165: IFFALSE 105171
// continue else
105167: GO 101328
105169: GO 105189
// SetTag ( group [ i ] , 0 ) ;
105171: LD_VAR 0 4
105175: PUSH
105176: LD_VAR 0 7
105180: ARRAY
105181: PPUSH
105182: LD_INT 0
105184: PPUSH
105185: CALL_OW 109
// end ; k := 8 ;
105189: LD_ADDR_VAR 0 9
105193: PUSH
105194: LD_INT 8
105196: ST_TO_ADDR
// x := 0 ;
105197: LD_ADDR_VAR 0 10
105201: PUSH
105202: LD_INT 0
105204: ST_TO_ADDR
// if tmp < k then
105205: LD_VAR 0 14
105209: PUSH
105210: LD_VAR 0 9
105214: LESS
105215: IFFALSE 105227
// k := tmp ;
105217: LD_ADDR_VAR 0 9
105221: PUSH
105222: LD_VAR 0 14
105226: ST_TO_ADDR
// for j = 1 to k do
105227: LD_ADDR_VAR 0 8
105231: PUSH
105232: DOUBLE
105233: LD_INT 1
105235: DEC
105236: ST_TO_ADDR
105237: LD_VAR 0 9
105241: PUSH
105242: FOR_TO
105243: IFFALSE 105341
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105245: LD_VAR 0 14
105249: PUSH
105250: LD_VAR 0 8
105254: ARRAY
105255: PPUSH
105256: CALL_OW 247
105260: PUSH
105261: LD_INT 1
105263: EQUAL
105264: PUSH
105265: LD_VAR 0 14
105269: PUSH
105270: LD_VAR 0 8
105274: ARRAY
105275: PPUSH
105276: CALL_OW 256
105280: PUSH
105281: LD_INT 250
105283: LESS
105284: PUSH
105285: LD_VAR 0 20
105289: AND
105290: PUSH
105291: LD_VAR 0 20
105295: NOT
105296: PUSH
105297: LD_VAR 0 14
105301: PUSH
105302: LD_VAR 0 8
105306: ARRAY
105307: PPUSH
105308: CALL_OW 256
105312: PUSH
105313: LD_INT 250
105315: GREATEREQUAL
105316: AND
105317: OR
105318: AND
105319: IFFALSE 105339
// begin x := tmp [ j ] ;
105321: LD_ADDR_VAR 0 10
105325: PUSH
105326: LD_VAR 0 14
105330: PUSH
105331: LD_VAR 0 8
105335: ARRAY
105336: ST_TO_ADDR
// break ;
105337: GO 105341
// end ;
105339: GO 105242
105341: POP
105342: POP
// if x then
105343: LD_VAR 0 10
105347: IFFALSE 105371
// ComAttackUnit ( group [ i ] , x ) else
105349: LD_VAR 0 4
105353: PUSH
105354: LD_VAR 0 7
105358: ARRAY
105359: PPUSH
105360: LD_VAR 0 10
105364: PPUSH
105365: CALL_OW 115
105369: GO 105395
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105371: LD_VAR 0 4
105375: PUSH
105376: LD_VAR 0 7
105380: ARRAY
105381: PPUSH
105382: LD_VAR 0 14
105386: PUSH
105387: LD_INT 1
105389: ARRAY
105390: PPUSH
105391: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105395: LD_VAR 0 4
105399: PUSH
105400: LD_VAR 0 7
105404: ARRAY
105405: PPUSH
105406: CALL_OW 314
105410: NOT
105411: IFFALSE 105449
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105413: LD_VAR 0 4
105417: PUSH
105418: LD_VAR 0 7
105422: ARRAY
105423: PPUSH
105424: LD_VAR 0 14
105428: PPUSH
105429: LD_VAR 0 4
105433: PUSH
105434: LD_VAR 0 7
105438: ARRAY
105439: PPUSH
105440: CALL_OW 74
105444: PPUSH
105445: CALL_OW 115
// end ; end ; end ;
105449: GO 101328
105451: POP
105452: POP
// wait ( 0 0$2 ) ;
105453: LD_INT 70
105455: PPUSH
105456: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105460: LD_VAR 0 4
105464: NOT
105465: PUSH
105466: LD_VAR 0 4
105470: PUSH
105471: EMPTY
105472: EQUAL
105473: OR
105474: PUSH
105475: LD_INT 81
105477: PUSH
105478: LD_VAR 0 35
105482: PUSH
105483: EMPTY
105484: LIST
105485: LIST
105486: PPUSH
105487: CALL_OW 69
105491: NOT
105492: OR
105493: IFFALSE 101313
// end ;
105495: LD_VAR 0 2
105499: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105500: LD_INT 0
105502: PPUSH
105503: PPUSH
105504: PPUSH
105505: PPUSH
// if not base_units then
105506: LD_VAR 0 1
105510: NOT
105511: IFFALSE 105515
// exit ;
105513: GO 105602
// result := false ;
105515: LD_ADDR_VAR 0 2
105519: PUSH
105520: LD_INT 0
105522: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105523: LD_ADDR_VAR 0 5
105527: PUSH
105528: LD_VAR 0 1
105532: PPUSH
105533: LD_INT 21
105535: PUSH
105536: LD_INT 3
105538: PUSH
105539: EMPTY
105540: LIST
105541: LIST
105542: PPUSH
105543: CALL_OW 72
105547: ST_TO_ADDR
// if not tmp then
105548: LD_VAR 0 5
105552: NOT
105553: IFFALSE 105557
// exit ;
105555: GO 105602
// for i in tmp do
105557: LD_ADDR_VAR 0 3
105561: PUSH
105562: LD_VAR 0 5
105566: PUSH
105567: FOR_IN
105568: IFFALSE 105600
// begin result := EnemyInRange ( i , 22 ) ;
105570: LD_ADDR_VAR 0 2
105574: PUSH
105575: LD_VAR 0 3
105579: PPUSH
105580: LD_INT 22
105582: PPUSH
105583: CALL 99129 0 2
105587: ST_TO_ADDR
// if result then
105588: LD_VAR 0 2
105592: IFFALSE 105598
// exit ;
105594: POP
105595: POP
105596: GO 105602
// end ;
105598: GO 105567
105600: POP
105601: POP
// end ;
105602: LD_VAR 0 2
105606: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105607: LD_INT 0
105609: PPUSH
105610: PPUSH
// if not units then
105611: LD_VAR 0 1
105615: NOT
105616: IFFALSE 105620
// exit ;
105618: GO 105690
// result := [ ] ;
105620: LD_ADDR_VAR 0 3
105624: PUSH
105625: EMPTY
105626: ST_TO_ADDR
// for i in units do
105627: LD_ADDR_VAR 0 4
105631: PUSH
105632: LD_VAR 0 1
105636: PUSH
105637: FOR_IN
105638: IFFALSE 105688
// if GetTag ( i ) = tag then
105640: LD_VAR 0 4
105644: PPUSH
105645: CALL_OW 110
105649: PUSH
105650: LD_VAR 0 2
105654: EQUAL
105655: IFFALSE 105686
// result := Insert ( result , result + 1 , i ) ;
105657: LD_ADDR_VAR 0 3
105661: PUSH
105662: LD_VAR 0 3
105666: PPUSH
105667: LD_VAR 0 3
105671: PUSH
105672: LD_INT 1
105674: PLUS
105675: PPUSH
105676: LD_VAR 0 4
105680: PPUSH
105681: CALL_OW 2
105685: ST_TO_ADDR
105686: GO 105637
105688: POP
105689: POP
// end ;
105690: LD_VAR 0 3
105694: RET
// export function IsDriver ( un ) ; begin
105695: LD_INT 0
105697: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105698: LD_ADDR_VAR 0 2
105702: PUSH
105703: LD_VAR 0 1
105707: PUSH
105708: LD_INT 55
105710: PUSH
105711: EMPTY
105712: LIST
105713: PPUSH
105714: CALL_OW 69
105718: IN
105719: ST_TO_ADDR
// end ;
105720: LD_VAR 0 2
105724: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105725: LD_INT 0
105727: PPUSH
105728: PPUSH
// list := [ ] ;
105729: LD_ADDR_VAR 0 5
105733: PUSH
105734: EMPTY
105735: ST_TO_ADDR
// case d of 0 :
105736: LD_VAR 0 3
105740: PUSH
105741: LD_INT 0
105743: DOUBLE
105744: EQUAL
105745: IFTRUE 105749
105747: GO 105882
105749: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105750: LD_ADDR_VAR 0 5
105754: PUSH
105755: LD_VAR 0 1
105759: PUSH
105760: LD_INT 4
105762: MINUS
105763: PUSH
105764: LD_VAR 0 2
105768: PUSH
105769: LD_INT 4
105771: MINUS
105772: PUSH
105773: LD_INT 2
105775: PUSH
105776: EMPTY
105777: LIST
105778: LIST
105779: LIST
105780: PUSH
105781: LD_VAR 0 1
105785: PUSH
105786: LD_INT 3
105788: MINUS
105789: PUSH
105790: LD_VAR 0 2
105794: PUSH
105795: LD_INT 1
105797: PUSH
105798: EMPTY
105799: LIST
105800: LIST
105801: LIST
105802: PUSH
105803: LD_VAR 0 1
105807: PUSH
105808: LD_INT 4
105810: PLUS
105811: PUSH
105812: LD_VAR 0 2
105816: PUSH
105817: LD_INT 4
105819: PUSH
105820: EMPTY
105821: LIST
105822: LIST
105823: LIST
105824: PUSH
105825: LD_VAR 0 1
105829: PUSH
105830: LD_INT 3
105832: PLUS
105833: PUSH
105834: LD_VAR 0 2
105838: PUSH
105839: LD_INT 3
105841: PLUS
105842: PUSH
105843: LD_INT 5
105845: PUSH
105846: EMPTY
105847: LIST
105848: LIST
105849: LIST
105850: PUSH
105851: LD_VAR 0 1
105855: PUSH
105856: LD_VAR 0 2
105860: PUSH
105861: LD_INT 4
105863: PLUS
105864: PUSH
105865: LD_INT 0
105867: PUSH
105868: EMPTY
105869: LIST
105870: LIST
105871: LIST
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: LIST
105877: LIST
105878: LIST
105879: ST_TO_ADDR
// end ; 1 :
105880: GO 106580
105882: LD_INT 1
105884: DOUBLE
105885: EQUAL
105886: IFTRUE 105890
105888: GO 106023
105890: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105891: LD_ADDR_VAR 0 5
105895: PUSH
105896: LD_VAR 0 1
105900: PUSH
105901: LD_VAR 0 2
105905: PUSH
105906: LD_INT 4
105908: MINUS
105909: PUSH
105910: LD_INT 3
105912: PUSH
105913: EMPTY
105914: LIST
105915: LIST
105916: LIST
105917: PUSH
105918: LD_VAR 0 1
105922: PUSH
105923: LD_INT 3
105925: MINUS
105926: PUSH
105927: LD_VAR 0 2
105931: PUSH
105932: LD_INT 3
105934: MINUS
105935: PUSH
105936: LD_INT 2
105938: PUSH
105939: EMPTY
105940: LIST
105941: LIST
105942: LIST
105943: PUSH
105944: LD_VAR 0 1
105948: PUSH
105949: LD_INT 4
105951: MINUS
105952: PUSH
105953: LD_VAR 0 2
105957: PUSH
105958: LD_INT 1
105960: PUSH
105961: EMPTY
105962: LIST
105963: LIST
105964: LIST
105965: PUSH
105966: LD_VAR 0 1
105970: PUSH
105971: LD_VAR 0 2
105975: PUSH
105976: LD_INT 3
105978: PLUS
105979: PUSH
105980: LD_INT 0
105982: PUSH
105983: EMPTY
105984: LIST
105985: LIST
105986: LIST
105987: PUSH
105988: LD_VAR 0 1
105992: PUSH
105993: LD_INT 4
105995: PLUS
105996: PUSH
105997: LD_VAR 0 2
106001: PUSH
106002: LD_INT 4
106004: PLUS
106005: PUSH
106006: LD_INT 5
106008: PUSH
106009: EMPTY
106010: LIST
106011: LIST
106012: LIST
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: LIST
106018: LIST
106019: LIST
106020: ST_TO_ADDR
// end ; 2 :
106021: GO 106580
106023: LD_INT 2
106025: DOUBLE
106026: EQUAL
106027: IFTRUE 106031
106029: GO 106160
106031: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
106032: LD_ADDR_VAR 0 5
106036: PUSH
106037: LD_VAR 0 1
106041: PUSH
106042: LD_VAR 0 2
106046: PUSH
106047: LD_INT 3
106049: MINUS
106050: PUSH
106051: LD_INT 3
106053: PUSH
106054: EMPTY
106055: LIST
106056: LIST
106057: LIST
106058: PUSH
106059: LD_VAR 0 1
106063: PUSH
106064: LD_INT 4
106066: PLUS
106067: PUSH
106068: LD_VAR 0 2
106072: PUSH
106073: LD_INT 4
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: LIST
106080: PUSH
106081: LD_VAR 0 1
106085: PUSH
106086: LD_VAR 0 2
106090: PUSH
106091: LD_INT 4
106093: PLUS
106094: PUSH
106095: LD_INT 0
106097: PUSH
106098: EMPTY
106099: LIST
106100: LIST
106101: LIST
106102: PUSH
106103: LD_VAR 0 1
106107: PUSH
106108: LD_INT 3
106110: MINUS
106111: PUSH
106112: LD_VAR 0 2
106116: PUSH
106117: LD_INT 1
106119: PUSH
106120: EMPTY
106121: LIST
106122: LIST
106123: LIST
106124: PUSH
106125: LD_VAR 0 1
106129: PUSH
106130: LD_INT 4
106132: MINUS
106133: PUSH
106134: LD_VAR 0 2
106138: PUSH
106139: LD_INT 4
106141: MINUS
106142: PUSH
106143: LD_INT 2
106145: PUSH
106146: EMPTY
106147: LIST
106148: LIST
106149: LIST
106150: PUSH
106151: EMPTY
106152: LIST
106153: LIST
106154: LIST
106155: LIST
106156: LIST
106157: ST_TO_ADDR
// end ; 3 :
106158: GO 106580
106160: LD_INT 3
106162: DOUBLE
106163: EQUAL
106164: IFTRUE 106168
106166: GO 106301
106168: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106169: LD_ADDR_VAR 0 5
106173: PUSH
106174: LD_VAR 0 1
106178: PUSH
106179: LD_INT 3
106181: PLUS
106182: PUSH
106183: LD_VAR 0 2
106187: PUSH
106188: LD_INT 4
106190: PUSH
106191: EMPTY
106192: LIST
106193: LIST
106194: LIST
106195: PUSH
106196: LD_VAR 0 1
106200: PUSH
106201: LD_INT 4
106203: PLUS
106204: PUSH
106205: LD_VAR 0 2
106209: PUSH
106210: LD_INT 4
106212: PLUS
106213: PUSH
106214: LD_INT 5
106216: PUSH
106217: EMPTY
106218: LIST
106219: LIST
106220: LIST
106221: PUSH
106222: LD_VAR 0 1
106226: PUSH
106227: LD_INT 4
106229: MINUS
106230: PUSH
106231: LD_VAR 0 2
106235: PUSH
106236: LD_INT 1
106238: PUSH
106239: EMPTY
106240: LIST
106241: LIST
106242: LIST
106243: PUSH
106244: LD_VAR 0 1
106248: PUSH
106249: LD_VAR 0 2
106253: PUSH
106254: LD_INT 4
106256: MINUS
106257: PUSH
106258: LD_INT 3
106260: PUSH
106261: EMPTY
106262: LIST
106263: LIST
106264: LIST
106265: PUSH
106266: LD_VAR 0 1
106270: PUSH
106271: LD_INT 3
106273: MINUS
106274: PUSH
106275: LD_VAR 0 2
106279: PUSH
106280: LD_INT 3
106282: MINUS
106283: PUSH
106284: LD_INT 2
106286: PUSH
106287: EMPTY
106288: LIST
106289: LIST
106290: LIST
106291: PUSH
106292: EMPTY
106293: LIST
106294: LIST
106295: LIST
106296: LIST
106297: LIST
106298: ST_TO_ADDR
// end ; 4 :
106299: GO 106580
106301: LD_INT 4
106303: DOUBLE
106304: EQUAL
106305: IFTRUE 106309
106307: GO 106442
106309: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106310: LD_ADDR_VAR 0 5
106314: PUSH
106315: LD_VAR 0 1
106319: PUSH
106320: LD_VAR 0 2
106324: PUSH
106325: LD_INT 4
106327: PLUS
106328: PUSH
106329: LD_INT 0
106331: PUSH
106332: EMPTY
106333: LIST
106334: LIST
106335: LIST
106336: PUSH
106337: LD_VAR 0 1
106341: PUSH
106342: LD_INT 3
106344: PLUS
106345: PUSH
106346: LD_VAR 0 2
106350: PUSH
106351: LD_INT 3
106353: PLUS
106354: PUSH
106355: LD_INT 5
106357: PUSH
106358: EMPTY
106359: LIST
106360: LIST
106361: LIST
106362: PUSH
106363: LD_VAR 0 1
106367: PUSH
106368: LD_INT 4
106370: PLUS
106371: PUSH
106372: LD_VAR 0 2
106376: PUSH
106377: LD_INT 4
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: LIST
106384: PUSH
106385: LD_VAR 0 1
106389: PUSH
106390: LD_VAR 0 2
106394: PUSH
106395: LD_INT 3
106397: MINUS
106398: PUSH
106399: LD_INT 3
106401: PUSH
106402: EMPTY
106403: LIST
106404: LIST
106405: LIST
106406: PUSH
106407: LD_VAR 0 1
106411: PUSH
106412: LD_INT 4
106414: MINUS
106415: PUSH
106416: LD_VAR 0 2
106420: PUSH
106421: LD_INT 4
106423: MINUS
106424: PUSH
106425: LD_INT 2
106427: PUSH
106428: EMPTY
106429: LIST
106430: LIST
106431: LIST
106432: PUSH
106433: EMPTY
106434: LIST
106435: LIST
106436: LIST
106437: LIST
106438: LIST
106439: ST_TO_ADDR
// end ; 5 :
106440: GO 106580
106442: LD_INT 5
106444: DOUBLE
106445: EQUAL
106446: IFTRUE 106450
106448: GO 106579
106450: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106451: LD_ADDR_VAR 0 5
106455: PUSH
106456: LD_VAR 0 1
106460: PUSH
106461: LD_INT 4
106463: MINUS
106464: PUSH
106465: LD_VAR 0 2
106469: PUSH
106470: LD_INT 1
106472: PUSH
106473: EMPTY
106474: LIST
106475: LIST
106476: LIST
106477: PUSH
106478: LD_VAR 0 1
106482: PUSH
106483: LD_VAR 0 2
106487: PUSH
106488: LD_INT 4
106490: MINUS
106491: PUSH
106492: LD_INT 3
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: LIST
106499: PUSH
106500: LD_VAR 0 1
106504: PUSH
106505: LD_INT 4
106507: PLUS
106508: PUSH
106509: LD_VAR 0 2
106513: PUSH
106514: LD_INT 4
106516: PLUS
106517: PUSH
106518: LD_INT 5
106520: PUSH
106521: EMPTY
106522: LIST
106523: LIST
106524: LIST
106525: PUSH
106526: LD_VAR 0 1
106530: PUSH
106531: LD_INT 3
106533: PLUS
106534: PUSH
106535: LD_VAR 0 2
106539: PUSH
106540: LD_INT 4
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: LIST
106547: PUSH
106548: LD_VAR 0 1
106552: PUSH
106553: LD_VAR 0 2
106557: PUSH
106558: LD_INT 3
106560: PLUS
106561: PUSH
106562: LD_INT 0
106564: PUSH
106565: EMPTY
106566: LIST
106567: LIST
106568: LIST
106569: PUSH
106570: EMPTY
106571: LIST
106572: LIST
106573: LIST
106574: LIST
106575: LIST
106576: ST_TO_ADDR
// end ; end ;
106577: GO 106580
106579: POP
// result := list ;
106580: LD_ADDR_VAR 0 4
106584: PUSH
106585: LD_VAR 0 5
106589: ST_TO_ADDR
// end ;
106590: LD_VAR 0 4
106594: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106595: LD_INT 0
106597: PPUSH
106598: PPUSH
106599: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106600: LD_VAR 0 1
106604: NOT
106605: PUSH
106606: LD_VAR 0 2
106610: PUSH
106611: LD_INT 1
106613: PUSH
106614: LD_INT 2
106616: PUSH
106617: LD_INT 3
106619: PUSH
106620: LD_INT 4
106622: PUSH
106623: EMPTY
106624: LIST
106625: LIST
106626: LIST
106627: LIST
106628: IN
106629: NOT
106630: OR
106631: IFFALSE 106635
// exit ;
106633: GO 106727
// tmp := [ ] ;
106635: LD_ADDR_VAR 0 5
106639: PUSH
106640: EMPTY
106641: ST_TO_ADDR
// for i in units do
106642: LD_ADDR_VAR 0 4
106646: PUSH
106647: LD_VAR 0 1
106651: PUSH
106652: FOR_IN
106653: IFFALSE 106696
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106655: LD_ADDR_VAR 0 5
106659: PUSH
106660: LD_VAR 0 5
106664: PPUSH
106665: LD_VAR 0 5
106669: PUSH
106670: LD_INT 1
106672: PLUS
106673: PPUSH
106674: LD_VAR 0 4
106678: PPUSH
106679: LD_VAR 0 2
106683: PPUSH
106684: CALL_OW 259
106688: PPUSH
106689: CALL_OW 2
106693: ST_TO_ADDR
106694: GO 106652
106696: POP
106697: POP
// if not tmp then
106698: LD_VAR 0 5
106702: NOT
106703: IFFALSE 106707
// exit ;
106705: GO 106727
// result := SortListByListDesc ( units , tmp ) ;
106707: LD_ADDR_VAR 0 3
106711: PUSH
106712: LD_VAR 0 1
106716: PPUSH
106717: LD_VAR 0 5
106721: PPUSH
106722: CALL_OW 77
106726: ST_TO_ADDR
// end ;
106727: LD_VAR 0 3
106731: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106732: LD_INT 0
106734: PPUSH
106735: PPUSH
106736: PPUSH
// x := GetX ( building ) ;
106737: LD_ADDR_VAR 0 4
106741: PUSH
106742: LD_VAR 0 2
106746: PPUSH
106747: CALL_OW 250
106751: ST_TO_ADDR
// y := GetY ( building ) ;
106752: LD_ADDR_VAR 0 5
106756: PUSH
106757: LD_VAR 0 2
106761: PPUSH
106762: CALL_OW 251
106766: ST_TO_ADDR
// if GetTaskList ( unit ) then
106767: LD_VAR 0 1
106771: PPUSH
106772: CALL_OW 437
106776: IFFALSE 106871
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106778: LD_STRING e
106780: PUSH
106781: LD_VAR 0 1
106785: PPUSH
106786: CALL_OW 437
106790: PUSH
106791: LD_INT 1
106793: ARRAY
106794: PUSH
106795: LD_INT 1
106797: ARRAY
106798: EQUAL
106799: PUSH
106800: LD_VAR 0 4
106804: PUSH
106805: LD_VAR 0 1
106809: PPUSH
106810: CALL_OW 437
106814: PUSH
106815: LD_INT 1
106817: ARRAY
106818: PUSH
106819: LD_INT 2
106821: ARRAY
106822: EQUAL
106823: AND
106824: PUSH
106825: LD_VAR 0 5
106829: PUSH
106830: LD_VAR 0 1
106834: PPUSH
106835: CALL_OW 437
106839: PUSH
106840: LD_INT 1
106842: ARRAY
106843: PUSH
106844: LD_INT 3
106846: ARRAY
106847: EQUAL
106848: AND
106849: IFFALSE 106861
// result := true else
106851: LD_ADDR_VAR 0 3
106855: PUSH
106856: LD_INT 1
106858: ST_TO_ADDR
106859: GO 106869
// result := false ;
106861: LD_ADDR_VAR 0 3
106865: PUSH
106866: LD_INT 0
106868: ST_TO_ADDR
// end else
106869: GO 106879
// result := false ;
106871: LD_ADDR_VAR 0 3
106875: PUSH
106876: LD_INT 0
106878: ST_TO_ADDR
// end ;
106879: LD_VAR 0 3
106883: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106884: LD_INT 0
106886: PPUSH
106887: PPUSH
106888: PPUSH
106889: PPUSH
// if not unit or not area then
106890: LD_VAR 0 1
106894: NOT
106895: PUSH
106896: LD_VAR 0 2
106900: NOT
106901: OR
106902: IFFALSE 106906
// exit ;
106904: GO 107070
// tmp := AreaToList ( area , i ) ;
106906: LD_ADDR_VAR 0 6
106910: PUSH
106911: LD_VAR 0 2
106915: PPUSH
106916: LD_VAR 0 5
106920: PPUSH
106921: CALL_OW 517
106925: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106926: LD_ADDR_VAR 0 5
106930: PUSH
106931: DOUBLE
106932: LD_INT 1
106934: DEC
106935: ST_TO_ADDR
106936: LD_VAR 0 6
106940: PUSH
106941: LD_INT 1
106943: ARRAY
106944: PUSH
106945: FOR_TO
106946: IFFALSE 107068
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106948: LD_ADDR_VAR 0 7
106952: PUSH
106953: LD_VAR 0 6
106957: PUSH
106958: LD_INT 1
106960: ARRAY
106961: PUSH
106962: LD_VAR 0 5
106966: ARRAY
106967: PUSH
106968: LD_VAR 0 6
106972: PUSH
106973: LD_INT 2
106975: ARRAY
106976: PUSH
106977: LD_VAR 0 5
106981: ARRAY
106982: PUSH
106983: EMPTY
106984: LIST
106985: LIST
106986: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106987: LD_VAR 0 7
106991: PUSH
106992: LD_INT 1
106994: ARRAY
106995: PPUSH
106996: LD_VAR 0 7
107000: PUSH
107001: LD_INT 2
107003: ARRAY
107004: PPUSH
107005: CALL_OW 428
107009: PUSH
107010: LD_INT 0
107012: EQUAL
107013: IFFALSE 107066
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107015: LD_VAR 0 1
107019: PPUSH
107020: LD_VAR 0 7
107024: PUSH
107025: LD_INT 1
107027: ARRAY
107028: PPUSH
107029: LD_VAR 0 7
107033: PUSH
107034: LD_INT 2
107036: ARRAY
107037: PPUSH
107038: LD_VAR 0 3
107042: PPUSH
107043: CALL_OW 48
// result := IsPlaced ( unit ) ;
107047: LD_ADDR_VAR 0 4
107051: PUSH
107052: LD_VAR 0 1
107056: PPUSH
107057: CALL_OW 305
107061: ST_TO_ADDR
// exit ;
107062: POP
107063: POP
107064: GO 107070
// end ; end ;
107066: GO 106945
107068: POP
107069: POP
// end ;
107070: LD_VAR 0 4
107074: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107075: LD_INT 0
107077: PPUSH
107078: PPUSH
107079: PPUSH
// if not side or side > 8 then
107080: LD_VAR 0 1
107084: NOT
107085: PUSH
107086: LD_VAR 0 1
107090: PUSH
107091: LD_INT 8
107093: GREATER
107094: OR
107095: IFFALSE 107099
// exit ;
107097: GO 107286
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107099: LD_ADDR_VAR 0 4
107103: PUSH
107104: LD_INT 22
107106: PUSH
107107: LD_VAR 0 1
107111: PUSH
107112: EMPTY
107113: LIST
107114: LIST
107115: PUSH
107116: LD_INT 21
107118: PUSH
107119: LD_INT 3
107121: PUSH
107122: EMPTY
107123: LIST
107124: LIST
107125: PUSH
107126: EMPTY
107127: LIST
107128: LIST
107129: PPUSH
107130: CALL_OW 69
107134: ST_TO_ADDR
// if not tmp then
107135: LD_VAR 0 4
107139: NOT
107140: IFFALSE 107144
// exit ;
107142: GO 107286
// enable_addtolog := true ;
107144: LD_ADDR_OWVAR 81
107148: PUSH
107149: LD_INT 1
107151: ST_TO_ADDR
// AddToLog ( [ ) ;
107152: LD_STRING [
107154: PPUSH
107155: CALL_OW 561
// for i in tmp do
107159: LD_ADDR_VAR 0 3
107163: PUSH
107164: LD_VAR 0 4
107168: PUSH
107169: FOR_IN
107170: IFFALSE 107277
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107172: LD_STRING [
107174: PUSH
107175: LD_VAR 0 3
107179: PPUSH
107180: CALL_OW 266
107184: STR
107185: PUSH
107186: LD_STRING , 
107188: STR
107189: PUSH
107190: LD_VAR 0 3
107194: PPUSH
107195: CALL_OW 250
107199: STR
107200: PUSH
107201: LD_STRING , 
107203: STR
107204: PUSH
107205: LD_VAR 0 3
107209: PPUSH
107210: CALL_OW 251
107214: STR
107215: PUSH
107216: LD_STRING , 
107218: STR
107219: PUSH
107220: LD_VAR 0 3
107224: PPUSH
107225: CALL_OW 254
107229: STR
107230: PUSH
107231: LD_STRING , 
107233: STR
107234: PUSH
107235: LD_VAR 0 3
107239: PPUSH
107240: LD_INT 1
107242: PPUSH
107243: CALL_OW 268
107247: STR
107248: PUSH
107249: LD_STRING , 
107251: STR
107252: PUSH
107253: LD_VAR 0 3
107257: PPUSH
107258: LD_INT 2
107260: PPUSH
107261: CALL_OW 268
107265: STR
107266: PUSH
107267: LD_STRING ],
107269: STR
107270: PPUSH
107271: CALL_OW 561
// end ;
107275: GO 107169
107277: POP
107278: POP
// AddToLog ( ]; ) ;
107279: LD_STRING ];
107281: PPUSH
107282: CALL_OW 561
// end ;
107286: LD_VAR 0 2
107290: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107291: LD_INT 0
107293: PPUSH
107294: PPUSH
107295: PPUSH
107296: PPUSH
107297: PPUSH
// if not area or not rate or not max then
107298: LD_VAR 0 1
107302: NOT
107303: PUSH
107304: LD_VAR 0 2
107308: NOT
107309: OR
107310: PUSH
107311: LD_VAR 0 4
107315: NOT
107316: OR
107317: IFFALSE 107321
// exit ;
107319: GO 107513
// while 1 do
107321: LD_INT 1
107323: IFFALSE 107513
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107325: LD_ADDR_VAR 0 9
107329: PUSH
107330: LD_VAR 0 1
107334: PPUSH
107335: LD_INT 1
107337: PPUSH
107338: CALL_OW 287
107342: PUSH
107343: LD_INT 10
107345: MUL
107346: ST_TO_ADDR
// r := rate / 10 ;
107347: LD_ADDR_VAR 0 7
107351: PUSH
107352: LD_VAR 0 2
107356: PUSH
107357: LD_INT 10
107359: DIVREAL
107360: ST_TO_ADDR
// time := 1 1$00 ;
107361: LD_ADDR_VAR 0 8
107365: PUSH
107366: LD_INT 2100
107368: ST_TO_ADDR
// if amount < min then
107369: LD_VAR 0 9
107373: PUSH
107374: LD_VAR 0 3
107378: LESS
107379: IFFALSE 107397
// r := r * 2 else
107381: LD_ADDR_VAR 0 7
107385: PUSH
107386: LD_VAR 0 7
107390: PUSH
107391: LD_INT 2
107393: MUL
107394: ST_TO_ADDR
107395: GO 107423
// if amount > max then
107397: LD_VAR 0 9
107401: PUSH
107402: LD_VAR 0 4
107406: GREATER
107407: IFFALSE 107423
// r := r / 2 ;
107409: LD_ADDR_VAR 0 7
107413: PUSH
107414: LD_VAR 0 7
107418: PUSH
107419: LD_INT 2
107421: DIVREAL
107422: ST_TO_ADDR
// time := time / r ;
107423: LD_ADDR_VAR 0 8
107427: PUSH
107428: LD_VAR 0 8
107432: PUSH
107433: LD_VAR 0 7
107437: DIVREAL
107438: ST_TO_ADDR
// if time < 0 then
107439: LD_VAR 0 8
107443: PUSH
107444: LD_INT 0
107446: LESS
107447: IFFALSE 107464
// time := time * - 1 ;
107449: LD_ADDR_VAR 0 8
107453: PUSH
107454: LD_VAR 0 8
107458: PUSH
107459: LD_INT 1
107461: NEG
107462: MUL
107463: ST_TO_ADDR
// wait ( time ) ;
107464: LD_VAR 0 8
107468: PPUSH
107469: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107473: LD_INT 35
107475: PPUSH
107476: LD_INT 875
107478: PPUSH
107479: CALL_OW 12
107483: PPUSH
107484: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107488: LD_INT 1
107490: PPUSH
107491: LD_INT 5
107493: PPUSH
107494: CALL_OW 12
107498: PPUSH
107499: LD_VAR 0 1
107503: PPUSH
107504: LD_INT 1
107506: PPUSH
107507: CALL_OW 55
// end ;
107511: GO 107321
// end ;
107513: LD_VAR 0 5
107517: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107518: LD_INT 0
107520: PPUSH
107521: PPUSH
107522: PPUSH
107523: PPUSH
107524: PPUSH
107525: PPUSH
107526: PPUSH
107527: PPUSH
// if not turrets or not factories then
107528: LD_VAR 0 1
107532: NOT
107533: PUSH
107534: LD_VAR 0 2
107538: NOT
107539: OR
107540: IFFALSE 107544
// exit ;
107542: GO 107851
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107544: LD_ADDR_VAR 0 10
107548: PUSH
107549: LD_INT 5
107551: PUSH
107552: LD_INT 6
107554: PUSH
107555: EMPTY
107556: LIST
107557: LIST
107558: PUSH
107559: LD_INT 2
107561: PUSH
107562: LD_INT 4
107564: PUSH
107565: EMPTY
107566: LIST
107567: LIST
107568: PUSH
107569: LD_INT 3
107571: PUSH
107572: LD_INT 5
107574: PUSH
107575: EMPTY
107576: LIST
107577: LIST
107578: PUSH
107579: EMPTY
107580: LIST
107581: LIST
107582: LIST
107583: PUSH
107584: LD_INT 24
107586: PUSH
107587: LD_INT 25
107589: PUSH
107590: EMPTY
107591: LIST
107592: LIST
107593: PUSH
107594: LD_INT 23
107596: PUSH
107597: LD_INT 27
107599: PUSH
107600: EMPTY
107601: LIST
107602: LIST
107603: PUSH
107604: EMPTY
107605: LIST
107606: LIST
107607: PUSH
107608: LD_INT 42
107610: PUSH
107611: LD_INT 43
107613: PUSH
107614: EMPTY
107615: LIST
107616: LIST
107617: PUSH
107618: LD_INT 44
107620: PUSH
107621: LD_INT 46
107623: PUSH
107624: EMPTY
107625: LIST
107626: LIST
107627: PUSH
107628: LD_INT 45
107630: PUSH
107631: LD_INT 47
107633: PUSH
107634: EMPTY
107635: LIST
107636: LIST
107637: PUSH
107638: EMPTY
107639: LIST
107640: LIST
107641: LIST
107642: PUSH
107643: EMPTY
107644: LIST
107645: LIST
107646: LIST
107647: ST_TO_ADDR
// result := [ ] ;
107648: LD_ADDR_VAR 0 3
107652: PUSH
107653: EMPTY
107654: ST_TO_ADDR
// for i in turrets do
107655: LD_ADDR_VAR 0 4
107659: PUSH
107660: LD_VAR 0 1
107664: PUSH
107665: FOR_IN
107666: IFFALSE 107849
// begin nat := GetNation ( i ) ;
107668: LD_ADDR_VAR 0 7
107672: PUSH
107673: LD_VAR 0 4
107677: PPUSH
107678: CALL_OW 248
107682: ST_TO_ADDR
// weapon := 0 ;
107683: LD_ADDR_VAR 0 8
107687: PUSH
107688: LD_INT 0
107690: ST_TO_ADDR
// if not nat then
107691: LD_VAR 0 7
107695: NOT
107696: IFFALSE 107700
// continue ;
107698: GO 107665
// for j in list [ nat ] do
107700: LD_ADDR_VAR 0 5
107704: PUSH
107705: LD_VAR 0 10
107709: PUSH
107710: LD_VAR 0 7
107714: ARRAY
107715: PUSH
107716: FOR_IN
107717: IFFALSE 107758
// if GetBWeapon ( i ) = j [ 1 ] then
107719: LD_VAR 0 4
107723: PPUSH
107724: CALL_OW 269
107728: PUSH
107729: LD_VAR 0 5
107733: PUSH
107734: LD_INT 1
107736: ARRAY
107737: EQUAL
107738: IFFALSE 107756
// begin weapon := j [ 2 ] ;
107740: LD_ADDR_VAR 0 8
107744: PUSH
107745: LD_VAR 0 5
107749: PUSH
107750: LD_INT 2
107752: ARRAY
107753: ST_TO_ADDR
// break ;
107754: GO 107758
// end ;
107756: GO 107716
107758: POP
107759: POP
// if not weapon then
107760: LD_VAR 0 8
107764: NOT
107765: IFFALSE 107769
// continue ;
107767: GO 107665
// for k in factories do
107769: LD_ADDR_VAR 0 6
107773: PUSH
107774: LD_VAR 0 2
107778: PUSH
107779: FOR_IN
107780: IFFALSE 107845
// begin weapons := AvailableWeaponList ( k ) ;
107782: LD_ADDR_VAR 0 9
107786: PUSH
107787: LD_VAR 0 6
107791: PPUSH
107792: CALL_OW 478
107796: ST_TO_ADDR
// if not weapons then
107797: LD_VAR 0 9
107801: NOT
107802: IFFALSE 107806
// continue ;
107804: GO 107779
// if weapon in weapons then
107806: LD_VAR 0 8
107810: PUSH
107811: LD_VAR 0 9
107815: IN
107816: IFFALSE 107843
// begin result := [ i , weapon ] ;
107818: LD_ADDR_VAR 0 3
107822: PUSH
107823: LD_VAR 0 4
107827: PUSH
107828: LD_VAR 0 8
107832: PUSH
107833: EMPTY
107834: LIST
107835: LIST
107836: ST_TO_ADDR
// exit ;
107837: POP
107838: POP
107839: POP
107840: POP
107841: GO 107851
// end ; end ;
107843: GO 107779
107845: POP
107846: POP
// end ;
107847: GO 107665
107849: POP
107850: POP
// end ;
107851: LD_VAR 0 3
107855: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107856: LD_INT 0
107858: PPUSH
// if not side or side > 8 then
107859: LD_VAR 0 3
107863: NOT
107864: PUSH
107865: LD_VAR 0 3
107869: PUSH
107870: LD_INT 8
107872: GREATER
107873: OR
107874: IFFALSE 107878
// exit ;
107876: GO 107937
// if not range then
107878: LD_VAR 0 4
107882: NOT
107883: IFFALSE 107894
// range := - 12 ;
107885: LD_ADDR_VAR 0 4
107889: PUSH
107890: LD_INT 12
107892: NEG
107893: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107894: LD_VAR 0 1
107898: PPUSH
107899: LD_VAR 0 2
107903: PPUSH
107904: LD_VAR 0 3
107908: PPUSH
107909: LD_VAR 0 4
107913: PPUSH
107914: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107918: LD_VAR 0 1
107922: PPUSH
107923: LD_VAR 0 2
107927: PPUSH
107928: LD_VAR 0 3
107932: PPUSH
107933: CALL_OW 331
// end ;
107937: LD_VAR 0 5
107941: RET
// export function Video ( mode ) ; begin
107942: LD_INT 0
107944: PPUSH
// ingame_video = mode ;
107945: LD_ADDR_OWVAR 52
107949: PUSH
107950: LD_VAR 0 1
107954: ST_TO_ADDR
// interface_hidden = mode ;
107955: LD_ADDR_OWVAR 54
107959: PUSH
107960: LD_VAR 0 1
107964: ST_TO_ADDR
// end ;
107965: LD_VAR 0 2
107969: RET
// export function Join ( array , element ) ; begin
107970: LD_INT 0
107972: PPUSH
// result := array ^ element ;
107973: LD_ADDR_VAR 0 3
107977: PUSH
107978: LD_VAR 0 1
107982: PUSH
107983: LD_VAR 0 2
107987: ADD
107988: ST_TO_ADDR
// end ;
107989: LD_VAR 0 3
107993: RET
// export function JoinUnion ( array , element ) ; begin
107994: LD_INT 0
107996: PPUSH
// result := array union element ;
107997: LD_ADDR_VAR 0 3
108001: PUSH
108002: LD_VAR 0 1
108006: PUSH
108007: LD_VAR 0 2
108011: UNION
108012: ST_TO_ADDR
// end ;
108013: LD_VAR 0 3
108017: RET
// export function GetBehemoths ( side ) ; begin
108018: LD_INT 0
108020: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
108021: LD_ADDR_VAR 0 2
108025: PUSH
108026: LD_INT 22
108028: PUSH
108029: LD_VAR 0 1
108033: PUSH
108034: EMPTY
108035: LIST
108036: LIST
108037: PUSH
108038: LD_INT 31
108040: PUSH
108041: LD_INT 25
108043: PUSH
108044: EMPTY
108045: LIST
108046: LIST
108047: PUSH
108048: EMPTY
108049: LIST
108050: LIST
108051: PPUSH
108052: CALL_OW 69
108056: ST_TO_ADDR
// end ;
108057: LD_VAR 0 2
108061: RET
// export function Shuffle ( array ) ; var i , index ; begin
108062: LD_INT 0
108064: PPUSH
108065: PPUSH
108066: PPUSH
// result := [ ] ;
108067: LD_ADDR_VAR 0 2
108071: PUSH
108072: EMPTY
108073: ST_TO_ADDR
// if not array then
108074: LD_VAR 0 1
108078: NOT
108079: IFFALSE 108083
// exit ;
108081: GO 108182
// Randomize ;
108083: CALL_OW 10
// for i = array downto 1 do
108087: LD_ADDR_VAR 0 3
108091: PUSH
108092: DOUBLE
108093: LD_VAR 0 1
108097: INC
108098: ST_TO_ADDR
108099: LD_INT 1
108101: PUSH
108102: FOR_DOWNTO
108103: IFFALSE 108180
// begin index := rand ( 1 , array ) ;
108105: LD_ADDR_VAR 0 4
108109: PUSH
108110: LD_INT 1
108112: PPUSH
108113: LD_VAR 0 1
108117: PPUSH
108118: CALL_OW 12
108122: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108123: LD_ADDR_VAR 0 2
108127: PUSH
108128: LD_VAR 0 2
108132: PPUSH
108133: LD_VAR 0 2
108137: PUSH
108138: LD_INT 1
108140: PLUS
108141: PPUSH
108142: LD_VAR 0 1
108146: PUSH
108147: LD_VAR 0 4
108151: ARRAY
108152: PPUSH
108153: CALL_OW 2
108157: ST_TO_ADDR
// array := Delete ( array , index ) ;
108158: LD_ADDR_VAR 0 1
108162: PUSH
108163: LD_VAR 0 1
108167: PPUSH
108168: LD_VAR 0 4
108172: PPUSH
108173: CALL_OW 3
108177: ST_TO_ADDR
// end ;
108178: GO 108102
108180: POP
108181: POP
// end ;
108182: LD_VAR 0 2
108186: RET
// export function GetBaseMaterials ( base ) ; begin
108187: LD_INT 0
108189: PPUSH
// result := [ 0 , 0 , 0 ] ;
108190: LD_ADDR_VAR 0 2
108194: PUSH
108195: LD_INT 0
108197: PUSH
108198: LD_INT 0
108200: PUSH
108201: LD_INT 0
108203: PUSH
108204: EMPTY
108205: LIST
108206: LIST
108207: LIST
108208: ST_TO_ADDR
// if not base then
108209: LD_VAR 0 1
108213: NOT
108214: IFFALSE 108218
// exit ;
108216: GO 108267
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108218: LD_ADDR_VAR 0 2
108222: PUSH
108223: LD_VAR 0 1
108227: PPUSH
108228: LD_INT 1
108230: PPUSH
108231: CALL_OW 275
108235: PUSH
108236: LD_VAR 0 1
108240: PPUSH
108241: LD_INT 2
108243: PPUSH
108244: CALL_OW 275
108248: PUSH
108249: LD_VAR 0 1
108253: PPUSH
108254: LD_INT 3
108256: PPUSH
108257: CALL_OW 275
108261: PUSH
108262: EMPTY
108263: LIST
108264: LIST
108265: LIST
108266: ST_TO_ADDR
// end ; end_of_file end_of_file
108267: LD_VAR 0 2
108271: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
108272: GO 108274
108274: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108275: LD_STRING initStreamRollete();
108277: PPUSH
108278: CALL_OW 559
// InitStreamMode ;
108282: CALL 108291 0 0
// DefineStreamItems ( ) ;
108286: CALL 108731 0 0
// end ;
108290: END
// function InitStreamMode ; begin
108291: LD_INT 0
108293: PPUSH
// streamModeActive := false ;
108294: LD_ADDR_EXP 153
108298: PUSH
108299: LD_INT 0
108301: ST_TO_ADDR
// normalCounter := 36 ;
108302: LD_ADDR_EXP 154
108306: PUSH
108307: LD_INT 36
108309: ST_TO_ADDR
// hardcoreCounter := 16 ;
108310: LD_ADDR_EXP 155
108314: PUSH
108315: LD_INT 16
108317: ST_TO_ADDR
// sRocket := false ;
108318: LD_ADDR_EXP 158
108322: PUSH
108323: LD_INT 0
108325: ST_TO_ADDR
// sSpeed := false ;
108326: LD_ADDR_EXP 157
108330: PUSH
108331: LD_INT 0
108333: ST_TO_ADDR
// sEngine := false ;
108334: LD_ADDR_EXP 159
108338: PUSH
108339: LD_INT 0
108341: ST_TO_ADDR
// sSpec := false ;
108342: LD_ADDR_EXP 156
108346: PUSH
108347: LD_INT 0
108349: ST_TO_ADDR
// sLevel := false ;
108350: LD_ADDR_EXP 160
108354: PUSH
108355: LD_INT 0
108357: ST_TO_ADDR
// sArmoury := false ;
108358: LD_ADDR_EXP 161
108362: PUSH
108363: LD_INT 0
108365: ST_TO_ADDR
// sRadar := false ;
108366: LD_ADDR_EXP 162
108370: PUSH
108371: LD_INT 0
108373: ST_TO_ADDR
// sBunker := false ;
108374: LD_ADDR_EXP 163
108378: PUSH
108379: LD_INT 0
108381: ST_TO_ADDR
// sHack := false ;
108382: LD_ADDR_EXP 164
108386: PUSH
108387: LD_INT 0
108389: ST_TO_ADDR
// sFire := false ;
108390: LD_ADDR_EXP 165
108394: PUSH
108395: LD_INT 0
108397: ST_TO_ADDR
// sRefresh := false ;
108398: LD_ADDR_EXP 166
108402: PUSH
108403: LD_INT 0
108405: ST_TO_ADDR
// sExp := false ;
108406: LD_ADDR_EXP 167
108410: PUSH
108411: LD_INT 0
108413: ST_TO_ADDR
// sDepot := false ;
108414: LD_ADDR_EXP 168
108418: PUSH
108419: LD_INT 0
108421: ST_TO_ADDR
// sFlag := false ;
108422: LD_ADDR_EXP 169
108426: PUSH
108427: LD_INT 0
108429: ST_TO_ADDR
// sKamikadze := false ;
108430: LD_ADDR_EXP 177
108434: PUSH
108435: LD_INT 0
108437: ST_TO_ADDR
// sTroll := false ;
108438: LD_ADDR_EXP 178
108442: PUSH
108443: LD_INT 0
108445: ST_TO_ADDR
// sSlow := false ;
108446: LD_ADDR_EXP 179
108450: PUSH
108451: LD_INT 0
108453: ST_TO_ADDR
// sLack := false ;
108454: LD_ADDR_EXP 180
108458: PUSH
108459: LD_INT 0
108461: ST_TO_ADDR
// sTank := false ;
108462: LD_ADDR_EXP 182
108466: PUSH
108467: LD_INT 0
108469: ST_TO_ADDR
// sRemote := false ;
108470: LD_ADDR_EXP 183
108474: PUSH
108475: LD_INT 0
108477: ST_TO_ADDR
// sPowell := false ;
108478: LD_ADDR_EXP 184
108482: PUSH
108483: LD_INT 0
108485: ST_TO_ADDR
// sTeleport := false ;
108486: LD_ADDR_EXP 187
108490: PUSH
108491: LD_INT 0
108493: ST_TO_ADDR
// sOilTower := false ;
108494: LD_ADDR_EXP 189
108498: PUSH
108499: LD_INT 0
108501: ST_TO_ADDR
// sShovel := false ;
108502: LD_ADDR_EXP 190
108506: PUSH
108507: LD_INT 0
108509: ST_TO_ADDR
// sSheik := false ;
108510: LD_ADDR_EXP 191
108514: PUSH
108515: LD_INT 0
108517: ST_TO_ADDR
// sEarthquake := false ;
108518: LD_ADDR_EXP 193
108522: PUSH
108523: LD_INT 0
108525: ST_TO_ADDR
// sAI := false ;
108526: LD_ADDR_EXP 194
108530: PUSH
108531: LD_INT 0
108533: ST_TO_ADDR
// sCargo := false ;
108534: LD_ADDR_EXP 197
108538: PUSH
108539: LD_INT 0
108541: ST_TO_ADDR
// sDLaser := false ;
108542: LD_ADDR_EXP 198
108546: PUSH
108547: LD_INT 0
108549: ST_TO_ADDR
// sExchange := false ;
108550: LD_ADDR_EXP 199
108554: PUSH
108555: LD_INT 0
108557: ST_TO_ADDR
// sFac := false ;
108558: LD_ADDR_EXP 200
108562: PUSH
108563: LD_INT 0
108565: ST_TO_ADDR
// sPower := false ;
108566: LD_ADDR_EXP 201
108570: PUSH
108571: LD_INT 0
108573: ST_TO_ADDR
// sRandom := false ;
108574: LD_ADDR_EXP 202
108578: PUSH
108579: LD_INT 0
108581: ST_TO_ADDR
// sShield := false ;
108582: LD_ADDR_EXP 203
108586: PUSH
108587: LD_INT 0
108589: ST_TO_ADDR
// sTime := false ;
108590: LD_ADDR_EXP 204
108594: PUSH
108595: LD_INT 0
108597: ST_TO_ADDR
// sTools := false ;
108598: LD_ADDR_EXP 205
108602: PUSH
108603: LD_INT 0
108605: ST_TO_ADDR
// sSold := false ;
108606: LD_ADDR_EXP 170
108610: PUSH
108611: LD_INT 0
108613: ST_TO_ADDR
// sDiff := false ;
108614: LD_ADDR_EXP 171
108618: PUSH
108619: LD_INT 0
108621: ST_TO_ADDR
// sFog := false ;
108622: LD_ADDR_EXP 174
108626: PUSH
108627: LD_INT 0
108629: ST_TO_ADDR
// sReset := false ;
108630: LD_ADDR_EXP 175
108634: PUSH
108635: LD_INT 0
108637: ST_TO_ADDR
// sSun := false ;
108638: LD_ADDR_EXP 176
108642: PUSH
108643: LD_INT 0
108645: ST_TO_ADDR
// sTiger := false ;
108646: LD_ADDR_EXP 172
108650: PUSH
108651: LD_INT 0
108653: ST_TO_ADDR
// sBomb := false ;
108654: LD_ADDR_EXP 173
108658: PUSH
108659: LD_INT 0
108661: ST_TO_ADDR
// sWound := false ;
108662: LD_ADDR_EXP 181
108666: PUSH
108667: LD_INT 0
108669: ST_TO_ADDR
// sBetray := false ;
108670: LD_ADDR_EXP 185
108674: PUSH
108675: LD_INT 0
108677: ST_TO_ADDR
// sContamin := false ;
108678: LD_ADDR_EXP 186
108682: PUSH
108683: LD_INT 0
108685: ST_TO_ADDR
// sOil := false ;
108686: LD_ADDR_EXP 188
108690: PUSH
108691: LD_INT 0
108693: ST_TO_ADDR
// sStu := false ;
108694: LD_ADDR_EXP 192
108698: PUSH
108699: LD_INT 0
108701: ST_TO_ADDR
// sBazooka := false ;
108702: LD_ADDR_EXP 195
108706: PUSH
108707: LD_INT 0
108709: ST_TO_ADDR
// sMortar := false ;
108710: LD_ADDR_EXP 196
108714: PUSH
108715: LD_INT 0
108717: ST_TO_ADDR
// sRanger := false ;
108718: LD_ADDR_EXP 206
108722: PUSH
108723: LD_INT 0
108725: ST_TO_ADDR
// end ;
108726: LD_VAR 0 1
108730: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
108731: LD_INT 0
108733: PPUSH
108734: PPUSH
108735: PPUSH
108736: PPUSH
108737: PPUSH
// result := [ ] ;
108738: LD_ADDR_VAR 0 1
108742: PUSH
108743: EMPTY
108744: ST_TO_ADDR
// if campaign_id = 1 then
108745: LD_OWVAR 69
108749: PUSH
108750: LD_INT 1
108752: EQUAL
108753: IFFALSE 111691
// begin case mission_number of 1 :
108755: LD_OWVAR 70
108759: PUSH
108760: LD_INT 1
108762: DOUBLE
108763: EQUAL
108764: IFTRUE 108768
108766: GO 108832
108768: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
108769: LD_ADDR_VAR 0 1
108773: PUSH
108774: LD_INT 2
108776: PUSH
108777: LD_INT 4
108779: PUSH
108780: LD_INT 11
108782: PUSH
108783: LD_INT 12
108785: PUSH
108786: LD_INT 15
108788: PUSH
108789: LD_INT 16
108791: PUSH
108792: LD_INT 22
108794: PUSH
108795: LD_INT 23
108797: PUSH
108798: LD_INT 26
108800: PUSH
108801: EMPTY
108802: LIST
108803: LIST
108804: LIST
108805: LIST
108806: LIST
108807: LIST
108808: LIST
108809: LIST
108810: LIST
108811: PUSH
108812: LD_INT 101
108814: PUSH
108815: LD_INT 102
108817: PUSH
108818: LD_INT 106
108820: PUSH
108821: EMPTY
108822: LIST
108823: LIST
108824: LIST
108825: PUSH
108826: EMPTY
108827: LIST
108828: LIST
108829: ST_TO_ADDR
108830: GO 111689
108832: LD_INT 2
108834: DOUBLE
108835: EQUAL
108836: IFTRUE 108840
108838: GO 108912
108840: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
108841: LD_ADDR_VAR 0 1
108845: PUSH
108846: LD_INT 2
108848: PUSH
108849: LD_INT 4
108851: PUSH
108852: LD_INT 11
108854: PUSH
108855: LD_INT 12
108857: PUSH
108858: LD_INT 15
108860: PUSH
108861: LD_INT 16
108863: PUSH
108864: LD_INT 22
108866: PUSH
108867: LD_INT 23
108869: PUSH
108870: LD_INT 26
108872: PUSH
108873: EMPTY
108874: LIST
108875: LIST
108876: LIST
108877: LIST
108878: LIST
108879: LIST
108880: LIST
108881: LIST
108882: LIST
108883: PUSH
108884: LD_INT 101
108886: PUSH
108887: LD_INT 102
108889: PUSH
108890: LD_INT 105
108892: PUSH
108893: LD_INT 106
108895: PUSH
108896: LD_INT 108
108898: PUSH
108899: EMPTY
108900: LIST
108901: LIST
108902: LIST
108903: LIST
108904: LIST
108905: PUSH
108906: EMPTY
108907: LIST
108908: LIST
108909: ST_TO_ADDR
108910: GO 111689
108912: LD_INT 3
108914: DOUBLE
108915: EQUAL
108916: IFTRUE 108920
108918: GO 108996
108920: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
108921: LD_ADDR_VAR 0 1
108925: PUSH
108926: LD_INT 2
108928: PUSH
108929: LD_INT 4
108931: PUSH
108932: LD_INT 5
108934: PUSH
108935: LD_INT 11
108937: PUSH
108938: LD_INT 12
108940: PUSH
108941: LD_INT 15
108943: PUSH
108944: LD_INT 16
108946: PUSH
108947: LD_INT 22
108949: PUSH
108950: LD_INT 26
108952: PUSH
108953: LD_INT 36
108955: PUSH
108956: EMPTY
108957: LIST
108958: LIST
108959: LIST
108960: LIST
108961: LIST
108962: LIST
108963: LIST
108964: LIST
108965: LIST
108966: LIST
108967: PUSH
108968: LD_INT 101
108970: PUSH
108971: LD_INT 102
108973: PUSH
108974: LD_INT 105
108976: PUSH
108977: LD_INT 106
108979: PUSH
108980: LD_INT 108
108982: PUSH
108983: EMPTY
108984: LIST
108985: LIST
108986: LIST
108987: LIST
108988: LIST
108989: PUSH
108990: EMPTY
108991: LIST
108992: LIST
108993: ST_TO_ADDR
108994: GO 111689
108996: LD_INT 4
108998: DOUBLE
108999: EQUAL
109000: IFTRUE 109004
109002: GO 109088
109004: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
109005: LD_ADDR_VAR 0 1
109009: PUSH
109010: LD_INT 2
109012: PUSH
109013: LD_INT 4
109015: PUSH
109016: LD_INT 5
109018: PUSH
109019: LD_INT 8
109021: PUSH
109022: LD_INT 11
109024: PUSH
109025: LD_INT 12
109027: PUSH
109028: LD_INT 15
109030: PUSH
109031: LD_INT 16
109033: PUSH
109034: LD_INT 22
109036: PUSH
109037: LD_INT 23
109039: PUSH
109040: LD_INT 26
109042: PUSH
109043: LD_INT 36
109045: PUSH
109046: EMPTY
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: LIST
109056: LIST
109057: LIST
109058: LIST
109059: PUSH
109060: LD_INT 101
109062: PUSH
109063: LD_INT 102
109065: PUSH
109066: LD_INT 105
109068: PUSH
109069: LD_INT 106
109071: PUSH
109072: LD_INT 108
109074: PUSH
109075: EMPTY
109076: LIST
109077: LIST
109078: LIST
109079: LIST
109080: LIST
109081: PUSH
109082: EMPTY
109083: LIST
109084: LIST
109085: ST_TO_ADDR
109086: GO 111689
109088: LD_INT 5
109090: DOUBLE
109091: EQUAL
109092: IFTRUE 109096
109094: GO 109196
109096: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
109097: LD_ADDR_VAR 0 1
109101: PUSH
109102: LD_INT 2
109104: PUSH
109105: LD_INT 4
109107: PUSH
109108: LD_INT 5
109110: PUSH
109111: LD_INT 6
109113: PUSH
109114: LD_INT 8
109116: PUSH
109117: LD_INT 11
109119: PUSH
109120: LD_INT 12
109122: PUSH
109123: LD_INT 15
109125: PUSH
109126: LD_INT 16
109128: PUSH
109129: LD_INT 22
109131: PUSH
109132: LD_INT 23
109134: PUSH
109135: LD_INT 25
109137: PUSH
109138: LD_INT 26
109140: PUSH
109141: LD_INT 36
109143: PUSH
109144: EMPTY
109145: LIST
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: PUSH
109160: LD_INT 101
109162: PUSH
109163: LD_INT 102
109165: PUSH
109166: LD_INT 105
109168: PUSH
109169: LD_INT 106
109171: PUSH
109172: LD_INT 108
109174: PUSH
109175: LD_INT 109
109177: PUSH
109178: LD_INT 112
109180: PUSH
109181: EMPTY
109182: LIST
109183: LIST
109184: LIST
109185: LIST
109186: LIST
109187: LIST
109188: LIST
109189: PUSH
109190: EMPTY
109191: LIST
109192: LIST
109193: ST_TO_ADDR
109194: GO 111689
109196: LD_INT 6
109198: DOUBLE
109199: EQUAL
109200: IFTRUE 109204
109202: GO 109324
109204: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
109205: LD_ADDR_VAR 0 1
109209: PUSH
109210: LD_INT 2
109212: PUSH
109213: LD_INT 4
109215: PUSH
109216: LD_INT 5
109218: PUSH
109219: LD_INT 6
109221: PUSH
109222: LD_INT 8
109224: PUSH
109225: LD_INT 11
109227: PUSH
109228: LD_INT 12
109230: PUSH
109231: LD_INT 15
109233: PUSH
109234: LD_INT 16
109236: PUSH
109237: LD_INT 20
109239: PUSH
109240: LD_INT 21
109242: PUSH
109243: LD_INT 22
109245: PUSH
109246: LD_INT 23
109248: PUSH
109249: LD_INT 25
109251: PUSH
109252: LD_INT 26
109254: PUSH
109255: LD_INT 30
109257: PUSH
109258: LD_INT 31
109260: PUSH
109261: LD_INT 32
109263: PUSH
109264: LD_INT 36
109266: PUSH
109267: EMPTY
109268: LIST
109269: LIST
109270: LIST
109271: LIST
109272: LIST
109273: LIST
109274: LIST
109275: LIST
109276: LIST
109277: LIST
109278: LIST
109279: LIST
109280: LIST
109281: LIST
109282: LIST
109283: LIST
109284: LIST
109285: LIST
109286: LIST
109287: PUSH
109288: LD_INT 101
109290: PUSH
109291: LD_INT 102
109293: PUSH
109294: LD_INT 105
109296: PUSH
109297: LD_INT 106
109299: PUSH
109300: LD_INT 108
109302: PUSH
109303: LD_INT 109
109305: PUSH
109306: LD_INT 112
109308: PUSH
109309: EMPTY
109310: LIST
109311: LIST
109312: LIST
109313: LIST
109314: LIST
109315: LIST
109316: LIST
109317: PUSH
109318: EMPTY
109319: LIST
109320: LIST
109321: ST_TO_ADDR
109322: GO 111689
109324: LD_INT 7
109326: DOUBLE
109327: EQUAL
109328: IFTRUE 109332
109330: GO 109432
109332: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
109333: LD_ADDR_VAR 0 1
109337: PUSH
109338: LD_INT 2
109340: PUSH
109341: LD_INT 4
109343: PUSH
109344: LD_INT 5
109346: PUSH
109347: LD_INT 7
109349: PUSH
109350: LD_INT 11
109352: PUSH
109353: LD_INT 12
109355: PUSH
109356: LD_INT 15
109358: PUSH
109359: LD_INT 16
109361: PUSH
109362: LD_INT 20
109364: PUSH
109365: LD_INT 21
109367: PUSH
109368: LD_INT 22
109370: PUSH
109371: LD_INT 23
109373: PUSH
109374: LD_INT 25
109376: PUSH
109377: LD_INT 26
109379: PUSH
109380: EMPTY
109381: LIST
109382: LIST
109383: LIST
109384: LIST
109385: LIST
109386: LIST
109387: LIST
109388: LIST
109389: LIST
109390: LIST
109391: LIST
109392: LIST
109393: LIST
109394: LIST
109395: PUSH
109396: LD_INT 101
109398: PUSH
109399: LD_INT 102
109401: PUSH
109402: LD_INT 103
109404: PUSH
109405: LD_INT 105
109407: PUSH
109408: LD_INT 106
109410: PUSH
109411: LD_INT 108
109413: PUSH
109414: LD_INT 112
109416: PUSH
109417: EMPTY
109418: LIST
109419: LIST
109420: LIST
109421: LIST
109422: LIST
109423: LIST
109424: LIST
109425: PUSH
109426: EMPTY
109427: LIST
109428: LIST
109429: ST_TO_ADDR
109430: GO 111689
109432: LD_INT 8
109434: DOUBLE
109435: EQUAL
109436: IFTRUE 109440
109438: GO 109568
109440: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
109441: LD_ADDR_VAR 0 1
109445: PUSH
109446: LD_INT 2
109448: PUSH
109449: LD_INT 4
109451: PUSH
109452: LD_INT 5
109454: PUSH
109455: LD_INT 6
109457: PUSH
109458: LD_INT 7
109460: PUSH
109461: LD_INT 8
109463: PUSH
109464: LD_INT 11
109466: PUSH
109467: LD_INT 12
109469: PUSH
109470: LD_INT 15
109472: PUSH
109473: LD_INT 16
109475: PUSH
109476: LD_INT 20
109478: PUSH
109479: LD_INT 21
109481: PUSH
109482: LD_INT 22
109484: PUSH
109485: LD_INT 23
109487: PUSH
109488: LD_INT 25
109490: PUSH
109491: LD_INT 26
109493: PUSH
109494: LD_INT 30
109496: PUSH
109497: LD_INT 31
109499: PUSH
109500: LD_INT 32
109502: PUSH
109503: LD_INT 36
109505: PUSH
109506: EMPTY
109507: LIST
109508: LIST
109509: LIST
109510: LIST
109511: LIST
109512: LIST
109513: LIST
109514: LIST
109515: LIST
109516: LIST
109517: LIST
109518: LIST
109519: LIST
109520: LIST
109521: LIST
109522: LIST
109523: LIST
109524: LIST
109525: LIST
109526: LIST
109527: PUSH
109528: LD_INT 101
109530: PUSH
109531: LD_INT 102
109533: PUSH
109534: LD_INT 103
109536: PUSH
109537: LD_INT 105
109539: PUSH
109540: LD_INT 106
109542: PUSH
109543: LD_INT 108
109545: PUSH
109546: LD_INT 109
109548: PUSH
109549: LD_INT 112
109551: PUSH
109552: EMPTY
109553: LIST
109554: LIST
109555: LIST
109556: LIST
109557: LIST
109558: LIST
109559: LIST
109560: LIST
109561: PUSH
109562: EMPTY
109563: LIST
109564: LIST
109565: ST_TO_ADDR
109566: GO 111689
109568: LD_INT 9
109570: DOUBLE
109571: EQUAL
109572: IFTRUE 109576
109574: GO 109712
109576: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
109577: LD_ADDR_VAR 0 1
109581: PUSH
109582: LD_INT 2
109584: PUSH
109585: LD_INT 4
109587: PUSH
109588: LD_INT 5
109590: PUSH
109591: LD_INT 6
109593: PUSH
109594: LD_INT 7
109596: PUSH
109597: LD_INT 8
109599: PUSH
109600: LD_INT 11
109602: PUSH
109603: LD_INT 12
109605: PUSH
109606: LD_INT 15
109608: PUSH
109609: LD_INT 16
109611: PUSH
109612: LD_INT 20
109614: PUSH
109615: LD_INT 21
109617: PUSH
109618: LD_INT 22
109620: PUSH
109621: LD_INT 23
109623: PUSH
109624: LD_INT 25
109626: PUSH
109627: LD_INT 26
109629: PUSH
109630: LD_INT 28
109632: PUSH
109633: LD_INT 30
109635: PUSH
109636: LD_INT 31
109638: PUSH
109639: LD_INT 32
109641: PUSH
109642: LD_INT 36
109644: PUSH
109645: EMPTY
109646: LIST
109647: LIST
109648: LIST
109649: LIST
109650: LIST
109651: LIST
109652: LIST
109653: LIST
109654: LIST
109655: LIST
109656: LIST
109657: LIST
109658: LIST
109659: LIST
109660: LIST
109661: LIST
109662: LIST
109663: LIST
109664: LIST
109665: LIST
109666: LIST
109667: PUSH
109668: LD_INT 101
109670: PUSH
109671: LD_INT 102
109673: PUSH
109674: LD_INT 103
109676: PUSH
109677: LD_INT 105
109679: PUSH
109680: LD_INT 106
109682: PUSH
109683: LD_INT 108
109685: PUSH
109686: LD_INT 109
109688: PUSH
109689: LD_INT 112
109691: PUSH
109692: LD_INT 114
109694: PUSH
109695: EMPTY
109696: LIST
109697: LIST
109698: LIST
109699: LIST
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: LIST
109705: PUSH
109706: EMPTY
109707: LIST
109708: LIST
109709: ST_TO_ADDR
109710: GO 111689
109712: LD_INT 10
109714: DOUBLE
109715: EQUAL
109716: IFTRUE 109720
109718: GO 109904
109720: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
109721: LD_ADDR_VAR 0 1
109725: PUSH
109726: LD_INT 2
109728: PUSH
109729: LD_INT 4
109731: PUSH
109732: LD_INT 5
109734: PUSH
109735: LD_INT 6
109737: PUSH
109738: LD_INT 7
109740: PUSH
109741: LD_INT 8
109743: PUSH
109744: LD_INT 9
109746: PUSH
109747: LD_INT 10
109749: PUSH
109750: LD_INT 11
109752: PUSH
109753: LD_INT 12
109755: PUSH
109756: LD_INT 13
109758: PUSH
109759: LD_INT 14
109761: PUSH
109762: LD_INT 15
109764: PUSH
109765: LD_INT 16
109767: PUSH
109768: LD_INT 17
109770: PUSH
109771: LD_INT 18
109773: PUSH
109774: LD_INT 19
109776: PUSH
109777: LD_INT 20
109779: PUSH
109780: LD_INT 21
109782: PUSH
109783: LD_INT 22
109785: PUSH
109786: LD_INT 23
109788: PUSH
109789: LD_INT 24
109791: PUSH
109792: LD_INT 25
109794: PUSH
109795: LD_INT 26
109797: PUSH
109798: LD_INT 28
109800: PUSH
109801: LD_INT 30
109803: PUSH
109804: LD_INT 31
109806: PUSH
109807: LD_INT 32
109809: PUSH
109810: LD_INT 36
109812: PUSH
109813: EMPTY
109814: LIST
109815: LIST
109816: LIST
109817: LIST
109818: LIST
109819: LIST
109820: LIST
109821: LIST
109822: LIST
109823: LIST
109824: LIST
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: LIST
109831: LIST
109832: LIST
109833: LIST
109834: LIST
109835: LIST
109836: LIST
109837: LIST
109838: LIST
109839: LIST
109840: LIST
109841: LIST
109842: LIST
109843: PUSH
109844: LD_INT 101
109846: PUSH
109847: LD_INT 102
109849: PUSH
109850: LD_INT 103
109852: PUSH
109853: LD_INT 104
109855: PUSH
109856: LD_INT 105
109858: PUSH
109859: LD_INT 106
109861: PUSH
109862: LD_INT 107
109864: PUSH
109865: LD_INT 108
109867: PUSH
109868: LD_INT 109
109870: PUSH
109871: LD_INT 110
109873: PUSH
109874: LD_INT 111
109876: PUSH
109877: LD_INT 112
109879: PUSH
109880: LD_INT 114
109882: PUSH
109883: EMPTY
109884: LIST
109885: LIST
109886: LIST
109887: LIST
109888: LIST
109889: LIST
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: PUSH
109898: EMPTY
109899: LIST
109900: LIST
109901: ST_TO_ADDR
109902: GO 111689
109904: LD_INT 11
109906: DOUBLE
109907: EQUAL
109908: IFTRUE 109912
109910: GO 110104
109912: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
109913: LD_ADDR_VAR 0 1
109917: PUSH
109918: LD_INT 2
109920: PUSH
109921: LD_INT 3
109923: PUSH
109924: LD_INT 4
109926: PUSH
109927: LD_INT 5
109929: PUSH
109930: LD_INT 6
109932: PUSH
109933: LD_INT 7
109935: PUSH
109936: LD_INT 8
109938: PUSH
109939: LD_INT 9
109941: PUSH
109942: LD_INT 10
109944: PUSH
109945: LD_INT 11
109947: PUSH
109948: LD_INT 12
109950: PUSH
109951: LD_INT 13
109953: PUSH
109954: LD_INT 14
109956: PUSH
109957: LD_INT 15
109959: PUSH
109960: LD_INT 16
109962: PUSH
109963: LD_INT 17
109965: PUSH
109966: LD_INT 18
109968: PUSH
109969: LD_INT 19
109971: PUSH
109972: LD_INT 20
109974: PUSH
109975: LD_INT 21
109977: PUSH
109978: LD_INT 22
109980: PUSH
109981: LD_INT 23
109983: PUSH
109984: LD_INT 24
109986: PUSH
109987: LD_INT 25
109989: PUSH
109990: LD_INT 26
109992: PUSH
109993: LD_INT 28
109995: PUSH
109996: LD_INT 30
109998: PUSH
109999: LD_INT 31
110001: PUSH
110002: LD_INT 32
110004: PUSH
110005: LD_INT 34
110007: PUSH
110008: LD_INT 36
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: LIST
110015: LIST
110016: LIST
110017: LIST
110018: LIST
110019: LIST
110020: LIST
110021: LIST
110022: LIST
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: LIST
110039: LIST
110040: LIST
110041: LIST
110042: LIST
110043: PUSH
110044: LD_INT 101
110046: PUSH
110047: LD_INT 102
110049: PUSH
110050: LD_INT 103
110052: PUSH
110053: LD_INT 104
110055: PUSH
110056: LD_INT 105
110058: PUSH
110059: LD_INT 106
110061: PUSH
110062: LD_INT 107
110064: PUSH
110065: LD_INT 108
110067: PUSH
110068: LD_INT 109
110070: PUSH
110071: LD_INT 110
110073: PUSH
110074: LD_INT 111
110076: PUSH
110077: LD_INT 112
110079: PUSH
110080: LD_INT 114
110082: PUSH
110083: EMPTY
110084: LIST
110085: LIST
110086: LIST
110087: LIST
110088: LIST
110089: LIST
110090: LIST
110091: LIST
110092: LIST
110093: LIST
110094: LIST
110095: LIST
110096: LIST
110097: PUSH
110098: EMPTY
110099: LIST
110100: LIST
110101: ST_TO_ADDR
110102: GO 111689
110104: LD_INT 12
110106: DOUBLE
110107: EQUAL
110108: IFTRUE 110112
110110: GO 110320
110112: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
110113: LD_ADDR_VAR 0 1
110117: PUSH
110118: LD_INT 1
110120: PUSH
110121: LD_INT 2
110123: PUSH
110124: LD_INT 3
110126: PUSH
110127: LD_INT 4
110129: PUSH
110130: LD_INT 5
110132: PUSH
110133: LD_INT 6
110135: PUSH
110136: LD_INT 7
110138: PUSH
110139: LD_INT 8
110141: PUSH
110142: LD_INT 9
110144: PUSH
110145: LD_INT 10
110147: PUSH
110148: LD_INT 11
110150: PUSH
110151: LD_INT 12
110153: PUSH
110154: LD_INT 13
110156: PUSH
110157: LD_INT 14
110159: PUSH
110160: LD_INT 15
110162: PUSH
110163: LD_INT 16
110165: PUSH
110166: LD_INT 17
110168: PUSH
110169: LD_INT 18
110171: PUSH
110172: LD_INT 19
110174: PUSH
110175: LD_INT 20
110177: PUSH
110178: LD_INT 21
110180: PUSH
110181: LD_INT 22
110183: PUSH
110184: LD_INT 23
110186: PUSH
110187: LD_INT 24
110189: PUSH
110190: LD_INT 25
110192: PUSH
110193: LD_INT 26
110195: PUSH
110196: LD_INT 27
110198: PUSH
110199: LD_INT 28
110201: PUSH
110202: LD_INT 30
110204: PUSH
110205: LD_INT 31
110207: PUSH
110208: LD_INT 32
110210: PUSH
110211: LD_INT 33
110213: PUSH
110214: LD_INT 34
110216: PUSH
110217: LD_INT 36
110219: PUSH
110220: EMPTY
110221: LIST
110222: LIST
110223: LIST
110224: LIST
110225: LIST
110226: LIST
110227: LIST
110228: LIST
110229: LIST
110230: LIST
110231: LIST
110232: LIST
110233: LIST
110234: LIST
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: LIST
110254: LIST
110255: PUSH
110256: LD_INT 101
110258: PUSH
110259: LD_INT 102
110261: PUSH
110262: LD_INT 103
110264: PUSH
110265: LD_INT 104
110267: PUSH
110268: LD_INT 105
110270: PUSH
110271: LD_INT 106
110273: PUSH
110274: LD_INT 107
110276: PUSH
110277: LD_INT 108
110279: PUSH
110280: LD_INT 109
110282: PUSH
110283: LD_INT 110
110285: PUSH
110286: LD_INT 111
110288: PUSH
110289: LD_INT 112
110291: PUSH
110292: LD_INT 113
110294: PUSH
110295: LD_INT 114
110297: PUSH
110298: EMPTY
110299: LIST
110300: LIST
110301: LIST
110302: LIST
110303: LIST
110304: LIST
110305: LIST
110306: LIST
110307: LIST
110308: LIST
110309: LIST
110310: LIST
110311: LIST
110312: LIST
110313: PUSH
110314: EMPTY
110315: LIST
110316: LIST
110317: ST_TO_ADDR
110318: GO 111689
110320: LD_INT 13
110322: DOUBLE
110323: EQUAL
110324: IFTRUE 110328
110326: GO 110524
110328: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
110329: LD_ADDR_VAR 0 1
110333: PUSH
110334: LD_INT 1
110336: PUSH
110337: LD_INT 2
110339: PUSH
110340: LD_INT 3
110342: PUSH
110343: LD_INT 4
110345: PUSH
110346: LD_INT 5
110348: PUSH
110349: LD_INT 8
110351: PUSH
110352: LD_INT 9
110354: PUSH
110355: LD_INT 10
110357: PUSH
110358: LD_INT 11
110360: PUSH
110361: LD_INT 12
110363: PUSH
110364: LD_INT 14
110366: PUSH
110367: LD_INT 15
110369: PUSH
110370: LD_INT 16
110372: PUSH
110373: LD_INT 17
110375: PUSH
110376: LD_INT 18
110378: PUSH
110379: LD_INT 19
110381: PUSH
110382: LD_INT 20
110384: PUSH
110385: LD_INT 21
110387: PUSH
110388: LD_INT 22
110390: PUSH
110391: LD_INT 23
110393: PUSH
110394: LD_INT 24
110396: PUSH
110397: LD_INT 25
110399: PUSH
110400: LD_INT 26
110402: PUSH
110403: LD_INT 27
110405: PUSH
110406: LD_INT 28
110408: PUSH
110409: LD_INT 30
110411: PUSH
110412: LD_INT 31
110414: PUSH
110415: LD_INT 32
110417: PUSH
110418: LD_INT 33
110420: PUSH
110421: LD_INT 34
110423: PUSH
110424: LD_INT 36
110426: PUSH
110427: EMPTY
110428: LIST
110429: LIST
110430: LIST
110431: LIST
110432: LIST
110433: LIST
110434: LIST
110435: LIST
110436: LIST
110437: LIST
110438: LIST
110439: LIST
110440: LIST
110441: LIST
110442: LIST
110443: LIST
110444: LIST
110445: LIST
110446: LIST
110447: LIST
110448: LIST
110449: LIST
110450: LIST
110451: LIST
110452: LIST
110453: LIST
110454: LIST
110455: LIST
110456: LIST
110457: LIST
110458: LIST
110459: PUSH
110460: LD_INT 101
110462: PUSH
110463: LD_INT 102
110465: PUSH
110466: LD_INT 103
110468: PUSH
110469: LD_INT 104
110471: PUSH
110472: LD_INT 105
110474: PUSH
110475: LD_INT 106
110477: PUSH
110478: LD_INT 107
110480: PUSH
110481: LD_INT 108
110483: PUSH
110484: LD_INT 109
110486: PUSH
110487: LD_INT 110
110489: PUSH
110490: LD_INT 111
110492: PUSH
110493: LD_INT 112
110495: PUSH
110496: LD_INT 113
110498: PUSH
110499: LD_INT 114
110501: PUSH
110502: EMPTY
110503: LIST
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: LIST
110509: LIST
110510: LIST
110511: LIST
110512: LIST
110513: LIST
110514: LIST
110515: LIST
110516: LIST
110517: PUSH
110518: EMPTY
110519: LIST
110520: LIST
110521: ST_TO_ADDR
110522: GO 111689
110524: LD_INT 14
110526: DOUBLE
110527: EQUAL
110528: IFTRUE 110532
110530: GO 110744
110532: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
110533: LD_ADDR_VAR 0 1
110537: PUSH
110538: LD_INT 1
110540: PUSH
110541: LD_INT 2
110543: PUSH
110544: LD_INT 3
110546: PUSH
110547: LD_INT 4
110549: PUSH
110550: LD_INT 5
110552: PUSH
110553: LD_INT 6
110555: PUSH
110556: LD_INT 7
110558: PUSH
110559: LD_INT 8
110561: PUSH
110562: LD_INT 9
110564: PUSH
110565: LD_INT 10
110567: PUSH
110568: LD_INT 11
110570: PUSH
110571: LD_INT 12
110573: PUSH
110574: LD_INT 13
110576: PUSH
110577: LD_INT 14
110579: PUSH
110580: LD_INT 15
110582: PUSH
110583: LD_INT 16
110585: PUSH
110586: LD_INT 17
110588: PUSH
110589: LD_INT 18
110591: PUSH
110592: LD_INT 19
110594: PUSH
110595: LD_INT 20
110597: PUSH
110598: LD_INT 21
110600: PUSH
110601: LD_INT 22
110603: PUSH
110604: LD_INT 23
110606: PUSH
110607: LD_INT 24
110609: PUSH
110610: LD_INT 25
110612: PUSH
110613: LD_INT 26
110615: PUSH
110616: LD_INT 27
110618: PUSH
110619: LD_INT 28
110621: PUSH
110622: LD_INT 29
110624: PUSH
110625: LD_INT 30
110627: PUSH
110628: LD_INT 31
110630: PUSH
110631: LD_INT 32
110633: PUSH
110634: LD_INT 33
110636: PUSH
110637: LD_INT 34
110639: PUSH
110640: LD_INT 36
110642: PUSH
110643: EMPTY
110644: LIST
110645: LIST
110646: LIST
110647: LIST
110648: LIST
110649: LIST
110650: LIST
110651: LIST
110652: LIST
110653: LIST
110654: LIST
110655: LIST
110656: LIST
110657: LIST
110658: LIST
110659: LIST
110660: LIST
110661: LIST
110662: LIST
110663: LIST
110664: LIST
110665: LIST
110666: LIST
110667: LIST
110668: LIST
110669: LIST
110670: LIST
110671: LIST
110672: LIST
110673: LIST
110674: LIST
110675: LIST
110676: LIST
110677: LIST
110678: LIST
110679: PUSH
110680: LD_INT 101
110682: PUSH
110683: LD_INT 102
110685: PUSH
110686: LD_INT 103
110688: PUSH
110689: LD_INT 104
110691: PUSH
110692: LD_INT 105
110694: PUSH
110695: LD_INT 106
110697: PUSH
110698: LD_INT 107
110700: PUSH
110701: LD_INT 108
110703: PUSH
110704: LD_INT 109
110706: PUSH
110707: LD_INT 110
110709: PUSH
110710: LD_INT 111
110712: PUSH
110713: LD_INT 112
110715: PUSH
110716: LD_INT 113
110718: PUSH
110719: LD_INT 114
110721: PUSH
110722: EMPTY
110723: LIST
110724: LIST
110725: LIST
110726: LIST
110727: LIST
110728: LIST
110729: LIST
110730: LIST
110731: LIST
110732: LIST
110733: LIST
110734: LIST
110735: LIST
110736: LIST
110737: PUSH
110738: EMPTY
110739: LIST
110740: LIST
110741: ST_TO_ADDR
110742: GO 111689
110744: LD_INT 15
110746: DOUBLE
110747: EQUAL
110748: IFTRUE 110752
110750: GO 110964
110752: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
110753: LD_ADDR_VAR 0 1
110757: PUSH
110758: LD_INT 1
110760: PUSH
110761: LD_INT 2
110763: PUSH
110764: LD_INT 3
110766: PUSH
110767: LD_INT 4
110769: PUSH
110770: LD_INT 5
110772: PUSH
110773: LD_INT 6
110775: PUSH
110776: LD_INT 7
110778: PUSH
110779: LD_INT 8
110781: PUSH
110782: LD_INT 9
110784: PUSH
110785: LD_INT 10
110787: PUSH
110788: LD_INT 11
110790: PUSH
110791: LD_INT 12
110793: PUSH
110794: LD_INT 13
110796: PUSH
110797: LD_INT 14
110799: PUSH
110800: LD_INT 15
110802: PUSH
110803: LD_INT 16
110805: PUSH
110806: LD_INT 17
110808: PUSH
110809: LD_INT 18
110811: PUSH
110812: LD_INT 19
110814: PUSH
110815: LD_INT 20
110817: PUSH
110818: LD_INT 21
110820: PUSH
110821: LD_INT 22
110823: PUSH
110824: LD_INT 23
110826: PUSH
110827: LD_INT 24
110829: PUSH
110830: LD_INT 25
110832: PUSH
110833: LD_INT 26
110835: PUSH
110836: LD_INT 27
110838: PUSH
110839: LD_INT 28
110841: PUSH
110842: LD_INT 29
110844: PUSH
110845: LD_INT 30
110847: PUSH
110848: LD_INT 31
110850: PUSH
110851: LD_INT 32
110853: PUSH
110854: LD_INT 33
110856: PUSH
110857: LD_INT 34
110859: PUSH
110860: LD_INT 36
110862: PUSH
110863: EMPTY
110864: LIST
110865: LIST
110866: LIST
110867: LIST
110868: LIST
110869: LIST
110870: LIST
110871: LIST
110872: LIST
110873: LIST
110874: LIST
110875: LIST
110876: LIST
110877: LIST
110878: LIST
110879: LIST
110880: LIST
110881: LIST
110882: LIST
110883: LIST
110884: LIST
110885: LIST
110886: LIST
110887: LIST
110888: LIST
110889: LIST
110890: LIST
110891: LIST
110892: LIST
110893: LIST
110894: LIST
110895: LIST
110896: LIST
110897: LIST
110898: LIST
110899: PUSH
110900: LD_INT 101
110902: PUSH
110903: LD_INT 102
110905: PUSH
110906: LD_INT 103
110908: PUSH
110909: LD_INT 104
110911: PUSH
110912: LD_INT 105
110914: PUSH
110915: LD_INT 106
110917: PUSH
110918: LD_INT 107
110920: PUSH
110921: LD_INT 108
110923: PUSH
110924: LD_INT 109
110926: PUSH
110927: LD_INT 110
110929: PUSH
110930: LD_INT 111
110932: PUSH
110933: LD_INT 112
110935: PUSH
110936: LD_INT 113
110938: PUSH
110939: LD_INT 114
110941: PUSH
110942: EMPTY
110943: LIST
110944: LIST
110945: LIST
110946: LIST
110947: LIST
110948: LIST
110949: LIST
110950: LIST
110951: LIST
110952: LIST
110953: LIST
110954: LIST
110955: LIST
110956: LIST
110957: PUSH
110958: EMPTY
110959: LIST
110960: LIST
110961: ST_TO_ADDR
110962: GO 111689
110964: LD_INT 16
110966: DOUBLE
110967: EQUAL
110968: IFTRUE 110972
110970: GO 111096
110972: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
110973: LD_ADDR_VAR 0 1
110977: PUSH
110978: LD_INT 2
110980: PUSH
110981: LD_INT 4
110983: PUSH
110984: LD_INT 5
110986: PUSH
110987: LD_INT 7
110989: PUSH
110990: LD_INT 11
110992: PUSH
110993: LD_INT 12
110995: PUSH
110996: LD_INT 15
110998: PUSH
110999: LD_INT 16
111001: PUSH
111002: LD_INT 20
111004: PUSH
111005: LD_INT 21
111007: PUSH
111008: LD_INT 22
111010: PUSH
111011: LD_INT 23
111013: PUSH
111014: LD_INT 25
111016: PUSH
111017: LD_INT 26
111019: PUSH
111020: LD_INT 30
111022: PUSH
111023: LD_INT 31
111025: PUSH
111026: LD_INT 32
111028: PUSH
111029: LD_INT 33
111031: PUSH
111032: LD_INT 34
111034: PUSH
111035: EMPTY
111036: LIST
111037: LIST
111038: LIST
111039: LIST
111040: LIST
111041: LIST
111042: LIST
111043: LIST
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: PUSH
111056: LD_INT 101
111058: PUSH
111059: LD_INT 102
111061: PUSH
111062: LD_INT 103
111064: PUSH
111065: LD_INT 106
111067: PUSH
111068: LD_INT 108
111070: PUSH
111071: LD_INT 112
111073: PUSH
111074: LD_INT 113
111076: PUSH
111077: LD_INT 114
111079: PUSH
111080: EMPTY
111081: LIST
111082: LIST
111083: LIST
111084: LIST
111085: LIST
111086: LIST
111087: LIST
111088: LIST
111089: PUSH
111090: EMPTY
111091: LIST
111092: LIST
111093: ST_TO_ADDR
111094: GO 111689
111096: LD_INT 17
111098: DOUBLE
111099: EQUAL
111100: IFTRUE 111104
111102: GO 111316
111104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
111105: LD_ADDR_VAR 0 1
111109: PUSH
111110: LD_INT 1
111112: PUSH
111113: LD_INT 2
111115: PUSH
111116: LD_INT 3
111118: PUSH
111119: LD_INT 4
111121: PUSH
111122: LD_INT 5
111124: PUSH
111125: LD_INT 6
111127: PUSH
111128: LD_INT 7
111130: PUSH
111131: LD_INT 8
111133: PUSH
111134: LD_INT 9
111136: PUSH
111137: LD_INT 10
111139: PUSH
111140: LD_INT 11
111142: PUSH
111143: LD_INT 12
111145: PUSH
111146: LD_INT 13
111148: PUSH
111149: LD_INT 14
111151: PUSH
111152: LD_INT 15
111154: PUSH
111155: LD_INT 16
111157: PUSH
111158: LD_INT 17
111160: PUSH
111161: LD_INT 18
111163: PUSH
111164: LD_INT 19
111166: PUSH
111167: LD_INT 20
111169: PUSH
111170: LD_INT 21
111172: PUSH
111173: LD_INT 22
111175: PUSH
111176: LD_INT 23
111178: PUSH
111179: LD_INT 24
111181: PUSH
111182: LD_INT 25
111184: PUSH
111185: LD_INT 26
111187: PUSH
111188: LD_INT 27
111190: PUSH
111191: LD_INT 28
111193: PUSH
111194: LD_INT 29
111196: PUSH
111197: LD_INT 30
111199: PUSH
111200: LD_INT 31
111202: PUSH
111203: LD_INT 32
111205: PUSH
111206: LD_INT 33
111208: PUSH
111209: LD_INT 34
111211: PUSH
111212: LD_INT 36
111214: PUSH
111215: EMPTY
111216: LIST
111217: LIST
111218: LIST
111219: LIST
111220: LIST
111221: LIST
111222: LIST
111223: LIST
111224: LIST
111225: LIST
111226: LIST
111227: LIST
111228: LIST
111229: LIST
111230: LIST
111231: LIST
111232: LIST
111233: LIST
111234: LIST
111235: LIST
111236: LIST
111237: LIST
111238: LIST
111239: LIST
111240: LIST
111241: LIST
111242: LIST
111243: LIST
111244: LIST
111245: LIST
111246: LIST
111247: LIST
111248: LIST
111249: LIST
111250: LIST
111251: PUSH
111252: LD_INT 101
111254: PUSH
111255: LD_INT 102
111257: PUSH
111258: LD_INT 103
111260: PUSH
111261: LD_INT 104
111263: PUSH
111264: LD_INT 105
111266: PUSH
111267: LD_INT 106
111269: PUSH
111270: LD_INT 107
111272: PUSH
111273: LD_INT 108
111275: PUSH
111276: LD_INT 109
111278: PUSH
111279: LD_INT 110
111281: PUSH
111282: LD_INT 111
111284: PUSH
111285: LD_INT 112
111287: PUSH
111288: LD_INT 113
111290: PUSH
111291: LD_INT 114
111293: PUSH
111294: EMPTY
111295: LIST
111296: LIST
111297: LIST
111298: LIST
111299: LIST
111300: LIST
111301: LIST
111302: LIST
111303: LIST
111304: LIST
111305: LIST
111306: LIST
111307: LIST
111308: LIST
111309: PUSH
111310: EMPTY
111311: LIST
111312: LIST
111313: ST_TO_ADDR
111314: GO 111689
111316: LD_INT 18
111318: DOUBLE
111319: EQUAL
111320: IFTRUE 111324
111322: GO 111460
111324: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
111325: LD_ADDR_VAR 0 1
111329: PUSH
111330: LD_INT 2
111332: PUSH
111333: LD_INT 4
111335: PUSH
111336: LD_INT 5
111338: PUSH
111339: LD_INT 7
111341: PUSH
111342: LD_INT 11
111344: PUSH
111345: LD_INT 12
111347: PUSH
111348: LD_INT 15
111350: PUSH
111351: LD_INT 16
111353: PUSH
111354: LD_INT 20
111356: PUSH
111357: LD_INT 21
111359: PUSH
111360: LD_INT 22
111362: PUSH
111363: LD_INT 23
111365: PUSH
111366: LD_INT 25
111368: PUSH
111369: LD_INT 26
111371: PUSH
111372: LD_INT 30
111374: PUSH
111375: LD_INT 31
111377: PUSH
111378: LD_INT 32
111380: PUSH
111381: LD_INT 33
111383: PUSH
111384: LD_INT 34
111386: PUSH
111387: LD_INT 35
111389: PUSH
111390: LD_INT 36
111392: PUSH
111393: EMPTY
111394: LIST
111395: LIST
111396: LIST
111397: LIST
111398: LIST
111399: LIST
111400: LIST
111401: LIST
111402: LIST
111403: LIST
111404: LIST
111405: LIST
111406: LIST
111407: LIST
111408: LIST
111409: LIST
111410: LIST
111411: LIST
111412: LIST
111413: LIST
111414: LIST
111415: PUSH
111416: LD_INT 101
111418: PUSH
111419: LD_INT 102
111421: PUSH
111422: LD_INT 103
111424: PUSH
111425: LD_INT 106
111427: PUSH
111428: LD_INT 108
111430: PUSH
111431: LD_INT 112
111433: PUSH
111434: LD_INT 113
111436: PUSH
111437: LD_INT 114
111439: PUSH
111440: LD_INT 115
111442: PUSH
111443: EMPTY
111444: LIST
111445: LIST
111446: LIST
111447: LIST
111448: LIST
111449: LIST
111450: LIST
111451: LIST
111452: LIST
111453: PUSH
111454: EMPTY
111455: LIST
111456: LIST
111457: ST_TO_ADDR
111458: GO 111689
111460: LD_INT 19
111462: DOUBLE
111463: EQUAL
111464: IFTRUE 111468
111466: GO 111688
111468: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
111469: LD_ADDR_VAR 0 1
111473: PUSH
111474: LD_INT 1
111476: PUSH
111477: LD_INT 2
111479: PUSH
111480: LD_INT 3
111482: PUSH
111483: LD_INT 4
111485: PUSH
111486: LD_INT 5
111488: PUSH
111489: LD_INT 6
111491: PUSH
111492: LD_INT 7
111494: PUSH
111495: LD_INT 8
111497: PUSH
111498: LD_INT 9
111500: PUSH
111501: LD_INT 10
111503: PUSH
111504: LD_INT 11
111506: PUSH
111507: LD_INT 12
111509: PUSH
111510: LD_INT 13
111512: PUSH
111513: LD_INT 14
111515: PUSH
111516: LD_INT 15
111518: PUSH
111519: LD_INT 16
111521: PUSH
111522: LD_INT 17
111524: PUSH
111525: LD_INT 18
111527: PUSH
111528: LD_INT 19
111530: PUSH
111531: LD_INT 20
111533: PUSH
111534: LD_INT 21
111536: PUSH
111537: LD_INT 22
111539: PUSH
111540: LD_INT 23
111542: PUSH
111543: LD_INT 24
111545: PUSH
111546: LD_INT 25
111548: PUSH
111549: LD_INT 26
111551: PUSH
111552: LD_INT 27
111554: PUSH
111555: LD_INT 28
111557: PUSH
111558: LD_INT 29
111560: PUSH
111561: LD_INT 30
111563: PUSH
111564: LD_INT 31
111566: PUSH
111567: LD_INT 32
111569: PUSH
111570: LD_INT 33
111572: PUSH
111573: LD_INT 34
111575: PUSH
111576: LD_INT 35
111578: PUSH
111579: LD_INT 36
111581: PUSH
111582: EMPTY
111583: LIST
111584: LIST
111585: LIST
111586: LIST
111587: LIST
111588: LIST
111589: LIST
111590: LIST
111591: LIST
111592: LIST
111593: LIST
111594: LIST
111595: LIST
111596: LIST
111597: LIST
111598: LIST
111599: LIST
111600: LIST
111601: LIST
111602: LIST
111603: LIST
111604: LIST
111605: LIST
111606: LIST
111607: LIST
111608: LIST
111609: LIST
111610: LIST
111611: LIST
111612: LIST
111613: LIST
111614: LIST
111615: LIST
111616: LIST
111617: LIST
111618: LIST
111619: PUSH
111620: LD_INT 101
111622: PUSH
111623: LD_INT 102
111625: PUSH
111626: LD_INT 103
111628: PUSH
111629: LD_INT 104
111631: PUSH
111632: LD_INT 105
111634: PUSH
111635: LD_INT 106
111637: PUSH
111638: LD_INT 107
111640: PUSH
111641: LD_INT 108
111643: PUSH
111644: LD_INT 109
111646: PUSH
111647: LD_INT 110
111649: PUSH
111650: LD_INT 111
111652: PUSH
111653: LD_INT 112
111655: PUSH
111656: LD_INT 113
111658: PUSH
111659: LD_INT 114
111661: PUSH
111662: LD_INT 115
111664: PUSH
111665: EMPTY
111666: LIST
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: LIST
111675: LIST
111676: LIST
111677: LIST
111678: LIST
111679: LIST
111680: LIST
111681: PUSH
111682: EMPTY
111683: LIST
111684: LIST
111685: ST_TO_ADDR
111686: GO 111689
111688: POP
// end else
111689: GO 111726
// if campaign_id = 5 then
111691: LD_OWVAR 69
111695: PUSH
111696: LD_INT 5
111698: EQUAL
111699: IFFALSE 111726
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
111701: LD_ADDR_VAR 0 1
111705: PUSH
111706: LD_INT 1
111708: PUSH
111709: LD_INT 2
111711: PUSH
111712: EMPTY
111713: LIST
111714: LIST
111715: PUSH
111716: LD_INT 100
111718: PUSH
111719: EMPTY
111720: LIST
111721: PUSH
111722: EMPTY
111723: LIST
111724: LIST
111725: ST_TO_ADDR
// end ; if result then
111726: LD_VAR 0 1
111730: IFFALSE 112019
// begin normal :=  ;
111732: LD_ADDR_VAR 0 3
111736: PUSH
111737: LD_STRING 
111739: ST_TO_ADDR
// hardcore :=  ;
111740: LD_ADDR_VAR 0 4
111744: PUSH
111745: LD_STRING 
111747: ST_TO_ADDR
// for i = 1 to normalCounter do
111748: LD_ADDR_VAR 0 5
111752: PUSH
111753: DOUBLE
111754: LD_INT 1
111756: DEC
111757: ST_TO_ADDR
111758: LD_EXP 154
111762: PUSH
111763: FOR_TO
111764: IFFALSE 111865
// begin tmp := 0 ;
111766: LD_ADDR_VAR 0 2
111770: PUSH
111771: LD_STRING 0
111773: ST_TO_ADDR
// if result [ 1 ] then
111774: LD_VAR 0 1
111778: PUSH
111779: LD_INT 1
111781: ARRAY
111782: IFFALSE 111847
// if result [ 1 ] [ 1 ] = i then
111784: LD_VAR 0 1
111788: PUSH
111789: LD_INT 1
111791: ARRAY
111792: PUSH
111793: LD_INT 1
111795: ARRAY
111796: PUSH
111797: LD_VAR 0 5
111801: EQUAL
111802: IFFALSE 111847
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111804: LD_ADDR_VAR 0 1
111808: PUSH
111809: LD_VAR 0 1
111813: PPUSH
111814: LD_INT 1
111816: PPUSH
111817: LD_VAR 0 1
111821: PUSH
111822: LD_INT 1
111824: ARRAY
111825: PPUSH
111826: LD_INT 1
111828: PPUSH
111829: CALL_OW 3
111833: PPUSH
111834: CALL_OW 1
111838: ST_TO_ADDR
// tmp := 1 ;
111839: LD_ADDR_VAR 0 2
111843: PUSH
111844: LD_STRING 1
111846: ST_TO_ADDR
// end ; normal := normal & tmp ;
111847: LD_ADDR_VAR 0 3
111851: PUSH
111852: LD_VAR 0 3
111856: PUSH
111857: LD_VAR 0 2
111861: STR
111862: ST_TO_ADDR
// end ;
111863: GO 111763
111865: POP
111866: POP
// for i = 1 to hardcoreCounter do
111867: LD_ADDR_VAR 0 5
111871: PUSH
111872: DOUBLE
111873: LD_INT 1
111875: DEC
111876: ST_TO_ADDR
111877: LD_EXP 155
111881: PUSH
111882: FOR_TO
111883: IFFALSE 111988
// begin tmp := 0 ;
111885: LD_ADDR_VAR 0 2
111889: PUSH
111890: LD_STRING 0
111892: ST_TO_ADDR
// if result [ 2 ] then
111893: LD_VAR 0 1
111897: PUSH
111898: LD_INT 2
111900: ARRAY
111901: IFFALSE 111970
// if result [ 2 ] [ 1 ] = 100 + i then
111903: LD_VAR 0 1
111907: PUSH
111908: LD_INT 2
111910: ARRAY
111911: PUSH
111912: LD_INT 1
111914: ARRAY
111915: PUSH
111916: LD_INT 100
111918: PUSH
111919: LD_VAR 0 5
111923: PLUS
111924: EQUAL
111925: IFFALSE 111970
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111927: LD_ADDR_VAR 0 1
111931: PUSH
111932: LD_VAR 0 1
111936: PPUSH
111937: LD_INT 2
111939: PPUSH
111940: LD_VAR 0 1
111944: PUSH
111945: LD_INT 2
111947: ARRAY
111948: PPUSH
111949: LD_INT 1
111951: PPUSH
111952: CALL_OW 3
111956: PPUSH
111957: CALL_OW 1
111961: ST_TO_ADDR
// tmp := 1 ;
111962: LD_ADDR_VAR 0 2
111966: PUSH
111967: LD_STRING 1
111969: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111970: LD_ADDR_VAR 0 4
111974: PUSH
111975: LD_VAR 0 4
111979: PUSH
111980: LD_VAR 0 2
111984: STR
111985: ST_TO_ADDR
// end ;
111986: GO 111882
111988: POP
111989: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
111990: LD_STRING getStreamItemsFromMission("
111992: PUSH
111993: LD_VAR 0 3
111997: STR
111998: PUSH
111999: LD_STRING ","
112001: STR
112002: PUSH
112003: LD_VAR 0 4
112007: STR
112008: PUSH
112009: LD_STRING ")
112011: STR
112012: PPUSH
112013: CALL_OW 559
// end else
112017: GO 112026
// ToLua ( getStreamItemsFromMission("","") ) ;
112019: LD_STRING getStreamItemsFromMission("","")
112021: PPUSH
112022: CALL_OW 559
// end ;
112026: LD_VAR 0 1
112030: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
112031: LD_VAR 0 2
112035: PUSH
112036: LD_INT 100
112038: EQUAL
112039: IFFALSE 112988
// begin if not StreamModeActive then
112041: LD_EXP 153
112045: NOT
112046: IFFALSE 112056
// StreamModeActive := true ;
112048: LD_ADDR_EXP 153
112052: PUSH
112053: LD_INT 1
112055: ST_TO_ADDR
// if p3 = 0 then
112056: LD_VAR 0 3
112060: PUSH
112061: LD_INT 0
112063: EQUAL
112064: IFFALSE 112070
// InitStreamMode ;
112066: CALL 108291 0 0
// if p3 = 1 then
112070: LD_VAR 0 3
112074: PUSH
112075: LD_INT 1
112077: EQUAL
112078: IFFALSE 112088
// sRocket := true ;
112080: LD_ADDR_EXP 158
112084: PUSH
112085: LD_INT 1
112087: ST_TO_ADDR
// if p3 = 2 then
112088: LD_VAR 0 3
112092: PUSH
112093: LD_INT 2
112095: EQUAL
112096: IFFALSE 112106
// sSpeed := true ;
112098: LD_ADDR_EXP 157
112102: PUSH
112103: LD_INT 1
112105: ST_TO_ADDR
// if p3 = 3 then
112106: LD_VAR 0 3
112110: PUSH
112111: LD_INT 3
112113: EQUAL
112114: IFFALSE 112124
// sEngine := true ;
112116: LD_ADDR_EXP 159
112120: PUSH
112121: LD_INT 1
112123: ST_TO_ADDR
// if p3 = 4 then
112124: LD_VAR 0 3
112128: PUSH
112129: LD_INT 4
112131: EQUAL
112132: IFFALSE 112142
// sSpec := true ;
112134: LD_ADDR_EXP 156
112138: PUSH
112139: LD_INT 1
112141: ST_TO_ADDR
// if p3 = 5 then
112142: LD_VAR 0 3
112146: PUSH
112147: LD_INT 5
112149: EQUAL
112150: IFFALSE 112160
// sLevel := true ;
112152: LD_ADDR_EXP 160
112156: PUSH
112157: LD_INT 1
112159: ST_TO_ADDR
// if p3 = 6 then
112160: LD_VAR 0 3
112164: PUSH
112165: LD_INT 6
112167: EQUAL
112168: IFFALSE 112178
// sArmoury := true ;
112170: LD_ADDR_EXP 161
112174: PUSH
112175: LD_INT 1
112177: ST_TO_ADDR
// if p3 = 7 then
112178: LD_VAR 0 3
112182: PUSH
112183: LD_INT 7
112185: EQUAL
112186: IFFALSE 112196
// sRadar := true ;
112188: LD_ADDR_EXP 162
112192: PUSH
112193: LD_INT 1
112195: ST_TO_ADDR
// if p3 = 8 then
112196: LD_VAR 0 3
112200: PUSH
112201: LD_INT 8
112203: EQUAL
112204: IFFALSE 112214
// sBunker := true ;
112206: LD_ADDR_EXP 163
112210: PUSH
112211: LD_INT 1
112213: ST_TO_ADDR
// if p3 = 9 then
112214: LD_VAR 0 3
112218: PUSH
112219: LD_INT 9
112221: EQUAL
112222: IFFALSE 112232
// sHack := true ;
112224: LD_ADDR_EXP 164
112228: PUSH
112229: LD_INT 1
112231: ST_TO_ADDR
// if p3 = 10 then
112232: LD_VAR 0 3
112236: PUSH
112237: LD_INT 10
112239: EQUAL
112240: IFFALSE 112250
// sFire := true ;
112242: LD_ADDR_EXP 165
112246: PUSH
112247: LD_INT 1
112249: ST_TO_ADDR
// if p3 = 11 then
112250: LD_VAR 0 3
112254: PUSH
112255: LD_INT 11
112257: EQUAL
112258: IFFALSE 112268
// sRefresh := true ;
112260: LD_ADDR_EXP 166
112264: PUSH
112265: LD_INT 1
112267: ST_TO_ADDR
// if p3 = 12 then
112268: LD_VAR 0 3
112272: PUSH
112273: LD_INT 12
112275: EQUAL
112276: IFFALSE 112286
// sExp := true ;
112278: LD_ADDR_EXP 167
112282: PUSH
112283: LD_INT 1
112285: ST_TO_ADDR
// if p3 = 13 then
112286: LD_VAR 0 3
112290: PUSH
112291: LD_INT 13
112293: EQUAL
112294: IFFALSE 112304
// sDepot := true ;
112296: LD_ADDR_EXP 168
112300: PUSH
112301: LD_INT 1
112303: ST_TO_ADDR
// if p3 = 14 then
112304: LD_VAR 0 3
112308: PUSH
112309: LD_INT 14
112311: EQUAL
112312: IFFALSE 112322
// sFlag := true ;
112314: LD_ADDR_EXP 169
112318: PUSH
112319: LD_INT 1
112321: ST_TO_ADDR
// if p3 = 15 then
112322: LD_VAR 0 3
112326: PUSH
112327: LD_INT 15
112329: EQUAL
112330: IFFALSE 112340
// sKamikadze := true ;
112332: LD_ADDR_EXP 177
112336: PUSH
112337: LD_INT 1
112339: ST_TO_ADDR
// if p3 = 16 then
112340: LD_VAR 0 3
112344: PUSH
112345: LD_INT 16
112347: EQUAL
112348: IFFALSE 112358
// sTroll := true ;
112350: LD_ADDR_EXP 178
112354: PUSH
112355: LD_INT 1
112357: ST_TO_ADDR
// if p3 = 17 then
112358: LD_VAR 0 3
112362: PUSH
112363: LD_INT 17
112365: EQUAL
112366: IFFALSE 112376
// sSlow := true ;
112368: LD_ADDR_EXP 179
112372: PUSH
112373: LD_INT 1
112375: ST_TO_ADDR
// if p3 = 18 then
112376: LD_VAR 0 3
112380: PUSH
112381: LD_INT 18
112383: EQUAL
112384: IFFALSE 112394
// sLack := true ;
112386: LD_ADDR_EXP 180
112390: PUSH
112391: LD_INT 1
112393: ST_TO_ADDR
// if p3 = 19 then
112394: LD_VAR 0 3
112398: PUSH
112399: LD_INT 19
112401: EQUAL
112402: IFFALSE 112412
// sTank := true ;
112404: LD_ADDR_EXP 182
112408: PUSH
112409: LD_INT 1
112411: ST_TO_ADDR
// if p3 = 20 then
112412: LD_VAR 0 3
112416: PUSH
112417: LD_INT 20
112419: EQUAL
112420: IFFALSE 112430
// sRemote := true ;
112422: LD_ADDR_EXP 183
112426: PUSH
112427: LD_INT 1
112429: ST_TO_ADDR
// if p3 = 21 then
112430: LD_VAR 0 3
112434: PUSH
112435: LD_INT 21
112437: EQUAL
112438: IFFALSE 112448
// sPowell := true ;
112440: LD_ADDR_EXP 184
112444: PUSH
112445: LD_INT 1
112447: ST_TO_ADDR
// if p3 = 22 then
112448: LD_VAR 0 3
112452: PUSH
112453: LD_INT 22
112455: EQUAL
112456: IFFALSE 112466
// sTeleport := true ;
112458: LD_ADDR_EXP 187
112462: PUSH
112463: LD_INT 1
112465: ST_TO_ADDR
// if p3 = 23 then
112466: LD_VAR 0 3
112470: PUSH
112471: LD_INT 23
112473: EQUAL
112474: IFFALSE 112484
// sOilTower := true ;
112476: LD_ADDR_EXP 189
112480: PUSH
112481: LD_INT 1
112483: ST_TO_ADDR
// if p3 = 24 then
112484: LD_VAR 0 3
112488: PUSH
112489: LD_INT 24
112491: EQUAL
112492: IFFALSE 112502
// sShovel := true ;
112494: LD_ADDR_EXP 190
112498: PUSH
112499: LD_INT 1
112501: ST_TO_ADDR
// if p3 = 25 then
112502: LD_VAR 0 3
112506: PUSH
112507: LD_INT 25
112509: EQUAL
112510: IFFALSE 112520
// sSheik := true ;
112512: LD_ADDR_EXP 191
112516: PUSH
112517: LD_INT 1
112519: ST_TO_ADDR
// if p3 = 26 then
112520: LD_VAR 0 3
112524: PUSH
112525: LD_INT 26
112527: EQUAL
112528: IFFALSE 112538
// sEarthquake := true ;
112530: LD_ADDR_EXP 193
112534: PUSH
112535: LD_INT 1
112537: ST_TO_ADDR
// if p3 = 27 then
112538: LD_VAR 0 3
112542: PUSH
112543: LD_INT 27
112545: EQUAL
112546: IFFALSE 112556
// sAI := true ;
112548: LD_ADDR_EXP 194
112552: PUSH
112553: LD_INT 1
112555: ST_TO_ADDR
// if p3 = 28 then
112556: LD_VAR 0 3
112560: PUSH
112561: LD_INT 28
112563: EQUAL
112564: IFFALSE 112574
// sCargo := true ;
112566: LD_ADDR_EXP 197
112570: PUSH
112571: LD_INT 1
112573: ST_TO_ADDR
// if p3 = 29 then
112574: LD_VAR 0 3
112578: PUSH
112579: LD_INT 29
112581: EQUAL
112582: IFFALSE 112592
// sDLaser := true ;
112584: LD_ADDR_EXP 198
112588: PUSH
112589: LD_INT 1
112591: ST_TO_ADDR
// if p3 = 30 then
112592: LD_VAR 0 3
112596: PUSH
112597: LD_INT 30
112599: EQUAL
112600: IFFALSE 112610
// sExchange := true ;
112602: LD_ADDR_EXP 199
112606: PUSH
112607: LD_INT 1
112609: ST_TO_ADDR
// if p3 = 31 then
112610: LD_VAR 0 3
112614: PUSH
112615: LD_INT 31
112617: EQUAL
112618: IFFALSE 112628
// sFac := true ;
112620: LD_ADDR_EXP 200
112624: PUSH
112625: LD_INT 1
112627: ST_TO_ADDR
// if p3 = 32 then
112628: LD_VAR 0 3
112632: PUSH
112633: LD_INT 32
112635: EQUAL
112636: IFFALSE 112646
// sPower := true ;
112638: LD_ADDR_EXP 201
112642: PUSH
112643: LD_INT 1
112645: ST_TO_ADDR
// if p3 = 33 then
112646: LD_VAR 0 3
112650: PUSH
112651: LD_INT 33
112653: EQUAL
112654: IFFALSE 112664
// sRandom := true ;
112656: LD_ADDR_EXP 202
112660: PUSH
112661: LD_INT 1
112663: ST_TO_ADDR
// if p3 = 34 then
112664: LD_VAR 0 3
112668: PUSH
112669: LD_INT 34
112671: EQUAL
112672: IFFALSE 112682
// sShield := true ;
112674: LD_ADDR_EXP 203
112678: PUSH
112679: LD_INT 1
112681: ST_TO_ADDR
// if p3 = 35 then
112682: LD_VAR 0 3
112686: PUSH
112687: LD_INT 35
112689: EQUAL
112690: IFFALSE 112700
// sTime := true ;
112692: LD_ADDR_EXP 204
112696: PUSH
112697: LD_INT 1
112699: ST_TO_ADDR
// if p3 = 36 then
112700: LD_VAR 0 3
112704: PUSH
112705: LD_INT 36
112707: EQUAL
112708: IFFALSE 112718
// sTools := true ;
112710: LD_ADDR_EXP 205
112714: PUSH
112715: LD_INT 1
112717: ST_TO_ADDR
// if p3 = 101 then
112718: LD_VAR 0 3
112722: PUSH
112723: LD_INT 101
112725: EQUAL
112726: IFFALSE 112736
// sSold := true ;
112728: LD_ADDR_EXP 170
112732: PUSH
112733: LD_INT 1
112735: ST_TO_ADDR
// if p3 = 102 then
112736: LD_VAR 0 3
112740: PUSH
112741: LD_INT 102
112743: EQUAL
112744: IFFALSE 112754
// sDiff := true ;
112746: LD_ADDR_EXP 171
112750: PUSH
112751: LD_INT 1
112753: ST_TO_ADDR
// if p3 = 103 then
112754: LD_VAR 0 3
112758: PUSH
112759: LD_INT 103
112761: EQUAL
112762: IFFALSE 112772
// sFog := true ;
112764: LD_ADDR_EXP 174
112768: PUSH
112769: LD_INT 1
112771: ST_TO_ADDR
// if p3 = 104 then
112772: LD_VAR 0 3
112776: PUSH
112777: LD_INT 104
112779: EQUAL
112780: IFFALSE 112790
// sReset := true ;
112782: LD_ADDR_EXP 175
112786: PUSH
112787: LD_INT 1
112789: ST_TO_ADDR
// if p3 = 105 then
112790: LD_VAR 0 3
112794: PUSH
112795: LD_INT 105
112797: EQUAL
112798: IFFALSE 112808
// sSun := true ;
112800: LD_ADDR_EXP 176
112804: PUSH
112805: LD_INT 1
112807: ST_TO_ADDR
// if p3 = 106 then
112808: LD_VAR 0 3
112812: PUSH
112813: LD_INT 106
112815: EQUAL
112816: IFFALSE 112826
// sTiger := true ;
112818: LD_ADDR_EXP 172
112822: PUSH
112823: LD_INT 1
112825: ST_TO_ADDR
// if p3 = 107 then
112826: LD_VAR 0 3
112830: PUSH
112831: LD_INT 107
112833: EQUAL
112834: IFFALSE 112844
// sBomb := true ;
112836: LD_ADDR_EXP 173
112840: PUSH
112841: LD_INT 1
112843: ST_TO_ADDR
// if p3 = 108 then
112844: LD_VAR 0 3
112848: PUSH
112849: LD_INT 108
112851: EQUAL
112852: IFFALSE 112862
// sWound := true ;
112854: LD_ADDR_EXP 181
112858: PUSH
112859: LD_INT 1
112861: ST_TO_ADDR
// if p3 = 109 then
112862: LD_VAR 0 3
112866: PUSH
112867: LD_INT 109
112869: EQUAL
112870: IFFALSE 112880
// sBetray := true ;
112872: LD_ADDR_EXP 185
112876: PUSH
112877: LD_INT 1
112879: ST_TO_ADDR
// if p3 = 110 then
112880: LD_VAR 0 3
112884: PUSH
112885: LD_INT 110
112887: EQUAL
112888: IFFALSE 112898
// sContamin := true ;
112890: LD_ADDR_EXP 186
112894: PUSH
112895: LD_INT 1
112897: ST_TO_ADDR
// if p3 = 111 then
112898: LD_VAR 0 3
112902: PUSH
112903: LD_INT 111
112905: EQUAL
112906: IFFALSE 112916
// sOil := true ;
112908: LD_ADDR_EXP 188
112912: PUSH
112913: LD_INT 1
112915: ST_TO_ADDR
// if p3 = 112 then
112916: LD_VAR 0 3
112920: PUSH
112921: LD_INT 112
112923: EQUAL
112924: IFFALSE 112934
// sStu := true ;
112926: LD_ADDR_EXP 192
112930: PUSH
112931: LD_INT 1
112933: ST_TO_ADDR
// if p3 = 113 then
112934: LD_VAR 0 3
112938: PUSH
112939: LD_INT 113
112941: EQUAL
112942: IFFALSE 112952
// sBazooka := true ;
112944: LD_ADDR_EXP 195
112948: PUSH
112949: LD_INT 1
112951: ST_TO_ADDR
// if p3 = 114 then
112952: LD_VAR 0 3
112956: PUSH
112957: LD_INT 114
112959: EQUAL
112960: IFFALSE 112970
// sMortar := true ;
112962: LD_ADDR_EXP 196
112966: PUSH
112967: LD_INT 1
112969: ST_TO_ADDR
// if p3 = 115 then
112970: LD_VAR 0 3
112974: PUSH
112975: LD_INT 115
112977: EQUAL
112978: IFFALSE 112988
// sRanger := true ;
112980: LD_ADDR_EXP 206
112984: PUSH
112985: LD_INT 1
112987: ST_TO_ADDR
// end ; end ;
112988: PPOPN 6
112990: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
112991: LD_EXP 153
112995: PUSH
112996: LD_EXP 158
113000: AND
113001: IFFALSE 113125
113003: GO 113005
113005: DISABLE
113006: LD_INT 0
113008: PPUSH
113009: PPUSH
// begin enable ;
113010: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
113011: LD_ADDR_VAR 0 2
113015: PUSH
113016: LD_INT 22
113018: PUSH
113019: LD_OWVAR 2
113023: PUSH
113024: EMPTY
113025: LIST
113026: LIST
113027: PUSH
113028: LD_INT 2
113030: PUSH
113031: LD_INT 34
113033: PUSH
113034: LD_INT 7
113036: PUSH
113037: EMPTY
113038: LIST
113039: LIST
113040: PUSH
113041: LD_INT 34
113043: PUSH
113044: LD_INT 45
113046: PUSH
113047: EMPTY
113048: LIST
113049: LIST
113050: PUSH
113051: LD_INT 34
113053: PUSH
113054: LD_INT 28
113056: PUSH
113057: EMPTY
113058: LIST
113059: LIST
113060: PUSH
113061: LD_INT 34
113063: PUSH
113064: LD_INT 47
113066: PUSH
113067: EMPTY
113068: LIST
113069: LIST
113070: PUSH
113071: EMPTY
113072: LIST
113073: LIST
113074: LIST
113075: LIST
113076: LIST
113077: PUSH
113078: EMPTY
113079: LIST
113080: LIST
113081: PPUSH
113082: CALL_OW 69
113086: ST_TO_ADDR
// if not tmp then
113087: LD_VAR 0 2
113091: NOT
113092: IFFALSE 113096
// exit ;
113094: GO 113125
// for i in tmp do
113096: LD_ADDR_VAR 0 1
113100: PUSH
113101: LD_VAR 0 2
113105: PUSH
113106: FOR_IN
113107: IFFALSE 113123
// begin SetLives ( i , 0 ) ;
113109: LD_VAR 0 1
113113: PPUSH
113114: LD_INT 0
113116: PPUSH
113117: CALL_OW 234
// end ;
113121: GO 113106
113123: POP
113124: POP
// end ;
113125: PPOPN 2
113127: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
113128: LD_EXP 153
113132: PUSH
113133: LD_EXP 159
113137: AND
113138: IFFALSE 113222
113140: GO 113142
113142: DISABLE
113143: LD_INT 0
113145: PPUSH
113146: PPUSH
// begin enable ;
113147: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
113148: LD_ADDR_VAR 0 2
113152: PUSH
113153: LD_INT 22
113155: PUSH
113156: LD_OWVAR 2
113160: PUSH
113161: EMPTY
113162: LIST
113163: LIST
113164: PUSH
113165: LD_INT 32
113167: PUSH
113168: LD_INT 3
113170: PUSH
113171: EMPTY
113172: LIST
113173: LIST
113174: PUSH
113175: EMPTY
113176: LIST
113177: LIST
113178: PPUSH
113179: CALL_OW 69
113183: ST_TO_ADDR
// if not tmp then
113184: LD_VAR 0 2
113188: NOT
113189: IFFALSE 113193
// exit ;
113191: GO 113222
// for i in tmp do
113193: LD_ADDR_VAR 0 1
113197: PUSH
113198: LD_VAR 0 2
113202: PUSH
113203: FOR_IN
113204: IFFALSE 113220
// begin SetLives ( i , 0 ) ;
113206: LD_VAR 0 1
113210: PPUSH
113211: LD_INT 0
113213: PPUSH
113214: CALL_OW 234
// end ;
113218: GO 113203
113220: POP
113221: POP
// end ;
113222: PPOPN 2
113224: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113225: LD_EXP 153
113229: PUSH
113230: LD_EXP 156
113234: AND
113235: IFFALSE 113328
113237: GO 113239
113239: DISABLE
113240: LD_INT 0
113242: PPUSH
// begin enable ;
113243: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113244: LD_ADDR_VAR 0 1
113248: PUSH
113249: LD_INT 22
113251: PUSH
113252: LD_OWVAR 2
113256: PUSH
113257: EMPTY
113258: LIST
113259: LIST
113260: PUSH
113261: LD_INT 2
113263: PUSH
113264: LD_INT 25
113266: PUSH
113267: LD_INT 5
113269: PUSH
113270: EMPTY
113271: LIST
113272: LIST
113273: PUSH
113274: LD_INT 25
113276: PUSH
113277: LD_INT 9
113279: PUSH
113280: EMPTY
113281: LIST
113282: LIST
113283: PUSH
113284: LD_INT 25
113286: PUSH
113287: LD_INT 8
113289: PUSH
113290: EMPTY
113291: LIST
113292: LIST
113293: PUSH
113294: EMPTY
113295: LIST
113296: LIST
113297: LIST
113298: LIST
113299: PUSH
113300: EMPTY
113301: LIST
113302: LIST
113303: PPUSH
113304: CALL_OW 69
113308: PUSH
113309: FOR_IN
113310: IFFALSE 113326
// begin SetClass ( i , 1 ) ;
113312: LD_VAR 0 1
113316: PPUSH
113317: LD_INT 1
113319: PPUSH
113320: CALL_OW 336
// end ;
113324: GO 113309
113326: POP
113327: POP
// end ;
113328: PPOPN 1
113330: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113331: LD_EXP 153
113335: PUSH
113336: LD_EXP 157
113340: AND
113341: PUSH
113342: LD_OWVAR 65
113346: PUSH
113347: LD_INT 7
113349: LESS
113350: AND
113351: IFFALSE 113365
113353: GO 113355
113355: DISABLE
// begin enable ;
113356: ENABLE
// game_speed := 7 ;
113357: LD_ADDR_OWVAR 65
113361: PUSH
113362: LD_INT 7
113364: ST_TO_ADDR
// end ;
113365: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113366: LD_EXP 153
113370: PUSH
113371: LD_EXP 160
113375: AND
113376: IFFALSE 113578
113378: GO 113380
113380: DISABLE
113381: LD_INT 0
113383: PPUSH
113384: PPUSH
113385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113386: LD_ADDR_VAR 0 3
113390: PUSH
113391: LD_INT 81
113393: PUSH
113394: LD_OWVAR 2
113398: PUSH
113399: EMPTY
113400: LIST
113401: LIST
113402: PUSH
113403: LD_INT 21
113405: PUSH
113406: LD_INT 1
113408: PUSH
113409: EMPTY
113410: LIST
113411: LIST
113412: PUSH
113413: EMPTY
113414: LIST
113415: LIST
113416: PPUSH
113417: CALL_OW 69
113421: ST_TO_ADDR
// if not tmp then
113422: LD_VAR 0 3
113426: NOT
113427: IFFALSE 113431
// exit ;
113429: GO 113578
// if tmp > 5 then
113431: LD_VAR 0 3
113435: PUSH
113436: LD_INT 5
113438: GREATER
113439: IFFALSE 113451
// k := 5 else
113441: LD_ADDR_VAR 0 2
113445: PUSH
113446: LD_INT 5
113448: ST_TO_ADDR
113449: GO 113461
// k := tmp ;
113451: LD_ADDR_VAR 0 2
113455: PUSH
113456: LD_VAR 0 3
113460: ST_TO_ADDR
// for i := 1 to k do
113461: LD_ADDR_VAR 0 1
113465: PUSH
113466: DOUBLE
113467: LD_INT 1
113469: DEC
113470: ST_TO_ADDR
113471: LD_VAR 0 2
113475: PUSH
113476: FOR_TO
113477: IFFALSE 113576
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113479: LD_VAR 0 3
113483: PUSH
113484: LD_VAR 0 1
113488: ARRAY
113489: PPUSH
113490: LD_VAR 0 1
113494: PUSH
113495: LD_INT 4
113497: MOD
113498: PUSH
113499: LD_INT 1
113501: PLUS
113502: PPUSH
113503: CALL_OW 259
113507: PUSH
113508: LD_INT 10
113510: LESS
113511: IFFALSE 113574
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113513: LD_VAR 0 3
113517: PUSH
113518: LD_VAR 0 1
113522: ARRAY
113523: PPUSH
113524: LD_VAR 0 1
113528: PUSH
113529: LD_INT 4
113531: MOD
113532: PUSH
113533: LD_INT 1
113535: PLUS
113536: PPUSH
113537: LD_VAR 0 3
113541: PUSH
113542: LD_VAR 0 1
113546: ARRAY
113547: PPUSH
113548: LD_VAR 0 1
113552: PUSH
113553: LD_INT 4
113555: MOD
113556: PUSH
113557: LD_INT 1
113559: PLUS
113560: PPUSH
113561: CALL_OW 259
113565: PUSH
113566: LD_INT 1
113568: PLUS
113569: PPUSH
113570: CALL_OW 237
113574: GO 113476
113576: POP
113577: POP
// end ;
113578: PPOPN 3
113580: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113581: LD_EXP 153
113585: PUSH
113586: LD_EXP 161
113590: AND
113591: IFFALSE 113611
113593: GO 113595
113595: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113596: LD_INT 4
113598: PPUSH
113599: LD_OWVAR 2
113603: PPUSH
113604: LD_INT 0
113606: PPUSH
113607: CALL_OW 324
113611: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113612: LD_EXP 153
113616: PUSH
113617: LD_EXP 190
113621: AND
113622: IFFALSE 113642
113624: GO 113626
113626: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113627: LD_INT 19
113629: PPUSH
113630: LD_OWVAR 2
113634: PPUSH
113635: LD_INT 0
113637: PPUSH
113638: CALL_OW 324
113642: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113643: LD_EXP 153
113647: PUSH
113648: LD_EXP 162
113652: AND
113653: IFFALSE 113755
113655: GO 113657
113657: DISABLE
113658: LD_INT 0
113660: PPUSH
113661: PPUSH
// begin enable ;
113662: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113663: LD_ADDR_VAR 0 2
113667: PUSH
113668: LD_INT 22
113670: PUSH
113671: LD_OWVAR 2
113675: PUSH
113676: EMPTY
113677: LIST
113678: LIST
113679: PUSH
113680: LD_INT 2
113682: PUSH
113683: LD_INT 34
113685: PUSH
113686: LD_INT 11
113688: PUSH
113689: EMPTY
113690: LIST
113691: LIST
113692: PUSH
113693: LD_INT 34
113695: PUSH
113696: LD_INT 30
113698: PUSH
113699: EMPTY
113700: LIST
113701: LIST
113702: PUSH
113703: EMPTY
113704: LIST
113705: LIST
113706: LIST
113707: PUSH
113708: EMPTY
113709: LIST
113710: LIST
113711: PPUSH
113712: CALL_OW 69
113716: ST_TO_ADDR
// if not tmp then
113717: LD_VAR 0 2
113721: NOT
113722: IFFALSE 113726
// exit ;
113724: GO 113755
// for i in tmp do
113726: LD_ADDR_VAR 0 1
113730: PUSH
113731: LD_VAR 0 2
113735: PUSH
113736: FOR_IN
113737: IFFALSE 113753
// begin SetLives ( i , 0 ) ;
113739: LD_VAR 0 1
113743: PPUSH
113744: LD_INT 0
113746: PPUSH
113747: CALL_OW 234
// end ;
113751: GO 113736
113753: POP
113754: POP
// end ;
113755: PPOPN 2
113757: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113758: LD_EXP 153
113762: PUSH
113763: LD_EXP 163
113767: AND
113768: IFFALSE 113788
113770: GO 113772
113772: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113773: LD_INT 32
113775: PPUSH
113776: LD_OWVAR 2
113780: PPUSH
113781: LD_INT 0
113783: PPUSH
113784: CALL_OW 324
113788: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113789: LD_EXP 153
113793: PUSH
113794: LD_EXP 164
113798: AND
113799: IFFALSE 113980
113801: GO 113803
113803: DISABLE
113804: LD_INT 0
113806: PPUSH
113807: PPUSH
113808: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113809: LD_ADDR_VAR 0 2
113813: PUSH
113814: LD_INT 22
113816: PUSH
113817: LD_OWVAR 2
113821: PUSH
113822: EMPTY
113823: LIST
113824: LIST
113825: PUSH
113826: LD_INT 33
113828: PUSH
113829: LD_INT 3
113831: PUSH
113832: EMPTY
113833: LIST
113834: LIST
113835: PUSH
113836: EMPTY
113837: LIST
113838: LIST
113839: PPUSH
113840: CALL_OW 69
113844: ST_TO_ADDR
// if not tmp then
113845: LD_VAR 0 2
113849: NOT
113850: IFFALSE 113854
// exit ;
113852: GO 113980
// side := 0 ;
113854: LD_ADDR_VAR 0 3
113858: PUSH
113859: LD_INT 0
113861: ST_TO_ADDR
// for i := 1 to 8 do
113862: LD_ADDR_VAR 0 1
113866: PUSH
113867: DOUBLE
113868: LD_INT 1
113870: DEC
113871: ST_TO_ADDR
113872: LD_INT 8
113874: PUSH
113875: FOR_TO
113876: IFFALSE 113924
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113878: LD_OWVAR 2
113882: PUSH
113883: LD_VAR 0 1
113887: NONEQUAL
113888: PUSH
113889: LD_OWVAR 2
113893: PPUSH
113894: LD_VAR 0 1
113898: PPUSH
113899: CALL_OW 81
113903: PUSH
113904: LD_INT 2
113906: EQUAL
113907: AND
113908: IFFALSE 113922
// begin side := i ;
113910: LD_ADDR_VAR 0 3
113914: PUSH
113915: LD_VAR 0 1
113919: ST_TO_ADDR
// break ;
113920: GO 113924
// end ;
113922: GO 113875
113924: POP
113925: POP
// if not side then
113926: LD_VAR 0 3
113930: NOT
113931: IFFALSE 113935
// exit ;
113933: GO 113980
// for i := 1 to tmp do
113935: LD_ADDR_VAR 0 1
113939: PUSH
113940: DOUBLE
113941: LD_INT 1
113943: DEC
113944: ST_TO_ADDR
113945: LD_VAR 0 2
113949: PUSH
113950: FOR_TO
113951: IFFALSE 113978
// if Prob ( 60 ) then
113953: LD_INT 60
113955: PPUSH
113956: CALL_OW 13
113960: IFFALSE 113976
// SetSide ( i , side ) ;
113962: LD_VAR 0 1
113966: PPUSH
113967: LD_VAR 0 3
113971: PPUSH
113972: CALL_OW 235
113976: GO 113950
113978: POP
113979: POP
// end ;
113980: PPOPN 3
113982: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
113983: LD_EXP 153
113987: PUSH
113988: LD_EXP 166
113992: AND
113993: IFFALSE 114112
113995: GO 113997
113997: DISABLE
113998: LD_INT 0
114000: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
114001: LD_ADDR_VAR 0 1
114005: PUSH
114006: LD_INT 22
114008: PUSH
114009: LD_OWVAR 2
114013: PUSH
114014: EMPTY
114015: LIST
114016: LIST
114017: PUSH
114018: LD_INT 21
114020: PUSH
114021: LD_INT 1
114023: PUSH
114024: EMPTY
114025: LIST
114026: LIST
114027: PUSH
114028: LD_INT 3
114030: PUSH
114031: LD_INT 23
114033: PUSH
114034: LD_INT 0
114036: PUSH
114037: EMPTY
114038: LIST
114039: LIST
114040: PUSH
114041: EMPTY
114042: LIST
114043: LIST
114044: PUSH
114045: EMPTY
114046: LIST
114047: LIST
114048: LIST
114049: PPUSH
114050: CALL_OW 69
114054: PUSH
114055: FOR_IN
114056: IFFALSE 114110
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
114058: LD_VAR 0 1
114062: PPUSH
114063: CALL_OW 257
114067: PUSH
114068: LD_INT 1
114070: PUSH
114071: LD_INT 2
114073: PUSH
114074: LD_INT 3
114076: PUSH
114077: LD_INT 4
114079: PUSH
114080: EMPTY
114081: LIST
114082: LIST
114083: LIST
114084: LIST
114085: IN
114086: IFFALSE 114108
// SetClass ( un , rand ( 1 , 4 ) ) ;
114088: LD_VAR 0 1
114092: PPUSH
114093: LD_INT 1
114095: PPUSH
114096: LD_INT 4
114098: PPUSH
114099: CALL_OW 12
114103: PPUSH
114104: CALL_OW 336
114108: GO 114055
114110: POP
114111: POP
// end ;
114112: PPOPN 1
114114: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
114115: LD_EXP 153
114119: PUSH
114120: LD_EXP 165
114124: AND
114125: IFFALSE 114204
114127: GO 114129
114129: DISABLE
114130: LD_INT 0
114132: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114133: LD_ADDR_VAR 0 1
114137: PUSH
114138: LD_INT 22
114140: PUSH
114141: LD_OWVAR 2
114145: PUSH
114146: EMPTY
114147: LIST
114148: LIST
114149: PUSH
114150: LD_INT 21
114152: PUSH
114153: LD_INT 3
114155: PUSH
114156: EMPTY
114157: LIST
114158: LIST
114159: PUSH
114160: EMPTY
114161: LIST
114162: LIST
114163: PPUSH
114164: CALL_OW 69
114168: ST_TO_ADDR
// if not tmp then
114169: LD_VAR 0 1
114173: NOT
114174: IFFALSE 114178
// exit ;
114176: GO 114204
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114178: LD_VAR 0 1
114182: PUSH
114183: LD_INT 1
114185: PPUSH
114186: LD_VAR 0 1
114190: PPUSH
114191: CALL_OW 12
114195: ARRAY
114196: PPUSH
114197: LD_INT 100
114199: PPUSH
114200: CALL_OW 234
// end ;
114204: PPOPN 1
114206: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114207: LD_EXP 153
114211: PUSH
114212: LD_EXP 167
114216: AND
114217: IFFALSE 114315
114219: GO 114221
114221: DISABLE
114222: LD_INT 0
114224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114225: LD_ADDR_VAR 0 1
114229: PUSH
114230: LD_INT 22
114232: PUSH
114233: LD_OWVAR 2
114237: PUSH
114238: EMPTY
114239: LIST
114240: LIST
114241: PUSH
114242: LD_INT 21
114244: PUSH
114245: LD_INT 1
114247: PUSH
114248: EMPTY
114249: LIST
114250: LIST
114251: PUSH
114252: EMPTY
114253: LIST
114254: LIST
114255: PPUSH
114256: CALL_OW 69
114260: ST_TO_ADDR
// if not tmp then
114261: LD_VAR 0 1
114265: NOT
114266: IFFALSE 114270
// exit ;
114268: GO 114315
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114270: LD_VAR 0 1
114274: PUSH
114275: LD_INT 1
114277: PPUSH
114278: LD_VAR 0 1
114282: PPUSH
114283: CALL_OW 12
114287: ARRAY
114288: PPUSH
114289: LD_INT 1
114291: PPUSH
114292: LD_INT 4
114294: PPUSH
114295: CALL_OW 12
114299: PPUSH
114300: LD_INT 3000
114302: PPUSH
114303: LD_INT 9000
114305: PPUSH
114306: CALL_OW 12
114310: PPUSH
114311: CALL_OW 492
// end ;
114315: PPOPN 1
114317: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114318: LD_EXP 153
114322: PUSH
114323: LD_EXP 168
114327: AND
114328: IFFALSE 114348
114330: GO 114332
114332: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114333: LD_INT 1
114335: PPUSH
114336: LD_OWVAR 2
114340: PPUSH
114341: LD_INT 0
114343: PPUSH
114344: CALL_OW 324
114348: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114349: LD_EXP 153
114353: PUSH
114354: LD_EXP 169
114358: AND
114359: IFFALSE 114442
114361: GO 114363
114363: DISABLE
114364: LD_INT 0
114366: PPUSH
114367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114368: LD_ADDR_VAR 0 2
114372: PUSH
114373: LD_INT 22
114375: PUSH
114376: LD_OWVAR 2
114380: PUSH
114381: EMPTY
114382: LIST
114383: LIST
114384: PUSH
114385: LD_INT 21
114387: PUSH
114388: LD_INT 3
114390: PUSH
114391: EMPTY
114392: LIST
114393: LIST
114394: PUSH
114395: EMPTY
114396: LIST
114397: LIST
114398: PPUSH
114399: CALL_OW 69
114403: ST_TO_ADDR
// if not tmp then
114404: LD_VAR 0 2
114408: NOT
114409: IFFALSE 114413
// exit ;
114411: GO 114442
// for i in tmp do
114413: LD_ADDR_VAR 0 1
114417: PUSH
114418: LD_VAR 0 2
114422: PUSH
114423: FOR_IN
114424: IFFALSE 114440
// SetBLevel ( i , 10 ) ;
114426: LD_VAR 0 1
114430: PPUSH
114431: LD_INT 10
114433: PPUSH
114434: CALL_OW 241
114438: GO 114423
114440: POP
114441: POP
// end ;
114442: PPOPN 2
114444: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114445: LD_EXP 153
114449: PUSH
114450: LD_EXP 170
114454: AND
114455: IFFALSE 114566
114457: GO 114459
114459: DISABLE
114460: LD_INT 0
114462: PPUSH
114463: PPUSH
114464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114465: LD_ADDR_VAR 0 3
114469: PUSH
114470: LD_INT 22
114472: PUSH
114473: LD_OWVAR 2
114477: PUSH
114478: EMPTY
114479: LIST
114480: LIST
114481: PUSH
114482: LD_INT 25
114484: PUSH
114485: LD_INT 1
114487: PUSH
114488: EMPTY
114489: LIST
114490: LIST
114491: PUSH
114492: EMPTY
114493: LIST
114494: LIST
114495: PPUSH
114496: CALL_OW 69
114500: ST_TO_ADDR
// if not tmp then
114501: LD_VAR 0 3
114505: NOT
114506: IFFALSE 114510
// exit ;
114508: GO 114566
// un := tmp [ rand ( 1 , tmp ) ] ;
114510: LD_ADDR_VAR 0 2
114514: PUSH
114515: LD_VAR 0 3
114519: PUSH
114520: LD_INT 1
114522: PPUSH
114523: LD_VAR 0 3
114527: PPUSH
114528: CALL_OW 12
114532: ARRAY
114533: ST_TO_ADDR
// if Crawls ( un ) then
114534: LD_VAR 0 2
114538: PPUSH
114539: CALL_OW 318
114543: IFFALSE 114554
// ComWalk ( un ) ;
114545: LD_VAR 0 2
114549: PPUSH
114550: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114554: LD_VAR 0 2
114558: PPUSH
114559: LD_INT 5
114561: PPUSH
114562: CALL_OW 336
// end ;
114566: PPOPN 3
114568: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
114569: LD_EXP 153
114573: PUSH
114574: LD_EXP 171
114578: AND
114579: PUSH
114580: LD_OWVAR 67
114584: PUSH
114585: LD_INT 3
114587: LESS
114588: AND
114589: IFFALSE 114608
114591: GO 114593
114593: DISABLE
// Difficulty := Difficulty + 1 ;
114594: LD_ADDR_OWVAR 67
114598: PUSH
114599: LD_OWVAR 67
114603: PUSH
114604: LD_INT 1
114606: PLUS
114607: ST_TO_ADDR
114608: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114609: LD_EXP 153
114613: PUSH
114614: LD_EXP 172
114618: AND
114619: IFFALSE 114722
114621: GO 114623
114623: DISABLE
114624: LD_INT 0
114626: PPUSH
// begin for i := 1 to 5 do
114627: LD_ADDR_VAR 0 1
114631: PUSH
114632: DOUBLE
114633: LD_INT 1
114635: DEC
114636: ST_TO_ADDR
114637: LD_INT 5
114639: PUSH
114640: FOR_TO
114641: IFFALSE 114720
// begin uc_nation := nation_nature ;
114643: LD_ADDR_OWVAR 21
114647: PUSH
114648: LD_INT 0
114650: ST_TO_ADDR
// uc_side := 0 ;
114651: LD_ADDR_OWVAR 20
114655: PUSH
114656: LD_INT 0
114658: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114659: LD_ADDR_OWVAR 29
114663: PUSH
114664: LD_INT 12
114666: PUSH
114667: LD_INT 12
114669: PUSH
114670: EMPTY
114671: LIST
114672: LIST
114673: ST_TO_ADDR
// hc_agressivity := 20 ;
114674: LD_ADDR_OWVAR 35
114678: PUSH
114679: LD_INT 20
114681: ST_TO_ADDR
// hc_class := class_tiger ;
114682: LD_ADDR_OWVAR 28
114686: PUSH
114687: LD_INT 14
114689: ST_TO_ADDR
// hc_gallery :=  ;
114690: LD_ADDR_OWVAR 33
114694: PUSH
114695: LD_STRING 
114697: ST_TO_ADDR
// hc_name :=  ;
114698: LD_ADDR_OWVAR 26
114702: PUSH
114703: LD_STRING 
114705: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114706: CALL_OW 44
114710: PPUSH
114711: LD_INT 0
114713: PPUSH
114714: CALL_OW 51
// end ;
114718: GO 114640
114720: POP
114721: POP
// end ;
114722: PPOPN 1
114724: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114725: LD_EXP 153
114729: PUSH
114730: LD_EXP 173
114734: AND
114735: IFFALSE 114744
114737: GO 114739
114739: DISABLE
// StreamSibBomb ;
114740: CALL 114745 0 0
114744: END
// export function StreamSibBomb ; var i , x , y ; begin
114745: LD_INT 0
114747: PPUSH
114748: PPUSH
114749: PPUSH
114750: PPUSH
// result := false ;
114751: LD_ADDR_VAR 0 1
114755: PUSH
114756: LD_INT 0
114758: ST_TO_ADDR
// for i := 1 to 16 do
114759: LD_ADDR_VAR 0 2
114763: PUSH
114764: DOUBLE
114765: LD_INT 1
114767: DEC
114768: ST_TO_ADDR
114769: LD_INT 16
114771: PUSH
114772: FOR_TO
114773: IFFALSE 114972
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114775: LD_ADDR_VAR 0 3
114779: PUSH
114780: LD_INT 10
114782: PUSH
114783: LD_INT 20
114785: PUSH
114786: LD_INT 30
114788: PUSH
114789: LD_INT 40
114791: PUSH
114792: LD_INT 50
114794: PUSH
114795: LD_INT 60
114797: PUSH
114798: LD_INT 70
114800: PUSH
114801: LD_INT 80
114803: PUSH
114804: LD_INT 90
114806: PUSH
114807: LD_INT 100
114809: PUSH
114810: LD_INT 110
114812: PUSH
114813: LD_INT 120
114815: PUSH
114816: LD_INT 130
114818: PUSH
114819: LD_INT 140
114821: PUSH
114822: LD_INT 150
114824: PUSH
114825: EMPTY
114826: LIST
114827: LIST
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: LIST
114834: LIST
114835: LIST
114836: LIST
114837: LIST
114838: LIST
114839: LIST
114840: LIST
114841: PUSH
114842: LD_INT 1
114844: PPUSH
114845: LD_INT 15
114847: PPUSH
114848: CALL_OW 12
114852: ARRAY
114853: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114854: LD_ADDR_VAR 0 4
114858: PUSH
114859: LD_INT 10
114861: PUSH
114862: LD_INT 20
114864: PUSH
114865: LD_INT 30
114867: PUSH
114868: LD_INT 40
114870: PUSH
114871: LD_INT 50
114873: PUSH
114874: LD_INT 60
114876: PUSH
114877: LD_INT 70
114879: PUSH
114880: LD_INT 80
114882: PUSH
114883: LD_INT 90
114885: PUSH
114886: LD_INT 100
114888: PUSH
114889: LD_INT 110
114891: PUSH
114892: LD_INT 120
114894: PUSH
114895: LD_INT 130
114897: PUSH
114898: LD_INT 140
114900: PUSH
114901: LD_INT 150
114903: PUSH
114904: EMPTY
114905: LIST
114906: LIST
114907: LIST
114908: LIST
114909: LIST
114910: LIST
114911: LIST
114912: LIST
114913: LIST
114914: LIST
114915: LIST
114916: LIST
114917: LIST
114918: LIST
114919: LIST
114920: PUSH
114921: LD_INT 1
114923: PPUSH
114924: LD_INT 15
114926: PPUSH
114927: CALL_OW 12
114931: ARRAY
114932: ST_TO_ADDR
// if ValidHex ( x , y ) then
114933: LD_VAR 0 3
114937: PPUSH
114938: LD_VAR 0 4
114942: PPUSH
114943: CALL_OW 488
114947: IFFALSE 114970
// begin result := [ x , y ] ;
114949: LD_ADDR_VAR 0 1
114953: PUSH
114954: LD_VAR 0 3
114958: PUSH
114959: LD_VAR 0 4
114963: PUSH
114964: EMPTY
114965: LIST
114966: LIST
114967: ST_TO_ADDR
// break ;
114968: GO 114972
// end ; end ;
114970: GO 114772
114972: POP
114973: POP
// if result then
114974: LD_VAR 0 1
114978: IFFALSE 115038
// begin ToLua ( playSibBomb() ) ;
114980: LD_STRING playSibBomb()
114982: PPUSH
114983: CALL_OW 559
// wait ( 0 0$14 ) ;
114987: LD_INT 490
114989: PPUSH
114990: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
114994: LD_VAR 0 1
114998: PUSH
114999: LD_INT 1
115001: ARRAY
115002: PPUSH
115003: LD_VAR 0 1
115007: PUSH
115008: LD_INT 2
115010: ARRAY
115011: PPUSH
115012: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
115016: LD_VAR 0 1
115020: PUSH
115021: LD_INT 1
115023: ARRAY
115024: PPUSH
115025: LD_VAR 0 1
115029: PUSH
115030: LD_INT 2
115032: ARRAY
115033: PPUSH
115034: CALL_OW 429
// end ; end ;
115038: LD_VAR 0 1
115042: RET
// every 0 0$1 trigger StreamModeActive and sReset do
115043: LD_EXP 153
115047: PUSH
115048: LD_EXP 175
115052: AND
115053: IFFALSE 115065
115055: GO 115057
115057: DISABLE
// YouLost (  ) ;
115058: LD_STRING 
115060: PPUSH
115061: CALL_OW 104
115065: END
// every 0 0$1 trigger StreamModeActive and sFog do
115066: LD_EXP 153
115070: PUSH
115071: LD_EXP 174
115075: AND
115076: IFFALSE 115090
115078: GO 115080
115080: DISABLE
// FogOff ( your_side ) ;
115081: LD_OWVAR 2
115085: PPUSH
115086: CALL_OW 344
115090: END
// every 0 0$1 trigger StreamModeActive and sSun do
115091: LD_EXP 153
115095: PUSH
115096: LD_EXP 176
115100: AND
115101: IFFALSE 115129
115103: GO 115105
115105: DISABLE
// begin solar_recharge_percent := 0 ;
115106: LD_ADDR_OWVAR 79
115110: PUSH
115111: LD_INT 0
115113: ST_TO_ADDR
// wait ( 5 5$00 ) ;
115114: LD_INT 10500
115116: PPUSH
115117: CALL_OW 67
// solar_recharge_percent := 100 ;
115121: LD_ADDR_OWVAR 79
115125: PUSH
115126: LD_INT 100
115128: ST_TO_ADDR
// end ;
115129: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
115130: LD_EXP 153
115134: PUSH
115135: LD_EXP 177
115139: AND
115140: IFFALSE 115379
115142: GO 115144
115144: DISABLE
115145: LD_INT 0
115147: PPUSH
115148: PPUSH
115149: PPUSH
// begin tmp := [ ] ;
115150: LD_ADDR_VAR 0 3
115154: PUSH
115155: EMPTY
115156: ST_TO_ADDR
// for i := 1 to 6 do
115157: LD_ADDR_VAR 0 1
115161: PUSH
115162: DOUBLE
115163: LD_INT 1
115165: DEC
115166: ST_TO_ADDR
115167: LD_INT 6
115169: PUSH
115170: FOR_TO
115171: IFFALSE 115276
// begin uc_nation := nation_nature ;
115173: LD_ADDR_OWVAR 21
115177: PUSH
115178: LD_INT 0
115180: ST_TO_ADDR
// uc_side := 0 ;
115181: LD_ADDR_OWVAR 20
115185: PUSH
115186: LD_INT 0
115188: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115189: LD_ADDR_OWVAR 29
115193: PUSH
115194: LD_INT 12
115196: PUSH
115197: LD_INT 12
115199: PUSH
115200: EMPTY
115201: LIST
115202: LIST
115203: ST_TO_ADDR
// hc_agressivity := 20 ;
115204: LD_ADDR_OWVAR 35
115208: PUSH
115209: LD_INT 20
115211: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115212: LD_ADDR_OWVAR 28
115216: PUSH
115217: LD_INT 17
115219: ST_TO_ADDR
// hc_gallery :=  ;
115220: LD_ADDR_OWVAR 33
115224: PUSH
115225: LD_STRING 
115227: ST_TO_ADDR
// hc_name :=  ;
115228: LD_ADDR_OWVAR 26
115232: PUSH
115233: LD_STRING 
115235: ST_TO_ADDR
// un := CreateHuman ;
115236: LD_ADDR_VAR 0 2
115240: PUSH
115241: CALL_OW 44
115245: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115246: LD_VAR 0 2
115250: PPUSH
115251: LD_INT 1
115253: PPUSH
115254: CALL_OW 51
// tmp := tmp ^ un ;
115258: LD_ADDR_VAR 0 3
115262: PUSH
115263: LD_VAR 0 3
115267: PUSH
115268: LD_VAR 0 2
115272: ADD
115273: ST_TO_ADDR
// end ;
115274: GO 115170
115276: POP
115277: POP
// repeat wait ( 0 0$1 ) ;
115278: LD_INT 35
115280: PPUSH
115281: CALL_OW 67
// for un in tmp do
115285: LD_ADDR_VAR 0 2
115289: PUSH
115290: LD_VAR 0 3
115294: PUSH
115295: FOR_IN
115296: IFFALSE 115370
// begin if IsDead ( un ) then
115298: LD_VAR 0 2
115302: PPUSH
115303: CALL_OW 301
115307: IFFALSE 115327
// begin tmp := tmp diff un ;
115309: LD_ADDR_VAR 0 3
115313: PUSH
115314: LD_VAR 0 3
115318: PUSH
115319: LD_VAR 0 2
115323: DIFF
115324: ST_TO_ADDR
// continue ;
115325: GO 115295
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115327: LD_VAR 0 2
115331: PPUSH
115332: LD_INT 3
115334: PUSH
115335: LD_INT 22
115337: PUSH
115338: LD_INT 0
115340: PUSH
115341: EMPTY
115342: LIST
115343: LIST
115344: PUSH
115345: EMPTY
115346: LIST
115347: LIST
115348: PPUSH
115349: CALL_OW 69
115353: PPUSH
115354: LD_VAR 0 2
115358: PPUSH
115359: CALL_OW 74
115363: PPUSH
115364: CALL_OW 115
// end ;
115368: GO 115295
115370: POP
115371: POP
// until not tmp ;
115372: LD_VAR 0 3
115376: NOT
115377: IFFALSE 115278
// end ;
115379: PPOPN 3
115381: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115382: LD_EXP 153
115386: PUSH
115387: LD_EXP 178
115391: AND
115392: IFFALSE 115446
115394: GO 115396
115396: DISABLE
// begin ToLua ( displayTroll(); ) ;
115397: LD_STRING displayTroll();
115399: PPUSH
115400: CALL_OW 559
// wait ( 3 3$00 ) ;
115404: LD_INT 6300
115406: PPUSH
115407: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115411: LD_STRING hideTroll();
115413: PPUSH
115414: CALL_OW 559
// wait ( 1 1$00 ) ;
115418: LD_INT 2100
115420: PPUSH
115421: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115425: LD_STRING displayTroll();
115427: PPUSH
115428: CALL_OW 559
// wait ( 1 1$00 ) ;
115432: LD_INT 2100
115434: PPUSH
115435: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115439: LD_STRING hideTroll();
115441: PPUSH
115442: CALL_OW 559
// end ;
115446: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115447: LD_EXP 153
115451: PUSH
115452: LD_EXP 179
115456: AND
115457: IFFALSE 115520
115459: GO 115461
115461: DISABLE
115462: LD_INT 0
115464: PPUSH
// begin p := 0 ;
115465: LD_ADDR_VAR 0 1
115469: PUSH
115470: LD_INT 0
115472: ST_TO_ADDR
// repeat game_speed := 1 ;
115473: LD_ADDR_OWVAR 65
115477: PUSH
115478: LD_INT 1
115480: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115481: LD_INT 35
115483: PPUSH
115484: CALL_OW 67
// p := p + 1 ;
115488: LD_ADDR_VAR 0 1
115492: PUSH
115493: LD_VAR 0 1
115497: PUSH
115498: LD_INT 1
115500: PLUS
115501: ST_TO_ADDR
// until p >= 60 ;
115502: LD_VAR 0 1
115506: PUSH
115507: LD_INT 60
115509: GREATEREQUAL
115510: IFFALSE 115473
// game_speed := 4 ;
115512: LD_ADDR_OWVAR 65
115516: PUSH
115517: LD_INT 4
115519: ST_TO_ADDR
// end ;
115520: PPOPN 1
115522: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115523: LD_EXP 153
115527: PUSH
115528: LD_EXP 180
115532: AND
115533: IFFALSE 115679
115535: GO 115537
115537: DISABLE
115538: LD_INT 0
115540: PPUSH
115541: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115542: LD_ADDR_VAR 0 1
115546: PUSH
115547: LD_INT 22
115549: PUSH
115550: LD_OWVAR 2
115554: PUSH
115555: EMPTY
115556: LIST
115557: LIST
115558: PUSH
115559: LD_INT 2
115561: PUSH
115562: LD_INT 30
115564: PUSH
115565: LD_INT 0
115567: PUSH
115568: EMPTY
115569: LIST
115570: LIST
115571: PUSH
115572: LD_INT 30
115574: PUSH
115575: LD_INT 1
115577: PUSH
115578: EMPTY
115579: LIST
115580: LIST
115581: PUSH
115582: EMPTY
115583: LIST
115584: LIST
115585: LIST
115586: PUSH
115587: EMPTY
115588: LIST
115589: LIST
115590: PPUSH
115591: CALL_OW 69
115595: ST_TO_ADDR
// if not depot then
115596: LD_VAR 0 1
115600: NOT
115601: IFFALSE 115605
// exit ;
115603: GO 115679
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115605: LD_ADDR_VAR 0 2
115609: PUSH
115610: LD_VAR 0 1
115614: PUSH
115615: LD_INT 1
115617: PPUSH
115618: LD_VAR 0 1
115622: PPUSH
115623: CALL_OW 12
115627: ARRAY
115628: PPUSH
115629: CALL_OW 274
115633: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115634: LD_VAR 0 2
115638: PPUSH
115639: LD_INT 1
115641: PPUSH
115642: LD_INT 0
115644: PPUSH
115645: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115649: LD_VAR 0 2
115653: PPUSH
115654: LD_INT 2
115656: PPUSH
115657: LD_INT 0
115659: PPUSH
115660: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115664: LD_VAR 0 2
115668: PPUSH
115669: LD_INT 3
115671: PPUSH
115672: LD_INT 0
115674: PPUSH
115675: CALL_OW 277
// end ;
115679: PPOPN 2
115681: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115682: LD_EXP 153
115686: PUSH
115687: LD_EXP 181
115691: AND
115692: IFFALSE 115789
115694: GO 115696
115696: DISABLE
115697: LD_INT 0
115699: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115700: LD_ADDR_VAR 0 1
115704: PUSH
115705: LD_INT 22
115707: PUSH
115708: LD_OWVAR 2
115712: PUSH
115713: EMPTY
115714: LIST
115715: LIST
115716: PUSH
115717: LD_INT 21
115719: PUSH
115720: LD_INT 1
115722: PUSH
115723: EMPTY
115724: LIST
115725: LIST
115726: PUSH
115727: LD_INT 3
115729: PUSH
115730: LD_INT 23
115732: PUSH
115733: LD_INT 0
115735: PUSH
115736: EMPTY
115737: LIST
115738: LIST
115739: PUSH
115740: EMPTY
115741: LIST
115742: LIST
115743: PUSH
115744: EMPTY
115745: LIST
115746: LIST
115747: LIST
115748: PPUSH
115749: CALL_OW 69
115753: ST_TO_ADDR
// if not tmp then
115754: LD_VAR 0 1
115758: NOT
115759: IFFALSE 115763
// exit ;
115761: GO 115789
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115763: LD_VAR 0 1
115767: PUSH
115768: LD_INT 1
115770: PPUSH
115771: LD_VAR 0 1
115775: PPUSH
115776: CALL_OW 12
115780: ARRAY
115781: PPUSH
115782: LD_INT 200
115784: PPUSH
115785: CALL_OW 234
// end ;
115789: PPOPN 1
115791: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115792: LD_EXP 153
115796: PUSH
115797: LD_EXP 182
115801: AND
115802: IFFALSE 115881
115804: GO 115806
115806: DISABLE
115807: LD_INT 0
115809: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115810: LD_ADDR_VAR 0 1
115814: PUSH
115815: LD_INT 22
115817: PUSH
115818: LD_OWVAR 2
115822: PUSH
115823: EMPTY
115824: LIST
115825: LIST
115826: PUSH
115827: LD_INT 21
115829: PUSH
115830: LD_INT 2
115832: PUSH
115833: EMPTY
115834: LIST
115835: LIST
115836: PUSH
115837: EMPTY
115838: LIST
115839: LIST
115840: PPUSH
115841: CALL_OW 69
115845: ST_TO_ADDR
// if not tmp then
115846: LD_VAR 0 1
115850: NOT
115851: IFFALSE 115855
// exit ;
115853: GO 115881
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115855: LD_VAR 0 1
115859: PUSH
115860: LD_INT 1
115862: PPUSH
115863: LD_VAR 0 1
115867: PPUSH
115868: CALL_OW 12
115872: ARRAY
115873: PPUSH
115874: LD_INT 60
115876: PPUSH
115877: CALL_OW 234
// end ;
115881: PPOPN 1
115883: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115884: LD_EXP 153
115888: PUSH
115889: LD_EXP 183
115893: AND
115894: IFFALSE 115993
115896: GO 115898
115898: DISABLE
115899: LD_INT 0
115901: PPUSH
115902: PPUSH
// begin enable ;
115903: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115904: LD_ADDR_VAR 0 1
115908: PUSH
115909: LD_INT 22
115911: PUSH
115912: LD_OWVAR 2
115916: PUSH
115917: EMPTY
115918: LIST
115919: LIST
115920: PUSH
115921: LD_INT 61
115923: PUSH
115924: EMPTY
115925: LIST
115926: PUSH
115927: LD_INT 33
115929: PUSH
115930: LD_INT 2
115932: PUSH
115933: EMPTY
115934: LIST
115935: LIST
115936: PUSH
115937: EMPTY
115938: LIST
115939: LIST
115940: LIST
115941: PPUSH
115942: CALL_OW 69
115946: ST_TO_ADDR
// if not tmp then
115947: LD_VAR 0 1
115951: NOT
115952: IFFALSE 115956
// exit ;
115954: GO 115993
// for i in tmp do
115956: LD_ADDR_VAR 0 2
115960: PUSH
115961: LD_VAR 0 1
115965: PUSH
115966: FOR_IN
115967: IFFALSE 115991
// if IsControledBy ( i ) then
115969: LD_VAR 0 2
115973: PPUSH
115974: CALL_OW 312
115978: IFFALSE 115989
// ComUnlink ( i ) ;
115980: LD_VAR 0 2
115984: PPUSH
115985: CALL_OW 136
115989: GO 115966
115991: POP
115992: POP
// end ;
115993: PPOPN 2
115995: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
115996: LD_EXP 153
116000: PUSH
116001: LD_EXP 184
116005: AND
116006: IFFALSE 116146
116008: GO 116010
116010: DISABLE
116011: LD_INT 0
116013: PPUSH
116014: PPUSH
// begin ToLua ( displayPowell(); ) ;
116015: LD_STRING displayPowell();
116017: PPUSH
116018: CALL_OW 559
// uc_side := 0 ;
116022: LD_ADDR_OWVAR 20
116026: PUSH
116027: LD_INT 0
116029: ST_TO_ADDR
// uc_nation := 2 ;
116030: LD_ADDR_OWVAR 21
116034: PUSH
116035: LD_INT 2
116037: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
116038: LD_ADDR_OWVAR 37
116042: PUSH
116043: LD_INT 14
116045: ST_TO_ADDR
// vc_engine := engine_siberite ;
116046: LD_ADDR_OWVAR 39
116050: PUSH
116051: LD_INT 3
116053: ST_TO_ADDR
// vc_control := control_apeman ;
116054: LD_ADDR_OWVAR 38
116058: PUSH
116059: LD_INT 5
116061: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
116062: LD_ADDR_OWVAR 40
116066: PUSH
116067: LD_INT 29
116069: ST_TO_ADDR
// un := CreateVehicle ;
116070: LD_ADDR_VAR 0 2
116074: PUSH
116075: CALL_OW 45
116079: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116080: LD_VAR 0 2
116084: PPUSH
116085: LD_INT 1
116087: PPUSH
116088: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116092: LD_INT 35
116094: PPUSH
116095: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116099: LD_VAR 0 2
116103: PPUSH
116104: LD_INT 22
116106: PUSH
116107: LD_OWVAR 2
116111: PUSH
116112: EMPTY
116113: LIST
116114: LIST
116115: PPUSH
116116: CALL_OW 69
116120: PPUSH
116121: LD_VAR 0 2
116125: PPUSH
116126: CALL_OW 74
116130: PPUSH
116131: CALL_OW 115
// until IsDead ( un ) ;
116135: LD_VAR 0 2
116139: PPUSH
116140: CALL_OW 301
116144: IFFALSE 116092
// end ;
116146: PPOPN 2
116148: END
// every 0 0$1 trigger StreamModeActive and sStu do
116149: LD_EXP 153
116153: PUSH
116154: LD_EXP 192
116158: AND
116159: IFFALSE 116175
116161: GO 116163
116163: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116164: LD_STRING displayStucuk();
116166: PPUSH
116167: CALL_OW 559
// ResetFog ;
116171: CALL_OW 335
// end ;
116175: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116176: LD_EXP 153
116180: PUSH
116181: LD_EXP 185
116185: AND
116186: IFFALSE 116327
116188: GO 116190
116190: DISABLE
116191: LD_INT 0
116193: PPUSH
116194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116195: LD_ADDR_VAR 0 2
116199: PUSH
116200: LD_INT 22
116202: PUSH
116203: LD_OWVAR 2
116207: PUSH
116208: EMPTY
116209: LIST
116210: LIST
116211: PUSH
116212: LD_INT 21
116214: PUSH
116215: LD_INT 1
116217: PUSH
116218: EMPTY
116219: LIST
116220: LIST
116221: PUSH
116222: EMPTY
116223: LIST
116224: LIST
116225: PPUSH
116226: CALL_OW 69
116230: ST_TO_ADDR
// if not tmp then
116231: LD_VAR 0 2
116235: NOT
116236: IFFALSE 116240
// exit ;
116238: GO 116327
// un := tmp [ rand ( 1 , tmp ) ] ;
116240: LD_ADDR_VAR 0 1
116244: PUSH
116245: LD_VAR 0 2
116249: PUSH
116250: LD_INT 1
116252: PPUSH
116253: LD_VAR 0 2
116257: PPUSH
116258: CALL_OW 12
116262: ARRAY
116263: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116264: LD_VAR 0 1
116268: PPUSH
116269: LD_INT 0
116271: PPUSH
116272: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116276: LD_VAR 0 1
116280: PPUSH
116281: LD_OWVAR 3
116285: PUSH
116286: LD_VAR 0 1
116290: DIFF
116291: PPUSH
116292: LD_VAR 0 1
116296: PPUSH
116297: CALL_OW 74
116301: PPUSH
116302: CALL_OW 115
// wait ( 0 0$20 ) ;
116306: LD_INT 700
116308: PPUSH
116309: CALL_OW 67
// SetSide ( un , your_side ) ;
116313: LD_VAR 0 1
116317: PPUSH
116318: LD_OWVAR 2
116322: PPUSH
116323: CALL_OW 235
// end ;
116327: PPOPN 2
116329: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116330: LD_EXP 153
116334: PUSH
116335: LD_EXP 186
116339: AND
116340: IFFALSE 116446
116342: GO 116344
116344: DISABLE
116345: LD_INT 0
116347: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116348: LD_ADDR_VAR 0 1
116352: PUSH
116353: LD_INT 22
116355: PUSH
116356: LD_OWVAR 2
116360: PUSH
116361: EMPTY
116362: LIST
116363: LIST
116364: PUSH
116365: LD_INT 2
116367: PUSH
116368: LD_INT 30
116370: PUSH
116371: LD_INT 0
116373: PUSH
116374: EMPTY
116375: LIST
116376: LIST
116377: PUSH
116378: LD_INT 30
116380: PUSH
116381: LD_INT 1
116383: PUSH
116384: EMPTY
116385: LIST
116386: LIST
116387: PUSH
116388: EMPTY
116389: LIST
116390: LIST
116391: LIST
116392: PUSH
116393: EMPTY
116394: LIST
116395: LIST
116396: PPUSH
116397: CALL_OW 69
116401: ST_TO_ADDR
// if not depot then
116402: LD_VAR 0 1
116406: NOT
116407: IFFALSE 116411
// exit ;
116409: GO 116446
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116411: LD_VAR 0 1
116415: PUSH
116416: LD_INT 1
116418: ARRAY
116419: PPUSH
116420: CALL_OW 250
116424: PPUSH
116425: LD_VAR 0 1
116429: PUSH
116430: LD_INT 1
116432: ARRAY
116433: PPUSH
116434: CALL_OW 251
116438: PPUSH
116439: LD_INT 70
116441: PPUSH
116442: CALL_OW 495
// end ;
116446: PPOPN 1
116448: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116449: LD_EXP 153
116453: PUSH
116454: LD_EXP 187
116458: AND
116459: IFFALSE 116670
116461: GO 116463
116463: DISABLE
116464: LD_INT 0
116466: PPUSH
116467: PPUSH
116468: PPUSH
116469: PPUSH
116470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116471: LD_ADDR_VAR 0 5
116475: PUSH
116476: LD_INT 22
116478: PUSH
116479: LD_OWVAR 2
116483: PUSH
116484: EMPTY
116485: LIST
116486: LIST
116487: PUSH
116488: LD_INT 21
116490: PUSH
116491: LD_INT 1
116493: PUSH
116494: EMPTY
116495: LIST
116496: LIST
116497: PUSH
116498: EMPTY
116499: LIST
116500: LIST
116501: PPUSH
116502: CALL_OW 69
116506: ST_TO_ADDR
// if not tmp then
116507: LD_VAR 0 5
116511: NOT
116512: IFFALSE 116516
// exit ;
116514: GO 116670
// for i in tmp do
116516: LD_ADDR_VAR 0 1
116520: PUSH
116521: LD_VAR 0 5
116525: PUSH
116526: FOR_IN
116527: IFFALSE 116668
// begin d := rand ( 0 , 5 ) ;
116529: LD_ADDR_VAR 0 4
116533: PUSH
116534: LD_INT 0
116536: PPUSH
116537: LD_INT 5
116539: PPUSH
116540: CALL_OW 12
116544: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116545: LD_ADDR_VAR 0 2
116549: PUSH
116550: LD_VAR 0 1
116554: PPUSH
116555: CALL_OW 250
116559: PPUSH
116560: LD_VAR 0 4
116564: PPUSH
116565: LD_INT 3
116567: PPUSH
116568: LD_INT 12
116570: PPUSH
116571: CALL_OW 12
116575: PPUSH
116576: CALL_OW 272
116580: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116581: LD_ADDR_VAR 0 3
116585: PUSH
116586: LD_VAR 0 1
116590: PPUSH
116591: CALL_OW 251
116595: PPUSH
116596: LD_VAR 0 4
116600: PPUSH
116601: LD_INT 3
116603: PPUSH
116604: LD_INT 12
116606: PPUSH
116607: CALL_OW 12
116611: PPUSH
116612: CALL_OW 273
116616: ST_TO_ADDR
// if ValidHex ( x , y ) then
116617: LD_VAR 0 2
116621: PPUSH
116622: LD_VAR 0 3
116626: PPUSH
116627: CALL_OW 488
116631: IFFALSE 116666
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116633: LD_VAR 0 1
116637: PPUSH
116638: LD_VAR 0 2
116642: PPUSH
116643: LD_VAR 0 3
116647: PPUSH
116648: LD_INT 3
116650: PPUSH
116651: LD_INT 6
116653: PPUSH
116654: CALL_OW 12
116658: PPUSH
116659: LD_INT 1
116661: PPUSH
116662: CALL_OW 483
// end ;
116666: GO 116526
116668: POP
116669: POP
// end ;
116670: PPOPN 5
116672: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116673: LD_EXP 153
116677: PUSH
116678: LD_EXP 188
116682: AND
116683: IFFALSE 116777
116685: GO 116687
116687: DISABLE
116688: LD_INT 0
116690: PPUSH
116691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116692: LD_ADDR_VAR 0 2
116696: PUSH
116697: LD_INT 22
116699: PUSH
116700: LD_OWVAR 2
116704: PUSH
116705: EMPTY
116706: LIST
116707: LIST
116708: PUSH
116709: LD_INT 32
116711: PUSH
116712: LD_INT 1
116714: PUSH
116715: EMPTY
116716: LIST
116717: LIST
116718: PUSH
116719: LD_INT 21
116721: PUSH
116722: LD_INT 2
116724: PUSH
116725: EMPTY
116726: LIST
116727: LIST
116728: PUSH
116729: EMPTY
116730: LIST
116731: LIST
116732: LIST
116733: PPUSH
116734: CALL_OW 69
116738: ST_TO_ADDR
// if not tmp then
116739: LD_VAR 0 2
116743: NOT
116744: IFFALSE 116748
// exit ;
116746: GO 116777
// for i in tmp do
116748: LD_ADDR_VAR 0 1
116752: PUSH
116753: LD_VAR 0 2
116757: PUSH
116758: FOR_IN
116759: IFFALSE 116775
// SetFuel ( i , 0 ) ;
116761: LD_VAR 0 1
116765: PPUSH
116766: LD_INT 0
116768: PPUSH
116769: CALL_OW 240
116773: GO 116758
116775: POP
116776: POP
// end ;
116777: PPOPN 2
116779: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116780: LD_EXP 153
116784: PUSH
116785: LD_EXP 189
116789: AND
116790: IFFALSE 116856
116792: GO 116794
116794: DISABLE
116795: LD_INT 0
116797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116798: LD_ADDR_VAR 0 1
116802: PUSH
116803: LD_INT 22
116805: PUSH
116806: LD_OWVAR 2
116810: PUSH
116811: EMPTY
116812: LIST
116813: LIST
116814: PUSH
116815: LD_INT 30
116817: PUSH
116818: LD_INT 29
116820: PUSH
116821: EMPTY
116822: LIST
116823: LIST
116824: PUSH
116825: EMPTY
116826: LIST
116827: LIST
116828: PPUSH
116829: CALL_OW 69
116833: ST_TO_ADDR
// if not tmp then
116834: LD_VAR 0 1
116838: NOT
116839: IFFALSE 116843
// exit ;
116841: GO 116856
// DestroyUnit ( tmp [ 1 ] ) ;
116843: LD_VAR 0 1
116847: PUSH
116848: LD_INT 1
116850: ARRAY
116851: PPUSH
116852: CALL_OW 65
// end ;
116856: PPOPN 1
116858: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116859: LD_EXP 153
116863: PUSH
116864: LD_EXP 191
116868: AND
116869: IFFALSE 116998
116871: GO 116873
116873: DISABLE
116874: LD_INT 0
116876: PPUSH
// begin uc_side := 0 ;
116877: LD_ADDR_OWVAR 20
116881: PUSH
116882: LD_INT 0
116884: ST_TO_ADDR
// uc_nation := nation_arabian ;
116885: LD_ADDR_OWVAR 21
116889: PUSH
116890: LD_INT 2
116892: ST_TO_ADDR
// hc_gallery :=  ;
116893: LD_ADDR_OWVAR 33
116897: PUSH
116898: LD_STRING 
116900: ST_TO_ADDR
// hc_name :=  ;
116901: LD_ADDR_OWVAR 26
116905: PUSH
116906: LD_STRING 
116908: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116909: LD_INT 1
116911: PPUSH
116912: LD_INT 11
116914: PPUSH
116915: LD_INT 10
116917: PPUSH
116918: CALL_OW 380
// un := CreateHuman ;
116922: LD_ADDR_VAR 0 1
116926: PUSH
116927: CALL_OW 44
116931: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116932: LD_VAR 0 1
116936: PPUSH
116937: LD_INT 1
116939: PPUSH
116940: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116944: LD_INT 35
116946: PPUSH
116947: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116951: LD_VAR 0 1
116955: PPUSH
116956: LD_INT 22
116958: PUSH
116959: LD_OWVAR 2
116963: PUSH
116964: EMPTY
116965: LIST
116966: LIST
116967: PPUSH
116968: CALL_OW 69
116972: PPUSH
116973: LD_VAR 0 1
116977: PPUSH
116978: CALL_OW 74
116982: PPUSH
116983: CALL_OW 115
// until IsDead ( un ) ;
116987: LD_VAR 0 1
116991: PPUSH
116992: CALL_OW 301
116996: IFFALSE 116944
// end ;
116998: PPOPN 1
117000: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
117001: LD_EXP 153
117005: PUSH
117006: LD_EXP 193
117010: AND
117011: IFFALSE 117023
117013: GO 117015
117015: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
117016: LD_STRING earthquake(getX(game), 0, 32)
117018: PPUSH
117019: CALL_OW 559
117023: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
117024: LD_EXP 153
117028: PUSH
117029: LD_EXP 194
117033: AND
117034: IFFALSE 117125
117036: GO 117038
117038: DISABLE
117039: LD_INT 0
117041: PPUSH
// begin enable ;
117042: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
117043: LD_ADDR_VAR 0 1
117047: PUSH
117048: LD_INT 22
117050: PUSH
117051: LD_OWVAR 2
117055: PUSH
117056: EMPTY
117057: LIST
117058: LIST
117059: PUSH
117060: LD_INT 21
117062: PUSH
117063: LD_INT 2
117065: PUSH
117066: EMPTY
117067: LIST
117068: LIST
117069: PUSH
117070: LD_INT 33
117072: PUSH
117073: LD_INT 3
117075: PUSH
117076: EMPTY
117077: LIST
117078: LIST
117079: PUSH
117080: EMPTY
117081: LIST
117082: LIST
117083: LIST
117084: PPUSH
117085: CALL_OW 69
117089: ST_TO_ADDR
// if not tmp then
117090: LD_VAR 0 1
117094: NOT
117095: IFFALSE 117099
// exit ;
117097: GO 117125
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117099: LD_VAR 0 1
117103: PUSH
117104: LD_INT 1
117106: PPUSH
117107: LD_VAR 0 1
117111: PPUSH
117112: CALL_OW 12
117116: ARRAY
117117: PPUSH
117118: LD_INT 1
117120: PPUSH
117121: CALL_OW 234
// end ;
117125: PPOPN 1
117127: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
117128: LD_EXP 153
117132: PUSH
117133: LD_EXP 195
117137: AND
117138: IFFALSE 117279
117140: GO 117142
117142: DISABLE
117143: LD_INT 0
117145: PPUSH
117146: PPUSH
117147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117148: LD_ADDR_VAR 0 3
117152: PUSH
117153: LD_INT 22
117155: PUSH
117156: LD_OWVAR 2
117160: PUSH
117161: EMPTY
117162: LIST
117163: LIST
117164: PUSH
117165: LD_INT 25
117167: PUSH
117168: LD_INT 1
117170: PUSH
117171: EMPTY
117172: LIST
117173: LIST
117174: PUSH
117175: EMPTY
117176: LIST
117177: LIST
117178: PPUSH
117179: CALL_OW 69
117183: ST_TO_ADDR
// if not tmp then
117184: LD_VAR 0 3
117188: NOT
117189: IFFALSE 117193
// exit ;
117191: GO 117279
// un := tmp [ rand ( 1 , tmp ) ] ;
117193: LD_ADDR_VAR 0 2
117197: PUSH
117198: LD_VAR 0 3
117202: PUSH
117203: LD_INT 1
117205: PPUSH
117206: LD_VAR 0 3
117210: PPUSH
117211: CALL_OW 12
117215: ARRAY
117216: ST_TO_ADDR
// if Crawls ( un ) then
117217: LD_VAR 0 2
117221: PPUSH
117222: CALL_OW 318
117226: IFFALSE 117237
// ComWalk ( un ) ;
117228: LD_VAR 0 2
117232: PPUSH
117233: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117237: LD_VAR 0 2
117241: PPUSH
117242: LD_INT 9
117244: PPUSH
117245: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117249: LD_INT 28
117251: PPUSH
117252: LD_OWVAR 2
117256: PPUSH
117257: LD_INT 2
117259: PPUSH
117260: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117264: LD_INT 29
117266: PPUSH
117267: LD_OWVAR 2
117271: PPUSH
117272: LD_INT 2
117274: PPUSH
117275: CALL_OW 322
// end ;
117279: PPOPN 3
117281: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117282: LD_EXP 153
117286: PUSH
117287: LD_EXP 196
117291: AND
117292: IFFALSE 117403
117294: GO 117296
117296: DISABLE
117297: LD_INT 0
117299: PPUSH
117300: PPUSH
117301: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117302: LD_ADDR_VAR 0 3
117306: PUSH
117307: LD_INT 22
117309: PUSH
117310: LD_OWVAR 2
117314: PUSH
117315: EMPTY
117316: LIST
117317: LIST
117318: PUSH
117319: LD_INT 25
117321: PUSH
117322: LD_INT 1
117324: PUSH
117325: EMPTY
117326: LIST
117327: LIST
117328: PUSH
117329: EMPTY
117330: LIST
117331: LIST
117332: PPUSH
117333: CALL_OW 69
117337: ST_TO_ADDR
// if not tmp then
117338: LD_VAR 0 3
117342: NOT
117343: IFFALSE 117347
// exit ;
117345: GO 117403
// un := tmp [ rand ( 1 , tmp ) ] ;
117347: LD_ADDR_VAR 0 2
117351: PUSH
117352: LD_VAR 0 3
117356: PUSH
117357: LD_INT 1
117359: PPUSH
117360: LD_VAR 0 3
117364: PPUSH
117365: CALL_OW 12
117369: ARRAY
117370: ST_TO_ADDR
// if Crawls ( un ) then
117371: LD_VAR 0 2
117375: PPUSH
117376: CALL_OW 318
117380: IFFALSE 117391
// ComWalk ( un ) ;
117382: LD_VAR 0 2
117386: PPUSH
117387: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117391: LD_VAR 0 2
117395: PPUSH
117396: LD_INT 8
117398: PPUSH
117399: CALL_OW 336
// end ;
117403: PPOPN 3
117405: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117406: LD_EXP 153
117410: PUSH
117411: LD_EXP 197
117415: AND
117416: IFFALSE 117560
117418: GO 117420
117420: DISABLE
117421: LD_INT 0
117423: PPUSH
117424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117425: LD_ADDR_VAR 0 2
117429: PUSH
117430: LD_INT 22
117432: PUSH
117433: LD_OWVAR 2
117437: PUSH
117438: EMPTY
117439: LIST
117440: LIST
117441: PUSH
117442: LD_INT 21
117444: PUSH
117445: LD_INT 2
117447: PUSH
117448: EMPTY
117449: LIST
117450: LIST
117451: PUSH
117452: LD_INT 2
117454: PUSH
117455: LD_INT 34
117457: PUSH
117458: LD_INT 12
117460: PUSH
117461: EMPTY
117462: LIST
117463: LIST
117464: PUSH
117465: LD_INT 34
117467: PUSH
117468: LD_INT 51
117470: PUSH
117471: EMPTY
117472: LIST
117473: LIST
117474: PUSH
117475: LD_INT 34
117477: PUSH
117478: LD_INT 32
117480: PUSH
117481: EMPTY
117482: LIST
117483: LIST
117484: PUSH
117485: EMPTY
117486: LIST
117487: LIST
117488: LIST
117489: LIST
117490: PUSH
117491: EMPTY
117492: LIST
117493: LIST
117494: LIST
117495: PPUSH
117496: CALL_OW 69
117500: ST_TO_ADDR
// if not tmp then
117501: LD_VAR 0 2
117505: NOT
117506: IFFALSE 117510
// exit ;
117508: GO 117560
// for i in tmp do
117510: LD_ADDR_VAR 0 1
117514: PUSH
117515: LD_VAR 0 2
117519: PUSH
117520: FOR_IN
117521: IFFALSE 117558
// if GetCargo ( i , mat_artifact ) = 0 then
117523: LD_VAR 0 1
117527: PPUSH
117528: LD_INT 4
117530: PPUSH
117531: CALL_OW 289
117535: PUSH
117536: LD_INT 0
117538: EQUAL
117539: IFFALSE 117556
// SetCargo ( i , mat_siberit , 100 ) ;
117541: LD_VAR 0 1
117545: PPUSH
117546: LD_INT 3
117548: PPUSH
117549: LD_INT 100
117551: PPUSH
117552: CALL_OW 290
117556: GO 117520
117558: POP
117559: POP
// end ;
117560: PPOPN 2
117562: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117563: LD_EXP 153
117567: PUSH
117568: LD_EXP 198
117572: AND
117573: IFFALSE 117726
117575: GO 117577
117577: DISABLE
117578: LD_INT 0
117580: PPUSH
117581: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117582: LD_ADDR_VAR 0 2
117586: PUSH
117587: LD_INT 22
117589: PUSH
117590: LD_OWVAR 2
117594: PUSH
117595: EMPTY
117596: LIST
117597: LIST
117598: PPUSH
117599: CALL_OW 69
117603: ST_TO_ADDR
// if not tmp then
117604: LD_VAR 0 2
117608: NOT
117609: IFFALSE 117613
// exit ;
117611: GO 117726
// for i := 1 to 2 do
117613: LD_ADDR_VAR 0 1
117617: PUSH
117618: DOUBLE
117619: LD_INT 1
117621: DEC
117622: ST_TO_ADDR
117623: LD_INT 2
117625: PUSH
117626: FOR_TO
117627: IFFALSE 117724
// begin uc_side := your_side ;
117629: LD_ADDR_OWVAR 20
117633: PUSH
117634: LD_OWVAR 2
117638: ST_TO_ADDR
// uc_nation := nation_american ;
117639: LD_ADDR_OWVAR 21
117643: PUSH
117644: LD_INT 1
117646: ST_TO_ADDR
// vc_chassis := us_morphling ;
117647: LD_ADDR_OWVAR 37
117651: PUSH
117652: LD_INT 5
117654: ST_TO_ADDR
// vc_engine := engine_siberite ;
117655: LD_ADDR_OWVAR 39
117659: PUSH
117660: LD_INT 3
117662: ST_TO_ADDR
// vc_control := control_computer ;
117663: LD_ADDR_OWVAR 38
117667: PUSH
117668: LD_INT 3
117670: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117671: LD_ADDR_OWVAR 40
117675: PUSH
117676: LD_INT 10
117678: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
117679: CALL_OW 45
117683: PPUSH
117684: LD_VAR 0 2
117688: PUSH
117689: LD_INT 1
117691: ARRAY
117692: PPUSH
117693: CALL_OW 250
117697: PPUSH
117698: LD_VAR 0 2
117702: PUSH
117703: LD_INT 1
117705: ARRAY
117706: PPUSH
117707: CALL_OW 251
117711: PPUSH
117712: LD_INT 12
117714: PPUSH
117715: LD_INT 1
117717: PPUSH
117718: CALL_OW 50
// end ;
117722: GO 117626
117724: POP
117725: POP
// end ;
117726: PPOPN 2
117728: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117729: LD_EXP 153
117733: PUSH
117734: LD_EXP 199
117738: AND
117739: IFFALSE 117961
117741: GO 117743
117743: DISABLE
117744: LD_INT 0
117746: PPUSH
117747: PPUSH
117748: PPUSH
117749: PPUSH
117750: PPUSH
117751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117752: LD_ADDR_VAR 0 6
117756: PUSH
117757: LD_INT 22
117759: PUSH
117760: LD_OWVAR 2
117764: PUSH
117765: EMPTY
117766: LIST
117767: LIST
117768: PUSH
117769: LD_INT 21
117771: PUSH
117772: LD_INT 1
117774: PUSH
117775: EMPTY
117776: LIST
117777: LIST
117778: PUSH
117779: LD_INT 3
117781: PUSH
117782: LD_INT 23
117784: PUSH
117785: LD_INT 0
117787: PUSH
117788: EMPTY
117789: LIST
117790: LIST
117791: PUSH
117792: EMPTY
117793: LIST
117794: LIST
117795: PUSH
117796: EMPTY
117797: LIST
117798: LIST
117799: LIST
117800: PPUSH
117801: CALL_OW 69
117805: ST_TO_ADDR
// if not tmp then
117806: LD_VAR 0 6
117810: NOT
117811: IFFALSE 117815
// exit ;
117813: GO 117961
// s1 := rand ( 1 , 4 ) ;
117815: LD_ADDR_VAR 0 2
117819: PUSH
117820: LD_INT 1
117822: PPUSH
117823: LD_INT 4
117825: PPUSH
117826: CALL_OW 12
117830: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117831: LD_ADDR_VAR 0 4
117835: PUSH
117836: LD_VAR 0 6
117840: PUSH
117841: LD_INT 1
117843: ARRAY
117844: PPUSH
117845: LD_VAR 0 2
117849: PPUSH
117850: CALL_OW 259
117854: ST_TO_ADDR
// if s1 = 1 then
117855: LD_VAR 0 2
117859: PUSH
117860: LD_INT 1
117862: EQUAL
117863: IFFALSE 117883
// s2 := rand ( 2 , 4 ) else
117865: LD_ADDR_VAR 0 3
117869: PUSH
117870: LD_INT 2
117872: PPUSH
117873: LD_INT 4
117875: PPUSH
117876: CALL_OW 12
117880: ST_TO_ADDR
117881: GO 117891
// s2 := 1 ;
117883: LD_ADDR_VAR 0 3
117887: PUSH
117888: LD_INT 1
117890: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117891: LD_ADDR_VAR 0 5
117895: PUSH
117896: LD_VAR 0 6
117900: PUSH
117901: LD_INT 1
117903: ARRAY
117904: PPUSH
117905: LD_VAR 0 3
117909: PPUSH
117910: CALL_OW 259
117914: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
117915: LD_VAR 0 6
117919: PUSH
117920: LD_INT 1
117922: ARRAY
117923: PPUSH
117924: LD_VAR 0 2
117928: PPUSH
117929: LD_VAR 0 5
117933: PPUSH
117934: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
117938: LD_VAR 0 6
117942: PUSH
117943: LD_INT 1
117945: ARRAY
117946: PPUSH
117947: LD_VAR 0 3
117951: PPUSH
117952: LD_VAR 0 4
117956: PPUSH
117957: CALL_OW 237
// end ;
117961: PPOPN 6
117963: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
117964: LD_EXP 153
117968: PUSH
117969: LD_EXP 200
117973: AND
117974: IFFALSE 118053
117976: GO 117978
117978: DISABLE
117979: LD_INT 0
117981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
117982: LD_ADDR_VAR 0 1
117986: PUSH
117987: LD_INT 22
117989: PUSH
117990: LD_OWVAR 2
117994: PUSH
117995: EMPTY
117996: LIST
117997: LIST
117998: PUSH
117999: LD_INT 30
118001: PUSH
118002: LD_INT 3
118004: PUSH
118005: EMPTY
118006: LIST
118007: LIST
118008: PUSH
118009: EMPTY
118010: LIST
118011: LIST
118012: PPUSH
118013: CALL_OW 69
118017: ST_TO_ADDR
// if not tmp then
118018: LD_VAR 0 1
118022: NOT
118023: IFFALSE 118027
// exit ;
118025: GO 118053
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118027: LD_VAR 0 1
118031: PUSH
118032: LD_INT 1
118034: PPUSH
118035: LD_VAR 0 1
118039: PPUSH
118040: CALL_OW 12
118044: ARRAY
118045: PPUSH
118046: LD_INT 1
118048: PPUSH
118049: CALL_OW 234
// end ;
118053: PPOPN 1
118055: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
118056: LD_EXP 153
118060: PUSH
118061: LD_EXP 201
118065: AND
118066: IFFALSE 118178
118068: GO 118070
118070: DISABLE
118071: LD_INT 0
118073: PPUSH
118074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
118075: LD_ADDR_VAR 0 2
118079: PUSH
118080: LD_INT 22
118082: PUSH
118083: LD_OWVAR 2
118087: PUSH
118088: EMPTY
118089: LIST
118090: LIST
118091: PUSH
118092: LD_INT 2
118094: PUSH
118095: LD_INT 30
118097: PUSH
118098: LD_INT 27
118100: PUSH
118101: EMPTY
118102: LIST
118103: LIST
118104: PUSH
118105: LD_INT 30
118107: PUSH
118108: LD_INT 26
118110: PUSH
118111: EMPTY
118112: LIST
118113: LIST
118114: PUSH
118115: LD_INT 30
118117: PUSH
118118: LD_INT 28
118120: PUSH
118121: EMPTY
118122: LIST
118123: LIST
118124: PUSH
118125: EMPTY
118126: LIST
118127: LIST
118128: LIST
118129: LIST
118130: PUSH
118131: EMPTY
118132: LIST
118133: LIST
118134: PPUSH
118135: CALL_OW 69
118139: ST_TO_ADDR
// if not tmp then
118140: LD_VAR 0 2
118144: NOT
118145: IFFALSE 118149
// exit ;
118147: GO 118178
// for i in tmp do
118149: LD_ADDR_VAR 0 1
118153: PUSH
118154: LD_VAR 0 2
118158: PUSH
118159: FOR_IN
118160: IFFALSE 118176
// SetLives ( i , 1 ) ;
118162: LD_VAR 0 1
118166: PPUSH
118167: LD_INT 1
118169: PPUSH
118170: CALL_OW 234
118174: GO 118159
118176: POP
118177: POP
// end ;
118178: PPOPN 2
118180: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118181: LD_EXP 153
118185: PUSH
118186: LD_EXP 202
118190: AND
118191: IFFALSE 118465
118193: GO 118195
118195: DISABLE
118196: LD_INT 0
118198: PPUSH
118199: PPUSH
118200: PPUSH
// begin i := rand ( 1 , 7 ) ;
118201: LD_ADDR_VAR 0 1
118205: PUSH
118206: LD_INT 1
118208: PPUSH
118209: LD_INT 7
118211: PPUSH
118212: CALL_OW 12
118216: ST_TO_ADDR
// case i of 1 :
118217: LD_VAR 0 1
118221: PUSH
118222: LD_INT 1
118224: DOUBLE
118225: EQUAL
118226: IFTRUE 118230
118228: GO 118240
118230: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118231: LD_STRING earthquake(getX(game), 0, 32)
118233: PPUSH
118234: CALL_OW 559
118238: GO 118465
118240: LD_INT 2
118242: DOUBLE
118243: EQUAL
118244: IFTRUE 118248
118246: GO 118262
118248: POP
// begin ToLua ( displayStucuk(); ) ;
118249: LD_STRING displayStucuk();
118251: PPUSH
118252: CALL_OW 559
// ResetFog ;
118256: CALL_OW 335
// end ; 3 :
118260: GO 118465
118262: LD_INT 3
118264: DOUBLE
118265: EQUAL
118266: IFTRUE 118270
118268: GO 118374
118270: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118271: LD_ADDR_VAR 0 2
118275: PUSH
118276: LD_INT 22
118278: PUSH
118279: LD_OWVAR 2
118283: PUSH
118284: EMPTY
118285: LIST
118286: LIST
118287: PUSH
118288: LD_INT 25
118290: PUSH
118291: LD_INT 1
118293: PUSH
118294: EMPTY
118295: LIST
118296: LIST
118297: PUSH
118298: EMPTY
118299: LIST
118300: LIST
118301: PPUSH
118302: CALL_OW 69
118306: ST_TO_ADDR
// if not tmp then
118307: LD_VAR 0 2
118311: NOT
118312: IFFALSE 118316
// exit ;
118314: GO 118465
// un := tmp [ rand ( 1 , tmp ) ] ;
118316: LD_ADDR_VAR 0 3
118320: PUSH
118321: LD_VAR 0 2
118325: PUSH
118326: LD_INT 1
118328: PPUSH
118329: LD_VAR 0 2
118333: PPUSH
118334: CALL_OW 12
118338: ARRAY
118339: ST_TO_ADDR
// if Crawls ( un ) then
118340: LD_VAR 0 3
118344: PPUSH
118345: CALL_OW 318
118349: IFFALSE 118360
// ComWalk ( un ) ;
118351: LD_VAR 0 3
118355: PPUSH
118356: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118360: LD_VAR 0 3
118364: PPUSH
118365: LD_INT 8
118367: PPUSH
118368: CALL_OW 336
// end ; 4 :
118372: GO 118465
118374: LD_INT 4
118376: DOUBLE
118377: EQUAL
118378: IFTRUE 118382
118380: GO 118443
118382: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118383: LD_ADDR_VAR 0 2
118387: PUSH
118388: LD_INT 22
118390: PUSH
118391: LD_OWVAR 2
118395: PUSH
118396: EMPTY
118397: LIST
118398: LIST
118399: PUSH
118400: LD_INT 30
118402: PUSH
118403: LD_INT 29
118405: PUSH
118406: EMPTY
118407: LIST
118408: LIST
118409: PUSH
118410: EMPTY
118411: LIST
118412: LIST
118413: PPUSH
118414: CALL_OW 69
118418: ST_TO_ADDR
// if not tmp then
118419: LD_VAR 0 2
118423: NOT
118424: IFFALSE 118428
// exit ;
118426: GO 118465
// DestroyUnit ( tmp [ 1 ] ) ;
118428: LD_VAR 0 2
118432: PUSH
118433: LD_INT 1
118435: ARRAY
118436: PPUSH
118437: CALL_OW 65
// end ; 5 .. 7 :
118441: GO 118465
118443: LD_INT 5
118445: DOUBLE
118446: GREATEREQUAL
118447: IFFALSE 118455
118449: LD_INT 7
118451: DOUBLE
118452: LESSEQUAL
118453: IFTRUE 118457
118455: GO 118464
118457: POP
// StreamSibBomb ; end ;
118458: CALL 114745 0 0
118462: GO 118465
118464: POP
// end ;
118465: PPOPN 3
118467: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118468: LD_EXP 153
118472: PUSH
118473: LD_EXP 203
118477: AND
118478: IFFALSE 118634
118480: GO 118482
118482: DISABLE
118483: LD_INT 0
118485: PPUSH
118486: PPUSH
118487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118488: LD_ADDR_VAR 0 2
118492: PUSH
118493: LD_INT 81
118495: PUSH
118496: LD_OWVAR 2
118500: PUSH
118501: EMPTY
118502: LIST
118503: LIST
118504: PUSH
118505: LD_INT 2
118507: PUSH
118508: LD_INT 21
118510: PUSH
118511: LD_INT 1
118513: PUSH
118514: EMPTY
118515: LIST
118516: LIST
118517: PUSH
118518: LD_INT 21
118520: PUSH
118521: LD_INT 2
118523: PUSH
118524: EMPTY
118525: LIST
118526: LIST
118527: PUSH
118528: EMPTY
118529: LIST
118530: LIST
118531: LIST
118532: PUSH
118533: EMPTY
118534: LIST
118535: LIST
118536: PPUSH
118537: CALL_OW 69
118541: ST_TO_ADDR
// if not tmp then
118542: LD_VAR 0 2
118546: NOT
118547: IFFALSE 118551
// exit ;
118549: GO 118634
// p := 0 ;
118551: LD_ADDR_VAR 0 3
118555: PUSH
118556: LD_INT 0
118558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118559: LD_INT 35
118561: PPUSH
118562: CALL_OW 67
// p := p + 1 ;
118566: LD_ADDR_VAR 0 3
118570: PUSH
118571: LD_VAR 0 3
118575: PUSH
118576: LD_INT 1
118578: PLUS
118579: ST_TO_ADDR
// for i in tmp do
118580: LD_ADDR_VAR 0 1
118584: PUSH
118585: LD_VAR 0 2
118589: PUSH
118590: FOR_IN
118591: IFFALSE 118622
// if GetLives ( i ) < 1000 then
118593: LD_VAR 0 1
118597: PPUSH
118598: CALL_OW 256
118602: PUSH
118603: LD_INT 1000
118605: LESS
118606: IFFALSE 118620
// SetLives ( i , 1000 ) ;
118608: LD_VAR 0 1
118612: PPUSH
118613: LD_INT 1000
118615: PPUSH
118616: CALL_OW 234
118620: GO 118590
118622: POP
118623: POP
// until p > 20 ;
118624: LD_VAR 0 3
118628: PUSH
118629: LD_INT 20
118631: GREATER
118632: IFFALSE 118559
// end ;
118634: PPOPN 3
118636: END
// every 0 0$1 trigger StreamModeActive and sTime do
118637: LD_EXP 153
118641: PUSH
118642: LD_EXP 204
118646: AND
118647: IFFALSE 118682
118649: GO 118651
118651: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118652: LD_INT 28
118654: PPUSH
118655: LD_OWVAR 2
118659: PPUSH
118660: LD_INT 2
118662: PPUSH
118663: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118667: LD_INT 30
118669: PPUSH
118670: LD_OWVAR 2
118674: PPUSH
118675: LD_INT 2
118677: PPUSH
118678: CALL_OW 322
// end ;
118682: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118683: LD_EXP 153
118687: PUSH
118688: LD_EXP 205
118692: AND
118693: IFFALSE 118814
118695: GO 118697
118697: DISABLE
118698: LD_INT 0
118700: PPUSH
118701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118702: LD_ADDR_VAR 0 2
118706: PUSH
118707: LD_INT 22
118709: PUSH
118710: LD_OWVAR 2
118714: PUSH
118715: EMPTY
118716: LIST
118717: LIST
118718: PUSH
118719: LD_INT 21
118721: PUSH
118722: LD_INT 1
118724: PUSH
118725: EMPTY
118726: LIST
118727: LIST
118728: PUSH
118729: LD_INT 3
118731: PUSH
118732: LD_INT 23
118734: PUSH
118735: LD_INT 0
118737: PUSH
118738: EMPTY
118739: LIST
118740: LIST
118741: PUSH
118742: EMPTY
118743: LIST
118744: LIST
118745: PUSH
118746: EMPTY
118747: LIST
118748: LIST
118749: LIST
118750: PPUSH
118751: CALL_OW 69
118755: ST_TO_ADDR
// if not tmp then
118756: LD_VAR 0 2
118760: NOT
118761: IFFALSE 118765
// exit ;
118763: GO 118814
// for i in tmp do
118765: LD_ADDR_VAR 0 1
118769: PUSH
118770: LD_VAR 0 2
118774: PUSH
118775: FOR_IN
118776: IFFALSE 118812
// begin if Crawls ( i ) then
118778: LD_VAR 0 1
118782: PPUSH
118783: CALL_OW 318
118787: IFFALSE 118798
// ComWalk ( i ) ;
118789: LD_VAR 0 1
118793: PPUSH
118794: CALL_OW 138
// SetClass ( i , 2 ) ;
118798: LD_VAR 0 1
118802: PPUSH
118803: LD_INT 2
118805: PPUSH
118806: CALL_OW 336
// end ;
118810: GO 118775
118812: POP
118813: POP
// end ;
118814: PPOPN 2
118816: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118817: LD_EXP 153
118821: PUSH
118822: LD_EXP 206
118826: AND
118827: IFFALSE 119108
118829: GO 118831
118831: DISABLE
118832: LD_INT 0
118834: PPUSH
118835: PPUSH
118836: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118837: LD_OWVAR 2
118841: PPUSH
118842: LD_INT 9
118844: PPUSH
118845: LD_INT 1
118847: PPUSH
118848: LD_INT 1
118850: PPUSH
118851: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118855: LD_INT 9
118857: PPUSH
118858: LD_OWVAR 2
118862: PPUSH
118863: CALL_OW 343
// uc_side := 9 ;
118867: LD_ADDR_OWVAR 20
118871: PUSH
118872: LD_INT 9
118874: ST_TO_ADDR
// uc_nation := 2 ;
118875: LD_ADDR_OWVAR 21
118879: PUSH
118880: LD_INT 2
118882: ST_TO_ADDR
// hc_name := Dark Warrior ;
118883: LD_ADDR_OWVAR 26
118887: PUSH
118888: LD_STRING Dark Warrior
118890: ST_TO_ADDR
// hc_gallery :=  ;
118891: LD_ADDR_OWVAR 33
118895: PUSH
118896: LD_STRING 
118898: ST_TO_ADDR
// hc_noskilllimit := true ;
118899: LD_ADDR_OWVAR 76
118903: PUSH
118904: LD_INT 1
118906: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
118907: LD_ADDR_OWVAR 31
118911: PUSH
118912: LD_INT 30
118914: PUSH
118915: LD_INT 30
118917: PUSH
118918: LD_INT 30
118920: PUSH
118921: LD_INT 30
118923: PUSH
118924: EMPTY
118925: LIST
118926: LIST
118927: LIST
118928: LIST
118929: ST_TO_ADDR
// un := CreateHuman ;
118930: LD_ADDR_VAR 0 3
118934: PUSH
118935: CALL_OW 44
118939: ST_TO_ADDR
// hc_noskilllimit := false ;
118940: LD_ADDR_OWVAR 76
118944: PUSH
118945: LD_INT 0
118947: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118948: LD_VAR 0 3
118952: PPUSH
118953: LD_INT 1
118955: PPUSH
118956: CALL_OW 51
// p := 0 ;
118960: LD_ADDR_VAR 0 2
118964: PUSH
118965: LD_INT 0
118967: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118968: LD_INT 35
118970: PPUSH
118971: CALL_OW 67
// p := p + 1 ;
118975: LD_ADDR_VAR 0 2
118979: PUSH
118980: LD_VAR 0 2
118984: PUSH
118985: LD_INT 1
118987: PLUS
118988: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118989: LD_VAR 0 3
118993: PPUSH
118994: CALL_OW 256
118998: PUSH
118999: LD_INT 1000
119001: LESS
119002: IFFALSE 119016
// SetLives ( un , 1000 ) ;
119004: LD_VAR 0 3
119008: PPUSH
119009: LD_INT 1000
119011: PPUSH
119012: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
119016: LD_VAR 0 3
119020: PPUSH
119021: LD_INT 81
119023: PUSH
119024: LD_OWVAR 2
119028: PUSH
119029: EMPTY
119030: LIST
119031: LIST
119032: PUSH
119033: LD_INT 91
119035: PUSH
119036: LD_VAR 0 3
119040: PUSH
119041: LD_INT 30
119043: PUSH
119044: EMPTY
119045: LIST
119046: LIST
119047: LIST
119048: PUSH
119049: EMPTY
119050: LIST
119051: LIST
119052: PPUSH
119053: CALL_OW 69
119057: PPUSH
119058: LD_VAR 0 3
119062: PPUSH
119063: CALL_OW 74
119067: PPUSH
119068: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
119072: LD_VAR 0 2
119076: PUSH
119077: LD_INT 60
119079: GREATER
119080: PUSH
119081: LD_VAR 0 3
119085: PPUSH
119086: CALL_OW 301
119090: OR
119091: IFFALSE 118968
// if un then
119093: LD_VAR 0 3
119097: IFFALSE 119108
// RemoveUnit ( un ) ;
119099: LD_VAR 0 3
119103: PPUSH
119104: CALL_OW 64
// end ; end_of_file
119108: PPOPN 3
119110: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
119111: LD_INT 0
119113: PPUSH
119114: PPUSH
119115: PPUSH
119116: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
119117: LD_VAR 0 1
119121: PPUSH
119122: CALL_OW 264
119126: PUSH
119127: LD_EXP 99
119131: EQUAL
119132: IFFALSE 119204
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
119134: LD_INT 68
119136: PPUSH
119137: LD_VAR 0 1
119141: PPUSH
119142: CALL_OW 255
119146: PPUSH
119147: CALL_OW 321
119151: PUSH
119152: LD_INT 2
119154: EQUAL
119155: IFFALSE 119167
// eff := 70 else
119157: LD_ADDR_VAR 0 4
119161: PUSH
119162: LD_INT 70
119164: ST_TO_ADDR
119165: GO 119175
// eff := 30 ;
119167: LD_ADDR_VAR 0 4
119171: PUSH
119172: LD_INT 30
119174: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
119175: LD_VAR 0 1
119179: PPUSH
119180: CALL_OW 250
119184: PPUSH
119185: LD_VAR 0 1
119189: PPUSH
119190: CALL_OW 251
119194: PPUSH
119195: LD_VAR 0 4
119199: PPUSH
119200: CALL_OW 495
// end ; end ;
119204: LD_VAR 0 2
119208: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
119209: LD_INT 0
119211: PPUSH
// end ;
119212: LD_VAR 0 4
119216: RET
// export function SOS_Command ( cmd ) ; begin
119217: LD_INT 0
119219: PPUSH
// end ;
119220: LD_VAR 0 2
119224: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
119225: LD_VAR 0 1
119229: PUSH
119230: LD_INT 255
119232: EQUAL
119233: PUSH
119234: LD_VAR 0 2
119238: PPUSH
119239: CALL_OW 264
119243: PUSH
119244: LD_INT 14
119246: PUSH
119247: LD_INT 53
119249: PUSH
119250: EMPTY
119251: LIST
119252: LIST
119253: IN
119254: AND
119255: PUSH
119256: LD_VAR 0 4
119260: PPUSH
119261: LD_VAR 0 5
119265: PPUSH
119266: CALL_OW 488
119270: AND
119271: IFFALSE 119295
// CutTreeXYR ( unit , x , y , 12 ) ;
119273: LD_VAR 0 2
119277: PPUSH
119278: LD_VAR 0 4
119282: PPUSH
119283: LD_VAR 0 5
119287: PPUSH
119288: LD_INT 12
119290: PPUSH
119291: CALL 119298 0 4
// end ;
119295: PPOPN 5
119297: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119298: LD_INT 0
119300: PPUSH
119301: PPUSH
119302: PPUSH
119303: PPUSH
119304: PPUSH
119305: PPUSH
119306: PPUSH
119307: PPUSH
119308: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119309: LD_VAR 0 1
119313: NOT
119314: PUSH
119315: LD_VAR 0 2
119319: PPUSH
119320: LD_VAR 0 3
119324: PPUSH
119325: CALL_OW 488
119329: NOT
119330: OR
119331: PUSH
119332: LD_VAR 0 4
119336: NOT
119337: OR
119338: IFFALSE 119342
// exit ;
119340: GO 119682
// list := [ ] ;
119342: LD_ADDR_VAR 0 13
119346: PUSH
119347: EMPTY
119348: ST_TO_ADDR
// if x - r < 0 then
119349: LD_VAR 0 2
119353: PUSH
119354: LD_VAR 0 4
119358: MINUS
119359: PUSH
119360: LD_INT 0
119362: LESS
119363: IFFALSE 119375
// min_x := 0 else
119365: LD_ADDR_VAR 0 7
119369: PUSH
119370: LD_INT 0
119372: ST_TO_ADDR
119373: GO 119391
// min_x := x - r ;
119375: LD_ADDR_VAR 0 7
119379: PUSH
119380: LD_VAR 0 2
119384: PUSH
119385: LD_VAR 0 4
119389: MINUS
119390: ST_TO_ADDR
// if y - r < 0 then
119391: LD_VAR 0 3
119395: PUSH
119396: LD_VAR 0 4
119400: MINUS
119401: PUSH
119402: LD_INT 0
119404: LESS
119405: IFFALSE 119417
// min_y := 0 else
119407: LD_ADDR_VAR 0 8
119411: PUSH
119412: LD_INT 0
119414: ST_TO_ADDR
119415: GO 119433
// min_y := y - r ;
119417: LD_ADDR_VAR 0 8
119421: PUSH
119422: LD_VAR 0 3
119426: PUSH
119427: LD_VAR 0 4
119431: MINUS
119432: ST_TO_ADDR
// max_x := x + r ;
119433: LD_ADDR_VAR 0 9
119437: PUSH
119438: LD_VAR 0 2
119442: PUSH
119443: LD_VAR 0 4
119447: PLUS
119448: ST_TO_ADDR
// max_y := y + r ;
119449: LD_ADDR_VAR 0 10
119453: PUSH
119454: LD_VAR 0 3
119458: PUSH
119459: LD_VAR 0 4
119463: PLUS
119464: ST_TO_ADDR
// for _x = min_x to max_x do
119465: LD_ADDR_VAR 0 11
119469: PUSH
119470: DOUBLE
119471: LD_VAR 0 7
119475: DEC
119476: ST_TO_ADDR
119477: LD_VAR 0 9
119481: PUSH
119482: FOR_TO
119483: IFFALSE 119600
// for _y = min_y to max_y do
119485: LD_ADDR_VAR 0 12
119489: PUSH
119490: DOUBLE
119491: LD_VAR 0 8
119495: DEC
119496: ST_TO_ADDR
119497: LD_VAR 0 10
119501: PUSH
119502: FOR_TO
119503: IFFALSE 119596
// begin if not ValidHex ( _x , _y ) then
119505: LD_VAR 0 11
119509: PPUSH
119510: LD_VAR 0 12
119514: PPUSH
119515: CALL_OW 488
119519: NOT
119520: IFFALSE 119524
// continue ;
119522: GO 119502
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119524: LD_VAR 0 11
119528: PPUSH
119529: LD_VAR 0 12
119533: PPUSH
119534: CALL_OW 351
119538: PUSH
119539: LD_VAR 0 11
119543: PPUSH
119544: LD_VAR 0 12
119548: PPUSH
119549: CALL_OW 554
119553: AND
119554: IFFALSE 119594
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119556: LD_ADDR_VAR 0 13
119560: PUSH
119561: LD_VAR 0 13
119565: PPUSH
119566: LD_VAR 0 13
119570: PUSH
119571: LD_INT 1
119573: PLUS
119574: PPUSH
119575: LD_VAR 0 11
119579: PUSH
119580: LD_VAR 0 12
119584: PUSH
119585: EMPTY
119586: LIST
119587: LIST
119588: PPUSH
119589: CALL_OW 2
119593: ST_TO_ADDR
// end ;
119594: GO 119502
119596: POP
119597: POP
119598: GO 119482
119600: POP
119601: POP
// if not list then
119602: LD_VAR 0 13
119606: NOT
119607: IFFALSE 119611
// exit ;
119609: GO 119682
// for i in list do
119611: LD_ADDR_VAR 0 6
119615: PUSH
119616: LD_VAR 0 13
119620: PUSH
119621: FOR_IN
119622: IFFALSE 119680
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119624: LD_VAR 0 1
119628: PPUSH
119629: LD_STRING M
119631: PUSH
119632: LD_VAR 0 6
119636: PUSH
119637: LD_INT 1
119639: ARRAY
119640: PUSH
119641: LD_VAR 0 6
119645: PUSH
119646: LD_INT 2
119648: ARRAY
119649: PUSH
119650: LD_INT 0
119652: PUSH
119653: LD_INT 0
119655: PUSH
119656: LD_INT 0
119658: PUSH
119659: LD_INT 0
119661: PUSH
119662: EMPTY
119663: LIST
119664: LIST
119665: LIST
119666: LIST
119667: LIST
119668: LIST
119669: LIST
119670: PUSH
119671: EMPTY
119672: LIST
119673: PPUSH
119674: CALL_OW 447
119678: GO 119621
119680: POP
119681: POP
// end ;
119682: LD_VAR 0 5
119686: RET
