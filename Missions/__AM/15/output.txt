// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35114 0 0
// InitMacro ;
  19: CALL 35290 0 0
// InitNature ;
  23: CALL 34982 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11169 0 0
// PrepareRussian ;
  44: CALL 7025 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15071 0 0
// MC_Start ( ) ;
  64: CALL 37455 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 141
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 142
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60204 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60297 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59647 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59462 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60204 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60297 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59462 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59647 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 60077 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 59144 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60204 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60297 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 146
 963: PUSH
 964: LD_EXP 146
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59462 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60204 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60297 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59354 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60615 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59786 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 60077 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 60077 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60409 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59462 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 60028 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65916 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70780 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70780 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70780 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70780 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70780 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65916 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65916 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65916 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65916 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65916 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65916 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65916 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65916 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65916 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65916 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65916 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65916 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65916 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65916 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65916 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65916 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65916 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65916 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65916 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65916 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65916 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65916 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65916 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65916 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65916 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65916 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65916 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65916 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70780 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65916 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65916 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65916 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74226 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 117
4751: PUSH
4752: LD_EXP 117
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70780 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59647 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59510 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60928 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59510 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59510 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60928 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60928 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 136
6051: PUSH
6052: LD_EXP 136
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 136
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7022
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70780 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// if legionDestroyed then
6858: LD_EXP 22
6862: IFFALSE 6866
// exit ;
6864: GO 7022
// for i in tmp do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: LD_VAR 0 3
6875: PUSH
6876: FOR_IN
6877: IFFALSE 7013
// begin if GetLives ( i ) > 250 then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 256
6888: PUSH
6889: LD_INT 250
6891: GREATER
6892: IFFALSE 6984
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6894: LD_INT 81
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 91
6906: PUSH
6907: LD_VAR 0 1
6911: PUSH
6912: LD_INT 10
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PPUSH
6924: CALL_OW 69
6928: NOT
6929: IFFALSE 6948
// ComAgressiveMove ( i , 67 , 110 ) else
6931: LD_VAR 0 1
6935: PPUSH
6936: LD_INT 67
6938: PPUSH
6939: LD_INT 110
6941: PPUSH
6942: CALL_OW 114
6946: GO 6982
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6948: LD_VAR 0 1
6952: PPUSH
6953: LD_INT 81
6955: PUSH
6956: LD_INT 8
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PPUSH
6963: CALL_OW 69
6967: PPUSH
6968: LD_VAR 0 1
6972: PPUSH
6973: CALL_OW 74
6977: PPUSH
6978: CALL_OW 115
// end else
6982: GO 7011
// if IsDead ( i ) then
6984: LD_VAR 0 1
6988: PPUSH
6989: CALL_OW 301
6993: IFFALSE 7011
// tmp := tmp diff i ;
6995: LD_ADDR_VAR 0 3
6999: PUSH
7000: LD_VAR 0 3
7004: PUSH
7005: LD_VAR 0 1
7009: DIFF
7010: ST_TO_ADDR
// end ;
7011: GO 6876
7013: POP
7014: POP
// until not tmp ;
7015: LD_VAR 0 3
7019: NOT
7020: IFFALSE 6851
// end ; end_of_file
7022: PPOPN 3
7024: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7025: LD_INT 0
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
7035: PPUSH
// side := 3 ;
7036: LD_ADDR_VAR 0 6
7040: PUSH
7041: LD_INT 3
7043: ST_TO_ADDR
// uc_side := side ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_VAR 0 6
7053: ST_TO_ADDR
// uc_nation := 3 ;
7054: LD_ADDR_OWVAR 21
7058: PUSH
7059: LD_INT 3
7061: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7062: LD_ADDR_VAR 0 2
7066: PUSH
7067: LD_INT 22
7069: PUSH
7070: LD_VAR 0 6
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PUSH
7079: LD_INT 21
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PPUSH
7093: CALL_OW 69
7097: PUSH
7098: FOR_IN
7099: IFFALSE 7115
// SetBLevel ( i , 10 ) ;
7101: LD_VAR 0 2
7105: PPUSH
7106: LD_INT 10
7108: PPUSH
7109: CALL_OW 241
7113: GO 7098
7115: POP
7116: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7117: LD_ADDR_VAR 0 9
7121: PUSH
7122: LD_INT 22
7124: PUSH
7125: LD_VAR 0 6
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 30
7136: PUSH
7137: LD_INT 34
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: ST_TO_ADDR
// if teleport then
7153: LD_VAR 0 9
7157: IFFALSE 7178
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7159: LD_VAR 0 9
7163: PUSH
7164: LD_INT 1
7166: ARRAY
7167: PPUSH
7168: LD_INT 123
7170: PPUSH
7171: LD_INT 122
7173: PPUSH
7174: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7178: LD_ADDR_EXP 64
7182: PUSH
7183: LD_STRING Platonov
7185: PPUSH
7186: CALL_OW 25
7190: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7191: LD_ADDR_EXP 65
7195: PUSH
7196: LD_STRING Kovalyuk
7198: PPUSH
7199: CALL_OW 25
7203: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7204: LD_ADDR_EXP 67
7208: PUSH
7209: LD_STRING Yakotich
7211: PPUSH
7212: LD_EXP 1
7216: NOT
7217: PPUSH
7218: LD_STRING 09_
7220: PPUSH
7221: CALL 65916 0 3
7225: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7226: LD_ADDR_EXP 66
7230: PUSH
7231: LD_STRING Bystrov
7233: PPUSH
7234: CALL_OW 25
7238: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7239: LD_ADDR_EXP 68
7243: PUSH
7244: LD_STRING Gleb
7246: PPUSH
7247: CALL_OW 25
7251: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7252: LD_STRING 03_Cornel
7254: PPUSH
7255: CALL_OW 28
7259: IFFALSE 7307
// begin Bierezov := NewCharacter ( Mikhail ) ;
7261: LD_ADDR_EXP 69
7265: PUSH
7266: LD_STRING Mikhail
7268: PPUSH
7269: CALL_OW 25
7273: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7274: LD_EXP 69
7278: PPUSH
7279: LD_INT 197
7281: PPUSH
7282: LD_INT 111
7284: PPUSH
7285: LD_INT 9
7287: PPUSH
7288: LD_INT 0
7290: PPUSH
7291: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7295: LD_EXP 69
7299: PPUSH
7300: LD_INT 3
7302: PPUSH
7303: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7307: LD_EXP 64
7311: PPUSH
7312: LD_INT 126
7314: PPUSH
7315: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7319: LD_EXP 65
7323: PPUSH
7324: LD_INT 134
7326: PPUSH
7327: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7331: LD_EXP 67
7335: PPUSH
7336: LD_INT 197
7338: PPUSH
7339: LD_INT 111
7341: PPUSH
7342: LD_INT 9
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7352: LD_EXP 66
7356: PPUSH
7357: LD_INT 197
7359: PPUSH
7360: LD_INT 111
7362: PPUSH
7363: LD_INT 9
7365: PPUSH
7366: LD_INT 0
7368: PPUSH
7369: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7373: LD_EXP 68
7377: PPUSH
7378: LD_INT 197
7380: PPUSH
7381: LD_INT 111
7383: PPUSH
7384: LD_INT 9
7386: PPUSH
7387: LD_INT 0
7389: PPUSH
7390: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7394: LD_ADDR_VAR 0 5
7398: PUSH
7399: LD_INT 126
7401: PPUSH
7402: LD_INT 4
7404: PPUSH
7405: LD_STRING zhukov
7407: PPUSH
7408: LD_INT 9
7410: PUSH
7411: LD_INT 10
7413: PUSH
7414: LD_INT 10
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: LD_INT 90000
7434: PUSH
7435: LD_INT 1000
7437: PUSH
7438: LD_INT 300
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PPUSH
7446: LD_INT 18
7448: PUSH
7449: LD_INT 8
7451: PUSH
7452: LD_INT 13
7454: PUSH
7455: LD_INT 8
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL 74226 0 6
7468: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7469: LD_ADDR_VAR 0 4
7473: PUSH
7474: LD_INT 267
7476: PPUSH
7477: CALL_OW 274
7481: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 5000
7492: PPUSH
7493: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7497: LD_VAR 0 4
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: LD_INT 200
7507: PPUSH
7508: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7512: LD_VAR 0 4
7516: PPUSH
7517: LD_INT 3
7519: PPUSH
7520: LD_INT 200
7522: PPUSH
7523: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7527: LD_ADDR_EXP 117
7531: PUSH
7532: LD_EXP 117
7536: PPUSH
7537: LD_INT 2
7539: PPUSH
7540: LD_VAR 0 5
7544: PUSH
7545: LD_INT 22
7547: PUSH
7548: LD_VAR 0 6
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 3
7559: PUSH
7560: LD_INT 21
7562: PUSH
7563: LD_INT 2
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PPUSH
7578: CALL_OW 69
7582: UNION
7583: PUSH
7584: LD_EXP 64
7588: DIFF
7589: PPUSH
7590: CALL_OW 1
7594: ST_TO_ADDR
// behemoths := [ ] ;
7595: LD_ADDR_EXP 72
7599: PUSH
7600: EMPTY
7601: ST_TO_ADDR
// behemothBuilders := [ ] ;
7602: LD_ADDR_EXP 73
7606: PUSH
7607: EMPTY
7608: ST_TO_ADDR
// if Kovalyuk then
7609: LD_EXP 65
7613: IFFALSE 7635
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7615: LD_ADDR_EXP 73
7619: PUSH
7620: LD_EXP 73
7624: PPUSH
7625: LD_EXP 65
7629: PPUSH
7630: CALL 102597 0 2
7634: ST_TO_ADDR
// j := 3 ;
7635: LD_ADDR_VAR 0 3
7639: PUSH
7640: LD_INT 3
7642: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7643: LD_ADDR_VAR 0 2
7647: PUSH
7648: LD_INT 22
7650: PUSH
7651: LD_INT 3
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 3
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: PUSH
7677: LD_EXP 65
7681: DIFF
7682: PUSH
7683: FOR_IN
7684: IFFALSE 7734
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7686: LD_ADDR_EXP 73
7690: PUSH
7691: LD_EXP 73
7695: PPUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: CALL 102597 0 2
7705: ST_TO_ADDR
// j := j - 1 ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: MINUS
7719: ST_TO_ADDR
// if j = 0 then
7720: LD_VAR 0 3
7724: PUSH
7725: LD_INT 0
7727: EQUAL
7728: IFFALSE 7732
// break ;
7730: GO 7734
// end ;
7732: GO 7683
7734: POP
7735: POP
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7741: LD_INT 0
7743: PPUSH
7744: PPUSH
7745: PPUSH
7746: PPUSH
7747: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7748: LD_ADDR_VAR 0 4
7752: PUSH
7753: LD_INT 209
7755: PUSH
7756: LD_INT 149
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 219
7765: PUSH
7766: LD_INT 154
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: LD_INT 223
7775: PUSH
7776: LD_INT 149
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: LD_INT 232
7785: PUSH
7786: LD_INT 155
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: ST_TO_ADDR
// if not behemothBuilders then
7799: LD_EXP 73
7803: NOT
7804: IFFALSE 7808
// exit ;
7806: GO 7912
// j := 1 ;
7808: LD_ADDR_VAR 0 3
7812: PUSH
7813: LD_INT 1
7815: ST_TO_ADDR
// for i in behemothBuilders do
7816: LD_ADDR_VAR 0 2
7820: PUSH
7821: LD_EXP 73
7825: PUSH
7826: FOR_IN
7827: IFFALSE 7910
// begin if IsInUnit ( i ) then
7829: LD_VAR 0 2
7833: PPUSH
7834: CALL_OW 310
7838: IFFALSE 7849
// ComExitBuilding ( i ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7849: LD_VAR 0 2
7853: PPUSH
7854: LD_INT 37
7856: PPUSH
7857: LD_VAR 0 4
7861: PUSH
7862: LD_VAR 0 3
7866: ARRAY
7867: PUSH
7868: LD_INT 1
7870: ARRAY
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_VAR 0 3
7881: ARRAY
7882: PUSH
7883: LD_INT 2
7885: ARRAY
7886: PPUSH
7887: LD_INT 0
7889: PPUSH
7890: CALL_OW 230
// j := j + 1 ;
7894: LD_ADDR_VAR 0 3
7898: PUSH
7899: LD_VAR 0 3
7903: PUSH
7904: LD_INT 1
7906: PLUS
7907: ST_TO_ADDR
// end ;
7908: GO 7826
7910: POP
7911: POP
// end ;
7912: LD_VAR 0 1
7916: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7917: LD_INT 24
7919: PPUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 37
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 70
7934: IFFALSE 7947
7936: GO 7938
7938: DISABLE
// behemothUnderConstruct := true ;
7939: LD_ADDR_EXP 26
7943: PUSH
7944: LD_INT 1
7946: ST_TO_ADDR
7947: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7948: LD_INT 3
7950: PPUSH
7951: CALL 102658 0 1
7955: PUSH
7956: LD_INT 22
7958: PUSH
7959: LD_INT 3
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PUSH
7966: LD_INT 30
7968: PUSH
7969: LD_INT 37
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PPUSH
7980: CALL_OW 69
7984: NOT
7985: AND
7986: IFFALSE 8172
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: PPUSH
8004: CALL 102658 0 1
8008: ST_TO_ADDR
// for i in tmp do
8009: LD_ADDR_VAR 0 1
8013: PUSH
8014: LD_VAR 0 2
8018: PUSH
8019: FOR_IN
8020: IFFALSE 8170
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8022: LD_VAR 0 1
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL_OW 308
8034: PUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: CALL_OW 110
8044: PUSH
8045: LD_INT 2
8047: EQUAL
8048: NOT
8049: AND
8050: IFFALSE 8064
// SetTag ( i , 2 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 2
8059: PPUSH
8060: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8064: LD_INT 81
8066: PUSH
8067: LD_INT 3
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 91
8076: PUSH
8077: LD_VAR 0 1
8081: PUSH
8082: LD_INT 12
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: LIST
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PPUSH
8094: CALL_OW 69
8098: NOT
8099: PUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 110
8109: PUSH
8110: LD_INT 2
8112: EQUAL
8113: NOT
8114: AND
8115: IFFALSE 8134
// ComAgressiveMove ( i , 64 , 93 ) else
8117: LD_VAR 0 1
8121: PPUSH
8122: LD_INT 64
8124: PPUSH
8125: LD_INT 93
8127: PPUSH
8128: CALL_OW 114
8132: GO 8168
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8134: LD_VAR 0 1
8138: PPUSH
8139: LD_INT 81
8141: PUSH
8142: LD_INT 3
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 69
8153: PPUSH
8154: LD_VAR 0 1
8158: PPUSH
8159: CALL_OW 74
8163: PPUSH
8164: CALL_OW 115
// end ;
8168: GO 8019
8170: POP
8171: POP
// end ;
8172: PPOPN 2
8174: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8175: LD_INT 0
8177: PPUSH
8178: PPUSH
8179: PPUSH
// result := [ ] ;
8180: LD_ADDR_VAR 0 2
8184: PUSH
8185: EMPTY
8186: ST_TO_ADDR
// uc_side := 6 ;
8187: LD_ADDR_OWVAR 20
8191: PUSH
8192: LD_INT 6
8194: ST_TO_ADDR
// uc_nation := 3 ;
8195: LD_ADDR_OWVAR 21
8199: PUSH
8200: LD_INT 3
8202: ST_TO_ADDR
// case strength of 1 :
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: DOUBLE
8211: EQUAL
8212: IFTRUE 8216
8214: GO 8358
8216: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8217: LD_ADDR_VAR 0 3
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_INT 4
8229: PUSH
8230: LD_INT 5
8232: PUSH
8233: LD_INT 6
8235: PUSH
8236: LD_INT 7
8238: PUSH
8239: EMPTY
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: PUSH
8245: LD_OWVAR 67
8249: ARRAY
8250: PUSH
8251: FOR_TO
8252: IFFALSE 8354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8254: LD_INT 22
8256: PUSH
8257: LD_INT 24
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: LD_VAR 0 3
8268: PUSH
8269: LD_INT 2
8271: MOD
8272: PUSH
8273: LD_INT 1
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: LD_INT 1
8280: PUSH
8281: LD_INT 3
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: LD_INT 2
8293: PPUSH
8294: CALL_OW 12
8298: ARRAY
8299: PPUSH
8300: LD_INT 3
8302: PPUSH
8303: LD_INT 43
8305: PUSH
8306: LD_INT 44
8308: PUSH
8309: LD_INT 45
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_INT 3
8322: PPUSH
8323: CALL_OW 12
8327: ARRAY
8328: PPUSH
8329: LD_INT 80
8331: PPUSH
8332: CALL 70780 0 5
// result := result union CreateVehicle ;
8336: LD_ADDR_VAR 0 2
8340: PUSH
8341: LD_VAR 0 2
8345: PUSH
8346: CALL_OW 45
8350: UNION
8351: ST_TO_ADDR
// end ;
8352: GO 8251
8354: POP
8355: POP
// end ; 2 :
8356: GO 9321
8358: LD_INT 2
8360: DOUBLE
8361: EQUAL
8362: IFTRUE 8366
8364: GO 8526
8366: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: DOUBLE
8373: LD_INT 1
8375: DEC
8376: ST_TO_ADDR
8377: LD_INT 5
8379: PUSH
8380: LD_INT 6
8382: PUSH
8383: LD_INT 7
8385: PUSH
8386: LD_INT 8
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: LD_OWVAR 67
8399: ARRAY
8400: PUSH
8401: FOR_TO
8402: IFFALSE 8522
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8404: LD_INT 22
8406: PUSH
8407: LD_INT 24
8409: PUSH
8410: LD_INT 24
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: LIST
8417: PUSH
8418: LD_VAR 0 3
8422: PUSH
8423: LD_INT 3
8425: MOD
8426: PUSH
8427: LD_INT 1
8429: PLUS
8430: ARRAY
8431: PPUSH
8432: LD_INT 1
8434: PUSH
8435: LD_INT 3
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: LD_INT 1
8444: PPUSH
8445: LD_INT 2
8447: PPUSH
8448: CALL_OW 12
8452: ARRAY
8453: PPUSH
8454: LD_INT 3
8456: PPUSH
8457: LD_INT 43
8459: PUSH
8460: LD_INT 44
8462: PUSH
8463: LD_INT 45
8465: PUSH
8466: LD_INT 44
8468: PUSH
8469: LD_INT 46
8471: PUSH
8472: LD_INT 46
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PUSH
8483: LD_VAR 0 3
8487: PUSH
8488: LD_INT 6
8490: MOD
8491: PUSH
8492: LD_INT 1
8494: PLUS
8495: ARRAY
8496: PPUSH
8497: LD_INT 80
8499: PPUSH
8500: CALL 70780 0 5
// result := result union CreateVehicle ;
8504: LD_ADDR_VAR 0 2
8508: PUSH
8509: LD_VAR 0 2
8513: PUSH
8514: CALL_OW 45
8518: UNION
8519: ST_TO_ADDR
// end ;
8520: GO 8401
8522: POP
8523: POP
// end ; 3 :
8524: GO 9321
8526: LD_INT 3
8528: DOUBLE
8529: EQUAL
8530: IFTRUE 8534
8532: GO 8694
8534: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 5
8547: PUSH
8548: LD_INT 7
8550: PUSH
8551: LD_INT 8
8553: PUSH
8554: LD_INT 9
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: PUSH
8563: LD_OWVAR 67
8567: ARRAY
8568: PUSH
8569: FOR_TO
8570: IFFALSE 8690
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8572: LD_INT 22
8574: PUSH
8575: LD_INT 24
8577: PUSH
8578: LD_INT 24
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 3
8593: MOD
8594: PUSH
8595: LD_INT 1
8597: PLUS
8598: ARRAY
8599: PPUSH
8600: LD_INT 1
8602: PUSH
8603: LD_INT 3
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 2
8615: PPUSH
8616: CALL_OW 12
8620: ARRAY
8621: PPUSH
8622: LD_INT 3
8624: PPUSH
8625: LD_INT 43
8627: PUSH
8628: LD_INT 47
8630: PUSH
8631: LD_INT 45
8633: PUSH
8634: LD_INT 45
8636: PUSH
8637: LD_INT 46
8639: PUSH
8640: LD_INT 46
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: PUSH
8651: LD_VAR 0 3
8655: PUSH
8656: LD_INT 6
8658: MOD
8659: PUSH
8660: LD_INT 1
8662: PLUS
8663: ARRAY
8664: PPUSH
8665: LD_INT 80
8667: PPUSH
8668: CALL 70780 0 5
// result := result union CreateVehicle ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_VAR 0 2
8681: PUSH
8682: CALL_OW 45
8686: UNION
8687: ST_TO_ADDR
// end ;
8688: GO 8569
8690: POP
8691: POP
// end ; 4 :
8692: GO 9321
8694: LD_INT 4
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 9320
8702: POP
// begin uc_nation := 3 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 3
8710: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8711: LD_ADDR_VAR 0 3
8715: PUSH
8716: DOUBLE
8717: LD_INT 1
8719: DEC
8720: ST_TO_ADDR
8721: LD_INT 6
8723: PUSH
8724: LD_INT 8
8726: PUSH
8727: LD_INT 9
8729: PUSH
8730: LD_INT 10
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: LD_OWVAR 67
8743: ARRAY
8744: PUSH
8745: FOR_TO
8746: IFFALSE 8866
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8748: LD_INT 22
8750: PUSH
8751: LD_INT 24
8753: PUSH
8754: LD_INT 24
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: LIST
8761: PUSH
8762: LD_VAR 0 3
8766: PUSH
8767: LD_INT 3
8769: MOD
8770: PUSH
8771: LD_INT 1
8773: PLUS
8774: ARRAY
8775: PPUSH
8776: LD_INT 1
8778: PUSH
8779: LD_INT 3
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: PUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 2
8791: PPUSH
8792: CALL_OW 12
8796: ARRAY
8797: PPUSH
8798: LD_INT 3
8800: PPUSH
8801: LD_INT 45
8803: PUSH
8804: LD_INT 47
8806: PUSH
8807: LD_INT 47
8809: PUSH
8810: LD_INT 45
8812: PUSH
8813: LD_INT 46
8815: PUSH
8816: LD_INT 46
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_VAR 0 3
8831: PUSH
8832: LD_INT 6
8834: MOD
8835: PUSH
8836: LD_INT 1
8838: PLUS
8839: ARRAY
8840: PPUSH
8841: LD_INT 80
8843: PPUSH
8844: CALL 70780 0 5
// result := result union CreateVehicle ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_VAR 0 2
8857: PUSH
8858: CALL_OW 45
8862: UNION
8863: ST_TO_ADDR
// end ;
8864: GO 8745
8866: POP
8867: POP
// if not KappaStatus then
8868: LD_EXP 2
8872: NOT
8873: IFFALSE 9108
// begin uc_nation := 1 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// for i = 1 to 3 do
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_INT 3
8895: PUSH
8896: FOR_TO
8897: IFFALSE 9033
// begin j := rand ( 0 , 1 ) ;
8899: LD_ADDR_VAR 0 4
8903: PUSH
8904: LD_INT 0
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 12
8914: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8915: LD_INT 3
8917: PUSH
8918: LD_INT 5
8920: PUSH
8921: LD_INT 5
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: CALL_OW 12
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_INT 9
8978: PUSH
8979: LD_INT 7
8981: PUSH
8982: LD_INT 6
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PUSH
8990: LD_VAR 0 4
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: PLUS
9006: ARRAY
9007: PPUSH
9008: LD_INT 85
9010: PPUSH
9011: CALL 70780 0 5
// result := result union CreateVehicle ;
9015: LD_ADDR_VAR 0 2
9019: PUSH
9020: LD_VAR 0 2
9024: PUSH
9025: CALL_OW 45
9029: UNION
9030: ST_TO_ADDR
// end ;
9031: GO 8896
9033: POP
9034: POP
// if vsevolodFirstAttack then
9035: LD_EXP 24
9039: IFFALSE 9106
// begin vsevolodFirstAttack := false ;
9041: LD_ADDR_EXP 24
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9049: LD_INT 5
9051: PPUSH
9052: LD_INT 3
9054: PPUSH
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 6
9060: PPUSH
9061: LD_INT 100
9063: PPUSH
9064: CALL 70780 0 5
// sewiVeh := CreateVehicle ;
9068: LD_ADDR_EXP 71
9072: PUSH
9073: CALL_OW 45
9077: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9078: LD_EXP 71
9082: PPUSH
9083: LD_INT 1
9085: PPUSH
9086: CALL_OW 242
// result := result union sewiVeh ;
9090: LD_ADDR_VAR 0 2
9094: PUSH
9095: LD_VAR 0 2
9099: PUSH
9100: LD_EXP 71
9104: UNION
9105: ST_TO_ADDR
// end ; end else
9106: GO 9318
// if vsevolodFirstAttack then
9108: LD_EXP 24
9112: IFFALSE 9318
// begin vsevolodFirstAttack := false ;
9114: LD_ADDR_EXP 24
9118: PUSH
9119: LD_INT 0
9121: ST_TO_ADDR
// uc_nation := 3 ;
9122: LD_ADDR_OWVAR 21
9126: PUSH
9127: LD_INT 3
9129: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9130: LD_ADDR_VAR 0 3
9134: PUSH
9135: DOUBLE
9136: LD_INT 1
9138: DEC
9139: ST_TO_ADDR
9140: LD_INT 2
9142: PUSH
9143: LD_OWVAR 67
9147: PLUS
9148: PUSH
9149: FOR_TO
9150: IFFALSE 9258
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9152: LD_INT 22
9154: PUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 24
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: PUSH
9166: LD_VAR 0 3
9170: PUSH
9171: LD_INT 3
9173: MOD
9174: PUSH
9175: LD_INT 1
9177: PLUS
9178: ARRAY
9179: PPUSH
9180: LD_INT 1
9182: PUSH
9183: LD_INT 3
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: LD_INT 1
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 12
9200: ARRAY
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 45
9207: PUSH
9208: LD_INT 47
9210: PUSH
9211: LD_INT 47
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: LIST
9218: PUSH
9219: LD_VAR 0 3
9223: PUSH
9224: LD_INT 3
9226: MOD
9227: PUSH
9228: LD_INT 1
9230: PLUS
9231: ARRAY
9232: PPUSH
9233: LD_INT 80
9235: PPUSH
9236: CALL 70780 0 5
// result := result union CreateVehicle ;
9240: LD_ADDR_VAR 0 2
9244: PUSH
9245: LD_VAR 0 2
9249: PUSH
9250: CALL_OW 45
9254: UNION
9255: ST_TO_ADDR
// end ;
9256: GO 9149
9258: POP
9259: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9260: LD_INT 24
9262: PPUSH
9263: LD_INT 3
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: LD_INT 47
9271: PPUSH
9272: LD_INT 100
9274: PPUSH
9275: CALL 70780 0 5
// sewiVeh := CreateVehicle ;
9279: LD_ADDR_EXP 71
9283: PUSH
9284: CALL_OW 45
9288: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9289: LD_EXP 71
9293: PPUSH
9294: LD_INT 6
9296: NEG
9297: PPUSH
9298: CALL_OW 242
// result := result union sewiVeh ;
9302: LD_ADDR_VAR 0 2
9306: PUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_EXP 71
9316: UNION
9317: ST_TO_ADDR
// end ; end ; end ;
9318: GO 9321
9320: POP
// end ;
9321: LD_VAR 0 2
9325: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9326: LD_EXP 16
9330: IFFALSE 10175
9332: GO 9334
9334: DISABLE
9335: LD_INT 0
9337: PPUSH
9338: PPUSH
9339: PPUSH
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9343: LD_ADDR_VAR 0 4
9347: PUSH
9348: LD_INT 11
9350: PUSH
9351: LD_INT 12
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_INT 11550
9365: PUSH
9366: LD_INT 10150
9368: PUSH
9369: LD_INT 9800
9371: PUSH
9372: LD_INT 9450
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: PUSH
9381: LD_OWVAR 67
9385: ARRAY
9386: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9387: LD_ADDR_VAR 0 6
9391: PUSH
9392: LD_INT 70
9394: PUSH
9395: LD_INT 118
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 78
9404: PUSH
9405: LD_INT 31
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// repeat if missionStage = 2 then
9416: LD_EXP 15
9420: PUSH
9421: LD_INT 2
9423: EQUAL
9424: IFFALSE 9435
// wait ( 1 1$30 ) else
9426: LD_INT 3150
9428: PPUSH
9429: CALL_OW 67
9433: GO 9444
// wait ( time ) ;
9435: LD_VAR 0 3
9439: PPUSH
9440: CALL_OW 67
// if missionStage = 6 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 6
9451: EQUAL
9452: IFFALSE 9480
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9454: LD_INT 51
9456: PPUSH
9457: LD_INT 6
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9467: LD_INT 57
9469: PPUSH
9470: LD_INT 6
9472: PPUSH
9473: LD_INT 2
9475: PPUSH
9476: CALL_OW 322
// end ; if missionStage = 8 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 8
9487: EQUAL
9488: IFFALSE 9516
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9490: LD_INT 52
9492: PPUSH
9493: LD_INT 6
9495: PPUSH
9496: LD_INT 2
9498: PPUSH
9499: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9503: LD_INT 58
9505: PPUSH
9506: LD_INT 6
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9516: LD_EXP 15
9520: PUSH
9521: LD_INT 10
9523: EQUAL
9524: PUSH
9525: LD_OWVAR 67
9529: PUSH
9530: LD_INT 1
9532: GREATER
9533: AND
9534: IFFALSE 9562
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9536: LD_INT 53
9538: PPUSH
9539: LD_INT 6
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9549: LD_INT 59
9551: PPUSH
9552: LD_INT 6
9554: PPUSH
9555: LD_INT 2
9557: PPUSH
9558: CALL_OW 322
// end ; if activeAttacks then
9562: LD_EXP 16
9566: IFFALSE 10169
// begin if missionStage = 2 then
9568: LD_EXP 15
9572: PUSH
9573: LD_INT 2
9575: EQUAL
9576: IFFALSE 9586
// strength := 1 ;
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_INT 1
9585: ST_TO_ADDR
// if missionStage > 2 then
9586: LD_EXP 15
9590: PUSH
9591: LD_INT 2
9593: GREATER
9594: IFFALSE 9604
// strength := 2 ;
9596: LD_ADDR_VAR 0 5
9600: PUSH
9601: LD_INT 2
9603: ST_TO_ADDR
// if missionStage > 6 then
9604: LD_EXP 15
9608: PUSH
9609: LD_INT 6
9611: GREATER
9612: IFFALSE 9622
// strength := 3 ;
9614: LD_ADDR_VAR 0 5
9618: PUSH
9619: LD_INT 3
9621: ST_TO_ADDR
// if missionStage > 10 then
9622: LD_EXP 15
9626: PUSH
9627: LD_INT 10
9629: GREATER
9630: IFFALSE 9640
// strength := 4 ;
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: LD_INT 4
9639: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9640: LD_ADDR_VAR 0 2
9644: PUSH
9645: LD_VAR 0 5
9649: PPUSH
9650: CALL 8175 0 1
9654: ST_TO_ADDR
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9849
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9668: LD_VAR 0 1
9672: PPUSH
9673: LD_VAR 0 4
9677: PUSH
9678: LD_INT 1
9680: PPUSH
9681: LD_INT 2
9683: PPUSH
9684: CALL_OW 12
9688: ARRAY
9689: PPUSH
9690: LD_INT 0
9692: PPUSH
9693: CALL_OW 49
// if i = sewiVeh then
9697: LD_VAR 0 1
9701: PUSH
9702: LD_EXP 71
9706: EQUAL
9707: IFFALSE 9744
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9709: LD_ADDR_EXP 70
9713: PUSH
9714: LD_STRING Vsevolod
9716: PPUSH
9717: LD_INT 0
9719: PPUSH
9720: LD_STRING 
9722: PPUSH
9723: CALL 65916 0 3
9727: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9728: LD_EXP 70
9732: PPUSH
9733: LD_VAR 0 1
9737: PPUSH
9738: CALL_OW 52
// end else
9742: GO 9825
// if GetControl ( i ) = control_manual then
9744: LD_VAR 0 1
9748: PPUSH
9749: CALL_OW 263
9753: PUSH
9754: LD_INT 1
9756: EQUAL
9757: IFFALSE 9825
// begin uc_side := 6 ;
9759: LD_ADDR_OWVAR 20
9763: PUSH
9764: LD_INT 6
9766: ST_TO_ADDR
// uc_nation := 3 ;
9767: LD_ADDR_OWVAR 21
9771: PUSH
9772: LD_INT 3
9774: ST_TO_ADDR
// hc_gallery :=  ;
9775: LD_ADDR_OWVAR 33
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// hc_name :=  ;
9783: LD_ADDR_OWVAR 26
9787: PUSH
9788: LD_STRING 
9790: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9791: LD_INT 0
9793: PPUSH
9794: LD_INT 3
9796: PPUSH
9797: LD_INT 10
9799: PPUSH
9800: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9804: CALL_OW 44
9808: PPUSH
9809: LD_VAR 0 1
9813: PPUSH
9814: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9818: LD_INT 10
9820: PPUSH
9821: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_INT 111
9832: PPUSH
9833: LD_INT 197
9835: PPUSH
9836: CALL_OW 111
// wait ( 0 0$2 ) ;
9840: LD_INT 70
9842: PPUSH
9843: CALL_OW 67
// end ;
9847: GO 9665
9849: POP
9850: POP
// repeat wait ( 0 0$1 ) ;
9851: LD_INT 35
9853: PPUSH
9854: CALL_OW 67
// for i in tmp do
9858: LD_ADDR_VAR 0 1
9862: PUSH
9863: LD_VAR 0 2
9867: PUSH
9868: FOR_IN
9869: IFFALSE 10150
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9871: LD_INT 81
9873: PUSH
9874: LD_INT 6
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: LD_INT 91
9883: PUSH
9884: LD_VAR 0 1
9888: PUSH
9889: LD_INT 12
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL_OW 69
9905: IFFALSE 9963
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PUSH
9922: LD_INT 91
9924: PUSH
9925: LD_VAR 0 1
9929: PUSH
9930: LD_INT 12
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 69
9946: PPUSH
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL_OW 74
9956: PPUSH
9957: CALL_OW 115
9961: GO 10148
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9963: LD_INT 9
9965: PPUSH
9966: LD_INT 81
9968: PUSH
9969: LD_INT 6
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PPUSH
9976: CALL_OW 70
9980: IFFALSE 10114
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ARRAY
9995: PUSH
9996: LD_INT 1
9998: ARRAY
9999: PPUSH
10000: LD_VAR 0 6
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PUSH
10009: LD_INT 2
10011: ARRAY
10012: PPUSH
10013: CALL_OW 297
10017: PUSH
10018: LD_INT 10
10020: GREATER
10021: PUSH
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_INT 9
10029: PPUSH
10030: CALL_OW 308
10034: NOT
10035: AND
10036: IFFALSE 10075
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10038: LD_VAR 0 1
10042: PPUSH
10043: LD_VAR 0 6
10047: PUSH
10048: LD_INT 1
10050: ARRAY
10051: PUSH
10052: LD_INT 1
10054: ARRAY
10055: PPUSH
10056: LD_VAR 0 6
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PUSH
10065: LD_INT 2
10067: ARRAY
10068: PPUSH
10069: CALL_OW 114
10073: GO 10112
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10075: LD_VAR 0 1
10079: PPUSH
10080: LD_INT 9
10082: PPUSH
10083: LD_INT 81
10085: PUSH
10086: LD_INT 6
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PPUSH
10093: CALL_OW 70
10097: PPUSH
10098: LD_VAR 0 1
10102: PPUSH
10103: CALL_OW 74
10107: PPUSH
10108: CALL_OW 115
// end else
10112: GO 10148
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: LD_INT 81
10121: PUSH
10122: LD_INT 6
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PPUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: CALL_OW 74
10143: PPUSH
10144: CALL_OW 115
// end ;
10148: GO 9868
10150: POP
10151: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10152: LD_INT 22
10154: PUSH
10155: LD_INT 6
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: NOT
10167: IFFALSE 9851
// end ; until russianDestroyed ;
10169: LD_EXP 21
10173: IFFALSE 9416
// end ;
10175: PPOPN 6
10177: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10178: LD_EXP 21
10182: NOT
10183: PUSH
10184: LD_EXP 15
10188: PUSH
10189: LD_INT 6
10191: GREATEREQUAL
10192: AND
10193: PUSH
10194: LD_INT 2
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: CALL 60928 0 2
10204: NOT
10205: AND
10206: IFFALSE 11166
10208: GO 10210
10210: DISABLE
10211: LD_INT 0
10213: PPUSH
10214: PPUSH
10215: PPUSH
10216: PPUSH
// begin enable ;
10217: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10218: LD_INT 22
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 30
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: NOT
10247: IFFALSE 10251
// exit ;
10249: GO 11166
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10251: LD_ADDR_VAR 0 4
10255: PUSH
10256: LD_INT 22
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: LD_INT 30
10268: PUSH
10269: LD_INT 34
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PPUSH
10280: CALL_OW 69
10284: ST_TO_ADDR
// if Prob ( 40 ) then
10285: LD_INT 40
10287: PPUSH
10288: CALL_OW 13
10292: IFFALSE 10419
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10294: LD_INT 2
10296: PPUSH
10297: LD_INT 22
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 49
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 22
10317: PUSH
10318: LD_INT 3
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 49
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_INT 3
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 49
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 24
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 46
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PUSH
10369: LD_INT 24
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 46
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 24
10389: PUSH
10390: LD_INT 3
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 46
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL 59510 0 2
// end else
10417: GO 10542
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10419: LD_INT 2
10421: PPUSH
10422: LD_INT 24
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 3
10430: PUSH
10431: LD_INT 47
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 24
10442: PUSH
10443: LD_INT 3
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 47
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: PUSH
10458: LD_INT 24
10460: PUSH
10461: LD_INT 3
10463: PUSH
10464: LD_INT 3
10466: PUSH
10467: LD_INT 47
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: PUSH
10476: LD_INT 24
10478: PUSH
10479: LD_INT 3
10481: PUSH
10482: LD_INT 3
10484: PUSH
10485: LD_INT 46
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 24
10496: PUSH
10497: LD_INT 3
10499: PUSH
10500: LD_INT 3
10502: PUSH
10503: LD_INT 46
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 24
10514: PUSH
10515: LD_INT 3
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: LD_INT 46
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL 59510 0 2
// end ; if Difficulty > 1 then
10542: LD_OWVAR 67
10546: PUSH
10547: LD_INT 1
10549: GREATER
10550: IFFALSE 10580
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10552: LD_INT 2
10554: PPUSH
10555: LD_INT 24
10557: PUSH
10558: LD_INT 3
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: LD_INT 47
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: PPUSH
10576: CALL 59510 0 2
// repeat wait ( 0 0$1 ) ;
10580: LD_INT 35
10582: PPUSH
10583: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10587: LD_INT 2
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL 60928 0 2
10597: PUSH
10598: LD_INT 6
10600: PUSH
10601: LD_INT 7
10603: PUSH
10604: LD_INT 7
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_OWVAR 67
10620: ARRAY
10621: GREATEREQUAL
10622: IFFALSE 10580
// wait ( 0 0$30 ) ;
10624: LD_INT 1050
10626: PPUSH
10627: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: LD_INT 2
10638: PPUSH
10639: LD_INT 1
10641: PPUSH
10642: CALL 60928 0 2
10646: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10647: LD_ADDR_EXP 136
10651: PUSH
10652: LD_EXP 136
10656: PPUSH
10657: LD_INT 2
10659: PPUSH
10660: LD_EXP 136
10664: PUSH
10665: LD_INT 2
10667: ARRAY
10668: PUSH
10669: LD_VAR 0 2
10673: DIFF
10674: PPUSH
10675: CALL_OW 1
10679: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: LD_INT 0
10687: PPUSH
10688: LD_INT 1
10690: PPUSH
10691: CALL_OW 12
10695: ST_TO_ADDR
// if target then
10696: LD_VAR 0 3
10700: IFFALSE 10828
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10702: LD_ADDR_VAR 0 2
10706: PUSH
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_INT 24
10714: PUSH
10715: LD_INT 250
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PPUSH
10722: CALL_OW 72
10726: ST_TO_ADDR
// for i in tmp do
10727: LD_ADDR_VAR 0 1
10731: PUSH
10732: LD_VAR 0 2
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10778
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_INT 139
10747: PPUSH
10748: LD_INT 89
10750: PPUSH
10751: CALL_OW 297
10755: PUSH
10756: LD_INT 9
10758: GREATER
10759: IFFALSE 10776
// ComMoveXY ( i , 139 , 89 ) ;
10761: LD_VAR 0 1
10765: PPUSH
10766: LD_INT 139
10768: PPUSH
10769: LD_INT 89
10771: PPUSH
10772: CALL_OW 111
10776: GO 10737
10778: POP
10779: POP
// wait ( 0 0$1 ) ;
10780: LD_INT 35
10782: PPUSH
10783: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10787: LD_VAR 0 2
10791: PPUSH
10792: LD_INT 92
10794: PUSH
10795: LD_INT 139
10797: PUSH
10798: LD_INT 89
10800: PUSH
10801: LD_INT 9
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PPUSH
10810: CALL_OW 72
10814: PUSH
10815: LD_VAR 0 2
10819: PUSH
10820: LD_INT 1
10822: MINUS
10823: GREATEREQUAL
10824: IFFALSE 10702
// end else
10826: GO 10970
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_VAR 0 4
10837: PUSH
10838: LD_INT 1
10840: ARRAY
10841: PPUSH
10842: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_VAR 0 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 250
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 72
10870: ST_TO_ADDR
// for i in tmp do
10871: LD_ADDR_VAR 0 1
10875: PUSH
10876: LD_VAR 0 2
10880: PUSH
10881: FOR_IN
10882: IFFALSE 10922
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10884: LD_VAR 0 1
10888: PPUSH
10889: LD_INT 124
10891: PPUSH
10892: LD_INT 139
10894: PPUSH
10895: CALL_OW 297
10899: PUSH
10900: LD_INT 9
10902: GREATER
10903: IFFALSE 10920
// ComMoveXY ( i , 124 , 139 ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: LD_INT 124
10912: PPUSH
10913: LD_INT 139
10915: PPUSH
10916: CALL_OW 111
10920: GO 10881
10922: POP
10923: POP
// wait ( 0 0$1 ) ;
10924: LD_INT 35
10926: PPUSH
10927: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10931: LD_VAR 0 2
10935: PPUSH
10936: LD_INT 92
10938: PUSH
10939: LD_INT 124
10941: PUSH
10942: LD_INT 139
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: PPUSH
10954: CALL_OW 72
10958: PUSH
10959: LD_VAR 0 2
10963: PUSH
10964: LD_INT 1
10966: MINUS
10967: GREATEREQUAL
10968: IFFALSE 10846
// end ; repeat wait ( 0 0$1 ) ;
10970: LD_INT 35
10972: PPUSH
10973: CALL_OW 67
// for i in tmp do
10977: LD_ADDR_VAR 0 1
10981: PUSH
10982: LD_VAR 0 2
10986: PUSH
10987: FOR_IN
10988: IFFALSE 11157
// begin if GetLives ( i ) > 251 then
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 256
10999: PUSH
11000: LD_INT 251
11002: GREATER
11003: IFFALSE 11128
// begin if GetWeapon ( i ) = ru_time_lapser then
11005: LD_VAR 0 1
11009: PPUSH
11010: CALL_OW 264
11014: PUSH
11015: LD_INT 49
11017: EQUAL
11018: IFFALSE 11074
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11020: LD_VAR 0 1
11024: PPUSH
11025: LD_INT 2
11027: PUSH
11028: LD_INT 22
11030: PUSH
11031: LD_INT 1
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 8
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: PPUSH
11058: LD_VAR 0 1
11062: PPUSH
11063: CALL_OW 74
11067: PPUSH
11068: CALL_OW 112
11072: GO 11126
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11074: LD_VAR 0 1
11078: PPUSH
11079: LD_INT 2
11081: PUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 1
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 8
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: PPUSH
11107: CALL_OW 69
11111: PPUSH
11112: LD_VAR 0 1
11116: PPUSH
11117: CALL_OW 74
11121: PPUSH
11122: CALL_OW 115
// end else
11126: GO 11155
// if IsDead ( i ) then
11128: LD_VAR 0 1
11132: PPUSH
11133: CALL_OW 301
11137: IFFALSE 11155
// tmp := tmp diff i ;
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_VAR 0 2
11148: PUSH
11149: LD_VAR 0 1
11153: DIFF
11154: ST_TO_ADDR
// end ;
11155: GO 10987
11157: POP
11158: POP
// until not tmp ;
11159: LD_VAR 0 2
11163: NOT
11164: IFFALSE 10970
// end ; end_of_file
11166: PPOPN 4
11168: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11169: LD_INT 0
11171: PPUSH
11172: PPUSH
11173: PPUSH
11174: PPUSH
11175: PPUSH
11176: PPUSH
// side := 7 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 7
11184: ST_TO_ADDR
// uc_side := side ;
11185: LD_ADDR_OWVAR 20
11189: PUSH
11190: LD_VAR 0 5
11194: ST_TO_ADDR
// uc_nation := 1 ;
11195: LD_ADDR_OWVAR 21
11199: PUSH
11200: LD_INT 1
11202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11203: LD_ADDR_VAR 0 2
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_VAR 0 5
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 21
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PPUSH
11234: CALL_OW 69
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11256
// SetBLevel ( i , 10 ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: LD_INT 10
11249: PPUSH
11250: CALL_OW 241
11254: GO 11239
11256: POP
11257: POP
// base := GetBase ( al_depot ) ;
11258: LD_ADDR_VAR 0 4
11262: PUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 274
11270: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11271: LD_ADDR_VAR 0 6
11275: PUSH
11276: LD_INT 22
11278: PUSH
11279: LD_VAR 0 5
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 30
11290: PUSH
11291: LD_INT 34
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PPUSH
11302: CALL_OW 69
11306: ST_TO_ADDR
// if teleport then
11307: LD_VAR 0 6
11311: IFFALSE 11332
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11313: LD_VAR 0 6
11317: PUSH
11318: LD_INT 1
11320: ARRAY
11321: PPUSH
11322: LD_INT 262
11324: PPUSH
11325: LD_INT 119
11327: PPUSH
11328: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11332: LD_VAR 0 4
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: LD_INT 19500
11342: PPUSH
11343: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11347: LD_VAR 0 4
11351: PPUSH
11352: LD_INT 2
11354: PPUSH
11355: LD_INT 200
11357: PPUSH
11358: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11362: LD_VAR 0 4
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 650
11372: PPUSH
11373: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11377: LD_ADDR_EXP 74
11381: PUSH
11382: LD_STRING Roth
11384: PPUSH
11385: CALL_OW 25
11389: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11390: LD_ADDR_EXP 75
11394: PUSH
11395: LD_STRING Simms
11397: PPUSH
11398: LD_EXP 1
11402: NOT
11403: PPUSH
11404: LD_STRING 10c_
11406: PPUSH
11407: CALL 65916 0 3
11411: ST_TO_ADDR
// if not Simms then
11412: LD_EXP 75
11416: NOT
11417: IFFALSE 11447
// begin uc_nation := 1 ;
11419: LD_ADDR_OWVAR 21
11423: PUSH
11424: LD_INT 1
11426: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11427: LD_INT 2
11429: PPUSH
11430: LD_INT 10
11432: PPUSH
11433: CALL_OW 384
// Simms := CreateHuman ;
11437: LD_ADDR_EXP 75
11441: PUSH
11442: CALL_OW 44
11446: ST_TO_ADDR
// end ; uc_nation := 3 ;
11447: LD_ADDR_OWVAR 21
11451: PUSH
11452: LD_INT 3
11454: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11455: LD_ADDR_EXP 76
11459: PUSH
11460: LD_STRING Kirilenkova
11462: PPUSH
11463: CALL_OW 25
11467: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11468: LD_ADDR_EXP 90
11472: PUSH
11473: LD_STRING Oblukov
11475: PPUSH
11476: CALL_OW 25
11480: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11481: LD_ADDR_EXP 77
11485: PUSH
11486: LD_STRING Dolgov
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11494: LD_ADDR_EXP 78
11498: PUSH
11499: LD_STRING Petrosyan
11501: PPUSH
11502: CALL_OW 25
11506: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11507: LD_ADDR_EXP 89
11511: PUSH
11512: LD_STRING Scholtze
11514: PPUSH
11515: CALL_OW 25
11519: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11520: LD_ADDR_EXP 88
11524: PUSH
11525: LD_STRING Kapitsova
11527: PPUSH
11528: CALL_OW 25
11532: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11533: LD_ADDR_EXP 79
11537: PUSH
11538: LD_STRING Petrovova
11540: PPUSH
11541: CALL_OW 25
11545: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11546: LD_ADDR_EXP 80
11550: PUSH
11551: LD_STRING Kuzmov
11553: PPUSH
11554: CALL_OW 25
11558: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11559: LD_ADDR_EXP 87
11563: PUSH
11564: LD_STRING Karamazov
11566: PPUSH
11567: CALL_OW 25
11571: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11572: LD_STRING 13_Lipshchin_1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 30
11582: IFFALSE 11597
// Lipshchin := NewCharacter ( Lipshchin ) ;
11584: LD_ADDR_EXP 81
11588: PUSH
11589: LD_STRING Lipshchin
11591: PPUSH
11592: CALL_OW 25
11596: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11597: LD_STRING 13_Titov_1
11599: PPUSH
11600: LD_INT 0
11602: PPUSH
11603: CALL_OW 30
11607: IFFALSE 11622
// Titov := NewCharacter ( Titov ) ;
11609: LD_ADDR_EXP 83
11613: PUSH
11614: LD_STRING Titov
11616: PPUSH
11617: CALL_OW 25
11621: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11622: LD_STRING 13_Gnyevko_1
11624: PPUSH
11625: LD_INT 0
11627: PPUSH
11628: CALL_OW 30
11632: IFFALSE 11647
// Gnyevko := NewCharacter ( Gnyevko ) ;
11634: LD_ADDR_EXP 82
11638: PUSH
11639: LD_STRING Gnyevko
11641: PPUSH
11642: CALL_OW 25
11646: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11647: LD_STRING 13_Xavier_1
11649: PPUSH
11650: LD_INT 0
11652: PPUSH
11653: CALL_OW 30
11657: IFFALSE 11672
// Xavier := NewCharacter ( Xavier2 ) ;
11659: LD_ADDR_EXP 84
11663: PUSH
11664: LD_STRING Xavier2
11666: PPUSH
11667: CALL_OW 25
11671: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11672: LD_STRING 13_Belkov_1
11674: PPUSH
11675: LD_INT 0
11677: PPUSH
11678: CALL_OW 30
11682: IFFALSE 11697
// Belkov := NewCharacter ( Belkov ) ;
11684: LD_ADDR_EXP 85
11688: PUSH
11689: LD_STRING Belkov
11691: PPUSH
11692: CALL_OW 25
11696: ST_TO_ADDR
// if not BurlakStatus then
11697: LD_EXP 9
11701: NOT
11702: IFFALSE 11717
// Burlak = NewCharacter ( Burlak ) ;
11704: LD_ADDR_EXP 86
11708: PUSH
11709: LD_STRING Burlak
11711: PPUSH
11712: CALL_OW 25
11716: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11717: LD_ADDR_VAR 0 3
11721: PUSH
11722: LD_EXP 74
11726: PUSH
11727: LD_EXP 76
11731: PUSH
11732: LD_EXP 90
11736: PUSH
11737: LD_EXP 77
11741: PUSH
11742: LD_EXP 78
11746: PUSH
11747: LD_EXP 89
11751: PUSH
11752: LD_EXP 88
11756: PUSH
11757: LD_EXP 79
11761: PUSH
11762: LD_EXP 80
11766: PUSH
11767: LD_EXP 87
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: ST_TO_ADDR
// if Simms then
11784: LD_EXP 75
11788: IFFALSE 11806
// tmp := tmp ^ Simms ;
11790: LD_ADDR_VAR 0 3
11794: PUSH
11795: LD_VAR 0 3
11799: PUSH
11800: LD_EXP 75
11804: ADD
11805: ST_TO_ADDR
// if Titov then
11806: LD_EXP 83
11810: IFFALSE 11828
// tmp := tmp ^ Titov ;
11812: LD_ADDR_VAR 0 3
11816: PUSH
11817: LD_VAR 0 3
11821: PUSH
11822: LD_EXP 83
11826: ADD
11827: ST_TO_ADDR
// if Lipshchin then
11828: LD_EXP 81
11832: IFFALSE 11850
// tmp := tmp ^ Lipshchin ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_VAR 0 3
11843: PUSH
11844: LD_EXP 81
11848: ADD
11849: ST_TO_ADDR
// if Gnyevko then
11850: LD_EXP 82
11854: IFFALSE 11872
// tmp := tmp ^ Gnyevko ;
11856: LD_ADDR_VAR 0 3
11860: PUSH
11861: LD_VAR 0 3
11865: PUSH
11866: LD_EXP 82
11870: ADD
11871: ST_TO_ADDR
// if Xavier then
11872: LD_EXP 84
11876: IFFALSE 11894
// tmp := tmp ^ Xavier ;
11878: LD_ADDR_VAR 0 3
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: LD_EXP 84
11892: ADD
11893: ST_TO_ADDR
// if Belkov then
11894: LD_EXP 85
11898: IFFALSE 11916
// tmp := tmp ^ Belkov ;
11900: LD_ADDR_VAR 0 3
11904: PUSH
11905: LD_VAR 0 3
11909: PUSH
11910: LD_EXP 85
11914: ADD
11915: ST_TO_ADDR
// if Burlak then
11916: LD_EXP 86
11920: IFFALSE 11938
// tmp := tmp ^ Burlak ;
11922: LD_ADDR_VAR 0 3
11926: PUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_EXP 86
11936: ADD
11937: ST_TO_ADDR
// for i = 1 to 11 do
11938: LD_ADDR_VAR 0 2
11942: PUSH
11943: DOUBLE
11944: LD_INT 1
11946: DEC
11947: ST_TO_ADDR
11948: LD_INT 11
11950: PUSH
11951: FOR_TO
11952: IFFALSE 12018
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11954: LD_ADDR_OWVAR 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: LD_INT 3
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 1
11971: PPUSH
11972: LD_INT 2
11974: PPUSH
11975: CALL_OW 12
11979: ARRAY
11980: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11981: LD_INT 0
11983: PPUSH
11984: LD_VAR 0 2
11988: PUSH
11989: LD_INT 2
11991: DIV
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12000: LD_ADDR_VAR 0 3
12004: PUSH
12005: LD_VAR 0 3
12009: PUSH
12010: CALL_OW 44
12014: ADD
12015: ST_TO_ADDR
// end ;
12016: GO 11951
12018: POP
12019: POP
// for i in tmp do
12020: LD_ADDR_VAR 0 2
12024: PUSH
12025: LD_VAR 0 3
12029: PUSH
12030: FOR_IN
12031: IFFALSE 12056
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12033: LD_VAR 0 2
12037: PPUSH
12038: LD_INT 260
12040: PPUSH
12041: LD_INT 235
12043: PPUSH
12044: LD_INT 8
12046: PPUSH
12047: LD_INT 0
12049: PPUSH
12050: CALL_OW 50
12054: GO 12030
12056: POP
12057: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12058: LD_ADDR_EXP 117
12062: PUSH
12063: LD_EXP 117
12067: PPUSH
12068: LD_INT 1
12070: PPUSH
12071: LD_INT 22
12073: PUSH
12074: LD_VAR 0 5
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 3
12085: PUSH
12086: LD_INT 21
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PPUSH
12104: CALL_OW 69
12108: PUSH
12109: LD_EXP 74
12113: PUSH
12114: LD_EXP 75
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: DIFF
12123: PPUSH
12124: CALL_OW 1
12128: ST_TO_ADDR
// uc_side := 0 ;
12129: LD_ADDR_OWVAR 20
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// uc_nation := 0 ;
12137: LD_ADDR_OWVAR 21
12141: PUSH
12142: LD_INT 0
12144: ST_TO_ADDR
// for i = 1 to 5 do
12145: LD_ADDR_VAR 0 2
12149: PUSH
12150: DOUBLE
12151: LD_INT 1
12153: DEC
12154: ST_TO_ADDR
12155: LD_INT 5
12157: PUSH
12158: FOR_TO
12159: IFFALSE 12196
// begin InitHc ;
12161: CALL_OW 19
// hc_class := class_apeman ;
12165: LD_ADDR_OWVAR 28
12169: PUSH
12170: LD_INT 12
12172: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12173: CALL_OW 44
12177: PPUSH
12178: LD_INT 299
12180: PPUSH
12181: LD_INT 229
12183: PPUSH
12184: LD_INT 10
12186: PPUSH
12187: LD_INT 0
12189: PPUSH
12190: CALL_OW 50
// end ;
12194: GO 12158
12196: POP
12197: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12198: LD_EXP 74
12202: PPUSH
12203: LD_INT 259
12205: PPUSH
12206: LD_INT 235
12208: PPUSH
12209: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12213: LD_EXP 74
12217: PPUSH
12218: LD_INT 262
12220: PPUSH
12221: LD_INT 235
12223: PPUSH
12224: CALL_OW 178
// if Simms then
12228: LD_EXP 75
12232: IFFALSE 12263
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12234: LD_EXP 75
12238: PPUSH
12239: LD_INT 262
12241: PPUSH
12242: LD_INT 235
12244: PPUSH
12245: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12249: LD_EXP 75
12253: PPUSH
12254: LD_EXP 74
12258: PPUSH
12259: CALL_OW 179
// end ; end ;
12263: LD_VAR 0 1
12267: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12268: LD_EXP 31
12272: PUSH
12273: LD_EXP 23
12277: NOT
12278: AND
12279: IFFALSE 12455
12281: GO 12283
12283: DISABLE
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
12288: PPUSH
// begin enable ;
12289: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12290: LD_ADDR_VAR 0 2
12294: PUSH
12295: LD_INT 81
12297: PUSH
12298: LD_INT 7
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 2
12307: PUSH
12308: LD_INT 32
12310: PUSH
12311: LD_INT 3
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 30
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 30
12330: PUSH
12331: LD_INT 28
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 34
12340: PUSH
12341: LD_INT 49
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 34
12350: PUSH
12351: LD_INT 10
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 34
12360: PUSH
12361: LD_INT 8
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: ST_TO_ADDR
// if not tmp then
12386: LD_VAR 0 2
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12455
// target := tmp [ rand ( 1 , tmp ) ] ;
12395: LD_ADDR_VAR 0 3
12399: PUSH
12400: LD_VAR 0 2
12404: PUSH
12405: LD_INT 1
12407: PPUSH
12408: LD_VAR 0 2
12412: PPUSH
12413: CALL_OW 12
12417: ARRAY
12418: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12419: LD_VAR 0 3
12423: PPUSH
12424: CALL_OW 255
12428: PUSH
12429: LD_INT 1
12431: EQUAL
12432: IFFALSE 12443
// CenterNowOnUnits ( target ) ;
12434: LD_VAR 0 3
12438: PPUSH
12439: CALL_OW 87
// SetLives ( target , 0 ) ;
12443: LD_VAR 0 3
12447: PPUSH
12448: LD_INT 0
12450: PPUSH
12451: CALL_OW 234
// end ;
12455: PPOPN 3
12457: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12458: LD_EXP 23
12462: NOT
12463: PUSH
12464: LD_EXP 31
12468: AND
12469: IFFALSE 12995
12471: GO 12473
12473: DISABLE
12474: LD_INT 0
12476: PPUSH
12477: PPUSH
12478: PPUSH
// begin uc_side := 7 ;
12479: LD_ADDR_OWVAR 20
12483: PUSH
12484: LD_INT 7
12486: ST_TO_ADDR
// uc_nation := 1 ;
12487: LD_ADDR_OWVAR 21
12491: PUSH
12492: LD_INT 1
12494: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12495: LD_ADDR_VAR 0 3
12499: PUSH
12500: LD_INT 125
12502: PUSH
12503: LD_INT 163
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: LD_INT 185
12512: PUSH
12513: LD_INT 168
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 111
12522: PUSH
12523: LD_INT 97
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL 102702 0 1
12539: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12540: LD_ADDR_EXP 91
12544: PUSH
12545: EMPTY
12546: ST_TO_ADDR
// for i = 1 to Difficulty do
12547: LD_ADDR_VAR 0 1
12551: PUSH
12552: DOUBLE
12553: LD_INT 1
12555: DEC
12556: ST_TO_ADDR
12557: LD_OWVAR 67
12561: PUSH
12562: FOR_TO
12563: IFFALSE 12721
// begin InitHc ;
12565: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12569: LD_INT 0
12571: PPUSH
12572: LD_INT 8
12574: PPUSH
12575: CALL_OW 381
// un := CreateHuman ;
12579: LD_ADDR_VAR 0 2
12583: PUSH
12584: CALL_OW 44
12588: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12589: LD_VAR 0 2
12593: PPUSH
12594: LD_INT 258
12596: PPUSH
12597: LD_INT 267
12599: PPUSH
12600: LD_INT 4
12602: PPUSH
12603: LD_INT 0
12605: PPUSH
12606: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12610: LD_ADDR_EXP 91
12614: PUSH
12615: LD_EXP 91
12619: PUSH
12620: LD_VAR 0 2
12624: UNION
12625: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PUSH
12636: LD_VAR 0 1
12640: ARRAY
12641: PUSH
12642: LD_INT 1
12644: ARRAY
12645: PPUSH
12646: LD_VAR 0 3
12650: PUSH
12651: LD_VAR 0 1
12655: ARRAY
12656: PUSH
12657: LD_INT 2
12659: ARRAY
12660: PPUSH
12661: LD_INT 4
12663: PPUSH
12664: LD_INT 1
12666: PPUSH
12667: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12671: LD_VAR 0 2
12675: PPUSH
12676: LD_VAR 0 3
12680: PUSH
12681: LD_VAR 0 1
12685: ARRAY
12686: PUSH
12687: LD_INT 1
12689: ARRAY
12690: PPUSH
12691: LD_VAR 0 3
12695: PUSH
12696: LD_VAR 0 1
12700: ARRAY
12701: PUSH
12702: LD_INT 2
12704: ARRAY
12705: PPUSH
12706: CALL_OW 171
// AddComInvisible ( un ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: CALL_OW 212
// end ;
12719: GO 12562
12721: POP
12722: POP
// repeat wait ( 0 0$20 ) ;
12723: LD_INT 700
12725: PPUSH
12726: CALL_OW 67
// for i in allianceSpecialForce do
12730: LD_ADDR_VAR 0 1
12734: PUSH
12735: LD_EXP 91
12739: PUSH
12740: FOR_IN
12741: IFFALSE 12980
// begin if IsInvisible ( i ) then
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 571
12752: IFFALSE 12949
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12754: LD_ADDR_VAR 0 3
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_INT 1
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PUSH
12769: LD_INT 50
12771: PUSH
12772: EMPTY
12773: LIST
12774: PUSH
12775: LD_INT 56
12777: PUSH
12778: EMPTY
12779: LIST
12780: PUSH
12781: LD_INT 91
12783: PUSH
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 25
12791: PUSH
12792: LD_INT 30
12794: PUSH
12795: LD_INT 35
12797: PUSH
12798: LD_INT 40
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: PUSH
12807: LD_OWVAR 67
12811: ARRAY
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 2
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 1
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 25
12833: PUSH
12834: LD_INT 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 25
12843: PUSH
12844: LD_INT 3
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 25
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 25
12863: PUSH
12864: LD_INT 5
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 25
12873: PUSH
12874: LD_INT 8
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PPUSH
12897: CALL_OW 69
12901: ST_TO_ADDR
// if not tmp then
12902: LD_VAR 0 3
12906: NOT
12907: IFFALSE 12911
// continue ;
12909: GO 12740
// if Prob ( 30 * Difficulty ) then
12911: LD_INT 30
12913: PUSH
12914: LD_OWVAR 67
12918: MUL
12919: PPUSH
12920: CALL_OW 13
12924: IFFALSE 12949
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12926: LD_VAR 0 3
12930: PUSH
12931: LD_INT 1
12933: PPUSH
12934: LD_VAR 0 3
12938: PPUSH
12939: CALL_OW 12
12943: ARRAY
12944: PPUSH
12945: CALL 31278 0 1
// end ; if IsDead ( i ) then
12949: LD_VAR 0 1
12953: PPUSH
12954: CALL_OW 301
12958: IFFALSE 12978
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12960: LD_ADDR_EXP 91
12964: PUSH
12965: LD_EXP 91
12969: PUSH
12970: LD_VAR 0 1
12974: DIFF
12975: ST_TO_ADDR
// continue ;
12976: GO 12740
// end ; end ;
12978: GO 12740
12980: POP
12981: POP
// until allianceDestroyed or not allianceSpecialForce ;
12982: LD_EXP 23
12986: PUSH
12987: LD_EXP 91
12991: NOT
12992: OR
12993: IFFALSE 12723
// end ;
12995: PPOPN 3
12997: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12998: LD_EXP 23
13002: NOT
13003: PUSH
13004: LD_EXP 31
13008: AND
13009: IFFALSE 13980
13011: GO 13013
13013: DISABLE
13014: LD_INT 0
13016: PPUSH
13017: PPUSH
13018: PPUSH
13019: PPUSH
// begin enable ;
13020: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13021: LD_INT 22
13023: PUSH
13024: LD_INT 7
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PUSH
13031: LD_INT 30
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 69
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13980
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13054: LD_ADDR_VAR 0 4
13058: PUSH
13059: LD_INT 22
13061: PUSH
13062: LD_INT 7
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 34
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PPUSH
13083: CALL_OW 69
13087: ST_TO_ADDR
// if Prob ( 40 ) then
13088: LD_INT 40
13090: PPUSH
13091: CALL_OW 13
13095: IFFALSE 13222
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13097: LD_INT 1
13099: PPUSH
13100: LD_INT 5
13102: PUSH
13103: LD_INT 3
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: LD_INT 6
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 3
13123: PUSH
13124: LD_INT 2
13126: PUSH
13127: LD_INT 6
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 5
13138: PUSH
13139: LD_INT 3
13141: PUSH
13142: LD_INT 2
13144: PUSH
13145: LD_INT 6
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: PUSH
13154: LD_INT 24
13156: PUSH
13157: LD_INT 3
13159: PUSH
13160: LD_INT 3
13162: PUSH
13163: LD_INT 45
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 24
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: LD_INT 3
13180: PUSH
13181: LD_INT 47
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: LD_INT 24
13192: PUSH
13193: LD_INT 3
13195: PUSH
13196: LD_INT 3
13198: PUSH
13199: LD_INT 45
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: PPUSH
13216: CALL 59510 0 2
// end else
13220: GO 13345
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13222: LD_INT 1
13224: PPUSH
13225: LD_INT 24
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 3
13233: PUSH
13234: LD_INT 47
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 24
13245: PUSH
13246: LD_INT 3
13248: PUSH
13249: LD_INT 3
13251: PUSH
13252: LD_INT 47
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: PUSH
13261: LD_INT 5
13263: PUSH
13264: LD_INT 3
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: LD_INT 3
13284: PUSH
13285: LD_INT 2
13287: PUSH
13288: LD_INT 9
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: LD_INT 1
13302: PUSH
13303: LD_INT 3
13305: PUSH
13306: LD_INT 45
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: LD_INT 24
13317: PUSH
13318: LD_INT 1
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: LD_INT 45
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL 59510 0 2
// end ; if Difficulty > 1 then
13345: LD_OWVAR 67
13349: PUSH
13350: LD_INT 1
13352: GREATER
13353: IFFALSE 13383
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13355: LD_INT 1
13357: PPUSH
13358: LD_INT 24
13360: PUSH
13361: LD_INT 3
13363: PUSH
13364: LD_INT 3
13366: PUSH
13367: LD_INT 47
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: PUSH
13376: EMPTY
13377: LIST
13378: PPUSH
13379: CALL 59510 0 2
// repeat wait ( 0 0$1 ) ;
13383: LD_INT 35
13385: PPUSH
13386: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13390: LD_INT 1
13392: PPUSH
13393: LD_INT 1
13395: PPUSH
13396: CALL 60928 0 2
13400: PUSH
13401: LD_INT 6
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: LD_INT 7
13409: PUSH
13410: LD_INT 7
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: PUSH
13419: LD_OWVAR 67
13423: ARRAY
13424: GREATEREQUAL
13425: IFFALSE 13383
// wait ( 0 0$40 ) ;
13427: LD_INT 1400
13429: PPUSH
13430: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_INT 1
13444: PPUSH
13445: CALL 60928 0 2
13449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13450: LD_ADDR_EXP 136
13454: PUSH
13455: LD_EXP 136
13459: PPUSH
13460: LD_INT 1
13462: PPUSH
13463: LD_EXP 136
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: PUSH
13472: LD_VAR 0 2
13476: DIFF
13477: PPUSH
13478: CALL_OW 1
13482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13483: LD_ADDR_VAR 0 3
13487: PUSH
13488: LD_INT 0
13490: PPUSH
13491: LD_INT 1
13493: PPUSH
13494: CALL_OW 12
13498: ST_TO_ADDR
// if target then
13499: LD_VAR 0 3
13503: IFFALSE 13669
// begin for i in tmp do
13505: LD_ADDR_VAR 0 1
13509: PUSH
13510: LD_VAR 0 2
13514: PUSH
13515: FOR_IN
13516: IFFALSE 13541
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13518: LD_VAR 0 1
13522: PPUSH
13523: LD_INT 179
13525: PPUSH
13526: LD_INT 209
13528: PPUSH
13529: LD_INT 8
13531: PPUSH
13532: LD_INT 1
13534: PPUSH
13535: CALL_OW 483
13539: GO 13515
13541: POP
13542: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13543: LD_ADDR_VAR 0 2
13547: PUSH
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 24
13555: PUSH
13556: LD_INT 250
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PPUSH
13563: CALL_OW 72
13567: ST_TO_ADDR
// for i in tmp do
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13619
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13581: LD_VAR 0 1
13585: PPUSH
13586: LD_INT 179
13588: PPUSH
13589: LD_INT 209
13591: PPUSH
13592: CALL_OW 297
13596: PUSH
13597: LD_INT 9
13599: GREATER
13600: IFFALSE 13617
// ComMoveXY ( i , 179 , 209 ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 179
13609: PPUSH
13610: LD_INT 209
13612: PPUSH
13613: CALL_OW 111
13617: GO 13578
13619: POP
13620: POP
// wait ( 0 0$1 ) ;
13621: LD_INT 35
13623: PPUSH
13624: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: LD_INT 92
13635: PUSH
13636: LD_INT 179
13638: PUSH
13639: LD_INT 209
13641: PUSH
13642: LD_INT 9
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PPUSH
13651: CALL_OW 72
13655: PUSH
13656: LD_VAR 0 2
13660: PUSH
13661: LD_INT 1
13663: MINUS
13664: GREATEREQUAL
13665: IFFALSE 13543
// end else
13667: GO 13831
// begin for i in tmp do
13669: LD_ADDR_VAR 0 1
13673: PUSH
13674: LD_VAR 0 2
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13705
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 285
13689: PPUSH
13690: LD_INT 163
13692: PPUSH
13693: LD_INT 8
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: CALL_OW 483
13703: GO 13679
13705: POP
13706: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 24
13719: PUSH
13720: LD_INT 250
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 72
13731: ST_TO_ADDR
// for i in tmp do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_VAR 0 2
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13783
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13745: LD_VAR 0 1
13749: PPUSH
13750: LD_INT 285
13752: PPUSH
13753: LD_INT 163
13755: PPUSH
13756: CALL_OW 297
13760: PUSH
13761: LD_INT 9
13763: GREATER
13764: IFFALSE 13781
// ComMoveXY ( i , 285 , 163 ) ;
13766: LD_VAR 0 1
13770: PPUSH
13771: LD_INT 285
13773: PPUSH
13774: LD_INT 163
13776: PPUSH
13777: CALL_OW 111
13781: GO 13742
13783: POP
13784: POP
// wait ( 0 0$1 ) ;
13785: LD_INT 35
13787: PPUSH
13788: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13792: LD_VAR 0 2
13796: PPUSH
13797: LD_INT 92
13799: PUSH
13800: LD_INT 285
13802: PUSH
13803: LD_INT 163
13805: PUSH
13806: LD_INT 9
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 72
13819: PUSH
13820: LD_VAR 0 2
13824: PUSH
13825: LD_INT 1
13827: MINUS
13828: GREATEREQUAL
13829: IFFALSE 13707
// end ; repeat wait ( 0 0$1 ) ;
13831: LD_INT 35
13833: PPUSH
13834: CALL_OW 67
// for i in tmp do
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_VAR 0 2
13847: PUSH
13848: FOR_IN
13849: IFFALSE 13971
// if GetLives ( i ) > 251 then
13851: LD_VAR 0 1
13855: PPUSH
13856: CALL_OW 256
13860: PUSH
13861: LD_INT 251
13863: GREATER
13864: IFFALSE 13953
// begin if GetWeapon ( i ) = ru_time_lapser then
13866: LD_VAR 0 1
13870: PPUSH
13871: CALL_OW 264
13875: PUSH
13876: LD_INT 49
13878: EQUAL
13879: IFFALSE 13917
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13881: LD_VAR 0 1
13885: PPUSH
13886: LD_INT 81
13888: PUSH
13889: LD_INT 7
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PPUSH
13896: CALL_OW 69
13900: PPUSH
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 74
13910: PPUSH
13911: CALL_OW 112
13915: GO 13951
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13917: LD_VAR 0 1
13921: PPUSH
13922: LD_INT 81
13924: PUSH
13925: LD_INT 7
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PPUSH
13932: CALL_OW 69
13936: PPUSH
13937: LD_VAR 0 1
13941: PPUSH
13942: CALL_OW 74
13946: PPUSH
13947: CALL_OW 115
// end else
13951: GO 13969
// tmp := tmp diff i ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_VAR 0 2
13962: PUSH
13963: LD_VAR 0 1
13967: DIFF
13968: ST_TO_ADDR
13969: GO 13848
13971: POP
13972: POP
// until not tmp ;
13973: LD_VAR 0 2
13977: NOT
13978: IFFALSE 13831
// end ; end_of_file
13980: PPOPN 4
13982: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13983: LD_INT 0
13985: PPUSH
13986: PPUSH
13987: PPUSH
13988: PPUSH
// missionStage := 13 ;
13989: LD_ADDR_EXP 15
13993: PUSH
13994: LD_INT 13
13996: ST_TO_ADDR
// uc_side := 2 ;
13997: LD_ADDR_OWVAR 20
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// uc_nation := 2 ;
14005: LD_ADDR_OWVAR 21
14009: PUSH
14010: LD_INT 2
14012: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14013: LD_ADDR_EXP 92
14017: PUSH
14018: LD_STRING Omar
14020: PPUSH
14021: CALL_OW 25
14025: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14026: LD_EXP 92
14030: PPUSH
14031: LD_INT 4
14033: PPUSH
14034: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14038: LD_EXP 92
14042: PPUSH
14043: LD_INT 242
14045: PPUSH
14046: LD_INT 75
14048: PPUSH
14049: LD_INT 0
14051: PPUSH
14052: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14056: LD_ADDR_EXP 93
14060: PUSH
14061: LD_STRING Heike
14063: PPUSH
14064: CALL_OW 25
14068: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14069: LD_INT 14
14071: PPUSH
14072: LD_INT 3
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 27
14080: PPUSH
14081: LD_INT 100
14083: PPUSH
14084: CALL 70780 0 5
// veh := CreateVehicle ;
14088: LD_ADDR_VAR 0 3
14092: PUSH
14093: CALL_OW 45
14097: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14098: LD_VAR 0 3
14102: PPUSH
14103: LD_INT 1
14105: PPUSH
14106: CALL_OW 242
// SetDir ( veh , 4 ) ;
14110: LD_VAR 0 3
14114: PPUSH
14115: LD_INT 4
14117: PPUSH
14118: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14122: LD_VAR 0 3
14126: PPUSH
14127: LD_INT 241
14129: PPUSH
14130: LD_INT 72
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14140: LD_EXP 93
14144: PPUSH
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 52
// if KhatamStatus then
14154: LD_EXP 8
14158: IFFALSE 14209
// begin Khatam := NewCharacter ( Khatam ) ;
14160: LD_ADDR_EXP 94
14164: PUSH
14165: LD_STRING Khatam
14167: PPUSH
14168: CALL_OW 25
14172: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14173: LD_EXP 94
14177: PPUSH
14178: LD_INT 245
14180: PPUSH
14181: LD_INT 78
14183: PPUSH
14184: LD_INT 3
14186: PPUSH
14187: LD_INT 0
14189: PPUSH
14190: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14194: LD_EXP 94
14198: PPUSH
14199: LD_INT 4
14201: PPUSH
14202: LD_INT 10
14204: PPUSH
14205: CALL_OW 237
// end ; for i = 1 to Difficulty do
14209: LD_ADDR_VAR 0 2
14213: PUSH
14214: DOUBLE
14215: LD_INT 1
14217: DEC
14218: ST_TO_ADDR
14219: LD_OWVAR 67
14223: PUSH
14224: FOR_TO
14225: IFFALSE 14291
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14227: LD_INT 0
14229: PPUSH
14230: LD_INT 7
14232: PUSH
14233: LD_OWVAR 67
14237: PLUS
14238: PPUSH
14239: CALL_OW 384
// un := CreateHuman ;
14243: LD_ADDR_VAR 0 4
14247: PUSH
14248: CALL_OW 44
14252: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14253: LD_VAR 0 4
14257: PPUSH
14258: LD_INT 28
14260: PUSH
14261: LD_INT 29
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_VAR 0 2
14272: PUSH
14273: LD_INT 2
14275: MOD
14276: PUSH
14277: LD_INT 1
14279: PLUS
14280: ARRAY
14281: PPUSH
14282: LD_INT 0
14284: PPUSH
14285: CALL_OW 49
// end ;
14289: GO 14224
14291: POP
14292: POP
// for i = 1 to 6 do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_INT 6
14305: PUSH
14306: FOR_TO
14307: IFFALSE 14352
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14309: LD_INT 0
14311: PPUSH
14312: LD_INT 7
14314: PUSH
14315: LD_OWVAR 67
14319: PLUS
14320: PPUSH
14321: CALL_OW 381
// un := CreateHuman ;
14325: LD_ADDR_VAR 0 4
14329: PUSH
14330: CALL_OW 44
14334: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14335: LD_VAR 0 4
14339: PPUSH
14340: LD_INT 28
14342: PPUSH
14343: LD_INT 0
14345: PPUSH
14346: CALL_OW 49
// end ;
14350: GO 14306
14352: POP
14353: POP
// for i = 1 to 3 do
14354: LD_ADDR_VAR 0 2
14358: PUSH
14359: DOUBLE
14360: LD_INT 1
14362: DEC
14363: ST_TO_ADDR
14364: LD_INT 3
14366: PUSH
14367: FOR_TO
14368: IFFALSE 14416
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 8
14375: PPUSH
14376: LD_INT 7
14378: PUSH
14379: LD_OWVAR 67
14383: PLUS
14384: PPUSH
14385: CALL_OW 380
// un := CreateHuman ;
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: CALL_OW 44
14398: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14399: LD_VAR 0 4
14403: PPUSH
14404: LD_INT 28
14406: PPUSH
14407: LD_INT 0
14409: PPUSH
14410: CALL_OW 49
// end ;
14414: GO 14367
14416: POP
14417: POP
// for i = 1 to 3 do
14418: LD_ADDR_VAR 0 2
14422: PUSH
14423: DOUBLE
14424: LD_INT 1
14426: DEC
14427: ST_TO_ADDR
14428: LD_INT 3
14430: PUSH
14431: FOR_TO
14432: IFFALSE 14522
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14434: LD_INT 14
14436: PPUSH
14437: LD_INT 2
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PPUSH
14446: LD_INT 80
14448: PPUSH
14449: CALL 70780 0 5
// veh := CreateVehicle ;
14453: LD_ADDR_VAR 0 3
14457: PUSH
14458: CALL_OW 45
14462: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14463: LD_VAR 0 3
14467: PPUSH
14468: LD_INT 3
14470: PPUSH
14471: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14475: LD_VAR 0 3
14479: PPUSH
14480: LD_INT 29
14482: PPUSH
14483: LD_INT 0
14485: PPUSH
14486: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14490: LD_INT 0
14492: PPUSH
14493: LD_INT 7
14495: PUSH
14496: LD_OWVAR 67
14500: PLUS
14501: PPUSH
14502: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14506: CALL_OW 44
14510: PPUSH
14511: LD_VAR 0 3
14515: PPUSH
14516: CALL_OW 52
// end ;
14520: GO 14431
14522: POP
14523: POP
// for i = 1 to 5 + Difficulty do
14524: LD_ADDR_VAR 0 2
14528: PUSH
14529: DOUBLE
14530: LD_INT 1
14532: DEC
14533: ST_TO_ADDR
14534: LD_INT 5
14536: PUSH
14537: LD_OWVAR 67
14541: PLUS
14542: PUSH
14543: FOR_TO
14544: IFFALSE 14671
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14546: LD_INT 14
14548: PPUSH
14549: LD_INT 1
14551: PPUSH
14552: LD_INT 3
14554: PPUSH
14555: CALL_OW 12
14559: PPUSH
14560: LD_INT 1
14562: PPUSH
14563: LD_INT 28
14565: PUSH
14566: LD_INT 26
14568: PUSH
14569: LD_INT 27
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: PUSH
14581: LD_VAR 0 2
14585: PUSH
14586: LD_INT 4
14588: MOD
14589: PUSH
14590: LD_INT 1
14592: PLUS
14593: ARRAY
14594: PPUSH
14595: LD_INT 80
14597: PPUSH
14598: CALL 70780 0 5
// veh := CreateVehicle ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: CALL_OW 45
14611: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14612: LD_VAR 0 3
14616: PPUSH
14617: LD_INT 4
14619: PPUSH
14620: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14624: LD_VAR 0 3
14628: PPUSH
14629: LD_INT 28
14631: PPUSH
14632: LD_INT 0
14634: PPUSH
14635: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14639: LD_INT 0
14641: PPUSH
14642: LD_INT 7
14644: PUSH
14645: LD_OWVAR 67
14649: PLUS
14650: PPUSH
14651: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14655: CALL_OW 44
14659: PPUSH
14660: LD_VAR 0 3
14664: PPUSH
14665: CALL_OW 52
// end ;
14669: GO 14543
14671: POP
14672: POP
// for i = 1 to 3 do
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: DOUBLE
14679: LD_INT 1
14681: DEC
14682: ST_TO_ADDR
14683: LD_INT 3
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14747
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14689: LD_INT 14
14691: PPUSH
14692: LD_INT 3
14694: PPUSH
14695: LD_INT 5
14697: PPUSH
14698: LD_INT 29
14700: PPUSH
14701: LD_INT 80
14703: PPUSH
14704: CALL 70780 0 5
// veh := CreateVehicle ;
14708: LD_ADDR_VAR 0 3
14712: PUSH
14713: CALL_OW 45
14717: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_INT 4
14725: PPUSH
14726: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14730: LD_VAR 0 3
14734: PPUSH
14735: LD_INT 28
14737: PPUSH
14738: LD_INT 0
14740: PPUSH
14741: CALL_OW 49
// end ;
14745: GO 14686
14747: POP
14748: POP
// end ;
14749: LD_VAR 0 1
14753: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14754: LD_INT 22
14756: PUSH
14757: LD_INT 2
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PPUSH
14764: CALL_OW 69
14768: IFFALSE 15068
14770: GO 14772
14772: DISABLE
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
14777: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14778: LD_ADDR_VAR 0 3
14782: PUSH
14783: LD_INT 22
14785: PUSH
14786: LD_INT 2
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 25
14795: PUSH
14796: LD_INT 4
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 69
14811: PUSH
14812: LD_EXP 94
14816: DIFF
14817: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14818: LD_ADDR_VAR 0 2
14822: PUSH
14823: LD_INT 22
14825: PUSH
14826: LD_INT 2
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PPUSH
14833: CALL_OW 69
14837: PUSH
14838: LD_EXP 94
14842: PUSH
14843: LD_VAR 0 3
14847: UNION
14848: DIFF
14849: ST_TO_ADDR
// if Khatam then
14850: LD_EXP 94
14854: IFFALSE 14871
// ComMoveXY ( Khatam , 211 , 92 ) ;
14856: LD_EXP 94
14860: PPUSH
14861: LD_INT 211
14863: PPUSH
14864: LD_INT 92
14866: PPUSH
14867: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14871: LD_INT 197
14873: PPUSH
14874: LD_INT 80
14876: PPUSH
14877: LD_INT 2
14879: PPUSH
14880: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14884: LD_INT 213
14886: PPUSH
14887: LD_INT 90
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14897: LD_INT 215
14899: PPUSH
14900: LD_INT 129
14902: PPUSH
14903: LD_INT 2
14905: PPUSH
14906: CALL_OW 441
// if sci then
14910: LD_VAR 0 3
14914: IFFALSE 14935
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14916: LD_VAR 0 3
14920: PUSH
14921: LD_INT 1
14923: ARRAY
14924: PPUSH
14925: LD_INT 197
14927: PPUSH
14928: LD_INT 80
14930: PPUSH
14931: CALL_OW 158
// if sci > 1 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: GREATER
14943: IFFALSE 14964
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: PPUSH
14954: LD_INT 213
14956: PPUSH
14957: LD_INT 90
14959: PPUSH
14960: CALL_OW 158
// if sci > 2 then
14964: LD_VAR 0 3
14968: PUSH
14969: LD_INT 2
14971: GREATER
14972: IFFALSE 14993
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14974: LD_VAR 0 3
14978: PUSH
14979: LD_INT 3
14981: ARRAY
14982: PPUSH
14983: LD_INT 215
14985: PPUSH
14986: LD_INT 129
14988: PPUSH
14989: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14993: LD_INT 35
14995: PPUSH
14996: CALL_OW 67
// for i in tmp do
15000: LD_ADDR_VAR 0 1
15004: PUSH
15005: LD_VAR 0 2
15009: PUSH
15010: FOR_IN
15011: IFFALSE 15049
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15013: LD_VAR 0 1
15017: PPUSH
15018: LD_INT 81
15020: PUSH
15021: LD_INT 2
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PPUSH
15033: LD_VAR 0 1
15037: PPUSH
15038: CALL_OW 74
15042: PPUSH
15043: CALL_OW 115
15047: GO 15010
15049: POP
15050: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15051: LD_INT 22
15053: PUSH
15054: LD_INT 2
15056: PUSH
15057: EMPTY
15058: LIST
15059: LIST
15060: PPUSH
15061: CALL_OW 69
15065: NOT
15066: IFFALSE 14993
// end ; end_of_file
15068: PPOPN 3
15070: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15071: LD_INT 0
15073: PPUSH
15074: PPUSH
15075: PPUSH
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
15080: PPUSH
15081: PPUSH
// Video ( true ) ;
15082: LD_INT 1
15084: PPUSH
15085: CALL 102569 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15089: LD_ADDR_VAR 0 5
15093: PUSH
15094: LD_INT 7
15096: PPUSH
15097: LD_INT 0
15099: PPUSH
15100: CALL_OW 517
15104: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15105: LD_ADDR_VAR 0 2
15109: PUSH
15110: DOUBLE
15111: LD_INT 1
15113: DEC
15114: ST_TO_ADDR
15115: LD_VAR 0 5
15119: PUSH
15120: LD_INT 1
15122: ARRAY
15123: PUSH
15124: FOR_TO
15125: IFFALSE 15170
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15127: LD_VAR 0 5
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 2
15140: ARRAY
15141: PPUSH
15142: LD_VAR 0 5
15146: PUSH
15147: LD_INT 2
15149: ARRAY
15150: PUSH
15151: LD_VAR 0 2
15155: ARRAY
15156: PPUSH
15157: LD_INT 1
15159: PPUSH
15160: LD_INT 15
15162: NEG
15163: PPUSH
15164: CALL 102483 0 4
15168: GO 15124
15170: POP
15171: POP
// CenterNowOnUnits ( Powell ) ;
15172: LD_EXP 58
15176: PPUSH
15177: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15181: LD_ADDR_VAR 0 5
15185: PUSH
15186: LD_EXP 56
15190: PUSH
15191: EMPTY
15192: LIST
15193: ST_TO_ADDR
// if GirlNewVeh then
15194: LD_EXP 57
15198: IFFALSE 15216
// tmp := tmp ^ GirlNewVeh ;
15200: LD_ADDR_VAR 0 5
15204: PUSH
15205: LD_VAR 0 5
15209: PUSH
15210: LD_EXP 57
15214: ADD
15215: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15216: LD_VAR 0 5
15220: PPUSH
15221: LD_INT 60
15223: PPUSH
15224: LD_INT 109
15226: PPUSH
15227: CALL_OW 111
// if KappaStatus then
15231: LD_EXP 2
15235: IFFALSE 15287
// begin Say ( JMM , D1nT-JMM-1 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1nT-JMM-1
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-1
15256: PPUSH
15257: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15261: LD_EXP 39
15265: PPUSH
15266: LD_STRING D1T-JMM-2
15268: PPUSH
15269: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15273: LD_EXP 58
15277: PPUSH
15278: LD_STRING D1T-Pow-2
15280: PPUSH
15281: CALL_OW 88
// end else
15285: GO 15493
// if JMMGirlStatus then
15287: LD_EXP 6
15291: IFFALSE 15436
// begin Say ( JMM , D1T-JMM-1 ) ;
15293: LD_EXP 39
15297: PPUSH
15298: LD_STRING D1T-JMM-1
15300: PPUSH
15301: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15305: LD_EXP 58
15309: PPUSH
15310: LD_STRING D1T-Pow-1
15312: PPUSH
15313: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15317: LD_EXP 39
15321: PPUSH
15322: LD_STRING D1T-JMM-3
15324: PPUSH
15325: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15329: LD_EXP 58
15333: PPUSH
15334: LD_STRING D1T-Pow-3
15336: PPUSH
15337: CALL_OW 88
// if JMMGirl then
15341: LD_EXP 7
15345: IFFALSE 15434
// begin case JMMGirl of 1 :
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 1
15354: DOUBLE
15355: EQUAL
15356: IFTRUE 15360
15358: GO 15375
15360: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15361: LD_EXP 40
15365: PPUSH
15366: LD_STRING D1T-Joan-3
15368: PPUSH
15369: CALL_OW 88
15373: GO 15422
15375: LD_INT 2
15377: DOUBLE
15378: EQUAL
15379: IFTRUE 15383
15381: GO 15398
15383: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15384: LD_EXP 42
15388: PPUSH
15389: LD_STRING D1T-Lisa-3
15391: PPUSH
15392: CALL_OW 88
15396: GO 15422
15398: LD_INT 3
15400: DOUBLE
15401: EQUAL
15402: IFTRUE 15406
15404: GO 15421
15406: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15407: LD_EXP 54
15411: PPUSH
15412: LD_STRING D1T-Con-3
15414: PPUSH
15415: CALL_OW 88
15419: GO 15422
15421: POP
// Say ( Powell , D1T-Pow-4 ) ;
15422: LD_EXP 58
15426: PPUSH
15427: LD_STRING D1T-Pow-4
15429: PPUSH
15430: CALL_OW 88
// end ; end else
15434: GO 15493
// if not FastEnd then
15436: LD_EXP 11
15440: NOT
15441: IFFALSE 15469
// begin Say ( JMM , D1T-JMM-4 ) ;
15443: LD_EXP 39
15447: PPUSH
15448: LD_STRING D1T-JMM-4
15450: PPUSH
15451: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15455: LD_EXP 58
15459: PPUSH
15460: LD_STRING D1T-Pow-5
15462: PPUSH
15463: CALL_OW 88
// end else
15467: GO 15493
// begin Say ( JMM , D1nT-JMM-1 ) ;
15469: LD_EXP 39
15473: PPUSH
15474: LD_STRING D1nT-JMM-1
15476: PPUSH
15477: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15481: LD_EXP 58
15485: PPUSH
15486: LD_STRING D1nT-Pow-1
15488: PPUSH
15489: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15493: LD_INT 35
15495: PPUSH
15496: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15500: LD_EXP 56
15504: PPUSH
15505: CALL_OW 314
15509: NOT
15510: IFFALSE 15493
// ComExitVehicle ( JMM ) ;
15512: LD_EXP 39
15516: PPUSH
15517: CALL_OW 121
// wait ( 3 ) ;
15521: LD_INT 3
15523: PPUSH
15524: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15528: LD_EXP 39
15532: PPUSH
15533: LD_INT 60
15535: PPUSH
15536: LD_INT 94
15538: PPUSH
15539: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15543: LD_EXP 39
15547: PPUSH
15548: LD_EXP 58
15552: PPUSH
15553: CALL_OW 179
// if Joan then
15557: LD_EXP 40
15561: IFFALSE 15615
// begin ComExitVehicle ( Joan ) ;
15563: LD_EXP 40
15567: PPUSH
15568: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15572: LD_EXP 40
15576: PPUSH
15577: LD_INT 35
15579: PPUSH
15580: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15584: LD_EXP 40
15588: PPUSH
15589: LD_INT 65
15591: PPUSH
15592: LD_INT 104
15594: PPUSH
15595: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15599: LD_EXP 40
15603: PPUSH
15604: LD_EXP 39
15608: PPUSH
15609: CALL_OW 179
// end else
15613: GO 15749
// if Lisa and JMMGirl = 2 then
15615: LD_EXP 42
15619: PUSH
15620: LD_EXP 7
15624: PUSH
15625: LD_INT 2
15627: EQUAL
15628: AND
15629: IFFALSE 15683
// begin ComExitVehicle ( Lisa ) ;
15631: LD_EXP 42
15635: PPUSH
15636: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15640: LD_EXP 42
15644: PPUSH
15645: LD_INT 35
15647: PPUSH
15648: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15652: LD_EXP 42
15656: PPUSH
15657: LD_INT 65
15659: PPUSH
15660: LD_INT 104
15662: PPUSH
15663: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15667: LD_EXP 42
15671: PPUSH
15672: LD_EXP 39
15676: PPUSH
15677: CALL_OW 179
// end else
15681: GO 15749
// if Connie and JMMGirl = 3 then
15683: LD_EXP 54
15687: PUSH
15688: LD_EXP 7
15692: PUSH
15693: LD_INT 3
15695: EQUAL
15696: AND
15697: IFFALSE 15749
// begin ComExitVehicle ( Connie ) ;
15699: LD_EXP 54
15703: PPUSH
15704: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15708: LD_EXP 54
15712: PPUSH
15713: LD_INT 35
15715: PPUSH
15716: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15720: LD_EXP 54
15724: PPUSH
15725: LD_INT 65
15727: PPUSH
15728: LD_INT 104
15730: PPUSH
15731: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15735: LD_EXP 54
15739: PPUSH
15740: LD_EXP 39
15744: PPUSH
15745: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15749: LD_INT 35
15751: PPUSH
15752: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15756: LD_EXP 39
15760: PPUSH
15761: LD_EXP 58
15765: PPUSH
15766: CALL_OW 296
15770: PUSH
15771: LD_INT 6
15773: LESS
15774: IFFALSE 15749
// wait ( 0 0$0.5 ) ;
15776: LD_INT 18
15778: PPUSH
15779: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15783: LD_EXP 39
15787: PPUSH
15788: LD_STRING D1-JMM-1
15790: PPUSH
15791: CALL_OW 88
// async ;
15795: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15796: LD_EXP 58
15800: PPUSH
15801: LD_STRING D1-Pow-1
15803: PPUSH
15804: CALL_OW 88
// if not dialogue_skipped then
15808: LD_OWVAR 59
15812: NOT
15813: IFFALSE 15822
// wait ( 0 0$2 ) ;
15815: LD_INT 70
15817: PPUSH
15818: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15822: LD_INT 170
15824: PPUSH
15825: LD_INT 99
15827: PPUSH
15828: LD_INT 1
15830: PPUSH
15831: LD_INT 6
15833: NEG
15834: PPUSH
15835: CALL 102483 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15839: LD_INT 174
15841: PPUSH
15842: LD_INT 115
15844: PPUSH
15845: LD_INT 1
15847: PPUSH
15848: LD_INT 6
15850: NEG
15851: PPUSH
15852: CALL 102483 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15856: LD_INT 169
15858: PPUSH
15859: LD_INT 71
15861: PPUSH
15862: LD_INT 1
15864: PPUSH
15865: LD_INT 6
15867: NEG
15868: PPUSH
15869: CALL 102483 0 4
// if not dialogue_skipped then
15873: LD_OWVAR 59
15877: NOT
15878: IFFALSE 15897
// begin CenterOnXY ( 170 , 99 ) ;
15880: LD_INT 170
15882: PPUSH
15883: LD_INT 99
15885: PPUSH
15886: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15890: LD_INT 80
15892: PPUSH
15893: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15897: LD_INT 75
15899: PPUSH
15900: LD_INT 53
15902: PPUSH
15903: LD_INT 1
15905: PPUSH
15906: LD_INT 9
15908: NEG
15909: PPUSH
15910: CALL 102483 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15914: LD_INT 54
15916: PPUSH
15917: LD_INT 42
15919: PPUSH
15920: LD_INT 1
15922: PPUSH
15923: LD_INT 9
15925: NEG
15926: PPUSH
15927: CALL 102483 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15931: LD_INT 62
15933: PPUSH
15934: LD_INT 51
15936: PPUSH
15937: LD_INT 1
15939: PPUSH
15940: LD_INT 9
15942: NEG
15943: PPUSH
15944: CALL 102483 0 4
// if not dialogue_skipped then
15948: LD_OWVAR 59
15952: NOT
15953: IFFALSE 15972
// begin CenterOnXY ( 75 , 53 ) ;
15955: LD_INT 75
15957: PPUSH
15958: LD_INT 53
15960: PPUSH
15961: CALL_OW 84
// wait ( 0 0$4 ) ;
15965: LD_INT 140
15967: PPUSH
15968: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15972: LD_EXP 58
15976: PPUSH
15977: CALL_OW 87
// if not dialogue_skipped then
15981: LD_OWVAR 59
15985: NOT
15986: IFFALSE 15995
// wait ( 0 0$2 ) ;
15988: LD_INT 70
15990: PPUSH
15991: CALL_OW 67
// sync ;
15995: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15996: LD_EXP 39
16000: PPUSH
16001: LD_STRING D1-JMM-2
16003: PPUSH
16004: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16008: LD_EXP 58
16012: PPUSH
16013: LD_STRING D1-Pow-2
16015: PPUSH
16016: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16020: LD_EXP 39
16024: PPUSH
16025: LD_STRING D1-JMM-3
16027: PPUSH
16028: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16032: LD_EXP 58
16036: PPUSH
16037: LD_STRING D1-Pow-3
16039: PPUSH
16040: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16044: LD_EXP 39
16048: PPUSH
16049: LD_STRING D1-JMM-4
16051: PPUSH
16052: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16056: LD_EXP 58
16060: PPUSH
16061: LD_STRING D1-Pow-4
16063: PPUSH
16064: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16068: LD_EXP 39
16072: PPUSH
16073: LD_STRING D1-JMM-5
16075: PPUSH
16076: CALL_OW 88
// async ;
16080: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16081: LD_EXP 58
16085: PPUSH
16086: LD_STRING D1-Pow-5
16088: PPUSH
16089: CALL_OW 88
// if not dialogue_skipped then
16093: LD_OWVAR 59
16097: NOT
16098: IFFALSE 16107
// wait ( 0 0$3.6 ) ;
16100: LD_INT 126
16102: PPUSH
16103: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16107: LD_INT 134
16109: PPUSH
16110: LD_INT 210
16112: PPUSH
16113: LD_INT 1
16115: PPUSH
16116: LD_INT 11
16118: NEG
16119: PPUSH
16120: CALL 102483 0 4
// if not dialogue_skipped then
16124: LD_OWVAR 59
16128: NOT
16129: IFFALSE 16148
// begin CenterOnXY ( 134 , 210 ) ;
16131: LD_INT 134
16133: PPUSH
16134: LD_INT 210
16136: PPUSH
16137: CALL_OW 84
// wait ( 0 0$2 ) ;
16141: LD_INT 70
16143: PPUSH
16144: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16148: LD_INT 101
16150: PPUSH
16151: LD_INT 159
16153: PPUSH
16154: LD_INT 1
16156: PPUSH
16157: LD_INT 10
16159: NEG
16160: PPUSH
16161: CALL 102483 0 4
// if not dialogue_skipped then
16165: LD_OWVAR 59
16169: NOT
16170: IFFALSE 16189
// begin CenterOnXY ( 101 , 159 ) ;
16172: LD_INT 101
16174: PPUSH
16175: LD_INT 159
16177: PPUSH
16178: CALL_OW 84
// wait ( 0 0$2 ) ;
16182: LD_INT 70
16184: PPUSH
16185: CALL_OW 67
// end ; sync ;
16189: SYNC
// CenterNowOnUnits ( Powell ) ;
16190: LD_EXP 58
16194: PPUSH
16195: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16199: LD_ADDR_VAR 0 6
16203: PUSH
16204: LD_INT 1
16206: PUSH
16207: LD_INT 2
16209: PUSH
16210: LD_INT 3
16212: PUSH
16213: LD_INT 4
16215: PUSH
16216: LD_INT 5
16218: PUSH
16219: LD_INT 6
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if not dialogue_skipped then
16230: LD_OWVAR 59
16234: NOT
16235: IFFALSE 16404
// begin game_speed := 4 ;
16237: LD_ADDR_OWVAR 65
16241: PUSH
16242: LD_INT 4
16244: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16245: LD_INT 210
16247: PPUSH
16248: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16252: LD_ADDR_VAR 0 7
16256: PUSH
16257: LD_STRING Q1
16259: PPUSH
16260: LD_VAR 0 6
16264: PPUSH
16265: CALL_OW 98
16269: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16270: LD_ADDR_VAR 0 7
16274: PUSH
16275: LD_STRING Q1
16277: PPUSH
16278: LD_VAR 0 6
16282: PPUSH
16283: CALL_OW 98
16287: ST_TO_ADDR
// options = options diff dec ;
16288: LD_ADDR_VAR 0 6
16292: PUSH
16293: LD_VAR 0 6
16297: PUSH
16298: LD_VAR 0 7
16302: DIFF
16303: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16304: LD_VAR 0 7
16308: PPUSH
16309: LD_VAR 0 6
16313: PPUSH
16314: CALL 17876 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16318: LD_VAR 0 7
16322: PUSH
16323: LD_INT 5
16325: PUSH
16326: LD_INT 6
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: IN
16333: PUSH
16334: LD_VAR 0 6
16338: PUSH
16339: LD_INT 2
16341: EQUAL
16342: OR
16343: IFFALSE 16270
// if not ( dec in [ 5 , 6 ] ) then
16345: LD_VAR 0 7
16349: PUSH
16350: LD_INT 5
16352: PUSH
16353: LD_INT 6
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: IN
16360: NOT
16361: IFFALSE 16404
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16363: LD_ADDR_VAR 0 7
16367: PUSH
16368: LD_STRING Q1a
16370: PPUSH
16371: LD_INT 1
16373: PUSH
16374: LD_INT 2
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PPUSH
16381: CALL_OW 98
16385: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16386: LD_VAR 0 7
16390: PUSH
16391: LD_INT 4
16393: PLUS
16394: PPUSH
16395: LD_VAR 0 6
16399: PPUSH
16400: CALL 17876 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16404: LD_INT 81
16406: PPUSH
16407: LD_INT 127
16409: PPUSH
16410: CALL_OW 84
// amount := 5 ;
16414: LD_ADDR_VAR 0 8
16418: PUSH
16419: LD_INT 5
16421: ST_TO_ADDR
// macmilan_squad := [ ] ;
16422: LD_ADDR_VAR 0 9
16426: PUSH
16427: EMPTY
16428: ST_TO_ADDR
// if vip < amount then
16429: LD_EXP 59
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16483
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16441: LD_ADDR_VAR 0 5
16445: PUSH
16446: LD_EXP 59
16450: PUSH
16451: LD_INT 22
16453: PUSH
16454: LD_INT 4
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PUSH
16461: LD_INT 21
16463: PUSH
16464: LD_INT 1
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: PPUSH
16475: CALL_OW 69
16479: UNION
16480: ST_TO_ADDR
16481: GO 16493
// tmp := vip ;
16483: LD_ADDR_VAR 0 5
16487: PUSH
16488: LD_EXP 59
16492: ST_TO_ADDR
// tmp := tmp diff Powell ;
16493: LD_ADDR_VAR 0 5
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_EXP 58
16507: DIFF
16508: ST_TO_ADDR
// if tmp < amount then
16509: LD_VAR 0 5
16513: PUSH
16514: LD_VAR 0 8
16518: LESS
16519: IFFALSE 16531
// amount := tmp ;
16521: LD_ADDR_VAR 0 8
16525: PUSH
16526: LD_VAR 0 5
16530: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16531: LD_VAR 0 5
16535: PUSH
16536: LD_INT 1
16538: ARRAY
16539: PPUSH
16540: CALL_OW 257
16544: PUSH
16545: LD_INT 2
16547: NONEQUAL
16548: IFFALSE 16610
// begin if IsInUnit ( tmp [ 1 ] ) then
16550: LD_VAR 0 5
16554: PUSH
16555: LD_INT 1
16557: ARRAY
16558: PPUSH
16559: CALL_OW 310
16563: IFFALSE 16578
// ComExitBuilding ( tmp [ 1 ] ) ;
16565: LD_VAR 0 5
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_INT 387
16589: PPUSH
16590: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16594: LD_VAR 0 5
16598: PUSH
16599: LD_INT 1
16601: ARRAY
16602: PPUSH
16603: LD_INT 2
16605: PPUSH
16606: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16610: LD_EXP 39
16614: PPUSH
16615: LD_INT 82
16617: PPUSH
16618: LD_INT 129
16620: PPUSH
16621: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16625: LD_EXP 39
16629: PPUSH
16630: LD_EXP 58
16634: PPUSH
16635: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16639: LD_INT 22
16641: PUSH
16642: LD_INT 1
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PPUSH
16649: CALL_OW 69
16653: PUSH
16654: LD_EXP 39
16658: DIFF
16659: PPUSH
16660: LD_INT 84
16662: PPUSH
16663: LD_INT 128
16665: PPUSH
16666: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16670: LD_INT 22
16672: PUSH
16673: LD_INT 1
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL_OW 69
16684: PUSH
16685: LD_EXP 39
16689: DIFF
16690: PPUSH
16691: LD_EXP 39
16695: PPUSH
16696: CALL_OW 179
// for i = 1 to amount do
16700: LD_ADDR_VAR 0 2
16704: PUSH
16705: DOUBLE
16706: LD_INT 1
16708: DEC
16709: ST_TO_ADDR
16710: LD_VAR 0 8
16714: PUSH
16715: FOR_TO
16716: IFFALSE 16884
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16718: LD_ADDR_VAR 0 9
16722: PUSH
16723: LD_VAR 0 9
16727: PUSH
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: ADD
16739: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16740: LD_VAR 0 5
16744: PUSH
16745: LD_VAR 0 2
16749: ARRAY
16750: PPUSH
16751: CALL_OW 310
16755: IFFALSE 16772
// AddComExitBuilding ( tmp [ i ] ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: CALL_OW 182
// if i = 2 and JMMNewVeh then
16772: LD_VAR 0 2
16776: PUSH
16777: LD_INT 2
16779: EQUAL
16780: PUSH
16781: LD_EXP 56
16785: AND
16786: IFFALSE 16844
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16788: LD_VAR 0 5
16792: PUSH
16793: LD_VAR 0 2
16797: ARRAY
16798: PPUSH
16799: LD_EXP 56
16803: PPUSH
16804: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16808: LD_VAR 0 5
16812: PUSH
16813: LD_VAR 0 2
16817: ARRAY
16818: PPUSH
16819: LD_INT 86
16821: PPUSH
16822: LD_INT 133
16824: PPUSH
16825: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16829: LD_VAR 0 5
16833: PUSH
16834: LD_VAR 0 2
16838: ARRAY
16839: PPUSH
16840: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16844: LD_VAR 0 5
16848: PUSH
16849: LD_VAR 0 2
16853: ARRAY
16854: PPUSH
16855: LD_INT 8
16857: PPUSH
16858: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16862: LD_VAR 0 5
16866: PUSH
16867: LD_VAR 0 2
16871: ARRAY
16872: PPUSH
16873: LD_EXP 39
16877: PPUSH
16878: CALL_OW 179
// end ;
16882: GO 16715
16884: POP
16885: POP
// if GirlNewVeh then
16886: LD_EXP 57
16890: IFFALSE 16904
// SetSide ( GirlNewVeh , 4 ) ;
16892: LD_EXP 57
16896: PPUSH
16897: LD_INT 4
16899: PPUSH
16900: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16904: LD_INT 35
16906: PPUSH
16907: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16911: LD_VAR 0 9
16915: PPUSH
16916: LD_INT 95
16918: PUSH
16919: LD_INT 9
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL_OW 72
16930: PUSH
16931: LD_INT 0
16933: EQUAL
16934: PUSH
16935: LD_EXP 39
16939: PPUSH
16940: LD_INT 9
16942: PPUSH
16943: CALL_OW 308
16947: NOT
16948: AND
16949: IFFALSE 16904
// wait ( 0 0$2 ) ;
16951: LD_INT 70
16953: PPUSH
16954: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16958: LD_VAR 0 9
16962: PPUSH
16963: LD_INT 1
16965: PPUSH
16966: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16970: LD_INT 21
16972: PUSH
16973: LD_INT 2
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: LD_INT 92
16982: PUSH
16983: LD_INT 83
16985: PUSH
16986: LD_INT 130
16988: PUSH
16989: LD_INT 10
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PPUSH
17002: CALL_OW 69
17006: PPUSH
17007: LD_INT 1
17009: PPUSH
17010: CALL_OW 235
// Video ( false ) ;
17014: LD_INT 0
17016: PPUSH
17017: CALL 102569 0 1
// ChangeMissionObjectives ( M1 ) ;
17021: LD_STRING M1
17023: PPUSH
17024: CALL_OW 337
// SaveForQuickRestart ;
17028: CALL_OW 22
// missionStart := true ;
17032: LD_ADDR_EXP 13
17036: PUSH
17037: LD_INT 1
17039: ST_TO_ADDR
// missionStage := 2 ;
17040: LD_ADDR_EXP 15
17044: PUSH
17045: LD_INT 2
17047: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17048: LD_INT 105
17050: PPUSH
17051: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17055: LD_ADDR_VAR 0 5
17059: PUSH
17060: LD_INT 22
17062: PUSH
17063: LD_INT 4
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: PUSH
17070: LD_INT 21
17072: PUSH
17073: LD_INT 1
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PPUSH
17084: CALL_OW 69
17088: PUSH
17089: LD_EXP 58
17093: DIFF
17094: ST_TO_ADDR
// if not tmp then
17095: LD_VAR 0 5
17099: NOT
17100: IFFALSE 17115
// tmp := [ Powell ] ;
17102: LD_ADDR_VAR 0 5
17106: PUSH
17107: LD_EXP 58
17111: PUSH
17112: EMPTY
17113: LIST
17114: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17115: LD_ADDR_EXP 117
17119: PUSH
17120: LD_EXP 117
17124: PPUSH
17125: LD_INT 4
17127: PPUSH
17128: LD_INT 22
17130: PUSH
17131: LD_INT 4
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PUSH
17138: LD_INT 23
17140: PUSH
17141: LD_INT 1
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 21
17153: PUSH
17154: LD_INT 2
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PPUSH
17170: CALL_OW 69
17174: PUSH
17175: LD_EXP 58
17179: DIFF
17180: PPUSH
17181: CALL_OW 1
17185: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17186: LD_ADDR_VAR 0 4
17190: PUSH
17191: LD_INT 22
17193: PUSH
17194: LD_INT 4
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 34
17203: PUSH
17204: LD_INT 12
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: PUSH
17220: LD_INT 1
17222: ARRAY
17223: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17224: LD_VAR 0 5
17228: PUSH
17229: LD_INT 1
17231: ARRAY
17232: PPUSH
17233: CALL_OW 310
17237: IFFALSE 17252
// ComExitBuilding ( tmp [ 1 ] ) ;
17239: LD_VAR 0 5
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17252: LD_VAR 0 5
17256: PUSH
17257: LD_INT 1
17259: ARRAY
17260: PPUSH
17261: LD_VAR 0 4
17265: PPUSH
17266: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17270: LD_VAR 0 5
17274: PUSH
17275: LD_INT 1
17277: ARRAY
17278: PPUSH
17279: LD_INT 80
17281: PPUSH
17282: LD_INT 136
17284: PPUSH
17285: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17289: LD_VAR 0 5
17293: PUSH
17294: LD_INT 1
17296: ARRAY
17297: PPUSH
17298: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17302: LD_VAR 0 5
17306: PUSH
17307: LD_INT 1
17309: ARRAY
17310: PPUSH
17311: LD_INT 59
17313: PPUSH
17314: LD_INT 112
17316: PPUSH
17317: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17321: LD_VAR 0 5
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17334: LD_EXP 40
17338: PUSH
17339: LD_EXP 40
17343: PPUSH
17344: CALL_OW 255
17348: PUSH
17349: LD_INT 1
17351: EQUAL
17352: AND
17353: IFFALSE 17379
// begin Say ( Joan , D3W-Joan-1 ) ;
17355: LD_EXP 40
17359: PPUSH
17360: LD_STRING D3W-Joan-1
17362: PPUSH
17363: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17367: LD_EXP 39
17371: PPUSH
17372: LD_STRING D3W-JMM-1
17374: PPUSH
17375: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17379: LD_EXP 42
17383: PUSH
17384: LD_EXP 42
17388: PPUSH
17389: CALL_OW 255
17393: PUSH
17394: LD_INT 1
17396: EQUAL
17397: AND
17398: PUSH
17399: LD_EXP 42
17403: PUSH
17404: LD_EXP 59
17408: IN
17409: NOT
17410: AND
17411: IFFALSE 17437
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17413: LD_EXP 42
17417: PPUSH
17418: LD_STRING D3W-Lisa-1
17420: PPUSH
17421: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17425: LD_EXP 39
17429: PPUSH
17430: LD_STRING D3W-JMM-1
17432: PPUSH
17433: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17437: LD_EXP 54
17441: PUSH
17442: LD_EXP 54
17446: PPUSH
17447: CALL_OW 255
17451: PUSH
17452: LD_INT 1
17454: EQUAL
17455: AND
17456: IFFALSE 17482
// begin Say ( Connie , D3W-Con-1 ) ;
17458: LD_EXP 54
17462: PPUSH
17463: LD_STRING D3W-Con-1
17465: PPUSH
17466: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17470: LD_EXP 39
17474: PPUSH
17475: LD_STRING D3W-JMM-1
17477: PPUSH
17478: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17482: LD_EXP 42
17486: PUSH
17487: LD_EXP 59
17491: IN
17492: PUSH
17493: LD_EXP 42
17497: PPUSH
17498: CALL_OW 255
17502: PUSH
17503: LD_INT 1
17505: EQUAL
17506: AND
17507: IFFALSE 17523
// Say ( Lisa , D3nW-Lisa-1 ) else
17509: LD_EXP 42
17513: PPUSH
17514: LD_STRING D3nW-Lisa-1
17516: PPUSH
17517: CALL_OW 88
17521: GO 17767
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17523: LD_EXP 45
17527: PUSH
17528: LD_EXP 59
17532: IN
17533: PUSH
17534: LD_EXP 45
17538: PPUSH
17539: CALL_OW 255
17543: PUSH
17544: LD_INT 1
17546: EQUAL
17547: AND
17548: IFFALSE 17564
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17550: LD_EXP 45
17554: PPUSH
17555: LD_STRING D3nW-Cyrus-1
17557: PPUSH
17558: CALL_OW 88
17562: GO 17767
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17564: LD_EXP 44
17568: PUSH
17569: LD_EXP 59
17573: IN
17574: PUSH
17575: LD_EXP 44
17579: PPUSH
17580: CALL_OW 255
17584: PUSH
17585: LD_INT 1
17587: EQUAL
17588: AND
17589: IFFALSE 17605
// Say ( Bobby , D3nW-Bobby-1 ) else
17591: LD_EXP 44
17595: PPUSH
17596: LD_STRING D3nW-Bobby-1
17598: PPUSH
17599: CALL_OW 88
17603: GO 17767
// if Gary in vip and GetSide ( Gary ) = 1 then
17605: LD_EXP 51
17609: PUSH
17610: LD_EXP 59
17614: IN
17615: PUSH
17616: LD_EXP 51
17620: PPUSH
17621: CALL_OW 255
17625: PUSH
17626: LD_INT 1
17628: EQUAL
17629: AND
17630: IFFALSE 17646
// Say ( Gary , D3nW-Gary-1 ) else
17632: LD_EXP 51
17636: PPUSH
17637: LD_STRING D3nW-Gary-1
17639: PPUSH
17640: CALL_OW 88
17644: GO 17767
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17646: LD_EXP 43
17650: PUSH
17651: LD_EXP 59
17655: IN
17656: PUSH
17657: LD_EXP 43
17661: PPUSH
17662: CALL_OW 255
17666: PUSH
17667: LD_INT 1
17669: EQUAL
17670: AND
17671: IFFALSE 17687
// Say ( Donaldson , D3nW-Don-1 ) else
17673: LD_EXP 43
17677: PPUSH
17678: LD_STRING D3nW-Don-1
17680: PPUSH
17681: CALL_OW 88
17685: GO 17767
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17687: LD_EXP 50
17691: PUSH
17692: LD_EXP 59
17696: IN
17697: PUSH
17698: LD_EXP 50
17702: PPUSH
17703: CALL_OW 255
17707: PUSH
17708: LD_INT 1
17710: EQUAL
17711: AND
17712: IFFALSE 17728
// Say ( Cornel , D3nW-Corn-1 ) else
17714: LD_EXP 50
17718: PPUSH
17719: LD_STRING D3nW-Corn-1
17721: PPUSH
17722: CALL_OW 88
17726: GO 17767
// if Frank in vip and GetSide ( Frank ) = 1 then
17728: LD_EXP 52
17732: PUSH
17733: LD_EXP 59
17737: IN
17738: PUSH
17739: LD_EXP 52
17743: PPUSH
17744: CALL_OW 255
17748: PUSH
17749: LD_INT 1
17751: EQUAL
17752: AND
17753: IFFALSE 17767
// Say ( Frank , D3nW-Frank-1 ) ;
17755: LD_EXP 52
17759: PPUSH
17760: LD_STRING D3nW-Frank-1
17762: PPUSH
17763: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17767: LD_EXP 59
17771: PPUSH
17772: LD_INT 22
17774: PUSH
17775: LD_INT 1
17777: PUSH
17778: EMPTY
17779: LIST
17780: LIST
17781: PPUSH
17782: CALL_OW 72
17786: IFFALSE 17812
// begin Say ( JMM , D3nW-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D3nW-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17800: LD_EXP 39
17804: PPUSH
17805: LD_STRING D3nW-JMM-1a
17807: PPUSH
17808: CALL_OW 88
// end ; t := 0 0$00 ;
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: LD_INT 0
17819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17820: LD_INT 35
17822: PPUSH
17823: CALL_OW 67
// t := t + 0 0$1 ;
17827: LD_ADDR_VAR 0 3
17831: PUSH
17832: LD_VAR 0 3
17836: PUSH
17837: LD_INT 35
17839: PLUS
17840: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17841: LD_INT 59
17843: PPUSH
17844: LD_INT 112
17846: PPUSH
17847: CALL_OW 428
17851: PUSH
17852: LD_VAR 0 3
17856: PUSH
17857: LD_INT 2100
17859: GREATER
17860: OR
17861: IFFALSE 17820
// activeAttacks := true ;
17863: LD_ADDR_EXP 16
17867: PUSH
17868: LD_INT 1
17870: ST_TO_ADDR
// end ;
17871: LD_VAR 0 1
17875: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17876: LD_INT 0
17878: PPUSH
// case question of 1 :
17879: LD_VAR 0 1
17883: PUSH
17884: LD_INT 1
17886: DOUBLE
17887: EQUAL
17888: IFTRUE 17892
17890: GO 17943
17892: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17893: LD_EXP 39
17897: PPUSH
17898: LD_STRING D2Mot-JMM-1
17900: PPUSH
17901: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17905: LD_EXP 58
17909: PPUSH
17910: LD_STRING D2Mot-Pow-1
17912: PPUSH
17913: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17917: LD_EXP 39
17921: PPUSH
17922: LD_STRING D2Mot-JMM-2
17924: PPUSH
17925: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17929: LD_EXP 58
17933: PPUSH
17934: LD_STRING D2Mot-Pow-2
17936: PPUSH
17937: CALL_OW 88
// end ; 2 :
17941: GO 18294
17943: LD_INT 2
17945: DOUBLE
17946: EQUAL
17947: IFTRUE 17951
17949: GO 18027
17951: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17952: LD_EXP 39
17956: PPUSH
17957: LD_STRING D2Rus-JMM-1
17959: PPUSH
17960: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17964: LD_EXP 58
17968: PPUSH
17969: LD_STRING D2Rus-Pow-1
17971: PPUSH
17972: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17976: LD_EXP 39
17980: PPUSH
17981: LD_STRING D2Rus-JMM-2
17983: PPUSH
17984: CALL_OW 88
// if not ( 3 in list_of_q ) then
17988: LD_INT 3
17990: PUSH
17991: LD_VAR 0 2
17995: IN
17996: NOT
17997: IFFALSE 18013
// Say ( Powell , D2Rus-Pow-2 ) else
17999: LD_EXP 58
18003: PPUSH
18004: LD_STRING D2Rus-Pow-2
18006: PPUSH
18007: CALL_OW 88
18011: GO 18025
// Say ( Powell , D2Rus-Pow-2a ) ;
18013: LD_EXP 58
18017: PPUSH
18018: LD_STRING D2Rus-Pow-2a
18020: PPUSH
18021: CALL_OW 88
// end ; 3 :
18025: GO 18294
18027: LD_INT 3
18029: DOUBLE
18030: EQUAL
18031: IFTRUE 18035
18033: GO 18120
18035: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18036: LD_EXP 39
18040: PPUSH
18041: LD_STRING D2Leg-JMM-1
18043: PPUSH
18044: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18048: LD_EXP 58
18052: PPUSH
18053: LD_STRING D2Leg-Pow-1
18055: PPUSH
18056: CALL_OW 88
// if 2 in list_of_q then
18060: LD_INT 2
18062: PUSH
18063: LD_VAR 0 2
18067: IN
18068: IFFALSE 18094
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18070: LD_EXP 39
18074: PPUSH
18075: LD_STRING D2Leg-JMM-2
18077: PPUSH
18078: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18082: LD_EXP 58
18086: PPUSH
18087: LD_STRING D2Leg-Pow-2
18089: PPUSH
18090: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18094: LD_EXP 39
18098: PPUSH
18099: LD_STRING D2Leg-JMM-3
18101: PPUSH
18102: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18106: LD_EXP 58
18110: PPUSH
18111: LD_STRING D2Leg-Pow-3
18113: PPUSH
18114: CALL_OW 88
// end ; 4 :
18118: GO 18294
18120: LD_INT 4
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18203
18128: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18129: LD_EXP 39
18133: PPUSH
18134: LD_STRING D2Ar-JMM-1
18136: PPUSH
18137: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18141: LD_EXP 58
18145: PPUSH
18146: LD_STRING D2Ar-Pow-1
18148: PPUSH
18149: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18153: LD_EXP 39
18157: PPUSH
18158: LD_STRING D2Ar-JMM-2
18160: PPUSH
18161: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18165: LD_EXP 58
18169: PPUSH
18170: LD_STRING D2Ar-Pow-2
18172: PPUSH
18173: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18177: LD_EXP 39
18181: PPUSH
18182: LD_STRING D2Ar-JMM-3
18184: PPUSH
18185: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18189: LD_EXP 58
18193: PPUSH
18194: LD_STRING D2Ar-Pow-3
18196: PPUSH
18197: CALL_OW 88
// end ; 5 :
18201: GO 18294
18203: LD_INT 5
18205: DOUBLE
18206: EQUAL
18207: IFTRUE 18211
18209: GO 18226
18211: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18212: LD_EXP 39
18216: PPUSH
18217: LD_STRING D2Conf-JMM-1
18219: PPUSH
18220: CALL_OW 88
18224: GO 18294
18226: LD_INT 6
18228: DOUBLE
18229: EQUAL
18230: IFTRUE 18234
18232: GO 18293
18234: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18235: LD_EXP 39
18239: PPUSH
18240: LD_STRING D2Com-JMM-1
18242: PPUSH
18243: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18247: LD_EXP 58
18251: PPUSH
18252: LD_STRING D2Com-Pow-1
18254: PPUSH
18255: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18259: LD_EXP 39
18263: PPUSH
18264: LD_STRING D2Com-JMM-2
18266: PPUSH
18267: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18271: LD_EXP 58
18275: PPUSH
18276: LD_STRING D2Com-Pow-2
18278: PPUSH
18279: CALL_OW 88
// powellAngerQuery := true ;
18283: LD_ADDR_EXP 36
18287: PUSH
18288: LD_INT 1
18290: ST_TO_ADDR
// end ; end ;
18291: GO 18294
18293: POP
// end ;
18294: LD_VAR 0 3
18298: RET
// every 0 0$5 trigger missionStart do var tmp ;
18299: LD_EXP 13
18303: IFFALSE 18586
18305: GO 18307
18307: DISABLE
18308: LD_INT 0
18310: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18311: LD_INT 35
18313: PPUSH
18314: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18318: LD_INT 14
18320: PPUSH
18321: LD_INT 22
18323: PUSH
18324: LD_INT 1
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PPUSH
18331: CALL_OW 70
18335: PUSH
18336: LD_EXP 15
18340: PUSH
18341: LD_INT 2
18343: PUSH
18344: LD_INT 3
18346: PUSH
18347: LD_INT 4
18349: PUSH
18350: LD_INT 5
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: IN
18359: AND
18360: IFFALSE 18576
// begin powellAnger := powellAnger + 1 ;
18362: LD_ADDR_EXP 17
18366: PUSH
18367: LD_EXP 17
18371: PUSH
18372: LD_INT 1
18374: PLUS
18375: ST_TO_ADDR
// Video ( true ) ;
18376: LD_INT 1
18378: PPUSH
18379: CALL 102569 0 1
// CenterNowOnUnits ( tmp ) ;
18383: LD_VAR 0 1
18387: PPUSH
18388: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18392: LD_INT 14
18394: PPUSH
18395: LD_INT 22
18397: PUSH
18398: LD_INT 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PPUSH
18405: CALL_OW 70
18409: PPUSH
18410: LD_INT 86
18412: PPUSH
18413: LD_INT 133
18415: PPUSH
18416: CALL_OW 111
// async ;
18420: ASYNC
// case powellAnger of 1 :
18421: LD_EXP 17
18425: PUSH
18426: LD_INT 1
18428: DOUBLE
18429: EQUAL
18430: IFTRUE 18434
18432: GO 18449
18434: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18435: LD_EXP 58
18439: PPUSH
18440: LD_STRING DBack1-Pow-1
18442: PPUSH
18443: CALL_OW 88
18447: GO 18496
18449: LD_INT 2
18451: DOUBLE
18452: EQUAL
18453: IFTRUE 18457
18455: GO 18472
18457: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18458: LD_EXP 58
18462: PPUSH
18463: LD_STRING DBack2-Pow-1
18465: PPUSH
18466: CALL_OW 88
18470: GO 18496
18472: LD_INT 3
18474: DOUBLE
18475: EQUAL
18476: IFTRUE 18480
18478: GO 18495
18480: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18481: LD_EXP 58
18485: PPUSH
18486: LD_STRING DBack3-Pow-1
18488: PPUSH
18489: CALL_OW 88
18493: GO 18496
18495: POP
// sync ;
18496: SYNC
// repeat wait ( 0 0$1 ) ;
18497: LD_INT 35
18499: PPUSH
18500: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18504: LD_INT 14
18506: PPUSH
18507: LD_INT 22
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PPUSH
18517: CALL_OW 70
18521: PPUSH
18522: LD_INT 86
18524: PPUSH
18525: LD_INT 133
18527: PPUSH
18528: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18532: LD_INT 14
18534: PPUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 1
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 70
18549: NOT
18550: IFFALSE 18497
// if powellAnger >= 3 then
18552: LD_EXP 17
18556: PUSH
18557: LD_INT 3
18559: GREATEREQUAL
18560: IFFALSE 18569
// YouLost ( Dismissed ) ;
18562: LD_STRING Dismissed
18564: PPUSH
18565: CALL_OW 104
// Video ( false ) ;
18569: LD_INT 0
18571: PPUSH
18572: CALL 102569 0 1
// end ; until missionStage > 5 ;
18576: LD_EXP 15
18580: PUSH
18581: LD_INT 5
18583: GREATER
18584: IFFALSE 18311
// end ;
18586: PPOPN 1
18588: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18589: LD_EXP 13
18593: PUSH
18594: LD_INT 22
18596: PUSH
18597: LD_INT 4
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 21
18606: PUSH
18607: LD_INT 2
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PPUSH
18618: CALL_OW 69
18622: PUSH
18623: LD_INT 4
18625: GREATEREQUAL
18626: AND
18627: PUSH
18628: LD_EXP 15
18632: PUSH
18633: LD_INT 2
18635: EQUAL
18636: AND
18637: IFFALSE 20460
18639: GO 18641
18641: DISABLE
18642: LD_INT 0
18644: PPUSH
18645: PPUSH
18646: PPUSH
18647: PPUSH
18648: PPUSH
18649: PPUSH
18650: PPUSH
18651: PPUSH
// begin missionStage := 3 ;
18652: LD_ADDR_EXP 15
18656: PUSH
18657: LD_INT 3
18659: ST_TO_ADDR
// retreat := false ;
18660: LD_ADDR_VAR 0 4
18664: PUSH
18665: LD_INT 0
18667: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18668: LD_ADDR_VAR 0 5
18672: PUSH
18673: LD_INT 22
18675: PUSH
18676: LD_INT 4
18678: PUSH
18679: EMPTY
18680: LIST
18681: LIST
18682: PUSH
18683: LD_INT 30
18685: PUSH
18686: LD_INT 4
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PPUSH
18697: CALL_OW 69
18701: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18702: LD_ADDR_VAR 0 6
18706: PUSH
18707: LD_INT 22
18709: PUSH
18710: LD_INT 4
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: PUSH
18717: LD_INT 30
18719: PUSH
18720: LD_INT 5
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 69
18735: ST_TO_ADDR
// if not bar then
18736: LD_VAR 0 6
18740: NOT
18741: IFFALSE 18794
// begin repeat wait ( 0 0$1 ) ;
18743: LD_INT 35
18745: PPUSH
18746: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18750: LD_INT 22
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 3
18762: PUSH
18763: LD_INT 57
18765: PUSH
18766: EMPTY
18767: LIST
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: PUSH
18773: LD_INT 30
18775: PUSH
18776: LD_INT 5
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: LIST
18787: PPUSH
18788: CALL_OW 69
18792: IFFALSE 18743
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18794: LD_ADDR_VAR 0 6
18798: PUSH
18799: LD_INT 22
18801: PUSH
18802: LD_INT 4
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 30
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: PPUSH
18823: CALL_OW 69
18827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18828: LD_INT 35
18830: PPUSH
18831: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18835: LD_EXP 136
18839: PUSH
18840: LD_INT 4
18842: ARRAY
18843: PUSH
18844: LD_INT 4
18846: GREATEREQUAL
18847: IFFALSE 18828
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18849: LD_ADDR_VAR 0 2
18853: PUSH
18854: LD_INT 22
18856: PUSH
18857: LD_INT 4
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PUSH
18864: LD_INT 2
18866: PUSH
18867: LD_INT 25
18869: PUSH
18870: LD_INT 1
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PUSH
18877: LD_INT 25
18879: PUSH
18880: LD_INT 2
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: LD_INT 25
18889: PUSH
18890: LD_INT 3
18892: PUSH
18893: EMPTY
18894: LIST
18895: LIST
18896: PUSH
18897: LD_INT 25
18899: PUSH
18900: LD_INT 4
18902: PUSH
18903: EMPTY
18904: LIST
18905: LIST
18906: PUSH
18907: LD_INT 25
18909: PUSH
18910: LD_INT 5
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL_OW 69
18933: PUSH
18934: LD_EXP 58
18938: PUSH
18939: LD_EXP 59
18943: ADD
18944: DIFF
18945: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18946: LD_ADDR_VAR 0 3
18950: PUSH
18951: LD_VAR 0 2
18955: PPUSH
18956: LD_INT 26
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: PPUSH
18966: CALL_OW 72
18970: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18971: LD_ADDR_VAR 0 2
18975: PUSH
18976: LD_VAR 0 2
18980: PUSH
18981: LD_VAR 0 3
18985: DIFF
18986: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18987: LD_ADDR_VAR 0 2
18991: PUSH
18992: LD_VAR 0 2
18996: PPUSH
18997: LD_INT 1
18999: PPUSH
19000: CALL 101106 0 2
19004: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
19005: LD_ADDR_VAR 0 3
19009: PUSH
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL 101106 0 2
19022: ST_TO_ADDR
// for i = 1 to 4 do
19023: LD_ADDR_VAR 0 1
19027: PUSH
19028: DOUBLE
19029: LD_INT 1
19031: DEC
19032: ST_TO_ADDR
19033: LD_INT 4
19035: PUSH
19036: FOR_TO
19037: IFFALSE 19203
// begin if tmp2 then
19039: LD_VAR 0 3
19043: IFFALSE 19124
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19045: LD_ADDR_EXP 18
19049: PUSH
19050: LD_EXP 18
19054: PPUSH
19055: LD_INT 1
19057: PPUSH
19058: LD_EXP 18
19062: PUSH
19063: LD_INT 1
19065: ARRAY
19066: PUSH
19067: LD_VAR 0 3
19071: PUSH
19072: LD_VAR 0 3
19076: ARRAY
19077: ADD
19078: PPUSH
19079: CALL_OW 1
19083: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19084: LD_VAR 0 3
19088: PUSH
19089: LD_VAR 0 3
19093: ARRAY
19094: PPUSH
19095: LD_INT 1
19097: PPUSH
19098: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 3
19111: PPUSH
19112: LD_VAR 0 3
19116: PPUSH
19117: CALL_OW 3
19121: ST_TO_ADDR
// end else
19122: GO 19201
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19124: LD_ADDR_EXP 18
19128: PUSH
19129: LD_EXP 18
19133: PPUSH
19134: LD_INT 1
19136: PPUSH
19137: LD_EXP 18
19141: PUSH
19142: LD_INT 1
19144: ARRAY
19145: PUSH
19146: LD_VAR 0 2
19150: PUSH
19151: LD_VAR 0 2
19155: ARRAY
19156: ADD
19157: PPUSH
19158: CALL_OW 1
19162: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19163: LD_VAR 0 2
19167: PUSH
19168: LD_VAR 0 2
19172: ARRAY
19173: PPUSH
19174: LD_INT 1
19176: PPUSH
19177: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19181: LD_ADDR_VAR 0 2
19185: PUSH
19186: LD_VAR 0 2
19190: PPUSH
19191: LD_VAR 0 2
19195: PPUSH
19196: CALL_OW 3
19200: ST_TO_ADDR
// end ; end ;
19201: GO 19036
19203: POP
19204: POP
// if tmp2 then
19205: LD_VAR 0 3
19209: IFFALSE 19227
// tmp := tmp union tmp2 ;
19211: LD_ADDR_VAR 0 2
19215: PUSH
19216: LD_VAR 0 2
19220: PUSH
19221: LD_VAR 0 3
19225: UNION
19226: ST_TO_ADDR
// for i = 1 to 4 do
19227: LD_ADDR_VAR 0 1
19231: PUSH
19232: DOUBLE
19233: LD_INT 1
19235: DEC
19236: ST_TO_ADDR
19237: LD_INT 4
19239: PUSH
19240: FOR_TO
19241: IFFALSE 19290
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19243: LD_ADDR_EXP 18
19247: PUSH
19248: LD_EXP 18
19252: PPUSH
19253: LD_INT 2
19255: PPUSH
19256: LD_EXP 18
19260: PUSH
19261: LD_INT 2
19263: ARRAY
19264: PUSH
19265: LD_VAR 0 2
19269: PUSH
19270: LD_VAR 0 2
19274: PUSH
19275: LD_VAR 0 1
19279: MINUS
19280: ARRAY
19281: ADD
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
19288: GO 19240
19290: POP
19291: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19292: LD_ADDR_EXP 117
19296: PUSH
19297: LD_EXP 117
19301: PPUSH
19302: LD_INT 4
19304: PPUSH
19305: LD_EXP 117
19309: PUSH
19310: LD_INT 4
19312: ARRAY
19313: PUSH
19314: LD_EXP 18
19318: PUSH
19319: LD_INT 1
19321: ARRAY
19322: DIFF
19323: PPUSH
19324: CALL_OW 1
19328: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19329: LD_VAR 0 5
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PPUSH
19338: CALL_OW 313
19342: IFFALSE 19397
// begin for i in UnitsInside ( arm [ 1 ] ) do
19344: LD_ADDR_VAR 0 1
19348: PUSH
19349: LD_VAR 0 5
19353: PUSH
19354: LD_INT 1
19356: ARRAY
19357: PPUSH
19358: CALL_OW 313
19362: PUSH
19363: FOR_IN
19364: IFFALSE 19395
// begin ComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_VAR 0 6
19384: PUSH
19385: LD_INT 1
19387: ARRAY
19388: PPUSH
19389: CALL_OW 180
// end ;
19393: GO 19363
19395: POP
19396: POP
// end ; wait ( 0 0$3 ) ;
19397: LD_INT 105
19399: PPUSH
19400: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19404: LD_ADDR_VAR 0 1
19408: PUSH
19409: LD_EXP 18
19413: PUSH
19414: LD_INT 1
19416: ARRAY
19417: PUSH
19418: FOR_IN
19419: IFFALSE 19526
// begin if IsInUnit ( i ) then
19421: LD_VAR 0 1
19425: PPUSH
19426: CALL_OW 310
19430: IFFALSE 19441
// ComExitBuilding ( i ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: CALL_OW 122
// if GetClass ( i ) <> 1 then
19441: LD_VAR 0 1
19445: PPUSH
19446: CALL_OW 257
19450: PUSH
19451: LD_INT 1
19453: NONEQUAL
19454: IFFALSE 19495
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19456: LD_VAR 0 1
19460: PPUSH
19461: LD_VAR 0 5
19465: PUSH
19466: LD_INT 1
19468: ARRAY
19469: PPUSH
19470: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 1
19481: PPUSH
19482: CALL_OW 183
// AddComExitBuilding ( i ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19495: LD_VAR 0 1
19499: PPUSH
19500: LD_INT 60
19502: PPUSH
19503: LD_INT 94
19505: PPUSH
19506: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_EXP 58
19519: PPUSH
19520: CALL_OW 179
// end ;
19524: GO 19418
19526: POP
19527: POP
// wait ( 0 0$15 ) ;
19528: LD_INT 525
19530: PPUSH
19531: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19535: LD_EXP 58
19539: PPUSH
19540: LD_STRING D4-Pow-1
19542: PPUSH
19543: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19547: LD_ADDR_VAR 0 2
19551: PUSH
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PPUSH
19561: LD_INT 26
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PPUSH
19571: CALL_OW 72
19575: ST_TO_ADDR
// if tmp then
19576: LD_VAR 0 2
19580: IFFALSE 19598
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19582: LD_VAR 0 2
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: LD_STRING D4-Sol1-1
19593: PPUSH
19594: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19598: LD_EXP 58
19602: PPUSH
19603: LD_STRING D4-Pow-2
19605: PPUSH
19606: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19610: LD_ADDR_VAR 0 1
19614: PUSH
19615: DOUBLE
19616: LD_INT 1
19618: DEC
19619: ST_TO_ADDR
19620: LD_EXP 18
19624: PUSH
19625: LD_INT 1
19627: ARRAY
19628: PUSH
19629: FOR_TO
19630: IFFALSE 19723
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19632: LD_EXP 18
19636: PUSH
19637: LD_INT 1
19639: ARRAY
19640: PUSH
19641: LD_VAR 0 1
19645: ARRAY
19646: PPUSH
19647: LD_EXP 136
19651: PUSH
19652: LD_INT 4
19654: ARRAY
19655: PUSH
19656: LD_INT 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19664: LD_ADDR_EXP 136
19668: PUSH
19669: LD_EXP 136
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 136
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PPUSH
19686: LD_INT 1
19688: PPUSH
19689: CALL_OW 3
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19699: LD_INT 8
19701: PPUSH
19702: LD_EXP 18
19706: PUSH
19707: LD_INT 1
19709: ARRAY
19710: PUSH
19711: LD_VAR 0 1
19715: ARRAY
19716: PPUSH
19717: CALL_OW 471
// end ;
19721: GO 19629
19723: POP
19724: POP
// repeat wait ( 0 0$1 ) ;
19725: LD_INT 35
19727: PPUSH
19728: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19732: LD_EXP 18
19736: PUSH
19737: LD_INT 1
19739: ARRAY
19740: PPUSH
19741: LD_INT 55
19743: PUSH
19744: EMPTY
19745: LIST
19746: PPUSH
19747: CALL_OW 72
19751: PUSH
19752: LD_INT 4
19754: GREATEREQUAL
19755: IFFALSE 19725
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19757: LD_EXP 18
19761: PUSH
19762: LD_INT 1
19764: ARRAY
19765: PPUSH
19766: LD_INT 69
19768: PPUSH
19769: LD_INT 94
19771: PPUSH
19772: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19776: LD_EXP 18
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_INT 82
19787: PPUSH
19788: LD_INT 83
19790: PPUSH
19791: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PPUSH
19804: LD_INT 77
19806: PPUSH
19807: LD_INT 69
19809: PPUSH
19810: CALL_OW 174
// repeat wait ( 3 ) ;
19814: LD_INT 3
19816: PPUSH
19817: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19821: LD_ADDR_VAR 0 1
19825: PUSH
19826: LD_EXP 18
19830: PUSH
19831: LD_INT 1
19833: ARRAY
19834: PUSH
19835: FOR_IN
19836: IFFALSE 19972
// begin if GetLives ( i ) < 990 then
19838: LD_VAR 0 1
19842: PPUSH
19843: CALL_OW 256
19847: PUSH
19848: LD_INT 990
19850: LESS
19851: IFFALSE 19865
// SetLives ( i , 1000 ) ;
19853: LD_VAR 0 1
19857: PPUSH
19858: LD_INT 1000
19860: PPUSH
19861: CALL_OW 234
// if not IsInUnit ( i ) then
19865: LD_VAR 0 1
19869: PPUSH
19870: CALL_OW 310
19874: NOT
19875: IFFALSE 19970
// begin if not HasTask ( i ) then
19877: LD_VAR 0 1
19881: PPUSH
19882: CALL_OW 314
19886: NOT
19887: IFFALSE 19904
// ComMoveXY ( i , 64 , 93 ) ;
19889: LD_VAR 0 1
19893: PPUSH
19894: LD_INT 64
19896: PPUSH
19897: LD_INT 93
19899: PPUSH
19900: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19904: LD_VAR 0 4
19908: NOT
19909: PUSH
19910: LD_VAR 0 1
19914: PPUSH
19915: CALL_OW 258
19919: PUSH
19920: LD_INT 1
19922: EQUAL
19923: AND
19924: IFFALSE 19970
// begin retreat := true ;
19926: LD_ADDR_VAR 0 4
19930: PUSH
19931: LD_INT 1
19933: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19934: LD_VAR 0 1
19938: PPUSH
19939: LD_INT 2
19941: PPUSH
19942: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19946: LD_VAR 0 1
19950: PPUSH
19951: LD_STRING D4a-Sol1-1
19953: PPUSH
19954: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19958: LD_EXP 58
19962: PPUSH
19963: LD_STRING D4a-Pow-1
19965: PPUSH
19966: CALL_OW 88
// end ; end ; end ;
19970: GO 19835
19972: POP
19973: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19974: LD_EXP 18
19978: PUSH
19979: LD_INT 1
19981: ARRAY
19982: PPUSH
19983: LD_INT 95
19985: PUSH
19986: LD_INT 9
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PUSH
19993: LD_INT 3
19995: PUSH
19996: LD_INT 55
19998: PUSH
19999: EMPTY
20000: LIST
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: PUSH
20015: LD_INT 4
20017: GREATEREQUAL
20018: IFFALSE 19814
// for i in powellSquadAttack [ 1 ] do
20020: LD_ADDR_VAR 0 1
20024: PUSH
20025: LD_EXP 18
20029: PUSH
20030: LD_INT 1
20032: ARRAY
20033: PUSH
20034: FOR_IN
20035: IFFALSE 20171
// begin if GetTag ( i ) = 2 then
20037: LD_VAR 0 1
20041: PPUSH
20042: CALL_OW 110
20046: PUSH
20047: LD_INT 2
20049: EQUAL
20050: IFFALSE 20112
// begin ComMoveXY ( i , 60 , 94 ) ;
20052: LD_VAR 0 1
20056: PPUSH
20057: LD_INT 60
20059: PPUSH
20060: LD_INT 94
20062: PPUSH
20063: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20067: LD_VAR 0 1
20071: PPUSH
20072: LD_EXP 58
20076: PPUSH
20077: CALL_OW 179
// wait ( 0 0$3 ) ;
20081: LD_INT 105
20083: PPUSH
20084: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20088: LD_VAR 0 1
20092: PPUSH
20093: LD_STRING D4a-Sol1-2
20095: PPUSH
20096: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20100: LD_EXP 58
20104: PPUSH
20105: LD_STRING D4a-Pow-2
20107: PPUSH
20108: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20112: LD_VAR 0 1
20116: PPUSH
20117: LD_INT 0
20119: PPUSH
20120: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20124: LD_ADDR_EXP 117
20128: PUSH
20129: LD_EXP 117
20133: PPUSH
20134: LD_INT 4
20136: PPUSH
20137: LD_EXP 117
20141: PUSH
20142: LD_INT 4
20144: ARRAY
20145: PUSH
20146: LD_VAR 0 1
20150: UNION
20151: PPUSH
20152: CALL_OW 1
20156: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20157: LD_INT 8
20159: PPUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: CALL_OW 472
// end ;
20169: GO 20034
20171: POP
20172: POP
// wait ( 4 4$00 ) ;
20173: LD_INT 8400
20175: PPUSH
20176: CALL_OW 67
// uc_side := 6 ;
20180: LD_ADDR_OWVAR 20
20184: PUSH
20185: LD_INT 6
20187: ST_TO_ADDR
// uc_nation := 3 ;
20188: LD_ADDR_OWVAR 21
20192: PUSH
20193: LD_INT 3
20195: ST_TO_ADDR
// ru := [ ] ;
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: EMPTY
20202: ST_TO_ADDR
// for i = 1 to 4 do
20203: LD_ADDR_VAR 0 1
20207: PUSH
20208: DOUBLE
20209: LD_INT 1
20211: DEC
20212: ST_TO_ADDR
20213: LD_INT 4
20215: PUSH
20216: FOR_TO
20217: IFFALSE 20318
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20219: LD_INT 22
20221: PPUSH
20222: LD_INT 1
20224: PPUSH
20225: LD_INT 3
20227: PPUSH
20228: LD_INT 43
20230: PUSH
20231: LD_INT 44
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PUSH
20238: LD_INT 1
20240: PPUSH
20241: LD_INT 2
20243: PPUSH
20244: CALL_OW 12
20248: ARRAY
20249: PPUSH
20250: LD_INT 89
20252: PPUSH
20253: CALL 70780 0 5
// un := CreateVehicle ;
20257: LD_ADDR_VAR 0 8
20261: PUSH
20262: CALL_OW 45
20266: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20267: LD_VAR 0 8
20271: PPUSH
20272: LD_INT 4
20274: PPUSH
20275: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20279: LD_VAR 0 8
20283: PPUSH
20284: LD_INT 136
20286: PPUSH
20287: LD_INT 90
20289: PPUSH
20290: LD_INT 8
20292: PPUSH
20293: LD_INT 0
20295: PPUSH
20296: CALL_OW 50
// ru := ru ^ un ;
20300: LD_ADDR_VAR 0 7
20304: PUSH
20305: LD_VAR 0 7
20309: PUSH
20310: LD_VAR 0 8
20314: ADD
20315: ST_TO_ADDR
// end ;
20316: GO 20216
20318: POP
20319: POP
// if ru then
20320: LD_VAR 0 7
20324: IFFALSE 20341
// ComAgressiveMove ( ru , 80 , 92 ) ;
20326: LD_VAR 0 7
20330: PPUSH
20331: LD_INT 80
20333: PPUSH
20334: LD_INT 92
20336: PPUSH
20337: CALL_OW 114
// wait ( 8 8$00 ) ;
20341: LD_INT 16800
20343: PPUSH
20344: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20348: LD_INT 4
20350: PPUSH
20351: LD_INT 3
20353: PUSH
20354: LD_INT 1
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: LD_INT 5
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 4
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: LD_INT 1
20377: PUSH
20378: LD_INT 6
20380: PUSH
20381: EMPTY
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 4
20389: PUSH
20390: LD_INT 1
20392: PUSH
20393: LD_INT 1
20395: PUSH
20396: LD_INT 7
20398: PUSH
20399: EMPTY
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: PUSH
20405: LD_INT 3
20407: PUSH
20408: LD_INT 1
20410: PUSH
20411: LD_INT 1
20413: PUSH
20414: LD_INT 7
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 3
20425: PUSH
20426: LD_INT 1
20428: PUSH
20429: LD_INT 1
20431: PUSH
20432: LD_INT 5
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PPUSH
20448: CALL 59462 0 2
// missionStage := 4 ;
20452: LD_ADDR_EXP 15
20456: PUSH
20457: LD_INT 4
20459: ST_TO_ADDR
// end ;
20460: PPOPN 8
20462: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20463: LD_EXP 15
20467: PUSH
20468: LD_INT 4
20470: EQUAL
20471: PUSH
20472: LD_INT 22
20474: PUSH
20475: LD_INT 4
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: LD_INT 21
20484: PUSH
20485: LD_INT 2
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PPUSH
20496: CALL_OW 69
20500: PUSH
20501: LD_INT 5
20503: GREATEREQUAL
20504: AND
20505: IFFALSE 24626
20507: GO 20509
20509: DISABLE
20510: LD_INT 0
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
20517: PPUSH
20518: PPUSH
20519: PPUSH
20520: PPUSH
20521: PPUSH
20522: PPUSH
20523: PPUSH
20524: PPUSH
// begin missionStage := 5 ;
20525: LD_ADDR_EXP 15
20529: PUSH
20530: LD_INT 5
20532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20533: LD_ADDR_VAR 0 10
20537: PUSH
20538: LD_INT 22
20540: PUSH
20541: LD_INT 4
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 4
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: PUSH
20561: LD_INT 30
20563: PUSH
20564: LD_INT 5
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PPUSH
20580: CALL_OW 69
20584: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20585: LD_ADDR_VAR 0 6
20589: PUSH
20590: LD_INT 22
20592: PUSH
20593: LD_INT 4
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: PUSH
20600: LD_INT 21
20602: PUSH
20603: LD_INT 1
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 3
20612: PUSH
20613: LD_INT 25
20615: PUSH
20616: LD_INT 16
20618: PUSH
20619: EMPTY
20620: LIST
20621: LIST
20622: PUSH
20623: EMPTY
20624: LIST
20625: LIST
20626: PUSH
20627: LD_INT 3
20629: PUSH
20630: LD_INT 25
20632: PUSH
20633: LD_INT 12
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: PPUSH
20650: CALL_OW 69
20654: PUSH
20655: LD_EXP 58
20659: DIFF
20660: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20661: LD_ADDR_VAR 0 9
20665: PUSH
20666: LD_INT 22
20668: PUSH
20669: LD_INT 4
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: PUSH
20676: LD_INT 30
20678: PUSH
20679: LD_INT 3
20681: PUSH
20682: EMPTY
20683: LIST
20684: LIST
20685: PUSH
20686: EMPTY
20687: LIST
20688: LIST
20689: PPUSH
20690: CALL_OW 69
20694: PUSH
20695: LD_INT 1
20697: ARRAY
20698: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20699: LD_INT 35
20701: PPUSH
20702: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20706: LD_EXP 136
20710: PUSH
20711: LD_INT 4
20713: ARRAY
20714: PUSH
20715: LD_INT 5
20717: GREATEREQUAL
20718: PUSH
20719: LD_EXP 136
20723: PUSH
20724: LD_INT 4
20726: ARRAY
20727: PPUSH
20728: LD_INT 58
20730: PUSH
20731: EMPTY
20732: LIST
20733: PPUSH
20734: CALL_OW 72
20738: PUSH
20739: LD_INT 5
20741: GREATEREQUAL
20742: AND
20743: IFFALSE 20699
// powellAllowRetreat := false ;
20745: LD_ADDR_EXP 19
20749: PUSH
20750: LD_INT 0
20752: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20753: LD_INT 700
20755: PPUSH
20756: CALL_OW 67
// activeAttacks := false ;
20760: LD_ADDR_EXP 16
20764: PUSH
20765: LD_INT 0
20767: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20768: LD_INT 35
20770: PPUSH
20771: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20775: LD_INT 22
20777: PUSH
20778: LD_INT 6
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: PPUSH
20785: CALL_OW 69
20789: PUSH
20790: LD_INT 0
20792: EQUAL
20793: IFFALSE 20768
// tmp := mc_vehicles [ 4 ] ;
20795: LD_ADDR_VAR 0 3
20799: PUSH
20800: LD_EXP 136
20804: PUSH
20805: LD_INT 4
20807: ARRAY
20808: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20809: LD_ADDR_VAR 0 1
20813: PUSH
20814: DOUBLE
20815: LD_INT 1
20817: DEC
20818: ST_TO_ADDR
20819: LD_EXP 18
20823: PUSH
20824: FOR_TO
20825: IFFALSE 21086
// begin for j in powellSquadAttack [ i ] do
20827: LD_ADDR_VAR 0 2
20831: PUSH
20832: LD_EXP 18
20836: PUSH
20837: LD_VAR 0 1
20841: ARRAY
20842: PUSH
20843: FOR_IN
20844: IFFALSE 21082
// begin forces := forces diff j ;
20846: LD_ADDR_VAR 0 6
20850: PUSH
20851: LD_VAR 0 6
20855: PUSH
20856: LD_VAR 0 2
20860: DIFF
20861: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20862: LD_VAR 0 2
20866: PPUSH
20867: LD_INT 1
20869: PPUSH
20870: CALL_OW 109
// wait ( 0 0$2 ) ;
20874: LD_INT 70
20876: PPUSH
20877: CALL_OW 67
// if IsInUnit ( j ) then
20881: LD_VAR 0 2
20885: PPUSH
20886: CALL_OW 310
20890: IFFALSE 20901
// ComExitBuilding ( j ) ;
20892: LD_VAR 0 2
20896: PPUSH
20897: CALL_OW 122
// if GetClass ( j ) <> 1 then
20901: LD_VAR 0 2
20905: PPUSH
20906: CALL_OW 257
20910: PUSH
20911: LD_INT 1
20913: NONEQUAL
20914: IFFALSE 20994
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20916: LD_VAR 0 10
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PPUSH
20925: CALL_OW 313
20929: PUSH
20930: LD_INT 5
20932: GREATEREQUAL
20933: IFFALSE 20955
// AddComEnterUnit ( j , arm [ 2 ] ) else
20935: LD_VAR 0 2
20939: PPUSH
20940: LD_VAR 0 10
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: PPUSH
20949: CALL_OW 180
20953: GO 20973
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20955: LD_VAR 0 2
20959: PPUSH
20960: LD_VAR 0 10
20964: PUSH
20965: LD_INT 1
20967: ARRAY
20968: PPUSH
20969: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20973: LD_VAR 0 2
20977: PPUSH
20978: LD_INT 1
20980: PPUSH
20981: CALL_OW 183
// AddComExitBuilding ( j ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: CALL_OW 182
// end ; if i = 2 then
20994: LD_VAR 0 1
20998: PUSH
20999: LD_INT 2
21001: EQUAL
21002: IFFALSE 21019
// AddComMoveXY ( j , 61 , 93 ) ;
21004: LD_VAR 0 2
21008: PPUSH
21009: LD_INT 61
21011: PPUSH
21012: LD_INT 93
21014: PPUSH
21015: CALL_OW 171
// if i = 1 then
21019: LD_VAR 0 1
21023: PUSH
21024: LD_INT 1
21026: EQUAL
21027: IFFALSE 21080
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21029: LD_VAR 0 2
21033: PPUSH
21034: LD_VAR 0 3
21038: PUSH
21039: LD_INT 1
21041: ARRAY
21042: PPUSH
21043: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21047: LD_ADDR_VAR 0 3
21051: PUSH
21052: LD_VAR 0 3
21056: PPUSH
21057: LD_INT 1
21059: PPUSH
21060: CALL_OW 3
21064: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21065: LD_VAR 0 2
21069: PPUSH
21070: LD_INT 69
21072: PPUSH
21073: LD_INT 94
21075: PPUSH
21076: CALL_OW 171
// end ; end ;
21080: GO 20843
21082: POP
21083: POP
// end ;
21084: GO 20824
21086: POP
21087: POP
// wait ( 0 0$55 ) ;
21088: LD_INT 1925
21090: PPUSH
21091: CALL_OW 67
// MC_Kill ( 4 ) ;
21095: LD_INT 4
21097: PPUSH
21098: CALL 35532 0 1
// tmp := UnitsInside ( fac ) ;
21102: LD_ADDR_VAR 0 3
21106: PUSH
21107: LD_VAR 0 9
21111: PPUSH
21112: CALL_OW 313
21116: ST_TO_ADDR
// if tmp then
21117: LD_VAR 0 3
21121: IFFALSE 21242
// for i in tmp do
21123: LD_ADDR_VAR 0 1
21127: PUSH
21128: LD_VAR 0 3
21132: PUSH
21133: FOR_IN
21134: IFFALSE 21240
// begin ComExitBuilding ( i ) ;
21136: LD_VAR 0 1
21140: PPUSH
21141: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21145: LD_VAR 0 10
21149: PUSH
21150: LD_INT 2
21152: ARRAY
21153: PPUSH
21154: CALL_OW 313
21158: PUSH
21159: LD_INT 6
21161: LESS
21162: IFFALSE 21184
// AddComEnterUnit ( i , arm [ 2 ] ) else
21164: LD_VAR 0 1
21168: PPUSH
21169: LD_VAR 0 10
21173: PUSH
21174: LD_INT 2
21176: ARRAY
21177: PPUSH
21178: CALL_OW 180
21182: GO 21238
// if UnitsInside ( arm [ 1 ] ) < 6 then
21184: LD_VAR 0 10
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PPUSH
21193: CALL_OW 313
21197: PUSH
21198: LD_INT 6
21200: LESS
21201: IFFALSE 21223
// AddComEnterUnit ( i , arm [ 1 ] ) else
21203: LD_VAR 0 1
21207: PPUSH
21208: LD_VAR 0 10
21212: PUSH
21213: LD_INT 1
21215: ARRAY
21216: PPUSH
21217: CALL_OW 180
21221: GO 21238
// AddComMoveXY ( i , 37 , 68 ) ;
21223: LD_VAR 0 1
21227: PPUSH
21228: LD_INT 37
21230: PPUSH
21231: LD_INT 68
21233: PPUSH
21234: CALL_OW 171
// end ;
21238: GO 21133
21240: POP
21241: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21242: LD_ADDR_VAR 0 11
21246: PUSH
21247: LD_VAR 0 6
21251: PPUSH
21252: LD_INT 26
21254: PUSH
21255: LD_INT 1
21257: PUSH
21258: EMPTY
21259: LIST
21260: LIST
21261: PPUSH
21262: CALL_OW 72
21266: PUSH
21267: LD_EXP 59
21271: DIFF
21272: ST_TO_ADDR
// if not speaker then
21273: LD_VAR 0 11
21277: NOT
21278: IFFALSE 21305
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21280: LD_ADDR_VAR 0 11
21284: PUSH
21285: LD_VAR 0 6
21289: PPUSH
21290: LD_INT 26
21292: PUSH
21293: LD_INT 1
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: PPUSH
21300: CALL_OW 72
21304: ST_TO_ADDR
// if speaker then
21305: LD_VAR 0 11
21309: IFFALSE 21325
// speaker := speaker [ 1 ] ;
21311: LD_ADDR_VAR 0 11
21315: PUSH
21316: LD_VAR 0 11
21320: PUSH
21321: LD_INT 1
21323: ARRAY
21324: ST_TO_ADDR
// Video ( true ) ;
21325: LD_INT 1
21327: PPUSH
21328: CALL 102569 0 1
// CenterNowOnUnits ( Powell ) ;
21332: LD_EXP 58
21336: PPUSH
21337: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_VAR 0 6
21350: PPUSH
21351: LD_INT 3
21353: PUSH
21354: LD_INT 25
21356: PUSH
21357: LD_INT 1
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 72
21372: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21373: LD_ADDR_VAR 0 12
21377: PUSH
21378: LD_INT 22
21380: PUSH
21381: LD_INT 4
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: PUSH
21388: LD_INT 30
21390: PUSH
21391: LD_INT 32
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: PUSH
21398: LD_INT 58
21400: PUSH
21401: EMPTY
21402: LIST
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: LIST
21408: PPUSH
21409: CALL_OW 69
21413: ST_TO_ADDR
// for i = 1 to 6 do
21414: LD_ADDR_VAR 0 1
21418: PUSH
21419: DOUBLE
21420: LD_INT 1
21422: DEC
21423: ST_TO_ADDR
21424: LD_INT 6
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21569
// begin if IsInUnit ( tmp [ i ] ) then
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 310
21445: IFFALSE 21462
// ComExitBuilding ( tmp [ i ] ) ;
21447: LD_VAR 0 3
21451: PUSH
21452: LD_VAR 0 1
21456: ARRAY
21457: PPUSH
21458: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21462: LD_VAR 0 3
21466: PUSH
21467: LD_VAR 0 1
21471: ARRAY
21472: PPUSH
21473: LD_VAR 0 10
21477: PUSH
21478: LD_INT 1
21480: ARRAY
21481: PPUSH
21482: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21486: LD_VAR 0 3
21490: PUSH
21491: LD_VAR 0 1
21495: ARRAY
21496: PPUSH
21497: LD_INT 1
21499: PPUSH
21500: CALL_OW 183
// if emp_towers then
21504: LD_VAR 0 12
21508: IFFALSE 21567
// begin AddComExitBuilding ( tmp [ i ] ) ;
21510: LD_VAR 0 3
21514: PUSH
21515: LD_VAR 0 1
21519: ARRAY
21520: PPUSH
21521: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21525: LD_VAR 0 3
21529: PUSH
21530: LD_VAR 0 1
21534: ARRAY
21535: PPUSH
21536: LD_VAR 0 12
21540: PUSH
21541: LD_INT 1
21543: ARRAY
21544: PPUSH
21545: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21549: LD_ADDR_VAR 0 12
21553: PUSH
21554: LD_VAR 0 12
21558: PPUSH
21559: LD_INT 1
21561: PPUSH
21562: CALL_OW 3
21566: ST_TO_ADDR
// end ; end ;
21567: GO 21427
21569: POP
21570: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21571: LD_ADDR_VAR 0 3
21575: PUSH
21576: LD_EXP 18
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PUSH
21585: LD_EXP 18
21589: PUSH
21590: LD_INT 2
21592: ARRAY
21593: ADD
21594: PPUSH
21595: LD_INT 26
21597: PUSH
21598: LD_INT 1
21600: PUSH
21601: EMPTY
21602: LIST
21603: LIST
21604: PPUSH
21605: CALL_OW 72
21609: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21610: LD_ADDR_VAR 0 1
21614: PUSH
21615: LD_EXP 18
21619: PUSH
21620: LD_INT 2
21622: ARRAY
21623: PUSH
21624: FOR_IN
21625: IFFALSE 21643
// ComTurnUnit ( i , Powell ) ;
21627: LD_VAR 0 1
21631: PPUSH
21632: LD_EXP 58
21636: PPUSH
21637: CALL_OW 119
21641: GO 21624
21643: POP
21644: POP
// Say ( Powell , D5-Pow-1 ) ;
21645: LD_EXP 58
21649: PPUSH
21650: LD_STRING D5-Pow-1
21652: PPUSH
21653: CALL_OW 88
// if tmp then
21657: LD_VAR 0 3
21661: IFFALSE 21679
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 1
21670: ARRAY
21671: PPUSH
21672: LD_STRING D5-Sol2-1
21674: PPUSH
21675: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21679: LD_EXP 58
21683: PPUSH
21684: LD_STRING D5-Pow-2
21686: PPUSH
21687: CALL_OW 88
// if tmp > 1 then
21691: LD_VAR 0 3
21695: PUSH
21696: LD_INT 1
21698: GREATER
21699: IFFALSE 21717
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21701: LD_VAR 0 3
21705: PUSH
21706: LD_INT 2
21708: ARRAY
21709: PPUSH
21710: LD_STRING D5-Sol2-2
21712: PPUSH
21713: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21717: LD_EXP 58
21721: PPUSH
21722: LD_STRING D5-Pow-3
21724: PPUSH
21725: CALL_OW 88
// wait ( 0 0$1 ) ;
21729: LD_INT 35
21731: PPUSH
21732: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21736: LD_ADDR_VAR 0 3
21740: PUSH
21741: LD_EXP 18
21745: PUSH
21746: LD_INT 1
21748: ARRAY
21749: PUSH
21750: LD_EXP 18
21754: PUSH
21755: LD_INT 2
21757: ARRAY
21758: UNION
21759: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21760: LD_VAR 0 3
21764: PPUSH
21765: LD_INT 80
21767: PPUSH
21768: LD_INT 67
21770: PPUSH
21771: CALL_OW 114
// wait ( 0 0$2 ) ;
21775: LD_INT 70
21777: PPUSH
21778: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21782: LD_INT 79
21784: PPUSH
21785: LD_INT 72
21787: PPUSH
21788: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21792: LD_INT 35
21794: PPUSH
21795: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21799: LD_VAR 0 3
21803: PPUSH
21804: LD_INT 3
21806: PUSH
21807: LD_INT 24
21809: PUSH
21810: LD_INT 1000
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PPUSH
21821: CALL_OW 72
21825: IFFALSE 21792
// Say ( Powell , D5a-Pow-1 ) ;
21827: LD_EXP 58
21831: PPUSH
21832: LD_STRING D5a-Pow-1
21834: PPUSH
21835: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21839: LD_EXP 58
21843: PPUSH
21844: LD_STRING D5a-Pow-1a
21846: PPUSH
21847: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21851: LD_INT 10
21853: PPUSH
21854: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21858: LD_EXP 58
21862: PPUSH
21863: LD_STRING D5a-Pow-1b
21865: PPUSH
21866: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21870: LD_EXP 58
21874: PPUSH
21875: LD_STRING D5a-Pow-1c
21877: PPUSH
21878: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21882: LD_EXP 58
21886: PPUSH
21887: LD_STRING D5a-Pow-1d
21889: PPUSH
21890: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21894: LD_INT 35
21896: PPUSH
21897: CALL_OW 67
// if not HasTask ( tmp ) then
21901: LD_VAR 0 3
21905: PPUSH
21906: CALL_OW 314
21910: NOT
21911: IFFALSE 21928
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21913: LD_VAR 0 3
21917: PPUSH
21918: LD_INT 80
21920: PPUSH
21921: LD_INT 67
21923: PPUSH
21924: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21928: LD_VAR 0 3
21932: PPUSH
21933: LD_INT 24
21935: PUSH
21936: LD_INT 1
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: PPUSH
21943: CALL_OW 72
21947: NOT
21948: IFFALSE 21894
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21950: LD_ADDR_VAR 0 3
21954: PUSH
21955: LD_INT 22
21957: PUSH
21958: LD_INT 4
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: LD_INT 92
21967: PUSH
21968: LD_INT 60
21970: PUSH
21971: LD_INT 93
21973: PUSH
21974: LD_INT 10
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 3
21985: PUSH
21986: LD_INT 54
21988: PUSH
21989: EMPTY
21990: LIST
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: PPUSH
22001: CALL_OW 69
22005: PUSH
22006: LD_EXP 58
22010: DIFF
22011: ST_TO_ADDR
// if tmp then
22012: LD_VAR 0 3
22016: IFFALSE 22050
// for i in tmp do
22018: LD_ADDR_VAR 0 1
22022: PUSH
22023: LD_VAR 0 3
22027: PUSH
22028: FOR_IN
22029: IFFALSE 22048
// ComMoveXY ( i , 36 , 67 ) ;
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_INT 36
22038: PPUSH
22039: LD_INT 67
22041: PPUSH
22042: CALL_OW 111
22046: GO 22028
22048: POP
22049: POP
// wait ( 0 0$3 ) ;
22050: LD_INT 105
22052: PPUSH
22053: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22057: LD_VAR 0 11
22061: PPUSH
22062: LD_STRING D6-Sol3-1
22064: PPUSH
22065: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22069: LD_EXP 58
22073: PPUSH
22074: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22078: LD_EXP 58
22082: PPUSH
22083: LD_STRING D6-Pow-1
22085: PPUSH
22086: CALL_OW 88
// tmp := [ ] ;
22090: LD_ADDR_VAR 0 3
22094: PUSH
22095: EMPTY
22096: ST_TO_ADDR
// for i = 1 to 2 do
22097: LD_ADDR_VAR 0 1
22101: PUSH
22102: DOUBLE
22103: LD_INT 1
22105: DEC
22106: ST_TO_ADDR
22107: LD_INT 2
22109: PUSH
22110: FOR_TO
22111: IFFALSE 22225
// begin uc_side := 8 ;
22113: LD_ADDR_OWVAR 20
22117: PUSH
22118: LD_INT 8
22120: ST_TO_ADDR
// uc_nation := 2 ;
22121: LD_ADDR_OWVAR 21
22125: PUSH
22126: LD_INT 2
22128: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22129: LD_INT 14
22131: PPUSH
22132: LD_INT 3
22134: PPUSH
22135: LD_INT 2
22137: PPUSH
22138: LD_INT 29
22140: PPUSH
22141: LD_INT 100
22143: PPUSH
22144: CALL 70780 0 5
// veh := CreateVehicle ;
22148: LD_ADDR_VAR 0 13
22152: PUSH
22153: CALL_OW 45
22157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22158: LD_VAR 0 13
22162: PPUSH
22163: LD_INT 4
22165: PPUSH
22166: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22170: LD_VAR 0 13
22174: PPUSH
22175: LD_INT 99
22177: PPUSH
22178: LD_INT 83
22180: PPUSH
22181: LD_INT 6
22183: PPUSH
22184: LD_INT 0
22186: PPUSH
22187: CALL_OW 50
// wait ( 3 ) ;
22191: LD_INT 3
22193: PPUSH
22194: CALL_OW 67
// Connect ( veh ) ;
22198: LD_VAR 0 13
22202: PPUSH
22203: CALL 73873 0 1
// tmp := tmp ^ veh ;
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_VAR 0 3
22216: PUSH
22217: LD_VAR 0 13
22221: ADD
22222: ST_TO_ADDR
// end ;
22223: GO 22110
22225: POP
22226: POP
// wait ( 0 0$1 ) ;
22227: LD_INT 35
22229: PPUSH
22230: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22234: LD_INT 99
22236: PPUSH
22237: LD_INT 83
22239: PPUSH
22240: LD_INT 1
22242: PPUSH
22243: LD_INT 10
22245: PPUSH
22246: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22250: LD_INT 99
22252: PPUSH
22253: LD_INT 83
22255: PPUSH
22256: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22260: LD_VAR 0 11
22264: PPUSH
22265: LD_STRING D6-Sol3-2
22267: PPUSH
22268: CALL_OW 88
// async ;
22272: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22273: LD_EXP 58
22277: PPUSH
22278: LD_STRING D6-Pow-2
22280: PPUSH
22281: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22285: LD_VAR 0 3
22289: PUSH
22290: LD_INT 1
22292: ARRAY
22293: PPUSH
22294: LD_VAR 0 9
22298: PPUSH
22299: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22303: LD_VAR 0 3
22307: PUSH
22308: LD_INT 2
22310: ARRAY
22311: PPUSH
22312: LD_INT 22
22314: PUSH
22315: LD_INT 4
22317: PUSH
22318: EMPTY
22319: LIST
22320: LIST
22321: PUSH
22322: LD_INT 21
22324: PUSH
22325: LD_INT 3
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: PPUSH
22336: CALL_OW 69
22340: PPUSH
22341: LD_VAR 0 3
22345: PUSH
22346: LD_INT 2
22348: ARRAY
22349: PPUSH
22350: CALL_OW 74
22354: PPUSH
22355: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22359: LD_EXP 58
22363: PPUSH
22364: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22368: LD_INT 99
22370: PPUSH
22371: LD_INT 83
22373: PPUSH
22374: LD_INT 1
22376: PPUSH
22377: CALL_OW 331
// repeat wait ( 4 ) ;
22381: LD_INT 4
22383: PPUSH
22384: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22388: LD_VAR 0 3
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PPUSH
22397: CALL_OW 256
22401: PUSH
22402: LD_INT 1000
22404: LESS
22405: IFFALSE 22423
// SetLives ( tmp [ 1 ] , 1000 ) ;
22407: LD_VAR 0 3
22411: PUSH
22412: LD_INT 1
22414: ARRAY
22415: PPUSH
22416: LD_INT 1000
22418: PPUSH
22419: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22423: LD_INT 22
22425: PUSH
22426: LD_INT 4
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: PUSH
22433: LD_INT 30
22435: PUSH
22436: LD_INT 3
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PPUSH
22447: CALL_OW 69
22451: PUSH
22452: LD_INT 0
22454: EQUAL
22455: IFFALSE 22381
// skirmish := false ;
22457: LD_ADDR_EXP 115
22461: PUSH
22462: LD_INT 0
22464: ST_TO_ADDR
// sync ;
22465: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22466: LD_EXP 58
22470: PPUSH
22471: LD_STRING D6a-Pow-1
22473: PPUSH
22474: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22478: LD_VAR 0 11
22482: PPUSH
22483: LD_STRING D6a-Sol3-1
22485: PPUSH
22486: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22490: LD_EXP 58
22494: PPUSH
22495: LD_STRING D6a-Pow-2
22497: PPUSH
22498: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22502: LD_VAR 0 11
22506: PPUSH
22507: LD_STRING D6a-Sol3-2
22509: PPUSH
22510: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22514: LD_EXP 58
22518: PPUSH
22519: LD_STRING D6a-Pow-3
22521: PPUSH
22522: CALL_OW 88
// powellCenterCameraMode := true ;
22526: LD_ADDR_EXP 20
22530: PUSH
22531: LD_INT 1
22533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22534: LD_ADDR_VAR 0 1
22538: PUSH
22539: LD_INT 22
22541: PUSH
22542: LD_INT 8
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: PUSH
22549: LD_INT 25
22551: PUSH
22552: LD_INT 2
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 69
22567: PUSH
22568: FOR_IN
22569: IFFALSE 22624
// begin SetTag ( i , 1 ) ;
22571: LD_VAR 0 1
22575: PPUSH
22576: LD_INT 1
22578: PPUSH
22579: CALL_OW 109
// ComExitBuilding ( i ) ;
22583: LD_VAR 0 1
22587: PPUSH
22588: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22592: LD_VAR 0 1
22596: PPUSH
22597: LD_INT 35
22599: PPUSH
22600: LD_INT 6
22602: PPUSH
22603: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: LD_INT 4
22617: PPUSH
22618: CALL_OW 171
// end ;
22622: GO 22568
22624: POP
22625: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22626: LD_ADDR_VAR 0 3
22630: PUSH
22631: LD_INT 22
22633: PUSH
22634: LD_INT 4
22636: PUSH
22637: EMPTY
22638: LIST
22639: LIST
22640: PUSH
22641: LD_INT 21
22643: PUSH
22644: LD_INT 2
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: LD_INT 3
22653: PUSH
22654: LD_INT 34
22656: PUSH
22657: LD_INT 12
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: LIST
22672: PPUSH
22673: CALL_OW 69
22677: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22678: LD_EXP 58
22682: PPUSH
22683: LD_VAR 0 3
22687: PPUSH
22688: LD_EXP 58
22692: PPUSH
22693: CALL_OW 74
22697: PPUSH
22698: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22702: LD_EXP 58
22706: PPUSH
22707: LD_INT 100
22709: PPUSH
22710: LD_INT 88
22712: PPUSH
22713: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_INT 100
22724: PPUSH
22725: LD_INT 75
22727: PPUSH
22728: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22732: LD_EXP 58
22736: PPUSH
22737: LD_INT 88
22739: PPUSH
22740: LD_INT 53
22742: PPUSH
22743: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22747: LD_INT 8
22749: PPUSH
22750: LD_EXP 58
22754: PPUSH
22755: CALL_OW 471
// repeat wait ( 3 ) ;
22759: LD_INT 3
22761: PPUSH
22762: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22766: LD_INT 22
22768: PUSH
22769: LD_INT 4
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 92
22778: PUSH
22779: LD_INT 100
22781: PUSH
22782: LD_INT 75
22784: PUSH
22785: LD_INT 6
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 69
22802: IFFALSE 22759
// async ;
22804: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: LD_STRING D6b-Pow-1
22812: PPUSH
22813: CALL_OW 88
// repeat wait ( 3 ) ;
22817: LD_INT 3
22819: PPUSH
22820: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22824: LD_EXP 58
22828: PPUSH
22829: CALL_OW 310
22833: PPUSH
22834: CALL_OW 256
22838: PUSH
22839: LD_INT 1000
22841: LESS
22842: IFFALSE 22861
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22844: LD_EXP 58
22848: PPUSH
22849: CALL_OW 310
22853: PPUSH
22854: LD_INT 1000
22856: PPUSH
22857: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22861: LD_EXP 58
22865: PPUSH
22866: CALL_OW 256
22870: PUSH
22871: LD_INT 1000
22873: LESS
22874: IFFALSE 22888
// SetLives ( Powell , 1000 ) ;
22876: LD_EXP 58
22880: PPUSH
22881: LD_INT 1000
22883: PPUSH
22884: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22888: LD_EXP 58
22892: PPUSH
22893: LD_EXP 63
22897: PPUSH
22898: CALL_OW 296
22902: PUSH
22903: LD_INT 5
22905: LESS
22906: PUSH
22907: LD_EXP 58
22911: PPUSH
22912: CALL_OW 310
22916: PPUSH
22917: LD_EXP 63
22921: PPUSH
22922: CALL_OW 296
22926: PUSH
22927: LD_INT 5
22929: LESS
22930: OR
22931: IFFALSE 22950
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22933: LD_EXP 58
22937: PPUSH
22938: CALL_OW 310
22942: PPUSH
22943: LD_INT 100
22945: PPUSH
22946: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22950: LD_EXP 58
22954: PPUSH
22955: CALL_OW 310
22959: NOT
22960: IFFALSE 22817
// DoNotAttack ( 8 , powellBomb ) ;
22962: LD_INT 8
22964: PPUSH
22965: LD_EXP 63
22969: PPUSH
22970: CALL_OW 471
// game_speed := 4 ;
22974: LD_ADDR_OWVAR 65
22978: PUSH
22979: LD_INT 4
22981: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22982: LD_EXP 58
22986: PPUSH
22987: LD_STRING D6b-Pow-1a
22989: PPUSH
22990: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22994: LD_EXP 58
22998: PPUSH
22999: LD_EXP 63
23003: PPUSH
23004: CALL_OW 180
// sync ;
23008: SYNC
// repeat wait ( 0 0$1 ) ;
23009: LD_INT 35
23011: PPUSH
23012: CALL_OW 67
// until IsInUnit ( Powell ) ;
23016: LD_EXP 58
23020: PPUSH
23021: CALL_OW 310
23025: IFFALSE 23009
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23027: LD_INT 8
23029: PPUSH
23030: LD_EXP 58
23034: PPUSH
23035: CALL_OW 310
23039: PPUSH
23040: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23044: LD_EXP 58
23048: PPUSH
23049: LD_INT 91
23051: PPUSH
23052: LD_INT 44
23054: PPUSH
23055: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23059: LD_EXP 58
23063: PPUSH
23064: LD_INT 96
23066: PPUSH
23067: LD_INT 44
23069: PPUSH
23070: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23074: LD_EXP 58
23078: PPUSH
23079: LD_INT 96
23081: PPUSH
23082: LD_INT 41
23084: PPUSH
23085: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23089: LD_EXP 58
23093: PPUSH
23094: LD_INT 92
23096: PPUSH
23097: LD_INT 39
23099: PPUSH
23100: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23104: LD_EXP 58
23108: PPUSH
23109: LD_INT 88
23111: PPUSH
23112: LD_INT 41
23114: PPUSH
23115: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23119: LD_EXP 58
23123: PPUSH
23124: LD_INT 91
23126: PPUSH
23127: LD_INT 44
23129: PPUSH
23130: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23134: LD_EXP 58
23138: PPUSH
23139: LD_INT 96
23141: PPUSH
23142: LD_INT 44
23144: PPUSH
23145: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23149: LD_EXP 58
23153: PPUSH
23154: LD_INT 96
23156: PPUSH
23157: LD_INT 41
23159: PPUSH
23160: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23164: LD_EXP 58
23168: PPUSH
23169: LD_INT 92
23171: PPUSH
23172: LD_INT 39
23174: PPUSH
23175: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23179: LD_EXP 58
23183: PPUSH
23184: LD_INT 88
23186: PPUSH
23187: LD_INT 41
23189: PPUSH
23190: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23194: LD_EXP 58
23198: PPUSH
23199: LD_INT 91
23201: PPUSH
23202: LD_INT 44
23204: PPUSH
23205: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23209: LD_EXP 58
23213: PPUSH
23214: LD_INT 93
23216: PPUSH
23217: LD_INT 39
23219: PPUSH
23220: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23224: LD_EXP 58
23228: PPUSH
23229: LD_INT 93
23231: PPUSH
23232: LD_INT 36
23234: PPUSH
23235: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23239: LD_INT 122
23241: PPUSH
23242: CALL_OW 67
// game_speed := 4 ;
23246: LD_ADDR_OWVAR 65
23250: PUSH
23251: LD_INT 4
23253: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23254: LD_EXP 58
23258: PPUSH
23259: LD_STRING D6b-Pow-1b
23261: PPUSH
23262: CALL_OW 88
// tmp := [ ] ;
23266: LD_ADDR_VAR 0 3
23270: PUSH
23271: EMPTY
23272: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23273: LD_ADDR_VAR 0 5
23277: PUSH
23278: LD_INT 78
23280: PUSH
23281: LD_INT 47
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 106
23290: PUSH
23291: LD_INT 53
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23302: LD_ADDR_VAR 0 1
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 8
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 21
23319: PUSH
23320: LD_INT 3
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PUSH
23327: LD_INT 92
23329: PUSH
23330: LD_INT 90
23332: PUSH
23333: LD_INT 52
23335: PUSH
23336: LD_INT 12
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: LIST
23349: PPUSH
23350: CALL_OW 69
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23381
// tmp := tmp ^ UnitsInside ( i ) ;
23358: LD_ADDR_VAR 0 3
23362: PUSH
23363: LD_VAR 0 3
23367: PUSH
23368: LD_VAR 0 1
23372: PPUSH
23373: CALL_OW 313
23377: ADD
23378: ST_TO_ADDR
23379: GO 23355
23381: POP
23382: POP
// for i in tmp do
23383: LD_ADDR_VAR 0 1
23387: PUSH
23388: LD_VAR 0 3
23392: PUSH
23393: FOR_IN
23394: IFFALSE 23556
// begin dist := 9999 ;
23396: LD_ADDR_VAR 0 8
23400: PUSH
23401: LD_INT 9999
23403: ST_TO_ADDR
// _xy := [ ] ;
23404: LD_ADDR_VAR 0 7
23408: PUSH
23409: EMPTY
23410: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23411: LD_VAR 0 1
23415: PPUSH
23416: LD_INT 1
23418: PPUSH
23419: CALL_OW 109
// ComExitBuilding ( i ) ;
23423: LD_VAR 0 1
23427: PPUSH
23428: CALL_OW 122
// for j in xy do
23432: LD_ADDR_VAR 0 2
23436: PUSH
23437: LD_VAR 0 5
23441: PUSH
23442: FOR_IN
23443: IFFALSE 23525
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23445: LD_VAR 0 1
23449: PPUSH
23450: LD_VAR 0 2
23454: PUSH
23455: LD_INT 1
23457: ARRAY
23458: PPUSH
23459: LD_VAR 0 2
23463: PUSH
23464: LD_INT 2
23466: ARRAY
23467: PPUSH
23468: CALL_OW 297
23472: PUSH
23473: LD_VAR 0 8
23477: LESS
23478: IFFALSE 23523
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23480: LD_ADDR_VAR 0 8
23484: PUSH
23485: LD_VAR 0 1
23489: PPUSH
23490: LD_VAR 0 2
23494: PUSH
23495: LD_INT 1
23497: ARRAY
23498: PPUSH
23499: LD_VAR 0 2
23503: PUSH
23504: LD_INT 2
23506: ARRAY
23507: PPUSH
23508: CALL_OW 297
23512: ST_TO_ADDR
// _xy := j ;
23513: LD_ADDR_VAR 0 7
23517: PUSH
23518: LD_VAR 0 2
23522: ST_TO_ADDR
// end ;
23523: GO 23442
23525: POP
23526: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23527: LD_VAR 0 1
23531: PPUSH
23532: LD_VAR 0 7
23536: PUSH
23537: LD_INT 1
23539: ARRAY
23540: PPUSH
23541: LD_VAR 0 7
23545: PUSH
23546: LD_INT 2
23548: ARRAY
23549: PPUSH
23550: CALL_OW 171
// end ;
23554: GO 23393
23556: POP
23557: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23558: LD_ADDR_VAR 0 4
23562: PUSH
23563: LD_VAR 0 3
23567: PPUSH
23568: LD_INT 26
23570: PUSH
23571: LD_INT 1
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 1
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PPUSH
23592: CALL_OW 72
23596: ST_TO_ADDR
// if tmp2 < 2 then
23597: LD_VAR 0 4
23601: PUSH
23602: LD_INT 2
23604: LESS
23605: IFFALSE 23674
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23607: LD_ADDR_VAR 0 4
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 8
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 26
23624: PUSH
23625: LD_INT 1
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 3
23634: PUSH
23635: LD_INT 25
23637: PUSH
23638: LD_INT 15
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: LIST
23653: PPUSH
23654: CALL_OW 69
23658: PUSH
23659: LD_EXP 60
23663: PUSH
23664: LD_EXP 61
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: DIFF
23673: ST_TO_ADDR
// if tmp2 then
23674: LD_VAR 0 4
23678: IFFALSE 23696
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23680: LD_VAR 0 4
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PPUSH
23689: LD_STRING D6b-ArSol1-1
23691: PPUSH
23692: CALL_OW 88
// async ;
23696: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23697: LD_EXP 58
23701: PPUSH
23702: LD_STRING D6b-Pow-2
23704: PPUSH
23705: CALL_OW 88
// wait ( 0 0$1 ) ;
23709: LD_INT 35
23711: PPUSH
23712: CALL_OW 67
// if tmp2 > 1 then
23716: LD_VAR 0 4
23720: PUSH
23721: LD_INT 1
23723: GREATER
23724: IFFALSE 23742
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23726: LD_VAR 0 4
23730: PUSH
23731: LD_INT 2
23733: ARRAY
23734: PPUSH
23735: LD_STRING D6b-ArSol2-1
23737: PPUSH
23738: CALL_OW 88
// sync ;
23742: SYNC
// repeat wait ( 5 ) ;
23743: LD_INT 5
23745: PPUSH
23746: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23750: LD_INT 93
23752: PPUSH
23753: LD_INT 36
23755: PPUSH
23756: CALL_OW 428
23760: PPUSH
23761: CALL_OW 255
23765: PUSH
23766: LD_INT 4
23768: EQUAL
23769: IFFALSE 23743
// DialogueOn ;
23771: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23775: LD_INT 10
23777: PPUSH
23778: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23782: LD_EXP 58
23786: PPUSH
23787: LD_STRING D6b-Pow-2a
23789: PPUSH
23790: CALL_OW 88
// DialogueOff ;
23794: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23798: LD_EXP 58
23802: PPUSH
23803: CALL_OW 310
23807: PPUSH
23808: LD_INT 332
23810: PPUSH
23811: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23815: LD_INT 93
23817: PPUSH
23818: LD_INT 35
23820: PPUSH
23821: LD_INT 1
23823: PPUSH
23824: LD_INT 6
23826: NEG
23827: PPUSH
23828: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23832: LD_INT 35
23834: PPUSH
23835: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23839: LD_INT 332
23841: PPUSH
23842: CALL_OW 256
23846: PUSH
23847: LD_INT 1000
23849: LESS
23850: PUSH
23851: LD_INT 332
23853: PPUSH
23854: CALL_OW 300
23858: AND
23859: IFFALSE 23871
// SetLives ( kozlov_fac , 0 ) ;
23861: LD_INT 332
23863: PPUSH
23864: LD_INT 0
23866: PPUSH
23867: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23871: LD_INT 332
23873: PPUSH
23874: CALL_OW 301
23878: PUSH
23879: LD_EXP 58
23883: PPUSH
23884: CALL_OW 301
23888: OR
23889: IFFALSE 23832
// game_speed := 4 ;
23891: LD_ADDR_OWVAR 65
23895: PUSH
23896: LD_INT 4
23898: ST_TO_ADDR
// powellCenterCameraMode := false ;
23899: LD_ADDR_EXP 20
23903: PUSH
23904: LD_INT 0
23906: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23907: LD_ADDR_VAR 0 1
23911: PUSH
23912: LD_VAR 0 3
23916: PUSH
23917: LD_INT 22
23919: PUSH
23920: LD_INT 8
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 25
23929: PUSH
23930: LD_INT 2
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PPUSH
23941: CALL_OW 69
23945: UNION
23946: PUSH
23947: FOR_IN
23948: IFFALSE 23964
// SetTag ( i , 0 ) ;
23950: LD_VAR 0 1
23954: PPUSH
23955: LD_INT 0
23957: PPUSH
23958: CALL_OW 109
23962: GO 23947
23964: POP
23965: POP
// wait ( 0 0$3 ) ;
23966: LD_INT 105
23968: PPUSH
23969: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23973: LD_INT 93
23975: PPUSH
23976: LD_INT 35
23978: PPUSH
23979: LD_INT 1
23981: PPUSH
23982: CALL_OW 331
// DialogueOn ;
23986: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23990: LD_VAR 0 11
23994: PPUSH
23995: LD_STRING D6c-Sol3-1
23997: PPUSH
23998: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24002: LD_INT 10
24004: PPUSH
24005: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24009: LD_EXP 39
24013: PPUSH
24014: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24018: LD_EXP 39
24022: PPUSH
24023: LD_STRING D6c-JMM-1
24025: PPUSH
24026: CALL_OW 88
// if Cyrus then
24030: LD_EXP 45
24034: IFFALSE 24048
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24036: LD_EXP 45
24040: PPUSH
24041: LD_STRING D6c-Cyrus-1
24043: PPUSH
24044: CALL_OW 88
// if Bobby then
24048: LD_EXP 44
24052: IFFALSE 24066
// Say ( Bobby , D6c-Bobby-1 ) ;
24054: LD_EXP 44
24058: PPUSH
24059: LD_STRING D6c-Bobby-1
24061: PPUSH
24062: CALL_OW 88
// if Cornel then
24066: LD_EXP 50
24070: IFFALSE 24084
// Say ( Cornel , D6c-Corn-1 ) ;
24072: LD_EXP 50
24076: PPUSH
24077: LD_STRING D6c-Corn-1
24079: PPUSH
24080: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24084: LD_ADDR_VAR 0 4
24088: PUSH
24089: LD_INT 2
24091: PUSH
24092: LD_INT 22
24094: PUSH
24095: LD_INT 1
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 22
24104: PUSH
24105: LD_INT 4
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: LIST
24116: PUSH
24117: LD_INT 26
24119: PUSH
24120: LD_INT 1
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 3
24129: PUSH
24130: LD_INT 25
24132: PUSH
24133: LD_INT 16
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 25
24142: PUSH
24143: LD_INT 12
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: LIST
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: PPUSH
24160: CALL_OW 69
24164: PUSH
24165: LD_VAR 0 11
24169: PUSH
24170: LD_EXP 39
24174: UNION
24175: PUSH
24176: LD_EXP 59
24180: UNION
24181: PUSH
24182: EMPTY
24183: LIST
24184: DIFF
24185: ST_TO_ADDR
// if tmp2 then
24186: LD_VAR 0 4
24190: IFFALSE 24208
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24192: LD_VAR 0 4
24196: PUSH
24197: LD_INT 1
24199: ARRAY
24200: PPUSH
24201: LD_STRING D6c-Sol1-1
24203: PPUSH
24204: CALL_OW 88
// if Lisa then
24208: LD_EXP 42
24212: IFFALSE 24226
// Say ( Lisa , D6c-Lisa-1 ) ;
24214: LD_EXP 42
24218: PPUSH
24219: LD_STRING D6c-Lisa-1
24221: PPUSH
24222: CALL_OW 88
// if Gary then
24226: LD_EXP 51
24230: IFFALSE 24244
// Say ( Gary , D6c-Gary-1 ) ;
24232: LD_EXP 51
24236: PPUSH
24237: LD_STRING D6c-Gary-1
24239: PPUSH
24240: CALL_OW 88
// if Donaldson then
24244: LD_EXP 43
24248: IFFALSE 24262
// Say ( Donaldson , D6c-Don-1 ) ;
24250: LD_EXP 43
24254: PPUSH
24255: LD_STRING D6c-Don-1
24257: PPUSH
24258: CALL_OW 88
// if tmp2 > 1 then
24262: LD_VAR 0 4
24266: PUSH
24267: LD_INT 1
24269: GREATER
24270: IFFALSE 24288
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24272: LD_VAR 0 4
24276: PUSH
24277: LD_INT 2
24279: ARRAY
24280: PPUSH
24281: LD_STRING D6c-Sol2-1
24283: PPUSH
24284: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24288: LD_VAR 0 11
24292: PPUSH
24293: LD_STRING D6c-Sol3-2
24295: PPUSH
24296: CALL_OW 88
// dwait ( 0 0$1 ) ;
24300: LD_INT 35
24302: PPUSH
24303: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24307: LD_EXP 39
24311: PPUSH
24312: LD_STRING D6c-JMM-2
24314: PPUSH
24315: CALL_OW 88
// DialogueOff ;
24319: CALL_OW 7
// Video ( false ) ;
24323: LD_INT 0
24325: PPUSH
24326: CALL 102569 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24330: LD_INT 22
24332: PUSH
24333: LD_INT 4
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PPUSH
24340: CALL_OW 69
24344: PPUSH
24345: LD_INT 1
24347: PPUSH
24348: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24352: LD_INT 4
24354: PPUSH
24355: LD_INT 4
24357: PPUSH
24358: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24362: LD_ADDR_VAR 0 1
24366: PUSH
24367: LD_INT 4
24369: PPUSH
24370: LD_INT 1
24372: PPUSH
24373: LD_INT 2
24375: PPUSH
24376: CALL 65979 0 3
24380: PUSH
24381: FOR_IN
24382: IFFALSE 24419
// if GetTech ( i , 1 ) <> state_researched then
24384: LD_VAR 0 1
24388: PPUSH
24389: LD_INT 1
24391: PPUSH
24392: CALL_OW 321
24396: PUSH
24397: LD_INT 2
24399: NONEQUAL
24400: IFFALSE 24417
// SetTech ( i , 1 , state_researched ) ;
24402: LD_VAR 0 1
24406: PPUSH
24407: LD_INT 1
24409: PPUSH
24410: LD_INT 2
24412: PPUSH
24413: CALL_OW 322
24417: GO 24381
24419: POP
24420: POP
// missionStage := 6 ;
24421: LD_ADDR_EXP 15
24425: PUSH
24426: LD_INT 6
24428: ST_TO_ADDR
// activeAttacks := true ;
24429: LD_ADDR_EXP 16
24433: PUSH
24434: LD_INT 1
24436: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24437: LD_STRING M2
24439: PPUSH
24440: CALL_OW 337
// SaveForQuickRestart ;
24444: CALL_OW 22
// wait ( 0 0$40 ) ;
24448: LD_INT 1400
24450: PPUSH
24451: CALL_OW 67
// DialogueOn ;
24455: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24459: LD_EXP 62
24463: PPUSH
24464: LD_STRING D7-Friend-1
24466: PPUSH
24467: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24471: LD_EXP 39
24475: PPUSH
24476: LD_STRING D7-JMM-1
24478: PPUSH
24479: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24483: LD_EXP 62
24487: PPUSH
24488: LD_STRING D7-Friend-2
24490: PPUSH
24491: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24495: LD_EXP 39
24499: PPUSH
24500: LD_STRING D7-JMM-2
24502: PPUSH
24503: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24507: LD_EXP 62
24511: PPUSH
24512: LD_STRING D7-Friend-3
24514: PPUSH
24515: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24519: LD_EXP 39
24523: PPUSH
24524: LD_STRING D7-JMM-3
24526: PPUSH
24527: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24531: LD_EXP 62
24535: PPUSH
24536: LD_STRING D7-Friend-4
24538: PPUSH
24539: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24543: LD_EXP 39
24547: PPUSH
24548: LD_STRING D7-JMM-4
24550: PPUSH
24551: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24555: LD_EXP 62
24559: PPUSH
24560: LD_STRING D7-Friend-5
24562: PPUSH
24563: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24567: LD_EXP 39
24571: PPUSH
24572: LD_STRING D7-JMM-5
24574: PPUSH
24575: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24579: LD_EXP 62
24583: PPUSH
24584: LD_STRING D7-Friend-6
24586: PPUSH
24587: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24591: LD_EXP 39
24595: PPUSH
24596: LD_STRING D7-JMM-6
24598: PPUSH
24599: CALL_OW 88
// DialogueOff ;
24603: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24607: LD_STRING Mlegion
24609: PPUSH
24610: CALL_OW 337
// skirmish := true ;
24614: LD_ADDR_EXP 115
24618: PUSH
24619: LD_INT 1
24621: ST_TO_ADDR
// RebuildKozlovFactory ;
24622: CALL 4892 0 0
// end ;
24626: PPOPN 13
24628: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24629: LD_EXP 20
24633: PUSH
24634: LD_EXP 58
24638: PPUSH
24639: CALL_OW 300
24643: AND
24644: IFFALSE 24686
24646: GO 24648
24648: DISABLE
// begin enable ;
24649: ENABLE
// if IsInUnit ( Powell ) then
24650: LD_EXP 58
24654: PPUSH
24655: CALL_OW 310
24659: IFFALSE 24677
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24661: LD_EXP 58
24665: PPUSH
24666: CALL_OW 310
24670: PPUSH
24671: CALL_OW 85
24675: GO 24686
// CenterOnUnits ( Powell ) ;
24677: LD_EXP 58
24681: PPUSH
24682: CALL_OW 85
// end ;
24686: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24687: LD_INT 22
24689: PUSH
24690: LD_INT 8
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 34
24699: PUSH
24700: LD_INT 48
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: PPUSH
24711: CALL_OW 69
24715: IFFALSE 24989
24717: GO 24719
24719: DISABLE
24720: LD_INT 0
24722: PPUSH
24723: PPUSH
// begin if missionStage < 9 then
24724: LD_EXP 15
24728: PUSH
24729: LD_INT 9
24731: LESS
24732: IFFALSE 24742
// missionStage := 9 ;
24734: LD_ADDR_EXP 15
24738: PUSH
24739: LD_INT 9
24741: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24742: LD_ADDR_VAR 0 1
24746: PUSH
24747: LD_INT 22
24749: PUSH
24750: LD_INT 8
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 34
24759: PUSH
24760: LD_INT 48
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PPUSH
24771: CALL_OW 69
24775: PUSH
24776: LD_INT 1
24778: ARRAY
24779: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24780: LD_INT 175
24782: PPUSH
24783: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24787: LD_EXP 12
24791: PUSH
24792: LD_EXP 3
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: LD_INT 2
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: IN
24807: OR
24808: IFFALSE 24831
// target := [ 68 , 108 , 1 ] else
24810: LD_ADDR_VAR 0 2
24814: PUSH
24815: LD_INT 68
24817: PUSH
24818: LD_INT 108
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: LIST
24828: ST_TO_ADDR
24829: GO 24850
// target := [ 181 , 88 , 2 ] ;
24831: LD_ADDR_VAR 0 2
24835: PUSH
24836: LD_INT 181
24838: PUSH
24839: LD_INT 88
24841: PUSH
24842: LD_INT 2
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: LIST
24849: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24850: LD_VAR 0 1
24854: PPUSH
24855: LD_VAR 0 2
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 2
24871: ARRAY
24872: PPUSH
24873: CALL_OW 176
// if target [ 3 ] = 1 then
24877: LD_VAR 0 2
24881: PUSH
24882: LD_INT 3
24884: ARRAY
24885: PUSH
24886: LD_INT 1
24888: EQUAL
24889: IFFALSE 24905
// SayRadio ( Kurt , D12-Kurt-1 ) else
24891: LD_EXP 60
24895: PPUSH
24896: LD_STRING D12-Kurt-1
24898: PPUSH
24899: CALL_OW 94
24903: GO 24929
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24905: LD_EXP 60
24909: PPUSH
24910: LD_STRING D12a-Kurt-1
24912: PPUSH
24913: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24917: LD_EXP 74
24921: PPUSH
24922: LD_STRING D12a-Roth-1
24924: PPUSH
24925: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24929: LD_INT 350
24931: PPUSH
24932: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24936: LD_VAR 0 1
24940: PPUSH
24941: LD_INT 22
24943: PUSH
24944: LD_INT 8
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PUSH
24951: LD_INT 23
24953: PUSH
24954: LD_INT 2
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: LD_INT 30
24963: PUSH
24964: LD_INT 3
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: LIST
24975: PPUSH
24976: CALL_OW 69
24980: PUSH
24981: LD_INT 1
24983: ARRAY
24984: PPUSH
24985: CALL_OW 228
// end ;
24989: PPOPN 2
24991: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24992: LD_EXP 60
24996: PPUSH
24997: CALL_OW 256
25001: PUSH
25002: LD_INT 999
25004: LESS
25005: PUSH
25006: LD_INT 22
25008: PUSH
25009: LD_INT 8
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: PUSH
25016: LD_INT 21
25018: PUSH
25019: LD_INT 1
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 23
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 9
25048: PUSH
25049: LD_INT 8
25051: PUSH
25052: LD_INT 7
25054: PUSH
25055: LD_INT 6
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: PUSH
25064: LD_OWVAR 67
25068: ARRAY
25069: LESSEQUAL
25070: OR
25071: PUSH
25072: LD_INT 22
25074: PUSH
25075: LD_INT 8
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 34
25084: PUSH
25085: LD_INT 48
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PPUSH
25096: CALL_OW 69
25100: NOT
25101: AND
25102: PUSH
25103: LD_EXP 60
25107: PPUSH
25108: CALL_OW 302
25112: AND
25113: PUSH
25114: LD_INT 5
25116: PPUSH
25117: LD_INT 22
25119: PUSH
25120: LD_INT 1
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PPUSH
25127: CALL_OW 70
25131: AND
25132: IFFALSE 25845
25134: GO 25136
25136: DISABLE
25137: LD_INT 0
25139: PPUSH
25140: PPUSH
25141: PPUSH
// begin legionDestroyed := true ;
25142: LD_ADDR_EXP 22
25146: PUSH
25147: LD_INT 1
25149: ST_TO_ADDR
// DialogueOn ;
25150: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25154: LD_EXP 39
25158: PPUSH
25159: LD_STRING D13-JMM-1
25161: PPUSH
25162: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25166: LD_EXP 60
25170: PPUSH
25171: LD_STRING D13-Kurt-1
25173: PPUSH
25174: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25178: LD_EXP 39
25182: PPUSH
25183: LD_STRING D13-JMM-2
25185: PPUSH
25186: CALL_OW 88
// if FakeInfo then
25190: LD_EXP 12
25194: IFFALSE 25214
// begin Say ( Kurt , D13-Kurt-2 ) ;
25196: LD_EXP 60
25200: PPUSH
25201: LD_STRING D13-Kurt-2
25203: PPUSH
25204: CALL_OW 88
// DialogueOff ;
25208: CALL_OW 7
// exit ;
25212: GO 25845
// end ; if not KurtStatus then
25214: LD_EXP 3
25218: NOT
25219: IFFALSE 25235
// Say ( Kurt , D13-Kurt-2b ) else
25221: LD_EXP 60
25225: PPUSH
25226: LD_STRING D13-Kurt-2b
25228: PPUSH
25229: CALL_OW 88
25233: GO 25247
// Say ( Kurt , D13-Kurt-2a ) ;
25235: LD_EXP 60
25239: PPUSH
25240: LD_STRING D13-Kurt-2a
25242: PPUSH
25243: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25247: LD_EXP 39
25251: PPUSH
25252: LD_STRING D13-JMM-3
25254: PPUSH
25255: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25259: LD_EXP 60
25263: PPUSH
25264: LD_STRING D13-Kurt-3
25266: PPUSH
25267: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25271: LD_EXP 39
25275: PPUSH
25276: LD_STRING D13-JMM-4
25278: PPUSH
25279: CALL_OW 88
// DialogueOff ;
25283: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25287: LD_STRING MlegionOut
25289: PPUSH
25290: CALL_OW 337
// MC_Kill ( 3 ) ;
25294: LD_INT 3
25296: PPUSH
25297: CALL 35532 0 1
// KillUnit ( Kozlov ) ;
25301: LD_EXP 61
25305: PPUSH
25306: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25310: LD_ADDR_VAR 0 1
25314: PUSH
25315: LD_INT 22
25317: PUSH
25318: LD_INT 8
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: PUSH
25325: LD_INT 23
25327: PUSH
25328: LD_INT 3
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 3
25337: PUSH
25338: LD_INT 21
25340: PUSH
25341: LD_INT 33
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: PPUSH
25357: CALL_OW 69
25361: PUSH
25362: FOR_IN
25363: IFFALSE 25376
// KillUnit ( i ) ;
25365: LD_VAR 0 1
25369: PPUSH
25370: CALL_OW 66
25374: GO 25362
25376: POP
25377: POP
// ChangeSideFog ( 8 , 1 ) ;
25378: LD_INT 8
25380: PPUSH
25381: LD_INT 1
25383: PPUSH
25384: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25388: LD_ADDR_VAR 0 2
25392: PUSH
25393: LD_INT 22
25395: PUSH
25396: LD_INT 8
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 21
25405: PUSH
25406: LD_INT 1
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PPUSH
25417: CALL_OW 69
25421: PUSH
25422: LD_EXP 61
25426: PUSH
25427: LD_EXP 60
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: DIFF
25436: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25437: LD_VAR 0 2
25441: PUSH
25442: LD_INT 6
25444: PUSH
25445: LD_INT 5
25447: PUSH
25448: LD_INT 4
25450: PUSH
25451: LD_INT 3
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: PUSH
25460: LD_OWVAR 67
25464: ARRAY
25465: GREATEREQUAL
25466: IFFALSE 25644
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25468: LD_ADDR_VAR 0 3
25472: PUSH
25473: LD_INT 6
25475: PUSH
25476: LD_INT 5
25478: PUSH
25479: LD_INT 4
25481: PUSH
25482: LD_INT 3
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: PUSH
25491: LD_OWVAR 67
25495: ARRAY
25496: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25497: LD_ADDR_VAR 0 1
25501: PUSH
25502: DOUBLE
25503: LD_VAR 0 2
25507: PUSH
25508: LD_VAR 0 3
25512: PUSH
25513: LD_INT 1
25515: PLUS
25516: MINUS
25517: INC
25518: ST_TO_ADDR
25519: LD_INT 1
25521: PUSH
25522: FOR_DOWNTO
25523: IFFALSE 25640
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25525: LD_ADDR_EXP 38
25529: PUSH
25530: LD_EXP 38
25534: PUSH
25535: LD_VAR 0 2
25539: PUSH
25540: LD_VAR 0 1
25544: ARRAY
25545: ADD
25546: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitBuilding ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 122
// if IsInUnit ( i ) then
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL_OW 310
25588: IFFALSE 25605
// ComExitVehicle ( tmp [ i ] ) ;
25590: LD_VAR 0 2
25594: PUSH
25595: LD_VAR 0 1
25599: ARRAY
25600: PPUSH
25601: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25605: LD_VAR 0 2
25609: PUSH
25610: LD_VAR 0 1
25614: ARRAY
25615: PPUSH
25616: LD_INT 34
25618: PUSH
25619: LD_INT 0
25621: PPUSH
25622: LD_INT 6
25624: PPUSH
25625: CALL_OW 12
25629: PLUS
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 171
// end ;
25638: GO 25522
25640: POP
25641: POP
// end else
25642: GO 25654
// x := tmp ;
25644: LD_ADDR_VAR 0 3
25648: PUSH
25649: LD_VAR 0 2
25653: ST_TO_ADDR
// for i := tmp downto tmp - x do
25654: LD_ADDR_VAR 0 1
25658: PUSH
25659: DOUBLE
25660: LD_VAR 0 2
25664: INC
25665: ST_TO_ADDR
25666: LD_VAR 0 2
25670: PUSH
25671: LD_VAR 0 3
25675: MINUS
25676: PUSH
25677: FOR_DOWNTO
25678: IFFALSE 25732
// begin if IsInUnit ( tmp [ i ] ) then
25680: LD_VAR 0 2
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: CALL_OW 310
25695: IFFALSE 25712
// ComExitVehicle ( tmp [ i ] ) ;
25697: LD_VAR 0 2
25701: PUSH
25702: LD_VAR 0 1
25706: ARRAY
25707: PPUSH
25708: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25712: LD_VAR 0 2
25716: PUSH
25717: LD_VAR 0 1
25721: ARRAY
25722: PPUSH
25723: LD_INT 1
25725: PPUSH
25726: CALL_OW 235
// end ;
25730: GO 25677
25732: POP
25733: POP
// SetSide ( Kurt , 1 ) ;
25734: LD_EXP 60
25738: PPUSH
25739: LD_INT 1
25741: PPUSH
25742: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 3
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PPUSH
25775: LD_INT 1
25777: PPUSH
25778: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25782: LD_INT 8
25784: PPUSH
25785: LD_INT 1
25787: PPUSH
25788: LD_INT 1
25790: PPUSH
25791: LD_INT 1
25793: PPUSH
25794: CALL_OW 80
// wait ( 1 1$20 ) ;
25798: LD_INT 2800
25800: PPUSH
25801: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25805: LD_EXP 62
25809: PPUSH
25810: LD_INT 37
25812: PPUSH
25813: LD_INT 1
25815: PPUSH
25816: LD_INT 0
25818: PPUSH
25819: CALL_OW 48
// wait ( 0 0$1 ) ;
25823: LD_INT 35
25825: PPUSH
25826: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25830: LD_EXP 62
25834: PPUSH
25835: LD_INT 60
25837: PPUSH
25838: LD_INT 95
25840: PPUSH
25841: CALL_OW 111
// end ;
25845: PPOPN 3
25847: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25848: LD_EXP 22
25852: NOT
25853: PUSH
25854: LD_INT 22
25856: PUSH
25857: LD_INT 8
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 21
25866: PUSH
25867: LD_INT 1
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 69
25882: PUSH
25883: LD_INT 0
25885: EQUAL
25886: AND
25887: IFFALSE 25907
25889: GO 25891
25891: DISABLE
// begin legionDestroyed := true ;
25892: LD_ADDR_EXP 22
25896: PUSH
25897: LD_INT 1
25899: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25900: LD_STRING MlegionOut
25902: PPUSH
25903: CALL_OW 337
// end ;
25907: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25908: LD_EXP 38
25912: IFFALSE 25987
25914: GO 25916
25916: DISABLE
25917: LD_INT 0
25919: PPUSH
// begin enable ;
25920: ENABLE
// for i in legionEscapeUnits do
25921: LD_ADDR_VAR 0 1
25925: PUSH
25926: LD_EXP 38
25930: PUSH
25931: FOR_IN
25932: IFFALSE 25985
// begin if IsInArea ( i , legionEscapeArea ) then
25934: LD_VAR 0 1
25938: PPUSH
25939: LD_INT 31
25941: PPUSH
25942: CALL_OW 308
25946: IFFALSE 25959
// RemoveUnit ( i ) else
25948: LD_VAR 0 1
25952: PPUSH
25953: CALL_OW 64
25957: GO 25983
// if not HasTask ( i ) then
25959: LD_VAR 0 1
25963: PPUSH
25964: CALL_OW 314
25968: NOT
25969: IFFALSE 25983
// ComMoveToArea ( i , legionEscapeArea ) ;
25971: LD_VAR 0 1
25975: PPUSH
25976: LD_INT 31
25978: PPUSH
25979: CALL_OW 113
// end ;
25983: GO 25931
25985: POP
25986: POP
// end ;
25987: PPOPN 1
25989: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25990: LD_INT 1
25992: PPUSH
25993: LD_EXP 62
25997: PPUSH
25998: CALL_OW 292
26002: IFFALSE 26300
26004: GO 26006
26006: DISABLE
26007: LD_INT 0
26009: PPUSH
// begin wait ( 0 0$2 ) ;
26010: LD_INT 70
26012: PPUSH
26013: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26017: LD_EXP 62
26021: PPUSH
26022: CALL_OW 87
// DialogueOn ;
26026: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26030: LD_EXP 39
26034: PPUSH
26035: LD_STRING D14-JMM-1
26037: PPUSH
26038: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26042: LD_EXP 62
26046: PPUSH
26047: LD_STRING D14-Friend-1
26049: PPUSH
26050: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26054: LD_EXP 39
26058: PPUSH
26059: LD_STRING D14-JMM-2
26061: PPUSH
26062: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26066: LD_EXP 62
26070: PPUSH
26071: LD_STRING D14-Friend-2
26073: PPUSH
26074: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26078: LD_EXP 39
26082: PPUSH
26083: LD_STRING D14-JMM-3
26085: PPUSH
26086: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_STRING D14-Friend-3
26097: PPUSH
26098: CALL_OW 88
// DialogueOff ;
26102: CALL_OW 7
// dec = Query ( Q14 ) ;
26106: LD_ADDR_VAR 0 1
26110: PUSH
26111: LD_STRING Q14
26113: PPUSH
26114: CALL_OW 97
26118: ST_TO_ADDR
// if dec = 1 then
26119: LD_VAR 0 1
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26161
// begin DialogueOn ;
26129: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26133: LD_EXP 39
26137: PPUSH
26138: LD_STRING D14a-JMM-1
26140: PPUSH
26141: CALL_OW 88
// DialogueOff ;
26145: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26149: LD_EXP 62
26153: PPUSH
26154: LD_INT 1
26156: PPUSH
26157: CALL_OW 235
// end ; if dec = 2 then
26161: LD_VAR 0 1
26165: PUSH
26166: LD_INT 2
26168: EQUAL
26169: IFFALSE 26222
// begin DialogueOn ;
26171: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26175: LD_EXP 39
26179: PPUSH
26180: LD_STRING D14b-JMM-1
26182: PPUSH
26183: CALL_OW 88
// DialogueOff ;
26187: CALL_OW 7
// wait ( 0 0$1 ) ;
26191: LD_INT 35
26193: PPUSH
26194: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26198: LD_EXP 62
26202: PPUSH
26203: LD_INT 9
26205: PPUSH
26206: LD_INT 2
26208: PPUSH
26209: CALL_OW 111
// AddComHold ( Friend ) ;
26213: LD_EXP 62
26217: PPUSH
26218: CALL_OW 200
// end ; if dec = 3 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 3
26229: EQUAL
26230: IFFALSE 26300
// begin DialogueOn ;
26232: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26236: LD_EXP 39
26240: PPUSH
26241: LD_STRING D14c-JMM-1
26243: PPUSH
26244: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26248: LD_EXP 62
26252: PPUSH
26253: LD_STRING D14c-Friend-1
26255: PPUSH
26256: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26260: LD_EXP 39
26264: PPUSH
26265: LD_STRING D14c-JMM-2
26267: PPUSH
26268: CALL_OW 88
// DialogueOff ;
26272: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26276: LD_EXP 62
26280: PPUSH
26281: LD_INT 9
26283: PPUSH
26284: LD_INT 2
26286: PPUSH
26287: CALL_OW 111
// AddComHold ( Friend ) ;
26291: LD_EXP 62
26295: PPUSH
26296: CALL_OW 200
// end ; end ;
26300: PPOPN 1
26302: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26303: LD_INT 9
26305: PPUSH
26306: LD_INT 2
26308: PPUSH
26309: CALL_OW 428
26313: PUSH
26314: LD_EXP 62
26318: EQUAL
26319: PUSH
26320: LD_EXP 62
26324: PPUSH
26325: CALL_OW 255
26329: PUSH
26330: LD_INT 8
26332: EQUAL
26333: AND
26334: IFFALSE 26348
26336: GO 26338
26338: DISABLE
// RemoveUnit ( Friend ) ;
26339: LD_EXP 62
26343: PPUSH
26344: CALL_OW 64
26348: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26349: LD_EXP 14
26353: PUSH
26354: LD_INT 31500
26356: GREATEREQUAL
26357: PUSH
26358: LD_EXP 7
26362: AND
26363: PUSH
26364: LD_EXP 2
26368: AND
26369: IFFALSE 26799
26371: GO 26373
26373: DISABLE
26374: LD_INT 0
26376: PPUSH
26377: PPUSH
26378: PPUSH
// begin missionStage := 7 ;
26379: LD_ADDR_EXP 15
26383: PUSH
26384: LD_INT 7
26386: ST_TO_ADDR
// uc_side = 1 ;
26387: LD_ADDR_OWVAR 20
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// uc_nation = 1 ;
26395: LD_ADDR_OWVAR 21
26399: PUSH
26400: LD_INT 1
26402: ST_TO_ADDR
// for i = 1 to 5 do
26403: LD_ADDR_VAR 0 1
26407: PUSH
26408: DOUBLE
26409: LD_INT 1
26411: DEC
26412: ST_TO_ADDR
26413: LD_INT 5
26415: PUSH
26416: FOR_TO
26417: IFFALSE 26513
// begin vc_engine = 3 ;
26419: LD_ADDR_OWVAR 39
26423: PUSH
26424: LD_INT 3
26426: ST_TO_ADDR
// vc_control = 3 ;
26427: LD_ADDR_OWVAR 38
26431: PUSH
26432: LD_INT 3
26434: ST_TO_ADDR
// vc_chassis = 3 ;
26435: LD_ADDR_OWVAR 37
26439: PUSH
26440: LD_INT 3
26442: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26443: LD_ADDR_OWVAR 40
26447: PUSH
26448: LD_INT 5
26450: PUSH
26451: LD_INT 9
26453: PUSH
26454: LD_INT 7
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PPUSH
26465: LD_INT 3
26467: PPUSH
26468: CALL_OW 12
26472: ARRAY
26473: ST_TO_ADDR
// veh = CreateVehicle ;
26474: LD_ADDR_VAR 0 2
26478: PUSH
26479: CALL_OW 45
26483: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26484: LD_VAR 0 2
26488: PPUSH
26489: LD_INT 1
26491: PPUSH
26492: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26496: LD_VAR 0 2
26500: PPUSH
26501: LD_INT 19
26503: PPUSH
26504: LD_INT 0
26506: PPUSH
26507: CALL_OW 49
// end ;
26511: GO 26416
26513: POP
26514: POP
// vc_engine = 3 ;
26515: LD_ADDR_OWVAR 39
26519: PUSH
26520: LD_INT 3
26522: ST_TO_ADDR
// vc_control = 1 ;
26523: LD_ADDR_OWVAR 38
26527: PUSH
26528: LD_INT 1
26530: ST_TO_ADDR
// vc_chassis = 3 ;
26531: LD_ADDR_OWVAR 37
26535: PUSH
26536: LD_INT 3
26538: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26539: LD_ADDR_OWVAR 40
26543: PUSH
26544: LD_INT 5
26546: PUSH
26547: LD_INT 9
26549: PUSH
26550: LD_INT 7
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PPUSH
26561: LD_INT 3
26563: PPUSH
26564: CALL_OW 12
26568: ARRAY
26569: ST_TO_ADDR
// vehG = CreateVehicle ;
26570: LD_ADDR_VAR 0 3
26574: PUSH
26575: CALL_OW 45
26579: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26580: LD_VAR 0 3
26584: PPUSH
26585: LD_INT 1
26587: PPUSH
26588: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26592: LD_VAR 0 3
26596: PPUSH
26597: LD_INT 19
26599: PPUSH
26600: LD_INT 0
26602: PPUSH
26603: CALL_OW 49
// if JMMGirl = 1 then
26607: LD_EXP 7
26611: PUSH
26612: LD_INT 1
26614: EQUAL
26615: IFFALSE 26671
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26617: LD_ADDR_EXP 40
26621: PUSH
26622: LD_STRING Joan
26624: PPUSH
26625: LD_INT 1
26627: PPUSH
26628: LD_STRING 14_
26630: PPUSH
26631: CALL 65916 0 3
26635: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26636: LD_EXP 40
26640: PPUSH
26641: LD_VAR 0 3
26645: PPUSH
26646: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26650: LD_VAR 0 3
26654: PPUSH
26655: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26659: LD_EXP 40
26663: PPUSH
26664: LD_STRING D10BW-Joan-1
26666: PPUSH
26667: CALL_OW 94
// end ; if JMMGirl = 2 then
26671: LD_EXP 7
26675: PUSH
26676: LD_INT 2
26678: EQUAL
26679: IFFALSE 26735
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26681: LD_ADDR_EXP 42
26685: PUSH
26686: LD_STRING Lisa
26688: PPUSH
26689: LD_INT 1
26691: PPUSH
26692: LD_STRING 14_
26694: PPUSH
26695: CALL 65916 0 3
26699: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26700: LD_EXP 42
26704: PPUSH
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26714: LD_VAR 0 3
26718: PPUSH
26719: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26723: LD_EXP 42
26727: PPUSH
26728: LD_STRING D10BW-Lisa-1
26730: PPUSH
26731: CALL_OW 94
// end ; if JMMGirl = 3 then
26735: LD_EXP 7
26739: PUSH
26740: LD_INT 3
26742: EQUAL
26743: IFFALSE 26799
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26745: LD_ADDR_EXP 54
26749: PUSH
26750: LD_STRING Connie
26752: PPUSH
26753: LD_INT 1
26755: PPUSH
26756: LD_STRING 14_
26758: PPUSH
26759: CALL 65916 0 3
26763: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26764: LD_EXP 54
26768: PPUSH
26769: LD_VAR 0 3
26773: PPUSH
26774: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26787: LD_EXP 54
26791: PPUSH
26792: LD_STRING D10BW-Con-1
26794: PPUSH
26795: CALL_OW 94
// end ; end ;
26799: PPOPN 3
26801: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26802: LD_EXP 14
26806: PUSH
26807: LD_INT 94500
26809: GREATEREQUAL
26810: IFFALSE 27222
26812: GO 26814
26814: DISABLE
26815: LD_INT 0
26817: PPUSH
26818: PPUSH
26819: PPUSH
// begin tmp := PrepareStevensSquad ;
26820: LD_ADDR_VAR 0 3
26824: PUSH
26825: CALL 2226 0 0
26829: ST_TO_ADDR
// if not tmp then
26830: LD_VAR 0 3
26834: NOT
26835: IFFALSE 26839
// exit ;
26837: GO 27222
// uc_side := 1 ;
26839: LD_ADDR_OWVAR 20
26843: PUSH
26844: LD_INT 1
26846: ST_TO_ADDR
// uc_nation := 1 ;
26847: LD_ADDR_OWVAR 21
26851: PUSH
26852: LD_INT 1
26854: ST_TO_ADDR
// for i in tmp do
26855: LD_ADDR_VAR 0 1
26859: PUSH
26860: LD_VAR 0 3
26864: PUSH
26865: FOR_IN
26866: IFFALSE 26963
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26868: LD_INT 3
26870: PPUSH
26871: LD_INT 3
26873: PPUSH
26874: LD_INT 1
26876: PPUSH
26877: LD_INT 5
26879: PUSH
26880: LD_INT 9
26882: PUSH
26883: LD_INT 7
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 1
26893: PPUSH
26894: LD_INT 3
26896: PPUSH
26897: CALL_OW 12
26901: ARRAY
26902: PPUSH
26903: LD_INT 40
26905: PPUSH
26906: CALL 70780 0 5
// veh := CreateVehicle ;
26910: LD_ADDR_VAR 0 2
26914: PUSH
26915: CALL_OW 45
26919: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_INT 1
26927: PPUSH
26928: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26932: LD_VAR 0 2
26936: PPUSH
26937: LD_INT 19
26939: PPUSH
26940: LD_INT 0
26942: PPUSH
26943: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26947: LD_VAR 0 1
26951: PPUSH
26952: LD_VAR 0 2
26956: PPUSH
26957: CALL_OW 52
// end ;
26961: GO 26865
26963: POP
26964: POP
// missionStage := 8 ;
26965: LD_ADDR_EXP 15
26969: PUSH
26970: LD_INT 8
26972: ST_TO_ADDR
// DialogueOn ;
26973: CALL_OW 6
// if Stevens then
26977: LD_EXP 41
26981: IFFALSE 27095
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26983: LD_EXP 41
26987: PPUSH
26988: CALL_OW 310
26992: PPUSH
26993: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26997: LD_EXP 41
27001: PPUSH
27002: LD_STRING D8-Huck-1
27004: PPUSH
27005: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27009: LD_EXP 39
27013: PPUSH
27014: LD_STRING D8-JMM-1
27016: PPUSH
27017: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27021: LD_EXP 41
27025: PPUSH
27026: LD_STRING D8-Huck-2
27028: PPUSH
27029: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27033: LD_EXP 39
27037: PPUSH
27038: LD_STRING D8-JMM-2
27040: PPUSH
27041: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27045: LD_EXP 41
27049: PPUSH
27050: LD_STRING D8-Huck-3
27052: PPUSH
27053: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27057: LD_EXP 39
27061: PPUSH
27062: LD_STRING D8-JMM-3
27064: PPUSH
27065: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27069: LD_EXP 41
27073: PPUSH
27074: LD_STRING D8-Huck-4
27076: PPUSH
27077: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27081: LD_EXP 39
27085: PPUSH
27086: LD_STRING D8-JMM-4
27088: PPUSH
27089: CALL_OW 88
// end else
27093: GO 27205
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27095: LD_EXP 55
27099: PPUSH
27100: CALL_OW 310
27104: PPUSH
27105: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27109: LD_EXP 55
27113: PPUSH
27114: LD_STRING D8-Huck-1
27116: PPUSH
27117: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27121: LD_EXP 39
27125: PPUSH
27126: LD_STRING D8-JMM-1a
27128: PPUSH
27129: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27133: LD_EXP 55
27137: PPUSH
27138: LD_STRING D8-Huck-2
27140: PPUSH
27141: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27145: LD_EXP 39
27149: PPUSH
27150: LD_STRING D8-JMM-2
27152: PPUSH
27153: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27157: LD_EXP 55
27161: PPUSH
27162: LD_STRING D8-Huck-3
27164: PPUSH
27165: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27169: LD_EXP 39
27173: PPUSH
27174: LD_STRING D8-JMM-3
27176: PPUSH
27177: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27181: LD_EXP 55
27185: PPUSH
27186: LD_STRING D8-Huck-4
27188: PPUSH
27189: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27193: LD_EXP 39
27197: PPUSH
27198: LD_STRING D8-JMM-4
27200: PPUSH
27201: CALL_OW 88
// end ; DialogueOff ;
27205: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27209: LD_INT 25
27211: PPUSH
27212: LD_INT 1
27214: PPUSH
27215: LD_INT 1
27217: PPUSH
27218: CALL_OW 322
// end ;
27222: PPOPN 3
27224: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27225: LD_INT 1
27227: PPUSH
27228: LD_EXP 71
27232: PPUSH
27233: CALL_OW 292
27237: IFFALSE 27488
27239: GO 27241
27241: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27242: LD_EXP 71
27246: PPUSH
27247: CALL_OW 87
// DialogueOn ;
27251: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27255: LD_EXP 39
27259: PPUSH
27260: LD_STRING D10nB-JMM-1
27262: PPUSH
27263: CALL_OW 88
// if BurlakStatus = 1 then
27267: LD_EXP 9
27271: PUSH
27272: LD_INT 1
27274: EQUAL
27275: IFFALSE 27289
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27277: LD_EXP 70
27281: PPUSH
27282: LD_STRING D10nB-Vse-1a
27284: PPUSH
27285: CALL_OW 94
// end ; if BurlakStatus = 0 then
27289: LD_EXP 9
27293: PUSH
27294: LD_INT 0
27296: EQUAL
27297: IFFALSE 27311
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27299: LD_EXP 70
27303: PPUSH
27304: LD_STRING D10nB-Vse-1
27306: PPUSH
27307: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27311: LD_EXP 39
27315: PPUSH
27316: LD_STRING D10nB-JMM-2
27318: PPUSH
27319: CALL_OW 88
// if KappaStatus then
27323: LD_EXP 2
27327: IFFALSE 27341
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27329: LD_EXP 70
27333: PPUSH
27334: LD_STRING D10nB-Vse-5a
27336: PPUSH
27337: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27341: LD_EXP 2
27345: NOT
27346: PUSH
27347: LD_EXP 6
27351: PUSH
27352: LD_INT 0
27354: EQUAL
27355: AND
27356: IFFALSE 27484
// begin if JMMGirl = 1 then
27358: LD_EXP 7
27362: PUSH
27363: LD_INT 1
27365: EQUAL
27366: IFFALSE 27416
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27368: LD_EXP 70
27372: PPUSH
27373: LD_STRING D10nB-Vse-2
27375: PPUSH
27376: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27380: LD_EXP 39
27384: PPUSH
27385: LD_STRING D10nB-JMM-3
27387: PPUSH
27388: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27392: LD_EXP 70
27396: PPUSH
27397: LD_STRING D10nB-Vse-3
27399: PPUSH
27400: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27404: LD_EXP 39
27408: PPUSH
27409: LD_STRING D10nB-JMM-4
27411: PPUSH
27412: CALL_OW 88
// end ; if JMMGirl = 2 then
27416: LD_EXP 7
27420: PUSH
27421: LD_INT 2
27423: EQUAL
27424: IFFALSE 27450
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27426: LD_EXP 70
27430: PPUSH
27431: LD_STRING D10nB-Vse-4
27433: PPUSH
27434: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27438: LD_EXP 39
27442: PPUSH
27443: LD_STRING D10nB-JMM-5
27445: PPUSH
27446: CALL_OW 88
// end ; if JMMGirl = 3 then
27450: LD_EXP 7
27454: PUSH
27455: LD_INT 3
27457: EQUAL
27458: IFFALSE 27484
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27460: LD_EXP 70
27464: PPUSH
27465: LD_STRING D10nB-Vse-5
27467: PPUSH
27468: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27472: LD_EXP 39
27476: PPUSH
27477: LD_STRING D10nB-JMM-6
27479: PPUSH
27480: CALL_OW 88
// end ; end ; DialogueOff ;
27484: CALL_OW 7
// end ;
27488: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27489: LD_EXP 14
27493: PUSH
27494: LD_INT 115500
27496: GREATEREQUAL
27497: IFFALSE 27873
27499: GO 27501
27501: DISABLE
27502: LD_INT 0
27504: PPUSH
// begin missionStage := 10 ;
27505: LD_ADDR_EXP 15
27509: PUSH
27510: LD_INT 10
27512: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27513: LD_ADDR_VAR 0 1
27517: PUSH
27518: LD_INT 22
27520: PUSH
27521: LD_INT 1
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 23
27530: PUSH
27531: LD_INT 1
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 26
27540: PUSH
27541: LD_INT 1
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 3
27550: PUSH
27551: LD_INT 25
27553: PUSH
27554: LD_INT 12
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 3
27567: PUSH
27568: LD_INT 25
27570: PUSH
27571: LD_INT 16
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: PPUSH
27589: CALL_OW 69
27593: PUSH
27594: LD_EXP 39
27598: PUSH
27599: LD_EXP 60
27603: PUSH
27604: LD_EXP 41
27608: PUSH
27609: LD_EXP 55
27613: PUSH
27614: LD_EXP 42
27618: PUSH
27619: LD_EXP 43
27623: PUSH
27624: LD_EXP 44
27628: PUSH
27629: LD_EXP 45
27633: PUSH
27634: LD_EXP 46
27638: PUSH
27639: LD_EXP 47
27643: PUSH
27644: LD_EXP 48
27648: PUSH
27649: LD_EXP 49
27653: PUSH
27654: LD_EXP 50
27658: PUSH
27659: LD_EXP 51
27663: PUSH
27664: LD_EXP 52
27668: PUSH
27669: LD_EXP 53
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: DIFF
27692: ST_TO_ADDR
// if not tmp and Brown then
27693: LD_VAR 0 1
27697: NOT
27698: PUSH
27699: LD_EXP 47
27703: AND
27704: IFFALSE 27719
// tmp := [ Brown ] ;
27706: LD_ADDR_VAR 0 1
27710: PUSH
27711: LD_EXP 47
27715: PUSH
27716: EMPTY
27717: LIST
27718: ST_TO_ADDR
// DialogueOn ;
27719: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27723: LD_VAR 0 1
27727: PUSH
27728: LD_INT 1
27730: ARRAY
27731: PPUSH
27732: LD_STRING D11-Sol1-1
27734: PPUSH
27735: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27739: LD_EXP 64
27743: PPUSH
27744: LD_STRING D11-Pla-1
27746: PPUSH
27747: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27751: LD_EXP 65
27755: PPUSH
27756: LD_STRING D11-Kov-1
27758: PPUSH
27759: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27763: LD_EXP 64
27767: PPUSH
27768: LD_STRING D11-Pla-2
27770: PPUSH
27771: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27775: LD_VAR 0 1
27779: PUSH
27780: LD_INT 1
27782: ARRAY
27783: PPUSH
27784: LD_STRING D11-Sol1-2
27786: PPUSH
27787: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27791: LD_EXP 39
27795: PPUSH
27796: LD_STRING D11-JMM-2
27798: PPUSH
27799: CALL_OW 88
// DialogueOff ;
27803: CALL_OW 7
// allowBehemothConstruct := true ;
27807: LD_ADDR_EXP 25
27811: PUSH
27812: LD_INT 1
27814: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27815: LD_STRING M4
27817: PPUSH
27818: CALL_OW 337
// BuildBehemoths ;
27822: CALL 7741 0 0
// repeat wait ( 15 15$00 ) ;
27826: LD_INT 31500
27828: PPUSH
27829: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27833: LD_EXP 27
27837: IFFALSE 27841
// break ;
27839: GO 27873
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27841: LD_INT 267
27843: PPUSH
27844: CALL_OW 274
27848: PPUSH
27849: LD_INT 1
27851: PPUSH
27852: CALL_OW 275
27856: PUSH
27857: LD_INT 1000
27859: GREATEREQUAL
27860: IFFALSE 27866
// BuildBehemoths ;
27862: CALL 7741 0 0
// until not behemothBuilders ;
27866: LD_EXP 73
27870: NOT
27871: IFFALSE 27826
// end ;
27873: PPOPN 1
27875: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27876: LD_EXP 73
27880: NOT
27881: PUSH
27882: LD_EXP 28
27886: NOT
27887: AND
27888: PUSH
27889: LD_EXP 25
27893: AND
27894: IFFALSE 27914
27896: GO 27898
27898: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27899: LD_STRING M4a
27901: PPUSH
27902: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27906: LD_ADDR_EXP 27
27910: PUSH
27911: LD_INT 1
27913: ST_TO_ADDR
// end ;
27914: END
// every 0 0$1 trigger behemothDone do
27915: LD_EXP 28
27919: IFFALSE 27931
27921: GO 27923
27923: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27924: LD_STRING M4b
27926: PPUSH
27927: CALL_OW 337
27931: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27932: LD_EXP 29
27936: NOT
27937: IFFALSE 28133
27939: GO 27941
27941: DISABLE
27942: LD_INT 0
27944: PPUSH
27945: PPUSH
// begin enable ;
27946: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27947: LD_ADDR_VAR 0 1
27951: PUSH
27952: LD_INT 3
27954: PPUSH
27955: CALL 102658 0 1
27959: ST_TO_ADDR
// if not tmp and not behemothDone then
27960: LD_VAR 0 1
27964: NOT
27965: PUSH
27966: LD_EXP 28
27970: NOT
27971: AND
27972: IFFALSE 28008
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27974: LD_ADDR_VAR 0 1
27978: PUSH
27979: LD_INT 22
27981: PUSH
27982: LD_INT 3
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 30
27991: PUSH
27992: LD_INT 37
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PPUSH
28003: CALL_OW 69
28007: ST_TO_ADDR
// if not tmp then
28008: LD_VAR 0 1
28012: NOT
28013: IFFALSE 28017
// exit ;
28015: GO 28133
// for i in tmp do
28017: LD_ADDR_VAR 0 2
28021: PUSH
28022: LD_VAR 0 1
28026: PUSH
28027: FOR_IN
28028: IFFALSE 28131
// if See ( 1 , i ) then
28030: LD_INT 1
28032: PPUSH
28033: LD_VAR 0 2
28037: PPUSH
28038: CALL_OW 292
28042: IFFALSE 28129
// begin if GetType ( i ) = unit_building then
28044: LD_VAR 0 2
28048: PPUSH
28049: CALL_OW 247
28053: PUSH
28054: LD_INT 3
28056: EQUAL
28057: IFFALSE 28095
// begin CenterNowOnUnits ( i ) ;
28059: LD_VAR 0 2
28063: PPUSH
28064: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28068: LD_EXP 39
28072: PPUSH
28073: LD_STRING D17a-JMM-1
28075: PPUSH
28076: CALL_OW 88
// seeBehemoth := true ;
28080: LD_ADDR_EXP 29
28084: PUSH
28085: LD_INT 1
28087: ST_TO_ADDR
// disable ;
28088: DISABLE
// exit ;
28089: POP
28090: POP
28091: GO 28133
// end else
28093: GO 28129
// begin CenterNowOnUnits ( i ) ;
28095: LD_VAR 0 2
28099: PPUSH
28100: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28104: LD_EXP 39
28108: PPUSH
28109: LD_STRING D17b-JMM-1
28111: PPUSH
28112: CALL_OW 88
// seeBehemoth := true ;
28116: LD_ADDR_EXP 29
28120: PUSH
28121: LD_INT 1
28123: ST_TO_ADDR
// disable ;
28124: DISABLE
// exit ;
28125: POP
28126: POP
28127: GO 28133
// end ; end ;
28129: GO 28027
28131: POP
28132: POP
// end ;
28133: PPOPN 2
28135: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28136: LD_EXP 14
28140: PUSH
28141: LD_INT 123200
28143: GREATEREQUAL
28144: IFFALSE 29320
28146: GO 28148
28148: DISABLE
28149: LD_INT 0
28151: PPUSH
28152: PPUSH
28153: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28154: LD_INT 2
28156: PPUSH
28157: LD_INT 23
28159: PUSH
28160: LD_INT 3
28162: PUSH
28163: LD_INT 3
28165: PUSH
28166: LD_INT 48
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: PUSH
28175: EMPTY
28176: LIST
28177: PPUSH
28178: CALL 59510 0 2
// repeat wait ( 0 0$1 ) ;
28182: LD_INT 35
28184: PPUSH
28185: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28189: LD_INT 22
28191: PUSH
28192: LD_INT 3
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 48
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: IFFALSE 28182
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28219: LD_ADDR_VAR 0 1
28223: PUSH
28224: LD_INT 22
28226: PUSH
28227: LD_INT 3
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 34
28236: PUSH
28237: LD_INT 48
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PPUSH
28248: CALL_OW 69
28252: PUSH
28253: LD_INT 1
28255: ARRAY
28256: ST_TO_ADDR
// missionStage := 12 ;
28257: LD_ADDR_EXP 15
28261: PUSH
28262: LD_INT 12
28264: ST_TO_ADDR
// platonovHasBomb := true ;
28265: LD_ADDR_EXP 30
28269: PUSH
28270: LD_INT 1
28272: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28273: LD_VAR 0 1
28277: PPUSH
28278: LD_INT 181
28280: PPUSH
28281: LD_INT 86
28283: PPUSH
28284: CALL_OW 171
// AddComHold ( bomb ) ;
28288: LD_VAR 0 1
28292: PPUSH
28293: CALL_OW 200
// wait ( 0 0$10 ) ;
28297: LD_INT 350
28299: PPUSH
28300: CALL_OW 67
// DialogueOn ;
28304: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28308: LD_EXP 64
28312: PPUSH
28313: LD_STRING D15-Pla-1
28315: PPUSH
28316: CALL_OW 94
// dec = Query ( Q15a ) ;
28320: LD_ADDR_VAR 0 2
28324: PUSH
28325: LD_STRING Q15a
28327: PPUSH
28328: CALL_OW 97
28332: ST_TO_ADDR
// if dec = 1 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 1
28340: EQUAL
28341: IFFALSE 28364
// begin Say ( JMM , D15a-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15a-JMM-1
28350: PPUSH
28351: CALL_OW 88
// YouLost ( Surrender ) ;
28355: LD_STRING Surrender
28357: PPUSH
28358: CALL_OW 104
// exit ;
28362: GO 29320
// end ; if dec = 2 then
28364: LD_VAR 0 2
28368: PUSH
28369: LD_INT 2
28371: EQUAL
28372: IFFALSE 28441
// begin Say ( JMM , D15b-JMM-1 ) ;
28374: LD_EXP 39
28378: PPUSH
28379: LD_STRING D15b-JMM-1
28381: PPUSH
28382: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28386: LD_EXP 64
28390: PPUSH
28391: LD_STRING D15b-Pla-1
28393: PPUSH
28394: CALL_OW 94
// DialogueOff ;
28398: CALL_OW 7
// wait ( 3 3$00 ) ;
28402: LD_INT 6300
28404: PPUSH
28405: CALL_OW 67
// DialogueOn ;
28409: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28413: LD_EXP 39
28417: PPUSH
28418: LD_STRING D15d-JMM-1a
28420: PPUSH
28421: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28425: LD_EXP 64
28429: PPUSH
28430: LD_STRING D15d-Pla-1
28432: PPUSH
28433: CALL_OW 94
// DialogueOff ;
28437: CALL_OW 7
// end ; if dec = 3 then
28441: LD_VAR 0 2
28445: PUSH
28446: LD_INT 3
28448: EQUAL
28449: IFFALSE 28503
// begin Say ( JMM , D15c-JMM-1 ) ;
28451: LD_EXP 39
28455: PPUSH
28456: LD_STRING D15c-JMM-1
28458: PPUSH
28459: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28463: LD_EXP 64
28467: PPUSH
28468: LD_STRING D15c-Pla-1
28470: PPUSH
28471: CALL_OW 94
// DialogueOff ;
28475: CALL_OW 7
// wait ( 0 0$15 ) ;
28479: LD_INT 525
28481: PPUSH
28482: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28486: LD_VAR 0 1
28490: PPUSH
28491: LD_INT 60
28493: PPUSH
28494: LD_INT 95
28496: PPUSH
28497: CALL_OW 116
// exit ;
28501: GO 29320
// end ; if dec = 4 then
28503: LD_VAR 0 2
28507: PUSH
28508: LD_INT 4
28510: EQUAL
28511: IFFALSE 28541
// begin Say ( JMM , D15d-JMM-1 ) ;
28513: LD_EXP 39
28517: PPUSH
28518: LD_STRING D15d-JMM-1
28520: PPUSH
28521: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28525: LD_EXP 64
28529: PPUSH
28530: LD_STRING D15d-Pla-1
28532: PPUSH
28533: CALL_OW 94
// DialogueOff ;
28537: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28541: LD_EXP 62
28545: PPUSH
28546: CALL_OW 302
28550: PUSH
28551: LD_EXP 62
28555: PPUSH
28556: CALL_OW 255
28560: PUSH
28561: LD_INT 1
28563: EQUAL
28564: AND
28565: PUSH
28566: LD_INT 22
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 34
28578: PUSH
28579: LD_INT 8
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PPUSH
28590: CALL_OW 69
28594: NOT
28595: AND
28596: IFFALSE 29221
// begin SetSide ( Friend , 8 ) ;
28598: LD_EXP 62
28602: PPUSH
28603: LD_INT 8
28605: PPUSH
28606: CALL_OW 235
// if IsInUnit ( Friend ) then
28610: LD_EXP 62
28614: PPUSH
28615: CALL_OW 310
28619: IFFALSE 28630
// ComExitBuilding ( Friend ) ;
28621: LD_EXP 62
28625: PPUSH
28626: CALL_OW 122
// if IsDriver ( Friend ) then
28630: LD_EXP 62
28634: PPUSH
28635: CALL 100206 0 1
28639: IFFALSE 28650
// ComExitVehicle ( Friend ) ;
28641: LD_EXP 62
28645: PPUSH
28646: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28650: LD_EXP 62
28654: PPUSH
28655: LD_INT 9
28657: PPUSH
28658: LD_INT 2
28660: PPUSH
28661: CALL_OW 171
// wait ( 0 0$05 ) ;
28665: LD_INT 175
28667: PPUSH
28668: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28672: LD_EXP 62
28676: PPUSH
28677: CALL_OW 87
// DialogueOn ;
28681: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28685: LD_EXP 39
28689: PPUSH
28690: LD_STRING D16-JMM-1
28692: PPUSH
28693: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28697: LD_EXP 62
28701: PPUSH
28702: LD_STRING D16-Friend-1
28704: PPUSH
28705: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28709: LD_EXP 39
28713: PPUSH
28714: LD_STRING D16-JMM-2
28716: PPUSH
28717: CALL_OW 88
// DialogueOff ;
28721: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28725: LD_EXP 62
28729: PPUSH
28730: LD_INT 1
28732: PPUSH
28733: CALL_OW 235
// ComHold ( Friend ) ;
28737: LD_EXP 62
28741: PPUSH
28742: CALL_OW 140
// wait ( 0 0$20 ) ;
28746: LD_INT 700
28748: PPUSH
28749: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28753: LD_EXP 62
28757: PPUSH
28758: LD_INT 9
28760: PPUSH
28761: LD_INT 2
28763: PPUSH
28764: CALL_OW 297
28768: PUSH
28769: LD_INT 30
28771: LESS
28772: IFFALSE 28841
// begin SetSide ( Friend , 8 ) ;
28774: LD_EXP 62
28778: PPUSH
28779: LD_INT 8
28781: PPUSH
28782: CALL_OW 235
// if IsInUnit ( Friend ) then
28786: LD_EXP 62
28790: PPUSH
28791: CALL_OW 310
28795: IFFALSE 28806
// ComExitBuilding ( Friend ) ;
28797: LD_EXP 62
28801: PPUSH
28802: CALL_OW 122
// if IsDriver ( Friend ) then
28806: LD_EXP 62
28810: PPUSH
28811: CALL 100206 0 1
28815: IFFALSE 28826
// ComExitVehicle ( Friend ) ;
28817: LD_EXP 62
28821: PPUSH
28822: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28826: LD_EXP 62
28830: PPUSH
28831: LD_INT 9
28833: PPUSH
28834: LD_INT 2
28836: PPUSH
28837: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28841: LD_INT 1050
28843: PPUSH
28844: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28848: LD_INT 22
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: PUSH
28858: LD_INT 34
28860: PUSH
28861: LD_INT 8
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PPUSH
28872: CALL_OW 69
28876: NOT
28877: IFFALSE 29199
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28879: LD_ADDR_VAR 0 3
28883: PUSH
28884: LD_INT 22
28886: PUSH
28887: LD_INT 1
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 26
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 3
28906: PUSH
28907: LD_INT 25
28909: PUSH
28910: LD_INT 12
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 25
28919: PUSH
28920: LD_INT 16
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: LIST
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 69
28941: PUSH
28942: LD_EXP 39
28946: PUSH
28947: LD_EXP 41
28951: PUSH
28952: LD_EXP 55
28956: PUSH
28957: LD_EXP 42
28961: PUSH
28962: LD_EXP 43
28966: PUSH
28967: LD_EXP 44
28971: PUSH
28972: LD_EXP 45
28976: PUSH
28977: LD_EXP 46
28981: PUSH
28982: LD_EXP 47
28986: PUSH
28987: LD_EXP 48
28991: PUSH
28992: LD_EXP 49
28996: PUSH
28997: LD_EXP 50
29001: PUSH
29002: LD_EXP 51
29006: PUSH
29007: LD_EXP 52
29011: PUSH
29012: LD_EXP 53
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: DIFF
29034: ST_TO_ADDR
// DialogueOn ;
29035: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29039: LD_EXP 64
29043: PPUSH
29044: LD_STRING D16a-Pla-1
29046: PPUSH
29047: CALL_OW 94
// if Stevens then
29051: LD_EXP 41
29055: IFFALSE 29071
// Say ( Stevens , D16a-Huck-1 ) else
29057: LD_EXP 41
29061: PPUSH
29062: LD_STRING D16a-Huck-1
29064: PPUSH
29065: CALL_OW 88
29069: GO 29113
// if Baker then
29071: LD_EXP 55
29075: IFFALSE 29091
// Say ( Baker , D16a-Huck-1 ) else
29077: LD_EXP 55
29081: PPUSH
29082: LD_STRING D16a-Huck-1
29084: PPUSH
29085: CALL_OW 88
29089: GO 29113
// if tmp then
29091: LD_VAR 0 3
29095: IFFALSE 29113
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29097: LD_VAR 0 3
29101: PUSH
29102: LD_INT 1
29104: ARRAY
29105: PPUSH
29106: LD_STRING D16a-Sol1-1
29108: PPUSH
29109: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29113: LD_EXP 62
29117: PPUSH
29118: CALL_OW 255
29122: PUSH
29123: LD_INT 8
29125: EQUAL
29126: IFFALSE 29142
// Say ( JMM , D16a-JMM-1 ) else
29128: LD_EXP 39
29132: PPUSH
29133: LD_STRING D16a-JMM-1
29135: PPUSH
29136: CALL_OW 88
29140: GO 29178
// begin Say ( JMM , D16a-JMM-1a ) ;
29142: LD_EXP 39
29146: PPUSH
29147: LD_STRING D16a-JMM-1a
29149: PPUSH
29150: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29154: LD_EXP 62
29158: PPUSH
29159: LD_STRING D16a-Friend-1
29161: PPUSH
29162: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29166: LD_EXP 62
29170: PPUSH
29171: LD_INT 3
29173: PPUSH
29174: CALL_OW 235
// end ; DialogueOff ;
29178: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29182: LD_VAR 0 1
29186: PPUSH
29187: LD_INT 60
29189: PPUSH
29190: LD_INT 95
29192: PPUSH
29193: CALL_OW 116
// end else
29197: GO 29219
// begin DialogueOn ;
29199: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29203: LD_EXP 64
29207: PPUSH
29208: LD_STRING D16c-Pla-
29210: PPUSH
29211: CALL_OW 94
// DialogueOff ;
29215: CALL_OW 7
// end ; end else
29219: GO 29320
// begin wait ( 3 3$00 ) ;
29221: LD_INT 6300
29223: PPUSH
29224: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29228: LD_INT 22
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 34
29240: PUSH
29241: LD_INT 8
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 69
29256: NOT
29257: IFFALSE 29300
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29259: LD_EXP 64
29263: PPUSH
29264: LD_STRING D16b-Pla-1
29266: PPUSH
29267: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29271: LD_EXP 39
29275: PPUSH
29276: LD_STRING D16b-JMM-
29278: PPUSH
29279: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: LD_INT 60
29290: PPUSH
29291: LD_INT 95
29293: PPUSH
29294: CALL_OW 116
// end else
29298: GO 29320
// begin DialogueOn ;
29300: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29304: LD_EXP 64
29308: PPUSH
29309: LD_STRING D16c-Pla-
29311: PPUSH
29312: CALL_OW 94
// DialogueOff ;
29316: CALL_OW 7
// end ; end ; end ;
29320: PPOPN 3
29322: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29323: LD_EXP 14
29327: PUSH
29328: LD_INT 126000
29330: GREATEREQUAL
29331: PUSH
29332: LD_EXP 23
29336: NOT
29337: AND
29338: PUSH
29339: LD_EXP 74
29343: PPUSH
29344: CALL_OW 302
29348: AND
29349: IFFALSE 29707
29351: GO 29353
29353: DISABLE
29354: LD_INT 0
29356: PPUSH
// begin missionStage = 11 ;
29357: LD_ADDR_EXP 15
29361: PUSH
29362: LD_INT 11
29364: ST_TO_ADDR
// DialogueOn ;
29365: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29369: LD_EXP 74
29373: PPUSH
29374: LD_STRING D9-Roth-1
29376: PPUSH
29377: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29381: LD_EXP 39
29385: PPUSH
29386: LD_STRING D9-JMM-1
29388: PPUSH
29389: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29393: LD_EXP 74
29397: PPUSH
29398: LD_STRING D9-Roth-2
29400: PPUSH
29401: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29405: LD_EXP 74
29409: PPUSH
29410: LD_STRING D9-Roth-2a
29412: PPUSH
29413: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29417: LD_EXP 64
29421: PPUSH
29422: LD_STRING D9-Pla-2
29424: PPUSH
29425: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29429: LD_EXP 74
29433: PPUSH
29434: LD_STRING D9-Roth-3
29436: PPUSH
29437: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29441: LD_EXP 64
29445: PPUSH
29446: LD_STRING D9-Pla-3
29448: PPUSH
29449: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29453: LD_EXP 74
29457: PPUSH
29458: LD_STRING D9-Roth-4
29460: PPUSH
29461: CALL_OW 94
// dec = Query ( Q9 ) ;
29465: LD_ADDR_VAR 0 1
29469: PUSH
29470: LD_STRING Q9
29472: PPUSH
29473: CALL_OW 97
29477: ST_TO_ADDR
// if dec = 1 then
29478: LD_VAR 0 1
29482: PUSH
29483: LD_INT 1
29485: EQUAL
29486: IFFALSE 29500
// SayRadio ( Roth , D9a-Roth-1 ) ;
29488: LD_EXP 74
29492: PPUSH
29493: LD_STRING D9a-Roth-1
29495: PPUSH
29496: CALL_OW 94
// if dec = 2 then
29500: LD_VAR 0 1
29504: PUSH
29505: LD_INT 2
29507: EQUAL
29508: IFFALSE 29534
// begin Say ( JMM , D9b-JMM-1 ) ;
29510: LD_EXP 39
29514: PPUSH
29515: LD_STRING D9b-JMM-1
29517: PPUSH
29518: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29522: LD_EXP 74
29526: PPUSH
29527: LD_STRING D9b-Roth-1
29529: PPUSH
29530: CALL_OW 94
// end ; if dec = 3 then
29534: LD_VAR 0 1
29538: PUSH
29539: LD_INT 3
29541: EQUAL
29542: IFFALSE 29604
// begin Say ( JMM , D9c-JMM-1 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9c-JMM-1
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9c-Roth-1
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9c-JMM-2
29575: PPUSH
29576: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29580: LD_EXP 74
29584: PPUSH
29585: LD_STRING D9c-Roth-2
29587: PPUSH
29588: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29592: LD_EXP 39
29596: PPUSH
29597: LD_STRING D9c-JMM-3
29599: PPUSH
29600: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29604: LD_EXP 74
29608: PPUSH
29609: LD_STRING D9c-Roth-3
29611: PPUSH
29612: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29616: LD_EXP 74
29620: PPUSH
29621: LD_STRING D9cont-Roth-1
29623: PPUSH
29624: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29628: LD_EXP 39
29632: PPUSH
29633: LD_STRING D9cont-JMM-1
29635: PPUSH
29636: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29640: LD_EXP 74
29644: PPUSH
29645: LD_STRING D9cont-Roth-2
29647: PPUSH
29648: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29652: LD_EXP 39
29656: PPUSH
29657: LD_STRING D9cont-JMM-2
29659: PPUSH
29660: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29664: LD_EXP 74
29668: PPUSH
29669: LD_STRING D9cont-Roth-3
29671: PPUSH
29672: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29676: LD_EXP 39
29680: PPUSH
29681: LD_STRING D9cont-JMM-3
29683: PPUSH
29684: CALL_OW 88
// DialogueOff ;
29688: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29692: LD_STRING M3
29694: PPUSH
29695: CALL_OW 337
// allianceActive := true ;
29699: LD_ADDR_EXP 31
29703: PUSH
29704: LD_INT 1
29706: ST_TO_ADDR
// end ;
29707: PPOPN 1
29709: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29710: LD_INT 1
29712: PPUSH
29713: LD_INT 126
29715: PPUSH
29716: CALL_OW 292
29720: PUSH
29721: LD_EXP 64
29725: PPUSH
29726: CALL_OW 310
29730: AND
29731: IFFALSE 29811
29733: GO 29735
29735: DISABLE
29736: LD_INT 0
29738: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29739: LD_EXP 64
29743: PPUSH
29744: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29748: LD_ADDR_VAR 0 1
29752: PUSH
29753: LD_INT 4
29755: PPUSH
29756: LD_INT 22
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PPUSH
29766: CALL_OW 70
29770: PPUSH
29771: LD_EXP 64
29775: PPUSH
29776: CALL_OW 74
29780: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29781: LD_EXP 64
29785: PPUSH
29786: LD_VAR 0 1
29790: PUSH
29791: LD_INT 1
29793: ARRAY
29794: PPUSH
29795: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29799: LD_EXP 64
29803: PPUSH
29804: LD_STRING D18-Pla-1
29806: PPUSH
29807: CALL_OW 88
// end ;
29811: PPOPN 1
29813: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29814: LD_EXP 64
29818: PPUSH
29819: CALL_OW 301
29823: PUSH
29824: LD_EXP 67
29828: PPUSH
29829: CALL_OW 301
29833: AND
29834: PUSH
29835: LD_INT 22
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 21
29847: PUSH
29848: LD_INT 1
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 50
29857: PUSH
29858: EMPTY
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: LIST
29865: PPUSH
29866: CALL_OW 69
29870: PUSH
29871: LD_INT 7
29873: PUSH
29874: LD_INT 8
29876: PUSH
29877: LD_INT 9
29879: PUSH
29880: LD_INT 10
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: PUSH
29889: LD_OWVAR 67
29893: ARRAY
29894: LESS
29895: AND
29896: IFFALSE 30667
29898: GO 29900
29900: DISABLE
29901: LD_INT 0
29903: PPUSH
29904: PPUSH
29905: PPUSH
29906: PPUSH
// begin MC_Kill ( 2 ) ;
29907: LD_INT 2
29909: PPUSH
29910: CALL 35532 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 3
29919: PPUSH
29920: LD_INT 1
29922: PPUSH
29923: LD_INT 1
29925: PPUSH
29926: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29930: LD_ADDR_VAR 0 1
29934: PUSH
29935: LD_INT 22
29937: PUSH
29938: LD_INT 3
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 21
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 24
29957: PUSH
29958: LD_INT 900
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: LIST
29969: PPUSH
29970: CALL_OW 69
29974: PUSH
29975: FOR_IN
29976: IFFALSE 30007
// if GetSex ( i ) = sex_male then
29978: LD_VAR 0 1
29982: PPUSH
29983: CALL_OW 258
29987: PUSH
29988: LD_INT 1
29990: EQUAL
29991: IFFALSE 30005
// begin tmp = i ;
29993: LD_ADDR_VAR 0 2
29997: PUSH
29998: LD_VAR 0 1
30002: ST_TO_ADDR
// break ;
30003: GO 30007
// end ;
30005: GO 29975
30007: POP
30008: POP
// if tmp = 0 then
30009: LD_VAR 0 2
30013: PUSH
30014: LD_INT 0
30016: EQUAL
30017: IFFALSE 30071
// begin uc_side = 3 ;
30019: LD_ADDR_OWVAR 20
30023: PUSH
30024: LD_INT 3
30026: ST_TO_ADDR
// uc_nation = 3 ;
30027: LD_ADDR_OWVAR 21
30031: PUSH
30032: LD_INT 3
30034: ST_TO_ADDR
// hc_name =  ;
30035: LD_ADDR_OWVAR 26
30039: PUSH
30040: LD_STRING 
30042: ST_TO_ADDR
// hc_gallery =  ;
30043: LD_ADDR_OWVAR 33
30047: PUSH
30048: LD_STRING 
30050: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30051: LD_INT 1
30053: PPUSH
30054: LD_INT 10
30056: PPUSH
30057: CALL_OW 381
// tmp = CreateHuman ;
30061: LD_ADDR_VAR 0 2
30065: PUSH
30066: CALL_OW 44
30070: ST_TO_ADDR
// end ; DialogueOn ;
30071: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30075: LD_VAR 0 2
30079: PPUSH
30080: LD_STRING DSurrenderRussians-RSol1-1a
30082: PPUSH
30083: CALL_OW 94
// DialogueOff ;
30087: CALL_OW 7
// russianDestroyed := true ;
30091: LD_ADDR_EXP 21
30095: PUSH
30096: LD_INT 1
30098: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30099: LD_INT 22
30101: PUSH
30102: LD_INT 3
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 21
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PPUSH
30123: CALL_OW 69
30127: PPUSH
30128: CALL_OW 122
// wait ( 0 0$1 ) ;
30132: LD_INT 35
30134: PPUSH
30135: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30139: LD_INT 22
30141: PUSH
30142: LD_INT 3
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 21
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PPUSH
30163: CALL_OW 69
30167: PPUSH
30168: LD_INT 25
30170: PPUSH
30171: CALL_OW 173
// wait ( 0 0$10 ) ;
30175: LD_INT 350
30177: PPUSH
30178: CALL_OW 67
// PrepareOmarInvasion ;
30182: CALL 13983 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30186: LD_ADDR_VAR 0 2
30190: PUSH
30191: LD_EXP 92
30195: PPUSH
30196: CALL_OW 250
30200: PUSH
30201: LD_EXP 92
30205: PPUSH
30206: CALL_OW 251
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30215: LD_VAR 0 2
30219: PUSH
30220: LD_INT 1
30222: ARRAY
30223: PPUSH
30224: LD_VAR 0 2
30228: PUSH
30229: LD_INT 2
30231: ARRAY
30232: PPUSH
30233: LD_INT 1
30235: PPUSH
30236: LD_INT 8
30238: NEG
30239: PPUSH
30240: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30244: LD_EXP 92
30248: PPUSH
30249: CALL_OW 87
// DialogueOn ;
30253: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30257: LD_EXP 39
30261: PPUSH
30262: LD_STRING D19-JMM-1
30264: PPUSH
30265: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30269: LD_ADDR_VAR 0 3
30273: PUSH
30274: LD_INT 22
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 26
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 2
30296: PUSH
30297: LD_INT 25
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 25
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 25
30319: PUSH
30320: LD_INT 3
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 25
30329: PUSH
30330: LD_INT 4
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 25
30339: PUSH
30340: LD_INT 5
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 25
30349: PUSH
30350: LD_INT 8
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: LIST
30370: PPUSH
30371: CALL_OW 69
30375: PUSH
30376: LD_EXP 39
30380: PUSH
30381: LD_EXP 40
30385: PUSH
30386: LD_EXP 41
30390: PUSH
30391: LD_EXP 42
30395: PUSH
30396: LD_EXP 43
30400: PUSH
30401: LD_EXP 44
30405: PUSH
30406: LD_EXP 45
30410: PUSH
30411: LD_EXP 46
30415: PUSH
30416: LD_EXP 47
30420: PUSH
30421: LD_EXP 48
30425: PUSH
30426: LD_EXP 49
30430: PUSH
30431: LD_EXP 50
30435: PUSH
30436: LD_EXP 51
30440: PUSH
30441: LD_EXP 52
30445: PUSH
30446: LD_EXP 53
30450: PUSH
30451: LD_EXP 54
30455: PUSH
30456: LD_EXP 55
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: DIFF
30480: ST_TO_ADDR
// if tmp2 then
30481: LD_VAR 0 3
30485: IFFALSE 30503
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30487: LD_VAR 0 3
30491: PUSH
30492: LD_INT 1
30494: ARRAY
30495: PPUSH
30496: LD_STRING D19-Sol1-1
30498: PPUSH
30499: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30503: LD_EXP 39
30507: PPUSH
30508: LD_STRING D19-JMM-2
30510: PPUSH
30511: CALL_OW 88
// DialogueOff ;
30515: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30519: LD_VAR 0 2
30523: PUSH
30524: LD_INT 1
30526: ARRAY
30527: PPUSH
30528: LD_VAR 0 2
30532: PUSH
30533: LD_INT 2
30535: ARRAY
30536: PPUSH
30537: LD_INT 1
30539: PPUSH
30540: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30544: LD_STRING M5
30546: PPUSH
30547: CALL_OW 337
// omarOnMotherLode := false ;
30551: LD_ADDR_VAR 0 4
30555: PUSH
30556: LD_INT 0
30558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30559: LD_INT 35
30561: PPUSH
30562: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30566: LD_EXP 92
30570: PPUSH
30571: LD_INT 215
30573: PPUSH
30574: LD_INT 100
30576: PPUSH
30577: CALL_OW 297
30581: PUSH
30582: LD_INT 10
30584: LESS
30585: PUSH
30586: LD_VAR 0 4
30590: NOT
30591: AND
30592: IFFALSE 30626
// begin omarOnMotherLode := true ;
30594: LD_ADDR_VAR 0 4
30598: PUSH
30599: LD_INT 1
30601: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30602: LD_EXP 39
30606: PPUSH
30607: LD_STRING D19b-JMM-1
30609: PPUSH
30610: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30614: LD_EXP 92
30618: PPUSH
30619: LD_STRING DOmarContam-Omar-1
30621: PPUSH
30622: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30626: LD_EXP 92
30630: PPUSH
30631: CALL_OW 301
30635: IFFALSE 30559
// Say ( JMM , D19a-JMM-1 ) ;
30637: LD_EXP 39
30641: PPUSH
30642: LD_STRING D19a-JMM-1
30644: PPUSH
30645: CALL_OW 88
// if Heike then
30649: LD_EXP 93
30653: IFFALSE 30667
// Say ( Heike , D19a-Hke-1 ) ;
30655: LD_EXP 93
30659: PPUSH
30660: LD_STRING D19a-Hke-1
30662: PPUSH
30663: CALL_OW 88
// end ;
30667: PPOPN 4
30669: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30670: LD_INT 22
30672: PUSH
30673: LD_INT 3
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 21
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PPUSH
30694: CALL_OW 69
30698: PUSH
30699: LD_EXP 21
30703: AND
30704: IFFALSE 30772
30706: GO 30708
30708: DISABLE
30709: LD_INT 0
30711: PPUSH
30712: PPUSH
// begin enable ;
30713: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: LD_INT 25
30721: PPUSH
30722: LD_INT 22
30724: PUSH
30725: LD_INT 3
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PPUSH
30732: CALL_OW 70
30736: ST_TO_ADDR
// if not tmp then
30737: LD_VAR 0 2
30741: NOT
30742: IFFALSE 30746
// exit ;
30744: GO 30772
// for i in tmp do
30746: LD_ADDR_VAR 0 1
30750: PUSH
30751: LD_VAR 0 2
30755: PUSH
30756: FOR_IN
30757: IFFALSE 30770
// RemoveUnit ( i ) ;
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 64
30768: GO 30756
30770: POP
30771: POP
// end ;
30772: PPOPN 2
30774: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30775: LD_INT 22
30777: PUSH
30778: LD_INT 7
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 21
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PPUSH
30799: CALL_OW 69
30803: PUSH
30804: LD_INT 6
30806: LESS
30807: IFFALSE 31275
30809: GO 30811
30811: DISABLE
30812: LD_INT 0
30814: PPUSH
30815: PPUSH
// begin MC_Kill ( 1 ) ;
30816: LD_INT 1
30818: PPUSH
30819: CALL 35532 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30823: LD_INT 7
30825: PPUSH
30826: LD_INT 1
30828: PPUSH
30829: LD_INT 1
30831: PPUSH
30832: LD_INT 1
30834: PPUSH
30835: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30839: LD_ADDR_VAR 0 1
30843: PUSH
30844: LD_INT 22
30846: PUSH
30847: LD_INT 7
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 26
30856: PUSH
30857: LD_INT 1
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PPUSH
30868: CALL_OW 69
30872: PUSH
30873: LD_EXP 74
30877: DIFF
30878: ST_TO_ADDR
// if tmp then
30879: LD_VAR 0 1
30883: IFFALSE 30901
// tmp := tmp [ 1 ] else
30885: LD_ADDR_VAR 0 1
30889: PUSH
30890: LD_VAR 0 1
30894: PUSH
30895: LD_INT 1
30897: ARRAY
30898: ST_TO_ADDR
30899: GO 30937
// begin uc_side := 7 ;
30901: LD_ADDR_OWVAR 20
30905: PUSH
30906: LD_INT 7
30908: ST_TO_ADDR
// uc_nation := 1 ;
30909: LD_ADDR_OWVAR 21
30913: PUSH
30914: LD_INT 1
30916: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30917: LD_INT 1
30919: PPUSH
30920: LD_INT 8
30922: PPUSH
30923: CALL_OW 384
// tmp := CreateHuman ;
30927: LD_ADDR_VAR 0 1
30931: PUSH
30932: CALL_OW 44
30936: ST_TO_ADDR
// end ; DialogueOn ;
30937: CALL_OW 6
// if IsOK ( Roth ) then
30941: LD_EXP 74
30945: PPUSH
30946: CALL_OW 302
30950: IFFALSE 30964
// Say ( JMM , DAb-JMM-1 ) ;
30952: LD_EXP 39
30956: PPUSH
30957: LD_STRING DAb-JMM-1
30959: PPUSH
30960: CALL_OW 88
// if IsOK ( Roth ) then
30964: LD_EXP 74
30968: PPUSH
30969: CALL_OW 302
30973: IFFALSE 30997
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30975: LD_EXP 74
30979: PPUSH
30980: LD_STRING DSurrenderAlliance-Roth-1
30982: PPUSH
30983: CALL_OW 88
// RothCaptured := true ;
30987: LD_ADDR_EXP 33
30991: PUSH
30992: LD_INT 1
30994: ST_TO_ADDR
// end else
30995: GO 31009
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30997: LD_VAR 0 1
31001: PPUSH
31002: LD_STRING DSurrenderAlliance-Sci1-1
31004: PPUSH
31005: CALL_OW 88
// DialogueOff ;
31009: CALL_OW 7
// allianceDestroyed := true ;
31013: LD_ADDR_EXP 23
31017: PUSH
31018: LD_INT 1
31020: ST_TO_ADDR
// if capturedUnit = 0 then
31021: LD_EXP 34
31025: PUSH
31026: LD_INT 0
31028: EQUAL
31029: IFFALSE 31038
// SetAchievement ( ACH_ALLIANCE ) ;
31031: LD_STRING ACH_ALLIANCE
31033: PPUSH
31034: CALL_OW 543
// if trueAmericans then
31038: LD_EXP 35
31042: IFFALSE 31118
// begin if trueAmericans = 1 then
31044: LD_EXP 35
31048: PUSH
31049: LD_INT 1
31051: EQUAL
31052: IFFALSE 31068
// Say ( JMM , DAb-JMM-1a ) else
31054: LD_EXP 39
31058: PPUSH
31059: LD_STRING DAb-JMM-1a
31061: PPUSH
31062: CALL_OW 88
31066: GO 31080
// Say ( JMM , DAb-JMM-1b ) ;
31068: LD_EXP 39
31072: PPUSH
31073: LD_STRING DAb-JMM-1b
31075: PPUSH
31076: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31080: LD_EXP 35
31084: PPUSH
31085: CALL_OW 87
// for i in trueAmericans do
31089: LD_ADDR_VAR 0 2
31093: PUSH
31094: LD_EXP 35
31098: PUSH
31099: FOR_IN
31100: IFFALSE 31116
// SetSide ( i , 1 ) ;
31102: LD_VAR 0 2
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: CALL_OW 235
31114: GO 31099
31116: POP
31117: POP
// end ; repeat wait ( 0 0$1 ) ;
31118: LD_INT 35
31120: PPUSH
31121: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31125: LD_ADDR_VAR 0 2
31129: PUSH
31130: LD_INT 22
31132: PUSH
31133: LD_INT 7
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 21
31142: PUSH
31143: LD_INT 1
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PPUSH
31154: CALL_OW 69
31158: PUSH
31159: FOR_IN
31160: IFFALSE 31242
// begin if IsInUnit ( i ) then
31162: LD_VAR 0 2
31166: PPUSH
31167: CALL_OW 310
31171: IFFALSE 31182
// ComExitBuilding ( i ) ;
31173: LD_VAR 0 2
31177: PPUSH
31178: CALL_OW 122
// if IsDriver ( i ) then
31182: LD_VAR 0 2
31186: PPUSH
31187: CALL 100206 0 1
31191: IFFALSE 31202
// ComExitVehicle ( i ) ;
31193: LD_VAR 0 2
31197: PPUSH
31198: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31202: LD_VAR 0 2
31206: PPUSH
31207: LD_INT 26
31209: PPUSH
31210: CALL_OW 308
31214: NOT
31215: IFFALSE 31231
// AddComMoveToArea ( i , allianceEscapeArea ) else
31217: LD_VAR 0 2
31221: PPUSH
31222: LD_INT 26
31224: PPUSH
31225: CALL_OW 173
31229: GO 31240
// RemoveUnit ( i ) ;
31231: LD_VAR 0 2
31235: PPUSH
31236: CALL_OW 64
// end ;
31240: GO 31159
31242: POP
31243: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31244: LD_INT 22
31246: PUSH
31247: LD_INT 7
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 21
31256: PUSH
31257: LD_INT 1
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PPUSH
31268: CALL_OW 69
31272: NOT
31273: IFFALSE 31118
// end ;
31275: PPOPN 2
31277: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
// if not unit then
31282: LD_VAR 0 1
31286: NOT
31287: IFFALSE 31291
// exit ;
31289: GO 32789
// DoNotAttack ( 7 , unit ) ;
31291: LD_INT 7
31293: PPUSH
31294: LD_VAR 0 1
31298: PPUSH
31299: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31303: LD_VAR 0 1
31307: PPUSH
31308: LD_INT 260
31310: PPUSH
31311: LD_INT 235
31313: PPUSH
31314: LD_INT 3
31316: PPUSH
31317: LD_INT 1
31319: PPUSH
31320: CALL_OW 483
// SetSide ( unit , 4 ) ;
31324: LD_VAR 0 1
31328: PPUSH
31329: LD_INT 4
31331: PPUSH
31332: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31336: LD_ADDR_EXP 34
31340: PUSH
31341: LD_EXP 34
31345: PUSH
31346: LD_INT 1
31348: PLUS
31349: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31350: LD_INT 70
31352: PPUSH
31353: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31357: LD_INT 260
31359: PPUSH
31360: LD_INT 235
31362: PPUSH
31363: LD_INT 1
31365: PPUSH
31366: LD_INT 8
31368: NEG
31369: PPUSH
31370: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31374: LD_VAR 0 1
31378: PPUSH
31379: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31383: LD_VAR 0 1
31387: PPUSH
31388: LD_EXP 74
31392: PPUSH
31393: CALL_OW 119
// DialogueOn ;
31397: CALL_OW 6
// case unit of JMM :
31401: LD_VAR 0 1
31405: PUSH
31406: LD_EXP 39
31410: DOUBLE
31411: EQUAL
31412: IFTRUE 31416
31414: GO 31431
31416: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31417: LD_EXP 39
31421: PPUSH
31422: LD_STRING DA1-JMM-1
31424: PPUSH
31425: CALL_OW 91
31429: GO 31873
31431: LD_EXP 40
31435: DOUBLE
31436: EQUAL
31437: IFTRUE 31441
31439: GO 31456
31441: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31442: LD_EXP 40
31446: PPUSH
31447: LD_STRING DA1-Joan-1
31449: PPUSH
31450: CALL_OW 91
31454: GO 31873
31456: LD_EXP 42
31460: DOUBLE
31461: EQUAL
31462: IFTRUE 31466
31464: GO 31481
31466: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31467: LD_EXP 42
31471: PPUSH
31472: LD_STRING DA1-Lisa-1
31474: PPUSH
31475: CALL_OW 91
31479: GO 31873
31481: LD_EXP 43
31485: DOUBLE
31486: EQUAL
31487: IFTRUE 31491
31489: GO 31506
31491: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31492: LD_EXP 43
31496: PPUSH
31497: LD_STRING DA1-Don-1
31499: PPUSH
31500: CALL_OW 91
31504: GO 31873
31506: LD_EXP 50
31510: DOUBLE
31511: EQUAL
31512: IFTRUE 31516
31514: GO 31531
31516: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31517: LD_EXP 50
31521: PPUSH
31522: LD_STRING DA1-Corn-1
31524: PPUSH
31525: CALL_OW 91
31529: GO 31873
31531: LD_EXP 46
31535: DOUBLE
31536: EQUAL
31537: IFTRUE 31541
31539: GO 31556
31541: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31542: LD_EXP 46
31546: PPUSH
31547: LD_STRING DA1-Den-1
31549: PPUSH
31550: CALL_OW 91
31554: GO 31873
31556: LD_EXP 44
31560: DOUBLE
31561: EQUAL
31562: IFTRUE 31566
31564: GO 31581
31566: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31567: LD_EXP 44
31571: PPUSH
31572: LD_STRING DA1-Bobby-1
31574: PPUSH
31575: CALL_OW 91
31579: GO 31873
31581: LD_EXP 48
31585: DOUBLE
31586: EQUAL
31587: IFTRUE 31591
31589: GO 31606
31591: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31592: LD_EXP 48
31596: PPUSH
31597: LD_STRING DA1-Glad-1
31599: PPUSH
31600: CALL_OW 91
31604: GO 31873
31606: LD_EXP 45
31610: DOUBLE
31611: EQUAL
31612: IFTRUE 31616
31614: GO 31631
31616: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31617: LD_EXP 45
31621: PPUSH
31622: LD_STRING DA1-Cyrus-1
31624: PPUSH
31625: CALL_OW 91
31629: GO 31873
31631: LD_EXP 41
31635: DOUBLE
31636: EQUAL
31637: IFTRUE 31641
31639: GO 31656
31641: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31642: LD_EXP 41
31646: PPUSH
31647: LD_STRING DA1-Huck-1
31649: PPUSH
31650: CALL_OW 91
31654: GO 31873
31656: LD_EXP 55
31660: DOUBLE
31661: EQUAL
31662: IFTRUE 31666
31664: GO 31681
31666: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31667: LD_EXP 55
31671: PPUSH
31672: LD_STRING DA1-Huck-1
31674: PPUSH
31675: CALL_OW 91
31679: GO 31873
31681: LD_EXP 47
31685: DOUBLE
31686: EQUAL
31687: IFTRUE 31691
31689: GO 31706
31691: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31692: LD_EXP 47
31696: PPUSH
31697: LD_STRING DA1-Brown-1
31699: PPUSH
31700: CALL_OW 91
31704: GO 31873
31706: LD_EXP 51
31710: DOUBLE
31711: EQUAL
31712: IFTRUE 31716
31714: GO 31731
31716: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31717: LD_EXP 51
31721: PPUSH
31722: LD_STRING DA1-Gary-1
31724: PPUSH
31725: CALL_OW 91
31729: GO 31873
31731: LD_EXP 54
31735: DOUBLE
31736: EQUAL
31737: IFTRUE 31741
31739: GO 31756
31741: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31742: LD_EXP 54
31746: PPUSH
31747: LD_STRING DA1-Con-1
31749: PPUSH
31750: CALL_OW 91
31754: GO 31873
31756: LD_EXP 60
31760: DOUBLE
31761: EQUAL
31762: IFTRUE 31766
31764: GO 31781
31766: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31767: LD_EXP 60
31771: PPUSH
31772: LD_STRING DA1-Kurt-1
31774: PPUSH
31775: CALL_OW 91
31779: GO 31873
31781: LD_EXP 53
31785: DOUBLE
31786: EQUAL
31787: IFTRUE 31791
31789: GO 31806
31791: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31792: LD_EXP 53
31796: PPUSH
31797: LD_STRING DA1-Yam-1
31799: PPUSH
31800: CALL_OW 91
31804: GO 31873
31806: LD_EXP 52
31810: DOUBLE
31811: EQUAL
31812: IFTRUE 31816
31814: GO 31831
31816: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31817: LD_EXP 52
31821: PPUSH
31822: LD_STRING DA1-Frank-1
31824: PPUSH
31825: CALL_OW 91
31829: GO 31873
31831: POP
// begin if GetSex ( unit ) = sex_male then
31832: LD_VAR 0 1
31836: PPUSH
31837: CALL_OW 258
31841: PUSH
31842: LD_INT 1
31844: EQUAL
31845: IFFALSE 31861
// ForceSay ( unit , DA1-Sol1-1 ) else
31847: LD_VAR 0 1
31851: PPUSH
31852: LD_STRING DA1-Sol1-1
31854: PPUSH
31855: CALL_OW 91
31859: GO 31873
// ForceSay ( unit , DA1-FSol1-1 ) ;
31861: LD_VAR 0 1
31865: PPUSH
31866: LD_STRING DA1-FSol1-1
31868: PPUSH
31869: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31873: LD_EXP 74
31877: PPUSH
31878: LD_STRING DA-Roth-1
31880: PPUSH
31881: CALL_OW 88
// if capturedUnit = 1 then
31885: LD_EXP 34
31889: PUSH
31890: LD_INT 1
31892: EQUAL
31893: IFFALSE 31921
// begin Say ( Simms , DA-Sim-1 ) ;
31895: LD_EXP 75
31899: PPUSH
31900: LD_STRING DA-Sim-1
31902: PPUSH
31903: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31907: LD_EXP 74
31911: PPUSH
31912: LD_STRING DA-Roth-2
31914: PPUSH
31915: CALL_OW 88
// end else
31919: GO 31933
// Say ( Simms , DA-Sim-2 ) ;
31921: LD_EXP 75
31925: PPUSH
31926: LD_STRING DA-Sim-2
31928: PPUSH
31929: CALL_OW 88
// case unit of JMM :
31933: LD_VAR 0 1
31937: PUSH
31938: LD_EXP 39
31942: DOUBLE
31943: EQUAL
31944: IFTRUE 31948
31946: GO 31963
31948: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31949: LD_EXP 39
31953: PPUSH
31954: LD_STRING DA1-JMM-1a
31956: PPUSH
31957: CALL_OW 91
31961: GO 32470
31963: LD_EXP 40
31967: DOUBLE
31968: EQUAL
31969: IFTRUE 31973
31971: GO 31988
31973: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31974: LD_EXP 40
31978: PPUSH
31979: LD_STRING DA1-Joan-1a
31981: PPUSH
31982: CALL_OW 91
31986: GO 32470
31988: LD_EXP 42
31992: DOUBLE
31993: EQUAL
31994: IFTRUE 31998
31996: GO 32013
31998: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31999: LD_EXP 42
32003: PPUSH
32004: LD_STRING DA1-Lisa-1a
32006: PPUSH
32007: CALL_OW 91
32011: GO 32470
32013: LD_EXP 43
32017: DOUBLE
32018: EQUAL
32019: IFTRUE 32023
32021: GO 32038
32023: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32024: LD_EXP 43
32028: PPUSH
32029: LD_STRING DA1-Don-1a
32031: PPUSH
32032: CALL_OW 91
32036: GO 32470
32038: LD_EXP 50
32042: DOUBLE
32043: EQUAL
32044: IFTRUE 32048
32046: GO 32063
32048: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32049: LD_EXP 50
32053: PPUSH
32054: LD_STRING DA1-Corn-1a
32056: PPUSH
32057: CALL_OW 91
32061: GO 32470
32063: LD_EXP 46
32067: DOUBLE
32068: EQUAL
32069: IFTRUE 32073
32071: GO 32088
32073: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32074: LD_EXP 46
32078: PPUSH
32079: LD_STRING DA1-Den-1a
32081: PPUSH
32082: CALL_OW 91
32086: GO 32470
32088: LD_EXP 44
32092: DOUBLE
32093: EQUAL
32094: IFTRUE 32098
32096: GO 32113
32098: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32099: LD_EXP 44
32103: PPUSH
32104: LD_STRING DA1-Bobby-1a
32106: PPUSH
32107: CALL_OW 91
32111: GO 32470
32113: LD_EXP 48
32117: DOUBLE
32118: EQUAL
32119: IFTRUE 32123
32121: GO 32138
32123: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32124: LD_EXP 48
32128: PPUSH
32129: LD_STRING DA1-Glad-1a
32131: PPUSH
32132: CALL_OW 91
32136: GO 32470
32138: LD_EXP 45
32142: DOUBLE
32143: EQUAL
32144: IFTRUE 32148
32146: GO 32163
32148: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32149: LD_EXP 45
32153: PPUSH
32154: LD_STRING DA1-Cyrus-1a
32156: PPUSH
32157: CALL_OW 91
32161: GO 32470
32163: LD_EXP 41
32167: DOUBLE
32168: EQUAL
32169: IFTRUE 32173
32171: GO 32188
32173: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32174: LD_EXP 41
32178: PPUSH
32179: LD_STRING DA1-Huck-1a
32181: PPUSH
32182: CALL_OW 91
32186: GO 32470
32188: LD_EXP 55
32192: DOUBLE
32193: EQUAL
32194: IFTRUE 32198
32196: GO 32213
32198: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32199: LD_EXP 55
32203: PPUSH
32204: LD_STRING DA1-Huck-1a
32206: PPUSH
32207: CALL_OW 91
32211: GO 32470
32213: LD_EXP 47
32217: DOUBLE
32218: EQUAL
32219: IFTRUE 32223
32221: GO 32238
32223: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32224: LD_EXP 47
32228: PPUSH
32229: LD_STRING DA1-Brown-1a
32231: PPUSH
32232: CALL_OW 91
32236: GO 32470
32238: LD_EXP 51
32242: DOUBLE
32243: EQUAL
32244: IFTRUE 32248
32246: GO 32263
32248: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32249: LD_EXP 51
32253: PPUSH
32254: LD_STRING DA1-Gary-1a
32256: PPUSH
32257: CALL_OW 91
32261: GO 32470
32263: LD_EXP 54
32267: DOUBLE
32268: EQUAL
32269: IFTRUE 32273
32271: GO 32288
32273: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32274: LD_EXP 54
32278: PPUSH
32279: LD_STRING DA1-Con-1a
32281: PPUSH
32282: CALL_OW 91
32286: GO 32470
32288: LD_EXP 60
32292: DOUBLE
32293: EQUAL
32294: IFTRUE 32298
32296: GO 32313
32298: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32299: LD_EXP 60
32303: PPUSH
32304: LD_STRING DA1-Kurt-1a
32306: PPUSH
32307: CALL_OW 91
32311: GO 32470
32313: LD_EXP 53
32317: DOUBLE
32318: EQUAL
32319: IFTRUE 32323
32321: GO 32338
32323: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32324: LD_EXP 53
32328: PPUSH
32329: LD_STRING DA1-Yam-1a
32331: PPUSH
32332: CALL_OW 91
32336: GO 32470
32338: LD_EXP 52
32342: DOUBLE
32343: EQUAL
32344: IFTRUE 32348
32346: GO 32363
32348: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32349: LD_EXP 52
32353: PPUSH
32354: LD_STRING DA1-Frank-1a
32356: PPUSH
32357: CALL_OW 91
32361: GO 32470
32363: POP
// begin join := rand ( 0 , 1 ) ;
32364: LD_ADDR_VAR 0 3
32368: PUSH
32369: LD_INT 0
32371: PPUSH
32372: LD_INT 1
32374: PPUSH
32375: CALL_OW 12
32379: ST_TO_ADDR
// if join then
32380: LD_VAR 0 3
32384: IFFALSE 32429
// begin if GetSex ( unit ) = sex_male then
32386: LD_VAR 0 1
32390: PPUSH
32391: CALL_OW 258
32395: PUSH
32396: LD_INT 1
32398: EQUAL
32399: IFFALSE 32415
// ForceSay ( unit , DA1-Sol1-1b ) else
32401: LD_VAR 0 1
32405: PPUSH
32406: LD_STRING DA1-Sol1-1b
32408: PPUSH
32409: CALL_OW 91
32413: GO 32427
// ForceSay ( unit , DA1-FSol1-1b ) ;
32415: LD_VAR 0 1
32419: PPUSH
32420: LD_STRING DA1-FSol1-1b
32422: PPUSH
32423: CALL_OW 91
// end else
32427: GO 32470
// begin if GetSex ( unit ) = sex_male then
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 258
32438: PUSH
32439: LD_INT 1
32441: EQUAL
32442: IFFALSE 32458
// ForceSay ( unit , DA1-Sol1-1a ) else
32444: LD_VAR 0 1
32448: PPUSH
32449: LD_STRING DA1-Sol1-1a
32451: PPUSH
32452: CALL_OW 91
32456: GO 32470
// ForceSay ( unit , DA1-FSol1-1a ) ;
32458: LD_VAR 0 1
32462: PPUSH
32463: LD_STRING DA1-FSol1-1a
32465: PPUSH
32466: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32470: LD_VAR 0 1
32474: PUSH
32475: LD_EXP 39
32479: EQUAL
32480: IFFALSE 32491
// begin YouLost ( JMMCaptured ) ;
32482: LD_STRING JMMCaptured
32484: PPUSH
32485: CALL_OW 104
// exit ;
32489: GO 32789
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32491: LD_VAR 0 1
32495: PUSH
32496: LD_EXP 43
32500: PUSH
32501: LD_EXP 46
32505: PUSH
32506: LD_EXP 44
32510: PUSH
32511: LD_EXP 41
32515: PUSH
32516: LD_EXP 55
32520: PUSH
32521: LD_EXP 47
32525: PUSH
32526: LD_EXP 53
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: IN
32540: PUSH
32541: LD_VAR 0 3
32545: OR
32546: IFFALSE 32645
// begin Say ( Roth , DA-Roth-3 ) ;
32548: LD_EXP 74
32552: PPUSH
32553: LD_STRING DA-Roth-3
32555: PPUSH
32556: CALL_OW 88
// SetSide ( unit , 7 ) ;
32560: LD_VAR 0 1
32564: PPUSH
32565: LD_INT 7
32567: PPUSH
32568: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32572: LD_ADDR_EXP 117
32576: PUSH
32577: LD_EXP 117
32581: PPUSH
32582: LD_INT 1
32584: PPUSH
32585: LD_EXP 117
32589: PUSH
32590: LD_INT 1
32592: ARRAY
32593: PUSH
32594: LD_VAR 0 1
32598: ADD
32599: PPUSH
32600: CALL_OW 1
32604: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32605: LD_INT 260
32607: PPUSH
32608: LD_INT 235
32610: PPUSH
32611: LD_INT 1
32613: PPUSH
32614: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32618: LD_VAR 0 1
32622: PPUSH
32623: LD_INT 1000
32625: PPUSH
32626: CALL_OW 234
// DialogueOff ;
32630: CALL_OW 7
// ComFree ( unit ) ;
32634: LD_VAR 0 1
32638: PPUSH
32639: CALL_OW 139
// end else
32643: GO 32726
// begin Say ( Roth , DA-Roth-3a ) ;
32645: LD_EXP 74
32649: PPUSH
32650: LD_STRING DA-Roth-3a
32652: PPUSH
32653: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32657: LD_ADDR_EXP 35
32661: PUSH
32662: LD_EXP 35
32666: PUSH
32667: LD_VAR 0 1
32671: ADD
32672: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32673: LD_INT 260
32675: PPUSH
32676: LD_INT 235
32678: PPUSH
32679: LD_INT 1
32681: PPUSH
32682: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32686: LD_VAR 0 1
32690: PPUSH
32691: LD_INT 1000
32693: PPUSH
32694: CALL_OW 234
// DialogueOff ;
32698: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32702: LD_VAR 0 1
32706: PPUSH
32707: LD_INT 272
32709: PPUSH
32710: LD_INT 254
32712: PPUSH
32713: CALL_OW 111
// AddComHold ( unit ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 200
// end ; if capturedUnit = 1 then
32726: LD_EXP 34
32730: PUSH
32731: LD_INT 1
32733: EQUAL
32734: IFFALSE 32789
// begin DialogueOn ;
32736: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32740: LD_EXP 39
32744: PPUSH
32745: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32749: LD_EXP 39
32753: PPUSH
32754: LD_STRING DAa-JMM-1
32756: PPUSH
32757: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32761: LD_EXP 39
32765: PPUSH
32766: LD_STRING DAa-JMM-1a
32768: PPUSH
32769: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32773: LD_EXP 39
32777: PPUSH
32778: LD_STRING DAa-JMM-1b
32780: PPUSH
32781: CALL_OW 88
// DialogueOff ;
32785: CALL_OW 7
// end ; end ;
32789: LD_VAR 0 2
32793: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32794: LD_EXP 15
32798: PUSH
32799: LD_INT 13
32801: GREATEREQUAL
32802: PUSH
32803: LD_INT 22
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 21
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PPUSH
32827: CALL_OW 69
32831: PUSH
32832: LD_INT 0
32834: EQUAL
32835: AND
32836: PUSH
32837: LD_INT 22
32839: PUSH
32840: LD_INT 2
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 33
32849: PUSH
32850: LD_INT 5
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 21
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 50
32869: PUSH
32870: EMPTY
32871: LIST
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: PPUSH
32879: CALL_OW 69
32883: PUSH
32884: LD_INT 0
32886: EQUAL
32887: AND
32888: PUSH
32889: LD_EXP 21
32893: AND
32894: PUSH
32895: LD_EXP 22
32899: AND
32900: PUSH
32901: LD_EXP 23
32905: AND
32906: IFFALSE 33555
32908: GO 32910
32910: DISABLE
32911: LD_INT 0
32913: PPUSH
32914: PPUSH
32915: PPUSH
// begin m1 := false ;
32916: LD_ADDR_VAR 0 1
32920: PUSH
32921: LD_INT 0
32923: ST_TO_ADDR
// m2 := false ;
32924: LD_ADDR_VAR 0 2
32928: PUSH
32929: LD_INT 0
32931: ST_TO_ADDR
// m3 := false ;
32932: LD_ADDR_VAR 0 3
32936: PUSH
32937: LD_INT 0
32939: ST_TO_ADDR
// if not bombExploded then
32940: LD_EXP 37
32944: NOT
32945: IFFALSE 32954
// SetAchievement ( ACH_SIBROCKET ) ;
32947: LD_STRING ACH_SIBROCKET
32949: PPUSH
32950: CALL_OW 543
// if tick <= 120 120$00 then
32954: LD_OWVAR 1
32958: PUSH
32959: LD_INT 252000
32961: LESSEQUAL
32962: IFFALSE 32978
// begin wait ( 3 ) ;
32964: LD_INT 3
32966: PPUSH
32967: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32971: LD_STRING ACH_ASPEED_15
32973: PPUSH
32974: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32978: LD_EXP 39
32982: PPUSH
32983: CALL_OW 87
// music_class := 5 ;
32987: LD_ADDR_OWVAR 72
32991: PUSH
32992: LD_INT 5
32994: ST_TO_ADDR
// music_nat := 5 ;
32995: LD_ADDR_OWVAR 71
32999: PUSH
33000: LD_INT 5
33002: ST_TO_ADDR
// DialogueOn ;
33003: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33007: LD_EXP 39
33011: PPUSH
33012: LD_STRING D20-JMM-1
33014: PPUSH
33015: CALL_OW 88
// if IsOK ( Joan ) then
33019: LD_EXP 40
33023: PPUSH
33024: CALL_OW 302
33028: IFFALSE 33042
// Say ( Joan , D20-Joan-1 ) ;
33030: LD_EXP 40
33034: PPUSH
33035: LD_STRING D20-Joan-1
33037: PPUSH
33038: CALL_OW 88
// if IsOk ( Lisa ) then
33042: LD_EXP 42
33046: PPUSH
33047: CALL_OW 302
33051: IFFALSE 33065
// Say ( Lisa , D20-Lisa-1 ) ;
33053: LD_EXP 42
33057: PPUSH
33058: LD_STRING D20-Lisa-1
33060: PPUSH
33061: CALL_OW 88
// if IsOk ( Donaldson ) then
33065: LD_EXP 43
33069: PPUSH
33070: CALL_OW 302
33074: IFFALSE 33088
// Say ( Donaldson , D20-Don-1 ) ;
33076: LD_EXP 43
33080: PPUSH
33081: LD_STRING D20-Don-1
33083: PPUSH
33084: CALL_OW 88
// if IsOK ( Cornel ) then
33088: LD_EXP 50
33092: PPUSH
33093: CALL_OW 302
33097: IFFALSE 33111
// Say ( Cornel , D20-Corn-1 ) ;
33099: LD_EXP 50
33103: PPUSH
33104: LD_STRING D20-Corn-1
33106: PPUSH
33107: CALL_OW 88
// if IsOk ( Denis ) then
33111: LD_EXP 46
33115: PPUSH
33116: CALL_OW 302
33120: IFFALSE 33134
// Say ( Denis , D20-Den-1 ) ;
33122: LD_EXP 46
33126: PPUSH
33127: LD_STRING D20-Den-1
33129: PPUSH
33130: CALL_OW 88
// if IsOk ( Bobby ) then
33134: LD_EXP 44
33138: PPUSH
33139: CALL_OW 302
33143: IFFALSE 33157
// Say ( Bobby , D20-Bobby-1 ) ;
33145: LD_EXP 44
33149: PPUSH
33150: LD_STRING D20-Bobby-1
33152: PPUSH
33153: CALL_OW 88
// if IsOk ( Gladstone ) then
33157: LD_EXP 48
33161: PPUSH
33162: CALL_OW 302
33166: IFFALSE 33180
// Say ( Gladstone , D20-Glad-1 ) ;
33168: LD_EXP 48
33172: PPUSH
33173: LD_STRING D20-Glad-1
33175: PPUSH
33176: CALL_OW 88
// if IsOk ( Cyrus ) then
33180: LD_EXP 45
33184: PPUSH
33185: CALL_OW 302
33189: IFFALSE 33203
// Say ( Cyrus , D20-Cyrus-1 ) ;
33191: LD_EXP 45
33195: PPUSH
33196: LD_STRING D20-Cyrus-1
33198: PPUSH
33199: CALL_OW 88
// if IsOk ( Stevens ) then
33203: LD_EXP 41
33207: PPUSH
33208: CALL_OW 302
33212: IFFALSE 33226
// Say ( Stevens , D20-Huck-1 ) ;
33214: LD_EXP 41
33218: PPUSH
33219: LD_STRING D20-Huck-1
33221: PPUSH
33222: CALL_OW 88
// if IsOk ( Brown ) then
33226: LD_EXP 47
33230: PPUSH
33231: CALL_OW 302
33235: IFFALSE 33249
// Say ( Brown , D20-Brown-1 ) ;
33237: LD_EXP 47
33241: PPUSH
33242: LD_STRING D20-Brown-1
33244: PPUSH
33245: CALL_OW 88
// if IsOk ( Gary ) then
33249: LD_EXP 51
33253: PPUSH
33254: CALL_OW 302
33258: IFFALSE 33272
// Say ( Gary , D20-Gary-1 ) ;
33260: LD_EXP 51
33264: PPUSH
33265: LD_STRING D20-Gary-1
33267: PPUSH
33268: CALL_OW 88
// if IsOk ( Connie ) then
33272: LD_EXP 54
33276: PPUSH
33277: CALL_OW 302
33281: IFFALSE 33295
// Say ( Connie , D20-Con-1 ) ;
33283: LD_EXP 54
33287: PPUSH
33288: LD_STRING D20-Con-1
33290: PPUSH
33291: CALL_OW 88
// if IsOk ( Kurt ) then
33295: LD_EXP 60
33299: PPUSH
33300: CALL_OW 302
33304: IFFALSE 33318
// Say ( Kurt , D20-Kurt-1 ) ;
33306: LD_EXP 60
33310: PPUSH
33311: LD_STRING D20-Kurt-1
33313: PPUSH
33314: CALL_OW 88
// if IsOk ( Kikuchi ) then
33318: LD_EXP 53
33322: PPUSH
33323: CALL_OW 302
33327: IFFALSE 33341
// Say ( Kikuchi , D20-Yam-1 ) ;
33329: LD_EXP 53
33333: PPUSH
33334: LD_STRING D20-Yam-1
33336: PPUSH
33337: CALL_OW 88
// if IsOk ( Frank ) then
33341: LD_EXP 52
33345: PPUSH
33346: CALL_OW 302
33350: IFFALSE 33364
// Say ( Frank , D20-Frank-1 ) ;
33352: LD_EXP 52
33356: PPUSH
33357: LD_STRING D20-Frank-1
33359: PPUSH
33360: CALL_OW 88
// DialogueOff ;
33364: CALL_OW 7
// if RothCaptured then
33368: LD_EXP 33
33372: IFFALSE 33394
// begin m1 := true ;
33374: LD_ADDR_VAR 0 1
33378: PUSH
33379: LD_INT 1
33381: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33382: LD_STRING Roth
33384: PPUSH
33385: LD_INT 1
33387: PPUSH
33388: CALL_OW 101
// end else
33392: GO 33405
// AddMedal ( Roth , - 1 ) ;
33394: LD_STRING Roth
33396: PPUSH
33397: LD_INT 1
33399: NEG
33400: PPUSH
33401: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33405: LD_EXP 25
33409: NOT
33410: PUSH
33411: LD_EXP 27
33415: OR
33416: IFFALSE 33438
// begin m2 := true ;
33418: LD_ADDR_VAR 0 2
33422: PUSH
33423: LD_INT 1
33425: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33426: LD_STRING Project
33428: PPUSH
33429: LD_INT 1
33431: PPUSH
33432: CALL_OW 101
// end else
33436: GO 33449
// AddMedal ( Project , - 1 ) ;
33438: LD_STRING Project
33440: PPUSH
33441: LD_INT 1
33443: NEG
33444: PPUSH
33445: CALL_OW 101
// if lostCounter = 0 then
33449: LD_EXP 32
33453: PUSH
33454: LD_INT 0
33456: EQUAL
33457: IFFALSE 33479
// begin m3 := true ;
33459: LD_ADDR_VAR 0 3
33463: PUSH
33464: LD_INT 1
33466: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33467: LD_STRING NoLosses
33469: PPUSH
33470: LD_INT 1
33472: PPUSH
33473: CALL_OW 101
// end else
33477: GO 33490
// AddMedal ( NoLosses , - 1 ) ;
33479: LD_STRING NoLosses
33481: PPUSH
33482: LD_INT 1
33484: NEG
33485: PPUSH
33486: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33490: LD_VAR 0 1
33494: PUSH
33495: LD_VAR 0 2
33499: AND
33500: PUSH
33501: LD_VAR 0 3
33505: AND
33506: PUSH
33507: LD_OWVAR 67
33511: PUSH
33512: LD_INT 3
33514: GREATEREQUAL
33515: AND
33516: IFFALSE 33528
// SetAchievementEX ( ACH_AMER , 15 ) ;
33518: LD_STRING ACH_AMER
33520: PPUSH
33521: LD_INT 15
33523: PPUSH
33524: CALL_OW 564
// GiveMedals ( MAIN ) ;
33528: LD_STRING MAIN
33530: PPUSH
33531: CALL_OW 102
// music_class := 4 ;
33535: LD_ADDR_OWVAR 72
33539: PUSH
33540: LD_INT 4
33542: ST_TO_ADDR
// music_nat := 1 ;
33543: LD_ADDR_OWVAR 71
33547: PUSH
33548: LD_INT 1
33550: ST_TO_ADDR
// YouWin ;
33551: CALL_OW 103
// end ; end_of_file
33555: PPOPN 3
33557: END
// export function CustomEvent ( event ) ; begin
33558: LD_INT 0
33560: PPUSH
// end ;
33561: LD_VAR 0 2
33565: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33566: LD_VAR 0 1
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: PUSH
33575: LD_VAR 0 2
33579: PUSH
33580: LD_INT 4
33582: EQUAL
33583: AND
33584: PUSH
33585: LD_EXP 58
33589: PPUSH
33590: CALL_OW 300
33594: AND
33595: IFFALSE 33611
// begin wait ( 0 0$2 ) ;
33597: LD_INT 70
33599: PPUSH
33600: CALL_OW 67
// YouLost ( Dismissed ) ;
33604: LD_STRING Dismissed
33606: PPUSH
33607: CALL_OW 104
// end ; end ;
33611: PPOPN 2
33613: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33614: LD_VAR 0 2
33618: PPUSH
33619: LD_VAR 0 3
33623: PPUSH
33624: LD_INT 18
33626: PPUSH
33627: CALL_OW 309
33631: IFFALSE 33640
// YouLost ( Motherlode3 ) ;
33633: LD_STRING Motherlode3
33635: PPUSH
33636: CALL_OW 104
// end ;
33640: PPOPN 3
33642: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33643: LD_EXP 27
33647: NOT
33648: IFFALSE 33658
// behemothDone := true ;
33650: LD_ADDR_EXP 28
33654: PUSH
33655: LD_INT 1
33657: ST_TO_ADDR
// end ;
33658: PPOPN 1
33660: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33661: LD_VAR 0 1
33665: PPUSH
33666: CALL_OW 255
33670: PUSH
33671: LD_INT 1
33673: EQUAL
33674: IFFALSE 33684
// bombExploded := true ;
33676: LD_ADDR_EXP 37
33680: PUSH
33681: LD_INT 1
33683: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33684: LD_VAR 0 1
33688: PPUSH
33689: CALL_OW 255
33693: PUSH
33694: LD_INT 1
33696: EQUAL
33697: PUSH
33698: LD_EXP 30
33702: AND
33703: PUSH
33704: LD_INT 22
33706: PUSH
33707: LD_INT 3
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 34
33716: PUSH
33717: LD_INT 48
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PPUSH
33728: CALL_OW 69
33732: AND
33733: PUSH
33734: LD_INT 22
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 34
33746: PUSH
33747: LD_INT 8
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PPUSH
33758: CALL_OW 69
33762: NOT
33763: AND
33764: IFFALSE 33816
// begin wait ( 0 0$5 ) ;
33766: LD_INT 175
33768: PPUSH
33769: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33773: LD_INT 22
33775: PUSH
33776: LD_INT 3
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 34
33785: PUSH
33786: LD_INT 48
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PPUSH
33797: CALL_OW 69
33801: PUSH
33802: LD_INT 1
33804: ARRAY
33805: PPUSH
33806: LD_INT 60
33808: PPUSH
33809: LD_INT 95
33811: PPUSH
33812: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33816: LD_VAR 0 2
33820: PPUSH
33821: LD_VAR 0 3
33825: PPUSH
33826: LD_INT 18
33828: PPUSH
33829: CALL_OW 309
33833: IFFALSE 33880
// begin if GetSide ( unit ) = 1 then
33835: LD_VAR 0 1
33839: PPUSH
33840: CALL_OW 255
33844: PUSH
33845: LD_INT 1
33847: EQUAL
33848: IFFALSE 33866
// begin wait ( 0 0$6 ) ;
33850: LD_INT 210
33852: PPUSH
33853: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33857: LD_STRING Motherlode2
33859: PPUSH
33860: CALL_OW 104
// end else
33864: GO 33880
// begin wait ( 0 0$6 ) ;
33866: LD_INT 210
33868: PPUSH
33869: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33873: LD_STRING Motherlode1
33875: PPUSH
33876: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33880: LD_VAR 0 1
33884: PPUSH
33885: CALL_OW 255
33889: PUSH
33890: LD_INT 3
33892: EQUAL
33893: IFFALSE 33914
// begin wait ( 0 0$5 ) ;
33895: LD_INT 175
33897: PPUSH
33898: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33902: LD_EXP 64
33906: PPUSH
33907: LD_STRING D18-Pla-1
33909: PPUSH
33910: CALL_OW 94
// end ; end ;
33914: PPOPN 3
33916: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: CALL 120389 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33926: LD_VAR 0 1
33930: PUSH
33931: LD_INT 22
33933: PUSH
33934: LD_INT 1
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 21
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 23
33953: PUSH
33954: LD_INT 1
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: LIST
33965: PPUSH
33966: CALL_OW 69
33970: IN
33971: IFFALSE 33987
// lostCounter := lostCounter + 1 ;
33973: LD_ADDR_EXP 32
33977: PUSH
33978: LD_EXP 32
33982: PUSH
33983: LD_INT 1
33985: PLUS
33986: ST_TO_ADDR
// if un in behemothBuilders then
33987: LD_VAR 0 1
33991: PUSH
33992: LD_EXP 73
33996: IN
33997: IFFALSE 34017
// begin behemothBuilders := behemothBuilders diff un ;
33999: LD_ADDR_EXP 73
34003: PUSH
34004: LD_EXP 73
34008: PUSH
34009: LD_VAR 0 1
34013: DIFF
34014: ST_TO_ADDR
// exit ;
34015: GO 34047
// end ; if un = JMM then
34017: LD_VAR 0 1
34021: PUSH
34022: LD_EXP 39
34026: EQUAL
34027: IFFALSE 34038
// begin YouLost ( JMM ) ;
34029: LD_STRING JMM
34031: PPUSH
34032: CALL_OW 104
// exit ;
34036: GO 34047
// end ; MCE_UnitDestroyed ( un ) ;
34038: LD_VAR 0 1
34042: PPUSH
34043: CALL 62930 0 1
// end ;
34047: PPOPN 1
34049: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34050: LD_VAR 0 1
34054: PPUSH
34055: LD_VAR 0 2
34059: PPUSH
34060: CALL 65264 0 2
// end ;
34064: PPOPN 2
34066: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34067: LD_VAR 0 1
34071: PPUSH
34072: CALL 64332 0 1
// end ;
34076: PPOPN 1
34078: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34079: LD_VAR 0 1
34083: PUSH
34084: LD_INT 22
34086: PUSH
34087: LD_INT 8
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: LD_INT 30
34096: PUSH
34097: LD_INT 2
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 23
34106: PUSH
34107: LD_INT 3
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: LIST
34118: PPUSH
34119: CALL_OW 69
34123: IN
34124: IFFALSE 34151
// begin ComUpgrade ( building ) ;
34126: LD_VAR 0 1
34130: PPUSH
34131: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34135: LD_EXP 61
34139: PPUSH
34140: LD_VAR 0 1
34144: PPUSH
34145: CALL 73765 0 2
// exit ;
34149: GO 34160
// end ; MCE_BuildingComplete ( building ) ;
34151: LD_VAR 0 1
34155: PPUSH
34156: CALL 64573 0 1
// end ;
34160: PPOPN 1
34162: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34163: LD_VAR 0 1
34167: PPUSH
34168: LD_VAR 0 2
34172: PPUSH
34173: CALL 62626 0 2
// end ;
34177: PPOPN 2
34179: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34180: LD_VAR 0 1
34184: PPUSH
34185: LD_VAR 0 2
34189: PPUSH
34190: LD_VAR 0 3
34194: PPUSH
34195: LD_VAR 0 4
34199: PPUSH
34200: LD_VAR 0 5
34204: PPUSH
34205: CALL 62246 0 5
// end ;
34209: PPOPN 5
34211: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
34212: LD_VAR 0 1
34216: PPUSH
34217: LD_VAR 0 2
34221: PPUSH
34222: CALL 120511 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
34226: LD_VAR 0 1
34230: PPUSH
34231: LD_VAR 0 2
34235: PPUSH
34236: CALL 61827 0 2
// end ;
34240: PPOPN 2
34242: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34243: LD_VAR 0 1
34247: PPUSH
34248: LD_VAR 0 2
34252: PPUSH
34253: LD_VAR 0 3
34257: PPUSH
34258: LD_VAR 0 4
34262: PPUSH
34263: CALL 61665 0 4
// end ;
34267: PPOPN 4
34269: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34270: LD_VAR 0 1
34274: PPUSH
34275: LD_VAR 0 2
34279: PPUSH
34280: LD_VAR 0 3
34284: PPUSH
34285: CALL 61440 0 3
// end ;
34289: PPOPN 3
34291: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34292: LD_VAR 0 1
34296: PPUSH
34297: LD_VAR 0 2
34301: PPUSH
34302: CALL 61325 0 2
// end ;
34306: PPOPN 2
34308: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34309: LD_VAR 0 1
34313: PPUSH
34314: LD_VAR 0 2
34318: PPUSH
34319: CALL 65559 0 2
// end ;
34323: PPOPN 2
34325: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34326: LD_VAR 0 1
34330: PPUSH
34331: CALL_OW 255
34335: PUSH
34336: LD_INT 4
34338: EQUAL
34339: PUSH
34340: LD_VAR 0 1
34344: PUSH
34345: LD_EXP 18
34349: PUSH
34350: LD_INT 1
34352: ARRAY
34353: IN
34354: AND
34355: PUSH
34356: LD_EXP 19
34360: AND
34361: IFFALSE 34380
// begin ComMoveXY ( driver , 61 , 93 ) ;
34363: LD_VAR 0 1
34367: PPUSH
34368: LD_INT 61
34370: PPUSH
34371: LD_INT 93
34373: PPUSH
34374: CALL_OW 111
// exit ;
34378: GO 34404
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34380: LD_VAR 0 1
34384: PPUSH
34385: LD_VAR 0 2
34389: PPUSH
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 4
34399: PPUSH
34400: CALL 65775 0 4
// end ;
34404: PPOPN 4
34406: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34407: LD_VAR 0 1
34411: PPUSH
34412: LD_VAR 0 2
34416: PPUSH
34417: CALL 61134 0 2
// end ;
34421: PPOPN 2
34423: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34424: LD_VAR 0 1
34428: PPUSH
34429: CALL 120495 0 1
// end ; end_of_file
34433: PPOPN 1
34435: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34436: LD_EXP 15
34440: PUSH
34441: LD_INT 2
34443: EQUAL
34444: IFFALSE 34927
34446: GO 34448
34448: DISABLE
34449: LD_INT 0
34451: PPUSH
// begin time := 0 0$40 ;
34452: LD_ADDR_VAR 0 1
34456: PUSH
34457: LD_INT 1400
34459: ST_TO_ADDR
// repeat wait ( time ) ;
34460: LD_VAR 0 1
34464: PPUSH
34465: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34469: LD_INT 1
34471: PPUSH
34472: LD_INT 5
34474: PPUSH
34475: CALL_OW 12
34479: PPUSH
34480: LD_INT 106
34482: PPUSH
34483: LD_INT 150
34485: PPUSH
34486: LD_INT 19
34488: PPUSH
34489: LD_INT 1
34491: PPUSH
34492: CALL_OW 56
// time := time + 0 0$9 ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_VAR 0 1
34505: PUSH
34506: LD_INT 315
34508: PLUS
34509: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34510: LD_INT 455
34512: PPUSH
34513: LD_INT 840
34515: PPUSH
34516: CALL_OW 12
34520: PPUSH
34521: CALL_OW 67
// if Prob ( 50 ) then
34525: LD_INT 50
34527: PPUSH
34528: CALL_OW 13
34532: IFFALSE 34561
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34534: LD_INT 1
34536: PPUSH
34537: LD_INT 5
34539: PPUSH
34540: CALL_OW 12
34544: PPUSH
34545: LD_INT 62
34547: PPUSH
34548: LD_INT 108
34550: PPUSH
34551: LD_INT 10
34553: PPUSH
34554: LD_INT 1
34556: PPUSH
34557: CALL_OW 56
// until missionStage > 4 ;
34561: LD_EXP 15
34565: PUSH
34566: LD_INT 4
34568: GREATER
34569: IFFALSE 34460
// repeat wait ( 0 0$1 ) ;
34571: LD_INT 35
34573: PPUSH
34574: CALL_OW 67
// until missionStage = 6 ;
34578: LD_EXP 15
34582: PUSH
34583: LD_INT 6
34585: EQUAL
34586: IFFALSE 34571
// time := 0 0$50 ;
34588: LD_ADDR_VAR 0 1
34592: PUSH
34593: LD_INT 1750
34595: ST_TO_ADDR
// repeat wait ( time ) ;
34596: LD_VAR 0 1
34600: PPUSH
34601: CALL_OW 67
// if Prob ( 50 ) then
34605: LD_INT 50
34607: PPUSH
34608: CALL_OW 13
34612: IFFALSE 34641
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34614: LD_INT 1
34616: PPUSH
34617: LD_INT 5
34619: PPUSH
34620: CALL_OW 12
34624: PPUSH
34625: LD_INT 106
34627: PPUSH
34628: LD_INT 89
34630: PPUSH
34631: LD_INT 45
34633: PPUSH
34634: LD_INT 1
34636: PPUSH
34637: CALL_OW 56
// time := time + 0 0$2 ;
34641: LD_ADDR_VAR 0 1
34645: PUSH
34646: LD_VAR 0 1
34650: PUSH
34651: LD_INT 70
34653: PLUS
34654: ST_TO_ADDR
// if Prob ( 30 ) then
34655: LD_INT 30
34657: PPUSH
34658: CALL_OW 13
34662: IFFALSE 34708
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34664: LD_INT 385
34666: PPUSH
34667: LD_INT 945
34669: PPUSH
34670: CALL_OW 12
34674: PPUSH
34675: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34679: LD_INT 1
34681: PPUSH
34682: LD_INT 5
34684: PPUSH
34685: CALL_OW 12
34689: PPUSH
34690: LD_INT 21
34692: PPUSH
34693: LD_INT 26
34695: PPUSH
34696: LD_INT 12
34698: PPUSH
34699: LD_INT 1
34701: PPUSH
34702: CALL_OW 56
// end else
34706: GO 34744
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34708: LD_INT 700
34710: PPUSH
34711: LD_INT 1225
34713: PPUSH
34714: CALL_OW 12
34718: PPUSH
34719: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34723: LD_INT 1
34725: PPUSH
34726: LD_INT 5
34728: PPUSH
34729: CALL_OW 12
34733: PPUSH
34734: LD_INT 16
34736: PPUSH
34737: LD_INT 1
34739: PPUSH
34740: CALL_OW 55
// end ; if Prob ( 50 ) then
34744: LD_INT 50
34746: PPUSH
34747: CALL_OW 13
34751: IFFALSE 34797
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34753: LD_INT 700
34755: PPUSH
34756: LD_INT 1050
34758: PPUSH
34759: CALL_OW 12
34763: PPUSH
34764: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34768: LD_INT 1
34770: PPUSH
34771: LD_INT 5
34773: PPUSH
34774: CALL_OW 12
34778: PPUSH
34779: LD_INT 181
34781: PPUSH
34782: LD_INT 218
34784: PPUSH
34785: LD_INT 16
34787: PPUSH
34788: LD_INT 1
34790: PPUSH
34791: CALL_OW 56
// end else
34795: GO 34833
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34797: LD_INT 350
34799: PPUSH
34800: LD_INT 525
34802: PPUSH
34803: CALL_OW 12
34807: PPUSH
34808: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34812: LD_INT 1
34814: PPUSH
34815: LD_INT 5
34817: PPUSH
34818: CALL_OW 12
34822: PPUSH
34823: LD_INT 15
34825: PPUSH
34826: LD_INT 1
34828: PPUSH
34829: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34833: LD_INT 45
34835: PUSH
34836: LD_INT 32
34838: PUSH
34839: LD_INT 25
34841: PUSH
34842: LD_INT 22
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: LIST
34850: PUSH
34851: LD_OWVAR 67
34855: ARRAY
34856: PPUSH
34857: CALL_OW 13
34861: IFFALSE 34905
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34863: LD_INT 175
34865: PPUSH
34866: LD_INT 315
34868: PPUSH
34869: CALL_OW 12
34873: PPUSH
34874: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34878: LD_INT 1
34880: PPUSH
34881: LD_INT 5
34883: PPUSH
34884: CALL_OW 12
34888: PPUSH
34889: LD_INT 103
34891: PPUSH
34892: LD_INT 140
34894: PPUSH
34895: LD_INT 20
34897: PPUSH
34898: LD_INT 1
34900: PPUSH
34901: CALL_OW 56
// end ; if time > 1 1$20 then
34905: LD_VAR 0 1
34909: PUSH
34910: LD_INT 2800
34912: GREATER
34913: IFFALSE 34923
// time := 0 0$30 ;
34915: LD_ADDR_VAR 0 1
34919: PUSH
34920: LD_INT 1050
34922: ST_TO_ADDR
// until false ;
34923: LD_INT 0
34925: IFFALSE 34596
// end ; end_of_file
34927: PPOPN 1
34929: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34930: LD_EXP 13
34934: PUSH
34935: LD_EXP 15
34939: PUSH
34940: LD_INT 6
34942: GREATEREQUAL
34943: AND
34944: IFFALSE 34981
34946: GO 34948
34948: DISABLE
// begin enable ;
34949: ENABLE
// missionTime := missionTime + 0 0$1 ;
34950: LD_ADDR_EXP 14
34954: PUSH
34955: LD_EXP 14
34959: PUSH
34960: LD_INT 35
34962: PLUS
34963: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34964: LD_ADDR_OWVAR 47
34968: PUSH
34969: LD_STRING #Am15-1
34971: PUSH
34972: LD_EXP 14
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: ST_TO_ADDR
// end ; end_of_file
34981: END
// export function InitNature ; begin
34982: LD_INT 0
34984: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34985: LD_INT 3
34987: PPUSH
34988: LD_INT 3
34990: PPUSH
34991: LD_INT 2
34993: PPUSH
34994: LD_INT 1
34996: PPUSH
34997: LD_INT 1
34999: PPUSH
35000: LD_INT 0
35002: PPUSH
35003: LD_INT 0
35005: PPUSH
35006: LD_INT 20
35008: PPUSH
35009: LD_INT 0
35011: PPUSH
35012: CALL 99279 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
35016: LD_INT 2
35018: PPUSH
35019: LD_INT 1
35021: PPUSH
35022: LD_INT 1
35024: PPUSH
35025: LD_INT 1
35027: PPUSH
35028: LD_INT 1
35030: PPUSH
35031: LD_INT 0
35033: PPUSH
35034: LD_INT 0
35036: PPUSH
35037: LD_INT 21
35039: PPUSH
35040: LD_INT 0
35042: PPUSH
35043: CALL 99279 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35047: LD_INT 4
35049: PPUSH
35050: LD_INT 1
35052: PPUSH
35053: LD_INT 2
35055: PPUSH
35056: LD_INT 4
35058: PPUSH
35059: LD_INT 2
35061: PPUSH
35062: LD_INT 1
35064: PPUSH
35065: LD_INT 0
35067: PPUSH
35068: LD_INT 22
35070: PPUSH
35071: LD_INT 0
35073: PPUSH
35074: CALL 99279 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35078: LD_INT 0
35080: PPUSH
35081: LD_INT 0
35083: PPUSH
35084: LD_INT 0
35086: PPUSH
35087: LD_INT 0
35089: PPUSH
35090: LD_INT 0
35092: PPUSH
35093: LD_INT 0
35095: PPUSH
35096: LD_INT 9
35098: PPUSH
35099: LD_INT 0
35101: PPUSH
35102: LD_INT 23
35104: PPUSH
35105: CALL 99279 0 9
// end ; end_of_file
35109: LD_VAR 0 1
35113: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
35114: LD_INT 0
35116: PPUSH
// ar_miner := 81 ;
35117: LD_ADDR_EXP 102
35121: PUSH
35122: LD_INT 81
35124: ST_TO_ADDR
// ar_crane := 88 ;
35125: LD_ADDR_EXP 101
35129: PUSH
35130: LD_INT 88
35132: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35133: LD_ADDR_EXP 96
35137: PUSH
35138: LD_INT 89
35140: ST_TO_ADDR
// us_hack := 99 ;
35141: LD_ADDR_EXP 97
35145: PUSH
35146: LD_INT 99
35148: ST_TO_ADDR
// us_artillery := 97 ;
35149: LD_ADDR_EXP 98
35153: PUSH
35154: LD_INT 97
35156: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35157: LD_ADDR_EXP 99
35161: PUSH
35162: LD_INT 91
35164: ST_TO_ADDR
// ar_mortar := 92 ;
35165: LD_ADDR_EXP 100
35169: PUSH
35170: LD_INT 92
35172: ST_TO_ADDR
// ru_flamethrower := 93 ;
35173: LD_ADDR_EXP 103
35177: PUSH
35178: LD_INT 93
35180: ST_TO_ADDR
// ru_radar := 98 ;
35181: LD_ADDR_EXP 95
35185: PUSH
35186: LD_INT 98
35188: ST_TO_ADDR
// tech_Artillery := 80 ;
35189: LD_ADDR_EXP 104
35193: PUSH
35194: LD_INT 80
35196: ST_TO_ADDR
// tech_RadMat := 81 ;
35197: LD_ADDR_EXP 105
35201: PUSH
35202: LD_INT 81
35204: ST_TO_ADDR
// tech_BasicTools := 82 ;
35205: LD_ADDR_EXP 106
35209: PUSH
35210: LD_INT 82
35212: ST_TO_ADDR
// tech_Cargo := 83 ;
35213: LD_ADDR_EXP 107
35217: PUSH
35218: LD_INT 83
35220: ST_TO_ADDR
// tech_Track := 84 ;
35221: LD_ADDR_EXP 108
35225: PUSH
35226: LD_INT 84
35228: ST_TO_ADDR
// tech_Crane := 85 ;
35229: LD_ADDR_EXP 109
35233: PUSH
35234: LD_INT 85
35236: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35237: LD_ADDR_EXP 110
35241: PUSH
35242: LD_INT 86
35244: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35245: LD_ADDR_EXP 111
35249: PUSH
35250: LD_INT 87
35252: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35253: LD_ADDR_EXP 112
35257: PUSH
35258: LD_INT 88
35260: ST_TO_ADDR
// class_mastodont := 31 ;
35261: LD_ADDR_EXP 113
35265: PUSH
35266: LD_INT 31
35268: ST_TO_ADDR
// class_horse := 21 ;
35269: LD_ADDR_EXP 114
35273: PUSH
35274: LD_INT 21
35276: ST_TO_ADDR
// end ;
35277: LD_VAR 0 1
35281: RET
// every 1 do
35282: GO 35284
35284: DISABLE
// InitGlobalVariables ; end_of_file
35285: CALL 35114 0 0
35289: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35290: LD_INT 0
35292: PPUSH
35293: PPUSH
// skirmish := false ;
35294: LD_ADDR_EXP 115
35298: PUSH
35299: LD_INT 0
35301: ST_TO_ADDR
// debug_mc := false ;
35302: LD_ADDR_EXP 116
35306: PUSH
35307: LD_INT 0
35309: ST_TO_ADDR
// mc_bases := [ ] ;
35310: LD_ADDR_EXP 117
35314: PUSH
35315: EMPTY
35316: ST_TO_ADDR
// mc_sides := [ ] ;
35317: LD_ADDR_EXP 143
35321: PUSH
35322: EMPTY
35323: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35324: LD_ADDR_EXP 118
35328: PUSH
35329: EMPTY
35330: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35331: LD_ADDR_EXP 119
35335: PUSH
35336: EMPTY
35337: ST_TO_ADDR
// mc_need_heal := [ ] ;
35338: LD_ADDR_EXP 120
35342: PUSH
35343: EMPTY
35344: ST_TO_ADDR
// mc_healers := [ ] ;
35345: LD_ADDR_EXP 121
35349: PUSH
35350: EMPTY
35351: ST_TO_ADDR
// mc_build_list := [ ] ;
35352: LD_ADDR_EXP 122
35356: PUSH
35357: EMPTY
35358: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35359: LD_ADDR_EXP 149
35363: PUSH
35364: EMPTY
35365: ST_TO_ADDR
// mc_builders := [ ] ;
35366: LD_ADDR_EXP 123
35370: PUSH
35371: EMPTY
35372: ST_TO_ADDR
// mc_construct_list := [ ] ;
35373: LD_ADDR_EXP 124
35377: PUSH
35378: EMPTY
35379: ST_TO_ADDR
// mc_turret_list := [ ] ;
35380: LD_ADDR_EXP 125
35384: PUSH
35385: EMPTY
35386: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35387: LD_ADDR_EXP 126
35391: PUSH
35392: EMPTY
35393: ST_TO_ADDR
// mc_miners := [ ] ;
35394: LD_ADDR_EXP 131
35398: PUSH
35399: EMPTY
35400: ST_TO_ADDR
// mc_mines := [ ] ;
35401: LD_ADDR_EXP 130
35405: PUSH
35406: EMPTY
35407: ST_TO_ADDR
// mc_minefields := [ ] ;
35408: LD_ADDR_EXP 132
35412: PUSH
35413: EMPTY
35414: ST_TO_ADDR
// mc_crates := [ ] ;
35415: LD_ADDR_EXP 133
35419: PUSH
35420: EMPTY
35421: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35422: LD_ADDR_EXP 134
35426: PUSH
35427: EMPTY
35428: ST_TO_ADDR
// mc_crates_area := [ ] ;
35429: LD_ADDR_EXP 135
35433: PUSH
35434: EMPTY
35435: ST_TO_ADDR
// mc_vehicles := [ ] ;
35436: LD_ADDR_EXP 136
35440: PUSH
35441: EMPTY
35442: ST_TO_ADDR
// mc_attack := [ ] ;
35443: LD_ADDR_EXP 137
35447: PUSH
35448: EMPTY
35449: ST_TO_ADDR
// mc_produce := [ ] ;
35450: LD_ADDR_EXP 138
35454: PUSH
35455: EMPTY
35456: ST_TO_ADDR
// mc_defender := [ ] ;
35457: LD_ADDR_EXP 139
35461: PUSH
35462: EMPTY
35463: ST_TO_ADDR
// mc_parking := [ ] ;
35464: LD_ADDR_EXP 141
35468: PUSH
35469: EMPTY
35470: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35471: LD_ADDR_EXP 127
35475: PUSH
35476: EMPTY
35477: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35478: LD_ADDR_EXP 129
35482: PUSH
35483: EMPTY
35484: ST_TO_ADDR
// mc_scan := [ ] ;
35485: LD_ADDR_EXP 140
35489: PUSH
35490: EMPTY
35491: ST_TO_ADDR
// mc_scan_area := [ ] ;
35492: LD_ADDR_EXP 142
35496: PUSH
35497: EMPTY
35498: ST_TO_ADDR
// mc_tech := [ ] ;
35499: LD_ADDR_EXP 144
35503: PUSH
35504: EMPTY
35505: ST_TO_ADDR
// mc_class := [ ] ;
35506: LD_ADDR_EXP 158
35510: PUSH
35511: EMPTY
35512: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35513: LD_ADDR_EXP 159
35517: PUSH
35518: EMPTY
35519: ST_TO_ADDR
// mc_is_defending := [ ] ;
35520: LD_ADDR_EXP 160
35524: PUSH
35525: EMPTY
35526: ST_TO_ADDR
// end ;
35527: LD_VAR 0 1
35531: RET
// export function MC_Kill ( base ) ; begin
35532: LD_INT 0
35534: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35535: LD_ADDR_EXP 117
35539: PUSH
35540: LD_EXP 117
35544: PPUSH
35545: LD_VAR 0 1
35549: PPUSH
35550: EMPTY
35551: PPUSH
35552: CALL_OW 1
35556: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35557: LD_ADDR_EXP 118
35561: PUSH
35562: LD_EXP 118
35566: PPUSH
35567: LD_VAR 0 1
35571: PPUSH
35572: EMPTY
35573: PPUSH
35574: CALL_OW 1
35578: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35579: LD_ADDR_EXP 119
35583: PUSH
35584: LD_EXP 119
35588: PPUSH
35589: LD_VAR 0 1
35593: PPUSH
35594: EMPTY
35595: PPUSH
35596: CALL_OW 1
35600: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35601: LD_ADDR_EXP 120
35605: PUSH
35606: LD_EXP 120
35610: PPUSH
35611: LD_VAR 0 1
35615: PPUSH
35616: EMPTY
35617: PPUSH
35618: CALL_OW 1
35622: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35623: LD_ADDR_EXP 121
35627: PUSH
35628: LD_EXP 121
35632: PPUSH
35633: LD_VAR 0 1
35637: PPUSH
35638: EMPTY
35639: PPUSH
35640: CALL_OW 1
35644: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35645: LD_ADDR_EXP 122
35649: PUSH
35650: LD_EXP 122
35654: PPUSH
35655: LD_VAR 0 1
35659: PPUSH
35660: EMPTY
35661: PPUSH
35662: CALL_OW 1
35666: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35667: LD_ADDR_EXP 123
35671: PUSH
35672: LD_EXP 123
35676: PPUSH
35677: LD_VAR 0 1
35681: PPUSH
35682: EMPTY
35683: PPUSH
35684: CALL_OW 1
35688: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35689: LD_ADDR_EXP 124
35693: PUSH
35694: LD_EXP 124
35698: PPUSH
35699: LD_VAR 0 1
35703: PPUSH
35704: EMPTY
35705: PPUSH
35706: CALL_OW 1
35710: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35711: LD_ADDR_EXP 125
35715: PUSH
35716: LD_EXP 125
35720: PPUSH
35721: LD_VAR 0 1
35725: PPUSH
35726: EMPTY
35727: PPUSH
35728: CALL_OW 1
35732: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35733: LD_ADDR_EXP 126
35737: PUSH
35738: LD_EXP 126
35742: PPUSH
35743: LD_VAR 0 1
35747: PPUSH
35748: EMPTY
35749: PPUSH
35750: CALL_OW 1
35754: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35755: LD_ADDR_EXP 127
35759: PUSH
35760: LD_EXP 127
35764: PPUSH
35765: LD_VAR 0 1
35769: PPUSH
35770: EMPTY
35771: PPUSH
35772: CALL_OW 1
35776: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35777: LD_ADDR_EXP 128
35781: PUSH
35782: LD_EXP 128
35786: PPUSH
35787: LD_VAR 0 1
35791: PPUSH
35792: LD_INT 0
35794: PPUSH
35795: CALL_OW 1
35799: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35800: LD_ADDR_EXP 129
35804: PUSH
35805: LD_EXP 129
35809: PPUSH
35810: LD_VAR 0 1
35814: PPUSH
35815: EMPTY
35816: PPUSH
35817: CALL_OW 1
35821: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35822: LD_ADDR_EXP 130
35826: PUSH
35827: LD_EXP 130
35831: PPUSH
35832: LD_VAR 0 1
35836: PPUSH
35837: EMPTY
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35844: LD_ADDR_EXP 131
35848: PUSH
35849: LD_EXP 131
35853: PPUSH
35854: LD_VAR 0 1
35858: PPUSH
35859: EMPTY
35860: PPUSH
35861: CALL_OW 1
35865: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35866: LD_ADDR_EXP 132
35870: PUSH
35871: LD_EXP 132
35875: PPUSH
35876: LD_VAR 0 1
35880: PPUSH
35881: EMPTY
35882: PPUSH
35883: CALL_OW 1
35887: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35888: LD_ADDR_EXP 133
35892: PUSH
35893: LD_EXP 133
35897: PPUSH
35898: LD_VAR 0 1
35902: PPUSH
35903: EMPTY
35904: PPUSH
35905: CALL_OW 1
35909: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35910: LD_ADDR_EXP 134
35914: PUSH
35915: LD_EXP 134
35919: PPUSH
35920: LD_VAR 0 1
35924: PPUSH
35925: EMPTY
35926: PPUSH
35927: CALL_OW 1
35931: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35932: LD_ADDR_EXP 135
35936: PUSH
35937: LD_EXP 135
35941: PPUSH
35942: LD_VAR 0 1
35946: PPUSH
35947: EMPTY
35948: PPUSH
35949: CALL_OW 1
35953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35954: LD_ADDR_EXP 136
35958: PUSH
35959: LD_EXP 136
35963: PPUSH
35964: LD_VAR 0 1
35968: PPUSH
35969: EMPTY
35970: PPUSH
35971: CALL_OW 1
35975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35976: LD_ADDR_EXP 137
35980: PUSH
35981: LD_EXP 137
35985: PPUSH
35986: LD_VAR 0 1
35990: PPUSH
35991: EMPTY
35992: PPUSH
35993: CALL_OW 1
35997: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35998: LD_ADDR_EXP 138
36002: PUSH
36003: LD_EXP 138
36007: PPUSH
36008: LD_VAR 0 1
36012: PPUSH
36013: EMPTY
36014: PPUSH
36015: CALL_OW 1
36019: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36020: LD_ADDR_EXP 139
36024: PUSH
36025: LD_EXP 139
36029: PPUSH
36030: LD_VAR 0 1
36034: PPUSH
36035: EMPTY
36036: PPUSH
36037: CALL_OW 1
36041: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36042: LD_ADDR_EXP 140
36046: PUSH
36047: LD_EXP 140
36051: PPUSH
36052: LD_VAR 0 1
36056: PPUSH
36057: EMPTY
36058: PPUSH
36059: CALL_OW 1
36063: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36064: LD_ADDR_EXP 141
36068: PUSH
36069: LD_EXP 141
36073: PPUSH
36074: LD_VAR 0 1
36078: PPUSH
36079: EMPTY
36080: PPUSH
36081: CALL_OW 1
36085: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36086: LD_ADDR_EXP 142
36090: PUSH
36091: LD_EXP 142
36095: PPUSH
36096: LD_VAR 0 1
36100: PPUSH
36101: EMPTY
36102: PPUSH
36103: CALL_OW 1
36107: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36108: LD_ADDR_EXP 144
36112: PUSH
36113: LD_EXP 144
36117: PPUSH
36118: LD_VAR 0 1
36122: PPUSH
36123: EMPTY
36124: PPUSH
36125: CALL_OW 1
36129: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36130: LD_ADDR_EXP 146
36134: PUSH
36135: LD_EXP 146
36139: PPUSH
36140: LD_VAR 0 1
36144: PPUSH
36145: EMPTY
36146: PPUSH
36147: CALL_OW 1
36151: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36152: LD_ADDR_EXP 147
36156: PUSH
36157: LD_EXP 147
36161: PPUSH
36162: LD_VAR 0 1
36166: PPUSH
36167: EMPTY
36168: PPUSH
36169: CALL_OW 1
36173: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36174: LD_ADDR_EXP 148
36178: PUSH
36179: LD_EXP 148
36183: PPUSH
36184: LD_VAR 0 1
36188: PPUSH
36189: EMPTY
36190: PPUSH
36191: CALL_OW 1
36195: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36196: LD_ADDR_EXP 149
36200: PUSH
36201: LD_EXP 149
36205: PPUSH
36206: LD_VAR 0 1
36210: PPUSH
36211: EMPTY
36212: PPUSH
36213: CALL_OW 1
36217: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36218: LD_ADDR_EXP 150
36222: PUSH
36223: LD_EXP 150
36227: PPUSH
36228: LD_VAR 0 1
36232: PPUSH
36233: EMPTY
36234: PPUSH
36235: CALL_OW 1
36239: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36240: LD_ADDR_EXP 151
36244: PUSH
36245: LD_EXP 151
36249: PPUSH
36250: LD_VAR 0 1
36254: PPUSH
36255: EMPTY
36256: PPUSH
36257: CALL_OW 1
36261: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36262: LD_ADDR_EXP 152
36266: PUSH
36267: LD_EXP 152
36271: PPUSH
36272: LD_VAR 0 1
36276: PPUSH
36277: EMPTY
36278: PPUSH
36279: CALL_OW 1
36283: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36284: LD_ADDR_EXP 153
36288: PUSH
36289: LD_EXP 153
36293: PPUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: EMPTY
36300: PPUSH
36301: CALL_OW 1
36305: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36306: LD_ADDR_EXP 154
36310: PUSH
36311: LD_EXP 154
36315: PPUSH
36316: LD_VAR 0 1
36320: PPUSH
36321: EMPTY
36322: PPUSH
36323: CALL_OW 1
36327: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36328: LD_ADDR_EXP 155
36332: PUSH
36333: LD_EXP 155
36337: PPUSH
36338: LD_VAR 0 1
36342: PPUSH
36343: EMPTY
36344: PPUSH
36345: CALL_OW 1
36349: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36350: LD_ADDR_EXP 156
36354: PUSH
36355: LD_EXP 156
36359: PPUSH
36360: LD_VAR 0 1
36364: PPUSH
36365: EMPTY
36366: PPUSH
36367: CALL_OW 1
36371: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36372: LD_ADDR_EXP 157
36376: PUSH
36377: LD_EXP 157
36381: PPUSH
36382: LD_VAR 0 1
36386: PPUSH
36387: EMPTY
36388: PPUSH
36389: CALL_OW 1
36393: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36394: LD_ADDR_EXP 158
36398: PUSH
36399: LD_EXP 158
36403: PPUSH
36404: LD_VAR 0 1
36408: PPUSH
36409: EMPTY
36410: PPUSH
36411: CALL_OW 1
36415: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36416: LD_ADDR_EXP 159
36420: PUSH
36421: LD_EXP 159
36425: PPUSH
36426: LD_VAR 0 1
36430: PPUSH
36431: LD_INT 0
36433: PPUSH
36434: CALL_OW 1
36438: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36439: LD_ADDR_EXP 160
36443: PUSH
36444: LD_EXP 160
36448: PPUSH
36449: LD_VAR 0 1
36453: PPUSH
36454: LD_INT 0
36456: PPUSH
36457: CALL_OW 1
36461: ST_TO_ADDR
// end ;
36462: LD_VAR 0 2
36466: RET
// export function MC_Add ( side , units ) ; var base ; begin
36467: LD_INT 0
36469: PPUSH
36470: PPUSH
// base := mc_bases + 1 ;
36471: LD_ADDR_VAR 0 4
36475: PUSH
36476: LD_EXP 117
36480: PUSH
36481: LD_INT 1
36483: PLUS
36484: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36485: LD_ADDR_EXP 143
36489: PUSH
36490: LD_EXP 143
36494: PPUSH
36495: LD_VAR 0 4
36499: PPUSH
36500: LD_VAR 0 1
36504: PPUSH
36505: CALL_OW 1
36509: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36510: LD_ADDR_EXP 117
36514: PUSH
36515: LD_EXP 117
36519: PPUSH
36520: LD_VAR 0 4
36524: PPUSH
36525: LD_VAR 0 2
36529: PPUSH
36530: CALL_OW 1
36534: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36535: LD_ADDR_EXP 118
36539: PUSH
36540: LD_EXP 118
36544: PPUSH
36545: LD_VAR 0 4
36549: PPUSH
36550: EMPTY
36551: PPUSH
36552: CALL_OW 1
36556: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36557: LD_ADDR_EXP 119
36561: PUSH
36562: LD_EXP 119
36566: PPUSH
36567: LD_VAR 0 4
36571: PPUSH
36572: EMPTY
36573: PPUSH
36574: CALL_OW 1
36578: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36579: LD_ADDR_EXP 120
36583: PUSH
36584: LD_EXP 120
36588: PPUSH
36589: LD_VAR 0 4
36593: PPUSH
36594: EMPTY
36595: PPUSH
36596: CALL_OW 1
36600: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36601: LD_ADDR_EXP 121
36605: PUSH
36606: LD_EXP 121
36610: PPUSH
36611: LD_VAR 0 4
36615: PPUSH
36616: EMPTY
36617: PPUSH
36618: CALL_OW 1
36622: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36623: LD_ADDR_EXP 122
36627: PUSH
36628: LD_EXP 122
36632: PPUSH
36633: LD_VAR 0 4
36637: PPUSH
36638: EMPTY
36639: PPUSH
36640: CALL_OW 1
36644: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36645: LD_ADDR_EXP 123
36649: PUSH
36650: LD_EXP 123
36654: PPUSH
36655: LD_VAR 0 4
36659: PPUSH
36660: EMPTY
36661: PPUSH
36662: CALL_OW 1
36666: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36667: LD_ADDR_EXP 124
36671: PUSH
36672: LD_EXP 124
36676: PPUSH
36677: LD_VAR 0 4
36681: PPUSH
36682: EMPTY
36683: PPUSH
36684: CALL_OW 1
36688: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36689: LD_ADDR_EXP 125
36693: PUSH
36694: LD_EXP 125
36698: PPUSH
36699: LD_VAR 0 4
36703: PPUSH
36704: EMPTY
36705: PPUSH
36706: CALL_OW 1
36710: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36711: LD_ADDR_EXP 126
36715: PUSH
36716: LD_EXP 126
36720: PPUSH
36721: LD_VAR 0 4
36725: PPUSH
36726: EMPTY
36727: PPUSH
36728: CALL_OW 1
36732: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36733: LD_ADDR_EXP 127
36737: PUSH
36738: LD_EXP 127
36742: PPUSH
36743: LD_VAR 0 4
36747: PPUSH
36748: EMPTY
36749: PPUSH
36750: CALL_OW 1
36754: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36755: LD_ADDR_EXP 128
36759: PUSH
36760: LD_EXP 128
36764: PPUSH
36765: LD_VAR 0 4
36769: PPUSH
36770: LD_INT 0
36772: PPUSH
36773: CALL_OW 1
36777: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36778: LD_ADDR_EXP 129
36782: PUSH
36783: LD_EXP 129
36787: PPUSH
36788: LD_VAR 0 4
36792: PPUSH
36793: EMPTY
36794: PPUSH
36795: CALL_OW 1
36799: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36800: LD_ADDR_EXP 130
36804: PUSH
36805: LD_EXP 130
36809: PPUSH
36810: LD_VAR 0 4
36814: PPUSH
36815: EMPTY
36816: PPUSH
36817: CALL_OW 1
36821: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36822: LD_ADDR_EXP 131
36826: PUSH
36827: LD_EXP 131
36831: PPUSH
36832: LD_VAR 0 4
36836: PPUSH
36837: EMPTY
36838: PPUSH
36839: CALL_OW 1
36843: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36844: LD_ADDR_EXP 132
36848: PUSH
36849: LD_EXP 132
36853: PPUSH
36854: LD_VAR 0 4
36858: PPUSH
36859: EMPTY
36860: PPUSH
36861: CALL_OW 1
36865: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36866: LD_ADDR_EXP 133
36870: PUSH
36871: LD_EXP 133
36875: PPUSH
36876: LD_VAR 0 4
36880: PPUSH
36881: EMPTY
36882: PPUSH
36883: CALL_OW 1
36887: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36888: LD_ADDR_EXP 134
36892: PUSH
36893: LD_EXP 134
36897: PPUSH
36898: LD_VAR 0 4
36902: PPUSH
36903: EMPTY
36904: PPUSH
36905: CALL_OW 1
36909: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36910: LD_ADDR_EXP 135
36914: PUSH
36915: LD_EXP 135
36919: PPUSH
36920: LD_VAR 0 4
36924: PPUSH
36925: EMPTY
36926: PPUSH
36927: CALL_OW 1
36931: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36932: LD_ADDR_EXP 136
36936: PUSH
36937: LD_EXP 136
36941: PPUSH
36942: LD_VAR 0 4
36946: PPUSH
36947: EMPTY
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36954: LD_ADDR_EXP 137
36958: PUSH
36959: LD_EXP 137
36963: PPUSH
36964: LD_VAR 0 4
36968: PPUSH
36969: EMPTY
36970: PPUSH
36971: CALL_OW 1
36975: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36976: LD_ADDR_EXP 138
36980: PUSH
36981: LD_EXP 138
36985: PPUSH
36986: LD_VAR 0 4
36990: PPUSH
36991: EMPTY
36992: PPUSH
36993: CALL_OW 1
36997: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36998: LD_ADDR_EXP 139
37002: PUSH
37003: LD_EXP 139
37007: PPUSH
37008: LD_VAR 0 4
37012: PPUSH
37013: EMPTY
37014: PPUSH
37015: CALL_OW 1
37019: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37020: LD_ADDR_EXP 140
37024: PUSH
37025: LD_EXP 140
37029: PPUSH
37030: LD_VAR 0 4
37034: PPUSH
37035: EMPTY
37036: PPUSH
37037: CALL_OW 1
37041: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37042: LD_ADDR_EXP 141
37046: PUSH
37047: LD_EXP 141
37051: PPUSH
37052: LD_VAR 0 4
37056: PPUSH
37057: EMPTY
37058: PPUSH
37059: CALL_OW 1
37063: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37064: LD_ADDR_EXP 142
37068: PUSH
37069: LD_EXP 142
37073: PPUSH
37074: LD_VAR 0 4
37078: PPUSH
37079: EMPTY
37080: PPUSH
37081: CALL_OW 1
37085: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37086: LD_ADDR_EXP 144
37090: PUSH
37091: LD_EXP 144
37095: PPUSH
37096: LD_VAR 0 4
37100: PPUSH
37101: EMPTY
37102: PPUSH
37103: CALL_OW 1
37107: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37108: LD_ADDR_EXP 146
37112: PUSH
37113: LD_EXP 146
37117: PPUSH
37118: LD_VAR 0 4
37122: PPUSH
37123: EMPTY
37124: PPUSH
37125: CALL_OW 1
37129: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37130: LD_ADDR_EXP 147
37134: PUSH
37135: LD_EXP 147
37139: PPUSH
37140: LD_VAR 0 4
37144: PPUSH
37145: EMPTY
37146: PPUSH
37147: CALL_OW 1
37151: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37152: LD_ADDR_EXP 148
37156: PUSH
37157: LD_EXP 148
37161: PPUSH
37162: LD_VAR 0 4
37166: PPUSH
37167: EMPTY
37168: PPUSH
37169: CALL_OW 1
37173: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37174: LD_ADDR_EXP 149
37178: PUSH
37179: LD_EXP 149
37183: PPUSH
37184: LD_VAR 0 4
37188: PPUSH
37189: EMPTY
37190: PPUSH
37191: CALL_OW 1
37195: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37196: LD_ADDR_EXP 150
37200: PUSH
37201: LD_EXP 150
37205: PPUSH
37206: LD_VAR 0 4
37210: PPUSH
37211: EMPTY
37212: PPUSH
37213: CALL_OW 1
37217: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37218: LD_ADDR_EXP 151
37222: PUSH
37223: LD_EXP 151
37227: PPUSH
37228: LD_VAR 0 4
37232: PPUSH
37233: EMPTY
37234: PPUSH
37235: CALL_OW 1
37239: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37240: LD_ADDR_EXP 152
37244: PUSH
37245: LD_EXP 152
37249: PPUSH
37250: LD_VAR 0 4
37254: PPUSH
37255: EMPTY
37256: PPUSH
37257: CALL_OW 1
37261: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37262: LD_ADDR_EXP 153
37266: PUSH
37267: LD_EXP 153
37271: PPUSH
37272: LD_VAR 0 4
37276: PPUSH
37277: EMPTY
37278: PPUSH
37279: CALL_OW 1
37283: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37284: LD_ADDR_EXP 154
37288: PUSH
37289: LD_EXP 154
37293: PPUSH
37294: LD_VAR 0 4
37298: PPUSH
37299: EMPTY
37300: PPUSH
37301: CALL_OW 1
37305: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37306: LD_ADDR_EXP 155
37310: PUSH
37311: LD_EXP 155
37315: PPUSH
37316: LD_VAR 0 4
37320: PPUSH
37321: EMPTY
37322: PPUSH
37323: CALL_OW 1
37327: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37328: LD_ADDR_EXP 156
37332: PUSH
37333: LD_EXP 156
37337: PPUSH
37338: LD_VAR 0 4
37342: PPUSH
37343: EMPTY
37344: PPUSH
37345: CALL_OW 1
37349: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37350: LD_ADDR_EXP 157
37354: PUSH
37355: LD_EXP 157
37359: PPUSH
37360: LD_VAR 0 4
37364: PPUSH
37365: EMPTY
37366: PPUSH
37367: CALL_OW 1
37371: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37372: LD_ADDR_EXP 158
37376: PUSH
37377: LD_EXP 158
37381: PPUSH
37382: LD_VAR 0 4
37386: PPUSH
37387: EMPTY
37388: PPUSH
37389: CALL_OW 1
37393: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37394: LD_ADDR_EXP 159
37398: PUSH
37399: LD_EXP 159
37403: PPUSH
37404: LD_VAR 0 4
37408: PPUSH
37409: LD_INT 0
37411: PPUSH
37412: CALL_OW 1
37416: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37417: LD_ADDR_EXP 160
37421: PUSH
37422: LD_EXP 160
37426: PPUSH
37427: LD_VAR 0 4
37431: PPUSH
37432: LD_INT 0
37434: PPUSH
37435: CALL_OW 1
37439: ST_TO_ADDR
// result := base ;
37440: LD_ADDR_VAR 0 3
37444: PUSH
37445: LD_VAR 0 4
37449: ST_TO_ADDR
// end ;
37450: LD_VAR 0 3
37454: RET
// export function MC_Start ( ) ; var i ; begin
37455: LD_INT 0
37457: PPUSH
37458: PPUSH
// for i = 1 to mc_bases do
37459: LD_ADDR_VAR 0 2
37463: PUSH
37464: DOUBLE
37465: LD_INT 1
37467: DEC
37468: ST_TO_ADDR
37469: LD_EXP 117
37473: PUSH
37474: FOR_TO
37475: IFFALSE 38575
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37477: LD_ADDR_EXP 117
37481: PUSH
37482: LD_EXP 117
37486: PPUSH
37487: LD_VAR 0 2
37491: PPUSH
37492: LD_EXP 117
37496: PUSH
37497: LD_VAR 0 2
37501: ARRAY
37502: PUSH
37503: LD_INT 0
37505: DIFF
37506: PPUSH
37507: CALL_OW 1
37511: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37512: LD_ADDR_EXP 118
37516: PUSH
37517: LD_EXP 118
37521: PPUSH
37522: LD_VAR 0 2
37526: PPUSH
37527: EMPTY
37528: PPUSH
37529: CALL_OW 1
37533: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37534: LD_ADDR_EXP 119
37538: PUSH
37539: LD_EXP 119
37543: PPUSH
37544: LD_VAR 0 2
37548: PPUSH
37549: EMPTY
37550: PPUSH
37551: CALL_OW 1
37555: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37556: LD_ADDR_EXP 120
37560: PUSH
37561: LD_EXP 120
37565: PPUSH
37566: LD_VAR 0 2
37570: PPUSH
37571: EMPTY
37572: PPUSH
37573: CALL_OW 1
37577: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37578: LD_ADDR_EXP 121
37582: PUSH
37583: LD_EXP 121
37587: PPUSH
37588: LD_VAR 0 2
37592: PPUSH
37593: EMPTY
37594: PUSH
37595: EMPTY
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PPUSH
37601: CALL_OW 1
37605: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37606: LD_ADDR_EXP 122
37610: PUSH
37611: LD_EXP 122
37615: PPUSH
37616: LD_VAR 0 2
37620: PPUSH
37621: EMPTY
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37628: LD_ADDR_EXP 149
37632: PUSH
37633: LD_EXP 149
37637: PPUSH
37638: LD_VAR 0 2
37642: PPUSH
37643: EMPTY
37644: PPUSH
37645: CALL_OW 1
37649: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37650: LD_ADDR_EXP 123
37654: PUSH
37655: LD_EXP 123
37659: PPUSH
37660: LD_VAR 0 2
37664: PPUSH
37665: EMPTY
37666: PPUSH
37667: CALL_OW 1
37671: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37672: LD_ADDR_EXP 124
37676: PUSH
37677: LD_EXP 124
37681: PPUSH
37682: LD_VAR 0 2
37686: PPUSH
37687: EMPTY
37688: PPUSH
37689: CALL_OW 1
37693: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37694: LD_ADDR_EXP 125
37698: PUSH
37699: LD_EXP 125
37703: PPUSH
37704: LD_VAR 0 2
37708: PPUSH
37709: LD_EXP 117
37713: PUSH
37714: LD_VAR 0 2
37718: ARRAY
37719: PPUSH
37720: LD_INT 2
37722: PUSH
37723: LD_INT 30
37725: PUSH
37726: LD_INT 32
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 30
37735: PUSH
37736: LD_INT 33
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: LIST
37747: PPUSH
37748: CALL_OW 72
37752: PPUSH
37753: CALL_OW 1
37757: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37758: LD_ADDR_EXP 126
37762: PUSH
37763: LD_EXP 126
37767: PPUSH
37768: LD_VAR 0 2
37772: PPUSH
37773: LD_EXP 117
37777: PUSH
37778: LD_VAR 0 2
37782: ARRAY
37783: PPUSH
37784: LD_INT 2
37786: PUSH
37787: LD_INT 30
37789: PUSH
37790: LD_INT 32
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: PUSH
37797: LD_INT 30
37799: PUSH
37800: LD_INT 31
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 58
37814: PUSH
37815: EMPTY
37816: LIST
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PPUSH
37822: CALL_OW 72
37826: PPUSH
37827: CALL_OW 1
37831: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37832: LD_ADDR_EXP 127
37836: PUSH
37837: LD_EXP 127
37841: PPUSH
37842: LD_VAR 0 2
37846: PPUSH
37847: EMPTY
37848: PPUSH
37849: CALL_OW 1
37853: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37854: LD_ADDR_EXP 131
37858: PUSH
37859: LD_EXP 131
37863: PPUSH
37864: LD_VAR 0 2
37868: PPUSH
37869: EMPTY
37870: PPUSH
37871: CALL_OW 1
37875: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37876: LD_ADDR_EXP 130
37880: PUSH
37881: LD_EXP 130
37885: PPUSH
37886: LD_VAR 0 2
37890: PPUSH
37891: EMPTY
37892: PPUSH
37893: CALL_OW 1
37897: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37898: LD_ADDR_EXP 132
37902: PUSH
37903: LD_EXP 132
37907: PPUSH
37908: LD_VAR 0 2
37912: PPUSH
37913: EMPTY
37914: PPUSH
37915: CALL_OW 1
37919: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37920: LD_ADDR_EXP 133
37924: PUSH
37925: LD_EXP 133
37929: PPUSH
37930: LD_VAR 0 2
37934: PPUSH
37935: EMPTY
37936: PPUSH
37937: CALL_OW 1
37941: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37942: LD_ADDR_EXP 134
37946: PUSH
37947: LD_EXP 134
37951: PPUSH
37952: LD_VAR 0 2
37956: PPUSH
37957: EMPTY
37958: PPUSH
37959: CALL_OW 1
37963: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37964: LD_ADDR_EXP 135
37968: PUSH
37969: LD_EXP 135
37973: PPUSH
37974: LD_VAR 0 2
37978: PPUSH
37979: EMPTY
37980: PPUSH
37981: CALL_OW 1
37985: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37986: LD_ADDR_EXP 136
37990: PUSH
37991: LD_EXP 136
37995: PPUSH
37996: LD_VAR 0 2
38000: PPUSH
38001: EMPTY
38002: PPUSH
38003: CALL_OW 1
38007: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38008: LD_ADDR_EXP 137
38012: PUSH
38013: LD_EXP 137
38017: PPUSH
38018: LD_VAR 0 2
38022: PPUSH
38023: EMPTY
38024: PPUSH
38025: CALL_OW 1
38029: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
38030: LD_ADDR_EXP 138
38034: PUSH
38035: LD_EXP 138
38039: PPUSH
38040: LD_VAR 0 2
38044: PPUSH
38045: EMPTY
38046: PPUSH
38047: CALL_OW 1
38051: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38052: LD_ADDR_EXP 139
38056: PUSH
38057: LD_EXP 139
38061: PPUSH
38062: LD_VAR 0 2
38066: PPUSH
38067: EMPTY
38068: PPUSH
38069: CALL_OW 1
38073: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38074: LD_ADDR_EXP 128
38078: PUSH
38079: LD_EXP 128
38083: PPUSH
38084: LD_VAR 0 2
38088: PPUSH
38089: LD_INT 0
38091: PPUSH
38092: CALL_OW 1
38096: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38097: LD_ADDR_EXP 141
38101: PUSH
38102: LD_EXP 141
38106: PPUSH
38107: LD_VAR 0 2
38111: PPUSH
38112: LD_INT 0
38114: PPUSH
38115: CALL_OW 1
38119: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38120: LD_ADDR_EXP 129
38124: PUSH
38125: LD_EXP 129
38129: PPUSH
38130: LD_VAR 0 2
38134: PPUSH
38135: EMPTY
38136: PPUSH
38137: CALL_OW 1
38141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38142: LD_ADDR_EXP 140
38146: PUSH
38147: LD_EXP 140
38151: PPUSH
38152: LD_VAR 0 2
38156: PPUSH
38157: LD_INT 0
38159: PPUSH
38160: CALL_OW 1
38164: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38165: LD_ADDR_EXP 142
38169: PUSH
38170: LD_EXP 142
38174: PPUSH
38175: LD_VAR 0 2
38179: PPUSH
38180: EMPTY
38181: PPUSH
38182: CALL_OW 1
38186: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38187: LD_ADDR_EXP 145
38191: PUSH
38192: LD_EXP 145
38196: PPUSH
38197: LD_VAR 0 2
38201: PPUSH
38202: LD_INT 0
38204: PPUSH
38205: CALL_OW 1
38209: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38210: LD_ADDR_EXP 146
38214: PUSH
38215: LD_EXP 146
38219: PPUSH
38220: LD_VAR 0 2
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL_OW 1
38231: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38232: LD_ADDR_EXP 147
38236: PUSH
38237: LD_EXP 147
38241: PPUSH
38242: LD_VAR 0 2
38246: PPUSH
38247: EMPTY
38248: PPUSH
38249: CALL_OW 1
38253: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38254: LD_ADDR_EXP 148
38258: PUSH
38259: LD_EXP 148
38263: PPUSH
38264: LD_VAR 0 2
38268: PPUSH
38269: EMPTY
38270: PPUSH
38271: CALL_OW 1
38275: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38276: LD_ADDR_EXP 150
38280: PUSH
38281: LD_EXP 150
38285: PPUSH
38286: LD_VAR 0 2
38290: PPUSH
38291: LD_EXP 117
38295: PUSH
38296: LD_VAR 0 2
38300: ARRAY
38301: PPUSH
38302: LD_INT 2
38304: PUSH
38305: LD_INT 30
38307: PUSH
38308: LD_INT 6
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 30
38317: PUSH
38318: LD_INT 7
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 30
38327: PUSH
38328: LD_INT 8
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: PPUSH
38341: CALL_OW 72
38345: PPUSH
38346: CALL_OW 1
38350: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38351: LD_ADDR_EXP 151
38355: PUSH
38356: LD_EXP 151
38360: PPUSH
38361: LD_VAR 0 2
38365: PPUSH
38366: EMPTY
38367: PPUSH
38368: CALL_OW 1
38372: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38373: LD_ADDR_EXP 152
38377: PUSH
38378: LD_EXP 152
38382: PPUSH
38383: LD_VAR 0 2
38387: PPUSH
38388: EMPTY
38389: PPUSH
38390: CALL_OW 1
38394: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38395: LD_ADDR_EXP 153
38399: PUSH
38400: LD_EXP 153
38404: PPUSH
38405: LD_VAR 0 2
38409: PPUSH
38410: EMPTY
38411: PPUSH
38412: CALL_OW 1
38416: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38417: LD_ADDR_EXP 154
38421: PUSH
38422: LD_EXP 154
38426: PPUSH
38427: LD_VAR 0 2
38431: PPUSH
38432: EMPTY
38433: PPUSH
38434: CALL_OW 1
38438: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38439: LD_ADDR_EXP 155
38443: PUSH
38444: LD_EXP 155
38448: PPUSH
38449: LD_VAR 0 2
38453: PPUSH
38454: EMPTY
38455: PPUSH
38456: CALL_OW 1
38460: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38461: LD_ADDR_EXP 156
38465: PUSH
38466: LD_EXP 156
38470: PPUSH
38471: LD_VAR 0 2
38475: PPUSH
38476: EMPTY
38477: PPUSH
38478: CALL_OW 1
38482: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38483: LD_ADDR_EXP 157
38487: PUSH
38488: LD_EXP 157
38492: PPUSH
38493: LD_VAR 0 2
38497: PPUSH
38498: EMPTY
38499: PPUSH
38500: CALL_OW 1
38504: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38505: LD_ADDR_EXP 158
38509: PUSH
38510: LD_EXP 158
38514: PPUSH
38515: LD_VAR 0 2
38519: PPUSH
38520: EMPTY
38521: PPUSH
38522: CALL_OW 1
38526: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38527: LD_ADDR_EXP 159
38531: PUSH
38532: LD_EXP 159
38536: PPUSH
38537: LD_VAR 0 2
38541: PPUSH
38542: LD_INT 0
38544: PPUSH
38545: CALL_OW 1
38549: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38550: LD_ADDR_EXP 160
38554: PUSH
38555: LD_EXP 160
38559: PPUSH
38560: LD_VAR 0 2
38564: PPUSH
38565: LD_INT 0
38567: PPUSH
38568: CALL_OW 1
38572: ST_TO_ADDR
// end ;
38573: GO 37474
38575: POP
38576: POP
// MC_InitSides ( ) ;
38577: CALL 38863 0 0
// MC_InitResearch ( ) ;
38581: CALL 38602 0 0
// CustomInitMacro ( ) ;
38585: CALL 471 0 0
// skirmish := true ;
38589: LD_ADDR_EXP 115
38593: PUSH
38594: LD_INT 1
38596: ST_TO_ADDR
// end ;
38597: LD_VAR 0 1
38601: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38602: LD_INT 0
38604: PPUSH
38605: PPUSH
38606: PPUSH
38607: PPUSH
38608: PPUSH
38609: PPUSH
// if not mc_bases then
38610: LD_EXP 117
38614: NOT
38615: IFFALSE 38619
// exit ;
38617: GO 38858
// for i = 1 to 8 do
38619: LD_ADDR_VAR 0 2
38623: PUSH
38624: DOUBLE
38625: LD_INT 1
38627: DEC
38628: ST_TO_ADDR
38629: LD_INT 8
38631: PUSH
38632: FOR_TO
38633: IFFALSE 38659
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38635: LD_ADDR_EXP 144
38639: PUSH
38640: LD_EXP 144
38644: PPUSH
38645: LD_VAR 0 2
38649: PPUSH
38650: EMPTY
38651: PPUSH
38652: CALL_OW 1
38656: ST_TO_ADDR
38657: GO 38632
38659: POP
38660: POP
// tmp := [ ] ;
38661: LD_ADDR_VAR 0 5
38665: PUSH
38666: EMPTY
38667: ST_TO_ADDR
// for i = 1 to mc_sides do
38668: LD_ADDR_VAR 0 2
38672: PUSH
38673: DOUBLE
38674: LD_INT 1
38676: DEC
38677: ST_TO_ADDR
38678: LD_EXP 143
38682: PUSH
38683: FOR_TO
38684: IFFALSE 38742
// if not mc_sides [ i ] in tmp then
38686: LD_EXP 143
38690: PUSH
38691: LD_VAR 0 2
38695: ARRAY
38696: PUSH
38697: LD_VAR 0 5
38701: IN
38702: NOT
38703: IFFALSE 38740
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38705: LD_ADDR_VAR 0 5
38709: PUSH
38710: LD_VAR 0 5
38714: PPUSH
38715: LD_VAR 0 5
38719: PUSH
38720: LD_INT 1
38722: PLUS
38723: PPUSH
38724: LD_EXP 143
38728: PUSH
38729: LD_VAR 0 2
38733: ARRAY
38734: PPUSH
38735: CALL_OW 2
38739: ST_TO_ADDR
38740: GO 38683
38742: POP
38743: POP
// if not tmp then
38744: LD_VAR 0 5
38748: NOT
38749: IFFALSE 38753
// exit ;
38751: GO 38858
// for j in tmp do
38753: LD_ADDR_VAR 0 3
38757: PUSH
38758: LD_VAR 0 5
38762: PUSH
38763: FOR_IN
38764: IFFALSE 38856
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38766: LD_ADDR_VAR 0 6
38770: PUSH
38771: LD_INT 22
38773: PUSH
38774: LD_VAR 0 3
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PPUSH
38783: CALL_OW 69
38787: ST_TO_ADDR
// if not un then
38788: LD_VAR 0 6
38792: NOT
38793: IFFALSE 38797
// continue ;
38795: GO 38763
// nation := GetNation ( un [ 1 ] ) ;
38797: LD_ADDR_VAR 0 4
38801: PUSH
38802: LD_VAR 0 6
38806: PUSH
38807: LD_INT 1
38809: ARRAY
38810: PPUSH
38811: CALL_OW 248
38815: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38816: LD_ADDR_EXP 144
38820: PUSH
38821: LD_EXP 144
38825: PPUSH
38826: LD_VAR 0 3
38830: PPUSH
38831: LD_VAR 0 3
38835: PPUSH
38836: LD_VAR 0 4
38840: PPUSH
38841: LD_INT 1
38843: PPUSH
38844: CALL 65979 0 3
38848: PPUSH
38849: CALL_OW 1
38853: ST_TO_ADDR
// end ;
38854: GO 38763
38856: POP
38857: POP
// end ;
38858: LD_VAR 0 1
38862: RET
// export function MC_InitSides ( ) ; var i ; begin
38863: LD_INT 0
38865: PPUSH
38866: PPUSH
// if not mc_bases then
38867: LD_EXP 117
38871: NOT
38872: IFFALSE 38876
// exit ;
38874: GO 38950
// for i = 1 to mc_bases do
38876: LD_ADDR_VAR 0 2
38880: PUSH
38881: DOUBLE
38882: LD_INT 1
38884: DEC
38885: ST_TO_ADDR
38886: LD_EXP 117
38890: PUSH
38891: FOR_TO
38892: IFFALSE 38948
// if mc_bases [ i ] then
38894: LD_EXP 117
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: IFFALSE 38946
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38906: LD_ADDR_EXP 143
38910: PUSH
38911: LD_EXP 143
38915: PPUSH
38916: LD_VAR 0 2
38920: PPUSH
38921: LD_EXP 117
38925: PUSH
38926: LD_VAR 0 2
38930: ARRAY
38931: PUSH
38932: LD_INT 1
38934: ARRAY
38935: PPUSH
38936: CALL_OW 255
38940: PPUSH
38941: CALL_OW 1
38945: ST_TO_ADDR
38946: GO 38891
38948: POP
38949: POP
// end ;
38950: LD_VAR 0 1
38954: RET
// every 0 0$03 trigger skirmish do
38955: LD_EXP 115
38959: IFFALSE 39113
38961: GO 38963
38963: DISABLE
// begin enable ;
38964: ENABLE
// MC_CheckBuildings ( ) ;
38965: CALL 43611 0 0
// MC_CheckPeopleLife ( ) ;
38969: CALL 43772 0 0
// RaiseSailEvent ( 100 ) ;
38973: LD_INT 100
38975: PPUSH
38976: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38980: LD_INT 103
38982: PPUSH
38983: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38987: LD_INT 104
38989: PPUSH
38990: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38994: LD_INT 105
38996: PPUSH
38997: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
39001: LD_INT 106
39003: PPUSH
39004: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
39008: LD_INT 107
39010: PPUSH
39011: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
39015: LD_INT 108
39017: PPUSH
39018: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
39022: LD_INT 109
39024: PPUSH
39025: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
39029: LD_INT 110
39031: PPUSH
39032: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
39036: LD_INT 111
39038: PPUSH
39039: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39043: LD_INT 112
39045: PPUSH
39046: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39050: LD_INT 113
39052: PPUSH
39053: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39057: LD_INT 120
39059: PPUSH
39060: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39064: LD_INT 121
39066: PPUSH
39067: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39071: LD_INT 122
39073: PPUSH
39074: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39078: LD_INT 123
39080: PPUSH
39081: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39085: LD_INT 124
39087: PPUSH
39088: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39092: LD_INT 125
39094: PPUSH
39095: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39099: LD_INT 126
39101: PPUSH
39102: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39106: LD_INT 200
39108: PPUSH
39109: CALL_OW 427
// end ;
39113: END
// on SailEvent ( event ) do begin if event < 100 then
39114: LD_VAR 0 1
39118: PUSH
39119: LD_INT 100
39121: LESS
39122: IFFALSE 39133
// CustomEvent ( event ) ;
39124: LD_VAR 0 1
39128: PPUSH
39129: CALL 33558 0 1
// if event = 100 then
39133: LD_VAR 0 1
39137: PUSH
39138: LD_INT 100
39140: EQUAL
39141: IFFALSE 39147
// MC_ClassManager ( ) ;
39143: CALL 39539 0 0
// if event = 101 then
39147: LD_VAR 0 1
39151: PUSH
39152: LD_INT 101
39154: EQUAL
39155: IFFALSE 39161
// MC_RepairBuildings ( ) ;
39157: CALL 44357 0 0
// if event = 102 then
39161: LD_VAR 0 1
39165: PUSH
39166: LD_INT 102
39168: EQUAL
39169: IFFALSE 39175
// MC_Heal ( ) ;
39171: CALL 45264 0 0
// if event = 103 then
39175: LD_VAR 0 1
39179: PUSH
39180: LD_INT 103
39182: EQUAL
39183: IFFALSE 39189
// MC_Build ( ) ;
39185: CALL 45686 0 0
// if event = 104 then
39189: LD_VAR 0 1
39193: PUSH
39194: LD_INT 104
39196: EQUAL
39197: IFFALSE 39203
// MC_TurretWeapon ( ) ;
39199: CALL 47327 0 0
// if event = 105 then
39203: LD_VAR 0 1
39207: PUSH
39208: LD_INT 105
39210: EQUAL
39211: IFFALSE 39217
// MC_BuildUpgrade ( ) ;
39213: CALL 46878 0 0
// if event = 106 then
39217: LD_VAR 0 1
39221: PUSH
39222: LD_INT 106
39224: EQUAL
39225: IFFALSE 39231
// MC_PlantMines ( ) ;
39227: CALL 47757 0 0
// if event = 107 then
39231: LD_VAR 0 1
39235: PUSH
39236: LD_INT 107
39238: EQUAL
39239: IFFALSE 39245
// MC_CollectCrates ( ) ;
39241: CALL 48548 0 0
// if event = 108 then
39245: LD_VAR 0 1
39249: PUSH
39250: LD_INT 108
39252: EQUAL
39253: IFFALSE 39259
// MC_LinkRemoteControl ( ) ;
39255: CALL 50398 0 0
// if event = 109 then
39259: LD_VAR 0 1
39263: PUSH
39264: LD_INT 109
39266: EQUAL
39267: IFFALSE 39273
// MC_ProduceVehicle ( ) ;
39269: CALL 50579 0 0
// if event = 110 then
39273: LD_VAR 0 1
39277: PUSH
39278: LD_INT 110
39280: EQUAL
39281: IFFALSE 39287
// MC_SendAttack ( ) ;
39283: CALL 51045 0 0
// if event = 111 then
39287: LD_VAR 0 1
39291: PUSH
39292: LD_INT 111
39294: EQUAL
39295: IFFALSE 39301
// MC_Defend ( ) ;
39297: CALL 51153 0 0
// if event = 112 then
39301: LD_VAR 0 1
39305: PUSH
39306: LD_INT 112
39308: EQUAL
39309: IFFALSE 39315
// MC_Research ( ) ;
39311: CALL 52033 0 0
// if event = 113 then
39315: LD_VAR 0 1
39319: PUSH
39320: LD_INT 113
39322: EQUAL
39323: IFFALSE 39329
// MC_MinesTrigger ( ) ;
39325: CALL 53147 0 0
// if event = 120 then
39329: LD_VAR 0 1
39333: PUSH
39334: LD_INT 120
39336: EQUAL
39337: IFFALSE 39343
// MC_RepairVehicle ( ) ;
39339: CALL 53246 0 0
// if event = 121 then
39343: LD_VAR 0 1
39347: PUSH
39348: LD_INT 121
39350: EQUAL
39351: IFFALSE 39357
// MC_TameApe ( ) ;
39353: CALL 53987 0 0
// if event = 122 then
39357: LD_VAR 0 1
39361: PUSH
39362: LD_INT 122
39364: EQUAL
39365: IFFALSE 39371
// MC_ChangeApeClass ( ) ;
39367: CALL 54816 0 0
// if event = 123 then
39371: LD_VAR 0 1
39375: PUSH
39376: LD_INT 123
39378: EQUAL
39379: IFFALSE 39385
// MC_Bazooka ( ) ;
39381: CALL 55466 0 0
// if event = 124 then
39385: LD_VAR 0 1
39389: PUSH
39390: LD_INT 124
39392: EQUAL
39393: IFFALSE 39399
// MC_TeleportExit ( ) ;
39395: CALL 55664 0 0
// if event = 125 then
39399: LD_VAR 0 1
39403: PUSH
39404: LD_INT 125
39406: EQUAL
39407: IFFALSE 39413
// MC_Deposits ( ) ;
39409: CALL 56311 0 0
// if event = 126 then
39413: LD_VAR 0 1
39417: PUSH
39418: LD_INT 126
39420: EQUAL
39421: IFFALSE 39427
// MC_RemoteDriver ( ) ;
39423: CALL 56936 0 0
// if event = 200 then
39427: LD_VAR 0 1
39431: PUSH
39432: LD_INT 200
39434: EQUAL
39435: IFFALSE 39441
// MC_Idle ( ) ;
39437: CALL 58885 0 0
// end ;
39441: PPOPN 1
39443: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39444: LD_INT 0
39446: PPUSH
39447: PPUSH
// if not mc_bases [ base ] or not tag then
39448: LD_EXP 117
39452: PUSH
39453: LD_VAR 0 1
39457: ARRAY
39458: NOT
39459: PUSH
39460: LD_VAR 0 2
39464: NOT
39465: OR
39466: IFFALSE 39470
// exit ;
39468: GO 39534
// for i in mc_bases [ base ] union mc_ape [ base ] do
39470: LD_ADDR_VAR 0 4
39474: PUSH
39475: LD_EXP 117
39479: PUSH
39480: LD_VAR 0 1
39484: ARRAY
39485: PUSH
39486: LD_EXP 146
39490: PUSH
39491: LD_VAR 0 1
39495: ARRAY
39496: UNION
39497: PUSH
39498: FOR_IN
39499: IFFALSE 39532
// if GetTag ( i ) = tag then
39501: LD_VAR 0 4
39505: PPUSH
39506: CALL_OW 110
39510: PUSH
39511: LD_VAR 0 2
39515: EQUAL
39516: IFFALSE 39530
// SetTag ( i , 0 ) ;
39518: LD_VAR 0 4
39522: PPUSH
39523: LD_INT 0
39525: PPUSH
39526: CALL_OW 109
39530: GO 39498
39532: POP
39533: POP
// end ;
39534: LD_VAR 0 3
39538: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39539: LD_INT 0
39541: PPUSH
39542: PPUSH
39543: PPUSH
39544: PPUSH
39545: PPUSH
39546: PPUSH
39547: PPUSH
39548: PPUSH
// if not mc_bases then
39549: LD_EXP 117
39553: NOT
39554: IFFALSE 39558
// exit ;
39556: GO 40016
// for i = 1 to mc_bases do
39558: LD_ADDR_VAR 0 2
39562: PUSH
39563: DOUBLE
39564: LD_INT 1
39566: DEC
39567: ST_TO_ADDR
39568: LD_EXP 117
39572: PUSH
39573: FOR_TO
39574: IFFALSE 40014
// begin tmp := MC_ClassCheckReq ( i ) ;
39576: LD_ADDR_VAR 0 4
39580: PUSH
39581: LD_VAR 0 2
39585: PPUSH
39586: CALL 40021 0 1
39590: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39591: LD_ADDR_EXP 158
39595: PUSH
39596: LD_EXP 158
39600: PPUSH
39601: LD_VAR 0 2
39605: PPUSH
39606: LD_VAR 0 4
39610: PPUSH
39611: CALL_OW 1
39615: ST_TO_ADDR
// if not tmp then
39616: LD_VAR 0 4
39620: NOT
39621: IFFALSE 39625
// continue ;
39623: GO 39573
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39625: LD_ADDR_VAR 0 6
39629: PUSH
39630: LD_EXP 117
39634: PUSH
39635: LD_VAR 0 2
39639: ARRAY
39640: PPUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 30
39646: PUSH
39647: LD_INT 4
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 30
39656: PUSH
39657: LD_INT 5
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: LIST
39668: PPUSH
39669: CALL_OW 72
39673: PUSH
39674: LD_EXP 117
39678: PUSH
39679: LD_VAR 0 2
39683: ARRAY
39684: PPUSH
39685: LD_INT 2
39687: PUSH
39688: LD_INT 30
39690: PUSH
39691: LD_INT 0
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 30
39700: PUSH
39701: LD_INT 1
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: LIST
39712: PPUSH
39713: CALL_OW 72
39717: PUSH
39718: LD_EXP 117
39722: PUSH
39723: LD_VAR 0 2
39727: ARRAY
39728: PPUSH
39729: LD_INT 30
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PPUSH
39739: CALL_OW 72
39743: PUSH
39744: LD_EXP 117
39748: PUSH
39749: LD_VAR 0 2
39753: ARRAY
39754: PPUSH
39755: LD_INT 2
39757: PUSH
39758: LD_INT 30
39760: PUSH
39761: LD_INT 6
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 30
39770: PUSH
39771: LD_INT 7
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 30
39780: PUSH
39781: LD_INT 8
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: PPUSH
39794: CALL_OW 72
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: ST_TO_ADDR
// for j = 1 to 4 do
39805: LD_ADDR_VAR 0 3
39809: PUSH
39810: DOUBLE
39811: LD_INT 1
39813: DEC
39814: ST_TO_ADDR
39815: LD_INT 4
39817: PUSH
39818: FOR_TO
39819: IFFALSE 40010
// begin if not tmp [ j ] then
39821: LD_VAR 0 4
39825: PUSH
39826: LD_VAR 0 3
39830: ARRAY
39831: NOT
39832: IFFALSE 39836
// continue ;
39834: GO 39818
// for p in tmp [ j ] do
39836: LD_ADDR_VAR 0 5
39840: PUSH
39841: LD_VAR 0 4
39845: PUSH
39846: LD_VAR 0 3
39850: ARRAY
39851: PUSH
39852: FOR_IN
39853: IFFALSE 40006
// begin if not b [ j ] then
39855: LD_VAR 0 6
39859: PUSH
39860: LD_VAR 0 3
39864: ARRAY
39865: NOT
39866: IFFALSE 39870
// break ;
39868: GO 40006
// e := 0 ;
39870: LD_ADDR_VAR 0 7
39874: PUSH
39875: LD_INT 0
39877: ST_TO_ADDR
// for k in b [ j ] do
39878: LD_ADDR_VAR 0 8
39882: PUSH
39883: LD_VAR 0 6
39887: PUSH
39888: LD_VAR 0 3
39892: ARRAY
39893: PUSH
39894: FOR_IN
39895: IFFALSE 39922
// if IsNotFull ( k ) then
39897: LD_VAR 0 8
39901: PPUSH
39902: CALL 68132 0 1
39906: IFFALSE 39920
// begin e := k ;
39908: LD_ADDR_VAR 0 7
39912: PUSH
39913: LD_VAR 0 8
39917: ST_TO_ADDR
// break ;
39918: GO 39922
// end ;
39920: GO 39894
39922: POP
39923: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39924: LD_VAR 0 7
39928: PUSH
39929: LD_VAR 0 5
39933: PPUSH
39934: LD_VAR 0 7
39938: PPUSH
39939: CALL 101243 0 2
39943: NOT
39944: AND
39945: IFFALSE 40004
// begin if IsInUnit ( p ) then
39947: LD_VAR 0 5
39951: PPUSH
39952: CALL_OW 310
39956: IFFALSE 39967
// ComExitBuilding ( p ) ;
39958: LD_VAR 0 5
39962: PPUSH
39963: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39967: LD_VAR 0 5
39971: PPUSH
39972: LD_VAR 0 7
39976: PPUSH
39977: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39981: LD_VAR 0 5
39985: PPUSH
39986: LD_VAR 0 3
39990: PPUSH
39991: CALL_OW 183
// AddComExitBuilding ( p ) ;
39995: LD_VAR 0 5
39999: PPUSH
40000: CALL_OW 182
// end ; end ;
40004: GO 39852
40006: POP
40007: POP
// end ;
40008: GO 39818
40010: POP
40011: POP
// end ;
40012: GO 39573
40014: POP
40015: POP
// end ;
40016: LD_VAR 0 1
40020: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
40021: LD_INT 0
40023: PPUSH
40024: PPUSH
40025: PPUSH
40026: PPUSH
40027: PPUSH
40028: PPUSH
40029: PPUSH
40030: PPUSH
40031: PPUSH
40032: PPUSH
40033: PPUSH
40034: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40035: LD_VAR 0 1
40039: NOT
40040: PUSH
40041: LD_EXP 117
40045: PUSH
40046: LD_VAR 0 1
40050: ARRAY
40051: NOT
40052: OR
40053: PUSH
40054: LD_EXP 117
40058: PUSH
40059: LD_VAR 0 1
40063: ARRAY
40064: PPUSH
40065: LD_INT 2
40067: PUSH
40068: LD_INT 30
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 30
40080: PUSH
40081: LD_INT 1
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: LIST
40092: PPUSH
40093: CALL_OW 72
40097: NOT
40098: OR
40099: IFFALSE 40103
// exit ;
40101: GO 43606
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40103: LD_ADDR_VAR 0 4
40107: PUSH
40108: LD_EXP 117
40112: PUSH
40113: LD_VAR 0 1
40117: ARRAY
40118: PPUSH
40119: LD_INT 2
40121: PUSH
40122: LD_INT 25
40124: PUSH
40125: LD_INT 1
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 25
40134: PUSH
40135: LD_INT 2
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 25
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 25
40154: PUSH
40155: LD_INT 4
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 25
40164: PUSH
40165: LD_INT 5
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 25
40174: PUSH
40175: LD_INT 8
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 25
40184: PUSH
40185: LD_INT 9
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: PPUSH
40202: CALL_OW 72
40206: ST_TO_ADDR
// if not tmp then
40207: LD_VAR 0 4
40211: NOT
40212: IFFALSE 40216
// exit ;
40214: GO 43606
// for i in tmp do
40216: LD_ADDR_VAR 0 3
40220: PUSH
40221: LD_VAR 0 4
40225: PUSH
40226: FOR_IN
40227: IFFALSE 40258
// if GetTag ( i ) then
40229: LD_VAR 0 3
40233: PPUSH
40234: CALL_OW 110
40238: IFFALSE 40256
// tmp := tmp diff i ;
40240: LD_ADDR_VAR 0 4
40244: PUSH
40245: LD_VAR 0 4
40249: PUSH
40250: LD_VAR 0 3
40254: DIFF
40255: ST_TO_ADDR
40256: GO 40226
40258: POP
40259: POP
// if not tmp then
40260: LD_VAR 0 4
40264: NOT
40265: IFFALSE 40269
// exit ;
40267: GO 43606
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40269: LD_ADDR_VAR 0 5
40273: PUSH
40274: LD_EXP 117
40278: PUSH
40279: LD_VAR 0 1
40283: ARRAY
40284: PPUSH
40285: LD_INT 2
40287: PUSH
40288: LD_INT 25
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 25
40300: PUSH
40301: LD_INT 5
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 25
40310: PUSH
40311: LD_INT 8
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 25
40320: PUSH
40321: LD_INT 9
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: PPUSH
40335: CALL_OW 72
40339: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40340: LD_ADDR_VAR 0 6
40344: PUSH
40345: LD_EXP 117
40349: PUSH
40350: LD_VAR 0 1
40354: ARRAY
40355: PPUSH
40356: LD_INT 25
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PPUSH
40366: CALL_OW 72
40370: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40371: LD_ADDR_VAR 0 7
40375: PUSH
40376: LD_EXP 117
40380: PUSH
40381: LD_VAR 0 1
40385: ARRAY
40386: PPUSH
40387: LD_INT 25
40389: PUSH
40390: LD_INT 3
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PPUSH
40397: CALL_OW 72
40401: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40402: LD_ADDR_VAR 0 8
40406: PUSH
40407: LD_EXP 117
40411: PUSH
40412: LD_VAR 0 1
40416: ARRAY
40417: PPUSH
40418: LD_INT 25
40420: PUSH
40421: LD_INT 4
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: PUSH
40428: LD_INT 24
40430: PUSH
40431: LD_INT 251
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PPUSH
40442: CALL_OW 72
40446: ST_TO_ADDR
// if mc_is_defending [ base ] then
40447: LD_EXP 160
40451: PUSH
40452: LD_VAR 0 1
40456: ARRAY
40457: IFFALSE 40918
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40459: LD_ADDR_EXP 159
40463: PUSH
40464: LD_EXP 159
40468: PPUSH
40469: LD_VAR 0 1
40473: PPUSH
40474: LD_INT 4
40476: PPUSH
40477: CALL_OW 1
40481: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40482: LD_ADDR_VAR 0 12
40486: PUSH
40487: LD_EXP 117
40491: PUSH
40492: LD_VAR 0 1
40496: ARRAY
40497: PPUSH
40498: LD_INT 2
40500: PUSH
40501: LD_INT 30
40503: PUSH
40504: LD_INT 4
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 30
40513: PUSH
40514: LD_INT 5
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: LIST
40525: PPUSH
40526: CALL_OW 72
40530: ST_TO_ADDR
// if not b then
40531: LD_VAR 0 12
40535: NOT
40536: IFFALSE 40540
// exit ;
40538: GO 43606
// p := [ ] ;
40540: LD_ADDR_VAR 0 11
40544: PUSH
40545: EMPTY
40546: ST_TO_ADDR
// if sci >= 2 then
40547: LD_VAR 0 8
40551: PUSH
40552: LD_INT 2
40554: GREATEREQUAL
40555: IFFALSE 40586
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40557: LD_ADDR_VAR 0 8
40561: PUSH
40562: LD_VAR 0 8
40566: PUSH
40567: LD_INT 1
40569: ARRAY
40570: PUSH
40571: LD_VAR 0 8
40575: PUSH
40576: LD_INT 2
40578: ARRAY
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: ST_TO_ADDR
40584: GO 40647
// if sci = 1 then
40586: LD_VAR 0 8
40590: PUSH
40591: LD_INT 1
40593: EQUAL
40594: IFFALSE 40615
// sci := [ sci [ 1 ] ] else
40596: LD_ADDR_VAR 0 8
40600: PUSH
40601: LD_VAR 0 8
40605: PUSH
40606: LD_INT 1
40608: ARRAY
40609: PUSH
40610: EMPTY
40611: LIST
40612: ST_TO_ADDR
40613: GO 40647
// if sci = 0 then
40615: LD_VAR 0 8
40619: PUSH
40620: LD_INT 0
40622: EQUAL
40623: IFFALSE 40647
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40625: LD_ADDR_VAR 0 11
40629: PUSH
40630: LD_VAR 0 4
40634: PPUSH
40635: LD_INT 4
40637: PPUSH
40638: CALL 101106 0 2
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: ST_TO_ADDR
// if eng > 4 then
40647: LD_VAR 0 6
40651: PUSH
40652: LD_INT 4
40654: GREATER
40655: IFFALSE 40701
// for i = eng downto 4 do
40657: LD_ADDR_VAR 0 3
40661: PUSH
40662: DOUBLE
40663: LD_VAR 0 6
40667: INC
40668: ST_TO_ADDR
40669: LD_INT 4
40671: PUSH
40672: FOR_DOWNTO
40673: IFFALSE 40699
// eng := eng diff eng [ i ] ;
40675: LD_ADDR_VAR 0 6
40679: PUSH
40680: LD_VAR 0 6
40684: PUSH
40685: LD_VAR 0 6
40689: PUSH
40690: LD_VAR 0 3
40694: ARRAY
40695: DIFF
40696: ST_TO_ADDR
40697: GO 40672
40699: POP
40700: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40701: LD_ADDR_VAR 0 4
40705: PUSH
40706: LD_VAR 0 4
40710: PUSH
40711: LD_VAR 0 5
40715: PUSH
40716: LD_VAR 0 6
40720: UNION
40721: PUSH
40722: LD_VAR 0 7
40726: UNION
40727: PUSH
40728: LD_VAR 0 8
40732: UNION
40733: DIFF
40734: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40735: LD_ADDR_VAR 0 13
40739: PUSH
40740: LD_EXP 117
40744: PUSH
40745: LD_VAR 0 1
40749: ARRAY
40750: PPUSH
40751: LD_INT 2
40753: PUSH
40754: LD_INT 30
40756: PUSH
40757: LD_INT 32
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 30
40766: PUSH
40767: LD_INT 31
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: LIST
40778: PPUSH
40779: CALL_OW 72
40783: PUSH
40784: LD_EXP 117
40788: PUSH
40789: LD_VAR 0 1
40793: ARRAY
40794: PPUSH
40795: LD_INT 2
40797: PUSH
40798: LD_INT 30
40800: PUSH
40801: LD_INT 4
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 30
40810: PUSH
40811: LD_INT 5
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: LIST
40822: PPUSH
40823: CALL_OW 72
40827: PUSH
40828: LD_INT 6
40830: MUL
40831: PLUS
40832: ST_TO_ADDR
// if bcount < tmp then
40833: LD_VAR 0 13
40837: PUSH
40838: LD_VAR 0 4
40842: LESS
40843: IFFALSE 40889
// for i = tmp downto bcount do
40845: LD_ADDR_VAR 0 3
40849: PUSH
40850: DOUBLE
40851: LD_VAR 0 4
40855: INC
40856: ST_TO_ADDR
40857: LD_VAR 0 13
40861: PUSH
40862: FOR_DOWNTO
40863: IFFALSE 40887
// tmp := Delete ( tmp , tmp ) ;
40865: LD_ADDR_VAR 0 4
40869: PUSH
40870: LD_VAR 0 4
40874: PPUSH
40875: LD_VAR 0 4
40879: PPUSH
40880: CALL_OW 3
40884: ST_TO_ADDR
40885: GO 40862
40887: POP
40888: POP
// result := [ tmp , 0 , 0 , p ] ;
40889: LD_ADDR_VAR 0 2
40893: PUSH
40894: LD_VAR 0 4
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: LD_VAR 0 11
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: ST_TO_ADDR
// exit ;
40916: GO 43606
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40918: LD_EXP 117
40922: PUSH
40923: LD_VAR 0 1
40927: ARRAY
40928: PPUSH
40929: LD_INT 2
40931: PUSH
40932: LD_INT 30
40934: PUSH
40935: LD_INT 6
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 30
40944: PUSH
40945: LD_INT 7
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 30
40954: PUSH
40955: LD_INT 8
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: PPUSH
40968: CALL_OW 72
40972: NOT
40973: PUSH
40974: LD_EXP 117
40978: PUSH
40979: LD_VAR 0 1
40983: ARRAY
40984: PPUSH
40985: LD_INT 30
40987: PUSH
40988: LD_INT 3
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PPUSH
40995: CALL_OW 72
40999: NOT
41000: AND
41001: IFFALSE 41073
// begin if eng = tmp then
41003: LD_VAR 0 6
41007: PUSH
41008: LD_VAR 0 4
41012: EQUAL
41013: IFFALSE 41017
// exit ;
41015: GO 43606
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
41017: LD_ADDR_EXP 159
41021: PUSH
41022: LD_EXP 159
41026: PPUSH
41027: LD_VAR 0 1
41031: PPUSH
41032: LD_INT 1
41034: PPUSH
41035: CALL_OW 1
41039: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41040: LD_ADDR_VAR 0 2
41044: PUSH
41045: LD_INT 0
41047: PUSH
41048: LD_VAR 0 4
41052: PUSH
41053: LD_VAR 0 6
41057: DIFF
41058: PUSH
41059: LD_INT 0
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: ST_TO_ADDR
// exit ;
41071: GO 43606
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41073: LD_EXP 144
41077: PUSH
41078: LD_EXP 143
41082: PUSH
41083: LD_VAR 0 1
41087: ARRAY
41088: ARRAY
41089: PUSH
41090: LD_EXP 117
41094: PUSH
41095: LD_VAR 0 1
41099: ARRAY
41100: PPUSH
41101: LD_INT 2
41103: PUSH
41104: LD_INT 30
41106: PUSH
41107: LD_INT 6
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 30
41116: PUSH
41117: LD_INT 7
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 30
41126: PUSH
41127: LD_INT 8
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: PPUSH
41140: CALL_OW 72
41144: AND
41145: PUSH
41146: LD_EXP 117
41150: PUSH
41151: LD_VAR 0 1
41155: ARRAY
41156: PPUSH
41157: LD_INT 30
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PPUSH
41167: CALL_OW 72
41171: NOT
41172: AND
41173: IFFALSE 41387
// begin if sci >= 6 then
41175: LD_VAR 0 8
41179: PUSH
41180: LD_INT 6
41182: GREATEREQUAL
41183: IFFALSE 41187
// exit ;
41185: GO 43606
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41187: LD_ADDR_EXP 159
41191: PUSH
41192: LD_EXP 159
41196: PPUSH
41197: LD_VAR 0 1
41201: PPUSH
41202: LD_INT 2
41204: PPUSH
41205: CALL_OW 1
41209: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41210: LD_ADDR_VAR 0 9
41214: PUSH
41215: LD_VAR 0 4
41219: PUSH
41220: LD_VAR 0 8
41224: DIFF
41225: PPUSH
41226: LD_INT 4
41228: PPUSH
41229: CALL 101106 0 2
41233: ST_TO_ADDR
// p := [ ] ;
41234: LD_ADDR_VAR 0 11
41238: PUSH
41239: EMPTY
41240: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41241: LD_VAR 0 8
41245: PUSH
41246: LD_INT 6
41248: LESS
41249: PUSH
41250: LD_VAR 0 9
41254: PUSH
41255: LD_INT 6
41257: GREATER
41258: AND
41259: IFFALSE 41340
// begin for i = 1 to 6 - sci do
41261: LD_ADDR_VAR 0 3
41265: PUSH
41266: DOUBLE
41267: LD_INT 1
41269: DEC
41270: ST_TO_ADDR
41271: LD_INT 6
41273: PUSH
41274: LD_VAR 0 8
41278: MINUS
41279: PUSH
41280: FOR_TO
41281: IFFALSE 41336
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41283: LD_ADDR_VAR 0 11
41287: PUSH
41288: LD_VAR 0 11
41292: PPUSH
41293: LD_VAR 0 11
41297: PUSH
41298: LD_INT 1
41300: PLUS
41301: PPUSH
41302: LD_VAR 0 9
41306: PUSH
41307: LD_INT 1
41309: ARRAY
41310: PPUSH
41311: CALL_OW 2
41315: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41316: LD_ADDR_VAR 0 9
41320: PUSH
41321: LD_VAR 0 9
41325: PPUSH
41326: LD_INT 1
41328: PPUSH
41329: CALL_OW 3
41333: ST_TO_ADDR
// end ;
41334: GO 41280
41336: POP
41337: POP
// end else
41338: GO 41360
// if sort then
41340: LD_VAR 0 9
41344: IFFALSE 41360
// p := sort [ 1 ] ;
41346: LD_ADDR_VAR 0 11
41350: PUSH
41351: LD_VAR 0 9
41355: PUSH
41356: LD_INT 1
41358: ARRAY
41359: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41360: LD_ADDR_VAR 0 2
41364: PUSH
41365: LD_INT 0
41367: PUSH
41368: LD_INT 0
41370: PUSH
41371: LD_INT 0
41373: PUSH
41374: LD_VAR 0 11
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: ST_TO_ADDR
// exit ;
41385: GO 43606
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41387: LD_EXP 144
41391: PUSH
41392: LD_EXP 143
41396: PUSH
41397: LD_VAR 0 1
41401: ARRAY
41402: ARRAY
41403: PUSH
41404: LD_EXP 117
41408: PUSH
41409: LD_VAR 0 1
41413: ARRAY
41414: PPUSH
41415: LD_INT 2
41417: PUSH
41418: LD_INT 30
41420: PUSH
41421: LD_INT 6
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 30
41430: PUSH
41431: LD_INT 7
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 30
41440: PUSH
41441: LD_INT 8
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: PPUSH
41454: CALL_OW 72
41458: AND
41459: PUSH
41460: LD_EXP 117
41464: PUSH
41465: LD_VAR 0 1
41469: ARRAY
41470: PPUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 3
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PPUSH
41481: CALL_OW 72
41485: AND
41486: IFFALSE 42220
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41488: LD_ADDR_EXP 159
41492: PUSH
41493: LD_EXP 159
41497: PPUSH
41498: LD_VAR 0 1
41502: PPUSH
41503: LD_INT 3
41505: PPUSH
41506: CALL_OW 1
41510: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41511: LD_ADDR_VAR 0 2
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: LD_INT 0
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: ST_TO_ADDR
// if not eng then
41534: LD_VAR 0 6
41538: NOT
41539: IFFALSE 41602
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41541: LD_ADDR_VAR 0 11
41545: PUSH
41546: LD_VAR 0 4
41550: PPUSH
41551: LD_INT 2
41553: PPUSH
41554: CALL 101106 0 2
41558: PUSH
41559: LD_INT 1
41561: ARRAY
41562: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41563: LD_ADDR_VAR 0 2
41567: PUSH
41568: LD_VAR 0 2
41572: PPUSH
41573: LD_INT 2
41575: PPUSH
41576: LD_VAR 0 11
41580: PPUSH
41581: CALL_OW 1
41585: ST_TO_ADDR
// tmp := tmp diff p ;
41586: LD_ADDR_VAR 0 4
41590: PUSH
41591: LD_VAR 0 4
41595: PUSH
41596: LD_VAR 0 11
41600: DIFF
41601: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41602: LD_VAR 0 4
41606: PUSH
41607: LD_VAR 0 8
41611: PUSH
41612: LD_INT 6
41614: LESS
41615: AND
41616: IFFALSE 41804
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41618: LD_ADDR_VAR 0 9
41622: PUSH
41623: LD_VAR 0 4
41627: PUSH
41628: LD_VAR 0 8
41632: PUSH
41633: LD_VAR 0 7
41637: UNION
41638: DIFF
41639: PPUSH
41640: LD_INT 4
41642: PPUSH
41643: CALL 101106 0 2
41647: ST_TO_ADDR
// p := [ ] ;
41648: LD_ADDR_VAR 0 11
41652: PUSH
41653: EMPTY
41654: ST_TO_ADDR
// if sort then
41655: LD_VAR 0 9
41659: IFFALSE 41775
// for i = 1 to 6 - sci do
41661: LD_ADDR_VAR 0 3
41665: PUSH
41666: DOUBLE
41667: LD_INT 1
41669: DEC
41670: ST_TO_ADDR
41671: LD_INT 6
41673: PUSH
41674: LD_VAR 0 8
41678: MINUS
41679: PUSH
41680: FOR_TO
41681: IFFALSE 41773
// begin if i = sort then
41683: LD_VAR 0 3
41687: PUSH
41688: LD_VAR 0 9
41692: EQUAL
41693: IFFALSE 41697
// break ;
41695: GO 41773
// if GetClass ( i ) = 4 then
41697: LD_VAR 0 3
41701: PPUSH
41702: CALL_OW 257
41706: PUSH
41707: LD_INT 4
41709: EQUAL
41710: IFFALSE 41714
// continue ;
41712: GO 41680
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41714: LD_ADDR_VAR 0 11
41718: PUSH
41719: LD_VAR 0 11
41723: PPUSH
41724: LD_VAR 0 11
41728: PUSH
41729: LD_INT 1
41731: PLUS
41732: PPUSH
41733: LD_VAR 0 9
41737: PUSH
41738: LD_VAR 0 3
41742: ARRAY
41743: PPUSH
41744: CALL_OW 2
41748: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41749: LD_ADDR_VAR 0 4
41753: PUSH
41754: LD_VAR 0 4
41758: PUSH
41759: LD_VAR 0 9
41763: PUSH
41764: LD_VAR 0 3
41768: ARRAY
41769: DIFF
41770: ST_TO_ADDR
// end ;
41771: GO 41680
41773: POP
41774: POP
// if p then
41775: LD_VAR 0 11
41779: IFFALSE 41804
// result := Replace ( result , 4 , p ) ;
41781: LD_ADDR_VAR 0 2
41785: PUSH
41786: LD_VAR 0 2
41790: PPUSH
41791: LD_INT 4
41793: PPUSH
41794: LD_VAR 0 11
41798: PPUSH
41799: CALL_OW 1
41803: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41804: LD_VAR 0 4
41808: PUSH
41809: LD_VAR 0 7
41813: PUSH
41814: LD_INT 6
41816: LESS
41817: AND
41818: IFFALSE 42006
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41820: LD_ADDR_VAR 0 9
41824: PUSH
41825: LD_VAR 0 4
41829: PUSH
41830: LD_VAR 0 8
41834: PUSH
41835: LD_VAR 0 7
41839: UNION
41840: DIFF
41841: PPUSH
41842: LD_INT 3
41844: PPUSH
41845: CALL 101106 0 2
41849: ST_TO_ADDR
// p := [ ] ;
41850: LD_ADDR_VAR 0 11
41854: PUSH
41855: EMPTY
41856: ST_TO_ADDR
// if sort then
41857: LD_VAR 0 9
41861: IFFALSE 41977
// for i = 1 to 6 - mech do
41863: LD_ADDR_VAR 0 3
41867: PUSH
41868: DOUBLE
41869: LD_INT 1
41871: DEC
41872: ST_TO_ADDR
41873: LD_INT 6
41875: PUSH
41876: LD_VAR 0 7
41880: MINUS
41881: PUSH
41882: FOR_TO
41883: IFFALSE 41975
// begin if i = sort then
41885: LD_VAR 0 3
41889: PUSH
41890: LD_VAR 0 9
41894: EQUAL
41895: IFFALSE 41899
// break ;
41897: GO 41975
// if GetClass ( i ) = 3 then
41899: LD_VAR 0 3
41903: PPUSH
41904: CALL_OW 257
41908: PUSH
41909: LD_INT 3
41911: EQUAL
41912: IFFALSE 41916
// continue ;
41914: GO 41882
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41916: LD_ADDR_VAR 0 11
41920: PUSH
41921: LD_VAR 0 11
41925: PPUSH
41926: LD_VAR 0 11
41930: PUSH
41931: LD_INT 1
41933: PLUS
41934: PPUSH
41935: LD_VAR 0 9
41939: PUSH
41940: LD_VAR 0 3
41944: ARRAY
41945: PPUSH
41946: CALL_OW 2
41950: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41951: LD_ADDR_VAR 0 4
41955: PUSH
41956: LD_VAR 0 4
41960: PUSH
41961: LD_VAR 0 9
41965: PUSH
41966: LD_VAR 0 3
41970: ARRAY
41971: DIFF
41972: ST_TO_ADDR
// end ;
41973: GO 41882
41975: POP
41976: POP
// if p then
41977: LD_VAR 0 11
41981: IFFALSE 42006
// result := Replace ( result , 3 , p ) ;
41983: LD_ADDR_VAR 0 2
41987: PUSH
41988: LD_VAR 0 2
41992: PPUSH
41993: LD_INT 3
41995: PPUSH
41996: LD_VAR 0 11
42000: PPUSH
42001: CALL_OW 1
42005: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
42006: LD_VAR 0 4
42010: PUSH
42011: LD_INT 6
42013: GREATER
42014: PUSH
42015: LD_VAR 0 6
42019: PUSH
42020: LD_INT 6
42022: LESS
42023: AND
42024: IFFALSE 42218
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42026: LD_ADDR_VAR 0 9
42030: PUSH
42031: LD_VAR 0 4
42035: PUSH
42036: LD_VAR 0 8
42040: PUSH
42041: LD_VAR 0 7
42045: UNION
42046: PUSH
42047: LD_VAR 0 6
42051: UNION
42052: DIFF
42053: PPUSH
42054: LD_INT 2
42056: PPUSH
42057: CALL 101106 0 2
42061: ST_TO_ADDR
// p := [ ] ;
42062: LD_ADDR_VAR 0 11
42066: PUSH
42067: EMPTY
42068: ST_TO_ADDR
// if sort then
42069: LD_VAR 0 9
42073: IFFALSE 42189
// for i = 1 to 6 - eng do
42075: LD_ADDR_VAR 0 3
42079: PUSH
42080: DOUBLE
42081: LD_INT 1
42083: DEC
42084: ST_TO_ADDR
42085: LD_INT 6
42087: PUSH
42088: LD_VAR 0 6
42092: MINUS
42093: PUSH
42094: FOR_TO
42095: IFFALSE 42187
// begin if i = sort then
42097: LD_VAR 0 3
42101: PUSH
42102: LD_VAR 0 9
42106: EQUAL
42107: IFFALSE 42111
// break ;
42109: GO 42187
// if GetClass ( i ) = 2 then
42111: LD_VAR 0 3
42115: PPUSH
42116: CALL_OW 257
42120: PUSH
42121: LD_INT 2
42123: EQUAL
42124: IFFALSE 42128
// continue ;
42126: GO 42094
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42128: LD_ADDR_VAR 0 11
42132: PUSH
42133: LD_VAR 0 11
42137: PPUSH
42138: LD_VAR 0 11
42142: PUSH
42143: LD_INT 1
42145: PLUS
42146: PPUSH
42147: LD_VAR 0 9
42151: PUSH
42152: LD_VAR 0 3
42156: ARRAY
42157: PPUSH
42158: CALL_OW 2
42162: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42163: LD_ADDR_VAR 0 4
42167: PUSH
42168: LD_VAR 0 4
42172: PUSH
42173: LD_VAR 0 9
42177: PUSH
42178: LD_VAR 0 3
42182: ARRAY
42183: DIFF
42184: ST_TO_ADDR
// end ;
42185: GO 42094
42187: POP
42188: POP
// if p then
42189: LD_VAR 0 11
42193: IFFALSE 42218
// result := Replace ( result , 2 , p ) ;
42195: LD_ADDR_VAR 0 2
42199: PUSH
42200: LD_VAR 0 2
42204: PPUSH
42205: LD_INT 2
42207: PPUSH
42208: LD_VAR 0 11
42212: PPUSH
42213: CALL_OW 1
42217: ST_TO_ADDR
// end ; exit ;
42218: GO 43606
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42220: LD_EXP 144
42224: PUSH
42225: LD_EXP 143
42229: PUSH
42230: LD_VAR 0 1
42234: ARRAY
42235: ARRAY
42236: NOT
42237: PUSH
42238: LD_EXP 117
42242: PUSH
42243: LD_VAR 0 1
42247: ARRAY
42248: PPUSH
42249: LD_INT 30
42251: PUSH
42252: LD_INT 3
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PPUSH
42259: CALL_OW 72
42263: AND
42264: PUSH
42265: LD_EXP 122
42269: PUSH
42270: LD_VAR 0 1
42274: ARRAY
42275: AND
42276: IFFALSE 42884
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42278: LD_ADDR_EXP 159
42282: PUSH
42283: LD_EXP 159
42287: PPUSH
42288: LD_VAR 0 1
42292: PPUSH
42293: LD_INT 5
42295: PPUSH
42296: CALL_OW 1
42300: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42301: LD_ADDR_VAR 0 2
42305: PUSH
42306: LD_INT 0
42308: PUSH
42309: LD_INT 0
42311: PUSH
42312: LD_INT 0
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: ST_TO_ADDR
// if sci > 1 then
42324: LD_VAR 0 8
42328: PUSH
42329: LD_INT 1
42331: GREATER
42332: IFFALSE 42360
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42334: LD_ADDR_VAR 0 4
42338: PUSH
42339: LD_VAR 0 4
42343: PUSH
42344: LD_VAR 0 8
42348: PUSH
42349: LD_VAR 0 8
42353: PUSH
42354: LD_INT 1
42356: ARRAY
42357: DIFF
42358: DIFF
42359: ST_TO_ADDR
// if tmp and not sci then
42360: LD_VAR 0 4
42364: PUSH
42365: LD_VAR 0 8
42369: NOT
42370: AND
42371: IFFALSE 42440
// begin sort := SortBySkill ( tmp , 4 ) ;
42373: LD_ADDR_VAR 0 9
42377: PUSH
42378: LD_VAR 0 4
42382: PPUSH
42383: LD_INT 4
42385: PPUSH
42386: CALL 101106 0 2
42390: ST_TO_ADDR
// if sort then
42391: LD_VAR 0 9
42395: IFFALSE 42411
// p := sort [ 1 ] ;
42397: LD_ADDR_VAR 0 11
42401: PUSH
42402: LD_VAR 0 9
42406: PUSH
42407: LD_INT 1
42409: ARRAY
42410: ST_TO_ADDR
// if p then
42411: LD_VAR 0 11
42415: IFFALSE 42440
// result := Replace ( result , 4 , p ) ;
42417: LD_ADDR_VAR 0 2
42421: PUSH
42422: LD_VAR 0 2
42426: PPUSH
42427: LD_INT 4
42429: PPUSH
42430: LD_VAR 0 11
42434: PPUSH
42435: CALL_OW 1
42439: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42440: LD_ADDR_VAR 0 4
42444: PUSH
42445: LD_VAR 0 4
42449: PUSH
42450: LD_VAR 0 7
42454: DIFF
42455: ST_TO_ADDR
// if tmp and mech < 6 then
42456: LD_VAR 0 4
42460: PUSH
42461: LD_VAR 0 7
42465: PUSH
42466: LD_INT 6
42468: LESS
42469: AND
42470: IFFALSE 42658
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42472: LD_ADDR_VAR 0 9
42476: PUSH
42477: LD_VAR 0 4
42481: PUSH
42482: LD_VAR 0 8
42486: PUSH
42487: LD_VAR 0 7
42491: UNION
42492: DIFF
42493: PPUSH
42494: LD_INT 3
42496: PPUSH
42497: CALL 101106 0 2
42501: ST_TO_ADDR
// p := [ ] ;
42502: LD_ADDR_VAR 0 11
42506: PUSH
42507: EMPTY
42508: ST_TO_ADDR
// if sort then
42509: LD_VAR 0 9
42513: IFFALSE 42629
// for i = 1 to 6 - mech do
42515: LD_ADDR_VAR 0 3
42519: PUSH
42520: DOUBLE
42521: LD_INT 1
42523: DEC
42524: ST_TO_ADDR
42525: LD_INT 6
42527: PUSH
42528: LD_VAR 0 7
42532: MINUS
42533: PUSH
42534: FOR_TO
42535: IFFALSE 42627
// begin if i = sort then
42537: LD_VAR 0 3
42541: PUSH
42542: LD_VAR 0 9
42546: EQUAL
42547: IFFALSE 42551
// break ;
42549: GO 42627
// if GetClass ( i ) = 3 then
42551: LD_VAR 0 3
42555: PPUSH
42556: CALL_OW 257
42560: PUSH
42561: LD_INT 3
42563: EQUAL
42564: IFFALSE 42568
// continue ;
42566: GO 42534
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42568: LD_ADDR_VAR 0 11
42572: PUSH
42573: LD_VAR 0 11
42577: PPUSH
42578: LD_VAR 0 11
42582: PUSH
42583: LD_INT 1
42585: PLUS
42586: PPUSH
42587: LD_VAR 0 9
42591: PUSH
42592: LD_VAR 0 3
42596: ARRAY
42597: PPUSH
42598: CALL_OW 2
42602: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42603: LD_ADDR_VAR 0 4
42607: PUSH
42608: LD_VAR 0 4
42612: PUSH
42613: LD_VAR 0 9
42617: PUSH
42618: LD_VAR 0 3
42622: ARRAY
42623: DIFF
42624: ST_TO_ADDR
// end ;
42625: GO 42534
42627: POP
42628: POP
// if p then
42629: LD_VAR 0 11
42633: IFFALSE 42658
// result := Replace ( result , 3 , p ) ;
42635: LD_ADDR_VAR 0 2
42639: PUSH
42640: LD_VAR 0 2
42644: PPUSH
42645: LD_INT 3
42647: PPUSH
42648: LD_VAR 0 11
42652: PPUSH
42653: CALL_OW 1
42657: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42658: LD_ADDR_VAR 0 4
42662: PUSH
42663: LD_VAR 0 4
42667: PUSH
42668: LD_VAR 0 6
42672: DIFF
42673: ST_TO_ADDR
// if tmp and eng < 6 then
42674: LD_VAR 0 4
42678: PUSH
42679: LD_VAR 0 6
42683: PUSH
42684: LD_INT 6
42686: LESS
42687: AND
42688: IFFALSE 42882
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42690: LD_ADDR_VAR 0 9
42694: PUSH
42695: LD_VAR 0 4
42699: PUSH
42700: LD_VAR 0 8
42704: PUSH
42705: LD_VAR 0 7
42709: UNION
42710: PUSH
42711: LD_VAR 0 6
42715: UNION
42716: DIFF
42717: PPUSH
42718: LD_INT 2
42720: PPUSH
42721: CALL 101106 0 2
42725: ST_TO_ADDR
// p := [ ] ;
42726: LD_ADDR_VAR 0 11
42730: PUSH
42731: EMPTY
42732: ST_TO_ADDR
// if sort then
42733: LD_VAR 0 9
42737: IFFALSE 42853
// for i = 1 to 6 - eng do
42739: LD_ADDR_VAR 0 3
42743: PUSH
42744: DOUBLE
42745: LD_INT 1
42747: DEC
42748: ST_TO_ADDR
42749: LD_INT 6
42751: PUSH
42752: LD_VAR 0 6
42756: MINUS
42757: PUSH
42758: FOR_TO
42759: IFFALSE 42851
// begin if i = sort then
42761: LD_VAR 0 3
42765: PUSH
42766: LD_VAR 0 9
42770: EQUAL
42771: IFFALSE 42775
// break ;
42773: GO 42851
// if GetClass ( i ) = 2 then
42775: LD_VAR 0 3
42779: PPUSH
42780: CALL_OW 257
42784: PUSH
42785: LD_INT 2
42787: EQUAL
42788: IFFALSE 42792
// continue ;
42790: GO 42758
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42792: LD_ADDR_VAR 0 11
42796: PUSH
42797: LD_VAR 0 11
42801: PPUSH
42802: LD_VAR 0 11
42806: PUSH
42807: LD_INT 1
42809: PLUS
42810: PPUSH
42811: LD_VAR 0 9
42815: PUSH
42816: LD_VAR 0 3
42820: ARRAY
42821: PPUSH
42822: CALL_OW 2
42826: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42827: LD_ADDR_VAR 0 4
42831: PUSH
42832: LD_VAR 0 4
42836: PUSH
42837: LD_VAR 0 9
42841: PUSH
42842: LD_VAR 0 3
42846: ARRAY
42847: DIFF
42848: ST_TO_ADDR
// end ;
42849: GO 42758
42851: POP
42852: POP
// if p then
42853: LD_VAR 0 11
42857: IFFALSE 42882
// result := Replace ( result , 2 , p ) ;
42859: LD_ADDR_VAR 0 2
42863: PUSH
42864: LD_VAR 0 2
42868: PPUSH
42869: LD_INT 2
42871: PPUSH
42872: LD_VAR 0 11
42876: PPUSH
42877: CALL_OW 1
42881: ST_TO_ADDR
// end ; exit ;
42882: GO 43606
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42884: LD_EXP 144
42888: PUSH
42889: LD_EXP 143
42893: PUSH
42894: LD_VAR 0 1
42898: ARRAY
42899: ARRAY
42900: NOT
42901: PUSH
42902: LD_EXP 117
42906: PUSH
42907: LD_VAR 0 1
42911: ARRAY
42912: PPUSH
42913: LD_INT 30
42915: PUSH
42916: LD_INT 3
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PPUSH
42923: CALL_OW 72
42927: AND
42928: PUSH
42929: LD_EXP 122
42933: PUSH
42934: LD_VAR 0 1
42938: ARRAY
42939: NOT
42940: AND
42941: IFFALSE 43606
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42943: LD_ADDR_EXP 159
42947: PUSH
42948: LD_EXP 159
42952: PPUSH
42953: LD_VAR 0 1
42957: PPUSH
42958: LD_INT 6
42960: PPUSH
42961: CALL_OW 1
42965: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42966: LD_ADDR_VAR 0 2
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: ST_TO_ADDR
// if sci >= 1 then
42989: LD_VAR 0 8
42993: PUSH
42994: LD_INT 1
42996: GREATEREQUAL
42997: IFFALSE 43019
// tmp := tmp diff sci [ 1 ] ;
42999: LD_ADDR_VAR 0 4
43003: PUSH
43004: LD_VAR 0 4
43008: PUSH
43009: LD_VAR 0 8
43013: PUSH
43014: LD_INT 1
43016: ARRAY
43017: DIFF
43018: ST_TO_ADDR
// if tmp and not sci then
43019: LD_VAR 0 4
43023: PUSH
43024: LD_VAR 0 8
43028: NOT
43029: AND
43030: IFFALSE 43099
// begin sort := SortBySkill ( tmp , 4 ) ;
43032: LD_ADDR_VAR 0 9
43036: PUSH
43037: LD_VAR 0 4
43041: PPUSH
43042: LD_INT 4
43044: PPUSH
43045: CALL 101106 0 2
43049: ST_TO_ADDR
// if sort then
43050: LD_VAR 0 9
43054: IFFALSE 43070
// p := sort [ 1 ] ;
43056: LD_ADDR_VAR 0 11
43060: PUSH
43061: LD_VAR 0 9
43065: PUSH
43066: LD_INT 1
43068: ARRAY
43069: ST_TO_ADDR
// if p then
43070: LD_VAR 0 11
43074: IFFALSE 43099
// result := Replace ( result , 4 , p ) ;
43076: LD_ADDR_VAR 0 2
43080: PUSH
43081: LD_VAR 0 2
43085: PPUSH
43086: LD_INT 4
43088: PPUSH
43089: LD_VAR 0 11
43093: PPUSH
43094: CALL_OW 1
43098: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43099: LD_ADDR_VAR 0 4
43103: PUSH
43104: LD_VAR 0 4
43108: PUSH
43109: LD_VAR 0 7
43113: DIFF
43114: ST_TO_ADDR
// if tmp and mech < 6 then
43115: LD_VAR 0 4
43119: PUSH
43120: LD_VAR 0 7
43124: PUSH
43125: LD_INT 6
43127: LESS
43128: AND
43129: IFFALSE 43311
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43131: LD_ADDR_VAR 0 9
43135: PUSH
43136: LD_VAR 0 4
43140: PUSH
43141: LD_VAR 0 7
43145: DIFF
43146: PPUSH
43147: LD_INT 3
43149: PPUSH
43150: CALL 101106 0 2
43154: ST_TO_ADDR
// p := [ ] ;
43155: LD_ADDR_VAR 0 11
43159: PUSH
43160: EMPTY
43161: ST_TO_ADDR
// if sort then
43162: LD_VAR 0 9
43166: IFFALSE 43282
// for i = 1 to 6 - mech do
43168: LD_ADDR_VAR 0 3
43172: PUSH
43173: DOUBLE
43174: LD_INT 1
43176: DEC
43177: ST_TO_ADDR
43178: LD_INT 6
43180: PUSH
43181: LD_VAR 0 7
43185: MINUS
43186: PUSH
43187: FOR_TO
43188: IFFALSE 43280
// begin if i = sort then
43190: LD_VAR 0 3
43194: PUSH
43195: LD_VAR 0 9
43199: EQUAL
43200: IFFALSE 43204
// break ;
43202: GO 43280
// if GetClass ( i ) = 3 then
43204: LD_VAR 0 3
43208: PPUSH
43209: CALL_OW 257
43213: PUSH
43214: LD_INT 3
43216: EQUAL
43217: IFFALSE 43221
// continue ;
43219: GO 43187
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43221: LD_ADDR_VAR 0 11
43225: PUSH
43226: LD_VAR 0 11
43230: PPUSH
43231: LD_VAR 0 11
43235: PUSH
43236: LD_INT 1
43238: PLUS
43239: PPUSH
43240: LD_VAR 0 9
43244: PUSH
43245: LD_VAR 0 3
43249: ARRAY
43250: PPUSH
43251: CALL_OW 2
43255: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43256: LD_ADDR_VAR 0 4
43260: PUSH
43261: LD_VAR 0 4
43265: PUSH
43266: LD_VAR 0 9
43270: PUSH
43271: LD_VAR 0 3
43275: ARRAY
43276: DIFF
43277: ST_TO_ADDR
// end ;
43278: GO 43187
43280: POP
43281: POP
// if p then
43282: LD_VAR 0 11
43286: IFFALSE 43311
// result := Replace ( result , 3 , p ) ;
43288: LD_ADDR_VAR 0 2
43292: PUSH
43293: LD_VAR 0 2
43297: PPUSH
43298: LD_INT 3
43300: PPUSH
43301: LD_VAR 0 11
43305: PPUSH
43306: CALL_OW 1
43310: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43311: LD_ADDR_VAR 0 4
43315: PUSH
43316: LD_VAR 0 4
43320: PUSH
43321: LD_VAR 0 6
43325: DIFF
43326: ST_TO_ADDR
// if tmp and eng < 4 then
43327: LD_VAR 0 4
43331: PUSH
43332: LD_VAR 0 6
43336: PUSH
43337: LD_INT 4
43339: LESS
43340: AND
43341: IFFALSE 43531
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43343: LD_ADDR_VAR 0 9
43347: PUSH
43348: LD_VAR 0 4
43352: PUSH
43353: LD_VAR 0 7
43357: PUSH
43358: LD_VAR 0 6
43362: UNION
43363: DIFF
43364: PPUSH
43365: LD_INT 2
43367: PPUSH
43368: CALL 101106 0 2
43372: ST_TO_ADDR
// p := [ ] ;
43373: LD_ADDR_VAR 0 11
43377: PUSH
43378: EMPTY
43379: ST_TO_ADDR
// if sort then
43380: LD_VAR 0 9
43384: IFFALSE 43500
// for i = 1 to 4 - eng do
43386: LD_ADDR_VAR 0 3
43390: PUSH
43391: DOUBLE
43392: LD_INT 1
43394: DEC
43395: ST_TO_ADDR
43396: LD_INT 4
43398: PUSH
43399: LD_VAR 0 6
43403: MINUS
43404: PUSH
43405: FOR_TO
43406: IFFALSE 43498
// begin if i = sort then
43408: LD_VAR 0 3
43412: PUSH
43413: LD_VAR 0 9
43417: EQUAL
43418: IFFALSE 43422
// break ;
43420: GO 43498
// if GetClass ( i ) = 2 then
43422: LD_VAR 0 3
43426: PPUSH
43427: CALL_OW 257
43431: PUSH
43432: LD_INT 2
43434: EQUAL
43435: IFFALSE 43439
// continue ;
43437: GO 43405
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43439: LD_ADDR_VAR 0 11
43443: PUSH
43444: LD_VAR 0 11
43448: PPUSH
43449: LD_VAR 0 11
43453: PUSH
43454: LD_INT 1
43456: PLUS
43457: PPUSH
43458: LD_VAR 0 9
43462: PUSH
43463: LD_VAR 0 3
43467: ARRAY
43468: PPUSH
43469: CALL_OW 2
43473: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43474: LD_ADDR_VAR 0 4
43478: PUSH
43479: LD_VAR 0 4
43483: PUSH
43484: LD_VAR 0 9
43488: PUSH
43489: LD_VAR 0 3
43493: ARRAY
43494: DIFF
43495: ST_TO_ADDR
// end ;
43496: GO 43405
43498: POP
43499: POP
// if p then
43500: LD_VAR 0 11
43504: IFFALSE 43529
// result := Replace ( result , 2 , p ) ;
43506: LD_ADDR_VAR 0 2
43510: PUSH
43511: LD_VAR 0 2
43515: PPUSH
43516: LD_INT 2
43518: PPUSH
43519: LD_VAR 0 11
43523: PPUSH
43524: CALL_OW 1
43528: ST_TO_ADDR
// end else
43529: GO 43575
// for i = eng downto 5 do
43531: LD_ADDR_VAR 0 3
43535: PUSH
43536: DOUBLE
43537: LD_VAR 0 6
43541: INC
43542: ST_TO_ADDR
43543: LD_INT 5
43545: PUSH
43546: FOR_DOWNTO
43547: IFFALSE 43573
// tmp := tmp union eng [ i ] ;
43549: LD_ADDR_VAR 0 4
43553: PUSH
43554: LD_VAR 0 4
43558: PUSH
43559: LD_VAR 0 6
43563: PUSH
43564: LD_VAR 0 3
43568: ARRAY
43569: UNION
43570: ST_TO_ADDR
43571: GO 43546
43573: POP
43574: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43575: LD_ADDR_VAR 0 2
43579: PUSH
43580: LD_VAR 0 2
43584: PPUSH
43585: LD_INT 1
43587: PPUSH
43588: LD_VAR 0 4
43592: PUSH
43593: LD_VAR 0 5
43597: DIFF
43598: PPUSH
43599: CALL_OW 1
43603: ST_TO_ADDR
// exit ;
43604: GO 43606
// end ; end ;
43606: LD_VAR 0 2
43610: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43611: LD_INT 0
43613: PPUSH
43614: PPUSH
43615: PPUSH
// if not mc_bases then
43616: LD_EXP 117
43620: NOT
43621: IFFALSE 43625
// exit ;
43623: GO 43767
// for i = 1 to mc_bases do
43625: LD_ADDR_VAR 0 2
43629: PUSH
43630: DOUBLE
43631: LD_INT 1
43633: DEC
43634: ST_TO_ADDR
43635: LD_EXP 117
43639: PUSH
43640: FOR_TO
43641: IFFALSE 43758
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43643: LD_ADDR_VAR 0 3
43647: PUSH
43648: LD_EXP 117
43652: PUSH
43653: LD_VAR 0 2
43657: ARRAY
43658: PPUSH
43659: LD_INT 21
43661: PUSH
43662: LD_INT 3
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: PUSH
43672: LD_INT 2
43674: PUSH
43675: LD_INT 30
43677: PUSH
43678: LD_INT 29
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 30
43687: PUSH
43688: LD_INT 30
43690: PUSH
43691: EMPTY
43692: LIST
43693: LIST
43694: PUSH
43695: EMPTY
43696: LIST
43697: LIST
43698: LIST
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 3
43706: PUSH
43707: LD_INT 24
43709: PUSH
43710: LD_INT 1000
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: LIST
43725: PPUSH
43726: CALL_OW 72
43730: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43731: LD_ADDR_EXP 118
43735: PUSH
43736: LD_EXP 118
43740: PPUSH
43741: LD_VAR 0 2
43745: PPUSH
43746: LD_VAR 0 3
43750: PPUSH
43751: CALL_OW 1
43755: ST_TO_ADDR
// end ;
43756: GO 43640
43758: POP
43759: POP
// RaiseSailEvent ( 101 ) ;
43760: LD_INT 101
43762: PPUSH
43763: CALL_OW 427
// end ;
43767: LD_VAR 0 1
43771: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43772: LD_INT 0
43774: PPUSH
43775: PPUSH
43776: PPUSH
43777: PPUSH
43778: PPUSH
43779: PPUSH
43780: PPUSH
// if not mc_bases then
43781: LD_EXP 117
43785: NOT
43786: IFFALSE 43790
// exit ;
43788: GO 44352
// for i = 1 to mc_bases do
43790: LD_ADDR_VAR 0 2
43794: PUSH
43795: DOUBLE
43796: LD_INT 1
43798: DEC
43799: ST_TO_ADDR
43800: LD_EXP 117
43804: PUSH
43805: FOR_TO
43806: IFFALSE 44343
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43808: LD_ADDR_VAR 0 5
43812: PUSH
43813: LD_EXP 117
43817: PUSH
43818: LD_VAR 0 2
43822: ARRAY
43823: PUSH
43824: LD_EXP 146
43828: PUSH
43829: LD_VAR 0 2
43833: ARRAY
43834: UNION
43835: PPUSH
43836: LD_INT 21
43838: PUSH
43839: LD_INT 1
43841: PUSH
43842: EMPTY
43843: LIST
43844: LIST
43845: PUSH
43846: LD_INT 1
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: LD_INT 54
43854: PUSH
43855: EMPTY
43856: LIST
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: LD_INT 3
43864: PUSH
43865: LD_INT 24
43867: PUSH
43868: LD_INT 1000
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: LIST
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PPUSH
43888: CALL_OW 72
43892: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43893: LD_ADDR_VAR 0 6
43897: PUSH
43898: LD_EXP 117
43902: PUSH
43903: LD_VAR 0 2
43907: ARRAY
43908: PPUSH
43909: LD_INT 21
43911: PUSH
43912: LD_INT 1
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: PUSH
43919: LD_INT 1
43921: PUSH
43922: LD_INT 3
43924: PUSH
43925: LD_INT 54
43927: PUSH
43928: EMPTY
43929: LIST
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: PUSH
43938: LD_INT 24
43940: PUSH
43941: LD_INT 250
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: LIST
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PPUSH
43961: CALL_OW 72
43965: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43966: LD_ADDR_VAR 0 7
43970: PUSH
43971: LD_VAR 0 5
43975: PUSH
43976: LD_VAR 0 6
43980: DIFF
43981: ST_TO_ADDR
// if not need_heal_1 then
43982: LD_VAR 0 6
43986: NOT
43987: IFFALSE 44020
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43989: LD_ADDR_EXP 120
43993: PUSH
43994: LD_EXP 120
43998: PPUSH
43999: LD_VAR 0 2
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PPUSH
44011: EMPTY
44012: PPUSH
44013: CALL 70902 0 3
44017: ST_TO_ADDR
44018: GO 44090
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
44020: LD_ADDR_EXP 120
44024: PUSH
44025: LD_EXP 120
44029: PPUSH
44030: LD_VAR 0 2
44034: PUSH
44035: LD_INT 1
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PPUSH
44042: LD_EXP 120
44046: PUSH
44047: LD_VAR 0 2
44051: ARRAY
44052: PUSH
44053: LD_INT 1
44055: ARRAY
44056: PPUSH
44057: LD_INT 3
44059: PUSH
44060: LD_INT 24
44062: PUSH
44063: LD_INT 1000
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PPUSH
44074: CALL_OW 72
44078: PUSH
44079: LD_VAR 0 6
44083: UNION
44084: PPUSH
44085: CALL 70902 0 3
44089: ST_TO_ADDR
// if not need_heal_2 then
44090: LD_VAR 0 7
44094: NOT
44095: IFFALSE 44128
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44097: LD_ADDR_EXP 120
44101: PUSH
44102: LD_EXP 120
44106: PPUSH
44107: LD_VAR 0 2
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PPUSH
44119: EMPTY
44120: PPUSH
44121: CALL 70902 0 3
44125: ST_TO_ADDR
44126: GO 44160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44128: LD_ADDR_EXP 120
44132: PUSH
44133: LD_EXP 120
44137: PPUSH
44138: LD_VAR 0 2
44142: PUSH
44143: LD_INT 2
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PPUSH
44150: LD_VAR 0 7
44154: PPUSH
44155: CALL 70902 0 3
44159: ST_TO_ADDR
// if need_heal_2 then
44160: LD_VAR 0 7
44164: IFFALSE 44325
// for j in need_heal_2 do
44166: LD_ADDR_VAR 0 3
44170: PUSH
44171: LD_VAR 0 7
44175: PUSH
44176: FOR_IN
44177: IFFALSE 44323
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44179: LD_ADDR_VAR 0 5
44183: PUSH
44184: LD_EXP 117
44188: PUSH
44189: LD_VAR 0 2
44193: ARRAY
44194: PPUSH
44195: LD_INT 2
44197: PUSH
44198: LD_INT 30
44200: PUSH
44201: LD_INT 6
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: LD_INT 30
44210: PUSH
44211: LD_INT 7
44213: PUSH
44214: EMPTY
44215: LIST
44216: LIST
44217: PUSH
44218: LD_INT 30
44220: PUSH
44221: LD_INT 8
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 30
44230: PUSH
44231: LD_INT 0
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 30
44240: PUSH
44241: LD_INT 1
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: PPUSH
44256: CALL_OW 72
44260: ST_TO_ADDR
// if tmp then
44261: LD_VAR 0 5
44265: IFFALSE 44321
// begin k := NearestUnitToUnit ( tmp , j ) ;
44267: LD_ADDR_VAR 0 4
44271: PUSH
44272: LD_VAR 0 5
44276: PPUSH
44277: LD_VAR 0 3
44281: PPUSH
44282: CALL_OW 74
44286: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44287: LD_VAR 0 3
44291: PPUSH
44292: LD_VAR 0 4
44296: PPUSH
44297: CALL_OW 296
44301: PUSH
44302: LD_INT 5
44304: GREATER
44305: IFFALSE 44321
// ComMoveToNearbyEntrance ( j , k ) ;
44307: LD_VAR 0 3
44311: PPUSH
44312: LD_VAR 0 4
44316: PPUSH
44317: CALL 103464 0 2
// end ; end ;
44321: GO 44176
44323: POP
44324: POP
// if not need_heal_1 and not need_heal_2 then
44325: LD_VAR 0 6
44329: NOT
44330: PUSH
44331: LD_VAR 0 7
44335: NOT
44336: AND
44337: IFFALSE 44341
// continue ;
44339: GO 43805
// end ;
44341: GO 43805
44343: POP
44344: POP
// RaiseSailEvent ( 102 ) ;
44345: LD_INT 102
44347: PPUSH
44348: CALL_OW 427
// end ;
44352: LD_VAR 0 1
44356: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44357: LD_INT 0
44359: PPUSH
44360: PPUSH
44361: PPUSH
44362: PPUSH
44363: PPUSH
44364: PPUSH
44365: PPUSH
44366: PPUSH
// if not mc_bases then
44367: LD_EXP 117
44371: NOT
44372: IFFALSE 44376
// exit ;
44374: GO 45259
// for i = 1 to mc_bases do
44376: LD_ADDR_VAR 0 2
44380: PUSH
44381: DOUBLE
44382: LD_INT 1
44384: DEC
44385: ST_TO_ADDR
44386: LD_EXP 117
44390: PUSH
44391: FOR_TO
44392: IFFALSE 45257
// begin if not mc_building_need_repair [ i ] then
44394: LD_EXP 118
44398: PUSH
44399: LD_VAR 0 2
44403: ARRAY
44404: NOT
44405: IFFALSE 44592
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44407: LD_ADDR_VAR 0 6
44411: PUSH
44412: LD_EXP 136
44416: PUSH
44417: LD_VAR 0 2
44421: ARRAY
44422: PPUSH
44423: LD_INT 3
44425: PUSH
44426: LD_INT 24
44428: PUSH
44429: LD_INT 1000
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 2
44442: PUSH
44443: LD_INT 34
44445: PUSH
44446: LD_INT 13
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 34
44455: PUSH
44456: LD_INT 52
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 34
44465: PUSH
44466: LD_EXP 101
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PPUSH
44485: CALL_OW 72
44489: ST_TO_ADDR
// if cranes then
44490: LD_VAR 0 6
44494: IFFALSE 44556
// for j in cranes do
44496: LD_ADDR_VAR 0 3
44500: PUSH
44501: LD_VAR 0 6
44505: PUSH
44506: FOR_IN
44507: IFFALSE 44554
// if not IsInArea ( j , mc_parking [ i ] ) then
44509: LD_VAR 0 3
44513: PPUSH
44514: LD_EXP 141
44518: PUSH
44519: LD_VAR 0 2
44523: ARRAY
44524: PPUSH
44525: CALL_OW 308
44529: NOT
44530: IFFALSE 44552
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44532: LD_VAR 0 3
44536: PPUSH
44537: LD_EXP 141
44541: PUSH
44542: LD_VAR 0 2
44546: ARRAY
44547: PPUSH
44548: CALL_OW 113
44552: GO 44506
44554: POP
44555: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44556: LD_ADDR_EXP 119
44560: PUSH
44561: LD_EXP 119
44565: PPUSH
44566: LD_VAR 0 2
44570: PPUSH
44571: EMPTY
44572: PPUSH
44573: CALL_OW 1
44577: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44578: LD_VAR 0 2
44582: PPUSH
44583: LD_INT 101
44585: PPUSH
44586: CALL 39444 0 2
// continue ;
44590: GO 44391
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44592: LD_ADDR_EXP 123
44596: PUSH
44597: LD_EXP 123
44601: PPUSH
44602: LD_VAR 0 2
44606: PPUSH
44607: EMPTY
44608: PPUSH
44609: CALL_OW 1
44613: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44614: LD_VAR 0 2
44618: PPUSH
44619: LD_INT 103
44621: PPUSH
44622: CALL 39444 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44626: LD_ADDR_VAR 0 5
44630: PUSH
44631: LD_EXP 117
44635: PUSH
44636: LD_VAR 0 2
44640: ARRAY
44641: PUSH
44642: LD_EXP 146
44646: PUSH
44647: LD_VAR 0 2
44651: ARRAY
44652: UNION
44653: PPUSH
44654: LD_INT 2
44656: PUSH
44657: LD_INT 25
44659: PUSH
44660: LD_INT 2
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 25
44669: PUSH
44670: LD_INT 16
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: LIST
44681: PUSH
44682: EMPTY
44683: LIST
44684: PPUSH
44685: CALL_OW 72
44689: ST_TO_ADDR
// if mc_need_heal [ i ] then
44690: LD_EXP 120
44694: PUSH
44695: LD_VAR 0 2
44699: ARRAY
44700: IFFALSE 44744
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44702: LD_ADDR_VAR 0 5
44706: PUSH
44707: LD_VAR 0 5
44711: PUSH
44712: LD_EXP 120
44716: PUSH
44717: LD_VAR 0 2
44721: ARRAY
44722: PUSH
44723: LD_INT 1
44725: ARRAY
44726: PUSH
44727: LD_EXP 120
44731: PUSH
44732: LD_VAR 0 2
44736: ARRAY
44737: PUSH
44738: LD_INT 2
44740: ARRAY
44741: UNION
44742: DIFF
44743: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44744: LD_ADDR_VAR 0 6
44748: PUSH
44749: LD_EXP 136
44753: PUSH
44754: LD_VAR 0 2
44758: ARRAY
44759: PPUSH
44760: LD_INT 2
44762: PUSH
44763: LD_INT 34
44765: PUSH
44766: LD_INT 13
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 34
44775: PUSH
44776: LD_INT 52
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 34
44785: PUSH
44786: LD_EXP 101
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: PPUSH
44801: CALL_OW 72
44805: ST_TO_ADDR
// if cranes then
44806: LD_VAR 0 6
44810: IFFALSE 44946
// begin for j in cranes do
44812: LD_ADDR_VAR 0 3
44816: PUSH
44817: LD_VAR 0 6
44821: PUSH
44822: FOR_IN
44823: IFFALSE 44944
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44825: LD_VAR 0 3
44829: PPUSH
44830: CALL_OW 256
44834: PUSH
44835: LD_INT 1000
44837: EQUAL
44838: PUSH
44839: LD_VAR 0 3
44843: PPUSH
44844: CALL_OW 314
44848: NOT
44849: AND
44850: IFFALSE 44884
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44852: LD_VAR 0 3
44856: PPUSH
44857: LD_EXP 118
44861: PUSH
44862: LD_VAR 0 2
44866: ARRAY
44867: PPUSH
44868: LD_VAR 0 3
44872: PPUSH
44873: CALL_OW 74
44877: PPUSH
44878: CALL_OW 130
44882: GO 44942
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44884: LD_VAR 0 3
44888: PPUSH
44889: CALL_OW 256
44893: PUSH
44894: LD_INT 500
44896: LESS
44897: PUSH
44898: LD_VAR 0 3
44902: PPUSH
44903: LD_EXP 141
44907: PUSH
44908: LD_VAR 0 2
44912: ARRAY
44913: PPUSH
44914: CALL_OW 308
44918: NOT
44919: AND
44920: IFFALSE 44942
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44922: LD_VAR 0 3
44926: PPUSH
44927: LD_EXP 141
44931: PUSH
44932: LD_VAR 0 2
44936: ARRAY
44937: PPUSH
44938: CALL_OW 113
// end ;
44942: GO 44822
44944: POP
44945: POP
// end ; if tmp > 3 then
44946: LD_VAR 0 5
44950: PUSH
44951: LD_INT 3
44953: GREATER
44954: IFFALSE 44974
// tmp := ShrinkArray ( tmp , 4 ) ;
44956: LD_ADDR_VAR 0 5
44960: PUSH
44961: LD_VAR 0 5
44965: PPUSH
44966: LD_INT 4
44968: PPUSH
44969: CALL 102912 0 2
44973: ST_TO_ADDR
// if not tmp then
44974: LD_VAR 0 5
44978: NOT
44979: IFFALSE 44983
// continue ;
44981: GO 44391
// for j in tmp do
44983: LD_ADDR_VAR 0 3
44987: PUSH
44988: LD_VAR 0 5
44992: PUSH
44993: FOR_IN
44994: IFFALSE 45253
// begin if IsInUnit ( j ) then
44996: LD_VAR 0 3
45000: PPUSH
45001: CALL_OW 310
45005: IFFALSE 45016
// ComExitBuilding ( j ) ;
45007: LD_VAR 0 3
45011: PPUSH
45012: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
45016: LD_VAR 0 3
45020: PUSH
45021: LD_EXP 119
45025: PUSH
45026: LD_VAR 0 2
45030: ARRAY
45031: IN
45032: NOT
45033: IFFALSE 45091
// begin SetTag ( j , 101 ) ;
45035: LD_VAR 0 3
45039: PPUSH
45040: LD_INT 101
45042: PPUSH
45043: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45047: LD_ADDR_EXP 119
45051: PUSH
45052: LD_EXP 119
45056: PPUSH
45057: LD_VAR 0 2
45061: PUSH
45062: LD_EXP 119
45066: PUSH
45067: LD_VAR 0 2
45071: ARRAY
45072: PUSH
45073: LD_INT 1
45075: PLUS
45076: PUSH
45077: EMPTY
45078: LIST
45079: LIST
45080: PPUSH
45081: LD_VAR 0 3
45085: PPUSH
45086: CALL 70902 0 3
45090: ST_TO_ADDR
// end ; wait ( 1 ) ;
45091: LD_INT 1
45093: PPUSH
45094: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45098: LD_ADDR_VAR 0 7
45102: PUSH
45103: LD_EXP 118
45107: PUSH
45108: LD_VAR 0 2
45112: ARRAY
45113: ST_TO_ADDR
// if mc_scan [ i ] then
45114: LD_EXP 140
45118: PUSH
45119: LD_VAR 0 2
45123: ARRAY
45124: IFFALSE 45186
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45126: LD_ADDR_VAR 0 7
45130: PUSH
45131: LD_EXP 118
45135: PUSH
45136: LD_VAR 0 2
45140: ARRAY
45141: PPUSH
45142: LD_INT 3
45144: PUSH
45145: LD_INT 30
45147: PUSH
45148: LD_INT 32
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 30
45157: PUSH
45158: LD_INT 33
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 30
45167: PUSH
45168: LD_INT 31
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: PPUSH
45181: CALL_OW 72
45185: ST_TO_ADDR
// if not to_repair_tmp then
45186: LD_VAR 0 7
45190: NOT
45191: IFFALSE 45195
// continue ;
45193: GO 44993
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45195: LD_ADDR_VAR 0 8
45199: PUSH
45200: LD_VAR 0 7
45204: PPUSH
45205: LD_VAR 0 3
45209: PPUSH
45210: CALL_OW 74
45214: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45215: LD_VAR 0 8
45219: PPUSH
45220: LD_INT 16
45222: PPUSH
45223: CALL 73501 0 2
45227: PUSH
45228: LD_INT 4
45230: ARRAY
45231: PUSH
45232: LD_INT 10
45234: LESS
45235: IFFALSE 45251
// ComRepairBuilding ( j , to_repair ) ;
45237: LD_VAR 0 3
45241: PPUSH
45242: LD_VAR 0 8
45246: PPUSH
45247: CALL_OW 130
// end ;
45251: GO 44993
45253: POP
45254: POP
// end ;
45255: GO 44391
45257: POP
45258: POP
// end ;
45259: LD_VAR 0 1
45263: RET
// export function MC_Heal ; var i , j , tmp ; begin
45264: LD_INT 0
45266: PPUSH
45267: PPUSH
45268: PPUSH
45269: PPUSH
// if not mc_bases then
45270: LD_EXP 117
45274: NOT
45275: IFFALSE 45279
// exit ;
45277: GO 45681
// for i = 1 to mc_bases do
45279: LD_ADDR_VAR 0 2
45283: PUSH
45284: DOUBLE
45285: LD_INT 1
45287: DEC
45288: ST_TO_ADDR
45289: LD_EXP 117
45293: PUSH
45294: FOR_TO
45295: IFFALSE 45679
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45297: LD_EXP 120
45301: PUSH
45302: LD_VAR 0 2
45306: ARRAY
45307: PUSH
45308: LD_INT 1
45310: ARRAY
45311: NOT
45312: PUSH
45313: LD_EXP 120
45317: PUSH
45318: LD_VAR 0 2
45322: ARRAY
45323: PUSH
45324: LD_INT 2
45326: ARRAY
45327: NOT
45328: AND
45329: IFFALSE 45367
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45331: LD_ADDR_EXP 121
45335: PUSH
45336: LD_EXP 121
45340: PPUSH
45341: LD_VAR 0 2
45345: PPUSH
45346: EMPTY
45347: PPUSH
45348: CALL_OW 1
45352: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45353: LD_VAR 0 2
45357: PPUSH
45358: LD_INT 102
45360: PPUSH
45361: CALL 39444 0 2
// continue ;
45365: GO 45294
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45367: LD_ADDR_VAR 0 4
45371: PUSH
45372: LD_EXP 117
45376: PUSH
45377: LD_VAR 0 2
45381: ARRAY
45382: PPUSH
45383: LD_INT 25
45385: PUSH
45386: LD_INT 4
45388: PUSH
45389: EMPTY
45390: LIST
45391: LIST
45392: PPUSH
45393: CALL_OW 72
45397: ST_TO_ADDR
// if not tmp then
45398: LD_VAR 0 4
45402: NOT
45403: IFFALSE 45407
// continue ;
45405: GO 45294
// if mc_taming [ i ] then
45407: LD_EXP 148
45411: PUSH
45412: LD_VAR 0 2
45416: ARRAY
45417: IFFALSE 45441
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45419: LD_ADDR_EXP 148
45423: PUSH
45424: LD_EXP 148
45428: PPUSH
45429: LD_VAR 0 2
45433: PPUSH
45434: EMPTY
45435: PPUSH
45436: CALL_OW 1
45440: ST_TO_ADDR
// for j in tmp do
45441: LD_ADDR_VAR 0 3
45445: PUSH
45446: LD_VAR 0 4
45450: PUSH
45451: FOR_IN
45452: IFFALSE 45675
// begin if IsInUnit ( j ) then
45454: LD_VAR 0 3
45458: PPUSH
45459: CALL_OW 310
45463: IFFALSE 45474
// ComExitBuilding ( j ) ;
45465: LD_VAR 0 3
45469: PPUSH
45470: CALL_OW 122
// if not j in mc_healers [ i ] then
45474: LD_VAR 0 3
45478: PUSH
45479: LD_EXP 121
45483: PUSH
45484: LD_VAR 0 2
45488: ARRAY
45489: IN
45490: NOT
45491: IFFALSE 45537
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45493: LD_ADDR_EXP 121
45497: PUSH
45498: LD_EXP 121
45502: PPUSH
45503: LD_VAR 0 2
45507: PUSH
45508: LD_EXP 121
45512: PUSH
45513: LD_VAR 0 2
45517: ARRAY
45518: PUSH
45519: LD_INT 1
45521: PLUS
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PPUSH
45527: LD_VAR 0 3
45531: PPUSH
45532: CALL 70902 0 3
45536: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45537: LD_VAR 0 3
45541: PPUSH
45542: CALL_OW 110
45546: PUSH
45547: LD_INT 102
45549: NONEQUAL
45550: IFFALSE 45564
// SetTag ( j , 102 ) ;
45552: LD_VAR 0 3
45556: PPUSH
45557: LD_INT 102
45559: PPUSH
45560: CALL_OW 109
// Wait ( 3 ) ;
45564: LD_INT 3
45566: PPUSH
45567: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45571: LD_EXP 120
45575: PUSH
45576: LD_VAR 0 2
45580: ARRAY
45581: PUSH
45582: LD_INT 1
45584: ARRAY
45585: IFFALSE 45617
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45587: LD_VAR 0 3
45591: PPUSH
45592: LD_EXP 120
45596: PUSH
45597: LD_VAR 0 2
45601: ARRAY
45602: PUSH
45603: LD_INT 1
45605: ARRAY
45606: PUSH
45607: LD_INT 1
45609: ARRAY
45610: PPUSH
45611: CALL_OW 128
45615: GO 45673
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45617: LD_VAR 0 3
45621: PPUSH
45622: CALL_OW 314
45626: NOT
45627: PUSH
45628: LD_EXP 120
45632: PUSH
45633: LD_VAR 0 2
45637: ARRAY
45638: PUSH
45639: LD_INT 2
45641: ARRAY
45642: AND
45643: IFFALSE 45673
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45645: LD_VAR 0 3
45649: PPUSH
45650: LD_EXP 120
45654: PUSH
45655: LD_VAR 0 2
45659: ARRAY
45660: PUSH
45661: LD_INT 2
45663: ARRAY
45664: PUSH
45665: LD_INT 1
45667: ARRAY
45668: PPUSH
45669: CALL_OW 128
// end ;
45673: GO 45451
45675: POP
45676: POP
// end ;
45677: GO 45294
45679: POP
45680: POP
// end ;
45681: LD_VAR 0 1
45685: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45686: LD_INT 0
45688: PPUSH
45689: PPUSH
45690: PPUSH
45691: PPUSH
45692: PPUSH
// if not mc_bases then
45693: LD_EXP 117
45697: NOT
45698: IFFALSE 45702
// exit ;
45700: GO 46873
// for i = 1 to mc_bases do
45702: LD_ADDR_VAR 0 2
45706: PUSH
45707: DOUBLE
45708: LD_INT 1
45710: DEC
45711: ST_TO_ADDR
45712: LD_EXP 117
45716: PUSH
45717: FOR_TO
45718: IFFALSE 46871
// begin if mc_scan [ i ] then
45720: LD_EXP 140
45724: PUSH
45725: LD_VAR 0 2
45729: ARRAY
45730: IFFALSE 45734
// continue ;
45732: GO 45717
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45734: LD_EXP 122
45738: PUSH
45739: LD_VAR 0 2
45743: ARRAY
45744: NOT
45745: PUSH
45746: LD_EXP 124
45750: PUSH
45751: LD_VAR 0 2
45755: ARRAY
45756: NOT
45757: AND
45758: PUSH
45759: LD_EXP 123
45763: PUSH
45764: LD_VAR 0 2
45768: ARRAY
45769: AND
45770: IFFALSE 45808
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45772: LD_ADDR_EXP 123
45776: PUSH
45777: LD_EXP 123
45781: PPUSH
45782: LD_VAR 0 2
45786: PPUSH
45787: EMPTY
45788: PPUSH
45789: CALL_OW 1
45793: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45794: LD_VAR 0 2
45798: PPUSH
45799: LD_INT 103
45801: PPUSH
45802: CALL 39444 0 2
// continue ;
45806: GO 45717
// end ; if mc_construct_list [ i ] then
45808: LD_EXP 124
45812: PUSH
45813: LD_VAR 0 2
45817: ARRAY
45818: IFFALSE 46038
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45820: LD_ADDR_VAR 0 4
45824: PUSH
45825: LD_EXP 117
45829: PUSH
45830: LD_VAR 0 2
45834: ARRAY
45835: PPUSH
45836: LD_INT 25
45838: PUSH
45839: LD_INT 2
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PPUSH
45846: CALL_OW 72
45850: PUSH
45851: LD_EXP 119
45855: PUSH
45856: LD_VAR 0 2
45860: ARRAY
45861: DIFF
45862: ST_TO_ADDR
// if not tmp then
45863: LD_VAR 0 4
45867: NOT
45868: IFFALSE 45872
// continue ;
45870: GO 45717
// for j in tmp do
45872: LD_ADDR_VAR 0 3
45876: PUSH
45877: LD_VAR 0 4
45881: PUSH
45882: FOR_IN
45883: IFFALSE 46034
// begin if not mc_builders [ i ] then
45885: LD_EXP 123
45889: PUSH
45890: LD_VAR 0 2
45894: ARRAY
45895: NOT
45896: IFFALSE 45954
// begin SetTag ( j , 103 ) ;
45898: LD_VAR 0 3
45902: PPUSH
45903: LD_INT 103
45905: PPUSH
45906: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45910: LD_ADDR_EXP 123
45914: PUSH
45915: LD_EXP 123
45919: PPUSH
45920: LD_VAR 0 2
45924: PUSH
45925: LD_EXP 123
45929: PUSH
45930: LD_VAR 0 2
45934: ARRAY
45935: PUSH
45936: LD_INT 1
45938: PLUS
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PPUSH
45944: LD_VAR 0 3
45948: PPUSH
45949: CALL 70902 0 3
45953: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45954: LD_VAR 0 3
45958: PPUSH
45959: CALL_OW 310
45963: IFFALSE 45974
// ComExitBuilding ( j ) ;
45965: LD_VAR 0 3
45969: PPUSH
45970: CALL_OW 122
// wait ( 3 ) ;
45974: LD_INT 3
45976: PPUSH
45977: CALL_OW 67
// if not mc_construct_list [ i ] then
45981: LD_EXP 124
45985: PUSH
45986: LD_VAR 0 2
45990: ARRAY
45991: NOT
45992: IFFALSE 45996
// break ;
45994: GO 46034
// if not HasTask ( j ) then
45996: LD_VAR 0 3
46000: PPUSH
46001: CALL_OW 314
46005: NOT
46006: IFFALSE 46032
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
46008: LD_VAR 0 3
46012: PPUSH
46013: LD_EXP 124
46017: PUSH
46018: LD_VAR 0 2
46022: ARRAY
46023: PUSH
46024: LD_INT 1
46026: ARRAY
46027: PPUSH
46028: CALL 73765 0 2
// end ;
46032: GO 45882
46034: POP
46035: POP
// end else
46036: GO 46869
// if mc_build_list [ i ] then
46038: LD_EXP 122
46042: PUSH
46043: LD_VAR 0 2
46047: ARRAY
46048: IFFALSE 46869
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46050: LD_ADDR_VAR 0 5
46054: PUSH
46055: LD_EXP 117
46059: PUSH
46060: LD_VAR 0 2
46064: ARRAY
46065: PPUSH
46066: LD_INT 2
46068: PUSH
46069: LD_INT 30
46071: PUSH
46072: LD_INT 0
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 30
46081: PUSH
46082: LD_INT 1
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: LIST
46093: PPUSH
46094: CALL_OW 72
46098: ST_TO_ADDR
// if depot then
46099: LD_VAR 0 5
46103: IFFALSE 46121
// depot := depot [ 1 ] else
46105: LD_ADDR_VAR 0 5
46109: PUSH
46110: LD_VAR 0 5
46114: PUSH
46115: LD_INT 1
46117: ARRAY
46118: ST_TO_ADDR
46119: GO 46129
// depot := 0 ;
46121: LD_ADDR_VAR 0 5
46125: PUSH
46126: LD_INT 0
46128: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46129: LD_EXP 122
46133: PUSH
46134: LD_VAR 0 2
46138: ARRAY
46139: PUSH
46140: LD_INT 1
46142: ARRAY
46143: PUSH
46144: LD_INT 1
46146: ARRAY
46147: PPUSH
46148: CALL 73589 0 1
46152: PUSH
46153: LD_EXP 117
46157: PUSH
46158: LD_VAR 0 2
46162: ARRAY
46163: PPUSH
46164: LD_INT 2
46166: PUSH
46167: LD_INT 30
46169: PUSH
46170: LD_INT 2
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 30
46179: PUSH
46180: LD_INT 3
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: EMPTY
46188: LIST
46189: LIST
46190: LIST
46191: PPUSH
46192: CALL_OW 72
46196: NOT
46197: AND
46198: IFFALSE 46303
// begin for j = 1 to mc_build_list [ i ] do
46200: LD_ADDR_VAR 0 3
46204: PUSH
46205: DOUBLE
46206: LD_INT 1
46208: DEC
46209: ST_TO_ADDR
46210: LD_EXP 122
46214: PUSH
46215: LD_VAR 0 2
46219: ARRAY
46220: PUSH
46221: FOR_TO
46222: IFFALSE 46301
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46224: LD_EXP 122
46228: PUSH
46229: LD_VAR 0 2
46233: ARRAY
46234: PUSH
46235: LD_VAR 0 3
46239: ARRAY
46240: PUSH
46241: LD_INT 1
46243: ARRAY
46244: PUSH
46245: LD_INT 2
46247: EQUAL
46248: IFFALSE 46299
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46250: LD_ADDR_EXP 122
46254: PUSH
46255: LD_EXP 122
46259: PPUSH
46260: LD_VAR 0 2
46264: PPUSH
46265: LD_EXP 122
46269: PUSH
46270: LD_VAR 0 2
46274: ARRAY
46275: PPUSH
46276: LD_VAR 0 3
46280: PPUSH
46281: LD_INT 1
46283: PPUSH
46284: LD_INT 0
46286: PPUSH
46287: CALL 70320 0 4
46291: PPUSH
46292: CALL_OW 1
46296: ST_TO_ADDR
// break ;
46297: GO 46301
// end ;
46299: GO 46221
46301: POP
46302: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46303: LD_EXP 122
46307: PUSH
46308: LD_VAR 0 2
46312: ARRAY
46313: PUSH
46314: LD_INT 1
46316: ARRAY
46317: PUSH
46318: LD_INT 1
46320: ARRAY
46321: PUSH
46322: LD_INT 0
46324: EQUAL
46325: PUSH
46326: LD_VAR 0 5
46330: PUSH
46331: LD_VAR 0 5
46335: PPUSH
46336: LD_EXP 122
46340: PUSH
46341: LD_VAR 0 2
46345: ARRAY
46346: PUSH
46347: LD_INT 1
46349: ARRAY
46350: PUSH
46351: LD_INT 1
46353: ARRAY
46354: PPUSH
46355: LD_EXP 122
46359: PUSH
46360: LD_VAR 0 2
46364: ARRAY
46365: PUSH
46366: LD_INT 1
46368: ARRAY
46369: PUSH
46370: LD_INT 2
46372: ARRAY
46373: PPUSH
46374: LD_EXP 122
46378: PUSH
46379: LD_VAR 0 2
46383: ARRAY
46384: PUSH
46385: LD_INT 1
46387: ARRAY
46388: PUSH
46389: LD_INT 3
46391: ARRAY
46392: PPUSH
46393: LD_EXP 122
46397: PUSH
46398: LD_VAR 0 2
46402: ARRAY
46403: PUSH
46404: LD_INT 1
46406: ARRAY
46407: PUSH
46408: LD_INT 4
46410: ARRAY
46411: PPUSH
46412: CALL 79005 0 5
46416: AND
46417: OR
46418: IFFALSE 46699
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46420: LD_ADDR_VAR 0 4
46424: PUSH
46425: LD_EXP 117
46429: PUSH
46430: LD_VAR 0 2
46434: ARRAY
46435: PPUSH
46436: LD_INT 25
46438: PUSH
46439: LD_INT 2
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PPUSH
46446: CALL_OW 72
46450: PUSH
46451: LD_EXP 119
46455: PUSH
46456: LD_VAR 0 2
46460: ARRAY
46461: DIFF
46462: ST_TO_ADDR
// if not tmp then
46463: LD_VAR 0 4
46467: NOT
46468: IFFALSE 46472
// continue ;
46470: GO 45717
// for j in tmp do
46472: LD_ADDR_VAR 0 3
46476: PUSH
46477: LD_VAR 0 4
46481: PUSH
46482: FOR_IN
46483: IFFALSE 46695
// begin if not mc_builders [ i ] then
46485: LD_EXP 123
46489: PUSH
46490: LD_VAR 0 2
46494: ARRAY
46495: NOT
46496: IFFALSE 46554
// begin SetTag ( j , 103 ) ;
46498: LD_VAR 0 3
46502: PPUSH
46503: LD_INT 103
46505: PPUSH
46506: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46510: LD_ADDR_EXP 123
46514: PUSH
46515: LD_EXP 123
46519: PPUSH
46520: LD_VAR 0 2
46524: PUSH
46525: LD_EXP 123
46529: PUSH
46530: LD_VAR 0 2
46534: ARRAY
46535: PUSH
46536: LD_INT 1
46538: PLUS
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PPUSH
46544: LD_VAR 0 3
46548: PPUSH
46549: CALL 70902 0 3
46553: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46554: LD_VAR 0 3
46558: PPUSH
46559: CALL_OW 310
46563: IFFALSE 46574
// ComExitBuilding ( j ) ;
46565: LD_VAR 0 3
46569: PPUSH
46570: CALL_OW 122
// wait ( 3 ) ;
46574: LD_INT 3
46576: PPUSH
46577: CALL_OW 67
// if not mc_build_list [ i ] then
46581: LD_EXP 122
46585: PUSH
46586: LD_VAR 0 2
46590: ARRAY
46591: NOT
46592: IFFALSE 46596
// break ;
46594: GO 46695
// if not HasTask ( j ) then
46596: LD_VAR 0 3
46600: PPUSH
46601: CALL_OW 314
46605: NOT
46606: IFFALSE 46693
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46608: LD_VAR 0 3
46612: PPUSH
46613: LD_EXP 122
46617: PUSH
46618: LD_VAR 0 2
46622: ARRAY
46623: PUSH
46624: LD_INT 1
46626: ARRAY
46627: PUSH
46628: LD_INT 1
46630: ARRAY
46631: PPUSH
46632: LD_EXP 122
46636: PUSH
46637: LD_VAR 0 2
46641: ARRAY
46642: PUSH
46643: LD_INT 1
46645: ARRAY
46646: PUSH
46647: LD_INT 2
46649: ARRAY
46650: PPUSH
46651: LD_EXP 122
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PUSH
46662: LD_INT 1
46664: ARRAY
46665: PUSH
46666: LD_INT 3
46668: ARRAY
46669: PPUSH
46670: LD_EXP 122
46674: PUSH
46675: LD_VAR 0 2
46679: ARRAY
46680: PUSH
46681: LD_INT 1
46683: ARRAY
46684: PUSH
46685: LD_INT 4
46687: ARRAY
46688: PPUSH
46689: CALL_OW 145
// end ;
46693: GO 46482
46695: POP
46696: POP
// end else
46697: GO 46869
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46699: LD_EXP 117
46703: PUSH
46704: LD_VAR 0 2
46708: ARRAY
46709: PPUSH
46710: LD_EXP 122
46714: PUSH
46715: LD_VAR 0 2
46719: ARRAY
46720: PUSH
46721: LD_INT 1
46723: ARRAY
46724: PUSH
46725: LD_INT 1
46727: ARRAY
46728: PPUSH
46729: LD_EXP 122
46733: PUSH
46734: LD_VAR 0 2
46738: ARRAY
46739: PUSH
46740: LD_INT 1
46742: ARRAY
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PPUSH
46748: LD_EXP 122
46752: PUSH
46753: LD_VAR 0 2
46757: ARRAY
46758: PUSH
46759: LD_INT 1
46761: ARRAY
46762: PUSH
46763: LD_INT 3
46765: ARRAY
46766: PPUSH
46767: LD_EXP 122
46771: PUSH
46772: LD_VAR 0 2
46776: ARRAY
46777: PUSH
46778: LD_INT 1
46780: ARRAY
46781: PUSH
46782: LD_INT 4
46784: ARRAY
46785: PPUSH
46786: LD_EXP 117
46790: PUSH
46791: LD_VAR 0 2
46795: ARRAY
46796: PPUSH
46797: LD_INT 21
46799: PUSH
46800: LD_INT 3
46802: PUSH
46803: EMPTY
46804: LIST
46805: LIST
46806: PPUSH
46807: CALL_OW 72
46811: PPUSH
46812: EMPTY
46813: PPUSH
46814: CALL 77755 0 7
46818: NOT
46819: IFFALSE 46869
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46821: LD_ADDR_EXP 122
46825: PUSH
46826: LD_EXP 122
46830: PPUSH
46831: LD_VAR 0 2
46835: PPUSH
46836: LD_EXP 122
46840: PUSH
46841: LD_VAR 0 2
46845: ARRAY
46846: PPUSH
46847: LD_INT 1
46849: PPUSH
46850: LD_INT 1
46852: NEG
46853: PPUSH
46854: LD_INT 0
46856: PPUSH
46857: CALL 70320 0 4
46861: PPUSH
46862: CALL_OW 1
46866: ST_TO_ADDR
// continue ;
46867: GO 45717
// end ; end ; end ;
46869: GO 45717
46871: POP
46872: POP
// end ;
46873: LD_VAR 0 1
46877: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46878: LD_INT 0
46880: PPUSH
46881: PPUSH
46882: PPUSH
46883: PPUSH
46884: PPUSH
46885: PPUSH
// if not mc_bases then
46886: LD_EXP 117
46890: NOT
46891: IFFALSE 46895
// exit ;
46893: GO 47322
// for i = 1 to mc_bases do
46895: LD_ADDR_VAR 0 2
46899: PUSH
46900: DOUBLE
46901: LD_INT 1
46903: DEC
46904: ST_TO_ADDR
46905: LD_EXP 117
46909: PUSH
46910: FOR_TO
46911: IFFALSE 47320
// begin tmp := mc_build_upgrade [ i ] ;
46913: LD_ADDR_VAR 0 4
46917: PUSH
46918: LD_EXP 149
46922: PUSH
46923: LD_VAR 0 2
46927: ARRAY
46928: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46929: LD_ADDR_VAR 0 6
46933: PUSH
46934: LD_EXP 150
46938: PUSH
46939: LD_VAR 0 2
46943: ARRAY
46944: PPUSH
46945: LD_INT 2
46947: PUSH
46948: LD_INT 30
46950: PUSH
46951: LD_INT 6
46953: PUSH
46954: EMPTY
46955: LIST
46956: LIST
46957: PUSH
46958: LD_INT 30
46960: PUSH
46961: LD_INT 7
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: LIST
46972: PPUSH
46973: CALL_OW 72
46977: ST_TO_ADDR
// if not tmp and not lab then
46978: LD_VAR 0 4
46982: NOT
46983: PUSH
46984: LD_VAR 0 6
46988: NOT
46989: AND
46990: IFFALSE 46994
// continue ;
46992: GO 46910
// if tmp then
46994: LD_VAR 0 4
46998: IFFALSE 47118
// for j in tmp do
47000: LD_ADDR_VAR 0 3
47004: PUSH
47005: LD_VAR 0 4
47009: PUSH
47010: FOR_IN
47011: IFFALSE 47116
// begin if UpgradeCost ( j ) then
47013: LD_VAR 0 3
47017: PPUSH
47018: CALL 77415 0 1
47022: IFFALSE 47114
// begin ComUpgrade ( j ) ;
47024: LD_VAR 0 3
47028: PPUSH
47029: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
47033: LD_ADDR_EXP 149
47037: PUSH
47038: LD_EXP 149
47042: PPUSH
47043: LD_VAR 0 2
47047: PPUSH
47048: LD_EXP 149
47052: PUSH
47053: LD_VAR 0 2
47057: ARRAY
47058: PUSH
47059: LD_VAR 0 3
47063: DIFF
47064: PPUSH
47065: CALL_OW 1
47069: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47070: LD_ADDR_EXP 124
47074: PUSH
47075: LD_EXP 124
47079: PPUSH
47080: LD_VAR 0 2
47084: PUSH
47085: LD_EXP 124
47089: PUSH
47090: LD_VAR 0 2
47094: ARRAY
47095: PUSH
47096: LD_INT 1
47098: PLUS
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: PPUSH
47104: LD_VAR 0 3
47108: PPUSH
47109: CALL 70902 0 3
47113: ST_TO_ADDR
// end ; end ;
47114: GO 47010
47116: POP
47117: POP
// if not lab or not mc_lab_upgrade [ i ] then
47118: LD_VAR 0 6
47122: NOT
47123: PUSH
47124: LD_EXP 151
47128: PUSH
47129: LD_VAR 0 2
47133: ARRAY
47134: NOT
47135: OR
47136: IFFALSE 47140
// continue ;
47138: GO 46910
// for j in lab do
47140: LD_ADDR_VAR 0 3
47144: PUSH
47145: LD_VAR 0 6
47149: PUSH
47150: FOR_IN
47151: IFFALSE 47316
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47153: LD_VAR 0 3
47157: PPUSH
47158: CALL_OW 266
47162: PUSH
47163: LD_INT 6
47165: PUSH
47166: LD_INT 7
47168: PUSH
47169: EMPTY
47170: LIST
47171: LIST
47172: IN
47173: PUSH
47174: LD_VAR 0 3
47178: PPUSH
47179: CALL_OW 461
47183: PUSH
47184: LD_INT 1
47186: NONEQUAL
47187: AND
47188: IFFALSE 47314
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47190: LD_VAR 0 3
47194: PPUSH
47195: LD_EXP 151
47199: PUSH
47200: LD_VAR 0 2
47204: ARRAY
47205: PUSH
47206: LD_INT 1
47208: ARRAY
47209: PPUSH
47210: CALL 77620 0 2
47214: IFFALSE 47314
// begin ComCancel ( j ) ;
47216: LD_VAR 0 3
47220: PPUSH
47221: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47225: LD_VAR 0 3
47229: PPUSH
47230: LD_EXP 151
47234: PUSH
47235: LD_VAR 0 2
47239: ARRAY
47240: PUSH
47241: LD_INT 1
47243: ARRAY
47244: PPUSH
47245: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47249: LD_VAR 0 3
47253: PUSH
47254: LD_EXP 124
47258: PUSH
47259: LD_VAR 0 2
47263: ARRAY
47264: IN
47265: NOT
47266: IFFALSE 47312
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47268: LD_ADDR_EXP 124
47272: PUSH
47273: LD_EXP 124
47277: PPUSH
47278: LD_VAR 0 2
47282: PUSH
47283: LD_EXP 124
47287: PUSH
47288: LD_VAR 0 2
47292: ARRAY
47293: PUSH
47294: LD_INT 1
47296: PLUS
47297: PUSH
47298: EMPTY
47299: LIST
47300: LIST
47301: PPUSH
47302: LD_VAR 0 3
47306: PPUSH
47307: CALL 70902 0 3
47311: ST_TO_ADDR
// break ;
47312: GO 47316
// end ; end ; end ;
47314: GO 47150
47316: POP
47317: POP
// end ;
47318: GO 46910
47320: POP
47321: POP
// end ;
47322: LD_VAR 0 1
47326: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47327: LD_INT 0
47329: PPUSH
47330: PPUSH
47331: PPUSH
47332: PPUSH
47333: PPUSH
47334: PPUSH
47335: PPUSH
47336: PPUSH
47337: PPUSH
// if not mc_bases then
47338: LD_EXP 117
47342: NOT
47343: IFFALSE 47347
// exit ;
47345: GO 47752
// for i = 1 to mc_bases do
47347: LD_ADDR_VAR 0 2
47351: PUSH
47352: DOUBLE
47353: LD_INT 1
47355: DEC
47356: ST_TO_ADDR
47357: LD_EXP 117
47361: PUSH
47362: FOR_TO
47363: IFFALSE 47750
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47365: LD_EXP 125
47369: PUSH
47370: LD_VAR 0 2
47374: ARRAY
47375: NOT
47376: PUSH
47377: LD_EXP 117
47381: PUSH
47382: LD_VAR 0 2
47386: ARRAY
47387: PPUSH
47388: LD_INT 30
47390: PUSH
47391: LD_INT 3
47393: PUSH
47394: EMPTY
47395: LIST
47396: LIST
47397: PPUSH
47398: CALL_OW 72
47402: NOT
47403: OR
47404: IFFALSE 47408
// continue ;
47406: GO 47362
// busy := false ;
47408: LD_ADDR_VAR 0 8
47412: PUSH
47413: LD_INT 0
47415: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47416: LD_ADDR_VAR 0 4
47420: PUSH
47421: LD_EXP 117
47425: PUSH
47426: LD_VAR 0 2
47430: ARRAY
47431: PPUSH
47432: LD_INT 30
47434: PUSH
47435: LD_INT 3
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: PPUSH
47442: CALL_OW 72
47446: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47447: LD_ADDR_VAR 0 6
47451: PUSH
47452: LD_EXP 125
47456: PUSH
47457: LD_VAR 0 2
47461: ARRAY
47462: PPUSH
47463: LD_INT 2
47465: PUSH
47466: LD_INT 30
47468: PUSH
47469: LD_INT 32
47471: PUSH
47472: EMPTY
47473: LIST
47474: LIST
47475: PUSH
47476: LD_INT 30
47478: PUSH
47479: LD_INT 33
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: LIST
47490: PPUSH
47491: CALL_OW 72
47495: ST_TO_ADDR
// if not t then
47496: LD_VAR 0 6
47500: NOT
47501: IFFALSE 47505
// continue ;
47503: GO 47362
// for j in tmp do
47505: LD_ADDR_VAR 0 3
47509: PUSH
47510: LD_VAR 0 4
47514: PUSH
47515: FOR_IN
47516: IFFALSE 47546
// if not BuildingStatus ( j ) = bs_idle then
47518: LD_VAR 0 3
47522: PPUSH
47523: CALL_OW 461
47527: PUSH
47528: LD_INT 2
47530: EQUAL
47531: NOT
47532: IFFALSE 47544
// begin busy := true ;
47534: LD_ADDR_VAR 0 8
47538: PUSH
47539: LD_INT 1
47541: ST_TO_ADDR
// break ;
47542: GO 47546
// end ;
47544: GO 47515
47546: POP
47547: POP
// if busy then
47548: LD_VAR 0 8
47552: IFFALSE 47556
// continue ;
47554: GO 47362
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47556: LD_ADDR_VAR 0 7
47560: PUSH
47561: LD_VAR 0 6
47565: PPUSH
47566: LD_INT 35
47568: PUSH
47569: LD_INT 0
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PPUSH
47576: CALL_OW 72
47580: ST_TO_ADDR
// if tw then
47581: LD_VAR 0 7
47585: IFFALSE 47662
// begin tw := tw [ 1 ] ;
47587: LD_ADDR_VAR 0 7
47591: PUSH
47592: LD_VAR 0 7
47596: PUSH
47597: LD_INT 1
47599: ARRAY
47600: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47601: LD_ADDR_VAR 0 9
47605: PUSH
47606: LD_VAR 0 7
47610: PPUSH
47611: LD_EXP 142
47615: PUSH
47616: LD_VAR 0 2
47620: ARRAY
47621: PPUSH
47622: CALL 75912 0 2
47626: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47627: LD_EXP 156
47631: PUSH
47632: LD_VAR 0 2
47636: ARRAY
47637: IFFALSE 47660
// if not weapon in mc_allowed_tower_weapons [ i ] then
47639: LD_VAR 0 9
47643: PUSH
47644: LD_EXP 156
47648: PUSH
47649: LD_VAR 0 2
47653: ARRAY
47654: IN
47655: NOT
47656: IFFALSE 47660
// continue ;
47658: GO 47362
// end else
47660: GO 47725
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47662: LD_ADDR_VAR 0 5
47666: PUSH
47667: LD_EXP 125
47671: PUSH
47672: LD_VAR 0 2
47676: ARRAY
47677: PPUSH
47678: LD_VAR 0 4
47682: PPUSH
47683: CALL 102145 0 2
47687: ST_TO_ADDR
// if not tmp2 then
47688: LD_VAR 0 5
47692: NOT
47693: IFFALSE 47697
// continue ;
47695: GO 47362
// tw := tmp2 [ 1 ] ;
47697: LD_ADDR_VAR 0 7
47701: PUSH
47702: LD_VAR 0 5
47706: PUSH
47707: LD_INT 1
47709: ARRAY
47710: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47711: LD_ADDR_VAR 0 9
47715: PUSH
47716: LD_VAR 0 5
47720: PUSH
47721: LD_INT 2
47723: ARRAY
47724: ST_TO_ADDR
// end ; if not weapon then
47725: LD_VAR 0 9
47729: NOT
47730: IFFALSE 47734
// continue ;
47732: GO 47362
// ComPlaceWeapon ( tw , weapon ) ;
47734: LD_VAR 0 7
47738: PPUSH
47739: LD_VAR 0 9
47743: PPUSH
47744: CALL_OW 148
// end ;
47748: GO 47362
47750: POP
47751: POP
// end ;
47752: LD_VAR 0 1
47756: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47757: LD_INT 0
47759: PPUSH
47760: PPUSH
47761: PPUSH
47762: PPUSH
47763: PPUSH
47764: PPUSH
47765: PPUSH
// if not mc_bases then
47766: LD_EXP 117
47770: NOT
47771: IFFALSE 47775
// exit ;
47773: GO 48543
// for i = 1 to mc_bases do
47775: LD_ADDR_VAR 0 2
47779: PUSH
47780: DOUBLE
47781: LD_INT 1
47783: DEC
47784: ST_TO_ADDR
47785: LD_EXP 117
47789: PUSH
47790: FOR_TO
47791: IFFALSE 48541
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47793: LD_EXP 130
47797: PUSH
47798: LD_VAR 0 2
47802: ARRAY
47803: NOT
47804: PUSH
47805: LD_EXP 130
47809: PUSH
47810: LD_VAR 0 2
47814: ARRAY
47815: PUSH
47816: LD_EXP 131
47820: PUSH
47821: LD_VAR 0 2
47825: ARRAY
47826: EQUAL
47827: OR
47828: PUSH
47829: LD_EXP 140
47833: PUSH
47834: LD_VAR 0 2
47838: ARRAY
47839: OR
47840: IFFALSE 47844
// continue ;
47842: GO 47790
// if mc_miners [ i ] then
47844: LD_EXP 131
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: IFFALSE 48228
// begin for j = mc_miners [ i ] downto 1 do
47856: LD_ADDR_VAR 0 3
47860: PUSH
47861: DOUBLE
47862: LD_EXP 131
47866: PUSH
47867: LD_VAR 0 2
47871: ARRAY
47872: INC
47873: ST_TO_ADDR
47874: LD_INT 1
47876: PUSH
47877: FOR_DOWNTO
47878: IFFALSE 48226
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47880: LD_EXP 131
47884: PUSH
47885: LD_VAR 0 2
47889: ARRAY
47890: PUSH
47891: LD_VAR 0 3
47895: ARRAY
47896: PPUSH
47897: CALL_OW 301
47901: PUSH
47902: LD_EXP 131
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: PUSH
47913: LD_VAR 0 3
47917: ARRAY
47918: PPUSH
47919: CALL_OW 257
47923: PUSH
47924: LD_INT 1
47926: NONEQUAL
47927: OR
47928: IFFALSE 47991
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47930: LD_ADDR_VAR 0 5
47934: PUSH
47935: LD_EXP 131
47939: PUSH
47940: LD_VAR 0 2
47944: ARRAY
47945: PUSH
47946: LD_EXP 131
47950: PUSH
47951: LD_VAR 0 2
47955: ARRAY
47956: PUSH
47957: LD_VAR 0 3
47961: ARRAY
47962: DIFF
47963: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47964: LD_ADDR_EXP 131
47968: PUSH
47969: LD_EXP 131
47973: PPUSH
47974: LD_VAR 0 2
47978: PPUSH
47979: LD_VAR 0 5
47983: PPUSH
47984: CALL_OW 1
47988: ST_TO_ADDR
// continue ;
47989: GO 47877
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47991: LD_EXP 131
47995: PUSH
47996: LD_VAR 0 2
48000: ARRAY
48001: PUSH
48002: LD_VAR 0 3
48006: ARRAY
48007: PPUSH
48008: CALL_OW 257
48012: PUSH
48013: LD_INT 1
48015: EQUAL
48016: PUSH
48017: LD_EXP 131
48021: PUSH
48022: LD_VAR 0 2
48026: ARRAY
48027: PUSH
48028: LD_VAR 0 3
48032: ARRAY
48033: PPUSH
48034: CALL_OW 459
48038: NOT
48039: AND
48040: PUSH
48041: LD_EXP 131
48045: PUSH
48046: LD_VAR 0 2
48050: ARRAY
48051: PUSH
48052: LD_VAR 0 3
48056: ARRAY
48057: PPUSH
48058: CALL_OW 314
48062: NOT
48063: AND
48064: IFFALSE 48224
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48066: LD_EXP 131
48070: PUSH
48071: LD_VAR 0 2
48075: ARRAY
48076: PUSH
48077: LD_VAR 0 3
48081: ARRAY
48082: PPUSH
48083: CALL_OW 310
48087: IFFALSE 48110
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48089: LD_EXP 131
48093: PUSH
48094: LD_VAR 0 2
48098: ARRAY
48099: PUSH
48100: LD_VAR 0 3
48104: ARRAY
48105: PPUSH
48106: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48110: LD_EXP 131
48114: PUSH
48115: LD_VAR 0 2
48119: ARRAY
48120: PUSH
48121: LD_VAR 0 3
48125: ARRAY
48126: PPUSH
48127: CALL_OW 314
48131: NOT
48132: IFFALSE 48224
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48134: LD_ADDR_VAR 0 7
48138: PUSH
48139: LD_INT 1
48141: PPUSH
48142: LD_EXP 130
48146: PUSH
48147: LD_VAR 0 2
48151: ARRAY
48152: PPUSH
48153: CALL_OW 12
48157: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48158: LD_EXP 131
48162: PUSH
48163: LD_VAR 0 2
48167: ARRAY
48168: PUSH
48169: LD_VAR 0 3
48173: ARRAY
48174: PPUSH
48175: LD_EXP 130
48179: PUSH
48180: LD_VAR 0 2
48184: ARRAY
48185: PUSH
48186: LD_VAR 0 7
48190: ARRAY
48191: PUSH
48192: LD_INT 1
48194: ARRAY
48195: PPUSH
48196: LD_EXP 130
48200: PUSH
48201: LD_VAR 0 2
48205: ARRAY
48206: PUSH
48207: LD_VAR 0 7
48211: ARRAY
48212: PUSH
48213: LD_INT 2
48215: ARRAY
48216: PPUSH
48217: LD_INT 0
48219: PPUSH
48220: CALL_OW 193
// end ; end ; end ;
48224: GO 47877
48226: POP
48227: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48228: LD_ADDR_VAR 0 5
48232: PUSH
48233: LD_EXP 117
48237: PUSH
48238: LD_VAR 0 2
48242: ARRAY
48243: PPUSH
48244: LD_INT 2
48246: PUSH
48247: LD_INT 30
48249: PUSH
48250: LD_INT 4
48252: PUSH
48253: EMPTY
48254: LIST
48255: LIST
48256: PUSH
48257: LD_INT 30
48259: PUSH
48260: LD_INT 5
48262: PUSH
48263: EMPTY
48264: LIST
48265: LIST
48266: PUSH
48267: LD_INT 30
48269: PUSH
48270: LD_INT 32
48272: PUSH
48273: EMPTY
48274: LIST
48275: LIST
48276: PUSH
48277: EMPTY
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: PPUSH
48283: CALL_OW 72
48287: ST_TO_ADDR
// if not tmp then
48288: LD_VAR 0 5
48292: NOT
48293: IFFALSE 48297
// continue ;
48295: GO 47790
// list := [ ] ;
48297: LD_ADDR_VAR 0 6
48301: PUSH
48302: EMPTY
48303: ST_TO_ADDR
// for j in tmp do
48304: LD_ADDR_VAR 0 3
48308: PUSH
48309: LD_VAR 0 5
48313: PUSH
48314: FOR_IN
48315: IFFALSE 48384
// begin for k in UnitsInside ( j ) do
48317: LD_ADDR_VAR 0 4
48321: PUSH
48322: LD_VAR 0 3
48326: PPUSH
48327: CALL_OW 313
48331: PUSH
48332: FOR_IN
48333: IFFALSE 48380
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48335: LD_VAR 0 4
48339: PPUSH
48340: CALL_OW 257
48344: PUSH
48345: LD_INT 1
48347: EQUAL
48348: PUSH
48349: LD_VAR 0 4
48353: PPUSH
48354: CALL_OW 459
48358: NOT
48359: AND
48360: IFFALSE 48378
// list := list ^ k ;
48362: LD_ADDR_VAR 0 6
48366: PUSH
48367: LD_VAR 0 6
48371: PUSH
48372: LD_VAR 0 4
48376: ADD
48377: ST_TO_ADDR
48378: GO 48332
48380: POP
48381: POP
// end ;
48382: GO 48314
48384: POP
48385: POP
// list := list diff mc_miners [ i ] ;
48386: LD_ADDR_VAR 0 6
48390: PUSH
48391: LD_VAR 0 6
48395: PUSH
48396: LD_EXP 131
48400: PUSH
48401: LD_VAR 0 2
48405: ARRAY
48406: DIFF
48407: ST_TO_ADDR
// if not list then
48408: LD_VAR 0 6
48412: NOT
48413: IFFALSE 48417
// continue ;
48415: GO 47790
// k := mc_mines [ i ] - mc_miners [ i ] ;
48417: LD_ADDR_VAR 0 4
48421: PUSH
48422: LD_EXP 130
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PUSH
48433: LD_EXP 131
48437: PUSH
48438: LD_VAR 0 2
48442: ARRAY
48443: MINUS
48444: ST_TO_ADDR
// if k > list then
48445: LD_VAR 0 4
48449: PUSH
48450: LD_VAR 0 6
48454: GREATER
48455: IFFALSE 48467
// k := list ;
48457: LD_ADDR_VAR 0 4
48461: PUSH
48462: LD_VAR 0 6
48466: ST_TO_ADDR
// for j = 1 to k do
48467: LD_ADDR_VAR 0 3
48471: PUSH
48472: DOUBLE
48473: LD_INT 1
48475: DEC
48476: ST_TO_ADDR
48477: LD_VAR 0 4
48481: PUSH
48482: FOR_TO
48483: IFFALSE 48537
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48485: LD_ADDR_EXP 131
48489: PUSH
48490: LD_EXP 131
48494: PPUSH
48495: LD_VAR 0 2
48499: PUSH
48500: LD_EXP 131
48504: PUSH
48505: LD_VAR 0 2
48509: ARRAY
48510: PUSH
48511: LD_INT 1
48513: PLUS
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PPUSH
48519: LD_VAR 0 6
48523: PUSH
48524: LD_VAR 0 3
48528: ARRAY
48529: PPUSH
48530: CALL 70902 0 3
48534: ST_TO_ADDR
48535: GO 48482
48537: POP
48538: POP
// end ;
48539: GO 47790
48541: POP
48542: POP
// end ;
48543: LD_VAR 0 1
48547: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48548: LD_INT 0
48550: PPUSH
48551: PPUSH
48552: PPUSH
48553: PPUSH
48554: PPUSH
48555: PPUSH
48556: PPUSH
48557: PPUSH
48558: PPUSH
48559: PPUSH
48560: PPUSH
// if not mc_bases then
48561: LD_EXP 117
48565: NOT
48566: IFFALSE 48570
// exit ;
48568: GO 50393
// for i = 1 to mc_bases do
48570: LD_ADDR_VAR 0 2
48574: PUSH
48575: DOUBLE
48576: LD_INT 1
48578: DEC
48579: ST_TO_ADDR
48580: LD_EXP 117
48584: PUSH
48585: FOR_TO
48586: IFFALSE 50391
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48588: LD_EXP 117
48592: PUSH
48593: LD_VAR 0 2
48597: ARRAY
48598: NOT
48599: PUSH
48600: LD_EXP 124
48604: PUSH
48605: LD_VAR 0 2
48609: ARRAY
48610: OR
48611: IFFALSE 48615
// continue ;
48613: GO 48585
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48615: LD_EXP 133
48619: PUSH
48620: LD_VAR 0 2
48624: ARRAY
48625: NOT
48626: PUSH
48627: LD_EXP 134
48631: PUSH
48632: LD_VAR 0 2
48636: ARRAY
48637: AND
48638: IFFALSE 48676
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48640: LD_ADDR_EXP 134
48644: PUSH
48645: LD_EXP 134
48649: PPUSH
48650: LD_VAR 0 2
48654: PPUSH
48655: EMPTY
48656: PPUSH
48657: CALL_OW 1
48661: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48662: LD_VAR 0 2
48666: PPUSH
48667: LD_INT 107
48669: PPUSH
48670: CALL 39444 0 2
// continue ;
48674: GO 48585
// end ; target := [ ] ;
48676: LD_ADDR_VAR 0 7
48680: PUSH
48681: EMPTY
48682: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48683: LD_ADDR_VAR 0 6
48687: PUSH
48688: LD_EXP 117
48692: PUSH
48693: LD_VAR 0 2
48697: ARRAY
48698: PUSH
48699: LD_INT 1
48701: ARRAY
48702: PPUSH
48703: CALL_OW 255
48707: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48708: LD_ADDR_VAR 0 9
48712: PUSH
48713: LD_EXP 117
48717: PUSH
48718: LD_VAR 0 2
48722: ARRAY
48723: PPUSH
48724: LD_INT 2
48726: PUSH
48727: LD_INT 30
48729: PUSH
48730: LD_INT 0
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: PUSH
48737: LD_INT 30
48739: PUSH
48740: LD_INT 1
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: PUSH
48747: EMPTY
48748: LIST
48749: LIST
48750: LIST
48751: PPUSH
48752: CALL_OW 72
48756: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48757: LD_ADDR_VAR 0 3
48761: PUSH
48762: DOUBLE
48763: LD_EXP 133
48767: PUSH
48768: LD_VAR 0 2
48772: ARRAY
48773: INC
48774: ST_TO_ADDR
48775: LD_INT 1
48777: PUSH
48778: FOR_DOWNTO
48779: IFFALSE 49024
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48781: LD_EXP 133
48785: PUSH
48786: LD_VAR 0 2
48790: ARRAY
48791: PUSH
48792: LD_VAR 0 3
48796: ARRAY
48797: PUSH
48798: LD_INT 2
48800: ARRAY
48801: PPUSH
48802: LD_EXP 133
48806: PUSH
48807: LD_VAR 0 2
48811: ARRAY
48812: PUSH
48813: LD_VAR 0 3
48817: ARRAY
48818: PUSH
48819: LD_INT 3
48821: ARRAY
48822: PPUSH
48823: CALL_OW 488
48827: PUSH
48828: LD_EXP 133
48832: PUSH
48833: LD_VAR 0 2
48837: ARRAY
48838: PUSH
48839: LD_VAR 0 3
48843: ARRAY
48844: PUSH
48845: LD_INT 2
48847: ARRAY
48848: PPUSH
48849: LD_EXP 133
48853: PUSH
48854: LD_VAR 0 2
48858: ARRAY
48859: PUSH
48860: LD_VAR 0 3
48864: ARRAY
48865: PUSH
48866: LD_INT 3
48868: ARRAY
48869: PPUSH
48870: CALL_OW 284
48874: PUSH
48875: LD_INT 0
48877: EQUAL
48878: AND
48879: IFFALSE 48934
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48881: LD_ADDR_VAR 0 5
48885: PUSH
48886: LD_EXP 133
48890: PUSH
48891: LD_VAR 0 2
48895: ARRAY
48896: PPUSH
48897: LD_VAR 0 3
48901: PPUSH
48902: CALL_OW 3
48906: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48907: LD_ADDR_EXP 133
48911: PUSH
48912: LD_EXP 133
48916: PPUSH
48917: LD_VAR 0 2
48921: PPUSH
48922: LD_VAR 0 5
48926: PPUSH
48927: CALL_OW 1
48931: ST_TO_ADDR
// continue ;
48932: GO 48778
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48934: LD_VAR 0 6
48938: PPUSH
48939: LD_EXP 133
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: PUSH
48950: LD_VAR 0 3
48954: ARRAY
48955: PUSH
48956: LD_INT 2
48958: ARRAY
48959: PPUSH
48960: LD_EXP 133
48964: PUSH
48965: LD_VAR 0 2
48969: ARRAY
48970: PUSH
48971: LD_VAR 0 3
48975: ARRAY
48976: PUSH
48977: LD_INT 3
48979: ARRAY
48980: PPUSH
48981: LD_INT 30
48983: PPUSH
48984: CALL 71798 0 4
48988: PUSH
48989: LD_INT 4
48991: ARRAY
48992: PUSH
48993: LD_INT 0
48995: EQUAL
48996: IFFALSE 49022
// begin target := mc_crates [ i ] [ j ] ;
48998: LD_ADDR_VAR 0 7
49002: PUSH
49003: LD_EXP 133
49007: PUSH
49008: LD_VAR 0 2
49012: ARRAY
49013: PUSH
49014: LD_VAR 0 3
49018: ARRAY
49019: ST_TO_ADDR
// break ;
49020: GO 49024
// end ; end ;
49022: GO 48778
49024: POP
49025: POP
// if not target then
49026: LD_VAR 0 7
49030: NOT
49031: IFFALSE 49035
// continue ;
49033: GO 48585
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
49035: LD_ADDR_VAR 0 8
49039: PUSH
49040: LD_EXP 136
49044: PUSH
49045: LD_VAR 0 2
49049: ARRAY
49050: PPUSH
49051: LD_INT 2
49053: PUSH
49054: LD_INT 3
49056: PUSH
49057: LD_INT 58
49059: PUSH
49060: EMPTY
49061: LIST
49062: PUSH
49063: EMPTY
49064: LIST
49065: LIST
49066: PUSH
49067: LD_INT 61
49069: PUSH
49070: EMPTY
49071: LIST
49072: PUSH
49073: LD_INT 33
49075: PUSH
49076: LD_INT 5
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: LD_INT 33
49085: PUSH
49086: LD_INT 3
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: PUSH
49100: LD_INT 2
49102: PUSH
49103: LD_INT 34
49105: PUSH
49106: LD_INT 32
49108: PUSH
49109: EMPTY
49110: LIST
49111: LIST
49112: PUSH
49113: LD_INT 34
49115: PUSH
49116: LD_INT 51
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: PUSH
49123: LD_INT 34
49125: PUSH
49126: LD_INT 12
49128: PUSH
49129: EMPTY
49130: LIST
49131: LIST
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: PPUSH
49143: CALL_OW 72
49147: ST_TO_ADDR
// if not cargo then
49148: LD_VAR 0 8
49152: NOT
49153: IFFALSE 49859
// begin if mc_crates_collector [ i ] < 5 then
49155: LD_EXP 134
49159: PUSH
49160: LD_VAR 0 2
49164: ARRAY
49165: PUSH
49166: LD_INT 5
49168: LESS
49169: IFFALSE 49535
// begin if mc_ape [ i ] then
49171: LD_EXP 146
49175: PUSH
49176: LD_VAR 0 2
49180: ARRAY
49181: IFFALSE 49228
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49183: LD_ADDR_VAR 0 5
49187: PUSH
49188: LD_EXP 146
49192: PUSH
49193: LD_VAR 0 2
49197: ARRAY
49198: PPUSH
49199: LD_INT 25
49201: PUSH
49202: LD_INT 16
49204: PUSH
49205: EMPTY
49206: LIST
49207: LIST
49208: PUSH
49209: LD_INT 24
49211: PUSH
49212: LD_INT 750
49214: PUSH
49215: EMPTY
49216: LIST
49217: LIST
49218: PUSH
49219: EMPTY
49220: LIST
49221: LIST
49222: PPUSH
49223: CALL_OW 72
49227: ST_TO_ADDR
// if not tmp then
49228: LD_VAR 0 5
49232: NOT
49233: IFFALSE 49280
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49235: LD_ADDR_VAR 0 5
49239: PUSH
49240: LD_EXP 117
49244: PUSH
49245: LD_VAR 0 2
49249: ARRAY
49250: PPUSH
49251: LD_INT 25
49253: PUSH
49254: LD_INT 2
49256: PUSH
49257: EMPTY
49258: LIST
49259: LIST
49260: PUSH
49261: LD_INT 24
49263: PUSH
49264: LD_INT 750
49266: PUSH
49267: EMPTY
49268: LIST
49269: LIST
49270: PUSH
49271: EMPTY
49272: LIST
49273: LIST
49274: PPUSH
49275: CALL_OW 72
49279: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49280: LD_EXP 146
49284: PUSH
49285: LD_VAR 0 2
49289: ARRAY
49290: PUSH
49291: LD_EXP 117
49295: PUSH
49296: LD_VAR 0 2
49300: ARRAY
49301: PPUSH
49302: LD_INT 25
49304: PUSH
49305: LD_INT 2
49307: PUSH
49308: EMPTY
49309: LIST
49310: LIST
49311: PUSH
49312: LD_INT 24
49314: PUSH
49315: LD_INT 750
49317: PUSH
49318: EMPTY
49319: LIST
49320: LIST
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PPUSH
49326: CALL_OW 72
49330: AND
49331: PUSH
49332: LD_VAR 0 5
49336: PUSH
49337: LD_INT 5
49339: LESS
49340: AND
49341: IFFALSE 49423
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49343: LD_ADDR_VAR 0 3
49347: PUSH
49348: LD_EXP 117
49352: PUSH
49353: LD_VAR 0 2
49357: ARRAY
49358: PPUSH
49359: LD_INT 25
49361: PUSH
49362: LD_INT 2
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PUSH
49369: LD_INT 24
49371: PUSH
49372: LD_INT 750
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PUSH
49379: EMPTY
49380: LIST
49381: LIST
49382: PPUSH
49383: CALL_OW 72
49387: PUSH
49388: FOR_IN
49389: IFFALSE 49421
// begin tmp := tmp union j ;
49391: LD_ADDR_VAR 0 5
49395: PUSH
49396: LD_VAR 0 5
49400: PUSH
49401: LD_VAR 0 3
49405: UNION
49406: ST_TO_ADDR
// if tmp >= 5 then
49407: LD_VAR 0 5
49411: PUSH
49412: LD_INT 5
49414: GREATEREQUAL
49415: IFFALSE 49419
// break ;
49417: GO 49421
// end ;
49419: GO 49388
49421: POP
49422: POP
// end ; if not tmp then
49423: LD_VAR 0 5
49427: NOT
49428: IFFALSE 49432
// continue ;
49430: GO 48585
// for j in tmp do
49432: LD_ADDR_VAR 0 3
49436: PUSH
49437: LD_VAR 0 5
49441: PUSH
49442: FOR_IN
49443: IFFALSE 49533
// if not GetTag ( j ) then
49445: LD_VAR 0 3
49449: PPUSH
49450: CALL_OW 110
49454: NOT
49455: IFFALSE 49531
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49457: LD_ADDR_EXP 134
49461: PUSH
49462: LD_EXP 134
49466: PPUSH
49467: LD_VAR 0 2
49471: PUSH
49472: LD_EXP 134
49476: PUSH
49477: LD_VAR 0 2
49481: ARRAY
49482: PUSH
49483: LD_INT 1
49485: PLUS
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: PPUSH
49491: LD_VAR 0 3
49495: PPUSH
49496: CALL 70902 0 3
49500: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49501: LD_VAR 0 3
49505: PPUSH
49506: LD_INT 107
49508: PPUSH
49509: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49513: LD_EXP 134
49517: PUSH
49518: LD_VAR 0 2
49522: ARRAY
49523: PUSH
49524: LD_INT 5
49526: GREATEREQUAL
49527: IFFALSE 49531
// break ;
49529: GO 49533
// end ;
49531: GO 49442
49533: POP
49534: POP
// end ; if mc_crates_collector [ i ] and target then
49535: LD_EXP 134
49539: PUSH
49540: LD_VAR 0 2
49544: ARRAY
49545: PUSH
49546: LD_VAR 0 7
49550: AND
49551: IFFALSE 49857
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49553: LD_EXP 134
49557: PUSH
49558: LD_VAR 0 2
49562: ARRAY
49563: PUSH
49564: LD_VAR 0 7
49568: PUSH
49569: LD_INT 1
49571: ARRAY
49572: LESS
49573: IFFALSE 49593
// tmp := mc_crates_collector [ i ] else
49575: LD_ADDR_VAR 0 5
49579: PUSH
49580: LD_EXP 134
49584: PUSH
49585: LD_VAR 0 2
49589: ARRAY
49590: ST_TO_ADDR
49591: GO 49607
// tmp := target [ 1 ] ;
49593: LD_ADDR_VAR 0 5
49597: PUSH
49598: LD_VAR 0 7
49602: PUSH
49603: LD_INT 1
49605: ARRAY
49606: ST_TO_ADDR
// k := 0 ;
49607: LD_ADDR_VAR 0 4
49611: PUSH
49612: LD_INT 0
49614: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49615: LD_ADDR_VAR 0 3
49619: PUSH
49620: LD_EXP 134
49624: PUSH
49625: LD_VAR 0 2
49629: ARRAY
49630: PUSH
49631: FOR_IN
49632: IFFALSE 49855
// begin k := k + 1 ;
49634: LD_ADDR_VAR 0 4
49638: PUSH
49639: LD_VAR 0 4
49643: PUSH
49644: LD_INT 1
49646: PLUS
49647: ST_TO_ADDR
// if k > tmp then
49648: LD_VAR 0 4
49652: PUSH
49653: LD_VAR 0 5
49657: GREATER
49658: IFFALSE 49662
// break ;
49660: GO 49855
// if not GetClass ( j ) in [ 2 , 16 ] then
49662: LD_VAR 0 3
49666: PPUSH
49667: CALL_OW 257
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 16
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: IN
49682: NOT
49683: IFFALSE 49736
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49685: LD_ADDR_EXP 134
49689: PUSH
49690: LD_EXP 134
49694: PPUSH
49695: LD_VAR 0 2
49699: PPUSH
49700: LD_EXP 134
49704: PUSH
49705: LD_VAR 0 2
49709: ARRAY
49710: PUSH
49711: LD_VAR 0 3
49715: DIFF
49716: PPUSH
49717: CALL_OW 1
49721: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49722: LD_VAR 0 3
49726: PPUSH
49727: LD_INT 0
49729: PPUSH
49730: CALL_OW 109
// continue ;
49734: GO 49631
// end ; if IsInUnit ( j ) then
49736: LD_VAR 0 3
49740: PPUSH
49741: CALL_OW 310
49745: IFFALSE 49756
// ComExitBuilding ( j ) ;
49747: LD_VAR 0 3
49751: PPUSH
49752: CALL_OW 122
// wait ( 3 ) ;
49756: LD_INT 3
49758: PPUSH
49759: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49763: LD_VAR 0 3
49767: PPUSH
49768: CALL_OW 314
49772: PUSH
49773: LD_VAR 0 6
49777: PPUSH
49778: LD_VAR 0 7
49782: PUSH
49783: LD_INT 2
49785: ARRAY
49786: PPUSH
49787: LD_VAR 0 7
49791: PUSH
49792: LD_INT 3
49794: ARRAY
49795: PPUSH
49796: LD_INT 30
49798: PPUSH
49799: CALL 71798 0 4
49803: PUSH
49804: LD_INT 4
49806: ARRAY
49807: AND
49808: IFFALSE 49826
// ComStandNearbyBuilding ( j , depot ) else
49810: LD_VAR 0 3
49814: PPUSH
49815: LD_VAR 0 9
49819: PPUSH
49820: CALL 67480 0 2
49824: GO 49853
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49826: LD_VAR 0 3
49830: PPUSH
49831: LD_VAR 0 7
49835: PUSH
49836: LD_INT 2
49838: ARRAY
49839: PPUSH
49840: LD_VAR 0 7
49844: PUSH
49845: LD_INT 3
49847: ARRAY
49848: PPUSH
49849: CALL_OW 117
// end ;
49853: GO 49631
49855: POP
49856: POP
// end ; end else
49857: GO 50389
// begin for j in cargo do
49859: LD_ADDR_VAR 0 3
49863: PUSH
49864: LD_VAR 0 8
49868: PUSH
49869: FOR_IN
49870: IFFALSE 50387
// begin if GetTag ( j ) <> 0 then
49872: LD_VAR 0 3
49876: PPUSH
49877: CALL_OW 110
49881: PUSH
49882: LD_INT 0
49884: NONEQUAL
49885: IFFALSE 49889
// continue ;
49887: GO 49869
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49889: LD_VAR 0 3
49893: PPUSH
49894: CALL_OW 256
49898: PUSH
49899: LD_INT 1000
49901: LESS
49902: PUSH
49903: LD_VAR 0 3
49907: PPUSH
49908: LD_EXP 141
49912: PUSH
49913: LD_VAR 0 2
49917: ARRAY
49918: PPUSH
49919: CALL_OW 308
49923: NOT
49924: AND
49925: IFFALSE 49947
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49927: LD_VAR 0 3
49931: PPUSH
49932: LD_EXP 141
49936: PUSH
49937: LD_VAR 0 2
49941: ARRAY
49942: PPUSH
49943: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49947: LD_VAR 0 3
49951: PPUSH
49952: CALL_OW 256
49956: PUSH
49957: LD_INT 1000
49959: LESS
49960: PUSH
49961: LD_VAR 0 3
49965: PPUSH
49966: LD_EXP 141
49970: PUSH
49971: LD_VAR 0 2
49975: ARRAY
49976: PPUSH
49977: CALL_OW 308
49981: AND
49982: IFFALSE 49986
// continue ;
49984: GO 49869
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49986: LD_VAR 0 3
49990: PPUSH
49991: CALL_OW 262
49995: PUSH
49996: LD_INT 2
49998: EQUAL
49999: PUSH
50000: LD_VAR 0 3
50004: PPUSH
50005: CALL_OW 261
50009: PUSH
50010: LD_INT 15
50012: LESS
50013: AND
50014: IFFALSE 50018
// continue ;
50016: GO 49869
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
50018: LD_VAR 0 3
50022: PPUSH
50023: CALL_OW 262
50027: PUSH
50028: LD_INT 1
50030: EQUAL
50031: PUSH
50032: LD_VAR 0 3
50036: PPUSH
50037: CALL_OW 261
50041: PUSH
50042: LD_INT 10
50044: LESS
50045: AND
50046: IFFALSE 50326
// begin if not depot then
50048: LD_VAR 0 9
50052: NOT
50053: IFFALSE 50057
// continue ;
50055: GO 49869
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50057: LD_VAR 0 3
50061: PPUSH
50062: LD_VAR 0 9
50066: PPUSH
50067: LD_VAR 0 3
50071: PPUSH
50072: CALL_OW 74
50076: PPUSH
50077: CALL_OW 296
50081: PUSH
50082: LD_INT 6
50084: LESS
50085: IFFALSE 50101
// SetFuel ( j , 100 ) else
50087: LD_VAR 0 3
50091: PPUSH
50092: LD_INT 100
50094: PPUSH
50095: CALL_OW 240
50099: GO 50326
// if GetFuel ( j ) = 0 then
50101: LD_VAR 0 3
50105: PPUSH
50106: CALL_OW 261
50110: PUSH
50111: LD_INT 0
50113: EQUAL
50114: IFFALSE 50326
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50116: LD_ADDR_EXP 136
50120: PUSH
50121: LD_EXP 136
50125: PPUSH
50126: LD_VAR 0 2
50130: PPUSH
50131: LD_EXP 136
50135: PUSH
50136: LD_VAR 0 2
50140: ARRAY
50141: PUSH
50142: LD_VAR 0 3
50146: DIFF
50147: PPUSH
50148: CALL_OW 1
50152: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50153: LD_VAR 0 3
50157: PPUSH
50158: CALL_OW 263
50162: PUSH
50163: LD_INT 1
50165: EQUAL
50166: IFFALSE 50182
// ComExitVehicle ( IsInUnit ( j ) ) ;
50168: LD_VAR 0 3
50172: PPUSH
50173: CALL_OW 310
50177: PPUSH
50178: CALL_OW 121
// if GetControl ( j ) = control_remote then
50182: LD_VAR 0 3
50186: PPUSH
50187: CALL_OW 263
50191: PUSH
50192: LD_INT 2
50194: EQUAL
50195: IFFALSE 50206
// ComUnlink ( j ) ;
50197: LD_VAR 0 3
50201: PPUSH
50202: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50206: LD_ADDR_VAR 0 10
50210: PUSH
50211: LD_VAR 0 2
50215: PPUSH
50216: LD_INT 3
50218: PPUSH
50219: CALL 59965 0 2
50223: ST_TO_ADDR
// if fac then
50224: LD_VAR 0 10
50228: IFFALSE 50324
// begin for k in fac do
50230: LD_ADDR_VAR 0 4
50234: PUSH
50235: LD_VAR 0 10
50239: PUSH
50240: FOR_IN
50241: IFFALSE 50322
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50243: LD_ADDR_VAR 0 11
50247: PUSH
50248: LD_VAR 0 10
50252: PPUSH
50253: LD_VAR 0 3
50257: PPUSH
50258: CALL_OW 265
50262: PPUSH
50263: LD_VAR 0 3
50267: PPUSH
50268: CALL_OW 262
50272: PPUSH
50273: LD_VAR 0 3
50277: PPUSH
50278: CALL_OW 263
50282: PPUSH
50283: LD_VAR 0 3
50287: PPUSH
50288: CALL_OW 264
50292: PPUSH
50293: CALL 68398 0 5
50297: ST_TO_ADDR
// if components then
50298: LD_VAR 0 11
50302: IFFALSE 50320
// begin MC_InsertProduceList ( i , components ) ;
50304: LD_VAR 0 2
50308: PPUSH
50309: LD_VAR 0 11
50313: PPUSH
50314: CALL 59510 0 2
// break ;
50318: GO 50322
// end ; end ;
50320: GO 50240
50322: POP
50323: POP
// end ; continue ;
50324: GO 49869
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50326: LD_VAR 0 3
50330: PPUSH
50331: LD_INT 1
50333: PPUSH
50334: CALL_OW 289
50338: PUSH
50339: LD_INT 100
50341: LESS
50342: PUSH
50343: LD_VAR 0 3
50347: PPUSH
50348: CALL_OW 314
50352: NOT
50353: AND
50354: IFFALSE 50383
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50356: LD_VAR 0 3
50360: PPUSH
50361: LD_VAR 0 7
50365: PUSH
50366: LD_INT 2
50368: ARRAY
50369: PPUSH
50370: LD_VAR 0 7
50374: PUSH
50375: LD_INT 3
50377: ARRAY
50378: PPUSH
50379: CALL_OW 117
// break ;
50383: GO 50387
// end ;
50385: GO 49869
50387: POP
50388: POP
// end ; end ;
50389: GO 48585
50391: POP
50392: POP
// end ;
50393: LD_VAR 0 1
50397: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50398: LD_INT 0
50400: PPUSH
50401: PPUSH
50402: PPUSH
50403: PPUSH
// if not mc_bases then
50404: LD_EXP 117
50408: NOT
50409: IFFALSE 50413
// exit ;
50411: GO 50574
// for i = 1 to mc_bases do
50413: LD_ADDR_VAR 0 2
50417: PUSH
50418: DOUBLE
50419: LD_INT 1
50421: DEC
50422: ST_TO_ADDR
50423: LD_EXP 117
50427: PUSH
50428: FOR_TO
50429: IFFALSE 50572
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50431: LD_ADDR_VAR 0 4
50435: PUSH
50436: LD_EXP 136
50440: PUSH
50441: LD_VAR 0 2
50445: ARRAY
50446: PUSH
50447: LD_EXP 139
50451: PUSH
50452: LD_VAR 0 2
50456: ARRAY
50457: UNION
50458: PPUSH
50459: LD_INT 33
50461: PUSH
50462: LD_INT 2
50464: PUSH
50465: EMPTY
50466: LIST
50467: LIST
50468: PPUSH
50469: CALL_OW 72
50473: ST_TO_ADDR
// if tmp then
50474: LD_VAR 0 4
50478: IFFALSE 50570
// for j in tmp do
50480: LD_ADDR_VAR 0 3
50484: PUSH
50485: LD_VAR 0 4
50489: PUSH
50490: FOR_IN
50491: IFFALSE 50568
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50493: LD_VAR 0 3
50497: PPUSH
50498: CALL_OW 312
50502: NOT
50503: PUSH
50504: LD_VAR 0 3
50508: PPUSH
50509: CALL_OW 256
50513: PUSH
50514: LD_INT 250
50516: GREATEREQUAL
50517: AND
50518: IFFALSE 50531
// Connect ( j ) else
50520: LD_VAR 0 3
50524: PPUSH
50525: CALL 73873 0 1
50529: GO 50566
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50531: LD_VAR 0 3
50535: PPUSH
50536: CALL_OW 256
50540: PUSH
50541: LD_INT 250
50543: LESS
50544: PUSH
50545: LD_VAR 0 3
50549: PPUSH
50550: CALL_OW 312
50554: AND
50555: IFFALSE 50566
// ComUnlink ( j ) ;
50557: LD_VAR 0 3
50561: PPUSH
50562: CALL_OW 136
50566: GO 50490
50568: POP
50569: POP
// end ;
50570: GO 50428
50572: POP
50573: POP
// end ;
50574: LD_VAR 0 1
50578: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50579: LD_INT 0
50581: PPUSH
50582: PPUSH
50583: PPUSH
50584: PPUSH
50585: PPUSH
// if not mc_bases then
50586: LD_EXP 117
50590: NOT
50591: IFFALSE 50595
// exit ;
50593: GO 51040
// for i = 1 to mc_bases do
50595: LD_ADDR_VAR 0 2
50599: PUSH
50600: DOUBLE
50601: LD_INT 1
50603: DEC
50604: ST_TO_ADDR
50605: LD_EXP 117
50609: PUSH
50610: FOR_TO
50611: IFFALSE 51038
// begin if not mc_produce [ i ] then
50613: LD_EXP 138
50617: PUSH
50618: LD_VAR 0 2
50622: ARRAY
50623: NOT
50624: IFFALSE 50628
// continue ;
50626: GO 50610
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50628: LD_ADDR_VAR 0 5
50632: PUSH
50633: LD_EXP 117
50637: PUSH
50638: LD_VAR 0 2
50642: ARRAY
50643: PPUSH
50644: LD_INT 30
50646: PUSH
50647: LD_INT 3
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: PPUSH
50654: CALL_OW 72
50658: ST_TO_ADDR
// if not fac then
50659: LD_VAR 0 5
50663: NOT
50664: IFFALSE 50668
// continue ;
50666: GO 50610
// for j in fac do
50668: LD_ADDR_VAR 0 3
50672: PUSH
50673: LD_VAR 0 5
50677: PUSH
50678: FOR_IN
50679: IFFALSE 51034
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50681: LD_VAR 0 3
50685: PPUSH
50686: CALL_OW 461
50690: PUSH
50691: LD_INT 2
50693: NONEQUAL
50694: PUSH
50695: LD_VAR 0 3
50699: PPUSH
50700: LD_INT 15
50702: PPUSH
50703: CALL 73501 0 2
50707: PUSH
50708: LD_INT 4
50710: ARRAY
50711: OR
50712: IFFALSE 50716
// continue ;
50714: GO 50678
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50716: LD_VAR 0 3
50720: PPUSH
50721: LD_EXP 138
50725: PUSH
50726: LD_VAR 0 2
50730: ARRAY
50731: PUSH
50732: LD_INT 1
50734: ARRAY
50735: PUSH
50736: LD_INT 1
50738: ARRAY
50739: PPUSH
50740: LD_EXP 138
50744: PUSH
50745: LD_VAR 0 2
50749: ARRAY
50750: PUSH
50751: LD_INT 1
50753: ARRAY
50754: PUSH
50755: LD_INT 2
50757: ARRAY
50758: PPUSH
50759: LD_EXP 138
50763: PUSH
50764: LD_VAR 0 2
50768: ARRAY
50769: PUSH
50770: LD_INT 1
50772: ARRAY
50773: PUSH
50774: LD_INT 3
50776: ARRAY
50777: PPUSH
50778: LD_EXP 138
50782: PUSH
50783: LD_VAR 0 2
50787: ARRAY
50788: PUSH
50789: LD_INT 1
50791: ARRAY
50792: PUSH
50793: LD_INT 4
50795: ARRAY
50796: PPUSH
50797: CALL_OW 448
50801: PUSH
50802: LD_VAR 0 3
50806: PPUSH
50807: LD_EXP 138
50811: PUSH
50812: LD_VAR 0 2
50816: ARRAY
50817: PUSH
50818: LD_INT 1
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PUSH
50826: LD_EXP 138
50830: PUSH
50831: LD_VAR 0 2
50835: ARRAY
50836: PUSH
50837: LD_INT 1
50839: ARRAY
50840: PUSH
50841: LD_INT 2
50843: ARRAY
50844: PUSH
50845: LD_EXP 138
50849: PUSH
50850: LD_VAR 0 2
50854: ARRAY
50855: PUSH
50856: LD_INT 1
50858: ARRAY
50859: PUSH
50860: LD_INT 3
50862: ARRAY
50863: PUSH
50864: LD_EXP 138
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: PUSH
50875: LD_INT 1
50877: ARRAY
50878: PUSH
50879: LD_INT 4
50881: ARRAY
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: PPUSH
50889: CALL 77268 0 2
50893: AND
50894: IFFALSE 51032
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50896: LD_VAR 0 3
50900: PPUSH
50901: LD_EXP 138
50905: PUSH
50906: LD_VAR 0 2
50910: ARRAY
50911: PUSH
50912: LD_INT 1
50914: ARRAY
50915: PUSH
50916: LD_INT 1
50918: ARRAY
50919: PPUSH
50920: LD_EXP 138
50924: PUSH
50925: LD_VAR 0 2
50929: ARRAY
50930: PUSH
50931: LD_INT 1
50933: ARRAY
50934: PUSH
50935: LD_INT 2
50937: ARRAY
50938: PPUSH
50939: LD_EXP 138
50943: PUSH
50944: LD_VAR 0 2
50948: ARRAY
50949: PUSH
50950: LD_INT 1
50952: ARRAY
50953: PUSH
50954: LD_INT 3
50956: ARRAY
50957: PPUSH
50958: LD_EXP 138
50962: PUSH
50963: LD_VAR 0 2
50967: ARRAY
50968: PUSH
50969: LD_INT 1
50971: ARRAY
50972: PUSH
50973: LD_INT 4
50975: ARRAY
50976: PPUSH
50977: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50981: LD_ADDR_VAR 0 4
50985: PUSH
50986: LD_EXP 138
50990: PUSH
50991: LD_VAR 0 2
50995: ARRAY
50996: PPUSH
50997: LD_INT 1
50999: PPUSH
51000: CALL_OW 3
51004: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51005: LD_ADDR_EXP 138
51009: PUSH
51010: LD_EXP 138
51014: PPUSH
51015: LD_VAR 0 2
51019: PPUSH
51020: LD_VAR 0 4
51024: PPUSH
51025: CALL_OW 1
51029: ST_TO_ADDR
// break ;
51030: GO 51034
// end ; end ;
51032: GO 50678
51034: POP
51035: POP
// end ;
51036: GO 50610
51038: POP
51039: POP
// end ;
51040: LD_VAR 0 1
51044: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51045: LD_INT 0
51047: PPUSH
51048: PPUSH
51049: PPUSH
// if not mc_bases then
51050: LD_EXP 117
51054: NOT
51055: IFFALSE 51059
// exit ;
51057: GO 51148
// for i = 1 to mc_bases do
51059: LD_ADDR_VAR 0 2
51063: PUSH
51064: DOUBLE
51065: LD_INT 1
51067: DEC
51068: ST_TO_ADDR
51069: LD_EXP 117
51073: PUSH
51074: FOR_TO
51075: IFFALSE 51146
// begin if mc_attack [ i ] then
51077: LD_EXP 137
51081: PUSH
51082: LD_VAR 0 2
51086: ARRAY
51087: IFFALSE 51144
// begin tmp := mc_attack [ i ] [ 1 ] ;
51089: LD_ADDR_VAR 0 3
51093: PUSH
51094: LD_EXP 137
51098: PUSH
51099: LD_VAR 0 2
51103: ARRAY
51104: PUSH
51105: LD_INT 1
51107: ARRAY
51108: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51109: LD_ADDR_EXP 137
51113: PUSH
51114: LD_EXP 137
51118: PPUSH
51119: LD_VAR 0 2
51123: PPUSH
51124: EMPTY
51125: PPUSH
51126: CALL_OW 1
51130: ST_TO_ADDR
// Attack ( tmp ) ;
51131: LD_VAR 0 3
51135: PPUSH
51136: CALL 125029 0 1
// exit ;
51140: POP
51141: POP
51142: GO 51148
// end ; end ;
51144: GO 51074
51146: POP
51147: POP
// end ;
51148: LD_VAR 0 1
51152: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51153: LD_INT 0
51155: PPUSH
51156: PPUSH
51157: PPUSH
51158: PPUSH
51159: PPUSH
51160: PPUSH
51161: PPUSH
// if not mc_bases then
51162: LD_EXP 117
51166: NOT
51167: IFFALSE 51171
// exit ;
51169: GO 52028
// for i = 1 to mc_bases do
51171: LD_ADDR_VAR 0 2
51175: PUSH
51176: DOUBLE
51177: LD_INT 1
51179: DEC
51180: ST_TO_ADDR
51181: LD_EXP 117
51185: PUSH
51186: FOR_TO
51187: IFFALSE 52026
// begin if not mc_bases [ i ] then
51189: LD_EXP 117
51193: PUSH
51194: LD_VAR 0 2
51198: ARRAY
51199: NOT
51200: IFFALSE 51204
// continue ;
51202: GO 51186
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51204: LD_ADDR_VAR 0 7
51208: PUSH
51209: LD_EXP 117
51213: PUSH
51214: LD_VAR 0 2
51218: ARRAY
51219: PUSH
51220: LD_INT 1
51222: ARRAY
51223: PPUSH
51224: CALL 67702 0 1
51228: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51229: LD_ADDR_EXP 140
51233: PUSH
51234: LD_EXP 140
51238: PPUSH
51239: LD_VAR 0 2
51243: PPUSH
51244: LD_EXP 117
51248: PUSH
51249: LD_VAR 0 2
51253: ARRAY
51254: PUSH
51255: LD_INT 1
51257: ARRAY
51258: PPUSH
51259: CALL_OW 255
51263: PPUSH
51264: LD_EXP 142
51268: PUSH
51269: LD_VAR 0 2
51273: ARRAY
51274: PPUSH
51275: CALL 67667 0 2
51279: PPUSH
51280: CALL_OW 1
51284: ST_TO_ADDR
// if not mc_scan [ i ] then
51285: LD_EXP 140
51289: PUSH
51290: LD_VAR 0 2
51294: ARRAY
51295: NOT
51296: IFFALSE 51474
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51298: LD_ADDR_EXP 160
51302: PUSH
51303: LD_EXP 160
51307: PPUSH
51308: LD_VAR 0 2
51312: PPUSH
51313: LD_INT 0
51315: PPUSH
51316: CALL_OW 1
51320: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51321: LD_ADDR_VAR 0 4
51325: PUSH
51326: LD_EXP 117
51330: PUSH
51331: LD_VAR 0 2
51335: ARRAY
51336: PPUSH
51337: LD_INT 2
51339: PUSH
51340: LD_INT 25
51342: PUSH
51343: LD_INT 5
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 25
51352: PUSH
51353: LD_INT 8
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: LD_INT 25
51362: PUSH
51363: LD_INT 9
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PUSH
51370: EMPTY
51371: LIST
51372: LIST
51373: LIST
51374: LIST
51375: PPUSH
51376: CALL_OW 72
51380: ST_TO_ADDR
// if not tmp then
51381: LD_VAR 0 4
51385: NOT
51386: IFFALSE 51390
// continue ;
51388: GO 51186
// for j in tmp do
51390: LD_ADDR_VAR 0 3
51394: PUSH
51395: LD_VAR 0 4
51399: PUSH
51400: FOR_IN
51401: IFFALSE 51472
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51403: LD_VAR 0 3
51407: PPUSH
51408: CALL_OW 310
51412: PPUSH
51413: CALL_OW 266
51417: PUSH
51418: LD_INT 5
51420: EQUAL
51421: PUSH
51422: LD_VAR 0 3
51426: PPUSH
51427: CALL_OW 257
51431: PUSH
51432: LD_INT 1
51434: EQUAL
51435: AND
51436: PUSH
51437: LD_VAR 0 3
51441: PPUSH
51442: CALL_OW 459
51446: NOT
51447: AND
51448: PUSH
51449: LD_VAR 0 7
51453: AND
51454: IFFALSE 51470
// ComChangeProfession ( j , class ) ;
51456: LD_VAR 0 3
51460: PPUSH
51461: LD_VAR 0 7
51465: PPUSH
51466: CALL_OW 123
51470: GO 51400
51472: POP
51473: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51474: LD_EXP 140
51478: PUSH
51479: LD_VAR 0 2
51483: ARRAY
51484: PUSH
51485: LD_EXP 160
51489: PUSH
51490: LD_VAR 0 2
51494: ARRAY
51495: NOT
51496: AND
51497: PUSH
51498: LD_EXP 139
51502: PUSH
51503: LD_VAR 0 2
51507: ARRAY
51508: NOT
51509: AND
51510: PUSH
51511: LD_EXP 117
51515: PUSH
51516: LD_VAR 0 2
51520: ARRAY
51521: PPUSH
51522: LD_INT 50
51524: PUSH
51525: EMPTY
51526: LIST
51527: PUSH
51528: LD_INT 2
51530: PUSH
51531: LD_INT 30
51533: PUSH
51534: LD_INT 32
51536: PUSH
51537: EMPTY
51538: LIST
51539: LIST
51540: PUSH
51541: LD_INT 30
51543: PUSH
51544: LD_INT 33
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PUSH
51551: LD_INT 30
51553: PUSH
51554: LD_INT 4
51556: PUSH
51557: EMPTY
51558: LIST
51559: LIST
51560: PUSH
51561: LD_INT 30
51563: PUSH
51564: LD_INT 5
51566: PUSH
51567: EMPTY
51568: LIST
51569: LIST
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: LIST
51575: LIST
51576: LIST
51577: PUSH
51578: EMPTY
51579: LIST
51580: LIST
51581: PPUSH
51582: CALL_OW 72
51586: PUSH
51587: LD_INT 4
51589: LESS
51590: PUSH
51591: LD_EXP 117
51595: PUSH
51596: LD_VAR 0 2
51600: ARRAY
51601: PPUSH
51602: LD_INT 3
51604: PUSH
51605: LD_INT 24
51607: PUSH
51608: LD_INT 1000
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: PUSH
51619: LD_INT 2
51621: PUSH
51622: LD_INT 30
51624: PUSH
51625: LD_INT 0
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: PUSH
51632: LD_INT 30
51634: PUSH
51635: LD_INT 1
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: PUSH
51642: EMPTY
51643: LIST
51644: LIST
51645: LIST
51646: PUSH
51647: EMPTY
51648: LIST
51649: LIST
51650: PPUSH
51651: CALL_OW 72
51655: OR
51656: AND
51657: IFFALSE 51908
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51659: LD_ADDR_EXP 160
51663: PUSH
51664: LD_EXP 160
51668: PPUSH
51669: LD_VAR 0 2
51673: PPUSH
51674: LD_INT 1
51676: PPUSH
51677: CALL_OW 1
51681: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51682: LD_ADDR_VAR 0 4
51686: PUSH
51687: LD_EXP 117
51691: PUSH
51692: LD_VAR 0 2
51696: ARRAY
51697: PPUSH
51698: LD_INT 2
51700: PUSH
51701: LD_INT 25
51703: PUSH
51704: LD_INT 1
51706: PUSH
51707: EMPTY
51708: LIST
51709: LIST
51710: PUSH
51711: LD_INT 25
51713: PUSH
51714: LD_INT 5
51716: PUSH
51717: EMPTY
51718: LIST
51719: LIST
51720: PUSH
51721: LD_INT 25
51723: PUSH
51724: LD_INT 8
51726: PUSH
51727: EMPTY
51728: LIST
51729: LIST
51730: PUSH
51731: LD_INT 25
51733: PUSH
51734: LD_INT 9
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: LIST
51745: LIST
51746: LIST
51747: PPUSH
51748: CALL_OW 72
51752: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51753: LD_ADDR_VAR 0 4
51757: PUSH
51758: LD_VAR 0 4
51762: PUSH
51763: LD_VAR 0 4
51767: PPUSH
51768: LD_INT 18
51770: PPUSH
51771: CALL 100171 0 2
51775: DIFF
51776: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51777: LD_VAR 0 4
51781: NOT
51782: PUSH
51783: LD_EXP 117
51787: PUSH
51788: LD_VAR 0 2
51792: ARRAY
51793: PPUSH
51794: LD_INT 2
51796: PUSH
51797: LD_INT 30
51799: PUSH
51800: LD_INT 4
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PUSH
51807: LD_INT 30
51809: PUSH
51810: LD_INT 5
51812: PUSH
51813: EMPTY
51814: LIST
51815: LIST
51816: PUSH
51817: EMPTY
51818: LIST
51819: LIST
51820: LIST
51821: PPUSH
51822: CALL_OW 72
51826: NOT
51827: AND
51828: IFFALSE 51890
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51830: LD_ADDR_VAR 0 4
51834: PUSH
51835: LD_EXP 117
51839: PUSH
51840: LD_VAR 0 2
51844: ARRAY
51845: PPUSH
51846: LD_INT 2
51848: PUSH
51849: LD_INT 25
51851: PUSH
51852: LD_INT 2
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: PUSH
51859: LD_INT 25
51861: PUSH
51862: LD_INT 3
51864: PUSH
51865: EMPTY
51866: LIST
51867: LIST
51868: PUSH
51869: LD_INT 25
51871: PUSH
51872: LD_INT 4
51874: PUSH
51875: EMPTY
51876: LIST
51877: LIST
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: LIST
51883: LIST
51884: PPUSH
51885: CALL_OW 72
51889: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51890: LD_VAR 0 2
51894: PPUSH
51895: LD_VAR 0 4
51899: PPUSH
51900: CALL 129738 0 2
// exit ;
51904: POP
51905: POP
51906: GO 52028
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51908: LD_EXP 140
51912: PUSH
51913: LD_VAR 0 2
51917: ARRAY
51918: PUSH
51919: LD_EXP 160
51923: PUSH
51924: LD_VAR 0 2
51928: ARRAY
51929: NOT
51930: AND
51931: PUSH
51932: LD_EXP 139
51936: PUSH
51937: LD_VAR 0 2
51941: ARRAY
51942: AND
51943: IFFALSE 52024
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51945: LD_ADDR_EXP 160
51949: PUSH
51950: LD_EXP 160
51954: PPUSH
51955: LD_VAR 0 2
51959: PPUSH
51960: LD_INT 1
51962: PPUSH
51963: CALL_OW 1
51967: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51968: LD_ADDR_VAR 0 4
51972: PUSH
51973: LD_EXP 139
51977: PUSH
51978: LD_VAR 0 2
51982: ARRAY
51983: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51984: LD_ADDR_EXP 139
51988: PUSH
51989: LD_EXP 139
51993: PPUSH
51994: LD_VAR 0 2
51998: PPUSH
51999: EMPTY
52000: PPUSH
52001: CALL_OW 1
52005: ST_TO_ADDR
// Defend ( i , tmp ) ;
52006: LD_VAR 0 2
52010: PPUSH
52011: LD_VAR 0 4
52015: PPUSH
52016: CALL 130334 0 2
// exit ;
52020: POP
52021: POP
52022: GO 52028
// end ; end ;
52024: GO 51186
52026: POP
52027: POP
// end ;
52028: LD_VAR 0 1
52032: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
52033: LD_INT 0
52035: PPUSH
52036: PPUSH
52037: PPUSH
52038: PPUSH
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
52044: PPUSH
52045: PPUSH
// if not mc_bases then
52046: LD_EXP 117
52050: NOT
52051: IFFALSE 52055
// exit ;
52053: GO 53142
// for i = 1 to mc_bases do
52055: LD_ADDR_VAR 0 2
52059: PUSH
52060: DOUBLE
52061: LD_INT 1
52063: DEC
52064: ST_TO_ADDR
52065: LD_EXP 117
52069: PUSH
52070: FOR_TO
52071: IFFALSE 53140
// begin tmp := mc_lab [ i ] ;
52073: LD_ADDR_VAR 0 6
52077: PUSH
52078: LD_EXP 150
52082: PUSH
52083: LD_VAR 0 2
52087: ARRAY
52088: ST_TO_ADDR
// if not tmp then
52089: LD_VAR 0 6
52093: NOT
52094: IFFALSE 52098
// continue ;
52096: GO 52070
// idle_lab := 0 ;
52098: LD_ADDR_VAR 0 11
52102: PUSH
52103: LD_INT 0
52105: ST_TO_ADDR
// for j in tmp do
52106: LD_ADDR_VAR 0 3
52110: PUSH
52111: LD_VAR 0 6
52115: PUSH
52116: FOR_IN
52117: IFFALSE 53136
// begin researching := false ;
52119: LD_ADDR_VAR 0 10
52123: PUSH
52124: LD_INT 0
52126: ST_TO_ADDR
// side := GetSide ( j ) ;
52127: LD_ADDR_VAR 0 4
52131: PUSH
52132: LD_VAR 0 3
52136: PPUSH
52137: CALL_OW 255
52141: ST_TO_ADDR
// if not mc_tech [ side ] then
52142: LD_EXP 144
52146: PUSH
52147: LD_VAR 0 4
52151: ARRAY
52152: NOT
52153: IFFALSE 52157
// continue ;
52155: GO 52116
// if BuildingStatus ( j ) = bs_idle then
52157: LD_VAR 0 3
52161: PPUSH
52162: CALL_OW 461
52166: PUSH
52167: LD_INT 2
52169: EQUAL
52170: IFFALSE 52358
// begin if idle_lab and UnitsInside ( j ) < 6 then
52172: LD_VAR 0 11
52176: PUSH
52177: LD_VAR 0 3
52181: PPUSH
52182: CALL_OW 313
52186: PUSH
52187: LD_INT 6
52189: LESS
52190: AND
52191: IFFALSE 52262
// begin tmp2 := UnitsInside ( idle_lab ) ;
52193: LD_ADDR_VAR 0 9
52197: PUSH
52198: LD_VAR 0 11
52202: PPUSH
52203: CALL_OW 313
52207: ST_TO_ADDR
// if tmp2 then
52208: LD_VAR 0 9
52212: IFFALSE 52254
// for x in tmp2 do
52214: LD_ADDR_VAR 0 7
52218: PUSH
52219: LD_VAR 0 9
52223: PUSH
52224: FOR_IN
52225: IFFALSE 52252
// begin ComExitBuilding ( x ) ;
52227: LD_VAR 0 7
52231: PPUSH
52232: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52236: LD_VAR 0 7
52240: PPUSH
52241: LD_VAR 0 3
52245: PPUSH
52246: CALL_OW 180
// end ;
52250: GO 52224
52252: POP
52253: POP
// idle_lab := 0 ;
52254: LD_ADDR_VAR 0 11
52258: PUSH
52259: LD_INT 0
52261: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52262: LD_ADDR_VAR 0 5
52266: PUSH
52267: LD_EXP 144
52271: PUSH
52272: LD_VAR 0 4
52276: ARRAY
52277: PUSH
52278: FOR_IN
52279: IFFALSE 52339
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52281: LD_VAR 0 3
52285: PPUSH
52286: LD_VAR 0 5
52290: PPUSH
52291: CALL_OW 430
52295: PUSH
52296: LD_VAR 0 4
52300: PPUSH
52301: LD_VAR 0 5
52305: PPUSH
52306: CALL 66772 0 2
52310: AND
52311: IFFALSE 52337
// begin researching := true ;
52313: LD_ADDR_VAR 0 10
52317: PUSH
52318: LD_INT 1
52320: ST_TO_ADDR
// ComResearch ( j , t ) ;
52321: LD_VAR 0 3
52325: PPUSH
52326: LD_VAR 0 5
52330: PPUSH
52331: CALL_OW 124
// break ;
52335: GO 52339
// end ;
52337: GO 52278
52339: POP
52340: POP
// if not researching then
52341: LD_VAR 0 10
52345: NOT
52346: IFFALSE 52358
// idle_lab := j ;
52348: LD_ADDR_VAR 0 11
52352: PUSH
52353: LD_VAR 0 3
52357: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52358: LD_VAR 0 3
52362: PPUSH
52363: CALL_OW 461
52367: PUSH
52368: LD_INT 10
52370: EQUAL
52371: IFFALSE 52959
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52373: LD_EXP 146
52377: PUSH
52378: LD_VAR 0 2
52382: ARRAY
52383: NOT
52384: PUSH
52385: LD_EXP 147
52389: PUSH
52390: LD_VAR 0 2
52394: ARRAY
52395: NOT
52396: AND
52397: PUSH
52398: LD_EXP 144
52402: PUSH
52403: LD_VAR 0 4
52407: ARRAY
52408: PUSH
52409: LD_INT 1
52411: GREATER
52412: AND
52413: IFFALSE 52544
// begin ComCancel ( j ) ;
52415: LD_VAR 0 3
52419: PPUSH
52420: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52424: LD_ADDR_EXP 144
52428: PUSH
52429: LD_EXP 144
52433: PPUSH
52434: LD_VAR 0 4
52438: PPUSH
52439: LD_EXP 144
52443: PUSH
52444: LD_VAR 0 4
52448: ARRAY
52449: PPUSH
52450: LD_EXP 144
52454: PUSH
52455: LD_VAR 0 4
52459: ARRAY
52460: PUSH
52461: LD_INT 1
52463: MINUS
52464: PPUSH
52465: LD_EXP 144
52469: PUSH
52470: LD_VAR 0 4
52474: ARRAY
52475: PPUSH
52476: LD_INT 0
52478: PPUSH
52479: CALL 70320 0 4
52483: PPUSH
52484: CALL_OW 1
52488: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52489: LD_ADDR_EXP 144
52493: PUSH
52494: LD_EXP 144
52498: PPUSH
52499: LD_VAR 0 4
52503: PPUSH
52504: LD_EXP 144
52508: PUSH
52509: LD_VAR 0 4
52513: ARRAY
52514: PPUSH
52515: LD_EXP 144
52519: PUSH
52520: LD_VAR 0 4
52524: ARRAY
52525: PPUSH
52526: LD_INT 1
52528: PPUSH
52529: LD_INT 0
52531: PPUSH
52532: CALL 70320 0 4
52536: PPUSH
52537: CALL_OW 1
52541: ST_TO_ADDR
// continue ;
52542: GO 52116
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52544: LD_EXP 146
52548: PUSH
52549: LD_VAR 0 2
52553: ARRAY
52554: PUSH
52555: LD_EXP 147
52559: PUSH
52560: LD_VAR 0 2
52564: ARRAY
52565: NOT
52566: AND
52567: IFFALSE 52694
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52569: LD_ADDR_EXP 147
52573: PUSH
52574: LD_EXP 147
52578: PPUSH
52579: LD_VAR 0 2
52583: PUSH
52584: LD_EXP 147
52588: PUSH
52589: LD_VAR 0 2
52593: ARRAY
52594: PUSH
52595: LD_INT 1
52597: PLUS
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: PPUSH
52603: LD_EXP 146
52607: PUSH
52608: LD_VAR 0 2
52612: ARRAY
52613: PUSH
52614: LD_INT 1
52616: ARRAY
52617: PPUSH
52618: CALL 70902 0 3
52622: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52623: LD_EXP 146
52627: PUSH
52628: LD_VAR 0 2
52632: ARRAY
52633: PUSH
52634: LD_INT 1
52636: ARRAY
52637: PPUSH
52638: LD_INT 112
52640: PPUSH
52641: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52645: LD_ADDR_VAR 0 9
52649: PUSH
52650: LD_EXP 146
52654: PUSH
52655: LD_VAR 0 2
52659: ARRAY
52660: PPUSH
52661: LD_INT 1
52663: PPUSH
52664: CALL_OW 3
52668: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52669: LD_ADDR_EXP 146
52673: PUSH
52674: LD_EXP 146
52678: PPUSH
52679: LD_VAR 0 2
52683: PPUSH
52684: LD_VAR 0 9
52688: PPUSH
52689: CALL_OW 1
52693: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52694: LD_EXP 146
52698: PUSH
52699: LD_VAR 0 2
52703: ARRAY
52704: PUSH
52705: LD_EXP 147
52709: PUSH
52710: LD_VAR 0 2
52714: ARRAY
52715: AND
52716: PUSH
52717: LD_EXP 147
52721: PUSH
52722: LD_VAR 0 2
52726: ARRAY
52727: PUSH
52728: LD_INT 1
52730: ARRAY
52731: PPUSH
52732: CALL_OW 310
52736: NOT
52737: AND
52738: PUSH
52739: LD_VAR 0 3
52743: PPUSH
52744: CALL_OW 313
52748: PUSH
52749: LD_INT 6
52751: EQUAL
52752: AND
52753: IFFALSE 52809
// begin tmp2 := UnitsInside ( j ) ;
52755: LD_ADDR_VAR 0 9
52759: PUSH
52760: LD_VAR 0 3
52764: PPUSH
52765: CALL_OW 313
52769: ST_TO_ADDR
// if tmp2 = 6 then
52770: LD_VAR 0 9
52774: PUSH
52775: LD_INT 6
52777: EQUAL
52778: IFFALSE 52809
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52780: LD_VAR 0 9
52784: PUSH
52785: LD_INT 1
52787: ARRAY
52788: PPUSH
52789: LD_INT 112
52791: PPUSH
52792: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52796: LD_VAR 0 9
52800: PUSH
52801: LD_INT 1
52803: ARRAY
52804: PPUSH
52805: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52809: LD_EXP 147
52813: PUSH
52814: LD_VAR 0 2
52818: ARRAY
52819: PUSH
52820: LD_EXP 147
52824: PUSH
52825: LD_VAR 0 2
52829: ARRAY
52830: PUSH
52831: LD_INT 1
52833: ARRAY
52834: PPUSH
52835: CALL_OW 314
52839: NOT
52840: AND
52841: PUSH
52842: LD_EXP 147
52846: PUSH
52847: LD_VAR 0 2
52851: ARRAY
52852: PUSH
52853: LD_INT 1
52855: ARRAY
52856: PPUSH
52857: CALL_OW 310
52861: NOT
52862: AND
52863: IFFALSE 52889
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52865: LD_EXP 147
52869: PUSH
52870: LD_VAR 0 2
52874: ARRAY
52875: PUSH
52876: LD_INT 1
52878: ARRAY
52879: PPUSH
52880: LD_VAR 0 3
52884: PPUSH
52885: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52889: LD_EXP 147
52893: PUSH
52894: LD_VAR 0 2
52898: ARRAY
52899: PUSH
52900: LD_INT 1
52902: ARRAY
52903: PPUSH
52904: CALL_OW 310
52908: PUSH
52909: LD_EXP 147
52913: PUSH
52914: LD_VAR 0 2
52918: ARRAY
52919: PUSH
52920: LD_INT 1
52922: ARRAY
52923: PPUSH
52924: CALL_OW 310
52928: PPUSH
52929: CALL_OW 461
52933: PUSH
52934: LD_INT 3
52936: NONEQUAL
52937: AND
52938: IFFALSE 52959
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52940: LD_EXP 147
52944: PUSH
52945: LD_VAR 0 2
52949: ARRAY
52950: PUSH
52951: LD_INT 1
52953: ARRAY
52954: PPUSH
52955: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52959: LD_VAR 0 3
52963: PPUSH
52964: CALL_OW 461
52968: PUSH
52969: LD_INT 6
52971: EQUAL
52972: PUSH
52973: LD_VAR 0 6
52977: PUSH
52978: LD_INT 1
52980: GREATER
52981: AND
52982: IFFALSE 53134
// begin sci := [ ] ;
52984: LD_ADDR_VAR 0 8
52988: PUSH
52989: EMPTY
52990: ST_TO_ADDR
// for x in ( tmp diff j ) do
52991: LD_ADDR_VAR 0 7
52995: PUSH
52996: LD_VAR 0 6
53000: PUSH
53001: LD_VAR 0 3
53005: DIFF
53006: PUSH
53007: FOR_IN
53008: IFFALSE 53060
// begin if sci = 6 then
53010: LD_VAR 0 8
53014: PUSH
53015: LD_INT 6
53017: EQUAL
53018: IFFALSE 53022
// break ;
53020: GO 53060
// if BuildingStatus ( x ) = bs_idle then
53022: LD_VAR 0 7
53026: PPUSH
53027: CALL_OW 461
53031: PUSH
53032: LD_INT 2
53034: EQUAL
53035: IFFALSE 53058
// sci := sci ^ UnitsInside ( x ) ;
53037: LD_ADDR_VAR 0 8
53041: PUSH
53042: LD_VAR 0 8
53046: PUSH
53047: LD_VAR 0 7
53051: PPUSH
53052: CALL_OW 313
53056: ADD
53057: ST_TO_ADDR
// end ;
53058: GO 53007
53060: POP
53061: POP
// if not sci then
53062: LD_VAR 0 8
53066: NOT
53067: IFFALSE 53071
// continue ;
53069: GO 52116
// for x in sci do
53071: LD_ADDR_VAR 0 7
53075: PUSH
53076: LD_VAR 0 8
53080: PUSH
53081: FOR_IN
53082: IFFALSE 53132
// if IsInUnit ( x ) and not HasTask ( x ) then
53084: LD_VAR 0 7
53088: PPUSH
53089: CALL_OW 310
53093: PUSH
53094: LD_VAR 0 7
53098: PPUSH
53099: CALL_OW 314
53103: NOT
53104: AND
53105: IFFALSE 53130
// begin ComExitBuilding ( x ) ;
53107: LD_VAR 0 7
53111: PPUSH
53112: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53116: LD_VAR 0 7
53120: PPUSH
53121: LD_VAR 0 3
53125: PPUSH
53126: CALL_OW 180
// end ;
53130: GO 53081
53132: POP
53133: POP
// end ; end ;
53134: GO 52116
53136: POP
53137: POP
// end ;
53138: GO 52070
53140: POP
53141: POP
// end ;
53142: LD_VAR 0 1
53146: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53147: LD_INT 0
53149: PPUSH
53150: PPUSH
// if not mc_bases then
53151: LD_EXP 117
53155: NOT
53156: IFFALSE 53160
// exit ;
53158: GO 53241
// for i = 1 to mc_bases do
53160: LD_ADDR_VAR 0 2
53164: PUSH
53165: DOUBLE
53166: LD_INT 1
53168: DEC
53169: ST_TO_ADDR
53170: LD_EXP 117
53174: PUSH
53175: FOR_TO
53176: IFFALSE 53239
// if mc_mines [ i ] and mc_miners [ i ] then
53178: LD_EXP 130
53182: PUSH
53183: LD_VAR 0 2
53187: ARRAY
53188: PUSH
53189: LD_EXP 131
53193: PUSH
53194: LD_VAR 0 2
53198: ARRAY
53199: AND
53200: IFFALSE 53237
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53202: LD_EXP 131
53206: PUSH
53207: LD_VAR 0 2
53211: ARRAY
53212: PUSH
53213: LD_INT 1
53215: ARRAY
53216: PPUSH
53217: CALL_OW 255
53221: PPUSH
53222: LD_EXP 130
53226: PUSH
53227: LD_VAR 0 2
53231: ARRAY
53232: PPUSH
53233: CALL 67855 0 2
53237: GO 53175
53239: POP
53240: POP
// end ;
53241: LD_VAR 0 1
53245: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53246: LD_INT 0
53248: PPUSH
53249: PPUSH
53250: PPUSH
53251: PPUSH
53252: PPUSH
53253: PPUSH
53254: PPUSH
53255: PPUSH
// if not mc_bases or not mc_parking then
53256: LD_EXP 117
53260: NOT
53261: PUSH
53262: LD_EXP 141
53266: NOT
53267: OR
53268: IFFALSE 53272
// exit ;
53270: GO 53982
// for i = 1 to mc_bases do
53272: LD_ADDR_VAR 0 2
53276: PUSH
53277: DOUBLE
53278: LD_INT 1
53280: DEC
53281: ST_TO_ADDR
53282: LD_EXP 117
53286: PUSH
53287: FOR_TO
53288: IFFALSE 53980
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53290: LD_EXP 117
53294: PUSH
53295: LD_VAR 0 2
53299: ARRAY
53300: NOT
53301: PUSH
53302: LD_EXP 141
53306: PUSH
53307: LD_VAR 0 2
53311: ARRAY
53312: NOT
53313: OR
53314: IFFALSE 53318
// continue ;
53316: GO 53287
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53318: LD_ADDR_VAR 0 5
53322: PUSH
53323: LD_EXP 117
53327: PUSH
53328: LD_VAR 0 2
53332: ARRAY
53333: PUSH
53334: LD_INT 1
53336: ARRAY
53337: PPUSH
53338: CALL_OW 255
53342: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53343: LD_ADDR_VAR 0 6
53347: PUSH
53348: LD_EXP 117
53352: PUSH
53353: LD_VAR 0 2
53357: ARRAY
53358: PPUSH
53359: LD_INT 30
53361: PUSH
53362: LD_INT 3
53364: PUSH
53365: EMPTY
53366: LIST
53367: LIST
53368: PPUSH
53369: CALL_OW 72
53373: ST_TO_ADDR
// if not fac then
53374: LD_VAR 0 6
53378: NOT
53379: IFFALSE 53430
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53381: LD_ADDR_VAR 0 6
53385: PUSH
53386: LD_EXP 117
53390: PUSH
53391: LD_VAR 0 2
53395: ARRAY
53396: PPUSH
53397: LD_INT 2
53399: PUSH
53400: LD_INT 30
53402: PUSH
53403: LD_INT 0
53405: PUSH
53406: EMPTY
53407: LIST
53408: LIST
53409: PUSH
53410: LD_INT 30
53412: PUSH
53413: LD_INT 1
53415: PUSH
53416: EMPTY
53417: LIST
53418: LIST
53419: PUSH
53420: EMPTY
53421: LIST
53422: LIST
53423: LIST
53424: PPUSH
53425: CALL_OW 72
53429: ST_TO_ADDR
// if not fac then
53430: LD_VAR 0 6
53434: NOT
53435: IFFALSE 53439
// continue ;
53437: GO 53287
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53439: LD_ADDR_VAR 0 7
53443: PUSH
53444: LD_EXP 141
53448: PUSH
53449: LD_VAR 0 2
53453: ARRAY
53454: PPUSH
53455: LD_INT 22
53457: PUSH
53458: LD_VAR 0 5
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: PUSH
53467: LD_INT 21
53469: PUSH
53470: LD_INT 2
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: PUSH
53477: LD_INT 3
53479: PUSH
53480: LD_INT 24
53482: PUSH
53483: LD_INT 1000
53485: PUSH
53486: EMPTY
53487: LIST
53488: LIST
53489: PUSH
53490: EMPTY
53491: LIST
53492: LIST
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: LIST
53498: PPUSH
53499: CALL_OW 70
53503: ST_TO_ADDR
// for j in fac do
53504: LD_ADDR_VAR 0 3
53508: PUSH
53509: LD_VAR 0 6
53513: PUSH
53514: FOR_IN
53515: IFFALSE 53596
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53517: LD_ADDR_VAR 0 7
53521: PUSH
53522: LD_VAR 0 7
53526: PUSH
53527: LD_INT 22
53529: PUSH
53530: LD_VAR 0 5
53534: PUSH
53535: EMPTY
53536: LIST
53537: LIST
53538: PUSH
53539: LD_INT 91
53541: PUSH
53542: LD_VAR 0 3
53546: PUSH
53547: LD_INT 15
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: LIST
53554: PUSH
53555: LD_INT 21
53557: PUSH
53558: LD_INT 2
53560: PUSH
53561: EMPTY
53562: LIST
53563: LIST
53564: PUSH
53565: LD_INT 3
53567: PUSH
53568: LD_INT 24
53570: PUSH
53571: LD_INT 1000
53573: PUSH
53574: EMPTY
53575: LIST
53576: LIST
53577: PUSH
53578: EMPTY
53579: LIST
53580: LIST
53581: PUSH
53582: EMPTY
53583: LIST
53584: LIST
53585: LIST
53586: LIST
53587: PPUSH
53588: CALL_OW 69
53592: UNION
53593: ST_TO_ADDR
53594: GO 53514
53596: POP
53597: POP
// if not vehs then
53598: LD_VAR 0 7
53602: NOT
53603: IFFALSE 53629
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53605: LD_ADDR_EXP 129
53609: PUSH
53610: LD_EXP 129
53614: PPUSH
53615: LD_VAR 0 2
53619: PPUSH
53620: EMPTY
53621: PPUSH
53622: CALL_OW 1
53626: ST_TO_ADDR
// continue ;
53627: GO 53287
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53629: LD_ADDR_VAR 0 8
53633: PUSH
53634: LD_EXP 117
53638: PUSH
53639: LD_VAR 0 2
53643: ARRAY
53644: PPUSH
53645: LD_INT 30
53647: PUSH
53648: LD_INT 3
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: PPUSH
53655: CALL_OW 72
53659: ST_TO_ADDR
// if tmp then
53660: LD_VAR 0 8
53664: IFFALSE 53767
// begin for j in tmp do
53666: LD_ADDR_VAR 0 3
53670: PUSH
53671: LD_VAR 0 8
53675: PUSH
53676: FOR_IN
53677: IFFALSE 53765
// for k in UnitsInside ( j ) do
53679: LD_ADDR_VAR 0 4
53683: PUSH
53684: LD_VAR 0 3
53688: PPUSH
53689: CALL_OW 313
53693: PUSH
53694: FOR_IN
53695: IFFALSE 53761
// if k then
53697: LD_VAR 0 4
53701: IFFALSE 53759
// if not k in mc_repair_vehicle [ i ] then
53703: LD_VAR 0 4
53707: PUSH
53708: LD_EXP 129
53712: PUSH
53713: LD_VAR 0 2
53717: ARRAY
53718: IN
53719: NOT
53720: IFFALSE 53759
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53722: LD_ADDR_EXP 129
53726: PUSH
53727: LD_EXP 129
53731: PPUSH
53732: LD_VAR 0 2
53736: PPUSH
53737: LD_EXP 129
53741: PUSH
53742: LD_VAR 0 2
53746: ARRAY
53747: PUSH
53748: LD_VAR 0 4
53752: UNION
53753: PPUSH
53754: CALL_OW 1
53758: ST_TO_ADDR
53759: GO 53694
53761: POP
53762: POP
53763: GO 53676
53765: POP
53766: POP
// end ; if not mc_repair_vehicle [ i ] then
53767: LD_EXP 129
53771: PUSH
53772: LD_VAR 0 2
53776: ARRAY
53777: NOT
53778: IFFALSE 53782
// continue ;
53780: GO 53287
// for j in mc_repair_vehicle [ i ] do
53782: LD_ADDR_VAR 0 3
53786: PUSH
53787: LD_EXP 129
53791: PUSH
53792: LD_VAR 0 2
53796: ARRAY
53797: PUSH
53798: FOR_IN
53799: IFFALSE 53976
// begin if GetClass ( j ) <> 3 then
53801: LD_VAR 0 3
53805: PPUSH
53806: CALL_OW 257
53810: PUSH
53811: LD_INT 3
53813: NONEQUAL
53814: IFFALSE 53855
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53816: LD_ADDR_EXP 129
53820: PUSH
53821: LD_EXP 129
53825: PPUSH
53826: LD_VAR 0 2
53830: PPUSH
53831: LD_EXP 129
53835: PUSH
53836: LD_VAR 0 2
53840: ARRAY
53841: PUSH
53842: LD_VAR 0 3
53846: DIFF
53847: PPUSH
53848: CALL_OW 1
53852: ST_TO_ADDR
// continue ;
53853: GO 53798
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53855: LD_VAR 0 3
53859: PPUSH
53860: CALL_OW 311
53864: NOT
53865: PUSH
53866: LD_VAR 0 3
53870: PUSH
53871: LD_EXP 120
53875: PUSH
53876: LD_VAR 0 2
53880: ARRAY
53881: PUSH
53882: LD_INT 1
53884: ARRAY
53885: IN
53886: NOT
53887: AND
53888: PUSH
53889: LD_VAR 0 3
53893: PUSH
53894: LD_EXP 120
53898: PUSH
53899: LD_VAR 0 2
53903: ARRAY
53904: PUSH
53905: LD_INT 2
53907: ARRAY
53908: IN
53909: NOT
53910: AND
53911: IFFALSE 53974
// begin if IsInUnit ( j ) then
53913: LD_VAR 0 3
53917: PPUSH
53918: CALL_OW 310
53922: IFFALSE 53935
// ComExitBuilding ( j ) else
53924: LD_VAR 0 3
53928: PPUSH
53929: CALL_OW 122
53933: GO 53974
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53935: LD_VAR 0 3
53939: PPUSH
53940: LD_VAR 0 7
53944: PUSH
53945: LD_INT 1
53947: ARRAY
53948: PPUSH
53949: CALL 104654 0 2
53953: NOT
53954: IFFALSE 53974
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53956: LD_VAR 0 3
53960: PPUSH
53961: LD_VAR 0 7
53965: PUSH
53966: LD_INT 1
53968: ARRAY
53969: PPUSH
53970: CALL_OW 129
// end ; end ;
53974: GO 53798
53976: POP
53977: POP
// end ;
53978: GO 53287
53980: POP
53981: POP
// end ;
53982: LD_VAR 0 1
53986: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53987: LD_INT 0
53989: PPUSH
53990: PPUSH
53991: PPUSH
53992: PPUSH
53993: PPUSH
53994: PPUSH
53995: PPUSH
53996: PPUSH
53997: PPUSH
53998: PPUSH
53999: PPUSH
// if not mc_bases then
54000: LD_EXP 117
54004: NOT
54005: IFFALSE 54009
// exit ;
54007: GO 54811
// for i = 1 to mc_bases do
54009: LD_ADDR_VAR 0 2
54013: PUSH
54014: DOUBLE
54015: LD_INT 1
54017: DEC
54018: ST_TO_ADDR
54019: LD_EXP 117
54023: PUSH
54024: FOR_TO
54025: IFFALSE 54809
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
54027: LD_EXP 145
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: NOT
54038: PUSH
54039: LD_EXP 120
54043: PUSH
54044: LD_VAR 0 2
54048: ARRAY
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: OR
54054: PUSH
54055: LD_EXP 120
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: PUSH
54066: LD_INT 2
54068: ARRAY
54069: OR
54070: PUSH
54071: LD_EXP 143
54075: PUSH
54076: LD_VAR 0 2
54080: ARRAY
54081: PPUSH
54082: LD_INT 1
54084: PPUSH
54085: CALL_OW 325
54089: NOT
54090: OR
54091: PUSH
54092: LD_EXP 140
54096: PUSH
54097: LD_VAR 0 2
54101: ARRAY
54102: OR
54103: IFFALSE 54107
// continue ;
54105: GO 54024
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54107: LD_ADDR_VAR 0 8
54111: PUSH
54112: LD_EXP 117
54116: PUSH
54117: LD_VAR 0 2
54121: ARRAY
54122: PPUSH
54123: LD_INT 25
54125: PUSH
54126: LD_INT 4
54128: PUSH
54129: EMPTY
54130: LIST
54131: LIST
54132: PUSH
54133: LD_INT 50
54135: PUSH
54136: EMPTY
54137: LIST
54138: PUSH
54139: LD_INT 3
54141: PUSH
54142: LD_INT 60
54144: PUSH
54145: EMPTY
54146: LIST
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: PPUSH
54157: CALL_OW 72
54161: PUSH
54162: LD_EXP 121
54166: PUSH
54167: LD_VAR 0 2
54171: ARRAY
54172: DIFF
54173: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54174: LD_ADDR_VAR 0 9
54178: PUSH
54179: LD_EXP 117
54183: PUSH
54184: LD_VAR 0 2
54188: ARRAY
54189: PPUSH
54190: LD_INT 2
54192: PUSH
54193: LD_INT 30
54195: PUSH
54196: LD_INT 0
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PUSH
54203: LD_INT 30
54205: PUSH
54206: LD_INT 1
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: LIST
54217: PPUSH
54218: CALL_OW 72
54222: ST_TO_ADDR
// if not tmp or not dep then
54223: LD_VAR 0 8
54227: NOT
54228: PUSH
54229: LD_VAR 0 9
54233: NOT
54234: OR
54235: IFFALSE 54239
// continue ;
54237: GO 54024
// side := GetSide ( tmp [ 1 ] ) ;
54239: LD_ADDR_VAR 0 11
54243: PUSH
54244: LD_VAR 0 8
54248: PUSH
54249: LD_INT 1
54251: ARRAY
54252: PPUSH
54253: CALL_OW 255
54257: ST_TO_ADDR
// dep := dep [ 1 ] ;
54258: LD_ADDR_VAR 0 9
54262: PUSH
54263: LD_VAR 0 9
54267: PUSH
54268: LD_INT 1
54270: ARRAY
54271: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54272: LD_ADDR_VAR 0 7
54276: PUSH
54277: LD_EXP 145
54281: PUSH
54282: LD_VAR 0 2
54286: ARRAY
54287: PPUSH
54288: LD_INT 22
54290: PUSH
54291: LD_INT 0
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PUSH
54298: LD_INT 25
54300: PUSH
54301: LD_INT 12
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: PPUSH
54312: CALL_OW 70
54316: PUSH
54317: LD_INT 22
54319: PUSH
54320: LD_INT 0
54322: PUSH
54323: EMPTY
54324: LIST
54325: LIST
54326: PUSH
54327: LD_INT 25
54329: PUSH
54330: LD_INT 12
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PUSH
54337: LD_INT 91
54339: PUSH
54340: LD_VAR 0 9
54344: PUSH
54345: LD_INT 20
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: LIST
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: LIST
54357: PPUSH
54358: CALL_OW 69
54362: UNION
54363: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54364: LD_ADDR_VAR 0 10
54368: PUSH
54369: LD_EXP 145
54373: PUSH
54374: LD_VAR 0 2
54378: ARRAY
54379: PPUSH
54380: LD_INT 81
54382: PUSH
54383: LD_VAR 0 11
54387: PUSH
54388: EMPTY
54389: LIST
54390: LIST
54391: PPUSH
54392: CALL_OW 70
54396: ST_TO_ADDR
// if not apes or danger_at_area then
54397: LD_VAR 0 7
54401: NOT
54402: PUSH
54403: LD_VAR 0 10
54407: OR
54408: IFFALSE 54458
// begin if mc_taming [ i ] then
54410: LD_EXP 148
54414: PUSH
54415: LD_VAR 0 2
54419: ARRAY
54420: IFFALSE 54456
// begin MC_Reset ( i , 121 ) ;
54422: LD_VAR 0 2
54426: PPUSH
54427: LD_INT 121
54429: PPUSH
54430: CALL 39444 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54434: LD_ADDR_EXP 148
54438: PUSH
54439: LD_EXP 148
54443: PPUSH
54444: LD_VAR 0 2
54448: PPUSH
54449: EMPTY
54450: PPUSH
54451: CALL_OW 1
54455: ST_TO_ADDR
// end ; continue ;
54456: GO 54024
// end ; for j in tmp do
54458: LD_ADDR_VAR 0 3
54462: PUSH
54463: LD_VAR 0 8
54467: PUSH
54468: FOR_IN
54469: IFFALSE 54805
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54471: LD_VAR 0 3
54475: PUSH
54476: LD_EXP 148
54480: PUSH
54481: LD_VAR 0 2
54485: ARRAY
54486: IN
54487: NOT
54488: PUSH
54489: LD_EXP 148
54493: PUSH
54494: LD_VAR 0 2
54498: ARRAY
54499: PUSH
54500: LD_INT 3
54502: LESS
54503: AND
54504: IFFALSE 54562
// begin SetTag ( j , 121 ) ;
54506: LD_VAR 0 3
54510: PPUSH
54511: LD_INT 121
54513: PPUSH
54514: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54518: LD_ADDR_EXP 148
54522: PUSH
54523: LD_EXP 148
54527: PPUSH
54528: LD_VAR 0 2
54532: PUSH
54533: LD_EXP 148
54537: PUSH
54538: LD_VAR 0 2
54542: ARRAY
54543: PUSH
54544: LD_INT 1
54546: PLUS
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: PPUSH
54552: LD_VAR 0 3
54556: PPUSH
54557: CALL 70902 0 3
54561: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54562: LD_VAR 0 3
54566: PUSH
54567: LD_EXP 148
54571: PUSH
54572: LD_VAR 0 2
54576: ARRAY
54577: IN
54578: IFFALSE 54803
// begin if GetClass ( j ) <> 4 then
54580: LD_VAR 0 3
54584: PPUSH
54585: CALL_OW 257
54589: PUSH
54590: LD_INT 4
54592: NONEQUAL
54593: IFFALSE 54646
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54595: LD_ADDR_EXP 148
54599: PUSH
54600: LD_EXP 148
54604: PPUSH
54605: LD_VAR 0 2
54609: PPUSH
54610: LD_EXP 148
54614: PUSH
54615: LD_VAR 0 2
54619: ARRAY
54620: PUSH
54621: LD_VAR 0 3
54625: DIFF
54626: PPUSH
54627: CALL_OW 1
54631: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54632: LD_VAR 0 3
54636: PPUSH
54637: LD_INT 0
54639: PPUSH
54640: CALL_OW 109
// continue ;
54644: GO 54468
// end ; if IsInUnit ( j ) then
54646: LD_VAR 0 3
54650: PPUSH
54651: CALL_OW 310
54655: IFFALSE 54666
// ComExitBuilding ( j ) ;
54657: LD_VAR 0 3
54661: PPUSH
54662: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54666: LD_ADDR_VAR 0 6
54670: PUSH
54671: LD_VAR 0 7
54675: PPUSH
54676: LD_VAR 0 3
54680: PPUSH
54681: CALL_OW 74
54685: ST_TO_ADDR
// if not ape then
54686: LD_VAR 0 6
54690: NOT
54691: IFFALSE 54695
// break ;
54693: GO 54805
// x := GetX ( ape ) ;
54695: LD_ADDR_VAR 0 4
54699: PUSH
54700: LD_VAR 0 6
54704: PPUSH
54705: CALL_OW 250
54709: ST_TO_ADDR
// y := GetY ( ape ) ;
54710: LD_ADDR_VAR 0 5
54714: PUSH
54715: LD_VAR 0 6
54719: PPUSH
54720: CALL_OW 251
54724: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54725: LD_VAR 0 4
54729: PPUSH
54730: LD_VAR 0 5
54734: PPUSH
54735: CALL_OW 488
54739: NOT
54740: PUSH
54741: LD_VAR 0 11
54745: PPUSH
54746: LD_VAR 0 4
54750: PPUSH
54751: LD_VAR 0 5
54755: PPUSH
54756: LD_INT 20
54758: PPUSH
54759: CALL 71798 0 4
54763: PUSH
54764: LD_INT 4
54766: ARRAY
54767: OR
54768: IFFALSE 54772
// break ;
54770: GO 54805
// if not HasTask ( j ) then
54772: LD_VAR 0 3
54776: PPUSH
54777: CALL_OW 314
54781: NOT
54782: IFFALSE 54803
// ComTameXY ( j , x , y ) ;
54784: LD_VAR 0 3
54788: PPUSH
54789: LD_VAR 0 4
54793: PPUSH
54794: LD_VAR 0 5
54798: PPUSH
54799: CALL_OW 131
// end ; end ;
54803: GO 54468
54805: POP
54806: POP
// end ;
54807: GO 54024
54809: POP
54810: POP
// end ;
54811: LD_VAR 0 1
54815: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54816: LD_INT 0
54818: PPUSH
54819: PPUSH
54820: PPUSH
54821: PPUSH
54822: PPUSH
54823: PPUSH
54824: PPUSH
54825: PPUSH
// if not mc_bases then
54826: LD_EXP 117
54830: NOT
54831: IFFALSE 54835
// exit ;
54833: GO 55461
// for i = 1 to mc_bases do
54835: LD_ADDR_VAR 0 2
54839: PUSH
54840: DOUBLE
54841: LD_INT 1
54843: DEC
54844: ST_TO_ADDR
54845: LD_EXP 117
54849: PUSH
54850: FOR_TO
54851: IFFALSE 55459
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54853: LD_EXP 146
54857: PUSH
54858: LD_VAR 0 2
54862: ARRAY
54863: NOT
54864: PUSH
54865: LD_EXP 146
54869: PUSH
54870: LD_VAR 0 2
54874: ARRAY
54875: PPUSH
54876: LD_INT 25
54878: PUSH
54879: LD_INT 12
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PPUSH
54886: CALL_OW 72
54890: NOT
54891: OR
54892: IFFALSE 54896
// continue ;
54894: GO 54850
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54896: LD_ADDR_VAR 0 5
54900: PUSH
54901: LD_EXP 146
54905: PUSH
54906: LD_VAR 0 2
54910: ARRAY
54911: PUSH
54912: LD_INT 1
54914: ARRAY
54915: PPUSH
54916: CALL_OW 255
54920: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54921: LD_VAR 0 5
54925: PPUSH
54926: LD_INT 2
54928: PPUSH
54929: CALL_OW 325
54933: IFFALSE 55186
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54935: LD_ADDR_VAR 0 4
54939: PUSH
54940: LD_EXP 146
54944: PUSH
54945: LD_VAR 0 2
54949: ARRAY
54950: PPUSH
54951: LD_INT 25
54953: PUSH
54954: LD_INT 16
54956: PUSH
54957: EMPTY
54958: LIST
54959: LIST
54960: PPUSH
54961: CALL_OW 72
54965: ST_TO_ADDR
// if tmp < 6 then
54966: LD_VAR 0 4
54970: PUSH
54971: LD_INT 6
54973: LESS
54974: IFFALSE 55186
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54976: LD_ADDR_VAR 0 6
54980: PUSH
54981: LD_EXP 117
54985: PUSH
54986: LD_VAR 0 2
54990: ARRAY
54991: PPUSH
54992: LD_INT 2
54994: PUSH
54995: LD_INT 30
54997: PUSH
54998: LD_INT 0
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: PUSH
55005: LD_INT 30
55007: PUSH
55008: LD_INT 1
55010: PUSH
55011: EMPTY
55012: LIST
55013: LIST
55014: PUSH
55015: EMPTY
55016: LIST
55017: LIST
55018: LIST
55019: PPUSH
55020: CALL_OW 72
55024: ST_TO_ADDR
// if depot then
55025: LD_VAR 0 6
55029: IFFALSE 55186
// begin selected := 0 ;
55031: LD_ADDR_VAR 0 7
55035: PUSH
55036: LD_INT 0
55038: ST_TO_ADDR
// for j in depot do
55039: LD_ADDR_VAR 0 3
55043: PUSH
55044: LD_VAR 0 6
55048: PUSH
55049: FOR_IN
55050: IFFALSE 55081
// begin if UnitsInside ( j ) < 6 then
55052: LD_VAR 0 3
55056: PPUSH
55057: CALL_OW 313
55061: PUSH
55062: LD_INT 6
55064: LESS
55065: IFFALSE 55079
// begin selected := j ;
55067: LD_ADDR_VAR 0 7
55071: PUSH
55072: LD_VAR 0 3
55076: ST_TO_ADDR
// break ;
55077: GO 55081
// end ; end ;
55079: GO 55049
55081: POP
55082: POP
// if selected then
55083: LD_VAR 0 7
55087: IFFALSE 55186
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55089: LD_ADDR_VAR 0 3
55093: PUSH
55094: LD_EXP 146
55098: PUSH
55099: LD_VAR 0 2
55103: ARRAY
55104: PPUSH
55105: LD_INT 25
55107: PUSH
55108: LD_INT 12
55110: PUSH
55111: EMPTY
55112: LIST
55113: LIST
55114: PPUSH
55115: CALL_OW 72
55119: PUSH
55120: FOR_IN
55121: IFFALSE 55184
// if not HasTask ( j ) then
55123: LD_VAR 0 3
55127: PPUSH
55128: CALL_OW 314
55132: NOT
55133: IFFALSE 55182
// begin if not IsInUnit ( j ) then
55135: LD_VAR 0 3
55139: PPUSH
55140: CALL_OW 310
55144: NOT
55145: IFFALSE 55161
// ComEnterUnit ( j , selected ) ;
55147: LD_VAR 0 3
55151: PPUSH
55152: LD_VAR 0 7
55156: PPUSH
55157: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55161: LD_VAR 0 3
55165: PPUSH
55166: LD_INT 16
55168: PPUSH
55169: CALL_OW 183
// AddComExitBuilding ( j ) ;
55173: LD_VAR 0 3
55177: PPUSH
55178: CALL_OW 182
// end ;
55182: GO 55120
55184: POP
55185: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55186: LD_VAR 0 5
55190: PPUSH
55191: LD_INT 11
55193: PPUSH
55194: CALL_OW 325
55198: IFFALSE 55457
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55200: LD_ADDR_VAR 0 4
55204: PUSH
55205: LD_EXP 146
55209: PUSH
55210: LD_VAR 0 2
55214: ARRAY
55215: PPUSH
55216: LD_INT 25
55218: PUSH
55219: LD_INT 16
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: PPUSH
55226: CALL_OW 72
55230: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55231: LD_VAR 0 4
55235: PUSH
55236: LD_INT 6
55238: GREATEREQUAL
55239: PUSH
55240: LD_VAR 0 5
55244: PPUSH
55245: LD_INT 2
55247: PPUSH
55248: CALL_OW 325
55252: NOT
55253: OR
55254: IFFALSE 55457
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55256: LD_ADDR_VAR 0 8
55260: PUSH
55261: LD_EXP 117
55265: PUSH
55266: LD_VAR 0 2
55270: ARRAY
55271: PPUSH
55272: LD_INT 2
55274: PUSH
55275: LD_INT 30
55277: PUSH
55278: LD_INT 4
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: PUSH
55285: LD_INT 30
55287: PUSH
55288: LD_INT 5
55290: PUSH
55291: EMPTY
55292: LIST
55293: LIST
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: LIST
55299: PPUSH
55300: CALL_OW 72
55304: ST_TO_ADDR
// if barracks then
55305: LD_VAR 0 8
55309: IFFALSE 55457
// begin selected := 0 ;
55311: LD_ADDR_VAR 0 7
55315: PUSH
55316: LD_INT 0
55318: ST_TO_ADDR
// for j in barracks do
55319: LD_ADDR_VAR 0 3
55323: PUSH
55324: LD_VAR 0 8
55328: PUSH
55329: FOR_IN
55330: IFFALSE 55361
// begin if UnitsInside ( j ) < 6 then
55332: LD_VAR 0 3
55336: PPUSH
55337: CALL_OW 313
55341: PUSH
55342: LD_INT 6
55344: LESS
55345: IFFALSE 55359
// begin selected := j ;
55347: LD_ADDR_VAR 0 7
55351: PUSH
55352: LD_VAR 0 3
55356: ST_TO_ADDR
// break ;
55357: GO 55361
// end ; end ;
55359: GO 55329
55361: POP
55362: POP
// if selected then
55363: LD_VAR 0 7
55367: IFFALSE 55457
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55369: LD_ADDR_VAR 0 3
55373: PUSH
55374: LD_EXP 146
55378: PUSH
55379: LD_VAR 0 2
55383: ARRAY
55384: PPUSH
55385: LD_INT 25
55387: PUSH
55388: LD_INT 12
55390: PUSH
55391: EMPTY
55392: LIST
55393: LIST
55394: PPUSH
55395: CALL_OW 72
55399: PUSH
55400: FOR_IN
55401: IFFALSE 55455
// if not IsInUnit ( j ) and not HasTask ( j ) then
55403: LD_VAR 0 3
55407: PPUSH
55408: CALL_OW 310
55412: NOT
55413: PUSH
55414: LD_VAR 0 3
55418: PPUSH
55419: CALL_OW 314
55423: NOT
55424: AND
55425: IFFALSE 55453
// begin ComEnterUnit ( j , selected ) ;
55427: LD_VAR 0 3
55431: PPUSH
55432: LD_VAR 0 7
55436: PPUSH
55437: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55441: LD_VAR 0 3
55445: PPUSH
55446: LD_INT 15
55448: PPUSH
55449: CALL_OW 183
// end ;
55453: GO 55400
55455: POP
55456: POP
// end ; end ; end ; end ; end ;
55457: GO 54850
55459: POP
55460: POP
// end ;
55461: LD_VAR 0 1
55465: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55466: LD_INT 0
55468: PPUSH
55469: PPUSH
55470: PPUSH
55471: PPUSH
// if not mc_bases then
55472: LD_EXP 117
55476: NOT
55477: IFFALSE 55481
// exit ;
55479: GO 55659
// for i = 1 to mc_bases do
55481: LD_ADDR_VAR 0 2
55485: PUSH
55486: DOUBLE
55487: LD_INT 1
55489: DEC
55490: ST_TO_ADDR
55491: LD_EXP 117
55495: PUSH
55496: FOR_TO
55497: IFFALSE 55657
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55499: LD_ADDR_VAR 0 4
55503: PUSH
55504: LD_EXP 117
55508: PUSH
55509: LD_VAR 0 2
55513: ARRAY
55514: PPUSH
55515: LD_INT 25
55517: PUSH
55518: LD_INT 9
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PPUSH
55525: CALL_OW 72
55529: ST_TO_ADDR
// if not tmp then
55530: LD_VAR 0 4
55534: NOT
55535: IFFALSE 55539
// continue ;
55537: GO 55496
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55539: LD_EXP 143
55543: PUSH
55544: LD_VAR 0 2
55548: ARRAY
55549: PPUSH
55550: LD_INT 29
55552: PPUSH
55553: CALL_OW 325
55557: NOT
55558: PUSH
55559: LD_EXP 143
55563: PUSH
55564: LD_VAR 0 2
55568: ARRAY
55569: PPUSH
55570: LD_INT 28
55572: PPUSH
55573: CALL_OW 325
55577: NOT
55578: AND
55579: IFFALSE 55583
// continue ;
55581: GO 55496
// for j in tmp do
55583: LD_ADDR_VAR 0 3
55587: PUSH
55588: LD_VAR 0 4
55592: PUSH
55593: FOR_IN
55594: IFFALSE 55653
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55596: LD_VAR 0 3
55600: PUSH
55601: LD_EXP 120
55605: PUSH
55606: LD_VAR 0 2
55610: ARRAY
55611: PUSH
55612: LD_INT 1
55614: ARRAY
55615: IN
55616: NOT
55617: PUSH
55618: LD_VAR 0 3
55622: PUSH
55623: LD_EXP 120
55627: PUSH
55628: LD_VAR 0 2
55632: ARRAY
55633: PUSH
55634: LD_INT 2
55636: ARRAY
55637: IN
55638: NOT
55639: AND
55640: IFFALSE 55651
// ComSpaceTimeShoot ( j ) ;
55642: LD_VAR 0 3
55646: PPUSH
55647: CALL 66863 0 1
55651: GO 55593
55653: POP
55654: POP
// end ;
55655: GO 55496
55657: POP
55658: POP
// end ;
55659: LD_VAR 0 1
55663: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55664: LD_INT 0
55666: PPUSH
55667: PPUSH
55668: PPUSH
55669: PPUSH
55670: PPUSH
55671: PPUSH
55672: PPUSH
55673: PPUSH
55674: PPUSH
// if not mc_bases then
55675: LD_EXP 117
55679: NOT
55680: IFFALSE 55684
// exit ;
55682: GO 56306
// for i = 1 to mc_bases do
55684: LD_ADDR_VAR 0 2
55688: PUSH
55689: DOUBLE
55690: LD_INT 1
55692: DEC
55693: ST_TO_ADDR
55694: LD_EXP 117
55698: PUSH
55699: FOR_TO
55700: IFFALSE 56304
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55702: LD_EXP 152
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: NOT
55713: PUSH
55714: LD_INT 38
55716: PPUSH
55717: LD_EXP 143
55721: PUSH
55722: LD_VAR 0 2
55726: ARRAY
55727: PPUSH
55728: CALL_OW 321
55732: PUSH
55733: LD_INT 2
55735: NONEQUAL
55736: OR
55737: IFFALSE 55741
// continue ;
55739: GO 55699
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55741: LD_ADDR_VAR 0 8
55745: PUSH
55746: LD_EXP 117
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 30
55759: PUSH
55760: LD_INT 34
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PPUSH
55767: CALL_OW 72
55771: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55772: LD_ADDR_VAR 0 9
55776: PUSH
55777: LD_EXP 117
55781: PUSH
55782: LD_VAR 0 2
55786: ARRAY
55787: PPUSH
55788: LD_INT 25
55790: PUSH
55791: LD_INT 4
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PPUSH
55798: CALL_OW 72
55802: PPUSH
55803: LD_INT 0
55805: PPUSH
55806: CALL 100171 0 2
55810: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55811: LD_VAR 0 9
55815: NOT
55816: PUSH
55817: LD_VAR 0 8
55821: NOT
55822: OR
55823: PUSH
55824: LD_EXP 117
55828: PUSH
55829: LD_VAR 0 2
55833: ARRAY
55834: PPUSH
55835: LD_INT 124
55837: PPUSH
55838: CALL 100171 0 2
55842: OR
55843: IFFALSE 55847
// continue ;
55845: GO 55699
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55847: LD_EXP 153
55851: PUSH
55852: LD_VAR 0 2
55856: ARRAY
55857: PUSH
55858: LD_EXP 152
55862: PUSH
55863: LD_VAR 0 2
55867: ARRAY
55868: LESS
55869: PUSH
55870: LD_EXP 153
55874: PUSH
55875: LD_VAR 0 2
55879: ARRAY
55880: PUSH
55881: LD_VAR 0 8
55885: LESS
55886: AND
55887: IFFALSE 56302
// begin tmp := sci [ 1 ] ;
55889: LD_ADDR_VAR 0 7
55893: PUSH
55894: LD_VAR 0 9
55898: PUSH
55899: LD_INT 1
55901: ARRAY
55902: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55903: LD_VAR 0 7
55907: PPUSH
55908: LD_INT 124
55910: PPUSH
55911: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55915: LD_ADDR_VAR 0 3
55919: PUSH
55920: DOUBLE
55921: LD_EXP 152
55925: PUSH
55926: LD_VAR 0 2
55930: ARRAY
55931: INC
55932: ST_TO_ADDR
55933: LD_EXP 152
55937: PUSH
55938: LD_VAR 0 2
55942: ARRAY
55943: PUSH
55944: FOR_DOWNTO
55945: IFFALSE 56288
// begin if IsInUnit ( tmp ) then
55947: LD_VAR 0 7
55951: PPUSH
55952: CALL_OW 310
55956: IFFALSE 55967
// ComExitBuilding ( tmp ) ;
55958: LD_VAR 0 7
55962: PPUSH
55963: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55967: LD_INT 35
55969: PPUSH
55970: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55974: LD_VAR 0 7
55978: PPUSH
55979: CALL_OW 310
55983: NOT
55984: PUSH
55985: LD_VAR 0 7
55989: PPUSH
55990: CALL_OW 314
55994: NOT
55995: AND
55996: IFFALSE 55967
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55998: LD_ADDR_VAR 0 6
56002: PUSH
56003: LD_VAR 0 7
56007: PPUSH
56008: CALL_OW 250
56012: PUSH
56013: LD_VAR 0 7
56017: PPUSH
56018: CALL_OW 251
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
56027: LD_INT 35
56029: PPUSH
56030: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
56034: LD_ADDR_VAR 0 4
56038: PUSH
56039: LD_EXP 152
56043: PUSH
56044: LD_VAR 0 2
56048: ARRAY
56049: PUSH
56050: LD_VAR 0 3
56054: ARRAY
56055: PUSH
56056: LD_INT 1
56058: ARRAY
56059: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56060: LD_ADDR_VAR 0 5
56064: PUSH
56065: LD_EXP 152
56069: PUSH
56070: LD_VAR 0 2
56074: ARRAY
56075: PUSH
56076: LD_VAR 0 3
56080: ARRAY
56081: PUSH
56082: LD_INT 2
56084: ARRAY
56085: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56086: LD_VAR 0 7
56090: PPUSH
56091: LD_INT 10
56093: PPUSH
56094: CALL 73501 0 2
56098: PUSH
56099: LD_INT 4
56101: ARRAY
56102: IFFALSE 56140
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56104: LD_VAR 0 7
56108: PPUSH
56109: LD_VAR 0 6
56113: PUSH
56114: LD_INT 1
56116: ARRAY
56117: PPUSH
56118: LD_VAR 0 6
56122: PUSH
56123: LD_INT 2
56125: ARRAY
56126: PPUSH
56127: CALL_OW 111
// wait ( 0 0$10 ) ;
56131: LD_INT 350
56133: PPUSH
56134: CALL_OW 67
// end else
56138: GO 56166
// begin ComMoveXY ( tmp , x , y ) ;
56140: LD_VAR 0 7
56144: PPUSH
56145: LD_VAR 0 4
56149: PPUSH
56150: LD_VAR 0 5
56154: PPUSH
56155: CALL_OW 111
// wait ( 0 0$3 ) ;
56159: LD_INT 105
56161: PPUSH
56162: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56166: LD_VAR 0 7
56170: PPUSH
56171: LD_VAR 0 4
56175: PPUSH
56176: LD_VAR 0 5
56180: PPUSH
56181: CALL_OW 307
56185: IFFALSE 56027
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56187: LD_VAR 0 7
56191: PPUSH
56192: LD_VAR 0 4
56196: PPUSH
56197: LD_VAR 0 5
56201: PPUSH
56202: LD_VAR 0 8
56206: PUSH
56207: LD_VAR 0 3
56211: ARRAY
56212: PPUSH
56213: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56217: LD_INT 35
56219: PPUSH
56220: CALL_OW 67
// until not HasTask ( tmp ) ;
56224: LD_VAR 0 7
56228: PPUSH
56229: CALL_OW 314
56233: NOT
56234: IFFALSE 56217
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56236: LD_ADDR_EXP 153
56240: PUSH
56241: LD_EXP 153
56245: PPUSH
56246: LD_VAR 0 2
56250: PUSH
56251: LD_EXP 153
56255: PUSH
56256: LD_VAR 0 2
56260: ARRAY
56261: PUSH
56262: LD_INT 1
56264: PLUS
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: PPUSH
56270: LD_VAR 0 8
56274: PUSH
56275: LD_VAR 0 3
56279: ARRAY
56280: PPUSH
56281: CALL 70902 0 3
56285: ST_TO_ADDR
// end ;
56286: GO 55944
56288: POP
56289: POP
// MC_Reset ( i , 124 ) ;
56290: LD_VAR 0 2
56294: PPUSH
56295: LD_INT 124
56297: PPUSH
56298: CALL 39444 0 2
// end ; end ;
56302: GO 55699
56304: POP
56305: POP
// end ;
56306: LD_VAR 0 1
56310: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56311: LD_INT 0
56313: PPUSH
56314: PPUSH
56315: PPUSH
// if not mc_bases then
56316: LD_EXP 117
56320: NOT
56321: IFFALSE 56325
// exit ;
56323: GO 56931
// for i = 1 to mc_bases do
56325: LD_ADDR_VAR 0 2
56329: PUSH
56330: DOUBLE
56331: LD_INT 1
56333: DEC
56334: ST_TO_ADDR
56335: LD_EXP 117
56339: PUSH
56340: FOR_TO
56341: IFFALSE 56929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56343: LD_ADDR_VAR 0 3
56347: PUSH
56348: LD_EXP 117
56352: PUSH
56353: LD_VAR 0 2
56357: ARRAY
56358: PPUSH
56359: LD_INT 25
56361: PUSH
56362: LD_INT 4
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: PPUSH
56369: CALL_OW 72
56373: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56374: LD_VAR 0 3
56378: NOT
56379: PUSH
56380: LD_EXP 154
56384: PUSH
56385: LD_VAR 0 2
56389: ARRAY
56390: NOT
56391: OR
56392: PUSH
56393: LD_EXP 117
56397: PUSH
56398: LD_VAR 0 2
56402: ARRAY
56403: PPUSH
56404: LD_INT 2
56406: PUSH
56407: LD_INT 30
56409: PUSH
56410: LD_INT 0
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PUSH
56417: LD_INT 30
56419: PUSH
56420: LD_INT 1
56422: PUSH
56423: EMPTY
56424: LIST
56425: LIST
56426: PUSH
56427: EMPTY
56428: LIST
56429: LIST
56430: LIST
56431: PPUSH
56432: CALL_OW 72
56436: NOT
56437: OR
56438: IFFALSE 56488
// begin if mc_deposits_finder [ i ] then
56440: LD_EXP 155
56444: PUSH
56445: LD_VAR 0 2
56449: ARRAY
56450: IFFALSE 56486
// begin MC_Reset ( i , 125 ) ;
56452: LD_VAR 0 2
56456: PPUSH
56457: LD_INT 125
56459: PPUSH
56460: CALL 39444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56464: LD_ADDR_EXP 155
56468: PUSH
56469: LD_EXP 155
56473: PPUSH
56474: LD_VAR 0 2
56478: PPUSH
56479: EMPTY
56480: PPUSH
56481: CALL_OW 1
56485: ST_TO_ADDR
// end ; continue ;
56486: GO 56340
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56488: LD_EXP 154
56492: PUSH
56493: LD_VAR 0 2
56497: ARRAY
56498: PUSH
56499: LD_INT 1
56501: ARRAY
56502: PUSH
56503: LD_INT 3
56505: ARRAY
56506: PUSH
56507: LD_INT 1
56509: EQUAL
56510: PUSH
56511: LD_INT 20
56513: PPUSH
56514: LD_EXP 143
56518: PUSH
56519: LD_VAR 0 2
56523: ARRAY
56524: PPUSH
56525: CALL_OW 321
56529: PUSH
56530: LD_INT 2
56532: NONEQUAL
56533: AND
56534: IFFALSE 56584
// begin if mc_deposits_finder [ i ] then
56536: LD_EXP 155
56540: PUSH
56541: LD_VAR 0 2
56545: ARRAY
56546: IFFALSE 56582
// begin MC_Reset ( i , 125 ) ;
56548: LD_VAR 0 2
56552: PPUSH
56553: LD_INT 125
56555: PPUSH
56556: CALL 39444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56560: LD_ADDR_EXP 155
56564: PUSH
56565: LD_EXP 155
56569: PPUSH
56570: LD_VAR 0 2
56574: PPUSH
56575: EMPTY
56576: PPUSH
56577: CALL_OW 1
56581: ST_TO_ADDR
// end ; continue ;
56582: GO 56340
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56584: LD_EXP 154
56588: PUSH
56589: LD_VAR 0 2
56593: ARRAY
56594: PUSH
56595: LD_INT 1
56597: ARRAY
56598: PUSH
56599: LD_INT 1
56601: ARRAY
56602: PPUSH
56603: LD_EXP 154
56607: PUSH
56608: LD_VAR 0 2
56612: ARRAY
56613: PUSH
56614: LD_INT 1
56616: ARRAY
56617: PUSH
56618: LD_INT 2
56620: ARRAY
56621: PPUSH
56622: LD_EXP 143
56626: PUSH
56627: LD_VAR 0 2
56631: ARRAY
56632: PPUSH
56633: CALL_OW 440
56637: IFFALSE 56680
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56639: LD_ADDR_EXP 154
56643: PUSH
56644: LD_EXP 154
56648: PPUSH
56649: LD_VAR 0 2
56653: PPUSH
56654: LD_EXP 154
56658: PUSH
56659: LD_VAR 0 2
56663: ARRAY
56664: PPUSH
56665: LD_INT 1
56667: PPUSH
56668: CALL_OW 3
56672: PPUSH
56673: CALL_OW 1
56677: ST_TO_ADDR
56678: GO 56927
// begin if not mc_deposits_finder [ i ] then
56680: LD_EXP 155
56684: PUSH
56685: LD_VAR 0 2
56689: ARRAY
56690: NOT
56691: IFFALSE 56743
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56693: LD_ADDR_EXP 155
56697: PUSH
56698: LD_EXP 155
56702: PPUSH
56703: LD_VAR 0 2
56707: PPUSH
56708: LD_VAR 0 3
56712: PUSH
56713: LD_INT 1
56715: ARRAY
56716: PUSH
56717: EMPTY
56718: LIST
56719: PPUSH
56720: CALL_OW 1
56724: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56725: LD_VAR 0 3
56729: PUSH
56730: LD_INT 1
56732: ARRAY
56733: PPUSH
56734: LD_INT 125
56736: PPUSH
56737: CALL_OW 109
// end else
56741: GO 56927
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56743: LD_EXP 155
56747: PUSH
56748: LD_VAR 0 2
56752: ARRAY
56753: PUSH
56754: LD_INT 1
56756: ARRAY
56757: PPUSH
56758: CALL_OW 310
56762: IFFALSE 56785
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56764: LD_EXP 155
56768: PUSH
56769: LD_VAR 0 2
56773: ARRAY
56774: PUSH
56775: LD_INT 1
56777: ARRAY
56778: PPUSH
56779: CALL_OW 122
56783: GO 56927
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56785: LD_EXP 155
56789: PUSH
56790: LD_VAR 0 2
56794: ARRAY
56795: PUSH
56796: LD_INT 1
56798: ARRAY
56799: PPUSH
56800: CALL_OW 314
56804: NOT
56805: PUSH
56806: LD_EXP 155
56810: PUSH
56811: LD_VAR 0 2
56815: ARRAY
56816: PUSH
56817: LD_INT 1
56819: ARRAY
56820: PPUSH
56821: LD_EXP 154
56825: PUSH
56826: LD_VAR 0 2
56830: ARRAY
56831: PUSH
56832: LD_INT 1
56834: ARRAY
56835: PUSH
56836: LD_INT 1
56838: ARRAY
56839: PPUSH
56840: LD_EXP 154
56844: PUSH
56845: LD_VAR 0 2
56849: ARRAY
56850: PUSH
56851: LD_INT 1
56853: ARRAY
56854: PUSH
56855: LD_INT 2
56857: ARRAY
56858: PPUSH
56859: CALL_OW 297
56863: PUSH
56864: LD_INT 6
56866: GREATER
56867: AND
56868: IFFALSE 56927
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56870: LD_EXP 155
56874: PUSH
56875: LD_VAR 0 2
56879: ARRAY
56880: PUSH
56881: LD_INT 1
56883: ARRAY
56884: PPUSH
56885: LD_EXP 154
56889: PUSH
56890: LD_VAR 0 2
56894: ARRAY
56895: PUSH
56896: LD_INT 1
56898: ARRAY
56899: PUSH
56900: LD_INT 1
56902: ARRAY
56903: PPUSH
56904: LD_EXP 154
56908: PUSH
56909: LD_VAR 0 2
56913: ARRAY
56914: PUSH
56915: LD_INT 1
56917: ARRAY
56918: PUSH
56919: LD_INT 2
56921: ARRAY
56922: PPUSH
56923: CALL_OW 111
// end ; end ; end ;
56927: GO 56340
56929: POP
56930: POP
// end ;
56931: LD_VAR 0 1
56935: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56936: LD_INT 0
56938: PPUSH
56939: PPUSH
56940: PPUSH
56941: PPUSH
56942: PPUSH
56943: PPUSH
56944: PPUSH
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
// if not mc_bases then
56949: LD_EXP 117
56953: NOT
56954: IFFALSE 56958
// exit ;
56956: GO 57898
// for i = 1 to mc_bases do
56958: LD_ADDR_VAR 0 2
56962: PUSH
56963: DOUBLE
56964: LD_INT 1
56966: DEC
56967: ST_TO_ADDR
56968: LD_EXP 117
56972: PUSH
56973: FOR_TO
56974: IFFALSE 57896
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56976: LD_EXP 117
56980: PUSH
56981: LD_VAR 0 2
56985: ARRAY
56986: NOT
56987: PUSH
56988: LD_EXP 140
56992: PUSH
56993: LD_VAR 0 2
56997: ARRAY
56998: OR
56999: IFFALSE 57003
// continue ;
57001: GO 56973
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
57003: LD_ADDR_VAR 0 7
57007: PUSH
57008: LD_EXP 117
57012: PUSH
57013: LD_VAR 0 2
57017: ARRAY
57018: PUSH
57019: LD_INT 1
57021: ARRAY
57022: PPUSH
57023: CALL_OW 248
57027: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
57028: LD_VAR 0 7
57032: PUSH
57033: LD_INT 3
57035: EQUAL
57036: PUSH
57037: LD_EXP 136
57041: PUSH
57042: LD_VAR 0 2
57046: ARRAY
57047: PUSH
57048: LD_EXP 139
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: UNION
57059: PPUSH
57060: LD_INT 33
57062: PUSH
57063: LD_INT 2
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PPUSH
57070: CALL_OW 72
57074: NOT
57075: OR
57076: IFFALSE 57080
// continue ;
57078: GO 56973
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57080: LD_ADDR_VAR 0 9
57084: PUSH
57085: LD_EXP 117
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: PPUSH
57096: LD_INT 30
57098: PUSH
57099: LD_INT 36
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PPUSH
57106: CALL_OW 72
57110: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57111: LD_ADDR_VAR 0 10
57115: PUSH
57116: LD_EXP 136
57120: PUSH
57121: LD_VAR 0 2
57125: ARRAY
57126: PPUSH
57127: LD_INT 34
57129: PUSH
57130: LD_INT 31
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: PPUSH
57137: CALL_OW 72
57141: ST_TO_ADDR
// if not cts and not mcts then
57142: LD_VAR 0 9
57146: NOT
57147: PUSH
57148: LD_VAR 0 10
57152: NOT
57153: AND
57154: IFFALSE 57158
// continue ;
57156: GO 56973
// x := cts ;
57158: LD_ADDR_VAR 0 11
57162: PUSH
57163: LD_VAR 0 9
57167: ST_TO_ADDR
// if not x then
57168: LD_VAR 0 11
57172: NOT
57173: IFFALSE 57185
// x := mcts ;
57175: LD_ADDR_VAR 0 11
57179: PUSH
57180: LD_VAR 0 10
57184: ST_TO_ADDR
// if not x then
57185: LD_VAR 0 11
57189: NOT
57190: IFFALSE 57194
// continue ;
57192: GO 56973
// if mc_remote_driver [ i ] then
57194: LD_EXP 157
57198: PUSH
57199: LD_VAR 0 2
57203: ARRAY
57204: IFFALSE 57591
// for j in mc_remote_driver [ i ] do
57206: LD_ADDR_VAR 0 3
57210: PUSH
57211: LD_EXP 157
57215: PUSH
57216: LD_VAR 0 2
57220: ARRAY
57221: PUSH
57222: FOR_IN
57223: IFFALSE 57589
// begin if GetClass ( j ) <> 3 then
57225: LD_VAR 0 3
57229: PPUSH
57230: CALL_OW 257
57234: PUSH
57235: LD_INT 3
57237: NONEQUAL
57238: IFFALSE 57291
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57240: LD_ADDR_EXP 157
57244: PUSH
57245: LD_EXP 157
57249: PPUSH
57250: LD_VAR 0 2
57254: PPUSH
57255: LD_EXP 157
57259: PUSH
57260: LD_VAR 0 2
57264: ARRAY
57265: PUSH
57266: LD_VAR 0 3
57270: DIFF
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57277: LD_VAR 0 3
57281: PPUSH
57282: LD_INT 0
57284: PPUSH
57285: CALL_OW 109
// continue ;
57289: GO 57222
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57291: LD_EXP 136
57295: PUSH
57296: LD_VAR 0 2
57300: ARRAY
57301: PPUSH
57302: LD_INT 34
57304: PUSH
57305: LD_INT 31
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PUSH
57312: LD_INT 58
57314: PUSH
57315: EMPTY
57316: LIST
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: PPUSH
57322: CALL_OW 72
57326: PUSH
57327: LD_VAR 0 3
57331: PPUSH
57332: CALL 100206 0 1
57336: NOT
57337: AND
57338: IFFALSE 57409
// begin if IsInUnit ( j ) then
57340: LD_VAR 0 3
57344: PPUSH
57345: CALL_OW 310
57349: IFFALSE 57360
// ComExitBuilding ( j ) ;
57351: LD_VAR 0 3
57355: PPUSH
57356: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57360: LD_VAR 0 3
57364: PPUSH
57365: LD_EXP 136
57369: PUSH
57370: LD_VAR 0 2
57374: ARRAY
57375: PPUSH
57376: LD_INT 34
57378: PUSH
57379: LD_INT 31
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 58
57388: PUSH
57389: EMPTY
57390: LIST
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PPUSH
57396: CALL_OW 72
57400: PUSH
57401: LD_INT 1
57403: ARRAY
57404: PPUSH
57405: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57409: LD_VAR 0 3
57413: PPUSH
57414: CALL_OW 310
57418: NOT
57419: PUSH
57420: LD_VAR 0 3
57424: PPUSH
57425: CALL_OW 310
57429: PPUSH
57430: CALL_OW 266
57434: PUSH
57435: LD_INT 36
57437: NONEQUAL
57438: PUSH
57439: LD_VAR 0 3
57443: PPUSH
57444: CALL 100206 0 1
57448: NOT
57449: AND
57450: OR
57451: IFFALSE 57587
// begin if IsInUnit ( j ) then
57453: LD_VAR 0 3
57457: PPUSH
57458: CALL_OW 310
57462: IFFALSE 57473
// ComExitBuilding ( j ) ;
57464: LD_VAR 0 3
57468: PPUSH
57469: CALL_OW 122
// ct := 0 ;
57473: LD_ADDR_VAR 0 8
57477: PUSH
57478: LD_INT 0
57480: ST_TO_ADDR
// for k in x do
57481: LD_ADDR_VAR 0 4
57485: PUSH
57486: LD_VAR 0 11
57490: PUSH
57491: FOR_IN
57492: IFFALSE 57565
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57494: LD_VAR 0 4
57498: PPUSH
57499: CALL_OW 264
57503: PUSH
57504: LD_INT 31
57506: EQUAL
57507: PUSH
57508: LD_VAR 0 4
57512: PPUSH
57513: CALL_OW 311
57517: NOT
57518: AND
57519: PUSH
57520: LD_VAR 0 4
57524: PPUSH
57525: CALL_OW 266
57529: PUSH
57530: LD_INT 36
57532: EQUAL
57533: PUSH
57534: LD_VAR 0 4
57538: PPUSH
57539: CALL_OW 313
57543: PUSH
57544: LD_INT 3
57546: LESS
57547: AND
57548: OR
57549: IFFALSE 57563
// begin ct := k ;
57551: LD_ADDR_VAR 0 8
57555: PUSH
57556: LD_VAR 0 4
57560: ST_TO_ADDR
// break ;
57561: GO 57565
// end ;
57563: GO 57491
57565: POP
57566: POP
// if ct then
57567: LD_VAR 0 8
57571: IFFALSE 57587
// ComEnterUnit ( j , ct ) ;
57573: LD_VAR 0 3
57577: PPUSH
57578: LD_VAR 0 8
57582: PPUSH
57583: CALL_OW 120
// end ; end ;
57587: GO 57222
57589: POP
57590: POP
// places := 0 ;
57591: LD_ADDR_VAR 0 5
57595: PUSH
57596: LD_INT 0
57598: ST_TO_ADDR
// for j = 1 to x do
57599: LD_ADDR_VAR 0 3
57603: PUSH
57604: DOUBLE
57605: LD_INT 1
57607: DEC
57608: ST_TO_ADDR
57609: LD_VAR 0 11
57613: PUSH
57614: FOR_TO
57615: IFFALSE 57691
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57617: LD_VAR 0 11
57621: PUSH
57622: LD_VAR 0 3
57626: ARRAY
57627: PPUSH
57628: CALL_OW 264
57632: PUSH
57633: LD_INT 31
57635: EQUAL
57636: IFFALSE 57654
// places := places + 1 else
57638: LD_ADDR_VAR 0 5
57642: PUSH
57643: LD_VAR 0 5
57647: PUSH
57648: LD_INT 1
57650: PLUS
57651: ST_TO_ADDR
57652: GO 57689
// if GetBType ( x [ j ] ) = b_control_tower then
57654: LD_VAR 0 11
57658: PUSH
57659: LD_VAR 0 3
57663: ARRAY
57664: PPUSH
57665: CALL_OW 266
57669: PUSH
57670: LD_INT 36
57672: EQUAL
57673: IFFALSE 57689
// places := places + 3 ;
57675: LD_ADDR_VAR 0 5
57679: PUSH
57680: LD_VAR 0 5
57684: PUSH
57685: LD_INT 3
57687: PLUS
57688: ST_TO_ADDR
57689: GO 57614
57691: POP
57692: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57693: LD_VAR 0 5
57697: PUSH
57698: LD_INT 0
57700: EQUAL
57701: PUSH
57702: LD_VAR 0 5
57706: PUSH
57707: LD_EXP 157
57711: PUSH
57712: LD_VAR 0 2
57716: ARRAY
57717: LESSEQUAL
57718: OR
57719: IFFALSE 57723
// continue ;
57721: GO 56973
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57723: LD_ADDR_VAR 0 6
57727: PUSH
57728: LD_EXP 117
57732: PUSH
57733: LD_VAR 0 2
57737: ARRAY
57738: PPUSH
57739: LD_INT 25
57741: PUSH
57742: LD_INT 3
57744: PUSH
57745: EMPTY
57746: LIST
57747: LIST
57748: PPUSH
57749: CALL_OW 72
57753: PUSH
57754: LD_EXP 157
57758: PUSH
57759: LD_VAR 0 2
57763: ARRAY
57764: DIFF
57765: PPUSH
57766: LD_INT 3
57768: PPUSH
57769: CALL 101106 0 2
57773: ST_TO_ADDR
// for j in tmp do
57774: LD_ADDR_VAR 0 3
57778: PUSH
57779: LD_VAR 0 6
57783: PUSH
57784: FOR_IN
57785: IFFALSE 57820
// if GetTag ( j ) > 0 then
57787: LD_VAR 0 3
57791: PPUSH
57792: CALL_OW 110
57796: PUSH
57797: LD_INT 0
57799: GREATER
57800: IFFALSE 57818
// tmp := tmp diff j ;
57802: LD_ADDR_VAR 0 6
57806: PUSH
57807: LD_VAR 0 6
57811: PUSH
57812: LD_VAR 0 3
57816: DIFF
57817: ST_TO_ADDR
57818: GO 57784
57820: POP
57821: POP
// if not tmp then
57822: LD_VAR 0 6
57826: NOT
57827: IFFALSE 57831
// continue ;
57829: GO 56973
// if places then
57831: LD_VAR 0 5
57835: IFFALSE 57894
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57837: LD_ADDR_EXP 157
57841: PUSH
57842: LD_EXP 157
57846: PPUSH
57847: LD_VAR 0 2
57851: PPUSH
57852: LD_EXP 157
57856: PUSH
57857: LD_VAR 0 2
57861: ARRAY
57862: PUSH
57863: LD_VAR 0 6
57867: PUSH
57868: LD_INT 1
57870: ARRAY
57871: UNION
57872: PPUSH
57873: CALL_OW 1
57877: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57878: LD_VAR 0 6
57882: PUSH
57883: LD_INT 1
57885: ARRAY
57886: PPUSH
57887: LD_INT 126
57889: PPUSH
57890: CALL_OW 109
// end ; end ;
57894: GO 56973
57896: POP
57897: POP
// end ;
57898: LD_VAR 0 1
57902: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57903: LD_INT 0
57905: PPUSH
57906: PPUSH
57907: PPUSH
57908: PPUSH
57909: PPUSH
57910: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57911: LD_VAR 0 1
57915: NOT
57916: PUSH
57917: LD_VAR 0 2
57921: NOT
57922: OR
57923: PUSH
57924: LD_VAR 0 3
57928: NOT
57929: OR
57930: PUSH
57931: LD_VAR 0 4
57935: PUSH
57936: LD_INT 1
57938: PUSH
57939: LD_INT 2
57941: PUSH
57942: LD_INT 3
57944: PUSH
57945: LD_INT 4
57947: PUSH
57948: LD_INT 5
57950: PUSH
57951: LD_INT 8
57953: PUSH
57954: LD_INT 9
57956: PUSH
57957: LD_INT 15
57959: PUSH
57960: LD_INT 16
57962: PUSH
57963: EMPTY
57964: LIST
57965: LIST
57966: LIST
57967: LIST
57968: LIST
57969: LIST
57970: LIST
57971: LIST
57972: LIST
57973: IN
57974: NOT
57975: OR
57976: IFFALSE 57980
// exit ;
57978: GO 58880
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57980: LD_ADDR_VAR 0 2
57984: PUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: LD_INT 21
57992: PUSH
57993: LD_INT 3
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: PUSH
58000: LD_INT 24
58002: PUSH
58003: LD_INT 250
58005: PUSH
58006: EMPTY
58007: LIST
58008: LIST
58009: PUSH
58010: EMPTY
58011: LIST
58012: LIST
58013: PPUSH
58014: CALL_OW 72
58018: ST_TO_ADDR
// case class of 1 , 15 :
58019: LD_VAR 0 4
58023: PUSH
58024: LD_INT 1
58026: DOUBLE
58027: EQUAL
58028: IFTRUE 58038
58030: LD_INT 15
58032: DOUBLE
58033: EQUAL
58034: IFTRUE 58038
58036: GO 58123
58038: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58039: LD_ADDR_VAR 0 8
58043: PUSH
58044: LD_VAR 0 2
58048: PPUSH
58049: LD_INT 2
58051: PUSH
58052: LD_INT 30
58054: PUSH
58055: LD_INT 32
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: LD_INT 30
58064: PUSH
58065: LD_INT 31
58067: PUSH
58068: EMPTY
58069: LIST
58070: LIST
58071: PUSH
58072: EMPTY
58073: LIST
58074: LIST
58075: LIST
58076: PPUSH
58077: CALL_OW 72
58081: PUSH
58082: LD_VAR 0 2
58086: PPUSH
58087: LD_INT 2
58089: PUSH
58090: LD_INT 30
58092: PUSH
58093: LD_INT 4
58095: PUSH
58096: EMPTY
58097: LIST
58098: LIST
58099: PUSH
58100: LD_INT 30
58102: PUSH
58103: LD_INT 5
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: PUSH
58110: EMPTY
58111: LIST
58112: LIST
58113: LIST
58114: PPUSH
58115: CALL_OW 72
58119: ADD
58120: ST_TO_ADDR
58121: GO 58369
58123: LD_INT 2
58125: DOUBLE
58126: EQUAL
58127: IFTRUE 58137
58129: LD_INT 16
58131: DOUBLE
58132: EQUAL
58133: IFTRUE 58137
58135: GO 58183
58137: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58138: LD_ADDR_VAR 0 8
58142: PUSH
58143: LD_VAR 0 2
58147: PPUSH
58148: LD_INT 2
58150: PUSH
58151: LD_INT 30
58153: PUSH
58154: LD_INT 0
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: PUSH
58161: LD_INT 30
58163: PUSH
58164: LD_INT 1
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: LIST
58175: PPUSH
58176: CALL_OW 72
58180: ST_TO_ADDR
58181: GO 58369
58183: LD_INT 3
58185: DOUBLE
58186: EQUAL
58187: IFTRUE 58191
58189: GO 58237
58191: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58192: LD_ADDR_VAR 0 8
58196: PUSH
58197: LD_VAR 0 2
58201: PPUSH
58202: LD_INT 2
58204: PUSH
58205: LD_INT 30
58207: PUSH
58208: LD_INT 2
58210: PUSH
58211: EMPTY
58212: LIST
58213: LIST
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 3
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: EMPTY
58226: LIST
58227: LIST
58228: LIST
58229: PPUSH
58230: CALL_OW 72
58234: ST_TO_ADDR
58235: GO 58369
58237: LD_INT 4
58239: DOUBLE
58240: EQUAL
58241: IFTRUE 58245
58243: GO 58302
58245: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58246: LD_ADDR_VAR 0 8
58250: PUSH
58251: LD_VAR 0 2
58255: PPUSH
58256: LD_INT 2
58258: PUSH
58259: LD_INT 30
58261: PUSH
58262: LD_INT 6
58264: PUSH
58265: EMPTY
58266: LIST
58267: LIST
58268: PUSH
58269: LD_INT 30
58271: PUSH
58272: LD_INT 7
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: LD_INT 30
58281: PUSH
58282: LD_INT 8
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: LIST
58293: LIST
58294: PPUSH
58295: CALL_OW 72
58299: ST_TO_ADDR
58300: GO 58369
58302: LD_INT 5
58304: DOUBLE
58305: EQUAL
58306: IFTRUE 58322
58308: LD_INT 8
58310: DOUBLE
58311: EQUAL
58312: IFTRUE 58322
58314: LD_INT 9
58316: DOUBLE
58317: EQUAL
58318: IFTRUE 58322
58320: GO 58368
58322: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58323: LD_ADDR_VAR 0 8
58327: PUSH
58328: LD_VAR 0 2
58332: PPUSH
58333: LD_INT 2
58335: PUSH
58336: LD_INT 30
58338: PUSH
58339: LD_INT 4
58341: PUSH
58342: EMPTY
58343: LIST
58344: LIST
58345: PUSH
58346: LD_INT 30
58348: PUSH
58349: LD_INT 5
58351: PUSH
58352: EMPTY
58353: LIST
58354: LIST
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: LIST
58360: PPUSH
58361: CALL_OW 72
58365: ST_TO_ADDR
58366: GO 58369
58368: POP
// if not tmp then
58369: LD_VAR 0 8
58373: NOT
58374: IFFALSE 58378
// exit ;
58376: GO 58880
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58378: LD_VAR 0 4
58382: PUSH
58383: LD_INT 1
58385: PUSH
58386: LD_INT 15
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: IN
58393: PUSH
58394: LD_EXP 126
58398: PUSH
58399: LD_VAR 0 1
58403: ARRAY
58404: AND
58405: IFFALSE 58561
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58407: LD_ADDR_VAR 0 9
58411: PUSH
58412: LD_EXP 126
58416: PUSH
58417: LD_VAR 0 1
58421: ARRAY
58422: PUSH
58423: LD_INT 1
58425: ARRAY
58426: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58427: LD_VAR 0 9
58431: PUSH
58432: LD_EXP 127
58436: PUSH
58437: LD_VAR 0 1
58441: ARRAY
58442: IN
58443: NOT
58444: IFFALSE 58559
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58446: LD_ADDR_EXP 127
58450: PUSH
58451: LD_EXP 127
58455: PPUSH
58456: LD_VAR 0 1
58460: PUSH
58461: LD_EXP 127
58465: PUSH
58466: LD_VAR 0 1
58470: ARRAY
58471: PUSH
58472: LD_INT 1
58474: PLUS
58475: PUSH
58476: EMPTY
58477: LIST
58478: LIST
58479: PPUSH
58480: LD_VAR 0 9
58484: PPUSH
58485: CALL 70902 0 3
58489: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58490: LD_ADDR_EXP 126
58494: PUSH
58495: LD_EXP 126
58499: PPUSH
58500: LD_VAR 0 1
58504: PPUSH
58505: LD_EXP 126
58509: PUSH
58510: LD_VAR 0 1
58514: ARRAY
58515: PUSH
58516: LD_VAR 0 9
58520: DIFF
58521: PPUSH
58522: CALL_OW 1
58526: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58527: LD_VAR 0 3
58531: PPUSH
58532: LD_EXP 127
58536: PUSH
58537: LD_VAR 0 1
58541: ARRAY
58542: PUSH
58543: LD_EXP 127
58547: PUSH
58548: LD_VAR 0 1
58552: ARRAY
58553: ARRAY
58554: PPUSH
58555: CALL_OW 120
// end ; exit ;
58559: GO 58880
// end ; if tmp > 1 then
58561: LD_VAR 0 8
58565: PUSH
58566: LD_INT 1
58568: GREATER
58569: IFFALSE 58673
// for i = 2 to tmp do
58571: LD_ADDR_VAR 0 6
58575: PUSH
58576: DOUBLE
58577: LD_INT 2
58579: DEC
58580: ST_TO_ADDR
58581: LD_VAR 0 8
58585: PUSH
58586: FOR_TO
58587: IFFALSE 58671
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58589: LD_VAR 0 8
58593: PUSH
58594: LD_VAR 0 6
58598: ARRAY
58599: PPUSH
58600: CALL_OW 461
58604: PUSH
58605: LD_INT 6
58607: EQUAL
58608: IFFALSE 58669
// begin x := tmp [ i ] ;
58610: LD_ADDR_VAR 0 9
58614: PUSH
58615: LD_VAR 0 8
58619: PUSH
58620: LD_VAR 0 6
58624: ARRAY
58625: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58626: LD_ADDR_VAR 0 8
58630: PUSH
58631: LD_VAR 0 8
58635: PPUSH
58636: LD_VAR 0 6
58640: PPUSH
58641: CALL_OW 3
58645: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58646: LD_ADDR_VAR 0 8
58650: PUSH
58651: LD_VAR 0 8
58655: PPUSH
58656: LD_INT 1
58658: PPUSH
58659: LD_VAR 0 9
58663: PPUSH
58664: CALL_OW 2
58668: ST_TO_ADDR
// end ;
58669: GO 58586
58671: POP
58672: POP
// for i in tmp do
58673: LD_ADDR_VAR 0 6
58677: PUSH
58678: LD_VAR 0 8
58682: PUSH
58683: FOR_IN
58684: IFFALSE 58753
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58686: LD_VAR 0 6
58690: PPUSH
58691: CALL_OW 313
58695: PUSH
58696: LD_INT 6
58698: LESS
58699: PUSH
58700: LD_VAR 0 6
58704: PPUSH
58705: CALL_OW 266
58709: PUSH
58710: LD_INT 31
58712: PUSH
58713: LD_INT 32
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: IN
58720: NOT
58721: AND
58722: PUSH
58723: LD_VAR 0 6
58727: PPUSH
58728: CALL_OW 313
58732: PUSH
58733: LD_INT 0
58735: EQUAL
58736: OR
58737: IFFALSE 58751
// begin j := i ;
58739: LD_ADDR_VAR 0 7
58743: PUSH
58744: LD_VAR 0 6
58748: ST_TO_ADDR
// break ;
58749: GO 58753
// end ; end ;
58751: GO 58683
58753: POP
58754: POP
// if j then
58755: LD_VAR 0 7
58759: IFFALSE 58777
// ComEnterUnit ( unit , j ) else
58761: LD_VAR 0 3
58765: PPUSH
58766: LD_VAR 0 7
58770: PPUSH
58771: CALL_OW 120
58775: GO 58880
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58777: LD_ADDR_VAR 0 10
58781: PUSH
58782: LD_VAR 0 2
58786: PPUSH
58787: LD_INT 2
58789: PUSH
58790: LD_INT 30
58792: PUSH
58793: LD_INT 0
58795: PUSH
58796: EMPTY
58797: LIST
58798: LIST
58799: PUSH
58800: LD_INT 30
58802: PUSH
58803: LD_INT 1
58805: PUSH
58806: EMPTY
58807: LIST
58808: LIST
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: LIST
58814: PPUSH
58815: CALL_OW 72
58819: ST_TO_ADDR
// if depot then
58820: LD_VAR 0 10
58824: IFFALSE 58880
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58826: LD_ADDR_VAR 0 10
58830: PUSH
58831: LD_VAR 0 10
58835: PPUSH
58836: LD_VAR 0 3
58840: PPUSH
58841: CALL_OW 74
58845: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58846: LD_VAR 0 3
58850: PPUSH
58851: LD_VAR 0 10
58855: PPUSH
58856: CALL_OW 296
58860: PUSH
58861: LD_INT 10
58863: GREATER
58864: IFFALSE 58880
// ComStandNearbyBuilding ( unit , depot ) ;
58866: LD_VAR 0 3
58870: PPUSH
58871: LD_VAR 0 10
58875: PPUSH
58876: CALL 67480 0 2
// end ; end ; end ;
58880: LD_VAR 0 5
58884: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58885: LD_INT 0
58887: PPUSH
58888: PPUSH
58889: PPUSH
58890: PPUSH
// if not mc_bases then
58891: LD_EXP 117
58895: NOT
58896: IFFALSE 58900
// exit ;
58898: GO 59139
// for i = 1 to mc_bases do
58900: LD_ADDR_VAR 0 2
58904: PUSH
58905: DOUBLE
58906: LD_INT 1
58908: DEC
58909: ST_TO_ADDR
58910: LD_EXP 117
58914: PUSH
58915: FOR_TO
58916: IFFALSE 59137
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58918: LD_ADDR_VAR 0 4
58922: PUSH
58923: LD_EXP 117
58927: PUSH
58928: LD_VAR 0 2
58932: ARRAY
58933: PPUSH
58934: LD_INT 21
58936: PUSH
58937: LD_INT 1
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: PPUSH
58944: CALL_OW 72
58948: PUSH
58949: LD_EXP 146
58953: PUSH
58954: LD_VAR 0 2
58958: ARRAY
58959: UNION
58960: ST_TO_ADDR
// if not tmp then
58961: LD_VAR 0 4
58965: NOT
58966: IFFALSE 58970
// continue ;
58968: GO 58915
// for j in tmp do
58970: LD_ADDR_VAR 0 3
58974: PUSH
58975: LD_VAR 0 4
58979: PUSH
58980: FOR_IN
58981: IFFALSE 59133
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58983: LD_VAR 0 3
58987: PPUSH
58988: CALL_OW 110
58992: NOT
58993: PUSH
58994: LD_VAR 0 3
58998: PPUSH
58999: CALL_OW 314
59003: NOT
59004: AND
59005: PUSH
59006: LD_VAR 0 3
59010: PPUSH
59011: CALL_OW 311
59015: NOT
59016: AND
59017: PUSH
59018: LD_VAR 0 3
59022: PPUSH
59023: CALL_OW 310
59027: NOT
59028: AND
59029: PUSH
59030: LD_VAR 0 3
59034: PUSH
59035: LD_EXP 120
59039: PUSH
59040: LD_VAR 0 2
59044: ARRAY
59045: PUSH
59046: LD_INT 1
59048: ARRAY
59049: IN
59050: NOT
59051: AND
59052: PUSH
59053: LD_VAR 0 3
59057: PUSH
59058: LD_EXP 120
59062: PUSH
59063: LD_VAR 0 2
59067: ARRAY
59068: PUSH
59069: LD_INT 2
59071: ARRAY
59072: IN
59073: NOT
59074: AND
59075: PUSH
59076: LD_VAR 0 3
59080: PUSH
59081: LD_EXP 129
59085: PUSH
59086: LD_VAR 0 2
59090: ARRAY
59091: IN
59092: NOT
59093: AND
59094: IFFALSE 59131
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59096: LD_VAR 0 2
59100: PPUSH
59101: LD_EXP 117
59105: PUSH
59106: LD_VAR 0 2
59110: ARRAY
59111: PPUSH
59112: LD_VAR 0 3
59116: PPUSH
59117: LD_VAR 0 3
59121: PPUSH
59122: CALL_OW 257
59126: PPUSH
59127: CALL 57903 0 4
// end ;
59131: GO 58980
59133: POP
59134: POP
// end ;
59135: GO 58915
59137: POP
59138: POP
// end ;
59139: LD_VAR 0 1
59143: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59144: LD_INT 0
59146: PPUSH
59147: PPUSH
59148: PPUSH
59149: PPUSH
59150: PPUSH
59151: PPUSH
// if not mc_bases [ base ] then
59152: LD_EXP 117
59156: PUSH
59157: LD_VAR 0 1
59161: ARRAY
59162: NOT
59163: IFFALSE 59167
// exit ;
59165: GO 59349
// tmp := [ ] ;
59167: LD_ADDR_VAR 0 6
59171: PUSH
59172: EMPTY
59173: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59174: LD_ADDR_VAR 0 7
59178: PUSH
59179: LD_VAR 0 3
59183: PPUSH
59184: LD_INT 0
59186: PPUSH
59187: CALL_OW 517
59191: ST_TO_ADDR
// if not list then
59192: LD_VAR 0 7
59196: NOT
59197: IFFALSE 59201
// exit ;
59199: GO 59349
// for i = 1 to amount do
59201: LD_ADDR_VAR 0 5
59205: PUSH
59206: DOUBLE
59207: LD_INT 1
59209: DEC
59210: ST_TO_ADDR
59211: LD_VAR 0 2
59215: PUSH
59216: FOR_TO
59217: IFFALSE 59297
// begin x := rand ( 1 , list [ 1 ] ) ;
59219: LD_ADDR_VAR 0 8
59223: PUSH
59224: LD_INT 1
59226: PPUSH
59227: LD_VAR 0 7
59231: PUSH
59232: LD_INT 1
59234: ARRAY
59235: PPUSH
59236: CALL_OW 12
59240: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59241: LD_ADDR_VAR 0 6
59245: PUSH
59246: LD_VAR 0 6
59250: PPUSH
59251: LD_VAR 0 5
59255: PPUSH
59256: LD_VAR 0 7
59260: PUSH
59261: LD_INT 1
59263: ARRAY
59264: PUSH
59265: LD_VAR 0 8
59269: ARRAY
59270: PUSH
59271: LD_VAR 0 7
59275: PUSH
59276: LD_INT 2
59278: ARRAY
59279: PUSH
59280: LD_VAR 0 8
59284: ARRAY
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: PPUSH
59290: CALL_OW 1
59294: ST_TO_ADDR
// end ;
59295: GO 59216
59297: POP
59298: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59299: LD_ADDR_EXP 130
59303: PUSH
59304: LD_EXP 130
59308: PPUSH
59309: LD_VAR 0 1
59313: PPUSH
59314: LD_VAR 0 6
59318: PPUSH
59319: CALL_OW 1
59323: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59324: LD_ADDR_EXP 132
59328: PUSH
59329: LD_EXP 132
59333: PPUSH
59334: LD_VAR 0 1
59338: PPUSH
59339: LD_VAR 0 3
59343: PPUSH
59344: CALL_OW 1
59348: ST_TO_ADDR
// end ;
59349: LD_VAR 0 4
59353: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59354: LD_INT 0
59356: PPUSH
// if not mc_bases [ base ] then
59357: LD_EXP 117
59361: PUSH
59362: LD_VAR 0 1
59366: ARRAY
59367: NOT
59368: IFFALSE 59372
// exit ;
59370: GO 59397
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59372: LD_ADDR_EXP 122
59376: PUSH
59377: LD_EXP 122
59381: PPUSH
59382: LD_VAR 0 1
59386: PPUSH
59387: LD_VAR 0 2
59391: PPUSH
59392: CALL_OW 1
59396: ST_TO_ADDR
// end ;
59397: LD_VAR 0 3
59401: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59402: LD_INT 0
59404: PPUSH
// if not mc_bases [ base ] then
59405: LD_EXP 117
59409: PUSH
59410: LD_VAR 0 1
59414: ARRAY
59415: NOT
59416: IFFALSE 59420
// exit ;
59418: GO 59457
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59420: LD_ADDR_EXP 122
59424: PUSH
59425: LD_EXP 122
59429: PPUSH
59430: LD_VAR 0 1
59434: PPUSH
59435: LD_EXP 122
59439: PUSH
59440: LD_VAR 0 1
59444: ARRAY
59445: PUSH
59446: LD_VAR 0 2
59450: UNION
59451: PPUSH
59452: CALL_OW 1
59456: ST_TO_ADDR
// end ;
59457: LD_VAR 0 3
59461: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59462: LD_INT 0
59464: PPUSH
// if not mc_bases [ base ] then
59465: LD_EXP 117
59469: PUSH
59470: LD_VAR 0 1
59474: ARRAY
59475: NOT
59476: IFFALSE 59480
// exit ;
59478: GO 59505
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59480: LD_ADDR_EXP 138
59484: PUSH
59485: LD_EXP 138
59489: PPUSH
59490: LD_VAR 0 1
59494: PPUSH
59495: LD_VAR 0 2
59499: PPUSH
59500: CALL_OW 1
59504: ST_TO_ADDR
// end ;
59505: LD_VAR 0 3
59509: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59510: LD_INT 0
59512: PPUSH
// if not mc_bases [ base ] then
59513: LD_EXP 117
59517: PUSH
59518: LD_VAR 0 1
59522: ARRAY
59523: NOT
59524: IFFALSE 59528
// exit ;
59526: GO 59565
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59528: LD_ADDR_EXP 138
59532: PUSH
59533: LD_EXP 138
59537: PPUSH
59538: LD_VAR 0 1
59542: PPUSH
59543: LD_EXP 138
59547: PUSH
59548: LD_VAR 0 1
59552: ARRAY
59553: PUSH
59554: LD_VAR 0 2
59558: ADD
59559: PPUSH
59560: CALL_OW 1
59564: ST_TO_ADDR
// end ;
59565: LD_VAR 0 3
59569: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59570: LD_INT 0
59572: PPUSH
// if not mc_bases [ base ] then
59573: LD_EXP 117
59577: PUSH
59578: LD_VAR 0 1
59582: ARRAY
59583: NOT
59584: IFFALSE 59588
// exit ;
59586: GO 59642
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59588: LD_ADDR_EXP 139
59592: PUSH
59593: LD_EXP 139
59597: PPUSH
59598: LD_VAR 0 1
59602: PPUSH
59603: LD_VAR 0 2
59607: PPUSH
59608: CALL_OW 1
59612: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59613: LD_ADDR_EXP 128
59617: PUSH
59618: LD_EXP 128
59622: PPUSH
59623: LD_VAR 0 1
59627: PPUSH
59628: LD_VAR 0 2
59632: PUSH
59633: LD_INT 0
59635: PLUS
59636: PPUSH
59637: CALL_OW 1
59641: ST_TO_ADDR
// end ;
59642: LD_VAR 0 3
59646: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59647: LD_INT 0
59649: PPUSH
// if not mc_bases [ base ] then
59650: LD_EXP 117
59654: PUSH
59655: LD_VAR 0 1
59659: ARRAY
59660: NOT
59661: IFFALSE 59665
// exit ;
59663: GO 59690
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59665: LD_ADDR_EXP 128
59669: PUSH
59670: LD_EXP 128
59674: PPUSH
59675: LD_VAR 0 1
59679: PPUSH
59680: LD_VAR 0 2
59684: PPUSH
59685: CALL_OW 1
59689: ST_TO_ADDR
// end ;
59690: LD_VAR 0 3
59694: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59695: LD_INT 0
59697: PPUSH
59698: PPUSH
59699: PPUSH
59700: PPUSH
// if not mc_bases [ base ] then
59701: LD_EXP 117
59705: PUSH
59706: LD_VAR 0 1
59710: ARRAY
59711: NOT
59712: IFFALSE 59716
// exit ;
59714: GO 59781
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59716: LD_ADDR_EXP 137
59720: PUSH
59721: LD_EXP 137
59725: PPUSH
59726: LD_VAR 0 1
59730: PUSH
59731: LD_EXP 137
59735: PUSH
59736: LD_VAR 0 1
59740: ARRAY
59741: PUSH
59742: LD_INT 1
59744: PLUS
59745: PUSH
59746: EMPTY
59747: LIST
59748: LIST
59749: PPUSH
59750: LD_VAR 0 1
59754: PUSH
59755: LD_VAR 0 2
59759: PUSH
59760: LD_VAR 0 3
59764: PUSH
59765: LD_VAR 0 4
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: LIST
59774: LIST
59775: PPUSH
59776: CALL 70902 0 3
59780: ST_TO_ADDR
// end ;
59781: LD_VAR 0 5
59785: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59786: LD_INT 0
59788: PPUSH
// if not mc_bases [ base ] then
59789: LD_EXP 117
59793: PUSH
59794: LD_VAR 0 1
59798: ARRAY
59799: NOT
59800: IFFALSE 59804
// exit ;
59802: GO 59829
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59804: LD_ADDR_EXP 154
59808: PUSH
59809: LD_EXP 154
59813: PPUSH
59814: LD_VAR 0 1
59818: PPUSH
59819: LD_VAR 0 2
59823: PPUSH
59824: CALL_OW 1
59828: ST_TO_ADDR
// end ;
59829: LD_VAR 0 3
59833: RET
// export function MC_GetMinesField ( base ) ; begin
59834: LD_INT 0
59836: PPUSH
// result := mc_mines [ base ] ;
59837: LD_ADDR_VAR 0 2
59841: PUSH
59842: LD_EXP 130
59846: PUSH
59847: LD_VAR 0 1
59851: ARRAY
59852: ST_TO_ADDR
// end ;
59853: LD_VAR 0 2
59857: RET
// export function MC_GetProduceList ( base ) ; begin
59858: LD_INT 0
59860: PPUSH
// result := mc_produce [ base ] ;
59861: LD_ADDR_VAR 0 2
59865: PUSH
59866: LD_EXP 138
59870: PUSH
59871: LD_VAR 0 1
59875: ARRAY
59876: ST_TO_ADDR
// end ;
59877: LD_VAR 0 2
59881: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59882: LD_INT 0
59884: PPUSH
59885: PPUSH
// if not mc_bases then
59886: LD_EXP 117
59890: NOT
59891: IFFALSE 59895
// exit ;
59893: GO 59960
// if mc_bases [ base ] then
59895: LD_EXP 117
59899: PUSH
59900: LD_VAR 0 1
59904: ARRAY
59905: IFFALSE 59960
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59907: LD_ADDR_VAR 0 3
59911: PUSH
59912: LD_EXP 117
59916: PUSH
59917: LD_VAR 0 1
59921: ARRAY
59922: PPUSH
59923: LD_INT 30
59925: PUSH
59926: LD_VAR 0 2
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PPUSH
59935: CALL_OW 72
59939: ST_TO_ADDR
// if result then
59940: LD_VAR 0 3
59944: IFFALSE 59960
// result := result [ 1 ] ;
59946: LD_ADDR_VAR 0 3
59950: PUSH
59951: LD_VAR 0 3
59955: PUSH
59956: LD_INT 1
59958: ARRAY
59959: ST_TO_ADDR
// end ; end ;
59960: LD_VAR 0 3
59964: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
// if not mc_bases then
59969: LD_EXP 117
59973: NOT
59974: IFFALSE 59978
// exit ;
59976: GO 60023
// if mc_bases [ base ] then
59978: LD_EXP 117
59982: PUSH
59983: LD_VAR 0 1
59987: ARRAY
59988: IFFALSE 60023
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59990: LD_ADDR_VAR 0 3
59994: PUSH
59995: LD_EXP 117
59999: PUSH
60000: LD_VAR 0 1
60004: ARRAY
60005: PPUSH
60006: LD_INT 30
60008: PUSH
60009: LD_VAR 0 2
60013: PUSH
60014: EMPTY
60015: LIST
60016: LIST
60017: PPUSH
60018: CALL_OW 72
60022: ST_TO_ADDR
// end ;
60023: LD_VAR 0 3
60027: RET
// export function MC_SetTame ( base , area ) ; begin
60028: LD_INT 0
60030: PPUSH
// if not mc_bases or not base then
60031: LD_EXP 117
60035: NOT
60036: PUSH
60037: LD_VAR 0 1
60041: NOT
60042: OR
60043: IFFALSE 60047
// exit ;
60045: GO 60072
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60047: LD_ADDR_EXP 145
60051: PUSH
60052: LD_EXP 145
60056: PPUSH
60057: LD_VAR 0 1
60061: PPUSH
60062: LD_VAR 0 2
60066: PPUSH
60067: CALL_OW 1
60071: ST_TO_ADDR
// end ;
60072: LD_VAR 0 3
60076: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60077: LD_INT 0
60079: PPUSH
60080: PPUSH
// if not mc_bases or not base then
60081: LD_EXP 117
60085: NOT
60086: PUSH
60087: LD_VAR 0 1
60091: NOT
60092: OR
60093: IFFALSE 60097
// exit ;
60095: GO 60199
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60097: LD_ADDR_VAR 0 4
60101: PUSH
60102: LD_EXP 117
60106: PUSH
60107: LD_VAR 0 1
60111: ARRAY
60112: PPUSH
60113: LD_INT 30
60115: PUSH
60116: LD_VAR 0 2
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PPUSH
60125: CALL_OW 72
60129: ST_TO_ADDR
// if not tmp then
60130: LD_VAR 0 4
60134: NOT
60135: IFFALSE 60139
// exit ;
60137: GO 60199
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60139: LD_ADDR_EXP 149
60143: PUSH
60144: LD_EXP 149
60148: PPUSH
60149: LD_VAR 0 1
60153: PPUSH
60154: LD_EXP 149
60158: PUSH
60159: LD_VAR 0 1
60163: ARRAY
60164: PPUSH
60165: LD_EXP 149
60169: PUSH
60170: LD_VAR 0 1
60174: ARRAY
60175: PUSH
60176: LD_INT 1
60178: PLUS
60179: PPUSH
60180: LD_VAR 0 4
60184: PUSH
60185: LD_INT 1
60187: ARRAY
60188: PPUSH
60189: CALL_OW 2
60193: PPUSH
60194: CALL_OW 1
60198: ST_TO_ADDR
// end ;
60199: LD_VAR 0 3
60203: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60204: LD_INT 0
60206: PPUSH
60207: PPUSH
// if not mc_bases or not base or not kinds then
60208: LD_EXP 117
60212: NOT
60213: PUSH
60214: LD_VAR 0 1
60218: NOT
60219: OR
60220: PUSH
60221: LD_VAR 0 2
60225: NOT
60226: OR
60227: IFFALSE 60231
// exit ;
60229: GO 60292
// for i in kinds do
60231: LD_ADDR_VAR 0 4
60235: PUSH
60236: LD_VAR 0 2
60240: PUSH
60241: FOR_IN
60242: IFFALSE 60290
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60244: LD_ADDR_EXP 151
60248: PUSH
60249: LD_EXP 151
60253: PPUSH
60254: LD_VAR 0 1
60258: PUSH
60259: LD_EXP 151
60263: PUSH
60264: LD_VAR 0 1
60268: ARRAY
60269: PUSH
60270: LD_INT 1
60272: PLUS
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PPUSH
60278: LD_VAR 0 4
60282: PPUSH
60283: CALL 70902 0 3
60287: ST_TO_ADDR
60288: GO 60241
60290: POP
60291: POP
// end ;
60292: LD_VAR 0 3
60296: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60297: LD_INT 0
60299: PPUSH
// if not mc_bases or not base or not areas then
60300: LD_EXP 117
60304: NOT
60305: PUSH
60306: LD_VAR 0 1
60310: NOT
60311: OR
60312: PUSH
60313: LD_VAR 0 2
60317: NOT
60318: OR
60319: IFFALSE 60323
// exit ;
60321: GO 60348
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60323: LD_ADDR_EXP 135
60327: PUSH
60328: LD_EXP 135
60332: PPUSH
60333: LD_VAR 0 1
60337: PPUSH
60338: LD_VAR 0 2
60342: PPUSH
60343: CALL_OW 1
60347: ST_TO_ADDR
// end ;
60348: LD_VAR 0 3
60352: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60353: LD_INT 0
60355: PPUSH
// if not mc_bases or not base or not teleports_exit then
60356: LD_EXP 117
60360: NOT
60361: PUSH
60362: LD_VAR 0 1
60366: NOT
60367: OR
60368: PUSH
60369: LD_VAR 0 2
60373: NOT
60374: OR
60375: IFFALSE 60379
// exit ;
60377: GO 60404
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60379: LD_ADDR_EXP 152
60383: PUSH
60384: LD_EXP 152
60388: PPUSH
60389: LD_VAR 0 1
60393: PPUSH
60394: LD_VAR 0 2
60398: PPUSH
60399: CALL_OW 1
60403: ST_TO_ADDR
// end ;
60404: LD_VAR 0 3
60408: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60409: LD_INT 0
60411: PPUSH
60412: PPUSH
60413: PPUSH
// if not mc_bases or not base or not ext_list then
60414: LD_EXP 117
60418: NOT
60419: PUSH
60420: LD_VAR 0 1
60424: NOT
60425: OR
60426: PUSH
60427: LD_VAR 0 5
60431: NOT
60432: OR
60433: IFFALSE 60437
// exit ;
60435: GO 60610
// tmp := GetFacExtXYD ( x , y , d ) ;
60437: LD_ADDR_VAR 0 8
60441: PUSH
60442: LD_VAR 0 2
60446: PPUSH
60447: LD_VAR 0 3
60451: PPUSH
60452: LD_VAR 0 4
60456: PPUSH
60457: CALL 100236 0 3
60461: ST_TO_ADDR
// if not tmp then
60462: LD_VAR 0 8
60466: NOT
60467: IFFALSE 60471
// exit ;
60469: GO 60610
// for i in tmp do
60471: LD_ADDR_VAR 0 7
60475: PUSH
60476: LD_VAR 0 8
60480: PUSH
60481: FOR_IN
60482: IFFALSE 60608
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60484: LD_ADDR_EXP 122
60488: PUSH
60489: LD_EXP 122
60493: PPUSH
60494: LD_VAR 0 1
60498: PPUSH
60499: LD_EXP 122
60503: PUSH
60504: LD_VAR 0 1
60508: ARRAY
60509: PPUSH
60510: LD_EXP 122
60514: PUSH
60515: LD_VAR 0 1
60519: ARRAY
60520: PUSH
60521: LD_INT 1
60523: PLUS
60524: PPUSH
60525: LD_VAR 0 5
60529: PUSH
60530: LD_INT 1
60532: ARRAY
60533: PUSH
60534: LD_VAR 0 7
60538: PUSH
60539: LD_INT 1
60541: ARRAY
60542: PUSH
60543: LD_VAR 0 7
60547: PUSH
60548: LD_INT 2
60550: ARRAY
60551: PUSH
60552: LD_VAR 0 7
60556: PUSH
60557: LD_INT 3
60559: ARRAY
60560: PUSH
60561: EMPTY
60562: LIST
60563: LIST
60564: LIST
60565: LIST
60566: PPUSH
60567: CALL_OW 2
60571: PPUSH
60572: CALL_OW 1
60576: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60577: LD_ADDR_VAR 0 5
60581: PUSH
60582: LD_VAR 0 5
60586: PPUSH
60587: LD_INT 1
60589: PPUSH
60590: CALL_OW 3
60594: ST_TO_ADDR
// if not ext_list then
60595: LD_VAR 0 5
60599: NOT
60600: IFFALSE 60606
// exit ;
60602: POP
60603: POP
60604: GO 60610
// end ;
60606: GO 60481
60608: POP
60609: POP
// end ;
60610: LD_VAR 0 6
60614: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60615: LD_INT 0
60617: PPUSH
// if not mc_bases or not base or not weapon_list then
60618: LD_EXP 117
60622: NOT
60623: PUSH
60624: LD_VAR 0 1
60628: NOT
60629: OR
60630: PUSH
60631: LD_VAR 0 2
60635: NOT
60636: OR
60637: IFFALSE 60641
// exit ;
60639: GO 60666
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60641: LD_ADDR_EXP 156
60645: PUSH
60646: LD_EXP 156
60650: PPUSH
60651: LD_VAR 0 1
60655: PPUSH
60656: LD_VAR 0 2
60660: PPUSH
60661: CALL_OW 1
60665: ST_TO_ADDR
// end ;
60666: LD_VAR 0 3
60670: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60671: LD_INT 0
60673: PPUSH
// if not mc_bases or not base or not tech_list then
60674: LD_EXP 117
60678: NOT
60679: PUSH
60680: LD_VAR 0 1
60684: NOT
60685: OR
60686: PUSH
60687: LD_VAR 0 2
60691: NOT
60692: OR
60693: IFFALSE 60697
// exit ;
60695: GO 60722
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60697: LD_ADDR_EXP 144
60701: PUSH
60702: LD_EXP 144
60706: PPUSH
60707: LD_VAR 0 1
60711: PPUSH
60712: LD_VAR 0 2
60716: PPUSH
60717: CALL_OW 1
60721: ST_TO_ADDR
// end ;
60722: LD_VAR 0 3
60726: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60727: LD_INT 0
60729: PPUSH
// if not mc_bases or not parking_area or not base then
60730: LD_EXP 117
60734: NOT
60735: PUSH
60736: LD_VAR 0 2
60740: NOT
60741: OR
60742: PUSH
60743: LD_VAR 0 1
60747: NOT
60748: OR
60749: IFFALSE 60753
// exit ;
60751: GO 60778
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60753: LD_ADDR_EXP 141
60757: PUSH
60758: LD_EXP 141
60762: PPUSH
60763: LD_VAR 0 1
60767: PPUSH
60768: LD_VAR 0 2
60772: PPUSH
60773: CALL_OW 1
60777: ST_TO_ADDR
// end ;
60778: LD_VAR 0 3
60782: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60783: LD_INT 0
60785: PPUSH
// if not mc_bases or not base or not scan_area then
60786: LD_EXP 117
60790: NOT
60791: PUSH
60792: LD_VAR 0 1
60796: NOT
60797: OR
60798: PUSH
60799: LD_VAR 0 2
60803: NOT
60804: OR
60805: IFFALSE 60809
// exit ;
60807: GO 60834
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60809: LD_ADDR_EXP 142
60813: PUSH
60814: LD_EXP 142
60818: PPUSH
60819: LD_VAR 0 1
60823: PPUSH
60824: LD_VAR 0 2
60828: PPUSH
60829: CALL_OW 1
60833: ST_TO_ADDR
// end ;
60834: LD_VAR 0 3
60838: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60839: LD_INT 0
60841: PPUSH
60842: PPUSH
// if not mc_bases or not base then
60843: LD_EXP 117
60847: NOT
60848: PUSH
60849: LD_VAR 0 1
60853: NOT
60854: OR
60855: IFFALSE 60859
// exit ;
60857: GO 60923
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60859: LD_ADDR_VAR 0 3
60863: PUSH
60864: LD_INT 1
60866: PUSH
60867: LD_INT 2
60869: PUSH
60870: LD_INT 3
60872: PUSH
60873: LD_INT 4
60875: PUSH
60876: LD_INT 11
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60886: LD_ADDR_EXP 144
60890: PUSH
60891: LD_EXP 144
60895: PPUSH
60896: LD_VAR 0 1
60900: PPUSH
60901: LD_EXP 144
60905: PUSH
60906: LD_VAR 0 1
60910: ARRAY
60911: PUSH
60912: LD_VAR 0 3
60916: DIFF
60917: PPUSH
60918: CALL_OW 1
60922: ST_TO_ADDR
// end ;
60923: LD_VAR 0 2
60927: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60928: LD_INT 0
60930: PPUSH
// result := mc_vehicles [ base ] ;
60931: LD_ADDR_VAR 0 3
60935: PUSH
60936: LD_EXP 136
60940: PUSH
60941: LD_VAR 0 1
60945: ARRAY
60946: ST_TO_ADDR
// if onlyCombat then
60947: LD_VAR 0 2
60951: IFFALSE 61129
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60953: LD_ADDR_VAR 0 3
60957: PUSH
60958: LD_VAR 0 3
60962: PUSH
60963: LD_VAR 0 3
60967: PPUSH
60968: LD_INT 2
60970: PUSH
60971: LD_INT 34
60973: PUSH
60974: LD_INT 12
60976: PUSH
60977: EMPTY
60978: LIST
60979: LIST
60980: PUSH
60981: LD_INT 34
60983: PUSH
60984: LD_INT 51
60986: PUSH
60987: EMPTY
60988: LIST
60989: LIST
60990: PUSH
60991: LD_INT 34
60993: PUSH
60994: LD_EXP 96
60998: PUSH
60999: EMPTY
61000: LIST
61001: LIST
61002: PUSH
61003: LD_INT 34
61005: PUSH
61006: LD_INT 32
61008: PUSH
61009: EMPTY
61010: LIST
61011: LIST
61012: PUSH
61013: LD_INT 34
61015: PUSH
61016: LD_INT 13
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: LD_INT 34
61025: PUSH
61026: LD_INT 52
61028: PUSH
61029: EMPTY
61030: LIST
61031: LIST
61032: PUSH
61033: LD_INT 34
61035: PUSH
61036: LD_EXP 101
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: PUSH
61045: LD_INT 34
61047: PUSH
61048: LD_INT 14
61050: PUSH
61051: EMPTY
61052: LIST
61053: LIST
61054: PUSH
61055: LD_INT 34
61057: PUSH
61058: LD_INT 53
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PUSH
61065: LD_INT 34
61067: PUSH
61068: LD_EXP 95
61072: PUSH
61073: EMPTY
61074: LIST
61075: LIST
61076: PUSH
61077: LD_INT 34
61079: PUSH
61080: LD_INT 31
61082: PUSH
61083: EMPTY
61084: LIST
61085: LIST
61086: PUSH
61087: LD_INT 34
61089: PUSH
61090: LD_INT 48
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PUSH
61097: LD_INT 34
61099: PUSH
61100: LD_INT 8
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: PUSH
61107: EMPTY
61108: LIST
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: LIST
61117: LIST
61118: LIST
61119: LIST
61120: LIST
61121: LIST
61122: PPUSH
61123: CALL_OW 72
61127: DIFF
61128: ST_TO_ADDR
// end ; end_of_file
61129: LD_VAR 0 3
61133: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61134: LD_INT 0
61136: PPUSH
61137: PPUSH
61138: PPUSH
// if not mc_bases or not skirmish then
61139: LD_EXP 117
61143: NOT
61144: PUSH
61145: LD_EXP 115
61149: NOT
61150: OR
61151: IFFALSE 61155
// exit ;
61153: GO 61320
// for i = 1 to mc_bases do
61155: LD_ADDR_VAR 0 4
61159: PUSH
61160: DOUBLE
61161: LD_INT 1
61163: DEC
61164: ST_TO_ADDR
61165: LD_EXP 117
61169: PUSH
61170: FOR_TO
61171: IFFALSE 61318
// begin if sci in mc_bases [ i ] then
61173: LD_VAR 0 2
61177: PUSH
61178: LD_EXP 117
61182: PUSH
61183: LD_VAR 0 4
61187: ARRAY
61188: IN
61189: IFFALSE 61316
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61191: LD_ADDR_EXP 146
61195: PUSH
61196: LD_EXP 146
61200: PPUSH
61201: LD_VAR 0 4
61205: PUSH
61206: LD_EXP 146
61210: PUSH
61211: LD_VAR 0 4
61215: ARRAY
61216: PUSH
61217: LD_INT 1
61219: PLUS
61220: PUSH
61221: EMPTY
61222: LIST
61223: LIST
61224: PPUSH
61225: LD_VAR 0 1
61229: PPUSH
61230: CALL 70902 0 3
61234: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61235: LD_ADDR_VAR 0 5
61239: PUSH
61240: LD_EXP 117
61244: PUSH
61245: LD_VAR 0 4
61249: ARRAY
61250: PPUSH
61251: LD_INT 2
61253: PUSH
61254: LD_INT 30
61256: PUSH
61257: LD_INT 0
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 30
61266: PUSH
61267: LD_INT 1
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: LIST
61278: PPUSH
61279: CALL_OW 72
61283: PPUSH
61284: LD_VAR 0 1
61288: PPUSH
61289: CALL_OW 74
61293: ST_TO_ADDR
// if tmp then
61294: LD_VAR 0 5
61298: IFFALSE 61314
// ComStandNearbyBuilding ( ape , tmp ) ;
61300: LD_VAR 0 1
61304: PPUSH
61305: LD_VAR 0 5
61309: PPUSH
61310: CALL 67480 0 2
// break ;
61314: GO 61318
// end ; end ;
61316: GO 61170
61318: POP
61319: POP
// end ;
61320: LD_VAR 0 3
61324: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61325: LD_INT 0
61327: PPUSH
61328: PPUSH
61329: PPUSH
// if not mc_bases or not skirmish then
61330: LD_EXP 117
61334: NOT
61335: PUSH
61336: LD_EXP 115
61340: NOT
61341: OR
61342: IFFALSE 61346
// exit ;
61344: GO 61435
// for i = 1 to mc_bases do
61346: LD_ADDR_VAR 0 4
61350: PUSH
61351: DOUBLE
61352: LD_INT 1
61354: DEC
61355: ST_TO_ADDR
61356: LD_EXP 117
61360: PUSH
61361: FOR_TO
61362: IFFALSE 61433
// begin if building in mc_busy_turret_list [ i ] then
61364: LD_VAR 0 1
61368: PUSH
61369: LD_EXP 127
61373: PUSH
61374: LD_VAR 0 4
61378: ARRAY
61379: IN
61380: IFFALSE 61431
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61382: LD_ADDR_VAR 0 5
61386: PUSH
61387: LD_EXP 127
61391: PUSH
61392: LD_VAR 0 4
61396: ARRAY
61397: PUSH
61398: LD_VAR 0 1
61402: DIFF
61403: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61404: LD_ADDR_EXP 127
61408: PUSH
61409: LD_EXP 127
61413: PPUSH
61414: LD_VAR 0 4
61418: PPUSH
61419: LD_VAR 0 5
61423: PPUSH
61424: CALL_OW 1
61428: ST_TO_ADDR
// break ;
61429: GO 61433
// end ; end ;
61431: GO 61361
61433: POP
61434: POP
// end ;
61435: LD_VAR 0 3
61439: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61440: LD_INT 0
61442: PPUSH
61443: PPUSH
61444: PPUSH
// if not mc_bases or not skirmish then
61445: LD_EXP 117
61449: NOT
61450: PUSH
61451: LD_EXP 115
61455: NOT
61456: OR
61457: IFFALSE 61461
// exit ;
61459: GO 61660
// for i = 1 to mc_bases do
61461: LD_ADDR_VAR 0 5
61465: PUSH
61466: DOUBLE
61467: LD_INT 1
61469: DEC
61470: ST_TO_ADDR
61471: LD_EXP 117
61475: PUSH
61476: FOR_TO
61477: IFFALSE 61658
// if building in mc_bases [ i ] then
61479: LD_VAR 0 1
61483: PUSH
61484: LD_EXP 117
61488: PUSH
61489: LD_VAR 0 5
61493: ARRAY
61494: IN
61495: IFFALSE 61656
// begin tmp := mc_bases [ i ] diff building ;
61497: LD_ADDR_VAR 0 6
61501: PUSH
61502: LD_EXP 117
61506: PUSH
61507: LD_VAR 0 5
61511: ARRAY
61512: PUSH
61513: LD_VAR 0 1
61517: DIFF
61518: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61519: LD_ADDR_EXP 117
61523: PUSH
61524: LD_EXP 117
61528: PPUSH
61529: LD_VAR 0 5
61533: PPUSH
61534: LD_VAR 0 6
61538: PPUSH
61539: CALL_OW 1
61543: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61544: LD_VAR 0 1
61548: PUSH
61549: LD_EXP 125
61553: PUSH
61554: LD_VAR 0 5
61558: ARRAY
61559: IN
61560: IFFALSE 61599
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61562: LD_ADDR_EXP 125
61566: PUSH
61567: LD_EXP 125
61571: PPUSH
61572: LD_VAR 0 5
61576: PPUSH
61577: LD_EXP 125
61581: PUSH
61582: LD_VAR 0 5
61586: ARRAY
61587: PUSH
61588: LD_VAR 0 1
61592: DIFF
61593: PPUSH
61594: CALL_OW 1
61598: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61599: LD_VAR 0 1
61603: PUSH
61604: LD_EXP 126
61608: PUSH
61609: LD_VAR 0 5
61613: ARRAY
61614: IN
61615: IFFALSE 61654
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61617: LD_ADDR_EXP 126
61621: PUSH
61622: LD_EXP 126
61626: PPUSH
61627: LD_VAR 0 5
61631: PPUSH
61632: LD_EXP 126
61636: PUSH
61637: LD_VAR 0 5
61641: ARRAY
61642: PUSH
61643: LD_VAR 0 1
61647: DIFF
61648: PPUSH
61649: CALL_OW 1
61653: ST_TO_ADDR
// break ;
61654: GO 61658
// end ;
61656: GO 61476
61658: POP
61659: POP
// end ;
61660: LD_VAR 0 4
61664: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61665: LD_INT 0
61667: PPUSH
61668: PPUSH
61669: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61670: LD_EXP 117
61674: NOT
61675: PUSH
61676: LD_EXP 115
61680: NOT
61681: OR
61682: PUSH
61683: LD_VAR 0 3
61687: PUSH
61688: LD_EXP 143
61692: IN
61693: NOT
61694: OR
61695: IFFALSE 61699
// exit ;
61697: GO 61822
// for i = 1 to mc_vehicles do
61699: LD_ADDR_VAR 0 6
61703: PUSH
61704: DOUBLE
61705: LD_INT 1
61707: DEC
61708: ST_TO_ADDR
61709: LD_EXP 136
61713: PUSH
61714: FOR_TO
61715: IFFALSE 61820
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61717: LD_VAR 0 2
61721: PUSH
61722: LD_EXP 136
61726: PUSH
61727: LD_VAR 0 6
61731: ARRAY
61732: IN
61733: PUSH
61734: LD_VAR 0 1
61738: PUSH
61739: LD_EXP 136
61743: PUSH
61744: LD_VAR 0 6
61748: ARRAY
61749: IN
61750: OR
61751: IFFALSE 61818
// begin tmp := mc_vehicles [ i ] diff old ;
61753: LD_ADDR_VAR 0 7
61757: PUSH
61758: LD_EXP 136
61762: PUSH
61763: LD_VAR 0 6
61767: ARRAY
61768: PUSH
61769: LD_VAR 0 2
61773: DIFF
61774: ST_TO_ADDR
// tmp := tmp diff new ;
61775: LD_ADDR_VAR 0 7
61779: PUSH
61780: LD_VAR 0 7
61784: PUSH
61785: LD_VAR 0 1
61789: DIFF
61790: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61791: LD_ADDR_EXP 136
61795: PUSH
61796: LD_EXP 136
61800: PPUSH
61801: LD_VAR 0 6
61805: PPUSH
61806: LD_VAR 0 7
61810: PPUSH
61811: CALL_OW 1
61815: ST_TO_ADDR
// break ;
61816: GO 61820
// end ;
61818: GO 61714
61820: POP
61821: POP
// end ;
61822: LD_VAR 0 5
61826: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61827: LD_INT 0
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
// if not mc_bases or not skirmish then
61833: LD_EXP 117
61837: NOT
61838: PUSH
61839: LD_EXP 115
61843: NOT
61844: OR
61845: IFFALSE 61849
// exit ;
61847: GO 62241
// side := GetSide ( vehicle ) ;
61849: LD_ADDR_VAR 0 5
61853: PUSH
61854: LD_VAR 0 1
61858: PPUSH
61859: CALL_OW 255
61863: ST_TO_ADDR
// for i = 1 to mc_bases do
61864: LD_ADDR_VAR 0 4
61868: PUSH
61869: DOUBLE
61870: LD_INT 1
61872: DEC
61873: ST_TO_ADDR
61874: LD_EXP 117
61878: PUSH
61879: FOR_TO
61880: IFFALSE 62239
// begin if factory in mc_bases [ i ] then
61882: LD_VAR 0 2
61886: PUSH
61887: LD_EXP 117
61891: PUSH
61892: LD_VAR 0 4
61896: ARRAY
61897: IN
61898: IFFALSE 62237
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61900: LD_EXP 139
61904: PUSH
61905: LD_VAR 0 4
61909: ARRAY
61910: PUSH
61911: LD_EXP 128
61915: PUSH
61916: LD_VAR 0 4
61920: ARRAY
61921: LESS
61922: PUSH
61923: LD_VAR 0 1
61927: PPUSH
61928: CALL_OW 264
61932: PUSH
61933: LD_INT 31
61935: PUSH
61936: LD_INT 32
61938: PUSH
61939: LD_INT 51
61941: PUSH
61942: LD_EXP 96
61946: PUSH
61947: LD_INT 12
61949: PUSH
61950: LD_INT 30
61952: PUSH
61953: LD_EXP 95
61957: PUSH
61958: LD_INT 11
61960: PUSH
61961: LD_INT 53
61963: PUSH
61964: LD_INT 14
61966: PUSH
61967: LD_EXP 99
61971: PUSH
61972: LD_INT 29
61974: PUSH
61975: LD_EXP 97
61979: PUSH
61980: LD_INT 13
61982: PUSH
61983: LD_INT 52
61985: PUSH
61986: LD_EXP 101
61990: PUSH
61991: LD_INT 48
61993: PUSH
61994: LD_INT 8
61996: PUSH
61997: EMPTY
61998: LIST
61999: LIST
62000: LIST
62001: LIST
62002: LIST
62003: LIST
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: LIST
62011: LIST
62012: LIST
62013: LIST
62014: LIST
62015: LIST
62016: IN
62017: NOT
62018: AND
62019: IFFALSE 62067
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
62021: LD_ADDR_EXP 139
62025: PUSH
62026: LD_EXP 139
62030: PPUSH
62031: LD_VAR 0 4
62035: PUSH
62036: LD_EXP 139
62040: PUSH
62041: LD_VAR 0 4
62045: ARRAY
62046: PUSH
62047: LD_INT 1
62049: PLUS
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: PPUSH
62055: LD_VAR 0 1
62059: PPUSH
62060: CALL 70902 0 3
62064: ST_TO_ADDR
62065: GO 62111
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62067: LD_ADDR_EXP 136
62071: PUSH
62072: LD_EXP 136
62076: PPUSH
62077: LD_VAR 0 4
62081: PUSH
62082: LD_EXP 136
62086: PUSH
62087: LD_VAR 0 4
62091: ARRAY
62092: PUSH
62093: LD_INT 1
62095: PLUS
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PPUSH
62101: LD_VAR 0 1
62105: PPUSH
62106: CALL 70902 0 3
62110: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62111: LD_VAR 0 1
62115: PPUSH
62116: CALL_OW 263
62120: PUSH
62121: LD_INT 2
62123: EQUAL
62124: IFFALSE 62153
// begin repeat wait ( 0 0$3 ) ;
62126: LD_INT 105
62128: PPUSH
62129: CALL_OW 67
// Connect ( vehicle ) ;
62133: LD_VAR 0 1
62137: PPUSH
62138: CALL 73873 0 1
// until IsControledBy ( vehicle ) ;
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 312
62151: IFFALSE 62126
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62153: LD_VAR 0 1
62157: PPUSH
62158: LD_EXP 141
62162: PUSH
62163: LD_VAR 0 4
62167: ARRAY
62168: PPUSH
62169: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62173: LD_VAR 0 1
62177: PPUSH
62178: CALL_OW 263
62182: PUSH
62183: LD_INT 1
62185: NONEQUAL
62186: IFFALSE 62190
// break ;
62188: GO 62239
// repeat wait ( 0 0$1 ) ;
62190: LD_INT 35
62192: PPUSH
62193: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62197: LD_VAR 0 1
62201: PPUSH
62202: LD_EXP 141
62206: PUSH
62207: LD_VAR 0 4
62211: ARRAY
62212: PPUSH
62213: CALL_OW 308
62217: IFFALSE 62190
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62219: LD_VAR 0 1
62223: PPUSH
62224: CALL_OW 311
62228: PPUSH
62229: CALL_OW 121
// exit ;
62233: POP
62234: POP
62235: GO 62241
// end ; end ;
62237: GO 61879
62239: POP
62240: POP
// end ;
62241: LD_VAR 0 3
62245: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62246: LD_INT 0
62248: PPUSH
62249: PPUSH
62250: PPUSH
62251: PPUSH
// if not mc_bases or not skirmish then
62252: LD_EXP 117
62256: NOT
62257: PUSH
62258: LD_EXP 115
62262: NOT
62263: OR
62264: IFFALSE 62268
// exit ;
62266: GO 62621
// repeat wait ( 0 0$1 ) ;
62268: LD_INT 35
62270: PPUSH
62271: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62275: LD_VAR 0 2
62279: PPUSH
62280: LD_VAR 0 3
62284: PPUSH
62285: CALL_OW 284
62289: IFFALSE 62268
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62291: LD_VAR 0 2
62295: PPUSH
62296: LD_VAR 0 3
62300: PPUSH
62301: CALL_OW 283
62305: PUSH
62306: LD_INT 4
62308: EQUAL
62309: IFFALSE 62313
// exit ;
62311: GO 62621
// for i = 1 to mc_bases do
62313: LD_ADDR_VAR 0 7
62317: PUSH
62318: DOUBLE
62319: LD_INT 1
62321: DEC
62322: ST_TO_ADDR
62323: LD_EXP 117
62327: PUSH
62328: FOR_TO
62329: IFFALSE 62619
// begin if mc_crates_area [ i ] then
62331: LD_EXP 135
62335: PUSH
62336: LD_VAR 0 7
62340: ARRAY
62341: IFFALSE 62452
// for j in mc_crates_area [ i ] do
62343: LD_ADDR_VAR 0 8
62347: PUSH
62348: LD_EXP 135
62352: PUSH
62353: LD_VAR 0 7
62357: ARRAY
62358: PUSH
62359: FOR_IN
62360: IFFALSE 62450
// if InArea ( x , y , j ) then
62362: LD_VAR 0 2
62366: PPUSH
62367: LD_VAR 0 3
62371: PPUSH
62372: LD_VAR 0 8
62376: PPUSH
62377: CALL_OW 309
62381: IFFALSE 62448
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62383: LD_ADDR_EXP 133
62387: PUSH
62388: LD_EXP 133
62392: PPUSH
62393: LD_VAR 0 7
62397: PUSH
62398: LD_EXP 133
62402: PUSH
62403: LD_VAR 0 7
62407: ARRAY
62408: PUSH
62409: LD_INT 1
62411: PLUS
62412: PUSH
62413: EMPTY
62414: LIST
62415: LIST
62416: PPUSH
62417: LD_VAR 0 4
62421: PUSH
62422: LD_VAR 0 2
62426: PUSH
62427: LD_VAR 0 3
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: LIST
62436: PPUSH
62437: CALL 70902 0 3
62441: ST_TO_ADDR
// exit ;
62442: POP
62443: POP
62444: POP
62445: POP
62446: GO 62621
// end ;
62448: GO 62359
62450: POP
62451: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62452: LD_ADDR_VAR 0 9
62456: PUSH
62457: LD_EXP 117
62461: PUSH
62462: LD_VAR 0 7
62466: ARRAY
62467: PPUSH
62468: LD_INT 2
62470: PUSH
62471: LD_INT 30
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 30
62483: PUSH
62484: LD_INT 1
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: LIST
62495: PPUSH
62496: CALL_OW 72
62500: ST_TO_ADDR
// if not depot then
62501: LD_VAR 0 9
62505: NOT
62506: IFFALSE 62510
// continue ;
62508: GO 62328
// for j in depot do
62510: LD_ADDR_VAR 0 8
62514: PUSH
62515: LD_VAR 0 9
62519: PUSH
62520: FOR_IN
62521: IFFALSE 62615
// if GetDistUnitXY ( j , x , y ) < 30 then
62523: LD_VAR 0 8
62527: PPUSH
62528: LD_VAR 0 2
62532: PPUSH
62533: LD_VAR 0 3
62537: PPUSH
62538: CALL_OW 297
62542: PUSH
62543: LD_INT 30
62545: LESS
62546: IFFALSE 62613
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62548: LD_ADDR_EXP 133
62552: PUSH
62553: LD_EXP 133
62557: PPUSH
62558: LD_VAR 0 7
62562: PUSH
62563: LD_EXP 133
62567: PUSH
62568: LD_VAR 0 7
62572: ARRAY
62573: PUSH
62574: LD_INT 1
62576: PLUS
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: PPUSH
62582: LD_VAR 0 4
62586: PUSH
62587: LD_VAR 0 2
62591: PUSH
62592: LD_VAR 0 3
62596: PUSH
62597: EMPTY
62598: LIST
62599: LIST
62600: LIST
62601: PPUSH
62602: CALL 70902 0 3
62606: ST_TO_ADDR
// exit ;
62607: POP
62608: POP
62609: POP
62610: POP
62611: GO 62621
// end ;
62613: GO 62520
62615: POP
62616: POP
// end ;
62617: GO 62328
62619: POP
62620: POP
// end ;
62621: LD_VAR 0 6
62625: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62626: LD_INT 0
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
// if not mc_bases or not skirmish then
62632: LD_EXP 117
62636: NOT
62637: PUSH
62638: LD_EXP 115
62642: NOT
62643: OR
62644: IFFALSE 62648
// exit ;
62646: GO 62925
// side := GetSide ( lab ) ;
62648: LD_ADDR_VAR 0 4
62652: PUSH
62653: LD_VAR 0 2
62657: PPUSH
62658: CALL_OW 255
62662: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62663: LD_VAR 0 4
62667: PUSH
62668: LD_EXP 143
62672: IN
62673: NOT
62674: PUSH
62675: LD_EXP 144
62679: NOT
62680: OR
62681: PUSH
62682: LD_EXP 117
62686: NOT
62687: OR
62688: IFFALSE 62692
// exit ;
62690: GO 62925
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62692: LD_ADDR_EXP 144
62696: PUSH
62697: LD_EXP 144
62701: PPUSH
62702: LD_VAR 0 4
62706: PPUSH
62707: LD_EXP 144
62711: PUSH
62712: LD_VAR 0 4
62716: ARRAY
62717: PUSH
62718: LD_VAR 0 1
62722: DIFF
62723: PPUSH
62724: CALL_OW 1
62728: ST_TO_ADDR
// for i = 1 to mc_bases do
62729: LD_ADDR_VAR 0 5
62733: PUSH
62734: DOUBLE
62735: LD_INT 1
62737: DEC
62738: ST_TO_ADDR
62739: LD_EXP 117
62743: PUSH
62744: FOR_TO
62745: IFFALSE 62923
// begin if lab in mc_bases [ i ] then
62747: LD_VAR 0 2
62751: PUSH
62752: LD_EXP 117
62756: PUSH
62757: LD_VAR 0 5
62761: ARRAY
62762: IN
62763: IFFALSE 62921
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62765: LD_VAR 0 1
62769: PUSH
62770: LD_INT 11
62772: PUSH
62773: LD_INT 4
62775: PUSH
62776: LD_INT 3
62778: PUSH
62779: LD_INT 2
62781: PUSH
62782: EMPTY
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: IN
62788: PUSH
62789: LD_EXP 147
62793: PUSH
62794: LD_VAR 0 5
62798: ARRAY
62799: AND
62800: IFFALSE 62921
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62802: LD_ADDR_VAR 0 6
62806: PUSH
62807: LD_EXP 147
62811: PUSH
62812: LD_VAR 0 5
62816: ARRAY
62817: PUSH
62818: LD_INT 1
62820: ARRAY
62821: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62822: LD_ADDR_EXP 147
62826: PUSH
62827: LD_EXP 147
62831: PPUSH
62832: LD_VAR 0 5
62836: PPUSH
62837: EMPTY
62838: PPUSH
62839: CALL_OW 1
62843: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62844: LD_VAR 0 6
62848: PPUSH
62849: LD_INT 0
62851: PPUSH
62852: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62856: LD_VAR 0 6
62860: PPUSH
62861: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62865: LD_ADDR_EXP 146
62869: PUSH
62870: LD_EXP 146
62874: PPUSH
62875: LD_VAR 0 5
62879: PPUSH
62880: LD_EXP 146
62884: PUSH
62885: LD_VAR 0 5
62889: ARRAY
62890: PPUSH
62891: LD_INT 1
62893: PPUSH
62894: LD_VAR 0 6
62898: PPUSH
62899: CALL_OW 2
62903: PPUSH
62904: CALL_OW 1
62908: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62909: LD_VAR 0 5
62913: PPUSH
62914: LD_INT 112
62916: PPUSH
62917: CALL 39444 0 2
// end ; end ; end ;
62921: GO 62744
62923: POP
62924: POP
// end ;
62925: LD_VAR 0 3
62929: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62930: LD_INT 0
62932: PPUSH
62933: PPUSH
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
62938: PPUSH
62939: PPUSH
// if not mc_bases or not skirmish then
62940: LD_EXP 117
62944: NOT
62945: PUSH
62946: LD_EXP 115
62950: NOT
62951: OR
62952: IFFALSE 62956
// exit ;
62954: GO 64327
// for i = 1 to mc_bases do
62956: LD_ADDR_VAR 0 3
62960: PUSH
62961: DOUBLE
62962: LD_INT 1
62964: DEC
62965: ST_TO_ADDR
62966: LD_EXP 117
62970: PUSH
62971: FOR_TO
62972: IFFALSE 64325
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62974: LD_VAR 0 1
62978: PUSH
62979: LD_EXP 117
62983: PUSH
62984: LD_VAR 0 3
62988: ARRAY
62989: IN
62990: PUSH
62991: LD_VAR 0 1
62995: PUSH
62996: LD_EXP 124
63000: PUSH
63001: LD_VAR 0 3
63005: ARRAY
63006: IN
63007: OR
63008: PUSH
63009: LD_VAR 0 1
63013: PUSH
63014: LD_EXP 139
63018: PUSH
63019: LD_VAR 0 3
63023: ARRAY
63024: IN
63025: OR
63026: PUSH
63027: LD_VAR 0 1
63031: PUSH
63032: LD_EXP 136
63036: PUSH
63037: LD_VAR 0 3
63041: ARRAY
63042: IN
63043: OR
63044: PUSH
63045: LD_VAR 0 1
63049: PUSH
63050: LD_EXP 146
63054: PUSH
63055: LD_VAR 0 3
63059: ARRAY
63060: IN
63061: OR
63062: PUSH
63063: LD_VAR 0 1
63067: PUSH
63068: LD_EXP 147
63072: PUSH
63073: LD_VAR 0 3
63077: ARRAY
63078: IN
63079: OR
63080: IFFALSE 64323
// begin if un in mc_ape [ i ] then
63082: LD_VAR 0 1
63086: PUSH
63087: LD_EXP 146
63091: PUSH
63092: LD_VAR 0 3
63096: ARRAY
63097: IN
63098: IFFALSE 63137
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63100: LD_ADDR_EXP 146
63104: PUSH
63105: LD_EXP 146
63109: PPUSH
63110: LD_VAR 0 3
63114: PPUSH
63115: LD_EXP 146
63119: PUSH
63120: LD_VAR 0 3
63124: ARRAY
63125: PUSH
63126: LD_VAR 0 1
63130: DIFF
63131: PPUSH
63132: CALL_OW 1
63136: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63137: LD_VAR 0 1
63141: PUSH
63142: LD_EXP 147
63146: PUSH
63147: LD_VAR 0 3
63151: ARRAY
63152: IN
63153: IFFALSE 63177
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63155: LD_ADDR_EXP 147
63159: PUSH
63160: LD_EXP 147
63164: PPUSH
63165: LD_VAR 0 3
63169: PPUSH
63170: EMPTY
63171: PPUSH
63172: CALL_OW 1
63176: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63177: LD_VAR 0 1
63181: PPUSH
63182: CALL_OW 247
63186: PUSH
63187: LD_INT 2
63189: EQUAL
63190: PUSH
63191: LD_VAR 0 1
63195: PPUSH
63196: CALL_OW 110
63200: PUSH
63201: LD_INT 20
63203: EQUAL
63204: PUSH
63205: LD_VAR 0 1
63209: PUSH
63210: LD_EXP 139
63214: PUSH
63215: LD_VAR 0 3
63219: ARRAY
63220: IN
63221: OR
63222: PUSH
63223: LD_VAR 0 1
63227: PPUSH
63228: CALL_OW 264
63232: PUSH
63233: LD_INT 12
63235: PUSH
63236: LD_INT 51
63238: PUSH
63239: LD_EXP 96
63243: PUSH
63244: LD_INT 32
63246: PUSH
63247: LD_INT 13
63249: PUSH
63250: LD_INT 52
63252: PUSH
63253: LD_INT 31
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: IN
63265: OR
63266: AND
63267: IFFALSE 63575
// begin if un in mc_defender [ i ] then
63269: LD_VAR 0 1
63273: PUSH
63274: LD_EXP 139
63278: PUSH
63279: LD_VAR 0 3
63283: ARRAY
63284: IN
63285: IFFALSE 63324
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63287: LD_ADDR_EXP 139
63291: PUSH
63292: LD_EXP 139
63296: PPUSH
63297: LD_VAR 0 3
63301: PPUSH
63302: LD_EXP 139
63306: PUSH
63307: LD_VAR 0 3
63311: ARRAY
63312: PUSH
63313: LD_VAR 0 1
63317: DIFF
63318: PPUSH
63319: CALL_OW 1
63323: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63324: LD_ADDR_VAR 0 8
63328: PUSH
63329: LD_VAR 0 3
63333: PPUSH
63334: LD_INT 3
63336: PPUSH
63337: CALL 59965 0 2
63341: ST_TO_ADDR
// if fac then
63342: LD_VAR 0 8
63346: IFFALSE 63575
// begin for j in fac do
63348: LD_ADDR_VAR 0 4
63352: PUSH
63353: LD_VAR 0 8
63357: PUSH
63358: FOR_IN
63359: IFFALSE 63573
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63361: LD_ADDR_VAR 0 9
63365: PUSH
63366: LD_VAR 0 8
63370: PPUSH
63371: LD_VAR 0 1
63375: PPUSH
63376: CALL_OW 265
63380: PPUSH
63381: LD_VAR 0 1
63385: PPUSH
63386: CALL_OW 262
63390: PPUSH
63391: LD_VAR 0 1
63395: PPUSH
63396: CALL_OW 263
63400: PPUSH
63401: LD_VAR 0 1
63405: PPUSH
63406: CALL_OW 264
63410: PPUSH
63411: CALL 68398 0 5
63415: ST_TO_ADDR
// if components then
63416: LD_VAR 0 9
63420: IFFALSE 63571
// begin if GetWeapon ( un ) = ar_control_tower then
63422: LD_VAR 0 1
63426: PPUSH
63427: CALL_OW 264
63431: PUSH
63432: LD_INT 31
63434: EQUAL
63435: IFFALSE 63552
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63437: LD_VAR 0 1
63441: PPUSH
63442: CALL_OW 311
63446: PPUSH
63447: LD_INT 0
63449: PPUSH
63450: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63454: LD_ADDR_EXP 157
63458: PUSH
63459: LD_EXP 157
63463: PPUSH
63464: LD_VAR 0 3
63468: PPUSH
63469: LD_EXP 157
63473: PUSH
63474: LD_VAR 0 3
63478: ARRAY
63479: PUSH
63480: LD_VAR 0 1
63484: PPUSH
63485: CALL_OW 311
63489: DIFF
63490: PPUSH
63491: CALL_OW 1
63495: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63496: LD_ADDR_VAR 0 7
63500: PUSH
63501: LD_EXP 138
63505: PUSH
63506: LD_VAR 0 3
63510: ARRAY
63511: PPUSH
63512: LD_INT 1
63514: PPUSH
63515: LD_VAR 0 9
63519: PPUSH
63520: CALL_OW 2
63524: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63525: LD_ADDR_EXP 138
63529: PUSH
63530: LD_EXP 138
63534: PPUSH
63535: LD_VAR 0 3
63539: PPUSH
63540: LD_VAR 0 7
63544: PPUSH
63545: CALL_OW 1
63549: ST_TO_ADDR
// end else
63550: GO 63569
// MC_InsertProduceList ( i , [ components ] ) ;
63552: LD_VAR 0 3
63556: PPUSH
63557: LD_VAR 0 9
63561: PUSH
63562: EMPTY
63563: LIST
63564: PPUSH
63565: CALL 59510 0 2
// break ;
63569: GO 63573
// end ; end ;
63571: GO 63358
63573: POP
63574: POP
// end ; end ; if GetType ( un ) = unit_building then
63575: LD_VAR 0 1
63579: PPUSH
63580: CALL_OW 247
63584: PUSH
63585: LD_INT 3
63587: EQUAL
63588: IFFALSE 63991
// begin btype := GetBType ( un ) ;
63590: LD_ADDR_VAR 0 5
63594: PUSH
63595: LD_VAR 0 1
63599: PPUSH
63600: CALL_OW 266
63604: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63605: LD_VAR 0 5
63609: PUSH
63610: LD_INT 29
63612: PUSH
63613: LD_INT 30
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: IN
63620: IFFALSE 63693
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63622: LD_VAR 0 1
63626: PPUSH
63627: CALL_OW 250
63631: PPUSH
63632: LD_VAR 0 1
63636: PPUSH
63637: CALL_OW 251
63641: PPUSH
63642: LD_VAR 0 1
63646: PPUSH
63647: CALL_OW 255
63651: PPUSH
63652: CALL_OW 440
63656: NOT
63657: IFFALSE 63693
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63659: LD_VAR 0 1
63663: PPUSH
63664: CALL_OW 250
63668: PPUSH
63669: LD_VAR 0 1
63673: PPUSH
63674: CALL_OW 251
63678: PPUSH
63679: LD_VAR 0 1
63683: PPUSH
63684: CALL_OW 255
63688: PPUSH
63689: CALL_OW 441
// end ; if btype = b_warehouse then
63693: LD_VAR 0 5
63697: PUSH
63698: LD_INT 1
63700: EQUAL
63701: IFFALSE 63719
// begin btype := b_depot ;
63703: LD_ADDR_VAR 0 5
63707: PUSH
63708: LD_INT 0
63710: ST_TO_ADDR
// pos := 1 ;
63711: LD_ADDR_VAR 0 6
63715: PUSH
63716: LD_INT 1
63718: ST_TO_ADDR
// end ; if btype = b_factory then
63719: LD_VAR 0 5
63723: PUSH
63724: LD_INT 3
63726: EQUAL
63727: IFFALSE 63745
// begin btype := b_workshop ;
63729: LD_ADDR_VAR 0 5
63733: PUSH
63734: LD_INT 2
63736: ST_TO_ADDR
// pos := 1 ;
63737: LD_ADDR_VAR 0 6
63741: PUSH
63742: LD_INT 1
63744: ST_TO_ADDR
// end ; if btype = b_barracks then
63745: LD_VAR 0 5
63749: PUSH
63750: LD_INT 5
63752: EQUAL
63753: IFFALSE 63763
// btype := b_armoury ;
63755: LD_ADDR_VAR 0 5
63759: PUSH
63760: LD_INT 4
63762: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63763: LD_VAR 0 5
63767: PUSH
63768: LD_INT 7
63770: PUSH
63771: LD_INT 8
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: IN
63778: IFFALSE 63788
// btype := b_lab ;
63780: LD_ADDR_VAR 0 5
63784: PUSH
63785: LD_INT 6
63787: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63788: LD_ADDR_EXP 122
63792: PUSH
63793: LD_EXP 122
63797: PPUSH
63798: LD_VAR 0 3
63802: PUSH
63803: LD_EXP 122
63807: PUSH
63808: LD_VAR 0 3
63812: ARRAY
63813: PUSH
63814: LD_INT 1
63816: PLUS
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: PPUSH
63822: LD_VAR 0 5
63826: PUSH
63827: LD_VAR 0 1
63831: PPUSH
63832: CALL_OW 250
63836: PUSH
63837: LD_VAR 0 1
63841: PPUSH
63842: CALL_OW 251
63846: PUSH
63847: LD_VAR 0 1
63851: PPUSH
63852: CALL_OW 254
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: PPUSH
63863: CALL 70902 0 3
63867: ST_TO_ADDR
// if pos = 1 then
63868: LD_VAR 0 6
63872: PUSH
63873: LD_INT 1
63875: EQUAL
63876: IFFALSE 63991
// begin tmp := mc_build_list [ i ] ;
63878: LD_ADDR_VAR 0 7
63882: PUSH
63883: LD_EXP 122
63887: PUSH
63888: LD_VAR 0 3
63892: ARRAY
63893: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63894: LD_VAR 0 7
63898: PPUSH
63899: LD_INT 2
63901: PUSH
63902: LD_INT 30
63904: PUSH
63905: LD_INT 0
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 30
63914: PUSH
63915: LD_INT 1
63917: PUSH
63918: EMPTY
63919: LIST
63920: LIST
63921: PUSH
63922: EMPTY
63923: LIST
63924: LIST
63925: LIST
63926: PPUSH
63927: CALL_OW 72
63931: IFFALSE 63941
// pos := 2 ;
63933: LD_ADDR_VAR 0 6
63937: PUSH
63938: LD_INT 2
63940: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63941: LD_ADDR_VAR 0 7
63945: PUSH
63946: LD_VAR 0 7
63950: PPUSH
63951: LD_VAR 0 6
63955: PPUSH
63956: LD_VAR 0 7
63960: PPUSH
63961: CALL 71228 0 3
63965: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63966: LD_ADDR_EXP 122
63970: PUSH
63971: LD_EXP 122
63975: PPUSH
63976: LD_VAR 0 3
63980: PPUSH
63981: LD_VAR 0 7
63985: PPUSH
63986: CALL_OW 1
63990: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63991: LD_VAR 0 1
63995: PUSH
63996: LD_EXP 117
64000: PUSH
64001: LD_VAR 0 3
64005: ARRAY
64006: IN
64007: IFFALSE 64046
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
64009: LD_ADDR_EXP 117
64013: PUSH
64014: LD_EXP 117
64018: PPUSH
64019: LD_VAR 0 3
64023: PPUSH
64024: LD_EXP 117
64028: PUSH
64029: LD_VAR 0 3
64033: ARRAY
64034: PUSH
64035: LD_VAR 0 1
64039: DIFF
64040: PPUSH
64041: CALL_OW 1
64045: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64046: LD_VAR 0 1
64050: PUSH
64051: LD_EXP 124
64055: PUSH
64056: LD_VAR 0 3
64060: ARRAY
64061: IN
64062: IFFALSE 64101
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64064: LD_ADDR_EXP 124
64068: PUSH
64069: LD_EXP 124
64073: PPUSH
64074: LD_VAR 0 3
64078: PPUSH
64079: LD_EXP 124
64083: PUSH
64084: LD_VAR 0 3
64088: ARRAY
64089: PUSH
64090: LD_VAR 0 1
64094: DIFF
64095: PPUSH
64096: CALL_OW 1
64100: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64101: LD_VAR 0 1
64105: PUSH
64106: LD_EXP 136
64110: PUSH
64111: LD_VAR 0 3
64115: ARRAY
64116: IN
64117: IFFALSE 64156
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64119: LD_ADDR_EXP 136
64123: PUSH
64124: LD_EXP 136
64128: PPUSH
64129: LD_VAR 0 3
64133: PPUSH
64134: LD_EXP 136
64138: PUSH
64139: LD_VAR 0 3
64143: ARRAY
64144: PUSH
64145: LD_VAR 0 1
64149: DIFF
64150: PPUSH
64151: CALL_OW 1
64155: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64156: LD_VAR 0 1
64160: PUSH
64161: LD_EXP 139
64165: PUSH
64166: LD_VAR 0 3
64170: ARRAY
64171: IN
64172: IFFALSE 64211
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64174: LD_ADDR_EXP 139
64178: PUSH
64179: LD_EXP 139
64183: PPUSH
64184: LD_VAR 0 3
64188: PPUSH
64189: LD_EXP 139
64193: PUSH
64194: LD_VAR 0 3
64198: ARRAY
64199: PUSH
64200: LD_VAR 0 1
64204: DIFF
64205: PPUSH
64206: CALL_OW 1
64210: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64211: LD_VAR 0 1
64215: PUSH
64216: LD_EXP 126
64220: PUSH
64221: LD_VAR 0 3
64225: ARRAY
64226: IN
64227: IFFALSE 64266
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64229: LD_ADDR_EXP 126
64233: PUSH
64234: LD_EXP 126
64238: PPUSH
64239: LD_VAR 0 3
64243: PPUSH
64244: LD_EXP 126
64248: PUSH
64249: LD_VAR 0 3
64253: ARRAY
64254: PUSH
64255: LD_VAR 0 1
64259: DIFF
64260: PPUSH
64261: CALL_OW 1
64265: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64266: LD_VAR 0 1
64270: PUSH
64271: LD_EXP 125
64275: PUSH
64276: LD_VAR 0 3
64280: ARRAY
64281: IN
64282: IFFALSE 64321
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64284: LD_ADDR_EXP 125
64288: PUSH
64289: LD_EXP 125
64293: PPUSH
64294: LD_VAR 0 3
64298: PPUSH
64299: LD_EXP 125
64303: PUSH
64304: LD_VAR 0 3
64308: ARRAY
64309: PUSH
64310: LD_VAR 0 1
64314: DIFF
64315: PPUSH
64316: CALL_OW 1
64320: ST_TO_ADDR
// end ; break ;
64321: GO 64325
// end ;
64323: GO 62971
64325: POP
64326: POP
// end ;
64327: LD_VAR 0 2
64331: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64332: LD_INT 0
64334: PPUSH
64335: PPUSH
64336: PPUSH
// if not mc_bases or not skirmish then
64337: LD_EXP 117
64341: NOT
64342: PUSH
64343: LD_EXP 115
64347: NOT
64348: OR
64349: IFFALSE 64353
// exit ;
64351: GO 64568
// for i = 1 to mc_bases do
64353: LD_ADDR_VAR 0 3
64357: PUSH
64358: DOUBLE
64359: LD_INT 1
64361: DEC
64362: ST_TO_ADDR
64363: LD_EXP 117
64367: PUSH
64368: FOR_TO
64369: IFFALSE 64566
// begin if building in mc_construct_list [ i ] then
64371: LD_VAR 0 1
64375: PUSH
64376: LD_EXP 124
64380: PUSH
64381: LD_VAR 0 3
64385: ARRAY
64386: IN
64387: IFFALSE 64564
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64389: LD_ADDR_EXP 124
64393: PUSH
64394: LD_EXP 124
64398: PPUSH
64399: LD_VAR 0 3
64403: PPUSH
64404: LD_EXP 124
64408: PUSH
64409: LD_VAR 0 3
64413: ARRAY
64414: PUSH
64415: LD_VAR 0 1
64419: DIFF
64420: PPUSH
64421: CALL_OW 1
64425: ST_TO_ADDR
// if building in mc_lab [ i ] then
64426: LD_VAR 0 1
64430: PUSH
64431: LD_EXP 150
64435: PUSH
64436: LD_VAR 0 3
64440: ARRAY
64441: IN
64442: IFFALSE 64497
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64444: LD_ADDR_EXP 151
64448: PUSH
64449: LD_EXP 151
64453: PPUSH
64454: LD_VAR 0 3
64458: PPUSH
64459: LD_EXP 151
64463: PUSH
64464: LD_VAR 0 3
64468: ARRAY
64469: PPUSH
64470: LD_INT 1
64472: PPUSH
64473: LD_EXP 151
64477: PUSH
64478: LD_VAR 0 3
64482: ARRAY
64483: PPUSH
64484: LD_INT 0
64486: PPUSH
64487: CALL 70320 0 4
64491: PPUSH
64492: CALL_OW 1
64496: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64497: LD_VAR 0 1
64501: PUSH
64502: LD_EXP 117
64506: PUSH
64507: LD_VAR 0 3
64511: ARRAY
64512: IN
64513: NOT
64514: IFFALSE 64560
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64516: LD_ADDR_EXP 117
64520: PUSH
64521: LD_EXP 117
64525: PPUSH
64526: LD_VAR 0 3
64530: PUSH
64531: LD_EXP 117
64535: PUSH
64536: LD_VAR 0 3
64540: ARRAY
64541: PUSH
64542: LD_INT 1
64544: PLUS
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PPUSH
64550: LD_VAR 0 1
64554: PPUSH
64555: CALL 70902 0 3
64559: ST_TO_ADDR
// exit ;
64560: POP
64561: POP
64562: GO 64568
// end ; end ;
64564: GO 64368
64566: POP
64567: POP
// end ;
64568: LD_VAR 0 2
64572: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64573: LD_INT 0
64575: PPUSH
64576: PPUSH
64577: PPUSH
64578: PPUSH
64579: PPUSH
64580: PPUSH
64581: PPUSH
// if not mc_bases or not skirmish then
64582: LD_EXP 117
64586: NOT
64587: PUSH
64588: LD_EXP 115
64592: NOT
64593: OR
64594: IFFALSE 64598
// exit ;
64596: GO 65259
// for i = 1 to mc_bases do
64598: LD_ADDR_VAR 0 3
64602: PUSH
64603: DOUBLE
64604: LD_INT 1
64606: DEC
64607: ST_TO_ADDR
64608: LD_EXP 117
64612: PUSH
64613: FOR_TO
64614: IFFALSE 65257
// begin if building in mc_construct_list [ i ] then
64616: LD_VAR 0 1
64620: PUSH
64621: LD_EXP 124
64625: PUSH
64626: LD_VAR 0 3
64630: ARRAY
64631: IN
64632: IFFALSE 65255
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64634: LD_ADDR_EXP 124
64638: PUSH
64639: LD_EXP 124
64643: PPUSH
64644: LD_VAR 0 3
64648: PPUSH
64649: LD_EXP 124
64653: PUSH
64654: LD_VAR 0 3
64658: ARRAY
64659: PUSH
64660: LD_VAR 0 1
64664: DIFF
64665: PPUSH
64666: CALL_OW 1
64670: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64671: LD_ADDR_EXP 117
64675: PUSH
64676: LD_EXP 117
64680: PPUSH
64681: LD_VAR 0 3
64685: PUSH
64686: LD_EXP 117
64690: PUSH
64691: LD_VAR 0 3
64695: ARRAY
64696: PUSH
64697: LD_INT 1
64699: PLUS
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PPUSH
64705: LD_VAR 0 1
64709: PPUSH
64710: CALL 70902 0 3
64714: ST_TO_ADDR
// btype := GetBType ( building ) ;
64715: LD_ADDR_VAR 0 5
64719: PUSH
64720: LD_VAR 0 1
64724: PPUSH
64725: CALL_OW 266
64729: ST_TO_ADDR
// side := GetSide ( building ) ;
64730: LD_ADDR_VAR 0 8
64734: PUSH
64735: LD_VAR 0 1
64739: PPUSH
64740: CALL_OW 255
64744: ST_TO_ADDR
// if btype = b_lab then
64745: LD_VAR 0 5
64749: PUSH
64750: LD_INT 6
64752: EQUAL
64753: IFFALSE 64803
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64755: LD_ADDR_EXP 150
64759: PUSH
64760: LD_EXP 150
64764: PPUSH
64765: LD_VAR 0 3
64769: PUSH
64770: LD_EXP 150
64774: PUSH
64775: LD_VAR 0 3
64779: ARRAY
64780: PUSH
64781: LD_INT 1
64783: PLUS
64784: PUSH
64785: EMPTY
64786: LIST
64787: LIST
64788: PPUSH
64789: LD_VAR 0 1
64793: PPUSH
64794: CALL 70902 0 3
64798: ST_TO_ADDR
// exit ;
64799: POP
64800: POP
64801: GO 65259
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64803: LD_VAR 0 5
64807: PUSH
64808: LD_INT 0
64810: PUSH
64811: LD_INT 2
64813: PUSH
64814: LD_INT 4
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: LIST
64821: IN
64822: IFFALSE 64946
// begin if btype = b_armoury then
64824: LD_VAR 0 5
64828: PUSH
64829: LD_INT 4
64831: EQUAL
64832: IFFALSE 64842
// btype := b_barracks ;
64834: LD_ADDR_VAR 0 5
64838: PUSH
64839: LD_INT 5
64841: ST_TO_ADDR
// if btype = b_depot then
64842: LD_VAR 0 5
64846: PUSH
64847: LD_INT 0
64849: EQUAL
64850: IFFALSE 64860
// btype := b_warehouse ;
64852: LD_ADDR_VAR 0 5
64856: PUSH
64857: LD_INT 1
64859: ST_TO_ADDR
// if btype = b_workshop then
64860: LD_VAR 0 5
64864: PUSH
64865: LD_INT 2
64867: EQUAL
64868: IFFALSE 64878
// btype := b_factory ;
64870: LD_ADDR_VAR 0 5
64874: PUSH
64875: LD_INT 3
64877: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64878: LD_VAR 0 5
64882: PPUSH
64883: LD_VAR 0 8
64887: PPUSH
64888: CALL_OW 323
64892: PUSH
64893: LD_INT 1
64895: EQUAL
64896: IFFALSE 64942
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64898: LD_ADDR_EXP 149
64902: PUSH
64903: LD_EXP 149
64907: PPUSH
64908: LD_VAR 0 3
64912: PUSH
64913: LD_EXP 149
64917: PUSH
64918: LD_VAR 0 3
64922: ARRAY
64923: PUSH
64924: LD_INT 1
64926: PLUS
64927: PUSH
64928: EMPTY
64929: LIST
64930: LIST
64931: PPUSH
64932: LD_VAR 0 1
64936: PPUSH
64937: CALL 70902 0 3
64941: ST_TO_ADDR
// exit ;
64942: POP
64943: POP
64944: GO 65259
// end ; if btype in [ b_bunker , b_turret ] then
64946: LD_VAR 0 5
64950: PUSH
64951: LD_INT 32
64953: PUSH
64954: LD_INT 33
64956: PUSH
64957: EMPTY
64958: LIST
64959: LIST
64960: IN
64961: IFFALSE 65251
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64963: LD_ADDR_EXP 125
64967: PUSH
64968: LD_EXP 125
64972: PPUSH
64973: LD_VAR 0 3
64977: PUSH
64978: LD_EXP 125
64982: PUSH
64983: LD_VAR 0 3
64987: ARRAY
64988: PUSH
64989: LD_INT 1
64991: PLUS
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PPUSH
64997: LD_VAR 0 1
65001: PPUSH
65002: CALL 70902 0 3
65006: ST_TO_ADDR
// if btype = b_bunker then
65007: LD_VAR 0 5
65011: PUSH
65012: LD_INT 32
65014: EQUAL
65015: IFFALSE 65251
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65017: LD_ADDR_EXP 126
65021: PUSH
65022: LD_EXP 126
65026: PPUSH
65027: LD_VAR 0 3
65031: PUSH
65032: LD_EXP 126
65036: PUSH
65037: LD_VAR 0 3
65041: ARRAY
65042: PUSH
65043: LD_INT 1
65045: PLUS
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PPUSH
65051: LD_VAR 0 1
65055: PPUSH
65056: CALL 70902 0 3
65060: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65061: LD_ADDR_VAR 0 6
65065: PUSH
65066: LD_EXP 117
65070: PUSH
65071: LD_VAR 0 3
65075: ARRAY
65076: PPUSH
65077: LD_INT 25
65079: PUSH
65080: LD_INT 1
65082: PUSH
65083: EMPTY
65084: LIST
65085: LIST
65086: PUSH
65087: LD_INT 3
65089: PUSH
65090: LD_INT 54
65092: PUSH
65093: EMPTY
65094: LIST
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PPUSH
65104: CALL_OW 72
65108: ST_TO_ADDR
// if tmp then
65109: LD_VAR 0 6
65113: IFFALSE 65119
// exit ;
65115: POP
65116: POP
65117: GO 65259
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65119: LD_ADDR_VAR 0 6
65123: PUSH
65124: LD_EXP 117
65128: PUSH
65129: LD_VAR 0 3
65133: ARRAY
65134: PPUSH
65135: LD_INT 2
65137: PUSH
65138: LD_INT 30
65140: PUSH
65141: LD_INT 4
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 30
65150: PUSH
65151: LD_INT 5
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: LIST
65162: PPUSH
65163: CALL_OW 72
65167: ST_TO_ADDR
// if not tmp then
65168: LD_VAR 0 6
65172: NOT
65173: IFFALSE 65179
// exit ;
65175: POP
65176: POP
65177: GO 65259
// for j in tmp do
65179: LD_ADDR_VAR 0 4
65183: PUSH
65184: LD_VAR 0 6
65188: PUSH
65189: FOR_IN
65190: IFFALSE 65249
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65192: LD_ADDR_VAR 0 7
65196: PUSH
65197: LD_VAR 0 4
65201: PPUSH
65202: CALL_OW 313
65206: PPUSH
65207: LD_INT 25
65209: PUSH
65210: LD_INT 1
65212: PUSH
65213: EMPTY
65214: LIST
65215: LIST
65216: PPUSH
65217: CALL_OW 72
65221: ST_TO_ADDR
// if units then
65222: LD_VAR 0 7
65226: IFFALSE 65247
// begin ComExitBuilding ( units [ 1 ] ) ;
65228: LD_VAR 0 7
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PPUSH
65237: CALL_OW 122
// exit ;
65241: POP
65242: POP
65243: POP
65244: POP
65245: GO 65259
// end ; end ;
65247: GO 65189
65249: POP
65250: POP
// end ; end ; exit ;
65251: POP
65252: POP
65253: GO 65259
// end ; end ;
65255: GO 64613
65257: POP
65258: POP
// end ;
65259: LD_VAR 0 2
65263: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65264: LD_INT 0
65266: PPUSH
65267: PPUSH
65268: PPUSH
65269: PPUSH
65270: PPUSH
65271: PPUSH
65272: PPUSH
// if not mc_bases or not skirmish then
65273: LD_EXP 117
65277: NOT
65278: PUSH
65279: LD_EXP 115
65283: NOT
65284: OR
65285: IFFALSE 65289
// exit ;
65287: GO 65554
// btype := GetBType ( building ) ;
65289: LD_ADDR_VAR 0 6
65293: PUSH
65294: LD_VAR 0 1
65298: PPUSH
65299: CALL_OW 266
65303: ST_TO_ADDR
// x := GetX ( building ) ;
65304: LD_ADDR_VAR 0 7
65308: PUSH
65309: LD_VAR 0 1
65313: PPUSH
65314: CALL_OW 250
65318: ST_TO_ADDR
// y := GetY ( building ) ;
65319: LD_ADDR_VAR 0 8
65323: PUSH
65324: LD_VAR 0 1
65328: PPUSH
65329: CALL_OW 251
65333: ST_TO_ADDR
// d := GetDir ( building ) ;
65334: LD_ADDR_VAR 0 9
65338: PUSH
65339: LD_VAR 0 1
65343: PPUSH
65344: CALL_OW 254
65348: ST_TO_ADDR
// for i = 1 to mc_bases do
65349: LD_ADDR_VAR 0 4
65353: PUSH
65354: DOUBLE
65355: LD_INT 1
65357: DEC
65358: ST_TO_ADDR
65359: LD_EXP 117
65363: PUSH
65364: FOR_TO
65365: IFFALSE 65552
// begin if not mc_build_list [ i ] then
65367: LD_EXP 122
65371: PUSH
65372: LD_VAR 0 4
65376: ARRAY
65377: NOT
65378: IFFALSE 65382
// continue ;
65380: GO 65364
// for j := 1 to mc_build_list [ i ] do
65382: LD_ADDR_VAR 0 5
65386: PUSH
65387: DOUBLE
65388: LD_INT 1
65390: DEC
65391: ST_TO_ADDR
65392: LD_EXP 122
65396: PUSH
65397: LD_VAR 0 4
65401: ARRAY
65402: PUSH
65403: FOR_TO
65404: IFFALSE 65548
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65406: LD_VAR 0 6
65410: PUSH
65411: LD_VAR 0 7
65415: PUSH
65416: LD_VAR 0 8
65420: PUSH
65421: LD_VAR 0 9
65425: PUSH
65426: EMPTY
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: PPUSH
65432: LD_EXP 122
65436: PUSH
65437: LD_VAR 0 4
65441: ARRAY
65442: PUSH
65443: LD_VAR 0 5
65447: ARRAY
65448: PPUSH
65449: CALL 77084 0 2
65453: IFFALSE 65546
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65455: LD_ADDR_EXP 122
65459: PUSH
65460: LD_EXP 122
65464: PPUSH
65465: LD_VAR 0 4
65469: PPUSH
65470: LD_EXP 122
65474: PUSH
65475: LD_VAR 0 4
65479: ARRAY
65480: PPUSH
65481: LD_VAR 0 5
65485: PPUSH
65486: CALL_OW 3
65490: PPUSH
65491: CALL_OW 1
65495: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65496: LD_ADDR_EXP 124
65500: PUSH
65501: LD_EXP 124
65505: PPUSH
65506: LD_VAR 0 4
65510: PUSH
65511: LD_EXP 124
65515: PUSH
65516: LD_VAR 0 4
65520: ARRAY
65521: PUSH
65522: LD_INT 1
65524: PLUS
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: PPUSH
65530: LD_VAR 0 1
65534: PPUSH
65535: CALL 70902 0 3
65539: ST_TO_ADDR
// exit ;
65540: POP
65541: POP
65542: POP
65543: POP
65544: GO 65554
// end ;
65546: GO 65403
65548: POP
65549: POP
// end ;
65550: GO 65364
65552: POP
65553: POP
// end ;
65554: LD_VAR 0 3
65558: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65559: LD_INT 0
65561: PPUSH
65562: PPUSH
65563: PPUSH
// if not mc_bases or not skirmish then
65564: LD_EXP 117
65568: NOT
65569: PUSH
65570: LD_EXP 115
65574: NOT
65575: OR
65576: IFFALSE 65580
// exit ;
65578: GO 65770
// for i = 1 to mc_bases do
65580: LD_ADDR_VAR 0 4
65584: PUSH
65585: DOUBLE
65586: LD_INT 1
65588: DEC
65589: ST_TO_ADDR
65590: LD_EXP 117
65594: PUSH
65595: FOR_TO
65596: IFFALSE 65683
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65598: LD_VAR 0 1
65602: PUSH
65603: LD_EXP 125
65607: PUSH
65608: LD_VAR 0 4
65612: ARRAY
65613: IN
65614: PUSH
65615: LD_VAR 0 1
65619: PUSH
65620: LD_EXP 126
65624: PUSH
65625: LD_VAR 0 4
65629: ARRAY
65630: IN
65631: NOT
65632: AND
65633: IFFALSE 65681
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65635: LD_ADDR_EXP 126
65639: PUSH
65640: LD_EXP 126
65644: PPUSH
65645: LD_VAR 0 4
65649: PUSH
65650: LD_EXP 126
65654: PUSH
65655: LD_VAR 0 4
65659: ARRAY
65660: PUSH
65661: LD_INT 1
65663: PLUS
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PPUSH
65669: LD_VAR 0 1
65673: PPUSH
65674: CALL 70902 0 3
65678: ST_TO_ADDR
// break ;
65679: GO 65683
// end ; end ;
65681: GO 65595
65683: POP
65684: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65685: LD_VAR 0 1
65689: PPUSH
65690: CALL_OW 257
65694: PUSH
65695: LD_EXP 143
65699: IN
65700: PUSH
65701: LD_VAR 0 1
65705: PPUSH
65706: CALL_OW 266
65710: PUSH
65711: LD_INT 5
65713: EQUAL
65714: AND
65715: PUSH
65716: LD_VAR 0 2
65720: PPUSH
65721: CALL_OW 110
65725: PUSH
65726: LD_INT 18
65728: NONEQUAL
65729: AND
65730: IFFALSE 65770
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65732: LD_VAR 0 2
65736: PPUSH
65737: CALL_OW 257
65741: PUSH
65742: LD_INT 5
65744: PUSH
65745: LD_INT 8
65747: PUSH
65748: LD_INT 9
65750: PUSH
65751: EMPTY
65752: LIST
65753: LIST
65754: LIST
65755: IN
65756: IFFALSE 65770
// SetClass ( unit , 1 ) ;
65758: LD_VAR 0 2
65762: PPUSH
65763: LD_INT 1
65765: PPUSH
65766: CALL_OW 336
// end ;
65770: LD_VAR 0 3
65774: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65775: LD_INT 0
65777: PPUSH
65778: PPUSH
// if not mc_bases or not skirmish then
65779: LD_EXP 117
65783: NOT
65784: PUSH
65785: LD_EXP 115
65789: NOT
65790: OR
65791: IFFALSE 65795
// exit ;
65793: GO 65911
// if GetLives ( abandoned_vehicle ) > 250 then
65795: LD_VAR 0 2
65799: PPUSH
65800: CALL_OW 256
65804: PUSH
65805: LD_INT 250
65807: GREATER
65808: IFFALSE 65812
// exit ;
65810: GO 65911
// for i = 1 to mc_bases do
65812: LD_ADDR_VAR 0 6
65816: PUSH
65817: DOUBLE
65818: LD_INT 1
65820: DEC
65821: ST_TO_ADDR
65822: LD_EXP 117
65826: PUSH
65827: FOR_TO
65828: IFFALSE 65909
// begin if driver in mc_bases [ i ] then
65830: LD_VAR 0 1
65834: PUSH
65835: LD_EXP 117
65839: PUSH
65840: LD_VAR 0 6
65844: ARRAY
65845: IN
65846: IFFALSE 65907
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65848: LD_VAR 0 1
65852: PPUSH
65853: LD_EXP 117
65857: PUSH
65858: LD_VAR 0 6
65862: ARRAY
65863: PPUSH
65864: LD_INT 2
65866: PUSH
65867: LD_INT 30
65869: PUSH
65870: LD_INT 0
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 30
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: LIST
65891: PPUSH
65892: CALL_OW 72
65896: PUSH
65897: LD_INT 1
65899: ARRAY
65900: PPUSH
65901: CALL 103464 0 2
// break ;
65905: GO 65909
// end ; end ;
65907: GO 65827
65909: POP
65910: POP
// end ; end_of_file
65911: LD_VAR 0 5
65915: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65916: LD_INT 0
65918: PPUSH
65919: PPUSH
// if exist_mode then
65920: LD_VAR 0 2
65924: IFFALSE 65949
// unit := CreateCharacter ( prefix & ident ) else
65926: LD_ADDR_VAR 0 5
65930: PUSH
65931: LD_VAR 0 3
65935: PUSH
65936: LD_VAR 0 1
65940: STR
65941: PPUSH
65942: CALL_OW 34
65946: ST_TO_ADDR
65947: GO 65964
// unit := NewCharacter ( ident ) ;
65949: LD_ADDR_VAR 0 5
65953: PUSH
65954: LD_VAR 0 1
65958: PPUSH
65959: CALL_OW 25
65963: ST_TO_ADDR
// result := unit ;
65964: LD_ADDR_VAR 0 4
65968: PUSH
65969: LD_VAR 0 5
65973: ST_TO_ADDR
// end ;
65974: LD_VAR 0 4
65978: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65979: LD_INT 0
65981: PPUSH
65982: PPUSH
// if not side or not nation then
65983: LD_VAR 0 1
65987: NOT
65988: PUSH
65989: LD_VAR 0 2
65993: NOT
65994: OR
65995: IFFALSE 65999
// exit ;
65997: GO 66767
// case nation of nation_american :
65999: LD_VAR 0 2
66003: PUSH
66004: LD_INT 1
66006: DOUBLE
66007: EQUAL
66008: IFTRUE 66012
66010: GO 66226
66012: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
66013: LD_ADDR_VAR 0 4
66017: PUSH
66018: LD_INT 35
66020: PUSH
66021: LD_INT 45
66023: PUSH
66024: LD_INT 46
66026: PUSH
66027: LD_INT 47
66029: PUSH
66030: LD_INT 82
66032: PUSH
66033: LD_INT 83
66035: PUSH
66036: LD_INT 84
66038: PUSH
66039: LD_INT 85
66041: PUSH
66042: LD_INT 86
66044: PUSH
66045: LD_INT 1
66047: PUSH
66048: LD_INT 2
66050: PUSH
66051: LD_INT 6
66053: PUSH
66054: LD_INT 15
66056: PUSH
66057: LD_INT 16
66059: PUSH
66060: LD_INT 7
66062: PUSH
66063: LD_INT 12
66065: PUSH
66066: LD_INT 13
66068: PUSH
66069: LD_INT 10
66071: PUSH
66072: LD_INT 14
66074: PUSH
66075: LD_INT 20
66077: PUSH
66078: LD_INT 21
66080: PUSH
66081: LD_INT 22
66083: PUSH
66084: LD_INT 25
66086: PUSH
66087: LD_INT 32
66089: PUSH
66090: LD_INT 27
66092: PUSH
66093: LD_INT 36
66095: PUSH
66096: LD_INT 69
66098: PUSH
66099: LD_INT 39
66101: PUSH
66102: LD_INT 34
66104: PUSH
66105: LD_INT 40
66107: PUSH
66108: LD_INT 48
66110: PUSH
66111: LD_INT 49
66113: PUSH
66114: LD_INT 50
66116: PUSH
66117: LD_INT 51
66119: PUSH
66120: LD_INT 52
66122: PUSH
66123: LD_INT 53
66125: PUSH
66126: LD_INT 54
66128: PUSH
66129: LD_INT 55
66131: PUSH
66132: LD_INT 56
66134: PUSH
66135: LD_INT 57
66137: PUSH
66138: LD_INT 58
66140: PUSH
66141: LD_INT 59
66143: PUSH
66144: LD_INT 60
66146: PUSH
66147: LD_INT 61
66149: PUSH
66150: LD_INT 62
66152: PUSH
66153: LD_INT 80
66155: PUSH
66156: LD_INT 82
66158: PUSH
66159: LD_INT 83
66161: PUSH
66162: LD_INT 84
66164: PUSH
66165: LD_INT 85
66167: PUSH
66168: LD_INT 86
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: ST_TO_ADDR
66224: GO 66691
66226: LD_INT 2
66228: DOUBLE
66229: EQUAL
66230: IFTRUE 66234
66232: GO 66460
66234: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66235: LD_ADDR_VAR 0 4
66239: PUSH
66240: LD_INT 35
66242: PUSH
66243: LD_INT 45
66245: PUSH
66246: LD_INT 46
66248: PUSH
66249: LD_INT 47
66251: PUSH
66252: LD_INT 82
66254: PUSH
66255: LD_INT 83
66257: PUSH
66258: LD_INT 84
66260: PUSH
66261: LD_INT 85
66263: PUSH
66264: LD_INT 87
66266: PUSH
66267: LD_INT 70
66269: PUSH
66270: LD_INT 1
66272: PUSH
66273: LD_INT 11
66275: PUSH
66276: LD_INT 3
66278: PUSH
66279: LD_INT 4
66281: PUSH
66282: LD_INT 5
66284: PUSH
66285: LD_INT 6
66287: PUSH
66288: LD_INT 15
66290: PUSH
66291: LD_INT 18
66293: PUSH
66294: LD_INT 7
66296: PUSH
66297: LD_INT 17
66299: PUSH
66300: LD_INT 8
66302: PUSH
66303: LD_INT 20
66305: PUSH
66306: LD_INT 21
66308: PUSH
66309: LD_INT 22
66311: PUSH
66312: LD_INT 72
66314: PUSH
66315: LD_INT 26
66317: PUSH
66318: LD_INT 69
66320: PUSH
66321: LD_INT 39
66323: PUSH
66324: LD_INT 40
66326: PUSH
66327: LD_INT 41
66329: PUSH
66330: LD_INT 42
66332: PUSH
66333: LD_INT 43
66335: PUSH
66336: LD_INT 48
66338: PUSH
66339: LD_INT 49
66341: PUSH
66342: LD_INT 50
66344: PUSH
66345: LD_INT 51
66347: PUSH
66348: LD_INT 52
66350: PUSH
66351: LD_INT 53
66353: PUSH
66354: LD_INT 54
66356: PUSH
66357: LD_INT 55
66359: PUSH
66360: LD_INT 56
66362: PUSH
66363: LD_INT 60
66365: PUSH
66366: LD_INT 61
66368: PUSH
66369: LD_INT 62
66371: PUSH
66372: LD_INT 66
66374: PUSH
66375: LD_INT 67
66377: PUSH
66378: LD_INT 68
66380: PUSH
66381: LD_INT 81
66383: PUSH
66384: LD_INT 82
66386: PUSH
66387: LD_INT 83
66389: PUSH
66390: LD_INT 84
66392: PUSH
66393: LD_INT 85
66395: PUSH
66396: LD_INT 87
66398: PUSH
66399: LD_INT 88
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: LIST
66427: LIST
66428: LIST
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: LIST
66456: LIST
66457: ST_TO_ADDR
66458: GO 66691
66460: LD_INT 3
66462: DOUBLE
66463: EQUAL
66464: IFTRUE 66468
66466: GO 66690
66468: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66469: LD_ADDR_VAR 0 4
66473: PUSH
66474: LD_INT 46
66476: PUSH
66477: LD_INT 47
66479: PUSH
66480: LD_INT 1
66482: PUSH
66483: LD_INT 2
66485: PUSH
66486: LD_INT 82
66488: PUSH
66489: LD_INT 83
66491: PUSH
66492: LD_INT 84
66494: PUSH
66495: LD_INT 85
66497: PUSH
66498: LD_INT 86
66500: PUSH
66501: LD_INT 11
66503: PUSH
66504: LD_INT 9
66506: PUSH
66507: LD_INT 20
66509: PUSH
66510: LD_INT 19
66512: PUSH
66513: LD_INT 21
66515: PUSH
66516: LD_INT 24
66518: PUSH
66519: LD_INT 22
66521: PUSH
66522: LD_INT 25
66524: PUSH
66525: LD_INT 28
66527: PUSH
66528: LD_INT 29
66530: PUSH
66531: LD_INT 30
66533: PUSH
66534: LD_INT 31
66536: PUSH
66537: LD_INT 37
66539: PUSH
66540: LD_INT 38
66542: PUSH
66543: LD_INT 32
66545: PUSH
66546: LD_INT 27
66548: PUSH
66549: LD_INT 33
66551: PUSH
66552: LD_INT 69
66554: PUSH
66555: LD_INT 39
66557: PUSH
66558: LD_INT 34
66560: PUSH
66561: LD_INT 40
66563: PUSH
66564: LD_INT 71
66566: PUSH
66567: LD_INT 23
66569: PUSH
66570: LD_INT 44
66572: PUSH
66573: LD_INT 48
66575: PUSH
66576: LD_INT 49
66578: PUSH
66579: LD_INT 50
66581: PUSH
66582: LD_INT 51
66584: PUSH
66585: LD_INT 52
66587: PUSH
66588: LD_INT 53
66590: PUSH
66591: LD_INT 54
66593: PUSH
66594: LD_INT 55
66596: PUSH
66597: LD_INT 56
66599: PUSH
66600: LD_INT 57
66602: PUSH
66603: LD_INT 58
66605: PUSH
66606: LD_INT 59
66608: PUSH
66609: LD_INT 63
66611: PUSH
66612: LD_INT 64
66614: PUSH
66615: LD_INT 65
66617: PUSH
66618: LD_INT 82
66620: PUSH
66621: LD_INT 83
66623: PUSH
66624: LD_INT 84
66626: PUSH
66627: LD_INT 85
66629: PUSH
66630: LD_INT 86
66632: PUSH
66633: EMPTY
66634: LIST
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: LIST
66671: LIST
66672: LIST
66673: LIST
66674: LIST
66675: LIST
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: ST_TO_ADDR
66688: GO 66691
66690: POP
// if state > - 1 and state < 3 then
66691: LD_VAR 0 3
66695: PUSH
66696: LD_INT 1
66698: NEG
66699: GREATER
66700: PUSH
66701: LD_VAR 0 3
66705: PUSH
66706: LD_INT 3
66708: LESS
66709: AND
66710: IFFALSE 66767
// for i in result do
66712: LD_ADDR_VAR 0 5
66716: PUSH
66717: LD_VAR 0 4
66721: PUSH
66722: FOR_IN
66723: IFFALSE 66765
// if GetTech ( i , side ) <> state then
66725: LD_VAR 0 5
66729: PPUSH
66730: LD_VAR 0 1
66734: PPUSH
66735: CALL_OW 321
66739: PUSH
66740: LD_VAR 0 3
66744: NONEQUAL
66745: IFFALSE 66763
// result := result diff i ;
66747: LD_ADDR_VAR 0 4
66751: PUSH
66752: LD_VAR 0 4
66756: PUSH
66757: LD_VAR 0 5
66761: DIFF
66762: ST_TO_ADDR
66763: GO 66722
66765: POP
66766: POP
// end ;
66767: LD_VAR 0 4
66771: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66772: LD_INT 0
66774: PPUSH
66775: PPUSH
66776: PPUSH
// result := true ;
66777: LD_ADDR_VAR 0 3
66781: PUSH
66782: LD_INT 1
66784: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66785: LD_ADDR_VAR 0 5
66789: PUSH
66790: LD_VAR 0 2
66794: PPUSH
66795: CALL_OW 480
66799: ST_TO_ADDR
// if not tmp then
66800: LD_VAR 0 5
66804: NOT
66805: IFFALSE 66809
// exit ;
66807: GO 66858
// for i in tmp do
66809: LD_ADDR_VAR 0 4
66813: PUSH
66814: LD_VAR 0 5
66818: PUSH
66819: FOR_IN
66820: IFFALSE 66856
// if GetTech ( i , side ) <> state_researched then
66822: LD_VAR 0 4
66826: PPUSH
66827: LD_VAR 0 1
66831: PPUSH
66832: CALL_OW 321
66836: PUSH
66837: LD_INT 2
66839: NONEQUAL
66840: IFFALSE 66854
// begin result := false ;
66842: LD_ADDR_VAR 0 3
66846: PUSH
66847: LD_INT 0
66849: ST_TO_ADDR
// exit ;
66850: POP
66851: POP
66852: GO 66858
// end ;
66854: GO 66819
66856: POP
66857: POP
// end ;
66858: LD_VAR 0 3
66862: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66863: LD_INT 0
66865: PPUSH
66866: PPUSH
66867: PPUSH
66868: PPUSH
66869: PPUSH
66870: PPUSH
66871: PPUSH
66872: PPUSH
66873: PPUSH
66874: PPUSH
66875: PPUSH
66876: PPUSH
66877: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66878: LD_VAR 0 1
66882: NOT
66883: PUSH
66884: LD_VAR 0 1
66888: PPUSH
66889: CALL_OW 257
66893: PUSH
66894: LD_INT 9
66896: NONEQUAL
66897: OR
66898: IFFALSE 66902
// exit ;
66900: GO 67475
// side := GetSide ( unit ) ;
66902: LD_ADDR_VAR 0 9
66906: PUSH
66907: LD_VAR 0 1
66911: PPUSH
66912: CALL_OW 255
66916: ST_TO_ADDR
// tech_space := tech_spacanom ;
66917: LD_ADDR_VAR 0 12
66921: PUSH
66922: LD_INT 29
66924: ST_TO_ADDR
// tech_time := tech_taurad ;
66925: LD_ADDR_VAR 0 13
66929: PUSH
66930: LD_INT 28
66932: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66933: LD_ADDR_VAR 0 11
66937: PUSH
66938: LD_VAR 0 1
66942: PPUSH
66943: CALL_OW 310
66947: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66948: LD_VAR 0 11
66952: PPUSH
66953: CALL_OW 247
66957: PUSH
66958: LD_INT 2
66960: EQUAL
66961: IFFALSE 66965
// exit ;
66963: GO 67475
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66965: LD_ADDR_VAR 0 8
66969: PUSH
66970: LD_INT 81
66972: PUSH
66973: LD_VAR 0 9
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 3
66984: PUSH
66985: LD_INT 21
66987: PUSH
66988: LD_INT 3
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PPUSH
67003: CALL_OW 69
67007: ST_TO_ADDR
// if not tmp then
67008: LD_VAR 0 8
67012: NOT
67013: IFFALSE 67017
// exit ;
67015: GO 67475
// if in_unit then
67017: LD_VAR 0 11
67021: IFFALSE 67045
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
67023: LD_ADDR_VAR 0 10
67027: PUSH
67028: LD_VAR 0 8
67032: PPUSH
67033: LD_VAR 0 11
67037: PPUSH
67038: CALL_OW 74
67042: ST_TO_ADDR
67043: GO 67065
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67045: LD_ADDR_VAR 0 10
67049: PUSH
67050: LD_VAR 0 8
67054: PPUSH
67055: LD_VAR 0 1
67059: PPUSH
67060: CALL_OW 74
67064: ST_TO_ADDR
// if not enemy then
67065: LD_VAR 0 10
67069: NOT
67070: IFFALSE 67074
// exit ;
67072: GO 67475
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67074: LD_VAR 0 11
67078: PUSH
67079: LD_VAR 0 11
67083: PPUSH
67084: LD_VAR 0 10
67088: PPUSH
67089: CALL_OW 296
67093: PUSH
67094: LD_INT 13
67096: GREATER
67097: AND
67098: PUSH
67099: LD_VAR 0 1
67103: PPUSH
67104: LD_VAR 0 10
67108: PPUSH
67109: CALL_OW 296
67113: PUSH
67114: LD_INT 12
67116: GREATER
67117: OR
67118: IFFALSE 67122
// exit ;
67120: GO 67475
// missile := [ 1 ] ;
67122: LD_ADDR_VAR 0 14
67126: PUSH
67127: LD_INT 1
67129: PUSH
67130: EMPTY
67131: LIST
67132: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67133: LD_VAR 0 9
67137: PPUSH
67138: LD_VAR 0 12
67142: PPUSH
67143: CALL_OW 325
67147: IFFALSE 67176
// missile := Replace ( missile , missile + 1 , 2 ) ;
67149: LD_ADDR_VAR 0 14
67153: PUSH
67154: LD_VAR 0 14
67158: PPUSH
67159: LD_VAR 0 14
67163: PUSH
67164: LD_INT 1
67166: PLUS
67167: PPUSH
67168: LD_INT 2
67170: PPUSH
67171: CALL_OW 1
67175: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67176: LD_VAR 0 9
67180: PPUSH
67181: LD_VAR 0 13
67185: PPUSH
67186: CALL_OW 325
67190: PUSH
67191: LD_VAR 0 10
67195: PPUSH
67196: CALL_OW 255
67200: PPUSH
67201: LD_VAR 0 13
67205: PPUSH
67206: CALL_OW 325
67210: NOT
67211: AND
67212: IFFALSE 67241
// missile := Replace ( missile , missile + 1 , 3 ) ;
67214: LD_ADDR_VAR 0 14
67218: PUSH
67219: LD_VAR 0 14
67223: PPUSH
67224: LD_VAR 0 14
67228: PUSH
67229: LD_INT 1
67231: PLUS
67232: PPUSH
67233: LD_INT 3
67235: PPUSH
67236: CALL_OW 1
67240: ST_TO_ADDR
// if missile < 2 then
67241: LD_VAR 0 14
67245: PUSH
67246: LD_INT 2
67248: LESS
67249: IFFALSE 67253
// exit ;
67251: GO 67475
// x := GetX ( enemy ) ;
67253: LD_ADDR_VAR 0 4
67257: PUSH
67258: LD_VAR 0 10
67262: PPUSH
67263: CALL_OW 250
67267: ST_TO_ADDR
// y := GetY ( enemy ) ;
67268: LD_ADDR_VAR 0 5
67272: PUSH
67273: LD_VAR 0 10
67277: PPUSH
67278: CALL_OW 251
67282: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67283: LD_ADDR_VAR 0 6
67287: PUSH
67288: LD_VAR 0 4
67292: PUSH
67293: LD_INT 1
67295: NEG
67296: PPUSH
67297: LD_INT 1
67299: PPUSH
67300: CALL_OW 12
67304: PLUS
67305: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67306: LD_ADDR_VAR 0 7
67310: PUSH
67311: LD_VAR 0 5
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PPUSH
67320: LD_INT 1
67322: PPUSH
67323: CALL_OW 12
67327: PLUS
67328: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67329: LD_VAR 0 6
67333: PPUSH
67334: LD_VAR 0 7
67338: PPUSH
67339: CALL_OW 488
67343: NOT
67344: IFFALSE 67366
// begin _x := x ;
67346: LD_ADDR_VAR 0 6
67350: PUSH
67351: LD_VAR 0 4
67355: ST_TO_ADDR
// _y := y ;
67356: LD_ADDR_VAR 0 7
67360: PUSH
67361: LD_VAR 0 5
67365: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67366: LD_ADDR_VAR 0 3
67370: PUSH
67371: LD_INT 1
67373: PPUSH
67374: LD_VAR 0 14
67378: PPUSH
67379: CALL_OW 12
67383: ST_TO_ADDR
// case i of 1 :
67384: LD_VAR 0 3
67388: PUSH
67389: LD_INT 1
67391: DOUBLE
67392: EQUAL
67393: IFTRUE 67397
67395: GO 67414
67397: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67398: LD_VAR 0 1
67402: PPUSH
67403: LD_VAR 0 10
67407: PPUSH
67408: CALL_OW 115
67412: GO 67475
67414: LD_INT 2
67416: DOUBLE
67417: EQUAL
67418: IFTRUE 67422
67420: GO 67444
67422: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67423: LD_VAR 0 1
67427: PPUSH
67428: LD_VAR 0 6
67432: PPUSH
67433: LD_VAR 0 7
67437: PPUSH
67438: CALL_OW 153
67442: GO 67475
67444: LD_INT 3
67446: DOUBLE
67447: EQUAL
67448: IFTRUE 67452
67450: GO 67474
67452: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67453: LD_VAR 0 1
67457: PPUSH
67458: LD_VAR 0 6
67462: PPUSH
67463: LD_VAR 0 7
67467: PPUSH
67468: CALL_OW 154
67472: GO 67475
67474: POP
// end ;
67475: LD_VAR 0 2
67479: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67480: LD_INT 0
67482: PPUSH
67483: PPUSH
67484: PPUSH
67485: PPUSH
67486: PPUSH
67487: PPUSH
// if not unit or not building then
67488: LD_VAR 0 1
67492: NOT
67493: PUSH
67494: LD_VAR 0 2
67498: NOT
67499: OR
67500: IFFALSE 67504
// exit ;
67502: GO 67662
// x := GetX ( building ) ;
67504: LD_ADDR_VAR 0 5
67508: PUSH
67509: LD_VAR 0 2
67513: PPUSH
67514: CALL_OW 250
67518: ST_TO_ADDR
// y := GetY ( building ) ;
67519: LD_ADDR_VAR 0 6
67523: PUSH
67524: LD_VAR 0 2
67528: PPUSH
67529: CALL_OW 251
67533: ST_TO_ADDR
// for i = 0 to 5 do
67534: LD_ADDR_VAR 0 4
67538: PUSH
67539: DOUBLE
67540: LD_INT 0
67542: DEC
67543: ST_TO_ADDR
67544: LD_INT 5
67546: PUSH
67547: FOR_TO
67548: IFFALSE 67660
// begin _x := ShiftX ( x , i , 3 ) ;
67550: LD_ADDR_VAR 0 7
67554: PUSH
67555: LD_VAR 0 5
67559: PPUSH
67560: LD_VAR 0 4
67564: PPUSH
67565: LD_INT 3
67567: PPUSH
67568: CALL_OW 272
67572: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67573: LD_ADDR_VAR 0 8
67577: PUSH
67578: LD_VAR 0 6
67582: PPUSH
67583: LD_VAR 0 4
67587: PPUSH
67588: LD_INT 3
67590: PPUSH
67591: CALL_OW 273
67595: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67596: LD_VAR 0 7
67600: PPUSH
67601: LD_VAR 0 8
67605: PPUSH
67606: CALL_OW 488
67610: NOT
67611: IFFALSE 67615
// continue ;
67613: GO 67547
// if HexInfo ( _x , _y ) = 0 then
67615: LD_VAR 0 7
67619: PPUSH
67620: LD_VAR 0 8
67624: PPUSH
67625: CALL_OW 428
67629: PUSH
67630: LD_INT 0
67632: EQUAL
67633: IFFALSE 67658
// begin ComMoveXY ( unit , _x , _y ) ;
67635: LD_VAR 0 1
67639: PPUSH
67640: LD_VAR 0 7
67644: PPUSH
67645: LD_VAR 0 8
67649: PPUSH
67650: CALL_OW 111
// exit ;
67654: POP
67655: POP
67656: GO 67662
// end ; end ;
67658: GO 67547
67660: POP
67661: POP
// end ;
67662: LD_VAR 0 3
67666: RET
// export function ScanBase ( side , base_area ) ; begin
67667: LD_INT 0
67669: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67670: LD_ADDR_VAR 0 3
67674: PUSH
67675: LD_VAR 0 2
67679: PPUSH
67680: LD_INT 81
67682: PUSH
67683: LD_VAR 0 1
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PPUSH
67692: CALL_OW 70
67696: ST_TO_ADDR
// end ;
67697: LD_VAR 0 3
67701: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67702: LD_INT 0
67704: PPUSH
67705: PPUSH
67706: PPUSH
67707: PPUSH
// result := false ;
67708: LD_ADDR_VAR 0 2
67712: PUSH
67713: LD_INT 0
67715: ST_TO_ADDR
// side := GetSide ( unit ) ;
67716: LD_ADDR_VAR 0 3
67720: PUSH
67721: LD_VAR 0 1
67725: PPUSH
67726: CALL_OW 255
67730: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67731: LD_ADDR_VAR 0 4
67735: PUSH
67736: LD_VAR 0 1
67740: PPUSH
67741: CALL_OW 248
67745: ST_TO_ADDR
// case nat of 1 :
67746: LD_VAR 0 4
67750: PUSH
67751: LD_INT 1
67753: DOUBLE
67754: EQUAL
67755: IFTRUE 67759
67757: GO 67770
67759: POP
// tech := tech_lassight ; 2 :
67760: LD_ADDR_VAR 0 5
67764: PUSH
67765: LD_INT 12
67767: ST_TO_ADDR
67768: GO 67809
67770: LD_INT 2
67772: DOUBLE
67773: EQUAL
67774: IFTRUE 67778
67776: GO 67789
67778: POP
// tech := tech_mortar ; 3 :
67779: LD_ADDR_VAR 0 5
67783: PUSH
67784: LD_INT 41
67786: ST_TO_ADDR
67787: GO 67809
67789: LD_INT 3
67791: DOUBLE
67792: EQUAL
67793: IFTRUE 67797
67795: GO 67808
67797: POP
// tech := tech_bazooka ; end ;
67798: LD_ADDR_VAR 0 5
67802: PUSH
67803: LD_INT 44
67805: ST_TO_ADDR
67806: GO 67809
67808: POP
// if Researched ( side , tech ) then
67809: LD_VAR 0 3
67813: PPUSH
67814: LD_VAR 0 5
67818: PPUSH
67819: CALL_OW 325
67823: IFFALSE 67850
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67825: LD_ADDR_VAR 0 2
67829: PUSH
67830: LD_INT 5
67832: PUSH
67833: LD_INT 8
67835: PUSH
67836: LD_INT 9
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: LIST
67843: PUSH
67844: LD_VAR 0 4
67848: ARRAY
67849: ST_TO_ADDR
// end ;
67850: LD_VAR 0 2
67854: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67855: LD_INT 0
67857: PPUSH
67858: PPUSH
67859: PPUSH
// if not mines then
67860: LD_VAR 0 2
67864: NOT
67865: IFFALSE 67869
// exit ;
67867: GO 68013
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67869: LD_ADDR_VAR 0 5
67873: PUSH
67874: LD_INT 81
67876: PUSH
67877: LD_VAR 0 1
67881: PUSH
67882: EMPTY
67883: LIST
67884: LIST
67885: PUSH
67886: LD_INT 3
67888: PUSH
67889: LD_INT 21
67891: PUSH
67892: LD_INT 3
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: EMPTY
67900: LIST
67901: LIST
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PPUSH
67907: CALL_OW 69
67911: ST_TO_ADDR
// for i in mines do
67912: LD_ADDR_VAR 0 4
67916: PUSH
67917: LD_VAR 0 2
67921: PUSH
67922: FOR_IN
67923: IFFALSE 68011
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67925: LD_VAR 0 4
67929: PUSH
67930: LD_INT 1
67932: ARRAY
67933: PPUSH
67934: LD_VAR 0 4
67938: PUSH
67939: LD_INT 2
67941: ARRAY
67942: PPUSH
67943: CALL_OW 458
67947: NOT
67948: IFFALSE 67952
// continue ;
67950: GO 67922
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67952: LD_VAR 0 4
67956: PUSH
67957: LD_INT 1
67959: ARRAY
67960: PPUSH
67961: LD_VAR 0 4
67965: PUSH
67966: LD_INT 2
67968: ARRAY
67969: PPUSH
67970: CALL_OW 428
67974: PUSH
67975: LD_VAR 0 5
67979: IN
67980: IFFALSE 68009
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67982: LD_VAR 0 4
67986: PUSH
67987: LD_INT 1
67989: ARRAY
67990: PPUSH
67991: LD_VAR 0 4
67995: PUSH
67996: LD_INT 2
67998: ARRAY
67999: PPUSH
68000: LD_VAR 0 1
68004: PPUSH
68005: CALL_OW 456
// end ;
68009: GO 67922
68011: POP
68012: POP
// end ;
68013: LD_VAR 0 3
68017: RET
// export function Count ( array ) ; var i ; begin
68018: LD_INT 0
68020: PPUSH
68021: PPUSH
// result := 0 ;
68022: LD_ADDR_VAR 0 2
68026: PUSH
68027: LD_INT 0
68029: ST_TO_ADDR
// for i in array do
68030: LD_ADDR_VAR 0 3
68034: PUSH
68035: LD_VAR 0 1
68039: PUSH
68040: FOR_IN
68041: IFFALSE 68065
// if i then
68043: LD_VAR 0 3
68047: IFFALSE 68063
// result := result + 1 ;
68049: LD_ADDR_VAR 0 2
68053: PUSH
68054: LD_VAR 0 2
68058: PUSH
68059: LD_INT 1
68061: PLUS
68062: ST_TO_ADDR
68063: GO 68040
68065: POP
68066: POP
// end ;
68067: LD_VAR 0 2
68071: RET
// export function IsEmpty ( building ) ; begin
68072: LD_INT 0
68074: PPUSH
// if not building then
68075: LD_VAR 0 1
68079: NOT
68080: IFFALSE 68084
// exit ;
68082: GO 68127
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68084: LD_ADDR_VAR 0 2
68088: PUSH
68089: LD_VAR 0 1
68093: PUSH
68094: LD_INT 22
68096: PUSH
68097: LD_VAR 0 1
68101: PPUSH
68102: CALL_OW 255
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 58
68113: PUSH
68114: EMPTY
68115: LIST
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PPUSH
68121: CALL_OW 69
68125: IN
68126: ST_TO_ADDR
// end ;
68127: LD_VAR 0 2
68131: RET
// export function IsNotFull ( building ) ; begin
68132: LD_INT 0
68134: PPUSH
// if not building then
68135: LD_VAR 0 1
68139: NOT
68140: IFFALSE 68144
// exit ;
68142: GO 68163
// result := UnitsInside ( building ) < 6 ;
68144: LD_ADDR_VAR 0 2
68148: PUSH
68149: LD_VAR 0 1
68153: PPUSH
68154: CALL_OW 313
68158: PUSH
68159: LD_INT 6
68161: LESS
68162: ST_TO_ADDR
// end ;
68163: LD_VAR 0 2
68167: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68168: LD_INT 0
68170: PPUSH
68171: PPUSH
68172: PPUSH
68173: PPUSH
// tmp := [ ] ;
68174: LD_ADDR_VAR 0 3
68178: PUSH
68179: EMPTY
68180: ST_TO_ADDR
// list := [ ] ;
68181: LD_ADDR_VAR 0 5
68185: PUSH
68186: EMPTY
68187: ST_TO_ADDR
// for i = 16 to 25 do
68188: LD_ADDR_VAR 0 4
68192: PUSH
68193: DOUBLE
68194: LD_INT 16
68196: DEC
68197: ST_TO_ADDR
68198: LD_INT 25
68200: PUSH
68201: FOR_TO
68202: IFFALSE 68275
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68204: LD_ADDR_VAR 0 3
68208: PUSH
68209: LD_VAR 0 3
68213: PUSH
68214: LD_INT 22
68216: PUSH
68217: LD_VAR 0 1
68221: PPUSH
68222: CALL_OW 255
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 91
68233: PUSH
68234: LD_VAR 0 1
68238: PUSH
68239: LD_INT 6
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 30
68249: PUSH
68250: LD_VAR 0 4
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: LIST
68263: PUSH
68264: EMPTY
68265: LIST
68266: PPUSH
68267: CALL_OW 69
68271: ADD
68272: ST_TO_ADDR
68273: GO 68201
68275: POP
68276: POP
// for i = 1 to tmp do
68277: LD_ADDR_VAR 0 4
68281: PUSH
68282: DOUBLE
68283: LD_INT 1
68285: DEC
68286: ST_TO_ADDR
68287: LD_VAR 0 3
68291: PUSH
68292: FOR_TO
68293: IFFALSE 68381
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68295: LD_ADDR_VAR 0 5
68299: PUSH
68300: LD_VAR 0 5
68304: PUSH
68305: LD_VAR 0 3
68309: PUSH
68310: LD_VAR 0 4
68314: ARRAY
68315: PPUSH
68316: CALL_OW 266
68320: PUSH
68321: LD_VAR 0 3
68325: PUSH
68326: LD_VAR 0 4
68330: ARRAY
68331: PPUSH
68332: CALL_OW 250
68336: PUSH
68337: LD_VAR 0 3
68341: PUSH
68342: LD_VAR 0 4
68346: ARRAY
68347: PPUSH
68348: CALL_OW 251
68352: PUSH
68353: LD_VAR 0 3
68357: PUSH
68358: LD_VAR 0 4
68362: ARRAY
68363: PPUSH
68364: CALL_OW 254
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: LIST
68373: LIST
68374: PUSH
68375: EMPTY
68376: LIST
68377: ADD
68378: ST_TO_ADDR
68379: GO 68292
68381: POP
68382: POP
// result := list ;
68383: LD_ADDR_VAR 0 2
68387: PUSH
68388: LD_VAR 0 5
68392: ST_TO_ADDR
// end ;
68393: LD_VAR 0 2
68397: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68398: LD_INT 0
68400: PPUSH
68401: PPUSH
68402: PPUSH
68403: PPUSH
68404: PPUSH
68405: PPUSH
68406: PPUSH
// if not factory then
68407: LD_VAR 0 1
68411: NOT
68412: IFFALSE 68416
// exit ;
68414: GO 69009
// if control = control_apeman then
68416: LD_VAR 0 4
68420: PUSH
68421: LD_INT 5
68423: EQUAL
68424: IFFALSE 68533
// begin tmp := UnitsInside ( factory ) ;
68426: LD_ADDR_VAR 0 8
68430: PUSH
68431: LD_VAR 0 1
68435: PPUSH
68436: CALL_OW 313
68440: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68441: LD_VAR 0 8
68445: PPUSH
68446: LD_INT 25
68448: PUSH
68449: LD_INT 12
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PPUSH
68456: CALL_OW 72
68460: NOT
68461: IFFALSE 68471
// control := control_manual ;
68463: LD_ADDR_VAR 0 4
68467: PUSH
68468: LD_INT 1
68470: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68471: LD_ADDR_VAR 0 8
68475: PUSH
68476: LD_VAR 0 1
68480: PPUSH
68481: CALL 68168 0 1
68485: ST_TO_ADDR
// if tmp then
68486: LD_VAR 0 8
68490: IFFALSE 68533
// begin for i in tmp do
68492: LD_ADDR_VAR 0 7
68496: PUSH
68497: LD_VAR 0 8
68501: PUSH
68502: FOR_IN
68503: IFFALSE 68531
// if i [ 1 ] = b_ext_radio then
68505: LD_VAR 0 7
68509: PUSH
68510: LD_INT 1
68512: ARRAY
68513: PUSH
68514: LD_INT 22
68516: EQUAL
68517: IFFALSE 68529
// begin control := control_remote ;
68519: LD_ADDR_VAR 0 4
68523: PUSH
68524: LD_INT 2
68526: ST_TO_ADDR
// break ;
68527: GO 68531
// end ;
68529: GO 68502
68531: POP
68532: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68533: LD_VAR 0 1
68537: PPUSH
68538: LD_VAR 0 2
68542: PPUSH
68543: LD_VAR 0 3
68547: PPUSH
68548: LD_VAR 0 4
68552: PPUSH
68553: LD_VAR 0 5
68557: PPUSH
68558: CALL_OW 448
68562: IFFALSE 68597
// begin result := [ chassis , engine , control , weapon ] ;
68564: LD_ADDR_VAR 0 6
68568: PUSH
68569: LD_VAR 0 2
68573: PUSH
68574: LD_VAR 0 3
68578: PUSH
68579: LD_VAR 0 4
68583: PUSH
68584: LD_VAR 0 5
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: ST_TO_ADDR
// exit ;
68595: GO 69009
// end ; _chassis := AvailableChassisList ( factory ) ;
68597: LD_ADDR_VAR 0 9
68601: PUSH
68602: LD_VAR 0 1
68606: PPUSH
68607: CALL_OW 475
68611: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68612: LD_ADDR_VAR 0 11
68616: PUSH
68617: LD_VAR 0 1
68621: PPUSH
68622: CALL_OW 476
68626: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68627: LD_ADDR_VAR 0 12
68631: PUSH
68632: LD_VAR 0 1
68636: PPUSH
68637: CALL_OW 477
68641: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68642: LD_ADDR_VAR 0 10
68646: PUSH
68647: LD_VAR 0 1
68651: PPUSH
68652: CALL_OW 478
68656: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68657: LD_VAR 0 9
68661: NOT
68662: PUSH
68663: LD_VAR 0 11
68667: NOT
68668: OR
68669: PUSH
68670: LD_VAR 0 12
68674: NOT
68675: OR
68676: PUSH
68677: LD_VAR 0 10
68681: NOT
68682: OR
68683: IFFALSE 68718
// begin result := [ chassis , engine , control , weapon ] ;
68685: LD_ADDR_VAR 0 6
68689: PUSH
68690: LD_VAR 0 2
68694: PUSH
68695: LD_VAR 0 3
68699: PUSH
68700: LD_VAR 0 4
68704: PUSH
68705: LD_VAR 0 5
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: ST_TO_ADDR
// exit ;
68716: GO 69009
// end ; if not chassis in _chassis then
68718: LD_VAR 0 2
68722: PUSH
68723: LD_VAR 0 9
68727: IN
68728: NOT
68729: IFFALSE 68755
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68731: LD_ADDR_VAR 0 2
68735: PUSH
68736: LD_VAR 0 9
68740: PUSH
68741: LD_INT 1
68743: PPUSH
68744: LD_VAR 0 9
68748: PPUSH
68749: CALL_OW 12
68753: ARRAY
68754: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68755: LD_VAR 0 2
68759: PPUSH
68760: LD_VAR 0 3
68764: PPUSH
68765: CALL 69014 0 2
68769: NOT
68770: IFFALSE 68829
// repeat engine := _engine [ 1 ] ;
68772: LD_ADDR_VAR 0 3
68776: PUSH
68777: LD_VAR 0 11
68781: PUSH
68782: LD_INT 1
68784: ARRAY
68785: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68786: LD_ADDR_VAR 0 11
68790: PUSH
68791: LD_VAR 0 11
68795: PPUSH
68796: LD_INT 1
68798: PPUSH
68799: CALL_OW 3
68803: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68804: LD_VAR 0 2
68808: PPUSH
68809: LD_VAR 0 3
68813: PPUSH
68814: CALL 69014 0 2
68818: PUSH
68819: LD_VAR 0 11
68823: PUSH
68824: EMPTY
68825: EQUAL
68826: OR
68827: IFFALSE 68772
// if not control in _control then
68829: LD_VAR 0 4
68833: PUSH
68834: LD_VAR 0 12
68838: IN
68839: NOT
68840: IFFALSE 68866
// control := _control [ rand ( 1 , _control ) ] ;
68842: LD_ADDR_VAR 0 4
68846: PUSH
68847: LD_VAR 0 12
68851: PUSH
68852: LD_INT 1
68854: PPUSH
68855: LD_VAR 0 12
68859: PPUSH
68860: CALL_OW 12
68864: ARRAY
68865: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68866: LD_VAR 0 2
68870: PPUSH
68871: LD_VAR 0 5
68875: PPUSH
68876: CALL 69234 0 2
68880: NOT
68881: IFFALSE 68940
// repeat weapon := _weapon [ 1 ] ;
68883: LD_ADDR_VAR 0 5
68887: PUSH
68888: LD_VAR 0 10
68892: PUSH
68893: LD_INT 1
68895: ARRAY
68896: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68897: LD_ADDR_VAR 0 10
68901: PUSH
68902: LD_VAR 0 10
68906: PPUSH
68907: LD_INT 1
68909: PPUSH
68910: CALL_OW 3
68914: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68915: LD_VAR 0 2
68919: PPUSH
68920: LD_VAR 0 5
68924: PPUSH
68925: CALL 69234 0 2
68929: PUSH
68930: LD_VAR 0 10
68934: PUSH
68935: EMPTY
68936: EQUAL
68937: OR
68938: IFFALSE 68883
// result := [ ] ;
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: EMPTY
68946: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68947: LD_VAR 0 1
68951: PPUSH
68952: LD_VAR 0 2
68956: PPUSH
68957: LD_VAR 0 3
68961: PPUSH
68962: LD_VAR 0 4
68966: PPUSH
68967: LD_VAR 0 5
68971: PPUSH
68972: CALL_OW 448
68976: IFFALSE 69009
// result := [ chassis , engine , control , weapon ] ;
68978: LD_ADDR_VAR 0 6
68982: PUSH
68983: LD_VAR 0 2
68987: PUSH
68988: LD_VAR 0 3
68992: PUSH
68993: LD_VAR 0 4
68997: PUSH
68998: LD_VAR 0 5
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: LIST
69007: LIST
69008: ST_TO_ADDR
// end ;
69009: LD_VAR 0 6
69013: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69014: LD_INT 0
69016: PPUSH
// if not chassis or not engine then
69017: LD_VAR 0 1
69021: NOT
69022: PUSH
69023: LD_VAR 0 2
69027: NOT
69028: OR
69029: IFFALSE 69033
// exit ;
69031: GO 69229
// case engine of engine_solar :
69033: LD_VAR 0 2
69037: PUSH
69038: LD_INT 2
69040: DOUBLE
69041: EQUAL
69042: IFTRUE 69046
69044: GO 69084
69046: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69047: LD_ADDR_VAR 0 3
69051: PUSH
69052: LD_INT 11
69054: PUSH
69055: LD_INT 12
69057: PUSH
69058: LD_INT 13
69060: PUSH
69061: LD_INT 14
69063: PUSH
69064: LD_INT 1
69066: PUSH
69067: LD_INT 2
69069: PUSH
69070: LD_INT 3
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: ST_TO_ADDR
69082: GO 69213
69084: LD_INT 1
69086: DOUBLE
69087: EQUAL
69088: IFTRUE 69092
69090: GO 69154
69092: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69093: LD_ADDR_VAR 0 3
69097: PUSH
69098: LD_INT 11
69100: PUSH
69101: LD_INT 12
69103: PUSH
69104: LD_INT 13
69106: PUSH
69107: LD_INT 14
69109: PUSH
69110: LD_INT 1
69112: PUSH
69113: LD_INT 2
69115: PUSH
69116: LD_INT 3
69118: PUSH
69119: LD_INT 4
69121: PUSH
69122: LD_INT 5
69124: PUSH
69125: LD_INT 21
69127: PUSH
69128: LD_INT 23
69130: PUSH
69131: LD_INT 22
69133: PUSH
69134: LD_INT 24
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: ST_TO_ADDR
69152: GO 69213
69154: LD_INT 3
69156: DOUBLE
69157: EQUAL
69158: IFTRUE 69162
69160: GO 69212
69162: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69163: LD_ADDR_VAR 0 3
69167: PUSH
69168: LD_INT 13
69170: PUSH
69171: LD_INT 14
69173: PUSH
69174: LD_INT 2
69176: PUSH
69177: LD_INT 3
69179: PUSH
69180: LD_INT 4
69182: PUSH
69183: LD_INT 5
69185: PUSH
69186: LD_INT 21
69188: PUSH
69189: LD_INT 22
69191: PUSH
69192: LD_INT 23
69194: PUSH
69195: LD_INT 24
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: LIST
69206: LIST
69207: LIST
69208: LIST
69209: ST_TO_ADDR
69210: GO 69213
69212: POP
// result := ( chassis in result ) ;
69213: LD_ADDR_VAR 0 3
69217: PUSH
69218: LD_VAR 0 1
69222: PUSH
69223: LD_VAR 0 3
69227: IN
69228: ST_TO_ADDR
// end ;
69229: LD_VAR 0 3
69233: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69234: LD_INT 0
69236: PPUSH
// if not chassis or not weapon then
69237: LD_VAR 0 1
69241: NOT
69242: PUSH
69243: LD_VAR 0 2
69247: NOT
69248: OR
69249: IFFALSE 69253
// exit ;
69251: GO 70315
// case weapon of us_machine_gun :
69253: LD_VAR 0 2
69257: PUSH
69258: LD_INT 2
69260: DOUBLE
69261: EQUAL
69262: IFTRUE 69266
69264: GO 69296
69266: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69267: LD_ADDR_VAR 0 3
69271: PUSH
69272: LD_INT 1
69274: PUSH
69275: LD_INT 2
69277: PUSH
69278: LD_INT 3
69280: PUSH
69281: LD_INT 4
69283: PUSH
69284: LD_INT 5
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: ST_TO_ADDR
69294: GO 70299
69296: LD_INT 3
69298: DOUBLE
69299: EQUAL
69300: IFTRUE 69304
69302: GO 69334
69304: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69305: LD_ADDR_VAR 0 3
69309: PUSH
69310: LD_INT 1
69312: PUSH
69313: LD_INT 2
69315: PUSH
69316: LD_INT 3
69318: PUSH
69319: LD_INT 4
69321: PUSH
69322: LD_INT 5
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: ST_TO_ADDR
69332: GO 70299
69334: LD_INT 11
69336: DOUBLE
69337: EQUAL
69338: IFTRUE 69342
69340: GO 69372
69342: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69343: LD_ADDR_VAR 0 3
69347: PUSH
69348: LD_INT 1
69350: PUSH
69351: LD_INT 2
69353: PUSH
69354: LD_INT 3
69356: PUSH
69357: LD_INT 4
69359: PUSH
69360: LD_INT 5
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: LIST
69367: LIST
69368: LIST
69369: ST_TO_ADDR
69370: GO 70299
69372: LD_INT 4
69374: DOUBLE
69375: EQUAL
69376: IFTRUE 69380
69378: GO 69406
69380: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69381: LD_ADDR_VAR 0 3
69385: PUSH
69386: LD_INT 2
69388: PUSH
69389: LD_INT 3
69391: PUSH
69392: LD_INT 4
69394: PUSH
69395: LD_INT 5
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: ST_TO_ADDR
69404: GO 70299
69406: LD_INT 5
69408: DOUBLE
69409: EQUAL
69410: IFTRUE 69414
69412: GO 69440
69414: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69415: LD_ADDR_VAR 0 3
69419: PUSH
69420: LD_INT 2
69422: PUSH
69423: LD_INT 3
69425: PUSH
69426: LD_INT 4
69428: PUSH
69429: LD_INT 5
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: ST_TO_ADDR
69438: GO 70299
69440: LD_INT 9
69442: DOUBLE
69443: EQUAL
69444: IFTRUE 69448
69446: GO 69474
69448: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69449: LD_ADDR_VAR 0 3
69453: PUSH
69454: LD_INT 2
69456: PUSH
69457: LD_INT 3
69459: PUSH
69460: LD_INT 4
69462: PUSH
69463: LD_INT 5
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: ST_TO_ADDR
69472: GO 70299
69474: LD_INT 7
69476: DOUBLE
69477: EQUAL
69478: IFTRUE 69482
69480: GO 69508
69482: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69483: LD_ADDR_VAR 0 3
69487: PUSH
69488: LD_INT 2
69490: PUSH
69491: LD_INT 3
69493: PUSH
69494: LD_INT 4
69496: PUSH
69497: LD_INT 5
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: ST_TO_ADDR
69506: GO 70299
69508: LD_INT 12
69510: DOUBLE
69511: EQUAL
69512: IFTRUE 69516
69514: GO 69542
69516: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69517: LD_ADDR_VAR 0 3
69521: PUSH
69522: LD_INT 2
69524: PUSH
69525: LD_INT 3
69527: PUSH
69528: LD_INT 4
69530: PUSH
69531: LD_INT 5
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: LIST
69538: LIST
69539: ST_TO_ADDR
69540: GO 70299
69542: LD_INT 13
69544: DOUBLE
69545: EQUAL
69546: IFTRUE 69550
69548: GO 69576
69550: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69551: LD_ADDR_VAR 0 3
69555: PUSH
69556: LD_INT 2
69558: PUSH
69559: LD_INT 3
69561: PUSH
69562: LD_INT 4
69564: PUSH
69565: LD_INT 5
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: ST_TO_ADDR
69574: GO 70299
69576: LD_INT 14
69578: DOUBLE
69579: EQUAL
69580: IFTRUE 69584
69582: GO 69602
69584: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69585: LD_ADDR_VAR 0 3
69589: PUSH
69590: LD_INT 4
69592: PUSH
69593: LD_INT 5
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: ST_TO_ADDR
69600: GO 70299
69602: LD_INT 6
69604: DOUBLE
69605: EQUAL
69606: IFTRUE 69610
69608: GO 69628
69610: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69611: LD_ADDR_VAR 0 3
69615: PUSH
69616: LD_INT 4
69618: PUSH
69619: LD_INT 5
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: ST_TO_ADDR
69626: GO 70299
69628: LD_INT 10
69630: DOUBLE
69631: EQUAL
69632: IFTRUE 69636
69634: GO 69654
69636: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69637: LD_ADDR_VAR 0 3
69641: PUSH
69642: LD_INT 4
69644: PUSH
69645: LD_INT 5
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: ST_TO_ADDR
69652: GO 70299
69654: LD_INT 22
69656: DOUBLE
69657: EQUAL
69658: IFTRUE 69662
69660: GO 69688
69662: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69663: LD_ADDR_VAR 0 3
69667: PUSH
69668: LD_INT 11
69670: PUSH
69671: LD_INT 12
69673: PUSH
69674: LD_INT 13
69676: PUSH
69677: LD_INT 14
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: ST_TO_ADDR
69686: GO 70299
69688: LD_INT 23
69690: DOUBLE
69691: EQUAL
69692: IFTRUE 69696
69694: GO 69722
69696: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69697: LD_ADDR_VAR 0 3
69701: PUSH
69702: LD_INT 11
69704: PUSH
69705: LD_INT 12
69707: PUSH
69708: LD_INT 13
69710: PUSH
69711: LD_INT 14
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: ST_TO_ADDR
69720: GO 70299
69722: LD_INT 24
69724: DOUBLE
69725: EQUAL
69726: IFTRUE 69730
69728: GO 69756
69730: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69731: LD_ADDR_VAR 0 3
69735: PUSH
69736: LD_INT 11
69738: PUSH
69739: LD_INT 12
69741: PUSH
69742: LD_INT 13
69744: PUSH
69745: LD_INT 14
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: ST_TO_ADDR
69754: GO 70299
69756: LD_INT 30
69758: DOUBLE
69759: EQUAL
69760: IFTRUE 69764
69762: GO 69790
69764: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69765: LD_ADDR_VAR 0 3
69769: PUSH
69770: LD_INT 11
69772: PUSH
69773: LD_INT 12
69775: PUSH
69776: LD_INT 13
69778: PUSH
69779: LD_INT 14
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: LIST
69786: LIST
69787: ST_TO_ADDR
69788: GO 70299
69790: LD_INT 25
69792: DOUBLE
69793: EQUAL
69794: IFTRUE 69798
69796: GO 69816
69798: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69799: LD_ADDR_VAR 0 3
69803: PUSH
69804: LD_INT 13
69806: PUSH
69807: LD_INT 14
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: ST_TO_ADDR
69814: GO 70299
69816: LD_INT 27
69818: DOUBLE
69819: EQUAL
69820: IFTRUE 69824
69822: GO 69842
69824: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69825: LD_ADDR_VAR 0 3
69829: PUSH
69830: LD_INT 13
69832: PUSH
69833: LD_INT 14
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: ST_TO_ADDR
69840: GO 70299
69842: LD_EXP 100
69846: DOUBLE
69847: EQUAL
69848: IFTRUE 69852
69850: GO 69878
69852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69853: LD_ADDR_VAR 0 3
69857: PUSH
69858: LD_INT 11
69860: PUSH
69861: LD_INT 12
69863: PUSH
69864: LD_INT 13
69866: PUSH
69867: LD_INT 14
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: ST_TO_ADDR
69876: GO 70299
69878: LD_INT 28
69880: DOUBLE
69881: EQUAL
69882: IFTRUE 69886
69884: GO 69904
69886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69887: LD_ADDR_VAR 0 3
69891: PUSH
69892: LD_INT 13
69894: PUSH
69895: LD_INT 14
69897: PUSH
69898: EMPTY
69899: LIST
69900: LIST
69901: ST_TO_ADDR
69902: GO 70299
69904: LD_INT 29
69906: DOUBLE
69907: EQUAL
69908: IFTRUE 69912
69910: GO 69930
69912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69913: LD_ADDR_VAR 0 3
69917: PUSH
69918: LD_INT 13
69920: PUSH
69921: LD_INT 14
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: ST_TO_ADDR
69928: GO 70299
69930: LD_INT 31
69932: DOUBLE
69933: EQUAL
69934: IFTRUE 69938
69936: GO 69956
69938: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69939: LD_ADDR_VAR 0 3
69943: PUSH
69944: LD_INT 13
69946: PUSH
69947: LD_INT 14
69949: PUSH
69950: EMPTY
69951: LIST
69952: LIST
69953: ST_TO_ADDR
69954: GO 70299
69956: LD_INT 26
69958: DOUBLE
69959: EQUAL
69960: IFTRUE 69964
69962: GO 69982
69964: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69965: LD_ADDR_VAR 0 3
69969: PUSH
69970: LD_INT 13
69972: PUSH
69973: LD_INT 14
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: ST_TO_ADDR
69980: GO 70299
69982: LD_INT 42
69984: DOUBLE
69985: EQUAL
69986: IFTRUE 69990
69988: GO 70016
69990: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69991: LD_ADDR_VAR 0 3
69995: PUSH
69996: LD_INT 21
69998: PUSH
69999: LD_INT 22
70001: PUSH
70002: LD_INT 23
70004: PUSH
70005: LD_INT 24
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: ST_TO_ADDR
70014: GO 70299
70016: LD_INT 43
70018: DOUBLE
70019: EQUAL
70020: IFTRUE 70024
70022: GO 70050
70024: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70025: LD_ADDR_VAR 0 3
70029: PUSH
70030: LD_INT 21
70032: PUSH
70033: LD_INT 22
70035: PUSH
70036: LD_INT 23
70038: PUSH
70039: LD_INT 24
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: ST_TO_ADDR
70048: GO 70299
70050: LD_INT 44
70052: DOUBLE
70053: EQUAL
70054: IFTRUE 70058
70056: GO 70084
70058: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70059: LD_ADDR_VAR 0 3
70063: PUSH
70064: LD_INT 21
70066: PUSH
70067: LD_INT 22
70069: PUSH
70070: LD_INT 23
70072: PUSH
70073: LD_INT 24
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: ST_TO_ADDR
70082: GO 70299
70084: LD_INT 45
70086: DOUBLE
70087: EQUAL
70088: IFTRUE 70092
70090: GO 70118
70092: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70093: LD_ADDR_VAR 0 3
70097: PUSH
70098: LD_INT 21
70100: PUSH
70101: LD_INT 22
70103: PUSH
70104: LD_INT 23
70106: PUSH
70107: LD_INT 24
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: LIST
70114: LIST
70115: ST_TO_ADDR
70116: GO 70299
70118: LD_INT 49
70120: DOUBLE
70121: EQUAL
70122: IFTRUE 70126
70124: GO 70152
70126: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70127: LD_ADDR_VAR 0 3
70131: PUSH
70132: LD_INT 21
70134: PUSH
70135: LD_INT 22
70137: PUSH
70138: LD_INT 23
70140: PUSH
70141: LD_INT 24
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: ST_TO_ADDR
70150: GO 70299
70152: LD_INT 51
70154: DOUBLE
70155: EQUAL
70156: IFTRUE 70160
70158: GO 70186
70160: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70161: LD_ADDR_VAR 0 3
70165: PUSH
70166: LD_INT 21
70168: PUSH
70169: LD_INT 22
70171: PUSH
70172: LD_INT 23
70174: PUSH
70175: LD_INT 24
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: LIST
70182: LIST
70183: ST_TO_ADDR
70184: GO 70299
70186: LD_INT 52
70188: DOUBLE
70189: EQUAL
70190: IFTRUE 70194
70192: GO 70220
70194: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70195: LD_ADDR_VAR 0 3
70199: PUSH
70200: LD_INT 21
70202: PUSH
70203: LD_INT 22
70205: PUSH
70206: LD_INT 23
70208: PUSH
70209: LD_INT 24
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: LIST
70216: LIST
70217: ST_TO_ADDR
70218: GO 70299
70220: LD_INT 53
70222: DOUBLE
70223: EQUAL
70224: IFTRUE 70228
70226: GO 70246
70228: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70229: LD_ADDR_VAR 0 3
70233: PUSH
70234: LD_INT 23
70236: PUSH
70237: LD_INT 24
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: ST_TO_ADDR
70244: GO 70299
70246: LD_INT 46
70248: DOUBLE
70249: EQUAL
70250: IFTRUE 70254
70252: GO 70272
70254: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70255: LD_ADDR_VAR 0 3
70259: PUSH
70260: LD_INT 23
70262: PUSH
70263: LD_INT 24
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: ST_TO_ADDR
70270: GO 70299
70272: LD_INT 47
70274: DOUBLE
70275: EQUAL
70276: IFTRUE 70280
70278: GO 70298
70280: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70281: LD_ADDR_VAR 0 3
70285: PUSH
70286: LD_INT 23
70288: PUSH
70289: LD_INT 24
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: ST_TO_ADDR
70296: GO 70299
70298: POP
// result := ( chassis in result ) ;
70299: LD_ADDR_VAR 0 3
70303: PUSH
70304: LD_VAR 0 1
70308: PUSH
70309: LD_VAR 0 3
70313: IN
70314: ST_TO_ADDR
// end ;
70315: LD_VAR 0 3
70319: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70320: LD_INT 0
70322: PPUSH
70323: PPUSH
70324: PPUSH
70325: PPUSH
70326: PPUSH
70327: PPUSH
70328: PPUSH
// result := array ;
70329: LD_ADDR_VAR 0 5
70333: PUSH
70334: LD_VAR 0 1
70338: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70339: LD_VAR 0 1
70343: NOT
70344: PUSH
70345: LD_VAR 0 2
70349: NOT
70350: OR
70351: PUSH
70352: LD_VAR 0 3
70356: NOT
70357: OR
70358: PUSH
70359: LD_VAR 0 2
70363: PUSH
70364: LD_VAR 0 1
70368: GREATER
70369: OR
70370: PUSH
70371: LD_VAR 0 3
70375: PUSH
70376: LD_VAR 0 1
70380: GREATER
70381: OR
70382: IFFALSE 70386
// exit ;
70384: GO 70682
// if direction then
70386: LD_VAR 0 4
70390: IFFALSE 70454
// begin d := 1 ;
70392: LD_ADDR_VAR 0 9
70396: PUSH
70397: LD_INT 1
70399: ST_TO_ADDR
// if i_from > i_to then
70400: LD_VAR 0 2
70404: PUSH
70405: LD_VAR 0 3
70409: GREATER
70410: IFFALSE 70436
// length := ( array - i_from ) + i_to else
70412: LD_ADDR_VAR 0 11
70416: PUSH
70417: LD_VAR 0 1
70421: PUSH
70422: LD_VAR 0 2
70426: MINUS
70427: PUSH
70428: LD_VAR 0 3
70432: PLUS
70433: ST_TO_ADDR
70434: GO 70452
// length := i_to - i_from ;
70436: LD_ADDR_VAR 0 11
70440: PUSH
70441: LD_VAR 0 3
70445: PUSH
70446: LD_VAR 0 2
70450: MINUS
70451: ST_TO_ADDR
// end else
70452: GO 70515
// begin d := - 1 ;
70454: LD_ADDR_VAR 0 9
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: ST_TO_ADDR
// if i_from > i_to then
70463: LD_VAR 0 2
70467: PUSH
70468: LD_VAR 0 3
70472: GREATER
70473: IFFALSE 70493
// length := i_from - i_to else
70475: LD_ADDR_VAR 0 11
70479: PUSH
70480: LD_VAR 0 2
70484: PUSH
70485: LD_VAR 0 3
70489: MINUS
70490: ST_TO_ADDR
70491: GO 70515
// length := ( array - i_to ) + i_from ;
70493: LD_ADDR_VAR 0 11
70497: PUSH
70498: LD_VAR 0 1
70502: PUSH
70503: LD_VAR 0 3
70507: MINUS
70508: PUSH
70509: LD_VAR 0 2
70513: PLUS
70514: ST_TO_ADDR
// end ; if not length then
70515: LD_VAR 0 11
70519: NOT
70520: IFFALSE 70524
// exit ;
70522: GO 70682
// tmp := array ;
70524: LD_ADDR_VAR 0 10
70528: PUSH
70529: LD_VAR 0 1
70533: ST_TO_ADDR
// for i = 1 to length do
70534: LD_ADDR_VAR 0 6
70538: PUSH
70539: DOUBLE
70540: LD_INT 1
70542: DEC
70543: ST_TO_ADDR
70544: LD_VAR 0 11
70548: PUSH
70549: FOR_TO
70550: IFFALSE 70670
// begin for j = 1 to array do
70552: LD_ADDR_VAR 0 7
70556: PUSH
70557: DOUBLE
70558: LD_INT 1
70560: DEC
70561: ST_TO_ADDR
70562: LD_VAR 0 1
70566: PUSH
70567: FOR_TO
70568: IFFALSE 70656
// begin k := j + d ;
70570: LD_ADDR_VAR 0 8
70574: PUSH
70575: LD_VAR 0 7
70579: PUSH
70580: LD_VAR 0 9
70584: PLUS
70585: ST_TO_ADDR
// if k > array then
70586: LD_VAR 0 8
70590: PUSH
70591: LD_VAR 0 1
70595: GREATER
70596: IFFALSE 70606
// k := 1 ;
70598: LD_ADDR_VAR 0 8
70602: PUSH
70603: LD_INT 1
70605: ST_TO_ADDR
// if not k then
70606: LD_VAR 0 8
70610: NOT
70611: IFFALSE 70623
// k := array ;
70613: LD_ADDR_VAR 0 8
70617: PUSH
70618: LD_VAR 0 1
70622: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70623: LD_ADDR_VAR 0 10
70627: PUSH
70628: LD_VAR 0 10
70632: PPUSH
70633: LD_VAR 0 8
70637: PPUSH
70638: LD_VAR 0 1
70642: PUSH
70643: LD_VAR 0 7
70647: ARRAY
70648: PPUSH
70649: CALL_OW 1
70653: ST_TO_ADDR
// end ;
70654: GO 70567
70656: POP
70657: POP
// array := tmp ;
70658: LD_ADDR_VAR 0 1
70662: PUSH
70663: LD_VAR 0 10
70667: ST_TO_ADDR
// end ;
70668: GO 70549
70670: POP
70671: POP
// result := array ;
70672: LD_ADDR_VAR 0 5
70676: PUSH
70677: LD_VAR 0 1
70681: ST_TO_ADDR
// end ;
70682: LD_VAR 0 5
70686: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70687: LD_INT 0
70689: PPUSH
70690: PPUSH
// result := 0 ;
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: LD_INT 0
70698: ST_TO_ADDR
// if not array or not value in array then
70699: LD_VAR 0 1
70703: NOT
70704: PUSH
70705: LD_VAR 0 2
70709: PUSH
70710: LD_VAR 0 1
70714: IN
70715: NOT
70716: OR
70717: IFFALSE 70721
// exit ;
70719: GO 70775
// for i = 1 to array do
70721: LD_ADDR_VAR 0 4
70725: PUSH
70726: DOUBLE
70727: LD_INT 1
70729: DEC
70730: ST_TO_ADDR
70731: LD_VAR 0 1
70735: PUSH
70736: FOR_TO
70737: IFFALSE 70773
// if value = array [ i ] then
70739: LD_VAR 0 2
70743: PUSH
70744: LD_VAR 0 1
70748: PUSH
70749: LD_VAR 0 4
70753: ARRAY
70754: EQUAL
70755: IFFALSE 70771
// begin result := i ;
70757: LD_ADDR_VAR 0 3
70761: PUSH
70762: LD_VAR 0 4
70766: ST_TO_ADDR
// exit ;
70767: POP
70768: POP
70769: GO 70775
// end ;
70771: GO 70736
70773: POP
70774: POP
// end ;
70775: LD_VAR 0 3
70779: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70780: LD_INT 0
70782: PPUSH
// vc_chassis := chassis ;
70783: LD_ADDR_OWVAR 37
70787: PUSH
70788: LD_VAR 0 1
70792: ST_TO_ADDR
// vc_engine := engine ;
70793: LD_ADDR_OWVAR 39
70797: PUSH
70798: LD_VAR 0 2
70802: ST_TO_ADDR
// vc_control := control ;
70803: LD_ADDR_OWVAR 38
70807: PUSH
70808: LD_VAR 0 3
70812: ST_TO_ADDR
// vc_weapon := weapon ;
70813: LD_ADDR_OWVAR 40
70817: PUSH
70818: LD_VAR 0 4
70822: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70823: LD_ADDR_OWVAR 41
70827: PUSH
70828: LD_VAR 0 5
70832: ST_TO_ADDR
// end ;
70833: LD_VAR 0 6
70837: RET
// export function WantPlant ( unit ) ; var task ; begin
70838: LD_INT 0
70840: PPUSH
70841: PPUSH
// result := false ;
70842: LD_ADDR_VAR 0 2
70846: PUSH
70847: LD_INT 0
70849: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70850: LD_ADDR_VAR 0 3
70854: PUSH
70855: LD_VAR 0 1
70859: PPUSH
70860: CALL_OW 437
70864: ST_TO_ADDR
// if task then
70865: LD_VAR 0 3
70869: IFFALSE 70897
// if task [ 1 ] [ 1 ] = p then
70871: LD_VAR 0 3
70875: PUSH
70876: LD_INT 1
70878: ARRAY
70879: PUSH
70880: LD_INT 1
70882: ARRAY
70883: PUSH
70884: LD_STRING p
70886: EQUAL
70887: IFFALSE 70897
// result := true ;
70889: LD_ADDR_VAR 0 2
70893: PUSH
70894: LD_INT 1
70896: ST_TO_ADDR
// end ;
70897: LD_VAR 0 2
70901: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70902: LD_INT 0
70904: PPUSH
70905: PPUSH
70906: PPUSH
70907: PPUSH
// if pos < 1 then
70908: LD_VAR 0 2
70912: PUSH
70913: LD_INT 1
70915: LESS
70916: IFFALSE 70920
// exit ;
70918: GO 71223
// if pos = 1 then
70920: LD_VAR 0 2
70924: PUSH
70925: LD_INT 1
70927: EQUAL
70928: IFFALSE 70961
// result := Replace ( arr , pos [ 1 ] , value ) else
70930: LD_ADDR_VAR 0 4
70934: PUSH
70935: LD_VAR 0 1
70939: PPUSH
70940: LD_VAR 0 2
70944: PUSH
70945: LD_INT 1
70947: ARRAY
70948: PPUSH
70949: LD_VAR 0 3
70953: PPUSH
70954: CALL_OW 1
70958: ST_TO_ADDR
70959: GO 71223
// begin tmp := arr ;
70961: LD_ADDR_VAR 0 6
70965: PUSH
70966: LD_VAR 0 1
70970: ST_TO_ADDR
// s_arr := [ tmp ] ;
70971: LD_ADDR_VAR 0 7
70975: PUSH
70976: LD_VAR 0 6
70980: PUSH
70981: EMPTY
70982: LIST
70983: ST_TO_ADDR
// for i = 1 to pos - 1 do
70984: LD_ADDR_VAR 0 5
70988: PUSH
70989: DOUBLE
70990: LD_INT 1
70992: DEC
70993: ST_TO_ADDR
70994: LD_VAR 0 2
70998: PUSH
70999: LD_INT 1
71001: MINUS
71002: PUSH
71003: FOR_TO
71004: IFFALSE 71049
// begin tmp := tmp [ pos [ i ] ] ;
71006: LD_ADDR_VAR 0 6
71010: PUSH
71011: LD_VAR 0 6
71015: PUSH
71016: LD_VAR 0 2
71020: PUSH
71021: LD_VAR 0 5
71025: ARRAY
71026: ARRAY
71027: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71028: LD_ADDR_VAR 0 7
71032: PUSH
71033: LD_VAR 0 7
71037: PUSH
71038: LD_VAR 0 6
71042: PUSH
71043: EMPTY
71044: LIST
71045: ADD
71046: ST_TO_ADDR
// end ;
71047: GO 71003
71049: POP
71050: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71051: LD_ADDR_VAR 0 6
71055: PUSH
71056: LD_VAR 0 6
71060: PPUSH
71061: LD_VAR 0 2
71065: PUSH
71066: LD_VAR 0 2
71070: ARRAY
71071: PPUSH
71072: LD_VAR 0 3
71076: PPUSH
71077: CALL_OW 1
71081: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71082: LD_ADDR_VAR 0 7
71086: PUSH
71087: LD_VAR 0 7
71091: PPUSH
71092: LD_VAR 0 7
71096: PPUSH
71097: LD_VAR 0 6
71101: PPUSH
71102: CALL_OW 1
71106: ST_TO_ADDR
// for i = s_arr downto 2 do
71107: LD_ADDR_VAR 0 5
71111: PUSH
71112: DOUBLE
71113: LD_VAR 0 7
71117: INC
71118: ST_TO_ADDR
71119: LD_INT 2
71121: PUSH
71122: FOR_DOWNTO
71123: IFFALSE 71207
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71125: LD_ADDR_VAR 0 6
71129: PUSH
71130: LD_VAR 0 7
71134: PUSH
71135: LD_VAR 0 5
71139: PUSH
71140: LD_INT 1
71142: MINUS
71143: ARRAY
71144: PPUSH
71145: LD_VAR 0 2
71149: PUSH
71150: LD_VAR 0 5
71154: PUSH
71155: LD_INT 1
71157: MINUS
71158: ARRAY
71159: PPUSH
71160: LD_VAR 0 7
71164: PUSH
71165: LD_VAR 0 5
71169: ARRAY
71170: PPUSH
71171: CALL_OW 1
71175: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71176: LD_ADDR_VAR 0 7
71180: PUSH
71181: LD_VAR 0 7
71185: PPUSH
71186: LD_VAR 0 5
71190: PUSH
71191: LD_INT 1
71193: MINUS
71194: PPUSH
71195: LD_VAR 0 6
71199: PPUSH
71200: CALL_OW 1
71204: ST_TO_ADDR
// end ;
71205: GO 71122
71207: POP
71208: POP
// result := s_arr [ 1 ] ;
71209: LD_ADDR_VAR 0 4
71213: PUSH
71214: LD_VAR 0 7
71218: PUSH
71219: LD_INT 1
71221: ARRAY
71222: ST_TO_ADDR
// end ; end ;
71223: LD_VAR 0 4
71227: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71228: LD_INT 0
71230: PPUSH
71231: PPUSH
// if not list then
71232: LD_VAR 0 1
71236: NOT
71237: IFFALSE 71241
// exit ;
71239: GO 71332
// i := list [ pos1 ] ;
71241: LD_ADDR_VAR 0 5
71245: PUSH
71246: LD_VAR 0 1
71250: PUSH
71251: LD_VAR 0 2
71255: ARRAY
71256: ST_TO_ADDR
// if not i then
71257: LD_VAR 0 5
71261: NOT
71262: IFFALSE 71266
// exit ;
71264: GO 71332
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71266: LD_ADDR_VAR 0 1
71270: PUSH
71271: LD_VAR 0 1
71275: PPUSH
71276: LD_VAR 0 2
71280: PPUSH
71281: LD_VAR 0 1
71285: PUSH
71286: LD_VAR 0 3
71290: ARRAY
71291: PPUSH
71292: CALL_OW 1
71296: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71297: LD_ADDR_VAR 0 1
71301: PUSH
71302: LD_VAR 0 1
71306: PPUSH
71307: LD_VAR 0 3
71311: PPUSH
71312: LD_VAR 0 5
71316: PPUSH
71317: CALL_OW 1
71321: ST_TO_ADDR
// result := list ;
71322: LD_ADDR_VAR 0 4
71326: PUSH
71327: LD_VAR 0 1
71331: ST_TO_ADDR
// end ;
71332: LD_VAR 0 4
71336: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71337: LD_INT 0
71339: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71340: LD_ADDR_VAR 0 5
71344: PUSH
71345: LD_VAR 0 1
71349: PPUSH
71350: CALL_OW 250
71354: PPUSH
71355: LD_VAR 0 1
71359: PPUSH
71360: CALL_OW 251
71364: PPUSH
71365: LD_VAR 0 2
71369: PPUSH
71370: LD_VAR 0 3
71374: PPUSH
71375: LD_VAR 0 4
71379: PPUSH
71380: CALL 71390 0 5
71384: ST_TO_ADDR
// end ;
71385: LD_VAR 0 5
71389: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71390: LD_INT 0
71392: PPUSH
71393: PPUSH
71394: PPUSH
71395: PPUSH
// if not list then
71396: LD_VAR 0 3
71400: NOT
71401: IFFALSE 71405
// exit ;
71403: GO 71793
// result := [ ] ;
71405: LD_ADDR_VAR 0 6
71409: PUSH
71410: EMPTY
71411: ST_TO_ADDR
// for i in list do
71412: LD_ADDR_VAR 0 7
71416: PUSH
71417: LD_VAR 0 3
71421: PUSH
71422: FOR_IN
71423: IFFALSE 71625
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71425: LD_ADDR_VAR 0 9
71429: PUSH
71430: LD_VAR 0 7
71434: PPUSH
71435: LD_VAR 0 1
71439: PPUSH
71440: LD_VAR 0 2
71444: PPUSH
71445: CALL_OW 297
71449: ST_TO_ADDR
// if not result then
71450: LD_VAR 0 6
71454: NOT
71455: IFFALSE 71481
// result := [ [ i , tmp ] ] else
71457: LD_ADDR_VAR 0 6
71461: PUSH
71462: LD_VAR 0 7
71466: PUSH
71467: LD_VAR 0 9
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: EMPTY
71477: LIST
71478: ST_TO_ADDR
71479: GO 71623
// begin if result [ result ] [ 2 ] < tmp then
71481: LD_VAR 0 6
71485: PUSH
71486: LD_VAR 0 6
71490: ARRAY
71491: PUSH
71492: LD_INT 2
71494: ARRAY
71495: PUSH
71496: LD_VAR 0 9
71500: LESS
71501: IFFALSE 71543
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71503: LD_ADDR_VAR 0 6
71507: PUSH
71508: LD_VAR 0 6
71512: PPUSH
71513: LD_VAR 0 6
71517: PUSH
71518: LD_INT 1
71520: PLUS
71521: PPUSH
71522: LD_VAR 0 7
71526: PUSH
71527: LD_VAR 0 9
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PPUSH
71536: CALL_OW 2
71540: ST_TO_ADDR
71541: GO 71623
// for j = 1 to result do
71543: LD_ADDR_VAR 0 8
71547: PUSH
71548: DOUBLE
71549: LD_INT 1
71551: DEC
71552: ST_TO_ADDR
71553: LD_VAR 0 6
71557: PUSH
71558: FOR_TO
71559: IFFALSE 71621
// begin if tmp < result [ j ] [ 2 ] then
71561: LD_VAR 0 9
71565: PUSH
71566: LD_VAR 0 6
71570: PUSH
71571: LD_VAR 0 8
71575: ARRAY
71576: PUSH
71577: LD_INT 2
71579: ARRAY
71580: LESS
71581: IFFALSE 71619
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71583: LD_ADDR_VAR 0 6
71587: PUSH
71588: LD_VAR 0 6
71592: PPUSH
71593: LD_VAR 0 8
71597: PPUSH
71598: LD_VAR 0 7
71602: PUSH
71603: LD_VAR 0 9
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PPUSH
71612: CALL_OW 2
71616: ST_TO_ADDR
// break ;
71617: GO 71621
// end ; end ;
71619: GO 71558
71621: POP
71622: POP
// end ; end ;
71623: GO 71422
71625: POP
71626: POP
// if result and not asc then
71627: LD_VAR 0 6
71631: PUSH
71632: LD_VAR 0 4
71636: NOT
71637: AND
71638: IFFALSE 71713
// begin tmp := result ;
71640: LD_ADDR_VAR 0 9
71644: PUSH
71645: LD_VAR 0 6
71649: ST_TO_ADDR
// for i = tmp downto 1 do
71650: LD_ADDR_VAR 0 7
71654: PUSH
71655: DOUBLE
71656: LD_VAR 0 9
71660: INC
71661: ST_TO_ADDR
71662: LD_INT 1
71664: PUSH
71665: FOR_DOWNTO
71666: IFFALSE 71711
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71668: LD_ADDR_VAR 0 6
71672: PUSH
71673: LD_VAR 0 6
71677: PPUSH
71678: LD_VAR 0 9
71682: PUSH
71683: LD_VAR 0 7
71687: MINUS
71688: PUSH
71689: LD_INT 1
71691: PLUS
71692: PPUSH
71693: LD_VAR 0 9
71697: PUSH
71698: LD_VAR 0 7
71702: ARRAY
71703: PPUSH
71704: CALL_OW 1
71708: ST_TO_ADDR
71709: GO 71665
71711: POP
71712: POP
// end ; tmp := [ ] ;
71713: LD_ADDR_VAR 0 9
71717: PUSH
71718: EMPTY
71719: ST_TO_ADDR
// if mode then
71720: LD_VAR 0 5
71724: IFFALSE 71793
// begin for i = 1 to result do
71726: LD_ADDR_VAR 0 7
71730: PUSH
71731: DOUBLE
71732: LD_INT 1
71734: DEC
71735: ST_TO_ADDR
71736: LD_VAR 0 6
71740: PUSH
71741: FOR_TO
71742: IFFALSE 71781
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71744: LD_ADDR_VAR 0 9
71748: PUSH
71749: LD_VAR 0 9
71753: PPUSH
71754: LD_VAR 0 7
71758: PPUSH
71759: LD_VAR 0 6
71763: PUSH
71764: LD_VAR 0 7
71768: ARRAY
71769: PUSH
71770: LD_INT 1
71772: ARRAY
71773: PPUSH
71774: CALL_OW 1
71778: ST_TO_ADDR
71779: GO 71741
71781: POP
71782: POP
// result := tmp ;
71783: LD_ADDR_VAR 0 6
71787: PUSH
71788: LD_VAR 0 9
71792: ST_TO_ADDR
// end ; end ;
71793: LD_VAR 0 6
71797: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71798: LD_INT 0
71800: PPUSH
71801: PPUSH
71802: PPUSH
71803: PPUSH
71804: PPUSH
71805: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71806: LD_ADDR_VAR 0 5
71810: PUSH
71811: LD_INT 0
71813: PUSH
71814: LD_INT 0
71816: PUSH
71817: LD_INT 0
71819: PUSH
71820: EMPTY
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: ST_TO_ADDR
// if not x or not y then
71828: LD_VAR 0 2
71832: NOT
71833: PUSH
71834: LD_VAR 0 3
71838: NOT
71839: OR
71840: IFFALSE 71844
// exit ;
71842: GO 73496
// if not range then
71844: LD_VAR 0 4
71848: NOT
71849: IFFALSE 71859
// range := 10 ;
71851: LD_ADDR_VAR 0 4
71855: PUSH
71856: LD_INT 10
71858: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71859: LD_ADDR_VAR 0 8
71863: PUSH
71864: LD_INT 81
71866: PUSH
71867: LD_VAR 0 1
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 92
71878: PUSH
71879: LD_VAR 0 2
71883: PUSH
71884: LD_VAR 0 3
71888: PUSH
71889: LD_VAR 0 4
71893: PUSH
71894: EMPTY
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 3
71902: PUSH
71903: LD_INT 21
71905: PUSH
71906: LD_INT 3
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: LIST
71921: PPUSH
71922: CALL_OW 69
71926: ST_TO_ADDR
// if not tmp then
71927: LD_VAR 0 8
71931: NOT
71932: IFFALSE 71936
// exit ;
71934: GO 73496
// for i in tmp do
71936: LD_ADDR_VAR 0 6
71940: PUSH
71941: LD_VAR 0 8
71945: PUSH
71946: FOR_IN
71947: IFFALSE 73471
// begin points := [ 0 , 0 , 0 ] ;
71949: LD_ADDR_VAR 0 9
71953: PUSH
71954: LD_INT 0
71956: PUSH
71957: LD_INT 0
71959: PUSH
71960: LD_INT 0
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: LIST
71967: ST_TO_ADDR
// bpoints := 1 ;
71968: LD_ADDR_VAR 0 10
71972: PUSH
71973: LD_INT 1
71975: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71976: LD_VAR 0 6
71980: PPUSH
71981: CALL_OW 247
71985: PUSH
71986: LD_INT 1
71988: DOUBLE
71989: EQUAL
71990: IFTRUE 71994
71992: GO 72572
71994: POP
// begin if GetClass ( i ) = 1 then
71995: LD_VAR 0 6
71999: PPUSH
72000: CALL_OW 257
72004: PUSH
72005: LD_INT 1
72007: EQUAL
72008: IFFALSE 72029
// points := [ 10 , 5 , 3 ] ;
72010: LD_ADDR_VAR 0 9
72014: PUSH
72015: LD_INT 10
72017: PUSH
72018: LD_INT 5
72020: PUSH
72021: LD_INT 3
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: LIST
72028: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72029: LD_VAR 0 6
72033: PPUSH
72034: CALL_OW 257
72038: PUSH
72039: LD_INT 2
72041: PUSH
72042: LD_INT 3
72044: PUSH
72045: LD_INT 4
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: LIST
72052: IN
72053: IFFALSE 72074
// points := [ 3 , 2 , 1 ] ;
72055: LD_ADDR_VAR 0 9
72059: PUSH
72060: LD_INT 3
72062: PUSH
72063: LD_INT 2
72065: PUSH
72066: LD_INT 1
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: LIST
72073: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72074: LD_VAR 0 6
72078: PPUSH
72079: CALL_OW 257
72083: PUSH
72084: LD_INT 5
72086: EQUAL
72087: IFFALSE 72108
// points := [ 130 , 5 , 2 ] ;
72089: LD_ADDR_VAR 0 9
72093: PUSH
72094: LD_INT 130
72096: PUSH
72097: LD_INT 5
72099: PUSH
72100: LD_INT 2
72102: PUSH
72103: EMPTY
72104: LIST
72105: LIST
72106: LIST
72107: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72108: LD_VAR 0 6
72112: PPUSH
72113: CALL_OW 257
72117: PUSH
72118: LD_INT 8
72120: EQUAL
72121: IFFALSE 72142
// points := [ 35 , 35 , 30 ] ;
72123: LD_ADDR_VAR 0 9
72127: PUSH
72128: LD_INT 35
72130: PUSH
72131: LD_INT 35
72133: PUSH
72134: LD_INT 30
72136: PUSH
72137: EMPTY
72138: LIST
72139: LIST
72140: LIST
72141: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72142: LD_VAR 0 6
72146: PPUSH
72147: CALL_OW 257
72151: PUSH
72152: LD_INT 9
72154: EQUAL
72155: IFFALSE 72176
// points := [ 20 , 55 , 40 ] ;
72157: LD_ADDR_VAR 0 9
72161: PUSH
72162: LD_INT 20
72164: PUSH
72165: LD_INT 55
72167: PUSH
72168: LD_INT 40
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: LIST
72175: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72176: LD_VAR 0 6
72180: PPUSH
72181: CALL_OW 257
72185: PUSH
72186: LD_INT 12
72188: PUSH
72189: LD_INT 16
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: IN
72196: IFFALSE 72217
// points := [ 5 , 3 , 2 ] ;
72198: LD_ADDR_VAR 0 9
72202: PUSH
72203: LD_INT 5
72205: PUSH
72206: LD_INT 3
72208: PUSH
72209: LD_INT 2
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72217: LD_VAR 0 6
72221: PPUSH
72222: CALL_OW 257
72226: PUSH
72227: LD_INT 17
72229: EQUAL
72230: IFFALSE 72251
// points := [ 100 , 50 , 75 ] ;
72232: LD_ADDR_VAR 0 9
72236: PUSH
72237: LD_INT 100
72239: PUSH
72240: LD_INT 50
72242: PUSH
72243: LD_INT 75
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: LIST
72250: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72251: LD_VAR 0 6
72255: PPUSH
72256: CALL_OW 257
72260: PUSH
72261: LD_INT 15
72263: EQUAL
72264: IFFALSE 72285
// points := [ 10 , 5 , 3 ] ;
72266: LD_ADDR_VAR 0 9
72270: PUSH
72271: LD_INT 10
72273: PUSH
72274: LD_INT 5
72276: PUSH
72277: LD_INT 3
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: LIST
72284: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72285: LD_VAR 0 6
72289: PPUSH
72290: CALL_OW 257
72294: PUSH
72295: LD_INT 14
72297: EQUAL
72298: IFFALSE 72319
// points := [ 10 , 0 , 0 ] ;
72300: LD_ADDR_VAR 0 9
72304: PUSH
72305: LD_INT 10
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: LD_INT 0
72313: PUSH
72314: EMPTY
72315: LIST
72316: LIST
72317: LIST
72318: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72319: LD_VAR 0 6
72323: PPUSH
72324: CALL_OW 257
72328: PUSH
72329: LD_INT 11
72331: EQUAL
72332: IFFALSE 72353
// points := [ 30 , 10 , 5 ] ;
72334: LD_ADDR_VAR 0 9
72338: PUSH
72339: LD_INT 30
72341: PUSH
72342: LD_INT 10
72344: PUSH
72345: LD_INT 5
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: LIST
72352: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72353: LD_VAR 0 1
72357: PPUSH
72358: LD_INT 5
72360: PPUSH
72361: CALL_OW 321
72365: PUSH
72366: LD_INT 2
72368: EQUAL
72369: IFFALSE 72386
// bpoints := bpoints * 1.8 ;
72371: LD_ADDR_VAR 0 10
72375: PUSH
72376: LD_VAR 0 10
72380: PUSH
72381: LD_REAL  1.80000000000000E+0000
72384: MUL
72385: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72386: LD_VAR 0 6
72390: PPUSH
72391: CALL_OW 257
72395: PUSH
72396: LD_INT 1
72398: PUSH
72399: LD_INT 2
72401: PUSH
72402: LD_INT 3
72404: PUSH
72405: LD_INT 4
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: IN
72414: PUSH
72415: LD_VAR 0 1
72419: PPUSH
72420: LD_INT 51
72422: PPUSH
72423: CALL_OW 321
72427: PUSH
72428: LD_INT 2
72430: EQUAL
72431: AND
72432: IFFALSE 72449
// bpoints := bpoints * 1.2 ;
72434: LD_ADDR_VAR 0 10
72438: PUSH
72439: LD_VAR 0 10
72443: PUSH
72444: LD_REAL  1.20000000000000E+0000
72447: MUL
72448: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72449: LD_VAR 0 6
72453: PPUSH
72454: CALL_OW 257
72458: PUSH
72459: LD_INT 5
72461: PUSH
72462: LD_INT 7
72464: PUSH
72465: LD_INT 9
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: LIST
72472: IN
72473: PUSH
72474: LD_VAR 0 1
72478: PPUSH
72479: LD_INT 52
72481: PPUSH
72482: CALL_OW 321
72486: PUSH
72487: LD_INT 2
72489: EQUAL
72490: AND
72491: IFFALSE 72508
// bpoints := bpoints * 1.5 ;
72493: LD_ADDR_VAR 0 10
72497: PUSH
72498: LD_VAR 0 10
72502: PUSH
72503: LD_REAL  1.50000000000000E+0000
72506: MUL
72507: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72508: LD_VAR 0 1
72512: PPUSH
72513: LD_INT 66
72515: PPUSH
72516: CALL_OW 321
72520: PUSH
72521: LD_INT 2
72523: EQUAL
72524: IFFALSE 72541
// bpoints := bpoints * 1.1 ;
72526: LD_ADDR_VAR 0 10
72530: PUSH
72531: LD_VAR 0 10
72535: PUSH
72536: LD_REAL  1.10000000000000E+0000
72539: MUL
72540: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72541: LD_ADDR_VAR 0 10
72545: PUSH
72546: LD_VAR 0 10
72550: PUSH
72551: LD_VAR 0 6
72555: PPUSH
72556: LD_INT 1
72558: PPUSH
72559: CALL_OW 259
72563: PUSH
72564: LD_REAL  1.15000000000000E+0000
72567: MUL
72568: MUL
72569: ST_TO_ADDR
// end ; unit_vehicle :
72570: GO 73400
72572: LD_INT 2
72574: DOUBLE
72575: EQUAL
72576: IFTRUE 72580
72578: GO 73388
72580: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72581: LD_VAR 0 6
72585: PPUSH
72586: CALL_OW 264
72590: PUSH
72591: LD_INT 2
72593: PUSH
72594: LD_INT 42
72596: PUSH
72597: LD_INT 24
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: LIST
72604: IN
72605: IFFALSE 72626
// points := [ 25 , 5 , 3 ] ;
72607: LD_ADDR_VAR 0 9
72611: PUSH
72612: LD_INT 25
72614: PUSH
72615: LD_INT 5
72617: PUSH
72618: LD_INT 3
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: LIST
72625: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72626: LD_VAR 0 6
72630: PPUSH
72631: CALL_OW 264
72635: PUSH
72636: LD_INT 4
72638: PUSH
72639: LD_INT 43
72641: PUSH
72642: LD_INT 25
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: LIST
72649: IN
72650: IFFALSE 72671
// points := [ 40 , 15 , 5 ] ;
72652: LD_ADDR_VAR 0 9
72656: PUSH
72657: LD_INT 40
72659: PUSH
72660: LD_INT 15
72662: PUSH
72663: LD_INT 5
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: LIST
72670: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72671: LD_VAR 0 6
72675: PPUSH
72676: CALL_OW 264
72680: PUSH
72681: LD_INT 3
72683: PUSH
72684: LD_INT 23
72686: PUSH
72687: EMPTY
72688: LIST
72689: LIST
72690: IN
72691: IFFALSE 72712
// points := [ 7 , 25 , 8 ] ;
72693: LD_ADDR_VAR 0 9
72697: PUSH
72698: LD_INT 7
72700: PUSH
72701: LD_INT 25
72703: PUSH
72704: LD_INT 8
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: LIST
72711: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72712: LD_VAR 0 6
72716: PPUSH
72717: CALL_OW 264
72721: PUSH
72722: LD_INT 5
72724: PUSH
72725: LD_INT 27
72727: PUSH
72728: LD_INT 44
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: LIST
72735: IN
72736: IFFALSE 72757
// points := [ 14 , 50 , 16 ] ;
72738: LD_ADDR_VAR 0 9
72742: PUSH
72743: LD_INT 14
72745: PUSH
72746: LD_INT 50
72748: PUSH
72749: LD_INT 16
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: LIST
72756: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72757: LD_VAR 0 6
72761: PPUSH
72762: CALL_OW 264
72766: PUSH
72767: LD_INT 6
72769: PUSH
72770: LD_INT 46
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: IN
72777: IFFALSE 72798
// points := [ 32 , 120 , 70 ] ;
72779: LD_ADDR_VAR 0 9
72783: PUSH
72784: LD_INT 32
72786: PUSH
72787: LD_INT 120
72789: PUSH
72790: LD_INT 70
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: LIST
72797: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72798: LD_VAR 0 6
72802: PPUSH
72803: CALL_OW 264
72807: PUSH
72808: LD_INT 7
72810: PUSH
72811: LD_INT 28
72813: PUSH
72814: LD_INT 45
72816: PUSH
72817: LD_EXP 100
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: IN
72828: IFFALSE 72849
// points := [ 35 , 20 , 45 ] ;
72830: LD_ADDR_VAR 0 9
72834: PUSH
72835: LD_INT 35
72837: PUSH
72838: LD_INT 20
72840: PUSH
72841: LD_INT 45
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: LIST
72848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72849: LD_VAR 0 6
72853: PPUSH
72854: CALL_OW 264
72858: PUSH
72859: LD_INT 47
72861: PUSH
72862: EMPTY
72863: LIST
72864: IN
72865: IFFALSE 72886
// points := [ 67 , 45 , 75 ] ;
72867: LD_ADDR_VAR 0 9
72871: PUSH
72872: LD_INT 67
72874: PUSH
72875: LD_INT 45
72877: PUSH
72878: LD_INT 75
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: LIST
72885: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72886: LD_VAR 0 6
72890: PPUSH
72891: CALL_OW 264
72895: PUSH
72896: LD_INT 26
72898: PUSH
72899: EMPTY
72900: LIST
72901: IN
72902: IFFALSE 72923
// points := [ 120 , 30 , 80 ] ;
72904: LD_ADDR_VAR 0 9
72908: PUSH
72909: LD_INT 120
72911: PUSH
72912: LD_INT 30
72914: PUSH
72915: LD_INT 80
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: LIST
72922: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72923: LD_VAR 0 6
72927: PPUSH
72928: CALL_OW 264
72932: PUSH
72933: LD_INT 22
72935: PUSH
72936: EMPTY
72937: LIST
72938: IN
72939: IFFALSE 72960
// points := [ 40 , 1 , 1 ] ;
72941: LD_ADDR_VAR 0 9
72945: PUSH
72946: LD_INT 40
72948: PUSH
72949: LD_INT 1
72951: PUSH
72952: LD_INT 1
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: LIST
72959: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72960: LD_VAR 0 6
72964: PPUSH
72965: CALL_OW 264
72969: PUSH
72970: LD_INT 29
72972: PUSH
72973: EMPTY
72974: LIST
72975: IN
72976: IFFALSE 72997
// points := [ 70 , 200 , 400 ] ;
72978: LD_ADDR_VAR 0 9
72982: PUSH
72983: LD_INT 70
72985: PUSH
72986: LD_INT 200
72988: PUSH
72989: LD_INT 400
72991: PUSH
72992: EMPTY
72993: LIST
72994: LIST
72995: LIST
72996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72997: LD_VAR 0 6
73001: PPUSH
73002: CALL_OW 264
73006: PUSH
73007: LD_INT 14
73009: PUSH
73010: LD_INT 53
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: IN
73017: IFFALSE 73038
// points := [ 40 , 10 , 20 ] ;
73019: LD_ADDR_VAR 0 9
73023: PUSH
73024: LD_INT 40
73026: PUSH
73027: LD_INT 10
73029: PUSH
73030: LD_INT 20
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: LIST
73037: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73038: LD_VAR 0 6
73042: PPUSH
73043: CALL_OW 264
73047: PUSH
73048: LD_INT 9
73050: PUSH
73051: EMPTY
73052: LIST
73053: IN
73054: IFFALSE 73075
// points := [ 5 , 70 , 20 ] ;
73056: LD_ADDR_VAR 0 9
73060: PUSH
73061: LD_INT 5
73063: PUSH
73064: LD_INT 70
73066: PUSH
73067: LD_INT 20
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: LIST
73074: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73075: LD_VAR 0 6
73079: PPUSH
73080: CALL_OW 264
73084: PUSH
73085: LD_INT 10
73087: PUSH
73088: EMPTY
73089: LIST
73090: IN
73091: IFFALSE 73112
// points := [ 35 , 110 , 70 ] ;
73093: LD_ADDR_VAR 0 9
73097: PUSH
73098: LD_INT 35
73100: PUSH
73101: LD_INT 110
73103: PUSH
73104: LD_INT 70
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: LIST
73111: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73112: LD_VAR 0 6
73116: PPUSH
73117: CALL_OW 265
73121: PUSH
73122: LD_INT 25
73124: EQUAL
73125: IFFALSE 73146
// points := [ 80 , 65 , 100 ] ;
73127: LD_ADDR_VAR 0 9
73131: PUSH
73132: LD_INT 80
73134: PUSH
73135: LD_INT 65
73137: PUSH
73138: LD_INT 100
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: LIST
73145: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73146: LD_VAR 0 6
73150: PPUSH
73151: CALL_OW 263
73155: PUSH
73156: LD_INT 1
73158: EQUAL
73159: IFFALSE 73194
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73161: LD_ADDR_VAR 0 10
73165: PUSH
73166: LD_VAR 0 10
73170: PUSH
73171: LD_VAR 0 6
73175: PPUSH
73176: CALL_OW 311
73180: PPUSH
73181: LD_INT 3
73183: PPUSH
73184: CALL_OW 259
73188: PUSH
73189: LD_INT 4
73191: MUL
73192: MUL
73193: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73194: LD_VAR 0 6
73198: PPUSH
73199: CALL_OW 263
73203: PUSH
73204: LD_INT 2
73206: EQUAL
73207: IFFALSE 73258
// begin j := IsControledBy ( i ) ;
73209: LD_ADDR_VAR 0 7
73213: PUSH
73214: LD_VAR 0 6
73218: PPUSH
73219: CALL_OW 312
73223: ST_TO_ADDR
// if j then
73224: LD_VAR 0 7
73228: IFFALSE 73258
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73230: LD_ADDR_VAR 0 10
73234: PUSH
73235: LD_VAR 0 10
73239: PUSH
73240: LD_VAR 0 7
73244: PPUSH
73245: LD_INT 3
73247: PPUSH
73248: CALL_OW 259
73252: PUSH
73253: LD_INT 3
73255: MUL
73256: MUL
73257: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73258: LD_VAR 0 6
73262: PPUSH
73263: CALL_OW 264
73267: PUSH
73268: LD_INT 5
73270: PUSH
73271: LD_INT 6
73273: PUSH
73274: LD_INT 46
73276: PUSH
73277: LD_INT 44
73279: PUSH
73280: LD_INT 47
73282: PUSH
73283: LD_INT 45
73285: PUSH
73286: LD_INT 28
73288: PUSH
73289: LD_INT 7
73291: PUSH
73292: LD_INT 27
73294: PUSH
73295: LD_INT 29
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: LIST
73308: LIST
73309: IN
73310: PUSH
73311: LD_VAR 0 1
73315: PPUSH
73316: LD_INT 52
73318: PPUSH
73319: CALL_OW 321
73323: PUSH
73324: LD_INT 2
73326: EQUAL
73327: AND
73328: IFFALSE 73345
// bpoints := bpoints * 1.2 ;
73330: LD_ADDR_VAR 0 10
73334: PUSH
73335: LD_VAR 0 10
73339: PUSH
73340: LD_REAL  1.20000000000000E+0000
73343: MUL
73344: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73345: LD_VAR 0 6
73349: PPUSH
73350: CALL_OW 264
73354: PUSH
73355: LD_INT 6
73357: PUSH
73358: LD_INT 46
73360: PUSH
73361: LD_INT 47
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: LIST
73368: IN
73369: IFFALSE 73386
// bpoints := bpoints * 1.2 ;
73371: LD_ADDR_VAR 0 10
73375: PUSH
73376: LD_VAR 0 10
73380: PUSH
73381: LD_REAL  1.20000000000000E+0000
73384: MUL
73385: ST_TO_ADDR
// end ; unit_building :
73386: GO 73400
73388: LD_INT 3
73390: DOUBLE
73391: EQUAL
73392: IFTRUE 73396
73394: GO 73399
73396: POP
// ; end ;
73397: GO 73400
73399: POP
// for j = 1 to 3 do
73400: LD_ADDR_VAR 0 7
73404: PUSH
73405: DOUBLE
73406: LD_INT 1
73408: DEC
73409: ST_TO_ADDR
73410: LD_INT 3
73412: PUSH
73413: FOR_TO
73414: IFFALSE 73467
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73416: LD_ADDR_VAR 0 5
73420: PUSH
73421: LD_VAR 0 5
73425: PPUSH
73426: LD_VAR 0 7
73430: PPUSH
73431: LD_VAR 0 5
73435: PUSH
73436: LD_VAR 0 7
73440: ARRAY
73441: PUSH
73442: LD_VAR 0 9
73446: PUSH
73447: LD_VAR 0 7
73451: ARRAY
73452: PUSH
73453: LD_VAR 0 10
73457: MUL
73458: PLUS
73459: PPUSH
73460: CALL_OW 1
73464: ST_TO_ADDR
73465: GO 73413
73467: POP
73468: POP
// end ;
73469: GO 71946
73471: POP
73472: POP
// result := Replace ( result , 4 , tmp ) ;
73473: LD_ADDR_VAR 0 5
73477: PUSH
73478: LD_VAR 0 5
73482: PPUSH
73483: LD_INT 4
73485: PPUSH
73486: LD_VAR 0 8
73490: PPUSH
73491: CALL_OW 1
73495: ST_TO_ADDR
// end ;
73496: LD_VAR 0 5
73500: RET
// export function DangerAtRange ( unit , range ) ; begin
73501: LD_INT 0
73503: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73504: LD_ADDR_VAR 0 3
73508: PUSH
73509: LD_VAR 0 1
73513: PPUSH
73514: CALL_OW 255
73518: PPUSH
73519: LD_VAR 0 1
73523: PPUSH
73524: CALL_OW 250
73528: PPUSH
73529: LD_VAR 0 1
73533: PPUSH
73534: CALL_OW 251
73538: PPUSH
73539: LD_VAR 0 2
73543: PPUSH
73544: CALL 71798 0 4
73548: ST_TO_ADDR
// end ;
73549: LD_VAR 0 3
73553: RET
// export function DangerInArea ( side , area ) ; begin
73554: LD_INT 0
73556: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73557: LD_ADDR_VAR 0 3
73561: PUSH
73562: LD_VAR 0 2
73566: PPUSH
73567: LD_INT 81
73569: PUSH
73570: LD_VAR 0 1
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PPUSH
73579: CALL_OW 70
73583: ST_TO_ADDR
// end ;
73584: LD_VAR 0 3
73588: RET
// export function IsExtension ( b ) ; begin
73589: LD_INT 0
73591: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73592: LD_ADDR_VAR 0 2
73596: PUSH
73597: LD_VAR 0 1
73601: PUSH
73602: LD_INT 23
73604: PUSH
73605: LD_INT 20
73607: PUSH
73608: LD_INT 22
73610: PUSH
73611: LD_INT 17
73613: PUSH
73614: LD_INT 24
73616: PUSH
73617: LD_INT 21
73619: PUSH
73620: LD_INT 19
73622: PUSH
73623: LD_INT 16
73625: PUSH
73626: LD_INT 25
73628: PUSH
73629: LD_INT 18
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: LIST
73636: LIST
73637: LIST
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: IN
73644: ST_TO_ADDR
// end ;
73645: LD_VAR 0 2
73649: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73650: LD_INT 0
73652: PPUSH
73653: PPUSH
73654: PPUSH
// result := [ ] ;
73655: LD_ADDR_VAR 0 4
73659: PUSH
73660: EMPTY
73661: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73662: LD_ADDR_VAR 0 5
73666: PUSH
73667: LD_VAR 0 2
73671: PPUSH
73672: LD_INT 21
73674: PUSH
73675: LD_INT 3
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PPUSH
73682: CALL_OW 70
73686: ST_TO_ADDR
// if not tmp then
73687: LD_VAR 0 5
73691: NOT
73692: IFFALSE 73696
// exit ;
73694: GO 73760
// if checkLink then
73696: LD_VAR 0 3
73700: IFFALSE 73750
// begin for i in tmp do
73702: LD_ADDR_VAR 0 6
73706: PUSH
73707: LD_VAR 0 5
73711: PUSH
73712: FOR_IN
73713: IFFALSE 73748
// if GetBase ( i ) <> base then
73715: LD_VAR 0 6
73719: PPUSH
73720: CALL_OW 274
73724: PUSH
73725: LD_VAR 0 1
73729: NONEQUAL
73730: IFFALSE 73746
// ComLinkToBase ( base , i ) ;
73732: LD_VAR 0 1
73736: PPUSH
73737: LD_VAR 0 6
73741: PPUSH
73742: CALL_OW 169
73746: GO 73712
73748: POP
73749: POP
// end ; result := tmp ;
73750: LD_ADDR_VAR 0 4
73754: PUSH
73755: LD_VAR 0 5
73759: ST_TO_ADDR
// end ;
73760: LD_VAR 0 4
73764: RET
// export function ComComplete ( units , b ) ; var i ; begin
73765: LD_INT 0
73767: PPUSH
73768: PPUSH
// if not units then
73769: LD_VAR 0 1
73773: NOT
73774: IFFALSE 73778
// exit ;
73776: GO 73868
// for i in units do
73778: LD_ADDR_VAR 0 4
73782: PUSH
73783: LD_VAR 0 1
73787: PUSH
73788: FOR_IN
73789: IFFALSE 73866
// if BuildingStatus ( b ) = bs_build then
73791: LD_VAR 0 2
73795: PPUSH
73796: CALL_OW 461
73800: PUSH
73801: LD_INT 1
73803: EQUAL
73804: IFFALSE 73864
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73806: LD_VAR 0 4
73810: PPUSH
73811: LD_STRING h
73813: PUSH
73814: LD_VAR 0 2
73818: PPUSH
73819: CALL_OW 250
73823: PUSH
73824: LD_VAR 0 2
73828: PPUSH
73829: CALL_OW 251
73833: PUSH
73834: LD_VAR 0 2
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: LD_INT 0
73844: PUSH
73845: LD_INT 0
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: LIST
73852: LIST
73853: LIST
73854: LIST
73855: LIST
73856: PUSH
73857: EMPTY
73858: LIST
73859: PPUSH
73860: CALL_OW 446
73864: GO 73788
73866: POP
73867: POP
// end ;
73868: LD_VAR 0 3
73872: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73873: LD_INT 0
73875: PPUSH
73876: PPUSH
73877: PPUSH
73878: PPUSH
73879: PPUSH
73880: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73881: LD_VAR 0 1
73885: NOT
73886: PUSH
73887: LD_VAR 0 1
73891: PPUSH
73892: CALL_OW 263
73896: PUSH
73897: LD_INT 2
73899: NONEQUAL
73900: OR
73901: IFFALSE 73905
// exit ;
73903: GO 74221
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73905: LD_ADDR_VAR 0 6
73909: PUSH
73910: LD_INT 22
73912: PUSH
73913: LD_VAR 0 1
73917: PPUSH
73918: CALL_OW 255
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 2
73929: PUSH
73930: LD_INT 30
73932: PUSH
73933: LD_INT 36
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 34
73942: PUSH
73943: LD_INT 31
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: EMPTY
73951: LIST
73952: LIST
73953: LIST
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PPUSH
73959: CALL_OW 69
73963: ST_TO_ADDR
// if not tmp then
73964: LD_VAR 0 6
73968: NOT
73969: IFFALSE 73973
// exit ;
73971: GO 74221
// result := [ ] ;
73973: LD_ADDR_VAR 0 2
73977: PUSH
73978: EMPTY
73979: ST_TO_ADDR
// for i in tmp do
73980: LD_ADDR_VAR 0 3
73984: PUSH
73985: LD_VAR 0 6
73989: PUSH
73990: FOR_IN
73991: IFFALSE 74062
// begin t := UnitsInside ( i ) ;
73993: LD_ADDR_VAR 0 4
73997: PUSH
73998: LD_VAR 0 3
74002: PPUSH
74003: CALL_OW 313
74007: ST_TO_ADDR
// if t then
74008: LD_VAR 0 4
74012: IFFALSE 74060
// for j in t do
74014: LD_ADDR_VAR 0 7
74018: PUSH
74019: LD_VAR 0 4
74023: PUSH
74024: FOR_IN
74025: IFFALSE 74058
// result := Replace ( result , result + 1 , j ) ;
74027: LD_ADDR_VAR 0 2
74031: PUSH
74032: LD_VAR 0 2
74036: PPUSH
74037: LD_VAR 0 2
74041: PUSH
74042: LD_INT 1
74044: PLUS
74045: PPUSH
74046: LD_VAR 0 7
74050: PPUSH
74051: CALL_OW 1
74055: ST_TO_ADDR
74056: GO 74024
74058: POP
74059: POP
// end ;
74060: GO 73990
74062: POP
74063: POP
// if not result then
74064: LD_VAR 0 2
74068: NOT
74069: IFFALSE 74073
// exit ;
74071: GO 74221
// mech := result [ 1 ] ;
74073: LD_ADDR_VAR 0 5
74077: PUSH
74078: LD_VAR 0 2
74082: PUSH
74083: LD_INT 1
74085: ARRAY
74086: ST_TO_ADDR
// if result > 1 then
74087: LD_VAR 0 2
74091: PUSH
74092: LD_INT 1
74094: GREATER
74095: IFFALSE 74207
// begin for i = 2 to result do
74097: LD_ADDR_VAR 0 3
74101: PUSH
74102: DOUBLE
74103: LD_INT 2
74105: DEC
74106: ST_TO_ADDR
74107: LD_VAR 0 2
74111: PUSH
74112: FOR_TO
74113: IFFALSE 74205
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74115: LD_ADDR_VAR 0 4
74119: PUSH
74120: LD_VAR 0 2
74124: PUSH
74125: LD_VAR 0 3
74129: ARRAY
74130: PPUSH
74131: LD_INT 3
74133: PPUSH
74134: CALL_OW 259
74138: PUSH
74139: LD_VAR 0 2
74143: PUSH
74144: LD_VAR 0 3
74148: ARRAY
74149: PPUSH
74150: CALL_OW 432
74154: MINUS
74155: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74156: LD_VAR 0 4
74160: PUSH
74161: LD_VAR 0 5
74165: PPUSH
74166: LD_INT 3
74168: PPUSH
74169: CALL_OW 259
74173: PUSH
74174: LD_VAR 0 5
74178: PPUSH
74179: CALL_OW 432
74183: MINUS
74184: GREATEREQUAL
74185: IFFALSE 74203
// mech := result [ i ] ;
74187: LD_ADDR_VAR 0 5
74191: PUSH
74192: LD_VAR 0 2
74196: PUSH
74197: LD_VAR 0 3
74201: ARRAY
74202: ST_TO_ADDR
// end ;
74203: GO 74112
74205: POP
74206: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74207: LD_VAR 0 1
74211: PPUSH
74212: LD_VAR 0 5
74216: PPUSH
74217: CALL_OW 135
// end ;
74221: LD_VAR 0 2
74225: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74226: LD_INT 0
74228: PPUSH
74229: PPUSH
74230: PPUSH
74231: PPUSH
74232: PPUSH
74233: PPUSH
74234: PPUSH
74235: PPUSH
74236: PPUSH
74237: PPUSH
74238: PPUSH
74239: PPUSH
74240: PPUSH
// result := [ ] ;
74241: LD_ADDR_VAR 0 7
74245: PUSH
74246: EMPTY
74247: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74248: LD_VAR 0 1
74252: PPUSH
74253: CALL_OW 266
74257: PUSH
74258: LD_INT 0
74260: PUSH
74261: LD_INT 1
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: IN
74268: NOT
74269: IFFALSE 74273
// exit ;
74271: GO 75907
// if name then
74273: LD_VAR 0 3
74277: IFFALSE 74293
// SetBName ( base_dep , name ) ;
74279: LD_VAR 0 1
74283: PPUSH
74284: LD_VAR 0 3
74288: PPUSH
74289: CALL_OW 500
// base := GetBase ( base_dep ) ;
74293: LD_ADDR_VAR 0 15
74297: PUSH
74298: LD_VAR 0 1
74302: PPUSH
74303: CALL_OW 274
74307: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74308: LD_ADDR_VAR 0 16
74312: PUSH
74313: LD_VAR 0 1
74317: PPUSH
74318: CALL_OW 255
74322: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74323: LD_ADDR_VAR 0 17
74327: PUSH
74328: LD_VAR 0 1
74332: PPUSH
74333: CALL_OW 248
74337: ST_TO_ADDR
// if sources then
74338: LD_VAR 0 5
74342: IFFALSE 74389
// for i = 1 to 3 do
74344: LD_ADDR_VAR 0 8
74348: PUSH
74349: DOUBLE
74350: LD_INT 1
74352: DEC
74353: ST_TO_ADDR
74354: LD_INT 3
74356: PUSH
74357: FOR_TO
74358: IFFALSE 74387
// AddResourceType ( base , i , sources [ i ] ) ;
74360: LD_VAR 0 15
74364: PPUSH
74365: LD_VAR 0 8
74369: PPUSH
74370: LD_VAR 0 5
74374: PUSH
74375: LD_VAR 0 8
74379: ARRAY
74380: PPUSH
74381: CALL_OW 276
74385: GO 74357
74387: POP
74388: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74389: LD_ADDR_VAR 0 18
74393: PUSH
74394: LD_VAR 0 15
74398: PPUSH
74399: LD_VAR 0 2
74403: PPUSH
74404: LD_INT 1
74406: PPUSH
74407: CALL 73650 0 3
74411: ST_TO_ADDR
// InitHc ;
74412: CALL_OW 19
// InitUc ;
74416: CALL_OW 18
// uc_side := side ;
74420: LD_ADDR_OWVAR 20
74424: PUSH
74425: LD_VAR 0 16
74429: ST_TO_ADDR
// uc_nation := nation ;
74430: LD_ADDR_OWVAR 21
74434: PUSH
74435: LD_VAR 0 17
74439: ST_TO_ADDR
// if buildings then
74440: LD_VAR 0 18
74444: IFFALSE 75766
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74446: LD_ADDR_VAR 0 19
74450: PUSH
74451: LD_VAR 0 18
74455: PPUSH
74456: LD_INT 2
74458: PUSH
74459: LD_INT 30
74461: PUSH
74462: LD_INT 29
74464: PUSH
74465: EMPTY
74466: LIST
74467: LIST
74468: PUSH
74469: LD_INT 30
74471: PUSH
74472: LD_INT 30
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: LIST
74483: PPUSH
74484: CALL_OW 72
74488: ST_TO_ADDR
// if tmp then
74489: LD_VAR 0 19
74493: IFFALSE 74541
// for i in tmp do
74495: LD_ADDR_VAR 0 8
74499: PUSH
74500: LD_VAR 0 19
74504: PUSH
74505: FOR_IN
74506: IFFALSE 74539
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74508: LD_VAR 0 8
74512: PPUSH
74513: CALL_OW 250
74517: PPUSH
74518: LD_VAR 0 8
74522: PPUSH
74523: CALL_OW 251
74527: PPUSH
74528: LD_VAR 0 16
74532: PPUSH
74533: CALL_OW 441
74537: GO 74505
74539: POP
74540: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74541: LD_VAR 0 18
74545: PPUSH
74546: LD_INT 2
74548: PUSH
74549: LD_INT 30
74551: PUSH
74552: LD_INT 32
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 30
74561: PUSH
74562: LD_INT 33
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: PPUSH
74574: CALL_OW 72
74578: IFFALSE 74666
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74580: LD_ADDR_VAR 0 8
74584: PUSH
74585: LD_VAR 0 18
74589: PPUSH
74590: LD_INT 2
74592: PUSH
74593: LD_INT 30
74595: PUSH
74596: LD_INT 32
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 30
74605: PUSH
74606: LD_INT 33
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: PPUSH
74618: CALL_OW 72
74622: PUSH
74623: FOR_IN
74624: IFFALSE 74664
// begin if not GetBWeapon ( i ) then
74626: LD_VAR 0 8
74630: PPUSH
74631: CALL_OW 269
74635: NOT
74636: IFFALSE 74662
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74638: LD_VAR 0 8
74642: PPUSH
74643: LD_VAR 0 8
74647: PPUSH
74648: LD_VAR 0 2
74652: PPUSH
74653: CALL 75912 0 2
74657: PPUSH
74658: CALL_OW 431
// end ;
74662: GO 74623
74664: POP
74665: POP
// end ; for i = 1 to personel do
74666: LD_ADDR_VAR 0 8
74670: PUSH
74671: DOUBLE
74672: LD_INT 1
74674: DEC
74675: ST_TO_ADDR
74676: LD_VAR 0 6
74680: PUSH
74681: FOR_TO
74682: IFFALSE 75746
// begin if i > 4 then
74684: LD_VAR 0 8
74688: PUSH
74689: LD_INT 4
74691: GREATER
74692: IFFALSE 74696
// break ;
74694: GO 75746
// case i of 1 :
74696: LD_VAR 0 8
74700: PUSH
74701: LD_INT 1
74703: DOUBLE
74704: EQUAL
74705: IFTRUE 74709
74707: GO 74789
74709: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74710: LD_ADDR_VAR 0 12
74714: PUSH
74715: LD_VAR 0 18
74719: PPUSH
74720: LD_INT 22
74722: PUSH
74723: LD_VAR 0 16
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 58
74734: PUSH
74735: EMPTY
74736: LIST
74737: PUSH
74738: LD_INT 2
74740: PUSH
74741: LD_INT 30
74743: PUSH
74744: LD_INT 32
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 30
74753: PUSH
74754: LD_INT 4
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 30
74763: PUSH
74764: LD_INT 5
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: LIST
74781: PPUSH
74782: CALL_OW 72
74786: ST_TO_ADDR
74787: GO 75011
74789: LD_INT 2
74791: DOUBLE
74792: EQUAL
74793: IFTRUE 74797
74795: GO 74859
74797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74798: LD_ADDR_VAR 0 12
74802: PUSH
74803: LD_VAR 0 18
74807: PPUSH
74808: LD_INT 22
74810: PUSH
74811: LD_VAR 0 16
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 2
74822: PUSH
74823: LD_INT 30
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 30
74835: PUSH
74836: LD_INT 1
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: LIST
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PPUSH
74852: CALL_OW 72
74856: ST_TO_ADDR
74857: GO 75011
74859: LD_INT 3
74861: DOUBLE
74862: EQUAL
74863: IFTRUE 74867
74865: GO 74929
74867: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74868: LD_ADDR_VAR 0 12
74872: PUSH
74873: LD_VAR 0 18
74877: PPUSH
74878: LD_INT 22
74880: PUSH
74881: LD_VAR 0 16
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 2
74892: PUSH
74893: LD_INT 30
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 30
74905: PUSH
74906: LD_INT 3
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: LIST
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PPUSH
74922: CALL_OW 72
74926: ST_TO_ADDR
74927: GO 75011
74929: LD_INT 4
74931: DOUBLE
74932: EQUAL
74933: IFTRUE 74937
74935: GO 75010
74937: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74938: LD_ADDR_VAR 0 12
74942: PUSH
74943: LD_VAR 0 18
74947: PPUSH
74948: LD_INT 22
74950: PUSH
74951: LD_VAR 0 16
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: PUSH
74960: LD_INT 2
74962: PUSH
74963: LD_INT 30
74965: PUSH
74966: LD_INT 6
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 30
74975: PUSH
74976: LD_INT 7
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 30
74985: PUSH
74986: LD_INT 8
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: LIST
74997: LIST
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PPUSH
75003: CALL_OW 72
75007: ST_TO_ADDR
75008: GO 75011
75010: POP
// if i = 1 then
75011: LD_VAR 0 8
75015: PUSH
75016: LD_INT 1
75018: EQUAL
75019: IFFALSE 75130
// begin tmp := [ ] ;
75021: LD_ADDR_VAR 0 19
75025: PUSH
75026: EMPTY
75027: ST_TO_ADDR
// for j in f do
75028: LD_ADDR_VAR 0 9
75032: PUSH
75033: LD_VAR 0 12
75037: PUSH
75038: FOR_IN
75039: IFFALSE 75112
// if GetBType ( j ) = b_bunker then
75041: LD_VAR 0 9
75045: PPUSH
75046: CALL_OW 266
75050: PUSH
75051: LD_INT 32
75053: EQUAL
75054: IFFALSE 75081
// tmp := Insert ( tmp , 1 , j ) else
75056: LD_ADDR_VAR 0 19
75060: PUSH
75061: LD_VAR 0 19
75065: PPUSH
75066: LD_INT 1
75068: PPUSH
75069: LD_VAR 0 9
75073: PPUSH
75074: CALL_OW 2
75078: ST_TO_ADDR
75079: GO 75110
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75081: LD_ADDR_VAR 0 19
75085: PUSH
75086: LD_VAR 0 19
75090: PPUSH
75091: LD_VAR 0 19
75095: PUSH
75096: LD_INT 1
75098: PLUS
75099: PPUSH
75100: LD_VAR 0 9
75104: PPUSH
75105: CALL_OW 2
75109: ST_TO_ADDR
75110: GO 75038
75112: POP
75113: POP
// if tmp then
75114: LD_VAR 0 19
75118: IFFALSE 75130
// f := tmp ;
75120: LD_ADDR_VAR 0 12
75124: PUSH
75125: LD_VAR 0 19
75129: ST_TO_ADDR
// end ; x := personel [ i ] ;
75130: LD_ADDR_VAR 0 13
75134: PUSH
75135: LD_VAR 0 6
75139: PUSH
75140: LD_VAR 0 8
75144: ARRAY
75145: ST_TO_ADDR
// if x = - 1 then
75146: LD_VAR 0 13
75150: PUSH
75151: LD_INT 1
75153: NEG
75154: EQUAL
75155: IFFALSE 75364
// begin for j in f do
75157: LD_ADDR_VAR 0 9
75161: PUSH
75162: LD_VAR 0 12
75166: PUSH
75167: FOR_IN
75168: IFFALSE 75360
// repeat InitHc ;
75170: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75174: LD_VAR 0 9
75178: PPUSH
75179: CALL_OW 266
75183: PUSH
75184: LD_INT 5
75186: EQUAL
75187: IFFALSE 75257
// begin if UnitsInside ( j ) < 3 then
75189: LD_VAR 0 9
75193: PPUSH
75194: CALL_OW 313
75198: PUSH
75199: LD_INT 3
75201: LESS
75202: IFFALSE 75238
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75204: LD_INT 0
75206: PPUSH
75207: LD_INT 5
75209: PUSH
75210: LD_INT 8
75212: PUSH
75213: LD_INT 9
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: LIST
75220: PUSH
75221: LD_VAR 0 17
75225: ARRAY
75226: PPUSH
75227: LD_VAR 0 4
75231: PPUSH
75232: CALL_OW 380
75236: GO 75255
// PrepareHuman ( false , i , skill ) ;
75238: LD_INT 0
75240: PPUSH
75241: LD_VAR 0 8
75245: PPUSH
75246: LD_VAR 0 4
75250: PPUSH
75251: CALL_OW 380
// end else
75255: GO 75274
// PrepareHuman ( false , i , skill ) ;
75257: LD_INT 0
75259: PPUSH
75260: LD_VAR 0 8
75264: PPUSH
75265: LD_VAR 0 4
75269: PPUSH
75270: CALL_OW 380
// un := CreateHuman ;
75274: LD_ADDR_VAR 0 14
75278: PUSH
75279: CALL_OW 44
75283: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75284: LD_ADDR_VAR 0 7
75288: PUSH
75289: LD_VAR 0 7
75293: PPUSH
75294: LD_INT 1
75296: PPUSH
75297: LD_VAR 0 14
75301: PPUSH
75302: CALL_OW 2
75306: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75307: LD_VAR 0 14
75311: PPUSH
75312: LD_VAR 0 9
75316: PPUSH
75317: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75321: LD_VAR 0 9
75325: PPUSH
75326: CALL_OW 313
75330: PUSH
75331: LD_INT 6
75333: EQUAL
75334: PUSH
75335: LD_VAR 0 9
75339: PPUSH
75340: CALL_OW 266
75344: PUSH
75345: LD_INT 32
75347: PUSH
75348: LD_INT 31
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: IN
75355: OR
75356: IFFALSE 75170
75358: GO 75167
75360: POP
75361: POP
// end else
75362: GO 75744
// for j = 1 to x do
75364: LD_ADDR_VAR 0 9
75368: PUSH
75369: DOUBLE
75370: LD_INT 1
75372: DEC
75373: ST_TO_ADDR
75374: LD_VAR 0 13
75378: PUSH
75379: FOR_TO
75380: IFFALSE 75742
// begin InitHc ;
75382: CALL_OW 19
// if not f then
75386: LD_VAR 0 12
75390: NOT
75391: IFFALSE 75480
// begin PrepareHuman ( false , i , skill ) ;
75393: LD_INT 0
75395: PPUSH
75396: LD_VAR 0 8
75400: PPUSH
75401: LD_VAR 0 4
75405: PPUSH
75406: CALL_OW 380
// un := CreateHuman ;
75410: LD_ADDR_VAR 0 14
75414: PUSH
75415: CALL_OW 44
75419: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75420: LD_ADDR_VAR 0 7
75424: PUSH
75425: LD_VAR 0 7
75429: PPUSH
75430: LD_INT 1
75432: PPUSH
75433: LD_VAR 0 14
75437: PPUSH
75438: CALL_OW 2
75442: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75443: LD_VAR 0 14
75447: PPUSH
75448: LD_VAR 0 1
75452: PPUSH
75453: CALL_OW 250
75457: PPUSH
75458: LD_VAR 0 1
75462: PPUSH
75463: CALL_OW 251
75467: PPUSH
75468: LD_INT 10
75470: PPUSH
75471: LD_INT 0
75473: PPUSH
75474: CALL_OW 50
// continue ;
75478: GO 75379
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75480: LD_VAR 0 12
75484: PUSH
75485: LD_INT 1
75487: ARRAY
75488: PPUSH
75489: CALL_OW 313
75493: PUSH
75494: LD_VAR 0 12
75498: PUSH
75499: LD_INT 1
75501: ARRAY
75502: PPUSH
75503: CALL_OW 266
75507: PUSH
75508: LD_INT 32
75510: PUSH
75511: LD_INT 31
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: IN
75518: AND
75519: PUSH
75520: LD_VAR 0 12
75524: PUSH
75525: LD_INT 1
75527: ARRAY
75528: PPUSH
75529: CALL_OW 313
75533: PUSH
75534: LD_INT 6
75536: EQUAL
75537: OR
75538: IFFALSE 75558
// f := Delete ( f , 1 ) ;
75540: LD_ADDR_VAR 0 12
75544: PUSH
75545: LD_VAR 0 12
75549: PPUSH
75550: LD_INT 1
75552: PPUSH
75553: CALL_OW 3
75557: ST_TO_ADDR
// if not f then
75558: LD_VAR 0 12
75562: NOT
75563: IFFALSE 75581
// begin x := x + 2 ;
75565: LD_ADDR_VAR 0 13
75569: PUSH
75570: LD_VAR 0 13
75574: PUSH
75575: LD_INT 2
75577: PLUS
75578: ST_TO_ADDR
// continue ;
75579: GO 75379
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75581: LD_VAR 0 12
75585: PUSH
75586: LD_INT 1
75588: ARRAY
75589: PPUSH
75590: CALL_OW 266
75594: PUSH
75595: LD_INT 5
75597: EQUAL
75598: IFFALSE 75672
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75600: LD_VAR 0 12
75604: PUSH
75605: LD_INT 1
75607: ARRAY
75608: PPUSH
75609: CALL_OW 313
75613: PUSH
75614: LD_INT 3
75616: LESS
75617: IFFALSE 75653
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75619: LD_INT 0
75621: PPUSH
75622: LD_INT 5
75624: PUSH
75625: LD_INT 8
75627: PUSH
75628: LD_INT 9
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: LIST
75635: PUSH
75636: LD_VAR 0 17
75640: ARRAY
75641: PPUSH
75642: LD_VAR 0 4
75646: PPUSH
75647: CALL_OW 380
75651: GO 75670
// PrepareHuman ( false , i , skill ) ;
75653: LD_INT 0
75655: PPUSH
75656: LD_VAR 0 8
75660: PPUSH
75661: LD_VAR 0 4
75665: PPUSH
75666: CALL_OW 380
// end else
75670: GO 75689
// PrepareHuman ( false , i , skill ) ;
75672: LD_INT 0
75674: PPUSH
75675: LD_VAR 0 8
75679: PPUSH
75680: LD_VAR 0 4
75684: PPUSH
75685: CALL_OW 380
// un := CreateHuman ;
75689: LD_ADDR_VAR 0 14
75693: PUSH
75694: CALL_OW 44
75698: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75699: LD_ADDR_VAR 0 7
75703: PUSH
75704: LD_VAR 0 7
75708: PPUSH
75709: LD_INT 1
75711: PPUSH
75712: LD_VAR 0 14
75716: PPUSH
75717: CALL_OW 2
75721: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75722: LD_VAR 0 14
75726: PPUSH
75727: LD_VAR 0 12
75731: PUSH
75732: LD_INT 1
75734: ARRAY
75735: PPUSH
75736: CALL_OW 52
// end ;
75740: GO 75379
75742: POP
75743: POP
// end ;
75744: GO 74681
75746: POP
75747: POP
// result := result ^ buildings ;
75748: LD_ADDR_VAR 0 7
75752: PUSH
75753: LD_VAR 0 7
75757: PUSH
75758: LD_VAR 0 18
75762: ADD
75763: ST_TO_ADDR
// end else
75764: GO 75907
// begin for i = 1 to personel do
75766: LD_ADDR_VAR 0 8
75770: PUSH
75771: DOUBLE
75772: LD_INT 1
75774: DEC
75775: ST_TO_ADDR
75776: LD_VAR 0 6
75780: PUSH
75781: FOR_TO
75782: IFFALSE 75905
// begin if i > 4 then
75784: LD_VAR 0 8
75788: PUSH
75789: LD_INT 4
75791: GREATER
75792: IFFALSE 75796
// break ;
75794: GO 75905
// x := personel [ i ] ;
75796: LD_ADDR_VAR 0 13
75800: PUSH
75801: LD_VAR 0 6
75805: PUSH
75806: LD_VAR 0 8
75810: ARRAY
75811: ST_TO_ADDR
// if x = - 1 then
75812: LD_VAR 0 13
75816: PUSH
75817: LD_INT 1
75819: NEG
75820: EQUAL
75821: IFFALSE 75825
// continue ;
75823: GO 75781
// PrepareHuman ( false , i , skill ) ;
75825: LD_INT 0
75827: PPUSH
75828: LD_VAR 0 8
75832: PPUSH
75833: LD_VAR 0 4
75837: PPUSH
75838: CALL_OW 380
// un := CreateHuman ;
75842: LD_ADDR_VAR 0 14
75846: PUSH
75847: CALL_OW 44
75851: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75852: LD_VAR 0 14
75856: PPUSH
75857: LD_VAR 0 1
75861: PPUSH
75862: CALL_OW 250
75866: PPUSH
75867: LD_VAR 0 1
75871: PPUSH
75872: CALL_OW 251
75876: PPUSH
75877: LD_INT 10
75879: PPUSH
75880: LD_INT 0
75882: PPUSH
75883: CALL_OW 50
// result := result ^ un ;
75887: LD_ADDR_VAR 0 7
75891: PUSH
75892: LD_VAR 0 7
75896: PUSH
75897: LD_VAR 0 14
75901: ADD
75902: ST_TO_ADDR
// end ;
75903: GO 75781
75905: POP
75906: POP
// end ; end ;
75907: LD_VAR 0 7
75911: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75912: LD_INT 0
75914: PPUSH
75915: PPUSH
75916: PPUSH
75917: PPUSH
75918: PPUSH
75919: PPUSH
75920: PPUSH
75921: PPUSH
75922: PPUSH
75923: PPUSH
75924: PPUSH
75925: PPUSH
75926: PPUSH
75927: PPUSH
75928: PPUSH
75929: PPUSH
// result := false ;
75930: LD_ADDR_VAR 0 3
75934: PUSH
75935: LD_INT 0
75937: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75938: LD_VAR 0 1
75942: NOT
75943: PUSH
75944: LD_VAR 0 1
75948: PPUSH
75949: CALL_OW 266
75953: PUSH
75954: LD_INT 32
75956: PUSH
75957: LD_INT 33
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: IN
75964: NOT
75965: OR
75966: IFFALSE 75970
// exit ;
75968: GO 77079
// nat := GetNation ( tower ) ;
75970: LD_ADDR_VAR 0 12
75974: PUSH
75975: LD_VAR 0 1
75979: PPUSH
75980: CALL_OW 248
75984: ST_TO_ADDR
// side := GetSide ( tower ) ;
75985: LD_ADDR_VAR 0 16
75989: PUSH
75990: LD_VAR 0 1
75994: PPUSH
75995: CALL_OW 255
75999: ST_TO_ADDR
// x := GetX ( tower ) ;
76000: LD_ADDR_VAR 0 10
76004: PUSH
76005: LD_VAR 0 1
76009: PPUSH
76010: CALL_OW 250
76014: ST_TO_ADDR
// y := GetY ( tower ) ;
76015: LD_ADDR_VAR 0 11
76019: PUSH
76020: LD_VAR 0 1
76024: PPUSH
76025: CALL_OW 251
76029: ST_TO_ADDR
// if not x or not y then
76030: LD_VAR 0 10
76034: NOT
76035: PUSH
76036: LD_VAR 0 11
76040: NOT
76041: OR
76042: IFFALSE 76046
// exit ;
76044: GO 77079
// weapon := 0 ;
76046: LD_ADDR_VAR 0 18
76050: PUSH
76051: LD_INT 0
76053: ST_TO_ADDR
// fac_list := [ ] ;
76054: LD_ADDR_VAR 0 17
76058: PUSH
76059: EMPTY
76060: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76061: LD_ADDR_VAR 0 6
76065: PUSH
76066: LD_VAR 0 1
76070: PPUSH
76071: CALL_OW 274
76075: PPUSH
76076: LD_VAR 0 2
76080: PPUSH
76081: LD_INT 0
76083: PPUSH
76084: CALL 73650 0 3
76088: PPUSH
76089: LD_INT 30
76091: PUSH
76092: LD_INT 3
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PPUSH
76099: CALL_OW 72
76103: ST_TO_ADDR
// if not factories then
76104: LD_VAR 0 6
76108: NOT
76109: IFFALSE 76113
// exit ;
76111: GO 77079
// for i in factories do
76113: LD_ADDR_VAR 0 8
76117: PUSH
76118: LD_VAR 0 6
76122: PUSH
76123: FOR_IN
76124: IFFALSE 76149
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76126: LD_ADDR_VAR 0 17
76130: PUSH
76131: LD_VAR 0 17
76135: PUSH
76136: LD_VAR 0 8
76140: PPUSH
76141: CALL_OW 478
76145: UNION
76146: ST_TO_ADDR
76147: GO 76123
76149: POP
76150: POP
// if not fac_list then
76151: LD_VAR 0 17
76155: NOT
76156: IFFALSE 76160
// exit ;
76158: GO 77079
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76160: LD_ADDR_VAR 0 5
76164: PUSH
76165: LD_INT 4
76167: PUSH
76168: LD_INT 5
76170: PUSH
76171: LD_INT 9
76173: PUSH
76174: LD_INT 10
76176: PUSH
76177: LD_INT 6
76179: PUSH
76180: LD_INT 7
76182: PUSH
76183: LD_INT 11
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 27
76197: PUSH
76198: LD_INT 28
76200: PUSH
76201: LD_INT 26
76203: PUSH
76204: LD_INT 30
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 43
76215: PUSH
76216: LD_INT 44
76218: PUSH
76219: LD_INT 46
76221: PUSH
76222: LD_INT 45
76224: PUSH
76225: LD_INT 47
76227: PUSH
76228: LD_INT 49
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: LIST
76235: LIST
76236: LIST
76237: LIST
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: LIST
76243: PUSH
76244: LD_VAR 0 12
76248: ARRAY
76249: ST_TO_ADDR
// list := list isect fac_list ;
76250: LD_ADDR_VAR 0 5
76254: PUSH
76255: LD_VAR 0 5
76259: PUSH
76260: LD_VAR 0 17
76264: ISECT
76265: ST_TO_ADDR
// if not list then
76266: LD_VAR 0 5
76270: NOT
76271: IFFALSE 76275
// exit ;
76273: GO 77079
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76275: LD_VAR 0 12
76279: PUSH
76280: LD_INT 3
76282: EQUAL
76283: PUSH
76284: LD_INT 49
76286: PUSH
76287: LD_VAR 0 5
76291: IN
76292: AND
76293: PUSH
76294: LD_INT 31
76296: PPUSH
76297: LD_VAR 0 16
76301: PPUSH
76302: CALL_OW 321
76306: PUSH
76307: LD_INT 2
76309: EQUAL
76310: AND
76311: IFFALSE 76371
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76313: LD_INT 22
76315: PUSH
76316: LD_VAR 0 16
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 35
76327: PUSH
76328: LD_INT 49
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: LD_INT 91
76337: PUSH
76338: LD_VAR 0 1
76342: PUSH
76343: LD_INT 10
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: LIST
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: LIST
76355: PPUSH
76356: CALL_OW 69
76360: NOT
76361: IFFALSE 76371
// weapon := ru_time_lapser ;
76363: LD_ADDR_VAR 0 18
76367: PUSH
76368: LD_INT 49
76370: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76371: LD_VAR 0 12
76375: PUSH
76376: LD_INT 1
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: IN
76386: PUSH
76387: LD_INT 11
76389: PUSH
76390: LD_VAR 0 5
76394: IN
76395: PUSH
76396: LD_INT 30
76398: PUSH
76399: LD_VAR 0 5
76403: IN
76404: OR
76405: AND
76406: PUSH
76407: LD_INT 6
76409: PPUSH
76410: LD_VAR 0 16
76414: PPUSH
76415: CALL_OW 321
76419: PUSH
76420: LD_INT 2
76422: EQUAL
76423: AND
76424: IFFALSE 76589
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76426: LD_INT 22
76428: PUSH
76429: LD_VAR 0 16
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 2
76440: PUSH
76441: LD_INT 35
76443: PUSH
76444: LD_INT 11
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 35
76453: PUSH
76454: LD_INT 30
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 91
76468: PUSH
76469: LD_VAR 0 1
76473: PUSH
76474: LD_INT 18
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: LIST
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: LIST
76486: PPUSH
76487: CALL_OW 69
76491: NOT
76492: PUSH
76493: LD_INT 22
76495: PUSH
76496: LD_VAR 0 16
76500: PUSH
76501: EMPTY
76502: LIST
76503: LIST
76504: PUSH
76505: LD_INT 2
76507: PUSH
76508: LD_INT 30
76510: PUSH
76511: LD_INT 32
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: LD_INT 30
76520: PUSH
76521: LD_INT 33
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 91
76535: PUSH
76536: LD_VAR 0 1
76540: PUSH
76541: LD_INT 12
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: LIST
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: LIST
76553: PUSH
76554: EMPTY
76555: LIST
76556: PPUSH
76557: CALL_OW 69
76561: PUSH
76562: LD_INT 2
76564: GREATER
76565: AND
76566: IFFALSE 76589
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76568: LD_ADDR_VAR 0 18
76572: PUSH
76573: LD_INT 11
76575: PUSH
76576: LD_INT 30
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_VAR 0 12
76587: ARRAY
76588: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76589: LD_VAR 0 18
76593: NOT
76594: PUSH
76595: LD_INT 40
76597: PPUSH
76598: LD_VAR 0 16
76602: PPUSH
76603: CALL_OW 321
76607: PUSH
76608: LD_INT 2
76610: EQUAL
76611: AND
76612: PUSH
76613: LD_INT 7
76615: PUSH
76616: LD_VAR 0 5
76620: IN
76621: PUSH
76622: LD_INT 28
76624: PUSH
76625: LD_VAR 0 5
76629: IN
76630: OR
76631: PUSH
76632: LD_INT 45
76634: PUSH
76635: LD_VAR 0 5
76639: IN
76640: OR
76641: AND
76642: IFFALSE 76896
// begin hex := GetHexInfo ( x , y ) ;
76644: LD_ADDR_VAR 0 4
76648: PUSH
76649: LD_VAR 0 10
76653: PPUSH
76654: LD_VAR 0 11
76658: PPUSH
76659: CALL_OW 546
76663: ST_TO_ADDR
// if hex [ 1 ] then
76664: LD_VAR 0 4
76668: PUSH
76669: LD_INT 1
76671: ARRAY
76672: IFFALSE 76676
// exit ;
76674: GO 77079
// height := hex [ 2 ] ;
76676: LD_ADDR_VAR 0 15
76680: PUSH
76681: LD_VAR 0 4
76685: PUSH
76686: LD_INT 2
76688: ARRAY
76689: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76690: LD_ADDR_VAR 0 14
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: LD_INT 2
76700: PUSH
76701: LD_INT 3
76703: PUSH
76704: LD_INT 5
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: ST_TO_ADDR
// for i in tmp do
76713: LD_ADDR_VAR 0 8
76717: PUSH
76718: LD_VAR 0 14
76722: PUSH
76723: FOR_IN
76724: IFFALSE 76894
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76726: LD_ADDR_VAR 0 9
76730: PUSH
76731: LD_VAR 0 10
76735: PPUSH
76736: LD_VAR 0 8
76740: PPUSH
76741: LD_INT 5
76743: PPUSH
76744: CALL_OW 272
76748: PUSH
76749: LD_VAR 0 11
76753: PPUSH
76754: LD_VAR 0 8
76758: PPUSH
76759: LD_INT 5
76761: PPUSH
76762: CALL_OW 273
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76771: LD_VAR 0 9
76775: PUSH
76776: LD_INT 1
76778: ARRAY
76779: PPUSH
76780: LD_VAR 0 9
76784: PUSH
76785: LD_INT 2
76787: ARRAY
76788: PPUSH
76789: CALL_OW 488
76793: IFFALSE 76892
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76795: LD_ADDR_VAR 0 4
76799: PUSH
76800: LD_VAR 0 9
76804: PUSH
76805: LD_INT 1
76807: ARRAY
76808: PPUSH
76809: LD_VAR 0 9
76813: PUSH
76814: LD_INT 2
76816: ARRAY
76817: PPUSH
76818: CALL_OW 546
76822: ST_TO_ADDR
// if hex [ 1 ] then
76823: LD_VAR 0 4
76827: PUSH
76828: LD_INT 1
76830: ARRAY
76831: IFFALSE 76835
// continue ;
76833: GO 76723
// h := hex [ 2 ] ;
76835: LD_ADDR_VAR 0 13
76839: PUSH
76840: LD_VAR 0 4
76844: PUSH
76845: LD_INT 2
76847: ARRAY
76848: ST_TO_ADDR
// if h + 7 < height then
76849: LD_VAR 0 13
76853: PUSH
76854: LD_INT 7
76856: PLUS
76857: PUSH
76858: LD_VAR 0 15
76862: LESS
76863: IFFALSE 76892
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76865: LD_ADDR_VAR 0 18
76869: PUSH
76870: LD_INT 7
76872: PUSH
76873: LD_INT 28
76875: PUSH
76876: LD_INT 45
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: LIST
76883: PUSH
76884: LD_VAR 0 12
76888: ARRAY
76889: ST_TO_ADDR
// break ;
76890: GO 76894
// end ; end ; end ;
76892: GO 76723
76894: POP
76895: POP
// end ; if not weapon then
76896: LD_VAR 0 18
76900: NOT
76901: IFFALSE 76961
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76903: LD_ADDR_VAR 0 5
76907: PUSH
76908: LD_VAR 0 5
76912: PUSH
76913: LD_INT 11
76915: PUSH
76916: LD_INT 30
76918: PUSH
76919: LD_INT 49
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: LIST
76926: DIFF
76927: ST_TO_ADDR
// if not list then
76928: LD_VAR 0 5
76932: NOT
76933: IFFALSE 76937
// exit ;
76935: GO 77079
// weapon := list [ rand ( 1 , list ) ] ;
76937: LD_ADDR_VAR 0 18
76941: PUSH
76942: LD_VAR 0 5
76946: PUSH
76947: LD_INT 1
76949: PPUSH
76950: LD_VAR 0 5
76954: PPUSH
76955: CALL_OW 12
76959: ARRAY
76960: ST_TO_ADDR
// end ; if weapon then
76961: LD_VAR 0 18
76965: IFFALSE 77079
// begin tmp := CostOfWeapon ( weapon ) ;
76967: LD_ADDR_VAR 0 14
76971: PUSH
76972: LD_VAR 0 18
76976: PPUSH
76977: CALL_OW 451
76981: ST_TO_ADDR
// j := GetBase ( tower ) ;
76982: LD_ADDR_VAR 0 9
76986: PUSH
76987: LD_VAR 0 1
76991: PPUSH
76992: CALL_OW 274
76996: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76997: LD_VAR 0 9
77001: PPUSH
77002: LD_INT 1
77004: PPUSH
77005: CALL_OW 275
77009: PUSH
77010: LD_VAR 0 14
77014: PUSH
77015: LD_INT 1
77017: ARRAY
77018: GREATEREQUAL
77019: PUSH
77020: LD_VAR 0 9
77024: PPUSH
77025: LD_INT 2
77027: PPUSH
77028: CALL_OW 275
77032: PUSH
77033: LD_VAR 0 14
77037: PUSH
77038: LD_INT 2
77040: ARRAY
77041: GREATEREQUAL
77042: AND
77043: PUSH
77044: LD_VAR 0 9
77048: PPUSH
77049: LD_INT 3
77051: PPUSH
77052: CALL_OW 275
77056: PUSH
77057: LD_VAR 0 14
77061: PUSH
77062: LD_INT 3
77064: ARRAY
77065: GREATEREQUAL
77066: AND
77067: IFFALSE 77079
// result := weapon ;
77069: LD_ADDR_VAR 0 3
77073: PUSH
77074: LD_VAR 0 18
77078: ST_TO_ADDR
// end ; end ;
77079: LD_VAR 0 3
77083: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77084: LD_INT 0
77086: PPUSH
77087: PPUSH
// result := true ;
77088: LD_ADDR_VAR 0 3
77092: PUSH
77093: LD_INT 1
77095: ST_TO_ADDR
// if array1 = array2 then
77096: LD_VAR 0 1
77100: PUSH
77101: LD_VAR 0 2
77105: EQUAL
77106: IFFALSE 77166
// begin for i = 1 to array1 do
77108: LD_ADDR_VAR 0 4
77112: PUSH
77113: DOUBLE
77114: LD_INT 1
77116: DEC
77117: ST_TO_ADDR
77118: LD_VAR 0 1
77122: PUSH
77123: FOR_TO
77124: IFFALSE 77162
// if array1 [ i ] <> array2 [ i ] then
77126: LD_VAR 0 1
77130: PUSH
77131: LD_VAR 0 4
77135: ARRAY
77136: PUSH
77137: LD_VAR 0 2
77141: PUSH
77142: LD_VAR 0 4
77146: ARRAY
77147: NONEQUAL
77148: IFFALSE 77160
// begin result := false ;
77150: LD_ADDR_VAR 0 3
77154: PUSH
77155: LD_INT 0
77157: ST_TO_ADDR
// break ;
77158: GO 77162
// end ;
77160: GO 77123
77162: POP
77163: POP
// end else
77164: GO 77174
// result := false ;
77166: LD_ADDR_VAR 0 3
77170: PUSH
77171: LD_INT 0
77173: ST_TO_ADDR
// end ;
77174: LD_VAR 0 3
77178: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77179: LD_INT 0
77181: PPUSH
77182: PPUSH
// if not array1 or not array2 then
77183: LD_VAR 0 1
77187: NOT
77188: PUSH
77189: LD_VAR 0 2
77193: NOT
77194: OR
77195: IFFALSE 77199
// exit ;
77197: GO 77263
// result := true ;
77199: LD_ADDR_VAR 0 3
77203: PUSH
77204: LD_INT 1
77206: ST_TO_ADDR
// for i = 1 to array1 do
77207: LD_ADDR_VAR 0 4
77211: PUSH
77212: DOUBLE
77213: LD_INT 1
77215: DEC
77216: ST_TO_ADDR
77217: LD_VAR 0 1
77221: PUSH
77222: FOR_TO
77223: IFFALSE 77261
// if array1 [ i ] <> array2 [ i ] then
77225: LD_VAR 0 1
77229: PUSH
77230: LD_VAR 0 4
77234: ARRAY
77235: PUSH
77236: LD_VAR 0 2
77240: PUSH
77241: LD_VAR 0 4
77245: ARRAY
77246: NONEQUAL
77247: IFFALSE 77259
// begin result := false ;
77249: LD_ADDR_VAR 0 3
77253: PUSH
77254: LD_INT 0
77256: ST_TO_ADDR
// break ;
77257: GO 77261
// end ;
77259: GO 77222
77261: POP
77262: POP
// end ;
77263: LD_VAR 0 3
77267: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77268: LD_INT 0
77270: PPUSH
77271: PPUSH
77272: PPUSH
// pom := GetBase ( fac ) ;
77273: LD_ADDR_VAR 0 5
77277: PUSH
77278: LD_VAR 0 1
77282: PPUSH
77283: CALL_OW 274
77287: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77288: LD_ADDR_VAR 0 4
77292: PUSH
77293: LD_VAR 0 2
77297: PUSH
77298: LD_INT 1
77300: ARRAY
77301: PPUSH
77302: LD_VAR 0 2
77306: PUSH
77307: LD_INT 2
77309: ARRAY
77310: PPUSH
77311: LD_VAR 0 2
77315: PUSH
77316: LD_INT 3
77318: ARRAY
77319: PPUSH
77320: LD_VAR 0 2
77324: PUSH
77325: LD_INT 4
77327: ARRAY
77328: PPUSH
77329: CALL_OW 449
77333: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77334: LD_ADDR_VAR 0 3
77338: PUSH
77339: LD_VAR 0 5
77343: PPUSH
77344: LD_INT 1
77346: PPUSH
77347: CALL_OW 275
77351: PUSH
77352: LD_VAR 0 4
77356: PUSH
77357: LD_INT 1
77359: ARRAY
77360: GREATEREQUAL
77361: PUSH
77362: LD_VAR 0 5
77366: PPUSH
77367: LD_INT 2
77369: PPUSH
77370: CALL_OW 275
77374: PUSH
77375: LD_VAR 0 4
77379: PUSH
77380: LD_INT 2
77382: ARRAY
77383: GREATEREQUAL
77384: AND
77385: PUSH
77386: LD_VAR 0 5
77390: PPUSH
77391: LD_INT 3
77393: PPUSH
77394: CALL_OW 275
77398: PUSH
77399: LD_VAR 0 4
77403: PUSH
77404: LD_INT 3
77406: ARRAY
77407: GREATEREQUAL
77408: AND
77409: ST_TO_ADDR
// end ;
77410: LD_VAR 0 3
77414: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77415: LD_INT 0
77417: PPUSH
77418: PPUSH
77419: PPUSH
77420: PPUSH
// pom := GetBase ( building ) ;
77421: LD_ADDR_VAR 0 3
77425: PUSH
77426: LD_VAR 0 1
77430: PPUSH
77431: CALL_OW 274
77435: ST_TO_ADDR
// if not pom then
77436: LD_VAR 0 3
77440: NOT
77441: IFFALSE 77445
// exit ;
77443: GO 77615
// btype := GetBType ( building ) ;
77445: LD_ADDR_VAR 0 5
77449: PUSH
77450: LD_VAR 0 1
77454: PPUSH
77455: CALL_OW 266
77459: ST_TO_ADDR
// if btype = b_armoury then
77460: LD_VAR 0 5
77464: PUSH
77465: LD_INT 4
77467: EQUAL
77468: IFFALSE 77478
// btype := b_barracks ;
77470: LD_ADDR_VAR 0 5
77474: PUSH
77475: LD_INT 5
77477: ST_TO_ADDR
// if btype = b_depot then
77478: LD_VAR 0 5
77482: PUSH
77483: LD_INT 0
77485: EQUAL
77486: IFFALSE 77496
// btype := b_warehouse ;
77488: LD_ADDR_VAR 0 5
77492: PUSH
77493: LD_INT 1
77495: ST_TO_ADDR
// if btype = b_workshop then
77496: LD_VAR 0 5
77500: PUSH
77501: LD_INT 2
77503: EQUAL
77504: IFFALSE 77514
// btype := b_factory ;
77506: LD_ADDR_VAR 0 5
77510: PUSH
77511: LD_INT 3
77513: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77514: LD_ADDR_VAR 0 4
77518: PUSH
77519: LD_VAR 0 5
77523: PPUSH
77524: LD_VAR 0 1
77528: PPUSH
77529: CALL_OW 248
77533: PPUSH
77534: CALL_OW 450
77538: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77539: LD_ADDR_VAR 0 2
77543: PUSH
77544: LD_VAR 0 3
77548: PPUSH
77549: LD_INT 1
77551: PPUSH
77552: CALL_OW 275
77556: PUSH
77557: LD_VAR 0 4
77561: PUSH
77562: LD_INT 1
77564: ARRAY
77565: GREATEREQUAL
77566: PUSH
77567: LD_VAR 0 3
77571: PPUSH
77572: LD_INT 2
77574: PPUSH
77575: CALL_OW 275
77579: PUSH
77580: LD_VAR 0 4
77584: PUSH
77585: LD_INT 2
77587: ARRAY
77588: GREATEREQUAL
77589: AND
77590: PUSH
77591: LD_VAR 0 3
77595: PPUSH
77596: LD_INT 3
77598: PPUSH
77599: CALL_OW 275
77603: PUSH
77604: LD_VAR 0 4
77608: PUSH
77609: LD_INT 3
77611: ARRAY
77612: GREATEREQUAL
77613: AND
77614: ST_TO_ADDR
// end ;
77615: LD_VAR 0 2
77619: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77620: LD_INT 0
77622: PPUSH
77623: PPUSH
77624: PPUSH
// pom := GetBase ( building ) ;
77625: LD_ADDR_VAR 0 4
77629: PUSH
77630: LD_VAR 0 1
77634: PPUSH
77635: CALL_OW 274
77639: ST_TO_ADDR
// if not pom then
77640: LD_VAR 0 4
77644: NOT
77645: IFFALSE 77649
// exit ;
77647: GO 77750
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77649: LD_ADDR_VAR 0 5
77653: PUSH
77654: LD_VAR 0 2
77658: PPUSH
77659: LD_VAR 0 1
77663: PPUSH
77664: CALL_OW 248
77668: PPUSH
77669: CALL_OW 450
77673: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77674: LD_ADDR_VAR 0 3
77678: PUSH
77679: LD_VAR 0 4
77683: PPUSH
77684: LD_INT 1
77686: PPUSH
77687: CALL_OW 275
77691: PUSH
77692: LD_VAR 0 5
77696: PUSH
77697: LD_INT 1
77699: ARRAY
77700: GREATEREQUAL
77701: PUSH
77702: LD_VAR 0 4
77706: PPUSH
77707: LD_INT 2
77709: PPUSH
77710: CALL_OW 275
77714: PUSH
77715: LD_VAR 0 5
77719: PUSH
77720: LD_INT 2
77722: ARRAY
77723: GREATEREQUAL
77724: AND
77725: PUSH
77726: LD_VAR 0 4
77730: PPUSH
77731: LD_INT 3
77733: PPUSH
77734: CALL_OW 275
77738: PUSH
77739: LD_VAR 0 5
77743: PUSH
77744: LD_INT 3
77746: ARRAY
77747: GREATEREQUAL
77748: AND
77749: ST_TO_ADDR
// end ;
77750: LD_VAR 0 3
77754: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77755: LD_INT 0
77757: PPUSH
77758: PPUSH
77759: PPUSH
77760: PPUSH
77761: PPUSH
77762: PPUSH
77763: PPUSH
77764: PPUSH
77765: PPUSH
77766: PPUSH
77767: PPUSH
// result := false ;
77768: LD_ADDR_VAR 0 8
77772: PUSH
77773: LD_INT 0
77775: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77776: LD_VAR 0 5
77780: NOT
77781: PUSH
77782: LD_VAR 0 1
77786: NOT
77787: OR
77788: PUSH
77789: LD_VAR 0 2
77793: NOT
77794: OR
77795: PUSH
77796: LD_VAR 0 3
77800: NOT
77801: OR
77802: IFFALSE 77806
// exit ;
77804: GO 78620
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77806: LD_ADDR_VAR 0 14
77810: PUSH
77811: LD_VAR 0 1
77815: PPUSH
77816: LD_VAR 0 2
77820: PPUSH
77821: LD_VAR 0 3
77825: PPUSH
77826: LD_VAR 0 4
77830: PPUSH
77831: LD_VAR 0 5
77835: PUSH
77836: LD_INT 1
77838: ARRAY
77839: PPUSH
77840: CALL_OW 248
77844: PPUSH
77845: LD_INT 0
77847: PPUSH
77848: CALL 79857 0 6
77852: ST_TO_ADDR
// if not hexes then
77853: LD_VAR 0 14
77857: NOT
77858: IFFALSE 77862
// exit ;
77860: GO 78620
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77862: LD_ADDR_VAR 0 17
77866: PUSH
77867: LD_VAR 0 5
77871: PPUSH
77872: LD_INT 22
77874: PUSH
77875: LD_VAR 0 13
77879: PPUSH
77880: CALL_OW 255
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 2
77891: PUSH
77892: LD_INT 30
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 30
77904: PUSH
77905: LD_INT 1
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: LIST
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PPUSH
77921: CALL_OW 72
77925: ST_TO_ADDR
// for i = 1 to hexes do
77926: LD_ADDR_VAR 0 9
77930: PUSH
77931: DOUBLE
77932: LD_INT 1
77934: DEC
77935: ST_TO_ADDR
77936: LD_VAR 0 14
77940: PUSH
77941: FOR_TO
77942: IFFALSE 78618
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77944: LD_ADDR_VAR 0 13
77948: PUSH
77949: LD_VAR 0 14
77953: PUSH
77954: LD_VAR 0 9
77958: ARRAY
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: PPUSH
77964: LD_VAR 0 14
77968: PUSH
77969: LD_VAR 0 9
77973: ARRAY
77974: PUSH
77975: LD_INT 2
77977: ARRAY
77978: PPUSH
77979: CALL_OW 428
77983: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77984: LD_VAR 0 14
77988: PUSH
77989: LD_VAR 0 9
77993: ARRAY
77994: PUSH
77995: LD_INT 1
77997: ARRAY
77998: PPUSH
77999: LD_VAR 0 14
78003: PUSH
78004: LD_VAR 0 9
78008: ARRAY
78009: PUSH
78010: LD_INT 2
78012: ARRAY
78013: PPUSH
78014: CALL_OW 351
78018: PUSH
78019: LD_VAR 0 14
78023: PUSH
78024: LD_VAR 0 9
78028: ARRAY
78029: PUSH
78030: LD_INT 1
78032: ARRAY
78033: PPUSH
78034: LD_VAR 0 14
78038: PUSH
78039: LD_VAR 0 9
78043: ARRAY
78044: PUSH
78045: LD_INT 2
78047: ARRAY
78048: PPUSH
78049: CALL_OW 488
78053: NOT
78054: OR
78055: PUSH
78056: LD_VAR 0 13
78060: PPUSH
78061: CALL_OW 247
78065: PUSH
78066: LD_INT 3
78068: EQUAL
78069: OR
78070: IFFALSE 78076
// exit ;
78072: POP
78073: POP
78074: GO 78620
// if not tmp then
78076: LD_VAR 0 13
78080: NOT
78081: IFFALSE 78085
// continue ;
78083: GO 77941
// result := true ;
78085: LD_ADDR_VAR 0 8
78089: PUSH
78090: LD_INT 1
78092: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78093: LD_VAR 0 6
78097: PUSH
78098: LD_VAR 0 13
78102: PPUSH
78103: CALL_OW 247
78107: PUSH
78108: LD_INT 2
78110: EQUAL
78111: AND
78112: PUSH
78113: LD_VAR 0 13
78117: PPUSH
78118: CALL_OW 263
78122: PUSH
78123: LD_INT 1
78125: EQUAL
78126: AND
78127: IFFALSE 78291
// begin if IsDrivenBy ( tmp ) then
78129: LD_VAR 0 13
78133: PPUSH
78134: CALL_OW 311
78138: IFFALSE 78142
// continue ;
78140: GO 77941
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78142: LD_VAR 0 6
78146: PPUSH
78147: LD_INT 3
78149: PUSH
78150: LD_INT 60
78152: PUSH
78153: EMPTY
78154: LIST
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 3
78162: PUSH
78163: LD_INT 55
78165: PUSH
78166: EMPTY
78167: LIST
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PPUSH
78177: CALL_OW 72
78181: IFFALSE 78289
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78183: LD_ADDR_VAR 0 18
78187: PUSH
78188: LD_VAR 0 6
78192: PPUSH
78193: LD_INT 3
78195: PUSH
78196: LD_INT 60
78198: PUSH
78199: EMPTY
78200: LIST
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 3
78208: PUSH
78209: LD_INT 55
78211: PUSH
78212: EMPTY
78213: LIST
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: EMPTY
78220: LIST
78221: LIST
78222: PPUSH
78223: CALL_OW 72
78227: PUSH
78228: LD_INT 1
78230: ARRAY
78231: ST_TO_ADDR
// if IsInUnit ( driver ) then
78232: LD_VAR 0 18
78236: PPUSH
78237: CALL_OW 310
78241: IFFALSE 78252
// ComExit ( driver ) ;
78243: LD_VAR 0 18
78247: PPUSH
78248: CALL 102985 0 1
// AddComEnterUnit ( driver , tmp ) ;
78252: LD_VAR 0 18
78256: PPUSH
78257: LD_VAR 0 13
78261: PPUSH
78262: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78266: LD_VAR 0 18
78270: PPUSH
78271: LD_VAR 0 7
78275: PPUSH
78276: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78280: LD_VAR 0 18
78284: PPUSH
78285: CALL_OW 181
// end ; continue ;
78289: GO 77941
// end ; if not cleaners or not tmp in cleaners then
78291: LD_VAR 0 6
78295: NOT
78296: PUSH
78297: LD_VAR 0 13
78301: PUSH
78302: LD_VAR 0 6
78306: IN
78307: NOT
78308: OR
78309: IFFALSE 78616
// begin if dep then
78311: LD_VAR 0 17
78315: IFFALSE 78451
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78317: LD_ADDR_VAR 0 16
78321: PUSH
78322: LD_VAR 0 17
78326: PUSH
78327: LD_INT 1
78329: ARRAY
78330: PPUSH
78331: CALL_OW 250
78335: PPUSH
78336: LD_VAR 0 17
78340: PUSH
78341: LD_INT 1
78343: ARRAY
78344: PPUSH
78345: CALL_OW 254
78349: PPUSH
78350: LD_INT 5
78352: PPUSH
78353: CALL_OW 272
78357: PUSH
78358: LD_VAR 0 17
78362: PUSH
78363: LD_INT 1
78365: ARRAY
78366: PPUSH
78367: CALL_OW 251
78371: PPUSH
78372: LD_VAR 0 17
78376: PUSH
78377: LD_INT 1
78379: ARRAY
78380: PPUSH
78381: CALL_OW 254
78385: PPUSH
78386: LD_INT 5
78388: PPUSH
78389: CALL_OW 273
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78398: LD_VAR 0 16
78402: PUSH
78403: LD_INT 1
78405: ARRAY
78406: PPUSH
78407: LD_VAR 0 16
78411: PUSH
78412: LD_INT 2
78414: ARRAY
78415: PPUSH
78416: CALL_OW 488
78420: IFFALSE 78451
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78422: LD_VAR 0 13
78426: PPUSH
78427: LD_VAR 0 16
78431: PUSH
78432: LD_INT 1
78434: ARRAY
78435: PPUSH
78436: LD_VAR 0 16
78440: PUSH
78441: LD_INT 2
78443: ARRAY
78444: PPUSH
78445: CALL_OW 111
// continue ;
78449: GO 77941
// end ; end ; r := GetDir ( tmp ) ;
78451: LD_ADDR_VAR 0 15
78455: PUSH
78456: LD_VAR 0 13
78460: PPUSH
78461: CALL_OW 254
78465: ST_TO_ADDR
// if r = 5 then
78466: LD_VAR 0 15
78470: PUSH
78471: LD_INT 5
78473: EQUAL
78474: IFFALSE 78484
// r := 0 ;
78476: LD_ADDR_VAR 0 15
78480: PUSH
78481: LD_INT 0
78483: ST_TO_ADDR
// for j = r to 5 do
78484: LD_ADDR_VAR 0 10
78488: PUSH
78489: DOUBLE
78490: LD_VAR 0 15
78494: DEC
78495: ST_TO_ADDR
78496: LD_INT 5
78498: PUSH
78499: FOR_TO
78500: IFFALSE 78614
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78502: LD_ADDR_VAR 0 11
78506: PUSH
78507: LD_VAR 0 13
78511: PPUSH
78512: CALL_OW 250
78516: PPUSH
78517: LD_VAR 0 10
78521: PPUSH
78522: LD_INT 2
78524: PPUSH
78525: CALL_OW 272
78529: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78530: LD_ADDR_VAR 0 12
78534: PUSH
78535: LD_VAR 0 13
78539: PPUSH
78540: CALL_OW 251
78544: PPUSH
78545: LD_VAR 0 10
78549: PPUSH
78550: LD_INT 2
78552: PPUSH
78553: CALL_OW 273
78557: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78558: LD_VAR 0 11
78562: PPUSH
78563: LD_VAR 0 12
78567: PPUSH
78568: CALL_OW 488
78572: PUSH
78573: LD_VAR 0 11
78577: PPUSH
78578: LD_VAR 0 12
78582: PPUSH
78583: CALL_OW 428
78587: NOT
78588: AND
78589: IFFALSE 78612
// begin ComMoveXY ( tmp , _x , _y ) ;
78591: LD_VAR 0 13
78595: PPUSH
78596: LD_VAR 0 11
78600: PPUSH
78601: LD_VAR 0 12
78605: PPUSH
78606: CALL_OW 111
// break ;
78610: GO 78614
// end ; end ;
78612: GO 78499
78614: POP
78615: POP
// end ; end ;
78616: GO 77941
78618: POP
78619: POP
// end ;
78620: LD_VAR 0 8
78624: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78625: LD_INT 0
78627: PPUSH
// result := true ;
78628: LD_ADDR_VAR 0 3
78632: PUSH
78633: LD_INT 1
78635: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78636: LD_VAR 0 2
78640: PUSH
78641: LD_INT 24
78643: DOUBLE
78644: EQUAL
78645: IFTRUE 78655
78647: LD_INT 33
78649: DOUBLE
78650: EQUAL
78651: IFTRUE 78655
78653: GO 78680
78655: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78656: LD_ADDR_VAR 0 3
78660: PUSH
78661: LD_INT 32
78663: PPUSH
78664: LD_VAR 0 1
78668: PPUSH
78669: CALL_OW 321
78673: PUSH
78674: LD_INT 2
78676: EQUAL
78677: ST_TO_ADDR
78678: GO 79000
78680: LD_INT 20
78682: DOUBLE
78683: EQUAL
78684: IFTRUE 78688
78686: GO 78713
78688: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78689: LD_ADDR_VAR 0 3
78693: PUSH
78694: LD_INT 6
78696: PPUSH
78697: LD_VAR 0 1
78701: PPUSH
78702: CALL_OW 321
78706: PUSH
78707: LD_INT 2
78709: EQUAL
78710: ST_TO_ADDR
78711: GO 79000
78713: LD_INT 22
78715: DOUBLE
78716: EQUAL
78717: IFTRUE 78727
78719: LD_INT 36
78721: DOUBLE
78722: EQUAL
78723: IFTRUE 78727
78725: GO 78752
78727: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78728: LD_ADDR_VAR 0 3
78732: PUSH
78733: LD_INT 15
78735: PPUSH
78736: LD_VAR 0 1
78740: PPUSH
78741: CALL_OW 321
78745: PUSH
78746: LD_INT 2
78748: EQUAL
78749: ST_TO_ADDR
78750: GO 79000
78752: LD_INT 30
78754: DOUBLE
78755: EQUAL
78756: IFTRUE 78760
78758: GO 78785
78760: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78761: LD_ADDR_VAR 0 3
78765: PUSH
78766: LD_INT 20
78768: PPUSH
78769: LD_VAR 0 1
78773: PPUSH
78774: CALL_OW 321
78778: PUSH
78779: LD_INT 2
78781: EQUAL
78782: ST_TO_ADDR
78783: GO 79000
78785: LD_INT 28
78787: DOUBLE
78788: EQUAL
78789: IFTRUE 78799
78791: LD_INT 21
78793: DOUBLE
78794: EQUAL
78795: IFTRUE 78799
78797: GO 78824
78799: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78800: LD_ADDR_VAR 0 3
78804: PUSH
78805: LD_INT 21
78807: PPUSH
78808: LD_VAR 0 1
78812: PPUSH
78813: CALL_OW 321
78817: PUSH
78818: LD_INT 2
78820: EQUAL
78821: ST_TO_ADDR
78822: GO 79000
78824: LD_INT 16
78826: DOUBLE
78827: EQUAL
78828: IFTRUE 78832
78830: GO 78859
78832: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78833: LD_ADDR_VAR 0 3
78837: PUSH
78838: LD_EXP 108
78842: PPUSH
78843: LD_VAR 0 1
78847: PPUSH
78848: CALL_OW 321
78852: PUSH
78853: LD_INT 2
78855: EQUAL
78856: ST_TO_ADDR
78857: GO 79000
78859: LD_INT 19
78861: DOUBLE
78862: EQUAL
78863: IFTRUE 78873
78865: LD_INT 23
78867: DOUBLE
78868: EQUAL
78869: IFTRUE 78873
78871: GO 78900
78873: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78874: LD_ADDR_VAR 0 3
78878: PUSH
78879: LD_EXP 107
78883: PPUSH
78884: LD_VAR 0 1
78888: PPUSH
78889: CALL_OW 321
78893: PUSH
78894: LD_INT 2
78896: EQUAL
78897: ST_TO_ADDR
78898: GO 79000
78900: LD_INT 17
78902: DOUBLE
78903: EQUAL
78904: IFTRUE 78908
78906: GO 78933
78908: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78909: LD_ADDR_VAR 0 3
78913: PUSH
78914: LD_INT 39
78916: PPUSH
78917: LD_VAR 0 1
78921: PPUSH
78922: CALL_OW 321
78926: PUSH
78927: LD_INT 2
78929: EQUAL
78930: ST_TO_ADDR
78931: GO 79000
78933: LD_INT 18
78935: DOUBLE
78936: EQUAL
78937: IFTRUE 78941
78939: GO 78966
78941: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78942: LD_ADDR_VAR 0 3
78946: PUSH
78947: LD_INT 40
78949: PPUSH
78950: LD_VAR 0 1
78954: PPUSH
78955: CALL_OW 321
78959: PUSH
78960: LD_INT 2
78962: EQUAL
78963: ST_TO_ADDR
78964: GO 79000
78966: LD_INT 27
78968: DOUBLE
78969: EQUAL
78970: IFTRUE 78974
78972: GO 78999
78974: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78975: LD_ADDR_VAR 0 3
78979: PUSH
78980: LD_INT 35
78982: PPUSH
78983: LD_VAR 0 1
78987: PPUSH
78988: CALL_OW 321
78992: PUSH
78993: LD_INT 2
78995: EQUAL
78996: ST_TO_ADDR
78997: GO 79000
78999: POP
// end ;
79000: LD_VAR 0 3
79004: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
79005: LD_INT 0
79007: PPUSH
79008: PPUSH
79009: PPUSH
79010: PPUSH
79011: PPUSH
79012: PPUSH
79013: PPUSH
79014: PPUSH
79015: PPUSH
79016: PPUSH
79017: PPUSH
// result := false ;
79018: LD_ADDR_VAR 0 6
79022: PUSH
79023: LD_INT 0
79025: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79026: LD_VAR 0 1
79030: NOT
79031: PUSH
79032: LD_VAR 0 1
79036: PPUSH
79037: CALL_OW 266
79041: PUSH
79042: LD_INT 0
79044: PUSH
79045: LD_INT 1
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: IN
79052: NOT
79053: OR
79054: PUSH
79055: LD_VAR 0 2
79059: NOT
79060: OR
79061: PUSH
79062: LD_VAR 0 5
79066: PUSH
79067: LD_INT 0
79069: PUSH
79070: LD_INT 1
79072: PUSH
79073: LD_INT 2
79075: PUSH
79076: LD_INT 3
79078: PUSH
79079: LD_INT 4
79081: PUSH
79082: LD_INT 5
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: IN
79093: NOT
79094: OR
79095: PUSH
79096: LD_VAR 0 3
79100: PPUSH
79101: LD_VAR 0 4
79105: PPUSH
79106: CALL_OW 488
79110: NOT
79111: OR
79112: IFFALSE 79116
// exit ;
79114: GO 79852
// side := GetSide ( depot ) ;
79116: LD_ADDR_VAR 0 9
79120: PUSH
79121: LD_VAR 0 1
79125: PPUSH
79126: CALL_OW 255
79130: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79131: LD_VAR 0 9
79135: PPUSH
79136: LD_VAR 0 2
79140: PPUSH
79141: CALL 78625 0 2
79145: NOT
79146: IFFALSE 79150
// exit ;
79148: GO 79852
// pom := GetBase ( depot ) ;
79150: LD_ADDR_VAR 0 10
79154: PUSH
79155: LD_VAR 0 1
79159: PPUSH
79160: CALL_OW 274
79164: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79165: LD_ADDR_VAR 0 11
79169: PUSH
79170: LD_VAR 0 2
79174: PPUSH
79175: LD_VAR 0 1
79179: PPUSH
79180: CALL_OW 248
79184: PPUSH
79185: CALL_OW 450
79189: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79190: LD_VAR 0 10
79194: PPUSH
79195: LD_INT 1
79197: PPUSH
79198: CALL_OW 275
79202: PUSH
79203: LD_VAR 0 11
79207: PUSH
79208: LD_INT 1
79210: ARRAY
79211: GREATEREQUAL
79212: PUSH
79213: LD_VAR 0 10
79217: PPUSH
79218: LD_INT 2
79220: PPUSH
79221: CALL_OW 275
79225: PUSH
79226: LD_VAR 0 11
79230: PUSH
79231: LD_INT 2
79233: ARRAY
79234: GREATEREQUAL
79235: AND
79236: PUSH
79237: LD_VAR 0 10
79241: PPUSH
79242: LD_INT 3
79244: PPUSH
79245: CALL_OW 275
79249: PUSH
79250: LD_VAR 0 11
79254: PUSH
79255: LD_INT 3
79257: ARRAY
79258: GREATEREQUAL
79259: AND
79260: NOT
79261: IFFALSE 79265
// exit ;
79263: GO 79852
// if GetBType ( depot ) = b_depot then
79265: LD_VAR 0 1
79269: PPUSH
79270: CALL_OW 266
79274: PUSH
79275: LD_INT 0
79277: EQUAL
79278: IFFALSE 79290
// dist := 28 else
79280: LD_ADDR_VAR 0 14
79284: PUSH
79285: LD_INT 28
79287: ST_TO_ADDR
79288: GO 79298
// dist := 36 ;
79290: LD_ADDR_VAR 0 14
79294: PUSH
79295: LD_INT 36
79297: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79298: LD_VAR 0 1
79302: PPUSH
79303: LD_VAR 0 3
79307: PPUSH
79308: LD_VAR 0 4
79312: PPUSH
79313: CALL_OW 297
79317: PUSH
79318: LD_VAR 0 14
79322: GREATER
79323: IFFALSE 79327
// exit ;
79325: GO 79852
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79327: LD_ADDR_VAR 0 12
79331: PUSH
79332: LD_VAR 0 2
79336: PPUSH
79337: LD_VAR 0 3
79341: PPUSH
79342: LD_VAR 0 4
79346: PPUSH
79347: LD_VAR 0 5
79351: PPUSH
79352: LD_VAR 0 1
79356: PPUSH
79357: CALL_OW 248
79361: PPUSH
79362: LD_INT 0
79364: PPUSH
79365: CALL 79857 0 6
79369: ST_TO_ADDR
// if not hexes then
79370: LD_VAR 0 12
79374: NOT
79375: IFFALSE 79379
// exit ;
79377: GO 79852
// hex := GetHexInfo ( x , y ) ;
79379: LD_ADDR_VAR 0 15
79383: PUSH
79384: LD_VAR 0 3
79388: PPUSH
79389: LD_VAR 0 4
79393: PPUSH
79394: CALL_OW 546
79398: ST_TO_ADDR
// if hex [ 1 ] then
79399: LD_VAR 0 15
79403: PUSH
79404: LD_INT 1
79406: ARRAY
79407: IFFALSE 79411
// exit ;
79409: GO 79852
// height := hex [ 2 ] ;
79411: LD_ADDR_VAR 0 13
79415: PUSH
79416: LD_VAR 0 15
79420: PUSH
79421: LD_INT 2
79423: ARRAY
79424: ST_TO_ADDR
// for i = 1 to hexes do
79425: LD_ADDR_VAR 0 7
79429: PUSH
79430: DOUBLE
79431: LD_INT 1
79433: DEC
79434: ST_TO_ADDR
79435: LD_VAR 0 12
79439: PUSH
79440: FOR_TO
79441: IFFALSE 79771
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79443: LD_VAR 0 12
79447: PUSH
79448: LD_VAR 0 7
79452: ARRAY
79453: PUSH
79454: LD_INT 1
79456: ARRAY
79457: PPUSH
79458: LD_VAR 0 12
79462: PUSH
79463: LD_VAR 0 7
79467: ARRAY
79468: PUSH
79469: LD_INT 2
79471: ARRAY
79472: PPUSH
79473: CALL_OW 488
79477: NOT
79478: PUSH
79479: LD_VAR 0 12
79483: PUSH
79484: LD_VAR 0 7
79488: ARRAY
79489: PUSH
79490: LD_INT 1
79492: ARRAY
79493: PPUSH
79494: LD_VAR 0 12
79498: PUSH
79499: LD_VAR 0 7
79503: ARRAY
79504: PUSH
79505: LD_INT 2
79507: ARRAY
79508: PPUSH
79509: CALL_OW 428
79513: PUSH
79514: LD_INT 0
79516: GREATER
79517: OR
79518: PUSH
79519: LD_VAR 0 12
79523: PUSH
79524: LD_VAR 0 7
79528: ARRAY
79529: PUSH
79530: LD_INT 1
79532: ARRAY
79533: PPUSH
79534: LD_VAR 0 12
79538: PUSH
79539: LD_VAR 0 7
79543: ARRAY
79544: PUSH
79545: LD_INT 2
79547: ARRAY
79548: PPUSH
79549: CALL_OW 351
79553: OR
79554: IFFALSE 79560
// exit ;
79556: POP
79557: POP
79558: GO 79852
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79560: LD_ADDR_VAR 0 8
79564: PUSH
79565: LD_VAR 0 12
79569: PUSH
79570: LD_VAR 0 7
79574: ARRAY
79575: PUSH
79576: LD_INT 1
79578: ARRAY
79579: PPUSH
79580: LD_VAR 0 12
79584: PUSH
79585: LD_VAR 0 7
79589: ARRAY
79590: PUSH
79591: LD_INT 2
79593: ARRAY
79594: PPUSH
79595: CALL_OW 546
79599: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79600: LD_VAR 0 8
79604: PUSH
79605: LD_INT 1
79607: ARRAY
79608: PUSH
79609: LD_VAR 0 8
79613: PUSH
79614: LD_INT 2
79616: ARRAY
79617: PUSH
79618: LD_VAR 0 13
79622: PUSH
79623: LD_INT 2
79625: PLUS
79626: GREATER
79627: OR
79628: PUSH
79629: LD_VAR 0 8
79633: PUSH
79634: LD_INT 2
79636: ARRAY
79637: PUSH
79638: LD_VAR 0 13
79642: PUSH
79643: LD_INT 2
79645: MINUS
79646: LESS
79647: OR
79648: PUSH
79649: LD_VAR 0 8
79653: PUSH
79654: LD_INT 3
79656: ARRAY
79657: PUSH
79658: LD_INT 0
79660: PUSH
79661: LD_INT 8
79663: PUSH
79664: LD_INT 9
79666: PUSH
79667: LD_INT 10
79669: PUSH
79670: LD_INT 11
79672: PUSH
79673: LD_INT 12
79675: PUSH
79676: LD_INT 13
79678: PUSH
79679: LD_INT 16
79681: PUSH
79682: LD_INT 17
79684: PUSH
79685: LD_INT 18
79687: PUSH
79688: LD_INT 19
79690: PUSH
79691: LD_INT 20
79693: PUSH
79694: LD_INT 21
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: IN
79712: NOT
79713: OR
79714: PUSH
79715: LD_VAR 0 8
79719: PUSH
79720: LD_INT 5
79722: ARRAY
79723: NOT
79724: OR
79725: PUSH
79726: LD_VAR 0 8
79730: PUSH
79731: LD_INT 6
79733: ARRAY
79734: PUSH
79735: LD_INT 1
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 7
79743: PUSH
79744: LD_INT 9
79746: PUSH
79747: LD_INT 10
79749: PUSH
79750: LD_INT 11
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: IN
79761: NOT
79762: OR
79763: IFFALSE 79769
// exit ;
79765: POP
79766: POP
79767: GO 79852
// end ;
79769: GO 79440
79771: POP
79772: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79773: LD_VAR 0 9
79777: PPUSH
79778: LD_VAR 0 3
79782: PPUSH
79783: LD_VAR 0 4
79787: PPUSH
79788: LD_INT 20
79790: PPUSH
79791: CALL 71798 0 4
79795: PUSH
79796: LD_INT 4
79798: ARRAY
79799: IFFALSE 79803
// exit ;
79801: GO 79852
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79803: LD_VAR 0 2
79807: PUSH
79808: LD_INT 29
79810: PUSH
79811: LD_INT 30
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: IN
79818: PUSH
79819: LD_VAR 0 3
79823: PPUSH
79824: LD_VAR 0 4
79828: PPUSH
79829: LD_VAR 0 9
79833: PPUSH
79834: CALL_OW 440
79838: NOT
79839: AND
79840: IFFALSE 79844
// exit ;
79842: GO 79852
// result := true ;
79844: LD_ADDR_VAR 0 6
79848: PUSH
79849: LD_INT 1
79851: ST_TO_ADDR
// end ;
79852: LD_VAR 0 6
79856: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79857: LD_INT 0
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
79878: PPUSH
79879: PPUSH
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
79886: PPUSH
79887: PPUSH
79888: PPUSH
79889: PPUSH
79890: PPUSH
79891: PPUSH
79892: PPUSH
79893: PPUSH
79894: PPUSH
79895: PPUSH
79896: PPUSH
79897: PPUSH
79898: PPUSH
79899: PPUSH
79900: PPUSH
79901: PPUSH
79902: PPUSH
79903: PPUSH
79904: PPUSH
79905: PPUSH
79906: PPUSH
79907: PPUSH
79908: PPUSH
79909: PPUSH
79910: PPUSH
79911: PPUSH
79912: PPUSH
79913: PPUSH
79914: PPUSH
79915: PPUSH
79916: PPUSH
// result = [ ] ;
79917: LD_ADDR_VAR 0 7
79921: PUSH
79922: EMPTY
79923: ST_TO_ADDR
// temp_list = [ ] ;
79924: LD_ADDR_VAR 0 9
79928: PUSH
79929: EMPTY
79930: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79931: LD_VAR 0 4
79935: PUSH
79936: LD_INT 0
79938: PUSH
79939: LD_INT 1
79941: PUSH
79942: LD_INT 2
79944: PUSH
79945: LD_INT 3
79947: PUSH
79948: LD_INT 4
79950: PUSH
79951: LD_INT 5
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: IN
79962: NOT
79963: PUSH
79964: LD_VAR 0 1
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: IN
79979: PUSH
79980: LD_VAR 0 5
79984: PUSH
79985: LD_INT 1
79987: PUSH
79988: LD_INT 2
79990: PUSH
79991: LD_INT 3
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: LIST
79998: IN
79999: NOT
80000: AND
80001: OR
80002: IFFALSE 80006
// exit ;
80004: GO 98397
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80006: LD_VAR 0 1
80010: PUSH
80011: LD_INT 6
80013: PUSH
80014: LD_INT 7
80016: PUSH
80017: LD_INT 8
80019: PUSH
80020: LD_INT 13
80022: PUSH
80023: LD_INT 12
80025: PUSH
80026: LD_INT 15
80028: PUSH
80029: LD_INT 11
80031: PUSH
80032: LD_INT 14
80034: PUSH
80035: LD_INT 10
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: IN
80049: IFFALSE 80059
// btype = b_lab ;
80051: LD_ADDR_VAR 0 1
80055: PUSH
80056: LD_INT 6
80058: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80059: LD_VAR 0 6
80063: PUSH
80064: LD_INT 0
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 2
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: LIST
80077: IN
80078: NOT
80079: PUSH
80080: LD_VAR 0 1
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: LD_INT 1
80090: PUSH
80091: LD_INT 2
80093: PUSH
80094: LD_INT 3
80096: PUSH
80097: LD_INT 6
80099: PUSH
80100: LD_INT 36
80102: PUSH
80103: LD_INT 4
80105: PUSH
80106: LD_INT 5
80108: PUSH
80109: LD_INT 31
80111: PUSH
80112: LD_INT 32
80114: PUSH
80115: LD_INT 33
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: IN
80131: NOT
80132: PUSH
80133: LD_VAR 0 6
80137: PUSH
80138: LD_INT 1
80140: EQUAL
80141: AND
80142: OR
80143: PUSH
80144: LD_VAR 0 1
80148: PUSH
80149: LD_INT 2
80151: PUSH
80152: LD_INT 3
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: IN
80159: NOT
80160: PUSH
80161: LD_VAR 0 6
80165: PUSH
80166: LD_INT 2
80168: EQUAL
80169: AND
80170: OR
80171: IFFALSE 80181
// mode = 0 ;
80173: LD_ADDR_VAR 0 6
80177: PUSH
80178: LD_INT 0
80180: ST_TO_ADDR
// case mode of 0 :
80181: LD_VAR 0 6
80185: PUSH
80186: LD_INT 0
80188: DOUBLE
80189: EQUAL
80190: IFTRUE 80194
80192: GO 91647
80194: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80195: LD_ADDR_VAR 0 11
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 0
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: LD_INT 1
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 0
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: LD_INT 1
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: LD_INT 1
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: LD_INT 0
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: NEG
80265: PUSH
80266: LD_INT 1
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 1
80276: NEG
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 0
80288: PUSH
80289: LD_INT 2
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 1
80299: PUSH
80300: LD_INT 1
80302: NEG
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 1
80310: PUSH
80311: LD_INT 2
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 0
80320: PUSH
80321: LD_INT 2
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: LD_INT 1
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 1
80341: PUSH
80342: LD_INT 3
80344: PUSH
80345: EMPTY
80346: LIST
80347: LIST
80348: PUSH
80349: LD_INT 0
80351: PUSH
80352: LD_INT 3
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: PUSH
80359: LD_INT 1
80361: NEG
80362: PUSH
80363: LD_INT 2
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80388: LD_ADDR_VAR 0 12
80392: PUSH
80393: LD_INT 0
80395: PUSH
80396: LD_INT 0
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 1
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 1
80426: PUSH
80427: LD_INT 1
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 0
80436: PUSH
80437: LD_INT 1
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 1
80446: NEG
80447: PUSH
80448: LD_INT 0
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: LD_INT 1
80461: NEG
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 1
80472: NEG
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 2
80480: PUSH
80481: LD_INT 0
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: LD_INT 1
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: NEG
80501: PUSH
80502: LD_INT 1
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: NEG
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 2
80522: NEG
80523: PUSH
80524: LD_INT 1
80526: NEG
80527: PUSH
80528: EMPTY
80529: LIST
80530: LIST
80531: PUSH
80532: LD_INT 2
80534: NEG
80535: PUSH
80536: LD_INT 1
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 3
80545: NEG
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 3
80556: NEG
80557: PUSH
80558: LD_INT 1
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80584: LD_ADDR_VAR 0 13
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: LD_INT 0
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 0
80601: PUSH
80602: LD_INT 1
80604: NEG
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: PUSH
80613: LD_INT 0
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 1
80622: PUSH
80623: LD_INT 1
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: LD_INT 1
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 1
80642: NEG
80643: PUSH
80644: LD_INT 0
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 1
80665: NEG
80666: PUSH
80667: LD_INT 2
80669: NEG
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 2
80687: PUSH
80688: LD_INT 2
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 1
80697: PUSH
80698: LD_INT 2
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 2
80707: NEG
80708: PUSH
80709: LD_INT 1
80711: NEG
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 2
80719: NEG
80720: PUSH
80721: LD_INT 2
80723: NEG
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 2
80731: NEG
80732: PUSH
80733: LD_INT 3
80735: NEG
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 3
80743: NEG
80744: PUSH
80745: LD_INT 2
80747: NEG
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 3
80755: NEG
80756: PUSH
80757: LD_INT 3
80759: NEG
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80783: LD_ADDR_VAR 0 14
80787: PUSH
80788: LD_INT 0
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 1
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: PUSH
80822: LD_INT 1
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 0
80876: PUSH
80877: LD_INT 2
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 1
80887: PUSH
80888: LD_INT 1
80890: NEG
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 1
80898: PUSH
80899: LD_INT 2
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 0
80908: PUSH
80909: LD_INT 2
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 1
80918: NEG
80919: PUSH
80920: LD_INT 1
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: NEG
80930: PUSH
80931: LD_INT 3
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 0
80941: PUSH
80942: LD_INT 3
80944: NEG
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 1
80952: PUSH
80953: LD_INT 2
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80979: LD_ADDR_VAR 0 15
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: LD_INT 0
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 1
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: LD_INT 0
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: PUSH
81018: LD_INT 1
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 0
81027: PUSH
81028: LD_INT 1
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 1
81037: NEG
81038: PUSH
81039: LD_INT 0
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: LD_INT 1
81048: NEG
81049: PUSH
81050: LD_INT 1
81052: NEG
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: PUSH
81061: LD_INT 1
81063: NEG
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: PUSH
81072: LD_INT 0
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 2
81081: PUSH
81082: LD_INT 1
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 1
81091: NEG
81092: PUSH
81093: LD_INT 1
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 2
81102: NEG
81103: PUSH
81104: LD_INT 0
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 2
81113: NEG
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 3
81136: PUSH
81137: LD_INT 0
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PUSH
81144: LD_INT 3
81146: PUSH
81147: LD_INT 1
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: EMPTY
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81172: LD_ADDR_VAR 0 16
81176: PUSH
81177: LD_INT 0
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: LD_INT 1
81192: NEG
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 1
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 1
81210: PUSH
81211: LD_INT 1
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 0
81220: PUSH
81221: LD_INT 1
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 1
81230: NEG
81231: PUSH
81232: LD_INT 0
81234: PUSH
81235: EMPTY
81236: LIST
81237: LIST
81238: PUSH
81239: LD_INT 1
81241: NEG
81242: PUSH
81243: LD_INT 1
81245: NEG
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: LD_INT 2
81257: NEG
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 2
81265: PUSH
81266: LD_INT 1
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 2
81275: PUSH
81276: LD_INT 2
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: LD_INT 2
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 2
81295: NEG
81296: PUSH
81297: LD_INT 1
81299: NEG
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 2
81307: NEG
81308: PUSH
81309: LD_INT 2
81311: NEG
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 3
81319: PUSH
81320: LD_INT 2
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 3
81329: PUSH
81330: LD_INT 3
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 2
81339: PUSH
81340: LD_INT 3
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81365: LD_ADDR_VAR 0 17
81369: PUSH
81370: LD_INT 0
81372: PUSH
81373: LD_INT 0
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 1
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 1
81403: PUSH
81404: LD_INT 1
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: LD_INT 1
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 1
81423: NEG
81424: PUSH
81425: LD_INT 0
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 1
81434: NEG
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 1
81446: NEG
81447: PUSH
81448: LD_INT 2
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 0
81458: PUSH
81459: LD_INT 2
81461: NEG
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 2
81490: PUSH
81491: LD_INT 1
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 2
81500: PUSH
81501: LD_INT 2
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 1
81510: PUSH
81511: LD_INT 2
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 0
81520: PUSH
81521: LD_INT 2
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: PUSH
81528: LD_INT 1
81530: NEG
81531: PUSH
81532: LD_INT 1
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PUSH
81539: LD_INT 2
81541: NEG
81542: PUSH
81543: LD_INT 0
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 2
81552: NEG
81553: PUSH
81554: LD_INT 1
81556: NEG
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 2
81564: NEG
81565: PUSH
81566: LD_INT 2
81568: NEG
81569: PUSH
81570: EMPTY
81571: LIST
81572: LIST
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81595: LD_ADDR_VAR 0 18
81599: PUSH
81600: LD_INT 0
81602: PUSH
81603: LD_INT 0
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: LD_INT 1
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 1
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 0
81643: PUSH
81644: LD_INT 1
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: PUSH
81651: LD_INT 1
81653: NEG
81654: PUSH
81655: LD_INT 0
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 1
81664: NEG
81665: PUSH
81666: LD_INT 1
81668: NEG
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 1
81676: NEG
81677: PUSH
81678: LD_INT 2
81680: NEG
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 0
81688: PUSH
81689: LD_INT 2
81691: NEG
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 1
81699: PUSH
81700: LD_INT 1
81702: NEG
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: LD_INT 0
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 2
81720: PUSH
81721: LD_INT 1
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 2
81730: PUSH
81731: LD_INT 2
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: LD_INT 2
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 0
81750: PUSH
81751: LD_INT 2
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 1
81760: NEG
81761: PUSH
81762: LD_INT 1
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 2
81771: NEG
81772: PUSH
81773: LD_INT 0
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: PUSH
81780: LD_INT 2
81782: NEG
81783: PUSH
81784: LD_INT 1
81786: NEG
81787: PUSH
81788: EMPTY
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 2
81794: NEG
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81825: LD_ADDR_VAR 0 19
81829: PUSH
81830: LD_INT 0
81832: PUSH
81833: LD_INT 0
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 1
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 0
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 1
81883: NEG
81884: PUSH
81885: LD_INT 0
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: NEG
81907: PUSH
81908: LD_INT 2
81910: NEG
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: LD_INT 2
81921: NEG
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 1
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 2
81940: PUSH
81941: LD_INT 0
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 2
81950: PUSH
81951: LD_INT 1
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 2
81960: PUSH
81961: LD_INT 2
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 1
81970: PUSH
81971: LD_INT 2
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 0
81980: PUSH
81981: LD_INT 2
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: LD_INT 1
81990: NEG
81991: PUSH
81992: LD_INT 1
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 2
82001: NEG
82002: PUSH
82003: LD_INT 0
82005: PUSH
82006: EMPTY
82007: LIST
82008: LIST
82009: PUSH
82010: LD_INT 2
82012: NEG
82013: PUSH
82014: LD_INT 1
82016: NEG
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 2
82024: NEG
82025: PUSH
82026: LD_INT 2
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82055: LD_ADDR_VAR 0 20
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: LD_INT 0
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 0
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: LD_INT 0
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 1
82124: NEG
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 1
82136: NEG
82137: PUSH
82138: LD_INT 2
82140: NEG
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 0
82148: PUSH
82149: LD_INT 2
82151: NEG
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 1
82159: PUSH
82160: LD_INT 1
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: PUSH
82171: LD_INT 0
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 2
82180: PUSH
82181: LD_INT 1
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: PUSH
82191: LD_INT 2
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 1
82200: PUSH
82201: LD_INT 2
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 0
82210: PUSH
82211: LD_INT 2
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 1
82220: NEG
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 2
82231: NEG
82232: PUSH
82233: LD_INT 0
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 2
82242: NEG
82243: PUSH
82244: LD_INT 1
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 2
82254: NEG
82255: PUSH
82256: LD_INT 2
82258: NEG
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82285: LD_ADDR_VAR 0 21
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: LD_INT 0
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: LD_INT 1
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: NEG
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 1
82354: NEG
82355: PUSH
82356: LD_INT 1
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 1
82366: NEG
82367: PUSH
82368: LD_INT 2
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: LD_INT 2
82381: NEG
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 1
82389: PUSH
82390: LD_INT 1
82392: NEG
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 2
82400: PUSH
82401: LD_INT 0
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 2
82410: PUSH
82411: LD_INT 1
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 2
82420: PUSH
82421: LD_INT 2
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 1
82430: PUSH
82431: LD_INT 2
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 0
82440: PUSH
82441: LD_INT 2
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 1
82450: NEG
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 2
82461: NEG
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 2
82484: NEG
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: LIST
82507: LIST
82508: LIST
82509: LIST
82510: LIST
82511: LIST
82512: LIST
82513: LIST
82514: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82515: LD_ADDR_VAR 0 22
82519: PUSH
82520: LD_INT 0
82522: PUSH
82523: LD_INT 0
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: LD_INT 1
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 1
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 0
82563: PUSH
82564: LD_INT 1
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: NEG
82574: PUSH
82575: LD_INT 0
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 1
82584: NEG
82585: PUSH
82586: LD_INT 1
82588: NEG
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: PUSH
82594: LD_INT 1
82596: NEG
82597: PUSH
82598: LD_INT 2
82600: NEG
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: LD_INT 2
82611: NEG
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 1
82619: PUSH
82620: LD_INT 1
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 2
82630: PUSH
82631: LD_INT 0
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 2
82640: PUSH
82641: LD_INT 1
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 2
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 1
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 0
82670: PUSH
82671: LD_INT 2
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 1
82680: NEG
82681: PUSH
82682: LD_INT 1
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 2
82691: NEG
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 2
82702: NEG
82703: PUSH
82704: LD_INT 1
82706: NEG
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 2
82714: NEG
82715: PUSH
82716: LD_INT 2
82718: NEG
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82745: LD_ADDR_VAR 0 23
82749: PUSH
82750: LD_INT 0
82752: PUSH
82753: LD_INT 0
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 0
82793: PUSH
82794: LD_INT 1
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 1
82803: NEG
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 1
82814: NEG
82815: PUSH
82816: LD_INT 1
82818: NEG
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: LD_INT 2
82830: NEG
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: LD_INT 2
82841: NEG
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: LD_INT 1
82852: NEG
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 2
82860: PUSH
82861: LD_INT 0
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 2
82870: PUSH
82871: LD_INT 1
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 2
82880: PUSH
82881: LD_INT 2
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 1
82890: PUSH
82891: LD_INT 2
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 0
82900: PUSH
82901: LD_INT 2
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: LD_INT 1
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 2
82921: NEG
82922: PUSH
82923: LD_INT 0
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 2
82932: NEG
82933: PUSH
82934: LD_INT 1
82936: NEG
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 2
82944: NEG
82945: PUSH
82946: LD_INT 2
82948: NEG
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 2
82956: NEG
82957: PUSH
82958: LD_INT 3
82960: NEG
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: LD_INT 3
82972: NEG
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: LD_INT 2
82983: NEG
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 2
82991: PUSH
82992: LD_INT 1
82994: NEG
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83025: LD_ADDR_VAR 0 24
83029: PUSH
83030: LD_INT 0
83032: PUSH
83033: LD_INT 0
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: LD_INT 1
83045: NEG
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 1
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: EMPTY
83068: LIST
83069: LIST
83070: PUSH
83071: LD_INT 0
83073: PUSH
83074: LD_INT 1
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: PUSH
83081: LD_INT 1
83083: NEG
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 1
83094: NEG
83095: PUSH
83096: LD_INT 1
83098: NEG
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 1
83106: NEG
83107: PUSH
83108: LD_INT 2
83110: NEG
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 0
83118: PUSH
83119: LD_INT 2
83121: NEG
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 1
83129: PUSH
83130: LD_INT 1
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 2
83140: PUSH
83141: LD_INT 0
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 2
83160: PUSH
83161: LD_INT 2
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: PUSH
83171: LD_INT 2
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: LD_INT 2
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: LD_INT 1
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 2
83201: NEG
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 2
83212: NEG
83213: PUSH
83214: LD_INT 1
83216: NEG
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 2
83224: NEG
83225: PUSH
83226: LD_INT 2
83228: NEG
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: LD_INT 2
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: LD_INT 1
83250: NEG
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 3
83258: PUSH
83259: LD_INT 1
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 3
83268: PUSH
83269: LD_INT 2
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83301: LD_ADDR_VAR 0 25
83305: PUSH
83306: LD_INT 0
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 1
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 1
83339: PUSH
83340: LD_INT 1
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: LD_INT 1
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 1
83370: NEG
83371: PUSH
83372: LD_INT 1
83374: NEG
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 1
83382: NEG
83383: PUSH
83384: LD_INT 2
83386: NEG
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 0
83394: PUSH
83395: LD_INT 2
83397: NEG
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 1
83405: PUSH
83406: LD_INT 1
83408: NEG
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 2
83426: PUSH
83427: LD_INT 1
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 2
83436: PUSH
83437: LD_INT 2
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: LD_INT 2
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 0
83456: PUSH
83457: LD_INT 2
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 1
83466: NEG
83467: PUSH
83468: LD_INT 1
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 2
83477: NEG
83478: PUSH
83479: LD_INT 0
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 2
83488: NEG
83489: PUSH
83490: LD_INT 1
83492: NEG
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 2
83500: NEG
83501: PUSH
83502: LD_INT 2
83504: NEG
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 3
83512: PUSH
83513: LD_INT 1
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: LD_INT 3
83522: PUSH
83523: LD_INT 2
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 2
83532: PUSH
83533: LD_INT 3
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 1
83542: PUSH
83543: LD_INT 3
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83575: LD_ADDR_VAR 0 26
83579: PUSH
83580: LD_INT 0
83582: PUSH
83583: LD_INT 0
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 0
83592: PUSH
83593: LD_INT 1
83595: NEG
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 1
83613: PUSH
83614: LD_INT 1
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 0
83623: PUSH
83624: LD_INT 1
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 1
83656: NEG
83657: PUSH
83658: LD_INT 2
83660: NEG
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 0
83668: PUSH
83669: LD_INT 2
83671: NEG
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 2
83690: PUSH
83691: LD_INT 0
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 2
83700: PUSH
83701: LD_INT 1
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 2
83710: PUSH
83711: LD_INT 2
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: LD_INT 1
83720: PUSH
83721: LD_INT 2
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 0
83730: PUSH
83731: LD_INT 2
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 1
83740: NEG
83741: PUSH
83742: LD_INT 1
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 2
83751: NEG
83752: PUSH
83753: LD_INT 0
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 2
83762: NEG
83763: PUSH
83764: LD_INT 1
83766: NEG
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 2
83774: NEG
83775: PUSH
83776: LD_INT 2
83778: NEG
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 2
83786: PUSH
83787: LD_INT 3
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 1
83796: PUSH
83797: LD_INT 3
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 1
83806: NEG
83807: PUSH
83808: LD_INT 2
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 2
83817: NEG
83818: PUSH
83819: LD_INT 1
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83851: LD_ADDR_VAR 0 27
83855: PUSH
83856: LD_INT 0
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 0
83899: PUSH
83900: LD_INT 1
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 1
83909: NEG
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 1
83920: NEG
83921: PUSH
83922: LD_INT 1
83924: NEG
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 1
83932: NEG
83933: PUSH
83934: LD_INT 2
83936: NEG
83937: PUSH
83938: EMPTY
83939: LIST
83940: LIST
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: LD_INT 2
83947: NEG
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 1
83955: PUSH
83956: LD_INT 1
83958: NEG
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 2
83966: PUSH
83967: LD_INT 0
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 2
83976: PUSH
83977: LD_INT 1
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 2
83986: PUSH
83987: LD_INT 2
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 1
83996: PUSH
83997: LD_INT 2
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 0
84006: PUSH
84007: LD_INT 2
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 1
84016: NEG
84017: PUSH
84018: LD_INT 1
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 2
84027: NEG
84028: PUSH
84029: LD_INT 0
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 2
84038: NEG
84039: PUSH
84040: LD_INT 1
84042: NEG
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 2
84050: NEG
84051: PUSH
84052: LD_INT 2
84054: NEG
84055: PUSH
84056: EMPTY
84057: LIST
84058: LIST
84059: PUSH
84060: LD_INT 1
84062: NEG
84063: PUSH
84064: LD_INT 2
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 2
84073: NEG
84074: PUSH
84075: LD_INT 1
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 3
84084: NEG
84085: PUSH
84086: LD_INT 1
84088: NEG
84089: PUSH
84090: EMPTY
84091: LIST
84092: LIST
84093: PUSH
84094: LD_INT 3
84096: NEG
84097: PUSH
84098: LD_INT 2
84100: NEG
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84131: LD_ADDR_VAR 0 28
84135: PUSH
84136: LD_INT 0
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 0
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: PUSH
84157: LD_INT 1
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: PUSH
84170: LD_INT 1
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: LD_INT 1
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: NEG
84201: PUSH
84202: LD_INT 1
84204: NEG
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: LD_INT 1
84212: NEG
84213: PUSH
84214: LD_INT 2
84216: NEG
84217: PUSH
84218: EMPTY
84219: LIST
84220: LIST
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: LD_INT 2
84227: NEG
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 1
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 2
84246: PUSH
84247: LD_INT 0
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 2
84256: PUSH
84257: LD_INT 1
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 2
84266: PUSH
84267: LD_INT 2
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 1
84276: PUSH
84277: LD_INT 2
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: PUSH
84284: LD_INT 0
84286: PUSH
84287: LD_INT 2
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: PUSH
84294: LD_INT 1
84296: NEG
84297: PUSH
84298: LD_INT 1
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 2
84307: NEG
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 2
84318: NEG
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 2
84330: NEG
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 2
84342: NEG
84343: PUSH
84344: LD_INT 3
84346: NEG
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: LD_INT 3
84358: NEG
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 3
84366: NEG
84367: PUSH
84368: LD_INT 1
84370: NEG
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 3
84378: NEG
84379: PUSH
84380: LD_INT 2
84382: NEG
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84413: LD_ADDR_VAR 0 29
84417: PUSH
84418: LD_INT 0
84420: PUSH
84421: LD_INT 0
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: LD_INT 1
84433: NEG
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 1
84451: PUSH
84452: LD_INT 1
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: LD_INT 1
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: LD_INT 0
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: LD_INT 1
84486: NEG
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 1
84494: NEG
84495: PUSH
84496: LD_INT 2
84498: NEG
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 0
84506: PUSH
84507: LD_INT 2
84509: NEG
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 1
84520: NEG
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 2
84528: PUSH
84529: LD_INT 0
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: PUSH
84536: LD_INT 2
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 2
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: LD_INT 2
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 1
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 2
84579: NEG
84580: PUSH
84581: LD_INT 1
84583: NEG
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 2
84591: NEG
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 2
84603: NEG
84604: PUSH
84605: LD_INT 3
84607: NEG
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 2
84615: PUSH
84616: LD_INT 1
84618: NEG
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 3
84626: PUSH
84627: LD_INT 1
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 1
84636: PUSH
84637: LD_INT 3
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 1
84646: NEG
84647: PUSH
84648: LD_INT 2
84650: PUSH
84651: EMPTY
84652: LIST
84653: LIST
84654: PUSH
84655: LD_INT 3
84657: NEG
84658: PUSH
84659: LD_INT 2
84661: NEG
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84692: LD_ADDR_VAR 0 30
84696: PUSH
84697: LD_INT 0
84699: PUSH
84700: LD_INT 0
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: LD_INT 1
84712: NEG
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: LD_INT 1
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: PUSH
84731: LD_INT 1
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: LD_INT 0
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 1
84750: NEG
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: EMPTY
84756: LIST
84757: LIST
84758: PUSH
84759: LD_INT 1
84761: NEG
84762: PUSH
84763: LD_INT 1
84765: NEG
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: LD_INT 2
84777: NEG
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 2
84788: NEG
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 1
84796: PUSH
84797: LD_INT 1
84799: NEG
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 2
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 2
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: PUSH
84828: LD_INT 2
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 1
84847: NEG
84848: PUSH
84849: LD_INT 1
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 2
84858: NEG
84859: PUSH
84860: LD_INT 0
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: LD_INT 1
84873: NEG
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 1
84881: NEG
84882: PUSH
84883: LD_INT 3
84885: NEG
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 1
84893: PUSH
84894: LD_INT 2
84896: NEG
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 3
84904: PUSH
84905: LD_INT 2
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 2
84914: PUSH
84915: LD_INT 3
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 2
84924: NEG
84925: PUSH
84926: LD_INT 1
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 3
84935: NEG
84936: PUSH
84937: LD_INT 1
84939: NEG
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84970: LD_ADDR_VAR 0 31
84974: PUSH
84975: LD_INT 0
84977: PUSH
84978: LD_INT 0
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: NEG
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 1
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: LD_INT 1
85011: PUSH
85012: EMPTY
85013: LIST
85014: LIST
85015: PUSH
85016: LD_INT 0
85018: PUSH
85019: LD_INT 1
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_INT 1
85028: NEG
85029: PUSH
85030: LD_INT 0
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: NEG
85040: PUSH
85041: LD_INT 1
85043: NEG
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 1
85051: NEG
85052: PUSH
85053: LD_INT 2
85055: NEG
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 1
85063: PUSH
85064: LD_INT 1
85066: NEG
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 2
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PUSH
85082: LD_INT 2
85084: PUSH
85085: LD_INT 1
85087: PUSH
85088: EMPTY
85089: LIST
85090: LIST
85091: PUSH
85092: LD_INT 2
85094: PUSH
85095: LD_INT 2
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 1
85104: PUSH
85105: LD_INT 2
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: LD_INT 2
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: LD_INT 1
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 2
85135: NEG
85136: PUSH
85137: LD_INT 1
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: LD_INT 2
85147: NEG
85148: PUSH
85149: LD_INT 2
85151: NEG
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 2
85159: NEG
85160: PUSH
85161: LD_INT 3
85163: NEG
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: LD_INT 1
85174: NEG
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 3
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: PUSH
85193: LD_INT 3
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 1
85202: NEG
85203: PUSH
85204: LD_INT 2
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 3
85213: NEG
85214: PUSH
85215: LD_INT 2
85217: NEG
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85248: LD_ADDR_VAR 0 32
85252: PUSH
85253: LD_INT 0
85255: PUSH
85256: LD_INT 0
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: LD_INT 1
85268: NEG
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: PUSH
85274: LD_INT 1
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: PUSH
85287: LD_INT 1
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 0
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 1
85306: NEG
85307: PUSH
85308: LD_INT 0
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: LD_INT 1
85321: NEG
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 1
85329: NEG
85330: PUSH
85331: LD_INT 2
85333: NEG
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 0
85341: PUSH
85342: LD_INT 2
85344: NEG
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 2
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 2
85373: PUSH
85374: LD_INT 2
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 1
85383: PUSH
85384: LD_INT 2
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: LD_INT 2
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 1
85403: NEG
85404: PUSH
85405: LD_INT 1
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 2
85414: NEG
85415: PUSH
85416: LD_INT 0
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: PUSH
85423: LD_INT 2
85425: NEG
85426: PUSH
85427: LD_INT 1
85429: NEG
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: LD_INT 3
85441: NEG
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 1
85449: PUSH
85450: LD_INT 2
85452: NEG
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 3
85460: PUSH
85461: LD_INT 2
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 2
85470: PUSH
85471: LD_INT 3
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: PUSH
85478: LD_INT 2
85480: NEG
85481: PUSH
85482: LD_INT 1
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PUSH
85489: LD_INT 3
85491: NEG
85492: PUSH
85493: LD_INT 1
85495: NEG
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85526: LD_ADDR_VAR 0 33
85530: PUSH
85531: LD_INT 0
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: LD_INT 1
85546: NEG
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 1
85554: PUSH
85555: LD_INT 0
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: PUSH
85565: LD_INT 1
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 0
85574: PUSH
85575: LD_INT 1
85577: PUSH
85578: EMPTY
85579: LIST
85580: LIST
85581: PUSH
85582: LD_INT 1
85584: NEG
85585: PUSH
85586: LD_INT 0
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: PUSH
85597: LD_INT 1
85599: NEG
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 1
85607: NEG
85608: PUSH
85609: LD_INT 2
85611: NEG
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 1
85622: NEG
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 2
85630: PUSH
85631: LD_INT 0
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 2
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 1
85650: PUSH
85651: LD_INT 2
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 0
85660: PUSH
85661: LD_INT 2
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: LD_INT 1
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 2
85681: NEG
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 2
85692: NEG
85693: PUSH
85694: LD_INT 1
85696: NEG
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: PUSH
85702: LD_INT 2
85704: NEG
85705: PUSH
85706: LD_INT 2
85708: NEG
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 2
85716: NEG
85717: PUSH
85718: LD_INT 3
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 2
85728: PUSH
85729: LD_INT 1
85731: NEG
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 3
85739: PUSH
85740: LD_INT 1
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: PUSH
85750: LD_INT 3
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 1
85759: NEG
85760: PUSH
85761: LD_INT 2
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 3
85770: NEG
85771: PUSH
85772: LD_INT 2
85774: NEG
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85805: LD_ADDR_VAR 0 34
85809: PUSH
85810: LD_INT 0
85812: PUSH
85813: LD_INT 0
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 0
85822: PUSH
85823: LD_INT 1
85825: NEG
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 1
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 1
85843: PUSH
85844: LD_INT 1
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PUSH
85851: LD_INT 0
85853: PUSH
85854: LD_INT 1
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: LD_INT 0
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: PUSH
85876: LD_INT 1
85878: NEG
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: LD_INT 2
85890: NEG
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 0
85898: PUSH
85899: LD_INT 2
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: LD_INT 1
85912: NEG
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 2
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 2
85930: PUSH
85931: LD_INT 2
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 1
85940: PUSH
85941: LD_INT 2
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: LD_INT 1
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 2
85961: NEG
85962: PUSH
85963: LD_INT 0
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 2
85984: NEG
85985: PUSH
85986: LD_INT 2
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 1
85996: NEG
85997: PUSH
85998: LD_INT 3
86000: NEG
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 1
86008: PUSH
86009: LD_INT 2
86011: NEG
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 3
86019: PUSH
86020: LD_INT 2
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 2
86029: PUSH
86030: LD_INT 3
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 2
86039: NEG
86040: PUSH
86041: LD_INT 1
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 3
86050: NEG
86051: PUSH
86052: LD_INT 1
86054: NEG
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86085: LD_ADDR_VAR 0 35
86089: PUSH
86090: LD_INT 0
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 1
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: PUSH
86124: LD_INT 1
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 1
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 1
86143: NEG
86144: PUSH
86145: LD_INT 0
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: NEG
86155: PUSH
86156: LD_INT 1
86158: NEG
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 2
86166: PUSH
86167: LD_INT 1
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 2
86176: NEG
86177: PUSH
86178: LD_INT 1
86180: NEG
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86197: LD_ADDR_VAR 0 36
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 1
86235: PUSH
86236: LD_INT 1
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: LD_INT 1
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: LD_INT 0
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: LD_INT 1
86270: NEG
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: NEG
86279: PUSH
86280: LD_INT 2
86282: NEG
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 1
86290: PUSH
86291: LD_INT 2
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86309: LD_ADDR_VAR 0 37
86313: PUSH
86314: LD_INT 0
86316: PUSH
86317: LD_INT 0
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: LD_INT 1
86329: NEG
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: LD_INT 1
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: LD_INT 1
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 1
86378: NEG
86379: PUSH
86380: LD_INT 1
86382: NEG
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 1
86390: PUSH
86391: LD_INT 1
86393: NEG
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 1
86401: NEG
86402: PUSH
86403: LD_INT 1
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86421: LD_ADDR_VAR 0 38
86425: PUSH
86426: LD_INT 0
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 0
86469: PUSH
86470: LD_INT 1
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: NEG
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: NEG
86491: PUSH
86492: LD_INT 1
86494: NEG
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 2
86502: PUSH
86503: LD_INT 1
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 2
86512: NEG
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: EMPTY
86519: LIST
86520: LIST
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86533: LD_ADDR_VAR 0 39
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: LD_INT 0
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: PUSH
86572: LD_INT 1
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: PUSH
86579: LD_INT 0
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: EMPTY
86586: LIST
86587: LIST
86588: PUSH
86589: LD_INT 1
86591: NEG
86592: PUSH
86593: LD_INT 0
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: NEG
86615: PUSH
86616: LD_INT 2
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: PUSH
86627: LD_INT 2
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86645: LD_ADDR_VAR 0 40
86649: PUSH
86650: LD_INT 0
86652: PUSH
86653: LD_INT 0
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: LD_INT 1
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 1
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 1
86683: PUSH
86684: LD_INT 1
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PUSH
86691: LD_INT 0
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 1
86703: NEG
86704: PUSH
86705: LD_INT 0
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: LD_INT 1
86718: NEG
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 1
86726: PUSH
86727: LD_INT 1
86729: NEG
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: PUSH
86739: LD_INT 1
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86757: LD_ADDR_VAR 0 41
86761: PUSH
86762: LD_INT 0
86764: PUSH
86765: LD_INT 0
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 0
86774: PUSH
86775: LD_INT 1
86777: NEG
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: PUSH
86796: LD_INT 1
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 0
86805: PUSH
86806: LD_INT 1
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 1
86815: NEG
86816: PUSH
86817: LD_INT 0
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 1
86826: NEG
86827: PUSH
86828: LD_INT 1
86830: NEG
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 1
86838: NEG
86839: PUSH
86840: LD_INT 2
86842: NEG
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: PUSH
86851: LD_INT 1
86853: NEG
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 2
86861: PUSH
86862: LD_INT 0
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 2
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 2
86881: PUSH
86882: LD_INT 2
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: PUSH
86889: LD_INT 1
86891: PUSH
86892: LD_INT 2
86894: PUSH
86895: EMPTY
86896: LIST
86897: LIST
86898: PUSH
86899: LD_INT 1
86901: NEG
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 2
86912: NEG
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 2
86923: NEG
86924: PUSH
86925: LD_INT 1
86927: NEG
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 2
86935: NEG
86936: PUSH
86937: LD_INT 2
86939: NEG
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 2
86947: NEG
86948: PUSH
86949: LD_INT 3
86951: NEG
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 2
86959: PUSH
86960: LD_INT 1
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 3
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: LD_INT 3
86980: PUSH
86981: LD_INT 1
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 3
86990: PUSH
86991: LD_INT 2
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 3
87000: PUSH
87001: LD_INT 3
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 2
87010: PUSH
87011: LD_INT 3
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: PUSH
87018: LD_INT 2
87020: NEG
87021: PUSH
87022: LD_INT 1
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 3
87031: NEG
87032: PUSH
87033: LD_INT 0
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 3
87042: NEG
87043: PUSH
87044: LD_INT 1
87046: NEG
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 3
87054: NEG
87055: PUSH
87056: LD_INT 2
87058: NEG
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 3
87066: NEG
87067: PUSH
87068: LD_INT 3
87070: NEG
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87107: LD_ADDR_VAR 0 42
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: LD_INT 0
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 1
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 1
87145: PUSH
87146: LD_INT 1
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: LD_INT 0
87155: PUSH
87156: LD_INT 1
87158: PUSH
87159: EMPTY
87160: LIST
87161: LIST
87162: PUSH
87163: LD_INT 1
87165: NEG
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 1
87176: NEG
87177: PUSH
87178: LD_INT 1
87180: NEG
87181: PUSH
87182: EMPTY
87183: LIST
87184: LIST
87185: PUSH
87186: LD_INT 1
87188: NEG
87189: PUSH
87190: LD_INT 2
87192: NEG
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 0
87200: PUSH
87201: LD_INT 2
87203: NEG
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 2
87222: PUSH
87223: LD_INT 1
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 2
87232: PUSH
87233: LD_INT 2
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 1
87242: PUSH
87243: LD_INT 2
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 0
87252: PUSH
87253: LD_INT 2
87255: PUSH
87256: EMPTY
87257: LIST
87258: LIST
87259: PUSH
87260: LD_INT 1
87262: NEG
87263: PUSH
87264: LD_INT 1
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 2
87273: NEG
87274: PUSH
87275: LD_INT 1
87277: NEG
87278: PUSH
87279: EMPTY
87280: LIST
87281: LIST
87282: PUSH
87283: LD_INT 2
87285: NEG
87286: PUSH
87287: LD_INT 2
87289: NEG
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PUSH
87295: LD_INT 2
87297: NEG
87298: PUSH
87299: LD_INT 3
87301: NEG
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 1
87309: NEG
87310: PUSH
87311: LD_INT 3
87313: NEG
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: LD_INT 3
87324: NEG
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: LD_INT 2
87335: NEG
87336: PUSH
87337: EMPTY
87338: LIST
87339: LIST
87340: PUSH
87341: LD_INT 3
87343: PUSH
87344: LD_INT 2
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: PUSH
87351: LD_INT 3
87353: PUSH
87354: LD_INT 3
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 2
87363: PUSH
87364: LD_INT 3
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 1
87373: PUSH
87374: LD_INT 3
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 0
87383: PUSH
87384: LD_INT 3
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 1
87393: NEG
87394: PUSH
87395: LD_INT 2
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 3
87404: NEG
87405: PUSH
87406: LD_INT 2
87408: NEG
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 3
87416: NEG
87417: PUSH
87418: LD_INT 3
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87457: LD_ADDR_VAR 0 43
87461: PUSH
87462: LD_INT 0
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 0
87474: PUSH
87475: LD_INT 1
87477: NEG
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 1
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: PUSH
87496: LD_INT 1
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 0
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 1
87515: NEG
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 1
87526: NEG
87527: PUSH
87528: LD_INT 1
87530: NEG
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: NEG
87539: PUSH
87540: LD_INT 2
87542: NEG
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 0
87550: PUSH
87551: LD_INT 2
87553: NEG
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: PUSH
87562: LD_INT 1
87564: NEG
87565: PUSH
87566: EMPTY
87567: LIST
87568: LIST
87569: PUSH
87570: LD_INT 2
87572: PUSH
87573: LD_INT 0
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 2
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: LD_INT 2
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: LD_INT 2
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: LD_INT 1
87612: NEG
87613: PUSH
87614: LD_INT 1
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 2
87623: NEG
87624: PUSH
87625: LD_INT 0
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 2
87634: NEG
87635: PUSH
87636: LD_INT 1
87638: NEG
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 1
87646: NEG
87647: PUSH
87648: LD_INT 3
87650: NEG
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 0
87658: PUSH
87659: LD_INT 3
87661: NEG
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 1
87669: PUSH
87670: LD_INT 2
87672: NEG
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 2
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 3
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 3
87701: PUSH
87702: LD_INT 1
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 1
87711: PUSH
87712: LD_INT 3
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: LD_INT 3
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 1
87731: NEG
87732: PUSH
87733: LD_INT 2
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 2
87742: NEG
87743: PUSH
87744: LD_INT 1
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 3
87753: NEG
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: LD_INT 3
87764: NEG
87765: PUSH
87766: LD_INT 1
87768: NEG
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87805: LD_ADDR_VAR 0 44
87809: PUSH
87810: LD_INT 0
87812: PUSH
87813: LD_INT 0
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 0
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 1
87833: PUSH
87834: LD_INT 0
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 1
87843: PUSH
87844: LD_INT 1
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 0
87853: PUSH
87854: LD_INT 1
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 1
87863: NEG
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 1
87874: NEG
87875: PUSH
87876: LD_INT 1
87878: NEG
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 1
87886: NEG
87887: PUSH
87888: LD_INT 2
87890: NEG
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 1
87898: PUSH
87899: LD_INT 1
87901: NEG
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 2
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 2
87919: PUSH
87920: LD_INT 1
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 2
87929: PUSH
87930: LD_INT 2
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 1
87939: PUSH
87940: LD_INT 2
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 1
87949: NEG
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 2
87960: NEG
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: NEG
87972: PUSH
87973: LD_INT 1
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 2
87983: NEG
87984: PUSH
87985: LD_INT 2
87987: NEG
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 2
87995: NEG
87996: PUSH
87997: LD_INT 3
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 2
88007: PUSH
88008: LD_INT 1
88010: NEG
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: PUSH
88016: LD_INT 3
88018: PUSH
88019: LD_INT 0
88021: PUSH
88022: EMPTY
88023: LIST
88024: LIST
88025: PUSH
88026: LD_INT 3
88028: PUSH
88029: LD_INT 1
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 3
88038: PUSH
88039: LD_INT 2
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 3
88048: PUSH
88049: LD_INT 3
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 2
88058: PUSH
88059: LD_INT 3
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 2
88068: NEG
88069: PUSH
88070: LD_INT 1
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 3
88079: NEG
88080: PUSH
88081: LD_INT 0
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: LD_INT 3
88090: NEG
88091: PUSH
88092: LD_INT 1
88094: NEG
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 3
88102: NEG
88103: PUSH
88104: LD_INT 2
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 3
88114: NEG
88115: PUSH
88116: LD_INT 3
88118: NEG
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88155: LD_ADDR_VAR 0 45
88159: PUSH
88160: LD_INT 0
88162: PUSH
88163: LD_INT 0
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: LD_INT 1
88175: NEG
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 1
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: PUSH
88194: LD_INT 1
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 0
88203: PUSH
88204: LD_INT 1
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 1
88213: NEG
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 1
88224: NEG
88225: PUSH
88226: LD_INT 1
88228: NEG
88229: PUSH
88230: EMPTY
88231: LIST
88232: LIST
88233: PUSH
88234: LD_INT 1
88236: NEG
88237: PUSH
88238: LD_INT 2
88240: NEG
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: LD_INT 2
88251: NEG
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: PUSH
88260: LD_INT 1
88262: NEG
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 2
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: LD_INT 2
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 1
88290: PUSH
88291: LD_INT 2
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: LD_INT 2
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 1
88310: NEG
88311: PUSH
88312: LD_INT 1
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: LD_INT 2
88321: NEG
88322: PUSH
88323: LD_INT 1
88325: NEG
88326: PUSH
88327: EMPTY
88328: LIST
88329: LIST
88330: PUSH
88331: LD_INT 2
88333: NEG
88334: PUSH
88335: LD_INT 2
88337: NEG
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 2
88345: NEG
88346: PUSH
88347: LD_INT 3
88349: NEG
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: LD_INT 1
88357: NEG
88358: PUSH
88359: LD_INT 3
88361: NEG
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 0
88369: PUSH
88370: LD_INT 3
88372: NEG
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 1
88380: PUSH
88381: LD_INT 2
88383: NEG
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 3
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 3
88401: PUSH
88402: LD_INT 3
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 2
88411: PUSH
88412: LD_INT 3
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 1
88421: PUSH
88422: LD_INT 3
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 0
88431: PUSH
88432: LD_INT 3
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 1
88441: NEG
88442: PUSH
88443: LD_INT 2
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: PUSH
88450: LD_INT 3
88452: NEG
88453: PUSH
88454: LD_INT 2
88456: NEG
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 3
88464: NEG
88465: PUSH
88466: LD_INT 3
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88505: LD_ADDR_VAR 0 46
88509: PUSH
88510: LD_INT 0
88512: PUSH
88513: LD_INT 0
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 1
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: PUSH
88544: LD_INT 1
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PUSH
88551: LD_INT 0
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 1
88563: NEG
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 1
88574: NEG
88575: PUSH
88576: LD_INT 1
88578: NEG
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 0
88598: PUSH
88599: LD_INT 2
88601: NEG
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: PUSH
88610: LD_INT 1
88612: NEG
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 2
88620: PUSH
88621: LD_INT 0
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 2
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: PUSH
88641: LD_INT 2
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 0
88650: PUSH
88651: LD_INT 2
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 1
88660: NEG
88661: PUSH
88662: LD_INT 1
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 2
88671: NEG
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 2
88682: NEG
88683: PUSH
88684: LD_INT 1
88686: NEG
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 1
88694: NEG
88695: PUSH
88696: LD_INT 3
88698: NEG
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: LD_INT 3
88709: NEG
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 1
88717: PUSH
88718: LD_INT 2
88720: NEG
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: LD_INT 2
88728: PUSH
88729: LD_INT 1
88731: NEG
88732: PUSH
88733: EMPTY
88734: LIST
88735: LIST
88736: PUSH
88737: LD_INT 3
88739: PUSH
88740: LD_INT 0
88742: PUSH
88743: EMPTY
88744: LIST
88745: LIST
88746: PUSH
88747: LD_INT 3
88749: PUSH
88750: LD_INT 1
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 1
88759: PUSH
88760: LD_INT 3
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 0
88769: PUSH
88770: LD_INT 3
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 1
88779: NEG
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 2
88790: NEG
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 3
88801: NEG
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: LD_INT 3
88812: NEG
88813: PUSH
88814: LD_INT 1
88816: NEG
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88853: LD_ADDR_VAR 0 47
88857: PUSH
88858: LD_INT 0
88860: PUSH
88861: LD_INT 0
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: LD_INT 1
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 1
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 1
88891: PUSH
88892: LD_INT 1
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 0
88901: PUSH
88902: LD_INT 1
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 1
88911: NEG
88912: PUSH
88913: LD_INT 0
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 1
88922: NEG
88923: PUSH
88924: LD_INT 1
88926: NEG
88927: PUSH
88928: EMPTY
88929: LIST
88930: LIST
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: LD_INT 2
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 0
88946: PUSH
88947: LD_INT 2
88949: NEG
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 1
88957: PUSH
88958: LD_INT 1
88960: NEG
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 2
88968: NEG
88969: PUSH
88970: LD_INT 1
88972: NEG
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: PUSH
88978: LD_INT 2
88980: NEG
88981: PUSH
88982: LD_INT 2
88984: NEG
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89004: LD_ADDR_VAR 0 48
89008: PUSH
89009: LD_INT 0
89011: PUSH
89012: LD_INT 0
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 1
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: LD_INT 1
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: LD_INT 1
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: NEG
89074: PUSH
89075: LD_INT 1
89077: NEG
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 1
89085: NEG
89086: PUSH
89087: LD_INT 2
89089: NEG
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 0
89097: PUSH
89098: LD_INT 2
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 1
89108: PUSH
89109: LD_INT 1
89111: NEG
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 2
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 2
89129: PUSH
89130: LD_INT 1
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89151: LD_ADDR_VAR 0 49
89155: PUSH
89156: LD_INT 0
89158: PUSH
89159: LD_INT 0
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 1
89171: NEG
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 1
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: PUSH
89190: LD_INT 1
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 0
89199: PUSH
89200: LD_INT 1
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 1
89209: NEG
89210: PUSH
89211: LD_INT 0
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 1
89220: NEG
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 1
89232: PUSH
89233: LD_INT 1
89235: NEG
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 2
89243: PUSH
89244: LD_INT 0
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 2
89253: PUSH
89254: LD_INT 1
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 2
89263: PUSH
89264: LD_INT 2
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: LD_INT 2
89276: PUSH
89277: EMPTY
89278: LIST
89279: LIST
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89295: LD_ADDR_VAR 0 50
89299: PUSH
89300: LD_INT 0
89302: PUSH
89303: LD_INT 0
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 0
89312: PUSH
89313: LD_INT 1
89315: NEG
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 1
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 1
89333: PUSH
89334: LD_INT 1
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 0
89343: PUSH
89344: LD_INT 1
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 1
89353: NEG
89354: PUSH
89355: LD_INT 0
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: PUSH
89362: LD_INT 1
89364: NEG
89365: PUSH
89366: LD_INT 1
89368: NEG
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: PUSH
89374: LD_INT 2
89376: PUSH
89377: LD_INT 1
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: LD_INT 2
89386: PUSH
89387: LD_INT 2
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 1
89396: PUSH
89397: LD_INT 2
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PUSH
89404: LD_INT 0
89406: PUSH
89407: LD_INT 2
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: PUSH
89414: LD_INT 1
89416: NEG
89417: PUSH
89418: LD_INT 1
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89439: LD_ADDR_VAR 0 51
89443: PUSH
89444: LD_INT 0
89446: PUSH
89447: LD_INT 0
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: NEG
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PUSH
89465: LD_INT 1
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 0
89487: PUSH
89488: LD_INT 1
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: PUSH
89495: LD_INT 1
89497: NEG
89498: PUSH
89499: LD_INT 0
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: LD_INT 1
89508: NEG
89509: PUSH
89510: LD_INT 1
89512: NEG
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 1
89520: PUSH
89521: LD_INT 2
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: LD_INT 0
89530: PUSH
89531: LD_INT 2
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: PUSH
89538: LD_INT 1
89540: NEG
89541: PUSH
89542: LD_INT 1
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: PUSH
89549: LD_INT 2
89551: NEG
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 2
89562: NEG
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89586: LD_ADDR_VAR 0 52
89590: PUSH
89591: LD_INT 0
89593: PUSH
89594: LD_INT 0
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 1
89606: NEG
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 1
89614: PUSH
89615: LD_INT 0
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: PUSH
89625: LD_INT 1
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: NEG
89645: PUSH
89646: LD_INT 0
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 1
89655: NEG
89656: PUSH
89657: LD_INT 1
89659: NEG
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: PUSH
89665: LD_INT 1
89667: NEG
89668: PUSH
89669: LD_INT 2
89671: NEG
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: PUSH
89681: LD_INT 1
89683: PUSH
89684: EMPTY
89685: LIST
89686: LIST
89687: PUSH
89688: LD_INT 2
89690: NEG
89691: PUSH
89692: LD_INT 0
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 2
89701: NEG
89702: PUSH
89703: LD_INT 1
89705: NEG
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 2
89713: NEG
89714: PUSH
89715: LD_INT 2
89717: NEG
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89737: LD_ADDR_VAR 0 53
89741: PUSH
89742: LD_INT 0
89744: PUSH
89745: LD_INT 0
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_INT 1
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 1
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 1
89775: PUSH
89776: LD_INT 1
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: LD_INT 1
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 1
89795: NEG
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 1
89806: NEG
89807: PUSH
89808: LD_INT 1
89810: NEG
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 1
89818: NEG
89819: PUSH
89820: LD_INT 2
89822: NEG
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: PUSH
89828: LD_INT 0
89830: PUSH
89831: LD_INT 2
89833: NEG
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: PUSH
89839: LD_INT 1
89841: PUSH
89842: LD_INT 1
89844: NEG
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: PUSH
89850: LD_INT 2
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: PUSH
89860: LD_INT 2
89862: PUSH
89863: LD_INT 1
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 2
89872: PUSH
89873: LD_INT 2
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 1
89882: PUSH
89883: LD_INT 2
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 0
89892: PUSH
89893: LD_INT 2
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: LD_INT 1
89902: NEG
89903: PUSH
89904: LD_INT 1
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 2
89913: NEG
89914: PUSH
89915: LD_INT 0
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 2
89924: NEG
89925: PUSH
89926: LD_INT 1
89928: NEG
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 2
89936: NEG
89937: PUSH
89938: LD_INT 2
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89967: LD_ADDR_VAR 0 54
89971: PUSH
89972: LD_INT 0
89974: PUSH
89975: LD_INT 0
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: LD_INT 1
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 1
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: PUSH
90006: LD_INT 1
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 0
90015: PUSH
90016: LD_INT 1
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: LD_INT 1
90040: NEG
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 1
90048: NEG
90049: PUSH
90050: LD_INT 2
90052: NEG
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 0
90060: PUSH
90061: LD_INT 2
90063: NEG
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 1
90071: PUSH
90072: LD_INT 1
90074: NEG
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 2
90082: PUSH
90083: LD_INT 0
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: LD_INT 2
90092: PUSH
90093: LD_INT 1
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: LD_INT 2
90102: PUSH
90103: LD_INT 2
90105: PUSH
90106: EMPTY
90107: LIST
90108: LIST
90109: PUSH
90110: LD_INT 1
90112: PUSH
90113: LD_INT 2
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 0
90122: PUSH
90123: LD_INT 2
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 1
90132: NEG
90133: PUSH
90134: LD_INT 1
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 2
90143: NEG
90144: PUSH
90145: LD_INT 0
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 2
90154: NEG
90155: PUSH
90156: LD_INT 1
90158: NEG
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 2
90166: NEG
90167: PUSH
90168: LD_INT 2
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90197: LD_ADDR_VAR 0 55
90201: PUSH
90202: LD_INT 0
90204: PUSH
90205: LD_INT 0
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 1
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 1
90235: PUSH
90236: LD_INT 1
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 0
90245: PUSH
90246: LD_INT 1
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 1
90255: NEG
90256: PUSH
90257: LD_INT 0
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 1
90266: NEG
90267: PUSH
90268: LD_INT 1
90270: NEG
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: LD_INT 1
90278: NEG
90279: PUSH
90280: LD_INT 2
90282: NEG
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: PUSH
90288: LD_INT 0
90290: PUSH
90291: LD_INT 2
90293: NEG
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: LD_INT 1
90301: PUSH
90302: LD_INT 1
90304: NEG
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 2
90312: PUSH
90313: LD_INT 0
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 2
90322: PUSH
90323: LD_INT 1
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 2
90332: PUSH
90333: LD_INT 2
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: LD_INT 2
90345: PUSH
90346: EMPTY
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 0
90352: PUSH
90353: LD_INT 2
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: PUSH
90360: LD_INT 1
90362: NEG
90363: PUSH
90364: LD_INT 1
90366: PUSH
90367: EMPTY
90368: LIST
90369: LIST
90370: PUSH
90371: LD_INT 2
90373: NEG
90374: PUSH
90375: LD_INT 0
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 2
90384: NEG
90385: PUSH
90386: LD_INT 1
90388: NEG
90389: PUSH
90390: EMPTY
90391: LIST
90392: LIST
90393: PUSH
90394: LD_INT 2
90396: NEG
90397: PUSH
90398: LD_INT 2
90400: NEG
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90427: LD_ADDR_VAR 0 56
90431: PUSH
90432: LD_INT 0
90434: PUSH
90435: LD_INT 0
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 1
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 0
90475: PUSH
90476: LD_INT 1
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: NEG
90486: PUSH
90487: LD_INT 0
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: PUSH
90494: LD_INT 1
90496: NEG
90497: PUSH
90498: LD_INT 1
90500: NEG
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 1
90508: NEG
90509: PUSH
90510: LD_INT 2
90512: NEG
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: LD_INT 2
90523: NEG
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 1
90531: PUSH
90532: LD_INT 1
90534: NEG
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 2
90542: PUSH
90543: LD_INT 0
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: LD_INT 2
90552: PUSH
90553: LD_INT 1
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 2
90562: PUSH
90563: LD_INT 2
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 1
90572: PUSH
90573: LD_INT 2
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 0
90582: PUSH
90583: LD_INT 2
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 1
90592: NEG
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 2
90603: NEG
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 2
90614: NEG
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 2
90626: NEG
90627: PUSH
90628: LD_INT 2
90630: NEG
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90657: LD_ADDR_VAR 0 57
90661: PUSH
90662: LD_INT 0
90664: PUSH
90665: LD_INT 0
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 1
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 1
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 0
90705: PUSH
90706: LD_INT 1
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 1
90715: NEG
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 1
90726: NEG
90727: PUSH
90728: LD_INT 1
90730: NEG
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: NEG
90739: PUSH
90740: LD_INT 2
90742: NEG
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: LD_INT 2
90753: NEG
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 1
90761: PUSH
90762: LD_INT 1
90764: NEG
90765: PUSH
90766: EMPTY
90767: LIST
90768: LIST
90769: PUSH
90770: LD_INT 2
90772: PUSH
90773: LD_INT 0
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 2
90782: PUSH
90783: LD_INT 1
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: LD_INT 2
90792: PUSH
90793: LD_INT 2
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 1
90802: PUSH
90803: LD_INT 2
90805: PUSH
90806: EMPTY
90807: LIST
90808: LIST
90809: PUSH
90810: LD_INT 0
90812: PUSH
90813: LD_INT 2
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 1
90822: NEG
90823: PUSH
90824: LD_INT 1
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PUSH
90831: LD_INT 2
90833: NEG
90834: PUSH
90835: LD_INT 0
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 2
90844: NEG
90845: PUSH
90846: LD_INT 1
90848: NEG
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 2
90856: NEG
90857: PUSH
90858: LD_INT 2
90860: NEG
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90887: LD_ADDR_VAR 0 58
90891: PUSH
90892: LD_INT 0
90894: PUSH
90895: LD_INT 0
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 0
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 1
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 1
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 0
90935: PUSH
90936: LD_INT 1
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 1
90945: NEG
90946: PUSH
90947: LD_INT 0
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: PUSH
90954: LD_INT 1
90956: NEG
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: NEG
90969: PUSH
90970: LD_INT 2
90972: NEG
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: LD_INT 2
90983: NEG
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 1
90991: PUSH
90992: LD_INT 1
90994: NEG
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: LD_INT 2
91002: PUSH
91003: LD_INT 0
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 2
91012: PUSH
91013: LD_INT 1
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 2
91022: PUSH
91023: LD_INT 2
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 1
91032: PUSH
91033: LD_INT 2
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: LD_INT 2
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: PUSH
91054: LD_INT 1
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 2
91063: NEG
91064: PUSH
91065: LD_INT 0
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 2
91074: NEG
91075: PUSH
91076: LD_INT 1
91078: NEG
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: PUSH
91084: LD_INT 2
91086: NEG
91087: PUSH
91088: LD_INT 2
91090: NEG
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: LIST
91116: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91117: LD_ADDR_VAR 0 59
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: LD_INT 0
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 0
91134: PUSH
91135: LD_INT 1
91137: NEG
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 1
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 0
91165: PUSH
91166: LD_INT 1
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 1
91175: NEG
91176: PUSH
91177: LD_INT 0
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: PUSH
91184: LD_INT 1
91186: NEG
91187: PUSH
91188: LD_INT 1
91190: NEG
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91205: LD_ADDR_VAR 0 60
91209: PUSH
91210: LD_INT 0
91212: PUSH
91213: LD_INT 0
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 0
91222: PUSH
91223: LD_INT 1
91225: NEG
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 1
91233: PUSH
91234: LD_INT 0
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: LD_INT 1
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 0
91253: PUSH
91254: LD_INT 1
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: PUSH
91261: LD_INT 1
91263: NEG
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 1
91274: NEG
91275: PUSH
91276: LD_INT 1
91278: NEG
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91293: LD_ADDR_VAR 0 61
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: LD_INT 0
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: LD_INT 1
91313: NEG
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 1
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: PUSH
91332: LD_INT 1
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 0
91341: PUSH
91342: LD_INT 1
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: NEG
91352: PUSH
91353: LD_INT 0
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: LD_INT 1
91366: NEG
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91381: LD_ADDR_VAR 0 62
91385: PUSH
91386: LD_INT 0
91388: PUSH
91389: LD_INT 0
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 0
91398: PUSH
91399: LD_INT 1
91401: NEG
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 1
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: LD_INT 1
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 0
91429: PUSH
91430: LD_INT 1
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 1
91439: NEG
91440: PUSH
91441: LD_INT 0
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 1
91450: NEG
91451: PUSH
91452: LD_INT 1
91454: NEG
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91469: LD_ADDR_VAR 0 63
91473: PUSH
91474: LD_INT 0
91476: PUSH
91477: LD_INT 0
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: LD_INT 1
91489: NEG
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 1
91507: PUSH
91508: LD_INT 1
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: PUSH
91515: LD_INT 0
91517: PUSH
91518: LD_INT 1
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 1
91527: NEG
91528: PUSH
91529: LD_INT 0
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: LD_INT 1
91542: NEG
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91557: LD_ADDR_VAR 0 64
91561: PUSH
91562: LD_INT 0
91564: PUSH
91565: LD_INT 0
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: LD_INT 1
91577: NEG
91578: PUSH
91579: EMPTY
91580: LIST
91581: LIST
91582: PUSH
91583: LD_INT 1
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: PUSH
91596: LD_INT 1
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 0
91605: PUSH
91606: LD_INT 1
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 1
91615: NEG
91616: PUSH
91617: LD_INT 0
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 1
91626: NEG
91627: PUSH
91628: LD_INT 1
91630: NEG
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: ST_TO_ADDR
// end ; 1 :
91645: GO 97542
91647: LD_INT 1
91649: DOUBLE
91650: EQUAL
91651: IFTRUE 91655
91653: GO 94278
91655: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91656: LD_ADDR_VAR 0 11
91660: PUSH
91661: LD_INT 1
91663: NEG
91664: PUSH
91665: LD_INT 3
91667: NEG
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 0
91675: PUSH
91676: LD_INT 3
91678: NEG
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 1
91686: PUSH
91687: LD_INT 2
91689: NEG
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: LIST
91699: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91700: LD_ADDR_VAR 0 12
91704: PUSH
91705: LD_INT 2
91707: PUSH
91708: LD_INT 1
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 3
91718: PUSH
91719: LD_INT 0
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: PUSH
91726: LD_INT 3
91728: PUSH
91729: LD_INT 1
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: LIST
91740: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91741: LD_ADDR_VAR 0 13
91745: PUSH
91746: LD_INT 3
91748: PUSH
91749: LD_INT 2
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: LD_INT 3
91758: PUSH
91759: LD_INT 3
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 2
91768: PUSH
91769: LD_INT 3
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: LIST
91780: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91781: LD_ADDR_VAR 0 14
91785: PUSH
91786: LD_INT 1
91788: PUSH
91789: LD_INT 3
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 0
91798: PUSH
91799: LD_INT 3
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 1
91808: NEG
91809: PUSH
91810: LD_INT 2
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: LIST
91821: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91822: LD_ADDR_VAR 0 15
91826: PUSH
91827: LD_INT 2
91829: NEG
91830: PUSH
91831: LD_INT 1
91833: PUSH
91834: EMPTY
91835: LIST
91836: LIST
91837: PUSH
91838: LD_INT 3
91840: NEG
91841: PUSH
91842: LD_INT 0
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: PUSH
91849: LD_INT 3
91851: NEG
91852: PUSH
91853: LD_INT 1
91855: NEG
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: LIST
91865: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91866: LD_ADDR_VAR 0 16
91870: PUSH
91871: LD_INT 2
91873: NEG
91874: PUSH
91875: LD_INT 3
91877: NEG
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 3
91885: NEG
91886: PUSH
91887: LD_INT 2
91889: NEG
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: PUSH
91895: LD_INT 3
91897: NEG
91898: PUSH
91899: LD_INT 3
91901: NEG
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: LIST
91911: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91912: LD_ADDR_VAR 0 17
91916: PUSH
91917: LD_INT 1
91919: NEG
91920: PUSH
91921: LD_INT 3
91923: NEG
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 0
91931: PUSH
91932: LD_INT 3
91934: NEG
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 1
91942: PUSH
91943: LD_INT 2
91945: NEG
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: LIST
91955: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91956: LD_ADDR_VAR 0 18
91960: PUSH
91961: LD_INT 2
91963: PUSH
91964: LD_INT 1
91966: NEG
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 3
91974: PUSH
91975: LD_INT 0
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 3
91984: PUSH
91985: LD_INT 1
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: LIST
91996: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91997: LD_ADDR_VAR 0 19
92001: PUSH
92002: LD_INT 3
92004: PUSH
92005: LD_INT 2
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 3
92014: PUSH
92015: LD_INT 3
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 2
92024: PUSH
92025: LD_INT 3
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: LIST
92036: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92037: LD_ADDR_VAR 0 20
92041: PUSH
92042: LD_INT 1
92044: PUSH
92045: LD_INT 3
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 0
92054: PUSH
92055: LD_INT 3
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 1
92064: NEG
92065: PUSH
92066: LD_INT 2
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: LIST
92077: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92078: LD_ADDR_VAR 0 21
92082: PUSH
92083: LD_INT 2
92085: NEG
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 3
92096: NEG
92097: PUSH
92098: LD_INT 0
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 3
92107: NEG
92108: PUSH
92109: LD_INT 1
92111: NEG
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: LIST
92121: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92122: LD_ADDR_VAR 0 22
92126: PUSH
92127: LD_INT 2
92129: NEG
92130: PUSH
92131: LD_INT 3
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 3
92141: NEG
92142: PUSH
92143: LD_INT 2
92145: NEG
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 3
92153: NEG
92154: PUSH
92155: LD_INT 3
92157: NEG
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: LIST
92167: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92168: LD_ADDR_VAR 0 23
92172: PUSH
92173: LD_INT 0
92175: PUSH
92176: LD_INT 3
92178: NEG
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: PUSH
92184: LD_INT 1
92186: NEG
92187: PUSH
92188: LD_INT 4
92190: NEG
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 1
92198: PUSH
92199: LD_INT 3
92201: NEG
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: LIST
92211: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92212: LD_ADDR_VAR 0 24
92216: PUSH
92217: LD_INT 3
92219: PUSH
92220: LD_INT 0
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 3
92229: PUSH
92230: LD_INT 1
92232: NEG
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: PUSH
92238: LD_INT 4
92240: PUSH
92241: LD_INT 1
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: LIST
92252: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92253: LD_ADDR_VAR 0 25
92257: PUSH
92258: LD_INT 3
92260: PUSH
92261: LD_INT 3
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: LD_INT 4
92270: PUSH
92271: LD_INT 3
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 3
92280: PUSH
92281: LD_INT 4
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: LIST
92292: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92293: LD_ADDR_VAR 0 26
92297: PUSH
92298: LD_INT 0
92300: PUSH
92301: LD_INT 3
92303: PUSH
92304: EMPTY
92305: LIST
92306: LIST
92307: PUSH
92308: LD_INT 1
92310: PUSH
92311: LD_INT 4
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 1
92320: NEG
92321: PUSH
92322: LD_INT 3
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: LIST
92333: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92334: LD_ADDR_VAR 0 27
92338: PUSH
92339: LD_INT 3
92341: NEG
92342: PUSH
92343: LD_INT 0
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 3
92352: NEG
92353: PUSH
92354: LD_INT 1
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 4
92363: NEG
92364: PUSH
92365: LD_INT 1
92367: NEG
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: LIST
92377: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92378: LD_ADDR_VAR 0 28
92382: PUSH
92383: LD_INT 3
92385: NEG
92386: PUSH
92387: LD_INT 3
92389: NEG
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 3
92397: NEG
92398: PUSH
92399: LD_INT 4
92401: NEG
92402: PUSH
92403: EMPTY
92404: LIST
92405: LIST
92406: PUSH
92407: LD_INT 4
92409: NEG
92410: PUSH
92411: LD_INT 3
92413: NEG
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: EMPTY
92420: LIST
92421: LIST
92422: LIST
92423: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92424: LD_ADDR_VAR 0 29
92428: PUSH
92429: LD_INT 1
92431: NEG
92432: PUSH
92433: LD_INT 3
92435: NEG
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 0
92443: PUSH
92444: LD_INT 3
92446: NEG
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 1
92454: PUSH
92455: LD_INT 2
92457: NEG
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 1
92465: NEG
92466: PUSH
92467: LD_INT 4
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 0
92477: PUSH
92478: LD_INT 4
92480: NEG
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 1
92488: PUSH
92489: LD_INT 3
92491: NEG
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: PUSH
92497: LD_INT 1
92499: NEG
92500: PUSH
92501: LD_INT 5
92503: NEG
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 0
92511: PUSH
92512: LD_INT 5
92514: NEG
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 1
92522: PUSH
92523: LD_INT 4
92525: NEG
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 1
92533: NEG
92534: PUSH
92535: LD_INT 6
92537: NEG
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 0
92545: PUSH
92546: LD_INT 6
92548: NEG
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: LD_INT 1
92556: PUSH
92557: LD_INT 5
92559: NEG
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: EMPTY
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92579: LD_ADDR_VAR 0 30
92583: PUSH
92584: LD_INT 2
92586: PUSH
92587: LD_INT 1
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 3
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 4
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 4
92638: PUSH
92639: LD_INT 1
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 4
92648: PUSH
92649: LD_INT 1
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 5
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 5
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 5
92679: PUSH
92680: LD_INT 1
92682: NEG
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 6
92690: PUSH
92691: LD_INT 0
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 6
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92722: LD_ADDR_VAR 0 31
92726: PUSH
92727: LD_INT 3
92729: PUSH
92730: LD_INT 2
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 3
92739: PUSH
92740: LD_INT 3
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: PUSH
92747: LD_INT 2
92749: PUSH
92750: LD_INT 3
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 4
92759: PUSH
92760: LD_INT 3
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: PUSH
92767: LD_INT 4
92769: PUSH
92770: LD_INT 4
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 3
92779: PUSH
92780: LD_INT 4
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 5
92789: PUSH
92790: LD_INT 4
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 5
92799: PUSH
92800: LD_INT 5
92802: PUSH
92803: EMPTY
92804: LIST
92805: LIST
92806: PUSH
92807: LD_INT 4
92809: PUSH
92810: LD_INT 5
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 6
92819: PUSH
92820: LD_INT 5
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 6
92829: PUSH
92830: LD_INT 6
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 5
92839: PUSH
92840: LD_INT 6
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92861: LD_ADDR_VAR 0 32
92865: PUSH
92866: LD_INT 1
92868: PUSH
92869: LD_INT 3
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: LD_INT 3
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 1
92888: NEG
92889: PUSH
92890: LD_INT 2
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 1
92899: PUSH
92900: LD_INT 4
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: LD_INT 4
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: LD_INT 3
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 1
92930: PUSH
92931: LD_INT 5
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 5
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: LD_INT 4
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 1
92961: PUSH
92962: LD_INT 6
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 0
92971: PUSH
92972: LD_INT 6
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 1
92981: NEG
92982: PUSH
92983: LD_INT 5
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93004: LD_ADDR_VAR 0 33
93008: PUSH
93009: LD_INT 2
93011: NEG
93012: PUSH
93013: LD_INT 1
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 3
93022: NEG
93023: PUSH
93024: LD_INT 0
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 3
93033: NEG
93034: PUSH
93035: LD_INT 1
93037: NEG
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 3
93045: NEG
93046: PUSH
93047: LD_INT 1
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 4
93056: NEG
93057: PUSH
93058: LD_INT 0
93060: PUSH
93061: EMPTY
93062: LIST
93063: LIST
93064: PUSH
93065: LD_INT 4
93067: NEG
93068: PUSH
93069: LD_INT 1
93071: NEG
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 4
93079: NEG
93080: PUSH
93081: LD_INT 1
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 5
93090: NEG
93091: PUSH
93092: LD_INT 0
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 5
93101: NEG
93102: PUSH
93103: LD_INT 1
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 5
93113: NEG
93114: PUSH
93115: LD_INT 1
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 6
93124: NEG
93125: PUSH
93126: LD_INT 0
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PUSH
93133: LD_INT 6
93135: NEG
93136: PUSH
93137: LD_INT 1
93139: NEG
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93159: LD_ADDR_VAR 0 34
93163: PUSH
93164: LD_INT 2
93166: NEG
93167: PUSH
93168: LD_INT 3
93170: NEG
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 3
93178: NEG
93179: PUSH
93180: LD_INT 2
93182: NEG
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 3
93190: NEG
93191: PUSH
93192: LD_INT 3
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 3
93202: NEG
93203: PUSH
93204: LD_INT 4
93206: NEG
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 4
93214: NEG
93215: PUSH
93216: LD_INT 3
93218: NEG
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 4
93226: NEG
93227: PUSH
93228: LD_INT 4
93230: NEG
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 4
93238: NEG
93239: PUSH
93240: LD_INT 5
93242: NEG
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 5
93250: NEG
93251: PUSH
93252: LD_INT 4
93254: NEG
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 5
93262: NEG
93263: PUSH
93264: LD_INT 5
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 5
93274: NEG
93275: PUSH
93276: LD_INT 6
93278: NEG
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 6
93286: NEG
93287: PUSH
93288: LD_INT 5
93290: NEG
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: LD_INT 6
93298: NEG
93299: PUSH
93300: LD_INT 6
93302: NEG
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93322: LD_ADDR_VAR 0 41
93326: PUSH
93327: LD_INT 0
93329: PUSH
93330: LD_INT 2
93332: NEG
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 1
93340: NEG
93341: PUSH
93342: LD_INT 3
93344: NEG
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 1
93352: PUSH
93353: LD_INT 2
93355: NEG
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: LIST
93365: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93366: LD_ADDR_VAR 0 42
93370: PUSH
93371: LD_INT 2
93373: PUSH
93374: LD_INT 0
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 2
93383: PUSH
93384: LD_INT 1
93386: NEG
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 3
93394: PUSH
93395: LD_INT 1
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: LIST
93406: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93407: LD_ADDR_VAR 0 43
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: LD_INT 2
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 3
93424: PUSH
93425: LD_INT 2
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 2
93434: PUSH
93435: LD_INT 3
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: LIST
93446: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93447: LD_ADDR_VAR 0 44
93451: PUSH
93452: LD_INT 0
93454: PUSH
93455: LD_INT 2
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 1
93464: PUSH
93465: LD_INT 3
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 1
93474: NEG
93475: PUSH
93476: LD_INT 2
93478: PUSH
93479: EMPTY
93480: LIST
93481: LIST
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: LIST
93487: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93488: LD_ADDR_VAR 0 45
93492: PUSH
93493: LD_INT 2
93495: NEG
93496: PUSH
93497: LD_INT 0
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 2
93506: NEG
93507: PUSH
93508: LD_INT 1
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: PUSH
93515: LD_INT 3
93517: NEG
93518: PUSH
93519: LD_INT 1
93521: NEG
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: LIST
93531: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93532: LD_ADDR_VAR 0 46
93536: PUSH
93537: LD_INT 2
93539: NEG
93540: PUSH
93541: LD_INT 2
93543: NEG
93544: PUSH
93545: EMPTY
93546: LIST
93547: LIST
93548: PUSH
93549: LD_INT 2
93551: NEG
93552: PUSH
93553: LD_INT 3
93555: NEG
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 3
93563: NEG
93564: PUSH
93565: LD_INT 2
93567: NEG
93568: PUSH
93569: EMPTY
93570: LIST
93571: LIST
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: LIST
93577: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93578: LD_ADDR_VAR 0 47
93582: PUSH
93583: LD_INT 2
93585: NEG
93586: PUSH
93587: LD_INT 3
93589: NEG
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 1
93597: NEG
93598: PUSH
93599: LD_INT 3
93601: NEG
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93611: LD_ADDR_VAR 0 48
93615: PUSH
93616: LD_INT 1
93618: PUSH
93619: LD_INT 2
93621: NEG
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 2
93629: PUSH
93630: LD_INT 1
93632: NEG
93633: PUSH
93634: EMPTY
93635: LIST
93636: LIST
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93642: LD_ADDR_VAR 0 49
93646: PUSH
93647: LD_INT 3
93649: PUSH
93650: LD_INT 1
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 3
93659: PUSH
93660: LD_INT 2
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93671: LD_ADDR_VAR 0 50
93675: PUSH
93676: LD_INT 2
93678: PUSH
93679: LD_INT 3
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 1
93688: PUSH
93689: LD_INT 3
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93700: LD_ADDR_VAR 0 51
93704: PUSH
93705: LD_INT 1
93707: NEG
93708: PUSH
93709: LD_INT 2
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: LD_INT 2
93718: NEG
93719: PUSH
93720: LD_INT 1
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93731: LD_ADDR_VAR 0 52
93735: PUSH
93736: LD_INT 3
93738: NEG
93739: PUSH
93740: LD_INT 1
93742: NEG
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: PUSH
93748: LD_INT 3
93750: NEG
93751: PUSH
93752: LD_INT 2
93754: NEG
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93764: LD_ADDR_VAR 0 53
93768: PUSH
93769: LD_INT 1
93771: NEG
93772: PUSH
93773: LD_INT 3
93775: NEG
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 0
93783: PUSH
93784: LD_INT 3
93786: NEG
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 1
93794: PUSH
93795: LD_INT 2
93797: NEG
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: LIST
93807: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93808: LD_ADDR_VAR 0 54
93812: PUSH
93813: LD_INT 2
93815: PUSH
93816: LD_INT 1
93818: NEG
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 3
93826: PUSH
93827: LD_INT 0
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: LD_INT 3
93836: PUSH
93837: LD_INT 1
93839: PUSH
93840: EMPTY
93841: LIST
93842: LIST
93843: PUSH
93844: EMPTY
93845: LIST
93846: LIST
93847: LIST
93848: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93849: LD_ADDR_VAR 0 55
93853: PUSH
93854: LD_INT 3
93856: PUSH
93857: LD_INT 2
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: PUSH
93864: LD_INT 3
93866: PUSH
93867: LD_INT 3
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: PUSH
93874: LD_INT 2
93876: PUSH
93877: LD_INT 3
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: LIST
93888: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93889: LD_ADDR_VAR 0 56
93893: PUSH
93894: LD_INT 1
93896: PUSH
93897: LD_INT 3
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: LD_INT 3
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 1
93916: NEG
93917: PUSH
93918: LD_INT 2
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: LIST
93929: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93930: LD_ADDR_VAR 0 57
93934: PUSH
93935: LD_INT 2
93937: NEG
93938: PUSH
93939: LD_INT 1
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 3
93948: NEG
93949: PUSH
93950: LD_INT 0
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 3
93959: NEG
93960: PUSH
93961: LD_INT 1
93963: NEG
93964: PUSH
93965: EMPTY
93966: LIST
93967: LIST
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: LIST
93973: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93974: LD_ADDR_VAR 0 58
93978: PUSH
93979: LD_INT 2
93981: NEG
93982: PUSH
93983: LD_INT 3
93985: NEG
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: PUSH
93991: LD_INT 3
93993: NEG
93994: PUSH
93995: LD_INT 2
93997: NEG
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 3
94005: NEG
94006: PUSH
94007: LD_INT 3
94009: NEG
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: LIST
94019: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94020: LD_ADDR_VAR 0 59
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: LD_INT 2
94031: NEG
94032: PUSH
94033: EMPTY
94034: LIST
94035: LIST
94036: PUSH
94037: LD_INT 0
94039: PUSH
94040: LD_INT 2
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 1
94050: PUSH
94051: LD_INT 1
94053: NEG
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: LIST
94063: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94064: LD_ADDR_VAR 0 60
94068: PUSH
94069: LD_INT 1
94071: PUSH
94072: LD_INT 1
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 2
94082: PUSH
94083: LD_INT 0
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: PUSH
94090: LD_INT 2
94092: PUSH
94093: LD_INT 1
94095: PUSH
94096: EMPTY
94097: LIST
94098: LIST
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: LIST
94104: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94105: LD_ADDR_VAR 0 61
94109: PUSH
94110: LD_INT 2
94112: PUSH
94113: LD_INT 1
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: LD_INT 2
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: PUSH
94130: LD_INT 1
94132: PUSH
94133: LD_INT 2
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: LIST
94144: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94145: LD_ADDR_VAR 0 62
94149: PUSH
94150: LD_INT 1
94152: PUSH
94153: LD_INT 2
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 0
94162: PUSH
94163: LD_INT 2
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: PUSH
94170: LD_INT 1
94172: NEG
94173: PUSH
94174: LD_INT 1
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: LIST
94185: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94186: LD_ADDR_VAR 0 63
94190: PUSH
94191: LD_INT 1
94193: NEG
94194: PUSH
94195: LD_INT 1
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 2
94204: NEG
94205: PUSH
94206: LD_INT 0
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 2
94215: NEG
94216: PUSH
94217: LD_INT 1
94219: NEG
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: LIST
94229: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94230: LD_ADDR_VAR 0 64
94234: PUSH
94235: LD_INT 1
94237: NEG
94238: PUSH
94239: LD_INT 2
94241: NEG
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: PUSH
94247: LD_INT 2
94249: NEG
94250: PUSH
94251: LD_INT 1
94253: NEG
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PUSH
94259: LD_INT 2
94261: NEG
94262: PUSH
94263: LD_INT 2
94265: NEG
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: LIST
94275: ST_TO_ADDR
// end ; 2 :
94276: GO 97542
94278: LD_INT 2
94280: DOUBLE
94281: EQUAL
94282: IFTRUE 94286
94284: GO 97541
94286: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94287: LD_ADDR_VAR 0 29
94291: PUSH
94292: LD_INT 4
94294: PUSH
94295: LD_INT 0
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 4
94304: PUSH
94305: LD_INT 1
94307: NEG
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 5
94315: PUSH
94316: LD_INT 0
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 5
94325: PUSH
94326: LD_INT 1
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 4
94335: PUSH
94336: LD_INT 1
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 3
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 3
94355: PUSH
94356: LD_INT 1
94358: NEG
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 3
94366: PUSH
94367: LD_INT 2
94369: NEG
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 5
94377: PUSH
94378: LD_INT 2
94380: PUSH
94381: EMPTY
94382: LIST
94383: LIST
94384: PUSH
94385: LD_INT 3
94387: PUSH
94388: LD_INT 3
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 3
94397: PUSH
94398: LD_INT 2
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 4
94407: PUSH
94408: LD_INT 3
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: LD_INT 4
94417: PUSH
94418: LD_INT 4
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PUSH
94425: LD_INT 3
94427: PUSH
94428: LD_INT 4
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 2
94437: PUSH
94438: LD_INT 3
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 2
94447: PUSH
94448: LD_INT 2
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 4
94457: PUSH
94458: LD_INT 2
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 2
94467: PUSH
94468: LD_INT 4
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 0
94477: PUSH
94478: LD_INT 4
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 0
94487: PUSH
94488: LD_INT 3
94490: PUSH
94491: EMPTY
94492: LIST
94493: LIST
94494: PUSH
94495: LD_INT 1
94497: PUSH
94498: LD_INT 4
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: LD_INT 5
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 0
94517: PUSH
94518: LD_INT 5
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 1
94527: NEG
94528: PUSH
94529: LD_INT 4
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 1
94538: NEG
94539: PUSH
94540: LD_INT 3
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: PUSH
94547: LD_INT 2
94549: PUSH
94550: LD_INT 5
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 2
94559: NEG
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: PUSH
94568: LD_INT 3
94570: NEG
94571: PUSH
94572: LD_INT 0
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: PUSH
94579: LD_INT 3
94581: NEG
94582: PUSH
94583: LD_INT 1
94585: NEG
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 2
94593: NEG
94594: PUSH
94595: LD_INT 0
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 2
94604: NEG
94605: PUSH
94606: LD_INT 1
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: LD_INT 3
94615: NEG
94616: PUSH
94617: LD_INT 1
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 4
94626: NEG
94627: PUSH
94628: LD_INT 0
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: LD_INT 1
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 4
94649: NEG
94650: PUSH
94651: LD_INT 2
94653: NEG
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: PUSH
94659: LD_INT 2
94661: NEG
94662: PUSH
94663: LD_INT 2
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: PUSH
94670: LD_INT 4
94672: NEG
94673: PUSH
94674: LD_INT 4
94676: NEG
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: LD_INT 4
94684: NEG
94685: PUSH
94686: LD_INT 5
94688: NEG
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 3
94696: NEG
94697: PUSH
94698: LD_INT 4
94700: NEG
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: PUSH
94706: LD_INT 3
94708: NEG
94709: PUSH
94710: LD_INT 3
94712: NEG
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 4
94720: NEG
94721: PUSH
94722: LD_INT 3
94724: NEG
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 5
94732: NEG
94733: PUSH
94734: LD_INT 4
94736: NEG
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 5
94744: NEG
94745: PUSH
94746: LD_INT 5
94748: NEG
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 3
94756: NEG
94757: PUSH
94758: LD_INT 5
94760: NEG
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: LD_INT 5
94768: NEG
94769: PUSH
94770: LD_INT 3
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94825: LD_ADDR_VAR 0 30
94829: PUSH
94830: LD_INT 4
94832: PUSH
94833: LD_INT 4
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 4
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 5
94852: PUSH
94853: LD_INT 4
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 5
94862: PUSH
94863: LD_INT 5
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 4
94872: PUSH
94873: LD_INT 5
94875: PUSH
94876: EMPTY
94877: LIST
94878: LIST
94879: PUSH
94880: LD_INT 3
94882: PUSH
94883: LD_INT 4
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 3
94892: PUSH
94893: LD_INT 3
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 5
94902: PUSH
94903: LD_INT 3
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 3
94912: PUSH
94913: LD_INT 5
94915: PUSH
94916: EMPTY
94917: LIST
94918: LIST
94919: PUSH
94920: LD_INT 0
94922: PUSH
94923: LD_INT 3
94925: PUSH
94926: EMPTY
94927: LIST
94928: LIST
94929: PUSH
94930: LD_INT 0
94932: PUSH
94933: LD_INT 2
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: LD_INT 1
94942: PUSH
94943: LD_INT 3
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 1
94952: PUSH
94953: LD_INT 4
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: LD_INT 0
94962: PUSH
94963: LD_INT 4
94965: PUSH
94966: EMPTY
94967: LIST
94968: LIST
94969: PUSH
94970: LD_INT 1
94972: NEG
94973: PUSH
94974: LD_INT 3
94976: PUSH
94977: EMPTY
94978: LIST
94979: LIST
94980: PUSH
94981: LD_INT 1
94983: NEG
94984: PUSH
94985: LD_INT 2
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 2
94994: PUSH
94995: LD_INT 4
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 2
95004: NEG
95005: PUSH
95006: LD_INT 2
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 4
95015: NEG
95016: PUSH
95017: LD_INT 0
95019: PUSH
95020: EMPTY
95021: LIST
95022: LIST
95023: PUSH
95024: LD_INT 4
95026: NEG
95027: PUSH
95028: LD_INT 1
95030: NEG
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 3
95038: NEG
95039: PUSH
95040: LD_INT 0
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: LD_INT 3
95049: NEG
95050: PUSH
95051: LD_INT 1
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: LD_INT 4
95060: NEG
95061: PUSH
95062: LD_INT 1
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 5
95071: NEG
95072: PUSH
95073: LD_INT 0
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: PUSH
95080: LD_INT 5
95082: NEG
95083: PUSH
95084: LD_INT 1
95086: NEG
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 5
95094: NEG
95095: PUSH
95096: LD_INT 2
95098: NEG
95099: PUSH
95100: EMPTY
95101: LIST
95102: LIST
95103: PUSH
95104: LD_INT 3
95106: NEG
95107: PUSH
95108: LD_INT 2
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 3
95117: NEG
95118: PUSH
95119: LD_INT 3
95121: NEG
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 3
95129: NEG
95130: PUSH
95131: LD_INT 4
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 2
95141: NEG
95142: PUSH
95143: LD_INT 3
95145: NEG
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 2
95153: NEG
95154: PUSH
95155: LD_INT 2
95157: NEG
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 3
95165: NEG
95166: PUSH
95167: LD_INT 2
95169: NEG
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 4
95177: NEG
95178: PUSH
95179: LD_INT 3
95181: NEG
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 4
95189: NEG
95190: PUSH
95191: LD_INT 4
95193: NEG
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PUSH
95199: LD_INT 2
95201: NEG
95202: PUSH
95203: LD_INT 4
95205: NEG
95206: PUSH
95207: EMPTY
95208: LIST
95209: LIST
95210: PUSH
95211: LD_INT 4
95213: NEG
95214: PUSH
95215: LD_INT 2
95217: NEG
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: LD_INT 0
95225: PUSH
95226: LD_INT 4
95228: NEG
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 0
95236: PUSH
95237: LD_INT 5
95239: NEG
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 1
95247: PUSH
95248: LD_INT 4
95250: NEG
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 1
95258: PUSH
95259: LD_INT 3
95261: NEG
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 0
95269: PUSH
95270: LD_INT 3
95272: NEG
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 1
95280: NEG
95281: PUSH
95282: LD_INT 4
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 1
95292: NEG
95293: PUSH
95294: LD_INT 5
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 2
95304: PUSH
95305: LD_INT 3
95307: NEG
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 2
95315: NEG
95316: PUSH
95317: LD_INT 5
95319: NEG
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95372: LD_ADDR_VAR 0 31
95376: PUSH
95377: LD_INT 0
95379: PUSH
95380: LD_INT 4
95382: PUSH
95383: EMPTY
95384: LIST
95385: LIST
95386: PUSH
95387: LD_INT 0
95389: PUSH
95390: LD_INT 3
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 1
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 1
95409: PUSH
95410: LD_INT 5
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 0
95419: PUSH
95420: LD_INT 5
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 1
95429: NEG
95430: PUSH
95431: LD_INT 4
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 1
95440: NEG
95441: PUSH
95442: LD_INT 3
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 2
95451: PUSH
95452: LD_INT 5
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 2
95461: NEG
95462: PUSH
95463: LD_INT 3
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PUSH
95470: LD_INT 3
95472: NEG
95473: PUSH
95474: LD_INT 0
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 3
95483: NEG
95484: PUSH
95485: LD_INT 1
95487: NEG
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 2
95495: NEG
95496: PUSH
95497: LD_INT 0
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 2
95506: NEG
95507: PUSH
95508: LD_INT 1
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 3
95517: NEG
95518: PUSH
95519: LD_INT 1
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: PUSH
95526: LD_INT 4
95528: NEG
95529: PUSH
95530: LD_INT 0
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 4
95539: NEG
95540: PUSH
95541: LD_INT 1
95543: NEG
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 4
95551: NEG
95552: PUSH
95553: LD_INT 2
95555: NEG
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 2
95563: NEG
95564: PUSH
95565: LD_INT 2
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 4
95574: NEG
95575: PUSH
95576: LD_INT 4
95578: NEG
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 4
95586: NEG
95587: PUSH
95588: LD_INT 5
95590: NEG
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 3
95598: NEG
95599: PUSH
95600: LD_INT 4
95602: NEG
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: PUSH
95608: LD_INT 3
95610: NEG
95611: PUSH
95612: LD_INT 3
95614: NEG
95615: PUSH
95616: EMPTY
95617: LIST
95618: LIST
95619: PUSH
95620: LD_INT 4
95622: NEG
95623: PUSH
95624: LD_INT 3
95626: NEG
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 5
95634: NEG
95635: PUSH
95636: LD_INT 4
95638: NEG
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 5
95646: NEG
95647: PUSH
95648: LD_INT 5
95650: NEG
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: PUSH
95656: LD_INT 3
95658: NEG
95659: PUSH
95660: LD_INT 5
95662: NEG
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: PUSH
95668: LD_INT 5
95670: NEG
95671: PUSH
95672: LD_INT 3
95674: NEG
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 0
95682: PUSH
95683: LD_INT 3
95685: NEG
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: LD_INT 0
95693: PUSH
95694: LD_INT 4
95696: NEG
95697: PUSH
95698: EMPTY
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 1
95704: PUSH
95705: LD_INT 3
95707: NEG
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 1
95715: PUSH
95716: LD_INT 2
95718: NEG
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 0
95726: PUSH
95727: LD_INT 2
95729: NEG
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 1
95737: NEG
95738: PUSH
95739: LD_INT 3
95741: NEG
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 1
95749: NEG
95750: PUSH
95751: LD_INT 4
95753: NEG
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 2
95761: PUSH
95762: LD_INT 2
95764: NEG
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: PUSH
95770: LD_INT 2
95772: NEG
95773: PUSH
95774: LD_INT 4
95776: NEG
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: PUSH
95782: LD_INT 4
95784: PUSH
95785: LD_INT 0
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 4
95794: PUSH
95795: LD_INT 1
95797: NEG
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: PUSH
95803: LD_INT 5
95805: PUSH
95806: LD_INT 0
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: LD_INT 5
95815: PUSH
95816: LD_INT 1
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 4
95825: PUSH
95826: LD_INT 1
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 3
95835: PUSH
95836: LD_INT 0
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: PUSH
95843: LD_INT 3
95845: PUSH
95846: LD_INT 1
95848: NEG
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 3
95856: PUSH
95857: LD_INT 2
95859: NEG
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 5
95867: PUSH
95868: LD_INT 2
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95922: LD_ADDR_VAR 0 32
95926: PUSH
95927: LD_INT 4
95929: NEG
95930: PUSH
95931: LD_INT 0
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: LD_INT 4
95940: NEG
95941: PUSH
95942: LD_INT 1
95944: NEG
95945: PUSH
95946: EMPTY
95947: LIST
95948: LIST
95949: PUSH
95950: LD_INT 3
95952: NEG
95953: PUSH
95954: LD_INT 0
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 3
95963: NEG
95964: PUSH
95965: LD_INT 1
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: PUSH
95972: LD_INT 4
95974: NEG
95975: PUSH
95976: LD_INT 1
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 5
95985: NEG
95986: PUSH
95987: LD_INT 0
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 5
95996: NEG
95997: PUSH
95998: LD_INT 1
96000: NEG
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 5
96008: NEG
96009: PUSH
96010: LD_INT 2
96012: NEG
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 3
96020: NEG
96021: PUSH
96022: LD_INT 2
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 3
96031: NEG
96032: PUSH
96033: LD_INT 3
96035: NEG
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 3
96043: NEG
96044: PUSH
96045: LD_INT 4
96047: NEG
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 2
96055: NEG
96056: PUSH
96057: LD_INT 3
96059: NEG
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 2
96067: NEG
96068: PUSH
96069: LD_INT 2
96071: NEG
96072: PUSH
96073: EMPTY
96074: LIST
96075: LIST
96076: PUSH
96077: LD_INT 3
96079: NEG
96080: PUSH
96081: LD_INT 2
96083: NEG
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 4
96091: NEG
96092: PUSH
96093: LD_INT 3
96095: NEG
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: PUSH
96101: LD_INT 4
96103: NEG
96104: PUSH
96105: LD_INT 4
96107: NEG
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PUSH
96113: LD_INT 2
96115: NEG
96116: PUSH
96117: LD_INT 4
96119: NEG
96120: PUSH
96121: EMPTY
96122: LIST
96123: LIST
96124: PUSH
96125: LD_INT 4
96127: NEG
96128: PUSH
96129: LD_INT 2
96131: NEG
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: PUSH
96137: LD_INT 0
96139: PUSH
96140: LD_INT 4
96142: NEG
96143: PUSH
96144: EMPTY
96145: LIST
96146: LIST
96147: PUSH
96148: LD_INT 0
96150: PUSH
96151: LD_INT 5
96153: NEG
96154: PUSH
96155: EMPTY
96156: LIST
96157: LIST
96158: PUSH
96159: LD_INT 1
96161: PUSH
96162: LD_INT 4
96164: NEG
96165: PUSH
96166: EMPTY
96167: LIST
96168: LIST
96169: PUSH
96170: LD_INT 1
96172: PUSH
96173: LD_INT 3
96175: NEG
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 0
96183: PUSH
96184: LD_INT 3
96186: NEG
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 1
96194: NEG
96195: PUSH
96196: LD_INT 4
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 1
96206: NEG
96207: PUSH
96208: LD_INT 5
96210: NEG
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 2
96218: PUSH
96219: LD_INT 3
96221: NEG
96222: PUSH
96223: EMPTY
96224: LIST
96225: LIST
96226: PUSH
96227: LD_INT 2
96229: NEG
96230: PUSH
96231: LD_INT 5
96233: NEG
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 3
96241: PUSH
96242: LD_INT 0
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: LD_INT 3
96251: PUSH
96252: LD_INT 1
96254: NEG
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 4
96262: PUSH
96263: LD_INT 0
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 4
96272: PUSH
96273: LD_INT 1
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 3
96282: PUSH
96283: LD_INT 1
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 2
96292: PUSH
96293: LD_INT 0
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: PUSH
96300: LD_INT 2
96302: PUSH
96303: LD_INT 1
96305: NEG
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 2
96313: PUSH
96314: LD_INT 2
96316: NEG
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: LD_INT 4
96324: PUSH
96325: LD_INT 2
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PUSH
96332: LD_INT 4
96334: PUSH
96335: LD_INT 4
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: PUSH
96342: LD_INT 4
96344: PUSH
96345: LD_INT 3
96347: PUSH
96348: EMPTY
96349: LIST
96350: LIST
96351: PUSH
96352: LD_INT 5
96354: PUSH
96355: LD_INT 4
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: PUSH
96362: LD_INT 5
96364: PUSH
96365: LD_INT 5
96367: PUSH
96368: EMPTY
96369: LIST
96370: LIST
96371: PUSH
96372: LD_INT 4
96374: PUSH
96375: LD_INT 5
96377: PUSH
96378: EMPTY
96379: LIST
96380: LIST
96381: PUSH
96382: LD_INT 3
96384: PUSH
96385: LD_INT 4
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 3
96394: PUSH
96395: LD_INT 3
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 5
96404: PUSH
96405: LD_INT 3
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: PUSH
96412: LD_INT 3
96414: PUSH
96415: LD_INT 5
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96469: LD_ADDR_VAR 0 33
96473: PUSH
96474: LD_INT 4
96476: NEG
96477: PUSH
96478: LD_INT 4
96480: NEG
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 4
96488: NEG
96489: PUSH
96490: LD_INT 5
96492: NEG
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 3
96500: NEG
96501: PUSH
96502: LD_INT 4
96504: NEG
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 3
96512: NEG
96513: PUSH
96514: LD_INT 3
96516: NEG
96517: PUSH
96518: EMPTY
96519: LIST
96520: LIST
96521: PUSH
96522: LD_INT 4
96524: NEG
96525: PUSH
96526: LD_INT 3
96528: NEG
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: PUSH
96534: LD_INT 5
96536: NEG
96537: PUSH
96538: LD_INT 4
96540: NEG
96541: PUSH
96542: EMPTY
96543: LIST
96544: LIST
96545: PUSH
96546: LD_INT 5
96548: NEG
96549: PUSH
96550: LD_INT 5
96552: NEG
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: PUSH
96558: LD_INT 3
96560: NEG
96561: PUSH
96562: LD_INT 5
96564: NEG
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 5
96572: NEG
96573: PUSH
96574: LD_INT 3
96576: NEG
96577: PUSH
96578: EMPTY
96579: LIST
96580: LIST
96581: PUSH
96582: LD_INT 0
96584: PUSH
96585: LD_INT 3
96587: NEG
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: PUSH
96593: LD_INT 0
96595: PUSH
96596: LD_INT 4
96598: NEG
96599: PUSH
96600: EMPTY
96601: LIST
96602: LIST
96603: PUSH
96604: LD_INT 1
96606: PUSH
96607: LD_INT 3
96609: NEG
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 1
96617: PUSH
96618: LD_INT 2
96620: NEG
96621: PUSH
96622: EMPTY
96623: LIST
96624: LIST
96625: PUSH
96626: LD_INT 0
96628: PUSH
96629: LD_INT 2
96631: NEG
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 1
96639: NEG
96640: PUSH
96641: LD_INT 3
96643: NEG
96644: PUSH
96645: EMPTY
96646: LIST
96647: LIST
96648: PUSH
96649: LD_INT 1
96651: NEG
96652: PUSH
96653: LD_INT 4
96655: NEG
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: PUSH
96661: LD_INT 2
96663: PUSH
96664: LD_INT 2
96666: NEG
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: PUSH
96672: LD_INT 2
96674: NEG
96675: PUSH
96676: LD_INT 4
96678: NEG
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 4
96686: PUSH
96687: LD_INT 0
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 4
96696: PUSH
96697: LD_INT 1
96699: NEG
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: LD_INT 5
96707: PUSH
96708: LD_INT 0
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: PUSH
96715: LD_INT 5
96717: PUSH
96718: LD_INT 1
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 4
96727: PUSH
96728: LD_INT 1
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 3
96737: PUSH
96738: LD_INT 0
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: PUSH
96745: LD_INT 3
96747: PUSH
96748: LD_INT 1
96750: NEG
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: LD_INT 2
96761: NEG
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: PUSH
96767: LD_INT 5
96769: PUSH
96770: LD_INT 2
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 3
96779: PUSH
96780: LD_INT 3
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 3
96789: PUSH
96790: LD_INT 2
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 4
96799: PUSH
96800: LD_INT 3
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: LD_INT 4
96809: PUSH
96810: LD_INT 4
96812: PUSH
96813: EMPTY
96814: LIST
96815: LIST
96816: PUSH
96817: LD_INT 3
96819: PUSH
96820: LD_INT 4
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: PUSH
96827: LD_INT 2
96829: PUSH
96830: LD_INT 3
96832: PUSH
96833: EMPTY
96834: LIST
96835: LIST
96836: PUSH
96837: LD_INT 2
96839: PUSH
96840: LD_INT 2
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: PUSH
96847: LD_INT 4
96849: PUSH
96850: LD_INT 2
96852: PUSH
96853: EMPTY
96854: LIST
96855: LIST
96856: PUSH
96857: LD_INT 2
96859: PUSH
96860: LD_INT 4
96862: PUSH
96863: EMPTY
96864: LIST
96865: LIST
96866: PUSH
96867: LD_INT 0
96869: PUSH
96870: LD_INT 4
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: LD_INT 0
96879: PUSH
96880: LD_INT 3
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: PUSH
96887: LD_INT 1
96889: PUSH
96890: LD_INT 4
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: PUSH
96900: LD_INT 5
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 0
96909: PUSH
96910: LD_INT 5
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 1
96919: NEG
96920: PUSH
96921: LD_INT 4
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 1
96930: NEG
96931: PUSH
96932: LD_INT 3
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: PUSH
96939: LD_INT 2
96941: PUSH
96942: LD_INT 5
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 2
96951: NEG
96952: PUSH
96953: LD_INT 3
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: LIST
97002: LIST
97003: LIST
97004: LIST
97005: LIST
97006: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97007: LD_ADDR_VAR 0 34
97011: PUSH
97012: LD_INT 0
97014: PUSH
97015: LD_INT 4
97017: NEG
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PUSH
97023: LD_INT 0
97025: PUSH
97026: LD_INT 5
97028: NEG
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 1
97036: PUSH
97037: LD_INT 4
97039: NEG
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 1
97047: PUSH
97048: LD_INT 3
97050: NEG
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 0
97058: PUSH
97059: LD_INT 3
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 1
97069: NEG
97070: PUSH
97071: LD_INT 4
97073: NEG
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 1
97081: NEG
97082: PUSH
97083: LD_INT 5
97085: NEG
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PUSH
97091: LD_INT 2
97093: PUSH
97094: LD_INT 3
97096: NEG
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: PUSH
97102: LD_INT 2
97104: NEG
97105: PUSH
97106: LD_INT 5
97108: NEG
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 3
97116: PUSH
97117: LD_INT 0
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 3
97126: PUSH
97127: LD_INT 1
97129: NEG
97130: PUSH
97131: EMPTY
97132: LIST
97133: LIST
97134: PUSH
97135: LD_INT 4
97137: PUSH
97138: LD_INT 0
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: PUSH
97145: LD_INT 4
97147: PUSH
97148: LD_INT 1
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 3
97157: PUSH
97158: LD_INT 1
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 2
97167: PUSH
97168: LD_INT 0
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 2
97177: PUSH
97178: LD_INT 1
97180: NEG
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 2
97188: PUSH
97189: LD_INT 2
97191: NEG
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: PUSH
97197: LD_INT 4
97199: PUSH
97200: LD_INT 2
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 4
97209: PUSH
97210: LD_INT 4
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: LD_INT 4
97219: PUSH
97220: LD_INT 3
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 5
97229: PUSH
97230: LD_INT 4
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 5
97239: PUSH
97240: LD_INT 5
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_INT 4
97249: PUSH
97250: LD_INT 5
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: LD_INT 3
97259: PUSH
97260: LD_INT 4
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: PUSH
97267: LD_INT 3
97269: PUSH
97270: LD_INT 3
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: PUSH
97277: LD_INT 5
97279: PUSH
97280: LD_INT 3
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 3
97289: PUSH
97290: LD_INT 5
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 0
97299: PUSH
97300: LD_INT 3
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 0
97309: PUSH
97310: LD_INT 2
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 1
97319: PUSH
97320: LD_INT 3
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 1
97329: PUSH
97330: LD_INT 4
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 0
97339: PUSH
97340: LD_INT 4
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: PUSH
97347: LD_INT 1
97349: NEG
97350: PUSH
97351: LD_INT 3
97353: PUSH
97354: EMPTY
97355: LIST
97356: LIST
97357: PUSH
97358: LD_INT 1
97360: NEG
97361: PUSH
97362: LD_INT 2
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 2
97371: PUSH
97372: LD_INT 4
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: PUSH
97379: LD_INT 2
97381: NEG
97382: PUSH
97383: LD_INT 2
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 4
97392: NEG
97393: PUSH
97394: LD_INT 0
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PUSH
97401: LD_INT 4
97403: NEG
97404: PUSH
97405: LD_INT 1
97407: NEG
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: PUSH
97413: LD_INT 3
97415: NEG
97416: PUSH
97417: LD_INT 0
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 3
97426: NEG
97427: PUSH
97428: LD_INT 1
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 4
97437: NEG
97438: PUSH
97439: LD_INT 1
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: LD_INT 5
97448: NEG
97449: PUSH
97450: LD_INT 0
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: PUSH
97457: LD_INT 5
97459: NEG
97460: PUSH
97461: LD_INT 1
97463: NEG
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: PUSH
97469: LD_INT 5
97471: NEG
97472: PUSH
97473: LD_INT 2
97475: NEG
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: LD_INT 3
97483: NEG
97484: PUSH
97485: LD_INT 2
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: EMPTY
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: ST_TO_ADDR
// end ; end ;
97539: GO 97542
97541: POP
// case btype of b_depot , b_warehouse :
97542: LD_VAR 0 1
97546: PUSH
97547: LD_INT 0
97549: DOUBLE
97550: EQUAL
97551: IFTRUE 97561
97553: LD_INT 1
97555: DOUBLE
97556: EQUAL
97557: IFTRUE 97561
97559: GO 97762
97561: POP
// case nation of nation_american :
97562: LD_VAR 0 5
97566: PUSH
97567: LD_INT 1
97569: DOUBLE
97570: EQUAL
97571: IFTRUE 97575
97573: GO 97631
97575: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97576: LD_ADDR_VAR 0 9
97580: PUSH
97581: LD_VAR 0 11
97585: PUSH
97586: LD_VAR 0 12
97590: PUSH
97591: LD_VAR 0 13
97595: PUSH
97596: LD_VAR 0 14
97600: PUSH
97601: LD_VAR 0 15
97605: PUSH
97606: LD_VAR 0 16
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: LIST
97617: LIST
97618: PUSH
97619: LD_VAR 0 4
97623: PUSH
97624: LD_INT 1
97626: PLUS
97627: ARRAY
97628: ST_TO_ADDR
97629: GO 97760
97631: LD_INT 2
97633: DOUBLE
97634: EQUAL
97635: IFTRUE 97639
97637: GO 97695
97639: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97640: LD_ADDR_VAR 0 9
97644: PUSH
97645: LD_VAR 0 17
97649: PUSH
97650: LD_VAR 0 18
97654: PUSH
97655: LD_VAR 0 19
97659: PUSH
97660: LD_VAR 0 20
97664: PUSH
97665: LD_VAR 0 21
97669: PUSH
97670: LD_VAR 0 22
97674: PUSH
97675: EMPTY
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: PUSH
97683: LD_VAR 0 4
97687: PUSH
97688: LD_INT 1
97690: PLUS
97691: ARRAY
97692: ST_TO_ADDR
97693: GO 97760
97695: LD_INT 3
97697: DOUBLE
97698: EQUAL
97699: IFTRUE 97703
97701: GO 97759
97703: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97704: LD_ADDR_VAR 0 9
97708: PUSH
97709: LD_VAR 0 23
97713: PUSH
97714: LD_VAR 0 24
97718: PUSH
97719: LD_VAR 0 25
97723: PUSH
97724: LD_VAR 0 26
97728: PUSH
97729: LD_VAR 0 27
97733: PUSH
97734: LD_VAR 0 28
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: PUSH
97747: LD_VAR 0 4
97751: PUSH
97752: LD_INT 1
97754: PLUS
97755: ARRAY
97756: ST_TO_ADDR
97757: GO 97760
97759: POP
97760: GO 98315
97762: LD_INT 2
97764: DOUBLE
97765: EQUAL
97766: IFTRUE 97776
97768: LD_INT 3
97770: DOUBLE
97771: EQUAL
97772: IFTRUE 97776
97774: GO 97832
97776: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97777: LD_ADDR_VAR 0 9
97781: PUSH
97782: LD_VAR 0 29
97786: PUSH
97787: LD_VAR 0 30
97791: PUSH
97792: LD_VAR 0 31
97796: PUSH
97797: LD_VAR 0 32
97801: PUSH
97802: LD_VAR 0 33
97806: PUSH
97807: LD_VAR 0 34
97811: PUSH
97812: EMPTY
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: PUSH
97820: LD_VAR 0 4
97824: PUSH
97825: LD_INT 1
97827: PLUS
97828: ARRAY
97829: ST_TO_ADDR
97830: GO 98315
97832: LD_INT 16
97834: DOUBLE
97835: EQUAL
97836: IFTRUE 97894
97838: LD_INT 17
97840: DOUBLE
97841: EQUAL
97842: IFTRUE 97894
97844: LD_INT 18
97846: DOUBLE
97847: EQUAL
97848: IFTRUE 97894
97850: LD_INT 19
97852: DOUBLE
97853: EQUAL
97854: IFTRUE 97894
97856: LD_INT 22
97858: DOUBLE
97859: EQUAL
97860: IFTRUE 97894
97862: LD_INT 20
97864: DOUBLE
97865: EQUAL
97866: IFTRUE 97894
97868: LD_INT 21
97870: DOUBLE
97871: EQUAL
97872: IFTRUE 97894
97874: LD_INT 23
97876: DOUBLE
97877: EQUAL
97878: IFTRUE 97894
97880: LD_INT 24
97882: DOUBLE
97883: EQUAL
97884: IFTRUE 97894
97886: LD_INT 25
97888: DOUBLE
97889: EQUAL
97890: IFTRUE 97894
97892: GO 97950
97894: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97895: LD_ADDR_VAR 0 9
97899: PUSH
97900: LD_VAR 0 35
97904: PUSH
97905: LD_VAR 0 36
97909: PUSH
97910: LD_VAR 0 37
97914: PUSH
97915: LD_VAR 0 38
97919: PUSH
97920: LD_VAR 0 39
97924: PUSH
97925: LD_VAR 0 40
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: PUSH
97938: LD_VAR 0 4
97942: PUSH
97943: LD_INT 1
97945: PLUS
97946: ARRAY
97947: ST_TO_ADDR
97948: GO 98315
97950: LD_INT 6
97952: DOUBLE
97953: EQUAL
97954: IFTRUE 98006
97956: LD_INT 7
97958: DOUBLE
97959: EQUAL
97960: IFTRUE 98006
97962: LD_INT 8
97964: DOUBLE
97965: EQUAL
97966: IFTRUE 98006
97968: LD_INT 13
97970: DOUBLE
97971: EQUAL
97972: IFTRUE 98006
97974: LD_INT 12
97976: DOUBLE
97977: EQUAL
97978: IFTRUE 98006
97980: LD_INT 15
97982: DOUBLE
97983: EQUAL
97984: IFTRUE 98006
97986: LD_INT 11
97988: DOUBLE
97989: EQUAL
97990: IFTRUE 98006
97992: LD_INT 14
97994: DOUBLE
97995: EQUAL
97996: IFTRUE 98006
97998: LD_INT 10
98000: DOUBLE
98001: EQUAL
98002: IFTRUE 98006
98004: GO 98062
98006: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
98007: LD_ADDR_VAR 0 9
98011: PUSH
98012: LD_VAR 0 41
98016: PUSH
98017: LD_VAR 0 42
98021: PUSH
98022: LD_VAR 0 43
98026: PUSH
98027: LD_VAR 0 44
98031: PUSH
98032: LD_VAR 0 45
98036: PUSH
98037: LD_VAR 0 46
98041: PUSH
98042: EMPTY
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: PUSH
98050: LD_VAR 0 4
98054: PUSH
98055: LD_INT 1
98057: PLUS
98058: ARRAY
98059: ST_TO_ADDR
98060: GO 98315
98062: LD_INT 36
98064: DOUBLE
98065: EQUAL
98066: IFTRUE 98070
98068: GO 98126
98070: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98071: LD_ADDR_VAR 0 9
98075: PUSH
98076: LD_VAR 0 47
98080: PUSH
98081: LD_VAR 0 48
98085: PUSH
98086: LD_VAR 0 49
98090: PUSH
98091: LD_VAR 0 50
98095: PUSH
98096: LD_VAR 0 51
98100: PUSH
98101: LD_VAR 0 52
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: PUSH
98114: LD_VAR 0 4
98118: PUSH
98119: LD_INT 1
98121: PLUS
98122: ARRAY
98123: ST_TO_ADDR
98124: GO 98315
98126: LD_INT 4
98128: DOUBLE
98129: EQUAL
98130: IFTRUE 98152
98132: LD_INT 5
98134: DOUBLE
98135: EQUAL
98136: IFTRUE 98152
98138: LD_INT 34
98140: DOUBLE
98141: EQUAL
98142: IFTRUE 98152
98144: LD_INT 37
98146: DOUBLE
98147: EQUAL
98148: IFTRUE 98152
98150: GO 98208
98152: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98153: LD_ADDR_VAR 0 9
98157: PUSH
98158: LD_VAR 0 53
98162: PUSH
98163: LD_VAR 0 54
98167: PUSH
98168: LD_VAR 0 55
98172: PUSH
98173: LD_VAR 0 56
98177: PUSH
98178: LD_VAR 0 57
98182: PUSH
98183: LD_VAR 0 58
98187: PUSH
98188: EMPTY
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: PUSH
98196: LD_VAR 0 4
98200: PUSH
98201: LD_INT 1
98203: PLUS
98204: ARRAY
98205: ST_TO_ADDR
98206: GO 98315
98208: LD_INT 31
98210: DOUBLE
98211: EQUAL
98212: IFTRUE 98258
98214: LD_INT 32
98216: DOUBLE
98217: EQUAL
98218: IFTRUE 98258
98220: LD_INT 33
98222: DOUBLE
98223: EQUAL
98224: IFTRUE 98258
98226: LD_INT 27
98228: DOUBLE
98229: EQUAL
98230: IFTRUE 98258
98232: LD_INT 26
98234: DOUBLE
98235: EQUAL
98236: IFTRUE 98258
98238: LD_INT 28
98240: DOUBLE
98241: EQUAL
98242: IFTRUE 98258
98244: LD_INT 29
98246: DOUBLE
98247: EQUAL
98248: IFTRUE 98258
98250: LD_INT 30
98252: DOUBLE
98253: EQUAL
98254: IFTRUE 98258
98256: GO 98314
98258: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98259: LD_ADDR_VAR 0 9
98263: PUSH
98264: LD_VAR 0 59
98268: PUSH
98269: LD_VAR 0 60
98273: PUSH
98274: LD_VAR 0 61
98278: PUSH
98279: LD_VAR 0 62
98283: PUSH
98284: LD_VAR 0 63
98288: PUSH
98289: LD_VAR 0 64
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: PUSH
98302: LD_VAR 0 4
98306: PUSH
98307: LD_INT 1
98309: PLUS
98310: ARRAY
98311: ST_TO_ADDR
98312: GO 98315
98314: POP
// temp_list2 = [ ] ;
98315: LD_ADDR_VAR 0 10
98319: PUSH
98320: EMPTY
98321: ST_TO_ADDR
// for i in temp_list do
98322: LD_ADDR_VAR 0 8
98326: PUSH
98327: LD_VAR 0 9
98331: PUSH
98332: FOR_IN
98333: IFFALSE 98385
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98335: LD_ADDR_VAR 0 10
98339: PUSH
98340: LD_VAR 0 10
98344: PUSH
98345: LD_VAR 0 8
98349: PUSH
98350: LD_INT 1
98352: ARRAY
98353: PUSH
98354: LD_VAR 0 2
98358: PLUS
98359: PUSH
98360: LD_VAR 0 8
98364: PUSH
98365: LD_INT 2
98367: ARRAY
98368: PUSH
98369: LD_VAR 0 3
98373: PLUS
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PUSH
98379: EMPTY
98380: LIST
98381: ADD
98382: ST_TO_ADDR
98383: GO 98332
98385: POP
98386: POP
// result = temp_list2 ;
98387: LD_ADDR_VAR 0 7
98391: PUSH
98392: LD_VAR 0 10
98396: ST_TO_ADDR
// end ;
98397: LD_VAR 0 7
98401: RET
// export function EnemyInRange ( unit , dist ) ; begin
98402: LD_INT 0
98404: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98405: LD_ADDR_VAR 0 3
98409: PUSH
98410: LD_VAR 0 1
98414: PPUSH
98415: CALL_OW 255
98419: PPUSH
98420: LD_VAR 0 1
98424: PPUSH
98425: CALL_OW 250
98429: PPUSH
98430: LD_VAR 0 1
98434: PPUSH
98435: CALL_OW 251
98439: PPUSH
98440: LD_VAR 0 2
98444: PPUSH
98445: CALL 71798 0 4
98449: PUSH
98450: LD_INT 4
98452: ARRAY
98453: ST_TO_ADDR
// end ;
98454: LD_VAR 0 3
98458: RET
// export function PlayerSeeMe ( unit ) ; begin
98459: LD_INT 0
98461: PPUSH
// result := See ( your_side , unit ) ;
98462: LD_ADDR_VAR 0 2
98466: PUSH
98467: LD_OWVAR 2
98471: PPUSH
98472: LD_VAR 0 1
98476: PPUSH
98477: CALL_OW 292
98481: ST_TO_ADDR
// end ;
98482: LD_VAR 0 2
98486: RET
// export function ReverseDir ( unit ) ; begin
98487: LD_INT 0
98489: PPUSH
// if not unit then
98490: LD_VAR 0 1
98494: NOT
98495: IFFALSE 98499
// exit ;
98497: GO 98522
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98499: LD_ADDR_VAR 0 2
98503: PUSH
98504: LD_VAR 0 1
98508: PPUSH
98509: CALL_OW 254
98513: PUSH
98514: LD_INT 3
98516: PLUS
98517: PUSH
98518: LD_INT 6
98520: MOD
98521: ST_TO_ADDR
// end ;
98522: LD_VAR 0 2
98526: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98527: LD_INT 0
98529: PPUSH
98530: PPUSH
98531: PPUSH
98532: PPUSH
98533: PPUSH
// if not hexes then
98534: LD_VAR 0 2
98538: NOT
98539: IFFALSE 98543
// exit ;
98541: GO 98691
// dist := 9999 ;
98543: LD_ADDR_VAR 0 5
98547: PUSH
98548: LD_INT 9999
98550: ST_TO_ADDR
// for i = 1 to hexes do
98551: LD_ADDR_VAR 0 4
98555: PUSH
98556: DOUBLE
98557: LD_INT 1
98559: DEC
98560: ST_TO_ADDR
98561: LD_VAR 0 2
98565: PUSH
98566: FOR_TO
98567: IFFALSE 98679
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98569: LD_VAR 0 1
98573: PPUSH
98574: LD_VAR 0 2
98578: PUSH
98579: LD_VAR 0 4
98583: ARRAY
98584: PUSH
98585: LD_INT 1
98587: ARRAY
98588: PPUSH
98589: LD_VAR 0 2
98593: PUSH
98594: LD_VAR 0 4
98598: ARRAY
98599: PUSH
98600: LD_INT 2
98602: ARRAY
98603: PPUSH
98604: CALL_OW 297
98608: PUSH
98609: LD_VAR 0 5
98613: LESS
98614: IFFALSE 98677
// begin hex := hexes [ i ] ;
98616: LD_ADDR_VAR 0 7
98620: PUSH
98621: LD_VAR 0 2
98625: PUSH
98626: LD_VAR 0 4
98630: ARRAY
98631: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98632: LD_ADDR_VAR 0 5
98636: PUSH
98637: LD_VAR 0 1
98641: PPUSH
98642: LD_VAR 0 2
98646: PUSH
98647: LD_VAR 0 4
98651: ARRAY
98652: PUSH
98653: LD_INT 1
98655: ARRAY
98656: PPUSH
98657: LD_VAR 0 2
98661: PUSH
98662: LD_VAR 0 4
98666: ARRAY
98667: PUSH
98668: LD_INT 2
98670: ARRAY
98671: PPUSH
98672: CALL_OW 297
98676: ST_TO_ADDR
// end ; end ;
98677: GO 98566
98679: POP
98680: POP
// result := hex ;
98681: LD_ADDR_VAR 0 3
98685: PUSH
98686: LD_VAR 0 7
98690: ST_TO_ADDR
// end ;
98691: LD_VAR 0 3
98695: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98696: LD_INT 0
98698: PPUSH
98699: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98700: LD_VAR 0 1
98704: NOT
98705: PUSH
98706: LD_VAR 0 1
98710: PUSH
98711: LD_INT 21
98713: PUSH
98714: LD_INT 2
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: PUSH
98721: LD_INT 23
98723: PUSH
98724: LD_INT 2
98726: PUSH
98727: EMPTY
98728: LIST
98729: LIST
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PPUSH
98735: CALL_OW 69
98739: IN
98740: NOT
98741: OR
98742: IFFALSE 98746
// exit ;
98744: GO 98793
// for i = 1 to 3 do
98746: LD_ADDR_VAR 0 3
98750: PUSH
98751: DOUBLE
98752: LD_INT 1
98754: DEC
98755: ST_TO_ADDR
98756: LD_INT 3
98758: PUSH
98759: FOR_TO
98760: IFFALSE 98791
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98762: LD_VAR 0 1
98766: PPUSH
98767: CALL_OW 250
98771: PPUSH
98772: LD_VAR 0 1
98776: PPUSH
98777: CALL_OW 251
98781: PPUSH
98782: LD_INT 1
98784: PPUSH
98785: CALL_OW 453
98789: GO 98759
98791: POP
98792: POP
// end ;
98793: LD_VAR 0 2
98797: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98798: LD_INT 0
98800: PPUSH
98801: PPUSH
98802: PPUSH
98803: PPUSH
98804: PPUSH
98805: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98806: LD_VAR 0 1
98810: NOT
98811: PUSH
98812: LD_VAR 0 2
98816: NOT
98817: OR
98818: PUSH
98819: LD_VAR 0 1
98823: PPUSH
98824: CALL_OW 314
98828: OR
98829: IFFALSE 98833
// exit ;
98831: GO 99274
// x := GetX ( enemy_unit ) ;
98833: LD_ADDR_VAR 0 7
98837: PUSH
98838: LD_VAR 0 2
98842: PPUSH
98843: CALL_OW 250
98847: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98848: LD_ADDR_VAR 0 8
98852: PUSH
98853: LD_VAR 0 2
98857: PPUSH
98858: CALL_OW 251
98862: ST_TO_ADDR
// if not x or not y then
98863: LD_VAR 0 7
98867: NOT
98868: PUSH
98869: LD_VAR 0 8
98873: NOT
98874: OR
98875: IFFALSE 98879
// exit ;
98877: GO 99274
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98879: LD_ADDR_VAR 0 6
98883: PUSH
98884: LD_VAR 0 7
98888: PPUSH
98889: LD_INT 0
98891: PPUSH
98892: LD_INT 4
98894: PPUSH
98895: CALL_OW 272
98899: PUSH
98900: LD_VAR 0 8
98904: PPUSH
98905: LD_INT 0
98907: PPUSH
98908: LD_INT 4
98910: PPUSH
98911: CALL_OW 273
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: PUSH
98920: LD_VAR 0 7
98924: PPUSH
98925: LD_INT 1
98927: PPUSH
98928: LD_INT 4
98930: PPUSH
98931: CALL_OW 272
98935: PUSH
98936: LD_VAR 0 8
98940: PPUSH
98941: LD_INT 1
98943: PPUSH
98944: LD_INT 4
98946: PPUSH
98947: CALL_OW 273
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PUSH
98956: LD_VAR 0 7
98960: PPUSH
98961: LD_INT 2
98963: PPUSH
98964: LD_INT 4
98966: PPUSH
98967: CALL_OW 272
98971: PUSH
98972: LD_VAR 0 8
98976: PPUSH
98977: LD_INT 2
98979: PPUSH
98980: LD_INT 4
98982: PPUSH
98983: CALL_OW 273
98987: PUSH
98988: EMPTY
98989: LIST
98990: LIST
98991: PUSH
98992: LD_VAR 0 7
98996: PPUSH
98997: LD_INT 3
98999: PPUSH
99000: LD_INT 4
99002: PPUSH
99003: CALL_OW 272
99007: PUSH
99008: LD_VAR 0 8
99012: PPUSH
99013: LD_INT 3
99015: PPUSH
99016: LD_INT 4
99018: PPUSH
99019: CALL_OW 273
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PUSH
99028: LD_VAR 0 7
99032: PPUSH
99033: LD_INT 4
99035: PPUSH
99036: LD_INT 4
99038: PPUSH
99039: CALL_OW 272
99043: PUSH
99044: LD_VAR 0 8
99048: PPUSH
99049: LD_INT 4
99051: PPUSH
99052: LD_INT 4
99054: PPUSH
99055: CALL_OW 273
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: PUSH
99064: LD_VAR 0 7
99068: PPUSH
99069: LD_INT 5
99071: PPUSH
99072: LD_INT 4
99074: PPUSH
99075: CALL_OW 272
99079: PUSH
99080: LD_VAR 0 8
99084: PPUSH
99085: LD_INT 5
99087: PPUSH
99088: LD_INT 4
99090: PPUSH
99091: CALL_OW 273
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: EMPTY
99101: LIST
99102: LIST
99103: LIST
99104: LIST
99105: LIST
99106: LIST
99107: ST_TO_ADDR
// for i = tmp downto 1 do
99108: LD_ADDR_VAR 0 4
99112: PUSH
99113: DOUBLE
99114: LD_VAR 0 6
99118: INC
99119: ST_TO_ADDR
99120: LD_INT 1
99122: PUSH
99123: FOR_DOWNTO
99124: IFFALSE 99225
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99126: LD_VAR 0 6
99130: PUSH
99131: LD_VAR 0 4
99135: ARRAY
99136: PUSH
99137: LD_INT 1
99139: ARRAY
99140: PPUSH
99141: LD_VAR 0 6
99145: PUSH
99146: LD_VAR 0 4
99150: ARRAY
99151: PUSH
99152: LD_INT 2
99154: ARRAY
99155: PPUSH
99156: CALL_OW 488
99160: NOT
99161: PUSH
99162: LD_VAR 0 6
99166: PUSH
99167: LD_VAR 0 4
99171: ARRAY
99172: PUSH
99173: LD_INT 1
99175: ARRAY
99176: PPUSH
99177: LD_VAR 0 6
99181: PUSH
99182: LD_VAR 0 4
99186: ARRAY
99187: PUSH
99188: LD_INT 2
99190: ARRAY
99191: PPUSH
99192: CALL_OW 428
99196: PUSH
99197: LD_INT 0
99199: NONEQUAL
99200: OR
99201: IFFALSE 99223
// tmp := Delete ( tmp , i ) ;
99203: LD_ADDR_VAR 0 6
99207: PUSH
99208: LD_VAR 0 6
99212: PPUSH
99213: LD_VAR 0 4
99217: PPUSH
99218: CALL_OW 3
99222: ST_TO_ADDR
99223: GO 99123
99225: POP
99226: POP
// j := GetClosestHex ( unit , tmp ) ;
99227: LD_ADDR_VAR 0 5
99231: PUSH
99232: LD_VAR 0 1
99236: PPUSH
99237: LD_VAR 0 6
99241: PPUSH
99242: CALL 98527 0 2
99246: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99247: LD_VAR 0 1
99251: PPUSH
99252: LD_VAR 0 5
99256: PUSH
99257: LD_INT 1
99259: ARRAY
99260: PPUSH
99261: LD_VAR 0 5
99265: PUSH
99266: LD_INT 2
99268: ARRAY
99269: PPUSH
99270: CALL_OW 111
// end ;
99274: LD_VAR 0 3
99278: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99279: LD_INT 0
99281: PPUSH
99282: PPUSH
99283: PPUSH
// uc_side = 0 ;
99284: LD_ADDR_OWVAR 20
99288: PUSH
99289: LD_INT 0
99291: ST_TO_ADDR
// uc_nation = 0 ;
99292: LD_ADDR_OWVAR 21
99296: PUSH
99297: LD_INT 0
99299: ST_TO_ADDR
// InitHc_All ( ) ;
99300: CALL_OW 584
// InitVc ;
99304: CALL_OW 20
// if mastodonts then
99308: LD_VAR 0 6
99312: IFFALSE 99379
// for i = 1 to mastodonts do
99314: LD_ADDR_VAR 0 11
99318: PUSH
99319: DOUBLE
99320: LD_INT 1
99322: DEC
99323: ST_TO_ADDR
99324: LD_VAR 0 6
99328: PUSH
99329: FOR_TO
99330: IFFALSE 99377
// begin vc_chassis := 31 ;
99332: LD_ADDR_OWVAR 37
99336: PUSH
99337: LD_INT 31
99339: ST_TO_ADDR
// vc_control := control_rider ;
99340: LD_ADDR_OWVAR 38
99344: PUSH
99345: LD_INT 4
99347: ST_TO_ADDR
// animal := CreateVehicle ;
99348: LD_ADDR_VAR 0 12
99352: PUSH
99353: CALL_OW 45
99357: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99358: LD_VAR 0 12
99362: PPUSH
99363: LD_VAR 0 8
99367: PPUSH
99368: LD_INT 0
99370: PPUSH
99371: CALL 101514 0 3
// end ;
99375: GO 99329
99377: POP
99378: POP
// if horses then
99379: LD_VAR 0 5
99383: IFFALSE 99450
// for i = 1 to horses do
99385: LD_ADDR_VAR 0 11
99389: PUSH
99390: DOUBLE
99391: LD_INT 1
99393: DEC
99394: ST_TO_ADDR
99395: LD_VAR 0 5
99399: PUSH
99400: FOR_TO
99401: IFFALSE 99448
// begin hc_class := 21 ;
99403: LD_ADDR_OWVAR 28
99407: PUSH
99408: LD_INT 21
99410: ST_TO_ADDR
// hc_gallery :=  ;
99411: LD_ADDR_OWVAR 33
99415: PUSH
99416: LD_STRING 
99418: ST_TO_ADDR
// animal := CreateHuman ;
99419: LD_ADDR_VAR 0 12
99423: PUSH
99424: CALL_OW 44
99428: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99429: LD_VAR 0 12
99433: PPUSH
99434: LD_VAR 0 8
99438: PPUSH
99439: LD_INT 0
99441: PPUSH
99442: CALL 101514 0 3
// end ;
99446: GO 99400
99448: POP
99449: POP
// if birds then
99450: LD_VAR 0 1
99454: IFFALSE 99521
// for i = 1 to birds do
99456: LD_ADDR_VAR 0 11
99460: PUSH
99461: DOUBLE
99462: LD_INT 1
99464: DEC
99465: ST_TO_ADDR
99466: LD_VAR 0 1
99470: PUSH
99471: FOR_TO
99472: IFFALSE 99519
// begin hc_class = 18 ;
99474: LD_ADDR_OWVAR 28
99478: PUSH
99479: LD_INT 18
99481: ST_TO_ADDR
// hc_gallery =  ;
99482: LD_ADDR_OWVAR 33
99486: PUSH
99487: LD_STRING 
99489: ST_TO_ADDR
// animal := CreateHuman ;
99490: LD_ADDR_VAR 0 12
99494: PUSH
99495: CALL_OW 44
99499: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99500: LD_VAR 0 12
99504: PPUSH
99505: LD_VAR 0 8
99509: PPUSH
99510: LD_INT 0
99512: PPUSH
99513: CALL 101514 0 3
// end ;
99517: GO 99471
99519: POP
99520: POP
// if tigers then
99521: LD_VAR 0 2
99525: IFFALSE 99609
// for i = 1 to tigers do
99527: LD_ADDR_VAR 0 11
99531: PUSH
99532: DOUBLE
99533: LD_INT 1
99535: DEC
99536: ST_TO_ADDR
99537: LD_VAR 0 2
99541: PUSH
99542: FOR_TO
99543: IFFALSE 99607
// begin hc_class = class_tiger ;
99545: LD_ADDR_OWVAR 28
99549: PUSH
99550: LD_INT 14
99552: ST_TO_ADDR
// hc_gallery =  ;
99553: LD_ADDR_OWVAR 33
99557: PUSH
99558: LD_STRING 
99560: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99561: LD_ADDR_OWVAR 35
99565: PUSH
99566: LD_INT 7
99568: NEG
99569: PPUSH
99570: LD_INT 7
99572: PPUSH
99573: CALL_OW 12
99577: ST_TO_ADDR
// animal := CreateHuman ;
99578: LD_ADDR_VAR 0 12
99582: PUSH
99583: CALL_OW 44
99587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99588: LD_VAR 0 12
99592: PPUSH
99593: LD_VAR 0 8
99597: PPUSH
99598: LD_INT 0
99600: PPUSH
99601: CALL 101514 0 3
// end ;
99605: GO 99542
99607: POP
99608: POP
// if apemans then
99609: LD_VAR 0 3
99613: IFFALSE 99736
// for i = 1 to apemans do
99615: LD_ADDR_VAR 0 11
99619: PUSH
99620: DOUBLE
99621: LD_INT 1
99623: DEC
99624: ST_TO_ADDR
99625: LD_VAR 0 3
99629: PUSH
99630: FOR_TO
99631: IFFALSE 99734
// begin hc_class = class_apeman ;
99633: LD_ADDR_OWVAR 28
99637: PUSH
99638: LD_INT 12
99640: ST_TO_ADDR
// hc_gallery =  ;
99641: LD_ADDR_OWVAR 33
99645: PUSH
99646: LD_STRING 
99648: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99649: LD_ADDR_OWVAR 35
99653: PUSH
99654: LD_INT 2
99656: NEG
99657: PPUSH
99658: LD_INT 2
99660: PPUSH
99661: CALL_OW 12
99665: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99666: LD_ADDR_OWVAR 31
99670: PUSH
99671: LD_INT 1
99673: PPUSH
99674: LD_INT 3
99676: PPUSH
99677: CALL_OW 12
99681: PUSH
99682: LD_INT 1
99684: PPUSH
99685: LD_INT 3
99687: PPUSH
99688: CALL_OW 12
99692: PUSH
99693: LD_INT 0
99695: PUSH
99696: LD_INT 0
99698: PUSH
99699: EMPTY
99700: LIST
99701: LIST
99702: LIST
99703: LIST
99704: ST_TO_ADDR
// animal := CreateHuman ;
99705: LD_ADDR_VAR 0 12
99709: PUSH
99710: CALL_OW 44
99714: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99715: LD_VAR 0 12
99719: PPUSH
99720: LD_VAR 0 8
99724: PPUSH
99725: LD_INT 0
99727: PPUSH
99728: CALL 101514 0 3
// end ;
99732: GO 99630
99734: POP
99735: POP
// if enchidnas then
99736: LD_VAR 0 4
99740: IFFALSE 99807
// for i = 1 to enchidnas do
99742: LD_ADDR_VAR 0 11
99746: PUSH
99747: DOUBLE
99748: LD_INT 1
99750: DEC
99751: ST_TO_ADDR
99752: LD_VAR 0 4
99756: PUSH
99757: FOR_TO
99758: IFFALSE 99805
// begin hc_class = 13 ;
99760: LD_ADDR_OWVAR 28
99764: PUSH
99765: LD_INT 13
99767: ST_TO_ADDR
// hc_gallery =  ;
99768: LD_ADDR_OWVAR 33
99772: PUSH
99773: LD_STRING 
99775: ST_TO_ADDR
// animal := CreateHuman ;
99776: LD_ADDR_VAR 0 12
99780: PUSH
99781: CALL_OW 44
99785: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99786: LD_VAR 0 12
99790: PPUSH
99791: LD_VAR 0 8
99795: PPUSH
99796: LD_INT 0
99798: PPUSH
99799: CALL 101514 0 3
// end ;
99803: GO 99757
99805: POP
99806: POP
// if fishes then
99807: LD_VAR 0 7
99811: IFFALSE 99878
// for i = 1 to fishes do
99813: LD_ADDR_VAR 0 11
99817: PUSH
99818: DOUBLE
99819: LD_INT 1
99821: DEC
99822: ST_TO_ADDR
99823: LD_VAR 0 7
99827: PUSH
99828: FOR_TO
99829: IFFALSE 99876
// begin hc_class = 20 ;
99831: LD_ADDR_OWVAR 28
99835: PUSH
99836: LD_INT 20
99838: ST_TO_ADDR
// hc_gallery =  ;
99839: LD_ADDR_OWVAR 33
99843: PUSH
99844: LD_STRING 
99846: ST_TO_ADDR
// animal := CreateHuman ;
99847: LD_ADDR_VAR 0 12
99851: PUSH
99852: CALL_OW 44
99856: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99857: LD_VAR 0 12
99861: PPUSH
99862: LD_VAR 0 9
99866: PPUSH
99867: LD_INT 0
99869: PPUSH
99870: CALL 101514 0 3
// end ;
99874: GO 99828
99876: POP
99877: POP
// end ;
99878: LD_VAR 0 10
99882: RET
// export function WantHeal ( sci , unit ) ; begin
99883: LD_INT 0
99885: PPUSH
// if GetTaskList ( sci ) > 0 then
99886: LD_VAR 0 1
99890: PPUSH
99891: CALL_OW 437
99895: PUSH
99896: LD_INT 0
99898: GREATER
99899: IFFALSE 99969
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99901: LD_VAR 0 1
99905: PPUSH
99906: CALL_OW 437
99910: PUSH
99911: LD_INT 1
99913: ARRAY
99914: PUSH
99915: LD_INT 1
99917: ARRAY
99918: PUSH
99919: LD_STRING l
99921: EQUAL
99922: PUSH
99923: LD_VAR 0 1
99927: PPUSH
99928: CALL_OW 437
99932: PUSH
99933: LD_INT 1
99935: ARRAY
99936: PUSH
99937: LD_INT 4
99939: ARRAY
99940: PUSH
99941: LD_VAR 0 2
99945: EQUAL
99946: AND
99947: IFFALSE 99959
// result := true else
99949: LD_ADDR_VAR 0 3
99953: PUSH
99954: LD_INT 1
99956: ST_TO_ADDR
99957: GO 99967
// result := false ;
99959: LD_ADDR_VAR 0 3
99963: PUSH
99964: LD_INT 0
99966: ST_TO_ADDR
// end else
99967: GO 99977
// result := false ;
99969: LD_ADDR_VAR 0 3
99973: PUSH
99974: LD_INT 0
99976: ST_TO_ADDR
// end ;
99977: LD_VAR 0 3
99981: RET
// export function HealTarget ( sci ) ; begin
99982: LD_INT 0
99984: PPUSH
// if not sci then
99985: LD_VAR 0 1
99989: NOT
99990: IFFALSE 99994
// exit ;
99992: GO 100059
// result := 0 ;
99994: LD_ADDR_VAR 0 2
99998: PUSH
99999: LD_INT 0
100001: ST_TO_ADDR
// if GetTaskList ( sci ) then
100002: LD_VAR 0 1
100006: PPUSH
100007: CALL_OW 437
100011: IFFALSE 100059
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100013: LD_VAR 0 1
100017: PPUSH
100018: CALL_OW 437
100022: PUSH
100023: LD_INT 1
100025: ARRAY
100026: PUSH
100027: LD_INT 1
100029: ARRAY
100030: PUSH
100031: LD_STRING l
100033: EQUAL
100034: IFFALSE 100059
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100036: LD_ADDR_VAR 0 2
100040: PUSH
100041: LD_VAR 0 1
100045: PPUSH
100046: CALL_OW 437
100050: PUSH
100051: LD_INT 1
100053: ARRAY
100054: PUSH
100055: LD_INT 4
100057: ARRAY
100058: ST_TO_ADDR
// end ;
100059: LD_VAR 0 2
100063: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100064: LD_INT 0
100066: PPUSH
100067: PPUSH
100068: PPUSH
100069: PPUSH
// if not base_units then
100070: LD_VAR 0 1
100074: NOT
100075: IFFALSE 100079
// exit ;
100077: GO 100166
// result := false ;
100079: LD_ADDR_VAR 0 2
100083: PUSH
100084: LD_INT 0
100086: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100087: LD_ADDR_VAR 0 5
100091: PUSH
100092: LD_VAR 0 1
100096: PPUSH
100097: LD_INT 21
100099: PUSH
100100: LD_INT 3
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PPUSH
100107: CALL_OW 72
100111: ST_TO_ADDR
// if not tmp then
100112: LD_VAR 0 5
100116: NOT
100117: IFFALSE 100121
// exit ;
100119: GO 100166
// for i in tmp do
100121: LD_ADDR_VAR 0 3
100125: PUSH
100126: LD_VAR 0 5
100130: PUSH
100131: FOR_IN
100132: IFFALSE 100164
// begin result := EnemyInRange ( i , 22 ) ;
100134: LD_ADDR_VAR 0 2
100138: PUSH
100139: LD_VAR 0 3
100143: PPUSH
100144: LD_INT 22
100146: PPUSH
100147: CALL 98402 0 2
100151: ST_TO_ADDR
// if result then
100152: LD_VAR 0 2
100156: IFFALSE 100162
// exit ;
100158: POP
100159: POP
100160: GO 100166
// end ;
100162: GO 100131
100164: POP
100165: POP
// end ;
100166: LD_VAR 0 2
100170: RET
// export function FilterByTag ( units , tag ) ; begin
100171: LD_INT 0
100173: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
100174: LD_ADDR_VAR 0 3
100178: PUSH
100179: LD_VAR 0 1
100183: PPUSH
100184: LD_INT 120
100186: PUSH
100187: LD_VAR 0 2
100191: PUSH
100192: EMPTY
100193: LIST
100194: LIST
100195: PPUSH
100196: CALL_OW 72
100200: ST_TO_ADDR
// end ;
100201: LD_VAR 0 3
100205: RET
// export function IsDriver ( un ) ; begin
100206: LD_INT 0
100208: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100209: LD_ADDR_VAR 0 2
100213: PUSH
100214: LD_VAR 0 1
100218: PUSH
100219: LD_INT 55
100221: PUSH
100222: EMPTY
100223: LIST
100224: PPUSH
100225: CALL_OW 69
100229: IN
100230: ST_TO_ADDR
// end ;
100231: LD_VAR 0 2
100235: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100236: LD_INT 0
100238: PPUSH
100239: PPUSH
// list := [ ] ;
100240: LD_ADDR_VAR 0 5
100244: PUSH
100245: EMPTY
100246: ST_TO_ADDR
// case d of 0 :
100247: LD_VAR 0 3
100251: PUSH
100252: LD_INT 0
100254: DOUBLE
100255: EQUAL
100256: IFTRUE 100260
100258: GO 100393
100260: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100261: LD_ADDR_VAR 0 5
100265: PUSH
100266: LD_VAR 0 1
100270: PUSH
100271: LD_INT 4
100273: MINUS
100274: PUSH
100275: LD_VAR 0 2
100279: PUSH
100280: LD_INT 4
100282: MINUS
100283: PUSH
100284: LD_INT 2
100286: PUSH
100287: EMPTY
100288: LIST
100289: LIST
100290: LIST
100291: PUSH
100292: LD_VAR 0 1
100296: PUSH
100297: LD_INT 3
100299: MINUS
100300: PUSH
100301: LD_VAR 0 2
100305: PUSH
100306: LD_INT 1
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: LIST
100313: PUSH
100314: LD_VAR 0 1
100318: PUSH
100319: LD_INT 4
100321: PLUS
100322: PUSH
100323: LD_VAR 0 2
100327: PUSH
100328: LD_INT 4
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: LIST
100335: PUSH
100336: LD_VAR 0 1
100340: PUSH
100341: LD_INT 3
100343: PLUS
100344: PUSH
100345: LD_VAR 0 2
100349: PUSH
100350: LD_INT 3
100352: PLUS
100353: PUSH
100354: LD_INT 5
100356: PUSH
100357: EMPTY
100358: LIST
100359: LIST
100360: LIST
100361: PUSH
100362: LD_VAR 0 1
100366: PUSH
100367: LD_VAR 0 2
100371: PUSH
100372: LD_INT 4
100374: PLUS
100375: PUSH
100376: LD_INT 0
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: LIST
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: LIST
100388: LIST
100389: LIST
100390: ST_TO_ADDR
// end ; 1 :
100391: GO 101091
100393: LD_INT 1
100395: DOUBLE
100396: EQUAL
100397: IFTRUE 100401
100399: GO 100534
100401: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100402: LD_ADDR_VAR 0 5
100406: PUSH
100407: LD_VAR 0 1
100411: PUSH
100412: LD_VAR 0 2
100416: PUSH
100417: LD_INT 4
100419: MINUS
100420: PUSH
100421: LD_INT 3
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: LIST
100428: PUSH
100429: LD_VAR 0 1
100433: PUSH
100434: LD_INT 3
100436: MINUS
100437: PUSH
100438: LD_VAR 0 2
100442: PUSH
100443: LD_INT 3
100445: MINUS
100446: PUSH
100447: LD_INT 2
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: LIST
100454: PUSH
100455: LD_VAR 0 1
100459: PUSH
100460: LD_INT 4
100462: MINUS
100463: PUSH
100464: LD_VAR 0 2
100468: PUSH
100469: LD_INT 1
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: LIST
100476: PUSH
100477: LD_VAR 0 1
100481: PUSH
100482: LD_VAR 0 2
100486: PUSH
100487: LD_INT 3
100489: PLUS
100490: PUSH
100491: LD_INT 0
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: LIST
100498: PUSH
100499: LD_VAR 0 1
100503: PUSH
100504: LD_INT 4
100506: PLUS
100507: PUSH
100508: LD_VAR 0 2
100512: PUSH
100513: LD_INT 4
100515: PLUS
100516: PUSH
100517: LD_INT 5
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: LIST
100524: PUSH
100525: EMPTY
100526: LIST
100527: LIST
100528: LIST
100529: LIST
100530: LIST
100531: ST_TO_ADDR
// end ; 2 :
100532: GO 101091
100534: LD_INT 2
100536: DOUBLE
100537: EQUAL
100538: IFTRUE 100542
100540: GO 100671
100542: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100543: LD_ADDR_VAR 0 5
100547: PUSH
100548: LD_VAR 0 1
100552: PUSH
100553: LD_VAR 0 2
100557: PUSH
100558: LD_INT 3
100560: MINUS
100561: PUSH
100562: LD_INT 3
100564: PUSH
100565: EMPTY
100566: LIST
100567: LIST
100568: LIST
100569: PUSH
100570: LD_VAR 0 1
100574: PUSH
100575: LD_INT 4
100577: PLUS
100578: PUSH
100579: LD_VAR 0 2
100583: PUSH
100584: LD_INT 4
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: LIST
100591: PUSH
100592: LD_VAR 0 1
100596: PUSH
100597: LD_VAR 0 2
100601: PUSH
100602: LD_INT 4
100604: PLUS
100605: PUSH
100606: LD_INT 0
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: LIST
100613: PUSH
100614: LD_VAR 0 1
100618: PUSH
100619: LD_INT 3
100621: MINUS
100622: PUSH
100623: LD_VAR 0 2
100627: PUSH
100628: LD_INT 1
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: LIST
100635: PUSH
100636: LD_VAR 0 1
100640: PUSH
100641: LD_INT 4
100643: MINUS
100644: PUSH
100645: LD_VAR 0 2
100649: PUSH
100650: LD_INT 4
100652: MINUS
100653: PUSH
100654: LD_INT 2
100656: PUSH
100657: EMPTY
100658: LIST
100659: LIST
100660: LIST
100661: PUSH
100662: EMPTY
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: ST_TO_ADDR
// end ; 3 :
100669: GO 101091
100671: LD_INT 3
100673: DOUBLE
100674: EQUAL
100675: IFTRUE 100679
100677: GO 100812
100679: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100680: LD_ADDR_VAR 0 5
100684: PUSH
100685: LD_VAR 0 1
100689: PUSH
100690: LD_INT 3
100692: PLUS
100693: PUSH
100694: LD_VAR 0 2
100698: PUSH
100699: LD_INT 4
100701: PUSH
100702: EMPTY
100703: LIST
100704: LIST
100705: LIST
100706: PUSH
100707: LD_VAR 0 1
100711: PUSH
100712: LD_INT 4
100714: PLUS
100715: PUSH
100716: LD_VAR 0 2
100720: PUSH
100721: LD_INT 4
100723: PLUS
100724: PUSH
100725: LD_INT 5
100727: PUSH
100728: EMPTY
100729: LIST
100730: LIST
100731: LIST
100732: PUSH
100733: LD_VAR 0 1
100737: PUSH
100738: LD_INT 4
100740: MINUS
100741: PUSH
100742: LD_VAR 0 2
100746: PUSH
100747: LD_INT 1
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: LIST
100754: PUSH
100755: LD_VAR 0 1
100759: PUSH
100760: LD_VAR 0 2
100764: PUSH
100765: LD_INT 4
100767: MINUS
100768: PUSH
100769: LD_INT 3
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: LIST
100776: PUSH
100777: LD_VAR 0 1
100781: PUSH
100782: LD_INT 3
100784: MINUS
100785: PUSH
100786: LD_VAR 0 2
100790: PUSH
100791: LD_INT 3
100793: MINUS
100794: PUSH
100795: LD_INT 2
100797: PUSH
100798: EMPTY
100799: LIST
100800: LIST
100801: LIST
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: LIST
100807: LIST
100808: LIST
100809: ST_TO_ADDR
// end ; 4 :
100810: GO 101091
100812: LD_INT 4
100814: DOUBLE
100815: EQUAL
100816: IFTRUE 100820
100818: GO 100953
100820: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100821: LD_ADDR_VAR 0 5
100825: PUSH
100826: LD_VAR 0 1
100830: PUSH
100831: LD_VAR 0 2
100835: PUSH
100836: LD_INT 4
100838: PLUS
100839: PUSH
100840: LD_INT 0
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: LIST
100847: PUSH
100848: LD_VAR 0 1
100852: PUSH
100853: LD_INT 3
100855: PLUS
100856: PUSH
100857: LD_VAR 0 2
100861: PUSH
100862: LD_INT 3
100864: PLUS
100865: PUSH
100866: LD_INT 5
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: LIST
100873: PUSH
100874: LD_VAR 0 1
100878: PUSH
100879: LD_INT 4
100881: PLUS
100882: PUSH
100883: LD_VAR 0 2
100887: PUSH
100888: LD_INT 4
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: LIST
100895: PUSH
100896: LD_VAR 0 1
100900: PUSH
100901: LD_VAR 0 2
100905: PUSH
100906: LD_INT 3
100908: MINUS
100909: PUSH
100910: LD_INT 3
100912: PUSH
100913: EMPTY
100914: LIST
100915: LIST
100916: LIST
100917: PUSH
100918: LD_VAR 0 1
100922: PUSH
100923: LD_INT 4
100925: MINUS
100926: PUSH
100927: LD_VAR 0 2
100931: PUSH
100932: LD_INT 4
100934: MINUS
100935: PUSH
100936: LD_INT 2
100938: PUSH
100939: EMPTY
100940: LIST
100941: LIST
100942: LIST
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: LIST
100948: LIST
100949: LIST
100950: ST_TO_ADDR
// end ; 5 :
100951: GO 101091
100953: LD_INT 5
100955: DOUBLE
100956: EQUAL
100957: IFTRUE 100961
100959: GO 101090
100961: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100962: LD_ADDR_VAR 0 5
100966: PUSH
100967: LD_VAR 0 1
100971: PUSH
100972: LD_INT 4
100974: MINUS
100975: PUSH
100976: LD_VAR 0 2
100980: PUSH
100981: LD_INT 1
100983: PUSH
100984: EMPTY
100985: LIST
100986: LIST
100987: LIST
100988: PUSH
100989: LD_VAR 0 1
100993: PUSH
100994: LD_VAR 0 2
100998: PUSH
100999: LD_INT 4
101001: MINUS
101002: PUSH
101003: LD_INT 3
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: LIST
101010: PUSH
101011: LD_VAR 0 1
101015: PUSH
101016: LD_INT 4
101018: PLUS
101019: PUSH
101020: LD_VAR 0 2
101024: PUSH
101025: LD_INT 4
101027: PLUS
101028: PUSH
101029: LD_INT 5
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: LIST
101036: PUSH
101037: LD_VAR 0 1
101041: PUSH
101042: LD_INT 3
101044: PLUS
101045: PUSH
101046: LD_VAR 0 2
101050: PUSH
101051: LD_INT 4
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: LIST
101058: PUSH
101059: LD_VAR 0 1
101063: PUSH
101064: LD_VAR 0 2
101068: PUSH
101069: LD_INT 3
101071: PLUS
101072: PUSH
101073: LD_INT 0
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: LIST
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: LIST
101085: LIST
101086: LIST
101087: ST_TO_ADDR
// end ; end ;
101088: GO 101091
101090: POP
// result := list ;
101091: LD_ADDR_VAR 0 4
101095: PUSH
101096: LD_VAR 0 5
101100: ST_TO_ADDR
// end ;
101101: LD_VAR 0 4
101105: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101106: LD_INT 0
101108: PPUSH
101109: PPUSH
101110: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101111: LD_VAR 0 1
101115: NOT
101116: PUSH
101117: LD_VAR 0 2
101121: PUSH
101122: LD_INT 1
101124: PUSH
101125: LD_INT 2
101127: PUSH
101128: LD_INT 3
101130: PUSH
101131: LD_INT 4
101133: PUSH
101134: EMPTY
101135: LIST
101136: LIST
101137: LIST
101138: LIST
101139: IN
101140: NOT
101141: OR
101142: IFFALSE 101146
// exit ;
101144: GO 101238
// tmp := [ ] ;
101146: LD_ADDR_VAR 0 5
101150: PUSH
101151: EMPTY
101152: ST_TO_ADDR
// for i in units do
101153: LD_ADDR_VAR 0 4
101157: PUSH
101158: LD_VAR 0 1
101162: PUSH
101163: FOR_IN
101164: IFFALSE 101207
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101166: LD_ADDR_VAR 0 5
101170: PUSH
101171: LD_VAR 0 5
101175: PPUSH
101176: LD_VAR 0 5
101180: PUSH
101181: LD_INT 1
101183: PLUS
101184: PPUSH
101185: LD_VAR 0 4
101189: PPUSH
101190: LD_VAR 0 2
101194: PPUSH
101195: CALL_OW 259
101199: PPUSH
101200: CALL_OW 2
101204: ST_TO_ADDR
101205: GO 101163
101207: POP
101208: POP
// if not tmp then
101209: LD_VAR 0 5
101213: NOT
101214: IFFALSE 101218
// exit ;
101216: GO 101238
// result := SortListByListDesc ( units , tmp ) ;
101218: LD_ADDR_VAR 0 3
101222: PUSH
101223: LD_VAR 0 1
101227: PPUSH
101228: LD_VAR 0 5
101232: PPUSH
101233: CALL_OW 77
101237: ST_TO_ADDR
// end ;
101238: LD_VAR 0 3
101242: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101243: LD_INT 0
101245: PPUSH
101246: PPUSH
101247: PPUSH
// result := false ;
101248: LD_ADDR_VAR 0 3
101252: PUSH
101253: LD_INT 0
101255: ST_TO_ADDR
// x := GetX ( building ) ;
101256: LD_ADDR_VAR 0 4
101260: PUSH
101261: LD_VAR 0 2
101265: PPUSH
101266: CALL_OW 250
101270: ST_TO_ADDR
// y := GetY ( building ) ;
101271: LD_ADDR_VAR 0 5
101275: PUSH
101276: LD_VAR 0 2
101280: PPUSH
101281: CALL_OW 251
101285: ST_TO_ADDR
// if not building or not x or not y then
101286: LD_VAR 0 2
101290: NOT
101291: PUSH
101292: LD_VAR 0 4
101296: NOT
101297: OR
101298: PUSH
101299: LD_VAR 0 5
101303: NOT
101304: OR
101305: IFFALSE 101309
// exit ;
101307: GO 101401
// if GetTaskList ( unit ) then
101309: LD_VAR 0 1
101313: PPUSH
101314: CALL_OW 437
101318: IFFALSE 101401
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101320: LD_STRING e
101322: PUSH
101323: LD_VAR 0 1
101327: PPUSH
101328: CALL_OW 437
101332: PUSH
101333: LD_INT 1
101335: ARRAY
101336: PUSH
101337: LD_INT 1
101339: ARRAY
101340: EQUAL
101341: PUSH
101342: LD_VAR 0 4
101346: PUSH
101347: LD_VAR 0 1
101351: PPUSH
101352: CALL_OW 437
101356: PUSH
101357: LD_INT 1
101359: ARRAY
101360: PUSH
101361: LD_INT 2
101363: ARRAY
101364: EQUAL
101365: AND
101366: PUSH
101367: LD_VAR 0 5
101371: PUSH
101372: LD_VAR 0 1
101376: PPUSH
101377: CALL_OW 437
101381: PUSH
101382: LD_INT 1
101384: ARRAY
101385: PUSH
101386: LD_INT 3
101388: ARRAY
101389: EQUAL
101390: AND
101391: IFFALSE 101401
// result := true end ;
101393: LD_ADDR_VAR 0 3
101397: PUSH
101398: LD_INT 1
101400: ST_TO_ADDR
// end ;
101401: LD_VAR 0 3
101405: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101406: LD_INT 0
101408: PPUSH
// result := false ;
101409: LD_ADDR_VAR 0 4
101413: PUSH
101414: LD_INT 0
101416: ST_TO_ADDR
// if GetTaskList ( unit ) then
101417: LD_VAR 0 1
101421: PPUSH
101422: CALL_OW 437
101426: IFFALSE 101509
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101428: LD_STRING M
101430: PUSH
101431: LD_VAR 0 1
101435: PPUSH
101436: CALL_OW 437
101440: PUSH
101441: LD_INT 1
101443: ARRAY
101444: PUSH
101445: LD_INT 1
101447: ARRAY
101448: EQUAL
101449: PUSH
101450: LD_VAR 0 2
101454: PUSH
101455: LD_VAR 0 1
101459: PPUSH
101460: CALL_OW 437
101464: PUSH
101465: LD_INT 1
101467: ARRAY
101468: PUSH
101469: LD_INT 2
101471: ARRAY
101472: EQUAL
101473: AND
101474: PUSH
101475: LD_VAR 0 3
101479: PUSH
101480: LD_VAR 0 1
101484: PPUSH
101485: CALL_OW 437
101489: PUSH
101490: LD_INT 1
101492: ARRAY
101493: PUSH
101494: LD_INT 3
101496: ARRAY
101497: EQUAL
101498: AND
101499: IFFALSE 101509
// result := true ;
101501: LD_ADDR_VAR 0 4
101505: PUSH
101506: LD_INT 1
101508: ST_TO_ADDR
// end ; end ;
101509: LD_VAR 0 4
101513: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101514: LD_INT 0
101516: PPUSH
101517: PPUSH
101518: PPUSH
101519: PPUSH
// if not unit or not area then
101520: LD_VAR 0 1
101524: NOT
101525: PUSH
101526: LD_VAR 0 2
101530: NOT
101531: OR
101532: IFFALSE 101536
// exit ;
101534: GO 101700
// tmp := AreaToList ( area , i ) ;
101536: LD_ADDR_VAR 0 6
101540: PUSH
101541: LD_VAR 0 2
101545: PPUSH
101546: LD_VAR 0 5
101550: PPUSH
101551: CALL_OW 517
101555: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101556: LD_ADDR_VAR 0 5
101560: PUSH
101561: DOUBLE
101562: LD_INT 1
101564: DEC
101565: ST_TO_ADDR
101566: LD_VAR 0 6
101570: PUSH
101571: LD_INT 1
101573: ARRAY
101574: PUSH
101575: FOR_TO
101576: IFFALSE 101698
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101578: LD_ADDR_VAR 0 7
101582: PUSH
101583: LD_VAR 0 6
101587: PUSH
101588: LD_INT 1
101590: ARRAY
101591: PUSH
101592: LD_VAR 0 5
101596: ARRAY
101597: PUSH
101598: LD_VAR 0 6
101602: PUSH
101603: LD_INT 2
101605: ARRAY
101606: PUSH
101607: LD_VAR 0 5
101611: ARRAY
101612: PUSH
101613: EMPTY
101614: LIST
101615: LIST
101616: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101617: LD_VAR 0 7
101621: PUSH
101622: LD_INT 1
101624: ARRAY
101625: PPUSH
101626: LD_VAR 0 7
101630: PUSH
101631: LD_INT 2
101633: ARRAY
101634: PPUSH
101635: CALL_OW 428
101639: PUSH
101640: LD_INT 0
101642: EQUAL
101643: IFFALSE 101696
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101645: LD_VAR 0 1
101649: PPUSH
101650: LD_VAR 0 7
101654: PUSH
101655: LD_INT 1
101657: ARRAY
101658: PPUSH
101659: LD_VAR 0 7
101663: PUSH
101664: LD_INT 2
101666: ARRAY
101667: PPUSH
101668: LD_VAR 0 3
101672: PPUSH
101673: CALL_OW 48
// result := IsPlaced ( unit ) ;
101677: LD_ADDR_VAR 0 4
101681: PUSH
101682: LD_VAR 0 1
101686: PPUSH
101687: CALL_OW 305
101691: ST_TO_ADDR
// exit ;
101692: POP
101693: POP
101694: GO 101700
// end ; end ;
101696: GO 101575
101698: POP
101699: POP
// end ;
101700: LD_VAR 0 4
101704: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101705: LD_INT 0
101707: PPUSH
101708: PPUSH
101709: PPUSH
// if not side or side > 8 then
101710: LD_VAR 0 1
101714: NOT
101715: PUSH
101716: LD_VAR 0 1
101720: PUSH
101721: LD_INT 8
101723: GREATER
101724: OR
101725: IFFALSE 101729
// exit ;
101727: GO 101916
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101729: LD_ADDR_VAR 0 4
101733: PUSH
101734: LD_INT 22
101736: PUSH
101737: LD_VAR 0 1
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: PUSH
101746: LD_INT 21
101748: PUSH
101749: LD_INT 3
101751: PUSH
101752: EMPTY
101753: LIST
101754: LIST
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PPUSH
101760: CALL_OW 69
101764: ST_TO_ADDR
// if not tmp then
101765: LD_VAR 0 4
101769: NOT
101770: IFFALSE 101774
// exit ;
101772: GO 101916
// enable_addtolog := true ;
101774: LD_ADDR_OWVAR 81
101778: PUSH
101779: LD_INT 1
101781: ST_TO_ADDR
// AddToLog ( [ ) ;
101782: LD_STRING [
101784: PPUSH
101785: CALL_OW 561
// for i in tmp do
101789: LD_ADDR_VAR 0 3
101793: PUSH
101794: LD_VAR 0 4
101798: PUSH
101799: FOR_IN
101800: IFFALSE 101907
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101802: LD_STRING [
101804: PUSH
101805: LD_VAR 0 3
101809: PPUSH
101810: CALL_OW 266
101814: STR
101815: PUSH
101816: LD_STRING , 
101818: STR
101819: PUSH
101820: LD_VAR 0 3
101824: PPUSH
101825: CALL_OW 250
101829: STR
101830: PUSH
101831: LD_STRING , 
101833: STR
101834: PUSH
101835: LD_VAR 0 3
101839: PPUSH
101840: CALL_OW 251
101844: STR
101845: PUSH
101846: LD_STRING , 
101848: STR
101849: PUSH
101850: LD_VAR 0 3
101854: PPUSH
101855: CALL_OW 254
101859: STR
101860: PUSH
101861: LD_STRING , 
101863: STR
101864: PUSH
101865: LD_VAR 0 3
101869: PPUSH
101870: LD_INT 1
101872: PPUSH
101873: CALL_OW 268
101877: STR
101878: PUSH
101879: LD_STRING , 
101881: STR
101882: PUSH
101883: LD_VAR 0 3
101887: PPUSH
101888: LD_INT 2
101890: PPUSH
101891: CALL_OW 268
101895: STR
101896: PUSH
101897: LD_STRING ],
101899: STR
101900: PPUSH
101901: CALL_OW 561
// end ;
101905: GO 101799
101907: POP
101908: POP
// AddToLog ( ]; ) ;
101909: LD_STRING ];
101911: PPUSH
101912: CALL_OW 561
// end ;
101916: LD_VAR 0 2
101920: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101921: LD_INT 0
101923: PPUSH
101924: PPUSH
101925: PPUSH
101926: PPUSH
101927: PPUSH
// if not area or not rate or not max then
101928: LD_VAR 0 1
101932: NOT
101933: PUSH
101934: LD_VAR 0 2
101938: NOT
101939: OR
101940: PUSH
101941: LD_VAR 0 4
101945: NOT
101946: OR
101947: IFFALSE 101951
// exit ;
101949: GO 102140
// while 1 do
101951: LD_INT 1
101953: IFFALSE 102140
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101955: LD_ADDR_VAR 0 9
101959: PUSH
101960: LD_VAR 0 1
101964: PPUSH
101965: LD_INT 1
101967: PPUSH
101968: CALL_OW 287
101972: PUSH
101973: LD_INT 10
101975: MUL
101976: ST_TO_ADDR
// r := rate / 10 ;
101977: LD_ADDR_VAR 0 7
101981: PUSH
101982: LD_VAR 0 2
101986: PUSH
101987: LD_INT 10
101989: DIVREAL
101990: ST_TO_ADDR
// time := 1 1$00 ;
101991: LD_ADDR_VAR 0 8
101995: PUSH
101996: LD_INT 2100
101998: ST_TO_ADDR
// if amount < min then
101999: LD_VAR 0 9
102003: PUSH
102004: LD_VAR 0 3
102008: LESS
102009: IFFALSE 102027
// r := r * 2 else
102011: LD_ADDR_VAR 0 7
102015: PUSH
102016: LD_VAR 0 7
102020: PUSH
102021: LD_INT 2
102023: MUL
102024: ST_TO_ADDR
102025: GO 102053
// if amount > max then
102027: LD_VAR 0 9
102031: PUSH
102032: LD_VAR 0 4
102036: GREATER
102037: IFFALSE 102053
// r := r / 2 ;
102039: LD_ADDR_VAR 0 7
102043: PUSH
102044: LD_VAR 0 7
102048: PUSH
102049: LD_INT 2
102051: DIVREAL
102052: ST_TO_ADDR
// time := time / r ;
102053: LD_ADDR_VAR 0 8
102057: PUSH
102058: LD_VAR 0 8
102062: PUSH
102063: LD_VAR 0 7
102067: DIVREAL
102068: ST_TO_ADDR
// if time < 0 then
102069: LD_VAR 0 8
102073: PUSH
102074: LD_INT 0
102076: LESS
102077: IFFALSE 102094
// time := time * - 1 ;
102079: LD_ADDR_VAR 0 8
102083: PUSH
102084: LD_VAR 0 8
102088: PUSH
102089: LD_INT 1
102091: NEG
102092: MUL
102093: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
102094: LD_VAR 0 8
102098: PUSH
102099: LD_INT 35
102101: PPUSH
102102: LD_INT 875
102104: PPUSH
102105: CALL_OW 12
102109: PLUS
102110: PPUSH
102111: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102115: LD_INT 1
102117: PPUSH
102118: LD_INT 5
102120: PPUSH
102121: CALL_OW 12
102125: PPUSH
102126: LD_VAR 0 1
102130: PPUSH
102131: LD_INT 1
102133: PPUSH
102134: CALL_OW 55
// end ;
102138: GO 101951
// end ;
102140: LD_VAR 0 5
102144: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102145: LD_INT 0
102147: PPUSH
102148: PPUSH
102149: PPUSH
102150: PPUSH
102151: PPUSH
102152: PPUSH
102153: PPUSH
102154: PPUSH
// if not turrets or not factories then
102155: LD_VAR 0 1
102159: NOT
102160: PUSH
102161: LD_VAR 0 2
102165: NOT
102166: OR
102167: IFFALSE 102171
// exit ;
102169: GO 102478
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102171: LD_ADDR_VAR 0 10
102175: PUSH
102176: LD_INT 5
102178: PUSH
102179: LD_INT 6
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: PUSH
102186: LD_INT 2
102188: PUSH
102189: LD_INT 4
102191: PUSH
102192: EMPTY
102193: LIST
102194: LIST
102195: PUSH
102196: LD_INT 3
102198: PUSH
102199: LD_INT 5
102201: PUSH
102202: EMPTY
102203: LIST
102204: LIST
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: LIST
102210: PUSH
102211: LD_INT 24
102213: PUSH
102214: LD_INT 25
102216: PUSH
102217: EMPTY
102218: LIST
102219: LIST
102220: PUSH
102221: LD_INT 23
102223: PUSH
102224: LD_INT 27
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: EMPTY
102232: LIST
102233: LIST
102234: PUSH
102235: LD_INT 42
102237: PUSH
102238: LD_INT 43
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: PUSH
102245: LD_INT 44
102247: PUSH
102248: LD_INT 46
102250: PUSH
102251: EMPTY
102252: LIST
102253: LIST
102254: PUSH
102255: LD_INT 45
102257: PUSH
102258: LD_INT 47
102260: PUSH
102261: EMPTY
102262: LIST
102263: LIST
102264: PUSH
102265: EMPTY
102266: LIST
102267: LIST
102268: LIST
102269: PUSH
102270: EMPTY
102271: LIST
102272: LIST
102273: LIST
102274: ST_TO_ADDR
// result := [ ] ;
102275: LD_ADDR_VAR 0 3
102279: PUSH
102280: EMPTY
102281: ST_TO_ADDR
// for i in turrets do
102282: LD_ADDR_VAR 0 4
102286: PUSH
102287: LD_VAR 0 1
102291: PUSH
102292: FOR_IN
102293: IFFALSE 102476
// begin nat := GetNation ( i ) ;
102295: LD_ADDR_VAR 0 7
102299: PUSH
102300: LD_VAR 0 4
102304: PPUSH
102305: CALL_OW 248
102309: ST_TO_ADDR
// weapon := 0 ;
102310: LD_ADDR_VAR 0 8
102314: PUSH
102315: LD_INT 0
102317: ST_TO_ADDR
// if not nat then
102318: LD_VAR 0 7
102322: NOT
102323: IFFALSE 102327
// continue ;
102325: GO 102292
// for j in list [ nat ] do
102327: LD_ADDR_VAR 0 5
102331: PUSH
102332: LD_VAR 0 10
102336: PUSH
102337: LD_VAR 0 7
102341: ARRAY
102342: PUSH
102343: FOR_IN
102344: IFFALSE 102385
// if GetBWeapon ( i ) = j [ 1 ] then
102346: LD_VAR 0 4
102350: PPUSH
102351: CALL_OW 269
102355: PUSH
102356: LD_VAR 0 5
102360: PUSH
102361: LD_INT 1
102363: ARRAY
102364: EQUAL
102365: IFFALSE 102383
// begin weapon := j [ 2 ] ;
102367: LD_ADDR_VAR 0 8
102371: PUSH
102372: LD_VAR 0 5
102376: PUSH
102377: LD_INT 2
102379: ARRAY
102380: ST_TO_ADDR
// break ;
102381: GO 102385
// end ;
102383: GO 102343
102385: POP
102386: POP
// if not weapon then
102387: LD_VAR 0 8
102391: NOT
102392: IFFALSE 102396
// continue ;
102394: GO 102292
// for k in factories do
102396: LD_ADDR_VAR 0 6
102400: PUSH
102401: LD_VAR 0 2
102405: PUSH
102406: FOR_IN
102407: IFFALSE 102472
// begin weapons := AvailableWeaponList ( k ) ;
102409: LD_ADDR_VAR 0 9
102413: PUSH
102414: LD_VAR 0 6
102418: PPUSH
102419: CALL_OW 478
102423: ST_TO_ADDR
// if not weapons then
102424: LD_VAR 0 9
102428: NOT
102429: IFFALSE 102433
// continue ;
102431: GO 102406
// if weapon in weapons then
102433: LD_VAR 0 8
102437: PUSH
102438: LD_VAR 0 9
102442: IN
102443: IFFALSE 102470
// begin result := [ i , weapon ] ;
102445: LD_ADDR_VAR 0 3
102449: PUSH
102450: LD_VAR 0 4
102454: PUSH
102455: LD_VAR 0 8
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: ST_TO_ADDR
// exit ;
102464: POP
102465: POP
102466: POP
102467: POP
102468: GO 102478
// end ; end ;
102470: GO 102406
102472: POP
102473: POP
// end ;
102474: GO 102292
102476: POP
102477: POP
// end ;
102478: LD_VAR 0 3
102482: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102483: LD_INT 0
102485: PPUSH
// if not side or side > 8 then
102486: LD_VAR 0 3
102490: NOT
102491: PUSH
102492: LD_VAR 0 3
102496: PUSH
102497: LD_INT 8
102499: GREATER
102500: OR
102501: IFFALSE 102505
// exit ;
102503: GO 102564
// if not range then
102505: LD_VAR 0 4
102509: NOT
102510: IFFALSE 102521
// range := - 12 ;
102512: LD_ADDR_VAR 0 4
102516: PUSH
102517: LD_INT 12
102519: NEG
102520: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102521: LD_VAR 0 1
102525: PPUSH
102526: LD_VAR 0 2
102530: PPUSH
102531: LD_VAR 0 3
102535: PPUSH
102536: LD_VAR 0 4
102540: PPUSH
102541: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102545: LD_VAR 0 1
102549: PPUSH
102550: LD_VAR 0 2
102554: PPUSH
102555: LD_VAR 0 3
102559: PPUSH
102560: CALL_OW 331
// end ;
102564: LD_VAR 0 5
102568: RET
// export function Video ( mode ) ; begin
102569: LD_INT 0
102571: PPUSH
// ingame_video = mode ;
102572: LD_ADDR_OWVAR 52
102576: PUSH
102577: LD_VAR 0 1
102581: ST_TO_ADDR
// interface_hidden = mode ;
102582: LD_ADDR_OWVAR 54
102586: PUSH
102587: LD_VAR 0 1
102591: ST_TO_ADDR
// end ;
102592: LD_VAR 0 2
102596: RET
// export function Join ( array , element ) ; begin
102597: LD_INT 0
102599: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102600: LD_ADDR_VAR 0 3
102604: PUSH
102605: LD_VAR 0 1
102609: PPUSH
102610: LD_VAR 0 1
102614: PUSH
102615: LD_INT 1
102617: PLUS
102618: PPUSH
102619: LD_VAR 0 2
102623: PPUSH
102624: CALL_OW 1
102628: ST_TO_ADDR
// end ;
102629: LD_VAR 0 3
102633: RET
// export function JoinUnion ( array , element ) ; begin
102634: LD_INT 0
102636: PPUSH
// result := array union element ;
102637: LD_ADDR_VAR 0 3
102641: PUSH
102642: LD_VAR 0 1
102646: PUSH
102647: LD_VAR 0 2
102651: UNION
102652: ST_TO_ADDR
// end ;
102653: LD_VAR 0 3
102657: RET
// export function GetBehemoths ( side ) ; begin
102658: LD_INT 0
102660: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102661: LD_ADDR_VAR 0 2
102665: PUSH
102666: LD_INT 22
102668: PUSH
102669: LD_VAR 0 1
102673: PUSH
102674: EMPTY
102675: LIST
102676: LIST
102677: PUSH
102678: LD_INT 31
102680: PUSH
102681: LD_INT 25
102683: PUSH
102684: EMPTY
102685: LIST
102686: LIST
102687: PUSH
102688: EMPTY
102689: LIST
102690: LIST
102691: PPUSH
102692: CALL_OW 69
102696: ST_TO_ADDR
// end ;
102697: LD_VAR 0 2
102701: RET
// export function Shuffle ( array ) ; var i , index ; begin
102702: LD_INT 0
102704: PPUSH
102705: PPUSH
102706: PPUSH
// result := [ ] ;
102707: LD_ADDR_VAR 0 2
102711: PUSH
102712: EMPTY
102713: ST_TO_ADDR
// if not array then
102714: LD_VAR 0 1
102718: NOT
102719: IFFALSE 102723
// exit ;
102721: GO 102822
// Randomize ;
102723: CALL_OW 10
// for i = array downto 1 do
102727: LD_ADDR_VAR 0 3
102731: PUSH
102732: DOUBLE
102733: LD_VAR 0 1
102737: INC
102738: ST_TO_ADDR
102739: LD_INT 1
102741: PUSH
102742: FOR_DOWNTO
102743: IFFALSE 102820
// begin index := rand ( 1 , array ) ;
102745: LD_ADDR_VAR 0 4
102749: PUSH
102750: LD_INT 1
102752: PPUSH
102753: LD_VAR 0 1
102757: PPUSH
102758: CALL_OW 12
102762: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102763: LD_ADDR_VAR 0 2
102767: PUSH
102768: LD_VAR 0 2
102772: PPUSH
102773: LD_VAR 0 2
102777: PUSH
102778: LD_INT 1
102780: PLUS
102781: PPUSH
102782: LD_VAR 0 1
102786: PUSH
102787: LD_VAR 0 4
102791: ARRAY
102792: PPUSH
102793: CALL_OW 2
102797: ST_TO_ADDR
// array := Delete ( array , index ) ;
102798: LD_ADDR_VAR 0 1
102802: PUSH
102803: LD_VAR 0 1
102807: PPUSH
102808: LD_VAR 0 4
102812: PPUSH
102813: CALL_OW 3
102817: ST_TO_ADDR
// end ;
102818: GO 102742
102820: POP
102821: POP
// end ;
102822: LD_VAR 0 2
102826: RET
// export function GetBaseMaterials ( base ) ; begin
102827: LD_INT 0
102829: PPUSH
// result := [ 0 , 0 , 0 ] ;
102830: LD_ADDR_VAR 0 2
102834: PUSH
102835: LD_INT 0
102837: PUSH
102838: LD_INT 0
102840: PUSH
102841: LD_INT 0
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: LIST
102848: ST_TO_ADDR
// if not base then
102849: LD_VAR 0 1
102853: NOT
102854: IFFALSE 102858
// exit ;
102856: GO 102907
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102858: LD_ADDR_VAR 0 2
102862: PUSH
102863: LD_VAR 0 1
102867: PPUSH
102868: LD_INT 1
102870: PPUSH
102871: CALL_OW 275
102875: PUSH
102876: LD_VAR 0 1
102880: PPUSH
102881: LD_INT 2
102883: PPUSH
102884: CALL_OW 275
102888: PUSH
102889: LD_VAR 0 1
102893: PPUSH
102894: LD_INT 3
102896: PPUSH
102897: CALL_OW 275
102901: PUSH
102902: EMPTY
102903: LIST
102904: LIST
102905: LIST
102906: ST_TO_ADDR
// end ;
102907: LD_VAR 0 2
102911: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102912: LD_INT 0
102914: PPUSH
102915: PPUSH
// result := array ;
102916: LD_ADDR_VAR 0 3
102920: PUSH
102921: LD_VAR 0 1
102925: ST_TO_ADDR
// if size > 0 then
102926: LD_VAR 0 2
102930: PUSH
102931: LD_INT 0
102933: GREATER
102934: IFFALSE 102980
// for i := array downto size do
102936: LD_ADDR_VAR 0 4
102940: PUSH
102941: DOUBLE
102942: LD_VAR 0 1
102946: INC
102947: ST_TO_ADDR
102948: LD_VAR 0 2
102952: PUSH
102953: FOR_DOWNTO
102954: IFFALSE 102978
// result := Delete ( result , result ) ;
102956: LD_ADDR_VAR 0 3
102960: PUSH
102961: LD_VAR 0 3
102965: PPUSH
102966: LD_VAR 0 3
102970: PPUSH
102971: CALL_OW 3
102975: ST_TO_ADDR
102976: GO 102953
102978: POP
102979: POP
// end ;
102980: LD_VAR 0 3
102984: RET
// export function ComExit ( unit ) ; var tmp ; begin
102985: LD_INT 0
102987: PPUSH
102988: PPUSH
// if not IsInUnit ( unit ) then
102989: LD_VAR 0 1
102993: PPUSH
102994: CALL_OW 310
102998: NOT
102999: IFFALSE 103003
// exit ;
103001: GO 103063
// tmp := IsInUnit ( unit ) ;
103003: LD_ADDR_VAR 0 3
103007: PUSH
103008: LD_VAR 0 1
103012: PPUSH
103013: CALL_OW 310
103017: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103018: LD_VAR 0 3
103022: PPUSH
103023: CALL_OW 247
103027: PUSH
103028: LD_INT 2
103030: EQUAL
103031: IFFALSE 103044
// ComExitVehicle ( unit ) else
103033: LD_VAR 0 1
103037: PPUSH
103038: CALL_OW 121
103042: GO 103053
// ComExitBuilding ( unit ) ;
103044: LD_VAR 0 1
103048: PPUSH
103049: CALL_OW 122
// result := tmp ;
103053: LD_ADDR_VAR 0 2
103057: PUSH
103058: LD_VAR 0 3
103062: ST_TO_ADDR
// end ;
103063: LD_VAR 0 2
103067: RET
// export function ComExitAll ( units ) ; var i ; begin
103068: LD_INT 0
103070: PPUSH
103071: PPUSH
// if not units then
103072: LD_VAR 0 1
103076: NOT
103077: IFFALSE 103081
// exit ;
103079: GO 103107
// for i in units do
103081: LD_ADDR_VAR 0 3
103085: PUSH
103086: LD_VAR 0 1
103090: PUSH
103091: FOR_IN
103092: IFFALSE 103105
// ComExit ( i ) ;
103094: LD_VAR 0 3
103098: PPUSH
103099: CALL 102985 0 1
103103: GO 103091
103105: POP
103106: POP
// end ;
103107: LD_VAR 0 2
103111: RET
// export function ResetHc ; begin
103112: LD_INT 0
103114: PPUSH
// InitHc ;
103115: CALL_OW 19
// hc_importance := 0 ;
103119: LD_ADDR_OWVAR 32
103123: PUSH
103124: LD_INT 0
103126: ST_TO_ADDR
// end ;
103127: LD_VAR 0 1
103131: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103132: LD_INT 0
103134: PPUSH
103135: PPUSH
103136: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103137: LD_ADDR_VAR 0 6
103141: PUSH
103142: LD_VAR 0 1
103146: PUSH
103147: LD_VAR 0 3
103151: PLUS
103152: PUSH
103153: LD_INT 2
103155: DIV
103156: ST_TO_ADDR
// if _x < 0 then
103157: LD_VAR 0 6
103161: PUSH
103162: LD_INT 0
103164: LESS
103165: IFFALSE 103182
// _x := _x * - 1 ;
103167: LD_ADDR_VAR 0 6
103171: PUSH
103172: LD_VAR 0 6
103176: PUSH
103177: LD_INT 1
103179: NEG
103180: MUL
103181: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103182: LD_ADDR_VAR 0 7
103186: PUSH
103187: LD_VAR 0 2
103191: PUSH
103192: LD_VAR 0 4
103196: PLUS
103197: PUSH
103198: LD_INT 2
103200: DIV
103201: ST_TO_ADDR
// if _y < 0 then
103202: LD_VAR 0 7
103206: PUSH
103207: LD_INT 0
103209: LESS
103210: IFFALSE 103227
// _y := _y * - 1 ;
103212: LD_ADDR_VAR 0 7
103216: PUSH
103217: LD_VAR 0 7
103221: PUSH
103222: LD_INT 1
103224: NEG
103225: MUL
103226: ST_TO_ADDR
// result := [ _x , _y ] ;
103227: LD_ADDR_VAR 0 5
103231: PUSH
103232: LD_VAR 0 6
103236: PUSH
103237: LD_VAR 0 7
103241: PUSH
103242: EMPTY
103243: LIST
103244: LIST
103245: ST_TO_ADDR
// end ;
103246: LD_VAR 0 5
103250: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103251: LD_INT 0
103253: PPUSH
103254: PPUSH
103255: PPUSH
103256: PPUSH
// task := GetTaskList ( unit ) ;
103257: LD_ADDR_VAR 0 7
103261: PUSH
103262: LD_VAR 0 1
103266: PPUSH
103267: CALL_OW 437
103271: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103272: LD_VAR 0 7
103276: NOT
103277: PUSH
103278: LD_VAR 0 1
103282: PPUSH
103283: LD_VAR 0 2
103287: PPUSH
103288: CALL_OW 308
103292: NOT
103293: AND
103294: IFFALSE 103298
// exit ;
103296: GO 103416
// if IsInArea ( unit , area ) then
103298: LD_VAR 0 1
103302: PPUSH
103303: LD_VAR 0 2
103307: PPUSH
103308: CALL_OW 308
103312: IFFALSE 103330
// begin ComMoveToArea ( unit , goAway ) ;
103314: LD_VAR 0 1
103318: PPUSH
103319: LD_VAR 0 3
103323: PPUSH
103324: CALL_OW 113
// exit ;
103328: GO 103416
// end ; if task [ 1 ] [ 1 ] <> M then
103330: LD_VAR 0 7
103334: PUSH
103335: LD_INT 1
103337: ARRAY
103338: PUSH
103339: LD_INT 1
103341: ARRAY
103342: PUSH
103343: LD_STRING M
103345: NONEQUAL
103346: IFFALSE 103350
// exit ;
103348: GO 103416
// x := task [ 1 ] [ 2 ] ;
103350: LD_ADDR_VAR 0 5
103354: PUSH
103355: LD_VAR 0 7
103359: PUSH
103360: LD_INT 1
103362: ARRAY
103363: PUSH
103364: LD_INT 2
103366: ARRAY
103367: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103368: LD_ADDR_VAR 0 6
103372: PUSH
103373: LD_VAR 0 7
103377: PUSH
103378: LD_INT 1
103380: ARRAY
103381: PUSH
103382: LD_INT 3
103384: ARRAY
103385: ST_TO_ADDR
// if InArea ( x , y , area ) then
103386: LD_VAR 0 5
103390: PPUSH
103391: LD_VAR 0 6
103395: PPUSH
103396: LD_VAR 0 2
103400: PPUSH
103401: CALL_OW 309
103405: IFFALSE 103416
// ComStop ( unit ) ;
103407: LD_VAR 0 1
103411: PPUSH
103412: CALL_OW 141
// end ;
103416: LD_VAR 0 4
103420: RET
// export function Abs ( value ) ; begin
103421: LD_INT 0
103423: PPUSH
// result := value ;
103424: LD_ADDR_VAR 0 2
103428: PUSH
103429: LD_VAR 0 1
103433: ST_TO_ADDR
// if value < 0 then
103434: LD_VAR 0 1
103438: PUSH
103439: LD_INT 0
103441: LESS
103442: IFFALSE 103459
// result := value * - 1 ;
103444: LD_ADDR_VAR 0 2
103448: PUSH
103449: LD_VAR 0 1
103453: PUSH
103454: LD_INT 1
103456: NEG
103457: MUL
103458: ST_TO_ADDR
// end ;
103459: LD_VAR 0 2
103463: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103464: LD_INT 0
103466: PPUSH
103467: PPUSH
103468: PPUSH
103469: PPUSH
103470: PPUSH
103471: PPUSH
103472: PPUSH
103473: PPUSH
// if not unit or not building then
103474: LD_VAR 0 1
103478: NOT
103479: PUSH
103480: LD_VAR 0 2
103484: NOT
103485: OR
103486: IFFALSE 103490
// exit ;
103488: GO 103716
// x := GetX ( building ) ;
103490: LD_ADDR_VAR 0 4
103494: PUSH
103495: LD_VAR 0 2
103499: PPUSH
103500: CALL_OW 250
103504: ST_TO_ADDR
// y := GetY ( building ) ;
103505: LD_ADDR_VAR 0 6
103509: PUSH
103510: LD_VAR 0 2
103514: PPUSH
103515: CALL_OW 251
103519: ST_TO_ADDR
// d := GetDir ( building ) ;
103520: LD_ADDR_VAR 0 8
103524: PUSH
103525: LD_VAR 0 2
103529: PPUSH
103530: CALL_OW 254
103534: ST_TO_ADDR
// r := 4 ;
103535: LD_ADDR_VAR 0 9
103539: PUSH
103540: LD_INT 4
103542: ST_TO_ADDR
// for i := 1 to 5 do
103543: LD_ADDR_VAR 0 10
103547: PUSH
103548: DOUBLE
103549: LD_INT 1
103551: DEC
103552: ST_TO_ADDR
103553: LD_INT 5
103555: PUSH
103556: FOR_TO
103557: IFFALSE 103714
// begin _x := ShiftX ( x , d , r + i ) ;
103559: LD_ADDR_VAR 0 5
103563: PUSH
103564: LD_VAR 0 4
103568: PPUSH
103569: LD_VAR 0 8
103573: PPUSH
103574: LD_VAR 0 9
103578: PUSH
103579: LD_VAR 0 10
103583: PLUS
103584: PPUSH
103585: CALL_OW 272
103589: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103590: LD_ADDR_VAR 0 7
103594: PUSH
103595: LD_VAR 0 6
103599: PPUSH
103600: LD_VAR 0 8
103604: PPUSH
103605: LD_VAR 0 9
103609: PUSH
103610: LD_VAR 0 10
103614: PLUS
103615: PPUSH
103616: CALL_OW 273
103620: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103621: LD_VAR 0 5
103625: PPUSH
103626: LD_VAR 0 7
103630: PPUSH
103631: CALL_OW 488
103635: PUSH
103636: LD_VAR 0 5
103640: PPUSH
103641: LD_VAR 0 7
103645: PPUSH
103646: CALL_OW 428
103650: PPUSH
103651: CALL_OW 247
103655: PUSH
103656: LD_INT 3
103658: PUSH
103659: LD_INT 2
103661: PUSH
103662: EMPTY
103663: LIST
103664: LIST
103665: IN
103666: NOT
103667: AND
103668: IFFALSE 103712
// begin ComMoveXY ( unit , _x , _y ) ;
103670: LD_VAR 0 1
103674: PPUSH
103675: LD_VAR 0 5
103679: PPUSH
103680: LD_VAR 0 7
103684: PPUSH
103685: CALL_OW 111
// result := [ _x , _y ] ;
103689: LD_ADDR_VAR 0 3
103693: PUSH
103694: LD_VAR 0 5
103698: PUSH
103699: LD_VAR 0 7
103703: PUSH
103704: EMPTY
103705: LIST
103706: LIST
103707: ST_TO_ADDR
// exit ;
103708: POP
103709: POP
103710: GO 103716
// end ; end ;
103712: GO 103556
103714: POP
103715: POP
// end ;
103716: LD_VAR 0 3
103720: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103721: LD_INT 0
103723: PPUSH
103724: PPUSH
103725: PPUSH
// result := 0 ;
103726: LD_ADDR_VAR 0 3
103730: PUSH
103731: LD_INT 0
103733: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103734: LD_VAR 0 1
103738: PUSH
103739: LD_INT 0
103741: LESS
103742: PUSH
103743: LD_VAR 0 1
103747: PUSH
103748: LD_INT 8
103750: GREATER
103751: OR
103752: PUSH
103753: LD_VAR 0 2
103757: PUSH
103758: LD_INT 0
103760: LESS
103761: OR
103762: PUSH
103763: LD_VAR 0 2
103767: PUSH
103768: LD_INT 8
103770: GREATER
103771: OR
103772: IFFALSE 103776
// exit ;
103774: GO 103851
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103776: LD_ADDR_VAR 0 4
103780: PUSH
103781: LD_INT 22
103783: PUSH
103784: LD_VAR 0 2
103788: PUSH
103789: EMPTY
103790: LIST
103791: LIST
103792: PPUSH
103793: CALL_OW 69
103797: PUSH
103798: FOR_IN
103799: IFFALSE 103849
// begin un := UnitShoot ( i ) ;
103801: LD_ADDR_VAR 0 5
103805: PUSH
103806: LD_VAR 0 4
103810: PPUSH
103811: CALL_OW 504
103815: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103816: LD_VAR 0 5
103820: PPUSH
103821: CALL_OW 255
103825: PUSH
103826: LD_VAR 0 1
103830: EQUAL
103831: IFFALSE 103847
// begin result := un ;
103833: LD_ADDR_VAR 0 3
103837: PUSH
103838: LD_VAR 0 5
103842: ST_TO_ADDR
// exit ;
103843: POP
103844: POP
103845: GO 103851
// end ; end ;
103847: GO 103798
103849: POP
103850: POP
// end ;
103851: LD_VAR 0 3
103855: RET
// export function GetCargoBay ( units ) ; begin
103856: LD_INT 0
103858: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103859: LD_ADDR_VAR 0 2
103863: PUSH
103864: LD_VAR 0 1
103868: PPUSH
103869: LD_INT 2
103871: PUSH
103872: LD_INT 34
103874: PUSH
103875: LD_INT 12
103877: PUSH
103878: EMPTY
103879: LIST
103880: LIST
103881: PUSH
103882: LD_INT 34
103884: PUSH
103885: LD_INT 51
103887: PUSH
103888: EMPTY
103889: LIST
103890: LIST
103891: PUSH
103892: LD_INT 34
103894: PUSH
103895: LD_INT 32
103897: PUSH
103898: EMPTY
103899: LIST
103900: LIST
103901: PUSH
103902: LD_INT 34
103904: PUSH
103905: LD_EXP 96
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: PUSH
103914: EMPTY
103915: LIST
103916: LIST
103917: LIST
103918: LIST
103919: LIST
103920: PPUSH
103921: CALL_OW 72
103925: ST_TO_ADDR
// end ;
103926: LD_VAR 0 2
103930: RET
// export function Negate ( value ) ; begin
103931: LD_INT 0
103933: PPUSH
// result := not value ;
103934: LD_ADDR_VAR 0 2
103938: PUSH
103939: LD_VAR 0 1
103943: NOT
103944: ST_TO_ADDR
// end ;
103945: LD_VAR 0 2
103949: RET
// export function Inc ( value ) ; begin
103950: LD_INT 0
103952: PPUSH
// result := value + 1 ;
103953: LD_ADDR_VAR 0 2
103957: PUSH
103958: LD_VAR 0 1
103962: PUSH
103963: LD_INT 1
103965: PLUS
103966: ST_TO_ADDR
// end ;
103967: LD_VAR 0 2
103971: RET
// export function Dec ( value ) ; begin
103972: LD_INT 0
103974: PPUSH
// result := value - 1 ;
103975: LD_ADDR_VAR 0 2
103979: PUSH
103980: LD_VAR 0 1
103984: PUSH
103985: LD_INT 1
103987: MINUS
103988: ST_TO_ADDR
// end ;
103989: LD_VAR 0 2
103993: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
103994: LD_INT 0
103996: PPUSH
103997: PPUSH
103998: PPUSH
103999: PPUSH
104000: PPUSH
104001: PPUSH
104002: PPUSH
104003: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
104004: LD_VAR 0 1
104008: PPUSH
104009: LD_VAR 0 2
104013: PPUSH
104014: CALL_OW 488
104018: NOT
104019: PUSH
104020: LD_VAR 0 3
104024: PPUSH
104025: LD_VAR 0 4
104029: PPUSH
104030: CALL_OW 488
104034: NOT
104035: OR
104036: IFFALSE 104049
// begin result := - 1 ;
104038: LD_ADDR_VAR 0 5
104042: PUSH
104043: LD_INT 1
104045: NEG
104046: ST_TO_ADDR
// exit ;
104047: GO 104284
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
104049: LD_ADDR_VAR 0 12
104053: PUSH
104054: LD_VAR 0 1
104058: PPUSH
104059: LD_VAR 0 2
104063: PPUSH
104064: LD_VAR 0 3
104068: PPUSH
104069: LD_VAR 0 4
104073: PPUSH
104074: CALL 103132 0 4
104078: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
104079: LD_ADDR_VAR 0 11
104083: PUSH
104084: LD_VAR 0 1
104088: PPUSH
104089: LD_VAR 0 2
104093: PPUSH
104094: LD_VAR 0 12
104098: PUSH
104099: LD_INT 1
104101: ARRAY
104102: PPUSH
104103: LD_VAR 0 12
104107: PUSH
104108: LD_INT 2
104110: ARRAY
104111: PPUSH
104112: CALL_OW 298
104116: ST_TO_ADDR
// distance := 9999 ;
104117: LD_ADDR_VAR 0 10
104121: PUSH
104122: LD_INT 9999
104124: ST_TO_ADDR
// for i := 0 to 5 do
104125: LD_ADDR_VAR 0 6
104129: PUSH
104130: DOUBLE
104131: LD_INT 0
104133: DEC
104134: ST_TO_ADDR
104135: LD_INT 5
104137: PUSH
104138: FOR_TO
104139: IFFALSE 104282
// begin _x := ShiftX ( x1 , i , centerDist ) ;
104141: LD_ADDR_VAR 0 7
104145: PUSH
104146: LD_VAR 0 1
104150: PPUSH
104151: LD_VAR 0 6
104155: PPUSH
104156: LD_VAR 0 11
104160: PPUSH
104161: CALL_OW 272
104165: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
104166: LD_ADDR_VAR 0 8
104170: PUSH
104171: LD_VAR 0 2
104175: PPUSH
104176: LD_VAR 0 6
104180: PPUSH
104181: LD_VAR 0 11
104185: PPUSH
104186: CALL_OW 273
104190: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104191: LD_VAR 0 7
104195: PPUSH
104196: LD_VAR 0 8
104200: PPUSH
104201: CALL_OW 488
104205: NOT
104206: IFFALSE 104210
// continue ;
104208: GO 104138
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
104210: LD_ADDR_VAR 0 9
104214: PUSH
104215: LD_VAR 0 12
104219: PUSH
104220: LD_INT 1
104222: ARRAY
104223: PPUSH
104224: LD_VAR 0 12
104228: PUSH
104229: LD_INT 2
104231: ARRAY
104232: PPUSH
104233: LD_VAR 0 7
104237: PPUSH
104238: LD_VAR 0 8
104242: PPUSH
104243: CALL_OW 298
104247: ST_TO_ADDR
// if tmp < distance then
104248: LD_VAR 0 9
104252: PUSH
104253: LD_VAR 0 10
104257: LESS
104258: IFFALSE 104280
// begin result := i ;
104260: LD_ADDR_VAR 0 5
104264: PUSH
104265: LD_VAR 0 6
104269: ST_TO_ADDR
// distance := tmp ;
104270: LD_ADDR_VAR 0 10
104274: PUSH
104275: LD_VAR 0 9
104279: ST_TO_ADDR
// end ; end ;
104280: GO 104138
104282: POP
104283: POP
// end ;
104284: LD_VAR 0 5
104288: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104289: LD_INT 0
104291: PPUSH
104292: PPUSH
// if not driver or not IsInUnit ( driver ) then
104293: LD_VAR 0 1
104297: NOT
104298: PUSH
104299: LD_VAR 0 1
104303: PPUSH
104304: CALL_OW 310
104308: NOT
104309: OR
104310: IFFALSE 104314
// exit ;
104312: GO 104404
// vehicle := IsInUnit ( driver ) ;
104314: LD_ADDR_VAR 0 3
104318: PUSH
104319: LD_VAR 0 1
104323: PPUSH
104324: CALL_OW 310
104328: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104329: LD_VAR 0 1
104333: PPUSH
104334: LD_STRING \
104336: PUSH
104337: LD_INT 0
104339: PUSH
104340: LD_INT 0
104342: PUSH
104343: LD_INT 0
104345: PUSH
104346: LD_INT 0
104348: PUSH
104349: LD_INT 0
104351: PUSH
104352: LD_INT 0
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: LIST
104359: LIST
104360: LIST
104361: LIST
104362: LIST
104363: PUSH
104364: LD_STRING E
104366: PUSH
104367: LD_INT 0
104369: PUSH
104370: LD_INT 0
104372: PUSH
104373: LD_VAR 0 3
104377: PUSH
104378: LD_INT 0
104380: PUSH
104381: LD_INT 0
104383: PUSH
104384: LD_INT 0
104386: PUSH
104387: EMPTY
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: LIST
104393: LIST
104394: LIST
104395: PUSH
104396: EMPTY
104397: LIST
104398: LIST
104399: PPUSH
104400: CALL_OW 446
// end ;
104404: LD_VAR 0 2
104408: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104409: LD_INT 0
104411: PPUSH
104412: PPUSH
// if not driver or not IsInUnit ( driver ) then
104413: LD_VAR 0 1
104417: NOT
104418: PUSH
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 310
104428: NOT
104429: OR
104430: IFFALSE 104434
// exit ;
104432: GO 104524
// vehicle := IsInUnit ( driver ) ;
104434: LD_ADDR_VAR 0 3
104438: PUSH
104439: LD_VAR 0 1
104443: PPUSH
104444: CALL_OW 310
104448: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104449: LD_VAR 0 1
104453: PPUSH
104454: LD_STRING \
104456: PUSH
104457: LD_INT 0
104459: PUSH
104460: LD_INT 0
104462: PUSH
104463: LD_INT 0
104465: PUSH
104466: LD_INT 0
104468: PUSH
104469: LD_INT 0
104471: PUSH
104472: LD_INT 0
104474: PUSH
104475: EMPTY
104476: LIST
104477: LIST
104478: LIST
104479: LIST
104480: LIST
104481: LIST
104482: LIST
104483: PUSH
104484: LD_STRING E
104486: PUSH
104487: LD_INT 0
104489: PUSH
104490: LD_INT 0
104492: PUSH
104493: LD_VAR 0 3
104497: PUSH
104498: LD_INT 0
104500: PUSH
104501: LD_INT 0
104503: PUSH
104504: LD_INT 0
104506: PUSH
104507: EMPTY
104508: LIST
104509: LIST
104510: LIST
104511: LIST
104512: LIST
104513: LIST
104514: LIST
104515: PUSH
104516: EMPTY
104517: LIST
104518: LIST
104519: PPUSH
104520: CALL_OW 447
// end ;
104524: LD_VAR 0 2
104528: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104529: LD_INT 0
104531: PPUSH
104532: PPUSH
104533: PPUSH
// tmp := [ ] ;
104534: LD_ADDR_VAR 0 5
104538: PUSH
104539: EMPTY
104540: ST_TO_ADDR
// for i in units do
104541: LD_ADDR_VAR 0 4
104545: PUSH
104546: LD_VAR 0 1
104550: PUSH
104551: FOR_IN
104552: IFFALSE 104590
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104554: LD_ADDR_VAR 0 5
104558: PUSH
104559: LD_VAR 0 5
104563: PPUSH
104564: LD_VAR 0 5
104568: PUSH
104569: LD_INT 1
104571: PLUS
104572: PPUSH
104573: LD_VAR 0 4
104577: PPUSH
104578: CALL_OW 256
104582: PPUSH
104583: CALL_OW 2
104587: ST_TO_ADDR
104588: GO 104551
104590: POP
104591: POP
// if not tmp then
104592: LD_VAR 0 5
104596: NOT
104597: IFFALSE 104601
// exit ;
104599: GO 104649
// if asc then
104601: LD_VAR 0 2
104605: IFFALSE 104629
// result := SortListByListAsc ( units , tmp ) else
104607: LD_ADDR_VAR 0 3
104611: PUSH
104612: LD_VAR 0 1
104616: PPUSH
104617: LD_VAR 0 5
104621: PPUSH
104622: CALL_OW 76
104626: ST_TO_ADDR
104627: GO 104649
// result := SortListByListDesc ( units , tmp ) ;
104629: LD_ADDR_VAR 0 3
104633: PUSH
104634: LD_VAR 0 1
104638: PPUSH
104639: LD_VAR 0 5
104643: PPUSH
104644: CALL_OW 77
104648: ST_TO_ADDR
// end ;
104649: LD_VAR 0 3
104653: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104654: LD_INT 0
104656: PPUSH
104657: PPUSH
// task := GetTaskList ( mech ) ;
104658: LD_ADDR_VAR 0 4
104662: PUSH
104663: LD_VAR 0 1
104667: PPUSH
104668: CALL_OW 437
104672: ST_TO_ADDR
// if not task then
104673: LD_VAR 0 4
104677: NOT
104678: IFFALSE 104682
// exit ;
104680: GO 104724
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104682: LD_ADDR_VAR 0 3
104686: PUSH
104687: LD_VAR 0 4
104691: PUSH
104692: LD_INT 1
104694: ARRAY
104695: PUSH
104696: LD_INT 1
104698: ARRAY
104699: PUSH
104700: LD_STRING r
104702: EQUAL
104703: PUSH
104704: LD_VAR 0 4
104708: PUSH
104709: LD_INT 1
104711: ARRAY
104712: PUSH
104713: LD_INT 4
104715: ARRAY
104716: PUSH
104717: LD_VAR 0 2
104721: EQUAL
104722: AND
104723: ST_TO_ADDR
// end ;
104724: LD_VAR 0 3
104728: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104729: LD_INT 0
104731: PPUSH
// SetDir ( unit , d ) ;
104732: LD_VAR 0 1
104736: PPUSH
104737: LD_VAR 0 4
104741: PPUSH
104742: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104746: LD_VAR 0 1
104750: PPUSH
104751: LD_VAR 0 2
104755: PPUSH
104756: LD_VAR 0 3
104760: PPUSH
104761: LD_VAR 0 5
104765: PPUSH
104766: CALL_OW 48
// end ;
104770: LD_VAR 0 6
104774: RET
// export function ToNaturalNumber ( number ) ; begin
104775: LD_INT 0
104777: PPUSH
// result := number div 1 ;
104778: LD_ADDR_VAR 0 2
104782: PUSH
104783: LD_VAR 0 1
104787: PUSH
104788: LD_INT 1
104790: DIV
104791: ST_TO_ADDR
// if number < 0 then
104792: LD_VAR 0 1
104796: PUSH
104797: LD_INT 0
104799: LESS
104800: IFFALSE 104810
// result := 0 ;
104802: LD_ADDR_VAR 0 2
104806: PUSH
104807: LD_INT 0
104809: ST_TO_ADDR
// end ;
104810: LD_VAR 0 2
104814: RET
// export function SortByClass ( units , class ) ; var un ; begin
104815: LD_INT 0
104817: PPUSH
104818: PPUSH
// if not units or not class then
104819: LD_VAR 0 1
104823: NOT
104824: PUSH
104825: LD_VAR 0 2
104829: NOT
104830: OR
104831: IFFALSE 104835
// exit ;
104833: GO 104930
// result := [ ] ;
104835: LD_ADDR_VAR 0 3
104839: PUSH
104840: EMPTY
104841: ST_TO_ADDR
// for un in units do
104842: LD_ADDR_VAR 0 4
104846: PUSH
104847: LD_VAR 0 1
104851: PUSH
104852: FOR_IN
104853: IFFALSE 104928
// if GetClass ( un ) = class then
104855: LD_VAR 0 4
104859: PPUSH
104860: CALL_OW 257
104864: PUSH
104865: LD_VAR 0 2
104869: EQUAL
104870: IFFALSE 104897
// result := Insert ( result , 1 , un ) else
104872: LD_ADDR_VAR 0 3
104876: PUSH
104877: LD_VAR 0 3
104881: PPUSH
104882: LD_INT 1
104884: PPUSH
104885: LD_VAR 0 4
104889: PPUSH
104890: CALL_OW 2
104894: ST_TO_ADDR
104895: GO 104926
// result := Replace ( result , result + 1 , un ) ;
104897: LD_ADDR_VAR 0 3
104901: PUSH
104902: LD_VAR 0 3
104906: PPUSH
104907: LD_VAR 0 3
104911: PUSH
104912: LD_INT 1
104914: PLUS
104915: PPUSH
104916: LD_VAR 0 4
104920: PPUSH
104921: CALL_OW 1
104925: ST_TO_ADDR
104926: GO 104852
104928: POP
104929: POP
// end ;
104930: LD_VAR 0 3
104934: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104935: LD_INT 0
104937: PPUSH
104938: PPUSH
104939: PPUSH
104940: PPUSH
104941: PPUSH
104942: PPUSH
104943: PPUSH
// result := [ ] ;
104944: LD_ADDR_VAR 0 4
104948: PUSH
104949: EMPTY
104950: ST_TO_ADDR
// if x - r < 0 then
104951: LD_VAR 0 1
104955: PUSH
104956: LD_VAR 0 3
104960: MINUS
104961: PUSH
104962: LD_INT 0
104964: LESS
104965: IFFALSE 104977
// min_x := 0 else
104967: LD_ADDR_VAR 0 8
104971: PUSH
104972: LD_INT 0
104974: ST_TO_ADDR
104975: GO 104993
// min_x := x - r ;
104977: LD_ADDR_VAR 0 8
104981: PUSH
104982: LD_VAR 0 1
104986: PUSH
104987: LD_VAR 0 3
104991: MINUS
104992: ST_TO_ADDR
// if y - r < 0 then
104993: LD_VAR 0 2
104997: PUSH
104998: LD_VAR 0 3
105002: MINUS
105003: PUSH
105004: LD_INT 0
105006: LESS
105007: IFFALSE 105019
// min_y := 0 else
105009: LD_ADDR_VAR 0 7
105013: PUSH
105014: LD_INT 0
105016: ST_TO_ADDR
105017: GO 105035
// min_y := y - r ;
105019: LD_ADDR_VAR 0 7
105023: PUSH
105024: LD_VAR 0 2
105028: PUSH
105029: LD_VAR 0 3
105033: MINUS
105034: ST_TO_ADDR
// max_x := x + r ;
105035: LD_ADDR_VAR 0 9
105039: PUSH
105040: LD_VAR 0 1
105044: PUSH
105045: LD_VAR 0 3
105049: PLUS
105050: ST_TO_ADDR
// max_y := y + r ;
105051: LD_ADDR_VAR 0 10
105055: PUSH
105056: LD_VAR 0 2
105060: PUSH
105061: LD_VAR 0 3
105065: PLUS
105066: ST_TO_ADDR
// for _x = min_x to max_x do
105067: LD_ADDR_VAR 0 5
105071: PUSH
105072: DOUBLE
105073: LD_VAR 0 8
105077: DEC
105078: ST_TO_ADDR
105079: LD_VAR 0 9
105083: PUSH
105084: FOR_TO
105085: IFFALSE 105186
// for _y = min_y to max_y do
105087: LD_ADDR_VAR 0 6
105091: PUSH
105092: DOUBLE
105093: LD_VAR 0 7
105097: DEC
105098: ST_TO_ADDR
105099: LD_VAR 0 10
105103: PUSH
105104: FOR_TO
105105: IFFALSE 105182
// begin if not ValidHex ( _x , _y ) then
105107: LD_VAR 0 5
105111: PPUSH
105112: LD_VAR 0 6
105116: PPUSH
105117: CALL_OW 488
105121: NOT
105122: IFFALSE 105126
// continue ;
105124: GO 105104
// if GetResourceTypeXY ( _x , _y ) then
105126: LD_VAR 0 5
105130: PPUSH
105131: LD_VAR 0 6
105135: PPUSH
105136: CALL_OW 283
105140: IFFALSE 105180
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
105142: LD_ADDR_VAR 0 4
105146: PUSH
105147: LD_VAR 0 4
105151: PPUSH
105152: LD_VAR 0 4
105156: PUSH
105157: LD_INT 1
105159: PLUS
105160: PPUSH
105161: LD_VAR 0 5
105165: PUSH
105166: LD_VAR 0 6
105170: PUSH
105171: EMPTY
105172: LIST
105173: LIST
105174: PPUSH
105175: CALL_OW 1
105179: ST_TO_ADDR
// end ;
105180: GO 105104
105182: POP
105183: POP
105184: GO 105084
105186: POP
105187: POP
// end ;
105188: LD_VAR 0 4
105192: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
105193: LD_INT 0
105195: PPUSH
105196: PPUSH
105197: PPUSH
105198: PPUSH
105199: PPUSH
105200: PPUSH
105201: PPUSH
105202: PPUSH
// if not units then
105203: LD_VAR 0 1
105207: NOT
105208: IFFALSE 105212
// exit ;
105210: GO 105637
// result := UnitFilter ( units , [ f_ok ] ) ;
105212: LD_ADDR_VAR 0 3
105216: PUSH
105217: LD_VAR 0 1
105221: PPUSH
105222: LD_INT 50
105224: PUSH
105225: EMPTY
105226: LIST
105227: PPUSH
105228: CALL_OW 72
105232: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105233: LD_ADDR_VAR 0 8
105237: PUSH
105238: LD_VAR 0 1
105242: PUSH
105243: LD_INT 1
105245: ARRAY
105246: PPUSH
105247: CALL_OW 255
105251: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
105252: LD_ADDR_VAR 0 10
105256: PUSH
105257: LD_INT 29
105259: PUSH
105260: LD_EXP 99
105264: PUSH
105265: EMPTY
105266: LIST
105267: LIST
105268: ST_TO_ADDR
// if not result then
105269: LD_VAR 0 3
105273: NOT
105274: IFFALSE 105278
// exit ;
105276: GO 105637
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105278: LD_ADDR_VAR 0 5
105282: PUSH
105283: LD_INT 81
105285: PUSH
105286: LD_VAR 0 8
105290: PUSH
105291: EMPTY
105292: LIST
105293: LIST
105294: PPUSH
105295: CALL_OW 69
105299: ST_TO_ADDR
// for i in result do
105300: LD_ADDR_VAR 0 4
105304: PUSH
105305: LD_VAR 0 3
105309: PUSH
105310: FOR_IN
105311: IFFALSE 105635
// begin tag := GetTag ( i ) + 1 ;
105313: LD_ADDR_VAR 0 9
105317: PUSH
105318: LD_VAR 0 4
105322: PPUSH
105323: CALL_OW 110
105327: PUSH
105328: LD_INT 1
105330: PLUS
105331: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
105332: LD_ADDR_VAR 0 7
105336: PUSH
105337: LD_VAR 0 4
105341: PPUSH
105342: CALL_OW 250
105346: PPUSH
105347: LD_VAR 0 4
105351: PPUSH
105352: CALL_OW 251
105356: PPUSH
105357: LD_INT 6
105359: PPUSH
105360: CALL 104935 0 3
105364: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
105365: LD_VAR 0 7
105369: PUSH
105370: LD_VAR 0 4
105374: PPUSH
105375: CALL_OW 264
105379: PUSH
105380: LD_VAR 0 10
105384: IN
105385: NOT
105386: AND
105387: IFFALSE 105426
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
105389: LD_VAR 0 4
105393: PPUSH
105394: LD_VAR 0 7
105398: PUSH
105399: LD_INT 1
105401: ARRAY
105402: PUSH
105403: LD_INT 1
105405: ARRAY
105406: PPUSH
105407: LD_VAR 0 7
105411: PUSH
105412: LD_INT 1
105414: ARRAY
105415: PUSH
105416: LD_INT 2
105418: ARRAY
105419: PPUSH
105420: CALL_OW 116
105424: GO 105633
// if path > tag then
105426: LD_VAR 0 2
105430: PUSH
105431: LD_VAR 0 9
105435: GREATER
105436: IFFALSE 105603
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
105438: LD_ADDR_VAR 0 6
105442: PUSH
105443: LD_VAR 0 5
105447: PPUSH
105448: LD_INT 91
105450: PUSH
105451: LD_VAR 0 4
105455: PUSH
105456: LD_INT 12
105458: PUSH
105459: EMPTY
105460: LIST
105461: LIST
105462: LIST
105463: PPUSH
105464: CALL_OW 72
105468: ST_TO_ADDR
// if nearEnemy then
105469: LD_VAR 0 6
105473: IFFALSE 105501
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
105475: LD_VAR 0 4
105479: PPUSH
105480: LD_VAR 0 6
105484: PPUSH
105485: LD_VAR 0 4
105489: PPUSH
105490: CALL_OW 74
105494: PPUSH
105495: CALL_OW 115
105499: GO 105601
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
105501: LD_VAR 0 4
105505: PPUSH
105506: LD_VAR 0 2
105510: PUSH
105511: LD_VAR 0 9
105515: ARRAY
105516: PUSH
105517: LD_INT 1
105519: ARRAY
105520: PPUSH
105521: LD_VAR 0 2
105525: PUSH
105526: LD_VAR 0 9
105530: ARRAY
105531: PUSH
105532: LD_INT 2
105534: ARRAY
105535: PPUSH
105536: CALL_OW 297
105540: PUSH
105541: LD_INT 6
105543: GREATER
105544: IFFALSE 105587
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
105546: LD_VAR 0 4
105550: PPUSH
105551: LD_VAR 0 2
105555: PUSH
105556: LD_VAR 0 9
105560: ARRAY
105561: PUSH
105562: LD_INT 1
105564: ARRAY
105565: PPUSH
105566: LD_VAR 0 2
105570: PUSH
105571: LD_VAR 0 9
105575: ARRAY
105576: PUSH
105577: LD_INT 2
105579: ARRAY
105580: PPUSH
105581: CALL_OW 114
105585: GO 105601
// SetTag ( i , tag ) ;
105587: LD_VAR 0 4
105591: PPUSH
105592: LD_VAR 0 9
105596: PPUSH
105597: CALL_OW 109
// end else
105601: GO 105633
// if enemy then
105603: LD_VAR 0 5
105607: IFFALSE 105633
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
105609: LD_VAR 0 4
105613: PPUSH
105614: LD_VAR 0 5
105618: PPUSH
105619: LD_VAR 0 4
105623: PPUSH
105624: CALL_OW 74
105628: PPUSH
105629: CALL_OW 115
// end ;
105633: GO 105310
105635: POP
105636: POP
// end ;
105637: LD_VAR 0 3
105641: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
105642: LD_INT 0
105644: PPUSH
105645: PPUSH
105646: PPUSH
// if not unit or IsInUnit ( unit ) then
105647: LD_VAR 0 1
105651: NOT
105652: PUSH
105653: LD_VAR 0 1
105657: PPUSH
105658: CALL_OW 310
105662: OR
105663: IFFALSE 105667
// exit ;
105665: GO 105758
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
105667: LD_ADDR_VAR 0 4
105671: PUSH
105672: LD_VAR 0 1
105676: PPUSH
105677: CALL_OW 250
105681: PPUSH
105682: LD_VAR 0 2
105686: PPUSH
105687: LD_INT 1
105689: PPUSH
105690: CALL_OW 272
105694: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
105695: LD_ADDR_VAR 0 5
105699: PUSH
105700: LD_VAR 0 1
105704: PPUSH
105705: CALL_OW 251
105709: PPUSH
105710: LD_VAR 0 2
105714: PPUSH
105715: LD_INT 1
105717: PPUSH
105718: CALL_OW 273
105722: ST_TO_ADDR
// if ValidHex ( x , y ) then
105723: LD_VAR 0 4
105727: PPUSH
105728: LD_VAR 0 5
105732: PPUSH
105733: CALL_OW 488
105737: IFFALSE 105758
// ComTurnXY ( unit , x , y ) ;
105739: LD_VAR 0 1
105743: PPUSH
105744: LD_VAR 0 4
105748: PPUSH
105749: LD_VAR 0 5
105753: PPUSH
105754: CALL_OW 118
// end ;
105758: LD_VAR 0 3
105762: RET
// export function SeeUnits ( side , units ) ; var i ; begin
105763: LD_INT 0
105765: PPUSH
105766: PPUSH
// result := false ;
105767: LD_ADDR_VAR 0 3
105771: PUSH
105772: LD_INT 0
105774: ST_TO_ADDR
// if not units then
105775: LD_VAR 0 2
105779: NOT
105780: IFFALSE 105784
// exit ;
105782: GO 105829
// for i in units do
105784: LD_ADDR_VAR 0 4
105788: PUSH
105789: LD_VAR 0 2
105793: PUSH
105794: FOR_IN
105795: IFFALSE 105827
// if See ( side , i ) then
105797: LD_VAR 0 1
105801: PPUSH
105802: LD_VAR 0 4
105806: PPUSH
105807: CALL_OW 292
105811: IFFALSE 105825
// begin result := true ;
105813: LD_ADDR_VAR 0 3
105817: PUSH
105818: LD_INT 1
105820: ST_TO_ADDR
// exit ;
105821: POP
105822: POP
105823: GO 105829
// end ;
105825: GO 105794
105827: POP
105828: POP
// end ;
105829: LD_VAR 0 3
105833: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
105834: LD_INT 0
105836: PPUSH
105837: PPUSH
105838: PPUSH
105839: PPUSH
// if not unit or not points then
105840: LD_VAR 0 1
105844: NOT
105845: PUSH
105846: LD_VAR 0 2
105850: NOT
105851: OR
105852: IFFALSE 105856
// exit ;
105854: GO 105946
// dist := 99999 ;
105856: LD_ADDR_VAR 0 5
105860: PUSH
105861: LD_INT 99999
105863: ST_TO_ADDR
// for i in points do
105864: LD_ADDR_VAR 0 4
105868: PUSH
105869: LD_VAR 0 2
105873: PUSH
105874: FOR_IN
105875: IFFALSE 105944
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
105877: LD_ADDR_VAR 0 6
105881: PUSH
105882: LD_VAR 0 1
105886: PPUSH
105887: LD_VAR 0 4
105891: PUSH
105892: LD_INT 1
105894: ARRAY
105895: PPUSH
105896: LD_VAR 0 4
105900: PUSH
105901: LD_INT 2
105903: ARRAY
105904: PPUSH
105905: CALL_OW 297
105909: ST_TO_ADDR
// if tmpDist < dist then
105910: LD_VAR 0 6
105914: PUSH
105915: LD_VAR 0 5
105919: LESS
105920: IFFALSE 105942
// begin result := i ;
105922: LD_ADDR_VAR 0 3
105926: PUSH
105927: LD_VAR 0 4
105931: ST_TO_ADDR
// dist := tmpDist ;
105932: LD_ADDR_VAR 0 5
105936: PUSH
105937: LD_VAR 0 6
105941: ST_TO_ADDR
// end ; end ;
105942: GO 105874
105944: POP
105945: POP
// end ;
105946: LD_VAR 0 3
105950: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
105951: LD_INT 0
105953: PPUSH
// uc_side := side ;
105954: LD_ADDR_OWVAR 20
105958: PUSH
105959: LD_VAR 0 1
105963: ST_TO_ADDR
// uc_nation := 3 ;
105964: LD_ADDR_OWVAR 21
105968: PUSH
105969: LD_INT 3
105971: ST_TO_ADDR
// vc_chassis := 25 ;
105972: LD_ADDR_OWVAR 37
105976: PUSH
105977: LD_INT 25
105979: ST_TO_ADDR
// vc_engine := engine_siberite ;
105980: LD_ADDR_OWVAR 39
105984: PUSH
105985: LD_INT 3
105987: ST_TO_ADDR
// vc_control := control_computer ;
105988: LD_ADDR_OWVAR 38
105992: PUSH
105993: LD_INT 3
105995: ST_TO_ADDR
// vc_weapon := 59 ;
105996: LD_ADDR_OWVAR 40
106000: PUSH
106001: LD_INT 59
106003: ST_TO_ADDR
// result := CreateVehicle ;
106004: LD_ADDR_VAR 0 5
106008: PUSH
106009: CALL_OW 45
106013: ST_TO_ADDR
// SetDir ( result , d ) ;
106014: LD_VAR 0 5
106018: PPUSH
106019: LD_VAR 0 4
106023: PPUSH
106024: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
106028: LD_VAR 0 5
106032: PPUSH
106033: LD_VAR 0 2
106037: PPUSH
106038: LD_VAR 0 3
106042: PPUSH
106043: LD_INT 0
106045: PPUSH
106046: CALL_OW 48
// end ; end_of_file end_of_file
106050: LD_VAR 0 5
106054: RET
// every 0 0$1 do
106055: GO 106057
106057: DISABLE
// begin enable ;
106058: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
106059: LD_STRING updateTimer(
106061: PUSH
106062: LD_OWVAR 1
106066: STR
106067: PUSH
106068: LD_STRING );
106070: STR
106071: PPUSH
106072: CALL_OW 559
// end ;
106076: END
// export function SOS_MapStart ( ) ; begin
106077: LD_INT 0
106079: PPUSH
// if streamModeActive then
106080: LD_EXP 161
106084: IFFALSE 106093
// DefineStreamItems ( true ) ;
106086: LD_INT 1
106088: PPUSH
106089: CALL 107743 0 1
// UpdateFactoryWaypoints ( ) ;
106093: CALL 121327 0 0
// end ;
106097: LD_VAR 0 1
106101: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106102: LD_INT 0
106104: PPUSH
// if p2 = 100 then
106105: LD_VAR 0 2
106109: PUSH
106110: LD_INT 100
106112: EQUAL
106113: IFFALSE 107116
// begin if not StreamModeActive then
106115: LD_EXP 161
106119: NOT
106120: IFFALSE 106130
// StreamModeActive := true ;
106122: LD_ADDR_EXP 161
106126: PUSH
106127: LD_INT 1
106129: ST_TO_ADDR
// if p3 = 0 then
106130: LD_VAR 0 3
106134: PUSH
106135: LD_INT 0
106137: EQUAL
106138: IFFALSE 106144
// InitStreamMode ;
106140: CALL 107279 0 0
// if p3 = 1 then
106144: LD_VAR 0 3
106148: PUSH
106149: LD_INT 1
106151: EQUAL
106152: IFFALSE 106162
// sRocket := true ;
106154: LD_ADDR_EXP 166
106158: PUSH
106159: LD_INT 1
106161: ST_TO_ADDR
// if p3 = 2 then
106162: LD_VAR 0 3
106166: PUSH
106167: LD_INT 2
106169: EQUAL
106170: IFFALSE 106180
// sSpeed := true ;
106172: LD_ADDR_EXP 165
106176: PUSH
106177: LD_INT 1
106179: ST_TO_ADDR
// if p3 = 3 then
106180: LD_VAR 0 3
106184: PUSH
106185: LD_INT 3
106187: EQUAL
106188: IFFALSE 106198
// sEngine := true ;
106190: LD_ADDR_EXP 167
106194: PUSH
106195: LD_INT 1
106197: ST_TO_ADDR
// if p3 = 4 then
106198: LD_VAR 0 3
106202: PUSH
106203: LD_INT 4
106205: EQUAL
106206: IFFALSE 106216
// sSpec := true ;
106208: LD_ADDR_EXP 164
106212: PUSH
106213: LD_INT 1
106215: ST_TO_ADDR
// if p3 = 5 then
106216: LD_VAR 0 3
106220: PUSH
106221: LD_INT 5
106223: EQUAL
106224: IFFALSE 106234
// sLevel := true ;
106226: LD_ADDR_EXP 168
106230: PUSH
106231: LD_INT 1
106233: ST_TO_ADDR
// if p3 = 6 then
106234: LD_VAR 0 3
106238: PUSH
106239: LD_INT 6
106241: EQUAL
106242: IFFALSE 106252
// sArmoury := true ;
106244: LD_ADDR_EXP 169
106248: PUSH
106249: LD_INT 1
106251: ST_TO_ADDR
// if p3 = 7 then
106252: LD_VAR 0 3
106256: PUSH
106257: LD_INT 7
106259: EQUAL
106260: IFFALSE 106270
// sRadar := true ;
106262: LD_ADDR_EXP 170
106266: PUSH
106267: LD_INT 1
106269: ST_TO_ADDR
// if p3 = 8 then
106270: LD_VAR 0 3
106274: PUSH
106275: LD_INT 8
106277: EQUAL
106278: IFFALSE 106288
// sBunker := true ;
106280: LD_ADDR_EXP 171
106284: PUSH
106285: LD_INT 1
106287: ST_TO_ADDR
// if p3 = 9 then
106288: LD_VAR 0 3
106292: PUSH
106293: LD_INT 9
106295: EQUAL
106296: IFFALSE 106306
// sHack := true ;
106298: LD_ADDR_EXP 172
106302: PUSH
106303: LD_INT 1
106305: ST_TO_ADDR
// if p3 = 10 then
106306: LD_VAR 0 3
106310: PUSH
106311: LD_INT 10
106313: EQUAL
106314: IFFALSE 106324
// sFire := true ;
106316: LD_ADDR_EXP 173
106320: PUSH
106321: LD_INT 1
106323: ST_TO_ADDR
// if p3 = 11 then
106324: LD_VAR 0 3
106328: PUSH
106329: LD_INT 11
106331: EQUAL
106332: IFFALSE 106342
// sRefresh := true ;
106334: LD_ADDR_EXP 174
106338: PUSH
106339: LD_INT 1
106341: ST_TO_ADDR
// if p3 = 12 then
106342: LD_VAR 0 3
106346: PUSH
106347: LD_INT 12
106349: EQUAL
106350: IFFALSE 106360
// sExp := true ;
106352: LD_ADDR_EXP 175
106356: PUSH
106357: LD_INT 1
106359: ST_TO_ADDR
// if p3 = 13 then
106360: LD_VAR 0 3
106364: PUSH
106365: LD_INT 13
106367: EQUAL
106368: IFFALSE 106378
// sDepot := true ;
106370: LD_ADDR_EXP 176
106374: PUSH
106375: LD_INT 1
106377: ST_TO_ADDR
// if p3 = 14 then
106378: LD_VAR 0 3
106382: PUSH
106383: LD_INT 14
106385: EQUAL
106386: IFFALSE 106396
// sFlag := true ;
106388: LD_ADDR_EXP 177
106392: PUSH
106393: LD_INT 1
106395: ST_TO_ADDR
// if p3 = 15 then
106396: LD_VAR 0 3
106400: PUSH
106401: LD_INT 15
106403: EQUAL
106404: IFFALSE 106414
// sKamikadze := true ;
106406: LD_ADDR_EXP 185
106410: PUSH
106411: LD_INT 1
106413: ST_TO_ADDR
// if p3 = 16 then
106414: LD_VAR 0 3
106418: PUSH
106419: LD_INT 16
106421: EQUAL
106422: IFFALSE 106432
// sTroll := true ;
106424: LD_ADDR_EXP 186
106428: PUSH
106429: LD_INT 1
106431: ST_TO_ADDR
// if p3 = 17 then
106432: LD_VAR 0 3
106436: PUSH
106437: LD_INT 17
106439: EQUAL
106440: IFFALSE 106450
// sSlow := true ;
106442: LD_ADDR_EXP 187
106446: PUSH
106447: LD_INT 1
106449: ST_TO_ADDR
// if p3 = 18 then
106450: LD_VAR 0 3
106454: PUSH
106455: LD_INT 18
106457: EQUAL
106458: IFFALSE 106468
// sLack := true ;
106460: LD_ADDR_EXP 188
106464: PUSH
106465: LD_INT 1
106467: ST_TO_ADDR
// if p3 = 19 then
106468: LD_VAR 0 3
106472: PUSH
106473: LD_INT 19
106475: EQUAL
106476: IFFALSE 106486
// sTank := true ;
106478: LD_ADDR_EXP 190
106482: PUSH
106483: LD_INT 1
106485: ST_TO_ADDR
// if p3 = 20 then
106486: LD_VAR 0 3
106490: PUSH
106491: LD_INT 20
106493: EQUAL
106494: IFFALSE 106504
// sRemote := true ;
106496: LD_ADDR_EXP 191
106500: PUSH
106501: LD_INT 1
106503: ST_TO_ADDR
// if p3 = 21 then
106504: LD_VAR 0 3
106508: PUSH
106509: LD_INT 21
106511: EQUAL
106512: IFFALSE 106522
// sPowell := true ;
106514: LD_ADDR_EXP 192
106518: PUSH
106519: LD_INT 1
106521: ST_TO_ADDR
// if p3 = 22 then
106522: LD_VAR 0 3
106526: PUSH
106527: LD_INT 22
106529: EQUAL
106530: IFFALSE 106540
// sTeleport := true ;
106532: LD_ADDR_EXP 195
106536: PUSH
106537: LD_INT 1
106539: ST_TO_ADDR
// if p3 = 23 then
106540: LD_VAR 0 3
106544: PUSH
106545: LD_INT 23
106547: EQUAL
106548: IFFALSE 106558
// sOilTower := true ;
106550: LD_ADDR_EXP 197
106554: PUSH
106555: LD_INT 1
106557: ST_TO_ADDR
// if p3 = 24 then
106558: LD_VAR 0 3
106562: PUSH
106563: LD_INT 24
106565: EQUAL
106566: IFFALSE 106576
// sShovel := true ;
106568: LD_ADDR_EXP 198
106572: PUSH
106573: LD_INT 1
106575: ST_TO_ADDR
// if p3 = 25 then
106576: LD_VAR 0 3
106580: PUSH
106581: LD_INT 25
106583: EQUAL
106584: IFFALSE 106594
// sSheik := true ;
106586: LD_ADDR_EXP 199
106590: PUSH
106591: LD_INT 1
106593: ST_TO_ADDR
// if p3 = 26 then
106594: LD_VAR 0 3
106598: PUSH
106599: LD_INT 26
106601: EQUAL
106602: IFFALSE 106612
// sEarthquake := true ;
106604: LD_ADDR_EXP 201
106608: PUSH
106609: LD_INT 1
106611: ST_TO_ADDR
// if p3 = 27 then
106612: LD_VAR 0 3
106616: PUSH
106617: LD_INT 27
106619: EQUAL
106620: IFFALSE 106630
// sAI := true ;
106622: LD_ADDR_EXP 202
106626: PUSH
106627: LD_INT 1
106629: ST_TO_ADDR
// if p3 = 28 then
106630: LD_VAR 0 3
106634: PUSH
106635: LD_INT 28
106637: EQUAL
106638: IFFALSE 106648
// sCargo := true ;
106640: LD_ADDR_EXP 205
106644: PUSH
106645: LD_INT 1
106647: ST_TO_ADDR
// if p3 = 29 then
106648: LD_VAR 0 3
106652: PUSH
106653: LD_INT 29
106655: EQUAL
106656: IFFALSE 106666
// sDLaser := true ;
106658: LD_ADDR_EXP 206
106662: PUSH
106663: LD_INT 1
106665: ST_TO_ADDR
// if p3 = 30 then
106666: LD_VAR 0 3
106670: PUSH
106671: LD_INT 30
106673: EQUAL
106674: IFFALSE 106684
// sExchange := true ;
106676: LD_ADDR_EXP 207
106680: PUSH
106681: LD_INT 1
106683: ST_TO_ADDR
// if p3 = 31 then
106684: LD_VAR 0 3
106688: PUSH
106689: LD_INT 31
106691: EQUAL
106692: IFFALSE 106702
// sFac := true ;
106694: LD_ADDR_EXP 208
106698: PUSH
106699: LD_INT 1
106701: ST_TO_ADDR
// if p3 = 32 then
106702: LD_VAR 0 3
106706: PUSH
106707: LD_INT 32
106709: EQUAL
106710: IFFALSE 106720
// sPower := true ;
106712: LD_ADDR_EXP 209
106716: PUSH
106717: LD_INT 1
106719: ST_TO_ADDR
// if p3 = 33 then
106720: LD_VAR 0 3
106724: PUSH
106725: LD_INT 33
106727: EQUAL
106728: IFFALSE 106738
// sRandom := true ;
106730: LD_ADDR_EXP 210
106734: PUSH
106735: LD_INT 1
106737: ST_TO_ADDR
// if p3 = 34 then
106738: LD_VAR 0 3
106742: PUSH
106743: LD_INT 34
106745: EQUAL
106746: IFFALSE 106756
// sShield := true ;
106748: LD_ADDR_EXP 211
106752: PUSH
106753: LD_INT 1
106755: ST_TO_ADDR
// if p3 = 35 then
106756: LD_VAR 0 3
106760: PUSH
106761: LD_INT 35
106763: EQUAL
106764: IFFALSE 106774
// sTime := true ;
106766: LD_ADDR_EXP 212
106770: PUSH
106771: LD_INT 1
106773: ST_TO_ADDR
// if p3 = 36 then
106774: LD_VAR 0 3
106778: PUSH
106779: LD_INT 36
106781: EQUAL
106782: IFFALSE 106792
// sTools := true ;
106784: LD_ADDR_EXP 213
106788: PUSH
106789: LD_INT 1
106791: ST_TO_ADDR
// if p3 = 101 then
106792: LD_VAR 0 3
106796: PUSH
106797: LD_INT 101
106799: EQUAL
106800: IFFALSE 106810
// sSold := true ;
106802: LD_ADDR_EXP 178
106806: PUSH
106807: LD_INT 1
106809: ST_TO_ADDR
// if p3 = 102 then
106810: LD_VAR 0 3
106814: PUSH
106815: LD_INT 102
106817: EQUAL
106818: IFFALSE 106828
// sDiff := true ;
106820: LD_ADDR_EXP 179
106824: PUSH
106825: LD_INT 1
106827: ST_TO_ADDR
// if p3 = 103 then
106828: LD_VAR 0 3
106832: PUSH
106833: LD_INT 103
106835: EQUAL
106836: IFFALSE 106846
// sFog := true ;
106838: LD_ADDR_EXP 182
106842: PUSH
106843: LD_INT 1
106845: ST_TO_ADDR
// if p3 = 104 then
106846: LD_VAR 0 3
106850: PUSH
106851: LD_INT 104
106853: EQUAL
106854: IFFALSE 106864
// sReset := true ;
106856: LD_ADDR_EXP 183
106860: PUSH
106861: LD_INT 1
106863: ST_TO_ADDR
// if p3 = 105 then
106864: LD_VAR 0 3
106868: PUSH
106869: LD_INT 105
106871: EQUAL
106872: IFFALSE 106882
// sSun := true ;
106874: LD_ADDR_EXP 184
106878: PUSH
106879: LD_INT 1
106881: ST_TO_ADDR
// if p3 = 106 then
106882: LD_VAR 0 3
106886: PUSH
106887: LD_INT 106
106889: EQUAL
106890: IFFALSE 106900
// sTiger := true ;
106892: LD_ADDR_EXP 180
106896: PUSH
106897: LD_INT 1
106899: ST_TO_ADDR
// if p3 = 107 then
106900: LD_VAR 0 3
106904: PUSH
106905: LD_INT 107
106907: EQUAL
106908: IFFALSE 106918
// sBomb := true ;
106910: LD_ADDR_EXP 181
106914: PUSH
106915: LD_INT 1
106917: ST_TO_ADDR
// if p3 = 108 then
106918: LD_VAR 0 3
106922: PUSH
106923: LD_INT 108
106925: EQUAL
106926: IFFALSE 106936
// sWound := true ;
106928: LD_ADDR_EXP 189
106932: PUSH
106933: LD_INT 1
106935: ST_TO_ADDR
// if p3 = 109 then
106936: LD_VAR 0 3
106940: PUSH
106941: LD_INT 109
106943: EQUAL
106944: IFFALSE 106954
// sBetray := true ;
106946: LD_ADDR_EXP 193
106950: PUSH
106951: LD_INT 1
106953: ST_TO_ADDR
// if p3 = 110 then
106954: LD_VAR 0 3
106958: PUSH
106959: LD_INT 110
106961: EQUAL
106962: IFFALSE 106972
// sContamin := true ;
106964: LD_ADDR_EXP 194
106968: PUSH
106969: LD_INT 1
106971: ST_TO_ADDR
// if p3 = 111 then
106972: LD_VAR 0 3
106976: PUSH
106977: LD_INT 111
106979: EQUAL
106980: IFFALSE 106990
// sOil := true ;
106982: LD_ADDR_EXP 196
106986: PUSH
106987: LD_INT 1
106989: ST_TO_ADDR
// if p3 = 112 then
106990: LD_VAR 0 3
106994: PUSH
106995: LD_INT 112
106997: EQUAL
106998: IFFALSE 107008
// sStu := true ;
107000: LD_ADDR_EXP 200
107004: PUSH
107005: LD_INT 1
107007: ST_TO_ADDR
// if p3 = 113 then
107008: LD_VAR 0 3
107012: PUSH
107013: LD_INT 113
107015: EQUAL
107016: IFFALSE 107026
// sBazooka := true ;
107018: LD_ADDR_EXP 203
107022: PUSH
107023: LD_INT 1
107025: ST_TO_ADDR
// if p3 = 114 then
107026: LD_VAR 0 3
107030: PUSH
107031: LD_INT 114
107033: EQUAL
107034: IFFALSE 107044
// sMortar := true ;
107036: LD_ADDR_EXP 204
107040: PUSH
107041: LD_INT 1
107043: ST_TO_ADDR
// if p3 = 115 then
107044: LD_VAR 0 3
107048: PUSH
107049: LD_INT 115
107051: EQUAL
107052: IFFALSE 107062
// sRanger := true ;
107054: LD_ADDR_EXP 214
107058: PUSH
107059: LD_INT 1
107061: ST_TO_ADDR
// if p3 = 116 then
107062: LD_VAR 0 3
107066: PUSH
107067: LD_INT 116
107069: EQUAL
107070: IFFALSE 107080
// sComputer := true ;
107072: LD_ADDR_EXP 215
107076: PUSH
107077: LD_INT 1
107079: ST_TO_ADDR
// if p3 = 117 then
107080: LD_VAR 0 3
107084: PUSH
107085: LD_INT 117
107087: EQUAL
107088: IFFALSE 107098
// s30 := true ;
107090: LD_ADDR_EXP 216
107094: PUSH
107095: LD_INT 1
107097: ST_TO_ADDR
// if p3 = 118 then
107098: LD_VAR 0 3
107102: PUSH
107103: LD_INT 118
107105: EQUAL
107106: IFFALSE 107116
// s60 := true ;
107108: LD_ADDR_EXP 217
107112: PUSH
107113: LD_INT 1
107115: ST_TO_ADDR
// end ; if p2 = 101 then
107116: LD_VAR 0 2
107120: PUSH
107121: LD_INT 101
107123: EQUAL
107124: IFFALSE 107252
// begin case p3 of 1 :
107126: LD_VAR 0 3
107130: PUSH
107131: LD_INT 1
107133: DOUBLE
107134: EQUAL
107135: IFTRUE 107139
107137: GO 107146
107139: POP
// hHackUnlimitedResources ; 2 :
107140: CALL 119350 0 0
107144: GO 107252
107146: LD_INT 2
107148: DOUBLE
107149: EQUAL
107150: IFTRUE 107154
107152: GO 107161
107154: POP
// hHackSetLevel10 ; 3 :
107155: CALL 119483 0 0
107159: GO 107252
107161: LD_INT 3
107163: DOUBLE
107164: EQUAL
107165: IFTRUE 107169
107167: GO 107176
107169: POP
// hHackSetLevel10YourUnits ; 4 :
107170: CALL 119568 0 0
107174: GO 107252
107176: LD_INT 4
107178: DOUBLE
107179: EQUAL
107180: IFTRUE 107184
107182: GO 107191
107184: POP
// hHackInvincible ; 5 :
107185: CALL 120016 0 0
107189: GO 107252
107191: LD_INT 5
107193: DOUBLE
107194: EQUAL
107195: IFTRUE 107199
107197: GO 107206
107199: POP
// hHackInvisible ; 6 :
107200: CALL 120127 0 0
107204: GO 107252
107206: LD_INT 6
107208: DOUBLE
107209: EQUAL
107210: IFTRUE 107214
107212: GO 107221
107214: POP
// hHackChangeYourSide ; 7 :
107215: CALL 120184 0 0
107219: GO 107252
107221: LD_INT 7
107223: DOUBLE
107224: EQUAL
107225: IFTRUE 107229
107227: GO 107236
107229: POP
// hHackChangeUnitSide ; 8 :
107230: CALL 120226 0 0
107234: GO 107252
107236: LD_INT 8
107238: DOUBLE
107239: EQUAL
107240: IFTRUE 107244
107242: GO 107251
107244: POP
// hHackFog ; end ;
107245: CALL 120327 0 0
107249: GO 107252
107251: POP
// end ; end ;
107252: LD_VAR 0 7
107256: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
107257: GO 107259
107259: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
107260: LD_STRING initStreamRollete();
107262: PPUSH
107263: CALL_OW 559
// InitStreamMode ;
107267: CALL 107279 0 0
// DefineStreamItems ( false ) ;
107271: LD_INT 0
107273: PPUSH
107274: CALL 107743 0 1
// end ;
107278: END
// function InitStreamMode ; begin
107279: LD_INT 0
107281: PPUSH
// streamModeActive := false ;
107282: LD_ADDR_EXP 161
107286: PUSH
107287: LD_INT 0
107289: ST_TO_ADDR
// normalCounter := 36 ;
107290: LD_ADDR_EXP 162
107294: PUSH
107295: LD_INT 36
107297: ST_TO_ADDR
// hardcoreCounter := 18 ;
107298: LD_ADDR_EXP 163
107302: PUSH
107303: LD_INT 18
107305: ST_TO_ADDR
// sRocket := false ;
107306: LD_ADDR_EXP 166
107310: PUSH
107311: LD_INT 0
107313: ST_TO_ADDR
// sSpeed := false ;
107314: LD_ADDR_EXP 165
107318: PUSH
107319: LD_INT 0
107321: ST_TO_ADDR
// sEngine := false ;
107322: LD_ADDR_EXP 167
107326: PUSH
107327: LD_INT 0
107329: ST_TO_ADDR
// sSpec := false ;
107330: LD_ADDR_EXP 164
107334: PUSH
107335: LD_INT 0
107337: ST_TO_ADDR
// sLevel := false ;
107338: LD_ADDR_EXP 168
107342: PUSH
107343: LD_INT 0
107345: ST_TO_ADDR
// sArmoury := false ;
107346: LD_ADDR_EXP 169
107350: PUSH
107351: LD_INT 0
107353: ST_TO_ADDR
// sRadar := false ;
107354: LD_ADDR_EXP 170
107358: PUSH
107359: LD_INT 0
107361: ST_TO_ADDR
// sBunker := false ;
107362: LD_ADDR_EXP 171
107366: PUSH
107367: LD_INT 0
107369: ST_TO_ADDR
// sHack := false ;
107370: LD_ADDR_EXP 172
107374: PUSH
107375: LD_INT 0
107377: ST_TO_ADDR
// sFire := false ;
107378: LD_ADDR_EXP 173
107382: PUSH
107383: LD_INT 0
107385: ST_TO_ADDR
// sRefresh := false ;
107386: LD_ADDR_EXP 174
107390: PUSH
107391: LD_INT 0
107393: ST_TO_ADDR
// sExp := false ;
107394: LD_ADDR_EXP 175
107398: PUSH
107399: LD_INT 0
107401: ST_TO_ADDR
// sDepot := false ;
107402: LD_ADDR_EXP 176
107406: PUSH
107407: LD_INT 0
107409: ST_TO_ADDR
// sFlag := false ;
107410: LD_ADDR_EXP 177
107414: PUSH
107415: LD_INT 0
107417: ST_TO_ADDR
// sKamikadze := false ;
107418: LD_ADDR_EXP 185
107422: PUSH
107423: LD_INT 0
107425: ST_TO_ADDR
// sTroll := false ;
107426: LD_ADDR_EXP 186
107430: PUSH
107431: LD_INT 0
107433: ST_TO_ADDR
// sSlow := false ;
107434: LD_ADDR_EXP 187
107438: PUSH
107439: LD_INT 0
107441: ST_TO_ADDR
// sLack := false ;
107442: LD_ADDR_EXP 188
107446: PUSH
107447: LD_INT 0
107449: ST_TO_ADDR
// sTank := false ;
107450: LD_ADDR_EXP 190
107454: PUSH
107455: LD_INT 0
107457: ST_TO_ADDR
// sRemote := false ;
107458: LD_ADDR_EXP 191
107462: PUSH
107463: LD_INT 0
107465: ST_TO_ADDR
// sPowell := false ;
107466: LD_ADDR_EXP 192
107470: PUSH
107471: LD_INT 0
107473: ST_TO_ADDR
// sTeleport := false ;
107474: LD_ADDR_EXP 195
107478: PUSH
107479: LD_INT 0
107481: ST_TO_ADDR
// sOilTower := false ;
107482: LD_ADDR_EXP 197
107486: PUSH
107487: LD_INT 0
107489: ST_TO_ADDR
// sShovel := false ;
107490: LD_ADDR_EXP 198
107494: PUSH
107495: LD_INT 0
107497: ST_TO_ADDR
// sSheik := false ;
107498: LD_ADDR_EXP 199
107502: PUSH
107503: LD_INT 0
107505: ST_TO_ADDR
// sEarthquake := false ;
107506: LD_ADDR_EXP 201
107510: PUSH
107511: LD_INT 0
107513: ST_TO_ADDR
// sAI := false ;
107514: LD_ADDR_EXP 202
107518: PUSH
107519: LD_INT 0
107521: ST_TO_ADDR
// sCargo := false ;
107522: LD_ADDR_EXP 205
107526: PUSH
107527: LD_INT 0
107529: ST_TO_ADDR
// sDLaser := false ;
107530: LD_ADDR_EXP 206
107534: PUSH
107535: LD_INT 0
107537: ST_TO_ADDR
// sExchange := false ;
107538: LD_ADDR_EXP 207
107542: PUSH
107543: LD_INT 0
107545: ST_TO_ADDR
// sFac := false ;
107546: LD_ADDR_EXP 208
107550: PUSH
107551: LD_INT 0
107553: ST_TO_ADDR
// sPower := false ;
107554: LD_ADDR_EXP 209
107558: PUSH
107559: LD_INT 0
107561: ST_TO_ADDR
// sRandom := false ;
107562: LD_ADDR_EXP 210
107566: PUSH
107567: LD_INT 0
107569: ST_TO_ADDR
// sShield := false ;
107570: LD_ADDR_EXP 211
107574: PUSH
107575: LD_INT 0
107577: ST_TO_ADDR
// sTime := false ;
107578: LD_ADDR_EXP 212
107582: PUSH
107583: LD_INT 0
107585: ST_TO_ADDR
// sTools := false ;
107586: LD_ADDR_EXP 213
107590: PUSH
107591: LD_INT 0
107593: ST_TO_ADDR
// sSold := false ;
107594: LD_ADDR_EXP 178
107598: PUSH
107599: LD_INT 0
107601: ST_TO_ADDR
// sDiff := false ;
107602: LD_ADDR_EXP 179
107606: PUSH
107607: LD_INT 0
107609: ST_TO_ADDR
// sFog := false ;
107610: LD_ADDR_EXP 182
107614: PUSH
107615: LD_INT 0
107617: ST_TO_ADDR
// sReset := false ;
107618: LD_ADDR_EXP 183
107622: PUSH
107623: LD_INT 0
107625: ST_TO_ADDR
// sSun := false ;
107626: LD_ADDR_EXP 184
107630: PUSH
107631: LD_INT 0
107633: ST_TO_ADDR
// sTiger := false ;
107634: LD_ADDR_EXP 180
107638: PUSH
107639: LD_INT 0
107641: ST_TO_ADDR
// sBomb := false ;
107642: LD_ADDR_EXP 181
107646: PUSH
107647: LD_INT 0
107649: ST_TO_ADDR
// sWound := false ;
107650: LD_ADDR_EXP 189
107654: PUSH
107655: LD_INT 0
107657: ST_TO_ADDR
// sBetray := false ;
107658: LD_ADDR_EXP 193
107662: PUSH
107663: LD_INT 0
107665: ST_TO_ADDR
// sContamin := false ;
107666: LD_ADDR_EXP 194
107670: PUSH
107671: LD_INT 0
107673: ST_TO_ADDR
// sOil := false ;
107674: LD_ADDR_EXP 196
107678: PUSH
107679: LD_INT 0
107681: ST_TO_ADDR
// sStu := false ;
107682: LD_ADDR_EXP 200
107686: PUSH
107687: LD_INT 0
107689: ST_TO_ADDR
// sBazooka := false ;
107690: LD_ADDR_EXP 203
107694: PUSH
107695: LD_INT 0
107697: ST_TO_ADDR
// sMortar := false ;
107698: LD_ADDR_EXP 204
107702: PUSH
107703: LD_INT 0
107705: ST_TO_ADDR
// sRanger := false ;
107706: LD_ADDR_EXP 214
107710: PUSH
107711: LD_INT 0
107713: ST_TO_ADDR
// sComputer := false ;
107714: LD_ADDR_EXP 215
107718: PUSH
107719: LD_INT 0
107721: ST_TO_ADDR
// s30 := false ;
107722: LD_ADDR_EXP 216
107726: PUSH
107727: LD_INT 0
107729: ST_TO_ADDR
// s60 := false ;
107730: LD_ADDR_EXP 217
107734: PUSH
107735: LD_INT 0
107737: ST_TO_ADDR
// end ;
107738: LD_VAR 0 1
107742: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
107743: LD_INT 0
107745: PPUSH
107746: PPUSH
107747: PPUSH
107748: PPUSH
107749: PPUSH
107750: PPUSH
107751: PPUSH
// result := [ ] ;
107752: LD_ADDR_VAR 0 2
107756: PUSH
107757: EMPTY
107758: ST_TO_ADDR
// if campaign_id = 1 then
107759: LD_OWVAR 69
107763: PUSH
107764: LD_INT 1
107766: EQUAL
107767: IFFALSE 110933
// begin case mission_number of 1 :
107769: LD_OWVAR 70
107773: PUSH
107774: LD_INT 1
107776: DOUBLE
107777: EQUAL
107778: IFTRUE 107782
107780: GO 107858
107782: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
107783: LD_ADDR_VAR 0 2
107787: PUSH
107788: LD_INT 2
107790: PUSH
107791: LD_INT 4
107793: PUSH
107794: LD_INT 11
107796: PUSH
107797: LD_INT 12
107799: PUSH
107800: LD_INT 15
107802: PUSH
107803: LD_INT 16
107805: PUSH
107806: LD_INT 22
107808: PUSH
107809: LD_INT 23
107811: PUSH
107812: LD_INT 26
107814: PUSH
107815: EMPTY
107816: LIST
107817: LIST
107818: LIST
107819: LIST
107820: LIST
107821: LIST
107822: LIST
107823: LIST
107824: LIST
107825: PUSH
107826: LD_INT 101
107828: PUSH
107829: LD_INT 102
107831: PUSH
107832: LD_INT 106
107834: PUSH
107835: LD_INT 116
107837: PUSH
107838: LD_INT 117
107840: PUSH
107841: LD_INT 118
107843: PUSH
107844: EMPTY
107845: LIST
107846: LIST
107847: LIST
107848: LIST
107849: LIST
107850: LIST
107851: PUSH
107852: EMPTY
107853: LIST
107854: LIST
107855: ST_TO_ADDR
107856: GO 110931
107858: LD_INT 2
107860: DOUBLE
107861: EQUAL
107862: IFTRUE 107866
107864: GO 107950
107866: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
107867: LD_ADDR_VAR 0 2
107871: PUSH
107872: LD_INT 2
107874: PUSH
107875: LD_INT 4
107877: PUSH
107878: LD_INT 11
107880: PUSH
107881: LD_INT 12
107883: PUSH
107884: LD_INT 15
107886: PUSH
107887: LD_INT 16
107889: PUSH
107890: LD_INT 22
107892: PUSH
107893: LD_INT 23
107895: PUSH
107896: LD_INT 26
107898: PUSH
107899: EMPTY
107900: LIST
107901: LIST
107902: LIST
107903: LIST
107904: LIST
107905: LIST
107906: LIST
107907: LIST
107908: LIST
107909: PUSH
107910: LD_INT 101
107912: PUSH
107913: LD_INT 102
107915: PUSH
107916: LD_INT 105
107918: PUSH
107919: LD_INT 106
107921: PUSH
107922: LD_INT 108
107924: PUSH
107925: LD_INT 116
107927: PUSH
107928: LD_INT 117
107930: PUSH
107931: LD_INT 118
107933: PUSH
107934: EMPTY
107935: LIST
107936: LIST
107937: LIST
107938: LIST
107939: LIST
107940: LIST
107941: LIST
107942: LIST
107943: PUSH
107944: EMPTY
107945: LIST
107946: LIST
107947: ST_TO_ADDR
107948: GO 110931
107950: LD_INT 3
107952: DOUBLE
107953: EQUAL
107954: IFTRUE 107958
107956: GO 108046
107958: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
107959: LD_ADDR_VAR 0 2
107963: PUSH
107964: LD_INT 2
107966: PUSH
107967: LD_INT 4
107969: PUSH
107970: LD_INT 5
107972: PUSH
107973: LD_INT 11
107975: PUSH
107976: LD_INT 12
107978: PUSH
107979: LD_INT 15
107981: PUSH
107982: LD_INT 16
107984: PUSH
107985: LD_INT 22
107987: PUSH
107988: LD_INT 26
107990: PUSH
107991: LD_INT 36
107993: PUSH
107994: EMPTY
107995: LIST
107996: LIST
107997: LIST
107998: LIST
107999: LIST
108000: LIST
108001: LIST
108002: LIST
108003: LIST
108004: LIST
108005: PUSH
108006: LD_INT 101
108008: PUSH
108009: LD_INT 102
108011: PUSH
108012: LD_INT 105
108014: PUSH
108015: LD_INT 106
108017: PUSH
108018: LD_INT 108
108020: PUSH
108021: LD_INT 116
108023: PUSH
108024: LD_INT 117
108026: PUSH
108027: LD_INT 118
108029: PUSH
108030: EMPTY
108031: LIST
108032: LIST
108033: LIST
108034: LIST
108035: LIST
108036: LIST
108037: LIST
108038: LIST
108039: PUSH
108040: EMPTY
108041: LIST
108042: LIST
108043: ST_TO_ADDR
108044: GO 110931
108046: LD_INT 4
108048: DOUBLE
108049: EQUAL
108050: IFTRUE 108054
108052: GO 108150
108054: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
108055: LD_ADDR_VAR 0 2
108059: PUSH
108060: LD_INT 2
108062: PUSH
108063: LD_INT 4
108065: PUSH
108066: LD_INT 5
108068: PUSH
108069: LD_INT 8
108071: PUSH
108072: LD_INT 11
108074: PUSH
108075: LD_INT 12
108077: PUSH
108078: LD_INT 15
108080: PUSH
108081: LD_INT 16
108083: PUSH
108084: LD_INT 22
108086: PUSH
108087: LD_INT 23
108089: PUSH
108090: LD_INT 26
108092: PUSH
108093: LD_INT 36
108095: PUSH
108096: EMPTY
108097: LIST
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: LIST
108104: LIST
108105: LIST
108106: LIST
108107: LIST
108108: LIST
108109: PUSH
108110: LD_INT 101
108112: PUSH
108113: LD_INT 102
108115: PUSH
108116: LD_INT 105
108118: PUSH
108119: LD_INT 106
108121: PUSH
108122: LD_INT 108
108124: PUSH
108125: LD_INT 116
108127: PUSH
108128: LD_INT 117
108130: PUSH
108131: LD_INT 118
108133: PUSH
108134: EMPTY
108135: LIST
108136: LIST
108137: LIST
108138: LIST
108139: LIST
108140: LIST
108141: LIST
108142: LIST
108143: PUSH
108144: EMPTY
108145: LIST
108146: LIST
108147: ST_TO_ADDR
108148: GO 110931
108150: LD_INT 5
108152: DOUBLE
108153: EQUAL
108154: IFTRUE 108158
108156: GO 108270
108158: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
108159: LD_ADDR_VAR 0 2
108163: PUSH
108164: LD_INT 2
108166: PUSH
108167: LD_INT 4
108169: PUSH
108170: LD_INT 5
108172: PUSH
108173: LD_INT 6
108175: PUSH
108176: LD_INT 8
108178: PUSH
108179: LD_INT 11
108181: PUSH
108182: LD_INT 12
108184: PUSH
108185: LD_INT 15
108187: PUSH
108188: LD_INT 16
108190: PUSH
108191: LD_INT 22
108193: PUSH
108194: LD_INT 23
108196: PUSH
108197: LD_INT 25
108199: PUSH
108200: LD_INT 26
108202: PUSH
108203: LD_INT 36
108205: PUSH
108206: EMPTY
108207: LIST
108208: LIST
108209: LIST
108210: LIST
108211: LIST
108212: LIST
108213: LIST
108214: LIST
108215: LIST
108216: LIST
108217: LIST
108218: LIST
108219: LIST
108220: LIST
108221: PUSH
108222: LD_INT 101
108224: PUSH
108225: LD_INT 102
108227: PUSH
108228: LD_INT 105
108230: PUSH
108231: LD_INT 106
108233: PUSH
108234: LD_INT 108
108236: PUSH
108237: LD_INT 109
108239: PUSH
108240: LD_INT 112
108242: PUSH
108243: LD_INT 116
108245: PUSH
108246: LD_INT 117
108248: PUSH
108249: LD_INT 118
108251: PUSH
108252: EMPTY
108253: LIST
108254: LIST
108255: LIST
108256: LIST
108257: LIST
108258: LIST
108259: LIST
108260: LIST
108261: LIST
108262: LIST
108263: PUSH
108264: EMPTY
108265: LIST
108266: LIST
108267: ST_TO_ADDR
108268: GO 110931
108270: LD_INT 6
108272: DOUBLE
108273: EQUAL
108274: IFTRUE 108278
108276: GO 108410
108278: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
108279: LD_ADDR_VAR 0 2
108283: PUSH
108284: LD_INT 2
108286: PUSH
108287: LD_INT 4
108289: PUSH
108290: LD_INT 5
108292: PUSH
108293: LD_INT 6
108295: PUSH
108296: LD_INT 8
108298: PUSH
108299: LD_INT 11
108301: PUSH
108302: LD_INT 12
108304: PUSH
108305: LD_INT 15
108307: PUSH
108308: LD_INT 16
108310: PUSH
108311: LD_INT 20
108313: PUSH
108314: LD_INT 21
108316: PUSH
108317: LD_INT 22
108319: PUSH
108320: LD_INT 23
108322: PUSH
108323: LD_INT 25
108325: PUSH
108326: LD_INT 26
108328: PUSH
108329: LD_INT 30
108331: PUSH
108332: LD_INT 31
108334: PUSH
108335: LD_INT 32
108337: PUSH
108338: LD_INT 36
108340: PUSH
108341: EMPTY
108342: LIST
108343: LIST
108344: LIST
108345: LIST
108346: LIST
108347: LIST
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: LIST
108353: LIST
108354: LIST
108355: LIST
108356: LIST
108357: LIST
108358: LIST
108359: LIST
108360: LIST
108361: PUSH
108362: LD_INT 101
108364: PUSH
108365: LD_INT 102
108367: PUSH
108368: LD_INT 105
108370: PUSH
108371: LD_INT 106
108373: PUSH
108374: LD_INT 108
108376: PUSH
108377: LD_INT 109
108379: PUSH
108380: LD_INT 112
108382: PUSH
108383: LD_INT 116
108385: PUSH
108386: LD_INT 117
108388: PUSH
108389: LD_INT 118
108391: PUSH
108392: EMPTY
108393: LIST
108394: LIST
108395: LIST
108396: LIST
108397: LIST
108398: LIST
108399: LIST
108400: LIST
108401: LIST
108402: LIST
108403: PUSH
108404: EMPTY
108405: LIST
108406: LIST
108407: ST_TO_ADDR
108408: GO 110931
108410: LD_INT 7
108412: DOUBLE
108413: EQUAL
108414: IFTRUE 108418
108416: GO 108530
108418: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
108419: LD_ADDR_VAR 0 2
108423: PUSH
108424: LD_INT 2
108426: PUSH
108427: LD_INT 4
108429: PUSH
108430: LD_INT 5
108432: PUSH
108433: LD_INT 7
108435: PUSH
108436: LD_INT 11
108438: PUSH
108439: LD_INT 12
108441: PUSH
108442: LD_INT 15
108444: PUSH
108445: LD_INT 16
108447: PUSH
108448: LD_INT 20
108450: PUSH
108451: LD_INT 21
108453: PUSH
108454: LD_INT 22
108456: PUSH
108457: LD_INT 23
108459: PUSH
108460: LD_INT 25
108462: PUSH
108463: LD_INT 26
108465: PUSH
108466: EMPTY
108467: LIST
108468: LIST
108469: LIST
108470: LIST
108471: LIST
108472: LIST
108473: LIST
108474: LIST
108475: LIST
108476: LIST
108477: LIST
108478: LIST
108479: LIST
108480: LIST
108481: PUSH
108482: LD_INT 101
108484: PUSH
108485: LD_INT 102
108487: PUSH
108488: LD_INT 103
108490: PUSH
108491: LD_INT 105
108493: PUSH
108494: LD_INT 106
108496: PUSH
108497: LD_INT 108
108499: PUSH
108500: LD_INT 112
108502: PUSH
108503: LD_INT 116
108505: PUSH
108506: LD_INT 117
108508: PUSH
108509: LD_INT 118
108511: PUSH
108512: EMPTY
108513: LIST
108514: LIST
108515: LIST
108516: LIST
108517: LIST
108518: LIST
108519: LIST
108520: LIST
108521: LIST
108522: LIST
108523: PUSH
108524: EMPTY
108525: LIST
108526: LIST
108527: ST_TO_ADDR
108528: GO 110931
108530: LD_INT 8
108532: DOUBLE
108533: EQUAL
108534: IFTRUE 108538
108536: GO 108678
108538: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
108539: LD_ADDR_VAR 0 2
108543: PUSH
108544: LD_INT 2
108546: PUSH
108547: LD_INT 4
108549: PUSH
108550: LD_INT 5
108552: PUSH
108553: LD_INT 6
108555: PUSH
108556: LD_INT 7
108558: PUSH
108559: LD_INT 8
108561: PUSH
108562: LD_INT 11
108564: PUSH
108565: LD_INT 12
108567: PUSH
108568: LD_INT 15
108570: PUSH
108571: LD_INT 16
108573: PUSH
108574: LD_INT 20
108576: PUSH
108577: LD_INT 21
108579: PUSH
108580: LD_INT 22
108582: PUSH
108583: LD_INT 23
108585: PUSH
108586: LD_INT 25
108588: PUSH
108589: LD_INT 26
108591: PUSH
108592: LD_INT 30
108594: PUSH
108595: LD_INT 31
108597: PUSH
108598: LD_INT 32
108600: PUSH
108601: LD_INT 36
108603: PUSH
108604: EMPTY
108605: LIST
108606: LIST
108607: LIST
108608: LIST
108609: LIST
108610: LIST
108611: LIST
108612: LIST
108613: LIST
108614: LIST
108615: LIST
108616: LIST
108617: LIST
108618: LIST
108619: LIST
108620: LIST
108621: LIST
108622: LIST
108623: LIST
108624: LIST
108625: PUSH
108626: LD_INT 101
108628: PUSH
108629: LD_INT 102
108631: PUSH
108632: LD_INT 103
108634: PUSH
108635: LD_INT 105
108637: PUSH
108638: LD_INT 106
108640: PUSH
108641: LD_INT 108
108643: PUSH
108644: LD_INT 109
108646: PUSH
108647: LD_INT 112
108649: PUSH
108650: LD_INT 116
108652: PUSH
108653: LD_INT 117
108655: PUSH
108656: LD_INT 118
108658: PUSH
108659: EMPTY
108660: LIST
108661: LIST
108662: LIST
108663: LIST
108664: LIST
108665: LIST
108666: LIST
108667: LIST
108668: LIST
108669: LIST
108670: LIST
108671: PUSH
108672: EMPTY
108673: LIST
108674: LIST
108675: ST_TO_ADDR
108676: GO 110931
108678: LD_INT 9
108680: DOUBLE
108681: EQUAL
108682: IFTRUE 108686
108684: GO 108834
108686: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
108687: LD_ADDR_VAR 0 2
108691: PUSH
108692: LD_INT 2
108694: PUSH
108695: LD_INT 4
108697: PUSH
108698: LD_INT 5
108700: PUSH
108701: LD_INT 6
108703: PUSH
108704: LD_INT 7
108706: PUSH
108707: LD_INT 8
108709: PUSH
108710: LD_INT 11
108712: PUSH
108713: LD_INT 12
108715: PUSH
108716: LD_INT 15
108718: PUSH
108719: LD_INT 16
108721: PUSH
108722: LD_INT 20
108724: PUSH
108725: LD_INT 21
108727: PUSH
108728: LD_INT 22
108730: PUSH
108731: LD_INT 23
108733: PUSH
108734: LD_INT 25
108736: PUSH
108737: LD_INT 26
108739: PUSH
108740: LD_INT 28
108742: PUSH
108743: LD_INT 30
108745: PUSH
108746: LD_INT 31
108748: PUSH
108749: LD_INT 32
108751: PUSH
108752: LD_INT 36
108754: PUSH
108755: EMPTY
108756: LIST
108757: LIST
108758: LIST
108759: LIST
108760: LIST
108761: LIST
108762: LIST
108763: LIST
108764: LIST
108765: LIST
108766: LIST
108767: LIST
108768: LIST
108769: LIST
108770: LIST
108771: LIST
108772: LIST
108773: LIST
108774: LIST
108775: LIST
108776: LIST
108777: PUSH
108778: LD_INT 101
108780: PUSH
108781: LD_INT 102
108783: PUSH
108784: LD_INT 103
108786: PUSH
108787: LD_INT 105
108789: PUSH
108790: LD_INT 106
108792: PUSH
108793: LD_INT 108
108795: PUSH
108796: LD_INT 109
108798: PUSH
108799: LD_INT 112
108801: PUSH
108802: LD_INT 114
108804: PUSH
108805: LD_INT 116
108807: PUSH
108808: LD_INT 117
108810: PUSH
108811: LD_INT 118
108813: PUSH
108814: EMPTY
108815: LIST
108816: LIST
108817: LIST
108818: LIST
108819: LIST
108820: LIST
108821: LIST
108822: LIST
108823: LIST
108824: LIST
108825: LIST
108826: LIST
108827: PUSH
108828: EMPTY
108829: LIST
108830: LIST
108831: ST_TO_ADDR
108832: GO 110931
108834: LD_INT 10
108836: DOUBLE
108837: EQUAL
108838: IFTRUE 108842
108840: GO 109038
108842: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
108843: LD_ADDR_VAR 0 2
108847: PUSH
108848: LD_INT 2
108850: PUSH
108851: LD_INT 4
108853: PUSH
108854: LD_INT 5
108856: PUSH
108857: LD_INT 6
108859: PUSH
108860: LD_INT 7
108862: PUSH
108863: LD_INT 8
108865: PUSH
108866: LD_INT 9
108868: PUSH
108869: LD_INT 10
108871: PUSH
108872: LD_INT 11
108874: PUSH
108875: LD_INT 12
108877: PUSH
108878: LD_INT 13
108880: PUSH
108881: LD_INT 14
108883: PUSH
108884: LD_INT 15
108886: PUSH
108887: LD_INT 16
108889: PUSH
108890: LD_INT 17
108892: PUSH
108893: LD_INT 18
108895: PUSH
108896: LD_INT 19
108898: PUSH
108899: LD_INT 20
108901: PUSH
108902: LD_INT 21
108904: PUSH
108905: LD_INT 22
108907: PUSH
108908: LD_INT 23
108910: PUSH
108911: LD_INT 24
108913: PUSH
108914: LD_INT 25
108916: PUSH
108917: LD_INT 26
108919: PUSH
108920: LD_INT 28
108922: PUSH
108923: LD_INT 30
108925: PUSH
108926: LD_INT 31
108928: PUSH
108929: LD_INT 32
108931: PUSH
108932: LD_INT 36
108934: PUSH
108935: EMPTY
108936: LIST
108937: LIST
108938: LIST
108939: LIST
108940: LIST
108941: LIST
108942: LIST
108943: LIST
108944: LIST
108945: LIST
108946: LIST
108947: LIST
108948: LIST
108949: LIST
108950: LIST
108951: LIST
108952: LIST
108953: LIST
108954: LIST
108955: LIST
108956: LIST
108957: LIST
108958: LIST
108959: LIST
108960: LIST
108961: LIST
108962: LIST
108963: LIST
108964: LIST
108965: PUSH
108966: LD_INT 101
108968: PUSH
108969: LD_INT 102
108971: PUSH
108972: LD_INT 103
108974: PUSH
108975: LD_INT 104
108977: PUSH
108978: LD_INT 105
108980: PUSH
108981: LD_INT 106
108983: PUSH
108984: LD_INT 107
108986: PUSH
108987: LD_INT 108
108989: PUSH
108990: LD_INT 109
108992: PUSH
108993: LD_INT 110
108995: PUSH
108996: LD_INT 111
108998: PUSH
108999: LD_INT 112
109001: PUSH
109002: LD_INT 114
109004: PUSH
109005: LD_INT 116
109007: PUSH
109008: LD_INT 117
109010: PUSH
109011: LD_INT 118
109013: PUSH
109014: EMPTY
109015: LIST
109016: LIST
109017: LIST
109018: LIST
109019: LIST
109020: LIST
109021: LIST
109022: LIST
109023: LIST
109024: LIST
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: LIST
109030: LIST
109031: PUSH
109032: EMPTY
109033: LIST
109034: LIST
109035: ST_TO_ADDR
109036: GO 110931
109038: LD_INT 11
109040: DOUBLE
109041: EQUAL
109042: IFTRUE 109046
109044: GO 109250
109046: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
109047: LD_ADDR_VAR 0 2
109051: PUSH
109052: LD_INT 2
109054: PUSH
109055: LD_INT 3
109057: PUSH
109058: LD_INT 4
109060: PUSH
109061: LD_INT 5
109063: PUSH
109064: LD_INT 6
109066: PUSH
109067: LD_INT 7
109069: PUSH
109070: LD_INT 8
109072: PUSH
109073: LD_INT 9
109075: PUSH
109076: LD_INT 10
109078: PUSH
109079: LD_INT 11
109081: PUSH
109082: LD_INT 12
109084: PUSH
109085: LD_INT 13
109087: PUSH
109088: LD_INT 14
109090: PUSH
109091: LD_INT 15
109093: PUSH
109094: LD_INT 16
109096: PUSH
109097: LD_INT 17
109099: PUSH
109100: LD_INT 18
109102: PUSH
109103: LD_INT 19
109105: PUSH
109106: LD_INT 20
109108: PUSH
109109: LD_INT 21
109111: PUSH
109112: LD_INT 22
109114: PUSH
109115: LD_INT 23
109117: PUSH
109118: LD_INT 24
109120: PUSH
109121: LD_INT 25
109123: PUSH
109124: LD_INT 26
109126: PUSH
109127: LD_INT 28
109129: PUSH
109130: LD_INT 30
109132: PUSH
109133: LD_INT 31
109135: PUSH
109136: LD_INT 32
109138: PUSH
109139: LD_INT 34
109141: PUSH
109142: LD_INT 36
109144: PUSH
109145: EMPTY
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: LIST
109161: LIST
109162: LIST
109163: LIST
109164: LIST
109165: LIST
109166: LIST
109167: LIST
109168: LIST
109169: LIST
109170: LIST
109171: LIST
109172: LIST
109173: LIST
109174: LIST
109175: LIST
109176: LIST
109177: PUSH
109178: LD_INT 101
109180: PUSH
109181: LD_INT 102
109183: PUSH
109184: LD_INT 103
109186: PUSH
109187: LD_INT 104
109189: PUSH
109190: LD_INT 105
109192: PUSH
109193: LD_INT 106
109195: PUSH
109196: LD_INT 107
109198: PUSH
109199: LD_INT 108
109201: PUSH
109202: LD_INT 109
109204: PUSH
109205: LD_INT 110
109207: PUSH
109208: LD_INT 111
109210: PUSH
109211: LD_INT 112
109213: PUSH
109214: LD_INT 114
109216: PUSH
109217: LD_INT 116
109219: PUSH
109220: LD_INT 117
109222: PUSH
109223: LD_INT 118
109225: PUSH
109226: EMPTY
109227: LIST
109228: LIST
109229: LIST
109230: LIST
109231: LIST
109232: LIST
109233: LIST
109234: LIST
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: LIST
109240: LIST
109241: LIST
109242: LIST
109243: PUSH
109244: EMPTY
109245: LIST
109246: LIST
109247: ST_TO_ADDR
109248: GO 110931
109250: LD_INT 12
109252: DOUBLE
109253: EQUAL
109254: IFTRUE 109258
109256: GO 109478
109258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
109259: LD_ADDR_VAR 0 2
109263: PUSH
109264: LD_INT 1
109266: PUSH
109267: LD_INT 2
109269: PUSH
109270: LD_INT 3
109272: PUSH
109273: LD_INT 4
109275: PUSH
109276: LD_INT 5
109278: PUSH
109279: LD_INT 6
109281: PUSH
109282: LD_INT 7
109284: PUSH
109285: LD_INT 8
109287: PUSH
109288: LD_INT 9
109290: PUSH
109291: LD_INT 10
109293: PUSH
109294: LD_INT 11
109296: PUSH
109297: LD_INT 12
109299: PUSH
109300: LD_INT 13
109302: PUSH
109303: LD_INT 14
109305: PUSH
109306: LD_INT 15
109308: PUSH
109309: LD_INT 16
109311: PUSH
109312: LD_INT 17
109314: PUSH
109315: LD_INT 18
109317: PUSH
109318: LD_INT 19
109320: PUSH
109321: LD_INT 20
109323: PUSH
109324: LD_INT 21
109326: PUSH
109327: LD_INT 22
109329: PUSH
109330: LD_INT 23
109332: PUSH
109333: LD_INT 24
109335: PUSH
109336: LD_INT 25
109338: PUSH
109339: LD_INT 26
109341: PUSH
109342: LD_INT 27
109344: PUSH
109345: LD_INT 28
109347: PUSH
109348: LD_INT 30
109350: PUSH
109351: LD_INT 31
109353: PUSH
109354: LD_INT 32
109356: PUSH
109357: LD_INT 33
109359: PUSH
109360: LD_INT 34
109362: PUSH
109363: LD_INT 36
109365: PUSH
109366: EMPTY
109367: LIST
109368: LIST
109369: LIST
109370: LIST
109371: LIST
109372: LIST
109373: LIST
109374: LIST
109375: LIST
109376: LIST
109377: LIST
109378: LIST
109379: LIST
109380: LIST
109381: LIST
109382: LIST
109383: LIST
109384: LIST
109385: LIST
109386: LIST
109387: LIST
109388: LIST
109389: LIST
109390: LIST
109391: LIST
109392: LIST
109393: LIST
109394: LIST
109395: LIST
109396: LIST
109397: LIST
109398: LIST
109399: LIST
109400: LIST
109401: PUSH
109402: LD_INT 101
109404: PUSH
109405: LD_INT 102
109407: PUSH
109408: LD_INT 103
109410: PUSH
109411: LD_INT 104
109413: PUSH
109414: LD_INT 105
109416: PUSH
109417: LD_INT 106
109419: PUSH
109420: LD_INT 107
109422: PUSH
109423: LD_INT 108
109425: PUSH
109426: LD_INT 109
109428: PUSH
109429: LD_INT 110
109431: PUSH
109432: LD_INT 111
109434: PUSH
109435: LD_INT 112
109437: PUSH
109438: LD_INT 113
109440: PUSH
109441: LD_INT 114
109443: PUSH
109444: LD_INT 116
109446: PUSH
109447: LD_INT 117
109449: PUSH
109450: LD_INT 118
109452: PUSH
109453: EMPTY
109454: LIST
109455: LIST
109456: LIST
109457: LIST
109458: LIST
109459: LIST
109460: LIST
109461: LIST
109462: LIST
109463: LIST
109464: LIST
109465: LIST
109466: LIST
109467: LIST
109468: LIST
109469: LIST
109470: LIST
109471: PUSH
109472: EMPTY
109473: LIST
109474: LIST
109475: ST_TO_ADDR
109476: GO 110931
109478: LD_INT 13
109480: DOUBLE
109481: EQUAL
109482: IFTRUE 109486
109484: GO 109694
109486: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
109487: LD_ADDR_VAR 0 2
109491: PUSH
109492: LD_INT 1
109494: PUSH
109495: LD_INT 2
109497: PUSH
109498: LD_INT 3
109500: PUSH
109501: LD_INT 4
109503: PUSH
109504: LD_INT 5
109506: PUSH
109507: LD_INT 8
109509: PUSH
109510: LD_INT 9
109512: PUSH
109513: LD_INT 10
109515: PUSH
109516: LD_INT 11
109518: PUSH
109519: LD_INT 12
109521: PUSH
109522: LD_INT 14
109524: PUSH
109525: LD_INT 15
109527: PUSH
109528: LD_INT 16
109530: PUSH
109531: LD_INT 17
109533: PUSH
109534: LD_INT 18
109536: PUSH
109537: LD_INT 19
109539: PUSH
109540: LD_INT 20
109542: PUSH
109543: LD_INT 21
109545: PUSH
109546: LD_INT 22
109548: PUSH
109549: LD_INT 23
109551: PUSH
109552: LD_INT 24
109554: PUSH
109555: LD_INT 25
109557: PUSH
109558: LD_INT 26
109560: PUSH
109561: LD_INT 27
109563: PUSH
109564: LD_INT 28
109566: PUSH
109567: LD_INT 30
109569: PUSH
109570: LD_INT 31
109572: PUSH
109573: LD_INT 32
109575: PUSH
109576: LD_INT 33
109578: PUSH
109579: LD_INT 34
109581: PUSH
109582: LD_INT 36
109584: PUSH
109585: EMPTY
109586: LIST
109587: LIST
109588: LIST
109589: LIST
109590: LIST
109591: LIST
109592: LIST
109593: LIST
109594: LIST
109595: LIST
109596: LIST
109597: LIST
109598: LIST
109599: LIST
109600: LIST
109601: LIST
109602: LIST
109603: LIST
109604: LIST
109605: LIST
109606: LIST
109607: LIST
109608: LIST
109609: LIST
109610: LIST
109611: LIST
109612: LIST
109613: LIST
109614: LIST
109615: LIST
109616: LIST
109617: PUSH
109618: LD_INT 101
109620: PUSH
109621: LD_INT 102
109623: PUSH
109624: LD_INT 103
109626: PUSH
109627: LD_INT 104
109629: PUSH
109630: LD_INT 105
109632: PUSH
109633: LD_INT 106
109635: PUSH
109636: LD_INT 107
109638: PUSH
109639: LD_INT 108
109641: PUSH
109642: LD_INT 109
109644: PUSH
109645: LD_INT 110
109647: PUSH
109648: LD_INT 111
109650: PUSH
109651: LD_INT 112
109653: PUSH
109654: LD_INT 113
109656: PUSH
109657: LD_INT 114
109659: PUSH
109660: LD_INT 116
109662: PUSH
109663: LD_INT 117
109665: PUSH
109666: LD_INT 118
109668: PUSH
109669: EMPTY
109670: LIST
109671: LIST
109672: LIST
109673: LIST
109674: LIST
109675: LIST
109676: LIST
109677: LIST
109678: LIST
109679: LIST
109680: LIST
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: LIST
109687: PUSH
109688: EMPTY
109689: LIST
109690: LIST
109691: ST_TO_ADDR
109692: GO 110931
109694: LD_INT 14
109696: DOUBLE
109697: EQUAL
109698: IFTRUE 109702
109700: GO 109926
109702: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
109703: LD_ADDR_VAR 0 2
109707: PUSH
109708: LD_INT 1
109710: PUSH
109711: LD_INT 2
109713: PUSH
109714: LD_INT 3
109716: PUSH
109717: LD_INT 4
109719: PUSH
109720: LD_INT 5
109722: PUSH
109723: LD_INT 6
109725: PUSH
109726: LD_INT 7
109728: PUSH
109729: LD_INT 8
109731: PUSH
109732: LD_INT 9
109734: PUSH
109735: LD_INT 10
109737: PUSH
109738: LD_INT 11
109740: PUSH
109741: LD_INT 12
109743: PUSH
109744: LD_INT 13
109746: PUSH
109747: LD_INT 14
109749: PUSH
109750: LD_INT 15
109752: PUSH
109753: LD_INT 16
109755: PUSH
109756: LD_INT 17
109758: PUSH
109759: LD_INT 18
109761: PUSH
109762: LD_INT 19
109764: PUSH
109765: LD_INT 20
109767: PUSH
109768: LD_INT 21
109770: PUSH
109771: LD_INT 22
109773: PUSH
109774: LD_INT 23
109776: PUSH
109777: LD_INT 24
109779: PUSH
109780: LD_INT 25
109782: PUSH
109783: LD_INT 26
109785: PUSH
109786: LD_INT 27
109788: PUSH
109789: LD_INT 28
109791: PUSH
109792: LD_INT 29
109794: PUSH
109795: LD_INT 30
109797: PUSH
109798: LD_INT 31
109800: PUSH
109801: LD_INT 32
109803: PUSH
109804: LD_INT 33
109806: PUSH
109807: LD_INT 34
109809: PUSH
109810: LD_INT 36
109812: PUSH
109813: EMPTY
109814: LIST
109815: LIST
109816: LIST
109817: LIST
109818: LIST
109819: LIST
109820: LIST
109821: LIST
109822: LIST
109823: LIST
109824: LIST
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: LIST
109831: LIST
109832: LIST
109833: LIST
109834: LIST
109835: LIST
109836: LIST
109837: LIST
109838: LIST
109839: LIST
109840: LIST
109841: LIST
109842: LIST
109843: LIST
109844: LIST
109845: LIST
109846: LIST
109847: LIST
109848: LIST
109849: PUSH
109850: LD_INT 101
109852: PUSH
109853: LD_INT 102
109855: PUSH
109856: LD_INT 103
109858: PUSH
109859: LD_INT 104
109861: PUSH
109862: LD_INT 105
109864: PUSH
109865: LD_INT 106
109867: PUSH
109868: LD_INT 107
109870: PUSH
109871: LD_INT 108
109873: PUSH
109874: LD_INT 109
109876: PUSH
109877: LD_INT 110
109879: PUSH
109880: LD_INT 111
109882: PUSH
109883: LD_INT 112
109885: PUSH
109886: LD_INT 113
109888: PUSH
109889: LD_INT 114
109891: PUSH
109892: LD_INT 116
109894: PUSH
109895: LD_INT 117
109897: PUSH
109898: LD_INT 118
109900: PUSH
109901: EMPTY
109902: LIST
109903: LIST
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: LIST
109909: LIST
109910: LIST
109911: LIST
109912: LIST
109913: LIST
109914: LIST
109915: LIST
109916: LIST
109917: LIST
109918: LIST
109919: PUSH
109920: EMPTY
109921: LIST
109922: LIST
109923: ST_TO_ADDR
109924: GO 110931
109926: LD_INT 15
109928: DOUBLE
109929: EQUAL
109930: IFTRUE 109934
109932: GO 110158
109934: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
109935: LD_ADDR_VAR 0 2
109939: PUSH
109940: LD_INT 1
109942: PUSH
109943: LD_INT 2
109945: PUSH
109946: LD_INT 3
109948: PUSH
109949: LD_INT 4
109951: PUSH
109952: LD_INT 5
109954: PUSH
109955: LD_INT 6
109957: PUSH
109958: LD_INT 7
109960: PUSH
109961: LD_INT 8
109963: PUSH
109964: LD_INT 9
109966: PUSH
109967: LD_INT 10
109969: PUSH
109970: LD_INT 11
109972: PUSH
109973: LD_INT 12
109975: PUSH
109976: LD_INT 13
109978: PUSH
109979: LD_INT 14
109981: PUSH
109982: LD_INT 15
109984: PUSH
109985: LD_INT 16
109987: PUSH
109988: LD_INT 17
109990: PUSH
109991: LD_INT 18
109993: PUSH
109994: LD_INT 19
109996: PUSH
109997: LD_INT 20
109999: PUSH
110000: LD_INT 21
110002: PUSH
110003: LD_INT 22
110005: PUSH
110006: LD_INT 23
110008: PUSH
110009: LD_INT 24
110011: PUSH
110012: LD_INT 25
110014: PUSH
110015: LD_INT 26
110017: PUSH
110018: LD_INT 27
110020: PUSH
110021: LD_INT 28
110023: PUSH
110024: LD_INT 29
110026: PUSH
110027: LD_INT 30
110029: PUSH
110030: LD_INT 31
110032: PUSH
110033: LD_INT 32
110035: PUSH
110036: LD_INT 33
110038: PUSH
110039: LD_INT 34
110041: PUSH
110042: LD_INT 36
110044: PUSH
110045: EMPTY
110046: LIST
110047: LIST
110048: LIST
110049: LIST
110050: LIST
110051: LIST
110052: LIST
110053: LIST
110054: LIST
110055: LIST
110056: LIST
110057: LIST
110058: LIST
110059: LIST
110060: LIST
110061: LIST
110062: LIST
110063: LIST
110064: LIST
110065: LIST
110066: LIST
110067: LIST
110068: LIST
110069: LIST
110070: LIST
110071: LIST
110072: LIST
110073: LIST
110074: LIST
110075: LIST
110076: LIST
110077: LIST
110078: LIST
110079: LIST
110080: LIST
110081: PUSH
110082: LD_INT 101
110084: PUSH
110085: LD_INT 102
110087: PUSH
110088: LD_INT 103
110090: PUSH
110091: LD_INT 104
110093: PUSH
110094: LD_INT 105
110096: PUSH
110097: LD_INT 106
110099: PUSH
110100: LD_INT 107
110102: PUSH
110103: LD_INT 108
110105: PUSH
110106: LD_INT 109
110108: PUSH
110109: LD_INT 110
110111: PUSH
110112: LD_INT 111
110114: PUSH
110115: LD_INT 112
110117: PUSH
110118: LD_INT 113
110120: PUSH
110121: LD_INT 114
110123: PUSH
110124: LD_INT 116
110126: PUSH
110127: LD_INT 117
110129: PUSH
110130: LD_INT 118
110132: PUSH
110133: EMPTY
110134: LIST
110135: LIST
110136: LIST
110137: LIST
110138: LIST
110139: LIST
110140: LIST
110141: LIST
110142: LIST
110143: LIST
110144: LIST
110145: LIST
110146: LIST
110147: LIST
110148: LIST
110149: LIST
110150: LIST
110151: PUSH
110152: EMPTY
110153: LIST
110154: LIST
110155: ST_TO_ADDR
110156: GO 110931
110158: LD_INT 16
110160: DOUBLE
110161: EQUAL
110162: IFTRUE 110166
110164: GO 110302
110166: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
110167: LD_ADDR_VAR 0 2
110171: PUSH
110172: LD_INT 2
110174: PUSH
110175: LD_INT 4
110177: PUSH
110178: LD_INT 5
110180: PUSH
110181: LD_INT 7
110183: PUSH
110184: LD_INT 11
110186: PUSH
110187: LD_INT 12
110189: PUSH
110190: LD_INT 15
110192: PUSH
110193: LD_INT 16
110195: PUSH
110196: LD_INT 20
110198: PUSH
110199: LD_INT 21
110201: PUSH
110202: LD_INT 22
110204: PUSH
110205: LD_INT 23
110207: PUSH
110208: LD_INT 25
110210: PUSH
110211: LD_INT 26
110213: PUSH
110214: LD_INT 30
110216: PUSH
110217: LD_INT 31
110219: PUSH
110220: LD_INT 32
110222: PUSH
110223: LD_INT 33
110225: PUSH
110226: LD_INT 34
110228: PUSH
110229: EMPTY
110230: LIST
110231: LIST
110232: LIST
110233: LIST
110234: LIST
110235: LIST
110236: LIST
110237: LIST
110238: LIST
110239: LIST
110240: LIST
110241: LIST
110242: LIST
110243: LIST
110244: LIST
110245: LIST
110246: LIST
110247: LIST
110248: LIST
110249: PUSH
110250: LD_INT 101
110252: PUSH
110253: LD_INT 102
110255: PUSH
110256: LD_INT 103
110258: PUSH
110259: LD_INT 106
110261: PUSH
110262: LD_INT 108
110264: PUSH
110265: LD_INT 112
110267: PUSH
110268: LD_INT 113
110270: PUSH
110271: LD_INT 114
110273: PUSH
110274: LD_INT 116
110276: PUSH
110277: LD_INT 117
110279: PUSH
110280: LD_INT 118
110282: PUSH
110283: EMPTY
110284: LIST
110285: LIST
110286: LIST
110287: LIST
110288: LIST
110289: LIST
110290: LIST
110291: LIST
110292: LIST
110293: LIST
110294: LIST
110295: PUSH
110296: EMPTY
110297: LIST
110298: LIST
110299: ST_TO_ADDR
110300: GO 110931
110302: LD_INT 17
110304: DOUBLE
110305: EQUAL
110306: IFTRUE 110310
110308: GO 110534
110310: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
110311: LD_ADDR_VAR 0 2
110315: PUSH
110316: LD_INT 1
110318: PUSH
110319: LD_INT 2
110321: PUSH
110322: LD_INT 3
110324: PUSH
110325: LD_INT 4
110327: PUSH
110328: LD_INT 5
110330: PUSH
110331: LD_INT 6
110333: PUSH
110334: LD_INT 7
110336: PUSH
110337: LD_INT 8
110339: PUSH
110340: LD_INT 9
110342: PUSH
110343: LD_INT 10
110345: PUSH
110346: LD_INT 11
110348: PUSH
110349: LD_INT 12
110351: PUSH
110352: LD_INT 13
110354: PUSH
110355: LD_INT 14
110357: PUSH
110358: LD_INT 15
110360: PUSH
110361: LD_INT 16
110363: PUSH
110364: LD_INT 17
110366: PUSH
110367: LD_INT 18
110369: PUSH
110370: LD_INT 19
110372: PUSH
110373: LD_INT 20
110375: PUSH
110376: LD_INT 21
110378: PUSH
110379: LD_INT 22
110381: PUSH
110382: LD_INT 23
110384: PUSH
110385: LD_INT 24
110387: PUSH
110388: LD_INT 25
110390: PUSH
110391: LD_INT 26
110393: PUSH
110394: LD_INT 27
110396: PUSH
110397: LD_INT 28
110399: PUSH
110400: LD_INT 29
110402: PUSH
110403: LD_INT 30
110405: PUSH
110406: LD_INT 31
110408: PUSH
110409: LD_INT 32
110411: PUSH
110412: LD_INT 33
110414: PUSH
110415: LD_INT 34
110417: PUSH
110418: LD_INT 36
110420: PUSH
110421: EMPTY
110422: LIST
110423: LIST
110424: LIST
110425: LIST
110426: LIST
110427: LIST
110428: LIST
110429: LIST
110430: LIST
110431: LIST
110432: LIST
110433: LIST
110434: LIST
110435: LIST
110436: LIST
110437: LIST
110438: LIST
110439: LIST
110440: LIST
110441: LIST
110442: LIST
110443: LIST
110444: LIST
110445: LIST
110446: LIST
110447: LIST
110448: LIST
110449: LIST
110450: LIST
110451: LIST
110452: LIST
110453: LIST
110454: LIST
110455: LIST
110456: LIST
110457: PUSH
110458: LD_INT 101
110460: PUSH
110461: LD_INT 102
110463: PUSH
110464: LD_INT 103
110466: PUSH
110467: LD_INT 104
110469: PUSH
110470: LD_INT 105
110472: PUSH
110473: LD_INT 106
110475: PUSH
110476: LD_INT 107
110478: PUSH
110479: LD_INT 108
110481: PUSH
110482: LD_INT 109
110484: PUSH
110485: LD_INT 110
110487: PUSH
110488: LD_INT 111
110490: PUSH
110491: LD_INT 112
110493: PUSH
110494: LD_INT 113
110496: PUSH
110497: LD_INT 114
110499: PUSH
110500: LD_INT 116
110502: PUSH
110503: LD_INT 117
110505: PUSH
110506: LD_INT 118
110508: PUSH
110509: EMPTY
110510: LIST
110511: LIST
110512: LIST
110513: LIST
110514: LIST
110515: LIST
110516: LIST
110517: LIST
110518: LIST
110519: LIST
110520: LIST
110521: LIST
110522: LIST
110523: LIST
110524: LIST
110525: LIST
110526: LIST
110527: PUSH
110528: EMPTY
110529: LIST
110530: LIST
110531: ST_TO_ADDR
110532: GO 110931
110534: LD_INT 18
110536: DOUBLE
110537: EQUAL
110538: IFTRUE 110542
110540: GO 110690
110542: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
110543: LD_ADDR_VAR 0 2
110547: PUSH
110548: LD_INT 2
110550: PUSH
110551: LD_INT 4
110553: PUSH
110554: LD_INT 5
110556: PUSH
110557: LD_INT 7
110559: PUSH
110560: LD_INT 11
110562: PUSH
110563: LD_INT 12
110565: PUSH
110566: LD_INT 15
110568: PUSH
110569: LD_INT 16
110571: PUSH
110572: LD_INT 20
110574: PUSH
110575: LD_INT 21
110577: PUSH
110578: LD_INT 22
110580: PUSH
110581: LD_INT 23
110583: PUSH
110584: LD_INT 25
110586: PUSH
110587: LD_INT 26
110589: PUSH
110590: LD_INT 30
110592: PUSH
110593: LD_INT 31
110595: PUSH
110596: LD_INT 32
110598: PUSH
110599: LD_INT 33
110601: PUSH
110602: LD_INT 34
110604: PUSH
110605: LD_INT 35
110607: PUSH
110608: LD_INT 36
110610: PUSH
110611: EMPTY
110612: LIST
110613: LIST
110614: LIST
110615: LIST
110616: LIST
110617: LIST
110618: LIST
110619: LIST
110620: LIST
110621: LIST
110622: LIST
110623: LIST
110624: LIST
110625: LIST
110626: LIST
110627: LIST
110628: LIST
110629: LIST
110630: LIST
110631: LIST
110632: LIST
110633: PUSH
110634: LD_INT 101
110636: PUSH
110637: LD_INT 102
110639: PUSH
110640: LD_INT 103
110642: PUSH
110643: LD_INT 106
110645: PUSH
110646: LD_INT 108
110648: PUSH
110649: LD_INT 112
110651: PUSH
110652: LD_INT 113
110654: PUSH
110655: LD_INT 114
110657: PUSH
110658: LD_INT 115
110660: PUSH
110661: LD_INT 116
110663: PUSH
110664: LD_INT 117
110666: PUSH
110667: LD_INT 118
110669: PUSH
110670: EMPTY
110671: LIST
110672: LIST
110673: LIST
110674: LIST
110675: LIST
110676: LIST
110677: LIST
110678: LIST
110679: LIST
110680: LIST
110681: LIST
110682: LIST
110683: PUSH
110684: EMPTY
110685: LIST
110686: LIST
110687: ST_TO_ADDR
110688: GO 110931
110690: LD_INT 19
110692: DOUBLE
110693: EQUAL
110694: IFTRUE 110698
110696: GO 110930
110698: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
110699: LD_ADDR_VAR 0 2
110703: PUSH
110704: LD_INT 1
110706: PUSH
110707: LD_INT 2
110709: PUSH
110710: LD_INT 3
110712: PUSH
110713: LD_INT 4
110715: PUSH
110716: LD_INT 5
110718: PUSH
110719: LD_INT 6
110721: PUSH
110722: LD_INT 7
110724: PUSH
110725: LD_INT 8
110727: PUSH
110728: LD_INT 9
110730: PUSH
110731: LD_INT 10
110733: PUSH
110734: LD_INT 11
110736: PUSH
110737: LD_INT 12
110739: PUSH
110740: LD_INT 13
110742: PUSH
110743: LD_INT 14
110745: PUSH
110746: LD_INT 15
110748: PUSH
110749: LD_INT 16
110751: PUSH
110752: LD_INT 17
110754: PUSH
110755: LD_INT 18
110757: PUSH
110758: LD_INT 19
110760: PUSH
110761: LD_INT 20
110763: PUSH
110764: LD_INT 21
110766: PUSH
110767: LD_INT 22
110769: PUSH
110770: LD_INT 23
110772: PUSH
110773: LD_INT 24
110775: PUSH
110776: LD_INT 25
110778: PUSH
110779: LD_INT 26
110781: PUSH
110782: LD_INT 27
110784: PUSH
110785: LD_INT 28
110787: PUSH
110788: LD_INT 29
110790: PUSH
110791: LD_INT 30
110793: PUSH
110794: LD_INT 31
110796: PUSH
110797: LD_INT 32
110799: PUSH
110800: LD_INT 33
110802: PUSH
110803: LD_INT 34
110805: PUSH
110806: LD_INT 35
110808: PUSH
110809: LD_INT 36
110811: PUSH
110812: EMPTY
110813: LIST
110814: LIST
110815: LIST
110816: LIST
110817: LIST
110818: LIST
110819: LIST
110820: LIST
110821: LIST
110822: LIST
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: LIST
110831: LIST
110832: LIST
110833: LIST
110834: LIST
110835: LIST
110836: LIST
110837: LIST
110838: LIST
110839: LIST
110840: LIST
110841: LIST
110842: LIST
110843: LIST
110844: LIST
110845: LIST
110846: LIST
110847: LIST
110848: LIST
110849: PUSH
110850: LD_INT 101
110852: PUSH
110853: LD_INT 102
110855: PUSH
110856: LD_INT 103
110858: PUSH
110859: LD_INT 104
110861: PUSH
110862: LD_INT 105
110864: PUSH
110865: LD_INT 106
110867: PUSH
110868: LD_INT 107
110870: PUSH
110871: LD_INT 108
110873: PUSH
110874: LD_INT 109
110876: PUSH
110877: LD_INT 110
110879: PUSH
110880: LD_INT 111
110882: PUSH
110883: LD_INT 112
110885: PUSH
110886: LD_INT 113
110888: PUSH
110889: LD_INT 114
110891: PUSH
110892: LD_INT 115
110894: PUSH
110895: LD_INT 116
110897: PUSH
110898: LD_INT 117
110900: PUSH
110901: LD_INT 118
110903: PUSH
110904: EMPTY
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: PUSH
110924: EMPTY
110925: LIST
110926: LIST
110927: ST_TO_ADDR
110928: GO 110931
110930: POP
// end else
110931: GO 111162
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
110933: LD_ADDR_VAR 0 2
110937: PUSH
110938: LD_INT 1
110940: PUSH
110941: LD_INT 2
110943: PUSH
110944: LD_INT 3
110946: PUSH
110947: LD_INT 4
110949: PUSH
110950: LD_INT 5
110952: PUSH
110953: LD_INT 6
110955: PUSH
110956: LD_INT 7
110958: PUSH
110959: LD_INT 8
110961: PUSH
110962: LD_INT 9
110964: PUSH
110965: LD_INT 10
110967: PUSH
110968: LD_INT 11
110970: PUSH
110971: LD_INT 12
110973: PUSH
110974: LD_INT 13
110976: PUSH
110977: LD_INT 14
110979: PUSH
110980: LD_INT 15
110982: PUSH
110983: LD_INT 16
110985: PUSH
110986: LD_INT 17
110988: PUSH
110989: LD_INT 18
110991: PUSH
110992: LD_INT 19
110994: PUSH
110995: LD_INT 20
110997: PUSH
110998: LD_INT 21
111000: PUSH
111001: LD_INT 22
111003: PUSH
111004: LD_INT 23
111006: PUSH
111007: LD_INT 24
111009: PUSH
111010: LD_INT 25
111012: PUSH
111013: LD_INT 26
111015: PUSH
111016: LD_INT 27
111018: PUSH
111019: LD_INT 28
111021: PUSH
111022: LD_INT 29
111024: PUSH
111025: LD_INT 30
111027: PUSH
111028: LD_INT 31
111030: PUSH
111031: LD_INT 32
111033: PUSH
111034: LD_INT 33
111036: PUSH
111037: LD_INT 34
111039: PUSH
111040: LD_INT 35
111042: PUSH
111043: LD_INT 36
111045: PUSH
111046: EMPTY
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: LIST
111052: LIST
111053: LIST
111054: LIST
111055: LIST
111056: LIST
111057: LIST
111058: LIST
111059: LIST
111060: LIST
111061: LIST
111062: LIST
111063: LIST
111064: LIST
111065: LIST
111066: LIST
111067: LIST
111068: LIST
111069: LIST
111070: LIST
111071: LIST
111072: LIST
111073: LIST
111074: LIST
111075: LIST
111076: LIST
111077: LIST
111078: LIST
111079: LIST
111080: LIST
111081: LIST
111082: LIST
111083: PUSH
111084: LD_INT 101
111086: PUSH
111087: LD_INT 102
111089: PUSH
111090: LD_INT 103
111092: PUSH
111093: LD_INT 104
111095: PUSH
111096: LD_INT 105
111098: PUSH
111099: LD_INT 106
111101: PUSH
111102: LD_INT 107
111104: PUSH
111105: LD_INT 108
111107: PUSH
111108: LD_INT 109
111110: PUSH
111111: LD_INT 110
111113: PUSH
111114: LD_INT 111
111116: PUSH
111117: LD_INT 112
111119: PUSH
111120: LD_INT 113
111122: PUSH
111123: LD_INT 114
111125: PUSH
111126: LD_INT 115
111128: PUSH
111129: LD_INT 116
111131: PUSH
111132: LD_INT 117
111134: PUSH
111135: LD_INT 118
111137: PUSH
111138: EMPTY
111139: LIST
111140: LIST
111141: LIST
111142: LIST
111143: LIST
111144: LIST
111145: LIST
111146: LIST
111147: LIST
111148: LIST
111149: LIST
111150: LIST
111151: LIST
111152: LIST
111153: LIST
111154: LIST
111155: LIST
111156: LIST
111157: PUSH
111158: EMPTY
111159: LIST
111160: LIST
111161: ST_TO_ADDR
// if result then
111162: LD_VAR 0 2
111166: IFFALSE 111952
// begin normal :=  ;
111168: LD_ADDR_VAR 0 5
111172: PUSH
111173: LD_STRING 
111175: ST_TO_ADDR
// hardcore :=  ;
111176: LD_ADDR_VAR 0 6
111180: PUSH
111181: LD_STRING 
111183: ST_TO_ADDR
// active :=  ;
111184: LD_ADDR_VAR 0 7
111188: PUSH
111189: LD_STRING 
111191: ST_TO_ADDR
// for i = 1 to normalCounter do
111192: LD_ADDR_VAR 0 8
111196: PUSH
111197: DOUBLE
111198: LD_INT 1
111200: DEC
111201: ST_TO_ADDR
111202: LD_EXP 162
111206: PUSH
111207: FOR_TO
111208: IFFALSE 111309
// begin tmp := 0 ;
111210: LD_ADDR_VAR 0 3
111214: PUSH
111215: LD_STRING 0
111217: ST_TO_ADDR
// if result [ 1 ] then
111218: LD_VAR 0 2
111222: PUSH
111223: LD_INT 1
111225: ARRAY
111226: IFFALSE 111291
// if result [ 1 ] [ 1 ] = i then
111228: LD_VAR 0 2
111232: PUSH
111233: LD_INT 1
111235: ARRAY
111236: PUSH
111237: LD_INT 1
111239: ARRAY
111240: PUSH
111241: LD_VAR 0 8
111245: EQUAL
111246: IFFALSE 111291
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111248: LD_ADDR_VAR 0 2
111252: PUSH
111253: LD_VAR 0 2
111257: PPUSH
111258: LD_INT 1
111260: PPUSH
111261: LD_VAR 0 2
111265: PUSH
111266: LD_INT 1
111268: ARRAY
111269: PPUSH
111270: LD_INT 1
111272: PPUSH
111273: CALL_OW 3
111277: PPUSH
111278: CALL_OW 1
111282: ST_TO_ADDR
// tmp := 1 ;
111283: LD_ADDR_VAR 0 3
111287: PUSH
111288: LD_STRING 1
111290: ST_TO_ADDR
// end ; normal := normal & tmp ;
111291: LD_ADDR_VAR 0 5
111295: PUSH
111296: LD_VAR 0 5
111300: PUSH
111301: LD_VAR 0 3
111305: STR
111306: ST_TO_ADDR
// end ;
111307: GO 111207
111309: POP
111310: POP
// for i = 1 to hardcoreCounter do
111311: LD_ADDR_VAR 0 8
111315: PUSH
111316: DOUBLE
111317: LD_INT 1
111319: DEC
111320: ST_TO_ADDR
111321: LD_EXP 163
111325: PUSH
111326: FOR_TO
111327: IFFALSE 111432
// begin tmp := 0 ;
111329: LD_ADDR_VAR 0 3
111333: PUSH
111334: LD_STRING 0
111336: ST_TO_ADDR
// if result [ 2 ] then
111337: LD_VAR 0 2
111341: PUSH
111342: LD_INT 2
111344: ARRAY
111345: IFFALSE 111414
// if result [ 2 ] [ 1 ] = 100 + i then
111347: LD_VAR 0 2
111351: PUSH
111352: LD_INT 2
111354: ARRAY
111355: PUSH
111356: LD_INT 1
111358: ARRAY
111359: PUSH
111360: LD_INT 100
111362: PUSH
111363: LD_VAR 0 8
111367: PLUS
111368: EQUAL
111369: IFFALSE 111414
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111371: LD_ADDR_VAR 0 2
111375: PUSH
111376: LD_VAR 0 2
111380: PPUSH
111381: LD_INT 2
111383: PPUSH
111384: LD_VAR 0 2
111388: PUSH
111389: LD_INT 2
111391: ARRAY
111392: PPUSH
111393: LD_INT 1
111395: PPUSH
111396: CALL_OW 3
111400: PPUSH
111401: CALL_OW 1
111405: ST_TO_ADDR
// tmp := 1 ;
111406: LD_ADDR_VAR 0 3
111410: PUSH
111411: LD_STRING 1
111413: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111414: LD_ADDR_VAR 0 6
111418: PUSH
111419: LD_VAR 0 6
111423: PUSH
111424: LD_VAR 0 3
111428: STR
111429: ST_TO_ADDR
// end ;
111430: GO 111326
111432: POP
111433: POP
// if isGameLoad then
111434: LD_VAR 0 1
111438: IFFALSE 111913
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
111440: LD_ADDR_VAR 0 4
111444: PUSH
111445: LD_EXP 166
111449: PUSH
111450: LD_EXP 165
111454: PUSH
111455: LD_EXP 167
111459: PUSH
111460: LD_EXP 164
111464: PUSH
111465: LD_EXP 168
111469: PUSH
111470: LD_EXP 169
111474: PUSH
111475: LD_EXP 170
111479: PUSH
111480: LD_EXP 171
111484: PUSH
111485: LD_EXP 172
111489: PUSH
111490: LD_EXP 173
111494: PUSH
111495: LD_EXP 174
111499: PUSH
111500: LD_EXP 175
111504: PUSH
111505: LD_EXP 176
111509: PUSH
111510: LD_EXP 177
111514: PUSH
111515: LD_EXP 185
111519: PUSH
111520: LD_EXP 186
111524: PUSH
111525: LD_EXP 187
111529: PUSH
111530: LD_EXP 188
111534: PUSH
111535: LD_EXP 190
111539: PUSH
111540: LD_EXP 191
111544: PUSH
111545: LD_EXP 192
111549: PUSH
111550: LD_EXP 195
111554: PUSH
111555: LD_EXP 197
111559: PUSH
111560: LD_EXP 198
111564: PUSH
111565: LD_EXP 199
111569: PUSH
111570: LD_EXP 201
111574: PUSH
111575: LD_EXP 202
111579: PUSH
111580: LD_EXP 205
111584: PUSH
111585: LD_EXP 206
111589: PUSH
111590: LD_EXP 207
111594: PUSH
111595: LD_EXP 208
111599: PUSH
111600: LD_EXP 209
111604: PUSH
111605: LD_EXP 210
111609: PUSH
111610: LD_EXP 211
111614: PUSH
111615: LD_EXP 212
111619: PUSH
111620: LD_EXP 213
111624: PUSH
111625: LD_EXP 178
111629: PUSH
111630: LD_EXP 179
111634: PUSH
111635: LD_EXP 182
111639: PUSH
111640: LD_EXP 183
111644: PUSH
111645: LD_EXP 184
111649: PUSH
111650: LD_EXP 180
111654: PUSH
111655: LD_EXP 181
111659: PUSH
111660: LD_EXP 189
111664: PUSH
111665: LD_EXP 193
111669: PUSH
111670: LD_EXP 194
111674: PUSH
111675: LD_EXP 196
111679: PUSH
111680: LD_EXP 200
111684: PUSH
111685: LD_EXP 203
111689: PUSH
111690: LD_EXP 204
111694: PUSH
111695: LD_EXP 214
111699: PUSH
111700: LD_EXP 215
111704: PUSH
111705: LD_EXP 216
111709: PUSH
111710: LD_EXP 217
111714: PUSH
111715: EMPTY
111716: LIST
111717: LIST
111718: LIST
111719: LIST
111720: LIST
111721: LIST
111722: LIST
111723: LIST
111724: LIST
111725: LIST
111726: LIST
111727: LIST
111728: LIST
111729: LIST
111730: LIST
111731: LIST
111732: LIST
111733: LIST
111734: LIST
111735: LIST
111736: LIST
111737: LIST
111738: LIST
111739: LIST
111740: LIST
111741: LIST
111742: LIST
111743: LIST
111744: LIST
111745: LIST
111746: LIST
111747: LIST
111748: LIST
111749: LIST
111750: LIST
111751: LIST
111752: LIST
111753: LIST
111754: LIST
111755: LIST
111756: LIST
111757: LIST
111758: LIST
111759: LIST
111760: LIST
111761: LIST
111762: LIST
111763: LIST
111764: LIST
111765: LIST
111766: LIST
111767: LIST
111768: LIST
111769: LIST
111770: ST_TO_ADDR
// tmp :=  ;
111771: LD_ADDR_VAR 0 3
111775: PUSH
111776: LD_STRING 
111778: ST_TO_ADDR
// for i = 1 to normalCounter do
111779: LD_ADDR_VAR 0 8
111783: PUSH
111784: DOUBLE
111785: LD_INT 1
111787: DEC
111788: ST_TO_ADDR
111789: LD_EXP 162
111793: PUSH
111794: FOR_TO
111795: IFFALSE 111831
// begin if flags [ i ] then
111797: LD_VAR 0 4
111801: PUSH
111802: LD_VAR 0 8
111806: ARRAY
111807: IFFALSE 111829
// tmp := tmp & i & ; ;
111809: LD_ADDR_VAR 0 3
111813: PUSH
111814: LD_VAR 0 3
111818: PUSH
111819: LD_VAR 0 8
111823: STR
111824: PUSH
111825: LD_STRING ;
111827: STR
111828: ST_TO_ADDR
// end ;
111829: GO 111794
111831: POP
111832: POP
// for i = 1 to hardcoreCounter do
111833: LD_ADDR_VAR 0 8
111837: PUSH
111838: DOUBLE
111839: LD_INT 1
111841: DEC
111842: ST_TO_ADDR
111843: LD_EXP 163
111847: PUSH
111848: FOR_TO
111849: IFFALSE 111895
// begin if flags [ normalCounter + i ] then
111851: LD_VAR 0 4
111855: PUSH
111856: LD_EXP 162
111860: PUSH
111861: LD_VAR 0 8
111865: PLUS
111866: ARRAY
111867: IFFALSE 111893
// tmp := tmp & ( 100 + i ) & ; ;
111869: LD_ADDR_VAR 0 3
111873: PUSH
111874: LD_VAR 0 3
111878: PUSH
111879: LD_INT 100
111881: PUSH
111882: LD_VAR 0 8
111886: PLUS
111887: STR
111888: PUSH
111889: LD_STRING ;
111891: STR
111892: ST_TO_ADDR
// end ;
111893: GO 111848
111895: POP
111896: POP
// if tmp then
111897: LD_VAR 0 3
111901: IFFALSE 111913
// active := tmp ;
111903: LD_ADDR_VAR 0 7
111907: PUSH
111908: LD_VAR 0 3
111912: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
111913: LD_STRING getStreamItemsFromMission("
111915: PUSH
111916: LD_VAR 0 5
111920: STR
111921: PUSH
111922: LD_STRING ","
111924: STR
111925: PUSH
111926: LD_VAR 0 6
111930: STR
111931: PUSH
111932: LD_STRING ","
111934: STR
111935: PUSH
111936: LD_VAR 0 7
111940: STR
111941: PUSH
111942: LD_STRING ")
111944: STR
111945: PPUSH
111946: CALL_OW 559
// end else
111950: GO 111959
// ToLua ( getStreamItemsFromMission("","","") ) ;
111952: LD_STRING getStreamItemsFromMission("","","")
111954: PPUSH
111955: CALL_OW 559
// end ;
111959: LD_VAR 0 2
111963: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
111964: LD_EXP 161
111968: PUSH
111969: LD_EXP 166
111973: AND
111974: IFFALSE 112098
111976: GO 111978
111978: DISABLE
111979: LD_INT 0
111981: PPUSH
111982: PPUSH
// begin enable ;
111983: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
111984: LD_ADDR_VAR 0 2
111988: PUSH
111989: LD_INT 22
111991: PUSH
111992: LD_OWVAR 2
111996: PUSH
111997: EMPTY
111998: LIST
111999: LIST
112000: PUSH
112001: LD_INT 2
112003: PUSH
112004: LD_INT 34
112006: PUSH
112007: LD_INT 7
112009: PUSH
112010: EMPTY
112011: LIST
112012: LIST
112013: PUSH
112014: LD_INT 34
112016: PUSH
112017: LD_INT 45
112019: PUSH
112020: EMPTY
112021: LIST
112022: LIST
112023: PUSH
112024: LD_INT 34
112026: PUSH
112027: LD_INT 28
112029: PUSH
112030: EMPTY
112031: LIST
112032: LIST
112033: PUSH
112034: LD_INT 34
112036: PUSH
112037: LD_INT 47
112039: PUSH
112040: EMPTY
112041: LIST
112042: LIST
112043: PUSH
112044: EMPTY
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: PUSH
112051: EMPTY
112052: LIST
112053: LIST
112054: PPUSH
112055: CALL_OW 69
112059: ST_TO_ADDR
// if not tmp then
112060: LD_VAR 0 2
112064: NOT
112065: IFFALSE 112069
// exit ;
112067: GO 112098
// for i in tmp do
112069: LD_ADDR_VAR 0 1
112073: PUSH
112074: LD_VAR 0 2
112078: PUSH
112079: FOR_IN
112080: IFFALSE 112096
// begin SetLives ( i , 0 ) ;
112082: LD_VAR 0 1
112086: PPUSH
112087: LD_INT 0
112089: PPUSH
112090: CALL_OW 234
// end ;
112094: GO 112079
112096: POP
112097: POP
// end ;
112098: PPOPN 2
112100: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
112101: LD_EXP 161
112105: PUSH
112106: LD_EXP 167
112110: AND
112111: IFFALSE 112195
112113: GO 112115
112115: DISABLE
112116: LD_INT 0
112118: PPUSH
112119: PPUSH
// begin enable ;
112120: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
112121: LD_ADDR_VAR 0 2
112125: PUSH
112126: LD_INT 22
112128: PUSH
112129: LD_OWVAR 2
112133: PUSH
112134: EMPTY
112135: LIST
112136: LIST
112137: PUSH
112138: LD_INT 32
112140: PUSH
112141: LD_INT 3
112143: PUSH
112144: EMPTY
112145: LIST
112146: LIST
112147: PUSH
112148: EMPTY
112149: LIST
112150: LIST
112151: PPUSH
112152: CALL_OW 69
112156: ST_TO_ADDR
// if not tmp then
112157: LD_VAR 0 2
112161: NOT
112162: IFFALSE 112166
// exit ;
112164: GO 112195
// for i in tmp do
112166: LD_ADDR_VAR 0 1
112170: PUSH
112171: LD_VAR 0 2
112175: PUSH
112176: FOR_IN
112177: IFFALSE 112193
// begin SetLives ( i , 0 ) ;
112179: LD_VAR 0 1
112183: PPUSH
112184: LD_INT 0
112186: PPUSH
112187: CALL_OW 234
// end ;
112191: GO 112176
112193: POP
112194: POP
// end ;
112195: PPOPN 2
112197: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
112198: LD_EXP 161
112202: PUSH
112203: LD_EXP 164
112207: AND
112208: IFFALSE 112301
112210: GO 112212
112212: DISABLE
112213: LD_INT 0
112215: PPUSH
// begin enable ;
112216: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
112217: LD_ADDR_VAR 0 1
112221: PUSH
112222: LD_INT 22
112224: PUSH
112225: LD_OWVAR 2
112229: PUSH
112230: EMPTY
112231: LIST
112232: LIST
112233: PUSH
112234: LD_INT 2
112236: PUSH
112237: LD_INT 25
112239: PUSH
112240: LD_INT 5
112242: PUSH
112243: EMPTY
112244: LIST
112245: LIST
112246: PUSH
112247: LD_INT 25
112249: PUSH
112250: LD_INT 9
112252: PUSH
112253: EMPTY
112254: LIST
112255: LIST
112256: PUSH
112257: LD_INT 25
112259: PUSH
112260: LD_INT 8
112262: PUSH
112263: EMPTY
112264: LIST
112265: LIST
112266: PUSH
112267: EMPTY
112268: LIST
112269: LIST
112270: LIST
112271: LIST
112272: PUSH
112273: EMPTY
112274: LIST
112275: LIST
112276: PPUSH
112277: CALL_OW 69
112281: PUSH
112282: FOR_IN
112283: IFFALSE 112299
// begin SetClass ( i , 1 ) ;
112285: LD_VAR 0 1
112289: PPUSH
112290: LD_INT 1
112292: PPUSH
112293: CALL_OW 336
// end ;
112297: GO 112282
112299: POP
112300: POP
// end ;
112301: PPOPN 1
112303: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
112304: LD_EXP 161
112308: PUSH
112309: LD_EXP 165
112313: AND
112314: PUSH
112315: LD_OWVAR 65
112319: PUSH
112320: LD_INT 7
112322: LESS
112323: AND
112324: IFFALSE 112338
112326: GO 112328
112328: DISABLE
// begin enable ;
112329: ENABLE
// game_speed := 7 ;
112330: LD_ADDR_OWVAR 65
112334: PUSH
112335: LD_INT 7
112337: ST_TO_ADDR
// end ;
112338: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
112339: LD_EXP 161
112343: PUSH
112344: LD_EXP 168
112348: AND
112349: IFFALSE 112551
112351: GO 112353
112353: DISABLE
112354: LD_INT 0
112356: PPUSH
112357: PPUSH
112358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
112359: LD_ADDR_VAR 0 3
112363: PUSH
112364: LD_INT 81
112366: PUSH
112367: LD_OWVAR 2
112371: PUSH
112372: EMPTY
112373: LIST
112374: LIST
112375: PUSH
112376: LD_INT 21
112378: PUSH
112379: LD_INT 1
112381: PUSH
112382: EMPTY
112383: LIST
112384: LIST
112385: PUSH
112386: EMPTY
112387: LIST
112388: LIST
112389: PPUSH
112390: CALL_OW 69
112394: ST_TO_ADDR
// if not tmp then
112395: LD_VAR 0 3
112399: NOT
112400: IFFALSE 112404
// exit ;
112402: GO 112551
// if tmp > 5 then
112404: LD_VAR 0 3
112408: PUSH
112409: LD_INT 5
112411: GREATER
112412: IFFALSE 112424
// k := 5 else
112414: LD_ADDR_VAR 0 2
112418: PUSH
112419: LD_INT 5
112421: ST_TO_ADDR
112422: GO 112434
// k := tmp ;
112424: LD_ADDR_VAR 0 2
112428: PUSH
112429: LD_VAR 0 3
112433: ST_TO_ADDR
// for i := 1 to k do
112434: LD_ADDR_VAR 0 1
112438: PUSH
112439: DOUBLE
112440: LD_INT 1
112442: DEC
112443: ST_TO_ADDR
112444: LD_VAR 0 2
112448: PUSH
112449: FOR_TO
112450: IFFALSE 112549
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
112452: LD_VAR 0 3
112456: PUSH
112457: LD_VAR 0 1
112461: ARRAY
112462: PPUSH
112463: LD_VAR 0 1
112467: PUSH
112468: LD_INT 4
112470: MOD
112471: PUSH
112472: LD_INT 1
112474: PLUS
112475: PPUSH
112476: CALL_OW 259
112480: PUSH
112481: LD_INT 10
112483: LESS
112484: IFFALSE 112547
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
112486: LD_VAR 0 3
112490: PUSH
112491: LD_VAR 0 1
112495: ARRAY
112496: PPUSH
112497: LD_VAR 0 1
112501: PUSH
112502: LD_INT 4
112504: MOD
112505: PUSH
112506: LD_INT 1
112508: PLUS
112509: PPUSH
112510: LD_VAR 0 3
112514: PUSH
112515: LD_VAR 0 1
112519: ARRAY
112520: PPUSH
112521: LD_VAR 0 1
112525: PUSH
112526: LD_INT 4
112528: MOD
112529: PUSH
112530: LD_INT 1
112532: PLUS
112533: PPUSH
112534: CALL_OW 259
112538: PUSH
112539: LD_INT 1
112541: PLUS
112542: PPUSH
112543: CALL_OW 237
112547: GO 112449
112549: POP
112550: POP
// end ;
112551: PPOPN 3
112553: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
112554: LD_EXP 161
112558: PUSH
112559: LD_EXP 169
112563: AND
112564: IFFALSE 112584
112566: GO 112568
112568: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
112569: LD_INT 4
112571: PPUSH
112572: LD_OWVAR 2
112576: PPUSH
112577: LD_INT 0
112579: PPUSH
112580: CALL_OW 324
112584: END
// every 0 0$1 trigger StreamModeActive and sShovel do
112585: LD_EXP 161
112589: PUSH
112590: LD_EXP 198
112594: AND
112595: IFFALSE 112615
112597: GO 112599
112599: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
112600: LD_INT 19
112602: PPUSH
112603: LD_OWVAR 2
112607: PPUSH
112608: LD_INT 0
112610: PPUSH
112611: CALL_OW 324
112615: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
112616: LD_EXP 161
112620: PUSH
112621: LD_EXP 170
112625: AND
112626: IFFALSE 112728
112628: GO 112630
112630: DISABLE
112631: LD_INT 0
112633: PPUSH
112634: PPUSH
// begin enable ;
112635: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
112636: LD_ADDR_VAR 0 2
112640: PUSH
112641: LD_INT 22
112643: PUSH
112644: LD_OWVAR 2
112648: PUSH
112649: EMPTY
112650: LIST
112651: LIST
112652: PUSH
112653: LD_INT 2
112655: PUSH
112656: LD_INT 34
112658: PUSH
112659: LD_INT 11
112661: PUSH
112662: EMPTY
112663: LIST
112664: LIST
112665: PUSH
112666: LD_INT 34
112668: PUSH
112669: LD_INT 30
112671: PUSH
112672: EMPTY
112673: LIST
112674: LIST
112675: PUSH
112676: EMPTY
112677: LIST
112678: LIST
112679: LIST
112680: PUSH
112681: EMPTY
112682: LIST
112683: LIST
112684: PPUSH
112685: CALL_OW 69
112689: ST_TO_ADDR
// if not tmp then
112690: LD_VAR 0 2
112694: NOT
112695: IFFALSE 112699
// exit ;
112697: GO 112728
// for i in tmp do
112699: LD_ADDR_VAR 0 1
112703: PUSH
112704: LD_VAR 0 2
112708: PUSH
112709: FOR_IN
112710: IFFALSE 112726
// begin SetLives ( i , 0 ) ;
112712: LD_VAR 0 1
112716: PPUSH
112717: LD_INT 0
112719: PPUSH
112720: CALL_OW 234
// end ;
112724: GO 112709
112726: POP
112727: POP
// end ;
112728: PPOPN 2
112730: END
// every 0 0$1 trigger StreamModeActive and sBunker do
112731: LD_EXP 161
112735: PUSH
112736: LD_EXP 171
112740: AND
112741: IFFALSE 112761
112743: GO 112745
112745: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
112746: LD_INT 32
112748: PPUSH
112749: LD_OWVAR 2
112753: PPUSH
112754: LD_INT 0
112756: PPUSH
112757: CALL_OW 324
112761: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
112762: LD_EXP 161
112766: PUSH
112767: LD_EXP 172
112771: AND
112772: IFFALSE 112953
112774: GO 112776
112776: DISABLE
112777: LD_INT 0
112779: PPUSH
112780: PPUSH
112781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
112782: LD_ADDR_VAR 0 2
112786: PUSH
112787: LD_INT 22
112789: PUSH
112790: LD_OWVAR 2
112794: PUSH
112795: EMPTY
112796: LIST
112797: LIST
112798: PUSH
112799: LD_INT 33
112801: PUSH
112802: LD_INT 3
112804: PUSH
112805: EMPTY
112806: LIST
112807: LIST
112808: PUSH
112809: EMPTY
112810: LIST
112811: LIST
112812: PPUSH
112813: CALL_OW 69
112817: ST_TO_ADDR
// if not tmp then
112818: LD_VAR 0 2
112822: NOT
112823: IFFALSE 112827
// exit ;
112825: GO 112953
// side := 0 ;
112827: LD_ADDR_VAR 0 3
112831: PUSH
112832: LD_INT 0
112834: ST_TO_ADDR
// for i := 1 to 8 do
112835: LD_ADDR_VAR 0 1
112839: PUSH
112840: DOUBLE
112841: LD_INT 1
112843: DEC
112844: ST_TO_ADDR
112845: LD_INT 8
112847: PUSH
112848: FOR_TO
112849: IFFALSE 112897
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
112851: LD_OWVAR 2
112855: PUSH
112856: LD_VAR 0 1
112860: NONEQUAL
112861: PUSH
112862: LD_OWVAR 2
112866: PPUSH
112867: LD_VAR 0 1
112871: PPUSH
112872: CALL_OW 81
112876: PUSH
112877: LD_INT 2
112879: EQUAL
112880: AND
112881: IFFALSE 112895
// begin side := i ;
112883: LD_ADDR_VAR 0 3
112887: PUSH
112888: LD_VAR 0 1
112892: ST_TO_ADDR
// break ;
112893: GO 112897
// end ;
112895: GO 112848
112897: POP
112898: POP
// if not side then
112899: LD_VAR 0 3
112903: NOT
112904: IFFALSE 112908
// exit ;
112906: GO 112953
// for i := 1 to tmp do
112908: LD_ADDR_VAR 0 1
112912: PUSH
112913: DOUBLE
112914: LD_INT 1
112916: DEC
112917: ST_TO_ADDR
112918: LD_VAR 0 2
112922: PUSH
112923: FOR_TO
112924: IFFALSE 112951
// if Prob ( 60 ) then
112926: LD_INT 60
112928: PPUSH
112929: CALL_OW 13
112933: IFFALSE 112949
// SetSide ( i , side ) ;
112935: LD_VAR 0 1
112939: PPUSH
112940: LD_VAR 0 3
112944: PPUSH
112945: CALL_OW 235
112949: GO 112923
112951: POP
112952: POP
// end ;
112953: PPOPN 3
112955: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
112956: LD_EXP 161
112960: PUSH
112961: LD_EXP 174
112965: AND
112966: IFFALSE 113085
112968: GO 112970
112970: DISABLE
112971: LD_INT 0
112973: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
112974: LD_ADDR_VAR 0 1
112978: PUSH
112979: LD_INT 22
112981: PUSH
112982: LD_OWVAR 2
112986: PUSH
112987: EMPTY
112988: LIST
112989: LIST
112990: PUSH
112991: LD_INT 21
112993: PUSH
112994: LD_INT 1
112996: PUSH
112997: EMPTY
112998: LIST
112999: LIST
113000: PUSH
113001: LD_INT 3
113003: PUSH
113004: LD_INT 23
113006: PUSH
113007: LD_INT 0
113009: PUSH
113010: EMPTY
113011: LIST
113012: LIST
113013: PUSH
113014: EMPTY
113015: LIST
113016: LIST
113017: PUSH
113018: EMPTY
113019: LIST
113020: LIST
113021: LIST
113022: PPUSH
113023: CALL_OW 69
113027: PUSH
113028: FOR_IN
113029: IFFALSE 113083
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
113031: LD_VAR 0 1
113035: PPUSH
113036: CALL_OW 257
113040: PUSH
113041: LD_INT 1
113043: PUSH
113044: LD_INT 2
113046: PUSH
113047: LD_INT 3
113049: PUSH
113050: LD_INT 4
113052: PUSH
113053: EMPTY
113054: LIST
113055: LIST
113056: LIST
113057: LIST
113058: IN
113059: IFFALSE 113081
// SetClass ( un , rand ( 1 , 4 ) ) ;
113061: LD_VAR 0 1
113065: PPUSH
113066: LD_INT 1
113068: PPUSH
113069: LD_INT 4
113071: PPUSH
113072: CALL_OW 12
113076: PPUSH
113077: CALL_OW 336
113081: GO 113028
113083: POP
113084: POP
// end ;
113085: PPOPN 1
113087: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
113088: LD_EXP 161
113092: PUSH
113093: LD_EXP 173
113097: AND
113098: IFFALSE 113177
113100: GO 113102
113102: DISABLE
113103: LD_INT 0
113105: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
113106: LD_ADDR_VAR 0 1
113110: PUSH
113111: LD_INT 22
113113: PUSH
113114: LD_OWVAR 2
113118: PUSH
113119: EMPTY
113120: LIST
113121: LIST
113122: PUSH
113123: LD_INT 21
113125: PUSH
113126: LD_INT 3
113128: PUSH
113129: EMPTY
113130: LIST
113131: LIST
113132: PUSH
113133: EMPTY
113134: LIST
113135: LIST
113136: PPUSH
113137: CALL_OW 69
113141: ST_TO_ADDR
// if not tmp then
113142: LD_VAR 0 1
113146: NOT
113147: IFFALSE 113151
// exit ;
113149: GO 113177
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
113151: LD_VAR 0 1
113155: PUSH
113156: LD_INT 1
113158: PPUSH
113159: LD_VAR 0 1
113163: PPUSH
113164: CALL_OW 12
113168: ARRAY
113169: PPUSH
113170: LD_INT 100
113172: PPUSH
113173: CALL_OW 234
// end ;
113177: PPOPN 1
113179: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
113180: LD_EXP 161
113184: PUSH
113185: LD_EXP 175
113189: AND
113190: IFFALSE 113288
113192: GO 113194
113194: DISABLE
113195: LD_INT 0
113197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
113198: LD_ADDR_VAR 0 1
113202: PUSH
113203: LD_INT 22
113205: PUSH
113206: LD_OWVAR 2
113210: PUSH
113211: EMPTY
113212: LIST
113213: LIST
113214: PUSH
113215: LD_INT 21
113217: PUSH
113218: LD_INT 1
113220: PUSH
113221: EMPTY
113222: LIST
113223: LIST
113224: PUSH
113225: EMPTY
113226: LIST
113227: LIST
113228: PPUSH
113229: CALL_OW 69
113233: ST_TO_ADDR
// if not tmp then
113234: LD_VAR 0 1
113238: NOT
113239: IFFALSE 113243
// exit ;
113241: GO 113288
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
113243: LD_VAR 0 1
113247: PUSH
113248: LD_INT 1
113250: PPUSH
113251: LD_VAR 0 1
113255: PPUSH
113256: CALL_OW 12
113260: ARRAY
113261: PPUSH
113262: LD_INT 1
113264: PPUSH
113265: LD_INT 4
113267: PPUSH
113268: CALL_OW 12
113272: PPUSH
113273: LD_INT 3000
113275: PPUSH
113276: LD_INT 9000
113278: PPUSH
113279: CALL_OW 12
113283: PPUSH
113284: CALL_OW 492
// end ;
113288: PPOPN 1
113290: END
// every 0 0$1 trigger StreamModeActive and sDepot do
113291: LD_EXP 161
113295: PUSH
113296: LD_EXP 176
113300: AND
113301: IFFALSE 113321
113303: GO 113305
113305: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
113306: LD_INT 1
113308: PPUSH
113309: LD_OWVAR 2
113313: PPUSH
113314: LD_INT 0
113316: PPUSH
113317: CALL_OW 324
113321: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
113322: LD_EXP 161
113326: PUSH
113327: LD_EXP 177
113331: AND
113332: IFFALSE 113415
113334: GO 113336
113336: DISABLE
113337: LD_INT 0
113339: PPUSH
113340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
113341: LD_ADDR_VAR 0 2
113345: PUSH
113346: LD_INT 22
113348: PUSH
113349: LD_OWVAR 2
113353: PUSH
113354: EMPTY
113355: LIST
113356: LIST
113357: PUSH
113358: LD_INT 21
113360: PUSH
113361: LD_INT 3
113363: PUSH
113364: EMPTY
113365: LIST
113366: LIST
113367: PUSH
113368: EMPTY
113369: LIST
113370: LIST
113371: PPUSH
113372: CALL_OW 69
113376: ST_TO_ADDR
// if not tmp then
113377: LD_VAR 0 2
113381: NOT
113382: IFFALSE 113386
// exit ;
113384: GO 113415
// for i in tmp do
113386: LD_ADDR_VAR 0 1
113390: PUSH
113391: LD_VAR 0 2
113395: PUSH
113396: FOR_IN
113397: IFFALSE 113413
// SetBLevel ( i , 10 ) ;
113399: LD_VAR 0 1
113403: PPUSH
113404: LD_INT 10
113406: PPUSH
113407: CALL_OW 241
113411: GO 113396
113413: POP
113414: POP
// end ;
113415: PPOPN 2
113417: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
113418: LD_EXP 161
113422: PUSH
113423: LD_EXP 178
113427: AND
113428: IFFALSE 113539
113430: GO 113432
113432: DISABLE
113433: LD_INT 0
113435: PPUSH
113436: PPUSH
113437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113438: LD_ADDR_VAR 0 3
113442: PUSH
113443: LD_INT 22
113445: PUSH
113446: LD_OWVAR 2
113450: PUSH
113451: EMPTY
113452: LIST
113453: LIST
113454: PUSH
113455: LD_INT 25
113457: PUSH
113458: LD_INT 1
113460: PUSH
113461: EMPTY
113462: LIST
113463: LIST
113464: PUSH
113465: EMPTY
113466: LIST
113467: LIST
113468: PPUSH
113469: CALL_OW 69
113473: ST_TO_ADDR
// if not tmp then
113474: LD_VAR 0 3
113478: NOT
113479: IFFALSE 113483
// exit ;
113481: GO 113539
// un := tmp [ rand ( 1 , tmp ) ] ;
113483: LD_ADDR_VAR 0 2
113487: PUSH
113488: LD_VAR 0 3
113492: PUSH
113493: LD_INT 1
113495: PPUSH
113496: LD_VAR 0 3
113500: PPUSH
113501: CALL_OW 12
113505: ARRAY
113506: ST_TO_ADDR
// if Crawls ( un ) then
113507: LD_VAR 0 2
113511: PPUSH
113512: CALL_OW 318
113516: IFFALSE 113527
// ComWalk ( un ) ;
113518: LD_VAR 0 2
113522: PPUSH
113523: CALL_OW 138
// SetClass ( un , class_sniper ) ;
113527: LD_VAR 0 2
113531: PPUSH
113532: LD_INT 5
113534: PPUSH
113535: CALL_OW 336
// end ;
113539: PPOPN 3
113541: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
113542: LD_EXP 161
113546: PUSH
113547: LD_EXP 179
113551: AND
113552: PUSH
113553: LD_OWVAR 67
113557: PUSH
113558: LD_INT 4
113560: LESS
113561: AND
113562: IFFALSE 113581
113564: GO 113566
113566: DISABLE
// begin Difficulty := Difficulty + 1 ;
113567: LD_ADDR_OWVAR 67
113571: PUSH
113572: LD_OWVAR 67
113576: PUSH
113577: LD_INT 1
113579: PLUS
113580: ST_TO_ADDR
// end ;
113581: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
113582: LD_EXP 161
113586: PUSH
113587: LD_EXP 180
113591: AND
113592: IFFALSE 113695
113594: GO 113596
113596: DISABLE
113597: LD_INT 0
113599: PPUSH
// begin for i := 1 to 5 do
113600: LD_ADDR_VAR 0 1
113604: PUSH
113605: DOUBLE
113606: LD_INT 1
113608: DEC
113609: ST_TO_ADDR
113610: LD_INT 5
113612: PUSH
113613: FOR_TO
113614: IFFALSE 113693
// begin uc_nation := nation_nature ;
113616: LD_ADDR_OWVAR 21
113620: PUSH
113621: LD_INT 0
113623: ST_TO_ADDR
// uc_side := 0 ;
113624: LD_ADDR_OWVAR 20
113628: PUSH
113629: LD_INT 0
113631: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
113632: LD_ADDR_OWVAR 29
113636: PUSH
113637: LD_INT 12
113639: PUSH
113640: LD_INT 12
113642: PUSH
113643: EMPTY
113644: LIST
113645: LIST
113646: ST_TO_ADDR
// hc_agressivity := 20 ;
113647: LD_ADDR_OWVAR 35
113651: PUSH
113652: LD_INT 20
113654: ST_TO_ADDR
// hc_class := class_tiger ;
113655: LD_ADDR_OWVAR 28
113659: PUSH
113660: LD_INT 14
113662: ST_TO_ADDR
// hc_gallery :=  ;
113663: LD_ADDR_OWVAR 33
113667: PUSH
113668: LD_STRING 
113670: ST_TO_ADDR
// hc_name :=  ;
113671: LD_ADDR_OWVAR 26
113675: PUSH
113676: LD_STRING 
113678: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
113679: CALL_OW 44
113683: PPUSH
113684: LD_INT 0
113686: PPUSH
113687: CALL_OW 51
// end ;
113691: GO 113613
113693: POP
113694: POP
// end ;
113695: PPOPN 1
113697: END
// every 0 0$1 trigger StreamModeActive and sBomb do
113698: LD_EXP 161
113702: PUSH
113703: LD_EXP 181
113707: AND
113708: IFFALSE 113717
113710: GO 113712
113712: DISABLE
// StreamSibBomb ;
113713: CALL 113718 0 0
113717: END
// export function StreamSibBomb ; var i , x , y ; begin
113718: LD_INT 0
113720: PPUSH
113721: PPUSH
113722: PPUSH
113723: PPUSH
// result := false ;
113724: LD_ADDR_VAR 0 1
113728: PUSH
113729: LD_INT 0
113731: ST_TO_ADDR
// for i := 1 to 16 do
113732: LD_ADDR_VAR 0 2
113736: PUSH
113737: DOUBLE
113738: LD_INT 1
113740: DEC
113741: ST_TO_ADDR
113742: LD_INT 16
113744: PUSH
113745: FOR_TO
113746: IFFALSE 113945
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
113748: LD_ADDR_VAR 0 3
113752: PUSH
113753: LD_INT 10
113755: PUSH
113756: LD_INT 20
113758: PUSH
113759: LD_INT 30
113761: PUSH
113762: LD_INT 40
113764: PUSH
113765: LD_INT 50
113767: PUSH
113768: LD_INT 60
113770: PUSH
113771: LD_INT 70
113773: PUSH
113774: LD_INT 80
113776: PUSH
113777: LD_INT 90
113779: PUSH
113780: LD_INT 100
113782: PUSH
113783: LD_INT 110
113785: PUSH
113786: LD_INT 120
113788: PUSH
113789: LD_INT 130
113791: PUSH
113792: LD_INT 140
113794: PUSH
113795: LD_INT 150
113797: PUSH
113798: EMPTY
113799: LIST
113800: LIST
113801: LIST
113802: LIST
113803: LIST
113804: LIST
113805: LIST
113806: LIST
113807: LIST
113808: LIST
113809: LIST
113810: LIST
113811: LIST
113812: LIST
113813: LIST
113814: PUSH
113815: LD_INT 1
113817: PPUSH
113818: LD_INT 15
113820: PPUSH
113821: CALL_OW 12
113825: ARRAY
113826: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
113827: LD_ADDR_VAR 0 4
113831: PUSH
113832: LD_INT 10
113834: PUSH
113835: LD_INT 20
113837: PUSH
113838: LD_INT 30
113840: PUSH
113841: LD_INT 40
113843: PUSH
113844: LD_INT 50
113846: PUSH
113847: LD_INT 60
113849: PUSH
113850: LD_INT 70
113852: PUSH
113853: LD_INT 80
113855: PUSH
113856: LD_INT 90
113858: PUSH
113859: LD_INT 100
113861: PUSH
113862: LD_INT 110
113864: PUSH
113865: LD_INT 120
113867: PUSH
113868: LD_INT 130
113870: PUSH
113871: LD_INT 140
113873: PUSH
113874: LD_INT 150
113876: PUSH
113877: EMPTY
113878: LIST
113879: LIST
113880: LIST
113881: LIST
113882: LIST
113883: LIST
113884: LIST
113885: LIST
113886: LIST
113887: LIST
113888: LIST
113889: LIST
113890: LIST
113891: LIST
113892: LIST
113893: PUSH
113894: LD_INT 1
113896: PPUSH
113897: LD_INT 15
113899: PPUSH
113900: CALL_OW 12
113904: ARRAY
113905: ST_TO_ADDR
// if ValidHex ( x , y ) then
113906: LD_VAR 0 3
113910: PPUSH
113911: LD_VAR 0 4
113915: PPUSH
113916: CALL_OW 488
113920: IFFALSE 113943
// begin result := [ x , y ] ;
113922: LD_ADDR_VAR 0 1
113926: PUSH
113927: LD_VAR 0 3
113931: PUSH
113932: LD_VAR 0 4
113936: PUSH
113937: EMPTY
113938: LIST
113939: LIST
113940: ST_TO_ADDR
// break ;
113941: GO 113945
// end ; end ;
113943: GO 113745
113945: POP
113946: POP
// if result then
113947: LD_VAR 0 1
113951: IFFALSE 114011
// begin ToLua ( playSibBomb() ) ;
113953: LD_STRING playSibBomb()
113955: PPUSH
113956: CALL_OW 559
// wait ( 0 0$14 ) ;
113960: LD_INT 490
113962: PPUSH
113963: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
113967: LD_VAR 0 1
113971: PUSH
113972: LD_INT 1
113974: ARRAY
113975: PPUSH
113976: LD_VAR 0 1
113980: PUSH
113981: LD_INT 2
113983: ARRAY
113984: PPUSH
113985: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
113989: LD_VAR 0 1
113993: PUSH
113994: LD_INT 1
113996: ARRAY
113997: PPUSH
113998: LD_VAR 0 1
114002: PUSH
114003: LD_INT 2
114005: ARRAY
114006: PPUSH
114007: CALL_OW 429
// end ; end ;
114011: LD_VAR 0 1
114015: RET
// every 0 0$1 trigger StreamModeActive and sReset do
114016: LD_EXP 161
114020: PUSH
114021: LD_EXP 183
114025: AND
114026: IFFALSE 114038
114028: GO 114030
114030: DISABLE
// YouLost (  ) ;
114031: LD_STRING 
114033: PPUSH
114034: CALL_OW 104
114038: END
// every 0 0$1 trigger StreamModeActive and sFog do
114039: LD_EXP 161
114043: PUSH
114044: LD_EXP 182
114048: AND
114049: IFFALSE 114063
114051: GO 114053
114053: DISABLE
// FogOff ( your_side ) ;
114054: LD_OWVAR 2
114058: PPUSH
114059: CALL_OW 344
114063: END
// every 0 0$1 trigger StreamModeActive and sSun do
114064: LD_EXP 161
114068: PUSH
114069: LD_EXP 184
114073: AND
114074: IFFALSE 114102
114076: GO 114078
114078: DISABLE
// begin solar_recharge_percent := 0 ;
114079: LD_ADDR_OWVAR 79
114083: PUSH
114084: LD_INT 0
114086: ST_TO_ADDR
// wait ( 5 5$00 ) ;
114087: LD_INT 10500
114089: PPUSH
114090: CALL_OW 67
// solar_recharge_percent := 100 ;
114094: LD_ADDR_OWVAR 79
114098: PUSH
114099: LD_INT 100
114101: ST_TO_ADDR
// end ;
114102: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
114103: LD_EXP 161
114107: PUSH
114108: LD_EXP 185
114112: AND
114113: IFFALSE 114352
114115: GO 114117
114117: DISABLE
114118: LD_INT 0
114120: PPUSH
114121: PPUSH
114122: PPUSH
// begin tmp := [ ] ;
114123: LD_ADDR_VAR 0 3
114127: PUSH
114128: EMPTY
114129: ST_TO_ADDR
// for i := 1 to 6 do
114130: LD_ADDR_VAR 0 1
114134: PUSH
114135: DOUBLE
114136: LD_INT 1
114138: DEC
114139: ST_TO_ADDR
114140: LD_INT 6
114142: PUSH
114143: FOR_TO
114144: IFFALSE 114249
// begin uc_nation := nation_nature ;
114146: LD_ADDR_OWVAR 21
114150: PUSH
114151: LD_INT 0
114153: ST_TO_ADDR
// uc_side := 0 ;
114154: LD_ADDR_OWVAR 20
114158: PUSH
114159: LD_INT 0
114161: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114162: LD_ADDR_OWVAR 29
114166: PUSH
114167: LD_INT 12
114169: PUSH
114170: LD_INT 12
114172: PUSH
114173: EMPTY
114174: LIST
114175: LIST
114176: ST_TO_ADDR
// hc_agressivity := 20 ;
114177: LD_ADDR_OWVAR 35
114181: PUSH
114182: LD_INT 20
114184: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
114185: LD_ADDR_OWVAR 28
114189: PUSH
114190: LD_INT 17
114192: ST_TO_ADDR
// hc_gallery :=  ;
114193: LD_ADDR_OWVAR 33
114197: PUSH
114198: LD_STRING 
114200: ST_TO_ADDR
// hc_name :=  ;
114201: LD_ADDR_OWVAR 26
114205: PUSH
114206: LD_STRING 
114208: ST_TO_ADDR
// un := CreateHuman ;
114209: LD_ADDR_VAR 0 2
114213: PUSH
114214: CALL_OW 44
114218: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
114219: LD_VAR 0 2
114223: PPUSH
114224: LD_INT 1
114226: PPUSH
114227: CALL_OW 51
// tmp := tmp ^ un ;
114231: LD_ADDR_VAR 0 3
114235: PUSH
114236: LD_VAR 0 3
114240: PUSH
114241: LD_VAR 0 2
114245: ADD
114246: ST_TO_ADDR
// end ;
114247: GO 114143
114249: POP
114250: POP
// repeat wait ( 0 0$1 ) ;
114251: LD_INT 35
114253: PPUSH
114254: CALL_OW 67
// for un in tmp do
114258: LD_ADDR_VAR 0 2
114262: PUSH
114263: LD_VAR 0 3
114267: PUSH
114268: FOR_IN
114269: IFFALSE 114343
// begin if IsDead ( un ) then
114271: LD_VAR 0 2
114275: PPUSH
114276: CALL_OW 301
114280: IFFALSE 114300
// begin tmp := tmp diff un ;
114282: LD_ADDR_VAR 0 3
114286: PUSH
114287: LD_VAR 0 3
114291: PUSH
114292: LD_VAR 0 2
114296: DIFF
114297: ST_TO_ADDR
// continue ;
114298: GO 114268
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
114300: LD_VAR 0 2
114304: PPUSH
114305: LD_INT 3
114307: PUSH
114308: LD_INT 22
114310: PUSH
114311: LD_INT 0
114313: PUSH
114314: EMPTY
114315: LIST
114316: LIST
114317: PUSH
114318: EMPTY
114319: LIST
114320: LIST
114321: PPUSH
114322: CALL_OW 69
114326: PPUSH
114327: LD_VAR 0 2
114331: PPUSH
114332: CALL_OW 74
114336: PPUSH
114337: CALL_OW 115
// end ;
114341: GO 114268
114343: POP
114344: POP
// until not tmp ;
114345: LD_VAR 0 3
114349: NOT
114350: IFFALSE 114251
// end ;
114352: PPOPN 3
114354: END
// every 0 0$1 trigger StreamModeActive and sTroll do
114355: LD_EXP 161
114359: PUSH
114360: LD_EXP 186
114364: AND
114365: IFFALSE 114419
114367: GO 114369
114369: DISABLE
// begin ToLua ( displayTroll(); ) ;
114370: LD_STRING displayTroll();
114372: PPUSH
114373: CALL_OW 559
// wait ( 3 3$00 ) ;
114377: LD_INT 6300
114379: PPUSH
114380: CALL_OW 67
// ToLua ( hideTroll(); ) ;
114384: LD_STRING hideTroll();
114386: PPUSH
114387: CALL_OW 559
// wait ( 1 1$00 ) ;
114391: LD_INT 2100
114393: PPUSH
114394: CALL_OW 67
// ToLua ( displayTroll(); ) ;
114398: LD_STRING displayTroll();
114400: PPUSH
114401: CALL_OW 559
// wait ( 1 1$00 ) ;
114405: LD_INT 2100
114407: PPUSH
114408: CALL_OW 67
// ToLua ( hideTroll(); ) ;
114412: LD_STRING hideTroll();
114414: PPUSH
114415: CALL_OW 559
// end ;
114419: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
114420: LD_EXP 161
114424: PUSH
114425: LD_EXP 187
114429: AND
114430: IFFALSE 114493
114432: GO 114434
114434: DISABLE
114435: LD_INT 0
114437: PPUSH
// begin p := 0 ;
114438: LD_ADDR_VAR 0 1
114442: PUSH
114443: LD_INT 0
114445: ST_TO_ADDR
// repeat game_speed := 1 ;
114446: LD_ADDR_OWVAR 65
114450: PUSH
114451: LD_INT 1
114453: ST_TO_ADDR
// wait ( 0 0$1 ) ;
114454: LD_INT 35
114456: PPUSH
114457: CALL_OW 67
// p := p + 1 ;
114461: LD_ADDR_VAR 0 1
114465: PUSH
114466: LD_VAR 0 1
114470: PUSH
114471: LD_INT 1
114473: PLUS
114474: ST_TO_ADDR
// until p >= 60 ;
114475: LD_VAR 0 1
114479: PUSH
114480: LD_INT 60
114482: GREATEREQUAL
114483: IFFALSE 114446
// game_speed := 4 ;
114485: LD_ADDR_OWVAR 65
114489: PUSH
114490: LD_INT 4
114492: ST_TO_ADDR
// end ;
114493: PPOPN 1
114495: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
114496: LD_EXP 161
114500: PUSH
114501: LD_EXP 188
114505: AND
114506: IFFALSE 114652
114508: GO 114510
114510: DISABLE
114511: LD_INT 0
114513: PPUSH
114514: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114515: LD_ADDR_VAR 0 1
114519: PUSH
114520: LD_INT 22
114522: PUSH
114523: LD_OWVAR 2
114527: PUSH
114528: EMPTY
114529: LIST
114530: LIST
114531: PUSH
114532: LD_INT 2
114534: PUSH
114535: LD_INT 30
114537: PUSH
114538: LD_INT 0
114540: PUSH
114541: EMPTY
114542: LIST
114543: LIST
114544: PUSH
114545: LD_INT 30
114547: PUSH
114548: LD_INT 1
114550: PUSH
114551: EMPTY
114552: LIST
114553: LIST
114554: PUSH
114555: EMPTY
114556: LIST
114557: LIST
114558: LIST
114559: PUSH
114560: EMPTY
114561: LIST
114562: LIST
114563: PPUSH
114564: CALL_OW 69
114568: ST_TO_ADDR
// if not depot then
114569: LD_VAR 0 1
114573: NOT
114574: IFFALSE 114578
// exit ;
114576: GO 114652
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
114578: LD_ADDR_VAR 0 2
114582: PUSH
114583: LD_VAR 0 1
114587: PUSH
114588: LD_INT 1
114590: PPUSH
114591: LD_VAR 0 1
114595: PPUSH
114596: CALL_OW 12
114600: ARRAY
114601: PPUSH
114602: CALL_OW 274
114606: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
114607: LD_VAR 0 2
114611: PPUSH
114612: LD_INT 1
114614: PPUSH
114615: LD_INT 0
114617: PPUSH
114618: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
114622: LD_VAR 0 2
114626: PPUSH
114627: LD_INT 2
114629: PPUSH
114630: LD_INT 0
114632: PPUSH
114633: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
114637: LD_VAR 0 2
114641: PPUSH
114642: LD_INT 3
114644: PPUSH
114645: LD_INT 0
114647: PPUSH
114648: CALL_OW 277
// end ;
114652: PPOPN 2
114654: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
114655: LD_EXP 161
114659: PUSH
114660: LD_EXP 189
114664: AND
114665: IFFALSE 114762
114667: GO 114669
114669: DISABLE
114670: LD_INT 0
114672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
114673: LD_ADDR_VAR 0 1
114677: PUSH
114678: LD_INT 22
114680: PUSH
114681: LD_OWVAR 2
114685: PUSH
114686: EMPTY
114687: LIST
114688: LIST
114689: PUSH
114690: LD_INT 21
114692: PUSH
114693: LD_INT 1
114695: PUSH
114696: EMPTY
114697: LIST
114698: LIST
114699: PUSH
114700: LD_INT 3
114702: PUSH
114703: LD_INT 23
114705: PUSH
114706: LD_INT 0
114708: PUSH
114709: EMPTY
114710: LIST
114711: LIST
114712: PUSH
114713: EMPTY
114714: LIST
114715: LIST
114716: PUSH
114717: EMPTY
114718: LIST
114719: LIST
114720: LIST
114721: PPUSH
114722: CALL_OW 69
114726: ST_TO_ADDR
// if not tmp then
114727: LD_VAR 0 1
114731: NOT
114732: IFFALSE 114736
// exit ;
114734: GO 114762
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
114736: LD_VAR 0 1
114740: PUSH
114741: LD_INT 1
114743: PPUSH
114744: LD_VAR 0 1
114748: PPUSH
114749: CALL_OW 12
114753: ARRAY
114754: PPUSH
114755: LD_INT 200
114757: PPUSH
114758: CALL_OW 234
// end ;
114762: PPOPN 1
114764: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
114765: LD_EXP 161
114769: PUSH
114770: LD_EXP 190
114774: AND
114775: IFFALSE 114854
114777: GO 114779
114779: DISABLE
114780: LD_INT 0
114782: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
114783: LD_ADDR_VAR 0 1
114787: PUSH
114788: LD_INT 22
114790: PUSH
114791: LD_OWVAR 2
114795: PUSH
114796: EMPTY
114797: LIST
114798: LIST
114799: PUSH
114800: LD_INT 21
114802: PUSH
114803: LD_INT 2
114805: PUSH
114806: EMPTY
114807: LIST
114808: LIST
114809: PUSH
114810: EMPTY
114811: LIST
114812: LIST
114813: PPUSH
114814: CALL_OW 69
114818: ST_TO_ADDR
// if not tmp then
114819: LD_VAR 0 1
114823: NOT
114824: IFFALSE 114828
// exit ;
114826: GO 114854
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
114828: LD_VAR 0 1
114832: PUSH
114833: LD_INT 1
114835: PPUSH
114836: LD_VAR 0 1
114840: PPUSH
114841: CALL_OW 12
114845: ARRAY
114846: PPUSH
114847: LD_INT 60
114849: PPUSH
114850: CALL_OW 234
// end ;
114854: PPOPN 1
114856: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
114857: LD_EXP 161
114861: PUSH
114862: LD_EXP 191
114866: AND
114867: IFFALSE 114966
114869: GO 114871
114871: DISABLE
114872: LD_INT 0
114874: PPUSH
114875: PPUSH
// begin enable ;
114876: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
114877: LD_ADDR_VAR 0 1
114881: PUSH
114882: LD_INT 22
114884: PUSH
114885: LD_OWVAR 2
114889: PUSH
114890: EMPTY
114891: LIST
114892: LIST
114893: PUSH
114894: LD_INT 61
114896: PUSH
114897: EMPTY
114898: LIST
114899: PUSH
114900: LD_INT 33
114902: PUSH
114903: LD_INT 2
114905: PUSH
114906: EMPTY
114907: LIST
114908: LIST
114909: PUSH
114910: EMPTY
114911: LIST
114912: LIST
114913: LIST
114914: PPUSH
114915: CALL_OW 69
114919: ST_TO_ADDR
// if not tmp then
114920: LD_VAR 0 1
114924: NOT
114925: IFFALSE 114929
// exit ;
114927: GO 114966
// for i in tmp do
114929: LD_ADDR_VAR 0 2
114933: PUSH
114934: LD_VAR 0 1
114938: PUSH
114939: FOR_IN
114940: IFFALSE 114964
// if IsControledBy ( i ) then
114942: LD_VAR 0 2
114946: PPUSH
114947: CALL_OW 312
114951: IFFALSE 114962
// ComUnlink ( i ) ;
114953: LD_VAR 0 2
114957: PPUSH
114958: CALL_OW 136
114962: GO 114939
114964: POP
114965: POP
// end ;
114966: PPOPN 2
114968: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
114969: LD_EXP 161
114973: PUSH
114974: LD_EXP 192
114978: AND
114979: IFFALSE 115119
114981: GO 114983
114983: DISABLE
114984: LD_INT 0
114986: PPUSH
114987: PPUSH
// begin ToLua ( displayPowell(); ) ;
114988: LD_STRING displayPowell();
114990: PPUSH
114991: CALL_OW 559
// uc_side := 0 ;
114995: LD_ADDR_OWVAR 20
114999: PUSH
115000: LD_INT 0
115002: ST_TO_ADDR
// uc_nation := 2 ;
115003: LD_ADDR_OWVAR 21
115007: PUSH
115008: LD_INT 2
115010: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
115011: LD_ADDR_OWVAR 37
115015: PUSH
115016: LD_INT 14
115018: ST_TO_ADDR
// vc_engine := engine_siberite ;
115019: LD_ADDR_OWVAR 39
115023: PUSH
115024: LD_INT 3
115026: ST_TO_ADDR
// vc_control := control_apeman ;
115027: LD_ADDR_OWVAR 38
115031: PUSH
115032: LD_INT 5
115034: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
115035: LD_ADDR_OWVAR 40
115039: PUSH
115040: LD_INT 29
115042: ST_TO_ADDR
// un := CreateVehicle ;
115043: LD_ADDR_VAR 0 2
115047: PUSH
115048: CALL_OW 45
115052: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115053: LD_VAR 0 2
115057: PPUSH
115058: LD_INT 1
115060: PPUSH
115061: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115065: LD_INT 35
115067: PPUSH
115068: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115072: LD_VAR 0 2
115076: PPUSH
115077: LD_INT 22
115079: PUSH
115080: LD_OWVAR 2
115084: PUSH
115085: EMPTY
115086: LIST
115087: LIST
115088: PPUSH
115089: CALL_OW 69
115093: PPUSH
115094: LD_VAR 0 2
115098: PPUSH
115099: CALL_OW 74
115103: PPUSH
115104: CALL_OW 115
// until IsDead ( un ) ;
115108: LD_VAR 0 2
115112: PPUSH
115113: CALL_OW 301
115117: IFFALSE 115065
// end ;
115119: PPOPN 2
115121: END
// every 0 0$1 trigger StreamModeActive and sStu do
115122: LD_EXP 161
115126: PUSH
115127: LD_EXP 200
115131: AND
115132: IFFALSE 115148
115134: GO 115136
115136: DISABLE
// begin ToLua ( displayStucuk(); ) ;
115137: LD_STRING displayStucuk();
115139: PPUSH
115140: CALL_OW 559
// ResetFog ;
115144: CALL_OW 335
// end ;
115148: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
115149: LD_EXP 161
115153: PUSH
115154: LD_EXP 193
115158: AND
115159: IFFALSE 115300
115161: GO 115163
115163: DISABLE
115164: LD_INT 0
115166: PPUSH
115167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115168: LD_ADDR_VAR 0 2
115172: PUSH
115173: LD_INT 22
115175: PUSH
115176: LD_OWVAR 2
115180: PUSH
115181: EMPTY
115182: LIST
115183: LIST
115184: PUSH
115185: LD_INT 21
115187: PUSH
115188: LD_INT 1
115190: PUSH
115191: EMPTY
115192: LIST
115193: LIST
115194: PUSH
115195: EMPTY
115196: LIST
115197: LIST
115198: PPUSH
115199: CALL_OW 69
115203: ST_TO_ADDR
// if not tmp then
115204: LD_VAR 0 2
115208: NOT
115209: IFFALSE 115213
// exit ;
115211: GO 115300
// un := tmp [ rand ( 1 , tmp ) ] ;
115213: LD_ADDR_VAR 0 1
115217: PUSH
115218: LD_VAR 0 2
115222: PUSH
115223: LD_INT 1
115225: PPUSH
115226: LD_VAR 0 2
115230: PPUSH
115231: CALL_OW 12
115235: ARRAY
115236: ST_TO_ADDR
// SetSide ( un , 0 ) ;
115237: LD_VAR 0 1
115241: PPUSH
115242: LD_INT 0
115244: PPUSH
115245: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
115249: LD_VAR 0 1
115253: PPUSH
115254: LD_OWVAR 3
115258: PUSH
115259: LD_VAR 0 1
115263: DIFF
115264: PPUSH
115265: LD_VAR 0 1
115269: PPUSH
115270: CALL_OW 74
115274: PPUSH
115275: CALL_OW 115
// wait ( 0 0$20 ) ;
115279: LD_INT 700
115281: PPUSH
115282: CALL_OW 67
// SetSide ( un , your_side ) ;
115286: LD_VAR 0 1
115290: PPUSH
115291: LD_OWVAR 2
115295: PPUSH
115296: CALL_OW 235
// end ;
115300: PPOPN 2
115302: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
115303: LD_EXP 161
115307: PUSH
115308: LD_EXP 194
115312: AND
115313: IFFALSE 115419
115315: GO 115317
115317: DISABLE
115318: LD_INT 0
115320: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115321: LD_ADDR_VAR 0 1
115325: PUSH
115326: LD_INT 22
115328: PUSH
115329: LD_OWVAR 2
115333: PUSH
115334: EMPTY
115335: LIST
115336: LIST
115337: PUSH
115338: LD_INT 2
115340: PUSH
115341: LD_INT 30
115343: PUSH
115344: LD_INT 0
115346: PUSH
115347: EMPTY
115348: LIST
115349: LIST
115350: PUSH
115351: LD_INT 30
115353: PUSH
115354: LD_INT 1
115356: PUSH
115357: EMPTY
115358: LIST
115359: LIST
115360: PUSH
115361: EMPTY
115362: LIST
115363: LIST
115364: LIST
115365: PUSH
115366: EMPTY
115367: LIST
115368: LIST
115369: PPUSH
115370: CALL_OW 69
115374: ST_TO_ADDR
// if not depot then
115375: LD_VAR 0 1
115379: NOT
115380: IFFALSE 115384
// exit ;
115382: GO 115419
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
115384: LD_VAR 0 1
115388: PUSH
115389: LD_INT 1
115391: ARRAY
115392: PPUSH
115393: CALL_OW 250
115397: PPUSH
115398: LD_VAR 0 1
115402: PUSH
115403: LD_INT 1
115405: ARRAY
115406: PPUSH
115407: CALL_OW 251
115411: PPUSH
115412: LD_INT 70
115414: PPUSH
115415: CALL_OW 495
// end ;
115419: PPOPN 1
115421: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
115422: LD_EXP 161
115426: PUSH
115427: LD_EXP 195
115431: AND
115432: IFFALSE 115643
115434: GO 115436
115436: DISABLE
115437: LD_INT 0
115439: PPUSH
115440: PPUSH
115441: PPUSH
115442: PPUSH
115443: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115444: LD_ADDR_VAR 0 5
115448: PUSH
115449: LD_INT 22
115451: PUSH
115452: LD_OWVAR 2
115456: PUSH
115457: EMPTY
115458: LIST
115459: LIST
115460: PUSH
115461: LD_INT 21
115463: PUSH
115464: LD_INT 1
115466: PUSH
115467: EMPTY
115468: LIST
115469: LIST
115470: PUSH
115471: EMPTY
115472: LIST
115473: LIST
115474: PPUSH
115475: CALL_OW 69
115479: ST_TO_ADDR
// if not tmp then
115480: LD_VAR 0 5
115484: NOT
115485: IFFALSE 115489
// exit ;
115487: GO 115643
// for i in tmp do
115489: LD_ADDR_VAR 0 1
115493: PUSH
115494: LD_VAR 0 5
115498: PUSH
115499: FOR_IN
115500: IFFALSE 115641
// begin d := rand ( 0 , 5 ) ;
115502: LD_ADDR_VAR 0 4
115506: PUSH
115507: LD_INT 0
115509: PPUSH
115510: LD_INT 5
115512: PPUSH
115513: CALL_OW 12
115517: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
115518: LD_ADDR_VAR 0 2
115522: PUSH
115523: LD_VAR 0 1
115527: PPUSH
115528: CALL_OW 250
115532: PPUSH
115533: LD_VAR 0 4
115537: PPUSH
115538: LD_INT 3
115540: PPUSH
115541: LD_INT 12
115543: PPUSH
115544: CALL_OW 12
115548: PPUSH
115549: CALL_OW 272
115553: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
115554: LD_ADDR_VAR 0 3
115558: PUSH
115559: LD_VAR 0 1
115563: PPUSH
115564: CALL_OW 251
115568: PPUSH
115569: LD_VAR 0 4
115573: PPUSH
115574: LD_INT 3
115576: PPUSH
115577: LD_INT 12
115579: PPUSH
115580: CALL_OW 12
115584: PPUSH
115585: CALL_OW 273
115589: ST_TO_ADDR
// if ValidHex ( x , y ) then
115590: LD_VAR 0 2
115594: PPUSH
115595: LD_VAR 0 3
115599: PPUSH
115600: CALL_OW 488
115604: IFFALSE 115639
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
115606: LD_VAR 0 1
115610: PPUSH
115611: LD_VAR 0 2
115615: PPUSH
115616: LD_VAR 0 3
115620: PPUSH
115621: LD_INT 3
115623: PPUSH
115624: LD_INT 6
115626: PPUSH
115627: CALL_OW 12
115631: PPUSH
115632: LD_INT 1
115634: PPUSH
115635: CALL_OW 483
// end ;
115639: GO 115499
115641: POP
115642: POP
// end ;
115643: PPOPN 5
115645: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
115646: LD_EXP 161
115650: PUSH
115651: LD_EXP 196
115655: AND
115656: IFFALSE 115750
115658: GO 115660
115660: DISABLE
115661: LD_INT 0
115663: PPUSH
115664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
115665: LD_ADDR_VAR 0 2
115669: PUSH
115670: LD_INT 22
115672: PUSH
115673: LD_OWVAR 2
115677: PUSH
115678: EMPTY
115679: LIST
115680: LIST
115681: PUSH
115682: LD_INT 32
115684: PUSH
115685: LD_INT 1
115687: PUSH
115688: EMPTY
115689: LIST
115690: LIST
115691: PUSH
115692: LD_INT 21
115694: PUSH
115695: LD_INT 2
115697: PUSH
115698: EMPTY
115699: LIST
115700: LIST
115701: PUSH
115702: EMPTY
115703: LIST
115704: LIST
115705: LIST
115706: PPUSH
115707: CALL_OW 69
115711: ST_TO_ADDR
// if not tmp then
115712: LD_VAR 0 2
115716: NOT
115717: IFFALSE 115721
// exit ;
115719: GO 115750
// for i in tmp do
115721: LD_ADDR_VAR 0 1
115725: PUSH
115726: LD_VAR 0 2
115730: PUSH
115731: FOR_IN
115732: IFFALSE 115748
// SetFuel ( i , 0 ) ;
115734: LD_VAR 0 1
115738: PPUSH
115739: LD_INT 0
115741: PPUSH
115742: CALL_OW 240
115746: GO 115731
115748: POP
115749: POP
// end ;
115750: PPOPN 2
115752: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
115753: LD_EXP 161
115757: PUSH
115758: LD_EXP 197
115762: AND
115763: IFFALSE 115829
115765: GO 115767
115767: DISABLE
115768: LD_INT 0
115770: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
115771: LD_ADDR_VAR 0 1
115775: PUSH
115776: LD_INT 22
115778: PUSH
115779: LD_OWVAR 2
115783: PUSH
115784: EMPTY
115785: LIST
115786: LIST
115787: PUSH
115788: LD_INT 30
115790: PUSH
115791: LD_INT 29
115793: PUSH
115794: EMPTY
115795: LIST
115796: LIST
115797: PUSH
115798: EMPTY
115799: LIST
115800: LIST
115801: PPUSH
115802: CALL_OW 69
115806: ST_TO_ADDR
// if not tmp then
115807: LD_VAR 0 1
115811: NOT
115812: IFFALSE 115816
// exit ;
115814: GO 115829
// DestroyUnit ( tmp [ 1 ] ) ;
115816: LD_VAR 0 1
115820: PUSH
115821: LD_INT 1
115823: ARRAY
115824: PPUSH
115825: CALL_OW 65
// end ;
115829: PPOPN 1
115831: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
115832: LD_EXP 161
115836: PUSH
115837: LD_EXP 199
115841: AND
115842: IFFALSE 115971
115844: GO 115846
115846: DISABLE
115847: LD_INT 0
115849: PPUSH
// begin uc_side := 0 ;
115850: LD_ADDR_OWVAR 20
115854: PUSH
115855: LD_INT 0
115857: ST_TO_ADDR
// uc_nation := nation_arabian ;
115858: LD_ADDR_OWVAR 21
115862: PUSH
115863: LD_INT 2
115865: ST_TO_ADDR
// hc_gallery :=  ;
115866: LD_ADDR_OWVAR 33
115870: PUSH
115871: LD_STRING 
115873: ST_TO_ADDR
// hc_name :=  ;
115874: LD_ADDR_OWVAR 26
115878: PUSH
115879: LD_STRING 
115881: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
115882: LD_INT 1
115884: PPUSH
115885: LD_INT 11
115887: PPUSH
115888: LD_INT 10
115890: PPUSH
115891: CALL_OW 380
// un := CreateHuman ;
115895: LD_ADDR_VAR 0 1
115899: PUSH
115900: CALL_OW 44
115904: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115905: LD_VAR 0 1
115909: PPUSH
115910: LD_INT 1
115912: PPUSH
115913: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115917: LD_INT 35
115919: PPUSH
115920: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115924: LD_VAR 0 1
115928: PPUSH
115929: LD_INT 22
115931: PUSH
115932: LD_OWVAR 2
115936: PUSH
115937: EMPTY
115938: LIST
115939: LIST
115940: PPUSH
115941: CALL_OW 69
115945: PPUSH
115946: LD_VAR 0 1
115950: PPUSH
115951: CALL_OW 74
115955: PPUSH
115956: CALL_OW 115
// until IsDead ( un ) ;
115960: LD_VAR 0 1
115964: PPUSH
115965: CALL_OW 301
115969: IFFALSE 115917
// end ;
115971: PPOPN 1
115973: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
115974: LD_EXP 161
115978: PUSH
115979: LD_EXP 201
115983: AND
115984: IFFALSE 115996
115986: GO 115988
115988: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
115989: LD_STRING earthquake(getX(game), 0, 32)
115991: PPUSH
115992: CALL_OW 559
115996: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
115997: LD_EXP 161
116001: PUSH
116002: LD_EXP 202
116006: AND
116007: IFFALSE 116098
116009: GO 116011
116011: DISABLE
116012: LD_INT 0
116014: PPUSH
// begin enable ;
116015: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
116016: LD_ADDR_VAR 0 1
116020: PUSH
116021: LD_INT 22
116023: PUSH
116024: LD_OWVAR 2
116028: PUSH
116029: EMPTY
116030: LIST
116031: LIST
116032: PUSH
116033: LD_INT 21
116035: PUSH
116036: LD_INT 2
116038: PUSH
116039: EMPTY
116040: LIST
116041: LIST
116042: PUSH
116043: LD_INT 33
116045: PUSH
116046: LD_INT 3
116048: PUSH
116049: EMPTY
116050: LIST
116051: LIST
116052: PUSH
116053: EMPTY
116054: LIST
116055: LIST
116056: LIST
116057: PPUSH
116058: CALL_OW 69
116062: ST_TO_ADDR
// if not tmp then
116063: LD_VAR 0 1
116067: NOT
116068: IFFALSE 116072
// exit ;
116070: GO 116098
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116072: LD_VAR 0 1
116076: PUSH
116077: LD_INT 1
116079: PPUSH
116080: LD_VAR 0 1
116084: PPUSH
116085: CALL_OW 12
116089: ARRAY
116090: PPUSH
116091: LD_INT 1
116093: PPUSH
116094: CALL_OW 234
// end ;
116098: PPOPN 1
116100: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
116101: LD_EXP 161
116105: PUSH
116106: LD_EXP 203
116110: AND
116111: IFFALSE 116252
116113: GO 116115
116115: DISABLE
116116: LD_INT 0
116118: PPUSH
116119: PPUSH
116120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116121: LD_ADDR_VAR 0 3
116125: PUSH
116126: LD_INT 22
116128: PUSH
116129: LD_OWVAR 2
116133: PUSH
116134: EMPTY
116135: LIST
116136: LIST
116137: PUSH
116138: LD_INT 25
116140: PUSH
116141: LD_INT 1
116143: PUSH
116144: EMPTY
116145: LIST
116146: LIST
116147: PUSH
116148: EMPTY
116149: LIST
116150: LIST
116151: PPUSH
116152: CALL_OW 69
116156: ST_TO_ADDR
// if not tmp then
116157: LD_VAR 0 3
116161: NOT
116162: IFFALSE 116166
// exit ;
116164: GO 116252
// un := tmp [ rand ( 1 , tmp ) ] ;
116166: LD_ADDR_VAR 0 2
116170: PUSH
116171: LD_VAR 0 3
116175: PUSH
116176: LD_INT 1
116178: PPUSH
116179: LD_VAR 0 3
116183: PPUSH
116184: CALL_OW 12
116188: ARRAY
116189: ST_TO_ADDR
// if Crawls ( un ) then
116190: LD_VAR 0 2
116194: PPUSH
116195: CALL_OW 318
116199: IFFALSE 116210
// ComWalk ( un ) ;
116201: LD_VAR 0 2
116205: PPUSH
116206: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
116210: LD_VAR 0 2
116214: PPUSH
116215: LD_INT 9
116217: PPUSH
116218: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
116222: LD_INT 28
116224: PPUSH
116225: LD_OWVAR 2
116229: PPUSH
116230: LD_INT 2
116232: PPUSH
116233: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
116237: LD_INT 29
116239: PPUSH
116240: LD_OWVAR 2
116244: PPUSH
116245: LD_INT 2
116247: PPUSH
116248: CALL_OW 322
// end ;
116252: PPOPN 3
116254: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
116255: LD_EXP 161
116259: PUSH
116260: LD_EXP 204
116264: AND
116265: IFFALSE 116376
116267: GO 116269
116269: DISABLE
116270: LD_INT 0
116272: PPUSH
116273: PPUSH
116274: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116275: LD_ADDR_VAR 0 3
116279: PUSH
116280: LD_INT 22
116282: PUSH
116283: LD_OWVAR 2
116287: PUSH
116288: EMPTY
116289: LIST
116290: LIST
116291: PUSH
116292: LD_INT 25
116294: PUSH
116295: LD_INT 1
116297: PUSH
116298: EMPTY
116299: LIST
116300: LIST
116301: PUSH
116302: EMPTY
116303: LIST
116304: LIST
116305: PPUSH
116306: CALL_OW 69
116310: ST_TO_ADDR
// if not tmp then
116311: LD_VAR 0 3
116315: NOT
116316: IFFALSE 116320
// exit ;
116318: GO 116376
// un := tmp [ rand ( 1 , tmp ) ] ;
116320: LD_ADDR_VAR 0 2
116324: PUSH
116325: LD_VAR 0 3
116329: PUSH
116330: LD_INT 1
116332: PPUSH
116333: LD_VAR 0 3
116337: PPUSH
116338: CALL_OW 12
116342: ARRAY
116343: ST_TO_ADDR
// if Crawls ( un ) then
116344: LD_VAR 0 2
116348: PPUSH
116349: CALL_OW 318
116353: IFFALSE 116364
// ComWalk ( un ) ;
116355: LD_VAR 0 2
116359: PPUSH
116360: CALL_OW 138
// SetClass ( un , class_mortar ) ;
116364: LD_VAR 0 2
116368: PPUSH
116369: LD_INT 8
116371: PPUSH
116372: CALL_OW 336
// end ;
116376: PPOPN 3
116378: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
116379: LD_EXP 161
116383: PUSH
116384: LD_EXP 205
116388: AND
116389: IFFALSE 116533
116391: GO 116393
116393: DISABLE
116394: LD_INT 0
116396: PPUSH
116397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
116398: LD_ADDR_VAR 0 2
116402: PUSH
116403: LD_INT 22
116405: PUSH
116406: LD_OWVAR 2
116410: PUSH
116411: EMPTY
116412: LIST
116413: LIST
116414: PUSH
116415: LD_INT 21
116417: PUSH
116418: LD_INT 2
116420: PUSH
116421: EMPTY
116422: LIST
116423: LIST
116424: PUSH
116425: LD_INT 2
116427: PUSH
116428: LD_INT 34
116430: PUSH
116431: LD_INT 12
116433: PUSH
116434: EMPTY
116435: LIST
116436: LIST
116437: PUSH
116438: LD_INT 34
116440: PUSH
116441: LD_INT 51
116443: PUSH
116444: EMPTY
116445: LIST
116446: LIST
116447: PUSH
116448: LD_INT 34
116450: PUSH
116451: LD_INT 32
116453: PUSH
116454: EMPTY
116455: LIST
116456: LIST
116457: PUSH
116458: EMPTY
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: PUSH
116464: EMPTY
116465: LIST
116466: LIST
116467: LIST
116468: PPUSH
116469: CALL_OW 69
116473: ST_TO_ADDR
// if not tmp then
116474: LD_VAR 0 2
116478: NOT
116479: IFFALSE 116483
// exit ;
116481: GO 116533
// for i in tmp do
116483: LD_ADDR_VAR 0 1
116487: PUSH
116488: LD_VAR 0 2
116492: PUSH
116493: FOR_IN
116494: IFFALSE 116531
// if GetCargo ( i , mat_artifact ) = 0 then
116496: LD_VAR 0 1
116500: PPUSH
116501: LD_INT 4
116503: PPUSH
116504: CALL_OW 289
116508: PUSH
116509: LD_INT 0
116511: EQUAL
116512: IFFALSE 116529
// SetCargo ( i , mat_siberit , 100 ) ;
116514: LD_VAR 0 1
116518: PPUSH
116519: LD_INT 3
116521: PPUSH
116522: LD_INT 100
116524: PPUSH
116525: CALL_OW 290
116529: GO 116493
116531: POP
116532: POP
// end ;
116533: PPOPN 2
116535: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
116536: LD_EXP 161
116540: PUSH
116541: LD_EXP 206
116545: AND
116546: IFFALSE 116729
116548: GO 116550
116550: DISABLE
116551: LD_INT 0
116553: PPUSH
116554: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
116555: LD_ADDR_VAR 0 2
116559: PUSH
116560: LD_INT 22
116562: PUSH
116563: LD_OWVAR 2
116567: PUSH
116568: EMPTY
116569: LIST
116570: LIST
116571: PPUSH
116572: CALL_OW 69
116576: ST_TO_ADDR
// if not tmp then
116577: LD_VAR 0 2
116581: NOT
116582: IFFALSE 116586
// exit ;
116584: GO 116729
// for i := 1 to 2 do
116586: LD_ADDR_VAR 0 1
116590: PUSH
116591: DOUBLE
116592: LD_INT 1
116594: DEC
116595: ST_TO_ADDR
116596: LD_INT 2
116598: PUSH
116599: FOR_TO
116600: IFFALSE 116727
// begin uc_side := your_side ;
116602: LD_ADDR_OWVAR 20
116606: PUSH
116607: LD_OWVAR 2
116611: ST_TO_ADDR
// uc_nation := nation_american ;
116612: LD_ADDR_OWVAR 21
116616: PUSH
116617: LD_INT 1
116619: ST_TO_ADDR
// vc_chassis := us_morphling ;
116620: LD_ADDR_OWVAR 37
116624: PUSH
116625: LD_INT 5
116627: ST_TO_ADDR
// vc_engine := engine_siberite ;
116628: LD_ADDR_OWVAR 39
116632: PUSH
116633: LD_INT 3
116635: ST_TO_ADDR
// vc_control := control_computer ;
116636: LD_ADDR_OWVAR 38
116640: PUSH
116641: LD_INT 3
116643: ST_TO_ADDR
// vc_weapon := us_double_laser ;
116644: LD_ADDR_OWVAR 40
116648: PUSH
116649: LD_INT 10
116651: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
116652: LD_VAR 0 2
116656: PUSH
116657: LD_INT 1
116659: ARRAY
116660: PPUSH
116661: CALL_OW 310
116665: NOT
116666: IFFALSE 116713
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
116668: CALL_OW 45
116672: PPUSH
116673: LD_VAR 0 2
116677: PUSH
116678: LD_INT 1
116680: ARRAY
116681: PPUSH
116682: CALL_OW 250
116686: PPUSH
116687: LD_VAR 0 2
116691: PUSH
116692: LD_INT 1
116694: ARRAY
116695: PPUSH
116696: CALL_OW 251
116700: PPUSH
116701: LD_INT 12
116703: PPUSH
116704: LD_INT 1
116706: PPUSH
116707: CALL_OW 50
116711: GO 116725
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
116713: CALL_OW 45
116717: PPUSH
116718: LD_INT 1
116720: PPUSH
116721: CALL_OW 51
// end ;
116725: GO 116599
116727: POP
116728: POP
// end ;
116729: PPOPN 2
116731: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
116732: LD_EXP 161
116736: PUSH
116737: LD_EXP 207
116741: AND
116742: IFFALSE 116964
116744: GO 116746
116746: DISABLE
116747: LD_INT 0
116749: PPUSH
116750: PPUSH
116751: PPUSH
116752: PPUSH
116753: PPUSH
116754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
116755: LD_ADDR_VAR 0 6
116759: PUSH
116760: LD_INT 22
116762: PUSH
116763: LD_OWVAR 2
116767: PUSH
116768: EMPTY
116769: LIST
116770: LIST
116771: PUSH
116772: LD_INT 21
116774: PUSH
116775: LD_INT 1
116777: PUSH
116778: EMPTY
116779: LIST
116780: LIST
116781: PUSH
116782: LD_INT 3
116784: PUSH
116785: LD_INT 23
116787: PUSH
116788: LD_INT 0
116790: PUSH
116791: EMPTY
116792: LIST
116793: LIST
116794: PUSH
116795: EMPTY
116796: LIST
116797: LIST
116798: PUSH
116799: EMPTY
116800: LIST
116801: LIST
116802: LIST
116803: PPUSH
116804: CALL_OW 69
116808: ST_TO_ADDR
// if not tmp then
116809: LD_VAR 0 6
116813: NOT
116814: IFFALSE 116818
// exit ;
116816: GO 116964
// s1 := rand ( 1 , 4 ) ;
116818: LD_ADDR_VAR 0 2
116822: PUSH
116823: LD_INT 1
116825: PPUSH
116826: LD_INT 4
116828: PPUSH
116829: CALL_OW 12
116833: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
116834: LD_ADDR_VAR 0 4
116838: PUSH
116839: LD_VAR 0 6
116843: PUSH
116844: LD_INT 1
116846: ARRAY
116847: PPUSH
116848: LD_VAR 0 2
116852: PPUSH
116853: CALL_OW 259
116857: ST_TO_ADDR
// if s1 = 1 then
116858: LD_VAR 0 2
116862: PUSH
116863: LD_INT 1
116865: EQUAL
116866: IFFALSE 116886
// s2 := rand ( 2 , 4 ) else
116868: LD_ADDR_VAR 0 3
116872: PUSH
116873: LD_INT 2
116875: PPUSH
116876: LD_INT 4
116878: PPUSH
116879: CALL_OW 12
116883: ST_TO_ADDR
116884: GO 116894
// s2 := 1 ;
116886: LD_ADDR_VAR 0 3
116890: PUSH
116891: LD_INT 1
116893: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
116894: LD_ADDR_VAR 0 5
116898: PUSH
116899: LD_VAR 0 6
116903: PUSH
116904: LD_INT 1
116906: ARRAY
116907: PPUSH
116908: LD_VAR 0 3
116912: PPUSH
116913: CALL_OW 259
116917: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
116918: LD_VAR 0 6
116922: PUSH
116923: LD_INT 1
116925: ARRAY
116926: PPUSH
116927: LD_VAR 0 2
116931: PPUSH
116932: LD_VAR 0 5
116936: PPUSH
116937: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
116941: LD_VAR 0 6
116945: PUSH
116946: LD_INT 1
116948: ARRAY
116949: PPUSH
116950: LD_VAR 0 3
116954: PPUSH
116955: LD_VAR 0 4
116959: PPUSH
116960: CALL_OW 237
// end ;
116964: PPOPN 6
116966: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
116967: LD_EXP 161
116971: PUSH
116972: LD_EXP 208
116976: AND
116977: IFFALSE 117056
116979: GO 116981
116981: DISABLE
116982: LD_INT 0
116984: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
116985: LD_ADDR_VAR 0 1
116989: PUSH
116990: LD_INT 22
116992: PUSH
116993: LD_OWVAR 2
116997: PUSH
116998: EMPTY
116999: LIST
117000: LIST
117001: PUSH
117002: LD_INT 30
117004: PUSH
117005: LD_INT 3
117007: PUSH
117008: EMPTY
117009: LIST
117010: LIST
117011: PUSH
117012: EMPTY
117013: LIST
117014: LIST
117015: PPUSH
117016: CALL_OW 69
117020: ST_TO_ADDR
// if not tmp then
117021: LD_VAR 0 1
117025: NOT
117026: IFFALSE 117030
// exit ;
117028: GO 117056
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117030: LD_VAR 0 1
117034: PUSH
117035: LD_INT 1
117037: PPUSH
117038: LD_VAR 0 1
117042: PPUSH
117043: CALL_OW 12
117047: ARRAY
117048: PPUSH
117049: LD_INT 1
117051: PPUSH
117052: CALL_OW 234
// end ;
117056: PPOPN 1
117058: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
117059: LD_EXP 161
117063: PUSH
117064: LD_EXP 209
117068: AND
117069: IFFALSE 117181
117071: GO 117073
117073: DISABLE
117074: LD_INT 0
117076: PPUSH
117077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
117078: LD_ADDR_VAR 0 2
117082: PUSH
117083: LD_INT 22
117085: PUSH
117086: LD_OWVAR 2
117090: PUSH
117091: EMPTY
117092: LIST
117093: LIST
117094: PUSH
117095: LD_INT 2
117097: PUSH
117098: LD_INT 30
117100: PUSH
117101: LD_INT 27
117103: PUSH
117104: EMPTY
117105: LIST
117106: LIST
117107: PUSH
117108: LD_INT 30
117110: PUSH
117111: LD_INT 26
117113: PUSH
117114: EMPTY
117115: LIST
117116: LIST
117117: PUSH
117118: LD_INT 30
117120: PUSH
117121: LD_INT 28
117123: PUSH
117124: EMPTY
117125: LIST
117126: LIST
117127: PUSH
117128: EMPTY
117129: LIST
117130: LIST
117131: LIST
117132: LIST
117133: PUSH
117134: EMPTY
117135: LIST
117136: LIST
117137: PPUSH
117138: CALL_OW 69
117142: ST_TO_ADDR
// if not tmp then
117143: LD_VAR 0 2
117147: NOT
117148: IFFALSE 117152
// exit ;
117150: GO 117181
// for i in tmp do
117152: LD_ADDR_VAR 0 1
117156: PUSH
117157: LD_VAR 0 2
117161: PUSH
117162: FOR_IN
117163: IFFALSE 117179
// SetLives ( i , 1 ) ;
117165: LD_VAR 0 1
117169: PPUSH
117170: LD_INT 1
117172: PPUSH
117173: CALL_OW 234
117177: GO 117162
117179: POP
117180: POP
// end ;
117181: PPOPN 2
117183: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
117184: LD_EXP 161
117188: PUSH
117189: LD_EXP 210
117193: AND
117194: IFFALSE 117481
117196: GO 117198
117198: DISABLE
117199: LD_INT 0
117201: PPUSH
117202: PPUSH
117203: PPUSH
// begin i := rand ( 1 , 7 ) ;
117204: LD_ADDR_VAR 0 1
117208: PUSH
117209: LD_INT 1
117211: PPUSH
117212: LD_INT 7
117214: PPUSH
117215: CALL_OW 12
117219: ST_TO_ADDR
// case i of 1 :
117220: LD_VAR 0 1
117224: PUSH
117225: LD_INT 1
117227: DOUBLE
117228: EQUAL
117229: IFTRUE 117233
117231: GO 117243
117233: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
117234: LD_STRING earthquake(getX(game), 0, 32)
117236: PPUSH
117237: CALL_OW 559
117241: GO 117481
117243: LD_INT 2
117245: DOUBLE
117246: EQUAL
117247: IFTRUE 117251
117249: GO 117265
117251: POP
// begin ToLua ( displayStucuk(); ) ;
117252: LD_STRING displayStucuk();
117254: PPUSH
117255: CALL_OW 559
// ResetFog ;
117259: CALL_OW 335
// end ; 3 :
117263: GO 117481
117265: LD_INT 3
117267: DOUBLE
117268: EQUAL
117269: IFTRUE 117273
117271: GO 117377
117273: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117274: LD_ADDR_VAR 0 2
117278: PUSH
117279: LD_INT 22
117281: PUSH
117282: LD_OWVAR 2
117286: PUSH
117287: EMPTY
117288: LIST
117289: LIST
117290: PUSH
117291: LD_INT 25
117293: PUSH
117294: LD_INT 1
117296: PUSH
117297: EMPTY
117298: LIST
117299: LIST
117300: PUSH
117301: EMPTY
117302: LIST
117303: LIST
117304: PPUSH
117305: CALL_OW 69
117309: ST_TO_ADDR
// if not tmp then
117310: LD_VAR 0 2
117314: NOT
117315: IFFALSE 117319
// exit ;
117317: GO 117481
// un := tmp [ rand ( 1 , tmp ) ] ;
117319: LD_ADDR_VAR 0 3
117323: PUSH
117324: LD_VAR 0 2
117328: PUSH
117329: LD_INT 1
117331: PPUSH
117332: LD_VAR 0 2
117336: PPUSH
117337: CALL_OW 12
117341: ARRAY
117342: ST_TO_ADDR
// if Crawls ( un ) then
117343: LD_VAR 0 3
117347: PPUSH
117348: CALL_OW 318
117352: IFFALSE 117363
// ComWalk ( un ) ;
117354: LD_VAR 0 3
117358: PPUSH
117359: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117363: LD_VAR 0 3
117367: PPUSH
117368: LD_INT 8
117370: PPUSH
117371: CALL_OW 336
// end ; 4 :
117375: GO 117481
117377: LD_INT 4
117379: DOUBLE
117380: EQUAL
117381: IFTRUE 117385
117383: GO 117459
117385: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
117386: LD_ADDR_VAR 0 2
117390: PUSH
117391: LD_INT 22
117393: PUSH
117394: LD_OWVAR 2
117398: PUSH
117399: EMPTY
117400: LIST
117401: LIST
117402: PUSH
117403: LD_INT 30
117405: PUSH
117406: LD_INT 29
117408: PUSH
117409: EMPTY
117410: LIST
117411: LIST
117412: PUSH
117413: EMPTY
117414: LIST
117415: LIST
117416: PPUSH
117417: CALL_OW 69
117421: ST_TO_ADDR
// if not tmp then
117422: LD_VAR 0 2
117426: NOT
117427: IFFALSE 117431
// exit ;
117429: GO 117481
// CenterNowOnUnits ( tmp [ 1 ] ) ;
117431: LD_VAR 0 2
117435: PUSH
117436: LD_INT 1
117438: ARRAY
117439: PPUSH
117440: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
117444: LD_VAR 0 2
117448: PUSH
117449: LD_INT 1
117451: ARRAY
117452: PPUSH
117453: CALL_OW 65
// end ; 5 .. 7 :
117457: GO 117481
117459: LD_INT 5
117461: DOUBLE
117462: GREATEREQUAL
117463: IFFALSE 117471
117465: LD_INT 7
117467: DOUBLE
117468: LESSEQUAL
117469: IFTRUE 117473
117471: GO 117480
117473: POP
// StreamSibBomb ; end ;
117474: CALL 113718 0 0
117478: GO 117481
117480: POP
// end ;
117481: PPOPN 3
117483: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
117484: LD_EXP 161
117488: PUSH
117489: LD_EXP 211
117493: AND
117494: IFFALSE 117650
117496: GO 117498
117498: DISABLE
117499: LD_INT 0
117501: PPUSH
117502: PPUSH
117503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
117504: LD_ADDR_VAR 0 2
117508: PUSH
117509: LD_INT 81
117511: PUSH
117512: LD_OWVAR 2
117516: PUSH
117517: EMPTY
117518: LIST
117519: LIST
117520: PUSH
117521: LD_INT 2
117523: PUSH
117524: LD_INT 21
117526: PUSH
117527: LD_INT 1
117529: PUSH
117530: EMPTY
117531: LIST
117532: LIST
117533: PUSH
117534: LD_INT 21
117536: PUSH
117537: LD_INT 2
117539: PUSH
117540: EMPTY
117541: LIST
117542: LIST
117543: PUSH
117544: EMPTY
117545: LIST
117546: LIST
117547: LIST
117548: PUSH
117549: EMPTY
117550: LIST
117551: LIST
117552: PPUSH
117553: CALL_OW 69
117557: ST_TO_ADDR
// if not tmp then
117558: LD_VAR 0 2
117562: NOT
117563: IFFALSE 117567
// exit ;
117565: GO 117650
// p := 0 ;
117567: LD_ADDR_VAR 0 3
117571: PUSH
117572: LD_INT 0
117574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
117575: LD_INT 35
117577: PPUSH
117578: CALL_OW 67
// p := p + 1 ;
117582: LD_ADDR_VAR 0 3
117586: PUSH
117587: LD_VAR 0 3
117591: PUSH
117592: LD_INT 1
117594: PLUS
117595: ST_TO_ADDR
// for i in tmp do
117596: LD_ADDR_VAR 0 1
117600: PUSH
117601: LD_VAR 0 2
117605: PUSH
117606: FOR_IN
117607: IFFALSE 117638
// if GetLives ( i ) < 1000 then
117609: LD_VAR 0 1
117613: PPUSH
117614: CALL_OW 256
117618: PUSH
117619: LD_INT 1000
117621: LESS
117622: IFFALSE 117636
// SetLives ( i , 1000 ) ;
117624: LD_VAR 0 1
117628: PPUSH
117629: LD_INT 1000
117631: PPUSH
117632: CALL_OW 234
117636: GO 117606
117638: POP
117639: POP
// until p > 20 ;
117640: LD_VAR 0 3
117644: PUSH
117645: LD_INT 20
117647: GREATER
117648: IFFALSE 117575
// end ;
117650: PPOPN 3
117652: END
// every 0 0$1 trigger StreamModeActive and sTime do
117653: LD_EXP 161
117657: PUSH
117658: LD_EXP 212
117662: AND
117663: IFFALSE 117698
117665: GO 117667
117667: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
117668: LD_INT 28
117670: PPUSH
117671: LD_OWVAR 2
117675: PPUSH
117676: LD_INT 2
117678: PPUSH
117679: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
117683: LD_INT 30
117685: PPUSH
117686: LD_OWVAR 2
117690: PPUSH
117691: LD_INT 2
117693: PPUSH
117694: CALL_OW 322
// end ;
117698: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
117699: LD_EXP 161
117703: PUSH
117704: LD_EXP 213
117708: AND
117709: IFFALSE 117830
117711: GO 117713
117713: DISABLE
117714: LD_INT 0
117716: PPUSH
117717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117718: LD_ADDR_VAR 0 2
117722: PUSH
117723: LD_INT 22
117725: PUSH
117726: LD_OWVAR 2
117730: PUSH
117731: EMPTY
117732: LIST
117733: LIST
117734: PUSH
117735: LD_INT 21
117737: PUSH
117738: LD_INT 1
117740: PUSH
117741: EMPTY
117742: LIST
117743: LIST
117744: PUSH
117745: LD_INT 3
117747: PUSH
117748: LD_INT 23
117750: PUSH
117751: LD_INT 0
117753: PUSH
117754: EMPTY
117755: LIST
117756: LIST
117757: PUSH
117758: EMPTY
117759: LIST
117760: LIST
117761: PUSH
117762: EMPTY
117763: LIST
117764: LIST
117765: LIST
117766: PPUSH
117767: CALL_OW 69
117771: ST_TO_ADDR
// if not tmp then
117772: LD_VAR 0 2
117776: NOT
117777: IFFALSE 117781
// exit ;
117779: GO 117830
// for i in tmp do
117781: LD_ADDR_VAR 0 1
117785: PUSH
117786: LD_VAR 0 2
117790: PUSH
117791: FOR_IN
117792: IFFALSE 117828
// begin if Crawls ( i ) then
117794: LD_VAR 0 1
117798: PPUSH
117799: CALL_OW 318
117803: IFFALSE 117814
// ComWalk ( i ) ;
117805: LD_VAR 0 1
117809: PPUSH
117810: CALL_OW 138
// SetClass ( i , 2 ) ;
117814: LD_VAR 0 1
117818: PPUSH
117819: LD_INT 2
117821: PPUSH
117822: CALL_OW 336
// end ;
117826: GO 117791
117828: POP
117829: POP
// end ;
117830: PPOPN 2
117832: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
117833: LD_EXP 161
117837: PUSH
117838: LD_EXP 214
117842: AND
117843: IFFALSE 118131
117845: GO 117847
117847: DISABLE
117848: LD_INT 0
117850: PPUSH
117851: PPUSH
117852: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
117853: LD_OWVAR 2
117857: PPUSH
117858: LD_INT 9
117860: PPUSH
117861: LD_INT 1
117863: PPUSH
117864: LD_INT 1
117866: PPUSH
117867: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
117871: LD_INT 9
117873: PPUSH
117874: LD_OWVAR 2
117878: PPUSH
117879: CALL_OW 343
// uc_side := 9 ;
117883: LD_ADDR_OWVAR 20
117887: PUSH
117888: LD_INT 9
117890: ST_TO_ADDR
// uc_nation := 2 ;
117891: LD_ADDR_OWVAR 21
117895: PUSH
117896: LD_INT 2
117898: ST_TO_ADDR
// hc_name := Dark Warrior ;
117899: LD_ADDR_OWVAR 26
117903: PUSH
117904: LD_STRING Dark Warrior
117906: ST_TO_ADDR
// hc_gallery :=  ;
117907: LD_ADDR_OWVAR 33
117911: PUSH
117912: LD_STRING 
117914: ST_TO_ADDR
// hc_noskilllimit := true ;
117915: LD_ADDR_OWVAR 76
117919: PUSH
117920: LD_INT 1
117922: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
117923: LD_ADDR_OWVAR 31
117927: PUSH
117928: LD_INT 30
117930: PUSH
117931: LD_INT 30
117933: PUSH
117934: LD_INT 30
117936: PUSH
117937: LD_INT 30
117939: PUSH
117940: EMPTY
117941: LIST
117942: LIST
117943: LIST
117944: LIST
117945: ST_TO_ADDR
// un := CreateHuman ;
117946: LD_ADDR_VAR 0 3
117950: PUSH
117951: CALL_OW 44
117955: ST_TO_ADDR
// hc_noskilllimit := false ;
117956: LD_ADDR_OWVAR 76
117960: PUSH
117961: LD_INT 0
117963: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117964: LD_VAR 0 3
117968: PPUSH
117969: LD_INT 1
117971: PPUSH
117972: CALL_OW 51
// ToLua ( playRanger() ) ;
117976: LD_STRING playRanger()
117978: PPUSH
117979: CALL_OW 559
// p := 0 ;
117983: LD_ADDR_VAR 0 2
117987: PUSH
117988: LD_INT 0
117990: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
117991: LD_INT 35
117993: PPUSH
117994: CALL_OW 67
// p := p + 1 ;
117998: LD_ADDR_VAR 0 2
118002: PUSH
118003: LD_VAR 0 2
118007: PUSH
118008: LD_INT 1
118010: PLUS
118011: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118012: LD_VAR 0 3
118016: PPUSH
118017: CALL_OW 256
118021: PUSH
118022: LD_INT 1000
118024: LESS
118025: IFFALSE 118039
// SetLives ( un , 1000 ) ;
118027: LD_VAR 0 3
118031: PPUSH
118032: LD_INT 1000
118034: PPUSH
118035: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
118039: LD_VAR 0 3
118043: PPUSH
118044: LD_INT 81
118046: PUSH
118047: LD_OWVAR 2
118051: PUSH
118052: EMPTY
118053: LIST
118054: LIST
118055: PUSH
118056: LD_INT 91
118058: PUSH
118059: LD_VAR 0 3
118063: PUSH
118064: LD_INT 30
118066: PUSH
118067: EMPTY
118068: LIST
118069: LIST
118070: LIST
118071: PUSH
118072: EMPTY
118073: LIST
118074: LIST
118075: PPUSH
118076: CALL_OW 69
118080: PPUSH
118081: LD_VAR 0 3
118085: PPUSH
118086: CALL_OW 74
118090: PPUSH
118091: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
118095: LD_VAR 0 2
118099: PUSH
118100: LD_INT 80
118102: GREATER
118103: PUSH
118104: LD_VAR 0 3
118108: PPUSH
118109: CALL_OW 301
118113: OR
118114: IFFALSE 117991
// if un then
118116: LD_VAR 0 3
118120: IFFALSE 118131
// RemoveUnit ( un ) ;
118122: LD_VAR 0 3
118126: PPUSH
118127: CALL_OW 64
// end ;
118131: PPOPN 3
118133: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
118134: LD_EXP 215
118138: IFFALSE 118254
118140: GO 118142
118142: DISABLE
118143: LD_INT 0
118145: PPUSH
118146: PPUSH
118147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118148: LD_ADDR_VAR 0 2
118152: PUSH
118153: LD_INT 81
118155: PUSH
118156: LD_OWVAR 2
118160: PUSH
118161: EMPTY
118162: LIST
118163: LIST
118164: PUSH
118165: LD_INT 21
118167: PUSH
118168: LD_INT 1
118170: PUSH
118171: EMPTY
118172: LIST
118173: LIST
118174: PUSH
118175: EMPTY
118176: LIST
118177: LIST
118178: PPUSH
118179: CALL_OW 69
118183: ST_TO_ADDR
// ToLua ( playComputer() ) ;
118184: LD_STRING playComputer()
118186: PPUSH
118187: CALL_OW 559
// if not tmp then
118191: LD_VAR 0 2
118195: NOT
118196: IFFALSE 118200
// exit ;
118198: GO 118254
// for i in tmp do
118200: LD_ADDR_VAR 0 1
118204: PUSH
118205: LD_VAR 0 2
118209: PUSH
118210: FOR_IN
118211: IFFALSE 118252
// for j := 1 to 4 do
118213: LD_ADDR_VAR 0 3
118217: PUSH
118218: DOUBLE
118219: LD_INT 1
118221: DEC
118222: ST_TO_ADDR
118223: LD_INT 4
118225: PUSH
118226: FOR_TO
118227: IFFALSE 118248
// SetSkill ( i , j , 10 ) ;
118229: LD_VAR 0 1
118233: PPUSH
118234: LD_VAR 0 3
118238: PPUSH
118239: LD_INT 10
118241: PPUSH
118242: CALL_OW 237
118246: GO 118226
118248: POP
118249: POP
118250: GO 118210
118252: POP
118253: POP
// end ;
118254: PPOPN 3
118256: END
// every 0 0$1 trigger s30 do var i , tmp ;
118257: LD_EXP 216
118261: IFFALSE 118330
118263: GO 118265
118265: DISABLE
118266: LD_INT 0
118268: PPUSH
118269: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
118270: LD_ADDR_VAR 0 2
118274: PUSH
118275: LD_INT 22
118277: PUSH
118278: LD_OWVAR 2
118282: PUSH
118283: EMPTY
118284: LIST
118285: LIST
118286: PPUSH
118287: CALL_OW 69
118291: ST_TO_ADDR
// if not tmp then
118292: LD_VAR 0 2
118296: NOT
118297: IFFALSE 118301
// exit ;
118299: GO 118330
// for i in tmp do
118301: LD_ADDR_VAR 0 1
118305: PUSH
118306: LD_VAR 0 2
118310: PUSH
118311: FOR_IN
118312: IFFALSE 118328
// SetLives ( i , 300 ) ;
118314: LD_VAR 0 1
118318: PPUSH
118319: LD_INT 300
118321: PPUSH
118322: CALL_OW 234
118326: GO 118311
118328: POP
118329: POP
// end ;
118330: PPOPN 2
118332: END
// every 0 0$1 trigger s60 do var i , tmp ;
118333: LD_EXP 217
118337: IFFALSE 118406
118339: GO 118341
118341: DISABLE
118342: LD_INT 0
118344: PPUSH
118345: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
118346: LD_ADDR_VAR 0 2
118350: PUSH
118351: LD_INT 22
118353: PUSH
118354: LD_OWVAR 2
118358: PUSH
118359: EMPTY
118360: LIST
118361: LIST
118362: PPUSH
118363: CALL_OW 69
118367: ST_TO_ADDR
// if not tmp then
118368: LD_VAR 0 2
118372: NOT
118373: IFFALSE 118377
// exit ;
118375: GO 118406
// for i in tmp do
118377: LD_ADDR_VAR 0 1
118381: PUSH
118382: LD_VAR 0 2
118386: PUSH
118387: FOR_IN
118388: IFFALSE 118404
// SetLives ( i , 600 ) ;
118390: LD_VAR 0 1
118394: PPUSH
118395: LD_INT 600
118397: PPUSH
118398: CALL_OW 234
118402: GO 118387
118404: POP
118405: POP
// end ;
118406: PPOPN 2
118408: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
118409: LD_INT 0
118411: PPUSH
// case cmd of 301 :
118412: LD_VAR 0 1
118416: PUSH
118417: LD_INT 301
118419: DOUBLE
118420: EQUAL
118421: IFTRUE 118425
118423: GO 118457
118425: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
118426: LD_VAR 0 6
118430: PPUSH
118431: LD_VAR 0 7
118435: PPUSH
118436: LD_VAR 0 8
118440: PPUSH
118441: LD_VAR 0 4
118445: PPUSH
118446: LD_VAR 0 5
118450: PPUSH
118451: CALL 119658 0 5
118455: GO 118578
118457: LD_INT 302
118459: DOUBLE
118460: EQUAL
118461: IFTRUE 118465
118463: GO 118502
118465: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
118466: LD_VAR 0 6
118470: PPUSH
118471: LD_VAR 0 7
118475: PPUSH
118476: LD_VAR 0 8
118480: PPUSH
118481: LD_VAR 0 9
118485: PPUSH
118486: LD_VAR 0 4
118490: PPUSH
118491: LD_VAR 0 5
118495: PPUSH
118496: CALL 119749 0 6
118500: GO 118578
118502: LD_INT 303
118504: DOUBLE
118505: EQUAL
118506: IFTRUE 118510
118508: GO 118547
118510: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
118511: LD_VAR 0 6
118515: PPUSH
118516: LD_VAR 0 7
118520: PPUSH
118521: LD_VAR 0 8
118525: PPUSH
118526: LD_VAR 0 9
118530: PPUSH
118531: LD_VAR 0 4
118535: PPUSH
118536: LD_VAR 0 5
118540: PPUSH
118541: CALL 118583 0 6
118545: GO 118578
118547: LD_INT 304
118549: DOUBLE
118550: EQUAL
118551: IFTRUE 118555
118553: GO 118577
118555: POP
// hHackTeleport ( unit , x , y ) ; end ;
118556: LD_VAR 0 2
118560: PPUSH
118561: LD_VAR 0 4
118565: PPUSH
118566: LD_VAR 0 5
118570: PPUSH
118571: CALL 120342 0 3
118575: GO 118578
118577: POP
// end ;
118578: LD_VAR 0 12
118582: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
118583: LD_INT 0
118585: PPUSH
118586: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
118587: LD_VAR 0 1
118591: PUSH
118592: LD_INT 1
118594: LESS
118595: PUSH
118596: LD_VAR 0 1
118600: PUSH
118601: LD_INT 3
118603: GREATER
118604: OR
118605: PUSH
118606: LD_VAR 0 5
118610: PPUSH
118611: LD_VAR 0 6
118615: PPUSH
118616: CALL_OW 428
118620: OR
118621: IFFALSE 118625
// exit ;
118623: GO 119345
// uc_side := your_side ;
118625: LD_ADDR_OWVAR 20
118629: PUSH
118630: LD_OWVAR 2
118634: ST_TO_ADDR
// uc_nation := nation ;
118635: LD_ADDR_OWVAR 21
118639: PUSH
118640: LD_VAR 0 1
118644: ST_TO_ADDR
// bc_level = 1 ;
118645: LD_ADDR_OWVAR 43
118649: PUSH
118650: LD_INT 1
118652: ST_TO_ADDR
// case btype of 1 :
118653: LD_VAR 0 2
118657: PUSH
118658: LD_INT 1
118660: DOUBLE
118661: EQUAL
118662: IFTRUE 118666
118664: GO 118677
118666: POP
// bc_type := b_depot ; 2 :
118667: LD_ADDR_OWVAR 42
118671: PUSH
118672: LD_INT 0
118674: ST_TO_ADDR
118675: GO 119289
118677: LD_INT 2
118679: DOUBLE
118680: EQUAL
118681: IFTRUE 118685
118683: GO 118696
118685: POP
// bc_type := b_warehouse ; 3 :
118686: LD_ADDR_OWVAR 42
118690: PUSH
118691: LD_INT 1
118693: ST_TO_ADDR
118694: GO 119289
118696: LD_INT 3
118698: DOUBLE
118699: EQUAL
118700: IFTRUE 118704
118702: GO 118715
118704: POP
// bc_type := b_lab ; 4 .. 9 :
118705: LD_ADDR_OWVAR 42
118709: PUSH
118710: LD_INT 6
118712: ST_TO_ADDR
118713: GO 119289
118715: LD_INT 4
118717: DOUBLE
118718: GREATEREQUAL
118719: IFFALSE 118727
118721: LD_INT 9
118723: DOUBLE
118724: LESSEQUAL
118725: IFTRUE 118729
118727: GO 118781
118729: POP
// begin bc_type := b_lab_half ;
118730: LD_ADDR_OWVAR 42
118734: PUSH
118735: LD_INT 7
118737: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
118738: LD_ADDR_OWVAR 44
118742: PUSH
118743: LD_INT 10
118745: PUSH
118746: LD_INT 11
118748: PUSH
118749: LD_INT 12
118751: PUSH
118752: LD_INT 15
118754: PUSH
118755: LD_INT 14
118757: PUSH
118758: LD_INT 13
118760: PUSH
118761: EMPTY
118762: LIST
118763: LIST
118764: LIST
118765: LIST
118766: LIST
118767: LIST
118768: PUSH
118769: LD_VAR 0 2
118773: PUSH
118774: LD_INT 3
118776: MINUS
118777: ARRAY
118778: ST_TO_ADDR
// end ; 10 .. 13 :
118779: GO 119289
118781: LD_INT 10
118783: DOUBLE
118784: GREATEREQUAL
118785: IFFALSE 118793
118787: LD_INT 13
118789: DOUBLE
118790: LESSEQUAL
118791: IFTRUE 118795
118793: GO 118872
118795: POP
// begin bc_type := b_lab_full ;
118796: LD_ADDR_OWVAR 42
118800: PUSH
118801: LD_INT 8
118803: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
118804: LD_ADDR_OWVAR 44
118808: PUSH
118809: LD_INT 10
118811: PUSH
118812: LD_INT 12
118814: PUSH
118815: LD_INT 14
118817: PUSH
118818: LD_INT 13
118820: PUSH
118821: EMPTY
118822: LIST
118823: LIST
118824: LIST
118825: LIST
118826: PUSH
118827: LD_VAR 0 2
118831: PUSH
118832: LD_INT 9
118834: MINUS
118835: ARRAY
118836: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
118837: LD_ADDR_OWVAR 45
118841: PUSH
118842: LD_INT 11
118844: PUSH
118845: LD_INT 15
118847: PUSH
118848: LD_INT 12
118850: PUSH
118851: LD_INT 15
118853: PUSH
118854: EMPTY
118855: LIST
118856: LIST
118857: LIST
118858: LIST
118859: PUSH
118860: LD_VAR 0 2
118864: PUSH
118865: LD_INT 9
118867: MINUS
118868: ARRAY
118869: ST_TO_ADDR
// end ; 14 :
118870: GO 119289
118872: LD_INT 14
118874: DOUBLE
118875: EQUAL
118876: IFTRUE 118880
118878: GO 118891
118880: POP
// bc_type := b_workshop ; 15 :
118881: LD_ADDR_OWVAR 42
118885: PUSH
118886: LD_INT 2
118888: ST_TO_ADDR
118889: GO 119289
118891: LD_INT 15
118893: DOUBLE
118894: EQUAL
118895: IFTRUE 118899
118897: GO 118910
118899: POP
// bc_type := b_factory ; 16 :
118900: LD_ADDR_OWVAR 42
118904: PUSH
118905: LD_INT 3
118907: ST_TO_ADDR
118908: GO 119289
118910: LD_INT 16
118912: DOUBLE
118913: EQUAL
118914: IFTRUE 118918
118916: GO 118929
118918: POP
// bc_type := b_ext_gun ; 17 :
118919: LD_ADDR_OWVAR 42
118923: PUSH
118924: LD_INT 17
118926: ST_TO_ADDR
118927: GO 119289
118929: LD_INT 17
118931: DOUBLE
118932: EQUAL
118933: IFTRUE 118937
118935: GO 118965
118937: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
118938: LD_ADDR_OWVAR 42
118942: PUSH
118943: LD_INT 19
118945: PUSH
118946: LD_INT 23
118948: PUSH
118949: LD_INT 19
118951: PUSH
118952: EMPTY
118953: LIST
118954: LIST
118955: LIST
118956: PUSH
118957: LD_VAR 0 1
118961: ARRAY
118962: ST_TO_ADDR
118963: GO 119289
118965: LD_INT 18
118967: DOUBLE
118968: EQUAL
118969: IFTRUE 118973
118971: GO 118984
118973: POP
// bc_type := b_ext_radar ; 19 :
118974: LD_ADDR_OWVAR 42
118978: PUSH
118979: LD_INT 20
118981: ST_TO_ADDR
118982: GO 119289
118984: LD_INT 19
118986: DOUBLE
118987: EQUAL
118988: IFTRUE 118992
118990: GO 119003
118992: POP
// bc_type := b_ext_radio ; 20 :
118993: LD_ADDR_OWVAR 42
118997: PUSH
118998: LD_INT 22
119000: ST_TO_ADDR
119001: GO 119289
119003: LD_INT 20
119005: DOUBLE
119006: EQUAL
119007: IFTRUE 119011
119009: GO 119022
119011: POP
// bc_type := b_ext_siberium ; 21 :
119012: LD_ADDR_OWVAR 42
119016: PUSH
119017: LD_INT 21
119019: ST_TO_ADDR
119020: GO 119289
119022: LD_INT 21
119024: DOUBLE
119025: EQUAL
119026: IFTRUE 119030
119028: GO 119041
119030: POP
// bc_type := b_ext_computer ; 22 :
119031: LD_ADDR_OWVAR 42
119035: PUSH
119036: LD_INT 24
119038: ST_TO_ADDR
119039: GO 119289
119041: LD_INT 22
119043: DOUBLE
119044: EQUAL
119045: IFTRUE 119049
119047: GO 119060
119049: POP
// bc_type := b_ext_track ; 23 :
119050: LD_ADDR_OWVAR 42
119054: PUSH
119055: LD_INT 16
119057: ST_TO_ADDR
119058: GO 119289
119060: LD_INT 23
119062: DOUBLE
119063: EQUAL
119064: IFTRUE 119068
119066: GO 119079
119068: POP
// bc_type := b_ext_laser ; 24 :
119069: LD_ADDR_OWVAR 42
119073: PUSH
119074: LD_INT 25
119076: ST_TO_ADDR
119077: GO 119289
119079: LD_INT 24
119081: DOUBLE
119082: EQUAL
119083: IFTRUE 119087
119085: GO 119098
119087: POP
// bc_type := b_control_tower ; 25 :
119088: LD_ADDR_OWVAR 42
119092: PUSH
119093: LD_INT 36
119095: ST_TO_ADDR
119096: GO 119289
119098: LD_INT 25
119100: DOUBLE
119101: EQUAL
119102: IFTRUE 119106
119104: GO 119117
119106: POP
// bc_type := b_breastwork ; 26 :
119107: LD_ADDR_OWVAR 42
119111: PUSH
119112: LD_INT 31
119114: ST_TO_ADDR
119115: GO 119289
119117: LD_INT 26
119119: DOUBLE
119120: EQUAL
119121: IFTRUE 119125
119123: GO 119136
119125: POP
// bc_type := b_bunker ; 27 :
119126: LD_ADDR_OWVAR 42
119130: PUSH
119131: LD_INT 32
119133: ST_TO_ADDR
119134: GO 119289
119136: LD_INT 27
119138: DOUBLE
119139: EQUAL
119140: IFTRUE 119144
119142: GO 119155
119144: POP
// bc_type := b_turret ; 28 :
119145: LD_ADDR_OWVAR 42
119149: PUSH
119150: LD_INT 33
119152: ST_TO_ADDR
119153: GO 119289
119155: LD_INT 28
119157: DOUBLE
119158: EQUAL
119159: IFTRUE 119163
119161: GO 119174
119163: POP
// bc_type := b_armoury ; 29 :
119164: LD_ADDR_OWVAR 42
119168: PUSH
119169: LD_INT 4
119171: ST_TO_ADDR
119172: GO 119289
119174: LD_INT 29
119176: DOUBLE
119177: EQUAL
119178: IFTRUE 119182
119180: GO 119193
119182: POP
// bc_type := b_barracks ; 30 :
119183: LD_ADDR_OWVAR 42
119187: PUSH
119188: LD_INT 5
119190: ST_TO_ADDR
119191: GO 119289
119193: LD_INT 30
119195: DOUBLE
119196: EQUAL
119197: IFTRUE 119201
119199: GO 119212
119201: POP
// bc_type := b_solar_power ; 31 :
119202: LD_ADDR_OWVAR 42
119206: PUSH
119207: LD_INT 27
119209: ST_TO_ADDR
119210: GO 119289
119212: LD_INT 31
119214: DOUBLE
119215: EQUAL
119216: IFTRUE 119220
119218: GO 119231
119220: POP
// bc_type := b_oil_power ; 32 :
119221: LD_ADDR_OWVAR 42
119225: PUSH
119226: LD_INT 26
119228: ST_TO_ADDR
119229: GO 119289
119231: LD_INT 32
119233: DOUBLE
119234: EQUAL
119235: IFTRUE 119239
119237: GO 119250
119239: POP
// bc_type := b_siberite_power ; 33 :
119240: LD_ADDR_OWVAR 42
119244: PUSH
119245: LD_INT 28
119247: ST_TO_ADDR
119248: GO 119289
119250: LD_INT 33
119252: DOUBLE
119253: EQUAL
119254: IFTRUE 119258
119256: GO 119269
119258: POP
// bc_type := b_oil_mine ; 34 :
119259: LD_ADDR_OWVAR 42
119263: PUSH
119264: LD_INT 29
119266: ST_TO_ADDR
119267: GO 119289
119269: LD_INT 34
119271: DOUBLE
119272: EQUAL
119273: IFTRUE 119277
119275: GO 119288
119277: POP
// bc_type := b_siberite_mine ; end ;
119278: LD_ADDR_OWVAR 42
119282: PUSH
119283: LD_INT 30
119285: ST_TO_ADDR
119286: GO 119289
119288: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
119289: LD_ADDR_VAR 0 8
119293: PUSH
119294: LD_VAR 0 5
119298: PPUSH
119299: LD_VAR 0 6
119303: PPUSH
119304: LD_VAR 0 3
119308: PPUSH
119309: CALL_OW 47
119313: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
119314: LD_OWVAR 42
119318: PUSH
119319: LD_INT 32
119321: PUSH
119322: LD_INT 33
119324: PUSH
119325: EMPTY
119326: LIST
119327: LIST
119328: IN
119329: IFFALSE 119345
// PlaceWeaponTurret ( b , weapon ) ;
119331: LD_VAR 0 8
119335: PPUSH
119336: LD_VAR 0 4
119340: PPUSH
119341: CALL_OW 431
// end ;
119345: LD_VAR 0 7
119349: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
119350: LD_INT 0
119352: PPUSH
119353: PPUSH
119354: PPUSH
119355: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
119356: LD_ADDR_VAR 0 4
119360: PUSH
119361: LD_INT 22
119363: PUSH
119364: LD_OWVAR 2
119368: PUSH
119369: EMPTY
119370: LIST
119371: LIST
119372: PUSH
119373: LD_INT 2
119375: PUSH
119376: LD_INT 30
119378: PUSH
119379: LD_INT 0
119381: PUSH
119382: EMPTY
119383: LIST
119384: LIST
119385: PUSH
119386: LD_INT 30
119388: PUSH
119389: LD_INT 1
119391: PUSH
119392: EMPTY
119393: LIST
119394: LIST
119395: PUSH
119396: EMPTY
119397: LIST
119398: LIST
119399: LIST
119400: PUSH
119401: EMPTY
119402: LIST
119403: LIST
119404: PPUSH
119405: CALL_OW 69
119409: ST_TO_ADDR
// if not tmp then
119410: LD_VAR 0 4
119414: NOT
119415: IFFALSE 119419
// exit ;
119417: GO 119478
// for i in tmp do
119419: LD_ADDR_VAR 0 2
119423: PUSH
119424: LD_VAR 0 4
119428: PUSH
119429: FOR_IN
119430: IFFALSE 119476
// for j = 1 to 3 do
119432: LD_ADDR_VAR 0 3
119436: PUSH
119437: DOUBLE
119438: LD_INT 1
119440: DEC
119441: ST_TO_ADDR
119442: LD_INT 3
119444: PUSH
119445: FOR_TO
119446: IFFALSE 119472
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
119448: LD_VAR 0 2
119452: PPUSH
119453: CALL_OW 274
119457: PPUSH
119458: LD_VAR 0 3
119462: PPUSH
119463: LD_INT 99999
119465: PPUSH
119466: CALL_OW 277
119470: GO 119445
119472: POP
119473: POP
119474: GO 119429
119476: POP
119477: POP
// end ;
119478: LD_VAR 0 1
119482: RET
// export function hHackSetLevel10 ; var i , j ; begin
119483: LD_INT 0
119485: PPUSH
119486: PPUSH
119487: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
119488: LD_ADDR_VAR 0 2
119492: PUSH
119493: LD_INT 21
119495: PUSH
119496: LD_INT 1
119498: PUSH
119499: EMPTY
119500: LIST
119501: LIST
119502: PPUSH
119503: CALL_OW 69
119507: PUSH
119508: FOR_IN
119509: IFFALSE 119561
// if IsSelected ( i ) then
119511: LD_VAR 0 2
119515: PPUSH
119516: CALL_OW 306
119520: IFFALSE 119559
// begin for j := 1 to 4 do
119522: LD_ADDR_VAR 0 3
119526: PUSH
119527: DOUBLE
119528: LD_INT 1
119530: DEC
119531: ST_TO_ADDR
119532: LD_INT 4
119534: PUSH
119535: FOR_TO
119536: IFFALSE 119557
// SetSkill ( i , j , 10 ) ;
119538: LD_VAR 0 2
119542: PPUSH
119543: LD_VAR 0 3
119547: PPUSH
119548: LD_INT 10
119550: PPUSH
119551: CALL_OW 237
119555: GO 119535
119557: POP
119558: POP
// end ;
119559: GO 119508
119561: POP
119562: POP
// end ;
119563: LD_VAR 0 1
119567: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
119568: LD_INT 0
119570: PPUSH
119571: PPUSH
119572: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
119573: LD_ADDR_VAR 0 2
119577: PUSH
119578: LD_INT 22
119580: PUSH
119581: LD_OWVAR 2
119585: PUSH
119586: EMPTY
119587: LIST
119588: LIST
119589: PUSH
119590: LD_INT 21
119592: PUSH
119593: LD_INT 1
119595: PUSH
119596: EMPTY
119597: LIST
119598: LIST
119599: PUSH
119600: EMPTY
119601: LIST
119602: LIST
119603: PPUSH
119604: CALL_OW 69
119608: PUSH
119609: FOR_IN
119610: IFFALSE 119651
// begin for j := 1 to 4 do
119612: LD_ADDR_VAR 0 3
119616: PUSH
119617: DOUBLE
119618: LD_INT 1
119620: DEC
119621: ST_TO_ADDR
119622: LD_INT 4
119624: PUSH
119625: FOR_TO
119626: IFFALSE 119647
// SetSkill ( i , j , 10 ) ;
119628: LD_VAR 0 2
119632: PPUSH
119633: LD_VAR 0 3
119637: PPUSH
119638: LD_INT 10
119640: PPUSH
119641: CALL_OW 237
119645: GO 119625
119647: POP
119648: POP
// end ;
119649: GO 119609
119651: POP
119652: POP
// end ;
119653: LD_VAR 0 1
119657: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
119658: LD_INT 0
119660: PPUSH
// uc_side := your_side ;
119661: LD_ADDR_OWVAR 20
119665: PUSH
119666: LD_OWVAR 2
119670: ST_TO_ADDR
// uc_nation := nation ;
119671: LD_ADDR_OWVAR 21
119675: PUSH
119676: LD_VAR 0 1
119680: ST_TO_ADDR
// InitHc ;
119681: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
119685: LD_INT 0
119687: PPUSH
119688: LD_VAR 0 2
119692: PPUSH
119693: LD_VAR 0 3
119697: PPUSH
119698: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
119702: LD_VAR 0 4
119706: PPUSH
119707: LD_VAR 0 5
119711: PPUSH
119712: CALL_OW 428
119716: PUSH
119717: LD_INT 0
119719: EQUAL
119720: IFFALSE 119744
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
119722: CALL_OW 44
119726: PPUSH
119727: LD_VAR 0 4
119731: PPUSH
119732: LD_VAR 0 5
119736: PPUSH
119737: LD_INT 1
119739: PPUSH
119740: CALL_OW 48
// end ;
119744: LD_VAR 0 6
119748: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
119749: LD_INT 0
119751: PPUSH
119752: PPUSH
// uc_side := your_side ;
119753: LD_ADDR_OWVAR 20
119757: PUSH
119758: LD_OWVAR 2
119762: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
119763: LD_VAR 0 1
119767: PUSH
119768: LD_INT 1
119770: PUSH
119771: LD_INT 2
119773: PUSH
119774: LD_INT 3
119776: PUSH
119777: LD_INT 4
119779: PUSH
119780: LD_INT 5
119782: PUSH
119783: EMPTY
119784: LIST
119785: LIST
119786: LIST
119787: LIST
119788: LIST
119789: IN
119790: IFFALSE 119802
// uc_nation := nation_american else
119792: LD_ADDR_OWVAR 21
119796: PUSH
119797: LD_INT 1
119799: ST_TO_ADDR
119800: GO 119845
// if chassis in [ 11 , 12 , 13 , 14 ] then
119802: LD_VAR 0 1
119806: PUSH
119807: LD_INT 11
119809: PUSH
119810: LD_INT 12
119812: PUSH
119813: LD_INT 13
119815: PUSH
119816: LD_INT 14
119818: PUSH
119819: EMPTY
119820: LIST
119821: LIST
119822: LIST
119823: LIST
119824: IN
119825: IFFALSE 119837
// uc_nation := nation_arabian else
119827: LD_ADDR_OWVAR 21
119831: PUSH
119832: LD_INT 2
119834: ST_TO_ADDR
119835: GO 119845
// uc_nation := nation_russian ;
119837: LD_ADDR_OWVAR 21
119841: PUSH
119842: LD_INT 3
119844: ST_TO_ADDR
// vc_chassis := chassis ;
119845: LD_ADDR_OWVAR 37
119849: PUSH
119850: LD_VAR 0 1
119854: ST_TO_ADDR
// vc_engine := engine ;
119855: LD_ADDR_OWVAR 39
119859: PUSH
119860: LD_VAR 0 2
119864: ST_TO_ADDR
// vc_control := control ;
119865: LD_ADDR_OWVAR 38
119869: PUSH
119870: LD_VAR 0 3
119874: ST_TO_ADDR
// vc_weapon := weapon ;
119875: LD_ADDR_OWVAR 40
119879: PUSH
119880: LD_VAR 0 4
119884: ST_TO_ADDR
// un := CreateVehicle ;
119885: LD_ADDR_VAR 0 8
119889: PUSH
119890: CALL_OW 45
119894: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
119895: LD_VAR 0 8
119899: PPUSH
119900: LD_INT 0
119902: PPUSH
119903: LD_INT 5
119905: PPUSH
119906: CALL_OW 12
119910: PPUSH
119911: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
119915: LD_VAR 0 8
119919: PPUSH
119920: LD_VAR 0 5
119924: PPUSH
119925: LD_VAR 0 6
119929: PPUSH
119930: LD_INT 1
119932: PPUSH
119933: CALL_OW 48
// end ;
119937: LD_VAR 0 7
119941: RET
// export hInvincible ; every 1 do
119942: GO 119944
119944: DISABLE
// hInvincible := [ ] ;
119945: LD_ADDR_EXP 218
119949: PUSH
119950: EMPTY
119951: ST_TO_ADDR
119952: END
// every 10 do var i ;
119953: GO 119955
119955: DISABLE
119956: LD_INT 0
119958: PPUSH
// begin enable ;
119959: ENABLE
// if not hInvincible then
119960: LD_EXP 218
119964: NOT
119965: IFFALSE 119969
// exit ;
119967: GO 120013
// for i in hInvincible do
119969: LD_ADDR_VAR 0 1
119973: PUSH
119974: LD_EXP 218
119978: PUSH
119979: FOR_IN
119980: IFFALSE 120011
// if GetLives ( i ) < 1000 then
119982: LD_VAR 0 1
119986: PPUSH
119987: CALL_OW 256
119991: PUSH
119992: LD_INT 1000
119994: LESS
119995: IFFALSE 120009
// SetLives ( i , 1000 ) ;
119997: LD_VAR 0 1
120001: PPUSH
120002: LD_INT 1000
120004: PPUSH
120005: CALL_OW 234
120009: GO 119979
120011: POP
120012: POP
// end ;
120013: PPOPN 1
120015: END
// export function hHackInvincible ; var i ; begin
120016: LD_INT 0
120018: PPUSH
120019: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
120020: LD_ADDR_VAR 0 2
120024: PUSH
120025: LD_INT 2
120027: PUSH
120028: LD_INT 21
120030: PUSH
120031: LD_INT 1
120033: PUSH
120034: EMPTY
120035: LIST
120036: LIST
120037: PUSH
120038: LD_INT 21
120040: PUSH
120041: LD_INT 2
120043: PUSH
120044: EMPTY
120045: LIST
120046: LIST
120047: PUSH
120048: EMPTY
120049: LIST
120050: LIST
120051: LIST
120052: PPUSH
120053: CALL_OW 69
120057: PUSH
120058: FOR_IN
120059: IFFALSE 120120
// if IsSelected ( i ) then
120061: LD_VAR 0 2
120065: PPUSH
120066: CALL_OW 306
120070: IFFALSE 120118
// begin if i in hInvincible then
120072: LD_VAR 0 2
120076: PUSH
120077: LD_EXP 218
120081: IN
120082: IFFALSE 120102
// hInvincible := hInvincible diff i else
120084: LD_ADDR_EXP 218
120088: PUSH
120089: LD_EXP 218
120093: PUSH
120094: LD_VAR 0 2
120098: DIFF
120099: ST_TO_ADDR
120100: GO 120118
// hInvincible := hInvincible union i ;
120102: LD_ADDR_EXP 218
120106: PUSH
120107: LD_EXP 218
120111: PUSH
120112: LD_VAR 0 2
120116: UNION
120117: ST_TO_ADDR
// end ;
120118: GO 120058
120120: POP
120121: POP
// end ;
120122: LD_VAR 0 1
120126: RET
// export function hHackInvisible ; var i , j ; begin
120127: LD_INT 0
120129: PPUSH
120130: PPUSH
120131: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
120132: LD_ADDR_VAR 0 2
120136: PUSH
120137: LD_INT 21
120139: PUSH
120140: LD_INT 1
120142: PUSH
120143: EMPTY
120144: LIST
120145: LIST
120146: PPUSH
120147: CALL_OW 69
120151: PUSH
120152: FOR_IN
120153: IFFALSE 120177
// if IsSelected ( i ) then
120155: LD_VAR 0 2
120159: PPUSH
120160: CALL_OW 306
120164: IFFALSE 120175
// ComForceInvisible ( i ) ;
120166: LD_VAR 0 2
120170: PPUSH
120171: CALL_OW 496
120175: GO 120152
120177: POP
120178: POP
// end ;
120179: LD_VAR 0 1
120183: RET
// export function hHackChangeYourSide ; begin
120184: LD_INT 0
120186: PPUSH
// if your_side = 8 then
120187: LD_OWVAR 2
120191: PUSH
120192: LD_INT 8
120194: EQUAL
120195: IFFALSE 120207
// your_side := 0 else
120197: LD_ADDR_OWVAR 2
120201: PUSH
120202: LD_INT 0
120204: ST_TO_ADDR
120205: GO 120221
// your_side := your_side + 1 ;
120207: LD_ADDR_OWVAR 2
120211: PUSH
120212: LD_OWVAR 2
120216: PUSH
120217: LD_INT 1
120219: PLUS
120220: ST_TO_ADDR
// end ;
120221: LD_VAR 0 1
120225: RET
// export function hHackChangeUnitSide ; var i , j ; begin
120226: LD_INT 0
120228: PPUSH
120229: PPUSH
120230: PPUSH
// for i in all_units do
120231: LD_ADDR_VAR 0 2
120235: PUSH
120236: LD_OWVAR 3
120240: PUSH
120241: FOR_IN
120242: IFFALSE 120320
// if IsSelected ( i ) then
120244: LD_VAR 0 2
120248: PPUSH
120249: CALL_OW 306
120253: IFFALSE 120318
// begin j := GetSide ( i ) ;
120255: LD_ADDR_VAR 0 3
120259: PUSH
120260: LD_VAR 0 2
120264: PPUSH
120265: CALL_OW 255
120269: ST_TO_ADDR
// if j = 8 then
120270: LD_VAR 0 3
120274: PUSH
120275: LD_INT 8
120277: EQUAL
120278: IFFALSE 120290
// j := 0 else
120280: LD_ADDR_VAR 0 3
120284: PUSH
120285: LD_INT 0
120287: ST_TO_ADDR
120288: GO 120304
// j := j + 1 ;
120290: LD_ADDR_VAR 0 3
120294: PUSH
120295: LD_VAR 0 3
120299: PUSH
120300: LD_INT 1
120302: PLUS
120303: ST_TO_ADDR
// SetSide ( i , j ) ;
120304: LD_VAR 0 2
120308: PPUSH
120309: LD_VAR 0 3
120313: PPUSH
120314: CALL_OW 235
// end ;
120318: GO 120241
120320: POP
120321: POP
// end ;
120322: LD_VAR 0 1
120326: RET
// export function hHackFog ; begin
120327: LD_INT 0
120329: PPUSH
// FogOff ( true ) ;
120330: LD_INT 1
120332: PPUSH
120333: CALL_OW 344
// end ;
120337: LD_VAR 0 1
120341: RET
// export function hHackTeleport ( unit , x , y ) ; begin
120342: LD_INT 0
120344: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
120345: LD_VAR 0 1
120349: PPUSH
120350: LD_VAR 0 2
120354: PPUSH
120355: LD_VAR 0 3
120359: PPUSH
120360: LD_INT 1
120362: PPUSH
120363: LD_INT 1
120365: PPUSH
120366: CALL_OW 483
// CenterOnXY ( x , y ) ;
120370: LD_VAR 0 2
120374: PPUSH
120375: LD_VAR 0 3
120379: PPUSH
120380: CALL_OW 84
// end ; end_of_file
120384: LD_VAR 0 4
120388: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
120389: LD_INT 0
120391: PPUSH
120392: PPUSH
120393: PPUSH
120394: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
120395: LD_VAR 0 1
120399: PPUSH
120400: CALL_OW 264
120404: PUSH
120405: LD_EXP 99
120409: EQUAL
120410: IFFALSE 120482
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
120412: LD_INT 68
120414: PPUSH
120415: LD_VAR 0 1
120419: PPUSH
120420: CALL_OW 255
120424: PPUSH
120425: CALL_OW 321
120429: PUSH
120430: LD_INT 2
120432: EQUAL
120433: IFFALSE 120445
// eff := 70 else
120435: LD_ADDR_VAR 0 4
120439: PUSH
120440: LD_INT 70
120442: ST_TO_ADDR
120443: GO 120453
// eff := 30 ;
120445: LD_ADDR_VAR 0 4
120449: PUSH
120450: LD_INT 30
120452: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
120453: LD_VAR 0 1
120457: PPUSH
120458: CALL_OW 250
120462: PPUSH
120463: LD_VAR 0 1
120467: PPUSH
120468: CALL_OW 251
120472: PPUSH
120473: LD_VAR 0 4
120477: PPUSH
120478: CALL_OW 495
// end ; end ;
120482: LD_VAR 0 2
120486: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
120487: LD_INT 0
120489: PPUSH
// end ;
120490: LD_VAR 0 4
120494: RET
// export function SOS_Command ( cmd ) ; begin
120495: LD_INT 0
120497: PPUSH
// end ;
120498: LD_VAR 0 2
120502: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
120503: LD_INT 0
120505: PPUSH
// end ;
120506: LD_VAR 0 6
120510: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
120511: LD_INT 0
120513: PPUSH
120514: PPUSH
// if not vehicle or not factory then
120515: LD_VAR 0 1
120519: NOT
120520: PUSH
120521: LD_VAR 0 2
120525: NOT
120526: OR
120527: IFFALSE 120531
// exit ;
120529: GO 120762
// if factoryWaypoints >= factory then
120531: LD_EXP 219
120535: PUSH
120536: LD_VAR 0 2
120540: GREATEREQUAL
120541: IFFALSE 120762
// if factoryWaypoints [ factory ] then
120543: LD_EXP 219
120547: PUSH
120548: LD_VAR 0 2
120552: ARRAY
120553: IFFALSE 120762
// begin if GetControl ( vehicle ) = control_manual then
120555: LD_VAR 0 1
120559: PPUSH
120560: CALL_OW 263
120564: PUSH
120565: LD_INT 1
120567: EQUAL
120568: IFFALSE 120649
// begin driver := IsDrivenBy ( vehicle ) ;
120570: LD_ADDR_VAR 0 4
120574: PUSH
120575: LD_VAR 0 1
120579: PPUSH
120580: CALL_OW 311
120584: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
120585: LD_VAR 0 4
120589: PPUSH
120590: LD_EXP 219
120594: PUSH
120595: LD_VAR 0 2
120599: ARRAY
120600: PUSH
120601: LD_INT 3
120603: ARRAY
120604: PPUSH
120605: LD_EXP 219
120609: PUSH
120610: LD_VAR 0 2
120614: ARRAY
120615: PUSH
120616: LD_INT 4
120618: ARRAY
120619: PPUSH
120620: CALL_OW 171
// AddComExitVehicle ( driver ) ;
120624: LD_VAR 0 4
120628: PPUSH
120629: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
120633: LD_VAR 0 4
120637: PPUSH
120638: LD_VAR 0 2
120642: PPUSH
120643: CALL_OW 180
// end else
120647: GO 120762
// if GetControl ( vehicle ) = control_remote then
120649: LD_VAR 0 1
120653: PPUSH
120654: CALL_OW 263
120658: PUSH
120659: LD_INT 2
120661: EQUAL
120662: IFFALSE 120723
// begin wait ( 0 0$2 ) ;
120664: LD_INT 70
120666: PPUSH
120667: CALL_OW 67
// if Connect ( vehicle ) then
120671: LD_VAR 0 1
120675: PPUSH
120676: CALL 73873 0 1
120680: IFFALSE 120721
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
120682: LD_VAR 0 1
120686: PPUSH
120687: LD_EXP 219
120691: PUSH
120692: LD_VAR 0 2
120696: ARRAY
120697: PUSH
120698: LD_INT 3
120700: ARRAY
120701: PPUSH
120702: LD_EXP 219
120706: PUSH
120707: LD_VAR 0 2
120711: ARRAY
120712: PUSH
120713: LD_INT 4
120715: ARRAY
120716: PPUSH
120717: CALL_OW 171
// end else
120721: GO 120762
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
120723: LD_VAR 0 1
120727: PPUSH
120728: LD_EXP 219
120732: PUSH
120733: LD_VAR 0 2
120737: ARRAY
120738: PUSH
120739: LD_INT 3
120741: ARRAY
120742: PPUSH
120743: LD_EXP 219
120747: PUSH
120748: LD_VAR 0 2
120752: ARRAY
120753: PUSH
120754: LD_INT 4
120756: ARRAY
120757: PPUSH
120758: CALL_OW 171
// end ; end ;
120762: LD_VAR 0 3
120766: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
120767: LD_INT 0
120769: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
120770: LD_VAR 0 1
120774: PUSH
120775: LD_INT 250
120777: EQUAL
120778: PUSH
120779: LD_VAR 0 2
120783: PPUSH
120784: CALL_OW 264
120788: PUSH
120789: LD_EXP 102
120793: EQUAL
120794: AND
120795: IFFALSE 120816
// MinerPlaceMine ( unit , x , y ) ;
120797: LD_VAR 0 2
120801: PPUSH
120802: LD_VAR 0 4
120806: PPUSH
120807: LD_VAR 0 5
120811: PPUSH
120812: CALL 123544 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
120816: LD_VAR 0 1
120820: PUSH
120821: LD_INT 251
120823: EQUAL
120824: PUSH
120825: LD_VAR 0 2
120829: PPUSH
120830: CALL_OW 264
120834: PUSH
120835: LD_EXP 102
120839: EQUAL
120840: AND
120841: IFFALSE 120862
// MinerDetonateMine ( unit , x , y ) ;
120843: LD_VAR 0 2
120847: PPUSH
120848: LD_VAR 0 4
120852: PPUSH
120853: LD_VAR 0 5
120857: PPUSH
120858: CALL 123821 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
120862: LD_VAR 0 1
120866: PUSH
120867: LD_INT 252
120869: EQUAL
120870: PUSH
120871: LD_VAR 0 2
120875: PPUSH
120876: CALL_OW 264
120880: PUSH
120881: LD_EXP 102
120885: EQUAL
120886: AND
120887: IFFALSE 120908
// MinerCreateMinefield ( unit , x , y ) ;
120889: LD_VAR 0 2
120893: PPUSH
120894: LD_VAR 0 4
120898: PPUSH
120899: LD_VAR 0 5
120903: PPUSH
120904: CALL 124238 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
120908: LD_VAR 0 1
120912: PUSH
120913: LD_INT 253
120915: EQUAL
120916: PUSH
120917: LD_VAR 0 2
120921: PPUSH
120922: CALL_OW 257
120926: PUSH
120927: LD_INT 5
120929: EQUAL
120930: AND
120931: IFFALSE 120952
// ComBinocular ( unit , x , y ) ;
120933: LD_VAR 0 2
120937: PPUSH
120938: LD_VAR 0 4
120942: PPUSH
120943: LD_VAR 0 5
120947: PPUSH
120948: CALL 124609 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
120952: LD_VAR 0 1
120956: PUSH
120957: LD_INT 254
120959: EQUAL
120960: PUSH
120961: LD_VAR 0 2
120965: PPUSH
120966: CALL_OW 264
120970: PUSH
120971: LD_EXP 97
120975: EQUAL
120976: AND
120977: PUSH
120978: LD_VAR 0 3
120982: PPUSH
120983: CALL_OW 263
120987: PUSH
120988: LD_INT 3
120990: EQUAL
120991: AND
120992: IFFALSE 121008
// HackDestroyVehicle ( unit , selectedUnit ) ;
120994: LD_VAR 0 2
120998: PPUSH
120999: LD_VAR 0 3
121003: PPUSH
121004: CALL 122904 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
121008: LD_VAR 0 1
121012: PUSH
121013: LD_INT 255
121015: EQUAL
121016: PUSH
121017: LD_VAR 0 2
121021: PPUSH
121022: CALL_OW 264
121026: PUSH
121027: LD_INT 14
121029: PUSH
121030: LD_INT 53
121032: PUSH
121033: EMPTY
121034: LIST
121035: LIST
121036: IN
121037: AND
121038: PUSH
121039: LD_VAR 0 4
121043: PPUSH
121044: LD_VAR 0 5
121048: PPUSH
121049: CALL_OW 488
121053: AND
121054: IFFALSE 121078
// CutTreeXYR ( unit , x , y , 12 ) ;
121056: LD_VAR 0 2
121060: PPUSH
121061: LD_VAR 0 4
121065: PPUSH
121066: LD_VAR 0 5
121070: PPUSH
121071: LD_INT 12
121073: PPUSH
121074: CALL 121470 0 4
// if cmd = 256 then
121078: LD_VAR 0 1
121082: PUSH
121083: LD_INT 256
121085: EQUAL
121086: IFFALSE 121107
// SetFactoryWaypoint ( unit , x , y ) ;
121088: LD_VAR 0 2
121092: PPUSH
121093: LD_VAR 0 4
121097: PPUSH
121098: LD_VAR 0 5
121102: PPUSH
121103: CALL 121112 0 3
// end ;
121107: LD_VAR 0 6
121111: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
121112: LD_INT 0
121114: PPUSH
121115: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
121116: LD_VAR 0 1
121120: NOT
121121: PUSH
121122: LD_VAR 0 2
121126: PPUSH
121127: LD_VAR 0 3
121131: PPUSH
121132: CALL_OW 488
121136: NOT
121137: OR
121138: PUSH
121139: LD_VAR 0 1
121143: PPUSH
121144: CALL_OW 266
121148: PUSH
121149: LD_INT 3
121151: NONEQUAL
121152: PUSH
121153: LD_VAR 0 1
121157: PPUSH
121158: CALL_OW 247
121162: PUSH
121163: LD_INT 1
121165: EQUAL
121166: NOT
121167: AND
121168: OR
121169: IFFALSE 121173
// exit ;
121171: GO 121322
// if GetType ( factory ) = unit_human then
121173: LD_VAR 0 1
121177: PPUSH
121178: CALL_OW 247
121182: PUSH
121183: LD_INT 1
121185: EQUAL
121186: IFFALSE 121203
// factory := IsInUnit ( factory ) ;
121188: LD_ADDR_VAR 0 1
121192: PUSH
121193: LD_VAR 0 1
121197: PPUSH
121198: CALL_OW 310
121202: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
121203: LD_VAR 0 1
121207: PPUSH
121208: CALL_OW 266
121212: PUSH
121213: LD_INT 3
121215: NONEQUAL
121216: IFFALSE 121220
// exit ;
121218: GO 121322
// if HexInfo ( x , y ) = factory then
121220: LD_VAR 0 2
121224: PPUSH
121225: LD_VAR 0 3
121229: PPUSH
121230: CALL_OW 428
121234: PUSH
121235: LD_VAR 0 1
121239: EQUAL
121240: IFFALSE 121267
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
121242: LD_ADDR_EXP 219
121246: PUSH
121247: LD_EXP 219
121251: PPUSH
121252: LD_VAR 0 1
121256: PPUSH
121257: LD_INT 0
121259: PPUSH
121260: CALL_OW 1
121264: ST_TO_ADDR
121265: GO 121318
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
121267: LD_ADDR_EXP 219
121271: PUSH
121272: LD_EXP 219
121276: PPUSH
121277: LD_VAR 0 1
121281: PPUSH
121282: LD_VAR 0 1
121286: PPUSH
121287: CALL_OW 255
121291: PUSH
121292: LD_VAR 0 1
121296: PUSH
121297: LD_VAR 0 2
121301: PUSH
121302: LD_VAR 0 3
121306: PUSH
121307: EMPTY
121308: LIST
121309: LIST
121310: LIST
121311: LIST
121312: PPUSH
121313: CALL_OW 1
121317: ST_TO_ADDR
// UpdateFactoryWaypoints ;
121318: CALL 121327 0 0
// end ;
121322: LD_VAR 0 4
121326: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
121327: LD_INT 0
121329: PPUSH
121330: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
121331: LD_STRING resetFactoryWaypoint();
121333: PPUSH
121334: CALL_OW 559
// if factoryWaypoints then
121338: LD_EXP 219
121342: IFFALSE 121465
// begin for i := 1 to factoryWaypoints do
121344: LD_ADDR_VAR 0 2
121348: PUSH
121349: DOUBLE
121350: LD_INT 1
121352: DEC
121353: ST_TO_ADDR
121354: LD_EXP 219
121358: PUSH
121359: FOR_TO
121360: IFFALSE 121463
// if factoryWaypoints [ i ] then
121362: LD_EXP 219
121366: PUSH
121367: LD_VAR 0 2
121371: ARRAY
121372: IFFALSE 121461
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
121374: LD_STRING setFactoryWaypointXY(
121376: PUSH
121377: LD_EXP 219
121381: PUSH
121382: LD_VAR 0 2
121386: ARRAY
121387: PUSH
121388: LD_INT 1
121390: ARRAY
121391: STR
121392: PUSH
121393: LD_STRING ,
121395: STR
121396: PUSH
121397: LD_EXP 219
121401: PUSH
121402: LD_VAR 0 2
121406: ARRAY
121407: PUSH
121408: LD_INT 2
121410: ARRAY
121411: STR
121412: PUSH
121413: LD_STRING ,
121415: STR
121416: PUSH
121417: LD_EXP 219
121421: PUSH
121422: LD_VAR 0 2
121426: ARRAY
121427: PUSH
121428: LD_INT 3
121430: ARRAY
121431: STR
121432: PUSH
121433: LD_STRING ,
121435: STR
121436: PUSH
121437: LD_EXP 219
121441: PUSH
121442: LD_VAR 0 2
121446: ARRAY
121447: PUSH
121448: LD_INT 4
121450: ARRAY
121451: STR
121452: PUSH
121453: LD_STRING )
121455: STR
121456: PPUSH
121457: CALL_OW 559
121461: GO 121359
121463: POP
121464: POP
// end ; end ;
121465: LD_VAR 0 1
121469: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
121470: LD_INT 0
121472: PPUSH
121473: PPUSH
121474: PPUSH
121475: PPUSH
121476: PPUSH
121477: PPUSH
121478: PPUSH
121479: PPUSH
121480: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
121481: LD_VAR 0 1
121485: NOT
121486: PUSH
121487: LD_VAR 0 2
121491: PPUSH
121492: LD_VAR 0 3
121496: PPUSH
121497: CALL_OW 488
121501: NOT
121502: OR
121503: PUSH
121504: LD_VAR 0 4
121508: NOT
121509: OR
121510: IFFALSE 121514
// exit ;
121512: GO 121854
// list := [ ] ;
121514: LD_ADDR_VAR 0 13
121518: PUSH
121519: EMPTY
121520: ST_TO_ADDR
// if x - r < 0 then
121521: LD_VAR 0 2
121525: PUSH
121526: LD_VAR 0 4
121530: MINUS
121531: PUSH
121532: LD_INT 0
121534: LESS
121535: IFFALSE 121547
// min_x := 0 else
121537: LD_ADDR_VAR 0 7
121541: PUSH
121542: LD_INT 0
121544: ST_TO_ADDR
121545: GO 121563
// min_x := x - r ;
121547: LD_ADDR_VAR 0 7
121551: PUSH
121552: LD_VAR 0 2
121556: PUSH
121557: LD_VAR 0 4
121561: MINUS
121562: ST_TO_ADDR
// if y - r < 0 then
121563: LD_VAR 0 3
121567: PUSH
121568: LD_VAR 0 4
121572: MINUS
121573: PUSH
121574: LD_INT 0
121576: LESS
121577: IFFALSE 121589
// min_y := 0 else
121579: LD_ADDR_VAR 0 8
121583: PUSH
121584: LD_INT 0
121586: ST_TO_ADDR
121587: GO 121605
// min_y := y - r ;
121589: LD_ADDR_VAR 0 8
121593: PUSH
121594: LD_VAR 0 3
121598: PUSH
121599: LD_VAR 0 4
121603: MINUS
121604: ST_TO_ADDR
// max_x := x + r ;
121605: LD_ADDR_VAR 0 9
121609: PUSH
121610: LD_VAR 0 2
121614: PUSH
121615: LD_VAR 0 4
121619: PLUS
121620: ST_TO_ADDR
// max_y := y + r ;
121621: LD_ADDR_VAR 0 10
121625: PUSH
121626: LD_VAR 0 3
121630: PUSH
121631: LD_VAR 0 4
121635: PLUS
121636: ST_TO_ADDR
// for _x = min_x to max_x do
121637: LD_ADDR_VAR 0 11
121641: PUSH
121642: DOUBLE
121643: LD_VAR 0 7
121647: DEC
121648: ST_TO_ADDR
121649: LD_VAR 0 9
121653: PUSH
121654: FOR_TO
121655: IFFALSE 121772
// for _y = min_y to max_y do
121657: LD_ADDR_VAR 0 12
121661: PUSH
121662: DOUBLE
121663: LD_VAR 0 8
121667: DEC
121668: ST_TO_ADDR
121669: LD_VAR 0 10
121673: PUSH
121674: FOR_TO
121675: IFFALSE 121768
// begin if not ValidHex ( _x , _y ) then
121677: LD_VAR 0 11
121681: PPUSH
121682: LD_VAR 0 12
121686: PPUSH
121687: CALL_OW 488
121691: NOT
121692: IFFALSE 121696
// continue ;
121694: GO 121674
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
121696: LD_VAR 0 11
121700: PPUSH
121701: LD_VAR 0 12
121705: PPUSH
121706: CALL_OW 351
121710: PUSH
121711: LD_VAR 0 11
121715: PPUSH
121716: LD_VAR 0 12
121720: PPUSH
121721: CALL_OW 554
121725: AND
121726: IFFALSE 121766
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
121728: LD_ADDR_VAR 0 13
121732: PUSH
121733: LD_VAR 0 13
121737: PPUSH
121738: LD_VAR 0 13
121742: PUSH
121743: LD_INT 1
121745: PLUS
121746: PPUSH
121747: LD_VAR 0 11
121751: PUSH
121752: LD_VAR 0 12
121756: PUSH
121757: EMPTY
121758: LIST
121759: LIST
121760: PPUSH
121761: CALL_OW 2
121765: ST_TO_ADDR
// end ;
121766: GO 121674
121768: POP
121769: POP
121770: GO 121654
121772: POP
121773: POP
// if not list then
121774: LD_VAR 0 13
121778: NOT
121779: IFFALSE 121783
// exit ;
121781: GO 121854
// for i in list do
121783: LD_ADDR_VAR 0 6
121787: PUSH
121788: LD_VAR 0 13
121792: PUSH
121793: FOR_IN
121794: IFFALSE 121852
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
121796: LD_VAR 0 1
121800: PPUSH
121801: LD_STRING M
121803: PUSH
121804: LD_VAR 0 6
121808: PUSH
121809: LD_INT 1
121811: ARRAY
121812: PUSH
121813: LD_VAR 0 6
121817: PUSH
121818: LD_INT 2
121820: ARRAY
121821: PUSH
121822: LD_INT 0
121824: PUSH
121825: LD_INT 0
121827: PUSH
121828: LD_INT 0
121830: PUSH
121831: LD_INT 0
121833: PUSH
121834: EMPTY
121835: LIST
121836: LIST
121837: LIST
121838: LIST
121839: LIST
121840: LIST
121841: LIST
121842: PUSH
121843: EMPTY
121844: LIST
121845: PPUSH
121846: CALL_OW 447
121850: GO 121793
121852: POP
121853: POP
// end ;
121854: LD_VAR 0 5
121858: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
121859: LD_EXP 220
121863: NOT
121864: IFFALSE 121914
121866: GO 121868
121868: DISABLE
// begin initHack := true ;
121869: LD_ADDR_EXP 220
121873: PUSH
121874: LD_INT 1
121876: ST_TO_ADDR
// hackTanks := [ ] ;
121877: LD_ADDR_EXP 221
121881: PUSH
121882: EMPTY
121883: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
121884: LD_ADDR_EXP 222
121888: PUSH
121889: EMPTY
121890: ST_TO_ADDR
// hackLimit := 3 ;
121891: LD_ADDR_EXP 223
121895: PUSH
121896: LD_INT 3
121898: ST_TO_ADDR
// hackDist := 12 ;
121899: LD_ADDR_EXP 224
121903: PUSH
121904: LD_INT 12
121906: ST_TO_ADDR
// hackCounter := [ ] ;
121907: LD_ADDR_EXP 225
121911: PUSH
121912: EMPTY
121913: ST_TO_ADDR
// end ;
121914: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
121915: LD_EXP 220
121919: PUSH
121920: LD_INT 34
121922: PUSH
121923: LD_EXP 97
121927: PUSH
121928: EMPTY
121929: LIST
121930: LIST
121931: PPUSH
121932: CALL_OW 69
121936: AND
121937: IFFALSE 122192
121939: GO 121941
121941: DISABLE
121942: LD_INT 0
121944: PPUSH
121945: PPUSH
// begin enable ;
121946: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
121947: LD_ADDR_VAR 0 1
121951: PUSH
121952: LD_INT 34
121954: PUSH
121955: LD_EXP 97
121959: PUSH
121960: EMPTY
121961: LIST
121962: LIST
121963: PPUSH
121964: CALL_OW 69
121968: PUSH
121969: FOR_IN
121970: IFFALSE 122190
// begin if not i in hackTanks then
121972: LD_VAR 0 1
121976: PUSH
121977: LD_EXP 221
121981: IN
121982: NOT
121983: IFFALSE 122066
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
121985: LD_ADDR_EXP 221
121989: PUSH
121990: LD_EXP 221
121994: PPUSH
121995: LD_EXP 221
121999: PUSH
122000: LD_INT 1
122002: PLUS
122003: PPUSH
122004: LD_VAR 0 1
122008: PPUSH
122009: CALL_OW 1
122013: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
122014: LD_ADDR_EXP 222
122018: PUSH
122019: LD_EXP 222
122023: PPUSH
122024: LD_EXP 222
122028: PUSH
122029: LD_INT 1
122031: PLUS
122032: PPUSH
122033: EMPTY
122034: PPUSH
122035: CALL_OW 1
122039: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
122040: LD_ADDR_EXP 225
122044: PUSH
122045: LD_EXP 225
122049: PPUSH
122050: LD_EXP 225
122054: PUSH
122055: LD_INT 1
122057: PLUS
122058: PPUSH
122059: EMPTY
122060: PPUSH
122061: CALL_OW 1
122065: ST_TO_ADDR
// end ; if not IsOk ( i ) then
122066: LD_VAR 0 1
122070: PPUSH
122071: CALL_OW 302
122075: NOT
122076: IFFALSE 122089
// begin HackUnlinkAll ( i ) ;
122078: LD_VAR 0 1
122082: PPUSH
122083: CALL 122195 0 1
// continue ;
122087: GO 121969
// end ; HackCheckCapturedStatus ( i ) ;
122089: LD_VAR 0 1
122093: PPUSH
122094: CALL 122638 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
122098: LD_ADDR_VAR 0 2
122102: PUSH
122103: LD_INT 81
122105: PUSH
122106: LD_VAR 0 1
122110: PPUSH
122111: CALL_OW 255
122115: PUSH
122116: EMPTY
122117: LIST
122118: LIST
122119: PUSH
122120: LD_INT 33
122122: PUSH
122123: LD_INT 3
122125: PUSH
122126: EMPTY
122127: LIST
122128: LIST
122129: PUSH
122130: LD_INT 91
122132: PUSH
122133: LD_VAR 0 1
122137: PUSH
122138: LD_EXP 224
122142: PUSH
122143: EMPTY
122144: LIST
122145: LIST
122146: LIST
122147: PUSH
122148: LD_INT 50
122150: PUSH
122151: EMPTY
122152: LIST
122153: PUSH
122154: EMPTY
122155: LIST
122156: LIST
122157: LIST
122158: LIST
122159: PPUSH
122160: CALL_OW 69
122164: ST_TO_ADDR
// if not tmp then
122165: LD_VAR 0 2
122169: NOT
122170: IFFALSE 122174
// continue ;
122172: GO 121969
// HackLink ( i , tmp ) ;
122174: LD_VAR 0 1
122178: PPUSH
122179: LD_VAR 0 2
122183: PPUSH
122184: CALL 122331 0 2
// end ;
122188: GO 121969
122190: POP
122191: POP
// end ;
122192: PPOPN 2
122194: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
122195: LD_INT 0
122197: PPUSH
122198: PPUSH
122199: PPUSH
// if not hack in hackTanks then
122200: LD_VAR 0 1
122204: PUSH
122205: LD_EXP 221
122209: IN
122210: NOT
122211: IFFALSE 122215
// exit ;
122213: GO 122326
// index := GetElementIndex ( hackTanks , hack ) ;
122215: LD_ADDR_VAR 0 4
122219: PUSH
122220: LD_EXP 221
122224: PPUSH
122225: LD_VAR 0 1
122229: PPUSH
122230: CALL 70687 0 2
122234: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
122235: LD_EXP 222
122239: PUSH
122240: LD_VAR 0 4
122244: ARRAY
122245: IFFALSE 122326
// begin for i in hackTanksCaptured [ index ] do
122247: LD_ADDR_VAR 0 3
122251: PUSH
122252: LD_EXP 222
122256: PUSH
122257: LD_VAR 0 4
122261: ARRAY
122262: PUSH
122263: FOR_IN
122264: IFFALSE 122290
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
122266: LD_VAR 0 3
122270: PUSH
122271: LD_INT 1
122273: ARRAY
122274: PPUSH
122275: LD_VAR 0 3
122279: PUSH
122280: LD_INT 2
122282: ARRAY
122283: PPUSH
122284: CALL_OW 235
122288: GO 122263
122290: POP
122291: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
122292: LD_ADDR_EXP 222
122296: PUSH
122297: LD_EXP 222
122301: PPUSH
122302: LD_VAR 0 4
122306: PPUSH
122307: EMPTY
122308: PPUSH
122309: CALL_OW 1
122313: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
122314: LD_VAR 0 1
122318: PPUSH
122319: LD_INT 0
122321: PPUSH
122322: CALL_OW 505
// end ; end ;
122326: LD_VAR 0 2
122330: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
122331: LD_INT 0
122333: PPUSH
122334: PPUSH
122335: PPUSH
// if not hack in hackTanks or not vehicles then
122336: LD_VAR 0 1
122340: PUSH
122341: LD_EXP 221
122345: IN
122346: NOT
122347: PUSH
122348: LD_VAR 0 2
122352: NOT
122353: OR
122354: IFFALSE 122358
// exit ;
122356: GO 122633
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
122358: LD_ADDR_VAR 0 2
122362: PUSH
122363: LD_VAR 0 1
122367: PPUSH
122368: LD_VAR 0 2
122372: PPUSH
122373: LD_INT 1
122375: PPUSH
122376: LD_INT 1
122378: PPUSH
122379: CALL 71337 0 4
122383: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
122384: LD_ADDR_VAR 0 5
122388: PUSH
122389: LD_EXP 221
122393: PPUSH
122394: LD_VAR 0 1
122398: PPUSH
122399: CALL 70687 0 2
122403: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
122404: LD_EXP 222
122408: PUSH
122409: LD_VAR 0 5
122413: ARRAY
122414: PUSH
122415: LD_EXP 223
122419: LESS
122420: IFFALSE 122609
// begin for i := 1 to vehicles do
122422: LD_ADDR_VAR 0 4
122426: PUSH
122427: DOUBLE
122428: LD_INT 1
122430: DEC
122431: ST_TO_ADDR
122432: LD_VAR 0 2
122436: PUSH
122437: FOR_TO
122438: IFFALSE 122607
// begin if hackTanksCaptured [ index ] = hackLimit then
122440: LD_EXP 222
122444: PUSH
122445: LD_VAR 0 5
122449: ARRAY
122450: PUSH
122451: LD_EXP 223
122455: EQUAL
122456: IFFALSE 122460
// break ;
122458: GO 122607
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
122460: LD_ADDR_EXP 225
122464: PUSH
122465: LD_EXP 225
122469: PPUSH
122470: LD_VAR 0 5
122474: PPUSH
122475: LD_EXP 225
122479: PUSH
122480: LD_VAR 0 5
122484: ARRAY
122485: PUSH
122486: LD_INT 1
122488: PLUS
122489: PPUSH
122490: CALL_OW 1
122494: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
122495: LD_ADDR_EXP 222
122499: PUSH
122500: LD_EXP 222
122504: PPUSH
122505: LD_VAR 0 5
122509: PUSH
122510: LD_EXP 222
122514: PUSH
122515: LD_VAR 0 5
122519: ARRAY
122520: PUSH
122521: LD_INT 1
122523: PLUS
122524: PUSH
122525: EMPTY
122526: LIST
122527: LIST
122528: PPUSH
122529: LD_VAR 0 2
122533: PUSH
122534: LD_VAR 0 4
122538: ARRAY
122539: PUSH
122540: LD_VAR 0 2
122544: PUSH
122545: LD_VAR 0 4
122549: ARRAY
122550: PPUSH
122551: CALL_OW 255
122555: PUSH
122556: EMPTY
122557: LIST
122558: LIST
122559: PPUSH
122560: CALL 70902 0 3
122564: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
122565: LD_VAR 0 2
122569: PUSH
122570: LD_VAR 0 4
122574: ARRAY
122575: PPUSH
122576: LD_VAR 0 1
122580: PPUSH
122581: CALL_OW 255
122585: PPUSH
122586: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
122590: LD_VAR 0 2
122594: PUSH
122595: LD_VAR 0 4
122599: ARRAY
122600: PPUSH
122601: CALL_OW 141
// end ;
122605: GO 122437
122607: POP
122608: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
122609: LD_VAR 0 1
122613: PPUSH
122614: LD_EXP 222
122618: PUSH
122619: LD_VAR 0 5
122623: ARRAY
122624: PUSH
122625: LD_INT 0
122627: PLUS
122628: PPUSH
122629: CALL_OW 505
// end ;
122633: LD_VAR 0 3
122637: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
122638: LD_INT 0
122640: PPUSH
122641: PPUSH
122642: PPUSH
122643: PPUSH
// if not hack in hackTanks then
122644: LD_VAR 0 1
122648: PUSH
122649: LD_EXP 221
122653: IN
122654: NOT
122655: IFFALSE 122659
// exit ;
122657: GO 122899
// index := GetElementIndex ( hackTanks , hack ) ;
122659: LD_ADDR_VAR 0 4
122663: PUSH
122664: LD_EXP 221
122668: PPUSH
122669: LD_VAR 0 1
122673: PPUSH
122674: CALL 70687 0 2
122678: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
122679: LD_ADDR_VAR 0 3
122683: PUSH
122684: DOUBLE
122685: LD_EXP 222
122689: PUSH
122690: LD_VAR 0 4
122694: ARRAY
122695: INC
122696: ST_TO_ADDR
122697: LD_INT 1
122699: PUSH
122700: FOR_DOWNTO
122701: IFFALSE 122873
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
122703: LD_ADDR_VAR 0 5
122707: PUSH
122708: LD_EXP 222
122712: PUSH
122713: LD_VAR 0 4
122717: ARRAY
122718: PUSH
122719: LD_VAR 0 3
122723: ARRAY
122724: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
122725: LD_VAR 0 5
122729: PUSH
122730: LD_INT 1
122732: ARRAY
122733: PPUSH
122734: CALL_OW 302
122738: NOT
122739: PUSH
122740: LD_VAR 0 5
122744: PUSH
122745: LD_INT 1
122747: ARRAY
122748: PPUSH
122749: CALL_OW 255
122753: PUSH
122754: LD_VAR 0 1
122758: PPUSH
122759: CALL_OW 255
122763: NONEQUAL
122764: OR
122765: IFFALSE 122871
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
122767: LD_VAR 0 5
122771: PUSH
122772: LD_INT 1
122774: ARRAY
122775: PPUSH
122776: CALL_OW 305
122780: PUSH
122781: LD_VAR 0 5
122785: PUSH
122786: LD_INT 1
122788: ARRAY
122789: PPUSH
122790: CALL_OW 255
122794: PUSH
122795: LD_VAR 0 1
122799: PPUSH
122800: CALL_OW 255
122804: EQUAL
122805: AND
122806: IFFALSE 122830
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
122808: LD_VAR 0 5
122812: PUSH
122813: LD_INT 1
122815: ARRAY
122816: PPUSH
122817: LD_VAR 0 5
122821: PUSH
122822: LD_INT 2
122824: ARRAY
122825: PPUSH
122826: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
122830: LD_ADDR_EXP 222
122834: PUSH
122835: LD_EXP 222
122839: PPUSH
122840: LD_VAR 0 4
122844: PPUSH
122845: LD_EXP 222
122849: PUSH
122850: LD_VAR 0 4
122854: ARRAY
122855: PPUSH
122856: LD_VAR 0 3
122860: PPUSH
122861: CALL_OW 3
122865: PPUSH
122866: CALL_OW 1
122870: ST_TO_ADDR
// end ; end ;
122871: GO 122700
122873: POP
122874: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
122875: LD_VAR 0 1
122879: PPUSH
122880: LD_EXP 222
122884: PUSH
122885: LD_VAR 0 4
122889: ARRAY
122890: PUSH
122891: LD_INT 0
122893: PLUS
122894: PPUSH
122895: CALL_OW 505
// end ;
122899: LD_VAR 0 2
122903: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
122904: LD_INT 0
122906: PPUSH
122907: PPUSH
122908: PPUSH
122909: PPUSH
// if not hack in hackTanks then
122910: LD_VAR 0 1
122914: PUSH
122915: LD_EXP 221
122919: IN
122920: NOT
122921: IFFALSE 122925
// exit ;
122923: GO 123010
// index := GetElementIndex ( hackTanks , hack ) ;
122925: LD_ADDR_VAR 0 5
122929: PUSH
122930: LD_EXP 221
122934: PPUSH
122935: LD_VAR 0 1
122939: PPUSH
122940: CALL 70687 0 2
122944: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
122945: LD_ADDR_VAR 0 4
122949: PUSH
122950: DOUBLE
122951: LD_INT 1
122953: DEC
122954: ST_TO_ADDR
122955: LD_EXP 222
122959: PUSH
122960: LD_VAR 0 5
122964: ARRAY
122965: PUSH
122966: FOR_TO
122967: IFFALSE 123008
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
122969: LD_EXP 222
122973: PUSH
122974: LD_VAR 0 5
122978: ARRAY
122979: PUSH
122980: LD_VAR 0 4
122984: ARRAY
122985: PUSH
122986: LD_INT 1
122988: ARRAY
122989: PUSH
122990: LD_VAR 0 2
122994: EQUAL
122995: IFFALSE 123006
// KillUnit ( vehicle ) ;
122997: LD_VAR 0 2
123001: PPUSH
123002: CALL_OW 66
123006: GO 122966
123008: POP
123009: POP
// end ;
123010: LD_VAR 0 3
123014: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
123015: LD_EXP 226
123019: NOT
123020: IFFALSE 123055
123022: GO 123024
123024: DISABLE
// begin initMiner := true ;
123025: LD_ADDR_EXP 226
123029: PUSH
123030: LD_INT 1
123032: ST_TO_ADDR
// minersList := [ ] ;
123033: LD_ADDR_EXP 227
123037: PUSH
123038: EMPTY
123039: ST_TO_ADDR
// minerMinesList := [ ] ;
123040: LD_ADDR_EXP 228
123044: PUSH
123045: EMPTY
123046: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
123047: LD_ADDR_EXP 229
123051: PUSH
123052: LD_INT 5
123054: ST_TO_ADDR
// end ;
123055: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
123056: LD_EXP 226
123060: PUSH
123061: LD_INT 34
123063: PUSH
123064: LD_EXP 102
123068: PUSH
123069: EMPTY
123070: LIST
123071: LIST
123072: PPUSH
123073: CALL_OW 69
123077: AND
123078: IFFALSE 123541
123080: GO 123082
123082: DISABLE
123083: LD_INT 0
123085: PPUSH
123086: PPUSH
123087: PPUSH
123088: PPUSH
// begin enable ;
123089: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
123090: LD_ADDR_VAR 0 1
123094: PUSH
123095: LD_INT 34
123097: PUSH
123098: LD_EXP 102
123102: PUSH
123103: EMPTY
123104: LIST
123105: LIST
123106: PPUSH
123107: CALL_OW 69
123111: PUSH
123112: FOR_IN
123113: IFFALSE 123185
// begin if not i in minersList then
123115: LD_VAR 0 1
123119: PUSH
123120: LD_EXP 227
123124: IN
123125: NOT
123126: IFFALSE 123183
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
123128: LD_ADDR_EXP 227
123132: PUSH
123133: LD_EXP 227
123137: PPUSH
123138: LD_EXP 227
123142: PUSH
123143: LD_INT 1
123145: PLUS
123146: PPUSH
123147: LD_VAR 0 1
123151: PPUSH
123152: CALL_OW 1
123156: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
123157: LD_ADDR_EXP 228
123161: PUSH
123162: LD_EXP 228
123166: PPUSH
123167: LD_EXP 228
123171: PUSH
123172: LD_INT 1
123174: PLUS
123175: PPUSH
123176: EMPTY
123177: PPUSH
123178: CALL_OW 1
123182: ST_TO_ADDR
// end end ;
123183: GO 123112
123185: POP
123186: POP
// for i := minerMinesList downto 1 do
123187: LD_ADDR_VAR 0 1
123191: PUSH
123192: DOUBLE
123193: LD_EXP 228
123197: INC
123198: ST_TO_ADDR
123199: LD_INT 1
123201: PUSH
123202: FOR_DOWNTO
123203: IFFALSE 123539
// begin if IsLive ( minersList [ i ] ) then
123205: LD_EXP 227
123209: PUSH
123210: LD_VAR 0 1
123214: ARRAY
123215: PPUSH
123216: CALL_OW 300
123220: IFFALSE 123248
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
123222: LD_EXP 227
123226: PUSH
123227: LD_VAR 0 1
123231: ARRAY
123232: PPUSH
123233: LD_EXP 228
123237: PUSH
123238: LD_VAR 0 1
123242: ARRAY
123243: PPUSH
123244: CALL_OW 505
// if not minerMinesList [ i ] then
123248: LD_EXP 228
123252: PUSH
123253: LD_VAR 0 1
123257: ARRAY
123258: NOT
123259: IFFALSE 123263
// continue ;
123261: GO 123202
// for j := minerMinesList [ i ] downto 1 do
123263: LD_ADDR_VAR 0 2
123267: PUSH
123268: DOUBLE
123269: LD_EXP 228
123273: PUSH
123274: LD_VAR 0 1
123278: ARRAY
123279: INC
123280: ST_TO_ADDR
123281: LD_INT 1
123283: PUSH
123284: FOR_DOWNTO
123285: IFFALSE 123535
// begin side := GetSide ( minersList [ i ] ) ;
123287: LD_ADDR_VAR 0 3
123291: PUSH
123292: LD_EXP 227
123296: PUSH
123297: LD_VAR 0 1
123301: ARRAY
123302: PPUSH
123303: CALL_OW 255
123307: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
123308: LD_ADDR_VAR 0 4
123312: PUSH
123313: LD_EXP 228
123317: PUSH
123318: LD_VAR 0 1
123322: ARRAY
123323: PUSH
123324: LD_VAR 0 2
123328: ARRAY
123329: PUSH
123330: LD_INT 1
123332: ARRAY
123333: PPUSH
123334: LD_EXP 228
123338: PUSH
123339: LD_VAR 0 1
123343: ARRAY
123344: PUSH
123345: LD_VAR 0 2
123349: ARRAY
123350: PUSH
123351: LD_INT 2
123353: ARRAY
123354: PPUSH
123355: CALL_OW 428
123359: ST_TO_ADDR
// if not tmp then
123360: LD_VAR 0 4
123364: NOT
123365: IFFALSE 123369
// continue ;
123367: GO 123284
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
123369: LD_VAR 0 4
123373: PUSH
123374: LD_INT 81
123376: PUSH
123377: LD_VAR 0 3
123381: PUSH
123382: EMPTY
123383: LIST
123384: LIST
123385: PPUSH
123386: CALL_OW 69
123390: IN
123391: PUSH
123392: LD_EXP 228
123396: PUSH
123397: LD_VAR 0 1
123401: ARRAY
123402: PUSH
123403: LD_VAR 0 2
123407: ARRAY
123408: PUSH
123409: LD_INT 1
123411: ARRAY
123412: PPUSH
123413: LD_EXP 228
123417: PUSH
123418: LD_VAR 0 1
123422: ARRAY
123423: PUSH
123424: LD_VAR 0 2
123428: ARRAY
123429: PUSH
123430: LD_INT 2
123432: ARRAY
123433: PPUSH
123434: CALL_OW 458
123438: AND
123439: IFFALSE 123533
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
123441: LD_EXP 228
123445: PUSH
123446: LD_VAR 0 1
123450: ARRAY
123451: PUSH
123452: LD_VAR 0 2
123456: ARRAY
123457: PUSH
123458: LD_INT 1
123460: ARRAY
123461: PPUSH
123462: LD_EXP 228
123466: PUSH
123467: LD_VAR 0 1
123471: ARRAY
123472: PUSH
123473: LD_VAR 0 2
123477: ARRAY
123478: PUSH
123479: LD_INT 2
123481: ARRAY
123482: PPUSH
123483: LD_VAR 0 3
123487: PPUSH
123488: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
123492: LD_ADDR_EXP 228
123496: PUSH
123497: LD_EXP 228
123501: PPUSH
123502: LD_VAR 0 1
123506: PPUSH
123507: LD_EXP 228
123511: PUSH
123512: LD_VAR 0 1
123516: ARRAY
123517: PPUSH
123518: LD_VAR 0 2
123522: PPUSH
123523: CALL_OW 3
123527: PPUSH
123528: CALL_OW 1
123532: ST_TO_ADDR
// end ; end ;
123533: GO 123284
123535: POP
123536: POP
// end ;
123537: GO 123202
123539: POP
123540: POP
// end ;
123541: PPOPN 4
123543: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
123544: LD_INT 0
123546: PPUSH
123547: PPUSH
// result := false ;
123548: LD_ADDR_VAR 0 4
123552: PUSH
123553: LD_INT 0
123555: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
123556: LD_VAR 0 1
123560: PPUSH
123561: CALL_OW 264
123565: PUSH
123566: LD_EXP 102
123570: EQUAL
123571: NOT
123572: IFFALSE 123576
// exit ;
123574: GO 123816
// index := GetElementIndex ( minersList , unit ) ;
123576: LD_ADDR_VAR 0 5
123580: PUSH
123581: LD_EXP 227
123585: PPUSH
123586: LD_VAR 0 1
123590: PPUSH
123591: CALL 70687 0 2
123595: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
123596: LD_EXP 228
123600: PUSH
123601: LD_VAR 0 5
123605: ARRAY
123606: PUSH
123607: LD_EXP 229
123611: GREATEREQUAL
123612: IFFALSE 123616
// exit ;
123614: GO 123816
// ComMoveXY ( unit , x , y ) ;
123616: LD_VAR 0 1
123620: PPUSH
123621: LD_VAR 0 2
123625: PPUSH
123626: LD_VAR 0 3
123630: PPUSH
123631: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
123635: LD_INT 35
123637: PPUSH
123638: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
123642: LD_VAR 0 1
123646: PPUSH
123647: LD_VAR 0 2
123651: PPUSH
123652: LD_VAR 0 3
123656: PPUSH
123657: CALL 101406 0 3
123661: NOT
123662: PUSH
123663: LD_VAR 0 1
123667: PPUSH
123668: CALL_OW 314
123672: AND
123673: IFFALSE 123677
// exit ;
123675: GO 123816
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
123677: LD_VAR 0 2
123681: PPUSH
123682: LD_VAR 0 3
123686: PPUSH
123687: CALL_OW 428
123691: PUSH
123692: LD_VAR 0 1
123696: EQUAL
123697: PUSH
123698: LD_VAR 0 1
123702: PPUSH
123703: CALL_OW 314
123707: NOT
123708: AND
123709: IFFALSE 123635
// PlaySoundXY ( x , y , PlantMine ) ;
123711: LD_VAR 0 2
123715: PPUSH
123716: LD_VAR 0 3
123720: PPUSH
123721: LD_STRING PlantMine
123723: PPUSH
123724: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
123728: LD_VAR 0 2
123732: PPUSH
123733: LD_VAR 0 3
123737: PPUSH
123738: LD_VAR 0 1
123742: PPUSH
123743: CALL_OW 255
123747: PPUSH
123748: LD_INT 0
123750: PPUSH
123751: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
123755: LD_ADDR_EXP 228
123759: PUSH
123760: LD_EXP 228
123764: PPUSH
123765: LD_VAR 0 5
123769: PUSH
123770: LD_EXP 228
123774: PUSH
123775: LD_VAR 0 5
123779: ARRAY
123780: PUSH
123781: LD_INT 1
123783: PLUS
123784: PUSH
123785: EMPTY
123786: LIST
123787: LIST
123788: PPUSH
123789: LD_VAR 0 2
123793: PUSH
123794: LD_VAR 0 3
123798: PUSH
123799: EMPTY
123800: LIST
123801: LIST
123802: PPUSH
123803: CALL 70902 0 3
123807: ST_TO_ADDR
// result := true ;
123808: LD_ADDR_VAR 0 4
123812: PUSH
123813: LD_INT 1
123815: ST_TO_ADDR
// end ;
123816: LD_VAR 0 4
123820: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
123821: LD_INT 0
123823: PPUSH
123824: PPUSH
123825: PPUSH
// if not unit in minersList then
123826: LD_VAR 0 1
123830: PUSH
123831: LD_EXP 227
123835: IN
123836: NOT
123837: IFFALSE 123841
// exit ;
123839: GO 124233
// index := GetElementIndex ( minersList , unit ) ;
123841: LD_ADDR_VAR 0 6
123845: PUSH
123846: LD_EXP 227
123850: PPUSH
123851: LD_VAR 0 1
123855: PPUSH
123856: CALL 70687 0 2
123860: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
123861: LD_ADDR_VAR 0 5
123865: PUSH
123866: DOUBLE
123867: LD_EXP 228
123871: PUSH
123872: LD_VAR 0 6
123876: ARRAY
123877: INC
123878: ST_TO_ADDR
123879: LD_INT 1
123881: PUSH
123882: FOR_DOWNTO
123883: IFFALSE 124044
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
123885: LD_EXP 228
123889: PUSH
123890: LD_VAR 0 6
123894: ARRAY
123895: PUSH
123896: LD_VAR 0 5
123900: ARRAY
123901: PUSH
123902: LD_INT 1
123904: ARRAY
123905: PUSH
123906: LD_VAR 0 2
123910: EQUAL
123911: PUSH
123912: LD_EXP 228
123916: PUSH
123917: LD_VAR 0 6
123921: ARRAY
123922: PUSH
123923: LD_VAR 0 5
123927: ARRAY
123928: PUSH
123929: LD_INT 2
123931: ARRAY
123932: PUSH
123933: LD_VAR 0 3
123937: EQUAL
123938: AND
123939: IFFALSE 124042
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
123941: LD_EXP 228
123945: PUSH
123946: LD_VAR 0 6
123950: ARRAY
123951: PUSH
123952: LD_VAR 0 5
123956: ARRAY
123957: PUSH
123958: LD_INT 1
123960: ARRAY
123961: PPUSH
123962: LD_EXP 228
123966: PUSH
123967: LD_VAR 0 6
123971: ARRAY
123972: PUSH
123973: LD_VAR 0 5
123977: ARRAY
123978: PUSH
123979: LD_INT 2
123981: ARRAY
123982: PPUSH
123983: LD_VAR 0 1
123987: PPUSH
123988: CALL_OW 255
123992: PPUSH
123993: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
123997: LD_ADDR_EXP 228
124001: PUSH
124002: LD_EXP 228
124006: PPUSH
124007: LD_VAR 0 6
124011: PPUSH
124012: LD_EXP 228
124016: PUSH
124017: LD_VAR 0 6
124021: ARRAY
124022: PPUSH
124023: LD_VAR 0 5
124027: PPUSH
124028: CALL_OW 3
124032: PPUSH
124033: CALL_OW 1
124037: ST_TO_ADDR
// exit ;
124038: POP
124039: POP
124040: GO 124233
// end ; end ;
124042: GO 123882
124044: POP
124045: POP
// for i := minerMinesList [ index ] downto 1 do
124046: LD_ADDR_VAR 0 5
124050: PUSH
124051: DOUBLE
124052: LD_EXP 228
124056: PUSH
124057: LD_VAR 0 6
124061: ARRAY
124062: INC
124063: ST_TO_ADDR
124064: LD_INT 1
124066: PUSH
124067: FOR_DOWNTO
124068: IFFALSE 124231
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
124070: LD_EXP 228
124074: PUSH
124075: LD_VAR 0 6
124079: ARRAY
124080: PUSH
124081: LD_VAR 0 5
124085: ARRAY
124086: PUSH
124087: LD_INT 1
124089: ARRAY
124090: PPUSH
124091: LD_EXP 228
124095: PUSH
124096: LD_VAR 0 6
124100: ARRAY
124101: PUSH
124102: LD_VAR 0 5
124106: ARRAY
124107: PUSH
124108: LD_INT 2
124110: ARRAY
124111: PPUSH
124112: LD_VAR 0 2
124116: PPUSH
124117: LD_VAR 0 3
124121: PPUSH
124122: CALL_OW 298
124126: PUSH
124127: LD_INT 6
124129: LESS
124130: IFFALSE 124229
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
124132: LD_EXP 228
124136: PUSH
124137: LD_VAR 0 6
124141: ARRAY
124142: PUSH
124143: LD_VAR 0 5
124147: ARRAY
124148: PUSH
124149: LD_INT 1
124151: ARRAY
124152: PPUSH
124153: LD_EXP 228
124157: PUSH
124158: LD_VAR 0 6
124162: ARRAY
124163: PUSH
124164: LD_VAR 0 5
124168: ARRAY
124169: PUSH
124170: LD_INT 2
124172: ARRAY
124173: PPUSH
124174: LD_VAR 0 1
124178: PPUSH
124179: CALL_OW 255
124183: PPUSH
124184: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
124188: LD_ADDR_EXP 228
124192: PUSH
124193: LD_EXP 228
124197: PPUSH
124198: LD_VAR 0 6
124202: PPUSH
124203: LD_EXP 228
124207: PUSH
124208: LD_VAR 0 6
124212: ARRAY
124213: PPUSH
124214: LD_VAR 0 5
124218: PPUSH
124219: CALL_OW 3
124223: PPUSH
124224: CALL_OW 1
124228: ST_TO_ADDR
// end ; end ;
124229: GO 124067
124231: POP
124232: POP
// end ;
124233: LD_VAR 0 4
124237: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
124238: LD_INT 0
124240: PPUSH
124241: PPUSH
124242: PPUSH
124243: PPUSH
124244: PPUSH
124245: PPUSH
124246: PPUSH
124247: PPUSH
124248: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
124249: LD_VAR 0 1
124253: PPUSH
124254: CALL_OW 264
124258: PUSH
124259: LD_EXP 102
124263: EQUAL
124264: NOT
124265: PUSH
124266: LD_VAR 0 1
124270: PUSH
124271: LD_EXP 227
124275: IN
124276: NOT
124277: OR
124278: IFFALSE 124282
// exit ;
124280: GO 124604
// index := GetElementIndex ( minersList , unit ) ;
124282: LD_ADDR_VAR 0 6
124286: PUSH
124287: LD_EXP 227
124291: PPUSH
124292: LD_VAR 0 1
124296: PPUSH
124297: CALL 70687 0 2
124301: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
124302: LD_ADDR_VAR 0 8
124306: PUSH
124307: LD_EXP 229
124311: PUSH
124312: LD_EXP 228
124316: PUSH
124317: LD_VAR 0 6
124321: ARRAY
124322: MINUS
124323: ST_TO_ADDR
// if not minesFreeAmount then
124324: LD_VAR 0 8
124328: NOT
124329: IFFALSE 124333
// exit ;
124331: GO 124604
// tmp := [ ] ;
124333: LD_ADDR_VAR 0 7
124337: PUSH
124338: EMPTY
124339: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
124340: LD_ADDR_VAR 0 5
124344: PUSH
124345: DOUBLE
124346: LD_INT 1
124348: DEC
124349: ST_TO_ADDR
124350: LD_VAR 0 8
124354: PUSH
124355: FOR_TO
124356: IFFALSE 124551
// begin _d := rand ( 0 , 5 ) ;
124358: LD_ADDR_VAR 0 11
124362: PUSH
124363: LD_INT 0
124365: PPUSH
124366: LD_INT 5
124368: PPUSH
124369: CALL_OW 12
124373: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
124374: LD_ADDR_VAR 0 12
124378: PUSH
124379: LD_INT 2
124381: PPUSH
124382: LD_INT 6
124384: PPUSH
124385: CALL_OW 12
124389: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
124390: LD_ADDR_VAR 0 9
124394: PUSH
124395: LD_VAR 0 2
124399: PPUSH
124400: LD_VAR 0 11
124404: PPUSH
124405: LD_VAR 0 12
124409: PPUSH
124410: CALL_OW 272
124414: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
124415: LD_ADDR_VAR 0 10
124419: PUSH
124420: LD_VAR 0 3
124424: PPUSH
124425: LD_VAR 0 11
124429: PPUSH
124430: LD_VAR 0 12
124434: PPUSH
124435: CALL_OW 273
124439: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
124440: LD_VAR 0 9
124444: PPUSH
124445: LD_VAR 0 10
124449: PPUSH
124450: CALL_OW 488
124454: PUSH
124455: LD_VAR 0 9
124459: PUSH
124460: LD_VAR 0 10
124464: PUSH
124465: EMPTY
124466: LIST
124467: LIST
124468: PUSH
124469: LD_VAR 0 7
124473: IN
124474: NOT
124475: AND
124476: PUSH
124477: LD_VAR 0 9
124481: PPUSH
124482: LD_VAR 0 10
124486: PPUSH
124487: CALL_OW 458
124491: NOT
124492: AND
124493: IFFALSE 124535
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
124495: LD_ADDR_VAR 0 7
124499: PUSH
124500: LD_VAR 0 7
124504: PPUSH
124505: LD_VAR 0 7
124509: PUSH
124510: LD_INT 1
124512: PLUS
124513: PPUSH
124514: LD_VAR 0 9
124518: PUSH
124519: LD_VAR 0 10
124523: PUSH
124524: EMPTY
124525: LIST
124526: LIST
124527: PPUSH
124528: CALL_OW 1
124532: ST_TO_ADDR
124533: GO 124549
// i := i - 1 ;
124535: LD_ADDR_VAR 0 5
124539: PUSH
124540: LD_VAR 0 5
124544: PUSH
124545: LD_INT 1
124547: MINUS
124548: ST_TO_ADDR
// end ;
124549: GO 124355
124551: POP
124552: POP
// for i in tmp do
124553: LD_ADDR_VAR 0 5
124557: PUSH
124558: LD_VAR 0 7
124562: PUSH
124563: FOR_IN
124564: IFFALSE 124602
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
124566: LD_VAR 0 1
124570: PPUSH
124571: LD_VAR 0 5
124575: PUSH
124576: LD_INT 1
124578: ARRAY
124579: PPUSH
124580: LD_VAR 0 5
124584: PUSH
124585: LD_INT 2
124587: ARRAY
124588: PPUSH
124589: CALL 123544 0 3
124593: NOT
124594: IFFALSE 124600
// exit ;
124596: POP
124597: POP
124598: GO 124604
124600: GO 124563
124602: POP
124603: POP
// end ;
124604: LD_VAR 0 4
124608: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
124609: LD_INT 0
124611: PPUSH
124612: PPUSH
124613: PPUSH
124614: PPUSH
124615: PPUSH
124616: PPUSH
124617: PPUSH
// if not GetClass ( unit ) = class_sniper then
124618: LD_VAR 0 1
124622: PPUSH
124623: CALL_OW 257
124627: PUSH
124628: LD_INT 5
124630: EQUAL
124631: NOT
124632: IFFALSE 124636
// exit ;
124634: GO 125024
// dist := 8 ;
124636: LD_ADDR_VAR 0 5
124640: PUSH
124641: LD_INT 8
124643: ST_TO_ADDR
// viewRange := 12 ;
124644: LD_ADDR_VAR 0 7
124648: PUSH
124649: LD_INT 12
124651: ST_TO_ADDR
// side := GetSide ( unit ) ;
124652: LD_ADDR_VAR 0 6
124656: PUSH
124657: LD_VAR 0 1
124661: PPUSH
124662: CALL_OW 255
124666: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
124667: LD_INT 61
124669: PPUSH
124670: LD_VAR 0 6
124674: PPUSH
124675: CALL_OW 321
124679: PUSH
124680: LD_INT 2
124682: EQUAL
124683: IFFALSE 124693
// viewRange := 16 ;
124685: LD_ADDR_VAR 0 7
124689: PUSH
124690: LD_INT 16
124692: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
124693: LD_VAR 0 1
124697: PPUSH
124698: LD_VAR 0 2
124702: PPUSH
124703: LD_VAR 0 3
124707: PPUSH
124708: CALL_OW 297
124712: PUSH
124713: LD_VAR 0 5
124717: GREATER
124718: IFFALSE 124797
// begin ComMoveXY ( unit , x , y ) ;
124720: LD_VAR 0 1
124724: PPUSH
124725: LD_VAR 0 2
124729: PPUSH
124730: LD_VAR 0 3
124734: PPUSH
124735: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
124739: LD_INT 35
124741: PPUSH
124742: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
124746: LD_VAR 0 1
124750: PPUSH
124751: LD_VAR 0 2
124755: PPUSH
124756: LD_VAR 0 3
124760: PPUSH
124761: CALL 101406 0 3
124765: NOT
124766: IFFALSE 124770
// exit ;
124768: GO 125024
// until GetDistUnitXY ( unit , x , y ) < dist ;
124770: LD_VAR 0 1
124774: PPUSH
124775: LD_VAR 0 2
124779: PPUSH
124780: LD_VAR 0 3
124784: PPUSH
124785: CALL_OW 297
124789: PUSH
124790: LD_VAR 0 5
124794: LESS
124795: IFFALSE 124739
// end ; ComTurnXY ( unit , x , y ) ;
124797: LD_VAR 0 1
124801: PPUSH
124802: LD_VAR 0 2
124806: PPUSH
124807: LD_VAR 0 3
124811: PPUSH
124812: CALL_OW 118
// wait ( 5 ) ;
124816: LD_INT 5
124818: PPUSH
124819: CALL_OW 67
// _d := GetDir ( unit ) ;
124823: LD_ADDR_VAR 0 10
124827: PUSH
124828: LD_VAR 0 1
124832: PPUSH
124833: CALL_OW 254
124837: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
124838: LD_ADDR_VAR 0 8
124842: PUSH
124843: LD_VAR 0 1
124847: PPUSH
124848: CALL_OW 250
124852: PPUSH
124853: LD_VAR 0 10
124857: PPUSH
124858: LD_VAR 0 5
124862: PPUSH
124863: CALL_OW 272
124867: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
124868: LD_ADDR_VAR 0 9
124872: PUSH
124873: LD_VAR 0 1
124877: PPUSH
124878: CALL_OW 251
124882: PPUSH
124883: LD_VAR 0 10
124887: PPUSH
124888: LD_VAR 0 5
124892: PPUSH
124893: CALL_OW 273
124897: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
124898: LD_VAR 0 8
124902: PPUSH
124903: LD_VAR 0 9
124907: PPUSH
124908: CALL_OW 488
124912: NOT
124913: IFFALSE 124917
// exit ;
124915: GO 125024
// ComAnimCustom ( unit , 1 ) ;
124917: LD_VAR 0 1
124921: PPUSH
124922: LD_INT 1
124924: PPUSH
124925: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
124929: LD_VAR 0 8
124933: PPUSH
124934: LD_VAR 0 9
124938: PPUSH
124939: LD_VAR 0 6
124943: PPUSH
124944: LD_VAR 0 7
124948: PPUSH
124949: CALL_OW 330
// repeat wait ( 1 ) ;
124953: LD_INT 1
124955: PPUSH
124956: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
124960: LD_VAR 0 1
124964: PPUSH
124965: CALL_OW 316
124969: PUSH
124970: LD_VAR 0 1
124974: PPUSH
124975: CALL_OW 314
124979: OR
124980: PUSH
124981: LD_VAR 0 1
124985: PPUSH
124986: CALL_OW 302
124990: NOT
124991: OR
124992: PUSH
124993: LD_VAR 0 1
124997: PPUSH
124998: CALL_OW 301
125002: OR
125003: IFFALSE 124953
// RemoveSeeing ( _x , _y , side ) ;
125005: LD_VAR 0 8
125009: PPUSH
125010: LD_VAR 0 9
125014: PPUSH
125015: LD_VAR 0 6
125019: PPUSH
125020: CALL_OW 331
// end ; end_of_file
125024: LD_VAR 0 4
125028: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
125029: LD_INT 0
125031: PPUSH
125032: PPUSH
125033: PPUSH
125034: PPUSH
125035: PPUSH
125036: PPUSH
125037: PPUSH
125038: PPUSH
125039: PPUSH
125040: PPUSH
125041: PPUSH
125042: PPUSH
125043: PPUSH
125044: PPUSH
125045: PPUSH
125046: PPUSH
125047: PPUSH
125048: PPUSH
125049: PPUSH
125050: PPUSH
125051: PPUSH
125052: PPUSH
125053: PPUSH
125054: PPUSH
125055: PPUSH
125056: PPUSH
125057: PPUSH
125058: PPUSH
125059: PPUSH
125060: PPUSH
125061: PPUSH
125062: PPUSH
125063: PPUSH
125064: PPUSH
// if not list then
125065: LD_VAR 0 1
125069: NOT
125070: IFFALSE 125074
// exit ;
125072: GO 129733
// base := list [ 1 ] ;
125074: LD_ADDR_VAR 0 3
125078: PUSH
125079: LD_VAR 0 1
125083: PUSH
125084: LD_INT 1
125086: ARRAY
125087: ST_TO_ADDR
// group := list [ 2 ] ;
125088: LD_ADDR_VAR 0 4
125092: PUSH
125093: LD_VAR 0 1
125097: PUSH
125098: LD_INT 2
125100: ARRAY
125101: ST_TO_ADDR
// path := list [ 3 ] ;
125102: LD_ADDR_VAR 0 5
125106: PUSH
125107: LD_VAR 0 1
125111: PUSH
125112: LD_INT 3
125114: ARRAY
125115: ST_TO_ADDR
// flags := list [ 4 ] ;
125116: LD_ADDR_VAR 0 6
125120: PUSH
125121: LD_VAR 0 1
125125: PUSH
125126: LD_INT 4
125128: ARRAY
125129: ST_TO_ADDR
// mined := [ ] ;
125130: LD_ADDR_VAR 0 27
125134: PUSH
125135: EMPTY
125136: ST_TO_ADDR
// bombed := [ ] ;
125137: LD_ADDR_VAR 0 28
125141: PUSH
125142: EMPTY
125143: ST_TO_ADDR
// healers := [ ] ;
125144: LD_ADDR_VAR 0 31
125148: PUSH
125149: EMPTY
125150: ST_TO_ADDR
// to_heal := [ ] ;
125151: LD_ADDR_VAR 0 30
125155: PUSH
125156: EMPTY
125157: ST_TO_ADDR
// repairs := [ ] ;
125158: LD_ADDR_VAR 0 33
125162: PUSH
125163: EMPTY
125164: ST_TO_ADDR
// to_repair := [ ] ;
125165: LD_ADDR_VAR 0 32
125169: PUSH
125170: EMPTY
125171: ST_TO_ADDR
// if not group or not path then
125172: LD_VAR 0 4
125176: NOT
125177: PUSH
125178: LD_VAR 0 5
125182: NOT
125183: OR
125184: IFFALSE 125188
// exit ;
125186: GO 129733
// side := GetSide ( group [ 1 ] ) ;
125188: LD_ADDR_VAR 0 35
125192: PUSH
125193: LD_VAR 0 4
125197: PUSH
125198: LD_INT 1
125200: ARRAY
125201: PPUSH
125202: CALL_OW 255
125206: ST_TO_ADDR
// if flags then
125207: LD_VAR 0 6
125211: IFFALSE 125355
// begin f_ignore_area := flags [ 1 ] ;
125213: LD_ADDR_VAR 0 17
125217: PUSH
125218: LD_VAR 0 6
125222: PUSH
125223: LD_INT 1
125225: ARRAY
125226: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
125227: LD_ADDR_VAR 0 18
125231: PUSH
125232: LD_VAR 0 6
125236: PUSH
125237: LD_INT 2
125239: ARRAY
125240: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
125241: LD_ADDR_VAR 0 19
125245: PUSH
125246: LD_VAR 0 6
125250: PUSH
125251: LD_INT 3
125253: ARRAY
125254: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
125255: LD_ADDR_VAR 0 20
125259: PUSH
125260: LD_VAR 0 6
125264: PUSH
125265: LD_INT 4
125267: ARRAY
125268: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
125269: LD_ADDR_VAR 0 21
125273: PUSH
125274: LD_VAR 0 6
125278: PUSH
125279: LD_INT 5
125281: ARRAY
125282: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
125283: LD_ADDR_VAR 0 22
125287: PUSH
125288: LD_VAR 0 6
125292: PUSH
125293: LD_INT 6
125295: ARRAY
125296: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
125297: LD_ADDR_VAR 0 23
125301: PUSH
125302: LD_VAR 0 6
125306: PUSH
125307: LD_INT 7
125309: ARRAY
125310: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
125311: LD_ADDR_VAR 0 24
125315: PUSH
125316: LD_VAR 0 6
125320: PUSH
125321: LD_INT 8
125323: ARRAY
125324: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
125325: LD_ADDR_VAR 0 25
125329: PUSH
125330: LD_VAR 0 6
125334: PUSH
125335: LD_INT 9
125337: ARRAY
125338: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
125339: LD_ADDR_VAR 0 26
125343: PUSH
125344: LD_VAR 0 6
125348: PUSH
125349: LD_INT 10
125351: ARRAY
125352: ST_TO_ADDR
// end else
125353: GO 125435
// begin f_ignore_area := false ;
125355: LD_ADDR_VAR 0 17
125359: PUSH
125360: LD_INT 0
125362: ST_TO_ADDR
// f_capture := false ;
125363: LD_ADDR_VAR 0 18
125367: PUSH
125368: LD_INT 0
125370: ST_TO_ADDR
// f_ignore_civ := false ;
125371: LD_ADDR_VAR 0 19
125375: PUSH
125376: LD_INT 0
125378: ST_TO_ADDR
// f_murder := false ;
125379: LD_ADDR_VAR 0 20
125383: PUSH
125384: LD_INT 0
125386: ST_TO_ADDR
// f_mines := false ;
125387: LD_ADDR_VAR 0 21
125391: PUSH
125392: LD_INT 0
125394: ST_TO_ADDR
// f_repair := false ;
125395: LD_ADDR_VAR 0 22
125399: PUSH
125400: LD_INT 0
125402: ST_TO_ADDR
// f_heal := false ;
125403: LD_ADDR_VAR 0 23
125407: PUSH
125408: LD_INT 0
125410: ST_TO_ADDR
// f_spacetime := false ;
125411: LD_ADDR_VAR 0 24
125415: PUSH
125416: LD_INT 0
125418: ST_TO_ADDR
// f_attack_depot := false ;
125419: LD_ADDR_VAR 0 25
125423: PUSH
125424: LD_INT 0
125426: ST_TO_ADDR
// f_crawl := false ;
125427: LD_ADDR_VAR 0 26
125431: PUSH
125432: LD_INT 0
125434: ST_TO_ADDR
// end ; if f_heal then
125435: LD_VAR 0 23
125439: IFFALSE 125466
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
125441: LD_ADDR_VAR 0 31
125445: PUSH
125446: LD_VAR 0 4
125450: PPUSH
125451: LD_INT 25
125453: PUSH
125454: LD_INT 4
125456: PUSH
125457: EMPTY
125458: LIST
125459: LIST
125460: PPUSH
125461: CALL_OW 72
125465: ST_TO_ADDR
// if f_repair then
125466: LD_VAR 0 22
125470: IFFALSE 125497
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
125472: LD_ADDR_VAR 0 33
125476: PUSH
125477: LD_VAR 0 4
125481: PPUSH
125482: LD_INT 25
125484: PUSH
125485: LD_INT 3
125487: PUSH
125488: EMPTY
125489: LIST
125490: LIST
125491: PPUSH
125492: CALL_OW 72
125496: ST_TO_ADDR
// units_path := [ ] ;
125497: LD_ADDR_VAR 0 16
125501: PUSH
125502: EMPTY
125503: ST_TO_ADDR
// for i = 1 to group do
125504: LD_ADDR_VAR 0 7
125508: PUSH
125509: DOUBLE
125510: LD_INT 1
125512: DEC
125513: ST_TO_ADDR
125514: LD_VAR 0 4
125518: PUSH
125519: FOR_TO
125520: IFFALSE 125549
// units_path := Replace ( units_path , i , path ) ;
125522: LD_ADDR_VAR 0 16
125526: PUSH
125527: LD_VAR 0 16
125531: PPUSH
125532: LD_VAR 0 7
125536: PPUSH
125537: LD_VAR 0 5
125541: PPUSH
125542: CALL_OW 1
125546: ST_TO_ADDR
125547: GO 125519
125549: POP
125550: POP
// repeat for i = group downto 1 do
125551: LD_ADDR_VAR 0 7
125555: PUSH
125556: DOUBLE
125557: LD_VAR 0 4
125561: INC
125562: ST_TO_ADDR
125563: LD_INT 1
125565: PUSH
125566: FOR_DOWNTO
125567: IFFALSE 129689
// begin wait ( 5 ) ;
125569: LD_INT 5
125571: PPUSH
125572: CALL_OW 67
// tmp := [ ] ;
125576: LD_ADDR_VAR 0 14
125580: PUSH
125581: EMPTY
125582: ST_TO_ADDR
// attacking := false ;
125583: LD_ADDR_VAR 0 29
125587: PUSH
125588: LD_INT 0
125590: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
125591: LD_VAR 0 4
125595: PUSH
125596: LD_VAR 0 7
125600: ARRAY
125601: PPUSH
125602: CALL_OW 301
125606: PUSH
125607: LD_VAR 0 4
125611: PUSH
125612: LD_VAR 0 7
125616: ARRAY
125617: NOT
125618: OR
125619: IFFALSE 125728
// begin if GetType ( group [ i ] ) = unit_human then
125621: LD_VAR 0 4
125625: PUSH
125626: LD_VAR 0 7
125630: ARRAY
125631: PPUSH
125632: CALL_OW 247
125636: PUSH
125637: LD_INT 1
125639: EQUAL
125640: IFFALSE 125686
// begin to_heal := to_heal diff group [ i ] ;
125642: LD_ADDR_VAR 0 30
125646: PUSH
125647: LD_VAR 0 30
125651: PUSH
125652: LD_VAR 0 4
125656: PUSH
125657: LD_VAR 0 7
125661: ARRAY
125662: DIFF
125663: ST_TO_ADDR
// healers := healers diff group [ i ] ;
125664: LD_ADDR_VAR 0 31
125668: PUSH
125669: LD_VAR 0 31
125673: PUSH
125674: LD_VAR 0 4
125678: PUSH
125679: LD_VAR 0 7
125683: ARRAY
125684: DIFF
125685: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
125686: LD_ADDR_VAR 0 4
125690: PUSH
125691: LD_VAR 0 4
125695: PPUSH
125696: LD_VAR 0 7
125700: PPUSH
125701: CALL_OW 3
125705: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
125706: LD_ADDR_VAR 0 16
125710: PUSH
125711: LD_VAR 0 16
125715: PPUSH
125716: LD_VAR 0 7
125720: PPUSH
125721: CALL_OW 3
125725: ST_TO_ADDR
// continue ;
125726: GO 125566
// end ; if f_repair then
125728: LD_VAR 0 22
125732: IFFALSE 126221
// begin if GetType ( group [ i ] ) = unit_vehicle then
125734: LD_VAR 0 4
125738: PUSH
125739: LD_VAR 0 7
125743: ARRAY
125744: PPUSH
125745: CALL_OW 247
125749: PUSH
125750: LD_INT 2
125752: EQUAL
125753: IFFALSE 125943
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
125755: LD_VAR 0 4
125759: PUSH
125760: LD_VAR 0 7
125764: ARRAY
125765: PPUSH
125766: CALL_OW 256
125770: PUSH
125771: LD_INT 700
125773: LESS
125774: PUSH
125775: LD_VAR 0 4
125779: PUSH
125780: LD_VAR 0 7
125784: ARRAY
125785: PUSH
125786: LD_VAR 0 32
125790: IN
125791: NOT
125792: AND
125793: IFFALSE 125817
// to_repair := to_repair union group [ i ] ;
125795: LD_ADDR_VAR 0 32
125799: PUSH
125800: LD_VAR 0 32
125804: PUSH
125805: LD_VAR 0 4
125809: PUSH
125810: LD_VAR 0 7
125814: ARRAY
125815: UNION
125816: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
125817: LD_VAR 0 4
125821: PUSH
125822: LD_VAR 0 7
125826: ARRAY
125827: PPUSH
125828: CALL_OW 256
125832: PUSH
125833: LD_INT 1000
125835: EQUAL
125836: PUSH
125837: LD_VAR 0 4
125841: PUSH
125842: LD_VAR 0 7
125846: ARRAY
125847: PUSH
125848: LD_VAR 0 32
125852: IN
125853: AND
125854: IFFALSE 125878
// to_repair := to_repair diff group [ i ] ;
125856: LD_ADDR_VAR 0 32
125860: PUSH
125861: LD_VAR 0 32
125865: PUSH
125866: LD_VAR 0 4
125870: PUSH
125871: LD_VAR 0 7
125875: ARRAY
125876: DIFF
125877: ST_TO_ADDR
// if group [ i ] in to_repair then
125878: LD_VAR 0 4
125882: PUSH
125883: LD_VAR 0 7
125887: ARRAY
125888: PUSH
125889: LD_VAR 0 32
125893: IN
125894: IFFALSE 125941
// begin if not IsInArea ( group [ i ] , f_repair ) then
125896: LD_VAR 0 4
125900: PUSH
125901: LD_VAR 0 7
125905: ARRAY
125906: PPUSH
125907: LD_VAR 0 22
125911: PPUSH
125912: CALL_OW 308
125916: NOT
125917: IFFALSE 125939
// ComMoveToArea ( group [ i ] , f_repair ) ;
125919: LD_VAR 0 4
125923: PUSH
125924: LD_VAR 0 7
125928: ARRAY
125929: PPUSH
125930: LD_VAR 0 22
125934: PPUSH
125935: CALL_OW 113
// continue ;
125939: GO 125566
// end ; end else
125941: GO 126221
// if group [ i ] in repairs then
125943: LD_VAR 0 4
125947: PUSH
125948: LD_VAR 0 7
125952: ARRAY
125953: PUSH
125954: LD_VAR 0 33
125958: IN
125959: IFFALSE 126221
// begin if IsInUnit ( group [ i ] ) then
125961: LD_VAR 0 4
125965: PUSH
125966: LD_VAR 0 7
125970: ARRAY
125971: PPUSH
125972: CALL_OW 310
125976: IFFALSE 126044
// begin z := IsInUnit ( group [ i ] ) ;
125978: LD_ADDR_VAR 0 13
125982: PUSH
125983: LD_VAR 0 4
125987: PUSH
125988: LD_VAR 0 7
125992: ARRAY
125993: PPUSH
125994: CALL_OW 310
125998: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
125999: LD_VAR 0 13
126003: PUSH
126004: LD_VAR 0 32
126008: IN
126009: PUSH
126010: LD_VAR 0 13
126014: PPUSH
126015: LD_VAR 0 22
126019: PPUSH
126020: CALL_OW 308
126024: AND
126025: IFFALSE 126042
// ComExitVehicle ( group [ i ] ) ;
126027: LD_VAR 0 4
126031: PUSH
126032: LD_VAR 0 7
126036: ARRAY
126037: PPUSH
126038: CALL_OW 121
// end else
126042: GO 126221
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
126044: LD_ADDR_VAR 0 13
126048: PUSH
126049: LD_VAR 0 4
126053: PPUSH
126054: LD_INT 95
126056: PUSH
126057: LD_VAR 0 22
126061: PUSH
126062: EMPTY
126063: LIST
126064: LIST
126065: PUSH
126066: LD_INT 58
126068: PUSH
126069: EMPTY
126070: LIST
126071: PUSH
126072: EMPTY
126073: LIST
126074: LIST
126075: PPUSH
126076: CALL_OW 72
126080: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
126081: LD_VAR 0 4
126085: PUSH
126086: LD_VAR 0 7
126090: ARRAY
126091: PPUSH
126092: CALL_OW 314
126096: NOT
126097: IFFALSE 126219
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
126099: LD_ADDR_VAR 0 10
126103: PUSH
126104: LD_VAR 0 13
126108: PPUSH
126109: LD_VAR 0 4
126113: PUSH
126114: LD_VAR 0 7
126118: ARRAY
126119: PPUSH
126120: CALL_OW 74
126124: ST_TO_ADDR
// if not x then
126125: LD_VAR 0 10
126129: NOT
126130: IFFALSE 126134
// continue ;
126132: GO 125566
// if GetLives ( x ) < 1000 then
126134: LD_VAR 0 10
126138: PPUSH
126139: CALL_OW 256
126143: PUSH
126144: LD_INT 1000
126146: LESS
126147: IFFALSE 126171
// ComRepairVehicle ( group [ i ] , x ) else
126149: LD_VAR 0 4
126153: PUSH
126154: LD_VAR 0 7
126158: ARRAY
126159: PPUSH
126160: LD_VAR 0 10
126164: PPUSH
126165: CALL_OW 129
126169: GO 126219
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
126171: LD_VAR 0 23
126175: PUSH
126176: LD_VAR 0 4
126180: PUSH
126181: LD_VAR 0 7
126185: ARRAY
126186: PPUSH
126187: CALL_OW 256
126191: PUSH
126192: LD_INT 1000
126194: LESS
126195: AND
126196: NOT
126197: IFFALSE 126219
// ComEnterUnit ( group [ i ] , x ) ;
126199: LD_VAR 0 4
126203: PUSH
126204: LD_VAR 0 7
126208: ARRAY
126209: PPUSH
126210: LD_VAR 0 10
126214: PPUSH
126215: CALL_OW 120
// end ; continue ;
126219: GO 125566
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
126221: LD_VAR 0 23
126225: PUSH
126226: LD_VAR 0 4
126230: PUSH
126231: LD_VAR 0 7
126235: ARRAY
126236: PPUSH
126237: CALL_OW 247
126241: PUSH
126242: LD_INT 1
126244: EQUAL
126245: AND
126246: IFFALSE 126724
// begin if group [ i ] in healers then
126248: LD_VAR 0 4
126252: PUSH
126253: LD_VAR 0 7
126257: ARRAY
126258: PUSH
126259: LD_VAR 0 31
126263: IN
126264: IFFALSE 126537
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
126266: LD_VAR 0 4
126270: PUSH
126271: LD_VAR 0 7
126275: ARRAY
126276: PPUSH
126277: LD_VAR 0 23
126281: PPUSH
126282: CALL_OW 308
126286: NOT
126287: PUSH
126288: LD_VAR 0 4
126292: PUSH
126293: LD_VAR 0 7
126297: ARRAY
126298: PPUSH
126299: CALL_OW 314
126303: NOT
126304: AND
126305: IFFALSE 126329
// ComMoveToArea ( group [ i ] , f_heal ) else
126307: LD_VAR 0 4
126311: PUSH
126312: LD_VAR 0 7
126316: ARRAY
126317: PPUSH
126318: LD_VAR 0 23
126322: PPUSH
126323: CALL_OW 113
126327: GO 126535
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
126329: LD_VAR 0 4
126333: PUSH
126334: LD_VAR 0 7
126338: ARRAY
126339: PPUSH
126340: CALL 99982 0 1
126344: PPUSH
126345: CALL_OW 256
126349: PUSH
126350: LD_INT 1000
126352: EQUAL
126353: IFFALSE 126372
// ComStop ( group [ i ] ) else
126355: LD_VAR 0 4
126359: PUSH
126360: LD_VAR 0 7
126364: ARRAY
126365: PPUSH
126366: CALL_OW 141
126370: GO 126535
// if not HasTask ( group [ i ] ) and to_heal then
126372: LD_VAR 0 4
126376: PUSH
126377: LD_VAR 0 7
126381: ARRAY
126382: PPUSH
126383: CALL_OW 314
126387: NOT
126388: PUSH
126389: LD_VAR 0 30
126393: AND
126394: IFFALSE 126535
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
126396: LD_ADDR_VAR 0 13
126400: PUSH
126401: LD_VAR 0 30
126405: PPUSH
126406: LD_INT 3
126408: PUSH
126409: LD_INT 54
126411: PUSH
126412: EMPTY
126413: LIST
126414: PUSH
126415: EMPTY
126416: LIST
126417: LIST
126418: PPUSH
126419: CALL_OW 72
126423: PPUSH
126424: LD_VAR 0 4
126428: PUSH
126429: LD_VAR 0 7
126433: ARRAY
126434: PPUSH
126435: CALL_OW 74
126439: ST_TO_ADDR
// if z then
126440: LD_VAR 0 13
126444: IFFALSE 126535
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
126446: LD_INT 91
126448: PUSH
126449: LD_VAR 0 13
126453: PUSH
126454: LD_INT 10
126456: PUSH
126457: EMPTY
126458: LIST
126459: LIST
126460: LIST
126461: PUSH
126462: LD_INT 81
126464: PUSH
126465: LD_VAR 0 13
126469: PPUSH
126470: CALL_OW 255
126474: PUSH
126475: EMPTY
126476: LIST
126477: LIST
126478: PUSH
126479: EMPTY
126480: LIST
126481: LIST
126482: PPUSH
126483: CALL_OW 69
126487: PUSH
126488: LD_INT 0
126490: EQUAL
126491: IFFALSE 126515
// ComHeal ( group [ i ] , z ) else
126493: LD_VAR 0 4
126497: PUSH
126498: LD_VAR 0 7
126502: ARRAY
126503: PPUSH
126504: LD_VAR 0 13
126508: PPUSH
126509: CALL_OW 128
126513: GO 126535
// ComMoveToArea ( group [ i ] , f_heal ) ;
126515: LD_VAR 0 4
126519: PUSH
126520: LD_VAR 0 7
126524: ARRAY
126525: PPUSH
126526: LD_VAR 0 23
126530: PPUSH
126531: CALL_OW 113
// end ; continue ;
126535: GO 125566
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
126537: LD_VAR 0 4
126541: PUSH
126542: LD_VAR 0 7
126546: ARRAY
126547: PPUSH
126548: CALL_OW 256
126552: PUSH
126553: LD_INT 700
126555: LESS
126556: PUSH
126557: LD_VAR 0 4
126561: PUSH
126562: LD_VAR 0 7
126566: ARRAY
126567: PUSH
126568: LD_VAR 0 30
126572: IN
126573: NOT
126574: AND
126575: IFFALSE 126599
// to_heal := to_heal union group [ i ] ;
126577: LD_ADDR_VAR 0 30
126581: PUSH
126582: LD_VAR 0 30
126586: PUSH
126587: LD_VAR 0 4
126591: PUSH
126592: LD_VAR 0 7
126596: ARRAY
126597: UNION
126598: ST_TO_ADDR
// if group [ i ] in to_heal then
126599: LD_VAR 0 4
126603: PUSH
126604: LD_VAR 0 7
126608: ARRAY
126609: PUSH
126610: LD_VAR 0 30
126614: IN
126615: IFFALSE 126724
// begin if GetLives ( group [ i ] ) = 1000 then
126617: LD_VAR 0 4
126621: PUSH
126622: LD_VAR 0 7
126626: ARRAY
126627: PPUSH
126628: CALL_OW 256
126632: PUSH
126633: LD_INT 1000
126635: EQUAL
126636: IFFALSE 126662
// to_heal := to_heal diff group [ i ] else
126638: LD_ADDR_VAR 0 30
126642: PUSH
126643: LD_VAR 0 30
126647: PUSH
126648: LD_VAR 0 4
126652: PUSH
126653: LD_VAR 0 7
126657: ARRAY
126658: DIFF
126659: ST_TO_ADDR
126660: GO 126724
// begin if not IsInArea ( group [ i ] , to_heal ) then
126662: LD_VAR 0 4
126666: PUSH
126667: LD_VAR 0 7
126671: ARRAY
126672: PPUSH
126673: LD_VAR 0 30
126677: PPUSH
126678: CALL_OW 308
126682: NOT
126683: IFFALSE 126707
// ComMoveToArea ( group [ i ] , f_heal ) else
126685: LD_VAR 0 4
126689: PUSH
126690: LD_VAR 0 7
126694: ARRAY
126695: PPUSH
126696: LD_VAR 0 23
126700: PPUSH
126701: CALL_OW 113
126705: GO 126722
// ComHold ( group [ i ] ) ;
126707: LD_VAR 0 4
126711: PUSH
126712: LD_VAR 0 7
126716: ARRAY
126717: PPUSH
126718: CALL_OW 140
// continue ;
126722: GO 125566
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
126724: LD_VAR 0 4
126728: PUSH
126729: LD_VAR 0 7
126733: ARRAY
126734: PPUSH
126735: LD_INT 10
126737: PPUSH
126738: CALL 98402 0 2
126742: NOT
126743: PUSH
126744: LD_VAR 0 16
126748: PUSH
126749: LD_VAR 0 7
126753: ARRAY
126754: PUSH
126755: EMPTY
126756: EQUAL
126757: NOT
126758: AND
126759: IFFALSE 127025
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
126761: LD_VAR 0 4
126765: PUSH
126766: LD_VAR 0 7
126770: ARRAY
126771: PPUSH
126772: CALL_OW 262
126776: PUSH
126777: LD_INT 1
126779: PUSH
126780: LD_INT 2
126782: PUSH
126783: EMPTY
126784: LIST
126785: LIST
126786: IN
126787: IFFALSE 126828
// if GetFuel ( group [ i ] ) < 10 then
126789: LD_VAR 0 4
126793: PUSH
126794: LD_VAR 0 7
126798: ARRAY
126799: PPUSH
126800: CALL_OW 261
126804: PUSH
126805: LD_INT 10
126807: LESS
126808: IFFALSE 126828
// SetFuel ( group [ i ] , 12 ) ;
126810: LD_VAR 0 4
126814: PUSH
126815: LD_VAR 0 7
126819: ARRAY
126820: PPUSH
126821: LD_INT 12
126823: PPUSH
126824: CALL_OW 240
// if units_path [ i ] then
126828: LD_VAR 0 16
126832: PUSH
126833: LD_VAR 0 7
126837: ARRAY
126838: IFFALSE 127023
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
126840: LD_VAR 0 4
126844: PUSH
126845: LD_VAR 0 7
126849: ARRAY
126850: PPUSH
126851: LD_VAR 0 16
126855: PUSH
126856: LD_VAR 0 7
126860: ARRAY
126861: PUSH
126862: LD_INT 1
126864: ARRAY
126865: PUSH
126866: LD_INT 1
126868: ARRAY
126869: PPUSH
126870: LD_VAR 0 16
126874: PUSH
126875: LD_VAR 0 7
126879: ARRAY
126880: PUSH
126881: LD_INT 1
126883: ARRAY
126884: PUSH
126885: LD_INT 2
126887: ARRAY
126888: PPUSH
126889: CALL_OW 297
126893: PUSH
126894: LD_INT 6
126896: GREATER
126897: IFFALSE 126972
// begin if not HasTask ( group [ i ] ) then
126899: LD_VAR 0 4
126903: PUSH
126904: LD_VAR 0 7
126908: ARRAY
126909: PPUSH
126910: CALL_OW 314
126914: NOT
126915: IFFALSE 126970
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
126917: LD_VAR 0 4
126921: PUSH
126922: LD_VAR 0 7
126926: ARRAY
126927: PPUSH
126928: LD_VAR 0 16
126932: PUSH
126933: LD_VAR 0 7
126937: ARRAY
126938: PUSH
126939: LD_INT 1
126941: ARRAY
126942: PUSH
126943: LD_INT 1
126945: ARRAY
126946: PPUSH
126947: LD_VAR 0 16
126951: PUSH
126952: LD_VAR 0 7
126956: ARRAY
126957: PUSH
126958: LD_INT 1
126960: ARRAY
126961: PUSH
126962: LD_INT 2
126964: ARRAY
126965: PPUSH
126966: CALL_OW 114
// end else
126970: GO 127023
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
126972: LD_ADDR_VAR 0 15
126976: PUSH
126977: LD_VAR 0 16
126981: PUSH
126982: LD_VAR 0 7
126986: ARRAY
126987: PPUSH
126988: LD_INT 1
126990: PPUSH
126991: CALL_OW 3
126995: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
126996: LD_ADDR_VAR 0 16
127000: PUSH
127001: LD_VAR 0 16
127005: PPUSH
127006: LD_VAR 0 7
127010: PPUSH
127011: LD_VAR 0 15
127015: PPUSH
127016: CALL_OW 1
127020: ST_TO_ADDR
// continue ;
127021: GO 125566
// end ; end ; end else
127023: GO 129687
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
127025: LD_ADDR_VAR 0 14
127029: PUSH
127030: LD_INT 81
127032: PUSH
127033: LD_VAR 0 4
127037: PUSH
127038: LD_VAR 0 7
127042: ARRAY
127043: PPUSH
127044: CALL_OW 255
127048: PUSH
127049: EMPTY
127050: LIST
127051: LIST
127052: PPUSH
127053: CALL_OW 69
127057: ST_TO_ADDR
// if not tmp then
127058: LD_VAR 0 14
127062: NOT
127063: IFFALSE 127067
// continue ;
127065: GO 125566
// if f_ignore_area then
127067: LD_VAR 0 17
127071: IFFALSE 127159
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
127073: LD_ADDR_VAR 0 15
127077: PUSH
127078: LD_VAR 0 14
127082: PPUSH
127083: LD_INT 3
127085: PUSH
127086: LD_INT 92
127088: PUSH
127089: LD_VAR 0 17
127093: PUSH
127094: LD_INT 1
127096: ARRAY
127097: PUSH
127098: LD_VAR 0 17
127102: PUSH
127103: LD_INT 2
127105: ARRAY
127106: PUSH
127107: LD_VAR 0 17
127111: PUSH
127112: LD_INT 3
127114: ARRAY
127115: PUSH
127116: EMPTY
127117: LIST
127118: LIST
127119: LIST
127120: LIST
127121: PUSH
127122: EMPTY
127123: LIST
127124: LIST
127125: PPUSH
127126: CALL_OW 72
127130: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
127131: LD_VAR 0 14
127135: PUSH
127136: LD_VAR 0 15
127140: DIFF
127141: IFFALSE 127159
// tmp := tmp diff tmp2 ;
127143: LD_ADDR_VAR 0 14
127147: PUSH
127148: LD_VAR 0 14
127152: PUSH
127153: LD_VAR 0 15
127157: DIFF
127158: ST_TO_ADDR
// end ; if not f_murder then
127159: LD_VAR 0 20
127163: NOT
127164: IFFALSE 127222
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
127166: LD_ADDR_VAR 0 15
127170: PUSH
127171: LD_VAR 0 14
127175: PPUSH
127176: LD_INT 3
127178: PUSH
127179: LD_INT 50
127181: PUSH
127182: EMPTY
127183: LIST
127184: PUSH
127185: EMPTY
127186: LIST
127187: LIST
127188: PPUSH
127189: CALL_OW 72
127193: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
127194: LD_VAR 0 14
127198: PUSH
127199: LD_VAR 0 15
127203: DIFF
127204: IFFALSE 127222
// tmp := tmp diff tmp2 ;
127206: LD_ADDR_VAR 0 14
127210: PUSH
127211: LD_VAR 0 14
127215: PUSH
127216: LD_VAR 0 15
127220: DIFF
127221: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
127222: LD_ADDR_VAR 0 14
127226: PUSH
127227: LD_VAR 0 4
127231: PUSH
127232: LD_VAR 0 7
127236: ARRAY
127237: PPUSH
127238: LD_VAR 0 14
127242: PPUSH
127243: LD_INT 1
127245: PPUSH
127246: LD_INT 1
127248: PPUSH
127249: CALL 71337 0 4
127253: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
127254: LD_VAR 0 4
127258: PUSH
127259: LD_VAR 0 7
127263: ARRAY
127264: PPUSH
127265: CALL_OW 257
127269: PUSH
127270: LD_INT 1
127272: EQUAL
127273: IFFALSE 127721
// begin if WantPlant ( group [ i ] ) then
127275: LD_VAR 0 4
127279: PUSH
127280: LD_VAR 0 7
127284: ARRAY
127285: PPUSH
127286: CALL 70838 0 1
127290: IFFALSE 127294
// continue ;
127292: GO 125566
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
127294: LD_VAR 0 18
127298: PUSH
127299: LD_VAR 0 4
127303: PUSH
127304: LD_VAR 0 7
127308: ARRAY
127309: PPUSH
127310: CALL_OW 310
127314: NOT
127315: AND
127316: PUSH
127317: LD_VAR 0 14
127321: PUSH
127322: LD_INT 1
127324: ARRAY
127325: PUSH
127326: LD_VAR 0 14
127330: PPUSH
127331: LD_INT 21
127333: PUSH
127334: LD_INT 2
127336: PUSH
127337: EMPTY
127338: LIST
127339: LIST
127340: PUSH
127341: LD_INT 58
127343: PUSH
127344: EMPTY
127345: LIST
127346: PUSH
127347: EMPTY
127348: LIST
127349: LIST
127350: PPUSH
127351: CALL_OW 72
127355: IN
127356: AND
127357: IFFALSE 127393
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
127359: LD_VAR 0 4
127363: PUSH
127364: LD_VAR 0 7
127368: ARRAY
127369: PPUSH
127370: LD_VAR 0 14
127374: PUSH
127375: LD_INT 1
127377: ARRAY
127378: PPUSH
127379: CALL_OW 120
// attacking := true ;
127383: LD_ADDR_VAR 0 29
127387: PUSH
127388: LD_INT 1
127390: ST_TO_ADDR
// continue ;
127391: GO 125566
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
127393: LD_VAR 0 26
127397: PUSH
127398: LD_VAR 0 4
127402: PUSH
127403: LD_VAR 0 7
127407: ARRAY
127408: PPUSH
127409: CALL_OW 257
127413: PUSH
127414: LD_INT 1
127416: EQUAL
127417: AND
127418: PUSH
127419: LD_VAR 0 4
127423: PUSH
127424: LD_VAR 0 7
127428: ARRAY
127429: PPUSH
127430: CALL_OW 256
127434: PUSH
127435: LD_INT 800
127437: LESS
127438: AND
127439: PUSH
127440: LD_VAR 0 4
127444: PUSH
127445: LD_VAR 0 7
127449: ARRAY
127450: PPUSH
127451: CALL_OW 318
127455: NOT
127456: AND
127457: IFFALSE 127474
// ComCrawl ( group [ i ] ) ;
127459: LD_VAR 0 4
127463: PUSH
127464: LD_VAR 0 7
127468: ARRAY
127469: PPUSH
127470: CALL_OW 137
// if f_mines then
127474: LD_VAR 0 21
127478: IFFALSE 127721
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
127480: LD_VAR 0 14
127484: PUSH
127485: LD_INT 1
127487: ARRAY
127488: PPUSH
127489: CALL_OW 247
127493: PUSH
127494: LD_INT 3
127496: EQUAL
127497: PUSH
127498: LD_VAR 0 14
127502: PUSH
127503: LD_INT 1
127505: ARRAY
127506: PUSH
127507: LD_VAR 0 27
127511: IN
127512: NOT
127513: AND
127514: IFFALSE 127721
// begin x := GetX ( tmp [ 1 ] ) ;
127516: LD_ADDR_VAR 0 10
127520: PUSH
127521: LD_VAR 0 14
127525: PUSH
127526: LD_INT 1
127528: ARRAY
127529: PPUSH
127530: CALL_OW 250
127534: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
127535: LD_ADDR_VAR 0 11
127539: PUSH
127540: LD_VAR 0 14
127544: PUSH
127545: LD_INT 1
127547: ARRAY
127548: PPUSH
127549: CALL_OW 251
127553: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
127554: LD_ADDR_VAR 0 12
127558: PUSH
127559: LD_VAR 0 4
127563: PUSH
127564: LD_VAR 0 7
127568: ARRAY
127569: PPUSH
127570: CALL 98487 0 1
127574: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
127575: LD_VAR 0 4
127579: PUSH
127580: LD_VAR 0 7
127584: ARRAY
127585: PPUSH
127586: LD_VAR 0 10
127590: PPUSH
127591: LD_VAR 0 11
127595: PPUSH
127596: LD_VAR 0 14
127600: PUSH
127601: LD_INT 1
127603: ARRAY
127604: PPUSH
127605: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
127609: LD_VAR 0 4
127613: PUSH
127614: LD_VAR 0 7
127618: ARRAY
127619: PPUSH
127620: LD_VAR 0 10
127624: PPUSH
127625: LD_VAR 0 12
127629: PPUSH
127630: LD_INT 7
127632: PPUSH
127633: CALL_OW 272
127637: PPUSH
127638: LD_VAR 0 11
127642: PPUSH
127643: LD_VAR 0 12
127647: PPUSH
127648: LD_INT 7
127650: PPUSH
127651: CALL_OW 273
127655: PPUSH
127656: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
127660: LD_VAR 0 4
127664: PUSH
127665: LD_VAR 0 7
127669: ARRAY
127670: PPUSH
127671: LD_INT 71
127673: PPUSH
127674: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
127678: LD_ADDR_VAR 0 27
127682: PUSH
127683: LD_VAR 0 27
127687: PPUSH
127688: LD_VAR 0 27
127692: PUSH
127693: LD_INT 1
127695: PLUS
127696: PPUSH
127697: LD_VAR 0 14
127701: PUSH
127702: LD_INT 1
127704: ARRAY
127705: PPUSH
127706: CALL_OW 1
127710: ST_TO_ADDR
// attacking := true ;
127711: LD_ADDR_VAR 0 29
127715: PUSH
127716: LD_INT 1
127718: ST_TO_ADDR
// continue ;
127719: GO 125566
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
127721: LD_VAR 0 4
127725: PUSH
127726: LD_VAR 0 7
127730: ARRAY
127731: PPUSH
127732: CALL_OW 257
127736: PUSH
127737: LD_INT 17
127739: EQUAL
127740: PUSH
127741: LD_VAR 0 4
127745: PUSH
127746: LD_VAR 0 7
127750: ARRAY
127751: PPUSH
127752: CALL_OW 110
127756: PUSH
127757: LD_INT 71
127759: EQUAL
127760: NOT
127761: AND
127762: IFFALSE 127908
// begin attacking := false ;
127764: LD_ADDR_VAR 0 29
127768: PUSH
127769: LD_INT 0
127771: ST_TO_ADDR
// k := 5 ;
127772: LD_ADDR_VAR 0 9
127776: PUSH
127777: LD_INT 5
127779: ST_TO_ADDR
// if tmp < k then
127780: LD_VAR 0 14
127784: PUSH
127785: LD_VAR 0 9
127789: LESS
127790: IFFALSE 127802
// k := tmp ;
127792: LD_ADDR_VAR 0 9
127796: PUSH
127797: LD_VAR 0 14
127801: ST_TO_ADDR
// for j = 1 to k do
127802: LD_ADDR_VAR 0 8
127806: PUSH
127807: DOUBLE
127808: LD_INT 1
127810: DEC
127811: ST_TO_ADDR
127812: LD_VAR 0 9
127816: PUSH
127817: FOR_TO
127818: IFFALSE 127906
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
127820: LD_VAR 0 14
127824: PUSH
127825: LD_VAR 0 8
127829: ARRAY
127830: PUSH
127831: LD_VAR 0 14
127835: PPUSH
127836: LD_INT 58
127838: PUSH
127839: EMPTY
127840: LIST
127841: PPUSH
127842: CALL_OW 72
127846: IN
127847: NOT
127848: IFFALSE 127904
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
127850: LD_VAR 0 4
127854: PUSH
127855: LD_VAR 0 7
127859: ARRAY
127860: PPUSH
127861: LD_VAR 0 14
127865: PUSH
127866: LD_VAR 0 8
127870: ARRAY
127871: PPUSH
127872: CALL_OW 115
// attacking := true ;
127876: LD_ADDR_VAR 0 29
127880: PUSH
127881: LD_INT 1
127883: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
127884: LD_VAR 0 4
127888: PUSH
127889: LD_VAR 0 7
127893: ARRAY
127894: PPUSH
127895: LD_INT 71
127897: PPUSH
127898: CALL_OW 109
// continue ;
127902: GO 127817
// end ; end ;
127904: GO 127817
127906: POP
127907: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
127908: LD_VAR 0 4
127912: PUSH
127913: LD_VAR 0 7
127917: ARRAY
127918: PPUSH
127919: CALL_OW 257
127923: PUSH
127924: LD_INT 8
127926: EQUAL
127927: PUSH
127928: LD_VAR 0 4
127932: PUSH
127933: LD_VAR 0 7
127937: ARRAY
127938: PPUSH
127939: CALL_OW 264
127943: PUSH
127944: LD_INT 28
127946: PUSH
127947: LD_INT 45
127949: PUSH
127950: LD_INT 7
127952: PUSH
127953: LD_INT 47
127955: PUSH
127956: EMPTY
127957: LIST
127958: LIST
127959: LIST
127960: LIST
127961: IN
127962: OR
127963: IFFALSE 128219
// begin attacking := false ;
127965: LD_ADDR_VAR 0 29
127969: PUSH
127970: LD_INT 0
127972: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
127973: LD_VAR 0 14
127977: PUSH
127978: LD_INT 1
127980: ARRAY
127981: PPUSH
127982: CALL_OW 266
127986: PUSH
127987: LD_INT 32
127989: PUSH
127990: LD_INT 31
127992: PUSH
127993: LD_INT 33
127995: PUSH
127996: LD_INT 4
127998: PUSH
127999: LD_INT 5
128001: PUSH
128002: EMPTY
128003: LIST
128004: LIST
128005: LIST
128006: LIST
128007: LIST
128008: IN
128009: IFFALSE 128195
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
128011: LD_ADDR_VAR 0 9
128015: PUSH
128016: LD_VAR 0 14
128020: PUSH
128021: LD_INT 1
128023: ARRAY
128024: PPUSH
128025: CALL_OW 266
128029: PPUSH
128030: LD_VAR 0 14
128034: PUSH
128035: LD_INT 1
128037: ARRAY
128038: PPUSH
128039: CALL_OW 250
128043: PPUSH
128044: LD_VAR 0 14
128048: PUSH
128049: LD_INT 1
128051: ARRAY
128052: PPUSH
128053: CALL_OW 251
128057: PPUSH
128058: LD_VAR 0 14
128062: PUSH
128063: LD_INT 1
128065: ARRAY
128066: PPUSH
128067: CALL_OW 254
128071: PPUSH
128072: LD_VAR 0 14
128076: PUSH
128077: LD_INT 1
128079: ARRAY
128080: PPUSH
128081: CALL_OW 248
128085: PPUSH
128086: LD_INT 0
128088: PPUSH
128089: CALL 79857 0 6
128093: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
128094: LD_ADDR_VAR 0 8
128098: PUSH
128099: LD_VAR 0 4
128103: PUSH
128104: LD_VAR 0 7
128108: ARRAY
128109: PPUSH
128110: LD_VAR 0 9
128114: PPUSH
128115: CALL 98527 0 2
128119: ST_TO_ADDR
// if j then
128120: LD_VAR 0 8
128124: IFFALSE 128193
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
128126: LD_VAR 0 8
128130: PUSH
128131: LD_INT 1
128133: ARRAY
128134: PPUSH
128135: LD_VAR 0 8
128139: PUSH
128140: LD_INT 2
128142: ARRAY
128143: PPUSH
128144: CALL_OW 488
128148: IFFALSE 128193
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
128150: LD_VAR 0 4
128154: PUSH
128155: LD_VAR 0 7
128159: ARRAY
128160: PPUSH
128161: LD_VAR 0 8
128165: PUSH
128166: LD_INT 1
128168: ARRAY
128169: PPUSH
128170: LD_VAR 0 8
128174: PUSH
128175: LD_INT 2
128177: ARRAY
128178: PPUSH
128179: CALL_OW 116
// attacking := true ;
128183: LD_ADDR_VAR 0 29
128187: PUSH
128188: LD_INT 1
128190: ST_TO_ADDR
// continue ;
128191: GO 125566
// end ; end else
128193: GO 128219
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
128195: LD_VAR 0 4
128199: PUSH
128200: LD_VAR 0 7
128204: ARRAY
128205: PPUSH
128206: LD_VAR 0 14
128210: PUSH
128211: LD_INT 1
128213: ARRAY
128214: PPUSH
128215: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
128219: LD_VAR 0 4
128223: PUSH
128224: LD_VAR 0 7
128228: ARRAY
128229: PPUSH
128230: CALL_OW 265
128234: PUSH
128235: LD_INT 11
128237: EQUAL
128238: IFFALSE 128516
// begin k := 10 ;
128240: LD_ADDR_VAR 0 9
128244: PUSH
128245: LD_INT 10
128247: ST_TO_ADDR
// x := 0 ;
128248: LD_ADDR_VAR 0 10
128252: PUSH
128253: LD_INT 0
128255: ST_TO_ADDR
// if tmp < k then
128256: LD_VAR 0 14
128260: PUSH
128261: LD_VAR 0 9
128265: LESS
128266: IFFALSE 128278
// k := tmp ;
128268: LD_ADDR_VAR 0 9
128272: PUSH
128273: LD_VAR 0 14
128277: ST_TO_ADDR
// for j = k downto 1 do
128278: LD_ADDR_VAR 0 8
128282: PUSH
128283: DOUBLE
128284: LD_VAR 0 9
128288: INC
128289: ST_TO_ADDR
128290: LD_INT 1
128292: PUSH
128293: FOR_DOWNTO
128294: IFFALSE 128369
// begin if GetType ( tmp [ j ] ) = unit_human then
128296: LD_VAR 0 14
128300: PUSH
128301: LD_VAR 0 8
128305: ARRAY
128306: PPUSH
128307: CALL_OW 247
128311: PUSH
128312: LD_INT 1
128314: EQUAL
128315: IFFALSE 128367
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
128317: LD_VAR 0 4
128321: PUSH
128322: LD_VAR 0 7
128326: ARRAY
128327: PPUSH
128328: LD_VAR 0 14
128332: PUSH
128333: LD_VAR 0 8
128337: ARRAY
128338: PPUSH
128339: CALL 98798 0 2
// x := tmp [ j ] ;
128343: LD_ADDR_VAR 0 10
128347: PUSH
128348: LD_VAR 0 14
128352: PUSH
128353: LD_VAR 0 8
128357: ARRAY
128358: ST_TO_ADDR
// attacking := true ;
128359: LD_ADDR_VAR 0 29
128363: PUSH
128364: LD_INT 1
128366: ST_TO_ADDR
// end ; end ;
128367: GO 128293
128369: POP
128370: POP
// if not x then
128371: LD_VAR 0 10
128375: NOT
128376: IFFALSE 128516
// begin attacking := true ;
128378: LD_ADDR_VAR 0 29
128382: PUSH
128383: LD_INT 1
128385: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
128386: LD_VAR 0 4
128390: PUSH
128391: LD_VAR 0 7
128395: ARRAY
128396: PPUSH
128397: CALL_OW 250
128401: PPUSH
128402: LD_VAR 0 4
128406: PUSH
128407: LD_VAR 0 7
128411: ARRAY
128412: PPUSH
128413: CALL_OW 251
128417: PPUSH
128418: CALL_OW 546
128422: PUSH
128423: LD_INT 2
128425: ARRAY
128426: PUSH
128427: LD_VAR 0 14
128431: PUSH
128432: LD_INT 1
128434: ARRAY
128435: PPUSH
128436: CALL_OW 250
128440: PPUSH
128441: LD_VAR 0 14
128445: PUSH
128446: LD_INT 1
128448: ARRAY
128449: PPUSH
128450: CALL_OW 251
128454: PPUSH
128455: CALL_OW 546
128459: PUSH
128460: LD_INT 2
128462: ARRAY
128463: EQUAL
128464: IFFALSE 128492
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
128466: LD_VAR 0 4
128470: PUSH
128471: LD_VAR 0 7
128475: ARRAY
128476: PPUSH
128477: LD_VAR 0 14
128481: PUSH
128482: LD_INT 1
128484: ARRAY
128485: PPUSH
128486: CALL 98798 0 2
128490: GO 128516
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
128492: LD_VAR 0 4
128496: PUSH
128497: LD_VAR 0 7
128501: ARRAY
128502: PPUSH
128503: LD_VAR 0 14
128507: PUSH
128508: LD_INT 1
128510: ARRAY
128511: PPUSH
128512: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
128516: LD_VAR 0 4
128520: PUSH
128521: LD_VAR 0 7
128525: ARRAY
128526: PPUSH
128527: CALL_OW 264
128531: PUSH
128532: LD_INT 29
128534: EQUAL
128535: IFFALSE 128901
// begin if WantsToAttack ( group [ i ] ) in bombed then
128537: LD_VAR 0 4
128541: PUSH
128542: LD_VAR 0 7
128546: ARRAY
128547: PPUSH
128548: CALL_OW 319
128552: PUSH
128553: LD_VAR 0 28
128557: IN
128558: IFFALSE 128562
// continue ;
128560: GO 125566
// k := 8 ;
128562: LD_ADDR_VAR 0 9
128566: PUSH
128567: LD_INT 8
128569: ST_TO_ADDR
// x := 0 ;
128570: LD_ADDR_VAR 0 10
128574: PUSH
128575: LD_INT 0
128577: ST_TO_ADDR
// if tmp < k then
128578: LD_VAR 0 14
128582: PUSH
128583: LD_VAR 0 9
128587: LESS
128588: IFFALSE 128600
// k := tmp ;
128590: LD_ADDR_VAR 0 9
128594: PUSH
128595: LD_VAR 0 14
128599: ST_TO_ADDR
// for j = 1 to k do
128600: LD_ADDR_VAR 0 8
128604: PUSH
128605: DOUBLE
128606: LD_INT 1
128608: DEC
128609: ST_TO_ADDR
128610: LD_VAR 0 9
128614: PUSH
128615: FOR_TO
128616: IFFALSE 128748
// begin if GetType ( tmp [ j ] ) = unit_building then
128618: LD_VAR 0 14
128622: PUSH
128623: LD_VAR 0 8
128627: ARRAY
128628: PPUSH
128629: CALL_OW 247
128633: PUSH
128634: LD_INT 3
128636: EQUAL
128637: IFFALSE 128746
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
128639: LD_VAR 0 14
128643: PUSH
128644: LD_VAR 0 8
128648: ARRAY
128649: PUSH
128650: LD_VAR 0 28
128654: IN
128655: NOT
128656: PUSH
128657: LD_VAR 0 14
128661: PUSH
128662: LD_VAR 0 8
128666: ARRAY
128667: PPUSH
128668: CALL_OW 313
128672: AND
128673: IFFALSE 128746
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
128675: LD_VAR 0 4
128679: PUSH
128680: LD_VAR 0 7
128684: ARRAY
128685: PPUSH
128686: LD_VAR 0 14
128690: PUSH
128691: LD_VAR 0 8
128695: ARRAY
128696: PPUSH
128697: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
128701: LD_ADDR_VAR 0 28
128705: PUSH
128706: LD_VAR 0 28
128710: PPUSH
128711: LD_VAR 0 28
128715: PUSH
128716: LD_INT 1
128718: PLUS
128719: PPUSH
128720: LD_VAR 0 14
128724: PUSH
128725: LD_VAR 0 8
128729: ARRAY
128730: PPUSH
128731: CALL_OW 1
128735: ST_TO_ADDR
// attacking := true ;
128736: LD_ADDR_VAR 0 29
128740: PUSH
128741: LD_INT 1
128743: ST_TO_ADDR
// break ;
128744: GO 128748
// end ; end ;
128746: GO 128615
128748: POP
128749: POP
// if not attacking and f_attack_depot then
128750: LD_VAR 0 29
128754: NOT
128755: PUSH
128756: LD_VAR 0 25
128760: AND
128761: IFFALSE 128856
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
128763: LD_ADDR_VAR 0 13
128767: PUSH
128768: LD_VAR 0 14
128772: PPUSH
128773: LD_INT 2
128775: PUSH
128776: LD_INT 30
128778: PUSH
128779: LD_INT 0
128781: PUSH
128782: EMPTY
128783: LIST
128784: LIST
128785: PUSH
128786: LD_INT 30
128788: PUSH
128789: LD_INT 1
128791: PUSH
128792: EMPTY
128793: LIST
128794: LIST
128795: PUSH
128796: EMPTY
128797: LIST
128798: LIST
128799: LIST
128800: PPUSH
128801: CALL_OW 72
128805: ST_TO_ADDR
// if z then
128806: LD_VAR 0 13
128810: IFFALSE 128856
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
128812: LD_VAR 0 4
128816: PUSH
128817: LD_VAR 0 7
128821: ARRAY
128822: PPUSH
128823: LD_VAR 0 13
128827: PPUSH
128828: LD_VAR 0 4
128832: PUSH
128833: LD_VAR 0 7
128837: ARRAY
128838: PPUSH
128839: CALL_OW 74
128843: PPUSH
128844: CALL_OW 115
// attacking := true ;
128848: LD_ADDR_VAR 0 29
128852: PUSH
128853: LD_INT 1
128855: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
128856: LD_VAR 0 4
128860: PUSH
128861: LD_VAR 0 7
128865: ARRAY
128866: PPUSH
128867: CALL_OW 256
128871: PUSH
128872: LD_INT 500
128874: LESS
128875: IFFALSE 128901
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
128877: LD_VAR 0 4
128881: PUSH
128882: LD_VAR 0 7
128886: ARRAY
128887: PPUSH
128888: LD_VAR 0 14
128892: PUSH
128893: LD_INT 1
128895: ARRAY
128896: PPUSH
128897: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
128901: LD_VAR 0 4
128905: PUSH
128906: LD_VAR 0 7
128910: ARRAY
128911: PPUSH
128912: CALL_OW 264
128916: PUSH
128917: LD_INT 49
128919: EQUAL
128920: IFFALSE 129041
// begin if not HasTask ( group [ i ] ) then
128922: LD_VAR 0 4
128926: PUSH
128927: LD_VAR 0 7
128931: ARRAY
128932: PPUSH
128933: CALL_OW 314
128937: NOT
128938: IFFALSE 129041
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
128940: LD_ADDR_VAR 0 9
128944: PUSH
128945: LD_INT 81
128947: PUSH
128948: LD_VAR 0 4
128952: PUSH
128953: LD_VAR 0 7
128957: ARRAY
128958: PPUSH
128959: CALL_OW 255
128963: PUSH
128964: EMPTY
128965: LIST
128966: LIST
128967: PPUSH
128968: CALL_OW 69
128972: PPUSH
128973: LD_VAR 0 4
128977: PUSH
128978: LD_VAR 0 7
128982: ARRAY
128983: PPUSH
128984: CALL_OW 74
128988: ST_TO_ADDR
// if k then
128989: LD_VAR 0 9
128993: IFFALSE 129041
// if GetDistUnits ( group [ i ] , k ) > 10 then
128995: LD_VAR 0 4
128999: PUSH
129000: LD_VAR 0 7
129004: ARRAY
129005: PPUSH
129006: LD_VAR 0 9
129010: PPUSH
129011: CALL_OW 296
129015: PUSH
129016: LD_INT 10
129018: GREATER
129019: IFFALSE 129041
// ComMoveUnit ( group [ i ] , k ) ;
129021: LD_VAR 0 4
129025: PUSH
129026: LD_VAR 0 7
129030: ARRAY
129031: PPUSH
129032: LD_VAR 0 9
129036: PPUSH
129037: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
129041: LD_VAR 0 4
129045: PUSH
129046: LD_VAR 0 7
129050: ARRAY
129051: PPUSH
129052: CALL_OW 256
129056: PUSH
129057: LD_INT 250
129059: LESS
129060: PUSH
129061: LD_VAR 0 4
129065: PUSH
129066: LD_VAR 0 7
129070: ARRAY
129071: PUSH
129072: LD_INT 21
129074: PUSH
129075: LD_INT 2
129077: PUSH
129078: EMPTY
129079: LIST
129080: LIST
129081: PUSH
129082: LD_INT 23
129084: PUSH
129085: LD_INT 2
129087: PUSH
129088: EMPTY
129089: LIST
129090: LIST
129091: PUSH
129092: EMPTY
129093: LIST
129094: LIST
129095: PPUSH
129096: CALL_OW 69
129100: IN
129101: AND
129102: IFFALSE 129227
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
129104: LD_ADDR_VAR 0 9
129108: PUSH
129109: LD_OWVAR 3
129113: PUSH
129114: LD_VAR 0 4
129118: PUSH
129119: LD_VAR 0 7
129123: ARRAY
129124: DIFF
129125: PPUSH
129126: LD_VAR 0 4
129130: PUSH
129131: LD_VAR 0 7
129135: ARRAY
129136: PPUSH
129137: CALL_OW 74
129141: ST_TO_ADDR
// if not k then
129142: LD_VAR 0 9
129146: NOT
129147: IFFALSE 129151
// continue ;
129149: GO 125566
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
129151: LD_VAR 0 9
129155: PUSH
129156: LD_INT 81
129158: PUSH
129159: LD_VAR 0 4
129163: PUSH
129164: LD_VAR 0 7
129168: ARRAY
129169: PPUSH
129170: CALL_OW 255
129174: PUSH
129175: EMPTY
129176: LIST
129177: LIST
129178: PPUSH
129179: CALL_OW 69
129183: IN
129184: PUSH
129185: LD_VAR 0 9
129189: PPUSH
129190: LD_VAR 0 4
129194: PUSH
129195: LD_VAR 0 7
129199: ARRAY
129200: PPUSH
129201: CALL_OW 296
129205: PUSH
129206: LD_INT 5
129208: LESS
129209: AND
129210: IFFALSE 129227
// ComAutodestruct ( group [ i ] ) ;
129212: LD_VAR 0 4
129216: PUSH
129217: LD_VAR 0 7
129221: ARRAY
129222: PPUSH
129223: CALL 98696 0 1
// end ; if f_attack_depot then
129227: LD_VAR 0 25
129231: IFFALSE 129343
// begin k := 6 ;
129233: LD_ADDR_VAR 0 9
129237: PUSH
129238: LD_INT 6
129240: ST_TO_ADDR
// if tmp < k then
129241: LD_VAR 0 14
129245: PUSH
129246: LD_VAR 0 9
129250: LESS
129251: IFFALSE 129263
// k := tmp ;
129253: LD_ADDR_VAR 0 9
129257: PUSH
129258: LD_VAR 0 14
129262: ST_TO_ADDR
// for j = 1 to k do
129263: LD_ADDR_VAR 0 8
129267: PUSH
129268: DOUBLE
129269: LD_INT 1
129271: DEC
129272: ST_TO_ADDR
129273: LD_VAR 0 9
129277: PUSH
129278: FOR_TO
129279: IFFALSE 129341
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
129281: LD_VAR 0 8
129285: PPUSH
129286: CALL_OW 266
129290: PUSH
129291: LD_INT 0
129293: PUSH
129294: LD_INT 1
129296: PUSH
129297: EMPTY
129298: LIST
129299: LIST
129300: IN
129301: IFFALSE 129339
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
129303: LD_VAR 0 4
129307: PUSH
129308: LD_VAR 0 7
129312: ARRAY
129313: PPUSH
129314: LD_VAR 0 14
129318: PUSH
129319: LD_VAR 0 8
129323: ARRAY
129324: PPUSH
129325: CALL_OW 115
// attacking := true ;
129329: LD_ADDR_VAR 0 29
129333: PUSH
129334: LD_INT 1
129336: ST_TO_ADDR
// break ;
129337: GO 129341
// end ;
129339: GO 129278
129341: POP
129342: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
129343: LD_VAR 0 4
129347: PUSH
129348: LD_VAR 0 7
129352: ARRAY
129353: PPUSH
129354: CALL_OW 302
129358: PUSH
129359: LD_VAR 0 29
129363: NOT
129364: AND
129365: IFFALSE 129687
// begin if GetTag ( group [ i ] ) = 71 then
129367: LD_VAR 0 4
129371: PUSH
129372: LD_VAR 0 7
129376: ARRAY
129377: PPUSH
129378: CALL_OW 110
129382: PUSH
129383: LD_INT 71
129385: EQUAL
129386: IFFALSE 129427
// begin if HasTask ( group [ i ] ) then
129388: LD_VAR 0 4
129392: PUSH
129393: LD_VAR 0 7
129397: ARRAY
129398: PPUSH
129399: CALL_OW 314
129403: IFFALSE 129409
// continue else
129405: GO 125566
129407: GO 129427
// SetTag ( group [ i ] , 0 ) ;
129409: LD_VAR 0 4
129413: PUSH
129414: LD_VAR 0 7
129418: ARRAY
129419: PPUSH
129420: LD_INT 0
129422: PPUSH
129423: CALL_OW 109
// end ; k := 8 ;
129427: LD_ADDR_VAR 0 9
129431: PUSH
129432: LD_INT 8
129434: ST_TO_ADDR
// x := 0 ;
129435: LD_ADDR_VAR 0 10
129439: PUSH
129440: LD_INT 0
129442: ST_TO_ADDR
// if tmp < k then
129443: LD_VAR 0 14
129447: PUSH
129448: LD_VAR 0 9
129452: LESS
129453: IFFALSE 129465
// k := tmp ;
129455: LD_ADDR_VAR 0 9
129459: PUSH
129460: LD_VAR 0 14
129464: ST_TO_ADDR
// for j = 1 to k do
129465: LD_ADDR_VAR 0 8
129469: PUSH
129470: DOUBLE
129471: LD_INT 1
129473: DEC
129474: ST_TO_ADDR
129475: LD_VAR 0 9
129479: PUSH
129480: FOR_TO
129481: IFFALSE 129579
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
129483: LD_VAR 0 14
129487: PUSH
129488: LD_VAR 0 8
129492: ARRAY
129493: PPUSH
129494: CALL_OW 247
129498: PUSH
129499: LD_INT 1
129501: EQUAL
129502: PUSH
129503: LD_VAR 0 14
129507: PUSH
129508: LD_VAR 0 8
129512: ARRAY
129513: PPUSH
129514: CALL_OW 256
129518: PUSH
129519: LD_INT 250
129521: LESS
129522: PUSH
129523: LD_VAR 0 20
129527: AND
129528: PUSH
129529: LD_VAR 0 20
129533: NOT
129534: PUSH
129535: LD_VAR 0 14
129539: PUSH
129540: LD_VAR 0 8
129544: ARRAY
129545: PPUSH
129546: CALL_OW 256
129550: PUSH
129551: LD_INT 250
129553: GREATEREQUAL
129554: AND
129555: OR
129556: AND
129557: IFFALSE 129577
// begin x := tmp [ j ] ;
129559: LD_ADDR_VAR 0 10
129563: PUSH
129564: LD_VAR 0 14
129568: PUSH
129569: LD_VAR 0 8
129573: ARRAY
129574: ST_TO_ADDR
// break ;
129575: GO 129579
// end ;
129577: GO 129480
129579: POP
129580: POP
// if x then
129581: LD_VAR 0 10
129585: IFFALSE 129609
// ComAttackUnit ( group [ i ] , x ) else
129587: LD_VAR 0 4
129591: PUSH
129592: LD_VAR 0 7
129596: ARRAY
129597: PPUSH
129598: LD_VAR 0 10
129602: PPUSH
129603: CALL_OW 115
129607: GO 129633
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
129609: LD_VAR 0 4
129613: PUSH
129614: LD_VAR 0 7
129618: ARRAY
129619: PPUSH
129620: LD_VAR 0 14
129624: PUSH
129625: LD_INT 1
129627: ARRAY
129628: PPUSH
129629: CALL_OW 115
// if not HasTask ( group [ i ] ) then
129633: LD_VAR 0 4
129637: PUSH
129638: LD_VAR 0 7
129642: ARRAY
129643: PPUSH
129644: CALL_OW 314
129648: NOT
129649: IFFALSE 129687
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
129651: LD_VAR 0 4
129655: PUSH
129656: LD_VAR 0 7
129660: ARRAY
129661: PPUSH
129662: LD_VAR 0 14
129666: PPUSH
129667: LD_VAR 0 4
129671: PUSH
129672: LD_VAR 0 7
129676: ARRAY
129677: PPUSH
129678: CALL_OW 74
129682: PPUSH
129683: CALL_OW 115
// end ; end ; end ;
129687: GO 125566
129689: POP
129690: POP
// wait ( 0 0$2 ) ;
129691: LD_INT 70
129693: PPUSH
129694: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
129698: LD_VAR 0 4
129702: NOT
129703: PUSH
129704: LD_VAR 0 4
129708: PUSH
129709: EMPTY
129710: EQUAL
129711: OR
129712: PUSH
129713: LD_INT 81
129715: PUSH
129716: LD_VAR 0 35
129720: PUSH
129721: EMPTY
129722: LIST
129723: LIST
129724: PPUSH
129725: CALL_OW 69
129729: NOT
129730: OR
129731: IFFALSE 125551
// end ;
129733: LD_VAR 0 2
129737: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
129738: LD_INT 0
129740: PPUSH
129741: PPUSH
129742: PPUSH
129743: PPUSH
129744: PPUSH
129745: PPUSH
// if not base or not mc_bases [ base ] or not solds then
129746: LD_VAR 0 1
129750: NOT
129751: PUSH
129752: LD_EXP 117
129756: PUSH
129757: LD_VAR 0 1
129761: ARRAY
129762: NOT
129763: OR
129764: PUSH
129765: LD_VAR 0 2
129769: NOT
129770: OR
129771: IFFALSE 129775
// exit ;
129773: GO 130329
// side := mc_sides [ base ] ;
129775: LD_ADDR_VAR 0 6
129779: PUSH
129780: LD_EXP 143
129784: PUSH
129785: LD_VAR 0 1
129789: ARRAY
129790: ST_TO_ADDR
// if not side then
129791: LD_VAR 0 6
129795: NOT
129796: IFFALSE 129800
// exit ;
129798: GO 130329
// for i in solds do
129800: LD_ADDR_VAR 0 7
129804: PUSH
129805: LD_VAR 0 2
129809: PUSH
129810: FOR_IN
129811: IFFALSE 129872
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
129813: LD_VAR 0 7
129817: PPUSH
129818: CALL_OW 310
129822: PPUSH
129823: CALL_OW 266
129827: PUSH
129828: LD_INT 32
129830: PUSH
129831: LD_INT 31
129833: PUSH
129834: EMPTY
129835: LIST
129836: LIST
129837: IN
129838: IFFALSE 129858
// solds := solds diff i else
129840: LD_ADDR_VAR 0 2
129844: PUSH
129845: LD_VAR 0 2
129849: PUSH
129850: LD_VAR 0 7
129854: DIFF
129855: ST_TO_ADDR
129856: GO 129870
// SetTag ( i , 18 ) ;
129858: LD_VAR 0 7
129862: PPUSH
129863: LD_INT 18
129865: PPUSH
129866: CALL_OW 109
129870: GO 129810
129872: POP
129873: POP
// if not solds then
129874: LD_VAR 0 2
129878: NOT
129879: IFFALSE 129883
// exit ;
129881: GO 130329
// repeat wait ( 0 0$2 ) ;
129883: LD_INT 70
129885: PPUSH
129886: CALL_OW 67
// enemy := mc_scan [ base ] ;
129890: LD_ADDR_VAR 0 4
129894: PUSH
129895: LD_EXP 140
129899: PUSH
129900: LD_VAR 0 1
129904: ARRAY
129905: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
129906: LD_EXP 117
129910: PUSH
129911: LD_VAR 0 1
129915: ARRAY
129916: NOT
129917: PUSH
129918: LD_EXP 117
129922: PUSH
129923: LD_VAR 0 1
129927: ARRAY
129928: PUSH
129929: EMPTY
129930: EQUAL
129931: OR
129932: IFFALSE 129969
// begin for i in solds do
129934: LD_ADDR_VAR 0 7
129938: PUSH
129939: LD_VAR 0 2
129943: PUSH
129944: FOR_IN
129945: IFFALSE 129958
// ComStop ( i ) ;
129947: LD_VAR 0 7
129951: PPUSH
129952: CALL_OW 141
129956: GO 129944
129958: POP
129959: POP
// solds := [ ] ;
129960: LD_ADDR_VAR 0 2
129964: PUSH
129965: EMPTY
129966: ST_TO_ADDR
// exit ;
129967: GO 130329
// end ; for i in solds do
129969: LD_ADDR_VAR 0 7
129973: PUSH
129974: LD_VAR 0 2
129978: PUSH
129979: FOR_IN
129980: IFFALSE 130301
// begin if IsInUnit ( i ) then
129982: LD_VAR 0 7
129986: PPUSH
129987: CALL_OW 310
129991: IFFALSE 130002
// ComExitBuilding ( i ) ;
129993: LD_VAR 0 7
129997: PPUSH
129998: CALL_OW 122
// if GetLives ( i ) > 500 then
130002: LD_VAR 0 7
130006: PPUSH
130007: CALL_OW 256
130011: PUSH
130012: LD_INT 500
130014: GREATER
130015: IFFALSE 130068
// begin e := NearestUnitToUnit ( enemy , i ) ;
130017: LD_ADDR_VAR 0 5
130021: PUSH
130022: LD_VAR 0 4
130026: PPUSH
130027: LD_VAR 0 7
130031: PPUSH
130032: CALL_OW 74
130036: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
130037: LD_VAR 0 7
130041: PPUSH
130042: LD_VAR 0 5
130046: PPUSH
130047: CALL_OW 250
130051: PPUSH
130052: LD_VAR 0 5
130056: PPUSH
130057: CALL_OW 251
130061: PPUSH
130062: CALL_OW 114
// end else
130066: GO 130299
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
130068: LD_VAR 0 7
130072: PPUSH
130073: LD_EXP 117
130077: PUSH
130078: LD_VAR 0 1
130082: ARRAY
130083: PPUSH
130084: LD_INT 2
130086: PUSH
130087: LD_INT 30
130089: PUSH
130090: LD_INT 0
130092: PUSH
130093: EMPTY
130094: LIST
130095: LIST
130096: PUSH
130097: LD_INT 30
130099: PUSH
130100: LD_INT 1
130102: PUSH
130103: EMPTY
130104: LIST
130105: LIST
130106: PUSH
130107: LD_INT 30
130109: PUSH
130110: LD_INT 6
130112: PUSH
130113: EMPTY
130114: LIST
130115: LIST
130116: PUSH
130117: EMPTY
130118: LIST
130119: LIST
130120: LIST
130121: LIST
130122: PPUSH
130123: CALL_OW 72
130127: PPUSH
130128: LD_VAR 0 7
130132: PPUSH
130133: CALL_OW 74
130137: PPUSH
130138: CALL_OW 296
130142: PUSH
130143: LD_INT 10
130145: GREATER
130146: IFFALSE 130299
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
130148: LD_ADDR_VAR 0 8
130152: PUSH
130153: LD_EXP 117
130157: PUSH
130158: LD_VAR 0 1
130162: ARRAY
130163: PPUSH
130164: LD_INT 2
130166: PUSH
130167: LD_INT 30
130169: PUSH
130170: LD_INT 0
130172: PUSH
130173: EMPTY
130174: LIST
130175: LIST
130176: PUSH
130177: LD_INT 30
130179: PUSH
130180: LD_INT 1
130182: PUSH
130183: EMPTY
130184: LIST
130185: LIST
130186: PUSH
130187: LD_INT 30
130189: PUSH
130190: LD_INT 6
130192: PUSH
130193: EMPTY
130194: LIST
130195: LIST
130196: PUSH
130197: EMPTY
130198: LIST
130199: LIST
130200: LIST
130201: LIST
130202: PPUSH
130203: CALL_OW 72
130207: PPUSH
130208: LD_VAR 0 7
130212: PPUSH
130213: CALL_OW 74
130217: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
130218: LD_VAR 0 7
130222: PPUSH
130223: LD_VAR 0 8
130227: PPUSH
130228: CALL_OW 250
130232: PPUSH
130233: LD_INT 3
130235: PPUSH
130236: LD_INT 5
130238: PPUSH
130239: CALL_OW 272
130243: PPUSH
130244: LD_VAR 0 8
130248: PPUSH
130249: CALL_OW 251
130253: PPUSH
130254: LD_INT 3
130256: PPUSH
130257: LD_INT 5
130259: PPUSH
130260: CALL_OW 273
130264: PPUSH
130265: CALL_OW 111
// SetTag ( i , 0 ) ;
130269: LD_VAR 0 7
130273: PPUSH
130274: LD_INT 0
130276: PPUSH
130277: CALL_OW 109
// solds := solds diff i ;
130281: LD_ADDR_VAR 0 2
130285: PUSH
130286: LD_VAR 0 2
130290: PUSH
130291: LD_VAR 0 7
130295: DIFF
130296: ST_TO_ADDR
// continue ;
130297: GO 129979
// end ; end ;
130299: GO 129979
130301: POP
130302: POP
// until not solds or not enemy ;
130303: LD_VAR 0 2
130307: NOT
130308: PUSH
130309: LD_VAR 0 4
130313: NOT
130314: OR
130315: IFFALSE 129883
// MC_Reset ( base , 18 ) ;
130317: LD_VAR 0 1
130321: PPUSH
130322: LD_INT 18
130324: PPUSH
130325: CALL 39444 0 2
// end ;
130329: LD_VAR 0 3
130333: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
130334: LD_INT 0
130336: PPUSH
130337: PPUSH
130338: PPUSH
130339: PPUSH
130340: PPUSH
130341: PPUSH
130342: PPUSH
130343: PPUSH
130344: PPUSH
130345: PPUSH
130346: PPUSH
130347: PPUSH
130348: PPUSH
130349: PPUSH
130350: PPUSH
130351: PPUSH
130352: PPUSH
130353: PPUSH
130354: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
130355: LD_ADDR_VAR 0 12
130359: PUSH
130360: LD_EXP 117
130364: PUSH
130365: LD_VAR 0 1
130369: ARRAY
130370: PPUSH
130371: LD_INT 25
130373: PUSH
130374: LD_INT 3
130376: PUSH
130377: EMPTY
130378: LIST
130379: LIST
130380: PPUSH
130381: CALL_OW 72
130385: ST_TO_ADDR
// if mc_remote_driver [ base ] then
130386: LD_EXP 157
130390: PUSH
130391: LD_VAR 0 1
130395: ARRAY
130396: IFFALSE 130420
// mechs := mechs diff mc_remote_driver [ base ] ;
130398: LD_ADDR_VAR 0 12
130402: PUSH
130403: LD_VAR 0 12
130407: PUSH
130408: LD_EXP 157
130412: PUSH
130413: LD_VAR 0 1
130417: ARRAY
130418: DIFF
130419: ST_TO_ADDR
// for i in mechs do
130420: LD_ADDR_VAR 0 4
130424: PUSH
130425: LD_VAR 0 12
130429: PUSH
130430: FOR_IN
130431: IFFALSE 130466
// if GetTag ( i ) > 0 then
130433: LD_VAR 0 4
130437: PPUSH
130438: CALL_OW 110
130442: PUSH
130443: LD_INT 0
130445: GREATER
130446: IFFALSE 130464
// mechs := mechs diff i ;
130448: LD_ADDR_VAR 0 12
130452: PUSH
130453: LD_VAR 0 12
130457: PUSH
130458: LD_VAR 0 4
130462: DIFF
130463: ST_TO_ADDR
130464: GO 130430
130466: POP
130467: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
130468: LD_ADDR_VAR 0 8
130472: PUSH
130473: LD_EXP 117
130477: PUSH
130478: LD_VAR 0 1
130482: ARRAY
130483: PPUSH
130484: LD_INT 2
130486: PUSH
130487: LD_INT 25
130489: PUSH
130490: LD_INT 1
130492: PUSH
130493: EMPTY
130494: LIST
130495: LIST
130496: PUSH
130497: LD_INT 25
130499: PUSH
130500: LD_INT 5
130502: PUSH
130503: EMPTY
130504: LIST
130505: LIST
130506: PUSH
130507: LD_INT 25
130509: PUSH
130510: LD_INT 8
130512: PUSH
130513: EMPTY
130514: LIST
130515: LIST
130516: PUSH
130517: LD_INT 25
130519: PUSH
130520: LD_INT 9
130522: PUSH
130523: EMPTY
130524: LIST
130525: LIST
130526: PUSH
130527: EMPTY
130528: LIST
130529: LIST
130530: LIST
130531: LIST
130532: LIST
130533: PPUSH
130534: CALL_OW 72
130538: ST_TO_ADDR
// if not defenders and not solds then
130539: LD_VAR 0 2
130543: NOT
130544: PUSH
130545: LD_VAR 0 8
130549: NOT
130550: AND
130551: IFFALSE 130555
// exit ;
130553: GO 132325
// depot_under_attack := false ;
130555: LD_ADDR_VAR 0 16
130559: PUSH
130560: LD_INT 0
130562: ST_TO_ADDR
// sold_defenders := [ ] ;
130563: LD_ADDR_VAR 0 17
130567: PUSH
130568: EMPTY
130569: ST_TO_ADDR
// if mechs then
130570: LD_VAR 0 12
130574: IFFALSE 130727
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
130576: LD_ADDR_VAR 0 4
130580: PUSH
130581: LD_VAR 0 2
130585: PPUSH
130586: LD_INT 21
130588: PUSH
130589: LD_INT 2
130591: PUSH
130592: EMPTY
130593: LIST
130594: LIST
130595: PPUSH
130596: CALL_OW 72
130600: PUSH
130601: FOR_IN
130602: IFFALSE 130725
// begin if GetTag ( i ) <> 20 then
130604: LD_VAR 0 4
130608: PPUSH
130609: CALL_OW 110
130613: PUSH
130614: LD_INT 20
130616: NONEQUAL
130617: IFFALSE 130631
// SetTag ( i , 20 ) ;
130619: LD_VAR 0 4
130623: PPUSH
130624: LD_INT 20
130626: PPUSH
130627: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
130631: LD_VAR 0 4
130635: PPUSH
130636: CALL_OW 263
130640: PUSH
130641: LD_INT 1
130643: EQUAL
130644: PUSH
130645: LD_VAR 0 4
130649: PPUSH
130650: CALL_OW 311
130654: NOT
130655: AND
130656: IFFALSE 130723
// begin un := mechs [ 1 ] ;
130658: LD_ADDR_VAR 0 10
130662: PUSH
130663: LD_VAR 0 12
130667: PUSH
130668: LD_INT 1
130670: ARRAY
130671: ST_TO_ADDR
// ComExit ( un ) ;
130672: LD_VAR 0 10
130676: PPUSH
130677: CALL 102985 0 1
// AddComEnterUnit ( un , i ) ;
130681: LD_VAR 0 10
130685: PPUSH
130686: LD_VAR 0 4
130690: PPUSH
130691: CALL_OW 180
// SetTag ( un , 19 ) ;
130695: LD_VAR 0 10
130699: PPUSH
130700: LD_INT 19
130702: PPUSH
130703: CALL_OW 109
// mechs := mechs diff un ;
130707: LD_ADDR_VAR 0 12
130711: PUSH
130712: LD_VAR 0 12
130716: PUSH
130717: LD_VAR 0 10
130721: DIFF
130722: ST_TO_ADDR
// end ; end ;
130723: GO 130601
130725: POP
130726: POP
// if solds then
130727: LD_VAR 0 8
130731: IFFALSE 130790
// for i in solds do
130733: LD_ADDR_VAR 0 4
130737: PUSH
130738: LD_VAR 0 8
130742: PUSH
130743: FOR_IN
130744: IFFALSE 130788
// if not GetTag ( i ) then
130746: LD_VAR 0 4
130750: PPUSH
130751: CALL_OW 110
130755: NOT
130756: IFFALSE 130786
// begin defenders := defenders union i ;
130758: LD_ADDR_VAR 0 2
130762: PUSH
130763: LD_VAR 0 2
130767: PUSH
130768: LD_VAR 0 4
130772: UNION
130773: ST_TO_ADDR
// SetTag ( i , 18 ) ;
130774: LD_VAR 0 4
130778: PPUSH
130779: LD_INT 18
130781: PPUSH
130782: CALL_OW 109
// end ;
130786: GO 130743
130788: POP
130789: POP
// repeat wait ( 0 0$2 ) ;
130790: LD_INT 70
130792: PPUSH
130793: CALL_OW 67
// enemy := mc_scan [ base ] ;
130797: LD_ADDR_VAR 0 21
130801: PUSH
130802: LD_EXP 140
130806: PUSH
130807: LD_VAR 0 1
130811: ARRAY
130812: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
130813: LD_EXP 117
130817: PUSH
130818: LD_VAR 0 1
130822: ARRAY
130823: NOT
130824: PUSH
130825: LD_EXP 117
130829: PUSH
130830: LD_VAR 0 1
130834: ARRAY
130835: PUSH
130836: EMPTY
130837: EQUAL
130838: OR
130839: IFFALSE 130876
// begin for i in defenders do
130841: LD_ADDR_VAR 0 4
130845: PUSH
130846: LD_VAR 0 2
130850: PUSH
130851: FOR_IN
130852: IFFALSE 130865
// ComStop ( i ) ;
130854: LD_VAR 0 4
130858: PPUSH
130859: CALL_OW 141
130863: GO 130851
130865: POP
130866: POP
// defenders := [ ] ;
130867: LD_ADDR_VAR 0 2
130871: PUSH
130872: EMPTY
130873: ST_TO_ADDR
// exit ;
130874: GO 132325
// end ; for i in defenders do
130876: LD_ADDR_VAR 0 4
130880: PUSH
130881: LD_VAR 0 2
130885: PUSH
130886: FOR_IN
130887: IFFALSE 131785
// begin e := NearestUnitToUnit ( enemy , i ) ;
130889: LD_ADDR_VAR 0 13
130893: PUSH
130894: LD_VAR 0 21
130898: PPUSH
130899: LD_VAR 0 4
130903: PPUSH
130904: CALL_OW 74
130908: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
130909: LD_ADDR_VAR 0 7
130913: PUSH
130914: LD_EXP 117
130918: PUSH
130919: LD_VAR 0 1
130923: ARRAY
130924: PPUSH
130925: LD_INT 2
130927: PUSH
130928: LD_INT 30
130930: PUSH
130931: LD_INT 0
130933: PUSH
130934: EMPTY
130935: LIST
130936: LIST
130937: PUSH
130938: LD_INT 30
130940: PUSH
130941: LD_INT 1
130943: PUSH
130944: EMPTY
130945: LIST
130946: LIST
130947: PUSH
130948: EMPTY
130949: LIST
130950: LIST
130951: LIST
130952: PPUSH
130953: CALL_OW 72
130957: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
130958: LD_ADDR_VAR 0 16
130962: PUSH
130963: LD_VAR 0 7
130967: NOT
130968: PUSH
130969: LD_VAR 0 7
130973: PPUSH
130974: LD_INT 3
130976: PUSH
130977: LD_INT 24
130979: PUSH
130980: LD_INT 600
130982: PUSH
130983: EMPTY
130984: LIST
130985: LIST
130986: PUSH
130987: EMPTY
130988: LIST
130989: LIST
130990: PPUSH
130991: CALL_OW 72
130995: OR
130996: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
130997: LD_VAR 0 4
131001: PPUSH
131002: CALL_OW 247
131006: PUSH
131007: LD_INT 2
131009: DOUBLE
131010: EQUAL
131011: IFTRUE 131015
131013: GO 131411
131015: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
131016: LD_VAR 0 4
131020: PPUSH
131021: CALL_OW 256
131025: PUSH
131026: LD_INT 1000
131028: EQUAL
131029: PUSH
131030: LD_VAR 0 4
131034: PPUSH
131035: LD_VAR 0 13
131039: PPUSH
131040: CALL_OW 296
131044: PUSH
131045: LD_INT 40
131047: LESS
131048: PUSH
131049: LD_VAR 0 13
131053: PPUSH
131054: LD_EXP 142
131058: PUSH
131059: LD_VAR 0 1
131063: ARRAY
131064: PPUSH
131065: CALL_OW 308
131069: OR
131070: AND
131071: IFFALSE 131193
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
131073: LD_VAR 0 4
131077: PPUSH
131078: CALL_OW 262
131082: PUSH
131083: LD_INT 1
131085: EQUAL
131086: PUSH
131087: LD_VAR 0 4
131091: PPUSH
131092: CALL_OW 261
131096: PUSH
131097: LD_INT 30
131099: LESS
131100: AND
131101: PUSH
131102: LD_VAR 0 7
131106: AND
131107: IFFALSE 131177
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
131109: LD_VAR 0 4
131113: PPUSH
131114: LD_VAR 0 7
131118: PPUSH
131119: LD_VAR 0 4
131123: PPUSH
131124: CALL_OW 74
131128: PPUSH
131129: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
131133: LD_VAR 0 4
131137: PPUSH
131138: LD_VAR 0 7
131142: PPUSH
131143: LD_VAR 0 4
131147: PPUSH
131148: CALL_OW 74
131152: PPUSH
131153: CALL_OW 296
131157: PUSH
131158: LD_INT 6
131160: LESS
131161: IFFALSE 131175
// SetFuel ( i , 100 ) ;
131163: LD_VAR 0 4
131167: PPUSH
131168: LD_INT 100
131170: PPUSH
131171: CALL_OW 240
// end else
131175: GO 131191
// ComAttackUnit ( i , e ) ;
131177: LD_VAR 0 4
131181: PPUSH
131182: LD_VAR 0 13
131186: PPUSH
131187: CALL_OW 115
// end else
131191: GO 131294
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
131193: LD_VAR 0 13
131197: PPUSH
131198: LD_EXP 142
131202: PUSH
131203: LD_VAR 0 1
131207: ARRAY
131208: PPUSH
131209: CALL_OW 308
131213: NOT
131214: PUSH
131215: LD_VAR 0 4
131219: PPUSH
131220: LD_VAR 0 13
131224: PPUSH
131225: CALL_OW 296
131229: PUSH
131230: LD_INT 40
131232: GREATEREQUAL
131233: AND
131234: PUSH
131235: LD_VAR 0 4
131239: PPUSH
131240: CALL_OW 256
131244: PUSH
131245: LD_INT 650
131247: LESSEQUAL
131248: OR
131249: PUSH
131250: LD_VAR 0 4
131254: PPUSH
131255: LD_EXP 141
131259: PUSH
131260: LD_VAR 0 1
131264: ARRAY
131265: PPUSH
131266: CALL_OW 308
131270: NOT
131271: AND
131272: IFFALSE 131294
// ComMoveToArea ( i , mc_parking [ base ] ) ;
131274: LD_VAR 0 4
131278: PPUSH
131279: LD_EXP 141
131283: PUSH
131284: LD_VAR 0 1
131288: ARRAY
131289: PPUSH
131290: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
131294: LD_VAR 0 4
131298: PPUSH
131299: CALL_OW 256
131303: PUSH
131304: LD_INT 1000
131306: LESS
131307: PUSH
131308: LD_VAR 0 4
131312: PPUSH
131313: CALL_OW 263
131317: PUSH
131318: LD_INT 1
131320: EQUAL
131321: AND
131322: PUSH
131323: LD_VAR 0 4
131327: PPUSH
131328: CALL_OW 311
131332: AND
131333: PUSH
131334: LD_VAR 0 4
131338: PPUSH
131339: LD_EXP 141
131343: PUSH
131344: LD_VAR 0 1
131348: ARRAY
131349: PPUSH
131350: CALL_OW 308
131354: AND
131355: IFFALSE 131409
// begin mech := IsDrivenBy ( i ) ;
131357: LD_ADDR_VAR 0 9
131361: PUSH
131362: LD_VAR 0 4
131366: PPUSH
131367: CALL_OW 311
131371: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
131372: LD_VAR 0 9
131376: PPUSH
131377: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
131381: LD_VAR 0 9
131385: PPUSH
131386: LD_VAR 0 4
131390: PPUSH
131391: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
131395: LD_VAR 0 9
131399: PPUSH
131400: LD_VAR 0 4
131404: PPUSH
131405: CALL_OW 180
// end ; end ; unit_human :
131409: GO 131756
131411: LD_INT 1
131413: DOUBLE
131414: EQUAL
131415: IFTRUE 131419
131417: GO 131755
131419: POP
// begin b := IsInUnit ( i ) ;
131420: LD_ADDR_VAR 0 18
131424: PUSH
131425: LD_VAR 0 4
131429: PPUSH
131430: CALL_OW 310
131434: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
131435: LD_ADDR_VAR 0 19
131439: PUSH
131440: LD_VAR 0 18
131444: NOT
131445: PUSH
131446: LD_VAR 0 18
131450: PPUSH
131451: CALL_OW 266
131455: PUSH
131456: LD_INT 32
131458: PUSH
131459: LD_INT 31
131461: PUSH
131462: EMPTY
131463: LIST
131464: LIST
131465: IN
131466: OR
131467: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
131468: LD_VAR 0 18
131472: PPUSH
131473: CALL_OW 266
131477: PUSH
131478: LD_INT 5
131480: EQUAL
131481: PUSH
131482: LD_VAR 0 4
131486: PPUSH
131487: CALL_OW 257
131491: PUSH
131492: LD_INT 1
131494: PUSH
131495: LD_INT 2
131497: PUSH
131498: LD_INT 3
131500: PUSH
131501: LD_INT 4
131503: PUSH
131504: EMPTY
131505: LIST
131506: LIST
131507: LIST
131508: LIST
131509: IN
131510: AND
131511: IFFALSE 131548
// begin class := AllowSpecClass ( i ) ;
131513: LD_ADDR_VAR 0 20
131517: PUSH
131518: LD_VAR 0 4
131522: PPUSH
131523: CALL 67702 0 1
131527: ST_TO_ADDR
// if class then
131528: LD_VAR 0 20
131532: IFFALSE 131548
// ComChangeProfession ( i , class ) ;
131534: LD_VAR 0 4
131538: PPUSH
131539: LD_VAR 0 20
131543: PPUSH
131544: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
131548: LD_VAR 0 16
131552: PUSH
131553: LD_VAR 0 2
131557: PPUSH
131558: LD_INT 21
131560: PUSH
131561: LD_INT 2
131563: PUSH
131564: EMPTY
131565: LIST
131566: LIST
131567: PPUSH
131568: CALL_OW 72
131572: PUSH
131573: LD_INT 1
131575: LESSEQUAL
131576: OR
131577: PUSH
131578: LD_VAR 0 19
131582: AND
131583: PUSH
131584: LD_VAR 0 4
131588: PUSH
131589: LD_VAR 0 17
131593: IN
131594: NOT
131595: AND
131596: IFFALSE 131689
// begin if b then
131598: LD_VAR 0 18
131602: IFFALSE 131651
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
131604: LD_VAR 0 18
131608: PPUSH
131609: LD_VAR 0 21
131613: PPUSH
131614: LD_VAR 0 18
131618: PPUSH
131619: CALL_OW 74
131623: PPUSH
131624: CALL_OW 296
131628: PUSH
131629: LD_INT 10
131631: LESS
131632: PUSH
131633: LD_VAR 0 18
131637: PPUSH
131638: CALL_OW 461
131642: PUSH
131643: LD_INT 7
131645: NONEQUAL
131646: AND
131647: IFFALSE 131651
// continue ;
131649: GO 130886
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
131651: LD_ADDR_VAR 0 17
131655: PUSH
131656: LD_VAR 0 17
131660: PPUSH
131661: LD_VAR 0 17
131665: PUSH
131666: LD_INT 1
131668: PLUS
131669: PPUSH
131670: LD_VAR 0 4
131674: PPUSH
131675: CALL_OW 1
131679: ST_TO_ADDR
// ComExitBuilding ( i ) ;
131680: LD_VAR 0 4
131684: PPUSH
131685: CALL_OW 122
// end ; if sold_defenders then
131689: LD_VAR 0 17
131693: IFFALSE 131753
// if i in sold_defenders then
131695: LD_VAR 0 4
131699: PUSH
131700: LD_VAR 0 17
131704: IN
131705: IFFALSE 131753
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
131707: LD_VAR 0 4
131711: PPUSH
131712: CALL_OW 314
131716: NOT
131717: PUSH
131718: LD_VAR 0 4
131722: PPUSH
131723: LD_VAR 0 13
131727: PPUSH
131728: CALL_OW 296
131732: PUSH
131733: LD_INT 30
131735: LESS
131736: AND
131737: IFFALSE 131753
// ComAttackUnit ( i , e ) ;
131739: LD_VAR 0 4
131743: PPUSH
131744: LD_VAR 0 13
131748: PPUSH
131749: CALL_OW 115
// end ; end ; end ;
131753: GO 131756
131755: POP
// if IsDead ( i ) then
131756: LD_VAR 0 4
131760: PPUSH
131761: CALL_OW 301
131765: IFFALSE 131783
// defenders := defenders diff i ;
131767: LD_ADDR_VAR 0 2
131771: PUSH
131772: LD_VAR 0 2
131776: PUSH
131777: LD_VAR 0 4
131781: DIFF
131782: ST_TO_ADDR
// end ;
131783: GO 130886
131785: POP
131786: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
131787: LD_VAR 0 21
131791: NOT
131792: PUSH
131793: LD_VAR 0 2
131797: NOT
131798: OR
131799: PUSH
131800: LD_EXP 117
131804: PUSH
131805: LD_VAR 0 1
131809: ARRAY
131810: NOT
131811: OR
131812: IFFALSE 130790
// MC_Reset ( base , 18 ) ;
131814: LD_VAR 0 1
131818: PPUSH
131819: LD_INT 18
131821: PPUSH
131822: CALL 39444 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
131826: LD_ADDR_VAR 0 2
131830: PUSH
131831: LD_VAR 0 2
131835: PUSH
131836: LD_VAR 0 2
131840: PPUSH
131841: LD_INT 2
131843: PUSH
131844: LD_INT 25
131846: PUSH
131847: LD_INT 1
131849: PUSH
131850: EMPTY
131851: LIST
131852: LIST
131853: PUSH
131854: LD_INT 25
131856: PUSH
131857: LD_INT 5
131859: PUSH
131860: EMPTY
131861: LIST
131862: LIST
131863: PUSH
131864: LD_INT 25
131866: PUSH
131867: LD_INT 8
131869: PUSH
131870: EMPTY
131871: LIST
131872: LIST
131873: PUSH
131874: LD_INT 25
131876: PUSH
131877: LD_INT 9
131879: PUSH
131880: EMPTY
131881: LIST
131882: LIST
131883: PUSH
131884: EMPTY
131885: LIST
131886: LIST
131887: LIST
131888: LIST
131889: LIST
131890: PPUSH
131891: CALL_OW 72
131895: DIFF
131896: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
131897: LD_VAR 0 21
131901: NOT
131902: PUSH
131903: LD_VAR 0 2
131907: PPUSH
131908: LD_INT 21
131910: PUSH
131911: LD_INT 2
131913: PUSH
131914: EMPTY
131915: LIST
131916: LIST
131917: PPUSH
131918: CALL_OW 72
131922: AND
131923: IFFALSE 132261
// begin tmp := FilterByTag ( defenders , 19 ) ;
131925: LD_ADDR_VAR 0 11
131929: PUSH
131930: LD_VAR 0 2
131934: PPUSH
131935: LD_INT 19
131937: PPUSH
131938: CALL 100171 0 2
131942: ST_TO_ADDR
// if tmp then
131943: LD_VAR 0 11
131947: IFFALSE 132017
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
131949: LD_ADDR_VAR 0 11
131953: PUSH
131954: LD_VAR 0 11
131958: PPUSH
131959: LD_INT 25
131961: PUSH
131962: LD_INT 3
131964: PUSH
131965: EMPTY
131966: LIST
131967: LIST
131968: PPUSH
131969: CALL_OW 72
131973: ST_TO_ADDR
// if tmp then
131974: LD_VAR 0 11
131978: IFFALSE 132017
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
131980: LD_ADDR_EXP 129
131984: PUSH
131985: LD_EXP 129
131989: PPUSH
131990: LD_VAR 0 1
131994: PPUSH
131995: LD_EXP 129
131999: PUSH
132000: LD_VAR 0 1
132004: ARRAY
132005: PUSH
132006: LD_VAR 0 11
132010: UNION
132011: PPUSH
132012: CALL_OW 1
132016: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
132017: LD_VAR 0 1
132021: PPUSH
132022: LD_INT 19
132024: PPUSH
132025: CALL 39444 0 2
// repeat wait ( 0 0$1 ) ;
132029: LD_INT 35
132031: PPUSH
132032: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
132036: LD_EXP 117
132040: PUSH
132041: LD_VAR 0 1
132045: ARRAY
132046: NOT
132047: PUSH
132048: LD_EXP 117
132052: PUSH
132053: LD_VAR 0 1
132057: ARRAY
132058: PUSH
132059: EMPTY
132060: EQUAL
132061: OR
132062: IFFALSE 132099
// begin for i in defenders do
132064: LD_ADDR_VAR 0 4
132068: PUSH
132069: LD_VAR 0 2
132073: PUSH
132074: FOR_IN
132075: IFFALSE 132088
// ComStop ( i ) ;
132077: LD_VAR 0 4
132081: PPUSH
132082: CALL_OW 141
132086: GO 132074
132088: POP
132089: POP
// defenders := [ ] ;
132090: LD_ADDR_VAR 0 2
132094: PUSH
132095: EMPTY
132096: ST_TO_ADDR
// exit ;
132097: GO 132325
// end ; for i in defenders do
132099: LD_ADDR_VAR 0 4
132103: PUSH
132104: LD_VAR 0 2
132108: PUSH
132109: FOR_IN
132110: IFFALSE 132199
// begin if not IsInArea ( i , mc_parking [ base ] ) then
132112: LD_VAR 0 4
132116: PPUSH
132117: LD_EXP 141
132121: PUSH
132122: LD_VAR 0 1
132126: ARRAY
132127: PPUSH
132128: CALL_OW 308
132132: NOT
132133: IFFALSE 132157
// ComMoveToArea ( i , mc_parking [ base ] ) else
132135: LD_VAR 0 4
132139: PPUSH
132140: LD_EXP 141
132144: PUSH
132145: LD_VAR 0 1
132149: ARRAY
132150: PPUSH
132151: CALL_OW 113
132155: GO 132197
// if GetControl ( i ) = control_manual then
132157: LD_VAR 0 4
132161: PPUSH
132162: CALL_OW 263
132166: PUSH
132167: LD_INT 1
132169: EQUAL
132170: IFFALSE 132197
// if IsDrivenBy ( i ) then
132172: LD_VAR 0 4
132176: PPUSH
132177: CALL_OW 311
132181: IFFALSE 132197
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
132183: LD_VAR 0 4
132187: PPUSH
132188: CALL_OW 311
132192: PPUSH
132193: CALL_OW 121
// end ;
132197: GO 132109
132199: POP
132200: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
132201: LD_VAR 0 2
132205: PPUSH
132206: LD_INT 95
132208: PUSH
132209: LD_EXP 141
132213: PUSH
132214: LD_VAR 0 1
132218: ARRAY
132219: PUSH
132220: EMPTY
132221: LIST
132222: LIST
132223: PPUSH
132224: CALL_OW 72
132228: PUSH
132229: LD_VAR 0 2
132233: EQUAL
132234: PUSH
132235: LD_EXP 140
132239: PUSH
132240: LD_VAR 0 1
132244: ARRAY
132245: OR
132246: PUSH
132247: LD_EXP 117
132251: PUSH
132252: LD_VAR 0 1
132256: ARRAY
132257: NOT
132258: OR
132259: IFFALSE 132029
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
132261: LD_ADDR_EXP 139
132265: PUSH
132266: LD_EXP 139
132270: PPUSH
132271: LD_VAR 0 1
132275: PPUSH
132276: LD_VAR 0 2
132280: PPUSH
132281: LD_INT 21
132283: PUSH
132284: LD_INT 2
132286: PUSH
132287: EMPTY
132288: LIST
132289: LIST
132290: PPUSH
132291: CALL_OW 72
132295: PPUSH
132296: CALL_OW 1
132300: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
132301: LD_VAR 0 1
132305: PPUSH
132306: LD_INT 19
132308: PPUSH
132309: CALL 39444 0 2
// MC_Reset ( base , 20 ) ;
132313: LD_VAR 0 1
132317: PPUSH
132318: LD_INT 20
132320: PPUSH
132321: CALL 39444 0 2
// end ; end_of_file
132325: LD_VAR 0 3
132329: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
132330: LD_VAR 0 1
132334: PUSH
132335: LD_INT 200
132337: DOUBLE
132338: GREATEREQUAL
132339: IFFALSE 132347
132341: LD_INT 299
132343: DOUBLE
132344: LESSEQUAL
132345: IFTRUE 132349
132347: GO 132381
132349: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
132350: LD_VAR 0 1
132354: PPUSH
132355: LD_VAR 0 2
132359: PPUSH
132360: LD_VAR 0 3
132364: PPUSH
132365: LD_VAR 0 4
132369: PPUSH
132370: LD_VAR 0 5
132374: PPUSH
132375: CALL 120767 0 5
132379: GO 132458
132381: LD_INT 300
132383: DOUBLE
132384: GREATEREQUAL
132385: IFFALSE 132393
132387: LD_INT 399
132389: DOUBLE
132390: LESSEQUAL
132391: IFTRUE 132395
132393: GO 132457
132395: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
132396: LD_VAR 0 1
132400: PPUSH
132401: LD_VAR 0 2
132405: PPUSH
132406: LD_VAR 0 3
132410: PPUSH
132411: LD_VAR 0 4
132415: PPUSH
132416: LD_VAR 0 5
132420: PPUSH
132421: LD_VAR 0 6
132425: PPUSH
132426: LD_VAR 0 7
132430: PPUSH
132431: LD_VAR 0 8
132435: PPUSH
132436: LD_VAR 0 9
132440: PPUSH
132441: LD_VAR 0 10
132445: PPUSH
132446: LD_VAR 0 11
132450: PPUSH
132451: CALL 118409 0 11
132455: GO 132458
132457: POP
// end ;
132458: PPOPN 11
132460: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
132461: LD_VAR 0 1
132465: PPUSH
132466: LD_VAR 0 2
132470: PPUSH
132471: LD_VAR 0 3
132475: PPUSH
132476: LD_VAR 0 4
132480: PPUSH
132481: LD_VAR 0 5
132485: PPUSH
132486: CALL 120503 0 5
// end ; end_of_file
132490: PPOPN 5
132492: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
132493: LD_VAR 0 1
132497: PPUSH
132498: LD_VAR 0 2
132502: PPUSH
132503: LD_VAR 0 3
132507: PPUSH
132508: LD_VAR 0 4
132512: PPUSH
132513: LD_VAR 0 5
132517: PPUSH
132518: LD_VAR 0 6
132522: PPUSH
132523: CALL 106102 0 6
// end ;
132527: PPOPN 6
132529: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
132530: CALL 106077 0 0
// end ;
132534: PPOPN 1
132536: END
